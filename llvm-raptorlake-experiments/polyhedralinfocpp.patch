--- a/polly/lib/Analysis/PolyhedralInfo.cpp	2025-09-21 15:19:47.774089816 +0200
+++ b/polly/lib/Analysis/PolyhedralInfo.cpp	2025-09-21 15:22:42.837583285 +0200
@@ -1,20 +1,9 @@
 //===--------- PolyhedralInfo.cpp  - Create Scops from LLVM IR-------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
-//===----------------------------------------------------------------------===//
-//
-// An interface to the Polyhedral analysis engine(Polly) of LLVM.
-//
-// This pass provides an interface to the polyhedral analysis performed by
-// Polly.
-//
-// This interface provides basic interface like isParallel, isVectorizable
-// that can be used in LLVM transformation passes.
-//
-// Work in progress, this file is subject to change.
+// Interface to Polly's polyhedral analysis.
 //
 //===----------------------------------------------------------------------===//
 
@@ -27,6 +16,7 @@
 #include "llvm/Analysis/LoopInfo.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/Debug.h"
+#include "isl/map.h"
 #include "isl/union_map.h"
 
 using namespace llvm;
@@ -61,23 +51,27 @@ void PolyhedralInfo::print(raw_ostream &
   for (auto *TopLevelLoop : LI) {
     for (auto *L : depth_first(TopLevelLoop)) {
       OS.indent(2) << L->getHeader()->getName() << ":\t";
-      if (CheckParallel && isParallel(L))
+      if (CheckParallel && isParallel(L)) {
         OS << "Loop is parallel.\n";
-      else if (CheckParallel)
+      } else if (CheckParallel) {
         OS << "Loop is not parallel.\n";
+      }
     }
   }
 }
 
 bool PolyhedralInfo::checkParallel(Loop *L, isl_pw_aff **MinDepDistPtr) const {
-  bool IsParallel;
   const Scop *S = getScopContainingLoop(L);
-  if (!S)
+  if (!S) {
     return false;
+  }
+
   const Dependences &D =
       DI->getDependences(const_cast<Scop *>(S), Dependences::AL_Access);
-  if (!D.hasValidDependences())
+  if (!D.hasValidDependences()) {
     return false;
+  }
+
   POLLY_DEBUG(dbgs() << "Loop :\t" << L->getHeader()->getName() << ":\n");
 
   isl_union_map *Deps =
@@ -92,36 +86,27 @@ bool PolyhedralInfo::checkParallel(Loop
   POLLY_DEBUG(dbgs() << "Schedule: \t" << stringFromIslObj(Schedule, "null")
                      << "\n");
 
-  IsParallel = D.isParallel(Schedule, Deps, MinDepDistPtr);
+  bool IsParallel = D.isParallel(Schedule, Deps, MinDepDistPtr);
   isl_union_map_free(Schedule);
   return IsParallel;
 }
 
-bool PolyhedralInfo::isParallel(Loop *L) const { return checkParallel(L); }
+bool PolyhedralInfo::isParallel(Loop *L) const {
+  return checkParallel(L, nullptr);
+}
 
 const Scop *PolyhedralInfo::getScopContainingLoop(Loop *L) const {
-  assert((SI) && "ScopInfoWrapperPass is required by PolyhedralInfo pass!\n");
+  assert(SI && "ScopInfoWrapperPass is required by PolyhedralInfo pass!");
   for (auto &It : *SI) {
     Region *R = It.first;
-    if (R->contains(L))
+    if (R->contains(L)) {
       return It.second.get();
+    }
   }
   return nullptr;
 }
 
-//  Given a Loop and the containing SCoP, we compute the partial schedule
-//  by taking union of individual schedules of each ScopStmt within the loop
-//  and projecting out the inner dimensions from the range of the schedule.
-//   for (i = 0; i < n; i++)
-//      for (j = 0; j < n; j++)
-//        A[j] = 1;  //Stmt
-//
-//  The original schedule will be
-//    Stmt[i0, i1] -> [i0, i1]
-//  The schedule for the outer loop will be
-//    Stmt[i0, i1] -> [i0]
-//  The schedule for the inner loop will be
-//    Stmt[i0, i1] -> [i0, i1]
+// Union of statement schedules at loop depth CurrDim, inner dims projected out.
 __isl_give isl_union_map *PolyhedralInfo::getScheduleForLoop(const Scop *S,
                                                              Loop *L) const {
   isl_union_map *Schedule = isl_union_map_empty(S->getParamSpace().release());
@@ -130,23 +115,29 @@ __isl_give isl_union_map *PolyhedralInfo
   assert(CurrDim >= 0 && "Loop in region should have at least depth one");
 
   for (auto &SS : *S) {
-    if (L->contains(SS.getSurroundingLoop())) {
+    if (!L->contains(SS.getSurroundingLoop())) {
+      continue;
+    }
+
+    unsigned MaxDim = SS.getNumIterators();
+    POLLY_DEBUG(dbgs() << "Maximum depth of Stmt:\t" << MaxDim << "\n");
 
-      unsigned int MaxDim = SS.getNumIterators();
-      POLLY_DEBUG(dbgs() << "Maximum depth of Stmt:\t" << MaxDim << "\n");
-      isl_map *ScheduleMap = SS.getSchedule().release();
-      assert(
-          ScheduleMap &&
-          "Schedules that contain extension nodes require special handling.");
-
-      ScheduleMap = isl_map_project_out(ScheduleMap, isl_dim_out, CurrDim + 1,
-                                        MaxDim - CurrDim - 1);
-      ScheduleMap = isl_map_set_tuple_id(ScheduleMap, isl_dim_in,
-                                         SS.getDomainId().release());
-      Schedule =
-          isl_union_map_union(Schedule, isl_union_map_from_map(ScheduleMap));
+    isl_map *ScheduleMap = SS.getSchedule().release();
+    assert(ScheduleMap &&
+           "Schedules that contain extension nodes require special handling.");
+
+    unsigned First = static_cast<unsigned>(CurrDim + 1);
+    unsigned N = (MaxDim > First) ? (MaxDim - First) : 0;
+    if (N > 0) {
+      ScheduleMap = isl_map_project_out(ScheduleMap, isl_dim_out, First, N);
     }
+
+    ScheduleMap = isl_map_set_tuple_id(ScheduleMap, isl_dim_in,
+                                       SS.getDomainId().release());
+    Schedule =
+        isl_union_map_union(Schedule, isl_union_map_from_map(ScheduleMap));
   }
+
   Schedule = isl_union_map_coalesce(Schedule);
   return Schedule;
 }
@@ -168,7 +159,6 @@ INITIALIZE_PASS_END(PolyhedralInfo, "pol
 //===----------------------------------------------------------------------===//
 
 namespace {
-/// Print result from PolyhedralInfo.
 class PolyhedralInfoPrinterLegacyPass final : public FunctionPass {
 public:
   static char ID;
