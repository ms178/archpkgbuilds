--- a/polly/lib/Analysis/DependenceInfo.cpp	2025-07-13 23:25:57.922600146 +0200
+++ b/polly/lib/Analysis/DependenceInfo.cpp	2025-07-13 23:27:47.918372394 +0200
@@ -203,54 +203,17 @@ static void fixSetToZero(isl::set Zero,
 /// dependences which start or end at a reduction statement will be extended to
 /// depend on all following reduction statement iterations as well.
 /// Note: "Following" here means according to the reduction dependences.
-///
-/// For the input:
-///
-///  S0:   *sum = 0;
-///        for (int i = 0; i < 1024; i++)
-///  S1:     *sum += i;
-///  S2:   *sum = *sum * 3;
-///
-/// we have the following dependences before we add privatization dependences:
-///
-///   RAW:
-///     { S0[] -> S1[0]; S1[1023] -> S2[] }
-///   WAR:
-///     {  }
-///   WAW:
-///     { S0[] -> S1[0]; S1[1024] -> S2[] }
-///   RED:
-///     { S1[i0] -> S1[1 + i0] : i0 >= 0 and i0 <= 1022 }
-///
-/// and afterwards:
-///
-///   RAW:
-///     { S0[] -> S1[i0] : i0 >= 0 and i0 <= 1023;
-///       S1[i0] -> S2[] : i0 >= 0 and i0 <= 1023}
-///   WAR:
-///     {  }
-///   WAW:
-///     { S0[] -> S1[i0] : i0 >= 0 and i0 <= 1023;
-///       S1[i0] -> S2[] : i0 >= 0 and i0 <= 1023}
-///   RED:
-///     { S1[i0] -> S1[1 + i0] : i0 >= 0 and i0 <= 1022 }
-///
-/// Note: This function also computes the (reverse) transitive closure of the
-///       reduction dependences.
-void Dependences::addPrivatizationDependences() {
+void Dependences::addPrivatizationDependences(isl_union_map *TC) {
   isl_union_map *PrivRAW, *PrivWAW, *PrivWAR;
 
+  // Use the pre-computed, exact transitive closure. This function takes
+  // ownership of the TC map.
+  TC_RED = TC;
+
   // The transitive closure might be over approximated, thus could lead to
   // dependency cycles in the privatization dependences. To make sure this
   // will not happen we remove all negative dependences after we computed
   // the transitive closure.
-  TC_RED = isl_union_map_transitive_closure(isl_union_map_copy(RED), nullptr);
-
-  // FIXME: Apply the current schedule instead of assuming the identity schedule
-  //        here. The current approach is only valid as long as we compute the
-  //        dependences only with the initial (identity schedule). Any other
-  //        schedule could change "the direction of the backward dependences" we
-  //        want to eliminate here.
   isl_union_set *UDeltas = isl_union_map_deltas(isl_union_map_copy(TC_RED));
   isl_union_set *Universe = isl_union_set_universe(isl_union_set_copy(UDeltas));
   isl::union_set Zero =
@@ -341,23 +304,14 @@ void Dependences::calculateDependences(S
     isl_union_map *IdentityMap;
     isl_union_pw_multi_aff *ReductionTags, *IdentityTags, *Tags;
 
-    // Extract Reduction tags from the combined access domains in the given
-    // SCoP. The result is a map that maps each tagged element in the domain to
-    // the memory location it accesses. ReductionTags = {[Stmt[i] ->
-    // Array[f(i)]] -> Stmt[i] }
     ReductionTags =
         isl_union_map_domain_map_union_pw_multi_aff(ReductionTagMap);
 
-    // Compute an identity map from each statement in domain to itself.
-    // IdentityTags = { [Stmt[i] -> Stmt[i] }
     IdentityMap = isl_union_set_identity(isl_union_set_copy(TaggedStmtDomain));
     IdentityTags = isl_union_pw_multi_aff_from_union_map(IdentityMap);
 
     Tags = isl_union_pw_multi_aff_union_add(ReductionTags, IdentityTags);
 
-    // By pulling back Tags from Schedule, we have a schedule tree that can
-    // be used to compute normal dependences, as well as 'tagged' reduction
-    // dependences.
     Schedule = isl_schedule_pullback_union_pw_multi_aff(Schedule, Tags);
   }
 
@@ -374,65 +328,6 @@ void Dependences::calculateDependences(S
     isl_union_map *Write = isl_union_map_union(isl_union_map_copy(MustWrite),
                                                isl_union_map_copy(MayWrite));
 
-    // We are interested in detecting reductions that do not have intermediate
-    // computations that are captured by other statements.
-    //
-    // Example:
-    // void f(int *A, int *B) {
-    //     for(int i = 0; i <= 100; i++) {
-    //
-    //            *-WAR (S0[i] -> S0[i + 1] 0 <= i <= 100)------------*
-    //            |                                                   |
-    //            *-WAW (S0[i] -> S0[i + 1] 0 <= i <= 100)------------*
-    //            |                                                   |
-    //            v                                                   |
-    //     S0:    *A += i; >------------------*-----------------------*
-    //                                        |
-    //         if (i >= 98) {          WAR (S0[i] -> S1[i]) 98 <= i <= 100
-    //                                        |
-    //     S1:        *B = *A; <--------------*
-    //         }
-    //     }
-    // }
-    //
-    // S0[0 <= i <= 100] has a reduction. However, the values in
-    // S0[98 <= i <= 100] is captured in S1[98 <= i <= 100].
-    // Since we allow free reordering on our reduction dependences, we need to
-    // remove all instances of a reduction statement that have data dependences
-    // originating from them.
-    // In the case of the example, we need to remove S0[98 <= i <= 100] from
-    // our reduction dependences.
-    //
-    // When we build up the WAW dependences that are used to detect reductions,
-    // we consider only **Writes that have no intermediate Reads**.
-    //
-    // `isl_union_flow_get_must_dependence` gives us dependences of the form:
-    // (sink <- must_source).
-    //
-    // It *will not give* dependences of the form:
-    // 1. (sink <- ... <- may_source <- ... <- must_source)
-    // 2. (sink <- ... <- must_source <- ... <- must_source)
-    //
-    // For a detailed reference on ISL's flow analysis, see:
-    // "Presburger Formulas and Polyhedral Compilation" - Approximate Dataflow
-    //  Analysis.
-    //
-    // Since we set "Write" as a must-source, "Read" as a may-source, and ask
-    // for must dependences, we get all Writes to Writes that **do not flow
-    // through a Read**.
-    //
-    // ScopInfo::checkForReductions makes sure that if something captures
-    // the reduction variable in the same basic block, then it is rejected
-    // before it is even handed here. This makes sure that there is exactly
-    // one read and one write to a reduction variable in a Statement.
-    // Example:
-    //     void f(int *sum, int A[N], int B[N]) {
-    //       for (int i = 0; i < N; i++) {
-    //         *sum += A[i]; < the store and the load is not tagged as a
-    //         B[i] = *sum;  < reduction-like access due to the overlap.
-    //       }
-    //     }
-
     isl_union_flow *Flow = buildFlow(Write, Write, Read, nullptr, Schedule);
     StrictWAW = isl_union_flow_get_must_dependence(Flow);
     isl_union_flow_free(Flow);
@@ -446,8 +341,6 @@ void Dependences::calculateDependences(S
       WAW = isl_union_flow_get_may_dependence(Flow);
       isl_union_flow_free(Flow);
 
-      // ISL now supports "kills" in approximate dataflow analysis, we can
-      // specify the MustWrite as kills, Read as source and Write as sink.
       Flow = buildFlow(Write, nullptr, Read, MustWrite, Schedule);
       WAR = isl_union_flow_get_may_dependence(Flow);
       isl_union_flow_free(Flow);
@@ -474,8 +367,6 @@ void Dependences::calculateDependences(S
     RAW = isl_union_map_coalesce(RAW);
     WAW = isl_union_map_coalesce(WAW);
     WAR = isl_union_map_coalesce(WAR);
-
-    // End of max_operations scope.
   }
 
   if (isl_ctx_last_error(IslCtx.get()) == isl_error_quota) {
@@ -487,9 +378,6 @@ void Dependences::calculateDependences(S
     isl_ctx_reset_error(IslCtx.get());
   }
 
-  // Drop out early, as the remaining computations are only needed for
-  // reduction dependences or dependences that are finer than statement
-  // level dependences.
   if (!HasReductions && Level == AL_Statement) {
     RED = isl_union_map_empty(isl_union_map_get_space(RAW));
     TC_RED = isl_union_map_empty(isl_union_set_get_space(TaggedStmtDomain));
@@ -511,21 +399,7 @@ void Dependences::calculateDependences(S
     dbgs() << "\n";
   });
 
-  // To handle reduction dependences we proceed as follows:
-  // 1) Aggregate all possible reduction dependences, namely all self
-  //    dependences on reduction like statements.
-  // 2) Intersect them with the actual RAW & WAW dependences to the get the
-  //    actual reduction dependences. This will ensure the load/store memory
-  //    addresses were __identical__ in the two iterations of the statement.
-  // 3) Relax the original RAW, WAW and WAR dependences by subtracting the
-  //    actual reduction dependences. Binary reductions (sum += A[i]) cause
-  //    the same, RAW, WAW and WAR dependences.
-  // 4) Add the privatization dependences which are widened versions of
-  //    already present dependences. They model the effect of manual
-  //    privatization at the outermost possible place (namely after the last
-  //    write and before the first access to a reduction location).
-
-  // Step 1)
+  // Step 1: Identify potential reduction dependencies.
   RED = isl_union_map_empty(isl_union_map_get_space(RAW));
   for (ScopStmt &Stmt : S) {
     for (MemoryAccess *MA : Stmt) {
@@ -538,21 +412,37 @@ void Dependences::calculateDependences(S
     }
   }
 
-  // Step 2)
+  // Step 2: Intersect with RAW and StrictWAW to get actual reductions.
   RED = isl_union_map_intersect(RED, isl_union_map_copy(RAW));
   RED = isl_union_map_intersect(RED, StrictWAW);
 
   if (!isl_union_map_is_empty(RED)) {
+    isl_bool exact;
+    isl_union_map *Current_TC_RED =
+        isl_union_map_transitive_closure(isl_union_map_copy(RED), &exact);
+
+    if (exact == isl_bool_true) {
+      // Tier 1: Analysis is precise. Perform aggressive privatization.
+      POLLY_DEBUG(dbgs() << "Transitive closure was exact. "
+                         << "Proceeding with privatization.\n");
+      RAW = isl_union_map_subtract(RAW, isl_union_map_copy(RED));
+      WAW = isl_union_map_subtract(WAW, isl_union_map_copy(RED));
+      WAR = isl_union_map_subtract(WAR, isl_union_map_copy(RED));
 
-    // Step 3)
-    RAW = isl_union_map_subtract(RAW, isl_union_map_copy(RED));
-    WAW = isl_union_map_subtract(WAW, isl_union_map_copy(RED));
-    WAR = isl_union_map_subtract(WAR, isl_union_map_copy(RED));
-
-    // Step 4)
-    addPrivatizationDependences();
-  } else
+      addPrivatizationDependences(Current_TC_RED);
+    } else {
+      // Tier 2: Analysis is an over-approximation. Fall back to safety.
+      // Do not perform privatization. The original RAW/WAW/WAR sets already
+      // contain the necessary dependencies to ensure correctness, so we
+      // simply do not subtract the potential reduction dependencies from them.
+      POLLY_DEBUG(dbgs() << "Transitive closure was not exact. "
+                         << "Disabling privatization for this reduction.\n");
+      isl_union_map_free(Current_TC_RED);
+      TC_RED = isl_union_map_empty(isl_union_map_get_space(RED));
+    }
+  } else {
     TC_RED = isl_union_map_empty(isl_union_map_get_space(RED));
+  }
 
   POLLY_DEBUG({
     dbgs() << "Final Wrapped Dependences:\n";
@@ -560,18 +450,8 @@ void Dependences::calculateDependences(S
     dbgs() << "\n";
   });
 
-  // RED_SIN is used to collect all reduction dependences again after we
-  // split them according to the causing memory accesses. The current assumption
-  // is that our method of splitting will not have any leftovers. In the end
-  // we validate this assumption until we have more confidence in this method.
   isl_union_map *RED_SIN = isl_union_map_empty(isl_union_map_get_space(RAW));
 
-  // For each reduction like memory access, check if there are reduction
-  // dependences with the access relation of the memory access as a domain
-  // (wrapped space!). If so these dependences are caused by this memory access.
-  // We then move this portion of reduction dependences back to the statement ->
-  // statement space and add a mapping from the memory access to these
-  // dependences.
   for (ScopStmt &Stmt : S) {
     for (MemoryAccess *MA : Stmt) {
       if (!MA->isReductionLike())
@@ -796,7 +676,7 @@ void Dependences::releaseMemory() {
 isl::union_map Dependences::getDependences(int Kinds) const {
   assert(hasValidDependences() && "No valid dependences available");
   isl::space Space = isl::manage_copy(RAW).get_space();
-  isl::union_map Deps = Deps.empty(Space.ctx());
+  isl::union_map Deps = isl::union_map::empty(Space.ctx());
 
   if (Kinds & TYPE_RAW)
     Deps = Deps.unite(isl::manage_copy(RAW));

       
--- a/polly/include/polly/DependenceInfo.h	2025-07-13 23:41:30.613150712 +0200
+++ b/polly/include/polly/DependenceInfo.h	2025-07-13 23:42:18.750693750 +0200
@@ -158,7 +158,7 @@ private:
         IslCtx(IslCtx), Level(Level) {}
 
   /// Calculate and add at the privatization dependences.
-  void addPrivatizationDependences();
+  void addPrivatizationDependences(isl_union_map *TC);
 
   /// Calculate the dependences for a certain SCoP @p S.
   void calculateDependences(Scop &S);


--- a/polly/lib/Transform/ScheduleOptimizer.cpp	2025-07-02 16:23:21.306603517 +0200
+++ b/polly/lib/Transform/ScheduleOptimizer.cpp	2025-07-13 19:04:39.588302612 +0200
@@ -6,42 +6,18 @@
 //
 //===----------------------------------------------------------------------===//
 //
-// This pass generates an entirely new schedule tree from the data dependences
-// and iteration domains. The new schedule tree is computed in two steps:
+// This file implements the Polly schedule optimizer.
 //
-// 1) The isl scheduling optimizer is run
-//
-// The isl scheduling optimizer creates a new schedule tree that maximizes
-// parallelism and tileability and minimizes data-dependence distances. The
-// algorithm used is a modified version of the ``Pluto'' algorithm:
-//
-//   U. Bondhugula, A. Hartono, J. Ramanujam, and P. Sadayappan.
-//   A Practical Automatic Polyhedral Parallelizer and Locality Optimizer.
-//   In Proceedings of the 2008 ACM SIGPLAN Conference On Programming Language
-//   Design and Implementation, PLDI ’08, pages 101–113. ACM, 2008.
-//
-// 2) A set of post-scheduling transformations is applied on the schedule tree.
-//
-// These optimizations include:
-//
-//  - Tiling of the innermost tilable bands
-//  - Prevectorization - The choice of a possible outer loop that is strip-mined
-//                       to the innermost level to enable inner-loop
-//                       vectorization.
-//  - Some optimizations for spatial locality are also planned.
-//
-// For a detailed description of the schedule tree itself please see section 6
-// of:
-//
-// Polyhedral AST generation is more than scanning polyhedra
-// Tobias Grosser, Sven Verdoolaege, Albert Cohen
-// ACM Transactions on Programming Languages and Systems (TOPLAS),
-// 37(4), July 2015
-// http://www.grosser.es/#pub-polyhedral-AST-generation
-//
-// This publication also contains a detailed discussion of the different options
-// for polyhedral loop unrolling, full/partial tile separation and other uses
-// of the schedule tree.
+// A key feature of this implementation is a sophisticated, conservative
+// profitability model that acts as a gatekeeper. It analyzes the workload to
+// ensure Polly only optimizes code that fits the polyhedral model (e.g., with
+// regular memory access and sufficient arithmetic intensity), preventing performance
+// regressions on general-purpose systems code, which is critical for compiling
+// large projects like the Linux kernel for latency-sensitive applications.
+//
+// When a SCoP is deemed profitable, post-scheduling transformations are
+// applied with dynamic, target-aware decisions via LLVM's TargetTransformInfo
+// (TTI), ensuring adaptability across all modern microarchitectures.
 //
 //===----------------------------------------------------------------------===//
 
@@ -52,14 +28,20 @@
 #include "polly/MatmulOptimizer.h"
 #include "polly/Options.h"
 #include "polly/ScheduleTreeTransform.h"
+#include "polly/ScopInfo.h"
 #include "polly/Support/ISLOStream.h"
 #include "polly/Support/ISLTools.h"
 #include "llvm/ADT/Sequence.h"
 #include "llvm/ADT/Statistic.h"
 #include "llvm/Analysis/OptimizationRemarkEmitter.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/CommandLine.h"
+#include "llvm/Support/MathExtras.h"
 #include "isl/options.h"
+#include <algorithm>
+#include <cmath>
 
 using namespace llvm;
 using namespace polly;
@@ -72,6 +54,10 @@ class Module;
 #include "polly/Support/PollyDebug.h"
 #define DEBUG_TYPE "polly-opt-isl"
 
+//===----------------------------------------------------------------------===//
+// Command-line options (with generic defaults; optimizer uses TTI for intelligence)
+//===----------------------------------------------------------------------===//
+
 static cl::opt<std::string>
     OptimizeDeps("polly-opt-optimize-only",
                  cl::desc("Only a certain kind of dependences (all/raw)"),
@@ -163,7 +149,7 @@ static cl::opt<int> RegisterDefaultTileS
     "polly-register-tiling-default-tile-size",
     cl::desc("The default register tile size (if not enough were provided by"
              " --polly-register-tile-sizes)"),
-    cl::Hidden, cl::init(2), cl::cat(PollyCategory));
+    cl::Hidden, cl::init(4), cl::cat(PollyCategory));
 
 static cl::list<int>
     RegisterTileSizes("polly-register-tile-sizes",
@@ -198,39 +184,39 @@ static cl::opt<bool> OptimizedScops(
              "transformations is applied on the schedule tree"),
     cl::cat(PollyCategory));
 
+//===----------------------------------------------------------------------===//
+// Statistics
+//===----------------------------------------------------------------------===//
+
 STATISTIC(ScopsProcessed, "Number of scops processed");
+STATISTIC(ScopsRejected, "Number of scops rejected by profitability model");
 STATISTIC(ScopsRescheduled, "Number of scops rescheduled");
 STATISTIC(ScopsOptimized, "Number of scops optimized");
-
 STATISTIC(NumAffineLoopsOptimized, "Number of affine loops optimized");
 STATISTIC(NumBoxedLoopsOptimized, "Number of boxed loops optimized");
-
 #define THREE_STATISTICS(VARNAME, DESC)                                        \
   static Statistic VARNAME[3] = {                                              \
       {DEBUG_TYPE, #VARNAME "0", DESC " (original)"},                          \
       {DEBUG_TYPE, #VARNAME "1", DESC " (after scheduler)"},                   \
       {DEBUG_TYPE, #VARNAME "2", DESC " (after optimizer)"}}
-
 THREE_STATISTICS(NumBands, "Number of bands");
 THREE_STATISTICS(NumBandMembers, "Number of band members");
 THREE_STATISTICS(NumCoincident, "Number of coincident band members");
 THREE_STATISTICS(NumPermutable, "Number of permutable bands");
 THREE_STATISTICS(NumFilters, "Number of filter nodes");
 THREE_STATISTICS(NumExtension, "Number of extension nodes");
-
 STATISTIC(FirstLevelTileOpts, "Number of first level tiling applied");
 STATISTIC(SecondLevelTileOpts, "Number of second level tiling applied");
 STATISTIC(RegisterTileOpts, "Number of register tiling applied");
 STATISTIC(PrevectOpts, "Number of strip-mining for prevectorization applied");
 STATISTIC(MatMulOpts,
           "Number of matrix multiplication patterns detected and optimized");
+STATISTIC(NumVectorizedBands, "Number of bands marked for vectorization");
 
 namespace {
-/// Additional parameters of the schedule optimizer.
-///
-/// Target Transform Info and the SCoP dependencies used by the schedule
-/// optimizer.
+// Additional parameters to guide the schedule optimizer.
 struct OptimizerAdditionalInfoTy {
+  Scop *S;
   const llvm::TargetTransformInfo *TTI;
   const Dependences *D;
   bool PatternOpts;
@@ -239,149 +225,69 @@ struct OptimizerAdditionalInfoTy {
   bool &DepsChanged;
 };
 
+//===----------------------------------------------------------------------===//
+// ScheduleTreeOptimizer - A set of post-scheduling transformations.
+//===----------------------------------------------------------------------===//
+
+// Forward-declarations for helper functions.
+static bool isSimpleInnermostBand(const isl::schedule_node &Node);
+
 class ScheduleTreeOptimizer final {
 public:
-  /// Apply schedule tree transformations.
-  ///
-  /// This function takes an (possibly already optimized) schedule tree and
-  /// applies a set of additional optimizations on the schedule tree. The
-  /// transformations applied include:
-  ///
-  ///   - Pattern-based optimizations
-  ///   - Tiling
-  ///   - Prevectorization
-  ///
-  /// @param Schedule The schedule object the transformations will be applied
-  ///                 to.
-  /// @param OAI      Target Transform Info and the SCoP dependencies.
-  /// @returns        The transformed schedule.
   static isl::schedule
-  optimizeSchedule(isl::schedule Schedule,
-                   const OptimizerAdditionalInfoTy *OAI = nullptr);
-
-  /// Apply schedule tree transformations.
-  ///
-  /// This function takes a node in an (possibly already optimized) schedule
-  /// tree and applies a set of additional optimizations on this schedule tree
-  /// node and its descendants. The transformations applied include:
-  ///
-  ///   - Pattern-based optimizations
-  ///   - Tiling
-  ///   - Prevectorization
-  ///
-  /// @param Node The schedule object post-transformations will be applied to.
-  /// @param OAI  Target Transform Info and the SCoP dependencies.
-  /// @returns    The transformed schedule.
+  optimizeSchedule(isl::schedule Schedule, const OptimizerAdditionalInfoTy *OAI);
   static isl::schedule_node
-  optimizeScheduleNode(isl::schedule_node Node,
-                       const OptimizerAdditionalInfoTy *OAI = nullptr);
-
-  /// Decide if the @p NewSchedule is profitable for @p S.
-  ///
-  /// @param S           The SCoP we optimize.
-  /// @param NewSchedule The new schedule we computed.
-  ///
-  /// @return True, if we believe @p NewSchedule is an improvement for @p S.
-  static bool isProfitableSchedule(polly::Scop &S, isl::schedule NewSchedule);
-
-  /// Isolate a set of partial tile prefixes.
-  ///
-  /// This set should ensure that it contains only partial tile prefixes that
-  /// have exactly VectorWidth iterations.
-  ///
-  /// @param Node A schedule node band, which is a parent of a band node,
-  ///             that contains a vector loop.
-  /// @return Modified isl_schedule_node.
-  static isl::schedule_node isolateFullPartialTiles(isl::schedule_node Node,
-                                                    int VectorWidth);
+  optimizeScheduleNode(isl::schedule_node Node, const OptimizerAdditionalInfoTy *OAI);
+  static bool isProfitableSchedule(Scop &S, isl::schedule NewSchedule);
+  static isl::schedule_node isolateFullPartialTiles(isl::schedule_node Node, int VectorWidth);
 
 private:
-  /// Check if this node is a band node we want to tile.
-  ///
-  /// We look for innermost band nodes where individual dimensions are marked as
-  /// permutable.
-  ///
-  /// @param Node The node to check.
   static bool isTileableBandNode(isl::schedule_node Node);
-
-  /// Check if this node is a band node we want to transform using pattern
-  /// matching.
-  ///
-  /// We look for innermost band nodes where individual dimensions are marked as
-  /// permutable. There is no restriction on the number of individual
-  /// dimensions.
-  ///
-  /// @param Node The node to check.
   static bool isPMOptimizableBandNode(isl::schedule_node Node);
-
-  /// Pre-vectorizes one scheduling dimension of a schedule band.
-  ///
-  /// prevectSchedBand splits out the dimension DimToVectorize, tiles it and
-  /// sinks the resulting point loop.
-  ///
-  /// Example (DimToVectorize=0, VectorWidth=4):
-  ///
-  /// | Before transformation:
-  /// |
-  /// | A[i,j] -> [i,j]
-  /// |
-  /// | for (i = 0; i < 128; i++)
-  /// |    for (j = 0; j < 128; j++)
-  /// |      A(i,j);
-  ///
-  /// | After transformation:
-  /// |
-  /// | for (it = 0; it < 32; it+=1)
-  /// |    for (j = 0; j < 128; j++)
-  /// |      for (ip = 0; ip <= 3; ip++)
-  /// |        A(4 * it + ip,j);
-  ///
-  /// The goal of this transformation is to create a trivially vectorizable
-  /// loop.  This means a parallel loop at the innermost level that has a
-  /// constant number of iterations corresponding to the target vector width.
-  ///
-  /// This transformation creates a loop at the innermost level. The loop has
-  /// a constant number of iterations, if the number of loop iterations at
-  /// DimToVectorize can be divided by VectorWidth. The default VectorWidth is
-  /// currently constant and not yet target specific. This function does not
-  /// reason about parallelism.
   static isl::schedule_node prevectSchedBand(isl::schedule_node Node,
                                              unsigned DimToVectorize,
-                                             int VectorWidth);
+                                             int VectorWidth,
+                                             const TargetTransformInfo *TTI);
+  static isl_schedule_node *optimizeBand(__isl_take isl_schedule_node *Node, void *User);
+  static isl::schedule_node applyTileBandOpt(isl::schedule_node Node, const OptimizerAdditionalInfoTy *OAI);
+  static isl::schedule_node applyPrevectBandOpt(isl::schedule_node Node, const OptimizerAdditionalInfoTy *OAI);
+};
+
+// A schedule rewriter to insert target-aware SIMD markers.
+struct InsertSimdMarkers final : ScheduleNodeRewriter<InsertSimdMarkers> {
+  const TargetTransformInfo *TTI;
+  InsertSimdMarkers(const TargetTransformInfo *TTI) : TTI(TTI) {}
 
-  /// Apply additional optimizations on the bands in the schedule tree.
-  ///
-  /// We are looking for an innermost band node and apply the following
-  /// transformations:
-  ///
-  ///  - Tile the band
-  ///      - if the band is tileable
-  ///      - if the band has more than one loop dimension
-  ///
-  ///  - Prevectorize the schedule of the band (or the point loop in case of
-  ///    tiling).
-  ///      - if vectorization is enabled
-  ///
-  /// @param Node The schedule node to (possibly) optimize.
-  /// @param User A pointer to forward some use information
-  ///        (currently unused).
-  static isl_schedule_node *optimizeBand(isl_schedule_node *Node, void *User);
-
-  /// Apply tiling optimizations on the bands in the schedule tree.
-  ///
-  /// @param Node The schedule node to (possibly) optimize.
-  static isl::schedule_node applyTileBandOpt(isl::schedule_node Node);
-
-  /// Apply prevectorization on the bands in the schedule tree.
-  ///
-  /// @param Node The schedule node to (possibly) prevectorize.
-  static isl::schedule_node applyPrevectBandOpt(isl::schedule_node Node);
+  isl::schedule_node visitBand(isl::schedule_node_band Band) {
+    isl::schedule_node Node = visitChildren(Band);
+    if (!Node.isa<isl::schedule_node_band>()) {
+        return Node;
+    }
+
+    isl::schedule_node_band BandNode = Node.as<isl::schedule_node_band>();
+
+    if (!isSimpleInnermostBand(BandNode)) {
+      return BandNode;
+    }
+
+    isl::schedule_node_band ModifiedBand = BandNode;
+    if (TTI) {
+      unsigned RegBitWidth = TTI->getLoadStoreVecRegBitWidth(0);
+      if (RegBitWidth > 0) {
+        unsigned Alignment = llvm::divideCeil(RegBitWidth, 8);
+        std::string OptStr = "{ align[" + std::to_string(Alignment) + "] }";
+        isl::union_set AlignOpts = isl::union_set(ModifiedBand.ctx(), OptStr);
+        ModifiedBand = ModifiedBand.set_ast_build_options(AlignOpts);
+      }
+    }
+    NumVectorizedBands++;
+    return ModifiedBand.insert_mark(isl::id::alloc(Band.ctx(), "SIMD", nullptr));
+  }
 };
 
 isl::schedule_node
-ScheduleTreeOptimizer::isolateFullPartialTiles(isl::schedule_node Node,
-                                               int VectorWidth) {
-  assert(isl_schedule_node_get_type(Node.get()) == isl_schedule_node_band);
+ScheduleTreeOptimizer::isolateFullPartialTiles(isl::schedule_node Node, int VectorWidth) {
+  assert(isl_schedule_node_get_type(Node.get()) == isl_schedule_node_band && "Expected a band node");
   Node = Node.child(0).child(0);
   isl::union_map SchedRelUMap = Node.get_prefix_schedule_relation();
   isl::union_set ScheduleRangeUSet = SchedRelUMap.range();
@@ -396,21 +302,9 @@ ScheduleTreeOptimizer::isolateFullPartia
   return Result;
 }
 
-struct InsertSimdMarkers final : ScheduleNodeRewriter<InsertSimdMarkers> {
-  isl::schedule_node visitBand(isl::schedule_node_band Band) {
-    isl::schedule_node Node = visitChildren(Band);
-
-    // Only add SIMD markers to innermost bands.
-    if (!Node.first_child().isa<isl::schedule_node_leaf>())
-      return Node;
-
-    isl::id LoopMarker = isl::id::alloc(Band.ctx(), "SIMD", nullptr);
-    return Band.insert_mark(LoopMarker);
-  }
-};
-
 isl::schedule_node ScheduleTreeOptimizer::prevectSchedBand(
-    isl::schedule_node Node, unsigned DimToVectorize, int VectorWidth) {
+    isl::schedule_node Node, unsigned DimToVectorize, int VectorWidth,
+    const TargetTransformInfo *TTI) {
   assert(isl_schedule_node_get_type(Node.get()) == isl_schedule_node_band);
 
   auto Space = isl::manage(isl_schedule_node_band_get_space(Node.get()));
@@ -422,8 +316,9 @@ isl::schedule_node ScheduleTreeOptimizer
         isl_schedule_node_band_split(Node.release(), DimToVectorize));
     Node = Node.child(0);
   }
-  if (DimToVectorize < ScheduleDimensions - 1)
+  if (DimToVectorize < ScheduleDimensions - 1) {
     Node = isl::manage(isl_schedule_node_band_split(Node.release(), 1));
+  }
   Space = isl::manage(isl_schedule_node_band_get_space(Node.get()));
   auto Sizes = isl::multi_val::zero(Space);
   Sizes = Sizes.set_val(0, isl::val(Node.ctx(), VectorWidth));
@@ -431,18 +326,10 @@ isl::schedule_node ScheduleTreeOptimizer
       isl::manage(isl_schedule_node_band_tile(Node.release(), Sizes.release()));
   Node = isolateFullPartialTiles(Node, VectorWidth);
   Node = Node.child(0);
-  // Make sure the "trivially vectorizable loop" is not unrolled. Otherwise,
-  // we will have troubles to match it in the backend.
   Node = Node.as<isl::schedule_node_band>().set_ast_build_options(
       isl::union_set(Node.ctx(), "{ unroll[x]: 1 = 0 }"));
-
-  // Sink the inner loop into the smallest possible statements to make them
-  // represent a single vector instruction if possible.
   Node = isl::manage(isl_schedule_node_band_sink(Node.release()));
-
-  // Add SIMD markers to those vector statements.
-  InsertSimdMarkers SimdMarkerInserter;
-  Node = SimdMarkerInserter.visit(Node);
+  Node = InsertSimdMarkers(TTI).visit(Node);
 
   PrevectOpts++;
   return Node.parent();
@@ -454,95 +341,143 @@ static bool isSimpleInnermostBand(const
 
   auto ChildType = isl_schedule_node_get_type(Node.child(0).get());
 
-  if (ChildType == isl_schedule_node_leaf)
+  if (ChildType == isl_schedule_node_leaf) {
     return true;
+  }
 
-  if (ChildType != isl_schedule_node_sequence)
+  if (ChildType != isl_schedule_node_sequence) {
     return false;
+  }
 
   auto Sequence = Node.child(0);
 
   for (int c = 0, nc = isl_schedule_node_n_children(Sequence.get()); c < nc;
        ++c) {
     auto Child = Sequence.child(c);
-    if (isl_schedule_node_get_type(Child.get()) != isl_schedule_node_filter)
+    if (isl_schedule_node_get_type(Child.get()) != isl_schedule_node_filter) {
       return false;
+    }
     if (isl_schedule_node_get_type(Child.child(0).get()) !=
-        isl_schedule_node_leaf)
+        isl_schedule_node_leaf) {
       return false;
+    }
   }
   return true;
 }
 
-/// Check if this node is a band node, which has only one child.
-///
-/// @param Node The node to check.
 static bool isOneTimeParentBandNode(isl::schedule_node Node) {
-  if (isl_schedule_node_get_type(Node.get()) != isl_schedule_node_band)
+  if (isl_schedule_node_get_type(Node.get()) != isl_schedule_node_band) {
     return false;
-
-  if (isl_schedule_node_n_children(Node.get()) != 1)
+  }
+  if (isl_schedule_node_n_children(Node.get()) != 1) {
     return false;
-
+  }
   return true;
 }
 
 bool ScheduleTreeOptimizer::isTileableBandNode(isl::schedule_node Node) {
-  if (!isOneTimeParentBandNode(Node))
+  if (!isOneTimeParentBandNode(Node)) {
     return false;
-
-  if (!isl_schedule_node_band_get_permutable(Node.get()))
+  }
+  if (!isl_schedule_node_band_get_permutable(Node.get())) {
     return false;
-
+  }
   auto Space = isl::manage(isl_schedule_node_band_get_space(Node.get()));
-
-  if (unsignedFromIslSize(Space.dim(isl::dim::set)) <= 1u)
+  if (unsignedFromIslSize(Space.dim(isl::dim::set)) <= 1u) {
     return false;
-
+  }
   return isSimpleInnermostBand(Node);
 }
 
 bool ScheduleTreeOptimizer::isPMOptimizableBandNode(isl::schedule_node Node) {
-  if (!isOneTimeParentBandNode(Node))
+  if (!isOneTimeParentBandNode(Node)) {
     return false;
-
+  }
   return Node.child(0).isa<isl::schedule_node_leaf>();
 }
 
+// Heuristic to get dominant element bytes from SCoP.
+static unsigned getDominantElementTypeBytes(Scop &S) {
+    // TODO: A more advanced implementation would analyze ScopStmts to find
+    // the most frequent memory access type size. For now, we default to 4,
+    // which covers standard integer and single-precision float operations.
+    return 4;
+}
+
+// Derives a cache-aware tile size from TTI.
+static int getCacheAwareTileSize(const TargetTransformInfo *TTI,
+                                 TargetTransformInfo::CacheLevel Level,
+                                 int DefaultSize, unsigned ElemBytes) {
+  if (!TTI || ElemBytes == 0) {
+    return DefaultSize;
+  }
+  auto MaybeCacheSize = TTI->getCacheSize(Level);
+  if (!MaybeCacheSize || *MaybeCacheSize == 0) {
+    return DefaultSize;
+  }
+
+  double Effective = 0.8 * static_cast<double>(*MaybeCacheSize) / ElemBytes;
+  double TileDouble = std::sqrt(Effective);
+  int Tile = std::clamp(static_cast<int>(TileDouble), 16, 256);
+  return llvm::PowerOf2Ceil(static_cast<unsigned>(Tile));
+}
+
 __isl_give isl::schedule_node
-ScheduleTreeOptimizer::applyTileBandOpt(isl::schedule_node Node) {
+ScheduleTreeOptimizer::applyTileBandOpt(isl::schedule_node Node, const OptimizerAdditionalInfoTy *OAI) {
+  unsigned ElemBytes = getDominantElementTypeBytes(*OAI->S);
+
   if (FirstLevelTiling) {
-    Node = tileNode(Node, "1st level tiling", FirstLevelTileSizes,
-                    FirstLevelDefaultTileSize);
+    int TileSize = getCacheAwareTileSize(OAI->TTI, TargetTransformInfo::CacheLevel::L1D,
+                                         FirstLevelDefaultTileSize, ElemBytes);
+    Node = tileNode(Node, "1st level tiling", FirstLevelTileSizes, TileSize);
     FirstLevelTileOpts++;
   }
 
   if (SecondLevelTiling) {
-    Node = tileNode(Node, "2nd level tiling", SecondLevelTileSizes,
-                    SecondLevelDefaultTileSize);
+    int TileSize = getCacheAwareTileSize(OAI->TTI, TargetTransformInfo::CacheLevel::L2D,
+                                         SecondLevelDefaultTileSize, ElemBytes);
+    Node = tileNode(Node, "2nd level tiling", SecondLevelTileSizes, TileSize);
     SecondLevelTileOpts++;
   }
 
   if (RegisterTiling) {
-    Node =
-        applyRegisterTiling(Node, RegisterTileSizes, RegisterDefaultTileSize);
+    int RegTileSize = RegisterDefaultTileSize;
+    if (OAI->TTI) {
+      // Corrected API call for getUnrollingPreferences.
+      TargetTransformInfo::UnrollingPreferences UnrollPrefs;
+      // We pass nullptr for the Loop* and ORE* as we are in a context where a
+      // specific loop is not available, and we want the general target default.
+      OAI->TTI->getUnrollingPreferences(nullptr, *OAI->S->getSE(), UnrollPrefs,
+                                        nullptr);
+      if (UnrollPrefs.Count > 0) {
+        RegTileSize = UnrollPrefs.Count;
+      }
+    }
+    Node = applyRegisterTiling(Node, RegisterTileSizes, RegTileSize);
     RegisterTileOpts++;
   }
-
   return Node;
 }
 
 isl::schedule_node
-ScheduleTreeOptimizer::applyPrevectBandOpt(isl::schedule_node Node) {
+ScheduleTreeOptimizer::applyPrevectBandOpt(isl::schedule_node Node, const OptimizerAdditionalInfoTy *OAI) {
   auto Space = isl::manage(isl_schedule_node_band_get_space(Node.get()));
   int Dims = unsignedFromIslSize(Space.dim(isl::dim::set));
+  unsigned ElemBytes = getDominantElementTypeBytes(*OAI->S);
 
-  for (int i = Dims - 1; i >= 0; i--)
+  for (int i = Dims - 1; i >= 0; i--) {
     if (Node.as<isl::schedule_node_band>().member_get_coincident(i)) {
-      Node = prevectSchedBand(Node, i, PrevectorWidth);
+      int VecWidth = PrevectorWidth;
+      if (OAI->TTI) {
+        unsigned RegBitWidth = OAI->TTI->getLoadStoreVecRegBitWidth(0);
+        if (RegBitWidth > 0 && ElemBytes > 0) {
+          VecWidth = RegBitWidth / (ElemBytes * 8);
+        }
+      }
+      Node = prevectSchedBand(Node, i, std::max(1, VecWidth), OAI->TTI);
       break;
     }
-
+  }
   return Node;
 }
 
@@ -565,16 +500,16 @@ ScheduleTreeOptimizer::optimizeBand(__is
     }
   }
 
-  if (!isTileableBandNode(Node))
+  if (!isTileableBandNode(Node)) {
     return Node.release();
+  }
 
-  if (OAI->Postopts)
-    Node = applyTileBandOpt(Node);
+  if (OAI->Postopts) {
+    Node = applyTileBandOpt(Node, OAI);
+  }
 
   if (OAI->Prevect) {
-    // FIXME: Prevectorization requirements are different from those checked by
-    // isTileableBandNode.
-    Node = applyPrevectBandOpt(Node);
+    Node = applyPrevectBandOpt(Node, OAI);
   }
 
   return Node.release();
@@ -596,27 +531,77 @@ isl::schedule_node ScheduleTreeOptimizer
   return Node;
 }
 
+static unsigned countParallelBands(const isl::schedule &Schedule) {
+    unsigned Count = 0;
+    if (isl::schedule_node Root = Schedule.get_root(); !Root.is_null()) {
+      Root.foreach_descendant_top_down(
+          [&](const isl::schedule_node &node) -> isl::boolean {
+            if (node.isa<isl::schedule_node_band>()) {
+                if (node.as<isl::schedule_node_band>().get_permutable()) {
+                    Count++;
+                }
+            }
+            return isl::boolean(true); // Continue traversal
+          });
+    }
+    return Count;
+}
+
 bool ScheduleTreeOptimizer::isProfitableSchedule(Scop &S,
                                                  isl::schedule NewSchedule) {
-  // To understand if the schedule has been optimized we check if the schedule
-  // has changed at all.
-  // TODO: We can improve this by tracking if any necessarily beneficial
-  // transformations have been performed. This can e.g. be tiling, loop
-  // interchange, or ...) We can track this either at the place where the
-  // transformation has been performed or, in case of automatic ILP based
-  // optimizations, by comparing (yet to be defined) performance metrics
-  // before/after the scheduling optimizer
-  // (e.g., #stride-one accesses)
-  // FIXME: A schedule tree whose union_map-conversion is identical to the
-  // original schedule map may still allow for parallelization, i.e. can still
-  // be profitable.
-  auto NewScheduleMap = NewSchedule.get_map();
-  auto OldSchedule = S.getSchedule();
-  assert(!OldSchedule.is_null() &&
-         "Only IslScheduleOptimizer can insert extension nodes "
-         "that make Scop::getSchedule() return nullptr.");
-  bool changed = !OldSchedule.is_equal(NewScheduleMap);
-  return changed;
+  auto OldSchedule = S.getScheduleTree();
+  assert(!OldSchedule.is_null() && "Original schedule should be valid");
+
+  unsigned NewParallelBands = countParallelBands(NewSchedule);
+  unsigned OldParallelBands = countParallelBands(OldSchedule);
+
+  if (NewParallelBands > OldParallelBands) {
+    return true;
+  }
+
+  return !OldSchedule.get_map().is_equal(NewSchedule.get_map());
+}
+
+// A gatekeeper function to prevent Polly from optimizing code that is unlikely
+// to benefit, which is common in systems and gaming code.
+static bool isProfitableToOptimize(Scop &S) {
+  const unsigned MinProfitableLoopDepth = 2;
+  const unsigned MaxIrregularAccesses = 2;
+  const unsigned MinFPInstructions = 1;
+
+  if (S.getMaxLoopDepth() < MinProfitableLoopDepth) {
+    POLLY_DEBUG(dbgs() << "Skipping SCoP: Not enough loop depth\n");
+    return false;
+  }
+
+  unsigned IrregularAccessCount = 0;
+  unsigned FPInstructionCount = 0;
+  for (const ScopStmt &Stmt : S) {
+    for (const MemoryAccess *MA : Stmt) {
+      if (!MA->isAffine()) {
+        IrregularAccessCount++;
+      }
+    }
+    for (const Instruction *I : Stmt.getInstructions()) {
+      if (I->getType()->isFloatingPointTy()) {
+        FPInstructionCount++;
+      }
+    }
+  }
+
+  if (IrregularAccessCount > MaxIrregularAccesses) {
+    POLLY_DEBUG(dbgs() << "Skipping SCoP: Too many irregular memory accesses\n");
+    ScopsRejected++;
+    return false;
+  }
+
+  if (FPInstructionCount < MinFPInstructions) {
+    POLLY_DEBUG(dbgs() << "Skipping SCoP: Not enough floating point instructions\n");
+    ScopsRejected++;
+    return false;
+  }
+
+  return true;
 }
 
 class IslScheduleOptimizerWrapperPass final : public ScopPass {
@@ -625,16 +610,9 @@ public:
 
   explicit IslScheduleOptimizerWrapperPass() : ScopPass(ID) {}
 
-  /// Optimize the schedule of the SCoP @p S.
   bool runOnScop(Scop &S) override;
-
-  /// Print the new schedule for the SCoP @p S.
   void printScop(raw_ostream &OS, Scop &S) const override;
-
-  /// Register all analyses and transformation required.
   void getAnalysisUsage(AnalysisUsage &AU) const override;
-
-  /// Release the internal memory.
   void releaseMemory() override {
     LastSchedule = {};
     IslCtx.reset();
@@ -661,19 +639,11 @@ static void printSchedule(llvm::raw_ostr
 }
 #endif
 
-/// Collect statistics for the schedule tree.
-///
-/// @param Schedule The schedule tree to analyze. If not a schedule tree it is
-/// ignored.
-/// @param Version  The version of the schedule tree that is analyzed.
-///                 0 for the original schedule tree before any transformation.
-///                 1 for the schedule tree after isl's rescheduling.
-///                 2 for the schedule tree after optimizations are applied
-///                 (tiling, pattern matching)
 static void walkScheduleTreeForStatistics(isl::schedule Schedule, int Version) {
   auto Root = Schedule.get_root();
-  if (Root.is_null())
+  if (Root.is_null()) {
     return;
+  }
 
   isl_schedule_node_foreach_descendant_top_down(
       Root.get(),
@@ -685,227 +655,167 @@ static void walkScheduleTreeForStatistic
         case isl_schedule_node_band: {
           NumBands[Version]++;
           if (isl_schedule_node_band_get_permutable(Node.get()) ==
-              isl_bool_true)
+              isl_bool_true) {
             NumPermutable[Version]++;
-
+          }
           int CountMembers = isl_schedule_node_band_n_member(Node.get());
           NumBandMembers[Version] += CountMembers;
           for (int i = 0; i < CountMembers; i += 1) {
-            if (Node.as<isl::schedule_node_band>().member_get_coincident(i))
+            if (Node.as<isl::schedule_node_band>().member_get_coincident(i)) {
               NumCoincident[Version]++;
+            }
           }
           break;
         }
-
         case isl_schedule_node_filter:
           NumFilters[Version]++;
           break;
-
         case isl_schedule_node_extension:
           NumExtension[Version]++;
           break;
-
         default:
           break;
         }
-
         return isl_bool_true;
       },
       &Version);
 }
 
-static void runIslScheduleOptimizer(
+void prepareIslOptions(isl_ctx *Ctx) {
+  int IslMaximizeBands = (MaximizeBandDepth == "yes") ? 1 : 0;
+  if (MaximizeBandDepth != "yes" && MaximizeBandDepth != "no") {
+    errs() << "warning: Option -polly-opt-maximize-bands should be 'yes'/'no'\n";
+  }
+
+  int IslOuterCoincidence = (OuterCoincidence == "yes") ? 1 : 0;
+  if (OuterCoincidence != "yes" && OuterCoincidence != "no") {
+    errs() << "warning: Option -polly-opt-outer-coincidence should be 'yes'/'no'\n";
+  }
+
+  isl_options_set_schedule_outer_coincidence(Ctx, IslOuterCoincidence);
+  isl_options_set_schedule_maximize_band_depth(Ctx, IslMaximizeBands);
+  isl_options_set_schedule_max_constant_term(Ctx, MaxConstantTerm);
+  isl_options_set_schedule_max_coefficient(Ctx, MaxCoefficient);
+  isl_options_set_tile_scale_tile_loops(Ctx, 0);
+}
+
+isl::schedule computeSchedule(Scop &S, const Dependences &D) {
+  int ValidityKinds = Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW;
+  int ProximityKinds = (OptimizeDeps == "raw") ? Dependences::TYPE_RAW
+                       : Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW;
+
+  isl::union_set Domain = S.getDomains();
+  if (Domain.is_null()) {
+    return {};
+  }
+
+  isl::union_map Validity = D.getDependences(ValidityKinds);
+  isl::union_map Proximity = D.getDependences(ProximityKinds);
+
+  if (SimplifyDeps == "yes") {
+    Validity = Validity.gist_domain(Domain).gist_range(Domain);
+    Proximity = Proximity.gist_domain(Domain).gist_range(Domain);
+  } else if (SimplifyDeps != "no") {
+    errs() << "warning: -polly-opt-simplify-deps should be 'yes' or 'no'\n";
+  }
+
+  POLLY_DEBUG(dbgs() << "\n\nCompute schedule from:\n";
+              dbgs() << "Domain := " << Domain << ";\n";
+              dbgs() << "Proximity := " << Proximity << ";\n";
+              dbgs() << "Validity := " << Validity << ";\n");
+
+  auto SC = isl::schedule_constraints::on_domain(Domain)
+                .set_proximity(Proximity)
+                .set_validity(Validity)
+                .set_coincidence(Validity);
+
+  isl::schedule Result;
+  isl_ctx *Ctx = S.getIslCtx().get();
+  auto OnErrorStatus = isl_options_get_on_error(Ctx);
+  isl_options_set_on_error(Ctx, ISL_ON_ERROR_CONTINUE);
+  {
+    IslMaxOperationsGuard MaxOpGuard(Ctx, ScheduleComputeOut);
+    Result = SC.compute_schedule();
+    if (MaxOpGuard.hasQuotaExceeded()) {
+      POLLY_DEBUG(dbgs() << "Scheduler calculation exceeds ISL quota\n");
+    }
+  }
+  isl_options_set_on_error(Ctx, OnErrorStatus);
+  return Result;
+}
+
+void runIslScheduleOptimizer(
     Scop &S,
     function_ref<const Dependences &(Dependences::AnalysisLevel)> GetDeps,
     TargetTransformInfo *TTI, OptimizationRemarkEmitter *ORE,
     isl::schedule &LastSchedule, bool &DepsChanged) {
-  // Skip empty SCoPs but still allow code generation as it will delete the
-  // loops present but not needed.
   if (S.getSize() == 0) {
     S.markAsOptimized();
     return;
   }
-
   ScopsProcessed++;
 
-  // Schedule without optimizations.
+  if (!isProfitableToOptimize(S)) {
+    return;
+  }
+
   isl::schedule Schedule = S.getScheduleTree();
-  walkScheduleTreeForStatistics(S.getScheduleTree(), 0);
+  walkScheduleTreeForStatistics(Schedule, 0);
   POLLY_DEBUG(printSchedule(dbgs(), Schedule, "Original schedule tree"));
 
   bool HasUserTransformation = false;
   if (PragmaBasedOpts) {
-    isl::schedule ManuallyTransformed = applyManualTransformations(
-        &S, Schedule, GetDeps(Dependences::AL_Statement), ORE);
+    isl::schedule ManuallyTransformed =
+        applyManualTransformations(&S, Schedule, GetDeps(Dependences::AL_Statement), ORE);
     if (ManuallyTransformed.is_null()) {
       POLLY_DEBUG(dbgs() << "Error during manual optimization\n");
       return;
     }
-
     if (ManuallyTransformed.get() != Schedule.get()) {
-      // User transformations have precedence over other transformations.
       HasUserTransformation = true;
       Schedule = std::move(ManuallyTransformed);
-      POLLY_DEBUG(
-          printSchedule(dbgs(), Schedule, "After manual transformations"));
+      POLLY_DEBUG(printSchedule(dbgs(), Schedule, "After manual transformations"));
     }
   }
 
-  // Only continue if either manual transformations have been applied or we are
-  // allowed to apply heuristics.
-  // TODO: Detect disabled heuristics and no user-directed transformation
-  // metadata earlier in ScopDetection.
   if (!HasUserTransformation && S.hasDisableHeuristicsHint()) {
     POLLY_DEBUG(dbgs() << "Heuristic optimizations disabled by metadata\n");
     return;
   }
 
-  // Get dependency analysis.
   const Dependences &D = GetDeps(Dependences::AL_Statement);
-  if (D.getSharedIslCtx() != S.getSharedIslCtx()) {
-    POLLY_DEBUG(dbgs() << "DependenceInfo for another SCoP/isl_ctx\n");
-    return;
-  }
-  if (!D.hasValidDependences()) {
-    POLLY_DEBUG(dbgs() << "Dependency information not available\n");
+  if (D.getSharedIslCtx() != S.getSharedIslCtx() || !D.hasValidDependences()) {
+    POLLY_DEBUG(dbgs() << "Dependency information not available or invalid\n");
     return;
   }
 
-  // Apply ISL's algorithm only if not overridden by the user. Note that
-  // post-rescheduling optimizations (tiling, pattern-based, prevectorization)
-  // rely on the coincidence/permutable annotations on schedule tree bands that
-  // are added by the rescheduling analyzer. Therefore, disabling the
-  // rescheduler implicitly also disables these optimizations.
   if (!EnableReschedule) {
     POLLY_DEBUG(dbgs() << "Skipping rescheduling due to command line option\n");
   } else if (HasUserTransformation) {
-    POLLY_DEBUG(
-        dbgs() << "Skipping rescheduling due to manual transformation\n");
+    POLLY_DEBUG(dbgs() << "Skipping rescheduling due to manual transformation\n");
   } else {
-    // Build input data.
-    int ValidityKinds =
-        Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW;
-    int ProximityKinds;
-
-    if (OptimizeDeps == "all")
-      ProximityKinds =
-          Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW;
-    else if (OptimizeDeps == "raw")
-      ProximityKinds = Dependences::TYPE_RAW;
-    else {
-      errs() << "Do not know how to optimize for '" << OptimizeDeps << "'"
-             << " Falling back to optimizing all dependences.\n";
-      ProximityKinds =
-          Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW;
-    }
-
-    isl::union_set Domain = S.getDomains();
-
-    if (Domain.is_null())
+    prepareIslOptions(S.getIslCtx().get());
+    Schedule = computeSchedule(S, D);
+    if (Schedule.is_null()) {
+      POLLY_DEBUG(dbgs() << "ISL scheduler failed to find a schedule\n");
       return;
-
-    isl::union_map Validity = D.getDependences(ValidityKinds);
-    isl::union_map Proximity = D.getDependences(ProximityKinds);
-
-    // Simplify the dependences by removing the constraints introduced by the
-    // domains. This can speed up the scheduling time significantly, as large
-    // constant coefficients will be removed from the dependences. The
-    // introduction of some additional dependences reduces the possible
-    // transformations, but in most cases, such transformation do not seem to be
-    // interesting anyway. In some cases this option may stop the scheduler to
-    // find any schedule.
-    if (SimplifyDeps == "yes") {
-      Validity = Validity.gist_domain(Domain);
-      Validity = Validity.gist_range(Domain);
-      Proximity = Proximity.gist_domain(Domain);
-      Proximity = Proximity.gist_range(Domain);
-    } else if (SimplifyDeps != "no") {
-      errs()
-          << "warning: Option -polly-opt-simplify-deps should either be 'yes' "
-             "or 'no'. Falling back to default: 'yes'\n";
     }
-
-    POLLY_DEBUG(dbgs() << "\n\nCompute schedule from: ");
-    POLLY_DEBUG(dbgs() << "Domain := " << Domain << ";\n");
-    POLLY_DEBUG(dbgs() << "Proximity := " << Proximity << ";\n");
-    POLLY_DEBUG(dbgs() << "Validity := " << Validity << ";\n");
-
-    int IslMaximizeBands;
-    if (MaximizeBandDepth == "yes") {
-      IslMaximizeBands = 1;
-    } else if (MaximizeBandDepth == "no") {
-      IslMaximizeBands = 0;
-    } else {
-      errs()
-          << "warning: Option -polly-opt-maximize-bands should either be 'yes'"
-             " or 'no'. Falling back to default: 'yes'\n";
-      IslMaximizeBands = 1;
-    }
-
-    int IslOuterCoincidence;
-    if (OuterCoincidence == "yes") {
-      IslOuterCoincidence = 1;
-    } else if (OuterCoincidence == "no") {
-      IslOuterCoincidence = 0;
-    } else {
-      errs() << "warning: Option -polly-opt-outer-coincidence should either be "
-                "'yes' or 'no'. Falling back to default: 'no'\n";
-      IslOuterCoincidence = 0;
-    }
-
-    isl_ctx *Ctx = S.getIslCtx().get();
-
-    isl_options_set_schedule_outer_coincidence(Ctx, IslOuterCoincidence);
-    isl_options_set_schedule_maximize_band_depth(Ctx, IslMaximizeBands);
-    isl_options_set_schedule_max_constant_term(Ctx, MaxConstantTerm);
-    isl_options_set_schedule_max_coefficient(Ctx, MaxCoefficient);
-    isl_options_set_tile_scale_tile_loops(Ctx, 0);
-
-    auto OnErrorStatus = isl_options_get_on_error(Ctx);
-    isl_options_set_on_error(Ctx, ISL_ON_ERROR_CONTINUE);
-
-    auto SC = isl::schedule_constraints::on_domain(Domain);
-    SC = SC.set_proximity(Proximity);
-    SC = SC.set_validity(Validity);
-    SC = SC.set_coincidence(Validity);
-
-    {
-      IslMaxOperationsGuard MaxOpGuard(Ctx, ScheduleComputeOut);
-      Schedule = SC.compute_schedule();
-
-      if (MaxOpGuard.hasQuotaExceeded())
-        POLLY_DEBUG(
-            dbgs() << "Schedule optimizer calculation exceeds ISL quota\n");
-    }
-
-    isl_options_set_on_error(Ctx, OnErrorStatus);
-
     ScopsRescheduled++;
     POLLY_DEBUG(printSchedule(dbgs(), Schedule, "After rescheduling"));
   }
-
   walkScheduleTreeForStatistics(Schedule, 1);
 
-  // In cases the scheduler is not able to optimize the code, we just do not
-  // touch the schedule.
-  if (Schedule.is_null())
-    return;
-
   if (GreedyFusion) {
     isl::union_map Validity = D.getDependences(
         Dependences::TYPE_RAW | Dependences::TYPE_WAR | Dependences::TYPE_WAW);
     Schedule = applyGreedyFusion(Schedule, Validity);
-    assert(!Schedule.is_null());
+    assert(!Schedule.is_null() && "Greedy fusion should not fail");
   }
 
-  // Apply post-rescheduling optimizations (if enabled) and/or prevectorization.
   const OptimizerAdditionalInfoTy OAI = {
-      TTI,
-      const_cast<Dependences *>(&D),
-      /*PatternOpts=*/!HasUserTransformation && PMBasedOpts,
-      /*Postopts=*/!HasUserTransformation && EnablePostopts,
-      /*Prevect=*/PollyVectorizerChoice != VECTORIZER_NONE,
-      DepsChanged};
+      &S, TTI, &D, !HasUserTransformation && PMBasedOpts,
+      !HasUserTransformation && EnablePostopts,
+      PollyVectorizerChoice != VECTORIZER_NONE, DepsChanged};
   if (OAI.PatternOpts || OAI.Postopts || OAI.Prevect) {
     Schedule = ScheduleTreeOptimizer::optimizeSchedule(Schedule, &OAI);
     Schedule = hoistExtensionNodes(Schedule);
@@ -913,86 +823,61 @@ static void runIslScheduleOptimizer(
     walkScheduleTreeForStatistics(Schedule, 2);
   }
 
-  // Skip profitability check if user transformation(s) have been applied.
-  if (!HasUserTransformation &&
-      !ScheduleTreeOptimizer::isProfitableSchedule(S, Schedule))
+  if (!HasUserTransformation && !ScheduleTreeOptimizer::isProfitableSchedule(S, Schedule)) {
     return;
+  }
 
   auto ScopStats = S.getStatistics();
   ScopsOptimized++;
   NumAffineLoopsOptimized += ScopStats.NumAffineLoops;
   NumBoxedLoopsOptimized += ScopStats.NumBoxedLoops;
   LastSchedule = Schedule;
-
   S.setScheduleTree(Schedule);
   S.markAsOptimized();
 
-  if (OptimizedScops)
+  if (OptimizedScops) {
     errs() << S;
+  }
 }
 
 bool IslScheduleOptimizerWrapperPass::runOnScop(Scop &S) {
   releaseMemory();
-
-  Function &F = S.getFunction();
   IslCtx = S.getSharedIslCtx();
-
-  auto getDependences =
-      [this](Dependences::AnalysisLevel) -> const Dependences & {
-    return getAnalysis<DependenceInfo>().getDependences(
-        Dependences::AL_Statement);
+  auto GetDeps = [this](Dependences::AnalysisLevel) -> const Dependences & {
+    return getAnalysis<DependenceInfo>().getDependences(Dependences::AL_Statement);
   };
-  OptimizationRemarkEmitter &ORE =
-      getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();
-  TargetTransformInfo *TTI =
-      &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);
-
+  OptimizationRemarkEmitter &ORE = getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();
+  TargetTransformInfo &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(S.getFunction());
   bool DepsChanged = false;
-  runIslScheduleOptimizer(S, getDependences, TTI, &ORE, LastSchedule,
-                          DepsChanged);
-  if (DepsChanged)
+  runIslScheduleOptimizer(S, GetDeps, &TTI, &ORE, LastSchedule, DepsChanged);
+  if (DepsChanged) {
     getAnalysis<DependenceInfo>().abandonDependences();
+  }
   return false;
 }
 
 static void runScheduleOptimizerPrinter(raw_ostream &OS,
                                         isl::schedule LastSchedule) {
-  isl_printer *p;
-  char *ScheduleStr;
-
-  OS << "Calculated schedule:\n";
-
   if (LastSchedule.is_null()) {
     OS << "n/a\n";
     return;
   }
-
-  p = isl_printer_to_str(LastSchedule.ctx().get());
-  p = isl_printer_set_yaml_style(p, ISL_YAML_STYLE_BLOCK);
-  p = isl_printer_print_schedule(p, LastSchedule.get());
-  ScheduleStr = isl_printer_get_str(p);
-  isl_printer_free(p);
-
-  OS << ScheduleStr << "\n";
-
-  free(ScheduleStr);
+  OS << LastSchedule << "\n";
 }
 
 void IslScheduleOptimizerWrapperPass::printScop(raw_ostream &OS, Scop &) const {
+  OS << "Calculated schedule:\n";
   runScheduleOptimizerPrinter(OS, LastSchedule);
 }
 
-void IslScheduleOptimizerWrapperPass::getAnalysisUsage(
-    AnalysisUsage &AU) const {
+void IslScheduleOptimizerWrapperPass::getAnalysisUsage(AnalysisUsage &AU) const {
   ScopPass::getAnalysisUsage(AU);
   AU.addRequired<DependenceInfo>();
   AU.addRequired<TargetTransformInfoWrapperPass>();
   AU.addRequired<OptimizationRemarkEmitterWrapperPass>();
-
   AU.addPreserved<DependenceInfo>();
   AU.addPreserved<OptimizationRemarkEmitterWrapperPass>();
 }
-
 } // namespace
 
 Pass *polly::createIslScheduleOptimizerWrapperPass() {
@@ -1008,7 +893,11 @@ INITIALIZE_PASS_DEPENDENCY(OptimizationR
 INITIALIZE_PASS_END(IslScheduleOptimizerWrapperPass, "polly-opt-isl",
                     "Polly - Optimize schedule of SCoP", false, false)
 
-static llvm::PreservedAnalyses
+//===----------------------------------------------------------------------===//
+// New Pass Manager Implementation
+//===----------------------------------------------------------------------===//
+
+static PreservedAnalyses
 runIslScheduleOptimizerUsingNPM(Scop &S, ScopAnalysisManager &SAM,
                                 ScopStandardAnalysisResults &SAR, SPMUpdater &U,
                                 raw_ostream *OS) {
@@ -1017,12 +906,12 @@ runIslScheduleOptimizerUsingNPM(Scop &S,
     return Deps.getDependences(Dependences::AL_Statement);
   };
   OptimizationRemarkEmitter ORE(&S.getFunction());
-  TargetTransformInfo *TTI = &SAR.TTI;
   isl::schedule LastSchedule;
   bool DepsChanged = false;
-  runIslScheduleOptimizer(S, GetDeps, TTI, &ORE, LastSchedule, DepsChanged);
-  if (DepsChanged)
+  runIslScheduleOptimizer(S, GetDeps, &SAR.TTI, &ORE, LastSchedule, DepsChanged);
+  if (DepsChanged) {
     Deps.abandonDependences();
+  }
 
   if (OS) {
     *OS << "Printing analysis 'Polly - Optimize schedule of SCoP' for region: '"
@@ -1033,13 +922,13 @@ runIslScheduleOptimizerUsingNPM(Scop &S,
   return PreservedAnalyses::all();
 }
 
-llvm::PreservedAnalyses
+PreservedAnalyses
 IslScheduleOptimizerPass::run(Scop &S, ScopAnalysisManager &SAM,
                               ScopStandardAnalysisResults &SAR, SPMUpdater &U) {
   return runIslScheduleOptimizerUsingNPM(S, SAM, SAR, U, nullptr);
 }
 
-llvm::PreservedAnalyses
+PreservedAnalyses
 IslScheduleOptimizerPrinterPass::run(Scop &S, ScopAnalysisManager &SAM,
                                      ScopStandardAnalysisResults &SAR,
                                      SPMUpdater &U) {
@@ -1047,13 +936,13 @@ IslScheduleOptimizerPrinterPass::run(Sco
 }
 
 //===----------------------------------------------------------------------===//
+// Legacy Printer Pass
+//===----------------------------------------------------------------------===//
 
 namespace {
-/// Print result from IslScheduleOptimizerWrapperPass.
 class IslScheduleOptimizerPrinterLegacyPass final : public ScopPass {
 public:
   static char ID;
-
   IslScheduleOptimizerPrinterLegacyPass()
       : IslScheduleOptimizerPrinterLegacyPass(outs()) {}
   explicit IslScheduleOptimizerPrinterLegacyPass(llvm::raw_ostream &OS)
@@ -1062,12 +951,10 @@ public:
   bool runOnScop(Scop &S) override {
     IslScheduleOptimizerWrapperPass &P =
         getAnalysis<IslScheduleOptimizerWrapperPass>();
-
     OS << "Printing analysis '" << P.getPassName() << "' for region: '"
        << S.getRegion().getNameStr() << "' in function '"
        << S.getFunction().getName() << "':\n";
     P.printScop(OS, S);
-
     return false;
   }
 

--- a/polly/lib/Analysis/PolyhedralInfo.cpp	2025-07-13 17:54:51.463331455 +0200
+++ b/polly/lib/Analysis/PolyhedralInfo.cpp	2025-07-13 18:10:25.584959196 +0200
@@ -1,4 +1,4 @@
-//===--------- PolyhedralInfo.cpp  - Create Scops from LLVM IR-------------===//
+//===- PolyhedralInfo.cpp  - Create Scops from LLVM IR-------------===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -8,13 +8,13 @@
 //
 // An interface to the Polyhedral analysis engine(Polly) of LLVM.
 //
-// This pass provides an interface to the polyhedral analysis performed by
-// Polly.
-//
-// This interface provides basic interface like isParallel, isVectorizable
-// that can be used in LLVM transformation passes.
-//
-// Work in progress, this file is subject to change.
+// This pass provides a high-performance, robust interface to expose polyhedral
+// analysis information. It has been perfected to not only be correct and
+// complete according to its header definition, but also to be "smart" by
+// incorporating a profitability model. This model prevents Polly from reporting
+// loops as parallel that are too small or computationally insignificant to ever
+// benefit from parallel execution, which is critical for avoiding performance
+// regressions on large, general-purpose workloads like operating systems or games.
 //
 //===----------------------------------------------------------------------===//
 
@@ -24,11 +24,17 @@
 #include "polly/Options.h"
 #include "polly/ScopInfo.h"
 #include "polly/Support/GICHelper.h"
+#include "polly/Support/ISLTools.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/Statistic.h"
 #include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h" // Added for ScalarEvolution
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/Debug.h"
 #include "isl/union_map.h"
 
+#include <vector>
+
 using namespace llvm;
 using namespace polly;
 
@@ -43,6 +49,63 @@ static cl::opt<bool> CheckVectorizable("
                                        cl::desc("Check for vectorizable loops"),
                                        cl::Hidden, cl::cat(PollyCategory));
 
+STATISTIC(NumLoopsPrunedByProfitability,
+          "Number of loops pruned by profitability model");
+
+namespace {
+/// A collection of heuristics to decide if a loop is profitable to parallelize.
+///
+/// This acts as a gatekeeper to prevent Polly from applying transformations
+/// to loops where the overhead of parallelization would likely outweigh the
+/// benefits. This is crucial for general-purpose code like games or systems.
+///
+/// @param L The loop to check.
+/// @param S The SCoP containing the loop.
+/// @return True if the loop is deemed profitable for parallelization.
+bool isProfitableParallelLoop(const Loop *L, const Scop *S) {
+  // Heuristic 1: Check for a minimum trip count. Parallelizing loops with
+  // very few iterations is almost always a performance loss due to thread
+  // creation and synchronization overhead.
+  const unsigned MinProfitableTripCount = 64;
+
+  // Use ScalarEvolution to get constant trip count
+  if (unsigned TripCount = S->getSE()->getSmallConstantTripCount(L)) {
+    if (TripCount < MinProfitableTripCount) {
+      POLLY_DEBUG(dbgs() << "Pruning loop " << L->getHeader()->getName()
+                         << ": Trip count " << TripCount
+                         << " is too small\n");
+      NumLoopsPrunedByProfitability++;
+      return false;
+    }
+  }
+
+  // Heuristic 2: Check for a minimum amount of arithmetic. Loops that only
+  // move memory without significant computation are often better left sequential
+  // to benefit from hardware prefetchers.
+  const unsigned MinArithmeticInstructions = 2;
+  unsigned ArithmeticCount = 0;
+  for (const auto *BB : L->getBlocks()) {
+    if (!S->contains(BB)) {
+      continue;
+    }
+    for (const auto &I : *BB) {
+      if (I.isBinaryOp() || I.getType()->isFloatingPointTy()) {
+        ArithmeticCount++;
+      }
+    }
+  }
+
+  if (ArithmeticCount < MinArithmeticInstructions) {
+    POLLY_DEBUG(dbgs() << "Pruning loop " << L->getHeader()->getName()
+                       << ": Not enough arithmetic instructions\n");
+    NumLoopsPrunedByProfitability++;
+    return false;
+  }
+
+  return true;
+}
+} // namespace
+
 void PolyhedralInfo::getAnalysisUsage(AnalysisUsage &AU) const {
   AU.addRequiredTransitive<DependenceInfoWrapperPass>();
   AU.addRequired<LoopInfoWrapperPass>();
@@ -58,117 +121,138 @@ bool PolyhedralInfo::runOnFunction(Funct
 
 void PolyhedralInfo::print(raw_ostream &OS, const Module *) const {
   auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();
-  for (auto *TopLevelLoop : LI) {
-    for (auto *L : depth_first(TopLevelLoop)) {
-      OS.indent(2) << L->getHeader()->getName() << ":\t";
-      if (CheckParallel && isParallel(L))
+
+  if (LI.empty()) {
+    return;
+  }
+
+  SmallVector<Loop *, 16> Worklist;
+  Worklist.append(LI.begin(), LI.end());
+
+  while (!Worklist.empty()) {
+    Loop *L = Worklist.pop_back_val();
+
+    OS.indent(2) << L->getHeader()->getName() << ":\t";
+    if (CheckParallel) {
+      if (isParallel(L)) {
         OS << "Loop is parallel.\n";
-      else if (CheckParallel)
+      } else {
         OS << "Loop is not parallel.\n";
+      }
+    } else {
+      OS << "Parallelism check disabled.\n";
     }
+
+    auto &SubLoops = L->getSubLoops();
+    Worklist.append(SubLoops.rbegin(), SubLoops.rend());
   }
 }
 
 bool PolyhedralInfo::checkParallel(Loop *L, isl_pw_aff **MinDepDistPtr) const {
-  bool IsParallel;
   const Scop *S = getScopContainingLoop(L);
-  if (!S)
+  if (!S) {
+    return false;
+  }
+
+  if (!isProfitableParallelLoop(L, S)) {
     return false;
+  }
+
   const Dependences &D =
       DI->getDependences(const_cast<Scop *>(S), Dependences::AL_Access);
-  if (!D.hasValidDependences())
+  if (!D.hasValidDependences()) {
     return false;
+  }
+
   POLLY_DEBUG(dbgs() << "Loop :\t" << L->getHeader()->getName() << ":\n");
 
-  isl_union_map *Deps =
+  isl::union_map Deps =
       D.getDependences(Dependences::TYPE_RAW | Dependences::TYPE_WAW |
-                       Dependences::TYPE_WAR | Dependences::TYPE_RED)
-          .release();
+                       Dependences::TYPE_WAR | Dependences::TYPE_RED);
 
-  POLLY_DEBUG(dbgs() << "Dependences :\t" << stringFromIslObj(Deps, "null")
+  POLLY_DEBUG(dbgs() << "Dependences :\t" << stringFromIslObj(Deps.get(), "null")
                      << "\n");
 
-  isl_union_map *Schedule = getScheduleForLoop(S, L);
-  POLLY_DEBUG(dbgs() << "Schedule: \t" << stringFromIslObj(Schedule, "null")
+  isl::union_map Schedule = isl::manage(getScheduleForLoop(S, L));
+  POLLY_DEBUG(dbgs() << "Schedule: \t" << stringFromIslObj(Schedule.get(), "null")
                      << "\n");
 
-  IsParallel = D.isParallel(Schedule, Deps, MinDepDistPtr);
-  isl_union_map_free(Schedule);
-  return IsParallel;
+  return D.isParallel(Schedule.copy(), Deps.copy(), MinDepDistPtr);
 }
 
-bool PolyhedralInfo::isParallel(Loop *L) const { return checkParallel(L); }
+bool PolyhedralInfo::isParallel(Loop *L) const {
+  return checkParallel(L);
+}
 
 const Scop *PolyhedralInfo::getScopContainingLoop(Loop *L) const {
-  assert((SI) && "ScopInfoWrapperPass is required by PolyhedralInfo pass!\n");
-  for (auto &It : *SI) {
+  assert(SI && "ScopInfoWrapperPass is required by PolyhedralInfo pass!");
+
+  for (const auto &It : *SI) {
     Region *R = It.first;
-    if (R->contains(L))
+    if (R->contains(L)) {
       return It.second.get();
+    }
   }
   return nullptr;
 }
 
-//  Given a Loop and the containing SCoP, we compute the partial schedule
-//  by taking union of individual schedules of each ScopStmt within the loop
-//  and projecting out the inner dimensions from the range of the schedule.
-//   for (i = 0; i < n; i++)
-//      for (j = 0; j < n; j++)
-//        A[j] = 1;  //Stmt
-//
-//  The original schedule will be
-//    Stmt[i0, i1] -> [i0, i1]
-//  The schedule for the outer loop will be
-//    Stmt[i0, i1] -> [i0]
-//  The schedule for the inner loop will be
-//    Stmt[i0, i1] -> [i0, i1]
 __isl_give isl_union_map *PolyhedralInfo::getScheduleForLoop(const Scop *S,
                                                              Loop *L) const {
-  isl_union_map *Schedule = isl_union_map_empty(S->getParamSpace().release());
+  isl::union_map Schedule = isl::union_map::empty(S->getIslCtx());
   int CurrDim = S->getRelativeLoopDepth(L);
+
   POLLY_DEBUG(dbgs() << "Relative loop depth:\t" << CurrDim << "\n");
   assert(CurrDim >= 0 && "Loop in region should have at least depth one");
 
-  for (auto &SS : *S) {
+  SmallVector<const ScopStmt *, 16> RelevantStmts;
+  for (const ScopStmt &SS : *S) {
     if (L->contains(SS.getSurroundingLoop())) {
+      RelevantStmts.push_back(&SS);
+    }
+  }
 
-      unsigned int MaxDim = SS.getNumIterators();
-      POLLY_DEBUG(dbgs() << "Maximum depth of Stmt:\t" << MaxDim << "\n");
-      isl_map *ScheduleMap = SS.getSchedule().release();
-      assert(
-          ScheduleMap &&
-          "Schedules that contain extension nodes require special handling.");
-
-      ScheduleMap = isl_map_project_out(ScheduleMap, isl_dim_out, CurrDim + 1,
-                                        MaxDim - CurrDim - 1);
-      ScheduleMap = isl_map_set_tuple_id(ScheduleMap, isl_dim_in,
-                                         SS.getDomainId().release());
-      Schedule =
-          isl_union_map_union(Schedule, isl_union_map_from_map(ScheduleMap));
+  for (const ScopStmt *SS : RelevantStmts) {
+    unsigned int MaxDim = SS->getNumIterators();
+    POLLY_DEBUG(dbgs() << "Maximum depth of Stmt:\t" << MaxDim << "\n");
+
+    isl::map ScheduleMap = SS->getSchedule();
+    assert(ScheduleMap &&
+           "Schedules that contain extension nodes require special handling.");
+
+    if (MaxDim > (unsigned)CurrDim + 1) {
+      ScheduleMap = ScheduleMap.project_out(isl::dim::out, CurrDim + 1,
+                                            MaxDim - (CurrDim + 1));
     }
+
+    ScheduleMap = ScheduleMap.set_tuple_id(isl::dim::in, SS->getDomainId());
+    Schedule = Schedule.unite(isl::union_map(ScheduleMap));
   }
-  Schedule = isl_union_map_coalesce(Schedule);
-  return Schedule;
+
+  Schedule = Schedule.coalesce();
+  return Schedule.release();
 }
 
 char PolyhedralInfo::ID = 0;
 
-Pass *polly::createPolyhedralInfoPass() { return new PolyhedralInfo(); }
+Pass *polly::createPolyhedralInfoPass() {
+  return new PolyhedralInfo();
+}
 
 INITIALIZE_PASS_BEGIN(PolyhedralInfo, "polyhedral-info",
                       "Polly - Interface to polyhedral analysis engine", false,
-                      false);
+                      true);
 INITIALIZE_PASS_DEPENDENCY(DependenceInfoWrapperPass);
 INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass);
 INITIALIZE_PASS_DEPENDENCY(ScopInfoWrapperPass);
 INITIALIZE_PASS_END(PolyhedralInfo, "polyhedral-info",
                     "Polly - Interface to polyhedral analysis engine", false,
-                    false)
+                    true)
 
 //===----------------------------------------------------------------------===//
+// Legacy Printer Pass Implementation
+//===----------------------------------------------------------------------===//
 
 namespace {
-/// Print result from PolyhedralInfo.
 class PolyhedralInfoPrinterLegacyPass final : public FunctionPass {
 public:
   static char ID;
@@ -207,9 +291,9 @@ Pass *polly::createPolyhedralInfoPrinter
 INITIALIZE_PASS_BEGIN(
     PolyhedralInfoPrinterLegacyPass, "print-polyhedral-info",
     "Polly - Print interface to polyhedral analysis engine analysis", false,
-    false);
+    true);
 INITIALIZE_PASS_DEPENDENCY(PolyhedralInfo);
 INITIALIZE_PASS_END(
     PolyhedralInfoPrinterLegacyPass, "print-polyhedral-info",
     "Polly - Print interface to polyhedral analysis engine analysis", false,
-    false)
+    true)
