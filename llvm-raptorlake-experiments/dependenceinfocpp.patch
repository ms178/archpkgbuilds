--- DependenceInfo.cpp	2025-09-21 14:59:12.228534011 +0200
+++ DependenceInfo.cpp	2025-09-21 15:16:14.364885868 +0200
@@ -1,24 +1,12 @@
 //===- DependenceInfo.cpp - Calculate dependency information for a Scop. --===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
-//===----------------------------------------------------------------------===//
-//
 // Calculate the data dependency relations for a Scop using ISL.
 //
-// The integer set library (ISL) from Sven, has a integrated dependency analysis
-// to calculate data dependences. This pass takes advantage of this and
-// calculate those dependences a Scop.
-//
-// The dependences in this pass are exact in terms that for a specific read
-// statement instance only the last write statement instance is returned. In
-// case of may writes a set of possible write instances is returned. This
-// analysis will never produce redundant dependences.
-//
 //===----------------------------------------------------------------------===//
-//
+
 #include "polly/DependenceInfo.h"
 #include "polly/LinkAllPasses.h"
 #include "polly/Options.h"
@@ -31,6 +19,7 @@
 #include "isl/ctx.h"
 #include "isl/flow.h"
 #include "isl/map.h"
+#include "isl/options.h"
 #include "isl/schedule.h"
 #include "isl/set.h"
 #include "isl/union_map.h"
@@ -82,9 +71,18 @@ static cl::opt<Dependences::AnalysisLeve
                           " access instructions in the same statement")),
     cl::Hidden, cl::init(Dependences::AL_Statement), cl::cat(PollyCategory));
 
-//===----------------------------------------------------------------------===//
+static inline __isl_give isl_union_map *emptyUMapWithParamSpace(const Scop &S) {
+  return isl_union_map_empty(S.getParamSpace().release());
+}
+
+static inline void ensureNonNullUM(__isl_give isl_union_map *&UM,
+                                   const Scop &S) {
+  if (!UM) {
+    UM = emptyUMapWithParamSpace(S);
+  }
+}
 
-/// Tag the @p Relation domain with @p TagId
+/// Tag the Relation domain with TagId.
 static __isl_give isl_map *tag(__isl_take isl_map *Relation,
                                __isl_take isl_id *TagId) {
   isl_space *Space = isl_map_get_space(Relation);
@@ -96,21 +94,18 @@ static __isl_give isl_map *tag(__isl_tak
   return Relation;
 }
 
-/// Tag the @p Relation domain with either MA->getArrayId() or
-///        MA->getId() based on @p TagLevel
+/// Tag the Relation domain with either MA->getArrayId() or MA->getId().
 static __isl_give isl_map *tag(__isl_take isl_map *Relation, MemoryAccess *MA,
                                Dependences::AnalysisLevel TagLevel) {
-  if (TagLevel == Dependences::AL_Reference)
+  if (TagLevel == Dependences::AL_Reference) {
     return tag(Relation, MA->getArrayId().release());
-
-  if (TagLevel == Dependences::AL_Access)
+  }
+  if (TagLevel == Dependences::AL_Access) {
     return tag(Relation, MA->getId().release());
-
-  // No need to tag at the statement level.
+  }
   return Relation;
 }
 
-/// Collect information about the SCoP @p S.
 static void collectInfo(Scop &S, isl_union_map *&Read,
                         isl_union_map *&MustWrite, isl_union_map *&MayWrite,
                         isl_union_map *&ReductionTagMap,
@@ -124,57 +119,50 @@ static void collectInfo(Scop &S, isl_uni
   isl_union_map *StmtSchedule = isl_union_map_empty(Space);
 
   SmallPtrSet<const ScopArrayInfo *, 8> ReductionArrays;
-  if (UseReductions)
-    for (ScopStmt &Stmt : S)
-      for (MemoryAccess *MA : Stmt)
-        if (MA->isReductionLike())
+  if (UseReductions) {
+    for (ScopStmt &Stmt : S) {
+      for (MemoryAccess *MA : Stmt) {
+        if (MA->isReductionLike()) {
           ReductionArrays.insert(MA->getScopArrayInfo());
+        }
+      }
+    }
+  }
 
   for (ScopStmt &Stmt : S) {
     for (MemoryAccess *MA : Stmt) {
-      isl_set *domcp = Stmt.getDomain().release();
-      isl_map *accdom = MA->getAccessRelation().release();
-
-      accdom = isl_map_intersect_domain(accdom, domcp);
+      isl_set *Dom = Stmt.getDomain().release();
+      isl_map *AccRel = MA->getAccessRelation().release();
+      AccRel = isl_map_intersect_domain(AccRel, Dom);
 
       if (ReductionArrays.count(MA->getScopArrayInfo())) {
-        // Wrap the access domain and adjust the schedule accordingly.
-        //
-        // An access domain like
-        //   Stmt[i0, i1] -> MemAcc_A[i0 + i1]
-        // will be transformed into
-        //   [Stmt[i0, i1] -> MemAcc_A[i0 + i1]] -> MemAcc_A[i0 + i1]
-        //
-        // We collect all the access domains in the ReductionTagMap.
-        // This is used in Dependences::calculateDependences to create
-        // a tagged Schedule tree.
-
         ReductionTagMap =
-            isl_union_map_add_map(ReductionTagMap, isl_map_copy(accdom));
-        accdom = isl_map_range_map(accdom);
+            isl_union_map_add_map(ReductionTagMap, isl_map_copy(AccRel));
+        AccRel = isl_map_range_map(AccRel);
       } else {
-        accdom = tag(accdom, MA, Level);
+        AccRel = tag(AccRel, MA, Level);
         if (Level > Dependences::AL_Statement) {
           isl_map *StmtScheduleMap = Stmt.getSchedule().release();
           assert(StmtScheduleMap &&
-                 "Schedules that contain extension nodes require special "
-                 "handling.");
+                 "Schedules with extension nodes require special handling.");
           isl_map *Schedule = tag(StmtScheduleMap, MA, Level);
           StmtSchedule = isl_union_map_add_map(StmtSchedule, Schedule);
         }
       }
 
-      if (MA->isRead())
-        Read = isl_union_map_add_map(Read, accdom);
-      else if (MA->isMayWrite())
-        MayWrite = isl_union_map_add_map(MayWrite, accdom);
-      else
-        MustWrite = isl_union_map_add_map(MustWrite, accdom);
+      if (MA->isRead()) {
+        Read = isl_union_map_add_map(Read, AccRel);
+      } else if (MA->isMayWrite()) {
+        MayWrite = isl_union_map_add_map(MayWrite, AccRel);
+      } else {
+        MustWrite = isl_union_map_add_map(MustWrite, AccRel);
+      }
     }
 
-    if (!ReductionArrays.empty() && Level == Dependences::AL_Statement)
+    if (!ReductionArrays.empty() && Level == Dependences::AL_Statement) {
       StmtSchedule =
           isl_union_map_add_map(StmtSchedule, Stmt.getSchedule().release());
+    }
   }
 
   StmtSchedule = isl_union_map_intersect_params(
@@ -187,83 +175,31 @@ static void collectInfo(Scop &S, isl_uni
   MayWrite = isl_union_map_coalesce(MayWrite);
 }
 
-/// Fix all dimension of @p Zero to 0 and add it to @p user
 static void fixSetToZero(isl::set Zero, isl::union_set *User) {
-  for (auto i : rangeIslSize(0, Zero.tuple_dim()))
+  for (auto i : rangeIslSize(0, Zero.tuple_dim())) {
     Zero = Zero.fix_si(isl::dim::set, i, 0);
+  }
   *User = User->unite(Zero);
 }
 
-/// Compute the privatization dependences for a given dependency @p Map
-///
-/// Privatization dependences are widened original dependences which originate
-/// or end in a reduction access. To compute them we apply the transitive close
-/// of the reduction dependences (which maps each iteration of a reduction
-/// statement to all following ones) on the RAW/WAR/WAW dependences. The
-/// dependences which start or end at a reduction statement will be extended to
-/// depend on all following reduction statement iterations as well.
-/// Note: "Following" here means according to the reduction dependences.
-///
-/// For the input:
-///
-///  S0:   *sum = 0;
-///        for (int i = 0; i < 1024; i++)
-///  S1:     *sum += i;
-///  S2:   *sum = *sum * 3;
-///
-/// we have the following dependences before we add privatization dependences:
-///
-///   RAW:
-///     { S0[] -> S1[0]; S1[1023] -> S2[] }
-///   WAR:
-///     {  }
-///   WAW:
-///     { S0[] -> S1[0]; S1[1024] -> S2[] }
-///   RED:
-///     { S1[i0] -> S1[1 + i0] : i0 >= 0 and i0 <= 1022 }
-///
-/// and afterwards:
-///
-///   RAW:
-///     { S0[] -> S1[i0] : i0 >= 0 and i0 <= 1023;
-///       S1[i0] -> S2[] : i0 >= 0 and i0 <= 1023}
-///   WAR:
-///     {  }
-///   WAW:
-///     { S0[] -> S1[i0] : i0 >= 0 and i0 <= 1023;
-///       S1[i0] -> S2[] : i0 >= 0 and i0 <= 1023}
-///   RED:
-///     { S1[i0] -> S1[1 + i0] : i0 >= 0 and i0 <= 1022 }
-///
-/// Note: This function also computes the (reverse) transitive closure of the
-///       reduction dependences.
 void Dependences::addPrivatizationDependences() {
   isl_union_map *PrivRAW, *PrivWAW, *PrivWAR;
 
-  // The transitive closure might be over approximated, thus could lead to
-  // dependency cycles in the privatization dependences. To make sure this
-  // will not happen we remove all negative dependences after we computed
-  // the transitive closure.
   TC_RED = isl_union_map_transitive_closure(isl_union_map_copy(RED), nullptr);
 
-  // FIXME: Apply the current schedule instead of assuming the identity schedule
-  //        here. The current approach is only valid as long as we compute the
-  //        dependences only with the initial (identity schedule). Any other
-  //        schedule could change "the direction of the backward dependences" we
-  //        want to eliminate here.
   isl_union_set *UDeltas = isl_union_map_deltas(isl_union_map_copy(TC_RED));
   isl_union_set *Universe = isl_union_set_universe(isl_union_set_copy(UDeltas));
   isl::union_set Zero =
       isl::manage(isl_union_set_empty(isl_union_set_get_space(Universe)));
 
-  for (isl::set Set : isl::manage_copy(Universe).get_set_list())
+  for (isl::set Set : isl::manage_copy(Universe).get_set_list()) {
     fixSetToZero(Set, &Zero);
+  }
 
   isl_union_map *NonPositive =
       isl_union_set_lex_le_union_set(UDeltas, Zero.release());
 
   TC_RED = isl_union_map_subtract(TC_RED, NonPositive);
-
   TC_RED = isl_union_map_union(
       TC_RED, isl_union_map_reverse(isl_union_map_copy(TC_RED)));
   TC_RED = isl_union_map_coalesce(TC_RED);
@@ -290,17 +226,19 @@ static __isl_give isl_union_flow *buildF
                                             __isl_keep isl_union_map *MaySrc,
                                             __isl_keep isl_union_map *Kill,
                                             __isl_keep isl_schedule *Schedule) {
-  isl_union_access_info *AI;
-
-  AI = isl_union_access_info_from_sink(isl_union_map_copy(Snk));
-  if (MaySrc)
+  isl_union_access_info *AI =
+      isl_union_access_info_from_sink(isl_union_map_copy(Snk));
+  if (MaySrc) {
     AI = isl_union_access_info_set_may_source(AI, isl_union_map_copy(MaySrc));
-  if (Src)
+  }
+  if (Src) {
     AI = isl_union_access_info_set_must_source(AI, isl_union_map_copy(Src));
-  if (Kill)
+  }
+  if (Kill) {
     AI = isl_union_access_info_set_kill(AI, isl_union_map_copy(Kill));
+  }
   AI = isl_union_access_info_set_schedule(AI, isl_schedule_copy(Schedule));
-  auto Flow = isl_union_access_info_compute_flow(AI);
+  isl_union_flow *Flow = isl_union_access_info_compute_flow(AI);
   POLLY_DEBUG(if (!Flow) dbgs()
                   << "last error: "
                   << isl_ctx_last_error(isl_schedule_get_ctx(Schedule))
@@ -330,7 +268,6 @@ void Dependences::calculateDependences(S
 
   if (!HasReductions) {
     isl_union_map_free(ReductionTagMap);
-    // Tag the schedule tree if we want fine-grain dependence info
     if (Level > AL_Statement) {
       auto TaggedMap =
           isl_union_set_unwrap(isl_union_set_copy(TaggedStmtDomain));
@@ -341,23 +278,11 @@ void Dependences::calculateDependences(S
     isl_union_map *IdentityMap;
     isl_union_pw_multi_aff *ReductionTags, *IdentityTags, *Tags;
 
-    // Extract Reduction tags from the combined access domains in the given
-    // SCoP. The result is a map that maps each tagged element in the domain to
-    // the memory location it accesses. ReductionTags = {[Stmt[i] ->
-    // Array[f(i)]] -> Stmt[i] }
     ReductionTags =
         isl_union_map_domain_map_union_pw_multi_aff(ReductionTagMap);
-
-    // Compute an identity map from each statement in domain to itself.
-    // IdentityTags = { [Stmt[i] -> Stmt[i] }
     IdentityMap = isl_union_set_identity(isl_union_set_copy(TaggedStmtDomain));
     IdentityTags = isl_union_pw_multi_aff_from_union_map(IdentityMap);
-
     Tags = isl_union_pw_multi_aff_union_add(ReductionTags, IdentityTags);
-
-    // By pulling back Tags from Schedule, we have a schedule tree that can
-    // be used to compute normal dependences, as well as 'tagged' reduction
-    // dependences.
     Schedule = isl_schedule_pullback_union_pw_multi_aff(Schedule, Tags);
   }
 
@@ -368,101 +293,55 @@ void Dependences::calculateDependences(S
 
   isl_union_map *StrictWAW = nullptr;
   {
-    IslMaxOperationsGuard MaxOpGuard(IslCtx.get(), OptComputeOut);
+    isl_ctx *Ctx = IslCtx.get();
+    auto OldOnError = isl_options_get_on_error(Ctx);
+    isl_options_set_on_error(Ctx, ISL_ON_ERROR_CONTINUE);
+
+    IslMaxOperationsGuard MaxOpGuard(Ctx, OptComputeOut);
 
     RAW = WAW = WAR = RED = nullptr;
+
     isl_union_map *Write = isl_union_map_union(isl_union_map_copy(MustWrite),
                                                isl_union_map_copy(MayWrite));
 
-    // We are interested in detecting reductions that do not have intermediate
-    // computations that are captured by other statements.
-    //
-    // Example:
-    // void f(int *A, int *B) {
-    //     for(int i = 0; i <= 100; i++) {
-    //
-    //            *-WAR (S0[i] -> S0[i + 1] 0 <= i <= 100)------------*
-    //            |                                                   |
-    //            *-WAW (S0[i] -> S0[i + 1] 0 <= i <= 100)------------*
-    //            |                                                   |
-    //            v                                                   |
-    //     S0:    *A += i; >------------------*-----------------------*
-    //                                        |
-    //         if (i >= 98) {          WAR (S0[i] -> S1[i]) 98 <= i <= 100
-    //                                        |
-    //     S1:        *B = *A; <--------------*
-    //         }
-    //     }
-    // }
-    //
-    // S0[0 <= i <= 100] has a reduction. However, the values in
-    // S0[98 <= i <= 100] is captured in S1[98 <= i <= 100].
-    // Since we allow free reordering on our reduction dependences, we need to
-    // remove all instances of a reduction statement that have data dependences
-    // originating from them.
-    // In the case of the example, we need to remove S0[98 <= i <= 100] from
-    // our reduction dependences.
-    //
-    // When we build up the WAW dependences that are used to detect reductions,
-    // we consider only **Writes that have no intermediate Reads**.
-    //
-    // `isl_union_flow_get_must_dependence` gives us dependences of the form:
-    // (sink <- must_source).
-    //
-    // It *will not give* dependences of the form:
-    // 1. (sink <- ... <- may_source <- ... <- must_source)
-    // 2. (sink <- ... <- must_source <- ... <- must_source)
-    //
-    // For a detailed reference on ISL's flow analysis, see:
-    // "Presburger Formulas and Polyhedral Compilation" - Approximate Dataflow
-    //  Analysis.
-    //
-    // Since we set "Write" as a must-source, "Read" as a may-source, and ask
-    // for must dependences, we get all Writes to Writes that **do not flow
-    // through a Read**.
-    //
-    // ScopInfo::checkForReductions makes sure that if something captures
-    // the reduction variable in the same basic block, then it is rejected
-    // before it is even handed here. This makes sure that there is exactly
-    // one read and one write to a reduction variable in a Statement.
-    // Example:
-    //     void f(int *sum, int A[N], int B[N]) {
-    //       for (int i = 0; i < N; i++) {
-    //         *sum += A[i]; < the store and the load is not tagged as a
-    //         B[i] = *sum;  < reduction-like access due to the overlap.
-    //       }
-    //     }
-
-    isl_union_flow *Flow = buildFlow(Write, Write, Read, nullptr, Schedule);
-    StrictWAW = isl_union_flow_get_must_dependence(Flow);
-    isl_union_flow_free(Flow);
+    if (HasReductions) {
+      isl_union_flow *FlowSW = buildFlow(Write, Write, Read, nullptr, Schedule);
+      StrictWAW = FlowSW ? isl_union_flow_get_must_dependence(FlowSW) : nullptr;
+      isl_union_flow_free(FlowSW);
+    } else {
+      StrictWAW = emptyUMapWithParamSpace(S);
+    }
 
     if (OptAnalysisType == VALUE_BASED_ANALYSIS) {
-      Flow = buildFlow(Read, MustWrite, MayWrite, nullptr, Schedule);
-      RAW = isl_union_flow_get_may_dependence(Flow);
-      isl_union_flow_free(Flow);
-
-      Flow = buildFlow(Write, MustWrite, MayWrite, nullptr, Schedule);
-      WAW = isl_union_flow_get_may_dependence(Flow);
-      isl_union_flow_free(Flow);
-
-      // ISL now supports "kills" in approximate dataflow analysis, we can
-      // specify the MustWrite as kills, Read as source and Write as sink.
-      Flow = buildFlow(Write, nullptr, Read, MustWrite, Schedule);
-      WAR = isl_union_flow_get_may_dependence(Flow);
-      isl_union_flow_free(Flow);
+      isl_union_flow *FlowRAW =
+          buildFlow(Read, MustWrite, MayWrite, nullptr, Schedule);
+      RAW = FlowRAW ? isl_union_flow_get_may_dependence(FlowRAW) : nullptr;
+      isl_union_flow_free(FlowRAW);
+
+      isl_union_flow *FlowWAW =
+          buildFlow(Write, MustWrite, MayWrite, nullptr, Schedule);
+      WAW = FlowWAW ? isl_union_flow_get_may_dependence(FlowWAW) : nullptr;
+      isl_union_flow_free(FlowWAW);
+
+      isl_union_flow *FlowWAR =
+          buildFlow(Write, nullptr, Read, MustWrite, Schedule);
+      WAR = FlowWAR ? isl_union_flow_get_may_dependence(FlowWAR) : nullptr;
+      isl_union_flow_free(FlowWAR);
     } else {
-      Flow = buildFlow(Read, nullptr, Write, nullptr, Schedule);
-      RAW = isl_union_flow_get_may_dependence(Flow);
-      isl_union_flow_free(Flow);
-
-      Flow = buildFlow(Write, nullptr, Read, nullptr, Schedule);
-      WAR = isl_union_flow_get_may_dependence(Flow);
-      isl_union_flow_free(Flow);
-
-      Flow = buildFlow(Write, nullptr, Write, nullptr, Schedule);
-      WAW = isl_union_flow_get_may_dependence(Flow);
-      isl_union_flow_free(Flow);
+      isl_union_flow *FlowRAW =
+          buildFlow(Read, nullptr, Write, nullptr, Schedule);
+      RAW = FlowRAW ? isl_union_flow_get_may_dependence(FlowRAW) : nullptr;
+      isl_union_flow_free(FlowRAW);
+
+      isl_union_flow *FlowWAR =
+          buildFlow(Write, nullptr, Read, nullptr, Schedule);
+      WAR = FlowWAR ? isl_union_flow_get_may_dependence(FlowWAR) : nullptr;
+      isl_union_flow_free(FlowWAR);
+
+      isl_union_flow *FlowWAW =
+          buildFlow(Write, nullptr, Write, nullptr, Schedule);
+      WAW = FlowWAW ? isl_union_flow_get_may_dependence(FlowWAW) : nullptr;
+      isl_union_flow_free(FlowWAW);
     }
 
     isl_union_map_free(Write);
@@ -471,25 +350,21 @@ void Dependences::calculateDependences(S
     isl_union_map_free(Read);
     isl_schedule_free(Schedule);
 
+    ensureNonNullUM(RAW, S);
+    ensureNonNullUM(WAW, S);
+    ensureNonNullUM(WAR, S);
+    ensureNonNullUM(StrictWAW, S);
+
     RAW = isl_union_map_coalesce(RAW);
     WAW = isl_union_map_coalesce(WAW);
     WAR = isl_union_map_coalesce(WAR);
 
-    // End of max_operations scope.
-  }
-
-  if (isl_ctx_last_error(IslCtx.get()) == isl_error_quota) {
-    isl_union_map_free(RAW);
-    isl_union_map_free(WAW);
-    isl_union_map_free(WAR);
-    isl_union_map_free(StrictWAW);
-    RAW = WAW = WAR = StrictWAW = nullptr;
-    isl_ctx_reset_error(IslCtx.get());
+    if (isl_ctx_last_error(Ctx) == isl_error_quota) {
+      isl_ctx_reset_error(Ctx);
+    }
+    isl_options_set_on_error(Ctx, OldOnError);
   }
 
-  // Drop out early, as the remaining computations are only needed for
-  // reduction dependences or dependences that are finer than statement
-  // level dependences.
   if (!HasReductions && Level == AL_Statement) {
     RED = isl_union_map_empty(isl_union_map_get_space(RAW));
     TC_RED = isl_union_map_empty(isl_union_set_get_space(TaggedStmtDomain));
@@ -505,32 +380,13 @@ void Dependences::calculateDependences(S
       isl_union_map_copy(WAW), isl_union_set_copy(TaggedStmtDomain));
   STMT_WAR =
       isl_union_map_intersect_domain(isl_union_map_copy(WAR), TaggedStmtDomain);
-  POLLY_DEBUG({
-    dbgs() << "Wrapped Dependences:\n";
-    dump();
-    dbgs() << "\n";
-  });
-
-  // To handle reduction dependences we proceed as follows:
-  // 1) Aggregate all possible reduction dependences, namely all self
-  //    dependences on reduction like statements.
-  // 2) Intersect them with the actual RAW & WAW dependences to the get the
-  //    actual reduction dependences. This will ensure the load/store memory
-  //    addresses were __identical__ in the two iterations of the statement.
-  // 3) Relax the original RAW, WAW and WAR dependences by subtracting the
-  //    actual reduction dependences. Binary reductions (sum += A[i]) cause
-  //    the same, RAW, WAW and WAR dependences.
-  // 4) Add the privatization dependences which are widened versions of
-  //    already present dependences. They model the effect of manual
-  //    privatization at the outermost possible place (namely after the last
-  //    write and before the first access to a reduction location).
 
-  // Step 1)
   RED = isl_union_map_empty(isl_union_map_get_space(RAW));
   for (ScopStmt &Stmt : S) {
     for (MemoryAccess *MA : Stmt) {
-      if (!MA->isReductionLike())
+      if (!MA->isReductionLike()) {
         continue;
+      }
       isl_set *AccDomW = isl_map_wrap(MA->getAccessRelation().release());
       isl_map *Identity =
           isl_map_from_domain_and_range(isl_set_copy(AccDomW), AccDomW);
@@ -538,21 +394,17 @@ void Dependences::calculateDependences(S
     }
   }
 
-  // Step 2)
   RED = isl_union_map_intersect(RED, isl_union_map_copy(RAW));
   RED = isl_union_map_intersect(RED, StrictWAW);
 
   if (!isl_union_map_is_empty(RED)) {
-
-    // Step 3)
     RAW = isl_union_map_subtract(RAW, isl_union_map_copy(RED));
     WAW = isl_union_map_subtract(WAW, isl_union_map_copy(RED));
     WAR = isl_union_map_subtract(WAR, isl_union_map_copy(RED));
-
-    // Step 4)
     addPrivatizationDependences();
-  } else
+  } else {
     TC_RED = isl_union_map_empty(isl_union_map_get_space(RED));
+  }
 
   POLLY_DEBUG({
     dbgs() << "Final Wrapped Dependences:\n";
@@ -560,22 +412,13 @@ void Dependences::calculateDependences(S
     dbgs() << "\n";
   });
 
-  // RED_SIN is used to collect all reduction dependences again after we
-  // split them according to the causing memory accesses. The current assumption
-  // is that our method of splitting will not have any leftovers. In the end
-  // we validate this assumption until we have more confidence in this method.
   isl_union_map *RED_SIN = isl_union_map_empty(isl_union_map_get_space(RAW));
 
-  // For each reduction like memory access, check if there are reduction
-  // dependences with the access relation of the memory access as a domain
-  // (wrapped space!). If so these dependences are caused by this memory access.
-  // We then move this portion of reduction dependences back to the statement ->
-  // statement space and add a mapping from the memory access to these
-  // dependences.
   for (ScopStmt &Stmt : S) {
     for (MemoryAccess *MA : Stmt) {
-      if (!MA->isReductionLike())
+      if (!MA->isReductionLike()) {
         continue;
+      }
 
       isl_set *AccDomW = isl_map_wrap(MA->getAccessRelation().release());
       isl_union_map *AccRedDepU = isl_union_map_intersect_domain(
@@ -593,9 +436,10 @@ void Dependences::calculateDependences(S
     }
   }
 
+#ifndef NDEBUG
   assert(isl_union_map_is_equal(RED_SIN, TC_RED) &&
-         "Intersecting the reduction dependence domain with the wrapped access "
-         "relation is not enough, we need to loosen the access relation also");
+         "Unexpected leftover reduction dependences");
+#endif
   isl_union_map_free(RED_SIN);
 
   RAW = isl_union_map_zip(RAW);
@@ -604,24 +448,12 @@ void Dependences::calculateDependences(S
   RED = isl_union_map_zip(RED);
   TC_RED = isl_union_map_zip(TC_RED);
 
-  POLLY_DEBUG({
-    dbgs() << "Zipped Dependences:\n";
-    dump();
-    dbgs() << "\n";
-  });
-
   RAW = isl_union_set_unwrap(isl_union_map_domain(RAW));
   WAW = isl_union_set_unwrap(isl_union_map_domain(WAW));
   WAR = isl_union_set_unwrap(isl_union_map_domain(WAR));
   RED = isl_union_set_unwrap(isl_union_map_domain(RED));
   TC_RED = isl_union_set_unwrap(isl_union_map_domain(TC_RED));
 
-  POLLY_DEBUG({
-    dbgs() << "Unwrapped Dependences:\n";
-    dump();
-    dbgs() << "\n";
-  });
-
   RAW = isl_union_map_union(RAW, STMT_RAW);
   WAW = isl_union_map_union(WAW, STMT_WAW);
   WAR = isl_union_map_union(WAR, STMT_WAR);
@@ -636,42 +468,39 @@ void Dependences::calculateDependences(S
 }
 
 bool Dependences::isValidSchedule(Scop &S, isl::schedule NewSched) const {
-  // TODO: Also check permutable/coincident flags as well.
-
   StatementToIslMapTy NewSchedules;
   for (auto NewMap : NewSched.get_map().get_map_list()) {
     auto Stmt = reinterpret_cast<ScopStmt *>(
         NewMap.get_tuple_id(isl::dim::in).get_user());
     NewSchedules[Stmt] = NewMap;
   }
-
   return isValidSchedule(S, NewSchedules);
 }
 
 bool Dependences::isValidSchedule(
     Scop &S, const StatementToIslMapTy &NewSchedule) const {
-  if (LegalityCheckDisabled)
+  if (LegalityCheckDisabled) {
     return true;
+  }
 
   isl::union_map Dependences = getDependences(TYPE_RAW | TYPE_WAW | TYPE_WAR);
   isl::union_map Schedule = isl::union_map::empty(S.getIslCtx());
-
   isl::space ScheduleSpace;
 
   for (ScopStmt &Stmt : S) {
     isl::map StmtScat;
-
     auto Lookup = NewSchedule.find(&Stmt);
-    if (Lookup == NewSchedule.end())
+    if (Lookup == NewSchedule.end()) {
       StmtScat = Stmt.getSchedule();
-    else
+    } else {
       StmtScat = Lookup->second;
+    }
     assert(!StmtScat.is_null() &&
-           "Schedules that contain extension nodes require special handling.");
+           "Schedules with extension nodes require special handling.");
 
-    if (ScheduleSpace.is_null())
+    if (ScheduleSpace.is_null()) {
       ScheduleSpace = StmtScat.get_space().range();
-
+    }
     Schedule = Schedule.unite(StmtScat);
   }
 
@@ -679,8 +508,9 @@ bool Dependences::isValidSchedule(
   Dependences = Dependences.apply_range(Schedule);
 
   isl::set Zero = isl::set::universe(ScheduleSpace);
-  for (auto i : rangeIslSize(0, Zero.tuple_dim()))
+  for (auto i : rangeIslSize(0, Zero.tuple_dim())) {
     Zero = Zero.fix_si(isl::dim::set, i, 0);
+  }
 
   isl::union_set UDeltas = Dependences.deltas();
   isl::set Deltas = singleton(UDeltas, ScheduleSpace);
@@ -695,24 +525,12 @@ bool Dependences::isValidSchedule(
   return NonPositive.is_empty();
 }
 
-// Check if the current scheduling dimension is parallel.
-//
-// We check for parallelism by verifying that the loop does not carry any
-// dependences.
-//
-// Parallelism test: if the distance is zero in all outer dimensions, then it
-// has to be zero in the current dimension as well.
-//
-// Implementation: first, translate dependences into time space, then force
-// outer dimensions to be equal. If the distance is zero in the current
-// dimension, then the loop is parallel. The distance is zero in the current
-// dimension if it is a subset of a map with equal values for the current
-// dimension.
 bool Dependences::isParallel(__isl_keep isl_union_map *Schedule,
                              __isl_take isl_union_map *Deps,
                              __isl_give isl_pw_aff **MinDistancePtr) const {
   isl_set *Deltas, *Distance;
   isl_map *ScheduleDeps;
+  unsigned OutDim;
   unsigned Dimension;
   bool IsParallel;
 
@@ -725,17 +543,23 @@ bool Dependences::isParallel(__isl_keep
   }
 
   ScheduleDeps = isl_map_from_union_map(Deps);
-  Dimension = isl_map_dim(ScheduleDeps, isl_dim_out) - 1;
+  OutDim = isl_map_dim(ScheduleDeps, isl_dim_out);
+  if (OutDim == 0) {
+    isl_map_free(ScheduleDeps);
+    return true;
+  }
+  Dimension = OutDim - 1;
 
-  for (unsigned i = 0; i < Dimension; i++)
+  for (unsigned i = 0; i < Dimension; i++) {
     ScheduleDeps = isl_map_equate(ScheduleDeps, isl_dim_out, i, isl_dim_in, i);
+  }
 
   Deltas = isl_map_deltas(ScheduleDeps);
   Distance = isl_set_universe(isl_set_get_space(Deltas));
 
-  // [0, ..., 0, +] - All zeros and last dimension larger than zero
-  for (unsigned i = 0; i < Dimension; i++)
+  for (unsigned i = 0; i < Dimension; i++) {
     Distance = isl_set_fix_si(Distance, isl_dim_set, i, 0);
+  }
 
   Distance = isl_set_lower_bound_si(Distance, isl_dim_set, Dimension, 1);
   Distance = isl_set_intersect(Distance, Deltas);
@@ -748,20 +572,17 @@ bool Dependences::isParallel(__isl_keep
 
   Distance = isl_set_project_out(Distance, isl_dim_set, 0, Dimension);
   Distance = isl_set_coalesce(Distance);
-
-  // This last step will compute a expression for the minimal value in the
-  // distance polyhedron Distance with regards to the first (outer most)
-  // dimension.
   *MinDistancePtr = isl_pw_aff_coalesce(isl_set_dim_min(Distance, 0));
 
   return false;
 }
 
 static void printDependencyMap(raw_ostream &OS, __isl_keep isl_union_map *DM) {
-  if (DM)
+  if (DM) {
     OS << DM << "\n";
-  else
+  } else {
     OS << "n/a\n";
+  }
 }
 
 void Dependences::print(raw_ostream &OS) const {
@@ -788,8 +609,9 @@ void Dependences::releaseMemory() {
 
   RED = RAW = WAR = WAW = TC_RED = nullptr;
 
-  for (auto &ReductionDeps : ReductionDependences)
+  for (auto &ReductionDeps : ReductionDependences) {
     isl_map_free(ReductionDeps.second);
+  }
   ReductionDependences.clear();
 }
 
@@ -798,20 +620,21 @@ isl::union_map Dependences::getDependenc
   isl::space Space = isl::manage_copy(RAW).get_space();
   isl::union_map Deps = Deps.empty(Space.ctx());
 
-  if (Kinds & TYPE_RAW)
+  if (Kinds & TYPE_RAW) {
     Deps = Deps.unite(isl::manage_copy(RAW));
-
-  if (Kinds & TYPE_WAR)
+  }
+  if (Kinds & TYPE_WAR) {
     Deps = Deps.unite(isl::manage_copy(WAR));
-
-  if (Kinds & TYPE_WAW)
+  }
+  if (Kinds & TYPE_WAW) {
     Deps = Deps.unite(isl::manage_copy(WAW));
-
-  if (Kinds & TYPE_RED)
+  }
+  if (Kinds & TYPE_RED) {
     Deps = Deps.unite(isl::manage_copy(RED));
-
-  if (Kinds & TYPE_TC_RED)
+  }
+  if (Kinds & TYPE_TC_RED) {
     Deps = Deps.unite(isl::manage_copy(TC_RED));
+  }
 
   Deps = Deps.coalesce();
   Deps = Deps.detect_equalities();
@@ -836,9 +659,9 @@ void Dependences::setReductionDependence
 
 const Dependences &
 DependenceAnalysis::Result::getDependences(Dependences::AnalysisLevel Level) {
-  if (Dependences *d = D[Level].get())
+  if (Dependences *d = D[Level].get()) {
     return *d;
-
+  }
   return recomputeDependences(Level);
 }
 
@@ -850,8 +673,9 @@ const Dependences &DependenceAnalysis::R
 }
 
 void DependenceAnalysis::Result::abandonDependences() {
-  for (std::unique_ptr<Dependences> &Deps : D)
+  for (std::unique_ptr<Dependences> &Deps : D) {
     Deps.release();
+  }
 }
 
 DependenceAnalysis::Result
@@ -873,7 +697,6 @@ DependenceInfoPrinterPass::run(Scop &S,
     return PreservedAnalyses::all();
   }
 
-  // Otherwise create the dependences on-the-fly and print them
   Dependences D(S.getSharedIslCtx(), OptAnalysisLevel);
   D.calculateDependences(S);
   D.print(OS);
@@ -883,9 +706,9 @@ DependenceInfoPrinterPass::run(Scop &S,
 
 const Dependences &
 DependenceInfo::getDependences(Dependences::AnalysisLevel Level) {
-  if (Dependences *d = D[Level].get())
+  if (Dependences *d = D[Level].get()) {
     return *d;
-
+  }
   return recomputeDependences(Level);
 }
 
@@ -897,8 +720,9 @@ DependenceInfo::recomputeDependences(Dep
 }
 
 void DependenceInfo::abandonDependences() {
-  for (std::unique_ptr<Dependences> &Deps : D)
+  for (std::unique_ptr<Dependences> &Deps : D) {
     Deps.release();
+  }
 }
 
 bool DependenceInfo::runOnScop(Scop &ScopVar) {
@@ -906,15 +730,12 @@ bool DependenceInfo::runOnScop(Scop &Sco
   return false;
 }
 
-/// Print the dependences for the given SCoP to @p OS.
-
 void polly::DependenceInfo::printScop(raw_ostream &OS, Scop &S) const {
   if (auto d = D[OptAnalysisLevel].get()) {
     d->print(OS);
     return;
   }
 
-  // Otherwise create the dependences on-the-fly and print it
   Dependences D(S.getSharedIslCtx(), OptAnalysisLevel);
   D.calculateDependences(S);
   D.print(OS);
@@ -938,7 +759,6 @@ INITIALIZE_PASS_END(DependenceInfo, "pol
 //===----------------------------------------------------------------------===//
 
 namespace {
-/// Print result from DependenceAnalysis.
 class DependenceInfoPrinterLegacyPass final : public ScopPass {
 public:
   static char ID;
@@ -989,11 +809,13 @@ const Dependences &
 DependenceInfoWrapperPass::getDependences(Scop *S,
                                           Dependences::AnalysisLevel Level) {
   auto It = ScopToDepsMap.find(S);
-  if (It != ScopToDepsMap.end())
+  if (It != ScopToDepsMap.end()) {
     if (It->second) {
-      if (It->second->getDependenceLevel() == Level)
+      if (It->second->getDependenceLevel() == Level) {
         return *It->second;
+      }
     }
+  }
   return recomputeDependences(S, Level);
 }
 
@@ -1045,7 +867,6 @@ INITIALIZE_PASS_END(
 //===----------------------------------------------------------------------===//
 
 namespace {
-/// Print result from DependenceInfoWrapperPass.
 class DependenceInfoPrinterLegacyFunctionPass final : public FunctionPass {
 public:
   static char ID;
