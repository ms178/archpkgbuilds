From: patphzhang <patphzhang@tencent.com>
Date: Thu, 7 Nov 2024 11:13:49 +0800
Subject: [PATCH 1/7] [BOLT] support mold linker generated PLT in disassembling

---
 bolt/include/bolt/Utils/CommandLineOpts.h |   1 +
 bolt/lib/Rewrite/RewriteInstance.cpp      |  30 +-
 bolt/lib/Utils/CommandLineOpts.cpp        |   6 +
 bolt/test/X86/Inputs/plt-mold-header.yaml | 399 ++++++++++++++++++++++
 bolt/test/X86/plt-mold-header.test        |   7 +
 5 files changed, 442 insertions(+), 1 deletion(-)
 create mode 100644 bolt/test/X86/Inputs/plt-mold-header.yaml
 create mode 100644 bolt/test/X86/plt-mold-header.test

diff --git a/bolt/include/bolt/Utils/CommandLineOpts.h b/bolt/include/bolt/Utils/CommandLineOpts.h
index 04bf7db5de9527..3b0c0db1bd089e 100644
--- a/bolt/include/bolt/Utils/CommandLineOpts.h
+++ b/bolt/include/bolt/Utils/CommandLineOpts.h
@@ -34,6 +34,7 @@ extern llvm::cl::opt<bool> AggregateOnly;
 extern llvm::cl::opt<unsigned> BucketsPerLine;
 extern llvm::cl::opt<bool> DiffOnly;
 extern llvm::cl::opt<bool> EnableBAT;
+extern llvm::cl::opt<bool> UseMold;
 extern llvm::cl::opt<bool> EqualizeBBCounts;
 extern llvm::cl::opt<bool> RemoveSymtab;
 extern llvm::cl::opt<unsigned> ExecutionCountThreshold;
diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 32ec7abe8b666a..a7118be5dc263a 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -1672,7 +1672,35 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
   const uint64_t SectionAddress = Section.getAddress();
   const uint64_t SectionSize = Section.getSize();
 
-  for (uint64_t EntryOffset = 0; EntryOffset + EntrySize <= SectionSize;
+  uint64_t EntryStartOffset = 0;
+  if (opts::UseMold) {
+    // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
+    // generates a unique format for the PLT.
+    // The first entry of the mold-style PLT is 32 bytes long, while the remaining entries
+    // are 16 bytes long. We need to parse the first entry with a special offset limit setting.
+    uint64_t HeaderSize = 32;
+    outs() << "BOLT-INFO: parsing PLT header for mold\n";
+    MCInst Instruction;
+    uint64_t InstrSize, InstrOffset = EntryStartOffset;
+    while (InstrOffset < HeaderSize) {
+      disassemblePLTInstruction(Section, InstrOffset, Instruction, InstrSize);
+      if (BC->MIB->isIndirectBranch(Instruction))
+        break;
+      InstrOffset += InstrSize;
+    }
+    uint64_t TargetAddress;
+    if (!BC->MIB->evaluateMemOperandTarget(Instruction, TargetAddress,
+                                            SectionAddress + InstrOffset,
+                                            InstrSize)) {
+      errs() << "BOLT-ERROR: error evaluating PLT instruction for the mold header at offset 0x"
+                  << Twine::utohexstr(SectionAddress + InstrOffset) << '\n';
+      exit(1);
+    }
+    createPLTBinaryFunction(TargetAddress, SectionAddress, HeaderSize);
+    EntryStartOffset += HeaderSize;
+  }
+
+  for (uint64_t EntryOffset = EntryStartOffset; EntryOffset + EntrySize <= SectionSize;
        EntryOffset += EntrySize) {
     MCInst Instruction;
     uint64_t InstrSize, InstrOffset = EntryOffset;
diff --git a/bolt/lib/Utils/CommandLineOpts.cpp b/bolt/lib/Utils/CommandLineOpts.cpp
index de82420a167131..356e530c9ca361 100644
--- a/bolt/lib/Utils/CommandLineOpts.cpp
+++ b/bolt/lib/Utils/CommandLineOpts.cpp
@@ -72,6 +72,12 @@ EnableBAT("enable-bat",
   cl::ZeroOrMore,
   cl::cat(BoltCategory));
 
+cl::opt<bool> UseMold("use-mold",
+  cl::desc("the binary is generated by the mold linker"),
+  cl::init(false),
+  cl::ZeroOrMore,
+  cl::cat(BoltCategory));
+
 cl::opt<bool> EqualizeBBCounts(
     "equalize-bb-counts",
     cl::desc("use same count for BBs that should have equivalent count (used "
diff --git a/bolt/test/X86/Inputs/plt-mold-header.yaml b/bolt/test/X86/Inputs/plt-mold-header.yaml
new file mode 100644
index 00000000000000..be6eabeccbba8f
--- /dev/null
+++ b/bolt/test/X86/Inputs/plt-mold-header.yaml
@@ -0,0 +1,399 @@
+--- !ELF
+FileHeader:
+  Class:           ELFCLASS64
+  Data:            ELFDATA2LSB
+  Type:            ET_DYN
+  Machine:         EM_X86_64
+  Entry:           0x13D0
+ProgramHeaders:
+  - Type:            PT_PHDR
+    Flags:           [ PF_R ]
+    VAddr:           0x40
+    Align:           0x8
+  - Type:            PT_INTERP
+    Flags:           [ PF_R ]
+    FirstSec:        .interp
+    LastSec:         .interp
+    VAddr:           0x270
+  - Type:            PT_LOAD
+    Flags:           [ PF_R ]
+    FirstSec:        .interp
+    LastSec:         .rodata.str
+    Align:           0x1000
+  - Type:            PT_LOAD
+    Flags:           [ PF_X, PF_R ]
+    FirstSec:        .plt
+    LastSec:         .text
+    VAddr:           0x13A0
+    Align:           0x1000
+  - Type:            PT_LOAD
+    Flags:           [ PF_W, PF_R ]
+    FirstSec:        .dynamic
+    LastSec:         .relro_padding
+    VAddr:           0x23F8
+    Align:           0x1000
+  - Type:            PT_LOAD
+    Flags:           [ PF_W, PF_R ]
+    FirstSec:        .got.plt
+    LastSec:         .got.plt
+    VAddr:           0x3550
+    Align:           0x1000
+  - Type:            PT_DYNAMIC
+    Flags:           [ PF_W, PF_R ]
+    FirstSec:        .dynamic
+    LastSec:         .dynamic
+    VAddr:           0x23F8
+    Align:           0x8
+  - Type:            PT_GNU_EH_FRAME
+    Flags:           [ PF_R ]
+    FirstSec:        .eh_frame_hdr
+    LastSec:         .eh_frame_hdr
+    VAddr:           0x37C
+    Align:           0x4
+  - Type:            PT_GNU_STACK
+    Flags:           [ PF_W, PF_R ]
+  - Type:            PT_GNU_RELRO
+    Flags:           [ PF_R ]
+    FirstSec:        .dynamic
+    LastSec:         .relro_padding
+    VAddr:           0x23F8
+Sections:
+  - Name:            .interp
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x270
+    AddressAlign:    0x1
+    Content:         2F6C696236342F6C642D6C696E75782D7838362D36342E736F2E3200
+  - Name:            .gnu.hash
+    Type:            SHT_GNU_HASH
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x290
+    Link:            .dynsym
+    AddressAlign:    0x8
+    Header:
+      SymNdx:          0x2
+      Shift2:          0x1A
+    BloomFilter:     [ 0x0 ]
+    HashBuckets:     [ 0x0 ]
+    HashValues:      [  ]
+  - Name:            .dynsym
+    Type:            SHT_DYNSYM
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x2B0
+    Link:            .dynstr
+    AddressAlign:    0x8
+  - Name:            .dynstr
+    Type:            SHT_STRTAB
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x2E0
+    AddressAlign:    0x1
+  - Name:            .gnu.version
+    Type:            SHT_GNU_versym
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x2FE
+    Link:            .dynsym
+    AddressAlign:    0x2
+    Entries:         [ 0, 2 ]
+  - Name:            .gnu.version_r
+    Type:            SHT_GNU_verneed
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x308
+    Link:            .dynstr
+    AddressAlign:    0x8
+    Dependencies:
+      - Version:         1
+        File:            libc.so.6
+        Entries:
+          - Name:            GLIBC_2.2.5
+            Hash:            157882997
+            Flags:           0
+            Other:           2
+  - Name:            .rela.plt
+    Type:            SHT_RELA
+    Flags:           [ SHF_ALLOC, SHF_INFO_LINK ]
+    Address:         0x328
+    Link:            .dynsym
+    AddressAlign:    0x8
+    Info:            .got.plt
+    Relocations:
+      - Offset:          0x3568
+        Symbol:          printf
+        Type:            R_X86_64_JUMP_SLOT
+  - Name:            .eh_frame
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x340
+    AddressAlign:    0x8
+    Content:         1400000000000000017A5200017810011B0C0708900100001C0000001C000000701000002500000000410E108602430D06600C070800000000000000
+  - Name:            .eh_frame_hdr
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x37C
+    AddressAlign:    0x4
+    Content:         011B033BC0FFFFFF0100000054100000DCFFFFFF
+  - Name:            .rodata.str
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_ALLOC ]
+    Address:         0x390
+    AddressAlign:    0x1
+    Content:         48656C6C6F20776F726C64210A00
+  - Name:            .plt
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_ALLOC, SHF_EXECINSTR ]
+    Address:         0x13A0
+    AddressAlign:    0x10
+    Content:         F30F1EFA4153FF35CC3C1602FF25CE3C1602CCCCCCCCCCCCCCCCCCCCCCCCCCCCF30F1EFA41BB00000000FF2598210000
+  - Name:            .text
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_ALLOC, SHF_EXECINSTR ]
+    Address:         0x13D0
+    AddressAlign:    0x10
+    Content:         554889E54883EC10C745FC00000000488D3DAAEFFFFFB000E8D3FFFFFF31C04883C4105DC3
+  - Name:            .dynamic
+    Type:            SHT_DYNAMIC
+    Flags:           [ SHF_WRITE, SHF_ALLOC ]
+    Address:         0x23F8
+    Link:            .dynstr
+    AddressAlign:    0x8
+    Entries:
+      - Tag:             DT_NEEDED
+        Value:           0x1
+      - Tag:             DT_JMPREL
+        Value:           0x328
+      - Tag:             DT_PLTRELSZ
+        Value:           0x18
+      - Tag:             DT_PLTREL
+        Value:           0x7
+      - Tag:             DT_PLTGOT
+        Value:           0x3550
+      - Tag:             DT_SYMTAB
+        Value:           0x2B0
+      - Tag:             DT_SYMENT
+        Value:           0x18
+      - Tag:             DT_STRTAB
+        Value:           0x2E0
+      - Tag:             DT_STRSZ
+        Value:           0x1E
+      - Tag:             DT_VERSYM
+        Value:           0x2FE
+      - Tag:             DT_VERNEED
+        Value:           0x308
+      - Tag:             DT_VERNEEDNUM
+        Value:           0x1
+      - Tag:             DT_GNU_HASH
+        Value:           0x290
+      - Tag:             DT_FLAGS_1
+        Value:           0x8000000
+      - Tag:             DT_DEBUG
+        Value:           0x0
+      - Tag:             DT_NULL
+        Value:           0x0
+      - Tag:             DT_NULL
+        Value:           0x0
+      - Tag:             DT_NULL
+        Value:           0x0
+      - Tag:             DT_NULL
+        Value:           0x0
+      - Tag:             DT_NULL
+        Value:           0x0
+      - Tag:             DT_NULL
+        Value:           0x0
+  - Name:            .got
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_WRITE, SHF_ALLOC ]
+    Address:         0x2548
+    AddressAlign:    0x8
+    Content:         '0000000000000000'
+  - Name:            .relro_padding
+    Type:            SHT_NOBITS
+    Flags:           [ SHF_WRITE, SHF_ALLOC ]
+    Address:         0x2550
+    AddressAlign:    0x1
+    Size:            0xAB0
+  - Name:            .got.plt
+    Type:            SHT_PROGBITS
+    Flags:           [ SHF_WRITE, SHF_ALLOC ]
+    Address:         0x3550
+    AddressAlign:    0x8
+    Content:         F82300000000000000000000000000000000000000000000A013000000000000
+  - Name:            .rela.text
+    Type:            SHT_RELA
+    Flags:           [ SHF_INFO_LINK ]
+    Link:            .symtab
+    AddressAlign:    0x8
+    Info:            .text
+    Relocations:
+      - Offset:          0x13E2
+        Symbol:          .L.str
+        Type:            R_X86_64_PC32
+        Addend:          -4
+      - Offset:          0x13E9
+        Symbol:          printf
+        Type:            R_X86_64_PLT32
+        Addend:          -4
+  - Type:            SectionHeaderTable
+    Sections:
+      - Name:            .interp
+      - Name:            .gnu.hash
+      - Name:            .dynsym
+      - Name:            .dynstr
+      - Name:            .gnu.version
+      - Name:            .gnu.version_r
+      - Name:            .rela.plt
+      - Name:            .eh_frame
+      - Name:            .eh_frame_hdr
+      - Name:            .rodata.str
+      - Name:            .plt
+      - Name:            .text
+      - Name:            .rela.text
+      - Name:            .dynamic
+      - Name:            .got
+      - Name:            .relro_padding
+      - Name:            .got.plt
+      - Name:            .symtab
+      - Name:            .strtab
+      - Name:            .shstrtab
+Symbols:
+  - Name:            .interp
+    Type:            STT_SECTION
+    Section:         .interp
+    Value:           0x270
+  - Name:            .gnu.hash
+    Type:            STT_SECTION
+    Section:         .gnu.hash
+    Value:           0x290
+  - Name:            .dynsym
+    Type:            STT_SECTION
+    Section:         .dynsym
+    Value:           0x2B0
+  - Name:            .dynstr
+    Type:            STT_SECTION
+    Section:         .dynstr
+    Value:           0x2E0
+  - Name:            .gnu.version
+    Type:            STT_SECTION
+    Section:         .gnu.version
+    Value:           0x2FE
+  - Name:            .gnu.version_r
+    Type:            STT_SECTION
+    Section:         .gnu.version_r
+    Value:           0x308
+  - Name:            .rela.plt
+    Type:            STT_SECTION
+    Section:         .rela.plt
+    Value:           0x328
+  - Name:            .eh_frame
+    Type:            STT_SECTION
+    Section:         .eh_frame
+    Value:           0x340
+  - Name:            .eh_frame_hdr
+    Type:            STT_SECTION
+    Section:         .eh_frame_hdr
+    Value:           0x37C
+  - Name:            .rodata.str
+    Type:            STT_SECTION
+    Section:         .rodata.str
+    Value:           0x390
+  - Name:            .plt
+    Type:            STT_SECTION
+    Section:         .plt
+    Value:           0x13A0
+  - Name:            .text
+    Type:            STT_SECTION
+    Section:         .text
+    Value:           0x13D0
+  - Name:            .dynamic
+    Type:            STT_SECTION
+    Section:         .dynamic
+    Value:           0x23F8
+  - Name:            .got
+    Type:            STT_SECTION
+    Section:         .got
+    Value:           0x2548
+  - Name:            .relro_padding
+    Type:            STT_SECTION
+    Section:         .relro_padding
+    Value:           0x2550
+  - Name:            .got.plt
+    Type:            STT_SECTION
+    Section:         .got.plt
+    Value:           0x3550
+  - Name:            'printf$plt'
+    Type:            STT_FUNC
+    Section:         .plt
+    Value:           0x13C0
+  - Name:            hello.c
+    Type:            STT_FILE
+    Index:           SHN_ABS
+  - Name:            .L.str
+    Type:            STT_OBJECT
+    Section:         .rodata.str
+    Value:           0x390
+  - Name:            main
+    Type:            STT_FUNC
+    Section:         .text
+    Value:           0x13D0
+    Size:            0x25
+  - Name:            __ehdr_start
+    Section:         .interp
+  - Name:            __init_array_start
+    Index:           SHN_ABS
+  - Name:            __init_array_end
+    Index:           SHN_ABS
+  - Name:            __fini_array_start
+    Index:           SHN_ABS
+  - Name:            __fini_array_end
+    Index:           SHN_ABS
+  - Name:            __preinit_array_start
+    Index:           SHN_ABS
+  - Name:            __preinit_array_end
+    Index:           SHN_ABS
+  - Name:            _DYNAMIC
+    Section:         .dynamic
+    Value:           0x23F8
+  - Name:            _GLOBAL_OFFSET_TABLE_
+    Section:         .got.plt
+    Value:           0x3550
+  - Name:            _PROCEDURE_LINKAGE_TABLE_
+    Section:         .plt
+    Value:           0x13A0
+  - Name:            __bss_start
+    Index:           SHN_ABS
+  - Name:            _end
+    Section:         .got.plt
+    Value:           0x3570
+  - Name:            _etext
+    Section:         .text
+    Value:           0x13F5
+  - Name:            _edata
+    Section:         .got.plt
+    Value:           0x3570
+  - Name:            __executable_start
+    Section:         .interp
+  - Name:            __rela_iplt_start
+    Index:           SHN_ABS
+  - Name:            __rela_iplt_end
+    Index:           SHN_ABS
+  - Name:            __GNU_EH_FRAME_HDR
+    Section:         .eh_frame_hdr
+    Value:           0x37C
+  - Name:            end
+    Section:         .got.plt
+    Value:           0x3570
+  - Name:            etext
+    Section:         .text
+    Value:           0x13F5
+  - Name:            edata
+    Section:         .got.plt
+    Value:           0x3570
+  - Name:            __dso_handle
+    Section:         .interp
+  - Name:            _TLS_MODULE_BASE_
+    Section:         .interp
+  - Name:            printf
+    Binding:         STB_GLOBAL
+DynamicSymbols:
+  - Name:            printf
+    Type:            STT_FUNC
+    Binding:         STB_GLOBAL
+...
diff --git a/bolt/test/X86/plt-mold-header.test b/bolt/test/X86/plt-mold-header.test
new file mode 100644
index 00000000000000..8cbbed8711cbce
--- /dev/null
+++ b/bolt/test/X86/plt-mold-header.test
@@ -0,0 +1,7 @@
+# RUN: yaml2obj %p/Inputs/plt-mold-header.yaml &> %t.exe
+# RUN: llvm-bolt -use-mold %t.exe --print-cfg --print-only=main.* -o %t.out | FileCheck %s
+
+## Check that llvm-bolt correctly parses PLT header created by mold linker.
+## Without the '-use-mold' option, "BOLT-ERROR: unable to disassemble instruction in PLT section .plt at offset 0x10" will be reported.
+## The only call instruction in main() should be a call to printf() in PLT.
+CHECK:  callq "printf$plt

From fd9dc20eb9e5da903ea593df7c8a774dc481414a Mon Sep 17 00:00:00 2001
From: patphzhang <patphzhang@tencent.com>
Date: Fri, 8 Nov 2024 16:16:02 +0800
Subject: [PATCH 2/7] [BOLT] support mold linker generated PLT in disassembling
 without the new option

---
 bolt/include/bolt/Core/MCPlusBuilder.h    |  5 +++
 bolt/include/bolt/Utils/CommandLineOpts.h |  1 -
 bolt/lib/Rewrite/RewriteInstance.cpp      | 54 ++++++++++-------------
 bolt/lib/Target/X86/X86MCPlusBuilder.cpp  | 23 ++++++++++
 bolt/lib/Utils/CommandLineOpts.cpp        |  6 ---
 5 files changed, 52 insertions(+), 37 deletions(-)

diff --git a/bolt/include/bolt/Core/MCPlusBuilder.h b/bolt/include/bolt/Core/MCPlusBuilder.h
index 32eda0b283b883..2cc94c52f802de 100644
--- a/bolt/include/bolt/Core/MCPlusBuilder.h
+++ b/bolt/include/bolt/Core/MCPlusBuilder.h
@@ -1495,6 +1495,11 @@ class MCPlusBuilder {
     return 0;
   }
 
+  virtual bool isMoldPLTHeader(std::vector<MCInst *> &Insns) const {
+    llvm_unreachable("not implemented");
+    return false;
+  }
+
   virtual bool analyzeVirtualMethodCall(InstructionIterator Begin,
                                         InstructionIterator End,
                                         std::vector<MCInst *> &MethodFetchInsns,
diff --git a/bolt/include/bolt/Utils/CommandLineOpts.h b/bolt/include/bolt/Utils/CommandLineOpts.h
index 3b0c0db1bd089e..04bf7db5de9527 100644
--- a/bolt/include/bolt/Utils/CommandLineOpts.h
+++ b/bolt/include/bolt/Utils/CommandLineOpts.h
@@ -34,7 +34,6 @@ extern llvm::cl::opt<bool> AggregateOnly;
 extern llvm::cl::opt<unsigned> BucketsPerLine;
 extern llvm::cl::opt<bool> DiffOnly;
 extern llvm::cl::opt<bool> EnableBAT;
-extern llvm::cl::opt<bool> UseMold;
 extern llvm::cl::opt<bool> EqualizeBBCounts;
 extern llvm::cl::opt<bool> RemoveSymtab;
 extern llvm::cl::opt<unsigned> ExecutionCountThreshold;
diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index a7118be5dc263a..831880233b3acf 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -1672,35 +1672,7 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
   const uint64_t SectionAddress = Section.getAddress();
   const uint64_t SectionSize = Section.getSize();
 
-  uint64_t EntryStartOffset = 0;
-  if (opts::UseMold) {
-    // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
-    // generates a unique format for the PLT.
-    // The first entry of the mold-style PLT is 32 bytes long, while the remaining entries
-    // are 16 bytes long. We need to parse the first entry with a special offset limit setting.
-    uint64_t HeaderSize = 32;
-    outs() << "BOLT-INFO: parsing PLT header for mold\n";
-    MCInst Instruction;
-    uint64_t InstrSize, InstrOffset = EntryStartOffset;
-    while (InstrOffset < HeaderSize) {
-      disassemblePLTInstruction(Section, InstrOffset, Instruction, InstrSize);
-      if (BC->MIB->isIndirectBranch(Instruction))
-        break;
-      InstrOffset += InstrSize;
-    }
-    uint64_t TargetAddress;
-    if (!BC->MIB->evaluateMemOperandTarget(Instruction, TargetAddress,
-                                            SectionAddress + InstrOffset,
-                                            InstrSize)) {
-      errs() << "BOLT-ERROR: error evaluating PLT instruction for the mold header at offset 0x"
-                  << Twine::utohexstr(SectionAddress + InstrOffset) << '\n';
-      exit(1);
-    }
-    createPLTBinaryFunction(TargetAddress, SectionAddress, HeaderSize);
-    EntryStartOffset += HeaderSize;
-  }
-
-  for (uint64_t EntryOffset = EntryStartOffset; EntryOffset + EntrySize <= SectionSize;
+  for (uint64_t EntryOffset = 0; EntryOffset + EntrySize <= SectionSize;
        EntryOffset += EntrySize) {
     MCInst Instruction;
     uint64_t InstrSize, InstrOffset = EntryOffset;
@@ -1717,8 +1689,30 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
       InstrOffset += InstrSize;
     }
 
-    if (InstrOffset + InstrSize > EntryOffset + EntrySize)
+    if (InstrOffset + InstrSize > EntryOffset + EntrySize) {
+      // Check if it is a mold header before rolling back because the mold linker generates
+      // a unique format. The header entry of the mold-style PLT is 32 bytes long, while the
+      // remaining entries are 16 bytes long. We need to skip the header entry.
+      uint64_t HeaderOffset = 0, MoldHeaderSize = 32;
+      if (EntryOffset == HeaderOffset && SectionSize >= MoldHeaderSize) {
+        std::vector<MCInst *> Insns;
+        MCInst Instructions[32]; // 32 insns at most
+        uint32_t Index = 0;
+        while (HeaderOffset < MoldHeaderSize) {
+          disassemblePLTInstruction(Section, HeaderOffset, Instructions[Index], InstrSize);
+          Insns.push_back(&Instructions[Index]);
+          HeaderOffset += InstrSize;
+          Index++;
+        }
+        // if it is a mold header, skip it
+        if (BC->MIB->isMoldPLTHeader(Insns)) {
+          BC->outs() << "BOLT-INFO: parsing the PLT of the mold linker\n";
+          EntryOffset += EntrySize;
+        }
+          
+      }
       continue;
+    }
 
     uint64_t TargetAddress;
     if (!BC->MIB->evaluateMemOperandTarget(Instruction, TargetAddress,
diff --git a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
index 63086c06d74fd9..215380085deb01 100644
--- a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
+++ b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
@@ -2127,6 +2127,29 @@ class X86MCPlusBuilder : public MCPlusBuilder {
     return Type;
   }
 
+  /// Analyze a series of insns that match the PLT header of the mold linker
+  /// (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50).
+  /// The size of the header is 32 bytes and the format is as follows:
+  ///   endbr64
+  ///   push %r11
+  ///   push GOTPLT+8(%rip)
+  ///   jmp *GOTPLT+16(%rip)
+  ///   padding （14 bytes）
+  ///
+  bool isMoldPLTHeader(std::vector<MCInst *> &Insns) const override {
+    if (Insns.size() != 18)
+      return false;
+      
+    if (!isTerminateBranch(*Insns[0]) || !isPush(*Insns[1])
+        || !isPush(*Insns[2]) || !isIndirectBranch(*Insns[3]))
+      return false;
+      
+    for (unsigned int i = 4; i < 18; ++i)
+      if (Insns[i]->getOpcode() != X86::INT3)
+        return false;
+    return true;
+  }
+
   /// Analyze a callsite to see if it could be a virtual method call.  This only
   /// checks to see if the overall pattern is satisfied, it does not guarantee
   /// that the callsite is a true virtual method call.
diff --git a/bolt/lib/Utils/CommandLineOpts.cpp b/bolt/lib/Utils/CommandLineOpts.cpp
index 356e530c9ca361..de82420a167131 100644
--- a/bolt/lib/Utils/CommandLineOpts.cpp
+++ b/bolt/lib/Utils/CommandLineOpts.cpp
@@ -72,12 +72,6 @@ EnableBAT("enable-bat",
   cl::ZeroOrMore,
   cl::cat(BoltCategory));
 
-cl::opt<bool> UseMold("use-mold",
-  cl::desc("the binary is generated by the mold linker"),
-  cl::init(false),
-  cl::ZeroOrMore,
-  cl::cat(BoltCategory));
-
 cl::opt<bool> EqualizeBBCounts(
     "equalize-bb-counts",
     cl::desc("use same count for BBs that should have equivalent count (used "

From 8c51da24960b673d242247a3af8e486bac8a2b78 Mon Sep 17 00:00:00 2001
From: patphzhang <patphzhang@tencent.com>
Date: Fri, 8 Nov 2024 16:33:15 +0800
Subject: [PATCH 3/7] [BOLT] removed the mold option in the test case

---
 bolt/test/X86/plt-mold-header.test | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/bolt/test/X86/plt-mold-header.test b/bolt/test/X86/plt-mold-header.test
index 8cbbed8711cbce..563e15e22d6642 100644
--- a/bolt/test/X86/plt-mold-header.test
+++ b/bolt/test/X86/plt-mold-header.test
@@ -1,7 +1,6 @@
 # RUN: yaml2obj %p/Inputs/plt-mold-header.yaml &> %t.exe
-# RUN: llvm-bolt -use-mold %t.exe --print-cfg --print-only=main.* -o %t.out | FileCheck %s
+# RUN: llvm-bolt %t.exe --print-cfg --print-only=main.* -o %t.out | FileCheck %s
 
 ## Check that llvm-bolt correctly parses PLT header created by mold linker.
-## Without the '-use-mold' option, "BOLT-ERROR: unable to disassemble instruction in PLT section .plt at offset 0x10" will be reported.
 ## The only call instruction in main() should be a call to printf() in PLT.
 CHECK:  callq "printf$plt

From beaa547d8e65baa6d81f1bbc9916b766b713f99e Mon Sep 17 00:00:00 2001
From: patphzhang <patphzhang@tencent.com>
Date: Mon, 11 Nov 2024 14:05:47 +0800
Subject: [PATCH 4/7] [BOLT] parse the PLT in two parts: header detection and
 entry detection

---
 bolt/include/bolt/Core/MCPlusBuilder.h   |  5 ---
 bolt/lib/Rewrite/RewriteInstance.cpp     | 40 ++++++++++--------------
 bolt/lib/Target/X86/X86MCPlusBuilder.cpp | 23 --------------
 3 files changed, 16 insertions(+), 52 deletions(-)

diff --git a/bolt/include/bolt/Core/MCPlusBuilder.h b/bolt/include/bolt/Core/MCPlusBuilder.h
index 2cc94c52f802de..32eda0b283b883 100644
--- a/bolt/include/bolt/Core/MCPlusBuilder.h
+++ b/bolt/include/bolt/Core/MCPlusBuilder.h
@@ -1495,11 +1495,6 @@ class MCPlusBuilder {
     return 0;
   }
 
-  virtual bool isMoldPLTHeader(std::vector<MCInst *> &Insns) const {
-    llvm_unreachable("not implemented");
-    return false;
-  }
-
   virtual bool analyzeVirtualMethodCall(InstructionIterator Begin,
                                         InstructionIterator End,
                                         std::vector<MCInst *> &MethodFetchInsns,
diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 5d4118e51d2f1c..806edb970dab0f 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -1707,7 +1707,21 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
   const uint64_t SectionAddress = Section.getAddress();
   const uint64_t SectionSize = Section.getSize();
 
-  for (uint64_t EntryOffset = 0; EntryOffset + EntrySize <= SectionSize;
+  // Parse the PLT header
+  uint64_t HeaderSize = 16;
+  MCInst FirstInstr;
+  uint64_t FirstInstrSize;
+  disassemblePLTInstruction(Section, 0, FirstInstr, FirstInstrSize);
+  if (BC->MIB->isTerminateBranch(FirstInstr)) {
+    // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
+    // generates a unique format for the PLT. The header entry is 32 bytes long, while the 
+    // remaining entries are 16 bytes long.
+    BC->outs() << "BOLT-INFO: parsing PLT header for mold\n";
+    HeaderSize = 32;
+  }
+
+  // Parse the PLT entries
+  for (uint64_t EntryOffset = HeaderSize; EntryOffset + EntrySize <= SectionSize;
        EntryOffset += EntrySize) {
     MCInst Instruction;
     uint64_t InstrSize, InstrOffset = EntryOffset;
@@ -1724,30 +1738,8 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
       InstrOffset += InstrSize;
     }
 
-    if (InstrOffset + InstrSize > EntryOffset + EntrySize) {
-      // Check if it is a mold header before rolling back because the mold linker generates
-      // a unique format. The header entry of the mold-style PLT is 32 bytes long, while the
-      // remaining entries are 16 bytes long. We need to skip the header entry.
-      uint64_t HeaderOffset = 0, MoldHeaderSize = 32;
-      if (EntryOffset == HeaderOffset && SectionSize >= MoldHeaderSize) {
-        std::vector<MCInst *> Insns;
-        MCInst Instructions[32]; // 32 insns at most
-        uint32_t Index = 0;
-        while (HeaderOffset < MoldHeaderSize) {
-          disassemblePLTInstruction(Section, HeaderOffset, Instructions[Index], InstrSize);
-          Insns.push_back(&Instructions[Index]);
-          HeaderOffset += InstrSize;
-          Index++;
-        }
-        // if it is a mold header, skip it
-        if (BC->MIB->isMoldPLTHeader(Insns)) {
-          BC->outs() << "BOLT-INFO: parsing the PLT of the mold linker\n";
-          EntryOffset += EntrySize;
-        }
-          
-      }
+    if (InstrOffset + InstrSize > EntryOffset + EntrySize)
       continue;
-    }
 
     uint64_t TargetAddress;
     if (!BC->MIB->evaluateMemOperandTarget(Instruction, TargetAddress,
diff --git a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
index 215380085deb01..63086c06d74fd9 100644
--- a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
+++ b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
@@ -2127,29 +2127,6 @@ class X86MCPlusBuilder : public MCPlusBuilder {
     return Type;
   }
 
-  /// Analyze a series of insns that match the PLT header of the mold linker
-  /// (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50).
-  /// The size of the header is 32 bytes and the format is as follows:
-  ///   endbr64
-  ///   push %r11
-  ///   push GOTPLT+8(%rip)
-  ///   jmp *GOTPLT+16(%rip)
-  ///   padding （14 bytes）
-  ///
-  bool isMoldPLTHeader(std::vector<MCInst *> &Insns) const override {
-    if (Insns.size() != 18)
-      return false;
-      
-    if (!isTerminateBranch(*Insns[0]) || !isPush(*Insns[1])
-        || !isPush(*Insns[2]) || !isIndirectBranch(*Insns[3]))
-      return false;
-      
-    for (unsigned int i = 4; i < 18; ++i)
-      if (Insns[i]->getOpcode() != X86::INT3)
-        return false;
-    return true;
-  }
-
   /// Analyze a callsite to see if it could be a virtual method call.  This only
   /// checks to see if the overall pattern is satisfied, it does not guarantee
   /// that the callsite is a true virtual method call.

From e42256e0cf011d528e15e4d51332d1b269a8f05b Mon Sep 17 00:00:00 2001
From: patphzhang <patphzhang@tencent.com>
Date: Mon, 11 Nov 2024 15:01:44 +0800
Subject: [PATCH 5/7] [BOLT] skip the '.plt.sec' section when parsing mold
 header

---
 bolt/lib/Rewrite/RewriteInstance.cpp | 24 +++++++++++++-----------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 806edb970dab0f..3c4631f0c1451e 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -1708,17 +1708,19 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
   const uint64_t SectionSize = Section.getSize();
 
   // Parse the PLT header
-  uint64_t HeaderSize = 16;
-  MCInst FirstInstr;
-  uint64_t FirstInstrSize;
-  disassemblePLTInstruction(Section, 0, FirstInstr, FirstInstrSize);
-  if (BC->MIB->isTerminateBranch(FirstInstr)) {
-    // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
-    // generates a unique format for the PLT. The header entry is 32 bytes long, while the 
-    // remaining entries are 16 bytes long.
-    BC->outs() << "BOLT-INFO: parsing PLT header for mold\n";
-    HeaderSize = 32;
-  }
+  uint64_t HeaderSize = 0;
+  if (Section.getName() != ".plt.sec") {
+    MCInst FirstInstr;
+    uint64_t FirstInstrSize;
+    disassemblePLTInstruction(Section, 0, FirstInstr, FirstInstrSize);
+    if (BC->MIB->isTerminateBranch(FirstInstr)) {
+      // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
+      // generates a unique format for the PLT. The header entry is 32 bytes long, while the 
+      // remaining entries are 16 bytes long.
+      BC->outs() << "BOLT-INFO: parsing PLT header for mold\n";
+      HeaderSize = 32;
+    }
+  }  
 
   // Parse the PLT entries
   for (uint64_t EntryOffset = HeaderSize; EntryOffset + EntrySize <= SectionSize;

From 7133d21a5c4f7d32002a3d0a02f626ba6296fbcf Mon Sep 17 00:00:00 2001
From: patphzhang <patphzhang@tencent.com>
Date: Mon, 11 Nov 2024 15:14:51 +0800
Subject: [PATCH 6/7] [BOLT] choose the '.plt' section when parsing mold header

---
 bolt/lib/Rewrite/RewriteInstance.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 3c4631f0c1451e..1333851fa21945 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -1709,7 +1709,7 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
 
   // Parse the PLT header
   uint64_t HeaderSize = 0;
-  if (Section.getName() != ".plt.sec") {
+  if (Section.getName() == ".plt") {
     MCInst FirstInstr;
     uint64_t FirstInstrSize;
     disassemblePLTInstruction(Section, 0, FirstInstr, FirstInstrSize);

From f2f238e128bcd7ce1f4b2f5c19dc3967a0090a55 Mon Sep 17 00:00:00 2001
From: patphzhang <patphzhang@tencent.com>
Date: Fri, 15 Nov 2024 14:50:43 +0800
Subject: [PATCH 7/7] [BOLT] support different PLT header type in disassembling

---
 bolt/include/bolt/Core/MCPlusBuilder.h      |  7 +++++
 bolt/include/bolt/Rewrite/RewriteInstance.h |  3 +++
 bolt/lib/Rewrite/RewriteInstance.cpp        | 29 ++++++++++++---------
 bolt/lib/Target/X86/X86MCPlusBuilder.cpp    | 28 ++++++++++++++++++++
 4 files changed, 54 insertions(+), 13 deletions(-)

diff --git a/bolt/include/bolt/Core/MCPlusBuilder.h b/bolt/include/bolt/Core/MCPlusBuilder.h
index 32eda0b283b883..6a619b33aaf48c 100644
--- a/bolt/include/bolt/Core/MCPlusBuilder.h
+++ b/bolt/include/bolt/Core/MCPlusBuilder.h
@@ -1495,6 +1495,13 @@ class MCPlusBuilder {
     return 0;
   }
 
+  /// Analyze preamble instrucions in PLT section and try to determine
+  /// the size of the header.
+  virtual uint32_t analyzePLTHeader(std::vector<MCInst *> &Insns) const {
+    llvm_unreachable("not implemented");
+    return 0;
+  }
+
   virtual bool analyzeVirtualMethodCall(InstructionIterator Begin,
                                         InstructionIterator End,
                                         std::vector<MCInst *> &MethodFetchInsns,
diff --git a/bolt/include/bolt/Rewrite/RewriteInstance.h b/bolt/include/bolt/Rewrite/RewriteInstance.h
index e5b7ad63007cab..54708da2bdf41a 100644
--- a/bolt/include/bolt/Rewrite/RewriteInstance.h
+++ b/bolt/include/bolt/Rewrite/RewriteInstance.h
@@ -277,6 +277,9 @@ class RewriteInstance {
   /// is the expected .plt \p Section entry function size.
   void disassemblePLTSectionX86(BinarySection &Section, uint64_t EntrySize);
 
+  /// Disassemble the X86-specific .plt \p Section header and get header size.
+  uint32_t disassemblePLTHeaderX86(BinarySection &Section, uint64_t EntrySize);
+
   /// Disassemble riscv-specific .plt \p Section auxiliary function
   void disassemblePLTSectionRISCV(BinarySection &Section);
 
diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 1333851fa21945..ca3f86f72d1ddf 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -1708,19 +1708,7 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
   const uint64_t SectionSize = Section.getSize();
 
   // Parse the PLT header
-  uint64_t HeaderSize = 0;
-  if (Section.getName() == ".plt") {
-    MCInst FirstInstr;
-    uint64_t FirstInstrSize;
-    disassemblePLTInstruction(Section, 0, FirstInstr, FirstInstrSize);
-    if (BC->MIB->isTerminateBranch(FirstInstr)) {
-      // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
-      // generates a unique format for the PLT. The header entry is 32 bytes long, while the 
-      // remaining entries are 16 bytes long.
-      BC->outs() << "BOLT-INFO: parsing PLT header for mold\n";
-      HeaderSize = 32;
-    }
-  }  
+  uint64_t HeaderSize = disassemblePLTHeaderX86(Section, EntrySize);
 
   // Parse the PLT entries
   for (uint64_t EntryOffset = HeaderSize; EntryOffset + EntrySize <= SectionSize;
@@ -1757,6 +1745,21 @@ void RewriteInstance::disassemblePLTSectionX86(BinarySection &Section,
   }
 }
 
+uint32_t RewriteInstance::disassemblePLTHeaderX86(BinarySection &Section,
+                                               uint64_t EntrySize) {
+  uint64_t InstrSize, InstrOffset = 0;
+  std::vector<MCInst *> Insns;
+  MCInst Instructions[32]; // 32 insns (bytes) at most
+  uint32_t Index = 0;
+  while (InstrOffset < EntrySize) {
+    disassemblePLTInstruction(Section, InstrOffset, Instructions[Index], InstrSize);
+    Insns.push_back(&Instructions[Index]);
+    InstrOffset += InstrSize;
+    Index++;
+  }
+  return BC->MIB->analyzePLTHeader(Insns);
+}
+
 void RewriteInstance::disassemblePLT() {
   auto analyzeOnePLTSection = [&](BinarySection &Section, uint64_t EntrySize) {
     if (BC->isAArch64())
diff --git a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
index 63086c06d74fd9..2acff1c018c0c7 100644
--- a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
+++ b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
@@ -2127,6 +2127,34 @@ class X86MCPlusBuilder : public MCPlusBuilder {
     return Type;
   }
 
+  uint32_t analyzePLTHeader(std::vector<MCInst *> &Insns) const override {
+    uint32_t HeaderSize = 0;
+    if (Insns.size() == 0) // empty header
+      return HeaderSize;
+    if (isTerminateBranch(*Insns[0])) {
+      // starting with an endbr, possible headers: mold
+      if (Insns.size() >= 4 && isPush(*Insns[1]) && isPush(*Insns[2]) &&
+          isIndirectBranch(*Insns[3])) {
+        // The mold linker (https://github.com/rui314/mold/blob/v2.34.1/src/arch-x86-64.cc#L50)
+        // generates a unique format for the PLT. The size of the header is 32 bytes and the 
+        // format is as follows:
+        ///   endbr64
+        ///   push %r11
+        ///   push GOTPLT+8(%rip)
+        ///   jmp *GOTPLT+16(%rip)
+        ///   padding （14 bytes）
+        HeaderSize = 32; // mold with CET support
+      } else {
+        // In case other linkers have new proposals.
+      }
+    } else {
+      // TODO: headers with endbr in the midddle, including the lld version plt,
+      // or headers without CET support, including R_386_PLT32, R_X86_64_PLT32,
+      // retpolineplt of lld (for Spectre v2 mitigation), and etc.
+    }
+    return HeaderSize;
+  }
+
   /// Analyze a callsite to see if it could be a virtual method call.  This only
   /// checks to see if the overall pattern is satisfied, it does not guarantee
   /// that the callsite is a true virtual method call.

From 241e72477e3891b062c12a210adf54e8612d5553 Mon Sep 17 00:00:00 2001
From: Nicholas <45984215+liusy58@users.noreply.github.com>
Date: Fri, 17 Jan 2025 09:48:17 +0800
Subject: [PATCH 1/3] [BOLT]  Support identifying indirect tail call.

AArch64 instructions have a fixed size 4 bytes, no need to compute.
---
 bolt/include/bolt/Core/MCPlusBuilder.h        |  5 ++
 bolt/lib/Core/BinaryFunction.cpp              | 53 +++++++++++++++++++
 .../Target/AArch64/AArch64MCPlusBuilder.cpp   | 10 ++++
 bolt/lib/Target/X86/X86MCPlusBuilder.cpp      | 11 ++++
 bolt/test/AArch64/indirect-tail-call.s        | 32 +++++++++++
 5 files changed, 111 insertions(+)
 create mode 100644 bolt/test/AArch64/indirect-tail-call.s

diff --git a/bolt/include/bolt/Core/MCPlusBuilder.h b/bolt/include/bolt/Core/MCPlusBuilder.h
index 5d77e6faff2fc6..a38f17b2c81b09 100644
--- a/bolt/include/bolt/Core/MCPlusBuilder.h
+++ b/bolt/include/bolt/Core/MCPlusBuilder.h
@@ -610,6 +610,11 @@ class MCPlusBuilder {
 
   virtual bool isLeave(const MCInst &Inst) const { return false; }
 
+  virtual bool hasUseOrDefofSPOrFP(const MCInst &Inst) const {
+    llvm_unreachable("not implemented");
+    return false;
+  }
+
   virtual bool isADRP(const MCInst &Inst) const {
     llvm_unreachable("not implemented");
     return false;
diff --git a/bolt/lib/Core/BinaryFunction.cpp b/bolt/lib/Core/BinaryFunction.cpp
index 1c5cd62a095b24..f44303b52c7a0b 100644
--- a/bolt/lib/Core/BinaryFunction.cpp
+++ b/bolt/lib/Core/BinaryFunction.cpp
@@ -1961,6 +1961,59 @@ bool BinaryFunction::postProcessIndirectBranches(
       bool IsEpilogue = llvm::any_of(BB, [&](const MCInst &Instr) {
         return BC.MIB->isLeave(Instr) || BC.MIB->isPop(Instr);
       });
+      if (BC.isAArch64()) {
+        // Any adr instruction of aarch64 will generate a new entry,
+        // Adr instruction cannt afford to do any optimizations
+        if (!IsEpilogue && !isMultiEntry()) {
+          BinaryBasicBlock::iterator LastDefCFAOffsetInstIter = BB.end();
+          // find the last OpDefCfaOffset 0 instruction.
+          for (BinaryBasicBlock::iterator Iter = BB.begin(); Iter != BB.end();
+               ++Iter) {
+            if (&*Iter == &Instr) {
+              break;
+            }
+            if (BC.MIB->isCFI(*Iter)) {
+              const MCCFIInstruction *CFIInst =
+                  BB.getParent()->getCFIFor(*Iter);
+              if ((CFIInst->getOperation() ==
+                   MCCFIInstruction::OpDefCfaOffset) &&
+                  (CFIInst->getOffset() == 0)) {
+                LastDefCFAOffsetInstIter = Iter;
+                break;
+              }
+            }
+          }
+          if (LastDefCFAOffsetInstIter != BB.end()) {
+            IsEpilogue = true;
+            // make sure there is no instruction manipulating sp between the two
+            // instructions
+            BinaryBasicBlock::iterator Iter = LastDefCFAOffsetInstIter;
+            while (&*Iter != &Instr) {
+              if (BC.MIB->hasUseOrDefofSPOrFP(*Iter)) {
+                IsEpilogue = false;
+                break;
+              }
+              ++Iter;
+            }
+          }
+        }
+
+        if (!IsEpilogue) {
+          IsEpilogue = true;
+          BinaryFunction *Func = BB.getFunction();
+          for (const BinaryBasicBlock &BinaryBB : *Func) {
+            for (const MCInst &Inst : BinaryBB) {
+              if (BC.MIB->hasUseOrDefofSPOrFP(Inst)) {
+                IsEpilogue = false;
+                break;
+              }
+            }
+            if (!IsEpilogue) {
+              break;
+            }
+          }
+        }
+      }
       if (IsEpilogue) {
         BC.MIB->convertJmpToTailCall(Instr);
         BB.removeAllSuccessors();
diff --git a/bolt/lib/Target/AArch64/AArch64MCPlusBuilder.cpp b/bolt/lib/Target/AArch64/AArch64MCPlusBuilder.cpp
index d752751c17932a..e6e79cd33605fc 100644
--- a/bolt/lib/Target/AArch64/AArch64MCPlusBuilder.cpp
+++ b/bolt/lib/Target/AArch64/AArch64MCPlusBuilder.cpp
@@ -1797,6 +1797,16 @@ class AArch64MCPlusBuilder : public MCPlusBuilder {
   getInstructionSize(const MCInst &Inst) const override {
     return 4;
   }
+
+  bool hasUseOrDefofSPOrFP(const MCInst &Inst) const override {
+    if (isPseudo(Inst) || isNoop(Inst) || isCFI(Inst)) {
+      return false;
+    }
+    return hasDefOfPhysReg(Inst, AArch64::SP) ||
+           hasUseOfPhysReg(Inst, AArch64::SP) ||
+           hasDefOfPhysReg(Inst, AArch64::FP) ||
+           hasUseOfPhysReg(Inst, AArch64::FP);
+  }
 };
 
 } // end anonymous namespace
diff --git a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
index 63086c06d74fd9..ad998d8601e26f 100644
--- a/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
+++ b/bolt/lib/Target/X86/X86MCPlusBuilder.cpp
@@ -89,6 +89,17 @@ class X86MCPlusBuilder : public MCPlusBuilder {
 public:
   using MCPlusBuilder::MCPlusBuilder;
 
+  virtual bool hasUseOrDefofSPOrFP(const MCInst &Inst) const override {
+    bool IsLoad, IsStore, IsStoreFromReg, IsSimple, IsIndexed;
+    MCPhysReg Reg;
+    int32_t SrcImm;
+    uint16_t StackPtrReg;
+    int64_t StackOffset;
+    uint8_t Size;
+    return isStackAccess(Inst, IsLoad, IsStore, IsStoreFromReg, Reg, SrcImm,
+                         StackPtrReg, StackOffset, Size, IsSimple, IsIndexed);
+  }
+
   std::unique_ptr<MCSymbolizer>
   createTargetSymbolizer(BinaryFunction &Function,
                          bool CreateNewSymbols) const override {
diff --git a/bolt/test/AArch64/indirect-tail-call.s b/bolt/test/AArch64/indirect-tail-call.s
new file mode 100644
index 00000000000000..5eb600132dce9a
--- /dev/null
+++ b/bolt/test/AArch64/indirect-tail-call.s
@@ -0,0 +1,32 @@
+## This test checks that indirect tail call is properly identified by BOLT on aarch64.
+
+# REQUIRES: system-linux
+
+# RUN: llvm-mc -filetype=obj -triple aarch64-unknown-unknown %s -o %t.o
+# RUN: %clang %cflags -O0 %t.o -o %t.exe -Wl,-q
+# RUN: llvm-bolt --print-all --print-only=indirect  \
+# RUN: %t.exe -o %t.bolt | FileCheck %s
+
+#CHECK: Binary Function "indirect" after building cfg {
+#CHECK-NOT: # UNKNOWN CONTROL FLOW
+#CHECK: End of Function "indirect"
+	.text
+	.globl	indirect                       
+	.type	indirect,@function
+indirect:      
+    cbz	x0, .LBB0_2                         
+	ldr	x8, [x0]
+	ldr	x1, [x8]
+	br	x1
+.LBB0_2:
+	mov	w0, #3
+	ret
+	.size	indirect, .-indirect
+
+
+	.globl	main                            
+	.type	main,@function
+main:                                   
+	mov	w0, wzr
+	ret
+	.size	main, .-main

From 1c4982813f21eddede6e4070c780a6e532bcf112 Mon Sep 17 00:00:00 2001
From: liusy58 <liusy58@linux.alibaba.com>
Date: Fri, 17 Jan 2025 16:59:57 +0800
Subject: [PATCH 2/3] [BOLT] Support identifying indirect tail calls.

---
 bolt/test/AArch64/indirect-tail-call.s | 1 -
 1 file changed, 1 deletion(-)

diff --git a/bolt/test/AArch64/indirect-tail-call.s b/bolt/test/AArch64/indirect-tail-call.s
index 5eb600132dce9a..1c820b1ad94bbc 100644
--- a/bolt/test/AArch64/indirect-tail-call.s
+++ b/bolt/test/AArch64/indirect-tail-call.s
@@ -1,5 +1,4 @@
 ## This test checks that indirect tail call is properly identified by BOLT on aarch64.
-
 # REQUIRES: system-linux
 
 # RUN: llvm-mc -filetype=obj -triple aarch64-unknown-unknown %s -o %t.o

From 4bb0fedddeeb4698b44297c5f3c0dd437e94fbe2 Mon Sep 17 00:00:00 2001
From: liusy58 <liusy58@linux.alibaba.com>
Date: Mon, 20 Jan 2025 17:14:54 +0800
Subject: [PATCH 3/3] [BOLT] Add another test to identify indirect tail call by
 using CFI

---
 bolt/test/AArch64/indirect-tail-call2.s | 52 +++++++++++++++++++++++++
 1 file changed, 52 insertions(+)
 create mode 100644 bolt/test/AArch64/indirect-tail-call2.s

diff --git a/bolt/test/AArch64/indirect-tail-call2.s b/bolt/test/AArch64/indirect-tail-call2.s
new file mode 100644
index 00000000000000..e27010ae2e0bbc
--- /dev/null
+++ b/bolt/test/AArch64/indirect-tail-call2.s
@@ -0,0 +1,52 @@
+## This test checks that indirect tail call is properly identified by BOLT on aarch64.
+# REQUIRES: system-linux
+
+# RUN: llvm-mc -filetype=obj -triple aarch64-unknown-unknown %s -o %t.o
+# RUN: %clang %cflags -O0 %t.o -o %t.exe -Wl,-q
+# RUN: llvm-bolt --print-all --print-only=indirect  \
+# RUN: %t.exe -o %t.bolt | FileCheck %s
+
+#CHECK: Binary Function "indirect" after building cfg {
+#CHECK-NOT: # UNKNOWN CONTROL FLOW
+#CHECK: End of Function "indirect"
+	.text
+	.global	indirect
+	.type	indirect, %function
+indirect:
+.LFB0:
+	.cfi_startproc
+	stp	x29, x30, [sp, -16]!
+	.cfi_def_cfa_offset 16
+	.cfi_offset 29, -16
+	.cfi_offset 30, -8
+	mov	w3, w1
+	add	w1, w0, w1
+	add	w5, w1, w1, lsr 31
+	tst	x1, 1
+	asr	w5, w5, 1
+	csel	w1, w1, w5, eq
+	cmp	w0, w3
+	beq	.L3
+	mov	w0, w3
+	mov	x16, x2
+	ldp	x29, x30, [sp], 16
+	.cfi_restore 30
+	.cfi_restore 29
+	.cfi_def_cfa_offset 0
+	br	x16
+.L3:
+	ret
+	.cfi_endproc
+.LFE0:
+	.size	indirect, .-indirect
+
+	.global	main
+	.type	main, %function
+main:
+.LFB1:
+	.cfi_startproc
+	mov	w0, 0
+	ret
+	.cfi_endproc
+.LFE1:
+	.size	main, .-main

From ceab654027e6da5fdce1e7e38f3a85d8fd4ac46e Mon Sep 17 00:00:00 2001
From: Amir Ayupov <aaupov@fb.com>
Date: Wed, 18 Dec 2024 21:32:32 -0800
Subject: [PATCH] fix Location::operator==

Created using spr 1.3.4
---
 bolt/include/bolt/Passes/IndirectCallPromotion.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/bolt/include/bolt/Passes/IndirectCallPromotion.h b/bolt/include/bolt/Passes/IndirectCallPromotion.h
index 6f5f3532fc82bc..34ad9582bce657 100644
--- a/bolt/include/bolt/Passes/IndirectCallPromotion.h
+++ b/bolt/include/bolt/Passes/IndirectCallPromotion.h
@@ -109,7 +109,7 @@ class IndirectCallPromotion : public BinaryFunctionPass {
     explicit Location(MCSymbol *Sym) : Sym(Sym) {}
     explicit Location(uint64_t Addr) : Addr(Addr) {}
     bool operator==(const Location &O) {
-      return Sym == O.Sym || Addr == O.Addr;
+      return Sym ? Sym == O.Sym : Addr == O.Addr;
     }
   };

From f6435e5499dd0384820381bf85995b823789c279 Mon Sep 17 00:00:00 2001
From: Rin Dobrescu <rin.dobrescu@arm.com>
Date: Tue, 17 Dec 2024 16:43:33 +0000
Subject: [PATCH 1/4] [BOLT][AArch64] Create entry points for addresses
 referenced by dynamic relocations and allow getNewFunctionOrDataAddress to
 map addrs inside functions.

By adding addresses referenced by dynamic relocations as entry points,
this patch fixes an issue where bolt fails on code using computing
goto's. This also fixes a mapping issue with the bugfix from this
PR: https://github.com/llvm/llvm-project/pull/117766.
---
 bolt/lib/Rewrite/RewriteInstance.cpp | 10 ++++++-
 bolt/test/AArch64/computed-goto.s    | 39 ++++++++++++++++++++++++++++
 2 files changed, 48 insertions(+), 1 deletion(-)
 create mode 100644 bolt/test/AArch64/computed-goto.s

diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 4329235d470497..55fcd6b6e782c4 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -2439,6 +2439,14 @@ void RewriteInstance::readDynamicRelocations(const SectionRef &Section,
     if (Symbol)
       SymbolIndex[Symbol] = getRelocationSymbol(InputFile, Rel);
 
+    const uint64_t SymAddress = SymbolAddress + Addend;
+    BinaryFunction *Func = BC->getBinaryFunctionContainingAddress(SymAddress);
+    if(Func){
+      const uint64_t FunctionOffset = SymAddress - Func->getAddress();
+      if(FunctionOffset)
+        Func->addEntryPointAtOffset(FunctionOffset);
+    }
+
     BC->addDynamicRelocation(Rel.getOffset(), Symbol, RType, Addend);
   }
 }
@@ -5599,7 +5607,7 @@ uint64_t RewriteInstance::getNewFunctionOrDataAddress(uint64_t OldAddress) {
         for (const BinaryBasicBlock &BB : *BF)
           if (BB.isEntryPoint() &&
               (BF->getAddress() + BB.getOffset()) == OldAddress)
-            return BF->getOutputAddress() + BB.getOffset();
+            return BB.getOutputStartAddress();
       }
       BC->errs() << "BOLT-ERROR: unable to get new address corresponding to "
                     "input address 0x"
diff --git a/bolt/test/AArch64/computed-goto.s b/bolt/test/AArch64/computed-goto.s
new file mode 100644
index 00000000000000..043f9a8e37e6b0
--- /dev/null
+++ b/bolt/test/AArch64/computed-goto.s
@@ -0,0 +1,39 @@
+# RUN: llvm-mc -filetype=obj -triple aarch64-unknown-unknown %s -o %t.o
+# RUN: %clang %cflags %t.o -o %t.exe -Wl,-q
+# RUN: llvm-bolt %t.exe -o %t.bolt 2>&1 | FileCheck %s
+
+## Before bolt could handle mapping addresses within moved functions, it
+## would bail out with an error of the form:
+## BOLT-ERROR: unable to get new address corresponding to input address 0x10390 in function main. Consider adding this function to --skip-funcs=...
+## These addresses arise if computed GOTO is in use.
+## Check that bolt does not emit any error.
+
+# CHECK-NOT: BOLT-ERROR
+
+.globl  main
+.p2align        2
+.type   main,@function
+main:
+.cfi_startproc
+        adrp    x8, .L__const.main.ptrs+8
+        add     x8, x8, :lo12:.L__const.main.ptrs+8
+        ldr     x9, [x8], #8
+        br      x9
+
+.Label0: // Block address taken
+        ldr     x9, [x8], #8
+        br      x9
+
+.Label1: // Block address taken
+        mov     w0, #42
+        ret
+
+.Lfunc_end0:
+.size   main, .Lfunc_end0-main
+.cfi_endproc
+        .type   .L__const.main.ptrs,@object
+        .section        .data.rel.ro,"aw",@progbits
+        .p2align        3, 0x0
+.L__const.main.ptrs:
+        .xword  .Label0
+        .xword  .Label1

From dd67da54eba30b68350cc95f6e3eeb31d9dbb9ce Mon Sep 17 00:00:00 2001
From: Rin Dobrescu <rin.dobrescu@arm.com>
Date: Wed, 18 Dec 2024 12:11:10 +0000
Subject: [PATCH 2/4] Fix clang-format and address PR comments.

---
 bolt/lib/Rewrite/RewriteInstance.cpp | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/bolt/lib/Rewrite/RewriteInstance.cpp b/bolt/lib/Rewrite/RewriteInstance.cpp
index 55fcd6b6e782c4..1d8bce5c8a8881 100644
--- a/bolt/lib/Rewrite/RewriteInstance.cpp
+++ b/bolt/lib/Rewrite/RewriteInstance.cpp
@@ -2441,10 +2441,9 @@ void RewriteInstance::readDynamicRelocations(const SectionRef &Section,
 
     const uint64_t SymAddress = SymbolAddress + Addend;
     BinaryFunction *Func = BC->getBinaryFunctionContainingAddress(SymAddress);
-    if(Func){
-      const uint64_t FunctionOffset = SymAddress - Func->getAddress();
-      if(FunctionOffset)
-        Func->addEntryPointAtOffset(FunctionOffset);
+    if (Func && !Func->isInConstantIsland(SymAddress)) {
+      if (const uint64_t SymOffset = SymAddress - Func->getAddress())
+        Func->addEntryPointAtOffset(SymOffset);
     }
 
     BC->addDynamicRelocation(Rel.getOffset(), Symbol, RType, Addend);

From 1dd6d5a0d6b572036a004bb87a1a204fa0c5dd84 Mon Sep 17 00:00:00 2001
From: Rin Dobrescu <rin.dobrescu@arm.com>
Date: Tue, 31 Dec 2024 12:45:05 +0000
Subject: [PATCH 3/4] Remove redundant test and expand different test.

---
 bolt/test/AArch64/computed-goto.s    | 38 ++++++++++++++++++++++++----
 bolt/test/X86/indirect-goto-pie.test | 16 ------------
 2 files changed, 33 insertions(+), 21 deletions(-)
 delete mode 100644 bolt/test/X86/indirect-goto-pie.test

diff --git a/bolt/test/AArch64/computed-goto.s b/bolt/test/AArch64/computed-goto.s
index 043f9a8e37e6b0..654bdfb7a5bf80 100644
--- a/bolt/test/AArch64/computed-goto.s
+++ b/bolt/test/AArch64/computed-goto.s
@@ -1,15 +1,43 @@
+// This test checks that BOLT creates entry points for addresses
+// referenced by dynamic relocations.
+// The test also checks that BOLT can map addresses inside functions.
+
+// Checks for error and entry points.
 # RUN: llvm-mc -filetype=obj -triple aarch64-unknown-unknown %s -o %t.o
 # RUN: %clang %cflags %t.o -o %t.exe -Wl,-q
 # RUN: llvm-bolt %t.exe -o %t.bolt 2>&1 | FileCheck %s
+# RUN: llvm-bolt %t.exe -o %t.bolt --print-cfg | FileCheck --check-prefix=CHECK-ENTRYS %s
 
-## Before bolt could handle mapping addresses within moved functions, it
-## would bail out with an error of the form:
-## BOLT-ERROR: unable to get new address corresponding to input address 0x10390 in function main. Consider adding this function to --skip-funcs=...
-## These addresses arise if computed GOTO is in use.
-## Check that bolt does not emit any error.
+// Checks for dynamic relocations.
+# RUN: llvm-readelf -dr %t.bolt > %t.out.txt
+# RUN: llvm-objdump -j .rela.dyn -d %t.bolt >> %t.out.txt
+# RUN: FileCheck --check-prefix=CHECK-RELOCS %s --input-file=%t.out.txt
 
+// Before bolt could handle mapping addresses within moved functions, it
+// would bail out with an error of the form:
+// BOLT-ERROR: unable to get new address corresponding to input address 0x10390 in function main. Consider adding this function to --skip-funcs=...
+// These addresses arise if computed GOTO is in use.
+// Check that bolt does not emit any error.
 # CHECK-NOT: BOLT-ERROR
 
+// Check that there are dynamic relocations.
+# CHECK-RELOCS:     Dynamic section at offset {{.*}} contains {{.*}} entries:
+# CHECK-RELOCS:     Relocation section '.rela.dyn' at offset {{.*}} contains {{.*}} entries
+
+// Check that dynamic relocations were updated
+# CHECK-RELOCS: [[#%x,OFF:]] [[#%x,INFO_DYN:]] R_AARCH64_RELATIVE [[#%x,ADDR:]]
+# CHECK-RELOCS-NEXT: [[#OFF + 8]] {{0*}}[[#INFO_DYN]] R_AARCH64_RELATIVE [[#ADDR + 8]]
+# CHECK-RELOCS: [[#ADDR]] <unknown>
+# CHECK-RELOCS: [[#ADDR + 8]] <unknown>
+
+// Check that BOLT registers extra entry points for dynamic relocations.
+# CHECK-ENTRYS: Binary Function "main" after building cfg {
+# CHECK-ENTRYS:  IsMultiEntry: 1
+# CHECK-ENTRYS: .Ltmp0 {{.*}}
+# CHECK-ENTRYS-NEXT: Secondary Entry Point: {{.*}}
+# CHECK-ENTRYS: .Ltmp1 {{.*}}
+# CHECK-ENTRYS-NEXT: Secondary Entry Point: {{.*}}
+
 .globl  main
 .p2align        2
 .type   main,@function
diff --git a/bolt/test/X86/indirect-goto-pie.test b/bolt/test/X86/indirect-goto-pie.test
deleted file mode 100644
index 3311c1aec061c5..00000000000000
--- a/bolt/test/X86/indirect-goto-pie.test
+++ /dev/null
@@ -1,16 +0,0 @@
-## Check that llvm-bolt fails to process PIC binaries with computed goto, as the
-## support is not there yet for correctly updating dynamic relocations
-## referencing code inside functions.
-
-REQUIRES: x86_64-linux
-
-RUN: %clang %S/Inputs/indirect_goto.c -o %t -fpic -pie -Wl,-q
-RUN: not llvm-bolt %t -o %t.bolt --relocs=1 --print-cfg --print-only=main \
-RUN:   2>&1 | FileCheck %s
-
-## Check that processing works if main() is skipped.
-RUN: llvm-bolt %t -o %t.bolt --relocs=1 --skip-funcs=main
-
-CHECK:  jmpq    *%rax # UNKNOWN CONTROL FLOW
-
-CHECK: BOLT-ERROR: unable to get new address

From 5e4642274f0360bbc0904feabace8c72c163d8b8 Mon Sep 17 00:00:00 2001
From: Shatian Wang <shatian@meta.com>
Date: Wed, 9 Oct 2024 14:45:50 -0700
Subject: [PATCH 1/2] [BOLT][X86]Redirect never-taken jumps

---
 bolt/include/bolt/Core/BinaryBasicBlock.h     |  14 +-
 .../bolt/Passes/RedirectNeverTakenJumps.h     |  58 ++
 bolt/lib/Core/BinaryBasicBlock.cpp            |  73 +++
 bolt/lib/Passes/CMakeLists.txt                |   1 +
 bolt/lib/Passes/RedirectNeverTakenJumps.cpp   | 503 ++++++++++++++++++
 bolt/lib/Rewrite/BinaryPassManager.cpp        |   9 +
 bolt/test/X86/redirect-never-taken-jumps.s    |  86 +++
 7 files changed, 742 insertions(+), 2 deletions(-)
 create mode 100644 bolt/include/bolt/Passes/RedirectNeverTakenJumps.h
 create mode 100644 bolt/lib/Passes/RedirectNeverTakenJumps.cpp
 create mode 100644 bolt/test/X86/redirect-never-taken-jumps.s

diff --git a/bolt/include/bolt/Core/BinaryBasicBlock.h b/bolt/include/bolt/Core/BinaryBasicBlock.h
index b4f31cf2bae6f6..df4c3f3a20f23f 100644
--- a/bolt/include/bolt/Core/BinaryBasicBlock.h
+++ b/bolt/include/bolt/Core/BinaryBasicBlock.h
@@ -789,13 +789,23 @@ class BinaryBasicBlock {
     return SplitInst;
   }
 
-  /// Split basic block at the instruction pointed to by II.
+  /// Split basic block at the instruction pointed to by II that is
+  /// not after any branch instructions in the basic block.
   /// All iterators pointing after II get invalidated.
   ///
   /// Return the new basic block that starts with the instruction
-  /// at the split point.
+  /// at the split point, which has been inserted at the end of the
+  /// current function.
   BinaryBasicBlock *splitAt(iterator II);
 
+  /// Split basic block in place at the instruction pointed to by II.
+  /// All iterators pointing after II get invalidated.
+  ///
+  /// Return the new basic block that starts with the instruction
+  /// at the split point, which has been inserted right after the
+  /// current basic block in the current function.
+  BinaryBasicBlock *splitInPlaceAt(iterator II);
+
   /// Set start offset of this basic block in the input binary.
   void setOffset(uint32_t Offset) { InputRange.first = Offset; };
 
diff --git a/bolt/include/bolt/Passes/RedirectNeverTakenJumps.h b/bolt/include/bolt/Passes/RedirectNeverTakenJumps.h
new file mode 100644
index 00000000000000..d85eb5fb0fdf35
--- /dev/null
+++ b/bolt/include/bolt/Passes/RedirectNeverTakenJumps.h
@@ -0,0 +1,58 @@
+//===- bolt/Passes/RedirectNeverTakenJumps.h - Code size reduction --------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass reduces code size in X86 by redirecting never-taken jumps that take
+// 5 or 6 bytes to nearby jumps with the same jump target and compatible
+// condition codes. Doing each such redirection will save 3 or 4 bytes depending
+// on if the redirected jump is unconditional or conditional, since a short jump
+// takes only 2 bytes. The pass can be turned on with BOLT option
+// -redirect-never-taken-jumps.
+//
+// There are two modes for classifying "never-taken" jumps: aggressive and
+// conservative. The aggressive mode classifies any jump with zero execution
+// count as never-taken, and can be turned on with BOLT option
+// -aggressive-never-taken. The conservative mode is used by default and
+// accounts for potential errors in the input profile. It infers if a jump with
+// zero execution count is actually never-taken by checking the gap between the
+// inflow (resp. outflow) and block execution count for each basic block.
+// The conservativeness is controlled by BOLT option
+// -conservative-never-taken-threshold. The smaller the threshold, the more
+// conservative the classification is. In most realistic settings, the value
+// should exceed 1.0. The current default is 1.25.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef BOLT_PASSES_REDIRECT_NEVER_TAKEN_JUMPS_H
+#define BOLT_PASSES_REDIRECT_NEVER_TAKEN_JUMPS_H
+
+#include "bolt/Passes/BinaryPasses.h"
+#include <atomic>
+
+namespace llvm {
+namespace bolt {
+
+class RedirectNeverTakenJumps : public BinaryFunctionPass {
+private:
+  std::atomic<uint64_t> TotalHotSizeSavings{0ull};
+  std::atomic<uint64_t> TotalSizeSavings{0ull};
+
+public:
+  explicit RedirectNeverTakenJumps(const cl::opt<bool> &PrintPass)
+      : BinaryFunctionPass(PrintPass) {}
+
+  const char *getName() const override { return "redirect-never-taken-jumps"; }
+
+  Error runOnFunctions(BinaryContext &BC) override;
+
+  void performRedirections(BinaryFunction &Function);
+};
+
+} // namespace bolt
+} // namespace llvm
+
+#endif
diff --git a/bolt/lib/Core/BinaryBasicBlock.cpp b/bolt/lib/Core/BinaryBasicBlock.cpp
index 2a2192b79bb4bf..4e87865f6a210f 100644
--- a/bolt/lib/Core/BinaryBasicBlock.cpp
+++ b/bolt/lib/Core/BinaryBasicBlock.cpp
@@ -572,5 +572,78 @@ BinaryBasicBlock *BinaryBasicBlock::splitAt(iterator II) {
   return NewBlock;
 }
 
+BinaryBasicBlock *BinaryBasicBlock::splitInPlaceAt(iterator II) {
+  assert(II != end() && "expected iterator pointing to instruction");
+  if (II == begin())
+    return this;
+  const BinaryContext &BC = Function->getBinaryContext();
+  std::vector<std::unique_ptr<BinaryBasicBlock>> ToAdd;
+  ToAdd.emplace_back(getFunction()->createBasicBlock());
+  BinaryBasicBlock *BBNew = ToAdd.back().get();
+  uint64_t BBNewExecCount = 0;
+
+  // Find successors of the current block that needs to be moved.
+  BinaryBasicBlock *CondSuccessor = nullptr;
+  BinaryBasicBlock::BinaryBranchInfo CondSuccessorBI;
+  BinaryBasicBlock *UncondSuccessor = nullptr;
+  BinaryBasicBlock::BinaryBranchInfo UncondSuccessorBI;
+  auto I = end();
+  while (I != II) {
+    --I;
+    if (BC.MIB->isUnconditionalBranch(*I)) {
+      const MCSymbol *TargetSymbol = BC.MIB->getTargetSymbol(*I);
+      UncondSuccessor = getSuccessor(TargetSymbol, UncondSuccessorBI);
+    } else if (BC.MIB->isConditionalBranch(*I)) {
+      const MCSymbol *TargetSymbol = BC.MIB->getTargetSymbol(*I);
+      CondSuccessor = getSuccessor(TargetSymbol, CondSuccessorBI);
+    }
+  }
+
+  // Adjust successors of the current and the new blocks.
+  if (CondSuccessor != nullptr) {
+    BBNew->addSuccessor(CondSuccessor, CondSuccessorBI);
+    BBNewExecCount +=
+        CondSuccessorBI.Count != BinaryBasicBlock::COUNT_NO_PROFILE
+            ? CondSuccessorBI.Count
+            : 0;
+    removeSuccessor(CondSuccessor);
+  }
+  if (UncondSuccessor != nullptr) {
+    BBNew->addSuccessor(UncondSuccessor, UncondSuccessorBI);
+    BBNewExecCount +=
+        UncondSuccessorBI.Count != BinaryBasicBlock::COUNT_NO_PROFILE
+            ? UncondSuccessorBI.Count
+            : 0;
+    removeSuccessor(UncondSuccessor);
+  } else { // Fall through.
+    BinaryBasicBlock *NextBB =
+        Function->getLayout().getBasicBlockAfter(this, /*IgnoreSplits=*/false);
+    assert(NextBB);
+    if (getSuccessor(NextBB->getLabel())) {
+      const BinaryBasicBlock::BinaryBranchInfo &BI = getBranchInfo(*NextBB);
+      BBNew->addSuccessor(NextBB, BI);
+      BBNewExecCount +=
+          BI.Count != BinaryBasicBlock::COUNT_NO_PROFILE ? BI.Count : 0;
+      removeSuccessor(NextBB);
+    }
+  }
+  addSuccessor(BBNew, BBNewExecCount, 0);
+  BBNew->setExecutionCount(BBNewExecCount);
+
+  // Set correct CFI state for the new block.
+  BBNew->setCFIState(getCFIStateAtInstr(&*II));
+
+  // Move instructions over.
+  adjustNumPseudos(II, end(), -1);
+  BBNew->addInstructions(II, end());
+  Instructions.erase(II, end());
+
+  // Insert new block after the current block.
+  getFunction()->insertBasicBlocks(
+      this, std::move(ToAdd), /*UpdateLayout*/ true, /*UpdateCFIState*/ true,
+      /*RecomputeLandingPads*/ false);
+  return BBNew;
+}
+
 } // namespace bolt
 } // namespace llvm
diff --git a/bolt/lib/Passes/CMakeLists.txt b/bolt/lib/Passes/CMakeLists.txt
index 1c1273b3d2420d..1b64d3e1d0b9e9 100644
--- a/bolt/lib/Passes/CMakeLists.txt
+++ b/bolt/lib/Passes/CMakeLists.txt
@@ -27,6 +27,7 @@ add_llvm_library(LLVMBOLTPasses
   PettisAndHansen.cpp
   PLTCall.cpp
   ContinuityStats.cpp
+  RedirectNeverTakenJumps.cpp
   RegAnalysis.cpp
   RegReAssign.cpp
   ReorderAlgorithm.cpp
diff --git a/bolt/lib/Passes/RedirectNeverTakenJumps.cpp b/bolt/lib/Passes/RedirectNeverTakenJumps.cpp
new file mode 100644
index 00000000000000..418f055beff306
--- /dev/null
+++ b/bolt/lib/Passes/RedirectNeverTakenJumps.cpp
@@ -0,0 +1,503 @@
+//===- bolt/Passes/RedirectNeverTakenJumps.cpp - Code size reduction ------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements RedirectNeverTakenJumps class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "bolt/Passes/RedirectNeverTakenJumps.h"
+#include "bolt/Core/ParallelUtilities.h"
+
+using namespace llvm;
+using namespace bolt;
+
+namespace opts {
+extern cl::OptionCategory BoltOptCategory;
+
+static cl::opt<bool> RedirectNeverTakenJumps(
+    "redirect-never-taken-jumps",
+    cl::desc("Apply a heuristic to redirect never taken jumps in order to "
+             "reduce hot code size (X86 only)"),
+    cl::Hidden, cl::init(false), cl::cat(BoltOptCategory));
+
+static cl::opt<bool> AggressiveNeverTaken(
+    "aggressive-never-taken",
+    cl::desc("Classify all zero-execution-count jumps as never taken. This "
+             "option ignores the possibility of execution counts of hot jumps "
+             "being incorrectly set to 0 in the input profile"),
+    cl::ReallyHidden, cl::init(false), cl::cat(BoltOptCategory));
+
+static cl::opt<double> ConservativeNeverTakenThreshold(
+    "conservative-never-taken-threshold",
+    cl::desc(
+        "When aggressive-never-taken=0 (default), this value controls how "
+        "conservative the classification of never-taken jumps is. The smaller "
+        "the value the more conservative the classification. In most realistic "
+        "settings, the value should exceed 1.0. Default 1.25."),
+    cl::ZeroOrMore, cl::init(1.25), cl::ReallyHidden, cl::cat(BoltOptCategory));
+} // namespace opts
+
+namespace {
+/// A jump instruction in the binary.
+struct JumpT {
+  JumpT(const JumpT &) = delete;
+  JumpT(JumpT &&) = default;
+  JumpT &operator=(const JumpT &) = delete;
+  JumpT &operator=(JumpT &&) = default;
+
+  explicit JumpT(MCInst *Inst, unsigned CC, bool IsUnconditional,
+                 BinaryBasicBlock *OriginalTargetBB, uint64_t ExecutionCount,
+                 BinaryBasicBlock *HomeBB, uint64_t OriginalAddress,
+                 uint64_t OriginalInstrSize)
+      : Inst(Inst), CC(CC), IsUnconditional(IsUnconditional),
+        OriginalTargetBB(OriginalTargetBB), ExecutionCount(ExecutionCount),
+        HomeBB(HomeBB), OriginalAddress(OriginalAddress),
+        OriginalInstrSize(OriginalInstrSize) {}
+
+  MCInst *Inst;
+  unsigned CC;
+  bool IsUnconditional;
+  BinaryBasicBlock *OriginalTargetBB;
+  uint64_t ExecutionCount;
+  BinaryBasicBlock *HomeBB;
+  uint64_t OriginalAddress{0};
+  uint8_t OriginalInstrSize{0};
+
+  bool IsLongNeverTaken{false};
+  bool IsRedirectionTarget{false};
+  JumpT *RedirectionTarget{nullptr};
+  JumpT *UncondJumpInSameBlock{nullptr};
+};
+
+using Jumps = std::vector<std::unique_ptr<JumpT>>;
+using JumpPtrs = std::vector<JumpT *>;
+using FlowMapTy = std::unordered_map<const BinaryBasicBlock *, uint64_t>;
+using BlockToJumpsMapTy =
+    std::unordered_map<BinaryBasicBlock *, std::vector<JumpT *>>;
+
+/// Size of jump instructions in bytes in X86.
+static constexpr uint8_t ShortJumpSize = 2;
+static constexpr uint8_t LongUncondJumpSize = 5;
+static constexpr uint8_t LongCondJumpSize = 6;
+
+/// The longest distance for any short jump on X86.
+static constexpr uint8_t ShortJumpBits = 8;
+static constexpr uint8_t ShortestJumpSpan = 1ULL << (ShortJumpBits - 1);
+
+bool isLongJump(const uint64_t JumpStartAddr, const uint64_t JumpEndAddr,
+                const bool SameFragment) {
+  if (!SameFragment)
+    return true;
+  if (JumpEndAddr > JumpStartAddr)
+    return JumpEndAddr - JumpStartAddr > ShortestJumpSpan - 1;
+  else
+    return JumpStartAddr - JumpEndAddr > ShortestJumpSpan;
+}
+
+void createJumps(BinaryFunction &Function, FunctionFragment &Fragment,
+                 Jumps &JumpsInFunction, JumpPtrs &JumpsInFragment) {
+  const BinaryContext &BC = Function.getBinaryContext();
+
+  auto createJump = [&](MCInst *Branch, bool IsUnconditional,
+                        BinaryBasicBlock *SourceBB, BinaryBasicBlock *TargetBB,
+                        const uint8_t OffsetFromBlockEnd) {
+    const BinaryBasicBlock::BinaryBranchInfo &BI =
+        SourceBB->getBranchInfo(*TargetBB);
+    uint64_t ExecCount = 0;
+    if (BI.Count != BinaryBasicBlock::COUNT_NO_PROFILE)
+      ExecCount = BI.Count;
+
+    const uint64_t JumpEndAddr = TargetBB->getOutputStartAddress();
+    const uint64_t JumpStartAddr =
+        SourceBB->getOutputEndAddress() - OffsetFromBlockEnd;
+    const uint8_t LongJumpSize =
+        IsUnconditional ? LongUncondJumpSize : LongCondJumpSize;
+    const uint8_t JumpInstrSize =
+        isLongJump(JumpStartAddr, JumpEndAddr,
+                   SourceBB->getFragmentNum() == TargetBB->getFragmentNum())
+            ? LongJumpSize
+            : ShortJumpSize;
+    return std::unique_ptr<JumpT>(new JumpT(
+        Branch, BC.MIB->getCondCode(*Branch), IsUnconditional, TargetBB,
+        ExecCount, SourceBB, JumpStartAddr - JumpInstrSize, JumpInstrSize));
+  };
+
+  for (BinaryBasicBlock *BB : Fragment) {
+    const MCSymbol *TBB = nullptr;
+    const MCSymbol *FBB = nullptr;
+    MCInst *CondBranch = nullptr;
+    MCInst *UncondBranch = nullptr;
+    BinaryBasicBlock *CondSuccessor = nullptr;
+    BinaryBasicBlock *UncondSuccessor = nullptr;
+
+    if (BB->analyzeBranch(TBB, FBB, CondBranch, UncondBranch)) {
+      if (BB->succ_size() == 1) {
+        UncondSuccessor = BB->getSuccessor();
+        if (UncondBranch != nullptr) {
+          std::unique_ptr<JumpT> Jump =
+              createJump(UncondBranch, true, BB, UncondSuccessor, 0);
+          JumpsInFragment.push_back(Jump.get());
+          JumpsInFunction.push_back(std::move(Jump));
+        }
+      } else if (BB->succ_size() == 2) {
+        assert(CondBranch != nullptr);
+        CondSuccessor = BB->getConditionalSuccessor(true);
+        UncondSuccessor = BB->getConditionalSuccessor(false);
+        std::unique_ptr<JumpT> UncondJump = nullptr;
+        std::unique_ptr<JumpT> CondJump = nullptr;
+        uint8_t UncondJumpInstrSize = 0;
+        if (UncondBranch != nullptr) {
+          UncondJump = createJump(UncondBranch, true, BB, UncondSuccessor, 0);
+          UncondJumpInstrSize = UncondJump->OriginalInstrSize;
+        }
+        if (!BC.MIB->isDynamicBranch(*CondBranch)) {
+          CondJump = createJump(CondBranch, false, BB, CondSuccessor,
+                                UncondJumpInstrSize);
+          if (UncondJump != nullptr)
+            CondJump->UncondJumpInSameBlock = UncondJump.get();
+        }
+        if (CondJump != nullptr) {
+          JumpsInFragment.push_back(CondJump.get());
+          JumpsInFunction.push_back(std::move(CondJump));
+        }
+        if (UncondJump != nullptr) {
+          JumpsInFragment.push_back(UncondJump.get());
+          JumpsInFunction.push_back(std::move(UncondJump));
+        }
+      }
+    }
+  }
+}
+
+void identifyCandidates(BinaryFunction &Function, JumpPtrs &JumpsInFragment,
+                        BlockToJumpsMapTy &TargetsToJumps) {
+  // Identify jumps that are long and never taken.
+  // First check if each jump is long and have zero execution count.
+  auto isLongZeroCount = [&](const JumpT &Jump) {
+    return Jump.ExecutionCount == 0 && Jump.OriginalInstrSize > ShortJumpSize;
+    ;
+  };
+
+  BlockToJumpsMapTy SourcesToJumps;
+  for (JumpT *Jump : JumpsInFragment) {
+    Jump->IsLongNeverTaken = isLongZeroCount(*Jump);
+    assert(Jump->OriginalTargetBB != nullptr);
+    TargetsToJumps[Jump->OriginalTargetBB].push_back(Jump);
+    SourcesToJumps[Jump->HomeBB].push_back(Jump);
+  }
+
+  // Next identify zero-execution-count jumps that are unlikely to actually be
+  // never-taken by comparing the value of inflow (resp outflow) of each basic
+  // block with its block execution count.
+  FlowMapTy IncomingMap;
+  FlowMapTy OutgoingMap;
+  for (const BinaryBasicBlock &BB : Function) {
+    auto SuccBIIter = BB.branch_info_begin();
+    for (BinaryBasicBlock *Succ : BB.successors()) {
+      const uint64_t Count = SuccBIIter->Count;
+      if (Count == BinaryBasicBlock::COUNT_NO_PROFILE || Count == 0) {
+        ++SuccBIIter;
+        continue;
+      }
+      IncomingMap[Succ] += Count;
+      OutgoingMap[&BB] += Count;
+      ++SuccBIIter;
+    }
+  }
+
+  if (!opts::AggressiveNeverTaken) {
+    for (auto &TargetToJumps : TargetsToJumps) {
+      const BinaryBasicBlock *TargetBB = TargetToJumps.first;
+      if (TargetBB->getKnownExecutionCount() == 0)
+        continue;
+      const uint64_t IncomingCount = IncomingMap[TargetBB];
+      // If there is a noticeable gap between the incoming edge count and the BB
+      // execution count, then we don't want to trust the 0 execution count
+      // edges as actually 0 execution count.
+      if (IncomingCount * opts::ConservativeNeverTakenThreshold <
+          TargetBB->getKnownExecutionCount()) {
+        for (JumpT *Jump : TargetToJumps.second) {
+          Jump->IsLongNeverTaken = false;
+        }
+      }
+    }
+
+    for (auto &SourceToJumps : SourcesToJumps) {
+      const BinaryBasicBlock *SourceBB = SourceToJumps.first;
+      if (SourceBB->getKnownExecutionCount() == 0)
+        continue;
+      const uint64_t OutgoingCount = OutgoingMap[SourceBB];
+      // If there is a noticeable gap between the outgoing edge count and the BB
+      // execution count, then we don't want to trust the 0 execution count
+      // edges as actually 0 execution count.
+
+      if (OutgoingCount * opts::ConservativeNeverTakenThreshold <
+          SourceBB->getKnownExecutionCount()) {
+        for (JumpT *Jump : SourceToJumps.second) {
+          Jump->IsLongNeverTaken = false;
+        }
+      }
+    }
+  }
+}
+
+uint64_t makeRedirectionDecisions(BlockToJumpsMapTy &TargetsToJumps) {
+  uint64_t NumRedirected = 0;
+  for (auto &TargetToJumps : TargetsToJumps) {
+    std::vector<JumpT *> &Jumps = TargetToJumps.second;
+    if (Jumps.size() <= 1)
+      continue;
+    std::unordered_map<unsigned, JumpT *> MostRecentCondJumps;
+    JumpT *MostRecentUncondJump = nullptr;
+
+    // Round 1: redirect jumps to the closest candidate to its right.
+    for (auto JumpItr = Jumps.rbegin(); JumpItr != Jumps.rend(); ++JumpItr) {
+      JumpT *CurrJump = *JumpItr;
+      if (CurrJump->IsLongNeverTaken) {
+        // Check if we can redirect CurrJump to MostRecentUncondJump.
+        if (MostRecentUncondJump != nullptr) {
+          if (!isLongJump(CurrJump->OriginalAddress + ShortJumpSize,
+                          MostRecentUncondJump->OriginalAddress, true)) {
+            // Redirect CurrJump to MostRecentUncondJump if the latter is close
+            // enough.
+            CurrJump->RedirectionTarget = MostRecentUncondJump;
+            MostRecentUncondJump->IsRedirectionTarget = true;
+            NumRedirected++;
+          } else if (!CurrJump->IsUnconditional) {
+            // Otherwise, try to redirect CurrJump to the most recent
+            // conditional jump with the same conditional code.
+            JumpT *MostRecentCondJump = MostRecentCondJumps[CurrJump->CC];
+            if (MostRecentCondJump != nullptr &&
+                !isLongJump(CurrJump->OriginalAddress + ShortJumpSize,
+                            MostRecentCondJump->OriginalAddress, true)) {
+              CurrJump->RedirectionTarget = MostRecentCondJump;
+              MostRecentCondJump->IsRedirectionTarget = true;
+              NumRedirected++;
+            }
+          }
+        } else if (!CurrJump->IsUnconditional) {
+          // If MostRecentUncondJump does not exist and CurrJump is conditional,
+          // try to redirect CurrJump to the most recent conditional jump with
+          // the same conditional code
+          JumpT *MostRecentCondJump = MostRecentCondJumps[CurrJump->CC];
+          if (MostRecentCondJump != nullptr &&
+              !isLongJump(CurrJump->OriginalAddress + ShortJumpSize,
+                          MostRecentCondJump->OriginalAddress, true)) {
+            CurrJump->RedirectionTarget = MostRecentCondJump;
+            MostRecentCondJump->IsRedirectionTarget = true;
+            NumRedirected++;
+          }
+        }
+      }
+
+      // Update most recent jump by condition.
+      if (CurrJump->IsUnconditional)
+        MostRecentUncondJump = CurrJump;
+      else
+        MostRecentCondJumps[CurrJump->CC] = CurrJump;
+    }
+
+    // Round 2: redirect jumps to the closest candidate to its left while
+    // making shre there are no cyclic redirections.
+    MostRecentCondJumps.clear();
+    MostRecentUncondJump = nullptr;
+    for (auto JumpItr = Jumps.begin(); JumpItr != Jumps.end(); ++JumpItr) {
+      JumpT *CurrJump = *JumpItr;
+      if (CurrJump->IsLongNeverTaken) {
+        if (CurrJump->RedirectionTarget == nullptr) {
+          // Check if we can redirect CurrJump to MostRecentUncondJump.
+          if (MostRecentUncondJump != nullptr) {
+            if (!isLongJump(CurrJump->OriginalAddress + ShortJumpSize,
+                            MostRecentUncondJump->OriginalAddress, true)) {
+              // Redirect CurrJump to MostRecentUncondJump if the latter is
+              // close enough.
+              CurrJump->RedirectionTarget = MostRecentUncondJump;
+              MostRecentUncondJump->IsRedirectionTarget = true;
+              NumRedirected++;
+            } else if (!CurrJump->IsUnconditional) {
+              // Otherwise, try to redirect CurrJump to the most recent
+              // conditional jump with the same conditional code.
+              JumpT *MostRecentCondJump = MostRecentCondJumps[CurrJump->CC];
+              if (MostRecentCondJump != nullptr &&
+                  !isLongJump(CurrJump->OriginalAddress + ShortJumpSize,
+                              MostRecentCondJump->OriginalAddress, true)) {
+                CurrJump->RedirectionTarget = MostRecentCondJump;
+                MostRecentCondJump->IsRedirectionTarget = true;
+                NumRedirected++;
+              }
+            }
+          } else if (!CurrJump->IsUnconditional) {
+            // If MostRecentUncondJump does not exist and CurrJump is
+            // conditional, try to redirect CurrJump to the most recent
+            // conditional jump with the same conditional code
+            JumpT *MostRecentCondJump = MostRecentCondJumps[CurrJump->CC];
+            if (MostRecentCondJump != nullptr &&
+                !isLongJump(CurrJump->OriginalAddress + ShortJumpSize,
+                            MostRecentCondJump->OriginalAddress, true)) {
+              CurrJump->RedirectionTarget = MostRecentCondJump;
+              MostRecentCondJump->IsRedirectionTarget = true;
+              NumRedirected++;
+            }
+          }
+        } else {
+          // If CurrJump has already been redirected in round 1, then use
+          // continue to avoid updating MostRecentUncondJump or
+          // MostRecentCondJumps with CurrJump. This will disallow redirection
+          // to jumps that were redirected in round 1 and hence avoid cyclic
+          // redirections.
+          continue;
+        }
+      }
+
+      // Update most recent jump by condition.
+      if (CurrJump->IsUnconditional)
+        MostRecentUncondJump = CurrJump;
+      else
+        MostRecentCondJumps[CurrJump->CC] = CurrJump;
+    }
+  }
+  return NumRedirected;
+}
+
+void checkDecisionCorrectness(Jumps &JumpsInFunction) {
+  // Check correctness of redirection decisions.
+  for (const auto &Jump : JumpsInFunction) {
+    if (Jump->RedirectionTarget != nullptr) {
+      JumpT *CurrJump = Jump.get();
+      JumpT *NextJump = CurrJump->RedirectionTarget;
+      while (NextJump != nullptr) {
+        // No cyclic redirections.
+        assert(NextJump != Jump.get());
+        // Redirect either to unconditional jump or jump with the same
+        // conditional code.
+        assert(NextJump->CC == CurrJump->CC || NextJump->IsUnconditional);
+        CurrJump = NextJump;
+        NextJump = CurrJump->RedirectionTarget;
+      }
+      // Jump will eventually reach its original target.
+      assert(CurrJump->OriginalTargetBB == Jump->OriginalTargetBB);
+    }
+  }
+}
+
+void redirectJumps(BinaryFunction &Function, Jumps &JumpsInFunction) {
+  const BinaryContext &BC = Function.getBinaryContext();
+  // Helper function to split HomeBB at the JumpInst and return the new
+  // basic block that has JumpInst as its first instruction.
+  auto createJumpBlock = [&](JumpT *Jump) {
+    BinaryBasicBlock *HomeBB = Jump->HomeBB;
+    MCInst *Inst = Jump->Inst;
+
+    // Obtain iterator II pointing to Inst.
+    auto II = HomeBB->end();
+    while (&*II != Inst)
+      II--;
+    return HomeBB->splitInPlaceAt(II);
+  };
+
+  // Split basic blocks at jump instructions that are redirection targets.
+  for (auto JumpItr = JumpsInFunction.rbegin();
+       JumpItr != JumpsInFunction.rend(); ++JumpItr) {
+    JumpT *Jump = (*JumpItr).get();
+    if (!Jump->IsRedirectionTarget)
+      continue;
+    BinaryBasicBlock *NewBB = createJumpBlock(Jump);
+    Jump->HomeBB = NewBB;
+    // If the new block contains two instructions, then it means NewBB
+    // contains both a conditional jump (Jump) and an unconditional
+    // jump (Jump->UncondJumpInSameBlock). We also need to update
+    // the HomeBB of the latter.
+    if (NewBB->getNumNonPseudos() == 2) {
+      assert(Jump->UncondJumpInSameBlock != nullptr);
+      Jump->UncondJumpInSameBlock->HomeBB = NewBB;
+    }
+  }
+
+  // Check correctness of splitting.
+  for (const auto &Jump : JumpsInFunction) {
+    if (Jump->IsRedirectionTarget) {
+      MCInst FirstInst = *(Jump->HomeBB->begin());
+      assert(BC.MIB->getCondCode(FirstInst) == Jump->CC);
+      assert(BC.MIB->getTargetSymbol(FirstInst) ==
+             Jump->OriginalTargetBB->getLabel());
+    }
+  }
+
+  // Perform redirections.
+  for (const auto &Jump : JumpsInFunction) {
+    if (Jump->RedirectionTarget != nullptr) {
+      BinaryBasicBlock *HomeBB = Jump->HomeBB;
+      BinaryBasicBlock *OriginalTargetBB = Jump->OriginalTargetBB;
+      BinaryBasicBlock *NewTargetBB = Jump->RedirectionTarget->HomeBB;
+      HomeBB->replaceSuccessor(OriginalTargetBB, NewTargetBB, /*Count=*/0,
+                               /*MispredictedCount=*/0);
+    }
+  }
+}
+} // namespace
+
+void RedirectNeverTakenJumps::performRedirections(BinaryFunction &Function) {
+  BinaryContext &BC = Function.getBinaryContext();
+
+  // Populate BinaryBasicBlock::OutputAddressRange.
+  uint64_t OldHotSize = 0;
+  uint64_t OldColdSize = 0;
+  std::tie(OldHotSize, OldColdSize) =
+      BC.calculateEmittedSize(Function, /*FixBranches=*/true);
+
+  // Perform redirections.
+  Jumps JumpsInFunction;
+  uint64_t NumJumpsToRedirect = 0;
+  for (FunctionFragment &FF : Function.getLayout().fragments()) {
+    JumpPtrs JumpsInFragment;
+    BlockToJumpsMapTy TargetsToJumps;
+    createJumps(Function, FF, JumpsInFunction, JumpsInFragment);
+    identifyCandidates(Function, JumpsInFragment, TargetsToJumps);
+    NumJumpsToRedirect += makeRedirectionDecisions(TargetsToJumps);
+  }
+  if (NumJumpsToRedirect == 0)
+    return;
+
+  checkDecisionCorrectness(JumpsInFunction);
+  redirectJumps(Function, JumpsInFunction);
+
+  // Log size reduction.
+  const auto [NewHotSize, NewColdSize] =
+      BC.calculateEmittedSize(Function, /*FixBranches*/ true);
+
+  assert(NewHotSize <= OldHotSize);
+  assert(NewColdSize <= OldColdSize);
+
+  TotalSizeSavings += OldHotSize - NewHotSize + OldColdSize - NewColdSize;
+  if (Function.hasValidIndex())
+    TotalHotSizeSavings += OldHotSize - NewHotSize;
+  return;
+}
+
+Error RedirectNeverTakenJumps::runOnFunctions(BinaryContext &BC) {
+  if (!BC.isX86())
+    return Error::success();
+
+  if (opts::RedirectNeverTakenJumps) {
+    ParallelUtilities::PredicateTy SkipFunc = [&](const BinaryFunction &BF) {
+      return !shouldOptimize(BF);
+    };
+
+    ParallelUtilities::runOnEachFunction(
+        BC, ParallelUtilities::SchedulingPolicy::SP_BB_LINEAR,
+        [&](BinaryFunction &BF) { performRedirections(BF); }, SkipFunc,
+        "RedirectNeverTakenJumps", /*ForceSequential*/ false);
+
+    BC.outs() << format(
+        "BOLT-INFO: redirection of never-taken jumps saved %zu bytes hot "
+        "section code size and %zu bytes total code size\n",
+        TotalHotSizeSavings.load(), TotalSizeSavings.load());
+  }
+
+  return Error::success();
+}
diff --git a/bolt/lib/Rewrite/BinaryPassManager.cpp b/bolt/lib/Rewrite/BinaryPassManager.cpp
index b0906041833484..93f0ef482997c8 100644
--- a/bolt/lib/Rewrite/BinaryPassManager.cpp
+++ b/bolt/lib/Rewrite/BinaryPassManager.cpp
@@ -27,6 +27,7 @@
 #include "bolt/Passes/MCF.h"
 #include "bolt/Passes/PLTCall.h"
 #include "bolt/Passes/PatchEntries.h"
+#include "bolt/Passes/RedirectNeverTakenJumps.h"
 #include "bolt/Passes/RegReAssign.h"
 #include "bolt/Passes/ReorderData.h"
 #include "bolt/Passes/ReorderFunctions.h"
@@ -146,6 +147,11 @@ static cl::opt<bool>
                    cl::desc("print functions after peephole optimization"),
                    cl::Hidden, cl::cat(BoltOptCategory));
 
+static cl::opt<bool> PrintRedirectNeverTaken(
+    "print-redirect-never-taken",
+    cl::desc("print functions after redirecting never taken jumps"), cl::Hidden,
+    cl::cat(BoltOptCategory));
+
 static cl::opt<bool>
     PrintPLT("print-plt", cl::desc("print functions after PLT optimization"),
              cl::Hidden, cl::cat(BoltOptCategory));
@@ -462,6 +468,9 @@ Error BinaryFunctionPassManager::runAllPasses(BinaryContext &BC) {
   // splitting.
   Manager.registerPass(std::make_unique<SplitFunctions>(PrintSplit));
 
+  Manager.registerPass(
+      std::make_unique<RedirectNeverTakenJumps>(PrintRedirectNeverTaken));
+
   // Print final dyno stats right while CFG and instruction analysis are intact.
   Manager.registerPass(std::make_unique<DynoStatsPrintPass>(
                            "after all optimizations before SCTC and FOP"),
diff --git a/bolt/test/X86/redirect-never-taken-jumps.s b/bolt/test/X86/redirect-never-taken-jumps.s
new file mode 100644
index 00000000000000..5701383cc1ac55
--- /dev/null
+++ b/bolt/test/X86/redirect-never-taken-jumps.s
@@ -0,0 +1,86 @@
+## Test redirect-never-taken-jumps
+
+# RUN: llvm-mc --filetype=obj --triple x86_64-unknown-unknown %s -o %t.o
+# RUN: link_fdata %s %t.o %t.fdata1 FDATA1
+# RUN: link_fdata %s %t.o %t.fdata2 FDATA2
+# RUN: llvm-strip --strip-unneeded %t.o
+# RUN: %clang %cflags %t.o -o %t.exe -Wl,-q
+
+# RUN: llvm-bolt %t.exe -o %t.bolt --reorder-blocks=none --split-functions=1 \
+# RUN:         --redirect-never-taken-jumps --print-redirect-never-taken --data=%t.fdata1 \
+# RUN:     2>&1 | FileCheck --check-prefix=CHECK_REGULAR %s
+
+# RUN: llvm-bolt %t.exe -o %t.bolt --reorder-blocks=none --split-functions=1 \
+# RUN:         --redirect-never-taken-jumps --data=%t.fdata2 \
+# RUN:     2>&1 | FileCheck --check-prefix=CHECK_CONSERVATIVE_DEFAULT %s
+
+# RUN: llvm-bolt %t.exe -o %t.bolt --reorder-blocks=none --split-functions=1 \
+# RUN:         --redirect-never-taken-jumps --conservative-never-taken-threshold=2.0 --data=%t.fdata2 \
+# RUN:     2>&1 | FileCheck --check-prefix=CHECK_CONSERVATIVE_THRESHOLD %s
+
+# RUN: llvm-bolt %t.exe -o %t.bolt --reorder-blocks=none --split-functions=1 \
+# RUN:         --redirect-never-taken-jumps --aggressive-never-taken --data=%t.fdata2 \
+# RUN:     2>&1 | FileCheck --check-prefix=CHECK_AGGRRESSIVE %s
+
+# CHECK_REGULAR: redirection of never-taken jumps saved 4 bytes hot section code size and 12 bytes total code size
+# CHECK_REGULAR: .LBB00 (1 instructions, align : 1)
+# CHECK_REGULAR: Successors: .LBB2 (mispreds: 0, count: 0), .Ltmp2 (mispreds: 0, count: 20)
+# CHECK_REGULAR: .Ltmp2 (1 instructions, align : 1)
+# CHECK_REGULAR: Successors: .LBB2 (mispreds: 0, count: 20)
+# CHECK_REGULAR: .LBB2 (1 instructions, align : 1)
+# CHECK_REGULAR: Successors: .Ltmp0 (mispreds: 0, count: 0), .LFT0 (mispreds: 0, count: 20)
+# CHECK_REGULAR: .Ltmp3 (1 instructions, align : 1)
+# CHECK_REGULAR: HOT-COLD SPLIT POINT
+# CHECK_REGULAR: .Ltmp0 (2 instructions, align : 1)
+# CHECK_REGULAR: Successors: .LBB1 (mispreds: 0, count: 0), .LBB00 (mispreds: 0, count: 0)
+# CHECk_REGULAR: .Ltmp4 (1 instructions, align : 1)
+# CHECK_REGULAR: Successors: .LBB1 (mispreds: 0, count: 0)
+# CHECk_REGULAR: .LBB1 (2 instructions, align : 1)
+# CHECk_REGULAR: Successors: .LBB0 (mispreds: 0, count: 0), .Ltmp2 (mispreds: 0, count: 0)
+# CHECk_REGULAR: .Ltmp1 (1 instructions, align : 1)
+# CHECK_REGULAR: Successors: .Ltmp4 (mispreds: 0, count: 0), .LBB0 (mispreds: 0, count: 0)
+# CHECk_REGULAR: .LBB0 (1 instructions, align : 1)
+# CHECK_REGULAR: Successors: .Ltmp3 (mispreds: 0, count: 0)
+
+# CHECK_CONSERVATIVE_DEFAULT: redirection of never-taken jumps saved 4 bytes hot section code size and 8 bytes total code size
+# CHECK_CONSERVATIVE_THRESHOLD: redirection of never-taken jumps saved 4 bytes hot section code size and 12 bytes total code size
+# CHECK_AGGRRESSIVE: redirection of never-taken jumps saved 4 bytes hot section code size and 12 bytes total code size
+
+
+        .globl  main
+        .type   main, @function
+main:
+LBB00:
+        ja Ltmp0
+# FDATA1: 1 main #LBB00# 1 main #Ltmp0# 0 0
+# FDATA1: 1 main #LBB00# 1 main #Ltmp2# 0 20
+# FDATA2: 1 main #LBB00# 1 main #Ltmp0# 0 0
+# FDATA2: 1 main #LBB00# 1 main #Ltmp2# 0 10
+Ltmp2:
+        cmpl $0,%eax
+Ltmp2Jcc:
+        ja Ltmp0
+# FDATA1: 1 main #Ltmp2Jcc# 1 main #Ltmp0# 0 0
+# FDATA1: 1 main #Ltmp2Jcc# 1 main #LFT0# 0 20
+# FDATA2: 1 main #Ltmp2Jcc# 1 main #Ltmp0# 0 0
+# FDATA2: 1 main #Ltmp2Jcc# 1 main #LFT0# 0 20
+LFT0:
+        ja Ltmp1
+# FDATA1: 1 main #LFT0# 1 main #Ltmp1# 0 0
+# FDATA1: 1 main #LFT0# 1 main #Ltmp3# 0 20
+# FDATA2: 1 main #LFT0# 1 main #Ltmp1# 0 0
+# FDATA2: 1 main #LFT0# 1 main #Ltmp3# 0 20
+Ltmp3:
+        ret
+Ltmp0:
+        jae Ltmp2
+        jmp LBB00
+Ltmp4:
+        cmpl $0,%eax
+        jae Ltmp2
+        jmp Ltmp3
+Ltmp1:
+        je Ltmp4
+        jmp Ltmp3
+.LLmain_end:
+        .size   main, .LLmain_end-main

From 17f47b2d3cb61d935a0f83d5bc54dc98b36a231e Mon Sep 17 00:00:00 2001
From: Shatian Wang <shatian@meta.com>
Date: Mon, 28 Oct 2024 12:07:43 -0700
Subject: [PATCH 2/2] fixup! [BOLT][X86]Redirect never-taken jumps

---
 bolt/lib/Passes/RedirectNeverTakenJumps.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/bolt/lib/Passes/RedirectNeverTakenJumps.cpp b/bolt/lib/Passes/RedirectNeverTakenJumps.cpp
index 418f055beff306..65bdc6637bbca8 100644
--- a/bolt/lib/Passes/RedirectNeverTakenJumps.cpp
+++ b/bolt/lib/Passes/RedirectNeverTakenJumps.cpp
@@ -112,9 +112,9 @@ void createJumps(BinaryFunction &Function, FunctionFragment &Fragment,
     if (BI.Count != BinaryBasicBlock::COUNT_NO_PROFILE)
       ExecCount = BI.Count;
 
-    const uint64_t JumpEndAddr = TargetBB->getOutputStartAddress();
+    const uint64_t JumpEndAddr = TargetBB->getOutputAddressRange().first;
     const uint64_t JumpStartAddr =
-        SourceBB->getOutputEndAddress() - OffsetFromBlockEnd;
+        SourceBB->getOutputAddressRange().second - OffsetFromBlockEnd;
     const uint8_t LongJumpSize =
         IsUnconditional ? LongUncondJumpSize : LongCondJumpSize;
     const uint8_t JumpInstrSize =
