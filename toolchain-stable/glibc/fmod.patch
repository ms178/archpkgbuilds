This uses a new algorithm similar to already proposed earlier [1].
With x = mx * 2^ex and y = my * 2^ey (mx, my, ex, ey being integers),
the simplest implementation is:

   mx * 2^ex == 2 * mx * 2^(ex - 1)

   while (ex > ey)
     {
       mx *= 2;
       --ex;
       mx %= my;
     }

With mx/my being mantissa of double floating pointer, on each step the
argument reduction can be improved 11 (which is sizeo of uint64_t minus
MANTISSA_WIDTH plus the signal bit):

   while (ex > ey)
     {
       mx << 11;
       ex -= 11;
       mx %= my;
     }  */

The implementation uses builtin clz and ctz, along with shifts to
convert hx/hy back to doubles.  Different than the original patch,
this path assume modulo/divide operation is slow, so use multiplication
with invert values.

I see the following performance improvements using fmod benchtests
(result only show the 'mean' result):

  Architecture     | Input           | master   | patch
  -----------------|-----------------|----------|--------
  x86_64 (Ryzen 9) | subnormals      | 19.1584  | 12.5049
  x86_64 (Ryzen 9) | normal          | 1016.51  | 296.939
  x86_64 (Ryzen 9) | close-exponents | 18.4428  | 16.0244
  aarch64 (N1)     | subnormal       | 11.153   | 6.81778
  aarch64 (N1)     | normal          | 528.649  | 155.62
  aarch64 (N1)     | close-exponents | 11.4517  | 8.21306

I also see similar improvements on arm-linux-gnueabihf when running on
the N1 aarch64 chips, where it a lot of soft-fp implementation (for
modulo, clz, ctz, and multiplication):

  Architecture     | Input           | master   | patch
  -----------------|-----------------|----------|--------
  armhf (N1)       | subnormal       | 15.908   | 15.1083
  armhf (N1)       | normal          | 837.525  | 244.833
  armhf (N1)       | close-exponents | 16.2111  | 21.8182

Instead of using the math_private.h definitions, I used the
math_config.h instead which is used on newer math implementations.

Co-authored-by: kirill <kirill.okhotnikov@gmail.com>

[1] https://sourceware.org/pipermail/libc-alpha/2020-November/119794.html
---
 math/libm-test-fmod.inc              |  16 ++
 sysdeps/ieee754/dbl-64/e_fmod.c      | 232 ++++++++++++++++-----------
 sysdeps/ieee754/dbl-64/math_config.h |  61 +++++++
 3 files changed, 213 insertions(+), 96 deletions(-)

diff --git a/math/libm-test-fmod.inc b/math/libm-test-fmod.inc
index 39fd02f9ef..6d3cdda4fe 100644
--- a/math/libm-test-fmod.inc
+++ b/math/libm-test-fmod.inc
@@ -152,6 +152,16 @@ static const struct test_ff_f_data fmod_test_data[] =
     TEST_ff_f (fmod, 6.5, -2.25L, 2.0L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, -6.5, -2.25L, -2.0L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),

+    TEST_ff_f (fmod, 0x1.e848p+18, 0x1.6p+3, 0x1.8p+2, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, 0x1.e848p+18, -0x1.6p+3, 0x1.8p+2, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x1.e848p+18, 0x1.6p+3, -0x1.8p+2, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x1.e848p+18, -0x1.6p+3, -0x1.8p+2, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+
+    TEST_ff_f (fmod, 0x1.4p+2, 0x1p+0, 0x0p+0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, 0x1.4p+2, -0x1p+0, 0x0p+0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x1.4p+2, 0x1p+0, -0x0p+0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x1.4p+2, -0x1p+0, -0x0p+0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+
     TEST_ff_f (fmod, max_value, max_value, 0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, max_value, -max_value, 0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, max_value, min_value, 0, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
@@ -217,6 +227,12 @@ static const struct test_ff_f_data fmod_test_data[] =
     TEST_ff_f (fmod, -0x1p1023L, 0x3p-1022L, -0x1p-1021L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, -0x1p1023L, -0x3p-1022L, -0x1p-1021L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
 #endif
+#if TEST_COND_binary64
+    TEST_ff_f (fmod, 0x0.cded0a47373e9p-1022, 0x0.3212f5b8c8c16p-1022, 0x0.05a1336414391p-1022, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, 0x0.cded0a47373e9p-1022, -0x0.3212f5b8c8c16p-1022, 0x0.05a1336414391p-1022, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x0.cded0a47373e9p-1022, 0x0.3212f5b8c8c16p-1022, -0x0.05a1336414391p-1022, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x0.cded0a47373e9p-1022, -0x0.3212f5b8c8c16p-1022, -0x0.05a1336414391p-1022, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+#endif
 #if MIN_EXP <= -16381
     TEST_ff_f (fmod, 0x1p16383L, 0x3p-16445L, 0x1p-16445L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, 0x1p16383L, -0x3p-16445L, 0x1p-16445L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
diff --git a/sysdeps/ieee754/dbl-64/e_fmod.c b/sysdeps/ieee754/dbl-64/e_fmod.c
index 60b8bbb9d2..d20466fd5d 100644
--- a/sysdeps/ieee754/dbl-64/e_fmod.c
+++ b/sysdeps/ieee754/dbl-64/e_fmod.c
@@ -1,105 +1,145 @@
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-/*
- * __ieee754_fmod(x,y)
- * Return x mod y in exact arithmetic
- * Method: shift and subtract
- */
+/* Floating-point remainder function.
+   Copyright (C) 2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */

-#include <math.h>
-#include <math_private.h>
-#include <stdint.h>
 #include <libm-alias-finite.h>
+#include <math.h>
+#include "math_config.h"
+
+/* With x = mx * 2^ex and y = my * 2^ey (mx, my, ex, ey being integers), the
+   simplest implementation is:
+
+   mx * 2^ex == 2 * mx * 2^(ex - 1)

-static const double one = 1.0, Zero[] = {0.0, -0.0,};
+   while (ex > ey)
+     {
+       mx *= 2;
+       --ex;
+       mx %= my;
+     }
+
+   With mx/my being mantissa of double floating pointer, on each step the
+   argument reduction can be improved 11 (which is sizeo of uint64_t minus
+   MANTISSA_WIDTH plus the signal bit):
+
+   while (ex > ey)
+     {
+       mx << 11;
+       ex -= 11;
+       mx %= my;
+     }  */

 double
 __ieee754_fmod (double x, double y)
 {
-	int32_t n,ix,iy;
-	int64_t hx,hy,hz,sx,i;
-
-	EXTRACT_WORDS64(hx,x);
-	EXTRACT_WORDS64(hy,y);
-	sx = hx&UINT64_C(0x8000000000000000);	/* sign of x */
-	hx ^=sx;				/* |x| */
-	hy &= UINT64_C(0x7fffffffffffffff);	/* |y| */
-
-    /* purge off exception values */
-	if(__builtin_expect(hy==0
-			    || hx >= UINT64_C(0x7ff0000000000000)
-			    || hy > UINT64_C(0x7ff0000000000000), 0))
-	  /* y=0,or x not finite or y is NaN */
-	    return (x*y)/(x*y);
-	if(__builtin_expect(hx<=hy, 0)) {
-	    if(hx<hy) return x;	/* |x|<|y| return x */
-	    return Zero[(uint64_t)sx>>63];	/* |x|=|y| return x*0*/
-	}
-
-    /* determine ix = ilogb(x) */
-	if(__builtin_expect(hx<UINT64_C(0x0010000000000000), 0)) {
-	  /* subnormal x */
-	  for (ix = -1022,i=(hx<<11); i>0; i<<=1) ix -=1;
-	} else ix = (hx>>52)-1023;
-
-    /* determine iy = ilogb(y) */
-	if(__builtin_expect(hy<UINT64_C(0x0010000000000000), 0)) {	/* subnormal y */
-	  for (iy = -1022,i=(hy<<11); i>0; i<<=1) iy -=1;
-	} else iy = (hy>>52)-1023;
-
-    /* set up hx, hy and align y to x */
-	if(__builtin_expect(ix >= -1022, 1))
-	    hx = UINT64_C(0x0010000000000000)|(UINT64_C(0x000fffffffffffff)&hx);
-	else {		/* subnormal x, shift x to normal */
-	    n = -1022-ix;
-	    hx<<=n;
-	}
-	if(__builtin_expect(iy >= -1022, 1))
-	    hy = UINT64_C(0x0010000000000000)|(UINT64_C(0x000fffffffffffff)&hy);
-	else {		/* subnormal y, shift y to normal */
-	    n = -1022-iy;
-	    hy<<=n;
-	}
-
-    /* fix point fmod */
-	n = ix - iy;
-	while(n--) {
-	    hz=hx-hy;
-	    if(hz<0){hx = hx+hx;}
-	    else {
-		if(hz==0)		/* return sign(x)*0 */
-		    return Zero[(uint64_t)sx>>63];
-		hx = hz+hz;
-	    }
-	}
-	hz=hx-hy;
-	if(hz>=0) {hx=hz;}
-
-    /* convert back to floating value and restore the sign */
-	if(hx==0)			/* return sign(x)*0 */
-	    return Zero[(uint64_t)sx>>63];
-	while(hx<UINT64_C(0x0010000000000000)) {	/* normalize x */
-	    hx = hx+hx;
-	    iy -= 1;
-	}
-	if(__builtin_expect(iy>= -1022, 1)) {	/* normalize output */
-	  hx = ((hx-UINT64_C(0x0010000000000000))|((uint64_t)(iy+1023)<<52));
-	    INSERT_WORDS64(x,hx|sx);
-	} else {		/* subnormal output */
-	    n = -1022 - iy;
-	    hx>>=n;
-	    INSERT_WORDS64(x,hx|sx);
-	    x *= one;		/* create necessary signal */
-	}
-	return x;		/* exact output */
+  uint64_t hx = asuint64 (x);
+  uint64_t hy = asuint64 (y);
+
+  uint64_t sx = hx & SIGN_MASK;
+  /* Get |x| and |y|.  */
+  hx ^= sx;
+  hy &= ~SIGN_MASK;
+
+  /* Special cases:
+     - If x or y is a Nan, NaN is returned.
+     - If x is an inifinity, a NaN is returned.
+     - If y is zero, Nan is returned.
+     - If x is +0/-0, and y is not zero, +0/-0 is returned.  */
+  if (__glibc_unlikely (hy == 0	|| hx >= EXPONENT_MASK || hy > EXPONENT_MASK))
+    return (x * y) / (x * y);
+
+  if (__glibc_unlikely (hx <= hy))
+    {
+      if (hx < hy)
+	return x;
+      return asdouble (sx);
+    }
+
+  int ex = hx >> MANTISSA_WIDTH;
+  int ey = hy >> MANTISSA_WIDTH;
+
+  /* Common case where exponents are close: ey >= -907 and |x/y| < 2^52,  */
+  if (__glibc_likely (ey > MANTISSA_WIDTH && ex - ey <= EXPONENT_WIDTH))
+    {
+      uint64_t mx = (hx & MANTISSA_MASK) | (MANTISSA_MASK + 1);
+      uint64_t my = (hy & MANTISSA_MASK) | (MANTISSA_MASK + 1);
+
+      uint64_t d = (ex == ey) ? (mx - my) : (mx << (ex - ey)) % my;
+      return make_double (d, ey - 1, sx);
+    }
+
+  /* Special case, both x and y are subnormal.  */
+  if (__glibc_unlikely (ex == 0 && ey == 0))
+    return asdouble (sx | hx % hy);
+
+  /* Convert |x| and |y| to 'mx + 2^ex' and 'my + 2^ey'.  Assume that hx is
+     not subnormal by conditions above.  */
+  uint64_t mx = get_mantissa (hx) | (MANTISSA_MASK + 1);
+  ex--;
+  uint64_t my = get_mantissa (hy) | (MANTISSA_MASK + 1);
+
+  int lead_zeros_my = EXPONENT_WIDTH;
+  if (__glibc_likely (ey > 0))
+    ey--;
+  else
+    {
+      my = hy;
+      lead_zeros_my = clz_uint64 (my);
+    }
+
+  /* Assume hy != 0  */
+  int tail_zeros_my = ctz_uint64 (my);
+  int sides_zeroes = lead_zeros_my + tail_zeros_my;
+  int exp_diff = ex - ey;
+
+  int right_shift = exp_diff < tail_zeros_my ? exp_diff : tail_zeros_my;
+  my >>= right_shift;
+  exp_diff -= right_shift;
+  ey += right_shift;
+
+  int left_shift = exp_diff < EXPONENT_WIDTH ? exp_diff : EXPONENT_WIDTH;
+  mx <<= left_shift;
+  exp_diff -= left_shift;
+
+  mx %= my;
+
+  if (__glibc_unlikely (mx == 0))
+    return asdouble (sx);
+
+  if (exp_diff == 0)
+    return make_double (mx, ey, sx);
+
+  /* Assume modulo/divide operation is slow, so use multiplication with invert
+     values.  */
+  uint64_t inv_hy = UINT64_MAX / my;
+  while (exp_diff > sides_zeroes) {
+    exp_diff -= sides_zeroes;
+    uint64_t hd = (mx * inv_hy) >> (BIT_WIDTH - sides_zeroes);
+    mx <<= sides_zeroes;
+    mx -= hd * my;
+    while (__glibc_unlikely (mx > my))
+      mx -= my;
+  }
+  uint64_t hd = (mx * inv_hy) >> (BIT_WIDTH - exp_diff);
+  mx <<= exp_diff;
+  mx -= hd * my;
+  while (__glibc_unlikely (mx > my))
+    mx -= my;
+
+  return make_double (mx, ey, sx);
 }
 libm_alias_finite (__ieee754_fmod, __fmod)
diff --git a/sysdeps/ieee754/dbl-64/math_config.h b/sysdeps/ieee754/dbl-64/math_config.h
index 3cbaeede64..2049cea3f7 100644
--- a/sysdeps/ieee754/dbl-64/math_config.h
+++ b/sysdeps/ieee754/dbl-64/math_config.h
@@ -43,6 +43,24 @@
 # define TOINT_INTRINSICS 0
 #endif

+static inline int
+clz_uint64 (uint64_t x)
+{
+  if (sizeof (uint64_t) == sizeof (unsigned long))
+    return __builtin_clzl (x);
+  else
+    return __builtin_clzll (x);
+}
+
+static inline int
+ctz_uint64 (uint64_t x)
+{
+  if (sizeof (uint64_t) == sizeof (unsigned long))
+    return __builtin_ctzl (x);
+  else
+    return __builtin_ctzll (x);
+}
+
 #if TOINT_INTRINSICS
 /* Round x to nearest int in all rounding modes, ties have to be rounded
    consistently with converttoint so the results match.  If the result
@@ -88,6 +106,49 @@ issignaling_inline (double x)
   return 2 * (ix ^ 0x0008000000000000) > 2 * 0x7ff8000000000000ULL;
 }

+#define BIT_WIDTH       64
+#define MANTISSA_WIDTH  52
+#define EXPONENT_WIDTH  11
+#define MANTISSA_MASK   UINT64_C(0x000fffffffffffff)
+#define EXPONENT_MASK   UINT64_C(0x7ff0000000000000)
+#define EXP_MANT_MASK   UINT64_C(0x7fffffffffffffff)
+#define QUIET_NAN_MASK  UINT64_C(0x0008000000000000)
+#define SIGN_MASK	UINT64_C(0x8000000000000000)
+
+static inline bool
+is_nan (uint64_t x)
+{
+  return (x & EXP_MANT_MASK) > EXPONENT_MASK;
+}
+
+static inline uint64_t
+get_mantissa (uint64_t x)
+{
+  return x & MANTISSA_MASK;
+}
+
+/* Convert integer number X, unbiased exponent EP, and sign S to double:
+
+   result = X * 2^(EP+1 - exponent_bias)
+
+   NB: zero is not supported.  */
+static inline double
+make_double (uint64_t x, int64_t ep, uint64_t s)
+{
+  int lz = clz_uint64 (x) - EXPONENT_WIDTH;
+  x <<= lz;
+  ep -= lz;
+
+  if (__glibc_unlikely (ep < 0 || x == 0))
+    {
+      x >>= -ep;
+      ep = 0;
+    }
+
+  return asdouble (s + x + (ep << MANTISSA_WIDTH));
+}
+
+
 #define NOINLINE __attribute__ ((noinline))

 /* Error handling tail calls for special cases, with a sign argument.
--
2.34.1

This uses a new algorithm similar to already proposed earlier [1].
With x = mx * 2^ex and y = my * 2^ey (mx, my, ex, ey being integers),
the simplest implementation is:

   mx * 2^ex == 2 * mx * 2^(ex - 1)

   while (ex > ey)
     {
       mx *= 2;
       --ex;
       mx %= my;
     }

With mx/my being mantissa of double floating pointer, on each step the
argument reduction can be improved 8 (which is sizeof of uint32_t minus
MANTISSA_WIDTH plus the signal bit):

   while (ex > ey)
     {
       mx << 8;
       ex -= 8;
       mx %= my;
     }  */

The implementation uses builtin clz and ctz, along with shifts to
convert hx/hy back to doubles.  Different than the original patch,
this path assume modulo/divide operation is slow, so use multiplication
with invert values.

I see the following performance improvements using fmod benchtests
(result only show the 'mean' result):

  Architecture     | Input           | master   | patch
  -----------------|-----------------|----------|--------
  x86_64 (Ryzen 9) | subnormals      | 17.2549  | 12.0318
  x86_64 (Ryzen 9) | normal          | 85.4096  | 49.9641
  x86_64 (Ryzen 9) | close-exponents | 19.1072  | 15.8224
  aarch64 (N1)     | subnormal       | 10.2182  | 6.81778
  aarch64 (N1)     | normal          | 60.0616  | 20.3667
  aarch64 (N1)     | close-exponents | 11.5256  | 8.39685

I also see similar improvements on arm-linux-gnueabihf when running on
the N1 aarch64 chips, where it a lot of soft-fp implementation (for
modulo, and multiplication):

  Architecture     | Input           | master   | patch
  -----------------|-----------------|----------|--------
  armhf (N1)       | subnormal       | 11.6662  | 10.8955
  armhf (N1)       | normal          | 69.2759  | 34.1524
  armhf (N1)       | close-exponents | 13.6472  | 18.2131

Instead of using the math_private.h definitions, I used the
math_config.h instead which is used on newer math implementations.

Co-authored-by: kirill <kirill.okhotnikov@gmail.com>

[1] https://sourceware.org/pipermail/libc-alpha/2020-November/119794.html
---
 math/libm-test-fmod.inc              |   5 +
 sysdeps/ieee754/flt-32/e_fmodf.c     | 228 ++++++++++++++++-----------
 sysdeps/ieee754/flt-32/math_config.h |  41 +++++
 3 files changed, 181 insertions(+), 93 deletions(-)

diff --git a/math/libm-test-fmod.inc b/math/libm-test-fmod.inc
index 6d3cdda4fe..4b77b54736 100644
--- a/math/libm-test-fmod.inc
+++ b/math/libm-test-fmod.inc
@@ -226,6 +226,11 @@ static const struct test_ff_f_data fmod_test_data[] =
     TEST_ff_f (fmod, -0x1p1023L, -0x3p-1073L, -0x1p-1073L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, -0x1p1023L, 0x3p-1022L, -0x1p-1021L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
     TEST_ff_f (fmod, -0x1p1023L, -0x3p-1022L, -0x1p-1021L, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+#else
+    TEST_ff_f (fmod, 0x1.3a3e6p-127, 0x1.8b8338p-128, 0x1.d1f31p-129, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, 0x1.3a3e6p-127, -0x1.8b8338p-128, 0x1.d1f31p-129, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x1.3a3e6p-127, 0x1.8b8338p-128, -0x1.d1f31p-129, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
+    TEST_ff_f (fmod, -0x1.3a3e6p-127, -0x1.8b8338p-128, -0x1.d1f31p-129, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
 #endif
 #if TEST_COND_binary64
     TEST_ff_f (fmod, 0x0.cded0a47373e9p-1022, 0x0.3212f5b8c8c16p-1022, 0x0.05a1336414391p-1022, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED),
diff --git a/sysdeps/ieee754/flt-32/e_fmodf.c b/sysdeps/ieee754/flt-32/e_fmodf.c
index b71c4f754f..53db32cbe2 100644
--- a/sysdeps/ieee754/flt-32/e_fmodf.c
+++ b/sysdeps/ieee754/flt-32/e_fmodf.c
@@ -1,102 +1,144 @@
-/* e_fmodf.c -- float version of e_fmod.c.
- */
-
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-/*
- * __ieee754_fmodf(x,y)
- * Return x mod y in exact arithmetic
- * Method: shift and subtract
- */
+/* Floating-point remainder function.
+   Copyright (C) 2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */

-#include <math.h>
-#include <math_private.h>
 #include <libm-alias-finite.h>
+#include <math.h>
+#include "math_config.h"
+
+/* With x = mx * 2^ex and y = my * 2^ey (mx, my, ex, ey being integers), the
+   simplest implementation is:
+
+   mx * 2^ex == 2 * mx * 2^(ex - 1)

-static const float one = 1.0, Zero[] = {0.0, -0.0,};
+   while (ex > ey)
+     {
+       mx *= 2;
+       --ex;
+       mx %= my;
+     }
+
+   With mx/my being mantissa of double floating pointer, on each step the
+   argument reduction can be improved 11 (which is sizeo of uint64_t minus
+   MANTISSA_WIDTH plus the signal bit):
+
+   while (ex > ey)
+     {
+       mx << 11;
+       ex -= 11;
+       mx %= my;
+     }  */

 float
 __ieee754_fmodf (float x, float y)
 {
-	int32_t n,hx,hy,hz,ix,iy,sx,i;
-
-	GET_FLOAT_WORD(hx,x);
-	GET_FLOAT_WORD(hy,y);
-	sx = hx&0x80000000;		/* sign of x */
-	hx ^=sx;		/* |x| */
-	hy &= 0x7fffffff;	/* |y| */
-
-    /* purge off exception values */
-	if(hy==0||(hx>=0x7f800000)||		/* y=0,or x not finite */
-	   (hy>0x7f800000))			/* or y is NaN */
-	    return (x*y)/(x*y);
-	if(hx<hy) return x;			/* |x|<|y| return x */
-	if(hx==hy)
-	    return Zero[(uint32_t)sx>>31];	/* |x|=|y| return x*0*/
-
-    /* determine ix = ilogb(x) */
-	if(hx<0x00800000) {	/* subnormal x */
-	    for (ix = -126,i=(hx<<8); i>0; i<<=1) ix -=1;
-	} else ix = (hx>>23)-127;
-
-    /* determine iy = ilogb(y) */
-	if(hy<0x00800000) {	/* subnormal y */
-	    for (iy = -126,i=(hy<<8); i>=0; i<<=1) iy -=1;
-	} else iy = (hy>>23)-127;
-
-    /* set up {hx,lx}, {hy,ly} and align y to x */
-	if(ix >= -126)
-	    hx = 0x00800000|(0x007fffff&hx);
-	else {		/* subnormal x, shift x to normal */
-	    n = -126-ix;
-	    hx = hx<<n;
-	}
-	if(iy >= -126)
-	    hy = 0x00800000|(0x007fffff&hy);
-	else {		/* subnormal y, shift y to normal */
-	    n = -126-iy;
-	    hy = hy<<n;
-	}
-
-    /* fix point fmod */
-	n = ix - iy;
-	while(n--) {
-	    hz=hx-hy;
-	    if(hz<0){hx = hx+hx;}
-	    else {
-		if(hz==0)		/* return sign(x)*0 */
-		    return Zero[(uint32_t)sx>>31];
-		hx = hz+hz;
-	    }
-	}
-	hz=hx-hy;
-	if(hz>=0) {hx=hz;}
-
-    /* convert back to floating value and restore the sign */
-	if(hx==0)			/* return sign(x)*0 */
-	    return Zero[(uint32_t)sx>>31];
-	while(hx<0x00800000) {		/* normalize x */
-	    hx = hx+hx;
-	    iy -= 1;
-	}
-	if(iy>= -126) {		/* normalize output */
-	    hx = ((hx-0x00800000)|((iy+127)<<23));
-	    SET_FLOAT_WORD(x,hx|sx);
-	} else {		/* subnormal output */
-	    n = -126 - iy;
-	    hx >>= n;
-	    SET_FLOAT_WORD(x,hx|sx);
-	    x *= one;		/* create necessary signal */
-	}
-	return x;		/* exact output */
+  uint32_t hx = asuint (x);
+  uint32_t hy = asuint (y);
+
+  uint32_t sx = hx & SIGN_MASK;
+  /* Get |x| and |y|.  */
+  hx ^= sx;
+  hy &= ~SIGN_MASK;
+
+  /* Special cases:
+     - If x or y is a Nan, NaN is returned.
+     - If x is an inifinity, a NaN is returned.
+     - If y is zero, Nan is returned.
+     - If x is +0/-0, and y is not zero, +0/-0 is returned.  */
+  if (__glibc_unlikely (hy == 0	|| hx >= EXPONENT_MASK || hy > EXPONENT_MASK))
+    return (x * y) / (x * y);
+
+  if (__glibc_unlikely (hx <= hy))
+    {
+      if (hx < hy)
+	return x;
+      return asfloat (sx);
+    }
+
+  int ex = hx >> MANTISSA_WIDTH;
+  int ey = hy >> MANTISSA_WIDTH;
+
+  /* Common case where exponents are close: ey >= -103 and |x/y| < 2^8,  */
+  if (__glibc_likely (ey > MANTISSA_WIDTH && ex - ey <= EXPONENT_WIDTH))
+    {
+      uint64_t mx = (hx & MANTISSA_MASK) | (MANTISSA_MASK + 1);
+      uint64_t my = (hy & MANTISSA_MASK) | (MANTISSA_MASK + 1);
+
+      uint32_t d = (ex == ey) ? (mx - my) : (mx << (ex - ey)) % my;
+      return make_float (d, ey - 1, sx);
+    }
+
+  /* Special case, both x and y are subnormal.  */
+  if (__glibc_unlikely (ex == 0 && ey == 0))
+    return asfloat (sx | hx % hy);
+
+  /* Convert |x| and |y| to 'mx + 2^ex' and 'my + 2^ey'.  Assume that hx is
+     not subnormal by conditions above.  */
+  uint32_t mx = get_mantissa (hx) | (MANTISSA_MASK + 1);
+  ex--;
+
+  uint32_t my = get_mantissa (hy) | (MANTISSA_MASK + 1);
+  int lead_zeros_my = EXPONENT_WIDTH;
+  if (__glibc_likely (ey > 0))
+    ey--;
+  else
+    {
+      my = hy;
+      lead_zeros_my = __builtin_clz (my);
+    }
+
+  int tail_zeros_my = __builtin_ctz (my);
+  int sides_zeroes = lead_zeros_my + tail_zeros_my;
+  int exp_diff = ex - ey;
+
+  int right_shift = exp_diff < tail_zeros_my ? exp_diff : tail_zeros_my;
+  my >>= right_shift;
+  exp_diff -= right_shift;
+  ey += right_shift;
+
+  int left_shift = exp_diff < EXPONENT_WIDTH ? exp_diff : EXPONENT_WIDTH;
+  mx <<= left_shift;
+  exp_diff -= left_shift;
+
+  mx %= my;
+
+  if (__glibc_unlikely (mx == 0))
+    return asfloat (sx);
+
+  if (exp_diff == 0)
+    return make_float (mx, ey, sx);
+
+  /* Assume modulo/divide operation is slow, so use multiplication with invert
+     values.  */
+  uint32_t inv_hy = UINT32_MAX / my;
+  while (exp_diff > sides_zeroes) {
+    exp_diff -= sides_zeroes;
+    uint32_t hd = (mx * inv_hy) >> (BIT_WIDTH - sides_zeroes);
+    mx <<= sides_zeroes;
+    mx -= hd * my;
+    while (__glibc_unlikely (mx > my))
+      mx -= my;
+  }
+  uint32_t hd = (mx * inv_hy) >> (BIT_WIDTH - exp_diff);
+  mx <<= exp_diff;
+  mx -= hd * my;
+  while (__glibc_unlikely (mx > my))
+    mx -= my;
+
+  return make_float (mx, ey, sx);
 }
 libm_alias_finite (__ieee754_fmodf, __fmodf)
diff --git a/sysdeps/ieee754/flt-32/math_config.h b/sysdeps/ieee754/flt-32/math_config.h
index 23045f59d6..829430ea28 100644
--- a/sysdeps/ieee754/flt-32/math_config.h
+++ b/sysdeps/ieee754/flt-32/math_config.h
@@ -110,6 +110,47 @@ issignalingf_inline (float x)
   return 2 * (ix ^ 0x00400000) > 2 * 0x7fc00000UL;
 }

+#define BIT_WIDTH       32
+#define MANTISSA_WIDTH  23
+#define EXPONENT_WIDTH  8
+#define MANTISSA_MASK   0x007fffff
+#define EXPONENT_MASK   0x7f800000
+#define EXP_MANT_MASK   0x7fffffff
+#define QUIET_NAN_MASK  0x00400000
+#define SIGN_MASK       0x80000000
+
+static inline bool
+is_nan (uint32_t x)
+{
+  return (x & EXP_MANT_MASK) > EXPONENT_MASK;
+}
+
+static inline uint32_t
+get_mantissa (uint32_t x)
+{
+  return x & MANTISSA_MASK;
+}
+
+/* Convert integer number X, unbiased exponent EP, and sign S to double:
+
+   result = X * 2^(EP+1 - exponent_bias)
+
+   NB: zero is not supported.  */
+static inline double
+make_float (uint32_t x, int ep, uint32_t s)
+{
+  int lz = __builtin_clz (x) - EXPONENT_WIDTH;
+  x <<= lz;
+  ep -= lz;
+
+  if (__glibc_unlikely (ep < 0 || x == 0))
+    {
+      x >>= -ep;
+      ep = 0;
+    }
+  return asfloat (s + x + (ep << MANTISSA_WIDTH));
+}
+
 #define NOINLINE __attribute__ ((noinline))

 attribute_hidden float __math_oflowf (uint32_t);
--
2.34.1

The error handling is moved to sysdeps/ieee754 version with no SVID
support.  The compatibility symbol versions still use the wrapper
with SVID error handling around the new code.  There is no new symbol
version nor compatibility code on !LIBM_SVID_COMPAT targets
(e.g. riscv).

The ia64 is unchanged, since it still uses the arch specific
__libm_error_region on its implementation.  For both i686 and m68k,
which provive arch specific implementation, wrappers are added so
no new symbol are added (which would require to change the
implementations).

It shows an small improvement, the results for fmod:

  Architecture     | Input           | master   | patch
  -----------------|-----------------|----------|--------
  x86_64 (Ryzen 9) | subnormals      | 12.5049  | 9.40992
  x86_64 (Ryzen 9) | normal          | 296.939  | 296.738
  x86_64 (Ryzen 9) | close-exponents | 16.0244  | 13.119
  aarch64 (N1)     | subnormal       | 6.81778  | 4.33313
  aarch64 (N1)     | normal          | 155.620  | 152.915
  aarch64 (N1)     | close-exponents | 8.21306  | 5.76138
  armhf (N1)       | subnormal       | 15.1083  | 14.5746
  armhf (N1)       | normal          | 244.833  | 241.738
  armhf (N1)       | close-exponents | 21.8182  | 22.457

Checked on x86_64-linux-gnu, i686-linux-gnu, and aarch64-linux-gnu.
---
 math/Versions                                 |  4 ++++
 math/w_fmod_compat.c                          | 13 ++++++++---
 math/w_fmodf_compat.c                         |  6 ++---
 sysdeps/i386/fpu/w_fmod_compat.c              | 14 ++++++++++++
 sysdeps/i386/fpu/w_fmodf_compat.c             | 14 ++++++++++++
 sysdeps/ieee754/dbl-64/e_fmod.c               | 22 +++++++++++++++----
 sysdeps/ieee754/dbl-64/math_config.h          |  9 ++++++++
 sysdeps/ieee754/dbl-64/math_err.c             |  6 +++++
 sysdeps/ieee754/dbl-64/w_fmod.c               |  1 +
 sysdeps/ieee754/flt-32/e_fmodf.c              | 20 ++++++++++++++---
 sysdeps/ieee754/flt-32/math_config.h          |  7 ++++++
 sysdeps/ieee754/flt-32/math_errf.c            |  6 +++++
 sysdeps/ieee754/flt-32/w_fmodf.c              |  1 +
 sysdeps/m68k/m680x0/fpu/w_fmod_compat.c       | 14 ++++++++++++
 sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c      | 14 ++++++++++++
 sysdeps/unix/sysv/linux/aarch64/libm.abilist  |  2 ++
 sysdeps/unix/sysv/linux/alpha/libm.abilist    |  2 ++
 sysdeps/unix/sysv/linux/arm/be/libm.abilist   |  2 ++
 sysdeps/unix/sysv/linux/arm/le/libm.abilist   |  2 ++
 sysdeps/unix/sysv/linux/hppa/libm.abilist     |  2 ++
 .../sysv/linux/m68k/coldfire/libm.abilist     |  2 ++
 .../sysv/linux/microblaze/be/libm.abilist     |  2 ++
 .../sysv/linux/microblaze/le/libm.abilist     |  2 ++
 .../unix/sysv/linux/mips/mips32/libm.abilist  |  2 ++
 .../unix/sysv/linux/mips/mips64/libm.abilist  |  2 ++
 sysdeps/unix/sysv/linux/nios2/libm.abilist    |  2 ++
 .../linux/powerpc/powerpc32/fpu/libm.abilist  |  2 ++
 .../powerpc/powerpc32/nofpu/libm.abilist      |  2 ++
 .../linux/powerpc/powerpc64/be/libm.abilist   |  2 ++
 .../linux/powerpc/powerpc64/le/libm.abilist   |  2 ++
 .../unix/sysv/linux/s390/s390-32/libm.abilist |  2 ++
 .../unix/sysv/linux/s390/s390-64/libm.abilist |  2 ++
 sysdeps/unix/sysv/linux/sh/be/libm.abilist    |  2 ++
 sysdeps/unix/sysv/linux/sh/le/libm.abilist    |  2 ++
 .../sysv/linux/sparc/sparc32/libm.abilist     |  2 ++
 .../sysv/linux/sparc/sparc64/libm.abilist     |  2 ++
 .../unix/sysv/linux/x86_64/64/libm.abilist    |  2 ++
 .../unix/sysv/linux/x86_64/x32/libm.abilist   |  2 ++
 38 files changed, 184 insertions(+), 13 deletions(-)
 create mode 100644 sysdeps/i386/fpu/w_fmod_compat.c
 create mode 100644 sysdeps/i386/fpu/w_fmodf_compat.c
 create mode 100644 sysdeps/ieee754/dbl-64/w_fmod.c
 create mode 100644 sysdeps/ieee754/flt-32/w_fmodf.c
 create mode 100644 sysdeps/m68k/m680x0/fpu/w_fmod_compat.c
 create mode 100644 sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c

diff --git a/math/Versions b/math/Versions
index fef7a08c3b..759b5fac7f 100644
--- a/math/Versions
+++ b/math/Versions
@@ -631,4 +631,8 @@ libm {
     # No SVID compatible error handling.
     hypotf; hypot;
   }
+  GLIBC_2.37 {
+    # No SVID compatible error handling.
+    fmod; fmodf;
+  }
 }
diff --git a/math/w_fmod_compat.c b/math/w_fmod_compat.c
index c6947f3042..aef98885a3 100644
--- a/math/w_fmod_compat.c
+++ b/math/w_fmod_compat.c
@@ -20,10 +20,10 @@
 #include <math-svid-compat.h>
 #include <libm-alias-double.h>

-#if LIBM_SVID_COMPAT
+#if LIBM_SVID_COMPAT && SHLIB_COMPAT (libm, GLIBC_2_0, GLIBC_2_37)
 /* wrapper fmod */
 double
-__fmod (double x, double y)
+__fmod_compat (double x, double y)
 {
   if (__builtin_expect (isinf (x) || y == 0.0, 0)
       && _LIB_VERSION != _IEEE_ && !isnan (y) && !isnan (x))
@@ -32,5 +32,12 @@ __fmod (double x, double y)

   return __ieee754_fmod (x, y);
 }
-libm_alias_double (__fmod, fmod)
+compat_symbol (libm, __fmod_compat, fmod, GLIBC_2_0);
+# ifdef NO_LONG_DOUBLE
+weak_alias (__fmod_compat, fmodl)
+# endif
+# ifdef LONG_DOUBLE_COMPAT
+LONG_DOUBLE_COMPAT_CHOOSE_libm_fmodl (
+  compat_symbol (libm, __fmod_compat, fmodl, FIRST_VERSION_libm_fmodl), );
+# endif
 #endif
diff --git a/math/w_fmodf_compat.c b/math/w_fmodf_compat.c
index 5025b06684..55823961f4 100644
--- a/math/w_fmodf_compat.c
+++ b/math/w_fmodf_compat.c
@@ -20,10 +20,10 @@
 #include <math-svid-compat.h>
 #include <libm-alias-float.h>

-#if LIBM_SVID_COMPAT
+#if LIBM_SVID_COMPAT && SHLIB_COMPAT (libm, GLIBC_2_0, GLIBC_2_37)
 /* wrapper fmodf */
 float
-__fmodf (float x, float y)
+__fmod_compatf (float x, float y)
 {
   if (__builtin_expect (isinf (x) || y == 0.0f, 0)
       && _LIB_VERSION != _IEEE_ && !isnan (y) && !isnan (x))
@@ -32,5 +32,5 @@ __fmodf (float x, float y)

   return __ieee754_fmodf (x, y);
 }
-libm_alias_float (__fmod, fmod)
+compat_symbol (libm, __fmod_compatf, fmodf, GLIBC_2_0);
 #endif
diff --git a/sysdeps/i386/fpu/w_fmod_compat.c b/sysdeps/i386/fpu/w_fmod_compat.c
new file mode 100644
index 0000000000..5ac9995ffd
--- /dev/null
+++ b/sysdeps/i386/fpu/w_fmod_compat.c
@@ -0,0 +1,14 @@
+/* i386 provides an optimized __ieee752_fmod.  */
+#include <math-svid-compat.h>
+#ifdef SHARED
+# undef SHLIB_COMPAT
+# define SHLIB_COMPAT(a, b, c) 1
+# undef LIBM_SVID_COMPAT
+# define LIBM_SVID_COMPAT 1
+# undef compat_symbol
+# define compat_symbol(a, b, c, d)
+#endif
+#include <math/w_fmod_compat.c>
+#ifdef SHARED
+libm_alias_double (__fmod_compat, fmod)
+#endif
diff --git a/sysdeps/i386/fpu/w_fmodf_compat.c b/sysdeps/i386/fpu/w_fmodf_compat.c
new file mode 100644
index 0000000000..cc417e07d3
--- /dev/null
+++ b/sysdeps/i386/fpu/w_fmodf_compat.c
@@ -0,0 +1,14 @@
+/* i386 provides an optimized __ieee752_fmodf.  */
+#include <math-svid-compat.h>
+#ifdef SHARED
+# undef SHLIB_COMPAT
+# define SHLIB_COMPAT(a, b, c) 1
+# undef LIBM_SVID_COMPAT
+# define LIBM_SVID_COMPAT 1
+# undef compat_symbol
+# define compat_symbol(a, b, c, d)
+#endif
+#include <math/w_fmodf_compat.c>
+#ifdef SHARED
+libm_alias_float (__fmod_compat, fmod)
+#endif
diff --git a/sysdeps/ieee754/dbl-64/e_fmod.c b/sysdeps/ieee754/dbl-64/e_fmod.c
index d20466fd5d..ff506c40b4 100644
--- a/sysdeps/ieee754/dbl-64/e_fmod.c
+++ b/sysdeps/ieee754/dbl-64/e_fmod.c
@@ -16,7 +16,9 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */

+#include <libm-alias-double.h>
 #include <libm-alias-finite.h>
+#include <math-svid-compat.h>
 #include <math.h>
 #include "math_config.h"

@@ -44,7 +46,7 @@
      }  */

 double
-__ieee754_fmod (double x, double y)
+__fmod (double x, double y)
 {
   uint64_t hx = asuint64 (x);
   uint64_t hy = asuint64 (y);
@@ -56,11 +58,16 @@ __ieee754_fmod (double x, double y)

   /* Special cases:
      - If x or y is a Nan, NaN is returned.
-     - If x is an inifinity, a NaN is returned.
+     - If x is an inifinity, a NaN is returned and EDOM is set.
      - If y is zero, Nan is returned.
      - If x is +0/-0, and y is not zero, +0/-0 is returned.  */
-  if (__glibc_unlikely (hy == 0	|| hx >= EXPONENT_MASK || hy > EXPONENT_MASK))
-    return (x * y) / (x * y);
+  if (__glibc_unlikely (hy == 0
+			|| hx >= EXPONENT_MASK || hy > EXPONENT_MASK))
+    {
+      if (is_nan (hx) || is_nan (hy))
+	return (x * y) / (x * y);
+      return __math_edom ((x * y) / (x * y));
+    }

   if (__glibc_unlikely (hx <= hy))
     {
@@ -142,4 +149,11 @@ __ieee754_fmod (double x, double y)

   return make_double (mx, ey, sx);
 }
+strong_alias (__fmod, __ieee754_fmod)
 libm_alias_finite (__ieee754_fmod, __fmod)
+#if LIBM_SVID_COMPAT
+versioned_symbol (libm, __fmod, fmod, GLIBC_2_37);
+libm_alias_double_other (__fmod, fmod)
+#else
+libm_alias_double (__fmod, fmod)
+#endif
diff --git a/sysdeps/ieee754/dbl-64/math_config.h b/sysdeps/ieee754/dbl-64/math_config.h
index 2049cea3f7..5173b99e4a 100644
--- a/sysdeps/ieee754/dbl-64/math_config.h
+++ b/sysdeps/ieee754/dbl-64/math_config.h
@@ -121,6 +121,12 @@ is_nan (uint64_t x)
   return (x & EXP_MANT_MASK) > EXPONENT_MASK;
 }

+static inline bool
+is_inf (uint64_t x)
+{
+  return (x & EXP_MANT_MASK) == EXPONENT_MASK;
+}
+
 static inline uint64_t
 get_mantissa (uint64_t x)
 {
@@ -170,6 +176,9 @@ attribute_hidden double __math_invalid (double);

 /* Error handling using output checking, only for errno setting.  */

+/* Check if the result generated a demain error.  */
+attribute_hidden double __math_edom (double x);
+
 /* Check if the result overflowed to infinity.  */
 attribute_hidden double __math_check_oflow (double);
 /* Check if the result underflowed to 0.  */
diff --git a/sysdeps/ieee754/dbl-64/math_err.c b/sysdeps/ieee754/dbl-64/math_err.c
index 5f5f965d3e..377a4caad2 100644
--- a/sysdeps/ieee754/dbl-64/math_err.c
+++ b/sysdeps/ieee754/dbl-64/math_err.c
@@ -33,6 +33,12 @@ with_errno (double y, int e)
 #define with_errno(x, e) (x)
 #endif

+attribute_hidden double
+__math_edom (double y)
+{
+  return with_errno (y, EDOM);
+}
+
 /* NOINLINE reduces code size.  */
 NOINLINE static double
 xflow (uint32_t sign, double y)
diff --git a/sysdeps/ieee754/dbl-64/w_fmod.c b/sysdeps/ieee754/dbl-64/w_fmod.c
new file mode 100644
index 0000000000..1cc8931700
--- /dev/null
+++ b/sysdeps/ieee754/dbl-64/w_fmod.c
@@ -0,0 +1 @@
+/* Not needed.  */
diff --git a/sysdeps/ieee754/flt-32/e_fmodf.c b/sysdeps/ieee754/flt-32/e_fmodf.c
index 53db32cbe2..c0b5dccc23 100644
--- a/sysdeps/ieee754/flt-32/e_fmodf.c
+++ b/sysdeps/ieee754/flt-32/e_fmodf.c
@@ -17,6 +17,8 @@
    <https://www.gnu.org/licenses/>.  */

 #include <libm-alias-finite.h>
+#include <libm-alias-float.h>
+#include <math-svid-compat.h>
 #include <math.h>
 #include "math_config.h"

@@ -44,7 +46,7 @@
      }  */

 float
-__ieee754_fmodf (float x, float y)
+__fmodf (float x, float y)
 {
   uint32_t hx = asuint (x);
   uint32_t hy = asuint (y);
@@ -59,8 +61,13 @@ __ieee754_fmodf (float x, float y)
      - If x is an inifinity, a NaN is returned.
      - If y is zero, Nan is returned.
      - If x is +0/-0, and y is not zero, +0/-0 is returned.  */
-  if (__glibc_unlikely (hy == 0	|| hx >= EXPONENT_MASK || hy > EXPONENT_MASK))
-    return (x * y) / (x * y);
+  if (__glibc_unlikely (hy == 0
+			|| hx >= EXPONENT_MASK || hy > EXPONENT_MASK))
+    {
+      if (is_nan (hx) || is_nan (hy))
+	return (x * y) / (x * y);
+      return __math_edomf ((x * y) / (x * y));
+    }

   if (__glibc_unlikely (hx <= hy))
     {
@@ -141,4 +148,11 @@ __ieee754_fmodf (float x, float y)

   return make_float (mx, ey, sx);
 }
+strong_alias (__fmodf, __ieee754_fmodf)
+#if LIBM_SVID_COMPAT
+versioned_symbol (libm, __fmodf, fmodf, GLIBC_2_37);
+libm_alias_float_other (__fmod, fmod)
+#else
+libm_alias_float (__fmod, fmod)
+#endif
 libm_alias_finite (__ieee754_fmodf, __fmodf)
diff --git a/sysdeps/ieee754/flt-32/math_config.h b/sysdeps/ieee754/flt-32/math_config.h
index 829430ea28..f97cd39df1 100644
--- a/sysdeps/ieee754/flt-32/math_config.h
+++ b/sysdeps/ieee754/flt-32/math_config.h
@@ -125,6 +125,12 @@ is_nan (uint32_t x)
   return (x & EXP_MANT_MASK) > EXPONENT_MASK;
 }

+static inline bool
+is_inf (uint32_t x)
+{
+  return (x & EXP_MANT_MASK) == EXPONENT_MASK;
+}
+
 static inline uint32_t
 get_mantissa (uint32_t x)
 {
@@ -158,6 +164,7 @@ attribute_hidden float __math_uflowf (uint32_t);
 attribute_hidden float __math_may_uflowf (uint32_t);
 attribute_hidden float __math_divzerof (uint32_t);
 attribute_hidden float __math_invalidf (float);
+attribute_hidden float __math_edomf (float x);

 /* Shared between expf, exp2f, exp10f, and powf.  */
 #define EXP2F_TABLE_BITS 5
diff --git a/sysdeps/ieee754/flt-32/math_errf.c b/sysdeps/ieee754/flt-32/math_errf.c
index 0389ce0a81..7245ab8d96 100644
--- a/sysdeps/ieee754/flt-32/math_errf.c
+++ b/sysdeps/ieee754/flt-32/math_errf.c
@@ -31,6 +31,12 @@ with_errnof (float y, int e)
 # define with_errnof(x, e) (x)
 #endif

+attribute_hidden float
+__math_edomf (float y)
+{
+  return with_errnof (y, EDOM);
+}
+
 /* NOINLINE prevents fenv semantics breaking optimizations.  */
 NOINLINE static float
 xflowf (uint32_t sign, float y)
diff --git a/sysdeps/ieee754/flt-32/w_fmodf.c b/sysdeps/ieee754/flt-32/w_fmodf.c
new file mode 100644
index 0000000000..1cc8931700
--- /dev/null
+++ b/sysdeps/ieee754/flt-32/w_fmodf.c
@@ -0,0 +1 @@
+/* Not needed.  */
diff --git a/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c b/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c
new file mode 100644
index 0000000000..527d4fbed2
--- /dev/null
+++ b/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c
@@ -0,0 +1,14 @@
+/* m68k provides an optimized __ieee752_fmod.  */
+#include <math-svid-compat.h>
+#ifdef SHARED
+# undef SHLIB_COMPAT
+# define SHLIB_COMPAT(a, b, c) 1
+# undef LIBM_SVID_COMPAT
+# define LIBM_SVID_COMPAT 1
+# undef compat_symbol
+# define compat_symbol(a, b, c, d)
+#endif
+#include <math/w_fmod_compat.c>
+#ifdef SHARED
+libm_alias_double (__fmod_compat, fmod)
+#endif
diff --git a/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c b/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c
new file mode 100644
index 0000000000..5043586b91
--- /dev/null
+++ b/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c
@@ -0,0 +1,14 @@
+/* m68k provides an optimized __ieee752_fmodf.  */
+#include <math-svid-compat.h>
+#ifdef SHARED
+# undef SHLIB_COMPAT
+# define SHLIB_COMPAT(a, b, c) 1
+# undef LIBM_SVID_COMPAT
+# define LIBM_SVID_COMPAT 1
+# undef compat_symbol
+# define compat_symbol(a, b, c, d)
+#endif
+#include <math/w_fmodf_compat.c>
+#ifdef SHARED
+libm_alias_float (__fmod_compat, fmod)
+#endif
diff --git a/sysdeps/unix/sysv/linux/aarch64/libm.abilist b/sysdeps/unix/sysv/linux/aarch64/libm.abilist
index c2e3c6453e..e3924c3499 100644
--- a/sysdeps/unix/sysv/linux/aarch64/libm.abilist
+++ b/sysdeps/unix/sysv/linux/aarch64/libm.abilist
@@ -1146,3 +1146,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/alpha/libm.abilist b/sysdeps/unix/sysv/linux/alpha/libm.abilist
index 4f85b6180f..066dd1a6b3 100644
--- a/sysdeps/unix/sysv/linux/alpha/libm.abilist
+++ b/sysdeps/unix/sysv/linux/alpha/libm.abilist
@@ -1203,6 +1203,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/arm/be/libm.abilist b/sysdeps/unix/sysv/linux/arm/be/libm.abilist
index 36190add84..4adfed072b 100644
--- a/sysdeps/unix/sysv/linux/arm/be/libm.abilist
+++ b/sysdeps/unix/sysv/linux/arm/be/libm.abilist
@@ -533,6 +533,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 _LIB_VERSION D 0x4
 GLIBC_2.4 __clog10 F
 GLIBC_2.4 __clog10f F
diff --git a/sysdeps/unix/sysv/linux/arm/le/libm.abilist b/sysdeps/unix/sysv/linux/arm/le/libm.abilist
index 36190add84..4adfed072b 100644
--- a/sysdeps/unix/sysv/linux/arm/le/libm.abilist
+++ b/sysdeps/unix/sysv/linux/arm/le/libm.abilist
@@ -533,6 +533,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 _LIB_VERSION D 0x4
 GLIBC_2.4 __clog10 F
 GLIBC_2.4 __clog10f F
diff --git a/sysdeps/unix/sysv/linux/hppa/libm.abilist b/sysdeps/unix/sysv/linux/hppa/libm.abilist
index b5dd4e851f..5c3f47caef 100644
--- a/sysdeps/unix/sysv/linux/hppa/libm.abilist
+++ b/sysdeps/unix/sysv/linux/hppa/libm.abilist
@@ -844,4 +844,6 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 exp2l F
diff --git a/sysdeps/unix/sysv/linux/m68k/coldfire/libm.abilist b/sysdeps/unix/sysv/linux/m68k/coldfire/libm.abilist
index 36190add84..4adfed072b 100644
--- a/sysdeps/unix/sysv/linux/m68k/coldfire/libm.abilist
+++ b/sysdeps/unix/sysv/linux/m68k/coldfire/libm.abilist
@@ -533,6 +533,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 _LIB_VERSION D 0x4
 GLIBC_2.4 __clog10 F
 GLIBC_2.4 __clog10f F
diff --git a/sysdeps/unix/sysv/linux/microblaze/be/libm.abilist b/sysdeps/unix/sysv/linux/microblaze/be/libm.abilist
index 274ecff630..ea0dbd4b72 100644
--- a/sysdeps/unix/sysv/linux/microblaze/be/libm.abilist
+++ b/sysdeps/unix/sysv/linux/microblaze/be/libm.abilist
@@ -845,3 +845,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/microblaze/le/libm.abilist b/sysdeps/unix/sysv/linux/microblaze/le/libm.abilist
index 274ecff630..ea0dbd4b72 100644
--- a/sysdeps/unix/sysv/linux/microblaze/le/libm.abilist
+++ b/sysdeps/unix/sysv/linux/microblaze/le/libm.abilist
@@ -845,3 +845,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/mips/mips32/libm.abilist b/sysdeps/unix/sysv/linux/mips/mips32/libm.abilist
index 08b902118d..7c94a8db70 100644
--- a/sysdeps/unix/sysv/linux/mips/mips32/libm.abilist
+++ b/sysdeps/unix/sysv/linux/mips/mips32/libm.abilist
@@ -844,4 +844,6 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 exp2l F
diff --git a/sysdeps/unix/sysv/linux/mips/mips64/libm.abilist b/sysdeps/unix/sysv/linux/mips/mips64/libm.abilist
index 09bb3bd75b..0d08245adf 100644
--- a/sysdeps/unix/sysv/linux/mips/mips64/libm.abilist
+++ b/sysdeps/unix/sysv/linux/mips/mips64/libm.abilist
@@ -1146,3 +1146,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/nios2/libm.abilist b/sysdeps/unix/sysv/linux/nios2/libm.abilist
index 11abbb5668..a3b776fece 100644
--- a/sysdeps/unix/sysv/linux/nios2/libm.abilist
+++ b/sysdeps/unix/sysv/linux/nios2/libm.abilist
@@ -845,3 +845,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/powerpc/powerpc32/fpu/libm.abilist b/sysdeps/unix/sysv/linux/powerpc/powerpc32/fpu/libm.abilist
index 1688809c36..c696215739 100644
--- a/sysdeps/unix/sysv/linux/powerpc/powerpc32/fpu/libm.abilist
+++ b/sysdeps/unix/sysv/linux/powerpc/powerpc32/fpu/libm.abilist
@@ -890,6 +890,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/powerpc/powerpc32/nofpu/libm.abilist b/sysdeps/unix/sysv/linux/powerpc/powerpc32/nofpu/libm.abilist
index e880cebd78..a5ce9b1997 100644
--- a/sysdeps/unix/sysv/linux/powerpc/powerpc32/nofpu/libm.abilist
+++ b/sysdeps/unix/sysv/linux/powerpc/powerpc32/nofpu/libm.abilist
@@ -889,6 +889,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/powerpc/powerpc64/be/libm.abilist b/sysdeps/unix/sysv/linux/powerpc/powerpc64/be/libm.abilist
index 033385dfc1..8e41056d0d 100644
--- a/sysdeps/unix/sysv/linux/powerpc/powerpc64/be/libm.abilist
+++ b/sysdeps/unix/sysv/linux/powerpc/powerpc64/be/libm.abilist
@@ -883,6 +883,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/powerpc/powerpc64/le/libm.abilist b/sysdeps/unix/sysv/linux/powerpc/powerpc64/le/libm.abilist
index 7923d428bc..939f29a0f2 100644
--- a/sysdeps/unix/sysv/linux/powerpc/powerpc64/le/libm.abilist
+++ b/sysdeps/unix/sysv/linux/powerpc/powerpc64/le/libm.abilist
@@ -1318,3 +1318,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/s390/s390-32/libm.abilist b/sysdeps/unix/sysv/linux/s390/s390-32/libm.abilist
index 9a84163089..4baefb1217 100644
--- a/sysdeps/unix/sysv/linux/s390/s390-32/libm.abilist
+++ b/sysdeps/unix/sysv/linux/s390/s390-32/libm.abilist
@@ -1147,6 +1147,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/s390/s390-64/libm.abilist b/sysdeps/unix/sysv/linux/s390/s390-64/libm.abilist
index 174bde4fa0..debb767575 100644
--- a/sysdeps/unix/sysv/linux/s390/s390-64/libm.abilist
+++ b/sysdeps/unix/sysv/linux/s390/s390-64/libm.abilist
@@ -1147,6 +1147,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/sh/be/libm.abilist b/sysdeps/unix/sysv/linux/sh/be/libm.abilist
index 1e1324d667..fb94386fff 100644
--- a/sysdeps/unix/sysv/linux/sh/be/libm.abilist
+++ b/sysdeps/unix/sysv/linux/sh/be/libm.abilist
@@ -844,4 +844,6 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 exp2l F
diff --git a/sysdeps/unix/sysv/linux/sh/le/libm.abilist b/sysdeps/unix/sysv/linux/sh/le/libm.abilist
index 1e1324d667..fb94386fff 100644
--- a/sysdeps/unix/sysv/linux/sh/le/libm.abilist
+++ b/sysdeps/unix/sysv/linux/sh/le/libm.abilist
@@ -844,4 +844,6 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 exp2l F
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc32/libm.abilist b/sysdeps/unix/sysv/linux/sparc/sparc32/libm.abilist
index 217e6eff7f..2fdb5ff145 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc32/libm.abilist
+++ b/sysdeps/unix/sysv/linux/sparc/sparc32/libm.abilist
@@ -1154,6 +1154,8 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
 GLIBC_2.4 __clog10l F
 GLIBC_2.4 __finitel F
 GLIBC_2.4 __fpclassifyl F
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc64/libm.abilist b/sysdeps/unix/sysv/linux/sparc/sparc64/libm.abilist
index 6b53b0c59f..02d4c3a754 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc64/libm.abilist
+++ b/sysdeps/unix/sysv/linux/sparc/sparc64/libm.abilist
@@ -1146,3 +1146,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/libm.abilist b/sysdeps/unix/sysv/linux/x86_64/64/libm.abilist
index dbefbc3a1a..cc8be5b510 100644
--- a/sysdeps/unix/sysv/linux/x86_64/64/libm.abilist
+++ b/sysdeps/unix/sysv/linux/x86_64/64/libm.abilist
@@ -1179,3 +1179,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/libm.abilist b/sysdeps/unix/sysv/linux/x86_64/x32/libm.abilist
index 8001d0f219..fda4df2653 100644
--- a/sysdeps/unix/sysv/linux/x86_64/x32/libm.abilist
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/libm.abilist
@@ -1179,3 +1179,5 @@ GLIBC_2.35 fsqrt F
 GLIBC_2.35 fsqrtl F
 GLIBC_2.35 hypot F
 GLIBC_2.35 hypotf F
+GLIBC_2.37 fmod F
+GLIBC_2.37 fmodf F
--
2.34.1
