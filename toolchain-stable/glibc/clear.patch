--- glibc-2.25/math/Makefile~	2017-02-05 15:28:43.000000000 +0000
+++ glibc-2.25/math/Makefile	2017-07-29 13:52:56.181213874 +0000
@@ -21,6 +21,8 @@

 include ../Makeconfig

+CFLAGS-.o += -fno-stack-protector -fno-math-errno -falign-functions=32 -flto=auto
+
 # Installed header files.
 headers		:= math.h bits/mathcalls.h \
 		   fpu_control.h complex.h bits/cmathcalls.h fenv.h \
--- glibc-2.37/sysdeps/generic/adaptive_spin_count.h~	2023-02-01 03:27:45.000000000 +0000
+++ glibc-2.37/sysdeps/generic/adaptive_spin_count.h	2023-04-20 16:24:07.132939021 +0000
@@ -19,4 +19,4 @@
 /* The choice of 100 spins for the default spin count for an adaptive spin
    is a completely arbitrary choice that has not been evaluated thoroughly
    using modern hardware.  */
-#define DEFAULT_ADAPTIVE_COUNT 100
+#define DEFAULT_ADAPTIVE_COUNT 5000
--- glibc-2.24/malloc/malloc.c~	2016-11-13 22:53:14.000000000 +0000
+++ glibc-2.24/malloc/malloc.c	2016-11-13 23:01:29.750884186 +0000
@@ -858,7 +858,7 @@
 #define M_TRIM_THRESHOLD       -1

 #ifndef DEFAULT_TRIM_THRESHOLD
-#define DEFAULT_TRIM_THRESHOLD (128 * 1024)
+#define DEFAULT_TRIM_THRESHOLD (512 * 1024)
 #endif

 /*
@@ -891,7 +891,7 @@
 #define M_TOP_PAD              -2

 #ifndef DEFAULT_TOP_PAD
-#define DEFAULT_TOP_PAD        (0)
+#define DEFAULT_TOP_PAD        (256 * 1024)
 #endif

 /*
--- glibc-2.36/malloc/malloc.c~	2022-07-29 22:03:09.000000000 +0000
+++ glibc-2.36/malloc/malloc.c	2022-09-02 18:38:17.273948072 +0000
@@ -958,7 +958,7 @@
 */

 #ifndef DEFAULT_MMAP_THRESHOLD_MIN
-#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)
+#define DEFAULT_MMAP_THRESHOLD_MIN (512 * 1024)
 #endif

 #ifndef DEFAULT_MMAP_THRESHOLD_MAX
--- glibc-2.36/malloc/arena.c~	2022-07-29 22:03:09.000000000 +0000
+++ glibc-2.36/malloc/arena.c	2022-11-08 17:43:39.951807284 +0000
@@ -940,11 +940,11 @@
               int n = __get_nprocs_sched ();

               if (n >= 1)
-                narenas_limit = NARENAS_FROM_NCORES (n);
+                narenas_limit = NARENAS_FROM_NCORES (n + 32);
               else
                 /* We have no information about the system.  Assume two
                    cores.  */
-                narenas_limit = NARENAS_FROM_NCORES (2);
+                narenas_limit = NARENAS_FROM_NCORES (2 + 32);
             }
         }
     repeat:;
--- glibc-2.36/malloc/malloc.c~	2022-09-02 18:38:17.000000000 +0000
+++ glibc-2.36/malloc/malloc.c	2022-11-08 20:32:05.797225851 +0000
@@ -2710,6 +2710,9 @@
 #endif
 	size = ALIGN_UP (size, GLRO(dl_pagesize));

+     if (size < 512 * 1024)
+	 size = 512 * 1024;
+
       /*
          Don't try to call MORECORE if argument is so big as to appear
          negative. Note that since mmap takes size_t arg, it may succeed
From 9c308b6c4800e39bed92becde22c4a5365510b35 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <michael.i.doherty@intel.com>
Date: Thu, 9 Apr 2015 16:24:28 +0100
Subject: [PATCH] locale: Use cache location

Signed-off-by: Ikey Doherty <michael.i.doherty@intel.com>
---
 locale/loadarchive.c         | 2 +-
 locale/programs/locale.c     | 2 +-
 locale/programs/locarchive.c | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/locale/loadarchive.c b/locale/loadarchive.c
index 0ac11af..4767db2 100644
--- a/locale/loadarchive.c
+++ b/locale/loadarchive.c
@@ -42,7 +42,7 @@


 /* Name of the locale archive file.  */
-static const char archfname[] = COMPLOCALEDIR "/locale-archive";
+static const char archfname[] = "/var/cache/locale/locale-archive";

 /* Size of initial mapping window, optimal if large enough to
    cover the header plus the initial locale.  */
diff --git a/locale/programs/locale.c b/locale/programs/locale.c
index 6cb3d5e..6fd43c6 100644
--- a/locale/programs/locale.c
+++ b/locale/programs/locale.c
@@ -45,7 +45,7 @@
 #include "../locarchive.h"
 #include <programs/xmalloc.h>

-#define ARCHIVE_NAME COMPLOCALEDIR "/locale-archive"
+#define ARCHIVE_NAME "/var/cache/locale/locale-archive"

 /* If set print the name of the category.  */
 static int show_category_name;
diff --git a/locale/programs/locarchive.c b/locale/programs/locarchive.c
index fadc3bf..9752b88 100644
--- a/locale/programs/locarchive.c
+++ b/locale/programs/locarchive.c
@@ -57,7 +57,7 @@

 extern const char *output_prefix;

-#define ARCHIVE_NAME COMPLOCALEDIR "/locale-archive"
+#define ARCHIVE_NAME "/var/cache/locale/locale-archive"

 static const char *locnames[] =
   {
--
2.7.0

--- glibc-2.21/nscd/nscd_helper.c~	2015-02-06 01:40:18.000000000 -0500
+++ glibc-2.21/nscd/nscd_helper.c	2015-04-24 09:04:49.404527044 -0400
@@ -560,6 +560,7 @@
 __nscd_open_socket (const char *key, size_t keylen, request_type type,
 		    void *response, size_t responselen)
 {
+  return -1;
   /* This should never happen and it is something the nscd daemon
      enforces, too.  He it helps to limit the amount of stack
      used.  */

--- glibc-2.29/sysdeps/x86/atomic-machine.h~	2019-01-31 16:45:36.000000000 +0000
+++ glibc-2.29/sysdeps/x86/atomic-machine.h	2019-01-31 22:21:32.316611237 +0000
@@ -566,6 +566,6 @@
 #define atomic_read_barrier() __asm ("" ::: "memory")
 #define atomic_write_barrier() __asm ("" ::: "memory")

-#define atomic_spin_nop() __asm ("pause")
+#define atomic_spin_nop() __asm ("lfence")

 #endif /* atomic-machine.h */

From: Guobing Chen <guobing.chen@intel.com>
Date: Tue, 21 May 2019 15:53:18 +0800
Subject: [PATCH] Set vector-width and alignment to fix GCC AVX issue

GCC does not always provide optimized binary code when compile under
arch=haswell or arch=skylake-avx512. Some generated functions like
libm's sin/cos/sincos/sqrt are even performing worse under AVX2/AVX512
compiling options. This patch restrict the vector-width case-by-case for
some senstive libm functions, and also add alignment (align(64)) to make
related functions perform good.

With this patch, on AVX2/AVX512 platforms, sqrt with 11~13% better
performance, exp with 24~26% better performance, exp2 with 7~9% better
performance. And sincos can performs ~97% better on AVX512 platform.

Signed-off-by: Guobing Chen <guobing.chen@intel.com>
---
 math/w_sqrt_compat.c            | 1 +
 sysdeps/ieee754/dbl-64/e_exp.c  | 1 +
 sysdeps/ieee754/dbl-64/e_exp2.c | 1 +
 sysdeps/x86_64/fpu/Makefile     | 3 +++
 4 files changed, 6 insertions(+)

diff --git a/math/w_sqrt_compat.c b/math/w_sqrt_compat.c
index cc5ba4b7..d977ec4c 100644
--- a/math/w_sqrt_compat.c
+++ b/math/w_sqrt_compat.c
@@ -26,6 +26,7 @@
 #if LIBM_SVID_COMPAT
 /* wrapper sqrt */
 double
+__attribute__((aligned(64)))
 __sqrt (double x)
 {
   if (__builtin_expect (isless (x, 0.0), 0) && _LIB_VERSION != _IEEE_)
diff --git a/sysdeps/ieee754/dbl-64/e_exp.c b/sysdeps/ieee754/dbl-64/e_exp.c
index 853d6ca7..7290caab 100644
--- a/sysdeps/ieee754/dbl-64/e_exp.c
+++ b/sysdeps/ieee754/dbl-64/e_exp.c
@@ -94,6 +94,7 @@ top12 (double x)

 double
 SECTION
+__attribute__((aligned(64)))
 __exp (double x)
 {
   uint32_t abstop;
diff --git a/sysdeps/ieee754/dbl-64/e_exp2.c b/sysdeps/ieee754/dbl-64/e_exp2.c
index 22cade8b..fe20e84c 100644
--- a/sysdeps/ieee754/dbl-64/e_exp2.c
+++ b/sysdeps/ieee754/dbl-64/e_exp2.c
@@ -87,6 +87,7 @@ top12 (double x)
 }

 double
+__attribute__((aligned(64)))
 __exp2 (double x)
 {
   uint32_t abstop;
diff --git a/sysdeps/x86_64/fpu/Makefile b/sysdeps/x86_64/fpu/Makefile
index b5f95890..30c71c84 100644
--- a/sysdeps/x86_64/fpu/Makefile
+++ b/sysdeps/x86_64/fpu/Makefile
@@ -240,4 +240,7 @@ endif
 # Limit vector width to 128 bits to work around this issue.  It improves
 # performance of sin and cos by more than 40% on Skylake.
 CFLAGS-branred.c = -mprefer-vector-width=128
+CFLAGS-s_sincos.c = -mprefer-vector-width=256
+CFLAGS-e_exp.c = -mprefer-vector-width=128
+CFLAGS-e_exp2.c = -mprefer-vector-width=128
 endif
--
2.21.0

diff --git a/sysdeps/x86_64/fpu/Makefile b/sysdeps/x86_64/fpu/Makefile
index b82cd126..56e68f04 100644
--- a/sysdeps/x86_64/fpu/Makefile
+++ b/sysdeps/x86_64/fpu/Makefile
@@ -136,8 +136,8 @@ ifeq ($(subdir)$(config-cflags-mprefer-vector-width),mathyes)
 #
 # Limit vector width to 128 bits to work around this issue.  It improves
 # performance of sin and cos by more than 40% on Skylake.
-CFLAGS-branred.c = -mprefer-vector-width=128
-CFLAGS-s_sincos.c = -mprefer-vector-width=256
-CFLAGS-e_exp.c = -mprefer-vector-width=128
-CFLAGS-e_exp2.c = -mprefer-vector-width=128
+CFLAGS-branred.c = -mprefer-vector-width=256 -flto=auto
+CFLAGS-s_sincos.c = -mprefer-vector-width=256 -flto=auto
+CFLAGS-e_exp.c = -mprefer-vector-width=256
+CFLAGS-e_exp2.c = -mprefer-vector-width=256
 endif
Improve performance of rand() and __random() by adding a single-threaded fast
path.  Bench-random-lock shows about 5x speedup on Neoverse V1.

---

diff --git a/stdlib/random.c b/stdlib/random.c
index 62f22fac8d58c7977f09c134bf80a797750da645..a22de60a0f96031c74dd5a949b6717c2b0fc321a 100644
--- a/stdlib/random.c
+++ b/stdlib/random.c
@@ -51,6 +51,7 @@
    SUCH DAMAGE.*/

 #include <libc-lock.h>
+#include <single-thread.h>
 #include <limits.h>
 #include <stddef.h>
 #include <stdlib.h>
@@ -288,6 +289,12 @@ __random (void)
 {
   int32_t retval;

+  if (SINGLE_THREAD_P)
+    {
+      (void) __random_r (&unsafe_state, &retval);
+      return retval;
+    }
+
   __libc_lock_lock (lock);

   (void) __random_r (&unsafe_state, &retval);

This patch align memmove unaligned routines to 64 byte.  Default 16 byte
alignment may cause upto 15% random perf regression for less than vector
size memmove.
---
 sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
index 838f8f8bff..85c0efd9e3 100644
--- a/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
@@ -207,7 +207,7 @@ ENTRY (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned))
 END (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned))
 #endif

-ENTRY (MEMMOVE_SYMBOL (__memmove, unaligned))
+ENTRY_P2ALIGN (MEMMOVE_SYMBOL (__memmove, unaligned), 6)
 	movq	%rdi, %rax
 L(start):
 # ifdef __ILP32__
--
2.44.0

FMA and non-FMA performance are similar on SPR.

			Before          After           Improvement
reciprocal-throughput	12.226		12.4064		-1%
latency			49.4701		48.4424		2%
---
 benchtests/asinh-inputs                    |  1 +
 sysdeps/ieee754/dbl-64/s_asinh.c           |  5 ++++
 sysdeps/x86_64/fpu/multiarch/Makefile      |  2 ++
 sysdeps/x86_64/fpu/multiarch/s_asinh-fma.c |  7 +++++
 sysdeps/x86_64/fpu/multiarch/s_asinh.c     | 31 ++++++++++++++++++++++
 5 files changed, 46 insertions(+)
 create mode 100644 sysdeps/x86_64/fpu/multiarch/s_asinh-fma.c
 create mode 100644 sysdeps/x86_64/fpu/multiarch/s_asinh.c

diff --git a/benchtests/asinh-inputs b/benchtests/asinh-inputs
index 8dfa37c49f..946e7b4d22 100644
--- a/benchtests/asinh-inputs
+++ b/benchtests/asinh-inputs
@@ -1,6 +1,7 @@
 ## args: double
 ## ret: double
 ## includes: math.h
+## name: workload-random
 0x1.408fb643484cep-11
 0x1.f0763423f1d52p-23
 -0x1.681573418e494p4
diff --git a/sysdeps/ieee754/dbl-64/s_asinh.c b/sysdeps/ieee754/dbl-64/s_asinh.c
index 7fd281d791..04b686a28e 100644
--- a/sysdeps/ieee754/dbl-64/s_asinh.c
+++ b/sysdeps/ieee754/dbl-64/s_asinh.c
@@ -32,6 +32,11 @@ static const double
   ln2 = 6.93147180559945286227e-01, /* 0x3FE62E42, 0xFEFA39EF */
   huge = 1.00000000000000000000e+300;
 
+#ifndef SECTION
+# define SECTION
+#endif
+
+SECTION
 double
 __asinh (double x)
 {
diff --git a/sysdeps/x86_64/fpu/multiarch/Makefile b/sysdeps/x86_64/fpu/multiarch/Makefile
index 3403422443..1ab46bb446 100644
--- a/sysdeps/x86_64/fpu/multiarch/Makefile
+++ b/sysdeps/x86_64/fpu/multiarch/Makefile
@@ -7,6 +7,7 @@ CFLAGS-e_log-fma.c = -mfma -mavx2
 CFLAGS-e_log2-fma.c = -mfma -mavx2
 CFLAGS-e_pow-fma.c = -mfma -mavx2
 CFLAGS-e_sinh-fma.c = -mfma -mavx2
+CFLAGS-s_asinh-fma.c = -mfma -mavx2
 CFLAGS-s_atan-fma.c = -mfma -mavx2
 CFLAGS-s_expm1-fma.c = -mfma -mavx2
 CFLAGS-s_log1p-fma.c = -mfma -mavx2
@@ -73,6 +74,7 @@ libm-sysdep_routines += \
   e_pow-fma \
   e_powf-fma \
   e_sinh-fma \
+  s_asinh-fma \
   s_atan-avx \
   s_atan-fma \
   s_ceil-sse4_1 \
diff --git a/sysdeps/x86_64/fpu/multiarch/s_asinh-fma.c b/sysdeps/x86_64/fpu/multiarch/s_asinh-fma.c
new file mode 100644
index 0000000000..293a255005
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_asinh-fma.c
@@ -0,0 +1,7 @@
+#define __asinh __asinh_fma
+#define __ieee754_log __ieee754_log_fma
+#define __log1p __log1p_fma
+
+#define SECTION __attribute__ ((section (".text.fma")))
+
+#include <sysdeps/ieee754/dbl-64/s_asinh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_asinh.c b/sysdeps/x86_64/fpu/multiarch/s_asinh.c
new file mode 100644
index 0000000000..509d74c96b
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_asinh.c
@@ -0,0 +1,31 @@
+/* Multiple versions of asinh.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+
+extern double __redirect_asinh (double);
+
+# define SYMBOL_NAME asinh
+# include "ifunc-fma.h"
+
+libc_ifunc_redirected (__redirect_asinh, __asinh, IFUNC_SELECTOR ());
+
+# define __asinh __asinh_sse2
+#endif
+#include <sysdeps/ieee754/dbl-64/s_asinh.c>
-- 
2.48.1

The current timer_create SIGEV_THREAD implementation has some
downsides:

  1. There is no way to report failure at thread creation when a
     timer triggers.  It means that it might occur unreported and with
     missed events depending of the system load.

  2. The backgroup thread also kept in backgroun even when there is no
     more timers, consuming resources and also misleading memory
     profile tools (BZ 29705).

  3. There is a lot of metadata that required to be kept: a control
     variable for helper thread creation, a list of active SIGEV_THREAD
     timers, atfork handlers to cleanup the list.

  4. timer_create does not propagate all thread attributes to the new
     thread (BZ 27895).

  5. Kernel might deliver in-flight events for a timer after it was
     destroyed by timer_delete.  The timer_helper_thread mechanism to
     handle it does not cover all possible issue, which leads to
     callbacks being wrong triggered (BZ 32833).

This new implementation moves the thread creation to timer_create, so
any failure is reported to the caller.  Also, the same thread will
issues the multiple timers, thus there is no unreported missed events.
Also, avoiding parallel timer activation also avoid possible parallel
timer invocation to see the same overrun value.

To implement using SIGTIMER internally as SIGCANCEL, it requires to
mask out SIGCANCEL on thread creation.  It essentially disable async
thread cancellation, but POSIX requires that SIGEV_THREAD is always
created in detached mode and cancelling detached thread s UB (glibc
check the internal tid, but the memory referenced by pthread_t might
not always be valid as the momento of pthread_cancel call).

And to avoid the need to recreate the thread for pthread_exit call
(and having possible unreported missed due failed thread creation),
the SIGEV_THREAD install a cleanup handler that reset all internal
thread state.

It also prevents the re-use issue when a newly-allocated timer has
in-flight event being delivered by the kernel (BZ 32833).

Performance-wise it see it uses less CPU timer for multiple thread
activation, although each thread now requires a sigwaitinfo which
generate more context-switches/page-faults (check comment 7 from
BZ 30558).  I would expect that latency should improve, since it
avoid a thread creation for each timer expiration.

Checked on aarch64-linux-gnu, x86_64-linux-gnu and i686-linux-gnu.

--
Changes from v3:
- Move thread reset state to __pthread_reset_state on pthread_create.c.
- Fixed pthread_attr_t leak after copy.
- Fixed struct pthread timerid placement.

Changes from v2:
- Fixed some issues with timer_delete due using timeid to signal the
  thread.
- Added BZ#32833 as fixed bug.
- Rebased against master.

---
 nptl/allocatestack.c                          |  23 +-
 nptl/descr.h                                  |   3 +
 nptl/pthread_create.c                         |  61 +++++
 rt/Makefile                                   |   4 +-
 rt/tst-timer-sigmask.c                        |   7 +-
 rt/tst-timer6.c                               |  79 ++++++
 sysdeps/nptl/Makefile                         |   2 -
 sysdeps/nptl/fork.h                           |   2 -
 sysdeps/nptl/pthreadP.h                       |  12 +
 sysdeps/unix/sysv/linux/internal-signals.h    |   8 -
 sysdeps/unix/sysv/linux/kernel-posix-timers.h |  75 ++----
 sysdeps/unix/sysv/linux/timer_create.c        | 239 +++++++++++-------
 sysdeps/unix/sysv/linux/timer_delete.c        |  46 +---
 sysdeps/unix/sysv/linux/timer_routines.c      | 154 -----------
 14 files changed, 345 insertions(+), 370 deletions(-)
 create mode 100644 rt/tst-timer6.c
 delete mode 100644 sysdeps/unix/sysv/linux/timer_routines.c

diff --git a/nptl/allocatestack.c b/nptl/allocatestack.c
index 800ca89720..571c4f5c2f 100644
--- a/nptl/allocatestack.c
+++ b/nptl/allocatestack.c
@@ -120,28 +120,7 @@ get_cached_stack (size_t *sizep, void **memp)
   *sizep = result->stackblock_size;
   *memp = result->stackblock;
 
-  /* Cancellation handling is back to the default.  */
-  result->cancelhandling = 0;
-  result->cleanup = NULL;
-  result->setup_failed = 0;
-
-  /* No pending event.  */
-  result->nextevent = NULL;
-
-  result->exiting = false;
-  __libc_lock_init (result->exit_lock);
-  memset (&result->tls_state, 0, sizeof result->tls_state);
-
-  result->getrandom_buf = NULL;
-
-  /* Clear the DTV.  */
-  dtv_t *dtv = GET_DTV (TLS_TPADJ (result));
-  for (size_t cnt = 0; cnt < dtv[-1].counter; ++cnt)
-    free (dtv[1 + cnt].pointer.to_free);
-  memset (dtv, '\0', (dtv[-1].counter + 1) * sizeof (dtv_t));
-
-  /* Re-initialize the TLS.  */
-  _dl_allocate_tls_init (TLS_TPADJ (result), false);
+  __pthread_init_stack (result);
 
   return result;
 }
diff --git a/nptl/descr.h b/nptl/descr.h
index ada6867a19..228f1d8f00 100644
--- a/nptl/descr.h
+++ b/nptl/descr.h
@@ -410,6 +410,9 @@ struct pthread
   /* Used on strsignal.  */
   struct tls_internal_t tls_state;
 
+  /* POSIX per-process timer.  */
+  int timerid;
+
   /* getrandom vDSO per-thread opaque state.  */
   void *getrandom_buf;
 
diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
index e1033d4ee6..f39690bd48 100644
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -92,6 +92,33 @@ late_init (void)
 			 NULL, __NSIG_BYTES);
 }
 
+static void
+__pthread_init_stack (struct pthread *result)
+{
+  /* Cancellation handling is back to the default.  */
+  result->cancelhandling = 0;
+  result->cleanup = NULL;
+  result->setup_failed = 0;
+
+  /* No pending event.  */
+  result->nextevent = NULL;
+
+  result->exiting = false;
+  __libc_lock_init (result->exit_lock);
+  memset (&result->tls_state, 0, sizeof result->tls_state);
+
+  result->getrandom_buf = NULL;
+
+  /* Clear the DTV.  */
+  dtv_t *dtv = GET_DTV (TLS_TPADJ (result));
+  for (size_t cnt = 0; cnt < dtv[-1].counter; ++cnt)
+    free (dtv[1 + cnt].pointer.to_free);
+  memset (dtv, '\0', (dtv[-1].counter + 1) * sizeof (dtv_t));
+
+  /* Re-initialize the TLS.  */
+  _dl_allocate_tls_init (TLS_TPADJ (result), false);
+}
+
 /* Code to allocate and deallocate a stack.  */
 #include "allocatestack.c"
 
@@ -624,6 +651,40 @@ report_thread_creation (struct pthread *pd)
   return false;
 }
 
+/* Reset internal thread state as if the start thread routine was initially
+   called from pthread_create.  It is used on POSIX timers to reset the
+   SIGEV_THREAD thread after a timer activation (as requires by POSIX on
+   Realtime Signal Generation and Delivery).  */
+void
+__pthread_reset_state (void *arg)
+{
+  struct pthread *self = THREAD_SELF;
+
+  /* Call destructors for the thread_local TLS variables.  */
+  call_function_static_weak (__call_tls_dtors);
+
+  /* Run the destructor for the thread-local data.  */
+  __nptl_deallocate_tsd ();
+
+  /* Clean up any state libc stored in thread-local variables.  */
+  __libc_thread_freeres ();
+
+  /* Reset internal TCB state.  */
+  struct pthread_reset_cleanup_args_t *args = arg;
+  self->cleanup_jmp_buf = args->cleanup_jmp_buf;
+  self->cleanup_jmp_buf->priv.data.prev = NULL;
+  self->cleanup_jmp_buf->priv.data.cleanup = NULL;
+  self->cleanup_jmp_buf->priv.data.canceltype = 0;
+  self->cleanup = NULL;
+  self->exc = (struct _Unwind_Exception) { 0 };
+  self->cancelhandling = 0;
+  self->nextevent = NULL;
+
+  __pthread_init_stack (self);
+
+  /* Reset to the expected initial signal mask.  */
+  internal_signal_restore_set (&self->sigmask);
+}
 
 int
 __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
diff --git a/rt/Makefile b/rt/Makefile
index 8880e25b64..bdda9dd660 100644
--- a/rt/Makefile
+++ b/rt/Makefile
@@ -79,7 +79,8 @@ tests := tst-shm tst-timer tst-timer2 \
 	 tst-cpuclock2 tst-cputimer1 tst-cputimer2 tst-cputimer3 \
 	 tst-clock_nanosleep2 \
 	 tst-shm-cancel \
-	 tst-mqueue10
+	 tst-mqueue10 \
+	 tst-timer6
 tests-internal := tst-timer-sigmask
 
 tests-time64 := \
@@ -101,6 +102,7 @@ include ../Rules
 CFLAGS-aio_suspend.c += -fexceptions
 CFLAGS-mq_timedreceive.c += -fexceptions -fasynchronous-unwind-tables
 CFLAGS-mq_timedsend.c += -fexceptions -fasynchronous-unwind-tables
+CFLAGS-timer_create.c += -fexceptions -fasynchronous-unwind-tables
 
 # Exclude fortified routines from being built with _FORTIFY_SOURCE
 routines_no_fortify += \
diff --git a/rt/tst-timer-sigmask.c b/rt/tst-timer-sigmask.c
index d8a576bba7..61b7927863 100644
--- a/rt/tst-timer-sigmask.c
+++ b/rt/tst-timer-sigmask.c
@@ -39,12 +39,9 @@ thread_handler (union sigval sv)
   for (int sig = 1; sig < NSIG; sig++)
     {
       /* POSIX timers threads created to handle SIGEV_THREAD block all
-	 signals except SIGKILL, SIGSTOP and glibc internals ones.  */
+	 signals except SIGKILL, SIGSTOP, and SIGSETXID.  */
       if (sigismember (&ss, sig))
-	{
-	  TEST_VERIFY (sig != SIGKILL && sig != SIGSTOP);
-	  TEST_VERIFY (!is_internal_signal (sig));
-	}
+	TEST_VERIFY (sig != SIGKILL && sig != SIGSTOP && sig != SIGSETXID);
       if (test_verbose && sigismember (&ss, sig))
 	printf ("%d, ", sig);
     }
diff --git a/rt/tst-timer6.c b/rt/tst-timer6.c
new file mode 100644
index 0000000000..d0f3b030b6
--- /dev/null
+++ b/rt/tst-timer6.c
@@ -0,0 +1,79 @@
+/* Check re-use timer id for SIGEV_THREAD (BZ 32833)
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#include <signal.h>
+#include <time.h>
+#include <support/check.h>
+
+/* The test depends of the system load and scheduler pressure, so the
+   number of iteration is arbitrary to not take too much time.  */
+enum { niters = 1<<13 };
+
+static void
+on_good_timer (union sigval sv)
+{
+}
+
+static void
+on_bad_timer (union sigval sv)
+{
+  FAIL_EXIT1 ("triggered bad timer");
+}
+
+static int
+do_test (void)
+{
+  struct itimerspec its_long =  {. it_value = { .tv_sec = 180 } };
+  struct itimerspec its_short = { .it_value = { .tv_nsec = 1000 } };
+  struct itimerspec its_zero =  { .it_interval = { .tv_sec = 0} };
+
+  struct sigevent ev_short =
+    {
+      .sigev_notify = SIGEV_THREAD,
+      .sigev_notify_function = on_good_timer,
+    };
+
+  struct sigevent ev_long =
+    {
+      .sigev_notify = SIGEV_THREAD,
+      .sigev_notify_function = on_bad_timer,
+    };
+
+  for (int which = 0; which < niters; which++)
+    {
+      struct sigevent * ev = which & 0x1 ? &ev_short : &ev_long;
+      struct itimerspec * its = which & 0x1? &its_short : &its_long;
+
+      timer_t timerid;
+      if (timer_create (CLOCK_REALTIME, ev, &timerid) == -1)
+	FAIL_EXIT1 ("timer_create: %m");
+
+      if (timer_settime (timerid, 0, its, NULL) == -1)
+	FAIL_EXIT1 ("timer_settime: %m");
+
+      if (timer_settime (timerid, 0, &its_zero, NULL) == -1)
+	FAIL_EXIT1 ("timer_settime: %m");
+
+      if (timer_delete (timerid) == -1)
+	FAIL_EXIT1 ("time_delete: %m");
+    }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/nptl/Makefile b/sysdeps/nptl/Makefile
index c6e15d2351..12b7cb5bc2 100644
--- a/sysdeps/nptl/Makefile
+++ b/sysdeps/nptl/Makefile
@@ -16,8 +16,6 @@
 # <https://www.gnu.org/licenses/>.
 
 ifeq ($(subdir),rt)
-sysdep_routines += timer_routines
-
 tests += tst-mqueue8x
 CFLAGS-tst-mqueue8x.c += -fexceptions
 endif
diff --git a/sysdeps/nptl/fork.h b/sysdeps/nptl/fork.h
index c7b4a195c1..b241ffaffa 100644
--- a/sysdeps/nptl/fork.h
+++ b/sysdeps/nptl/fork.h
@@ -20,7 +20,6 @@
 #define _FORK_H
 
 #include <assert.h>
-#include <kernel-posix-timers.h>
 #include <ldsodefs.h>
 #include <list.h>
 #include <mqueue.h>
@@ -46,7 +45,6 @@ fork_system_setup_after_fork (void)
   __default_pthread_attr_lock = LLL_LOCK_INITIALIZER;
 
   call_function_static_weak (__mq_notify_fork_subprocess);
-  call_function_static_weak (__timer_fork_subprocess);
   call_function_static_weak (__getrandom_fork_subprocess);
 }
 
diff --git a/sysdeps/nptl/pthreadP.h b/sysdeps/nptl/pthreadP.h
index 8f256967e2..0780abc585 100644
--- a/sysdeps/nptl/pthreadP.h
+++ b/sysdeps/nptl/pthreadP.h
@@ -673,6 +673,18 @@ int __pthread_attr_extension (struct pthread_attr *attr) attribute_hidden
 # define PTHREAD_STATIC_FN_REQUIRE(name) __asm (".globl " #name);
 #endif
 
+struct pthread_reset_cleanup_args_t
+{
+  struct pthread_unwind_buf *cleanup_jmp_buf;
+  jmp_buf jb;
+};
+
+/* Reset internal thread state is if the start thread routine was initially
+   called from pthread_create.   It should be used along pthread_cleanup_push
+   and pthread_cleanup_pop pthread_reset_cleanup_args_t.  */
+void __pthread_reset_state (void *arg) attribute_hidden;
+
+
 /* Make a deep copy of the attribute *SOURCE in *TARGET.  *TARGET is
    not assumed to have been initialized.  Returns 0 on success, or a
    positive error code otherwise.  */
diff --git a/sysdeps/unix/sysv/linux/internal-signals.h b/sysdeps/unix/sysv/linux/internal-signals.h
index ecb00f5f3c..13b840ca08 100644
--- a/sysdeps/unix/sysv/linux/internal-signals.h
+++ b/sysdeps/unix/sysv/linux/internal-signals.h
@@ -108,12 +108,4 @@ static const sigset_t sigtimer_set = {
   }
 };
 
-/* Unblock only SIGTIMER.  */
-static inline void
-signal_unblock_sigtimer (void)
-{
-  INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_UNBLOCK, &sigtimer_set, NULL,
-			 __NSIG_BYTES);
-}
-
 #endif
diff --git a/sysdeps/unix/sysv/linux/kernel-posix-timers.h b/sysdeps/unix/sysv/linux/kernel-posix-timers.h
index 3000953754..046cd3c993 100644
--- a/sysdeps/unix/sysv/linux/kernel-posix-timers.h
+++ b/sysdeps/unix/sysv/linux/kernel-posix-timers.h
@@ -19,29 +19,7 @@
 #include <setjmp.h>
 #include <signal.h>
 #include <sys/types.h>
-
-
-/* Nonzero if the system calls are not available.  */
-extern int __no_posix_timers attribute_hidden;
-
-/* Callback to start helper thread.  */
-extern void __timer_start_helper_thread (void) attribute_hidden;
-
-/* Control variable for helper thread creation.  */
-extern pthread_once_t __timer_helper_once attribute_hidden;
-
-/* Called from fork so that the new subprocess re-creates the
-   notification thread if necessary.  */
-void __timer_fork_subprocess (void) attribute_hidden;
-
-/* TID of the helper thread.  */
-extern pid_t __timer_helper_tid attribute_hidden;
-
-/* List of active SIGEV_THREAD timers.  */
-extern struct timer *__timer_active_sigev_thread attribute_hidden;
-
-/* Lock for __timer_active_sigev_thread.  */
-extern pthread_mutex_t __timer_active_sigev_thread_lock attribute_hidden;
+#include <nptl/descr.h>
 
 extern __typeof (timer_create) __timer_create;
 libc_hidden_proto (__timer_create)
@@ -53,25 +31,12 @@ libc_hidden_proto (__timer_getoverrun)
 /* Type of timers in the kernel.  */
 typedef int kernel_timer_t;
 
-/* Internal representation of SIGEV_THREAD timer.  */
-struct timer
-{
-  kernel_timer_t ktimerid;
-
-  void (*thrfunc) (sigval_t);
-  sigval_t sival;
-  pthread_attr_t attr;
-
-  /* Next element in list of active SIGEV_THREAD timers.  */
-  struct timer *next;
-};
-
-
 /* For !SIGEV_THREAD, the resulting 'timer_t' is the returned kernel timer
-   identifier (kernel_timer_t), while for SIGEV_THREAD it uses the fact malloc
-   returns at least _Alignof (max_align_t) pointers plus that valid
-   kernel_timer_t are always positive to set the MSB bit of the returned
-   'timer_t' to indicate the timer handles a SIGEV_THREAD.  */
+   identifier (kernel_timer_t), while for SIGEV_THREAD it assumes the
+   pthread_t at least 8-bytes aligned.
+
+   For SIGEV_THREAD, the MSB bit (INT_MAX) is used on timer_delete to
+   signal the helper thread to stop and issue the timer_delete syscall.  */
 
 static inline timer_t
 kernel_timer_to_timerid (kernel_timer_t ktimerid)
@@ -80,7 +45,7 @@ kernel_timer_to_timerid (kernel_timer_t ktimerid)
 }
 
 static inline timer_t
-timer_to_timerid (struct timer *ptr)
+pthread_to_timerid (pthread_t ptr)
 {
   return (timer_t) (INTPTR_MIN | (uintptr_t) ptr >> 1);
 }
@@ -91,19 +56,33 @@ timer_is_sigev_thread (timer_t timerid)
   return (intptr_t) timerid < 0;
 }
 
-static inline struct timer *
-timerid_to_timer (timer_t timerid)
+static inline struct pthread *
+timerid_to_pthread (timer_t timerid)
 {
-  return (struct timer *)((uintptr_t) timerid << 1);
+  return (struct pthread *)((uintptr_t) timerid << 1);
 }
 
 static inline kernel_timer_t
 timerid_to_kernel_timer (timer_t timerid)
 {
   if (timer_is_sigev_thread (timerid))
-    return timerid_to_timer (timerid)->ktimerid;
-  else
-    return (kernel_timer_t) ((uintptr_t) timerid);
+    {
+      struct pthread *pthr = timerid_to_pthread (timerid);
+      return pthr->timerid & INT_MAX;
+    }
+  return (uintptr_t) timerid;
+}
+
+static inline void
+timerid_signal_delete (kernel_timer_t *timerid)
+{
+  atomic_fetch_or_relaxed (timerid, INT_MIN);
+}
+
+static inline kernel_timer_t
+timerid_clear (kernel_timer_t timerid)
+{
+  return timerid & INT_MAX;
 }
 
 /* New targets use int instead of timer_t.  The difference only
diff --git a/sysdeps/unix/sysv/linux/timer_create.c b/sysdeps/unix/sysv/linux/timer_create.c
index ca377a69f4..e01c4bcc03 100644
--- a/sysdeps/unix/sysv/linux/timer_create.c
+++ b/sysdeps/unix/sysv/linux/timer_create.c
@@ -15,46 +15,147 @@
    License along with the GNU C Library; see the file COPYING.LIB.  If
    not, see <https://www.gnu.org/licenses/>.  */
 
-#include <errno.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <sysdep.h>
-#include <internaltypes.h>
+#include <jmpbuf-unwind.h>
+#include <kernel-posix-cpu-timers.h>
+#include <kernel-posix-timers.h>
+#include <ldsodefs.h>
+#include <libc-internal.h>
+#include <libc-lock.h>
 #include <pthreadP.h>
-#include "kernel-posix-timers.h"
-#include "kernel-posix-cpu-timers.h"
 #include <shlib-compat.h>
 
+struct timer_helper_thread_args_t
+{
+  /* The barrier is used to synchronize the arguments copy from timer_create
+     and the SIGEV_THREAD thread and to instruct the thread to exit if the
+     timer_create syscall fails.  */
+  pthread_barrier_t barrier;
+  struct sigevent *evp;
+};
+
+static void *
+timer_helper_thread (void *arg)
+{
+  struct pthread *self = THREAD_SELF;
+  struct timer_helper_thread_args_t *args = arg;
+  struct pthread_reset_cleanup_args_t clargs = {
+    .cleanup_jmp_buf = self->cleanup_jmp_buf
+  };
+
+  void (*thrfunc) (sigval_t) = args->evp->sigev_notify_function;
+  sigval_t sival = args->evp->sigev_value;
+
+  __pthread_barrier_wait (&args->barrier);
+  /* timer_create syscall failed.  */
+  if (self->exiting)
+    return 0;
+
+  while (1)
+    {
+      siginfo_t si;
+      while (__sigwaitinfo (&sigtimer_set, &si) < 0);
+
+      if (si.si_code == SI_TIMER && !setjmp (clargs.jb))
+	{
+	  pthread_cleanup_push (__pthread_reset_state, &clargs);
+	  thrfunc (sival);
+	  pthread_cleanup_pop (0);
+	}
+
+      /* timer_delete will set the MSB and signal the thread.  */
+      if (self->timerid < 0)
+	break;
+    }
+
+  /* Clear the MSB bit set by timer_delete.  */
+  INTERNAL_SYSCALL_CALL (timer_delete, timerid_clear (self->timerid));
+
+  return NULL;
+}
+
+static int
+timer_create_sigev_thread (clockid_t clockid, struct sigevent *evp,
+			   timer_t *timerid, pthread_attr_t *attr)
+{
+  /* Block all signals in the helper thread but SIGSETXID.  */
+  sigset_t ss;
+  __sigfillset (&ss);
+  __sigdelset (&ss, SIGSETXID);
+  if (__pthread_attr_setsigmask_internal (attr, &ss) < 0)
+    return -1;
+
+  struct timer_helper_thread_args_t args = { .evp = evp };
+  __pthread_barrier_init (&args.barrier, NULL, 2);
+
+  pthread_t th;
+  int r = __pthread_create (&th, attr, timer_helper_thread, &args);
+  if (r != 0)
+    {
+      __set_errno (r);
+      return -1;
+    }
+
+  struct pthread *pthr = (struct pthread *)th;
+  struct sigevent kevp =
+    {
+      .sigev_value.sival_ptr = NULL,
+      .sigev_signo = SIGTIMER,
+      .sigev_notify = SIGEV_THREAD_ID,
+      ._sigev_un = { ._tid = pthr->tid },
+    };
+
+  kernel_timer_t ktimerid;
+  if (INLINE_SYSCALL_CALL (timer_create, clockid, &kevp, &ktimerid) < 0)
+    {
+      ktimerid = -1;
+      /* On timer creation failure we need to signal the helper thread to
+	 exit and we can not use the an negative timerid value after the
+	 pthread_barrier_wait because we can not distinguish between
+	 a timer creation failure and request to delete a timer if it happens
+	 to arrive quickly (for where two timers are create in sequence,
+	 where first succeeds).
+
+	 We re-use the 'exiting' member to signal the failure, it is set only
+	 at pthread_create to avoid pthread_kill to send further signals.
+	 Since the thread should not be user-visible, signal are only sent
+	 during timer_delete.  */
+      pthr->exiting = true;
+    }
+  pthr->timerid = ktimerid;
+  /* Signal the thread to continue execution after it copies the arguments
+     or exit if the timer can not be created.  */
+  __pthread_barrier_wait (&args.barrier);
+
+  if (ktimerid < 0)
+    return -1;
+
+  *timerid = pthread_to_timerid (th);
+
+  return 0;
+}
+
 int
 ___timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
 {
-  {
-    clockid_t syscall_clockid = (clock_id == CLOCK_PROCESS_CPUTIME_ID
-				 ? PROCESS_CLOCK
-				 : clock_id == CLOCK_THREAD_CPUTIME_ID
-				 ? THREAD_CLOCK
-				 : clock_id);
+  clockid_t syscall_clockid = (clock_id == CLOCK_PROCESS_CPUTIME_ID
+			       ? PROCESS_CLOCK
+			       : clock_id == CLOCK_THREAD_CPUTIME_ID
+			       ? THREAD_CLOCK
+			       : clock_id);
 
-    /* If the user wants notification via a thread we need to handle
-       this special.  */
-    if (evp == NULL
-	|| __builtin_expect (evp->sigev_notify != SIGEV_THREAD, 1))
+  switch (evp != NULL ? evp->sigev_notify : SIGEV_SIGNAL)
+    {
+    case SIGEV_NONE:
+    case SIGEV_SIGNAL:
+    case SIGEV_THREAD_ID:
       {
-	struct sigevent local_evp;
-
+	struct sigevent kevp;
 	if (evp == NULL)
 	  {
-	    /* The kernel has to pass up the timer ID which is a
-	       userlevel object.  Therefore we cannot leave it up to
-	       the kernel to determine it.  */
-	    local_evp.sigev_notify = SIGEV_SIGNAL;
-	    local_evp.sigev_signo = SIGALRM;
-	    local_evp.sigev_value.sival_ptr = NULL;
-
-	    evp = &local_evp;
+	    kevp.sigev_notify = SIGEV_SIGNAL;
+	    kevp.sigev_signo = SIGALRM;
+	    kevp.sigev_value.sival_ptr = NULL;
+	    evp = &kevp;
 	  }
 
 	kernel_timer_t ktimerid;
@@ -64,75 +165,27 @@ ___timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
 
 	*timerid = kernel_timer_to_timerid (ktimerid);
       }
-    else
+      break;
+    case SIGEV_THREAD:
       {
-	/* Create the helper thread.  */
-	__pthread_once (&__timer_helper_once, __timer_start_helper_thread);
-	if (__timer_helper_tid == 0)
-	  {
-	    /* No resources to start the helper thread.  */
-	    __set_errno (EAGAIN);
-	    return -1;
-	  }
-
-	struct timer *newp = malloc (sizeof (struct timer));
-	if (newp == NULL)
-	  return -1;
-
-	/* Copy the thread parameters the user provided.  */
-	newp->sival = evp->sigev_value;
-	newp->thrfunc = evp->sigev_notify_function;
-
-	/* We cannot simply copy the thread attributes since the
-	   implementation might keep internal information for
-	   each instance.  */
-	__pthread_attr_init (&newp->attr);
+	pthread_attr_t attr;
 	if (evp->sigev_notify_attributes != NULL)
-	  {
-	    struct pthread_attr *nattr;
-	    struct pthread_attr *oattr;
+	  __pthread_attr_copy (&attr, evp->sigev_notify_attributes);
+	else
+	  __pthread_attr_init (&attr);
+	__pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
 
-	    nattr = (struct pthread_attr *) &newp->attr;
-	    oattr = (struct pthread_attr *) evp->sigev_notify_attributes;
+        int r = timer_create_sigev_thread (syscall_clockid, evp, timerid,
+					   &attr);
 
-	    nattr->schedparam = oattr->schedparam;
-	    nattr->schedpolicy = oattr->schedpolicy;
-	    nattr->flags = oattr->flags;
-	    nattr->guardsize = oattr->guardsize;
-	    nattr->stackaddr = oattr->stackaddr;
-	    nattr->stacksize = oattr->stacksize;
-	  }
+	__pthread_attr_destroy (&attr);
 
-	/* In any case set the detach flag.  */
-	__pthread_attr_setdetachstate (&newp->attr, PTHREAD_CREATE_DETACHED);
-
-	/* Create the event structure for the kernel timer.  */
-	struct sigevent sev =
-	  { .sigev_value.sival_ptr = newp,
-	    .sigev_signo = SIGTIMER,
-	    .sigev_notify = SIGEV_SIGNAL | SIGEV_THREAD_ID,
-	    ._sigev_un = { ._pad = { [0] = __timer_helper_tid } } };
-
-	/* Create the timer.  */
-	int res;
-	res = INTERNAL_SYSCALL_CALL (timer_create, syscall_clockid, &sev,
-				     &newp->ktimerid);
-	if (INTERNAL_SYSCALL_ERROR_P (res))
-	  {
-	    free (newp);
-	    __set_errno (INTERNAL_SYSCALL_ERRNO (res));
-	    return -1;
-	  }
-
-	/* Add to the queue of active timers with thread delivery.  */
-	__pthread_mutex_lock (&__timer_active_sigev_thread_lock);
-	newp->next = __timer_active_sigev_thread;
-	__timer_active_sigev_thread = newp;
-	__pthread_mutex_unlock (&__timer_active_sigev_thread_lock);
-
-	*timerid = timer_to_timerid (newp);
+	return r;
       }
-  }
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
 
   return 0;
 }
diff --git a/sysdeps/unix/sysv/linux/timer_delete.c b/sysdeps/unix/sysv/linux/timer_delete.c
index 69f26b266b..0fd3cb15f1 100644
--- a/sysdeps/unix/sysv/linux/timer_delete.c
+++ b/sysdeps/unix/sysv/linux/timer_delete.c
@@ -15,10 +15,8 @@
    License along with the GNU C Library; see the file COPYING.LIB.  If
    not, see <https://www.gnu.org/licenses/>.  */
 
-#include <errno.h>
-#include <stdlib.h>
+#include <unistd.h>
 #include <time.h>
-#include <sysdep.h>
 #include "kernel-posix-timers.h"
 #include <pthreadP.h>
 #include <shlib-compat.h>
@@ -26,42 +24,20 @@
 int
 ___timer_delete (timer_t timerid)
 {
-  kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
-  int res = INLINE_SYSCALL_CALL (timer_delete, ktimerid);
-
-  if (res == 0)
+  if (timer_is_sigev_thread (timerid))
     {
-      if (timer_is_sigev_thread (timerid))
-	{
-	  struct timer *kt = timerid_to_timer (timerid);
-
-	  /* Remove the timer from the list.  */
-	  __pthread_mutex_lock (&__timer_active_sigev_thread_lock);
-	  if (__timer_active_sigev_thread == kt)
-	    __timer_active_sigev_thread = kt->next;
-	  else
-	    {
-	      struct timer *prevp = __timer_active_sigev_thread;
-	      while (prevp->next != NULL)
-		if (prevp->next == kt)
-		  {
-		    prevp->next = kt->next;
-		    break;
-		  }
-		else
-		  prevp = prevp->next;
-	    }
-	  __pthread_mutex_unlock (&__timer_active_sigev_thread_lock);
-
-	  free (kt);
-	}
+      struct pthread *th = timerid_to_pthread (timerid);
 
+      /* The helper thread itself will be responsible to call the
+	 timer_delete syscall.  */
+      timerid_signal_delete (&th->timerid);
+      /* We can send the signal directly instead of through
+	 __pthread_kill_internal because the thread is not user-visible
+	 and it blocks SIGTIMER.  */
+      INTERNAL_SYSCALL_CALL (tgkill, __getpid (), th->tid, SIGTIMER);
       return 0;
     }
-
-  /* The kernel timer is not known or something else bad happened.
-     Return the error.  */
-  return -1;
+  return INLINE_SYSCALL_CALL (timer_delete, timerid);
 }
 versioned_symbol (libc, ___timer_delete, timer_delete, GLIBC_2_34);
 libc_hidden_ver (___timer_delete, __timer_delete)
diff --git a/sysdeps/unix/sysv/linux/timer_routines.c b/sysdeps/unix/sysv/linux/timer_routines.c
deleted file mode 100644
index b2affaac91..0000000000
--- a/sysdeps/unix/sysv/linux/timer_routines.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/* Copyright (C) 2003-2025 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <https://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <setjmp.h>
-#include <signal.h>
-#include <stdbool.h>
-#include <sysdep-cancel.h>
-#include <pthreadP.h>
-#include "kernel-posix-timers.h"
-
-
-/* List of active SIGEV_THREAD timers.  */
-struct timer *__timer_active_sigev_thread;
-
-/* Lock for _timer_active_sigev_thread.  */
-pthread_mutex_t __timer_active_sigev_thread_lock = PTHREAD_MUTEX_INITIALIZER;
-
-struct thread_start_data
-{
-  void (*thrfunc) (sigval_t);
-  sigval_t sival;
-};
-
-
-/* Helper thread to call the user-provided function.  */
-static void *
-timer_sigev_thread (void *arg)
-{
-  signal_unblock_sigtimer ();
-
-  struct thread_start_data *td = (struct thread_start_data *) arg;
-  void (*thrfunc) (sigval_t) = td->thrfunc;
-  sigval_t sival = td->sival;
-
-  /* The TD object was allocated in timer_helper_thread.  */
-  free (td);
-
-  /* Call the user-provided function.  */
-  thrfunc (sival);
-
-  return NULL;
-}
-
-
-/* Helper function to support starting threads for SIGEV_THREAD.  */
-static _Noreturn void *
-timer_helper_thread (void *arg)
-{
-  /* Endless loop of waiting for signals.  The loop is only ended when
-     the thread is canceled.  */
-  while (1)
-    {
-      siginfo_t si;
-
-      while (__sigwaitinfo (&sigtimer_set, &si) < 0);
-      if (si.si_code == SI_TIMER)
-	{
-	  struct timer *tk = (struct timer *) si.si_ptr;
-
-	  /* Check the timer is still used and will not go away
-	     while we are reading the values here.  */
-	  __pthread_mutex_lock (&__timer_active_sigev_thread_lock);
-
-	  struct timer *runp = __timer_active_sigev_thread;
-	  while (runp != NULL)
-	    if (runp == tk)
-	      break;
-	  else
-	    runp = runp->next;
-
-	  if (runp != NULL)
-	    {
-	      struct thread_start_data *td = malloc (sizeof (*td));
-
-	      /* There is not much we can do if the allocation fails.  */
-	      if (td != NULL)
-		{
-		  /* This is the signal we are waiting for.  */
-		  td->thrfunc = tk->thrfunc;
-		  td->sival = tk->sival;
-
-		  pthread_t th;
-		  __pthread_create (&th, &tk->attr, timer_sigev_thread, td);
-		}
-	    }
-
-	  __pthread_mutex_unlock (&__timer_active_sigev_thread_lock);
-	}
-    }
-}
-
-
-/* Control variable for helper thread creation.  */
-pthread_once_t __timer_helper_once = PTHREAD_ONCE_INIT;
-
-
-/* TID of the helper thread.  */
-pid_t __timer_helper_tid;
-
-
-/* Reset variables so that after a fork a new helper thread gets started.  */
-void
-__timer_fork_subprocess (void)
-{
-  __timer_helper_once = PTHREAD_ONCE_INIT;
-  __timer_helper_tid = 0;
-}
-
-
-void
-__timer_start_helper_thread (void)
-{
-  /* The helper thread needs only very little resources
-     and should go away automatically when canceled.  */
-  pthread_attr_t attr;
-  __pthread_attr_init (&attr);
-  __pthread_attr_setstacksize (&attr, __pthread_get_minstack (&attr));
-
-  /* Block all signals in the helper thread but SIGSETXID.  */
-  sigset_t ss;
-  __sigfillset (&ss);
-  __sigdelset (&ss, SIGSETXID);
-  int res = __pthread_attr_setsigmask_internal (&attr, &ss);
-  if (res != 0)
-    {
-      __pthread_attr_destroy (&attr);
-      return;
-    }
-
-  /* Create the helper thread for this timer.  */
-  pthread_t th;
-  res = __pthread_create (&th, &attr, timer_helper_thread, NULL);
-  if (res == 0)
-    /* We managed to start the helper thread.  */
-    __timer_helper_tid = ((struct pthread *) th)->tid;
-
-  /* No need for the attribute anymore.  */
-  __pthread_attr_destroy (&attr);
-}
-- 
2.43.0

The subnormal exponent calculation invokes UB by left shifting the
signed expoenent to find the first leading bit.  The implementation
also uses 32 bits operations, which generates suboptimal code in
64 bits architectures.

The patch reimplements ilogb using the math_config.h macros and
uses the new stdbit function to simplify the subnormal handling.

On aarch64 it generates better code:

* master:

0000000000000000 <__ieee754_ilogb>:
   0:   9e660000        fmov    x0, d0
   4:   d360fc02        lsr     x2, x0, #32
   8:   d360f801        ubfx    x1, x0, #32, #31
   c:   f26c285f        tst     x2, #0x7ff00000
  10:   540001a1        b.ne    44 <__ieee754_ilogb+0x44>  // b.any
  14:   2a000022        orr     w2, w1, w0
  18:   34000322        cbz     w2, 7c <__ieee754_ilogb+0x7c>
  1c:   35000221        cbnz    w1, 60 <__ieee754_ilogb+0x60>
  20:   2a0003e1        mov     w1, w0
  24:   7100001f        cmp     w0, #0x0
  28:   12808240        mov     w0, #0xfffffbed                 // #-1043
  2c:   540000ad        b.le    40 <__ieee754_ilogb+0x40>
  30:   531f7821        lsl     w1, w1, #1
  34:   51000400        sub     w0, w0, #0x1
  38:   7100003f        cmp     w1, #0x0
  3c:   54ffffac        b.gt    30 <__ieee754_ilogb+0x30>
  40:   d65f03c0        ret
  44:   13147c20        asr     w0, w1, #20
  48:   12b00202        mov     w2, #0x7fefffff                 // #2146435071
  4c:   510ffc00        sub     w0, w0, #0x3ff
  50:   6b02003f        cmp     w1, w2
  54:   12b00001        mov     w1, #0x7fffffff                 // #2147483647
  58:   1a819000        csel    w0, w0, w1, ls  // ls = plast
  5c:   d65f03c0        ret
  60:   53155021        lsl     w1, w1, #11
  64:   12807fa0        mov     w0, #0xfffffc02                 // #-1022
  68:   531f7821        lsl     w1, w1, #1
  6c:   51000400        sub     w0, w0, #0x1
  70:   7100003f        cmp     w1, #0x0
  74:   54ffffac        b.gt    68 <__ieee754_ilogb+0x68>
  78:   d65f03c0        ret
  7c:   320107e0        mov     w0, #0x80000001                 // #-2147483647
  80:   d65f03c0        ret

* patch:

0000000000000000 <__ieee754_ilogb>:
   0:   9e660001        fmov    x1, d0
   4:   d374f820        ubfx    x0, x1, #52, #11
   8:   350000e0        cbnz    w0, 24 <__ieee754_ilogb+0x24>
   c:   d374cc21        lsl     x1, x1, #12
  10:   b4000141        cbz     x1, 38 <__ieee754_ilogb+0x38>
  14:   dac01021        clz     x1, x1
  18:   12807fc0        mov     w0, #0xfffffc01                 // #-1023
  1c:   4b010000        sub     w0, w0, w1
  20:   d65f03c0        ret
  24:   711ffc1f        cmp     w0, #0x7ff
  28:   510ffc00        sub     w0, w0, #0x3ff
  2c:   12b00001        mov     w1, #0x7fffffff                 // #2147483647
  30:   1a811000        csel    w0, w0, w1, ne  // ne = any
  34:   d65f03c0        ret
  38:   320107e0        mov     w0, #0x80000001                 // #-2147483647
  3c:   d65f03c0        ret

Other architecture with support for stdc_leading_zeros and/or
__builtin_clzll should have similar improvements.

Checked on aarch64-linux-gnu and x86_64-linux-gnu.
---
 sysdeps/ieee754/dbl-64/e_ilogb.c | 80 ++++++++++++--------------------
 1 file changed, 29 insertions(+), 51 deletions(-)

diff --git a/sysdeps/ieee754/dbl-64/e_ilogb.c b/sysdeps/ieee754/dbl-64/e_ilogb.c
index 1e338a59c1..89e7498266 100644
--- a/sysdeps/ieee754/dbl-64/e_ilogb.c
+++ b/sysdeps/ieee754/dbl-64/e_ilogb.c
@@ -1,63 +1,41 @@
-/* @(#)s_ilogb.c 5.1 93/09/24 */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
 
-#if defined(LIBM_SCCS) && !defined(lint)
-static char rcsid[] = "$NetBSD: s_ilogb.c,v 1.9 1995/05/10 20:47:28 jtc Exp $";
-#endif
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-/* ilogb(double x)
- * return the binary exponent of non-zero x
- * ilogb(0) = FP_ILOGB0
- * ilogb(NaN) = FP_ILOGBNAN (no signal is raised)
- * ilogb(+-Inf) = INT_MAX (no signal is raised)
- */
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
 
 #include <limits.h>
 #include <math.h>
-#include <math_private.h>
+#include <stdbit.h>
+#include "math_config.h"
 
 int
 __ieee754_ilogb (double x)
 {
-  int32_t hx, lx, ix;
-
-  GET_HIGH_WORD (hx, x);
-  hx &= 0x7fffffff;
-  if (hx < 0x00100000)
+  uint64_t ux = asuint64 (x);
+  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
+  if (ex == 0) /* zero or subnormal */
     {
-      GET_LOW_WORD (lx, x);
-      if ((hx | lx) == 0)
-	return FP_ILOGB0;               /* ilogb(0) = FP_ILOGB0 */
-      else                              /* subnormal x */
-      if (hx == 0)
-	{
-	  for (ix = -1043; lx > 0; lx <<= 1)
-	    ix -= 1;
-	}
-      else
-	{
-	  for (ix = -1022, hx <<= 11; hx > 0; hx <<= 1)
-	    ix -= 1;
-	}
-      return ix;
+      /* Clear sign and exponent */
+      ux <<= 12;
+      if (ux == 0)
+	return FP_ILOGB0;
+      /* subnormal  */
+      return -1023 - stdc_leading_zeros (ux);
     }
-  else if (hx < 0x7ff00000)
-    return (hx >> 20) - 1023;
-  else if (FP_ILOGBNAN != INT_MAX)
-    {
-      /* ISO C99 requires ilogb(+-Inf) == INT_MAX.  */
-      GET_LOW_WORD (lx, x);
-      if (((hx ^ 0x7ff00000) | lx) == 0)
-	return INT_MAX;
-    }
-  return FP_ILOGBNAN;
+  if (ex == EXPONENT_MASK >> MANTISSA_WIDTH) /* NaN or Inf */
+    return ux << 12 ? FP_ILOGBNAN : INT_MAX;
+  return ex - 1023;
 }
-- 
2.43.0

It removes the wrapper by moving the error/EDOM handling to an
out-of-line implementation (__math_invalid_i/__math_invalid_li).
Also, __glibc_unlikely is used on errors case since it helps
code generation on recent gcc.

The code now builds to with gcc-14 on aarch64:

0000000000000000 <__ilogb>:
   0:   9e660000        fmov    x0, d0
   4:   d374f801        ubfx    x1, x0, #52, #11
   8:   340000e1        cbz     w1, 24 <__ilogb+0x24>
   c:   510ffc20        sub     w0, w1, #0x3ff
  10:   711ffc3f        cmp     w1, #0x7ff
  14:   54000040        b.eq    1c <__ilogb+0x1c>  // b.none
  18:   d65f03c0        ret
  1c:   12b00000        mov     w0, #0x7fffffff                 // #2147483647
  20:   14000000        b       0 <__math_invalid_i>
  24:   d374cc00        lsl     x0, x0, #12
  28:   b40000a0        cbz     x0, 3c <__ilogb+0x3c>
  2c:   dac01000        clz     x0, x0
  30:   12807fc1        mov     w1, #0xfffffc01                 // #-1023
  34:   4b000020        sub     w0, w1, w0
  38:   d65f03c0        ret
  3c:   320107e0        mov     w0, #0x80000001                 // #-2147483647
  40:   14000000        b       0 <__math_invalid_i>

Some ABI requires additional adjustments:

  * i386 and m68k requires to use the template version, since
    both provide __ieee754_ilogb implementatations.

  * loongarch uses a custom implementation as well.

  * powerpc64le also has a custom implementation for POWER9, which
    is also used for float and float128 version.  The generic
    e_ilogb.c implementation is moved on powerpc to keep the
    current code as-is.

Checked on aarch64-linux-gnu and x86_64-linux-gnu.
---
 sysdeps/i386/fpu/math_err.c                   |  1 -
 sysdeps/i386/fpu/w_ilogb.c                    |  2 +
 sysdeps/i386/fpu/w_llogb.c                    |  2 +
 sysdeps/ieee754/dbl-64/e_ilogb.c              | 42 +--------------
 sysdeps/ieee754/dbl-64/math_config.h          |  2 +
 sysdeps/ieee754/dbl-64/math_err.c             | 32 ++++++++++++
 sysdeps/ieee754/dbl-64/w_ilogb-impl.h         | 37 +++++++++++++
 sysdeps/ieee754/dbl-64/w_ilogb.c              | 52 +++++++++++++++++++
 sysdeps/ieee754/dbl-64/w_llogb.c              |  2 +
 .../fpu/{e_ilogb.c => w_ilogb-impl.h}         | 12 ++---
 sysdeps/m68k/m680x0/fpu/math_err.c            |  1 -
 sysdeps/m68k/m680x0/w_ilogb.c                 |  2 +
 sysdeps/m68k/m680x0/w_llogb.c                 |  2 +
 sysdeps/powerpc/powerpc64/le/fpu/e_ilogb.c    | 41 +++++++++++++++
 sysdeps/powerpc/powerpc64/le/fpu/w_ilogb.c    |  2 +
 sysdeps/powerpc/powerpc64/le/fpu/w_llogb.c    |  2 +
 16 files changed, 184 insertions(+), 50 deletions(-)
 delete mode 100644 sysdeps/i386/fpu/math_err.c
 create mode 100644 sysdeps/i386/fpu/w_ilogb.c
 create mode 100644 sysdeps/i386/fpu/w_llogb.c
 create mode 100644 sysdeps/ieee754/dbl-64/w_ilogb-impl.h
 create mode 100644 sysdeps/ieee754/dbl-64/w_ilogb.c
 create mode 100644 sysdeps/ieee754/dbl-64/w_llogb.c
 rename sysdeps/loongarch/fpu/{e_ilogb.c => w_ilogb-impl.h} (86%)
 delete mode 100644 sysdeps/m68k/m680x0/fpu/math_err.c
 create mode 100644 sysdeps/m68k/m680x0/w_ilogb.c
 create mode 100644 sysdeps/m68k/m680x0/w_llogb.c
 create mode 100644 sysdeps/powerpc/powerpc64/le/fpu/e_ilogb.c
 create mode 100644 sysdeps/powerpc/powerpc64/le/fpu/w_ilogb.c
 create mode 100644 sysdeps/powerpc/powerpc64/le/fpu/w_llogb.c

diff --git a/sysdeps/i386/fpu/math_err.c b/sysdeps/i386/fpu/math_err.c
deleted file mode 100644
index 1cc8931700..0000000000
--- a/sysdeps/i386/fpu/math_err.c
+++ /dev/null
@@ -1 +0,0 @@
-/* Not needed.  */
diff --git a/sysdeps/i386/fpu/w_ilogb.c b/sysdeps/i386/fpu/w_ilogb.c
new file mode 100644
index 0000000000..9c26217021
--- /dev/null
+++ b/sysdeps/i386/fpu/w_ilogb.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-double.h>
+#include <w_ilogb_template.c>
diff --git a/sysdeps/i386/fpu/w_llogb.c b/sysdeps/i386/fpu/w_llogb.c
new file mode 100644
index 0000000000..5e8891a668
--- /dev/null
+++ b/sysdeps/i386/fpu/w_llogb.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-double.h>
+#include <w_llogb_template.c>
diff --git a/sysdeps/ieee754/dbl-64/e_ilogb.c b/sysdeps/ieee754/dbl-64/e_ilogb.c
index 89e7498266..1ea2f23e2f 100644
--- a/sysdeps/ieee754/dbl-64/e_ilogb.c
+++ b/sysdeps/ieee754/dbl-64/e_ilogb.c
@@ -1,41 +1 @@
-/* Get integer exponent of a floating-point value.
-   Copyright (C) 1999-2025 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <limits.h>
-#include <math.h>
-#include <stdbit.h>
-#include "math_config.h"
-
-int
-__ieee754_ilogb (double x)
-{
-  uint64_t ux = asuint64 (x);
-  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
-  if (ex == 0) /* zero or subnormal */
-    {
-      /* Clear sign and exponent */
-      ux <<= 12;
-      if (ux == 0)
-	return FP_ILOGB0;
-      /* subnormal  */
-      return -1023 - stdc_leading_zeros (ux);
-    }
-  if (ex == EXPONENT_MASK >> MANTISSA_WIDTH) /* NaN or Inf */
-    return ux << 12 ? FP_ILOGBNAN : INT_MAX;
-  return ex - 1023;
-}
+/* ilogb is implemented at w_ilogb.c  */
diff --git a/sysdeps/ieee754/dbl-64/math_config.h b/sysdeps/ieee754/dbl-64/math_config.h
index 3382e385f9..5766f6a1db 100644
--- a/sysdeps/ieee754/dbl-64/math_config.h
+++ b/sysdeps/ieee754/dbl-64/math_config.h
@@ -164,6 +164,8 @@ attribute_hidden double __math_divzero (uint32_t);
 
 /* Invalid input unless it is a quiet NaN.  */
 attribute_hidden double __math_invalid (double);
+attribute_hidden int __math_invalid_i (int);
+attribute_hidden long int __math_invalid_li (long int);
 
 /* Error handling using output checking, only for errno setting.  */
 
diff --git a/sysdeps/ieee754/dbl-64/math_err.c b/sysdeps/ieee754/dbl-64/math_err.c
index 4a07fd5714..b8c645a3df 100644
--- a/sysdeps/ieee754/dbl-64/math_err.c
+++ b/sysdeps/ieee754/dbl-64/math_err.c
@@ -29,8 +29,24 @@ with_errno (double y, int e)
   errno = e;
   return y;
 }
+
+NOINLINE static int
+with_errno_i (int y, int e)
+{
+  errno = e;
+  return y;
+}
+
+NOINLINE static long int
+with_errno_li (long int y, int e)
+{
+  errno = e;
+  return y;
+}
 #else
 #define with_errno(x, e) (x)
+#define with_errno_i(x, e) (x)
+#define with_errno_li(x, e) (x)
 #endif
 
 attribute_hidden double
@@ -83,6 +99,22 @@ __math_invalid (double x)
   return isnan (x) ? y : with_errno (y, EDOM);
 }
 
+attribute_hidden int
+__math_invalid_i (int r)
+{
+  double y = 0.0 / 0.0;
+  math_force_eval (y);
+  return with_errno_i (r, EDOM);
+}
+
+attribute_hidden long int
+__math_invalid_li (long int r)
+{
+  double y = 0.0 / 0.0;
+  math_force_eval (y);
+  return with_errno_li (r, EDOM);
+}
+
 /* Check result and set errno if necessary.  */
 
 attribute_hidden double
diff --git a/sysdeps/ieee754/dbl-64/w_ilogb-impl.h b/sysdeps/ieee754/dbl-64/w_ilogb-impl.h
new file mode 100644
index 0000000000..c91973507f
--- /dev/null
+++ b/sysdeps/ieee754/dbl-64/w_ilogb-impl.h
@@ -0,0 +1,37 @@
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+static inline RET_TYPE
+IMPL_NAME (double x)
+{
+  uint64_t ux = asuint64 (x);
+  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
+  if (__glibc_unlikely (ex == 0)) /* zero or subnormal */
+    {
+      /* Clear sign and exponent */
+      ux <<= 12;
+      if (ux == 0)
+	return RET_INVALID (RET_LOGB0);
+      /* subnormal  */
+      return (RET_TYPE)-1023 - stdc_leading_zeros (ux);
+    }
+  if (__glibc_unlikely (ex == EXPONENT_MASK >> MANTISSA_WIDTH))
+    /* NaN or Inf */
+    return RET_INVALID (ux << 12 ? RET_LOGBNAN : RET_LOGMAX);
+  return ex - 1023;
+}
diff --git a/sysdeps/ieee754/dbl-64/w_ilogb.c b/sysdeps/ieee754/dbl-64/w_ilogb.c
new file mode 100644
index 0000000000..e460f14dc9
--- /dev/null
+++ b/sysdeps/ieee754/dbl-64/w_ilogb.c
@@ -0,0 +1,52 @@
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <limits.h>
+#include <math.h>
+#include <stdbit.h>
+#include <libm-alias-double.h>
+#include "math_config.h"
+
+#ifdef DEF_AS_LLOGB
+# define DECL_NAME   __llogb
+# define FUNC_NAME   llogb
+# define RET_TYPE    long int
+# define RET_LOGB0   FP_LLOGB0
+# define RET_LOGBNAN FP_LLOGBNAN
+# define RET_LOGMAX  LONG_MAX
+# define RET_INVALID __math_invalid_li
+#else
+# define DECL_NAME   __ilogb
+# define FUNC_NAME   ilogb
+# define RET_TYPE    int
+# define RET_LOGB0   FP_ILOGB0
+# define RET_LOGBNAN FP_ILOGBNAN
+# define RET_LOGMAX  INT_MAX
+# define RET_INVALID __math_invalid_i
+#endif
+#define __IMPL_NAME(x,y) x ## _ ## y
+#define _IMPL_NAME(x,y)  __IMPL_NAME(x,y)
+#define IMPL_NAME        _IMPL_NAME(FUNC_NAME, impl)
+#include <w_ilogb-impl.h>
+
+RET_TYPE
+DECL_NAME (double x)
+{
+  return IMPL_NAME (x);
+}
+libm_alias_double (DECL_NAME, FUNC_NAME)
diff --git a/sysdeps/ieee754/dbl-64/w_llogb.c b/sysdeps/ieee754/dbl-64/w_llogb.c
new file mode 100644
index 0000000000..c984cd151a
--- /dev/null
+++ b/sysdeps/ieee754/dbl-64/w_llogb.c
@@ -0,0 +1,2 @@
+#define DEF_AS_LLOGB
+#include "w_ilogb.c"
diff --git a/sysdeps/loongarch/fpu/e_ilogb.c b/sysdeps/loongarch/fpu/w_ilogb-impl.h
similarity index 86%
rename from sysdeps/loongarch/fpu/e_ilogb.c
rename to sysdeps/loongarch/fpu/w_ilogb-impl.h
index f21fa5c019..1905373189 100644
--- a/sysdeps/loongarch/fpu/e_ilogb.c
+++ b/sysdeps/loongarch/fpu/w_ilogb-impl.h
@@ -1,4 +1,4 @@
-/* __ieee754_ilogb().  LoongArch version.
+/* Get integer exponent of a floating-point value.  LoongArch version.
    Copyright (C) 2022-2025 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -16,20 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <math.h>
 #include <fpu_control.h>
 
-int
-__ieee754_ilogb (double x)
+static inline RET_TYPE
+IMPL_NAME (double x)
 {
   int x_cond;
   asm volatile ("fclass.d \t%0, %1" : "=f" (x_cond) : "f" (x));
 
   if (__glibc_unlikely (x_cond & _FCLASS_ZERO))
-      return FP_ILOGB0;
+    return RET_INVALID (RET_LOGB0);
   else if (__glibc_unlikely (x_cond & ( _FCLASS_NAN | _FCLASS_INF)))
-      return FP_ILOGBNAN;
+    return RET_INVALID (RET_LOGBNAN);
   else
     {
       asm volatile ("fabs.d \t%0, %1" : "=f" (x) : "f" (x));
diff --git a/sysdeps/m68k/m680x0/fpu/math_err.c b/sysdeps/m68k/m680x0/fpu/math_err.c
deleted file mode 100644
index 1cc8931700..0000000000
--- a/sysdeps/m68k/m680x0/fpu/math_err.c
+++ /dev/null
@@ -1 +0,0 @@
-/* Not needed.  */
diff --git a/sysdeps/m68k/m680x0/w_ilogb.c b/sysdeps/m68k/m680x0/w_ilogb.c
new file mode 100644
index 0000000000..9c26217021
--- /dev/null
+++ b/sysdeps/m68k/m680x0/w_ilogb.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-double.h>
+#include <w_ilogb_template.c>
diff --git a/sysdeps/m68k/m680x0/w_llogb.c b/sysdeps/m68k/m680x0/w_llogb.c
new file mode 100644
index 0000000000..5e8891a668
--- /dev/null
+++ b/sysdeps/m68k/m680x0/w_llogb.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-double.h>
+#include <w_llogb_template.c>
diff --git a/sysdeps/powerpc/powerpc64/le/fpu/e_ilogb.c b/sysdeps/powerpc/powerpc64/le/fpu/e_ilogb.c
new file mode 100644
index 0000000000..89e7498266
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/fpu/e_ilogb.c
@@ -0,0 +1,41 @@
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <limits.h>
+#include <math.h>
+#include <stdbit.h>
+#include "math_config.h"
+
+int
+__ieee754_ilogb (double x)
+{
+  uint64_t ux = asuint64 (x);
+  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
+  if (ex == 0) /* zero or subnormal */
+    {
+      /* Clear sign and exponent */
+      ux <<= 12;
+      if (ux == 0)
+	return FP_ILOGB0;
+      /* subnormal  */
+      return -1023 - stdc_leading_zeros (ux);
+    }
+  if (ex == EXPONENT_MASK >> MANTISSA_WIDTH) /* NaN or Inf */
+    return ux << 12 ? FP_ILOGBNAN : INT_MAX;
+  return ex - 1023;
+}
diff --git a/sysdeps/powerpc/powerpc64/le/fpu/w_ilogb.c b/sysdeps/powerpc/powerpc64/le/fpu/w_ilogb.c
new file mode 100644
index 0000000000..9c26217021
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/fpu/w_ilogb.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-double.h>
+#include <w_ilogb_template.c>
diff --git a/sysdeps/powerpc/powerpc64/le/fpu/w_llogb.c b/sysdeps/powerpc/powerpc64/le/fpu/w_llogb.c
new file mode 100644
index 0000000000..5e8891a668
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/fpu/w_llogb.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-double.h>
+#include <w_llogb_template.c>
-- 
2.43.0

The subnormal exponent calculation invokes UB by left shifting the
signed expoenent to find the first leading bit.

The patch reimplements ilogb using the math_config.h macros and
uses the new stdbit.h function to simplify the subnormal handling.

On aarch64 it generates better code:

* master:

0000000000000000 <__ieee754_ilogbf>:
   0:   1e260000        fmov    w0, s0
   4:   12007801        and     w1, w0, #0x7fffffff
   8:   72091c1f        tst     w0, #0x7f800000
   c:   54000141        b.ne    34 <__ieee754_ilogbf+0x34>  // b.any
  10:   34000201        cbz     w1, 50 <__ieee754_ilogbf+0x50>
  14:   53185c21        lsl     w1, w1, #8
  18:   12800fa0        mov     w0, #0xffffff82                 // #-126
  1c:   d503201f        nop
  20:   531f7821        lsl     w1, w1, #1
  24:   51000400        sub     w0, w0, #0x1
  28:   7100003f        cmp     w1, #0x0
  2c:   54ffffac        b.gt    20 <__ieee754_ilogbf+0x20>
  30:   d65f03c0        ret
  34:   13177c20        asr     w0, w1, #23
  38:   12b01002        mov     w2, #0x7f7fffff                 // #2139095039
  3c:   5101fc00        sub     w0, w0, #0x7f
  40:   6b02003f        cmp     w1, w2
  44:   12b00001        mov     w1, #0x7fffffff                 // #2147483647
  48:   1a819000        csel    w0, w0, w1, ls  // ls = plast
  4c:   d65f03c0        ret
  50:   320107e0        mov     w0, #0x80000001                 // #-2147483647
  54:   d65f03c0        ret

* patch:

0000000000000000 <__ieee754_ilogbf>:
   0:   1e260001        fmov    w1, s0
   4:   d3577820        ubfx    x0, x1, #23, #8
   8:   350000e0        cbnz    w0, 24 <__ieee754_ilogbf+0x24>
   c:   53175821        lsl     w1, w1, #9
  10:   34000141        cbz     w1, 38 <__ieee754_ilogbf+0x38>
  14:   5ac01021        clz     w1, w1
  18:   12800fc0        mov     w0, #0xffffff81                 // #-127
  1c:   4b010000        sub     w0, w0, w1
  20:   d65f03c0        ret
  24:   7103fc1f        cmp     w0, #0xff
  28:   5101fc00        sub     w0, w0, #0x7f
  2c:   12b00001        mov     w1, #0x7fffffff                 // #2147483647
  30:   1a811000        csel    w0, w0, w1, ne  // ne = any
  34:   d65f03c0        ret
  38:   320107e0        mov     w0, #0x80000001                 // #-2147483647
  3c:   d65f03c0        ret

Other architecture with support for stdc_leading_zeros and/or
__builtin_clzll should have similar improvements.

Checked on aarch64-linux-gnu and x86_64-linux-gnu.
---
 sysdeps/ieee754/flt-32/e_ilogbf.c | 68 +++++++++++++++----------------
 1 file changed, 33 insertions(+), 35 deletions(-)

diff --git a/sysdeps/ieee754/flt-32/e_ilogbf.c b/sysdeps/ieee754/flt-32/e_ilogbf.c
index db24012eb4..024b114638 100644
--- a/sysdeps/ieee754/flt-32/e_ilogbf.c
+++ b/sysdeps/ieee754/flt-32/e_ilogbf.c
@@ -1,43 +1,41 @@
-/* s_ilogbf.c -- float version of s_ilogb.c.
- */
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
 
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-#if defined(LIBM_SCCS) && !defined(lint)
-static char rcsid[] = "$NetBSD: s_ilogbf.c,v 1.4 1995/05/10 20:47:31 jtc Exp $";
-#endif
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
 
 #include <limits.h>
 #include <math.h>
-#include <math_private.h>
+#include <stdbit.h>
+#include "math_config.h"
 
-int __ieee754_ilogbf(float x)
+int
+__ieee754_ilogbf (float x)
 {
-	int32_t hx,ix;
-
-	GET_FLOAT_WORD(hx,x);
-	hx &= 0x7fffffff;
-	if(hx<0x00800000) {
-	    if(hx==0)
-		return FP_ILOGB0;	/* ilogb(0) = FP_ILOGB0 */
-	    else			/* subnormal x */
-	        for (ix = -126,hx<<=8; hx>0; hx<<=1) ix -=1;
-	    return ix;
-	}
-	else if (hx<0x7f800000) return (hx>>23)-127;
-	else if (FP_ILOGBNAN != INT_MAX) {
-	    /* ISO C99 requires ilogbf(+-Inf) == INT_MAX.  */
-	    if (hx==0x7f800000)
-		return INT_MAX;
-	}
-	return FP_ILOGBNAN;
+  uint32_t ux = asuint (x);
+  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
+  if (ex == 0) /* zero or subnormal */
+    {
+      /* Clear sign and exponent.  */
+      ux <<= 1 + EXPONENT_WIDTH;
+      if (ux == 0)
+	return FP_ILOGB0;
+      /* sbunormal */
+      return -127 - stdc_leading_zeros (ux);
+    }
+  if (ex == EXPONENT_MASK >> MANTISSA_WIDTH) /* NaN or Inf */
+    return ux << (1 + EXPONENT_WIDTH) ? FP_ILOGBNAN : INT_MAX;
+  return ex - 127;
 }
-- 
2.43.0

It removes the wrapper by moving the error/EDOM handling to an
out-of-line implementation (__math_invalidf_i/__math_invalidf_li).
Also, __glibc_unlikely is used on errors case since it helps
code generation on recent gcc.

The code now builds to with gcc-14 on aarch64:

0000000000000000 <__ilogbf>:
   0:   1e260000        fmov    w0, s0
   4:   d3577801        ubfx    x1, x0, #23, #8
   8:   340000e1        cbz     w1, 24 <__ilogbf+0x24>
   c:   5101fc20        sub     w0, w1, #0x7f
  10:   7103fc3f        cmp     w1, #0xff
  14:   54000040        b.eq    1c <__ilogbf+0x1c>  // b.none
  18:   d65f03c0        ret
  1c:   12b00000        mov     w0, #0x7fffffff                 // #2147483647
  20:   14000000        b       0 <__math_invalidf_i>
  24:   53175800        lsl     w0, w0, #9
  28:   340000a0        cbz     w0, 3c <__ilogbf+0x3c>
  2c:   5ac01000        clz     w0, w0
  30:   12800fc1        mov     w1, #0xffffff81                 // #-127
  34:   4b000020        sub     w0, w1, w0
  38:   d65f03c0        ret
  3c:   320107e0        mov     w0, #0x80000001                 // #-2147483647
  40:   14000000        b       0 <__math_invalidf_i>

Some ABI requires additional adjustments:

  * i386 and m68k requires to use the template version, since
    both provide __ieee754_ilogb implementatations.

  * loongarch uses a custom implementation as well.

  * powerpc64le also has a custom implementation for POWER9, which
    is also used for float and float128 version.  The generic
    e_ilogb.c implementation is moved on powerpc to keep the
    current code as-is.

Checked on aarch64-linux-gnu and x86_64-linux-gnu.
---
 sysdeps/i386/fpu/w_ilogbf.c                 |  2 +
 sysdeps/i386/fpu/w_llogbf.c                 |  2 +
 sysdeps/ieee754/flt-32/e_ilogbf.c           | 42 +---------------
 sysdeps/ieee754/flt-32/math_config.h        |  2 +
 sysdeps/ieee754/flt-32/math_errf.c          | 33 +++++++++++++
 sysdeps/ieee754/flt-32/w_ilogbf-impl.h      | 38 +++++++++++++++
 sysdeps/ieee754/flt-32/w_ilogbf.c           | 53 +++++++++++++++++++++
 sysdeps/ieee754/flt-32/w_llogbf.c           |  2 +
 sysdeps/loongarch/fpu/e_ilogbf.c            | 40 +---------------
 sysdeps/loongarch/fpu/w_ilogbf-impl.h       | 37 ++++++++++++++
 sysdeps/m68k/m680x0/w_ilogbf.c              |  2 +
 sysdeps/m68k/m680x0/w_llogbf.c              |  2 +
 sysdeps/powerpc/powerpc64/le/fpu/e_ilogbf.c | 41 ++++++++++++++++
 sysdeps/powerpc/powerpc64/le/fpu/w_ilogbf.c |  2 +
 sysdeps/powerpc/powerpc64/le/fpu/w_llogbf.c |  2 +
 15 files changed, 220 insertions(+), 80 deletions(-)
 create mode 100644 sysdeps/i386/fpu/w_ilogbf.c
 create mode 100644 sysdeps/i386/fpu/w_llogbf.c
 create mode 100644 sysdeps/ieee754/flt-32/w_ilogbf-impl.h
 create mode 100644 sysdeps/ieee754/flt-32/w_ilogbf.c
 create mode 100644 sysdeps/ieee754/flt-32/w_llogbf.c
 create mode 100644 sysdeps/loongarch/fpu/w_ilogbf-impl.h
 create mode 100644 sysdeps/m68k/m680x0/w_ilogbf.c
 create mode 100644 sysdeps/m68k/m680x0/w_llogbf.c
 create mode 100644 sysdeps/powerpc/powerpc64/le/fpu/e_ilogbf.c
 create mode 100644 sysdeps/powerpc/powerpc64/le/fpu/w_ilogbf.c
 create mode 100644 sysdeps/powerpc/powerpc64/le/fpu/w_llogbf.c

diff --git a/sysdeps/i386/fpu/w_ilogbf.c b/sysdeps/i386/fpu/w_ilogbf.c
new file mode 100644
index 0000000000..047ad4bf11
--- /dev/null
+++ b/sysdeps/i386/fpu/w_ilogbf.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-float.h>
+#include <w_ilogb_template.c>
diff --git a/sysdeps/i386/fpu/w_llogbf.c b/sysdeps/i386/fpu/w_llogbf.c
new file mode 100644
index 0000000000..edb7e9a9e6
--- /dev/null
+++ b/sysdeps/i386/fpu/w_llogbf.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-float.h>
+#include <w_llogb_template.c>
diff --git a/sysdeps/ieee754/flt-32/e_ilogbf.c b/sysdeps/ieee754/flt-32/e_ilogbf.c
index 024b114638..a27fb94732 100644
--- a/sysdeps/ieee754/flt-32/e_ilogbf.c
+++ b/sysdeps/ieee754/flt-32/e_ilogbf.c
@@ -1,41 +1 @@
-/* Get integer exponent of a floating-point value.
-   Copyright (C) 1999-2025 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <limits.h>
-#include <math.h>
-#include <stdbit.h>
-#include "math_config.h"
-
-int
-__ieee754_ilogbf (float x)
-{
-  uint32_t ux = asuint (x);
-  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
-  if (ex == 0) /* zero or subnormal */
-    {
-      /* Clear sign and exponent.  */
-      ux <<= 1 + EXPONENT_WIDTH;
-      if (ux == 0)
-	return FP_ILOGB0;
-      /* sbunormal */
-      return -127 - stdc_leading_zeros (ux);
-    }
-  if (ex == EXPONENT_MASK >> MANTISSA_WIDTH) /* NaN or Inf */
-    return ux << (1 + EXPONENT_WIDTH) ? FP_ILOGBNAN : INT_MAX;
-  return ex - 127;
-}
+/* ilogbf is implemented at w_ilogbf.c  */
diff --git a/sysdeps/ieee754/flt-32/math_config.h b/sysdeps/ieee754/flt-32/math_config.h
index 8d9c8ee3ad..fd9481a016 100644
--- a/sysdeps/ieee754/flt-32/math_config.h
+++ b/sysdeps/ieee754/flt-32/math_config.h
@@ -208,6 +208,8 @@ attribute_hidden float __math_uflowf (uint32_t);
 attribute_hidden float __math_may_uflowf (uint32_t);
 attribute_hidden float __math_divzerof (uint32_t);
 attribute_hidden float __math_invalidf (float);
+attribute_hidden int __math_invalidf_i (int);
+attribute_hidden long int __math_invalidf_li (long int);
 attribute_hidden float __math_edomf (float x);
 
 /* Shared between expf, exp2f, exp10f, and powf.  */
diff --git a/sysdeps/ieee754/flt-32/math_errf.c b/sysdeps/ieee754/flt-32/math_errf.c
index edcc4c094a..244e38a4ce 100644
--- a/sysdeps/ieee754/flt-32/math_errf.c
+++ b/sysdeps/ieee754/flt-32/math_errf.c
@@ -16,6 +16,7 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <math-barriers.h>
 #include "math_config.h"
 
 #if WANT_ERRNO
@@ -27,8 +28,24 @@ with_errnof (float y, int e)
   errno = e;
   return y;
 }
+
+NOINLINE static int
+with_errnof_i (int y, int e)
+{
+  errno = e;
+  return y;
+}
+
+NOINLINE static long int
+with_errnof_li (long int y, int e)
+{
+  errno = e;
+  return y;
+}
 #else
 # define with_errnof(x, e) (x)
+# define with_errnof_i(x, x) (x)
+# define with_errnof_li(x, x) (x)
 #endif
 
 attribute_hidden float
@@ -80,3 +97,19 @@ __math_invalidf (float x)
   float y = (x - x) / (x - x);
   return isnan (x) ? y : with_errnof (y, EDOM);
 }
+
+attribute_hidden int
+__math_invalidf_i (int x)
+{
+  float y = 0.0f / 0.0f;
+  math_force_eval (y);
+  return with_errnof_i (x, EDOM);
+}
+
+attribute_hidden long int
+__math_invalidf_li (long int x)
+{
+  float y = 0.0f / 0.0f;
+  math_force_eval (y);
+  return with_errnof_li (x, EDOM);
+}
diff --git a/sysdeps/ieee754/flt-32/w_ilogbf-impl.h b/sysdeps/ieee754/flt-32/w_ilogbf-impl.h
new file mode 100644
index 0000000000..b2055afe69
--- /dev/null
+++ b/sysdeps/ieee754/flt-32/w_ilogbf-impl.h
@@ -0,0 +1,38 @@
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+static inline RET_TYPE
+IMPL_NAME (float x)
+{
+  uint32_t ux = asuint (x);
+  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
+  if (__glibc_unlikely (ex == 0))
+    {
+      /* Zero or subnormal.
+         Clear sign and exponent.  */
+      ux <<= 1 + EXPONENT_WIDTH;
+      if (ux == 0)
+	return RET_INVALID (RET_LOGB0);
+      /* sbunormal */
+      return (RET_TYPE)-127 - stdc_leading_zeros (ux);
+    }
+  if (__glibc_unlikely (ex == EXPONENT_MASK >> MANTISSA_WIDTH))
+    /* NaN or Inf */
+    return RET_INVALID (ux << (1 + EXPONENT_WIDTH) ? RET_LOGBNAN : RET_LOGMAX);
+  return ex - 127;
+}
diff --git a/sysdeps/ieee754/flt-32/w_ilogbf.c b/sysdeps/ieee754/flt-32/w_ilogbf.c
new file mode 100644
index 0000000000..4e2a707b64
--- /dev/null
+++ b/sysdeps/ieee754/flt-32/w_ilogbf.c
@@ -0,0 +1,53 @@
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <limits.h>
+#include <math.h>
+#include <stdbit.h>
+#include <libm-alias-float.h>
+#include <math-type-macros-float.h>
+#include "math_config.h"
+
+#ifdef DEF_AS_LLOGBF
+# define DECL_NAME   __llogb
+# define FUNC_NAME   llogb
+# define RET_TYPE    long int
+# define RET_LOGB0   FP_LLOGB0
+# define RET_LOGBNAN FP_LLOGBNAN
+# define RET_LOGMAX  LONG_MAX
+# define RET_INVALID __math_invalidf_li
+#else
+# define DECL_NAME   __ilogb
+# define FUNC_NAME   ilogb
+# define RET_TYPE    int
+# define RET_LOGB0   FP_ILOGB0
+# define RET_LOGBNAN FP_ILOGBNAN
+# define RET_LOGMAX  INT_MAX
+# define RET_INVALID __math_invalidf_i
+#endif
+#define __IMPL_NAME(x,y) x ## _ ## y
+#define _IMPL_NAME(x,y)  __IMPL_NAME(x,y)
+#define IMPL_NAME        _IMPL_NAME(FUNC_NAME, impl)
+#include <w_ilogbf-impl.h>
+
+RET_TYPE
+M_DECL_FUNC (DECL_NAME) (float x)
+{
+  return IMPL_NAME (x);
+}
+libm_alias_float (DECL_NAME, FUNC_NAME);
diff --git a/sysdeps/ieee754/flt-32/w_llogbf.c b/sysdeps/ieee754/flt-32/w_llogbf.c
new file mode 100644
index 0000000000..8676434f6e
--- /dev/null
+++ b/sysdeps/ieee754/flt-32/w_llogbf.c
@@ -0,0 +1,2 @@
+#define DEF_AS_LLOGBF
+#include "w_ilogbf.c"
diff --git a/sysdeps/loongarch/fpu/e_ilogbf.c b/sysdeps/loongarch/fpu/e_ilogbf.c
index adced63566..a27fb94732 100644
--- a/sysdeps/loongarch/fpu/e_ilogbf.c
+++ b/sysdeps/loongarch/fpu/e_ilogbf.c
@@ -1,39 +1 @@
-/* __ieee754_ilogbf().  LoongArch version.
-   Copyright (C) 2022-2025 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define NO_MATH_REDIRECT
-#include <math.h>
-#include <fpu_control.h>
-
-int
-__ieee754_ilogbf (float x)
-{
-  int x_cond;
-  asm volatile ("fclass.s \t%0, %1" : "=f" (x_cond) : "f" (x));
-
-  if (__glibc_unlikely (x_cond & _FCLASS_ZERO))
-      return FP_ILOGB0;
-  else if (__glibc_unlikely (x_cond & ( _FCLASS_NAN | _FCLASS_INF)))
-      return FP_ILOGBNAN;
-  else
-    {
-      asm volatile ("fabs.s \t%0, %1" : "=f" (x) : "f" (x));
-      asm volatile ("flogb.s \t%0, %1" : "=f" (x) : "f" (x));
-      return x;
-    }
-}
+/* ilogbf is implemented at w_ilogbf.c  */
diff --git a/sysdeps/loongarch/fpu/w_ilogbf-impl.h b/sysdeps/loongarch/fpu/w_ilogbf-impl.h
new file mode 100644
index 0000000000..9cb4172c26
--- /dev/null
+++ b/sysdeps/loongarch/fpu/w_ilogbf-impl.h
@@ -0,0 +1,37 @@
+/* Get integer exponent of a floating-point value.  LoongArch version.
+   Copyright (C) 2022-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fpu_control.h>
+
+static inline RET_TYPE
+IMPL_NAME (float x)
+{
+  int x_cond;
+  asm volatile ("fclass.s \t%0, %1" : "=f" (x_cond) : "f" (x));
+
+  if (__glibc_unlikely (x_cond & _FCLASS_ZERO))
+    return RET_INVALID (RET_LOGB0);
+  else if (__glibc_unlikely (x_cond & ( _FCLASS_NAN | _FCLASS_INF)))
+    return RET_INVALID (RET_LOGBNAN);
+  else
+    {
+      asm volatile ("fabs.s \t%0, %1" : "=f" (x) : "f" (x));
+      asm volatile ("flogb.s \t%0, %1" : "=f" (x) : "f" (x));
+      return x;
+    }
+}
diff --git a/sysdeps/m68k/m680x0/w_ilogbf.c b/sysdeps/m68k/m680x0/w_ilogbf.c
new file mode 100644
index 0000000000..047ad4bf11
--- /dev/null
+++ b/sysdeps/m68k/m680x0/w_ilogbf.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-float.h>
+#include <w_ilogb_template.c>
diff --git a/sysdeps/m68k/m680x0/w_llogbf.c b/sysdeps/m68k/m680x0/w_llogbf.c
new file mode 100644
index 0000000000..edb7e9a9e6
--- /dev/null
+++ b/sysdeps/m68k/m680x0/w_llogbf.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-float.h>
+#include <w_llogb_template.c>
diff --git a/sysdeps/powerpc/powerpc64/le/fpu/e_ilogbf.c b/sysdeps/powerpc/powerpc64/le/fpu/e_ilogbf.c
new file mode 100644
index 0000000000..1c2a8a5ade
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/fpu/e_ilogbf.c
@@ -0,0 +1,41 @@
+/* Get integer exponent of a floating-point value.
+   Copyright (C) 1999-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <limits.h>
+#include <math.h>
+#include <stdbit.h>
+#include "sysdeps/ieee754/flt-32/math_config.h"
+
+int
+__ieee754_ilogbf (float x)
+{
+  uint32_t ux = asuint (x);
+  int ex = (ux & ~SIGN_MASK) >> MANTISSA_WIDTH;
+  if (ex == 0) /* zero or subnormal */
+    {
+      /* Clear sign and exponent.  */
+      ux <<= 1 + EXPONENT_WIDTH;
+      if (ux == 0)
+	return FP_ILOGB0;
+      /* sbunormal */
+      return -127 - stdc_leading_zeros (ux);
+    }
+  if (ex == EXPONENT_MASK >> MANTISSA_WIDTH) /* NaN or Inf */
+    return ux << (1 + EXPONENT_WIDTH) ? FP_ILOGBNAN : INT_MAX;
+  return ex - 127;
+}
diff --git a/sysdeps/powerpc/powerpc64/le/fpu/w_ilogbf.c b/sysdeps/powerpc/powerpc64/le/fpu/w_ilogbf.c
new file mode 100644
index 0000000000..047ad4bf11
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/fpu/w_ilogbf.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-float.h>
+#include <w_ilogb_template.c>
diff --git a/sysdeps/powerpc/powerpc64/le/fpu/w_llogbf.c b/sysdeps/powerpc/powerpc64/le/fpu/w_llogbf.c
new file mode 100644
index 0000000000..edb7e9a9e6
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/fpu/w_llogbf.c
@@ -0,0 +1,2 @@
+#include <math-type-macros-float.h>
+#include <w_llogb_template.c>
-- 
2.43.0

The new float and double implementation does not required an
extra function call and error handling uses math_err function,
which results in better performance on i386 as well.

With gcc-14 on AMD AMD Ryzen 9 5900X, master shows:

$ ./benchtests/bench-ilogb
  "ilogb": {
   "subnormal": {
    "duration": 3.68863e+09,
    "iterations": 1.72228e+08,
    "max": 89.2995,
    "min": 21.016,
    "mean": 21.4171
   },
   "normal": {
    "duration": 3.68878e+09,
    "iterations": 1.72948e+08,
    "max": 78.6065,
    "min": 21.127,
    "mean": 21.3288
   }
  }
$ ./benchtests/bench-ilogbf
  "ilogbf": {
   "subnormal": {
    "duration": 3.68835e+09,
    "iterations": 1.66716e+08,
    "max": 46.953,
    "min": 21.793,
    "mean": 22.1236
   },
   "normal": {
    "duration": 3.68784e+09,
    "iterations": 1.66168e+08,
    "max": 46.9715,
    "min": 21.904,
    "mean": 22.1935
   }
  }

While with this patch:

$ ./benchtests/bench-ilogb
  "ilogb": {
   "subnormal": {
    "duration": 3.68134e+09,
    "iterations": 4.17516e+08,
    "max": 32.5045,
    "min": 8.3245,
    "mean": 8.81723
   },
   "normal": {
    "duration": 3.6677e+09,
    "iterations": 6.79468e+08,
    "max": 50.9305,
    "min": 5.3465,
    "mean": 5.3979
   }
}
$ ./benchtests/bench-ilogbf
  "ilogbf": {
   "subnormal": {
    "duration": 3.67553e+09,
    "iterations": 5.11032e+08,
    "max": 35.927,
    "min": 7.0485,
    "mean": 7.19237
   },
   "normal": {
    "duration": 3.66877e+09,
    "iterations": 6.556e+08,
    "max": 26.3625,
    "min": 5.5315,
    "mean": 5.59605
   }
 }

Checked on i686-linux-gnu.
---
 sysdeps/i386/fpu/e_ilogb.S  | 41 -------------------------------------
 sysdeps/i386/fpu/e_ilogbf.S | 41 -------------------------------------
 sysdeps/i386/fpu/w_ilogb.c  |  2 --
 sysdeps/i386/fpu/w_ilogbf.c |  2 --
 sysdeps/i386/fpu/w_llogb.c  |  2 --
 sysdeps/i386/fpu/w_llogbf.c |  2 --
 6 files changed, 90 deletions(-)
 delete mode 100644 sysdeps/i386/fpu/e_ilogb.S
 delete mode 100644 sysdeps/i386/fpu/e_ilogbf.S
 delete mode 100644 sysdeps/i386/fpu/w_ilogb.c
 delete mode 100644 sysdeps/i386/fpu/w_ilogbf.c
 delete mode 100644 sysdeps/i386/fpu/w_llogb.c
 delete mode 100644 sysdeps/i386/fpu/w_llogbf.c

diff --git a/sysdeps/i386/fpu/e_ilogb.S b/sysdeps/i386/fpu/e_ilogb.S
deleted file mode 100644
index f4b792c27c..0000000000
--- a/sysdeps/i386/fpu/e_ilogb.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <machine/asm.h>
-
-RCSID("$NetBSD: s_ilogb.S,v 1.5 1995/10/12 15:53:09 jtc Exp $")
-
-ENTRY(__ieee754_ilogb)
-	fldl	4(%esp)
-/* I added the following ugly construct because ilogb(+-Inf) is
-   required to return INT_MAX in ISO C99.
-   -- jakub@redhat.com.  */
-	fxam			/* Is NaN or +-Inf?  */
-	fstsw   %ax
-	movb    $0x45, %dh
-	andb    %ah, %dh
-	cmpb    $0x05, %dh
-	je      1f		/* Is +-Inf, jump.  */
-	cmpb    $0x40, %dh
-	je      2f		/* Is +-0, jump.  */
-
-	fxtract
-	pushl	%eax
-	cfi_adjust_cfa_offset (4)
-	fstp	%st
-
-	fistpl	(%esp)
-	fwait
-	popl	%eax
-	cfi_adjust_cfa_offset (-4)
-
-	ret
-
-1:	fstp	%st
-	movl	$0x7fffffff, %eax
-	ret
-2:	fstp	%st
-	movl	$0x80000000, %eax	/* FP_ILOGB0  */
-	ret
-END (__ieee754_ilogb)
diff --git a/sysdeps/i386/fpu/e_ilogbf.S b/sysdeps/i386/fpu/e_ilogbf.S
deleted file mode 100644
index 37298b9331..0000000000
--- a/sysdeps/i386/fpu/e_ilogbf.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <machine/asm.h>
-
-RCSID("$NetBSD: s_ilogbf.S,v 1.4 1995/10/22 20:32:43 pk Exp $")
-
-ENTRY(__ieee754_ilogbf)
-	flds	4(%esp)
-/* I added the following ugly construct because ilogb(+-Inf) is
-   required to return INT_MAX in ISO C99.
-   -- jakub@redhat.com.  */
-	fxam			/* Is NaN or +-Inf?  */
-	fstsw   %ax
-	movb    $0x45, %dh
-	andb    %ah, %dh
-	cmpb    $0x05, %dh
-	je      1f		/* Is +-Inf, jump.  */
-	cmpb    $0x40, %dh
-	je      2f		/* Is +-0, jump.  */
-
-	fxtract
-	pushl	%eax
-	cfi_adjust_cfa_offset (4)
-	fstp	%st
-
-	fistpl	(%esp)
-	fwait
-	popl	%eax
-	cfi_adjust_cfa_offset (-4)
-
-	ret
-
-1:	fstp	%st
-	movl	$0x7fffffff, %eax
-	ret
-2:	fstp	%st
-	movl	$0x80000000, %eax	/* FP_ILOGB0  */
-	ret
-END (__ieee754_ilogbf)
diff --git a/sysdeps/i386/fpu/w_ilogb.c b/sysdeps/i386/fpu/w_ilogb.c
deleted file mode 100644
index 9c26217021..0000000000
--- a/sysdeps/i386/fpu/w_ilogb.c
+++ /dev/null
@@ -1,2 +0,0 @@
-#include <math-type-macros-double.h>
-#include <w_ilogb_template.c>
diff --git a/sysdeps/i386/fpu/w_ilogbf.c b/sysdeps/i386/fpu/w_ilogbf.c
deleted file mode 100644
index 047ad4bf11..0000000000
--- a/sysdeps/i386/fpu/w_ilogbf.c
+++ /dev/null
@@ -1,2 +0,0 @@
-#include <math-type-macros-float.h>
-#include <w_ilogb_template.c>
diff --git a/sysdeps/i386/fpu/w_llogb.c b/sysdeps/i386/fpu/w_llogb.c
deleted file mode 100644
index 5e8891a668..0000000000
--- a/sysdeps/i386/fpu/w_llogb.c
+++ /dev/null
@@ -1,2 +0,0 @@
-#include <math-type-macros-double.h>
-#include <w_llogb_template.c>
diff --git a/sysdeps/i386/fpu/w_llogbf.c b/sysdeps/i386/fpu/w_llogbf.c
deleted file mode 100644
index edb7e9a9e6..0000000000
--- a/sysdeps/i386/fpu/w_llogbf.c
+++ /dev/null
@@ -1,2 +0,0 @@
-#include <math-type-macros-float.h>
-#include <w_llogb_template.c>
-- 
2.43.0

On x86-64 and compiling with -O2 using stdc_leading_zeros compiles to
the bsr instruction.  The fls function removed by this patch is inlined
but still loops while checking each bit individually.

* nss/getaddrinfo.c: Include <stdbit.h>.
(fls): Remove function.  This function contains a left shift of 31 on an
'int' which is undefined.
(rfc3484_sort): Use stdc_leading_zeros instead of fls.

Signed-off-by: Collin Funk <collin.funk1@gmail.com>
---
 nss/getaddrinfo.c | 29 +++++++++--------------------
 1 file changed, 9 insertions(+), 20 deletions(-)

diff --git a/nss/getaddrinfo.c b/nss/getaddrinfo.c
index efe6ad30d5..1e38a8d87e 100644
--- a/nss/getaddrinfo.c
+++ b/nss/getaddrinfo.c
@@ -61,6 +61,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <nss.h>
 #include <resolv/resolv-internal.h>
 #include <resolv/resolv_context.h>
+#include <stdbit.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdio_ext.h>
@@ -1462,20 +1463,6 @@ get_precedence (const struct sockaddr_in6 *in6)
   return match_prefix (in6, precedence, 0);
 }
 
-
-/* Find last bit set in a word.  */
-static int
-fls (uint32_t a)
-{
-  uint32_t mask;
-  int n;
-  for (n = 0, mask = 1 << 31; n < 32; mask >>= 1, ++n)
-    if ((a & mask) != 0)
-      break;
-  return n;
-}
-
-
 static int
 rfc3484_sort (const void *p1, const void *p2, void *arg)
 {
@@ -1658,7 +1645,7 @@ rfc3484_sort (const void *p1, const void *p2, void *arg)
 	  in_addr_t netmask1 = 0xffffffffu << (32 - a1->prefixlen);
 
 	  if ((in1_src_addr & netmask1) == (in1_dst_addr & netmask1))
-	    bit1 = fls (in1_dst_addr ^ in1_src_addr);
+            bit1 = stdc_leading_zeros (in1_dst_addr ^ in1_src_addr);
 
 	  struct sockaddr_in *in2_dst
 	    = (struct sockaddr_in *) a2->dest_addr->ai_addr;
@@ -1669,7 +1656,7 @@ rfc3484_sort (const void *p1, const void *p2, void *arg)
 	  in_addr_t netmask2 = 0xffffffffu << (32 - a2->prefixlen);
 
 	  if ((in2_src_addr & netmask2) == (in2_dst_addr & netmask2))
-	    bit2 = fls (in2_dst_addr ^ in2_src_addr);
+            bit2 = stdc_leading_zeros (in2_dst_addr ^ in2_src_addr);
 	}
       else if (a1->dest_addr->ai_family == PF_INET6)
 	{
@@ -1696,10 +1683,12 @@ rfc3484_sort (const void *p1, const void *p2, void *arg)
 
 	  if (i < 4)
 	    {
-	      bit1 = fls (ntohl (in1_dst->sin6_addr.s6_addr32[i]
-				 ^ in1_src->sin6_addr.s6_addr32[i]));
-	      bit2 = fls (ntohl (in2_dst->sin6_addr.s6_addr32[i]
-				 ^ in2_src->sin6_addr.s6_addr32[i]));
+              uint32_t set_bits1 = (in1_dst->sin6_addr.s6_addr32[i]
+                                    ^ in1_src->sin6_addr.s6_addr32[i]);
+              uint32_t set_bits2 = (in2_dst->sin6_addr.s6_addr32[i]
+                                    ^ in2_src->sin6_addr.s6_addr32[i]);
+              bit1 = stdc_leading_zeros (ntohl (set_bits1));
+              bit2 = stdc_leading_zeros (ntohl (set_bits2));
 	    }
 	}
 
-- 
2.49.0

The iovec size should account for all substrings between each conversion
specification.  For the format:

  "abc %s efg"

The list of substrings are:

  ["abc ", arg, " efg]

which is 2 times the number of maximum arguments *plus* one.

This issue triggered 'out of bounds' errors by stdlib/tst-bz20544 when
glibc is built with experimental UBSAN support [1].

Checked on x86_64-linux-gnu.

[1] https://sourceware.org/git/?p=glibc.git;a=shortlog;h=refs/heads/azanella/ubsan-undef
---
 sysdeps/posix/libc_fatal.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sysdeps/posix/libc_fatal.c b/sysdeps/posix/libc_fatal.c
index d90cc6c681..25ef20cfc1 100644
--- a/sysdeps/posix/libc_fatal.c
+++ b/sysdeps/posix/libc_fatal.c
@@ -61,7 +61,7 @@ __libc_message_impl (const char *fmt, ...)
   if (fd == -1)
     fd = STDERR_FILENO;
 
-  struct iovec iov[LIBC_MESSAGE_MAX_ARGS * 2 - 1];
+  struct iovec iov[LIBC_MESSAGE_MAX_ARGS * 2 + 1];
   int iovcnt = 0;
   ssize_t total = 0;
 
-- 
2.43.0

The __printf_fp_buffer_1 issues count_leading_zeros with 0 argument,
which might leads to call __builtin_ctz depending of the ABI.
Replace with stdbit.h function instead.

Checked on x86_64-linux-gnu and i686-linux-gnu.
---
 stdio-common/printf_fp.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/stdio-common/printf_fp.c b/stdio-common/printf_fp.c
index 5b46ddcaec..0039e1b20b 100644
--- a/stdio-common/printf_fp.c
+++ b/stdio-common/printf_fp.c
@@ -29,7 +29,6 @@
 #include <gmp.h>
 #include <ieee754.h>
 #include <stdlib/gmp-impl.h>
-#include <stdlib/longlong.h>
 #include <stdlib/fpioconst.h>
 #include <locale/localeinfo.h>
 #include <limits.h>
@@ -40,6 +39,7 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <stdbool.h>
+#include <stdbit.h>
 #include <rounding-mode.h>
 #include <printf_buffer.h>
 #include <printf_buffer_to_file.h>
@@ -386,7 +386,7 @@ __printf_fp_buffer_1 (struct __printf_buffer *buf, locale_t loc,
 		{
 		  int cnt;
 		  MPN_ASSIGN (p.scale, p.tmp);
-		  count_leading_zeros (cnt, p.scale[p.scalesize - 1]);
+		  cnt = stdc_leading_zeros (p.scale[p.scalesize - 1]);
 		  scaleexpo = (p.scalesize - 2) * BITS_PER_MP_LIMB - cnt - 1;
 		  exp10 |= 1 << explog;
 		}
@@ -408,7 +408,7 @@ __printf_fp_buffer_1 (struct __printf_buffer *buf, locale_t loc,
 	    ;
 
 	  /* Determine number of bits the scaling factor is misplaced.	*/
-	  count_leading_zeros (cnt_h, p.scale[p.scalesize - 1]);
+	  cnt_h = stdc_leading_zeros (p.scale[p.scalesize - 1]);
 
 	  if (cnt_h == 0)
 	    {
@@ -426,17 +426,17 @@ __printf_fp_buffer_1 (struct __printf_buffer *buf, locale_t loc,
 	    {
 	      if (p.scale[i] != 0)
 		{
-		  count_trailing_zeros (cnt_l, p.scale[i]);
+		  cnt_l = stdc_trailing_zeros (p.scale[i]);
 		  if (p.frac[i] != 0)
 		    {
 		      int cnt_l2;
-		      count_trailing_zeros (cnt_l2, p.frac[i]);
+		      cnt_l2 = stdc_trailing_zeros (p.frac[i]);
 		      if (cnt_l2 < cnt_l)
 			cnt_l = cnt_l2;
 		    }
 		}
 	      else
-		count_trailing_zeros (cnt_l, p.frac[i]);
+		cnt_l = stdc_trailing_zeros (p.frac[i]);
 
 	      /* Now shift the numbers to their optimal position.  */
 	      if (i == 0 && BITS_PER_MP_LIMB - cnt_h > cnt_l)
@@ -528,7 +528,7 @@ __printf_fp_buffer_1 (struct __printf_buffer *buf, locale_t loc,
 	      if (cy == 0)
 		--p.tmpsize;
 
-	      count_leading_zeros (cnt_h, p.tmp[p.tmpsize - 1]);
+	      cnt_h = stdc_leading_zeros (p.tmp[p.tmpsize - 1]);
 	      incr = (p.tmpsize - p.fracsize) * BITS_PER_MP_LIMB
 		     + BITS_PER_MP_LIMB - 1 - cnt_h;
 
@@ -584,7 +584,7 @@ __printf_fp_buffer_1 (struct __printf_buffer *buf, locale_t loc,
 		    }
 		  else
 		    {
-		      count_trailing_zeros (cnt_l, p.tmp[i]);
+		      cnt_l = stdc_trailing_zeros (p.tmp[i]);
 
 		      /* Now shift the numbers to their optimal position.  */
 		      if (i == 0 && BITS_PER_MP_LIMB - 1 - cnt_h > cnt_l)
@@ -630,7 +630,7 @@ __printf_fp_buffer_1 (struct __printf_buffer *buf, locale_t loc,
 	  p.tmpsize = p.fracsize;
 	  assert (cy == 0 || p.tmp[p.tmpsize - 1] < 20);
 
-	  count_trailing_zeros (cnt_l, p.tmp[0]);
+	  cnt_l = stdc_trailing_zeros (p.tmp[0]);
 	  if (cnt_l < MIN (4, p.exponent))
 	    {
 	      cy = __mpn_lshift (p.frac, p.tmp, p.tmpsize,
-- 
2.43.0

The left shift overflows for 'int', use unsigned instead.  It syncs
with CORE-MATH commit 4d6192d2.

Checked on aarch64-linux-gnu, x86_64-linux-gnu, and i686-linux-gnu.
---
 sysdeps/ieee754/flt-32/e_atanhf.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/sysdeps/ieee754/flt-32/e_atanhf.c b/sysdeps/ieee754/flt-32/e_atanhf.c
index 5138408324..eeb1aae6a1 100644
--- a/sysdeps/ieee754/flt-32/e_atanhf.c
+++ b/sysdeps/ieee754/flt-32/e_atanhf.c
@@ -3,7 +3,7 @@
 Copyright (c) 2023-2024 Alexei Sibidanov.
 
 The original version of this file was copied from the CORE-MATH
-project (file src/binary32/acosh/acoshf.c, revision bc385c2).
+project (file src/binary32/acosh/acoshf.c, revision 4d6192d2).
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -135,7 +135,7 @@ __ieee754_atanhf (float x)
     }
   double sgn = s[ux >> 31];
   unsigned int e = ax >> 24;
-  unsigned int md = ((ux << 8) | 1 << 31) >> (126 - e);
+  unsigned int md = ((ux << 8) | 1U << 31) >> (126 - e);
   unsigned int mn = -md;
   int nz = __builtin_clz (mn) + 1;
   mn <<= nz;
-- 
2.43.0

The left shift overflows for 'int', use a literal instead.  It syncs
with OPTIMIZED-ROUTINES commit 0f87f607b976820ef41fe64d004fe67dc7af8236.

Checked on aarch64-linux-gnu, x86_64-linux-gnu, and i686-linux-gnu.
---
 sysdeps/ieee754/flt-32/e_logf.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sysdeps/ieee754/flt-32/e_logf.c b/sysdeps/ieee754/flt-32/e_logf.c
index 6a595cf7f0..207151c76a 100644
--- a/sysdeps/ieee754/flt-32/e_logf.c
+++ b/sysdeps/ieee754/flt-32/e_logf.c
@@ -70,7 +70,7 @@ __logf (float x)
   tmp = ix - OFF;
   i = (tmp >> (23 - LOGF_TABLE_BITS)) % N;
   k = (int32_t) tmp >> 23; /* arithmetic shift */
-  iz = ix - (tmp & 0x1ff << 23);
+  iz = ix - (tmp & 0xff800000);
   invc = T[i].invc;
   logc = T[i].logc;
   z = (double_t) asfloat (iz);
-- 
2.43.0

The left shift overflows for 'int64_t', use unsigned instead.  It syncs
with CORE-MATH commit f7c7408d1749ec2859ea249495af699359ae559b.

Checked on aarch64-linux-gnu, x86_64-linux-gnu, and i686-linux-gnu.
---
 sysdeps/ieee754/flt-32/s_cbrtf.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/sysdeps/ieee754/flt-32/s_cbrtf.c b/sysdeps/ieee754/flt-32/s_cbrtf.c
index 5a7a9a952d..df9e888c1f 100644
--- a/sysdeps/ieee754/flt-32/s_cbrtf.c
+++ b/sysdeps/ieee754/flt-32/s_cbrtf.c
@@ -3,7 +3,7 @@
 Copyright (c) 2023, 2024 Alexei Sibidanov.
 
 The original version of this file was copied from the CORE-MATH
-project (file src/binary32/cbrt/cbrtf.c, revision bc385c2).
+project (file src/binary32/cbrt/cbrtf.c, revision f7c7408d).
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -61,8 +61,8 @@ __cbrtf (float x)
   e += 899;
   uint32_t et = e / 3, it = e % 3;
   uint64_t isc = escale[it].u;
-  isc += (int64_t) (et - 342) << 52;
-  isc |= (int64_t) sgn << 63;
+  isc += (uint64_t) (et - 342) << 52;
+  isc |= (uint64_t) sgn << 63;
   double cvt2 = asdouble (isc);
   static const double c[] =
     {
-- 
2.43.0

The left shift overflows for 'int', use uint64_t instead.  It syncs
with CORE-MATH commit d0a2be200cbc1344d800d9ef0ebee9ad67dd3ad8.

Checked on aarch64-linux-gnu, x86_64-linux-gnu, and i686-linux-gnu.
---
 sysdeps/ieee754/flt-32/s_erfcf.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/sysdeps/ieee754/flt-32/s_erfcf.c b/sysdeps/ieee754/flt-32/s_erfcf.c
index 3dae2a0b0e..955f129148 100644
--- a/sysdeps/ieee754/flt-32/s_erfcf.c
+++ b/sysdeps/ieee754/flt-32/s_erfcf.c
@@ -3,7 +3,7 @@
 Copyright (c) 2023, 2024 Alexei Sibidanov.
 
 This file is part of the CORE-MATH project
-project (file src/binary32/erfc/erfcf.c revision bc385c2).
+project (file src/binary32/erfc/erfcf.c revision d0a2be20).
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
@@ -142,7 +142,7 @@ __erfcf (float xf)
   const double ln2l = 0x1.cf79abd6f5dc8p-47;
   uint64_t jt = asuint64 (fma (x2, iln2, -(1024 + 0x1p-8)));
   int64_t j = (int64_t) (jt << 12) >> 48;
-  double S = asdouble (((j >> 7) + (0x3ff | sgn << 11)) << 52);
+  double S = asdouble ((uint64_t)((j >> 7) + (0x3ff | sgn << 11)) << 52);
   static const double ch[] =
     {
       -0x1.ffffffffff333p-2, 0x1.5555555556a14p-3, -0x1.55556666659b4p-5,
-- 
2.43.0
