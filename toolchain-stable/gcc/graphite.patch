From fb268a37704b1598a84051c735514ff38adad038 Mon Sep 17 00:00:00 2001
From: Frederik Harwath <frederik@codesourcery.com>
Date: Wed, 18 May 2022 07:59:42 +0200
Subject: [PATCH] graphite: Extend SCoP detection dump output

Extend dump output to make understanding why Graphite rejects to
include a loop in a SCoP easier (for GCC developers).

gcc/ChangeLog:

	* graphite-scop-detection.cc (scop_detection::can_represent_loop):
	Output reason for failure to dump file.
	(scop_detection::harmful_loop_in_region): Likewise.
	(scop_detection::graphite_can_represent_expr): Likewise.
	(scop_detection::stmt_has_simple_data_refs_p): Likewise.
	(scop_detection::stmt_simple_for_scop_p): Likewise.
	(print_sese_loop_numbers): New function.
	(scop_detection::add_scop): Use from here.

gcc/testsuite/ChangeLog:

	* gcc.dg/graphite/scop-22a.c: New test.
---
 gcc/graphite-scop-detection.cc           | 184 ++++++++++++++++++++---
 gcc/testsuite/gcc.dg/graphite/scop-22a.c |  56 +++++++
 2 files changed, 219 insertions(+), 21 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/graphite/scop-22a.c

diff --git a/gcc/graphite-scop-detection.cc b/gcc/graphite-scop-detection.cc
index 8c0ee9975579..9792d87ee0ae 100644
--- a/gcc/graphite-scop-detection.cc
+++ b/gcc/graphite-scop-detection.cc
@@ -69,12 +69,27 @@ public:
     fprintf (output.dump_file, "%d", i);
     return output;
   }
+
   friend debug_printer &
   operator<< (debug_printer &output, const char *s)
   {
     fprintf (output.dump_file, "%s", s);
     return output;
   }
+
+  friend debug_printer &
+  operator<< (debug_printer &output, gimple* stmt)
+  {
+    print_gimple_stmt (output.dump_file, stmt, 0, TDF_VOPS | TDF_MEMSYMS);
+    return output;
+  }
+
+  friend debug_printer &
+  operator<< (debug_printer &output, tree t)
+  {
+    print_generic_expr (output.dump_file, t, TDF_SLIM);
+    return output;
+  }
 } dp;

 #define DEBUG_PRINT(args) do \
@@ -506,6 +521,27 @@ scop_detection::merge_sese (sese_l first, sese_l second) const
   return combined;
 }

+/* Print the loop numbers of the loops contained in SESE to FILE. */
+
+static void
+print_sese_loop_numbers (FILE *file, sese_l sese)
+{
+  bool first_loop = true;
+  for (loop_p nest = sese.entry->dest->loop_father; nest; nest = nest->next)
+    {
+      if (!loop_in_sese_p (nest, sese))
+        break;
+
+      for (auto loop : loops_list (cfun, LI_INCLUDE_ROOT, nest))
+        {
+          gcc_assert (loop_in_sese_p (loop, sese));
+
+          fprintf (file, "%s%d", first_loop ? "" : ", ", loop->num);
+          first_loop = false;
+        }
+    }
+}
+
 /* Build scop outer->inner if possible.  */

 void
@@ -519,6 +555,10 @@ scop_detection::build_scop_depth (loop_p loop)
       if (! next
 	  || harmful_loop_in_region (next))
 	{
+	  if (next)
+	    DEBUG_PRINT (dp << "[scop-detection] Discarding SCoP on loops ";
+			 print_sese_loop_numbers (dump_file, next);
+			 dp << " because of harmful loops\n");
 	  if (s)
 	    add_scop (s);
 	  build_scop_depth (loop);
@@ -560,14 +600,63 @@ scop_detection::can_represent_loop (loop_p loop, sese_l scop)
       || !single_pred_p (loop->latch)
       || exit->src != single_pred (loop->latch)
       || !empty_block_p (loop->latch))
-    return false;
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] Loop shape unsupported.\n");
+      return false;
+    }
+
+  bool edge_irreducible = (loop_preheader_edge (loop)->flags
+			   & EDGE_IRREDUCIBLE_LOOP);
+  if (edge_irreducible)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+			 "Loop is not a natural loop.\n");
+      return false;
+    }
+
+  bool niter_is_unconditional = number_of_iterations_exit (loop,
+							   single_exit (loop),
+							   &niter_desc, false);
+
+  if (!niter_is_unconditional)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+			 "Loop niter not unconditional.\n"
+			 "Condition: " << niter_desc.assumptions << "\n");
+      return false;
+    }
+
+  niter = number_of_latch_executions (loop);
+  if (!niter)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] Loop niter unknown.\n");
+      return false;
+    }
+  if (!niter_desc.control.no_overflow)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] Loop niter can overflow.\n");
+      return false;
+    }

-  return !(loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP)
-    && number_of_iterations_exit (loop, single_exit (loop), &niter_desc, false)
-    && niter_desc.control.no_overflow
-    && (niter = number_of_latch_executions (loop))
-    && !chrec_contains_undetermined (niter)
-    && graphite_can_represent_expr (scop, loop, niter);
+  bool undetermined_coefficients = chrec_contains_undetermined (niter);
+  if (undetermined_coefficients)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+			 "Loop niter chrec contains undetermined "
+			 "coefficients.\n");
+      return false;
+    }
+
+  bool can_represent_expr = graphite_can_represent_expr (scop, loop, niter);
+  if (!can_represent_expr)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+		      << "Loop niter expression cannot be represented: "
+		      << niter << "\n");
+      return false;
+    }
+
+  return true;
 }

 /* Return true when BEGIN is the preheader edge of a loop with a single exit
@@ -640,6 +729,13 @@ scop_detection::add_scop (sese_l s)

   scops.safe_push (s);
   DEBUG_PRINT (dp << "[scop-detection] Adding SCoP: "; print_sese (dump_file, s));
+
+  if (dump_file && dump_flags & TDF_DETAILS)
+    {
+      fprintf (dump_file, "Loops in SCoP: ");
+      print_sese_loop_numbers (dump_file, s);
+      fprintf (dump_file, "\n");
+    }
 }

 /* Return true when a statement in SCOP cannot be represented by Graphite.  */
@@ -665,7 +761,12 @@ scop_detection::harmful_loop_in_region (sese_l scop) const

       /* The basic block should not be part of an irreducible loop.  */
       if (bb->flags & BB_IRREDUCIBLE_LOOP)
-	return true;
+	{
+	  DEBUG_PRINT (dp << "[scop-detection-fail] Found bb in irreducible "
+			     "loop.\n");
+
+	  return true;
+	}

       /* Check for unstructured control flow: CFG not generated by structured
 	 if-then-else.  */
@@ -676,7 +777,11 @@ scop_detection::harmful_loop_in_region (sese_l scop) const
 	  FOR_EACH_EDGE (e, ei, bb->succs)
 	    if (!dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest)
 		&& !dominated_by_p (CDI_DOMINATORS, e->dest, bb))
-	      return true;
+	      {
+		DEBUG_PRINT (dp << "[scop-detection-fail] Found unstructured "
+				   "control flow.\n");
+		return true;
+	      }
 	}

       /* Collect all loops in the current region.  */
@@ -688,7 +793,11 @@ scop_detection::harmful_loop_in_region (sese_l scop) const
       for (gimple_stmt_iterator gsi = gsi_start_bb (bb);
 	   !gsi_end_p (gsi); gsi_next (&gsi))
 	if (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))
-	  return true;
+	  {
+	    DEBUG_PRINT (dp << "[scop-detection-fail] "
+			       "Found harmful statement.\n");
+	    return true;
+	  }

       for (basic_block dom = first_dom_son (CDI_DOMINATORS, bb);
 	   dom;
@@ -731,9 +840,10 @@ scop_detection::harmful_loop_in_region (sese_l scop) const
 	  && ! loop_nest_has_data_refs (loop))
 	{
 	  DEBUG_PRINT (dp << "[scop-detection-fail] loop_" << loop->num
-		       << "does not have any data reference.\n");
+		       << " does not have any data reference.\n");
 	  return true;
 	}
+      DEBUG_PRINT (dp << "[scop-detection] loop_" << loop->num << " is harmless.\n");
     }

   return false;
@@ -922,7 +1032,21 @@ scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,
 					     tree expr)
 {
   tree scev = cached_scalar_evolution_in_region (scop, loop, expr);
-  return graphite_can_represent_scev (scop, scev);
+  bool can_represent = graphite_can_represent_scev (scop, scev);
+
+  if (!can_represent)
+    {
+      if (dump_file)
+	{
+	  fprintf (dump_file,
+		   "[graphite_can_represent_expr] Cannot represent scev \"");
+	  print_generic_expr (dump_file, scev, TDF_SLIM);
+	  fprintf (dump_file, "\" of expression ");
+	  print_generic_expr (dump_file, expr, TDF_SLIM);
+	  fprintf (dump_file, " in loop %d\n", loop->num);
+	}
+    }
+  return can_represent;
 }

 /* Return true if the data references of STMT can be represented by Graphite.
@@ -938,7 +1062,11 @@ scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)

   auto_vec<data_reference_p> drs;
   if (! graphite_find_data_references_in_stmt (nest, loop, stmt, &drs))
-    return false;
+    {
+      DEBUG_PRINT (dp << "[stmt_has_simple_data_refs_p] "
+			 "Unanalyzable statement.\n");
+      return false;
+    }

   int j;
   data_reference_p dr;
@@ -946,7 +1074,12 @@ scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)
     {
       for (unsigned i = 0; i < DR_NUM_DIMENSIONS (dr); ++i)
 	if (! graphite_can_represent_scev (scop, DR_ACCESS_FN (dr, i)))
-	  return false;
+	  {
+	    DEBUG_PRINT (dp << "[stmt_has_simple_data_refs_p] "
+			       "Cannot represent access function SCEV: "
+			    << DR_ACCESS_FN (dr, i) << "\n");
+	    return false;
+	  }
     }

   return true;
@@ -1027,14 +1160,23 @@ scop_detection::stmt_simple_for_scop_p (sese_l scop, gimple *stmt,
 	for (unsigned i = 0; i < 2; ++i)
 	  {
 	    tree op = gimple_op (stmt, i);
-	    if (!graphite_can_represent_expr (scop, loop, op)
-		/* We can only constrain on integer type.  */
-		|| ! INTEGRAL_TYPE_P (TREE_TYPE (op)))
+	    if (!graphite_can_represent_expr (scop, loop, op))
+	      {
+		DEBUG_PRINT (dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,
+					      "[scop-detection-fail] "
+					      "Graphite cannot represent cond "
+					      "stmt operator expression.\n"));
+		DEBUG_PRINT (dp << op << "\n");
+		return false;
+	      }
+
+	    if (! INTEGRAL_TYPE_P (TREE_TYPE (op)))
 	      {
-		DEBUG_PRINT (dp << "[scop-detection-fail] "
-				<< "Graphite cannot represent stmt:\n";
-			     print_gimple_stmt (dump_file, stmt, 0,
-						TDF_VOPS | TDF_MEMSYMS));
+		DEBUG_PRINT (dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,
+					      "[scop-detection-fail] "
+					      "Graphite cannot represent cond "
+					      "statement operator. "
+					      "Type must be integral.\n"));
 		return false;
 	      }
 	  }
diff --git a/gcc/testsuite/gcc.dg/graphite/scop-22a.c b/gcc/testsuite/gcc.dg/graphite/scop-22a.c
new file mode 100644
index 000000000000..00d4b5315aeb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/graphite/scop-22a.c
@@ -0,0 +1,56 @@
+/* { dg-require-effective-target size32plus } */
+double u[1782225];
+
+void foo(int N, int *res)
+{
+  int i, j;
+  double a, b;
+  double sum = 0.0;
+
+  for (j = 3; j < N; j = j * j)
+    {
+      sum += a + b;
+    }
+
+  /* Next two loops form first SCoP */
+  for (i = 0; i < N; i++)
+    sum += u[i];
+
+  for (i = 0; i < N; i++)
+    {
+      a = u[i];
+      u[i] = i * i;
+      b = u[i];
+      sum += a + b;
+    }
+
+  for (j = 3; j < N; j = j * j)
+    {
+      sum += a + b;
+    }
+
+  for (j = 3; j < N; j = j * j)
+    {
+      sum += a + b;
+    }
+
+  /* Next two loop-nests form second SCoP */
+  for (i = 0; i < N; i++)
+    sum += u[i];
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	a = u[i];
+	u[i] = i * i;
+	b = u[j];
+	sum += a + b;
+      }
+
+  *res = sum + N;
+}
+
+/* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */
+/* { dg-final { scan-tree-dump-times "Loops in SCoP" 2 "graphite"} } */
+/* { dg-final { scan-tree-dump "Loops in SCoP: 2, 3" "graphite"} } */
+/* { dg-final { scan-tree-dump "Loops in SCoP: 6, 7, 8" "graphite"} } */
--
2.36.0

graphite: Rename isl_id_for_ssa_name

The SSA names for which this function gets used are always SCoP
parameters and hence "isl_id_for_parameter" is a better name.  It also
explains the prefix "P_" for those names in the ISL representation.

gcc/ChangeLog:

	* graphite-sese-to-poly.cc (isl_id_for_ssa_name): Rename to ...
	(isl_id_for_parameter): ... this new function name.
	(build_scop_context): Adjust function use.

 gcc/graphite-sese-to-poly.cc | 21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/gcc/graphite-sese-to-poly.cc b/gcc/graphite-sese-to-poly.cc
index 5a6d779052c..ea67b267e1c 100644
--- a/gcc/graphite-sese-to-poly.cc
+++ b/gcc/graphite-sese-to-poly.cc
@@ -100,14 +100,15 @@ extract_affine_mul (scop_p s, tree e, __isl_take isl_space *space)
   return isl_pw_aff_mul (lhs, rhs);
 }

-/* Return an isl identifier from the name of the ssa_name E.  */
+/* Return an isl identifier for the parameter P.  */

 static isl_id *
-isl_id_for_ssa_name (scop_p s, tree e)
+isl_id_for_parameter (scop_p s, tree p)
 {
-  char name1[14];
-  snprintf (name1, sizeof (name1), "P_%d", SSA_NAME_VERSION (e));
-  return isl_id_alloc (s->isl_context, name1, e);
+  gcc_checking_assert (TREE_CODE (p) == SSA_NAME);
+  char name[14];
+  snprintf (name, sizeof (name), "P_%d", SSA_NAME_VERSION (p));
+  return isl_id_alloc (s->isl_context, name, p);
 }

 /* Return an isl identifier for the data reference DR.  Data references and
@@ -898,15 +899,15 @@ build_scop_context (scop_p scop)
   isl_space *space = isl_space_set_alloc (scop->isl_context, nbp, 0);

   unsigned i;
-  tree e;
-  FOR_EACH_VEC_ELT (region->params, i, e)
+  tree p;
+  FOR_EACH_VEC_ELT (region->params, i, p)
     space = isl_space_set_dim_id (space, isl_dim_param, i,
-                                  isl_id_for_ssa_name (scop, e));
+				  isl_id_for_parameter (scop, p));

   scop->param_context = isl_set_universe (space);

-  FOR_EACH_VEC_ELT (region->params, i, e)
-    add_param_constraints (scop, i, e);
+  FOR_EACH_VEC_ELT (region->params, i, p)
+    add_param_constraints (scop, i, p);
 }

 /* Return true when loop A is nested in loop B.  */

graphite: Fix minor mistakes in comments

gcc/ChangeLog:

	* graphite-sese-to-poly.cc (build_poly_sr_1): Fix a typo and
	a reference to a variable which does not exist.
	* graphite-isl-ast-to-gimple.cc (gsi_insert_earliest): Fix typo
	in comment.

 gcc/graphite-isl-ast-to-gimple.cc | 2 +-
 gcc/graphite-sese-to-poly.cc      | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/gcc/graphite-isl-ast-to-gimple.cc b/gcc/graphite-isl-ast-to-gimple.cc
index 45ed7704807..844b6d4e2b5 100644
--- a/gcc/graphite-isl-ast-to-gimple.cc
+++ b/gcc/graphite-isl-ast-to-gimple.cc
@@ -1014,7 +1014,7 @@ gsi_insert_earliest (gimple_seq seq)
   basic_block begin_bb = get_entry_bb (codegen_region);

   /* Inserting the gimple statements in a vector because gimple_seq behave
-     in strage ways when inserting the stmts from it into different basic
+     in strange ways when inserting the stmts from it into different basic
      blocks one at a time.  */
   auto_vec<gimple *, 3> stmts;
   for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);
diff --git a/gcc/graphite-sese-to-poly.cc b/gcc/graphite-sese-to-poly.cc
index ea67b267e1c..51ba3af204f 100644
--- a/gcc/graphite-sese-to-poly.cc
+++ b/gcc/graphite-sese-to-poly.cc
@@ -649,14 +649,14 @@ build_poly_sr_1 (poly_bb_p pbb, gimple *stmt, tree var, enum poly_dr_type kind,
 		 isl_map *acc, isl_set *subscript_sizes)
 {
   scop_p scop = PBB_SCOP (pbb);
-  /* Each scalar variables has a unique alias set number starting from
+  /* Each scalar variable has a unique alias set number starting from
      the maximum alias set assigned to a dr.  */
   int alias_set = scop->max_alias_set + SSA_NAME_VERSION (var);
   subscript_sizes = isl_set_fix_si (subscript_sizes, isl_dim_set, 0,
 				    alias_set);

   /* Add a constrain to the ACCESSES polyhedron for the alias set of
-     data reference DR.  */
+     the reference.  */
   isl_constraint *c
     = isl_equality_alloc (isl_local_space_from_space (isl_map_get_space (acc)));
   c = isl_constraint_set_constant_si (c, -alias_set);
