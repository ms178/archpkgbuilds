From 5bd6b6f0e7d630c597900e82fe04bb2bc7a1e3d4 Mon Sep 17 00:00:00 2001
From: Thomas Rodgers <trodgers@redhat.com>
Date: Tue, 5 Jul 2022 17:42:42 -0700
Subject: [PATCH] libstdc++: Minor codegen improvement for atomic wait spinloop

This patch merges the spin loops in the atomic wait implementation which is a
minor codegen improvement.

libstdc++-v3/ChangeLog:
	* include/bits/atomic_wait.h (__atomic_spin): Merge spin loops.
---
 libstdc++-v3/include/bits/atomic_wait.h | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/libstdc++-v3/include/bits/atomic_wait.h b/libstdc++-v3/include/bits/atomic_wait.h
index 125b1cad886..a6d55d3af8a 100644
--- a/libstdc++-v3/include/bits/atomic_wait.h
+++ b/libstdc++-v3/include/bits/atomic_wait.h
@@ -142,8 +142,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     }

-    constexpr auto __atomic_spin_count_1 = 12;
-    constexpr auto __atomic_spin_count_2 = 4;
+    constexpr auto __atomic_spin_count_relax = 12;
+    constexpr auto __atomic_spin_count = 16;

     struct __default_spin_policy
     {
@@ -157,18 +157,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool
       __atomic_spin(_Pred& __pred, _Spin __spin = _Spin{ }) noexcept
       {
-	for (auto __i = 0; __i < __atomic_spin_count_1; ++__i)
+	for (auto __i = 0; __i < __atomic_spin_count; ++__i)
 	  {
 	    if (__pred())
 	      return true;
-	    __detail::__thread_relax();
-	  }

-	for (auto __i = 0; __i < __atomic_spin_count_2; ++__i)
-	  {
-	    if (__pred())
-	      return true;
-	    __detail::__thread_yield();
+	    if (__i < __atomic_spin_count_relax)
+	      __detail::__thread_relax();
+	    else
+	      __detail::__thread_yield();
 	  }

 	while (__spin())
--
2.36.1

The following avoids collecting all loops exit blocks into bitmaps
and computing the union of those up the loop tree possibly repeatedly.
Instead we make sure to do this only once for each loop with a
definition possibly requiring a LC phi node plus make sure to
leverage recorded exits to avoid the intermediate bitmap allocation.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

	* tree-ssa-loop-manip.cc (compute_live_loop_exits): Take
	the def loop exit block bitmap as argument instead of
	re-computing it here.
	(add_exit_phis_var): Adjust.
	(loop_name_cmp): New function.
	(add_exit_phis): Sort variables to insert LC PHI nodes
	after definition loop, for each definition loop compute
	the exit block bitmap once.
	(get_loops_exit): Remove.
	(rewrite_into_loop_closed_ssa_1): Do not pre-record
	all loop exit blocks into bitmaps.  Record loop exits
	if required.
---
 gcc/tree-ssa-loop-manip.cc | 95 ++++++++++++++++++++++----------------
 1 file changed, 56 insertions(+), 39 deletions(-)

diff --git a/gcc/tree-ssa-loop-manip.cc b/gcc/tree-ssa-loop-manip.cc
index 9f3b62652ea..0324ff60a0f 100644
--- a/gcc/tree-ssa-loop-manip.cc
+++ b/gcc/tree-ssa-loop-manip.cc
@@ -183,12 +183,14 @@ find_sibling_superloop (class loop *use_loop, class loop *def_loop)
 /* DEF_BB is a basic block containing a DEF that needs rewriting into
    loop-closed SSA form.  USE_BLOCKS is the set of basic blocks containing
    uses of DEF that "escape" from the loop containing DEF_BB (i.e. blocks in
-   USE_BLOCKS are dominated by DEF_BB but not in the loop father of DEF_B).
+   USE_BLOCKS are dominated by DEF_BB but not in the loop father of DEF_BB).
    ALL_EXITS[I] is the set of all basic blocks that exit loop I.
+   DEF_LOOP_EXITS is a bitmap of loop exit blocks that exit the loop
+   containing DEF_BB or its outer loops.

-   Compute the subset of LOOP_EXITS that exit the loop containing DEF_BB
-   or one of its loop fathers, in which DEF is live.  This set is returned
-   in the bitmap LIVE_EXITS.
+   Compute the subset of loop exit destinations that exit the loop
+   containing DEF_BB or one of its loop fathers, in which DEF is live.
+   This set is returned in the bitmap LIVE_EXITS.

    Instead of computing the complete livein set of the def, we use the loop
    nesting tree as a form of poor man's structure analysis.  This greatly
@@ -197,18 +199,17 @@ find_sibling_superloop (class loop *use_loop, class loop *def_loop)

 static void
 compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,
-			 bitmap *loop_exits, basic_block def_bb)
+			 basic_block def_bb, bitmap def_loop_exits)
 {
   unsigned i;
   bitmap_iterator bi;
   class loop *def_loop = def_bb->loop_father;
   unsigned def_loop_depth = loop_depth (def_loop);
-  bitmap def_loop_exits;

   /* Normally the work list size is bounded by the number of basic
      blocks in the largest loop.  We don't know this number, but we
      can be fairly sure that it will be relatively small.  */
-  auto_vec<basic_block> worklist (MAX (8, n_basic_blocks_for_fn (cfun) / 128));
+  auto_vec<basic_block, 8> worklist (MAX (8, n_basic_blocks_for_fn (cfun) / 128));

   EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)
     {
@@ -272,13 +273,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,
 	}
     }

-  def_loop_exits = BITMAP_ALLOC (&loop_renamer_obstack);
-  for (class loop *loop = def_loop;
-       loop != current_loops->tree_root;
-       loop = loop_outer (loop))
-    bitmap_ior_into (def_loop_exits, loop_exits[loop->num]);
   bitmap_and_into (live_exits, def_loop_exits);
-  BITMAP_FREE (def_loop_exits);
 }

 /* Add a loop-closing PHI for VAR in basic block EXIT.  */
@@ -322,23 +317,33 @@ add_exit_phi (basic_block exit, tree var)
    Exits of the loops are stored in LOOP_EXITS.  */

 static void
-add_exit_phis_var (tree var, bitmap use_blocks, bitmap *loop_exits)
+add_exit_phis_var (tree var, bitmap use_blocks, bitmap def_loop_exits)
 {
   unsigned index;
   bitmap_iterator bi;
   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));
-  bitmap live_exits = BITMAP_ALLOC (&loop_renamer_obstack);

   gcc_checking_assert (! bitmap_bit_p (use_blocks, def_bb->index));

-  compute_live_loop_exits (live_exits, use_blocks, loop_exits, def_bb);
+  auto_bitmap live_exits (&loop_renamer_obstack);
+  compute_live_loop_exits (live_exits, use_blocks, def_bb, def_loop_exits);

   EXECUTE_IF_SET_IN_BITMAP (live_exits, 0, index, bi)
     {
       add_exit_phi (BASIC_BLOCK_FOR_FN (cfun, index), var);
     }
+}

-  BITMAP_FREE (live_exits);
+static int
+loop_name_cmp (const void *p1, const void *p2)
+{
+  auto l1 = (const std::pair<int, int> *)p1;
+  auto l2 = (const std::pair<int, int> *)p2;
+  if (l1->first < l2->first)
+    return -1;
+  else if (l1->first > l2->first)
+    return 1;
+  return 0;
 }

 /* Add exit phis for the names marked in NAMES_TO_RENAME.
@@ -346,31 +351,38 @@ add_exit_phis_var (tree var, bitmap use_blocks, bitmap *loop_exits)
    names are used are stored in USE_BLOCKS.  */

 static void
-add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap *loop_exits)
+add_exit_phis (bitmap names_to_rename, bitmap *use_blocks)
 {
   unsigned i;
   bitmap_iterator bi;

+  /* Sort names_to_rename after definition loop so we can avoid re-computing
+     def_loop_exits.  */
+  auto_vec<std::pair<int, int> > names (bitmap_count_bits (names_to_rename));
   EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)
     {
-      add_exit_phis_var (ssa_name (i), use_blocks[i], loop_exits);
+      tree name = ssa_name (i);
+      loop_p def_loop = gimple_bb (SSA_NAME_DEF_STMT (name))->loop_father;
+      names.quick_push (std::make_pair (def_loop->num, i));
     }
-}
+  names.qsort (loop_name_cmp);

-/* Fill the array of bitmaps LOOP_EXITS with all loop exit edge targets.  */
-
-static void
-get_loops_exits (bitmap *loop_exits)
-{
-  unsigned j;
-  edge e;
-
-  for (auto loop : loops_list (cfun, 0))
+  auto_bitmap def_loop_exits (&loop_renamer_obstack);
+  loop_p last_def_loop = NULL;
+  for (auto p : names)
     {
-      auto_vec<edge> exit_edges = get_loop_exit_edges (loop);
-      loop_exits[loop->num] = BITMAP_ALLOC (&loop_renamer_obstack);
-      FOR_EACH_VEC_ELT (exit_edges, j, e)
-        bitmap_set_bit (loop_exits[loop->num], e->dest->index);
+      loop_p def_loop = get_loop (cfun, p.first);
+      if (def_loop != last_def_loop)
+	{
+	  bitmap_clear (def_loop_exits);
+	  last_def_loop = def_loop;
+	  for (class loop *loop = def_loop; loop != current_loops->tree_root;
+	       loop = loop_outer (loop))
+	    for (auto exit = loop->exits->next; exit->e; exit = exit->next)
+	      bitmap_set_bit (def_loop_exits, exit->e->dest->index);
+	}
+      add_exit_phis_var (ssa_name (p.second), use_blocks[p.second],
+			 def_loop_exits);
     }
 }

@@ -566,16 +578,21 @@ rewrite_into_loop_closed_ssa_1 (bitmap changed_bbs, unsigned update_flag,

   if (!bitmap_empty_p (names_to_rename))
     {
-      /* An array of bitmaps where LOOP_EXITS[I] is the set of basic blocks
-	 that are the destination of an edge exiting loop number I.  */
-      bitmap *loop_exits = XNEWVEC (bitmap, number_of_loops (cfun));
-      get_loops_exits (loop_exits);
+      bool release_recorded_exits_p = false;
+      if (!loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS))
+	{
+	  /* Doing one scan over the whole function is cheaper than
+	     traversing the loop tree and gathering BBs of each loop.  */
+	  record_loop_exits ();
+	  release_recorded_exits_p = true;
+	}

       /* Add the PHI nodes on exits of the loops for the names we need to
 	 rewrite.  */
-      add_exit_phis (names_to_rename, use_blocks, loop_exits);
+      add_exit_phis (names_to_rename, use_blocks);

-      free (loop_exits);
+      if (release_recorded_exits_p)
+	release_recorded_exits (cfun);

       /* Fix up all the names found to be used outside their original
 	 loops.  */
--
2.35.3

In many cases loops have only one exit or a variable is only live
across one of the exits.  In this case we know that all uses
outside of the loop will be dominated by the single LC PHI node
we insert.  If that holds for all variables requiring LC SSA PHIs
then we can simplify the update_ssa process, avoiding the
(iterated) dominance frontier computations.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

	* tree-ssa-loop-manip.cc (add_exit_phis_var): Return the
	number of LC PHIs inserted.
	(add_exit_phis): Return whether any variable required
	multiple LC PHI nodes.
	(rewrite_into_loop_closed_ssa_1): Use TODO_update_ssa_no_phi
	when possible.
---
 gcc/tree-ssa-loop-manip.cc | 30 +++++++++++++++++++++---------
 1 file changed, 21 insertions(+), 9 deletions(-)

diff --git a/gcc/tree-ssa-loop-manip.cc b/gcc/tree-ssa-loop-manip.cc
index 0324ff60a0f..c531f1f12fd 100644
--- a/gcc/tree-ssa-loop-manip.cc
+++ b/gcc/tree-ssa-loop-manip.cc
@@ -314,9 +314,10 @@ add_exit_phi (basic_block exit, tree var)
 }

 /* Add exit phis for VAR that is used in LIVEIN.
-   Exits of the loops are stored in LOOP_EXITS.  */
+   Exits of the loops are stored in LOOP_EXITS.  Returns the number
+   of PHIs added for VAR.  */

-static void
+static unsigned
 add_exit_phis_var (tree var, bitmap use_blocks, bitmap def_loop_exits)
 {
   unsigned index;
@@ -328,10 +329,13 @@ add_exit_phis_var (tree var, bitmap use_blocks, bitmap def_loop_exits)
   auto_bitmap live_exits (&loop_renamer_obstack);
   compute_live_loop_exits (live_exits, use_blocks, def_bb, def_loop_exits);

+  unsigned cnt = 0;
   EXECUTE_IF_SET_IN_BITMAP (live_exits, 0, index, bi)
     {
       add_exit_phi (BASIC_BLOCK_FOR_FN (cfun, index), var);
+      cnt++;
     }
+  return cnt;
 }

 static int
@@ -348,13 +352,15 @@ loop_name_cmp (const void *p1, const void *p2)

 /* Add exit phis for the names marked in NAMES_TO_RENAME.
    Exits of the loops are stored in EXITS.  Sets of blocks where the ssa
-   names are used are stored in USE_BLOCKS.  */
+   names are used are stored in USE_BLOCKS.  Returns whether any name
+   required multiple LC PHI nodes.  */

-static void
+static bool
 add_exit_phis (bitmap names_to_rename, bitmap *use_blocks)
 {
   unsigned i;
   bitmap_iterator bi;
+  bool multiple_p = false;

   /* Sort names_to_rename after definition loop so we can avoid re-computing
      def_loop_exits.  */
@@ -381,9 +387,12 @@ add_exit_phis (bitmap names_to_rename, bitmap *use_blocks)
 	    for (auto exit = loop->exits->next; exit->e; exit = exit->next)
 	      bitmap_set_bit (def_loop_exits, exit->e->dest->index);
 	}
-      add_exit_phis_var (ssa_name (p.second), use_blocks[p.second],
-			 def_loop_exits);
+      if (add_exit_phis_var (ssa_name (p.second), use_blocks[p.second],
+			     def_loop_exits) > 1)
+	multiple_p = true;
     }
+
+  return multiple_p;
 }

 /* For USE in BB, if it is used outside of the loop it is defined in,
@@ -588,15 +597,18 @@ rewrite_into_loop_closed_ssa_1 (bitmap changed_bbs, unsigned update_flag,
 	}

       /* Add the PHI nodes on exits of the loops for the names we need to
-	 rewrite.  */
-      add_exit_phis (names_to_rename, use_blocks);
+	 rewrite.  When no variable required multiple LC PHI nodes to be
+	 inserted then we know that all uses outside of the loop are
+	 dominated by the single LC SSA definition and no further PHI
+	 node insertions are required.  */
+      bool need_phis_p = add_exit_phis (names_to_rename, use_blocks);

       if (release_recorded_exits_p)
 	release_recorded_exits (cfun);

       /* Fix up all the names found to be used outside their original
 	 loops.  */
-      update_ssa (TODO_update_ssa);
+      update_ssa (need_phis_p ? TODO_update_ssa : TODO_update_ssa_no_phi);
     }

   bitmap_obstack_release (&loop_renamer_obstack);
--
2.35.3

From fb268a37704b1598a84051c735514ff38adad038 Mon Sep 17 00:00:00 2001
From: Frederik Harwath <frederik@codesourcery.com>
Date: Wed, 18 May 2022 07:59:42 +0200
Subject: [PATCH] graphite: Extend SCoP detection dump output

Extend dump output to make understanding why Graphite rejects to
include a loop in a SCoP easier (for GCC developers).

gcc/ChangeLog:

	* graphite-scop-detection.cc (scop_detection::can_represent_loop):
	Output reason for failure to dump file.
	(scop_detection::harmful_loop_in_region): Likewise.
	(scop_detection::graphite_can_represent_expr): Likewise.
	(scop_detection::stmt_has_simple_data_refs_p): Likewise.
	(scop_detection::stmt_simple_for_scop_p): Likewise.
	(print_sese_loop_numbers): New function.
	(scop_detection::add_scop): Use from here.

gcc/testsuite/ChangeLog:

	* gcc.dg/graphite/scop-22a.c: New test.
---
 gcc/graphite-scop-detection.cc           | 184 ++++++++++++++++++++---
 gcc/testsuite/gcc.dg/graphite/scop-22a.c |  56 +++++++
 2 files changed, 219 insertions(+), 21 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/graphite/scop-22a.c

diff --git a/gcc/graphite-scop-detection.cc b/gcc/graphite-scop-detection.cc
index 8c0ee9975579..9792d87ee0ae 100644
--- a/gcc/graphite-scop-detection.cc
+++ b/gcc/graphite-scop-detection.cc
@@ -69,12 +69,27 @@ public:
     fprintf (output.dump_file, "%d", i);
     return output;
   }
+
   friend debug_printer &
   operator<< (debug_printer &output, const char *s)
   {
     fprintf (output.dump_file, "%s", s);
     return output;
   }
+
+  friend debug_printer &
+  operator<< (debug_printer &output, gimple* stmt)
+  {
+    print_gimple_stmt (output.dump_file, stmt, 0, TDF_VOPS | TDF_MEMSYMS);
+    return output;
+  }
+
+  friend debug_printer &
+  operator<< (debug_printer &output, tree t)
+  {
+    print_generic_expr (output.dump_file, t, TDF_SLIM);
+    return output;
+  }
 } dp;

 #define DEBUG_PRINT(args) do \
@@ -506,6 +521,27 @@ scop_detection::merge_sese (sese_l first, sese_l second) const
   return combined;
 }

+/* Print the loop numbers of the loops contained in SESE to FILE. */
+
+static void
+print_sese_loop_numbers (FILE *file, sese_l sese)
+{
+  bool first_loop = true;
+  for (loop_p nest = sese.entry->dest->loop_father; nest; nest = nest->next)
+    {
+      if (!loop_in_sese_p (nest, sese))
+        break;
+
+      for (auto loop : loops_list (cfun, LI_INCLUDE_ROOT, nest))
+        {
+          gcc_assert (loop_in_sese_p (loop, sese));
+
+          fprintf (file, "%s%d", first_loop ? "" : ", ", loop->num);
+          first_loop = false;
+        }
+    }
+}
+
 /* Build scop outer->inner if possible.  */

 void
@@ -519,6 +555,10 @@ scop_detection::build_scop_depth (loop_p loop)
       if (! next
 	  || harmful_loop_in_region (next))
 	{
+	  if (next)
+	    DEBUG_PRINT (dp << "[scop-detection] Discarding SCoP on loops ";
+			 print_sese_loop_numbers (dump_file, next);
+			 dp << " because of harmful loops\n");
 	  if (s)
 	    add_scop (s);
 	  build_scop_depth (loop);
@@ -560,14 +600,63 @@ scop_detection::can_represent_loop (loop_p loop, sese_l scop)
       || !single_pred_p (loop->latch)
       || exit->src != single_pred (loop->latch)
       || !empty_block_p (loop->latch))
-    return false;
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] Loop shape unsupported.\n");
+      return false;
+    }
+
+  bool edge_irreducible = (loop_preheader_edge (loop)->flags
+			   & EDGE_IRREDUCIBLE_LOOP);
+  if (edge_irreducible)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+			 "Loop is not a natural loop.\n");
+      return false;
+    }
+
+  bool niter_is_unconditional = number_of_iterations_exit (loop,
+							   single_exit (loop),
+							   &niter_desc, false);
+
+  if (!niter_is_unconditional)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+			 "Loop niter not unconditional.\n"
+			 "Condition: " << niter_desc.assumptions << "\n");
+      return false;
+    }
+
+  niter = number_of_latch_executions (loop);
+  if (!niter)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] Loop niter unknown.\n");
+      return false;
+    }
+  if (!niter_desc.control.no_overflow)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] Loop niter can overflow.\n");
+      return false;
+    }

-  return !(loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP)
-    && number_of_iterations_exit (loop, single_exit (loop), &niter_desc, false)
-    && niter_desc.control.no_overflow
-    && (niter = number_of_latch_executions (loop))
-    && !chrec_contains_undetermined (niter)
-    && graphite_can_represent_expr (scop, loop, niter);
+  bool undetermined_coefficients = chrec_contains_undetermined (niter);
+  if (undetermined_coefficients)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+			 "Loop niter chrec contains undetermined "
+			 "coefficients.\n");
+      return false;
+    }
+
+  bool can_represent_expr = graphite_can_represent_expr (scop, loop, niter);
+  if (!can_represent_expr)
+    {
+      DEBUG_PRINT (dp << "[can_represent_loop-fail] "
+		      << "Loop niter expression cannot be represented: "
+		      << niter << "\n");
+      return false;
+    }
+
+  return true;
 }

 /* Return true when BEGIN is the preheader edge of a loop with a single exit
@@ -640,6 +729,13 @@ scop_detection::add_scop (sese_l s)

   scops.safe_push (s);
   DEBUG_PRINT (dp << "[scop-detection] Adding SCoP: "; print_sese (dump_file, s));
+
+  if (dump_file && dump_flags & TDF_DETAILS)
+    {
+      fprintf (dump_file, "Loops in SCoP: ");
+      print_sese_loop_numbers (dump_file, s);
+      fprintf (dump_file, "\n");
+    }
 }

 /* Return true when a statement in SCOP cannot be represented by Graphite.  */
@@ -665,7 +761,12 @@ scop_detection::harmful_loop_in_region (sese_l scop) const

       /* The basic block should not be part of an irreducible loop.  */
       if (bb->flags & BB_IRREDUCIBLE_LOOP)
-	return true;
+	{
+	  DEBUG_PRINT (dp << "[scop-detection-fail] Found bb in irreducible "
+			     "loop.\n");
+
+	  return true;
+	}

       /* Check for unstructured control flow: CFG not generated by structured
 	 if-then-else.  */
@@ -676,7 +777,11 @@ scop_detection::harmful_loop_in_region (sese_l scop) const
 	  FOR_EACH_EDGE (e, ei, bb->succs)
 	    if (!dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest)
 		&& !dominated_by_p (CDI_DOMINATORS, e->dest, bb))
-	      return true;
+	      {
+		DEBUG_PRINT (dp << "[scop-detection-fail] Found unstructured "
+				   "control flow.\n");
+		return true;
+	      }
 	}

       /* Collect all loops in the current region.  */
@@ -688,7 +793,11 @@ scop_detection::harmful_loop_in_region (sese_l scop) const
       for (gimple_stmt_iterator gsi = gsi_start_bb (bb);
 	   !gsi_end_p (gsi); gsi_next (&gsi))
 	if (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))
-	  return true;
+	  {
+	    DEBUG_PRINT (dp << "[scop-detection-fail] "
+			       "Found harmful statement.\n");
+	    return true;
+	  }

       for (basic_block dom = first_dom_son (CDI_DOMINATORS, bb);
 	   dom;
@@ -731,9 +840,10 @@ scop_detection::harmful_loop_in_region (sese_l scop) const
 	  && ! loop_nest_has_data_refs (loop))
 	{
 	  DEBUG_PRINT (dp << "[scop-detection-fail] loop_" << loop->num
-		       << "does not have any data reference.\n");
+		       << " does not have any data reference.\n");
 	  return true;
 	}
+      DEBUG_PRINT (dp << "[scop-detection] loop_" << loop->num << " is harmless.\n");
     }

   return false;
@@ -922,7 +1032,21 @@ scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,
 					     tree expr)
 {
   tree scev = cached_scalar_evolution_in_region (scop, loop, expr);
-  return graphite_can_represent_scev (scop, scev);
+  bool can_represent = graphite_can_represent_scev (scop, scev);
+
+  if (!can_represent)
+    {
+      if (dump_file)
+	{
+	  fprintf (dump_file,
+		   "[graphite_can_represent_expr] Cannot represent scev \"");
+	  print_generic_expr (dump_file, scev, TDF_SLIM);
+	  fprintf (dump_file, "\" of expression ");
+	  print_generic_expr (dump_file, expr, TDF_SLIM);
+	  fprintf (dump_file, " in loop %d\n", loop->num);
+	}
+    }
+  return can_represent;
 }

 /* Return true if the data references of STMT can be represented by Graphite.
@@ -938,7 +1062,11 @@ scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)

   auto_vec<data_reference_p> drs;
   if (! graphite_find_data_references_in_stmt (nest, loop, stmt, &drs))
-    return false;
+    {
+      DEBUG_PRINT (dp << "[stmt_has_simple_data_refs_p] "
+			 "Unanalyzable statement.\n");
+      return false;
+    }

   int j;
   data_reference_p dr;
@@ -946,7 +1074,12 @@ scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)
     {
       for (unsigned i = 0; i < DR_NUM_DIMENSIONS (dr); ++i)
 	if (! graphite_can_represent_scev (scop, DR_ACCESS_FN (dr, i)))
-	  return false;
+	  {
+	    DEBUG_PRINT (dp << "[stmt_has_simple_data_refs_p] "
+			       "Cannot represent access function SCEV: "
+			    << DR_ACCESS_FN (dr, i) << "\n");
+	    return false;
+	  }
     }

   return true;
@@ -1027,14 +1160,23 @@ scop_detection::stmt_simple_for_scop_p (sese_l scop, gimple *stmt,
 	for (unsigned i = 0; i < 2; ++i)
 	  {
 	    tree op = gimple_op (stmt, i);
-	    if (!graphite_can_represent_expr (scop, loop, op)
-		/* We can only constrain on integer type.  */
-		|| ! INTEGRAL_TYPE_P (TREE_TYPE (op)))
+	    if (!graphite_can_represent_expr (scop, loop, op))
+	      {
+		DEBUG_PRINT (dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,
+					      "[scop-detection-fail] "
+					      "Graphite cannot represent cond "
+					      "stmt operator expression.\n"));
+		DEBUG_PRINT (dp << op << "\n");
+		return false;
+	      }
+
+	    if (! INTEGRAL_TYPE_P (TREE_TYPE (op)))
 	      {
-		DEBUG_PRINT (dp << "[scop-detection-fail] "
-				<< "Graphite cannot represent stmt:\n";
-			     print_gimple_stmt (dump_file, stmt, 0,
-						TDF_VOPS | TDF_MEMSYMS));
+		DEBUG_PRINT (dump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,
+					      "[scop-detection-fail] "
+					      "Graphite cannot represent cond "
+					      "statement operator. "
+					      "Type must be integral.\n"));
 		return false;
 	      }
 	  }
diff --git a/gcc/testsuite/gcc.dg/graphite/scop-22a.c b/gcc/testsuite/gcc.dg/graphite/scop-22a.c
new file mode 100644
index 000000000000..00d4b5315aeb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/graphite/scop-22a.c
@@ -0,0 +1,56 @@
+/* { dg-require-effective-target size32plus } */
+double u[1782225];
+
+void foo(int N, int *res)
+{
+  int i, j;
+  double a, b;
+  double sum = 0.0;
+
+  for (j = 3; j < N; j = j * j)
+    {
+      sum += a + b;
+    }
+
+  /* Next two loops form first SCoP */
+  for (i = 0; i < N; i++)
+    sum += u[i];
+
+  for (i = 0; i < N; i++)
+    {
+      a = u[i];
+      u[i] = i * i;
+      b = u[i];
+      sum += a + b;
+    }
+
+  for (j = 3; j < N; j = j * j)
+    {
+      sum += a + b;
+    }
+
+  for (j = 3; j < N; j = j * j)
+    {
+      sum += a + b;
+    }
+
+  /* Next two loop-nests form second SCoP */
+  for (i = 0; i < N; i++)
+    sum += u[i];
+
+  for (i = 0; i < N; i++)
+    for (j = 0; j < N; j++)
+      {
+	a = u[i];
+	u[i] = i * i;
+	b = u[j];
+	sum += a + b;
+      }
+
+  *res = sum + N;
+}
+
+/* { dg-final { scan-tree-dump-times "number of SCoPs: 2" 1 "graphite"} } */
+/* { dg-final { scan-tree-dump-times "Loops in SCoP" 2 "graphite"} } */
+/* { dg-final { scan-tree-dump "Loops in SCoP: 2, 3" "graphite"} } */
+/* { dg-final { scan-tree-dump "Loops in SCoP: 6, 7, 8" "graphite"} } */
--
2.36.0

graphite: Rename isl_id_for_ssa_name

The SSA names for which this function gets used are always SCoP
parameters and hence "isl_id_for_parameter" is a better name.  It also
explains the prefix "P_" for those names in the ISL representation.

gcc/ChangeLog:

	* graphite-sese-to-poly.cc (isl_id_for_ssa_name): Rename to ...
	(isl_id_for_parameter): ... this new function name.
	(build_scop_context): Adjust function use.

 gcc/graphite-sese-to-poly.cc | 21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff --git a/gcc/graphite-sese-to-poly.cc b/gcc/graphite-sese-to-poly.cc
index 5a6d779052c..ea67b267e1c 100644
--- a/gcc/graphite-sese-to-poly.cc
+++ b/gcc/graphite-sese-to-poly.cc
@@ -100,14 +100,15 @@ extract_affine_mul (scop_p s, tree e, __isl_take isl_space *space)
   return isl_pw_aff_mul (lhs, rhs);
 }

-/* Return an isl identifier from the name of the ssa_name E.  */
+/* Return an isl identifier for the parameter P.  */

 static isl_id *
-isl_id_for_ssa_name (scop_p s, tree e)
+isl_id_for_parameter (scop_p s, tree p)
 {
-  char name1[14];
-  snprintf (name1, sizeof (name1), "P_%d", SSA_NAME_VERSION (e));
-  return isl_id_alloc (s->isl_context, name1, e);
+  gcc_checking_assert (TREE_CODE (p) == SSA_NAME);
+  char name[14];
+  snprintf (name, sizeof (name), "P_%d", SSA_NAME_VERSION (p));
+  return isl_id_alloc (s->isl_context, name, p);
 }

 /* Return an isl identifier for the data reference DR.  Data references and
@@ -898,15 +899,15 @@ build_scop_context (scop_p scop)
   isl_space *space = isl_space_set_alloc (scop->isl_context, nbp, 0);

   unsigned i;
-  tree e;
-  FOR_EACH_VEC_ELT (region->params, i, e)
+  tree p;
+  FOR_EACH_VEC_ELT (region->params, i, p)
     space = isl_space_set_dim_id (space, isl_dim_param, i,
-                                  isl_id_for_ssa_name (scop, e));
+				  isl_id_for_parameter (scop, p));

   scop->param_context = isl_set_universe (space);

-  FOR_EACH_VEC_ELT (region->params, i, e)
-    add_param_constraints (scop, i, e);
+  FOR_EACH_VEC_ELT (region->params, i, p)
+    add_param_constraints (scop, i, p);
 }

 /* Return true when loop A is nested in loop B.  */

graphite: Fix minor mistakes in comments

gcc/ChangeLog:

	* graphite-sese-to-poly.cc (build_poly_sr_1): Fix a typo and
	a reference to a variable which does not exist.
	* graphite-isl-ast-to-gimple.cc (gsi_insert_earliest): Fix typo
	in comment.

 gcc/graphite-isl-ast-to-gimple.cc | 2 +-
 gcc/graphite-sese-to-poly.cc      | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/gcc/graphite-isl-ast-to-gimple.cc b/gcc/graphite-isl-ast-to-gimple.cc
index 45ed7704807..844b6d4e2b5 100644
--- a/gcc/graphite-isl-ast-to-gimple.cc
+++ b/gcc/graphite-isl-ast-to-gimple.cc
@@ -1014,7 +1014,7 @@ gsi_insert_earliest (gimple_seq seq)
   basic_block begin_bb = get_entry_bb (codegen_region);

   /* Inserting the gimple statements in a vector because gimple_seq behave
-     in strage ways when inserting the stmts from it into different basic
+     in strange ways when inserting the stmts from it into different basic
      blocks one at a time.  */
   auto_vec<gimple *, 3> stmts;
   for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);
diff --git a/gcc/graphite-sese-to-poly.cc b/gcc/graphite-sese-to-poly.cc
index ea67b267e1c..51ba3af204f 100644
--- a/gcc/graphite-sese-to-poly.cc
+++ b/gcc/graphite-sese-to-poly.cc
@@ -649,14 +649,14 @@ build_poly_sr_1 (poly_bb_p pbb, gimple *stmt, tree var, enum poly_dr_type kind,
 		 isl_map *acc, isl_set *subscript_sizes)
 {
   scop_p scop = PBB_SCOP (pbb);
-  /* Each scalar variables has a unique alias set number starting from
+  /* Each scalar variable has a unique alias set number starting from
      the maximum alias set assigned to a dr.  */
   int alias_set = scop->max_alias_set + SSA_NAME_VERSION (var);
   subscript_sizes = isl_set_fix_si (subscript_sizes, isl_dim_set, 0,
 				    alias_set);

   /* Add a constrain to the ACCESSES polyhedron for the alias set of
-     data reference DR.  */
+     the reference.  */
   isl_constraint *c
     = isl_equality_alloc (isl_local_space_from_space (isl_map_get_space (acc)));
   c = isl_constraint_set_constant_si (c, -alias_set);

The code to remove LC PHI nodes in clean_up_loop_closed_phi does not handle
virtual operands because may_propagate_copy generally returns false
for them.  The following copies the merge_blocks variant for
dealing with them.

This fixes a missed jump threading in gcc.dg/auto-init-uninit-4.c
which manifests in bogus uninit diagnostics.

Bootstrap and regtest pending on x86_64-unknown-linux-gnu.

	PR tree-optimization/106186
	* tree-ssa-propagate.cc (clean_up_loop_closed_phi):
	Properly handle virtual PHI nodes.
---
 gcc/tree-ssa-propagate.cc | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/gcc/tree-ssa-propagate.cc b/gcc/tree-ssa-propagate.cc
index 163b24f0e69..9dc4bfd85bf 100644
--- a/gcc/tree-ssa-propagate.cc
+++ b/gcc/tree-ssa-propagate.cc
@@ -1272,7 +1272,21 @@ clean_up_loop_closed_phi (function *fun)
 	      rhs = gimple_phi_arg_def (phi, 0);
 	      lhs = gimple_phi_result (phi);

-	      if (rhs && may_propagate_copy (lhs, rhs))
+	      if (virtual_operand_p (rhs))
+		{
+		  imm_use_iterator iter;
+		  use_operand_p use_p;
+		  gimple *stmt;
+
+		  FOR_EACH_IMM_USE_STMT (stmt, iter, lhs)
+		    FOR_EACH_IMM_USE_ON_STMT (use_p, iter)
+		      SET_USE (use_p, rhs);
+
+		  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))
+		    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;
+		  remove_phi_node (&gsi, true);
+		}
+	      else if (may_propagate_copy (lhs, rhs))
 		{
 		  /* Dump details.  */
 		  if (dump_file && (dump_flags & TDF_DETAILS))
--
2.35.3

The following avoids copying and using blocks_to_update to
the interesting_blocks sbitmap when doing update_ssa as it is
unused besides the redundant query in the domwalk.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

	* tree-into-ssa.cc (rewrite_update_dom_walker::before_dom_children):
	Do not look at interesting_blocks which is a copy of
	blocks_to_update.
	(update_ssa): Do not initialize it.
	(pass_build_ssa::execute): Set interesting_blocks to NULL
	after releasing it.
---
 gcc/tree-into-ssa.cc | 22 ++++++----------------
 1 file changed, 6 insertions(+), 16 deletions(-)

diff --git a/gcc/tree-into-ssa.cc b/gcc/tree-into-ssa.cc
index c4e40e8fb08..c90651c3a89 100644
--- a/gcc/tree-into-ssa.cc
+++ b/gcc/tree-into-ssa.cc
@@ -2214,15 +2214,11 @@ rewrite_update_dom_walker::before_dom_children (basic_block bb)
     }

   /* Step 2.  Rewrite every variable used in each statement in the block.  */
-  if (bitmap_bit_p (interesting_blocks, bb->index))
-    {
-      gcc_checking_assert (bitmap_bit_p (blocks_to_update, bb->index));
-      for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )
-	if (rewrite_update_stmt (gsi_stmt (gsi), gsi))
-	  gsi_remove (&gsi, true);
-	else
-	  gsi_next (&gsi);
-    }
+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )
+    if (rewrite_update_stmt (gsi_stmt (gsi), gsi))
+      gsi_remove (&gsi, true);
+    else
+      gsi_next (&gsi);

   /* Step 3.  Update PHI nodes.  */
   rewrite_update_phi_arguments (bb);
@@ -2460,6 +2456,7 @@ pass_build_ssa::execute (function *fun)
   free (dfs);

   sbitmap_free (interesting_blocks);
+  interesting_blocks = NULL;

   fini_ssa_renamer ();

@@ -3503,15 +3500,8 @@ update_ssa (unsigned update_flags)
     get_var_info (sym)->info.current_def = NULL_TREE;

   /* Now start the renaming process at START_BB.  */
-  interesting_blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));
-  bitmap_clear (interesting_blocks);
-  EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)
-    bitmap_set_bit (interesting_blocks, i);
-
   rewrite_blocks (start_bb, REWRITE_UPDATE);

-  sbitmap_free (interesting_blocks);
-
   /* Debugging dumps.  */
   if (dump_file)
     {
--
2.35.3

The following avoids the need to massage the target optimization
node at WPA time when we fixup the optimization node, copying
FP related flags from callee to caller.  The target is already
set up to fixup, but that only works when not switching between
functions.  After fixing that the fixup is then done at LTRANS
time when materializing the function.

Bootstrapped and tested on x86_64-unknown-linux-gnu, ok?

Thanks,
Richard.

2022-07-01  Richard Biener  <rguenthert@suse.de>

	PR target/105459
	* config/i386/i386-options.cc (ix86_set_current_function):
	Rebuild the target optimization node whenever necessary,
	not only when the optimization node didn't change.

	* gcc.dg/lto/pr105459_0.c: New testcase.
---
 gcc/config/i386/i386-options.cc       | 32 ++++++++++--------------
 gcc/testsuite/gcc.dg/lto/pr105459_0.c | 35 +++++++++++++++++++++++++++
 2 files changed, 48 insertions(+), 19 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/lto/pr105459_0.c

diff --git a/gcc/config/i386/i386-options.cc b/gcc/config/i386/i386-options.cc
index e11f68186f5..acb2291e70f 100644
--- a/gcc/config/i386/i386-options.cc
+++ b/gcc/config/i386/i386-options.cc
@@ -3232,28 +3232,22 @@ ix86_set_current_function (tree fndecl)
   if (new_tree == NULL_TREE)
     new_tree = target_option_default_node;

-  if (old_tree != new_tree)
+  bool fp_flag_change
+    = (flag_unsafe_math_optimizations
+       != TREE_TARGET_OPTION (new_tree)->x_ix86_unsafe_math_optimizations
+       || (flag_excess_precision
+	   != TREE_TARGET_OPTION (new_tree)->x_ix86_excess_precision));
+  if (old_tree != new_tree || fp_flag_change)
     {
       cl_target_option_restore (&global_options, &global_options_set,
 				TREE_TARGET_OPTION (new_tree));
-      if (TREE_TARGET_GLOBALS (new_tree))
-	restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
-      else if (new_tree == target_option_default_node)
-	restore_target_globals (&default_target_globals);
-      else
-	TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
-    }
-  else if (flag_unsafe_math_optimizations
-	   != TREE_TARGET_OPTION (new_tree)->x_ix86_unsafe_math_optimizations
-	   || (flag_excess_precision
-	       != TREE_TARGET_OPTION (new_tree)->x_ix86_excess_precision))
-    {
-      cl_target_option_restore (&global_options, &global_options_set,
-				TREE_TARGET_OPTION (new_tree));
-      ix86_excess_precision = flag_excess_precision;
-      ix86_unsafe_math_optimizations = flag_unsafe_math_optimizations;
-      DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_tree
-	= build_target_option_node (&global_options, &global_options_set);
+      if (fp_flag_change)
+	{
+	  ix86_excess_precision = flag_excess_precision;
+	  ix86_unsafe_math_optimizations = flag_unsafe_math_optimizations;
+	  DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_tree
+	    = build_target_option_node (&global_options, &global_options_set);
+	}
       if (TREE_TARGET_GLOBALS (new_tree))
 	restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
       else if (new_tree == target_option_default_node)
diff --git a/gcc/testsuite/gcc.dg/lto/pr105459_0.c b/gcc/testsuite/gcc.dg/lto/pr105459_0.c
new file mode 100644
index 00000000000..c799e6ef23d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr105459_0.c
@@ -0,0 +1,35 @@
+/* { dg-lto-do link } */
+/* { dg-lto-options { { -flto -O1 } } } */
+
+double m;
+int n;
+
+__attribute__ ((optimize ("-funsafe-math-optimizations")))
+void
+bar (int x)
+{
+  n = x;
+  m = n;
+}
+
+__attribute__ ((flatten))
+void
+foo (int x)
+{
+  bar (x);
+}
+
+void
+quux (void)
+{
+  ++n;
+}
+
+int
+main (void)
+{
+  foo (0);
+  quux ();
+
+  return 0;
+}
--
2.35.3

1. Add a predicate for constant vectors which can be converted to integer
constants suitable for constant integer stores.  For a 8-byte constant
vector, the converted 64-bit integer must be valid for store with 64-bit
immediate, which is a 64-bit integer sign-extended from a 32-bit integer.
2. Add a new pattern to allow 2-byte, 4-byte and 8-byte constant vector
stores, like

(set (mem:V2HI (reg:DI 84))
     (const_vector:V2HI [(const_int 0 [0]) (const_int 1 [0x1])]))

3. After reload, convert constant vector stores to constant integer
stores, like

(set (mem:SI (reg:DI 5 di [84]))
     (const_int 65536 [0x10000]))

For

void
foo (short * c)
{
  c[0] = 0;
  c[1] = 1;
}

it generates

	movl	$65536, (%rdi)

instead of

	movl	.LC0(%rip), %eax
	movl	%eax, (%rdi)

gcc/

	PR target/106022
	* config/i386/i386-protos.h (ix86_convert_const_vector_to_integer):
	New.
	* config/i386/i386.cc (ix86_convert_const_vector_to_integer):
	New.
	* config/i386/mmx.md (V_16_32_64): New.
	(*mov<mode>_imm): New patterns for stores with 16-bit, 32-bit
	and 64-bit constant vector.
	* config/i386/predicates.md (x86_64_const_vector_operand): New.

gcc/testsuite/

	PR target/106022
	* gcc.target/i386/pr106022-1.c: New test.
	* gcc.target/i386/pr106022-2.c: Likewise.
	* gcc.target/i386/pr106022-3.c: Likewise.
	* gcc.target/i386/pr106022-4.c: Likewise.
---
 gcc/config/i386/i386-protos.h              |  2 +
 gcc/config/i386/i386.cc                    | 47 ++++++++++++++++++++++
 gcc/config/i386/mmx.md                     | 37 +++++++++++++++++
 gcc/config/i386/predicates.md              | 11 +++++
 gcc/testsuite/gcc.target/i386/pr106022-1.c | 13 ++++++
 gcc/testsuite/gcc.target/i386/pr106022-2.c | 14 +++++++
 gcc/testsuite/gcc.target/i386/pr106022-3.c | 14 +++++++
 gcc/testsuite/gcc.target/i386/pr106022-4.c | 14 +++++++
 8 files changed, 152 insertions(+)
 create mode 100644 gcc/testsuite/gcc.target/i386/pr106022-1.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr106022-2.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr106022-3.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr106022-4.c

diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 3596ce81ecf..cf847751ac5 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -122,6 +122,8 @@ extern void ix86_expand_unary_operator (enum rtx_code, machine_mode,
 					rtx[]);
 extern rtx ix86_build_const_vector (machine_mode, bool, rtx);
 extern rtx ix86_build_signbit_mask (machine_mode, bool, bool);
+extern HOST_WIDE_INT ix86_convert_const_vector_to_integer (rtx,
+							   machine_mode);
 extern void ix86_split_convert_uns_si_sse (rtx[]);
 extern void ix86_expand_convert_uns_didf_sse (rtx, rtx);
 extern void ix86_expand_convert_uns_sixf_sse (rtx, rtx);
diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index b15b4893bb9..0cfe9962f75 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -15723,6 +15723,53 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)
   return force_reg (vec_mode, v);
 }

+/* Return HOST_WIDE_INT for const vector OP in MODE.  */
+
+HOST_WIDE_INT
+ix86_convert_const_vector_to_integer (rtx op, machine_mode mode)
+{
+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+    gcc_unreachable ();
+
+  int nunits = GET_MODE_NUNITS (mode);
+  wide_int val = wi::zero (GET_MODE_BITSIZE (mode));
+  machine_mode innermode = GET_MODE_INNER (mode);
+  unsigned int innermode_bits = GET_MODE_BITSIZE (innermode);
+
+  switch (mode)
+    {
+    case E_V2QImode:
+    case E_V4QImode:
+    case E_V2HImode:
+    case E_V8QImode:
+    case E_V4HImode:
+    case E_V2SImode:
+      for (int i = 0; i < nunits; ++i)
+	{
+	  int v = INTVAL (XVECEXP (op, 0, i));
+	  wide_int wv = wi::shwi (v, innermode_bits);
+	  val = wi::insert (val, wv, innermode_bits * i, innermode_bits);
+	}
+      break;
+    case E_V2HFmode:
+    case E_V4HFmode:
+    case E_V2SFmode:
+      for (int i = 0; i < nunits; ++i)
+	{
+	  rtx x = XVECEXP (op, 0, i);
+	  int v = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (x),
+				  REAL_MODE_FORMAT (innermode));
+	  wide_int wv = wi::shwi (v, innermode_bits);
+	  val = wi::insert (val, wv, innermode_bits * i, innermode_bits);
+	}
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  return val.to_shwi ();
+}
+
 /* Return TRUE or FALSE depending on whether the first SET in INSN
    has source and destination with matching CC modes, and that the
    CC mode is at least as constrained as REQ_MODE.  */
diff --git a/gcc/config/i386/mmx.md b/gcc/config/i386/mmx.md
index ba53007a35e..3294c1e6274 100644
--- a/gcc/config/i386/mmx.md
+++ b/gcc/config/i386/mmx.md
@@ -69,6 +69,12 @@ (define_mode_iterator VI_16_32 [V4QI V2QI V2HI])
 ;; 4-byte and 2-byte QImode vector modes
 (define_mode_iterator VI1_16_32 [V4QI V2QI])

+;; All 2-byte, 4-byte and 8-byte vector modes with more than 1 element
+(define_mode_iterator V_16_32_64
+   [V2QI V4QI V2HI V2HF
+    (V8QI "TARGET_64BIT") (V4HI "TARGET_64BIT") (V4HF "TARGET_64BIT")
+    (V2SI "TARGET_64BIT") (V2SF "TARGET_64BIT")])
+
 ;; V2S* modes
 (define_mode_iterator V2FI [V2SF V2SI])

@@ -331,6 +337,37 @@ (define_insn "*mov<mode>_internal"
 	   ]
 	   (symbol_ref "true")))])

+;; 16-bit, 32-bit and 64-bit constant vector stores.  After reload,
+;; convert them to immediate integer stores.
+(define_insn_and_split "*mov<mode>_imm"
+  [(set (match_operand:V_16_32_64 0 "memory_operand" "=m")
+	(match_operand:V_16_32_64 1 "x86_64_const_vector_operand" "i"))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 0) (match_dup 1))]
+{
+  HOST_WIDE_INT val = ix86_convert_const_vector_to_integer (operands[1],
+							    <MODE>mode);
+  operands[1] = GEN_INT (val);
+  machine_mode mode;
+  switch (GET_MODE_SIZE (<MODE>mode))
+    {
+    case 2:
+      mode = HImode;
+      break;
+    case 4:
+      mode = SImode;
+      break;
+    case 8:
+      mode = DImode;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  operands[0] = lowpart_subreg (mode, operands[0], <MODE>mode);
+})
+
 ;; For TARGET_64BIT we always round up to 8 bytes.
 (define_insn "*push<mode>2_rex64"
   [(set (match_operand:V_32 0 "push_operand" "=X,X")
diff --git a/gcc/config/i386/predicates.md b/gcc/config/i386/predicates.md
index 128144f1050..c71c453cceb 100644
--- a/gcc/config/i386/predicates.md
+++ b/gcc/config/i386/predicates.md
@@ -1194,6 +1194,17 @@ (define_predicate "reg_or_const_vector_operand"
   (ior (match_operand 0 "register_operand")
        (match_code "const_vector")))

+;; Return true when OP is CONST_VECTOR which can be converted to a
+;; sign extended 32-bit integer.
+(define_predicate "x86_64_const_vector_operand"
+  (match_code "const_vector")
+{
+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+    return false;
+  HOST_WIDE_INT val = ix86_convert_const_vector_to_integer (op, mode);
+  return trunc_int_for_mode (val, SImode) == val;
+})
+
 ;; Return true when OP is nonimmediate or standard SSE constant.
 (define_predicate "nonimmediate_or_sse_const_operand"
   (ior (match_operand 0 "nonimmediate_operand")
diff --git a/gcc/testsuite/gcc.target/i386/pr106022-1.c b/gcc/testsuite/gcc.target/i386/pr106022-1.c
new file mode 100644
index 00000000000..6643b4c30f1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr106022-1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=x86-64" } */
+
+void
+foo (char *c)
+{
+  c[0] = 0;
+  c[1] = 1;
+  c[2] = 2;
+  c[3] = 3;
+}
+
+/* { dg-final { scan-assembler-times "movl\[ \\t\]+\\\$50462976," 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr106022-2.c b/gcc/testsuite/gcc.target/i386/pr106022-2.c
new file mode 100644
index 00000000000..0e79fb53297
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr106022-2.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=x86-64" } */
+
+void
+foo (int *c)
+{
+  c = __builtin_assume_aligned (c, 16);
+  c[0] = -1;
+  c[1] = -1;
+}
+
+/* { dg-final { scan-assembler-times "movq\[ \\t\]+\[^\n\]*%xmm" 2 { target { ia32 } } } } */
+/* { dg-final { scan-assembler-times "movq\[ \\t\]+\\\$-1," 1 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-not "xmm" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr106022-3.c b/gcc/testsuite/gcc.target/i386/pr106022-3.c
new file mode 100644
index 00000000000..8b0c2a8f6d8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr106022-3.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=x86-64" } */
+
+void
+foo (int *c)
+{
+  c[0] = 0;
+  c[1] = 1;
+  c[2] = 2;
+  c[3] = 3;
+}
+
+/* { dg-final { scan-assembler-times "movdqa\[ \\t\]+\[^\n\]*%xmm" 1 } } */
+/* { dg-final { scan-assembler-times "movups\[ \\t\]+\[^\n\]*%xmm" 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr106022-4.c b/gcc/testsuite/gcc.target/i386/pr106022-4.c
new file mode 100644
index 00000000000..8ecda170af3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr106022-4.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=x86-64" } */
+
+void
+foo (float *c)
+{
+  c[0] = 2.3;
+  c[1] = 0.0;
+}
+
+/* { dg-final { scan-assembler-times "movl\[ \\t\]+\\\$0x40133333" 1 { target { ia32 } } } } */
+/* { dg-final { scan-assembler-times "movl\[ \\t\]+\\\$0x00000000" 1 { target { ia32 } } } } */
+/* { dg-final { scan-assembler-times "movq\[ \\t\]+\\\$1075000115," 1 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-not "xmm" } } */
--
2.36.1

From 842ab824d565d5ab823bb6da55ad7adb36f87bf3 Mon Sep 17 00:00:00 2001
From: Haochen Jiang <haochen.jiang@intel.com>
Date: Mon, 30 May 2022 17:12:31 +0800
Subject: [PATCH] i386: Extend cvtps2pd to memory

gcc/ChangeLog:

	PR target/43618
	* config/i386/sse.md (extendv2sfv2df2): New define_expand.
	(sse2_cvtps2pd_<mask_name>): Change constraint of operands[1].
	(*sse2_cvtps2pd_<mask_name>_1): Rename from extendvsdfv2df2.

gcc/testsuite/ChangeLog:

	PR target/43618
	* gcc.target/i386/pr43618-1.c: New test.
---
 gcc/config/i386/sse.md                    | 26 ++++++++++++++++++-----
 gcc/testsuite/gcc.target/i386/pr43618-1.c | 12 +++++++++++
 2 files changed, 33 insertions(+), 5 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/i386/pr43618-1.c

diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 8b2602bfa79..742bb6c222c 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -9175,11 +9175,27 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])

+(define_expand "extendv2sfv2df2"
+  [(set (match_operand:V2DF 0 "register_operand")
+	(float_extend:V2DF
+	  (match_operand:V2SF 1 "nonimmediate_operand")))]
+  "TARGET_MMX_WITH_SSE"
+{
+  if (!MEM_P (operands[1]))
+    {
+      operands[1] = lowpart_subreg (V4SFmode,
+				    force_reg (V2SFmode, operands[1]),
+				    V2SFmode);
+      emit_insn (gen_sse2_cvtps2pd (operands[0], operands[1]));
+      DONE;
+    }
+})
+
 (define_insn "sse2_cvtps2pd<mask_name>"
   [(set (match_operand:V2DF 0 "register_operand" "=v")
 	(float_extend:V2DF
 	  (vec_select:V2SF
-	    (match_operand:V4SF 1 "vector_operand" "vm")
+	    (match_operand:V4SF 1 "register_operand" "v")
 	    (parallel [(const_int 0) (const_int 1)]))))]
   "TARGET_SSE2 && <mask_avx512vl_condition>"
   "%vcvtps2pd\t{%1, %0<mask_operand2>|%0<mask_operand2>, %q1}"
@@ -9191,12 +9207,12 @@
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V2DF")])

-(define_insn "extendv2sfv2df2"
+(define_insn "*sse2_cvtps2pd<mask_name>_1"
   [(set (match_operand:V2DF 0 "register_operand" "=v")
 	(float_extend:V2DF
-	  (match_operand:V2SF 1 "register_operand" "v")))]
-  "TARGET_MMX_WITH_SSE"
-  "%vcvtps2pd\t{%1, %0|%0, %1}"
+	  (match_operand:V2SF 1 "memory_operand" "m")))]
+  "TARGET_SSE2 && <mask_avx512vl_condition>"
+  "%vcvtps2pd\t{%1, %0<mask_operand2>|%0<mask_operand2>, %q1}"
   [(set_attr "type" "ssecvt")
    (set_attr "amdfam10_decode" "direct")
    (set_attr "athlon_decode" "double")
diff --git a/gcc/testsuite/gcc.target/i386/pr43618-1.c b/gcc/testsuite/gcc.target/i386/pr43618-1.c
new file mode 100644
index 00000000000..7d16f0e0cf9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr43618-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "movq" } } */
+/* { dg-final { scan-assembler "cvtps2pd" } } */
+
+void
+foo (float a[2], double b[2])
+{
+    int i;
+    for (i = 0; i < 2; i++)
+      b[i] = a[i];
+}
--
2.18.1

diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 3396ff748da..5b91c7be54e 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -9208,7 +9208,7 @@
    (set_attr "prefix" "maybe_vex")
    (set_attr "mode" "V2DF")])

-(define_insn "*sse2_cvtps2pd<mask_name>_1"
+(define_insn "sse2_cvtps2pd<mask_name>_1"
   [(set (match_operand:V2DF 0 "register_operand" "=v")
 	(float_extend:V2DF
 	  (match_operand:V2SF 1 "memory_operand" "m")))]
@@ -9270,7 +9270,15 @@
 	  (vec_select:V2SF
 	    (match_operand:V4SF 1 "vector_operand")
 	    (parallel [(const_int 0) (const_int 1)]))))]
-  "TARGET_SSE2")
+  "TARGET_SSE2"
+{
+  if (MEM_P (operands[1]))
+    {
+      operands[1] = adjust_address_nv (operands[1], V2SFmode, 0);
+      emit_insn (gen_sse2_cvtps2pd_1 (operands[0], operands[1]));
+      DONE;
+    }
+})

 (define_expand "vec_unpacks_lo_v8sf"
   [(set (match_operand:V4DF 0 "register_operand")
diff --git a/gcc/testsuite/g++.target/i386/pr106180-1.C b/gcc/testsuite/g++.target/i386/pr106180-1.C
new file mode 100644
index 00000000000..7f734536001
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr106180-1.C
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -c -ffloat-store  -std=c++11" } */
+
+struct PointT
+{
+  double x, y;
+};
+using PointF = PointT;
+
+template <int _Nm> struct __array_traits { typedef PointT _Type[_Nm]; };
+template <int _Nm> struct array
+{
+  typename __array_traits<_Nm>::_Type _M_elems;
+};
+
+float SampleGrid_low, SampleGrid_high;
+using QuadrilateralF = array<4>;
+struct PerspectiveTransform
+{
+  PerspectiveTransform (QuadrilateralF, QuadrilateralF);
+};
+
+void SampleGrid()
+{
+  PerspectiveTransform
+  {
+    { PointF {SampleGrid_high, SampleGrid_low},
+      SampleGrid_low, SampleGrid_high },
+    {}
+  };
+}
--
2.18.2

The target optimize pragma path to initialize extra target specific
builtins missed handling of the pure_p flag which in turn causes
extra clobber side-effects of gather builtins leading to unexpected
issues downhill.

Bootstrap and regtest running on x86_64-unknown-linux-gnu, will push
as obvious if that succeeds.

	* config/i386/i386-builtins.cc (ix86_add_new_builtins): Properly
	set DECL_PURE_P.

	* g++.dg/pr106219.C: New testcase.
---
 gcc/config/i386/i386-builtins.cc |  2 ++
 gcc/testsuite/g++.dg/pr106219.C  | 31 +++++++++++++++++++++++++++++++
 2 files changed, 33 insertions(+)
 create mode 100644 gcc/testsuite/g++.dg/pr106219.C

diff --git a/gcc/config/i386/i386-builtins.cc b/gcc/config/i386/i386-builtins.cc
index 96743e6122d..fe7243c3837 100644
--- a/gcc/config/i386/i386-builtins.cc
+++ b/gcc/config/i386/i386-builtins.cc
@@ -385,6 +385,8 @@ ix86_add_new_builtins (HOST_WIDE_INT isa, HOST_WIDE_INT isa2)
 	  ix86_builtins[i] = decl;
 	  if (ix86_builtins_isa[i].const_p)
 	    TREE_READONLY (decl) = 1;
+	  if (ix86_builtins_isa[i].pure_p)
+	    DECL_PURE_P (decl) = 1;
 	}
     }

diff --git a/gcc/testsuite/g++.dg/pr106219.C b/gcc/testsuite/g++.dg/pr106219.C
new file mode 100644
index 00000000000..3cad1507d5f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr106219.C
@@ -0,0 +1,31 @@
+// { dg-do compile }
+// { dg-options "-O3" }
+// { dg-additional-options "-march=bdver2" { target x86_64-*-* } }
+
+int max(int __b) {
+  if (0 < __b)
+    return __b;
+  return 0;
+}
+struct Plane {
+  Plane(int, int);
+  int *Row();
+};
+#ifdef __x86_64__
+#pragma GCC target "sse2,ssse3,avx,avx2"
+#endif
+float *ConvolveXSampleAndTranspose_rowp;
+int ConvolveXSampleAndTranspose_res, ConvolveXSampleAndTranspose_r;
+void ConvolveXSampleAndTranspose() {
+  Plane out(0, ConvolveXSampleAndTranspose_res);
+  for (int y;;) {
+    float sum;
+    for (int i = ConvolveXSampleAndTranspose_r; i; ++i)
+      sum += i;
+    for (; ConvolveXSampleAndTranspose_r; ++ConvolveXSampleAndTranspose_r)
+      sum +=
+          ConvolveXSampleAndTranspose_rowp[max(ConvolveXSampleAndTranspose_r)] *
+          ConvolveXSampleAndTranspose_r;
+    out.Row()[y] = sum;
+  }
+}
--
2.35.3

diff --git a/gcc/ipa-visibility.cc b/gcc/ipa-visibility.cc
index 8a27e7bcd..3ed2b7cf6 100644
--- a/gcc/ipa-visibility.cc
+++ b/gcc/ipa-visibility.cc
@@ -873,6 +873,25 @@ function_and_variable_visibility (bool whole_program)
 	}
     }

+  if (symtab->state >= IPA_SSA)
+    {
+      FOR_EACH_VARIABLE (vnode)
+	{
+	  tree decl = vnode->decl;
+
+	  /* Upgrade TLS access model based on optimized visibility status,
+	     unless it was specified explicitly or no references remain.  */
+	  if (DECL_THREAD_LOCAL_P (decl)
+	      && !lookup_attribute ("tls_model", DECL_ATTRIBUTES (decl))
+	      && vnode->ref_list.referring.length ())
+	    {
+	      enum tls_model new_model = decl_default_tls_model (decl);
+	      gcc_checking_assert (new_model >= decl_tls_model (decl));
+	      set_decl_tls_model (decl, new_model);
+	    }
+	}
+    }
+
   if (dump_file)
     {
       fprintf (dump_file, "\nMarking local functions:");
diff --git a/gcc/varasm.cc b/gcc/varasm.cc
index 4db8506b1..de149e82c 100644
--- a/gcc/varasm.cc
+++ b/gcc/varasm.cc
@@ -6679,6 +6679,36 @@ init_varasm_once (void)
 #endif
 }

+/* Determine whether SYMBOL is used in any optimized function.  */
+
+static bool
+have_optimized_refs (struct symtab_node *symbol)
+{
+  struct ipa_ref *ref;
+
+  for (int i = 0; symbol->iterate_referring (i, ref); i++)
+    {
+      cgraph_node *cnode = dyn_cast <cgraph_node *> (ref->referring);
+
+      if (cnode && opt_for_fn (cnode->decl, optimize))
+	return true;
+    }
+
+  return false;
+}
+
+/* Check if promoting general-dynamic TLS access model to local-dynamic is
+   desirable for DECL.  */
+
+static bool
+optimize_dyn_tls_for_decl_p (const_tree decl)
+{
+  if (optimize)
+    return true;
+  return symtab->state >= IPA && have_optimized_refs (symtab_node::get (decl));
+}
+
+
 enum tls_model
 decl_default_tls_model (const_tree decl)
 {
@@ -6696,7 +6726,7 @@ decl_default_tls_model (const_tree decl)

   /* Local dynamic is inefficient when we're not combining the
      parts of the address.  */
-  else if (optimize && is_local)
+  else if (is_local && optimize_dyn_tls_for_decl_p (decl))
     kind = TLS_MODEL_LOCAL_DYNAMIC;
   else
     kind = TLS_MODEL_GLOBAL_DYNAMIC;
diff --git a/gcc/testsuite/gcc.dg/tls/vis-attr-gd.c b/gcc/testsuite/gcc.dg/tls/vis-attr-gd.c
new file mode 100644
index 000000000..89a248a80
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-attr-gd.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program" } */
+
+// tls_model should be global-dynamic due to explicitly specified attribute
+__attribute__((tls_model("global-dynamic")))
+__thread int x;
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-global-dynamic" "whole-program" } } */
diff --git a/gcc/testsuite/gcc.dg/tls/vis-attr-hidden-gd.c b/gcc/testsuite/gcc.dg/tls/vis-attr-hidden-gd.c
new file mode 100644
index 000000000..e32565588
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-attr-hidden-gd.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program" } */
+
+// tls_model should be global-dynamic due to explicitly specified attribute
+__attribute__((visibility("hidden")))
+__attribute__((tls_model("global-dynamic")))
+__thread int x;
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-global-dynamic" "whole-program" } } */
diff --git a/gcc/testsuite/gcc.dg/tls/vis-attr-hidden.c b/gcc/testsuite/gcc.dg/tls/vis-attr-hidden.c
new file mode 100644
index 000000000..0d43fc565
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-attr-hidden.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program" } */
+
+//tls_model should be local-dynamic due to visibility("hidden")
+__attribute__((visibility("hidden")))
+__thread int x;
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-local-dynamic" "whole-program" } } */
diff --git a/gcc/testsuite/gcc.dg/tls/vis-flag-hidden-gd.c b/gcc/testsuite/gcc.dg/tls/vis-flag-hidden-gd.c
new file mode 100644
index 000000000..cad41e0c8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-flag-hidden-gd.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program -fvisibility=hidden" } */
+
+
+// tls_model should be global-dynamic due to explicitly specified attribute
+__attribute__((tls_model("global-dynamic")))
+__thread int x;
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-global-dynamic" "whole-program" } } */
diff --git a/gcc/testsuite/gcc.dg/tls/vis-flag-hidden.c b/gcc/testsuite/gcc.dg/tls/vis-flag-hidden.c
new file mode 100644
index 000000000..a15df092d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-flag-hidden.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program -fvisibility=hidden" } */
+
+
+// tls_model should be local-dynamic due to -fvisibility=hidden
+__thread int x;
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-local-dynamic" "whole-program" } } */
diff --git a/gcc/testsuite/gcc.dg/tls/vis-pragma-hidden-gd.c b/gcc/testsuite/gcc.dg/tls/vis-pragma-hidden-gd.c
new file mode 100644
index 000000000..3b3598134
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-pragma-hidden-gd.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program" } */
+
+
+#pragma GCC visibility push(hidden)
+
+// tls_model should be global-dynamic due to explicitly specified attribute
+__attribute__((tls_model("global-dynamic")))
+__thread int x;
+
+#pragma GCC visibility pop
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-global-dynamic" "whole-program" } } */
diff --git a/gcc/testsuite/gcc.dg/tls/vis-pragma-hidden.c b/gcc/testsuite/gcc.dg/tls/vis-pragma-hidden.c
new file mode 100644
index 000000000..1be976442
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/vis-pragma-hidden.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target tls } */
+/* { dg-options "-O2 -fPIC -fdump-ipa-whole-program" } */
+
+
+#pragma GCC visibility push(hidden)
+
+// tls_model should be local-dynamic due to a pragma
+__thread int x;
+
+#pragma GCC visibility pop
+
+void reference() { x++; }
+
+/* { dg-final { scan-ipa-dump "Varpool flags: tls-local-dynamic" "whole-program" } } */
--
2.35.1

This patch allows for strchr(x, c) to the replace with memchr(x, c,
strlen(x) + 1) if strlen(x) has already been computed earlier in the
tree.

Handles PR95821: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95821

Since memchr doesn't need to re-find the null terminator it is faster
than strchr.

bootstrapped and tested on x86_64-linux.

	PR tree-optimization/95821

gcc/

	* tree-ssa-strlen.cc (strlen_pass::handle_builtin_strchr): Emit
	memchr instead of strchr if strlen already computed.

gcc/testsuite/

	* c-c++-common/pr95821-1.c: New test.
	* c-c++-common/pr95821-2.c: New test.
	* c-c++-common/pr95821-3.c: New test.
	* c-c++-common/pr95821-4.c: New test.
	* c-c++-common/pr95821-5.c: New test.
	* c-c++-common/pr95821-6.c: New test.
	* c-c++-common/pr95821-7.c: New test.
	* c-c++-common/pr95821-8.c: New test.
---
 gcc/testsuite/c-c++-common/pr95821-1.c |  15 ++++
 gcc/testsuite/c-c++-common/pr95821-2.c |  17 ++++
 gcc/testsuite/c-c++-common/pr95821-3.c |  17 ++++
 gcc/testsuite/c-c++-common/pr95821-4.c |  16 ++++
 gcc/testsuite/c-c++-common/pr95821-5.c |  19 +++++
 gcc/testsuite/c-c++-common/pr95821-6.c |  18 ++++
 gcc/testsuite/c-c++-common/pr95821-7.c |  18 ++++
 gcc/testsuite/c-c++-common/pr95821-8.c |  19 +++++
 gcc/tree-ssa-strlen.cc                 | 113 ++++++++++++++++++++-----
 9 files changed, 233 insertions(+), 19 deletions(-)
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-1.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-2.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-3.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-4.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-5.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-6.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-7.c
 create mode 100644 gcc/testsuite/c-c++-common/pr95821-8.c

diff --git a/gcc/testsuite/c-c++-common/pr95821-1.c b/gcc/testsuite/c-c++-common/pr95821-1.c
new file mode 100644
index 00000000000..e0beb609ea2
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-1.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "memchr" } } */
+
+#include <stddef.h>
+
+char *
+foo (char *s, char c)
+{
+	size_t slen = __builtin_strlen(s);
+	if(slen < 1000)
+		return NULL;
+
+	return __builtin_strchr(s, c);
+}
diff --git a/gcc/testsuite/c-c++-common/pr95821-2.c b/gcc/testsuite/c-c++-common/pr95821-2.c
new file mode 100644
index 00000000000..5429f0586be
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-2.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "memchr" } } */
+
+#include <stddef.h>
+
+char *
+foo (char *s, char c, char * other)
+{
+	size_t slen = __builtin_strlen(s);
+	if(slen < 1000)
+		return NULL;
+
+	*other = 0;
+
+	return __builtin_strchr(s, c);
+}
diff --git a/gcc/testsuite/c-c++-common/pr95821-3.c b/gcc/testsuite/c-c++-common/pr95821-3.c
new file mode 100644
index 00000000000..bc929c6044b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-3.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "memchr" } } */
+
+#include <stddef.h>
+
+char *
+foo (char * __restrict s, char c, char * __restrict other)
+{
+	size_t slen = __builtin_strlen(s);
+	if(slen < 1000)
+		return NULL;
+
+	*other = 0;
+
+	return __builtin_strchr(s, c);
+}
diff --git a/gcc/testsuite/c-c++-common/pr95821-4.c b/gcc/testsuite/c-c++-common/pr95821-4.c
new file mode 100644
index 00000000000..684b41d5b70
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-4.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "memchr" } } */
+
+#include <stddef.h>
+#include <string.h>
+
+char *
+foo (char *s, char c)
+{
+	size_t slen = strlen(s);
+	if(slen < 1000)
+		return NULL;
+
+	return strchr(s, c);
+}
diff --git a/gcc/testsuite/c-c++-common/pr95821-5.c b/gcc/testsuite/c-c++-common/pr95821-5.c
new file mode 100644
index 00000000000..00c1d93b614
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-5.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "memchr" } } */
+
+#include <stddef.h>
+#include <string.h>
+
+char *
+foo (char *s, char c, char * other)
+{
+	size_t slen = strlen(s);
+	if(slen < 1000)
+		return NULL;
+
+	*other = 0;
+
+	return strchr(s, c);
+}
+int main() {}
diff --git a/gcc/testsuite/c-c++-common/pr95821-6.c b/gcc/testsuite/c-c++-common/pr95821-6.c
new file mode 100644
index 00000000000..dec839de5ea
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-6.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "memchr" } } */
+
+#include <stddef.h>
+#include <string.h>
+
+char *
+foo (char * __restrict s, char c, char * __restrict other)
+{
+	size_t slen = strlen(s);
+	if(slen < 1000)
+		return NULL;
+
+	*other = 0;
+
+	return strchr(s, c);
+}
diff --git a/gcc/testsuite/c-c++-common/pr95821-7.c b/gcc/testsuite/c-c++-common/pr95821-7.c
new file mode 100644
index 00000000000..9da0fff7250
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-7.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler "memchr" } } */
+
+#include <stddef.h>
+#include <string.h>
+
+char *
+foo (char * __restrict s, char c, char * __restrict other)
+{
+	size_t slen = strlen(s);
+	if(slen < 1000 || c == 0)
+		return NULL;
+
+	*other = 0;
+
+	return strchr(s, c);
+}
diff --git a/gcc/testsuite/c-c++-common/pr95821-8.c b/gcc/testsuite/c-c++-common/pr95821-8.c
new file mode 100644
index 00000000000..5eb02c6fea4
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr95821-8.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "strchr" } } */
+/* { dg-final { scan-assembler-not "memchr" } } */
+
+#include <stddef.h>
+#include <string.h>
+
+char *
+foo (char * __restrict s, int c, char * __restrict other)
+{
+	size_t slen = strlen(s);
+	if(slen < 1000 || c != 0x100)
+		return NULL;
+
+	*other = 0;
+
+	return strchr(s, c);
+}
diff --git a/gcc/tree-ssa-strlen.cc b/gcc/tree-ssa-strlen.cc
index 1d4c0f78fbf..3c26ea7eb83 100644
--- a/gcc/tree-ssa-strlen.cc
+++ b/gcc/tree-ssa-strlen.cc
@@ -2405,9 +2405,12 @@ strlen_pass::handle_builtin_strlen ()
     }
 }

-/* Handle a strchr call.  If strlen of the first argument is known, replace
-   the strchr (x, 0) call with the endptr or x + strlen, otherwise remember
-   that lhs of the call is endptr and strlen of the argument is endptr - x.  */
+/* Handle a strchr call.  If strlen of the first argument is known,
+   replace the strchr (x, 0) call with the endptr or x + strlen,
+   otherwise remember that lhs of the call is endptr and strlen of the
+   argument is endptr - x.  If strlen of x is not know but has been
+   computed earlier in the tree then replace strchr (x, c) to
+   memchr (x, c, strlen + 1).  */

 void
 strlen_pass::handle_builtin_strchr ()
@@ -2418,8 +2421,12 @@ strlen_pass::handle_builtin_strchr ()
   if (lhs == NULL_TREE)
     return;

-  if (!integer_zerop (gimple_call_arg (stmt, 1)))
-    return;
+  tree chr = gimple_call_arg (stmt, 1);
+  /* strchr only uses the lower char of input so to check if its
+     strchr (s, zerop) only take into account the lower char.  */
+  bool is_strchr_zerop
+    = (TREE_CODE (chr) == INTEGER_CST
+       && integer_zerop (fold_convert (char_type_node, chr)));

   tree src = gimple_call_arg (stmt, 0);

@@ -2452,32 +2459,96 @@ strlen_pass::handle_builtin_strchr ()
 	      fprintf (dump_file, "Optimizing: ");
 	      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
 	    }
-	  if (si != NULL && si->endptr != NULL_TREE)
+	  /* Three potential optimizations assume t=strlen (s) has already been
+	     computed:
+	        1. strchr (s, chr) where chr is known to be zero -> t
+	        2. strchr (s, chr) where chr is known not to be zero ->
+	           memchr (s, chr, t)
+	        3. strchr (s, chr) where chr is not known to be zero or
+	           non-zero -> memchr (s, chr, t + 1).  */
+	  if (!is_strchr_zerop)
 	    {
-	      rhs = unshare_expr (si->endptr);
-	      if (!useless_type_conversion_p (TREE_TYPE (lhs),
-					      TREE_TYPE (rhs)))
-		rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);
+	      /* If its not strchr (s, zerop) then try and convert to
+	         memchr since strlen has already been computed.  */
+	      tree fn = builtin_decl_explicit (BUILT_IN_MEMCHR);
+
+	      /* Only need to check length strlen (s) + 1 if chr may be zero.
+	         Otherwise the last chr (which is known to be zero) can never
+	         be a match.  */
+	      bool chr_nonzero = false;
+	      if (TREE_CODE (chr) == INTEGER_CST
+		  && integer_nonzerop (fold_convert (char_type_node, chr)))
+		chr_nonzero = true;
+	      else if (TREE_CODE (chr) == SSA_NAME
+		       && CHAR_TYPE_SIZE < INT_TYPE_SIZE)
+		{
+		  value_range r;
+		  /* Try to determine using ranges if (char) chr must
+		     be always 0.  That is true e.g. if all the subranges
+		     have the INT_TYPE_SIZE - CHAR_TYPE_SIZE bits
+		     the same on lower and upper bounds.  */
+		  if (get_range_query (cfun)->range_of_expr (r, chr, stmt)
+		      && r.kind () == VR_RANGE)
+		    {
+		      wide_int mask
+			  = wi::mask (CHAR_TYPE_SIZE, true, INT_TYPE_SIZE);
+		      for (unsigned i = 0; i < r.num_pairs (); ++i)
+			if ((r.lower_bound (i) & mask)
+			    != (r.upper_bound (i) & mask))
+			  {
+			    chr_nonzero = false;
+			    break;
+			  }
+		    }
+		}
+	      if (!chr_nonzero)
+		{
+		  tree one = build_int_cst (TREE_TYPE (rhs), 1);
+		  rhs = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (rhs),
+					 unshare_expr (rhs), one);
+		  tree size = make_ssa_name (TREE_TYPE (rhs));
+		  gassign *size_stmt = gimple_build_assign (size, rhs);
+		  gsi_insert_before (&m_gsi, size_stmt, GSI_SAME_STMT);
+		  rhs = size;
+		}
+	      if (!update_gimple_call (&m_gsi, fn, 3, src, chr, rhs))
+		return;
 	    }
 	  else
 	    {
-	      rhs = fold_convert_loc (loc, sizetype, unshare_expr (rhs));
-	      rhs = fold_build2_loc (loc, POINTER_PLUS_EXPR,
-				     TREE_TYPE (src), src, rhs);
-	      if (!useless_type_conversion_p (TREE_TYPE (lhs),
-					      TREE_TYPE (rhs)))
-		rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);
+	      if (si != NULL && si->endptr != NULL_TREE)
+		{
+		  rhs = unshare_expr (si->endptr);
+		  if (!useless_type_conversion_p (TREE_TYPE (lhs),
+						  TREE_TYPE (rhs)))
+		    rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);
+		}
+	      else
+		{
+		  rhs = fold_convert_loc (loc, sizetype, unshare_expr (rhs));
+		  rhs = fold_build2_loc (loc, POINTER_PLUS_EXPR,
+					 TREE_TYPE (src), src, rhs);
+		  if (!useless_type_conversion_p (TREE_TYPE (lhs),
+						  TREE_TYPE (rhs)))
+		    rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);
+		}
+	      gimplify_and_update_call_from_tree (&m_gsi, rhs);
 	    }
-	  gimplify_and_update_call_from_tree (&m_gsi, rhs);
+
 	  stmt = gsi_stmt (m_gsi);
 	  update_stmt (stmt);
+
 	  if (dump_file && (dump_flags & TDF_DETAILS) != 0)
 	    {
 	      fprintf (dump_file, "into: ");
 	      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
 	    }
-	  if (si != NULL
-	      && si->endptr == NULL_TREE
+
+	  /* Don't update strlen of lhs if search-char wasn't know to be zero.  */
+	  if (!is_strchr_zerop)
+	    return;
+
+	  if (si != NULL && si->endptr == NULL_TREE
 	      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))
 	    {
 	      si = unshare_strinfo (si);
@@ -2487,6 +2558,10 @@ strlen_pass::handle_builtin_strchr ()
 	  return;
 	}
     }
+
+  if (!is_strchr_zerop)
+    return;
+
   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))
     return;
   if (TREE_CODE (src) != SSA_NAME || !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (src))
--
2.34.1

diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index f9c06ff..33473c6 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -10401,6 +10401,40 @@
   [(set_attr "type" "bitmanip")
    (set_attr "btver2_decode" "direct, double")
    (set_attr "mode" "<MODE>")])
+
+;; Split *andnsi_1 after reload with -Oz when not;and is shorter.
+(define_split
+  [(set (match_operand:SI 0 "register_operand")
+	(and:SI (not:SI (match_operand:SI 1 "register_operand"))
+		(match_operand:SI 2 "nonimmediate_operand")))
+   (clobber (reg:CC FLAGS_REG))]
+  "reload_completed
+   && optimize_insn_for_size_p () && optimize_size > 1
+   && REGNO (operands[0]) == REGNO (operands[1])
+   && LEGACY_INT_REG_P (operands[0])
+   && !REX_INT_REG_P (operands[2])
+   && !reg_overlap_mentioned_p (operands[0], operands[2])"
+  [(set (match_dup 0) (not:SI (match_dup 1)))
+   (parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 2)))
+	      (clobber (reg:CC FLAGS_REG))])])
+
+;; Split *andn_si_ccno with -Oz when not;test is shorter.
+(define_split
+  [(set (match_operand 0 "flags_reg_operand")
+	(match_operator 1 "compare_operator"
+	  [(and:SI (not:SI (match_operand:SI 2 "general_reg_operand"))
+		   (match_operand:SI 3 "nonimmediate_operand"))
+	   (const_int 0)]))
+   (clobber (match_dup 2))]
+  "reload_completed
+   && optimize_insn_for_size_p () && optimize_size > 1
+   && LEGACY_INT_REG_P (operands[2])
+   && !REX_INT_REG_P (operands[3])
+   && !reg_overlap_mentioned_p (operands[2], operands[3])"
+  [(set (match_dup 2) (not:SI (match_dup 2)))
+   (set (match_dup 0) (match_op_dup 1
+                        [(and:SI (match_dup 3) (match_dup 2))
+			 (const_int 0)]))])

 ;; Logical inclusive and exclusive OR instructions

diff --git a/gcc/testsuite/gcc.target/i386/bmi-andn-3.c b/gcc/testsuite/gcc.target/i386/bmi-andn-3.c
new file mode 100644
index 0000000..16993a3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/bmi-andn-3.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-Oz -mbmi" } */
+int m;
+
+int foo(int x, int y)
+{
+  return (x & ~y) != 0;
+}
+
+int bar(int x)
+{
+  return (~x & m) != 0;
+}
+/* { dg-final { scan-assembler-not "andn\[ \\t\]+" } } */
+

This patch builds upon Richard Biener's suggestion of avoiding global
variables to track state/identify which passes have already been run.
In the early middle-end, the tree-ssa passes use the curr_properties
field in cfun to track this.  This patch uses a new rtl_pass_progress
int field in crtl to do something similar.
2022-07-10  Roger Sayle  <roger@nextmovesoftware.com>

diff --git a/gcc/bb-reorder.cc b/gcc/bb-reorder.cc
index 5cd4825..1c1cbae 100644
--- a/gcc/bb-reorder.cc
+++ b/gcc/bb-reorder.cc
@@ -2570,7 +2570,7 @@ reorder_basic_blocks (void)

   /* Signal that rtl_verify_flow_info_1 can now verify that there
      is at most one switch between hot/cold sections.  */
-  crtl->bb_reorder_complete = true;
+  crtl->rtl_pass_progress |= PROGRESS_bb_reorder_complete;
 }

 /* Determine which partition the first basic block in the function
diff --git a/gcc/cfgrtl.cc b/gcc/cfgrtl.cc
index a05c338..8fe367e 100644
--- a/gcc/cfgrtl.cc
+++ b/gcc/cfgrtl.cc
@@ -1907,7 +1907,7 @@ rtl_split_edge (edge edge_in)
              an extra partition crossing in the chain, which is illegal.
              It can't go after the src, because src may have a fall-through
              to a different block.  */
-          if (crtl->bb_reorder_complete
+          if (bb_reorder_complete
               && (edge_in->flags & EDGE_CROSSING))
             {
               after = last_bb_in_partition (edge_in->src);
@@ -2444,7 +2444,7 @@ fixup_partitions (void)
       while (! bbs_to_fix.is_empty ());

       /* Fix up hot cold block grouping if needed.  */
-      if (crtl->bb_reorder_complete && current_ir_type () == IR_RTL_CFGRTL)
+      if (bb_reorder_complete && current_ir_type () == IR_RTL_CFGRTL)
 	{
 	  basic_block bb, first = NULL, second = NULL;
 	  int current_partition = BB_UNPARTITIONED;
@@ -2507,7 +2507,7 @@ verify_hot_cold_block_grouping (void)
   /* Even after bb reordering is complete, we go into cfglayout mode
      again (in compgoto). Ensure we don't call this before going back
      into linearized RTL when any layout fixes would have been committed.  */
-  if (!crtl->bb_reorder_complete
+  if (!bb_reorder_complete
       || current_ir_type () != IR_RTL_CFGRTL)
     return err;

@@ -4481,7 +4481,7 @@ cfg_layout_initialize (int flags)
      layout required moving a block from the hot to the cold
      section. This would create an illegal partitioning unless some
      manual fixup was performed.  */
-  gcc_assert (!crtl->bb_reorder_complete || !crtl->has_bb_partition);
+  gcc_assert (!bb_reorder_complete || !crtl->has_bb_partition);

   initialize_original_copy_tables ();

diff --git a/gcc/combine.cc b/gcc/combine.cc
index a5fabf3..18e2a80 100644
--- a/gcc/combine.cc
+++ b/gcc/combine.cc
@@ -14991,6 +14991,7 @@ rest_of_handle_combine (void)
     }

   regstat_free_n_sets_and_refs ();
+  crtl->rtl_pass_progress |= PROGRESS_combine_completed;
   return 0;
 }

diff --git a/gcc/config/i386/x86-tune-sched-atom.cc b/gcc/config/i386/x86-tune-sched-atom.cc
index 07d2093..9fe3933 100644
--- a/gcc/config/i386/x86-tune-sched-atom.cc
+++ b/gcc/config/i386/x86-tune-sched-atom.cc
@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl-iter.h"
 #include "regset.h"
 #include "sched-int.h"
+#include "memmodel.h"
+#include "emit-rtl.h"

 /* Try to reorder ready list to take advantage of Atom pipelined IMUL
    execution. It is applied if
diff --git a/gcc/config/i386/x86-tune-sched.cc b/gcc/config/i386/x86-tune-sched.cc
index 1ffaeef..315ce04 100644
--- a/gcc/config/i386/x86-tune-sched.cc
+++ b/gcc/config/i386/x86-tune-sched.cc
@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "insn-attr.h"
 #include "insn-opinit.h"
 #include "recog.h"
+#include "memmodel.h"
+#include "emit-rtl.h"

 /* Return the maximum number of instructions a cpu can issue.  */

diff --git a/gcc/cse.cc b/gcc/cse.cc
index b13afd4..b094a38 100644
--- a/gcc/cse.cc
+++ b/gcc/cse.cc
@@ -7533,7 +7533,7 @@ rest_of_handle_cse (void)

   /* If we are not running more CSE passes, then we are no longer
      expecting CSE to be run.  But always rerun it in a cheap mode.  */
-  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;
+  crtl->cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;

   if (tem == 2)
     {
@@ -7617,7 +7617,7 @@ rest_of_handle_cse2 (void)
   else if (tem == 1 || cse_cfg_altered)
     cse_cfg_altered |= cleanup_cfg (0);

-  cse_not_expected = 1;
+  crtl->cse_not_expected = true;
   return 0;
 }

@@ -7681,7 +7681,7 @@ rest_of_handle_cse_after_global_opts (void)
   cse_cfg_altered |= purge_all_dead_edges ();
   delete_trivially_dead_insns (get_insns (), max_reg_num ());

-  cse_not_expected = !flag_rerun_cse_after_loop;
+  crtl->cse_not_expected = !flag_rerun_cse_after_loop;

   /* If cse altered any jumps, rerun jump opts to clean things up.  */
   if (tem == 2)
diff --git a/gcc/df-problems.cc b/gcc/df-problems.cc
index 238424c..8fd0470 100644
--- a/gcc/df-problems.cc
+++ b/gcc/df-problems.cc
@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl-iter.h"
 #include "regs.h"
 #include "function-abi.h"
+#include "emit-rtl.h"

 /* Note that turning REG_DEAD_DEBUGGING on will cause
    gcc.c-torture/unsorted/dump-noaddr.c to fail because it prints
diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
index 7a58fed..8dcbb36 100644
--- a/gcc/emit-rtl.h
+++ b/gcc/emit-rtl.h
@@ -54,6 +54,16 @@ struct GTY(()) incoming_args {
   rtx internal_arg_pointer;
 };

+#define PROGRESS_combine_completed	(1 << 0)
+#define PROGRESS_lra_in_progress	(1 << 1)
+#define PROGRESS_reload_in_progress	(1 << 2)
+#define PROGRESS_reload_completed	(1 << 3)
+#define PROGRESS_epilogue_completed	(1 << 4)
+#define PROGRESS_bb_reorder_complete	(1 << 5)
+#define PROGRESS_regstack_completed	(1 << 6)
+
+#define PROGRESS_no_pseudos \
+	(PROGRESS_reload_in_progress | PROGRESS_reload_completed)

 /* Datastructures maintained for currently processed function in RTL form.  */
 struct GTY(()) rtl_data {
@@ -76,6 +86,9 @@ struct GTY(()) rtl_data {

   rtl_ssa::function_info *GTY((skip)) ssa;

+  /* Track progress of RTL passes, reload_completed etc.  */
+  int rtl_pass_progress;
+
   /* For function.cc  */

   /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is
@@ -303,9 +316,13 @@ struct GTY(()) rtl_data {
      block.  */
   bool has_bb_partition;

-  /* Nonzero if the function being compiled has completed the bb reordering
-     pass.  */
-  bool bb_reorder_complete;
+  /* If this is nonzero, we do not bother generating VOLATILE
+     around volatile memory references, and we are willing to
+     output indirect addresses.  If cse is to follow, we reject
+     indirect addresses so a useful potential cse is generated;
+     if it is used only once, instruction combination will produce
+     the same indirect address eventually.  */
+  bool cse_not_expected;

   /* Like regs_ever_live, but 1 if a reg is set or clobbered from an
      asm.  Unlike regs_ever_live, elements of this array corresponding
@@ -342,6 +359,20 @@ extern GTY(()) struct rtl_data x_rtl;
    want to do differently.  */
 #define crtl (&x_rtl)

+/* rtl_pass_progress macros.  */
+#define crtl_pass_progress (crtl->rtl_pass_progress)
+
+#define combine_completed (crtl_pass_progress & PROGRESS_combine_completed)
+#define lra_in_progress (crtl_pass_progress & PROGRESS_lra_in_progress)
+#define reload_in_progress (crtl_pass_progress & PROGRESS_reload_in_progress)
+#define reload_completed (crtl_pass_progress & PROGRESS_reload_completed)
+#define bb_reorder_complete (crtl_pass_progress & PROGRESS_bb_reorder_complete)
+#define epilogue_completed (crtl_pass_progress & PROGRESS_epilogue_completed)
+#define regstack_completed (crtl_pass_progress & PROGRESS_regstack_completed)
+
+/* This macro indicates whether you may create a new pseudo-register.  */
+#define can_create_pseudo_p() ((crtl_pass_progress & PROGRESS_no_pseudos) == 0)
+
 /* Return whether two MEM_ATTRs are equal.  */
 bool mem_attrs_eq_p (const class mem_attrs *, const class mem_attrs *);

diff --git a/gcc/explow.cc b/gcc/explow.cc
index ddb4d6ae..9fbeea7 100644
--- a/gcc/explow.cc
+++ b/gcc/explow.cc
@@ -439,7 +439,7 @@ memory_address_addr_space (machine_mode mode, rtx x, addr_space_t as)

   /* By passing constant addresses through registers
      we get a chance to cse them.  */
-  if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))
+  if (! crtl->cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))
     x = force_reg (address_mode, x);

   /* We get better cse by rejecting indirect addressing at this stage.
@@ -448,7 +448,7 @@ memory_address_addr_space (machine_mode mode, rtx x, addr_space_t as)
      are visible.  But not if cse won't be done!  */
   else
     {
-      if (! cse_not_expected && !REG_P (x))
+      if (! crtl->cse_not_expected && !REG_P (x))
 	x = break_out_memory_refs (x);

       /* At this point, any valid address is accepted.  */
@@ -603,7 +603,7 @@ use_anchored_address (rtx x)
      We will then be able to reuse registers for several accesses, if the
      target costs say that that's worthwhile.  */
   mode = GET_MODE (base);
-  if (!cse_not_expected)
+  if (!crtl->cse_not_expected)
     base = force_reg (mode, base);

   return replace_equiv_address (x, plus_constant (mode, base, offset));
diff --git a/gcc/final.cc b/gcc/final.cc
index 0352786..5ee812e 100644
--- a/gcc/final.cc
+++ b/gcc/final.cc
@@ -4511,11 +4511,7 @@ rest_of_clean_state (void)
     }

   flag_rerun_cse_after_global_opts = 0;
-  reload_completed = 0;
-  epilogue_completed = 0;
-#ifdef STACK_REGS
-  regstack_completed = 0;
-#endif
+  crtl->rtl_pass_progress = 0;

   /* Clear out the insn_length contents now that they are no
      longer valid.  */
diff --git a/gcc/function.cc b/gcc/function.cc
index 31256b5..349aaa3 100644
--- a/gcc/function.cc
+++ b/gcc/function.cc
@@ -4924,7 +4924,7 @@ prepare_function_start (void)
   if (flag_stack_usage_info && !flag_callgraph_info)
     allocate_stack_usage_info ();

-  cse_not_expected = ! optimize;
+  crtl->cse_not_expected = ! optimize;

   /* Caller save not needed yet.  */
   caller_save_needed = 0;
@@ -6093,7 +6093,7 @@ thread_prologue_and_epilogue_insns (void)
   /* A small fib -- epilogue is not yet completed, but we wish to re-use
      this marker for the splits of EH_RETURN patterns, and nothing else
      uses the flag in the meantime.  */
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;

   /* Find non-fallthru edges that end with EH_RETURN instructions.  On
      some targets, these get split to a special version of the epilogue
@@ -6259,7 +6259,7 @@ thread_prologue_and_epilogue_insns (void)

   /* Threading the prologue and epilogue changes the artificial refs
      in the entry and exit blocks.  */
-  epilogue_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;
   df_update_entry_exit_and_calls ();
 }

diff --git a/gcc/ifcvt.cc b/gcc/ifcvt.cc
index 2e8ab39..fd7d1ed 100644
--- a/gcc/ifcvt.cc
+++ b/gcc/ifcvt.cc
@@ -2128,7 +2128,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)
      conditional on their addresses followed by a load.  Don't do this
      early because it'll screw alias analysis.  Note that we've
      already checked for no side effects.  */
-  if (cse_not_expected
+  if (crtl->cse_not_expected
       && MEM_P (a) && MEM_P (b)
       && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b))
     {
diff --git a/gcc/lra-eliminations.cc b/gcc/lra-eliminations.cc
index c630ff4..434e4ec 100644
--- a/gcc/lra-eliminations.cc
+++ b/gcc/lra-eliminations.cc
@@ -1261,14 +1261,14 @@ init_elim_table (void)
      will cause, e.g., gen_rtx_REG (Pmode, STACK_POINTER_REGNUM) to
      equal stack_pointer_rtx.  We depend on this. Threfore we switch
      off that we are in LRA temporarily.  */
-  lra_in_progress = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_lra_in_progress;
   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)
     {
       ep->from_rtx = gen_rtx_REG (Pmode, ep->from);
       ep->to_rtx = gen_rtx_REG (Pmode, ep->to);
       eliminable_reg_rtx[ep->from] = ep->from_rtx;
     }
-  lra_in_progress = 1;
+  crtl->rtl_pass_progress |= PROGRESS_lra_in_progress;
 }

 /* Function for initialization of elimination once per function.  It
diff --git a/gcc/lra.cc b/gcc/lra.cc
index 1444cb7..ce4843f 100644
--- a/gcc/lra.cc
+++ b/gcc/lra.cc
@@ -2218,9 +2218,6 @@ update_inc_notes (void)
       }
 }

-/* Set to 1 while in lra.  */
-int lra_in_progress;
-
 /* Start of pseudo regnos before the LRA.  */
 int lra_new_regno_start;

@@ -2316,7 +2313,7 @@ lra (FILE *f)
   if (flag_checking)
     check_rtl (false);

-  lra_in_progress = 1;
+  crtl->rtl_pass_progress |= PROGRESS_lra_in_progress;

   lra_live_range_iter = lra_coalesce_iter = lra_constraint_iter = 0;
   lra_assignment_iter = lra_assignment_iter_after_spill = 0;
@@ -2508,7 +2505,7 @@ lra (FILE *f)
   ira_restore_scratches (lra_dump_file);
   lra_eliminate (true, false);
   lra_final_code_change ();
-  lra_in_progress = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_lra_in_progress;
   if (live_p)
     lra_clear_live_ranges ();
   lra_live_ranges_finish ();
@@ -2519,7 +2516,7 @@ lra (FILE *f)
   finish_insn_recog_data ();
   regstat_free_n_sets_and_refs ();
   regstat_free_ri ();
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;
   update_inc_notes ();

   inserted_p = fixup_abnormal_edges ();
diff --git a/gcc/modulo-sched.cc b/gcc/modulo-sched.cc
index 162de19..f3b15a4 100644
--- a/gcc/modulo-sched.cc
+++ b/gcc/modulo-sched.cc
@@ -1369,11 +1369,11 @@ sms_schedule (void)
   /* Initialize issue_rate.  */
   if (targetm.sched.issue_rate)
     {
-      int temp = reload_completed;
+      int temp = crtl->rtl_pass_progress;

-      reload_completed = 1;
+      crtl->rtl_pass_progress |= PROGRESS_reload_completed;
       issue_rate = targetm.sched.issue_rate ();
-      reload_completed = temp;
+      crtl->rtl_pass_progress = temp;
     }
   else
     issue_rate = 1;
diff --git a/gcc/passes.cc b/gcc/passes.cc
index 78a07f8..9a1a0d8 100644
--- a/gcc/passes.cc
+++ b/gcc/passes.cc
@@ -2541,12 +2541,12 @@ skip_pass (opt_pass *pass)
   /* Pass "reload" sets the global "reload_completed", and many
      things depend on this (e.g. instructions in .md files).  */
   if (strcmp (pass->name, "reload") == 0)
-    reload_completed = 1;
+    crtl->rtl_pass_progress |= PROGRESS_reload_completed;

   /* Similar for pass "pro_and_epilogue" and the "epilogue_completed" global
      variable.  */
   if (strcmp (pass->name, "pro_and_epilogue") == 0)
-    epilogue_completed = 1;
+    crtl->rtl_pass_progress |= PROGRESS_epilogue_completed;

   /* The INSN_ADDRESSES vec is normally set up by
      shorten_branches; set it up for the benefit of passes that
diff --git a/gcc/recog.cc b/gcc/recog.cc
index dac172b..cb1e331 100644
--- a/gcc/recog.cc
+++ b/gcc/recog.cc
@@ -85,15 +85,6 @@ static operand_alternative asm_op_alt[MAX_RECOG_OPERANDS

 int which_alternative;

-/* Nonzero after end of reload pass.
-   Set to 1 or 0 by toplev.cc.
-   Controls the significance of (SUBREG (MEM)).  */
-
-int reload_completed;
-
-/* Nonzero after thread_prologue_and_epilogue_insns has run.  */
-int epilogue_completed;
-
 /* Initialize data used by the function `recog'.
    This must be called once in the compilation of a function
    before any insn recognition may be done in the function.  */
diff --git a/gcc/reg-stack.cc b/gcc/reg-stack.cc
index fd03250..a2580f1 100644
--- a/gcc/reg-stack.cc
+++ b/gcc/reg-stack.cc
@@ -188,8 +188,6 @@ static vec<char> stack_regs_mentioned_data;

 #define REG_STACK_SIZE (LAST_STACK_REG - FIRST_STACK_REG + 1)

-int regstack_completed = 0;
-
 /* This is the basic stack record.  TOP is an index into REG[] such
    that REG[TOP] is the top of stack.  If TOP is -1 the stack is empty.

@@ -3440,7 +3438,7 @@ rest_of_handle_stack_regs (void)
 #ifdef STACK_REGS
   if (reg_to_stack ())
     df_insn_rescan_all ();
-  regstack_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_regstack_completed;
 #endif
   return 0;
 }
diff --git a/gcc/regstat.cc b/gcc/regstat.cc
index db28354..1825a4f 100644
--- a/gcc/regstat.cc
+++ b/gcc/regstat.cc
@@ -27,6 +27,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "predict.h"
 #include "df.h"
 #include "regs.h"
+#include "memmodel.h"
+#include "emit-rtl.h"


 struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;
diff --git a/gcc/reload1.cc b/gcc/reload1.cc
index 728dc2a..153315e 100644
--- a/gcc/reload1.cc
+++ b/gcc/reload1.cc
@@ -216,10 +216,6 @@ int reload_first_uid;
    a call-clobbered reg across calls.  */
 int caller_save_needed;

-/* Set to 1 while reload_as_needed is operating.
-   Required by some machines to handle any generated moves differently.  */
-int reload_in_progress = 0;
-
 /* This obstack is used for allocation of rtl during register elimination.
    The allocated storage can be freed once find_reloads has processed the
    insn.  */
@@ -877,7 +873,7 @@ reload (rtx_insn *first, int global)
   /* From now on, we may need to generate moves differently.  We may also
      allow modifications of insns which cause them to not be recognized.
      Any such modifications will be cleaned up during reload itself.  */
-  reload_in_progress = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_in_progress;

   /* This loop scans the entire function each go-round
      and repeats until one repetition spills no additional hard regs.  */
@@ -1067,7 +1063,7 @@ reload (rtx_insn *first, int global)

   CLEAR_REG_SET (&changed_allocation_pseudos);
   CLEAR_REG_SET (&spilled_pseudos);
-  reload_in_progress = 0;
+  crtl->rtl_pass_progress &= ~PROGRESS_reload_in_progress;

   /* Now eliminate all pseudo regs by modifying them into
      their equivalent memory references.
@@ -1158,7 +1154,7 @@ reload (rtx_insn *first, int global)
   /* We must set reload_completed now since the cleanup_subreg_operands call
      below will re-recognize each insn and reload may have generated insns
      which are only valid during and after reload.  */
-  reload_completed = 1;
+  crtl->rtl_pass_progress |= PROGRESS_reload_completed;

   /* Make a pass over all the insns and delete all USEs which we inserted
      only to tag a REG_EQUAL note on them.  Remove all REG_DEAD and REG_UNUSED
@@ -1294,7 +1290,10 @@ reload (rtx_insn *first, int global)

   gcc_assert (bitmap_empty_p (&spilled_pseudos));

-  reload_completed = !failure;
+  if (failure)
+    crtl->rtl_pass_progress &= ~PROGRESS_reload_completed;
+  else
+    crtl->rtl_pass_progress |= PROGRESS_reload_completed;

   return need_dce;
 }
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 488016b..55c3435 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -4089,41 +4089,6 @@ PUT_MODE (rtx x, machine_mode mode)
 extern rtx output_constant_def (tree, int);
 extern rtx lookup_constant_def (tree);

-/* Nonzero after end of reload pass.
-   Set to 1 or 0 by reload1.cc.  */
-
-extern int reload_completed;
-
-/* Nonzero after thread_prologue_and_epilogue_insns has run.  */
-extern int epilogue_completed;
-
-/* Set to 1 while reload_as_needed is operating.
-   Required by some machines to handle any generated moves differently.  */
-
-extern int reload_in_progress;
-
-/* Set to 1 while in lra.  */
-extern int lra_in_progress;
-
-/* This macro indicates whether you may create a new
-   pseudo-register.  */
-
-#define can_create_pseudo_p() (!reload_in_progress && !reload_completed)
-
-#ifdef STACK_REGS
-/* Nonzero after end of regstack pass.
-   Set to 1 or 0 by reg-stack.cc.  */
-extern int regstack_completed;
-#endif
-
-/* If this is nonzero, we do not bother generating VOLATILE
-   around volatile memory references, and we are willing to
-   output indirect addresses.  If cse is to follow, we reject
-   indirect addresses so a useful potential cse is generated;
-   if it is used only once, instruction combination will produce
-   the same indirect address eventually.  */
-extern int cse_not_expected;
-
 /* Translates rtx code to tree code, for those codes needed by
    real_arithmetic.  The function returns an int because the caller may not
    know what `enum tree_code' means.  */
diff --git a/gcc/sched-ebb.cc b/gcc/sched-ebb.cc
index 71d72b6..89e4be9 100644
--- a/gcc/sched-ebb.cc
+++ b/gcc/sched-ebb.cc
@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfgrtl.h"
 #include "cfgbuild.h"
 #include "sched-int.h"
+#include "memmodel.h"
+#include "emit-rtl.h"


 #ifdef INSN_SCHEDULING

From 7d43f2b3b69420f1b57618dc8ccd225c266423a3 Mon Sep 17 00:00:00 2001
From: Eugene Rozenfeld <erozen@microsoft.com>
Date: Thu, 21 Apr 2022 15:42:15 -0700
Subject: [PATCH] Add instruction level discriminator support.

This is the first in a series of patches to enable discriminator support
in AutoFDO.

This patch switches to tracking discriminators per statement/instruction
instead of per basic block. Tracking per basic block was problematic since
not all statements in a basic block needed a discriminator and, also, later
optimizations could move statements between basic blocks making correlation
during AutoFDO compilation unreliable. Tracking per statement also allows
us to assign different discriminators to multiple function calls in the same
basic block. A subsequent patch will add that support.

The idea of this patch is based on commit 4c311d95cf6d9519c3c20f641cc77af7df491fdf
by Dehao Chen in vendors/google/heads/gcc-4_8 but uses a slightly different
approach. In Dehao's work special (normally unused) location ids and side tables
were used to keep track of locations with discriminators. Things have changed
since then and I don't think we have unused location ids anymore. Instead,
I made discriminators a part of ad-hoc locations.

The difference from Dehao's work also includes support for discriminator
reading/writing in lto streaming and in modules.

Tested on x86_64-pc-linux-gnu.

gcc/ChangeLog:

	* basic-block.h: Remove discriminator from basic blocks.
	* cfghooks.cc (split_block_1): Remove discriminator from basic blocks.
	* cp/module.cc (write_location): Write discriminator.
	(read_location): Read discriminator.
	* final.cc (final_start_function_1): Switch from per-bb to per statement
	discriminator.
	(final_scan_insn_1): Don't keep track of basic block discriminators.
	(compute_discriminator): Switch from basic block discriminators to
	instruction discriminators.
	(insn_discriminator): New function to return instruction discriminator.
	(notice_source_line): Use insn_discriminator.
	* gimple-pretty-print.cc (dump_gimple_bb_header): Remove dumping of
	basic block discriminators.
	* gimple-streamer-in.cc (input_bb): Remove reading of basic block
	discriminators.
	* gimple-streamer-out.cc (output_bb): Remove writing of basic block
	discriminators.
	* input.cc (make_location): Pass 0 discriminator to COMBINE_LOCATION_DATA.
	(location_with_discriminator): New function to combine locus with
	a discriminator.
	(has_discriminator): New function to check if a location has a discriminator.
	(get_discriminator_from_locus): New function to get the discriminator
	from a location.
	* input.h: Declarations of new functions and definition of
	LOCATION_DISCRIMINATOR.
	* lto-streamer-in.cc (cmp_loc): Use discriminators in location comparison.
	(apply_location_cache): Keep track of current discriminator.
	(input_location_and_block): Read discriminator from stream.
	* lto-streamer-out.cc (clear_line_info): Set current discriminator to
	UINT_MAX.
	(lto_output_location_1): Write discriminator to stream.
	* lto-streamer.h: Add discriminator to cached_location.
	Add current_discr to lto_location_cache.
	Add current_discr to output_block.
	* print-rtl.cc (print_rtx_operand_code_i): Print discriminator.
	* rtl.h: Add extern declaration of insn_discriminator.
	* tree-cfg.cc (assign_discriminator): New function to assign a unique
	discriminator value to all statements in a basic block that have the given
	line number.
	(assign_discriminators): Assign discriminators to statement locations.
	* tree-pretty-print.cc (dump_location): Dump discriminators.
	* tree.cc (set_block): Preserve discriminator when setting block.
	(set_source_range): Preserve discriminator when setting source range.

libcpp/ChangeLog:

	* include/line-map.h: Add discriminator to location_adhoc_data.
	(get_combined_adhoc_loc): Add discriminator parameter.
	(get_discriminator_from_adhoc_loc): Add external declaration.
	(get_discriminator_from_loc): Add external declaration.
	(COMBINE_LOCATION_DATA): Add discriminator parameter.
	* lex.cc (get_location_for_byte_range_in_cur_line) Pass 0 discriminator
	in a call to COMBINE_LOCATION_DATA.
	(warn_about_normalization): Pass 0 discriminator in a call to
	COMBINE_LOCATION_DATA.
	(_cpp_lex_direct): Pass 0 discriminator in a call to
	COMBINE_LOCATION_DATA.
	* line-map.cc (location_adhoc_data_hash): Use discriminator compute
	location_adhoc_data hash.
	(location_adhoc_data_eq): Use discriminator when comparing
	location_adhoc_data.
	(can_be_stored_compactly_p): Check discriminator to determine
	compact storage.
	(get_combined_adhoc_loc): Add discriminator parameter.
	(get_discriminator_from_adhoc_loc): New function to get the discriminator
	from an ad-hoc location.
	(get_discriminator_from_loc): New function to get the discriminator
	from a location.

gcc/testsuite/ChangeLog:

	* c-c++-common/ubsan/pr85213.c: Pass -gno-statement-frontiers.
---
 gcc/basic-block.h                          |  5 ---
 gcc/cfghooks.cc                            |  1 -
 gcc/cp/module.cc                           |  5 ++-
 gcc/final.cc                               | 26 +++++++--------
 gcc/gimple-pretty-print.cc                 |  2 --
 gcc/gimple-streamer-in.cc                  |  1 -
 gcc/gimple-streamer-out.cc                 |  1 -
 gcc/input.cc                               | 36 ++++++++++++++++++--
 gcc/input.h                                |  7 ++++
 gcc/lto-streamer-in.cc                     | 21 ++++++++++--
 gcc/lto-streamer-out.cc                    |  7 ++++
 gcc/lto-streamer.h                         |  3 ++
 gcc/print-rtl.cc                           |  4 +++
 gcc/rtl.h                                  |  1 +
 gcc/testsuite/c-c++-common/ubsan/pr85213.c |  7 +++-
 gcc/tree-cfg.cc                            | 39 ++++++++++++++++++----
 gcc/tree-pretty-print.cc                   |  6 ++++
 gcc/tree.cc                                | 10 ++++--
 libcpp/include/line-map.h                  | 10 ++++--
 libcpp/lex.cc                              |  7 ++--
 libcpp/line-map.cc                         | 38 +++++++++++++++++----
 21 files changed, 185 insertions(+), 52 deletions(-)

diff --git a/gcc/basic-block.h b/gcc/basic-block.h
index c9d1fc91bbb..1eae03d1aca 100644
--- a/gcc/basic-block.h
+++ b/gcc/basic-block.h
@@ -148,11 +148,6 @@ struct GTY((chain_next ("%h.next_bb"), chain_prev ("%h.prev_bb"))) basic_block_d

   /* Expected number of executions: calculated in profile.cc.  */
   profile_count count;
-
-  /* The discriminator for this block.  The discriminator distinguishes
-     among several basic blocks that share a common locus, allowing for
-     more accurate sample-based profiling.  */
-  int discriminator;
 };

 /* This ensures that struct gimple_bb_info is smaller than
diff --git a/gcc/cfghooks.cc b/gcc/cfghooks.cc
index e435891fac6..7a0c5f77ef9 100644
--- a/gcc/cfghooks.cc
+++ b/gcc/cfghooks.cc
@@ -541,7 +541,6 @@ split_block_1 (basic_block bb, void *i)
     return NULL;

   new_bb->count = bb->count;
-  new_bb->discriminator = bb->discriminator;

   if (dom_info_available_p (CDI_DOMINATORS))
     {
diff --git a/gcc/cp/module.cc b/gcc/cp/module.cc
index d1dc73724d1..5ed6b7b0f94 100644
--- a/gcc/cp/module.cc
+++ b/gcc/cp/module.cc
@@ -15587,6 +15587,8 @@ module_state::write_location (bytes_out &sec, location_t loc)
 	range.m_start = UNKNOWN_LOCATION;
       write_location (sec, range.m_start);
       write_location (sec, range.m_finish);
+      unsigned discriminator = get_discriminator_from_adhoc_loc (line_table, loc);
+      sec.u (discriminator);
     }
   else if (loc >= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))
     {
@@ -15671,8 +15673,9 @@ module_state::read_location (bytes_in &sec) const
 	if (range.m_start == UNKNOWN_LOCATION)
 	  range.m_start = locus;
 	range.m_finish = read_location (sec);
+	unsigned discriminator = sec.u ();
 	if (locus != loc && range.m_start != loc && range.m_finish != loc)
-	  locus = get_combined_adhoc_loc (line_table, locus, range, NULL);
+	  locus = get_combined_adhoc_loc (line_table, locus, range, NULL, discriminator);
       }
       break;

diff --git a/gcc/final.cc b/gcc/final.cc
index a9868861bd2..0d8c21b0681 100644
--- a/gcc/final.cc
+++ b/gcc/final.cc
@@ -126,18 +126,10 @@ static int last_columnnum;
 /* Discriminator written to assembly.  */
 static int last_discriminator;

-/* Discriminator to be written to assembly for current instruction.
+/* Compute discriminator to be written to assembly for current instruction.
    Note: actual usage depends on loc_discriminator_kind setting.  */
-static int discriminator;
 static inline int compute_discriminator (location_t loc);

-/* Discriminator identifying current basic block among others sharing
-   the same locus.  */
-static int bb_discriminator;
-
-/* Basic block discriminator for previous instruction.  */
-static int last_bb_discriminator;
-
 /* Highest line number in current block.  */
 static int high_block_linenum;

@@ -1697,8 +1689,7 @@ final_start_function_1 (rtx_insn **firstp, FILE *file, int *seen,
   last_filename = LOCATION_FILE (prologue_location);
   last_linenum = LOCATION_LINE (prologue_location);
   last_columnnum = LOCATION_COLUMN (prologue_location);
-  last_discriminator = discriminator = 0;
-  last_bb_discriminator = bb_discriminator = 0;
+  last_discriminator = 0;
   force_source_line = false;

   high_block_linenum = high_function_linenum = last_linenum;
@@ -2243,7 +2234,6 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 	  if (targetm.asm_out.unwind_emit)
 	    targetm.asm_out.unwind_emit (asm_out_file, insn);

-	  bb_discriminator = NOTE_BASIC_BLOCK (insn)->discriminator;
 	  break;

 	case NOTE_INSN_EH_REGION_BEG:
@@ -2982,7 +2972,7 @@ compute_discriminator (location_t loc)
   int discriminator;

   if (!decl_to_instance_map)
-    discriminator = bb_discriminator;
+    discriminator = get_discriminator_from_locus (loc);
   else
     {
       tree block = LOCATION_BLOCK (loc);
@@ -3006,6 +2996,13 @@ compute_discriminator (location_t loc)
   return discriminator;
 }

+/* Return discriminator of the statement that produced this insn.  */
+int
+insn_discriminator (const rtx_insn *insn)
+{
+  return compute_discriminator (INSN_LOCATION (insn));
+}
+
 /* Return whether a source line note needs to be emitted before INSN.
    Sets IS_STMT to TRUE if the line should be marked as a possible
    breakpoint location.  */
@@ -3015,6 +3012,7 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)
 {
   const char *filename;
   int linenum, columnnum;
+  int discriminator;

   if (NOTE_MARKER_P (insn))
     {
@@ -3044,7 +3042,7 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)
       filename = xloc.file;
       linenum = xloc.line;
       columnnum = xloc.column;
-      discriminator = compute_discriminator (INSN_LOCATION (insn));
+      discriminator = insn_discriminator (insn);
     }
   else
     {
diff --git a/gcc/gimple-pretty-print.cc b/gcc/gimple-pretty-print.cc
index ebd87b20a0a..5e7039dbf66 100644
--- a/gcc/gimple-pretty-print.cc
+++ b/gcc/gimple-pretty-print.cc
@@ -2899,8 +2899,6 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent,
 			 indent, "", get_lineno (gsi_stmt (gsi)));
 		break;
 	      }
-	  if (bb->discriminator)
-	    fprintf (outf, ", discriminator %i", bb->discriminator);
 	  fputc ('\n', outf);
 	}
     }
diff --git a/gcc/gimple-streamer-in.cc b/gcc/gimple-streamer-in.cc
index e7f3256302f..ea8891e8e92 100644
--- a/gcc/gimple-streamer-in.cc
+++ b/gcc/gimple-streamer-in.cc
@@ -267,7 +267,6 @@ input_bb (class lto_input_block *ib, enum LTO_tags tag,
     bb->count
       = bb->count.apply_scale (count_materialization_scale, REG_BR_PROB_BASE);
   bb->flags = streamer_read_hwi (ib);
-  bb->discriminator = streamer_read_hwi (ib);

   /* LTO_bb1 has statements.  LTO_bb0 does not.  */
   if (tag == LTO_bb0)
diff --git a/gcc/gimple-streamer-out.cc b/gcc/gimple-streamer-out.cc
index 33365251295..45832547bf5 100644
--- a/gcc/gimple-streamer-out.cc
+++ b/gcc/gimple-streamer-out.cc
@@ -208,7 +208,6 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)
   streamer_write_uhwi (ob, bb->index);
   bb->count.stream_out (ob);
   streamer_write_hwi (ob, bb->flags);
-  streamer_write_hwi (ob, bb->discriminator);

   if (!gsi_end_p (bsi) || phi_nodes (bb))
     {
diff --git a/gcc/input.cc b/gcc/input.cc
index 2acbfdea4f8..ef4bacf0da6 100644
--- a/gcc/input.cc
+++ b/gcc/input.cc
@@ -1045,7 +1045,8 @@ make_location (location_t caret, location_t start, location_t finish)
   location_t combined_loc = COMBINE_LOCATION_DATA (line_table,
 						   pure_loc,
 						   src_range,
-						   NULL);
+						   NULL,
+						   0);
   return combined_loc;
 }

@@ -1055,7 +1056,7 @@ location_t
 make_location (location_t caret, source_range src_range)
 {
   location_t pure_loc = get_pure_location (caret);
-  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, NULL);
+  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, NULL, 0);
 }

 /* An expanded_location stores the column in byte units.  This function
@@ -1729,6 +1730,37 @@ get_location_within_string (cpp_reader *pfile,
   return NULL;
 }

+/* Associate the DISCRIMINATOR with LOCUS, and return a new locus. */
+
+location_t
+location_with_discriminator (location_t locus, int discriminator)
+{
+  tree block = LOCATION_BLOCK (locus);
+  source_range src_range = get_range_from_loc (line_table, locus);
+  locus = get_pure_location (locus);
+
+  if (locus == UNKNOWN_LOCATION)
+    return locus;
+
+  return COMBINE_LOCATION_DATA (line_table, locus, src_range, block, discriminator);
+}
+
+/* Return TRUE if LOCUS represents a location with a discriminator.  */
+
+bool
+has_discriminator (location_t locus)
+{
+  return LOCATION_DISCRIMINATOR(locus) != 0;
+}
+
+/* Return the discriminator for LOCUS.  */
+
+int
+get_discriminator_from_locus (location_t locus)
+{
+  return LOCATION_DISCRIMINATOR(locus);
+}
+
 #if CHECKING_P

 namespace selftest {
diff --git a/gcc/input.h b/gcc/input.h
index f1ae3aec95c..564ebd893e9 100644
--- a/gcc/input.h
+++ b/gcc/input.h
@@ -165,6 +165,10 @@ extern location_t expansion_point_location (location_t);

 extern location_t input_location;

+extern location_t location_with_discriminator (location_t, int);
+extern bool has_discriminator (location_t);
+extern int get_discriminator_from_locus (location_t);
+
 #define LOCATION_FILE(LOC) ((expand_location (LOC)).file)
 #define LOCATION_LINE(LOC) ((expand_location (LOC)).line)
 #define LOCATION_COLUMN(LOC)((expand_location (LOC)).column)
@@ -174,6 +178,9 @@ extern location_t input_location;
 #define LOCATION_BLOCK(LOC) \
   ((tree) ((IS_ADHOC_LOC (LOC)) ? get_data_from_adhoc_loc (line_table, (LOC)) \
    : NULL))
+#define LOCATION_DISCRIMINATOR(LOC) \
+  ((IS_ADHOC_LOC (LOC)) ? get_discriminator_from_adhoc_loc (line_table, (LOC)) \
+   : 0)
 #define RESERVED_LOCATION_P(LOC) \
   (LOCATION_LOCUS (LOC) < RESERVED_LOCATION_COUNT)

diff --git a/gcc/lto-streamer-in.cc b/gcc/lto-streamer-in.cc
index fe5a4e7fe1d..271b8006ac0 100644
--- a/gcc/lto-streamer-in.cc
+++ b/gcc/lto-streamer-in.cc
@@ -409,6 +409,8 @@ lto_location_cache::cmp_loc (const void *pa, const void *pb)
     return a->line - b->line;
   if (a->col != b->col)
     return a->col - b->col;
+  if (a->discr != b->discr)
+    return a->discr - b->discr;
   if ((a->block == NULL_TREE) != (b->block == NULL_TREE))
     return a->block ? 1 : -1;
   if (a->block)
@@ -460,6 +462,8 @@ lto_location_cache::apply_location_cache ()
 	  current_loc = linemap_position_for_column (line_table, loc.col);
 	  if (loc.block)
 	    current_loc = set_block (current_loc, loc.block);
+	  if (loc.discr)
+	    current_loc = location_with_discriminator (current_loc, loc.discr);
 	}
       else if (current_block != loc.block)
 	{
@@ -467,12 +471,19 @@ lto_location_cache::apply_location_cache ()
 	    current_loc = set_block (current_loc, loc.block);
 	  else
 	    current_loc = LOCATION_LOCUS (current_loc);
+	  if (loc.discr)
+	    current_loc = location_with_discriminator (current_loc, loc.discr);
+	}
+      else if (current_discr != loc.discr)
+	{
+	    current_loc = location_with_discriminator (current_loc, loc.discr);
 	}
       *loc.loc = current_loc;
       current_line = loc.line;
       prev_file = current_file = loc.file;
       current_col = loc.col;
       current_block = loc.block;
+      current_discr = loc.discr;
     }
   loc_cache.truncate (0);
   accepted_length = 0;
@@ -512,6 +523,7 @@ lto_location_cache::input_location_and_block (location_t *loc,
   static int stream_col;
   static bool stream_sysp;
   static tree stream_block;
+  static unsigned stream_discr;
   static const char *stream_relative_path_prefix;

   gcc_assert (current_cache == this);
@@ -538,6 +550,7 @@ lto_location_cache::input_location_and_block (location_t *loc,
   *loc = RESERVED_LOCATION_COUNT;
   bool line_change = bp_unpack_value (bp, 1);
   bool column_change = bp_unpack_value (bp, 1);
+  bool discr_change = bp_unpack_value (bp, 1);

   if (file_change)
     {
@@ -563,6 +576,9 @@ lto_location_cache::input_location_and_block (location_t *loc,
   if (column_change)
     stream_col = bp_unpack_var_len_unsigned (bp);

+  if (discr_change)
+    stream_discr = bp_unpack_var_len_unsigned (bp);
+
   tree block = NULL_TREE;
   if (ib)
     {
@@ -578,7 +594,8 @@ lto_location_cache::input_location_and_block (location_t *loc,
   if (current_file == stream_file
       && current_line == stream_line
       && current_col == stream_col
-      && current_sysp == stream_sysp)
+      && current_sysp == stream_sysp
+      && current_discr == stream_discr)
     {
       if (current_block == block)
 	*loc = current_loc;
@@ -590,7 +607,7 @@ lto_location_cache::input_location_and_block (location_t *loc,
     }

   struct cached_location entry
-    = {stream_file, loc, stream_line, stream_col, stream_sysp, block};
+    = {stream_file, loc, stream_line, stream_col, stream_sysp, block, stream_discr};
   loc_cache.safe_push (entry);
 }

diff --git a/gcc/lto-streamer-out.cc b/gcc/lto-streamer-out.cc
index 471f35c315f..d2b6c69315f 100644
--- a/gcc/lto-streamer-out.cc
+++ b/gcc/lto-streamer-out.cc
@@ -67,6 +67,7 @@ clear_line_info (struct output_block *ob)
      so that the first location with block in a function etc.
      always streams a change_block bit and the first block.  */
   ob->current_block = void_node;
+  ob->current_discr = UINT_MAX;
 }


@@ -194,6 +195,7 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,
   if (loc >= RESERVED_LOCATION_COUNT)
     {
       expanded_location xloc = expand_location (loc);
+      unsigned discr = LOCATION_DISCRIMINATOR (orig_loc);

       if (ob->reset_locus)
 	{
@@ -216,6 +218,7 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,

       bp_pack_value (bp, ob->current_line != xloc.line, 1);
       bp_pack_value (bp, ob->current_col != xloc.column, 1);
+      bp_pack_value (bp, ob->current_discr != discr, 1);

       if (ob->current_file != xloc.file)
 	{
@@ -242,6 +245,10 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,
       if (ob->current_col != xloc.column)
 	bp_pack_var_len_unsigned (bp, xloc.column);
       ob->current_col = xloc.column;
+
+      if (ob->current_discr != discr)
+	bp_pack_var_len_unsigned (bp, discr);
+      ob->current_discr = discr;
     }
   else
     bp_pack_int_in_range (bp, 0, RESERVED_LOCATION_COUNT + 1, loc);
diff --git a/gcc/lto-streamer.h b/gcc/lto-streamer.h
index 597e9e405ec..2e3abd97959 100644
--- a/gcc/lto-streamer.h
+++ b/gcc/lto-streamer.h
@@ -311,6 +311,7 @@ private:
     int line, col;
     bool sysp;
     tree block;
+    unsigned discr;
   };

   /* The location cache.  */
@@ -333,6 +334,7 @@ private:
   bool current_sysp;
   location_t current_loc;
   tree current_block;
+  unsigned current_discr;
 };

 /* Structure used as buffer for reading an LTO file.  */
@@ -723,6 +725,7 @@ struct output_block
   bool reset_locus;
   bool emit_pwd;
   tree current_block;
+  unsigned current_discr;

   /* Cache of nodes written in this section.  */
   struct streamer_tree_cache_d *writer_cache;
diff --git a/gcc/print-rtl.cc b/gcc/print-rtl.cc
index 60c845485bc..e115f987173 100644
--- a/gcc/print-rtl.cc
+++ b/gcc/print-rtl.cc
@@ -453,6 +453,10 @@ rtx_writer::print_rtx_operand_code_i (const_rtx in_rtx, int idx)
 	  expanded_location xloc = insn_location (in_insn);
 	  fprintf (m_outfile, " \"%s\":%i:%i", xloc.file, xloc.line,
 		   xloc.column);
+	  int discriminator = insn_discriminator (in_insn);
+	    if (discriminator)
+	      fprintf (m_outfile, " discrim %d", discriminator);
+
 	}
 #endif
     }
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 488016bb42a..b0528235ef8 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -3369,6 +3369,7 @@ extern int insn_line (const rtx_insn *);
 extern const char * insn_file (const rtx_insn *);
 extern tree insn_scope (const rtx_insn *);
 extern expanded_location insn_location (const rtx_insn *);
+extern int insn_discriminator (const rtx_insn *);
 extern location_t prologue_location, epilogue_location;

 /* In jump.cc */
diff --git a/gcc/testsuite/c-c++-common/ubsan/pr85213.c b/gcc/testsuite/c-c++-common/ubsan/pr85213.c
index 8a6be81d20f..e903e976f2c 100644
--- a/gcc/testsuite/c-c++-common/ubsan/pr85213.c
+++ b/gcc/testsuite/c-c++-common/ubsan/pr85213.c
@@ -1,6 +1,11 @@
 /* PR sanitizer/85213 */
 /* { dg-do compile } */
-/* { dg-options "-O1 -fsanitize=undefined -fcompare-debug" } */
+/* Pass -gno-statement-frontiers to work around
+   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100733 :
+   without it the IR coming from the front end may be different with and without
+   debug information turned on. That may cause e.g., different discriminator values
+   and -fcompare-debug failures. */
+/* { dg-options "-O1 -fsanitize=undefined -fcompare-debug -gno-statement-frontiers" } */

 int
 foo (int x)
diff --git a/gcc/tree-cfg.cc b/gcc/tree-cfg.cc
index 8de1b144a42..3b4063f18fd 100644
--- a/gcc/tree-cfg.cc
+++ b/gcc/tree-cfg.cc
@@ -1162,7 +1162,33 @@ same_line_p (location_t locus1, expanded_location *from, location_t locus2)
           && filename_cmp (from->file, to.file) == 0);
 }

-/* Assign discriminators to each basic block.  */
+/* Assign a unique discriminator value to all statements in block bb that
+   have the same line number as locus. */
+
+static void
+assign_discriminator (location_t locus, basic_block bb)
+{
+  gimple_stmt_iterator gsi;
+  int discriminator;
+
+  if (locus == UNKNOWN_LOCATION)
+    return;
+
+  expanded_location locus_e = expand_location (locus);
+
+  discriminator = next_discriminator_for_locus (locus_e.line);
+
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple *stmt = gsi_stmt (gsi);
+      location_t stmt_locus = gimple_location (stmt);
+      if (same_line_p (locus, &locus_e, stmt_locus))
+	gimple_set_location (stmt,
+	    location_with_discriminator (stmt_locus, discriminator));
+    }
+}
+
+/* Assign discriminators to statement locations.  */

 static void
 assign_discriminators (void)
@@ -1177,6 +1203,7 @@ assign_discriminators (void)
       location_t locus = last ? gimple_location (last) : UNKNOWN_LOCATION;

       if (locus == UNKNOWN_LOCATION)
+
 	continue;

       expanded_location locus_e = expand_location (locus);
@@ -1190,12 +1217,12 @@ assign_discriminators (void)
 	      || (last && same_line_p (locus, &locus_e,
 				       gimple_location (last))))
 	    {
-	      if (e->dest->discriminator != 0 && bb->discriminator == 0)
-		bb->discriminator
-		  = next_discriminator_for_locus (locus_e.line);
+	      if (((first && has_discriminator (gimple_location (first)))
+		   || (last && has_discriminator (gimple_location (last))))
+		  && !has_discriminator (locus))
+		assign_discriminator (locus, bb);
 	      else
-		e->dest->discriminator
-		  = next_discriminator_for_locus (locus_e.line);
+		assign_discriminator (locus, e->dest);
 	    }
 	}
     }
diff --git a/gcc/tree-pretty-print.cc b/gcc/tree-pretty-print.cc
index 6acd394a079..ed9c368742e 100644
--- a/gcc/tree-pretty-print.cc
+++ b/gcc/tree-pretty-print.cc
@@ -1416,6 +1416,7 @@ void
 dump_location (pretty_printer *pp, location_t loc)
 {
   expanded_location xloc = expand_location (loc);
+  int discriminator = get_discriminator_from_locus (loc);

   pp_left_bracket (pp);
   if (xloc.file)
@@ -1426,6 +1427,11 @@ dump_location (pretty_printer *pp, location_t loc)
   pp_decimal_int (pp, xloc.line);
   pp_colon (pp);
   pp_decimal_int (pp, xloc.column);
+  if (discriminator)
+  {
+    pp_string (pp, " discrim ");
+    pp_decimal_int (pp, discriminator);
+  }
   pp_string (pp, "] ");
 }

diff --git a/gcc/tree.cc b/gcc/tree.cc
index 2bfb67489c6..a35a1e824d0 100644
--- a/gcc/tree.cc
+++ b/gcc/tree.cc
@@ -14124,7 +14124,8 @@ set_block (location_t loc, tree block)
 {
   location_t pure_loc = get_pure_location (loc);
   source_range src_range = get_range_from_loc (line_table, loc);
-  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, block);
+  unsigned discriminator = get_discriminator_from_loc (line_table, loc);
+  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, block, discriminator);
 }

 location_t
@@ -14142,11 +14143,14 @@ set_source_range (tree expr, source_range src_range)
   if (!EXPR_P (expr))
     return UNKNOWN_LOCATION;

-  location_t pure_loc = get_pure_location (EXPR_LOCATION (expr));
+  location_t expr_location = EXPR_LOCATION (expr);
+  location_t pure_loc = get_pure_location (expr_location);
+  unsigned discriminator = get_discriminator_from_locus (expr_location);
   location_t adhoc = COMBINE_LOCATION_DATA (line_table,
 					    pure_loc,
 					    src_range,
-					    NULL);
+					    NULL,
+					    discriminator);
   SET_EXPR_LOCATION (expr, adhoc);
   return adhoc;
 }
diff --git a/libcpp/include/line-map.h b/libcpp/include/line-map.h
index 80335721e03..f2d9e3cfbb7 100644
--- a/libcpp/include/line-map.h
+++ b/libcpp/include/line-map.h
@@ -755,6 +755,7 @@ struct GTY(()) location_adhoc_data {
   location_t locus;
   source_range src_range;
   void * GTY((skip)) data;
+  unsigned discriminator;
 };

 struct htab;
@@ -1032,12 +1033,14 @@ LINEMAPS_LAST_ALLOCATED_MACRO_MAP (const line_maps *set)
 }

 extern location_t get_combined_adhoc_loc (line_maps *, location_t,
-					  source_range, void *);
+					  source_range, void *, unsigned);
 extern void *get_data_from_adhoc_loc (const line_maps *, location_t);
+extern unsigned get_discriminator_from_adhoc_loc (const line_maps *, location_t);
 extern location_t get_location_from_adhoc_loc (const line_maps *,
 					       location_t);

 extern source_range get_range_from_loc (line_maps *set, location_t loc);
+extern unsigned get_discriminator_from_loc (line_maps *set, location_t loc);

 /* Get whether location LOC is a "pure" location, or
    whether it is an ad-hoc location, or embeds range information.  */
@@ -1056,9 +1059,10 @@ inline location_t
 COMBINE_LOCATION_DATA (class line_maps *set,
 		       location_t loc,
 		       source_range src_range,
-		       void *block)
+		       void *block,
+		       unsigned discriminator)
 {
-  return get_combined_adhoc_loc (set, loc, src_range, block);
+  return get_combined_adhoc_loc (set, loc, src_range, block, discriminator);
 }

 extern void rebuild_location_adhoc_htab (class line_maps *);
diff --git a/libcpp/lex.cc b/libcpp/lex.cc
index f891d3e17df..7bbd8c0f8e1 100644
--- a/libcpp/lex.cc
+++ b/libcpp/lex.cc
@@ -1359,7 +1359,8 @@ get_location_for_byte_range_in_cur_line (cpp_reader *pfile,
   location_t combined_loc = COMBINE_LOCATION_DATA (pfile->line_table,
 						   start_loc,
 						   src_range,
-						   NULL);
+						   NULL,
+						   0);
   return combined_loc;
 }

@@ -1828,7 +1829,7 @@ warn_about_normalization (cpp_reader *pfile,
 					   CPP_BUF_COLUMN (pfile->buffer,
 							   pfile->buffer->cur));
 	  loc = COMBINE_LOCATION_DATA (pfile->line_table,
-				       loc, tok_range, NULL);
+				       loc, tok_range, NULL, 0);
 	}

       encoding_rich_location rich_loc (pfile, loc);
@@ -4025,7 +4026,7 @@ _cpp_lex_direct (cpp_reader *pfile)

       result->src_loc = COMBINE_LOCATION_DATA (pfile->line_table,
 					       result->src_loc,
-					       tok_range, NULL);
+					       tok_range, NULL, 0);
     }

   return result;
diff --git a/libcpp/line-map.cc b/libcpp/line-map.cc
index 62077c3857c..e17d109d9f1 100644
--- a/libcpp/line-map.cc
+++ b/libcpp/line-map.cc
@@ -67,7 +67,8 @@ location_adhoc_data_hash (const void *l)
   return ((hashval_t) lb->locus
 	  + (hashval_t) lb->src_range.m_start
 	  + (hashval_t) lb->src_range.m_finish
-	  + (size_t) lb->data);
+	  + (size_t) lb->data
+	  + lb->discriminator);
 }

 /* Compare function for location_adhoc_data hashtable.  */
@@ -82,7 +83,8 @@ location_adhoc_data_eq (const void *l1, const void *l2)
   return (lb1->locus == lb2->locus
 	  && lb1->src_range.m_start == lb2->src_range.m_start
 	  && lb1->src_range.m_finish == lb2->src_range.m_finish
-	  && lb1->data == lb2->data);
+	  && lb1->data == lb2->data
+	  && lb1->discriminator == lb2->discriminator);
 }

 /* Update the hashtable when location_adhoc_data is reallocated.  */
@@ -116,13 +118,17 @@ static bool
 can_be_stored_compactly_p (line_maps *set,
 			   location_t locus,
 			   source_range src_range,
-			   void *data)
+			   void *data,
+			   unsigned discriminator)
 {
   /* If there's an ad-hoc pointer, we can't store it directly in the
      location_t, we need the lookaside.  */
   if (data)
     return false;

+  if (discriminator != 0)
+    return false;
+
   /* We only store ranges that begin at the locus and that are sufficiently
      "sane".  */
   if (src_range.m_start != locus)
@@ -157,7 +163,8 @@ location_t
 get_combined_adhoc_loc (line_maps *set,
 			location_t locus,
 			source_range src_range,
-			void *data)
+			void *data,
+			unsigned discriminator)
 {
   struct location_adhoc_data lb;
   struct location_adhoc_data **slot;
@@ -175,7 +182,7 @@ get_combined_adhoc_loc (line_maps *set,
 		  || pure_location_p (set, locus));

   /* Consider short-range optimization.  */
-  if (can_be_stored_compactly_p (set, locus, src_range, data))
+  if (can_be_stored_compactly_p (set, locus, src_range, data, discriminator))
     {
       /* The low bits ought to be clear.  */
       linemap_assert (pure_location_p (set, locus));
@@ -195,15 +202,16 @@ get_combined_adhoc_loc (line_maps *set,
      when locus == start == finish (and data is NULL).  */
   if (locus == src_range.m_start
       && locus == src_range.m_finish
-      && !data)
+      && !data && discriminator == 0)
     return locus;

-  if (!data)
+  if (!data && discriminator == 0)
     set->num_unoptimized_ranges++;

   lb.locus = locus;
   lb.src_range = src_range;
   lb.data = data;
+  lb.discriminator = discriminator;
   slot = (struct location_adhoc_data **)
       htab_find_slot (set->location_adhoc_data_map.htab, &lb, INSERT);
   if (*slot == NULL)
@@ -248,6 +256,13 @@ get_data_from_adhoc_loc (const class line_maps *set, location_t loc)
   return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].data;
 }

+unsigned
+get_discriminator_from_adhoc_loc (const class line_maps *set, location_t loc)
+{
+  linemap_assert (IS_ADHOC_LOC (loc));
+  return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].discriminator;
+}
+
 /* Return the location for the adhoc loc.  */

 location_t
@@ -293,6 +308,15 @@ get_range_from_loc (line_maps *set,
   return source_range::from_location (loc);
 }

+unsigned
+get_discriminator_from_loc (line_maps *set,
+			    location_t loc)
+{
+  if (IS_ADHOC_LOC (loc))
+    return get_discriminator_from_adhoc_loc (set, loc);
+  return 0;
+}
+
 /* Get whether location LOC is a "pure" location, or
    whether it is an ad-hoc location, or embeds range information.  */

--
2.25.1

When DSE asks whether __real a is using __imag a it gets a surprising
result when a is a FUNCTION_DECL.  The following makes sure this case
is less surprising to callers but keeping the bail-out for the
non-decl case where it is true that PTA doesn't track aliases to code
correctly.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

2022-06-15  Richard Biener  <rguenther@suse.de>

	PR tree-optimization/105971
	* tree-ssa-alias.cc (refs_may_alias_p_2): Put bail-out for
	FUNCTION_DECL and LABEL_DECL refs after decl-decl disambiguation
	to leak less surprising alias results.

	* gcc.dg/torture/pr106971.c: New testcase.
---
 gcc/testsuite/gcc.dg/torture/pr106971.c | 12 ++++++++++++
 gcc/tree-ssa-alias.cc                   | 18 +++++++++---------
 2 files changed, 21 insertions(+), 9 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/torture/pr106971.c

diff --git a/gcc/testsuite/gcc.dg/torture/pr106971.c b/gcc/testsuite/gcc.dg/torture/pr106971.c
new file mode 100644
index 00000000000..33f21056e62
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106971.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+
+void a()
+{
+  int b;
+  int c;
+  int d = (__INTPTR_TYPE__)a;
+  _Complex float *e = (_Complex float *)a;
+  for (;;) {
+    (*e += d) / b ?: 0;
+  }
+}
diff --git a/gcc/tree-ssa-alias.cc b/gcc/tree-ssa-alias.cc
index 063f1893851..b1e7a2d5afc 100644
--- a/gcc/tree-ssa-alias.cc
+++ b/gcc/tree-ssa-alias.cc
@@ -2397,15 +2397,6 @@ refs_may_alias_p_2 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)
       || CONSTANT_CLASS_P (base2))
     return false;

-  /* We can end up referring to code via function and label decls.
-     As we likely do not properly track code aliases conservatively
-     bail out.  */
-  if (TREE_CODE (base1) == FUNCTION_DECL
-      || TREE_CODE (base1) == LABEL_DECL
-      || TREE_CODE (base2) == FUNCTION_DECL
-      || TREE_CODE (base2) == LABEL_DECL)
-    return true;
-
   /* Two volatile accesses always conflict.  */
   if (ref1->volatile_p
       && ref2->volatile_p)
@@ -2432,6 +2423,15 @@ refs_may_alias_p_2 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)
 				  ref2ref, base2, offset2, max_size2,
 				  ref2->size);

+  /* We can end up referring to code via function and label decls.
+     As we likely do not properly track code aliases conservatively
+     bail out.  */
+  if (TREE_CODE (base1) == FUNCTION_DECL
+      || TREE_CODE (base1) == LABEL_DECL
+      || TREE_CODE (base2) == FUNCTION_DECL
+      || TREE_CODE (base2) == LABEL_DECL)
+    return true;
+
   /* Handle restrict based accesses.
      ???  ao_ref_base strips inner MEM_REF [&decl], recover from that
      here.  */
--
2.35.3

For a [0][0] array we have to be careful when dividing by the element
size which is zero for the outermost dimension.  Luckily the division
is only for an overflow check which is pointless for array size zero.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

2022-06-15  Richard Biener  <rguenther@suse.de>

	PR tree-optimization/105969
	* gimple-ssa-sprintf.cc (): Avoid division by zero
	in overflow check.

	* gcc.dg/pr105969.c: New testcase.
---
 gcc/gimple-ssa-sprintf.cc       |  2 +-
 gcc/testsuite/gcc.dg/pr105969.c | 13 +++++++++++++
 2 files changed, 14 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/gcc.dg/pr105969.c

diff --git a/gcc/gimple-ssa-sprintf.cc b/gcc/gimple-ssa-sprintf.cc
index 6bd27302213..a888b5ac7d5 100644
--- a/gcc/gimple-ssa-sprintf.cc
+++ b/gcc/gimple-ssa-sprintf.cc
@@ -2319,7 +2319,7 @@ get_origin_and_offset_r (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *fldsize,

 	if (byteoff < HOST_WIDE_INT_MAX
 	    && elbytes < HOST_WIDE_INT_MAX
-	    && byteoff / elbytes == idx)
+	    && (elbytes == 0 || byteoff / elbytes == idx))
 	  {
 	    /* For in-bounds constant offsets into constant-sized arrays
 	       bump up *OFF, and for what's likely arrays or structs of
diff --git a/gcc/testsuite/gcc.dg/pr105969.c b/gcc/testsuite/gcc.dg/pr105969.c
new file mode 100644
index 00000000000..52c63fc2efe
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105969.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-Wall" } */
+
+struct A
+{
+  char a[0][0][0];
+};
+extern struct A b[][2];
+void f (void)
+{
+  __builtin_sprintf (b[0][0].a[1][0], "%s", b[0][0].a[1][0]); /* { dg-warning "past the end" } */
+  /* { dg-warning "overlaps destination" "" { target *-*-* } .-1 } */
+}
--
2.35.3

When autopar uses graphites canonicalize_loop_closed_ssa it fails to
check whether propagation is allowed and thus it ends up messing up
abnormal constraints.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

2022-07-01  Richard Biener  <rguenther@suse.de>

	PR tree-optimization/106055
	* graphite.cc (canonicalize_loop_closed_ssa): Check whether
	we can propagate.

	* gcc.dg/graphite/pr106055.c: New testcase.
---
 gcc/graphite.cc                          |  5 ++-
 gcc/testsuite/gcc.dg/graphite/pr106055.c | 41 ++++++++++++++++++++++++
 2 files changed, 45 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/gcc.dg/graphite/pr106055.c

diff --git a/gcc/graphite.cc b/gcc/graphite.cc
index a88b13c0219..fd4f7a126e1 100644
--- a/gcc/graphite.cc
+++ b/gcc/graphite.cc
@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-ssa-loop-manip.h"
 #include "tree-ssa.h"
 #include "tree-into-ssa.h"
+#include "tree-ssa-propagate.h"
 #include "graphite.h"

 /* Print global statistics to FILE.  */
@@ -337,7 +338,9 @@ canonicalize_loop_closed_ssa (loop_p loop, edge e)
       /* Iterate over the next phis and remove duplicates.  */
       gsi_next (&gsi);
       while (!gsi_end_p (gsi))
-	if (gimple_phi_arg_def (phi, 0) == gimple_phi_arg_def (gsi.phi (), 0))
+	if (gimple_phi_arg_def (phi, 0) == gimple_phi_arg_def (gsi.phi (), 0)
+	    && may_propagate_copy (gimple_phi_result (gsi.phi ()),
+				   gimple_phi_result (phi)))
 	  {
 	    replace_uses_by (gimple_phi_result (gsi.phi ()),
 			     gimple_phi_result (phi));
diff --git a/gcc/testsuite/gcc.dg/graphite/pr106055.c b/gcc/testsuite/gcc.dg/graphite/pr106055.c
new file mode 100644
index 00000000000..22be62b3607
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/graphite/pr106055.c
@@ -0,0 +1,41 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -floop-parallelize-all -fno-tree-dce" } */
+
+__attribute__ ((returns_twice)) int
+bar (void);
+
+void
+quux (void);
+
+void
+empty (void)
+{
+}
+
+unsigned int
+choose (unsigned int x, unsigned int y)
+{
+  return y ? x : 0;
+}
+
+int
+foo (int *p, unsigned int x, int y)
+{
+  unsigned int acc = 0;
+
+  empty ();
+
+  while (x)
+    {
+      bar ();
+      ++x;
+    }
+
+  while (y)
+    acc += y;
+
+  *p = choose (acc, 1);
+  quux ();
+
+  return x;
+}
--
2.35.3

The following adds missing assignment of a virtual use operand to a
created load to vect_setup_realignment which shows as bootstrap
failure on powerpc64-linux and extra testsuite fails for targets
when misaligned loads are not supported or not optimal.

Bootstrapped on x86_64-unknown-linux-gnu, testing in progress.

	PR tree-optimization/106228
	* tree-vect-data-refs.cc (vect_setup_realignment): Properly
	set a VUSE operand on the emitted load.
---
 gcc/tree-vect-data-refs.cc | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/gcc/tree-vect-data-refs.cc b/gcc/tree-vect-data-refs.cc
index d20a10a1524..53e52cb58cb 100644
--- a/gcc/tree-vect-data-refs.cc
+++ b/gcc/tree-vect-data-refs.cc
@@ -5780,6 +5780,13 @@ vect_setup_realignment (vec_info *vinfo, stmt_vec_info stmt_info,
   if (loop_for_initial_load)
     pe = loop_preheader_edge (loop_for_initial_load);

+  tree vuse;
+  gphi *vphi = get_virtual_phi (loop_for_initial_load->header);
+  if (vphi)
+    vuse = PHI_ARG_DEF_FROM_EDGE (vphi, pe);
+  else
+    vuse = gimple_vuse (gsi_stmt (*gsi));
+
   /* 3. For the case of the optimized realignment, create the first vector
       load at the loop preheader.  */

@@ -5813,6 +5820,7 @@ vect_setup_realignment (vec_info *vinfo, stmt_vec_info stmt_info,
       new_stmt = gimple_build_assign (vec_dest, data_ref);
       new_temp = make_ssa_name (vec_dest, new_stmt);
       gimple_assign_set_lhs (new_stmt, new_temp);
+      gimple_set_vuse (new_stmt, vuse);
       if (pe)
         {
           new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);
--
2.35.3

The following fixes the last commit to honor the case we are not
vectorizing a loop.

Bootstrapped on x86_64-unknown-linux-gnu, pushed.

	PR tree-optimization/106228
	* tree-vect-data-refs.cc (vect_setup_realignment): Adjust
	VUSE compute for the non-loop case.
---
 gcc/tree-vect-data-refs.cc | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/gcc/tree-vect-data-refs.cc b/gcc/tree-vect-data-refs.cc
index 53e52cb58cb..609cacc4971 100644
--- a/gcc/tree-vect-data-refs.cc
+++ b/gcc/tree-vect-data-refs.cc
@@ -5777,14 +5777,14 @@ vect_setup_realignment (vec_info *vinfo, stmt_vec_info stmt_info,
   if (at_loop)
     *at_loop = loop_for_initial_load;

+  tree vuse = NULL_TREE;
   if (loop_for_initial_load)
-    pe = loop_preheader_edge (loop_for_initial_load);
-
-  tree vuse;
-  gphi *vphi = get_virtual_phi (loop_for_initial_load->header);
-  if (vphi)
-    vuse = PHI_ARG_DEF_FROM_EDGE (vphi, pe);
-  else
+    {
+      pe = loop_preheader_edge (loop_for_initial_load);
+      if (gphi *vphi = get_virtual_phi (loop_for_initial_load->header))
+	vuse = PHI_ARG_DEF_FROM_EDGE (vphi, pe);
+    }
+  if (!vuse)
     vuse = gimple_vuse (gsi_stmt (*gsi));

   /* 3. For the case of the optimized realignment, create the first vector
--
2.35.3

When working on a smaller region like a loop version copy the main
time spent is now dominance fast query recompute which does a full
function DFS walk.  The dominance queries within the region of
interest should be O(log n) without fast queries and we should do
on the order of O(n) of them which overall means reasonable
complexity.

For the artificial testcase I'm looking at this shaves off
considerable time again.

Bootstrapped and tested on x86_64-unknown-linux-gnu, pushed.

	* tree-into-ssa.cc (update_ssa): Do not forcefully
	re-compute dominance fast queries for TODO_update_ssa_no_phi.
---
 gcc/tree-into-ssa.cc | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/gcc/tree-into-ssa.cc b/gcc/tree-into-ssa.cc
index be71b629f97..d13fb720b37 100644
--- a/gcc/tree-into-ssa.cc
+++ b/gcc/tree-into-ssa.cc
@@ -3451,11 +3451,13 @@ update_ssa (unsigned update_flags)
     phis_to_rewrite.create (last_basic_block_for_fn (cfun) + 1);
   blocks_to_update = BITMAP_ALLOC (NULL);

-  /* Ensure that the dominance information is up-to-date.  */
-  calculate_dominance_info (CDI_DOMINATORS);
-
   insert_phi_p = (update_flags != TODO_update_ssa_no_phi);

+  /* Ensure that the dominance information is up-to-date and when we
+     are going to compute dominance frontiers fast queries are possible.  */
+  if (insert_phi_p || dom_info_state (CDI_DOMINATORS) == DOM_NONE)
+    calculate_dominance_info (CDI_DOMINATORS);
+
   /* If there are names defined in the replacement table, prepare
      definition and use sites for all the names in NEW_SSA_NAMES and
      OLD_SSA_NAMES.  */
--
2.35.3

Here we incorrectly deem the calls to func1, func2 and tmpl2 as
ambiguous ahead of time ultimately because we mishandle dependence
of a constrained member function from the current instantiation.

In type_dependent_expression_p, we consider the dependence of a
TEMPLATE_DECL's constraints (via uses_outer_template_parms), but
neglect to do the same for a FUNCTION_DECL such as func1.

And in satisfy_declaration_constraints, we give up if _any_ template
argument is dependent, but for non-dependent member functions from
the current instantiation such as func2 and tmpl2, we can and must
check constraints as long as the innermost arguments aren't dependent.

Tested on x86_64-pc-linux-gnu, does this look OK for trunk/12?

	PR c++/105842

gcc/cp/ChangeLog:

	* constraint.cc (satisfy_declaration_constraints): Refine
	early exit test for argument dependence.
	* cp-tree.h (uses_outer_template_parms_in_constraints): Declare.
	* pt.cc (template_class_depth): Handle TI_TEMPLATE being a
	FIELD_DECL.
	(usse_outer_template_parms): Factor out constraint dependence
	check to ...
	(uses_outer_template_parms_in_constraints): ... here.
	(type_dependent_expression_p): Use it for FUNCTION_DECL.

gcc/testsuite/ChangeLog:

	* g++.dg/cpp2a/concepts-memtmpl6.C: New test.
---
 gcc/cp/constraint.cc                          | 20 +++++++----
 gcc/cp/cp-tree.h                              |  1 +
 gcc/cp/pt.cc                                  | 34 ++++++++++++++++---
 .../g++.dg/cpp2a/concepts-memtmpl6.C          | 34 +++++++++++++++++++
 4 files changed, 79 insertions(+), 10 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl6.C

diff --git a/gcc/cp/constraint.cc b/gcc/cp/constraint.cc
index 591155cee22..99b97d24eae 100644
--- a/gcc/cp/constraint.cc
+++ b/gcc/cp/constraint.cc
@@ -3176,9 +3176,13 @@ satisfy_declaration_constraints (tree t, sat_info info)
 	args = regen_args;
     }

-  /* If any arguments depend on template parameters, we can't
-     check constraints. Pretend they're satisfied for now.  */
-  if (uses_template_parms (args))
+  /* If the innermost arguments are dependent, or if the outer arguments
+     are dependent and are needed by the constraints, we can't check
+     satisfaction yet so pretend they're satisfied for now.  */
+  if (uses_template_parms (args)
+      && (TMPL_ARGS_DEPTH (args) == 1
+	  || uses_template_parms (INNERMOST_TEMPLATE_ARGS (args))
+	  || uses_outer_template_parms_in_constraints (t)))
     return boolean_true_node;

   /* Get the normalized constraints.  */
@@ -3240,9 +3244,13 @@ satisfy_declaration_constraints (tree t, tree args, sat_info info)
   else
     args = add_outermost_template_args (t, args);

-  /* If any arguments depend on template parameters, we can't
-     check constraints. Pretend they're satisfied for now.  */
-  if (uses_template_parms (args))
+  /* If the innermost arguments are dependent, or if the outer arguments
+     are dependent and are needed by the constraints, we can't check
+     satisfaction yet so pretend they're satisfied for now.  */
+  if (uses_template_parms (args)
+      && (TMPL_ARGS_DEPTH (args) == 1
+	  || uses_template_parms (INNERMOST_TEMPLATE_ARGS (args))
+	  || uses_outer_template_parms_in_constraints (t)))
     return boolean_true_node;

   tree result = boolean_true_node;
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 2fde4f83b41..bec98aa2ac3 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -7297,6 +7297,7 @@ extern tree lookup_template_function		(tree, tree);
 extern tree lookup_template_variable		(tree, tree);
 extern bool uses_template_parms			(tree);
 extern bool uses_template_parms_level		(tree, int);
+extern bool uses_outer_template_parms_in_constraints (tree);
 extern bool in_template_function		(void);
 extern bool need_generic_capture		(void);
 extern tree instantiate_class_template		(tree);
diff --git a/gcc/cp/pt.cc b/gcc/cp/pt.cc
index 59ee50c152d..de5d3a5cd78 100644
--- a/gcc/cp/pt.cc
+++ b/gcc/cp/pt.cc
@@ -391,7 +391,9 @@ template_class_depth (tree type)
     {
       tree tinfo = get_template_info (type);

-      if (tinfo && PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo))
+      if (tinfo
+	  && TREE_CODE (TI_TEMPLATE (tinfo)) == TEMPLATE_DECL
+	  && PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo))
 	  && uses_template_parms (INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo))))
 	++depth;

@@ -11011,7 +11013,7 @@ uses_template_parms_level (tree t, int level)
 /* Returns true if the signature of DECL depends on any template parameter from
    its enclosing class.  */

-bool
+static bool
 uses_outer_template_parms (tree decl)
 {
   int depth = template_class_depth (CP_DECL_CONTEXT (decl));
@@ -11042,11 +11044,27 @@ uses_outer_template_parms (tree decl)
 	    return true;
 	}
     }
+  if (uses_outer_template_parms_in_constraints (decl))
+    return true;
+  return false;
+}
+
+/* Returns true if the constraints of DECL depend on any template parameters
+   from its enclosing scope.  */
+
+bool
+uses_outer_template_parms_in_constraints (tree decl)
+{
   tree ci = get_constraints (decl);
   if (ci)
     ci = CI_ASSOCIATED_CONSTRAINTS (ci);
-  if (ci && for_each_template_parm (ci, template_parm_outer_level,
-				    &depth, NULL, /*nondeduced*/true))
+  if (!ci)
+    return false;
+  int depth = template_class_depth (CP_DECL_CONTEXT (decl));
+  if (depth == 0)
+    return false;
+  if (for_each_template_parm (ci, template_parm_outer_level,
+			      &depth, NULL, /*nondeduced*/true))
     return true;
   return false;
 }
@@ -28103,6 +28121,14 @@ type_dependent_expression_p (tree expression)
       return false;
     }

+  /* Otherwise, its constraints could still depend on outer template parameters
+     from its (dependent) scope.  */
+  if (TREE_CODE (expression) == FUNCTION_DECL
+      /* Check this sufficient condition first, as a minor optimization.  */
+      && !dependent_type_p (TREE_TYPE (expression))
+      && uses_outer_template_parms_in_constraints (expression))
+    return true;
+
   /* Always dependent, on the number of arguments if nothing else.  */
   if (TREE_CODE (expression) == EXPR_PACK_EXPANSION)
     return true;
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl6.C b/gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl6.C
new file mode 100644
index 00000000000..0e09ae6ed4c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-memtmpl6.C
@@ -0,0 +1,34 @@
+// PR c++/105842
+// { dg-do compile { target c++20 } }
+
+template<class T>
+struct S {
+  static void func1() requires __is_same(T, int);
+  static void func1() requires (!__is_same(T, int));
+
+  static void func2() requires false && false;
+  static void func2() requires false;
+
+  template<class...> static void tmpl1() requires __is_same(T, int);
+  template<class...> static void tmpl1() requires (!__is_same(T, int));
+
+  template<class... Us> static void tmpl2() requires (sizeof...(Us) == 1);
+  template<class... Us> static void tmpl2() requires (sizeof...(Us) == 2);
+
+  static void foo() {
+    // Both calls resolve to the first overload at instantiation time.
+    func1();
+    tmpl1();
+  }
+
+  static void bar() {
+    // We can check and reject both calls ahead of time since the functions'
+    // constraints don't depend on outer template parameters.
+    func2(); // { dg-error "no match" }
+    tmpl2(); // { dg-error "no match" }
+  }
+};
+
+int main() {
+  S<int>::foo();
+}
--
2.37.0.3.g30cc8d0f14

Here we were crashing when substituting a non-dependent call to a
consteval operator, whose CALL_EXPR_OPERATOR_SYNTAX flag we try to
propagate to the result, but the result isn't a CALL_EXPR since the
called function is consteval.  This patch fixes this by checking the
result of extract_call_expr accordingly.  (Note that we can't easily
check DECL_IMMEDIATE_FUNCTION_P here because we don't know which
function was selected by overload resolution from this call frame.)

Bootstrapped and regtested on x86_64-pc-linux-gnu, does this look OK
for trunk/12?

	PR c++/105912

gcc/cp/ChangeLog:

	* pt.cc (tsubst_copy_and_build) <case CALL_EXPR>: Guard against
	NULL_TREE extract_call_expr result.

gcc/testsuite/ChangeLog:

	* g++.dg/cpp2a/consteval31.C: New test.
---
 gcc/cp/pt.cc                             | 10 +++++----
 gcc/testsuite/g++.dg/cpp2a/consteval31.C | 26 ++++++++++++++++++++++++
 2 files changed, 32 insertions(+), 4 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp2a/consteval31.C

diff --git a/gcc/cp/pt.cc b/gcc/cp/pt.cc
index 232964c2831..8a6ae5c42fe 100644
--- a/gcc/cp/pt.cc
+++ b/gcc/cp/pt.cc
@@ -21207,10 +21207,12 @@ tsubst_copy_and_build (tree t,
 	    bool rev = CALL_EXPR_REVERSE_ARGS (t);
 	    if (op || ord || rev)
 	      {
-		function = extract_call_expr (ret);
-		CALL_EXPR_OPERATOR_SYNTAX (function) = op;
-		CALL_EXPR_ORDERED_ARGS (function) = ord;
-		CALL_EXPR_REVERSE_ARGS (function) = rev;
+		if (tree call = extract_call_expr (ret))
+		  {
+		    CALL_EXPR_OPERATOR_SYNTAX (call) = op;
+		    CALL_EXPR_ORDERED_ARGS (call) = ord;
+		    CALL_EXPR_REVERSE_ARGS (call) = rev;
+		  }
 	      }
 	  }

diff --git a/gcc/testsuite/g++.dg/cpp2a/consteval31.C b/gcc/testsuite/g++.dg/cpp2a/consteval31.C
new file mode 100644
index 00000000000..85a4d1794e5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/consteval31.C
@@ -0,0 +1,26 @@
+// PR c++/105912
+// { dg-do compile { target c++20 } }
+
+struct A {
+  consteval A operator+() {
+    return {};
+  }
+};
+
+consteval A operator~(A) {
+  return {};
+}
+
+consteval A operator+(A, A) {
+  return {};
+}
+
+template<class>
+void f() {
+  A a;
+  ~a;
+  a + a;
+  +a;
+}
+
+template void f<int>();
--
2.37.0.3.g30cc8d0f14
