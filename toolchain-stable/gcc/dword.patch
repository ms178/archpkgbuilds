diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index df5c80d..af11669 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -20918,6 +20918,19 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,
 	  return true;
 	}

+      if (SCALAR_INT_MODE_P (GET_MODE (op0))
+	  && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)
+	{
+	  if (op1 == const0_rtx)
+	    *total = cost->add
+		     + rtx_cost (op0, GET_MODE (op0), outer_code, opno, speed);
+	  else
+	    *total = 3*cost->add
+		     + rtx_cost (op0, GET_MODE (op0), outer_code, opno, speed)
+		     + rtx_cost (op1, GET_MODE (op0), outer_code, opno, speed);
+	  return true;
+	}
+
       /* The embedded comparison operand is completely free.  */
       if (!general_operand (op0, GET_MODE (op0)) && op1 == const0_rtx)
 	*total = 0;
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 2b1d65b..502416b 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -9785,9 +9785,24 @@
    (set (reg:CCZ FLAGS_REG)
 	(compare:CCZ (and:SWI (match_dup 2) (match_dup 1))
 		     (const_int 0)))]
-{
-  operands[2] = gen_reg_rtx (<MODE>mode);
-})
+  "operands[2] = gen_reg_rtx (<MODE>mode);")
+
+;; Split and;cmp (as optimized by combine) into andn;cmp $0
+(define_insn_and_split "*test<mode>_not_doubleword"
+  [(set (reg:CCZ FLAGS_REG)
+	(compare:CCZ
+	  (and:DWI
+	    (not:DWI (match_operand:DWI 0 "register_operand"))
+	    (match_operand:DWI 1 "nonimmediate_operand"))
+	  (const_int 0)))]
+  "ix86_pre_reload_split ()"
+  "#"
+  "&& 1"
+  [(parallel
+      [(set (match_dup 2) (and:DWI (not:DWI (match_dup 0)) (match_dup 1)))
+       (clobber (reg:CC FLAGS_REG))])
+   (set (reg:CCZ FLAGS_REG) (compare:CCZ (match_dup 2) (const_int 0)))]
+  "operands[2] = gen_reg_rtx (<MODE>mode);")

 ;; Convert HImode/SImode test instructions with immediate to QImode ones.
 ;; i386 does not allow to encode test with 8bit sign extended immediate, so
@@ -9846,19 +9861,21 @@
 ;; it should be done with splitters.

 (define_expand "and<mode>3"
-  [(set (match_operand:SWIM1248x 0 "nonimmediate_operand")
-	(and:SWIM1248x (match_operand:SWIM1248x 1 "nonimmediate_operand")
-		       (match_operand:SWIM1248x 2 "<general_szext_operand>")))]
+  [(set (match_operand:SWIDWI 0 "nonimmediate_operand")
+	(and:SWIDWI (match_operand:SWIDWI 1 "nonimmediate_operand")
+		    (match_operand:SWIDWI 2 "<general_operand>")))]
   ""
 {
   machine_mode mode = <MODE>mode;

-  if (<MODE>mode == DImode && !TARGET_64BIT)
-    ;
-  else if (const_int_operand (operands[2], <MODE>mode)
-	   && register_operand (operands[0], <MODE>mode)
-	   && !(TARGET_ZERO_EXTEND_WITH_AND
-		&& optimize_function_for_speed_p (cfun)))
+  if (!x86_64_hilo_general_operand (operands[2], <MODE>mode))
+    operands[2] = force_reg (<MODE>mode, operands[2]);
+
+  if (GET_MODE_SIZE (<MODE>mode) <= UNITS_PER_WORD
+      && const_int_operand (operands[2], <MODE>mode)
+      && register_operand (operands[0], <MODE>mode)
+      && !(TARGET_ZERO_EXTEND_WITH_AND
+	   && optimize_function_for_speed_p (cfun)))
     {
       unsigned HOST_WIDE_INT ival = UINTVAL (operands[2]);

@@ -9880,34 +9897,38 @@
   DONE;
 })

-(define_insn_and_split "*anddi3_doubleword"
-  [(set (match_operand:DI 0 "nonimmediate_operand")
-	(and:DI
-	 (match_operand:DI 1 "nonimmediate_operand")
-	 (match_operand:DI 2 "x86_64_szext_general_operand")))
+(define_insn_and_split "*and<dwi>3_doubleword"
+  [(set (match_operand:<DWI> 0 "nonimmediate_operand")
+	(and:<DWI>
+	 (match_operand:<DWI> 1 "nonimmediate_operand")
+	 (match_operand:<DWI> 2 "<general_operand>")))
    (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT
-   && ix86_binary_operator_ok (AND, DImode, operands)
+  "ix86_binary_operator_ok (AND, <DWI>mode, operands)
    && ix86_pre_reload_split ()"
   "#"
   "&& 1"
-  [(const_int 0)]
+  [(parallel
+    [(set (match_dup 0) (and:DWIH (match_dup 1) (match_dup 2)))
+     (clobber (reg:CC FLAGS_REG))])
+   (parallel
+    [(set (match_dup 3) (and:DWIH (match_dup 4) (match_dup 5)))
+     (clobber (reg:CC FLAGS_REG))])]
 {
-  split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);
+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);

   if (operands[2] == const0_rtx)
     emit_move_insn (operands[0], const0_rtx);
   else if (operands[2] == constm1_rtx)
     emit_move_insn (operands[0], operands[1]);
   else
-    emit_insn (gen_andsi3 (operands[0], operands[1], operands[2]));
+    ix86_expand_binary_operator (AND, <MODE>mode, &operands[0]);

   if (operands[5] == const0_rtx)
     emit_move_insn (operands[3], const0_rtx);
   else if (operands[5] == constm1_rtx)
     emit_move_insn (operands[3], operands[4]);
   else
-    emit_insn (gen_andsi3 (operands[3], operands[4], operands[5]));
+    ix86_expand_binary_operator (AND, <MODE>mode, &operands[3]);

   DONE;
 })
@@ -10391,53 +10412,52 @@
   operands[2] = gen_int_mode (INTVAL (operands[2]), QImode);
 })

-(define_insn "*andndi3_doubleword"
-  [(set (match_operand:DI 0 "register_operand")
-	(and:DI
-	  (not:DI (match_operand:DI 1 "register_operand"))
-	  (match_operand:DI 2 "nonimmediate_operand")))
+(define_insn "*andn<mode>3_doubleword"
+  [(set (match_operand:DWI 0 "register_operand")
+	(and:DWI
+	  (not:DWI (match_operand:DWI 1 "register_operand"))
+	  (match_operand:DWI 2 "nonimmediate_operand")))
    (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT && TARGET_STV && TARGET_SSE2
-   && ix86_pre_reload_split ()"
+  "ix86_pre_reload_split ()"
   "#")

 (define_split
-  [(set (match_operand:DI 0 "register_operand")
-	(and:DI
-	  (not:DI (match_operand:DI 1 "register_operand"))
-	  (match_operand:DI 2 "nonimmediate_operand")))
+  [(set (match_operand:<DWI> 0 "register_operand")
+	(and:<DWI>
+	  (not:<DWI> (match_operand:<DWI> 1 "register_operand"))
+	  (match_operand:<DWI> 2 "nonimmediate_operand")))
    (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT && TARGET_BMI && TARGET_STV && TARGET_SSE2
+  "TARGET_BMI
    && can_create_pseudo_p ()"
   [(parallel [(set (match_dup 0)
-		   (and:SI (not:SI (match_dup 1)) (match_dup 2)))
+		   (and:DWIH (not:DWIH (match_dup 1)) (match_dup 2)))
 	      (clobber (reg:CC FLAGS_REG))])
    (parallel [(set (match_dup 3)
-		   (and:SI (not:SI (match_dup 4)) (match_dup 5)))
+		   (and:DWIH (not:DWIH (match_dup 4)) (match_dup 5)))
 	      (clobber (reg:CC FLAGS_REG))])]
-  "split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);")
+  "split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);")

 (define_split
-  [(set (match_operand:DI 0 "register_operand")
-	(and:DI
-	  (not:DI (match_operand:DI 1 "register_operand"))
-	  (match_operand:DI 2 "nonimmediate_operand")))
+  [(set (match_operand:<DWI> 0 "register_operand")
+	(and:<DWI>
+	  (not:<DWI> (match_operand:<DWI> 1 "register_operand"))
+	  (match_operand:<DWI> 2 "nonimmediate_operand")))
    (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT && !TARGET_BMI && TARGET_STV && TARGET_SSE2
+  "!TARGET_BMI
    && can_create_pseudo_p ()"
-  [(set (match_dup 6) (not:SI (match_dup 1)))
+  [(set (match_dup 6) (not:DWIH (match_dup 1)))
    (parallel [(set (match_dup 0)
-		   (and:SI (match_dup 6) (match_dup 2)))
+		   (and:DWIH (match_dup 6) (match_dup 2)))
 	      (clobber (reg:CC FLAGS_REG))])
-   (set (match_dup 7) (not:SI (match_dup 4)))
+   (set (match_dup 7) (not:DWIH (match_dup 4)))
    (parallel [(set (match_dup 3)
-		   (and:SI (match_dup 7) (match_dup 5)))
+		   (and:DWIH (match_dup 7) (match_dup 5)))
 	      (clobber (reg:CC FLAGS_REG))])]
 {
-  operands[6] = gen_reg_rtx (SImode);
-  operands[7] = gen_reg_rtx (SImode);
+  operands[6] = gen_reg_rtx (<MODE>mode);
+  operands[7] = gen_reg_rtx (<MODE>mode);

-  split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);
+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);
 })

 (define_insn "*andn<mode>_1"
@@ -10532,26 +10552,35 @@
 ;; If this is considered useful, it should be done with splitters.

 (define_expand "<code><mode>3"
-  [(set (match_operand:SWIM1248x 0 "nonimmediate_operand")
-	(any_or:SWIM1248x (match_operand:SWIM1248x 1 "nonimmediate_operand")
-			  (match_operand:SWIM1248x 2 "<general_operand>")))]
+  [(set (match_operand:SWIDWI 0 "nonimmediate_operand")
+	(any_or:SWIDWI (match_operand:SWIDWI 1 "nonimmediate_operand")
+		       (match_operand:SWIDWI 2 "<general_hilo_operand>")))]
   ""
-  "ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;")
+{
+  if (!x86_64_hilo_general_operand (operands[2], <MODE>mode))
+    operands[2] = force_reg (<MODE>mode, operands[2]);
+  ix86_expand_binary_operator (<CODE>, <MODE>mode, operands);
+  DONE;
+})

-(define_insn_and_split "*<code>di3_doubleword"
-  [(set (match_operand:DI 0 "nonimmediate_operand")
-	(any_or:DI
-	 (match_operand:DI 1 "nonimmediate_operand")
-	 (match_operand:DI 2 "x86_64_szext_general_operand")))
+(define_insn_and_split "*<code><dwi>3_doubleword"
+  [(set (match_operand:<DWI> 0 "nonimmediate_operand")
+	(any_or:<DWI>
+	 (match_operand:<DWI> 1 "nonimmediate_operand")
+	 (match_operand:<DWI> 2 "<general_hilo_operand>")))
    (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT
-   && ix86_binary_operator_ok (<CODE>, DImode, operands)
+  "ix86_binary_operator_ok (<CODE>, <DWI>mode, operands)
    && ix86_pre_reload_split ()"
   "#"
   "&& 1"
-  [(const_int 0)]
+  [(parallel
+    [(set (match_dup 0) (any_or:DWIH (match_dup 1) (match_dup 2)))
+     (clobber (reg:CC FLAGS_REG))])
+   (parallel
+    [(set (match_dup 3) (any_or:DWIH (match_dup 4) (match_dup 5)))
+     (clobber (reg:CC FLAGS_REG))])]
 {
-  split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);
+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);

   if (operands[2] == const0_rtx)
     emit_move_insn (operands[0], operands[1]);
@@ -10560,10 +10589,10 @@
       if (<CODE> == IOR)
 	emit_move_insn (operands[0], constm1_rtx);
       else
-	ix86_expand_unary_operator (NOT, SImode, &operands[0]);
+	ix86_expand_unary_operator (NOT, <MODE>mode, &operands[0]);
     }
   else
-    ix86_expand_binary_operator (<CODE>, SImode, &operands[0]);
+    ix86_expand_binary_operator (<CODE>, <MODE>mode, &operands[0]);

   if (operands[5] == const0_rtx)
     emit_move_insn (operands[3], operands[4]);
@@ -10572,10 +10601,10 @@
       if (<CODE> == IOR)
 	emit_move_insn (operands[3], constm1_rtx);
       else
-	ix86_expand_unary_operator (NOT, SImode, &operands[3]);
+	ix86_expand_unary_operator (NOT, <MODE>mode, &operands[3]);
     }
   else
-    ix86_expand_binary_operator (<CODE>, SImode, &operands[3]);
+    ix86_expand_binary_operator (<CODE>, <MODE>mode, &operands[3]);

   DONE;
 })
diff --git a/gcc/testsuite/gcc.target/i386/testnot-3.c b/gcc/testsuite/gcc.target/i386/testnot-3.c
new file mode 100644
index 0000000..56438df
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/testnot-3.c
@@ -0,0 +1,10 @@
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O2" } */
+
+int foo(__int128 x, __int128 y)
+{
+  return (x & y) == y;
+}
+
+/* { dg-final { scan-assembler-times "notq" 2 } } */
+/* { dg-final { scan-assembler-not "xorq" } } */

diff --git a/gcc/calls.cc b/gcc/calls.cc
index a4336c1..f4e1299 100644
--- a/gcc/calls.cc
+++ b/gcc/calls.cc
@@ -2186,10 +2186,11 @@ load_register_parameters (struct arg_data *args, int num_actuals,
 		   && immediate_const_ctor_p (DECL_INITIAL (tree_value)))
 	    {
 	      rtx target = gen_reg_rtx (word_mode);
-	      rtx x = expand_expr (DECL_INITIAL (tree_value),
-				   target, word_mode, EXPAND_NORMAL);
+	      store_constructor (DECL_INITIAL (tree_value), target, 0,
+				 int_expr_size (DECL_INITIAL (tree_value)),
+				 false);
 	      reg = gen_rtx_REG (word_mode, REGNO (reg));
-	      emit_move_insn (reg, x);
+	      emit_move_insn (reg, target);
 	    }
 	  else if (partial == 0 || args[i].pass_on_stack)
 	    {
diff --git a/gcc/expr.cc b/gcc/expr.cc
index fb062dc..85cb414 100644
--- a/gcc/expr.cc
+++ b/gcc/expr.cc
@@ -84,7 +84,6 @@ static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);
 static void clear_by_pieces (rtx, unsigned HOST_WIDE_INT, unsigned int);
 static rtx_insn *compress_float_constant (rtx, rtx);
 static rtx get_subtarget (rtx);
-static void store_constructor (tree, rtx, int, poly_int64, bool);
 static rtx store_field (rtx, poly_int64, poly_int64, poly_uint64, poly_uint64,
 			machine_mode, tree, alias_set_type, bool, bool);

@@ -100,7 +99,6 @@ static void do_tablejump (rtx, machine_mode, rtx, rtx, rtx,
 			  profile_probability);
 static rtx const_vector_from_tree (tree);
 static tree tree_expr_size (const_tree);
-static HOST_WIDE_INT int_expr_size (const_tree);
 static void convert_mode_scalar (rtx, rtx, int);


@@ -6757,7 +6755,7 @@ fields_length (const_tree type)
    which has been packed to exclude padding bits.
    If REVERSE is true, the store is to be done in reverse order.  */

-static void
+void
 store_constructor (tree exp, rtx target, int cleared, poly_int64 size,
 		   bool reverse)
 {
@@ -13209,7 +13207,7 @@ expr_size (tree exp)
 /* Return a wide integer for the size in bytes of the value of EXP, or -1
    if the size can vary or is larger than an integer.  */

-static HOST_WIDE_INT
+HOST_WIDE_INT
 int_expr_size (const_tree exp)
 {
   tree size;
diff --git a/gcc/expr.h b/gcc/expr.h
index d777c28..0351183 100644
--- a/gcc/expr.h
+++ b/gcc/expr.h
@@ -339,6 +339,8 @@ extern bool categorize_ctor_elements (const_tree, HOST_WIDE_INT *,
 				      HOST_WIDE_INT *, HOST_WIDE_INT *,
 				      bool *);
 extern bool immediate_const_ctor_p (const_tree, unsigned int words = 1);
+extern void store_constructor (tree, rtx, int, poly_int64, bool);
+extern HOST_WIDE_INT int_expr_size (const_tree exp);

 extern void expand_operands (tree, tree, rtx, rtx*, rtx*,
 			     enum expand_modifier);
diff --git a/gcc/testsuite/gcc.dg/pr105853.c b/gcc/testsuite/gcc.dg/pr105853.c
new file mode 100644
index 0000000..4f234ac
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105853.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct {
+  struct {
+    short e16[3];
+  }
+} const eth_addr_zero = {{}};  /* { dg-warning "no semicolon at" } */
+void compose_nd_na_ipv6_src() {
+  packet_set_nd(eth_addr_zero); /* { dg-warning "implicit declaration" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr105856.c b/gcc/testsuite/gcc.dg/pr105856.c
new file mode 100644
index 0000000..dd3aa2f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105856.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+#pragma pack(1)
+struct {
+  unsigned f0;
+} static g_251 = {6};
+void g_329_3() {
+  func_19(g_251);  /* { dg-warning "implicit declaration" } */
+}
+

The code to remove LC PHI nodes in clean_up_loop_closed_phi does not handle
virtual operands because may_propagate_copy generally returns false
for them.  The following copies the merge_blocks variant for
dealing with them.

This fixes a missed jump threading in gcc.dg/auto-init-uninit-4.c
which manifests in bogus uninit diagnostics.

Bootstrap and regtest pending on x86_64-unknown-linux-gnu.

	PR tree-optimization/106186
	* tree-ssa-propagate.cc (clean_up_loop_closed_phi):
	Properly handle virtual PHI nodes.
---
 gcc/tree-ssa-propagate.cc | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/gcc/tree-ssa-propagate.cc b/gcc/tree-ssa-propagate.cc
index 163b24f0e69..9dc4bfd85bf 100644
--- a/gcc/tree-ssa-propagate.cc
+++ b/gcc/tree-ssa-propagate.cc
@@ -1272,7 +1272,21 @@ clean_up_loop_closed_phi (function *fun)
 	      rhs = gimple_phi_arg_def (phi, 0);
 	      lhs = gimple_phi_result (phi);

-	      if (rhs && may_propagate_copy (lhs, rhs))
+	      if (virtual_operand_p (rhs))
+		{
+		  imm_use_iterator iter;
+		  use_operand_p use_p;
+		  gimple *stmt;
+
+		  FOR_EACH_IMM_USE_STMT (stmt, iter, lhs)
+		    FOR_EACH_IMM_USE_ON_STMT (use_p, iter)
+		      SET_USE (use_p, rhs);
+
+		  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))
+		    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;
+		  remove_phi_node (&gsi, true);
+		}
+	      else if (may_propagate_copy (lhs, rhs))
 		{
 		  /* Dump details.  */
 		  if (dump_file && (dump_flags & TDF_DETAILS))
--
2.35.3
