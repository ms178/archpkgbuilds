--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -8465,7 +8465,7 @@
 			(zero_extend:<DWI> (match_dup 3)))
 	    (match_operand:QI 4 "const_int_operand" "n"))))]
   "TARGET_BMI2 && INTVAL (operands[4]) == <MODE_SIZE> * BITS_PER_UNIT
-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))"
+   && !(MEM_P (operands[2]) && MEM_P (operands[3]))"
   "mulx\t{%3, %0, %1|%1, %0, %3}"
   [(set_attr "type" "imulx")
    (set_attr "prefix" "vex")

diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 20c3b9a..d114754 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -10522,6 +10522,82 @@
    (set (match_dup 0) (match_op_dup 1
                         [(and:SI (match_dup 3) (match_dup 2))
 			 (const_int 0)]))])
+
+;; Variant 1 of 4: Split ((A | B) ^ A) ^ C as (B & ~A) ^ C.
+(define_split
+  [(set (match_operand:SWI48 0 "register_operand")
+	(xor:SWI48
+	   (xor:SWI48
+	      (ior:SWI48 (match_operand:SWI48 1 "register_operand")
+			 (match_operand:SWI48 2 "nonimmediate_operand"))
+	      (match_dup 1))
+	   (match_operand:SWI48 3 "nonimmediate_operand")))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_BMI"
+  [(parallel
+      [(set (match_dup 4) (and:SWI48 (not:SWI48 (match_dup 1)) (match_dup 2)))
+       (clobber (reg:CC FLAGS_REG))])
+   (parallel
+      [(set (match_dup 0) (xor:SWI48 (match_dup 4) (match_dup 3)))
+       (clobber (reg:CC FLAGS_REG))])]
+  "operands[4] = gen_reg_rtx (<MODE>mode);")
+
+;; Variant 2 of 4: Split ((A | B) ^ B) ^ C as (A & ~B) ^ C.
+(define_split
+  [(set (match_operand:SWI48 0 "register_operand")
+	(xor:SWI48
+	   (xor:SWI48
+	      (ior:SWI48 (match_operand:SWI48 1 "register_operand")
+			 (match_operand:SWI48 2 "register_operand"))
+	      (match_dup 2))
+	   (match_operand:SWI48 3 "nonimmediate_operand")))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_BMI"
+  [(parallel
+      [(set (match_dup 4) (and:SWI48 (not:SWI48 (match_dup 2)) (match_dup 1)))
+       (clobber (reg:CC FLAGS_REG))])
+   (parallel
+      [(set (match_dup 0) (xor:SWI48 (match_dup 4) (match_dup 3)))
+       (clobber (reg:CC FLAGS_REG))])]
+  "operands[4] = gen_reg_rtx (<MODE>mode);")
+
+;; Variant 3 of 4: Split ((A | B) ^ C) ^ A as (B & ~A) ^ C.
+(define_split
+  [(set (match_operand:SWI48 0 "register_operand")
+	(xor:SWI48
+	   (xor:SWI48
+	      (ior:SWI48 (match_operand:SWI48 1 "register_operand")
+			 (match_operand:SWI48 2 "nonimmediate_operand"))
+	      (match_operand:SWI48 3 "nonimmediate_operand"))
+	   (match_dup 1)))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_BMI"
+  [(parallel
+      [(set (match_dup 4) (and:SWI48 (not:SWI48 (match_dup 1)) (match_dup 2)))
+       (clobber (reg:CC FLAGS_REG))])
+   (parallel
+      [(set (match_dup 0) (xor:SWI48 (match_dup 4) (match_dup 3)))
+       (clobber (reg:CC FLAGS_REG))])]
+  "operands[4] = gen_reg_rtx (<MODE>mode);")
+
+;; Variant 4 of 4: Split ((A | B) ^ C) ^ B as (A & ~B) ^ C.
+(define_split
+  [(set (match_operand:SWI48 0 "register_operand")
+	(xor:SWI48
+	   (xor:SWI48
+	      (ior:SWI48 (match_operand:SWI48 1 "register_operand")
+			 (match_operand:SWI48 2 "register_operand"))
+	      (match_operand:SWI48 3 "nonimmediate_operand"))
+	   (match_dup 2)))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_BMI"
+  [(parallel
+      [(set (match_dup 4) (and:SWI48 (not:SWI48 (match_dup 2)) (match_dup 1)))
+       (clobber (reg:CC FLAGS_REG))])
+   (parallel
+      [(set (match_dup 0) (xor:SWI48 (match_dup 4) (match_dup 3)))
+       (clobber (reg:CC FLAGS_REG))])]
+  "operands[4] = gen_reg_rtx (<MODE>mode);")

 ;; Logical inclusive and exclusive OR instructions

diff --git a/gcc/testsuite/gcc.target/i386/bmi-andn-4.c b/gcc/testsuite/gcc.target/i386/bmi-andn-4.c
new file mode 100644
index 0000000..fb89529
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/bmi-andn-4.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mbmi" } */
+
+int f(int a, int b, int c)
+{
+    return (a ^ b) ^ (a | c);
+}
+
+/* { dg-final { scan-assembler "andn\[ \\t\]+" } } */
