diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index 30a9cd0..daa60ac 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -20738,70 +20738,125 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,
 	}

       if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))
-	{
-	  *total = cost->addss;
-	  return false;
-	}
+	*total = cost->addss;
       else if (X87_FLOAT_MODE_P (mode))
-	{
-	  *total = cost->fadd;
-	  return false;
-	}
+	*total = cost->fadd;
       else if (FLOAT_MODE_P (mode))
-	{
-	  *total = ix86_vec_cost (mode, cost->addss);
-	  return false;
-	}
-      /* FALLTHRU */
+	*total = ix86_vec_cost (mode, cost->addss);
+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	*total = ix86_vec_cost (mode, cost->sse_op);
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	*total = cost->add * 2;
+      else
+	*total = cost->add;
+      return false;

-    case AND:
     case IOR:
     case XOR:
-      if (GET_MODE_CLASS (mode) == MODE_INT
-	  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	*total = ix86_vec_cost (mode, cost->sse_op);
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	*total = cost->add * 2;
+      else
+	*total = cost->add;
+      return false;
+
+    case AND:
+      if (address_no_seg_operand (x, mode))
 	{
-	  *total = (cost->add * 2
-		    + (rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)
-		       << (GET_MODE (XEXP (x, 0)) != DImode))
-		    + (rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed)
-	               << (GET_MODE (XEXP (x, 1)) != DImode)));
+	  *total = cost->lea;
 	  return true;
 	}
-      else if (code == AND
-	       && address_no_seg_operand (x, mode))
+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
 	{
-	  *total = cost->lea;
-	  return true;
+	  /* pandn is a single instruction.  */
+	  if (GET_CODE (XEXP (x, 0)) == NOT)
+	    {
+	      *total = ix86_vec_cost (mode, cost->sse_op)
+		       + rtx_cost (XEXP (XEXP (x, 0), 0), mode,
+				   outer_code, opno, speed)
+		       + rtx_cost (XEXP (x, 1), mode,
+				   outer_code, opno, speed);
+	      return true;
+	    }
+	  else if (GET_CODE (XEXP (x, 1)) == NOT)
+	    {
+	      *total = ix86_vec_cost (mode, cost->sse_op)
+		       + rtx_cost (XEXP (x, 0), mode,
+				   outer_code, opno, speed)
+		       + rtx_cost (XEXP (XEXP (x, 1), 0), mode,
+				   outer_code, opno, speed);
+	      return true;
+	    }
+	  *total = ix86_vec_cost (mode, cost->sse_op);
 	}
-      /* FALLTHRU */
-
-    case NEG:
-      if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
 	{
-	  *total = cost->sse_op;
-	  return false;
+	  if (TARGET_BMI && GET_CODE (XEXP (x,0)) == NOT)
+	    {
+	      *total = cost->add * 2
+		       + rtx_cost (XEXP (XEXP (x, 0), 0), mode,
+				   outer_code, opno, speed)
+		       + rtx_cost (XEXP (x, 1), mode,
+				   outer_code, opno, speed);
+	      return true;
+	    }
+	  else if (TARGET_BMI && GET_CODE (XEXP (x, 1)) == NOT)
+	    {
+	      *total = cost->add * 2
+		       + rtx_cost (XEXP (x, 0), mode,
+				   outer_code, opno, speed)
+		       + rtx_cost (XEXP (XEXP (x, 1), 0), mode,
+				   outer_code, opno, speed);
+	      return true;
+	    }
+	  *total = cost->add * 2;
 	}
-      else if (X87_FLOAT_MODE_P (mode))
+      else if (TARGET_BMI && GET_CODE (XEXP (x,0)) == NOT)
 	{
-	  *total = cost->fchs;
-	  return false;
+	  *total = cost->add
+		   + rtx_cost (XEXP (XEXP (x, 0), 0), mode,
+			       outer_code, opno, speed)
+		   + rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed);
+	  return true;
 	}
-      else if (FLOAT_MODE_P (mode))
+      else if (TARGET_BMI && GET_CODE (XEXP (x,1)) == NOT)
 	{
-	  *total = ix86_vec_cost (mode, cost->sse_op);
-	  return false;
+	  *total = cost->add
+		   + rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)
+		   + rtx_cost (XEXP (XEXP (x, 1), 0), mode,
+			       outer_code, opno, speed);
+	  return true;
 	}
-      /* FALLTHRU */
+      else
+	*total = cost->add;
+      return false;

     case NOT:
       if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
-	*total = ix86_vec_cost (mode, cost->sse_op);
+	// vnot is pxor -1.
+	*total = ix86_vec_cost (mode, cost->sse_op) + 1;
       else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
 	*total = cost->add * 2;
       else
 	*total = cost->add;
       return false;

+    case NEG:
+      if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))
+	*total = cost->sse_op;
+      else if (X87_FLOAT_MODE_P (mode))
+	*total = cost->fchs;
+      else if (FLOAT_MODE_P (mode))
+	*total = ix86_vec_cost (mode, cost->sse_op);
+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	*total = ix86_vec_cost (mode, cost->sse_op);
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	*total = cost->add * 3;
+      else
+	*total = cost->add;
+      return false;
+
     case COMPARE:
       rtx op0, op1;
       op0 = XEXP (x, 0);

diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index 86752a6..e8a2229 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -20634,7 +20634,17 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,
 	        op0 = XEXP (op0, 0), mode = GET_MODE (op0);
 	    }

-  	  *total = (cost->mult_init[MODE_INDEX (mode)]
+	  int mult_init;
+	  // Double word multiplication requires 3 mults and 2 adds.
+	  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	    {
+	      mult_init = 3 * cost->mult_init[MODE_INDEX (word_mode)]
+			  + 2 * cost->add;
+	      nbits *= 3;
+	    }
+	  else mult_init = cost->mult_init[MODE_INDEX (mode)];
+
+  	  *total = (mult_init
 		    + nbits * cost->mult_bit
 	            + rtx_cost (op0, mode, outer_code, opno, speed)
 		    + rtx_cost (op1, mode, outer_code, opno, speed));

diff --git a/gcc/tree-ssa-strlen.cc b/gcc/tree-ssa-strlen.cc
index 7370516..d2db197 100644
--- a/gcc/tree-ssa-strlen.cc
+++ b/gcc/tree-ssa-strlen.cc
@@ -3810,9 +3810,44 @@ strlen_pass::handle_builtin_memset (bool *zero_write)
 {
   gimple *memset_stmt = gsi_stmt (m_gsi);
   tree ptr = gimple_call_arg (memset_stmt, 0);
+  tree memset_val = gimple_call_arg (memset_stmt, 1);
+  tree memset_size = gimple_call_arg (memset_stmt, 2);
+
   /* Set to the non-constant offset added to PTR.  */
   wide_int offrng[2];
   int idx1 = get_stridx (ptr, memset_stmt, offrng, ptr_qry.rvals);
+  if (idx1 == 0
+      && TREE_CODE (memset_val) == INTEGER_CST
+      && ((TREE_CODE (memset_size) == INTEGER_CST
+	   && !integer_zerop (memset_size))
+	  || TREE_CODE (memset_size) == SSA_NAME))
+    {
+      unsigned HOST_WIDE_INT mask = (HOST_WIDE_INT_1U << CHAR_TYPE_SIZE) - 1;
+      bool full_string_p = (wi::to_wide (memset_val) & mask) == 0;
+
+      /* We only handle symbolic lengths when writing non-zero values.  */
+      if (full_string_p && TREE_CODE (memset_size) != INTEGER_CST)
+	return false;
+
+      idx1 = new_stridx (ptr);
+      if (idx1 == 0)
+	return false;
+      tree newlen;
+      if (full_string_p)
+	newlen = build_int_cst (size_type_node, 0);
+      else if (TREE_CODE (memset_size) == INTEGER_CST)
+	newlen = fold_convert (size_type_node, memset_size);
+      else
+	newlen = memset_size;
+
+      strinfo *dsi = new_strinfo (ptr, idx1, newlen, full_string_p);
+      set_strinfo (idx1, dsi);
+      find_equal_ptrs (ptr, idx1);
+      dsi->dont_invalidate = true;
+      dsi->writable = true;
+      return false;
+    }
+
   if (idx1 <= 0)
     return false;
   strinfo *si1 = get_strinfo (idx1);
@@ -3825,7 +3860,6 @@ strlen_pass::handle_builtin_memset (bool *zero_write)
   if (!valid_builtin_call (alloc_stmt))
     return false;
   tree alloc_size = gimple_call_arg (alloc_stmt, 0);
-  tree memset_size = gimple_call_arg (memset_stmt, 2);

   /* Check for overflow.  */
   maybe_warn_overflow (memset_stmt, false, memset_size, NULL, false, true);
@@ -3841,7 +3875,7 @@ strlen_pass::handle_builtin_memset (bool *zero_write)
     return false;

   /* Bail when the call writes a non-zero value.  */
-  if (!integer_zerop (gimple_call_arg (memset_stmt, 1)))
+  if (!integer_zerop (memset_val))
     return false;

   /* Let the caller know the memset call cleared the destination.  */
@@ -5093,8 +5127,9 @@ strlen_pass::handle_store (bool *zero_write)
 	  return false;
 	}

-      if (storing_all_zeros_p
-	  || storing_nonzero_p
+      if (storing_nonzero_p
+	  || storing_all_zeros_p
+	  || (full_string_p && lenrange[1] == 0)
 	  || (offset != 0 && store_before_nul[1] > 0))
 	{
 	  /* When STORING_NONZERO_P, we know that the string will start
@@ -5104,8 +5139,9 @@ strlen_pass::handle_store (bool *zero_write)
 	     of leading non-zero characters and set si->NONZERO_CHARS to
 	     the result instead.

-	     When STORING_ALL_ZEROS_P, we know that the string is now
-	     OFFSET characters long.
+	     When STORING_ALL_ZEROS_P, or the first byte written is zero,
+	     i.e. FULL_STRING_P && LENRANGE[1] == 0, we know that the
+	     string is now OFFSET characters long.

 	     Otherwise, we're storing an unknown value at offset OFFSET,
 	     so need to clip the nonzero_chars to OFFSET.
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr83907-1.c b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-1.c
new file mode 100644
index 0000000..2a6f4f5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+extern char str[];
+
+unsigned int foo()
+{
+  __builtin_memset(str,'x',5);
+  str[5] = 0;
+  return __builtin_strlen (str);
+}
+
+/* { dg-final { scan-tree-dump-not "strlen" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr83907-2.c b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-2.c
new file mode 100644
index 0000000..cc27504
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-2.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+extern char str[];
+
+unsigned int foo()
+{
+  __builtin_memset(str,'x',5);
+  str[5] = 0;
+  str[6] = 'z';
+  return __builtin_strlen (str);
+}
+
+/* { dg-final { scan-tree-dump-not "strlen" "optimized" } } */
