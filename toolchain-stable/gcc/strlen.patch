diff --git a/gcc/expr.cc b/gcc/expr.cc
index 1806091..7197996 100644
--- a/gcc/expr.cc
+++ b/gcc/expr.cc
@@ -9541,6 +9541,38 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,
 	}

       expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);
+
+      /* Expand X*Y as X&-Y when Y must be zero or one.  */
+      if (SCALAR_INT_MODE_P (mode))
+	{
+	  bool bit0_p = tree_nonzero_bits (treeop0) == 1;
+	  bool bit1_p = tree_nonzero_bits (treeop1) == 1;
+
+	  /* Expand X*Y as X&Y when both X and Y must be zero or one.  */
+	  if (bit0_p && bit1_p)
+	    return REDUCE_BIT_FIELD (expand_and (mode, op0, op1, target));
+
+	  if (bit0_p || bit1_p)
+	    {
+	      bool speed = optimize_insn_for_speed_p ();
+	      int cost = add_cost (speed, mode) + neg_cost (speed, mode);
+	      struct algorithm algorithm;
+	      enum mult_variant variant;
+	      if (CONST_INT_P (op1)
+		  ? !choose_mult_variant (mode, INTVAL (op1),
+					  &algorithm, &variant, cost)
+		  : cost < mul_cost (speed, mode))
+		{
+		  target = bit0_p ? expand_and (mode, negate_rtx (mode, op0),
+						op1, target)
+				  : expand_and (mode, op0,
+						negate_rtx (mode, op1),
+						target);
+		  return REDUCE_BIT_FIELD (target);
+		}
+	    }
+	}
+
       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));

     case TRUNC_MOD_EXPR:
diff --git a/gcc/testsuite/gcc.target/i386/pr98865.c b/gcc/testsuite/gcc.target/i386/pr98865.c
new file mode 100644
index 0000000..d047c4b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr98865.c
@@ -0,0 +1,54 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+#if __SIZEOF_INT__ == 4
+unsigned int foo(unsigned int a, unsigned int b)
+{
+  return (a >> 31) * b;
+}
+
+int bar(int a, int b)
+{
+  return -(a >> 31) * b;
+}
+
+int baz(int a, int b)
+{
+  int c = a >> 31;
+  int d = -c;
+  return d * b;
+}
+
+unsigned int pin(int a, unsigned int b)
+{
+  unsigned int t = a & 1;
+  return t * b;
+}
+#endif
+
+#if __SIZEOF_LONG_LONG__ == 8
+unsigned long long fool(unsigned long long a, unsigned long long b)
+{
+  return (a >> 63) * b;
+}
+
+long long barl (long long a, long long b)
+{
+  return -(a >> 63) * b;
+}
+
+long long bazl (long long a, long long b)
+{
+  long long c = a >> 63;
+  long long d = -c;
+  return d * b;
+}
+
+unsigned long long pinl(long long a, unsigned long long b)
+{
+  unsigned long long t = a & 1;
+  return t * b;
+}
+#endif
+
+/* { dg-final { scan-assembler-not "imul" } } */

diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index 86752a6..1701244 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -20744,26 +20744,67 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,
 	}
       /* FALLTHRU */

-    case AND:
     case IOR:
     case XOR:
       if (GET_MODE_CLASS (mode) == MODE_INT
 	  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)
 	{
-	  *total = (cost->add * 2
-		    + (rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)
-		       << (GET_MODE (XEXP (x, 0)) != DImode))
-		    + (rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed)
-	               << (GET_MODE (XEXP (x, 1)) != DImode)));
+	  *total = cost->add * 2
+		   + rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)
+		   + rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed);
+	  return true;
+	}
+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	*total = ix86_vec_cost (mode, cost->sse_op);
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	*total = cost->add * 2;
+      else
+	*total = cost->add;
+      return false;
+
+    case AND:
+      if (GET_MODE_CLASS (mode) == MODE_INT
+	  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	{
+	  *total = cost->add * 2
+		   + rtx_cost (XEXP (x, 0), mode, outer_code, opno, speed)
+		   + rtx_cost (XEXP (x, 1), mode, outer_code, opno, speed);
 	  return true;
 	}
-      else if (code == AND
-	       && address_no_seg_operand (x, mode))
+      else if (address_no_seg_operand (x, mode))
 	{
 	  *total = cost->lea;
 	  return true;
 	}
-      /* FALLTHRU */
+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	{
+	  /* pandn is a single instruction.  */
+	  if (GET_CODE (XEXP (x, 0)) == NOT)
+	    {
+	      *total = ix86_vec_cost (mode, cost->sse_op)
+		       + rtx_cost (XEXP (XEXP (x, 0), 0), mode,
+				   outer_code, opno, speed)
+		       + rtx_cost (XEXP (x, 1), mode,
+				   outer_code, opno, speed);
+	      return true;
+	    }
+	  *total = ix86_vec_cost (mode, cost->sse_op);
+	}
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	*total = cost->add * 2;
+      else
+	*total = cost->add;
+      return false;
+
+    case NOT:
+      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+	// vnot is pxor -1.
+	*total = ix86_vec_cost (mode, cost->sse_op) + 1;
+      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	*total = cost->add * 2;
+      else
+	*total = cost->add;
+      return false;

     case NEG:
       if (SSE_FLOAT_MODE_SSEMATH_OR_HF_P (mode))
@@ -20781,13 +20822,10 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,
 	  *total = ix86_vec_cost (mode, cost->sse_op);
 	  return false;
 	}
-      /* FALLTHRU */
-
-    case NOT:
-      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
+      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)
 	*total = ix86_vec_cost (mode, cost->sse_op);
       else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
-	*total = cost->add * 2;
+	*total = cost->add * 3;
       else
 	*total = cost->add;
       return false;

diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index 86752a6..e8a2229 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -20634,7 +20634,17 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,
 	        op0 = XEXP (op0, 0), mode = GET_MODE (op0);
 	    }

-  	  *total = (cost->mult_init[MODE_INDEX (mode)]
+	  int mult_init;
+	  // Double word multiplication requires 3 mults and 2 adds.
+	  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+	    {
+	      mult_init = 3 * cost->mult_init[MODE_INDEX (word_mode)]
+			  + 2 * cost->add;
+	      nbits *= 3;
+	    }
+	  else mult_init = cost->mult_init[MODE_INDEX (mode)];
+
+  	  *total = (mult_init
 		    + nbits * cost->mult_bit
 	            + rtx_cost (op0, mode, outer_code, opno, speed)
 		    + rtx_cost (op1, mode, outer_code, opno, speed));

diff --git a/gcc/tree-ssa-strlen.cc b/gcc/tree-ssa-strlen.cc
index 7370516..d2db197 100644
--- a/gcc/tree-ssa-strlen.cc
+++ b/gcc/tree-ssa-strlen.cc
@@ -3810,9 +3810,44 @@ strlen_pass::handle_builtin_memset (bool *zero_write)
 {
   gimple *memset_stmt = gsi_stmt (m_gsi);
   tree ptr = gimple_call_arg (memset_stmt, 0);
+  tree memset_val = gimple_call_arg (memset_stmt, 1);
+  tree memset_size = gimple_call_arg (memset_stmt, 2);
+
   /* Set to the non-constant offset added to PTR.  */
   wide_int offrng[2];
   int idx1 = get_stridx (ptr, memset_stmt, offrng, ptr_qry.rvals);
+  if (idx1 == 0
+      && TREE_CODE (memset_val) == INTEGER_CST
+      && ((TREE_CODE (memset_size) == INTEGER_CST
+	   && !integer_zerop (memset_size))
+	  || TREE_CODE (memset_size) == SSA_NAME))
+    {
+      unsigned HOST_WIDE_INT mask = (HOST_WIDE_INT_1U << CHAR_TYPE_SIZE) - 1;
+      bool full_string_p = (wi::to_wide (memset_val) & mask) == 0;
+
+      /* We only handle symbolic lengths when writing non-zero values.  */
+      if (full_string_p && TREE_CODE (memset_size) != INTEGER_CST)
+	return false;
+
+      idx1 = new_stridx (ptr);
+      if (idx1 == 0)
+	return false;
+      tree newlen;
+      if (full_string_p)
+	newlen = build_int_cst (size_type_node, 0);
+      else if (TREE_CODE (memset_size) == INTEGER_CST)
+	newlen = fold_convert (size_type_node, memset_size);
+      else
+	newlen = memset_size;
+
+      strinfo *dsi = new_strinfo (ptr, idx1, newlen, full_string_p);
+      set_strinfo (idx1, dsi);
+      find_equal_ptrs (ptr, idx1);
+      dsi->dont_invalidate = true;
+      dsi->writable = true;
+      return false;
+    }
+
   if (idx1 <= 0)
     return false;
   strinfo *si1 = get_strinfo (idx1);
@@ -3825,7 +3860,6 @@ strlen_pass::handle_builtin_memset (bool *zero_write)
   if (!valid_builtin_call (alloc_stmt))
     return false;
   tree alloc_size = gimple_call_arg (alloc_stmt, 0);
-  tree memset_size = gimple_call_arg (memset_stmt, 2);

   /* Check for overflow.  */
   maybe_warn_overflow (memset_stmt, false, memset_size, NULL, false, true);
@@ -3841,7 +3875,7 @@ strlen_pass::handle_builtin_memset (bool *zero_write)
     return false;

   /* Bail when the call writes a non-zero value.  */
-  if (!integer_zerop (gimple_call_arg (memset_stmt, 1)))
+  if (!integer_zerop (memset_val))
     return false;

   /* Let the caller know the memset call cleared the destination.  */
@@ -5093,8 +5127,9 @@ strlen_pass::handle_store (bool *zero_write)
 	  return false;
 	}

-      if (storing_all_zeros_p
-	  || storing_nonzero_p
+      if (storing_nonzero_p
+	  || storing_all_zeros_p
+	  || (full_string_p && lenrange[1] == 0)
 	  || (offset != 0 && store_before_nul[1] > 0))
 	{
 	  /* When STORING_NONZERO_P, we know that the string will start
@@ -5104,8 +5139,9 @@ strlen_pass::handle_store (bool *zero_write)
 	     of leading non-zero characters and set si->NONZERO_CHARS to
 	     the result instead.

-	     When STORING_ALL_ZEROS_P, we know that the string is now
-	     OFFSET characters long.
+	     When STORING_ALL_ZEROS_P, or the first byte written is zero,
+	     i.e. FULL_STRING_P && LENRANGE[1] == 0, we know that the
+	     string is now OFFSET characters long.

 	     Otherwise, we're storing an unknown value at offset OFFSET,
 	     so need to clip the nonzero_chars to OFFSET.
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr83907-1.c b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-1.c
new file mode 100644
index 0000000..2a6f4f5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-1.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+extern char str[];
+
+unsigned int foo()
+{
+  __builtin_memset(str,'x',5);
+  str[5] = 0;
+  return __builtin_strlen (str);
+}
+
+/* { dg-final { scan-tree-dump-not "strlen" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr83907-2.c b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-2.c
new file mode 100644
index 0000000..cc27504
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr83907-2.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+extern char str[];
+
+unsigned int foo()
+{
+  __builtin_memset(str,'x',5);
+  str[5] = 0;
+  str[6] = 'z';
+  return __builtin_strlen (str);
+}
+
+/* { dg-final { scan-tree-dump-not "strlen" "optimized" } } */
