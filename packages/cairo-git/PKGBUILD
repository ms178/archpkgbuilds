pkgbase=cairo
pkgname=(
  cairo-git
)
pkgver=1.18.4+51+g04656d745
pkgrel=10.1
pkgdesc="2D graphics library with support for multiple output devices (PGO+CS-PGO+BOLT optimized)"
url="https://cairographics.org/"
arch=(x86_64)
license=(LGPL MPL)
depends=(zlib libpng fontconfig freetype2 libx11 libxext libxrender libxcb
         glib2 pixman)
makedepends=(
  valgrind
  git
  meson
  clang
  llvm
  python
  bolt
  mimalloc
  lld
)
provides=(cairo)
conflicts=(cairo)
options=(!strip)
source=("git+https://gitlab.freedesktop.org/cairo/cairo.git")
sha256sums=('SKIP')

pkgver() {
  cd cairo
  git describe --tags | sed 's/-/+/g'
}

prepare() {
  cd cairo

  # CRITICAL: Your original workload code with shell-comment corruption fixed
  cat > "$srcdir/cairo_workload.c" << 'EOF'
#include <cairo/cairo.h>
#include <cairo/cairo-pdf.h>
#include <cairo/cairo-svg.h>
#include <cairo/cairo-ps.h>
#include <cairo/cairo-xlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <math.h>
#include <X11/Xlib.h>

#define WORKLOAD_ITERATIONS 2
#define SURFACE_WIDTH 4096
#define SURFACE_HEIGHT 2160

static inline float rand_float(float min, float max) {
    return min + (max - min) * (double)rand() / RAND_MAX;
}

static inline int rand_int(int min, int max) {
    return min + (int)((double)rand() / (RAND_MAX + 1.0) * (max - min + 1));
}

void draw_random_shapes(cairo_t *cr, int num_shapes) {
    for (int i = 0; i < num_shapes; i++) {
        cairo_set_source_rgba(cr, rand_float(0, 1), rand_float(0, 1),
                              rand_float(0, 1), rand_float(0.1, 1.0));
        cairo_set_line_width(cr, rand_float(0.5, 10.0));

        int shape_type = rand_int(0, 8);
        switch (shape_type) {
            case 0: {
                cairo_rectangle(cr, rand_float(0, SURFACE_WIDTH),
                               rand_float(0, SURFACE_HEIGHT),
                               rand_float(10, 500), rand_float(10, 500));
                break;
            }
            case 1: {
                cairo_arc(cr, rand_float(0, SURFACE_WIDTH),
                         rand_float(0, SURFACE_HEIGHT),
                         rand_float(5, 200), 0, 2 * M_PI);
                break;
            }
            case 2: {
                cairo_save(cr);
                cairo_translate(cr, rand_float(0, SURFACE_WIDTH),
                               rand_float(0, SURFACE_HEIGHT));
                cairo_scale(cr, rand_float(0.2, 2.0), rand_float(0.2, 2.0));
                cairo_arc(cr, 0, 0, 1.0, 0, 2 * M_PI);
                cairo_restore(cr);
                break;
            }
            default: {
                cairo_move_to(cr, rand_float(0, SURFACE_WIDTH),
                             rand_float(0, SURFACE_HEIGHT));
                for (int j = 0; j < rand_int(3, 10); j++) {
                    cairo_line_to(cr, rand_float(0, SURFACE_WIDTH),
                                 rand_float(0, SURFACE_HEIGHT));
                }
                cairo_close_path(cr);
                break;
            }
        }

        cairo_set_operator(cr, rand_int(0, 12));
        if (rand_int(0, 2) == 0) {
            cairo_fill(cr);
        } else {
            cairo_stroke(cr);
        }
    }
}

void draw_random_text(cairo_t *cr, int num_texts) {
    const char* fonts[] = {"Sans", "Serif", "Monospace", "Arial", "Helvetica"};
    const char* texts[] = {"Cairo", "PGO", "Graphics", "Linux", "Optimization"};

    for (int i = 0; i < num_texts; i++) {
        cairo_select_font_face(cr, fonts[rand_int(0, 4)],
                              rand_int(0, 1) ? CAIRO_FONT_SLANT_ITALIC : CAIRO_FONT_SLANT_NORMAL,
                              rand_int(0, 1) ? CAIRO_FONT_WEIGHT_BOLD : CAIRO_FONT_WEIGHT_NORMAL);
        cairo_set_font_size(cr, rand_float(8, 96));
        cairo_set_source_rgba(cr, rand_float(0, 1), rand_float(0, 1),
                              rand_float(0, 1), rand_float(0.5, 1.0));

        cairo_move_to(cr, rand_float(0, SURFACE_WIDTH),
                     rand_float(0, SURFACE_HEIGHT));
        cairo_show_text(cr, texts[rand_int(0, 4)]);
    }
}

void draw_random_gradients(cairo_t *cr, int num_gradients) {
    for (int i = 0; i < num_gradients; i++) {
        cairo_pattern_t *pattern;

        if (rand_int(0, 1)) {
            pattern = cairo_pattern_create_linear(
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT),
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT));
        } else {
            pattern = cairo_pattern_create_radial(
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT), 0,
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT),
                rand_float(50, 500));
        }

        for (int j = 0; j < rand_int(2, 6); j++) {
            cairo_pattern_add_color_stop_rgba(pattern, (double)j / 5,
                rand_float(0, 1), rand_float(0, 1),
                rand_float(0, 1), rand_float(0.5, 1.0));
        }

        cairo_set_source(cr, pattern);
        cairo_rectangle(cr, rand_float(0, SURFACE_WIDTH),
                       rand_float(0, SURFACE_HEIGHT),
                       rand_float(100, 800), rand_float(100, 800));
        cairo_fill(cr);
        cairo_pattern_destroy(pattern);
    }
}

void draw_surface_patterns(cairo_t *cr, int num_patterns) {
    for (int i = 0; i < num_patterns; i++) {
        cairo_surface_t *surface = cairo_image_surface_create(
            CAIRO_FORMAT_ARGB32, 256, 256);
        cairo_t *pattern_cr = cairo_create(surface);

        cairo_set_source_rgb(pattern_cr, rand_float(0, 1),
                            rand_float(0, 1), rand_float(0, 1));
        cairo_paint(pattern_cr);
        draw_random_shapes(pattern_cr, rand_int(10, 30));

        cairo_pattern_t *pattern = cairo_pattern_create_for_surface(surface);
        cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
        cairo_set_source(cr, pattern);

        cairo_rectangle(cr, rand_float(0, SURFACE_WIDTH),
                       rand_float(0, SURFACE_HEIGHT),
                       rand_float(200, 1000), rand_float(200, 1000));
        cairo_fill(cr);

        cairo_pattern_destroy(pattern);
        cairo_destroy(pattern_cr);
        cairo_surface_destroy(surface);
    }
}

int main() {
    printf("Starting Cairo PGO Workload...\n");
    srand(time(NULL));

    const char* surfaces[] = {"image", "pdf", "svg", "ps"};

    for (int iter = 0; iter < WORKLOAD_ITERATIONS; iter++) {
        printf("Iteration %d/%d\n", iter + 1, WORKLOAD_ITERATIONS);

        for (int s = 0; s < 4; s++) {
            cairo_surface_t *surface = NULL;

            if (strcmp(surfaces[s], "image") == 0) {
                surface = cairo_image_surface_create(
                    CAIRO_FORMAT_ARGB32, SURFACE_WIDTH, SURFACE_HEIGHT);
            } else {
                char filename[256];
                snprintf(filename, sizeof(filename), "/tmp/cairo_%s_%d.tmp",
                        surfaces[s], iter);
                if (strcmp(surfaces[s], "pdf") == 0) {
                    surface = cairo_pdf_surface_create(filename,
                                                      SURFACE_WIDTH, SURFACE_HEIGHT);
                } else if (strcmp(surfaces[s], "svg") == 0) {
                    surface = cairo_svg_surface_create(filename,
                                                      SURFACE_WIDTH, SURFACE_HEIGHT);
                } else {
                    surface = cairo_ps_surface_create(filename,
                                                     SURFACE_WIDTH, SURFACE_HEIGHT);
                }
            }

            if (!surface) {
                fprintf(stderr, "Failed to create %s surface\n", surfaces[s]);
                continue;
            }

            cairo_t *cr = cairo_create(surface);

            // Heavy workload with instrumentation triggers
            draw_random_shapes(cr, 500);
            draw_random_text(cr, 200);
            draw_random_gradients(cr, 100);
            draw_surface_patterns(cr, 50);

            cairo_surface_flush(surface);
            cairo_show_page(cr);
            cairo_destroy(cr);
            cairo_surface_destroy(surface);

            if (strcmp(surfaces[s], "image") != 0) {
                char filename[256];
                snprintf(filename, sizeof(filename), "/tmp/cairo_%s_%d.tmp",
                        surfaces[s], iter);
                unlink(filename);
            }
        }
    }

    printf("Workload completed.\n");
    return 0;
}
EOF
}

run_cairo_workload() {(
  local build_dir="$1"
  local cflags_name="$2"
  local ldflags_name="$3"
  local profile_dir="$4"
  local temp_install_dir="${srcdir}/temp_install"

  cd "$build_dir" || return 1

  if [[ ! -f "${temp_install_dir}/usr/lib/libcairo.so.2" ]]; then
    error "Instrumented libcairo.so.2 not found in ${temp_install_dir}/usr/lib"
    ls -la "${temp_install_dir}/usr/lib/libcairo.so"* 2>/dev/null || true
    return 1
  fi

  # Use nameref to get the actual arrays
  local -n cflags_ref="$cflags_name"
  local -n ldflags_ref="$ldflags_name"

  # Filter LTO-specific flags for workload compilation
  local -a workload_cflags=()
  local -a workload_ldflags=()

  for flag in "${cflags_ref[@]}"; do
    if [[ "$flag" != "-fwhole-program-vtables" ]] && [[ "$flag" != "-fsplit-lto-unit" ]]; then
      workload_cflags+=("$flag")
    fi
  done

  for flag in "${ldflags_ref[@]}"; do
    if [[ "$flag" != "-Wl,--lto-O3" ]]; then
      workload_ldflags+=("$flag")
    fi
  done

  echo "Compiling workload with ${#workload_cflags[@]} CFLAGS..."
  echo "CRITICAL: Library was built with LTO, workload compiles without LTO-specific flags"
  echo "Instrumented library path: ${temp_install_dir}/usr/lib"

  # Verify library has both LTO and instrumentation
  echo "Verifying library has LTO and PGO instrumentation:"
  nm "${temp_install_dir}/usr/lib/libcairo.so.2" | grep -E "(llvm_profile|llvm\.lto)" | head -5 || true
  objdump -h "${temp_install_dir}/usr/lib/libcairo.so.2" | grep -E "(__llvm|\.lto)" | head -5 || true

  clang "${workload_cflags[@]}" "$srcdir/cairo_workload.c" -o "$srcdir/cairo_workload_runner" \
    -I"${temp_install_dir}/usr/include" \
    -L"${temp_install_dir}/usr/lib" \
    -Wl,-rpath,"${temp_install_dir}/usr/lib" \
    -lcairo -lm "${workload_ldflags[@]}" || {
    error "Workload compilation failed"
    echo "CFLAGS used: ${workload_cflags[*]}"
    echo "LDFLAGS used: ${workload_ldflags[*]}"
    return 1
  }

  echo "Verifying workload links to instrumented library:"
  ldd "$srcdir/cairo_workload_runner" | grep cairo || true

  echo "Running instrumented workload..."
  export LD_LIBRARY_PATH="${temp_install_dir}/usr/lib:${LD_LIBRARY_PATH}"
  export LLVM_PROFILE_FILE="${profile_dir}/cairo-%p-%m.profraw"
  export LLVM_PROFILE_VERBOSE=3

  timeout 180 "$srcdir/cairo_workload_runner" || {
    local status=$?
    if [ $status -eq 124 ]; then
      echo "Workload timed out after 180s, checking profiles..."
    else
      echo "Workload exited with status $status, checking profiles..."
    fi
  }

  echo "Profile directory contents after run:"
  ls -lh "$profile_dir"

  if ! find "$profile_dir" -name "*.profraw" -size +100k | grep -q .; then
    error "No substantial profiles generated in $profile_dir"
    echo "Profile files found:"
    find "$profile_dir" -name "*.profraw" -exec ls -lh {} \;
    return 1
  fi

  echo "Profile generation successful:"
  find "$profile_dir" -name "*.profraw" -exec ls -lh {} \;
  echo "Total profile size: $(du -sh "$profile_dir" | cut -f1)"

  rm -f "$srcdir/cairo_workload_runner"
  return 0
)}

build() {
  cd cairo

  # Convert to arrays to preserve flag boundaries
  local -a orig_cflags=($CFLAGS)
  local -a orig_cxxflags=($CXXFLAGS)
  local -a orig_ldflags=($LDFLAGS)

  if [[ " ${orig_ldflags[@]} " =~ " -fuse-ld=lld " ]]; then
    msg2 "Detected LLD in LDFLAGS: $(printf '%s ' "${orig_ldflags[@]}")"
  fi

  local PGO_DIR="${srcdir}/pgo-data"
  local CSPGO_DIR="${srcdir}/cspgo-data"

  rm -rf "$PGO_DIR" "$CSPGO_DIR"
  mkdir -p "$PGO_DIR" "$CSPGO_DIR"

  local meson_opts=(
    -D spectre=disabled
    -D python.bytecompile=2
    -D dwrite=disabled
    -D gtk_doc=false
    -D tee=enabled
    -D xlib-xcb=enabled
    -D lzo=disabled
    -D b_ndebug=true
    -D b_pie=false
    -D c_std=gnu18
    -D cpp_std=gnu++2a
    --buildtype=release
    -D quartz=disabled
    -D symbol-lookup=disabled
    -D tests=disabled
    -D default_library=shared
  )

  ###########################################################################
  # Stage 1: Standard PGO Instrumentation
  ###########################################################################
  msg2 "Stage 1: Building PGO-instrumented Cairo WITH LTO..."

  local -a pgo_instr_flags=(-fprofile-generate="${PGO_DIR}" -fno-omit-frame-pointer -mllvm -vp-counters-per-site=4096)
  local -a stage1_cflags=("${orig_cflags[@]}" "${pgo_instr_flags[@]}")
  local -a stage1_ldflags=("${orig_ldflags[@]}" "${pgo_instr_flags[@]}")

  rm -rf "${srcdir}/build-pgo"
  arch-meson . "${srcdir}/build-pgo" "${meson_opts[@]}" \
    -D c_args="${stage1_cflags[*]}" \
    -D cpp_args="${orig_cxxflags[*]} ${pgo_instr_flags[*]}" \
    -D c_link_args="${stage1_ldflags[*]}" || {
    error "Meson configure failed in Stage 1"
    return 1
  }

  meson compile -C "${srcdir}/build-pgo" || {
    error "Compilation failed in Stage 1"
    return 1
  }

  DESTDIR="${srcdir}/temp_install" meson install -C "${srcdir}/build-pgo" || {
    error "Install failed in Stage 1"
    return 1
  }

  ###########################################################################
  # Stage 1: PGO Training
  ###########################################################################
  msg2 "Stage 1: Running PGO training workload..."

  run_cairo_workload "${srcdir}/build-pgo" "stage1_cflags" "stage1_ldflags" "$PGO_DIR" || {
    error "PGO training failed"
    return 1
  }

  ###########################################################################
  # Stage 1: Profile Merging
  ###########################################################################
  msg2 "Stage 1: Merging PGO profiles..."

  llvm-profdata merge -output="${PGO_DIR}/default.profdata" "${PGO_DIR}"/*.profraw || {
    error "Failed to merge PGO profiles"
    return 1
  }

  echo "PGO profile size: $(du -h ${PGO_DIR}/default.profdata | cut -f1)"
  rm -f "${PGO_DIR}"/*.profraw

  ###########################################################################
  # Stage 2: CS-PGO Instrumentation
  ###########################################################################
  msg2 "Stage 2: Building CS-PGO instrumented Cairo WITH LTO..."

  rm -rf "${srcdir}/temp_install" "${srcdir}/build-cspgo"

  local -a cspgo_instr_flags=(-fprofile-use="${PGO_DIR}/default.profdata" -fcs-profile-generate="${CSPGO_DIR}" -fno-omit-frame-pointer -mllvm -vp-counters-per-site=4096)
  local -a stage2_cflags=("${orig_cflags[@]}" "${cspgo_instr_flags[@]}")
  local -a stage2_ldflags=("${orig_ldflags[@]}" "${cspgo_instr_flags[@]}")

  arch-meson . "${srcdir}/build-cspgo" "${meson_opts[@]}" \
    -D c_args="${stage2_cflags[*]}" \
    -D cpp_args="${orig_cxxflags[*]} ${cspgo_instr_flags[*]}" \
    -D c_link_args="${stage2_ldflags[*]}" || {
    error "Meson configure failed in Stage 2"
    return 1
  }

  meson compile -C "${srcdir}/build-cspgo" || {
    error "Compilation failed in Stage 2"
    return 1
  }

  DESTDIR="${srcdir}/temp_install" meson install -C "${srcdir}/build-cspgo" || {
    error "Install failed in Stage 2"
    return 1
  }

  ###########################################################################
  # Stage 2: CS-PGO Training
  ###########################################################################
  msg2 "Stage 2: Running CS-PGO training workload..."

  run_cairo_workload "${srcdir}/build-cspgo" "stage2_cflags" "stage2_ldflags" "$CSPGO_DIR" || {
    error "CS-PGO training failed"
    return 1
  }

  ###########################################################################
  # Stage 2: CS-PGO Profile Merging
  ###########################################################################
  msg2 "Stage 2: Merging CS-PGO profiles..."

  llvm-profdata merge -output="${CSPGO_DIR}/cs.profdata" "${CSPGO_DIR}"/*.profraw "${PGO_DIR}/default.profdata" || {
    error "Failed to merge CS-PGO profiles"
    return 1
  }

  echo "CS-PGO profile size: $(du -h ${CSPGO_DIR}/cs.profdata | cut -f1)"
  rm -f "${CSPGO_DIR}"/*.profraw

  ###########################################################################
  # Stage 3: Final PGO-Optimized Build
  ###########################################################################
  msg2 "Stage 3: Building final PGO-optimized Cairo WITH LTO..."

  rm -rf "${srcdir}/temp_install" "${srcdir}/build"

  local -a final_flags=(-fprofile-use="${CSPGO_DIR}/cs.profdata" -fno-common -ffunction-sections -fdata-sections)
  local -a stage3_cflags=("${orig_cflags[@]}" "${final_flags[@]}")
  local -a stage3_ldflags=("${orig_ldflags[@]}" "${final_flags[@]}" -Wl,--emit-relocs)

  arch-meson . "${srcdir}/build" "${meson_opts[@]}" \
    -D c_args="${stage3_cflags[*]}" \
    -D cpp_args="${orig_cxxflags[*]} ${final_flags[*]}" \
    -D c_link_args="${stage3_ldflags[*]}" || {
    error "Meson configure failed in Stage 3"
    return 1
  }

  meson compile -C "${srcdir}/build" || {
    error "Compilation failed in Stage 3"
    return 1
  }
}

package() {
  provides=(
    libcairo-gobject.so
    libcairo-script-interpreter.so
    libcairo.so
    cairo
    cairo-git
  )

  cd cairo
  DESTDIR="${pkgdir}" meson install -C "${srcdir}/build" || {
    error "Install of CS-PGO binary failed"
    return 1
  }

  msg2 "CS-PGO binary installed. Starting BOLT optimization cycle..."

  # Find the real, versioned library file installed in the package directory
  local lib_path
  lib_path=$(find "${pkgdir}" -type f -name "libcairo.so.*.*.*")
  if [[ -z "$lib_path" ]]; then
    error "Could not find installed libcairo.so in pkgdir"
    return 1
  fi
  msg2 "Found target library for BOLT: ${lib_path}"

  local lib_dir
  lib_dir=$(dirname "$lib_path")

  local BOLT_DIR="${srcdir}/bolt-data"
  rm -rf "$BOLT_DIR"
  mkdir -p "$BOLT_DIR"

  ###########################################################################
  # Stage 4: BOLT Instrumentation & Backup
  ###########################################################################
  msg2 "Stage 4: BOLT instrumentation..."

  cp "$lib_path" "$lib_path.cspgo"

  llvm-bolt "$lib_path.cspgo" \
    --instrument --instrumentation-file-append-pid \
    --instrumentation-file="${BOLT_DIR}/bolt.fdata" \
    -o "$lib_path" || {
    warning "BOLT instrumentation failed, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  }

  ###########################################################################
  # Stage 4: BOLT Training
  ###########################################################################
  msg2 "Stage 4: Running BOLT training workload..."

  export BOLT_PROFILE_FILE="${BOLT_DIR}/bolt.fdata"

  clang $CFLAGS "$srcdir/cairo_workload.c" -o "$srcdir/cairo_workload_runner" \
    -I"${pkgdir}/usr/include/cairo" \
    -L"$lib_dir" \
    -Wl,-rpath,"$lib_dir" \
    -lcairo -lm $LDFLAGS || {
    warning "Workload recompilation for BOLT failed, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  }

  timeout 180 "$srcdir/cairo_workload_runner" || {
    local status=$?
    if [ $status -eq 124 ]; then
      echo "BOLT training timed out after 180s, checking profiles..."
    else
      echo "BOLT training exited with status $status, checking profiles..."
    fi
  }

  if ! find "$BOLT_DIR" -name "bolt.fdata.*" -size +10k | grep -q .; then
    warning "No substantial BOLT profiles generated, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  fi

  echo "BOLT profiles generated:"
  find "$BOLT_DIR" -name "bolt.fdata.*" -exec ls -lh {} \;
  rm -f "$srcdir/cairo_workload_runner"

  ###########################################################################
  # Stage 5: BOLT Profile Merging
  ###########################################################################
  msg2 "Stage 5: Merging BOLT profiles..."

  if command -v merge-fdata >/dev/null 2>&1; then
    LD_PRELOAD=/usr/lib/libmimalloc.so merge-fdata ${BOLT_DIR}/bolt.fdata.* > "${BOLT_DIR}/bolt_merged.fdata" 2>/dev/null || {
      warning "BOLT profile merge failed, skipping BOLT optimization"
      mv "$lib_path.cspgo" "$lib_path"
      return 0
    }
  else
    warning "merge-fdata not found, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  fi

  if [[ ! -s "${BOLT_DIR}/bolt_merged.fdata" ]]; then
    warning "Merged BOLT profile is empty, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  fi

  echo "BOLT merged profile size: $(du -h ${BOLT_DIR}/bolt_merged.fdata | cut -f1)"

  ###########################################################################
  # Stage 6: BOLT Optimization
  ###########################################################################
  msg2 "Stage 6: Applying BOLT optimizations..."

  LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "$lib_path.cspgo" \
    --data "${BOLT_DIR}/bolt_merged.fdata" \
    -o "$lib_path" \
    --dyno-stats --lite=false --icf=all --plt=all --hugify --peepholes=all \
    --x86-strip-redundant-address-size --indirect-call-promotion=all \
    --reorder-blocks=ext-tsp --reorder-functions=cdsort --split-all-cold \
    --split-eh --split-functions --split-strategy=cdsplit || {
    warning "BOLT optimization failed, using CS-PGO binary"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  }

  rm -f "$lib_path.cspgo"
  msg2 "BOLT optimization completed successfully!"

  ###########################################################################
  # Final Stripping
  ###########################################################################
  find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null || true
  done
}
