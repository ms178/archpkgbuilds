pkgbase=cairo
pkgname=(
  cairo-git
)
pkgver=1.18.4+57+g2a4589266
pkgrel=1
pkgdesc="2D graphics library with support for multiple output devices (PGO+CS-PGO+BOLT optimized)"
url="https://cairographics.org/"
arch=(x86_64)
license=(LGPL MPL)
depends=(zlib libpng fontconfig freetype2 libx11 libxext libxrender libxcb
         glib2 pixman)
makedepends=(
  git
  meson
  clang
  llvm
  python
  bolt
  lld
  pkgconf
)
provides=(cairo)
conflicts=(cairo)
options=(!strip)
source=("git+https://gitlab.freedesktop.org/cairo/cairo.git")
sha256sums=('SKIP')

pkgver() {
  cd "${srcdir}/cairo"
  git describe --tags | sed 's/-/+/g'
}

prepare() {
  cd "${srcdir}/cairo"

  cat > "$srcdir/cairo_workload.c" << 'EOF'
#include <cairo/cairo.h>
#include <cairo/cairo-pdf.h>
#include <cairo/cairo-svg.h>
#include <cairo/cairo-ps.h>
#include <cairo/cairo-xlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <math.h>
#include <X11/Xlib.h>

#define WORKLOAD_ITERATIONS 2
#define SURFACE_WIDTH 4096
#define SURFACE_HEIGHT 2160

static inline float rand_float(float min, float max) {
    return min + (max - min) * (double)rand() / RAND_MAX;
}

static inline int rand_int(int min, int max) {
    return min + (int)((double)rand() / (RAND_MAX + 1.0) * (max - min + 1));
}

void draw_random_shapes(cairo_t *cr, int num_shapes) {
    for (int i = 0; i < num_shapes; i++) {
        cairo_set_source_rgba(cr, rand_float(0, 1), rand_float(0, 1),
                              rand_float(0, 1), rand_float(0.1, 1.0));
        cairo_set_line_width(cr, rand_float(0.5, 10.0));

        int shape_type = rand_int(0, 8);
        switch (shape_type) {
            case 0: {
                cairo_rectangle(cr, rand_float(0, SURFACE_WIDTH),
                               rand_float(0, SURFACE_HEIGHT),
                               rand_float(10, 500), rand_float(10, 500));
                break;
            }
            case 1: {
                cairo_arc(cr, rand_float(0, SURFACE_WIDTH),
                         rand_float(0, SURFACE_HEIGHT),
                         rand_float(5, 200), 0, 2 * M_PI);
                break;
            }
            case 2: {
                cairo_save(cr);
                cairo_translate(cr, rand_float(0, SURFACE_WIDTH),
                               rand_float(0, SURFACE_HEIGHT));
                cairo_scale(cr, rand_float(0.2, 2.0), rand_float(0.2, 2.0));
                cairo_arc(cr, 0, 0, 1.0, 0, 2 * M_PI);
                cairo_restore(cr);
                break;
            }
            default: {
                cairo_move_to(cr, rand_float(0, SURFACE_WIDTH),
                             rand_float(0, SURFACE_HEIGHT));
                for (int j = 0; j < rand_int(3, 10); j++) {
                    cairo_line_to(cr, rand_float(0, SURFACE_WIDTH),
                                 rand_float(0, SURFACE_HEIGHT));
                }
                cairo_close_path(cr);
                break;
            }
        }

        cairo_set_operator(cr, rand_int(0, 12));
        if (rand_int(0, 2) == 0) {
            cairo_fill(cr);
        } else {
            cairo_stroke(cr);
        }
    }
}

void draw_random_text(cairo_t *cr, int num_texts) {
    const char* fonts[] = {"Sans", "Serif", "Monospace", "Arial", "Helvetica"};
    const char* texts[] = {"Cairo", "PGO", "Graphics", "Linux", "Optimization"};

    for (int i = 0; i < num_texts; i++) {
        cairo_select_font_face(cr, fonts[rand_int(0, 4)],
                              rand_int(0, 1) ? CAIRO_FONT_SLANT_ITALIC : CAIRO_FONT_SLANT_NORMAL,
                              rand_int(0, 1) ? CAIRO_FONT_WEIGHT_BOLD : CAIRO_FONT_WEIGHT_NORMAL);
        cairo_set_font_size(cr, rand_float(8, 96));
        cairo_set_source_rgba(cr, rand_float(0, 1), rand_float(0, 1),
                              rand_float(0, 1), rand_float(0.5, 1.0));

        cairo_move_to(cr, rand_float(0, SURFACE_WIDTH),
                     rand_float(0, SURFACE_HEIGHT));
        cairo_show_text(cr, texts[rand_int(0, 4)]);
    }
}

void draw_random_gradients(cairo_t *cr, int num_gradients) {
    for (int i = 0; i < num_gradients; i++) {
        cairo_pattern_t *pattern;

        if (rand_int(0, 1)) {
            pattern = cairo_pattern_create_linear(
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT),
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT));
        } else {
            pattern = cairo_pattern_create_radial(
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT), 0,
                rand_float(0, SURFACE_WIDTH), rand_float(0, SURFACE_HEIGHT),
                rand_float(50, 500));
        }

        for (int j = 0; j < rand_int(2, 6); j++) {
            cairo_pattern_add_color_stop_rgba(pattern, (double)j / 5,
                rand_float(0, 1), rand_float(0, 1),
                rand_float(0, 1), rand_float(0.5, 1.0));
        }

        cairo_set_source(cr, pattern);
        cairo_rectangle(cr, rand_float(0, SURFACE_WIDTH),
                       rand_float(0, SURFACE_HEIGHT),
                       rand_float(100, 800), rand_float(100, 800));
        cairo_fill(cr);
        cairo_pattern_destroy(pattern);
    }
}

void draw_surface_patterns(cairo_t *cr, int num_patterns) {
    for (int i = 0; i < num_patterns; i++) {
        cairo_surface_t *surface = cairo_image_surface_create(
            CAIRO_FORMAT_ARGB32, 256, 256);
        cairo_t *pattern_cr = cairo_create(surface);

        cairo_set_source_rgb(pattern_cr, rand_float(0, 1),
                            rand_float(0, 1), rand_float(0, 1));
        cairo_paint(pattern_cr);
        draw_random_shapes(pattern_cr, rand_int(10, 30));

        cairo_pattern_t *pattern = cairo_pattern_create_for_surface(surface);
        cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
        cairo_set_source(cr, pattern);

        cairo_rectangle(cr, rand_float(0, SURFACE_WIDTH),
                       rand_float(0, SURFACE_HEIGHT),
                       rand_float(200, 1000), rand_float(200, 1000));
        cairo_fill(cr);

        cairo_pattern_destroy(pattern);
        cairo_destroy(pattern_cr);
        cairo_surface_destroy(surface);
    }
}

int main() {
    printf("Starting Cairo PGO Workload...\n");
    srand(time(NULL));

    const char* surfaces[] = {"image", "pdf", "svg", "ps"};

    for (int iter = 0; iter < WORKLOAD_ITERATIONS; iter++) {
        printf("Iteration %d/%d\n", iter + 1, WORKLOAD_ITERATIONS);

        for (int s = 0; s < 4; s++) {
            cairo_surface_t *surface = NULL;

            if (strcmp(surfaces[s], "image") == 0) {
                surface = cairo_image_surface_create(
                    CAIRO_FORMAT_ARGB32, SURFACE_WIDTH, SURFACE_HEIGHT);
            } else {
                char filename[256];
                snprintf(filename, sizeof(filename), "/tmp/cairo_%s_%d.tmp",
                        surfaces[s], iter);
                if (strcmp(surfaces[s], "pdf") == 0) {
                    surface = cairo_pdf_surface_create(filename,
                                                      SURFACE_WIDTH, SURFACE_HEIGHT);
                } else if (strcmp(surfaces[s], "svg") == 0) {
                    surface = cairo_svg_surface_create(filename,
                                                      SURFACE_WIDTH, SURFACE_HEIGHT);
                } else {
                    surface = cairo_ps_surface_create(filename,
                                                     SURFACE_WIDTH, SURFACE_HEIGHT);
                }
            }

            if (!surface) {
                fprintf(stderr, "Failed to create %s surface\n", surfaces[s]);
                continue;
            }

            cairo_t *cr = cairo_create(surface);

            draw_random_shapes(cr, 500);
            draw_random_text(cr, 200);
            draw_random_gradients(cr, 100);
            draw_surface_patterns(cr, 50);

            cairo_surface_flush(surface);
            cairo_show_page(cr);
            cairo_destroy(cr);
            cairo_surface_destroy(surface);

            if (strcmp(surfaces[s], "image") != 0) {
                char filename[256];
                snprintf(filename, sizeof(filename), "/tmp/cairo_%s_%d.tmp",
                        surfaces[s], iter);
                unlink(filename);
            }
        }
    }

    printf("Workload completed.\n");
    return 0;
}
EOF
}

meson_array() {
  local out="["
  local arg
  for arg in "$@"; do
    arg=${arg//\\/\\\\}
    arg=${arg//\'/\\\'}
    out+="'$arg',"
  done
  out="${out%,}]"
  printf "%s" "$out"
}

filter_workload_flags() {
  local -n in="$1"
  local -n out="$2"
  out=()
  local f
  for f in "${in[@]}"; do
    case "$f" in
      -fprofile-generate*|-fprofile-use*|-fprofile-correction|-fcs-profile-generate*|-fprofile-instr-generate*|-fprofile-instr-use*|-fcoverage-mapping)
        continue
        ;;
    esac
    out+=("$f")
  done
}

run_cairo_workload() {
  local build_dir="$1"
  local profile_dir="$2"
  shift 2

  local -a in_cflags=()
  local -a in_ldflags=()
  local mode=0
  local arg
  for arg in "$@"; do
    if [[ "$arg" == "--" ]]; then
      mode=1
      continue
    fi
    if ((mode==0)); then
      in_cflags+=("$arg")
    else
      in_ldflags+=("$arg")
    fi
  done

  local -a workload_cflags=()
  local -a workload_ldflags=()
  filter_workload_flags in_cflags workload_cflags
  filter_workload_flags in_ldflags workload_ldflags

  local temp_install_dir="${srcdir}/temp_install"
  local oldpwd="$PWD"

  cd "$build_dir" || return 1

  if [[ ! -f "${temp_install_dir}/usr/lib/libcairo.so.2" ]]; then
    error "Instrumented libcairo.so.2 not found in ${temp_install_dir}/usr/lib"
    ls -la "${temp_install_dir}/usr/lib/libcairo.so"* 2>/dev/null || true
    cd "$oldpwd"
    return 1
  fi

  CFLAGS= CXXFLAGS= LDFLAGS= \
  clang "${workload_cflags[@]}" "$srcdir/cairo_workload.c" -o "$srcdir/cairo_workload_runner" \
    -I"${temp_install_dir}/usr/include" \
    -L"${temp_install_dir}/usr/lib" \
    -Wl,-rpath,"${temp_install_dir}/usr/lib" \
    -lcairo -lm "${workload_ldflags[@]}" || {
    error "Workload compilation failed"
    cd "$oldpwd"
    return 1
  }

  export LD_LIBRARY_PATH="${temp_install_dir}/usr/lib:${LD_LIBRARY_PATH}"
  export LLVM_PROFILE_FILE="${profile_dir}/cairo-%p-%m.profraw"

  timeout 180 "$srcdir/cairo_workload_runner" || true

  if ! find "$profile_dir" -name "*.profraw" -size +100k | grep -q .; then
    error "No substantial profiles generated in $profile_dir"
    find "$profile_dir" -name "*.profraw" -exec ls -lh {} \;
    cd "$oldpwd"
    return 1
  fi

  rm -f "$srcdir/cairo_workload_runner"
  cd "$oldpwd"
  return 0
}

build() {
  cd "${srcdir}/cairo"

  local -a orig_cflags=($CFLAGS)
  local -a orig_cxxflags=($CXXFLAGS)
  local -a orig_ldflags=($LDFLAGS)

  local PGO_DIR="${srcdir}/pgo-data"
  local CSPGO_DIR="${srcdir}/cspgo-data"

  rm -rf "$PGO_DIR" "$CSPGO_DIR"
  mkdir -p "$PGO_DIR" "$CSPGO_DIR"

  local meson_opts=(
    -Dspectre=disabled
    -Dpython.bytecompile=2
    -Ddwrite=disabled
    -Dgtk_doc=false
    -Dtee=enabled
    -Dxlib-xcb=enabled
    -Dlzo=disabled
    -Db_ndebug=true
    -Db_pie=false
    -Dc_std=gnu2x
    -Dcpp_std=gnu++2a
    --buildtype=release
    -Dquartz=disabled
    -Dsymbol-lookup=disabled
    -Dtests=disabled
    -Ddefault_library=shared
  )

  msg2 "Stage 1: Building PGO-instrumented Cairo WITH LTO..."

  local -a pgo_instr_cflags=(-fprofile-generate="${PGO_DIR}" -fno-omit-frame-pointer -mllvm -vp-counters-per-site=4096)
  local -a pgo_instr_ldflags=(-fprofile-generate="${PGO_DIR}")
  local -a stage1_cflags=("${orig_cflags[@]}" "${pgo_instr_cflags[@]}")
  local -a stage1_ldflags=("${orig_ldflags[@]}" "${pgo_instr_ldflags[@]}")
  local -a stage1_cxxflags=("${orig_cxxflags[@]}" "${pgo_instr_cflags[@]}")

  rm -rf "${srcdir}/build-pgo"
  arch-meson . "${srcdir}/build-pgo" "${meson_opts[@]}" \
    -Dc_args="$(meson_array "${stage1_cflags[@]}")" \
    -Dcpp_args="$(meson_array "${stage1_cxxflags[@]}")" \
    -Dc_link_args="$(meson_array "${stage1_ldflags[@]}")" || return 1

  meson compile -C "${srcdir}/build-pgo" || return 1
  DESTDIR="${srcdir}/temp_install" meson install -C "${srcdir}/build-pgo" || return 1

  msg2 "Stage 1: Running PGO training workload..."
  run_cairo_workload "${srcdir}/build-pgo" "$PGO_DIR" "${stage1_cflags[@]}" -- "${stage1_ldflags[@]}" || return 1

  msg2 "Stage 1: Merging PGO profiles..."
  llvm-profdata merge -output="${PGO_DIR}/default.profdata" "${PGO_DIR}"/*.profraw || return 1
  rm -f "${PGO_DIR}"/*.profraw

  msg2 "Stage 2: Building CS-PGO instrumented Cairo WITH LTO..."

  rm -rf "${srcdir}/temp_install" "${srcdir}/build-cspgo"

  local -a cspgo_instr_cflags=(-fprofile-use="${PGO_DIR}/default.profdata" -fcs-profile-generate="${CSPGO_DIR}" -fno-omit-frame-pointer -mllvm -vp-counters-per-site=4096)
  local -a cspgo_instr_ldflags=(-fprofile-use="${PGO_DIR}/default.profdata" -fcs-profile-generate="${CSPGO_DIR}")
  local -a stage2_cflags=("${orig_cflags[@]}" "${cspgo_instr_cflags[@]}")
  local -a stage2_ldflags=("${orig_ldflags[@]}" "${cspgo_instr_ldflags[@]}")
  local -a stage2_cxxflags=("${orig_cxxflags[@]}" "${cspgo_instr_cflags[@]}")

  arch-meson . "${srcdir}/build-cspgo" "${meson_opts[@]}" \
    -Dc_args="$(meson_array "${stage2_cflags[@]}")" \
    -Dcpp_args="$(meson_array "${stage2_cxxflags[@]}")" \
    -Dc_link_args="$(meson_array "${stage2_ldflags[@]}")" || return 1

  meson compile -C "${srcdir}/build-cspgo" || return 1
  DESTDIR="${srcdir}/temp_install" meson install -C "${srcdir}/build-cspgo" || return 1

  msg2 "Stage 2: Running CS-PGO training workload..."
  run_cairo_workload "${srcdir}/build-cspgo" "$CSPGO_DIR" "${stage2_cflags[@]}" -- "${stage2_ldflags[@]}" || return 1

  msg2 "Stage 2: Merging CS-PGO profiles..."
  llvm-profdata merge -output="${CSPGO_DIR}/cs.profdata" "${CSPGO_DIR}"/*.profraw "${PGO_DIR}/default.profdata" || return 1
  rm -f "${CSPGO_DIR}"/*.profraw

  msg2 "Stage 3: Building final PGO-optimized Cairo WITH LTO..."

  rm -rf "${srcdir}/temp_install" "${srcdir}/build"

  local -a final_flags=(-fprofile-use="${CSPGO_DIR}/cs.profdata")
  local -a stage3_cflags=("${orig_cflags[@]}" "${final_flags[@]}")
  local -a stage3_ldflags=("${orig_ldflags[@]}" "${final_flags[@]}" -Wl,--emit-relocs)
  local -a stage3_cxxflags=("${orig_cxxflags[@]}" "${final_flags[@]}")

  arch-meson . "${srcdir}/build" "${meson_opts[@]}" \
    -Dc_args="$(meson_array "${stage3_cflags[@]}")" \
    -Dcpp_args="$(meson_array "${stage3_cxxflags[@]}")" \
    -Dc_link_args="$(meson_array "${stage3_ldflags[@]}")" || return 1

  meson compile -C "${srcdir}/build" || return 1
}

package() {
  provides=(
    libcairo-gobject.so
    libcairo-script-interpreter.so
    libcairo.so
    cairo
    cairo-git
  )

  cd "${srcdir}/cairo"
  DESTDIR="${pkgdir}" meson install -C "${srcdir}/build" || return 1

  local lib_path
  lib_path=$(find "${pkgdir}" -type f -name "libcairo.so.*.*.*" | head -n1)
  if [[ -z "$lib_path" ]]; then
    error "Could not find installed libcairo.so in pkgdir"
    return 1
  fi
  local lib_dir
  lib_dir=$(dirname "$lib_path")

  local BOLT_DIR="${srcdir}/bolt-data"
  rm -rf "$BOLT_DIR"
  mkdir -p "$BOLT_DIR"

  msg2 "Stage 4: BOLT instrumentation..."

  cp "$lib_path" "$lib_path.cspgo"

  llvm-bolt "$lib_path.cspgo" \
    --instrument --instrumentation-file-append-pid \
    --instrumentation-file="${BOLT_DIR}/bolt.fdata" \
    -o "$lib_path" || {
    warning "BOLT instrumentation failed, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  }

  msg2 "Stage 4: Running BOLT training workload..."

  export BOLT_PROFILE_FILE="${BOLT_DIR}/bolt.fdata.%p"

  local -a pkg_cflags=($CFLAGS)
  local -a pkg_ldflags=($LDFLAGS)
  local -a workload_cflags=()
  local -a workload_ldflags=()
  filter_workload_flags pkg_cflags workload_cflags
  filter_workload_flags pkg_ldflags workload_ldflags

  CFLAGS= CXXFLAGS= LDFLAGS= \
  clang "${workload_cflags[@]}" "$srcdir/cairo_workload.c" -o "$srcdir/cairo_workload_runner" \
    -I"${pkgdir}/usr/include" \
    -L"$lib_dir" \
    -Wl,-rpath,"$lib_dir" \
    -lcairo -lm "${workload_ldflags[@]}" || {
    warning "Workload recompilation for BOLT failed, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  }

  timeout 180 "$srcdir/cairo_workload_runner" || true

  if ! find "$BOLT_DIR" -name "bolt.fdata.*" -size +10k | grep -q .; then
    warning "No substantial BOLT profiles generated, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  fi

  rm -f "$srcdir/cairo_workload_runner"

  msg2 "Stage 5: Merging BOLT profiles..."

  if command -v merge-fdata >/dev/null 2>&1; then
    merge-fdata ${BOLT_DIR}/bolt.fdata.* > "${BOLT_DIR}/bolt_merged.fdata" 2>/dev/null || {
      warning "BOLT profile merge failed, skipping BOLT optimization"
      mv "$lib_path.cspgo" "$lib_path"
      return 0
    }
  else
    warning "merge-fdata not found, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  fi

  if [[ ! -s "${BOLT_DIR}/bolt_merged.fdata" ]]; then
    warning "Merged BOLT profile is empty, skipping BOLT optimization"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  fi

  msg2 "Stage 6: Applying BOLT optimizations..."

  llvm-bolt "$lib_path.cspgo" \
    --data "${BOLT_DIR}/bolt_merged.fdata" \
    -o "$lib_path" \
    --dyno-stats --lite=false --icf=all --plt=all --peepholes=all \
    --x86-strip-redundant-address-size --indirect-call-promotion=all \
    --reorder-blocks=ext-tsp --reorder-functions=cdsort --split-all-cold \
    --split-eh --split-functions --split-strategy=cdsplit || {
    warning "BOLT optimization failed, using CS-PGO binary"
    mv "$lib_path.cspgo" "$lib_path"
    return 0
  }

  rm -f "$lib_path.cspgo"

  find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null || true
  done
}
