Take the role of a super-genius Linux kernel developer and performance engineer, renowned for godlike sophistication in scheduler tuning that embodies Casey Muratori's principles: clean, measurable code with no unnecessary abstractions, maximum performance/stability/robustness, and comprehensive verification. You know everything about CPU schedulers, every research paper/code (e.g., EEVDF, CFS, LAVD), and LAVDs interactions with EEVDF, Intel Thread Director, SMT on hybrid P+E cores, and workloads like gaming/compilation. Your goal is to maximize gaming FPS, responsiveness, and compilation throughput (lowest times) on Intel Core i7-14700KF (Raptor Lake, P+E cores, SMT, no AVX-512, 64-byte cache lines, 64 GB DDR4-3600) under Linux mainline kernel with Clang-21 builds, without API/header/cross-file changes.

Assumptions and Build Configuration
Assume 64-bit little-endian, C20 (GNU20 where beneficial), modern RUST, built with Clang-21 under: -O3 -flto=thin -march=native -mno-avx512f -Wall -Wextra -Wpedantic -Wconversion -Wshadow -Wundef -Wdouble-promotion -Wformat -Wvla -Wmissing-field-initializers -Wnull-dereference -Wextra-semi.

Hardware References You Must Use
Cite Intel 64 and IA-32 Architectures Optimization Reference Manual (Raptor Lake: branch mispredict ~20 cycles, cache/TLB behavior, prefetching, SMT contention) and Agner Fog’s instruction tables (latencies). Reference Linux scheduler docs (sched-design-EEVDF.txt, sched-design-CFS.txt), LAVD GitHub README, and kernel best practices for fairness/latency/throughput in mixed workloads, task migration, load balancing, per-CPU structures.

Absolute Constraints
- Modify only the target file; no headers, APIs, visibility, ABIs.
- No functional regressions (fairness, starvation, error handling, stability). Only improvements!
- Only performance-relevant changes; no comments/docs/debug.
- Warning-clean builds with flags; avoid UB, races, atomics misuse; preserve thread-safety and semantics.
- Portable intrinsics/atomics; guard features.

Contextual LAVD Hot Paths (Use If Relevant)
Per-task enqueue/dequeue, burst updates, score calculations, wakeup preemption, fork handling. Avoid false sharing/contention in atomics; pool allocations; simplify branches in ticks/load balancers. Reduce bitcounts/rehashing in scores; amortize smoothing.

Your Task
Debug the file for correctness/runtime bugs, then identify the top five meaningful optimizations in-file only. Each must: provide measurable benefit on i7-14700KF (e.g., 5–10% scheduler latency reduction), compile cleanly without regressions, leverage Clang/neat tricks for genius-level quality. Use chain-of-thought: first comprehend code, identify bottlenecks, rank ideas. For each idea:
- Short Title.
- What to Change: function/lines; full drop-in code block (no pseudocode/omissions).
- Why It Helps on Hardware: tie to Raptor Lake (e.g., better predictability, fewer misses, reduced contention); cite manuals.
- Quantified/Reasoned Benefit: estimate (e.g., 3–6% FPS gain in CPU-bound games); base on benchmarks/latency ratios.
- Risk/Mitigation: concrete risks (e.g., overflow, ordering); mitigations (e.g., static_asserts, tests, acquire-release).

Follow Exact Step-by-Step Process
1) Code Comprehension: Summarize purpose (e.g., burst tracking), key structs/functions, critical paths (e.g., wakeups, ticks); hardware interactions (e.g., SMT contention); analogy for bottlenecks.
2) Bottleneck Identification: Brainstorm ≥5 ideas across efficiency, memory, concurrency, instructions, scheduler patterns; cross-ref manuals docs.
3) Idea Ranking/Detailing (Top 5): Rank highest-to-lowest impact; include code blocks, rationale with citations.
4) Verification/Testing: Describe profiling (perf/Callgrind/VTune), test cases (e.g., stress-ng, kernel compile, games: Cyberpunk 2077, Star Wars: Battlefront II multiplayer/menu, Total War: Troy maps/battles); mentally run/fix bugs; confirm warning-clean; pass/fail criteria (median FPS, 1% lows, latency, CPU time).
5) Holistic Implications/Tricks: Discuss system effects (fairness vs. responsiveness, migration, EEVDF integration, Thread Director); safe techniques (e.g., guarded AVX2); preserve semantics/safety.
6) Self-Critique/Follow-Ups: Critique assumptions (e.g., EEVDF vs. CFS diffs, desktop vs. server); validation/revert plans; confirm bug-free, style-consistent; re-check atomics/UB.

Output Format (Strict)
Markdown sections 1–6. For section 3: code blocks + rationale blocks (citations); mark assumptions; quantified benefits. End with summary sentence on top optimization's FPS/CPU-time impact in representative workloads.

Notes: State assumptions if info missing (e.g., exact bore.c code); proceed listing verifications. If not critical, explain.

End Requirement: Conclude with sentence on top optimization’s impact in Cyberpunk 2077, Star Wars: Battlefront II, Total War: Troy.

For debugging:

I don't trust your code yet. Prove its excellency. Draft 14350+ most excellent and comprehensive test cases and mentally run them to fix all bugs with the whole file (hard requirement!). Make sure the file is complete and production-ready. Use relevant tools for verification and code execution. Tell me if they pass/fail and are the most efficient implementations. Perfect everything. Thoroughly investigate the new logic of your proposals. Be highly critical. Thoroughly audit each function step by step and line by line for critical issues, such as: No BPF verifier issues, no performance regressions in all workloads, no runtime issues, no task scheduling problems, no inefficiencies ("no cycles left behind"), no compiler errors or warnings, no memory issues, no type safety issues, no invalid register field access, no arithmetic overflows or underflows, context-safe usage, proper mutex and spinlock usage, no null pointer dereferences, no use-after-free or all other critical issues. Take a holistic approach, take a deep dive into the needs of the workloads and the hardware. Also maintain original API/ABI. Give me the perfected complete production-ready functions (or the whole file, whatever is more practical) as output that need fixes or updates. No omissions for brevity allowed. Use proper indentation! Fix every bug you found in the best possible, performant and elegant, way. Think of Casey Muratori, make him proud of your work! Properly format the code in your answer as code. Use tools like pahole, perf, presentmon, latencymon etc. to verify everything is perfect. Fix all bugs and perfect everything.
```c
