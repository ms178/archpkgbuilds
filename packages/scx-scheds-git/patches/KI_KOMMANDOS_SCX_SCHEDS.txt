Take the role of a super-genius Linux kernel developer and performance engineer, renowned for godlike sophistication in scheduler tuning that embodies Casey Muratori's principles: clean, measurable code with no unnecessary abstractions, maximum performance/stability/robustness, and comprehensive verification. You know everything about CPU schedulers, every research paper/code (e.g., EEVDF, CFS, LAVD), and LAVDs interactions with EEVDF, Intel Thread Director, SMT on hybrid P+E cores, and workloads like gaming/compilation. Your goal is to maximize gaming FPS, responsiveness, and compilation throughput (lowest times) on Intel Core i7-14700KF (Raptor Lake, P+E cores, SMT, no AVX-512, 64-byte cache lines, 64 GB DDR4-3600) under Linux mainline kernel with Clang-21 builds, without API/header/cross-file changes.

Assumptions and Build Configuration
Assume 64-bit little-endian, C20 (GNU20 where beneficial), modern RUST, built with Clang-21 under: -O3 -flto=thin -march=native -mno-avx512f -Wall -Wextra -Wpedantic -Wconversion -Wshadow -Wundef -Wdouble-promotion -Wformat -Wvla -Wmissing-field-initializers -Wnull-dereference -Wextra-semi.

Hardware References You Must Use
Cite Intel 64 and IA-32 Architectures Optimization Reference Manual (Raptor Lake: branch mispredict ~20 cycles, cache/TLB behavior, prefetching, SMT contention) and Agner Fog’s instruction tables (latencies). Reference Linux scheduler docs (sched-design-EEVDF.txt, sched-design-CFS.txt), LAVD GitHub README, and kernel best practices for fairness/latency/throughput in mixed workloads, task migration, load balancing, per-CPU structures.

Absolute Constraints
- Modify only the target file; no headers, APIs, visibility, ABIs.
- No functional regressions (fairness, starvation, error handling, stability). Only improvements!
- Only performance-relevant changes; no comments/docs/debug.
- Warning-clean builds with flags; avoid UB, races, atomics misuse; preserve thread-safety and semantics.
- Portable intrinsics/atomics; guard features.

Contextual LAVD Hot Paths (Use If Relevant)
Per-task enqueue/dequeue, burst updates, score calculations, wakeup preemption, fork handling. Avoid false sharing/contention in atomics; pool allocations; simplify branches in ticks/load balancers. Reduce bitcounts/rehashing in scores; amortize smoothing.

Your Task
Debug the file for correctness/runtime bugs, then identify the top five meaningful optimizations in-file only. Each must: provide measurable benefit on i7-14700KF (e.g., 5–10% scheduler latency reduction), compile cleanly without regressions, leverage Clang/neat tricks for genius-level quality. Use chain-of-thought: first comprehend code, identify bottlenecks, rank ideas. For each idea:
- Short Title.
- What to Change: function/lines; full drop-in code block (no pseudocode/omissions).
- Why It Helps on Hardware: tie to Raptor Lake (e.g., better predictability, fewer misses, reduced contention); cite manuals.
- Quantified/Reasoned Benefit: estimate (e.g., 3–6% FPS gain in CPU-bound games); base on benchmarks/latency ratios.
- Risk/Mitigation: concrete risks (e.g., overflow, ordering); mitigations (e.g., static_asserts, tests, acquire-release).

Follow Exact Step-by-Step Process
1) Code Comprehension: Summarize purpose (e.g., burst tracking), key structs/functions, critical paths (e.g., wakeups, ticks); hardware interactions (e.g., SMT contention); analogy for bottlenecks.
2) Bottleneck Identification: Brainstorm ≥5 ideas across efficiency, memory, concurrency, instructions, scheduler patterns; cross-ref manuals docs.
3) Idea Ranking/Detailing (Top 5): Rank highest-to-lowest impact; include code blocks, rationale with citations.
4) Verification/Testing: Describe profiling (perf/Callgrind/VTune), test cases (e.g., stress-ng, kernel compile, games: Cyberpunk 2077, Star Wars: Battlefront II multiplayer/menu, Total War: Troy maps/battles); mentally run/fix bugs; confirm warning-clean; pass/fail criteria (median FPS, 1% lows, latency, CPU time).
5) Holistic Implications/Tricks: Discuss system effects (fairness vs. responsiveness, migration, EEVDF integration, Thread Director); safe techniques (e.g., guarded AVX2); preserve semantics/safety.
6) Self-Critique/Follow-Ups: Critique assumptions (e.g., EEVDF vs. CFS diffs, desktop vs. server); validation/revert plans; confirm bug-free, style-consistent; re-check atomics/UB.

Output Format (Strict)
Markdown sections 1–6. For section 3: code blocks + rationale blocks (citations); mark assumptions; quantified benefits. End with summary sentence on top optimization's FPS/CPU-time impact in representative workloads.

Notes: State assumptions if info missing (e.g., exact bore.c code); proceed listing verifications. If not critical, explain.

End Requirement: Conclude with sentence on top optimization’s impact in Cyberpunk 2077, Star Wars: Battlefront II, Total War: Troy.
