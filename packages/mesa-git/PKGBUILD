# Contributor: mesa-tkg-git
# Optimized for: AMD Vega 64 + Intel Core i7-14700KF
# vim: set ft=bash :

# Track basedir as different Arch-based distros move srcdir around
_where="${PWD}"

# Source configuration
source "${_where}/customization.cfg"

# Load external configuration file if present
if [[ -e "${_where}/mesa-userpatches/user.cfg" ]]; then
    source "${_where}/mesa-userpatches/user.cfg"
    msg2 "User.cfg config loaded"
elif [[ -n "${_EXT_CONFIG_PATH}" ]]; then
    _expanded_config="${_EXT_CONFIG_PATH/#\~/$HOME}"
    if [[ -e "${_expanded_config}" ]]; then
        source "${_expanded_config}"
        msg2 "External configuration file ${_EXT_CONFIG_PATH} loaded"
    fi
fi

# Validate and normalize boolean configurations
_normalize_bool() {
    local varname="$1"
    local val="${!varname}"
    case "${val,,}" in
        true|yes|1|on) printf -v "$varname" '%s' "true" ;;
        *) printf -v "$varname" '%s' "false" ;;
    esac
}

# Normalize all boolean options
_normalize_bool _lib32
_normalize_bool _NUKR
_normalize_bool _localglesv2pc
_normalize_bool _localeglpc
_normalize_bool _enable_lto
_normalize_bool _force_broken_lto
_normalize_bool _user_patches
_normalize_bool _user_patches_no_confirm
_normalize_bool _rusticl
_normalize_bool _shader_cache
_normalize_bool _amd_use_llvm
_normalize_bool _draw_use_llvm

# Package names
pkgname=('mesa-tkg-git')
[[ "${_lib32}" == "true" ]] && pkgname+=('lib32-mesa-tkg-git')

# Git version specification
if [[ -n "${_mesa_commit}" ]]; then
    _mesa_version="#commit=${_mesa_commit}"
else
    _mesa_version="#branch=${_mesa_branch}"
fi

pkgdesc="An open-source implementation of the OpenGL specification - git version"
pkgver=26.1.0_devel.218449.822da92d68a
pkgrel=1
arch=('x86_64')
url="https://www.mesa3d.org"
license=('MIT AND BSD-3-Clause AND SGI-B-2.0')

# Build options - will be modified based on configuration
_base_options=('!strip')

# Handle LTO in makepkg options
if [[ "${_enable_lto}" == "true" ]] && [[ "${_force_broken_lto}" == "true" ]]; then
    msg2 "WARNING: LTO enabled with force override - this is UNSUPPORTED upstream!"
else
    _base_options+=('!lto')
fi

# Check for debug build
if [[ "${_build_type}" == "debug" ]]; then
    _base_options+=('debug')
fi

# Use ccache if available
if command -v ccache &>/dev/null && pacman -Qq ccache &>/dev/null; then
    _base_options+=('ccache')
    msg2 "ccache found and will be used"
fi

options=("${_base_options[@]}")

# Core makedepends
makedepends=(
    'git'
    'meson'
    'ninja'
    'python'
    'python-mako'
    'python-ply'
    'python-packaging'
    'python-pyyaml'
    'xorgproto'
    'libxml2'
    'libx11'
    'libvdpau'
    'libva'
    'elfutils'
    'libxrandr'
    'libgcrypt'
    'wayland'
    'wayland-protocols'
    'libdrm'
    'libxshmfence'
    'libxxf86vm'
    'libxdamage'
    'libclc'
    'libglvnd'
    'libunwind'
    'lm_sensors'
    'glslang'
    'flex'
    'bison'
    'wget'
    'spirv-llvm-translator'
    'spirv-tools'
    'zstd'
)

# Rust dependencies (for rusticl and other Rust components)
makedepends+=(
    'rust'
    'rust-bindgen'
    'cbindgen'
)

# 32-bit build dependencies
if [[ "${_lib32}" == "true" ]]; then
    makedepends+=(
        'lib32-libxml2'
        'lib32-libx11'
        'lib32-libdrm'
        'lib32-libxshmfence'
        'lib32-libxxf86vm'
        'lib32-gcc-libs'
        'lib32-libvdpau'
        'lib32-libelf'
        'lib32-libgcrypt'
        'lib32-lm_sensors'
        'lib32-libxdamage'
        'gcc-multilib'
        'lib32-libunwind'
        'lib32-libglvnd'
        'lib32-libva'
        'lib32-wayland'
        'lib32-libxrandr'
        'lib32-expat'
        'lib32-spirv-llvm-translator'
        'lib32-rust-libs'
        'lib32-zstd'
    )
fi

depends=(
    'libdrm'
    'libxxf86vm'
    'libxdamage'
    'libxshmfence'
    'libelf'
    'libunwind'
    'libglvnd'
    'wayland'
    'lm_sensors'
    'libclc'
    'glslang'
    'zstd'
    'vulkan-icd-loader'
)

[[ "${_lib32}" == "true" ]] && depends+=('lib32-zstd' 'lib32-vulkan-icd-loader')

optdepends=('opengl-man-pages: for the OpenGL API man pages')

# LLVM selection (environment variable takes precedence)
MESA_WHICH_LLVM="${MESA_WHICH_LLVM:-4}"

# Validate MESA_WHICH_LLVM
if [[ ! "${MESA_WHICH_LLVM}" =~ ^[1-4]$ ]]; then
    MESA_WHICH_LLVM=4
fi

# Interactive LLVM selection if not set via environment and marker doesn't exist
if [[ -z "${MESA_WHICH_LLVM}" ]] && [[ ! -e "${_where}/frogminer" ]]; then
    plain "Which LLVM package tree do you want to use to build mesa-tkg-git against?"
    read -rp "$(cat <<'EOF'
     1. llvm-minimal-git (AUR)
     2. llvm-git (AUR)
     3. llvm-git from LordHeavy unofficial repo
   > 4. llvm (default)
    choice [1-4]:
EOF
)" MESA_WHICH_LLVM
    touch "${_where}/frogminer"
fi

# Configure LLVM dependencies
case "${MESA_WHICH_LLVM}" in
    1)
        makedepends+=('llvm-minimal-git' 'clang-minimal-git')
        _llvm='llvm-libs-minimal-git'
        if [[ "${_lib32}" == "true" ]]; then
            makedepends+=('lib32-llvm-minimal-git')
            _lib32_llvm='lib32-llvm-libs-minimal-git'
        fi
        msg2 "Using llvm-minimal-git (AUR)"
        ;;
    2)
        makedepends+=('aur-llvm-git' 'aur-clang-git')
        _llvm='aur-llvm-libs-git'
        if [[ "${_lib32}" == "true" ]]; then
            makedepends+=('aur-lib32-llvm-git')
            _lib32_llvm='aur-lib32-llvm-libs-git'
        fi
        msg2 "Using llvm-git (AUR)"
        ;;
    3)
        makedepends+=('llvm-git' 'clang-git')
        _llvm='llvm-libs-git'
        if [[ "${_lib32}" == "true" ]]; then
            makedepends+=('lib32-llvm-git')
            _lib32_llvm='lib32-llvm-libs-git'
        fi
        msg2 "Using llvm-git from LordHeavy unofficial repo"
        ;;
    4|*)
        makedepends+=('llvm>=18.0.0' 'clang>=18.0.0')
        _llvm='llvm-libs>=18.0.0'
        if [[ "${_lib32}" == "true" ]]; then
            makedepends+=('lib32-llvm>=18.0.0' 'lib32-clang>=18.0.0')
            _lib32_llvm='lib32-llvm-libs>=18.0.0'
        fi
        msg2 "Using llvm (default)"
        MESA_WHICH_LLVM=4
        ;;
esac

_sourceurl="mesa::git+${_mesa_source}${_mesa_version}"
_mesa_srcdir="mesa"

source=(
    "${_sourceurl}"
    'LICENSE'
    'llvm32.native'
)
b2sums=(
    'SKIP'
    'SKIP'
    'SKIP'
)

# User patch function
_user_patcher() {
    local _userpatch_target="$1"
    local _userpatch_ext="$2"
    local _CONDITION=""

    # Process reverts first
    local -a _patches
    mapfile -t _patches < <(find "${_where}" -maxdepth 1 -name "*.${_userpatch_ext}revert" -type f 2>/dev/null)

    if [[ ${#_patches[@]} -gt 0 ]]; then
        if [[ "${_user_patches_no_confirm}" != "true" ]]; then
            msg2 "Found ${#_patches[@]} 'to revert' userpatches for ${_userpatch_target}:"
            printf '%s\n' "${_patches[@]##*/}"
            read -rp "Do you want to revert them? [N/y]: " _CONDITION
        fi
        if [[ "${_CONDITION,,}" == "y" ]] || [[ "${_user_patches_no_confirm}" == "true" ]]; then
            for _f in "${_patches[@]}"; do
                msg2 "Reverting patch: ${_f##*/}"
                if ! patch -Np1 -R < "${_f}"; then
                    error "Failed to revert patch: ${_f##*/}"
                    return 1
                fi
                echo "Reverted patch: ${_f##*/}" >> "${_where}/last_build_config.log"
            done
        fi
    fi

    # Process patches
    _CONDITION=""
    mapfile -t _patches < <(find "${_where}" -maxdepth 1 -name "*.${_userpatch_ext}patch" -type f 2>/dev/null)

    if [[ ${#_patches[@]} -gt 0 ]]; then
        if [[ "${_user_patches_no_confirm}" != "true" ]]; then
            msg2 "Found ${#_patches[@]} userpatches for ${_userpatch_target}:"
            printf '%s\n' "${_patches[@]##*/}"
            read -rp "Do you want to apply them? [N/y]: " _CONDITION
        fi
        if [[ "${_CONDITION,,}" == "y" ]] || [[ "${_user_patches_no_confirm}" == "true" ]]; then
            for _f in "${_patches[@]}"; do
                msg2 "Applying patch: ${_f##*/}"
                if ! patch -Np1 < "${_f}"; then
                    error "Failed to apply patch: ${_f##*/}"
                    return 1
                fi
                echo "Applied patch: ${_f##*/}" >> "${_where}/last_build_config.log"
            done
        fi
    fi
}

pkgver() {
    cd "${_mesa_srcdir}" || exit 1
    local _ver
    _ver=$(cat VERSION)
    printf '%s.%s.%s' "${_ver//-/_}" "$(git rev-list --count HEAD)" "$(git rev-parse --short HEAD)"
}

prepare() {
    cd "${srcdir}/${_mesa_srcdir}" || exit 1

    # Clean the tree
    git reset --hard HEAD
    git clean -xdf

    if [[ -n "${_mesa_commit}" ]]; then
        git checkout "${_mesa_commit}" || {
            error "Failed to checkout commit: ${_mesa_commit}"
            return 1
        }
    fi
    msg2 "Tree cleaned"

    # Prepare userpatches directory
    mkdir -p "${_where}/mesa-userpatches"

    # Copy userpatches to working directory
    rm -f "${_where}"/*.mymesa*
    cp "${_where}"/mesa-userpatches/*.mymesa* "${_where}/" 2>/dev/null || true

    # Fetch merge request patches
    if [[ -n "${_mesa_prs}" ]]; then
        for _pr in ${_mesa_prs}; do
            msg2 "Fetching MR ${_pr}..."
            if ! wget -q -O "${_where}/${_pr}.mymesapatch" \
                "https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/${_pr}.diff"; then
                warning "Failed to fetch MR ${_pr}"
            fi
        done
    fi

    # Link community patches
    if [[ -n "${_community_patches}" ]]; then
        if [[ ! -d "${_where}/../community-patches" ]]; then
            msg2 "Cloning community-patches repository..."
            git clone --depth=1 https://github.com/Frogging-Family/community-patches.git \
                "${_where}/../community-patches"
        fi
        for _p in ${_community_patches}; do
            if [[ -e "${_where}/../community-patches/mesa-git/${_p}" ]]; then
                ln -sf "${_where}/../community-patches/mesa-git/${_p}" "${_where}/"
            else
                warning "Community patch not found: ${_p}"
            fi
        done
    fi

    # Initialize build log
    {
        echo "# Mesa TKG Build Configuration - $(date)"
        echo "# ============================================"
        echo "# LLVM: ${MESA_WHICH_LLVM}"
        echo "# Compiler: ${_compiler}"
        echo "# Build type: ${_build_type:-release}"
        echo "# LTO: ${_enable_lto} (forced: ${_force_broken_lto})"
        echo "# Gallium drivers: ${_gallium_drivers}"
        echo "# Vulkan drivers: ${_vulkan_drivers}"
        echo "# Vulkan layers: ${_vulkan_layers:-device-select,overlay}"
        echo "# Video codecs: ${_codecs}"
        echo "# Rusticl: ${_rusticl}"
        echo "# Shader cache: ${_shader_cache}"
        echo "# AMD use LLVM: ${_amd_use_llvm}"
        echo ""
    } > "${_where}/last_build_config.log"

    # Apply user patches
    if [[ "${_user_patches}" == "true" ]]; then
        _user_patcher "mesa" "mymesa"
    fi

    # Cleanup temporary patch links
    for _p in ${_community_patches}; do
        rm -f "${_where}/${_p}"
    done
    for _pr in ${_mesa_prs}; do
        rm -f "${_where}/${_pr}.mymesapatch"
    done

    cd "${srcdir}" || exit 1

    # Handle build directory cleanup (respects PGO workflow)
    if [[ "${_NUKR}" == "true" ]]; then
        for _bdir in _build64 _build32; do
            if [[ -d "${_bdir}" ]]; then
                if [[ "${_additional_meson_flags}" == *-Db_pgo=use* ]]; then
                    # Preserve PGO data
                    find "./${_bdir}" -type f ! -name '*.gcda' -delete 2>/dev/null || true
                else
                    rm -rf "${_bdir}"
                fi
            fi
        done
    fi
}

build() {
    # Helper: Check if a gallium driver is enabled
    _has_gallium_driver() {
        [[ ",${_gallium_drivers}," == *",$1,"* ]]
    }

    # Helper: Check if any of the listed drivers are enabled
    _has_any_gallium_driver() {
        local driver
        for driver in "$@"; do
            _has_gallium_driver "${driver}" && return 0
        done
        return 1
    }

    # Setup compiler environment
    _setup_compiler() {
        local _m32_flag="$1"

        if [[ "${_compiler}" == "clang" ]]; then
            export CC="clang"
            export CXX="clang++"
        else
            export CC="gcc"
            export CXX="g++"
        fi

        if [[ -n "${_m32_flag}" ]]; then
            export CC="${CC} -m32"
            export CXX="${CXX} -m32"
        fi

        # Custom GCC path
        if [[ -n "${CUSTOM_GCC_PATH}" ]] && [[ "${_compiler}" != "clang" ]]; then
            if [[ -d "${CUSTOM_GCC_PATH}" ]]; then
                export PATH="${CUSTOM_GCC_PATH}/bin:${PATH}"
                msg2 "Using custom GCC from: ${CUSTOM_GCC_PATH}"
            else
                warning "Custom GCC path does not exist: ${CUSTOM_GCC_PATH}"
            fi
        fi
    }

    # Configure meson build
    _configure_build() {
        local _build_dir="$1"
        local _lib_dir="$2"
        local _extra_flags="$3"
        local _is_32bit="$4"

        # Determine feature availability based on drivers
        local _gallium_va="disabled"
        local _gallium_vdpau="disabled"

        if _has_any_gallium_driver r600 radeonsi nouveau virgl; then
            _gallium_va="enabled"
        else
            warning "Gallium VA disabled (requires r600, radeonsi, nouveau, or virgl)"
        fi

        if _has_any_gallium_driver r300 r600 radeonsi nouveau; then
            _gallium_vdpau="enabled"
        else
            warning "Gallium VDPAU disabled (requires r300, r600, radeonsi, or nouveau)"
        fi

        # Vulkan layers configuration
        local _vk_layers="${_vulkan_layers:-device-select,overlay}"

        # Build meson arguments
        local -a _meson_args=(
            --wrap-mode=nofallback
            --unity=subprojects
            --buildtype="${_build_type:-release}"

            # Core options
            -D b_ndebug=true
            -D b_lundef=false
            -D python.bytecompile=2

            # Build tests disabled
            -D build-tests=false
            -D enable-glcpp-tests=false

            # Platform configuration
            -D platforms=x11,wayland
            -D egl-native-platform=auto

            # API support
            -D egl=enabled
            -D gbm=enabled
            -D glvnd=enabled
            -D glx=dri
            -D opengl=true
            -D gles1=disabled
            -D gles2=enabled

            # LLVM configuration
            -D llvm=enabled
            -D shared-llvm=enabled
            -D amd-use-llvm="${_amd_use_llvm}"
            -D draw-use-llvm="${_draw_use_llvm}"

            # Driver selection
            -D gallium-drivers="${_gallium_drivers}"
            -D vulkan-drivers="${_vulkan_drivers}"
            -D vulkan-layers="${_vk_layers}"

            # Video support
            -D video-codecs="${_codecs}"
            -D gallium-va="${_gallium_va}"

            # Additional features
            -D zstd=enabled
            -D lmsensors=enabled
            -D valgrind=disabled

            # Disabled/unsupported features
            -D android-libbacktrace=disabled
            -D gallium-extra-hud=false
            -D intel-rt=disabled
            -D microsoft-clc=disabled
            -D gallium-d3d12-graphics=disabled
            -D gallium-d3d12-video=disabled
            -D gallium-mediafoundation=disabled
        )

        # Add libdir if specified
        [[ -n "${_lib_dir}" ]] && _meson_args+=(--libdir="${_lib_dir}")

        # Shader cache configuration
        if [[ "${_shader_cache}" == "true" ]]; then
            _meson_args+=(-D shader-cache=enabled)
            _meson_args+=(-D shader-cache-default=true)
            if [[ -n "${_shader_cache_max_size}" ]]; then
                _meson_args+=(-D shader-cache-max-size="${_shader_cache_max_size}")
            fi
        else
            _meson_args+=(-D shader-cache=disabled)
        fi

        # Rusticl configuration (64-bit only)
        if [[ "${_rusticl}" == "true" ]] && [[ "${_is_32bit}" != "true" ]]; then
            _meson_args+=(-D gallium-rusticl=true)
        else
            _meson_args+=(-D gallium-rusticl=false)
        fi

        # LTO configuration (accounting for upstream's block)
        if [[ "${_enable_lto}" == "true" ]]; then
            if [[ "${_force_broken_lto}" == "true" ]]; then
                _meson_args+=(
                    -D b_lto=true
                    -D allow-broken-lto=true
                )
                warning "LTO enabled with force override - this is UNSUPPORTED upstream!"
            else
                error "LTO requested but _force_broken_lto is not set to 'true'"
                error "Upstream Mesa has disabled LTO. Set _force_broken_lto='true' to override."
                return 1
            fi
        else
            _meson_args+=(-D b_lto=false)
        fi

        # Add extra flags (properly split)
        local _flag
        for _flag in ${_extra_flags}; do
            _meson_args+=("${_flag}")
        done

        arch-meson "${_mesa_srcdir}" "${_build_dir}" "${_meson_args[@]}"
    }

    # Apply custom optimization flags
    if [[ -n "${_custom_opt_flags}" ]]; then
        export CFLAGS="${_custom_opt_flags}"
        export CPPFLAGS="${_custom_opt_flags}"
        export CXXFLAGS="${_custom_opt_flags}"
    fi

    # ========== 64-bit Build ==========
    msg2 "Configuring 64-bit build..."
    _setup_compiler ""
    _configure_build "_build64" "" "${_additional_meson_flags} ${_additional_meson_flags_64}" "false"

    msg2 "Building 64-bit..."
    meson configure _build64 --no-pager
    ninja ${NINJAFLAGS} -C _build64

    # Generate PC files if needed
    if [[ "${_localglesv2pc}" == "true" ]]; then
        cat > "${srcdir}/_build64/glesv2.pc" <<EOF
prefix=/usr
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: glesv2
Description: Mesa OpenGL ES 2.0 library
Version: ${pkgver}
Libs: -L\${libdir} -lGLESv2
Libs.private: -lpthread -pthread -lm -ldl
Cflags: -I\${includedir}
EOF
    fi

    if [[ "${_localeglpc}" == "true" ]]; then
        cat > "${srcdir}/_build64/egl.pc" <<EOF
prefix=/usr
libdir=\${prefix}/lib
includedir=\${prefix}/include

Name: egl
Description: Mesa EGL Library
Version: ${pkgver}
Requires.private: x11, xext, xdamage, xfixes, x11-xcb, xcb, xcb-glx, xcb-dri2, xxf86vm, libdrm
Libs: -L\${libdir} -lEGL
Libs.private: -lpthread -pthread -lm -ldl
Cflags: -I\${includedir}
EOF
    fi

    # ========== 32-bit Build ==========
    if [[ "${_lib32}" == "true" ]]; then
        msg2 "Configuring 32-bit build..."
        _setup_compiler "-m32"
        export PKG_CONFIG="i686-pc-linux-gnu-pkg-config"

        _configure_build "_build32" "/usr/lib32" "${_additional_meson_flags} ${_additional_meson_flags_32}" "true"

        msg2 "Building 32-bit..."
        meson configure _build32 --no-pager
        ninja ${NINJAFLAGS} -C _build32

        # Generate 32-bit PC files if needed
        if [[ "${_localglesv2pc}" == "true" ]]; then
            cat > "${srcdir}/_build32/glesv2.pc" <<EOF
prefix=/usr
libdir=\${prefix}/lib32
includedir=\${prefix}/include

Name: glesv2
Description: Mesa OpenGL ES 2.0 library
Version: ${pkgver}
Libs: -L\${libdir} -lGLESv2
Libs.private: -lpthread -pthread -lm -ldl
Cflags: -I\${includedir}
EOF
        fi

        if [[ "${_localeglpc}" == "true" ]]; then
            cat > "${srcdir}/_build32/egl.pc" <<EOF
prefix=/usr
libdir=\${prefix}/lib32
includedir=\${prefix}/include

Name: egl
Description: Mesa EGL Library
Version: ${pkgver}
Requires.private: x11, xext, xdamage >= 1.1, xfixes, x11-xcb, xcb, xcb-glx >= 1.8.1, xcb-dri2 >= 1.8, xxf86vm, libdrm >= 2.4.75
Libs: -L\${libdir} -lEGL
Libs.private: -lpthread -pthread -lm -ldl
Cflags: -I\${includedir}
EOF
        fi
    fi
}

package_mesa-tkg-git() {
    depends=(
        'libdrm'
        'wayland'
        'libxxf86vm'
        'libxdamage'
        'libxshmfence'
        'libelf'
        'libunwind'
        'lm_sensors'
        'libglvnd'
        'expat'
        'libclc'
        'libx11'
        'zstd'
        'vulkan-icd-loader'
        "${_llvm}"
    )

    # Add rusticl dependency if enabled
    if [[ "${_rusticl}" == "true" ]]; then
        depends+=('opencl-clover-mesa' 'ocl-icd')
        optdepends+=('opencl-headers: for OpenCL development')
    fi

    provides=(
        "mesa=${pkgver}-${pkgrel}"
        "vulkan-radeon=${pkgver}-${pkgrel}"
        "vulkan-mesa-layers=${pkgver}-${pkgrel}"
        "mesa-vulkan-layers=${pkgver}-${pkgrel}"
        "libva-mesa-driver=${pkgver}-${pkgrel}"
        "mesa-vdpau=${pkgver}-${pkgrel}"
        "opencl-mesa=${pkgver}-${pkgrel}"
        'vulkan-driver'
        'opengl-driver'
        'opencl-driver'
        'ati-dri'
        'mesa-dri'
        'mesa-libgl'
        'vulkan-swrast'
    )

    conflicts=(
        'mesa'
        'opencl-mesa'
        'vulkan-radeon'
        'vulkan-mesa-layers'
        'mesa-vulkan-layers'
        'libva-mesa-driver'
        'mesa-vdpau'
        'vulkan-swrast'
    )

    DESTDIR="${pkgdir}" ninja ${NINJAFLAGS} -C _build64 install

    # Remove Python script (not needed in package)
    rm -f "${pkgdir}/usr/bin/mesa-overlay-control.py"

    # Indirect rendering symlink
    ln -sf /usr/lib/libGLX_mesa.so.0 "${pkgdir}/usr/lib/libGLX_indirect.so.0"

    # Install local PC files if configured
    if [[ "${_localglesv2pc}" == "true" ]]; then
        install -Dm644 "${srcdir}/_build64/glesv2.pc" "${pkgdir}/usr/lib/pkgconfig/glesv2.pc"
    fi
    if [[ "${_localeglpc}" == "true" ]]; then
        install -Dm644 "${srcdir}/_build64/egl.pc" "${pkgdir}/usr/lib/pkgconfig/egl.pc"
    fi

    # Install license
    install -Dm644 "${srcdir}/LICENSE" "${pkgdir}/usr/share/licenses/${pkgname}/LICENSE"
}

package_lib32-mesa-tkg-git() {
    depends=(
        'lib32-libdrm'
        'lib32-libxxf86vm'
        'lib32-libxdamage'
        'lib32-libxshmfence'
        'lib32-lm_sensors'
        'lib32-libelf'
        'lib32-wayland'
        'lib32-libglvnd'
        'lib32-libx11'
        'lib32-zstd'
        'lib32-vulkan-icd-loader'
        'lib32-expat'
        'lib32-libva'
        'mesa'
        "${_lib32_llvm}"
    )

    provides=(
        "lib32-mesa=${pkgver}-${pkgrel}"
        "lib32-vulkan-radeon=${pkgver}-${pkgrel}"
        "lib32-vulkan-mesa-layers=${pkgver}-${pkgrel}"
        "lib32-mesa-vulkan-layers=${pkgver}-${pkgrel}"
        "lib32-libva-mesa-driver=${pkgver}-${pkgrel}"
        "lib32-mesa-vdpau=${pkgver}-${pkgrel}"
        'lib32-opengl-driver'
        'lib32-vulkan-driver'
        'lib32-ati-dri'
        'lib32-mesa-dri'
        'lib32-mesa-libgl'
        'lib32-vulkan-swrast'
    )

    conflicts=(
        'lib32-mesa'
        'lib32-vulkan-radeon'
        'lib32-vulkan-mesa-layers'
        'lib32-mesa-vulkan-layers'
        'lib32-libva-mesa-driver'
        'lib32-mesa-vdpau'
        'lib32-vulkan-swrast'
    )

    DESTDIR="${pkgdir}" ninja ${NINJAFLAGS} -C _build32 install

    # Remove files that conflict with 64-bit package
    rm -f "${pkgdir}/usr/include/EGL/eglext_angle.h"
    rm -f "${pkgdir}/usr/include/EGL/eglmesaext.h"
    rm -f "${pkgdir}/usr/include/GL/internal/dri_interface.h"
    rm -f "${pkgdir}/usr/include/gbm.h"
    rm -f "${pkgdir}/usr/include/gbm_backend_abi.h"
    rm -f "${pkgdir}/usr/include/xa_composite.h"
    rm -f "${pkgdir}/usr/include/xa_context.h"
    rm -f "${pkgdir}/usr/include/xa_tracker.h"
    rm -f "${pkgdir}/usr/share/drirc.d/00-mesa-defaults.conf"
    rm -f "${pkgdir}/usr/share/drirc.d/00-radv-defaults.conf"
    rm -f "${pkgdir}/usr/share/glvnd/egl_vendor.d/50_mesa.json"
    rm -f "${pkgdir}/usr/share/vulkan/explicit_layer.d/VkLayer_MESA_overlay.json"
    rm -f "${pkgdir}/usr/share/vulkan/implicit_layer.d/VkLayer_MESA_device_select.json"
    rm -f "${pkgdir}/usr/share/vulkan/implicit_layer.d/VkLayer_MESA_anti_lag.json"

    # Remove Python script
    rm -f "${pkgdir}/usr/bin/mesa-overlay-control.py"

    # Indirect rendering symlink
    ln -sf /usr/lib32/libGLX_mesa.so.0 "${pkgdir}/usr/lib32/libGLX_indirect.so.0"

    # Install local PC files if configured
    if [[ "${_localglesv2pc}" == "true" ]]; then
        install -Dm644 "${srcdir}/_build32/glesv2.pc" "${pkgdir}/usr/lib32/pkgconfig/glesv2.pc"
    fi
    if [[ "${_localeglpc}" == "true" ]]; then
        install -Dm644 "${srcdir}/_build32/egl.pc" "${pkgdir}/usr/lib32/pkgconfig/egl.pc"
    fi
}

# Cleanup trap
trap '_exit_cleanup' EXIT

_exit_cleanup() {
    # Reset pkgver in PKGBUILD
    if [[ "${pkgver}" != "0" ]]; then
        sed -i "s/^pkgver=.*/pkgver=0/" "${_where}/PKGBUILD" 2>/dev/null || true
    fi

    # Remove temporary files
    sleep 1  # Workaround for potential race condition with ninja
    rm -f "${_where}"/*.mymesa* 2>/dev/null || true
    rm -f "${_where}/frogminer" 2>/dev/null || true

    msg2 "Cleanup done"
}
