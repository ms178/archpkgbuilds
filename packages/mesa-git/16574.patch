From 7f883628192156a3a59ae701b211810ec0d21d56 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Wed, 18 May 2022 11:09:53 +0900
Subject: [PATCH 1/2] radv: Hoist extent calculations in copy_image.

---
 src/amd/vulkan/radv_meta_copy.c | 60 ++++++++++++++++-----------------
 1 file changed, 30 insertions(+), 30 deletions(-)

diff --git a/src/amd/vulkan/radv_meta_copy.c b/src/amd/vulkan/radv_meta_copy.c
index a22a4664ca11..723a9dcef0c4 100644
--- a/src/amd/vulkan/radv_meta_copy.c
+++ b/src/amd/vulkan/radv_meta_copy.c
@@ -422,6 +422,36 @@ copy_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
     */
    assert(src_image->info.samples == dst_image->info.samples);
 
+   /**
+    * From the Vulkan 1.0.6 spec: 18.4 Copying Data Between Buffers and Images
+    *    imageExtent is the size in texels of the image to copy in width, height
+    *    and depth. 1D images use only x and width. 2D images use x, y, width
+    *    and height. 3D images use x, y, z, width, height and depth.
+    *
+    * Also, convert the offsets and extent from units of texels to units of
+    * blocks - which is the highest resolution accessible in this command.
+    */
+   const VkOffset3D dst_offset_el = meta_region_offset_el(dst_image, &region->dstOffset);
+   const VkOffset3D src_offset_el = meta_region_offset_el(src_image, &region->srcOffset);
+
+   /*
+    * From Vulkan 1.0.68, "Copying Data Between Images":
+    *    "When copying between compressed and uncompressed formats
+    *     the extent members represent the texel dimensions of the
+    *     source image and not the destination."
+    * However, we must use the destination image type to avoid
+    * clamping depth when copying multiple layers of a 2D image to
+    * a 3D image.
+    */
+   const VkExtent3D img_extent_el =
+      meta_region_extent_el(src_image, dst_image->vk.image_type, &region->extent);
+
+   /* Start creating blit rect */
+   struct radv_meta_blit2d_rect rect = {
+      .width = img_extent_el.width,
+      .height = img_extent_el.height,
+   };
+
    cs = cmd_buffer->qf == RADV_QUEUE_COMPUTE ||
         !radv_image_is_renderable(cmd_buffer->device, dst_image);
 
@@ -521,36 +551,6 @@ copy_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
          b_dst.disable_compression = true;
       }
 
-      /**
-       * From the Vulkan 1.0.6 spec: 18.4 Copying Data Between Buffers and Images
-       *    imageExtent is the size in texels of the image to copy in width, height
-       *    and depth. 1D images use only x and width. 2D images use x, y, width
-       *    and height. 3D images use x, y, z, width, height and depth.
-       *
-       * Also, convert the offsets and extent from units of texels to units of
-       * blocks - which is the highest resolution accessible in this command.
-       */
-      const VkOffset3D dst_offset_el = meta_region_offset_el(dst_image, &region->dstOffset);
-      const VkOffset3D src_offset_el = meta_region_offset_el(src_image, &region->srcOffset);
-
-      /*
-       * From Vulkan 1.0.68, "Copying Data Between Images":
-       *    "When copying between compressed and uncompressed formats
-       *     the extent members represent the texel dimensions of the
-       *     source image and not the destination."
-       * However, we must use the destination image type to avoid
-       * clamping depth when copying multiple layers of a 2D image to
-       * a 3D image.
-       */
-      const VkExtent3D img_extent_el =
-         meta_region_extent_el(src_image, dst_image->vk.image_type, &region->extent);
-
-      /* Start creating blit rect */
-      struct radv_meta_blit2d_rect rect = {
-         .width = img_extent_el.width,
-         .height = img_extent_el.height,
-      };
-
       if (src_image->vk.image_type == VK_IMAGE_TYPE_3D)
          b_src.layer = src_offset_el.z;
 
-- 
GitLab


From 9f0b61a85ef862420ad0f40f98c3a1907b6395de Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Wed, 18 May 2022 11:11:16 +0900
Subject: [PATCH 2/2] radv: Use CS copies for small image sizes.

---
 src/amd/vulkan/radv_constants.h |  8 ++++++++
 src/amd/vulkan/radv_meta_copy.c | 31 ++++++++++++++++---------------
 2 files changed, 24 insertions(+), 15 deletions(-)

diff --git a/src/amd/vulkan/radv_constants.h b/src/amd/vulkan/radv_constants.h
index c40330f3bc33..d417e64187ba 100644
--- a/src/amd/vulkan/radv_constants.h
+++ b/src/amd/vulkan/radv_constants.h
@@ -66,6 +66,14 @@
 
 #define RADV_BUFFER_UPDATE_THRESHOLD 1024
 
+/*
+ * This is the point we switch from using CS to a blit render pipeline
+ * for copy-to-image operations.
+ * Smaller sizes should use CS because it has less setup cost and
+ * mitigates certain over-syncs in the driver.
+ */
+#define RADV_IMAGE_BLIT_THRESHOLD 65536
+
 /* descriptor index into scratch ring offsets */
 #define RING_SCRATCH             0
 #define RING_ESGS_VS             1
diff --git a/src/amd/vulkan/radv_meta_copy.c b/src/amd/vulkan/radv_meta_copy.c
index 723a9dcef0c4..b1a7b52bacdc 100644
--- a/src/amd/vulkan/radv_meta_copy.c
+++ b/src/amd/vulkan/radv_meta_copy.c
@@ -138,19 +138,6 @@ copy_buffer_to_image(struct radv_cmd_buffer *cmd_buffer, struct radv_buffer *buf
     */
    assert(image->info.samples == 1);
 
-   cs = cmd_buffer->qf == RADV_QUEUE_COMPUTE ||
-        !radv_image_is_renderable(cmd_buffer->device, image);
-
-   radv_meta_save(&saved_state, cmd_buffer,
-                  (cs ? RADV_META_SAVE_COMPUTE_PIPELINE : RADV_META_SAVE_GRAPHICS_PIPELINE) |
-                     RADV_META_SAVE_CONSTANTS | RADV_META_SAVE_DESCRIPTORS);
-
-   /* VK_EXT_conditional_rendering says that copy commands should not be
-    * affected by conditional rendering.
-    */
-   old_predicating = cmd_buffer->state.predicating;
-   cmd_buffer->state.predicating = false;
-
    /**
     * From the Vulkan 1.0.6 spec: 18.3 Copying Data Between Images
     *    extent is the size in texels of the source image to copy in width,
@@ -174,6 +161,19 @@ copy_buffer_to_image(struct radv_cmd_buffer *cmd_buffer, struct radv_buffer *buf
       .width = img_extent_el.width,
       .height = img_extent_el.height,
    };
+   const uint32_t pixels = rect.width * rect.height;
+   cs = cmd_buffer->qf == RADV_QUEUE_COMPUTE ||
+        !radv_image_is_renderable(cmd_buffer->device, image) || pixels < RADV_IMAGE_BLIT_THRESHOLD;
+
+   radv_meta_save(&saved_state, cmd_buffer,
+                  (cs ? RADV_META_SAVE_COMPUTE_PIPELINE : RADV_META_SAVE_GRAPHICS_PIPELINE) |
+                     RADV_META_SAVE_CONSTANTS | RADV_META_SAVE_DESCRIPTORS);
+
+   /* VK_EXT_conditional_rendering says that copy commands should not be
+    * affected by conditional rendering.
+    */
+   old_predicating = cmd_buffer->state.predicating;
+   cmd_buffer->state.predicating = false;
 
    /* Create blit surfaces */
    struct radv_meta_blit2d_surf img_bsurf = blit_surf_for_image_level_layer(
@@ -451,9 +451,10 @@ copy_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
       .width = img_extent_el.width,
       .height = img_extent_el.height,
    };
-
+   const uint32_t pixels = rect.width * rect.height;
    cs = cmd_buffer->qf == RADV_QUEUE_COMPUTE ||
-        !radv_image_is_renderable(cmd_buffer->device, dst_image);
+        !radv_image_is_renderable(cmd_buffer->device, dst_image) ||
+        pixels < RADV_IMAGE_BLIT_THRESHOLD;
 
    radv_meta_save(&saved_state, cmd_buffer,
                   (cs ? RADV_META_SAVE_COMPUTE_PIPELINE : RADV_META_SAVE_GRAPHICS_PIPELINE) |
-- 
GitLab

