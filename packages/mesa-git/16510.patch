From fdab5adb0bfe5984dbfd54e75d01ccd3d262732f Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Sun, 8 May 2022 14:24:41 -0400
Subject: [PATCH 1/3] radv: refactor image binding into struct

---
 src/amd/vulkan/radv_cmd_buffer.c      | 13 +++++-----
 src/amd/vulkan/radv_descriptor_set.c  |  4 +--
 src/amd/vulkan/radv_device.c          | 31 ++++++++++++----------
 src/amd/vulkan/radv_image.c           | 32 ++++++++++++-----------
 src/amd/vulkan/radv_meta_bufimage.c   |  4 +--
 src/amd/vulkan/radv_meta_clear.c      | 37 +++++++++++++++------------
 src/amd/vulkan/radv_meta_copy.c       |  2 +-
 src/amd/vulkan/radv_meta_dcc_retile.c |  2 +-
 src/amd/vulkan/radv_meta_fast_clear.c |  2 +-
 src/amd/vulkan/radv_meta_fmask_copy.c |  7 ++---
 src/amd/vulkan/radv_private.h         | 30 ++++++++++++----------
 src/amd/vulkan/radv_sdma_copy_image.c |  2 +-
 12 files changed, 90 insertions(+), 76 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index b95ebb432045..3ba47bb687f0 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2525,7 +2525,7 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       VkImageLayout layout = subpass->color_attachments[i].layout;
       bool in_render_loop = subpass->color_attachments[i].in_render_loop;
 
-      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, iview->image->bo);
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
 
       assert(iview->vk.aspects & (VK_IMAGE_ASPECT_COLOR_BIT | VK_IMAGE_ASPECT_PLANE_0_BIT |
                                   VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT));
@@ -2554,7 +2554,7 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       bool in_render_loop = subpass->depth_stencil_attachment->in_render_loop;
       struct radv_image_view *iview = cmd_buffer->state.attachments[idx].iview;
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
-                         cmd_buffer->state.attachments[idx].iview->image->bo);
+                         cmd_buffer->state.attachments[idx].iview->image->bindings[0].bo);
 
       radv_emit_fb_ds_state(cmd_buffer, &cmd_buffer->state.attachments[idx].ds, iview, layout,
                             in_render_loop);
@@ -5952,12 +5952,12 @@ radv_cmd_buffer_begin_subpass(struct radv_cmd_buffer *cmd_buffer, uint32_t subpa
          };
 
          /* HTILE buffer */
-         uint64_t htile_offset = ds_image->offset + ds_image->planes[0].surface.meta_offset +
+         uint64_t htile_offset = ds_image->bindings[0].offset + ds_image->planes[0].surface.meta_offset +
                                  ds_image->planes[0].surface.u.gfx9.meta_levels[level].offset;
          uint64_t htile_size = ds_image->planes[0].surface.u.gfx9.meta_levels[level].size;
          struct radv_buffer htile_buffer;
 
-         radv_buffer_init(&htile_buffer, cmd_buffer->device, ds_image->bo, htile_size, htile_offset);
+         radv_buffer_init(&htile_buffer, cmd_buffer->device, ds_image->bindings[0].bo, htile_size, htile_offset);
 
          /* Copy the VRS rates to the HTILE buffer. */
          radv_copy_vrs_htile(cmd_buffer, vrs_iview->image, &extent, ds_image, &htile_buffer, true);
@@ -8230,8 +8230,9 @@ radv_init_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
 
       /* Initialize the mipmap levels without DCC. */
       if (size != image->planes[0].surface.meta_size) {
-         flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bo,
-                                        radv_buffer_get_va(image->bo) + image->offset +
+         flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                        radv_buffer_get_va(image->bindings[0].bo) +
+                                           image->bindings[0].offset +
                                            image->planes[0].surface.meta_offset + size,
                                         image->planes[0].surface.meta_size - size, 0xffffffff);
       }
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 56e226883e0b..8751a4207427 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -1172,9 +1172,9 @@ write_image_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_b
    memcpy(dst, descriptor, size);
 
    if (cmd_buffer)
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bo);
+      radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
    else
-      *buffer_list = iview->image->bo;
+      *buffer_list = iview->image->bindings[0].bo;
 }
 
 static ALWAYS_INLINE void
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 0651bd16b1dd..97491c2c47de 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -4368,7 +4368,7 @@ radv_sparse_image_opaque_bind_memory(struct radv_device *device,
       if (bind->pBinds[i].memory != VK_NULL_HANDLE)
          mem = radv_device_memory_from_handle(bind->pBinds[i].memory);
 
-      result = device->ws->buffer_virtual_bind(device->ws, image->bo,
+      result = device->ws->buffer_virtual_bind(device->ws, image->bindings[0].bo,
                                                bind->pBinds[i].resourceOffset, bind->pBinds[i].size,
                                                mem ? mem->bo : NULL, bind->pBinds[i].memoryOffset);
       if (result != VK_SUCCESS)
@@ -4425,7 +4425,7 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
          uint32_t aligned_extent_height = ALIGN(bind_extent.height, surface->prt_tile_height);
 
          uint32_t size = aligned_extent_width * aligned_extent_height * bs;
-         result = device->ws->buffer_virtual_bind(device->ws, image->bo, offset, size,
+         result = device->ws->buffer_virtual_bind(device->ws, image->bindings[0].bo, offset, size,
                                                   mem ? mem->bo : NULL, mem_offset);
          if (result != VK_SUCCESS)
             return result;
@@ -4434,8 +4434,8 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
          uint32_t mem_increment = aligned_extent_width * bs;
          uint32_t size = mem_increment * surface->prt_tile_height;
          for (unsigned y = 0; y < bind_extent.height; y += surface->prt_tile_height) {
-            result = device->ws->buffer_virtual_bind(
-               device->ws, image->bo, offset + img_increment * y, size, mem ? mem->bo : NULL,
+            result = device->ws->buffer_virtual_bind(device->ws,
+               image->bindings[0].bo, offset + img_increment * y, size, mem ? mem->bo : NULL,
                mem_offset + mem_increment * y);
             if (result != VK_SUCCESS)
                return result;
@@ -4761,7 +4761,7 @@ bool
 radv_get_memory_fd(struct radv_device *device, struct radv_device_memory *memory, int *pFD)
 {
    /* Only set BO metadata for the first plane */
-   if (memory->image && memory->image->offset == 0) {
+   if (memory->image && memory->image->bindings[0].offset == 0) {
       struct radeon_bo_metadata metadata;
       radv_init_metadata(device, memory->image, &metadata);
       device->ws->buffer_set_metadata(device->ws, memory->bo, &metadata);
@@ -5260,8 +5260,8 @@ radv_BindImageMemory2(VkDevice _device, uint32_t bindInfoCount,
          }
       }
 
-      image->bo = mem->bo;
-      image->offset = pBindInfos[i].memoryOffset;
+      image->bindings[0].bo = mem->bo;
+      image->bindings[0].offset = pBindInfos[i].memoryOffset;
    }
    return VK_SUCCESS;
 }
@@ -5594,7 +5594,7 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    else
       cb->cb_color_attrib = S_028C74_FORCE_DST_ALPHA_1_GFX6(desc->swizzle[3] == PIPE_SWIZZLE_1);
 
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
 
    cb->cb_color_base = va >> 8;
 
@@ -5656,11 +5656,11 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    }
 
    /* CMASK variables */
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
    va += surf->cmask_offset;
    cb->cb_color_cmask = va >> 8;
 
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
    va += surf->meta_offset;
 
    if (radv_dcc_enabled(iview->image, iview->vk.base_mip_level) &&
@@ -5689,7 +5689,8 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    }
 
    if (radv_image_has_fmask(iview->image)) {
-      va = radv_buffer_get_va(iview->image->bo) + iview->image->offset + surf->fmask_offset;
+      va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset +
+         surf->fmask_offset;
       cb->cb_color_fmask = va >> 8;
       cb->cb_color_fmask |= surf->fmask_tile_swizzle;
    } else {
@@ -5921,7 +5922,7 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
    ds->db_htile_data_base = 0;
    ds->db_htile_surface = 0;
 
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
    s_offs = z_offs = va;
 
    if (device->physical_device->rad_info.gfx_level >= GFX9) {
@@ -5972,7 +5973,8 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
             ds->db_stencil_info |= S_02803C_TILE_STENCIL_DISABLE(1);
          }
 
-         va = radv_buffer_get_va(iview->image->bo) + iview->image->offset + surf->meta_offset;
+         va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset + 
+            surf->meta_offset;
          ds->db_htile_data_base = va >> 8;
          ds->db_htile_surface = S_028ABC_FULL_CACHE(1) | S_028ABC_PIPE_ALIGNED(1);
 
@@ -6041,7 +6043,8 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
             ds->db_stencil_info |= S_028044_TILE_STENCIL_DISABLE(1);
          }
 
-         va = radv_buffer_get_va(iview->image->bo) + iview->image->offset + surf->meta_offset;
+         va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset +
+            surf->meta_offset;
          ds->db_htile_data_base = va >> 8;
          ds->db_htile_surface = S_028ABC_FULL_CACHE(1);
 
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 902a0f5469cd..accdc966e067 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -769,7 +769,8 @@ si_set_mutable_tex_desc_fields(struct radv_device *device, struct radv_image *im
                                bool enable_write_compression, uint32_t *state)
 {
    struct radv_image_plane *plane = &image->planes[plane_id];
-   uint64_t gpu_address = image->bo ? radv_buffer_get_va(image->bo) + image->offset : 0;
+   struct radv_image_binding *binding = &image->bindings[0];
+   uint64_t gpu_address = binding->bo ? radv_buffer_get_va(binding->bo) + binding->offset : 0;
    uint64_t va = gpu_address;
    enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
    uint64_t meta_va = 0;
@@ -1054,13 +1055,13 @@ gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *ima
    /* Initialize the sampler view for FMASK. */
    if (fmask_state) {
       if (radv_image_has_fmask(image)) {
-         uint64_t gpu_address = radv_buffer_get_va(image->bo);
+         uint64_t gpu_address = radv_buffer_get_va(image->bindings[0].bo);
          uint32_t format;
          uint64_t va;
 
          assert(image->plane_count == 1);
 
-         va = gpu_address + image->offset + image->planes[0].surface.fmask_offset;
+         va = gpu_address + image->bindings[0].offset + image->planes[0].surface.fmask_offset;
 
          switch (image->info.samples) {
          case 2:
@@ -1093,7 +1094,7 @@ gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *ima
          fmask_state[7] = 0;
 
          if (radv_image_is_tc_compat_cmask(image)) {
-            va = gpu_address + image->offset + image->planes[0].surface.cmask_offset;
+            va = gpu_address + image->bindings[0].offset + image->planes[0].surface.cmask_offset;
 
             fmask_state[6] |= S_00A018_COMPRESSION_EN(1);
             fmask_state[6] |= S_00A018_META_DATA_ADDRESS_LO(va >> 8);
@@ -1233,12 +1234,12 @@ si_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
    if (fmask_state) {
       if (radv_image_has_fmask(image)) {
          uint32_t fmask_format;
-         uint64_t gpu_address = radv_buffer_get_va(image->bo);
+         uint64_t gpu_address = radv_buffer_get_va(image->bindings[0].bo);
          uint64_t va;
 
          assert(image->plane_count == 1);
 
-         va = gpu_address + image->offset + image->planes[0].surface.fmask_offset;
+         va = gpu_address + image->bindings[0].offset + image->planes[0].surface.fmask_offset;
 
          if (device->physical_device->rad_info.gfx_level == GFX9) {
             fmask_format = V_008F14_IMG_DATA_FORMAT_FMASK;
@@ -1295,7 +1296,7 @@ si_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
             fmask_state[5] |= S_008F24_META_PIPE_ALIGNED(1) | S_008F24_META_RB_ALIGNED(1);
 
             if (radv_image_is_tc_compat_cmask(image)) {
-               va = gpu_address + image->offset + image->planes[0].surface.cmask_offset;
+               va = gpu_address + image->bindings[0].offset + image->planes[0].surface.cmask_offset;
 
                fmask_state[5] |= S_008F24_META_DATA_ADDRESS(va >> 40);
                fmask_state[6] |= S_008F28_COMPRESSION_EN(1);
@@ -1310,7 +1311,7 @@ si_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
             fmask_state[5] |= S_008F24_LAST_ARRAY(last_layer);
 
             if (radv_image_is_tc_compat_cmask(image)) {
-               va = gpu_address + image->offset + image->planes[0].surface.cmask_offset;
+               va = gpu_address + image->bindings[0].offset + image->planes[0].surface.cmask_offset;
 
                fmask_state[6] |= S_008F28_COMPRESSION_EN(1);
                fmask_state[7] |= va >> 8;
@@ -1372,7 +1373,7 @@ radv_init_metadata(struct radv_device *device, struct radv_image *image,
 
    if (device->physical_device->rad_info.gfx_level >= GFX9) {
       uint64_t dcc_offset =
-         image->offset +
+         image->bindings[0].offset +
          (surface->display_dcc_offset ? surface->display_dcc_offset : surface->meta_offset);
       metadata->u.gfx9.swizzle_mode = surface->u.gfx9.swizzle_mode;
       metadata->u.gfx9.dcc_offset_256b = dcc_offset >> 8;
@@ -1735,8 +1736,8 @@ static void
 radv_destroy_image(struct radv_device *device, const VkAllocationCallbacks *pAllocator,
                    struct radv_image *image)
 {
-   if ((image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) && image->bo)
-      device->ws->buffer_destroy(device->ws, image->bo);
+   if ((image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) && image->bindings[0].bo)
+      device->ws->buffer_destroy(device->ws, image->bindings[0].bo);
 
    if (image->owned_memory != VK_NULL_HANDLE) {
       RADV_FROM_HANDLE(radv_device_memory, mem, image->owned_memory);
@@ -1754,8 +1755,8 @@ radv_image_print_info(struct radv_device *device, struct radv_image *image)
    fprintf(stderr,
            "  Info: size=%" PRIu64 ", alignment=%" PRIu32 ", "
            "width=%" PRIu32 ", height=%" PRIu32 ", "
-           "offset=%" PRIu64 ", array_size=%" PRIu32 ", levels=%" PRIu32 "\n",
-           image->size, image->alignment, image->info.width, image->info.height, image->offset,
+           "array_size=%" PRIu32 ", levels=%" PRIu32 "\n",
+           image->size, image->alignment, image->info.width, image->info.height,
            image->info.array_size, image->info.levels);
    for (unsigned i = 0; i < image->plane_count; ++i) {
       const struct radv_image_plane *plane = &image->planes[i];
@@ -1904,11 +1905,12 @@ radv_image_create(VkDevice _device, const struct radv_image_create_info *create_
    if (image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) {
       image->alignment = MAX2(image->alignment, 4096);
       image->size = align64(image->size, image->alignment);
-      image->offset = 0;
+      image->bindings[0].offset = 0;
 
       result =
          device->ws->buffer_create(device->ws, image->size, image->alignment, 0,
-                                   RADEON_FLAG_VIRTUAL, RADV_BO_PRIORITY_VIRTUAL, 0, &image->bo);
+                                   RADEON_FLAG_VIRTUAL, RADV_BO_PRIORITY_VIRTUAL, 0,
+                                   &image->bindings[0].bo);
       if (result != VK_SUCCESS) {
          radv_destroy_image(device, alloc, image);
          return vk_error(device, result);
diff --git a/src/amd/vulkan/radv_meta_bufimage.c b/src/amd/vulkan/radv_meta_bufimage.c
index 444a02280fee..93e360a6ac1e 100644
--- a/src/amd/vulkan/radv_meta_bufimage.c
+++ b/src/amd/vulkan/radv_meta_bufimage.c
@@ -1264,7 +1264,7 @@ create_buffer_from_image(struct radv_cmd_buffer *cmd_buffer, struct radv_meta_bl
    struct radv_device *device = cmd_buffer->device;
    struct radv_device_memory mem;
 
-   radv_device_memory_init(&mem, device, surf->image->bo);
+   radv_device_memory_init(&mem, device, surf->image->bindings[0].bo);
 
    radv_CreateBuffer(radv_device_to_handle(device),
                      &(VkBufferCreateInfo){
@@ -1281,7 +1281,7 @@ create_buffer_from_image(struct radv_cmd_buffer *cmd_buffer, struct radv_meta_bl
                              .sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
                              .buffer = *buffer,
                              .memory = radv_device_memory_to_handle(&mem),
-                             .memoryOffset = surf->image->offset,
+                             .memoryOffset = surf->image->bindings[0].offset,
                           }});
 
    radv_device_memory_finish(&mem);
diff --git a/src/amd/vulkan/radv_meta_clear.c b/src/amd/vulkan/radv_meta_clear.c
index 3c374945d43e..3d701b11027b 100644
--- a/src/amd/vulkan/radv_meta_clear.c
+++ b/src/amd/vulkan/radv_meta_clear.c
@@ -1265,7 +1265,7 @@ uint32_t
 radv_clear_cmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
                  const VkImageSubresourceRange *range, uint32_t value)
 {
-   uint64_t offset = image->offset + image->planes[0].surface.cmask_offset;
+   uint64_t offset = image->bindings[0].offset + image->planes[0].surface.cmask_offset;
    uint64_t size;
 
    if (cmd_buffer->device->physical_device->rad_info.gfx_level == GFX9) {
@@ -1278,15 +1278,15 @@ radv_clear_cmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
       size = slice_size * radv_get_layerCount(image, range);
    }
 
-   return radv_fill_buffer(cmd_buffer, image, image->bo, radv_buffer_get_va(image->bo) + offset,
-                           size, value);
+   return radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+         radv_buffer_get_va(image->bindings[0].bo) + offset, size, value);
 }
 
 uint32_t
 radv_clear_fmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
                  const VkImageSubresourceRange *range, uint32_t value)
 {
-   uint64_t offset = image->offset + image->planes[0].surface.fmask_offset;
+   uint64_t offset = image->bindings[0].offset + image->planes[0].surface.fmask_offset;
    unsigned slice_size = image->planes[0].surface.fmask_slice_size;
    uint64_t size;
 
@@ -1296,8 +1296,8 @@ radv_clear_fmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
    offset += slice_size * range->baseArrayLayer;
    size = slice_size * radv_get_layerCount(image, range);
 
-   return radv_fill_buffer(cmd_buffer, image, image->bo, radv_buffer_get_va(image->bo) + offset,
-                           size, value);
+   return radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+         radv_buffer_get_va(image->bindings[0].bo) + offset, size, value);
 }
 
 uint32_t
@@ -1312,7 +1312,7 @@ radv_clear_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
    radv_update_dcc_metadata(cmd_buffer, image, range, true);
 
    for (uint32_t l = 0; l < level_count; l++) {
-      uint64_t offset = image->offset + image->planes[0].surface.meta_offset;
+      uint64_t offset = image->bindings[0].offset + image->planes[0].surface.meta_offset;
       uint32_t level = range->baseMipLevel + l;
       uint64_t size;
 
@@ -1344,8 +1344,9 @@ radv_clear_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
       if (!size)
          continue;
 
-      flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bo,
-                                     radv_buffer_get_va(image->bo) + offset, size, value);
+      flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                     radv_buffer_get_va(image->bindings[0].bo) + offset,
+                                     size, value);
    }
 
    return flush_bits;
@@ -1480,7 +1481,7 @@ radv_clear_htile(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
       /* Clear individuals levels separately. */
       for (uint32_t l = 0; l < level_count; l++) {
          uint32_t level = range->baseMipLevel + l;
-         uint64_t offset = image->offset + image->planes[0].surface.meta_offset +
+         uint64_t offset = image->bindings[0].offset + image->planes[0].surface.meta_offset +
                            image->planes[0].surface.u.gfx9.meta_levels[level].offset;
          uint32_t size = image->planes[0].surface.u.gfx9.meta_levels[level].size;
 
@@ -1490,28 +1491,30 @@ radv_clear_htile(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
 
          if (htile_mask == UINT_MAX) {
             /* Clear the whole HTILE buffer. */
-            flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bo,
-                                           radv_buffer_get_va(image->bo) + offset, size, value);
+            flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                           radv_buffer_get_va(image->bindings[0].bo) + offset,
+                                           size, value);
          } else {
             /* Only clear depth or stencil bytes in the HTILE buffer. */
             flush_bits |=
-               clear_htile_mask(cmd_buffer, image, image->bo, offset, size, value, htile_mask);
+               clear_htile_mask(cmd_buffer, image, image->bindings[0].bo, offset, size, value, htile_mask);
          }
       }
    } else {
       unsigned layer_count = radv_get_layerCount(image, range);
       uint64_t size = image->planes[0].surface.meta_slice_size * layer_count;
-      uint64_t offset = image->offset + image->planes[0].surface.meta_offset +
+      uint64_t offset = image->bindings[0].offset + image->planes[0].surface.meta_offset +
                         image->planes[0].surface.meta_slice_size * range->baseArrayLayer;
 
       if (htile_mask == UINT_MAX) {
          /* Clear the whole HTILE buffer. */
-         flush_bits = radv_fill_buffer(cmd_buffer, image, image->bo,
-                                       radv_buffer_get_va(image->bo) + offset, size, value);
+         flush_bits = radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                       radv_buffer_get_va(image->bindings[0].bo) + offset,
+                                       size, value);
       } else {
          /* Only clear depth or stencil bytes in the HTILE buffer. */
          flush_bits =
-            clear_htile_mask(cmd_buffer, image, image->bo, offset, size, value, htile_mask);
+            clear_htile_mask(cmd_buffer, image, image->bindings[0].bo, offset, size, value, htile_mask);
       }
    }
 
diff --git a/src/amd/vulkan/radv_meta_copy.c b/src/amd/vulkan/radv_meta_copy.c
index a22a4664ca11..593efd0fab2d 100644
--- a/src/amd/vulkan/radv_meta_copy.c
+++ b/src/amd/vulkan/radv_meta_copy.c
@@ -288,7 +288,7 @@ copy_image_to_buffer(struct radv_cmd_buffer *cmd_buffer, struct radv_buffer *buf
       assert(image->info.height == region->imageExtent.height);
       ASSERTED bool res = radv_sdma_copy_image(cmd_buffer, image, buffer, region);
       assert(res);
-      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, image->bo);
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, image->bindings[0].bo);
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, buffer->bo);
       return;
    }
diff --git a/src/amd/vulkan/radv_meta_dcc_retile.c b/src/amd/vulkan/radv_meta_dcc_retile.c
index b77063b482d9..df623283a890 100644
--- a/src/amd/vulkan/radv_meta_dcc_retile.c
+++ b/src/amd/vulkan/radv_meta_dcc_retile.c
@@ -213,7 +213,7 @@ radv_retile_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image)
    radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_COMPUTE,
                         device->meta_state.dcc_retile.pipeline[swizzle_mode]);
 
-   radv_buffer_init(&buffer, device, image->bo, image->size, image->offset);
+   radv_buffer_init(&buffer, device, image->bindings[0].bo, image->size, image->bindings[0].offset);
 
    struct radv_buffer_view views[2];
    VkBufferView view_handles[2];
diff --git a/src/amd/vulkan/radv_meta_fast_clear.c b/src/amd/vulkan/radv_meta_fast_clear.c
index c213ea43aa22..d5ced737f3b2 100644
--- a/src/amd/vulkan/radv_meta_fast_clear.c
+++ b/src/amd/vulkan/radv_meta_fast_clear.c
@@ -472,7 +472,7 @@ radv_emit_set_predication_state_from_image(struct radv_cmd_buffer *cmd_buffer,
    uint64_t va = 0;
 
    if (value) {
-      va = radv_buffer_get_va(image->bo) + image->offset;
+      va = radv_buffer_get_va(image->bindings[0].bo) + image->bindings[0].offset;
       va += pred_offset;
    }
 
diff --git a/src/amd/vulkan/radv_meta_fmask_copy.c b/src/amd/vulkan/radv_meta_fmask_copy.c
index 389aa96bd6fb..d90110e0a313 100644
--- a/src/amd/vulkan/radv_meta_fmask_copy.c
+++ b/src/amd/vulkan/radv_meta_fmask_copy.c
@@ -239,10 +239,11 @@ radv_fixup_copy_dst_metadata(struct radv_cmd_buffer *cmd_buffer, const struct ra
 
    /* Copy CMASK+FMASK. */
    size = src_image->planes[0].surface.cmask_size + src_image->planes[0].surface.fmask_size;
-   src_offset = src_image->offset + src_image->planes[0].surface.fmask_offset;
-   dst_offset = dst_image->offset + dst_image->planes[0].surface.fmask_offset;
+   src_offset = src_image->bindings[0].offset + src_image->planes[0].surface.fmask_offset;
+   dst_offset = dst_image->bindings[0].offset + dst_image->planes[0].surface.fmask_offset;
 
-   radv_copy_buffer(cmd_buffer, src_image->bo, dst_image->bo, src_offset, dst_offset, size);
+   radv_copy_buffer(cmd_buffer, src_image->bindings[0].bo, dst_image->bindings[0].bo,
+                    src_offset, dst_offset, size);
 }
 
 bool
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index c64d25574ac4..ec5ab5893a2f 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2112,6 +2112,12 @@ struct radv_image_plane {
    struct radeon_surf surface;
 };
 
+struct radv_image_binding {
+   /* Set when bound */
+   struct radeon_winsys_bo *bo;
+   VkDeviceSize offset;
+};
+
 struct radv_image {
    struct vk_image vk;
 
@@ -2127,9 +2133,7 @@ struct radv_image {
    bool dcc_sign_reinterpret;
    bool support_comp_to_single;
 
-   /* Set when bound */
-   struct radeon_winsys_bo *bo;
-   VkDeviceSize offset;
+   struct radv_image_binding bindings[3];
    bool tc_compatible_cmask;
 
    uint64_t clear_value_offset;
@@ -2295,8 +2299,8 @@ radv_image_get_fast_clear_va(const struct radv_image *image, uint32_t base_level
 {
    assert(radv_image_has_clear_value(image));
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->clear_value_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->clear_value_offset + base_level * 8;
    return va;
 }
 
@@ -2305,8 +2309,8 @@ radv_image_get_fce_pred_va(const struct radv_image *image, uint32_t base_level)
 {
    assert(image->fce_pred_offset != 0);
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->fce_pred_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->fce_pred_offset + base_level * 8;
    return va;
 }
 
@@ -2315,8 +2319,8 @@ radv_image_get_dcc_pred_va(const struct radv_image *image, uint32_t base_level)
 {
    assert(image->dcc_pred_offset != 0);
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->dcc_pred_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->dcc_pred_offset + base_level * 8;
    return va;
 }
 
@@ -2325,8 +2329,8 @@ radv_get_tc_compat_zrange_va(const struct radv_image *image, uint32_t base_level
 {
    assert(image->tc_compat_zrange_offset != 0);
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->tc_compat_zrange_offset + base_level * 4;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->tc_compat_zrange_offset + base_level * 4;
    return va;
 }
 
@@ -2335,8 +2339,8 @@ radv_get_ds_clear_value_va(const struct radv_image *image, uint32_t base_level)
 {
    assert(radv_image_has_clear_value(image));
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->clear_value_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->clear_value_offset + base_level * 8;
    return va;
 }
 
diff --git a/src/amd/vulkan/radv_sdma_copy_image.c b/src/amd/vulkan/radv_sdma_copy_image.c
index 3bb2d0779088..93044c6e6754 100644
--- a/src/amd/vulkan/radv_sdma_copy_image.c
+++ b/src/amd/vulkan/radv_sdma_copy_image.c
@@ -76,7 +76,7 @@ radv_sdma_v4_v5_copy_image_to_buffer(struct radv_cmd_buffer *cmd_buffer, struct
    struct radv_device *device = cmd_buffer->device;
    unsigned bpp = image->planes[0].surface.bpe;
    uint64_t dst_address = buffer->bo->va;
-   uint64_t src_address = image->bo->va + image->planes[0].surface.u.gfx9.surf_offset;
+   uint64_t src_address = image->bindings[0].bo->va + image->planes[0].surface.u.gfx9.surf_offset;
    unsigned src_pitch = image->planes[0].surface.u.gfx9.surf_pitch;
    unsigned copy_width = DIV_ROUND_UP(image->info.width, image->planes[0].surface.blk_w);
    unsigned copy_height = DIV_ROUND_UP(image->info.height, image->planes[0].surface.blk_h);
-- 
GitLab


From b2fcdd2e271bd44fcaba94feebb6a9c898e62d40 Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Fri, 6 May 2022 15:54:18 -0400
Subject: [PATCH 2/3] radv: implement disjoint memory for multiplane images

For descriptor binding, we need to allow up to three buffers to be
referenced by any image.
---
 src/amd/vulkan/radv_cmd_buffer.c     | 14 ++++++++++++-
 src/amd/vulkan/radv_descriptor_set.c | 26 ++++++++++++++++--------
 src/amd/vulkan/radv_device.c         | 30 +++++++++++++++++++++++++---
 src/amd/vulkan/radv_image.c          |  6 ++++--
 src/amd/vulkan/radv_private.h        |  1 +
 5 files changed, 63 insertions(+), 14 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 3ba47bb687f0..d6ae087ffba4 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2528,7 +2528,19 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
 
       assert(iview->vk.aspects & (VK_IMAGE_ASPECT_COLOR_BIT | VK_IMAGE_ASPECT_PLANE_0_BIT |
-                                  VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT));
+                                   VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT));
+
+      if (iview->image->disjoint && iview->vk.aspects == VK_IMAGE_ASPECT_COLOR_BIT) {
+         for (uint32_t plane_id = 0; plane_id < iview->image->plane_count; plane_id++) {
+            radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
+                  iview->image->bindings[plane_id].bo);
+         }
+      } else {
+         uint32_t plane_id = iview->image->disjoint ? iview->plane_id : 0;
+         radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
+               iview->image->bindings[plane_id].bo);
+      }
+
       radv_emit_fb_color_state(cmd_buffer, i, &cmd_buffer->state.attachments[idx].cb, iview, layout,
                                in_render_loop);
 
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 8751a4207427..9870e10ca47b 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -239,20 +239,20 @@ radv_CreateDescriptorSetLayout(VkDevice _device, const VkDescriptorSetLayoutCrea
          break;
       case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
          set_layout->binding[b].size = 32;
-         binding_buffer_count = 1;
+         binding_buffer_count = 3;
          alignment = 32;
          break;
       case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
       case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
          /* main descriptor + fmask descriptor */
          set_layout->binding[b].size = 64;
-         binding_buffer_count = 1;
+         binding_buffer_count = 3;
          alignment = 32;
          break;
       case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
          /* main descriptor + fmask descriptor + sampler */
          set_layout->binding[b].size = 96;
-         binding_buffer_count = 1;
+         binding_buffer_count = 3;
          alignment = 32;
          break;
       case VK_DESCRIPTOR_TYPE_SAMPLER:
@@ -821,7 +821,12 @@ radv_CreateDescriptorPool(VkDevice _device, const VkDescriptorPoolCreateInfo *pC
    }
 
    for (unsigned i = 0; i < pCreateInfo->poolSizeCount; ++i) {
-      if (pCreateInfo->pPoolSizes[i].type != VK_DESCRIPTOR_TYPE_SAMPLER)
+      if (pCreateInfo->pPoolSizes[i].type == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE ||
+            pCreateInfo->pPoolSizes[i].type == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE ||
+            pCreateInfo->pPoolSizes[i].type == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT ||
+            pCreateInfo->pPoolSizes[i].type == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER)
+         bo_count += 3 * pCreateInfo->pPoolSizes[i].descriptorCount;
+      else if (pCreateInfo->pPoolSizes[i].type != VK_DESCRIPTOR_TYPE_SAMPLER)
          bo_count += pCreateInfo->pPoolSizes[i].descriptorCount;
 
       switch (pCreateInfo->pPoolSizes[i].type) {
@@ -1171,10 +1176,15 @@ write_image_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_b
 
    memcpy(dst, descriptor, size);
 
-   if (cmd_buffer)
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
-   else
-      *buffer_list = iview->image->bindings[0].bo;
+   uint32_t binding_count = iview->image->disjoint ? iview->image->plane_count : 1;
+   for (uint32_t b = 0; b < binding_count; b++) {
+      if (cmd_buffer)
+         radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[b].bo);
+      else {
+         *buffer_list = iview->image->bindings[b].bo;
+         buffer_list++;
+      }
+   }
 }
 
 static ALWAYS_INLINE void
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 97491c2c47de..ca70c9e3adfb 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -5260,8 +5260,30 @@ radv_BindImageMemory2(VkDevice _device, uint32_t bindInfoCount,
          }
       }
 
-      image->bindings[0].bo = mem->bo;
-      image->bindings[0].offset = pBindInfos[i].memoryOffset;
+      if (image->disjoint) {
+         const VkBindImagePlaneMemoryInfo *plane_info =
+            vk_find_struct_const(pBindInfos[i].pNext, BIND_IMAGE_PLANE_MEMORY_INFO);
+
+         switch (plane_info->planeAspect) {
+            case VK_IMAGE_ASPECT_PLANE_0_BIT:
+               image->bindings[0].bo = mem->bo;
+               image->bindings[0].offset = pBindInfos[i].memoryOffset;
+               break;
+            case VK_IMAGE_ASPECT_PLANE_1_BIT:
+               image->bindings[1].bo = mem->bo;
+               image->bindings[1].offset = pBindInfos[i].memoryOffset;
+               break;
+            case VK_IMAGE_ASPECT_PLANE_2_BIT:
+               image->bindings[2].bo = mem->bo;
+               image->bindings[2].offset = pBindInfos[i].memoryOffset;
+               break;
+            default:
+               break;
+         }
+      } else {
+         image->bindings[0].bo = mem->bo;
+         image->bindings[0].offset = pBindInfos[i].memoryOffset;
+      }
    }
    return VK_SUCCESS;
 }
@@ -5594,7 +5616,9 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    else
       cb->cb_color_attrib = S_028C74_FORCE_DST_ALPHA_1_GFX6(desc->swizzle[3] == PIPE_SWIZZLE_1);
 
-   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
+   uint32_t plane_id = iview->image->disjoint ? iview->plane_id : 0;
+   va = radv_buffer_get_va(iview->image->bindings[plane_id].bo) +
+      iview->image->bindings[plane_id].offset;
 
    cb->cb_color_base = va >> 8;
 
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index accdc966e067..05bafff14705 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -769,7 +769,7 @@ si_set_mutable_tex_desc_fields(struct radv_device *device, struct radv_image *im
                                bool enable_write_compression, uint32_t *state)
 {
    struct radv_image_plane *plane = &image->planes[plane_id];
-   struct radv_image_binding *binding = &image->bindings[0];
+   struct radv_image_binding *binding = image->disjoint ? &image->bindings[plane_id] : &image->bindings[0];
    uint64_t gpu_address = binding->bo ? radv_buffer_get_va(binding->bo) + binding->offset : 0;
    uint64_t va = gpu_address;
    enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
@@ -1687,7 +1687,8 @@ radv_image_create_layout(struct radv_device *device, struct radv_image_create_in
          offset = mod_info->pPlaneLayouts[plane].offset;
          stride = mod_info->pPlaneLayouts[plane].rowPitch / image->planes[plane].surface.bpe;
       } else {
-         offset = align64(image->size, 1 << image->planes[plane].surface.alignment_log2);
+         offset = image->disjoint ? 0 :
+            align64(image->size, 1 << image->planes[plane].surface.alignment_log2);
          stride = 0; /* 0 means no override */
       }
 
@@ -1853,6 +1854,7 @@ radv_image_create(VkDevice _device, const struct radv_image_create_info *create_
    image->info.num_channels = vk_format_get_nr_components(format);
 
    image->plane_count = vk_format_get_plane_count(format);
+   image->disjoint = image->plane_count > 1 && pCreateInfo->flags & VK_IMAGE_CREATE_DISJOINT_BIT;
 
    image->exclusive = pCreateInfo->sharingMode == VK_SHARING_MODE_EXCLUSIVE;
    if (pCreateInfo->sharingMode == VK_SHARING_MODE_CONCURRENT) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index ec5ab5893a2f..07dab819506c 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2152,6 +2152,7 @@ struct radv_image {
    VkDeviceMemory owned_memory;
 
    unsigned plane_count;
+   bool disjoint;
    struct radv_image_plane planes[0];
 };
 
-- 
GitLab


From 5eabf40ceb913eea3ceb9ce9493a36e5840f0c40 Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Fri, 13 May 2022 21:24:12 -0400
Subject: [PATCH 3/3] radv: expose disjoint image support

---
 src/amd/vulkan/radv_formats.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index f9c5614ac3f7..e8c341bfc1ef 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -721,7 +721,8 @@ radv_physical_device_get_format_properties(struct radv_physical_device *physical
                         VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
                         VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT |
                         VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT |
-                        VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT;
+                        VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT |
+                        VK_FORMAT_FEATURE_2_DISJOINT_BIT;
 
       /* The subsampled formats have no support for linear filters. */
       if (desc->layout != UTIL_FORMAT_LAYOUT_SUBSAMPLED) {
-- 
GitLab

