From 2b566e46c56bced11f11442156ca89687322d003 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 24 Mar 2022 11:15:58 +0800
Subject: [PATCH 01/16] mesa/program: fix nir output reg overflow
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

outputs_written is uint64_t, should count max reg number
by util_last_bit64(). Otherwise the following access will
overflow the allocated array with a smaller size.

cc: mesa-stable

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/program/prog_to_nir.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/mesa/program/prog_to_nir.c b/src/mesa/program/prog_to_nir.c
index cf5c5b1be2ee..5cd073d565ea 100644
--- a/src/mesa/program/prog_to_nir.c
+++ b/src/mesa/program/prog_to_nir.c
@@ -916,7 +916,7 @@ setup_registers_and_variables(struct ptn_compile *c)
    }
 
    /* Create output registers and variables. */
-   int max_outputs = util_last_bit(c->prog->info.outputs_written);
+   int max_outputs = util_last_bit64(c->prog->info.outputs_written);
    c->output_regs = rzalloc_array(c, nir_register *, max_outputs);
 
    uint64_t outputs_written = c->prog->info.outputs_written;
-- 
GitLab


From 2ec7ab743e509bc52483fe973c6635851170afb4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 14 Mar 2022 15:11:34 +0800
Subject: [PATCH 02/16] mesa/vbo: remove unused vbo_context->binding
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/mtypes.h     | 1 -
 src/mesa/vbo/vbo_context.c | 6 ------
 2 files changed, 7 deletions(-)

diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index cd2af9f7225f..9d7aa49972c2 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3062,7 +3062,6 @@ struct gl_client_attrib_node
  * The VBO module implemented in src/vbo.
  */
 struct vbo_context {
-   struct gl_vertex_buffer_binding binding;
    struct gl_array_attributes current[VBO_ATTRIB_MAX];
 
    struct gl_vertex_array_object *VAO;
diff --git a/src/mesa/vbo/vbo_context.c b/src/mesa/vbo/vbo_context.c
index 89dc1486ee9c..0ac99b552e59 100644
--- a/src/mesa/vbo/vbo_context.c
+++ b/src/mesa/vbo/vbo_context.c
@@ -155,10 +155,6 @@ _vbo_CreateContext(struct gl_context *ctx)
 
    memset(vbo, 0, sizeof(*vbo));
 
-   vbo->binding.Offset = 0;
-   vbo->binding.Stride = 0;
-   vbo->binding.InstanceDivisor = 0;
-
    init_legacy_currval(ctx);
    init_generic_currval(ctx);
    init_mat_currval(ctx);
@@ -191,8 +187,6 @@ _vbo_DestroyContext(struct gl_context *ctx)
    struct vbo_context *vbo = vbo_context(ctx);
 
    if (vbo) {
-      _mesa_reference_buffer_object(ctx, &vbo->binding.BufferObj, NULL);
-
       vbo_exec_destroy(ctx);
       if (ctx->API == API_OPENGL_COMPAT)
          vbo_save_destroy(ctx);
-- 
GitLab


From 604f0956e0c0c96f3e66c07fb5dd000738534d98 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 19 Mar 2022 21:05:33 +0800
Subject: [PATCH 03/16] nir/builder: add load/store array variable helper
 functions
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/compiler/nir/nir_builder.h | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index 928d7797f3f0..af0660a7d881 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -1452,6 +1452,40 @@ nir_copy_var(nir_builder *build, nir_variable *dest, nir_variable *src)
                          nir_build_deref_var(build, src));
 }
 
+static inline nir_ssa_def *
+nir_load_array_var(nir_builder *build, nir_variable *var, nir_ssa_def *index)
+{
+   nir_deref_instr *deref =
+      nir_build_deref_array(build, nir_build_deref_var(build, var), index);
+   return nir_load_deref(build, deref);
+}
+
+static inline nir_ssa_def *
+nir_load_array_var_imm(nir_builder *build, nir_variable *var, int64_t index)
+{
+   nir_deref_instr *deref =
+      nir_build_deref_array_imm(build, nir_build_deref_var(build, var), index);
+   return nir_load_deref(build, deref);
+}
+
+static inline void
+nir_store_array_var(nir_builder *build, nir_variable *var, nir_ssa_def *index,
+                    nir_ssa_def *value, unsigned writemask)
+{
+   nir_deref_instr *deref =
+      nir_build_deref_array(build, nir_build_deref_var(build, var), index);
+   nir_store_deref(build, deref, value, writemask);
+}
+
+static inline void
+nir_store_array_var_imm(nir_builder *build, nir_variable *var, int64_t index,
+                        nir_ssa_def *value, unsigned writemask)
+{
+   nir_deref_instr *deref =
+      nir_build_deref_array_imm(build, nir_build_deref_var(build, var), index);
+   nir_store_deref(build, deref, value, writemask);
+}
+
 #undef nir_load_global
 static inline nir_ssa_def *
 nir_load_global(nir_builder *build, nir_ssa_def *addr, unsigned align,
-- 
GitLab


From 9dc36de9e5f21b567dd1d05ba3a903bcc38903d7 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 7 Mar 2022 15:37:03 +0800
Subject: [PATCH 04/16] mesa: add hardware accelerated select constant
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/consts_exts.h            | 3 +++
 src/mesa/state_tracker/st_extensions.c | 2 ++
 2 files changed, 5 insertions(+)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 8af55ad30857..be3f9b01f3f6 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -994,5 +994,8 @@ struct gl_constants
    GLuint MaxSparse3DTextureSize;
    GLuint MaxSparseArrayTextureLayers;
    bool SparseTextureFullArrayCubeMipmaps;
+
+   /** Use hardware accelerated GL_SELECT */
+   bool HardwareAcceleratedSelect;
 };
 #endif
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 8720ac6ca91b..2d307169259d 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -630,6 +630,8 @@ void st_init_limits(struct pipe_screen *screen,
       screen->get_param(screen, PIPE_CAP_MAX_SPARSE_ARRAY_TEXTURE_LAYERS);
    c->SparseTextureFullArrayCubeMipmaps =
       screen->get_param(screen, PIPE_CAP_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS);
+
+   c->HardwareAcceleratedSelect = false;
 }
 
 
-- 
GitLab


From 078a1b90d8f28090434bdc4f3a8feec56c5229fb Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 9 Mar 2022 11:34:57 +0800
Subject: [PATCH 05/16] mesa: add _mesa_bufferobj_get_subdata
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/bufferobj.c | 8 ++++++++
 src/mesa/main/bufferobj.h | 6 ++++++
 2 files changed, 14 insertions(+)

diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index b3b2dc6c77b0..67079f4fd866 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -145,6 +145,14 @@ bufferobj_get_subdata(struct gl_context *ctx,
                     offset, size, data);
 }
 
+void
+_mesa_bufferobj_get_subdata(struct gl_context *ctx,
+                            GLintptrARB offset,
+                            GLsizeiptrARB size,
+                            void *data, struct gl_buffer_object *obj)
+{
+   bufferobj_get_subdata(ctx, offset, size, data, obj);
+}
 
 /**
  * Return bitmask of PIPE_BIND_x flags corresponding a GL buffer target.
diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index aa02b6298a14..032a4cd376c5 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -79,6 +79,12 @@ GLboolean _mesa_bufferobj_data(struct gl_context *ctx,
                             GLenum usage,
                             GLbitfield storageFlags,
                             struct gl_buffer_object *obj);
+void
+_mesa_bufferobj_get_subdata(struct gl_context *ctx,
+                            GLintptrARB offset,
+                            GLsizeiptrARB size,
+                            void *data, struct gl_buffer_object *obj);
+
 void *_mesa_bufferobj_map_range(struct gl_context *ctx,
                                 GLintptr offset, GLsizeiptr length,
                                 GLbitfield access,
-- 
GitLab


From 55f95d958fc686eba2fcd1ea17644d1846537494 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 9 Mar 2022 14:33:22 +0800
Subject: [PATCH 06/16] mesa: refine name stack code to prepare for hw select
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

No functional change, just pack existing software based implementation into
the HardwareAcceleratedSelect switch, will add hardware implementation in
next commit.

ctx->Select.NameStackDepth is sure to be <=MAX_NAME_STACK_DEPTH, so removed
the overflow check in _mesa_LoadName.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Sgined-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/feedback.c | 158 +++++++++++++++++----------------------
 1 file changed, 70 insertions(+), 88 deletions(-)

diff --git a/src/mesa/main/feedback.c b/src/mesa/main/feedback.c
index 8daa85e4e4f5..27880188d5f6 100644
--- a/src/mesa/main/feedback.c
+++ b/src/mesa/main/feedback.c
@@ -221,68 +221,66 @@ _mesa_update_hitflag(struct gl_context *ctx, GLfloat z)
    }
 }
 
-
-/**
- * Write the hit record.
- *
- * \param ctx GL context.
- *
- * Write the hit record, i.e., the number of names in the stack, the minimum and
- * maximum depth values and the number of names in the name stack at the time
- * of the event. Resets the hit flag. 
- *
- * \sa gl_selection.
- */
 static void
-write_hit_record(struct gl_context *ctx)
+update_hit_record(struct gl_context *ctx)
 {
-   GLuint i;
-   GLuint zmin, zmax, zscale = (~0u);
+   struct gl_selection *s = &ctx->Select;
 
-   /* HitMinZ and HitMaxZ are in [0,1].  Multiply these values by */
-   /* 2^32-1 and round to nearest unsigned integer. */
+   if (ctx->Const.HardwareAcceleratedSelect) {
 
-   assert( ctx != NULL ); /* this line magically fixes a SunOS 5.x/gcc bug */
-   zmin = (GLuint) ((GLfloat) zscale * ctx->Select.HitMinZ);
-   zmax = (GLuint) ((GLfloat) zscale * ctx->Select.HitMaxZ);
+   } else {
+      if (!s->HitFlag)
+         return;
 
-   write_record( ctx, ctx->Select.NameStackDepth );
-   write_record( ctx, zmin );
-   write_record( ctx, zmax );
-   for (i = 0; i < ctx->Select.NameStackDepth; i++) {
-      write_record( ctx, ctx->Select.NameStack[i] );
-   }
+      /* HitMinZ and HitMaxZ are in [0,1].  Multiply these values by */
+      /* 2^32-1 and round to nearest unsigned integer. */
+      GLuint zscale = (~0u);
+      GLuint zmin = (GLuint) ((GLfloat) zscale * s->HitMinZ);
+      GLuint zmax = (GLuint) ((GLfloat) zscale * s->HitMaxZ);
 
-   ctx->Select.Hits++;
-   ctx->Select.HitFlag = GL_FALSE;
-   ctx->Select.HitMinZ = 1.0;
-   ctx->Select.HitMaxZ = -1.0;
+      write_record(ctx, s->NameStackDepth);
+      write_record(ctx, zmin);
+      write_record(ctx, zmax);
+      for (int i = 0; i < s->NameStackDepth; i++)
+         write_record(ctx, s->NameStack[i]);
+
+      s->HitFlag = GL_FALSE;
+      s->HitMinZ = 1.0;
+      s->HitMaxZ = -1.0;
+
+      s->Hits++;
+   }
 }
 
+static void
+reset_name_stack_to_empty(struct gl_context *ctx)
+{
+   struct gl_selection *s = &ctx->Select;
+
+   s->NameStackDepth = 0;
+   s->HitFlag = GL_FALSE;
+   s->HitMinZ = 1.0;
+   s->HitMaxZ = 0.0;
+}
 
 /**
  * Initialize the name stack.
- *
- * Verifies we are in select mode and resets the name stack depth and resets
- * the hit record data in gl_selection. Marks new render mode in
- * __struct gl_contextRec::NewState.
  */
 void GLAPIENTRY
 _mesa_InitNames( void )
 {
    GET_CURRENT_CONTEXT(ctx);
+
+   /* Calls to glInitNames while the render mode is not GL_SELECT are ignored. */
+   if (ctx->RenderMode != GL_SELECT)
+      return;
+
    FLUSH_VERTICES(ctx, 0, 0);
 
-   /* Record the hit before the HitFlag is wiped out again. */
-   if (ctx->RenderMode == GL_SELECT) {
-      if (ctx->Select.HitFlag) {
-         write_hit_record( ctx );
-      }
-   }
-   ctx->Select.NameStackDepth = 0;
-   ctx->Select.HitFlag = GL_FALSE;
-   ctx->Select.HitMinZ = 1.0;
-   ctx->Select.HitMaxZ = 0.0;
+   update_hit_record(ctx);
+
+   reset_name_stack_to_empty(ctx);
+
    ctx->NewState |= _NEW_RENDERMODE;
 }
 
@@ -291,12 +289,6 @@ _mesa_InitNames( void )
  * Load the top-most name of the name stack.
  *
  * \param name name.
- *
- * Verifies we are in selection mode and that the name stack is not empty.
- * Flushes vertices. If there is a hit flag writes it (via write_hit_record()),
- * and replace the top-most name in the stack.
- *
- * sa __struct gl_contextRec::Select.
  */
 void GLAPIENTRY
 _mesa_LoadName( GLuint name )
@@ -311,17 +303,13 @@ _mesa_LoadName( GLuint name )
       return;
    }
 
-   FLUSH_VERTICES(ctx, _NEW_RENDERMODE, 0);
-
-   if (ctx->Select.HitFlag) {
-      write_hit_record( ctx );
-   }
-   if (ctx->Select.NameStackDepth < MAX_NAME_STACK_DEPTH) {
-      ctx->Select.NameStack[ctx->Select.NameStackDepth-1] = name;
-   }
-   else {
-      ctx->Select.NameStack[MAX_NAME_STACK_DEPTH-1] = name;
+   if (!ctx->Const.HardwareAcceleratedSelect) {
+      FLUSH_VERTICES(ctx, 0, 0);
+      update_hit_record(ctx);
    }
+
+   ctx->Select.NameStack[ctx->Select.NameStackDepth-1] = name;
+   ctx->NewState |= _NEW_RENDERMODE;
 }
 
 
@@ -329,12 +317,6 @@ _mesa_LoadName( GLuint name )
  * Push a name into the name stack.
  *
  * \param name name.
- *
- * Verifies we are in selection mode and that the name stack is not full.
- * Flushes vertices. If there is a hit flag writes it (via write_hit_record()),
- * and adds the name to the top of the name stack.
- *
- * sa __struct gl_contextRec::Select.
  */
 void GLAPIENTRY
 _mesa_PushName( GLuint name )
@@ -345,26 +327,23 @@ _mesa_PushName( GLuint name )
       return;
    }
 
-   FLUSH_VERTICES(ctx, _NEW_RENDERMODE, 0);
-   if (ctx->Select.HitFlag) {
-      write_hit_record( ctx );
-   }
    if (ctx->Select.NameStackDepth >= MAX_NAME_STACK_DEPTH) {
       _mesa_error( ctx, GL_STACK_OVERFLOW, "glPushName" );
+      return;
+   }
+
+   if (!ctx->Const.HardwareAcceleratedSelect) {
+      FLUSH_VERTICES(ctx, 0, 0);
+      update_hit_record(ctx);
    }
-   else
-      ctx->Select.NameStack[ctx->Select.NameStackDepth++] = name;
+
+   ctx->Select.NameStack[ctx->Select.NameStackDepth++] = name;
+   ctx->NewState |= _NEW_RENDERMODE;
 }
 
 
 /**
  * Pop a name into the name stack.
- *
- * Verifies we are in selection mode and that the name stack is not empty.
- * Flushes vertices. If there is a hit flag writes it (via write_hit_record()),
- * and removes top-most name in the name stack.
- *
- * sa __struct gl_contextRec::Select.
  */
 void GLAPIENTRY
 _mesa_PopName( void )
@@ -375,15 +354,18 @@ _mesa_PopName( void )
       return;
    }
 
-   FLUSH_VERTICES(ctx, _NEW_RENDERMODE, 0);
-   if (ctx->Select.HitFlag) {
-      write_hit_record( ctx );
-   }
    if (ctx->Select.NameStackDepth == 0) {
       _mesa_error( ctx, GL_STACK_UNDERFLOW, "glPopName" );
+      return;
    }
-   else
-      ctx->Select.NameStackDepth--;
+
+   if (!ctx->Const.HardwareAcceleratedSelect) {
+      FLUSH_VERTICES(ctx, 0, 0);
+      update_hit_record(ctx);
+   }
+
+   ctx->Select.NameStackDepth--;
+   ctx->NewState |= _NEW_RENDERMODE;
 }
 
 /*@}*/
@@ -426,9 +408,8 @@ _mesa_RenderMode( GLenum mode )
 	 result = 0;
 	 break;
       case GL_SELECT:
-	 if (ctx->Select.HitFlag) {
-	    write_hit_record( ctx );
-	 }
+	 update_hit_record(ctx);
+
 	 if (ctx->Select.BufferCount > ctx->Select.BufferSize) {
 	    /* overflow */
 #ifndef NDEBUG
@@ -441,7 +422,8 @@ _mesa_RenderMode( GLenum mode )
 	 }
 	 ctx->Select.BufferCount = 0;
 	 ctx->Select.Hits = 0;
-	 ctx->Select.NameStackDepth = 0;
+	 /* name stack should be in empty state after exiting GL_SELECT mode */
+	 reset_name_stack_to_empty(ctx);
 	 break;
       case GL_FEEDBACK:
 	 if (ctx->Feedback.Count > ctx->Feedback.BufferSize) {
-- 
GitLab


From c4a7fb7679c03f8f0778d97b5c4fe9d526978ea9 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 9 Mar 2022 15:03:01 +0800
Subject: [PATCH 07/16] mesa: add hw select name stack code path
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

HW code path will not flush vertex whenever name stack change.
It will save the current name stack and write to select buffer
only when no space left or exit select mode.

This let us submit multi draws from different name stack at
once instead of submit draws for a single name stack then
wait it finish before submit next one.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/config.h      |   4 +
 src/mesa/main/context.c     |   1 +
 src/mesa/main/context.h     |   7 ++
 src/mesa/main/feedback.c    | 182 +++++++++++++++++++++++++++++++++++-
 src/mesa/main/feedback.h    |   3 +
 src/mesa/main/mtypes.h      |   9 ++
 src/mesa/vbo/vbo_exec_api.c |   7 +-
 7 files changed, 209 insertions(+), 4 deletions(-)

diff --git a/src/mesa/main/config.h b/src/mesa/main/config.h
index 3571a338d582..753d847efb1d 100644
--- a/src/mesa/main/config.h
+++ b/src/mesa/main/config.h
@@ -76,6 +76,10 @@
 
 /** Maximum Name stack depth */
 #define MAX_NAME_STACK_DEPTH 64
+/** Name stack buffer size */
+#define NAME_STACK_BUFFER_SIZE 2048
+/** Maximum name stack result number */
+#define MAX_NAME_STACK_RESULT_NUM 256
 
 /** Minimum point size */
 #define MIN_POINT_SIZE 1.0
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 8e623d68c309..1941aaa33d6a 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1140,6 +1140,7 @@ _mesa_free_context_data(struct gl_context *ctx, bool destroy_debug_output)
 
    _mesa_free_attrib_data(ctx);
    _mesa_free_eval_data( ctx );
+   _mesa_free_feedback(ctx);
    _mesa_free_texture_data( ctx );
    _mesa_free_image_textures(ctx);
    _mesa_free_matrix_data( ctx );
diff --git a/src/mesa/main/context.h b/src/mesa/main/context.h
index 6e068f9dd7ab..eb52f7575d45 100644
--- a/src/mesa/main/context.h
+++ b/src/mesa/main/context.h
@@ -412,6 +412,13 @@ _mesa_has_texture_view(const struct gl_context *ctx)
           _mesa_has_OES_texture_view(ctx);
 }
 
+static inline bool
+_mesa_hw_select_enabled(const struct gl_context *ctx)
+{
+   return ctx->RenderMode == GL_SELECT &&
+      ctx->Const.HardwareAcceleratedSelect;
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mesa/main/feedback.c b/src/mesa/main/feedback.c
index 27880188d5f6..34e6a82aea6f 100644
--- a/src/mesa/main/feedback.c
+++ b/src/mesa/main/feedback.c
@@ -36,6 +36,7 @@
 #include "macros.h"
 #include "mtypes.h"
 #include "api_exec_decl.h"
+#include "bufferobj.h"
 
 #include "state_tracker/st_cb_feedback.h"
 
@@ -221,13 +222,170 @@ _mesa_update_hitflag(struct gl_context *ctx, GLfloat z)
    }
 }
 
+static void
+alloc_select_resource(struct gl_context *ctx)
+{
+   struct gl_selection *s = &ctx->Select;
+
+   if (!ctx->Const.HardwareAcceleratedSelect)
+      return;
+
+   if (!s->SaveBuffer) {
+      s->SaveBuffer = malloc(NAME_STACK_BUFFER_SIZE);
+      if (!s->SaveBuffer) {
+         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Cannot allocate name stack save buffer");
+         return;
+      }
+   }
+
+   if (!s->Result) {
+      s->Result = _mesa_bufferobj_alloc(ctx, -1);
+      if (!s->Result) {
+         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Cannot allocate select result buffer");
+         return;
+      }
+
+      GLuint init_result[MAX_NAME_STACK_RESULT_NUM * 3];
+      for (int i = 0; i < MAX_NAME_STACK_RESULT_NUM; i++) {
+         init_result[i * 3] = 0;              /* hit */
+         init_result[i * 3 + 1] = 0xffffffff; /* minz */
+         init_result[i * 3 + 2] = 0;          /* maxz */
+      }
+
+      bool success = _mesa_bufferobj_data(ctx,
+                                          GL_SHADER_STORAGE_BUFFER,
+                                          sizeof(init_result),
+                                          init_result,
+                                          GL_STATIC_DRAW, 0,
+                                          s->Result);
+      if (!success) {
+         _mesa_reference_buffer_object(ctx, &s->Result, NULL);
+         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Cannot init result buffer");
+         return;
+      }
+   }
+}
+
+static bool
+save_used_name_stack(struct gl_context *ctx)
+{
+   struct gl_selection *s = &ctx->Select;
+
+   if (!ctx->Const.HardwareAcceleratedSelect)
+      return false;
+
+   /* We have two kinds of name stack user:
+    *   1. glRasterPos (CPU based) will set HitFlag
+    *   2. draw call for GPU will set ResultUsed
+    */
+   if (!s->ResultUsed && !s->HitFlag)
+      return false;
+
+   void *save = (char *)s->SaveBuffer + s->SaveBufferTail;
+
+   /* save meta data */
+   uint8_t *metadata = save;
+   metadata[0] = s->HitFlag;
+   metadata[1] = s->ResultUsed;
+   metadata[2] = s->NameStackDepth;
+   metadata[3] = 0;
+
+   /* save hit data */
+   int index = 1;
+   if (s->HitFlag) {
+      float *hit = save;
+      hit[index++] = s->HitMinZ;
+      hit[index++] = s->HitMaxZ;
+   }
+
+   /* save name stack */
+   memcpy((uint32_t *)save + index, s->NameStack, s->NameStackDepth * sizeof(GLuint));
+   index += s->NameStackDepth;
+
+   s->SaveBufferTail += index * sizeof(GLuint);
+   s->SavedStackNum++;
+
+   /* if current slot has been used, store result to next slot in result buffer */
+   if (s->ResultUsed)
+      s->ResultOffset += 3 * sizeof(GLuint);
+
+   /* reset fields */
+   s->HitFlag = GL_FALSE;
+   s->HitMinZ = 1.0;
+   s->HitMaxZ = 0;
+
+   s->ResultUsed = GL_FALSE;
+
+   /* return true if we have no enough space for the next name stack data */
+   return s->ResultOffset >= MAX_NAME_STACK_RESULT_NUM * 3 * sizeof(GLuint) ||
+      s->SaveBufferTail >= NAME_STACK_BUFFER_SIZE - (MAX_NAME_STACK_DEPTH + 3) * sizeof(GLuint);
+}
+
 static void
 update_hit_record(struct gl_context *ctx)
 {
    struct gl_selection *s = &ctx->Select;
 
    if (ctx->Const.HardwareAcceleratedSelect) {
+      if (!s->SavedStackNum)
+         return;
 
+      unsigned size = s->ResultOffset;
+      GLuint *result = size ? alloca(size) : NULL;
+      _mesa_bufferobj_get_subdata(ctx, 0, size, result, s->Result);
+
+      unsigned index = 0;
+      unsigned *save = s->SaveBuffer;
+      for (int i = 0; i < s->SavedStackNum; i++) {
+         uint8_t *metadata = (uint8_t *)(save++);
+
+         unsigned zmin, zmax;
+         bool cpu_hit = !!metadata[0];
+         if (cpu_hit) {
+            /* map [0, 1] to [0, UINT_MAX]*/
+            zmin = (unsigned) ((float)(~0u) * *(float *)(save++));
+            zmax = (unsigned) ((float)(~0u) * *(float *)(save++));
+         } else {
+            zmin = ~0u;
+            zmax = 0;
+         }
+
+         bool gpu_hit = false;
+         if (metadata[1]) {
+            gpu_hit = !!result[index];
+
+            if (gpu_hit) {
+               zmin = MIN2(zmin, result[index + 1]);
+               zmax = MAX2(zmax, result[index + 2]);
+
+               /* reset data */
+               result[index]     = 0;          /* hit */
+               result[index + 1] = 0xffffffff; /* minz */
+               result[index + 2] = 0;          /* maxz */
+            }
+            index += 3;
+         }
+
+         int depth = metadata[2];
+         if (cpu_hit || gpu_hit) {
+            /* hit */
+            write_record(ctx, depth);
+            write_record(ctx, zmin);
+            write_record(ctx, zmax);
+
+            for (int j = 0; j < depth; j++)
+               write_record(ctx, save[j]);
+            s->Hits++;
+         }
+         save += depth;
+      }
+
+      /* reset result buffer */
+      _mesa_bufferobj_subdata(ctx, 0, size, result, s->Result);
+
+      s->SaveBufferTail = 0;
+      s->SavedStackNum = 0;
+      s->ResultOffset = 0;
    } else {
       if (!s->HitFlag)
          return;
@@ -261,6 +419,13 @@ reset_name_stack_to_empty(struct gl_context *ctx)
    s->HitFlag = GL_FALSE;
    s->HitMinZ = 1.0;
    s->HitMaxZ = 0.0;
+
+   if (ctx->Const.HardwareAcceleratedSelect) {
+      s->SaveBufferTail = 0;
+      s->SavedStackNum = 0;
+      s->ResultUsed = GL_FALSE;
+      s->ResultOffset = 0;
+   }
 }
 
 /**
@@ -277,6 +442,7 @@ _mesa_InitNames( void )
 
    FLUSH_VERTICES(ctx, 0, 0);
 
+   save_used_name_stack(ctx);
    update_hit_record(ctx);
 
    reset_name_stack_to_empty(ctx);
@@ -303,7 +469,7 @@ _mesa_LoadName( GLuint name )
       return;
    }
 
-   if (!ctx->Const.HardwareAcceleratedSelect) {
+   if (!ctx->Const.HardwareAcceleratedSelect || save_used_name_stack(ctx)) {
       FLUSH_VERTICES(ctx, 0, 0);
       update_hit_record(ctx);
    }
@@ -332,7 +498,7 @@ _mesa_PushName( GLuint name )
       return;
    }
 
-   if (!ctx->Const.HardwareAcceleratedSelect) {
+   if (!ctx->Const.HardwareAcceleratedSelect || save_used_name_stack(ctx)) {
       FLUSH_VERTICES(ctx, 0, 0);
       update_hit_record(ctx);
    }
@@ -359,7 +525,7 @@ _mesa_PopName( void )
       return;
    }
 
-   if (!ctx->Const.HardwareAcceleratedSelect) {
+   if (!ctx->Const.HardwareAcceleratedSelect || save_used_name_stack(ctx)) {
       FLUSH_VERTICES(ctx, 0, 0);
       update_hit_record(ctx);
    }
@@ -408,6 +574,7 @@ _mesa_RenderMode( GLenum mode )
 	 result = 0;
 	 break;
       case GL_SELECT:
+	 save_used_name_stack(ctx);
 	 update_hit_record(ctx);
 
 	 if (ctx->Select.BufferCount > ctx->Select.BufferSize) {
@@ -448,6 +615,7 @@ _mesa_RenderMode( GLenum mode )
 	    /* haven't called glSelectBuffer yet */
 	    _mesa_error( ctx, GL_INVALID_OPERATION, "glRenderMode" );
 	 }
+	 alloc_select_resource(ctx);
 	 break;
       case GL_FEEDBACK:
 	 if (ctx->Feedback.BufferSize==0) {
@@ -495,4 +663,12 @@ void _mesa_init_feedback( struct gl_context * ctx )
    ctx->RenderMode = GL_RENDER;
 }
 
+void _mesa_free_feedback(struct gl_context * ctx)
+{
+   struct gl_selection *s = &ctx->Select;
+
+   free(s->SaveBuffer);
+   _mesa_reference_buffer_object(ctx, &s->Result, NULL);
+}
+
 /*@}*/
diff --git a/src/mesa/main/feedback.h b/src/mesa/main/feedback.h
index 0d8646ba2150..67b4dba00dab 100644
--- a/src/mesa/main/feedback.h
+++ b/src/mesa/main/feedback.h
@@ -52,4 +52,7 @@ _mesa_update_hitflag( struct gl_context *ctx, GLfloat z );
 extern void
 _mesa_init_feedback( struct gl_context *ctx );
 
+extern void
+_mesa_free_feedback( struct gl_context *ctx );
+
 #endif /* FEEDBACK_H */
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 9d7aa49972c2..5db4417f665b 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1787,6 +1787,15 @@ struct gl_selection
    GLboolean HitFlag;	/**< hit flag */
    GLfloat HitMinZ;	/**< minimum hit depth */
    GLfloat HitMaxZ;	/**< maximum hit depth */
+
+   /* HW GL_SELECT */
+   void *SaveBuffer;        /**< array holds multi stack data */
+   GLuint SaveBufferTail;   /**< offset to SaveBuffer's tail */
+   GLuint SavedStackNum;    /**< number of saved stacks */
+
+   GLboolean ResultUsed;    /**< whether any draw used result buffer */
+   GLuint ResultOffset;     /**< offset into result buffer */
+   struct gl_buffer_object *Result; /**< result buffer */
 };
 
 
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index f0986c75c1c6..83c1a5eea37a 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -922,8 +922,13 @@ _mesa_End(void)
       last_draw->count = count;
       exec->vtx.markers[last].end = 1;
 
-      if (count)
+      if (count) {
+         /* mark result buffer used */
+         if (_mesa_hw_select_enabled(ctx))
+            ctx->Select.ResultUsed = GL_TRUE;
+
          ctx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;
+      }
 
       /* Special handling for GL_LINE_LOOP */
       if (exec->vtx.mode[last] == GL_LINE_LOOP &&
-- 
GitLab


From 1b897c536d3fac8d96318f44ce1b57ddec6ed606 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 13 May 2022 19:50:04 +0800
Subject: [PATCH 08/16] mesa/vbo: enclose none-vertex functions with
 HW_SELECT_MODE
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

For constructing dispatch table used in GL_SELECT mode. Every vertex
inserted need to also insert a name stack offset attribute.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/vbo/vbo_attrib_tmp.h | 2660 ++++++++++++++++-----------------
 1 file changed, 1327 insertions(+), 1333 deletions(-)

diff --git a/src/mesa/vbo/vbo_attrib_tmp.h b/src/mesa/vbo/vbo_attrib_tmp.h
index a83b0e61b6cb..af417a664f1e 100644
--- a/src/mesa/vbo/vbo_attrib_tmp.h
+++ b/src/mesa/vbo/vbo_attrib_tmp.h
@@ -248,234 +248,6 @@ TAG(Vertex4fv)(const GLfloat * v)
    ATTR4FV(VBO_ATTRIB_POS, v);
 }
 
-
-
-static void GLAPIENTRY
-TAG(TexCoord1f)(GLfloat x)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, x);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord1fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1FV(VBO_ATTRIB_TEX0, v);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord2f)(GLfloat x, GLfloat y)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, x, y);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord2fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR2FV(VBO_ATTRIB_TEX0, v);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord3f)(GLfloat x, GLfloat y, GLfloat z)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, x, y, z);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord3fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3FV(VBO_ATTRIB_TEX0, v);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, x, y, z, w);
-}
-
-static void GLAPIENTRY
-TAG(TexCoord4fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR4FV(VBO_ATTRIB_TEX0, v);
-}
-
-
-
-static void GLAPIENTRY
-TAG(Normal3f)(GLfloat x, GLfloat y, GLfloat z)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, x, y, z);
-}
-
-static void GLAPIENTRY
-TAG(Normal3fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3FV(VBO_ATTRIB_NORMAL, v);
-}
-
-
-
-static void GLAPIENTRY
-TAG(FogCoordfEXT)(GLfloat x)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_FOG, x);
-}
-
-
-
-static void GLAPIENTRY
-TAG(FogCoordfvEXT)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1FV(VBO_ATTRIB_FOG, v);
-}
-
-static void GLAPIENTRY
-TAG(Color3f)(GLfloat x, GLfloat y, GLfloat z)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR0, x, y, z);
-}
-
-static void GLAPIENTRY
-TAG(Color3fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3FV(VBO_ATTRIB_COLOR0, v);
-}
-
-static void GLAPIENTRY
-TAG(Color4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, x, y, z, w);
-}
-
-static void GLAPIENTRY
-TAG(Color4fv)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR4FV(VBO_ATTRIB_COLOR0, v);
-}
-
-
-
-static void GLAPIENTRY
-TAG(SecondaryColor3fEXT)(GLfloat x, GLfloat y, GLfloat z)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, x, y, z);
-}
-
-static void GLAPIENTRY
-TAG(SecondaryColor3fvEXT)(const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR3FV(VBO_ATTRIB_COLOR1, v);
-}
-
-
-
-static void GLAPIENTRY
-TAG(EdgeFlag)(GLboolean b)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_EDGEFLAG, (GLfloat) b);
-}
-
-
-
-static void GLAPIENTRY
-TAG(Indexf)(GLfloat f)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, f);
-}
-
-static void GLAPIENTRY
-TAG(Indexfv)(const GLfloat * f)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR1FV(VBO_ATTRIB_COLOR_INDEX, f);
-}
-
-
-
-static void GLAPIENTRY
-TAG(MultiTexCoord1fARB)(GLenum target, GLfloat x)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, x);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord1fvARB)(GLenum target, const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1FV(attr, v);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord2fARB)(GLenum target, GLfloat x, GLfloat y)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, x, y);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord2fvARB)(GLenum target, const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2FV(attr, v);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord3fARB)(GLenum target, GLfloat x, GLfloat y, GLfloat z)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, x, y, z);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord3fvARB)(GLenum target, const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3FV(attr, v);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord4fARB)(GLenum target, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, x, y, z, w);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoord4fvARB)(GLenum target, const GLfloat * v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4FV(attr, v);
-}
-
-
 static void GLAPIENTRY
 TAG(VertexAttrib1fARB)(GLuint index, GLfloat x)
 {
@@ -871,239 +643,39 @@ TAG(VertexP4uiv)(GLenum type, const GLuint *value)
 }
 
 static void GLAPIENTRY
-TAG(TexCoordP1ui)(GLenum type, GLuint coords)
+TAG(VertexAttribP1ui)(GLuint index, GLenum type, GLboolean normalized,
+		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP1ui");
-   ATTR_UI(ctx, 1, type, 0, VBO_ATTRIB_TEX0, coords);
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP1ui");
+   ATTR_UI_INDEX(ctx, 1, type, normalized, index, value);
 }
 
 static void GLAPIENTRY
-TAG(TexCoordP1uiv)(GLenum type, const GLuint *coords)
+TAG(VertexAttribP2ui)(GLuint index, GLenum type, GLboolean normalized,
+		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP1uiv");
-   ATTR_UI(ctx, 1, type, 0, VBO_ATTRIB_TEX0, coords[0]);
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP2ui");
+   ATTR_UI_INDEX(ctx, 2, type, normalized, index, value);
 }
 
 static void GLAPIENTRY
-TAG(TexCoordP2ui)(GLenum type, GLuint coords)
+TAG(VertexAttribP3ui)(GLuint index, GLenum type, GLboolean normalized,
+		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP2ui");
-   ATTR_UI(ctx, 2, type, 0, VBO_ATTRIB_TEX0, coords);
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP3ui");
+   ATTR_UI_INDEX(ctx, 3, type, normalized, index, value);
 }
 
 static void GLAPIENTRY
-TAG(TexCoordP2uiv)(GLenum type, const GLuint *coords)
+TAG(VertexAttribP4ui)(GLuint index, GLenum type, GLboolean normalized,
+		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP2uiv");
-   ATTR_UI(ctx, 2, type, 0, VBO_ATTRIB_TEX0, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(TexCoordP3ui)(GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP3ui");
-   ATTR_UI(ctx, 3, type, 0, VBO_ATTRIB_TEX0, coords);
-}
-
-static void GLAPIENTRY
-TAG(TexCoordP3uiv)(GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP3uiv");
-   ATTR_UI(ctx, 3, type, 0, VBO_ATTRIB_TEX0, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(TexCoordP4ui)(GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP4ui");
-   ATTR_UI(ctx, 4, type, 0, VBO_ATTRIB_TEX0, coords);
-}
-
-static void GLAPIENTRY
-TAG(TexCoordP4uiv)(GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP4uiv");
-   ATTR_UI(ctx, 4, type, 0, VBO_ATTRIB_TEX0, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP1ui)(GLenum target, GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP1ui");
-   ATTR_UI(ctx, 1, type, 0, attr, coords);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP1uiv)(GLenum target, GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP1uiv");
-   ATTR_UI(ctx, 1, type, 0, attr, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP2ui)(GLenum target, GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP2ui");
-   ATTR_UI(ctx, 2, type, 0, attr, coords);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP2uiv)(GLenum target, GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP2uiv");
-   ATTR_UI(ctx, 2, type, 0, attr, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP3ui)(GLenum target, GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP3ui");
-   ATTR_UI(ctx, 3, type, 0, attr, coords);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP3uiv)(GLenum target, GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP3uiv");
-   ATTR_UI(ctx, 3, type, 0, attr, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP4ui)(GLenum target, GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP4ui");
-   ATTR_UI(ctx, 4, type, 0, attr, coords);
-}
-
-static void GLAPIENTRY
-TAG(MultiTexCoordP4uiv)(GLenum target, GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP4uiv");
-   ATTR_UI(ctx, 4, type, 0, attr, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(NormalP3ui)(GLenum type, GLuint coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glNormalP3ui");
-   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_NORMAL, coords);
-}
-
-static void GLAPIENTRY
-TAG(NormalP3uiv)(GLenum type, const GLuint *coords)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glNormalP3uiv");
-   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_NORMAL, coords[0]);
-}
-
-static void GLAPIENTRY
-TAG(ColorP3ui)(GLenum type, GLuint color)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP3ui");
-   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR0, color);
-}
-
-static void GLAPIENTRY
-TAG(ColorP3uiv)(GLenum type, const GLuint *color)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP3uiv");
-   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR0, color[0]);
-}
-
-static void GLAPIENTRY
-TAG(ColorP4ui)(GLenum type, GLuint color)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP4ui");
-   ATTR_UI(ctx, 4, type, 1, VBO_ATTRIB_COLOR0, color);
-}
-
-static void GLAPIENTRY
-TAG(ColorP4uiv)(GLenum type, const GLuint *color)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP4uiv");
-   ATTR_UI(ctx, 4, type, 1, VBO_ATTRIB_COLOR0, color[0]);
-}
-
-static void GLAPIENTRY
-TAG(SecondaryColorP3ui)(GLenum type, GLuint color)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glSecondaryColorP3ui");
-   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR1, color);
-}
-
-static void GLAPIENTRY
-TAG(SecondaryColorP3uiv)(GLenum type, const GLuint *color)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glSecondaryColorP3uiv");
-   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR1, color[0]);
-}
-
-static void GLAPIENTRY
-TAG(VertexAttribP1ui)(GLuint index, GLenum type, GLboolean normalized,
-		      GLuint value)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP1ui");
-   ATTR_UI_INDEX(ctx, 1, type, normalized, index, value);
-}
-
-static void GLAPIENTRY
-TAG(VertexAttribP2ui)(GLuint index, GLenum type, GLboolean normalized,
-		      GLuint value)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP2ui");
-   ATTR_UI_INDEX(ctx, 2, type, normalized, index, value);
-}
-
-static void GLAPIENTRY
-TAG(VertexAttribP3ui)(GLuint index, GLenum type, GLboolean normalized,
-		      GLuint value)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP3ui");
-   ATTR_UI_INDEX(ctx, 3, type, normalized, index, value);
-}
-
-static void GLAPIENTRY
-TAG(VertexAttribP4ui)(GLuint index, GLenum type, GLboolean normalized,
-		      GLuint value)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP4ui");
-   ATTR_UI_INDEX(ctx, 4, type, normalized, index, value);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP4ui");
+   ATTR_UI_INDEX(ctx, 4, type, normalized, index, value);
 }
 
 static void GLAPIENTRY
@@ -1307,2083 +879,2505 @@ TAG(Vertex4hvNV)(const GLhalfNV * v)
    ATTR4HV(VBO_ATTRIB_POS, v);
 }
 
-
-
 static void GLAPIENTRY
-TAG(Normal3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
+TAG(VertexAttrib1hNV)(GLuint index, GLhalfNV x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3H(VBO_ATTRIB_NORMAL, x, y, z);
+   if (is_vertex_position(ctx, index))
+      ATTR1H(0, x);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1H(VBO_ATTRIB_GENERIC0 + index, x);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3hvNV)(const GLhalfNV * v)
+TAG(VertexAttrib2hNV)(GLuint index, GLhalfNV x, GLhalfNV y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3HV(VBO_ATTRIB_NORMAL, v);
+   if (is_vertex_position(ctx, index))
+      ATTR2H(0, x, y);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR2H(VBO_ATTRIB_GENERIC0 + index, x, y);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
-
 static void GLAPIENTRY
-TAG(Color3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
+TAG(VertexAttrib3hNV)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3H(VBO_ATTRIB_COLOR0, x, y, z);
+   if (is_vertex_position(ctx, index))
+      ATTR3H(0, x, y, z);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR3H(VBO_ATTRIB_GENERIC0 + index, x, y, z);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Color3hvNV)(const GLhalfNV * v)
+TAG(VertexAttrib4hNV)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3HV(VBO_ATTRIB_COLOR0, v);
+   if (is_vertex_position(ctx, index))
+      ATTR4H(0, x, y, z, w);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4H(VBO_ATTRIB_GENERIC0 + index, x, y, z, w);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Color4hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
+TAG(VertexAttrib1hvNV)(GLuint index, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4H(VBO_ATTRIB_COLOR0, x, y, z, w);
+   if (is_vertex_position(ctx, index))
+      ATTR1HV(0, v);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1HV(VBO_ATTRIB_GENERIC0 + index, v);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Color4hvNV)(const GLhalfNV * v)
+TAG(VertexAttrib2hvNV)(GLuint index, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4HV(VBO_ATTRIB_COLOR0, v);
+   if (is_vertex_position(ctx, index))
+      ATTR2HV(0, v);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR2HV(VBO_ATTRIB_GENERIC0 + index, v);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
-
 static void GLAPIENTRY
-TAG(TexCoord1hNV)(GLhalfNV x)
+TAG(VertexAttrib3hvNV)(GLuint index, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1H(VBO_ATTRIB_TEX0, x);
+   if (is_vertex_position(ctx, index))
+      ATTR3HV(0, v);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR3HV(VBO_ATTRIB_GENERIC0 + index, v);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1hvNV)(const GLhalfNV * v)
+TAG(VertexAttrib4hvNV)(GLuint index, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1HV(VBO_ATTRIB_TEX0, v);
+   if (is_vertex_position(ctx, index))
+      ATTR4HV(0, v);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4HV(VBO_ATTRIB_GENERIC0 + index, v);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2hNV)(GLhalfNV x, GLhalfNV y)
+TAG(VertexAttribs1hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2H(VBO_ATTRIB_TEX0, x, y);
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (GLint i = n - 1; i >= 0; i--)
+      ATTR1H(index + i, v[i]);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2hvNV)(const GLhalfNV * v)
+TAG(VertexAttribs2hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2HV(VBO_ATTRIB_TEX0, v);
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (GLint i = n - 1; i >= 0; i--)
+      ATTR2H(index + i, v[2 * i], v[2 * i + 1]);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
+TAG(VertexAttribs3hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3H(VBO_ATTRIB_TEX0, x, y, z);
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (GLint i = n - 1; i >= 0; i--)
+      ATTR3H(index + i, v[3 * i], v[3 * i + 1], v[3 * i + 2]);
 }
 
+
 static void GLAPIENTRY
-TAG(TexCoord3hvNV)(const GLhalfNV * v)
+TAG(VertexAttribs4hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3HV(VBO_ATTRIB_TEX0, v);
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (GLint i = n - 1; i >= 0; i--)
+      ATTR4H(index + i, v[4 * i], v[4 * i + 1], v[4 * i + 2], v[4 * i + 3]);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord4hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
+TAG(Vertex2d)(GLdouble x, GLdouble y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4H(VBO_ATTRIB_TEX0, x, y, z, w);
+   ATTR2F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord4hvNV)(const GLhalfNV * v)
+TAG(Vertex2i)(GLint x, GLint y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4HV(VBO_ATTRIB_TEX0, v);
+   ATTR2F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y);
 }
 
-
-
 static void GLAPIENTRY
-TAG(MultiTexCoord1hNV)(GLenum target, GLhalfNV x)
+TAG(Vertex2s)(GLshort x, GLshort y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1H(attr, x);
+   ATTR2F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1hvNV)(GLenum target, const GLhalfNV * v)
+TAG(Vertex3d)(GLdouble x, GLdouble y, GLdouble z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1HV(attr, v);
+   ATTR3F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2hNV)(GLenum target, GLhalfNV x, GLhalfNV y)
+TAG(Vertex3i)(GLint x, GLint y, GLint z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2H(attr, x, y);
+   ATTR3F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2hvNV)(GLenum target, const GLhalfNV * v)
+TAG(Vertex3s)(GLshort x, GLshort y, GLshort z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2HV(attr, v);
+   ATTR3F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3hNV)(GLenum target, GLhalfNV x, GLhalfNV y, GLhalfNV z)
+TAG(Vertex4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3H(attr, x, y, z);
+   ATTR4F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3hvNV)(GLenum target, const GLhalfNV * v)
+TAG(Vertex4i)(GLint x, GLint y, GLint z, GLint w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3HV(attr, v);
+   ATTR4F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4hNV)(GLenum target, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
+TAG(Vertex4s)(GLshort x, GLshort y, GLshort z, GLshort w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4H(attr, x, y, z, w);
+   ATTR4F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4hvNV)(GLenum target, const GLhalfNV * v)
+TAG(Vertex2dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4HV(attr, v);
+   ATTR2F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1]);
 }
 
-
-
 static void GLAPIENTRY
-TAG(VertexAttrib1hNV)(GLuint index, GLhalfNV x)
+TAG(Vertex2iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1H(0, x);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1H(VBO_ATTRIB_GENERIC0 + index, x);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib2hNV)(GLuint index, GLhalfNV x, GLhalfNV y)
+TAG(Vertex2sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR2H(0, x, y);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR2H(VBO_ATTRIB_GENERIC0 + index, x, y);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3hNV)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
+TAG(Vertex3dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR3H(0, x, y, z);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR3H(VBO_ATTRIB_GENERIC0 + index, x, y, z);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4hNV)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
+TAG(Vertex3iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4H(0, x, y, z, w);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4H(VBO_ATTRIB_GENERIC0 + index, x, y, z, w);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1hvNV)(GLuint index, const GLhalfNV * v)
+TAG(Vertex3sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1HV(0, v);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1HV(VBO_ATTRIB_GENERIC0 + index, v);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib2hvNV)(GLuint index, const GLhalfNV * v)
+TAG(Vertex4dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR2HV(0, v);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR2HV(VBO_ATTRIB_GENERIC0 + index, v);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR4F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1],
+         (GLfloat) v[2], (GLfloat) v[3]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3hvNV)(GLuint index, const GLhalfNV * v)
+TAG(Vertex4iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR3HV(0, v);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR3HV(VBO_ATTRIB_GENERIC0 + index, v);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR4F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1],
+         (GLfloat) v[2], (GLfloat) v[3]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4hvNV)(GLuint index, const GLhalfNV * v)
+TAG(Vertex4sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4HV(0, v);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4HV(VBO_ATTRIB_GENERIC0 + index, v);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR4F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1],
+         (GLfloat) v[2], (GLfloat) v[3]);
 }
 
+/*
+ * GL_NV_vertex_program:
+ * Note that attribute indexes DO alias conventional vertex attributes.
+ */
+
 static void GLAPIENTRY
-TAG(VertexAttribs1hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
+TAG(VertexAttrib1sNV)(GLuint index, GLshort x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (GLint i = n - 1; i >= 0; i--)
-      ATTR1H(index + i, v[i]);
+   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) x);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs2hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
+TAG(VertexAttrib1dNV)(GLuint index, GLdouble x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (GLint i = n - 1; i >= 0; i--)
-      ATTR2H(index + i, v[2 * i], v[2 * i + 1]);
+   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) x);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs3hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
+TAG(VertexAttrib2sNV)(GLuint index, GLshort x, GLshort y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (GLint i = n - 1; i >= 0; i--)
-      ATTR3H(index + i, v[3 * i], v[3 * i + 1], v[3 * i + 2]);
+   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) x, y);
 }
 
-
 static void GLAPIENTRY
-TAG(VertexAttribs4hvNV)(GLuint index, GLsizei n, const GLhalfNV *v)
+TAG(VertexAttrib2dNV)(GLuint index, GLdouble x, GLdouble y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (GLint i = n - 1; i >= 0; i--)
-      ATTR4H(index + i, v[4 * i], v[4 * i + 1], v[4 * i + 2], v[4 * i + 3]);
+   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) x, (GLfloat) y);
 }
 
-
-
 static void GLAPIENTRY
-TAG(FogCoordhNV)(GLhalf x)
+TAG(VertexAttrib3sNV)(GLuint index, GLshort x, GLshort y, GLshort z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1H(VBO_ATTRIB_FOG, x);
+   if (index < VBO_ATTRIB_MAX) ATTR3F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
 }
 
 static void GLAPIENTRY
-TAG(FogCoordhvNV)(const GLhalf * v)
+TAG(VertexAttrib3dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1HV(VBO_ATTRIB_FOG, v);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
 }
 
-
-
 static void GLAPIENTRY
-TAG(SecondaryColor3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
+TAG(VertexAttrib4sNV)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3H(VBO_ATTRIB_COLOR1, x, y, z);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3hvNV)(const GLhalfNV * v)
+TAG(VertexAttrib4dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3HV(VBO_ATTRIB_COLOR1, v);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
 }
 
-
 static void GLAPIENTRY
-TAG(Color3b)(GLbyte red, GLbyte green, GLbyte blue)
+TAG(VertexAttrib4ubNV)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(red),
-          BYTE_TO_FLOAT(green),
-          BYTE_TO_FLOAT(blue),
-          1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, UBYTE_TO_FLOAT(x), UBYTE_TO_FLOAT(y),
+                                      UBYTE_TO_FLOAT(z), UBYTE_TO_FLOAT(w));
 }
 
 static void GLAPIENTRY
-TAG(Color3d)(GLdouble red, GLdouble green, GLdouble blue)
+TAG(VertexAttrib1svNV)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) red, (GLfloat) green, (GLfloat) blue, 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) v[0]);
 }
 
 static void GLAPIENTRY
-TAG(Color3i)(GLint red, GLint green, GLint blue)
+TAG(VertexAttrib1dvNV)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(red), INT_TO_FLOAT(green),
-          INT_TO_FLOAT(blue), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) v[0]);
 }
 
 static void GLAPIENTRY
-TAG(Color3s)(GLshort red, GLshort green, GLshort blue)
+TAG(VertexAttrib2svNV)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(red), SHORT_TO_FLOAT(green),
-          SHORT_TO_FLOAT(blue), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) v[0], (GLfloat) v[1]);
 }
 
 static void GLAPIENTRY
-TAG(Color3ui)(GLuint red, GLuint green, GLuint blue)
+TAG(VertexAttrib2dvNV)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(red), UINT_TO_FLOAT(green),
-          UINT_TO_FLOAT(blue), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) v[0], (GLfloat) v[1]);
 }
 
 static void GLAPIENTRY
-TAG(Color3us)(GLushort red, GLushort green, GLushort blue)
+TAG(VertexAttrib3svNV)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(red), USHORT_TO_FLOAT(green),
-          USHORT_TO_FLOAT(blue), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR3F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
 }
 
 static void GLAPIENTRY
-TAG(Color3ub)(GLubyte red, GLubyte green, GLubyte blue)
+TAG(VertexAttrib3dvNV)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(red), UBYTE_TO_FLOAT(green),
-          UBYTE_TO_FLOAT(blue), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR3F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
 }
 
-
 static void GLAPIENTRY
-TAG(Color3bv)(const GLbyte *v)
+TAG(VertexAttrib4svNV)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]),
-         BYTE_TO_FLOAT(v[2]), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2],
+         (GLfloat)v[3]);
 }
 
 static void GLAPIENTRY
-TAG(Color3dv)(const GLdouble *v)
+TAG(VertexAttrib4dvNV)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
 }
 
 static void GLAPIENTRY
-TAG(Color3iv)(const GLint *v)
+TAG(VertexAttrib4ubvNV)(GLuint index, const GLubyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]),
-         INT_TO_FLOAT(v[2]), 1.0);
+   if (index < VBO_ATTRIB_MAX) ATTR4F(index, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]),
+         UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
 }
 
-static void GLAPIENTRY
-TAG(Color3sv)(const GLshort *v)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]),
-         SHORT_TO_FLOAT(v[2]), 1.0);
-}
 
 static void GLAPIENTRY
-TAG(Color3uiv)(const GLuint *v)
+TAG(VertexAttribs1svNV)(GLuint index, GLsizei n, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]),
-         UINT_TO_FLOAT(v[2]), 1.0);
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR1F(index + i, (GLfloat) v[i]);
 }
 
 static void GLAPIENTRY
-TAG(Color3usv)(const GLushort *v)
+TAG(VertexAttribs1fvNV)(GLuint index, GLsizei n, const GLfloat *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]),
-         USHORT_TO_FLOAT(v[2]), 1.0);
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR1F(index + i, v[i]);
 }
 
 static void GLAPIENTRY
-TAG(Color3ubv)(const GLubyte *v)
+TAG(VertexAttribs1dvNV)(GLuint index, GLsizei n, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]),
-         UBYTE_TO_FLOAT(v[2]), 1.0);
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR1F(index + i, (GLfloat) v[i]);
 }
 
-
 static void GLAPIENTRY
-TAG(Color4b)(GLbyte red, GLbyte green, GLbyte blue,
-              GLbyte alpha)
+TAG(VertexAttribs2svNV)(GLuint index, GLsizei n, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(red), BYTE_TO_FLOAT(green),
-          BYTE_TO_FLOAT(blue), BYTE_TO_FLOAT(alpha));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR2F(index + i, (GLfloat) v[2 * i], (GLfloat) v[2 * i + 1]);
 }
 
 static void GLAPIENTRY
-TAG(Color4d)(GLdouble red, GLdouble green, GLdouble blue,
-              GLdouble alpha)
+TAG(VertexAttribs2fvNV)(GLuint index, GLsizei n, const GLfloat *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) red, (GLfloat) green, (GLfloat) blue, (GLfloat) alpha);
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR2F(index + i, v[2 * i], v[2 * i + 1]);
 }
 
 static void GLAPIENTRY
-TAG(Color4i)(GLint red, GLint green, GLint blue, GLint alpha)
+TAG(VertexAttribs2dvNV)(GLuint index, GLsizei n, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(red), INT_TO_FLOAT(green),
-          INT_TO_FLOAT(blue), INT_TO_FLOAT(alpha));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR2F(index + i, (GLfloat) v[2 * i], (GLfloat) v[2 * i + 1]);
 }
 
 static void GLAPIENTRY
-TAG(Color4s)(GLshort red, GLshort green, GLshort blue,
-              GLshort alpha)
+TAG(VertexAttribs3svNV)(GLuint index, GLsizei n, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(red), SHORT_TO_FLOAT(green),
-          SHORT_TO_FLOAT(blue), SHORT_TO_FLOAT(alpha));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR3F(index + i, (GLfloat) v[3 * i], (GLfloat) v[3 * i + 1], (GLfloat) v[3 * i + 2]);
 }
 
 static void GLAPIENTRY
-TAG(Color4ui)(GLuint red, GLuint green, GLuint blue, GLuint alpha)
+TAG(VertexAttribs3fvNV)(GLuint index, GLsizei n, const GLfloat *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(red), UINT_TO_FLOAT(green),
-          UINT_TO_FLOAT(blue), UINT_TO_FLOAT(alpha));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR3F(index + i, v[3 * i], v[3 * i + 1], v[3 * i + 2]);
 }
 
 static void GLAPIENTRY
-TAG(Color4us)(GLushort red, GLushort green, GLushort blue, GLushort alpha)
+TAG(VertexAttribs3dvNV)(GLuint index, GLsizei n, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(red), USHORT_TO_FLOAT(green),
-          USHORT_TO_FLOAT(blue), USHORT_TO_FLOAT(alpha));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR3F(index + i, (GLfloat) v[3 * i], (GLfloat) v[3 * i + 1], (GLfloat) v[3 * i + 2]);
 }
 
 static void GLAPIENTRY
-TAG(Color4ub)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
+TAG(VertexAttribs4svNV)(GLuint index, GLsizei n, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(red), UBYTE_TO_FLOAT(green),
-          UBYTE_TO_FLOAT(blue), UBYTE_TO_FLOAT(alpha));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR4F(index + i, (GLfloat) v[4 * i], (GLfloat) v[4 * i + 1], (GLfloat) v[4 * i + 2], (GLfloat) v[4 * i + 3]);
 }
 
-
 static void GLAPIENTRY
-TAG(Color4iv)(const GLint *v)
+TAG(VertexAttribs4fvNV)(GLuint index, GLsizei n, const GLfloat *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]),
-         INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR4F(index + i, v[4 * i], v[4 * i + 1], v[4 * i + 2], v[4 * i + 3]);
 }
 
-
 static void GLAPIENTRY
-TAG(Color4bv)(const GLbyte *v)
+TAG(VertexAttribs4dvNV)(GLuint index, GLsizei n, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]),
-         BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]));
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR4F(index + i, (GLfloat) v[4 * i], (GLfloat) v[4 * i + 1], (GLfloat) v[4 * i + 2], (GLfloat) v[4 * i + 3]);
 }
 
 static void GLAPIENTRY
-TAG(Color4dv)(const GLdouble *v)
+TAG(VertexAttribs4ubvNV)(GLuint index, GLsizei n, const GLubyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+   GLint i;
+   n = MIN2(n, VBO_ATTRIB_MAX - index);
+   for (i = n - 1; i >= 0; i--)
+      ATTR4F(index + i, UBYTE_TO_FLOAT(v[4 * i]), UBYTE_TO_FLOAT(v[4 * i + 1]),
+             UBYTE_TO_FLOAT(v[4 * i + 2]), UBYTE_TO_FLOAT(v[4 * i + 3]));
 }
 
 
+/*
+ * GL_ARB_vertex_program
+ * Note that attribute indexes do NOT alias conventional attributes.
+ */
+
 static void GLAPIENTRY
-TAG(Color4sv)(const GLshort *v)
+TAG(VertexAttrib1s)(GLuint index, GLshort x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]),
-         SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]));
+   if (is_vertex_position(ctx, index))
+      ATTR1F(0, (GLfloat) x);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
 static void GLAPIENTRY
-TAG(Color4uiv)(const GLuint *v)
+TAG(VertexAttrib1d)(GLuint index, GLdouble x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]),
-         UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]));
+   if (is_vertex_position(ctx, index))
+      ATTR1F(0, (GLfloat) x);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Color4usv)(const GLushort *v)
+TAG(VertexAttrib2s)(GLuint index, GLshort x, GLshort y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]),
-         USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]));
+   if (is_vertex_position(ctx, index))
+      ATTR2F(0, (GLfloat) x, (GLfloat) y);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Color4ubv)(const GLubyte *v)
+TAG(VertexAttrib2d)(GLuint index, GLdouble x, GLdouble y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]),
-         UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
+   if (is_vertex_position(ctx, index))
+      ATTR2F(0, (GLfloat) x, (GLfloat) y);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
 static void GLAPIENTRY
-TAG(FogCoordd)(GLdouble d)
+TAG(VertexAttrib3s)(GLuint index, GLshort x, GLshort y, GLshort z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_FOG, (GLfloat) d);
+   if (is_vertex_position(ctx, index))
+      ATTR3F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(FogCoorddv)(const GLdouble *v)
+TAG(VertexAttrib3d)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_FOG, (GLfloat) *v);
+   if (is_vertex_position(ctx, index))
+      ATTR3F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
 static void GLAPIENTRY
-TAG(Indexd)(GLdouble c)
+TAG(VertexAttrib4s)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexi)(GLint c)
+TAG(VertexAttrib4d)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexs)(GLshort c)
+TAG(VertexAttrib1sv)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
+   if (is_vertex_position(ctx, index))
+      ATTR1F(0, (GLfloat) v[0]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexub)(GLubyte c)
+TAG(VertexAttrib1dv)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
+   if (is_vertex_position(ctx, index))
+      ATTR1F(0, (GLfloat) v[0]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexdv)(const GLdouble *c)
+TAG(VertexAttrib2sv)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
+   if (is_vertex_position(ctx, index))
+      ATTR2F(0, (GLfloat) v[0], (GLfloat) v[1]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexiv)(const GLint *c)
+TAG(VertexAttrib2dv)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
+   if (is_vertex_position(ctx, index))
+      ATTR2F(0, (GLfloat) v[0], (GLfloat) v[1]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexsv)(const GLshort *c)
+TAG(VertexAttrib3sv)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
+   if (is_vertex_position(ctx, index))
+      ATTR3F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Indexubv)(const GLubyte *c)
+TAG(VertexAttrib3dv)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
+   if (is_vertex_position(ctx, index))
+      ATTR3F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
 static void GLAPIENTRY
-TAG(EdgeFlagv)(const GLboolean *flag)
+TAG(VertexAttrib4sv)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_EDGEFLAG, (GLfloat)*flag);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
-
 static void GLAPIENTRY
-TAG(Normal3b)(GLbyte nx, GLbyte ny, GLbyte nz)
+TAG(VertexAttrib4dv)(GLuint index, const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, BYTE_TO_FLOAT(nx), BYTE_TO_FLOAT(ny), BYTE_TO_FLOAT(nz));
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3d)(GLdouble nx, GLdouble ny, GLdouble nz)
+TAG(VertexAttrib4bv)(GLuint index, const GLbyte * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, (GLfloat) nx, (GLfloat) ny, (GLfloat) nz);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3i)(GLint nx, GLint ny, GLint nz)
+TAG(VertexAttrib4iv)(GLuint index, const GLint * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, INT_TO_FLOAT(nx), INT_TO_FLOAT(ny), INT_TO_FLOAT(nz));
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3s)(GLshort nx, GLshort ny, GLshort nz)
+TAG(VertexAttrib4ubv)(GLuint index, const GLubyte * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, SHORT_TO_FLOAT(nx), SHORT_TO_FLOAT(ny), SHORT_TO_FLOAT(nz));
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3bv)(const GLbyte *v)
+TAG(VertexAttrib4usv)(GLuint index, const GLushort * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]));
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3dv)(const GLdouble *v)
+TAG(VertexAttrib4uiv)(GLuint index, const GLuint * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3iv)(const GLint *v)
+TAG(VertexAttrib4Nbv)(GLuint index, const GLbyte * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]));
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(Normal3sv)(const GLshort *v)
+TAG(VertexAttrib4Nsv)(GLuint index, const GLshort * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_NORMAL, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]));
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1d)(GLdouble s)
+TAG(VertexAttrib4Niv)(GLuint index, const GLint * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) s);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1i)(GLint s)
+TAG(VertexAttrib4Nub)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) s);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, UBYTE_TO_FLOAT(x), UBYTE_TO_FLOAT(y), UBYTE_TO_FLOAT(z), UBYTE_TO_FLOAT(w));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, UBYTE_TO_FLOAT(x), UBYTE_TO_FLOAT(y), UBYTE_TO_FLOAT(z), UBYTE_TO_FLOAT(w));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1s)(GLshort s)
+TAG(VertexAttrib4Nubv)(GLuint index, const GLubyte * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) s);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]), UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]), UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2d)(GLdouble s, GLdouble t)
+TAG(VertexAttrib4Nusv)(GLuint index, const GLushort * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]), USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]), USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2s)(GLshort s, GLshort t)
+TAG(VertexAttrib4Nuiv)(GLuint index, const GLuint * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t);
+   if (is_vertex_position(ctx, index))
+      ATTR4F(0, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]), UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]));
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4F(VBO_ATTRIB_GENERIC0 + index, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]), UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]));
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
+/**
+ * GL_EXT_gpu_shader / GL 3.0 signed/unsigned integer-valued attributes.
+ * Note that attribute indexes do NOT alias conventional attributes.
+ */
+
 static void GLAPIENTRY
-TAG(TexCoord2i)(GLint s, GLint t)
+TAG(VertexAttribI1iv)(GLuint index, const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t);
+   if (is_vertex_position(ctx, index))
+      ATTR1I(0, v[0]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1I(VBO_ATTRIB_GENERIC0 + index, v[0]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord3d)(GLdouble s, GLdouble t, GLdouble r)
+TAG(VertexAttribI1uiv)(GLuint index, const GLuint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r);
+   if (is_vertex_position(ctx, index))
+      ATTR1UI(0, v[0]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR1UI(VBO_ATTRIB_GENERIC0 + index, v[0]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord3i)(GLint s, GLint t, GLint r)
+TAG(VertexAttribI4bv)(GLuint index, const GLbyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r);
+   if (is_vertex_position(ctx, index))
+      ATTR4I(0, v[0], v[1], v[2], v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4I(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord3s)(GLshort s, GLshort t, GLshort r)
+TAG(VertexAttribI4sv)(GLuint index, const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r);
+   if (is_vertex_position(ctx, index))
+      ATTR4I(0, v[0], v[1], v[2], v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4I(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord4d)(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+TAG(VertexAttribI4ubv)(GLuint index, const GLubyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r,(GLfloat) q);
+   if (is_vertex_position(ctx, index))
+      ATTR4UI(0, v[0], v[1], v[2], v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4UI(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord4i)(GLint s, GLint t, GLint r, GLint q)
+TAG(VertexAttribI4usv)(GLuint index, const GLushort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r,(GLfloat) q);
+   if (is_vertex_position(ctx, index))
+      ATTR4UI(0, v[0], v[1], v[2], v[3]);
+   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
+      ATTR4UI(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
+   else
+      ERROR(GL_INVALID_VALUE);
 }
 
+/* define this macro to exclude folllowing none-vertex functions */
+#ifndef HW_SELECT_MODE
+
 static void GLAPIENTRY
-TAG(TexCoord4s)(GLshort s, GLshort t, GLshort r, GLshort q)
+TAG(TexCoord1f)(GLfloat x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r,(GLfloat) q);
+   ATTR1F(VBO_ATTRIB_TEX0, x);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1dv)(const GLdouble *v)
+TAG(TexCoord1fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) v[0]);
+   ATTR1FV(VBO_ATTRIB_TEX0, v);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1iv)(const GLint *v)
+TAG(TexCoord2f)(GLfloat x, GLfloat y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) v[0]);
+   ATTR2F(VBO_ATTRIB_TEX0, x, y);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord1sv)(const GLshort *v)
+TAG(TexCoord2fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) v[0]);
+   ATTR2FV(VBO_ATTRIB_TEX0, v);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2dv)(const GLdouble *v)
+TAG(TexCoord3f)(GLfloat x, GLfloat y, GLfloat z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1]);
+   ATTR3F(VBO_ATTRIB_TEX0, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2iv)(const GLint *v)
+TAG(TexCoord3fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1]);
+   ATTR3FV(VBO_ATTRIB_TEX0, v);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord2sv)(const GLshort *v)
+TAG(TexCoord4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1]);
+   ATTR4F(VBO_ATTRIB_TEX0, x, y, z, w);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord3dv)(const GLdouble *v)
+TAG(TexCoord4fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2]);
+   ATTR4FV(VBO_ATTRIB_TEX0, v);
 }
 
+
+
 static void GLAPIENTRY
-TAG(TexCoord3iv)(const GLint *v)
+TAG(Normal3f)(GLfloat x, GLfloat y, GLfloat z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2]);
+   ATTR3F(VBO_ATTRIB_NORMAL, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord3sv)(const GLshort *v)
+TAG(Normal3fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2]);
+   ATTR3FV(VBO_ATTRIB_NORMAL, v);
 }
 
-static void GLAPIENTRY
-TAG(TexCoord4dv)(const GLdouble *v)
+
+
+static void GLAPIENTRY
+TAG(FogCoordfEXT)(GLfloat x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2],(GLfloat) v[3]);
+   ATTR1F(VBO_ATTRIB_FOG, x);
 }
 
+
+
 static void GLAPIENTRY
-TAG(TexCoord4iv)(const GLint *v)
+TAG(FogCoordfvEXT)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2],(GLfloat) v[3]);
+   ATTR1FV(VBO_ATTRIB_FOG, v);
 }
 
 static void GLAPIENTRY
-TAG(TexCoord4sv)(const GLshort *v)
+TAG(Color3f)(GLfloat x, GLfloat y, GLfloat z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2],(GLfloat) v[3]);
+   ATTR3F(VBO_ATTRIB_COLOR0, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(Vertex2d)(GLdouble x, GLdouble y)
+TAG(Color3fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y);
+   ATTR3FV(VBO_ATTRIB_COLOR0, v);
 }
 
 static void GLAPIENTRY
-TAG(Vertex2i)(GLint x, GLint y)
+TAG(Color4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y);
+   ATTR4F(VBO_ATTRIB_COLOR0, x, y, z, w);
 }
 
 static void GLAPIENTRY
-TAG(Vertex2s)(GLshort x, GLshort y)
+TAG(Color4fv)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y);
+   ATTR4FV(VBO_ATTRIB_COLOR0, v);
 }
 
+
+
 static void GLAPIENTRY
-TAG(Vertex3d)(GLdouble x, GLdouble y, GLdouble z)
+TAG(SecondaryColor3fEXT)(GLfloat x, GLfloat y, GLfloat z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   ATTR3F(VBO_ATTRIB_COLOR1, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(Vertex3i)(GLint x, GLint y, GLint z)
+TAG(SecondaryColor3fvEXT)(const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   ATTR3FV(VBO_ATTRIB_COLOR1, v);
 }
 
+
+
 static void GLAPIENTRY
-TAG(Vertex3s)(GLshort x, GLshort y, GLshort z)
+TAG(EdgeFlag)(GLboolean b)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   ATTR1F(VBO_ATTRIB_EDGEFLAG, (GLfloat) b);
 }
 
+
+
 static void GLAPIENTRY
-TAG(Vertex4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+TAG(Indexf)(GLfloat f)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, f);
 }
 
 static void GLAPIENTRY
-TAG(Vertex4i)(GLint x, GLint y, GLint z, GLint w)
+TAG(Indexfv)(const GLfloat * f)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   ATTR1FV(VBO_ATTRIB_COLOR_INDEX, f);
 }
 
+
+
 static void GLAPIENTRY
-TAG(Vertex4s)(GLshort x, GLshort y, GLshort z, GLshort w)
+TAG(MultiTexCoord1fARB)(GLenum target, GLfloat x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_POS, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, x);
 }
 
 static void GLAPIENTRY
-TAG(Vertex2dv)(const GLdouble *v)
+TAG(MultiTexCoord1fvARB)(GLenum target, const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1FV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(Vertex2iv)(const GLint *v)
+TAG(MultiTexCoord2fARB)(GLenum target, GLfloat x, GLfloat y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, x, y);
 }
 
 static void GLAPIENTRY
-TAG(Vertex2sv)(const GLshort *v)
+TAG(MultiTexCoord2fvARB)(GLenum target, const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR2F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2FV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(Vertex3dv)(const GLdouble *v)
+TAG(MultiTexCoord3fARB)(GLenum target, GLfloat x, GLfloat y, GLfloat z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(Vertex3iv)(const GLint *v)
+TAG(MultiTexCoord3fvARB)(GLenum target, const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3FV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(Vertex3sv)(const GLshort *v)
+TAG(MultiTexCoord4fARB)(GLenum target, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, x, y, z, w);
 }
 
 static void GLAPIENTRY
-TAG(Vertex4dv)(const GLdouble *v)
+TAG(MultiTexCoord4fvARB)(GLenum target, const GLfloat * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1],
-         (GLfloat) v[2], (GLfloat) v[3]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4FV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(Vertex4iv)(const GLint *v)
+TAG(TexCoordP1ui)(GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1],
-         (GLfloat) v[2], (GLfloat) v[3]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP1ui");
+   ATTR_UI(ctx, 1, type, 0, VBO_ATTRIB_TEX0, coords);
 }
 
 static void GLAPIENTRY
-TAG(Vertex4sv)(const GLshort *v)
+TAG(TexCoordP1uiv)(GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR4F(VBO_ATTRIB_POS, (GLfloat) v[0], (GLfloat) v[1],
-         (GLfloat) v[2], (GLfloat) v[3]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP1uiv");
+   ATTR_UI(ctx, 1, type, 0, VBO_ATTRIB_TEX0, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1d)(GLenum target, GLdouble s)
+TAG(TexCoordP2ui)(GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, (GLfloat) s);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP2ui");
+   ATTR_UI(ctx, 2, type, 0, VBO_ATTRIB_TEX0, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1dv)(GLenum target, const GLdouble *v)
+TAG(TexCoordP2uiv)(GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, (GLfloat) v[0]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP2uiv");
+   ATTR_UI(ctx, 2, type, 0, VBO_ATTRIB_TEX0, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1i)(GLenum target, GLint s)
+TAG(TexCoordP3ui)(GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, (GLfloat) s);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP3ui");
+   ATTR_UI(ctx, 3, type, 0, VBO_ATTRIB_TEX0, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1iv)(GLenum target, const GLint *v)
+TAG(TexCoordP3uiv)(GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, (GLfloat) v[0]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP3uiv");
+   ATTR_UI(ctx, 3, type, 0, VBO_ATTRIB_TEX0, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1s)(GLenum target, GLshort s)
+TAG(TexCoordP4ui)(GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, (GLfloat) s);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP4ui");
+   ATTR_UI(ctx, 4, type, 0, VBO_ATTRIB_TEX0, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord1sv)(GLenum target, const GLshort *v)
+TAG(TexCoordP4uiv)(GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR1F(attr, (GLfloat) v[0]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glTexCoordP4uiv");
+   ATTR_UI(ctx, 4, type, 0, VBO_ATTRIB_TEX0, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2d)(GLenum target, GLdouble s, GLdouble t)
+TAG(MultiTexCoordP1ui)(GLenum target, GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, (GLfloat) s, (GLfloat) t);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP1ui");
+   ATTR_UI(ctx, 1, type, 0, attr, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2dv)(GLenum target, const GLdouble *v)
+TAG(MultiTexCoordP1uiv)(GLenum target, GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, (GLfloat) v[0], (GLfloat) v[1]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP1uiv");
+   ATTR_UI(ctx, 1, type, 0, attr, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2i)(GLenum target, GLint s, GLint t)
+TAG(MultiTexCoordP2ui)(GLenum target, GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, (GLfloat) s, (GLfloat) t);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP2ui");
+   ATTR_UI(ctx, 2, type, 0, attr, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2iv)(GLenum target, const GLint *v)
+TAG(MultiTexCoordP2uiv)(GLenum target, GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, (GLfloat) v[0], (GLfloat) v[1]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP2uiv");
+   ATTR_UI(ctx, 2, type, 0, attr, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2s)(GLenum target, GLshort s, GLshort t)
+TAG(MultiTexCoordP3ui)(GLenum target, GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, (GLfloat) s, (GLfloat) t);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP3ui");
+   ATTR_UI(ctx, 3, type, 0, attr, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord2sv)(GLenum target, const GLshort *v)
+TAG(MultiTexCoordP3uiv)(GLenum target, GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR2F(attr, (GLfloat) v[0], (GLfloat) v[1]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP3uiv");
+   ATTR_UI(ctx, 3, type, 0, attr, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3d)(GLenum target, GLdouble s, GLdouble t, GLdouble r)
+TAG(MultiTexCoordP4ui)(GLenum target, GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP4ui");
+   ATTR_UI(ctx, 4, type, 0, attr, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3dv)(GLenum target, const GLdouble *v)
+TAG(MultiTexCoordP4uiv)(GLenum target, GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
    GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glMultiTexCoordP4uiv");
+   ATTR_UI(ctx, 4, type, 0, attr, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3i)(GLenum target, GLint s, GLint t, GLint r)
+TAG(NormalP3ui)(GLenum type, GLuint coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glNormalP3ui");
+   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_NORMAL, coords);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3iv)(GLenum target, const GLint *v)
+TAG(NormalP3uiv)(GLenum type, const GLuint *coords)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glNormalP3uiv");
+   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_NORMAL, coords[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3s)(GLenum target, GLshort s, GLshort t, GLshort r)
+TAG(ColorP3ui)(GLenum type, GLuint color)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP3ui");
+   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR0, color);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord3sv)(GLenum target, const GLshort *v)
+TAG(ColorP3uiv)(GLenum type, const GLuint *color)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR3F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP3uiv");
+   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR0, color[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4d)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+TAG(ColorP4ui)(GLenum type, GLuint color)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP4ui");
+   ATTR_UI(ctx, 4, type, 1, VBO_ATTRIB_COLOR0, color);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4dv)(GLenum target, const GLdouble *v)
+TAG(ColorP4uiv)(GLenum type, const GLuint *color)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glColorP4uiv");
+   ATTR_UI(ctx, 4, type, 1, VBO_ATTRIB_COLOR0, color[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4i)(GLenum target, GLint s, GLint t, GLint r, GLint q)
+TAG(SecondaryColorP3ui)(GLenum type, GLuint color)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glSecondaryColorP3ui");
+   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR1, color);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4iv)(GLenum target, const GLint *v)
+TAG(SecondaryColorP3uiv)(GLenum type, const GLuint *color)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glSecondaryColorP3uiv");
+   ATTR_UI(ctx, 3, type, 1, VBO_ATTRIB_COLOR1, color[0]);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4s)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
+TAG(Normal3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
+   ATTR3H(VBO_ATTRIB_NORMAL, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(MultiTexCoord4sv)(GLenum target, const GLshort *v)
+TAG(Normal3hvNV)(const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
-   ATTR4F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+   ATTR3HV(VBO_ATTRIB_NORMAL, v);
 }
 
 
+
 static void GLAPIENTRY
-TAG(EvalCoord2dv)(const GLdouble *u)
+TAG(Color3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
 {
-   TAG(EvalCoord2f)((GLfloat) u[0], (GLfloat) u[1]);
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3H(VBO_ATTRIB_COLOR0, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(EvalCoord2d)(GLdouble u, GLdouble v)
+TAG(Color3hvNV)(const GLhalfNV * v)
 {
-   TAG(EvalCoord2f)((GLfloat) u, (GLfloat) v);
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3HV(VBO_ATTRIB_COLOR0, v);
 }
 
 static void GLAPIENTRY
-TAG(EvalCoord1dv)(const GLdouble *u)
+TAG(Color4hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
 {
-   TAG(EvalCoord1f)((GLfloat) *u);
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4H(VBO_ATTRIB_COLOR0, x, y, z, w);
 }
 
 static void GLAPIENTRY
-TAG(EvalCoord1d)(GLdouble u)
+TAG(Color4hvNV)(const GLhalfNV * v)
 {
-   TAG(EvalCoord1f)((GLfloat) u);
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4HV(VBO_ATTRIB_COLOR0, v);
 }
 
 
-static void GLAPIENTRY
-TAG(Materialf)(GLenum face, GLenum pname, GLfloat param)
-{
-   GLfloat fparam[4];
-   fparam[0] = param;
-   TAG(Materialfv)(face, pname, fparam);
-}
 
 static void GLAPIENTRY
-TAG(Materiali)(GLenum face, GLenum pname, GLint param)
+TAG(TexCoord1hNV)(GLhalfNV x)
 {
-   GLfloat p[4];
-   p[0] = (GLfloat) param;
-   TAG(Materialfv)(face, pname, p);
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR1H(VBO_ATTRIB_TEX0, x);
 }
 
 static void GLAPIENTRY
-TAG(Materialiv)(GLenum face, GLenum pname, const GLint *params)
+TAG(TexCoord1hvNV)(const GLhalfNV * v)
 {
-   GLfloat fparam[4];
-   switch (pname) {
-   case GL_AMBIENT:
-   case GL_DIFFUSE:
-   case GL_SPECULAR:
-   case GL_EMISSION:
-   case GL_AMBIENT_AND_DIFFUSE:
-      fparam[0] = INT_TO_FLOAT(params[0]);
-      fparam[1] = INT_TO_FLOAT(params[1]);
-      fparam[2] = INT_TO_FLOAT(params[2]);
-      fparam[3] = INT_TO_FLOAT(params[3]);
-      break;
-   case GL_SHININESS:
-      fparam[0] = (GLfloat) params[0];
-      break;
-   case GL_COLOR_INDEXES:
-      fparam[0] = (GLfloat) params[0];
-      fparam[1] = (GLfloat) params[1];
-      fparam[2] = (GLfloat) params[2];
-      break;
-   default:
-      ;
-   }
-   TAG(Materialfv)(face, pname, fparam);
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR1HV(VBO_ATTRIB_TEX0, v);
 }
 
-
 static void GLAPIENTRY
-TAG(SecondaryColor3b)(GLbyte red, GLbyte green, GLbyte blue)
+TAG(TexCoord2hNV)(GLhalfNV x, GLhalfNV y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, BYTE_TO_FLOAT(red),
-          BYTE_TO_FLOAT(green),
-          BYTE_TO_FLOAT(blue));
+   ATTR2H(VBO_ATTRIB_TEX0, x, y);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3d)(GLdouble red, GLdouble green, GLdouble blue)
+TAG(TexCoord2hvNV)(const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, (GLfloat) red, (GLfloat) green, (GLfloat) blue);
+   ATTR2HV(VBO_ATTRIB_TEX0, v);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3i)(GLint red, GLint green, GLint blue)
+TAG(TexCoord3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, INT_TO_FLOAT(red),
-          INT_TO_FLOAT(green),
-          INT_TO_FLOAT(blue));
+   ATTR3H(VBO_ATTRIB_TEX0, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3s)(GLshort red, GLshort green, GLshort blue)
+TAG(TexCoord3hvNV)(const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, SHORT_TO_FLOAT(red),
-          SHORT_TO_FLOAT(green),
-          SHORT_TO_FLOAT(blue));
+   ATTR3HV(VBO_ATTRIB_TEX0, v);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3ui)(GLuint red, GLuint green, GLuint blue)
+TAG(TexCoord4hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, UINT_TO_FLOAT(red),
-          UINT_TO_FLOAT(green),
-          UINT_TO_FLOAT(blue));
+   ATTR4H(VBO_ATTRIB_TEX0, x, y, z, w);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3us)(GLushort red, GLushort green, GLushort blue)
+TAG(TexCoord4hvNV)(const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, USHORT_TO_FLOAT(red),
-          USHORT_TO_FLOAT(green),
-          USHORT_TO_FLOAT(blue));
+   ATTR4HV(VBO_ATTRIB_TEX0, v);
 }
 
+
+
 static void GLAPIENTRY
-TAG(SecondaryColor3ub)(GLubyte red, GLubyte green, GLubyte blue)
+TAG(MultiTexCoord1hNV)(GLenum target, GLhalfNV x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, UBYTE_TO_FLOAT(red),
-          UBYTE_TO_FLOAT(green),
-          UBYTE_TO_FLOAT(blue));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1H(attr, x);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3bv)(const GLbyte *v)
+TAG(MultiTexCoord1hvNV)(GLenum target, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, BYTE_TO_FLOAT(v[0]),
-         BYTE_TO_FLOAT(v[1]),
-         BYTE_TO_FLOAT(v[2]));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1HV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3dv)(const GLdouble *v)
+TAG(MultiTexCoord2hNV)(GLenum target, GLhalfNV x, GLhalfNV y)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2H(attr, x, y);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3iv)(const GLint *v)
+TAG(MultiTexCoord2hvNV)(GLenum target, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, INT_TO_FLOAT(v[0]),
-         INT_TO_FLOAT(v[1]),
-         INT_TO_FLOAT(v[2]));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2HV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3sv)(const GLshort *v)
+TAG(MultiTexCoord3hNV)(GLenum target, GLhalfNV x, GLhalfNV y, GLhalfNV z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, SHORT_TO_FLOAT(v[0]),
-         SHORT_TO_FLOAT(v[1]),
-         SHORT_TO_FLOAT(v[2]));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3H(attr, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3uiv)(const GLuint *v)
+TAG(MultiTexCoord3hvNV)(GLenum target, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, UINT_TO_FLOAT(v[0]),
-         UINT_TO_FLOAT(v[1]),
-         UINT_TO_FLOAT(v[2]));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3HV(attr, v);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3usv)(const GLushort *v)
+TAG(MultiTexCoord4hNV)(GLenum target, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, USHORT_TO_FLOAT(v[0]),
-         USHORT_TO_FLOAT(v[1]),
-         USHORT_TO_FLOAT(v[2]));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4H(attr, x, y, z, w);
 }
 
 static void GLAPIENTRY
-TAG(SecondaryColor3ubv)(const GLubyte *v)
+TAG(MultiTexCoord4hvNV)(GLenum target, const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ATTR3F(VBO_ATTRIB_COLOR1, UBYTE_TO_FLOAT(v[0]),
-         UBYTE_TO_FLOAT(v[1]),
-         UBYTE_TO_FLOAT(v[2]));
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4HV(attr, v);
 }
 
 
-/*
- * GL_NV_vertex_program:
- * Note that attribute indexes DO alias conventional vertex attributes.
- */
-
 static void GLAPIENTRY
-TAG(VertexAttrib1sNV)(GLuint index, GLshort x)
+TAG(FogCoordhNV)(GLhalf x)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) x);
+   ATTR1H(VBO_ATTRIB_FOG, x);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1dNV)(GLuint index, GLdouble x)
+TAG(FogCoordhvNV)(const GLhalf * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) x);
+   ATTR1HV(VBO_ATTRIB_FOG, v);
 }
 
+
+
 static void GLAPIENTRY
-TAG(VertexAttrib2sNV)(GLuint index, GLshort x, GLshort y)
+TAG(SecondaryColor3hNV)(GLhalfNV x, GLhalfNV y, GLhalfNV z)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) x, y);
+   ATTR3H(VBO_ATTRIB_COLOR1, x, y, z);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib2dNV)(GLuint index, GLdouble x, GLdouble y)
+TAG(SecondaryColor3hvNV)(const GLhalfNV * v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) x, (GLfloat) y);
+   ATTR3HV(VBO_ATTRIB_COLOR1, v);
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttrib3sNV)(GLuint index, GLshort x, GLshort y, GLshort z)
+TAG(Color3b)(GLbyte red, GLbyte green, GLbyte blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR3F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
+   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(red),
+          BYTE_TO_FLOAT(green),
+          BYTE_TO_FLOAT(blue),
+          1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
+TAG(Color3d)(GLdouble red, GLdouble green, GLdouble blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z, 1.0F);
+   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) red, (GLfloat) green, (GLfloat) blue, 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4sNV)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
+TAG(Color3i)(GLint red, GLint green, GLint blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(red), INT_TO_FLOAT(green),
+          INT_TO_FLOAT(blue), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+TAG(Color3s)(GLshort red, GLshort green, GLshort blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
+   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(red), SHORT_TO_FLOAT(green),
+          SHORT_TO_FLOAT(blue), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4ubNV)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
+TAG(Color3ui)(GLuint red, GLuint green, GLuint blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, UBYTE_TO_FLOAT(x), UBYTE_TO_FLOAT(y),
-                                      UBYTE_TO_FLOAT(z), UBYTE_TO_FLOAT(w));
+   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(red), UINT_TO_FLOAT(green),
+          UINT_TO_FLOAT(blue), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1svNV)(GLuint index, const GLshort *v)
+TAG(Color3us)(GLushort red, GLushort green, GLushort blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) v[0]);
+   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(red), USHORT_TO_FLOAT(green),
+          USHORT_TO_FLOAT(blue), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1dvNV)(GLuint index, const GLdouble *v)
+TAG(Color3ub)(GLubyte red, GLubyte green, GLubyte blue)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR1F(index, (GLfloat) v[0]);
+   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(red), UBYTE_TO_FLOAT(green),
+          UBYTE_TO_FLOAT(blue), 1.0);
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttrib2svNV)(GLuint index, const GLshort *v)
+TAG(Color3bv)(const GLbyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) v[0], (GLfloat) v[1]);
+   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]),
+         BYTE_TO_FLOAT(v[2]), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib2dvNV)(GLuint index, const GLdouble *v)
+TAG(Color3dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR2F(index, (GLfloat) v[0], (GLfloat) v[1]);
+   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3svNV)(GLuint index, const GLshort *v)
+TAG(Color3iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR3F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]),
+         INT_TO_FLOAT(v[2]), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3dvNV)(GLuint index, const GLdouble *v)
+TAG(Color3sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR3F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]),
+         SHORT_TO_FLOAT(v[2]), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4svNV)(GLuint index, const GLshort *v)
+TAG(Color3uiv)(const GLuint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2],
-         (GLfloat)v[3]);
+   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]),
+         UINT_TO_FLOAT(v[2]), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4dvNV)(GLuint index, const GLdouble *v)
+TAG(Color3usv)(const GLushort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]),
+         USHORT_TO_FLOAT(v[2]), 1.0);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4ubvNV)(GLuint index, const GLubyte *v)
+TAG(Color3ubv)(const GLubyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (index < VBO_ATTRIB_MAX) ATTR4F(index, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]),
-         UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
+   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]),
+         UBYTE_TO_FLOAT(v[2]), 1.0);
 }
 
 
 static void GLAPIENTRY
-TAG(VertexAttribs1svNV)(GLuint index, GLsizei n, const GLshort *v)
+TAG(Color4b)(GLbyte red, GLbyte green, GLbyte blue,
+              GLbyte alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR1F(index + i, (GLfloat) v[i]);
+   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(red), BYTE_TO_FLOAT(green),
+          BYTE_TO_FLOAT(blue), BYTE_TO_FLOAT(alpha));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs1fvNV)(GLuint index, GLsizei n, const GLfloat *v)
+TAG(Color4d)(GLdouble red, GLdouble green, GLdouble blue,
+              GLdouble alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR1F(index + i, v[i]);
+   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) red, (GLfloat) green, (GLfloat) blue, (GLfloat) alpha);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs1dvNV)(GLuint index, GLsizei n, const GLdouble *v)
+TAG(Color4i)(GLint red, GLint green, GLint blue, GLint alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR1F(index + i, (GLfloat) v[i]);
+   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(red), INT_TO_FLOAT(green),
+          INT_TO_FLOAT(blue), INT_TO_FLOAT(alpha));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs2svNV)(GLuint index, GLsizei n, const GLshort *v)
+TAG(Color4s)(GLshort red, GLshort green, GLshort blue,
+              GLshort alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR2F(index + i, (GLfloat) v[2 * i], (GLfloat) v[2 * i + 1]);
+   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(red), SHORT_TO_FLOAT(green),
+          SHORT_TO_FLOAT(blue), SHORT_TO_FLOAT(alpha));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs2fvNV)(GLuint index, GLsizei n, const GLfloat *v)
+TAG(Color4ui)(GLuint red, GLuint green, GLuint blue, GLuint alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR2F(index + i, v[2 * i], v[2 * i + 1]);
+   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(red), UINT_TO_FLOAT(green),
+          UINT_TO_FLOAT(blue), UINT_TO_FLOAT(alpha));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs2dvNV)(GLuint index, GLsizei n, const GLdouble *v)
+TAG(Color4us)(GLushort red, GLushort green, GLushort blue, GLushort alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR2F(index + i, (GLfloat) v[2 * i], (GLfloat) v[2 * i + 1]);
+   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(red), USHORT_TO_FLOAT(green),
+          USHORT_TO_FLOAT(blue), USHORT_TO_FLOAT(alpha));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs3svNV)(GLuint index, GLsizei n, const GLshort *v)
+TAG(Color4ub)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR3F(index + i, (GLfloat) v[3 * i], (GLfloat) v[3 * i + 1], (GLfloat) v[3 * i + 2]);
+   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(red), UBYTE_TO_FLOAT(green),
+          UBYTE_TO_FLOAT(blue), UBYTE_TO_FLOAT(alpha));
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttribs3fvNV)(GLuint index, GLsizei n, const GLfloat *v)
+TAG(Color4iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR3F(index + i, v[3 * i], v[3 * i + 1], v[3 * i + 2]);
+   ATTR4F(VBO_ATTRIB_COLOR0, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]),
+         INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]));
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttribs3dvNV)(GLuint index, GLsizei n, const GLdouble *v)
+TAG(Color4bv)(const GLbyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR3F(index + i, (GLfloat) v[3 * i], (GLfloat) v[3 * i + 1], (GLfloat) v[3 * i + 2]);
+   ATTR4F(VBO_ATTRIB_COLOR0, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]),
+         BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs4svNV)(GLuint index, GLsizei n, const GLshort *v)
+TAG(Color4dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR4F(index + i, (GLfloat) v[4 * i], (GLfloat) v[4 * i + 1], (GLfloat) v[4 * i + 2], (GLfloat) v[4 * i + 3]);
+   ATTR4F(VBO_ATTRIB_COLOR0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttribs4fvNV)(GLuint index, GLsizei n, const GLfloat *v)
+TAG(Color4sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR4F(index + i, v[4 * i], v[4 * i + 1], v[4 * i + 2], v[4 * i + 3]);
+   ATTR4F(VBO_ATTRIB_COLOR0, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]),
+         SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]));
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttribs4dvNV)(GLuint index, GLsizei n, const GLdouble *v)
+TAG(Color4uiv)(const GLuint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR4F(index + i, (GLfloat) v[4 * i], (GLfloat) v[4 * i + 1], (GLfloat) v[4 * i + 2], (GLfloat) v[4 * i + 3]);
+   ATTR4F(VBO_ATTRIB_COLOR0, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]),
+         UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribs4ubvNV)(GLuint index, GLsizei n, const GLubyte *v)
+TAG(Color4usv)(const GLushort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLint i;
-   n = MIN2(n, VBO_ATTRIB_MAX - index);
-   for (i = n - 1; i >= 0; i--)
-      ATTR4F(index + i, UBYTE_TO_FLOAT(v[4 * i]), UBYTE_TO_FLOAT(v[4 * i + 1]),
-             UBYTE_TO_FLOAT(v[4 * i + 2]), UBYTE_TO_FLOAT(v[4 * i + 3]));
+   ATTR4F(VBO_ATTRIB_COLOR0, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]),
+         USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]));
 }
 
+static void GLAPIENTRY
+TAG(Color4ubv)(const GLubyte *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_COLOR0, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]),
+         UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
+}
 
-/*
- * GL_ARB_vertex_program
- * Note that attribute indexes do NOT alias conventional attributes.
- */
 
 static void GLAPIENTRY
-TAG(VertexAttrib1s)(GLuint index, GLshort x)
+TAG(FogCoordd)(GLdouble d)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1F(0, (GLfloat) x);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_FOG, (GLfloat) d);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1d)(GLuint index, GLdouble x)
+TAG(FogCoorddv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1F(0, (GLfloat) x);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_FOG, (GLfloat) *v);
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttrib2s)(GLuint index, GLshort x, GLshort y)
+TAG(Indexd)(GLdouble c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR2F(0, (GLfloat) x, (GLfloat) y);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib2d)(GLuint index, GLdouble x, GLdouble y)
+TAG(Indexi)(GLint c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR2F(0, (GLfloat) x, (GLfloat) y);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3s)(GLuint index, GLshort x, GLshort y, GLshort z)
+TAG(Indexs)(GLshort c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR3F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3d)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
+TAG(Indexub)(GLubyte c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR3F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4s)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
+TAG(Indexdv)(const GLdouble *c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4d)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+TAG(Indexiv)(const GLint *c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) x, (GLfloat) y, (GLfloat) z, (GLfloat) w);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1sv)(GLuint index, const GLshort *v)
+TAG(Indexsv)(const GLshort *c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1F(0, (GLfloat) v[0]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib1dv)(GLuint index, const GLdouble *v)
+TAG(Indexubv)(const GLubyte *c)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1F(0, (GLfloat) v[0]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_COLOR_INDEX, (GLfloat) *c);
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttrib2sv)(GLuint index, const GLshort *v)
+TAG(EdgeFlagv)(const GLboolean *flag)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR2F(0, (GLfloat) v[0], (GLfloat) v[1]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_EDGEFLAG, (GLfloat)*flag);
 }
 
+
 static void GLAPIENTRY
-TAG(VertexAttrib2dv)(GLuint index, const GLdouble *v)
+TAG(Normal3b)(GLbyte nx, GLbyte ny, GLbyte nz)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR2F(0, (GLfloat) v[0], (GLfloat) v[1]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR2F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, BYTE_TO_FLOAT(nx), BYTE_TO_FLOAT(ny), BYTE_TO_FLOAT(nz));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3sv)(GLuint index, const GLshort *v)
+TAG(Normal3d)(GLdouble nx, GLdouble ny, GLdouble nz)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR3F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, (GLfloat) nx, (GLfloat) ny, (GLfloat) nz);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib3dv)(GLuint index, const GLdouble *v)
+TAG(Normal3i)(GLint nx, GLint ny, GLint nz)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR3F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR3F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, INT_TO_FLOAT(nx), INT_TO_FLOAT(ny), INT_TO_FLOAT(nz));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4sv)(GLuint index, const GLshort *v)
+TAG(Normal3s)(GLshort nx, GLshort ny, GLshort nz)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, SHORT_TO_FLOAT(nx), SHORT_TO_FLOAT(ny), SHORT_TO_FLOAT(nz));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4dv)(GLuint index, const GLdouble *v)
+TAG(Normal3bv)(const GLbyte *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4bv)(GLuint index, const GLbyte * v)
+TAG(Normal3dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4iv)(GLuint index, const GLint * v)
+TAG(Normal3iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4ubv)(GLuint index, const GLubyte * v)
+TAG(Normal3sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_NORMAL, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]));
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4usv)(GLuint index, const GLushort * v)
+TAG(TexCoord1d)(GLdouble s)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) s);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4uiv)(GLuint index, const GLuint * v)
+TAG(TexCoord1i)(GLint s)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat)v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) s);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Nbv)(GLuint index, const GLbyte * v)
+TAG(TexCoord1s)(GLshort s)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, BYTE_TO_FLOAT(v[0]), BYTE_TO_FLOAT(v[1]), BYTE_TO_FLOAT(v[2]), BYTE_TO_FLOAT(v[3]));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) s);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Nsv)(GLuint index, const GLshort * v)
+TAG(TexCoord2d)(GLdouble s, GLdouble t)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, SHORT_TO_FLOAT(v[0]), SHORT_TO_FLOAT(v[1]), SHORT_TO_FLOAT(v[2]), SHORT_TO_FLOAT(v[3]));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Niv)(GLuint index, const GLint * v)
+TAG(TexCoord2s)(GLshort s, GLshort t)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, INT_TO_FLOAT(v[0]), INT_TO_FLOAT(v[1]), INT_TO_FLOAT(v[2]), INT_TO_FLOAT(v[3]));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Nub)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
+TAG(TexCoord2i)(GLint s, GLint t)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, UBYTE_TO_FLOAT(x), UBYTE_TO_FLOAT(y), UBYTE_TO_FLOAT(z), UBYTE_TO_FLOAT(w));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, UBYTE_TO_FLOAT(x), UBYTE_TO_FLOAT(y), UBYTE_TO_FLOAT(z), UBYTE_TO_FLOAT(w));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Nubv)(GLuint index, const GLubyte * v)
+TAG(TexCoord3d)(GLdouble s, GLdouble t, GLdouble r)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]), UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, UBYTE_TO_FLOAT(v[0]), UBYTE_TO_FLOAT(v[1]), UBYTE_TO_FLOAT(v[2]), UBYTE_TO_FLOAT(v[3]));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Nusv)(GLuint index, const GLushort * v)
+TAG(TexCoord3i)(GLint s, GLint t, GLint r)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]), USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, USHORT_TO_FLOAT(v[0]), USHORT_TO_FLOAT(v[1]), USHORT_TO_FLOAT(v[2]), USHORT_TO_FLOAT(v[3]));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttrib4Nuiv)(GLuint index, const GLuint * v)
+TAG(TexCoord3s)(GLshort s, GLshort t, GLshort r)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4F(0, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]), UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]));
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4F(VBO_ATTRIB_GENERIC0 + index, UINT_TO_FLOAT(v[0]), UINT_TO_FLOAT(v[1]), UINT_TO_FLOAT(v[2]), UINT_TO_FLOAT(v[3]));
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r);
 }
 
+static void GLAPIENTRY
+TAG(TexCoord4d)(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r,(GLfloat) q);
+}
 
+static void GLAPIENTRY
+TAG(TexCoord4i)(GLint s, GLint t, GLint r, GLint q)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r,(GLfloat) q);
+}
 
-/**
- * GL_EXT_gpu_shader / GL 3.0 signed/unsigned integer-valued attributes.
- * Note that attribute indexes do NOT alias conventional attributes.
- */
+static void GLAPIENTRY
+TAG(TexCoord4s)(GLshort s, GLshort t, GLshort r, GLshort q)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) s,(GLfloat) t,(GLfloat) r,(GLfloat) q);
+}
 
 static void GLAPIENTRY
-TAG(VertexAttribI1iv)(GLuint index, const GLint *v)
+TAG(TexCoord1dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1I(0, v[0]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1I(VBO_ATTRIB_GENERIC0 + index, v[0]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) v[0]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribI1uiv)(GLuint index, const GLuint *v)
+TAG(TexCoord1iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR1UI(0, v[0]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR1UI(VBO_ATTRIB_GENERIC0 + index, v[0]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) v[0]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribI4bv)(GLuint index, const GLbyte *v)
+TAG(TexCoord1sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4I(0, v[0], v[1], v[2], v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4I(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR1F(VBO_ATTRIB_TEX0, (GLfloat) v[0]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribI4sv)(GLuint index, const GLshort *v)
+TAG(TexCoord2dv)(const GLdouble *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4I(0, v[0], v[1], v[2], v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4I(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribI4ubv)(GLuint index, const GLubyte *v)
+TAG(TexCoord2iv)(const GLint *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4UI(0, v[0], v[1], v[2], v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4UI(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1]);
 }
 
 static void GLAPIENTRY
-TAG(VertexAttribI4usv)(GLuint index, const GLushort *v)
+TAG(TexCoord2sv)(const GLshort *v)
 {
    GET_CURRENT_CONTEXT(ctx);
-   if (is_vertex_position(ctx, index))
-      ATTR4UI(0, v[0], v[1], v[2], v[3]);
-   else if (index < MAX_VERTEX_GENERIC_ATTRIBS)
-      ATTR4UI(VBO_ATTRIB_GENERIC0 + index, v[0], v[1], v[2], v[3]);
-   else
-      ERROR(GL_INVALID_VALUE);
+   ATTR2F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1]);
+}
+
+static void GLAPIENTRY
+TAG(TexCoord3dv)(const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(TexCoord3iv)(const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(TexCoord3sv)(const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(TexCoord4dv)(const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2],(GLfloat) v[3]);
+}
+
+static void GLAPIENTRY
+TAG(TexCoord4iv)(const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2],(GLfloat) v[3]);
+}
+
+static void GLAPIENTRY
+TAG(TexCoord4sv)(const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR4F(VBO_ATTRIB_TEX0, (GLfloat) v[0],(GLfloat) v[1],(GLfloat) v[2],(GLfloat) v[3]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord1d)(GLenum target, GLdouble s)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, (GLfloat) s);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord1dv)(GLenum target, const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, (GLfloat) v[0]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord1i)(GLenum target, GLint s)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, (GLfloat) s);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord1iv)(GLenum target, const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, (GLfloat) v[0]);
 }
 
+static void GLAPIENTRY
+TAG(MultiTexCoord1s)(GLenum target, GLshort s)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, (GLfloat) s);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord1sv)(GLenum target, const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR1F(attr, (GLfloat) v[0]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord2d)(GLenum target, GLdouble s, GLdouble t)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, (GLfloat) s, (GLfloat) t);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord2dv)(GLenum target, const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, (GLfloat) v[0], (GLfloat) v[1]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord2i)(GLenum target, GLint s, GLint t)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, (GLfloat) s, (GLfloat) t);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord2iv)(GLenum target, const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, (GLfloat) v[0], (GLfloat) v[1]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord2s)(GLenum target, GLshort s, GLshort t)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, (GLfloat) s, (GLfloat) t);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord2sv)(GLenum target, const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR2F(attr, (GLfloat) v[0], (GLfloat) v[1]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord3d)(GLenum target, GLdouble s, GLdouble t, GLdouble r)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord3dv)(GLenum target, const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord3i)(GLenum target, GLint s, GLint t, GLint r)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord3iv)(GLenum target, const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord3s)(GLenum target, GLshort s, GLshort t, GLshort r)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord3sv)(GLenum target, const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR3F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord4d)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord4dv)(GLenum target, const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord4i)(GLenum target, GLint s, GLint t, GLint r, GLint q)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord4iv)(GLenum target, const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord4s)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, (GLfloat) s, (GLfloat) t, (GLfloat) r, (GLfloat) q);
+}
+
+static void GLAPIENTRY
+TAG(MultiTexCoord4sv)(GLenum target, const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   GLuint attr = (target & 0x7) + VBO_ATTRIB_TEX0;
+   ATTR4F(attr, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2], (GLfloat) v[3]);
+}
+
+
+static void GLAPIENTRY
+TAG(EvalCoord2dv)(const GLdouble *u)
+{
+   TAG(EvalCoord2f)((GLfloat) u[0], (GLfloat) u[1]);
+}
+
+static void GLAPIENTRY
+TAG(EvalCoord2d)(GLdouble u, GLdouble v)
+{
+   TAG(EvalCoord2f)((GLfloat) u, (GLfloat) v);
+}
+
+static void GLAPIENTRY
+TAG(EvalCoord1dv)(const GLdouble *u)
+{
+   TAG(EvalCoord1f)((GLfloat) *u);
+}
+
+static void GLAPIENTRY
+TAG(EvalCoord1d)(GLdouble u)
+{
+   TAG(EvalCoord1f)((GLfloat) u);
+}
+
+
+static void GLAPIENTRY
+TAG(Materialf)(GLenum face, GLenum pname, GLfloat param)
+{
+   GLfloat fparam[4];
+   fparam[0] = param;
+   TAG(Materialfv)(face, pname, fparam);
+}
+
+static void GLAPIENTRY
+TAG(Materiali)(GLenum face, GLenum pname, GLint param)
+{
+   GLfloat p[4];
+   p[0] = (GLfloat) param;
+   TAG(Materialfv)(face, pname, p);
+}
+
+static void GLAPIENTRY
+TAG(Materialiv)(GLenum face, GLenum pname, const GLint *params)
+{
+   GLfloat fparam[4];
+   switch (pname) {
+   case GL_AMBIENT:
+   case GL_DIFFUSE:
+   case GL_SPECULAR:
+   case GL_EMISSION:
+   case GL_AMBIENT_AND_DIFFUSE:
+      fparam[0] = INT_TO_FLOAT(params[0]);
+      fparam[1] = INT_TO_FLOAT(params[1]);
+      fparam[2] = INT_TO_FLOAT(params[2]);
+      fparam[3] = INT_TO_FLOAT(params[3]);
+      break;
+   case GL_SHININESS:
+      fparam[0] = (GLfloat) params[0];
+      break;
+   case GL_COLOR_INDEXES:
+      fparam[0] = (GLfloat) params[0];
+      fparam[1] = (GLfloat) params[1];
+      fparam[2] = (GLfloat) params[2];
+      break;
+   default:
+      ;
+   }
+   TAG(Materialfv)(face, pname, fparam);
+}
+
+
+static void GLAPIENTRY
+TAG(SecondaryColor3b)(GLbyte red, GLbyte green, GLbyte blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, BYTE_TO_FLOAT(red),
+          BYTE_TO_FLOAT(green),
+          BYTE_TO_FLOAT(blue));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3d)(GLdouble red, GLdouble green, GLdouble blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, (GLfloat) red, (GLfloat) green, (GLfloat) blue);
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3i)(GLint red, GLint green, GLint blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, INT_TO_FLOAT(red),
+          INT_TO_FLOAT(green),
+          INT_TO_FLOAT(blue));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3s)(GLshort red, GLshort green, GLshort blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, SHORT_TO_FLOAT(red),
+          SHORT_TO_FLOAT(green),
+          SHORT_TO_FLOAT(blue));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3ui)(GLuint red, GLuint green, GLuint blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, UINT_TO_FLOAT(red),
+          UINT_TO_FLOAT(green),
+          UINT_TO_FLOAT(blue));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3us)(GLushort red, GLushort green, GLushort blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, USHORT_TO_FLOAT(red),
+          USHORT_TO_FLOAT(green),
+          USHORT_TO_FLOAT(blue));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3ub)(GLubyte red, GLubyte green, GLubyte blue)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, UBYTE_TO_FLOAT(red),
+          UBYTE_TO_FLOAT(green),
+          UBYTE_TO_FLOAT(blue));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3bv)(const GLbyte *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, BYTE_TO_FLOAT(v[0]),
+         BYTE_TO_FLOAT(v[1]),
+         BYTE_TO_FLOAT(v[2]));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3dv)(const GLdouble *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, (GLfloat) v[0], (GLfloat) v[1], (GLfloat) v[2]);
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3iv)(const GLint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, INT_TO_FLOAT(v[0]),
+         INT_TO_FLOAT(v[1]),
+         INT_TO_FLOAT(v[2]));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3sv)(const GLshort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, SHORT_TO_FLOAT(v[0]),
+         SHORT_TO_FLOAT(v[1]),
+         SHORT_TO_FLOAT(v[2]));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3uiv)(const GLuint *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, UINT_TO_FLOAT(v[0]),
+         UINT_TO_FLOAT(v[1]),
+         UINT_TO_FLOAT(v[2]));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3usv)(const GLushort *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, USHORT_TO_FLOAT(v[0]),
+         USHORT_TO_FLOAT(v[1]),
+         USHORT_TO_FLOAT(v[2]));
+}
+
+static void GLAPIENTRY
+TAG(SecondaryColor3ubv)(const GLubyte *v)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ATTR3F(VBO_ATTRIB_COLOR1, UBYTE_TO_FLOAT(v[0]),
+         UBYTE_TO_FLOAT(v[1]),
+         UBYTE_TO_FLOAT(v[2]));
+}
+
+#endif /* HW_SELECT_MODE */
+
 #undef ATTR1FV
 #undef ATTR2FV
 #undef ATTR3FV
-- 
GitLab


From f03b8d03b8f6037a151e81a196567ef43f4e7fd5 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 13 May 2022 21:11:47 +0800
Subject: [PATCH 09/16] mapi: add api setup header for hw select mode
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by GL_SELECT mode dispatch table setup.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mapi/glapi/gen/api_hw_select_init_h.py | 53 ++++++++++++++++++++++
 src/mapi/glapi/gen/meson.build             |  9 ++++
 src/mesa/meson.build                       |  1 +
 3 files changed, 63 insertions(+)
 create mode 100644 src/mapi/glapi/gen/api_hw_select_init_h.py

diff --git a/src/mapi/glapi/gen/api_hw_select_init_h.py b/src/mapi/glapi/gen/api_hw_select_init_h.py
new file mode 100644
index 000000000000..ae8cdda2c1cf
--- /dev/null
+++ b/src/mapi/glapi/gen/api_hw_select_init_h.py
@@ -0,0 +1,53 @@
+# Copyright (C) 2012 Intel Corporation
+# Copyright (C) 2021 Advanced Micro Devices, Inc.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice (including the next
+# paragraph) shall be included in all copies or substantial portions of the
+# Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+# IN THE SOFTWARE.
+
+# This script generates the file api_hw_select_init.h.
+
+import argparse
+import collections
+import license
+import gl_XML
+import sys
+import apiexec
+import re
+
+
+class PrintCode(gl_XML.gl_print_base):
+    def __init__(self):
+        super().__init__()
+
+        self.name = 'api_hw_select_init_h.py'
+        self.license = license.bsd_license_template % (
+            'Copyright (C) 2012 Intel Corporation\n'
+            'Copyright (C) 2021 Advanced Micro Devices, Inc.',
+            'AUTHORS')
+
+    def printBody(self, api):
+        for f in api.functionIterateAll():
+            if f.exec_flavor != 'vtxfmt':
+                continue
+
+            if (re.match('Vertex*', f.name)):
+                print('SET_{0}(tab, NAME({0}));'.format(f.name))
+
+if __name__ == '__main__':
+    apiexec.print_glapi_file(PrintCode())
diff --git a/src/mapi/glapi/gen/meson.build b/src/mapi/glapi/gen/meson.build
index 1b807585d1a3..e43f04d72812 100644
--- a/src/mapi/glapi/gen/meson.build
+++ b/src/mapi/glapi/gen/meson.build
@@ -261,6 +261,15 @@ main_api_vtxfmt_init_h = custom_target(
   capture : true,
 )
 
+main_api_hw_select_init_h = custom_target(
+  'api_hw_select_init.h',
+  input : ['api_hw_select_init_h.py', 'gl_API.xml'],
+  output : 'api_hw_select_init.h',
+  command : [prog_python, '@INPUT0@', '-f', '@INPUT1@'],
+  depend_files : files('apiexec.py') + glapi_gen_depends,
+  capture : true,
+)
+
 main_marshal_generated_c = []
 foreach x : ['0', '1', '2', '3', '4', '5', '6', '7']
   main_marshal_generated_c += custom_target(
diff --git a/src/mesa/meson.build b/src/mesa/meson.build
index 4971e594760c..522a4c2eb11d 100644
--- a/src/mesa/meson.build
+++ b/src/mesa/meson.build
@@ -451,6 +451,7 @@ files_libmesa += [
   main_api_save_h,
   main_api_save_init_h,
   main_api_vtxfmt_init_h,
+  main_api_hw_select_init_h,
   main_enums_c,
   format_fallback_c,
   get_hash_h,
-- 
GitLab


From d092c81ee93a07b20331a576dc1e0583d2fee1b9 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 14 May 2022 11:34:41 +0800
Subject: [PATCH 10/16] mesa: set CurrentServerDispatch too when glBegin/End
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When glthread not enabled, CurrentClientDispatch and CurrentServerDispatch
should be same. This does not cause problems before because OutsideBeginEnd
and BeginEnd have same BeginEnd entries, so when
CurrentServerDispatch==OutsideBeginEnd
CurrentClientDispatch==BeginEnd
will call into same BeginEnd _mesa_* functions.

But we'll add another dispatch table to replace BeginEnd when HW GL_SELECT
mode, so this needs to be fixed. Otherwise some function like _mesa_Rectf
which always call with CurrentServerDispatch will go into wrong entries.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/vbo/vbo_exec_api.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index 83c1a5eea37a..806cd6c60f80 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -850,7 +850,7 @@ _mesa_Begin(GLenum mode)
    if (ctx->GLThread.enabled) {
       ctx->CurrentServerDispatch = ctx->Exec;
    } else if (ctx->CurrentClientDispatch == ctx->OutsideBeginEnd) {
-      ctx->CurrentClientDispatch = ctx->Exec;
+      ctx->CurrentClientDispatch = ctx->CurrentServerDispatch = ctx->Exec;
       _glapi_set_dispatch(ctx->CurrentClientDispatch);
    } else {
       assert(ctx->CurrentClientDispatch == ctx->Save);
@@ -909,7 +909,7 @@ _mesa_End(void)
    if (ctx->GLThread.enabled) {
       ctx->CurrentServerDispatch = ctx->Exec;
    } else if (ctx->CurrentClientDispatch == ctx->BeginEnd) {
-      ctx->CurrentClientDispatch = ctx->Exec;
+      ctx->CurrentClientDispatch = ctx->CurrentServerDispatch = ctx->Exec;
       _glapi_set_dispatch(ctx->CurrentClientDispatch);
    }
 
-- 
GitLab


From 41b90da10cb39dd2af645ad4df64c207822ca26c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 13 May 2022 17:34:14 +0800
Subject: [PATCH 11/16] mesa: add HWSelectModeBeginEnd dispatch table
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used when in glBegin/End section and HW GL_RENDER mode.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/context.c     |  1 +
 src/mesa/main/feedback.c    |  9 +++++++++
 src/mesa/main/mtypes.h      |  5 +++++
 src/mesa/vbo/vbo.h          |  3 +++
 src/mesa/vbo/vbo_exec_api.c | 40 ++++++++++++++++++++++++++++++++++---
 src/mesa/vbo/vbo_noop.c     |  5 +++++
 6 files changed, 60 insertions(+), 3 deletions(-)

diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 1941aaa33d6a..7d496e7bf24b 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1172,6 +1172,7 @@ _mesa_free_context_data(struct gl_context *ctx, bool destroy_debug_output)
    free(ctx->Save);
    free(ctx->ContextLost);
    free(ctx->MarshalExec);
+   free(ctx->HWSelectModeBeginEnd);
 
    /* Shared context state (display lists, textures, etc) */
    _mesa_reference_shared_state(ctx, &ctx->Shared, NULL);
diff --git a/src/mesa/main/feedback.c b/src/mesa/main/feedback.c
index 34e6a82aea6f..e6d925b274d3 100644
--- a/src/mesa/main/feedback.c
+++ b/src/mesa/main/feedback.c
@@ -230,6 +230,15 @@ alloc_select_resource(struct gl_context *ctx)
    if (!ctx->Const.HardwareAcceleratedSelect)
       return;
 
+   if (!ctx->HWSelectModeBeginEnd) {
+      ctx->HWSelectModeBeginEnd = _mesa_alloc_dispatch_table(false);
+      if (!ctx->HWSelectModeBeginEnd) {
+         _mesa_error(ctx, GL_OUT_OF_MEMORY, "Cannot allocate HWSelectModeBeginEnd");
+         return;
+      }
+      vbo_install_hw_select_begin_end(ctx);
+   }
+
    if (!s->SaveBuffer) {
       s->SaveBuffer = malloc(NAME_STACK_BUFFER_SIZE);
       if (!s->SaveBuffer) {
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 5db4417f665b..4fa389d7e004 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3255,6 +3255,11 @@ struct gl_context
     * display list).  Only valid functions between those two are set.
     */
    struct _glapi_table *BeginEnd;
+   /**
+    * Same as BeginEnd except vertex postion set functions. Used when
+    * HW GL_SELECT mode instead of BeginEnd.
+    */
+   struct _glapi_table *HWSelectModeBeginEnd;
    /**
     * Dispatch table for when a graphics reset has happened.
     */
diff --git a/src/mesa/vbo/vbo.h b/src/mesa/vbo/vbo.h
index 2fcbfc577b1c..9e47b49d2160 100644
--- a/src/mesa/vbo/vbo.h
+++ b/src/mesa/vbo/vbo.h
@@ -190,6 +190,9 @@ _vbo_DestroyContext(struct gl_context *ctx);
 void
 vbo_install_exec_vtxfmt(struct gl_context *ctx);
 
+void
+vbo_install_hw_select_begin_end(struct gl_context *ctx);
+
 void
 vbo_install_exec_vtxfmt_noop(struct gl_context *ctx);
 
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index 806cd6c60f80..f7ee3baa49b6 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -477,7 +477,7 @@ is_vertex_position(const struct gl_context *ctx, GLuint index)
  * \param C  cast type (uint32_t or uint64_t)
  * \param V0, V1, v2, V3  attribute value
  */
-#define ATTR_UNION(A, N, T, C, V0, V1, V2, V3)                          \
+#define ATTR_UNION_BASE(A, N, T, C, V0, V1, V2, V3)                     \
 do {                                                                    \
    struct vbo_exec_context *exec = &vbo_context(ctx)->exec;             \
    int sz = (sizeof(C) / sizeof(GLfloat));                              \
@@ -563,6 +563,9 @@ do {                                                                    \
 #define TAG(x) _mesa_##x
 #define SUPPRESS_STATIC
 
+#define ATTR_UNION(A, N, T, C, V0, V1, V2, V3) \
+   ATTR_UNION_BASE(A, N, T, C, V0, V1, V2, V3)
+
 #include "vbo_attrib_tmp.h"
 
 
@@ -842,7 +845,8 @@ _mesa_Begin(GLenum mode)
 
    ctx->Driver.CurrentExecPrimitive = mode;
 
-   ctx->Exec = ctx->BeginEnd;
+   ctx->Exec = _mesa_hw_select_enabled(ctx) ?
+      ctx->HWSelectModeBeginEnd : ctx->BeginEnd;
 
    /* We may have been called from a display list, in which case we should
     * leave dlist.c's dispatch table in place.
@@ -908,7 +912,8 @@ _mesa_End(void)
 
    if (ctx->GLThread.enabled) {
       ctx->CurrentServerDispatch = ctx->Exec;
-   } else if (ctx->CurrentClientDispatch == ctx->BeginEnd) {
+   } else if (ctx->CurrentClientDispatch == ctx->BeginEnd ||
+              ctx->CurrentClientDispatch == ctx->HWSelectModeBeginEnd) {
       ctx->CurrentClientDispatch = ctx->CurrentServerDispatch = ctx->Exec;
       _glapi_set_dispatch(ctx->CurrentClientDispatch);
    }
@@ -1215,3 +1220,32 @@ _es_Materialf(GLenum face, GLenum pname, GLfloat param)
    p[1] = p[2] = p[3] = 0.0F;
    _mesa_Materialfv(face, pname, p);
 }
+
+#undef TAG
+#undef SUPPRESS_STATIC
+#define TAG(x) _hw_select_##x
+/* filter out none vertex api */
+#define HW_SELECT_MODE
+
+#undef ATTR_UNION
+#define ATTR_UNION(A, N, T, C, V0, V1, V2, V3)     \
+   do {                                            \
+      if ((A) == 0) {                              \
+         /* TODO: insert name stack attr. */       \
+      }                                            \
+      ATTR_UNION_BASE(A, N, T, C, V0, V1, V2, V3); \
+   } while (0)
+
+#include "vbo_attrib_tmp.h"
+
+void
+vbo_install_hw_select_begin_end(struct gl_context *ctx)
+{
+   int numEntries = MAX2(_gloffset_COUNT, _glapi_get_dispatch_table_size());
+   memcpy(ctx->HWSelectModeBeginEnd, ctx->BeginEnd, numEntries * sizeof(_glapi_proc));
+
+#undef NAME
+#define NAME(x) _hw_select_##x
+   struct _glapi_table *tab = ctx->HWSelectModeBeginEnd;
+   #include "api_hw_select_init.h"
+}
diff --git a/src/mesa/vbo/vbo_noop.c b/src/mesa/vbo/vbo_noop.c
index f4b6120d0960..9ed773d3bc51 100644
--- a/src/mesa/vbo/vbo_noop.c
+++ b/src/mesa/vbo/vbo_noop.c
@@ -134,6 +134,11 @@ vbo_install_exec_vtxfmt_noop(struct gl_context *ctx)
       tab = ctx->BeginEnd;
       #include "api_vtxfmt_init.h"
    }
+
+   if (ctx->HWSelectModeBeginEnd) {
+      tab = ctx->HWSelectModeBeginEnd;
+      #include "api_vtxfmt_init.h"
+   }
 }
 
 
-- 
GitLab


From 4b65802894ad2024c488d19227fdf4d98c07bbd2 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 17 Mar 2022 11:23:22 +0800
Subject: [PATCH 12/16] mesa: pass select result buffer offset as
 attribute/varying
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Will be used by geometry shader to store hit result.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/compiler/shader_enums.h   |  3 +++
 src/mesa/main/ffvertex_prog.c | 14 ++++++++++++++
 src/mesa/vbo/vbo_attrib.h     |  3 +++
 src/mesa/vbo/vbo_exec.c       |  2 +-
 src/mesa/vbo/vbo_exec_api.c   |  8 ++++++--
 src/mesa/vbo/vbo_exec_draw.c  | 12 +++++++++---
 6 files changed, 36 insertions(+), 6 deletions(-)

diff --git a/src/compiler/shader_enums.h b/src/compiler/shader_enums.h
index e07761bf9f9f..c5559700fad8 100644
--- a/src/compiler/shader_enums.h
+++ b/src/compiler/shader_enums.h
@@ -272,6 +272,9 @@ const char *gl_vert_attrib_name(gl_vert_attrib attrib);
 #define VERT_BIT_MAT(i)	         VERT_BIT(VERT_ATTRIB_MAT(i))
 #define VERT_BIT_MAT_ALL         \
    BITFIELD_RANGE(VERT_ATTRIB_MAT(0), VERT_ATTRIB_MAT_MAX)
+
+#define VERT_ATTRIB_SELECT_RESULT_OFFSET VERT_ATTRIB_GENERIC(3)
+#define VERT_BIT_SELECT_RESULT_OFFSET VERT_BIT_GENERIC(3)
 /*@}*/
 
 #define MAX_VARYING 32 /**< number of float[4] vectors */
diff --git a/src/mesa/main/ffvertex_prog.c b/src/mesa/main/ffvertex_prog.c
index c6f6234625e2..c28bd732f97b 100644
--- a/src/mesa/main/ffvertex_prog.c
+++ b/src/mesa/main/ffvertex_prog.c
@@ -38,6 +38,7 @@
 #include "main/mtypes.h"
 #include "main/macros.h"
 #include "main/enums.h"
+#include "main/context.h"
 #include "main/ffvertex_prog.h"
 #include "program/program.h"
 #include "program/prog_cache.h"
@@ -157,6 +158,16 @@ static void make_state_key( struct gl_context *ctx, struct state_key *key )
 
    memset(key, 0, sizeof(struct state_key));
 
+   if (_mesa_hw_select_enabled(ctx)) {
+      /* GL_SELECT mode only need position calculation.
+       * glBegin/End use VERT_BIT_SELECT_RESULT_OFFSET for multi name stack in one draw.
+       * glDrawArrays may also be called without user shader, fallback to FF one.
+       */
+      key->varying_vp_inputs = ctx->VertexProgram._VaryingInputs &
+         (VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET);
+      return;
+   }
+
    /* This now relies on texenvprogram.c being active:
     */
    assert(fp);
@@ -1668,6 +1679,9 @@ static void build_tnl_program( struct tnl_program *p )
    else if (p->state->varying_vp_inputs & VERT_BIT_POINT_SIZE)
       build_array_pointsize(p);
 
+   if (p->state->varying_vp_inputs & VERT_BIT_SELECT_RESULT_OFFSET)
+      emit_passthrough(p, VERT_ATTRIB_SELECT_RESULT_OFFSET, VARYING_SLOT_VAR0);
+
    /* Finish up:
     */
    emit_op1(p, OPCODE_END, undef, 0, undef);
diff --git a/src/mesa/vbo/vbo_attrib.h b/src/mesa/vbo/vbo_attrib.h
index 57346cb182ad..b3dc29764341 100644
--- a/src/mesa/vbo/vbo_attrib.h
+++ b/src/mesa/vbo/vbo_attrib.h
@@ -96,6 +96,9 @@ enum vbo_attrib {
    VBO_ATTRIB_MAT_FRONT_INDEXES,
    VBO_ATTRIB_MAT_BACK_INDEXES,
 
+   /* Offset into HW GL_SELECT result buffer. */
+   VBO_ATTRIB_SELECT_RESULT_OFFSET,
+
    VBO_ATTRIB_MAX
 };
 
diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index 58b315022f56..22b9464d487d 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -53,7 +53,7 @@ _vbo_attribute_alias_map[VP_MODE_MAX][VERT_ATTRIB_MAX] = {
       VBO_ATTRIB_GENERIC0,            /* VERT_ATTRIB_GENERIC0 */
       VBO_ATTRIB_GENERIC1,            /* VERT_ATTRIB_GENERIC1 */
       VBO_ATTRIB_GENERIC2,            /* VERT_ATTRIB_GENERIC2 */
-      VBO_ATTRIB_GENERIC3,            /* VERT_ATTRIB_GENERIC3 */
+      VBO_ATTRIB_SELECT_RESULT_OFFSET,/* VERT_ATTRIB_GENERIC3 */
       VBO_ATTRIB_MAT_FRONT_AMBIENT,   /* VERT_ATTRIB_GENERIC4 */
       VBO_ATTRIB_MAT_BACK_AMBIENT,    /* VERT_ATTRIB_GENERIC5 */
       VBO_ATTRIB_MAT_FRONT_DIFFUSE,   /* VERT_ATTRIB_GENERIC6 */
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index f7ee3baa49b6..570081198502 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -180,6 +180,10 @@ vbo_exec_copy_to_current(struct vbo_exec_context *exec)
 
       assert(exec->vtx.attr[i].size);
 
+      /* VBO_ATTRIB_SELECT_RESULT_INDEX has no current */
+      if (!current)
+         continue;
+
       if (exec->vtx.attr[i].type == GL_DOUBLE ||
           exec->vtx.attr[i].type == GL_UNSIGNED_INT64_ARB) {
          memset(tmp, 0, sizeof(tmp));
@@ -557,7 +561,6 @@ do {                                                                    \
    }                                                                    \
 } while (0)
 
-
 #undef ERROR
 #define ERROR(err) _mesa_error(ctx, err, __func__)
 #define TAG(x) _mesa_##x
@@ -1231,7 +1234,8 @@ _es_Materialf(GLenum face, GLenum pname, GLfloat param)
 #define ATTR_UNION(A, N, T, C, V0, V1, V2, V3)     \
    do {                                            \
       if ((A) == 0) {                              \
-         /* TODO: insert name stack attr. */       \
+         ATTR_UNION_BASE(VBO_ATTRIB_SELECT_RESULT_OFFSET, 1, GL_UNSIGNED_INT, uint32_t, \
+                         ctx->Select.ResultOffset, 0, 0, 0); \
       }                                            \
       ATTR_UNION_BASE(A, N, T, C, V0, V1, V2, V3); \
    } while (0)
diff --git a/src/mesa/vbo/vbo_exec_draw.c b/src/mesa/vbo/vbo_exec_draw.c
index e68b9f635d89..d149985fe700 100644
--- a/src/mesa/vbo/vbo_exec_draw.c
+++ b/src/mesa/vbo/vbo_exec_draw.c
@@ -101,8 +101,14 @@ vbo_exec_bind_arrays(struct gl_context *ctx)
 
    const gl_vertex_processing_mode mode = ctx->VertexProgram._VPMode;
 
-   /* Compute the bitmasks of vao_enabled arrays */
-   GLbitfield vao_enabled = _vbo_get_vao_enabled_from_vbo(mode, exec->vtx.enabled);
+   GLbitfield vao_enabled, vao_filter;
+   if (_mesa_hw_select_enabled(ctx)) {
+      /* HW GL_SELECT has fixed input */
+      vao_enabled = vao_filter = VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET;
+   } else {
+      vao_enabled = _vbo_get_vao_enabled_from_vbo(mode, exec->vtx.enabled);
+      vao_filter = _vbo_get_vao_filter(mode);
+   }
 
    /* At first disable arrays no longer needed */
    _mesa_disable_vertex_array_attribs(ctx, vao, VERT_BIT_ALL & ~vao_enabled);
@@ -141,7 +147,7 @@ vbo_exec_bind_arrays(struct gl_context *ctx)
    assert(!exec->vtx.bufferobj ||
           (vao_enabled & ~vao->VertexAttribBufferMask) == 0);
 
-   _mesa_set_draw_vao(ctx, vao, _vbo_get_vao_filter(mode));
+   _mesa_set_draw_vao(ctx, vao, vao_filter);
 }
 
 
-- 
GitLab


From b04d83d38bba6453de924d6a23e3f34d2f1c2467 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 2 Apr 2022 17:12:20 +0800
Subject: [PATCH 13/16] mesa/st: implement hardware accelerated GL_SELECT
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Use an internal geometry shader to handle input primitives. Do full
accurate culling and clipping in the shader and output hit result and
min/max depth to a SSBO for final being written to select buffer.

With multiple result slots in SSBO we can left multiple draws on the
fly and wait them done when buffer is full or exit GL_SELECT mode.

This provides quicker selection response compared to software based
solution. Tested on Discovery Studio 2020: some complex model needs
1~2s selection response time originally, now it's almost selected
immidiately.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/main/feedback.c                   |   4 +-
 src/mesa/meson.build                       |   1 +
 src/mesa/state_tracker/st_cb_feedback.c    |  20 +-
 src/mesa/state_tracker/st_context.c        |   7 +
 src/mesa/state_tracker/st_context.h        |   2 +
 src/mesa/state_tracker/st_draw.c           |  67 ++
 src/mesa/state_tracker/st_draw.h           |   9 +
 src/mesa/state_tracker/st_draw_hw_select.c | 821 +++++++++++++++++++++
 8 files changed, 924 insertions(+), 7 deletions(-)
 create mode 100644 src/mesa/state_tracker/st_draw_hw_select.c

diff --git a/src/mesa/main/feedback.c b/src/mesa/main/feedback.c
index e6d925b274d3..3a035b67eeb2 100644
--- a/src/mesa/main/feedback.c
+++ b/src/mesa/main/feedback.c
@@ -637,9 +637,11 @@ _mesa_RenderMode( GLenum mode )
 	 return 0;
    }
 
-   ctx->RenderMode = mode;
    st_RenderMode( ctx, mode );
 
+   /* finally update render mode to new one */
+   ctx->RenderMode = mode;
+
    return result;
 }
 
diff --git a/src/mesa/meson.build b/src/mesa/meson.build
index 522a4c2eb11d..8fba301efc55 100644
--- a/src/mesa/meson.build
+++ b/src/mesa/meson.build
@@ -351,6 +351,7 @@ files_libmesa = files(
   'state_tracker/st_draw.c',
   'state_tracker/st_draw.h',
   'state_tracker/st_draw_feedback.c',
+  'state_tracker/st_draw_hw_select.c',
   'state_tracker/st_extensions.c',
   'state_tracker/st_extensions.h',
   'state_tracker/st_format.c',
diff --git a/src/mesa/state_tracker/st_cb_feedback.c b/src/mesa/state_tracker/st_cb_feedback.c
index c5e6f779cd08..e937386fde05 100644
--- a/src/mesa/state_tracker/st_cb_feedback.c
+++ b/src/mesa/state_tracker/st_cb_feedback.c
@@ -291,12 +291,16 @@ st_RenderMode(struct gl_context *ctx, GLenum newMode )
       st_init_draw_functions(st->screen, &ctx->Driver);
    }
    else if (newMode == GL_SELECT) {
-      if (!st->selection_stage)
-         st->selection_stage = draw_glselect_stage(ctx, draw);
-      draw_set_rasterize_stage(draw, st->selection_stage);
-      /* Plug in new vbo draw function */
-      ctx->Driver.DrawGallium = _mesa_draw_gallium_fallback;
-      ctx->Driver.DrawGalliumMultiMode = _mesa_draw_gallium_multimode_fallback;
+      if (ctx->Const.HardwareAcceleratedSelect)
+         st_init_hw_select_draw_functions(st->screen, &ctx->Driver);
+      else {
+         if (!st->selection_stage)
+            st->selection_stage = draw_glselect_stage(ctx, draw);
+         draw_set_rasterize_stage(draw, st->selection_stage);
+         /* Plug in new vbo draw function */
+         ctx->Driver.DrawGallium = _mesa_draw_gallium_fallback;
+         ctx->Driver.DrawGalliumMultiMode = _mesa_draw_gallium_multimode_fallback;
+      }
    }
    else {
       struct gl_program *vp = st->ctx->VertexProgram._Current;
@@ -311,4 +315,8 @@ st_RenderMode(struct gl_context *ctx, GLenum newMode )
       if (vp)
          st->dirty |= ST_NEW_VERTEX_PROGRAM(st, vp);
    }
+
+   /* Restore geometry shader states when leaving GL_SELECT mode. */
+   if (ctx->RenderMode == GL_SELECT && ctx->Const.HardwareAcceleratedSelect)
+      st->dirty |= ST_NEW_GS_SSBOS | ST_NEW_GS_CONSTANTS | ST_NEW_GS_STATE;
 }
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index f306eea9237f..66ec72fa1b80 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -64,6 +64,7 @@
 #include "util/u_upload_mgr.h"
 #include "util/u_vbuf.h"
 #include "util/u_memory.h"
+#include "util/hash_table.h"
 #include "cso_cache/cso_context.h"
 #include "compiler/glsl/glsl_parser_extras.h"
 #include "nir/nir_to_tgsi.h"
@@ -968,6 +969,12 @@ st_destroy_context(struct st_context *st)
    st_release_program(st, &st->tep);
    st_release_program(st, &st->cp);
 
+   if (st->hw_select_shaders) {
+      hash_table_foreach(st->hw_select_shaders, entry)
+         st->pipe->delete_gs_state(st->pipe, entry->data);
+      _mesa_hash_table_destroy(st->hw_select_shaders, NULL);
+   }
+
    /* release framebuffer in the winsys buffers list */
    LIST_FOR_EACH_ENTRY_SAFE_REV(stfb, next, &st->winsys_buffers, head) {
       _mesa_reference_framebuffer(&stfb, NULL);
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 1498884b31ea..c9f4ec887fc7 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -384,6 +384,8 @@ struct st_context
       struct st_zombie_shader_node list;
       simple_mtx_t mutex;
    } zombie_shaders;
+
+   struct hash_table *hw_select_shaders;
 };
 
 
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index cd0b8d6e8b23..1fbfc5c11701 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -519,3 +519,70 @@ st_draw_quad(struct st_context *st,
 
    return true;
 }
+
+static void
+st_hw_select_draw_gallium(struct gl_context *ctx,
+                          struct pipe_draw_info *info,
+                          unsigned drawid_offset,
+                          const struct pipe_draw_start_count_bias *draws,
+                          unsigned num_draws)
+{
+   struct st_context *st = st_context(ctx);
+
+   prepare_draw(st, ctx, ST_PIPELINE_RENDER_STATE_MASK, ST_PIPELINE_RENDER);
+
+   if (!prepare_indexed_draw(st, ctx, info, draws, num_draws))
+      return;
+
+   if (!st_draw_hw_select_prepare_common(ctx) ||
+       !st_draw_hw_select_prepare_mode(ctx, info))
+      return;
+
+   cso_multi_draw(st->cso_context, info, drawid_offset, draws, num_draws);
+}
+
+static void
+st_hw_select_draw_gallium_multimode(struct gl_context *ctx,
+                                    struct pipe_draw_info *info,
+                                    const struct pipe_draw_start_count_bias *draws,
+                                    const unsigned char *mode,
+                                    unsigned num_draws)
+{
+   struct st_context *st = st_context(ctx);
+
+   prepare_draw(st, ctx, ST_PIPELINE_RENDER_STATE_MASK, ST_PIPELINE_RENDER);
+
+   if (!prepare_indexed_draw(st, ctx, info, draws, num_draws))
+      return;
+
+   if (!st_draw_hw_select_prepare_common(ctx))
+      return;
+
+   unsigned i, first;
+   struct cso_context *cso = st->cso_context;
+
+   /* Find consecutive draws where mode doesn't vary. */
+   for (i = 0, first = 0; i <= num_draws; i++) {
+      if (i == num_draws || mode[i] != mode[first]) {
+         info->mode = mode[first];
+
+         if (st_draw_hw_select_prepare_mode(ctx, info))
+            cso_multi_draw(cso, info, 0, &draws[first], i - first);
+
+         first = i;
+
+         /* We can pass the reference only once. st_buffer_object keeps
+          * the reference alive for later draws.
+          */
+         info->take_index_buffer_ownership = false;
+      }
+   }
+}
+
+void
+st_init_hw_select_draw_functions(struct pipe_screen *screen,
+                                 struct dd_function_table *functions)
+{
+   functions->DrawGallium = st_hw_select_draw_gallium;
+   functions->DrawGalliumMultiMode = st_hw_select_draw_gallium_multimode;
+}
diff --git a/src/mesa/state_tracker/st_draw.h b/src/mesa/state_tracker/st_draw.h
index e0e6e472bbd8..46ee64df6fa0 100644
--- a/src/mesa/state_tracker/st_draw.h
+++ b/src/mesa/state_tracker/st_draw.h
@@ -99,4 +99,13 @@ st_indirect_draw_vbo(struct gl_context *ctx,
                      const struct _mesa_index_buffer *ib,
                      bool primitive_restart,
                      unsigned restart_index);
+
+bool
+st_draw_hw_select_prepare_common(struct gl_context *ctx);
+bool
+st_draw_hw_select_prepare_mode(struct gl_context *ctx, struct pipe_draw_info *info);
+void
+st_init_hw_select_draw_functions(struct pipe_screen *screen,
+                                 struct dd_function_table *functions);
+
 #endif
diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
new file mode 100644
index 000000000000..5a032da046a1
--- /dev/null
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -0,0 +1,821 @@
+/*
+ * Copyright 2022 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "main/enums.h"
+#include "main/context.h"
+
+#include "st_context.h"
+#include "st_nir.h"
+#include "st_draw.h"
+
+#include "nir.h"
+#include "nir_builtin_builder.h"
+
+#include "u_memory.h"
+
+union state_key {
+   struct {
+      unsigned num_user_clip_planes:4;
+      unsigned face_culling_enabled:1;
+      unsigned result_offset_from_attribute:1;
+      unsigned primitive:4;
+   };
+   uint32_t u32;
+};
+
+enum primitive_state {
+   HW_SELECT_PRIM_NONE,
+   HW_SELECT_PRIM_POINTS,
+   HW_SELECT_PRIM_LINES,
+   HW_SELECT_PRIM_TRIANGLES,
+   HW_SELECT_PRIM_QUADS,
+};
+
+struct geometry_constant {
+   float depth_scale;
+   float depth_transport;
+   uint32_t culling_config;
+   uint32_t result_offset;
+   float clip_planes[MAX_CLIP_PLANES][4];
+};
+
+#define set_uniform_location(var, field, packed)                 \
+   do {                                                          \
+      unsigned offset = Offset(struct geometry_constant, field); \
+      var->data.driver_location = offset >> (packed ? 2 : 4);    \
+      var->data.location_frac = (offset >> 2) & 0x3;             \
+   } while (0)
+
+static nir_ssa_def *
+has_nan_or_inf(nir_builder *b, nir_ssa_def *v)
+{
+   nir_ssa_def *nan = nir_bany_fnequal4(b, v, v);
+
+   nir_ssa_def *imm = nir_imm_float(b, INFINITY);
+   nir_ssa_def *inf = nir_bany(b, nir_feq(b, nir_fabs(b, v), imm));
+
+   return nir_ior(b, nan, inf);
+}
+
+static void
+return_if_true(nir_builder *b, nir_ssa_def *cond)
+{
+   nir_if *if_cond = nir_push_if(b, cond);
+   nir_jump(b, nir_jump_return);
+   nir_pop_if(b, if_cond);
+}
+
+static void
+get_input_vertices(nir_builder *b, nir_ssa_def **v)
+{
+   const int num_in_vert = b->shader->info.gs.vertices_in;
+
+   nir_variable *in_pos = nir_variable_create(
+      b->shader, nir_var_shader_in, glsl_array_type(glsl_vec4_type(), num_in_vert, 0),
+      "gl_Position");
+   in_pos->data.location = VARYING_SLOT_POS;
+
+   nir_ssa_def *is_nan_or_inf = NULL;
+   for (int i = 0; i < num_in_vert; i++) {
+      v[i] = nir_load_array_var_imm(b, in_pos, i);
+      nir_ssa_def *r = has_nan_or_inf(b, v[i]);
+      is_nan_or_inf = i ? nir_ior(b, is_nan_or_inf, r) : r;
+   }
+   return_if_true(b, is_nan_or_inf);
+}
+
+static void
+face_culling(nir_builder *b, nir_ssa_def **v, bool packed)
+{
+   /* use the z value of the face normal to determine if the face points to us:
+    *   Nz = (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)
+    *
+    * it should be in NDC (Normalized Device Coordinate), but now we are in clip
+    * space (Vd = Vc / Vc.w), so multiply Nz with w0*w1*w2 to get the clip space
+    * value:
+    *   det = x0 * (y1 * w2 - y2 * w1) +
+    *         x1 * (y2 * w0 - y0 * w2) +
+    *         x2 * (y0 * w1 - y1 * w0)
+    *
+    * we only care about the sign of the det, but also need to count the sign of
+    * w0/w1/w2 as a negtive w would change the direction of Nz < 0
+    */
+   nir_ssa_def *y1w2 = nir_fmul(b, nir_channel(b, v[1], 1), nir_channel(b, v[2], 3));
+   nir_ssa_def *y2w1 = nir_fmul(b, nir_channel(b, v[2], 1), nir_channel(b, v[1], 3));
+   nir_ssa_def *y2w0 = nir_fmul(b, nir_channel(b, v[2], 1), nir_channel(b, v[0], 3));
+   nir_ssa_def *y0w2 = nir_fmul(b, nir_channel(b, v[0], 1), nir_channel(b, v[2], 3));
+   nir_ssa_def *y0w1 = nir_fmul(b, nir_channel(b, v[0], 1), nir_channel(b, v[1], 3));
+   nir_ssa_def *y1w0 = nir_fmul(b, nir_channel(b, v[1], 1), nir_channel(b, v[0], 3));
+   nir_ssa_def *t0 = nir_fmul(b, nir_channel(b, v[0], 0), nir_fsub(b, y1w2, y2w1));
+   nir_ssa_def *t1 = nir_fmul(b, nir_channel(b, v[1], 0), nir_fsub(b, y2w0, y0w2));
+   nir_ssa_def *t2 = nir_fmul(b, nir_channel(b, v[2], 0), nir_fsub(b, y0w1, y1w0));
+   nir_ssa_def *det = nir_fadd(b, nir_fadd(b, t0, t1), t2);
+
+   /* invert det sign once any vertex w < 0 */
+   nir_ssa_def *n0 = nir_flt(b, nir_channel(b, v[0], 3), nir_imm_float(b, 0));
+   nir_ssa_def *n1 = nir_flt(b, nir_channel(b, v[1], 3), nir_imm_float(b, 0));
+   nir_ssa_def *n2 = nir_flt(b, nir_channel(b, v[2], 3), nir_imm_float(b, 0));
+   nir_ssa_def *cond = nir_ixor(b, nir_ixor(b, n0, n1), n2);
+   det = nir_bcsel(b, cond, nir_fneg(b, det), det);
+
+   nir_variable *culling_config = nir_variable_create(
+      b->shader, nir_var_uniform, glsl_uint_type(), "culling_config");
+   set_uniform_location(culling_config, culling_config, packed);
+   nir_ssa_def *config = nir_i2b(b, nir_load_var(b, culling_config));
+
+   /* det < 0 then z points to camera */
+   nir_ssa_def *zero = nir_imm_zero(b, 1, det->bit_size);
+   nir_ssa_def *is_zero = nir_feq(b, det, zero);
+   nir_ssa_def *is_neg = nir_flt(b, det, zero);
+   nir_ssa_def *cull = nir_ixor(b, is_neg, config);
+   return_if_true(b, nir_ior(b, is_zero, cull));
+}
+
+static void
+fast_frustum_culling(nir_builder *b, nir_ssa_def **v)
+{
+   nir_ssa_def *cull = NULL;
+
+   /* there are six culling planes for the visible volume:
+    *   1.  x + w = 0
+    *   2. -x + w = 0
+    *   3.  y + w = 0
+    *   4. -y + w = 0
+    *   5.  z + w = 0
+    *   6. -z + w = 0
+    *
+    * if all vertices of the primitive are outside (plane equation <0) of
+    * any plane, the primitive must be invisible.
+    */
+   for (int i = 0; i < 6; i++) {
+      nir_ssa_def *outside = NULL;
+
+      for (int j = 0; j < b->shader->info.gs.vertices_in; j++) {
+         nir_ssa_def *c = nir_channel(b, v[j], i >> 1);
+         if (i & 1)
+            c = nir_fneg(b, c);
+
+         nir_ssa_def *r = nir_flt(b, nir_channel(b, v[j], 3), c);
+         outside = j ? nir_iand(b, outside, r) : r;
+      }
+
+      cull = i ? nir_ior(b, cull, outside) : outside;
+   }
+
+   return_if_true(b, cull);
+}
+
+static nir_ssa_def *
+get_intersection(nir_builder *b, nir_ssa_def *v1, nir_ssa_def *v2,
+                 nir_ssa_def *d1, nir_ssa_def *d2)
+{
+   nir_ssa_def *factor = nir_fdiv(b, d1, nir_fsub(b, d1, d2));
+   return nir_fmad(b, nir_fsub(b, v2, v1), factor, v1);
+}
+
+#define begin_for_loop(name, max)                                       \
+   nir_variable *name##_index =                                         \
+      nir_local_variable_create(b->impl, glsl_int_type(), #name "_i");  \
+   nir_store_var(b, name##_index, nir_imm_int(b, 0), 1);                \
+                                                                        \
+   nir_loop *name = nir_push_loop(b);                                   \
+   {                                                                    \
+      nir_ssa_def *idx = nir_load_var(b, name##_index);                 \
+      nir_if *if_in_loop = nir_push_if(b, nir_ilt(b, idx, max));
+
+#define end_for_loop(name)                                              \
+         nir_store_var(b, name##_index, nir_iadd_imm(b, idx, 1), 1);    \
+      nir_push_else(b, if_in_loop);                                     \
+         nir_jump(b, nir_jump_break);                                   \
+      nir_pop_if(b, if_in_loop);                                        \
+   }                                                                    \
+   nir_pop_loop(b, name);
+
+static void
+clip_with_plane(nir_builder *b, nir_variable *vert, nir_variable *num_vert,
+                int max_vert, nir_ssa_def *plane)
+{
+   nir_variable *all_clipped = nir_local_variable_create(
+      b->impl, glsl_bool_type(), "all_clipped");
+   nir_store_var(b, all_clipped, nir_imm_true(b), 1);
+
+   nir_variable *dist = nir_local_variable_create(
+      b->impl, glsl_array_type(glsl_float_type(), max_vert, 0), "dist");
+
+   nir_ssa_def *num = nir_load_var(b, num_vert);
+   begin_for_loop(dist_loop, num)
+   {
+      nir_ssa_def *v = nir_load_array_var(b, vert, idx);
+      nir_ssa_def *d = nir_fdot(b, v, plane);
+      nir_store_array_var(b, dist, idx, d, 1);
+
+      nir_ssa_def *clipped = nir_flt(b, d, nir_imm_float(b, 0));
+      nir_store_var(b, all_clipped,
+                    nir_iand(b, nir_load_var(b, all_clipped), clipped), 1);
+   }
+   end_for_loop(dist_loop)
+
+   return_if_true(b, nir_load_var(b, all_clipped));
+
+   /* Use +/0/- to denote the dist[i] sign, which means:
+    * +: inside plane
+    * -: outside plane
+    * 0: just on the plane
+    *
+    * Some example:
+    * ++++: all vertex not clipped
+    * ----: all vertex clipped
+    * +-++: one vertex clipped, need to insert two vertex at '-', array grow
+    * +--+: two vertex clipped, need to insert two vertex at '--', array same
+    * +---: three vertex clipped, need to insert two vertex at '---', array trim
+    * +-0+: one vertex clipped, need to insert one vertex at '-', array same
+    *
+    * Plane clip only produce convex polygon, so '-' must be contigous, there's
+    * no '+-+-', so one clip plane can only grow array by 1.
+    */
+
+   /* when array grow or '-' has been replaced with inserted vertex, save the
+    * original vert to be used by following calculation.
+    */
+   nir_variable *saved =
+      nir_local_variable_create(b->impl, glsl_vec4_type(), "saved");
+
+   nir_variable *vert_index =
+      nir_local_variable_create(b->impl, glsl_int_type(), "vert_index");
+   nir_store_var(b, vert_index, nir_imm_int(b, 0), 1);
+
+   begin_for_loop(vert_loop, num)
+   {
+      nir_ssa_def *di = nir_load_array_var(b, dist, idx);
+      nir_if *if_clipped = nir_push_if(b, nir_flt(b, di, nir_imm_float(b, 0)));
+      {
+         /* - case, we need to take care of sign change and insert vertex */
+
+         nir_ssa_def *prev = nir_bcsel(b, nir_ieq_imm(b, idx, 0),
+                                       nir_iadd_imm(b, num, -1),
+                                       nir_iadd_imm(b, idx, -1));
+         nir_ssa_def *dp = nir_load_array_var(b, dist, prev);
+         nir_if *prev_if = nir_push_if(b, nir_flt(b, nir_imm_float(b, 0), dp));
+         {
+            /* +- case, replace - with inserted vertex
+             * assert(vert_index <= idx), array is sure to not grow here
+             * but need to save vert[idx] when vert_index==idx
+             */
+
+            nir_ssa_def *vi = nir_load_array_var(b, vert, idx);
+            nir_store_var(b, saved, vi, 0xf);
+
+            nir_ssa_def *vp = nir_load_array_var(b, vert, prev);
+            nir_ssa_def *iv = get_intersection(b, vp, vi, dp, di);
+            nir_ssa_def *index = nir_load_var(b, vert_index);
+            nir_store_array_var(b, vert, index, iv, 0xf);
+
+            nir_store_var(b, vert_index, nir_iadd_imm(b, index, 1), 1);
+         }
+         nir_pop_if(b, prev_if);
+
+         nir_ssa_def *next = nir_bcsel(b, nir_ieq(b, idx, nir_iadd_imm(b, num, -1)),
+                                       nir_imm_int(b, 0), nir_iadd_imm(b, idx, 1));
+         nir_ssa_def *dn = nir_load_array_var(b, dist, next);
+         nir_if *next_if = nir_push_if(b, nir_flt(b, nir_imm_float(b, 0), dn));
+         {
+            /* -+ case, may grow array:
+             *   vert_index > idx: +-+ case, grow array, current vertex in 'saved',
+             *     save next + to 'saved', will replace it with inserted vertex.
+             *   vert_index <= idx: --+ case, will replace last - with inserted vertex,
+             *     no need to save last -, because + case won't use - value.
+             */
+
+            nir_ssa_def *index = nir_load_var(b, vert_index);
+            nir_ssa_def *vi = nir_bcsel(b, nir_flt(b, idx, index),
+                                        nir_load_var(b, saved),
+                                        nir_load_array_var(b, vert, idx));
+            nir_ssa_def *vn = nir_load_array_var(b, vert, next);
+            nir_ssa_def *iv = get_intersection(b, vn, vi, dn, di);
+
+            nir_store_var(b, saved, nir_load_array_var(b, vert, index), 0xf);
+            nir_store_array_var(b, vert, index, iv, 0xf);
+
+            nir_store_var(b, vert_index, nir_iadd_imm(b, index, 1), 1);
+         }
+         nir_pop_if(b, next_if);
+      }
+      nir_push_else(b, if_clipped);
+      {
+         /* +/0 case, just keep the vert
+          *   vert_index > idx: array grew case, vert[idx] is inserted vertex or prev
+          *     +/0 vertex, current vertex is in 'saved', need to save next vertex
+          *   vert_index < idx: array trim case
+          */
+
+         nir_ssa_def *index = nir_load_var(b, vert_index);
+         nir_ssa_def *vi = nir_bcsel(b, nir_flt(b, idx, index),
+                                     nir_load_var(b, saved),
+                                     nir_load_array_var(b, vert, idx));
+
+         nir_store_var(b, saved, nir_load_array_var(b, vert, index), 0xf);
+         nir_store_array_var(b, vert, index, vi, 0xf);
+
+         nir_store_var(b, vert_index, nir_iadd_imm(b, index, 1), 1);
+      }
+      nir_pop_if(b, if_clipped);
+   }
+   end_for_loop(vert_loop);
+
+   nir_copy_var(b, num_vert, vert_index);
+}
+
+static nir_ssa_def *
+get_user_clip_plane(nir_builder *b, int index, bool packed)
+{
+   char name[16];
+   snprintf(name, sizeof(name), "gl_ClipPlane%d", index);
+   nir_variable *plane = nir_variable_create(
+      b->shader, nir_var_uniform, glsl_vec4_type(), name);
+
+   set_uniform_location(plane, clip_planes[index][0], packed);
+
+   return nir_load_var(b, plane);
+}
+
+static void
+get_depth_range_transform(nir_builder *b, bool packed, nir_ssa_def **trans)
+{
+   nir_variable *depth_scale = nir_variable_create(
+      b->shader, nir_var_uniform, glsl_float_type(), "depth_scale");
+   set_uniform_location(depth_scale, depth_scale, packed);
+
+   nir_variable *depth_transport = nir_variable_create(
+      b->shader, nir_var_uniform, glsl_float_type(), "depth_transport");
+   set_uniform_location(depth_transport, depth_transport, packed);
+
+   trans[0] = nir_load_var(b, depth_scale);
+   trans[1] = nir_load_var(b, depth_transport);
+}
+
+static nir_ssa_def *
+get_window_space_depth(nir_builder *b, nir_ssa_def *v, nir_ssa_def **trans)
+{
+   nir_ssa_def *z = nir_channel(b, v, 2);
+   nir_ssa_def *w = nir_channel(b, v, 3);
+
+   /* do perspective division, if w==0, xyz must be 0 too (otherwise can't pass
+    * the clip test), 0/0=NaN, but we want it to be the nearest point.
+    */
+   nir_ssa_def *c = nir_feq(b, w, nir_imm_float(b, 0));
+   nir_ssa_def *d = nir_bcsel(b, c, nir_imm_float(b, -1), nir_fdiv(b, z, w));
+
+   /* map [-1, 1] to [near, far] set by glDepthRange(near, far) */
+   return nir_fmad(b, trans[0], d, trans[1]);
+}
+
+static void
+update_result_buffer(nir_builder *b, nir_ssa_def *dmin, nir_ssa_def *dmax,
+                     bool offset_from_attribute, bool packed)
+{
+   nir_ssa_def *offset;
+   if (offset_from_attribute) {
+      nir_variable *in_offset = nir_variable_create(
+         b->shader, nir_var_shader_in,
+         glsl_array_type(glsl_uint_type(), b->shader->info.gs.vertices_in, 0),
+         "result_offset");
+      in_offset->data.location = VARYING_SLOT_VAR0;
+      offset = nir_load_array_var_imm(b, in_offset, 0);
+   } else {
+      nir_variable *uni_offset = nir_variable_create(
+         b->shader, nir_var_uniform, glsl_uint_type(), "result_offset");
+      set_uniform_location(uni_offset, result_offset, packed);
+      offset = nir_load_var(b, uni_offset);
+   }
+
+   nir_variable_create(b->shader, nir_var_mem_ssbo,
+                       glsl_array_type(glsl_uint_type(), 0, 0), "result");
+   /* driver_location = 0 (slot 0) */
+
+   nir_ssa_def *ssbo = nir_imm_int(b, 0);
+   nir_ssbo_atomic_exchange(b, 32, ssbo, offset, nir_imm_int(b, 1));
+   nir_ssbo_atomic_umin(b, 32, ssbo, nir_iadd_imm(b, offset, 4), dmin);
+   nir_ssbo_atomic_umax(b, 32, ssbo, nir_iadd_imm(b, offset, 8), dmax);
+}
+
+static void
+build_point_nir_shader(nir_builder *b, union state_key state, bool packed)
+{
+   assert(b->shader->info.gs.vertices_in == 1);
+
+   nir_ssa_def *v;
+   get_input_vertices(b, &v);
+
+   fast_frustum_culling(b, &v);
+
+   nir_ssa_def *outside = NULL;
+   for (int i = 0; i < state.num_user_clip_planes; i++) {
+      nir_ssa_def *p = get_user_clip_plane(b, i, packed);
+      nir_ssa_def *d = nir_fdot(b, v, p);
+      nir_ssa_def *r = nir_flt(b, d, nir_imm_float(b, 0));
+      outside = i ? nir_ior(b, outside, r) : r;
+   }
+   if (outside)
+      return_if_true(b, outside);
+
+   nir_ssa_def *trans[2];
+   get_depth_range_transform(b, packed, trans);
+
+   nir_ssa_def *depth = get_window_space_depth(b, v, trans);
+   nir_ssa_def *fdepth = nir_fmul_imm(b, depth, 4294967295.0);
+   nir_ssa_def *idepth = nir_f2uN(b, fdepth, 32);
+
+   update_result_buffer(b, idepth, idepth, state.result_offset_from_attribute, packed);
+}
+
+static nir_variable *
+create_clip_planes(nir_builder *b, int num_clip_planes, bool packed)
+{
+   nir_variable *clip_planes = nir_local_variable_create(
+      b->impl, glsl_array_type(glsl_vec4_type(), num_clip_planes, 0), "clip_planes");
+
+   nir_ssa_def *unit_clip_planes[6] = {
+      nir_imm_vec4(b,  1,  0,  0,  1),
+      nir_imm_vec4(b, -1,  0,  0,  1),
+      nir_imm_vec4(b,  0,  1,  0,  1),
+      nir_imm_vec4(b,  0, -1,  0,  1),
+      nir_imm_vec4(b,  0,  0,  1,  1),
+      nir_imm_vec4(b,  0,  0, -1,  1),
+   };
+   for (int i = 0; i < 6; i++)
+      nir_store_array_var_imm(b, clip_planes, i, unit_clip_planes[i], 0xf);
+
+   for (int i = 6; i < num_clip_planes; i++) {
+      nir_ssa_def *p = get_user_clip_plane(b, i - 6, packed);
+      nir_store_array_var_imm(b, clip_planes, i, p, 0xf);
+   }
+
+   return clip_planes;
+}
+
+static void
+build_line_nir_shader(nir_builder *b, union state_key state, bool packed)
+{
+   assert(b->shader->info.gs.vertices_in == 2);
+
+   nir_ssa_def *v[2];
+   get_input_vertices(b, v);
+
+   fast_frustum_culling(b, v);
+
+   nir_variable *vert0 = nir_local_variable_create(b->impl, glsl_vec4_type(), "vert0");
+   nir_store_var(b, vert0, v[0], 0xf);
+
+   nir_variable *vert1 = nir_local_variable_create(b->impl, glsl_vec4_type(), "vert1");
+   nir_store_var(b, vert1, v[1], 0xf);
+
+   const int num_clip_planes = 6 + state.num_user_clip_planes;
+   nir_variable *clip_planes = create_clip_planes(b, num_clip_planes, packed);
+
+   begin_for_loop(clip_loop, nir_imm_int(b, num_clip_planes))
+   {
+      nir_ssa_def *plane = nir_load_array_var(b, clip_planes, idx);
+      nir_ssa_def *v0 = nir_load_var(b, vert0);
+      nir_ssa_def *v1 = nir_load_var(b, vert1);
+      nir_ssa_def *d0 = nir_fdot(b, v0, plane);
+      nir_ssa_def *d1 = nir_fdot(b, v1, plane);
+      nir_ssa_def *n0 = nir_flt(b, d0, nir_imm_float(b, 0));
+      nir_ssa_def *n1 = nir_flt(b, d1, nir_imm_float(b, 0));
+
+      return_if_true(b, nir_iand(b, n0, n1));
+
+      nir_if *clip_if = nir_push_if(b, nir_ior(b, n0, n1));
+      {
+         nir_ssa_def *iv = get_intersection(b, v0, v1, d0, d1);
+         nir_store_var(b, vert0, nir_bcsel(b, n0, iv, v0), 0xf);
+         nir_store_var(b, vert1, nir_bcsel(b, n1, iv, v1), 0xf);
+      }
+      nir_pop_if(b, clip_if);
+   }
+   end_for_loop(clip_loop)
+
+   nir_ssa_def *trans[2];
+   get_depth_range_transform(b, packed, trans);
+
+   nir_ssa_def *d0 = get_window_space_depth(b, nir_load_var(b, vert0), trans);
+   nir_ssa_def *d1 = get_window_space_depth(b, nir_load_var(b, vert1), trans);
+
+   nir_ssa_def *dmin = nir_fmin(b, d0, d1);
+   nir_ssa_def *dmax = nir_fmax(b, d0, d1);
+
+   nir_ssa_def *fdmin = nir_fmul_imm(b, dmin, 4294967295.0);
+   nir_ssa_def *idmin = nir_f2uN(b, fdmin, 32);
+
+   nir_ssa_def *fdmax = nir_fmul_imm(b, dmax, 4294967295.0);
+   nir_ssa_def *idmax = nir_f2uN(b, fdmax, 32);
+
+   update_result_buffer(b, idmin, idmax, state.result_offset_from_attribute, packed);
+}
+
+static void
+build_planar_primitive_nir_shader(nir_builder *b, union state_key state, bool packed)
+{
+   const int num_in_vert = b->shader->info.gs.vertices_in;
+   assert(num_in_vert == 3 || num_in_vert == 4);
+
+   nir_ssa_def *v[4];
+   get_input_vertices(b, v);
+
+   if (state.face_culling_enabled)
+      face_culling(b, v, packed);
+
+   /* fast frustum culling, this should filter out most primitives */
+   fast_frustum_culling(b, v);
+
+   const int num_clip_planes = 6 + state.num_user_clip_planes;
+   const int max_vert = num_in_vert + num_clip_planes;
+
+   /* TODO: could use shared memory (ie. AMD GPU LDS) for this array
+    * to reduce register usage.
+    */
+   nir_variable *vert = nir_local_variable_create(
+      b->impl, glsl_array_type(glsl_vec4_type(), max_vert, 0), "vert");
+   for (int i = 0; i < num_in_vert; i++)
+      nir_store_array_var_imm(b, vert, i, v[i], 0xf);
+
+   nir_variable *num_vert =
+      nir_local_variable_create(b->impl, glsl_int_type(), "num_vert");
+   nir_store_var(b, num_vert, nir_imm_int(b, num_in_vert), 1);
+
+   nir_variable *clip_planes = create_clip_planes(b, num_clip_planes, packed);
+
+   /* accurate clipping with all clip planes */
+   begin_for_loop(clip_loop, nir_imm_int(b, num_clip_planes))
+   {
+      nir_ssa_def *plane = nir_load_array_var(b, clip_planes, idx);
+      clip_with_plane(b, vert, num_vert, max_vert, plane);
+   }
+   end_for_loop(clip_loop)
+
+   nir_ssa_def *trans[2];
+   get_depth_range_transform(b, packed, trans);
+
+   nir_variable *dmin =
+      nir_local_variable_create(b->impl, glsl_float_type(), "dmin");
+   nir_store_var(b, dmin, nir_imm_float(b, 1), 1);
+
+   nir_variable *dmax =
+      nir_local_variable_create(b->impl, glsl_float_type(), "dmax");
+   nir_store_var(b, dmax, nir_imm_float(b, 0), 1);
+
+   begin_for_loop(depth_loop, nir_load_var(b, num_vert))
+   {
+      nir_ssa_def *vtx = nir_load_array_var(b, vert, idx);
+      nir_ssa_def *depth = get_window_space_depth(b, vtx, trans);
+      nir_store_var(b, dmin, nir_fmin(b, nir_load_var(b, dmin), depth), 1);
+      nir_store_var(b, dmax, nir_fmax(b, nir_load_var(b, dmax), depth), 1);
+   }
+   end_for_loop(depth_loop)
+
+   nir_ssa_def *fdmin = nir_fmul_imm(b, nir_load_var(b, dmin), 4294967295.0);
+   nir_ssa_def *idmin = nir_f2uN(b, fdmin, 32);
+
+   nir_ssa_def *fdmax = nir_fmul_imm(b, nir_load_var(b, dmax), 4294967295.0);
+   nir_ssa_def *idmax = nir_f2uN(b, fdmax, 32);
+
+   update_result_buffer(b, idmin, idmax, state.result_offset_from_attribute, packed);
+}
+
+static void *
+hw_select_create_gs(struct st_context *st, union state_key state)
+{
+   const nir_shader_compiler_options *options =
+      st_get_nir_compiler_options(st, MESA_SHADER_GEOMETRY);
+
+   nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_GEOMETRY, options,
+                                                  "hw select GS");
+
+   nir_shader *nir = b.shader;
+   nir->info.inputs_read = VARYING_BIT_POS;
+   nir->info.num_ssbos = 1;
+   nir->info.gs.output_primitive = SHADER_PRIM_POINTS;
+   nir->info.gs.vertices_out = 1;
+   nir->info.gs.invocations = 1;
+   nir->info.gs.active_stream_mask = 1;
+
+   if (state.result_offset_from_attribute)
+      nir->info.inputs_read |= VARYING_BIT_VAR(0);
+
+   bool packed = st->ctx->Const.PackedDriverUniformStorage;
+
+   switch (state.primitive) {
+   case HW_SELECT_PRIM_POINTS:
+      nir->info.gs.input_primitive = SHADER_PRIM_POINTS;
+      nir->info.gs.vertices_in = 1;
+      build_point_nir_shader(&b, state, packed);
+      break;
+   case HW_SELECT_PRIM_LINES:
+      nir->info.gs.input_primitive = SHADER_PRIM_LINES;
+      nir->info.gs.vertices_in = 2;
+      build_line_nir_shader(&b, state, packed);
+      break;
+   case HW_SELECT_PRIM_TRIANGLES:
+      nir->info.gs.input_primitive = SHADER_PRIM_TRIANGLES;
+      nir->info.gs.vertices_in = 3;
+      build_planar_primitive_nir_shader(&b, state, packed);
+      break;
+   case HW_SELECT_PRIM_QUADS:
+      /* geometry shader has no quad primitive, use lines_adjacency instead */
+      nir->info.gs.input_primitive = SHADER_PRIM_LINES_ADJACENCY;
+      nir->info.gs.vertices_in = 4;
+      build_planar_primitive_nir_shader(&b, state, packed);
+      break;
+   default:
+      unreachable("unexpected primitive");
+   }
+
+   nir_lower_returns(nir);
+
+   return st_nir_finish_builtin_shader(st, nir);
+}
+
+bool
+st_draw_hw_select_prepare_common(struct gl_context *ctx)
+{
+   struct st_context *st = st_context(ctx);
+   if (st->gp || st->tcp || st->tep) {
+      fprintf(stderr, "HW GL_SELECT does not support user geometry/tessellation shader\n");
+      return false;
+   }
+
+   struct geometry_constant consts;
+
+   float n = ctx->ViewportArray[0].Near;
+   float f = ctx->ViewportArray[0].Far;
+   consts.depth_scale = (f - n) / 2;
+   consts.depth_transport = (f + n) / 2;
+
+   /* this field is not used when face culling disabled */
+   consts.culling_config =
+      (ctx->Polygon.CullFaceMode == GL_BACK) ^
+      (ctx->Polygon.FrontFace == GL_CCW);
+
+   /* this field is not used when passing result offset by attribute */
+   consts.result_offset = st->ctx->Select.ResultOffset;
+
+   int num_planes = 0;
+   u_foreach_bit(i, ctx->Transform.ClipPlanesEnabled) {
+      COPY_4V(consts.clip_planes[num_planes], ctx->Transform._ClipUserPlane[i]);
+      num_planes++;
+   }
+
+   struct pipe_constant_buffer cb;
+   cb.buffer = NULL;
+   cb.user_buffer = &consts;
+   cb.buffer_offset = 0;
+   cb.buffer_size = sizeof(consts) - (MAX_CLIP_PLANES - num_planes) * 4 * sizeof(float);
+
+   struct pipe_context *pipe = st->pipe;
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_GEOMETRY, 0, false, &cb);
+
+   struct pipe_shader_buffer buffer;
+   memset(&buffer, 0, sizeof(buffer));
+   buffer.buffer = ctx->Select.Result->buffer;
+   buffer.buffer_size = MAX_NAME_STACK_RESULT_NUM * 3 * sizeof(int);
+
+   pipe->set_shader_buffers(pipe, PIPE_SHADER_GEOMETRY, 0, 1, &buffer, 0x1);
+
+   return true;
+}
+
+static union state_key
+make_state_key(struct gl_context *ctx, int mode)
+{
+   union state_key state = {0};
+
+   switch (mode) {
+   case GL_POINTS:
+      state.primitive = HW_SELECT_PRIM_POINTS;
+      break;
+   case GL_LINES:
+   case GL_LINE_STRIP:
+   case GL_LINE_LOOP:
+      state.primitive = HW_SELECT_PRIM_LINES;
+      break;
+   case GL_QUADS:
+      state.primitive = HW_SELECT_PRIM_QUADS;
+      break;
+   case GL_TRIANGLES:
+   case GL_TRIANGLE_STRIP:
+   case GL_TRIANGLE_FAN:
+      /* These will be broken into triangles. */
+   case GL_QUAD_STRIP:
+   case GL_POLYGON:
+      state.primitive = HW_SELECT_PRIM_TRIANGLES;
+      break;
+   default:
+      fprintf(stderr, "HW GL_SELECT does not support draw mode %s\n",
+              _mesa_enum_to_string(mode));
+      return (union state_key){0};
+   }
+
+   /* TODO: support gl_ClipDistance/gl_CullDistance, but it costs more regs */
+   struct gl_program *vp = ctx->st->vp;
+   if (vp->info.clip_distance_array_size || vp->info.cull_distance_array_size) {
+      fprintf(stderr, "HW GL_SELECT does not support gl_ClipDistance/gl_CullDistance\n");
+      return (union state_key){0};
+   }
+
+   state.num_user_clip_planes = util_bitcount(ctx->Transform.ClipPlanesEnabled);
+
+   /* face culling only apply to 2D primitives */
+   if (state.primitive == HW_SELECT_PRIM_QUADS ||
+       state.primitive == HW_SELECT_PRIM_TRIANGLES)
+      state.face_culling_enabled = ctx->Polygon.CullFlag;
+
+   state.result_offset_from_attribute =
+      ctx->VertexProgram._VPMode == VP_MODE_FF &&
+      (ctx->VertexProgram._VaryingInputs & VERT_BIT_SELECT_RESULT_OFFSET);
+
+   return state;
+}
+
+bool
+st_draw_hw_select_prepare_mode(struct gl_context *ctx, struct pipe_draw_info *info)
+{
+   union state_key key = make_state_key(ctx, info->mode);
+   if (!key.u32)
+      return false;
+
+   struct st_context *st = st_context(ctx);
+   if (!st->hw_select_shaders)
+      st->hw_select_shaders = _mesa_hash_table_create_u32_keys(NULL);
+
+   struct hash_entry *he = _mesa_hash_table_search(st->hw_select_shaders,
+                                                   (void*)(uintptr_t)key.u32);
+   void *gs;
+   if (!he) {
+      gs = hw_select_create_gs(st, key);
+      if (!gs)
+         return false;
+
+      _mesa_hash_table_insert(st->hw_select_shaders, (void*)(uintptr_t)key.u32, gs);
+   } else
+      gs = he->data;
+
+   struct cso_context *cso = st->cso_context;
+   cso_set_geometry_shader_handle(cso, gs);
+
+   /* Replace draw mode with equivalent one which geometry shader support.
+    *
+    * New mode consume same vertex buffer structure and produce primitive with
+    * same vertices (no need to be same type of primitive, because geometry shader
+    * operate on vertives and emit nothing).
+    *
+    * We can break QUAD and POLYGON to triangles with same shape. But we can't futher
+    * break them into single line or point because new primitive need to contain >=3
+    * vertices so that it's still handled in 2D (planar) way instead of 1D (line) or
+    * 0D (point) way which have different algorithm.
+    */
+   switch (info->mode) {
+   case GL_QUADS:
+      info->mode = GL_LINES_ADJACENCY;
+      break;
+   case GL_QUAD_STRIP:
+      info->mode = GL_TRIANGLE_STRIP;
+      break;
+   case GL_POLYGON:
+      info->mode = GL_TRIANGLE_FAN;
+      break;
+   default:
+      break;
+   }
+
+   /* Only normal glBegin/End draws pass result offset by attribute to avoid flush
+    * vertices when change name stack, so multiple glBegin/End sections before/after
+    * name stack calls can be merged to a single draw call. To achieve this We mark
+    * name stack result buffer used in glEnd instead of the last draw call.
+    *
+    * Other case like glDrawArrays and display list replay won't merge draws cross
+    * name stack calls, so we just mark name stack result buffer used here.
+    */
+   if (!key.result_offset_from_attribute)
+      ctx->Select.ResultUsed = GL_TRUE;
+
+   return true;
+}
-- 
GitLab


From bb3ef2fb850e3be518234b16269b26d0576909c5 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 21 May 2022 15:35:39 +0800
Subject: [PATCH 14/16] zink: reset PIPE_CAP_ACCELERATED when cpu soft
 rendering

This field can be used to disable some unsupport/unproper hardware
acceleration. Reset it when zink is runing on cpu rendering.

Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/zink/zink_screen.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index fb402ed1367b..4086135935ac 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -625,7 +625,7 @@ zink_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
       return screen->info.props.deviceID;
 
    case PIPE_CAP_ACCELERATED:
-      return 1;
+      return !screen->is_cpu;
    case PIPE_CAP_VIDEO_MEMORY:
       return get_video_mem(screen) >> 20;
    case PIPE_CAP_UMA:
-- 
GitLab


From d7512ae32b29aae564e01d1642a15e0c46d5eafe Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 21 May 2022 20:55:00 +0800
Subject: [PATCH 15/16] virgl: return -1 for PIPE_CAP_ACCELERATED

There's no way currently in virgl to determine whether it's running
above CPU or GPU. This info will be used to disable HW SELECT.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 docs/gallium/screen.rst                        | 5 ++++-
 src/gallium/drivers/virgl/virgl_screen.c       | 2 +-
 src/gallium/frontends/dri/dri_query_renderer.c | 4 ++--
 3 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/docs/gallium/screen.rst b/docs/gallium/screen.rst
index 808afec859a7..032a933c1194 100644
--- a/docs/gallium/screen.rst
+++ b/docs/gallium/screen.rst
@@ -256,7 +256,10 @@ The integer capabilities:
   not available one should return 0xFFFFFFFF.
 * ``PIPE_CAP_DEVICE_ID``: The device ID (PCI ID) of the underlying hardware.
   0xFFFFFFFF if not available.
-* ``PIPE_CAP_ACCELERATED``: Whether the renderer is hardware accelerated.
+* ``PIPE_CAP_ACCELERATED``: Whether the renderer is hardware accelerated. 0 means
+  not accelerated (ie. CPU rendering), 1 means accelerated (ie. GPU rendering),
+  -1 means unknown (ie. an API translation driver which doesn't known what kind of
+  hardware it's running above).
 * ``PIPE_CAP_VIDEO_MEMORY``: The amount of video memory in megabytes.
 * ``PIPE_CAP_UMA``: If the device has a unified memory architecture or on-card
   memory and GART.
diff --git a/src/gallium/drivers/virgl/virgl_screen.c b/src/gallium/drivers/virgl/virgl_screen.c
index 135ccf2fd032..b85b8a33d443 100644
--- a/src/gallium/drivers/virgl/virgl_screen.c
+++ b/src/gallium/drivers/virgl/virgl_screen.c
@@ -330,7 +330,7 @@ virgl_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_DEVICE_ID:
       return 0x1010;
    case PIPE_CAP_ACCELERATED:
-      return 1;
+      return -1; /* -1 means unknown */
    case PIPE_CAP_UMA:
    case PIPE_CAP_VIDEO_MEMORY:
       if (vscreen->caps.caps.v2.capability_bits_v2 & VIRGL_CAP_V2_VIDEO_MEMORY)
diff --git a/src/gallium/frontends/dri/dri_query_renderer.c b/src/gallium/frontends/dri/dri_query_renderer.c
index 11790fd0f456..7b4870cdb8d5 100644
--- a/src/gallium/frontends/dri/dri_query_renderer.c
+++ b/src/gallium/frontends/dri/dri_query_renderer.c
@@ -98,8 +98,8 @@ dri2_query_renderer_integer(__DRIscreen *_screen, int param,
       return 0;
    case __DRI2_RENDERER_ACCELERATED:
       value[0] =
-         (unsigned int)screen->base.screen->get_param(screen->base.screen,
-                                                      PIPE_CAP_ACCELERATED);
+         (unsigned int)!!screen->base.screen->get_param(screen->base.screen,
+                                                        PIPE_CAP_ACCELERATED);
       return 0;
 
    case __DRI2_RENDERER_VIDEO_MEMORY: {
-- 
GitLab


From 2460aea1f88360835b23e35b34635a4e39bf8830 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 28 Apr 2022 10:26:13 +0800
Subject: [PATCH 16/16] mesa: enable HardwareAcceleratedSelect

Could be enabled/disabled by MESA_HW_ACCEL_SELECT.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/mesa/state_tracker/st_extensions.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 2d307169259d..313d9ef33ac4 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -631,7 +631,17 @@ void st_init_limits(struct pipe_screen *screen,
    c->SparseTextureFullArrayCubeMipmaps =
       screen->get_param(screen, PIPE_CAP_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS);
 
-   c->HardwareAcceleratedSelect = false;
+   /* =0: on CPU, always disabled
+    * >0: on GPU, enable by default, user can disable it manually
+    * <0: unknown, disable by default, user can enable it manually
+    */
+   int accel = screen->get_param(screen, PIPE_CAP_ACCELERATED);
+   c->HardwareAcceleratedSelect =
+      accel && debug_get_bool_option("MESA_HW_ACCEL_SELECT", accel > 0) &&
+      /* internal geometry shader need indirect array access */
+      !c->ShaderCompilerOptions[MESA_SHADER_GEOMETRY].EmitNoIndirectTemp &&
+      /* internal geometry shader need SSBO support */
+      c->Program[MESA_SHADER_GEOMETRY].MaxShaderStorageBlocks;
 }
 
 
-- 
GitLab

