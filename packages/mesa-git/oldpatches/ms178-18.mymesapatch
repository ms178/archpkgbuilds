--- a/src/amd/compiler/instruction_selection/aco_isel_setup.cpp	2025-07-21 22:07:21.084777262 +0200
+++ b/src/amd/compiler/instruction_selection/aco_isel_setup.cpp	2025-07-21 22:16:00.003821217 +0200
@@ -12,13 +12,14 @@
 
 #include "ac_nir.h"
 #include <vector>
+#include <algorithm>
 
 namespace aco {
 
 namespace {
 
 /* Check whether the given SSA def is only used by cross-lane instructions. */
-bool
+static inline bool
 only_used_by_cross_lane_instrs(nir_def* ssa, bool follow_phis = true)
 {
    nir_foreach_use (src, ssa) {
@@ -29,7 +30,6 @@ only_used_by_cross_lane_instrs(nir_def*
             return false;
          if (!only_used_by_cross_lane_instrs(&alu->def, follow_phis))
             return false;
-
          continue;
       }
       case nir_instr_type_intrinsic: {
@@ -38,7 +38,6 @@ only_used_by_cross_lane_instrs(nir_def*
              intrin->intrinsic != nir_intrinsic_read_first_invocation &&
              intrin->intrinsic != nir_intrinsic_lane_permute_16_amd)
             return false;
-
          continue;
       }
       case nir_instr_type_phi: {
@@ -49,10 +48,10 @@ only_used_by_cross_lane_instrs(nir_def*
          nir_phi_instr* phi = nir_instr_as_phi(nir_src_parent_instr(src));
          if (!only_used_by_cross_lane_instrs(&phi->def, false))
             return false;
-
          continue;
       }
-      default: return false;
+      default:
+         return false;
       }
    }
 
@@ -66,7 +65,7 @@ only_used_by_cross_lane_instrs(nir_def*
  *
  * This also removes any unreachable merge blocks.
  */
-bool
+static bool
 sanitize_if(nir_function_impl* impl, nir_if* nif)
 {
    nir_block* then_block = nir_if_last_then_block(nif);
@@ -76,20 +75,18 @@ sanitize_if(nir_function_impl* impl, nir
    if (!then_jump && !else_jump)
       return false;
 
-   /* If the continue from block is empty then return as there is nothing to
-    * move.
-    */
+   /* If the continue-from block is empty then return as there is nothing to move. */
    if (nir_cf_list_is_empty_block(then_jump ? &nif->else_list : &nif->then_list))
       return false;
 
-   /* Even though this if statement has a jump on one side, we may still have
-    * phis afterwards.  Single-source phis can be produced by loop unrolling
-    * or dead control-flow passes and are perfectly legal.  Run a quick phi
+   /* Even though this if-statement has a jump on one side, we may still have
+    * phis afterwards. Single-source phis can be produced by loop unrolling
+    * or dead control-flow passes and are perfectly legal. Run a quick phi
     * removal on the block after the if to clean up any such phis.
     */
    nir_remove_single_src_phis_block(nir_cf_node_as_block(nir_cf_node_next(&nif->cf_node)));
 
-   /* Finally, move the continue from branch after the if-statement. */
+   /* Finally, move the continue-from branch after the if-statement. */
    nir_block* last_continue_from_blk = then_jump ? else_block : then_block;
    nir_block* first_continue_from_blk =
       then_jump ? nir_if_first_else_block(nif) : nir_if_first_then_block(nif);
@@ -106,13 +103,14 @@ sanitize_if(nir_function_impl* impl, nir
    return true;
 }
 
-bool
+static bool
 sanitize_cf_list(nir_function_impl* impl, struct exec_list* cf_list)
 {
    bool progress = false;
    foreach_list_typed (nir_cf_node, cf_node, node, cf_list) {
       switch (cf_node->type) {
-      case nir_cf_node_block: break;
+      case nir_cf_node_block:
+         break;
       case nir_cf_node_if: {
          nir_if* nif = nir_cf_node_as_if(cf_node);
          progress |= sanitize_cf_list(impl, &nif->then_list);
@@ -143,14 +141,15 @@ sanitize_cf_list(nir_function_impl* impl
          }
          break;
       }
-      case nir_cf_node_function: UNREACHABLE("Invalid cf type");
+      case nir_cf_node_function:
+         UNREACHABLE("Invalid cf type");
       }
    }
 
    return progress;
 }
 
-void
+static void
 apply_nuw_to_ssa(isel_context* ctx, nir_def* ssa)
 {
    nir_scalar scalar;
@@ -168,15 +167,15 @@ apply_nuw_to_ssa(isel_context* ctx, nir_
    nir_scalar src0 = nir_scalar_chase_alu_src(scalar, 0);
    nir_scalar src1 = nir_scalar_chase_alu_src(scalar, 1);
 
-   if (nir_scalar_is_const(src0)) {
+   if (nir_scalar_is_const(src0))
       std::swap(src0, src1);
-   }
 
+   /* Use NIR's upper-bound analysis to prove iadd nuw. */
    uint32_t src1_ub = nir_unsigned_upper_bound(ctx->shader, ctx->range_ht, src1);
    add->no_unsigned_wrap = !nir_addition_might_overflow(ctx->shader, ctx->range_ht, src0, src1_ub);
 }
 
-void
+static void
 apply_nuw_to_offsets(isel_context* ctx, nir_function_impl* impl)
 {
    nir_foreach_block (block, impl) {
@@ -201,20 +200,25 @@ apply_nuw_to_offsets(isel_context* ctx,
             if (!nir_src_is_divergent(&intrin->src[2]))
                apply_nuw_to_ssa(ctx, intrin->src[2].ssa);
             break;
-         case nir_intrinsic_load_scratch: apply_nuw_to_ssa(ctx, intrin->src[0].ssa); break;
+         case nir_intrinsic_load_scratch:
+            apply_nuw_to_ssa(ctx, intrin->src[0].ssa);
+            break;
          case nir_intrinsic_store_scratch:
-         case nir_intrinsic_load_smem_amd: apply_nuw_to_ssa(ctx, intrin->src[1].ssa); break;
+         case nir_intrinsic_load_smem_amd:
+            apply_nuw_to_ssa(ctx, intrin->src[1].ssa);
+            break;
          case nir_intrinsic_load_global_amd:
             if (nir_intrinsic_access(intrin) & ACCESS_SMEM_AMD)
                apply_nuw_to_ssa(ctx, intrin->src[1].ssa);
             break;
-         default: break;
+         default:
+            break;
          }
       }
    }
 }
 
-RegClass
+static inline RegClass
 get_reg_class(isel_context* ctx, RegType type, unsigned components, unsigned bitsize)
 {
    if (bitsize == 1)
@@ -223,14 +227,14 @@ get_reg_class(isel_context* ctx, RegType
       return RegClass::get(type, components * bitsize / 8u);
 }
 
-void
+static inline void
 setup_tcs_info(isel_context* ctx)
 {
    ctx->tcs_in_out_eq = ctx->program->info.vs.tcs_in_out_eq;
    ctx->any_tcs_inputs_via_lds = ctx->program->info.vs.any_tcs_inputs_via_lds;
 }
 
-void
+static inline void
 setup_lds_size(isel_context* ctx, nir_shader* nir)
 {
    /* TCS and GFX9 GS are special cases, already in units of the allocation granule. */
@@ -247,7 +251,7 @@ setup_lds_size(isel_context* ctx, nir_sh
           ctx->program->dev.lds_limit);
 }
 
-void
+static inline void
 setup_nir(isel_context* ctx, nir_shader* nir)
 {
    nir_convert_to_lcssa(nir, true, false);
@@ -266,7 +270,7 @@ setup_nir(isel_context* ctx, nir_shader*
  * some subgroup intrinsics and certain conversions) can use divergence analysis information which
  * is no longer correct.
  */
-bool
+static bool
 skip_uniformize_merge_phi(nir_def* ssa, unsigned depth)
 {
    if (depth >= 16)
@@ -292,11 +296,7 @@ skip_uniformize_merge_phi(nir_def* ssa,
          case nir_op_b2f32:
          case nir_op_b2f64:
          case nir_op_mov:
-            /* These opcodes p_as_uniform or vote_any() the source, so fail immediately. We don't
-             * need to do this for non-nir_op_b2 if we know we'll move it back into a VGPR,
-             * in which case the p_as_uniform would be eliminated. This would be way too fragile,
-             * though.
-             */
+            /* These opcodes p_as_uniform or vote_any() the source, so fail immediately. */
             return false;
          default:
             if (!skip_uniformize_merge_phi(&alu->def, depth + 1))
@@ -308,10 +308,7 @@ skip_uniformize_merge_phi(nir_def* ssa,
       case nir_instr_type_intrinsic: {
          nir_intrinsic_instr* intrin = nir_instr_as_intrinsic(nir_src_parent_instr(src));
          unsigned src_idx = src - intrin->src;
-         /* nir_intrinsic_lane_permute_16_amd is only safe because we don't use divergence analysis
-          * for it's instruction selection. We use that intrinsic for NGG culling. All others are
-          * stores with VGPR sources.
-          */
+         /* Safe intrinsics: either don't use divergence for ISel or use VGPR sources. */
          if (intrin->intrinsic == nir_intrinsic_lane_permute_16_amd ||
              intrin->intrinsic == nir_intrinsic_export_amd ||
              intrin->intrinsic == nir_intrinsic_export_dual_src_blend_amd ||
@@ -330,20 +327,18 @@ skip_uniformize_merge_phi(nir_def* ssa,
             break;
          return false;
       }
-      case nir_instr_type_tex: {
-         /* This is either used as a VGPR source or it's a (potentially undef) descriptor. */
+      case nir_instr_type_tex:
+         /* Either used as a VGPR source or it's a (potentially undef) descriptor. */
          break;
-      }
-      default: {
+      default:
          return false;
       }
-      }
    }
 
    return true;
 }
 
-bool
+static bool
 intrinsic_try_skip_helpers(nir_intrinsic_instr* intr, UNUSED void* data)
 {
    switch (intr->intrinsic) {
@@ -356,7 +351,8 @@ intrinsic_try_skip_helpers(nir_intrinsic
    case nir_intrinsic_bindless_image_fragment_mask_load_amd:
    case nir_intrinsic_bindless_image_sparse_load:
       return !(nir_intrinsic_access(intr) & ACCESS_SMEM_AMD);
-   default: return false;
+   default:
+      return false;
    }
 }
 
@@ -410,7 +406,14 @@ init_context(isel_context* ctx, nir_shad
    ctx->program->allocateRange(impl->ssa_alloc);
    RegClass* regclasses = ctx->program->temp_rc.data() + ctx->first_temp_id;
 
+   /* Pre-scan for calls once to pre-size call_infos precisely. */
    unsigned call_count = 0;
+   nir_foreach_block (pre_b, impl) {
+      nir_foreach_instr (pre_i, pre_b) {
+         if (pre_i->type == nir_instr_type_call)
+            ++call_count;
+      }
+   }
 
    /* TODO: make this recursive to improve compile times */
    bool done = false;
@@ -472,7 +475,9 @@ init_context(isel_context* ctx, nir_shad
                case nir_op_sdot_2x16_iadd_sat:
                case nir_op_bfdot2_bfadd:
                case nir_op_byte_perm_amd:
-               case nir_op_alignbyte_amd: type = RegType::vgpr; break;
+               case nir_op_alignbyte_amd:
+                  type = RegType::vgpr;
+                  break;
                case nir_op_fmul:
                case nir_op_ffma:
                case nir_op_fadd:
@@ -531,10 +536,9 @@ init_context(isel_context* ctx, nir_shad
                break;
             }
             case nir_instr_type_load_const: {
-               unsigned num_components = nir_instr_as_load_const(instr)->def.num_components;
-               unsigned bit_size = nir_instr_as_load_const(instr)->def.bit_size;
-               RegClass rc = get_reg_class(ctx, RegType::sgpr, num_components, bit_size);
-               regclasses[nir_instr_as_load_const(instr)->def.index] = rc;
+               nir_load_const_instr* lc = nir_instr_as_load_const(instr);
+               RegClass rc = get_reg_class(ctx, RegType::sgpr, lc->def.num_components, lc->def.bit_size);
+               regclasses[lc->def.index] = rc;
                break;
             }
             case nir_instr_type_intrinsic: {
@@ -567,7 +571,9 @@ init_context(isel_context* ctx, nir_shad
                case nir_intrinsic_bindless_image_samples:
                case nir_intrinsic_load_scalar_arg_amd:
                case nir_intrinsic_load_smem_amd:
-               case nir_intrinsic_unit_test_uniform_amd: type = RegType::sgpr; break;
+               case nir_intrinsic_unit_test_uniform_amd:
+                  type = RegType::sgpr;
+                  break;
                case nir_intrinsic_load_input:
                case nir_intrinsic_load_per_primitive_input:
                case nir_intrinsic_load_output:
@@ -598,13 +604,12 @@ init_context(isel_context* ctx, nir_shad
                case nir_intrinsic_load_vector_arg_amd:
                case nir_intrinsic_ordered_xfb_counter_add_gfx11_amd:
                case nir_intrinsic_cmat_muladd_amd:
-               case nir_intrinsic_unit_test_divergent_amd: type = RegType::vgpr; break;
+               case nir_intrinsic_unit_test_divergent_amd:
+                  type = RegType::vgpr;
+                  break;
                case nir_intrinsic_load_shared:
                case nir_intrinsic_load_shared2_amd:
-                  /* When the result of these loads is only used by cross-lane instructions,
-                   * it is beneficial to use a VGPR destination. This is because this allows
-                   * to put the s_waitcnt further down, which decreases latency.
-                   */
+                  /* When only used by cross-lane instructions, prefer VGPR to move s_waitcnt. */
                   if (only_used_by_cross_lane_instrs(&intrinsic->def)) {
                      type = RegType::vgpr;
                      break;
@@ -631,10 +636,11 @@ init_context(isel_context* ctx, nir_shad
                case nir_intrinsic_ddx_fine:
                case nir_intrinsic_ddy_fine:
                case nir_intrinsic_ddx_coarse:
-               case nir_intrinsic_ddy_coarse: type = RegType::vgpr; break;
+               case nir_intrinsic_ddy_coarse:
+                  type = RegType::vgpr;
+                  break;
                default:
-                  for (unsigned i = 0; i < nir_intrinsic_infos[intrinsic->intrinsic].num_srcs;
-                       i++) {
+                  for (unsigned i = 0; i < nir_intrinsic_infos[intrinsic->intrinsic].num_srcs; i++) {
                      if (regclasses[intrinsic->src[i].ssa->index].type() == RegType::vgpr)
                         type = RegType::vgpr;
                   }
@@ -655,10 +661,9 @@ init_context(isel_context* ctx, nir_shad
                break;
             }
             case nir_instr_type_undef: {
-               unsigned num_components = nir_instr_as_undef(instr)->def.num_components;
-               unsigned bit_size = nir_instr_as_undef(instr)->def.bit_size;
-               RegClass rc = get_reg_class(ctx, RegType::sgpr, num_components, bit_size);
-               regclasses[nir_instr_as_undef(instr)->def.index] = rc;
+               nir_undef_instr* und = nir_instr_as_undef(instr);
+               RegClass rc = get_reg_class(ctx, RegType::sgpr, und->def.num_components, und->def.bit_size);
+               regclasses[und->def.index] = rc;
                break;
             }
             case nir_instr_type_phi: {
@@ -700,11 +705,11 @@ init_context(isel_context* ctx, nir_shad
                regclasses[phi->def.index] = rc;
                break;
             }
-            case nir_instr_type_call: {
-               ++call_count;
+            case nir_instr_type_call:
+               /* Calls pre-counted above; nothing to do here. */
+               break;
+            default:
                break;
-            }
-            default: break;
             }
          }
       }
