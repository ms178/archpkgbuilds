From 20be68954456ee454957a0ed4855fe2bf5111120 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 20 May 2022 14:17:36 +0100
Subject: [PATCH 1/3] nir/deref: consider multiple bindings in a single
 variable to be separate

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_deref.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_deref.c b/src/compiler/nir/nir_deref.c
index 4faad2657ca0..c43ebf4d7d2b 100644
--- a/src/compiler/nir/nir_deref.c
+++ b/src/compiler/nir/nir_deref.c
@@ -475,7 +475,17 @@ nir_compare_deref_paths(nir_deref_path *a_path,
       return nir_derefs_may_alias_bit;
 
    if (a_path->path[0]->deref_type == nir_deref_type_var) {
-      if (a_path->path[0]->var != b_path->path[0]->var) {
+      bool different_vars = a_path->path[0]->var != b_path->path[0]->var;
+
+      /* When a SSBO/UBO is an array, then this is several bindings in the same variable. */
+      if (!different_vars && glsl_type_is_array(a_path->path[0]->var->type) &&
+          a_path->path[0]->var->data.mode & (nir_var_mem_ubo | nir_var_mem_ssbo)) {
+         assert(a_path->path[1]->deref_type == nir_deref_type_array);
+         assert(b_path->path[1]->deref_type == nir_deref_type_array);
+         different_vars |= a_path->path[1]->arr.index.ssa != b_path->path[1]->arr.index.ssa;
+      }
+
+      if (different_vars) {
          /* Shader and function temporaries aren't backed by memory so two
           * distinct variables never alias.
           */
-- 
GitLab


From a0bdc62cf02b159e6aea415496c7c2a81e1fac58 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 20 May 2022 14:18:17 +0100
Subject: [PATCH 2/3] nir/deref: consider two ssbos to be aliasing if restrict
 is missing

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_deref.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/compiler/nir/nir_deref.c b/src/compiler/nir/nir_deref.c
index c43ebf4d7d2b..b858351873f5 100644
--- a/src/compiler/nir/nir_deref.c
+++ b/src/compiler/nir/nir_deref.c
@@ -495,6 +495,15 @@ nir_compare_deref_paths(nir_deref_path *a_path,
              !(b_path->path[0]->modes & ~temp_var_modes))
             return nir_derefs_do_not_alias;
 
+         /* If both are SSBOs and neither are declared restrict, we have to
+          * assume we that we could have any kind of aliasing.
+          */
+         if (a_path->path[0]->modes & nir_var_mem_ssbo &&
+             b_path->path[0]->modes & nir_var_mem_ssbo &&
+             !(a_path->path[0]->var->data.access & ACCESS_RESTRICT) &&
+             !(b_path->path[0]->var->data.access & ACCESS_RESTRICT))
+            return nir_derefs_may_alias_bit;
+
          /* If they are both declared coherent or have coherent somewhere in
           * their path (due to a member of an interface being declared
           * coherent), we have to assume we that we could have any kind of
-- 
GitLab


From 7e265390b3626da6b9088c460898903f3441f040 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 20 May 2022 14:28:29 +0100
Subject: [PATCH 3/3] nir/deref: stop assuming coherent accesses of different
 SSBOs may alias

Whether it's coherent should be irrelevant and the ACCESS_RESTRICT check
above should consider all cases aliasing unless NIR makes it clear they're
not.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_deref.c | 32 --------------------------------
 1 file changed, 32 deletions(-)

diff --git a/src/compiler/nir/nir_deref.c b/src/compiler/nir/nir_deref.c
index b858351873f5..1bc14310fe70 100644
--- a/src/compiler/nir/nir_deref.c
+++ b/src/compiler/nir/nir_deref.c
@@ -442,28 +442,6 @@ modes_may_alias(nir_variable_mode a, nir_variable_mode b)
    return a & b;
 }
 
-static bool
-deref_path_contains_coherent_decoration(nir_deref_path *path)
-{
-   assert(path->path[0]->deref_type == nir_deref_type_var);
-
-   if (path->path[0]->var->data.access & ACCESS_COHERENT)
-      return true;
-
-   for (nir_deref_instr **p = &path->path[1]; *p; p++) {
-      if ((*p)->deref_type != nir_deref_type_struct)
-         continue;
-
-      const struct glsl_type *struct_type = (*(p - 1))->type;
-      const struct glsl_struct_field *field =
-         glsl_get_struct_field_data(struct_type, (*p)->strct.index);
-      if (field->memory_coherent)
-         return true;
-   }
-
-   return false;
-}
-
 nir_deref_compare_result
 nir_compare_deref_paths(nir_deref_path *a_path,
                         nir_deref_path *b_path)
@@ -504,16 +482,6 @@ nir_compare_deref_paths(nir_deref_path *a_path,
              !(b_path->path[0]->var->data.access & ACCESS_RESTRICT))
             return nir_derefs_may_alias_bit;
 
-         /* If they are both declared coherent or have coherent somewhere in
-          * their path (due to a member of an interface being declared
-          * coherent), we have to assume we that we could have any kind of
-          * aliasing.  Otherwise, they could still alias but the client didn't
-          * tell us and that's their fault.
-          */
-         if (deref_path_contains_coherent_decoration(a_path) &&
-             deref_path_contains_coherent_decoration(b_path))
-            return nir_derefs_may_alias_bit;
-
          /* Per SPV_KHR_workgroup_memory_explicit_layout and GL_EXT_shared_memory_block,
           * shared blocks alias each other.
           */
-- 
GitLab

