From 94d4876f6c8b3245e0558cc122b35fb04768afaa Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 20 May 2022 16:07:13 +0200
Subject: [PATCH 1/9] radv: copy viewport/scissor when initializing
 radv_viewport_info

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 26 ++++++++++++++++++--------
 src/amd/vulkan/radv_private.h  |  4 ++++
 2 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index b17b97bc8b03..a15df25f6ddf 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1693,6 +1693,20 @@ radv_pipeline_init_viewport_info(struct radv_graphics_pipeline *pipeline,
    struct radv_viewport_info info = {0};

    if (radv_is_raster_enabled(pipeline, pCreateInfo)) {
+      if (!(pipeline->dynamic_states & RADV_DYNAMIC_VIEWPORT)) {
+         for (uint32_t i = 0; i < vp->viewportCount; i++) {
+            info.viewports[i] = vp->pViewports[i];
+         }
+      }
+      info.viewport_count = vp->viewportCount;
+
+      if (!(pipeline->dynamic_states & RADV_DYNAMIC_SCISSOR)) {
+         for (uint32_t i = 0; i < vp->scissorCount; i++) {
+            info.scissors[i] = vp->pScissors[i];
+         }
+      }
+      info.scissor_count = vp->scissorCount;
+
       const VkPipelineViewportDepthClipControlCreateInfoEXT *depth_clip_control =
          vk_find_struct_const(vp->pNext, PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT);
       if (depth_clip_control) {
@@ -1816,12 +1830,9 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
    struct radv_dynamic_state *dynamic = &pipeline->dynamic_state;

    if (needed_states & RADV_DYNAMIC_VIEWPORT) {
-      assert(pCreateInfo->pViewportState);
-
-      dynamic->viewport.count = pCreateInfo->pViewportState->viewportCount;
+      dynamic->viewport.count = info->vp.viewport_count;
       if (states & RADV_DYNAMIC_VIEWPORT) {
-         typed_memcpy(dynamic->viewport.viewports, pCreateInfo->pViewportState->pViewports,
-                      pCreateInfo->pViewportState->viewportCount);
+         typed_memcpy(dynamic->viewport.viewports, info->vp.viewports, info->vp.viewport_count);
          for (unsigned i = 0; i < dynamic->viewport.count; i++)
             radv_get_viewport_xform(&dynamic->viewport.viewports[i],
                                     dynamic->viewport.xform[i].scale, dynamic->viewport.xform[i].translate);
@@ -1829,10 +1840,9 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
    }

    if (needed_states & RADV_DYNAMIC_SCISSOR) {
-      dynamic->scissor.count = pCreateInfo->pViewportState->scissorCount;
+      dynamic->scissor.count = info->vp.scissor_count;
       if (states & RADV_DYNAMIC_SCISSOR) {
-         typed_memcpy(dynamic->scissor.scissors, pCreateInfo->pViewportState->pScissors,
-                      pCreateInfo->pViewportState->scissorCount);
+         typed_memcpy(dynamic->scissor.scissors, info->vp.scissors, info->vp.scissor_count);
       }
    }

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 9d7bca31a9c5..2620fbc8dd6f 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1884,6 +1884,10 @@ struct radv_tessellation_info {
 };

 struct radv_viewport_info {
+   VkRect2D scissors[MAX_SCISSORS];
+   uint32_t scissor_count;
+   VkViewport viewports[MAX_VIEWPORTS];
+   uint32_t viewport_count;
    bool negative_one_to_one;
 };

--
GitLab


From 98e9caf75bc0eefd180650220981b586f22094bd Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 19 May 2022 16:04:17 +0200
Subject: [PATCH 2/9] radv: init states from pMultisampleState at only one
 place

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 203 +++++++++++++++++----------------
 src/amd/vulkan/radv_private.h  |  15 +++
 2 files changed, 121 insertions(+), 97 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index a15df25f6ddf..388bd45045f2 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -104,15 +104,6 @@ radv_is_vrs_enabled(const struct radv_graphics_pipeline *pipeline,
           (pipeline->dynamic_states & RADV_DYNAMIC_FRAGMENT_SHADING_RATE);
 }

-static const VkPipelineMultisampleStateCreateInfo *
-radv_pipeline_get_multisample_state(const struct radv_graphics_pipeline *pipeline,
-                                    const VkGraphicsPipelineCreateInfo *pCreateInfo)
-{
-   if (radv_is_raster_enabled(pipeline, pCreateInfo))
-      return pCreateInfo->pMultisampleState;
-   return NULL;
-}
-
 static bool
 radv_pipeline_has_ds_attachments(const VkGraphicsPipelineCreateInfo *pCreateInfo)
 {
@@ -675,13 +666,12 @@ radv_blend_check_commutativity(struct radv_blend_state *blend, VkBlendOp op, VkB

 static struct radv_blend_state
 radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
-                               const VkGraphicsPipelineCreateInfo *pCreateInfo)
+                               const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                               const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_device *device = pipeline->base.device;
    const VkPipelineColorBlendStateCreateInfo *vkblend =
       radv_pipeline_get_color_blend_state(pipeline, pCreateInfo);
-   const VkPipelineMultisampleStateCreateInfo *vkms =
-      radv_pipeline_get_multisample_state(pipeline, pCreateInfo);
    struct radv_blend_state blend = {0};
    unsigned cb_color_control = 0;
    const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
@@ -707,7 +697,7 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
                                S_028B70_OFFSET_ROUND(1);
    }

-   if (vkms && vkms->alphaToCoverageEnable) {
+   if (info->ms.alpha_to_coverage_enable) {
       blend.db_alpha_to_mask |= S_028B70_ALPHA_TO_MASK_ENABLE(1);
       blend.need_src_alpha |= 0x1;
    }
@@ -873,7 +863,8 @@ si_translate_fill(VkPolygonMode func)
 }

 static unsigned
-radv_pipeline_color_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo)
+radv_pipeline_color_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                            const struct radv_graphics_pipeline_info *info)
 {
    const VkAttachmentSampleCountInfoAMD *sample_info =
       vk_find_struct_const(pCreateInfo->pNext, ATTACHMENT_SAMPLE_COUNT_INFO_AMD);
@@ -888,12 +879,13 @@ radv_pipeline_color_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo)
       }
       return samples;
    }
-   const VkPipelineMultisampleStateCreateInfo *vkms = pCreateInfo->pMultisampleState;
-   return vkms ? vkms->rasterizationSamples : 1;
+
+   return info->ms.raster_samples;
 }

 static unsigned
-radv_pipeline_depth_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo)
+radv_pipeline_depth_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                            const struct radv_graphics_pipeline_info *info)
 {
    const VkAttachmentSampleCountInfoAMD *sample_info =
       vk_find_struct_const(pCreateInfo->pNext, ATTACHMENT_SAMPLE_COUNT_INFO_AMD);
@@ -902,19 +894,19 @@ radv_pipeline_depth_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo)
          return sample_info->depthStencilAttachmentSamples;
       }
    }
-   const VkPipelineMultisampleStateCreateInfo *vkms = pCreateInfo->pMultisampleState;
-   return vkms ? vkms->rasterizationSamples : 1;
+
+   return info->ms.raster_samples;
 }

 static uint8_t
-radv_pipeline_get_ps_iter_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo)
+radv_pipeline_get_ps_iter_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                                  const struct radv_graphics_pipeline_info *info)
 {
-   const VkPipelineMultisampleStateCreateInfo *vkms = pCreateInfo->pMultisampleState;
    uint32_t ps_iter_samples = 1;
-   uint32_t num_samples = radv_pipeline_color_samples(pCreateInfo);
+   uint32_t num_samples = radv_pipeline_color_samples(pCreateInfo, info);

-   if (vkms->sampleShadingEnable) {
-      ps_iter_samples = ceilf(vkms->minSampleShading * num_samples);
+   if (info->ms.sample_shading_enable) {
+      ps_iter_samples = ceilf(info->ms.min_sample_shading * num_samples);
       ps_iter_samples = util_next_power_of_two(ps_iter_samples);
    }
    return ps_iter_samples;
@@ -1092,41 +1084,34 @@ radv_pipeline_init_multisample_state(struct radv_graphics_pipeline *pipeline,
                                      const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-   const VkPipelineMultisampleStateCreateInfo *vkms =
-      radv_pipeline_get_multisample_state(pipeline, pCreateInfo);
    struct radv_multisample_state *ms = &pipeline->ms;
    unsigned num_tile_pipes = pdevice->rad_info.num_tile_pipes;
    const VkConservativeRasterizationModeEXT mode = info->rs.conservative_mode;
    bool out_of_order_rast = false;
    int ps_iter_samples = 1;
-   uint32_t mask = 0xffff;

-   if (vkms) {
-      ms->num_samples = vkms->rasterizationSamples;
+   ms->num_samples = info->ms.raster_samples;

-      /* From the Vulkan 1.1.129 spec, 26.7. Sample Shading:
-       *
-       * "Sample shading is enabled for a graphics pipeline:
-       *
-       * - If the interface of the fragment shader entry point of the
-       *   graphics pipeline includes an input variable decorated
-       *   with SampleId or SamplePosition. In this case
-       *   minSampleShadingFactor takes the value 1.0.
-       * - Else if the sampleShadingEnable member of the
-       *   VkPipelineMultisampleStateCreateInfo structure specified
-       *   when creating the graphics pipeline is set to VK_TRUE. In
-       *   this case minSampleShadingFactor takes the value of
-       *   VkPipelineMultisampleStateCreateInfo::minSampleShading.
-       *
-       * Otherwise, sample shading is considered disabled."
-       */
-      if (pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.uses_sample_shading) {
-         ps_iter_samples = ms->num_samples;
-      } else {
-         ps_iter_samples = radv_pipeline_get_ps_iter_samples(pCreateInfo);
-      }
+   /* From the Vulkan 1.1.129 spec, 26.7. Sample Shading:
+    *
+    * "Sample shading is enabled for a graphics pipeline:
+    *
+    * - If the interface of the fragment shader entry point of the
+    *   graphics pipeline includes an input variable decorated
+    *   with SampleId or SamplePosition. In this case
+    *   minSampleShadingFactor takes the value 1.0.
+    * - Else if the sampleShadingEnable member of the
+    *   VkPipelineMultisampleStateCreateInfo structure specified
+    *   when creating the graphics pipeline is set to VK_TRUE. In
+    *   this case minSampleShadingFactor takes the value of
+    *   VkPipelineMultisampleStateCreateInfo::minSampleShading.
+    *
+    * Otherwise, sample shading is considered disabled."
+    */
+   if (pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.uses_sample_shading) {
+      ps_iter_samples = ms->num_samples;
    } else {
-      ms->num_samples = 1;
+      ps_iter_samples = radv_pipeline_get_ps_iter_samples(pCreateInfo, info);
    }

    if (info->rs.order == VK_RASTERIZATION_ORDER_RELAXED_AMD) {
@@ -1177,7 +1162,7 @@ radv_pipeline_init_multisample_state(struct radv_graphics_pipeline *pipeline,
    }

    if (ms->num_samples > 1) {
-      uint32_t z_samples = radv_pipeline_depth_samples(pCreateInfo);
+      uint32_t z_samples = radv_pipeline_depth_samples(pCreateInfo, info);
       unsigned log_samples = util_logbase2(ms->num_samples);
       unsigned log_z_samples = util_logbase2(z_samples);
       unsigned log_ps_iter_samples = util_logbase2(ps_iter_samples);
@@ -1196,26 +1181,21 @@ radv_pipeline_init_multisample_state(struct radv_graphics_pipeline *pipeline,
          pipeline->spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
    }

-   if (vkms && vkms->pSampleMask) {
-      mask = vkms->pSampleMask[0] & 0xffff;
-   }
-
-   ms->pa_sc_aa_mask[0] = mask | (mask << 16);
-   ms->pa_sc_aa_mask[1] = mask | (mask << 16);
+   ms->pa_sc_aa_mask[0] = info->ms.sample_mask | (info->ms.sample_mask << 16);
+   ms->pa_sc_aa_mask[1] = info->ms.sample_mask | (info->ms.sample_mask << 16);
 }

 static void
 gfx103_pipeline_init_vrs_state(struct radv_graphics_pipeline *pipeline,
-                               const VkGraphicsPipelineCreateInfo *pCreateInfo)
+                               const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                               const struct radv_graphics_pipeline_info *info)
 {
-   const VkPipelineMultisampleStateCreateInfo *vkms =
-      radv_pipeline_get_multisample_state(pipeline, pCreateInfo);
    struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
    struct radv_multisample_state *ms = &pipeline->ms;
    struct radv_vrs_state *vrs = &pipeline->vrs;

-   if (vkms && (vkms->sampleShadingEnable || ps->info.ps.uses_sample_shading ||
-                ps->info.ps.reads_sample_mask_in)) {
+   if (info->ms.sample_shading_enable ||
+       ps->info.ps.uses_sample_shading || ps->info.ps.reads_sample_mask_in) {
       /* Disable VRS and use the rates from PS_ITER_SAMPLES if:
        *
        * 1) sample shading is enabled or per-sample interpolation is
@@ -1773,6 +1753,51 @@ radv_pipeline_init_rasterization_info(struct radv_graphics_pipeline *pipeline,
    return info;
 }

+static struct radv_multisample_info
+radv_pipeline_init_multisample_info(struct radv_graphics_pipeline *pipeline,
+                                    const VkGraphicsPipelineCreateInfo *pCreateInfo)
+{
+   const VkPipelineMultisampleStateCreateInfo *ms = pCreateInfo->pMultisampleState;
+   struct radv_multisample_info info = {0};
+
+   if (radv_is_raster_enabled(pipeline, pCreateInfo)) {
+      info.raster_samples = ms->rasterizationSamples;
+      info.sample_shading_enable = ms->sampleShadingEnable;
+      info.min_sample_shading = ms->minSampleShading;
+      info.alpha_to_coverage_enable = ms->alphaToCoverageEnable;
+      if (ms->pSampleMask) {
+         info.sample_mask = ms->pSampleMask[0] & 0xffff;
+      } else {
+         info.sample_mask = 0xffff;
+      }
+
+      const VkPipelineSampleLocationsStateCreateInfoEXT *sample_location_info =
+         vk_find_struct_const(ms->pNext, PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT);
+      if (sample_location_info) {
+         /* If sampleLocationsEnable is VK_FALSE, the default sample locations are used and the
+          * values specified in sampleLocationsInfo are ignored.
+          */
+         info.sample_locs_enable = sample_location_info->sampleLocationsEnable;
+         if (sample_location_info->sampleLocationsEnable) {
+            const VkSampleLocationsInfoEXT *pSampleLocationsInfo =
+               &sample_location_info->sampleLocationsInfo;
+            assert(pSampleLocationsInfo->sampleLocationsCount <= MAX_SAMPLE_LOCATIONS);
+
+            info.sample_locs_per_pixel = pSampleLocationsInfo->sampleLocationsPerPixel;
+            info.sample_locs_grid_size = pSampleLocationsInfo->sampleLocationGridSize;
+            for (uint32_t i = 0; i < pSampleLocationsInfo->sampleLocationsCount; i++) {
+               info.sample_locs[i] = pSampleLocationsInfo->pSampleLocations[i];
+            }
+            info.sample_locs_count = pSampleLocationsInfo->sampleLocationsCount;
+         }
+      }
+   } else {
+      info.raster_samples = VK_SAMPLE_COUNT_1_BIT;
+   }
+
+   return info;
+}
+
 static struct radv_graphics_pipeline_info
 radv_pipeline_init_graphics_info(struct radv_graphics_pipeline *pipeline,
                                  const VkGraphicsPipelineCreateInfo *pCreateInfo)
@@ -1789,6 +1814,8 @@ radv_pipeline_init_graphics_info(struct radv_graphics_pipeline *pipeline,
    info.vp = radv_pipeline_init_viewport_info(pipeline, pCreateInfo);
    info.rs = radv_pipeline_init_rasterization_info(pipeline, pCreateInfo);

+   info.ms = radv_pipeline_init_multisample_info(pipeline, pCreateInfo);
+
    return info;
 }

@@ -1958,25 +1985,12 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
    }

    if (needed_states & RADV_DYNAMIC_SAMPLE_LOCATIONS) {
-      const VkPipelineSampleLocationsStateCreateInfoEXT *sample_location_info =
-         vk_find_struct_const(pCreateInfo->pMultisampleState->pNext,
-                              PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT);
-      /* If sampleLocationsEnable is VK_FALSE, the default sample
-       * locations are used and the values specified in
-       * sampleLocationsInfo are ignored.
-       */
-      if (sample_location_info->sampleLocationsEnable) {
-         const VkSampleLocationsInfoEXT *pSampleLocationsInfo =
-            &sample_location_info->sampleLocationsInfo;
-
-         assert(pSampleLocationsInfo->sampleLocationsCount <= MAX_SAMPLE_LOCATIONS);
-
-         dynamic->sample_location.per_pixel = pSampleLocationsInfo->sampleLocationsPerPixel;
-         dynamic->sample_location.grid_size = pSampleLocationsInfo->sampleLocationGridSize;
-         dynamic->sample_location.count = pSampleLocationsInfo->sampleLocationsCount;
-         typed_memcpy(&dynamic->sample_location.locations[0],
-                      pSampleLocationsInfo->pSampleLocations,
-                      pSampleLocationsInfo->sampleLocationsCount);
+      if (info->ms.sample_locs_enable) {
+         dynamic->sample_location.per_pixel = info->ms.sample_locs_per_pixel;
+         dynamic->sample_location.grid_size = info->ms.sample_locs_grid_size;
+         dynamic->sample_location.count = info->ms.sample_locs_count;
+         typed_memcpy(&dynamic->sample_location.locations[0], info->ms.sample_locs,
+                      info->ms.sample_locs_count);
       }
    }

@@ -2087,10 +2101,8 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,

    if (ds_info) {
       if (has_depth_attachment) {
-         const VkPipelineMultisampleStateCreateInfo *vkms = pCreateInfo->pMultisampleState;
-
          /* from amdvlk: For 4xAA and 8xAA need to decompress on flush for better performance */
-         ds_state.db_render_override2 |= S_028010_DECOMPRESS_Z_ON_FLUSH(vkms && vkms->rasterizationSamples > 2);
+         ds_state.db_render_override2 |= S_028010_DECOMPRESS_Z_ON_FLUSH(info->ms.raster_samples > 2);

          if (pdevice->rad_info.gfx_level >= GFX10_3)
             ds_state.db_render_override2 |= S_028010_CENTROID_COMPUTATION_MODE(1);
@@ -2127,8 +2139,8 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,

    if (pdevice->rad_info.gfx_level >= GFX11) {
       unsigned max_allowed_tiles_in_wave = 0;
-      unsigned num_samples = MAX2(radv_pipeline_color_samples(pCreateInfo),
-                                  radv_pipeline_depth_samples(pCreateInfo));
+      unsigned num_samples = MAX2(radv_pipeline_color_samples(pCreateInfo, info),
+                                  radv_pipeline_depth_samples(pCreateInfo, info));

       if (pdevice->rad_info.has_dedicated_vram) {
          if (num_samples == 8)
@@ -3263,12 +3275,9 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin

    key.tcs.tess_input_vertices = info->ts.patch_control_points;

-   const VkPipelineMultisampleStateCreateInfo *vkms =
-      radv_pipeline_get_multisample_state(pipeline, pCreateInfo);
-   if (vkms && vkms->rasterizationSamples > 1) {
-      uint32_t num_samples = vkms->rasterizationSamples;
-      uint32_t ps_iter_samples = radv_pipeline_get_ps_iter_samples(pCreateInfo);
-      key.ps.num_samples = num_samples;
+   if (info->ms.raster_samples > 1) {
+      uint32_t ps_iter_samples = radv_pipeline_get_ps_iter_samples(pCreateInfo, info);
+      key.ps.num_samples = info->ms.raster_samples;
       key.ps.log2_ps_iter_samples = util_logbase2(ps_iter_samples);
    }

@@ -3280,7 +3289,7 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
       key.ps.is_int10 = blend->col_format_is_int10;
    }
    if (device->physical_device->rad_info.gfx_level >= GFX11) {
-      key.ps.alpha_to_coverage_via_mrtz = G_028B70_ALPHA_TO_MASK_ENABLE(blend->db_alpha_to_mask);
+      key.ps.alpha_to_coverage_via_mrtz = info->ms.alpha_to_coverage_enable;
    }

    key.vs.topology = info->ia.primitive_topology;
@@ -6877,10 +6886,10 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       pipeline->base.active_stages |= sinfo->stage;
    }

-   struct radv_blend_state blend = radv_pipeline_init_blend_state(pipeline, pCreateInfo);
-
    struct radv_graphics_pipeline_info info = radv_pipeline_init_graphics_info(pipeline, pCreateInfo);

+   struct radv_blend_state blend = radv_pipeline_init_blend_state(pipeline, pCreateInfo, &info);
+
    const VkPipelineCreationFeedbackCreateInfo *creation_feedback =
       vk_find_struct_const(pCreateInfo->pNext, PIPELINE_CREATION_FEEDBACK_CREATE_INFO);

@@ -6908,7 +6917,7 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       radv_pipeline_init_depth_stencil_state(pipeline, pCreateInfo, &info);

    if (device->physical_device->rad_info.gfx_level >= GFX10_3)
-      gfx103_pipeline_init_vrs_state(pipeline, pCreateInfo);
+      gfx103_pipeline_init_vrs_state(pipeline, pCreateInfo, &info);

    /* Ensure that some export memory is always allocated, for two reasons:
     *
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 2620fbc8dd6f..527e4487f357 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1912,6 +1912,19 @@ struct radv_rasterization_info {
    VkRasterizationOrderAMD order;
 };

+struct radv_multisample_info {
+   VkSampleCountFlagBits raster_samples;
+   bool sample_shading_enable;
+   float min_sample_shading;
+   bool alpha_to_coverage_enable;
+   uint32_t sample_mask;
+   bool sample_locs_enable;
+   VkSampleCountFlagBits sample_locs_per_pixel;
+   VkExtent2D sample_locs_grid_size;
+   VkSampleLocationEXT sample_locs[MAX_SAMPLE_LOCATIONS];
+   uint32_t sample_locs_count;
+};
+
 struct radv_graphics_pipeline_info {
    struct radv_vertex_input_info vi;
    struct radv_input_assembly_info ia;
@@ -1919,6 +1932,8 @@ struct radv_graphics_pipeline_info {
    struct radv_tessellation_info ts;
    struct radv_viewport_info vp;
    struct radv_rasterization_info rs;
+
+   struct radv_multisample_info ms;
 };

 struct radv_pipeline {
--
GitLab

From 25eb1eeb31cbdcdc6e88ebe88c74aa0d5e45ebb0 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 18 May 2022 09:22:59 +0200
Subject: [PATCH 3/9] radv: init states from pDepthStencilState at only one
 place

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 288 ++++++++++++++++++---------------
 src/amd/vulkan/radv_private.h  |  39 +++++
 2 files changed, 196 insertions(+), 131 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 388bd45045f2..e043c1d5b0f6 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -113,17 +113,6 @@ radv_pipeline_has_ds_attachments(const VkGraphicsPipelineCreateInfo *pCreateInfo
            render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED);
 }

-static const VkPipelineDepthStencilStateCreateInfo *
-radv_pipeline_get_depth_stencil_state(const struct radv_graphics_pipeline *pipeline,
-                                      const VkGraphicsPipelineCreateInfo *pCreateInfo)
-{
-   bool has_ds_att = radv_pipeline_has_ds_attachments(pCreateInfo);
-
-   if (radv_is_raster_enabled(pipeline, pCreateInfo) && has_ds_att)
-      return pCreateInfo->pDepthStencilState;
-   return NULL;
-}
-
 static bool
 radv_pipeline_has_color_attachments(const VkGraphicsPipelineCreateInfo *pCreateInfo)
 {
@@ -913,31 +902,27 @@ radv_pipeline_get_ps_iter_samples(const VkGraphicsPipelineCreateInfo *pCreateInf
 }

 static bool
-radv_is_depth_write_enabled(const VkPipelineDepthStencilStateCreateInfo *pCreateInfo)
-{
-   return pCreateInfo->depthTestEnable && pCreateInfo->depthWriteEnable &&
-          pCreateInfo->depthCompareOp != VK_COMPARE_OP_NEVER;
-}
-
-static bool
-radv_writes_stencil(const VkStencilOpState *state)
+radv_is_depth_write_enabled(const struct radv_depth_stencil_info *ds_info)
 {
-   return state->writeMask &&
-          (state->failOp != VK_STENCIL_OP_KEEP || state->passOp != VK_STENCIL_OP_KEEP ||
-           state->depthFailOp != VK_STENCIL_OP_KEEP);
+   return ds_info->depth_test_enable && ds_info->depth_write_enable &&
+          ds_info->depth_compare_op != VK_COMPARE_OP_NEVER;
 }

 static bool
-radv_is_stencil_write_enabled(const VkPipelineDepthStencilStateCreateInfo *pCreateInfo)
+radv_is_stencil_write_enabled(const struct radv_depth_stencil_info *ds_info)
 {
-   return pCreateInfo->stencilTestEnable &&
-          (radv_writes_stencil(&pCreateInfo->front) || radv_writes_stencil(&pCreateInfo->back));
-}
+   const bool writes_stencil_front =
+      ds_info->stencil_write_mask.front &&
+      (ds_info->stencil_op.front.fail_op != VK_STENCIL_OP_KEEP ||
+       ds_info->stencil_op.front.pass_op != VK_STENCIL_OP_KEEP ||
+       ds_info->stencil_op.front.depth_fail_op != VK_STENCIL_OP_KEEP);
+   const bool writes_stencil_back =
+      ds_info->stencil_write_mask.back &&
+      (ds_info->stencil_op.back.fail_op != VK_STENCIL_OP_KEEP ||
+       ds_info->stencil_op.back.pass_op != VK_STENCIL_OP_KEEP ||
+       ds_info->stencil_op.back.depth_fail_op != VK_STENCIL_OP_KEEP);

-static bool
-radv_is_ds_write_enabled(const VkPipelineDepthStencilStateCreateInfo *pCreateInfo)
-{
-   return radv_is_depth_write_enabled(pCreateInfo) || radv_is_stencil_write_enabled(pCreateInfo);
+   return ds_info->stencil_test_enable && (writes_stencil_front || writes_stencil_back);
 }

 static bool
@@ -952,20 +937,31 @@ radv_order_invariant_stencil_op(VkStencilOp op)
 }

 static bool
-radv_order_invariant_stencil_state(const VkStencilOpState *state)
+radv_order_invariant_stencil_state(const struct radv_depth_stencil_info *ds_info)
 {
    /* Compute whether, assuming Z writes are disabled, this stencil state
     * is order invariant in the sense that the set of passing fragments as
     * well as the final stencil buffer result does not depend on the order
     * of fragments.
     */
-   return !state->writeMask ||
-          /* The following assumes that Z writes are disabled. */
-          (state->compareOp == VK_COMPARE_OP_ALWAYS &&
-           radv_order_invariant_stencil_op(state->passOp) &&
-           radv_order_invariant_stencil_op(state->depthFailOp)) ||
-          (state->compareOp == VK_COMPARE_OP_NEVER &&
-           radv_order_invariant_stencil_op(state->failOp));
+   const bool order_invariant_front =
+      !ds_info->stencil_write_mask.front ||
+      /* The following assumes that Z writes are disabled. */
+      (ds_info->stencil_op.front.compare_op == VK_COMPARE_OP_ALWAYS &&
+       radv_order_invariant_stencil_op(ds_info->stencil_op.front.pass_op) &&
+       radv_order_invariant_stencil_op(ds_info->stencil_op.front.depth_fail_op)) ||
+      (ds_info->stencil_op.front.compare_op == VK_COMPARE_OP_NEVER &&
+       radv_order_invariant_stencil_op(ds_info->stencil_op.front.fail_op));
+   const bool order_invariant_back =
+      !ds_info->stencil_write_mask.back ||
+      /* The following assumes that Z writes are disabled. */
+      (ds_info->stencil_op.back.compare_op == VK_COMPARE_OP_ALWAYS &&
+       radv_order_invariant_stencil_op(ds_info->stencil_op.back.pass_op) &&
+       radv_order_invariant_stencil_op(ds_info->stencil_op.back.depth_fail_op)) ||
+      (ds_info->stencil_op.back.compare_op == VK_COMPARE_OP_NEVER &&
+       radv_order_invariant_stencil_op(ds_info->stencil_op.back.fail_op));
+
+   return order_invariant_front && order_invariant_back;
 }

 static bool
@@ -981,12 +977,11 @@ radv_pipeline_has_dynamic_ds_states(const struct radv_graphics_pipeline *pipelin
 static bool
 radv_pipeline_out_of_order_rast(struct radv_graphics_pipeline *pipeline,
                                 const struct radv_blend_state *blend,
-                                const VkGraphicsPipelineCreateInfo *pCreateInfo)
+                                const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                                const struct radv_graphics_pipeline_info *info)
 {
    const VkPipelineRenderingCreateInfo *render_create_info =
       vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
-   const VkPipelineDepthStencilStateCreateInfo *vkds =
-      radv_pipeline_get_depth_stencil_state(pipeline, pCreateInfo);
    const VkPipelineColorBlendStateCreateInfo *vkblend =
       radv_pipeline_get_color_blend_state(pipeline, pCreateInfo);
    unsigned colormask = blend->cb_target_enabled_4bit;
@@ -1008,53 +1003,54 @@ radv_pipeline_out_of_order_rast(struct radv_graphics_pipeline *pipeline,
    /* Default depth/stencil invariance when no attachment is bound. */
    struct radv_dsa_order_invariance dsa_order_invariant = {.zs = true, .pass_set = true};

-   if (vkds) {
-      bool has_stencil = render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED;
-      struct radv_dsa_order_invariance order_invariance[2];
-      struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
+   bool has_stencil = render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED;
+   struct radv_dsa_order_invariance order_invariance[2];
+   struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];

-      /* Compute depth/stencil order invariance in order to know if
-       * it's safe to enable out-of-order.
-       */
-      bool zfunc_is_ordered = vkds->depthCompareOp == VK_COMPARE_OP_NEVER ||
-                              vkds->depthCompareOp == VK_COMPARE_OP_LESS ||
-                              vkds->depthCompareOp == VK_COMPARE_OP_LESS_OR_EQUAL ||
-                              vkds->depthCompareOp == VK_COMPARE_OP_GREATER ||
-                              vkds->depthCompareOp == VK_COMPARE_OP_GREATER_OR_EQUAL;
-
-      bool nozwrite_and_order_invariant_stencil =
-         !radv_is_ds_write_enabled(vkds) ||
-         (!radv_is_depth_write_enabled(vkds) && radv_order_invariant_stencil_state(&vkds->front) &&
-          radv_order_invariant_stencil_state(&vkds->back));
-
-      order_invariance[1].zs = nozwrite_and_order_invariant_stencil ||
-                               (!radv_is_stencil_write_enabled(vkds) && zfunc_is_ordered);
-      order_invariance[0].zs = !radv_is_depth_write_enabled(vkds) || zfunc_is_ordered;
-
-      order_invariance[1].pass_set =
-         nozwrite_and_order_invariant_stencil ||
-         (!radv_is_stencil_write_enabled(vkds) && (vkds->depthCompareOp == VK_COMPARE_OP_ALWAYS ||
-                                                   vkds->depthCompareOp == VK_COMPARE_OP_NEVER));
-      order_invariance[0].pass_set =
-         !radv_is_depth_write_enabled(vkds) || (vkds->depthCompareOp == VK_COMPARE_OP_ALWAYS ||
-                                                vkds->depthCompareOp == VK_COMPARE_OP_NEVER);
-
-      dsa_order_invariant = order_invariance[has_stencil];
-      if (!dsa_order_invariant.zs)
-         return false;
+   /* Compute depth/stencil order invariance in order to know if
+    * it's safe to enable out-of-order.
+    */
+   bool zfunc_is_ordered = info->ds.depth_compare_op == VK_COMPARE_OP_NEVER ||
+                           info->ds.depth_compare_op == VK_COMPARE_OP_LESS ||
+                           info->ds.depth_compare_op == VK_COMPARE_OP_LESS_OR_EQUAL ||
+                           info->ds.depth_compare_op == VK_COMPARE_OP_GREATER ||
+                           info->ds.depth_compare_op == VK_COMPARE_OP_GREATER_OR_EQUAL;
+   bool depth_write_enabled = radv_is_depth_write_enabled(&info->ds);
+   bool stencil_write_enabled = radv_is_stencil_write_enabled(&info->ds);
+   bool ds_write_enabled = depth_write_enabled || stencil_write_enabled;
+
+   bool nozwrite_and_order_invariant_stencil =
+      !ds_write_enabled ||
+      (!depth_write_enabled &&
+       radv_order_invariant_stencil_state(&info->ds));
+
+   order_invariance[1].zs = nozwrite_and_order_invariant_stencil ||
+                            (!stencil_write_enabled && zfunc_is_ordered);
+   order_invariance[0].zs = !depth_write_enabled || zfunc_is_ordered;
+
+   order_invariance[1].pass_set =
+      nozwrite_and_order_invariant_stencil ||
+      (!stencil_write_enabled &&
+       (info->ds.depth_compare_op == VK_COMPARE_OP_ALWAYS ||
+        info->ds.depth_compare_op == VK_COMPARE_OP_NEVER));
+   order_invariance[0].pass_set =
+      !depth_write_enabled ||
+      (info->ds.depth_compare_op == VK_COMPARE_OP_ALWAYS ||
+       info->ds.depth_compare_op == VK_COMPARE_OP_NEVER);
+
+   dsa_order_invariant = order_invariance[has_stencil];
+   if (!dsa_order_invariant.zs)
+      return false;

-      /* The set of PS invocations is always order invariant,
-       * except when early Z/S tests are requested.
-       */
-      if (ps && ps->info.ps.writes_memory && ps->info.ps.early_fragment_test &&
-          !dsa_order_invariant.pass_set)
-         return false;
+   /* The set of PS invocations is always order invariant,
+    * except when early Z/S tests are requested.
+    */
+   if (ps && ps->info.ps.writes_memory && ps->info.ps.early_fragment_test &&
+       !dsa_order_invariant.pass_set)
+      return false;

-      /* Determine if out-of-order rasterization should be disabled
-       * when occlusion queries are used.
-       */
-      pipeline->disable_out_of_order_rast_for_occlusion = !dsa_order_invariant.pass_set;
-   }
+   /* Determine if out-of-order rasterization should be disabled when occlusion queries are used. */
+   pipeline->disable_out_of_order_rast_for_occlusion = !dsa_order_invariant.pass_set;

    /* No color buffers are enabled for writing. */
    if (!colormask)
@@ -1123,7 +1119,7 @@ radv_pipeline_init_multisample_state(struct radv_graphics_pipeline *pipeline,
       /* Determine if the driver can enable out-of-order
        * rasterization internally.
        */
-      out_of_order_rast = radv_pipeline_out_of_order_rast(pipeline, blend, pCreateInfo);
+      out_of_order_rast = radv_pipeline_out_of_order_rast(pipeline, blend, pCreateInfo, info);
    }

    ms->pa_sc_aa_config = 0;
@@ -1398,14 +1394,12 @@ radv_pipeline_needed_dynamic_state(const struct radv_graphics_pipeline *pipeline
        !(pipeline->dynamic_states & RADV_DYNAMIC_DEPTH_BIAS_ENABLE))
       states &= ~RADV_DYNAMIC_DEPTH_BIAS;

-   if (!pCreateInfo->pDepthStencilState ||
-       (!pCreateInfo->pDepthStencilState->depthBoundsTestEnable &&
-        !(pipeline->dynamic_states & RADV_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE)))
+   if (!info->ds.depth_bounds.test_enable &&
+       !(pipeline->dynamic_states & RADV_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE))
       states &= ~RADV_DYNAMIC_DEPTH_BOUNDS;

-   if (!pCreateInfo->pDepthStencilState ||
-       (!pCreateInfo->pDepthStencilState->stencilTestEnable &&
-        !(pipeline->dynamic_states & RADV_DYNAMIC_STENCIL_TEST_ENABLE)))
+   if (!info->ds.stencil_test_enable &&
+       !(pipeline->dynamic_states & RADV_DYNAMIC_STENCIL_TEST_ENABLE))
       states &= ~(RADV_DYNAMIC_STENCIL_COMPARE_MASK | RADV_DYNAMIC_STENCIL_WRITE_MASK |
                   RADV_DYNAMIC_STENCIL_REFERENCE);

@@ -1798,6 +1792,41 @@ radv_pipeline_init_multisample_info(struct radv_graphics_pipeline *pipeline,
    return info;
 }

+static struct radv_depth_stencil_info
+radv_pipeline_init_depth_stencil_info(struct radv_graphics_pipeline *pipeline,
+                                      const VkGraphicsPipelineCreateInfo *pCreateInfo)
+{
+   const VkPipelineDepthStencilStateCreateInfo *ds = pCreateInfo->pDepthStencilState;
+   bool has_ds_att = radv_pipeline_has_ds_attachments(pCreateInfo);
+   struct radv_depth_stencil_info info = {0};
+
+   if (radv_is_raster_enabled(pipeline, pCreateInfo) && has_ds_att) {
+      info.depth_bounds.test_enable = ds->depthBoundsTestEnable;
+      info.depth_bounds.min = ds->minDepthBounds;
+      info.depth_bounds.max = ds->maxDepthBounds;
+      info.stencil_test_enable = ds->stencilTestEnable;
+      info.stencil_compare_mask.front = ds->front.compareMask;
+      info.stencil_compare_mask.back = ds->back.compareMask;
+      info.stencil_write_mask.front = ds->front.writeMask;
+      info.stencil_write_mask.back = ds->back.writeMask;
+      info.stencil_reference.front = ds->front.reference;
+      info.stencil_reference.back = ds->back.reference;
+      info.stencil_op.front.compare_op = ds->front.compareOp;
+      info.stencil_op.front.fail_op = ds->front.failOp;
+      info.stencil_op.front.pass_op = ds->front.passOp;
+      info.stencil_op.front.depth_fail_op = ds->front.depthFailOp;
+      info.stencil_op.back.compare_op = ds->back.compareOp;
+      info.stencil_op.back.fail_op = ds->back.failOp;
+      info.stencil_op.back.pass_op = ds->back.passOp;
+      info.stencil_op.back.depth_fail_op = ds->back.depthFailOp;
+      info.depth_test_enable = ds->depthTestEnable;
+      info.depth_write_enable = ds->depthWriteEnable;
+      info.depth_compare_op = ds->depthCompareOp;
+   }
+
+   return info;
+}
+
 static struct radv_graphics_pipeline_info
 radv_pipeline_init_graphics_info(struct radv_graphics_pipeline *pipeline,
                                  const VkGraphicsPipelineCreateInfo *pCreateInfo)
@@ -1815,6 +1844,7 @@ radv_pipeline_init_graphics_info(struct radv_graphics_pipeline *pipeline,
    info.rs = radv_pipeline_init_rasterization_info(pipeline, pCreateInfo);

    info.ms = radv_pipeline_init_multisample_info(pipeline, pCreateInfo);
+   info.ds = radv_pipeline_init_depth_stencil_info(pipeline, pCreateInfo);

    return info;
 }
@@ -1920,56 +1950,56 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
     */
    if (needed_states && radv_pipeline_has_ds_attachments(pCreateInfo)) {
       if (states & RADV_DYNAMIC_DEPTH_BOUNDS) {
-         dynamic->depth_bounds.min = pCreateInfo->pDepthStencilState->minDepthBounds;
-         dynamic->depth_bounds.max = pCreateInfo->pDepthStencilState->maxDepthBounds;
+         dynamic->depth_bounds.min = info->ds.depth_bounds.min;
+         dynamic->depth_bounds.max = info->ds.depth_bounds.max;
       }

       if (states & RADV_DYNAMIC_STENCIL_COMPARE_MASK) {
-         dynamic->stencil_compare_mask.front = pCreateInfo->pDepthStencilState->front.compareMask;
-         dynamic->stencil_compare_mask.back = pCreateInfo->pDepthStencilState->back.compareMask;
+         dynamic->stencil_compare_mask.front = info->ds.stencil_compare_mask.front;
+         dynamic->stencil_compare_mask.back = info->ds.stencil_compare_mask.back;
       }

       if (states & RADV_DYNAMIC_STENCIL_WRITE_MASK) {
-         dynamic->stencil_write_mask.front = pCreateInfo->pDepthStencilState->front.writeMask;
-         dynamic->stencil_write_mask.back = pCreateInfo->pDepthStencilState->back.writeMask;
+         dynamic->stencil_write_mask.front = info->ds.stencil_write_mask.front;
+         dynamic->stencil_write_mask.back = info->ds.stencil_write_mask.back;
       }

       if (states & RADV_DYNAMIC_STENCIL_REFERENCE) {
-         dynamic->stencil_reference.front = pCreateInfo->pDepthStencilState->front.reference;
-         dynamic->stencil_reference.back = pCreateInfo->pDepthStencilState->back.reference;
+         dynamic->stencil_reference.front = info->ds.stencil_reference.front;
+         dynamic->stencil_reference.back = info->ds.stencil_reference.back;
       }

       if (states & RADV_DYNAMIC_DEPTH_TEST_ENABLE) {
-         dynamic->depth_test_enable = pCreateInfo->pDepthStencilState->depthTestEnable;
+         dynamic->depth_test_enable = info->ds.depth_test_enable;
       }

       if (states & RADV_DYNAMIC_DEPTH_WRITE_ENABLE) {
-         dynamic->depth_write_enable = pCreateInfo->pDepthStencilState->depthWriteEnable;
+         dynamic->depth_write_enable = info->ds.depth_write_enable;
       }

       if (states & RADV_DYNAMIC_DEPTH_COMPARE_OP) {
-         dynamic->depth_compare_op = pCreateInfo->pDepthStencilState->depthCompareOp;
+         dynamic->depth_compare_op = info->ds.depth_compare_op;
       }

       if (states & RADV_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE) {
-         dynamic->depth_bounds_test_enable = pCreateInfo->pDepthStencilState->depthBoundsTestEnable;
+         dynamic->depth_bounds_test_enable = info->ds.depth_bounds.test_enable;
       }

       if (states & RADV_DYNAMIC_STENCIL_TEST_ENABLE) {
-         dynamic->stencil_test_enable = pCreateInfo->pDepthStencilState->stencilTestEnable;
+         dynamic->stencil_test_enable = info->ds.stencil_test_enable;
       }

       if (states & RADV_DYNAMIC_STENCIL_OP) {
-         dynamic->stencil_op.front.compare_op = pCreateInfo->pDepthStencilState->front.compareOp;
-         dynamic->stencil_op.front.fail_op = pCreateInfo->pDepthStencilState->front.failOp;
-         dynamic->stencil_op.front.pass_op = pCreateInfo->pDepthStencilState->front.passOp;
+         dynamic->stencil_op.front.compare_op = info->ds.stencil_op.front.compare_op;
+         dynamic->stencil_op.front.fail_op = info->ds.stencil_op.front.fail_op;
+         dynamic->stencil_op.front.pass_op = info->ds.stencil_op.front.pass_op;
          dynamic->stencil_op.front.depth_fail_op =
-            pCreateInfo->pDepthStencilState->front.depthFailOp;
+            info->ds.stencil_op.front.depth_fail_op;

-         dynamic->stencil_op.back.compare_op = pCreateInfo->pDepthStencilState->back.compareOp;
-         dynamic->stencil_op.back.fail_op = pCreateInfo->pDepthStencilState->back.failOp;
-         dynamic->stencil_op.back.pass_op = pCreateInfo->pDepthStencilState->back.passOp;
-         dynamic->stencil_op.back.depth_fail_op = pCreateInfo->pDepthStencilState->back.depthFailOp;
+         dynamic->stencil_op.back.compare_op = info->ds.stencil_op.back.compare_op;
+         dynamic->stencil_op.back.fail_op = info->ds.stencil_op.back.fail_op;
+         dynamic->stencil_op.back.pass_op = info->ds.stencil_op.back.pass_op;
+         dynamic->stencil_op.back.depth_fail_op = info->ds.stencil_op.back.depth_fail_op;
       }
    }

@@ -2088,8 +2118,6 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,
                                        const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-   const VkPipelineDepthStencilStateCreateInfo *ds_info =
-      radv_pipeline_get_depth_stencil_state(pipeline, pCreateInfo);
    const VkPipelineRenderingCreateInfo *render_create_info =
       vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
@@ -2099,25 +2127,23 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,
    bool has_depth_attachment = render_create_info->depthAttachmentFormat != VK_FORMAT_UNDEFINED;
    bool has_stencil_attachment = render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED;

-   if (ds_info) {
-      if (has_depth_attachment) {
-         /* from amdvlk: For 4xAA and 8xAA need to decompress on flush for better performance */
-         ds_state.db_render_override2 |= S_028010_DECOMPRESS_Z_ON_FLUSH(info->ms.raster_samples > 2);
+   if (has_depth_attachment) {
+      /* from amdvlk: For 4xAA and 8xAA need to decompress on flush for better performance */
+      ds_state.db_render_override2 |= S_028010_DECOMPRESS_Z_ON_FLUSH(info->ms.raster_samples > 2);

-         if (pdevice->rad_info.gfx_level >= GFX10_3)
-            ds_state.db_render_override2 |= S_028010_CENTROID_COMPUTATION_MODE(1);
+      if (pdevice->rad_info.gfx_level >= GFX10_3)
+         ds_state.db_render_override2 |= S_028010_CENTROID_COMPUTATION_MODE(1);

-         db_depth_control = S_028800_Z_ENABLE(ds_info->depthTestEnable ? 1 : 0) |
-                            S_028800_Z_WRITE_ENABLE(ds_info->depthWriteEnable ? 1 : 0) |
-                            S_028800_ZFUNC(ds_info->depthCompareOp) |
-                            S_028800_DEPTH_BOUNDS_ENABLE(ds_info->depthBoundsTestEnable ? 1 : 0);
-      }
+      db_depth_control = S_028800_Z_ENABLE(info->ds.depth_test_enable) |
+                         S_028800_Z_WRITE_ENABLE(info->ds.depth_write_enable) |
+                         S_028800_ZFUNC(info->ds.depth_compare_op) |
+                         S_028800_DEPTH_BOUNDS_ENABLE(info->ds.depth_bounds.test_enable);
+   }

-      if (has_stencil_attachment && ds_info->stencilTestEnable) {
-         db_depth_control |= S_028800_STENCIL_ENABLE(1) | S_028800_BACKFACE_ENABLE(1);
-         db_depth_control |= S_028800_STENCILFUNC(ds_info->front.compareOp);
-         db_depth_control |= S_028800_STENCILFUNC_BF(ds_info->back.compareOp);
-      }
+   if (has_stencil_attachment && info->ds.stencil_test_enable) {
+      db_depth_control |= S_028800_STENCIL_ENABLE(1) | S_028800_BACKFACE_ENABLE(1);
+      db_depth_control |= S_028800_STENCILFUNC(info->ds.stencil_op.front.compare_op);
+      db_depth_control |= S_028800_STENCILFUNC_BF(info->ds.stencil_op.back.compare_op);
    }

    ds_state.db_render_override |= S_02800C_FORCE_HIS_ENABLE0(V_02800C_FORCE_DISABLE) |
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 527e4487f357..7a0908db5cbe 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1925,6 +1925,44 @@ struct radv_multisample_info {
    uint32_t sample_locs_count;
 };

+struct radv_depth_stencil_info {
+   struct {
+      bool test_enable;
+      float min;
+      float max;
+   } depth_bounds;
+   struct {
+      uint32_t front;
+      uint32_t back;
+   } stencil_compare_mask;
+   struct {
+      uint32_t front;
+      uint32_t back;
+   } stencil_write_mask;
+   struct {
+      struct {
+         VkStencilOp fail_op;
+         VkStencilOp pass_op;
+         VkStencilOp depth_fail_op;
+         VkCompareOp compare_op;
+      } front;
+      struct {
+         VkStencilOp fail_op;
+         VkStencilOp pass_op;
+         VkStencilOp depth_fail_op;
+         VkCompareOp compare_op;
+      } back;
+   } stencil_op;
+   struct {
+      uint32_t front;
+      uint32_t back;
+   } stencil_reference;
+   bool stencil_test_enable;
+   bool depth_test_enable;
+   bool depth_write_enable;
+   VkCompareOp depth_compare_op;
+};
+
 struct radv_graphics_pipeline_info {
    struct radv_vertex_input_info vi;
    struct radv_input_assembly_info ia;
@@ -1934,6 +1972,7 @@ struct radv_graphics_pipeline_info {
    struct radv_rasterization_info rs;

    struct radv_multisample_info ms;
+   struct radv_depth_stencil_info ds;
 };

 struct radv_pipeline {
--
GitLab

From 2479f126deaa642415408b93f47bf2687f8c2ec7 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 20 May 2022 08:25:13 +0200
Subject: [PATCH 4/9] radv: init states from VkPipelineRenderingCreateInfo at
 only one place

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 162 +++++++++++++++++----------------
 src/amd/vulkan/radv_private.h  |   9 ++
 2 files changed, 95 insertions(+), 76 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index e043c1d5b0f6..b786286d6aee 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -105,22 +105,17 @@ radv_is_vrs_enabled(const struct radv_graphics_pipeline *pipeline,
 }

 static bool
-radv_pipeline_has_ds_attachments(const VkGraphicsPipelineCreateInfo *pCreateInfo)
+radv_pipeline_has_ds_attachments(const struct radv_rendering_info *ri_info)
 {
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
-   return (render_create_info->depthAttachmentFormat != VK_FORMAT_UNDEFINED ||
-           render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED);
+   return ri_info->depth_att_format != VK_FORMAT_UNDEFINED ||
+          ri_info->stencil_att_format != VK_FORMAT_UNDEFINED;
 }

 static bool
-radv_pipeline_has_color_attachments(const VkGraphicsPipelineCreateInfo *pCreateInfo)
+radv_pipeline_has_color_attachments(const struct radv_rendering_info *ri_info)
 {
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
-
-   for (uint32_t i = 0; i < render_create_info->colorAttachmentCount; ++i) {
-      if (render_create_info->pColorAttachmentFormats[i] != VK_FORMAT_UNDEFINED)
+   for (uint32_t i = 0; i < ri_info->color_att_count; ++i) {
+      if (ri_info->color_att_formats[i] != VK_FORMAT_UNDEFINED)
          return true;
    }

@@ -131,7 +126,16 @@ static const VkPipelineColorBlendStateCreateInfo *
 radv_pipeline_get_color_blend_state(const struct radv_graphics_pipeline *pipeline,
                                     const VkGraphicsPipelineCreateInfo *pCreateInfo)
 {
-   bool has_color_att = radv_pipeline_has_color_attachments(pCreateInfo);
+   const VkPipelineRenderingCreateInfo *ri =
+      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
+   bool has_color_att = false;
+
+   for (uint32_t i = 0; i < ri->colorAttachmentCount; ++i) {
+      if (ri->pColorAttachmentFormats[i] != VK_FORMAT_UNDEFINED) {
+         has_color_att = true;
+         break;
+      }
+   }

    if (radv_is_raster_enabled(pipeline, pCreateInfo) && has_color_att)
       return pCreateInfo->pColorBlendState;
@@ -519,16 +523,15 @@ format_is_float32(VkFormat format)
 static void
 radv_pipeline_compute_spi_color_formats(const struct radv_graphics_pipeline *pipeline,
                                         const VkGraphicsPipelineCreateInfo *pCreateInfo,
-                                        struct radv_blend_state *blend)
+                                        struct radv_blend_state *blend,
+                                        const struct radv_graphics_pipeline_info *info)
 {
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    unsigned col_format = 0, is_int8 = 0, is_int10 = 0, is_float32 = 0;
    unsigned num_targets;

-   for (unsigned i = 0; i < render_create_info->colorAttachmentCount; ++i) {
+   for (unsigned i = 0; i < info->ri.color_att_count; ++i) {
       unsigned cf;
-      VkFormat fmt = render_create_info->pColorAttachmentFormats[i];
+      VkFormat fmt = info->ri.color_att_formats[i];

       if (fmt == VK_FORMAT_UNDEFINED || !(blend->cb_target_mask & (0xfu << (i * 4)))) {
          cf = V_028714_SPI_SHADER_ZERO;
@@ -828,7 +831,7 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    else
       cb_color_control |= S_028808_MODE(V_028808_CB_DISABLE);

-   radv_pipeline_compute_spi_color_formats(pipeline, pCreateInfo, &blend);
+   radv_pipeline_compute_spi_color_formats(pipeline, pCreateInfo, &blend, info);

    pipeline->cb_color_control = cb_color_control;

@@ -857,12 +860,10 @@ radv_pipeline_color_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo,
 {
    const VkAttachmentSampleCountInfoAMD *sample_info =
       vk_find_struct_const(pCreateInfo->pNext, ATTACHMENT_SAMPLE_COUNT_INFO_AMD);
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    if (sample_info && sample_info->colorAttachmentCount > 0) {
       unsigned samples = 1;
       for (uint32_t i = 0; i < sample_info->colorAttachmentCount; ++i) {
-         if (render_create_info->pColorAttachmentFormats[i] != VK_FORMAT_UNDEFINED) {
+         if (info->ri.color_att_formats[i] != VK_FORMAT_UNDEFINED) {
             samples = MAX2(samples, sample_info->pColorAttachmentSamples[i]);
          }
       }
@@ -879,7 +880,7 @@ radv_pipeline_depth_samples(const VkGraphicsPipelineCreateInfo *pCreateInfo,
    const VkAttachmentSampleCountInfoAMD *sample_info =
       vk_find_struct_const(pCreateInfo->pNext, ATTACHMENT_SAMPLE_COUNT_INFO_AMD);
    if (sample_info) {
-      if (radv_pipeline_has_ds_attachments(pCreateInfo)) {
+      if (radv_pipeline_has_ds_attachments(&info->ri)) {
          return sample_info->depthStencilAttachmentSamples;
       }
    }
@@ -980,8 +981,6 @@ radv_pipeline_out_of_order_rast(struct radv_graphics_pipeline *pipeline,
                                 const VkGraphicsPipelineCreateInfo *pCreateInfo,
                                 const struct radv_graphics_pipeline_info *info)
 {
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    const VkPipelineColorBlendStateCreateInfo *vkblend =
       radv_pipeline_get_color_blend_state(pipeline, pCreateInfo);
    unsigned colormask = blend->cb_target_enabled_4bit;
@@ -1003,7 +1002,7 @@ radv_pipeline_out_of_order_rast(struct radv_graphics_pipeline *pipeline,
    /* Default depth/stencil invariance when no attachment is bound. */
    struct radv_dsa_order_invariance dsa_order_invariant = {.zs = true, .pass_set = true};

-   bool has_stencil = render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED;
+   bool has_stencil = info->ri.stencil_att_format != VK_FORMAT_UNDEFINED;
    struct radv_dsa_order_invariance order_invariance[2];
    struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];

@@ -1366,7 +1365,7 @@ radv_pipeline_needed_dynamic_state(const struct radv_graphics_pipeline *pipeline
                                    const VkGraphicsPipelineCreateInfo *pCreateInfo,
                                    const struct radv_graphics_pipeline_info *info)
 {
-   bool has_color_att = radv_pipeline_has_color_attachments(pCreateInfo);
+   bool has_color_att = radv_pipeline_has_color_attachments(&info->ri);
    bool raster_enabled = radv_is_raster_enabled(pipeline, pCreateInfo);
    uint64_t states = RADV_DYNAMIC_ALL;

@@ -1797,10 +1796,13 @@ radv_pipeline_init_depth_stencil_info(struct radv_graphics_pipeline *pipeline,
                                       const VkGraphicsPipelineCreateInfo *pCreateInfo)
 {
    const VkPipelineDepthStencilStateCreateInfo *ds = pCreateInfo->pDepthStencilState;
-   bool has_ds_att = radv_pipeline_has_ds_attachments(pCreateInfo);
+   const VkPipelineRenderingCreateInfo *ri =
+      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    struct radv_depth_stencil_info info = {0};

-   if (radv_is_raster_enabled(pipeline, pCreateInfo) && has_ds_att) {
+   if (radv_is_raster_enabled(pipeline, pCreateInfo) &&
+       (ri->depthAttachmentFormat != VK_FORMAT_UNDEFINED ||
+        ri->stencilAttachmentFormat != VK_FORMAT_UNDEFINED)) {
       info.depth_bounds.test_enable = ds->depthBoundsTestEnable;
       info.depth_bounds.min = ds->minDepthBounds;
       info.depth_bounds.max = ds->maxDepthBounds;
@@ -1827,6 +1829,25 @@ radv_pipeline_init_depth_stencil_info(struct radv_graphics_pipeline *pipeline,
    return info;
 }

+static struct radv_rendering_info
+radv_pipeline_init_rendering_info(struct radv_graphics_pipeline *pipeline,
+                                  const VkGraphicsPipelineCreateInfo *pCreateInfo)
+{
+   const VkPipelineRenderingCreateInfo *ri =
+      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
+   struct radv_rendering_info info = {0};
+
+   info.view_mask = ri->viewMask;
+   for (uint32_t i = 0; i < ri->colorAttachmentCount; i++) {
+      info.color_att_formats[i] = ri->pColorAttachmentFormats[i];
+   }
+   info.color_att_count = ri->colorAttachmentCount;
+   info.depth_att_format = ri->depthAttachmentFormat;
+   info.stencil_att_format = ri->stencilAttachmentFormat;
+
+   return info;
+}
+
 static struct radv_graphics_pipeline_info
 radv_pipeline_init_graphics_info(struct radv_graphics_pipeline *pipeline,
                                  const VkGraphicsPipelineCreateInfo *pCreateInfo)
@@ -1845,6 +1866,7 @@ radv_pipeline_init_graphics_info(struct radv_graphics_pipeline *pipeline,

    info.ms = radv_pipeline_init_multisample_info(pipeline, pCreateInfo);
    info.ds = radv_pipeline_init_depth_stencil_info(pipeline, pCreateInfo);
+   info.ri = radv_pipeline_init_rendering_info(pipeline, pCreateInfo);

    return info;
 }
@@ -1948,7 +1970,7 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
     *    disabled or if the subpass of the render pass the pipeline is created
     *    against does not use a depth/stencil attachment.
     */
-   if (needed_states && radv_pipeline_has_ds_attachments(pCreateInfo)) {
+   if (needed_states && radv_pipeline_has_ds_attachments(&info->ri)) {
       if (states & RADV_DYNAMIC_DEPTH_BOUNDS) {
          dynamic->depth_bounds.min = info->ds.depth_bounds.min;
          dynamic->depth_bounds.max = info->ds.depth_bounds.max;
@@ -2053,7 +2075,7 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
       dynamic->rasterizer_discard_enable = info->rs.discard_enable;
    }

-   if (radv_pipeline_has_color_attachments(pCreateInfo) && states & RADV_DYNAMIC_LOGIC_OP) {
+   if (radv_pipeline_has_color_attachments(&info->ri) && states & RADV_DYNAMIC_LOGIC_OP) {
       if (pCreateInfo->pColorBlendState->logicOpEnable) {
          dynamic->logic_op = si_translate_blend_logic_op(pCreateInfo->pColorBlendState->logicOp);
       } else {
@@ -2118,14 +2140,12 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,
                                        const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
    struct radv_depth_stencil_state ds_state = {0};
    uint32_t db_depth_control = 0;

-   bool has_depth_attachment = render_create_info->depthAttachmentFormat != VK_FORMAT_UNDEFINED;
-   bool has_stencil_attachment = render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED;
+   bool has_depth_attachment = info->ri.depth_att_format != VK_FORMAT_UNDEFINED;
+   bool has_stencil_attachment = info->ri.stencil_att_format != VK_FORMAT_UNDEFINED;

    if (has_depth_attachment) {
       /* from amdvlk: For 4xAA and 8xAA need to decompress on flush for better performance */
@@ -3271,12 +3291,9 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
                                     const struct radv_blend_state *blend)
 {
    struct radv_device *device = pipeline->base.device;
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
-
    struct radv_pipeline_key key = radv_generate_pipeline_key(&pipeline->base, pCreateInfo->flags);

-   key.has_multiview_view_index = !!render_create_info->viewMask;
+   key.has_multiview_view_index = !!info->ri.view_mask;

    if (pipeline->dynamic_states & RADV_DYNAMIC_VERTEX_INPUT) {
       key.vs.dynamic_input_state = true;
@@ -5023,7 +5040,8 @@ struct radv_bin_size_entry {

 static VkExtent2D
 radv_gfx9_compute_bin_size(const struct radv_graphics_pipeline *pipeline,
-                           const VkGraphicsPipelineCreateInfo *pCreateInfo)
+                           const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                           const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
    static const struct radv_bin_size_entry color_size_table[][3][9] = {
@@ -5236,8 +5254,6 @@ radv_gfx9_compute_bin_size(const struct radv_graphics_pipeline *pipeline,
       },
    };

-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    VkExtent2D extent = {512, 512};

    unsigned log_num_rb_per_se =
@@ -5252,15 +5268,14 @@ radv_gfx9_compute_bin_size(const struct radv_graphics_pipeline *pipeline,
    const VkPipelineColorBlendStateCreateInfo *vkblend =
       radv_pipeline_get_color_blend_state(pipeline, pCreateInfo);
    if (vkblend) {
-      for (unsigned i = 0; i < render_create_info->colorAttachmentCount; i++) {
+      for (unsigned i = 0; i < info->ri.color_att_count; i++) {
          if (!vkblend->pAttachments[i].colorWriteMask)
             continue;

-         if (render_create_info->pColorAttachmentFormats[i] == VK_FORMAT_UNDEFINED)
+         if (info->ri.color_att_formats[i] == VK_FORMAT_UNDEFINED)
             continue;

-         color_bytes_per_pixel +=
-            vk_format_get_blocksize(render_create_info->pColorAttachmentFormats[i]);
+         color_bytes_per_pixel += vk_format_get_blocksize(info->ri.color_att_formats[i]);
       }

       /* MSAA images typically don't use all samples all the time. */
@@ -5275,12 +5290,10 @@ radv_gfx9_compute_bin_size(const struct radv_graphics_pipeline *pipeline,

    extent = color_entry->extent;

-   if (radv_pipeline_has_ds_attachments(pCreateInfo)) {
+   if (radv_pipeline_has_ds_attachments(&info->ri)) {
       /* Coefficients taken from AMDVLK */
-      unsigned depth_coeff =
-         render_create_info->depthAttachmentFormat != VK_FORMAT_UNDEFINED ? 5 : 0;
-      unsigned stencil_coeff =
-         render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED ? 1 : 0;
+      unsigned depth_coeff = info->ri.depth_att_format != VK_FORMAT_UNDEFINED ? 5 : 0;
+      unsigned stencil_coeff = info->ri.stencil_att_format != VK_FORMAT_UNDEFINED ? 1 : 0;
       unsigned ds_bytes_per_pixel = 4 * (depth_coeff + stencil_coeff) * total_samples;

       const struct radv_bin_size_entry *ds_entry = ds_size_table[log_num_rb_per_se][log_num_se];
@@ -5296,11 +5309,10 @@ radv_gfx9_compute_bin_size(const struct radv_graphics_pipeline *pipeline,

 static VkExtent2D
 radv_gfx10_compute_bin_size(const struct radv_graphics_pipeline *pipeline,
-                            const VkGraphicsPipelineCreateInfo *pCreateInfo)
+                            const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                            const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-   const VkPipelineRenderingCreateInfo *render_create_info =
-      vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
    VkExtent2D extent = {512, 512};

    const unsigned db_tag_size = 64;
@@ -5329,15 +5341,14 @@ radv_gfx10_compute_bin_size(const struct radv_graphics_pipeline *pipeline,
    const VkPipelineColorBlendStateCreateInfo *vkblend =
       radv_pipeline_get_color_blend_state(pipeline, pCreateInfo);
    if (vkblend) {
-      for (unsigned i = 0; i < render_create_info->colorAttachmentCount; i++) {
+      for (unsigned i = 0; i < info->ri.color_att_count; i++) {
          if (!vkblend->pAttachments[i].colorWriteMask)
             continue;

-         if (render_create_info->pColorAttachmentFormats[i] == VK_FORMAT_UNDEFINED)
+         if (info->ri.color_att_formats[i] == VK_FORMAT_UNDEFINED)
             continue;

-         color_bytes_per_pixel +=
-            vk_format_get_blocksize(render_create_info->pColorAttachmentFormats[i]);
+         color_bytes_per_pixel += vk_format_get_blocksize(info->ri.color_att_formats[i]);

          if (total_samples > 1) {
             assert(samples_log <= 3);
@@ -5365,12 +5376,10 @@ radv_gfx10_compute_bin_size(const struct radv_graphics_pipeline *pipeline,
          extent = fmask_extent;
    }

-   if (radv_pipeline_has_ds_attachments(pCreateInfo)) {
+   if (radv_pipeline_has_ds_attachments(&info->ri)) {
       /* Coefficients taken from AMDVLK */
-      unsigned depth_coeff =
-         render_create_info->depthAttachmentFormat != VK_FORMAT_UNDEFINED ? 5 : 0;
-      unsigned stencil_coeff =
-         render_create_info->stencilAttachmentFormat != VK_FORMAT_UNDEFINED ? 1 : 0;
+      unsigned depth_coeff = info->ri.depth_att_format != VK_FORMAT_UNDEFINED ? 5 : 0;
+      unsigned stencil_coeff = info->ri.stencil_att_format != VK_FORMAT_UNDEFINED ? 1 : 0;
       unsigned db_bytes_per_pixel = (depth_coeff + stencil_coeff) * total_samples;

       const unsigned db_pixel_count_log = util_logbase2(db_tag_part / db_bytes_per_pixel);
@@ -5390,29 +5399,27 @@ radv_gfx10_compute_bin_size(const struct radv_graphics_pipeline *pipeline,

 static void
 radv_pipeline_init_disabled_binning_state(struct radv_graphics_pipeline *pipeline,
-                                          const VkGraphicsPipelineCreateInfo *pCreateInfo)
+                                          const VkGraphicsPipelineCreateInfo *pCreateInfo,
+                                          const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
    uint32_t pa_sc_binner_cntl_0 = S_028C44_BINNING_MODE(V_028C44_DISABLE_BINNING_USE_LEGACY_SC) |
                                   S_028C44_DISABLE_START_OF_PRIM(1);

    if (pdevice->rad_info.gfx_level >= GFX10) {
-      const VkPipelineRenderingCreateInfo *render_create_info =
-         vk_find_struct_const(pCreateInfo->pNext, PIPELINE_RENDERING_CREATE_INFO);
       const VkPipelineColorBlendStateCreateInfo *vkblend =
          radv_pipeline_get_color_blend_state(pipeline, pCreateInfo);
       unsigned min_bytes_per_pixel = 0;

       if (vkblend) {
-         for (unsigned i = 0; i < render_create_info->colorAttachmentCount; i++) {
+         for (unsigned i = 0; i < info->ri.color_att_count; i++) {
             if (!vkblend->pAttachments[i].colorWriteMask)
                continue;

-            if (render_create_info->pColorAttachmentFormats[i] == VK_FORMAT_UNDEFINED)
+            if (info->ri.color_att_formats[i] == VK_FORMAT_UNDEFINED)
                continue;

-            unsigned bytes =
-               vk_format_get_blocksize(render_create_info->pColorAttachmentFormats[i]);
+            unsigned bytes = vk_format_get_blocksize(info->ri.color_att_formats[i]);
             if (!min_bytes_per_pixel || bytes < min_bytes_per_pixel)
                min_bytes_per_pixel = bytes;
          }
@@ -5458,7 +5465,8 @@ radv_get_binning_settings(const struct radv_physical_device *pdev)
 static void
 radv_pipeline_init_binning_state(struct radv_graphics_pipeline *pipeline,
                                  const VkGraphicsPipelineCreateInfo *pCreateInfo,
-                                 const struct radv_blend_state *blend)
+                                 const struct radv_blend_state *blend,
+                                 const struct radv_graphics_pipeline_info *info)
 {
    const struct radv_device *device = pipeline->base.device;

@@ -5467,9 +5475,9 @@ radv_pipeline_init_binning_state(struct radv_graphics_pipeline *pipeline,

    VkExtent2D bin_size;
    if (device->physical_device->rad_info.gfx_level >= GFX10) {
-      bin_size = radv_gfx10_compute_bin_size(pipeline, pCreateInfo);
+      bin_size = radv_gfx10_compute_bin_size(pipeline, pCreateInfo, info);
    } else if (device->physical_device->rad_info.gfx_level == GFX9) {
-      bin_size = radv_gfx9_compute_bin_size(pipeline, pCreateInfo);
+      bin_size = radv_gfx9_compute_bin_size(pipeline, pCreateInfo, info);
    } else
       unreachable("Unhandled generation for binning bin size calculation");

@@ -5488,7 +5496,7 @@ radv_pipeline_init_binning_state(struct radv_graphics_pipeline *pipeline,

       pipeline->binning.pa_sc_binner_cntl_0 = pa_sc_binner_cntl_0;
    } else
-      radv_pipeline_init_disabled_binning_state(pipeline, pCreateInfo);
+      radv_pipeline_init_disabled_binning_state(pipeline, pCreateInfo, info);
 }

 static void
@@ -6836,6 +6844,7 @@ radv_pipeline_init_extra(struct radv_graphics_pipeline *pipeline,
                          const struct radv_graphics_pipeline_create_info *extra,
                          struct radv_blend_state *blend_state,
                          struct radv_depth_stencil_state *ds_state,
+                         const struct radv_graphics_pipeline_info *info,
                          uint32_t *vgt_gs_out_prim_type)
 {
    if (extra->custom_blend_mode == V_028808_CB_ELIMINATE_FAST_CLEAR ||
@@ -6866,7 +6875,7 @@ radv_pipeline_init_extra(struct radv_graphics_pipeline *pipeline,
          *vgt_gs_out_prim_type = V_028A6C_RECTLIST;
    }

-   if (radv_pipeline_has_ds_attachments(pCreateInfo)) {
+   if (radv_pipeline_has_ds_attachments(&info->ri)) {
       ds_state->db_render_control |= S_028000_DEPTH_CLEAR_ENABLE(extra->db_depth_clear);
       ds_state->db_render_control |= S_028000_STENCIL_CLEAR_ENABLE(extra->db_stencil_clear);
       ds_state->db_render_control |= S_028000_RESUMMARIZE_ENABLE(extra->resummarize_enable);
@@ -6985,7 +6994,7 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv

    uint32_t vgt_gs_out_prim_type = radv_pipeline_init_vgt_gs_out(pipeline, &info, pCreateInfo);

-   radv_pipeline_init_binning_state(pipeline, pCreateInfo, &blend);
+   radv_pipeline_init_binning_state(pipeline, pCreateInfo, &blend, &info);
    radv_pipeline_init_shader_stages_state(pipeline);
    radv_pipeline_init_scratch(device, &pipeline->base);

@@ -7003,7 +7012,8 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
    pipeline->base.dynamic_offset_count = pipeline_layout->dynamic_offset_count;

    if (extra) {
-      radv_pipeline_init_extra(pipeline, pCreateInfo, extra, &blend, &ds_state, &vgt_gs_out_prim_type);
+      radv_pipeline_init_extra(pipeline, pCreateInfo, extra, &blend, &ds_state, &info,
+                               &vgt_gs_out_prim_type);
    }

    radv_pipeline_emit_pm4(pipeline, pCreateInfo, &blend, &ds_state, vgt_gs_out_prim_type, &info);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 7a0908db5cbe..1cbf14a3c35f 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1963,6 +1963,14 @@ struct radv_depth_stencil_info {
    VkCompareOp depth_compare_op;
 };

+struct radv_rendering_info {
+   uint32_t view_mask;
+   uint32_t color_att_count;
+   VkFormat color_att_formats[MAX_RTS];
+   VkFormat depth_att_format;
+   VkFormat stencil_att_format;
+};
+
 struct radv_graphics_pipeline_info {
    struct radv_vertex_input_info vi;
    struct radv_input_assembly_info ia;
@@ -1973,6 +1981,7 @@ struct radv_graphics_pipeline_info {

    struct radv_multisample_info ms;
    struct radv_depth_stencil_info ds;
+   struct radv_rendering_info ri;
 };

 struct radv_pipeline {
--
GitLab
