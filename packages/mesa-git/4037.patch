From baca8bbb3dc4741496dd4bd2941d7634eeb54a57 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 18:54:09 -0500
Subject: [PATCH 01/14] anv/wsi: Stop resetting semaphores

This will happen automatically when they're waited on by the dummy
submit in wsi_common_queue_present().

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/intel/vulkan/anv_wsi.c | 11 -----------
 1 file changed, 11 deletions(-)

diff --git a/src/intel/vulkan/anv_wsi.c b/src/intel/vulkan/anv_wsi.c
index d66034a2537a..5e98673e2752 100644
--- a/src/intel/vulkan/anv_wsi.c
+++ b/src/intel/vulkan/anv_wsi.c
@@ -112,17 +112,6 @@ VkResult anv_QueuePresentKHR(
                                      _queue, 0,
                                      pPresentInfo);
 
-   for (uint32_t i = 0; i < pPresentInfo->waitSemaphoreCount; i++) {
-      VK_FROM_HANDLE(vk_semaphore, semaphore, pPresentInfo->pWaitSemaphores[i]);
-      /* From the Vulkan 1.0.53 spec:
-       *
-       *    "If the import is temporary, the implementation must restore the
-       *    semaphore to its prior permanent state after submitting the next
-       *    semaphore wait operation."
-       */
-      vk_semaphore_reset_temporary(&queue->device->vk, semaphore);
-   }
-
    u_trace_context_process(&device->ds.trace_context, true);
 
    return result;
-- 
GitLab


From 8c48a0c4df3bc758deb692ec3ea28ba4f7e2786c Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:23:48 -0500
Subject: [PATCH 02/14] vulkan/wsi: Fix a signal_semaphore_with_memory check

Reviewed-by: Iago Toral Quiroga <itoral@igalia.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/vulkan/wsi/wsi_common.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 0b48f16a0b23..36428a5a7821 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -833,7 +833,7 @@ wsi_signal_semaphore_for_image(struct vk_device *device,
 {
    VK_FROM_HANDLE(vk_semaphore, semaphore, _semaphore);
 
-   if (!chain->wsi->signal_fence_with_memory)
+   if (!chain->wsi->signal_semaphore_with_memory)
       return VK_SUCCESS;
 
    vk_semaphore_reset_temporary(device, semaphore);
-- 
GitLab


From 219a0b26aece0460e5989966e7f725a3d86ffa95 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:33:01 -0500
Subject: [PATCH 03/14] wsi: Always signal semaphores and fences in
 wsi_common_acquire_next_image

If the driver wants to do something special, it can reset the semaphore
or fence again and re-signal it.  Sure, that wastes a malloc/free but
this is the window-system path.  It'll be fine.

Reviewed-by: Iago Toral Quiroga <itoral@igalia.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/vulkan/wsi/wsi_common.c | 40 ++++++++++++++++++++++++++-----------
 1 file changed, 28 insertions(+), 12 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 36428a5a7821..1cf2480ab0fe 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -33,6 +33,8 @@
 #include "vk_physical_device.h"
 #include "vk_queue.h"
 #include "vk_semaphore.h"
+#include "vk_sync.h"
+#include "vk_sync_dummy.h"
 #include "vk_util.h"
 
 #include <time.h>
@@ -831,15 +833,22 @@ wsi_signal_semaphore_for_image(struct vk_device *device,
                                const struct wsi_image *image,
                                VkSemaphore _semaphore)
 {
-   VK_FROM_HANDLE(vk_semaphore, semaphore, _semaphore);
-
-   if (!chain->wsi->signal_semaphore_with_memory)
+   if (device->physical->supported_sync_types == NULL)
       return VK_SUCCESS;
 
+   VK_FROM_HANDLE(vk_semaphore, semaphore, _semaphore);
+
    vk_semaphore_reset_temporary(device, semaphore);
-   return device->create_sync_for_memory(device, image->memory,
-                                         false /* signal_memory */,
-                                         &semaphore->temporary);
+
+   if (chain->wsi->signal_semaphore_with_memory) {
+      return device->create_sync_for_memory(device, image->memory,
+                                            false /* signal_memory */,
+                                            &semaphore->temporary);
+   } else {
+      return vk_sync_create(device, &vk_sync_dummy_type,
+                            0 /* flags */, 0 /* initial_value */,
+                            &semaphore->temporary);
+   }
 }
 
 static VkResult
@@ -848,15 +857,22 @@ wsi_signal_fence_for_image(struct vk_device *device,
                            const struct wsi_image *image,
                            VkFence _fence)
 {
-   VK_FROM_HANDLE(vk_fence, fence, _fence);
-
-   if (!chain->wsi->signal_fence_with_memory)
+   if (device->physical->supported_sync_types == NULL)
       return VK_SUCCESS;
 
+   VK_FROM_HANDLE(vk_fence, fence, _fence);
+
    vk_fence_reset_temporary(device, fence);
-   return device->create_sync_for_memory(device, image->memory,
-                                         false /* signal_memory */,
-                                         &fence->temporary);
+
+   if (chain->wsi->signal_fence_with_memory) {
+      return device->create_sync_for_memory(device, image->memory,
+                                            false /* signal_memory */,
+                                            &fence->temporary);
+   } else {
+      return vk_sync_create(device, &vk_sync_dummy_type,
+                            0 /* flags */, 0 /* initial_value */,
+                            &fence->temporary);
+   }
 }
 
 VkResult
-- 
GitLab


From 4dd2e27880054aee2ebe0cdb48e380bd8487b6eb Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:34:12 -0500
Subject: [PATCH 04/14] panvk: Use the common AcquireNextImage implementation

The only reason for the wrapper was so that we could dummy signal the
semaphore and fence.  Now that the WSI code always dos this for us, we
can drop our wrapper.

Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/panfrost/vulkan/panvk_wsi.c | 42 ---------------------------------
 1 file changed, 42 deletions(-)

diff --git a/src/panfrost/vulkan/panvk_wsi.c b/src/panfrost/vulkan/panvk_wsi.c
index 2af6f85ccc1f..d48f9d2d2c9e 100644
--- a/src/panfrost/vulkan/panvk_wsi.c
+++ b/src/panfrost/vulkan/panvk_wsi.c
@@ -27,9 +27,6 @@
 
 #include "panvk_private.h"
 
-#include "vk_fence.h"
-#include "vk_semaphore.h"
-#include "vk_sync_dummy.h"
 #include "vk_util.h"
 #include "wsi_common.h"
 
@@ -68,42 +65,3 @@ panvk_wsi_finish(struct panvk_physical_device *physical_device)
    wsi_device_finish(&physical_device->wsi_device,
                      &physical_device->instance->vk.alloc);
 }
-
-VkResult
-panvk_AcquireNextImage2KHR(VkDevice _device,
-                           const VkAcquireNextImageInfoKHR *pAcquireInfo,
-                           uint32_t *pImageIndex)
-{
-   VK_FROM_HANDLE(panvk_device, device, _device);
-   VK_FROM_HANDLE(vk_fence, fence, pAcquireInfo->fence);
-   VK_FROM_HANDLE(vk_semaphore, sem, pAcquireInfo->semaphore);
-   struct panvk_physical_device *pdevice = device->physical_device;
-
-   VkResult result =
-      wsi_common_acquire_next_image2(&pdevice->wsi_device, _device,
-                                     pAcquireInfo, pImageIndex);
-
-   /* signal fence/semaphore - image is available immediately */
-   if (result == VK_SUCCESS || result == VK_SUBOPTIMAL_KHR) {
-      VkResult sync_res;
-      if (fence) {
-         vk_fence_reset_temporary(&device->vk, fence);
-         sync_res = vk_sync_create(&device->vk, &vk_sync_dummy_type,
-                                   0 /* flags */, 0 /* initial_value */,
-                                   &fence->temporary);
-         if (sync_res != VK_SUCCESS)
-            return sync_res;
-      }
-
-      if (sem) {
-         vk_semaphore_reset_temporary(&device->vk, sem);
-         sync_res = vk_sync_create(&device->vk, &vk_sync_dummy_type,
-                                   0 /* flags */, 0 /* initial_value */,
-                                   &sem->temporary);
-         if (sync_res != VK_SUCCESS)
-            return sync_res;
-      }
-   }
-
-   return result;
-}
-- 
GitLab


From 97600fd67cba3455622e356393b0a3ca8b70fbd0 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:35:41 -0500
Subject: [PATCH 05/14] v3dv: Use the common AcquireNextImage implementation

The only reason for the wrapper was so that we could dummy signal the
semaphore and fence.  Now that the WSI code always dos this for us, we
can drop our wrapper.

Reviewed-by: Iago Toral Quiroga <itoral@igalia.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/broadcom/vulkan/v3dv_wsi.c | 42 ----------------------------------
 1 file changed, 42 deletions(-)

diff --git a/src/broadcom/vulkan/v3dv_wsi.c b/src/broadcom/vulkan/v3dv_wsi.c
index ad77d3970e9c..5242bc20538d 100644
--- a/src/broadcom/vulkan/v3dv_wsi.c
+++ b/src/broadcom/vulkan/v3dv_wsi.c
@@ -29,9 +29,6 @@
 #include "vk_util.h"
 #include "wsi_common.h"
 #include "wsi_common_drm.h"
-#include "vk_fence.h"
-#include "vk_semaphore.h"
-#include "vk_sync_dummy.h"
 
 static VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
 v3dv_wsi_proc_addr(VkPhysicalDevice physicalDevice, const char *pName)
@@ -147,42 +144,3 @@ v3dv_wsi_get_image_from_swapchain(VkSwapchainKHR swapchain, uint32_t index)
    VkImage image = wsi_common_get_image(swapchain, index);
    return v3dv_image_from_handle(image);
 }
-
-VKAPI_ATTR VkResult VKAPI_CALL
-v3dv_AcquireNextImage2KHR(VkDevice _device,
-                          const VkAcquireNextImageInfoKHR *pAcquireInfo,
-                          uint32_t *pImageIndex)
-{
-   V3DV_FROM_HANDLE(v3dv_device, device, _device);
-   VK_FROM_HANDLE(vk_fence, fence, pAcquireInfo->fence);
-   VK_FROM_HANDLE(vk_semaphore, semaphore, pAcquireInfo->semaphore);
-
-   struct v3dv_physical_device *pdevice = device->pdevice;
-
-   VkResult result = wsi_common_acquire_next_image2(
-      &pdevice->wsi_device, _device, pAcquireInfo, pImageIndex);
-
-   /* signal fence/semaphore - image is available immediately */
-   if (result == VK_SUCCESS || result == VK_SUBOPTIMAL_KHR) {
-      VkResult sync_res;
-      if (fence) {
-         vk_fence_reset_temporary(&device->vk, fence);
-         sync_res = vk_sync_create(&device->vk, &vk_sync_dummy_type,
-                                   0 /* flags */, 1 /* initial_value */,
-                                   &fence->temporary);
-         if (sync_res != VK_SUCCESS)
-            return sync_res;
-      }
-
-      if (semaphore) {
-         vk_semaphore_reset_temporary(&device->vk, semaphore);
-         sync_res = vk_sync_create(&device->vk, &vk_sync_dummy_type,
-                                   0 /* flags */, 1 /* initial_value */,
-                                   &semaphore->temporary);
-         if (sync_res != VK_SUCCESS)
-            return sync_res;
-      }
-   }
-
-   return result;
-}
-- 
GitLab


From 7e9de9c3d00bf0e5996b6a765df519d12b6740f6 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:37:25 -0500
Subject: [PATCH 06/14] radv: Drop create_sync_for_memory

Also, stop setting wsi_device::signal_semaphore/fence_with_memory
because those cause the WSI code to call the function we just dropped.
Since the core WSI code is now setting dummy syncs by default, we don't
need any of this anymore.

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_device.c | 10 ----------
 src/amd/vulkan/radv_wsi.c    |  2 --
 2 files changed, 12 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 0bbcd57c9737..a93506a6f9c3 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -2968,15 +2968,6 @@ radv_device_finish_vrs_image(struct radv_device *device)
                      &device->meta_state.alloc);
 }
 
-static VkResult
-radv_create_sync_for_memory(struct vk_device *device,
-                           VkDeviceMemory memory,
-                           bool signal_memory,
-                           struct vk_sync **sync_out)
-{
-   return vk_sync_create(device, &vk_sync_dummy_type, 0, 1, sync_out);
-}
-
 static enum radv_force_vrs
 radv_parse_vrs_rates(const char *str)
 {
@@ -3244,7 +3235,6 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
    simple_mtx_init(&device->trace_mtx, mtx_plain);
 
    device->ws = physical_device->ws;
-   device->vk.create_sync_for_memory = radv_create_sync_for_memory;
    vk_device_set_drm_fd(&device->vk, device->ws->get_fd(device->ws));
 
    /* With update after bind we can't attach bo's to the command buffer
diff --git a/src/amd/vulkan/radv_wsi.c b/src/amd/vulkan/radv_wsi.c
index d3114ab2ecb6..8d72865ffc84 100644
--- a/src/amd/vulkan/radv_wsi.c
+++ b/src/amd/vulkan/radv_wsi.c
@@ -99,8 +99,6 @@ radv_init_wsi(struct radv_physical_device *physical_device)
    physical_device->wsi_device.supports_modifiers = physical_device->rad_info.gfx_level >= GFX9;
    physical_device->wsi_device.set_memory_ownership = radv_wsi_set_memory_ownership;
    physical_device->wsi_device.get_buffer_blit_queue = radv_wsi_get_prime_blit_queue;
-   physical_device->wsi_device.signal_semaphore_with_memory = true;
-   physical_device->wsi_device.signal_fence_with_memory = true;
 
    wsi_device_setup_syncobj_fd(&physical_device->wsi_device, physical_device->local_fd);
 
-- 
GitLab


From fc27067b9587c2f3e42c78428c23bafd45fcb9ad Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:38:27 -0500
Subject: [PATCH 07/14] lavapipe: Use the common AcquireNextImage
 implementation

The only reason for the wrapper was so that we could dummy signal the
semaphore and fence.  Now that the WSI code always dos this for us, we
can drop our wrapper.

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/gallium/frontends/lavapipe/lvp_wsi.c | 43 ------------------------
 1 file changed, 43 deletions(-)

diff --git a/src/gallium/frontends/lavapipe/lvp_wsi.c b/src/gallium/frontends/lavapipe/lvp_wsi.c
index 333241ac97a7..39d4f826fa8e 100644
--- a/src/gallium/frontends/lavapipe/lvp_wsi.c
+++ b/src/gallium/frontends/lavapipe/lvp_wsi.c
@@ -23,10 +23,6 @@
 
 #include "lvp_wsi.h"
 
-#include "vk_fence.h"
-#include "vk_semaphore.h"
-#include "vk_sync_dummy.h"
-
 static VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
 lvp_wsi_proc_addr(VkPhysicalDevice physicalDevice, const char *pName)
 {
@@ -59,42 +55,3 @@ lvp_finish_wsi(struct lvp_physical_device *physical_device)
    wsi_device_finish(&physical_device->wsi_device,
                      &physical_device->vk.instance->alloc);
 }
-
-VKAPI_ATTR VkResult VKAPI_CALL lvp_AcquireNextImage2KHR(
-   VkDevice                                     _device,
-   const VkAcquireNextImageInfoKHR*             pAcquireInfo,
-   uint32_t*                                    pImageIndex)
-{
-   LVP_FROM_HANDLE(lvp_device, device, _device);
-   struct lvp_physical_device *pdevice = device->physical_device;
-
-   VkResult result = wsi_common_acquire_next_image2(&pdevice->wsi_device,
-                                                    _device,
-                                                    pAcquireInfo,
-                                                    pImageIndex);
-
-   VK_FROM_HANDLE(vk_fence, fence, pAcquireInfo->fence);
-   VK_FROM_HANDLE(vk_semaphore, sem, pAcquireInfo->semaphore);
-   if (result == VK_SUCCESS || result == VK_SUBOPTIMAL_KHR) {
-      VkResult sync_res;
-      if (fence) {
-         vk_fence_reset_temporary(&device->vk, fence);
-         sync_res = vk_sync_create(&device->vk, &vk_sync_dummy_type,
-                                   0 /* flags */, 0 /* initial_value */,
-                                   &fence->temporary);
-         if (sync_res != VK_SUCCESS)
-            return sync_res;
-      }
-
-      if (sem) {
-         vk_semaphore_reset_temporary(&device->vk, sem);
-         sync_res = vk_sync_create(&device->vk, &vk_sync_dummy_type,
-                                   0 /* flags */, 0 /* initial_value */,
-                                   &sem->temporary);
-         if (sync_res != VK_SUCCESS)
-            return sync_res;
-      }
-   }
-
-   return result;
-}
-- 
GitLab


From 73ef7c957f0b832a38d2daea6ef9b93fb25f1602 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 19:39:04 -0500
Subject: [PATCH 08/14] pvr: Use the common AcquireNextImage implementation

The only reason for the wrapper was so that we could dummy signal the
semaphore and fence.  Now that the WSI code always dos this for us, we
can drop our wrapper.

Reviewed-by: Rajnesh Kanwal <rajnesh.kanwal@imgtec.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/imagination/vulkan/pvr_wsi.c | 45 --------------------------------
 1 file changed, 45 deletions(-)

diff --git a/src/imagination/vulkan/pvr_wsi.c b/src/imagination/vulkan/pvr_wsi.c
index 3d44ef3816b9..65650e1a86c0 100644
--- a/src/imagination/vulkan/pvr_wsi.c
+++ b/src/imagination/vulkan/pvr_wsi.c
@@ -31,10 +31,7 @@
 
 #include "pvr_private.h"
 #include "util/u_atomic.h"
-#include "vk_fence.h"
 #include "vk_object.h"
-#include "vk_semaphore.h"
-#include "vk_sync_dummy.h"
 #include "wsi_common.h"
 
 static PFN_vkVoidFunction pvr_wsi_proc_addr(VkPhysicalDevice physicalDevice,
@@ -89,45 +86,3 @@ VkResult pvr_QueuePresentKHR(VkQueue _queue,
 
    return VK_SUCCESS;
 }
-
-VkResult pvr_AcquireNextImage2KHR(VkDevice _device,
-                                  const VkAcquireNextImageInfoKHR *pAcquireInfo,
-                                  uint32_t *pImageIndex)
-{
-   VK_FROM_HANDLE(vk_semaphore, sem, pAcquireInfo->semaphore);
-   VK_FROM_HANDLE(vk_fence, fence, pAcquireInfo->fence);
-   PVR_FROM_HANDLE(pvr_device, device, _device);
-   VkResult result;
-   VkResult ret;
-
-   result = wsi_common_acquire_next_image2(&device->pdevice->wsi_device,
-                                           _device,
-                                           pAcquireInfo,
-                                           pImageIndex);
-   if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)
-      return result;
-
-   if (fence) {
-      vk_fence_reset_temporary(&device->vk, fence);
-      ret = vk_sync_create(&device->vk,
-                           &vk_sync_dummy_type,
-                           0U,
-                           0UL,
-                           &fence->temporary);
-      if (ret != VK_SUCCESS)
-         return ret;
-   }
-
-   if (sem) {
-      vk_semaphore_reset_temporary(&device->vk, sem);
-      ret = vk_sync_create(&device->vk,
-                           &vk_sync_dummy_type,
-                           0U,
-                           0UL,
-                           &sem->temporary);
-      if (ret != VK_SUCCESS)
-         return ret;
-   }
-
-   return result;
-}
-- 
GitLab


From 7d5fb3f731001b6915d8cf33b948fe0e20c6c851 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 20:09:52 -0500
Subject: [PATCH 09/14] vulkan/wsi: Use a STACK_ARRAY for stage_flags

This avoids the heap allocation in the common case.

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/vulkan/wsi/wsi_common.c | 23 +++++++----------------
 1 file changed, 7 insertions(+), 16 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 1cf2480ab0fe..6c6b76224649 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -936,6 +936,11 @@ wsi_common_queue_present(const struct wsi_device *wsi,
 {
    VkResult final_result = VK_SUCCESS;
 
+   STACK_ARRAY(VkPipelineStageFlags, stage_flags,
+               pPresentInfo->waitSemaphoreCount);
+   for (uint32_t s = 0; s < pPresentInfo->waitSemaphoreCount; s++)
+      stage_flags[s] = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+
    const VkPresentRegionsKHR *regions =
       vk_find_struct_const(pPresentInfo->pNext, PRESENT_REGIONS_KHR);
 
@@ -990,27 +995,12 @@ wsi_common_queue_present(const struct wsi_device *wsi,
          .pNext = &mem_signal,
       };
 
-      VkPipelineStageFlags *stage_flags = NULL;
       if (i == 0) {
          /* We only need/want to wait on semaphores once.  After that, we're
           * guaranteed ordering since it all happens on the same queue.
           */
          submit_info.waitSemaphoreCount = pPresentInfo->waitSemaphoreCount;
          submit_info.pWaitSemaphores = pPresentInfo->pWaitSemaphores;
-
-         /* Set up the pWaitDstStageMasks */
-         stage_flags = vk_alloc(&swapchain->alloc,
-                                sizeof(VkPipelineStageFlags) *
-                                pPresentInfo->waitSemaphoreCount,
-                                8,
-                                VK_SYSTEM_ALLOCATION_SCOPE_COMMAND);
-         if (!stage_flags) {
-            result = VK_ERROR_OUT_OF_HOST_MEMORY;
-            goto fail_present;
-         }
-         for (uint32_t s = 0; s < pPresentInfo->waitSemaphoreCount; s++)
-            stage_flags[s] = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-
          submit_info.pWaitDstStageMask = stage_flags;
       }
 
@@ -1039,7 +1029,6 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       }
 
       result = wsi->QueueSubmit(queue, 1, &submit_info, fence);
-      vk_free(&swapchain->alloc, stage_flags);
       if (result != VK_SUCCESS)
          goto fail_present;
 
@@ -1087,6 +1076,8 @@ wsi_common_queue_present(const struct wsi_device *wsi,
          final_result = result;
    }
 
+   STACK_ARRAY_FINISH(stage_flags);
+
    return final_result;
 }
 
-- 
GitLab


From 45c5c2ce0eb704ecb2ca3616faefaf05803ce23e Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 20:05:21 -0500
Subject: [PATCH 10/14] vulkan/wsi: Reset fences earlier in
 wsi_common_queue_present

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/vulkan/wsi/wsi_common.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 6c6b76224649..a073c6b2524b 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -981,6 +981,10 @@ wsi_common_queue_present(const struct wsi_device *wsi,
             goto fail_present;
       }
 
+      result = wsi->ResetFences(device, 1, &swapchain->fences[image_index]);
+      if (result != VK_SUCCESS)
+         goto fail_present;
+
       struct wsi_image *image =
          swapchain->get_wsi_image(swapchain, image_index);
 
@@ -1004,10 +1008,6 @@ wsi_common_queue_present(const struct wsi_device *wsi,
          submit_info.pWaitDstStageMask = stage_flags;
       }
 
-      result = wsi->ResetFences(device, 1, &swapchain->fences[image_index]);
-      if (result != VK_SUCCESS)
-         goto fail_present;
-
       VkFence fence = swapchain->fences[image_index];
       if (swapchain->use_buffer_blit) {
          if (swapchain->buffer_blit_queue == VK_NULL_HANDLE) {
-- 
GitLab


From d9b52f0a6bb1089014693ada7dcd4b4bff3e623b Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 19 May 2022 20:23:30 -0500
Subject: [PATCH 11/14] vulkan/wsi: Re-arrange QueueSubmit code in
 wsi_common_queue_present

Instead of treating the blit submit specially in the buffer_blit_queue
case, treat the dummy submit as special.  This lets us keep all the
handling of special-queue blits together.  It also means that the
wsi_memory_signal_submit_info gets chained into the final submit which
is what we want if we're to rely on it for implicit sync.  If we chain
it into the dummy submit, we'll implicit sync on all work previous to
the blit but not the blit.  This won't work if X11 or a Wayland
compositor is depending on that to synchronize the linear copy.

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/vulkan/wsi/wsi_common.c | 66 +++++++++++++++++--------------------
 1 file changed, 31 insertions(+), 35 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index a073c6b2524b..b63d669d0091 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -985,18 +985,8 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       if (result != VK_SUCCESS)
          goto fail_present;
 
-      struct wsi_image *image =
-         swapchain->get_wsi_image(swapchain, image_index);
-
-      struct wsi_memory_signal_submit_info mem_signal = {
-         .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_SIGNAL_SUBMIT_INFO_MESA,
-         .pNext = NULL,
-         .memory = image->memory,
-      };
-
       VkSubmitInfo submit_info = {
          .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
-         .pNext = &mem_signal,
       };
 
       if (i == 0) {
@@ -1008,48 +998,54 @@ wsi_common_queue_present(const struct wsi_device *wsi,
          submit_info.pWaitDstStageMask = stage_flags;
       }
 
-      VkFence fence = swapchain->fences[image_index];
+      struct wsi_image *image =
+         swapchain->get_wsi_image(swapchain, image_index);
+
+      VkQueue submit_queue = queue;
       if (swapchain->use_buffer_blit) {
          if (swapchain->buffer_blit_queue == VK_NULL_HANDLE) {
-            /* If we are using default buffer blits, we need to perform the blit now.  The
-             * command buffer is attached to the image.
-             */
             submit_info.commandBufferCount = 1;
             submit_info.pCommandBuffers =
                &image->buffer.blit_cmd_buffers[queue_family_index];
-            mem_signal.memory = image->buffer.memory;
          } else {
-            /* If we are using a blit using the driver's private queue, then do an empty
-             * submit signalling a semaphore, and then submit the blit.
+            /* If we are using a blit using the driver's private queue, then
+             * do an empty submit signalling a semaphore, and then submit the
+             * blit waiting on that.  This ensures proper queue ordering of
+             * vkQueueSubmit() calls.
              */
-            fence = VK_NULL_HANDLE;
             submit_info.signalSemaphoreCount = 1;
-            submit_info.pSignalSemaphores = &swapchain->buffer_blit_semaphores[image_index];
-         }
-      }
+            submit_info.pSignalSemaphores =
+               &swapchain->buffer_blit_semaphores[image_index];
 
-      result = wsi->QueueSubmit(queue, 1, &submit_info, fence);
-      if (result != VK_SUCCESS)
-         goto fail_present;
-
-      if (swapchain->use_buffer_blit && swapchain->buffer_blit_queue != VK_NULL_HANDLE) {
-         submit_info.commandBufferCount = 1;
+            result = wsi->QueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE);
+            if (result != VK_SUCCESS)
+               goto fail_present;
 
-         if (swapchain->buffer_blit_queue != VK_NULL_HANDLE) {
-            submit_info.pCommandBuffers = &image->buffer.blit_cmd_buffers[0];
+            /* Now prepare the blit submit.  It needs to then wait on the
+             * semaphore we signaled above.
+             */
+            submit_queue = swapchain->buffer_blit_queue;
             submit_info.waitSemaphoreCount = 1;
             submit_info.pWaitSemaphores = submit_info.pSignalSemaphores;
             submit_info.signalSemaphoreCount = 0;
             submit_info.pSignalSemaphores = NULL;
-            /* Submit the copy to the private transfer queue */
-            result = wsi->QueueSubmit(swapchain->buffer_blit_queue,
-                                      1,
-                                      &submit_info,
-                                      swapchain->fences[image_index]);
+            submit_info.commandBufferCount = 1;
+            submit_info.pCommandBuffers = &image->buffer.blit_cmd_buffers[0];
          }
-         mem_signal.memory = image->buffer.memory;
       }
 
+      VkFence fence = swapchain->fences[image_index];
+
+      struct wsi_memory_signal_submit_info mem_signal = {
+         .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_SIGNAL_SUBMIT_INFO_MESA,
+         .memory = image->memory,
+      };
+      __vk_append_struct(&submit_info, &mem_signal);
+
+      result = wsi->QueueSubmit(submit_queue, 1, &submit_info, fence);
+      if (result != VK_SUCCESS)
+         goto fail_present;
+
       if (wsi->sw)
 	      wsi->WaitForFences(device, 1, &swapchain->fences[image_index],
 				 true, ~0ull);
-- 
GitLab


From 875d3d4c3643bc6b4725c08550d8a07cde314160 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason@jlekstrand.net>
Date: Mon, 15 Mar 2021 12:19:54 -0500
Subject: [PATCH 12/14] vulkan/wsi: Set memory ownership after signaling fences
 and semaphores

This isn't a functional change today because the set of drivers which
use set_ownership and those that use signal_fence/semaphore_for_memory
are mutually exclusive.  It's important for the next commit, though.

Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/vulkan/wsi/wsi_common.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index b63d669d0091..ba701eaf487f 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -888,12 +888,6 @@ wsi_common_acquire_next_image2(const struct wsi_device *wsi,
                                                    pImageIndex);
    if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)
       return result;
-
-   if (wsi->set_memory_ownership) {
-      VkDeviceMemory mem = swapchain->get_wsi_image(swapchain, *pImageIndex)->memory;
-      wsi->set_memory_ownership(swapchain->device, mem, true);
-   }
-
    struct wsi_image *image =
       swapchain->get_wsi_image(swapchain, *pImageIndex);
 
@@ -913,6 +907,9 @@ wsi_common_acquire_next_image2(const struct wsi_device *wsi,
          return signal_result;
    }
 
+   if (wsi->set_memory_ownership)
+      wsi->set_memory_ownership(swapchain->device, image->memory, true);
+
    return result;
 }
 
-- 
GitLab


From 11dbf8d7515907b31b81240a4566af99534f0de7 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason@jlekstrand.net>
Date: Mon, 15 Mar 2021 12:06:53 -0500
Subject: [PATCH 13/14] vulkan/wsi: Signal semaphores and fences from the
 dma-buf

Instead of attempting to signal based on the memory object, use the new
DMA_BUF_IOCTL_EXPORT_SYNC_FILE to get a sync_file for the dma-buf and
use that to signal the semaphore or fence.  Because this happens before
we transfer ownership back to the driver, the resulting sync_file should
only contain dma_fences from the compositor and/or display and shouldn't
be mixed up with the driver in any way.  This gives us a real semaphore
and fence (as opposed to the dummy objects we've used int the past)
without over-synchronization.

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/vulkan/wsi/wsi_common.c         |  70 +++++++++-
 src/vulkan/wsi/wsi_common.h         |   3 +
 src/vulkan/wsi/wsi_common_drm.c     | 205 ++++++++++++++++++++++++++++
 src/vulkan/wsi/wsi_common_private.h |  15 ++
 4 files changed, 288 insertions(+), 5 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index ba701eaf487f..9171d05ed822 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -64,6 +64,7 @@ wsi_device_init(struct wsi_device *wsi,
    wsi->sw = sw_device;
 #define WSI_GET_CB(func) \
    PFN_vk##func func = (PFN_vk##func)proc_addr(pdevice, "vk" #func)
+   WSI_GET_CB(GetPhysicalDeviceExternalSemaphoreProperties);
    WSI_GET_CB(GetPhysicalDeviceProperties2);
    WSI_GET_CB(GetPhysicalDeviceMemoryProperties);
    WSI_GET_CB(GetPhysicalDeviceQueueFamilyProperties);
@@ -83,6 +84,23 @@ wsi_device_init(struct wsi_device *wsi,
    GetPhysicalDeviceMemoryProperties(pdevice, &wsi->memory_props);
    GetPhysicalDeviceQueueFamilyProperties(pdevice, &wsi->queue_family_count, NULL);
 
+   for (VkExternalSemaphoreHandleTypeFlags handle_type = 1;
+        handle_type <= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+        handle_type <<= 1) {
+      const VkPhysicalDeviceExternalSemaphoreInfo esi = {
+         .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
+         .handleType = handle_type,
+      };
+      VkExternalSemaphoreProperties esp = {
+         .sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
+      };
+      GetPhysicalDeviceExternalSemaphoreProperties(pdevice, &esi, &esp);
+
+      if (esp.externalSemaphoreFeatures &
+          VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT)
+         wsi->semaphore_export_handle_types |= handle_type;
+   }
+
    list_inithead(&wsi->hotplug_fences);
 
 #define WSI_GET_CB(func) \
@@ -116,6 +134,7 @@ wsi_device_init(struct wsi_device *wsi,
    WSI_GET_CB(GetPhysicalDeviceFormatProperties);
    WSI_GET_CB(GetPhysicalDeviceFormatProperties2KHR);
    WSI_GET_CB(GetPhysicalDeviceImageFormatProperties2);
+   WSI_GET_CB(GetSemaphoreFdKHR);
    WSI_GET_CB(ResetFences);
    WSI_GET_CB(QueueSubmit);
    WSI_GET_CB(WaitForFences);
@@ -349,6 +368,8 @@ wsi_swapchain_finish(struct wsi_swapchain *chain)
 
       vk_free(&chain->alloc, chain->buffer_blit_semaphores);
    }
+   chain->wsi->DestroySemaphore(chain->device, chain->dma_buf_semaphore,
+                                &chain->alloc);
 
    int cmd_pools_count = chain->buffer_blit_queue != VK_NULL_HANDLE ?
       1 : chain->wsi->queue_family_count;
@@ -840,6 +861,14 @@ wsi_signal_semaphore_for_image(struct vk_device *device,
 
    vk_semaphore_reset_temporary(device, semaphore);
 
+#ifndef _WIN32
+   VkResult result = wsi_create_sync_for_dma_buf_wait(chain, image,
+                                                      VK_SYNC_FEATURE_GPU_WAIT,
+                                                      &semaphore->temporary);
+   if (result != VK_ERROR_FEATURE_NOT_PRESENT)
+      return result;
+#endif
+
    if (chain->wsi->signal_semaphore_with_memory) {
       return device->create_sync_for_memory(device, image->memory,
                                             false /* signal_memory */,
@@ -864,6 +893,14 @@ wsi_signal_fence_for_image(struct vk_device *device,
 
    vk_fence_reset_temporary(device, fence);
 
+#ifndef _WIN32
+   VkResult result = wsi_create_sync_for_dma_buf_wait(chain, image,
+                                                      VK_SYNC_FEATURE_CPU_WAIT,
+                                                      &fence->temporary);
+   if (result != VK_ERROR_FEATURE_NOT_PRESENT)
+      return result;
+#endif
+
    if (chain->wsi->signal_fence_with_memory) {
       return device->create_sync_for_memory(device, image->memory,
                                             false /* signal_memory */,
@@ -1033,16 +1070,39 @@ wsi_common_queue_present(const struct wsi_device *wsi,
 
       VkFence fence = swapchain->fences[image_index];
 
-      struct wsi_memory_signal_submit_info mem_signal = {
-         .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_SIGNAL_SUBMIT_INFO_MESA,
-         .memory = image->memory,
-      };
-      __vk_append_struct(&submit_info, &mem_signal);
+      bool has_signal_dma_buf = true;
+      struct wsi_memory_signal_submit_info mem_signal;
+      result = wsi_prepare_signal_dma_buf_from_semaphore(swapchain, image);
+      if (result == VK_SUCCESS) {
+         assert(submit_info.signalSemaphoreCount == 0);
+         submit_info.signalSemaphoreCount = 1;
+         submit_info.pSignalSemaphores = &swapchain->dma_buf_semaphore;
+         has_signal_dma_buf = true;
+      } else if (result == VK_ERROR_FEATURE_NOT_PRESENT) {
+         /* If we don't have dma-buf signaling, signal the memory object by
+          * chaining wsi_memory_signal_submit_info into VkSubmitInfo.
+          */
+         result = VK_SUCCESS;
+         has_signal_dma_buf = false;
+         mem_signal = (struct wsi_memory_signal_submit_info) {
+            .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_SIGNAL_SUBMIT_INFO_MESA,
+            .memory = image->memory,
+         };
+         __vk_append_struct(&submit_info, &mem_signal);
+      } else {
+         goto fail_present;
+      }
 
       result = wsi->QueueSubmit(submit_queue, 1, &submit_info, fence);
       if (result != VK_SUCCESS)
          goto fail_present;
 
+      if (has_signal_dma_buf) {
+         result = wsi_signal_dma_buf_from_semaphore(swapchain, image);
+         if (result != VK_SUCCESS)
+            goto fail_present;
+      }
+
       if (wsi->sw)
 	      wsi->WaitForFences(device, 1, &swapchain->fences[image_index],
 				 true, ~0ull);
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index f96632308df1..7821e0b02004 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -102,6 +102,8 @@ struct wsi_device {
 
    VkPhysicalDevicePCIBusInfoPropertiesEXT pci_bus_info;
 
+   VkExternalSemaphoreHandleTypeFlags semaphore_export_handle_types;
+
    bool supports_modifiers;
    uint32_t maxImageDimension2D;
    VkPresentModeKHR override_present_mode;
@@ -209,6 +211,7 @@ struct wsi_device {
    WSI_CB(GetPhysicalDeviceFormatProperties);
    WSI_CB(GetPhysicalDeviceFormatProperties2KHR);
    WSI_CB(GetPhysicalDeviceImageFormatProperties2);
+   WSI_CB(GetSemaphoreFdKHR);
    WSI_CB(ResetFences);
    WSI_CB(QueueSubmit);
    WSI_CB(WaitForFences);
diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index 2f82963841da..ed600606912f 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -26,16 +26,221 @@
 #include "util/macros.h"
 #include "util/os_file.h"
 #include "util/xmlconfig.h"
+#include "vk_device.h"
 #include "vk_format.h"
+#include "vk_physical_device.h"
 #include "vk_util.h"
 #include "drm-uapi/drm_fourcc.h"
 
+#include <errno.h>
+#include <linux/dma-buf.h>
+#include <linux/sync_file.h>
 #include <time.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <xf86drm.h>
 
+struct dma_buf_export_sync_file_wsi {
+   __u32 flags;
+   __s32 fd;
+};
+
+struct dma_buf_import_sync_file_wsi {
+   __u32 flags;
+   __s32 fd;
+};
+
+#define DMA_BUF_IOCTL_EXPORT_SYNC_FILE_WSI   _IOWR(DMA_BUF_BASE, 2, struct dma_buf_export_sync_file_wsi)
+#define DMA_BUF_IOCTL_IMPORT_SYNC_FILE_WSI   _IOW(DMA_BUF_BASE, 3, struct dma_buf_import_sync_file_wsi)
+
+static VkResult
+wsi_dma_buf_export_sync_file(int dma_buf_fd, int *sync_file_fd)
+{
+   /* Don't keep trying an IOCTL that doesn't exist. */
+   static bool no_dma_buf_sync_file = false;
+   if (no_dma_buf_sync_file)
+      return VK_ERROR_FEATURE_NOT_PRESENT;
+
+   struct dma_buf_export_sync_file_wsi export = {
+      .flags = DMA_BUF_SYNC_RW,
+      .fd = -1,
+   };
+   int ret = drmIoctl(dma_buf_fd, DMA_BUF_IOCTL_EXPORT_SYNC_FILE_WSI, &export);
+   if (ret) {
+      if (errno == ENOTTY) {
+         no_dma_buf_sync_file = true;
+         return VK_ERROR_FEATURE_NOT_PRESENT;
+      } else {
+         return VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+   }
+
+   *sync_file_fd = export.fd;
+
+   return VK_SUCCESS;
+}
+
+static VkResult
+wsi_dma_buf_import_sync_file(int dma_buf_fd, int sync_file_fd)
+{
+   /* Don't keep trying an IOCTL that doesn't exist. */
+   static bool no_dma_buf_sync_file = false;
+   if (no_dma_buf_sync_file)
+      return VK_ERROR_FEATURE_NOT_PRESENT;
+
+   struct dma_buf_import_sync_file_wsi import = {
+      .flags = DMA_BUF_SYNC_RW,
+      .fd = sync_file_fd,
+   };
+   int ret = drmIoctl(dma_buf_fd, DMA_BUF_IOCTL_IMPORT_SYNC_FILE_WSI, &import);
+   if (ret) {
+      if (errno == ENOTTY) {
+         no_dma_buf_sync_file = true;
+         return VK_ERROR_FEATURE_NOT_PRESENT;
+      } else {
+         return VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+   }
+
+   return VK_SUCCESS;
+}
+
+static VkResult
+prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
+                                      const struct wsi_image *image)
+{
+   VkResult result;
+
+   if (!(chain->wsi->semaphore_export_handle_types &
+         VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT))
+      return VK_ERROR_FEATURE_NOT_PRESENT;
+
+   int sync_file_fd = -1;
+   result = wsi_dma_buf_export_sync_file(image->dma_buf_fd, &sync_file_fd);
+   if (result != VK_SUCCESS)
+      return result;
+
+   result = wsi_dma_buf_import_sync_file(image->dma_buf_fd, sync_file_fd);
+   close(sync_file_fd);
+   if (result != VK_SUCCESS)
+      return result;
+
+   /* If we got here, all our checks pass.  Create the actual semaphore */
+   const VkExportSemaphoreCreateInfo export_info = {
+      .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
+      .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
+   };
+   const VkSemaphoreCreateInfo semaphore_info = {
+      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
+      .pNext = &export_info,
+   };
+   result = chain->wsi->CreateSemaphore(chain->device, &semaphore_info,
+                                        &chain->alloc,
+                                        &chain->dma_buf_semaphore);
+   if (result != VK_SUCCESS)
+      return result;
+
+   return VK_SUCCESS;
+}
+
+VkResult
+wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
+                                          const struct wsi_image *image)
+{
+   VkResult result;
+
+   /* We cache result - 1 in the swapchain */
+   if (unlikely(chain->signal_dma_buf_from_semaphore == 0)) {
+      result = prepare_signal_dma_buf_from_semaphore(chain, image);
+      assert(result <= 0);
+      chain->signal_dma_buf_from_semaphore = (int)result - 1;
+   } else {
+      result = (VkResult)(chain->signal_dma_buf_from_semaphore + 1);
+   }
+
+   return result;
+}
+
+VkResult
+wsi_signal_dma_buf_from_semaphore(const struct wsi_swapchain *chain,
+                                  const struct wsi_image *image)
+{
+   VkResult result;
+
+   const VkSemaphoreGetFdInfoKHR get_fd_info = {
+      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
+      .semaphore = chain->dma_buf_semaphore,
+      .handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
+   };
+   int sync_file_fd = -1;
+   result = chain->wsi->GetSemaphoreFdKHR(chain->device, &get_fd_info,
+                                          &sync_file_fd);
+   if (result != VK_SUCCESS)
+      return result;
+
+   result = wsi_dma_buf_import_sync_file(image->dma_buf_fd, sync_file_fd);
+   close(sync_file_fd);
+   return result;
+}
+
+static const struct vk_sync_type *
+get_sync_file_sync_type(struct vk_device *device,
+                        enum vk_sync_features req_features)
+{
+   for (const struct vk_sync_type *const *t =
+        device->physical->supported_sync_types; *t; t++) {
+      if (req_features & ~(*t)->features)
+         continue;
+
+      if ((*t)->import_sync_file != NULL)
+         return *t;
+   }
+
+   return NULL;
+}
+
+VkResult
+wsi_create_sync_for_dma_buf_wait(const struct wsi_swapchain *chain,
+                                 const struct wsi_image *image,
+                                 enum vk_sync_features req_features,
+                                 struct vk_sync **sync_out)
+{
+   VK_FROM_HANDLE(vk_device, device, chain->device);
+   VkResult result;
+
+   const struct vk_sync_type *sync_type =
+      get_sync_file_sync_type(device, req_features);
+   if (sync_type == NULL)
+      return VK_ERROR_FEATURE_NOT_PRESENT;
+
+   int sync_file_fd = -1;
+   result = wsi_dma_buf_export_sync_file(image->dma_buf_fd, &sync_file_fd);
+   if (result != VK_SUCCESS)
+      return result;
+
+   struct vk_sync *sync = NULL;
+   result = vk_sync_create(device, sync_type, VK_SYNC_IS_SHAREABLE, 0, &sync);
+   if (result != VK_SUCCESS)
+      goto fail_close_sync_file;
+
+   result = vk_sync_import_sync_file(device, sync, sync_file_fd);
+   if (result != VK_SUCCESS)
+      goto fail_destroy_sync;
+
+   close(sync_file_fd);
+   *sync_out = sync;
+
+   return VK_SUCCESS;
+
+fail_destroy_sync:
+   vk_sync_destroy(device, sync);
+fail_close_sync_file:
+   close(sync_file_fd);
+
+   return result;
+}
+
 bool
 wsi_common_drm_devices_equal(int fd_a, int fd_b)
 {
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index b5198d45b0b6..e5d6bb5204bb 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -25,6 +25,7 @@
 
 #include "wsi_common.h"
 #include "vulkan/runtime/vk_object.h"
+#include "vulkan/runtime/vk_sync.h"
 
 struct wsi_image;
 struct wsi_swapchain;
@@ -97,6 +98,9 @@ struct wsi_swapchain {
    VkSemaphore* buffer_blit_semaphores;
    VkPresentModeKHR present_mode;
 
+   int signal_dma_buf_from_semaphore;
+   VkSemaphore dma_buf_semaphore;
+
    struct wsi_image_info image_info;
    uint32_t image_count;
 
@@ -193,6 +197,17 @@ void
 wsi_destroy_image(const struct wsi_swapchain *chain,
                   struct wsi_image *image);
 
+VkResult
+wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
+                                          const struct wsi_image *image);
+VkResult
+wsi_signal_dma_buf_from_semaphore(const struct wsi_swapchain *chain,
+                                  const struct wsi_image *image);
+VkResult
+wsi_create_sync_for_dma_buf_wait(const struct wsi_swapchain *chain,
+                                 const struct wsi_image *image,
+                                 enum vk_sync_features sync_features,
+                                 struct vk_sync **sync_out);
 
 struct wsi_interface {
    VkResult (*get_support)(VkIcdSurfaceBase *surface,
-- 
GitLab


From 8cee006e95787661c1d919ff78882cef50d6a056 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Thu, 26 May 2022 16:04:18 -0500
Subject: [PATCH 14/14] FIXUP: Use dma-buf caps to detect import/export

---
 src/vulkan/wsi/wsi_common.c         |  70 +++++-------
 src/vulkan/wsi/wsi_common.h         |   4 +-
 src/vulkan/wsi/wsi_common_drm.c     | 165 ++++++++++++++--------------
 src/vulkan/wsi/wsi_common_private.h |   5 +-
 4 files changed, 120 insertions(+), 124 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 9171d05ed822..e6442c35aa30 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -64,7 +64,6 @@ wsi_device_init(struct wsi_device *wsi,
    wsi->sw = sw_device;
 #define WSI_GET_CB(func) \
    PFN_vk##func func = (PFN_vk##func)proc_addr(pdevice, "vk" #func)
-   WSI_GET_CB(GetPhysicalDeviceExternalSemaphoreProperties);
    WSI_GET_CB(GetPhysicalDeviceProperties2);
    WSI_GET_CB(GetPhysicalDeviceMemoryProperties);
    WSI_GET_CB(GetPhysicalDeviceQueueFamilyProperties);
@@ -84,23 +83,6 @@ wsi_device_init(struct wsi_device *wsi,
    GetPhysicalDeviceMemoryProperties(pdevice, &wsi->memory_props);
    GetPhysicalDeviceQueueFamilyProperties(pdevice, &wsi->queue_family_count, NULL);
 
-   for (VkExternalSemaphoreHandleTypeFlags handle_type = 1;
-        handle_type <= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
-        handle_type <<= 1) {
-      const VkPhysicalDeviceExternalSemaphoreInfo esi = {
-         .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
-         .handleType = handle_type,
-      };
-      VkExternalSemaphoreProperties esp = {
-         .sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
-      };
-      GetPhysicalDeviceExternalSemaphoreProperties(pdevice, &esi, &esp);
-
-      if (esp.externalSemaphoreFeatures &
-          VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT)
-         wsi->semaphore_export_handle_types |= handle_type;
-   }
-
    list_inithead(&wsi->hotplug_fences);
 
 #define WSI_GET_CB(func) \
@@ -131,6 +113,7 @@ wsi_device_init(struct wsi_device *wsi,
    WSI_GET_CB(GetImageSubresourceLayout);
    if (!wsi->sw)
       WSI_GET_CB(GetMemoryFdKHR);
+   WSI_GET_CB(GetPhysicalDeviceExternalSemaphoreProperties);
    WSI_GET_CB(GetPhysicalDeviceFormatProperties);
    WSI_GET_CB(GetPhysicalDeviceFormatProperties2KHR);
    WSI_GET_CB(GetPhysicalDeviceImageFormatProperties2);
@@ -142,6 +125,12 @@ wsi_device_init(struct wsi_device *wsi,
    WSI_GET_CB(UnmapMemory);
 #undef WSI_GET_CB
 
+#ifndef _WIN32
+   result = wsi_dma_buf_init_wsi(wsi);
+   if (result != VK_SUCCESS)
+      goto fail;
+#endif
+
 #ifdef VK_USE_PLATFORM_XCB_KHR
    result = wsi_x11_init_wsi(wsi, alloc, dri_options);
    if (result != VK_SUCCESS)
@@ -862,11 +851,11 @@ wsi_signal_semaphore_for_image(struct vk_device *device,
    vk_semaphore_reset_temporary(device, semaphore);
 
 #ifndef _WIN32
-   VkResult result = wsi_create_sync_for_dma_buf_wait(chain, image,
-                                                      VK_SYNC_FEATURE_GPU_WAIT,
-                                                      &semaphore->temporary);
-   if (result != VK_ERROR_FEATURE_NOT_PRESENT)
-      return result;
+   if (chain->wsi->has_dma_buf_explicit_sync) {
+      return wsi_create_sync_for_dma_buf_wait(chain, image,
+                                              VK_SYNC_FEATURE_GPU_WAIT,
+                                              &semaphore->temporary);
+   }
 #endif
 
    if (chain->wsi->signal_semaphore_with_memory) {
@@ -894,11 +883,11 @@ wsi_signal_fence_for_image(struct vk_device *device,
    vk_fence_reset_temporary(device, fence);
 
 #ifndef _WIN32
-   VkResult result = wsi_create_sync_for_dma_buf_wait(chain, image,
-                                                      VK_SYNC_FEATURE_CPU_WAIT,
-                                                      &fence->temporary);
-   if (result != VK_ERROR_FEATURE_NOT_PRESENT)
-      return result;
+   if (chain->wsi->has_dma_buf_explicit_sync) {
+      return wsi_create_sync_for_dma_buf_wait(chain, image,
+                                              VK_SYNC_FEATURE_CPU_WAIT,
+                                              &fence->temporary);
+   }
 #endif
 
    if (chain->wsi->signal_fence_with_memory) {
@@ -1070,34 +1059,35 @@ wsi_common_queue_present(const struct wsi_device *wsi,
 
       VkFence fence = swapchain->fences[image_index];
 
-      bool has_signal_dma_buf = true;
       struct wsi_memory_signal_submit_info mem_signal;
-      result = wsi_prepare_signal_dma_buf_from_semaphore(swapchain, image);
-      if (result == VK_SUCCESS) {
-         assert(submit_info.signalSemaphoreCount == 0);
-         submit_info.signalSemaphoreCount = 1;
-         submit_info.pSignalSemaphores = &swapchain->dma_buf_semaphore;
-         has_signal_dma_buf = true;
-      } else if (result == VK_ERROR_FEATURE_NOT_PRESENT) {
+      if (!wsi->has_dma_buf_explicit_sync) {
          /* If we don't have dma-buf signaling, signal the memory object by
           * chaining wsi_memory_signal_submit_info into VkSubmitInfo.
           */
          result = VK_SUCCESS;
-         has_signal_dma_buf = false;
          mem_signal = (struct wsi_memory_signal_submit_info) {
             .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_SIGNAL_SUBMIT_INFO_MESA,
             .memory = image->memory,
          };
          __vk_append_struct(&submit_info, &mem_signal);
-      } else {
-         goto fail_present;
       }
+#ifndef _WIN32
+      if (wsi->has_dma_buf_explicit_sync) {
+         result = wsi_prepare_signal_dma_buf_from_semaphore(swapchain);
+         if (result != VK_SUCCESS)
+            goto fail_present;
+
+         assert(submit_info.signalSemaphoreCount == 0);
+         submit_info.signalSemaphoreCount = 1;
+         submit_info.pSignalSemaphores = &swapchain->dma_buf_semaphore;
+      }
+#endif
 
       result = wsi->QueueSubmit(submit_queue, 1, &submit_info, fence);
       if (result != VK_SUCCESS)
          goto fail_present;
 
-      if (has_signal_dma_buf) {
+      if (wsi->has_dma_buf_explicit_sync) {
          result = wsi_signal_dma_buf_from_semaphore(swapchain, image);
          if (result != VK_SUCCESS)
             goto fail_present;
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 7821e0b02004..e54dd4713160 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -102,7 +102,8 @@ struct wsi_device {
 
    VkPhysicalDevicePCIBusInfoPropertiesEXT pci_bus_info;
 
-   VkExternalSemaphoreHandleTypeFlags semaphore_export_handle_types;
+   /* True if we have support for explicit sync with dma-bufs */
+   bool has_dma_buf_explicit_sync;
 
    bool supports_modifiers;
    uint32_t maxImageDimension2D;
@@ -208,6 +209,7 @@ struct wsi_device {
    WSI_CB(GetImageMemoryRequirements);
    WSI_CB(GetImageSubresourceLayout);
    WSI_CB(GetMemoryFdKHR);
+   WSI_CB(GetPhysicalDeviceExternalSemaphoreProperties);
    WSI_CB(GetPhysicalDeviceFormatProperties);
    WSI_CB(GetPhysicalDeviceFormatProperties2KHR);
    WSI_CB(GetPhysicalDeviceImageFormatProperties2);
diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index ed600606912f..23d7798664fc 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -28,6 +28,7 @@
 #include "util/xmlconfig.h"
 #include "vk_device.h"
 #include "vk_format.h"
+#include "vk_log.h"
 #include "vk_physical_device.h"
 #include "vk_util.h"
 #include "drm-uapi/drm_fourcc.h"
@@ -39,6 +40,7 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <sys/stat.h>
 #include <xf86drm.h>
 
 struct dma_buf_export_sync_file_wsi {
@@ -54,26 +56,33 @@ struct dma_buf_import_sync_file_wsi {
 #define DMA_BUF_IOCTL_EXPORT_SYNC_FILE_WSI   _IOWR(DMA_BUF_BASE, 2, struct dma_buf_export_sync_file_wsi)
 #define DMA_BUF_IOCTL_IMPORT_SYNC_FILE_WSI   _IOW(DMA_BUF_BASE, 3, struct dma_buf_import_sync_file_wsi)
 
+static bool
+wsi_dma_buf_has_sync_file_import_export(struct vk_instance *instance)
+{
+   struct stat s;
+   int ret = stat("/sys/kernel", &s);
+   if (ret < 0) {
+      vk_logw(VK_LOG_NO_OBJS(instance),
+              "Unable to find sysfs and detect dma-buf features. "
+              "Falling back to legacy implicit sync handling");
+      return false;
+   }
+
+   ret = stat("/sys/kernel/dmabuf/caps/sync_file_import_export", &s);
+   return ret == 0;
+}
+
 static VkResult
 wsi_dma_buf_export_sync_file(int dma_buf_fd, int *sync_file_fd)
 {
-   /* Don't keep trying an IOCTL that doesn't exist. */
-   static bool no_dma_buf_sync_file = false;
-   if (no_dma_buf_sync_file)
-      return VK_ERROR_FEATURE_NOT_PRESENT;
-
    struct dma_buf_export_sync_file_wsi export = {
       .flags = DMA_BUF_SYNC_RW,
       .fd = -1,
    };
    int ret = drmIoctl(dma_buf_fd, DMA_BUF_IOCTL_EXPORT_SYNC_FILE_WSI, &export);
    if (ret) {
-      if (errno == ENOTTY) {
-         no_dma_buf_sync_file = true;
-         return VK_ERROR_FEATURE_NOT_PRESENT;
-      } else {
-         return VK_ERROR_OUT_OF_HOST_MEMORY;
-      }
+      assert(errno != ENOTTY);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
 
    *sync_file_fd = export.fd;
@@ -84,82 +93,91 @@ wsi_dma_buf_export_sync_file(int dma_buf_fd, int *sync_file_fd)
 static VkResult
 wsi_dma_buf_import_sync_file(int dma_buf_fd, int sync_file_fd)
 {
-   /* Don't keep trying an IOCTL that doesn't exist. */
-   static bool no_dma_buf_sync_file = false;
-   if (no_dma_buf_sync_file)
-      return VK_ERROR_FEATURE_NOT_PRESENT;
-
    struct dma_buf_import_sync_file_wsi import = {
       .flags = DMA_BUF_SYNC_RW,
       .fd = sync_file_fd,
    };
    int ret = drmIoctl(dma_buf_fd, DMA_BUF_IOCTL_IMPORT_SYNC_FILE_WSI, &import);
    if (ret) {
-      if (errno == ENOTTY) {
-         no_dma_buf_sync_file = true;
-         return VK_ERROR_FEATURE_NOT_PRESENT;
-      } else {
-         return VK_ERROR_OUT_OF_HOST_MEMORY;
-      }
+      assert(errno != ENOTTY);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
 
    return VK_SUCCESS;
 }
 
-static VkResult
-prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
-                                      const struct wsi_image *image)
+static const struct vk_sync_type *
+get_sync_file_sync_type(struct vk_physical_device *pdevice,
+                        enum vk_sync_features req_features)
 {
-   VkResult result;
+   for (const struct vk_sync_type *const *t =
+        pdevice->supported_sync_types; *t; t++) {
+      if (req_features & ~(*t)->features)
+         continue;
 
-   if (!(chain->wsi->semaphore_export_handle_types &
-         VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT))
-      return VK_ERROR_FEATURE_NOT_PRESENT;
+      if ((*t)->import_sync_file != NULL)
+         return *t;
+   }
 
-   int sync_file_fd = -1;
-   result = wsi_dma_buf_export_sync_file(image->dma_buf_fd, &sync_file_fd);
-   if (result != VK_SUCCESS)
-      return result;
+   return NULL;
+}
 
-   result = wsi_dma_buf_import_sync_file(image->dma_buf_fd, sync_file_fd);
-   close(sync_file_fd);
-   if (result != VK_SUCCESS)
-      return result;
+static bool
+test_dma_buf_explicit_sync(struct wsi_device *wsi)
+{
+   VK_FROM_HANDLE(vk_physical_device, pdevice, wsi->pdevice);
 
-   /* If we got here, all our checks pass.  Create the actual semaphore */
-   const VkExportSemaphoreCreateInfo export_info = {
-      .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
-      .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
+   if (!wsi_dma_buf_has_sync_file_import_export(pdevice->instance))
+      return false;
+
+   /* Implicit signal requires that we can export a sync_file */
+   const VkPhysicalDeviceExternalSemaphoreInfo esi = {
+      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
+      .handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    };
-   const VkSemaphoreCreateInfo semaphore_info = {
-      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
-      .pNext = &export_info,
+   VkExternalSemaphoreProperties esp = {
+      .sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    };
-   result = chain->wsi->CreateSemaphore(chain->device, &semaphore_info,
-                                        &chain->alloc,
-                                        &chain->dma_buf_semaphore);
-   if (result != VK_SUCCESS)
-      return result;
+   wsi->GetPhysicalDeviceExternalSemaphoreProperties(wsi->pdevice, &esi, &esp);
+   if (!(esp.externalSemaphoreFeatures &
+         VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT))
+      return false;
 
-   return VK_SUCCESS;
+   /* Implicit wait requires that we can create syncs for either a semaphore
+    * or a fence from a sync_file
+    */
+   if (!get_sync_file_sync_type(pdevice, VK_SYNC_FEATURE_GPU_WAIT) ||
+       !get_sync_file_sync_type(pdevice, VK_SYNC_FEATURE_CPU_WAIT))
+      return false;
+
+   return true;
 }
 
 VkResult
-wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
-                                          const struct wsi_image *image)
+wsi_dma_buf_init_wsi(struct wsi_device *wsi)
 {
-   VkResult result;
+   wsi->has_dma_buf_explicit_sync = test_dma_buf_explicit_sync(wsi);
+   return VK_SUCCESS;
+}
 
-   /* We cache result - 1 in the swapchain */
-   if (unlikely(chain->signal_dma_buf_from_semaphore == 0)) {
-      result = prepare_signal_dma_buf_from_semaphore(chain, image);
-      assert(result <= 0);
-      chain->signal_dma_buf_from_semaphore = (int)result - 1;
-   } else {
-      result = (VkResult)(chain->signal_dma_buf_from_semaphore + 1);
-   }
+VkResult
+wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain)
+{
+   if (likely(chain->dma_buf_semaphore != VK_NULL_HANDLE))
+      return VK_SUCCESS;
 
-   return result;
+   /* If we got here, all our checks pass.  Create the actual semaphore */
+   const VkExportSemaphoreCreateInfo export_info = {
+      .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
+      .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
+   };
+   const VkSemaphoreCreateInfo semaphore_info = {
+      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
+      .pNext = &export_info,
+   };
+   return chain->wsi->CreateSemaphore(chain->device, &semaphore_info,
+                                      &chain->alloc,
+                                      &chain->dma_buf_semaphore);
 }
 
 VkResult
@@ -184,22 +202,6 @@ wsi_signal_dma_buf_from_semaphore(const struct wsi_swapchain *chain,
    return result;
 }
 
-static const struct vk_sync_type *
-get_sync_file_sync_type(struct vk_device *device,
-                        enum vk_sync_features req_features)
-{
-   for (const struct vk_sync_type *const *t =
-        device->physical->supported_sync_types; *t; t++) {
-      if (req_features & ~(*t)->features)
-         continue;
-
-      if ((*t)->import_sync_file != NULL)
-         return *t;
-   }
-
-   return NULL;
-}
-
 VkResult
 wsi_create_sync_for_dma_buf_wait(const struct wsi_swapchain *chain,
                                  const struct wsi_image *image,
@@ -209,10 +211,11 @@ wsi_create_sync_for_dma_buf_wait(const struct wsi_swapchain *chain,
    VK_FROM_HANDLE(vk_device, device, chain->device);
    VkResult result;
 
+   assert(req_features == VK_SYNC_FEATURE_GPU_WAIT ||
+          req_features == VK_SYNC_FEATURE_CPU_WAIT);
+
    const struct vk_sync_type *sync_type =
-      get_sync_file_sync_type(device, req_features);
-   if (sync_type == NULL)
-      return VK_ERROR_FEATURE_NOT_PRESENT;
+      get_sync_file_sync_type(device->physical, req_features);
 
    int sync_file_fd = -1;
    result = wsi_dma_buf_export_sync_file(image->dma_buf_fd, &sync_file_fd);
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index e5d6bb5204bb..25cb9bbd8544 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -197,9 +197,10 @@ void
 wsi_destroy_image(const struct wsi_swapchain *chain,
                   struct wsi_image *image);
 
+VkResult wsi_dma_buf_init_wsi(struct wsi_device *wsi);
+
 VkResult
-wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
-                                          const struct wsi_image *image);
+wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain);
 VkResult
 wsi_signal_dma_buf_from_semaphore(const struct wsi_swapchain *chain,
                                   const struct wsi_image *image);
-- 
GitLab

