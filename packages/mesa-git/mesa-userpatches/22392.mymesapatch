From 9b65f19f715b2fc07ff4f9b589b01f4e1174bf32 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 00:51:19 +0100
Subject: [PATCH 1/6] radv: Reserve space in framebuffer emission.

In the execute secondary scenario nothing else does it for us.

Fixes: 203f60ebf2f ("radv: emit framebuffer state from primary if secondary doesn't inherit it")
---
 src/amd/vulkan/radv_cmd_buffer.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f45b4dba05a6..69ef521c3d6c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3402,6 +3402,9 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
                             ? S_028C70_FORMAT_GFX11(V_028C70_COLOR_INVALID)
                             : S_028C70_FORMAT_GFX6(V_028C70_COLOR_INVALID);
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 48 + MAX_RTS * 70);
+
    for (i = 0; i < render->color_att_count; ++i) {
       struct radv_image_view *iview = render->color_att[i].iview;
       if (!iview) {
@@ -3557,6 +3560,8 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       }
    }
 
+   assert(cmd_buffer->cs->cdw <= cdw_max);
+
    cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_FRAMEBUFFER;
 }
 
-- 
GitLab


From 3745667b30af822f4bd16d0ca0d1c6c2dbf67213 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 01:40:10 +0100
Subject: [PATCH 2/6] radv: Reserve space in various streamout functions.

Fixes: b4eb029062a ("radv: implement VK_EXT_transform_feedback")
---
 src/amd/vulkan/radv_cmd_buffer.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 69ef521c3d6c..30f54935c26c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -10789,6 +10789,8 @@ radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer)
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    uint32_t enabled_stream_buffers_mask = 0;
 
+   ASSERTED unsigned cdw_max = radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4);
+
    if (cmd_buffer->state.last_vgt_shader) {
       enabled_stream_buffers_mask = cmd_buffer->state.last_vgt_shader->info.so.enabled_stream_buffers_mask;
    }
@@ -10801,6 +10803,8 @@ radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer)
    radeon_emit(cs, so->hw_enabled_mask & enabled_stream_buffers_mask);
 
    cmd_buffer->state.context_roll_without_scissor_emitted = true;
+
+   assert(cs->cdw <= cdw_max);
 }
 
 static void
@@ -10835,6 +10839,8 @@ radv_flush_vgt_streamout(struct radv_cmd_buffer *cmd_buffer)
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    unsigned reg_strmout_cntl;
 
+   ASSERTED unsigned cdw_max = radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 14);
+
    /* The register is at different places on different ASICs. */
    if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX9) {
       reg_strmout_cntl = R_0300FC_CP_STRMOUT_CNTL;
@@ -10862,6 +10868,8 @@ radv_flush_vgt_streamout(struct radv_cmd_buffer *cmd_buffer)
    radeon_emit(cs, S_0084FC_OFFSET_UPDATE_DONE(1)); /* reference value */
    radeon_emit(cs, S_0084FC_OFFSET_UPDATE_DONE(1)); /* mask */
    radeon_emit(cs, 4);                              /* poll interval */
+
+   assert(cs->cdw <= cdw_max);
 }
 
 VKAPI_ATTR void VKAPI_CALL
@@ -10889,6 +10897,9 @@ radv_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstC
       radv_flush_vgt_streamout(cmd_buffer);
    }
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, MAX_SO_BUFFERS * 10);
+
    u_foreach_bit(i, so->enabled_mask)
    {
       int32_t counter_buffer_idx = i - firstCounterBuffer;
@@ -10953,6 +10964,8 @@ radv_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstC
       }
    }
 
+   assert(cs->cdw <= cdw_max);
+
    radv_set_streamout_enable(cmd_buffer, true);
 }
 
@@ -10970,6 +10983,9 @@ radv_CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCou
    if (!cmd_buffer->device->physical_device->use_ngg_streamout)
       radv_flush_vgt_streamout(cmd_buffer);
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, MAX_SO_BUFFERS * 12);
+
    u_foreach_bit(i, so->enabled_mask)
    {
       int32_t counter_buffer_idx = i - firstCounterBuffer;
@@ -11022,6 +11038,8 @@ radv_CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCou
       }
    }
 
+   assert(cmd_buffer->cs->cdw <= cdw_max);
+
    radv_set_streamout_enable(cmd_buffer, false);
 }
 
-- 
GitLab


From b1e9c10edd2966cfdd8b925fa7896d77e290e1ec Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 02:02:36 +0100
Subject: [PATCH 3/6] radv: Reserve space in conditional rendering functions.

Fixes: e45ba51ea45 ("radv: add support for VK_EXT_conditional_rendering")
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 ++
 src/amd/vulkan/si_cmd_buffer.c   | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 30f54935c26c..4c6282cd3c7d 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -10702,6 +10702,8 @@ radv_CmdBeginConditionalRenderingEXT(
 
       pred_va = radv_buffer_get_va(cmd_buffer->upload.upload_bo) + pred_offset;
 
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 8);
+
       radeon_emit(cs, PKT3(PKT3_COPY_DATA, 4, 0));
       radeon_emit(cs, COPY_DATA_SRC_SEL(COPY_DATA_SRC_MEM) | COPY_DATA_DST_SEL(COPY_DATA_DST_MEM) |
                          COPY_DATA_WR_CONFIRM);
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index b243a54e8ae1..a68a35127f53 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -1571,6 +1571,8 @@ si_emit_set_predication_state(struct radv_cmd_buffer *cmd_buffer, bool draw_visi
 {
    uint32_t op = 0;
 
+   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4);
+
    if (va) {
       assert(pred_op == PREDICATION_OP_BOOL32 || pred_op == PREDICATION_OP_BOOL64);
 
-- 
GitLab


From 1703a15713c357979ff591127c0ad5f98a3180c9 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 02:11:51 +0100
Subject: [PATCH 4/6] radv: Reserve space in si_cs_emit_cache_flush.

Fixes: 4c6f83006d4 ("radv: Synchronization for task shaders.")
---
 src/amd/vulkan/radv_cmd_buffer.c | 14 ++++++--------
 src/amd/vulkan/radv_private.h    |  6 +++---
 src/amd/vulkan/radv_queue.c      |  3 ++-
 src/amd/vulkan/radv_sqtt.c       |  2 +-
 src/amd/vulkan/si_cmd_buffer.c   | 12 +++++++-----
 5 files changed, 19 insertions(+), 18 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 4c6282cd3c7d..c1e9fb457ae2 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -611,8 +611,9 @@ radv_ace_internal_cache_flush(struct radv_cmd_buffer *cmd_buffer)
    const uint32_t flush_bits = cmd_buffer->ace_internal.flush_bits;
    enum rgp_flush_bits sqtt_flush_bits = 0;
 
-   si_cs_emit_cache_flush(ace_cs, cmd_buffer->device->physical_device->rad_info.gfx_level, NULL, 0,
-                          true, flush_bits, &sqtt_flush_bits, 0);
+   si_cs_emit_cache_flush(cmd_buffer->device->ws, ace_cs,
+                          cmd_buffer->device->physical_device->rad_info.gfx_level, NULL, 0, true,
+                          flush_bits, &sqtt_flush_bits, 0);
 
    cmd_buffer->ace_internal.flush_bits = 0;
 }
@@ -740,20 +741,17 @@ radv_cmd_buffer_after_draw(struct radv_cmd_buffer *cmd_buffer, enum radv_cmd_flu
       enum rgp_flush_bits sqtt_flush_bits = 0;
       assert(flags & (RADV_CMD_FLAG_PS_PARTIAL_FLUSH | RADV_CMD_FLAG_CS_PARTIAL_FLUSH));
 
-      ASSERTED const unsigned cdw_max = radeon_check_space(device->ws, cmd_buffer->cs, 4);
-
       /* Force wait for graphics or compute engines to be idle. */
-      si_cs_emit_cache_flush(cmd_buffer->cs, device->physical_device->rad_info.gfx_level,
+      si_cs_emit_cache_flush(device->ws, cmd_buffer->cs,
+                             device->physical_device->rad_info.gfx_level,
                              &cmd_buffer->gfx9_fence_idx, cmd_buffer->gfx9_fence_va,
                              radv_cmd_buffer_uses_mec(cmd_buffer), flags, &sqtt_flush_bits,
                              cmd_buffer->gfx9_eop_bug_va);
 
-      assert(cmd_buffer->cs->cdw <= cdw_max);
-
       if (cmd_buffer->state.graphics_pipeline && (flags & RADV_CMD_FLAG_PS_PARTIAL_FLUSH) &&
           radv_cmdbuf_has_stage(cmd_buffer, MESA_SHADER_TASK)) {
          /* Force wait for compute engines to be idle on the internal cmdbuf. */
-         si_cs_emit_cache_flush(cmd_buffer->ace_internal.cs,
+         si_cs_emit_cache_flush(device->ws, cmd_buffer->ace_internal.cs,
                                 device->physical_device->rad_info.gfx_level, NULL, 0, true,
                                 RADV_CMD_FLAG_CS_PARTIAL_FLUSH, &sqtt_flush_bits, 0);
       }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index fcb1cbf277b3..5bea3ed5b9cf 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1885,9 +1885,9 @@ void si_cs_emit_write_event_eop(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx
 
 void radv_cp_wait_mem(struct radeon_cmdbuf *cs, uint32_t op, uint64_t va, uint32_t ref,
                       uint32_t mask);
-void si_cs_emit_cache_flush(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level,
-                            uint32_t *fence_ptr, uint64_t va, bool is_mec,
-                            enum radv_cmd_flush_bits flush_bits,
+void si_cs_emit_cache_flush(struct radeon_winsys *ws, struct radeon_cmdbuf *cs,
+                            enum amd_gfx_level gfx_level, uint32_t *flush_cnt, uint64_t flush_va,
+                            bool is_mec, enum radv_cmd_flush_bits flush_bits,
                             enum rgp_flush_bits *sqtt_flush_bits, uint64_t gfx9_eop_bug_va);
 void si_emit_cache_flush(struct radv_cmd_buffer *cmd_buffer);
 void si_emit_set_predication_state(struct radv_cmd_buffer *cmd_buffer, bool draw_visible,
diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index 147e5a20fcd8..0823e545a190 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -1127,7 +1127,8 @@ radv_update_preamble_cs(struct radv_queue_state *queue, struct radv_device *devi
                flush_bits |= RADV_CMD_FLAG_PS_PARTIAL_FLUSH;
          }
 
-         si_cs_emit_cache_flush(cs, gfx_level, NULL, 0, is_mec, flush_bits, &sqtt_flush_bits, 0);
+         si_cs_emit_cache_flush(ws, cs, gfx_level, NULL, 0, is_mec, flush_bits, &sqtt_flush_bits,
+                                0);
       }
 
       result = ws->cs_finalize(cs);
diff --git a/src/amd/vulkan/radv_sqtt.c b/src/amd/vulkan/radv_sqtt.c
index 8c9b67ad6567..c4adb9b38e4b 100644
--- a/src/amd/vulkan/radv_sqtt.c
+++ b/src/amd/vulkan/radv_sqtt.c
@@ -78,7 +78,7 @@ radv_emit_wait_for_idle(struct radv_device *device, struct radeon_cmdbuf *cs, in
 {
    enum rgp_flush_bits sqtt_flush_bits = 0;
    si_cs_emit_cache_flush(
-      cs, device->physical_device->rad_info.gfx_level, NULL, 0,
+      device->ws, cs, device->physical_device->rad_info.gfx_level, NULL, 0,
       family == AMD_IP_COMPUTE && device->physical_device->rad_info.gfx_level >= GFX7,
       (family == RADV_QUEUE_COMPUTE
           ? RADV_CMD_FLAG_CS_PARTIAL_FLUSH
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index a68a35127f53..dede9a862b11 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -1324,14 +1324,17 @@ gfx10_cs_emit_cache_flush(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level
 }
 
 void
-si_cs_emit_cache_flush(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level, uint32_t *flush_cnt,
-                       uint64_t flush_va, bool is_mec, enum radv_cmd_flush_bits flush_bits,
+si_cs_emit_cache_flush(struct radeon_winsys *ws, struct radeon_cmdbuf *cs,
+                       enum amd_gfx_level gfx_level, uint32_t *flush_cnt, uint64_t flush_va,
+                       bool is_mec, enum radv_cmd_flush_bits flush_bits,
                        enum rgp_flush_bits *sqtt_flush_bits, uint64_t gfx9_eop_bug_va)
 {
    unsigned cp_coher_cntl = 0;
    uint32_t flush_cb_db =
       flush_bits & (RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_DB);
 
+   radeon_check_space(ws, cs, 128);
+
    if (gfx_level >= GFX10) {
       /* GFX10 cache flush handling is quite different. */
       gfx10_cs_emit_cache_flush(cs, gfx_level, flush_cnt, flush_va, is_mec, flush_bits,
@@ -1536,9 +1539,8 @@ si_emit_cache_flush(struct radv_cmd_buffer *cmd_buffer)
       return;
    }
 
-   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 128);
-
-   si_cs_emit_cache_flush(cmd_buffer->cs, cmd_buffer->device->physical_device->rad_info.gfx_level,
+   si_cs_emit_cache_flush(cmd_buffer->device->ws, cmd_buffer->cs,
+                          cmd_buffer->device->physical_device->rad_info.gfx_level,
                           &cmd_buffer->gfx9_fence_idx, cmd_buffer->gfx9_fence_va,
                           radv_cmd_buffer_uses_mec(cmd_buffer), cmd_buffer->state.flush_bits,
                           &cmd_buffer->state.sqtt_flush_bits, cmd_buffer->gfx9_eop_bug_va);
-- 
GitLab


From fb0029c0d694d200dbb4307bc2f4312a7fdbb356 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Sat, 11 Mar 2023 18:43:45 +0100
Subject: [PATCH 5/6] radv: Reserve space for updating DCC metadata.

Fixes: 9ee67467c9e ("radv: predicate cmask eliminate when using DCC.")
---
 src/amd/vulkan/radv_cmd_buffer.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index c1e9fb457ae2..2888606bd089 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3169,6 +3169,9 @@ radv_update_dcc_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_image *
 
    assert(radv_dcc_enabled(image, range->baseMipLevel));
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4 + count);
+
    radeon_emit(cmd_buffer->cs, PKT3(PKT3_WRITE_DATA, 2 + count, 0));
    radeon_emit(cmd_buffer->cs,
                S_370_DST_SEL(V_370_MEM) | S_370_WR_CONFIRM(1) | S_370_ENGINE_SEL(V_370_PFP));
@@ -3179,6 +3182,8 @@ radv_update_dcc_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_image *
       radeon_emit(cmd_buffer->cs, pred_val);
       radeon_emit(cmd_buffer->cs, pred_val >> 32);
    }
+
+   assert(cmd_buffer->cs->cdw <= cdw_max);
 }
 
 /**
-- 
GitLab


From 9874a115b8d68cc6f09309af2c3e697075381475 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Sat, 1 Apr 2023 00:50:24 +0200
Subject: [PATCH 6/6] radv: Reserve space for fast clear related writes.

Fixes: 9ee67467c9e ("radv: predicate cmask eliminate when using DCC.")
---
 src/amd/vulkan/radv_cmd_buffer.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 2888606bd089..8eae45769ab6 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3140,6 +3140,9 @@ radv_update_fce_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_image *
    uint32_t level_count = radv_get_levelCount(image, range);
    uint32_t count = 2 * level_count;
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4 + count);
+
    radeon_emit(cmd_buffer->cs, PKT3(PKT3_WRITE_DATA, 2 + count, 0));
    radeon_emit(cmd_buffer->cs,
                S_370_DST_SEL(V_370_MEM) | S_370_WR_CONFIRM(1) | S_370_ENGINE_SEL(V_370_PFP));
@@ -3150,6 +3153,8 @@ radv_update_fce_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_image *
       radeon_emit(cmd_buffer->cs, pred_val);
       radeon_emit(cmd_buffer->cs, pred_val >> 32);
    }
+
+   assert(cmd_buffer->cs->cdw <= cdw_max);
 }
 
 /**
@@ -3200,10 +3205,15 @@ radv_update_bound_fast_clear_color(struct radv_cmd_buffer *cmd_buffer, struct ra
        cmd_buffer->state.render.color_att[cb_idx].iview->image != image)
       return;
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4);
+
    radeon_set_context_reg_seq(cs, R_028C8C_CB_COLOR0_CLEAR_WORD0 + cb_idx * 0x3c, 2);
    radeon_emit(cs, color_values[0]);
    radeon_emit(cs, color_values[1]);
 
+   assert(cmd_buffer->cs->cdw <= cdw_max);
+
    cmd_buffer->state.context_roll_without_scissor_emitted = true;
 }
 
@@ -3223,6 +3233,9 @@ radv_set_color_clear_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_im
    if (radv_image_has_clear_value(image)) {
       uint64_t va = radv_image_get_fast_clear_va(image, range->baseMipLevel);
 
+      ASSERTED unsigned cdw_max =
+         radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4 + count);
+
       radeon_emit(cs, PKT3(PKT3_WRITE_DATA, 2 + count, cmd_buffer->state.predicating));
       radeon_emit(cs, S_370_DST_SEL(V_370_MEM) | S_370_WR_CONFIRM(1) | S_370_ENGINE_SEL(V_370_PFP));
       radeon_emit(cs, va);
@@ -3232,6 +3245,8 @@ radv_set_color_clear_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_im
          radeon_emit(cs, color_values[0]);
          radeon_emit(cs, color_values[1]);
       }
+
+      assert(cmd_buffer->cs->cdw <= cdw_max);
    } else {
       /* Some default value we can set in the update. */
       assert(color_values[0] == 0 && color_values[1] == 0);
-- 
GitLab

