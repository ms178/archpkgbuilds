From 39c03a04af4b687621069f01155aafbdabc10e9d Mon Sep 17 00:00:00 2001
From: Lepton Wu <lepton@chromium.org>
Date: Tue, 10 Jan 2023 21:23:58 -0800
Subject: [PATCH] util: Remove ATTRIBUTE_CONST for util_get_cpu_caps

With ATTRIBUTE_CONST, compiler could optimize it and eliminate this function
call and _util_cpu_caps_state will never be initialized.

Fixes: 1b8a43a0baf ("util: Remove util_cpu_detect")

Signed-off-by: Lepton Wu <lepton@chromium.org>
---
 src/util/u_cpu_detect.h | 20 +-------------------
 1 file changed, 1 insertion(+), 19 deletions(-)

diff --git a/src/util/u_cpu_detect.h b/src/util/u_cpu_detect.h
index 0c59a008a6b2..f31fff42b34b 100644
--- a/src/util/u_cpu_detect.h
+++ b/src/util/u_cpu_detect.h
@@ -142,7 +142,7 @@ struct _util_cpu_caps_state_t {
 
 #define U_CPU_INVALID_L3 0xffff
 
-static inline ATTRIBUTE_CONST const struct util_cpu_caps_t *
+static inline const struct util_cpu_caps_t *
 util_get_cpu_caps(void)
 {
    extern void _util_cpu_detect_once(void);
@@ -152,24 +152,6 @@ util_get_cpu_caps(void)
     * load instruction with some extra compiler magic to prevent code
     * re-ordering around it.  The perf impact of doing this check should be
     * negligible in most cases.
-    *
-    * Also, even though it looks like  a bit of a lie, we've declared this
-    * function with ATTRIBUTE_CONST.  The GCC docs say:
-    *
-    *    "Calls to functions whose return value is not affected by changes to
-    *    the observable state of the program and that have no observable
-    *    effects on such state other than to return a value may lend
-    *    themselves to optimizations such as common subexpression elimination.
-    *    Declaring such functions with the const attribute allows GCC to avoid
-    *    emitting some calls in repeated invocations of the function with the
-    *    same argument values."
-    *
-    * The word "observable" is important here.  With the exception of a
-    * llvmpipe debug flag behind an environment variable and a few unit tests,
-    * all of which emulate worse CPUs, this function neither affects nor is
-    * affected by any "observable" state.  It has its own internal state for
-    * sure, but that state is such that it appears to return exactly the same
-    * value with the same internal data every time.
     */
    if (unlikely(!p_atomic_read(&_util_cpu_caps_state.detect_done)))
       call_once(&_util_cpu_caps_state.once_flag, _util_cpu_detect_once);
-- 
GitLab

