From 1e4102e4e71626ad7195f87f16b9352f1d1321af Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 3 Jun 2025 13:05:17 -0400
Subject: [PATCH 01/23] mesa: make _mesa_bufferobj_release_buffer static

---
 src/mesa/main/bufferobj.c | 39 +++++++++++++++++++--------------------
 src/mesa/main/bufferobj.h |  2 --
 2 files changed, 19 insertions(+), 22 deletions(-)

diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index c8280e8de6d1d..54e022b33a087 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -255,6 +255,25 @@ buffer_usage(GLenum target, GLboolean immutable,
    }
 }
 
+static void
+_mesa_bufferobj_release_buffer(struct gl_buffer_object *obj)
+{
+   if (!obj->buffer)
+      return;
+
+   /* Subtract the remaining private references before unreferencing
+    * the buffer. See the header file for explanation.
+    */
+   if (obj->private_refcount) {
+      assert(obj->private_refcount > 0);
+      p_atomic_add(&obj->buffer->reference.count,
+                   -obj->private_refcount);
+      obj->private_refcount = 0;
+   }
+   obj->private_refcount_ctx = NULL;
+
+   pipe_resource_reference(&obj->buffer, NULL);
+}
 
 static ALWAYS_INLINE GLboolean
 bufferobj_data(struct gl_context *ctx,
@@ -1008,26 +1027,6 @@ convert_clear_buffer_data(struct gl_context *ctx,
    }
 }
 
-void
-_mesa_bufferobj_release_buffer(struct gl_buffer_object *obj)
-{
-   if (!obj->buffer)
-      return;
-
-   /* Subtract the remaining private references before unreferencing
-    * the buffer. See the header file for explanation.
-    */
-   if (obj->private_refcount) {
-      assert(obj->private_refcount > 0);
-      p_atomic_add(&obj->buffer->reference.count,
-                   -obj->private_refcount);
-      obj->private_refcount = 0;
-   }
-   obj->private_refcount_ctx = NULL;
-
-   pipe_resource_reference(&obj->buffer, NULL);
-}
-
 /**
  * Delete a buffer object.
  *
diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index f89bf1be25fc2..e67bd4eb9f928 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -104,8 +104,6 @@ GLboolean _mesa_bufferobj_unmap(struct gl_context *ctx, struct gl_buffer_object
 
 struct gl_buffer_object *
 _mesa_bufferobj_alloc(struct gl_context *ctx, GLuint id);
-void
-_mesa_bufferobj_release_buffer(struct gl_buffer_object *obj);
 
 enum pipe_map_flags
 _mesa_access_flags_to_transfer_flags(GLbitfield access, bool wholeBuffer);
-- 
GitLab


From a71a9b7ac4970f4f81fa85495466b4231d2be0c5 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 3 Jun 2025 13:05:51 -0400
Subject: [PATCH 02/23] mesa: add a ctx param to _mesa_bufferobj_release_buffer

---
 src/mesa/main/bufferobj.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 54e022b33a087..b4dd3c7ce7f54 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -256,7 +256,7 @@ buffer_usage(GLenum target, GLboolean immutable,
 }
 
 static void
-_mesa_bufferobj_release_buffer(struct gl_buffer_object *obj)
+_mesa_bufferobj_release_buffer(struct gl_context *ctx, struct gl_buffer_object *obj)
 {
    if (!obj->buffer)
       return;
@@ -331,7 +331,7 @@ bufferobj_data(struct gl_context *ctx,
    obj->Usage = usage;
    obj->StorageFlags = storageFlags;
 
-   _mesa_bufferobj_release_buffer(obj);
+   _mesa_bufferobj_release_buffer(ctx, obj);
 
    unsigned bindings = buffer_target_to_bind_flags(target);
 
@@ -1038,7 +1038,7 @@ _mesa_delete_buffer_object(struct gl_context *ctx,
 {
    assert(bufObj->RefCount == 0);
    _mesa_buffer_unmap_all_mappings(ctx, bufObj);
-   _mesa_bufferobj_release_buffer(bufObj);
+   _mesa_bufferobj_release_buffer(ctx, bufObj);
 
    vbo_delete_minmax_cache(bufObj);
 
-- 
GitLab


From d5a118fe067cc3631c6a638928baae7c4b4b6e1f Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 13:42:20 -0400
Subject: [PATCH 03/23] mesa/st: check for tc on context create

---
 src/mesa/state_tracker/st_context.c | 2 ++
 src/mesa/state_tracker/st_context.h | 1 +
 2 files changed, 3 insertions(+)

diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 7c37f76d32d55..6d9f8753d4bd5 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -67,6 +67,7 @@
 #include "util/u_memory.h"
 #include "util/hash_table.h"
 #include "util/thread_sched.h"
+#include "util/u_threaded_context.h"
 #include "cso_cache/cso_context.h"
 #include "compiler/glsl/glsl_parser_extras.h"
 #include "nir.h"
@@ -466,6 +467,7 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
       cso_flags = 0;
       break;
    }
+   st->is_threaded_context = pipe->draw_vbo == tc_draw_vbo;
 
    st->cso_context = cso_create_context(pipe, cso_flags);
    ctx->cso_context = st->cso_context;
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 0ce4bd2861ccf..a4c926c496ca8 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -212,6 +212,7 @@ struct st_context
 
    bool validate_all_dirty_states;
    bool can_null_texture;
+   bool is_threaded_context;
 
    /* driver supports scissored clears */
    bool can_scissor_clear;
-- 
GitLab


From a1b82831627c0b8f9f319e64803295ccdc112101 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 11:09:11 -0400
Subject: [PATCH 04/23] freedreno: stop using util_set_vertex_buffers

---
 src/gallium/drivers/freedreno/freedreno_blitter.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/gallium/drivers/freedreno/freedreno_blitter.c b/src/gallium/drivers/freedreno/freedreno_blitter.c
index a1e2f3d4f84b0..1aba5ed13a1e7 100644
--- a/src/gallium/drivers/freedreno/freedreno_blitter.c
+++ b/src/gallium/drivers/freedreno/freedreno_blitter.c
@@ -316,8 +316,7 @@ fd_blitter_clear(struct pipe_context *pctx, unsigned buffers,
    pctx->set_viewport_states(pctx, 0, 1, &vp);
 
    pctx->bind_vertex_elements_state(pctx, ctx->solid_vbuf_state.vtx);
-   util_set_vertex_buffers(pctx, 1, false,
-                           &ctx->solid_vbuf_state.vertexbuf.vb[0]);
+   pctx->set_vertex_buffers(pctx, 1, &ctx->solid_vbuf_state.vertexbuf.vb[0]);
    pctx->set_stream_output_targets(pctx, 0, NULL, NULL, 0);
 
    if (pfb->layers > 1)
-- 
GitLab


From 73434d8afbe051ca0aaccbf7fe174975173e87f3 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 11:09:36 -0400
Subject: [PATCH 05/23] r300: stop using util_set_vertex_buffers

---
 src/gallium/drivers/r300/r300_context.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/r300/r300_context.c b/src/gallium/drivers/r300/r300_context.c
index c7257068ca6a7..d87286d426717 100644
--- a/src/gallium/drivers/r300/r300_context.c
+++ b/src/gallium/drivers/r300/r300_context.c
@@ -467,7 +467,8 @@ struct pipe_context* r300_create_context(struct pipe_screen* screen,
         vb.depth0 = 1;
 
         r300->dummy_vb.buffer.resource = screen->resource_create(screen, &vb);
-        util_set_vertex_buffers(&r300->context, 1, false, &r300->dummy_vb);
+        pipe_reference(NULL, &r300->dummy_vb.buffer.resource->reference);
+        r300->context.set_vertex_buffers(&r300->context, 1, &r300->dummy_vb);
     }
 
     {
-- 
GitLab


From a7d1bc999f7b0aad894d3816bcc57eccf2b91ce7 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 11:10:01 -0400
Subject: [PATCH 06/23] r600: stop using util_set_vertex_buffers

---
 src/gallium/drivers/r600/r600_pipe_common.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index 133249a58dae8..4b053d787f0dc 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -200,10 +200,9 @@ void r600_draw_rectangle(struct blitter_context *blitter,
 	vbuffer.buffer.resource = buf;
 	vbuffer.buffer_offset = offset;
 
-	util_set_vertex_buffers(&rctx->b, 1, false, &vbuffer);
+	rctx->b.set_vertex_buffers(&rctx->b, 1, &vbuffer);
 	util_draw_arrays_instanced(&rctx->b, R600_PRIM_RECTANGLE_LIST, 0, 3,
 				   0, num_instances);
-	pipe_resource_reference(&buf, NULL);
 }
 
 static void r600_dma_emit_wait_idle(struct r600_common_context *rctx)
-- 
GitLab


From b6db2c4cdd93d32018b41e227d8370d92ea981ec Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 23 Jul 2025 13:00:56 -0400
Subject: [PATCH 07/23] zink: destroy u_uploaders earlier in context destroy

these might get defer-deleted onto the batch states, so ensure they
don't leak in that way
---
 src/gallium/drivers/zink/zink_context.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 9d0cc4ac7bdec..7876af590df0e 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -160,6 +160,8 @@ zink_context_destroy(struct pipe_context *pctx)
 
    zink_descriptors_deinit_bindless(ctx);
 
+   u_upload_destroy(pctx->stream_uploader);
+   u_upload_destroy(pctx->const_uploader);
    struct zink_batch_state *bs = ctx->batch_states;
    while (bs) {
       struct zink_batch_state *bs_next = bs->next;
@@ -239,8 +241,6 @@ zink_context_destroy(struct pipe_context *pctx)
       struct zink_gfx_output_key *okey = (void*)he->key;
       VKSCR(DestroyPipeline)(screen->dev, okey->pipeline, NULL);
    }
-   u_upload_destroy(pctx->stream_uploader);
-   u_upload_destroy(pctx->const_uploader);
    slab_destroy_child(&ctx->transfer_pool);
    for (unsigned i = 0; i < ARRAY_SIZE(ctx->program_cache); i++)
       _mesa_hash_table_clear(&ctx->program_cache[i], NULL);
-- 
GitLab


From 72abcae24831768268903acf7708259f47d2fad8 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 13:56:50 -0400
Subject: [PATCH 08/23] mesa/st: always upload cbuf0 for tc

---
 src/mesa/state_tracker/st_atom_constbuf.c  | 21 ++++++++++++++++++++-
 src/mesa/state_tracker/st_atom_constbuf.h  |  3 ++-
 src/mesa/state_tracker/st_cb_clear.c       |  8 ++++++--
 src/mesa/state_tracker/st_draw_feedback.c  |  2 +-
 src/mesa/state_tracker/st_draw_hw_select.c |  7 ++++++-
 src/mesa/state_tracker/st_pbo.c            |  8 +++++---
 src/mesa/state_tracker/st_pbo_compute.c    |  6 +++++-
 7 files changed, 45 insertions(+), 10 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index bd4903a51609b..056cfe2572310 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -62,6 +62,24 @@ st_unbind_unused_cb0(struct st_context *st, enum pipe_shader_type shader_type)
    }
 }
 
+void
+st_upload_constant_buffer(struct st_context *st, gl_shader_stage stage, struct pipe_constant_buffer *cb)
+{
+   struct pipe_constant_buffer cbuf = *cb;
+   cbuf.buffer = NULL;
+   struct pipe_context *pipe = st->pipe;
+   const unsigned alignment = MAX2(st->ctx->Const.UniformBufferOffsetAlignment, 64);
+   void *ptr;
+
+   u_upload_alloc(pipe->const_uploader, 0, cbuf.buffer_size,
+      alignment, &cbuf.buffer_offset, &cbuf.buffer, (void**)&ptr);
+   memcpy(ptr, cbuf.user_buffer, cbuf.buffer_size);
+   cbuf.user_buffer = NULL;
+
+   u_upload_unmap(pipe->const_uploader);
+   pipe->set_constant_buffer(pipe, stage, 0, true, &cbuf);
+}
+
 /**
  * Pass the given program parameters to the graphics pipe as a
  * constant buffer.
@@ -119,7 +137,8 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
       cb.buffer_offset = 0;
       cb.buffer_size = paramBytes;
 
-      if (st->prefer_real_buffer_in_constbuf0) {
+      /* this path cannot be used with select/feedback draws */
+      if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context) {
          struct pipe_context *pipe = st->pipe;
          uint32_t *ptr;
 
diff --git a/src/mesa/state_tracker/st_atom_constbuf.h b/src/mesa/state_tracker/st_atom_constbuf.h
index 7fd275c2138b3..3491bd8b6770e 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.h
+++ b/src/mesa/state_tracker/st_atom_constbuf.h
@@ -31,10 +31,11 @@
 
 #include "compiler/shader_enums.h"
 
+struct gl_program;
 struct gl_program_parameter_list;
 struct st_context;
 
-
+void st_upload_constant_buffer(struct st_context *st, gl_shader_stage stage, struct pipe_constant_buffer *cb);
 void st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_stage stage);
 
 
diff --git a/src/mesa/state_tracker/st_cb_clear.c b/src/mesa/state_tracker/st_cb_clear.c
index d6fa72871a3cd..c5f3ba80b1031 100644
--- a/src/mesa/state_tracker/st_cb_clear.c
+++ b/src/mesa/state_tracker/st_cb_clear.c
@@ -51,6 +51,7 @@
 #include "st_nir.h"
 #include "st_program.h"
 #include "st_util.h"
+#include "st_atom_constbuf.h"
 
 #include "pipe/p_context.h"
 #include "pipe/p_shader_tokens.h"
@@ -113,8 +114,11 @@ set_clearcolor_fs(struct st_context *st, union pipe_color_union *color)
       .user_buffer = color->f,
       .buffer_size = 4 * sizeof(float),
    };
-   st->pipe->set_constant_buffer(st->pipe, PIPE_SHADER_FRAGMENT, 0,
-                                false, &cb);
+   if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context) {
+      st_upload_constant_buffer(st, PIPE_SHADER_FRAGMENT, &cb);
+   } else {
+      st->pipe->set_constant_buffer(st->pipe, PIPE_SHADER_FRAGMENT, 0, false, &cb);
+   }
 
    if (!st->clear.fs) {
       st->clear.fs = st_nir_make_clearcolor_shader(st);
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index 63a936ac45b29..322e356d7e5ca 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -181,7 +181,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
     * in gl_program_parameter_list because allow_constbuf0_as_real_buffer
     * is set.
     */
-   if ((st->prefer_real_buffer_in_constbuf0 || st->allow_st_finalize_nir_twice) && params->StateFlags)
+   if ((st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context || st->allow_st_finalize_nir_twice) && params->StateFlags)
       _mesa_load_state_parameters(st->ctx, params);
 
    draw_set_constant_buffer_stride(draw, sizeof(float));
diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index cd37f23329240..5f36f34c85e04 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -27,6 +27,7 @@
 #include "st_context.h"
 #include "st_nir.h"
 #include "st_draw.h"
+#include "st_atom_constbuf.h"
 
 #include "nir.h"
 #include "nir_builtin_builder.h"
@@ -691,7 +692,11 @@ st_draw_hw_select_prepare_common(struct gl_context *ctx)
    cb.buffer_size = sizeof(consts) - (MAX_CLIP_PLANES - num_planes) * 4 * sizeof(float);
 
    struct pipe_context *pipe = st->pipe;
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_GEOMETRY, 0, false, &cb);
+   if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context) {
+      st_upload_constant_buffer(st, PIPE_SHADER_GEOMETRY, &cb);
+   } else {
+      pipe->set_constant_buffer(pipe, PIPE_SHADER_GEOMETRY, 0, false, &cb);
+   }
 
    struct pipe_shader_buffer buffer;
    memset(&buffer, 0, sizeof(buffer));
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index 442534795645e..ee3123519e6fb 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -31,6 +31,7 @@
 #include "state_tracker/st_context.h"
 #include "state_tracker/st_nir.h"
 #include "state_tracker/st_pbo.h"
+#include "state_tracker/st_atom_constbuf.h"
 
 #include "main/context.h"
 #include "pipe/p_context.h"
@@ -260,9 +261,10 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       cb.buffer_offset = 0;
       cb.buffer_size = sizeof(addr->constants);
 
-      pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, 0, false, &cb);
-
-      pipe_resource_reference(&cb.buffer, NULL);
+      if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context)
+         st_upload_constant_buffer(st, PIPE_SHADER_FRAGMENT, &cb);
+      else
+         pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, 0, false, &cb);
    }
 
    /* Rasterizer state */
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 5dc30db358837..ef43b47b403ab 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -29,6 +29,7 @@
 #include "main/pbo.h"
 
 #include "nir/pipe_nir.h"
+#include "state_tracker/st_atom_constbuf.h"
 #include "state_tracker/st_nir.h"
 #include "state_tracker/st_format.h"
 #include "state_tracker/st_pbo.h"
@@ -1003,7 +1004,10 @@ download_texture_compute(struct st_context *st,
    assert(cs);
    struct cso_context *cso = st->cso_context;
 
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, false, &cb);
+   if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context)
+      st_upload_constant_buffer(st, PIPE_SHADER_COMPUTE, &cb);
+   else
+      pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, false, &cb);
 
    cso_save_compute_state(cso, CSO_BIT_COMPUTE_SHADER | CSO_BIT_COMPUTE_SAMPLERS);
    cso_set_compute_shader_handle(cso, cs);
-- 
GitLab


From 37669f3eb04857cb01b76b39baa2971a6a2a6929 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 18 Jul 2025 07:34:20 -0400
Subject: [PATCH 09/23] gallium: add pipe_context::resource_release

---
 src/gallium/auxiliary/driver_noop/noop_pipe.c |  7 ++++
 .../auxiliary/driver_trace/tr_context.c       | 16 +++++++++
 src/gallium/auxiliary/util/u_inlines.h        |  6 ++++
 .../auxiliary/util/u_threaded_context.c       | 28 +++++++++++++++
 .../auxiliary/util/u_threaded_context_calls.h |  1 +
 src/gallium/drivers/asahi/agx_state.c         |  1 +
 src/gallium/drivers/crocus/crocus_state.c     |  1 +
 .../drivers/d3d12/d3d12_context_graphics.cpp  |  1 +
 .../drivers/etnaviv/etnaviv_texture_desc.c    |  1 +
 .../drivers/etnaviv/etnaviv_texture_state.c   |  1 +
 .../drivers/freedreno/freedreno_texture.c     |  1 +
 src/gallium/drivers/i915/i915_state.c         |  1 +
 src/gallium/drivers/iris/iris_state.c         |  1 +
 src/gallium/drivers/lima/lima_state.c         |  1 +
 .../drivers/llvmpipe/lp_state_sampler.c       |  1 +
 .../drivers/nouveau/nv30/nv30_texture.c       |  1 +
 src/gallium/drivers/nouveau/nv50/nv50_state.c |  1 +
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c |  1 +
 src/gallium/drivers/panfrost/pan_cmdstream.c  |  1 +
 src/gallium/drivers/r300/r300_state.c         |  1 +
 src/gallium/drivers/r600/r600_state_common.c  |  1 +
 src/gallium/drivers/radeonsi/si_state.c       |  1 +
 .../drivers/softpipe/sp_state_sampler.c       |  1 +
 src/gallium/drivers/svga/svga_pipe_sampler.c  |  1 +
 src/gallium/drivers/tegra/tegra_context.c     |  1 +
 src/gallium/drivers/v3d/v3dx_state.c          |  1 +
 src/gallium/drivers/vc4/vc4_state.c           |  1 +
 src/gallium/drivers/virgl/virgl_context.c     |  1 +
 src/gallium/drivers/zink/zink_context.c       |  1 +
 src/gallium/include/pipe/p_context.h          |  7 ++++
 src/mesa/main/bufferobj.c                     | 19 ++--------
 src/mesa/main/bufferobj.h                     | 36 -------------------
 src/mesa/main/draw.c                          |  9 +++--
 src/mesa/main/mtypes.h                        | 16 ---------
 src/mesa/state_tracker/st_atom_array.cpp      |  8 ++---
 src/mesa/state_tracker/st_atom_constbuf.c     |  3 +-
 src/mesa/state_tracker/st_draw.c              |  2 +-
 src/mesa/state_tracker/st_draw_feedback.c     |  2 --
 38 files changed, 99 insertions(+), 85 deletions(-)

diff --git a/src/gallium/auxiliary/driver_noop/noop_pipe.c b/src/gallium/auxiliary/driver_noop/noop_pipe.c
index 48ee16215a65b..6a4d65ac9857c 100644
--- a/src/gallium/auxiliary/driver_noop/noop_pipe.c
+++ b/src/gallium/auxiliary/driver_noop/noop_pipe.c
@@ -414,6 +414,12 @@ static bool noop_is_resource_busy(struct pipe_screen *screen,
    return false;
 }
 
+static void
+noop_resource_release(struct pipe_context *ctx, struct pipe_resource *resource)
+{
+   pipe_resource_reference(&resource, NULL);
+}
+
 static struct pipe_context *noop_create_context(struct pipe_screen *screen,
                                                 void *priv, unsigned flags)
 {
@@ -458,6 +464,7 @@ static struct pipe_context *noop_create_context(struct pipe_screen *screen,
    ctx->invalidate_resource = noop_invalidate_resource;
    ctx->set_context_param = noop_set_context_param;
    ctx->set_frontend_noop = noop_set_frontend_noop;
+   ctx->resource_release = noop_resource_release;
    noop_init_state_functions(ctx);
 
    p_atomic_inc(&screen->num_contexts);
diff --git a/src/gallium/auxiliary/driver_trace/tr_context.c b/src/gallium/auxiliary/driver_trace/tr_context.c
index cfee0ddaa0103..4c7c8e7678712 100644
--- a/src/gallium/auxiliary/driver_trace/tr_context.c
+++ b/src/gallium/auxiliary/driver_trace/tr_context.c
@@ -2464,6 +2464,21 @@ trace_context_get_device_reset_status(struct pipe_context *_pipe)
    return status;
 }
 
+static void
+trace_context_resource_release(struct pipe_context *_pipe, struct pipe_resource *resource)
+{
+   struct trace_context *tr_ctx = trace_context(_pipe);
+   struct pipe_context *pipe = tr_ctx->pipe;
+
+   trace_dump_call_begin("pipe_context", "resource_release");
+   trace_dump_arg(ptr, pipe);
+   trace_dump_arg(ptr, resource);
+
+   pipe->resource_release(pipe, resource);
+
+   trace_dump_call_end();
+}
+
 struct pipe_context *
 trace_context_create(struct trace_screen *tr_scr,
                      struct pipe_context *pipe)
@@ -2611,6 +2626,7 @@ trace_context_create(struct trace_screen *tr_scr,
    TR_CTX_INIT(set_global_binding);
    TR_CTX_INIT(set_hw_atomic_buffers);
    TR_CTX_INIT(get_device_reset_status);
+   TR_CTX_INIT(resource_release);
 
 
 #undef TR_CTX_INIT
diff --git a/src/gallium/auxiliary/util/u_inlines.h b/src/gallium/auxiliary/util/u_inlines.h
index 4bb3dbd362c7e..f852c704df8a9 100644
--- a/src/gallium/auxiliary/util/u_inlines.h
+++ b/src/gallium/auxiliary/util/u_inlines.h
@@ -195,6 +195,12 @@ pipe_resource_reference(struct pipe_resource **dst, struct pipe_resource *src)
    *dst = src;
 }
 
+static inline void
+u_default_resource_release(struct pipe_context *pipe, struct pipe_resource *pres)
+{
+   pipe_resource_reference(&pres, NULL);
+}
+
 /**
  * Subtract the given number of references.
  */
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 44fe0ff18ac48..aaa8be8d83d1a 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -1904,6 +1904,33 @@ tc_sampler_view_release(struct pipe_context *_pipe, struct pipe_sampler_view *vi
    p->view = view;
 }
 
+struct tc_resource_release {
+   struct tc_call_base base;
+   struct pipe_resource *resource;
+};
+
+static uint16_t ALWAYS_INLINE
+tc_call_resource_release(struct pipe_context *pipe, void *call)
+{
+   struct tc_resource_release *p = (struct tc_resource_release *)call;
+
+   pipe->resource_release(pipe, p->resource);
+   return call_size(tc_resource_release);
+}
+
+static void
+tc_resource_release(struct pipe_context *_pipe, struct pipe_resource *resource)
+{
+   if (!resource)
+      return;
+
+   struct threaded_context *tc = threaded_context(_pipe);
+   struct tc_resource_release *p =
+      tc_add_call(tc, TC_CALL_resource_release, tc_resource_release);
+
+   p->resource = resource;
+}
+
 struct tc_shader_images {
    struct tc_call_base base;
    uint8_t shader, start, count;
@@ -5572,6 +5599,7 @@ threaded_context_create(struct pipe_context *pipe,
    CTX_INIT(set_global_binding);
    CTX_INIT(get_sample_position);
    CTX_INIT(invalidate_resource);
+   CTX_INIT(resource_release);
    CTX_INIT(get_device_reset_status);
    CTX_INIT(set_device_reset_callback);
    CTX_INIT(dump_debug_state);
diff --git a/src/gallium/auxiliary/util/u_threaded_context_calls.h b/src/gallium/auxiliary/util/u_threaded_context_calls.h
index 8d48dc50f8de4..9e386b5fb5f7b 100644
--- a/src/gallium/auxiliary/util/u_threaded_context_calls.h
+++ b/src/gallium/auxiliary/util/u_threaded_context_calls.h
@@ -78,6 +78,7 @@ CALL(blit)
 CALL(resolve)
 CALL(generate_mipmap)
 CALL(invalidate_resource)
+CALL(resource_release)
 CALL(clear_render_target)
 CALL(clear_depth_stencil)
 CALL(clear_buffer)
diff --git a/src/gallium/drivers/asahi/agx_state.c b/src/gallium/drivers/asahi/agx_state.c
index 4f0b46c526375..5b8f69c85f662 100644
--- a/src/gallium/drivers/asahi/agx_state.c
+++ b/src/gallium/drivers/asahi/agx_state.c
@@ -5588,6 +5588,7 @@ agx_init_state_functions(struct pipe_context *ctx)
    ctx->set_viewport_states = agx_set_viewport_states;
    ctx->sampler_view_destroy = agx_sampler_view_destroy;
    ctx->sampler_view_release = u_default_sampler_view_release;
+   ctx->resource_release = u_default_resource_release;
    ctx->draw_vbo = agx_draw_vbo;
    ctx->launch_grid = agx_launch_grid;
    ctx->set_global_binding = agx_set_global_binding;
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 4bfb9ab4eab51..3a08235af056f 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -9260,6 +9260,7 @@ genX(crocus_init_state)(struct crocus_context *ice)
    ctx->set_viewport_states = crocus_set_viewport_states;
    ctx->sampler_view_destroy = crocus_sampler_view_destroy;
    ctx->sampler_view_release = u_default_sampler_view_release;
+   ctx->resource_release = u_default_resource_release;
    ctx->surface_destroy = crocus_surface_destroy;
    ctx->draw_vbo = crocus_draw_vbo;
    ctx->launch_grid = crocus_launch_grid;
diff --git a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
index ebb16e2f13e9e..1f4a15c9ca0d9 100644
--- a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
@@ -2238,6 +2238,7 @@ d3d12_init_graphics_context_functions(struct d3d12_context *ctx)
    ctx->base.create_sampler_view = d3d12_create_sampler_view;
    ctx->base.sampler_view_destroy = d3d12_destroy_sampler_view;
    ctx->base.sampler_view_release = u_default_sampler_view_release;
+   ctx->base.resource_release = u_default_resource_release;
 
    ctx->base.create_vertex_elements_state = d3d12_create_vertex_elements_state;
    ctx->base.bind_vertex_elements_state = d3d12_bind_vertex_elements_state;
diff --git a/src/gallium/drivers/etnaviv/etnaviv_texture_desc.c b/src/gallium/drivers/etnaviv/etnaviv_texture_desc.c
index 26432ffa7da12..bad85e52992ca 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_texture_desc.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_texture_desc.c
@@ -388,6 +388,7 @@ etna_texture_desc_init(struct pipe_context *pctx)
    ctx->base.create_sampler_view = etna_create_sampler_view_desc;
    ctx->base.sampler_view_destroy = etna_sampler_view_desc_destroy;
    ctx->base.sampler_view_release = u_default_sampler_view_release;
+   ctx->base.resource_release = u_default_resource_release;
    ctx->emit_texture_state = etna_emit_texture_desc;
    ctx->ts_for_sampler_view = etna_ts_for_sampler_view_state;
 }
diff --git a/src/gallium/drivers/etnaviv/etnaviv_texture_state.c b/src/gallium/drivers/etnaviv/etnaviv_texture_state.c
index 90f2b803f33ec..a3dbbd65d6c30 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_texture_state.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_texture_state.c
@@ -617,6 +617,7 @@ etna_texture_state_init(struct pipe_context *pctx)
    ctx->base.create_sampler_view = etna_create_sampler_view_state;
    ctx->base.sampler_view_destroy = etna_sampler_view_state_destroy;
    ctx->base.sampler_view_release = u_default_sampler_view_release;
+   ctx->base.resource_release = u_default_resource_release;
    ctx->ts_for_sampler_view = etna_ts_for_sampler_view_state;
 
    STATIC_ASSERT(VIVS_TE_SAMPLER_LOD_ADDR__LEN == VIVS_NTE_SAMPLER_ADDR_LOD__LEN);
diff --git a/src/gallium/drivers/freedreno/freedreno_texture.c b/src/gallium/drivers/freedreno/freedreno_texture.c
index 9a9075bdcd9b8..6196e31318700 100644
--- a/src/gallium/drivers/freedreno/freedreno_texture.c
+++ b/src/gallium/drivers/freedreno/freedreno_texture.c
@@ -95,6 +95,7 @@ fd_texture_init(struct pipe_context *pctx)
    if (!pctx->sampler_view_destroy)
       pctx->sampler_view_destroy = fd_sampler_view_destroy;
    pctx->sampler_view_release = u_default_sampler_view_release;
+   pctx->resource_release = u_default_resource_release;
 }
 
 /* helper for setting up border-color buffer for a3xx/a4xx: */
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 75e487e84ecd3..56bcb106e3027 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -1109,6 +1109,7 @@ i915_init_state_functions(struct i915_context *i915)
    i915->base.create_sampler_view = i915_create_sampler_view;
    i915->base.sampler_view_destroy = i915_sampler_view_destroy;
    i915->base.sampler_view_release = u_default_sampler_view_release;
+   i915->base.resource_release = u_default_resource_release;
    i915->base.set_viewport_states = i915_set_viewport_states;
    i915->base.set_vertex_buffers = i915_set_vertex_buffers;
 }
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index e5905f8296a3b..4794d997017c1 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -10652,6 +10652,7 @@ genX(init_state)(struct iris_context *ice)
    ctx->set_viewport_states = iris_set_viewport_states;
    ctx->sampler_view_destroy = iris_sampler_view_destroy;
    ctx->sampler_view_release = u_default_sampler_view_release;
+   ctx->resource_release = u_default_resource_release;
    ctx->surface_destroy = iris_surface_destroy;
    ctx->draw_vbo = iris_draw_vbo;
    ctx->launch_grid = iris_launch_grid;
diff --git a/src/gallium/drivers/lima/lima_state.c b/src/gallium/drivers/lima/lima_state.c
index a8e6a35444bc8..fd0e182199cfb 100644
--- a/src/gallium/drivers/lima/lima_state.c
+++ b/src/gallium/drivers/lima/lima_state.c
@@ -441,6 +441,7 @@ lima_state_init(struct lima_context *ctx)
    ctx->base.create_sampler_view = lima_create_sampler_view;
    ctx->base.sampler_view_destroy = lima_sampler_view_destroy;
    ctx->base.sampler_view_release = u_default_sampler_view_release;
+   ctx->base.resource_release = u_default_resource_release;
    ctx->base.set_sampler_views = lima_set_sampler_views;
 
    ctx->base.set_sample_mask = lima_set_sample_mask;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_sampler.c b/src/gallium/drivers/llvmpipe/lp_state_sampler.c
index 78ee298423773..b9a6d6a1a0d7d 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_sampler.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_sampler.c
@@ -622,5 +622,6 @@ llvmpipe_init_sampler_funcs(struct llvmpipe_context *llvmpipe)
    llvmpipe->pipe.set_sampler_views = llvmpipe_set_sampler_views;
    llvmpipe->pipe.sampler_view_destroy = llvmpipe_sampler_view_destroy;
    llvmpipe->pipe.sampler_view_release = u_default_sampler_view_release;
+   llvmpipe->pipe.resource_release = u_default_resource_release;
    llvmpipe->pipe.delete_sampler_state = llvmpipe_delete_sampler_state;
 }
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_texture.c b/src/gallium/drivers/nouveau/nv30/nv30_texture.c
index 8ba749c59831d..f7fbc6d95ac89 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_texture.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_texture.c
@@ -325,4 +325,5 @@ nv30_texture_init(struct pipe_context *pipe)
    pipe->create_sampler_view = nv30_sampler_view_create;
    pipe->sampler_view_destroy = nv30_sampler_view_destroy;
    pipe->sampler_view_release = u_default_sampler_view_release;
+   pipe->resource_release = u_default_resource_release;
 }
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 6e217cc17793f..929a6ad76f6f1 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -1475,6 +1475,7 @@ nv50_init_state_functions(struct nv50_context *nv50)
    pipe->create_sampler_view = nv50_create_sampler_view;
    pipe->sampler_view_destroy = nv50_sampler_view_destroy;
    pipe->sampler_view_release = u_default_sampler_view_release;
+   pipe->resource_release = u_default_resource_release;
    pipe->set_sampler_views = nv50_set_sampler_views;
 
    pipe->create_vs_state = nv50_vp_state_create;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index f63f4f8132721..7224de4a25e58 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -1432,6 +1432,7 @@ nvc0_init_state_functions(struct nvc0_context *nvc0)
    pipe->create_sampler_view = nvc0_create_sampler_view;
    pipe->sampler_view_destroy = nvc0_sampler_view_destroy;
    pipe->sampler_view_release = u_default_sampler_view_release;
+   pipe->resource_release = u_default_resource_release;
    pipe->set_sampler_views = nvc0_set_sampler_views;
 
    pipe->create_vs_state = nvc0_vp_state_create;
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 6f43f995c17f3..76c22c02bedc9 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -4327,6 +4327,7 @@ context_populate_vtbl(struct pipe_context *pipe)
    pipe->create_sampler_view = panfrost_create_sampler_view;
    pipe->sampler_view_destroy = panfrost_sampler_view_destroy;
    pipe->sampler_view_release = u_default_sampler_view_release;
+   pipe->resource_release = u_default_resource_release;
    pipe->create_sampler_state = panfrost_create_sampler_state;
    pipe->create_blend_state = panfrost_create_blend_state;
 
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index c403ed1263461..052e1f1ccce2a 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -2178,6 +2178,7 @@ void r300_init_state_functions(struct r300_context* r300)
     r300->context.create_sampler_view = r300_create_sampler_view;
     r300->context.sampler_view_destroy = r300_sampler_view_destroy;
     r300->context.sampler_view_release = u_default_sampler_view_release;
+    r300->context.resource_release = u_default_resource_release;
 
     r300->context.set_scissor_states = r300_set_scissor_states;
 
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index f926b7c13dac6..9b8664c094cb3 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -3966,6 +3966,7 @@ void r600_init_common_state_functions(struct r600_context *rctx)
 	rctx->b.b.set_sampler_views = r600_set_sampler_views;
 	rctx->b.b.sampler_view_destroy = r600_sampler_view_destroy;
 	rctx->b.b.sampler_view_release = u_default_sampler_view_release;
+	rctx->b.b.resource_release = u_default_resource_release;
 	rctx->b.b.memory_barrier = r600_memory_barrier;
 	rctx->b.b.texture_barrier = r600_texture_barrier;
 	rctx->b.b.set_stream_output_targets = r600_set_streamout_targets;
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 9bbec335e6289..1e18073470992 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4891,6 +4891,7 @@ void si_init_state_compute_functions(struct si_context *sctx)
    sctx->b.create_sampler_view = si_create_sampler_view;
    sctx->b.sampler_view_destroy = si_sampler_view_destroy;
    sctx->b.sampler_view_release = u_default_sampler_view_release;
+   sctx->b.resource_release = u_default_resource_release;
 }
 
 void si_init_state_functions(struct si_context *sctx)
diff --git a/src/gallium/drivers/softpipe/sp_state_sampler.c b/src/gallium/drivers/softpipe/sp_state_sampler.c
index 4dd3db40007a9..6b0035d805438 100644
--- a/src/gallium/drivers/softpipe/sp_state_sampler.c
+++ b/src/gallium/drivers/softpipe/sp_state_sampler.c
@@ -350,4 +350,5 @@ softpipe_init_sampler_funcs(struct pipe_context *pipe)
    pipe->set_sampler_views = softpipe_set_sampler_views;
    pipe->sampler_view_destroy = softpipe_sampler_view_destroy;
    pipe->sampler_view_release = u_default_sampler_view_release;
+   pipe->resource_release = u_default_resource_release;
 }
diff --git a/src/gallium/drivers/svga/svga_pipe_sampler.c b/src/gallium/drivers/svga/svga_pipe_sampler.c
index 5883dcef49817..4eab6630256fb 100644
--- a/src/gallium/drivers/svga/svga_pipe_sampler.c
+++ b/src/gallium/drivers/svga/svga_pipe_sampler.c
@@ -543,4 +543,5 @@ svga_init_sampler_functions(struct svga_context *svga)
    svga->pipe.create_sampler_view = svga_create_sampler_view;
    svga->pipe.sampler_view_destroy = svga_sampler_view_destroy;
    svga->pipe.sampler_view_release = u_default_sampler_view_release;
+   svga->pipe.resource_release = u_default_resource_release;
 }
diff --git a/src/gallium/drivers/tegra/tegra_context.c b/src/gallium/drivers/tegra/tegra_context.c
index a1402db41d598..9598592323b0a 100644
--- a/src/gallium/drivers/tegra/tegra_context.c
+++ b/src/gallium/drivers/tegra/tegra_context.c
@@ -1355,6 +1355,7 @@ tegra_screen_context_create(struct pipe_screen *pscreen, void *priv,
    context->base.create_sampler_view = tegra_create_sampler_view;
    context->base.sampler_view_destroy = tegra_sampler_view_destroy;
    context->base.sampler_view_release = u_default_sampler_view_release;
+   context->base.resource_release = u_default_resource_release;
 
    context->base.create_surface = tegra_create_surface;
    context->base.surface_destroy = tegra_surface_destroy;
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index 1252d0c3c8adf..4cfbfc5f02b9c 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -1465,6 +1465,7 @@ v3dX(state_init)(struct pipe_context *pctx)
         pctx->create_sampler_view = v3d_create_sampler_view;
         pctx->sampler_view_destroy = v3d_sampler_view_destroy;
         pctx->sampler_view_release = u_default_sampler_view_release;
+        pctx->resource_release = u_default_resource_release;
         pctx->set_sampler_views = v3d_set_sampler_views;
 
         pctx->set_shader_buffers = v3d_set_shader_buffers;
diff --git a/src/gallium/drivers/vc4/vc4_state.c b/src/gallium/drivers/vc4/vc4_state.c
index e1354bbd5f604..d4f0d111b34c6 100644
--- a/src/gallium/drivers/vc4/vc4_state.c
+++ b/src/gallium/drivers/vc4/vc4_state.c
@@ -698,5 +698,6 @@ vc4_state_init(struct pipe_context *pctx)
         pctx->create_sampler_view = vc4_create_sampler_view;
         pctx->sampler_view_destroy = vc4_sampler_view_destroy;
         pctx->sampler_view_release = u_default_sampler_view_release;
+        pctx->resource_release = u_default_resource_release;
         pctx->set_sampler_views = vc4_set_sampler_views;
 }
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 5759d6c232063..3ad10020e4633 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -1746,6 +1746,7 @@ struct pipe_context *virgl_context_create(struct pipe_screen *pscreen,
    vctx->base.create_sampler_view = virgl_create_sampler_view;
    vctx->base.sampler_view_destroy = virgl_destroy_sampler_view;
    vctx->base.sampler_view_release = u_default_sampler_view_release;
+   vctx->base.resource_release = u_default_resource_release;
    vctx->base.set_sampler_views = virgl_set_sampler_views;
    vctx->base.texture_barrier = virgl_texture_barrier;
 
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 7876af590df0e..4ef045eae6e71 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -5340,6 +5340,7 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
    ctx->base.set_sampler_views = zink_set_sampler_views;
    ctx->base.sampler_view_destroy = zink_sampler_view_destroy;
    ctx->base.sampler_view_release = u_default_sampler_view_release;
+   ctx->base.resource_release = u_default_resource_release;
    ctx->base.get_sample_position = zink_get_sample_position;
    ctx->base.set_sample_locations = zink_set_sample_locations;
 
diff --git a/src/gallium/include/pipe/p_context.h b/src/gallium/include/pipe/p_context.h
index dbdf55b6fce2c..b2c3e14bfb0d6 100644
--- a/src/gallium/include/pipe/p_context.h
+++ b/src/gallium/include/pipe/p_context.h
@@ -964,6 +964,13 @@ struct pipe_context {
    bool (*resource_commit)(struct pipe_context *, struct pipe_resource *,
                            unsigned level, struct pipe_box *box, bool commit);
 
+   /**
+    * Signal the driver that the frontend has released a resource.
+    *
+    * Following this call, the driver has full ownership of the resource.
+    */
+   void (*resource_release)(struct pipe_context *, struct pipe_resource *);
+
    /**
     * Creates a video codec for a specific video format/profile
     */
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index b4dd3c7ce7f54..50a6413cfabdb 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -258,21 +258,8 @@ buffer_usage(GLenum target, GLboolean immutable,
 static void
 _mesa_bufferobj_release_buffer(struct gl_context *ctx, struct gl_buffer_object *obj)
 {
-   if (!obj->buffer)
-      return;
-
-   /* Subtract the remaining private references before unreferencing
-    * the buffer. See the header file for explanation.
-    */
-   if (obj->private_refcount) {
-      assert(obj->private_refcount > 0);
-      p_atomic_add(&obj->buffer->reference.count,
-                   -obj->private_refcount);
-      obj->private_refcount = 0;
-   }
-   obj->private_refcount_ctx = NULL;
-
-   pipe_resource_reference(&obj->buffer, NULL);
+   pipe_resource_release(ctx->pipe, obj->buffer);
+   obj->buffer = NULL;
 }
 
 static ALWAYS_INLINE GLboolean
@@ -379,8 +366,6 @@ bufferobj_data(struct gl_context *ctx,
          obj->Size = 0;
          return GL_FALSE;
       }
-
-      obj->private_refcount_ctx = ctx;
    }
 
    /* The current buffer may be bound, so we have to revalidate all atoms that
diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index e67bd4eb9f928..01833da8d6f27 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -36,42 +36,6 @@
  * Internal functions
  */
 
-static ALWAYS_INLINE struct pipe_resource *
-_mesa_get_bufferobj_reference(struct gl_context *ctx, struct gl_buffer_object *obj)
-{
-   assert(obj);
-   struct pipe_resource *buffer = obj->buffer;
-
-   /* Only one context is using the fast path. All other contexts must use
-    * the slow path.
-    */
-   if (unlikely(obj->private_refcount_ctx != ctx ||
-                obj->private_refcount <= 0)) {
-      if (buffer) {
-         if (obj->private_refcount_ctx != ctx) {
-            p_atomic_inc(&buffer->reference.count);
-         } else {
-            /* This is the number of atomic increments we will skip. */
-            const unsigned count = 100000000;
-            p_atomic_add(&buffer->reference.count, count);
-
-            /* Remove the reference that we return. */
-            assert(obj->private_refcount == 0);
-            obj->private_refcount = count - 1;
-         }
-      }
-      return buffer;
-   }
-
-   /* Return a buffer reference while decrementing the private refcount.
-    * The buffer must be non-NULL, which is implied by private_refcount_ctx
-    * being non-NULL.
-    */
-   assert(buffer);
-   obj->private_refcount--;
-   return buffer;
-}
-
 void _mesa_bufferobj_subdata(struct gl_context *ctx,
                           GLintptrARB offset,
                           GLsizeiptrARB size,
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 485ae07ecb0a6..e56201dbc82d3 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1627,8 +1627,7 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
    if (index_bo && ctx->Driver.DrawGallium == st_draw_gallium &&
        st->cso_context->draw_vbo == tc_draw_vbo && ctx->DrawID == 0) {
       assert(!st->draw_needs_minmax_index);
-      struct pipe_resource *index_buffer =
-         _mesa_get_bufferobj_reference(ctx, index_bo);
+      struct pipe_resource *index_buffer = index_bo->buffer;
       struct tc_draw_single *draw =
          tc_add_draw_single_call(st->pipe, index_buffer);
       bool primitive_restart = ctx->Array._PrimitiveRestart[index_size_shift];
@@ -1687,7 +1686,7 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
 
       if (ctx->pipe->draw_vbo == tc_draw_vbo) {
          /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = _mesa_get_bufferobj_reference(ctx, index_bo);
+         info.index.resource = index_bo->buffer;
          info.take_index_buffer_ownership = true;
       } else {
          info.index.resource = index_bo->buffer;
@@ -2074,7 +2073,7 @@ _mesa_validated_multidrawelements(struct gl_context *ctx,
    } else {
       if (ctx->pipe->draw_vbo == tc_draw_vbo) {
          /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = _mesa_get_bufferobj_reference(ctx, index_bo);
+         info.index.resource = index_bo->buffer;
          info.take_index_buffer_ownership = true;
       } else {
          info.index.resource = index_bo->buffer;
@@ -2554,7 +2553,7 @@ _mesa_MultiDrawElementsIndirect(GLenum mode, GLenum type,
 
       if (ctx->pipe->draw_vbo == tc_draw_vbo) {
          /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = _mesa_get_bufferobj_reference(ctx, index_bo);
+         info.index.resource = index_bo->buffer;
          info.take_index_buffer_ownership = true;
          /* Increase refcount so be able to use take_index_buffer_ownership with
           * multiple draws.
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 058df583acd7b..bf9762adae48c 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1443,22 +1443,6 @@ struct gl_buffer_object
    gl_buffer_usage UsageHistory; /**< How has this buffer been used so far? */
 
    struct pipe_resource *buffer;
-   struct gl_context *private_refcount_ctx;
-   /* This mechanism allows passing buffer references to the driver without
-    * using atomics to increase the reference count.
-    *
-    * This private refcount can be decremented without atomics but only one
-    * context (ctx above) can use this counter to be thread-safe.
-    *
-    * This number is atomically added to buffer->reference.count at
-    * initialization. If it's never used, the same number is atomically
-    * subtracted from buffer->reference.count before destruction. If this
-    * number is decremented, we can pass that reference to the driver without
-    * touching reference.count. At buffer destruction we only subtract
-    * the number of references we did not return. This can possibly turn
-    * a million atomic increments into 1 add and 1 subtract atomic op.
-    */
-   int private_refcount;
 
    GLbitfield StorageFlags; /**< GL_MAP_PERSISTENT_BIT, etc. */
 
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index c10342ae57ab1..6f3f9c595fd3a 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -149,8 +149,7 @@ setup_arrays(struct gl_context *ctx,
          /* Set the vertex buffer. */
          if (!ALLOW_USER_BUFFERS || binding->BufferObj) {
             assert(binding->BufferObj);
-            struct pipe_resource *buf =
-               _mesa_get_bufferobj_reference(ctx, binding->BufferObj);
+            struct pipe_resource *buf = binding->BufferObj->buffer;
             vbuffer[bufidx].buffer.resource = buf;
             vbuffer[bufidx].is_user_buffer = false;
             vbuffer[bufidx].buffer_offset = binding->Offset +
@@ -215,8 +214,7 @@ setup_arrays(struct gl_context *ctx,
 
       if (binding->BufferObj) {
          /* Set the binding */
-         vbuffer[bufidx].buffer.resource =
-            _mesa_get_bufferobj_reference(ctx, binding->BufferObj);
+         vbuffer[bufidx].buffer.resource = binding->BufferObj->buffer;
          vbuffer[bufidx].is_user_buffer = false;
          vbuffer[bufidx].buffer_offset = _mesa_draw_binding_offset(binding);
       } else {
@@ -704,7 +702,5 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
                                   indexbuf->buffer : NULL,
                                   enabled_arrays);
 
-   for (unsigned i = 0; i < num_vbuffers; i++)
-      pipe_vertex_buffer_unreference(&vbuffer[i]);
    return state;
 }
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 056cfe2572310..ced2940b72c3c 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -302,8 +302,7 @@ st_bind_ubos(struct st_context *st, struct gl_program *prog,
          &st->ctx->UniformBufferBindings[prog->sh.UniformBlocks[i]->Binding];
 
       if (binding->BufferObject) {
-         cb.buffer = _mesa_get_bufferobj_reference(st->ctx,
-                                                   binding->BufferObject);
+         cb.buffer = binding->BufferObject->buffer;
       } else {
          cb.buffer = NULL;
       }
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 6df165c372302..f5614825cdbf2 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -215,7 +215,7 @@ st_indirect_draw_vbo(struct gl_context *ctx,
       if (st->pipe->draw_vbo == tc_draw_vbo &&
           (draw_count == 1 || st->has_multi_draw_indirect)) {
          /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = _mesa_get_bufferobj_reference(ctx, bufobj);
+         info.index.resource = bufobj->buffer;
          info.take_index_buffer_ownership = true;
       } else {
          info.index.resource = bufobj->buffer;
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index 322e356d7e5ca..f94e3b86a2b86 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -456,8 +456,6 @@ st_feedback_draw_vbo(struct gl_context *ctx,
       if (vb_transfer[buf])
          pipe_buffer_unmap(pipe, vb_transfer[buf]);
       draw_set_mapped_vertex_buffer(draw, buf, NULL, 0);
-      if (!vbuffers[buf].is_user_buffer)
-         pipe_resource_reference(&vbuffers[buf].buffer.resource, NULL);
    }
    draw_set_vertex_buffers(draw, 0, NULL);
 
-- 
GitLab


From 9372a7218ebde624add221f3be654dee13dc1ccb Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 5 Jun 2025 10:50:14 -0400
Subject: [PATCH 10/23] index buffer refcount--

---
 src/gallium/auxiliary/indices/u_primconvert.c | 10 +----
 .../auxiliary/util/u_threaded_context.c       | 43 +------------------
 src/gallium/auxiliary/util/u_vbuf.c           | 34 +++------------
 src/gallium/drivers/zink/zink_draw.cpp        |  2 +-
 src/gallium/include/pipe/p_state.h            |  4 +-
 src/mesa/main/draw.c                          | 37 ++--------------
 src/mesa/state_tracker/st_draw.c              | 19 +-------
 7 files changed, 17 insertions(+), 132 deletions(-)

diff --git a/src/gallium/auxiliary/indices/u_primconvert.c b/src/gallium/auxiliary/indices/u_primconvert.c
index 876e35631e14f..8b476b8bb3914 100644
--- a/src/gallium/auxiliary/indices/u_primconvert.c
+++ b/src/gallium/auxiliary/indices/u_primconvert.c
@@ -294,7 +294,7 @@ util_primconvert_draw_single_vbo(struct primconvert_context *pc,
    /* to the translated draw: */
    pc->pipe->draw_vbo(pc->pipe, &new_info, drawid_offset, NULL, &new_draw, 1);
 
-   pipe_resource_reference(&new_info.index.resource, NULL);
+   pc->pipe->resource_release(pc->pipe, new_info.index.resource);
 }
 
 void
@@ -312,7 +312,7 @@ util_primconvert_draw_vbo(struct primconvert_context *pc,
       unsigned draw_count = 0;
       struct u_indirect_params *new_draws = util_draw_indirect_read(pc->pipe, info, indirect, &draw_count);
       if (!new_draws)
-         goto cleanup;
+         return;
 
       for (unsigned i = 0; i < draw_count; i++)
          util_primconvert_draw_single_vbo(pc, &new_draws[i].info, drawid_offset + i, &new_draws[i].draw);
@@ -326,12 +326,6 @@ util_primconvert_draw_vbo(struct primconvert_context *pc,
             drawid++;
       }
    }
-
-cleanup:
-   if (info->take_index_buffer_ownership) {
-      struct pipe_resource *buffer = info->index.resource;
-      pipe_resource_reference(&buffer, NULL);
-   }
 }
 
 void
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index aaa8be8d83d1a..45118e11628a8 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -3672,11 +3672,8 @@ tc_call_draw_single_drawid(struct pipe_context *pipe, void *call)
 
    info->info.index_bounds_valid = false;
    info->info.has_user_indices = false;
-   info->info.take_index_buffer_ownership = false;
 
    pipe->draw_vbo(pipe, &info->info, info_drawid->drawid_offset, NULL, &draw, 1);
-   if (info->info.index_size)
-      tc_drop_resource_reference(info->info.index.resource);
 
    return call_size(tc_draw_single_drawid);
 }
@@ -3689,7 +3686,6 @@ simplify_draw_info(struct pipe_draw_info *info)
     */
    info->has_user_indices = false;
    info->index_bounds_valid = false;
-   info->take_index_buffer_ownership = false;
    info->index_bias_varies = false;
    info->_pad = 0;
 
@@ -3761,10 +3757,6 @@ tc_call_draw_single(struct pipe_context *pipe, void *call)
          first->info.index_bias_varies = index_bias_varies;
          pipe->draw_vbo(pipe, &first->info, 0, NULL, multi, num_draws);
 
-         /* Since all draws use the same index buffer, drop all references at once. */
-         if (first->info.index_size)
-            pipe_drop_resource_references(first->info.index.resource, num_draws);
-
          return call_size(tc_draw_single) * num_draws;
       }
    }
@@ -3779,11 +3771,8 @@ tc_call_draw_single(struct pipe_context *pipe, void *call)
 
    first->info.index_bounds_valid = false;
    first->info.has_user_indices = false;
-   first->info.take_index_buffer_ownership = false;
 
    pipe->draw_vbo(pipe, &first->info, 0, NULL, &draw, 1);
-   if (first->info.index_size)
-      tc_drop_resource_reference(first->info.index.resource);
 
    return call_size(tc_draw_single);
 }
@@ -3801,11 +3790,8 @@ tc_call_draw_indirect(struct pipe_context *pipe, void *call)
    struct tc_draw_indirect *info = to_call(call, tc_draw_indirect);
 
    info->info.index_bounds_valid = false;
-   info->info.take_index_buffer_ownership = false;
 
    pipe->draw_vbo(pipe, &info->info, 0, &info->indirect, &info->draw, 1);
-   if (info->info.index_size)
-      tc_drop_resource_reference(info->info.index.resource);
 
    tc_drop_resource_reference(info->indirect.buffer);
    tc_drop_resource_reference(info->indirect.indirect_draw_count);
@@ -3827,11 +3813,8 @@ tc_call_draw_multi(struct pipe_context *pipe, void *call)
 
    info->info.has_user_indices = false;
    info->info.index_bounds_valid = false;
-   info->info.take_index_buffer_ownership = false;
 
    pipe->draw_vbo(pipe, &info->info, 0, NULL, info->slot, info->num_draws);
-   if (info->info.index_size)
-      tc_drop_resource_reference(info->info.index.resource);
 
    return info->base.num_slots;
 }
@@ -3852,10 +3835,6 @@ tc_draw_single(struct pipe_context *_pipe, const struct pipe_draw_info *info,
       tc_add_call(tc, TC_CALL_draw_single, tc_draw_single);
 
    if (info->index_size) {
-      if (!info->take_index_buffer_ownership) {
-         tc_set_resource_reference(&p->info.index.resource,
-                                   info->index.resource);
-      }
       tc_add_to_buffer_list(&tc->buffer_lists[tc->next_buf_list], info->index.resource);
    }
    memcpy(&p->info, info, DRAW_INFO_SIZE_WITHOUT_MIN_MAX_INDEX);
@@ -3880,10 +3859,6 @@ tc_draw_single_draw_id(struct pipe_context *_pipe,
       &tc_add_call(tc, TC_CALL_draw_single_drawid, tc_draw_single_drawid)->base;
 
    if (info->index_size) {
-      if (!info->take_index_buffer_ownership) {
-         tc_set_resource_reference(&p->info.index.resource,
-                                   info->index.resource);
-      }
       tc_add_to_buffer_list(&tc->buffer_lists[tc->next_buf_list], info->index.resource);
    }
    ((struct tc_draw_single_drawid*)p)->drawid_offset = drawid_offset;
@@ -3990,7 +3965,6 @@ tc_draw_multi(struct pipe_context *_pipe, const struct pipe_draw_info *info,
 {
    struct threaded_context *tc = threaded_context(_pipe);
    int total_offset = 0;
-   bool take_index_buffer_ownership = info->take_index_buffer_ownership;
 
    while (num_draws) {
       struct tc_batch *next = &tc->batch_slots[tc->next];
@@ -4010,13 +3984,8 @@ tc_draw_multi(struct pipe_context *_pipe, const struct pipe_draw_info *info,
          tc_add_slot_based_call(tc, TC_CALL_draw_multi, tc_draw_multi,
                                 dr);
       if (info->index_size) {
-         if (!take_index_buffer_ownership) {
-            tc_set_resource_reference(&p->info.index.resource,
-                                      info->index.resource);
-         }
          tc_add_to_buffer_list(&tc->buffer_lists[tc->next_buf_list], info->index.resource);
       }
-      take_index_buffer_ownership = false;
       memcpy(&p->info, info, DRAW_INFO_SIZE_WITHOUT_MIN_MAX_INDEX);
       p->num_draws = dr;
       memcpy(p->slot, &draws[total_offset], sizeof(draws[0]) * dr);
@@ -4079,12 +4048,7 @@ tc_draw_user_indices_multi(struct pipe_context *_pipe,
                                 dr);
       memcpy(&p->info, info, DRAW_INFO_SIZE_WITHOUT_INDEXBUF_AND_MIN_MAX_INDEX);
 
-      if (total_offset == 0)
-         /* the first slot inherits the reference from u_upload_alloc() */
-         p->info.index.resource = buffer;
-      else
-         /* all following slots need a new reference */
-         tc_set_resource_reference(&p->info.index.resource, buffer);
+      p->info.index.resource = buffer;
 
       p->num_draws = dr;
 
@@ -4112,6 +4076,7 @@ tc_draw_user_indices_multi(struct pipe_context *_pipe,
       total_offset += dr;
       num_draws -= dr;
    }
+   pipe_resource_release(_pipe, buffer);
 }
 
 static void
@@ -4130,10 +4095,6 @@ tc_draw_indirect(struct pipe_context *_pipe, const struct pipe_draw_info *info,
    struct tc_buffer_list *next = &tc->buffer_lists[tc->next_buf_list];
 
    if (info->index_size) {
-      if (!info->take_index_buffer_ownership) {
-         tc_set_resource_reference(&p->info.index.resource,
-                                   info->index.resource);
-      }
       tc_add_to_buffer_list(next, info->index.resource);
    }
    memcpy(&p->info, info, DRAW_INFO_SIZE_WITHOUT_MIN_MAX_INDEX);
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 8aaf38600ff0c..e6fe094687a95 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -1417,12 +1417,6 @@ u_vbuf_split_indexed_multidraw(struct u_vbuf *mgr, struct pipe_draw_info *info,
                                unsigned *indirect_data, unsigned stride,
                                unsigned draw_count)
 {
-   /* Increase refcount to be able to use take_index_buffer_ownership with
-    * all draws.
-    */
-   if (draw_count > 1 && info->take_index_buffer_ownership)
-      p_atomic_add(&info->index.resource->reference.count, draw_count - 1);
-
    assert(info->index_size);
 
    for (unsigned i = 0; i < draw_count; i++) {
@@ -1483,12 +1477,6 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
       return;
    }
 
-   /* Increase refcount to be able to use take_index_buffer_ownership with
-    * all draws.
-    */
-   if (num_draws > 1 && info->take_index_buffer_ownership)
-      p_atomic_add(&info->index.resource->reference.count, num_draws - 1);
-
    for (unsigned d = 0; d < num_draws; d++) {
       struct pipe_draw_info new_info = *info;
       struct pipe_draw_start_count_bias new_draw = draws[d];
@@ -1510,13 +1498,13 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
          }
 
          if (!draw_count)
-            goto cleanup;
+            return;
 
          unsigned data_size = (draw_count - 1) * indirect->stride +
                               (new_info.index_size ? 20 : 16);
          unsigned *data = malloc(data_size);
          if (!data)
-            goto cleanup; /* report an error? */
+            return; /* report an error? */
 
          /* Read the used buffer range only once, because the read can be
           * uncached.
@@ -1616,7 +1604,7 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
             new_info.instance_count = end_instance - new_info.start_instance;
 
             if (new_info.start_instance == ~0u || !new_info.instance_count)
-               goto cleanup;
+               return;
          } else {
             /* Non-indexed multidraw.
              *
@@ -1653,11 +1641,11 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
             new_info.instance_count = end_instance - new_info.start_instance;
 
             if (new_draw.start == ~0u || !new_draw.count || !new_info.instance_count)
-               goto cleanup;
+               return;
          }
       } else {
          if ((!indirect && !new_draw.count) || !new_info.instance_count)
-            goto cleanup;
+            return;
       }
 
       if (new_info.index_size) {
@@ -1710,12 +1698,10 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
                                      start_vertex, num_vertices,
                                      min_index, unroll_indices, misaligned)) {
             debug_warn_once("u_vbuf_translate_begin() failed");
-            goto cleanup;
+            return;
          }
 
          if (unroll_indices) {
-            if (!new_info.has_user_indices && info->take_index_buffer_ownership)
-               pipe_drop_resource_references(new_info.index.resource, 1);
             new_info.index_size = 0;
             new_draw.index_bias = 0;
             new_info.index_bounds_valid = true;
@@ -1735,7 +1721,7 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
                                    new_info.start_instance,
                                    new_info.instance_count) != PIPE_OK) {
             debug_warn_once("u_vbuf_upload_buffers() failed");
-            goto cleanup;
+            return;
          }
 
          mgr->vertex_buffers_dirty = true;
@@ -1783,12 +1769,6 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
       u_vbuf_translate_end(mgr);
    }
    return;
-
-cleanup:
-   if (info->take_index_buffer_ownership) {
-      struct pipe_resource *indexbuf = info->index.resource;
-      pipe_resource_reference(&indexbuf, NULL);
-   }
 }
 
 void u_vbuf_save_vertex_elements(struct u_vbuf *mgr)
diff --git a/src/gallium/drivers/zink/zink_draw.cpp b/src/gallium/drivers/zink/zink_draw.cpp
index 21e4509feae99..4a4289dd15c7b 100644
--- a/src/gallium/drivers/zink/zink_draw.cpp
+++ b/src/gallium/drivers/zink/zink_draw.cpp
@@ -387,7 +387,7 @@ zink_draw(struct pipe_context *pctx,
             zink_batch_reference_resource(ctx, zink_resource(index_buffer));
       } else {
          index_buffer = dinfo->index.resource;
-         zink_batch_reference_resource_rw(ctx, zink_resource(index_buffer), false);
+         zink_batch_resource_usage_set(ctx->bs, zink_resource(index_buffer), false, true);
       }
       assert(index_size <= 4 && index_size != 3);
       assert(index_size != 1 || screen->info.have_EXT_index_type_uint8);
diff --git a/src/gallium/include/pipe/p_state.h b/src/gallium/include/pipe/p_state.h
index ec329738e4c8a..82d2bd4d33be4 100644
--- a/src/gallium/include/pipe/p_state.h
+++ b/src/gallium/include/pipe/p_state.h
@@ -848,11 +848,9 @@ struct pipe_draw_info
    bool index_bounds_valid:1; /**< whether min_index and max_index are valid;
                                    they're always invalid if index_size == 0 */
    bool increment_draw_id:1;  /**< whether drawid increments for direct draws */
-   bool take_index_buffer_ownership:1; /**< callee inherits caller's refcount
-         (no need to reference indexbuf, but still needs to unreference it) */
    bool index_bias_varies:1;   /**< true if index_bias varies between draws */
    bool was_line_loop:1; /**< true if mesa_prim was LINE_LOOP before translation */
-   uint8_t _pad:1;
+   uint8_t _pad:2;
 
    unsigned start_instance; /**< first instance id */
    unsigned instance_count; /**< number of instances */
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index e56201dbc82d3..61d6a51bb21cc 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1162,7 +1162,6 @@ _mesa_draw_arrays(struct gl_context *ctx, GLenum mode, GLint start,
    info.index_bounds_valid = true;
    info.increment_draw_id = false;
    info.was_line_loop = false;
-   info.take_index_buffer_ownership = false;
    info.index_bias_varies = false;
    /* Packed section end. */
    info.start_instance = baseInstance;
@@ -1468,7 +1467,6 @@ _mesa_MultiDrawArrays(GLenum mode, const GLint *first,
    info.index_bounds_valid = false;
    info.increment_draw_id = primcount > 1;
    info.was_line_loop = false;
-   info.take_index_buffer_ownership = false;
    info.index_bias_varies = false;
    /* Packed section end. */
    info.start_instance = 0;
@@ -1642,7 +1640,6 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
       draw->info.has_user_indices = false;
       draw->info.index_bounds_valid = false;
       draw->info.increment_draw_id = false;
-      draw->info.take_index_buffer_ownership = false;
       draw->info.index_bias_varies = false;
       draw->info.was_line_loop = false;
       draw->info._pad = 0;
@@ -1671,7 +1668,6 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
    info.index_bounds_valid = index_bounds_valid;
    info.increment_draw_id = false;
    info.was_line_loop = false;
-   info.take_index_buffer_ownership = false;
    info.index_bias_varies = false;
    /* Packed section end. */
    info.start_instance = baseInstance;
@@ -1683,14 +1679,7 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
       draw.start = 0;
    } else {
       draw.start = (uintptr_t)indices >> index_size_shift;
-
-      if (ctx->pipe->draw_vbo == tc_draw_vbo) {
-         /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = index_bo->buffer;
-         info.take_index_buffer_ownership = true;
-      } else {
-         info.index.resource = index_bo->buffer;
-      }
+      info.index.resource = index_bo->buffer;
    }
    draw.index_bias = basevertex;
 
@@ -2061,7 +2050,6 @@ _mesa_validated_multidrawelements(struct gl_context *ctx,
    info.index_bounds_valid = false;
    info.increment_draw_id = primcount > 1;
    info.was_line_loop = false;
-   info.take_index_buffer_ownership = false;
    info.index_bias_varies = !!basevertex;
    /* Packed section end. */
    info.start_instance = 0;
@@ -2071,13 +2059,7 @@ _mesa_validated_multidrawelements(struct gl_context *ctx,
    if (info.has_user_indices) {
       info.index.user = (void*)min_index_ptr;
    } else {
-      if (ctx->pipe->draw_vbo == tc_draw_vbo) {
-         /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = index_bo->buffer;
-         info.take_index_buffer_ownership = true;
-      } else {
-         info.index.resource = index_bo->buffer;
-      }
+      info.index.resource = index_bo->buffer;
 
       /* No index buffer storage allocated - nothing to do. */
       if (!info.index.resource)
@@ -2450,7 +2432,6 @@ _mesa_MultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect,
       info.index_bounds_valid = false;
       info.increment_draw_id = primcount > 1;
       info.was_line_loop = false;
-      info.take_index_buffer_ownership = false;
       info.index_bias_varies = false;
       /* Packed section end. */
 
@@ -2544,25 +2525,13 @@ _mesa_MultiDrawElementsIndirect(GLenum mode, GLenum type,
       info.index_bounds_valid = false;
       info.increment_draw_id = primcount > 1;
       info.was_line_loop = false;
-      info.take_index_buffer_ownership = false;
       info.index_bias_varies = false;
       /* Packed section end. */
       info.restart_index = ctx->Array._RestartIndex[index_size_shift];
 
       struct gl_buffer_object *index_bo = ctx->Array.VAO->IndexBufferObj;
 
-      if (ctx->pipe->draw_vbo == tc_draw_vbo) {
-         /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = index_bo->buffer;
-         info.take_index_buffer_ownership = true;
-         /* Increase refcount so be able to use take_index_buffer_ownership with
-          * multiple draws.
-          */
-         if (primcount > 1 && info.index.resource)
-            p_atomic_add(&info.index.resource->reference.count, primcount - 1);
-      } else {
-         info.index.resource = index_bo->buffer;
-      }
+      info.index.resource = index_bo->buffer;
 
       /* No index buffer storage allocated - nothing to do. */
       if (!info.index.resource)
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index f5614825cdbf2..3c3cdfbd1b5cd 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -143,11 +143,6 @@ st_draw_gallium_multimode(struct gl_context *ctx,
          info->mode = mode[first];
          cso_draw_vbo(cso, info, 0, NULL, &draws[first], i - first);
          first = i;
-
-         /* We can pass the reference only once. st_buffer_object keeps
-          * the reference alive for later draws.
-          */
-         info->take_index_buffer_ownership = false;
       }
    }
 }
@@ -212,14 +207,7 @@ st_indirect_draw_vbo(struct gl_context *ctx,
       /* indices are always in a real VBO */
       assert(bufobj);
 
-      if (st->pipe->draw_vbo == tc_draw_vbo &&
-          (draw_count == 1 || st->has_multi_draw_indirect)) {
-         /* Fast path for u_threaded_context to eliminate atomics. */
-         info.index.resource = bufobj->buffer;
-         info.take_index_buffer_ownership = true;
-      } else {
-         info.index.resource = bufobj->buffer;
-      }
+      info.index.resource = bufobj->buffer;
 
       /* No index buffer storage allocated - nothing to do. */
       if (!info.index.resource)
@@ -438,11 +426,6 @@ st_hw_select_draw_gallium_multimode(struct gl_context *ctx,
             cso_draw_vbo(cso, info, 0, NULL, &draws[first], i - first);
 
          first = i;
-
-         /* We can pass the reference only once. st_buffer_object keeps
-          * the reference alive for later draws.
-          */
-         info->take_index_buffer_ownership = false;
       }
    }
 }
-- 
GitLab


From c19d54d04fb98b8136c5f63e9dd7a6269f99d6cb Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 10:41:22 -0400
Subject: [PATCH 11/23] vbuf

---
 src/gallium/auxiliary/util/u_inlines.h |  7 +++
 src/gallium/auxiliary/util/u_vbuf.c    | 70 ++++++++++++++++----------
 2 files changed, 50 insertions(+), 27 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_inlines.h b/src/gallium/auxiliary/util/u_inlines.h
index f852c704df8a9..199761f2b8737 100644
--- a/src/gallium/auxiliary/util/u_inlines.h
+++ b/src/gallium/auxiliary/util/u_inlines.h
@@ -195,6 +195,13 @@ pipe_resource_reference(struct pipe_resource **dst, struct pipe_resource *src)
    *dst = src;
 }
 
+static inline void
+pipe_resource_release(struct pipe_context *pipe, struct pipe_resource *resource)
+{
+   if (resource)
+      pipe->resource_release(pipe, resource);
+}
+
 static inline void
 u_default_resource_release(struct pipe_context *pipe, struct pipe_resource *pres)
 {
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index e6fe094687a95..7a6bfef220f37 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -174,6 +174,7 @@ struct u_vbuf {
    uint8_t num_vertex_buffers;
    uint8_t num_real_vertex_buffers;
    bool vertex_buffers_dirty;
+   bool take_ownership;
    uint32_t enabled_vb_mask;
 
    uint32_t unaligned_vb_mask[2]; //16/32bit
@@ -438,16 +439,27 @@ void u_vbuf_unset_vertex_elements(struct u_vbuf *mgr)
    mgr->ve = NULL;
 }
 
-void u_vbuf_destroy(struct u_vbuf *mgr)
+static void
+u_vbuf_release_ownership(struct u_vbuf *mgr, unsigned last_count)
 {
-   unsigned i;
+   /* only the fallback vbs have refs */
+   u_foreach_bit(i, mgr->fallback_vbs_mask)
+      pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
 
+   if (mgr->take_ownership) {
+      for (unsigned i = 0; i < last_count; i++) {
+         if (!mgr->real_vertex_buffer[i].is_user_buffer)
+            pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
+      }
+   }
+   mgr->take_ownership = false;
+}
+
+void u_vbuf_destroy(struct u_vbuf *mgr)
+{
    mgr->pipe->set_vertex_buffers(mgr->pipe, 0, NULL);
 
-   for (i = 0; i < PIPE_MAX_ATTRIBS; i++)
-      pipe_vertex_buffer_unreference(&mgr->vertex_buffer[i]);
-   for (i = 0; i < PIPE_MAX_ATTRIBS; i++)
-      pipe_vertex_buffer_unreference(&mgr->real_vertex_buffer[i]);
+   u_vbuf_release_ownership(mgr, mgr->num_vertex_buffers);
 
    if (mgr->pc)
       util_primconvert_destroy(mgr->pc);
@@ -608,7 +620,6 @@ u_vbuf_translate_buffers(struct u_vbuf *mgr, struct translate_key *key,
    mgr->real_vertex_buffer[out_vb].buffer_offset = out_offset;
 
    /* Move the buffer reference. */
-   pipe_vertex_buffer_unreference(&mgr->real_vertex_buffer[out_vb]);
    mgr->real_vertex_buffer[out_vb].buffer.resource = out_buffer;
    mgr->real_vertex_buffer[out_vb].is_user_buffer = false;
 
@@ -627,6 +638,7 @@ u_vbuf_translate_find_free_vb_slots(struct u_vbuf *mgr,
       ~mgr->enabled_vb_mask;
    uint32_t unused_vb_mask_orig;
    bool insufficient_buffers = false;
+   uint32_t prev_mask = mgr->fallback_vbs_mask;
 
    /* No vertex buffers available at all */
    if (!unused_vb_mask)
@@ -648,6 +660,10 @@ u_vbuf_translate_find_free_vb_slots(struct u_vbuf *mgr,
 
          index = ffs(unused_vb_mask) - 1;
          fallback_vbs[type] = index;
+         if (prev_mask & BITFIELD_BIT(index)) {
+            pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[index].buffer.resource);
+            memset(&mgr->real_vertex_buffer[index], 0, sizeof(mgr->real_vertex_buffer[index]));
+         }
          mgr->fallback_vbs_mask |= 1 << index;
          unused_vb_mask &= ~(1 << index);
          /*printf("found slot=%i for type=%i\n", index, type);*/
@@ -660,6 +676,10 @@ u_vbuf_translate_find_free_vb_slots(struct u_vbuf *mgr,
       uint32_t index = ffs(unused_vb_mask_orig) - 1;
       /* When sharing one vertex buffer use per-vertex frequency for everything. */
       fallback_vbs[VB_VERTEX] = index;
+      if (prev_mask & BITFIELD_BIT(index)) {
+         pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[index].buffer.resource);
+         memset(&mgr->real_vertex_buffer[index], 0, sizeof(mgr->real_vertex_buffer[index]));
+      }
       mgr->fallback_vbs_mask = 1 << index;
       mask[VB_VERTEX] = mask[VB_VERTEX] | mask[VB_CONST] | mask[VB_INSTANCE];
       mask[VB_CONST] = 0;
@@ -853,11 +873,12 @@ static void u_vbuf_translate_end(struct u_vbuf *mgr)
    mgr->pipe->bind_vertex_elements_state(mgr->pipe, mgr->ve->driver_cso);
    mgr->using_translate = false;
 
-   /* Unreference the now-unused VBOs. */
+   /* Release the now-unused VBOs. */
    for (i = 0; i < VB_NUM; i++) {
       unsigned vb = mgr->fallback_vbs[i];
       if (vb != ~0u) {
-         pipe_resource_reference(&mgr->real_vertex_buffer[vb].buffer.resource, NULL);
+         pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[vb].buffer.resource);
+         memset(&mgr->real_vertex_buffer[vb], 0, sizeof(mgr->real_vertex_buffer[vb]));
          mgr->fallback_vbs[i] = ~0;
       }
    }
@@ -1008,12 +1029,8 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
       mgr->unaligned_vb_mask[1] = 0;
       mgr->vertex_buffers_dirty = false;
 
-      for (unsigned i = 0; i < last_count; i++) {
-         pipe_vertex_buffer_unreference(&mgr->vertex_buffer[i]);
-         pipe_vertex_buffer_unreference(&mgr->real_vertex_buffer[i]);
-      }
-
       pipe->set_vertex_buffers(pipe, 0, NULL);
+      u_vbuf_release_ownership(mgr, last_count);
       return;
    }
 
@@ -1030,14 +1047,16 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
    uint32_t unaligned_vb_mask[2] = {0};
    unsigned num_identical = 0;
 
+   u_vbuf_release_ownership(mgr, mgr->num_vertex_buffers);
+
    for (i = 0; i < count; i++) {
       const struct pipe_vertex_buffer *vb = &bufs[i];
       struct pipe_vertex_buffer *orig_vb = &mgr->vertex_buffer[i];
       struct pipe_vertex_buffer *real_vb = &mgr->real_vertex_buffer[i];
 
       if (!vb->buffer.resource) {
-         pipe_vertex_buffer_unreference(orig_vb);
-         pipe_vertex_buffer_unreference(real_vb);
+         memset(orig_vb, 0, sizeof(*orig_vb));
+         memset(real_vb, 0, sizeof(*real_vb));
          continue;
       }
 
@@ -1047,19 +1066,14 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
           orig_vb->buffer.resource == vb->buffer.resource)
          num_identical++;
 
-      if (take_ownership) {
-         pipe_vertex_buffer_unreference(orig_vb);
-         memcpy(orig_vb, vb, sizeof(*vb));
-      } else {
-         pipe_vertex_buffer_reference(orig_vb, vb);
-      }
+      *orig_vb = *vb;
 
       enabled_vb_mask |= 1 << i;
 
       if ((!mgr->caps.attrib_4byte_unaligned && vb->buffer_offset % 4 != 0)) {
          incompatible_vb_mask |= 1 << i;
          real_vb->buffer_offset = vb->buffer_offset;
-         pipe_vertex_buffer_unreference(real_vb);
+         memset(real_vb, 0, sizeof(*real_vb));
          real_vb->is_user_buffer = false;
          continue;
       }
@@ -1074,12 +1088,12 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
       if (!mgr->caps.user_vertex_buffers && vb->is_user_buffer) {
          user_vb_mask |= 1 << i;
          real_vb->buffer_offset = vb->buffer_offset;
-         pipe_vertex_buffer_unreference(real_vb);
+         memset(real_vb, 0, sizeof(*real_vb));
          real_vb->is_user_buffer = false;
          continue;
       }
 
-      pipe_vertex_buffer_reference(real_vb, vb);
+      *real_vb = *vb;
    }
 
    unsigned last_count = mgr->num_vertex_buffers;
@@ -1088,8 +1102,10 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
       return;
 
    for (; i < last_count; i++) {
-      pipe_vertex_buffer_unreference(&mgr->vertex_buffer[i]);
-      pipe_vertex_buffer_unreference(&mgr->real_vertex_buffer[i]);
+      if (mgr->fallback_vbs_mask & BITFIELD_BIT(i))
+         pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
+      memset(&mgr->vertex_buffer[i], 0, sizeof(struct pipe_vertex_buffer));
+      memset(&mgr->real_vertex_buffer[i], 0, sizeof(struct pipe_vertex_buffer));
    }
 
    mgr->num_vertex_buffers = count;
-- 
GitLab


From 34b6c50a326360a74032f78307bfeca4fc44d384 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 11:34:59 -0400
Subject: [PATCH 12/23] util_draw_vertex_buffer

---
 src/gallium/auxiliary/postprocess/pp_run.c | 2 +-
 src/gallium/auxiliary/util/u_draw_quad.c   | 5 ++---
 src/gallium/auxiliary/util/u_draw_quad.h   | 2 +-
 src/gallium/auxiliary/util/u_vbuf.c        | 1 -
 src/gallium/auxiliary/util/u_vbuf.h        | 1 -
 src/mesa/state_tracker/st_cb_drawtex.c     | 3 ++-
 6 files changed, 6 insertions(+), 8 deletions(-)

diff --git a/src/gallium/auxiliary/postprocess/pp_run.c b/src/gallium/auxiliary/postprocess/pp_run.c
index 17af3c0598929..4fe9a997b2d6d 100644
--- a/src/gallium/auxiliary/postprocess/pp_run.c
+++ b/src/gallium/auxiliary/postprocess/pp_run.c
@@ -292,7 +292,7 @@ pp_filter_misc_state(struct pp_program *p)
 void
 pp_filter_draw(struct pp_program *p)
 {
-   util_draw_vertex_buffer(p->pipe, p->cso, p->vbuf, 0, false,
+   util_draw_vertex_buffer(p->pipe, p->cso, p->vbuf, 0,
                            MESA_PRIM_QUADS, 4, 2);
 }
 
diff --git a/src/gallium/auxiliary/util/u_draw_quad.c b/src/gallium/auxiliary/util/u_draw_quad.c
index c332548ce0d1c..74a210584172e 100644
--- a/src/gallium/auxiliary/util/u_draw_quad.c
+++ b/src/gallium/auxiliary/util/u_draw_quad.c
@@ -43,7 +43,6 @@ util_draw_vertex_buffer(struct pipe_context *pipe,
                         struct cso_context *cso,
                         struct pipe_resource *vbuf,
                         unsigned offset,
-                        bool vb_take_ownership,
                         enum mesa_prim prim_type,
                         unsigned num_verts,
                         unsigned num_attribs)
@@ -60,10 +59,10 @@ util_draw_vertex_buffer(struct pipe_context *pipe,
    /* note: vertex elements already set by caller */
 
    if (cso) {
-      cso_set_vertex_buffers(cso, 1, vb_take_ownership, &vbuffer);
+      cso_set_vertex_buffers(cso, 1, false, &vbuffer);
       cso_draw_arrays(cso, prim_type, 0, num_verts);
    } else {
-      util_set_vertex_buffers(pipe, 1, vb_take_ownership, &vbuffer);
+      util_set_vertex_buffers(pipe, 1, false, &vbuffer);
       util_draw_arrays(pipe, prim_type, 0, num_verts);
    }
 }
diff --git a/src/gallium/auxiliary/util/u_draw_quad.h b/src/gallium/auxiliary/util/u_draw_quad.h
index af84ef0371c1b..83164d51fb069 100644
--- a/src/gallium/auxiliary/util/u_draw_quad.h
+++ b/src/gallium/auxiliary/util/u_draw_quad.h
@@ -45,7 +45,7 @@ struct cso_velems_state;
 extern void
 util_draw_vertex_buffer(struct pipe_context *pipe, struct cso_context *cso,
                         struct pipe_resource *vbuf, unsigned offset,
-                        bool vb_take_ownership, enum mesa_prim prim_type,
+                        enum mesa_prim prim_type,
                         unsigned num_attribs, unsigned num_verts);
 
 void
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 7a6bfef220f37..7f5b8cae70d7c 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -1012,7 +1012,6 @@ static void u_vbuf_delete_vertex_elements(void *ctx, void *state,
 
 void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
                                unsigned count,
-                               bool take_ownership,
                                const struct pipe_vertex_buffer *bufs)
 {
    if (!count) {
diff --git a/src/gallium/auxiliary/util/u_vbuf.h b/src/gallium/auxiliary/util/u_vbuf.h
index 9809ee90b6d40..a6aeb3b729eb8 100644
--- a/src/gallium/auxiliary/util/u_vbuf.h
+++ b/src/gallium/auxiliary/util/u_vbuf.h
@@ -82,7 +82,6 @@ void u_vbuf_set_vertex_elements(struct u_vbuf *mgr,
 void u_vbuf_unset_vertex_elements(struct u_vbuf *mgr);
 void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
                                unsigned count,
-                               bool take_ownership,
                                const struct pipe_vertex_buffer *bufs);
 void u_vbuf_draw_vbo(struct pipe_context *pipe,
                      const struct pipe_draw_info *info,
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index 5313d3ecc1ad1..2da25cea69d0e 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -294,11 +294,12 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
    }
 
    util_draw_vertex_buffer(pipe, cso, vbuffer,
-                           offset, true,
+                           offset,
                            MESA_PRIM_TRIANGLE_FAN,
                            4,  /* verts */
                            numAttribs); /* attribs/vert */
 
+   pipe_resource_release(pipe, vbuffer);
    /* restore state */
    cso_restore_state(cso, 0);
    ctx->Array.NewVertexElements = true;
-- 
GitLab


From 9c5fb31aa99fdc808badb4f7c956ddcc10e4726b Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 11:54:06 -0400
Subject: [PATCH 13/23] cso context

---
 src/gallium/auxiliary/cso_cache/cso_context.c | 7 +++----
 src/gallium/auxiliary/cso_cache/cso_context.h | 1 -
 src/gallium/auxiliary/hud/hud_context.c       | 9 +++++----
 src/gallium/auxiliary/util/u_draw_quad.c      | 6 +++---
 src/gallium/auxiliary/util/u_vbuf.c           | 9 ---------
 src/gallium/frontends/d3d10umd/Draw.cpp       | 2 +-
 src/gallium/frontends/lavapipe/lvp_execute.c  | 2 +-
 src/mesa/state_tracker/st_atom_array.cpp      | 2 +-
 src/mesa/state_tracker/st_draw.c              | 3 ++-
 src/mesa/state_tracker/st_pbo.c               | 5 +++--
 10 files changed, 19 insertions(+), 27 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index c57bc357ee56c..a24aee37f9350 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1300,18 +1300,17 @@ cso_restore_vertex_elements(struct cso_context_priv *ctx)
 void
 cso_set_vertex_buffers(struct cso_context *cso,
                        unsigned count,
-                       bool take_ownership,
                        const struct pipe_vertex_buffer *buffers)
 {
    struct cso_context_priv *ctx = (struct cso_context_priv *)cso;
    struct u_vbuf *vbuf = ctx->vbuf_current;
 
    if (vbuf) {
-      u_vbuf_set_vertex_buffers(vbuf, count, take_ownership, buffers);
+      u_vbuf_set_vertex_buffers(vbuf, count, buffers);
       return;
    }
 
-   util_set_vertex_buffers(ctx->base.pipe, count, take_ownership, buffers);
+   util_set_vertex_buffers(ctx->base.pipe, count, buffers);
 }
 
 
@@ -1348,7 +1347,7 @@ cso_set_vertex_buffers_and_elements(struct cso_context *cso,
       }
 
       u_vbuf_set_vertex_elements(vbuf, velems);
-      u_vbuf_set_vertex_buffers(vbuf, vb_count, true, vbuffers);
+      u_vbuf_set_vertex_buffers(vbuf, vb_count, vbuffers);
       return;
    }
 
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.h b/src/gallium/auxiliary/cso_cache/cso_context.h
index 24bf4ea11397b..f70ac6a121710 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.h
+++ b/src/gallium/auxiliary/cso_cache/cso_context.h
@@ -98,7 +98,6 @@ cso_set_vertex_elements(struct cso_context *ctx,
 
 void cso_set_vertex_buffers(struct cso_context *ctx,
                             unsigned count,
-                            bool take_ownership,
                             const struct pipe_vertex_buffer *buffers);
 
 void cso_set_stream_outputs(struct cso_context *ctx,
diff --git a/src/gallium/auxiliary/hud/hud_context.c b/src/gallium/auxiliary/hud/hud_context.c
index 49649c5f6a7e0..5111cf256e0dd 100644
--- a/src/gallium/auxiliary/hud/hud_context.c
+++ b/src/gallium/auxiliary/hud/hud_context.c
@@ -113,9 +113,10 @@ hud_draw_colored_prims(struct hud_context *hud, unsigned prim,
                  &vbuffer.buffer_offset, &vbuffer.buffer.resource);
    u_upload_unmap(hud->pipe->stream_uploader);
 
-   cso_set_vertex_buffers(cso, 1, true, &vbuffer);
+   cso_set_vertex_buffers(cso, 1, &vbuffer);
    cso_set_fragment_shader_handle(hud->cso, hud->fs_color);
    cso_draw_arrays(cso, prim, 0, num_vertices);
+   pipe_resource_release(hud->pipe, vbuffer.buffer.resource);
 }
 
 static void
@@ -598,7 +599,7 @@ hud_draw_results(struct hud_context *hud, struct pipe_resource *tex)
 
       pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &hud->constbuf);
 
-      cso_set_vertex_buffers(cso, 1, true, &hud->bg.vbuf);
+      cso_set_vertex_buffers(cso, 1, &hud->bg.vbuf);
       cso_draw_arrays(cso, MESA_PRIM_QUADS, 0, hud->bg.num_vertices);
       hud->bg.vbuf.buffer.resource = NULL;
    } else {
@@ -609,7 +610,7 @@ hud_draw_results(struct hud_context *hud, struct pipe_resource *tex)
    if (hud->text.num_vertices) {
       cso_set_vertex_shader_handle(cso, hud->vs_text);
       cso_set_vertex_elements(cso, &hud->text_velems);
-      cso_set_vertex_buffers(cso, 1, true, &hud->text.vbuf);
+      cso_set_vertex_buffers(cso, 1, &hud->text.vbuf);
       cso_set_fragment_shader_handle(hud->cso, hud->fs_text);
       cso_draw_arrays(cso, MESA_PRIM_QUADS, 0, hud->text.num_vertices);
       cso_set_vertex_elements(cso, &hud->velems);
@@ -636,7 +637,7 @@ hud_draw_results(struct hud_context *hud, struct pipe_resource *tex)
 
    if (hud->whitelines.num_vertices) {
       cso_set_vertex_shader_handle(cso, hud->vs_color);
-      cso_set_vertex_buffers(cso, 1, true, &hud->whitelines.vbuf);
+      cso_set_vertex_buffers(cso, 1, &hud->whitelines.vbuf);
       cso_set_fragment_shader_handle(hud->cso, hud->fs_color);
       cso_draw_arrays(cso, MESA_PRIM_LINES, 0, hud->whitelines.num_vertices);
       hud->whitelines.vbuf.buffer.resource = NULL;
diff --git a/src/gallium/auxiliary/util/u_draw_quad.c b/src/gallium/auxiliary/util/u_draw_quad.c
index 74a210584172e..61142619c09d6 100644
--- a/src/gallium/auxiliary/util/u_draw_quad.c
+++ b/src/gallium/auxiliary/util/u_draw_quad.c
@@ -59,10 +59,10 @@ util_draw_vertex_buffer(struct pipe_context *pipe,
    /* note: vertex elements already set by caller */
 
    if (cso) {
-      cso_set_vertex_buffers(cso, 1, false, &vbuffer);
+      cso_set_vertex_buffers(cso, 1, &vbuffer);
       cso_draw_arrays(cso, prim_type, 0, num_verts);
    } else {
-      util_set_vertex_buffers(pipe, 1, false, &vbuffer);
+      util_set_vertex_buffers(pipe, 1, &vbuffer);
       util_draw_arrays(pipe, prim_type, 0, num_verts);
    }
 }
@@ -86,7 +86,7 @@ util_draw_user_vertex_buffer(struct cso_context *cso, void *buffer,
 
    /* note: vertex elements already set by caller */
 
-   cso_set_vertex_buffers(cso, 1, false, &vbuffer);
+   cso_set_vertex_buffers(cso, 1, &vbuffer);
    cso_draw_arrays(cso, prim_type, 0, num_verts);
 }
 
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 7f5b8cae70d7c..23ab17fbbf393 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -174,7 +174,6 @@ struct u_vbuf {
    uint8_t num_vertex_buffers;
    uint8_t num_real_vertex_buffers;
    bool vertex_buffers_dirty;
-   bool take_ownership;
    uint32_t enabled_vb_mask;
 
    uint32_t unaligned_vb_mask[2]; //16/32bit
@@ -445,14 +444,6 @@ u_vbuf_release_ownership(struct u_vbuf *mgr, unsigned last_count)
    /* only the fallback vbs have refs */
    u_foreach_bit(i, mgr->fallback_vbs_mask)
       pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
-
-   if (mgr->take_ownership) {
-      for (unsigned i = 0; i < last_count; i++) {
-         if (!mgr->real_vertex_buffer[i].is_user_buffer)
-            pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
-      }
-   }
-   mgr->take_ownership = false;
 }
 
 void u_vbuf_destroy(struct u_vbuf *mgr)
diff --git a/src/gallium/frontends/d3d10umd/Draw.cpp b/src/gallium/frontends/d3d10umd/Draw.cpp
index 6f651f8faf88b..3bf231ea48674 100644
--- a/src/gallium/frontends/d3d10umd/Draw.cpp
+++ b/src/gallium/frontends/d3d10umd/Draw.cpp
@@ -105,7 +105,7 @@ ResolveState(Device *pDevice)
    update_velems(pDevice);
 
    if (pDevice->vbuffers_changed) {
-      cso_set_vertex_buffers(pDevice->cso, PIPE_MAX_ATTRIBS, false, pDevice->vertex_buffers);
+      cso_set_vertex_buffers(pDevice->cso, PIPE_MAX_ATTRIBS, pDevice->vertex_buffers);
       pDevice->vbuffers_changed = false;
    }
 }
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 98498ad266c4d..336dca1698986 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -494,7 +494,7 @@ static void emit_state(struct rendering_state *state)
    }
 
    if (state->vb_dirty) {
-      cso_set_vertex_buffers(state->cso, state->num_vb, false, state->vb);
+      cso_set_vertex_buffers(state->cso, state->num_vb, state->vb);
       state->vb_dirty = false;
    }
 
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 6f3f9c595fd3a..d396026936fc3 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -477,7 +477,7 @@ st_update_array_templ(struct st_context *st,
    } else {
       /* Only vertex buffers. */
       if (!FILL_TC_SET_VB)
-         cso_set_vertex_buffers(st->cso_context, num_vbuffers, true, vbuffer);
+         cso_set_vertex_buffers(st->cso_context, num_vbuffers, vbuffer);
 
       /* This can change only when we update vertex elements. */
       assert(st->uses_user_vertex_buffers == uses_user_vertex_buffers);
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 3c3cdfbd1b5cd..a70a2e75b625a 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -368,7 +368,7 @@ st_draw_quad(struct st_context *st,
 
    u_upload_unmap(st->pipe->stream_uploader);
 
-   cso_set_vertex_buffers(st->cso_context, 1, true, &vb);
+   cso_set_vertex_buffers(st->cso_context, 1, &vb);
 
    if (num_instances > 1) {
       cso_draw_arrays_instanced(st->cso_context, MESA_PRIM_TRIANGLE_FAN, 0, 4,
@@ -376,6 +376,7 @@ st_draw_quad(struct st_context *st,
    } else {
       cso_draw_arrays(st->cso_context, MESA_PRIM_TRIANGLE_FAN, 0, 4);
    }
+   pipe_resource_release(st->pipe, vb.buffer.resource);
 
    return true;
 }
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index ee3123519e6fb..e6e27511d7a4e 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -213,8 +213,8 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
    cso_set_tesseval_shader_handle(cso, NULL);
 
    /* Upload vertices */
+   struct pipe_vertex_buffer vbo = {0};
    {
-      struct pipe_vertex_buffer vbo = {0};
       struct cso_velems_state velem;
 
       float x0 = (float) addr->xoffset / surface_width * 2.0f - 1.0f;
@@ -249,7 +249,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       velem.velems[0].dual_slot = false;
 
       cso_set_vertex_elements(cso, &velem);
-      cso_set_vertex_buffers(cso, 1, true, &vbo);
+      cso_set_vertex_buffers(cso, 1, &vbo);
    }
 
    /* Upload constants */
@@ -279,6 +279,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       cso_draw_arrays_instanced(cso, MESA_PRIM_TRIANGLE_STRIP,
                                 0, 4, 0, addr->depth);
    }
+   pipe_resource_release(st->pipe, vbo.buffer.resource);
 
    return true;
 }
-- 
GitLab


From f49a59f6a24934ced5a0982474004b14d3a66b32 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 11:59:57 -0400
Subject: [PATCH 14/23] delete util_set_vertex_buffers

---
 src/gallium/auxiliary/cso_cache/cso_context.c |  2 +-
 src/gallium/auxiliary/util/u_draw_quad.c      |  2 +-
 src/gallium/auxiliary/util/u_inlines.h        | 18 ------------------
 src/gallium/auxiliary/util/u_vbuf.c           |  7 +------
 src/gallium/auxiliary/vl/vl_bicubic_filter.c  |  2 +-
 src/gallium/auxiliary/vl/vl_compositor_gfx.c  |  2 +-
 src/gallium/auxiliary/vl/vl_deint_filter.c    |  2 +-
 src/gallium/auxiliary/vl/vl_matrix_filter.c   |  2 +-
 src/gallium/auxiliary/vl/vl_median_filter.c   |  2 +-
 src/gallium/auxiliary/vl/vl_mpeg12_decoder.c  |  6 +++---
 src/gallium/drivers/radeonsi/si_state.c       | 10 +---------
 src/gallium/drivers/zink/zink_context.c       |  3 +--
 src/gallium/include/pipe/p_context.h          |  5 -----
 13 files changed, 13 insertions(+), 50 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index a24aee37f9350..8ec2d22f9340e 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1310,7 +1310,7 @@ cso_set_vertex_buffers(struct cso_context *cso,
       return;
    }
 
-   util_set_vertex_buffers(ctx->base.pipe, count, buffers);
+   ctx->base.pipe->set_vertex_buffers(ctx->base.pipe, count, buffers);
 }
 
 
diff --git a/src/gallium/auxiliary/util/u_draw_quad.c b/src/gallium/auxiliary/util/u_draw_quad.c
index 61142619c09d6..a91cb36f39e55 100644
--- a/src/gallium/auxiliary/util/u_draw_quad.c
+++ b/src/gallium/auxiliary/util/u_draw_quad.c
@@ -62,7 +62,7 @@ util_draw_vertex_buffer(struct pipe_context *pipe,
       cso_set_vertex_buffers(cso, 1, &vbuffer);
       cso_draw_arrays(cso, prim_type, 0, num_verts);
    } else {
-      util_set_vertex_buffers(pipe, 1, &vbuffer);
+      pipe->set_vertex_buffers(pipe, 1, &vbuffer);
       util_draw_arrays(pipe, prim_type, 0, num_verts);
    }
 }
diff --git a/src/gallium/auxiliary/util/u_inlines.h b/src/gallium/auxiliary/util/u_inlines.h
index 199761f2b8737..24eac806c71f2 100644
--- a/src/gallium/auxiliary/util/u_inlines.h
+++ b/src/gallium/auxiliary/util/u_inlines.h
@@ -977,24 +977,6 @@ static inline unsigned util_res_sample_count(const struct pipe_resource *res)
    return res->nr_samples > 0 ? res->nr_samples : 1;
 }
 
-static inline void
-util_set_vertex_buffers(struct pipe_context *pipe,
-                        unsigned num_buffers, bool take_ownership,
-                        const struct pipe_vertex_buffer *buffers)
-{
-   /* set_vertex_buffers requires that reference counts are incremented
-    * by the caller.
-    */
-   if (!take_ownership) {
-      for (unsigned i = 0; i < num_buffers; i++) {
-         if (!buffers[i].is_user_buffer && buffers[i].buffer.resource)
-            p_atomic_inc(&buffers[i].buffer.resource->reference.count);
-      }
-   }
-
-   pipe->set_vertex_buffers(pipe, num_buffers, buffers);
-}
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 23ab17fbbf393..e7536a5f4362b 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -1399,10 +1399,6 @@ static void u_vbuf_set_driver_vertex_buffers(struct u_vbuf *mgr)
    assert(mgr->vertex_buffers_dirty);
 
    if (mgr->user_vb_mask == BITFIELD_MASK(count)) {
-      /* Fast path that allows us to transfer the VBO references to the driver
-       * to skip atomic reference counting there. These are freshly uploaded
-       * user buffers that can be discarded after this call.
-       */
       pipe->set_vertex_buffers(pipe, count, mgr->real_vertex_buffer);
 
       /* We don't own the VBO references now. Set them to NULL. */
@@ -1411,8 +1407,7 @@ static void u_vbuf_set_driver_vertex_buffers(struct u_vbuf *mgr)
          mgr->real_vertex_buffer[i].buffer.resource = NULL;
       }
    } else {
-      /* Slow path where we have to keep VBO references. */
-      util_set_vertex_buffers(pipe, count, false, mgr->real_vertex_buffer);
+      pipe->set_vertex_buffers(pipe, count, mgr->real_vertex_buffer);
    }
    mgr->vertex_buffers_dirty = false;
 }
diff --git a/src/gallium/auxiliary/vl/vl_bicubic_filter.c b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
index 95fc7621b317e..421d562ecec7b 100644
--- a/src/gallium/auxiliary/vl/vl_bicubic_filter.c
+++ b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
@@ -462,7 +462,7 @@ vl_bicubic_filter_render(struct vl_bicubic_filter *filter,
    filter->pipe->set_framebuffer_state(filter->pipe, &fb_state);
    filter->pipe->set_viewport_states(filter->pipe, 0, 1, &viewport);
    filter->pipe->bind_vertex_elements_state(filter->pipe, filter->ves);
-   util_set_vertex_buffers(filter->pipe, 1, false, &filter->quad);
+   filter->pipe->set_vertex_buffers(filter->pipe, 1, &filter->quad);
 
    util_draw_arrays(filter->pipe, MESA_PRIM_QUADS, 0, 4);
 }
diff --git a/src/gallium/auxiliary/vl/vl_compositor_gfx.c b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
index 688ea3d7ac816..4e2580ab641c6 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_gfx.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
@@ -739,7 +739,7 @@ vl_compositor_gfx_render(struct vl_compositor_state *s,
    c->pipe->set_framebuffer_state(c->pipe, &c->fb_state);
    c->pipe->bind_vs_state(c->pipe, c->vs);
    c->pipe->bind_vertex_elements_state(c->pipe, c->vertex_elems_state);
-   util_set_vertex_buffers(c->pipe, 1, false, &c->vertex_buf);
+   c->pipe->set_vertex_buffers(c->pipe, 1, &c->vertex_buf);
    pipe_set_constant_buffer(c->pipe, PIPE_SHADER_FRAGMENT, 0, s->shader_params);
    c->pipe->bind_rasterizer_state(c->pipe, c->rast);
 
diff --git a/src/gallium/auxiliary/vl/vl_deint_filter.c b/src/gallium/auxiliary/vl/vl_deint_filter.c
index 12b5a3ba8d446..b4dcfb68dc623 100644
--- a/src/gallium/auxiliary/vl/vl_deint_filter.c
+++ b/src/gallium/auxiliary/vl/vl_deint_filter.c
@@ -494,7 +494,7 @@ vl_deint_filter_render(struct vl_deint_filter *filter,
    /* set up pipe state */
    filter->pipe->bind_rasterizer_state(filter->pipe, filter->rs_state);
    filter->pipe->bind_vertex_elements_state(filter->pipe, filter->ves);
-   util_set_vertex_buffers(filter->pipe, 1, false, &filter->quad);
+   filter->pipe->set_vertex_buffers(filter->pipe, 1, &filter->quad);
    filter->pipe->bind_vs_state(filter->pipe, filter->vs);
    filter->pipe->bind_sampler_states(filter->pipe, PIPE_SHADER_FRAGMENT,
                                      0, 4, filter->sampler);
diff --git a/src/gallium/auxiliary/vl/vl_matrix_filter.c b/src/gallium/auxiliary/vl/vl_matrix_filter.c
index 7ca86aa4a40cc..edccc0aa06792 100644
--- a/src/gallium/auxiliary/vl/vl_matrix_filter.c
+++ b/src/gallium/auxiliary/vl/vl_matrix_filter.c
@@ -308,7 +308,7 @@ vl_matrix_filter_render(struct vl_matrix_filter *filter,
    filter->pipe->set_framebuffer_state(filter->pipe, &fb_state);
    filter->pipe->set_viewport_states(filter->pipe, 0, 1, &viewport);
    filter->pipe->bind_vertex_elements_state(filter->pipe, filter->ves);
-   util_set_vertex_buffers(filter->pipe, 1, false, &filter->quad);
+   filter->pipe->set_vertex_buffers(filter->pipe, 1, &filter->quad);
 
    util_draw_arrays(filter->pipe, MESA_PRIM_QUADS, 0, 4);
 }
diff --git a/src/gallium/auxiliary/vl/vl_median_filter.c b/src/gallium/auxiliary/vl/vl_median_filter.c
index 3a578726d8cee..65d5a579b28c7 100644
--- a/src/gallium/auxiliary/vl/vl_median_filter.c
+++ b/src/gallium/auxiliary/vl/vl_median_filter.c
@@ -426,7 +426,7 @@ vl_median_filter_render(struct vl_median_filter *filter,
    filter->pipe->set_framebuffer_state(filter->pipe, &fb_state);
    filter->pipe->set_viewport_states(filter->pipe, 0, 1, &viewport);
    filter->pipe->bind_vertex_elements_state(filter->pipe, filter->ves);
-   util_set_vertex_buffers(filter->pipe, 1, false, &filter->quad);
+   filter->pipe->set_vertex_buffers(filter->pipe, 1, &filter->quad);
 
    util_draw_arrays(filter->pipe, MESA_PRIM_QUADS, 0, 4);
 }
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
index 1a0f1f78b50b0..8973d397cd38c 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
@@ -786,7 +786,7 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
          if (!ref_frames[j] || !ref_frames[j][i]) continue;
 
          vb[2] = vl_vb_get_mv(&buf->vertex_stream, j);
-         util_set_vertex_buffers(dec->context, 3, false, vb);
+         dec->context->set_vertex_buffers(dec->context, 3, vb);
 
          vl_mc_render_ref(i ? &dec->mc_c : &dec->mc_y, &buf->mc[i], ref_frames[j][i]);
       }
@@ -797,7 +797,7 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
       if (!buf->num_ycbcr_blocks[i]) continue;
 
       vb[1] = vl_vb_get_ycbcr(&buf->vertex_stream, i);
-      util_set_vertex_buffers(dec->context, 2, false, vb);
+      dec->context->set_vertex_buffers(dec->context, 2, vb);
 
       vl_zscan_render(i ? &dec->zscan_c : & dec->zscan_y, &buf->zscan[i] , buf->num_ycbcr_blocks[i]);
 
@@ -816,7 +816,7 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
          if (!buf->num_ycbcr_blocks[plane]) continue;
 
          vb[1] = vl_vb_get_ycbcr(&buf->vertex_stream, plane);
-         util_set_vertex_buffers(dec->context, 2, false, vb);
+         dec->context->set_vertex_buffers(dec->context, 2, vb);
 
          if (dec->base.entrypoint <= PIPE_VIDEO_ENTRYPOINT_IDCT)
             vl_idct_prepare_stage2(i ? &dec->idct_c : &dec->idct_y, &buf->idct[plane]);
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 1e18073470992..18b6baa83709b 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4698,13 +4698,6 @@ static void si_bind_vertex_elements(struct pipe_context *ctx, void *state)
       cb.buffer_size = 0xffffffff;
       si_set_internal_const_buffer(sctx, SI_VS_CONST_INSTANCE_DIVISORS, &cb);
    }
-
-   /* Unbind all vertex buffers. set_vertex_buffers is required to be called after this.
-    * If it's not called, no buffers will be enabled.
-    */
-   unsigned old_num_vertex_buffers = old->num_vertex_buffers;
-   for (unsigned i = 0; i < old_num_vertex_buffers; i++)
-      pipe_resource_reference(&sctx->vertex_buffer[i].buffer.resource, NULL);
 }
 
 static void si_delete_vertex_element(struct pipe_context *ctx, void *state)
@@ -4738,8 +4731,7 @@ static void si_set_vertex_buffers(struct pipe_context *ctx, unsigned count,
       dst->buffer_offset = src->buffer_offset;
 
       /* Only unreference bound vertex buffers. */
-      pipe_resource_reference(&dst->buffer.resource, NULL);
-      dst->buffer.resource = src->buffer.resource;
+      pipe_resource_reference(&dst->buffer.resource, src->buffer.resource);
 
       if (src->buffer_offset & 3)
          unaligned |= BITFIELD_BIT(i);
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 4ef045eae6e71..bde414dc89336 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -1379,8 +1379,7 @@ zink_set_vertex_buffers_internal(struct pipe_context *pctx,
       const struct pipe_vertex_buffer *vb = buffers + i;
       struct pipe_vertex_buffer *ctx_vb = &ctx->vertex_buffers[i];
       update_existing_vbo(ctx, i);
-      pipe_resource_reference(&ctx_vb->buffer.resource, NULL);
-      ctx_vb->buffer.resource = vb->buffer.resource;
+      pipe_resource_reference(&ctx_vb->buffer.resource, vb->buffer.resource);
 
       if (vb->buffer.resource) {
          struct zink_resource *res = zink_resource(vb->buffer.resource);
diff --git a/src/gallium/include/pipe/p_context.h b/src/gallium/include/pipe/p_context.h
index b2c3e14bfb0d6..c375fbad6c529 100644
--- a/src/gallium/include/pipe/p_context.h
+++ b/src/gallium/include/pipe/p_context.h
@@ -620,11 +620,6 @@ struct pipe_context {
    /**
     * Bind an array of vertex buffers to the specified slots.
     *
-    * Unlike other set functions, the caller should always increment
-    * the buffer reference counts because the driver should only copy
-    * the pipe_resource pointers. This is the same behavior as setting
-    * take_ownership = true in other functions.
-    *
     * count must be equal to the maximum used vertex buffer index + 1
     * in vertex elements or 0.
     *
-- 
GitLab


From d635fef43a9242f503587c2cadac0e071275dc83 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 21 Jul 2025 13:07:44 -0400
Subject: [PATCH 15/23] pp (buffer upload)

---
 src/gallium/auxiliary/postprocess/pp_mlaa.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/src/gallium/auxiliary/postprocess/pp_mlaa.c b/src/gallium/auxiliary/postprocess/pp_mlaa.c
index f45089b611a20..1c3ad68952323 100644
--- a/src/gallium/auxiliary/postprocess/pp_mlaa.c
+++ b/src/gallium/auxiliary/postprocess/pp_mlaa.c
@@ -97,15 +97,18 @@ pp_jimenezmlaa_run(struct pp_queue_t *ppq, struct pipe_resource *in,
       dimensions[1] = p->framebuffer.height;
    }
 
+   struct pipe_context *pipe = ppq->p->pipe;
+   struct pipe_resource *buffer = pipe_buffer_create_with_data(pipe, PIPE_BIND_CONSTANT_BUFFER,
+                                                               PIPE_USAGE_IMMUTABLE, sizeof(constants),
+                                                               constants);
    struct pipe_constant_buffer cb;
-   cb.buffer = NULL;
+   cb.buffer = buffer;
    cb.buffer_offset = 0;
    cb.buffer_size = sizeof(constants);
-   cb.user_buffer = constants;
+   cb.user_buffer = NULL;
 
-   struct pipe_context *pipe = ppq->p->pipe;
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &cb);
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, 0, false, &cb);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, &cb);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, 0, &cb);
 
    mstencil.stencil[0].enabled = 1;
    mstencil.stencil[0].valuemask = mstencil.stencil[0].writemask = ~0;
@@ -209,6 +212,7 @@ pp_jimenezmlaa_run(struct pp_queue_t *ppq, struct pipe_resource *in,
    pp_filter_end_pass(p);
    pipe->sampler_view_release(pipe, arr[0]);
    pipe->sampler_view_release(pipe, arr[1]);
+   pipe_resource_release(pipe, buffer);
 
    p->blend.rt[0].blend_enable = 0;
    memset(&p->framebuffer.zsbuf, 0, sizeof(p->framebuffer.zsbuf));
-- 
GitLab


From 266374c7bea8396efc5409e1d8355ede0487eaf3 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 22 Jul 2025 12:08:56 -0400
Subject: [PATCH 16/23] u_upload: outbuf no longer needs refcounting management

---
 src/gallium/auxiliary/hud/hud_context.c       |  1 -
 src/gallium/auxiliary/indices/u_primconvert.c |  4 --
 .../auxiliary/util/u_threaded_context.c       |  1 -
 src/gallium/auxiliary/util/u_upload_mgr.c     | 44 +------------------
 src/gallium/auxiliary/util/u_vbuf.c           | 19 --------
 src/gallium/frontends/lavapipe/lvp_execute.c  |  9 ----
 src/mesa/state_tracker/st_cb_drawtex.c        |  1 -
 src/mesa/state_tracker/st_draw.c              |  1 -
 src/mesa/state_tracker/st_pbo.c               |  3 +-
 9 files changed, 2 insertions(+), 81 deletions(-)

diff --git a/src/gallium/auxiliary/hud/hud_context.c b/src/gallium/auxiliary/hud/hud_context.c
index 5111cf256e0dd..31d2e3f0336ee 100644
--- a/src/gallium/auxiliary/hud/hud_context.c
+++ b/src/gallium/auxiliary/hud/hud_context.c
@@ -116,7 +116,6 @@ hud_draw_colored_prims(struct hud_context *hud, unsigned prim,
    cso_set_vertex_buffers(cso, 1, &vbuffer);
    cso_set_fragment_shader_handle(hud->cso, hud->fs_color);
    cso_draw_arrays(cso, prim, 0, num_vertices);
-   pipe_resource_release(hud->pipe, vbuffer.buffer.resource);
 }
 
 static void
diff --git a/src/gallium/auxiliary/indices/u_primconvert.c b/src/gallium/auxiliary/indices/u_primconvert.c
index 8b476b8bb3914..ee2eb21d99fb7 100644
--- a/src/gallium/auxiliary/indices/u_primconvert.c
+++ b/src/gallium/auxiliary/indices/u_primconvert.c
@@ -293,8 +293,6 @@ util_primconvert_draw_single_vbo(struct primconvert_context *pc,
       return;
    /* to the translated draw: */
    pc->pipe->draw_vbo(pc->pipe, &new_info, drawid_offset, NULL, &new_draw, 1);
-
-   pc->pipe->resource_release(pc->pipe, new_info.index.resource);
 }
 
 void
@@ -375,6 +373,4 @@ util_primconvert_draw_vertex_state(struct primconvert_context *pc,
    }
    if (info.take_vertex_state_ownership)
       pipe_vertex_state_reference(&vstate, NULL);
-
-   pipe_resource_reference(&new_info.index.resource, NULL);
 }
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 45118e11628a8..8894870409688 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -4076,7 +4076,6 @@ tc_draw_user_indices_multi(struct pipe_context *_pipe,
       total_offset += dr;
       num_draws -= dr;
    }
-   pipe_resource_release(_pipe, buffer);
 }
 
 static void
diff --git a/src/gallium/auxiliary/util/u_upload_mgr.c b/src/gallium/auxiliary/util/u_upload_mgr.c
index 4b1ca06433217..b0ff0ee69b798 100644
--- a/src/gallium/auxiliary/util/u_upload_mgr.c
+++ b/src/gallium/auxiliary/util/u_upload_mgr.c
@@ -54,7 +54,6 @@ struct u_upload_mgr {
    unsigned buffer_size; /* Same as buffer->width0. */
    unsigned offset; /* Aligned offset to the upload buffer, pointing
                      * at the first unused byte. */
-   int buffer_private_refcount;
 };
 
 
@@ -151,16 +150,7 @@ u_upload_release_buffer(struct u_upload_mgr *upload)
 {
    /* Unmap and unreference the upload buffer. */
    upload_unmap_internal(upload, true);
-   if (upload->buffer_private_refcount) {
-      /* Subtract the remaining private references before unreferencing
-       * the buffer. The mega comment below explains it.
-       */
-      assert(upload->buffer_private_refcount > 0);
-      p_atomic_add(&upload->buffer->reference.count,
-                   -upload->buffer_private_refcount);
-      upload->buffer_private_refcount = 0;
-   }
-   pipe_resource_reference(&upload->buffer, NULL);
+   pipe_resource_release(upload->pipe, upload->buffer);
    upload->buffer_size = 0;
 }
 
@@ -208,33 +198,6 @@ u_upload_alloc_buffer(struct u_upload_mgr *upload, unsigned min_size)
    if (upload->buffer == NULL)
       return 0;
 
-   /* Since atomic operations are very very slow when 2 threads are not
-    * sharing the same L3 cache (which happens on AMD Zen), eliminate all
-    * atomics in u_upload_alloc as follows:
-    *
-    * u_upload_alloc has to return a buffer reference to the caller.
-    * Instead of atomic_inc for every call, it does all possible future
-    * increments in advance here. The maximum number of times u_upload_alloc
-    * can be called per upload buffer is "size", because the minimum
-    * allocation size is 1, thus u_upload_alloc can only return "size" number
-    * of suballocations at most, so we will never need more. This is
-    * the number that is added to reference.count here.
-    *
-    * buffer_private_refcount tracks how many buffer references we can return
-    * without using atomics. If the buffer is full and there are still
-    * references left, they are atomically subtracted from reference.count
-    * before the buffer is unreferenced.
-    *
-    * This technique can increase CPU performance by 10%.
-    *
-    * The caller of u_upload_alloc_buffer will consume min_size bytes,
-    * so init the buffer_private_refcount to 1 + size - min_size, instead
-    * of size to avoid overflowing reference.count when size is huge.
-    */
-   upload->buffer_private_refcount = 1 + (size - min_size);
-   assert(upload->buffer_private_refcount < INT32_MAX / 2);
-   p_atomic_add(&upload->buffer->reference.count, upload->buffer_private_refcount);
-
    /* Map the new buffer. */
    upload->map = pipe_buffer_map_range(upload->pipe, upload->buffer,
                                        0, size, upload->map_flags,
@@ -273,7 +236,6 @@ u_upload_alloc(struct u_upload_mgr *upload,
 
       if (unlikely(!buffer_size)) {
          *out_offset = ~0;
-         pipe_resource_reference(outbuf, NULL);
          *ptr = NULL;
          return;
       }
@@ -288,7 +250,6 @@ u_upload_alloc(struct u_upload_mgr *upload,
       if (unlikely(!upload->map)) {
          upload->transfer = NULL;
          *out_offset = ~0;
-         pipe_resource_reference(outbuf, NULL);
          *ptr = NULL;
          return;
       }
@@ -305,10 +266,7 @@ u_upload_alloc(struct u_upload_mgr *upload,
    *out_offset = offset;
 
    if (*outbuf != upload->buffer) {
-      pipe_resource_reference(outbuf, NULL);
       *outbuf = upload->buffer;
-      assert (upload->buffer_private_refcount > 0);
-      upload->buffer_private_refcount--;
    }
 
    upload->offset = offset + size;
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index e7536a5f4362b..68c41c9861c7e 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -438,20 +438,10 @@ void u_vbuf_unset_vertex_elements(struct u_vbuf *mgr)
    mgr->ve = NULL;
 }
 
-static void
-u_vbuf_release_ownership(struct u_vbuf *mgr, unsigned last_count)
-{
-   /* only the fallback vbs have refs */
-   u_foreach_bit(i, mgr->fallback_vbs_mask)
-      pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
-}
-
 void u_vbuf_destroy(struct u_vbuf *mgr)
 {
    mgr->pipe->set_vertex_buffers(mgr->pipe, 0, NULL);
 
-   u_vbuf_release_ownership(mgr, mgr->num_vertex_buffers);
-
    if (mgr->pc)
       util_primconvert_destroy(mgr->pc);
 
@@ -652,7 +642,6 @@ u_vbuf_translate_find_free_vb_slots(struct u_vbuf *mgr,
          index = ffs(unused_vb_mask) - 1;
          fallback_vbs[type] = index;
          if (prev_mask & BITFIELD_BIT(index)) {
-            pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[index].buffer.resource);
             memset(&mgr->real_vertex_buffer[index], 0, sizeof(mgr->real_vertex_buffer[index]));
          }
          mgr->fallback_vbs_mask |= 1 << index;
@@ -668,7 +657,6 @@ u_vbuf_translate_find_free_vb_slots(struct u_vbuf *mgr,
       /* When sharing one vertex buffer use per-vertex frequency for everything. */
       fallback_vbs[VB_VERTEX] = index;
       if (prev_mask & BITFIELD_BIT(index)) {
-         pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[index].buffer.resource);
          memset(&mgr->real_vertex_buffer[index], 0, sizeof(mgr->real_vertex_buffer[index]));
       }
       mgr->fallback_vbs_mask = 1 << index;
@@ -868,7 +856,6 @@ static void u_vbuf_translate_end(struct u_vbuf *mgr)
    for (i = 0; i < VB_NUM; i++) {
       unsigned vb = mgr->fallback_vbs[i];
       if (vb != ~0u) {
-         pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[vb].buffer.resource);
          memset(&mgr->real_vertex_buffer[vb], 0, sizeof(mgr->real_vertex_buffer[vb]));
          mgr->fallback_vbs[i] = ~0;
       }
@@ -1007,7 +994,6 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
 {
    if (!count) {
       struct pipe_context *pipe = mgr->pipe;
-      unsigned last_count = mgr->num_vertex_buffers;
 
       /* Unbind. */
       mgr->num_vertex_buffers = 0;
@@ -1020,7 +1006,6 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
       mgr->vertex_buffers_dirty = false;
 
       pipe->set_vertex_buffers(pipe, 0, NULL);
-      u_vbuf_release_ownership(mgr, last_count);
       return;
    }
 
@@ -1037,8 +1022,6 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
    uint32_t unaligned_vb_mask[2] = {0};
    unsigned num_identical = 0;
 
-   u_vbuf_release_ownership(mgr, mgr->num_vertex_buffers);
-
    for (i = 0; i < count; i++) {
       const struct pipe_vertex_buffer *vb = &bufs[i];
       struct pipe_vertex_buffer *orig_vb = &mgr->vertex_buffer[i];
@@ -1092,8 +1075,6 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
       return;
 
    for (; i < last_count; i++) {
-      if (mgr->fallback_vbs_mask & BITFIELD_BIT(i))
-         pipe_resource_release(mgr->pipe, mgr->real_vertex_buffer[i].buffer.resource);
       memset(&mgr->vertex_buffer[i], 0, sizeof(struct pipe_vertex_buffer));
       memset(&mgr->real_vertex_buffer[i], 0, sizeof(struct pipe_vertex_buffer));
    }
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 336dca1698986..f48ca6d4b0af3 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -208,7 +208,6 @@ struct rendering_state {
    void *tess_states[2];
 
    struct util_dynarray push_desc_sets;
-   struct util_dynarray internal_buffers;
 
    struct lvp_pipeline *exec_graph;
 
@@ -4369,8 +4368,6 @@ lvp_push_internal_buffer(struct rendering_state *state, gl_shader_stage stage, u
 
    state->pctx->set_shader_buffers(state->pctx, stage, 0, 1, &buffer, 0x1);
 
-   util_dynarray_append(&state->internal_buffers, struct pipe_resource *, buffer.buffer);
-
    return mem;
 }
 
@@ -5380,7 +5377,6 @@ VkResult lvp_execute_cmds(struct lvp_device *device,
    state->sample_mask = UINT32_MAX;
    state->poison_mem = device->poison_mem;
    util_dynarray_init(&state->push_desc_sets, NULL);
-   util_dynarray_init(&state->internal_buffers, NULL);
 
    /* default values */
    state->min_sample_shading = 1;
@@ -5420,11 +5416,6 @@ VkResult lvp_execute_cmds(struct lvp_device *device,
 
    util_dynarray_fini(&state->push_desc_sets);
 
-   util_dynarray_foreach (&state->internal_buffers, struct pipe_resource *, buffer)
-      pipe_resource_reference(buffer, NULL);
-
-   util_dynarray_fini(&state->internal_buffers);
-
    for (unsigned i = 0; i < ARRAY_SIZE(state->desc_buffers); i++)
       pipe_resource_reference(&state->desc_buffers[i], NULL);
 
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index 2da25cea69d0e..b83e63ee03ef4 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -299,7 +299,6 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                            4,  /* verts */
                            numAttribs); /* attribs/vert */
 
-   pipe_resource_release(pipe, vbuffer);
    /* restore state */
    cso_restore_state(cso, 0);
    ctx->Array.NewVertexElements = true;
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index a70a2e75b625a..97b2d03674a7e 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -376,7 +376,6 @@ st_draw_quad(struct st_context *st,
    } else {
       cso_draw_arrays(st->cso_context, MESA_PRIM_TRIANGLE_FAN, 0, 4);
    }
-   pipe_resource_release(st->pipe, vb.buffer.resource);
 
    return true;
 }
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index e6e27511d7a4e..9b8e9bcd2c4df 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -213,8 +213,8 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
    cso_set_tesseval_shader_handle(cso, NULL);
 
    /* Upload vertices */
-   struct pipe_vertex_buffer vbo = {0};
    {
+      struct pipe_vertex_buffer vbo = {0};
       struct cso_velems_state velem;
 
       float x0 = (float) addr->xoffset / surface_width * 2.0f - 1.0f;
@@ -279,7 +279,6 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       cso_draw_arrays_instanced(cso, MESA_PRIM_TRIANGLE_STRIP,
                                 0, 4, 0, addr->depth);
    }
-   pipe_resource_release(st->pipe, vbo.buffer.resource);
 
    return true;
 }
-- 
GitLab


From e39001c11d99ba87598fa7a4b38665162efaa049 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 22 Jul 2025 11:47:38 -0400
Subject: [PATCH 17/23] u_upload: add _ref versions of the functions to
 preserve existing refcount behavior

---
 src/gallium/auxiliary/util/u_helpers.c        |  2 +-
 .../auxiliary/util/u_threaded_context.c       |  6 ++--
 src/gallium/auxiliary/util/u_upload_mgr.c     | 30 +++++++++++++++++++
 src/gallium/auxiliary/util/u_upload_mgr.h     | 19 ++++++++++++
 src/gallium/drivers/asahi/agx_state.c         |  6 ++--
 src/gallium/drivers/crocus/crocus_draw.c      |  6 ++--
 .../drivers/crocus/crocus_fine_fence.c        |  2 +-
 src/gallium/drivers/crocus/crocus_query.c     |  2 +-
 src/gallium/drivers/crocus/crocus_state.c     | 12 ++++----
 .../drivers/d3d12/d3d12_context_graphics.cpp  |  2 +-
 src/gallium/drivers/etnaviv/etnaviv_state.c   |  2 +-
 src/gallium/drivers/freedreno/a3xx/fd3_emit.c |  2 +-
 src/gallium/drivers/freedreno/a4xx/fd4_emit.c |  2 +-
 src/gallium/drivers/freedreno/a5xx/fd5_emit.c |  2 +-
 .../drivers/freedreno/a6xx/fd6_const.cc       |  4 +--
 .../drivers/freedreno/freedreno_state.c       |  2 +-
 src/gallium/drivers/freedreno/ir3/ir3_const.h |  4 +--
 src/gallium/drivers/iris/iris_blorp.c         |  2 +-
 src/gallium/drivers/iris/iris_draw.c          |  8 ++---
 src/gallium/drivers/iris/iris_fine_fence.c    |  2 +-
 src/gallium/drivers/iris/iris_indirect_gen.c  |  4 +--
 src/gallium/drivers/iris/iris_program.c       |  2 +-
 src/gallium/drivers/iris/iris_program_cache.c |  2 +-
 src/gallium/drivers/iris/iris_query.c         |  2 +-
 src/gallium/drivers/iris/iris_state.c         | 10 +++----
 src/gallium/drivers/lima/lima_context.c       |  2 +-
 src/gallium/drivers/lima/lima_job.c           |  2 +-
 src/gallium/drivers/llvmpipe/lp_state_fs.c    |  2 +-
 src/gallium/drivers/r300/r300_render.c        |  2 +-
 .../drivers/r300/r300_render_translate.c      |  6 ++--
 src/gallium/drivers/r300/r300_screen_buffer.c |  2 +-
 src/gallium/drivers/r600/r600_blit.c          |  2 +-
 src/gallium/drivers/r600/r600_buffer_common.c |  2 +-
 src/gallium/drivers/r600/r600_pipe_common.c   |  2 +-
 src/gallium/drivers/r600/r600_state_common.c  | 10 +++----
 src/gallium/drivers/radeonsi/si_buffer.c      |  2 +-
 src/gallium/drivers/radeonsi/si_descriptors.c |  4 +--
 src/gallium/drivers/radeonsi/si_fence.c       |  2 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |  4 +--
 src/gallium/drivers/radeonsi/si_shader.c      |  2 +-
 .../drivers/radeonsi/si_state_draw.cpp        |  6 ++--
 .../drivers/radeonsi/si_state_viewport.c      |  2 +-
 src/gallium/drivers/svga/svga_draw_elements.c |  4 +--
 .../drivers/svga/svga_resource_texture.c      |  2 +-
 .../drivers/svga/svga_state_constants.c       |  2 +-
 src/gallium/drivers/v3d/v3d_context.c         |  2 +-
 src/gallium/drivers/v3d/v3d_disk_cache.c      |  2 +-
 src/gallium/drivers/v3d/v3d_program.c         |  2 +-
 src/gallium/drivers/v3d/v3d_uniforms.c        |  2 +-
 src/gallium/drivers/v3d/v3dx_draw.c           |  2 +-
 src/gallium/drivers/v3d/v3dx_state.c          |  6 ++--
 src/gallium/drivers/vc4/vc4_draw.c            |  2 +-
 src/gallium/drivers/vc4/vc4_resource.c        |  2 +-
 src/gallium/drivers/vc4/vc4_uniforms.c        |  2 +-
 src/gallium/drivers/virgl/virgl_context.c     |  2 +-
 src/gallium/drivers/zink/zink_context.c       |  2 +-
 src/gallium/drivers/zink/zink_resource.c      |  2 +-
 57 files changed, 138 insertions(+), 89 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_helpers.c b/src/gallium/auxiliary/util/u_helpers.c
index 799ad1cd6e80c..2f3c1a677f9cf 100644
--- a/src/gallium/auxiliary/util/u_helpers.c
+++ b/src/gallium/auxiliary/util/u_helpers.c
@@ -149,7 +149,7 @@ util_upload_index_buffer(struct pipe_context *pipe,
 {
    unsigned start_offset = draw->start * info->index_size;
 
-   u_upload_data(pipe->stream_uploader, start_offset,
+   u_upload_data_ref(pipe->stream_uploader, start_offset,
                  draw->count * info->index_size, alignment,
                  (char*)info->index.user + start_offset,
                  out_offset, out_buffer);
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 8894870409688..a0e72b5193c9a 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -1632,7 +1632,7 @@ tc_set_constant_buffer(struct pipe_context *_pipe,
        * set_constant_buffer to the driver if it was done afterwards.
        */
       buffer = NULL;
-      u_upload_data(tc->base.const_uploader, 0, cb->buffer_size,
+      u_upload_data_ref(tc->base.const_uploader, 0, cb->buffer_size,
                     tc->ubo_alignment, cb->user_buffer, &offset, &buffer);
       u_upload_unmap(tc->base.const_uploader);
       take_ownership = true;
@@ -2720,7 +2720,7 @@ tc_buffer_map(struct pipe_context *_pipe,
       struct threaded_transfer *ttrans = slab_zalloc(&tc->pool_transfers);
       uint8_t *map;
 
-      u_upload_alloc(tc->base.stream_uploader, 0,
+      u_upload_alloc_ref(tc->base.stream_uploader, 0,
                      box->width + (box->x % tc->map_buffer_alignment),
                      tc->map_buffer_alignment, &ttrans->b.offset,
                      &ttrans->staging, (void**)&map);
@@ -4022,7 +4022,7 @@ tc_draw_user_indices_multi(struct pipe_context *_pipe,
     * e.g. transfer_unmap and flush partially-uninitialized draw_vbo
     * to the driver if it was done afterwards.
     */
-   u_upload_alloc(tc->base.stream_uploader, 0,
+   u_upload_alloc_ref(tc->base.stream_uploader, 0,
                   total_count << index_size_shift, 4,
                   &buffer_offset, &buffer, (void**)&ptr);
    if (unlikely(!buffer))
diff --git a/src/gallium/auxiliary/util/u_upload_mgr.c b/src/gallium/auxiliary/util/u_upload_mgr.c
index b0ff0ee69b798..cf32d33ca5ad5 100644
--- a/src/gallium/auxiliary/util/u_upload_mgr.c
+++ b/src/gallium/auxiliary/util/u_upload_mgr.c
@@ -272,6 +272,21 @@ u_upload_alloc(struct u_upload_mgr *upload,
    upload->offset = offset + size;
 }
 
+void
+u_upload_alloc_ref(struct u_upload_mgr *upload,
+               unsigned min_out_offset,
+               unsigned size,
+               unsigned alignment,
+               unsigned *out_offset,
+               struct pipe_resource **outbuf,
+               void **ptr)
+{
+   struct pipe_resource *pres = NULL;
+
+   u_upload_alloc(upload, min_out_offset, size, alignment, out_offset, &pres, ptr);
+   pipe_resource_reference(outbuf, pres);
+}
+
 void
 u_upload_data(struct u_upload_mgr *upload,
               unsigned min_out_offset,
@@ -289,3 +304,18 @@ u_upload_data(struct u_upload_mgr *upload,
    if (ptr)
       memcpy(ptr, data, size);
 }
+
+void
+u_upload_data_ref(struct u_upload_mgr *upload,
+              unsigned min_out_offset,
+              unsigned size,
+              unsigned alignment,
+              const void *data,
+              unsigned *out_offset,
+              struct pipe_resource **outbuf)
+{
+   struct pipe_resource *pres = NULL;
+
+   u_upload_data(upload, min_out_offset, size, alignment, data, out_offset, &pres);
+   pipe_resource_reference(outbuf, pres);
+}
diff --git a/src/gallium/auxiliary/util/u_upload_mgr.h b/src/gallium/auxiliary/util/u_upload_mgr.h
index 3ea1822ea6e15..fb11cd2fe5808 100644
--- a/src/gallium/auxiliary/util/u_upload_mgr.h
+++ b/src/gallium/auxiliary/util/u_upload_mgr.h
@@ -110,6 +110,16 @@ void u_upload_alloc(struct u_upload_mgr *upload,
                     void **ptr);
 
 
+/* same as above, but outbuf gains a ref */
+void
+u_upload_alloc_ref(struct u_upload_mgr *upload,
+                  unsigned min_out_offset,
+                  unsigned size,
+                  unsigned alignment,
+                  unsigned *out_offset,
+                  struct pipe_resource **outbuf,
+                  void **ptr);
+
 /**
  * Allocate and write data to the upload buffer.
  *
@@ -124,6 +134,15 @@ void u_upload_data(struct u_upload_mgr *upload,
                    unsigned *out_offset,
                    struct pipe_resource **outbuf);
 
+/* same as above, but outbuf gains a ref */
+void u_upload_data_ref(struct u_upload_mgr *upload,
+                     unsigned min_out_offset,
+                     unsigned size,
+                     unsigned alignment,
+                     const void *data,
+                     unsigned *out_offset,
+                     struct pipe_resource **outbuf);
+
 #ifdef __cplusplus
 } // extern "C" {
 #endif
diff --git a/src/gallium/drivers/asahi/agx_state.c b/src/gallium/drivers/asahi/agx_state.c
index 5b8f69c85f662..aa0a6102ff7cf 100644
--- a/src/gallium/drivers/asahi/agx_state.c
+++ b/src/gallium/drivers/asahi/agx_state.c
@@ -1312,7 +1312,7 @@ agx_set_constant_buffer(struct pipe_context *pctx, enum pipe_shader_type shader,
 
    /* Upload user buffer immediately */
    if (constants->user_buffer && !constants->buffer) {
-      u_upload_data(ctx->base.const_uploader, 0, constants->buffer_size, 64,
+      u_upload_data_ref(ctx->base.const_uploader, 0, constants->buffer_size, 64,
                     constants->user_buffer, &constants->buffer_offset,
                     &constants->buffer);
    }
@@ -4208,7 +4208,7 @@ agx_draw_without_restart(struct agx_batch *batch,
       uint32_t desc[5] = {draw->count, info->instance_count, 0,
                           draw->index_bias, info->start_instance};
 
-      u_upload_data(ctx->base.const_uploader, 0, sizeof(desc), 4, &desc,
+      u_upload_data_ref(ctx->base.const_uploader, 0, sizeof(desc), 4, &desc,
                     &indirect_synthesized.offset, &indirect_synthesized.buffer);
 
       indirect = &indirect_synthesized;
@@ -4425,7 +4425,7 @@ util_draw_multi_upload_indirect(struct pipe_context *pctx,
                                 const struct pipe_draw_start_count_bias *draws)
 {
    struct pipe_draw_indirect_info indirect_ = *indirect;
-   u_upload_data(pctx->const_uploader, 0, 4, 4, &indirect->draw_count,
+   u_upload_data_ref(pctx->const_uploader, 0, 4, 4, &indirect->draw_count,
                  &indirect_.indirect_draw_count_offset,
                  &indirect_.indirect_draw_count);
 
diff --git a/src/gallium/drivers/crocus/crocus_draw.c b/src/gallium/drivers/crocus/crocus_draw.c
index 7787d47c7bbfc..9c92534dc67b6 100644
--- a/src/gallium/drivers/crocus/crocus_draw.c
+++ b/src/gallium/drivers/crocus/crocus_draw.c
@@ -229,7 +229,7 @@ crocus_update_draw_parameters(struct crocus_context *ice,
             ice->draw.params.baseinstance = info->start_instance;
             ice->draw.params_valid = true;
 
-            u_upload_data(ice->ctx.stream_uploader, 0,
+            u_upload_data_ref(ice->ctx.stream_uploader, 0,
                           sizeof(ice->draw.params), 4, &ice->draw.params,
                           &draw_params->offset, &draw_params->res);
          }
@@ -247,7 +247,7 @@ crocus_update_draw_parameters(struct crocus_context *ice,
          ice->draw.derived_params.drawid = drawid_offset;
          ice->draw.derived_params.is_indexed_draw = is_indexed_draw;
 
-         u_upload_data(ice->ctx.stream_uploader, 0,
+         u_upload_data_ref(ice->ctx.stream_uploader, 0,
                        sizeof(ice->draw.derived_params), 4,
                        &ice->draw.derived_params, &derived_params->offset,
                        &derived_params->res);
@@ -463,7 +463,7 @@ crocus_update_grid_size_resource(struct crocus_context *ice,
       memset(ice->state.last_grid, 0, sizeof(ice->state.last_grid));
    } else if (memcmp(ice->state.last_grid, grid->grid, sizeof(grid->grid)) != 0) {
       memcpy(ice->state.last_grid, grid->grid, sizeof(grid->grid));
-      u_upload_data(ice->ctx.const_uploader, 0, sizeof(grid->grid), 4,
+      u_upload_data_ref(ice->ctx.const_uploader, 0, sizeof(grid->grid), 4,
                     grid->grid, &grid_ref->offset, &grid_ref->res);
    }
 
diff --git a/src/gallium/drivers/crocus/crocus_fine_fence.c b/src/gallium/drivers/crocus/crocus_fine_fence.c
index 9bb8a9673e31b..0838585280f44 100644
--- a/src/gallium/drivers/crocus/crocus_fine_fence.c
+++ b/src/gallium/drivers/crocus/crocus_fine_fence.c
@@ -5,7 +5,7 @@
 static void
 crocus_fine_fence_reset(struct crocus_batch *batch)
 {
-   u_upload_alloc(batch->fine_fences.uploader,
+   u_upload_alloc_ref(batch->fine_fences.uploader,
                   0, sizeof(uint64_t), sizeof(uint64_t),
                   &batch->fine_fences.ref.offset, &batch->fine_fences.ref.res,
                   (void **)&batch->fine_fences.map);
diff --git a/src/gallium/drivers/crocus/crocus_query.c b/src/gallium/drivers/crocus/crocus_query.c
index 752193a97780e..ee7f4d3ea458b 100644
--- a/src/gallium/drivers/crocus/crocus_query.c
+++ b/src/gallium/drivers/crocus/crocus_query.c
@@ -539,7 +539,7 @@ crocus_begin_query(struct pipe_context *ctx, struct pipe_query *query)
    else
       size = sizeof(struct crocus_query_snapshots);
 
-   u_upload_alloc(ice->query_buffer_uploader, 0,
+   u_upload_alloc_ref(ice->query_buffer_uploader, 0,
                   size, util_next_power_of_two(size), &q->query_state_ref.offset,
                   &q->query_state_ref.res, &ptr);
 
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 3a08235af056f..ab5cd72aa6ded 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -970,7 +970,7 @@ gen4_upload_curbe(struct crocus_batch *batch)
       goto emit;
 
    uint32_t *map;
-   u_upload_alloc(ice->ctx.const_uploader, 0, buf_sz, 64,
+   u_upload_alloc_ref(ice->ctx.const_uploader, 0, buf_sz, 64,
                   &ice->curbe.curbe_offset, (struct pipe_resource **)&ice->curbe.curbe_res, (void **) &map);
 
    /* fragment shader constants */
@@ -3482,7 +3482,7 @@ crocus_set_constant_buffer(struct pipe_context *ctx,
       if (input->user_buffer) {
          void *map = NULL;
          pipe_resource_reference(&cbuf->buffer, NULL);
-         u_upload_alloc(ice->ctx.const_uploader, 0, input->buffer_size, 64,
+         u_upload_alloc_ref(ice->ctx.const_uploader, 0, input->buffer_size, 64,
                         &cbuf->buffer_offset, &cbuf->buffer, (void **) &map);
 
          if (!cbuf->buffer) {
@@ -3527,7 +3527,7 @@ upload_sysvals(struct crocus_context *ice,
    uint32_t *map = NULL;
 
    assert(sysval_cbuf_index < PIPE_MAX_CONSTANT_BUFFERS);
-   u_upload_alloc(ice->ctx.const_uploader, 0, upload_size, 64,
+   u_upload_alloc_ref(ice->ctx.const_uploader, 0, upload_size, 64,
                   &cbuf->buffer_offset, &cbuf->buffer, (void **) &map);
 
    for (int i = 0; i < shader->num_system_values; i++) {
@@ -4017,7 +4017,7 @@ crocus_create_stream_output_target(struct pipe_context *ctx,
 #if GFX_VER >= 7
    struct crocus_context *ice = (struct crocus_context *) ctx;
    void *temp;
-   u_upload_alloc(ice->ctx.stream_uploader, 0, sizeof(uint32_t), 4,
+   u_upload_alloc_ref(ice->ctx.stream_uploader, 0, sizeof(uint32_t), 4,
                   &cso->offset_offset,
                   (struct pipe_resource **)&cso->offset_res,
                   &temp);
@@ -4066,7 +4066,7 @@ crocus_stream_store_prims_written(struct crocus_batch *batch,
                                   struct crocus_stream_output_target *tgt)
 {
    if (!tgt->offset_res) {
-      u_upload_alloc(batch->ice->ctx.stream_uploader, 0, 4096, 4,
+      u_upload_alloc_ref(batch->ice->ctx.stream_uploader, 0, 4096, 4,
                      &tgt->offset_offset,
                      (struct pipe_resource **)&tgt->offset_res,
                      &tgt->prim_map);
@@ -7790,7 +7790,7 @@ crocus_upload_render_state(struct crocus_context *ice,
 
       if (draw->has_user_indices) {
          unsigned start_offset = draw->index_size * sc->start;
-         u_upload_data(ice->ctx.stream_uploader, 0,
+         u_upload_data_ref(ice->ctx.stream_uploader, 0,
                        sc->count * draw->index_size, 4,
                        (char *)draw->index.user + start_offset,
                        &offset, &ice->state.index_buffer.res);
diff --git a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
index 1f4a15c9ca0d9..c0685d3dfc1cc 100644
--- a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
@@ -1378,7 +1378,7 @@ d3d12_set_constant_buffer(struct pipe_context *pctx,
    if (buf) {
       unsigned offset = buf->buffer_offset;
       if (buf->user_buffer) {
-         u_upload_data(pctx->const_uploader, 0, buf->buffer_size,
+         u_upload_data_ref(pctx->const_uploader, 0, buf->buffer_size,
                        D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT,
                        buf->user_buffer, &offset, &ctx->cbufs[shader][index].buffer);
          d3d12_increment_constant_buffer_bind_count(ctx, shader,
diff --git a/src/gallium/drivers/etnaviv/etnaviv_state.c b/src/gallium/drivers/etnaviv/etnaviv_state.c
index d04195c3afc74..2caa4181d70c6 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_state.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_state.c
@@ -99,7 +99,7 @@ etna_set_constant_buffer(struct pipe_context *pctx,
 
    if (!cb->buffer) {
       struct pipe_constant_buffer *cb = &so->cb[index];
-      u_upload_data(pctx->const_uploader, 0, cb->buffer_size, 16, cb->user_buffer, &cb->buffer_offset, &cb->buffer);
+      u_upload_data_ref(pctx->const_uploader, 0, cb->buffer_size, 16, cb->user_buffer, &cb->buffer_offset, &cb->buffer);
       ctx->dirty |= ETNA_DIRTY_SHADER_CACHES;
    }
 
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
index 0be39065a4ec3..60281177ac400 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
@@ -235,7 +235,7 @@ emit_textures(struct fd_context *ctx, struct fd_ringbuffer *ring,
       unsigned off;
       void *ptr;
 
-      u_upload_alloc(fd3_ctx->border_color_uploader, 0,
+      u_upload_alloc_ref(fd3_ctx->border_color_uploader, 0,
                      BORDER_COLOR_UPLOAD_SIZE, BORDER_COLOR_UPLOAD_SIZE, &off,
                      &fd3_ctx->border_color_buf, &ptr);
 
diff --git a/src/gallium/drivers/freedreno/a4xx/fd4_emit.c b/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
index 2afc1895fcdaa..353ef628748e5 100644
--- a/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
+++ b/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
@@ -333,7 +333,7 @@ emit_textures(struct fd_context *ctx, struct fd_ringbuffer *ring,
       unsigned off;
       void *ptr;
 
-      u_upload_alloc(fd4_ctx->border_color_uploader, 0,
+      u_upload_alloc_ref(fd4_ctx->border_color_uploader, 0,
                      BORDER_COLOR_UPLOAD_SIZE, BORDER_COLOR_UPLOAD_SIZE, &off,
                      &fd4_ctx->border_color_buf, &ptr);
 
diff --git a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
index 0fc2456fece87..0b3468901e183 100644
--- a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
+++ b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
@@ -294,7 +294,7 @@ emit_border_color(struct fd_context *ctx, struct fd_ringbuffer *ring) assert_dt
 
    const unsigned int alignment =
       util_next_power_of_two(FD5_BORDER_COLOR_UPLOAD_SIZE);
-   u_upload_alloc(fd5_ctx->border_color_uploader, 0,
+   u_upload_alloc_ref(fd5_ctx->border_color_uploader, 0,
                   FD5_BORDER_COLOR_UPLOAD_SIZE, alignment,
                   &off, &fd5_ctx->border_color_buf, &ptr);
 
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_const.cc b/src/gallium/drivers/freedreno/a6xx/fd6_const.cc
index b4c1559d28f14..ee0481e0591aa 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_const.cc
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_const.cc
@@ -54,7 +54,7 @@ fd6_upload_emit_driver_ubo(struct fd_context *ctx, struct fd_ringbuffer *ring,
 
    unsigned buffer_offset;
    struct pipe_resource *buffer = NULL;
-   u_upload_data(pctx->const_uploader, 0, sizedwords * sizeof(uint32_t),
+   u_upload_data_ref(pctx->const_uploader, 0, sizedwords * sizeof(uint32_t),
                  16, dwords,  &buffer_offset, &buffer);
    if (!buffer)
       return;  /* nothing good will come of this.. */
@@ -496,7 +496,7 @@ fd6_emit_cs_driver_params(struct fd_context *ctx,
       struct pipe_resource *buffer = NULL;
       unsigned buffer_offset;
 
-      u_upload_data(ctx->base.const_uploader, 0, sizeof(compute_params),
+      u_upload_data_ref(ctx->base.const_uploader, 0, sizeof(compute_params),
                      16, &compute_params,  &buffer_offset, &buffer);
 
       if (info->indirect) {
diff --git a/src/gallium/drivers/freedreno/freedreno_state.c b/src/gallium/drivers/freedreno/freedreno_state.c
index 4ef044366fb4d..d762c09e6067b 100644
--- a/src/gallium/drivers/freedreno/freedreno_state.c
+++ b/src/gallium/drivers/freedreno/freedreno_state.c
@@ -110,7 +110,7 @@ fd_set_min_samples(struct pipe_context *pctx, unsigned min_samples) in_dt
 static void
 upload_user_buffer(struct pipe_context *pctx, struct pipe_constant_buffer *cb)
 {
-   u_upload_data(pctx->stream_uploader, 0, cb->buffer_size, 64,
+   u_upload_data_ref(pctx->stream_uploader, 0, cb->buffer_size, 64,
                  cb->user_buffer, &cb->buffer_offset, &cb->buffer);
    cb->user_buffer = NULL;
 }
diff --git a/src/gallium/drivers/freedreno/ir3/ir3_const.h b/src/gallium/drivers/freedreno/ir3/ir3_const.h
index 1b4ac0274f400..828c4bf52ab68 100644
--- a/src/gallium/drivers/freedreno/ir3/ir3_const.h
+++ b/src/gallium/drivers/freedreno/ir3/ir3_const.h
@@ -218,7 +218,7 @@ ir3_emit_ubos(struct fd_context *ctx, const struct ir3_shader_variant *v,
           */
          if (cb->user_buffer) {
             struct pipe_context *pctx = &ctx->base;
-            u_upload_data(pctx->stream_uploader, 0, cb->buffer_size, 64,
+            u_upload_data_ref(pctx->stream_uploader, 0, cb->buffer_size, 64,
                           cb->user_buffer, &cb->buffer_offset, &cb->buffer);
             cb->user_buffer = NULL;
          }
@@ -638,7 +638,7 @@ ir3_emit_cs_driver_params(const struct ir3_shader_variant *v,
          struct pipe_resource *buffer = NULL;
          unsigned buffer_offset;
 
-         u_upload_data(ctx->base.const_uploader, 0, sizeof(compute_params),
+         u_upload_data_ref(ctx->base.const_uploader, 0, sizeof(compute_params),
                        16, &compute_params,  &buffer_offset, &buffer);
 
          /* Copy the indirect params into the driver param buffer.  The layout
diff --git a/src/gallium/drivers/iris/iris_blorp.c b/src/gallium/drivers/iris/iris_blorp.c
index 6c6dfdf90ab66..de61dc8cd76fb 100644
--- a/src/gallium/drivers/iris/iris_blorp.c
+++ b/src/gallium/drivers/iris/iris_blorp.c
@@ -63,7 +63,7 @@ stream_state(struct iris_batch *batch,
    struct pipe_resource *res = NULL;
    void *ptr = NULL;
 
-   u_upload_alloc(uploader, 0, size, alignment, out_offset, &res, &ptr);
+   u_upload_alloc_ref(uploader, 0, size, alignment, out_offset, &res, &ptr);
 
    struct iris_bo *bo = iris_resource_bo(res);
    iris_use_pinned_bo(batch, bo, false, IRIS_DOMAIN_NONE);
diff --git a/src/gallium/drivers/iris/iris_draw.c b/src/gallium/drivers/iris/iris_draw.c
index 5ebff01027954..40d15234661cb 100644
--- a/src/gallium/drivers/iris/iris_draw.c
+++ b/src/gallium/drivers/iris/iris_draw.c
@@ -146,7 +146,7 @@ iris_update_draw_parameters(struct iris_context *ice,
             ice->draw.params.baseinstance = info->start_instance;
             ice->draw.params_valid = true;
 
-            u_upload_data(ice->ctx.const_uploader, 0,
+            u_upload_data_ref(ice->ctx.const_uploader, 0,
                           sizeof(ice->draw.params), 4, &ice->draw.params,
                           &draw_params->offset, &draw_params->res);
          }
@@ -164,7 +164,7 @@ iris_update_draw_parameters(struct iris_context *ice,
          ice->draw.derived_params.drawid = drawid_offset;
          ice->draw.derived_params.is_indexed_draw = is_indexed_draw;
 
-         u_upload_data(ice->ctx.const_uploader, 0,
+         u_upload_data_ref(ice->ctx.const_uploader, 0,
                        sizeof(ice->draw.derived_params), 4,
                        &ice->draw.derived_params,
                        &derived_params->offset, &derived_params->res);
@@ -376,7 +376,7 @@ iris_update_grid_size_resource(struct iris_context *ice,
       grid_updated = true;
    } else if (memcmp(ice->state.last_grid, grid->grid, sizeof(grid->grid)) != 0) {
       memcpy(ice->state.last_grid, grid->grid, sizeof(grid->grid));
-      u_upload_data(ice->state.dynamic_uploader, 0, sizeof(grid->grid), 4,
+      u_upload_data_ref(ice->state.dynamic_uploader, 0, sizeof(grid->grid), 4,
                     grid->grid, &grid_ref->offset, &grid_ref->res);
       grid_updated = true;
    }
@@ -392,7 +392,7 @@ iris_update_grid_size_resource(struct iris_context *ice,
    struct iris_bo *grid_bo = iris_resource_bo(grid_ref->res);
 
    void *surf_map = NULL;
-   u_upload_alloc(ice->state.surface_uploader, 0, isl_dev->ss.size,
+   u_upload_alloc_ref(ice->state.surface_uploader, 0, isl_dev->ss.size,
                   isl_dev->ss.align, &state_ref->offset, &state_ref->res,
                   &surf_map);
    state_ref->offset +=
diff --git a/src/gallium/drivers/iris/iris_fine_fence.c b/src/gallium/drivers/iris/iris_fine_fence.c
index bdeffdd20536f..9e9e954a4edb2 100644
--- a/src/gallium/drivers/iris/iris_fine_fence.c
+++ b/src/gallium/drivers/iris/iris_fine_fence.c
@@ -5,7 +5,7 @@
 static void
 iris_fine_fence_reset(struct iris_batch *batch)
 {
-   u_upload_alloc(batch->fine_fences.uploader,
+   u_upload_alloc_ref(batch->fine_fences.uploader,
 		  0, sizeof(uint64_t), sizeof(uint64_t),
                   &batch->fine_fences.ref.offset, &batch->fine_fences.ref.res,
                   (void **)&batch->fine_fences.map);
diff --git a/src/gallium/drivers/iris/iris_indirect_gen.c b/src/gallium/drivers/iris/iris_indirect_gen.c
index 1204e6fdc71ee..73d0f5ca41e01 100644
--- a/src/gallium/drivers/iris/iris_indirect_gen.c
+++ b/src/gallium/drivers/iris/iris_indirect_gen.c
@@ -116,7 +116,7 @@ upload_state(struct iris_batch *batch,
              unsigned alignment)
 {
    void *p = NULL;
-   u_upload_alloc(uploader, 0, size, alignment, &ref->offset, &ref->res, &p);
+   u_upload_alloc_ref(uploader, 0, size, alignment, &ref->offset, &ref->res, &p);
    iris_use_pinned_bo(batch, iris_resource_bo(ref->res), false, IRIS_DOMAIN_NONE);
    return p;
 }
@@ -131,7 +131,7 @@ stream_state(struct iris_batch *batch,
 {
    void *ptr = NULL;
 
-   u_upload_alloc(uploader, 0, size, alignment, out_offset, out_res, &ptr);
+   u_upload_alloc_ref(uploader, 0, size, alignment, out_offset, out_res, &ptr);
 
    struct iris_bo *bo = iris_resource_bo(*out_res);
    iris_use_pinned_bo(batch, bo, false, IRIS_DOMAIN_NONE);
diff --git a/src/gallium/drivers/iris/iris_program.c b/src/gallium/drivers/iris/iris_program.c
index a3e05775b6a35..e1bb9fd3f2eda 100644
--- a/src/gallium/drivers/iris/iris_program.c
+++ b/src/gallium/drivers/iris/iris_program.c
@@ -696,7 +696,7 @@ upload_state(struct u_upload_mgr *uploader,
              unsigned alignment)
 {
    void *p = NULL;
-   u_upload_alloc(uploader, 0, size, alignment, &ref->offset, &ref->res, &p);
+   u_upload_alloc_ref(uploader, 0, size, alignment, &ref->offset, &ref->res, &p);
    return p;
 }
 
diff --git a/src/gallium/drivers/iris/iris_program_cache.c b/src/gallium/drivers/iris/iris_program_cache.c
index 9d758e128bf83..cbdda6772c82b 100644
--- a/src/gallium/drivers/iris/iris_program_cache.c
+++ b/src/gallium/drivers/iris/iris_program_cache.c
@@ -165,7 +165,7 @@ iris_upload_shader(struct iris_screen *screen,
 {
    const struct intel_device_info *devinfo = screen->devinfo;
 
-   u_upload_alloc(uploader, 0, shader->program_size, 64,
+   u_upload_alloc_ref(uploader, 0, shader->program_size, 64,
                   &shader->assembly.offset, &shader->assembly.res,
                   &shader->map);
    memcpy(shader->map, assembly, shader->program_size);
diff --git a/src/gallium/drivers/iris/iris_query.c b/src/gallium/drivers/iris/iris_query.c
index 29a5161cbb333..6810342c14f34 100644
--- a/src/gallium/drivers/iris/iris_query.c
+++ b/src/gallium/drivers/iris/iris_query.c
@@ -518,7 +518,7 @@ iris_begin_query(struct pipe_context *ctx, struct pipe_query *query)
    else
       size = sizeof(struct iris_query_snapshots);
 
-   u_upload_alloc(ice->query_buffer_uploader, 0,
+   u_upload_alloc_ref(ice->query_buffer_uploader, 0,
                   size, util_next_power_of_two(size),
                   &q->query_state_ref.offset,
                   &q->query_state_ref.res, &ptr);
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index 4794d997017c1..95310bac617b2 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -326,7 +326,7 @@ upload_state(struct u_upload_mgr *uploader,
              unsigned alignment)
 {
    void *p = NULL;
-   u_upload_alloc(uploader, 0, size, alignment, &ref->offset, &ref->res, &p);
+   u_upload_alloc_ref(uploader, 0, size, alignment, &ref->offset, &ref->res, &p);
    return p;
 }
 
@@ -347,7 +347,7 @@ stream_state(struct iris_batch *batch,
 {
    void *ptr = NULL;
 
-   u_upload_alloc(uploader, 0, size, alignment, out_offset, out_res, &ptr);
+   u_upload_alloc_ref(uploader, 0, size, alignment, out_offset, out_res, &ptr);
 
    struct iris_bo *bo = iris_resource_bo(*out_res);
    iris_use_pinned_bo(batch, bo, false, IRIS_DOMAIN_NONE);
@@ -3967,7 +3967,7 @@ iris_set_constant_buffer(struct pipe_context *ctx,
       if (input->user_buffer) {
          void *map = NULL;
          pipe_resource_reference(&cbuf->buffer, NULL);
-         u_upload_alloc(ice->ctx.const_uploader, 0, input->buffer_size, 64,
+         u_upload_alloc_ref(ice->ctx.const_uploader, 0, input->buffer_size, 64,
                         &cbuf->buffer_offset, &cbuf->buffer, (void **) &map);
 
          if (!cbuf->buffer) {
@@ -4030,7 +4030,7 @@ upload_sysvals(struct iris_context *ice,
    void *map = NULL;
 
    assert(sysval_cbuf_index < PIPE_MAX_CONSTANT_BUFFERS);
-   u_upload_alloc(ice->ctx.const_uploader, 0, upload_size, 64,
+   u_upload_alloc_ref(ice->ctx.const_uploader, 0, upload_size, 64,
                   &cbuf->buffer_offset, &cbuf->buffer, &map);
 
    uint32_t *sysval_map = map;
@@ -8481,7 +8481,7 @@ iris_emit_index_buffer(struct iris_context *ice,
    if (draw->has_user_indices) {
       unsigned start_offset = draw->index_size * sc->start;
 
-      u_upload_data(ice->ctx.const_uploader, start_offset,
+      u_upload_data_ref(ice->ctx.const_uploader, start_offset,
                     sc->count * draw->index_size, 4,
                     (char*)draw->index.user + start_offset,
                     &offset, &ice->state.last_res.index_buffer);
diff --git a/src/gallium/drivers/lima/lima_context.c b/src/gallium/drivers/lima/lima_context.c
index ad966bd90ecde..7ee961e2674d1 100644
--- a/src/gallium/drivers/lima/lima_context.c
+++ b/src/gallium/drivers/lima/lima_context.c
@@ -76,7 +76,7 @@ lima_ctx_buff_alloc(struct lima_context *ctx, enum lima_ctx_buff buff,
 
    cbs->size = align(size, 0x40);
 
-   u_upload_alloc(ctx->uploader, 0, cbs->size, 0x40, &cbs->offset,
+   u_upload_alloc_ref(ctx->uploader, 0, cbs->size, 0x40, &cbs->offset,
                   &cbs->res, &ret);
 
    return ret;
diff --git a/src/gallium/drivers/lima/lima_job.c b/src/gallium/drivers/lima/lima_job.c
index fc72bbbdb3bbe..da2d4f125ade7 100644
--- a/src/gallium/drivers/lima/lima_job.c
+++ b/src/gallium/drivers/lima/lima_job.c
@@ -310,7 +310,7 @@ lima_job_create_stream_bo(struct lima_job *job, int pipe,
    void *cpu;
    unsigned offset;
    struct pipe_resource *pres = NULL;
-   u_upload_alloc(ctx->uploader, 0, size, 0x40, &offset, &pres, &cpu);
+   u_upload_alloc_ref(ctx->uploader, 0, size, 0x40, &offset, &pres, &cpu);
 
    struct lima_resource *res = lima_resource(pres);
    *va = res->bo->va + offset;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 654af717b6c55..2bca60e3c3bc9 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -4231,7 +4231,7 @@ llvmpipe_set_constant_buffer(struct pipe_context *pipe,
     * sure it doesn't get updated/freed out from under us.
     */
    if (constants->user_buffer) {
-      u_upload_data(llvmpipe->pipe.const_uploader, 0, constants->buffer_size,
+      u_upload_data_ref(llvmpipe->pipe.const_uploader, 0, constants->buffer_size,
                     16, constants->user_buffer, &constants->buffer_offset,
                     &constants->buffer);
    }
diff --git a/src/gallium/drivers/r300/r300_render.c b/src/gallium/drivers/r300/r300_render.c
index c5e6d9847304b..f835ca01a1ab9 100644
--- a/src/gallium/drivers/r300/r300_render.c
+++ b/src/gallium/drivers/r300/r300_render.c
@@ -1050,7 +1050,7 @@ static void r300_render_draw_elements(struct vbuf_render* render,
     CS_LOCALS(r300);
     DBG(r300, DBG_DRAW, "r300: render_draw_elements (count: %d)\n", count);
 
-    u_upload_data(r300->uploader, 0, count * 2, 4, indices,
+    u_upload_data_ref(r300->uploader, 0, count * 2, 4, indices,
                   &index_buffer_offset, &index_buffer);
     if (!index_buffer) {
         return;
diff --git a/src/gallium/drivers/r300/r300_render_translate.c b/src/gallium/drivers/r300/r300_render_translate.c
index b579960c49aec..cea5200cab349 100644
--- a/src/gallium/drivers/r300/r300_render_translate.c
+++ b/src/gallium/drivers/r300/r300_render_translate.c
@@ -21,7 +21,7 @@ void r300_translate_index_buffer(struct r300_context *r300,
     switch (*index_size) {
     case 1:
         *out_buffer = NULL;
-        u_upload_alloc(r300->uploader, 0, count * 2, 4,
+        u_upload_alloc_ref(r300->uploader, 0, count * 2, 4,
                        &out_offset, out_buffer, ptr);
 
         util_shorten_ubyte_elts_to_userptr(
@@ -35,7 +35,7 @@ void r300_translate_index_buffer(struct r300_context *r300,
     case 2:
         if (index_offset) {
             *out_buffer = NULL;
-            u_upload_alloc(r300->uploader, 0, count * 2, 4,
+            u_upload_alloc_ref(r300->uploader, 0, count * 2, 4,
                            &out_offset, out_buffer, ptr);
 
             util_rebuild_ushort_elts_to_userptr(&r300->context, info,
@@ -50,7 +50,7 @@ void r300_translate_index_buffer(struct r300_context *r300,
     case 4:
         if (index_offset) {
             *out_buffer = NULL;
-            u_upload_alloc(r300->uploader, 0, count * 4, 4,
+            u_upload_alloc_ref(r300->uploader, 0, count * 4, 4,
                            &out_offset, out_buffer, ptr);
 
             util_rebuild_uint_elts_to_userptr(&r300->context, info,
diff --git a/src/gallium/drivers/r300/r300_screen_buffer.c b/src/gallium/drivers/r300/r300_screen_buffer.c
index 37b6befdb09f2..490f1361e50ec 100644
--- a/src/gallium/drivers/r300/r300_screen_buffer.c
+++ b/src/gallium/drivers/r300/r300_screen_buffer.c
@@ -22,7 +22,7 @@ void r300_upload_index_buffer(struct r300_context *r300,
 
     *index_buffer = NULL;
 
-    u_upload_data(r300->uploader,
+    u_upload_data_ref(r300->uploader,
                   0, count * index_size, 4,
                   ptr + (*start * index_size),
                   &index_offset,
diff --git a/src/gallium/drivers/r600/r600_blit.c b/src/gallium/drivers/r600/r600_blit.c
index 650325d8671c6..58be3d6e1188e 100644
--- a/src/gallium/drivers/r600/r600_blit.c
+++ b/src/gallium/drivers/r600/r600_blit.c
@@ -808,7 +808,7 @@ static void r600_blitter_clear_buffer(struct r600_context *rctx,
 		return;
 	}
 
-	u_upload_data(pipe->stream_uploader, 0, num_channels*4, 4, clear_value,
+	u_upload_data_ref(pipe->stream_uploader, 0, num_channels*4, 4, clear_value,
 	              &vb.buffer_offset, &vb.buffer.resource);
 	if (!vb.buffer.resource)
 		goto out;
diff --git a/src/gallium/drivers/r600/r600_buffer_common.c b/src/gallium/drivers/r600/r600_buffer_common.c
index a49b76baf27e4..fd3bd3579a05a 100644
--- a/src/gallium/drivers/r600/r600_buffer_common.c
+++ b/src/gallium/drivers/r600/r600_buffer_common.c
@@ -374,7 +374,7 @@ void *r600_buffer_transfer_map(struct pipe_context *ctx,
 			unsigned offset;
 			struct r600_resource *staging = NULL;
 
-			u_upload_alloc(ctx->stream_uploader, 0,
+			u_upload_alloc_ref(ctx->stream_uploader, 0,
                                        box->width + (box->x % R600_MAP_BUFFER_ALIGNMENT),
 				       rctx->screen->info.tcc_cache_line_size,
 				       &offset, (struct pipe_resource**)&staging,
diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index 4b053d787f0dc..f5bfe2caccdf7 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -158,7 +158,7 @@ void r600_draw_rectangle(struct blitter_context *blitter,
 	/* Upload vertices. The hw rectangle has only 3 vertices,
 	 * The 4th one is derived from the first 3.
 	 * The vertex specification should match u_blitter's vertex element state. */
-	u_upload_alloc(rctx->b.stream_uploader, 0, sizeof(float) * 24,
+	u_upload_alloc_ref(rctx->b.stream_uploader, 0, sizeof(float) * 24,
 		       rctx->screen->info.tcc_cache_line_size,
                        &offset, &buf, (void**)&vb);
 	if (!buf)
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index 9b8664c094cb3..f15ec348af30d 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -1278,11 +1278,11 @@ static void r600_set_constant_buffer(struct pipe_context *ctx,
 				tmpPtr[i] = util_cpu_to_le32(((uint32_t *)ptr)[i]);
 			}
 
-			u_upload_data(ctx->stream_uploader, 0, size, 256,
+			u_upload_data_ref(ctx->stream_uploader, 0, size, 256,
                                       tmpPtr, &cb->buffer_offset, &cb->buffer);
 			free(tmpPtr);
 		} else {
-			u_upload_data(ctx->stream_uploader, 0,
+			u_upload_data_ref(ctx->stream_uploader, 0,
                                       input->buffer_size, 256, ptr,
                                       &cb->buffer_offset, &cb->buffer);
 		}
@@ -2298,7 +2298,7 @@ r600_indirect_parameters_init(struct r600_context *rctx,
 		indirect_parameters->counter = 0;
 		indirect_parameters->internal = NULL;
 
-		u_upload_alloc(rctx->b.b.stream_uploader, 0,
+		u_upload_alloc_ref(rctx->b.b.stream_uploader, 0,
 			       sizeof(struct r600_indirect_gpu_internal),
 			       256,
 			       &indirect_parameters->internal_offset,
@@ -2630,7 +2630,7 @@ static void r600_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info
 				indexbuf->width0 - index_offset;
 			const unsigned out_width = count * out_size;
 
-			u_upload_alloc(ctx->stream_uploader, start, out_width,
+			u_upload_alloc_ref(ctx->stream_uploader, start, out_width,
                                        256, &out_offset, &out_buffer, &ptr);
 
 			if (unlikely(!ptr))
@@ -2655,7 +2655,7 @@ static void r600_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info
 						 draws[0].count*index_size > 20)) {
 			unsigned start_offset = draws[0].start * index_size;
 			indexbuf = NULL;
-			u_upload_data(ctx->stream_uploader, 0,
+			u_upload_data_ref(ctx->stream_uploader, 0,
                                       draws[0].count * index_size, 256,
 				      (char*)info->index.user + start_offset,
 				      &index_offset, &indexbuf);
diff --git a/src/gallium/drivers/radeonsi/si_buffer.c b/src/gallium/drivers/radeonsi/si_buffer.c
index 2694506527b42..8e6ecc2f612dc 100644
--- a/src/gallium/drivers/radeonsi/si_buffer.c
+++ b/src/gallium/drivers/radeonsi/si_buffer.c
@@ -448,7 +448,7 @@ static void *si_buffer_transfer_map(struct pipe_context *ctx, struct pipe_resour
          else
             uploader = sctx->b.stream_uploader;
 
-         u_upload_alloc(uploader, 0, box->width + (box->x % SI_MAP_BUFFER_ALIGNMENT),
+         u_upload_alloc_ref(uploader, 0, box->width + (box->x % SI_MAP_BUFFER_ALIGNMENT),
                         sctx->screen->info.tcc_cache_line_size, &offset,
                         (struct pipe_resource **)&staging, (void **)&data);
 
diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index 939c646cc202b..982dcf6ffc26d 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -125,7 +125,7 @@ static void si_upload_descriptors(struct si_context *sctx, struct si_descriptors
 
    uint32_t *ptr;
    unsigned buffer_offset;
-   u_upload_alloc(sctx->b.const_uploader, first_slot_offset, upload_size,
+   u_upload_alloc_ref(sctx->b.const_uploader, first_slot_offset, upload_size,
                   si_optimal_tcc_alignment(sctx, upload_size), &buffer_offset,
                   (struct pipe_resource **)&desc->buffer, (void **)&ptr);
    if (!desc->buffer) {
@@ -1117,7 +1117,7 @@ static void si_upload_const_buffer(struct si_context *sctx, struct si_resource *
 {
    void *tmp;
 
-   u_upload_alloc(sctx->b.const_uploader, 0, size, si_optimal_tcc_alignment(sctx, size),
+   u_upload_alloc_ref(sctx->b.const_uploader, 0, size, si_optimal_tcc_alignment(sctx, size),
                   const_offset, (struct pipe_resource **)buf, &tmp);
    if (*buf)
       util_memcpy_cpu_to_le32(tmp, ptr, size);
diff --git a/src/gallium/drivers/radeonsi/si_fence.c b/src/gallium/drivers/radeonsi/si_fence.c
index ebfb3c6e04a13..14b829572568d 100644
--- a/src/gallium/drivers/radeonsi/si_fence.c
+++ b/src/gallium/drivers/radeonsi/si_fence.c
@@ -237,7 +237,7 @@ static void si_fine_fence_set(struct si_context *ctx, struct si_fine_fence *fine
    assert(util_bitcount(flags & (PIPE_FLUSH_TOP_OF_PIPE | PIPE_FLUSH_BOTTOM_OF_PIPE)) == 1);
 
    /* Use cached system memory for the fence. */
-   u_upload_alloc(ctx->cached_gtt_allocator, 0, 4, 4, &fine->offset,
+   u_upload_alloc_ref(ctx->cached_gtt_allocator, 0, 4, 4, &fine->offset,
                   (struct pipe_resource **)&fine->buf, (void **)&fence_ptr);
    if (!fine->buf)
       return;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 4c77f62c356ff..c63a9d300794a 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -1143,9 +1143,9 @@ struct si_context {
    uint16_t vertex_buffer_unaligned; /* bitmask of not dword-aligned buffers */
    struct pipe_vertex_buffer vertex_buffer[SI_NUM_VERTEX_BUFFERS];
 
-   /* Even though we don't need this variable, u_upload_alloc has an optimization that skips
+   /* Even though we don't need this variable, u_upload_alloc_ref has an optimization that skips
     * reference counting when the new upload buffer is the same as the last one. So keep
-    * the last upload buffer here and always pass &last_const_upload_buffer to u_upload_alloc.
+    * the last upload buffer here and always pass &last_const_upload_buffer to u_upload_alloc_ref.
     */
    struct si_resource *last_const_upload_buffer;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index c4b21e4c8d49e..64a04bac80576 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -323,7 +323,7 @@ static void *pre_upload_binary(struct si_screen *sscreen, struct si_shader *shad
       *upload_ctx = si_get_aux_context(&sscreen->aux_context.shader_upload);
 
       void *ret;
-      u_upload_alloc((*upload_ctx)->b.stream_uploader, 0, binary_size, 256,
+      u_upload_alloc_ref((*upload_ctx)->b.stream_uploader, 0, binary_size, 256,
                      staging_offset, staging, &ret);
       if (!ret)
          si_put_aux_context_flush(&sscreen->aux_context.shader_upload);
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index bd91e23b239b8..8d99d237df15c 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -1868,7 +1868,7 @@ static bool si_upload_and_prefetch_VB_descriptors(struct si_context *sctx,
          /* Vertex buffer descriptors are the only ones which are uploaded directly
           * and don't go through si_upload_graphics_shader_descriptors.
           */
-         u_upload_alloc(sctx->b.const_uploader, 0, alloc_size,
+         u_upload_alloc_ref(sctx->b.const_uploader, 0, alloc_size,
                         si_optimal_tcc_alignment(sctx, alloc_size), &offset,
                         (struct pipe_resource **)&sctx->last_const_upload_buffer, (void **)&ptr);
          if (!sctx->last_const_upload_buffer)
@@ -2184,7 +2184,7 @@ static void si_draw(struct pipe_context *ctx,
          start_offset = start * 2;
          size = count * 2;
 
-         /* Don't use u_upload_alloc because we don't need to map the buffer for CPU access. */
+         /* Don't use u_upload_alloc_ref because we don't need to map the buffer for CPU access. */
          indexbuf = pipe_buffer_create(&sctx->screen->b, 0, PIPE_USAGE_IMMUTABLE, start_offset + size);
          if (unlikely(!indexbuf))
             return;
@@ -2208,7 +2208,7 @@ static void si_draw(struct pipe_context *ctx,
          start_offset = draws[0].start * index_size;
 
          indexbuf = NULL;
-         u_upload_data(ctx->stream_uploader, start_offset, draws[0].count * index_size,
+         u_upload_data_ref(ctx->stream_uploader, start_offset, draws[0].count * index_size,
                        sctx->screen->info.tcc_cache_line_size,
                        (char *)info->index.user + start_offset, &index_offset, &indexbuf);
          if (unlikely(!indexbuf))
diff --git a/src/gallium/drivers/radeonsi/si_state_viewport.c b/src/gallium/drivers/radeonsi/si_state_viewport.c
index b72122eec58a2..7f8d8b188f2d6 100644
--- a/src/gallium/drivers/radeonsi/si_state_viewport.c
+++ b/src/gallium/drivers/radeonsi/si_state_viewport.c
@@ -86,7 +86,7 @@ static void si_emit_cull_state(struct si_context *sctx, unsigned index)
        memcmp(&info, &sctx->last_small_prim_cull_info, sizeof(info))) {
       unsigned offset = 0;
 
-      u_upload_data(sctx->b.const_uploader, 0, sizeof(info),
+      u_upload_data_ref(sctx->b.const_uploader, 0, sizeof(info),
                     si_optimal_tcc_alignment(sctx, sizeof(info)), &info, &offset,
                     (struct pipe_resource **)&sctx->small_prim_cull_info_buf);
 
diff --git a/src/gallium/drivers/svga/svga_draw_elements.c b/src/gallium/drivers/svga/svga_draw_elements.c
index 59415fbe24ef1..2efe297ed2848 100644
--- a/src/gallium/drivers/svga/svga_draw_elements.c
+++ b/src/gallium/drivers/svga/svga_draw_elements.c
@@ -111,7 +111,7 @@ translate_indices(struct svga_hwtnl *hwtnl,
          goto fail;
    } else {
       /* Allocate upload buffer space. Align to the index size. */
-      u_upload_alloc(pipe->stream_uploader, 0, size, gen_size,
+      u_upload_alloc_ref(pipe->stream_uploader, 0, size, gen_size,
                      out_offset, &dst, &dst_map);
       if (!dst)
          goto fail;
@@ -246,7 +246,7 @@ svga_hwtnl_draw_range_elements(struct svga_hwtnl *hwtnl,
       unsigned index_offset;
 
       if (info->has_user_indices) {
-         u_upload_data(pipe->stream_uploader, 0, count * info->index_size,
+         u_upload_data_ref(pipe->stream_uploader, 0, count * info->index_size,
                        info->index_size, (char *) info->index.user + start_offset,
                        &index_offset, &index_buffer);
          u_upload_unmap(pipe->stream_uploader);
diff --git a/src/gallium/drivers/svga/svga_resource_texture.c b/src/gallium/drivers/svga/svga_resource_texture.c
index 0764c27d3975f..44775527c9a77 100644
--- a/src/gallium/drivers/svga/svga_resource_texture.c
+++ b/src/gallium/drivers/svga/svga_resource_texture.c
@@ -1459,7 +1459,7 @@ svga_texture_transfer_map_upload(struct svga_context *svga,
     * upload buffer manager code will try to allocate a new buffer
     * with the new buffer size.
     */
-   u_upload_alloc(svga->tex_upload, 0, upload_size, 16,
+   u_upload_alloc_ref(svga->tex_upload, 0, upload_size, 16,
                   &offset, &tex_buffer, &tex_map);
 
    if (!tex_map) {
diff --git a/src/gallium/drivers/svga/svga_state_constants.c b/src/gallium/drivers/svga/svga_state_constants.c
index a4fc07fe874ba..14df6a7079d10 100644
--- a/src/gallium/drivers/svga/svga_state_constants.c
+++ b/src/gallium/drivers/svga/svga_state_constants.c
@@ -771,7 +771,7 @@ emit_constbuf(struct svga_context *svga,
        */
       alloc_buf_size = align(new_buf_size, CONST0_UPLOAD_ALIGNMENT);
 
-      u_upload_alloc(svga->const0_upload, 0, alloc_buf_size,
+      u_upload_alloc_ref(svga->const0_upload, 0, alloc_buf_size,
                      CONST0_UPLOAD_ALIGNMENT, &offset,
                      &dst_buffer, &dst_map);
 
diff --git a/src/gallium/drivers/v3d/v3d_context.c b/src/gallium/drivers/v3d/v3d_context.c
index 25a29a775b30d..c81547ad20d4a 100644
--- a/src/gallium/drivers/v3d/v3d_context.c
+++ b/src/gallium/drivers/v3d/v3d_context.c
@@ -228,7 +228,7 @@ v3d_ensure_prim_counts_allocated(struct v3d_context *ctx)
 
         /* Init all 7 counters and 1 padding to 0 */
         uint32_t zeroes[8] = { 0 };
-        u_upload_data(ctx->uploader,
+        u_upload_data_ref(ctx->uploader,
                       0, sizeof(zeroes), 32, zeroes,
                       &ctx->prim_counts_offset,
                       &ctx->prim_counts);
diff --git a/src/gallium/drivers/v3d/v3d_disk_cache.c b/src/gallium/drivers/v3d/v3d_disk_cache.c
index 51587b1abb341..c0fb50579e067 100644
--- a/src/gallium/drivers/v3d/v3d_disk_cache.c
+++ b/src/gallium/drivers/v3d/v3d_disk_cache.c
@@ -166,7 +166,7 @@ v3d_disk_cache_retrieve(struct v3d_context *v3d,
                 ralloc_array(shader->prog_data.base, uint32_t, ulist_count);
         memcpy(shader->prog_data.base->uniforms.data, ulist_data, ulist_data_size);
 
-        u_upload_data(v3d->state_uploader, 0, qpu_size, 8,
+        u_upload_data_ref(v3d->state_uploader, 0, qpu_size, 8,
                       qpu_insts, &shader->offset, &shader->resource);
 
         shader->qpu_size = qpu_size;
diff --git a/src/gallium/drivers/v3d/v3d_program.c b/src/gallium/drivers/v3d/v3d_program.c
index c99c2ad5799bb..5b6f58d98a9a6 100644
--- a/src/gallium/drivers/v3d/v3d_program.c
+++ b/src/gallium/drivers/v3d/v3d_program.c
@@ -510,7 +510,7 @@ v3d_get_compiled_shader(struct v3d_context *v3d,
                 ralloc_steal(shader, shader->prog_data.base);
 
                 if (shader->qpu_size) {
-                        u_upload_data(v3d->state_uploader, 0, shader->qpu_size, 8,
+                        u_upload_data_ref(v3d->state_uploader, 0, shader->qpu_size, 8,
                                       qpu_insts, &shader->offset, &shader->resource);
                 }
 
diff --git a/src/gallium/drivers/v3d/v3d_uniforms.c b/src/gallium/drivers/v3d/v3d_uniforms.c
index 91dcdf8c3e0dd..02792d3f89370 100644
--- a/src/gallium/drivers/v3d/v3d_uniforms.c
+++ b/src/gallium/drivers/v3d/v3d_uniforms.c
@@ -322,7 +322,7 @@ v3d_write_uniforms(struct v3d_context *v3d, struct v3d_job *job,
                          * the GPU.
                         */
                         if (!cb->cb[unit].buffer) {
-                                u_upload_data(v3d->uploader, 0,
+                                u_upload_data_ref(v3d->uploader, 0,
                                               cb->cb[unit].buffer_size, 16,
                                               cb->cb[unit].user_buffer,
                                               &cb->cb[unit].buffer_offset,
diff --git a/src/gallium/drivers/v3d/v3dx_draw.c b/src/gallium/drivers/v3d/v3dx_draw.c
index d3e073fbd18a9..5812adf3213a4 100644
--- a/src/gallium/drivers/v3d/v3dx_draw.c
+++ b/src/gallium/drivers/v3d/v3dx_draw.c
@@ -1290,7 +1290,7 @@ v3d_draw_vbo(struct pipe_context *pctx, const struct pipe_draw_info *info,
                 if (info->has_user_indices) {
                         unsigned start_offset = draws[0].start * info->index_size;
                         prsc = NULL;
-                        u_upload_data(v3d->uploader, start_offset,
+                        u_upload_data_ref(v3d->uploader, start_offset,
                                       draws[0].count * info->index_size, 4,
                                       (char*)info->index.user + start_offset,
                                       &offset, &prsc);
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index 4cfbfc5f02b9c..901a46b26b543 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -436,7 +436,7 @@ v3d_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
                  * elements use them.
                  */
                 uint32_t *attrs;
-                u_upload_alloc(v3d->state_uploader, 0,
+                u_upload_alloc_ref(v3d->state_uploader, 0,
                                V3D_MAX_VS_INPUTS * sizeof(float), 16,
                                &so->defaults_offset, &so->defaults, (void **)&attrs);
 
@@ -784,7 +784,7 @@ v3d_create_sampler_state(struct pipe_context *pctx,
         int sampler_align = so->border_color_variants ? 32 : 8;
         int sampler_size = align(cl_packet_length(SAMPLER_STATE), sampler_align);
         int num_variants = (so->border_color_variants ? ARRAY_SIZE(so->sampler_state_offset) : 1);
-        u_upload_alloc(v3d->state_uploader, 0,
+        u_upload_alloc_ref(v3d->state_uploader, 0,
                        sampler_size * num_variants,
                        sampler_align,
                        &so->sampler_state_offset[0],
@@ -1340,7 +1340,7 @@ v3d_create_image_view_texture_shader_state(struct v3d_context *v3d,
         struct v3d_image_view *iview = &so->si[img];
 
         void *map;
-        u_upload_alloc(v3d->uploader, 0, cl_packet_length(TEXTURE_SHADER_STATE),
+        u_upload_alloc_ref(v3d->uploader, 0, cl_packet_length(TEXTURE_SHADER_STATE),
                        32,
                        &iview->tex_state_offset,
                        &iview->tex_state,
diff --git a/src/gallium/drivers/vc4/vc4_draw.c b/src/gallium/drivers/vc4/vc4_draw.c
index e4b30a9a0fc4e..96f59e2f4d7f6 100644
--- a/src/gallium/drivers/vc4/vc4_draw.c
+++ b/src/gallium/drivers/vc4/vc4_draw.c
@@ -403,7 +403,7 @@ vc4_draw_vbo(struct pipe_context *pctx, const struct pipe_draw_info *info,
                         if (info->has_user_indices) {
                                 unsigned start_offset = draws[0].start * info->index_size;
                                 prsc = NULL;
-                                u_upload_data(vc4->uploader, start_offset,
+                                u_upload_data_ref(vc4->uploader, start_offset,
                                               draws[0].count * index_size, 4,
                                               (char*)info->index.user + start_offset,
                                               &offset, &prsc);
diff --git a/src/gallium/drivers/vc4/vc4_resource.c b/src/gallium/drivers/vc4/vc4_resource.c
index 2fa66f78115d3..c69224d57ec2a 100644
--- a/src/gallium/drivers/vc4/vc4_resource.c
+++ b/src/gallium/drivers/vc4/vc4_resource.c
@@ -1130,7 +1130,7 @@ vc4_get_shadow_index_buffer(struct pipe_context *pctx,
 
         void *data;
         struct pipe_resource *shadow_rsc = NULL;
-        u_upload_alloc(vc4->uploader, 0, count * 2, 4,
+        u_upload_alloc_ref(vc4->uploader, 0, count * 2, 4,
                        shadow_offset, &shadow_rsc, &data);
         uint16_t *dst = data;
 
diff --git a/src/gallium/drivers/vc4/vc4_uniforms.c b/src/gallium/drivers/vc4/vc4_uniforms.c
index 6a7d1c90a01c9..5f06f7071a4ab 100644
--- a/src/gallium/drivers/vc4/vc4_uniforms.c
+++ b/src/gallium/drivers/vc4/vc4_uniforms.c
@@ -252,7 +252,7 @@ vc4_write_uniforms(struct vc4_context *vc4, struct vc4_compiled_shader *shader,
                          * the GPU.
                         */
                         if (!cb->cb[0].buffer) {
-                                u_upload_data(vc4->uploader, 0,
+                                u_upload_data_ref(vc4->uploader, 0,
                                               cb->cb[0].buffer_size, 16,
                                               cb->cb[0].user_buffer,
                                               &cb->cb[0].buffer_offset,
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 3ad10020e4633..4270bb0513a5a 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -1019,7 +1019,7 @@ static void virgl_draw_vbo(struct pipe_context *ctx,
 
            if (ib.user_buffer) {
                    unsigned start_offset = draws[0].start * ib.index_size;
-                   u_upload_data(vctx->uploader, 0,
+                   u_upload_data_ref(vctx->uploader, 0,
                                  draws[0].count * ib.index_size, 4,
                                  (char*)ib.user_buffer + start_offset,
                                  &ib.offset, &ib.buffer);
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index bde414dc89336..0210a9201cbbd 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -1550,7 +1550,7 @@ zink_set_constant_buffer_internal(struct pipe_context *pctx,
       unsigned offset = cb->buffer_offset;
       struct zink_screen *screen = zink_screen(pctx->screen);
       if (cb->user_buffer) {
-         u_upload_data(ctx->base.const_uploader, 0, cb->buffer_size,
+         u_upload_data_ref(ctx->base.const_uploader, 0, cb->buffer_size,
                        screen->info.props.limits.minUniformBufferOffsetAlignment,
                        cb->user_buffer, &offset, &buffer);
       }
diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 829a428fe4a46..dd9480c7450e0 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -2411,7 +2411,7 @@ zink_buffer_map(struct pipe_context *pctx,
                mgr = ctx->tc->base.stream_uploader;
             else
                mgr = ctx->base.stream_uploader;
-            u_upload_alloc(mgr, 0, box->width,
+            u_upload_alloc_ref(mgr, 0, box->width,
                         screen->info.props.limits.minMemoryMapAlignment, &offset,
                         (struct pipe_resource **)&trans->staging_res, (void **)&ptr);
             trans->offset = offset;
-- 
GitLab


From 6c6280e984d958011d8faa8a6ce45ab48d5978e1 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 24 Jul 2025 13:44:20 -0400
Subject: [PATCH 18/23] u_upload: releasing the buffer in frontend stuff has to
 be explicit

otherwise the upload buffer can be deleted before it is used
---
 src/gallium/auxiliary/hud/hud_context.c       |  9 ++--
 src/gallium/auxiliary/indices/u_primconvert.c | 13 ++++--
 src/gallium/auxiliary/util/u_blitter.c        |  4 +-
 .../auxiliary/util/u_threaded_context.c       |  8 +++-
 src/gallium/auxiliary/util/u_upload_mgr.c     | 27 ++++++++---
 src/gallium/auxiliary/util/u_upload_mgr.h     |  5 ++-
 src/gallium/auxiliary/util/u_vbuf.c           | 45 ++++++++++++++-----
 src/gallium/auxiliary/vl/vl_bicubic_filter.c  |  4 +-
 src/gallium/auxiliary/vl/vl_compositor_gfx.c  |  7 ++-
 src/gallium/frontends/lavapipe/lvp_execute.c  | 19 +++++++-
 .../frontends/rusticl/mesa/pipe/context.rs    |  3 ++
 src/mesa/main/compute.c                       |  3 ++
 src/mesa/state_tracker/st_atom_array.cpp      |  5 ++-
 src/mesa/state_tracker/st_atom_constbuf.c     | 38 ++++++++++++----
 src/mesa/state_tracker/st_atom_constbuf.h     |  2 +-
 src/mesa/state_tracker/st_cb_bitmap.c         |  7 ++-
 src/mesa/state_tracker/st_cb_drawpixels.c     | 10 ++++-
 src/mesa/state_tracker/st_cb_drawtex.c        |  5 ++-
 src/mesa/state_tracker/st_context.c           | 18 ++++++++
 src/mesa/state_tracker/st_context.h           |  5 +++
 src/mesa/state_tracker/st_draw.c              |  8 +++-
 src/mesa/state_tracker/st_pbo.c               |  4 +-
 .../state_tracker/st_texcompress_compute.c    |  5 ++-
 23 files changed, 200 insertions(+), 54 deletions(-)

diff --git a/src/gallium/auxiliary/hud/hud_context.c b/src/gallium/auxiliary/hud/hud_context.c
index 31d2e3f0336ee..3867ee7625c10 100644
--- a/src/gallium/auxiliary/hud/hud_context.c
+++ b/src/gallium/auxiliary/hud/hud_context.c
@@ -108,7 +108,7 @@ hud_draw_colored_prims(struct hud_context *hud, unsigned prim,
    hud->constants.scale[1] = yscale * hud_scale;
    pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &hud->constbuf);
 
-   u_upload_data(hud->pipe->stream_uploader, 0,
+   u_upload_data_ref(hud->pipe->stream_uploader, 0,
                  num_vertices * 2 * sizeof(float), 16, buffer,
                  &vbuffer.buffer_offset, &vbuffer.buffer.resource);
    u_upload_unmap(hud->pipe->stream_uploader);
@@ -116,6 +116,7 @@ hud_draw_colored_prims(struct hud_context *hud, unsigned prim,
    cso_set_vertex_buffers(cso, 1, &vbuffer);
    cso_set_fragment_shader_handle(hud->cso, hud->fs_color);
    cso_draw_arrays(cso, prim, 0, num_vertices);
+   pipe_resource_reference(&vbuffer.buffer.resource, NULL);
 }
 
 static void
@@ -696,17 +697,19 @@ hud_stop_queries(struct hud_context *hud, struct pipe_context *pipe)
    /* Allocate everything once and divide the storage into 3 portions
     * manually, because u_upload_alloc can unmap memory from previous calls.
     */
+   struct pipe_resource *pres = NULL, *releasebuf = NULL;
    u_upload_alloc(pipe->stream_uploader, 0,
                   hud->bg.buffer_size +
                   hud->whitelines.buffer_size +
                   hud->text.buffer_size,
-                  16, &hud->bg.vbuf.buffer_offset, &hud->bg.vbuf.buffer.resource,
+                  16, &hud->bg.vbuf.buffer_offset, &pres, &releasebuf,
                   (void**)&hud->bg.vertices);
    if (!hud->bg.vertices)
       return;
-
+   pipe_resource_reference(&hud->bg.vbuf.buffer.resource, pres);
    pipe_resource_reference(&hud->whitelines.vbuf.buffer.resource, hud->bg.vbuf.buffer.resource);
    pipe_resource_reference(&hud->text.vbuf.buffer.resource, hud->bg.vbuf.buffer.resource);
+   pipe_resource_release(pipe, releasebuf);
 
    hud->whitelines.vbuf.buffer_offset = hud->bg.vbuf.buffer_offset +
                                         hud->bg.buffer_size;
diff --git a/src/gallium/auxiliary/indices/u_primconvert.c b/src/gallium/auxiliary/indices/u_primconvert.c
index ee2eb21d99fb7..3e6afc92bc102 100644
--- a/src/gallium/auxiliary/indices/u_primconvert.c
+++ b/src/gallium/auxiliary/indices/u_primconvert.c
@@ -107,7 +107,8 @@ primconvert_init_draw(struct primconvert_context *pc,
                       const struct pipe_draw_info *info,
                       const struct pipe_draw_start_count_bias *draws,
                       struct pipe_draw_info *new_info,
-                      struct pipe_draw_start_count_bias *new_draw)
+                      struct pipe_draw_start_count_bias *new_draw,
+                      struct pipe_resource **releasebuf)
 {
    struct pipe_draw_start_count_bias *direct_draws = NULL;
    unsigned num_direct_draws = 0;
@@ -225,7 +226,7 @@ primconvert_init_draw(struct primconvert_context *pc,
    if (new_size > UINT_MAX)
       return false;
    u_upload_alloc(pc->pipe->stream_uploader, 0, new_size, 4,
-                  &ib_offset, &new_info->index.resource, &dst);
+                  &ib_offset, &new_info->index.resource, releasebuf, &dst);
    if (!dst)
       return false;
    new_draw->start = ib_offset / new_info->index_size;
@@ -288,11 +289,13 @@ util_primconvert_draw_single_vbo(struct primconvert_context *pc,
 {
    struct pipe_draw_info new_info;
    struct pipe_draw_start_count_bias new_draw;
+   struct pipe_resource *releasebuf = NULL;
 
-   if (!primconvert_init_draw(pc, info, draw, &new_info, &new_draw))
+   if (!primconvert_init_draw(pc, info, draw, &new_info, &new_draw, &releasebuf))
       return;
    /* to the translated draw: */
    pc->pipe->draw_vbo(pc->pipe, &new_info, drawid_offset, NULL, &new_draw, 1);
+   pipe_resource_release(pc->pipe, releasebuf);
 }
 
 void
@@ -336,6 +339,7 @@ util_primconvert_draw_vertex_state(struct primconvert_context *pc,
 {
    struct pipe_draw_info new_info;
    struct pipe_draw_start_count_bias new_draw;
+   struct pipe_resource *releasebuf = NULL;
 
    if (pc->cfg.primtypes_mask & BITFIELD_BIT(info.mode)) {
       pc->pipe->draw_vertex_state(pc->pipe, vstate, partial_velem_mask, info, draws, num_draws);
@@ -355,7 +359,7 @@ util_primconvert_draw_vertex_state(struct primconvert_context *pc,
    dinfo.index_size = 4;
    dinfo.instance_count = 1;
    dinfo.index.resource = vstate->input.indexbuf;
-   if (!primconvert_init_draw(pc, &dinfo, draws, &new_info, &new_draw))
+   if (!primconvert_init_draw(pc, &dinfo, draws, &new_info, &new_draw, &releasebuf))
       return;
 
    struct pipe_vertex_state *new_state = pc->pipe->screen->create_vertex_state(pc->pipe->screen,
@@ -373,4 +377,5 @@ util_primconvert_draw_vertex_state(struct primconvert_context *pc,
    }
    if (info.take_vertex_state_ownership)
       pipe_vertex_state_reference(&vstate, NULL);
+   pipe_resource_release(pc->pipe, releasebuf);
 }
diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 73c3ca67b53cb..1c4ac345fffdc 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -1355,11 +1355,12 @@ static void blitter_draw(struct blitter_context_priv *ctx,
 {
    struct pipe_context *pipe = ctx->base.pipe;
    struct pipe_vertex_buffer vb = {0};
+   struct pipe_resource *releasebuf = NULL;
 
    blitter_set_rectangle(ctx, x1, y1, x2, y2, depth);
 
    u_upload_data(pipe->stream_uploader, 0, sizeof(ctx->vertices), 4, ctx->vertices,
-                 &vb.buffer_offset, &vb.buffer.resource);
+                 &vb.buffer_offset, &vb.buffer.resource, &releasebuf);
    if (!vb.buffer.resource)
       return;
    u_upload_unmap(pipe->stream_uploader);
@@ -1381,6 +1382,7 @@ static void blitter_draw(struct blitter_context_priv *ctx,
       util_draw_arrays_instanced(pipe, MESA_PRIM_TRIANGLE_FAN, 0, 4,
                                  0, num_instances);
    }
+   pipe_resource_release(pipe, releasebuf);
 }
 
 void util_blitter_draw_rectangle(struct blitter_context *blitter,
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index a0e72b5193c9a..c690e3076395c 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -3883,6 +3883,7 @@ tc_draw_user_indices_single(struct pipe_context *_pipe,
    unsigned index_size = info->index_size;
    unsigned size = draws[0].count * index_size;
    struct pipe_resource *buffer = NULL;
+   struct pipe_resource *releasebuf = NULL;
    unsigned offset;
 
    if (!size)
@@ -3894,7 +3895,7 @@ tc_draw_user_indices_single(struct pipe_context *_pipe,
     */
    u_upload_data(tc->base.stream_uploader, 0, size, 4,
                  (uint8_t*)info->index.user + draws[0].start * index_size,
-                 &offset, &buffer);
+                 &offset, &buffer, &releasebuf);
    if (unlikely(!buffer))
       return;
 
@@ -3907,6 +3908,7 @@ tc_draw_user_indices_single(struct pipe_context *_pipe,
    p->info.max_index = draws[0].count;
    p->index_bias = draws[0].index_bias;
    simplify_draw_info(&p->info);
+   pipe_resource_release(_pipe, releasebuf);
 }
 
 /* Single draw with user indices and drawid_offset > 0. */
@@ -3922,6 +3924,7 @@ tc_draw_user_indices_single_draw_id(struct pipe_context *_pipe,
    unsigned index_size = info->index_size;
    unsigned size = draws[0].count * index_size;
    struct pipe_resource *buffer = NULL;
+   struct pipe_resource *releasebuf = NULL;
    unsigned offset;
 
    if (!size)
@@ -3933,7 +3936,7 @@ tc_draw_user_indices_single_draw_id(struct pipe_context *_pipe,
     */
    u_upload_data(tc->base.stream_uploader, 0, size, 4,
                  (uint8_t*)info->index.user + draws[0].start * index_size,
-                 &offset, &buffer);
+                 &offset, &buffer, &releasebuf);
    if (unlikely(!buffer))
       return;
 
@@ -3947,6 +3950,7 @@ tc_draw_user_indices_single_draw_id(struct pipe_context *_pipe,
    p->info.max_index = draws[0].count;
    p->index_bias = draws[0].index_bias;
    simplify_draw_info(&p->info);
+   pipe_resource_release(_pipe, releasebuf);
 }
 
 #define DRAW_OVERHEAD_BYTES sizeof(struct tc_draw_multi)
diff --git a/src/gallium/auxiliary/util/u_upload_mgr.c b/src/gallium/auxiliary/util/u_upload_mgr.c
index cf32d33ca5ad5..d2152f1fb366e 100644
--- a/src/gallium/auxiliary/util/u_upload_mgr.c
+++ b/src/gallium/auxiliary/util/u_upload_mgr.c
@@ -150,7 +150,6 @@ u_upload_release_buffer(struct u_upload_mgr *upload)
 {
    /* Unmap and unreference the upload buffer. */
    upload_unmap_internal(upload, true);
-   pipe_resource_release(upload->pipe, upload->buffer);
    upload->buffer_size = 0;
 }
 
@@ -159,12 +158,13 @@ void
 u_upload_destroy(struct u_upload_mgr *upload)
 {
    u_upload_release_buffer(upload);
+   pipe_resource_release(upload->pipe, upload->buffer);
    FREE(upload);
 }
 
 /* Return the allocated buffer size or 0 if it failed. */
 static unsigned
-u_upload_alloc_buffer(struct u_upload_mgr *upload, unsigned min_size)
+u_upload_alloc_buffer(struct u_upload_mgr *upload, unsigned min_size, struct pipe_resource **releasebuf)
 {
    struct pipe_screen *screen = upload->pipe->screen;
    struct pipe_resource buffer;
@@ -173,6 +173,8 @@ u_upload_alloc_buffer(struct u_upload_mgr *upload, unsigned min_size)
    /* Release the old buffer, if present:
     */
    u_upload_release_buffer(upload);
+   *releasebuf = upload->buffer;
+   upload->buffer = NULL;
 
    /* Allocate a new one:
     */
@@ -204,6 +206,7 @@ u_upload_alloc_buffer(struct u_upload_mgr *upload, unsigned min_size)
                                        &upload->transfer);
    if (upload->map == NULL) {
       u_upload_release_buffer(upload);
+      pipe_resource_release(upload->pipe, upload->buffer);
       return 0;
    }
 
@@ -219,6 +222,7 @@ u_upload_alloc(struct u_upload_mgr *upload,
                unsigned alignment,
                unsigned *out_offset,
                struct pipe_resource **outbuf,
+               struct pipe_resource **releasebuf,
                void **ptr)
 {
    unsigned buffer_size = upload->buffer_size;
@@ -232,13 +236,16 @@ u_upload_alloc(struct u_upload_mgr *upload,
    if (unlikely(offset + size > buffer_size)) {
       /* Allocate a new buffer and set the offset to the smallest one. */
       offset = align(min_out_offset, alignment);
-      buffer_size = u_upload_alloc_buffer(upload, offset + size);
+      buffer_size = u_upload_alloc_buffer(upload, offset + size, releasebuf);
 
       if (unlikely(!buffer_size)) {
          *out_offset = ~0;
          *ptr = NULL;
+         *releasebuf = NULL;
          return;
       }
+   } else {
+      *releasebuf = NULL;
    }
 
    if (unlikely(!upload->map)) {
@@ -251,6 +258,7 @@ u_upload_alloc(struct u_upload_mgr *upload,
          upload->transfer = NULL;
          *out_offset = ~0;
          *ptr = NULL;
+         *releasebuf = NULL;
          return;
       }
 
@@ -282,8 +290,10 @@ u_upload_alloc_ref(struct u_upload_mgr *upload,
                void **ptr)
 {
    struct pipe_resource *pres = NULL;
+   struct pipe_resource *releasebuf = NULL;
 
-   u_upload_alloc(upload, min_out_offset, size, alignment, out_offset, &pres, ptr);
+   u_upload_alloc(upload, min_out_offset, size, alignment, out_offset, &pres, &releasebuf, ptr);
+   pipe_resource_release(upload->pipe, releasebuf);
    pipe_resource_reference(outbuf, pres);
 }
 
@@ -294,12 +304,13 @@ u_upload_data(struct u_upload_mgr *upload,
               unsigned alignment,
               const void *data,
               unsigned *out_offset,
-              struct pipe_resource **outbuf)
+              struct pipe_resource **outbuf,
+              struct pipe_resource **releasebuf)
 {
    uint8_t *ptr;
 
    u_upload_alloc(upload, min_out_offset, size, alignment,
-                  out_offset, outbuf,
+                  out_offset, outbuf, releasebuf,
                   (void**)&ptr);
    if (ptr)
       memcpy(ptr, data, size);
@@ -315,7 +326,9 @@ u_upload_data_ref(struct u_upload_mgr *upload,
               struct pipe_resource **outbuf)
 {
    struct pipe_resource *pres = NULL;
+   struct pipe_resource *releasebuf = NULL;
 
-   u_upload_data(upload, min_out_offset, size, alignment, data, out_offset, &pres);
+   u_upload_data(upload, min_out_offset, size, alignment, data, out_offset, &pres, &releasebuf);
+   pipe_resource_release(upload->pipe, releasebuf);
    pipe_resource_reference(outbuf, pres);
 }
diff --git a/src/gallium/auxiliary/util/u_upload_mgr.h b/src/gallium/auxiliary/util/u_upload_mgr.h
index fb11cd2fe5808..f4471663da1db 100644
--- a/src/gallium/auxiliary/util/u_upload_mgr.h
+++ b/src/gallium/auxiliary/util/u_upload_mgr.h
@@ -99,6 +99,7 @@ void u_upload_unmap( struct u_upload_mgr *upload );
  * \param alignment        Alignment of the suballocation within the buffer
  * \param out_offset       Pointer to where the new buffer offset will be returned.
  * \param outbuf           Pointer to where the upload buffer will be returned.
+ * \param releasebuf       If non-null, this buffer must be released by the caller
  * \param ptr              Pointer to the allocated memory that is returned.
  */
 void u_upload_alloc(struct u_upload_mgr *upload,
@@ -107,6 +108,7 @@ void u_upload_alloc(struct u_upload_mgr *upload,
                     unsigned alignment,
                     unsigned *out_offset,
                     struct pipe_resource **outbuf,
+                    struct pipe_resource **releasebuf,
                     void **ptr);
 
 
@@ -132,7 +134,8 @@ void u_upload_data(struct u_upload_mgr *upload,
                    unsigned alignment,
                    const void *data,
                    unsigned *out_offset,
-                   struct pipe_resource **outbuf);
+                   struct pipe_resource **outbuf,
+                   struct pipe_resource **releasebuf);
 
 /* same as above, but outbuf gains a ref */
 void u_upload_data_ref(struct u_upload_mgr *upload,
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 68c41c9861c7e..9195e3efcca44 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -456,7 +456,8 @@ u_vbuf_translate_buffers(struct u_vbuf *mgr, struct translate_key *key,
                          const struct pipe_draw_start_count_bias *draw,
                          unsigned vb_mask, unsigned out_vb,
                          int start_vertex, unsigned num_vertices,
-                         int min_index, bool unroll_indices)
+                         int min_index, bool unroll_indices,
+                         struct pipe_resource **releasebuf)
 {
    struct translate *tr;
    struct pipe_transfer *vb_transfer[PIPE_MAX_ATTRIBS] = {0};
@@ -543,7 +544,7 @@ u_vbuf_translate_buffers(struct u_vbuf *mgr, struct translate_key *key,
       /* Create and map the output buffer. */
       u_upload_alloc(mgr->pipe->stream_uploader, 0,
                      key->output_stride * draw->count, 4,
-                     &out_offset, &out_buffer,
+                     &out_offset, &out_buffer, releasebuf,
                      (void**)&out_map);
       if (!out_buffer)
          return PIPE_ERROR_OUT_OF_MEMORY;
@@ -577,7 +578,7 @@ u_vbuf_translate_buffers(struct u_vbuf *mgr, struct translate_key *key,
                      mgr->has_signed_vb_offset ?
                         0 : key->output_stride * start_vertex,
                      key->output_stride * num_vertices, 4,
-                     &out_offset, &out_buffer,
+                     &out_offset, &out_buffer, releasebuf,
                      (void**)&out_map);
       if (!out_buffer)
          return PIPE_ERROR_OUT_OF_MEMORY;
@@ -683,7 +684,7 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
                        const struct pipe_draw_start_count_bias *draw,
                        int start_vertex, unsigned num_vertices,
                        int min_index, bool unroll_indices,
-                       uint32_t misaligned)
+                       uint32_t misaligned, struct pipe_resource **releasebuf)
 {
    unsigned mask[VB_NUM] = {0};
    struct translate_key key[VB_NUM];
@@ -802,7 +803,7 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
          err = u_vbuf_translate_buffers(mgr, &key[type], info, draw,
                                         mask[type], mgr->fallback_vbs[type],
                                         start[type], num[type], min_index,
-                                        unroll_indices && type == VB_VERTEX);
+                                        unroll_indices && type == VB_VERTEX, releasebuf);
          if (err != PIPE_OK)
             return false;
       }
@@ -1135,13 +1136,15 @@ get_upload_offset_size(struct u_vbuf *mgr,
 static enum pipe_error
 u_vbuf_upload_buffers(struct u_vbuf *mgr,
                       int start_vertex, unsigned num_vertices,
-                      int start_instance, unsigned num_instances)
+                      int start_instance, unsigned num_instances,
+                      unsigned *release_count, struct pipe_resource **releasebufs)
 {
    unsigned i;
    struct u_vbuf_elements *ve = mgr->ve;
    unsigned nr_velems = ve->count;
    const struct pipe_vertex_element *velems =
          mgr->using_translate ? mgr->fallback_velems.velems : ve->ve;
+   unsigned rcount = 0;
 
    /* Faster path when no vertex attribs are interleaved. */
    if ((ve->interleaved_vb_mask & mgr->user_vb_mask) == 0) {
@@ -1162,12 +1165,16 @@ u_vbuf_upload_buffers(struct u_vbuf *mgr,
          u_upload_data(mgr->pipe->stream_uploader,
                        mgr->has_signed_vb_offset ? 0 : offset,
                        size, 4, ptr + offset, &real_vb->buffer_offset,
-                       &real_vb->buffer.resource);
+                       &real_vb->buffer.resource, &releasebufs[rcount]);
          if (!real_vb->buffer.resource)
             return PIPE_ERROR_OUT_OF_MEMORY;
 
+         if (releasebufs[rcount])
+            rcount++;
+
          real_vb->buffer_offset -= offset;
       }
+      *release_count = rcount;
       return PIPE_OK;
    }
 
@@ -1222,13 +1229,18 @@ u_vbuf_upload_buffers(struct u_vbuf *mgr,
       u_upload_data(mgr->pipe->stream_uploader,
                     mgr->has_signed_vb_offset ? 0 : start,
                     end - start, 4,
-                    ptr + start, &real_vb->buffer_offset, &real_vb->buffer.resource);
+                    ptr + start, &real_vb->buffer_offset, &real_vb->buffer.resource, &releasebufs[rcount]);
       if (!real_vb->buffer.resource)
          return PIPE_ERROR_OUT_OF_MEMORY;
 
+      if (releasebufs[rcount])
+         rcount++;
+
       real_vb->buffer_offset -= start;
    }
 
+   *release_count = rcount;
+
    return PIPE_OK;
 }
 
@@ -1429,6 +1441,9 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
    const uint32_t used_vb_mask = mgr->ve->used_vb_mask;
    uint32_t user_vb_mask = mgr->user_vb_mask & used_vb_mask;
    unsigned fixed_restart_index = info->index_size ? util_prim_restart_index_from_size(info->index_size) : 0;
+   struct pipe_resource *releasebuf = NULL;
+   struct pipe_resource *releasebufs[PIPE_MAX_ATTRIBS];
+   unsigned release_count = 0;
 
    uint32_t misaligned = 0;
    if (!mgr->caps.attrib_element_unaligned) {
@@ -1678,9 +1693,9 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
           mgr->ve->incompatible_elem_mask) {
          if (!u_vbuf_translate_begin(mgr, &new_info, &new_draw,
                                      start_vertex, num_vertices,
-                                     min_index, unroll_indices, misaligned)) {
+                                     min_index, unroll_indices, misaligned, &releasebuf)) {
             debug_warn_once("u_vbuf_translate_begin() failed");
-            return;
+            goto out;
          }
 
          if (unroll_indices) {
@@ -1701,9 +1716,10 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
       if (user_vb_mask) {
          if (u_vbuf_upload_buffers(mgr, start_vertex, num_vertices,
                                    new_info.start_instance,
-                                   new_info.instance_count) != PIPE_OK) {
+                                   new_info.instance_count,
+                                   &release_count, releasebufs) != PIPE_OK) {
             debug_warn_once("u_vbuf_upload_buffers() failed");
-            return;
+            goto out;
          }
 
          mgr->vertex_buffers_dirty = true;
@@ -1750,6 +1766,11 @@ void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *inf
    if (mgr->using_translate) {
       u_vbuf_translate_end(mgr);
    }
+
+out:
+   pipe_resource_release(pipe, releasebuf);
+   for (unsigned i = 0; i < release_count; i++)
+      pipe_resource_release(pipe, releasebufs[i]);
    return;
 }
 
diff --git a/src/gallium/auxiliary/vl/vl_bicubic_filter.c b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
index 421d562ecec7b..696a850e5962c 100644
--- a/src/gallium/auxiliary/vl/vl_bicubic_filter.c
+++ b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
@@ -428,9 +428,10 @@ vl_bicubic_filter_render(struct vl_bicubic_filter *filter,
 
    struct pipe_constant_buffer cb = {0};
    float *ptr = NULL;
+   struct pipe_resource *releasebuf = NULL;
 
    u_upload_alloc(filter->pipe->const_uploader, 0, 2 * sizeof(float), 256,
-                  &cb.buffer_offset, &cb.buffer, (void**)&ptr);
+                  &cb.buffer_offset, &cb.buffer, &releasebuf, (void**)&ptr);
    cb.buffer_size = 2 * sizeof(float);
 
    if (ptr) {
@@ -465,4 +466,5 @@ vl_bicubic_filter_render(struct vl_bicubic_filter *filter,
    filter->pipe->set_vertex_buffers(filter->pipe, 1, &filter->quad);
 
    util_draw_arrays(filter->pipe, MESA_PRIM_QUADS, 0, 4);
+   pipe_resource_release(filter->pipe, releasebuf);
 }
diff --git a/src/gallium/auxiliary/vl/vl_compositor_gfx.c b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
index 4e2580ab641c6..2b98ce049f78a 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_gfx.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
@@ -599,7 +599,7 @@ calc_drawn_area(struct vl_compositor_state *s, struct vl_compositor_layer *layer
 }
 
 static void
-gen_vertex_data(struct vl_compositor *c, struct vl_compositor_state *s, struct u_rect *dirty)
+gen_vertex_data(struct vl_compositor *c, struct vl_compositor_state *s, struct u_rect *dirty, struct pipe_resource **releasebuf)
 {
    struct vertex2f *vb;
    unsigned i;
@@ -611,6 +611,7 @@ gen_vertex_data(struct vl_compositor *c, struct vl_compositor_state *s, struct u
                   VL_COMPOSITOR_VB_STRIDE * VL_COMPOSITOR_MAX_LAYERS * 4, /* size */
                   4, /* alignment */
                   &c->vertex_buf.buffer_offset, &c->vertex_buf.buffer.resource,
+                  releasebuf,
                   (void **)&vb);
 
    for (i = 0; i < VL_COMPOSITOR_MAX_LAYERS; i++) {
@@ -724,7 +725,8 @@ vl_compositor_gfx_render(struct vl_compositor_state *s,
    }
    c->pipe->set_scissor_states(c->pipe, 0, 1, &s->scissor);
 
-   gen_vertex_data(c, s, dirty_area);
+   struct pipe_resource *releasebuf = NULL;
+   gen_vertex_data(c, s, dirty_area, &releasebuf);
    set_csc_matrix(s);
 
    if (clear_dirty && dirty_area &&
@@ -744,4 +746,5 @@ vl_compositor_gfx_render(struct vl_compositor_state *s,
    c->pipe->bind_rasterizer_state(c->pipe, c->rast);
 
    draw_layers(c, s, dirty_area);
+   pipe_resource_release(c->pipe, releasebuf);
 }
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index f48ca6d4b0af3..2c23f1307604b 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -93,6 +93,8 @@ struct rendering_state {
    struct u_upload_mgr *uploader;
    struct cso_context *cso;
 
+   struct util_dynarray releasebufs;
+
    bool blend_dirty;
    bool rs_dirty;
    bool dsa_dirty;
@@ -301,7 +303,10 @@ update_pcbuf(struct rendering_state *state, enum pipe_shader_type pstage,
       cbuf.buffer_size = size;
       cbuf.buffer = NULL;
       cbuf.user_buffer = NULL;
-      u_upload_alloc(state->uploader, 0, size, 64, &cbuf.buffer_offset, &cbuf.buffer, (void**)&mem);
+      struct pipe_resource *releasebuf = NULL;
+      u_upload_alloc(state->uploader, 0, size, 64, &cbuf.buffer_offset, &cbuf.buffer, &releasebuf, (void**)&mem);
+      if (releasebuf)
+         util_dynarray_append(&state->releasebufs, struct pipe_resource*, releasebuf);
       memcpy(mem, state->push_constants, size);
       state->pctx->set_constant_buffer(state->pctx, pstage, 0, true, &cbuf);
    }
@@ -4364,7 +4369,10 @@ lvp_push_internal_buffer(struct rendering_state *state, gl_shader_stage stage, u
    };
 
    uint8_t *mem;
-   u_upload_alloc(state->uploader, 0, size, 64, &buffer.buffer_offset, &buffer.buffer, (void**)&mem);
+   struct pipe_resource *releasebuf = NULL;
+   u_upload_alloc(state->uploader, 0, size, 64, &buffer.buffer_offset, &buffer.buffer, &releasebuf, (void**)&mem);
+   if (releasebuf)
+      util_dynarray_append(&state->releasebufs, struct pipe_resource*, releasebuf);
 
    state->pctx->set_shader_buffers(state->pctx, stage, 0, 1, &buffer, 0x1);
 
@@ -5377,6 +5385,7 @@ VkResult lvp_execute_cmds(struct lvp_device *device,
    state->sample_mask = UINT32_MAX;
    state->poison_mem = device->poison_mem;
    util_dynarray_init(&state->push_desc_sets, NULL);
+   util_dynarray_init(&state->releasebufs, NULL);
 
    /* default values */
    state->min_sample_shading = 1;
@@ -5414,7 +5423,13 @@ VkResult lvp_execute_cmds(struct lvp_device *device,
    util_dynarray_foreach (&state->push_desc_sets, struct lvp_descriptor_set *, set)
       lvp_descriptor_set_destroy(device, *set);
 
+   struct pipe_resource **pres = state->releasebufs.data;
+   unsigned count = util_dynarray_num_elements(&state->releasebufs, struct pipe_resource*);
+   for (unsigned j = 0; j < count; j++)
+      pipe_resource_release(state->pctx, pres[j]);
+
    util_dynarray_fini(&state->push_desc_sets);
+   util_dynarray_fini(&state->releasebufs);
 
    for (unsigned i = 0; i < ARRAY_SIZE(state->desc_buffers); i++)
       pipe_resource_reference(&state->desc_buffers[i], NULL);
diff --git a/src/gallium/frontends/rusticl/mesa/pipe/context.rs b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
index 781ed5fe8dc34..63bcd14f81a44 100644
--- a/src/gallium/frontends/rusticl/mesa/pipe/context.rs
+++ b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
@@ -468,6 +468,7 @@ impl PipeContext {
 
         unsafe {
             let stream = self.pipe.as_ref().stream_uploader;
+            let mut releasebuf = ptr::null_mut();
             u_upload_data(
                 stream,
                 0,
@@ -476,6 +477,7 @@ impl PipeContext {
                 data.as_ptr().cast(),
                 &mut cb.buffer_offset,
                 &mut cb.buffer,
+                &mut releasebuf,
             );
             u_upload_unmap(stream);
 
@@ -490,6 +492,7 @@ impl PipeContext {
                 true,
                 &cb,
             );
+            self.pipe.as_ref().resource_release.unwrap()(self.pipe.as_ptr(), releasebuf);
 
             true
         }
diff --git a/src/mesa/main/compute.c b/src/mesa/main/compute.c
index 9ad499040b76c..df3cf6b52cadd 100644
--- a/src/mesa/main/compute.c
+++ b/src/mesa/main/compute.c
@@ -329,6 +329,7 @@ dispatch_compute(GLuint num_groups_x, GLuint num_groups_y,
 
    prepare_compute(ctx);
    ctx->pipe->launch_grid(ctx->pipe, &info);
+   st_prune_releasebufs(ctx->st, true);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
       _mesa_flush(ctx);
@@ -374,6 +375,7 @@ dispatch_compute_indirect(GLintptr indirect, bool no_error)
 
    prepare_compute(ctx);
    ctx->pipe->launch_grid(ctx->pipe, &info);
+   st_prune_releasebufs(ctx->st, true);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
       _mesa_flush(ctx);
@@ -424,6 +426,7 @@ dispatch_compute_group_size(GLuint num_groups_x, GLuint num_groups_y,
 
    prepare_compute(ctx);
    ctx->pipe->launch_grid(ctx->pipe, &info);
+   st_prune_releasebufs(ctx->st, true);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
       _mesa_flush(ctx);
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index d396026936fc3..35182d5561eac 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -313,10 +313,11 @@ st_setup_current(struct st_context *st,
                                       st->pipe->const_uploader :
                                       st->pipe->stream_uploader;
       uint8_t *ptr = NULL;
+      struct pipe_resource *releasebuf = NULL;
 
       u_upload_alloc(uploader, 0, max_size, 16,
                      &vbuffer[bufidx].buffer_offset,
-                     &vbuffer[bufidx].buffer.resource, (void**)&ptr);
+                     &vbuffer[bufidx].buffer.resource, &releasebuf, (void**)&ptr);
       uint8_t *cursor = ptr;
 
       if (FILL_TC_SET_VB) {
@@ -353,6 +354,8 @@ st_setup_current(struct st_context *st,
 
       /* Always unmap. The uploader might use explicit flushes. */
       u_upload_unmap(uploader);
+      if (releasebuf)
+         util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
    }
 }
 
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index ced2940b72c3c..6f9d8bdedab7a 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -70,14 +70,16 @@ st_upload_constant_buffer(struct st_context *st, gl_shader_stage stage, struct p
    struct pipe_context *pipe = st->pipe;
    const unsigned alignment = MAX2(st->ctx->Const.UniformBufferOffsetAlignment, 64);
    void *ptr;
+   struct pipe_resource *releasebuf = NULL;
 
    u_upload_alloc(pipe->const_uploader, 0, cbuf.buffer_size,
-      alignment, &cbuf.buffer_offset, &cbuf.buffer, (void**)&ptr);
+      alignment, &cbuf.buffer_offset, &cbuf.buffer, &releasebuf, (void**)&ptr);
    memcpy(ptr, cbuf.user_buffer, cbuf.buffer_size);
    cbuf.user_buffer = NULL;
 
    u_upload_unmap(pipe->const_uploader);
    pipe->set_constant_buffer(pipe, stage, 0, true, &cbuf);
+   pipe_resource_release(pipe, releasebuf);
 }
 
 /**
@@ -85,7 +87,7 @@ st_upload_constant_buffer(struct st_context *st, gl_shader_stage stage, struct p
  * constant buffer.
  */
 void
-st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_stage stage)
+st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_stage stage, struct pipe_resource **releasebuf)
 {
    enum pipe_shader_type shader_type = pipe_shader_type_from_mesa(stage);
    if (!prog) {
@@ -150,7 +152,7 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
           * to compensate for the fetch_state defect.
           */
          u_upload_alloc(pipe->const_uploader, 0, paramBytes + 12,
-            alignment, &cb.buffer_offset, &cb.buffer, (void**)&ptr);
+            alignment, &cb.buffer_offset, &cb.buffer, releasebuf, (void**)&ptr);
 
          int uniform_bytes = params->UniformBytes;
          if (uniform_bytes)
@@ -232,8 +234,11 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
 void
 st_update_vs_constants(struct st_context *st)
 {
+   struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->VertexProgram._Current,
-                       MESA_SHADER_VERTEX);
+                       MESA_SHADER_VERTEX, &releasebuf);
+   if (releasebuf)
+      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
 }
 
 /**
@@ -242,8 +247,11 @@ st_update_vs_constants(struct st_context *st)
 void
 st_update_fs_constants(struct st_context *st)
 {
+   struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->FragmentProgram._Current,
-                       MESA_SHADER_FRAGMENT);
+                       MESA_SHADER_FRAGMENT, &releasebuf);
+   if (releasebuf)
+      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
 }
 
 
@@ -252,8 +260,11 @@ st_update_fs_constants(struct st_context *st)
 void
 st_update_gs_constants(struct st_context *st)
 {
+   struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->GeometryProgram._Current,
-                       MESA_SHADER_GEOMETRY);
+                       MESA_SHADER_GEOMETRY, &releasebuf);
+   if (releasebuf)
+      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
 }
 
 /* Tessellation control shader:
@@ -261,8 +272,11 @@ st_update_gs_constants(struct st_context *st)
 void
 st_update_tcs_constants(struct st_context *st)
 {
+   struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->TessCtrlProgram._Current,
-                       MESA_SHADER_TESS_CTRL);
+                       MESA_SHADER_TESS_CTRL, &releasebuf);
+   if (releasebuf)
+      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
 }
 
 /* Tessellation evaluation shader:
@@ -270,8 +284,11 @@ st_update_tcs_constants(struct st_context *st)
 void
 st_update_tes_constants(struct st_context *st)
 {
+   struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->TessEvalProgram._Current,
-                       MESA_SHADER_TESS_EVAL);
+                       MESA_SHADER_TESS_EVAL, &releasebuf);
+   if (releasebuf)
+      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
 }
 
 /* Compute shader:
@@ -279,8 +296,11 @@ st_update_tes_constants(struct st_context *st)
 void
 st_update_cs_constants(struct st_context *st)
 {
+   struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->ComputeProgram._Current,
-                       MESA_SHADER_COMPUTE);
+                       MESA_SHADER_COMPUTE, &releasebuf);
+   if (releasebuf)
+      util_dynarray_append(&st->release_resources[1], struct pipe_resource*, releasebuf);
 }
 
 static void
diff --git a/src/mesa/state_tracker/st_atom_constbuf.h b/src/mesa/state_tracker/st_atom_constbuf.h
index 3491bd8b6770e..15f90d8938775 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.h
+++ b/src/mesa/state_tracker/st_atom_constbuf.h
@@ -36,7 +36,7 @@ struct gl_program_parameter_list;
 struct st_context;
 
 void st_upload_constant_buffer(struct st_context *st, gl_shader_stage stage, struct pipe_constant_buffer *cb);
-void st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_stage stage);
+void st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_stage stage, struct pipe_resource **releasebuf);
 
 
 #endif /* ST_ATOM_CONSTBUF_H */
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index e3ae006298429..a876184cabf96 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -172,6 +172,7 @@ static void
 setup_render_state(struct gl_context *ctx,
                    struct pipe_sampler_view *sv,
                    const GLfloat *color, struct gl_program *fp,
+                   struct pipe_resource **releasebuf,
                    bool scissor_enabled, bool clamp_frag_color)
 {
    struct st_context *st = st_context(ctx);
@@ -200,7 +201,7 @@ setup_render_state(struct gl_context *ctx,
       GLfloat colorSave[4];
       COPY_4V(colorSave, ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
       COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], color);
-      st_upload_constants(st, fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, fp, MESA_SHADER_FRAGMENT, releasebuf);
       COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], colorSave);
    }
 
@@ -334,7 +335,8 @@ draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
       tBot = (float) height;
    }
 
-   setup_render_state(ctx, sv, color, fp, scissor_enabled, clamp_frag_color);
+   struct pipe_resource *releasebuf = NULL;
+   setup_render_state(ctx, sv, color, fp, &releasebuf, scissor_enabled, clamp_frag_color);
 
    /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
    z = z * 2.0f - 1.0f;
@@ -343,6 +345,7 @@ draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
                      sLeft, tBot, sRight, tTop, color, 0)) {
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBitmap");
    }
+   pipe_resource_release(st->pipe, releasebuf);
 
    restore_render_state(ctx);
 
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 6f70eed7205e9..27f709c17f146 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -1315,6 +1315,7 @@ st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
    /*
     * Get vertex/fragment shaders
     */
+   struct pipe_resource *releasebuf = NULL;
    if (write_depth || write_stencil) {
       driver_fp = get_drawpix_z_stencil_program(st, write_depth,
                                                 write_stencil);
@@ -1333,7 +1334,7 @@ st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
       /* compiling a new fragment shader variant added new state constants
        * into the constant buffer, we need to update them
        */
-      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT, &releasebuf);
    }
 
    {
@@ -1384,6 +1385,8 @@ st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
 
    for (unsigned i = 0; i < num_sampler_view; i++)
       st->pipe->sampler_view_release(st->pipe, sv[i]);
+   
+   pipe_resource_release(st->pipe, releasebuf);
 
    /* free the texture (but may persist in the cache) */
    pipe_resource_reference(&pt, NULL);
@@ -1707,6 +1710,7 @@ st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
    /*
     * Get vertex/fragment shaders
     */
+   struct pipe_resource *releasebuf = NULL;
    if (type == GL_COLOR) {
       fpv = get_color_fp_variant(st);
 
@@ -1722,7 +1726,7 @@ st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
       /* compiling a new fragment shader variant added new state constants
        * into the constant buffer, we need to update them
        */
-      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT, &releasebuf);
    } else if (type == GL_DEPTH) {
       rbRead = ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
       driver_fp = get_drawpix_z_stencil_program(st, GL_TRUE, GL_FALSE);
@@ -1915,6 +1919,8 @@ st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
    st->pipe->sampler_view_release(st->pipe, sv[0]);
    if (frontend_owns_sv1)
       st->pipe->sampler_view_release(st->pipe, sv[1]);
+   
+   pipe_resource_release(st->pipe, releasebuf);
 
    pipe_resource_reference(&pt, NULL);
 }
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index b83e63ee03ef4..576ecdbb62c81 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -156,6 +156,7 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
    numAttribs = 1 + emitColor + numTexCoords;
 
    /* load vertex buffer */
+   struct pipe_resource *releasebuf = NULL;
    {
 #define SET_ATTRIB(VERT, ATTR, X, Y, Z, W)                              \
       do {                                                              \
@@ -173,7 +174,7 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
 
       u_upload_alloc(pipe->stream_uploader, 0,
                      numAttribs * 4 * 4 * sizeof(GLfloat), 4,
-                     &offset, &vbuffer, (void **) &vbuf);
+                     &offset, &vbuffer, &releasebuf, (void **) &vbuf);
       if (!vbuffer) {
          return;
       }
@@ -299,6 +300,8 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                            4,  /* verts */
                            numAttribs); /* attribs/vert */
 
+   pipe_resource_release(pipe, releasebuf);
+
    /* restore state */
    cso_restore_state(cso, 0);
    ctx->Array.NewVertexElements = true;
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 6d9f8753d4bd5..7e27586a0db3f 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -760,6 +760,9 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
    list_inithead(&st->zombie_shaders.list.node);
    simple_mtx_init(&st->zombie_shaders.mutex, mtx_plain);
 
+   for (unsigned i = 0; i < ARRAY_SIZE(st->release_resources); i++)
+      util_dynarray_init(&st->release_resources[i], NULL);
+
    ctx->Const.DriverSupportedPrimMask = screen->caps.supported_prim_modes |
                                         /* patches is always supported */
                                         BITFIELD_BIT(MESA_PRIM_PATCHES);
@@ -879,6 +882,16 @@ destroy_framebuffer_attachment_sampler_cb(void *data, void *userData)
    }
 }
 
+void
+st_prune_releasebufs(struct st_context *st, bool compute)
+{
+   struct pipe_resource **pres = st->release_resources[compute].data;
+   unsigned count = util_dynarray_num_elements(&st->release_resources[compute], struct pipe_resource*);
+   for (unsigned j = 0; j < count; j++)
+      pipe_resource_release(st->pipe, pres[j]);
+   util_dynarray_clear(&st->release_resources[compute]);
+}
+
 void
 st_destroy_context(struct st_context *st)
 {
@@ -926,6 +939,11 @@ st_destroy_context(struct st_context *st)
       }
    }
 
+   for (unsigned i = 0; i < ARRAY_SIZE(st->release_resources); i++) {
+      st_prune_releasebufs(st, i);
+      util_dynarray_fini(&st->release_resources[i]);
+   }
+
    st_release_program(st, &st->fp);
    st_release_program(st, &st->gp);
    st_release_program(st, &st->vp);
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index a4c926c496ca8..3e943a3cf75b1 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -278,6 +278,8 @@ struct st_context
       struct gl_program *current_program[MESA_SHADER_STAGES];
    };
 
+   struct util_dynarray release_resources[2]; //[gfx, compute]
+
    struct st_common_variant *vp_variant;
 
    struct {
@@ -517,6 +519,9 @@ st_api_destroy_drawable(struct pipe_frontend_drawable *drawable);
 void
 st_screen_destroy(struct pipe_frontend_screen *fscreen);
 
+void
+st_prune_releasebufs(struct st_context *st, bool compute);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 97b2d03674a7e..05dc67642cabf 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -123,6 +123,7 @@ st_draw_gallium(struct gl_context *ctx,
    struct st_context *st = st_context(ctx);
 
    cso_draw_vbo(st->cso_context, info, drawid_offset, indirect, draws, num_draws);
+   st_prune_releasebufs(st, false);
 }
 
 static void
@@ -145,6 +146,7 @@ st_draw_gallium_multimode(struct gl_context *ctx,
          first = i;
       }
    }
+   st_prune_releasebufs(st, false);
 }
 
 static void
@@ -314,10 +316,11 @@ st_draw_quad(struct st_context *st,
 {
    struct pipe_vertex_buffer vb = {0};
    struct st_util_vertex *verts;
+   struct pipe_resource *releasebuf = NULL;
 
    u_upload_alloc(st->pipe->stream_uploader, 0,
                   4 * sizeof(struct st_util_vertex), 4,
-                  &vb.buffer_offset, &vb.buffer.resource, (void **) &verts);
+                  &vb.buffer_offset, &vb.buffer.resource, &releasebuf, (void **) &verts);
    if (!vb.buffer.resource) {
       return false;
    }
@@ -376,6 +379,7 @@ st_draw_quad(struct st_context *st,
    } else {
       cso_draw_arrays(st->cso_context, MESA_PRIM_TRIANGLE_FAN, 0, 4);
    }
+   pipe_resource_release(st->pipe, releasebuf);
 
    return true;
 }
@@ -397,6 +401,7 @@ st_hw_select_draw_gallium(struct gl_context *ctx,
        st_draw_hw_select_prepare_mode(ctx, ((struct pipe_draw_info*)info))) {
       cso_draw_vbo(st->cso_context, info, drawid_offset, indirect, draws,
                    num_draws);
+      st_prune_releasebufs(st, false);
    }
 
    ((struct pipe_draw_info*)info)->mode = old_mode;
@@ -428,6 +433,7 @@ st_hw_select_draw_gallium_multimode(struct gl_context *ctx,
          first = i;
       }
    }
+   st_prune_releasebufs(st, false);
 }
 
 void
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index 9b8e9bcd2c4df..54ad9e72e53c8 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -213,6 +213,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
    cso_set_tesseval_shader_handle(cso, NULL);
 
    /* Upload vertices */
+   struct pipe_resource *releasebuf = NULL;
    {
       struct pipe_vertex_buffer vbo = {0};
       struct cso_velems_state velem;
@@ -225,7 +226,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       float *verts = NULL;
 
       u_upload_alloc(st->pipe->stream_uploader, 0, 8 * sizeof(float), 4,
-                     &vbo.buffer_offset, &vbo.buffer.resource, (void **) &verts);
+                     &vbo.buffer_offset, &vbo.buffer.resource, &releasebuf, (void **) &verts);
       if (!verts)
          return false;
 
@@ -279,6 +280,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       cso_draw_arrays_instanced(cso, MESA_PRIM_TRIANGLE_STRIP,
                                 0, 4, 0, addr->depth);
    }
+   pipe_resource_release(pipe, releasebuf);
 
    return true;
 }
diff --git a/src/mesa/state_tracker/st_texcompress_compute.c b/src/mesa/state_tracker/st_texcompress_compute.c
index 11a0d8b9e06a0..5bbb4393222ac 100644
--- a/src/mesa/state_tracker/st_texcompress_compute.c
+++ b/src/mesa/state_tracker/st_texcompress_compute.c
@@ -183,8 +183,11 @@ bind_compute_state(struct st_context *st,
    }
 
    if (prog->affected_states & ST_NEW_CS_CONSTANTS) {
+      struct pipe_resource *releasebuf = NULL;
       st_upload_constants(st, constbuf0_from_prog ? prog : NULL,
-                          prog->info.stage);
+                          prog->info.stage, &releasebuf);
+      if (releasebuf)
+         util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
    }
 
    if (prog->affected_states & ST_NEW_CS_UBOS) {
-- 
GitLab


From a5db0cd97d6df6743f7f6f31a681b9e4f50ef524 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 22 Jul 2025 12:07:26 -0400
Subject: [PATCH 19/23] remove take_ownership from set_constant_buffer

this is no longer necessary
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 10 +++---
 .../auxiliary/driver_ddebug/dd_context.c      |  3 +-
 .../auxiliary/driver_noop/noop_state.c        |  5 ---
 .../auxiliary/driver_trace/tr_context.c       |  4 +--
 src/gallium/auxiliary/hud/hud_context.c       |  8 ++---
 src/gallium/auxiliary/util/u_blitter.c        |  8 ++---
 src/gallium/auxiliary/util/u_inlines.h        | 14 +++-----
 .../auxiliary/util/u_threaded_context.c       | 32 ++++---------------
 src/gallium/auxiliary/vl/vl_bicubic_filter.c  |  2 +-
 src/gallium/auxiliary/vl/vl_compositor_cs.c   |  2 +-
 src/gallium/drivers/asahi/agx_blit.c          |  6 ++--
 src/gallium/drivers/asahi/agx_state.c         |  4 +--
 src/gallium/drivers/crocus/crocus_state.c     |  5 ++-
 .../d3d12/d3d12_compute_transforms.cpp        |  2 +-
 .../drivers/d3d12/d3d12_context_graphics.cpp  | 10 ++----
 src/gallium/drivers/d3d12/d3d12_draw.cpp      |  2 +-
 src/gallium/drivers/etnaviv/etnaviv_state.c   |  4 +--
 .../drivers/freedreno/freedreno_blitter.c     |  2 +-
 .../drivers/freedreno/freedreno_state.c       |  4 +--
 src/gallium/drivers/i915/i915_state.c         |  8 +----
 src/gallium/drivers/iris/iris_state.c         | 10 ++----
 src/gallium/drivers/lima/lima_state.c         |  1 -
 src/gallium/drivers/llvmpipe/lp_setup.c       |  4 +--
 src/gallium/drivers/llvmpipe/lp_state_cs.c    |  4 +--
 src/gallium/drivers/llvmpipe/lp_state_fs.c    |  4 +--
 src/gallium/drivers/nouveau/nv30/nv30_state.c | 15 ++-------
 src/gallium/drivers/nouveau/nv50/nv50_state.c |  8 +----
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c |  8 +----
 src/gallium/drivers/panfrost/pan_cmdstream.c  | 12 +++----
 src/gallium/drivers/panfrost/pan_context.c    |  3 +-
 src/gallium/drivers/r300/r300_state.c         |  1 -
 src/gallium/drivers/r600/evergreen_compute.c  |  2 +-
 src/gallium/drivers/r600/evergreen_state.c    | 14 ++++----
 src/gallium/drivers/r600/r600_pipe.c          |  4 +--
 src/gallium/drivers/r600/r600_query.c         |  4 +--
 src/gallium/drivers/r600/r600_state_common.c  | 22 +++++--------
 src/gallium/drivers/radeonsi/gfx11_query.c    |  2 +-
 src/gallium/drivers/radeonsi/si_descriptors.c | 16 ++++------
 src/gallium/drivers/radeonsi/si_pipe.c        |  2 +-
 src/gallium/drivers/radeonsi/si_query.c       |  2 +-
 src/gallium/drivers/radeonsi/si_state.c       |  2 +-
 .../drivers/softpipe/sp_state_shader.c        |  9 +-----
 .../drivers/svga/svga_pipe_constants.c        |  9 +-----
 src/gallium/drivers/svga/svga_state_ts.c      |  2 +-
 src/gallium/drivers/tegra/tegra_context.c     |  4 +--
 src/gallium/drivers/v3d/v3d_blit.c            | 12 +++----
 src/gallium/drivers/v3d/v3dx_state.c          |  3 +-
 src/gallium/drivers/vc4/vc4_blit.c            |  6 ++--
 src/gallium/drivers/vc4/vc4_state.c           |  3 +-
 src/gallium/drivers/virgl/virgl_context.c     |  8 +----
 src/gallium/drivers/zink/zink_context.c       | 14 ++------
 src/gallium/frontends/d3d10umd/Shader.cpp     |  1 -
 src/gallium/frontends/lavapipe/lvp_execute.c  |  8 ++---
 .../frontends/rusticl/mesa/pipe/context.rs    |  3 --
 src/gallium/include/pipe/p_context.h          |  3 --
 src/gallium/tools/trace/dump_state.py         |  2 +-
 src/mesa/state_tracker/st_atom_constbuf.c     | 10 +++---
 src/mesa/state_tracker/st_cb_clear.c          |  2 +-
 src/mesa/state_tracker/st_draw_hw_select.c    |  2 +-
 src/mesa/state_tracker/st_pbo.c               |  2 +-
 src/mesa/state_tracker/st_pbo_compute.c       |  2 +-
 61 files changed, 127 insertions(+), 253 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 8ec2d22f9340e..7c07d6d286572 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -411,7 +411,7 @@ cso_unbind_context(struct cso_context *cso)
                ctx->base.pipe->set_shader_images(ctx->base.pipe, sh, 0, 0, maximg, NULL);
             }
             for (int i = 0; i < maxcb; i++) {
-               ctx->base.pipe->set_constant_buffer(ctx->base.pipe, sh, i, false, NULL);
+               ctx->base.pipe->set_constant_buffer(ctx->base.pipe, sh, i, NULL);
             }
          }
       }
@@ -420,9 +420,9 @@ cso_unbind_context(struct cso_context *cso)
       struct pipe_stencil_ref sr = {0};
       ctx->base.pipe->set_stencil_ref(ctx->base.pipe, sr);
       ctx->base.pipe->bind_fs_state(ctx->base.pipe, NULL);
-      ctx->base.pipe->set_constant_buffer(ctx->base.pipe, PIPE_SHADER_FRAGMENT, 0, false, NULL);
+      ctx->base.pipe->set_constant_buffer(ctx->base.pipe, PIPE_SHADER_FRAGMENT, 0, NULL);
       ctx->base.pipe->bind_vs_state(ctx->base.pipe, NULL);
-      ctx->base.pipe->set_constant_buffer(ctx->base.pipe, PIPE_SHADER_VERTEX, 0, false, NULL);
+      ctx->base.pipe->set_constant_buffer(ctx->base.pipe, PIPE_SHADER_VERTEX, 0, NULL);
       if (ctx->has_geometry_shader) {
          ctx->base.pipe->bind_gs_state(ctx->base.pipe, NULL);
       }
@@ -1749,9 +1749,9 @@ cso_restore_state(struct cso_context *ctx, unsigned unbind)
    if (state_mask & CSO_BIT_VIEWPORT)
       cso_restore_viewport(cso);
    if (unbind & CSO_UNBIND_VS_CONSTANTS)
-      cso->base.pipe->set_constant_buffer(cso->base.pipe, PIPE_SHADER_VERTEX, 0, false, NULL);
+      cso->base.pipe->set_constant_buffer(cso->base.pipe, PIPE_SHADER_VERTEX, 0, NULL);
    if (unbind & CSO_UNBIND_FS_CONSTANTS)
-      cso->base.pipe->set_constant_buffer(cso->base.pipe, PIPE_SHADER_FRAGMENT, 0, false, NULL);
+      cso->base.pipe->set_constant_buffer(cso->base.pipe, PIPE_SHADER_FRAGMENT, 0, NULL);
    if (state_mask & CSO_BIT_VERTEX_ELEMENTS)
       cso_restore_vertex_elements(cso);
    if (state_mask & CSO_BIT_STREAM_OUTPUTS)
diff --git a/src/gallium/auxiliary/driver_ddebug/dd_context.c b/src/gallium/auxiliary/driver_ddebug/dd_context.c
index 6a5997721f9cb..da50c4b4743d9 100644
--- a/src/gallium/auxiliary/driver_ddebug/dd_context.c
+++ b/src/gallium/auxiliary/driver_ddebug/dd_context.c
@@ -360,7 +360,6 @@ DD_IMM_STATE(polygon_stipple, const struct pipe_poly_stipple, *state, state)
 static void
 dd_context_set_constant_buffer(struct pipe_context *_pipe,
                                enum pipe_shader_type shader, uint index,
-                               bool take_ownership,
                                const struct pipe_constant_buffer *constant_buffer)
 {
    struct dd_context *dctx = dd_context(_pipe);
@@ -368,7 +367,7 @@ dd_context_set_constant_buffer(struct pipe_context *_pipe,
 
    safe_memcpy(&dctx->draw_state.constant_buffers[shader][index],
                constant_buffer, sizeof(*constant_buffer));
-   pipe->set_constant_buffer(pipe, shader, index, take_ownership, constant_buffer);
+   pipe->set_constant_buffer(pipe, shader, index, constant_buffer);
 }
 
 static void
diff --git a/src/gallium/auxiliary/driver_noop/noop_state.c b/src/gallium/auxiliary/driver_noop/noop_state.c
index 0498219301dec..1f4cdc1bf8660 100644
--- a/src/gallium/auxiliary/driver_noop/noop_state.c
+++ b/src/gallium/auxiliary/driver_noop/noop_state.c
@@ -154,13 +154,8 @@ static void noop_set_framebuffer_state(struct pipe_context *ctx,
 
 static void noop_set_constant_buffer(struct pipe_context *ctx,
                                      enum pipe_shader_type shader, uint index,
-                                     bool take_ownership,
                                      const struct pipe_constant_buffer *cb)
 {
-   if (take_ownership && cb) {
-      struct pipe_resource *buf = cb->buffer;
-      pipe_resource_reference(&buf, NULL);
-   }
 }
 
 static void noop_set_inlinable_constants(struct pipe_context *ctx,
diff --git a/src/gallium/auxiliary/driver_trace/tr_context.c b/src/gallium/auxiliary/driver_trace/tr_context.c
index 4c7c8e7678712..02756c1069d85 100644
--- a/src/gallium/auxiliary/driver_trace/tr_context.c
+++ b/src/gallium/auxiliary/driver_trace/tr_context.c
@@ -942,7 +942,6 @@ trace_context_set_sample_mask(struct pipe_context *_pipe,
 static void
 trace_context_set_constant_buffer(struct pipe_context *_pipe,
                                   enum pipe_shader_type shader, uint index,
-                                  bool take_ownership,
                                   const struct pipe_constant_buffer *constant_buffer)
 {
    struct trace_context *tr_ctx = trace_context(_pipe);
@@ -953,10 +952,9 @@ trace_context_set_constant_buffer(struct pipe_context *_pipe,
    trace_dump_arg(ptr, pipe);
    trace_dump_arg_enum(pipe_shader_type, shader);
    trace_dump_arg(uint, index);
-   trace_dump_arg(bool, take_ownership);
    trace_dump_arg(constant_buffer, constant_buffer);
 
-   pipe->set_constant_buffer(pipe, shader, index, take_ownership, constant_buffer);
+   pipe->set_constant_buffer(pipe, shader, index, constant_buffer);
 
    trace_dump_call_end();
 }
diff --git a/src/gallium/auxiliary/hud/hud_context.c b/src/gallium/auxiliary/hud/hud_context.c
index 3867ee7625c10..2a2c5bef3dfc3 100644
--- a/src/gallium/auxiliary/hud/hud_context.c
+++ b/src/gallium/auxiliary/hud/hud_context.c
@@ -106,7 +106,7 @@ hud_draw_colored_prims(struct hud_context *hud, unsigned prim,
    hud->constants.translate[1] = (float) (yoffset * hud_scale);
    hud->constants.scale[0] = hud_scale;
    hud->constants.scale[1] = yscale * hud_scale;
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &hud->constbuf);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, &hud->constbuf);
 
    u_upload_data_ref(hud->pipe->stream_uploader, 0,
                  num_vertices * 2 * sizeof(float), 16, buffer,
@@ -581,7 +581,7 @@ hud_draw_results(struct hud_context *hud, struct pipe_resource *tex)
    pipe->set_sampler_views(pipe, PIPE_SHADER_FRAGMENT, 0, 1, 0,
                            &hud->font_sampler_view);
    cso_set_samplers(cso, PIPE_SHADER_FRAGMENT, 1, sampler_states);
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &hud->constbuf);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, &hud->constbuf);
 
    /* draw accumulated vertices for background quads */
    cso_set_blend(cso, &hud->alpha_blend);
@@ -597,7 +597,7 @@ hud_draw_results(struct hud_context *hud, struct pipe_resource *tex)
       hud->constants.scale[0] = hud_scale;
       hud->constants.scale[1] = hud_scale;
 
-      pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &hud->constbuf);
+      pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, &hud->constbuf);
 
       cso_set_vertex_buffers(cso, 1, &hud->bg.vbuf);
       cso_draw_arrays(cso, MESA_PRIM_QUADS, 0, hud->bg.num_vertices);
@@ -633,7 +633,7 @@ hud_draw_results(struct hud_context *hud, struct pipe_resource *tex)
    hud->constants.translate[1] = 0;
    hud->constants.scale[0] = hud_scale;
    hud->constants.scale[1] = hud_scale;
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, false, &hud->constbuf);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_VERTEX, 0, &hud->constbuf);
 
    if (hud->whitelines.num_vertices) {
       cso_set_vertex_shader_handle(cso, hud->vs_color);
diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 1c4ac345fffdc..35f607152598d 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -760,7 +760,7 @@ void util_blitter_restore_constant_buffer_state(struct blitter_context *blitter)
    struct pipe_context *pipe = blitter->pipe;
 
    pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, blitter->cb_slot,
-                             true, &blitter->saved_fs_constant_buffer);
+                             &blitter->saved_fs_constant_buffer);
    blitter->saved_fs_constant_buffer.buffer = NULL;
 }
 
@@ -1526,7 +1526,7 @@ static void util_blitter_clear_custom(struct blitter_context *blitter,
          .buffer_size = 4 * sizeof(float),
       };
       pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, blitter->cb_slot,
-                                false, &cb);
+                                &cb);
       bind_fs_clear_color(ctx, true);
    } else {
       bind_fs_empty(ctx);
@@ -2386,7 +2386,7 @@ void util_blitter_clear_render_target(struct blitter_context *blitter,
       .buffer_size = 4 * sizeof(float),
    };
    pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, blitter->cb_slot,
-                             false, &cb);
+                             &cb);
 
    num_layers = dstsurf->last_layer - dstsurf->first_layer + 1;
 
@@ -2836,7 +2836,7 @@ util_blitter_stencil_fallback(struct blitter_context *blitter,
             .buffer_size = sizeof(mask),
          };
          pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, blitter->cb_slot,
-                                 false, &cb);
+                                   &cb);
 
          pipe->bind_depth_stencil_alpha_state(pipe,
             get_stencil_blit_fallback_dsa(ctx, i));
diff --git a/src/gallium/auxiliary/util/u_inlines.h b/src/gallium/auxiliary/util/u_inlines.h
index 24eac806c71f2..3fe73ab65542e 100644
--- a/src/gallium/auxiliary/util/u_inlines.h
+++ b/src/gallium/auxiliary/util/u_inlines.h
@@ -698,9 +698,9 @@ pipe_set_constant_buffer(struct pipe_context *pipe,
       cb.buffer_offset = 0;
       cb.buffer_size = buf->width0;
       cb.user_buffer = NULL;
-      pipe->set_constant_buffer(pipe, shader, index, false, &cb);
+      pipe->set_constant_buffer(pipe, shader, index, &cb);
    } else {
-      pipe->set_constant_buffer(pipe, shader, index, false, NULL);
+      pipe->set_constant_buffer(pipe, shader, index, NULL);
    }
 }
 
@@ -770,16 +770,10 @@ util_query_clear_result(union pipe_query_result *result, unsigned type)
 
 static inline void
 util_copy_constant_buffer(struct pipe_constant_buffer *dst,
-                          const struct pipe_constant_buffer *src,
-                          bool take_ownership)
+                          const struct pipe_constant_buffer *src)
 {
    if (src) {
-      if (take_ownership) {
-         pipe_resource_reference(&dst->buffer, NULL);
-         dst->buffer = src->buffer;
-      } else {
-         pipe_resource_reference(&dst->buffer, src->buffer);
-      }
+      pipe_resource_reference(&dst->buffer, src->buffer);
       dst->buffer_offset = src->buffer_offset;
       dst->buffer_size = src->buffer_size;
       dst->user_buffer = src->user_buffer;
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index c690e3076395c..928c3cd3da082 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -1597,18 +1597,17 @@ tc_call_set_constant_buffer(struct pipe_context *pipe, void *call)
    struct tc_constant_buffer *p = (struct tc_constant_buffer *)call;
 
    if (unlikely(p->base.is_null)) {
-      pipe->set_constant_buffer(pipe, p->base.shader, p->base.index, false, NULL);
+      pipe->set_constant_buffer(pipe, p->base.shader, p->base.index, NULL);
       return call_size(tc_constant_buffer_base);
    }
 
-   pipe->set_constant_buffer(pipe, p->base.shader, p->base.index, true, &p->cb);
+   pipe->set_constant_buffer(pipe, p->base.shader, p->base.index, &p->cb);
    return call_size(tc_constant_buffer);
 }
 
 static void
 tc_set_constant_buffer(struct pipe_context *_pipe,
                        enum pipe_shader_type shader, uint index,
-                       bool take_ownership,
                        const struct pipe_constant_buffer *cb)
 {
    struct threaded_context *tc = threaded_context(_pipe);
@@ -1623,23 +1622,10 @@ tc_set_constant_buffer(struct pipe_context *_pipe,
       return;
    }
 
-   struct pipe_resource *buffer;
-   unsigned offset;
-
-   if (cb->user_buffer) {
-      /* This must be done before adding set_constant_buffer, because it could
-       * generate e.g. transfer_unmap and flush partially-uninitialized
-       * set_constant_buffer to the driver if it was done afterwards.
-       */
-      buffer = NULL;
-      u_upload_data_ref(tc->base.const_uploader, 0, cb->buffer_size,
-                    tc->ubo_alignment, cb->user_buffer, &offset, &buffer);
-      u_upload_unmap(tc->base.const_uploader);
-      take_ownership = true;
-   } else {
-      buffer = cb->buffer;
-      offset = cb->buffer_offset;
-   }
+   /* frontend must handle this */
+   assert(!cb->user_buffer);
+   struct pipe_resource *buffer = cb->buffer;
+   unsigned offset = cb->buffer_offset;
 
    struct tc_constant_buffer *p =
       tc_add_call(tc, TC_CALL_set_constant_buffer, tc_constant_buffer);
@@ -1649,11 +1635,7 @@ tc_set_constant_buffer(struct pipe_context *_pipe,
    p->cb.user_buffer = NULL;
    p->cb.buffer_offset = offset;
    p->cb.buffer_size = cb->buffer_size;
-
-   if (take_ownership)
-      p->cb.buffer = buffer;
-   else
-      tc_set_resource_reference(&p->cb.buffer, buffer);
+   p->cb.buffer = buffer;
 
    if (buffer) {
       tc_bind_buffer(&tc->const_buffers[shader][index],
diff --git a/src/gallium/auxiliary/vl/vl_bicubic_filter.c b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
index 696a850e5962c..114dabbbc38a4 100644
--- a/src/gallium/auxiliary/vl/vl_bicubic_filter.c
+++ b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
@@ -451,7 +451,7 @@ vl_bicubic_filter_render(struct vl_bicubic_filter *filter,
                                      0, 0, pipe_surface_width(dst),
                                      pipe_surface_height(dst), false);
    filter->pipe->set_constant_buffer(filter->pipe, PIPE_SHADER_FRAGMENT,
-                                     0, false, &cb);
+                                     0, &cb);
    filter->pipe->bind_rasterizer_state(filter->pipe, filter->rs_state);
    filter->pipe->bind_blend_state(filter->pipe, filter->blend);
    filter->pipe->bind_sampler_states(filter->pipe, PIPE_SHADER_FRAGMENT,
diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.c b/src/gallium/auxiliary/vl/vl_compositor_cs.c
index a98d484da39aa..71a3e10c32a3c 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.c
@@ -863,7 +863,7 @@ draw_layers(struct vl_compositor       *c,
 
          /* Unbind. */
          c->pipe->set_shader_images(c->pipe, PIPE_SHADER_COMPUTE, 0, 0, 1, NULL);
-         c->pipe->set_constant_buffer(c->pipe, PIPE_SHADER_COMPUTE, 0, false, NULL);
+         c->pipe->set_constant_buffer(c->pipe, PIPE_SHADER_COMPUTE, 0, NULL);
          c->pipe->set_sampler_views(c->pipe, PIPE_SHADER_COMPUTE, 0, 0,
                         num_sampler_views, NULL);
          c->pipe->bind_compute_state(c->pipe, NULL);
diff --git a/src/gallium/drivers/asahi/agx_blit.c b/src/gallium/drivers/asahi/agx_blit.c
index e715e0e1ce470..2eeb5fafd45c0 100644
--- a/src/gallium/drivers/asahi/agx_blit.c
+++ b/src/gallium/drivers/asahi/agx_blit.c
@@ -284,7 +284,7 @@ asahi_compute_restore(struct agx_context *ctx)
    }
 
    /* take_ownership=true so do not unreference */
-   pctx->set_constant_buffer(pctx, PIPE_SHADER_COMPUTE, 0, true,
+   pctx->set_constant_buffer(pctx, PIPE_SHADER_COMPUTE, 0,
                              &blitter->saved_cb);
    blitter->saved_cb.buffer = NULL;
 
@@ -366,7 +366,7 @@ asahi_compute_blit(struct pipe_context *ctx, const struct pipe_blit_info *info,
       .buffer_size = sizeof(data),
       .user_buffer = data,
    };
-   ctx->set_constant_buffer(ctx, PIPE_SHADER_COMPUTE, 0, false, &cb);
+   ctx->set_constant_buffer(ctx, PIPE_SHADER_COMPUTE, 0, &cb);
 
    struct pipe_image_view image = {
       .resource = dst,
@@ -448,7 +448,7 @@ asahi_compute_blit(struct pipe_context *ctx, const struct pipe_blit_info *info,
    };
    ctx->launch_grid(ctx, &grid_info);
    ctx->set_shader_images(ctx, PIPE_SHADER_COMPUTE, 0, 0, 1, NULL);
-   ctx->set_constant_buffer(ctx, PIPE_SHADER_COMPUTE, 0, false, NULL);
+   ctx->set_constant_buffer(ctx, PIPE_SHADER_COMPUTE, 0, NULL);
    ctx->set_sampler_views(ctx, PIPE_SHADER_COMPUTE, 0, 0, 1, NULL);
 
    asahi_compute_restore(agx_context(ctx));
diff --git a/src/gallium/drivers/asahi/agx_state.c b/src/gallium/drivers/asahi/agx_state.c
index aa0a6102ff7cf..683dd8f626da1 100644
--- a/src/gallium/drivers/asahi/agx_state.c
+++ b/src/gallium/drivers/asahi/agx_state.c
@@ -1301,14 +1301,14 @@ agx_batch_upload_pbe(struct agx_batch *batch, struct agx_pbe_packed *out,
 
 static void
 agx_set_constant_buffer(struct pipe_context *pctx, enum pipe_shader_type shader,
-                        uint index, bool take_ownership,
+                        uint index,
                         const struct pipe_constant_buffer *cb)
 {
    struct agx_context *ctx = agx_context(pctx);
    struct agx_stage *s = &ctx->stage[shader];
    struct pipe_constant_buffer *constants = &s->cb[index];
 
-   util_copy_constant_buffer(&s->cb[index], cb, take_ownership);
+   util_copy_constant_buffer(&s->cb[index], cb);
 
    /* Upload user buffer immediately */
    if (constants->user_buffer && !constants->buffer) {
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index ab5cd72aa6ded..b04f5c4a54ea7 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -3466,7 +3466,6 @@ crocus_set_framebuffer_state(struct pipe_context *ctx,
 static void
 crocus_set_constant_buffer(struct pipe_context *ctx,
                            enum pipe_shader_type p_stage, unsigned index,
-                           bool take_ownership,
                            const struct pipe_constant_buffer *input)
 {
    struct crocus_context *ice = (struct crocus_context *) ctx;
@@ -3474,7 +3473,7 @@ crocus_set_constant_buffer(struct pipe_context *ctx,
    struct crocus_shader_state *shs = &ice->state.shaders[stage];
    struct pipe_constant_buffer *cbuf = &shs->constbufs[index];
 
-   util_copy_constant_buffer(&shs->constbufs[index], input, take_ownership);
+   util_copy_constant_buffer(&shs->constbufs[index], input);
 
    if (input && input->buffer_size && (input->buffer || input->user_buffer)) {
       shs->bound_cbufs |= 1u << index;
@@ -3487,7 +3486,7 @@ crocus_set_constant_buffer(struct pipe_context *ctx,
 
          if (!cbuf->buffer) {
             /* Allocation was unsuccessful - just unbind */
-            crocus_set_constant_buffer(ctx, p_stage, index, false, NULL);
+            crocus_set_constant_buffer(ctx, p_stage, index, NULL);
             return;
          }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp b/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp
index 049aefe45baaf..56f1c5bf1dcd4 100644
--- a/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp
@@ -505,7 +505,7 @@ d3d12_restore_compute_transform_state(struct d3d12_context *ctx, d3d12_compute_t
 
    ctx->base.bind_compute_state(&ctx->base, save->cs);
 
-   ctx->base.set_constant_buffer(&ctx->base, PIPE_SHADER_COMPUTE, 1, true, &save->cbuf0);
+   ctx->base.set_constant_buffer(&ctx->base, PIPE_SHADER_COMPUTE, 1, &save->cbuf0);
    ctx->base.set_shader_buffers(&ctx->base, PIPE_SHADER_COMPUTE, 0, ARRAY_SIZE(save->ssbos), save->ssbos, (1u << ARRAY_SIZE(save->ssbos)) - 1);
 
    if (ctx->current_predication)
diff --git a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
index c0685d3dfc1cc..e39c14ee8e7a4 100644
--- a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
@@ -1367,7 +1367,6 @@ d3d12_increment_constant_buffer_bind_count(struct d3d12_context *ctx,
 static void
 d3d12_set_constant_buffer(struct pipe_context *pctx,
                           enum pipe_shader_type shader, uint index,
-                          bool take_ownership,
                           const struct pipe_constant_buffer *buf)
 {
    struct d3d12_context *ctx = d3d12_context(pctx);
@@ -1388,12 +1387,7 @@ d3d12_set_constant_buffer(struct pipe_context *pctx,
          if (buffer)
             d3d12_increment_constant_buffer_bind_count(ctx, shader, d3d12_resource(buffer));
 
-         if (take_ownership) {
-            pipe_resource_reference(&ctx->cbufs[shader][index].buffer, NULL);
-            ctx->cbufs[shader][index].buffer = buffer;
-         } else {
-            pipe_resource_reference(&ctx->cbufs[shader][index].buffer, buffer);
-         }
+         pipe_resource_reference(&ctx->cbufs[shader][index].buffer, buffer);
       }
 
       ctx->cbufs[shader][index].buffer_offset = offset;
@@ -1881,7 +1875,7 @@ d3d12_disable_fake_so_buffers(struct d3d12_context *ctx)
       cbuf.buffer = fake_target->fill_buffer;
       cbuf.buffer_offset = fake_target->fill_buffer_offset;
       cbuf.buffer_size = fake_target->fill_buffer->width0 - cbuf.buffer_offset;
-      ctx->base.set_constant_buffer(&ctx->base, PIPE_SHADER_COMPUTE, 1, false, &cbuf);
+      ctx->base.set_constant_buffer(&ctx->base, PIPE_SHADER_COMPUTE, 1, &cbuf);
 
       grid.indirect = fake_target->fill_buffer;
       grid.indirect_offset = fake_target->fill_buffer_offset + 4;
diff --git a/src/gallium/drivers/d3d12/d3d12_draw.cpp b/src/gallium/drivers/d3d12/d3d12_draw.cpp
index 148dae3c5a7b4..81b1fa54da805 100644
--- a/src/gallium/drivers/d3d12/d3d12_draw.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_draw.cpp
@@ -795,7 +795,7 @@ update_draw_indirect_with_sysvals(struct d3d12_context *ctx,
       draw_count_cbuf.buffer_offset = indirect_in->indirect_draw_count_offset;
       draw_count_cbuf.buffer_size = 4;
       draw_count_cbuf.user_buffer = nullptr;
-      ctx->base.set_constant_buffer(&ctx->base, PIPE_SHADER_COMPUTE, 1, false, &draw_count_cbuf);
+      ctx->base.set_constant_buffer(&ctx->base, PIPE_SHADER_COMPUTE, 1, &draw_count_cbuf);
    }
    
    pipe_shader_buffer new_cs_ssbos[2];
diff --git a/src/gallium/drivers/etnaviv/etnaviv_state.c b/src/gallium/drivers/etnaviv/etnaviv_state.c
index 2caa4181d70c6..f73a48cf81955 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_state.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_state.c
@@ -78,7 +78,7 @@ etna_set_sample_mask(struct pipe_context *pctx, unsigned sample_mask)
 
 static void
 etna_set_constant_buffer(struct pipe_context *pctx,
-      enum pipe_shader_type shader, uint index, bool take_ownership,
+      enum pipe_shader_type shader, uint index,
       const struct pipe_constant_buffer *cb)
 {
    struct etna_context *ctx = etna_context(pctx);
@@ -86,7 +86,7 @@ etna_set_constant_buffer(struct pipe_context *pctx,
 
    assert(index < ETNA_MAX_CONST_BUF);
 
-   util_copy_constant_buffer(&so->cb[index], cb, take_ownership);
+   util_copy_constant_buffer(&so->cb[index], cb);
 
    /* Note that the gallium frontends can unbind constant buffers by
     * passing NULL here. */
diff --git a/src/gallium/drivers/freedreno/freedreno_blitter.c b/src/gallium/drivers/freedreno/freedreno_blitter.c
index 1aba5ed13a1e7..e1a30beacbaeb 100644
--- a/src/gallium/drivers/freedreno/freedreno_blitter.c
+++ b/src/gallium/drivers/freedreno/freedreno_blitter.c
@@ -292,7 +292,7 @@ fd_blitter_clear(struct pipe_context *pctx, unsigned buffers,
       .buffer_size = 16,
       .user_buffer = &color->ui,
    };
-   pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0, false, &cb);
+   pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0, &cb);
 
    unsigned rs_idx = pfb->samples > 1 ? 1 : 0;
    if (!ctx->clear_rs_state[rs_idx]) {
diff --git a/src/gallium/drivers/freedreno/freedreno_state.c b/src/gallium/drivers/freedreno/freedreno_state.c
index d762c09e6067b..3e32731c47d66 100644
--- a/src/gallium/drivers/freedreno/freedreno_state.c
+++ b/src/gallium/drivers/freedreno/freedreno_state.c
@@ -125,13 +125,13 @@ upload_user_buffer(struct pipe_context *pctx, struct pipe_constant_buffer *cb)
  */
 static void
 fd_set_constant_buffer(struct pipe_context *pctx, enum pipe_shader_type shader,
-                       uint index, bool take_ownership,
+                       uint index,
                        const struct pipe_constant_buffer *cb) in_dt
 {
    struct fd_context *ctx = fd_context(pctx);
    struct fd_constbuf_stateobj *so = &ctx->constbuf[shader];
 
-   util_copy_constant_buffer(&so->cb[index], cb, take_ownership);
+   util_copy_constant_buffer(&so->cb[index], cb);
 
    /* Note that gallium frontends can unbind constant buffers by
     * passing a NULL cb, or a cb with no buffer:
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 56bcb106e3027..94973a33eacc8 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -718,7 +718,6 @@ i915_delete_vs_state(struct pipe_context *pipe, void *shader)
 static void
 i915_set_constant_buffer(struct pipe_context *pipe,
                          enum pipe_shader_type shader, uint32_t index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb)
 {
    struct i915_context *i915 = i915_context(pipe);
@@ -760,12 +759,7 @@ i915_set_constant_buffer(struct pipe_context *pipe,
       diff = i915->current.num_user_constants[shader] != 0;
    }
 
-   if (take_ownership) {
-      pipe_resource_reference(&i915->constants[shader], NULL);
-      i915->constants[shader] = buf;
-   } else {
-      pipe_resource_reference(&i915->constants[shader], buf);
-   }
+   pipe_resource_reference(&i915->constants[shader], buf);
    i915->current.num_user_constants[shader] = new_num;
 
    if (diff)
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index 95310bac617b2..5399005c07446 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -3950,7 +3950,6 @@ iris_set_framebuffer_state(struct pipe_context *ctx,
 static void
 iris_set_constant_buffer(struct pipe_context *ctx,
                          enum pipe_shader_type p_stage, unsigned index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *input)
 {
    struct iris_context *ice = (struct iris_context *) ctx;
@@ -3972,7 +3971,7 @@ iris_set_constant_buffer(struct pipe_context *ctx,
 
          if (!cbuf->buffer) {
             /* Allocation was unsuccessful - just unbind */
-            iris_set_constant_buffer(ctx, p_stage, index, false, NULL);
+            iris_set_constant_buffer(ctx, p_stage, index, NULL);
             return;
          }
 
@@ -3985,12 +3984,7 @@ iris_set_constant_buffer(struct pipe_context *ctx,
             shs->dirty_cbufs |= 1u << index;
          }
 
-         if (take_ownership) {
-            pipe_resource_reference(&cbuf->buffer, NULL);
-            cbuf->buffer = input->buffer;
-         } else {
-            pipe_resource_reference(&cbuf->buffer, input->buffer);
-         }
+         pipe_resource_reference(&cbuf->buffer, input->buffer);
 
          cbuf->buffer_offset = input->buffer_offset;
       }
diff --git a/src/gallium/drivers/lima/lima_state.c b/src/gallium/drivers/lima/lima_state.c
index fd0e182199cfb..de4c5171ef736 100644
--- a/src/gallium/drivers/lima/lima_state.c
+++ b/src/gallium/drivers/lima/lima_state.c
@@ -264,7 +264,6 @@ lima_set_stencil_ref(struct pipe_context *pctx,
 static void
 lima_set_constant_buffer(struct pipe_context *pctx,
                          enum pipe_shader_type shader, uint index,
-                         bool pass_reference,
                          const struct pipe_constant_buffer *cb)
 {
    struct lima_context *ctx = lima_context(pctx);
diff --git a/src/gallium/drivers/llvmpipe/lp_setup.c b/src/gallium/drivers/llvmpipe/lp_setup.c
index 4a68aeb03db20..2f90bc1b48401 100644
--- a/src/gallium/drivers/llvmpipe/lp_setup.c
+++ b/src/gallium/drivers/llvmpipe/lp_setup.c
@@ -639,10 +639,10 @@ lp_setup_set_fs_constants(struct lp_setup_context *setup,
    unsigned i;
    for (i = 0; i < num; ++i) {
       util_copy_constant_buffer(&setup->constants[i].current,
-                                &buffers[i], false);
+                                &buffers[i]);
    }
    for (; i < ARRAY_SIZE(setup->constants); i++) {
-      util_copy_constant_buffer(&setup->constants[i].current, NULL, false);
+      util_copy_constant_buffer(&setup->constants[i].current, NULL);
    }
    setup->dirty |= LP_SETUP_NEW_CONSTANTS;
 }
diff --git a/src/gallium/drivers/llvmpipe/lp_state_cs.c b/src/gallium/drivers/llvmpipe/lp_state_cs.c
index 2f9ef5b7da213..487a2d32b7757 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_cs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_cs.c
@@ -1545,10 +1545,10 @@ lp_csctx_set_cs_constants(struct lp_cs_context *csctx,
    assert(num <= ARRAY_SIZE(csctx->constants));
 
    for (i = 0; i < num; ++i) {
-      util_copy_constant_buffer(&csctx->constants[i].current, &buffers[i], false);
+      util_copy_constant_buffer(&csctx->constants[i].current, &buffers[i]);
    }
    for (; i < ARRAY_SIZE(csctx->constants); i++) {
-      util_copy_constant_buffer(&csctx->constants[i].current, NULL, false);
+      util_copy_constant_buffer(&csctx->constants[i].current, NULL);
    }
 }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 2bca60e3c3bc9..5865839eb64bc 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -4213,7 +4213,6 @@ llvmpipe_delete_fs_state(struct pipe_context *pipe, void *fs)
 static void
 llvmpipe_set_constant_buffer(struct pipe_context *pipe,
                              enum pipe_shader_type shader, uint index,
-                             bool take_ownership,
                              const struct pipe_constant_buffer *cb)
 {
    struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
@@ -4223,8 +4222,7 @@ llvmpipe_set_constant_buffer(struct pipe_context *pipe,
    assert(index < ARRAY_SIZE(llvmpipe->constants[shader]));
 
    /* note: reference counting */
-   util_copy_constant_buffer(&llvmpipe->constants[shader][index], cb,
-                             take_ownership);
+   util_copy_constant_buffer(&llvmpipe->constants[shader][index], cb);
 
    /* user_buffer is only valid until the next set_constant_buffer (at most,
     * possibly until shader deletion), so we need to upload it now to make
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_state.c b/src/gallium/drivers/nouveau/nv30/nv30_state.c
index 7350d1efa3f19..c72c0da1ebe9c 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_state.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_state.c
@@ -328,7 +328,6 @@ nv30_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
 static void
 nv30_set_constant_buffer(struct pipe_context *pipe,
                          enum pipe_shader_type shader, uint index,
-                         bool pass_reference,
                          const struct pipe_constant_buffer *cb)
 {
    struct nv30_context *nv30 = nv30_context(pipe);
@@ -346,22 +345,12 @@ nv30_set_constant_buffer(struct pipe_context *pipe,
       size = buf->width0 / (4 * sizeof(float));
 
    if (shader == PIPE_SHADER_VERTEX) {
-      if (pass_reference) {
-         pipe_resource_reference(&nv30->vertprog.constbuf, NULL);
-         nv30->vertprog.constbuf = buf;
-      } else {
-         pipe_resource_reference(&nv30->vertprog.constbuf, buf);
-      }
+      pipe_resource_reference(&nv30->vertprog.constbuf, buf);
       nv30->vertprog.constbuf_nr = size;
       nv30->dirty |= NV30_NEW_VERTCONST;
    } else
    if (shader == PIPE_SHADER_FRAGMENT) {
-      if (pass_reference) {
-         pipe_resource_reference(&nv30->fragprog.constbuf, NULL);
-         nv30->fragprog.constbuf = buf;
-      } else {
-         pipe_resource_reference(&nv30->fragprog.constbuf, buf);
-      }
+      pipe_resource_reference(&nv30->fragprog.constbuf, buf);
       nv30->fragprog.constbuf_nr = size;
       nv30->dirty |= NV30_NEW_FRAGCONST;
    }
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 929a6ad76f6f1..5158be9b276fe 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -885,7 +885,6 @@ nv50_get_compute_state_info(struct pipe_context *pipe, void *hwcso,
 static void
 nv50_set_constant_buffer(struct pipe_context *pipe,
                          enum pipe_shader_type shader, uint index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb)
 {
    struct nv50_context *nv50 = nv50_context(pipe);
@@ -915,12 +914,7 @@ nv50_set_constant_buffer(struct pipe_context *pipe,
    if (nv50->constbuf[s][i].u.buf)
       nv04_resource(nv50->constbuf[s][i].u.buf)->cb_bindings[s] &= ~(1 << i);
 
-   if (take_ownership) {
-      pipe_resource_reference(&nv50->constbuf[s][i].u.buf, NULL);
-      nv50->constbuf[s][i].u.buf = res;
-   } else {
-      pipe_resource_reference(&nv50->constbuf[s][i].u.buf, res);
-   }
+   pipe_resource_reference(&nv50->constbuf[s][i].u.buf, res);
 
    nv50->constbuf[s][i].user = (cb && cb->user_buffer) ? true : false;
    if (nv50->constbuf[s][i].user) {
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index 7224de4a25e58..2e04b3c30b57c 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -789,7 +789,6 @@ nvc0_get_compute_state_info(struct pipe_context *pipe, void *hwcso,
 static void
 nvc0_set_constant_buffer(struct pipe_context *pipe,
                          enum pipe_shader_type shader, uint index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb)
 {
    struct nvc0_context *nvc0 = nvc0_context(pipe);
@@ -819,12 +818,7 @@ nvc0_set_constant_buffer(struct pipe_context *pipe,
    if (nvc0->constbuf[s][i].u.buf)
       nv04_resource(nvc0->constbuf[s][i].u.buf)->cb_bindings[s] &= ~(1 << i);
 
-   if (take_ownership) {
-      pipe_resource_reference(&nvc0->constbuf[s][i].u.buf, NULL);
-      nvc0->constbuf[s][i].u.buf = res;
-   } else {
-      pipe_resource_reference(&nvc0->constbuf[s][i].u.buf, res);
-   }
+   pipe_resource_reference(&nvc0->constbuf[s][i].u.buf, res);
 
    nvc0->constbuf[s][i].user = (cb && cb->user_buffer) ? true : false;
    if (nvc0->constbuf[s][i].user) {
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 76c22c02bedc9..d77c3fcd56b30 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -3585,15 +3585,15 @@ panfrost_launch_afbc_conv_shader(struct panfrost_batch *batch, void *cso,
    struct panfrost_constant_buffer *pbuf =
       &batch->ctx->constant_buffer[PIPE_SHADER_COMPUTE];
    saved_cso = batch->ctx->uncompiled[PIPE_SHADER_COMPUTE];
-   util_copy_constant_buffer(&pbuf->cb[0], &saved_const, true);
+   util_copy_constant_buffer(&pbuf->cb[0], &saved_const);
 
    pctx->bind_compute_state(pctx, cso);
-   pctx->set_constant_buffer(pctx, PIPE_SHADER_COMPUTE, 0, false, cbuf);
+   pctx->set_constant_buffer(pctx, PIPE_SHADER_COMPUTE, 0, cbuf);
 
    panfrost_launch_grid_on_batch(pctx, batch, &grid);
 
    pctx->bind_compute_state(pctx, saved_cso);
-   pctx->set_constant_buffer(pctx, PIPE_SHADER_COMPUTE, 0, true, &saved_const);
+   pctx->set_constant_buffer(pctx, PIPE_SHADER_COMPUTE, 0, &saved_const);
 }
 
 #define LAUNCH_AFBC_CONV_SHADER(name, batch, rsrc, consts, nr_blocks)          \
@@ -3792,15 +3792,15 @@ panfrost_mtk_detile_compute(struct panfrost_context *ctx, struct pipe_blit_info
       &batch->ctx->constant_buffer[PIPE_SHADER_COMPUTE];
    void *saved_cso = batch->ctx->uncompiled[PIPE_SHADER_COMPUTE];
    void *cso = shader->mtk_tiled.detile_cso;
-   util_copy_constant_buffer(&pbuf->cb[0], &saved_const, true);
+   util_copy_constant_buffer(&pbuf->cb[0], &saved_const);
 
    pipe->bind_compute_state(pipe, cso);
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, false, &cbuf);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, &cbuf);
 
    panfrost_launch_grid_on_batch(pipe, batch, &grid_info);
 
    pipe->bind_compute_state(pipe, saved_cso);
-   pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, true, &saved_const);
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, &saved_const);
 
    panfrost_resource_restore_format(pan_resource(y_src), &y_src_save);
    panfrost_resource_restore_format(pan_resource(uv_src), &uv_src_save);
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 813bb1538e7f7..2c646c6af01a2 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -346,13 +346,12 @@ panfrost_set_vertex_buffers(struct pipe_context *pctx, unsigned num_buffers,
 static void
 panfrost_set_constant_buffer(struct pipe_context *pctx,
                              enum pipe_shader_type shader, uint index,
-                             bool take_ownership,
                              const struct pipe_constant_buffer *buf)
 {
    struct panfrost_context *ctx = pan_context(pctx);
    struct panfrost_constant_buffer *pbuf = &ctx->constant_buffer[shader];
 
-   util_copy_constant_buffer(&pbuf->cb[index], buf, take_ownership);
+   util_copy_constant_buffer(&pbuf->cb[index], buf);
 
    unsigned mask = (1 << index);
 
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index 052e1f1ccce2a..057c1e3afec25 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -2063,7 +2063,6 @@ static void r300_delete_vs_state(struct pipe_context* pipe, void* shader)
 
 static void r300_set_constant_buffer(struct pipe_context *pipe,
                                      enum pipe_shader_type shader, uint index,
-                                     bool take_ownership,
                                      const struct pipe_constant_buffer *cb)
 {
     struct r300_context* r300 = r300_context(pipe);
diff --git a/src/gallium/drivers/r600/evergreen_compute.c b/src/gallium/drivers/r600/evergreen_compute.c
index 3b3fa88bee07d..eb647755037b8 100644
--- a/src/gallium/drivers/r600/evergreen_compute.c
+++ b/src/gallium/drivers/r600/evergreen_compute.c
@@ -150,7 +150,7 @@ static void evergreen_cs_set_constant_buffer(struct r600_context *rctx,
 	cb.buffer = buffer;
 	cb.user_buffer = NULL;
 
-	rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_COMPUTE, cb_index, false, &cb);
+	rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_COMPUTE, cb_index, &cb);
 }
 
 /* We need to define these R600 registers here, because we can't include
diff --git a/src/gallium/drivers/r600/evergreen_state.c b/src/gallium/drivers/r600/evergreen_state.c
index aed8af97bc517..dd506a3b868b2 100644
--- a/src/gallium/drivers/r600/evergreen_state.c
+++ b/src/gallium/drivers/r600/evergreen_state.c
@@ -4820,17 +4820,17 @@ void evergreen_setup_tess_constants(struct r600_context *rctx,
 
 		if (unlikely(vertexid))
 			rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_VERTEX,
-						      R600_LDS_INFO_CONST_BUFFER, false,
+						      R600_LDS_INFO_CONST_BUFFER,
 						      &rctx->lds_constbuf_pipe);
 		else
 			rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_VERTEX,
-						      R600_LDS_INFO_CONST_BUFFER, false,
+						      R600_LDS_INFO_CONST_BUFFER,
 						      NULL);
 
 		rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_TESS_CTRL,
-					      R600_LDS_INFO_CONST_BUFFER, false, NULL);
+					      R600_LDS_INFO_CONST_BUFFER, NULL);
 		rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_TESS_EVAL,
-					      R600_LDS_INFO_CONST_BUFFER, false, NULL);
+					      R600_LDS_INFO_CONST_BUFFER, NULL);
 		return;
 	}
 
@@ -4887,13 +4887,13 @@ void evergreen_setup_tess_constants(struct r600_context *rctx,
 	rctx->last_num_tcs_input_cp = num_tcs_input_cp;
 
 	rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_VERTEX,
-				      R600_LDS_INFO_CONST_BUFFER, false,
+				      R600_LDS_INFO_CONST_BUFFER,
 				      &rctx->lds_constbuf_pipe);
 	rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_TESS_CTRL,
-				      R600_LDS_INFO_CONST_BUFFER, false,
+				      R600_LDS_INFO_CONST_BUFFER,
 				      &rctx->lds_constbuf_pipe);
 	rctx->b.b.set_constant_buffer(&rctx->b.b, PIPE_SHADER_TESS_EVAL,
-				      R600_LDS_INFO_CONST_BUFFER, true,
+				      R600_LDS_INFO_CONST_BUFFER,
 				      &rctx->lds_constbuf_pipe);
 }
 
diff --git a/src/gallium/drivers/r600/r600_pipe.c b/src/gallium/drivers/r600/r600_pipe.c
index 926bf1f315003..6ec975cc387b2 100644
--- a/src/gallium/drivers/r600/r600_pipe.c
+++ b/src/gallium/drivers/r600/r600_pipe.c
@@ -53,7 +53,7 @@ static void r600_destroy_context(struct pipe_context *context)
 	if (rctx->append_fence)
 		pipe_resource_reference((struct pipe_resource**)&rctx->append_fence, NULL);
 	for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
-		rctx->b.b.set_constant_buffer(&rctx->b.b, sh, R600_BUFFER_INFO_CONST_BUFFER, false, NULL);
+		rctx->b.b.set_constant_buffer(&rctx->b.b, sh, R600_BUFFER_INFO_CONST_BUFFER, NULL);
 		free(rctx->driver_consts[sh].constants);
 	}
 
@@ -86,7 +86,7 @@ static void r600_destroy_context(struct pipe_context *context)
 
 	for (sh = 0; sh < PIPE_SHADER_TYPES; ++sh)
 		for (i = 0; i < PIPE_MAX_CONSTANT_BUFFERS; ++i)
-			rctx->b.b.set_constant_buffer(context, sh, i, false, NULL);
+			rctx->b.b.set_constant_buffer(context, sh, i, NULL);
 
 	if (rctx->blitter) {
 		util_blitter_destroy(rctx->blitter);
diff --git a/src/gallium/drivers/r600/r600_query.c b/src/gallium/drivers/r600/r600_query.c
index 2840665d7cd2d..8257cc8d72306 100644
--- a/src/gallium/drivers/r600/r600_query.c
+++ b/src/gallium/drivers/r600/r600_query.c
@@ -1579,7 +1579,7 @@ static void r600_restore_qbo_state(struct r600_common_context *rctx,
 				   struct r600_qbo_state *st)
 {
 	rctx->b.bind_compute_state(&rctx->b, st->saved_compute);
-	rctx->b.set_constant_buffer(&rctx->b, PIPE_SHADER_COMPUTE, 0, true, &st->saved_const0);
+	rctx->b.set_constant_buffer(&rctx->b, PIPE_SHADER_COMPUTE, 0, &st->saved_const0);
 	rctx->b.set_shader_buffers(&rctx->b, PIPE_SHADER_COMPUTE, 0, 3, st->saved_ssbo, ~0);
 	for (unsigned i = 0; i < 3; ++i)
 		pipe_resource_reference(&st->saved_ssbo[i].buffer, NULL);
@@ -1712,7 +1712,7 @@ static void r600_query_hw_get_result_resource(struct r600_common_context *rctx,
 		} else
 			consts.buffer_offset = 0;
 
-		rctx->b.set_constant_buffer(&rctx->b, PIPE_SHADER_COMPUTE, 0, false, &constant_buffer);
+		rctx->b.set_constant_buffer(&rctx->b, PIPE_SHADER_COMPUTE, 0, &constant_buffer);
 
 		rctx->b.set_shader_buffers(&rctx->b, PIPE_SHADER_COMPUTE, 0, 3, ssbo, ~0);
 
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index f15ec348af30d..51716a3b82172 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -1240,7 +1240,6 @@ void r600_constant_buffers_dirty(struct r600_context *rctx, struct r600_constbuf
 
 static void r600_set_constant_buffer(struct pipe_context *ctx,
 				     enum pipe_shader_type shader, uint index,
-				     bool take_ownership,
 				     const struct pipe_constant_buffer *input)
 {
 	struct r600_context *rctx = (struct r600_context *)ctx;
@@ -1291,12 +1290,7 @@ static void r600_set_constant_buffer(struct pipe_context *ctx,
 	} else {
 		/* Setup the hw buffer. */
 		cb->buffer_offset = input->buffer_offset;
-		if (take_ownership) {
-			pipe_resource_reference(&cb->buffer, NULL);
-			cb->buffer = input->buffer;
-		} else {
-			pipe_resource_reference(&cb->buffer, input->buffer);
-		}
+		pipe_resource_reference(&cb->buffer, input->buffer);
 		r600_context_add_resource_size(ctx, input->buffer);
 	}
 
@@ -1410,7 +1404,7 @@ void r600_update_driver_const_buffers(struct r600_context *rctx, bool compute_on
 		cb.user_buffer = ptr;
 		cb.buffer_offset = 0;
 		cb.buffer_size = size;
-		rctx->b.b.set_constant_buffer(&rctx->b.b, sh, R600_BUFFER_INFO_CONST_BUFFER, false, &cb);
+		rctx->b.b.set_constant_buffer(&rctx->b.b, sh, R600_BUFFER_INFO_CONST_BUFFER, &cb);
 		pipe_resource_reference(&cb.buffer, NULL);
 	}
 }
@@ -1599,21 +1593,21 @@ static void update_gs_block_state(struct r600_context *rctx, unsigned enable)
 
 		if (enable) {
 			r600_set_constant_buffer(&rctx->b.b, PIPE_SHADER_GEOMETRY,
-					R600_GS_RING_CONST_BUFFER, false, &rctx->gs_rings.esgs_ring);
+					R600_GS_RING_CONST_BUFFER, &rctx->gs_rings.esgs_ring);
 			if (rctx->tes_shader) {
 				r600_set_constant_buffer(&rctx->b.b, PIPE_SHADER_TESS_EVAL,
-							 R600_GS_RING_CONST_BUFFER, false, &rctx->gs_rings.gsvs_ring);
+							 R600_GS_RING_CONST_BUFFER, &rctx->gs_rings.gsvs_ring);
 			} else {
 				r600_set_constant_buffer(&rctx->b.b, PIPE_SHADER_VERTEX,
-							 R600_GS_RING_CONST_BUFFER, false, &rctx->gs_rings.gsvs_ring);
+							 R600_GS_RING_CONST_BUFFER, &rctx->gs_rings.gsvs_ring);
 			}
 		} else {
 			r600_set_constant_buffer(&rctx->b.b, PIPE_SHADER_GEOMETRY,
-					R600_GS_RING_CONST_BUFFER, false, NULL);
+					R600_GS_RING_CONST_BUFFER, NULL);
 			r600_set_constant_buffer(&rctx->b.b, PIPE_SHADER_VERTEX,
-					R600_GS_RING_CONST_BUFFER, false, NULL);
+					R600_GS_RING_CONST_BUFFER, NULL);
 			r600_set_constant_buffer(&rctx->b.b, PIPE_SHADER_TESS_EVAL,
-					R600_GS_RING_CONST_BUFFER, false, NULL);
+					R600_GS_RING_CONST_BUFFER, NULL);
 		}
 	}
 }
diff --git a/src/gallium/drivers/radeonsi/gfx11_query.c b/src/gallium/drivers/radeonsi/gfx11_query.c
index 0e9ce841b68da..5e21cff653469 100644
--- a/src/gallium/drivers/radeonsi/gfx11_query.c
+++ b/src/gallium/drivers/radeonsi/gfx11_query.c
@@ -374,7 +374,7 @@ static void gfx11_sh_query_get_result_resource(struct si_context *sctx, struct s
          ssbo[2].buffer_size = is_result_64bit ? 8 : 4;
       }
 
-      sctx->b.set_constant_buffer(&sctx->b, PIPE_SHADER_COMPUTE, 0, false, &constant_buffer);
+      sctx->b.set_constant_buffer(&sctx->b, PIPE_SHADER_COMPUTE, 0, &constant_buffer);
 
       if (flags & PIPE_QUERY_WAIT) {
          uint64_t va;
diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index 982dcf6ffc26d..fcd2820d1fa69 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -1124,7 +1124,7 @@ static void si_upload_const_buffer(struct si_context *sctx, struct si_resource *
 }
 
 static void si_set_constant_buffer(struct si_context *sctx, struct si_buffer_resources *buffers,
-                                   unsigned descriptors_idx, uint slot, bool take_ownership,
+                                   unsigned descriptors_idx, uint slot,
                                    const struct pipe_constant_buffer *input)
 {
    struct si_descriptors *descs = &sctx->descriptors[descriptors_idx];
@@ -1146,15 +1146,11 @@ static void si_set_constant_buffer(struct si_context *sctx, struct si_buffer_res
                                 input->buffer_size, &buffer_offset);
          if (!buffer) {
             /* Just unbind on failure. */
-            si_set_constant_buffer(sctx, buffers, descriptors_idx, slot, false, NULL);
+            si_set_constant_buffer(sctx, buffers, descriptors_idx, slot, NULL);
             return;
          }
       } else {
-         if (take_ownership) {
-            buffer = input->buffer;
-         } else {
-            pipe_resource_reference(&buffer, input->buffer);
-         }
+         pipe_resource_reference(&buffer, input->buffer);
          buffer_offset = input->buffer_offset;
       }
 
@@ -1212,7 +1208,7 @@ void si_invalidate_inlinable_uniforms(struct si_context *sctx, enum pipe_shader_
 }
 
 static void si_pipe_set_constant_buffer(struct pipe_context *ctx, enum pipe_shader_type shader,
-                                        uint slot, bool take_ownership,
+                                        uint slot,
                                         const struct pipe_constant_buffer *input)
 {
    struct si_context *sctx = (struct si_context *)ctx;
@@ -1237,7 +1233,7 @@ static void si_pipe_set_constant_buffer(struct pipe_context *ctx, enum pipe_shad
    slot = si_get_constbuf_slot(slot);
    si_set_constant_buffer(sctx, &sctx->const_and_shader_buffers[shader],
                           si_const_and_shader_buffer_descriptors_idx(shader), slot,
-                          take_ownership, input);
+                          input);
 }
 
 static void si_set_inlinable_constants(struct pipe_context *ctx,
@@ -1390,7 +1386,7 @@ void si_get_shader_buffers(struct si_context *sctx, enum pipe_shader_type shader
 void si_set_internal_const_buffer(struct si_context *sctx, uint slot,
                                   const struct pipe_constant_buffer *input)
 {
-   si_set_constant_buffer(sctx, &sctx->internal_bindings, SI_DESCS_INTERNAL, slot, false, input);
+   si_set_constant_buffer(sctx, &sctx->internal_bindings, SI_DESCS_INTERNAL, slot, input);
 }
 
 void si_set_internal_shader_buffer(struct si_context *sctx, uint slot,
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index a6f75f74a8016..bc10885da3db9 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -762,7 +762,7 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
       unsigned start_shader = sctx->is_gfx_queue ? 0 : PIPE_SHADER_COMPUTE;
       for (shader = start_shader; shader < SI_NUM_SHADERS; shader++) {
          for (i = 0; i < SI_NUM_CONST_BUFFERS; i++) {
-            sctx->b.set_constant_buffer(&sctx->b, shader, i, false, &sctx->null_const_buf);
+            sctx->b.set_constant_buffer(&sctx->b, shader, i, &sctx->null_const_buf);
          }
       }
 
diff --git a/src/gallium/drivers/radeonsi/si_query.c b/src/gallium/drivers/radeonsi/si_query.c
index 78bc8daa31ab1..1ab69b2da200b 100644
--- a/src/gallium/drivers/radeonsi/si_query.c
+++ b/src/gallium/drivers/radeonsi/si_query.c
@@ -1619,7 +1619,7 @@ static void si_query_hw_get_result_resource(struct si_context *sctx, struct si_q
          params.start_offset += qbuf->results_end - query->result_size;
       }
 
-      sctx->b.set_constant_buffer(&sctx->b, PIPE_SHADER_COMPUTE, 0, false, &constant_buffer);
+      sctx->b.set_constant_buffer(&sctx->b, PIPE_SHADER_COMPUTE, 0, &constant_buffer);
 
       ssbo[0].buffer = &qbuf->buf->b.b;
       ssbo[0].buffer_offset = params.start_offset;
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 18b6baa83709b..4b9ca99bea2cb 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -1841,7 +1841,7 @@ void si_save_qbo_state(struct si_context *sctx, struct si_qbo_state *st)
 
 void si_restore_qbo_state(struct si_context *sctx, struct si_qbo_state *st)
 {
-   sctx->b.set_constant_buffer(&sctx->b, PIPE_SHADER_COMPUTE, 0, true, &st->saved_const0);
+   sctx->b.set_constant_buffer(&sctx->b, PIPE_SHADER_COMPUTE, 0, &st->saved_const0);
 }
 
 static void si_emit_db_render_state(struct si_context *sctx, unsigned index)
diff --git a/src/gallium/drivers/softpipe/sp_state_shader.c b/src/gallium/drivers/softpipe/sp_state_shader.c
index a2ff6af112525..52b749462c32f 100644
--- a/src/gallium/drivers/softpipe/sp_state_shader.c
+++ b/src/gallium/drivers/softpipe/sp_state_shader.c
@@ -357,7 +357,6 @@ softpipe_delete_gs_state(struct pipe_context *pipe, void *gs)
 static void
 softpipe_set_constant_buffer(struct pipe_context *pipe,
                              enum pipe_shader_type shader, uint index,
-                             bool take_ownership,
                              const struct pipe_constant_buffer *cb)
 {
    struct softpipe_context *softpipe = softpipe_context(pipe);
@@ -381,13 +380,7 @@ softpipe_set_constant_buffer(struct pipe_context *pipe,
 
    draw_flush(softpipe->draw);
 
-   /* note: reference counting */
-   if (take_ownership) {
-      pipe_resource_reference(&softpipe->constants[shader][index], NULL);
-      softpipe->constants[shader][index] = constants;
-   } else {
-      pipe_resource_reference(&softpipe->constants[shader][index], constants);
-   }
+   pipe_resource_reference(&softpipe->constants[shader][index], constants);
 
    if (shader == PIPE_SHADER_VERTEX || shader == PIPE_SHADER_GEOMETRY) {
       draw_set_mapped_constant_buffer(softpipe->draw, shader, index, data, size);
diff --git a/src/gallium/drivers/svga/svga_pipe_constants.c b/src/gallium/drivers/svga/svga_pipe_constants.c
index bf01ef7254bd6..6d065bb145aa4 100644
--- a/src/gallium/drivers/svga/svga_pipe_constants.c
+++ b/src/gallium/drivers/svga/svga_pipe_constants.c
@@ -25,7 +25,6 @@ struct svga_constbuf
 static void
 svga_set_constant_buffer(struct pipe_context *pipe,
                          enum pipe_shader_type shader, uint index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb)
 {
    struct svga_screen *svgascreen = svga_screen(pipe->screen);
@@ -49,12 +48,7 @@ svga_set_constant_buffer(struct pipe_context *pipe,
    assert(index < svgascreen->max_const_buffers);
    (void) svgascreen;
 
-   if (take_ownership) {
-      pipe_resource_reference(&svga->curr.constbufs[shader][index].buffer, NULL);
-      svga->curr.constbufs[shader][index].buffer = buf;
-   } else {
-      pipe_resource_reference(&svga->curr.constbufs[shader][index].buffer, buf);
-   }
+   pipe_resource_reference(&svga->curr.constbufs[shader][index].buffer, buf);
 
    /* Make sure the constant buffer size to be updated is within the
     * limit supported by the device.
@@ -110,4 +104,3 @@ svga_init_constbuffer_functions(struct svga_context *svga)
 {
    svga->pipe.set_constant_buffer = svga_set_constant_buffer;
 }
-
diff --git a/src/gallium/drivers/svga/svga_state_ts.c b/src/gallium/drivers/svga/svga_state_ts.c
index d0aa7ed264490..7483c80ba1906 100644
--- a/src/gallium/drivers/svga/svga_state_ts.c
+++ b/src/gallium/drivers/svga/svga_state_ts.c
@@ -211,7 +211,7 @@ get_passthrough_tcs(struct svga_context *svga)
    cb.user_buffer = (void *) svga->curr.default_tesslevels;
    cb.buffer_offset = 0;
    cb.buffer_size = 2 * 4 * sizeof(float);
-   svga->pipe.set_constant_buffer(&svga->pipe, PIPE_SHADER_TESS_CTRL, 0, false, &cb);
+   svga->pipe.set_constant_buffer(&svga->pipe, PIPE_SHADER_TESS_CTRL, 0, &cb);
 }
 
 
diff --git a/src/gallium/drivers/tegra/tegra_context.c b/src/gallium/drivers/tegra/tegra_context.c
index 9598592323b0a..89802b98c982f 100644
--- a/src/gallium/drivers/tegra/tegra_context.c
+++ b/src/gallium/drivers/tegra/tegra_context.c
@@ -476,7 +476,7 @@ tegra_set_clip_state(struct pipe_context *pcontext,
 
 static void
 tegra_set_constant_buffer(struct pipe_context *pcontext, enum pipe_shader_type shader,
-                          unsigned int index, bool take_ownership,
+                          unsigned int index,
                           const struct pipe_constant_buffer *buf)
 {
    struct tegra_context *context = to_tegra_context(pcontext);
@@ -488,7 +488,7 @@ tegra_set_constant_buffer(struct pipe_context *pcontext, enum pipe_shader_type s
       buf = &buffer;
    }
 
-   context->gpu->set_constant_buffer(context->gpu, shader, index, take_ownership, buf);
+   context->gpu->set_constant_buffer(context->gpu, shader, index, buf);
 }
 
 static void
diff --git a/src/gallium/drivers/v3d/v3d_blit.c b/src/gallium/drivers/v3d/v3d_blit.c
index 759849ed2fc51..10ef3d43c966a 100644
--- a/src/gallium/drivers/v3d/v3d_blit.c
+++ b/src/gallium/drivers/v3d/v3d_blit.c
@@ -837,7 +837,7 @@ v3d_sand8_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
                 .buffer_size = sizeof(sand8_stride),
         };
 
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0, false,
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0,
                                   &cb_uniforms);
         struct pipe_constant_buffer saved_fs_cb1 = { 0 };
         pipe_resource_reference(&saved_fs_cb1.buffer,
@@ -850,7 +850,7 @@ v3d_sand8_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
                 .buffer_size = (src->bo->size -
                                 src->slices[info->src.level].offset),
         };
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, false,
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1,
                                   &cb_src);
         /* Unbind the textures, to make sure we don't try to recurse into the
          * shadow blit.
@@ -866,7 +866,7 @@ v3d_sand8_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
         util_blitter_restore_constant_buffer_state(v3d->blitter);
 
         /* Restore cb1 (util_blitter doesn't handle this one). */
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, true,
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1,
                                   &saved_fs_cb1);
 
         pipe_resource_reference(&dst_surf.texture, NULL);
@@ -1144,7 +1144,7 @@ v3d_sand30_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
                 .buffer_size = sizeof(sand30_stride),
         };
 
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0, false,
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0,
                                   &cb_uniforms);
 
         struct pipe_constant_buffer saved_fs_cb1 = { 0 };
@@ -1158,7 +1158,7 @@ v3d_sand30_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
                 .buffer_size = (src->bo->size -
                                 src->slices[info->src.level].offset),
         };
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, false,
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1,
                                   &cb_src);
         /* Unbind the textures, to make sure we don't try to recurse into the
          * shadow blit.
@@ -1175,7 +1175,7 @@ v3d_sand30_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
         util_blitter_restore_constant_buffer_state(v3d->blitter);
 
         /* Restore cb1 (util_blitter doesn't handle this one). */
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, true,
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1,
                                   &saved_fs_cb1);
         pipe_resource_reference(&dst_surf.texture, NULL);
 
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index 901a46b26b543..aaf52c9107edb 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -479,13 +479,12 @@ v3d_vertex_state_bind(struct pipe_context *pctx, void *hwcso)
 
 static void
 v3d_set_constant_buffer(struct pipe_context *pctx, enum pipe_shader_type shader, uint index,
-                        bool take_ownership,
                         const struct pipe_constant_buffer *cb)
 {
         struct v3d_context *v3d = v3d_context(pctx);
         struct v3d_constbuf_stateobj *so = &v3d->constbuf[shader];
 
-        util_copy_constant_buffer(&so->cb[index], cb, take_ownership);
+        util_copy_constant_buffer(&so->cb[index], cb);
 
         /* Note that the gallium frontend can unbind constant buffers by
          * passing NULL here.
diff --git a/src/gallium/drivers/vc4/vc4_blit.c b/src/gallium/drivers/vc4/vc4_blit.c
index 0aff1a08e0db8..608f24153bee2 100644
--- a/src/gallium/drivers/vc4/vc4_blit.c
+++ b/src/gallium/drivers/vc4/vc4_blit.c
@@ -385,14 +385,14 @@ vc4_yuv_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
                 .user_buffer = &stride,
                 .buffer_size = sizeof(stride),
         };
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0, false, &cb_uniforms);
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 0, &cb_uniforms);
         struct pipe_constant_buffer cb_src = {
                 .buffer = info->src.resource,
                 .buffer_offset = src->slices[info->src.level].offset,
                 .buffer_size = (src->bo->size -
                                 src->slices[info->src.level].offset),
         };
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, false, &cb_src);
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, &cb_src);
 
         /* Unbind the textures, to make sure we don't try to recurse into the
          * shadow blit.
@@ -408,7 +408,7 @@ vc4_yuv_blit(struct pipe_context *pctx, struct pipe_blit_info *info)
         util_blitter_restore_constant_buffer_state(vc4->blitter);
         /* Restore cb1 (util_blitter doesn't handle this one). */
         struct pipe_constant_buffer cb_disabled = { 0 };
-        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, false, &cb_disabled);
+        pctx->set_constant_buffer(pctx, PIPE_SHADER_FRAGMENT, 1, &cb_disabled);
 
         pipe_resource_reference(&dst_surf.texture, NULL);
 
diff --git a/src/gallium/drivers/vc4/vc4_state.c b/src/gallium/drivers/vc4/vc4_state.c
index d4f0d111b34c6..90b5cb79c0508 100644
--- a/src/gallium/drivers/vc4/vc4_state.c
+++ b/src/gallium/drivers/vc4/vc4_state.c
@@ -373,7 +373,6 @@ vc4_vertex_state_bind(struct pipe_context *pctx, void *hwcso)
 static void
 vc4_set_constant_buffer(struct pipe_context *pctx,
                         enum pipe_shader_type shader, uint index,
-                        bool take_ownership,
                         const struct pipe_constant_buffer *cb)
 {
         struct vc4_context *vc4 = vc4_context(pctx);
@@ -391,7 +390,7 @@ vc4_set_constant_buffer(struct pipe_context *pctx,
         if (index == 1 && so->cb[index].buffer_size != cb->buffer_size)
                 vc4->dirty |= VC4_DIRTY_UBO_1_SIZE;
 
-        util_copy_constant_buffer(&so->cb[index], cb, take_ownership);
+        util_copy_constant_buffer(&so->cb[index], cb);
 
         so->enabled_mask |= 1 << index;
         so->dirty_mask |= 1 << index;
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 4270bb0513a5a..6f82c931691fb 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -627,7 +627,6 @@ static void virgl_hw_set_index_buffer(struct virgl_context *vctx,
 
 static void virgl_set_constant_buffer(struct pipe_context *ctx,
                                      enum pipe_shader_type shader, uint index,
-                                      bool take_ownership,
                                      const struct pipe_constant_buffer *buf)
 {
    struct virgl_context *vctx = virgl_context(ctx);
@@ -642,12 +641,7 @@ static void virgl_set_constant_buffer(struct pipe_context *ctx,
                                        buf->buffer_offset,
                                        buf->buffer_size, res);
 
-      if (take_ownership) {
-         pipe_resource_reference(&binding->ubos[index].buffer, NULL);
-         binding->ubos[index].buffer = buf->buffer;
-      } else {
-         pipe_resource_reference(&binding->ubos[index].buffer, buf->buffer);
-      }
+      pipe_resource_reference(&binding->ubos[index].buffer, buf->buffer);
       binding->ubos[index] = *buf;
       binding->ubo_enabled_mask |= 1 << index;
    } else {
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 0210a9201cbbd..76e882784e5fd 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -1537,7 +1537,6 @@ invalidate_inlined_uniforms(struct zink_context *ctx, gl_shader_stage pstage)
 ALWAYS_INLINE static void
 zink_set_constant_buffer_internal(struct pipe_context *pctx,
                          gl_shader_stage shader, uint index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb,
                          bool use_db)
 {
@@ -1574,12 +1573,7 @@ zink_set_constant_buffer_internal(struct pipe_context *pctx,
                 !!res != !!buffer || (res && res->obj->buffer != new_res->obj->buffer) ||
                 ctx->ubos[shader][index].buffer_size != cb->buffer_size;
 
-      if (take_ownership) {
-         pipe_resource_reference(&ctx->ubos[shader][index].buffer, NULL);
-         ctx->ubos[shader][index].buffer = buffer;
-      } else {
-         pipe_resource_reference(&ctx->ubos[shader][index].buffer, buffer);
-      }
+      pipe_resource_reference(&ctx->ubos[shader][index].buffer, buffer);
       ctx->ubos[shader][index].buffer_offset = offset;
       ctx->ubos[shader][index].buffer_size = cb->buffer_size;
       ctx->ubos[shader][index].user_buffer = NULL;
@@ -1625,19 +1619,17 @@ zink_set_constant_buffer_internal(struct pipe_context *pctx,
 static void
 zink_set_constant_buffer_db(struct pipe_context *pctx,
                          gl_shader_stage shader, uint index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb)
 {
-   zink_set_constant_buffer_internal(pctx, shader, index, take_ownership, cb, true);
+   zink_set_constant_buffer_internal(pctx, shader, index, cb, true);
 }
 
 static void
 zink_set_constant_buffer_lazy(struct pipe_context *pctx,
                          gl_shader_stage shader, uint index,
-                         bool take_ownership,
                          const struct pipe_constant_buffer *cb)
 {
-   zink_set_constant_buffer_internal(pctx, shader, index, take_ownership, cb, false);
+   zink_set_constant_buffer_internal(pctx, shader, index, cb, false);
 }
 
 ALWAYS_INLINE static void
diff --git a/src/gallium/frontends/d3d10umd/Shader.cpp b/src/gallium/frontends/d3d10umd/Shader.cpp
index 23fbf80ae8525..44ba479b3b5d0 100644
--- a/src/gallium/frontends/d3d10umd/Shader.cpp
+++ b/src/gallium/frontends/d3d10umd/Shader.cpp
@@ -174,7 +174,6 @@ SetConstantBuffers(enum pipe_shader_type shader_type,    // IN
       pipe->set_constant_buffer(pipe,
                                 shader_type,
                                 StartBuffer + i,
-                                false,
                                 &cb);
    }
 }
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 2c23f1307604b..ccc2109fcb551 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -308,7 +308,7 @@ update_pcbuf(struct rendering_state *state, enum pipe_shader_type pstage,
       if (releasebuf)
          util_dynarray_append(&state->releasebufs, struct pipe_resource*, releasebuf);
       memcpy(mem, state->push_constants, size);
-      state->pctx->set_constant_buffer(state->pctx, pstage, 0, true, &cbuf);
+      state->pctx->set_constant_buffer(state->pctx, pstage, 0, &cbuf);
    }
    state->pcbuf_dirty[api_stage] = false;
 }
@@ -321,7 +321,7 @@ static void emit_compute_state(struct rendering_state *state)
    if (state->constbuf_dirty[MESA_SHADER_COMPUTE]) {
       for (unsigned i = 0; i < state->num_const_bufs[MESA_SHADER_COMPUTE]; i++)
          state->pctx->set_constant_buffer(state->pctx, MESA_SHADER_COMPUTE,
-                                          i + 1, false, &state->const_buffer[MESA_SHADER_COMPUTE][i]);
+                                          i + 1, &state->const_buffer[MESA_SHADER_COMPUTE][i]);
       state->constbuf_dirty[MESA_SHADER_COMPUTE] = false;
    }
 
@@ -506,7 +506,7 @@ static void emit_state(struct rendering_state *state)
       if (state->constbuf_dirty[sh]) {
          for (unsigned idx = 0; idx < state->num_const_bufs[sh]; idx++)
             state->pctx->set_constant_buffer(state->pctx, sh,
-                                             idx + 1, false, &state->const_buffer[sh][idx]);
+                                             idx + 1, &state->const_buffer[sh][idx]);
       }
       state->constbuf_dirty[sh] = false;
    }
@@ -4586,7 +4586,7 @@ lvp_trace_rays(struct rendering_state *state, VkTraceRaysIndirectCommand2KHR *co
    if (state->constbuf_dirty[MESA_SHADER_RAYGEN]) {
       for (unsigned i = 0; i < state->num_const_bufs[MESA_SHADER_RAYGEN]; i++)
          state->pctx->set_constant_buffer(state->pctx, MESA_SHADER_COMPUTE,
-                                          i + 1, false, &state->const_buffer[MESA_SHADER_RAYGEN][i]);
+                                          i + 1, &state->const_buffer[MESA_SHADER_RAYGEN][i]);
       state->constbuf_dirty[MESA_SHADER_RAYGEN] = false;
    }
 
diff --git a/src/gallium/frontends/rusticl/mesa/pipe/context.rs b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
index 63bcd14f81a44..0e1ab0f9653cc 100644
--- a/src/gallium/frontends/rusticl/mesa/pipe/context.rs
+++ b/src/gallium/frontends/rusticl/mesa/pipe/context.rs
@@ -432,7 +432,6 @@ impl PipeContext {
                 self.pipe.as_ptr(),
                 pipe_shader_type::PIPE_SHADER_COMPUTE,
                 idx,
-                false,
                 &cb,
             )
         }
@@ -450,7 +449,6 @@ impl PipeContext {
                 self.pipe.as_ptr(),
                 pipe_shader_type::PIPE_SHADER_COMPUTE,
                 idx,
-                false,
                 if data.is_empty() { ptr::null() } else { &cb },
             )
         }
@@ -489,7 +487,6 @@ impl PipeContext {
                 self.pipe.as_ptr(),
                 pipe_shader_type::PIPE_SHADER_COMPUTE,
                 idx,
-                true,
                 &cb,
             );
             self.pipe.as_ref().resource_release.unwrap()(self.pipe.as_ptr(), releasebuf);
diff --git a/src/gallium/include/pipe/p_context.h b/src/gallium/include/pipe/p_context.h
index c375fbad6c529..7392fcf84a436 100644
--- a/src/gallium/include/pipe/p_context.h
+++ b/src/gallium/include/pipe/p_context.h
@@ -460,13 +460,10 @@ struct pipe_context {
     *
     * \param shader           Shader stage
     * \param index            Buffer binding slot index within a shader stage
-    * \param take_ownership   The callee takes ownership of the buffer reference.
-    *                         (the callee shouldn't increment the ref count)
     * \param buf              Constant buffer parameters
     */
    void (*set_constant_buffer)(struct pipe_context *,
                                enum pipe_shader_type shader, uint index,
-                               bool take_ownership,
                                const struct pipe_constant_buffer *buf);
 
    /**
diff --git a/src/gallium/tools/trace/dump_state.py b/src/gallium/tools/trace/dump_state.py
index 62ed304cc5cac..4791a1396c140 100755
--- a/src/gallium/tools/trace/dump_state.py
+++ b/src/gallium/tools/trace/dump_state.py
@@ -422,7 +422,7 @@ class Context(Dispatcher):
             return self._state.fs
         assert False
 
-    def set_constant_buffer(self, shader, index, take_ownership, constant_buffer):
+    def set_constant_buffer(self, shader, index, constant_buffer):
         self._update(self._get_stage_state(shader).constant_buffer, index, 1, [constant_buffer])
 
     def set_framebuffer_state(self, state):
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 6f9d8bdedab7a..57488caa3c3d2 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -57,7 +57,7 @@ st_unbind_unused_cb0(struct st_context *st, enum pipe_shader_type shader_type)
    if (st->state.constbuf0_enabled_shader_mask & (1 << shader_type)) {
       struct pipe_context *pipe = st->pipe;
 
-      pipe->set_constant_buffer(pipe, shader_type, 0, false, NULL);
+      pipe->set_constant_buffer(pipe, shader_type, 0, NULL);
       st->state.constbuf0_enabled_shader_mask &= ~(1 << shader_type);
    }
 }
@@ -78,7 +78,7 @@ st_upload_constant_buffer(struct st_context *st, gl_shader_stage stage, struct p
    cbuf.user_buffer = NULL;
 
    u_upload_unmap(pipe->const_uploader);
-   pipe->set_constant_buffer(pipe, stage, 0, true, &cbuf);
+   pipe->set_constant_buffer(pipe, stage, 0, &cbuf);
    pipe_resource_release(pipe, releasebuf);
 }
 
@@ -165,7 +165,7 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
             _mesa_upload_state_parameters(st->ctx, params, ptr);
 
          u_upload_unmap(pipe->const_uploader);
-         pipe->set_constant_buffer(pipe, shader_type, 0, true, &cb);
+         pipe->set_constant_buffer(pipe, shader_type, 0, &cb);
 
          /* Set inlinable constants. This is more involved because state
           * parameters are uploaded directly above instead of being loaded
@@ -204,7 +204,7 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
          if (params->StateFlags)
             _mesa_load_state_parameters(st->ctx, params);
 
-         pipe->set_constant_buffer(pipe, shader_type, 0, false, &cb);
+         pipe->set_constant_buffer(pipe, shader_type, 0, &cb);
 
          /* Set inlinable constants. */
          unsigned num_inlinable_uniforms = prog->info.num_inlinable_uniforms;
@@ -342,7 +342,7 @@ st_bind_ubos(struct st_context *st, struct gl_program *prog,
          cb.buffer_size = 0;
       }
 
-      pipe->set_constant_buffer(pipe, shader_type, 1 + i, true, &cb);
+      pipe->set_constant_buffer(pipe, shader_type, 1 + i, &cb);
    }
 }
 
diff --git a/src/mesa/state_tracker/st_cb_clear.c b/src/mesa/state_tracker/st_cb_clear.c
index c5f3ba80b1031..b1debf5fce8bb 100644
--- a/src/mesa/state_tracker/st_cb_clear.c
+++ b/src/mesa/state_tracker/st_cb_clear.c
@@ -117,7 +117,7 @@ set_clearcolor_fs(struct st_context *st, union pipe_color_union *color)
    if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context) {
       st_upload_constant_buffer(st, PIPE_SHADER_FRAGMENT, &cb);
    } else {
-      st->pipe->set_constant_buffer(st->pipe, PIPE_SHADER_FRAGMENT, 0, false, &cb);
+      st->pipe->set_constant_buffer(st->pipe, PIPE_SHADER_FRAGMENT, 0, &cb);
    }
 
    if (!st->clear.fs) {
diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index 5f36f34c85e04..440af840b7bf3 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -695,7 +695,7 @@ st_draw_hw_select_prepare_common(struct gl_context *ctx)
    if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context) {
       st_upload_constant_buffer(st, PIPE_SHADER_GEOMETRY, &cb);
    } else {
-      pipe->set_constant_buffer(pipe, PIPE_SHADER_GEOMETRY, 0, false, &cb);
+      pipe->set_constant_buffer(pipe, PIPE_SHADER_GEOMETRY, 0, &cb);
    }
 
    struct pipe_shader_buffer buffer;
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index 54ad9e72e53c8..bcd291d315420 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -265,7 +265,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context)
          st_upload_constant_buffer(st, PIPE_SHADER_FRAGMENT, &cb);
       else
-         pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, 0, false, &cb);
+         pipe->set_constant_buffer(pipe, PIPE_SHADER_FRAGMENT, 0, &cb);
    }
 
    /* Rasterizer state */
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index ef43b47b403ab..8b22dd8f2fc20 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -1007,7 +1007,7 @@ download_texture_compute(struct st_context *st,
    if (st->prefer_real_buffer_in_constbuf0 || st->is_threaded_context)
       st_upload_constant_buffer(st, PIPE_SHADER_COMPUTE, &cb);
    else
-      pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, false, &cb);
+      pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, &cb);
 
    cso_save_compute_state(cso, CSO_BIT_COMPUTE_SHADER | CSO_BIT_COMPUTE_SAMPLERS);
    cso_set_compute_shader_handle(cso, cs);
-- 
GitLab


From 39389da5075b7c65eff917486757abc8bd68bf6b Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 24 Jul 2025 07:58:52 -0400
Subject: [PATCH 20/23] util_set_vertex_buffers_*

---
 src/gallium/auxiliary/draw/draw_context.c          |  2 +-
 src/gallium/auxiliary/util/u_blitter.c             | 12 +++++++-----
 src/gallium/auxiliary/util/u_helpers.c             | 14 ++++----------
 src/gallium/auxiliary/util/u_helpers.h             |  6 ++----
 src/gallium/drivers/asahi/agx_state.c              |  2 +-
 src/gallium/drivers/crocus/crocus_state.c          |  2 +-
 .../drivers/d3d12/d3d12_context_graphics.cpp       |  2 +-
 src/gallium/drivers/etnaviv/etnaviv_state.c        |  3 +--
 src/gallium/drivers/freedreno/freedreno_state.c    |  3 +--
 src/gallium/drivers/i915/i915_state.c              |  3 +--
 src/gallium/drivers/iris/iris_state.c              |  3 +--
 src/gallium/drivers/lima/lima_state.c              |  4 ++--
 src/gallium/drivers/llvmpipe/lp_state_vertex.c     |  2 +-
 src/gallium/drivers/nouveau/nv30/nv30_state.c      |  2 +-
 src/gallium/drivers/nouveau/nv50/nv50_state.c      |  2 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c      |  2 +-
 src/gallium/drivers/panfrost/pan_context.c         |  2 +-
 src/gallium/drivers/r300/r300_state.c              |  8 +++-----
 src/gallium/drivers/r600/r600_state_common.c       |  6 ++----
 src/gallium/drivers/softpipe/sp_state_vertex.c     |  2 +-
 src/gallium/drivers/svga/svga_pipe_vertex.c        |  2 +-
 src/gallium/drivers/v3d/v3dx_state.c               |  2 +-
 src/gallium/drivers/vc4/vc4_state.c                |  2 +-
 src/gallium/drivers/virgl/virgl_context.c          |  3 +--
 24 files changed, 38 insertions(+), 53 deletions(-)

diff --git a/src/gallium/auxiliary/draw/draw_context.c b/src/gallium/auxiliary/draw/draw_context.c
index 9e57b56dd256c..bc170d394e986 100644
--- a/src/gallium/auxiliary/draw/draw_context.c
+++ b/src/gallium/auxiliary/draw/draw_context.c
@@ -417,7 +417,7 @@ draw_set_vertex_buffers(struct draw_context *draw,
 
    util_set_vertex_buffers_count(draw->pt.vertex_buffer,
                                  &draw->pt.nr_vertex_buffers,
-                                 buffers, count, false);
+                                 buffers, count);
 }
 
 
diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 35f607152598d..daa6524b3273d 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -149,6 +149,7 @@ struct blitter_context_priv
    bool cube_as_2darray;
    bool has_texrect;
    bool cached_all_shaders;
+   bool must_unset_vbuf;
 
    /* The Draw module overrides these functions.
     * Always create the blitter before Draw. */
@@ -574,12 +575,12 @@ void util_blitter_restore_vertex_states(struct blitter_context *blitter)
       ctx->base.saved_velem_state = INVALID_PTR;
    }
 
-   /* Vertex buffer. */
-   if (ctx->base.saved_num_vb) {
+   /* Vertex buffers: must ensure no internal vbs are left on driver. */
+   if (ctx->base.saved_num_vb || ctx->must_unset_vbuf) {
       pipe->set_vertex_buffers(pipe, ctx->base.saved_num_vb,
-                               ctx->base.saved_vertex_buffers);
-      memset(ctx->base.saved_vertex_buffers, 0,
-             sizeof(ctx->base.saved_vertex_buffers[0]) * ctx->base.saved_num_vb);
+                                 ctx->base.saved_vertex_buffers);
+      for (unsigned i = 0; i < ctx->base.saved_num_vb; i++)
+         pipe_vertex_buffer_unreference(&ctx->base.saved_vertex_buffers[i]);
       ctx->base.saved_num_vb = 0;
    }
 
@@ -1368,6 +1369,7 @@ static void blitter_draw(struct blitter_context_priv *ctx,
    pipe->bind_vertex_elements_state(pipe, vertex_elements_cso);
    pipe->set_vertex_buffers(pipe, 1, &vb);
    pipe->bind_vs_state(pipe, get_vs(&ctx->base));
+   ctx->must_unset_vbuf = true;
 
    if (ctx->base.use_index_buffer) {
       /* Note that for V3D,
diff --git a/src/gallium/auxiliary/util/u_helpers.c b/src/gallium/auxiliary/util/u_helpers.c
index 2f3c1a677f9cf..e3014dc626045 100644
--- a/src/gallium/auxiliary/util/u_helpers.c
+++ b/src/gallium/auxiliary/util/u_helpers.c
@@ -47,8 +47,7 @@
 void util_set_vertex_buffers_mask(struct pipe_vertex_buffer *dst,
                                   uint32_t *enabled_buffers,
                                   const struct pipe_vertex_buffer *src,
-                                  unsigned count,
-                                  bool take_ownership)
+                                  unsigned count)
 {
    unsigned last_count = util_last_bit(*enabled_buffers);
    uint32_t bitmask = 0;
@@ -61,10 +60,7 @@ void util_set_vertex_buffers_mask(struct pipe_vertex_buffer *dst,
          if (src[i].buffer.resource)
             bitmask |= 1 << i;
 
-         pipe_vertex_buffer_unreference(&dst[i]);
-
-         if (!take_ownership && !src[i].is_user_buffer)
-            pipe_resource_reference(&dst[i].buffer.resource, src[i].buffer.resource);
+         pipe_vertex_buffer_reference(&dst[i], &src[i]);
       }
 
       /* Copy over the other members of pipe_vertex_buffer. */
@@ -84,8 +80,7 @@ void util_set_vertex_buffers_mask(struct pipe_vertex_buffer *dst,
 void util_set_vertex_buffers_count(struct pipe_vertex_buffer *dst,
                                    unsigned *dst_count,
                                    const struct pipe_vertex_buffer *src,
-                                   unsigned count,
-                                   bool take_ownership)
+                                   unsigned count)
 {
    uint32_t enabled_buffers = 0;
 
@@ -94,8 +89,7 @@ void util_set_vertex_buffers_count(struct pipe_vertex_buffer *dst,
          enabled_buffers |= (1ull << i);
    }
 
-   util_set_vertex_buffers_mask(dst, &enabled_buffers, src, count,
-                                take_ownership);
+   util_set_vertex_buffers_mask(dst, &enabled_buffers, src, count);
 
    *dst_count = util_last_bit(enabled_buffers);
 }
diff --git a/src/gallium/auxiliary/util/u_helpers.h b/src/gallium/auxiliary/util/u_helpers.h
index f377ad4a7d86b..a86f24b797af9 100644
--- a/src/gallium/auxiliary/util/u_helpers.h
+++ b/src/gallium/auxiliary/util/u_helpers.h
@@ -40,14 +40,12 @@ extern "C" {
 void util_set_vertex_buffers_mask(struct pipe_vertex_buffer *dst,
                                   uint32_t *enabled_buffers,
                                   const struct pipe_vertex_buffer *src,
-                                  unsigned count,
-                                  bool take_ownership);
+                                  unsigned count);
 
 void util_set_vertex_buffers_count(struct pipe_vertex_buffer *dst,
                                    unsigned *dst_count,
                                    const struct pipe_vertex_buffer *src,
-                                   unsigned count,
-                                   bool take_ownership);
+                                   unsigned count);
 
 void util_set_shader_buffers_mask(struct pipe_shader_buffer *dst,
                                   uint32_t *enabled_buffers,
diff --git a/src/gallium/drivers/asahi/agx_state.c b/src/gallium/drivers/asahi/agx_state.c
index 683dd8f626da1..a36b4aede453f 100644
--- a/src/gallium/drivers/asahi/agx_state.c
+++ b/src/gallium/drivers/asahi/agx_state.c
@@ -1342,7 +1342,7 @@ agx_set_vertex_buffers(struct pipe_context *pctx, unsigned count,
    struct agx_context *ctx = agx_context(pctx);
 
    util_set_vertex_buffers_mask(ctx->vertex_buffers, &ctx->vb_mask, buffers,
-                                count, true);
+                                count);
 
    ctx->dirty |= AGX_DIRTY_VERTEX;
 }
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index b04f5c4a54ea7..d2a5ce325d629 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -3653,7 +3653,7 @@ crocus_set_vertex_buffers(struct pipe_context *ctx,
       (GFX_VERx10 < 75 && screen->devinfo.platform != INTEL_PLATFORM_BYT) * 2;
 
    util_set_vertex_buffers_mask(ice->state.vertex_buffers, &ice->state.bound_vertex_buffers,
-                                buffers, count, true);
+                                buffers, count);
 
    for (unsigned i = 0; i < count; i++) {
       struct pipe_vertex_buffer *state =
diff --git a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
index e39c14ee8e7a4..a2cc5e3e09eea 100644
--- a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
@@ -1264,7 +1264,7 @@ d3d12_set_vertex_buffers(struct pipe_context *pctx,
                          const struct pipe_vertex_buffer *buffers)
 {
    struct d3d12_context *ctx = d3d12_context(pctx);
-   util_set_vertex_buffers_count(ctx->vbs, &ctx->num_vbs, buffers, num_buffers, true);
+   util_set_vertex_buffers_count(ctx->vbs, &ctx->num_vbs, buffers, num_buffers);
 
    for (unsigned i = 0; i < ctx->num_vbs; ++i) {
       const struct pipe_vertex_buffer* buf = ctx->vbs + i;
diff --git a/src/gallium/drivers/etnaviv/etnaviv_state.c b/src/gallium/drivers/etnaviv/etnaviv_state.c
index f73a48cf81955..85d0305ebe1f1 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_state.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_state.c
@@ -518,8 +518,7 @@ etna_set_vertex_buffers(struct pipe_context *pctx, unsigned num_buffers,
    struct etna_context *ctx = etna_context(pctx);
    struct etna_vertexbuf_state *so = &ctx->vertex_buffer;
 
-   util_set_vertex_buffers_mask(so->vb, &so->enabled_mask, vb, num_buffers,
-                                true);
+   util_set_vertex_buffers_mask(so->vb, &so->enabled_mask, vb, num_buffers);
    so->count = util_last_bit(so->enabled_mask);
 
    if (!num_buffers) {
diff --git a/src/gallium/drivers/freedreno/freedreno_state.c b/src/gallium/drivers/freedreno/freedreno_state.c
index 3e32731c47d66..25642582fbf3e 100644
--- a/src/gallium/drivers/freedreno/freedreno_state.c
+++ b/src/gallium/drivers/freedreno/freedreno_state.c
@@ -472,8 +472,7 @@ fd_set_vertex_buffers(struct pipe_context *pctx, unsigned count,
       }
    }
 
-   util_set_vertex_buffers_mask(so->vb, &so->enabled_mask, vb, count,
-                                true);
+   util_set_vertex_buffers_mask(so->vb, &so->enabled_mask, vb, count);
    so->count = util_last_bit(so->enabled_mask);
 
    if (!vb)
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 94973a33eacc8..8a4fa54a2afe0 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -1012,8 +1012,7 @@ i915_set_vertex_buffers(struct pipe_context *pipe, unsigned count,
    assert(count <= PIPE_MAX_ATTRIBS);
 
    util_set_vertex_buffers_count(draw->pt.vertex_buffer,
-                                 &draw->pt.nr_vertex_buffers, buffers, count,
-                                 true);
+                                 &draw->pt.nr_vertex_buffers, buffers, count);
 }
 
 static void *
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index 5399005c07446..7a90e55739887 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -4192,8 +4192,7 @@ iris_set_vertex_buffers(struct pipe_context *ctx,
           state->resource != buffer->buffer.resource)
          ice->state.dirty |= IRIS_DIRTY_VERTEX_BUFFER_FLUSHES;
 
-      pipe_resource_reference(&state->resource, NULL);
-      state->resource = buffer->buffer.resource;
+      pipe_resource_reference(&state->resource, buffer->buffer.resource);
 
       struct iris_resource *res = (void *) state->resource;
 
diff --git a/src/gallium/drivers/lima/lima_state.c b/src/gallium/drivers/lima/lima_state.c
index de4c5171ef736..a2b81efcc366a 100644
--- a/src/gallium/drivers/lima/lima_state.c
+++ b/src/gallium/drivers/lima/lima_state.c
@@ -193,7 +193,7 @@ lima_set_vertex_buffers(struct pipe_context *pctx,
    struct lima_context_vertex_buffer *so = &ctx->vertex_buffers;
 
    util_set_vertex_buffers_mask(so->vb, &so->enabled_mask,
-                                vb, count, true);
+                                vb, count);
    so->count = util_last_bit(so->enabled_mask);
 
    ctx->dirty |= LIMA_CONTEXT_DIRTY_VERTEX_BUFF;
@@ -452,5 +452,5 @@ lima_state_fini(struct lima_context *ctx)
    struct lima_context_vertex_buffer *so = &ctx->vertex_buffers;
 
    util_set_vertex_buffers_mask(so->vb, &so->enabled_mask, NULL,
-                                0, false);
+                                0);
 }
diff --git a/src/gallium/drivers/llvmpipe/lp_state_vertex.c b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
index dba5311aa4036..119aec090c0d2 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_vertex.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
@@ -89,7 +89,7 @@ llvmpipe_set_vertex_buffers(struct pipe_context *pipe,
 
    util_set_vertex_buffers_count(llvmpipe->vertex_buffer,
                                  &llvmpipe->num_vertex_buffers,
-                                 buffers, count, true);
+                                 buffers, count);
 
    llvmpipe->dirty |= LP_NEW_VERTEX;
 
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_state.c b/src/gallium/drivers/nouveau/nv30/nv30_state.c
index c72c0da1ebe9c..d5c9b55bdc907 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_state.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_state.c
@@ -435,7 +435,7 @@ nv30_set_vertex_buffers(struct pipe_context *pipe,
     nouveau_bufctx_reset(nv30->bufctx, BUFCTX_VTXBUF);
 
     util_set_vertex_buffers_count(nv30->vtxbuf, &nv30->num_vtxbufs,
-                                  vb, count, true);
+                                  vb, count);
 
     nv30->dirty |= NV30_NEW_ARRAYS;
 }
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 5158be9b276fe..25cf677f2de6f 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -1083,7 +1083,7 @@ nv50_set_vertex_buffers(struct pipe_context *pipe,
 
    unsigned last_count = nv50->num_vtxbufs;
    util_set_vertex_buffers_count(nv50->vtxbuf, &nv50->num_vtxbufs, vb,
-                                 count, true);
+                                 count);
 
    unsigned clear_mask =
       last_count > count ? BITFIELD_RANGE(count, last_count - count) : 0;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index 2e04b3c30b57c..7d26fde38e1f3 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -1024,7 +1024,7 @@ nvc0_set_vertex_buffers(struct pipe_context *pipe,
 
     unsigned last_count = nvc0->num_vtxbufs;
     util_set_vertex_buffers_count(nvc0->vtxbuf, &nvc0->num_vtxbufs, vb,
-                                  count, true);
+                                  count);
 
     unsigned clear_mask =
        last_count > count ? BITFIELD_RANGE(count, last_count - count) : 0;
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 2c646c6af01a2..239963dee1765 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -338,7 +338,7 @@ panfrost_set_vertex_buffers(struct pipe_context *pctx, unsigned num_buffers,
    struct panfrost_context *ctx = pan_context(pctx);
 
    util_set_vertex_buffers_mask(ctx->vertex_buffers, &ctx->vb_mask, buffers,
-                                num_buffers, true);
+                                num_buffers);
 
    ctx->dirty |= PAN_DIRTY_VERTEX;
 }
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index 057c1e3afec25..20fb00d575fca 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -1792,14 +1792,13 @@ static void r300_set_vertex_buffers_hwtcl(struct pipe_context* pipe,
     struct r300_context* r300 = r300_context(pipe);
 
     util_set_vertex_buffers_count(r300->vertex_buffer,
-                                  &r300->nr_vertex_buffers, buffers, count,
-                                  true);
+                                  &r300->nr_vertex_buffers, buffers, count);
 
     /* There must be at least one vertex buffer set, otherwise it locks up. */
     if (!r300->nr_vertex_buffers) {
         util_set_vertex_buffers_count(r300->vertex_buffer,
                                       &r300->nr_vertex_buffers,
-                                      &r300->dummy_vb, 1, false);
+                                      &r300->dummy_vb, 1);
     }
 
     r300->vertex_arrays_dirty = true;
@@ -1813,8 +1812,7 @@ static void r300_set_vertex_buffers_swtcl(struct pipe_context* pipe,
     unsigned i;
 
     util_set_vertex_buffers_count(r300->vertex_buffer,
-                                  &r300->nr_vertex_buffers, buffers, count,
-                                  true);
+                                  &r300->nr_vertex_buffers, buffers, count);
     draw_set_vertex_buffers(r300->draw, count, buffers);
 
     if (!buffers)
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index 51716a3b82172..d89439aa4c609 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -589,8 +589,7 @@ static void r600_set_vertex_buffers(struct pipe_context *ctx,
 			   (vb[i].is_user_buffer != input[i].is_user_buffer))) {
 			if (input[i].buffer.resource) {
 				vb[i].buffer_offset = input[i].buffer_offset;
-				pipe_resource_reference(&vb[i].buffer.resource, NULL);
-				vb[i].buffer.resource = input[i].buffer.resource;
+				pipe_resource_reference(&vb[i].buffer.resource, input[i].buffer.resource);
 				new_buffer_mask |= 1 << i;
 				r600_context_add_resource_size(ctx, input[i].buffer.resource);
 			} else {
@@ -598,8 +597,7 @@ static void r600_set_vertex_buffers(struct pipe_context *ctx,
 				disable_mask |= 1 << i;
 			}
 		} else if (input[i].buffer.resource) {
-			pipe_resource_reference(&vb[i].buffer.resource, NULL);
-			vb[i].buffer.resource = input[i].buffer.resource;
+			pipe_resource_reference(&vb[i].buffer.resource, input[i].buffer.resource);
 		}
 	}
 
diff --git a/src/gallium/drivers/softpipe/sp_state_vertex.c b/src/gallium/drivers/softpipe/sp_state_vertex.c
index 49d0492e30a0e..e3469a5341ff7 100644
--- a/src/gallium/drivers/softpipe/sp_state_vertex.c
+++ b/src/gallium/drivers/softpipe/sp_state_vertex.c
@@ -89,7 +89,7 @@ softpipe_set_vertex_buffers(struct pipe_context *pipe,
 
    util_set_vertex_buffers_count(softpipe->vertex_buffer,
                                  &softpipe->num_vertex_buffers,
-                                 buffers, count, true);
+                                 buffers, count);
 
    softpipe->dirty |= SP_NEW_VERTEX;
 
diff --git a/src/gallium/drivers/svga/svga_pipe_vertex.c b/src/gallium/drivers/svga/svga_pipe_vertex.c
index 9a2910d28b719..a8e24d0fe333a 100644
--- a/src/gallium/drivers/svga/svga_pipe_vertex.c
+++ b/src/gallium/drivers/svga/svga_pipe_vertex.c
@@ -30,7 +30,7 @@ svga_set_vertex_buffers(struct pipe_context *pipe,
 
    util_set_vertex_buffers_count(svga->curr.vb,
                                  &svga->curr.num_vertex_buffers,
-                                 buffers, count, true);
+                                 buffers, count);
 
    svga->dirty |= SVGA_NEW_VBUFFER;
 }
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index aaf52c9107edb..fe5d4a508bd2b 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -309,7 +309,7 @@ v3d_set_vertex_buffers(struct pipe_context *pctx,
 
         assert(BITSET_SIZE(so->enabled_mask) <= 32);
         util_set_vertex_buffers_mask(so->vb, &so->enabled_mask[0], vb,
-                                     count, true);
+                                     count);
 
         so->count = BITSET_LAST_BIT(so->enabled_mask);
 
diff --git a/src/gallium/drivers/vc4/vc4_state.c b/src/gallium/drivers/vc4/vc4_state.c
index 90b5cb79c0508..e29339c2a2ad1 100644
--- a/src/gallium/drivers/vc4/vc4_state.c
+++ b/src/gallium/drivers/vc4/vc4_state.c
@@ -310,7 +310,7 @@ vc4_set_vertex_buffers(struct pipe_context *pctx,
         struct vc4_vertexbuf_stateobj *so = &vc4->vertexbuf;
 
         util_set_vertex_buffers_mask(so->vb, &so->enabled_mask, vb,
-                                     count, true);
+                                     count);
         so->count = util_last_bit(so->enabled_mask);
 
         vc4->dirty |= VC4_DIRTY_VTXBUF;
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 6f82c931691fb..e13b8885010c8 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -569,8 +569,7 @@ static void virgl_set_vertex_buffers(struct pipe_context *ctx,
 
    util_set_vertex_buffers_count(vctx->vertex_buffer,
                                  &vctx->num_vertex_buffers,
-                                 buffers, num_buffers,
-                                 true);
+                                 buffers, num_buffers);
 
    if (buffers) {
       for (unsigned i = 0; i < num_buffers; i++) {
-- 
GitLab


From a89d266c61b6481bee50d4fe328001f14288f55c Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 22 Jul 2025 09:13:55 -0400
Subject: [PATCH 21/23] zink no refs

---
 src/gallium/drivers/zink/zink_context.c | 26 ++++++++++++++++++++++---
 src/gallium/drivers/zink/zink_types.h   |  1 +
 2 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 76e882784e5fd..59571bedbf8cd 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -1341,10 +1341,30 @@ update_res_bind_count(struct zink_context *ctx, struct zink_resource *res, bool
       if (!--res->bind_count[is_compute])
          _mesa_set_remove_key(ctx->need_barriers[is_compute], res);
       check_resource_for_batch_ref(ctx, res);
+      /* if hit while blitting, this will be triggered again after blitting */
+      if (res->deleted && !res->all_binds && !ctx->blitting) {
+         if (zink_resource_has_usage(res) && !zink_resource_usage_check_completion_fast(zink_screen(ctx->base.screen), res, ZINK_RESOURCE_ACCESS_RW))
+            zink_batch_reference_resource(ctx, res);
+         zink_resource_reference(&res, NULL);
+      }
    } else
       res->bind_count[is_compute]++;
 }
 
+static void
+zink_resource_release(struct pipe_context *pctx, struct pipe_resource *pres)
+{
+   struct zink_resource *res = zink_resource(pres);
+
+   if (res->all_binds) {
+      res->deleted = true;
+   } else {
+      if (zink_resource_has_usage(res) && !zink_resource_usage_check_completion_fast(zink_screen(pctx->screen), res, ZINK_RESOURCE_ACCESS_RW))
+         zink_batch_reference_resource(zink_context(pctx), res);
+      pipe_resource_reference(&pres, NULL);
+   }
+}
+
 ALWAYS_INLINE static void
 update_existing_vbo(struct zink_context *ctx, unsigned slot)
 {
@@ -1379,7 +1399,7 @@ zink_set_vertex_buffers_internal(struct pipe_context *pctx,
       const struct pipe_vertex_buffer *vb = buffers + i;
       struct pipe_vertex_buffer *ctx_vb = &ctx->vertex_buffers[i];
       update_existing_vbo(ctx, i);
-      pipe_resource_reference(&ctx_vb->buffer.resource, vb->buffer.resource);
+      ctx_vb->buffer.resource = vb->buffer.resource;
 
       if (vb->buffer.resource) {
          struct zink_resource *res = zink_resource(vb->buffer.resource);
@@ -1400,7 +1420,7 @@ zink_set_vertex_buffers_internal(struct pipe_context *pctx,
    }
    for (unsigned i = num_buffers; i < last_count; i++) {
       update_existing_vbo(ctx, i);
-      pipe_resource_reference(&ctx->vertex_buffers[i].buffer.resource, NULL);
+      ctx->vertex_buffers[i].buffer.resource = NULL;
    }
    if (!optimal) {
       if (need_state_change)
@@ -5331,7 +5351,7 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
    ctx->base.set_sampler_views = zink_set_sampler_views;
    ctx->base.sampler_view_destroy = zink_sampler_view_destroy;
    ctx->base.sampler_view_release = u_default_sampler_view_release;
-   ctx->base.resource_release = u_default_resource_release;
+   ctx->base.resource_release = zink_resource_release;
    ctx->base.get_sample_position = zink_get_sample_position;
    ctx->base.set_sample_locations = zink_set_sample_locations;
 
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index cf722d77aeab3..1738b6bc22cd5 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -1302,6 +1302,7 @@ struct zink_resource {
    bool use_damage;
 
    bool copies_warned;
+   bool deleted; //resource_release
    bool swapchain;
    bool dmabuf;
    unsigned dt_stride;
-- 
GitLab


From b932db721bd13238bc74eb54d914de1008745ff6 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 29 Jul 2025 15:31:44 -0400
Subject: [PATCH 22/23] mesa/st: rework thread scheduler handling + add
 dispatch tracking

---
 src/mesa/main/compute.c             |  1 +
 src/mesa/main/glthread.c            |  4 +--
 src/mesa/state_tracker/st_context.c |  2 +-
 src/mesa/state_tracker/st_context.h | 53 ++++++++++++++++++++++++++---
 src/mesa/state_tracker/st_draw.c    | 23 +------------
 5 files changed, 54 insertions(+), 29 deletions(-)

diff --git a/src/mesa/main/compute.c b/src/mesa/main/compute.c
index df3cf6b52cadd..8a4daf5e9c4f5 100644
--- a/src/mesa/main/compute.c
+++ b/src/mesa/main/compute.c
@@ -296,6 +296,7 @@ prepare_compute(struct gl_context *ctx)
       _mesa_update_state(ctx);
 
    st_validate_state(st, ST_PIPELINE_COMPUTE_STATE_MASK);
+   st_context_add_dispatch(st);
 }
 
 static ALWAYS_INLINE void
diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index c8e51b71b276a..86d00a242cd9f 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -299,7 +299,7 @@ void _mesa_glthread_enable(struct gl_context *ctx)
    ctx->GLApi = ctx->MarshalExec;
 
    /* glthread takes over all thread scheduling. */
-   ctx->st->pin_thread_counter = ST_THREAD_SCHEDULER_DISABLED;
+   ctx->st->thread_scheduler_disabled = true;
 
    /* Update the dispatch only if the dispatch is current. */
    if (GET_DISPATCH() == ctx->Dispatch.Current) {
@@ -319,7 +319,7 @@ void _mesa_glthread_disable(struct gl_context *ctx)
 
    /* Re-enable thread scheduling in st/mesa when glthread is disabled. */
    if (ctx->pipe->set_context_param && util_thread_scheduler_enabled())
-      ctx->st->pin_thread_counter = 0;
+      ctx->st->thread_scheduler_disabled = false;
 
    /* Update the dispatch only if the dispatch is current. */
    if (GET_DISPATCH() == ctx->MarshalExec) {
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 7e27586a0db3f..4736e44b93f0c 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -717,7 +717,7 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
    st->shader_has_one_variant[MESA_SHADER_COMPUTE] = st->has_shareable_shaders;
 
    if (!st->pipe->set_context_param || !util_thread_scheduler_enabled())
-      st->pin_thread_counter = ST_THREAD_SCHEDULER_DISABLED;
+      st->thread_scheduler_disabled = true;
 
    st->bitmap.cache.empty = true;
 
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 3e943a3cf75b1..5bfe1907a69ea 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -39,7 +39,7 @@
 #include "vbo/vbo.h"
 #include "util/list.h"
 #include "cso_cache/cso_context.h"
-
+#include "util/u_cpu_detect.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -53,8 +53,6 @@ struct st_context;
 struct st_program;
 struct u_upload_mgr;
 
-#define ST_THREAD_SCHEDULER_DISABLED 0xffffffff
-
 struct st_bitmap_cache
 {
    /** Window pos to render the cached image */
@@ -141,10 +139,12 @@ struct st_context
    struct draw_stage *selection_stage;  /**< For GL_SELECT rendermode */
    struct draw_stage *rastpos_stage;  /**< For glRasterPos */
 
-   unsigned pin_thread_counter; /* for L3 thread pinning on AMD Zen */
+   unsigned draw_counter; /* for L3 thread pinning on AMD Zen and resource pruning */
+   unsigned dispatch_counter; /* for L3 thread pinning on AMD Zen and resource pruning */
 
    GLboolean clamp_frag_color_in_shader;
    GLboolean clamp_vert_color_in_shader;
+   bool thread_scheduler_disabled;
    bool has_stencil_export; /**< can do shader stencil export? */
    bool has_time_elapsed;
    bool has_etc1;
@@ -522,6 +522,51 @@ st_screen_destroy(struct pipe_frontend_screen *fscreen);
 void
 st_prune_releasebufs(struct st_context *st, bool compute);
 
+static inline void
+st_context_apply_scheduler_policy(struct st_context *st)
+{
+   int cpu = util_get_current_cpu();
+   if (cpu >= 0) {
+      struct pipe_context *pipe = st->pipe;
+      uint16_t L3_cache = util_get_cpu_caps()->cpu_to_L3[cpu];
+
+      if (L3_cache != U_CPU_INVALID_L3) {
+         pipe->set_context_param(pipe,
+                                 PIPE_CONTEXT_PARAM_UPDATE_THREAD_SCHEDULING,
+                                 cpu);
+      }
+   }
+}
+
+static inline void
+st_context_add_draw(struct st_context *st)
+{
+
+   /* Apply our thread scheduling policy for better multithreading
+    * performance.
+    */
+   if (unlikely(++st->draw_counter % 512 == 0)) {
+      st->draw_counter = 0;
+      if (!st->thread_scheduler_disabled)
+         st_context_apply_scheduler_policy(st);
+   }
+}
+
+static inline void
+st_context_add_dispatch(struct st_context *st)
+{
+
+   /* Apply our thread scheduling policy for better multithreading
+    * performance.
+    */
+   if (unlikely(++st->dispatch_counter % 512 == 0)) {
+      st->dispatch_counter = 0;
+      if (!st->thread_scheduler_disabled)
+         st_context_apply_scheduler_policy(st);
+   }
+}
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 05dc67642cabf..ba405c449eafd 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -55,7 +55,6 @@
 
 #include "pipe/p_context.h"
 #include "pipe/p_defines.h"
-#include "util/u_cpu_detect.h"
 #include "util/u_inlines.h"
 #include "util/format/u_format.h"
 #include "util/u_prim.h"
@@ -87,27 +86,7 @@ st_prepare_draw(struct gl_context *ctx, uint64_t state_mask)
 
    /* Validate state. */
    st_validate_state(st, state_mask);
-
-   /* Apply our thread scheduling policy for better multithreading
-    * performance.
-    */
-   if (unlikely(st->pin_thread_counter != ST_THREAD_SCHEDULER_DISABLED &&
-                /* do it occasionally */
-                ++st->pin_thread_counter % 512 == 0)) {
-      st->pin_thread_counter = 0;
-
-      int cpu = util_get_current_cpu();
-      if (cpu >= 0) {
-         struct pipe_context *pipe = st->pipe;
-         uint16_t L3_cache = util_get_cpu_caps()->cpu_to_L3[cpu];
-
-         if (L3_cache != U_CPU_INVALID_L3) {
-            pipe->set_context_param(pipe,
-                                    PIPE_CONTEXT_PARAM_UPDATE_THREAD_SCHEDULING,
-                                    cpu);
-         }
-      }
-   }
+   st_context_add_draw(st);
 }
 
 void
-- 
GitLab


From 077249cb0da09cc2e6e9fa9dadc7e47f174a5016 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 29 Jul 2025 15:38:11 -0400
Subject: [PATCH 23/23] prune better?

---
 src/mesa/main/compute.c                        |  3 ---
 src/mesa/state_tracker/st_atom_array.cpp       |  3 +--
 src/mesa/state_tracker/st_atom_constbuf.c      | 18 ++++++------------
 src/mesa/state_tracker/st_context.c            | 13 +++++++++++++
 src/mesa/state_tracker/st_context.h            |  4 ++++
 src/mesa/state_tracker/st_draw.c               |  4 ----
 .../state_tracker/st_texcompress_compute.c     |  3 +--
 7 files changed, 25 insertions(+), 23 deletions(-)

diff --git a/src/mesa/main/compute.c b/src/mesa/main/compute.c
index 8a4daf5e9c4f5..1539af32471e1 100644
--- a/src/mesa/main/compute.c
+++ b/src/mesa/main/compute.c
@@ -330,7 +330,6 @@ dispatch_compute(GLuint num_groups_x, GLuint num_groups_y,
 
    prepare_compute(ctx);
    ctx->pipe->launch_grid(ctx->pipe, &info);
-   st_prune_releasebufs(ctx->st, true);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
       _mesa_flush(ctx);
@@ -376,7 +375,6 @@ dispatch_compute_indirect(GLintptr indirect, bool no_error)
 
    prepare_compute(ctx);
    ctx->pipe->launch_grid(ctx->pipe, &info);
-   st_prune_releasebufs(ctx->st, true);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
       _mesa_flush(ctx);
@@ -427,7 +425,6 @@ dispatch_compute_group_size(GLuint num_groups_x, GLuint num_groups_y,
 
    prepare_compute(ctx);
    ctx->pipe->launch_grid(ctx->pipe, &info);
-   st_prune_releasebufs(ctx->st, true);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
       _mesa_flush(ctx);
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 35182d5561eac..9dc118d118945 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -354,8 +354,7 @@ st_setup_current(struct st_context *st,
 
       /* Always unmap. The uploader might use explicit flushes. */
       u_upload_unmap(uploader);
-      if (releasebuf)
-         util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+      st_add_releasebuf(st, releasebuf, false);
    }
 }
 
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 57488caa3c3d2..d15ee3d9e6f77 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -237,8 +237,7 @@ st_update_vs_constants(struct st_context *st)
    struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->VertexProgram._Current,
                        MESA_SHADER_VERTEX, &releasebuf);
-   if (releasebuf)
-      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+   st_add_releasebuf(st, releasebuf, false);
 }
 
 /**
@@ -250,8 +249,7 @@ st_update_fs_constants(struct st_context *st)
    struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->FragmentProgram._Current,
                        MESA_SHADER_FRAGMENT, &releasebuf);
-   if (releasebuf)
-      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+   st_add_releasebuf(st, releasebuf, false);
 }
 
 
@@ -263,8 +261,7 @@ st_update_gs_constants(struct st_context *st)
    struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->GeometryProgram._Current,
                        MESA_SHADER_GEOMETRY, &releasebuf);
-   if (releasebuf)
-      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+   st_add_releasebuf(st, releasebuf, false);
 }
 
 /* Tessellation control shader:
@@ -275,8 +272,7 @@ st_update_tcs_constants(struct st_context *st)
    struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->TessCtrlProgram._Current,
                        MESA_SHADER_TESS_CTRL, &releasebuf);
-   if (releasebuf)
-      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+   st_add_releasebuf(st, releasebuf, false);
 }
 
 /* Tessellation evaluation shader:
@@ -287,8 +283,7 @@ st_update_tes_constants(struct st_context *st)
    struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->TessEvalProgram._Current,
                        MESA_SHADER_TESS_EVAL, &releasebuf);
-   if (releasebuf)
-      util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+   st_add_releasebuf(st, releasebuf, false);
 }
 
 /* Compute shader:
@@ -299,8 +294,7 @@ st_update_cs_constants(struct st_context *st)
    struct pipe_resource *releasebuf = NULL;
    st_upload_constants(st, st->ctx->ComputeProgram._Current,
                        MESA_SHADER_COMPUTE, &releasebuf);
-   if (releasebuf)
-      util_dynarray_append(&st->release_resources[1], struct pipe_resource*, releasebuf);
+   st_add_releasebuf(st, releasebuf, true);
 }
 
 static void
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 4736e44b93f0c..e0e3391fcff68 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -890,6 +890,19 @@ st_prune_releasebufs(struct st_context *st, bool compute)
    for (unsigned j = 0; j < count; j++)
       pipe_resource_release(st->pipe, pres[j]);
    util_dynarray_clear(&st->release_resources[compute]);
+   st->release_counter[compute] = 0;
+}
+
+void
+st_add_releasebuf(struct st_context *st, struct pipe_resource *releasebuf, bool compute)
+{
+   if (!releasebuf)
+      return;
+   const unsigned counter = compute ? st->dispatch_counter : st->draw_counter;
+   if (st->release_counter[compute] < counter)
+      st_prune_releasebufs(st, compute);
+   util_dynarray_append(&st->release_resources[compute], struct pipe_resource*, releasebuf);
+   st->release_counter[compute]++;
 }
 
 void
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 5bfe1907a69ea..79a2d4d6b7489 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -279,6 +279,7 @@ struct st_context
    };
 
    struct util_dynarray release_resources[2]; //[gfx, compute]
+   unsigned release_counter[2]; //[gfx, compute]
 
    struct st_common_variant *vp_variant;
 
@@ -522,6 +523,9 @@ st_screen_destroy(struct pipe_frontend_screen *fscreen);
 void
 st_prune_releasebufs(struct st_context *st, bool compute);
 
+void
+st_add_releasebuf(struct st_context *st, struct pipe_resource *releasebuf, bool compute);
+
 static inline void
 st_context_apply_scheduler_policy(struct st_context *st)
 {
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index ba405c449eafd..c3385175349e8 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -102,7 +102,6 @@ st_draw_gallium(struct gl_context *ctx,
    struct st_context *st = st_context(ctx);
 
    cso_draw_vbo(st->cso_context, info, drawid_offset, indirect, draws, num_draws);
-   st_prune_releasebufs(st, false);
 }
 
 static void
@@ -125,7 +124,6 @@ st_draw_gallium_multimode(struct gl_context *ctx,
          first = i;
       }
    }
-   st_prune_releasebufs(st, false);
 }
 
 static void
@@ -380,7 +378,6 @@ st_hw_select_draw_gallium(struct gl_context *ctx,
        st_draw_hw_select_prepare_mode(ctx, ((struct pipe_draw_info*)info))) {
       cso_draw_vbo(st->cso_context, info, drawid_offset, indirect, draws,
                    num_draws);
-      st_prune_releasebufs(st, false);
    }
 
    ((struct pipe_draw_info*)info)->mode = old_mode;
@@ -412,7 +409,6 @@ st_hw_select_draw_gallium_multimode(struct gl_context *ctx,
          first = i;
       }
    }
-   st_prune_releasebufs(st, false);
 }
 
 void
diff --git a/src/mesa/state_tracker/st_texcompress_compute.c b/src/mesa/state_tracker/st_texcompress_compute.c
index 5bbb4393222ac..7be406741f233 100644
--- a/src/mesa/state_tracker/st_texcompress_compute.c
+++ b/src/mesa/state_tracker/st_texcompress_compute.c
@@ -186,8 +186,7 @@ bind_compute_state(struct st_context *st,
       struct pipe_resource *releasebuf = NULL;
       st_upload_constants(st, constbuf0_from_prog ? prog : NULL,
                           prog->info.stage, &releasebuf);
-      if (releasebuf)
-         util_dynarray_append(&st->release_resources[0], struct pipe_resource*, releasebuf);
+      st_add_releasebuf(st, releasebuf, false);
    }
 
    if (prog->affected_states & ST_NEW_CS_UBOS) {
-- 
GitLab

