From b7f5c637ddc55ea07c4cad20ed547e141b8d97a0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 10 Nov 2023 11:35:43 +0100
Subject: [PATCH 1/5] aco/live_var_analysis: refactor using ctx struct

---
 src/amd/compiler/aco_live_var_analysis.cpp | 71 ++++++++++++----------
 1 file changed, 40 insertions(+), 31 deletions(-)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index 9160cb5558353..f3a19b7c58c95 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -91,6 +91,12 @@ struct PhiInfo {
    uint16_t linear_phi_defs = 0;
 };
 
+struct live_ctx {
+   Program* program;
+   std::vector<PhiInfo> phi_info;
+   unsigned worklist;
+};
+
 bool
 instr_needs_vcc(Instruction* instr)
 {
@@ -107,19 +113,18 @@ instr_needs_vcc(Instruction* instr)
 }
 
 void
-process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
-                             std::vector<PhiInfo>& phi_info)
+process_live_temps_per_block(live_ctx& ctx, Block* block)
 {
-   std::vector<RegisterDemand>& register_demand = program->live.register_demand[block->index];
+   std::vector<RegisterDemand>& register_demand = ctx.program->live.register_demand[block->index];
    RegisterDemand new_demand;
 
    register_demand.resize(block->instructions.size());
-   IDSet live = program->live.live_out[block->index];
+   IDSet live = ctx.program->live.live_out[block->index];
 
    /* initialize register demand */
    for (unsigned t : live)
-      new_demand += Temp(t, program->temp_rc[t]);
-   new_demand.sgpr -= phi_info[block->index].logical_phi_sgpr_ops;
+      new_demand += Temp(t, ctx.program->temp_rc[t]);
+   new_demand.sgpr -= ctx.phi_info[block->index].logical_phi_sgpr_ops;
 
    /* traverse the instructions backwards */
    int idx;
@@ -128,7 +133,7 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
       if (is_phi(insn))
          break;
 
-      program->needs_vcc |= instr_needs_vcc(insn);
+      ctx.program->needs_vcc |= instr_needs_vcc(insn);
       register_demand[idx] = RegisterDemand(new_demand.vgpr, new_demand.sgpr);
 
       /* KILL */
@@ -137,7 +142,7 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
             continue;
          }
          if (definition.isFixed() && definition.physReg() == vcc)
-            program->needs_vcc = true;
+            ctx.program->needs_vcc = true;
 
          const Temp temp = definition.getTemp();
          const size_t n = live.erase(temp.id());
@@ -153,7 +158,7 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
 
       /* GEN */
       if (insn->opcode == aco_opcode::p_logical_end) {
-         new_demand.sgpr += phi_info[block->index].logical_phi_sgpr_ops;
+         new_demand.sgpr += ctx.phi_info[block->index].logical_phi_sgpr_ops;
       } else {
          /* we need to do this in a separate loop because the next one can
           * setKill() for several operands at once and we don't want to
@@ -166,7 +171,7 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
             if (!operand.isTemp())
                continue;
             if (operand.isFixed() && operand.physReg() == vcc)
-               program->needs_vcc = true;
+               ctx.program->needs_vcc = true;
             const Temp temp = operand.getTemp();
             const bool inserted = live.insert(temp.id()).second;
             if (inserted) {
@@ -207,7 +212,7 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
       }
       Definition& definition = insn->definitions[0];
       if (definition.isFixed() && definition.physReg() == vcc)
-         program->needs_vcc = true;
+         ctx.program->needs_vcc = true;
       const Temp temp = definition.getTemp();
       const size_t n = live.erase(temp.id());
 
@@ -225,7 +230,7 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
    }
 
    for (unsigned pred_idx : block->linear_preds)
-      phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
+      ctx.phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
 
    /* now, we need to merge the live-ins into the live-out sets */
    bool fast_merge =
@@ -239,24 +244,24 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
 
    if (fast_merge) {
       for (unsigned pred_idx : block->linear_preds) {
-         if (program->live.live_out[pred_idx].insert(live))
-            worklist = std::max(worklist, pred_idx + 1);
+         if (ctx.program->live.live_out[pred_idx].insert(live))
+            ctx.worklist = std::max(ctx.worklist, pred_idx + 1);
       }
    } else {
       for (unsigned t : live) {
-         RegClass rc = program->temp_rc[t];
+         RegClass rc = ctx.program->temp_rc[t];
          Block::edge_vec& preds = rc.is_linear() ? block->linear_preds : block->logical_preds;
 
 #ifndef NDEBUG
          if (preds.empty())
-            aco_err(program, "Temporary never defined or are defined after use: %%%d in BB%d", t,
-                    block->index);
+            aco_err(ctx.program, "Temporary never defined or are defined after use: %%%d in BB%d",
+                    t, block->index);
 #endif
 
          for (unsigned pred_idx : preds) {
-            auto it = program->live.live_out[pred_idx].insert(t);
+            auto it = ctx.program->live.live_out[pred_idx].insert(t);
             if (it.second)
-               worklist = std::max(worklist, pred_idx + 1);
+               ctx.worklist = std::max(ctx.worklist, pred_idx + 1);
          }
       }
    }
@@ -274,16 +279,16 @@ process_live_temps_per_block(Program* program, Block* block, unsigned& worklist,
          if (!operand.isTemp())
             continue;
          if (operand.isFixed() && operand.physReg() == vcc)
-            program->needs_vcc = true;
+            ctx.program->needs_vcc = true;
          /* check if we changed an already processed block */
-         const bool inserted = program->live.live_out[preds[i]].insert(operand.tempId()).second;
+         const bool inserted = ctx.program->live.live_out[preds[i]].insert(operand.tempId()).second;
          if (inserted) {
-            worklist = std::max(worklist, preds[i] + 1);
+            ctx.worklist = std::max(ctx.worklist, preds[i] + 1);
             if (insn->opcode == aco_opcode::p_phi && operand.getTemp().type() == RegType::sgpr) {
-               phi_info[preds[i]].logical_phi_sgpr_ops += operand.size();
+               ctx.phi_info[preds[i]].logical_phi_sgpr_ops += operand.size();
             } else if (insn->opcode == aco_opcode::p_linear_phi) {
                assert(operand.getTemp().type() == RegType::sgpr);
-               phi_info[preds[i]].linear_phi_ops += operand.size();
+               ctx.phi_info[preds[i]].linear_phi_ops += operand.size();
             }
          }
 
@@ -462,25 +467,29 @@ live_var_analysis(Program* program)
    program->live.memory.release();
    program->live.live_out.resize(program->blocks.size(), IDSet(program->live.memory));
    program->live.register_demand.resize(program->blocks.size());
-   unsigned worklist = program->blocks.size();
-   std::vector<PhiInfo> phi_info(program->blocks.size());
+
+   live_ctx ctx{
+      program,
+      std::vector<PhiInfo>(program->blocks.size()),
+      unsigned(program->blocks.size()),
+   };
    RegisterDemand new_demand;
 
    program->needs_vcc = program->gfx_level >= GFX10;
 
    /* this implementation assumes that the block idx corresponds to the block's position in
     * program->blocks vector */
-   while (worklist) {
-      unsigned block_idx = --worklist;
-      process_live_temps_per_block(program, &program->blocks[block_idx], worklist, phi_info);
+   while (ctx.worklist) {
+      unsigned block_idx = --ctx.worklist;
+      process_live_temps_per_block(ctx, &program->blocks[block_idx]);
    }
 
    /* Handle branches: we will insert copies created for linear phis just before the branch. */
    for (Block& block : program->blocks) {
       program->live.register_demand[block.index].back().sgpr +=
-         phi_info[block.index].linear_phi_defs;
+         ctx.phi_info[block.index].linear_phi_defs;
       program->live.register_demand[block.index].back().sgpr -=
-         phi_info[block.index].linear_phi_ops;
+         ctx.phi_info[block.index].linear_phi_ops;
 
       /* update block's register demand */
       if (program->progress < CompilationProgress::after_ra) {
-- 
GitLab


From e915c56167752766fd0b31eff53c44a61393793b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 14 Nov 2023 16:57:16 +0100
Subject: [PATCH 2/5] aco/live_var_analysis: handle phis separately

---
 src/amd/compiler/aco_live_var_analysis.cpp | 94 ++++++++++++++--------
 1 file changed, 61 insertions(+), 33 deletions(-)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index f3a19b7c58c95..704c6ebe540ed 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -112,6 +112,31 @@ instr_needs_vcc(Instruction* instr)
    return false;
 }
 
+void
+handle_phi_operands(live_ctx& ctx)
+{
+   for (Block& block : ctx.program->blocks) {
+      for (aco_ptr<Instruction>& phi : block.instructions) {
+         if (!is_phi(phi))
+            break;
+
+         /* Directly insert into the predecessors' live-out set. */
+         Block::edge_vec& preds =
+            phi->opcode == aco_opcode::p_phi ? block.logical_preds : block.linear_preds;
+
+         for (unsigned i = 0; i < preds.size(); ++i) {
+            Operand& operand = phi->operands[i];
+            if (!operand.isTemp())
+               continue;
+            if (operand.isFixed() && operand.physReg() == vcc)
+               ctx.program->needs_vcc = true;
+
+            ctx.program->live.live_out[preds[i]].insert(operand.tempId());
+         }
+      }
+   }
+}
+
 void
 process_live_temps_per_block(live_ctx& ctx, Block* block)
 {
@@ -229,8 +254,40 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
       phi_idx--;
    }
 
-   for (unsigned pred_idx : block->linear_preds)
+   for (unsigned pred_idx : block->linear_preds) {
       ctx.phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
+      ctx.phi_info[pred_idx].linear_phi_ops = 0;
+   }
+   for (unsigned pred_idx : block->logical_preds) {
+      ctx.phi_info[pred_idx].logical_phi_sgpr_ops = 0;
+   }
+
+   /* handle phi operands */
+   phi_idx = idx;
+   while (phi_idx >= 0) {
+      Instruction* insn = block->instructions[phi_idx].get();
+      assert(is_phi(insn));
+
+      Block::edge_vec& preds =
+         insn->opcode == aco_opcode::p_phi ? block->logical_preds : block->linear_preds;
+      for (unsigned i = 0; i < preds.size(); ++i) {
+         Operand& operand = insn->operands[i];
+         if (!operand.isTemp())
+            continue;
+
+         const bool kill = !live.count(operand.tempId());
+         operand.setKill(kill);
+         if (kill) {
+            if (insn->opcode == aco_opcode::p_phi && operand.getTemp().type() == RegType::sgpr) {
+               ctx.phi_info[preds[i]].logical_phi_sgpr_ops += operand.size();
+            } else if (insn->opcode == aco_opcode::p_linear_phi) {
+               assert(operand.getTemp().type() == RegType::sgpr);
+               ctx.phi_info[preds[i]].linear_phi_ops += operand.size();
+            }
+         }
+      }
+      phi_idx--;
+   }
 
    /* now, we need to merge the live-ins into the live-out sets */
    bool fast_merge =
@@ -266,38 +323,6 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
       }
    }
 
-   /* handle phi operands */
-   phi_idx = idx;
-   while (phi_idx >= 0) {
-      Instruction* insn = block->instructions[phi_idx].get();
-      assert(is_phi(insn));
-      /* directly insert into the predecessors live-out set */
-      Block::edge_vec& preds =
-         insn->opcode == aco_opcode::p_phi ? block->logical_preds : block->linear_preds;
-      for (unsigned i = 0; i < preds.size(); ++i) {
-         Operand& operand = insn->operands[i];
-         if (!operand.isTemp())
-            continue;
-         if (operand.isFixed() && operand.physReg() == vcc)
-            ctx.program->needs_vcc = true;
-         /* check if we changed an already processed block */
-         const bool inserted = ctx.program->live.live_out[preds[i]].insert(operand.tempId()).second;
-         if (inserted) {
-            ctx.worklist = std::max(ctx.worklist, preds[i] + 1);
-            if (insn->opcode == aco_opcode::p_phi && operand.getTemp().type() == RegType::sgpr) {
-               ctx.phi_info[preds[i]].logical_phi_sgpr_ops += operand.size();
-            } else if (insn->opcode == aco_opcode::p_linear_phi) {
-               assert(operand.getTemp().type() == RegType::sgpr);
-               ctx.phi_info[preds[i]].linear_phi_ops += operand.size();
-            }
-         }
-
-         /* set if the operand is killed by this (or another) phi instruction */
-         operand.setKill(!live.count(operand.tempId()));
-      }
-      phi_idx--;
-   }
-
    assert(!block->linear_preds.empty() || (new_demand == RegisterDemand() && live.empty()));
 }
 
@@ -477,6 +502,9 @@ live_var_analysis(Program* program)
 
    program->needs_vcc = program->gfx_level >= GFX10;
 
+   /* First, insert all phi operands into live-out sets of the predecessors. */
+   handle_phi_operands(ctx);
+
    /* this implementation assumes that the block idx corresponds to the block's position in
     * program->blocks vector */
    while (ctx.worklist) {
-- 
GitLab


From 0ad9f5945bfb2c5a3662e610eda01443cf5c09dd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 9 Jan 2024 15:40:18 +0100
Subject: [PATCH 3/5] aco/live_var_analysis: apply logical_phi_sgpr_ops after
 live var analysis

---
 src/amd/compiler/aco_live_var_analysis.cpp | 23 +++++++++++++---------
 1 file changed, 14 insertions(+), 9 deletions(-)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index 704c6ebe540ed..3166c5c01a4a6 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -149,7 +149,6 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
    /* initialize register demand */
    for (unsigned t : live)
       new_demand += Temp(t, ctx.program->temp_rc[t]);
-   new_demand.sgpr -= ctx.phi_info[block->index].logical_phi_sgpr_ops;
 
    /* traverse the instructions backwards */
    int idx;
@@ -182,9 +181,7 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
       }
 
       /* GEN */
-      if (insn->opcode == aco_opcode::p_logical_end) {
-         new_demand.sgpr += ctx.phi_info[block->index].logical_phi_sgpr_ops;
-      } else {
+      {
          /* we need to do this in a separate loop because the next one can
           * setKill() for several operands at once and we don't want to
           * overwrite that in a later iteration */
@@ -512,12 +509,20 @@ live_var_analysis(Program* program)
       process_live_temps_per_block(ctx, &program->blocks[block_idx]);
    }
 
-   /* Handle branches: we will insert copies created for linear phis just before the branch. */
+   /* Handle branches: We will insert copies created for linear phis just before the branch.
+    * SGPR->VGPR copies for logical phis happen just before p_logical_end.
+    */
    for (Block& block : program->blocks) {
-      program->live.register_demand[block.index].back().sgpr +=
-         ctx.phi_info[block.index].linear_phi_defs;
-      program->live.register_demand[block.index].back().sgpr -=
-         ctx.phi_info[block.index].linear_phi_ops;
+      std::vector<RegisterDemand>& reg_demand = program->live.register_demand[block.index];
+      reg_demand.back().sgpr += ctx.phi_info[block.index].linear_phi_defs;
+      reg_demand.back().sgpr -= ctx.phi_info[block.index].linear_phi_ops;
+      if (ctx.phi_info[block.index].logical_phi_sgpr_ops) {
+         for (int i = block.instructions.size() - 1; i >= 0; i--) {
+            reg_demand[i].sgpr -= ctx.phi_info[block.index].logical_phi_sgpr_ops;
+            if (block.instructions[i]->opcode == aco_opcode::p_logical_end)
+               break;
+         }
+      }
 
       /* update block's register demand */
       if (program->progress < CompilationProgress::after_ra) {
-- 
GitLab


From ea24b41389238f3966ede7ac5bf03e6681c578d9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 14 Nov 2023 17:45:11 +0100
Subject: [PATCH 4/5] aco/live_var_analysis: simplify phi-handling

---
 src/amd/compiler/aco_live_var_analysis.cpp | 127 +++++++++------------
 1 file changed, 52 insertions(+), 75 deletions(-)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index 3166c5c01a4a6..1bb6d8ed80fae 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -137,6 +137,49 @@ handle_phi_operands(live_ctx& ctx)
    }
 }
 
+void
+procsss_phi_reg_changes(live_ctx& ctx, Block* block, IDSet& live)
+{
+   for (unsigned pred_idx : block->linear_preds)
+      ctx.phi_info[pred_idx].linear_phi_ops = 0;
+   for (unsigned pred_idx : block->logical_preds)
+      ctx.phi_info[pred_idx].logical_phi_sgpr_ops = 0;
+   uint16_t linear_phi_defs = 0;
+
+   for (unsigned j = 0; j < block->instructions.size(); j++) {
+      Instruction* insn = block->instructions[j].get();
+      if (!is_phi(insn))
+         break;
+
+      Block::edge_vec& preds =
+         insn->opcode == aco_opcode::p_phi ? block->logical_preds : block->linear_preds;
+      for (unsigned i = 0; i < preds.size(); ++i) {
+         Operand& operand = insn->operands[i];
+         if (!operand.isTemp())
+            continue;
+
+         const bool kill = !live.count(operand.tempId());
+         operand.setKill(kill);
+         if (kill) {
+            if (insn->opcode == aco_opcode::p_phi && operand.getTemp().type() == RegType::sgpr) {
+               ctx.phi_info[preds[i]].logical_phi_sgpr_ops += operand.size();
+            } else if (insn->opcode == aco_opcode::p_linear_phi) {
+               assert(operand.getTemp().type() == RegType::sgpr);
+               ctx.phi_info[preds[i]].linear_phi_ops += operand.size();
+            }
+         }
+      }
+
+      if (insn->opcode == aco_opcode::p_linear_phi && insn->definitions[0].isTemp()) {
+         assert(insn->definitions[0].getTemp().type() == RegType::sgpr);
+         linear_phi_defs += insn->definitions[0].size();
+      }
+   }
+
+   for (unsigned pred_idx : block->linear_preds)
+      ctx.phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
+}
+
 void
 process_live_temps_per_block(live_ctx& ctx, Block* block)
 {
@@ -154,8 +197,6 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
    int idx;
    for (idx = block->instructions.size() - 1; idx >= 0; idx--) {
       Instruction* insn = block->instructions[idx].get();
-      if (is_phi(insn))
-         break;
 
       ctx.program->needs_vcc |= instr_needs_vcc(insn);
       register_demand[idx] = RegisterDemand(new_demand.vgpr, new_demand.sgpr);
@@ -171,17 +212,17 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
          const Temp temp = definition.getTemp();
          const size_t n = live.erase(temp.id());
 
-         if (n) {
-            new_demand -= temp;
-            definition.setKill(false);
-         } else {
-            register_demand[idx] += temp;
-            definition.setKill(true);
+         if (!is_phi(insn)) {
+            if (n)
+               new_demand -= temp;
+            else
+               register_demand[idx] += temp;
          }
+         definition.setKill(!n);
       }
 
       /* GEN */
-      {
+      if (!is_phi(insn)) {
          /* we need to do this in a separate loop because the next one can
           * setKill() for several operands at once and we don't want to
           * overwrite that in a later iteration */
@@ -219,72 +260,8 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
       }
    }
 
-   /* handle phi definitions */
-   uint16_t linear_phi_defs = 0;
-   int phi_idx = idx;
-   while (phi_idx >= 0) {
-      register_demand[phi_idx] = new_demand;
-      Instruction* insn = block->instructions[phi_idx].get();
-
-      assert(is_phi(insn) && insn->definitions.size() == 1);
-      if (!insn->definitions[0].isTemp()) {
-         assert(insn->definitions[0].isFixed() && insn->definitions[0].physReg() == exec);
-         phi_idx--;
-         continue;
-      }
-      Definition& definition = insn->definitions[0];
-      if (definition.isFixed() && definition.physReg() == vcc)
-         ctx.program->needs_vcc = true;
-      const Temp temp = definition.getTemp();
-      const size_t n = live.erase(temp.id());
-
-      if (n)
-         definition.setKill(false);
-      else
-         definition.setKill(true);
-
-      if (insn->opcode == aco_opcode::p_linear_phi) {
-         assert(definition.getTemp().type() == RegType::sgpr);
-         linear_phi_defs += definition.size();
-      }
-
-      phi_idx--;
-   }
-
-   for (unsigned pred_idx : block->linear_preds) {
-      ctx.phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
-      ctx.phi_info[pred_idx].linear_phi_ops = 0;
-   }
-   for (unsigned pred_idx : block->logical_preds) {
-      ctx.phi_info[pred_idx].logical_phi_sgpr_ops = 0;
-   }
-
-   /* handle phi operands */
-   phi_idx = idx;
-   while (phi_idx >= 0) {
-      Instruction* insn = block->instructions[phi_idx].get();
-      assert(is_phi(insn));
-
-      Block::edge_vec& preds =
-         insn->opcode == aco_opcode::p_phi ? block->logical_preds : block->linear_preds;
-      for (unsigned i = 0; i < preds.size(); ++i) {
-         Operand& operand = insn->operands[i];
-         if (!operand.isTemp())
-            continue;
-
-         const bool kill = !live.count(operand.tempId());
-         operand.setKill(kill);
-         if (kill) {
-            if (insn->opcode == aco_opcode::p_phi && operand.getTemp().type() == RegType::sgpr) {
-               ctx.phi_info[preds[i]].logical_phi_sgpr_ops += operand.size();
-            } else if (insn->opcode == aco_opcode::p_linear_phi) {
-               assert(operand.getTemp().type() == RegType::sgpr);
-               ctx.phi_info[preds[i]].linear_phi_ops += operand.size();
-            }
-         }
-      }
-      phi_idx--;
-   }
+   /* Handle phis: fixup final register demand calculations */
+   procsss_phi_reg_changes(ctx, block, live);
 
    /* now, we need to merge the live-ins into the live-out sets */
    bool fast_merge =
-- 
GitLab


From 2896059bea2e51898d2044a3e6eec6368221d207 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 13 Nov 2023 10:01:29 +0100
Subject: [PATCH 5/5] aco/live_var_analysis: insert loop live variables into
 the entire loop at once

For reducible CFGs it holds that
- If a variable is live-in at the header of a loop then
  it is live at all nodes inside the loop.

We use property to directly insert the live-out variables into all blocks of the loop.
---
 src/amd/compiler/aco_live_var_analysis.cpp | 156 +++++++++++++++++----
 1 file changed, 126 insertions(+), 30 deletions(-)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index 1bb6d8ed80fae..e40b222918f3e 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -94,7 +94,8 @@ struct PhiInfo {
 struct live_ctx {
    Program* program;
    std::vector<PhiInfo> phi_info;
-   unsigned worklist;
+   std::vector<bool> live_out_complete;
+   std::vector<bool> reg_demand_complete;
 };
 
 bool
@@ -140,10 +141,6 @@ handle_phi_operands(live_ctx& ctx)
 void
 procsss_phi_reg_changes(live_ctx& ctx, Block* block, IDSet& live)
 {
-   for (unsigned pred_idx : block->linear_preds)
-      ctx.phi_info[pred_idx].linear_phi_ops = 0;
-   for (unsigned pred_idx : block->logical_preds)
-      ctx.phi_info[pred_idx].logical_phi_sgpr_ops = 0;
    uint16_t linear_phi_defs = 0;
 
    for (unsigned j = 0; j < block->instructions.size(); j++) {
@@ -180,6 +177,78 @@ procsss_phi_reg_changes(live_ctx& ctx, Block* block, IDSet& live)
       ctx.phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
 }
 
+/* For reducible CFGs it holds that
+ * - If a variable is live-in at the header of a loop then
+ *   it is live at all nodes inside the loop.
+ *
+ * We use this property to directly insert the live-out variables into all
+ * blocks of the loop.
+ */
+void
+insert_loop_lives(live_ctx& ctx, Block* loop_header, IDSet& live)
+{
+   unsigned loop_header_idx = loop_header->index;
+
+   /* Insert into preheader */
+   ctx.program->live.live_out[loop_header_idx - 1].insert(live);
+   ctx.live_out_complete[loop_header_idx - 1] = true;
+
+   std::vector<uint32_t> logical_blocks = {loop_header_idx};
+   std::vector<uint32_t> linear_blocks;
+
+   while (!logical_blocks.empty()) {
+      unsigned block_idx = logical_blocks.back();
+      logical_blocks.pop_back();
+      if (ctx.live_out_complete[block_idx])
+         continue;
+
+      ctx.program->live.live_out[block_idx].insert(live);
+      ctx.live_out_complete[block_idx] = true;
+
+      const Block& block = ctx.program->blocks[block_idx];
+      for (const unsigned pred : block.logical_preds) {
+         if (!ctx.live_out_complete[pred])
+            logical_blocks.emplace_back(pred);
+      }
+      for (const unsigned pred : block.linear_preds)
+         if (!ctx.live_out_complete[pred])
+            linear_blocks.emplace_back(pred);
+   }
+
+   while (!linear_blocks.empty() && ctx.live_out_complete[linear_blocks.back()])
+      linear_blocks.pop_back();
+
+   if (!linear_blocks.empty()) {
+      IDSet linear_set = IDSet(ctx.program->live.memory);
+      for (unsigned id : live) {
+         if (ctx.program->temp_rc[id].is_linear())
+            linear_set.insert(id);
+      }
+
+      while (!linear_blocks.empty()) {
+         unsigned block_idx = linear_blocks.back();
+         linear_blocks.pop_back();
+         if (ctx.live_out_complete[block_idx])
+            continue;
+
+         ctx.program->live.live_out[block_idx].insert(linear_set);
+         ctx.live_out_complete[block_idx] = true;
+
+         const Block& block = ctx.program->blocks[block_idx];
+         for (unsigned pred : block.linear_preds)
+            if (!ctx.live_out_complete[pred])
+               linear_blocks.emplace_back(pred);
+      }
+   }
+
+   unsigned loop_exit_idx = loop_header->linear_preds.back() + 1;
+   assert(ctx.program->blocks[loop_exit_idx].kind & block_kind_loop_exit);
+   const bool live_out_complete = ctx.reg_demand_complete[loop_exit_idx];
+   std::fill(std::next(ctx.live_out_complete.begin(), loop_header_idx),
+             std::next(ctx.live_out_complete.begin(), loop_exit_idx), live_out_complete);
+   ctx.live_out_complete[loop_header_idx - 1] = false;
+}
+
 void
 process_live_temps_per_block(live_ctx& ctx, Block* block)
 {
@@ -190,8 +259,17 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
    IDSet live = ctx.program->live.live_out[block->index];
 
    /* initialize register demand */
-   for (unsigned t : live)
-      new_demand += Temp(t, ctx.program->temp_rc[t]);
+   const bool live_out_complete = ctx.live_out_complete[block->index];
+   const bool update_reg_demand =
+      live_out_complete || std::all_of(block->linear_succs.begin(), block->linear_succs.end(),
+                                       [&](unsigned succ) { return ctx.live_out_complete[succ]; });
+   if (update_reg_demand) {
+      for (unsigned t : live)
+         new_demand += Temp(t, ctx.program->temp_rc[t]);
+
+      ctx.live_out_complete[block->index] = true;
+      ctx.reg_demand_complete[block->index] = true;
+   }
 
    /* traverse the instructions backwards */
    int idx;
@@ -260,8 +338,10 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
       }
    }
 
-   /* Handle phis: fixup final register demand calculations */
-   procsss_phi_reg_changes(ctx, block, live);
+   if (update_reg_demand) {
+      /* Handle phis: fixup final register demand calculations */
+      procsss_phi_reg_changes(ctx, block, live);
+   }
 
    /* now, we need to merge the live-ins into the live-out sets */
    bool fast_merge =
@@ -273,11 +353,13 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
       fast_merge = false; /* we might have errors */
 #endif
 
-   if (fast_merge) {
-      for (unsigned pred_idx : block->linear_preds) {
-         if (ctx.program->live.live_out[pred_idx].insert(live))
-            ctx.worklist = std::max(ctx.worklist, pred_idx + 1);
-      }
+   if (live_out_complete) {
+      /* Live-out have been inserted in a previous iteration. */
+   } else if (block->kind & block_kind_loop_header && block->linear_preds.size() > 1) {
+      insert_loop_lives(ctx, block, live);
+   } else if (fast_merge) {
+      for (unsigned pred_idx : block->linear_preds)
+         ctx.program->live.live_out[pred_idx].insert(live);
    } else {
       for (unsigned t : live) {
          RegClass rc = ctx.program->temp_rc[t];
@@ -289,11 +371,8 @@ process_live_temps_per_block(live_ctx& ctx, Block* block)
                     t, block->index);
 #endif
 
-         for (unsigned pred_idx : preds) {
-            auto it = ctx.program->live.live_out[pred_idx].insert(t);
-            if (it.second)
-               ctx.worklist = std::max(ctx.worklist, pred_idx + 1);
-         }
+         for (unsigned pred_idx : preds)
+            ctx.program->live.live_out[pred_idx].insert(t);
       }
    }
 
@@ -462,6 +541,12 @@ update_vgpr_sgpr_demand(Program* program, const RegisterDemand new_demand)
 void
 live_var_analysis(Program* program)
 {
+   /* This algorithm implements 'Liveness Sets On Reducible Graphs' from
+    * "Computing Liveness Sets for SSA-Form Programs" by F. Brandner et al.
+    *
+    * Note, that this implementation assumes that the block idx corresponds to the
+    * block's position in program->blocks vector.
+    */
    program->live.live_out.clear();
    program->live.memory.release();
    program->live.live_out.resize(program->blocks.size(), IDSet(program->live.memory));
@@ -470,26 +555,37 @@ live_var_analysis(Program* program)
    live_ctx ctx{
       program,
       std::vector<PhiInfo>(program->blocks.size()),
-      unsigned(program->blocks.size()),
+      std::vector<bool>(program->blocks.size()),
+      std::vector<bool>(program->blocks.size()),
    };
-   RegisterDemand new_demand;
 
    program->needs_vcc = program->gfx_level >= GFX10;
 
    /* First, insert all phi operands into live-out sets of the predecessors. */
    handle_phi_operands(ctx);
 
-   /* this implementation assumes that the block idx corresponds to the block's position in
-    * program->blocks vector */
-   while (ctx.worklist) {
-      unsigned block_idx = --ctx.worklist;
-      process_live_temps_per_block(ctx, &program->blocks[block_idx]);
+   /* Second, calculate complete live-out sets of all blocks by
+    * - computing partial liveness sets using postorder traversal.
+    * - propagating live variables withing loop bodies.
+    */
+   for (int i = program->blocks.size() - 1; i >= 0; i--)
+      process_live_temps_per_block(ctx, &program->blocks[i]);
+
+   /* Third, calculate register demand within loop bodies. */
+   for (int i = program->blocks.size() - 1; i >= 0; i--) {
+      assert(ctx.live_out_complete[i]);
+      if (!ctx.reg_demand_complete[i])
+         process_live_temps_per_block(ctx, &program->blocks[i]);
    }
 
-   /* Handle branches: We will insert copies created for linear phis just before the branch.
-    * SGPR->VGPR copies for logical phis happen just before p_logical_end.
-    */
+   /* Final register demand calculation. */
+   RegisterDemand new_demand;
    for (Block& block : program->blocks) {
+      /* Handle branches: Fixup the register demand changes caused by phis.
+       *
+       * We will insert copies created for linear phis just before the branch.
+       * SGPR->VGPR copies for logical phis happen just before p_logical_end.
+       */
       std::vector<RegisterDemand>& reg_demand = program->live.register_demand[block.index];
       reg_demand.back().sgpr += ctx.phi_info[block.index].linear_phi_defs;
       reg_demand.back().sgpr -= ctx.phi_info[block.index].linear_phi_ops;
@@ -501,7 +597,7 @@ live_var_analysis(Program* program)
          }
       }
 
-      /* update block's register demand */
+      /* Update block's register demand */
       if (program->progress < CompilationProgress::after_ra) {
          block.register_demand = RegisterDemand();
          for (RegisterDemand& demand : program->live.register_demand[block.index])
-- 
GitLab

