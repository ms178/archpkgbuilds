From 425c094ca78b1bb69361faf4bc307a1802b18f91 Mon Sep 17 00:00:00 2001
From: Friedrich Vock <friedrich.vock@gmx.de>
Date: Wed, 22 May 2024 10:49:20 +0200
Subject: [PATCH] nir/opt_loop: Don't peel header blocks that jump

This pass is run before nir_opt_dead_cf, so if-statements
following unconditional jumps aren't cleaned up yet.
This can cause "break"/"continue"-statements to be placed
outside the loop they're intended for. Peeling makes no
sense here, since nir_opt_dead_cf will clean up the loop
anyway.

Cc: mesa-stable
---
 src/compiler/nir/nir_opt_loop.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/compiler/nir/nir_opt_loop.c b/src/compiler/nir/nir_opt_loop.c
index 5ff42d6d67acb..d569ffce2cf25 100644
--- a/src/compiler/nir/nir_opt_loop.c
+++ b/src/compiler/nir/nir_opt_loop.c
@@ -381,6 +381,12 @@ opt_loop_peel_initial_break(nir_loop *loop)
    nir_block *prev_block = nir_cf_node_cf_tree_prev(&loop->cf_node);
    nir_block *exit_block = nir_cf_node_cf_tree_next(&loop->cf_node);
 
+   /* If we immediately continue/break out from the header block,
+    * we can't extract it since we'd be extracting the break as well.
+    * Instead, let nir_opt_dead_cf clean up the rest of the loop. */
+   if (nir_block_ends_in_jump(header_block))
+      return false;
+
    /* The loop must have exactly one continue block. */
    if (header_block->predecessors->entries != 2)
       return false;
-- 
GitLab

