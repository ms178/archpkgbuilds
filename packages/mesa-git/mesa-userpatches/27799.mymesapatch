From 1d77c82a3b6989bf57d70220daebab89bd137993 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 25 Mar 2024 18:08:29 +0100
Subject: [PATCH 1/9] aco/spill: Fix assertion for nested loops

Fixes: 898fd9227a7e4d5bf2a6ff5c3cce17dc7d0fc964 ('aco/spill: keep loop variables spilled during nested loops')
---
 src/amd/compiler/aco_spill.cpp | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 92304dfacaf72..999b2bb5fee7c 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -545,9 +545,13 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       if (!ctx.loop.empty()) {
          /* If this is a nested loop, keep variables from the outer loop spilled. */
          for (auto spilled : ctx.loop.back().spills) {
-            assert(next_use_distances.count(spilled.first));
-
-            if (ctx.spills_entry[block_idx].insert(spilled).second) {
+            /* If the outer loop is not an actual loop, the loop-carried variables
+             * might not be live-in for the inner loop.
+             */
+            assert(next_use_distances.count(spilled.first) ||
+                   ctx.program->blocks[ctx.loop.back().index].linear_preds.size() == 1);
+            if (next_use_distances.count(spilled.first) &&
+                ctx.spills_entry[block_idx].insert(spilled).second) {
                spilled_registers += spilled.first;
                loop_demand -= spilled.first;
             }
-- 
GitLab


From 798fc6218a2836f7c8606dfe167104f04b2ba089 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 15 Feb 2024 12:11:27 +0100
Subject: [PATCH 2/9] aco/spill: pass live_vars to spill_ctx

We will use them in future commits.
---
 src/amd/compiler/aco_spill.cpp | 29 ++++++++++++++---------------
 1 file changed, 14 insertions(+), 15 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 999b2bb5fee7c..9af4c3a6328c7 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -73,7 +73,7 @@ struct spill_ctx {
    Program* program;
    aco::monotonic_buffer_resource memory;
 
-   std::vector<std::vector<RegisterDemand>> register_demand;
+   live& live_vars;
    std::vector<aco::map<Temp, Temp>> renames;
    std::vector<aco::unordered_map<Temp, uint32_t>> spills_entry;
    std::vector<aco::unordered_map<Temp, uint32_t>> spills_exit;
@@ -96,10 +96,8 @@ struct spill_ctx {
    unsigned vgpr_spill_slots;
    Temp scratch_rsrc;
 
-   spill_ctx(const RegisterDemand target_pressure_, Program* program_,
-             std::vector<std::vector<RegisterDemand>> register_demand_)
-       : target_pressure(target_pressure_), program(program_), memory(),
-         register_demand(std::move(register_demand_)),
+   spill_ctx(const RegisterDemand target_pressure_, Program* program_, live& live_vars_)
+       : target_pressure(target_pressure_), program(program_), memory(), live_vars(live_vars_),
          renames(program->blocks.size(), aco::map<Temp, Temp>(memory)),
          spills_entry(program->blocks.size(), aco::unordered_map<Temp, uint32_t>(memory)),
          spills_exit(program->blocks.size(), aco::unordered_map<Temp, uint32_t>(memory)),
@@ -466,12 +464,12 @@ RegisterDemand
 get_demand_before(spill_ctx& ctx, unsigned block_idx, unsigned idx)
 {
    if (idx == 0) {
-      RegisterDemand demand = ctx.register_demand[block_idx][idx];
+      RegisterDemand demand = ctx.live_vars.register_demand[block_idx][idx];
       aco_ptr<Instruction>& instr = ctx.program->blocks[block_idx].instructions[idx];
       aco_ptr<Instruction> instr_before(nullptr);
       return get_demand_before(demand, instr, instr_before);
    } else {
-      return ctx.register_demand[block_idx][idx - 1];
+      return ctx.live_vars.register_demand[block_idx][idx - 1];
    }
 }
 
@@ -501,7 +499,7 @@ get_live_in_demand(spill_ctx& ctx, unsigned block_idx)
     * reg_pressure if the branch instructions define sgprs. */
    for (unsigned pred : block.linear_preds)
       reg_pressure.sgpr =
-         std::max<int16_t>(reg_pressure.sgpr, ctx.register_demand[pred].back().sgpr);
+         std::max<int16_t>(reg_pressure.sgpr, ctx.live_vars.register_demand[pred].back().sgpr);
 
    return reg_pressure;
 }
@@ -780,7 +778,7 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
    if (block->linear_preds.size() == 1 &&
        !(block->kind & (block_kind_loop_exit | block_kind_loop_header))) {
       assert(ctx.processed[block->linear_preds[0]]);
-      assert(ctx.register_demand[block_idx].size() == block->instructions.size());
+      assert(ctx.live_vars.register_demand[block_idx].size() == block->instructions.size());
 
       ctx.renames[block_idx] = ctx.renames[block->linear_preds[0]];
       if (!block->logical_preds.empty() && block->logical_preds[0] != block->linear_preds[0]) {
@@ -1093,10 +1091,11 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
    if (!ctx.processed[block_idx]) {
       assert(!(block->kind & block_kind_loop_header));
       RegisterDemand demand_before = get_demand_before(ctx, block_idx, idx);
-      ctx.register_demand[block->index].erase(ctx.register_demand[block->index].begin(),
-                                              ctx.register_demand[block->index].begin() + idx);
-      ctx.register_demand[block->index].insert(ctx.register_demand[block->index].begin(),
-                                               instructions.size(), demand_before);
+      ctx.live_vars.register_demand[block->index].erase(
+         ctx.live_vars.register_demand[block->index].begin(),
+         ctx.live_vars.register_demand[block->index].begin() + idx);
+      ctx.live_vars.register_demand[block->index].insert(
+         ctx.live_vars.register_demand[block->index].begin(), instructions.size(), demand_before);
    }
 
    std::vector<aco_ptr<Instruction>>::iterator start = std::next(block->instructions.begin(), idx);
@@ -1172,7 +1171,7 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
       /* check if register demand is low enough before and after the current instruction */
       if (block->register_demand.exceeds(ctx.target_pressure)) {
 
-         RegisterDemand new_demand = ctx.register_demand[block_idx][idx];
+         RegisterDemand new_demand = ctx.live_vars.register_demand[block_idx][idx];
          new_demand.update(get_demand_before(ctx, block_idx, idx));
 
          assert(!ctx.local_next_use_distance.empty());
@@ -1883,7 +1882,7 @@ spill(Program* program, live& live_vars)
    const RegisterDemand target(vgpr_limit - extra_vgprs, sgpr_limit - extra_sgprs);
 
    /* initialize ctx */
-   spill_ctx ctx(target, program, live_vars.register_demand);
+   spill_ctx ctx(target, program, live_vars);
    compute_global_next_uses(ctx);
    get_rematerialize_info(ctx);
 
-- 
GitLab


From c6c4d34c48a3746068951a1e77be45ceb784496a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 15 Feb 2024 16:01:47 +0100
Subject: [PATCH 3/9] aco/spill: compute live-in variables from live-out

---
 src/amd/compiler/aco_spill.cpp | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 9af4c3a6328c7..4269d2eac0a5d 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -171,6 +171,30 @@ struct spill_ctx {
    uint32_t next_spill_id = 0;
 };
 
+void
+compute_live_in(spill_ctx& ctx)
+{
+   for (Block& block : ctx.program->blocks) {
+      IDSet& live_set = ctx.live_vars.live_out[block.index];
+
+      for (int i = block.instructions.size() - 1; i >= 0; i--) {
+         aco_ptr<Instruction>& instr = block.instructions[i];
+         const bool phi = is_phi(instr);
+
+         for (const Definition& def : instr->definitions) {
+            if (!phi && def.isTemp() && !def.isKill())
+               live_set.erase(def.tempId());
+         }
+         for (const Operand& op : instr->operands) {
+            if (op.isTemp()) {
+               if (!phi && op.isFirstKill())
+                  live_set.insert(op.tempId());
+            }
+         }
+      }
+   }
+}
+
 int32_t
 get_dominator(int idx_a, int idx_b, Program* program, bool is_linear)
 {
@@ -1883,6 +1907,7 @@ spill(Program* program, live& live_vars)
 
    /* initialize ctx */
    spill_ctx ctx(target, program, live_vars);
+   compute_live_in(ctx);
    compute_global_next_uses(ctx);
    get_rematerialize_info(ctx);
 
-- 
GitLab


From efff8ea53c73951b941030dc899a8a300ea5cf4b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 16 Feb 2024 10:53:10 +0100
Subject: [PATCH 4/9] aco/spill: maintain valid live vars at any point

In order to do so, we need to process blocks unconditionally.
---
 src/amd/compiler/aco_spill.cpp | 30 +++++++++++++-----------------
 1 file changed, 13 insertions(+), 17 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 4269d2eac0a5d..ec75b94d72f0d 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -33,7 +33,6 @@
 #include <cstring>
 #include <map>
 #include <set>
-#include <stack>
 #include <unordered_map>
 #include <unordered_set>
 #include <vector>
@@ -66,6 +65,7 @@ struct remat_info {
 struct loop_info {
    uint32_t index;
    aco::unordered_map<Temp, uint32_t> spills;
+   IDSet live_in;
 };
 
 struct spill_ctx {
@@ -619,7 +619,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       }
 
       /* create new loop_info */
-      loop_info info = {block_idx, ctx.spills_entry[block_idx]};
+      loop_info info = {block_idx, ctx.spills_entry[block_idx], ctx.live_vars.live_out[block_idx]};
       ctx.loop.emplace_back(std::move(info));
 
       /* shortcut */
@@ -1169,6 +1169,10 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
       for (Operand& op : instr->operands) {
          if (!op.isTemp())
             continue;
+
+         if (op.isFirstKill())
+            ctx.live_vars.live_out[block_idx].erase(op.tempId());
+
          if (!current_spills.count(op.getTemp())) {
             /* the Operand is in register: check if it was renamed */
             auto rename_it = ctx.renames[block_idx].find(op.getTemp());
@@ -1264,6 +1268,11 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
          }
       }
 
+      for (const Definition& def : instr->definitions) {
+         if (def.isTemp() && !def.isKill())
+            ctx.live_vars.live_out[block_idx].insert(def.tempId());
+      }
+
       /* add reloads and instruction to new instructions */
       for (std::pair<const Temp, std::pair<Temp, uint32_t>>& pair : reloads) {
          aco_ptr<Instruction> reload =
@@ -1290,22 +1299,9 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
       add_coupling_code(ctx, block, block_idx);
    }
 
-   const auto& current_spills = ctx.spills_entry[block_idx];
-
-   /* check conditions to process this block */
-   bool process = (block->register_demand - spilled_registers).exceeds(ctx.target_pressure) ||
-                  !ctx.renames[block_idx].empty() || ctx.unused_remats.size();
-
-   for (auto it = current_spills.begin(); !process && it != current_spills.end(); ++it) {
-      if (ctx.next_use_distances_start[block_idx].at(it->first).first == block_idx)
-         process = true;
-   }
-
    assert(ctx.spills_exit[block_idx].empty());
-   ctx.spills_exit[block_idx] = current_spills;
-   if (process) {
-      process_block(ctx, block_idx, block, spilled_registers);
-   }
+   ctx.spills_exit[block_idx] = ctx.spills_entry[block_idx];
+   process_block(ctx, block_idx, block, spilled_registers);
 
    ctx.processed[block_idx] = true;
 
-- 
GitLab


From 0a82c1022e92464f1c79173cc5798cfae7feb28f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 15 Feb 2024 14:57:06 +0100
Subject: [PATCH 5/9] aco/spill: use live variables instead of
 next_use_distances in add_coupling_code()

---
 src/amd/compiler/aco_spill.cpp | 69 +++++++++++++++++-----------------
 1 file changed, 35 insertions(+), 34 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index ec75b94d72f0d..b53bbcf7c5825 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -792,8 +792,9 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
 }
 
 void
-add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
+add_coupling_code(spill_ctx& ctx, Block* block, IDSet& live_in)
 {
+   const unsigned block_idx = block->index;
    /* No coupling code necessary */
    if (block->linear_preds.size() == 0)
       return;
@@ -904,7 +905,7 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
 
       for (unsigned pred_idx : preds) {
          /* variable is dead at predecessor, it must be from a phi: this works because of CSSA form */
-         if (!ctx.next_use_distances_end[pred_idx].count(pair.first))
+         if (!ctx.live_vars.live_out[pred_idx].count(pair.first.id()))
             continue;
 
          /* variable is already spilled at predecessor */
@@ -1017,60 +1018,60 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
    }
 
    /* iterate live variables for which to reload */
-   // TODO: reload at current block if variable is spilled on all predecessors
-   for (std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair :
-        ctx.next_use_distances_start[block_idx]) {
+   for (unsigned t : live_in) {
+      const RegClass rc = ctx.program->temp_rc[t];
+      Temp var = Temp(t, rc);
+
       /* skip spilled variables */
-      if (ctx.spills_entry[block_idx].count(pair.first))
+      if (ctx.spills_entry[block_idx].count(var))
          continue;
-      Block::edge_vec& preds = pair.first.is_linear() ? block->linear_preds : block->logical_preds;
 
-      /* variable is dead at predecessor, it must be from a phi */
-      bool is_dead = false;
-      for (unsigned pred_idx : preds) {
-         if (!ctx.next_use_distances_end[pred_idx].count(pair.first))
-            is_dead = true;
-      }
+      Block::edge_vec& preds = rc.is_linear() ? block->linear_preds : block->logical_preds;
+      /* if a variable is dead at any predecessor, it must be from a phi */
+      const bool is_dead =
+         std::any_of(preds.begin(), preds.end(),
+                     [&](unsigned pred) { return !ctx.live_vars.live_out[pred].count(var.id()); });
       if (is_dead)
          continue;
+
       for (unsigned pred_idx : preds) {
-         /* the variable is not spilled at the predecessor */
-         if (!ctx.spills_exit[pred_idx].count(pair.first))
+         /* skip if the variable is not spilled at the predecessor */
+         if (!ctx.spills_exit[pred_idx].count(var))
             continue;
 
          /* variable is spilled at predecessor and has to be reloaded */
-         Temp new_name = ctx.program->allocateTmp(pair.first.regClass());
+         Temp new_name = ctx.program->allocateTmp(rc);
          Block& pred = ctx.program->blocks[pred_idx];
          unsigned idx = pred.instructions.size();
          do {
             assert(idx != 0);
             idx--;
-         } while (pair.first.type() == RegType::vgpr &&
+         } while (rc.type() == RegType::vgpr &&
                   pred.instructions[idx]->opcode != aco_opcode::p_logical_end);
          std::vector<aco_ptr<Instruction>>::iterator it = std::next(pred.instructions.begin(), idx);
 
          aco_ptr<Instruction> reload =
-            do_reload(ctx, pair.first, new_name, ctx.spills_exit[pred.index][pair.first]);
+            do_reload(ctx, var, new_name, ctx.spills_exit[pred.index][var]);
          pred.instructions.insert(it, std::move(reload));
 
-         ctx.spills_exit[pred.index].erase(pair.first);
-         ctx.renames[pred.index][pair.first] = new_name;
+         ctx.spills_exit[pred.index].erase(var);
+         ctx.renames[pred.index][var] = new_name;
       }
 
       /* check if we have to create a new phi for this variable */
       Temp rename = Temp();
       bool is_same = true;
       for (unsigned pred_idx : preds) {
-         if (!ctx.renames[pred_idx].count(pair.first)) {
+         if (!ctx.renames[pred_idx].count(var)) {
             if (rename == Temp())
-               rename = pair.first;
+               rename = var;
             else
-               is_same = rename == pair.first;
+               is_same = rename == var;
          } else {
             if (rename == Temp())
-               rename = ctx.renames[pred_idx][pair.first];
+               rename = ctx.renames[pred_idx][var];
             else
-               is_same = rename == ctx.renames[pred_idx][pair.first];
+               is_same = rename == ctx.renames[pred_idx][var];
          }
 
          if (!is_same)
@@ -1079,18 +1080,18 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
 
       if (!is_same) {
          /* the variable was renamed differently in the predecessors: we have to create a phi */
-         aco_opcode opcode = pair.first.is_linear() ? aco_opcode::p_linear_phi : aco_opcode::p_phi;
+         aco_opcode opcode = rc.is_linear() ? aco_opcode::p_linear_phi : aco_opcode::p_phi;
          aco_ptr<Pseudo_instruction> phi{
             create_instruction<Pseudo_instruction>(opcode, Format::PSEUDO, preds.size(), 1)};
-         rename = ctx.program->allocateTmp(pair.first.regClass());
+         rename = ctx.program->allocateTmp(rc);
          for (unsigned i = 0; i < phi->operands.size(); i++) {
             Temp tmp;
-            if (ctx.renames[preds[i]].count(pair.first)) {
-               tmp = ctx.renames[preds[i]][pair.first];
+            if (ctx.renames[preds[i]].count(var)) {
+               tmp = ctx.renames[preds[i]][var];
             } else if (preds[i] >= block_idx) {
                tmp = rename;
             } else {
-               tmp = pair.first;
+               tmp = var;
                /* prevent the defining instruction from being DCE'd if it could be rematerialized */
                if (ctx.remat.count(tmp))
                   ctx.unused_remats.erase(ctx.remat[tmp].instr);
@@ -1102,8 +1103,8 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
       }
 
       /* the variable was renamed: add new name to renames */
-      if (!(rename == Temp() || rename == pair.first))
-         ctx.renames[block_idx][pair.first] = rename;
+      if (!(rename == Temp() || rename == var))
+         ctx.renames[block_idx][var] = rename;
    }
 
    /* combine phis with instructions */
@@ -1296,7 +1297,7 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
 
    if (!(block->kind & block_kind_loop_header)) {
       /* add spill/reload code on incoming control flow edges */
-      add_coupling_code(ctx, block, block_idx);
+      add_coupling_code(ctx, block, ctx.live_vars.live_out[block_idx]);
    }
 
    assert(ctx.spills_exit[block_idx].empty());
@@ -1316,7 +1317,7 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
    aco::map<Temp, Temp> renames = std::move(ctx.renames[loop_header_idx]);
 
    /* add coupling code to all loop header predecessors */
-   add_coupling_code(ctx, &ctx.program->blocks[loop_header_idx], loop_header_idx);
+   add_coupling_code(ctx, &ctx.program->blocks[loop_header_idx], ctx.loop.back().live_in);
    renames.swap(ctx.renames[loop_header_idx]);
 
    /* remove loop header info from stack */
-- 
GitLab


From e77e7a22d844828096388b11aee062a06a0d09db Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 16 Feb 2024 11:20:13 +0100
Subject: [PATCH 6/9] aco/spill: gather information about average use distances

---
 src/amd/compiler/aco_spill.cpp | 44 +++++++++++++++++++++++++++++++---
 1 file changed, 41 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index b53bbcf7c5825..b7f2cf6625dd5 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -68,6 +68,12 @@ struct loop_info {
    IDSet live_in;
 };
 
+struct use_info {
+   uint32_t num_uses = 0;
+   uint32_t last_use = 0;
+   float score() { return last_use / num_uses; }
+};
+
 struct spill_ctx {
    RegisterDemand target_pressure;
    Program* program;
@@ -85,6 +91,7 @@ struct spill_ctx {
    std::vector<next_use_distance_startend_type> next_use_distances_start;
    std::vector<next_use_distance_startend_type> next_use_distances_end;
    std::vector<std::vector<std::pair<Temp, uint32_t>>> local_next_use_distance; /* Working buffer */
+   std::vector<use_info> ssa_infos;
    std::vector<std::pair<RegClass, std::unordered_set<uint32_t>>> interferences;
    std::vector<std::vector<uint32_t>> affinities;
    std::vector<bool> is_reloaded;
@@ -104,7 +111,8 @@ struct spill_ctx {
          processed(program->blocks.size(), false),
          next_use_distances_start(program->blocks.size(), next_use_distance_startend_type(memory)),
          next_use_distances_end(program->blocks.size(), next_use_distance_startend_type(memory)),
-         remat(memory), wave_size(program->wave_size), sgpr_spill_slots(0), vgpr_spill_slots(0)
+         ssa_infos(program->peekAllocationId()), remat(memory), wave_size(program->wave_size),
+         sgpr_spill_slots(0), vgpr_spill_slots(0)
    {}
 
    void add_affinity(uint32_t first, uint32_t second)
@@ -171,9 +179,16 @@ struct spill_ctx {
    uint32_t next_spill_id = 0;
 };
 
+/**
+ * Gathers information about the number of uses and point of last use
+ * per SSA value.
+ *
+ * Live-out variables are converted to live-in.
+ */
 void
-compute_live_in(spill_ctx& ctx)
+gather_ssa_use_info(spill_ctx& ctx)
 {
+   unsigned instruction_idx = 0;
    for (Block& block : ctx.program->blocks) {
       IDSet& live_set = ctx.live_vars.live_out[block.index];
 
@@ -187,11 +202,26 @@ compute_live_in(spill_ctx& ctx)
          }
          for (const Operand& op : instr->operands) {
             if (op.isTemp()) {
+               use_info& info = ctx.ssa_infos[op.tempId()];
+               info.num_uses++;
+               info.last_use = std::max(info.last_use, instruction_idx + i);
                if (!phi && op.isFirstKill())
                   live_set.insert(op.tempId());
             }
          }
       }
+
+      /* All live-in variables at loop headers get an additional artificial use.
+       * As we decrement the number of uses while processing the blocks, this
+       * ensures that the number of uses won't becomes zero before the loop
+       * (and the variables' live-ranges) end.
+       */
+      if (block.kind & block_kind_loop_header) {
+         for (unsigned t : live_set)
+            ctx.ssa_infos[t].num_uses++;
+      }
+
+      instruction_idx += block.instructions.size();
    }
 }
 
@@ -826,6 +856,11 @@ add_coupling_code(spill_ctx& ctx, Block* block, IDSet& live_in)
       if (!is_phi(phi))
          break;
 
+      for (const Operand& op : phi->operands) {
+         if (op.isTemp())
+            ctx.ssa_infos[op.tempId()].num_uses--;
+      }
+
       /* if the phi is not spilled, add to instructions */
       if (!phi->definitions[0].isTemp() ||
           !ctx.spills_entry[block_idx].count(phi->definitions[0].getTemp())) {
@@ -1173,6 +1208,7 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
 
          if (op.isFirstKill())
             ctx.live_vars.live_out[block_idx].erase(op.tempId());
+         ctx.ssa_infos[op.tempId()].num_uses--;
 
          if (!current_spills.count(op.getTemp())) {
             /* the Operand is in register: check if it was renamed */
@@ -1317,6 +1353,8 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
    aco::map<Temp, Temp> renames = std::move(ctx.renames[loop_header_idx]);
 
    /* add coupling code to all loop header predecessors */
+   for (unsigned t : ctx.loop.back().live_in)
+      ctx.ssa_infos[t].num_uses--;
    add_coupling_code(ctx, &ctx.program->blocks[loop_header_idx], ctx.loop.back().live_in);
    renames.swap(ctx.renames[loop_header_idx]);
 
@@ -1904,7 +1942,7 @@ spill(Program* program, live& live_vars)
 
    /* initialize ctx */
    spill_ctx ctx(target, program, live_vars);
-   compute_live_in(ctx);
+   gather_ssa_use_info(ctx);
    compute_global_next_uses(ctx);
    get_rematerialize_info(ctx);
 
-- 
GitLab


From 618803aa2e26bcfc1a0cd815513ea175de82ef10 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 20 Feb 2024 11:25:09 +0100
Subject: [PATCH 7/9] aco/spill: use average use distances in process_block()

Totals from 128 (0.16% of 79395) affected shaders: (GFX11)
Instrs: 672936 -> 672086 (-0.13%); split: -0.40%, +0.28%
CodeSize: 3574396 -> 3565540 (-0.25%); split: -0.55%, +0.30%
SpillSGPRs: 6254 -> 6636 (+6.11%); split: -0.32%, +6.43%
SpillVGPRs: 967 -> 839 (-13.24%)
Latency: 6489362 -> 6469427 (-0.31%); split: -0.36%, +0.05%
InvThroughput: 2216723 -> 2212417 (-0.19%); split: -0.24%, +0.05%
VClause: 11670 -> 11517 (-1.31%); split: -1.50%, +0.19%
SClause: 15711 -> 15754 (+0.27%); split: -0.29%, +0.57%
Copies: 85185 -> 84155 (-1.21%); split: -2.14%, +0.93%
Branches: 18706 -> 18708 (+0.01%); split: -0.05%, +0.06%
VALU: 386892 -> 386204 (-0.18%); split: -0.40%, +0.23%
SALU: 85754 -> 86211 (+0.53%); split: -0.46%, +1.00%
VMEM: 18777 -> 18524 (-1.35%); split: -1.37%, +0.02%
VOPD: 670 -> 628 (-6.27%); split: +0.75%, -7.01%
---
 src/amd/compiler/aco_spill.cpp | 119 +++++++++------------------------
 1 file changed, 30 insertions(+), 89 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index b7f2cf6625dd5..ecec33219da17 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -90,7 +90,6 @@ struct spill_ctx {
    using next_use_distance_startend_type = aco::unordered_map<Temp, std::pair<uint32_t, uint32_t>>;
    std::vector<next_use_distance_startend_type> next_use_distances_start;
    std::vector<next_use_distance_startend_type> next_use_distances_end;
-   std::vector<std::vector<std::pair<Temp, uint32_t>>> local_next_use_distance; /* Working buffer */
    std::vector<use_info> ssa_infos;
    std::vector<std::pair<RegClass, std::unordered_set<uint32_t>>> interferences;
    std::vector<std::vector<uint32_t>> affinities;
@@ -459,61 +458,6 @@ get_rematerialize_info(spill_ctx& ctx)
    }
 }
 
-void
-update_local_next_uses(spill_ctx& ctx, Block* block,
-                       std::vector<std::vector<std::pair<Temp, uint32_t>>>& local_next_uses)
-{
-   if (local_next_uses.size() < block->instructions.size()) {
-      /* Allocate more next-use-maps. Note that by never reducing the vector size, we enable
-       * future calls to this function to re-use already allocated map memory. */
-      local_next_uses.resize(block->instructions.size());
-   }
-
-   local_next_uses[block->instructions.size() - 1].clear();
-   for (std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair :
-        ctx.next_use_distances_end[block->index]) {
-      local_next_uses[block->instructions.size() - 1].push_back(std::make_pair<Temp, uint32_t>(
-         (Temp)pair.first, pair.second.second + block->instructions.size()));
-   }
-
-   for (int idx = block->instructions.size() - 1; idx >= 0; idx--) {
-      aco_ptr<Instruction>& instr = block->instructions[idx];
-      if (!instr)
-         break;
-      if (instr->opcode == aco_opcode::p_phi || instr->opcode == aco_opcode::p_linear_phi)
-         break;
-
-      if (idx != (int)block->instructions.size() - 1) {
-         local_next_uses[idx] = local_next_uses[idx + 1];
-      }
-
-      for (const Operand& op : instr->operands) {
-         if (op.isFixed() && op.physReg() == exec)
-            continue;
-         if (op.regClass().type() == RegType::vgpr && op.regClass().is_linear())
-            continue;
-         if (op.isTemp()) {
-            auto it = std::find_if(local_next_uses[idx].begin(), local_next_uses[idx].end(),
-                                   [op](auto& pair) { return pair.first == op.getTemp(); });
-            if (it == local_next_uses[idx].end()) {
-               local_next_uses[idx].push_back(std::make_pair<Temp, uint32_t>(op.getTemp(), idx));
-            } else {
-               it->second = idx;
-            }
-         }
-      }
-      for (const Definition& def : instr->definitions) {
-         if (def.isTemp()) {
-            auto it = std::find_if(local_next_uses[idx].begin(), local_next_uses[idx].end(),
-                                   [def](auto& pair) { return pair.first == def.getTemp(); });
-            if (it != local_next_uses[idx].end()) {
-               local_next_uses[idx].erase(it);
-            }
-         }
-      }
-   }
-}
-
 RegisterDemand
 get_demand_before(spill_ctx& ctx, unsigned block_idx, unsigned idx)
 {
@@ -1179,12 +1123,6 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
       instructions.emplace_back(std::move(block->instructions[idx++]));
    }
 
-   if (block->register_demand.exceeds(ctx.target_pressure)) {
-      update_local_next_uses(ctx, block, ctx.local_next_use_distance);
-   } else {
-      /* We won't use local_next_use_distance, so no initialization needed */
-   }
-
    auto& current_spills = ctx.spills_exit[block_idx];
 
    while (idx < block->instructions.size()) {
@@ -1210,26 +1148,14 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
             ctx.live_vars.live_out[block_idx].erase(op.tempId());
          ctx.ssa_infos[op.tempId()].num_uses--;
 
-         if (!current_spills.count(op.getTemp())) {
-            /* the Operand is in register: check if it was renamed */
-            auto rename_it = ctx.renames[block_idx].find(op.getTemp());
-            if (rename_it != ctx.renames[block_idx].end()) {
-               op.setTemp(rename_it->second);
-            } else {
-               /* prevent its defining instruction from being DCE'd if it could be rematerialized */
-               auto remat_it = ctx.remat.find(op.getTemp());
-               if (remat_it != ctx.remat.end()) {
-                  ctx.unused_remats.erase(remat_it->second.instr);
-               }
-            }
+         if (!current_spills.count(op.getTemp()))
             continue;
-         }
+
          /* the Operand is spilled: add it to reloads */
          Temp new_tmp = ctx.program->allocateTmp(op.regClass());
          ctx.renames[block_idx][op.getTemp()] = new_tmp;
          reloads[new_tmp] = std::make_pair(op.getTemp(), current_spills[op.getTemp()]);
          current_spills.erase(op.getTemp());
-         op.setTemp(new_tmp);
          spilled_registers -= new_tmp;
       }
 
@@ -1239,11 +1165,9 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
          RegisterDemand new_demand = ctx.live_vars.register_demand[block_idx][idx];
          new_demand.update(get_demand_before(ctx, block_idx, idx));
 
-         assert(!ctx.local_next_use_distance.empty());
-
          /* if reg pressure is too high, spill variable with furthest next use */
          while ((new_demand - spilled_registers).exceeds(ctx.target_pressure)) {
-            unsigned distance = 0;
+            float score = 0.0;
             Temp to_spill;
             unsigned do_rematerialize = 0;
             unsigned avoid_respill = 0;
@@ -1251,29 +1175,31 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
             if (new_demand.vgpr - spilled_registers.vgpr > ctx.target_pressure.vgpr)
                type = RegType::vgpr;
 
-            for (std::pair<Temp, uint32_t> pair : ctx.local_next_use_distance[idx]) {
-               if (pair.first.type() != type || current_spills.count(pair.first))
+            for (unsigned t : ctx.live_vars.live_out[block_idx]) {
+               RegClass rc = ctx.program->temp_rc[t];
+               Temp var = Temp(t, rc);
+               if (rc.type() != type || current_spills.count(var) || rc.is_linear_vgpr())
                   continue;
 
-               unsigned can_rematerialize = ctx.remat.count(pair.first);
-               unsigned loop_variable =
-                  block->loop_nest_depth && ctx.loop.back().spills.count(pair.first);
+               unsigned can_rematerialize = ctx.remat.count(var);
+               unsigned loop_variable = block->loop_nest_depth && ctx.loop.back().spills.count(var);
                if (avoid_respill > loop_variable || do_rematerialize > can_rematerialize)
                   continue;
 
                if (can_rematerialize > do_rematerialize || loop_variable > avoid_respill ||
-                   pair.second > distance) {
+                   ctx.ssa_infos[t].score() > score) {
                   /* Don't spill operands */
-                  if (pair.second <= idx)
+                  if (std::any_of(instr->operands.begin(), instr->operands.end(),
+                                  [&](Operand& op) { return op.isTemp() && op.getTemp() == var; }))
                      continue;
 
-                  to_spill = pair.first;
-                  distance = pair.second;
+                  to_spill = var;
+                  score = ctx.ssa_infos[t].score();
                   do_rematerialize = can_rematerialize;
                   avoid_respill = loop_variable;
                }
             }
-            assert(distance != 0 && distance > idx);
+            assert(score != 0.0);
 
             if (avoid_respill) {
                /* This variable is spilled at the loop-header of the current loop.
@@ -1309,6 +1235,21 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
          if (def.isTemp() && !def.isKill())
             ctx.live_vars.live_out[block_idx].insert(def.tempId());
       }
+      /* rename operands */
+      for (Operand& op : instr->operands) {
+         if (op.isTemp()) {
+            auto rename_it = ctx.renames[block_idx].find(op.getTemp());
+            if (rename_it != ctx.renames[block_idx].end()) {
+               op.setTemp(rename_it->second);
+            } else {
+               /* prevent its defining instruction from being DCE'd if it could be rematerialized */
+               auto remat_it = ctx.remat.find(op.getTemp());
+               if (remat_it != ctx.remat.end()) {
+                  ctx.unused_remats.erase(remat_it->second.instr);
+               }
+            }
+         }
+      }
 
       /* add reloads and instruction to new instructions */
       for (std::pair<const Temp, std::pair<Temp, uint32_t>>& pair : reloads) {
-- 
GitLab


From 2e76a165ac05ae2d83d76bf31d5bf441bacd5f45 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 16 Feb 2024 11:37:49 +0100
Subject: [PATCH 8/9] aco/spill: use average use distances in
 init_live_in_vars() for merge blocks

Totals from 18 (0.02% of 79395) affected shaders: (GFX11)
Instrs: 726400 -> 726409 (+0.00%); split: -0.00%, +0.00%
CodeSize: 3750396 -> 3750420 (+0.00%); split: -0.00%, +0.00%
Latency: 4363014 -> 4363039 (+0.00%); split: -0.00%, +0.00%
InvThroughput: 1483486 -> 1483485 (-0.00%)
SClause: 13393 -> 13392 (-0.01%); split: -0.01%, +0.01%
Copies: 70236 -> 70254 (+0.03%); split: -0.01%, +0.03%
Branches: 23811 -> 23810 (-0.00%)
VALU: 404250 -> 404247 (-0.00%); split: -0.00%, +0.00%
SALU: 92208 -> 92226 (+0.02%); split: -0.01%, +0.02%
---
 src/amd/compiler/aco_spill.cpp | 45 +++++++++++++++++++---------------
 1 file changed, 25 insertions(+), 20 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index ecec33219da17..8398169bb2044 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -513,6 +513,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
 
    /* next use distances at the beginning of the current block */
    const auto& next_use_distances = ctx.next_use_distances_start[block_idx];
+   const IDSet& live_in = ctx.live_vars.live_out[block_idx];
 
    /* loop header block */
    if (block->kind & block_kind_loop_header) {
@@ -593,7 +594,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       }
 
       /* create new loop_info */
-      loop_info info = {block_idx, ctx.spills_entry[block_idx], ctx.live_vars.live_out[block_idx]};
+      loop_info info = {block_idx, ctx.spills_entry[block_idx], live_in};
       ctx.loop.emplace_back(std::move(info));
 
       /* shortcut */
@@ -633,7 +634,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          if (pair.first.type() != RegType::sgpr)
             continue;
 
-         if (next_use_distances.count(pair.first)) {
+         if (live_in.count(pair.first.id())) {
             spilled_registers += pair.first;
             ctx.spills_entry[block_idx].emplace(pair);
          }
@@ -647,7 +648,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          if (pair.first.type() != RegType::vgpr)
             continue;
 
-         if (next_use_distances.count(pair.first)) {
+         if (live_in.count(pair.first.id())) {
             spilled_registers += pair.first;
             ctx.spills_entry[block_idx].emplace(pair);
          }
@@ -660,43 +661,47 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
    std::map<Temp, bool> partial_spills;
 
    /* keep variables spilled on all incoming paths */
-   for (const std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair : next_use_distances) {
-      Block::edge_vec& preds = pair.first.is_linear() ? block->linear_preds : block->logical_preds;
+   for (unsigned t : live_in) {
+      const RegClass rc = ctx.program->temp_rc[t];
+      Temp var = Temp(t, rc);
+      Block::edge_vec& preds = rc.is_linear() ? block->linear_preds : block->logical_preds;
+
       /* If it can be rematerialized, keep the variable spilled if all predecessors do not reload
        * it. Otherwise, if any predecessor reloads it, ensure it's reloaded on all other
        * predecessors. The idea is that it's better in practice to rematerialize redundantly than to
        * create lots of phis. */
-      const bool remat = ctx.remat.count(pair.first);
+      const bool remat = ctx.remat.count(var);
       /* If the variable is spilled at the current loop-header, spilling is essentially for free
        * while reloading is not. Thus, keep them spilled if they are at least partially spilled.
        */
-      const bool avoid_respill = block->loop_nest_depth && ctx.loop.back().spills.count(pair.first);
+      const bool avoid_respill = block->loop_nest_depth && ctx.loop.back().spills.count(var);
       bool spill = true;
       bool partial_spill = false;
       uint32_t spill_id = 0;
       for (unsigned pred_idx : preds) {
          /* variable is not even live at the predecessor: probably from a phi */
-         if (!ctx.next_use_distances_end[pred_idx].count(pair.first)) {
+         if (!ctx.live_vars.live_out[pred_idx].count(t)) {
             spill = false;
             break;
          }
-         if (!ctx.spills_exit[pred_idx].count(pair.first)) {
+
+         if (!ctx.spills_exit[pred_idx].count(var)) {
             spill = false;
          } else {
             partial_spill = true;
             /* it might be that on one incoming path, the variable has a different spill_id, but
              * add_couple_code() will take care of that. */
-            spill_id = ctx.spills_exit[pred_idx][pair.first];
+            spill_id = ctx.spills_exit[pred_idx][var];
          }
       }
       spill |= (remat && partial_spill);
       spill |= (avoid_respill && partial_spill);
       if (spill) {
-         ctx.spills_entry[block_idx][pair.first] = spill_id;
-         partial_spills.erase(pair.first);
-         spilled_registers += pair.first;
+         ctx.spills_entry[block_idx][var] = spill_id;
+         partial_spills.erase(var);
+         spilled_registers += var;
       } else {
-         partial_spills[pair.first] = partial_spill;
+         partial_spills[var] = partial_spill;
       }
    }
 
@@ -740,22 +745,22 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       std::map<Temp, bool>::iterator it = partial_spills.begin();
       Temp to_spill = Temp();
       bool is_partial_spill = false;
-      unsigned distance = 0;
+      float score = 0.0;
       RegType type = reg_pressure.vgpr > ctx.target_pressure.vgpr ? RegType::vgpr : RegType::sgpr;
 
       while (it != partial_spills.end()) {
          assert(!ctx.spills_entry[block_idx].count(it->first));
 
-         if (it->first.type() == type && ((it->second && !is_partial_spill) ||
-                                          (it->second == is_partial_spill &&
-                                           next_use_distances.at(it->first).second > distance))) {
-            distance = next_use_distances.at(it->first).second;
+         if (it->first.type() == type && !it->first.regClass().is_linear_vgpr() &&
+             ((it->second && !is_partial_spill) ||
+              (it->second == is_partial_spill && ctx.ssa_infos[it->first.id()].score() > score))) {
+            score = ctx.ssa_infos[it->first.id()].score();
             to_spill = it->first;
             is_partial_spill = it->second;
          }
          ++it;
       }
-      assert(distance != 0);
+      assert(score != 0.0);
       ctx.add_to_spills(to_spill, ctx.spills_entry[block_idx]);
       partial_spills.erase(to_spill);
       spilled_registers += to_spill;
-- 
GitLab


From c5894b4abdd462aeb842693da6d56b14501fdc4a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 22 Feb 2024 16:41:07 +0100
Subject: [PATCH 9/9] aco/spill: use average use distances to spill loop
 variables

Totals from 83 (0.10% of 79395) affected shaders: (GFX11)
Instrs: 3429510 -> 3427917 (-0.05%); split: -0.05%, +0.01%
CodeSize: 17587884 -> 17570224 (-0.10%); split: -0.11%, +0.01%
SpillSGPRs: 4660 -> 4630 (-0.64%); split: -1.07%, +0.43%
Latency: 20054145 -> 20054454 (+0.00%); split: -0.00%, +0.01%
InvThroughput: 4989606 -> 4989740 (+0.00%); split: -0.00%, +0.01%
VClause: 90844 -> 90843 (-0.00%)
SClause: 69534 -> 69535 (+0.00%); split: -0.04%, +0.04%
Copies: 283288 -> 283415 (+0.04%); split: -0.11%, +0.15%
Branches: 113543 -> 113409 (-0.12%); split: -0.12%, +0.01%
VALU: 1888933 -> 1887489 (-0.08%); split: -0.08%, +0.00%
SALU: 423548 -> 423609 (+0.01%); split: -0.07%, +0.09%
---
 src/amd/compiler/aco_spill.cpp | 206 ++++++---------------------------
 1 file changed, 34 insertions(+), 172 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 8398169bb2044..a72ea15c1d3b0 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -49,9 +49,16 @@ template <> struct hash<aco::Temp> {
 } // namespace std
 
 /*
- * Implements the spilling algorithm on SSA-form from
+ * Implements the spilling algorithm on SSA-form based on
  * "Register Spilling and Live-Range Splitting for SSA-Form Programs"
  * by Matthias Braun and Sebastian Hack.
+ *
+ * Key difference between this algorithm and the min-algorithm from the paper
+ * is the use of average use distances rather than next-use distances per
+ * instruction.
+ * As we decrement the number of remaining uses, the average use distances
+ * give an approximation of the next-use distances while being computationally
+ * and memory-wise less expensive.
  */
 
 namespace aco {
@@ -87,9 +94,6 @@ struct spill_ctx {
    std::vector<bool> processed;
    std::vector<loop_info> loop;
 
-   using next_use_distance_startend_type = aco::unordered_map<Temp, std::pair<uint32_t, uint32_t>>;
-   std::vector<next_use_distance_startend_type> next_use_distances_start;
-   std::vector<next_use_distance_startend_type> next_use_distances_end;
    std::vector<use_info> ssa_infos;
    std::vector<std::pair<RegClass, std::unordered_set<uint32_t>>> interferences;
    std::vector<std::vector<uint32_t>> affinities;
@@ -107,11 +111,8 @@ struct spill_ctx {
          renames(program->blocks.size(), aco::map<Temp, Temp>(memory)),
          spills_entry(program->blocks.size(), aco::unordered_map<Temp, uint32_t>(memory)),
          spills_exit(program->blocks.size(), aco::unordered_map<Temp, uint32_t>(memory)),
-         processed(program->blocks.size(), false),
-         next_use_distances_start(program->blocks.size(), next_use_distance_startend_type(memory)),
-         next_use_distances_end(program->blocks.size(), next_use_distance_startend_type(memory)),
-         ssa_infos(program->peekAllocationId()), remat(memory), wave_size(program->wave_size),
-         sgpr_spill_slots(0), vgpr_spill_slots(0)
+         processed(program->blocks.size(), false), ssa_infos(program->peekAllocationId()),
+         remat(memory), wave_size(program->wave_size), sgpr_spill_slots(0), vgpr_spill_slots(0)
    {}
 
    void add_affinity(uint32_t first, uint32_t second)
@@ -224,142 +225,6 @@ gather_ssa_use_info(spill_ctx& ctx)
    }
 }
 
-int32_t
-get_dominator(int idx_a, int idx_b, Program* program, bool is_linear)
-{
-
-   if (idx_a == -1)
-      return idx_b;
-   if (idx_b == -1)
-      return idx_a;
-   if (is_linear) {
-      while (idx_a != idx_b) {
-         if (idx_a > idx_b)
-            idx_a = program->blocks[idx_a].linear_idom;
-         else
-            idx_b = program->blocks[idx_b].linear_idom;
-      }
-   } else {
-      while (idx_a != idx_b) {
-         if (idx_a > idx_b)
-            idx_a = program->blocks[idx_a].logical_idom;
-         else
-            idx_b = program->blocks[idx_b].logical_idom;
-      }
-   }
-   assert(idx_a != -1);
-   return idx_a;
-}
-
-void
-next_uses_per_block(spill_ctx& ctx, unsigned block_idx, uint32_t& worklist)
-{
-   Block* block = &ctx.program->blocks[block_idx];
-   ctx.next_use_distances_start[block_idx] = ctx.next_use_distances_end[block_idx];
-   auto& next_use_distances_start = ctx.next_use_distances_start[block_idx];
-
-   /* to compute the next use distance at the beginning of the block, we have to add the block's
-    * size */
-   for (std::unordered_map<Temp, std::pair<uint32_t, uint32_t>>::iterator it =
-           next_use_distances_start.begin();
-        it != next_use_distances_start.end(); ++it)
-      it->second.second = it->second.second + block->instructions.size();
-
-   int idx = block->instructions.size() - 1;
-   while (idx >= 0) {
-      aco_ptr<Instruction>& instr = block->instructions[idx];
-
-      if (instr->opcode == aco_opcode::p_linear_phi || instr->opcode == aco_opcode::p_phi)
-         break;
-
-      for (const Definition& def : instr->definitions) {
-         if (def.isTemp())
-            next_use_distances_start.erase(def.getTemp());
-      }
-
-      for (const Operand& op : instr->operands) {
-         /* omit exec mask */
-         if (op.isFixed() && op.physReg() == exec)
-            continue;
-         if (op.regClass().type() == RegType::vgpr && op.regClass().is_linear())
-            continue;
-         if (op.isTemp())
-            next_use_distances_start[op.getTemp()] = {block_idx, idx};
-      }
-      idx--;
-   }
-
-   assert(block_idx != 0 || next_use_distances_start.empty());
-   std::unordered_set<Temp> phi_defs;
-   while (idx >= 0) {
-      aco_ptr<Instruction>& instr = block->instructions[idx];
-      assert(instr->opcode == aco_opcode::p_linear_phi || instr->opcode == aco_opcode::p_phi);
-
-      std::pair<uint32_t, uint32_t> distance{block_idx, 0};
-
-      auto it = instr->definitions[0].isTemp()
-                   ? next_use_distances_start.find(instr->definitions[0].getTemp())
-                   : next_use_distances_start.end();
-      if (it != next_use_distances_start.end() &&
-          phi_defs.insert(instr->definitions[0].getTemp()).second) {
-         distance = it->second;
-      }
-
-      for (unsigned i = 0; i < instr->operands.size(); i++) {
-         unsigned pred_idx =
-            instr->opcode == aco_opcode::p_phi ? block->logical_preds[i] : block->linear_preds[i];
-         if (instr->operands[i].isTemp()) {
-            auto insert_result = ctx.next_use_distances_end[pred_idx].insert(
-               std::make_pair(instr->operands[i].getTemp(), distance));
-            const bool inserted = insert_result.second;
-            std::pair<uint32_t, uint32_t>& entry_distance = insert_result.first->second;
-            if (inserted || entry_distance != distance)
-               worklist = std::max(worklist, pred_idx + 1);
-            entry_distance = distance;
-         }
-      }
-      idx--;
-   }
-
-   /* all remaining live vars must be live-out at the predecessors */
-   for (std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair : next_use_distances_start) {
-      Temp temp = pair.first;
-      if (phi_defs.count(temp)) {
-         continue;
-      }
-      uint32_t distance = pair.second.second;
-      uint32_t dom = pair.second.first;
-      Block::edge_vec& preds = temp.is_linear() ? block->linear_preds : block->logical_preds;
-      for (unsigned pred_idx : preds) {
-         if (ctx.program->blocks[pred_idx].loop_nest_depth > block->loop_nest_depth)
-            distance += 0xFFFF;
-         auto insert_result = ctx.next_use_distances_end[pred_idx].insert(
-            std::make_pair(temp, std::pair<uint32_t, uint32_t>{}));
-         const bool inserted = insert_result.second;
-         std::pair<uint32_t, uint32_t>& entry_distance = insert_result.first->second;
-
-         if (!inserted) {
-            dom = get_dominator(dom, entry_distance.first, ctx.program, temp.is_linear());
-            distance = std::min(entry_distance.second, distance);
-         }
-         if (entry_distance != std::pair<uint32_t, uint32_t>{dom, distance}) {
-            worklist = std::max(worklist, pred_idx + 1);
-            entry_distance = {dom, distance};
-         }
-      }
-   }
-}
-
-void
-compute_global_next_uses(spill_ctx& ctx)
-{
-   uint32_t worklist = ctx.program->blocks.size();
-   while (worklist) {
-      unsigned block_idx = --worklist;
-      next_uses_per_block(ctx, block_idx, worklist);
-   }
-}
-
 bool
 should_rematerialize(aco_ptr<Instruction>& instr)
 {
@@ -511,8 +376,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
    if (block->linear_preds.empty())
       return {0, 0};
 
-   /* next use distances at the beginning of the current block */
-   const auto& next_use_distances = ctx.next_use_distances_start[block_idx];
+   /* live-in variables at the beginning of the current block */
    const IDSet& live_in = ctx.live_vars.live_out[block_idx];
 
    /* loop header block */
@@ -528,10 +392,8 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          loop_demand.update(ctx.program->blocks[i++].register_demand);
 
       for (auto spilled : ctx.spills_exit[block_idx - 1]) {
-         auto it = next_use_distances.find(spilled.first);
-
          /* variable is not live at loop entry: probably a phi operand */
-         if (it == next_use_distances.end())
+         if (!live_in.count(spilled.first.id()))
             continue;
 
          /* keep live-through variables spilled */
@@ -545,9 +407,9 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
             /* If the outer loop is not an actual loop, the loop-carried variables
              * might not be live-in for the inner loop.
              */
-            assert(next_use_distances.count(spilled.first) ||
+            assert(live_in.count(spilled.first.id()) ||
                    ctx.program->blocks[ctx.loop.back().index].linear_preds.size() == 1);
-            if (next_use_distances.count(spilled.first) &&
+            if (live_in.count(spilled.first.id()) &&
                 ctx.spills_entry[block_idx].insert(spilled).second) {
                spilled_registers += spilled.first;
                loop_demand -= spilled.first;
@@ -565,23 +427,25 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          if (type == RegType::sgpr && loop_demand.sgpr <= ctx.target_pressure.sgpr)
             break;
 
-         unsigned distance = 0;
+         float score = 0.0;
          unsigned remat = 0;
          Temp to_spill;
-         for (const std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair :
-              next_use_distances) {
-            unsigned can_remat = ctx.remat.count(pair.first);
-            if (pair.first.type() == type && !ctx.spills_entry[block_idx].count(pair.first) &&
-                ctx.next_use_distances_end[block_idx - 1].count(pair.first) &&
-                (can_remat > remat || (can_remat == remat && pair.second.second > distance))) {
-               to_spill = pair.first;
-               distance = pair.second.second;
+         for (unsigned t : live_in) {
+            Temp var = Temp(t, ctx.program->temp_rc[t]);
+            if (var.type() != type || ctx.spills_entry[block_idx].count(var) ||
+                !ctx.live_vars.live_out[block_idx - 1].count(t) || var.regClass().is_linear_vgpr())
+               continue;
+
+            unsigned can_remat = ctx.remat.count(var);
+            if (can_remat > remat || (can_remat == remat && ctx.ssa_infos[t].score() > score)) {
+               to_spill = var;
+               score = ctx.ssa_infos[t].score();
                remat = can_remat;
             }
          }
 
          /* select SGPRs or break */
-         if (distance == 0) {
+         if (score == 0.0) {
             if (type == RegType::sgpr)
                break;
             type = RegType::sgpr;
@@ -605,19 +469,18 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       reg_pressure -= spilled_registers;
 
       while (reg_pressure.exceeds(ctx.target_pressure)) {
-         unsigned distance = 0;
+         float score = 0;
          Temp to_spill;
          type = reg_pressure.vgpr > ctx.target_pressure.vgpr ? RegType::vgpr : RegType::sgpr;
-
-         for (const std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair :
-              next_use_distances) {
-            if (pair.first.type() == type && pair.second.second > distance &&
-                !ctx.spills_entry[block_idx].count(pair.first)) {
-               to_spill = pair.first;
-               distance = pair.second.second;
+         for (unsigned t : live_in) {
+            Temp var = Temp(t, ctx.program->temp_rc[t]);
+            if (var.type() == type && !ctx.spills_entry[block_idx].count(var) &&
+                ctx.ssa_infos[t].score() > score) {
+               to_spill = var;
+               score = ctx.ssa_infos[t].score();
             }
          }
-         assert(distance != 0);
+         assert(score != 0.0);
          ctx.add_to_spills(to_spill, ctx.spills_entry[block_idx]);
          spilled_registers += to_spill;
          reg_pressure -= to_spill;
@@ -1889,7 +1752,6 @@ spill(Program* program, live& live_vars)
    /* initialize ctx */
    spill_ctx ctx(target, program, live_vars);
    gather_ssa_use_info(ctx);
-   compute_global_next_uses(ctx);
    get_rematerialize_info(ctx);
 
    /* create spills and reloads */
-- 
GitLab

