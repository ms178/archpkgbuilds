From a3ad5e3d9757ad14c916215f34fed7b95b8dd6f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 15 Mar 2023 11:59:41 -0700
Subject: [PATCH 1/5] ac, aco, radv: Clarify LDS size on GFX6, and NGG shaders.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This information was wrong in some places, let's fix it now.

GFX6:
The GPU has 64KB LDS, but only 32KB is usable by a workgroup.

NGG:
There was some misinformation about NGG only being able to
address 32 KB LDS, it turns out this is actually not true
and it can address the full 64K.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21935>
---
 src/amd/common/ac_gpu_info.c                         | 11 ++++++++---
 src/amd/compiler/README-ISA.md                       | 12 ++++++++++++
 src/amd/compiler/aco_instruction_selection_setup.cpp |  5 -----
 src/amd/compiler/aco_ir.cpp                          |  3 +++
 src/amd/vulkan/winsys/null/radv_null_winsys.c        |  4 +++-
 5 files changed, 26 insertions(+), 9 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 4d8014821f93..4721ecc7a89d 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1058,12 +1058,17 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
    }
    info->r600_has_virtual_memory = true;
 
-   /* LDS is 64KB per CU (4 SIMDs), which is 16KB per SIMD (usage above
+   /* LDS is 64KB per CU (4 SIMDs on GFX6-9), which is 16KB per SIMD (usage above
     * 16KB makes some SIMDs unoccupied).
     *
-    * LDS is 128KB in WGP mode and 64KB in CU mode. Assume the WGP mode is used.
+    * GFX10+: LDS is 128KB in WGP mode and 64KB in CU mode. Assume the WGP mode is used.
+    * GFX7+: Workgroups can use up to 64KB.
+    * GFX6: There is 64KB LDS per CU, but a workgroup can only use up to 32KB.
     */
-   info->lds_size_per_workgroup = info->gfx_level >= GFX10 ? 128 * 1024 : 64 * 1024;
+   info->lds_size_per_workgroup = info->gfx_level >= GFX10  ? 128 * 1024
+                                  : info->gfx_level >= GFX7 ? 64 * 1024
+                                                            : 32 * 1024;
+
    /* lds_encode_granularity is the block size used for encoding registers.
     * lds_alloc_granularity is what the hardware will align the LDS size to.
     */
diff --git a/src/amd/compiler/README-ISA.md b/src/amd/compiler/README-ISA.md
index f0cdbf8612b5..3b8590cbe9b8 100644
--- a/src/amd/compiler/README-ISA.md
+++ b/src/amd/compiler/README-ISA.md
@@ -113,6 +113,18 @@ Some instructions have a `_LEGACY` variant which implements "DX9 rules", in whic
 the zero "wins" in multiplications, ie. `0.0*x` is always `0.0`. The VEGA ISA
 mentions `V_MAC_LEGACY_F32` but this instruction is not really there on VEGA.
 
+## LDS size and allocation granule
+
+GFX7-8 ISA manuals are mistaken about the available LDS size.
+
+* GFX7+ workgroups can use 64KB LDS.
+  There is 64KB LDS per CU.
+* GFX6 workgroups can use 32KB LDS.
+  There is 64KB LDS per CU, but a single workgroup can only use half of it.
+
+ Regarding the LDS allocation granule, Mesa has the correct details and
+ the ISA manuals are mistaken.
+
 ## `m0` with LDS instructions on Vega and newer
 
 The Vega ISA doc (both the old one and the "7nm" one) claims that LDS instructions
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 66bc77f70c00..d5d2392cbb61 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -254,8 +254,6 @@ setup_vs_variables(isel_context* ctx, nir_shader* nir)
    if (ctx->stage == vertex_ngg) {
       ctx->program->config->lds_size =
          DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-      assert((ctx->program->config->lds_size * ctx->program->dev.lds_encoding_granule) <
-             (32 * 1024));
    }
 }
 
@@ -285,8 +283,6 @@ setup_tes_variables(isel_context* ctx, nir_shader* nir)
    if (ctx->stage == tess_eval_ngg) {
       ctx->program->config->lds_size =
          DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-      assert((ctx->program->config->lds_size * ctx->program->dev.lds_encoding_granule) <
-             (32 * 1024));
    }
 }
 
@@ -295,7 +291,6 @@ setup_ms_variables(isel_context* ctx, nir_shader* nir)
 {
    ctx->program->config->lds_size =
       DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-   assert((ctx->program->config->lds_size * ctx->program->dev.lds_encoding_granule) < (32 * 1024));
 }
 
 void
diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index f592cb6e65d6..ef04a89c7807 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -101,7 +101,10 @@ init_program(Program* program, Stage stage, const struct aco_shader_info* info,
    program->dev.lds_encoding_granule = gfx_level >= GFX11 && stage == fragment_fs ? 1024 :
                                        gfx_level >= GFX7 ? 512 : 256;
    program->dev.lds_alloc_granule = gfx_level >= GFX10_3 ? 1024 : program->dev.lds_encoding_granule;
+
+   /* GFX6: There is 64KB LDS per CU, but a single workgroup can only use 32KB. */
    program->dev.lds_limit = gfx_level >= GFX7 ? 65536 : 32768;
+
    /* apparently gfx702 also has 16-bank LDS but I can't find a family for that */
    program->dev.has_16bank_lds = family == CHIP_KABINI || family == CHIP_STONEY;
 
diff --git a/src/amd/vulkan/winsys/null/radv_null_winsys.c b/src/amd/vulkan/winsys/null/radv_null_winsys.c
index 28864a4570c1..daeddc900a73 100644
--- a/src/amd/vulkan/winsys/null/radv_null_winsys.c
+++ b/src/amd/vulkan/winsys/null/radv_null_winsys.c
@@ -137,7 +137,9 @@ radv_null_winsys_query_info(struct radeon_winsys *rws, struct radeon_info *info)
    else
       info->num_physical_wave64_vgprs_per_simd = 256;
    info->num_simd_per_compute_unit = info->gfx_level >= GFX10 ? 2 : 4;
-   info->lds_size_per_workgroup = info->gfx_level >= GFX10 ? 128 * 1024 : 64 * 1024;
+   info->lds_size_per_workgroup = info->gfx_level >= GFX10  ? 128 * 1024
+                                  : info->gfx_level >= GFX7 ? 64 * 1024
+                                                            : 32 * 1024;
    info->lds_encode_granularity = info->gfx_level >= GFX7 ? 128 * 4 : 64 * 4;
    info->lds_alloc_granularity =
       info->gfx_level >= GFX10_3 ? 256 * 4 : info->lds_encode_granularity;
-- 
GitLab


From ee770a88a77dff7f40f49e9f246d0090e0c254c4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 15 Mar 2023 11:25:55 -0700
Subject: [PATCH 2/5] radv: Don't hardcode LDS granularity in gfx9_get_gs_info.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21935>
---
 src/amd/vulkan/radv_shader_info.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 3d5085c19942..be5fa2f7fa47 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1102,7 +1102,9 @@ radv_get_legacy_gs_info(const struct radv_device *device, struct radv_pipeline_s
    const uint32_t gs_prims_per_subgroup = gs_prims;
    const uint32_t gs_inst_prims_in_subgroup = gs_prims * gs_num_invocations;
    const uint32_t max_prims_per_subgroup = gs_inst_prims_in_subgroup * gs_info->gs.vertices_out;
-   out->lds_size = align(esgs_lds_size, 128) / 128;
+   const uint32_t lds_granularity = device->physical_device->rad_info.lds_encode_granularity;
+   const uint32_t total_lds_bytes = align(esgs_lds_size * 4, lds_granularity);
+   out->lds_size = total_lds_bytes / lds_granularity;
    out->vgt_gs_onchip_cntl = S_028A44_ES_VERTS_PER_SUBGRP(es_verts_per_subgroup) |
                              S_028A44_GS_PRIMS_PER_SUBGRP(gs_prims_per_subgroup) |
                              S_028A44_GS_INST_PRIMS_IN_SUBGRP(gs_inst_prims_in_subgroup);
-- 
GitLab


From 09c16fedc3a56b3ae9290346fada94ed83c643e0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 15 Mar 2023 11:54:49 -0700
Subject: [PATCH 3/5] aco: Remove setup_*_variables and add setup_lds_size
 instead.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21935>
---
 .../aco_instruction_selection_setup.cpp       | 85 ++-----------------
 1 file changed, 8 insertions(+), 77 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index d5d2392cbb61..a87120bbdfd6 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -248,91 +248,24 @@ get_reg_class(isel_context* ctx, RegType type, unsigned components, unsigned bit
       return RegClass::get(type, components * bitsize / 8u);
 }
 
-void
-setup_vs_variables(isel_context* ctx, nir_shader* nir)
-{
-   if (ctx->stage == vertex_ngg) {
-      ctx->program->config->lds_size =
-         DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-   }
-}
-
-void
-setup_gs_variables(isel_context* ctx, nir_shader* nir)
-{
-   if (ctx->stage == vertex_geometry_gs || ctx->stage == tess_eval_geometry_gs) {
-      ctx->program->config->lds_size =
-         ctx->program->info.gfx9_gs_ring_lds_size; /* Already in units of the alloc granularity */
-   } else if (ctx->stage == vertex_geometry_ngg || ctx->stage == tess_eval_geometry_ngg) {
-      ctx->program->config->lds_size =
-         DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-   }
-}
-
 void
 setup_tcs_info(isel_context* ctx, nir_shader* nir, nir_shader* vs)
 {
    ctx->tcs_in_out_eq = ctx->program->info.vs.tcs_in_out_eq;
    ctx->tcs_temp_only_inputs = ctx->program->info.vs.tcs_temp_only_input_mask;
-   ctx->program->config->lds_size = ctx->program->info.tcs.num_lds_blocks;
-}
-
-void
-setup_tes_variables(isel_context* ctx, nir_shader* nir)
-{
-   if (ctx->stage == tess_eval_ngg) {
-      ctx->program->config->lds_size =
-         DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-   }
 }
 
 void
-setup_ms_variables(isel_context* ctx, nir_shader* nir)
+setup_lds_size(isel_context* ctx, nir_shader* nir)
 {
-   ctx->program->config->lds_size =
-      DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-}
-
-void
-setup_variables(isel_context* ctx, nir_shader* nir)
-{
-   switch (nir->info.stage) {
-   case MESA_SHADER_FRAGMENT: {
-      break;
-   }
-   case MESA_SHADER_COMPUTE:
-   case MESA_SHADER_TASK:
-   case MESA_SHADER_RAYGEN:
-   case MESA_SHADER_CLOSEST_HIT:
-   case MESA_SHADER_MISS:
-   case MESA_SHADER_CALLABLE:
-   case MESA_SHADER_INTERSECTION:
-   case MESA_SHADER_ANY_HIT: {
+   /* TCS and GFX9 GS are special cases, already in units of the allocation granule. */
+   if (ctx->stage.has(SWStage::TCS))
+      ctx->program->config->lds_size = ctx->program->info.tcs.num_lds_blocks;
+   else if (ctx->stage == vertex_geometry_gs || ctx->stage == tess_eval_geometry_gs)
+      ctx->program->config->lds_size = ctx->program->info.gfx9_gs_ring_lds_size;
+   else
       ctx->program->config->lds_size =
          DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
-      break;
-   }
-   case MESA_SHADER_VERTEX: {
-      setup_vs_variables(ctx, nir);
-      break;
-   }
-   case MESA_SHADER_GEOMETRY: {
-      setup_gs_variables(ctx, nir);
-      break;
-   }
-   case MESA_SHADER_TESS_CTRL: {
-      break;
-   }
-   case MESA_SHADER_TESS_EVAL: {
-      setup_tes_variables(ctx, nir);
-      break;
-   }
-   case MESA_SHADER_MESH: {
-      setup_ms_variables(ctx, nir);
-      break;
-   }
-   default: unreachable("Unhandled shader stage.");
-   }
 
    /* Make sure we fit the available LDS space. */
    assert((ctx->program->config->lds_size * ctx->program->dev.lds_encoding_granule) <=
@@ -342,9 +275,6 @@ setup_variables(isel_context* ctx, nir_shader* nir)
 void
 setup_nir(isel_context* ctx, nir_shader* nir)
 {
-   /* the variable setup has to be done before lower_io / CSE */
-   setup_variables(ctx, nir);
-
    nir_convert_to_lcssa(nir, true, false);
    nir_lower_phis_to_scalar(nir, true);
 
@@ -864,6 +794,7 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
    for (unsigned i = 0; i < shader_count; i++) {
       nir_shader* nir = shaders[i];
       setup_nir(&ctx, nir);
+      setup_lds_size(&ctx, nir);
    }
 
    for (unsigned i = 0; i < shader_count; i++)
-- 
GitLab


From 5619b036dc94803eb103814fa8d978c337d274e6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 15 Mar 2023 12:20:13 -0700
Subject: [PATCH 4/5] aco, radv: Remove "key" from aco_compiler_options.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

aco_compiler_options::key is a leftover from when aco used
the radv_pipeline_key struct, but aco_compiler_options::key was
never actually used as a cache key.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21935>
---
 .../compiler/aco_instruction_selection.cpp    | 23 ++++----
 src/amd/compiler/aco_interface.cpp            |  6 +--
 src/amd/compiler/aco_shader_info.h            | 52 ++++++++-----------
 src/amd/vulkan/radv_aco_shader_info.h         | 27 +++++-----
 src/amd/vulkan/radv_shader.c                  |  8 +--
 5 files changed, 51 insertions(+), 65 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index da627f5a2f93..af9ead23c939 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -6079,8 +6079,7 @@ get_image_coords(isel_context* ctx, const nir_intrinsic_instr* instr)
          lod = get_ssa_temp_tex(ctx, instr->src[lod_index].ssa, a16);
    }
 
-   if (ctx->options->key.image_2d_view_of_3d &&
-       dim == GLSL_SAMPLER_DIM_2D && !is_array) {
+   if (ctx->program->info.image_2d_view_of_3d && dim == GLSL_SAMPLER_DIM_2D && !is_array) {
       /* The hw can't bind a slice of a 3D image as a 2D image, because it
        * ignores BASE_ARRAY if the target is 3D. The workaround is to read
        * BASE_ARRAY and set it as the 3rd address operand for all 2D images.
@@ -10720,8 +10719,8 @@ export_fs_mrt_z(isel_context* ctx)
       values[i] = Operand(v1);
    }
 
-   bool writes_mrt0_alpha =
-      ctx->options->key.ps.alpha_to_coverage_via_mrtz && (ctx->outputs.mask[FRAG_RESULT_DATA0] & 0x8);
+   bool writes_mrt0_alpha = ctx->program->info.ps.alpha_to_coverage_via_mrtz &&
+                            (ctx->outputs.mask[FRAG_RESULT_DATA0] & 0x8);
 
    /* Both stencil and sample mask only need 16-bits. */
    if (!ctx->program->info.ps.writes_z && !writes_mrt0_alpha &&
@@ -11042,7 +11041,7 @@ create_fs_jump_to_epilog(isel_context* ctx)
       }
    }
 
-   Temp continue_pc = convert_pointer_to_64_bit(ctx, get_arg(ctx, ctx->options->key.ps.epilog.pc));
+   Temp continue_pc = convert_pointer_to_64_bit(ctx, get_arg(ctx, ctx->program->info.ps.epilog.pc));
 
    aco_ptr<Pseudo_instruction> jump{create_instruction<Pseudo_instruction>(
       aco_opcode::p_jump_to_epilog, Format::PSEUDO, 1 + color_exports.size(), 0)};
@@ -11104,7 +11103,7 @@ create_fs_exports(isel_context* ctx)
        * require MRT0 to be written. Just copy MRT1 into MRT0. Skipping MRT1 exports seems to be
        * fine.
        */
-      if (ctx->options->key.ps.epilog.mrt0_is_dual_src && !ctx->outputs.mask[FRAG_RESULT_DATA0] &&
+      if (ctx->program->info.ps.epilog.mrt0_is_dual_src && !ctx->outputs.mask[FRAG_RESULT_DATA0] &&
           ctx->outputs.mask[FRAG_RESULT_DATA1]) {
          u_foreach_bit (j, ctx->outputs.mask[FRAG_RESULT_DATA1]) {
             ctx->outputs.temps[FRAG_RESULT_DATA0 * 4u + j] =
@@ -11126,9 +11125,9 @@ create_fs_exports(isel_context* ctx)
 
          out.slot = compacted_mrt_index;
          out.write_mask = ctx->outputs.mask[i];
-         out.col_format = (ctx->options->key.ps.epilog.spi_shader_col_format >> (4 * idx)) & 0xf;
-         out.is_int8 = (ctx->options->key.ps.epilog.color_is_int8 >> idx) & 1;
-         out.is_int10 = (ctx->options->key.ps.epilog.color_is_int10 >> idx) & 1;
+         out.col_format = (ctx->program->info.ps.epilog.spi_shader_col_format >> (4 * idx)) & 0xf;
+         out.is_int8 = (ctx->program->info.ps.epilog.color_is_int8 >> idx) & 1;
+         out.is_int10 = (ctx->program->info.ps.epilog.color_is_int10 >> idx) & 1;
          out.enable_mrt_output_nan_fixup =
             (ctx->options->enable_mrt_output_nan_fixup >> idx) & 1;
 
@@ -11147,7 +11146,7 @@ create_fs_exports(isel_context* ctx)
       }
 
       if (exported) {
-         if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.epilog.mrt0_is_dual_src) {
+         if (ctx->options->gfx_level >= GFX11 && ctx->program->info.ps.epilog.mrt0_is_dual_src) {
             struct aco_export_mrt* mrt0 = mrts[0].enabled_channels ? &mrts[0] : NULL;
             struct aco_export_mrt* mrt1 = mrts[1].enabled_channels ? &mrts[1] : NULL;
             create_fs_dual_src_export_gfx11(ctx, mrt0, mrt1);
@@ -11564,8 +11563,8 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
          if (!ngg_gs && !tcs_skip_barrier) {
             sync_scope scope =
                ctx.stage == vertex_tess_control_hs &&
-                     ctx.options->key.tcs.tess_input_vertices == nir->info.tess.tcs_vertices_out &&
-                     program->wave_size % ctx.options->key.tcs.tess_input_vertices == 0
+                     ctx.program->info.tcs.tess_input_vertices == nir->info.tess.tcs_vertices_out &&
+                     program->wave_size % ctx.program->info.tcs.tess_input_vertices == 0
                   ? scope_subgroup
                   : scope_workgroup;
             bld.barrier(aco_opcode::p_barrier,
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 661ceb130813..41f8b0db75e6 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -126,7 +126,7 @@ aco_postprocess_shader(const struct aco_compiler_options* options,
       validate(program.get());
 
       /* Optimization */
-      if (!options->key.optimisations_disabled) {
+      if (!options->optimisations_disabled) {
          if (!(aco::debug_flags & aco::DEBUG_NO_VN))
             aco::value_numbering(program.get());
          if (!(aco::debug_flags & aco::DEBUG_NO_OPT))
@@ -165,7 +165,7 @@ aco_postprocess_shader(const struct aco_compiler_options* options,
       aco_print_program(program.get(), stderr, live_vars, aco::print_live_vars | aco::print_kill);
 
    if (!info->is_trap_handler_shader) {
-      if (!options->key.optimisations_disabled && !(aco::debug_flags & aco::DEBUG_NO_SCHED))
+      if (!options->optimisations_disabled && !(aco::debug_flags & aco::DEBUG_NO_SCHED))
          aco::schedule_program(program.get(), live_vars);
       validate(program.get());
 
@@ -182,7 +182,7 @@ aco_postprocess_shader(const struct aco_compiler_options* options,
       validate(program.get());
 
       /* Optimization */
-      if (!options->key.optimisations_disabled && !(aco::debug_flags & aco::DEBUG_NO_OPT)) {
+      if (!options->optimisations_disabled && !(aco::debug_flags & aco::DEBUG_NO_OPT)) {
          aco::optimize_postRA(program.get());
          validate(program.get());
       }
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index d4c9a60fb3b8..5b98501011b1 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -63,11 +63,26 @@ struct aco_vs_prolog_info {
    gl_shader_stage next_stage;
 };
 
+struct aco_ps_epilog_info {
+   struct ac_arg inputs[8];
+   struct ac_arg pc;
+
+   uint32_t spi_shader_col_format;
+
+   /* Bitmasks, each bit represents one of the 8 MRTs. */
+   uint8_t color_is_int8;
+   uint8_t color_is_int10;
+   uint8_t enable_mrt_output_nan_fixup;
+
+   bool mrt0_is_dual_src;
+};
+
 struct aco_shader_info {
    uint8_t wave_size;
    bool is_ngg;
    bool has_ngg_culling;
    bool has_ngg_early_prim_export;
+   bool image_2d_view_of_3d;
    unsigned workgroup_size;
    struct {
       bool as_es;
@@ -87,17 +102,22 @@ struct aco_shader_info {
    } gs;
    struct {
       uint32_t num_lds_blocks;
+      unsigned tess_input_vertices;
    } tcs;
    struct {
       bool as_es;
    } tes;
    struct {
+      struct aco_ps_epilog_info epilog;
       bool writes_z;
       bool writes_stencil;
       bool writes_sample_mask;
       bool has_epilog;
       uint32_t num_interp;
       unsigned spi_ps_input;
+
+      /* Used to export alpha through MRTZ for alpha-to-coverage (GFX11+). */
+      bool alpha_to_coverage_via_mrtz;
    } ps;
    struct {
       uint8_t subgroup_size;
@@ -114,38 +134,7 @@ enum aco_compiler_debug_level {
    ACO_COMPILER_DEBUG_LEVEL_ERROR,
 };
 
-struct aco_ps_epilog_info {
-   struct ac_arg inputs[8];
-   struct ac_arg pc;
-
-   uint32_t spi_shader_col_format;
-
-   /* Bitmasks, each bit represents one of the 8 MRTs. */
-   uint8_t color_is_int8;
-   uint8_t color_is_int10;
-   uint8_t enable_mrt_output_nan_fixup;
-
-   bool mrt0_is_dual_src;
-};
-
-struct aco_stage_input {
-   uint32_t optimisations_disabled : 1;
-   uint32_t image_2d_view_of_3d : 1;
-
-   struct {
-      unsigned tess_input_vertices;
-   } tcs;
-
-   struct {
-      struct aco_ps_epilog_info epilog;
-
-      /* Used to export alpha through MRTZ for alpha-to-coverage (GFX11+). */
-      bool alpha_to_coverage_via_mrtz;
-   } ps;
-};
-
 struct aco_compiler_options {
-   struct aco_stage_input key;
    bool robust_buffer_access;
    bool dump_shader;
    bool dump_preoptir;
@@ -153,6 +142,7 @@ struct aco_compiler_options {
    bool record_stats;
    bool has_ls_vgpr_init_bug;
    bool load_grid_size_from_user_sgpr;
+   bool optimisations_disabled;
    uint8_t enable_mrt_output_nan_fixup;
    bool wgp_mode;
    enum radeon_family family;
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 32bb76d8fe76..ccfa6088eb06 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -34,11 +34,16 @@
 #define ASSIGN_FIELD(x) aco_info->x = radv->x
 #define ASSIGN_FIELD_CP(x) memcpy(&aco_info->x, &radv->x, sizeof(radv->x))
 
+static inline void radv_aco_convert_ps_epilog_key(struct aco_ps_epilog_info *aco_info,
+                                                  const struct radv_ps_epilog_key *radv,
+                                                  const struct radv_shader_args *radv_args);
+
 static inline void
-radv_aco_convert_shader_info(struct aco_shader_info *aco_info,
-			     const struct radv_shader_info *radv,
-              const struct radv_shader_args *radv_args)
+radv_aco_convert_shader_info(struct aco_shader_info *aco_info, const struct radv_shader_info *radv,
+                             const struct radv_shader_args *radv_args,
+                             const struct radv_pipeline_key *radv_key)
 {
+   radv_aco_convert_ps_epilog_key(&aco_info->ps.epilog, &radv_key->ps.epilog, radv_args);
    ASSIGN_FIELD(wave_size);
    ASSIGN_FIELD(is_ngg);
    ASSIGN_FIELD(has_ngg_culling);
@@ -68,6 +73,9 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info,
    ASSIGN_FIELD(cs.uses_full_subgroups);
    aco_info->gfx9_gs_ring_lds_size = radv->gs_ring_info.lds_size;
    aco_info->is_trap_handler_shader = radv_args->type == RADV_SHADER_TYPE_TRAP_HANDLER;
+   aco_info->tcs.tess_input_vertices = radv_key->tcs.tess_input_vertices;
+   aco_info->ps.alpha_to_coverage_via_mrtz = radv_key->ps.alpha_to_coverage_via_mrtz;
+   aco_info->image_2d_view_of_3d = radv_key->image_2d_view_of_3d;
 }
 
 #define ASSIGN_VS_STATE_FIELD(x) aco_info->state.x = radv->state->x
@@ -107,23 +115,11 @@ radv_aco_convert_ps_epilog_key(struct aco_ps_epilog_info *aco_info,
    aco_info->pc = radv_args->ps_epilog_pc;
 }
 
-static inline void
-radv_aco_convert_pipe_key(struct aco_stage_input *aco_info, const struct radv_pipeline_key *radv,
-                          const struct radv_shader_args *radv_args)
-{
-   radv_aco_convert_ps_epilog_key(&aco_info->ps.epilog, &radv->ps.epilog, radv_args);
-   ASSIGN_FIELD(optimisations_disabled);
-   ASSIGN_FIELD(image_2d_view_of_3d);
-   ASSIGN_FIELD(tcs.tess_input_vertices);
-   ASSIGN_FIELD(ps.alpha_to_coverage_via_mrtz);
-}
-
 static inline void
 radv_aco_convert_opts(struct aco_compiler_options *aco_info,
                       const struct radv_nir_compiler_options *radv,
                       const struct radv_shader_args *radv_args)
 {
-   radv_aco_convert_pipe_key(&aco_info->key, &radv->key, radv_args);
    ASSIGN_FIELD(robust_buffer_access);
    ASSIGN_FIELD(dump_shader);
    ASSIGN_FIELD(dump_preoptir);
@@ -139,6 +135,7 @@ radv_aco_convert_opts(struct aco_compiler_options *aco_info,
    ASSIGN_FIELD(debug.private_data);
    ASSIGN_FIELD(debug.private_data);
    aco_info->load_grid_size_from_user_sgpr = radv_args->load_grid_size_from_user_sgpr;
+   aco_info->optimisations_disabled = radv->key.optimisations_disabled;
 }
 #undef ASSIGN_VS_STATE_FIELD
 #undef ASSIGN_VS_STATE_FIELD_CP
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index dbbb797bc0b6..0129516cee59 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2213,7 +2213,7 @@ shader_compile(struct radv_device *device, struct nir_shader *const *shaders, in
       struct aco_shader_info ac_info;
       struct aco_compiler_options ac_opts;
       radv_aco_convert_opts(&ac_opts, options, args);
-      radv_aco_convert_shader_info(&ac_info, info, args);
+      radv_aco_convert_shader_info(&ac_info, info, args, &options->key);
       aco_compile_shader(&ac_opts, &ac_info, shader_count, shaders, &args->ac, &radv_aco_build_shader_binary, (void **)&binary);
    }
 
@@ -2373,7 +2373,7 @@ radv_create_rt_prolog(struct radv_device *device)
    struct radv_shader_binary *binary = NULL;
    struct aco_shader_info ac_info;
    struct aco_compiler_options ac_opts;
-   radv_aco_convert_shader_info(&ac_info, &info, &in_args);
+   radv_aco_convert_shader_info(&ac_info, &info, &in_args, &options.key);
    radv_aco_convert_opts(&ac_opts, &options, &in_args);
    aco_compile_rt_prolog(&ac_opts, &ac_info, &in_args.ac, &out_args.ac,
                          &radv_aco_build_shader_binary, (void **)&binary);
@@ -2441,7 +2441,7 @@ radv_create_vs_prolog(struct radv_device *device, const struct radv_vs_prolog_ke
    struct aco_shader_info ac_info;
    struct aco_vs_prolog_info ac_prolog_info;
    struct aco_compiler_options ac_opts;
-   radv_aco_convert_shader_info(&ac_info, &info, &args);
+   radv_aco_convert_shader_info(&ac_info, &info, &args, &options.key);
    radv_aco_convert_opts(&ac_opts, &options, &args);
    radv_aco_convert_vs_prolog_key(&ac_prolog_info, key, &args);
    aco_compile_vs_prolog(&ac_opts, &ac_info, &ac_prolog_info, &args.ac, &radv_aco_build_shader_part,
@@ -2494,7 +2494,7 @@ radv_create_ps_epilog(struct radv_device *device, const struct radv_ps_epilog_ke
    struct aco_shader_info ac_info;
    struct aco_ps_epilog_info ac_epilog_info;
    struct aco_compiler_options ac_opts;
-   radv_aco_convert_shader_info(&ac_info, &info, &args);
+   radv_aco_convert_shader_info(&ac_info, &info, &args, &options.key);
    radv_aco_convert_opts(&ac_opts, &options, &args);
    radv_aco_convert_ps_epilog_key(&ac_epilog_info, key, &args);
    aco_compile_ps_epilog(&ac_opts, &ac_info, &ac_epilog_info, &args.ac, &radv_aco_build_shader_part,
-- 
GitLab


From 3ddce660846489bb63b153cbebbca5393c6eefd4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Tue, 11 Apr 2023 16:22:49 +0200
Subject: [PATCH 5/5] aco, radv: Remove redundant enable_mrt_output_nan_fixup
 from PS epilog info.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21935>
---
 src/amd/compiler/aco_instruction_selection.cpp | 2 +-
 src/amd/compiler/aco_shader_info.h             | 1 -
 src/amd/vulkan/radv_aco_shader_info.h          | 1 -
 3 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index af9ead23c939..38dedd5935d2 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12195,7 +12195,7 @@ select_ps_epilog(Program* program, const struct aco_ps_epilog_info* einfo, ac_sh
       out.col_format = col_format;
       out.is_int8 = (einfo->color_is_int8 >> i) & 1;
       out.is_int10 = (einfo->color_is_int10 >> i) & 1;
-      out.enable_mrt_output_nan_fixup = (einfo->enable_mrt_output_nan_fixup >> i) & 1;
+      out.enable_mrt_output_nan_fixup = (options->enable_mrt_output_nan_fixup >> i) & 1;
 
       Temp inputs = get_arg(&ctx, einfo->inputs[i]);
       emit_split_vector(&ctx, inputs, 4);
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 5b98501011b1..69d28824031f 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -72,7 +72,6 @@ struct aco_ps_epilog_info {
    /* Bitmasks, each bit represents one of the 8 MRTs. */
    uint8_t color_is_int8;
    uint8_t color_is_int10;
-   uint8_t enable_mrt_output_nan_fixup;
 
    bool mrt0_is_dual_src;
 };
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index ccfa6088eb06..80d10ebf9d87 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -108,7 +108,6 @@ radv_aco_convert_ps_epilog_key(struct aco_ps_epilog_info *aco_info,
    ASSIGN_FIELD(spi_shader_col_format);
    ASSIGN_FIELD(color_is_int8);
    ASSIGN_FIELD(color_is_int10);
-   ASSIGN_FIELD(enable_mrt_output_nan_fixup);
    ASSIGN_FIELD(mrt0_is_dual_src);
 
    memcpy(aco_info->inputs, radv_args->ps_epilog_inputs, sizeof(aco_info->inputs));
-- 
GitLab

