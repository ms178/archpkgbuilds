From 565e9e9e3b8c370bcc29f22e1586de4657412334 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 23 Aug 2022 14:57:56 -0400
Subject: [PATCH 01/13] mesa: fix glDrawRangeElementsBaseVertex should be
 compiled into display list

It's defined in terms of glDrawRangeElements, which is compiled into display
lists.

Cc: stable
Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 .../glapi/gen/ARB_draw_elements_base_vertex.xml   |  2 +-
 src/mesa/main/glthread_draw.c                     |  2 +-
 src/mesa/vbo/vbo_save_api.c                       | 15 +++++++++++++++
 3 files changed, 17 insertions(+), 2 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml b/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
index 129582b1adc3..a7b1be1c6eee 100644
--- a/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
+++ b/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
@@ -16,7 +16,7 @@
         <param name="basevertex" type="GLint"/>
     </function>
 
-    <function name="DrawRangeElementsBaseVertex" es2="3.2" marshal="custom">
+    <function name="DrawRangeElementsBaseVertex" es2="3.2" marshal="custom" exec="dlist">
         <param name="mode" type="GLenum"/>
         <param name="start" type="GLuint"/>
         <param name="end" type="GLuint"/>
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 21fce5010ef3..274db8b475c4 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -1198,7 +1198,7 @@ _mesa_marshal_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
                                           GLsizei count, GLenum type,
                                           const GLvoid *indices, GLint basevertex)
 {
-   draw_elements(mode, count, type, indices, 1, basevertex, 0, true, start, end, false);
+   draw_elements(mode, count, type, indices, 1, basevertex, 0, true, start, end, true);
 }
 
 void GLAPIENTRY
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index 29c9c629fb50..7d9148878298 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -1874,6 +1874,21 @@ save_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
    save_DrawElements(mode, count, type, indices);
 }
 
+void GLAPIENTRY
+save_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
+                                 GLsizei count, GLenum type,
+                                 const GLvoid *indices, GLint basevertex)
+{
+   GET_CURRENT_CONTEXT(ctx);
+
+   if (end < start) {
+      _mesa_compile_error(ctx, GL_INVALID_VALUE,
+                          "glDrawRangeElementsBaseVertex(end < start)");
+      return;
+   }
+
+   save_DrawElementsBaseVertex(mode, count, type, indices, basevertex);
+}
 
 void GLAPIENTRY
 save_MultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type,
-- 
GitLab


From 0c567df23c5068d71f6125df0d7e8b6b6ae5856d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 23 Aug 2022 15:02:48 -0400
Subject: [PATCH 02/13] glthread: fix draws not compiled into a display list
 should generate an error

Before it just crashed if indices were invalid.

Cc: stable
Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/mesa/main/glthread_draw.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 274db8b475c4..3af1d3d3e06c 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -396,7 +396,9 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
     * for possible GL errors.
     */
    if (ctx->API == API_OPENGL_CORE || !user_buffer_mask ||
-       count <= 0 || instance_count <= 0) {
+       count <= 0 || instance_count <= 0 ||
+       /* This will just generate GL_INVALID_OPERATION, as it should. */
+       (!compiled_into_dlist && ctx->GLThread.ListMode)) {
       draw_arrays_async(ctx, mode, first, count, instance_count, baseinstance);
       return;
    }
@@ -794,7 +796,9 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    if (ctx->API == API_OPENGL_CORE ||
        count <= 0 || instance_count <= 0 || max_index < min_index ||
        !is_index_type_valid(type) ||
-       (!user_buffer_mask && !has_user_indices)) {
+       (!user_buffer_mask && !has_user_indices) ||
+       /* This will just generate GL_INVALID_OPERATION, as it should. */
+       (!compiled_into_dlist && ctx->GLThread.ListMode)) {
       draw_elements_async(ctx, mode, count, type, indices, instance_count,
                           basevertex, baseinstance, index_bounds_valid,
                           min_index, max_index);
-- 
GitLab


From d0c70b8a2c86eecaac5f5b7fb843c6c2cb564b5a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 23 Aug 2022 15:40:01 -0400
Subject: [PATCH 03/13] glthread: generate errors for glGet functions between
 glBegin/End

Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/mapi/glapi/gen/gl_API.xml      |  6 ++++--
 src/mesa/main/glthread.h           |  1 +
 src/mesa/main/glthread_get.c       |  5 +++++
 src/mesa/main/glthread_marshal.h   |  4 ++++
 src/mesa/main/glthread_shaderobj.c | 15 +++++++++++++++
 5 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index bffb07232879..ce7374535859 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -1155,7 +1155,8 @@
         <glx rop="3"/>
     </function>
 
-    <function name="Begin" deprecated="3.1" exec="vtxfmt">
+    <function name="Begin" deprecated="3.1" exec="vtxfmt"
+              marshal_call_after="ctx->GLThread.inside_begin_end = true;">
         <param name="mode" type="GLenum"/>
         <glx rop="4"/>
     </function>
@@ -1369,7 +1370,8 @@
         <glx rop="22"/>
     </function>
 
-    <function name="End" deprecated="3.1" exec="vtxfmt">
+    <function name="End" deprecated="3.1" exec="vtxfmt"
+              marshal_call_after="ctx->GLThread.inside_begin_end = false;">
         <glx rop="23"/>
     </function>
 
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index de9783443b0c..6ed17a3c69db 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -154,6 +154,7 @@ struct glthread_state
 
    /** Whether GLThread is enabled. */
    bool enabled;
+   bool inside_begin_end;
 
    /** Display lists. */
    GLenum ListMode; /**< Zero if not inside display list, else list mode. */
diff --git a/src/mesa/main/glthread_get.c b/src/mesa/main/glthread_get.c
index 2c85d605ef9d..916f9b3a49bc 100644
--- a/src/mesa/main/glthread_get.c
+++ b/src/mesa/main/glthread_get.c
@@ -38,6 +38,10 @@ _mesa_marshal_GetIntegerv(GLenum pname, GLint *p)
 {
    GET_CURRENT_CONTEXT(ctx);
 
+   /* This will generate GL_INVALID_OPERATION, as it should. */
+   if (ctx->GLThread.inside_begin_end)
+      goto sync;
+
    /* TODO: Use get_hash_params.py to return values for items containing:
     * - CONST(
     * - CONTEXT_[A-Z]*(Const
@@ -127,6 +131,7 @@ _mesa_marshal_GetIntegerv(GLenum pname, GLint *p)
       return;
    }
 
+sync:
    _mesa_glthread_finish_before(ctx, "GetIntegerv");
    CALL_GetIntegerv(ctx->CurrentServerDispatch, (pname, p));
 }
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 2db4be1a28b2..9c56e57e78ce 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -487,6 +487,10 @@ _mesa_glthread_Disable(struct gl_context *ctx, GLenum cap)
 static inline int
 _mesa_glthread_IsEnabled(struct gl_context *ctx, GLenum cap)
 {
+   /* This will generate GL_INVALID_OPERATION, as it should. */
+   if (ctx->GLThread.inside_begin_end)
+      return -1;
+
    switch (cap) {
    case GL_CULL_FACE:
       return ctx->GLThread.CullFace;
diff --git a/src/mesa/main/glthread_shaderobj.c b/src/mesa/main/glthread_shaderobj.c
index 3fd5bbdcefce..617f10fb5904 100644
--- a/src/mesa/main/glthread_shaderobj.c
+++ b/src/mesa/main/glthread_shaderobj.c
@@ -155,6 +155,15 @@ _mesa_marshal_GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize,
 {
    GET_CURRENT_CONTEXT(ctx);
 
+   /* This will generate GL_INVALID_OPERATION, as it should. */
+   if (ctx->GLThread.inside_begin_end) {
+      _mesa_glthread_finish_before(ctx, "GetActiveUniform");
+      CALL_GetActiveUniform(ctx->CurrentServerDispatch,
+                            (program, index, bufSize, length, size, type,
+                             name));
+      return;
+   }
+
    wait_for_glLinkProgram(ctx);
 
    /* We can execute glGetActiveUniform without syncing if we are sync'd to
@@ -182,6 +191,12 @@ _mesa_marshal_GetUniformLocation(GLuint program, const GLchar *name)
 {
    GET_CURRENT_CONTEXT(ctx);
 
+   /* This will generate GL_INVALID_OPERATION, as it should. */
+   if (ctx->GLThread.inside_begin_end) {
+      _mesa_glthread_finish_before(ctx, "GetUniformLocation");
+      return CALL_GetUniformLocation(ctx->CurrentServerDispatch, (program, name));
+   }
+
    wait_for_glLinkProgram(ctx);
 
    /* This is thread-safe. See the comment in _mesa_marshal_GetActiveUniform. */
-- 
GitLab


From 687288dfb5acf10bc347456dbfd2dfd56b54f554 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 23 Aug 2022 15:41:52 -0400
Subject: [PATCH 04/13] glthread: always sync for glShaderSource because
 invalid params can crash

If an invalid parameter is received along with an invalid pointer and we
ignore the invalid parameter and dereference the pointer, we crash.
Since we can't fully validate all parameters (such as whether "shader"
is a valid object ID), remove the custom code.

Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/mapi/glapi/gen/gl_API.xml      |  2 +-
 src/mesa/main/glthread_shaderobj.c | 92 ------------------------------
 2 files changed, 1 insertion(+), 93 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index ce7374535859..1d21f3a72db3 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -5557,7 +5557,7 @@
         <glx ignore="true"/>
     </function>
 
-    <function name="ShaderSource" es2="2.0" marshal="custom" no_error="true">
+    <function name="ShaderSource" es2="2.0" no_error="true">
         <param name="shader" type="GLuint"/>
         <param name="count" type="GLsizei"/>
         <param name="string" type="const GLchar * const *"/>
diff --git a/src/mesa/main/glthread_shaderobj.c b/src/mesa/main/glthread_shaderobj.c
index 617f10fb5904..773e7c3af61a 100644
--- a/src/mesa/main/glthread_shaderobj.c
+++ b/src/mesa/main/glthread_shaderobj.c
@@ -26,98 +26,6 @@
 #include "uniforms.h"
 #include "api_exec_decl.h"
 
-struct marshal_cmd_ShaderSource
-{
-   struct marshal_cmd_base cmd_base;
-   GLuint shader;
-   GLsizei count;
-   /* Followed by GLint length[count], then the contents of all strings,
-    * concatenated.
-    */
-};
-
-
-uint32_t
-_mesa_unmarshal_ShaderSource(struct gl_context *ctx,
-                             const struct marshal_cmd_ShaderSource *cmd,
-                             const uint64_t *last)
-{
-   const GLint *cmd_length = (const GLint *) (cmd + 1);
-   const GLchar *cmd_strings = (const GLchar *) (cmd_length + cmd->count);
-   /* TODO: how to deal with malloc failure? */
-   const GLchar * *string = malloc(cmd->count * sizeof(const GLchar *));
-   int i;
-
-   for (i = 0; i < cmd->count; ++i) {
-      string[i] = cmd_strings;
-      cmd_strings += cmd_length[i];
-   }
-   CALL_ShaderSource(ctx->CurrentServerDispatch,
-                     (cmd->shader, cmd->count, string, cmd_length));
-   free((void *)string);
-   return cmd->cmd_base.cmd_size;
-}
-
-
-static size_t
-measure_ShaderSource_strings(GLsizei count, const GLchar * const *string,
-                             const GLint *length_in, GLint *length_out)
-{
-   int i;
-   size_t total_string_length = 0;
-
-   for (i = 0; i < count; ++i) {
-      if (length_in == NULL || length_in[i] < 0) {
-         if (string[i])
-            length_out[i] = strlen(string[i]);
-      } else {
-         length_out[i] = length_in[i];
-      }
-      total_string_length += length_out[i];
-   }
-   return total_string_length;
-}
-
-
-void GLAPIENTRY
-_mesa_marshal_ShaderSource(GLuint shader, GLsizei count,
-                           const GLchar * const *string, const GLint *length)
-{
-   /* TODO: how to report an error if count < 0? */
-
-   GET_CURRENT_CONTEXT(ctx);
-   /* TODO: how to deal with malloc failure? */
-   const size_t fixed_cmd_size = sizeof(struct marshal_cmd_ShaderSource);
-   STATIC_ASSERT(sizeof(struct marshal_cmd_ShaderSource) % sizeof(GLint) == 0);
-   size_t length_size = count * sizeof(GLint);
-   GLint *length_tmp = malloc(length_size);
-   size_t total_string_length =
-      measure_ShaderSource_strings(count, string, length, length_tmp);
-   size_t total_cmd_size = fixed_cmd_size + length_size + total_string_length;
-
-   if (total_cmd_size <= MARSHAL_MAX_CMD_SIZE && count > 0) {
-      struct marshal_cmd_ShaderSource *cmd =
-         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_ShaderSource,
-                                         total_cmd_size);
-      GLint *cmd_length = (GLint *) (cmd + 1);
-      GLchar *cmd_strings = (GLchar *) (cmd_length + count);
-      int i;
-
-      cmd->shader = shader;
-      cmd->count = count;
-      memcpy(cmd_length, length_tmp, length_size);
-      for (i = 0; i < count; ++i) {
-         memcpy(cmd_strings, string[i], cmd_length[i]);
-         cmd_strings += cmd_length[i];
-      }
-   } else {
-      _mesa_glthread_finish(ctx);
-      CALL_ShaderSource(ctx->CurrentServerDispatch,
-                        (shader, count, string, length_tmp));
-   }
-   free(length_tmp);
-}
-
 void
 _mesa_glthread_ProgramChanged(struct gl_context *ctx)
 {
-- 
GitLab


From ce16079b767b73b9780e42d4d0e0f96a4658a622 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 23 Aug 2022 15:55:35 -0400
Subject: [PATCH 05/13] glthread: fix glGetIntegerv(GL_CLIENT_ACTIVE_TEXTURE)

Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/mesa/main/glthread_get.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/mesa/main/glthread_get.c b/src/mesa/main/glthread_get.c
index 916f9b3a49bc..6a3ed67c0817 100644
--- a/src/mesa/main/glthread_get.c
+++ b/src/mesa/main/glthread_get.c
@@ -58,7 +58,7 @@ _mesa_marshal_GetIntegerv(GLenum pname, GLint *p)
       *p = ctx->GLThread.AttribStackDepth;
       return;
    case GL_CLIENT_ACTIVE_TEXTURE:
-      *p = ctx->GLThread.ClientActiveTexture;
+      *p = GL_TEXTURE0 + ctx->GLThread.ClientActiveTexture;
       return;
    case GL_CLIENT_ATTRIB_STACK_DEPTH:
       *p = ctx->GLThread.ClientAttribStackTop;
-- 
GitLab


From 60e1073bbe6cf158ad10c482ee10e05e20d10a80 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 23 Aug 2022 16:59:18 -0400
Subject: [PATCH 06/13] glthread: work around GL_INVALID_OPERATION with OpenGL
 ES 1.x draws

GLES1 only has (Multi)Draw{Array,Elements}, but glthread converts them
to the more complicated versions and then calls them through the dispatch,
which generated GL_INVALID_OPERATION.

Luckily, we can export them with the Internal prefix, so they are unlikely
to be used by apps by accident.

Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/mapi/glapi/gen/gl_API.xml | 44 +++++++++++++++++++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 1d21f3a72db3..35bbac8c8d18 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -12863,6 +12863,50 @@
 </category>
 
 <category name="GL_MESA_internal_functions">
+    <!-- These functions exist because glthread converts all draws to these
+         and then calls them through the dispatch table, so this is a workaround
+         for the GL_INVALID_OPERATION errors with OpenGL ES 1.x. -->
+    <function name="InternalDrawArraysInstancedBaseInstance" es1="1.0"
+              alias="DrawArraysInstancedBaseInstance">
+        <param name="mode" type="GLenum"/>
+        <param name="first" type="GLint"/>
+        <param name="count" type="GLsizei"/>
+        <param name="instancecount" type="GLsizei"/>
+        <param name="baseinstance" type="GLuint"/>
+    </function>
+
+    <function name="InternalDrawElementsInstancedBaseVertexBaseInstance" es1="1.0"
+              alias="DrawElementsInstancedBaseVertexBaseInstance">
+        <param name="mode" type="GLenum"/>
+        <param name="count" type="GLsizei"/>
+        <param name="type" type="GLenum"/>
+        <param name="indices" type="const GLvoid *"/>
+        <param name="instancecount" type="GLsizei"/>
+        <param name="basevertex" type="GLint"/>
+        <param name="baseinstance" type="GLuint"/>
+    </function>
+
+    <function name="InternalDrawRangeElementsBaseVertex" es1="1.0"
+              alias="DrawRangeElementsBaseVertex">
+        <param name="mode" type="GLenum"/>
+        <param name="start" type="GLuint"/>
+        <param name="end" type="GLuint"/>
+        <param name="count" type="GLsizei"/>
+        <param name="type" type="GLenum"/>
+        <param name="indices" type="const GLvoid *"/>
+        <param name="basevertex" type="GLint"/>
+    </function>
+
+    <function name="InternalMultiDrawElementsBaseVertex" es1="1.0"
+              alias="MultiDrawElementsBaseVertex">
+        <param name="mode" type="GLenum"/>
+        <param name="count" type="const GLsizei *"/>
+        <param name="type" type="GLenum"/>
+        <param name="indices" type="const GLvoid * const *"/>
+        <param name="primcount" type="GLsizei"/>
+        <param name="basevertex" type="const GLint *"/>
+    </function>
+
     <!-- Internal function for glthread to implement BufferSubData as a GPU copy. -->
     <function name="InternalBufferSubDataCopyMESA" es2="2.0">
         <param name="srcBuffer" type="GLintptr"/> <!-- "struct gl_buffer_object *" really -->
-- 
GitLab


From 5db4dc16ddfb71e93815980bc0fcb94285ab7da2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 22 Aug 2022 22:28:58 -0400
Subject: [PATCH 07/13] frontend/dri: make the backgroundCallable extension
 optional

It's only needed by X11/DRI2. This allows glthread to be used by android,
drm, wayland, and device (EGL backend).

This is the only solution to allow the egl/drm backend to work with glthread
without ugly hacks between libgbm and libEGL.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/gallium/frontends/dri/dri_context.c | 26 ++++++++++++-------------
 src/gallium/frontends/dri/dri_screen.c  |  8 ++------
 2 files changed, 14 insertions(+), 20 deletions(-)

diff --git a/src/gallium/frontends/dri/dri_context.c b/src/gallium/frontends/dri/dri_context.c
index 3a98eb2496a5..1d48665e3c59 100644
--- a/src/gallium/frontends/dri/dri_context.c
+++ b/src/gallium/frontends/dri/dri_context.c
@@ -206,20 +206,18 @@ dri_create_context(gl_api api, const struct gl_config * visual,
 
    /* Do this last. */
    if (ctx->st->start_thread &&
-         driQueryOptionb(&screen->dev->option_cache, "mesa_glthread")) {
-
-      if (backgroundCallable && backgroundCallable->base.version >= 2 &&
-            backgroundCallable->isThreadSafe) {
-
-         if (backgroundCallable->isThreadSafe(cPriv->loaderPrivate))
-            ctx->st->start_thread(ctx->st);
-         else
-            fprintf(stderr, "dri_create_context: glthread isn't thread safe "
-                  "- missing call XInitThreads\n");
-      } else {
-         fprintf(stderr, "dri_create_context: requested glthread but driver "
-               "is missing backgroundCallable V2 extension\n");
-      }
+       driQueryOptionb(&screen->dev->option_cache, "mesa_glthread")) {
+      bool safe = true;
+
+      /* This is only needed by X11/DRI2, which can be unsafe. */
+      if (backgroundCallable &&
+          backgroundCallable->base.version >= 2 &&
+          backgroundCallable->isThreadSafe &&
+          !backgroundCallable->isThreadSafe(cPriv->loaderPrivate))
+         safe = false;
+
+      if (safe)
+         ctx->st->start_thread(ctx->st);
    }
 
    *error = __DRI_CTX_ERROR_SUCCESS;
diff --git a/src/gallium/frontends/dri/dri_screen.c b/src/gallium/frontends/dri/dri_screen.c
index fe232baad705..e9f367121345 100644
--- a/src/gallium/frontends/dri/dri_screen.c
+++ b/src/gallium/frontends/dri/dri_screen.c
@@ -824,12 +824,8 @@ dri_set_background_context(struct st_context_iface *st,
    const __DRIbackgroundCallableExtension *backgroundCallable =
       ctx->sPriv->dri2.backgroundCallable;
 
-   /* Note: Mesa will only call this function if GL multithreading is enabled
-    * We only do that if the loader exposed the __DRI_BACKGROUND_CALLABLE
-    * extension. So we know that backgroundCallable is not NULL.
-    */
-   assert(backgroundCallable);
-   backgroundCallable->setBackgroundContext(ctx->cPriv->loaderPrivate);
+   if (backgroundCallable)
+      backgroundCallable->setBackgroundContext(ctx->cPriv->loaderPrivate);
 
    if (ctx->hud)
       hud_add_queue_for_monitoring(ctx->hud, queue_info);
-- 
GitLab


From 69eb7a3ad5f358f8178b8d1acf6b7efce7a748f9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 24 Aug 2022 02:21:00 -0400
Subject: [PATCH 08/13] frontend/dri: sync glthread when calling from the app
 side

The comments explain the reasons.

This is a prerequisite for glthread to be used by native drivers, swrast,
and zink.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/gallium/frontends/dri/dri2.c         | 34 +++++++++++++++++++++++
 src/gallium/frontends/dri/dri_context.c  | 12 ++++++++
 src/gallium/frontends/dri/dri_drawable.c |  6 ++++
 src/gallium/frontends/dri/dri_helpers.c  | 35 ++++++++++++++++++++++--
 src/gallium/frontends/dri/drisw.c        | 30 ++++++++++++++++++++
 src/gallium/frontends/dri/kopper.c       | 30 ++++++++++++++++++++
 6 files changed, 144 insertions(+), 3 deletions(-)

diff --git a/src/gallium/frontends/dri/dri2.c b/src/gallium/frontends/dri/dri2.c
index 400b94e8230f..240c5ca699a1 100644
--- a/src/gallium/frontends/dri/dri2.c
+++ b/src/gallium/frontends/dri/dri2.c
@@ -453,6 +453,12 @@ dri2_allocate_textures(struct dri_context *ctx,
 
    assert(num_buffers <= __DRI_BUFFER_COUNT);
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    /* First get the buffers from the loader */
    if (image) {
       if (!dri_image_drawable_get_buffers(drawable, &images,
@@ -752,6 +758,12 @@ dri2_flush_frontbuffer(struct dri_context *ctx,
        (!ctx->is_shared_buffer_bound || statt != ST_ATTACHMENT_BACK_LEFT))
          return false;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    if (drawable->stvis.samples > 1) {
       /* Resolve the buffer used for front rendering. */
       dri_pipe_blit(ctx->st->pipe, drawable->textures[statt],
@@ -1755,6 +1767,12 @@ dri2_blit_image(__DRIcontext *context, __DRIimage *dst, __DRIimage *src,
    if (!dst || !src)
       return;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    handle_in_fence(context, dst);
 
    memset(&blit, 0, sizeof(blit));
@@ -1807,6 +1825,12 @@ dri2_map_image(__DRIcontext *context, __DRIimage *image,
    if (plane >= dri2_get_mapping_by_format(image->dri_format)->nplanes)
       return NULL;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    handle_in_fence(context, image);
 
    struct pipe_resource *resource = image->texture;
@@ -1834,6 +1858,12 @@ dri2_unmap_image(__DRIcontext *context, __DRIimage *image, void *data)
    struct dri_context *ctx = dri_context(context);
    struct pipe_context *pipe = ctx->st->pipe;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    pipe_texture_unmap(pipe, (struct pipe_transfer *)data);
 }
 
@@ -2008,6 +2038,10 @@ dri2_interop_export_object(__DRIcontext *_ctx,
        in->miplevel != 0)
       return MESA_GLINTEROP_INVALID_MIP_LEVEL;
 
+   /* Wait for glthread to finish to get up-to-date GL object lookups. */
+   if (st->thread_finish)
+      st->thread_finish(st);
+
    /* Validate the OpenGL object and get pipe_resource. */
    simple_mtx_lock(&ctx->Shared->Mutex);
 
diff --git a/src/gallium/frontends/dri/dri_context.c b/src/gallium/frontends/dri/dri_context.c
index 1d48665e3c59..c304c8076801 100644
--- a/src/gallium/frontends/dri/dri_context.c
+++ b/src/gallium/frontends/dri/dri_context.c
@@ -236,6 +236,12 @@ dri_destroy_context(__DRIcontext * cPriv)
 {
    struct dri_context *ctx = dri_context(cPriv);
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    if (ctx->hud) {
       hud_destroy(ctx->hud, ctx->st->cso_context);
    }
@@ -289,6 +295,12 @@ dri_make_current(__DRIcontext * cPriv,
    struct dri_drawable *draw = dri_drawable(driDrawPriv);
    struct dri_drawable *read = dri_drawable(driReadPriv);
 
+   /* Wait for glthread to finish because we can't use st_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    if (!draw && !read)
       return ctx->stapi->make_current(ctx->stapi, ctx->st, NULL, NULL);
    else if (!draw || !read)
diff --git a/src/gallium/frontends/dri/dri_drawable.c b/src/gallium/frontends/dri/dri_drawable.c
index 2cf977eb05ca..f9df73ee896d 100644
--- a/src/gallium/frontends/dri/dri_drawable.c
+++ b/src/gallium/frontends/dri/dri_drawable.c
@@ -415,6 +415,12 @@ notify_before_flush_cb(void* _args)
    struct st_context_iface *st = args->ctx->st;
    struct pipe_context *pipe = st->pipe;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (st->thread_finish)
+      st->thread_finish(st);
+
    if (args->drawable->stvis.samples > 1 &&
        (args->reason == __DRI2_THROTTLE_SWAPBUFFER ||
         args->reason == __DRI2_THROTTLE_COPYSUBBUFFER)) {
diff --git a/src/gallium/frontends/dri/dri_helpers.c b/src/gallium/frontends/dri/dri_helpers.c
index 7b3d869b53ae..a656176c1d3e 100644
--- a/src/gallium/frontends/dri/dri_helpers.c
+++ b/src/gallium/frontends/dri/dri_helpers.c
@@ -96,6 +96,12 @@ dri2_create_fence(__DRIcontext *_ctx)
    if (!fence)
       return NULL;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (stapi->thread_finish)
+      stapi->thread_finish(stapi);
+
    stapi->flush(stapi, 0, &fence->pipe_fence, NULL, NULL);
 
    if (!fence->pipe_fence) {
@@ -114,6 +120,12 @@ dri2_create_fence_fd(__DRIcontext *_ctx, int fd)
    struct pipe_context *ctx = stapi->pipe;
    struct dri2_fence *fence = CALLOC_STRUCT(dri2_fence);
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (stapi->thread_finish)
+      stapi->thread_finish(stapi);
+
    if (fd == -1) {
       /* exporting driver created fence, flush: */
       stapi->flush(stapi, ST_FLUSH_FENCE_FD, &fence->pipe_fence, NULL, NULL);
@@ -211,7 +223,8 @@ dri2_client_wait_sync(__DRIcontext *_ctx, void *_fence, unsigned flags,
 static void
 dri2_server_wait_sync(__DRIcontext *_ctx, void *_fence, unsigned flags)
 {
-   struct pipe_context *ctx = dri_context(_ctx)->st->pipe;
+   struct st_context_iface *st = dri_context(_ctx)->st;
+   struct pipe_context *ctx = st->pipe;
    struct dri2_fence *fence = (struct dri2_fence*)_fence;
 
    /* We might be called here with a NULL fence as a result of WaitSyncKHR
@@ -220,6 +233,12 @@ dri2_server_wait_sync(__DRIcontext *_ctx, void *_fence, unsigned flags)
    if (!fence)
       return;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (st->thread_finish)
+      st->thread_finish(st);
+
    if (ctx->fence_server_sync)
       ctx->fence_server_sync(ctx, fence->pipe_fence);
 }
@@ -273,13 +292,18 @@ dri2_create_image_from_renderbuffer2(__DRIcontext *context,
 				     int renderbuffer, void *loaderPrivate,
                                      unsigned *error)
 {
-   struct st_context *st_ctx = (struct st_context *)dri_context(context)->st;
+   struct st_context_iface *st = dri_context(context)->st;
+   struct st_context *st_ctx = (struct st_context *)st;
    struct gl_context *ctx = st_ctx->ctx;
    struct pipe_context *p_ctx = st_ctx->pipe;
    struct gl_renderbuffer *rb;
    struct pipe_resource *tex;
    __DRIimage *img;
 
+   /* Wait for glthread to finish to get up-to-date GL object lookups. */
+   if (st->thread_finish)
+      st->thread_finish(st);
+
    /* Section 3.9 (EGLImage Specification and Management) of the EGL 1.5
     * specification says:
     *
@@ -369,13 +393,18 @@ dri2_create_from_texture(__DRIcontext *context, int target, unsigned texture,
                          void *loaderPrivate)
 {
    __DRIimage *img;
-   struct st_context *st_ctx = (struct st_context *)dri_context(context)->st;
+   struct st_context_iface *st = dri_context(context)->st;
+   struct st_context *st_ctx = (struct st_context *)st;
    struct gl_context *ctx = st_ctx->ctx;
    struct pipe_context *p_ctx = st_ctx->pipe;
    struct gl_texture_object *obj;
    struct pipe_resource *tex;
    GLuint face = 0;
 
+   /* Wait for glthread to finish to get up-to-date GL object lookups. */
+   if (st->thread_finish)
+      st->thread_finish(st);
+
    obj = _mesa_lookup_texture(ctx, texture);
    if (!obj || obj->Target != target) {
       *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
diff --git a/src/gallium/frontends/dri/drisw.c b/src/gallium/frontends/dri/drisw.c
index 1a3166452a55..b5c0b7a8ae2e 100644
--- a/src/gallium/frontends/dri/drisw.c
+++ b/src/gallium/frontends/dri/drisw.c
@@ -245,6 +245,12 @@ drisw_swap_buffers(__DRIdrawable *dPriv)
    if (!ctx)
       return;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    ptex = drawable->textures[ST_ATTACHMENT_BACK_LEFT];
 
    if (ptex) {
@@ -286,6 +292,12 @@ drisw_copy_sub_buffer(__DRIdrawable *dPriv, int x, int y,
    ptex = drawable->textures[ST_ATTACHMENT_BACK_LEFT];
 
    if (ptex) {
+      /* Wait for glthread to finish because we can't use pipe_context from
+       * multiple threads.
+       */
+      if (ctx->st->thread_finish)
+         ctx->st->thread_finish(ctx->st);
+
       struct pipe_fence_handle *fence = NULL;
       if (ctx->pp && drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL])
          pp_run(ctx->pp, ptex, ptex, drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL]);
@@ -318,6 +330,12 @@ drisw_flush_frontbuffer(struct dri_context *ctx,
    if (!ctx || statt != ST_ATTACHMENT_FRONT_LEFT)
       return false;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    if (drawable->stvis.samples > 1) {
       /* Resolve the front buffer. */
       dri_pipe_blit(ctx->st->pipe,
@@ -353,6 +371,12 @@ drisw_allocate_textures(struct dri_context *stctx,
    boolean resized;
    unsigned i;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (stctx->st->thread_finish)
+      stctx->st->thread_finish(stctx->st);
+
    width  = drawable->dPriv->w;
    height = drawable->dPriv->h;
 
@@ -439,6 +463,12 @@ drisw_update_tex_buffer(struct dri_drawable *drawable,
    int ximage_stride, line;
    int cpp = util_format_get_blocksize(res->format);
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    get_drawable_info(dPriv, &x, &y, &w, &h);
 
    map = pipe_texture_map(pipe, res,
diff --git a/src/gallium/frontends/dri/kopper.c b/src/gallium/frontends/dri/kopper.c
index 0d8d66d91d33..0102e2cf4774 100644
--- a/src/gallium/frontends/dri/kopper.c
+++ b/src/gallium/frontends/dri/kopper.c
@@ -507,6 +507,12 @@ kopper_allocate_textures(struct dri_context *ctx,
    resized = (drawable->old_w != width ||
               drawable->old_h != height);
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    /* First get the buffers from the loader */
    if (image) {
       if (!dri_image_drawable_get_buffers(drawable, &images,
@@ -717,6 +723,12 @@ kopper_flush_frontbuffer(struct dri_context *ctx,
    if (!ctx || statt != ST_ATTACHMENT_FRONT_LEFT)
       return false;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    if (drawable) {
       /* prevent recursion */
       if (drawable->flushing)
@@ -811,6 +823,12 @@ kopper_update_tex_buffer(struct dri_drawable *drawable,
       return;
    int cpp = util_format_get_blocksize(res->format);
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    get_drawable_info(dPriv, &x, &y, &w, &h);
 
    map = pipe_texture_map(pipe, res,
@@ -912,6 +930,12 @@ kopperSwapBuffers(__DRIdrawable *dPriv)
    if (!ptex)
       return 0;
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    drawable->texture_stamp = dPriv->lastStamp - 1;
    dri_flush(ctx->cPriv, dPriv, __DRI2_FLUSH_DRAWABLE | __DRI2_FLUSH_CONTEXT, __DRI2_THROTTLE_SWAPBUFFER);
    kopper_copy_to_front(ctx->st->pipe, dPriv, ptex);
@@ -1001,6 +1025,12 @@ kopperQueryBufferAge(__DRIdrawable *dPriv)
                                 drawable->textures[ST_ATTACHMENT_BACK_LEFT] :
                                 drawable->textures[ST_ATTACHMENT_FRONT_LEFT];
 
+   /* Wait for glthread to finish because we can't use pipe_context from
+    * multiple threads.
+    */
+   if (ctx->st->thread_finish)
+      ctx->st->thread_finish(ctx->st);
+
    return zink_kopper_query_buffer_age(ctx->st->pipe, ptex);
 }
 
-- 
GitLab


From 54648f7ca272f044378b30f007e5dc3bf93a0147 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 9 Sep 2022 15:18:17 +0200
Subject: [PATCH 09/13] egl/wayland: fix glthread crashes

glthread unmarshalling thread cannot run concurrently with code that alloc
the back bo or the code that perform the swaps.
Ensure this by running dri2_flush_drawable_for_swapbuffers early.

Reviewed-by: Daniel Stone <daniels@collabora.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/egl/drivers/dri2/platform_wayland.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index d536bdb0f9bf..93bb97c54e06 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -1527,6 +1527,17 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
       if (dri2_surf->color_buffers[i].age > 0)
          dri2_surf->color_buffers[i].age++;
 
+   /* Flush (and finish glthread) before:
+    *   - update_buffers_if_needed because the unmarshalling thread
+    *     may be running currently, and we would concurrently alloc/free
+    *     the back bo.
+    *   - swapping current/back because flushing may free the buffer and
+    *     dri_image and reallocate them using get_back_bo (which causes a
+    *     a crash because 'current' becomes NULL).
+    */
+   dri2_flush_drawable_for_swapbuffers(disp, draw);
+   dri2_dpy->flush->invalidate(dri2_surf->dri_drawable);
+
    /* Make sure we have a back buffer in case we're swapping without ever
     * rendering. */
    if (update_buffers_if_needed(dri2_surf) < 0)
@@ -1589,9 +1600,6 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
                                  dri2_surf->base.Height, 0);
    }
 
-   dri2_flush_drawable_for_swapbuffers(disp, draw);
-   dri2_dpy->flush->invalidate(dri2_surf->dri_drawable);
-
    wl_surface_commit(dri2_surf->wl_surface_wrapper);
 
    /* If we're not waiting for a frame callback then we'll at least throttle
-- 
GitLab


From bfbc463681ae5db8cf43b8c6c9e92a69ff1ebde7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Aug 2022 20:10:09 -0400
Subject: [PATCH 10/13] radeonsi: simplify radeonsi_zerovram implementation

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/gallium/drivers/radeonsi/driinfo_radeonsi.h | 1 -
 src/gallium/drivers/radeonsi/si_debug_options.h | 1 +
 src/util/driconf.h                              | 8 --------
 3 files changed, 1 insertion(+), 9 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/driinfo_radeonsi.h b/src/gallium/drivers/radeonsi/driinfo_radeonsi.h
index c58aff9f7fe0..7cfe86175a0e 100644
--- a/src/gallium/drivers/radeonsi/driinfo_radeonsi.h
+++ b/src/gallium/drivers/radeonsi/driinfo_radeonsi.h
@@ -1,7 +1,6 @@
 // DriConf options specific to radeonsi
 DRI_CONF_SECTION_PERFORMANCE
 DRI_CONF_ADAPTIVE_SYNC(true)
-DRI_CONF_RADEONSI_ZERO_ALL_VRAM_ALLOCS(false)
 DRI_CONF_SECTION_END
 
 DRI_CONF_SECTION_DEBUG
diff --git a/src/gallium/drivers/radeonsi/si_debug_options.h b/src/gallium/drivers/radeonsi/si_debug_options.h
index a01da8c63784..c90ef1d39aab 100644
--- a/src/gallium/drivers/radeonsi/si_debug_options.h
+++ b/src/gallium/drivers/radeonsi/si_debug_options.h
@@ -20,6 +20,7 @@ OPT_INT(max_vram_map_size, 8196, "Maximum size of a buffer in VRAM to map direct
 OPT_BOOL(force_use_fma32, false, "Force use fma32 instruction for GPU family newer than gfx9")
 OPT_BOOL(dcc_msaa, false, "Enable DCC for MSAA")
 OPT_BOOL(mall_noalloc, false, "Don't use MALL (infinity cache)")
+OPT_BOOL(zerovram, false, "Zero all VRAM allocations")
 
 #undef OPT_BOOL
 #undef OPT_INT
diff --git a/src/util/driconf.h b/src/util/driconf.h
index db095fdcd131..fa150115d717 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -475,14 +475,6 @@
    DRI_CONF_OPT_B(force_sw_rendering_on_cpu, def, \
                   "If set to false, emulates software rendering on the requested device, else uses a software renderer.")
 
-/**
- * \brief radeonsi specific configuration options
- */
-
-#define DRI_CONF_RADEONSI_ZERO_ALL_VRAM_ALLOCS(def) \
-   DRI_CONF_OPT_B(radeonsi_zerovram, def, \
-                  "Zero all vram allocations")
-
 #define DRI_CONF_V3D_NONMSAA_TEXTURE_SIZE_LIMIT(def) \
    DRI_CONF_OPT_B(v3d_nonmsaa_texture_size_limit, def, \
                   "Report the non-MSAA-only texture size limit")
-- 
GitLab


From db710d7bcb65db20528258c539a0ebe5fa4d22a4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Aug 2022 20:44:27 -0400
Subject: [PATCH 11/13] radeonsi: enable glthread by default

Let's enable it and see what happens. This should mostly be a win.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Acked-by: Adam Jackson <ajax@redhat.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/gallium/drivers/radeonsi/driinfo_radeonsi.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/driinfo_radeonsi.h b/src/gallium/drivers/radeonsi/driinfo_radeonsi.h
index 7cfe86175a0e..e8a2b4674a31 100644
--- a/src/gallium/drivers/radeonsi/driinfo_radeonsi.h
+++ b/src/gallium/drivers/radeonsi/driinfo_radeonsi.h
@@ -1,6 +1,7 @@
 // DriConf options specific to radeonsi
 DRI_CONF_SECTION_PERFORMANCE
 DRI_CONF_ADAPTIVE_SYNC(true)
+DRI_CONF_MESA_GLTHREAD(true)
 DRI_CONF_SECTION_END
 
 DRI_CONF_SECTION_DEBUG
-- 
GitLab


From 3649d3d9a4b48ea3a536853687ba326cfc7012fa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 27 Aug 2022 16:36:51 -0400
Subject: [PATCH 12/13] driconf: disable glthread for DeusEx:MD and F1 2015 due
 to a perf drop

glthread decreases performance for DeusEx:MD by 7.8% and F1 2015 by 5.7%.
I think that other Feral games are affected similarly.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/util/00-mesa-defaults.conf | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/util/00-mesa-defaults.conf b/src/util/00-mesa-defaults.conf
index 293971b0ed15..decabea44aa1 100644
--- a/src/util/00-mesa-defaults.conf
+++ b/src/util/00-mesa-defaults.conf
@@ -624,6 +624,13 @@ TODO: document the other workarounds.
             <option name="mesa_glthread" value="true"/>
         </application>
 
+        <application name="DeusExMD" executable="DeusExMD">
+            <option name="mesa_glthread" value="false"/>
+        </application>
+        <application name="F1 2015" executable="F12015">
+            <option name="mesa_glthread" value="false"/>
+        </application>
+
         <!-- Adaptive sync denylist follows below: -->
         <application name="gnome-shell" executable="gnome-shell">
             <option name="adaptive_sync" value="false" />
-- 
GitLab


From 81360b1f8f6fca2bd743e87f20e6fe3880c51f31 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 17 Sep 2022 01:22:42 -0400
Subject: [PATCH 13/13] radeonsi/ci: add glx@glx-swap-event_async to CI
 failures for glthread

The test can't pass because glXSwapBuffers now executes GL functions,
which the test doesn't expect. It's a test defect IMO.

Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18223>
---
 src/gallium/drivers/radeonsi/ci/radeonsi-raven-fails.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/ci/radeonsi-raven-fails.txt b/src/gallium/drivers/radeonsi/ci/radeonsi-raven-fails.txt
index 6756c59fb772..e14d500b3a28 100644
--- a/src/gallium/drivers/radeonsi/ci/radeonsi-raven-fails.txt
+++ b/src/gallium/drivers/radeonsi/ci/radeonsi-raven-fails.txt
@@ -1,3 +1,4 @@
+glx@glx-swap-event_async,Fail
 glx@glx-swap-pixmap-bad,Fail
 glx@glx-visuals-depth -pixmap,Crash
 glx@glx-visuals-stencil -pixmap,Crash
-- 
GitLab

