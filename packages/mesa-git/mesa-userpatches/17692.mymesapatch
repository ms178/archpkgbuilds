From 3c02afb802a85df145ca3dcbc5b86cff8d973fdf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 17 Jul 2022 08:06:14 -0400
Subject: [PATCH 1/5] gallium/u_blitter: remove unused code for integer MSAA
 resolve

GL doesn't have it.
---
 src/gallium/auxiliary/util/u_blitter.c        |  6 +--
 src/gallium/auxiliary/util/u_simple_shaders.c | 45 +++++--------------
 src/gallium/auxiliary/util/u_simple_shaders.h |  6 +--
 3 files changed, 14 insertions(+), 43 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 051668091718..0b7c252366ba 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -1024,13 +1024,11 @@ static void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
             assert(!ctx->cached_all_shaders);
             if (filter == PIPE_TEX_FILTER_LINEAR) {
                *shader = util_make_fs_msaa_resolve_bilinear(pipe, tgsi_tex,
-                                                   src_nr_samples,
-                                                   stype);
+                                                   src_nr_samples);
             }
             else {
                *shader = util_make_fs_msaa_resolve(pipe, tgsi_tex,
-                                                   src_nr_samples,
-                                                   stype);
+                                                   src_nr_samples);
             }
          }
       }
diff --git a/src/gallium/auxiliary/util/u_simple_shaders.c b/src/gallium/auxiliary/util/u_simple_shaders.c
index 77add5b7bf0d..e1dc08c845a9 100644
--- a/src/gallium/auxiliary/util/u_simple_shaders.c
+++ b/src/gallium/auxiliary/util/u_simple_shaders.c
@@ -708,8 +708,7 @@ util_make_fs_blit_msaa_depthstencil(struct pipe_context *pipe,
 
 void *
 util_make_fs_msaa_resolve(struct pipe_context *pipe,
-                          enum tgsi_texture_type tgsi_tex, unsigned nr_samples,
-                          enum tgsi_return_type stype)
+                          enum tgsi_texture_type tgsi_tex, unsigned nr_samples)
 {
    struct ureg_program *ureg;
    struct ureg_src sampler, coord;
@@ -722,7 +721,9 @@ util_make_fs_msaa_resolve(struct pipe_context *pipe,
 
    /* Declarations. */
    sampler = ureg_DECL_sampler(ureg, 0);
-   ureg_DECL_sampler_view(ureg, 0, tgsi_tex, stype, stype, stype, stype);
+   ureg_DECL_sampler_view(ureg, 0, tgsi_tex,
+                          TGSI_RETURN_TYPE_FLOAT, TGSI_RETURN_TYPE_FLOAT,
+                          TGSI_RETURN_TYPE_FLOAT, TGSI_RETURN_TYPE_FLOAT);
    coord = ureg_DECL_fs_input(ureg, TGSI_SEMANTIC_GENERIC, 0,
                               TGSI_INTERPOLATE_LINEAR);
    out = ureg_DECL_output(ureg, TGSI_SEMANTIC_COLOR, 0);
@@ -740,26 +741,13 @@ util_make_fs_msaa_resolve(struct pipe_context *pipe,
                ureg_imm1u(ureg, i));
       ureg_TXF(ureg, tmp, tgsi_tex, ureg_src(tmp_coord), sampler);
 
-      if (stype == TGSI_RETURN_TYPE_UINT)
-         ureg_U2F(ureg, tmp, ureg_src(tmp));
-      else if (stype == TGSI_RETURN_TYPE_SINT)
-         ureg_I2F(ureg, tmp, ureg_src(tmp));
-
       /* Add it to the sum.*/
       ureg_ADD(ureg, tmp_sum, ureg_src(tmp_sum), ureg_src(tmp));
    }
 
    /* Calculate the average and return. */
-   ureg_MUL(ureg, tmp_sum, ureg_src(tmp_sum),
+   ureg_MUL(ureg, out, ureg_src(tmp_sum),
             ureg_imm1f(ureg, 1.0 / nr_samples));
-
-   if (stype == TGSI_RETURN_TYPE_UINT)
-      ureg_F2U(ureg, out, ureg_src(tmp_sum));
-   else if (stype == TGSI_RETURN_TYPE_SINT)
-      ureg_F2I(ureg, out, ureg_src(tmp_sum));
-   else
-      ureg_MOV(ureg, out, ureg_src(tmp_sum));
-
    ureg_END(ureg);
 
    return ureg_create_shader_and_destroy(ureg, pipe);
@@ -769,8 +757,7 @@ util_make_fs_msaa_resolve(struct pipe_context *pipe,
 void *
 util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
                                    enum tgsi_texture_type tgsi_tex,
-                                   unsigned nr_samples,
-                                   enum tgsi_return_type stype)
+                                   unsigned nr_samples)
 {
    struct ureg_program *ureg;
    struct ureg_src sampler, coord;
@@ -784,7 +771,9 @@ util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
 
    /* Declarations. */
    sampler = ureg_DECL_sampler(ureg, 0);
-   ureg_DECL_sampler_view(ureg, 0, tgsi_tex, stype, stype, stype, stype);
+   ureg_DECL_sampler_view(ureg, 0, tgsi_tex,
+                          TGSI_RETURN_TYPE_FLOAT, TGSI_RETURN_TYPE_FLOAT,
+                          TGSI_RETURN_TYPE_FLOAT, TGSI_RETURN_TYPE_FLOAT);
    coord = ureg_DECL_fs_input(ureg, TGSI_SEMANTIC_GENERIC, 0,
                               TGSI_INTERPOLATE_LINEAR);
    out = ureg_DECL_output(ureg, TGSI_SEMANTIC_COLOR, 0);
@@ -816,11 +805,6 @@ util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
                   ureg_imm1u(ureg, i));
          ureg_TXF(ureg, tmp, tgsi_tex, ureg_src(tmp_coord[c]), sampler);
 
-         if (stype == TGSI_RETURN_TYPE_UINT)
-            ureg_U2F(ureg, tmp, ureg_src(tmp));
-         else if (stype == TGSI_RETURN_TYPE_SINT)
-            ureg_I2F(ureg, tmp, ureg_src(tmp));
-
          /* Add it to the sum.*/
          ureg_ADD(ureg, tmp_sum[c], ureg_src(tmp_sum[c]), ureg_src(tmp));
       }
@@ -844,19 +828,10 @@ util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
             ureg_src(tmp_sum[3]),
             ureg_src(tmp_sum[2]));
 
-   ureg_LRP(ureg, tmp,
+   ureg_LRP(ureg, out,
             ureg_scalar(ureg_src(tmp), 1),
             ureg_src(bottom),
             ureg_src(top));
-
-   /* Convert to the texture format and return. */
-   if (stype == TGSI_RETURN_TYPE_UINT)
-      ureg_F2U(ureg, out, ureg_src(tmp));
-   else if (stype == TGSI_RETURN_TYPE_SINT)
-      ureg_F2I(ureg, out, ureg_src(tmp));
-   else
-      ureg_MOV(ureg, out, ureg_src(tmp));
-
    ureg_END(ureg);
 
    return ureg_create_shader_and_destroy(ureg, pipe);
diff --git a/src/gallium/auxiliary/util/u_simple_shaders.h b/src/gallium/auxiliary/util/u_simple_shaders.h
index c0f30b7c8235..20d88b043fd9 100644
--- a/src/gallium/auxiliary/util/u_simple_shaders.h
+++ b/src/gallium/auxiliary/util/u_simple_shaders.h
@@ -141,15 +141,13 @@ util_make_fs_blit_msaa_stencil(struct pipe_context *pipe,
 
 void *
 util_make_fs_msaa_resolve(struct pipe_context *pipe,
-                          enum tgsi_texture_type tgsi_tex, unsigned nr_samples,
-                          enum tgsi_return_type stype);
+                          enum tgsi_texture_type tgsi_tex, unsigned nr_samples);
 
 
 void *
 util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
                                    enum tgsi_texture_type tgsi_tex,
-                                   unsigned nr_samples,
-                                   enum tgsi_return_type stype);
+                                   unsigned nr_samples);
 
 extern void *
 util_make_geometry_passthrough_shader(struct pipe_context *pipe,
-- 
GitLab


From dea763042b37af2dc85167550095884ef601199d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 17 Jul 2022 08:25:23 -0400
Subject: [PATCH 2/5] gallium/u_blitter: make nearest filtering emulation using
 TXF conformant

This is required by glBlitFramebuffer.
---
 src/gallium/auxiliary/util/u_simple_shaders.c | 97 ++++++++++++++++---
 1 file changed, 81 insertions(+), 16 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_simple_shaders.c b/src/gallium/auxiliary/util/u_simple_shaders.c
index e1dc08c845a9..a00c0701a756 100644
--- a/src/gallium/auxiliary/util/u_simple_shaders.c
+++ b/src/gallium/auxiliary/util/u_simple_shaders.c
@@ -208,7 +208,19 @@ ureg_load_tex(struct ureg_program *ureg, struct ureg_dst out,
    if (use_txf) {
       struct ureg_dst temp = ureg_DECL_temporary(ureg);
 
-      ureg_F2I(ureg, temp, coord);
+      /* Nearest filtering floors and then converts to integer, and then
+       * applies clamp to edge as clamp(coord, 0, dim - 1).
+       * u_blitter only uses this when the coordinates are in bounds,
+       * so no clamping is needed.
+       */
+      unsigned wrmask = tex_target == TGSI_TEXTURE_1D ||
+                        tex_target == TGSI_TEXTURE_1D_ARRAY ? TGSI_WRITEMASK_X :
+                        tex_target == TGSI_TEXTURE_3D ? TGSI_WRITEMASK_XYZ :
+                                                        TGSI_WRITEMASK_XY;
+
+      ureg_MOV(ureg, temp, coord);
+      ureg_FLR(ureg, ureg_writemask(temp, wrmask), ureg_src(temp));
+      ureg_F2I(ureg, temp, ureg_src(temp));
 
       if (load_level_zero)
          ureg_TXF_LZ(ureg, out, tex_target, ureg_src(temp), sampler);
@@ -540,11 +552,23 @@ util_make_fs_blit_msaa_gen(struct pipe_context *pipe,
          "DCL SAMP[0]\n"
          "DCL SVIEW[0], %s, %s\n"
          "DCL OUT[0], %s\n"
-         "DCL TEMP[0]\n"
+         "DCL TEMP[0..1]\n"
+         "IMM[0] INT32 {0, -1, 0, 0}\n"
          "%s"
          "%s"
 
-         "F2U TEMP[0], IN[0]\n"
+         /* Nearest filtering floors and then converts to integer, and then
+          * applies clamp to edge as clamp(coord, 0, dim - 1).
+          */
+         "MOV TEMP[0], IN[0]\n"
+         "FLR TEMP[0].xy, TEMP[0]\n"
+         "F2I TEMP[0], TEMP[0]\n"
+         "IMAX TEMP[0].xy, TEMP[0], IMM[0].xxxx\n"
+         /* Clamp to edge for the upper bound. */
+         "TXQ TEMP[1].xy, IMM[0].xxxx, SAMP[0], %s\n"
+         "UADD TEMP[1].xy, TEMP[1], IMM[0].yyyy\n" /* width - 1, height - 1 */
+         "IMIN TEMP[0].xy, TEMP[0], TEMP[1]\n"
+         /* Texel fetch. */
          "%s"
          "TXF TEMP[0], TEMP[0], SAMP[0], %s\n"
          "%s"
@@ -561,7 +585,7 @@ util_make_fs_blit_msaa_gen(struct pipe_context *pipe,
 
    snprintf(text, sizeof(text), shader_templ, type, samp_type,
             output_semantic, sample_shading ? "DCL SV[0], SAMPLEID\n" : "",
-            conversion_decl, sample_shading ? "MOV TEMP[0].w, SV[0].xxxx\n" : "",
+            conversion_decl, type, sample_shading ? "MOV TEMP[0].w, SV[0].xxxx\n" : "",
             type, conversion, output_mask);
 
    if (!tgsi_text_translate(text, tokens, ARRAY_SIZE(tokens))) {
@@ -598,15 +622,15 @@ util_make_fs_blit_msaa_color(struct pipe_context *pipe,
       samp_type = "UINT";
 
       if (dtype == TGSI_RETURN_TYPE_SINT) {
-         conversion_decl = "IMM[0] UINT32 {2147483647, 0, 0, 0}\n";
-         conversion = "UMIN TEMP[0], TEMP[0], IMM[0].xxxx\n";
+         conversion_decl = "IMM[1] UINT32 {2147483647, 0, 0, 0}\n";
+         conversion = "UMIN TEMP[0], TEMP[0], IMM[1].xxxx\n";
       }
    } else if (stype == TGSI_RETURN_TYPE_SINT) {
       samp_type = "SINT";
 
       if (dtype == TGSI_RETURN_TYPE_UINT) {
-         conversion_decl = "IMM[0] INT32 {0, 0, 0, 0}\n";
-         conversion = "IMAX TEMP[0], TEMP[0], IMM[0].xxxx\n";
+         conversion_decl = "IMM[1] INT32 {0, 0, 0, 0}\n";
+         conversion = "IMAX TEMP[0], TEMP[0], IMM[1].xxxx\n";
       }
    } else {
       assert(dtype == TGSI_RETURN_TYPE_FLOAT);
@@ -671,10 +695,22 @@ util_make_fs_blit_msaa_depthstencil(struct pipe_context *pipe,
          "DCL SVIEW[1], %s, UINT\n"
          "DCL OUT[0], POSITION\n"
          "DCL OUT[1], STENCIL\n"
-         "DCL TEMP[0]\n"
+         "DCL TEMP[0..1]\n"
+         "IMM[0] INT32 {0, -1, 0, 0}\n"
          "%s"
 
-         "F2U TEMP[0], IN[0]\n"
+         /* Nearest filtering floors and then converts to integer, and then
+          * applies clamp to edge as clamp(coord, 0, dim - 1).
+          */
+         "MOV TEMP[0], IN[0]\n"
+         "FLR TEMP[0].xy, TEMP[0]\n"
+         "F2I TEMP[0], TEMP[0]\n"
+         "IMAX TEMP[0].xy, TEMP[0], IMM[0].xxxx\n"
+         /* Clamp to edge for the upper bound. */
+         "TXQ TEMP[1].xy, IMM[0].xxxx, SAMP[0], %s\n"
+         "UADD TEMP[1].xy, TEMP[1], IMM[0].yyyy\n" /* width - 1, height - 1 */
+         "IMIN TEMP[0].xy, TEMP[0], TEMP[1]\n"
+         /* Texel fetch. */
          "%s"
          "TXF OUT[0].z, TEMP[0], SAMP[0], %s\n"
          "TXF OUT[1].y, TEMP[0], SAMP[1], %s\n"
@@ -689,7 +725,7 @@ util_make_fs_blit_msaa_depthstencil(struct pipe_context *pipe,
           tgsi_tex == TGSI_TEXTURE_2D_ARRAY_MSAA);
 
    sprintf(text, shader_templ, type, type,
-           sample_shading ? "DCL SV[0], SAMPLEID\n" : "",
+           sample_shading ? "DCL SV[0], SAMPLEID\n" : "", type,
            sample_shading ? "MOV TEMP[0].w, SV[0].xxxx\n" : "",
            type, type);
 
@@ -733,7 +769,23 @@ util_make_fs_msaa_resolve(struct pipe_context *pipe,
 
    /* Instructions. */
    ureg_MOV(ureg, tmp_sum, ureg_imm1f(ureg, 0));
-   ureg_F2U(ureg, tmp_coord, coord);
+
+   /* Nearest filtering floors and then converts to integer, and then
+    * applies clamp to edge as clamp(coord, 0, dim - 1).
+    */
+   ureg_MOV(ureg, tmp_coord, coord);
+   ureg_FLR(ureg, ureg_writemask(tmp_coord, TGSI_WRITEMASK_XY),
+            ureg_src(tmp_coord));
+   ureg_F2I(ureg, tmp_coord, ureg_src(tmp_coord));
+   ureg_IMAX(ureg, tmp_coord, ureg_src(tmp_coord), ureg_imm1i(ureg, 0));
+
+   /* Clamp to edge for the upper bound. */
+   ureg_TXQ(ureg, ureg_writemask(tmp, TGSI_WRITEMASK_XY), tgsi_tex,
+            ureg_imm1u(ureg, 0), sampler);
+   ureg_UADD(ureg, ureg_writemask(tmp, TGSI_WRITEMASK_XY), ureg_src(tmp),
+             ureg_imm2i(ureg, -1, -1)); /* width - 1, height - 1 */
+   ureg_IMIN(ureg,  ureg_writemask(tmp_coord, TGSI_WRITEMASK_XY),
+             ureg_src(tmp_coord), ureg_src(tmp));
 
    for (i = 0; i < nr_samples; i++) {
       /* Read one sample. */
@@ -1166,9 +1218,21 @@ util_make_fs_stencil_blit(struct pipe_context *pipe, bool msaa_src)
       "DCL SAMP[0]\n"
       "DCL SVIEW[0], %s, UINT\n"
       "DCL CONST[0][0]\n"
-      "DCL TEMP[0]\n"
-
-      "F2U TEMP[0], IN[0]\n"
+      "DCL TEMP[0..1]\n"
+      "IMM[0] INT32 {0, -1, 0, 0}\n"
+
+      /* Nearest filtering floors and then converts to integer, and then
+       * applies clamp to edge as clamp(coord, 0, dim - 1).
+       */
+      "MOV TEMP[0], IN[0]\n"
+      "FLR TEMP[0].xy, TEMP[0]\n"
+      "F2I TEMP[0], TEMP[0]\n"
+      "IMAX TEMP[0].xy, TEMP[0], IMM[0].xxxx\n"
+      /* Clamp to edge for the upper bound. */
+      "TXQ TEMP[1].xy, IMM[0].xxxx, SAMP[0], %s\n"
+      "UADD TEMP[1].xy, TEMP[1], IMM[0].yyyy\n" /* width - 1, height - 1 */
+      "IMIN TEMP[0].xy, TEMP[0], TEMP[1]\n"
+      /* Texel fetch. */
       "TXF_LZ TEMP[0].x, TEMP[0], SAMP[0], %s\n"
       "AND TEMP[0].x, TEMP[0], CONST[0][0]\n"
       "USNE TEMP[0].x, TEMP[0], CONST[0][0]\n"
@@ -1183,7 +1247,8 @@ util_make_fs_stencil_blit(struct pipe_context *pipe, bool msaa_src)
    enum tgsi_texture_type tgsi_tex = msaa_src ? TGSI_TEXTURE_2D_MSAA :
                                                 TGSI_TEXTURE_2D;
 
-   sprintf(text, shader_templ, tgsi_texture_names[tgsi_tex], tgsi_texture_names[tgsi_tex]);
+   sprintf(text, shader_templ, tgsi_texture_names[tgsi_tex],
+           tgsi_texture_names[tgsi_tex], tgsi_texture_names[tgsi_tex]);
 
    if (!tgsi_text_translate(text, tokens, ARRAY_SIZE(tokens))) {
       assert(0);
-- 
GitLab


From cde70a54f27ada7b5aa27ee89f31a744fabda686 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 23 Jul 2022 13:20:44 -0400
Subject: [PATCH 3/5] gallium/u_blitter: treat Z scaling as scaled blits

Hopefully this didn't break anything.
---
 src/gallium/auxiliary/util/u_blitter.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 0b7c252366ba..e39d7a17e9cc 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -2027,7 +2027,8 @@ void util_blitter_blit_generic(struct blitter_context *blitter,
    }
 
    bool is_scaled = dstbox->width != abs(srcbox->width) ||
-                    dstbox->height != abs(srcbox->height);
+                    dstbox->height != abs(srcbox->height) ||
+                    dstbox->depth != abs(srcbox->depth);
 
    if (src_has_stencil || !is_scaled)
       filter = PIPE_TEX_FILTER_NEAREST;
-- 
GitLab


From 63e499b7278759ef2148aad5c1e5b58fb1207224 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 18 Jul 2022 08:04:00 -0400
Subject: [PATCH 4/5] gallium/u_blitter: clean up IMMs in
 util_make_fs_blit_msaa_gen

Remove IMM[1], use IMM[0] instead.
---
 src/gallium/auxiliary/util/u_simple_shaders.c | 20 +++++++------------
 1 file changed, 7 insertions(+), 13 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_simple_shaders.c b/src/gallium/auxiliary/util/u_simple_shaders.c
index a00c0701a756..f2f6f1d8ff13 100644
--- a/src/gallium/auxiliary/util/u_simple_shaders.c
+++ b/src/gallium/auxiliary/util/u_simple_shaders.c
@@ -543,7 +543,6 @@ util_make_fs_blit_msaa_gen(struct pipe_context *pipe,
                            const char *samp_type,
                            const char *output_semantic,
                            const char *output_mask,
-                           const char *conversion_decl,
                            const char *conversion)
 {
    static const char shader_templ[] =
@@ -553,8 +552,7 @@ util_make_fs_blit_msaa_gen(struct pipe_context *pipe,
          "DCL SVIEW[0], %s, %s\n"
          "DCL OUT[0], %s\n"
          "DCL TEMP[0..1]\n"
-         "IMM[0] INT32 {0, -1, 0, 0}\n"
-         "%s"
+         "IMM[0] INT32 {0, -1, 2147483647, 0}\n"
          "%s"
 
          /* Nearest filtering floors and then converts to integer, and then
@@ -585,7 +583,7 @@ util_make_fs_blit_msaa_gen(struct pipe_context *pipe,
 
    snprintf(text, sizeof(text), shader_templ, type, samp_type,
             output_semantic, sample_shading ? "DCL SV[0], SAMPLEID\n" : "",
-            conversion_decl, type, sample_shading ? "MOV TEMP[0].w, SV[0].xxxx\n" : "",
+            type, sample_shading ? "MOV TEMP[0].w, SV[0].xxxx\n" : "",
             type, conversion, output_mask);
 
    if (!tgsi_text_translate(text, tokens, ARRAY_SIZE(tokens))) {
@@ -615,22 +613,19 @@ util_make_fs_blit_msaa_color(struct pipe_context *pipe,
                              bool sample_shading)
 {
    const char *samp_type;
-   const char *conversion_decl = "";
    const char *conversion = "";
 
    if (stype == TGSI_RETURN_TYPE_UINT) {
       samp_type = "UINT";
 
       if (dtype == TGSI_RETURN_TYPE_SINT) {
-         conversion_decl = "IMM[1] UINT32 {2147483647, 0, 0, 0}\n";
-         conversion = "UMIN TEMP[0], TEMP[0], IMM[1].xxxx\n";
+         conversion = "UMIN TEMP[0], TEMP[0], IMM[0].zzzz\n";
       }
    } else if (stype == TGSI_RETURN_TYPE_SINT) {
       samp_type = "SINT";
 
       if (dtype == TGSI_RETURN_TYPE_UINT) {
-         conversion_decl = "IMM[1] INT32 {0, 0, 0, 0}\n";
-         conversion = "IMAX TEMP[0], TEMP[0], IMM[1].xxxx\n";
+         conversion = "IMAX TEMP[0], TEMP[0], IMM[0].xxxx\n";
       }
    } else {
       assert(dtype == TGSI_RETURN_TYPE_FLOAT);
@@ -638,8 +633,7 @@ util_make_fs_blit_msaa_color(struct pipe_context *pipe,
    }
 
    return util_make_fs_blit_msaa_gen(pipe, tgsi_tex, sample_shading, samp_type,
-                                     "COLOR[0]", "", conversion_decl,
-                                     conversion);
+                                     "COLOR[0]", "", conversion);
 }
 
 
@@ -654,7 +648,7 @@ util_make_fs_blit_msaa_depth(struct pipe_context *pipe,
                              bool sample_shading)
 {
    return util_make_fs_blit_msaa_gen(pipe, tgsi_tex, sample_shading, "FLOAT",
-                                     "POSITION", ".z", "",
+                                     "POSITION", ".z",
                                      "MOV TEMP[0].z, TEMP[0].xxxx\n");
 }
 
@@ -670,7 +664,7 @@ util_make_fs_blit_msaa_stencil(struct pipe_context *pipe,
                                bool sample_shading)
 {
    return util_make_fs_blit_msaa_gen(pipe, tgsi_tex, sample_shading, "UINT",
-                                     "STENCIL", ".y", "",
+                                     "STENCIL", ".y",
                                      "MOV TEMP[0].y, TEMP[0].xxxx\n");
 }
 
-- 
GitLab


From db371bc9467124393fe59613cb9e79a4993416cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 17 Jul 2022 12:21:17 -0400
Subject: [PATCH 5/5] gallium/u_blitter: make the bilinear filter for MSAA
 resolving conformant

This implements the bilinear filter exactly like OpenGL.
---
 src/gallium/auxiliary/util/u_simple_shaders.c | 61 +++++++++++++++----
 1 file changed, 49 insertions(+), 12 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_simple_shaders.c b/src/gallium/auxiliary/util/u_simple_shaders.c
index f2f6f1d8ff13..ff7ea96604a8 100644
--- a/src/gallium/auxiliary/util/u_simple_shaders.c
+++ b/src/gallium/auxiliary/util/u_simple_shaders.c
@@ -808,7 +808,7 @@ util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
    struct ureg_program *ureg;
    struct ureg_src sampler, coord;
    struct ureg_dst out, tmp, top, bottom;
-   struct ureg_dst tmp_coord[4], tmp_sum[4];
+   struct ureg_dst tmp_coord[4], tmp_sum[4], weights;
    unsigned i, c;
 
    ureg = ureg_create(PIPE_SHADER_FRAGMENT);
@@ -829,21 +829,60 @@ util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
       tmp_coord[c] = ureg_DECL_temporary(ureg);
    tmp = ureg_DECL_temporary(ureg);
    top = ureg_DECL_temporary(ureg);
+   weights = ureg_DECL_temporary(ureg);
    bottom = ureg_DECL_temporary(ureg);
 
    /* Instructions. */
    for (c = 0; c < 4; c++)
       ureg_MOV(ureg, tmp_sum[c], ureg_imm1f(ureg, 0));
 
-   /* Get 4 texture coordinates for the bilinear filter. */
-   ureg_F2U(ureg, tmp_coord[0], coord); /* top-left */
-   ureg_UADD(ureg, tmp_coord[1], ureg_src(tmp_coord[0]),
-             ureg_imm4u(ureg, 1, 0, 0, 0)); /* top-right */
-   ureg_UADD(ureg, tmp_coord[2], ureg_src(tmp_coord[0]),
-             ureg_imm4u(ureg, 0, 1, 0, 0)); /* bottom-left */
+   /* Bilinear filtering starts with subtracting 0.5 from unnormalized
+    * coordinates.
+    */
+   ureg_MOV(ureg, ureg_writemask(tmp_coord[0], TGSI_WRITEMASK_ZW), coord);
+   ureg_ADD(ureg, ureg_writemask(tmp_coord[0], TGSI_WRITEMASK_XY), coord,
+            ureg_imm2f(ureg, -0.5, -0.5));
+
+   /* Get the filter weights. */
+   ureg_FRC(ureg, ureg_writemask(weights, TGSI_WRITEMASK_XY),
+            ureg_src(tmp_coord[0]));
+
+   /* Convert to integer by flooring to get the top-left coordinates. */
+   ureg_FLR(ureg, ureg_writemask(tmp_coord[0], TGSI_WRITEMASK_XY),
+         ureg_src(tmp_coord[0]));
+   ureg_F2I(ureg, tmp_coord[0], ureg_src(tmp_coord[0]));
+
+   /* Get the bottom-right coordinates. */
    ureg_UADD(ureg, tmp_coord[3], ureg_src(tmp_coord[0]),
              ureg_imm4u(ureg, 1, 1, 0, 0)); /* bottom-right */
 
+   /* Clamp to edge. */
+   ureg_TXQ(ureg, ureg_writemask(tmp, TGSI_WRITEMASK_XY), tgsi_tex,
+            ureg_imm1u(ureg, 0), sampler);
+   ureg_UADD(ureg, ureg_writemask(tmp, TGSI_WRITEMASK_XY), ureg_src(tmp),
+             ureg_imm2i(ureg, -1, -1)); /* width - 1, height - 1 */
+
+   ureg_IMAX(ureg, ureg_writemask(tmp_coord[0], TGSI_WRITEMASK_XY),
+             ureg_src(tmp_coord[0]), ureg_imm2i(ureg, 0, 0));
+   ureg_IMAX(ureg, ureg_writemask(tmp_coord[3], TGSI_WRITEMASK_XY),
+             ureg_src(tmp_coord[3]), ureg_imm2i(ureg, 0, 0));
+
+   ureg_IMIN(ureg, ureg_writemask(tmp_coord[0], TGSI_WRITEMASK_XY),
+             ureg_src(tmp_coord[0]), ureg_src(tmp));
+   ureg_IMIN(ureg, ureg_writemask(tmp_coord[3], TGSI_WRITEMASK_XY),
+             ureg_src(tmp_coord[3]), ureg_src(tmp));
+
+   /* Get the remaining top-right and bottom-left coordinates. */
+   ureg_MOV(ureg, ureg_writemask(tmp_coord[1], TGSI_WRITEMASK_X),
+         ureg_src(tmp_coord[3]));
+   ureg_MOV(ureg, ureg_writemask(tmp_coord[1], TGSI_WRITEMASK_YZW),
+         ureg_src(tmp_coord[0])); /* top-right */
+
+   ureg_MOV(ureg, ureg_writemask(tmp_coord[2], TGSI_WRITEMASK_Y),
+         ureg_src(tmp_coord[3]));
+   ureg_MOV(ureg, ureg_writemask(tmp_coord[2], TGSI_WRITEMASK_XZW),
+         ureg_src(tmp_coord[0])); /* bottom-left */
+
    for (i = 0; i < nr_samples; i++) {
       for (c = 0; c < 4; c++) {
          /* Read one sample. */
@@ -862,20 +901,18 @@ util_make_fs_msaa_resolve_bilinear(struct pipe_context *pipe,
                ureg_imm1f(ureg, 1.0 / nr_samples));
 
    /* Take the 4 average values and apply a standard bilinear filter. */
-   ureg_FRC(ureg, tmp, coord);
-
    ureg_LRP(ureg, top,
-            ureg_scalar(ureg_src(tmp), 0),
+            ureg_scalar(ureg_src(weights), 0),
             ureg_src(tmp_sum[1]),
             ureg_src(tmp_sum[0]));
 
    ureg_LRP(ureg, bottom,
-            ureg_scalar(ureg_src(tmp), 0),
+            ureg_scalar(ureg_src(weights), 0),
             ureg_src(tmp_sum[3]),
             ureg_src(tmp_sum[2]));
 
    ureg_LRP(ureg, out,
-            ureg_scalar(ureg_src(tmp), 1),
+            ureg_scalar(ureg_src(weights), 1),
             ureg_src(bottom),
             ureg_src(top));
    ureg_END(ureg);
-- 
GitLab

