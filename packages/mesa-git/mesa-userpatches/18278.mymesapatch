From 6536c494f13d1164a3e902b76eda581c3837fced Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 10:13:20 +0200
Subject: [PATCH 01/16] aco: remove unused isel_context::tcs_num_patches
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.h         | 1 -
 src/amd/compiler/aco_instruction_selection_setup.cpp | 3 ---
 src/amd/compiler/aco_shader_info.h                   | 1 -
 src/amd/vulkan/radv_aco_shader_info.h                | 1 -
 4 files changed, 6 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.h b/src/amd/compiler/aco_instruction_selection.h
index 3b775901aaa9..4c3717818028 100644
--- a/src/amd/compiler/aco_instruction_selection.h
+++ b/src/amd/compiler/aco_instruction_selection.h
@@ -103,7 +103,6 @@ struct isel_context {
 
    /* tessellation information */
    uint64_t tcs_temp_only_inputs;
-   uint32_t tcs_num_patches;
    bool tcs_in_out_eq = false;
 
    /* Fragment color output information */
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 68639c21ec61..d535c47fc79b 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -304,15 +304,12 @@ setup_tcs_info(isel_context* ctx, nir_shader* nir, nir_shader* vs)
 {
    ctx->tcs_in_out_eq = ctx->program->info.vs.tcs_in_out_eq;
    ctx->tcs_temp_only_inputs = ctx->program->info.vs.tcs_temp_only_input_mask;
-   ctx->tcs_num_patches = ctx->program->info.num_tess_patches;
    ctx->program->config->lds_size = ctx->program->info.tcs.num_lds_blocks;
 }
 
 void
 setup_tes_variables(isel_context* ctx, nir_shader* nir)
 {
-   ctx->tcs_num_patches = ctx->program->info.num_tess_patches;
-
    if (ctx->stage == tess_eval_vs || ctx->stage == tess_eval_ngg) {
       setup_vs_output_info(ctx, nir);
 
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 973624a231c9..3aa9cf46152a 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -105,7 +105,6 @@ struct aco_shader_info {
    bool is_ngg;
    bool has_ngg_culling;
    bool has_ngg_early_prim_export;
-   uint32_t num_tess_patches;
    unsigned workgroup_size;
    struct aco_vp_output_info outinfo;
    struct {
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 909be9abffe5..0c966f33c263 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -73,7 +73,6 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info,
    ASSIGN_FIELD(is_ngg);
    ASSIGN_FIELD(has_ngg_culling);
    ASSIGN_FIELD(has_ngg_early_prim_export);
-   ASSIGN_FIELD(num_tess_patches);
    ASSIGN_FIELD(workgroup_size);
    radv_aco_convert_shader_vp_info(&aco_info->outinfo, &radv->outinfo);
    ASSIGN_FIELD(vs.as_es);
-- 
GitLab


From 3483c765fa36d4f9805fb740bcf188b836386188 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 23 Aug 2022 15:28:26 +0200
Subject: [PATCH 02/16] radv: stop setting as_ls for the TCS stage
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This doesn't make sense and it was assigned because the shader info
stuff was a complete mess. LS is only a thing on GFX6-8, on GFX9+
it's a merged VS+TCS to HS.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    |  2 +-
 src/amd/vulkan/radv_shader_args.c | 10 +++++-----
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 6d85551c730a..1c0147f93930 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3304,7 +3304,6 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
       radv_nir_shader_info_init(&stages[MESA_SHADER_TESS_CTRL].info);
 
       /* Copy data to merged stage. */
-      stages[MESA_SHADER_TESS_CTRL].info.vs.as_ls = true;
       stages[MESA_SHADER_TESS_CTRL].info.vs.num_linked_outputs =
             stages[MESA_SHADER_VERTEX].info.vs.num_linked_outputs;
 
@@ -3314,6 +3313,7 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
       }
 
       stages[MESA_SHADER_VERTEX].info = stages[MESA_SHADER_TESS_CTRL].info;
+      stages[MESA_SHADER_VERTEX].info.vs.as_ls = true;
 
       filled_stages |= (1 << MESA_SHADER_VERTEX);
       filled_stages |= (1 << MESA_SHADER_TESS_CTRL);
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index 4dfdedcbca63..28cf810e9ed9 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -300,11 +300,11 @@ declare_vs_specific_input_sgprs(const struct radv_shader_info *info, struct radv
 
 static void
 declare_vs_input_vgprs(enum amd_gfx_level gfx_level, const struct radv_shader_info *info,
-                       struct radv_shader_args *args)
+                       struct radv_shader_args *args, bool merged_vs_tcs)
 {
    ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.vertex_id);
    if (!args->is_gs_copy_shader) {
-      if (info->vs.as_ls) {
+      if (info->vs.as_ls || merged_vs_tcs) {
 
          if (gfx_level >= GFX11) {
             ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* user VGPR */
@@ -645,7 +645,7 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
       }
 
-      declare_vs_input_vgprs(gfx_level, info, args);
+      declare_vs_input_vgprs(gfx_level, info, args, false);
       break;
    case MESA_SHADER_TESS_CTRL:
       if (has_previous_stage) {
@@ -674,7 +674,7 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
          ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.tcs_patch_id);
          ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.tcs_rel_ids);
 
-         declare_vs_input_vgprs(gfx_level, info, args);
+         declare_vs_input_vgprs(gfx_level, info, args, true);
       } else {
          declare_global_input_sgprs(info, &user_sgpr_info, args);
 
@@ -759,7 +759,7 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
          ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[2]);
 
          if (previous_stage == MESA_SHADER_VERTEX) {
-            declare_vs_input_vgprs(gfx_level, info, args);
+            declare_vs_input_vgprs(gfx_level, info, args, false);
          } else if (previous_stage == MESA_SHADER_TESS_EVAL) {
             declare_tes_input_vgprs(args);
          } else if (previous_stage == MESA_SHADER_MESH) {
-- 
GitLab


From fc1719ac88ac947481fb426a78fe102df44b2c74 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 23 Aug 2022 15:54:15 +0200
Subject: [PATCH 03/16] radv: stop setting as_es for the GS stage
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This doesn't make sense and it was assigned because the shader info
stuff was a complete mess.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 1c0147f93930..b485b0d64884 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3329,11 +3329,9 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
 
       /* Copy data to merged stage. */
       if (pre_stage == MESA_SHADER_VERTEX) {
-         stages[MESA_SHADER_GEOMETRY].info.vs.as_es = stages[MESA_SHADER_VERTEX].info.vs.as_es;
          stages[MESA_SHADER_GEOMETRY].info.vs.num_linked_outputs =
             stages[MESA_SHADER_VERTEX].info.vs.num_linked_outputs;
       } else {
-         stages[MESA_SHADER_GEOMETRY].info.tes.as_es = stages[MESA_SHADER_TESS_EVAL].info.tes.as_es;
          stages[MESA_SHADER_GEOMETRY].info.tes.num_linked_outputs =
             stages[MESA_SHADER_TESS_EVAL].info.tes.num_linked_outputs;
          stages[MESA_SHADER_GEOMETRY].info.tes.num_linked_inputs =
@@ -3350,6 +3348,11 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
       }
 
       stages[pre_stage].info = stages[MESA_SHADER_GEOMETRY].info;
+      if (pre_stage == MESA_SHADER_VERTEX) {
+         stages[MESA_SHADER_VERTEX].info.vs.as_es = true;
+      } else {
+         stages[MESA_SHADER_TESS_EVAL].info.tes.as_es = true;
+      }
 
       filled_stages |= (1 << pre_stage);
       filled_stages |= (1 << MESA_SHADER_GEOMETRY);
-- 
GitLab


From 1eb731958331148691bf7dee680f7f250c8bbe13 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 10:15:46 +0200
Subject: [PATCH 04/16] radv: stop setting num_tess_patches for the GS stage
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It's never read.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_shader_info.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 23cf42c08193..2b54f843fae9 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -815,8 +815,6 @@ radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline
 
       stages[MESA_SHADER_TESS_EVAL].info.num_tess_patches =
          stages[MESA_SHADER_TESS_CTRL].info.num_tess_patches;
-      stages[MESA_SHADER_GEOMETRY].info.num_tess_patches =
-         stages[MESA_SHADER_TESS_CTRL].info.num_tess_patches;
 
       if (!radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
          /* When the number of TCS input and output vertices are the same (typically 3):
-- 
GitLab


From bebd6b86e5fb5021aef1728c8fee849ca255f4db Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 10:22:53 +0200
Subject: [PATCH 05/16] radv: stop setting esgs_itemsize to the GS stage
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It's never read.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_shader_info.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 2b54f843fae9..e89212e78bb8 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -863,12 +863,6 @@ radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline
       }
 
       stages[es_stage].info.esgs_itemsize = num_outputs_written * 16;
-
-      /* Copy data to merged stage. */
-      if (device->physical_device->rad_info.gfx_level >= GFX9 &&
-          stages[MESA_SHADER_GEOMETRY].nir) {
-         stages[MESA_SHADER_GEOMETRY].info.esgs_itemsize = stages[es_stage].info.esgs_itemsize;
-      }
    }
 
    if (stages[MESA_SHADER_TASK].nir) {
-- 
GitLab


From 2e8d1d717d18f48d1f1b6b8eefc223d96a3c22bf Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 11:30:57 +0200
Subject: [PATCH 06/16] radv: cleanup helpers that compute NGG info and GS info
 on GFX9+
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Before moving them to the shader info link step.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 181 +++++++++++++++------------------
 1 file changed, 81 insertions(+), 100 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index b485b0d64884..d7d2d234fd1f 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1894,19 +1894,17 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,
 }
 
 static void
-gfx9_get_gs_info(const struct radv_pipeline *pipeline, struct radv_pipeline_stage *stages,
-                 struct gfx9_gs_info *out)
+gfx9_get_gs_info(const struct radv_device *device, struct radv_pipeline_stage *es_stage,
+                 struct radv_pipeline_stage *gs_stage)
 {
-   const struct radv_physical_device *pdevice = pipeline->device->physical_device;
-   struct radv_shader_info *gs_info = &stages[MESA_SHADER_GEOMETRY].info;
-   struct radv_shader_info *es_info;
-   bool has_tess = !!stages[MESA_SHADER_TESS_CTRL].nir;
-
-   es_info = has_tess ? &stages[MESA_SHADER_TESS_EVAL].info : &stages[MESA_SHADER_VERTEX].info;
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   struct radv_shader_info *gs_info = &gs_stage->info;
+   struct radv_shader_info *es_info = &es_stage->info;
+   struct gfx9_gs_info *out = &gs_stage->info.gs_ring_info;
 
-   unsigned gs_num_invocations = MAX2(gs_info->gs.invocations, 1);
-   bool uses_adjacency = gs_info->gs.input_prim == SHADER_PRIM_LINES_ADJACENCY ||
-                         gs_info->gs.input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
+   const unsigned gs_num_invocations = MAX2(gs_info->gs.invocations, 1);
+   const bool uses_adjacency = gs_info->gs.input_prim == SHADER_PRIM_LINES_ADJACENCY ||
+                               gs_info->gs.input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
 
    /* All these are in dwords: */
    /* We can't allow using the whole LDS, because GS waves compete with
@@ -1984,10 +1982,10 @@ gfx9_get_gs_info(const struct radv_pipeline *pipeline, struct radv_pipeline_stag
     */
    es_verts -= min_es_verts - 1;
 
-   uint32_t es_verts_per_subgroup = es_verts;
-   uint32_t gs_prims_per_subgroup = gs_prims;
-   uint32_t gs_inst_prims_in_subgroup = gs_prims * gs_num_invocations;
-   uint32_t max_prims_per_subgroup = gs_inst_prims_in_subgroup * gs_info->gs.vertices_out;
+   const uint32_t es_verts_per_subgroup = es_verts;
+   const uint32_t gs_prims_per_subgroup = gs_prims;
+   const uint32_t gs_inst_prims_in_subgroup = gs_prims * gs_num_invocations;
+   const uint32_t max_prims_per_subgroup = gs_inst_prims_in_subgroup * gs_info->gs.vertices_out;
    out->lds_size = align(esgs_lds_size, 128) / 128;
    out->vgt_gs_onchip_cntl = S_028A44_ES_VERTS_PER_SUBGRP(es_verts_per_subgroup) |
                              S_028A44_GS_PRIMS_PER_SUBGRP(gs_prims_per_subgroup) |
@@ -1996,12 +1994,10 @@ gfx9_get_gs_info(const struct radv_pipeline *pipeline, struct radv_pipeline_stag
    out->vgt_esgs_ring_itemsize = esgs_itemsize;
    assert(max_prims_per_subgroup <= max_out_prims);
 
-   gl_shader_stage es_stage = has_tess ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
-   unsigned workgroup_size = ac_compute_esgs_workgroup_size(
-      pdevice->rad_info.gfx_level, stages[es_stage].info.wave_size,
+   unsigned workgroup_size = ac_compute_esgs_workgroup_size(gfx_level, es_info->wave_size,
       es_verts_per_subgroup, gs_inst_prims_in_subgroup);
-   stages[es_stage].info.workgroup_size = workgroup_size;
-   stages[MESA_SHADER_GEOMETRY].info.workgroup_size = workgroup_size;
+   es_info->workgroup_size = workgroup_size;
+   gs_info->workgroup_size = workgroup_size;
 }
 
 static void
@@ -2015,20 +2011,17 @@ clamp_gsprims_to_esverts(unsigned *max_gsprims, unsigned max_esverts, unsigned m
 }
 
 static unsigned
-radv_get_num_input_vertices(const struct radv_pipeline_stage *stages)
+radv_get_num_input_vertices(const struct radv_pipeline_stage *es_stage,
+                            const struct radv_pipeline_stage *gs_stage)
 {
-   if (stages[MESA_SHADER_GEOMETRY].nir) {
-      nir_shader *gs = stages[MESA_SHADER_GEOMETRY].nir;
-
-      return gs->info.gs.vertices_in;
+   if (gs_stage) {
+      return gs_stage->nir->info.gs.vertices_in;
    }
 
-   if (stages[MESA_SHADER_TESS_CTRL].nir) {
-      nir_shader *tes = stages[MESA_SHADER_TESS_EVAL].nir;
-
-      if (tes->info.tess.point_mode)
+   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
+      if (es_stage->nir->info.tess.point_mode)
          return 1;
-      if (tes->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
+      if (es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
          return 2;
       return 3;
    }
@@ -2046,20 +2039,17 @@ gfx10_emit_ge_pc_alloc(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level,
 }
 
 static unsigned
-radv_get_pre_rast_input_topology(struct radv_pipeline_stage *stages)
+radv_get_pre_rast_input_topology(const struct radv_pipeline_stage *es_stage,
+                                 const struct radv_pipeline_stage *gs_stage)
 {
-   if (stages[MESA_SHADER_GEOMETRY].nir) {
-      struct radv_shader_info *gs_info = &stages[MESA_SHADER_GEOMETRY].info;
-
-      return gs_info->gs.input_prim;
+   if (gs_stage) {
+      return gs_stage->nir->info.gs.input_primitive;
    }
 
-   if (stages[MESA_SHADER_TESS_CTRL].nir) {
-      struct radv_shader_info *tes_info = &stages[MESA_SHADER_TESS_EVAL].info;
-
-      if (tes_info->tes.point_mode)
+   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
+      if (es_stage->nir->info.tess.point_mode)
          return SHADER_PRIM_POINTS;
-      if (tes_info->tes._primitive_mode == TESS_PRIMITIVE_ISOLINES)
+      if (es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
          return SHADER_PRIM_LINES;
       return SHADER_PRIM_TRIANGLES;
    }
@@ -2068,20 +2058,19 @@ radv_get_pre_rast_input_topology(struct radv_pipeline_stage *stages)
 }
 
 static void
-gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *stages,
-                   struct gfx10_ngg_info *ngg)
+gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage *es_stage,
+                   struct radv_pipeline_stage *gs_stage)
 {
-   const struct radv_physical_device *pdevice = pipeline->device->physical_device;
-   struct radv_shader_info *gs_info = &stages[MESA_SHADER_GEOMETRY].info;
-   struct radv_shader_info *es_info =
-      stages[MESA_SHADER_TESS_CTRL].nir ? &stages[MESA_SHADER_TESS_EVAL].info
-                                        : &stages[MESA_SHADER_VERTEX].info;
-   unsigned gs_type = stages[MESA_SHADER_GEOMETRY].nir ? MESA_SHADER_GEOMETRY : MESA_SHADER_VERTEX;
-   unsigned max_verts_per_prim = radv_get_num_input_vertices(stages);
-   unsigned min_verts_per_prim = gs_type == MESA_SHADER_GEOMETRY ? max_verts_per_prim : 1;
-   unsigned gs_num_invocations = stages[MESA_SHADER_GEOMETRY].nir ? MAX2(gs_info->gs.invocations, 1) : 1;
-
-   const unsigned input_prim = radv_get_pre_rast_input_topology(stages);
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   struct radv_shader_info *gs_info = gs_stage ? &gs_stage->info : NULL;
+   struct radv_shader_info *es_info = &es_stage->info;
+   const unsigned max_verts_per_prim = radv_get_num_input_vertices(es_stage, gs_stage);
+   const unsigned min_verts_per_prim = gs_stage ? max_verts_per_prim : 1;
+   struct gfx10_ngg_info *out = gs_stage ? &gs_info->ngg_info : &es_info->ngg_info;
+
+   const unsigned gs_num_invocations = gs_stage ? MAX2(gs_info->gs.invocations, 1) : 1;
+
+   const unsigned input_prim = radv_get_pre_rast_input_topology(es_stage, gs_stage);
    const bool uses_adjacency = input_prim == SHADER_PRIM_LINES_ADJACENCY ||
                                input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
 
@@ -2099,7 +2088,7 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
    unsigned gsprim_lds_size = 0;
 
    /* All these are per subgroup: */
-   const unsigned min_esverts = pdevice->rad_info.gfx_level >= GFX10_3 ? 29 : 24;
+   const unsigned min_esverts = gfx_level >= GFX10_3 ? 29 : 24;
    bool max_vert_out_per_gs_instance = false;
    unsigned max_esverts_base = 128;
    unsigned max_gsprims_base = 128; /* default prim group size clamp */
@@ -2114,7 +2103,7 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
     */
    max_esverts_base = MIN2(max_esverts_base, 251 + max_verts_per_prim - 1);
 
-   if (gs_type == MESA_SHADER_GEOMETRY) {
+   if (gs_stage) {
       unsigned max_out_verts_per_gsprim = gs_info->gs.vertices_out * gs_num_invocations;
 
       if (max_out_verts_per_gsprim <= 256) {
@@ -2135,9 +2124,7 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
    } else {
       /* VS and TES. */
       /* LDS size for passing data from GS to ES. */
-      struct radv_streamout_info *so_info = stages[MESA_SHADER_TESS_CTRL].nir
-                                               ? &stages[MESA_SHADER_TESS_EVAL].info.so
-                                               : &stages[MESA_SHADER_VERTEX].info.so;
+      struct radv_streamout_info *so_info = &es_info->so;
 
       if (so_info->num_outputs)
          esvert_lds_size = 4 * so_info->num_outputs + 1;
@@ -2146,7 +2133,7 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
        * corresponding to the ES thread of the provoking vertex. All
        * ES threads load and export PrimitiveID for their thread.
        */
-      if (!stages[MESA_SHADER_TESS_CTRL].nir && stages[MESA_SHADER_VERTEX].info.outinfo.export_prim_id)
+      if (es_stage->stage == MESA_SHADER_VERTEX && es_stage->info.outinfo.export_prim_id)
          esvert_lds_size = MAX2(esvert_lds_size, 1);
    }
 
@@ -2187,11 +2174,10 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
       unsigned orig_max_gsprims;
       unsigned wavesize;
 
-      if (gs_type == MESA_SHADER_GEOMETRY) {
+      if (gs_stage) {
          wavesize = gs_info->wave_size;
       } else {
-         wavesize = stages[MESA_SHADER_TESS_CTRL].nir ? stages[MESA_SHADER_TESS_EVAL].info.wave_size
-                                                      : stages[MESA_SHADER_VERTEX].info.wave_size;
+         wavesize = es_info->wave_size;
       }
 
       do {
@@ -2206,7 +2192,7 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
          max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
 
          /* Hardware restriction: minimum value of max_esverts */
-         if (pdevice->rad_info.gfx_level == GFX10)
+         if (gfx_level == GFX10)
             max_esverts = MAX2(max_esverts, min_esverts - 1 + max_verts_per_prim);
          else
             max_esverts = MAX2(max_esverts, min_esverts);
@@ -2229,26 +2215,26 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
       } while (orig_max_esverts != max_esverts || orig_max_gsprims != max_gsprims);
 
       /* Verify the restriction. */
-      if (pdevice->rad_info.gfx_level == GFX10)
+      if (gfx_level == GFX10)
          assert(max_esverts >= min_esverts - 1 + max_verts_per_prim);
       else
          assert(max_esverts >= min_esverts);
    } else {
       /* Hardware restriction: minimum value of max_esverts */
-      if (pdevice->rad_info.gfx_level == GFX10)
+      if (gfx_level == GFX10)
          max_esverts = MAX2(max_esverts, min_esverts - 1 + max_verts_per_prim);
       else
          max_esverts = MAX2(max_esverts, min_esverts);
    }
 
    unsigned max_out_vertices = max_vert_out_per_gs_instance ? gs_info->gs.vertices_out
-                               : gs_type == MESA_SHADER_GEOMETRY
+                               : gs_stage
                                   ? max_gsprims * gs_num_invocations * gs_info->gs.vertices_out
                                   : max_esverts;
    assert(max_out_vertices <= 256);
 
    unsigned prim_amp_factor = 1;
-   if (gs_type == MESA_SHADER_GEOMETRY) {
+   if (gs_stage) {
       /* Number of output primitives per GS input primitive after
        * GS instancing. */
       prim_amp_factor = gs_info->gs.vertices_out;
@@ -2259,35 +2245,36 @@ gfx10_get_ngg_info(struct radv_pipeline *pipeline, struct radv_pipeline_stage *s
     * whenever this check passes, there is enough space for a full
     * primitive without vertex reuse.
     */
-   if (pdevice->rad_info.gfx_level == GFX10)
-      ngg->hw_max_esverts = max_esverts - max_verts_per_prim + 1;
+   if (gfx_level == GFX10)
+      out->hw_max_esverts = max_esverts - max_verts_per_prim + 1;
    else
-      ngg->hw_max_esverts = max_esverts;
+      out->hw_max_esverts = max_esverts;
 
-   ngg->max_gsprims = max_gsprims;
-   ngg->max_out_verts = max_out_vertices;
-   ngg->prim_amp_factor = prim_amp_factor;
-   ngg->max_vert_out_per_gs_instance = max_vert_out_per_gs_instance;
-   ngg->ngg_emit_size = max_gsprims * gsprim_lds_size;
-   ngg->enable_vertex_grouping = true;
+   out->max_gsprims = max_gsprims;
+   out->max_out_verts = max_out_vertices;
+   out->prim_amp_factor = prim_amp_factor;
+   out->max_vert_out_per_gs_instance = max_vert_out_per_gs_instance;
+   out->ngg_emit_size = max_gsprims * gsprim_lds_size;
+   out->enable_vertex_grouping = true;
 
    /* Don't count unusable vertices. */
-   ngg->esgs_ring_size = MIN2(max_esverts, max_gsprims * max_verts_per_prim) * esvert_lds_size * 4;
+   out->esgs_ring_size = MIN2(max_esverts, max_gsprims * max_verts_per_prim) * esvert_lds_size * 4;
 
-   if (gs_type == MESA_SHADER_GEOMETRY) {
-      ngg->vgt_esgs_ring_itemsize = es_info->esgs_itemsize / 4;
+   if (gs_stage) {
+      out->vgt_esgs_ring_itemsize = es_info->esgs_itemsize / 4;
    } else {
-      ngg->vgt_esgs_ring_itemsize = 1;
+      out->vgt_esgs_ring_itemsize = 1;
    }
 
-   assert(ngg->hw_max_esverts >= min_esverts); /* HW limitation */
+   assert(out->hw_max_esverts >= min_esverts); /* HW limitation */
 
-   gl_shader_stage es_stage = stages[MESA_SHADER_TESS_CTRL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
    unsigned workgroup_size =
       ac_compute_ngg_workgroup_size(
          max_esverts, max_gsprims * gs_num_invocations, max_out_vertices, prim_amp_factor);
-   stages[MESA_SHADER_GEOMETRY].info.workgroup_size = workgroup_size;
-   stages[es_stage].info.workgroup_size = workgroup_size;
+   if (gs_stage) {
+      gs_info->workgroup_size = workgroup_size;
+   }
+   es_info->workgroup_size = workgroup_size;
 }
 
 static void
@@ -3405,25 +3392,19 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
    }
 
    if (pipeline_has_ngg) {
-      struct gfx10_ngg_info *ngg_info;
-
-      if (stages[MESA_SHADER_GEOMETRY].nir)
-         ngg_info = &stages[MESA_SHADER_GEOMETRY].info.ngg_info;
-      else if (stages[MESA_SHADER_TESS_CTRL].nir)
-         ngg_info = &stages[MESA_SHADER_TESS_EVAL].info.ngg_info;
-      else if (stages[MESA_SHADER_VERTEX].nir)
-         ngg_info = &stages[MESA_SHADER_VERTEX].info.ngg_info;
-      else if (stages[MESA_SHADER_MESH].nir)
-         ngg_info = &stages[MESA_SHADER_MESH].info.ngg_info;
-      else
-         unreachable("Missing NGG shader stage.");
+      if (last_vgt_api_stage != MESA_SHADER_MESH) {
+         struct radv_pipeline_stage *es_stage =
+            stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
+         struct radv_pipeline_stage *gs_stage =
+            stages[MESA_SHADER_GEOMETRY].nir ? &stages[MESA_SHADER_GEOMETRY] : NULL;
 
-      if (last_vgt_api_stage != MESA_SHADER_MESH)
-         gfx10_get_ngg_info(pipeline, stages, ngg_info);
+         gfx10_get_ngg_info(device, es_stage, gs_stage);
+      }
    } else if (stages[MESA_SHADER_GEOMETRY].nir) {
-      struct gfx9_gs_info *gs_info = &stages[MESA_SHADER_GEOMETRY].info.gs_ring_info;
+      struct radv_pipeline_stage *es_stage =
+         stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
 
-      gfx9_get_gs_info(pipeline, stages, gs_info);
+      gfx9_get_gs_info(device, es_stage, &stages[MESA_SHADER_GEOMETRY]);
    } else {
       gl_shader_stage hw_vs_api_stage =
          stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
-- 
GitLab


From ab3ca98dd99050c5e4921ae681e26991eb2dbc61 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 11:59:06 +0200
Subject: [PATCH 07/16] radv: move computing wave_size/ballot_bit_size to the
 shader info pass
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

NGG helpers need to know this information.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 32 -------------------------------
 src/amd/vulkan/radv_shader_info.c | 28 +++++++++++++++++++++++++++
 2 files changed, 28 insertions(+), 32 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index d7d2d234fd1f..c4a51b4d9bb9 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3116,31 +3116,6 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
    return key;
 }
 
-static uint8_t
-radv_get_wave_size(struct radv_device *device,  gl_shader_stage stage,
-                   const struct radv_shader_info *info)
-{
-   if (stage == MESA_SHADER_GEOMETRY && !info->is_ngg)
-      return 64;
-   else if (stage == MESA_SHADER_COMPUTE) {
-      return info->cs.subgroup_size;
-   } else if (stage == MESA_SHADER_FRAGMENT)
-      return device->physical_device->ps_wave_size;
-   else if (stage == MESA_SHADER_TASK)
-      return device->physical_device->cs_wave_size;
-   else
-      return device->physical_device->ge_wave_size;
-}
-
-static uint8_t
-radv_get_ballot_bit_size(struct radv_device *device, gl_shader_stage stage,
-                         const struct radv_shader_info *info)
-{
-   if (stage == MESA_SHADER_COMPUTE && info->cs.subgroup_size)
-      return info->cs.subgroup_size;
-   return 64;
-}
-
 static void
 radv_determine_ngg_settings(struct radv_pipeline *pipeline,
                             const struct radv_pipeline_key *pipeline_key,
@@ -3355,13 +3330,6 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
 
    radv_nir_shader_info_link(device, pipeline_key, stages, last_vgt_api_stage);
 
-   for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; i++) {
-      if (stages[i].nir) {
-         stages[i].info.wave_size = radv_get_wave_size(device, i, &stages[i].info);
-         stages[i].info.ballot_bit_size = radv_get_ballot_bit_size(device, i, &stages[i].info);
-      }
-   }
-
    if (stages[MESA_SHADER_TESS_CTRL].nir) {
       for (gl_shader_stage s = MESA_SHADER_VERTEX; s <= MESA_SHADER_TESS_CTRL; ++s) {
          stages[s].info.workgroup_size =
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index e89212e78bb8..ae192f51880e 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -315,6 +315,31 @@ assign_outinfo_params(struct radv_vs_output_info *outinfo, uint64_t mask,
    }
 }
 
+static uint8_t
+radv_get_wave_size(struct radv_device *device,  gl_shader_stage stage,
+                   const struct radv_shader_info *info)
+{
+   if (stage == MESA_SHADER_GEOMETRY && !info->is_ngg)
+      return 64;
+   else if (stage == MESA_SHADER_COMPUTE) {
+      return info->cs.subgroup_size;
+   } else if (stage == MESA_SHADER_FRAGMENT)
+      return device->physical_device->ps_wave_size;
+   else if (stage == MESA_SHADER_TASK)
+      return device->physical_device->cs_wave_size;
+   else
+      return device->physical_device->ge_wave_size;
+}
+
+static uint8_t
+radv_get_ballot_bit_size(struct radv_device *device, gl_shader_stage stage,
+                         const struct radv_shader_info *info)
+{
+   if (stage == MESA_SHADER_COMPUTE && info->cs.subgroup_size)
+      return info->cs.subgroup_size;
+   return 64;
+}
+
 static void
 gather_info_input_decl_vs(const nir_shader *nir, unsigned location, const struct glsl_type *type,
                           const struct radv_pipeline_key *key, struct radv_shader_info *info)
@@ -768,6 +793,9 @@ radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *n
    default:
       break;
    }
+
+   info->wave_size = radv_get_wave_size(device, nir->info.stage, info);
+   info->ballot_bit_size = radv_get_ballot_bit_size(device, nir->info.stage, info);
 }
 
 void
-- 
GitLab


From d7e2e97e3d98744d66999e4ca7aca33464b30b56 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 12:03:11 +0200
Subject: [PATCH 08/16] radv: move computing NGG info and GS info to
 radv_nir_shader_info_link()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It's a link step somehow, except for VS only on GFX10+ but keep it
there anyways.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 393 +----------------------------
 src/amd/vulkan/radv_private.h     |   2 +-
 src/amd/vulkan/radv_shader_info.c | 394 +++++++++++++++++++++++++++++-
 3 files changed, 396 insertions(+), 393 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index c4a51b4d9bb9..7b54de513b1d 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1893,142 +1893,6 @@ radv_pipeline_init_depth_stencil_state(struct radv_graphics_pipeline *pipeline,
    return ds_state;
 }
 
-static void
-gfx9_get_gs_info(const struct radv_device *device, struct radv_pipeline_stage *es_stage,
-                 struct radv_pipeline_stage *gs_stage)
-{
-   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
-   struct radv_shader_info *gs_info = &gs_stage->info;
-   struct radv_shader_info *es_info = &es_stage->info;
-   struct gfx9_gs_info *out = &gs_stage->info.gs_ring_info;
-
-   const unsigned gs_num_invocations = MAX2(gs_info->gs.invocations, 1);
-   const bool uses_adjacency = gs_info->gs.input_prim == SHADER_PRIM_LINES_ADJACENCY ||
-                               gs_info->gs.input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
-
-   /* All these are in dwords: */
-   /* We can't allow using the whole LDS, because GS waves compete with
-    * other shader stages for LDS space. */
-   const unsigned max_lds_size = 8 * 1024;
-   const unsigned esgs_itemsize = es_info->esgs_itemsize / 4;
-   unsigned esgs_lds_size;
-
-   /* All these are per subgroup: */
-   const unsigned max_out_prims = 32 * 1024;
-   const unsigned max_es_verts = 255;
-   const unsigned ideal_gs_prims = 64;
-   unsigned max_gs_prims, gs_prims;
-   unsigned min_es_verts, es_verts, worst_case_es_verts;
-
-   if (uses_adjacency || gs_num_invocations > 1)
-      max_gs_prims = 127 / gs_num_invocations;
-   else
-      max_gs_prims = 255;
-
-   /* MAX_PRIMS_PER_SUBGROUP = gs_prims * max_vert_out * gs_invocations.
-    * Make sure we don't go over the maximum value.
-    */
-   if (gs_info->gs.vertices_out > 0) {
-      max_gs_prims =
-         MIN2(max_gs_prims, max_out_prims / (gs_info->gs.vertices_out * gs_num_invocations));
-   }
-   assert(max_gs_prims > 0);
-
-   /* If the primitive has adjacency, halve the number of vertices
-    * that will be reused in multiple primitives.
-    */
-   min_es_verts = gs_info->gs.vertices_in / (uses_adjacency ? 2 : 1);
-
-   gs_prims = MIN2(ideal_gs_prims, max_gs_prims);
-   worst_case_es_verts = MIN2(min_es_verts * gs_prims, max_es_verts);
-
-   /* Compute ESGS LDS size based on the worst case number of ES vertices
-    * needed to create the target number of GS prims per subgroup.
-    */
-   esgs_lds_size = esgs_itemsize * worst_case_es_verts;
-
-   /* If total LDS usage is too big, refactor partitions based on ratio
-    * of ESGS item sizes.
-    */
-   if (esgs_lds_size > max_lds_size) {
-      /* Our target GS Prims Per Subgroup was too large. Calculate
-       * the maximum number of GS Prims Per Subgroup that will fit
-       * into LDS, capped by the maximum that the hardware can support.
-       */
-      gs_prims = MIN2((max_lds_size / (esgs_itemsize * min_es_verts)), max_gs_prims);
-      assert(gs_prims > 0);
-      worst_case_es_verts = MIN2(min_es_verts * gs_prims, max_es_verts);
-
-      esgs_lds_size = esgs_itemsize * worst_case_es_verts;
-      assert(esgs_lds_size <= max_lds_size);
-   }
-
-   /* Now calculate remaining ESGS information. */
-   if (esgs_lds_size)
-      es_verts = MIN2(esgs_lds_size / esgs_itemsize, max_es_verts);
-   else
-      es_verts = max_es_verts;
-
-   /* Vertices for adjacency primitives are not always reused, so restore
-    * it for ES_VERTS_PER_SUBGRP.
-    */
-   min_es_verts = gs_info->gs.vertices_in;
-
-   /* For normal primitives, the VGT only checks if they are past the ES
-    * verts per subgroup after allocating a full GS primitive and if they
-    * are, kick off a new subgroup.  But if those additional ES verts are
-    * unique (e.g. not reused) we need to make sure there is enough LDS
-    * space to account for those ES verts beyond ES_VERTS_PER_SUBGRP.
-    */
-   es_verts -= min_es_verts - 1;
-
-   const uint32_t es_verts_per_subgroup = es_verts;
-   const uint32_t gs_prims_per_subgroup = gs_prims;
-   const uint32_t gs_inst_prims_in_subgroup = gs_prims * gs_num_invocations;
-   const uint32_t max_prims_per_subgroup = gs_inst_prims_in_subgroup * gs_info->gs.vertices_out;
-   out->lds_size = align(esgs_lds_size, 128) / 128;
-   out->vgt_gs_onchip_cntl = S_028A44_ES_VERTS_PER_SUBGRP(es_verts_per_subgroup) |
-                             S_028A44_GS_PRIMS_PER_SUBGRP(gs_prims_per_subgroup) |
-                             S_028A44_GS_INST_PRIMS_IN_SUBGRP(gs_inst_prims_in_subgroup);
-   out->vgt_gs_max_prims_per_subgroup = S_028A94_MAX_PRIMS_PER_SUBGROUP(max_prims_per_subgroup);
-   out->vgt_esgs_ring_itemsize = esgs_itemsize;
-   assert(max_prims_per_subgroup <= max_out_prims);
-
-   unsigned workgroup_size = ac_compute_esgs_workgroup_size(gfx_level, es_info->wave_size,
-      es_verts_per_subgroup, gs_inst_prims_in_subgroup);
-   es_info->workgroup_size = workgroup_size;
-   gs_info->workgroup_size = workgroup_size;
-}
-
-static void
-clamp_gsprims_to_esverts(unsigned *max_gsprims, unsigned max_esverts, unsigned min_verts_per_prim,
-                         bool use_adjacency)
-{
-   unsigned max_reuse = max_esverts - min_verts_per_prim;
-   if (use_adjacency)
-      max_reuse /= 2;
-   *max_gsprims = MIN2(*max_gsprims, 1 + max_reuse);
-}
-
-static unsigned
-radv_get_num_input_vertices(const struct radv_pipeline_stage *es_stage,
-                            const struct radv_pipeline_stage *gs_stage)
-{
-   if (gs_stage) {
-      return gs_stage->nir->info.gs.vertices_in;
-   }
-
-   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
-      if (es_stage->nir->info.tess.point_mode)
-         return 1;
-      if (es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
-         return 2;
-      return 3;
-   }
-
-   return 3;
-}
-
 static void
 gfx10_emit_ge_pc_alloc(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level,
                        uint32_t oversub_pc_lines)
@@ -2038,245 +1902,6 @@ gfx10_emit_ge_pc_alloc(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level,
       S_030980_OVERSUB_EN(oversub_pc_lines > 0) | S_030980_NUM_PC_LINES(oversub_pc_lines - 1));
 }
 
-static unsigned
-radv_get_pre_rast_input_topology(const struct radv_pipeline_stage *es_stage,
-                                 const struct radv_pipeline_stage *gs_stage)
-{
-   if (gs_stage) {
-      return gs_stage->nir->info.gs.input_primitive;
-   }
-
-   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
-      if (es_stage->nir->info.tess.point_mode)
-         return SHADER_PRIM_POINTS;
-      if (es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
-         return SHADER_PRIM_LINES;
-      return SHADER_PRIM_TRIANGLES;
-   }
-
-   return SHADER_PRIM_TRIANGLES;
-}
-
-static void
-gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage *es_stage,
-                   struct radv_pipeline_stage *gs_stage)
-{
-   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
-   struct radv_shader_info *gs_info = gs_stage ? &gs_stage->info : NULL;
-   struct radv_shader_info *es_info = &es_stage->info;
-   const unsigned max_verts_per_prim = radv_get_num_input_vertices(es_stage, gs_stage);
-   const unsigned min_verts_per_prim = gs_stage ? max_verts_per_prim : 1;
-   struct gfx10_ngg_info *out = gs_stage ? &gs_info->ngg_info : &es_info->ngg_info;
-
-   const unsigned gs_num_invocations = gs_stage ? MAX2(gs_info->gs.invocations, 1) : 1;
-
-   const unsigned input_prim = radv_get_pre_rast_input_topology(es_stage, gs_stage);
-   const bool uses_adjacency = input_prim == SHADER_PRIM_LINES_ADJACENCY ||
-                               input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
-
-   /* All these are in dwords: */
-   /* We can't allow using the whole LDS, because GS waves compete with
-    * other shader stages for LDS space.
-    *
-    * TODO: We should really take the shader's internal LDS use into
-    *       account. The linker will fail if the size is greater than
-    *       8K dwords.
-    */
-   const unsigned max_lds_size = 8 * 1024 - 768;
-   const unsigned target_lds_size = max_lds_size;
-   unsigned esvert_lds_size = 0;
-   unsigned gsprim_lds_size = 0;
-
-   /* All these are per subgroup: */
-   const unsigned min_esverts = gfx_level >= GFX10_3 ? 29 : 24;
-   bool max_vert_out_per_gs_instance = false;
-   unsigned max_esverts_base = 128;
-   unsigned max_gsprims_base = 128; /* default prim group size clamp */
-
-   /* Hardware has the following non-natural restrictions on the value
-    * of GE_CNTL.VERT_GRP_SIZE based on based on the primitive type of
-    * the draw:
-    *  - at most 252 for any line input primitive type
-    *  - at most 251 for any quad input primitive type
-    *  - at most 251 for triangle strips with adjacency (this happens to
-    *    be the natural limit for triangle *lists* with adjacency)
-    */
-   max_esverts_base = MIN2(max_esverts_base, 251 + max_verts_per_prim - 1);
-
-   if (gs_stage) {
-      unsigned max_out_verts_per_gsprim = gs_info->gs.vertices_out * gs_num_invocations;
-
-      if (max_out_verts_per_gsprim <= 256) {
-         if (max_out_verts_per_gsprim) {
-            max_gsprims_base = MIN2(max_gsprims_base, 256 / max_out_verts_per_gsprim);
-         }
-      } else {
-         /* Use special multi-cycling mode in which each GS
-          * instance gets its own subgroup. Does not work with
-          * tessellation. */
-         max_vert_out_per_gs_instance = true;
-         max_gsprims_base = 1;
-         max_out_verts_per_gsprim = gs_info->gs.vertices_out;
-      }
-
-      esvert_lds_size = es_info->esgs_itemsize / 4;
-      gsprim_lds_size = (gs_info->gs.gsvs_vertex_size / 4 + 1) * max_out_verts_per_gsprim;
-   } else {
-      /* VS and TES. */
-      /* LDS size for passing data from GS to ES. */
-      struct radv_streamout_info *so_info = &es_info->so;
-
-      if (so_info->num_outputs)
-         esvert_lds_size = 4 * so_info->num_outputs + 1;
-
-      /* GS stores Primitive IDs (one DWORD) into LDS at the address
-       * corresponding to the ES thread of the provoking vertex. All
-       * ES threads load and export PrimitiveID for their thread.
-       */
-      if (es_stage->stage == MESA_SHADER_VERTEX && es_stage->info.outinfo.export_prim_id)
-         esvert_lds_size = MAX2(esvert_lds_size, 1);
-   }
-
-   unsigned max_gsprims = max_gsprims_base;
-   unsigned max_esverts = max_esverts_base;
-
-   if (esvert_lds_size)
-      max_esverts = MIN2(max_esverts, target_lds_size / esvert_lds_size);
-   if (gsprim_lds_size)
-      max_gsprims = MIN2(max_gsprims, target_lds_size / gsprim_lds_size);
-
-   max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
-   clamp_gsprims_to_esverts(&max_gsprims, max_esverts, min_verts_per_prim, uses_adjacency);
-   assert(max_esverts >= max_verts_per_prim && max_gsprims >= 1);
-
-   if (esvert_lds_size || gsprim_lds_size) {
-      /* Now that we have a rough proportionality between esverts
-       * and gsprims based on the primitive type, scale both of them
-       * down simultaneously based on required LDS space.
-       *
-       * We could be smarter about this if we knew how much vertex
-       * reuse to expect.
-       */
-      unsigned lds_total = max_esverts * esvert_lds_size + max_gsprims * gsprim_lds_size;
-      if (lds_total > target_lds_size) {
-         max_esverts = max_esverts * target_lds_size / lds_total;
-         max_gsprims = max_gsprims * target_lds_size / lds_total;
-
-         max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
-         clamp_gsprims_to_esverts(&max_gsprims, max_esverts, min_verts_per_prim, uses_adjacency);
-         assert(max_esverts >= max_verts_per_prim && max_gsprims >= 1);
-      }
-   }
-
-   /* Round up towards full wave sizes for better ALU utilization. */
-   if (!max_vert_out_per_gs_instance) {
-      unsigned orig_max_esverts;
-      unsigned orig_max_gsprims;
-      unsigned wavesize;
-
-      if (gs_stage) {
-         wavesize = gs_info->wave_size;
-      } else {
-         wavesize = es_info->wave_size;
-      }
-
-      do {
-         orig_max_esverts = max_esverts;
-         orig_max_gsprims = max_gsprims;
-
-         max_esverts = align(max_esverts, wavesize);
-         max_esverts = MIN2(max_esverts, max_esverts_base);
-         if (esvert_lds_size)
-            max_esverts =
-               MIN2(max_esverts, (max_lds_size - max_gsprims * gsprim_lds_size) / esvert_lds_size);
-         max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
-
-         /* Hardware restriction: minimum value of max_esverts */
-         if (gfx_level == GFX10)
-            max_esverts = MAX2(max_esverts, min_esverts - 1 + max_verts_per_prim);
-         else
-            max_esverts = MAX2(max_esverts, min_esverts);
-
-         max_gsprims = align(max_gsprims, wavesize);
-         max_gsprims = MIN2(max_gsprims, max_gsprims_base);
-         if (gsprim_lds_size) {
-            /* Don't count unusable vertices to the LDS
-             * size. Those are vertices above the maximum
-             * number of vertices that can occur in the
-             * workgroup, which is e.g. max_gsprims * 3
-             * for triangles.
-             */
-            unsigned usable_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
-            max_gsprims = MIN2(max_gsprims,
-                               (max_lds_size - usable_esverts * esvert_lds_size) / gsprim_lds_size);
-         }
-         clamp_gsprims_to_esverts(&max_gsprims, max_esverts, min_verts_per_prim, uses_adjacency);
-         assert(max_esverts >= max_verts_per_prim && max_gsprims >= 1);
-      } while (orig_max_esverts != max_esverts || orig_max_gsprims != max_gsprims);
-
-      /* Verify the restriction. */
-      if (gfx_level == GFX10)
-         assert(max_esverts >= min_esverts - 1 + max_verts_per_prim);
-      else
-         assert(max_esverts >= min_esverts);
-   } else {
-      /* Hardware restriction: minimum value of max_esverts */
-      if (gfx_level == GFX10)
-         max_esverts = MAX2(max_esverts, min_esverts - 1 + max_verts_per_prim);
-      else
-         max_esverts = MAX2(max_esverts, min_esverts);
-   }
-
-   unsigned max_out_vertices = max_vert_out_per_gs_instance ? gs_info->gs.vertices_out
-                               : gs_stage
-                                  ? max_gsprims * gs_num_invocations * gs_info->gs.vertices_out
-                                  : max_esverts;
-   assert(max_out_vertices <= 256);
-
-   unsigned prim_amp_factor = 1;
-   if (gs_stage) {
-      /* Number of output primitives per GS input primitive after
-       * GS instancing. */
-      prim_amp_factor = gs_info->gs.vertices_out;
-   }
-
-   /* On Gfx10, the GE only checks against the maximum number of ES verts
-    * after allocating a full GS primitive. So we need to ensure that
-    * whenever this check passes, there is enough space for a full
-    * primitive without vertex reuse.
-    */
-   if (gfx_level == GFX10)
-      out->hw_max_esverts = max_esverts - max_verts_per_prim + 1;
-   else
-      out->hw_max_esverts = max_esverts;
-
-   out->max_gsprims = max_gsprims;
-   out->max_out_verts = max_out_vertices;
-   out->prim_amp_factor = prim_amp_factor;
-   out->max_vert_out_per_gs_instance = max_vert_out_per_gs_instance;
-   out->ngg_emit_size = max_gsprims * gsprim_lds_size;
-   out->enable_vertex_grouping = true;
-
-   /* Don't count unusable vertices. */
-   out->esgs_ring_size = MIN2(max_esverts, max_gsprims * max_verts_per_prim) * esvert_lds_size * 4;
-
-   if (gs_stage) {
-      out->vgt_esgs_ring_itemsize = es_info->esgs_itemsize / 4;
-   } else {
-      out->vgt_esgs_ring_itemsize = 1;
-   }
-
-   assert(out->hw_max_esverts >= min_esverts); /* HW limitation */
-
-   unsigned workgroup_size =
-      ac_compute_ngg_workgroup_size(
-         max_esverts, max_gsprims * gs_num_invocations, max_out_vertices, prim_amp_factor);
-   if (gs_stage) {
-      gs_info->workgroup_size = workgroup_size;
-   }
-   es_info->workgroup_size = workgroup_size;
-}
-
 static void
 radv_pipeline_init_gs_ring_state(struct radv_graphics_pipeline *pipeline, const struct gfx9_gs_info *gs)
 {
@@ -3328,7 +2953,7 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
                                 &stages[i].info);
    }
 
-   radv_nir_shader_info_link(device, pipeline_key, stages, last_vgt_api_stage);
+   radv_nir_shader_info_link(device, pipeline_key, stages, pipeline_has_ngg, last_vgt_api_stage);
 
    if (stages[MESA_SHADER_TESS_CTRL].nir) {
       for (gl_shader_stage s = MESA_SHADER_VERTEX; s <= MESA_SHADER_TESS_CTRL; ++s) {
@@ -3359,21 +2984,7 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
             stages[MESA_SHADER_TASK].nir->info.workgroup_size, false, UINT32_MAX);
    }
 
-   if (pipeline_has_ngg) {
-      if (last_vgt_api_stage != MESA_SHADER_MESH) {
-         struct radv_pipeline_stage *es_stage =
-            stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
-         struct radv_pipeline_stage *gs_stage =
-            stages[MESA_SHADER_GEOMETRY].nir ? &stages[MESA_SHADER_GEOMETRY] : NULL;
-
-         gfx10_get_ngg_info(device, es_stage, gs_stage);
-      }
-   } else if (stages[MESA_SHADER_GEOMETRY].nir) {
-      struct radv_pipeline_stage *es_stage =
-         stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
-
-      gfx9_get_gs_info(device, es_stage, &stages[MESA_SHADER_GEOMETRY]);
-   } else {
+   if (!pipeline_has_ngg && !stages[MESA_SHADER_GEOMETRY].nir) {
       gl_shader_stage hw_vs_api_stage =
          stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
       stages[hw_vs_api_stage].info.workgroup_size = stages[hw_vs_api_stage].info.wave_size;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index e5172811a9af..1be1efc81c8d 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2793,7 +2793,7 @@ void radv_nir_shader_info_init(struct radv_shader_info *info);
 
 void radv_nir_shader_info_link(struct radv_device *device,
                                const struct radv_pipeline_key *pipeline_key,
-                               struct radv_pipeline_stage *stages,
+                               struct radv_pipeline_stage *stages, bool pipeline_has_ngg,
                                gl_shader_stage last_vgt_api_stage);
 
 bool radv_thread_trace_init(struct radv_device *device);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index ae192f51880e..c811df0415e0 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -798,9 +798,385 @@ radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *n
    info->ballot_bit_size = radv_get_ballot_bit_size(device, nir->info.stage, info);
 }
 
+static void
+gfx9_get_gs_info(const struct radv_device *device, struct radv_pipeline_stage *es_stage,
+                 struct radv_pipeline_stage *gs_stage)
+{
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   struct radv_shader_info *gs_info = &gs_stage->info;
+   struct radv_shader_info *es_info = &es_stage->info;
+   struct gfx9_gs_info *out = &gs_stage->info.gs_ring_info;
+
+   const unsigned gs_num_invocations = MAX2(gs_info->gs.invocations, 1);
+   const bool uses_adjacency = gs_info->gs.input_prim == SHADER_PRIM_LINES_ADJACENCY ||
+                               gs_info->gs.input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
+
+   /* All these are in dwords: */
+   /* We can't allow using the whole LDS, because GS waves compete with
+    * other shader stages for LDS space. */
+   const unsigned max_lds_size = 8 * 1024;
+   const unsigned esgs_itemsize = es_info->esgs_itemsize / 4;
+   unsigned esgs_lds_size;
+
+   /* All these are per subgroup: */
+   const unsigned max_out_prims = 32 * 1024;
+   const unsigned max_es_verts = 255;
+   const unsigned ideal_gs_prims = 64;
+   unsigned max_gs_prims, gs_prims;
+   unsigned min_es_verts, es_verts, worst_case_es_verts;
+
+   if (uses_adjacency || gs_num_invocations > 1)
+      max_gs_prims = 127 / gs_num_invocations;
+   else
+      max_gs_prims = 255;
+
+   /* MAX_PRIMS_PER_SUBGROUP = gs_prims * max_vert_out * gs_invocations.
+    * Make sure we don't go over the maximum value.
+    */
+   if (gs_info->gs.vertices_out > 0) {
+      max_gs_prims =
+         MIN2(max_gs_prims, max_out_prims / (gs_info->gs.vertices_out * gs_num_invocations));
+   }
+   assert(max_gs_prims > 0);
+
+   /* If the primitive has adjacency, halve the number of vertices
+    * that will be reused in multiple primitives.
+    */
+   min_es_verts = gs_info->gs.vertices_in / (uses_adjacency ? 2 : 1);
+
+   gs_prims = MIN2(ideal_gs_prims, max_gs_prims);
+   worst_case_es_verts = MIN2(min_es_verts * gs_prims, max_es_verts);
+
+   /* Compute ESGS LDS size based on the worst case number of ES vertices
+    * needed to create the target number of GS prims per subgroup.
+    */
+   esgs_lds_size = esgs_itemsize * worst_case_es_verts;
+
+   /* If total LDS usage is too big, refactor partitions based on ratio
+    * of ESGS item sizes.
+    */
+   if (esgs_lds_size > max_lds_size) {
+      /* Our target GS Prims Per Subgroup was too large. Calculate
+       * the maximum number of GS Prims Per Subgroup that will fit
+       * into LDS, capped by the maximum that the hardware can support.
+       */
+      gs_prims = MIN2((max_lds_size / (esgs_itemsize * min_es_verts)), max_gs_prims);
+      assert(gs_prims > 0);
+      worst_case_es_verts = MIN2(min_es_verts * gs_prims, max_es_verts);
+
+      esgs_lds_size = esgs_itemsize * worst_case_es_verts;
+      assert(esgs_lds_size <= max_lds_size);
+   }
+
+   /* Now calculate remaining ESGS information. */
+   if (esgs_lds_size)
+      es_verts = MIN2(esgs_lds_size / esgs_itemsize, max_es_verts);
+   else
+      es_verts = max_es_verts;
+
+   /* Vertices for adjacency primitives are not always reused, so restore
+    * it for ES_VERTS_PER_SUBGRP.
+    */
+   min_es_verts = gs_info->gs.vertices_in;
+
+   /* For normal primitives, the VGT only checks if they are past the ES
+    * verts per subgroup after allocating a full GS primitive and if they
+    * are, kick off a new subgroup.  But if those additional ES verts are
+    * unique (e.g. not reused) we need to make sure there is enough LDS
+    * space to account for those ES verts beyond ES_VERTS_PER_SUBGRP.
+    */
+   es_verts -= min_es_verts - 1;
+
+   const uint32_t es_verts_per_subgroup = es_verts;
+   const uint32_t gs_prims_per_subgroup = gs_prims;
+   const uint32_t gs_inst_prims_in_subgroup = gs_prims * gs_num_invocations;
+   const uint32_t max_prims_per_subgroup = gs_inst_prims_in_subgroup * gs_info->gs.vertices_out;
+   out->lds_size = align(esgs_lds_size, 128) / 128;
+   out->vgt_gs_onchip_cntl = S_028A44_ES_VERTS_PER_SUBGRP(es_verts_per_subgroup) |
+                             S_028A44_GS_PRIMS_PER_SUBGRP(gs_prims_per_subgroup) |
+                             S_028A44_GS_INST_PRIMS_IN_SUBGRP(gs_inst_prims_in_subgroup);
+   out->vgt_gs_max_prims_per_subgroup = S_028A94_MAX_PRIMS_PER_SUBGROUP(max_prims_per_subgroup);
+   out->vgt_esgs_ring_itemsize = esgs_itemsize;
+   assert(max_prims_per_subgroup <= max_out_prims);
+
+   unsigned workgroup_size = ac_compute_esgs_workgroup_size(gfx_level, es_info->wave_size,
+      es_verts_per_subgroup, gs_inst_prims_in_subgroup);
+   es_info->workgroup_size = workgroup_size;
+   gs_info->workgroup_size = workgroup_size;
+}
+
+static void
+clamp_gsprims_to_esverts(unsigned *max_gsprims, unsigned max_esverts, unsigned min_verts_per_prim,
+                         bool use_adjacency)
+{
+   unsigned max_reuse = max_esverts - min_verts_per_prim;
+   if (use_adjacency)
+      max_reuse /= 2;
+   *max_gsprims = MIN2(*max_gsprims, 1 + max_reuse);
+}
+
+static unsigned
+radv_get_num_input_vertices(const struct radv_pipeline_stage *es_stage,
+                            const struct radv_pipeline_stage *gs_stage)
+{
+   if (gs_stage) {
+      return gs_stage->nir->info.gs.vertices_in;
+   }
+
+   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
+      if (es_stage->nir->info.tess.point_mode)
+         return 1;
+      if (es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
+         return 2;
+      return 3;
+   }
+
+   return 3;
+}
+
+static unsigned
+radv_get_pre_rast_input_topology(const struct radv_pipeline_stage *es_stage,
+                                 const struct radv_pipeline_stage *gs_stage)
+{
+   if (gs_stage) {
+      return gs_stage->nir->info.gs.input_primitive;
+   }
+
+   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
+      if (es_stage->nir->info.tess.point_mode)
+         return SHADER_PRIM_POINTS;
+      if (es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES)
+         return SHADER_PRIM_LINES;
+      return SHADER_PRIM_TRIANGLES;
+   }
+
+   return SHADER_PRIM_TRIANGLES;
+}
+
+static void
+gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage *es_stage,
+                   struct radv_pipeline_stage *gs_stage)
+{
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   struct radv_shader_info *gs_info = gs_stage ? &gs_stage->info : NULL;
+   struct radv_shader_info *es_info = &es_stage->info;
+   const unsigned max_verts_per_prim = radv_get_num_input_vertices(es_stage, gs_stage);
+   const unsigned min_verts_per_prim = gs_stage ? max_verts_per_prim : 1;
+   struct gfx10_ngg_info *out = gs_stage ? &gs_info->ngg_info : &es_info->ngg_info;
+
+   const unsigned gs_num_invocations = gs_stage ? MAX2(gs_info->gs.invocations, 1) : 1;
+
+   const unsigned input_prim = radv_get_pre_rast_input_topology(es_stage, gs_stage);
+   const bool uses_adjacency = input_prim == SHADER_PRIM_LINES_ADJACENCY ||
+                               input_prim == SHADER_PRIM_TRIANGLES_ADJACENCY;
+
+   /* All these are in dwords: */
+   /* We can't allow using the whole LDS, because GS waves compete with
+    * other shader stages for LDS space.
+    *
+    * TODO: We should really take the shader's internal LDS use into
+    *       account. The linker will fail if the size is greater than
+    *       8K dwords.
+    */
+   const unsigned max_lds_size = 8 * 1024 - 768;
+   const unsigned target_lds_size = max_lds_size;
+   unsigned esvert_lds_size = 0;
+   unsigned gsprim_lds_size = 0;
+
+   /* All these are per subgroup: */
+   const unsigned min_esverts = gfx_level >= GFX10_3 ? 29 : 24;
+   bool max_vert_out_per_gs_instance = false;
+   unsigned max_esverts_base = 128;
+   unsigned max_gsprims_base = 128; /* default prim group size clamp */
+
+   /* Hardware has the following non-natural restrictions on the value
+    * of GE_CNTL.VERT_GRP_SIZE based on based on the primitive type of
+    * the draw:
+    *  - at most 252 for any line input primitive type
+    *  - at most 251 for any quad input primitive type
+    *  - at most 251 for triangle strips with adjacency (this happens to
+    *    be the natural limit for triangle *lists* with adjacency)
+    */
+   max_esverts_base = MIN2(max_esverts_base, 251 + max_verts_per_prim - 1);
+
+   if (gs_stage) {
+      unsigned max_out_verts_per_gsprim = gs_info->gs.vertices_out * gs_num_invocations;
+
+      if (max_out_verts_per_gsprim <= 256) {
+         if (max_out_verts_per_gsprim) {
+            max_gsprims_base = MIN2(max_gsprims_base, 256 / max_out_verts_per_gsprim);
+         }
+      } else {
+         /* Use special multi-cycling mode in which each GS
+          * instance gets its own subgroup. Does not work with
+          * tessellation. */
+         max_vert_out_per_gs_instance = true;
+         max_gsprims_base = 1;
+         max_out_verts_per_gsprim = gs_info->gs.vertices_out;
+      }
+
+      esvert_lds_size = es_info->esgs_itemsize / 4;
+      gsprim_lds_size = (gs_info->gs.gsvs_vertex_size / 4 + 1) * max_out_verts_per_gsprim;
+   } else {
+      /* VS and TES. */
+      /* LDS size for passing data from GS to ES. */
+      struct radv_streamout_info *so_info = &es_info->so;
+
+      if (so_info->num_outputs)
+         esvert_lds_size = 4 * so_info->num_outputs + 1;
+
+      /* GS stores Primitive IDs (one DWORD) into LDS at the address
+       * corresponding to the ES thread of the provoking vertex. All
+       * ES threads load and export PrimitiveID for their thread.
+       */
+      if (es_stage->stage == MESA_SHADER_VERTEX && es_stage->info.outinfo.export_prim_id)
+         esvert_lds_size = MAX2(esvert_lds_size, 1);
+   }
+
+   unsigned max_gsprims = max_gsprims_base;
+   unsigned max_esverts = max_esverts_base;
+
+   if (esvert_lds_size)
+      max_esverts = MIN2(max_esverts, target_lds_size / esvert_lds_size);
+   if (gsprim_lds_size)
+      max_gsprims = MIN2(max_gsprims, target_lds_size / gsprim_lds_size);
+
+   max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
+   clamp_gsprims_to_esverts(&max_gsprims, max_esverts, min_verts_per_prim, uses_adjacency);
+   assert(max_esverts >= max_verts_per_prim && max_gsprims >= 1);
+
+   if (esvert_lds_size || gsprim_lds_size) {
+      /* Now that we have a rough proportionality between esverts
+       * and gsprims based on the primitive type, scale both of them
+       * down simultaneously based on required LDS space.
+       *
+       * We could be smarter about this if we knew how much vertex
+       * reuse to expect.
+       */
+      unsigned lds_total = max_esverts * esvert_lds_size + max_gsprims * gsprim_lds_size;
+      if (lds_total > target_lds_size) {
+         max_esverts = max_esverts * target_lds_size / lds_total;
+         max_gsprims = max_gsprims * target_lds_size / lds_total;
+
+         max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
+         clamp_gsprims_to_esverts(&max_gsprims, max_esverts, min_verts_per_prim, uses_adjacency);
+         assert(max_esverts >= max_verts_per_prim && max_gsprims >= 1);
+      }
+   }
+
+   /* Round up towards full wave sizes for better ALU utilization. */
+   if (!max_vert_out_per_gs_instance) {
+      unsigned orig_max_esverts;
+      unsigned orig_max_gsprims;
+      unsigned wavesize;
+
+      if (gs_stage) {
+         wavesize = gs_info->wave_size;
+      } else {
+         wavesize = es_info->wave_size;
+      }
+
+      do {
+         orig_max_esverts = max_esverts;
+         orig_max_gsprims = max_gsprims;
+
+         max_esverts = align(max_esverts, wavesize);
+         max_esverts = MIN2(max_esverts, max_esverts_base);
+         if (esvert_lds_size)
+            max_esverts =
+               MIN2(max_esverts, (max_lds_size - max_gsprims * gsprim_lds_size) / esvert_lds_size);
+         max_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
+
+         /* Hardware restriction: minimum value of max_esverts */
+         if (gfx_level == GFX10)
+            max_esverts = MAX2(max_esverts, min_esverts - 1 + max_verts_per_prim);
+         else
+            max_esverts = MAX2(max_esverts, min_esverts);
+
+         max_gsprims = align(max_gsprims, wavesize);
+         max_gsprims = MIN2(max_gsprims, max_gsprims_base);
+         if (gsprim_lds_size) {
+            /* Don't count unusable vertices to the LDS
+             * size. Those are vertices above the maximum
+             * number of vertices that can occur in the
+             * workgroup, which is e.g. max_gsprims * 3
+             * for triangles.
+             */
+            unsigned usable_esverts = MIN2(max_esverts, max_gsprims * max_verts_per_prim);
+            max_gsprims = MIN2(max_gsprims,
+                               (max_lds_size - usable_esverts * esvert_lds_size) / gsprim_lds_size);
+         }
+         clamp_gsprims_to_esverts(&max_gsprims, max_esverts, min_verts_per_prim, uses_adjacency);
+         assert(max_esverts >= max_verts_per_prim && max_gsprims >= 1);
+      } while (orig_max_esverts != max_esverts || orig_max_gsprims != max_gsprims);
+
+      /* Verify the restriction. */
+      if (gfx_level == GFX10)
+         assert(max_esverts >= min_esverts - 1 + max_verts_per_prim);
+      else
+         assert(max_esverts >= min_esverts);
+   } else {
+      /* Hardware restriction: minimum value of max_esverts */
+      if (gfx_level == GFX10)
+         max_esverts = MAX2(max_esverts, min_esverts - 1 + max_verts_per_prim);
+      else
+         max_esverts = MAX2(max_esverts, min_esverts);
+   }
+
+   unsigned max_out_vertices = max_vert_out_per_gs_instance ? gs_info->gs.vertices_out
+                               : gs_stage
+                                  ? max_gsprims * gs_num_invocations * gs_info->gs.vertices_out
+                                  : max_esverts;
+   assert(max_out_vertices <= 256);
+
+   unsigned prim_amp_factor = 1;
+   if (gs_stage) {
+      /* Number of output primitives per GS input primitive after
+       * GS instancing. */
+      prim_amp_factor = gs_info->gs.vertices_out;
+   }
+
+   /* On Gfx10, the GE only checks against the maximum number of ES verts
+    * after allocating a full GS primitive. So we need to ensure that
+    * whenever this check passes, there is enough space for a full
+    * primitive without vertex reuse.
+    */
+   if (gfx_level == GFX10)
+      out->hw_max_esverts = max_esverts - max_verts_per_prim + 1;
+   else
+      out->hw_max_esverts = max_esverts;
+
+   out->max_gsprims = max_gsprims;
+   out->max_out_verts = max_out_vertices;
+   out->prim_amp_factor = prim_amp_factor;
+   out->max_vert_out_per_gs_instance = max_vert_out_per_gs_instance;
+   out->ngg_emit_size = max_gsprims * gsprim_lds_size;
+   out->enable_vertex_grouping = true;
+
+   /* Don't count unusable vertices. */
+   out->esgs_ring_size = MIN2(max_esverts, max_gsprims * max_verts_per_prim) * esvert_lds_size * 4;
+
+   if (gs_stage) {
+      out->vgt_esgs_ring_itemsize = es_info->esgs_itemsize / 4;
+   } else {
+      out->vgt_esgs_ring_itemsize = 1;
+   }
+
+   assert(out->hw_max_esverts >= min_esverts); /* HW limitation */
+
+   unsigned workgroup_size =
+      ac_compute_ngg_workgroup_size(
+         max_esverts, max_gsprims * gs_num_invocations, max_out_vertices, prim_amp_factor);
+   if (gs_stage) {
+      gs_info->workgroup_size = workgroup_size;
+   }
+   es_info->workgroup_size = workgroup_size;
+}
+
 void
 radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline_key *pipeline_key,
-                          struct radv_pipeline_stage *stages, gl_shader_stage last_vgt_api_stage)
+                          struct radv_pipeline_stage *stages, bool pipeline_has_ngg,
+                          gl_shader_stage last_vgt_api_stage)
 {
    if (stages[MESA_SHADER_FRAGMENT].nir) {
       assert(last_vgt_api_stage != MESA_SHADER_NONE);
@@ -897,4 +1273,20 @@ radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline
       /* Task/mesh I/O uses the task ring buffers. */
       stages[MESA_SHADER_MESH].info.ms.has_task = true;
    }
+
+   if (pipeline_has_ngg) {
+      if (last_vgt_api_stage != MESA_SHADER_MESH) {
+         struct radv_pipeline_stage *es_stage =
+            stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
+         struct radv_pipeline_stage *gs_stage =
+            stages[MESA_SHADER_GEOMETRY].nir ? &stages[MESA_SHADER_GEOMETRY] : NULL;
+
+         gfx10_get_ngg_info(device, es_stage, gs_stage);
+      }
+   } else if (stages[MESA_SHADER_GEOMETRY].nir) {
+      struct radv_pipeline_stage *es_stage =
+         stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
+
+      gfx9_get_gs_info(device, es_stage, &stages[MESA_SHADER_GEOMETRY]);
+   }
 }
-- 
GitLab


From 6e19e9d24f91e3e892ab267e19f3b6a179c355d7 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 12:30:57 +0200
Subject: [PATCH 09/16] radv: refactor radv_nir_shader_info_link()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To use the similar producer/consumer logic we do when linking shaders.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_shader_info.c | 184 ++++++++++++++++--------------
 1 file changed, 98 insertions(+), 86 deletions(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index c811df0415e0..266f04023df1 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1173,24 +1173,19 @@ gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage
    es_info->workgroup_size = workgroup_size;
 }
 
-void
-radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline_key *pipeline_key,
-                          struct radv_pipeline_stage *stages, bool pipeline_has_ngg,
-                          gl_shader_stage last_vgt_api_stage)
+static void
+radv_link_shaders_info(struct radv_device *device,
+                       struct radv_pipeline_stage *producer, struct radv_pipeline_stage *consumer,
+                       const struct radv_pipeline_key *pipeline_key)
 {
-   if (stages[MESA_SHADER_FRAGMENT].nir) {
-      assert(last_vgt_api_stage != MESA_SHADER_NONE);
-      struct radv_shader_info *pre_ps_info = &stages[last_vgt_api_stage].info;
-      struct radv_vs_output_info *outinfo = &pre_ps_info->outinfo;
-
-      /* Add PS input requirements to the output of the pre-PS stage. */
-      bool ps_prim_id_in = stages[MESA_SHADER_FRAGMENT].info.ps.prim_id_input;
-      bool ps_clip_dists_in = !!stages[MESA_SHADER_FRAGMENT].info.ps.num_input_clips_culls;
-
-      assert(outinfo);
+   /* Export primitive ID or clip/cull distances if necessary. */
+   if (consumer->stage == MESA_SHADER_FRAGMENT) {
+      struct radv_vs_output_info *outinfo = &producer->info.outinfo;
+      const bool ps_prim_id_in = consumer->info.ps.prim_id_input;
+      const bool ps_clip_dists_in = !!consumer->info.ps.num_input_clips_culls;
 
       if (ps_prim_id_in &&
-          (last_vgt_api_stage == MESA_SHADER_VERTEX || last_vgt_api_stage == MESA_SHADER_TESS_EVAL)) {
+          (producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL)) {
          /* Mark the primitive ID as output when it's implicitly exported by VS or TES with NGG. */
          if (outinfo->vs_output_param_offset[VARYING_SLOT_PRIMITIVE_ID] == AC_EXP_PARAM_UNDEFINED)
             outinfo->vs_output_param_offset[VARYING_SLOT_PRIMITIVE_ID] = outinfo->param_exports++;
@@ -1199,94 +1194,111 @@ radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline
       }
 
       if (ps_clip_dists_in) {
-         if (stages[last_vgt_api_stage].nir->info.outputs_written & VARYING_BIT_CLIP_DIST0)
+         if (producer->nir->info.outputs_written & VARYING_BIT_CLIP_DIST0)
             outinfo->vs_output_param_offset[VARYING_SLOT_CLIP_DIST0] = outinfo->param_exports++;
-         if (stages[last_vgt_api_stage].nir->info.outputs_written & VARYING_BIT_CLIP_DIST1)
+         if (producer->nir->info.outputs_written & VARYING_BIT_CLIP_DIST1)
             outinfo->vs_output_param_offset[VARYING_SLOT_CLIP_DIST1] = outinfo->param_exports++;
 
          outinfo->export_clip_dists = true;
       }
    }
 
-   if (stages[MESA_SHADER_TESS_CTRL].nir) {
-      stages[MESA_SHADER_TESS_CTRL].info.tcs.tes_reads_tess_factors =
-         !!(stages[MESA_SHADER_TESS_EVAL].nir->info.inputs_read &
-            (VARYING_BIT_TESS_LEVEL_INNER | VARYING_BIT_TESS_LEVEL_OUTER));
-      stages[MESA_SHADER_TESS_CTRL].info.tcs.tes_inputs_read =
-         stages[MESA_SHADER_TESS_EVAL].nir->info.inputs_read;
-      stages[MESA_SHADER_TESS_CTRL].info.tcs.tes_patch_inputs_read =
-         stages[MESA_SHADER_TESS_EVAL].nir->info.patch_inputs_read;
-
-      stages[MESA_SHADER_TESS_EVAL].info.num_tess_patches =
-         stages[MESA_SHADER_TESS_CTRL].info.num_tess_patches;
-
-      if (!radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
-         /* When the number of TCS input and output vertices are the same (typically 3):
-          * - There is an equal amount of LS and HS invocations
-          * - In case of merged LSHS shaders, the LS and HS halves of the shader
-          *   always process the exact same vertex. We can use this knowledge to optimize them.
-          *
-          * We don't set tcs_in_out_eq if the float controls differ because that might
-          * involve different float modes for the same block and our optimizer
-          * doesn't handle a instruction dominating another with a different mode.
-          */
-         stages[MESA_SHADER_VERTEX].info.vs.tcs_in_out_eq =
-            device->physical_device->rad_info.gfx_level >= GFX9 &&
-            pipeline_key->tcs.tess_input_vertices == stages[MESA_SHADER_TESS_CTRL].info.tcs.tcs_vertices_out &&
-            stages[MESA_SHADER_VERTEX].nir->info.float_controls_execution_mode ==
-               stages[MESA_SHADER_TESS_CTRL].nir->info.float_controls_execution_mode;
-
-         if (stages[MESA_SHADER_VERTEX].info.vs.tcs_in_out_eq)
-            stages[MESA_SHADER_VERTEX].info.vs.tcs_temp_only_input_mask =
-               stages[MESA_SHADER_TESS_CTRL].nir->info.inputs_read &
-               stages[MESA_SHADER_VERTEX].nir->info.outputs_written &
-               ~stages[MESA_SHADER_TESS_CTRL].nir->info.tess.tcs_cross_invocation_inputs_read &
-               ~stages[MESA_SHADER_TESS_CTRL].nir->info.inputs_read_indirectly &
-               ~stages[MESA_SHADER_VERTEX].nir->info.outputs_accessed_indirectly;
-
-         /* Copy data to TCS so it can be accessed by the backend if they are merged. */
-         stages[MESA_SHADER_TESS_CTRL].info.vs.tcs_in_out_eq =
-            stages[MESA_SHADER_VERTEX].info.vs.tcs_in_out_eq;
-         stages[MESA_SHADER_TESS_CTRL].info.vs.tcs_temp_only_input_mask =
-            stages[MESA_SHADER_VERTEX].info.vs.tcs_temp_only_input_mask;
+   if (producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL) {
+      if (consumer->stage == MESA_SHADER_GEOMETRY) {
+         /* Compute the ESGS item size for VS or TES as ES. */
+         uint32_t num_outputs_written = producer->stage == MESA_SHADER_TESS_EVAL
+            ? producer->info.tes.num_linked_outputs : producer->info.vs.num_linked_outputs;
+         producer->info.esgs_itemsize = num_outputs_written * 16;
       }
-   }
 
-   /* Compute the ESGS item size for VS or TES as ES. */
-   if ((stages[MESA_SHADER_VERTEX].nir && stages[MESA_SHADER_VERTEX].info.vs.as_es) ||
-       (stages[MESA_SHADER_TESS_EVAL].nir && stages[MESA_SHADER_TESS_EVAL].info.tes.as_es)) {
-      uint32_t num_outputs_written;
-      gl_shader_stage es_stage;
+      /* Compute NGG info (GFX10+) or GS info. */
+      if (producer->info.is_ngg) {
+         struct radv_pipeline_stage *gs_stage =
+            consumer->stage == MESA_SHADER_GEOMETRY ? consumer : NULL;
 
-      if (stages[MESA_SHADER_TESS_EVAL].nir) {
-         es_stage = MESA_SHADER_TESS_EVAL;
-         num_outputs_written = stages[MESA_SHADER_TESS_EVAL].info.tes.num_linked_outputs;
-      } else {
-         es_stage = MESA_SHADER_VERTEX;
-         num_outputs_written = stages[MESA_SHADER_VERTEX].info.vs.num_linked_outputs;
+         gfx10_get_ngg_info(device, producer, gs_stage);
+      } else if (consumer->stage == MESA_SHADER_GEOMETRY) {
+         gfx9_get_gs_info(device, producer, consumer);
       }
+   }
+
+   if (producer->stage == MESA_SHADER_VERTEX && consumer->stage == MESA_SHADER_TESS_CTRL &&
+       !radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
+      struct radv_pipeline_stage *vs_stage = producer;
+      struct radv_pipeline_stage *tcs_stage = consumer;
+
+      /* When the number of TCS input and output vertices are the same (typically 3):
+       * - There is an equal amount of LS and HS invocations
+       * - In case of merged LSHS shaders, the LS and HS halves of the shader always process the
+       *   exact same vertex. We can use this knowledge to optimize them.
+       *
+       * We don't set tcs_in_out_eq if the float controls differ because that might involve
+       * different float modes for the same block and our optimizer doesn't handle a instruction
+       * dominating another with a different mode.
+       */
+      vs_stage->info.vs.tcs_in_out_eq =
+         device->physical_device->rad_info.gfx_level >= GFX9 &&
+         pipeline_key->tcs.tess_input_vertices == tcs_stage->info.tcs.tcs_vertices_out &&
+         vs_stage->nir->info.float_controls_execution_mode ==
+            tcs_stage->nir->info.float_controls_execution_mode;
+
+      if (vs_stage->info.vs.tcs_in_out_eq)
+         vs_stage->info.vs.tcs_temp_only_input_mask =
+            tcs_stage->nir->info.inputs_read &
+            vs_stage->nir->info.outputs_written &
+            ~tcs_stage->nir->info.tess.tcs_cross_invocation_inputs_read &
+            ~tcs_stage->nir->info.inputs_read_indirectly &
+            ~vs_stage->nir->info.outputs_accessed_indirectly;
+
+      /* Copy data to TCS so it can be accessed by the backend if they are merged. */
+      tcs_stage->info.vs.tcs_in_out_eq =
+         vs_stage->info.vs.tcs_in_out_eq;
+      tcs_stage->info.vs.tcs_temp_only_input_mask =
+         vs_stage->info.vs.tcs_temp_only_input_mask;
+   }
+
+   /* Copy shader info between TCS<->TES. */
+   if (producer->stage == MESA_SHADER_TESS_CTRL) {
+      struct radv_pipeline_stage *tcs_stage = producer;
+      struct radv_pipeline_stage *tes_stage = consumer;
 
-      stages[es_stage].info.esgs_itemsize = num_outputs_written * 16;
+      tcs_stage->info.tcs.tes_reads_tess_factors =
+         !!(tes_stage->nir->info.inputs_read & (VARYING_BIT_TESS_LEVEL_INNER | VARYING_BIT_TESS_LEVEL_OUTER));
+      tcs_stage->info.tcs.tes_inputs_read = tes_stage->nir->info.inputs_read;
+      tcs_stage->info.tcs.tes_patch_inputs_read = tes_stage->nir->info.patch_inputs_read;
+
+      tes_stage->info.num_tess_patches = tcs_stage->info.num_tess_patches;
    }
 
-   if (stages[MESA_SHADER_TASK].nir) {
-      /* Task/mesh I/O uses the task ring buffers. */
-      stages[MESA_SHADER_MESH].info.ms.has_task = true;
+   /* Task/mesh I/O uses the task ring buffers. */
+   if (producer->stage == MESA_SHADER_TASK) {
+      consumer->info.ms.has_task = true;
    }
+}
 
-   if (pipeline_has_ngg) {
-      if (last_vgt_api_stage != MESA_SHADER_MESH) {
-         struct radv_pipeline_stage *es_stage =
-            stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
-         struct radv_pipeline_stage *gs_stage =
-            stages[MESA_SHADER_GEOMETRY].nir ? &stages[MESA_SHADER_GEOMETRY] : NULL;
+static const gl_shader_stage graphics_shader_order[] = {
+   MESA_SHADER_VERTEX,
+   MESA_SHADER_TESS_CTRL,
+   MESA_SHADER_TESS_EVAL,
+   MESA_SHADER_GEOMETRY,
 
-         gfx10_get_ngg_info(device, es_stage, gs_stage);
-      }
-   } else if (stages[MESA_SHADER_GEOMETRY].nir) {
-      struct radv_pipeline_stage *es_stage =
-         stages[MESA_SHADER_TESS_EVAL].nir ? &stages[MESA_SHADER_TESS_EVAL] : &stages[MESA_SHADER_VERTEX];
+   MESA_SHADER_TASK,
+   MESA_SHADER_MESH,
+};
 
-      gfx9_get_gs_info(device, es_stage, &stages[MESA_SHADER_GEOMETRY]);
+void
+radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline_key *pipeline_key,
+                          struct radv_pipeline_stage *stages, bool pipeline_has_ngg,
+                          gl_shader_stage last_vgt_api_stage)
+{
+   /* Walk backwards to link */
+   struct radv_pipeline_stage *next_stage = &stages[MESA_SHADER_FRAGMENT];
+   for (int i = ARRAY_SIZE(graphics_shader_order) - 1; i >= 0; i--) {
+      gl_shader_stage s = graphics_shader_order[i];
+      if (!stages[s].nir)
+         continue;
+
+      radv_link_shaders_info(device, &stages[s], next_stage, pipeline_key);
+      next_stage = &stages[s];
    }
 }
-- 
GitLab


From bb19829478abb992bdf41dc7860dba53e83606c1 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 13:05:23 +0200
Subject: [PATCH 10/16] radv: move determining other NGG settings in
 radv_link_shaders_info()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

At least, everything is at the same place now.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 51 ------------------------------
 src/amd/vulkan/radv_shader_info.c | 52 +++++++++++++++++++++++++++++++
 2 files changed, 52 insertions(+), 51 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 7b54de513b1d..d253ad317268 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2741,55 +2741,6 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
    return key;
 }
 
-static void
-radv_determine_ngg_settings(struct radv_pipeline *pipeline,
-                            const struct radv_pipeline_key *pipeline_key,
-                            struct radv_pipeline_stage *stages,
-                            gl_shader_stage last_vgt_api_stage)
-{
-   const struct radv_physical_device *pdevice = pipeline->device->physical_device;
-
-   /* Shader settings for VS or TES without GS. */
-   if (last_vgt_api_stage == MESA_SHADER_VERTEX ||
-       last_vgt_api_stage == MESA_SHADER_TESS_EVAL) {
-      uint64_t ps_inputs_read =
-         stages[MESA_SHADER_FRAGMENT].nir ? stages[MESA_SHADER_FRAGMENT].nir->info.inputs_read : 0;
-      gl_shader_stage es_stage = last_vgt_api_stage;
-
-      unsigned num_vertices_per_prim = si_conv_prim_to_gs_out(pipeline_key->vs.topology) + 1;
-      if (es_stage == MESA_SHADER_TESS_EVAL)
-         num_vertices_per_prim = stages[es_stage].nir->info.tess.point_mode                      ? 1
-                                 : stages[es_stage].nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES ? 2
-                                                                                          : 3;
-      /* TODO: Enable culling for LLVM. */
-      stages[es_stage].info.has_ngg_culling = radv_consider_culling(
-         pdevice, stages[es_stage].nir, ps_inputs_read, num_vertices_per_prim, &stages[es_stage].info) &&
-         !radv_use_llvm_for_stage(pipeline->device, es_stage);
-
-      nir_function_impl *impl = nir_shader_get_entrypoint(stages[es_stage].nir);
-      stages[es_stage].info.has_ngg_early_prim_export = exec_list_is_singular(&impl->body);
-
-      /* Invocations that process an input vertex */
-      const struct gfx10_ngg_info *ngg_info = &stages[es_stage].info.ngg_info;
-      unsigned max_vtx_in = MIN2(256, ngg_info->enable_vertex_grouping ? ngg_info->hw_max_esverts : num_vertices_per_prim * ngg_info->max_gsprims);
-
-      unsigned lds_bytes_if_culling_off = 0;
-      /* We need LDS space when VS needs to export the primitive ID. */
-      if (es_stage == MESA_SHADER_VERTEX && stages[es_stage].info.outinfo.export_prim_id)
-         lds_bytes_if_culling_off = max_vtx_in * 4u;
-      stages[es_stage].info.num_lds_blocks_when_not_culling =
-         DIV_ROUND_UP(lds_bytes_if_culling_off, pdevice->rad_info.lds_encode_granularity);
-
-      /* NGG passthrough mode should be disabled when culling and when the vertex shader exports the
-       * primitive ID.
-       */
-      stages[es_stage].info.is_ngg_passthrough = stages[es_stage].info.is_ngg_passthrough &&
-                                                !stages[es_stage].info.has_ngg_culling &&
-                                                 !(es_stage == MESA_SHADER_VERTEX &&
-                                                   stages[es_stage].info.outinfo.export_prim_id);
-   }
-}
-
 static void
 radv_fill_shader_info_ngg(struct radv_pipeline *pipeline,
                           const struct radv_pipeline_key *pipeline_key,
@@ -2989,8 +2940,6 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
          stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
       stages[hw_vs_api_stage].info.workgroup_size = stages[hw_vs_api_stage].info.wave_size;
    }
-
-   radv_determine_ngg_settings(pipeline, pipeline_key, stages, last_vgt_api_stage);
 }
 
 static void
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 266f04023df1..77f70f686215 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1173,6 +1173,53 @@ gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage
    es_info->workgroup_size = workgroup_size;
 }
 
+static void
+radv_determine_ngg_settings(struct radv_device *device, struct radv_pipeline_stage *es_stage,
+                            struct radv_pipeline_stage *fs_stage,
+                            const struct radv_pipeline_key *pipeline_key)
+{
+   assert(es_stage->stage == MESA_SHADER_VERTEX || es_stage->stage == MESA_SHADER_TESS_EVAL);
+   assert(fs_stage->stage == MESA_SHADER_FRAGMENT);
+
+   uint64_t ps_inputs_read = fs_stage->nir->info.inputs_read;
+
+   unsigned num_vertices_per_prim = si_conv_prim_to_gs_out(pipeline_key->vs.topology) + 1;
+   if (es_stage->stage == MESA_SHADER_TESS_EVAL) {
+      num_vertices_per_prim = es_stage->nir->info.tess.point_mode ? 1 :
+         es_stage->nir->info.tess._primitive_mode == TESS_PRIMITIVE_ISOLINES ? 2 : 3;
+   }
+
+   /* TODO: Enable culling for LLVM. */
+   es_stage->info.has_ngg_culling =
+      radv_consider_culling(device->physical_device, es_stage->nir, ps_inputs_read,
+                            num_vertices_per_prim, &es_stage->info) &&
+      !radv_use_llvm_for_stage(device, es_stage->stage);
+
+   nir_function_impl *impl = nir_shader_get_entrypoint(es_stage->nir);
+   es_stage->info.has_ngg_early_prim_export = exec_list_is_singular(&impl->body);
+
+   /* Invocations that process an input vertex */
+   const struct gfx10_ngg_info *ngg_info = &es_stage->info.ngg_info;
+   unsigned max_vtx_in = MIN2(256, ngg_info->enable_vertex_grouping ?
+         ngg_info->hw_max_esverts : num_vertices_per_prim * ngg_info->max_gsprims);
+
+   unsigned lds_bytes_if_culling_off = 0;
+   /* We need LDS space when VS needs to export the primitive ID. */
+   if (es_stage->stage == MESA_SHADER_VERTEX && es_stage->info.outinfo.export_prim_id)
+      lds_bytes_if_culling_off = max_vtx_in * 4u;
+
+   es_stage->info.num_lds_blocks_when_not_culling =
+      DIV_ROUND_UP(lds_bytes_if_culling_off,
+                   device->physical_device->rad_info.lds_encode_granularity);
+
+   /* NGG passthrough mode should be disabled when culling and when the vertex shader
+    * exports the primitive ID.
+    */
+   es_stage->info.is_ngg_passthrough = es_stage->info.is_ngg_passthrough &&
+      !es_stage->info.has_ngg_culling && !(es_stage->stage == MESA_SHADER_VERTEX &&
+                                           es_stage->info.outinfo.export_prim_id);
+}
+
 static void
 radv_link_shaders_info(struct radv_device *device,
                        struct radv_pipeline_stage *producer, struct radv_pipeline_stage *consumer,
@@ -1217,6 +1264,11 @@ radv_link_shaders_info(struct radv_device *device,
             consumer->stage == MESA_SHADER_GEOMETRY ? consumer : NULL;
 
          gfx10_get_ngg_info(device, producer, gs_stage);
+
+         /* Determine other NGG settings like culling for VS or TES without GS. */
+         if (!gs_stage) {
+            radv_determine_ngg_settings(device, producer, consumer, pipeline_key);
+         }
       } else if (consumer->stage == MESA_SHADER_GEOMETRY) {
          gfx9_get_gs_info(device, producer, consumer);
       }
-- 
GitLab


From 4910e07e173b432d4a227aec1e16877b5f49f1af Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 13:36:34 +0200
Subject: [PATCH 11/16] radv: simplify determining if NGG passthrough can be
 enabled
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

NGG can't be enabled with XFB, so this check is redundant now.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 13 -------------
 src/amd/vulkan/radv_shader_info.c |  5 ++---
 2 files changed, 2 insertions(+), 16 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index d253ad317268..2b4c78564f1d 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2791,19 +2791,6 @@ radv_fill_shader_info_ngg(struct radv_pipeline *pipeline,
          else
            stages[MESA_SHADER_VERTEX].info.is_ngg = false;
       }
-
-      /* Determine if the pipeline is eligible for the NGG passthrough
-       * mode. It can't be enabled for geometry shaders, for NGG
-       * streamout or for vertex shaders that export the primitive ID
-       * (this is checked later because we don't have the info here.)
-       */
-      if (!stages[MESA_SHADER_GEOMETRY].nir && !uses_xfb) {
-         if (stages[MESA_SHADER_TESS_CTRL].nir && stages[MESA_SHADER_TESS_EVAL].info.is_ngg) {
-            stages[MESA_SHADER_TESS_EVAL].info.is_ngg_passthrough = true;
-         } else if (stages[MESA_SHADER_VERTEX].nir && stages[MESA_SHADER_VERTEX].info.is_ngg) {
-            stages[MESA_SHADER_VERTEX].info.is_ngg_passthrough = true;
-         }
-      }
    }
 }
 
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 77f70f686215..e69b2ce56415 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1215,9 +1215,8 @@ radv_determine_ngg_settings(struct radv_device *device, struct radv_pipeline_sta
    /* NGG passthrough mode should be disabled when culling and when the vertex shader
     * exports the primitive ID.
     */
-   es_stage->info.is_ngg_passthrough = es_stage->info.is_ngg_passthrough &&
-      !es_stage->info.has_ngg_culling && !(es_stage->stage == MESA_SHADER_VERTEX &&
-                                           es_stage->info.outinfo.export_prim_id);
+   es_stage->info.is_ngg_passthrough = !es_stage->info.has_ngg_culling &&
+      !(es_stage->stage == MESA_SHADER_VERTEX && es_stage->info.outinfo.export_prim_id);
 }
 
 static void
-- 
GitLab


From 7d37afad9ebeeb43de79c20177f37e096fc88b3e Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 14:18:33 +0200
Subject: [PATCH 12/16] radv: cleanup computing the workgroup size for all
 stages
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 35 ------------
 src/amd/vulkan/radv_shader_info.c | 90 ++++++++++++++++++++-----------
 2 files changed, 60 insertions(+), 65 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 2b4c78564f1d..0f915f3e4017 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2892,41 +2892,6 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
    }
 
    radv_nir_shader_info_link(device, pipeline_key, stages, pipeline_has_ngg, last_vgt_api_stage);
-
-   if (stages[MESA_SHADER_TESS_CTRL].nir) {
-      for (gl_shader_stage s = MESA_SHADER_VERTEX; s <= MESA_SHADER_TESS_CTRL; ++s) {
-         stages[s].info.workgroup_size =
-            ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level, s,
-                                           stages[MESA_SHADER_TESS_CTRL].info.num_tess_patches,
-                                           pipeline_key->tcs.tess_input_vertices,
-                                           stages[MESA_SHADER_TESS_CTRL].info.tcs.tcs_vertices_out);
-      }
-   }
-
-   /* PS always operates without workgroups. */
-   if (stages[MESA_SHADER_FRAGMENT].nir)
-      stages[MESA_SHADER_FRAGMENT].info.workgroup_size = stages[MESA_SHADER_FRAGMENT].info.wave_size;
-
-   if (stages[MESA_SHADER_COMPUTE].nir) {
-      /* Variable workgroup size is not supported by Vulkan. */
-      assert(!stages[MESA_SHADER_COMPUTE].nir->info.workgroup_size_variable);
-
-      stages[MESA_SHADER_COMPUTE].info.workgroup_size =
-         ac_compute_cs_workgroup_size(
-            stages[MESA_SHADER_COMPUTE].nir->info.workgroup_size, false, UINT32_MAX);
-   }
-
-   if (stages[MESA_SHADER_TASK].nir) {
-      stages[MESA_SHADER_TASK].info.workgroup_size =
-         ac_compute_cs_workgroup_size(
-            stages[MESA_SHADER_TASK].nir->info.workgroup_size, false, UINT32_MAX);
-   }
-
-   if (!pipeline_has_ngg && !stages[MESA_SHADER_GEOMETRY].nir) {
-      gl_shader_stage hw_vs_api_stage =
-         stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
-      stages[hw_vs_api_stage].info.workgroup_size = stages[hw_vs_api_stage].info.wave_size;
-   }
 }
 
 static void
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index e69b2ce56415..383b4894edd9 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -796,6 +796,23 @@ radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *n
 
    info->wave_size = radv_get_wave_size(device, nir->info.stage, info);
    info->ballot_bit_size = radv_get_ballot_bit_size(device, nir->info.stage, info);
+
+   switch (nir->info.stage) {
+   case MESA_SHADER_COMPUTE:
+   case MESA_SHADER_TASK:
+      info->workgroup_size =
+         ac_compute_cs_workgroup_size(nir->info.workgroup_size, false, UINT32_MAX);
+      break;
+   case MESA_SHADER_MESH:
+      /* Already computed in gather_shader_info_mesh(). */
+      break;
+   default:
+      /* FS always operates without workgroups. Other stages are computed during linking but assume
+       * no workgroups by default.
+       */
+      info->workgroup_size = info->wave_size;
+      break;
+   }
 }
 
 static void
@@ -1273,39 +1290,52 @@ radv_link_shaders_info(struct radv_device *device,
       }
    }
 
-   if (producer->stage == MESA_SHADER_VERTEX && consumer->stage == MESA_SHADER_TESS_CTRL &&
-       !radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
+   if (producer->stage == MESA_SHADER_VERTEX && consumer->stage == MESA_SHADER_TESS_CTRL) {
       struct radv_pipeline_stage *vs_stage = producer;
       struct radv_pipeline_stage *tcs_stage = consumer;
 
-      /* When the number of TCS input and output vertices are the same (typically 3):
-       * - There is an equal amount of LS and HS invocations
-       * - In case of merged LSHS shaders, the LS and HS halves of the shader always process the
-       *   exact same vertex. We can use this knowledge to optimize them.
-       *
-       * We don't set tcs_in_out_eq if the float controls differ because that might involve
-       * different float modes for the same block and our optimizer doesn't handle a instruction
-       * dominating another with a different mode.
-       */
-      vs_stage->info.vs.tcs_in_out_eq =
-         device->physical_device->rad_info.gfx_level >= GFX9 &&
-         pipeline_key->tcs.tess_input_vertices == tcs_stage->info.tcs.tcs_vertices_out &&
-         vs_stage->nir->info.float_controls_execution_mode ==
-            tcs_stage->nir->info.float_controls_execution_mode;
-
-      if (vs_stage->info.vs.tcs_in_out_eq)
-         vs_stage->info.vs.tcs_temp_only_input_mask =
-            tcs_stage->nir->info.inputs_read &
-            vs_stage->nir->info.outputs_written &
-            ~tcs_stage->nir->info.tess.tcs_cross_invocation_inputs_read &
-            ~tcs_stage->nir->info.inputs_read_indirectly &
-            ~vs_stage->nir->info.outputs_accessed_indirectly;
-
-      /* Copy data to TCS so it can be accessed by the backend if they are merged. */
-      tcs_stage->info.vs.tcs_in_out_eq =
-         vs_stage->info.vs.tcs_in_out_eq;
-      tcs_stage->info.vs.tcs_temp_only_input_mask =
-         vs_stage->info.vs.tcs_temp_only_input_mask;
+      vs_stage->info.workgroup_size =
+         ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
+                                        MESA_SHADER_VERTEX, tcs_stage->info.num_tess_patches,
+                                        pipeline_key->tcs.tess_input_vertices,
+                                        tcs_stage->info.tcs.tcs_vertices_out);
+
+      tcs_stage->info.workgroup_size =
+         ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
+                                        MESA_SHADER_TESS_CTRL, tcs_stage->info.num_tess_patches,
+                                        pipeline_key->tcs.tess_input_vertices,
+                                        tcs_stage->info.tcs.tcs_vertices_out);
+
+      if (!radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
+         /* When the number of TCS input and output vertices are the same (typically 3):
+          * - There is an equal amount of LS and HS invocations
+          * - In case of merged LSHS shaders, the LS and HS halves of the shader always process the
+          *   exact same vertex. We can use this knowledge to optimize them.
+          *
+          * We don't set tcs_in_out_eq if the float controls differ because that might involve
+          * different float modes for the same block and our optimizer doesn't handle a instruction
+          * dominating another with a different mode.
+          */
+         vs_stage->info.vs.tcs_in_out_eq =
+            device->physical_device->rad_info.gfx_level >= GFX9 &&
+            pipeline_key->tcs.tess_input_vertices == tcs_stage->info.tcs.tcs_vertices_out &&
+            vs_stage->nir->info.float_controls_execution_mode ==
+               tcs_stage->nir->info.float_controls_execution_mode;
+
+         if (vs_stage->info.vs.tcs_in_out_eq)
+            vs_stage->info.vs.tcs_temp_only_input_mask =
+               tcs_stage->nir->info.inputs_read &
+               vs_stage->nir->info.outputs_written &
+               ~tcs_stage->nir->info.tess.tcs_cross_invocation_inputs_read &
+               ~tcs_stage->nir->info.inputs_read_indirectly &
+               ~vs_stage->nir->info.outputs_accessed_indirectly;
+
+         /* Copy data to TCS so it can be accessed by the backend if they are merged. */
+         tcs_stage->info.vs.tcs_in_out_eq =
+            vs_stage->info.vs.tcs_in_out_eq;
+         tcs_stage->info.vs.tcs_temp_only_input_mask =
+            vs_stage->info.vs.tcs_temp_only_input_mask;
+      }
    }
 
    /* Copy shader info between TCS<->TES. */
-- 
GitLab


From 71d35efdf559137b35eaacd4b4b1de7ed8ffa003 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 23 Aug 2022 16:28:05 +0200
Subject: [PATCH 13/16] radv: add and use a helper that merges shader info for
 merged stages on GFX9+
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It looks much cleaner and it's pretty small.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 73 ++-----------------------------
 src/amd/vulkan/radv_shader_info.c | 54 ++++++++++++++++++++---
 2 files changed, 51 insertions(+), 76 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 0f915f3e4017..3054cc397d6a 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2803,13 +2803,6 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
                       bool pipeline_has_ngg)
 {
    struct radv_device *device = pipeline->device;
-   unsigned active_stages = 0;
-   unsigned filled_stages = 0;
-
-   for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; i++) {
-      if (stages[i].nir)
-         active_stages |= (1 << i);
-   }
 
    if (stages[MESA_SHADER_TESS_CTRL].nir) {
       stages[MESA_SHADER_VERTEX].info.vs.as_ls = true;
@@ -2822,70 +2815,10 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
          stages[MESA_SHADER_VERTEX].info.vs.as_es = true;
    }
 
-   if (device->physical_device->rad_info.gfx_level >= GFX9 &&
-       stages[MESA_SHADER_TESS_CTRL].nir) {
-      struct nir_shader *combined_nir[] = {stages[MESA_SHADER_VERTEX].nir, stages[MESA_SHADER_TESS_CTRL].nir};
-
-      radv_nir_shader_info_init(&stages[MESA_SHADER_TESS_CTRL].info);
-
-      /* Copy data to merged stage. */
-      stages[MESA_SHADER_TESS_CTRL].info.vs.num_linked_outputs =
-            stages[MESA_SHADER_VERTEX].info.vs.num_linked_outputs;
-
-      for (int i = 0; i < 2; i++) {
-         radv_nir_shader_info_pass(device, combined_nir[i], pipeline_layout, pipeline_key,
-                                   &stages[MESA_SHADER_TESS_CTRL].info);
-      }
-
-      stages[MESA_SHADER_VERTEX].info = stages[MESA_SHADER_TESS_CTRL].info;
-      stages[MESA_SHADER_VERTEX].info.vs.as_ls = true;
-
-      filled_stages |= (1 << MESA_SHADER_VERTEX);
-      filled_stages |= (1 << MESA_SHADER_TESS_CTRL);
-   }
-
-   if (device->physical_device->rad_info.gfx_level >= GFX9 &&
-       stages[MESA_SHADER_GEOMETRY].nir) {
-      gl_shader_stage pre_stage =
-         stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
-      struct nir_shader *combined_nir[] = {stages[pre_stage].nir, stages[MESA_SHADER_GEOMETRY].nir};
-
-      radv_nir_shader_info_init(&stages[MESA_SHADER_GEOMETRY].info);
-
-      /* Copy data to merged stage. */
-      if (pre_stage == MESA_SHADER_VERTEX) {
-         stages[MESA_SHADER_GEOMETRY].info.vs.num_linked_outputs =
-            stages[MESA_SHADER_VERTEX].info.vs.num_linked_outputs;
-      } else {
-         stages[MESA_SHADER_GEOMETRY].info.tes.num_linked_outputs =
-            stages[MESA_SHADER_TESS_EVAL].info.tes.num_linked_outputs;
-         stages[MESA_SHADER_GEOMETRY].info.tes.num_linked_inputs =
-            stages[MESA_SHADER_TESS_EVAL].info.tes.num_linked_inputs;
-         stages[MESA_SHADER_GEOMETRY].info.tes.num_linked_patch_inputs =
-            stages[MESA_SHADER_TESS_EVAL].info.tes.num_linked_patch_inputs;
-      }
-      stages[MESA_SHADER_GEOMETRY].info.is_ngg = stages[pre_stage].info.is_ngg;
-      stages[MESA_SHADER_GEOMETRY].info.gs.es_type = pre_stage;
-
-      for (int i = 0; i < 2; i++) {
-         radv_nir_shader_info_pass(device, combined_nir[i], pipeline_layout, pipeline_key,
-                                   &stages[MESA_SHADER_GEOMETRY].info);
-      }
-
-      stages[pre_stage].info = stages[MESA_SHADER_GEOMETRY].info;
-      if (pre_stage == MESA_SHADER_VERTEX) {
-         stages[MESA_SHADER_VERTEX].info.vs.as_es = true;
-      } else {
-         stages[MESA_SHADER_TESS_EVAL].info.tes.as_es = true;
-      }
-
-      filled_stages |= (1 << pre_stage);
-      filled_stages |= (1 << MESA_SHADER_GEOMETRY);
-   }
+   for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; i++) {
+      if (!stages[i].nir)
+         continue;
 
-   active_stages ^= filled_stages;
-   while (active_stages) {
-      int i = u_bit_scan(&active_stages);
       radv_nir_shader_info_init(&stages[i].info);
       radv_nir_shader_info_pass(device, stages[i].nir, pipeline_layout, pipeline_key,
                                 &stages[i].info);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 383b4894edd9..eda4201f7c3a 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1329,12 +1329,6 @@ radv_link_shaders_info(struct radv_device *device,
                ~tcs_stage->nir->info.tess.tcs_cross_invocation_inputs_read &
                ~tcs_stage->nir->info.inputs_read_indirectly &
                ~vs_stage->nir->info.outputs_accessed_indirectly;
-
-         /* Copy data to TCS so it can be accessed by the backend if they are merged. */
-         tcs_stage->info.vs.tcs_in_out_eq =
-            vs_stage->info.vs.tcs_in_out_eq;
-         tcs_stage->info.vs.tcs_temp_only_input_mask =
-            vs_stage->info.vs.tcs_temp_only_input_mask;
       }
    }
 
@@ -1357,6 +1351,39 @@ radv_link_shaders_info(struct radv_device *device,
    }
 }
 
+static void
+radv_nir_shader_info_merge(const struct radv_pipeline_stage *src, struct radv_pipeline_stage *dst)
+{
+   const struct radv_shader_info *src_info = &src->info;
+   struct radv_shader_info *dst_info = &dst->info;
+
+   assert((src->stage == MESA_SHADER_VERTEX && dst->stage == MESA_SHADER_TESS_CTRL) ||
+          (src->stage == MESA_SHADER_VERTEX && dst->stage == MESA_SHADER_GEOMETRY) ||
+          (src->stage == MESA_SHADER_TESS_EVAL && dst->stage == MESA_SHADER_GEOMETRY));
+
+   dst_info->loads_push_constants |= src_info->loads_push_constants;
+   dst_info->loads_dynamic_offsets |= src_info->loads_dynamic_offsets;
+   dst_info->desc_set_used_mask |= src_info->desc_set_used_mask;
+   dst_info->uses_view_index |= src_info->uses_view_index;
+   dst_info->uses_invocation_id |= src_info->uses_invocation_id;
+   dst_info->uses_prim_id |= src_info->uses_prim_id;
+   dst_info->inline_push_constant_mask |= src_info->inline_push_constant_mask;
+
+   /* Only inline all push constants if both allows it. */
+   dst_info->can_inline_all_push_constants &= src_info->can_inline_all_push_constants;
+
+   if (src->stage == MESA_SHADER_VERTEX) {
+      dst_info->vs = src_info->vs;
+   } else {
+      dst_info->tes = src_info->tes;
+   }
+
+   if (dst->stage == MESA_SHADER_GEOMETRY) {
+      dst_info->is_ngg = src_info->is_ngg;
+      dst_info->gs.es_type = src->stage;
+   }
+}
+
 static const gl_shader_stage graphics_shader_order[] = {
    MESA_SHADER_VERTEX,
    MESA_SHADER_TESS_CTRL,
@@ -1382,4 +1409,19 @@ radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline
       radv_link_shaders_info(device, &stages[s], next_stage, pipeline_key);
       next_stage = &stages[s];
    }
+
+   if (device->physical_device->rad_info.gfx_level >= GFX9) {
+      /* Merge shader info for VS+TCS. */
+      if (stages[MESA_SHADER_TESS_CTRL].nir) {
+         radv_nir_shader_info_merge(&stages[MESA_SHADER_VERTEX], &stages[MESA_SHADER_TESS_CTRL]);
+      }
+
+      /* Merge shader info for VS+GS or TES+GS. */
+      if (stages[MESA_SHADER_GEOMETRY].nir) {
+         gl_shader_stage pre_stage =
+            stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
+
+         radv_nir_shader_info_merge(&stages[pre_stage], &stages[MESA_SHADER_GEOMETRY]);
+      }
+   }
 }
-- 
GitLab


From ba89d62de46b5585ff7726a2353913dc80fcb1db Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 14:37:30 +0200
Subject: [PATCH 14/16] radv: remove unused parameters in
 radv_fill_shader_info()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 9 +++------
 src/amd/vulkan/radv_private.h     | 3 +--
 src/amd/vulkan/radv_shader_info.c | 3 +--
 3 files changed, 5 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 3054cc397d6a..da24e3c8126e 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2798,9 +2798,7 @@ static void
 radv_fill_shader_info(struct radv_pipeline *pipeline,
                       struct radv_pipeline_layout *pipeline_layout,
                       const struct radv_pipeline_key *pipeline_key,
-                      struct radv_pipeline_stage *stages,
-                      gl_shader_stage last_vgt_api_stage,
-                      bool pipeline_has_ngg)
+                      struct radv_pipeline_stage *stages)
 {
    struct radv_device *device = pipeline->device;
 
@@ -2824,7 +2822,7 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
                                 &stages[i].info);
    }
 
-   radv_nir_shader_info_link(device, pipeline_key, stages, pipeline_has_ngg, last_vgt_api_stage);
+   radv_nir_shader_info_link(device, pipeline_key, stages);
 }
 
 static void
@@ -3978,8 +3976,7 @@ radv_create_shaders(struct radv_pipeline *pipeline, struct radv_pipeline_layout
       NIR_PASS(_, stages[MESA_SHADER_FRAGMENT].nir, radv_lower_fs_output, pipeline_key);
    }
 
-   radv_fill_shader_info(pipeline, pipeline_layout, pipeline_key, stages, *last_vgt_api_stage,
-                         pipeline_has_ngg);
+   radv_fill_shader_info(pipeline, pipeline_layout, pipeline_key, stages);
 
    radv_declare_pipeline_args(device, stages, pipeline_key);
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 1be1efc81c8d..a4f1246e73dc 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2793,8 +2793,7 @@ void radv_nir_shader_info_init(struct radv_shader_info *info);
 
 void radv_nir_shader_info_link(struct radv_device *device,
                                const struct radv_pipeline_key *pipeline_key,
-                               struct radv_pipeline_stage *stages, bool pipeline_has_ngg,
-                               gl_shader_stage last_vgt_api_stage);
+                               struct radv_pipeline_stage *stages);
 
 bool radv_thread_trace_init(struct radv_device *device);
 void radv_thread_trace_finish(struct radv_device *device);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index eda4201f7c3a..768e872572a6 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1396,8 +1396,7 @@ static const gl_shader_stage graphics_shader_order[] = {
 
 void
 radv_nir_shader_info_link(struct radv_device *device, const struct radv_pipeline_key *pipeline_key,
-                          struct radv_pipeline_stage *stages, bool pipeline_has_ngg,
-                          gl_shader_stage last_vgt_api_stage)
+                          struct radv_pipeline_stage *stages)
 {
    /* Walk backwards to link */
    struct radv_pipeline_stage *next_stage = &stages[MESA_SHADER_FRAGMENT];
-- 
GitLab


From 1af3d0916a497ed31b9e0d152c5ca9ecaf649452 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 14:42:05 +0200
Subject: [PATCH 15/16] radv: determine as_ls/as_es in radv_link_shaders_info()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is a link shader info step somehow.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 11 -----------
 src/amd/vulkan/radv_shader_info.c | 14 ++++++++++++--
 2 files changed, 12 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index da24e3c8126e..12adc9031594 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2802,17 +2802,6 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
 {
    struct radv_device *device = pipeline->device;
 
-   if (stages[MESA_SHADER_TESS_CTRL].nir) {
-      stages[MESA_SHADER_VERTEX].info.vs.as_ls = true;
-   }
-
-   if (stages[MESA_SHADER_GEOMETRY].nir) {
-      if (stages[MESA_SHADER_TESS_CTRL].nir)
-         stages[MESA_SHADER_TESS_EVAL].info.tes.as_es = true;
-      else
-         stages[MESA_SHADER_VERTEX].info.vs.as_es = true;
-   }
-
    for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; i++) {
       if (!stages[i].nir)
          continue;
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 768e872572a6..d61d4399e6c0 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1268,9 +1268,17 @@ radv_link_shaders_info(struct radv_device *device,
 
    if (producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL) {
       if (consumer->stage == MESA_SHADER_GEOMETRY) {
+         uint32_t num_outputs_written;
+
+         if (producer->stage == MESA_SHADER_TESS_EVAL) {
+            num_outputs_written = producer->info.tes.num_linked_outputs;
+            producer->info.tes.as_es = true;
+         } else {
+            num_outputs_written = producer->info.vs.num_linked_outputs;
+            producer->info.vs.as_es = true;
+         }
+
          /* Compute the ESGS item size for VS or TES as ES. */
-         uint32_t num_outputs_written = producer->stage == MESA_SHADER_TESS_EVAL
-            ? producer->info.tes.num_linked_outputs : producer->info.vs.num_linked_outputs;
          producer->info.esgs_itemsize = num_outputs_written * 16;
       }
 
@@ -1294,6 +1302,8 @@ radv_link_shaders_info(struct radv_device *device,
       struct radv_pipeline_stage *vs_stage = producer;
       struct radv_pipeline_stage *tcs_stage = consumer;
 
+      vs_stage->info.vs.as_ls = true;
+
       vs_stage->info.workgroup_size =
          ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
                                         MESA_SHADER_VERTEX, tcs_stage->info.num_tess_patches,
-- 
GitLab


From a8f27d70f239ae4c06bb7f5c444da9da77784466 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 26 Aug 2022 15:01:50 +0200
Subject: [PATCH 16/16] radv: constify radv_shader_info where it's missing
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_shader.c | 4 ++--
 src/amd/vulkan/radv_shader.h | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 1653bae61fe1..6f9b9a47ddb3 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2172,7 +2172,7 @@ radv_aco_build_shader_binary(void **bin,
 
 static struct radv_shader *
 shader_compile(struct radv_device *device, struct nir_shader *const *shaders, int shader_count, gl_shader_stage stage,
-               struct radv_shader_info *info, const struct radv_shader_args *args,
+               const struct radv_shader_info *info, const struct radv_shader_args *args,
                struct radv_nir_compiler_options *options, bool gs_copy_shader,
                bool trap_handler_shader, bool keep_shader_info, bool keep_statistic_info,
                struct radv_shader_binary **binary_out)
@@ -2267,7 +2267,7 @@ radv_shader_nir_to_asm(struct radv_device *device, struct radv_pipeline_stage *p
 
 struct radv_shader *
 radv_create_gs_copy_shader(struct radv_device *device, struct nir_shader *shader,
-                           struct radv_shader_info *info, const struct radv_shader_args *args,
+                           const struct radv_shader_info *info, const struct radv_shader_args *args,
                            struct radv_shader_binary **binary_out, bool keep_shader_info,
                            bool keep_statistic_info, bool disable_optimizations)
 {
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index bde2d0dd3b4c..16d3dab1db3d 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -572,7 +572,7 @@ void radv_free_shader_memory(struct radv_device *device, union radv_shader_arena
 
 struct radv_shader *
 radv_create_gs_copy_shader(struct radv_device *device, struct nir_shader *nir,
-                           struct radv_shader_info *info, const struct radv_shader_args *args,
+                           const struct radv_shader_info *info, const struct radv_shader_args *args,
                            struct radv_shader_binary **binary_out,
                            bool keep_shader_info, bool keep_statistic_info,
                            bool disable_optimizations);
-- 
GitLab

