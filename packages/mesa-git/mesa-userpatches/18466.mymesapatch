From ab6115a842f042642fbd867da2a52ec3195d30ff Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Wed, 7 Sep 2022 06:01:54 -0700
Subject: [PATCH 1/5] glsl: Remove lower_output_reads.

No longer used since 214c774ba6c7 ("mesa/st: Remove st_glsl_to_tgsi.").
---
 src/compiler/glsl/ir_optimization.h      |   1 -
 src/compiler/glsl/lower_output_reads.cpp | 182 -----------------------
 src/compiler/glsl/meson.build            |   1 -
 3 files changed, 184 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_output_reads.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 6571ce8c2a1b..36afc3d1918e 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -112,7 +112,6 @@ void lower_discard_flow(exec_list *instructions);
 bool lower_instructions(exec_list *instructions, unsigned what_to_lower);
 bool lower_clip_cull_distance(struct gl_shader_program *prog,
                               gl_linked_shader *shader);
-void lower_output_reads(unsigned stage, exec_list *instructions);
 bool lower_packing_builtins(exec_list *instructions, int op_mask);
 bool lower_vector_insert(exec_list *instructions, bool lower_nonconstant_index);
 bool lower_vector_derefs(gl_linked_shader *shader);
diff --git a/src/compiler/glsl/lower_output_reads.cpp b/src/compiler/glsl/lower_output_reads.cpp
deleted file mode 100644
index 7a182130b2e2..000000000000
--- a/src/compiler/glsl/lower_output_reads.cpp
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright © 2012 Vincent Lejeune
- * Copyright © 2012 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#include "ir.h"
-#include "util/hash_table.h"
-
-/**
- * \file lower_output_reads.cpp
- *
- * In GLSL, shader output variables (such as varyings) can be both read and
- * written.  However, on some hardware, reading an output register causes
- * trouble.
- *
- * This pass creates temporary shadow copies of every (used) shader output,
- * and replaces all accesses to use those instead.  It also adds code to the
- * main() function to copy the final values to the actual shader outputs.
- */
-
-namespace {
-
-class output_read_remover : public ir_hierarchical_visitor {
-protected:
-   /**
-    * A hash table mapping from the original ir_variable shader outputs
-    * (ir_var_shader_out mode) to the new temporaries to be used instead.
-    */
-   hash_table *replacements;
-
-   unsigned stage;
-public:
-   output_read_remover(unsigned stage);
-   ~output_read_remover();
-   virtual ir_visitor_status visit(class ir_dereference_variable *);
-   virtual ir_visitor_status visit_leave(class ir_emit_vertex *);
-   virtual ir_visitor_status visit_leave(class ir_return *);
-   virtual ir_visitor_status visit_leave(class ir_function_signature *);
-};
-
-} /* anonymous namespace */
-
-/**
- * Hash function for the output variables - computes the hash of the name.
- * NOTE: We're using the name string to ensure that the hash doesn't depend
- * on any random factors, otherwise the output_read_remover could produce
- * the random order of the assignments.
- *
- * NOTE: If you want to reuse this function please take into account that
- * generally the names of the variables are non-unique.
- */
-static unsigned
-hash_table_var_hash(const void *key)
-{
-   const ir_variable * var = static_cast<const ir_variable *>(key);
-   return _mesa_hash_string(var->name);
-}
-
-output_read_remover::output_read_remover(unsigned stage)
-{
-   this->stage = stage;
-   replacements = _mesa_hash_table_create(NULL, hash_table_var_hash,
-                                          _mesa_key_pointer_equal);
-}
-
-output_read_remover::~output_read_remover()
-{
-   _mesa_hash_table_destroy(replacements, NULL);
-}
-
-ir_visitor_status
-output_read_remover::visit(ir_dereference_variable *ir)
-{
-   if (ir->var->data.mode != ir_var_shader_out || ir->var->data.fb_fetch_output)
-      return visit_continue;
-
-   hash_entry *entry = _mesa_hash_table_search(replacements, ir->var);
-   ir_variable *temp = entry ? (ir_variable *) entry->data : NULL;
-
-   /* If we don't have an existing temporary, create one. */
-   if (temp == NULL) {
-      void *var_ctx = ralloc_parent(ir->var);
-      temp = new(var_ctx) ir_variable(ir->var->type, ir->var->name,
-                                      ir_var_temporary);
-      /* copy flags which affect arithematical precision */
-      temp->data.invariant = ir->var->data.invariant;
-      temp->data.precise = ir->var->data.precise;
-      temp->data.precision = ir->var->data.precision;
-      _mesa_hash_table_insert(replacements, ir->var, temp);
-      ir->var->insert_after(temp);
-   }
-
-   /* Update the dereference to use the temporary */
-   ir->var = temp;
-
-   return visit_continue;
-}
-
-/**
- * Create an assignment to copy a temporary value back to the actual output.
- */
-static ir_assignment *
-copy(void *ctx, ir_variable *output, ir_variable *temp)
-{
-   ir_dereference_variable *lhs = new(ctx) ir_dereference_variable(output);
-   ir_dereference_variable *rhs = new(ctx) ir_dereference_variable(temp);
-   return new(ctx) ir_assignment(lhs, rhs);
-}
-
-/** Insert a copy-back assignment before a "return" statement or a call to
- * EmitVertex().
- */
-static void
-emit_return_copy(const void *key, void *data, void *closure)
-{
-   ir_return *ir = (ir_return *) closure;
-   ir->insert_before(copy(ir, (ir_variable *) key, (ir_variable *) data));
-}
-
-/** Insert a copy-back assignment at the end of the main() function */
-static void
-emit_main_copy(const void *key, void *data, void *closure)
-{
-   ir_function_signature *sig = (ir_function_signature *) closure;
-   sig->body.push_tail(copy(sig, (ir_variable *) key, (ir_variable *) data));
-}
-
-ir_visitor_status
-output_read_remover::visit_leave(ir_return *ir)
-{
-   hash_table_call_foreach(replacements, emit_return_copy, ir);
-   return visit_continue;
-}
-
-ir_visitor_status
-output_read_remover::visit_leave(ir_emit_vertex *ir)
-{
-   hash_table_call_foreach(replacements, emit_return_copy, ir);
-   return visit_continue;
-}
-
-ir_visitor_status
-output_read_remover::visit_leave(ir_function_signature *sig)
-{
-   if (strcmp(sig->function_name(), "main") != 0)
-      return visit_continue;
-
-   hash_table_call_foreach(replacements, emit_main_copy, sig);
-   return visit_continue;
-}
-
-void
-lower_output_reads(unsigned stage, exec_list *instructions)
-{
-   /* Due to the possible interactions between multiple tessellation control
-    * shader invocations, we leave output variables as-is.
-    */
-   if (stage == MESA_SHADER_TESS_CTRL)
-      return;
-
-   output_read_remover v(stage);
-   visit_list_elements(&v, instructions);
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 5b0fe725245b..de73301a9e47 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -172,7 +172,6 @@ files_libglsl = files(
   'lower_vec_index_to_swizzle.cpp',
   'lower_vector_derefs.cpp',
   'lower_vector_insert.cpp',
-  'lower_output_reads.cpp',
   'opt_algebraic.cpp',
   'opt_array_splitting.cpp',
   'opt_constant_folding.cpp',
-- 
GitLab


From dbce2d186a5faaa741630eed27cbda0021fd90d5 Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Wed, 7 Sep 2022 07:05:28 -0700
Subject: [PATCH 2/5] glsl: Remove do_set_program_inouts.

No longer used since 214c774ba6c7 ("mesa/st: Remove st_glsl_to_tgsi.").
---
 src/compiler/glsl/ir.h                      |   4 -
 src/compiler/glsl/ir_set_program_inouts.cpp | 441 --------------------
 src/compiler/glsl/meson.build               |   1 -
 3 files changed, 446 deletions(-)
 delete mode 100644 src/compiler/glsl/ir_set_program_inouts.cpp

diff --git a/src/compiler/glsl/ir.h b/src/compiler/glsl/ir.h
index d6abd8438139..c9280aef438a 100644
--- a/src/compiler/glsl/ir.h
+++ b/src/compiler/glsl/ir.h
@@ -2513,10 +2513,6 @@ _mesa_glsl_initialize_variables(exec_list *instructions,
 extern void
 reparent_ir(exec_list *list, void *mem_ctx);
 
-extern void
-do_set_program_inouts(exec_list *instructions, struct gl_program *prog,
-                      gl_shader_stage shader_stage);
-
 extern char *
 prototype_string(const glsl_type *return_type, const char *name,
 		 exec_list *parameters);
diff --git a/src/compiler/glsl/ir_set_program_inouts.cpp b/src/compiler/glsl/ir_set_program_inouts.cpp
deleted file mode 100644
index d280344cbe07..000000000000
--- a/src/compiler/glsl/ir_set_program_inouts.cpp
+++ /dev/null
@@ -1,441 +0,0 @@
-/*
- * Copyright © 2010 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file ir_set_program_inouts.cpp
- *
- * Sets the inputs_read and outputs_written of Mesa programs.
- *
- * Mesa programs (gl_program, not gl_shader_program) have a set of
- * flags indicating which varyings are read and written.  Computing
- * which are actually read from some sort of backend code can be
- * tricky when variable array indexing involved.  So this pass
- * provides support for setting inputs_read and outputs_written right
- * from the GLSL IR.
- */
-
-#include "ir.h"
-#include "ir_visitor.h"
-#include "compiler/glsl_types.h"
-#include "main/shader_types.h"
-
-namespace {
-
-class ir_set_program_inouts_visitor : public ir_hierarchical_visitor {
-public:
-   ir_set_program_inouts_visitor(struct gl_program *prog,
-                                 gl_shader_stage shader_stage)
-   {
-      this->prog = prog;
-      this->shader_stage = shader_stage;
-   }
-   ~ir_set_program_inouts_visitor()
-   {
-   }
-
-   virtual ir_visitor_status visit_enter(ir_dereference_array *);
-   virtual ir_visitor_status visit_enter(ir_function_signature *);
-   virtual ir_visitor_status visit_enter(ir_discard *);
-   virtual ir_visitor_status visit_enter(ir_texture *);
-   virtual ir_visitor_status visit(ir_dereference_variable *);
-
-private:
-   void mark_whole_variable(ir_variable *var);
-   bool try_mark_partial_variable(ir_variable *var, ir_rvalue *index);
-
-   struct gl_program *prog;
-   gl_shader_stage shader_stage;
-};
-
-} /* anonymous namespace */
-
-static inline bool
-is_shader_inout(ir_variable *var)
-{
-   return var->data.mode == ir_var_shader_in ||
-          var->data.mode == ir_var_shader_out ||
-          var->data.mode == ir_var_system_value;
-}
-
-static void
-mark(struct gl_program *prog, ir_variable *var, int offset, int len,
-     gl_shader_stage stage)
-{
-   /* As of GLSL 1.20, varyings can only be floats, floating-point
-    * vectors or matrices, or arrays of them.  For Mesa programs using
-    * inputs_read/outputs_written, everything but matrices uses one
-    * slot, while matrices use a slot per column.  Presumably
-    * something doing a more clever packing would use something other
-    * than inputs_read/outputs_written.
-    */
-
-   for (int i = 0; i < len; i++) {
-      assert(var->data.location != -1);
-
-      int idx = var->data.location + offset + i;
-      bool is_patch_generic = var->data.patch &&
-                              idx != VARYING_SLOT_TESS_LEVEL_INNER &&
-                              idx != VARYING_SLOT_TESS_LEVEL_OUTER &&
-                              idx != VARYING_SLOT_BOUNDING_BOX0 &&
-                              idx != VARYING_SLOT_BOUNDING_BOX1;
-      GLbitfield64 bitfield;
-
-      if (is_patch_generic) {
-         assert(idx >= VARYING_SLOT_PATCH0 && idx < VARYING_SLOT_TESS_MAX);
-         bitfield = BITFIELD64_BIT(idx - VARYING_SLOT_PATCH0);
-      }
-      else {
-         assert(idx < VARYING_SLOT_MAX);
-         bitfield = BITFIELD64_BIT(idx);
-      }
-
-      if (var->data.mode == ir_var_shader_in) {
-         if (is_patch_generic)
-            prog->info.patch_inputs_read |= bitfield;
-         else
-            prog->info.inputs_read |= bitfield;
-
-         /* double inputs read is only for vertex inputs */
-         if (stage == MESA_SHADER_VERTEX &&
-             var->type->without_array()->is_dual_slot())
-            prog->DualSlotInputs |= bitfield;
-
-         if (stage == MESA_SHADER_FRAGMENT) {
-            prog->info.fs.uses_sample_qualifier |= var->data.sample;
-         }
-      } else if (var->data.mode == ir_var_system_value) {
-         BITSET_SET(prog->info.system_values_read, idx);
-      } else {
-         assert(var->data.mode == ir_var_shader_out);
-         if (is_patch_generic) {
-            prog->info.patch_outputs_written |= bitfield;
-         } else if (!var->data.read_only) {
-            prog->info.outputs_written |= bitfield;
-            if (var->data.index > 0)
-               prog->SecondaryOutputsWritten |= bitfield;
-         }
-
-         if (var->data.fb_fetch_output)
-            prog->info.outputs_read |= bitfield;
-      }
-   }
-}
-
-/**
- * Mark an entire variable as used.  Caller must ensure that the variable
- * represents a shader input or output.
- */
-void
-ir_set_program_inouts_visitor::mark_whole_variable(ir_variable *var)
-{
-   const glsl_type *type = var->type;
-   bool is_vertex_input = false;
-   if (this->shader_stage == MESA_SHADER_GEOMETRY &&
-       var->data.mode == ir_var_shader_in && type->is_array()) {
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_TESS_CTRL &&
-       var->data.mode == ir_var_shader_in) {
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_TESS_CTRL &&
-       var->data.mode == ir_var_shader_out && !var->data.patch) {
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_TESS_EVAL &&
-       var->data.mode == ir_var_shader_in && !var->data.patch) {
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_VERTEX &&
-       var->data.mode == ir_var_shader_in)
-      is_vertex_input = true;
-
-   mark(this->prog, var, 0, type->count_attribute_slots(is_vertex_input),
-        this->shader_stage);
-}
-
-/* Default handler: Mark all the locations in the variable as used. */
-ir_visitor_status
-ir_set_program_inouts_visitor::visit(ir_dereference_variable *ir)
-{
-   if (!is_shader_inout(ir->var))
-      return visit_continue;
-
-   mark_whole_variable(ir->var);
-
-   return visit_continue;
-}
-
-/**
- * Try to mark a portion of the given variable as used.  Caller must ensure
- * that the variable represents a shader input or output which can be indexed
- * into in array fashion (an array or matrix).  For the purpose of geometry
- * shader inputs (which are always arrays*), this means that the array element
- * must be something that can be indexed into in array fashion.
- *
- * *Except gl_PrimitiveIDIn, as noted below.
- *
- * For tessellation control shaders all inputs and non-patch outputs are
- * arrays. For tessellation evaluation shaders non-patch inputs are arrays.
- *
- * If the index can't be interpreted as a constant, or some other problem
- * occurs, then nothing will be marked and false will be returned.
- */
-bool
-ir_set_program_inouts_visitor::try_mark_partial_variable(ir_variable *var,
-                                                         ir_rvalue *index)
-{
-   const glsl_type *type = var->type;
-
-   if (this->shader_stage == MESA_SHADER_GEOMETRY &&
-       var->data.mode == ir_var_shader_in) {
-      /* The only geometry shader input that is not an array is
-       * gl_PrimitiveIDIn, and in that case, this code will never be reached,
-       * because gl_PrimitiveIDIn can't be indexed into in array fashion.
-       */
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_TESS_CTRL &&
-       var->data.mode == ir_var_shader_in) {
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_TESS_CTRL &&
-       var->data.mode == ir_var_shader_out && !var->data.patch) {
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   if (this->shader_stage == MESA_SHADER_TESS_EVAL &&
-       var->data.mode == ir_var_shader_in && !var->data.patch) {
-      assert(type->is_array());
-      type = type->fields.array;
-   }
-
-   /* TODO: implement proper arrays of arrays support
-    * for now let the caller mark whole variable as used.
-    */
-   if (type->is_array() && type->fields.array->is_array())
-      return false;
-
-   /* The code below only handles:
-    *
-    * - Indexing into matrices
-    * - Indexing into arrays of (matrices, vectors, or scalars)
-    *
-    * All other possibilities are either prohibited by GLSL (vertex inputs and
-    * fragment outputs can't be structs) or should have been eliminated by
-    * lowering passes (do_vec_index_to_swizzle() gets rid of indexing into
-    * vectors, and lower_packed_varyings() gets rid of structs that occur in
-    * varyings).
-    *
-    * However, we don't use varying packing in all cases - tessellation
-    * shaders bypass it.  This means we'll see varying structs and arrays
-    * of structs here.  For now, we just give up so the caller marks the
-    * entire variable as used.
-    */
-   if (!(type->is_matrix() ||
-        (type->is_array() &&
-         (type->fields.array->is_numeric() ||
-          type->fields.array->is_boolean())))) {
-
-      /* If we don't know how to handle this case, give up and let the
-       * caller mark the whole variable as used.
-       */
-      return false;
-   }
-
-   ir_constant *index_as_constant = index->as_constant();
-   if (!index_as_constant)
-      return false;
-
-   unsigned elem_width;
-   unsigned num_elems;
-   if (type->is_array()) {
-      num_elems = type->length;
-      if (type->fields.array->is_matrix())
-         elem_width = type->fields.array->matrix_columns;
-      else
-         elem_width = 1;
-   } else {
-      num_elems = type->matrix_columns;
-      elem_width = 1;
-   }
-
-   if (index_as_constant->value.u[0] >= num_elems) {
-      /* Constant index outside the bounds of the matrix/array.  This could
-       * arise as a result of constant folding of a legal GLSL program.
-       *
-       * Even though the spec says that indexing outside the bounds of a
-       * matrix/array results in undefined behaviour, we don't want to pass
-       * out-of-range values to mark() (since this could result in slots that
-       * don't exist being marked as used), so just let the caller mark the
-       * whole variable as used.
-       */
-      return false;
-   }
-
-   /* double element width for double types that takes two slots */
-   if (this->shader_stage != MESA_SHADER_VERTEX ||
-       var->data.mode != ir_var_shader_in) {
-      if (type->without_array()->is_dual_slot())
-	 elem_width *= 2;
-   }
-
-   mark(this->prog, var, index_as_constant->value.u[0] * elem_width,
-        elem_width, this->shader_stage);
-   return true;
-}
-
-static bool
-is_multiple_vertices(gl_shader_stage stage, ir_variable *var)
-{
-   if (var->data.patch)
-      return false;
-
-   if (var->data.mode == ir_var_shader_in)
-      return stage == MESA_SHADER_GEOMETRY ||
-             stage == MESA_SHADER_TESS_CTRL ||
-             stage == MESA_SHADER_TESS_EVAL;
-   if (var->data.mode == ir_var_shader_out)
-      return stage == MESA_SHADER_TESS_CTRL;
-
-   return false;
-}
-
-ir_visitor_status
-ir_set_program_inouts_visitor::visit_enter(ir_dereference_array *ir)
-{
-   /* Note: for geometry shader inputs, lower_named_interface_blocks may
-    * create 2D arrays, so we need to be able to handle those.  2D arrays
-    * shouldn't be able to crop up for any other reason.
-    */
-   if (ir_dereference_array * const inner_array =
-       ir->array->as_dereference_array()) {
-      /*          ir => foo[i][j]
-       * inner_array => foo[i]
-       */
-      if (ir_dereference_variable * const deref_var =
-          inner_array->array->as_dereference_variable()) {
-         if (is_multiple_vertices(this->shader_stage, deref_var->var)) {
-            /* foo is a geometry or tessellation shader input, so i is
-             * the vertex, and j the part of the input we're accessing.
-             */
-            if (try_mark_partial_variable(deref_var->var, ir->array_index))
-            {
-               /* We've now taken care of foo and j, but i might contain a
-                * subexpression that accesses shader inputs.  So manually
-                * visit i and then continue with the parent.
-                */
-               inner_array->array_index->accept(this);
-               return visit_continue_with_parent;
-            }
-         }
-      }
-   } else if (ir_dereference_variable * const deref_var =
-              ir->array->as_dereference_variable()) {
-      /* ir => foo[i], where foo is a variable. */
-      if (is_multiple_vertices(this->shader_stage, deref_var->var)) {
-         /* foo is a geometry or tessellation shader input, so i is
-          * the vertex, and we're accessing the entire input.
-          */
-         mark_whole_variable(deref_var->var);
-         /* We've now taken care of foo, but i might contain a subexpression
-          * that accesses shader inputs.  So manually visit i and then
-          * continue with the parent.
-          */
-         ir->array_index->accept(this);
-         return visit_continue_with_parent;
-      } else if (is_shader_inout(deref_var->var)) {
-         /* foo is a shader input/output, but not a geometry shader input,
-          * so i is the part of the input we're accessing.
-          */
-         if (try_mark_partial_variable(deref_var->var, ir->array_index))
-            return visit_continue_with_parent;
-      }
-   }
-
-   /* The expression is something we don't recognize.  Just visit its
-    * subexpressions.
-    */
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_set_program_inouts_visitor::visit_enter(ir_function_signature *ir)
-{
-   /* We don't want to descend into the function parameters and
-    * consider them as shader inputs or outputs.
-    */
-   visit_list_elements(this, &ir->body);
-   return visit_continue_with_parent;
-}
-
-ir_visitor_status
-ir_set_program_inouts_visitor::visit_enter(ir_discard *)
-{
-   /* discards are only allowed in fragment shaders. */
-   assert(this->shader_stage == MESA_SHADER_FRAGMENT);
-
-   prog->info.fs.uses_discard = true;
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_set_program_inouts_visitor::visit_enter(ir_texture *ir)
-{
-   if (ir->op == ir_tg4)
-      prog->info.uses_texture_gather = true;
-   return visit_continue;
-}
-
-void
-do_set_program_inouts(exec_list *instructions, struct gl_program *prog,
-                      gl_shader_stage shader_stage)
-{
-   ir_set_program_inouts_visitor v(prog, shader_stage);
-
-   prog->info.inputs_read = 0;
-   prog->info.outputs_written = 0;
-   prog->SecondaryOutputsWritten = 0;
-   prog->info.outputs_read = 0;
-   prog->info.patch_inputs_read = 0;
-   prog->info.patch_outputs_written = 0;
-   BITSET_ZERO(prog->info.system_values_read);
-   if (shader_stage == MESA_SHADER_FRAGMENT) {
-      prog->info.fs.uses_sample_qualifier = false;
-      prog->info.fs.uses_discard = false;
-   }
-   visit_list_elements(&v, instructions);
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index de73301a9e47..de87ef6f1b72 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -135,7 +135,6 @@ files_libglsl = files(
   'ir_reader.h',
   'ir_rvalue_visitor.cpp',
   'ir_rvalue_visitor.h',
-  'ir_set_program_inouts.cpp',
   'ir_uniform.h',
   'ir_validate.cpp',
   'ir_variable_refcount.cpp',
-- 
GitLab


From f28975c8c8cdae73118ee2cc15fd035a22a19f41 Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Wed, 7 Sep 2022 06:28:14 -0700
Subject: [PATCH 3/5] glsl: Remove opt_array_splitting.

nir_lower_vars_to_ssa will split temp arrays up anyway.  Fixes a bug where
split arrays wouldn't get their precision qualifier.

Helps mostly Android and skia shaders.  Also affects Civ5, Witcher 2, and
Borderlands 2.

freedreno shader-db:
total instructions in shared programs: 11319395 -> 11319355 (<.01%)
instructions in affected programs: 65744 -> 65704 (-0.06%)
---
 src/compiler/glsl/glsl_parser_extras.cpp  |  14 -
 src/compiler/glsl/ir_optimization.h       |   1 -
 src/compiler/glsl/meson.build             |   1 -
 src/compiler/glsl/opt_array_splitting.cpp | 499 ----------------------
 4 files changed, 515 deletions(-)
 delete mode 100644 src/compiler/glsl/opt_array_splitting.cpp

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 57a397e4cc7c..b1fb85adea3f 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -2415,20 +2415,6 @@ do_common_optimization(exec_list *ir, bool linked,
    OPT(do_vec_index_to_swizzle, ir);
    OPT(lower_vector_insert, ir, false);
 
-   /* Some drivers only call do_common_optimization() once rather than in a
-    * loop, and split arrays causes each element of a constant array to
-    * dereference is own copy of the entire array initilizer. This IR is not
-    * something that can be generated manually in a shader and is not
-    * accounted for by NIR optimisations, the result is an exponential slow
-    * down in compilation speed as a constant arrays element count grows. To
-    * avoid that here we make sure to always clean up the mess split arrays
-    * causes to constant arrays.
-    */
-   bool array_split = optimize_split_arrays(ir, linked);
-   if (array_split)
-      do_constant_propagation(ir);
-   progress |= array_split;
-
    /* If an optimization pass fails to preserve the invariant flag, calling
     * the pass only once earlier may result in incorrect code generation. Always call
     * propagate_invariance() last to avoid this possibility.
diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 36afc3d1918e..93b01b64b972 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -116,7 +116,6 @@ bool lower_packing_builtins(exec_list *instructions, int op_mask);
 bool lower_vector_insert(exec_list *instructions, bool lower_nonconstant_index);
 bool lower_vector_derefs(gl_linked_shader *shader);
 void lower_named_interface_blocks(void *mem_ctx, gl_linked_shader *shader);
-bool optimize_split_arrays(exec_list *instructions, bool linked);
 void optimize_dead_builtin_variables(exec_list *instructions,
                                      enum ir_variable_mode other);
 bool lower_tess_level(gl_linked_shader *shader);
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index de87ef6f1b72..388a6d6750cb 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -172,7 +172,6 @@ files_libglsl = files(
   'lower_vector_derefs.cpp',
   'lower_vector_insert.cpp',
   'opt_algebraic.cpp',
-  'opt_array_splitting.cpp',
   'opt_constant_folding.cpp',
   'opt_constant_propagation.cpp',
   'opt_constant_variable.cpp',
diff --git a/src/compiler/glsl/opt_array_splitting.cpp b/src/compiler/glsl/opt_array_splitting.cpp
deleted file mode 100644
index 1d9212b011d4..000000000000
--- a/src/compiler/glsl/opt_array_splitting.cpp
+++ /dev/null
@@ -1,499 +0,0 @@
-/*
- * Copyright © 2010 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file opt_array_splitting.cpp
- *
- * If an array is always dereferenced with a constant index, then
- * split it apart into its elements, making it more amenable to other
- * optimization passes.
- *
- * This skips uniform/varying arrays, which would need careful
- * handling due to their ir->location fields tying them to the GL API
- * and other shader stages.
- */
-
-#include "ir.h"
-#include "ir_visitor.h"
-#include "ir_rvalue_visitor.h"
-#include "compiler/glsl_types.h"
-
-static bool debug = false;
-
-namespace {
-
-namespace opt_array_splitting {
-
-class variable_entry : public exec_node
-{
-public:
-   variable_entry(ir_variable *var)
-   {
-      this->var = var;
-      this->split = true;
-      this->declaration = false;
-      this->components = NULL;
-      this->mem_ctx = NULL;
-      if (var->type->is_array())
-         this->size = var->type->length;
-      else
-         this->size = var->type->matrix_columns;
-   }
-
-   ir_variable *var; /* The key: the variable's pointer. */
-   unsigned size; /* array length or matrix columns */
-
-   /** Whether this array should be split or not. */
-   bool split;
-
-   /* If the variable had a decl we can work with in the instruction
-    * stream.  We can't do splitting on function arguments, which
-    * don't get this variable set.
-    */
-   bool declaration;
-
-   ir_variable **components;
-
-   /** ralloc_parent(this->var) -- the shader's talloc context. */
-   void *mem_ctx;
-};
-
-} /* namespace */
-
-using namespace opt_array_splitting;
-
-/**
- * This class does a walk over the tree, coming up with the set of
- * variables that could be split by looking to see if they are arrays
- * that are only ever constant-index dereferenced.
- */
-class ir_array_reference_visitor : public ir_hierarchical_visitor {
-public:
-   ir_array_reference_visitor(void)
-   {
-      this->mem_ctx = ralloc_context(NULL);
-      this->variable_list.make_empty();
-      this->in_whole_array_copy = false;
-   }
-
-   ~ir_array_reference_visitor(void)
-   {
-      ralloc_free(mem_ctx);
-   }
-
-   bool get_split_list(exec_list *instructions, bool linked);
-
-   virtual ir_visitor_status visit(ir_variable *);
-   virtual ir_visitor_status visit(ir_dereference_variable *);
-   virtual ir_visitor_status visit_enter(ir_assignment *);
-   virtual ir_visitor_status visit_leave(ir_assignment *);
-   virtual ir_visitor_status visit_enter(ir_dereference_array *);
-   virtual ir_visitor_status visit_enter(ir_function_signature *);
-
-   variable_entry *get_variable_entry(ir_variable *var);
-
-   /* List of variable_entry */
-   exec_list variable_list;
-
-   void *mem_ctx;
-
-   bool in_whole_array_copy;
-};
-
-} /* namespace */
-
-variable_entry *
-ir_array_reference_visitor::get_variable_entry(ir_variable *var)
-{
-   assert(var);
-
-   if (var->data.mode != ir_var_auto &&
-       var->data.mode != ir_var_temporary)
-      return NULL;
-
-   if (!(var->type->is_array() || var->type->is_matrix()))
-      return NULL;
-
-   /* If the array hasn't been sized yet, we can't split it.  After
-    * linking, this should be resolved.
-    */
-   if (var->type->is_unsized_array())
-      return NULL;
-
-   /* FIXME: arrays of arrays are not handled correctly by this pass so we
-    * skip it for now. While the pass will create functioning code it actually
-    * produces worse code.
-    *
-    * For example the array:
-    *
-    *    int[3][2] a;
-    *
-    * ends up being split up into:
-    *
-    *    int[3][2] a_0;
-    *    int[3][2] a_1;
-    *    int[3][2] a_2;
-    *
-    * And we end up referencing each of these new arrays for example:
-    *
-    *    a[0][1] will be turned into a_0[0][1]
-    *    a[1][0] will be turned into a_1[1][0]
-    *    a[2][0] will be turned into a_2[2][0]
-    */
-   if (var->type->is_array() && var->type->fields.array->is_array())
-      return NULL;
-
-   foreach_in_list(variable_entry, entry, &this->variable_list) {
-      if (entry->var == var)
-         return entry;
-   }
-
-   variable_entry *entry = new(mem_ctx) variable_entry(var);
-   this->variable_list.push_tail(entry);
-   return entry;
-}
-
-
-ir_visitor_status
-ir_array_reference_visitor::visit(ir_variable *ir)
-{
-   variable_entry *entry = this->get_variable_entry(ir);
-
-   if (entry)
-      entry->declaration = true;
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_array_reference_visitor::visit_enter(ir_assignment *ir)
-{
-   in_whole_array_copy =
-      ir->lhs->type->is_array() && ir->whole_variable_written();
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_array_reference_visitor::visit_leave(ir_assignment *)
-{
-   in_whole_array_copy = false;
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_array_reference_visitor::visit(ir_dereference_variable *ir)
-{
-   variable_entry *entry = this->get_variable_entry(ir->var);
-
-   /* Allow whole-array assignments on the LHS.  We can split those
-    * by "unrolling" the assignment into component-wise assignments.
-    */
-   if (in_assignee && in_whole_array_copy)
-      return visit_continue;
-
-   /* If we made it to here without seeing an ir_dereference_array,
-    * then the dereference of this array didn't have a constant index
-    * (see the visit_continue_with_parent below), so we can't split
-    * the variable.
-    */
-   if (entry)
-      entry->split = false;
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_array_reference_visitor::visit_enter(ir_dereference_array *ir)
-{
-   ir_dereference_variable *deref = ir->array->as_dereference_variable();
-   if (!deref)
-      return visit_continue;
-
-   variable_entry *entry = this->get_variable_entry(deref->var);
-
-   /* If the access to the array has a variable index, we wouldn't
-    * know which split variable this dereference should go to.
-    */
-   if (!ir->array_index->as_constant()) {
-      if (entry)
-         entry->split = false;
-      /* This variable indexing could come from a different array dereference
-       * that also has variable indexing, that is, something like a[b[a[b[0]]]].
-       * If we return visit_continue_with_parent here for the first appearence
-       * of a, then we can miss that b also has indirect indexing (if this is
-       * the only place in the program where such indirect indexing into b
-       * happens), so keep going.
-       */
-      return visit_continue;
-   }
-
-   /* If the index is also array dereference, visit index. */
-   if (ir->array_index->as_dereference_array())
-      visit_enter(ir->array_index->as_dereference_array());
-
-   return visit_continue_with_parent;
-}
-
-ir_visitor_status
-ir_array_reference_visitor::visit_enter(ir_function_signature *ir)
-{
-   /* We don't have logic for array-splitting function arguments,
-    * so just look at the body instructions and not the parameter
-    * declarations.
-    */
-   visit_list_elements(this, &ir->body);
-   return visit_continue_with_parent;
-}
-
-bool
-ir_array_reference_visitor::get_split_list(exec_list *instructions,
-                                           bool linked)
-{
-   visit_list_elements(this, instructions);
-
-   /* If the shaders aren't linked yet, we can't mess with global
-    * declarations, which need to be matched by name across shaders.
-    */
-   if (!linked) {
-      foreach_in_list(ir_instruction, node, instructions) {
-         ir_variable *var = node->as_variable();
-         if (var) {
-            variable_entry *entry = get_variable_entry(var);
-            if (entry)
-               entry->remove();
-         }
-      }
-   }
-
-   /* Trim out variables we found that we can't split. */
-   foreach_in_list_safe(variable_entry, entry, &variable_list) {
-      if (debug) {
-         printf("array %s@%p: decl %d, split %d\n",
-                entry->var->name, (void *) entry->var, entry->declaration,
-                entry->split);
-      }
-
-      if (!(entry->declaration && entry->split)) {
-         entry->remove();
-      }
-   }
-
-   return !variable_list.is_empty();
-}
-
-/**
- * This class rewrites the dereferences of arrays that have been split
- * to use the newly created ir_variables for each component.
- */
-class ir_array_splitting_visitor : public ir_rvalue_visitor {
-public:
-   ir_array_splitting_visitor(exec_list *vars)
-   {
-      this->variable_list = vars;
-   }
-
-   virtual ~ir_array_splitting_visitor()
-   {
-   }
-
-   virtual ir_visitor_status visit_leave(ir_assignment *);
-
-   void split_deref(ir_dereference **deref);
-   void handle_rvalue(ir_rvalue **rvalue);
-   variable_entry *get_splitting_entry(ir_variable *var);
-
-   exec_list *variable_list;
-};
-
-variable_entry *
-ir_array_splitting_visitor::get_splitting_entry(ir_variable *var)
-{
-   assert(var);
-
-   foreach_in_list(variable_entry, entry, this->variable_list) {
-      if (entry->var == var) {
-         return entry;
-      }
-   }
-
-   return NULL;
-}
-
-void
-ir_array_splitting_visitor::split_deref(ir_dereference **deref)
-{
-   ir_dereference_array *deref_array = (*deref)->as_dereference_array();
-   if (!deref_array)
-      return;
-
-   ir_dereference_variable *deref_var = deref_array->array->as_dereference_variable();
-   if (!deref_var)
-      return;
-   ir_variable *var = deref_var->var;
-
-   variable_entry *entry = get_splitting_entry(var);
-   if (!entry)
-      return;
-
-   ir_constant *constant = deref_array->array_index->as_constant();
-   assert(constant);
-
-   if (constant->value.i[0] >= 0 && constant->value.i[0] < (int)entry->size) {
-      *deref = new(entry->mem_ctx)
-               ir_dereference_variable(entry->components[constant->value.i[0]]);
-   } else {
-      /* There was a constant array access beyond the end of the
-       * array.  This might have happened due to constant folding
-       * after the initial parse.  This produces an undefined value,
-       * but shouldn't crash.  Just give them an uninitialized
-       * variable.
-       */
-      ir_variable *temp = new(entry->mem_ctx) ir_variable(deref_array->type,
-                                                          "undef",
-                                                          ir_var_temporary);
-      entry->components[0]->insert_before(temp);
-      *deref = new(entry->mem_ctx) ir_dereference_variable(temp);
-   }
-}
-
-void
-ir_array_splitting_visitor::handle_rvalue(ir_rvalue **rvalue)
-{
-   if (!*rvalue)
-      return;
-
-   ir_dereference *deref = (*rvalue)->as_dereference();
-
-   if (!deref)
-      return;
-
-   split_deref(&deref);
-   *rvalue = deref;
-}
-
-ir_visitor_status
-ir_array_splitting_visitor::visit_leave(ir_assignment *ir)
-{
-   /* The normal rvalue visitor skips the LHS of assignments, but we
-    * need to process those just the same.
-    */
-   ir_rvalue *lhs = ir->lhs;
-
-   /* "Unroll" any whole array assignments, creating assignments for
-    * each array element.  Then, do splitting on each new assignment.
-    */
-   if (lhs->type->is_array() && ir->whole_variable_written() &&
-       get_splitting_entry(ir->whole_variable_written())) {
-      void *mem_ctx = ralloc_parent(ir);
-
-      for (unsigned i = 0; i < lhs->type->length; i++) {
-         ir_rvalue *lhs_i =
-            new(mem_ctx) ir_dereference_array(ir->lhs->clone(mem_ctx, NULL),
-                                              new(mem_ctx) ir_constant(i));
-         ir_rvalue *rhs_i =
-            new(mem_ctx) ir_dereference_array(ir->rhs->clone(mem_ctx, NULL),
-                                              new(mem_ctx) ir_constant(i));
-
-         ir_assignment *assign_i = new(mem_ctx) ir_assignment(lhs_i, rhs_i);
-
-         ir->insert_before(assign_i);
-         assign_i->accept(this);
-      }
-      ir->remove();
-      return visit_continue;
-   }
-
-   handle_rvalue(&lhs);
-   ir->lhs = lhs->as_dereference();
-
-   ir->lhs->accept(this);
-
-   handle_rvalue(&ir->rhs);
-   ir->rhs->accept(this);
-
-   return visit_continue;
-}
-
-bool
-optimize_split_arrays(exec_list *instructions, bool linked)
-{
-   ir_array_reference_visitor refs;
-   if (!refs.get_split_list(instructions, linked))
-      return false;
-
-   void *mem_ctx = ralloc_context(NULL);
-
-   /* Replace the decls of the arrays to be split with their split
-    * components.
-    */
-   foreach_in_list(variable_entry, entry, &refs.variable_list) {
-      const struct glsl_type *type = entry->var->type;
-      const struct glsl_type *subtype;
-
-      if (type->is_matrix())
-         subtype = type->column_type();
-      else
-         subtype = type->fields.array;
-
-      entry->mem_ctx = ralloc_parent(entry->var);
-
-      entry->components = ralloc_array(mem_ctx, ir_variable *, entry->size);
-
-      for (unsigned int i = 0; i < entry->size; i++) {
-         const char *name = ralloc_asprintf(mem_ctx, "%s_%d",
-                                            entry->var->name, i);
-         ir_variable *new_var =
-            new(entry->mem_ctx) ir_variable(subtype, name, ir_var_temporary);
-         new_var->data.invariant = entry->var->data.invariant;
-         new_var->data.precise = entry->var->data.precise;
-
-         /* Do not lose memory/format qualifiers when arrays of images are
-          * split.
-          */
-         new_var->data.memory_read_only = entry->var->data.memory_read_only;
-         new_var->data.memory_write_only = entry->var->data.memory_write_only;
-         new_var->data.memory_coherent = entry->var->data.memory_coherent;
-         new_var->data.memory_volatile = entry->var->data.memory_volatile;
-         new_var->data.memory_restrict = entry->var->data.memory_restrict;
-         new_var->data.image_format = entry->var->data.image_format;
-
-         entry->components[i] = new_var;
-         entry->var->insert_before(entry->components[i]);
-      }
-
-      entry->var->remove();
-   }
-
-   ir_array_splitting_visitor split(&refs.variable_list);
-   visit_list_elements(&split, instructions);
-
-   if (debug)
-      _mesa_print_ir(stdout, instructions, NULL);
-
-   ralloc_free(mem_ctx);
-
-   return true;
-
-}
-- 
GitLab


From cfd0459194eb27781ca7a272c2ba960c753de10b Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Wed, 7 Sep 2022 06:34:03 -0700
Subject: [PATCH 4/5] glsl: remove opt_structure_splitting.

nir_lower_vars_to_ssa will split temp structs up anyway.  This fixes a bug
where mediump wouldn't be propagated to the split vars.

The effect is tiny, I think just shuffling some code scheduling from
optimizing at different places.  Affects Natural Selection 2, Serious Sam
3, 3dmark slingshot, and Lego Legacy.

freedreno shader-db:
total instructions in shared programs: 11315637 -> 11315993 (<.01%)
instructions in affected programs: 24861 -> 25217 (1.43%)
---
 src/compiler/glsl/glsl_parser_extras.cpp      |   1 -
 src/compiler/glsl/ir_optimization.h           |   1 -
 src/compiler/glsl/meson.build                 |   1 -
 src/compiler/glsl/opt_structure_splitting.cpp | 374 ------------------
 src/compiler/glsl/test_optpass.cpp            |   2 -
 5 files changed, 379 deletions(-)
 delete mode 100644 src/compiler/glsl/opt_structure_splitting.cpp

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index b1fb85adea3f..cd25fd7c3aa6 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -2385,7 +2385,6 @@ do_common_optimization(exec_list *ir, bool linked,
    if (linked) {
       OPT(do_function_inlining, ir);
       OPT(do_dead_functions, ir);
-      OPT(do_structure_splitting, ir);
    }
    OPT(propagate_invariance, ir);
    OPT(do_if_simplification, ir);
diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 93b01b64b972..8156b541ef61 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -103,7 +103,6 @@ bool do_if_simplification(exec_list *instructions);
 bool opt_flatten_nested_if_blocks(exec_list *instructions);
 bool do_mat_op_to_vec(exec_list *instructions);
 bool do_minmax_prune(exec_list *instructions);
-bool do_structure_splitting(exec_list *instructions);
 bool do_tree_grafting(exec_list *instructions);
 bool do_vec_index_to_cond_assign(exec_list *instructions);
 bool do_vec_index_to_swizzle(exec_list *instructions);
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 388a6d6750cb..72b19865e586 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -186,7 +186,6 @@ files_libglsl = files(
   'opt_if_simplification.cpp',
   'opt_minmax.cpp',
   'opt_rebalance_tree.cpp',
-  'opt_structure_splitting.cpp',
   'opt_tree_grafting.cpp',
   'program.h',
   'propagate_invariance.cpp',
diff --git a/src/compiler/glsl/opt_structure_splitting.cpp b/src/compiler/glsl/opt_structure_splitting.cpp
deleted file mode 100644
index 223d28820ce4..000000000000
--- a/src/compiler/glsl/opt_structure_splitting.cpp
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- * Copyright © 2010 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file opt_structure_splitting.cpp
- *
- * If a structure is only ever referenced by its components, then
- * split those components out to individual variables so they can be
- * handled normally by other optimization passes.
- *
- * This skips structures like uniforms, which need to be accessible as
- * structures for their access by the GL.
- */
-
-#include "ir.h"
-#include "ir_visitor.h"
-#include "ir_rvalue_visitor.h"
-#include "compiler/glsl_types.h"
-
-namespace {
-
-static bool debug = false;
-
-class variable_entry : public exec_node
-{
-public:
-   variable_entry(ir_variable *var)
-   {
-      this->var = var;
-      this->whole_structure_access = 0;
-      this->declaration = false;
-      this->components = NULL;
-      this->mem_ctx = NULL;
-   }
-
-   ir_variable *var; /* The key: the variable's pointer. */
-
-   /** Number of times the variable is referenced, including assignments. */
-   unsigned whole_structure_access;
-
-   /* If the variable had a decl we can work with in the instruction
-    * stream.  We can't do splitting on function arguments, which
-    * don't get this variable set.
-    */
-   bool declaration;
-
-   ir_variable **components;
-
-   /** ralloc_parent(this->var) -- the shader's ralloc context. */
-   void *mem_ctx;
-};
-
-
-class ir_structure_reference_visitor : public ir_hierarchical_visitor {
-public:
-   ir_structure_reference_visitor(void)
-   {
-      this->mem_ctx = ralloc_context(NULL);
-      this->variable_list.make_empty();
-   }
-
-   ~ir_structure_reference_visitor(void)
-   {
-      ralloc_free(mem_ctx);
-   }
-
-   virtual ir_visitor_status visit(ir_variable *);
-   virtual ir_visitor_status visit(ir_dereference_variable *);
-   virtual ir_visitor_status visit_enter(ir_dereference_record *);
-   virtual ir_visitor_status visit_enter(ir_assignment *);
-   virtual ir_visitor_status visit_enter(ir_function_signature *);
-
-   variable_entry *get_variable_entry(ir_variable *var);
-
-   /* List of variable_entry */
-   exec_list variable_list;
-
-   void *mem_ctx;
-};
-
-variable_entry *
-ir_structure_reference_visitor::get_variable_entry(ir_variable *var)
-{
-   assert(var);
-
-   if (!var->type->is_struct() ||
-       var->data.mode == ir_var_uniform || var->data.mode == ir_var_shader_storage ||
-       var->data.mode == ir_var_shader_in || var->data.mode == ir_var_shader_out)
-      return NULL;
-
-   foreach_in_list(variable_entry, entry, &this->variable_list) {
-      if (entry->var == var)
-	 return entry;
-   }
-
-   variable_entry *entry = new(mem_ctx) variable_entry(var);
-   this->variable_list.push_tail(entry);
-   return entry;
-}
-
-
-ir_visitor_status
-ir_structure_reference_visitor::visit(ir_variable *ir)
-{
-   variable_entry *entry = this->get_variable_entry(ir);
-
-   if (entry)
-      entry->declaration = true;
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_structure_reference_visitor::visit(ir_dereference_variable *ir)
-{
-   ir_variable *const var = ir->variable_referenced();
-   variable_entry *entry = this->get_variable_entry(var);
-
-   if (entry)
-      entry->whole_structure_access++;
-
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_structure_reference_visitor::visit_enter(ir_dereference_record *ir)
-{
-   (void) ir;
-   /* Don't descend into the ir_dereference_variable below. */
-   return visit_continue_with_parent;
-}
-
-ir_visitor_status
-ir_structure_reference_visitor::visit_enter(ir_assignment *ir)
-{
-   /* If there are no structure references yet, no need to bother with
-    * processing the expression tree.
-    */
-   if (this->variable_list.is_empty())
-      return visit_continue_with_parent;
-
-   if (ir->lhs->as_dereference_variable() &&
-       ir->rhs->as_dereference_variable()) {
-      /* We'll split copies of a structure to copies of components, so don't
-       * descend to the ir_dereference_variables.
-       */
-      return visit_continue_with_parent;
-   }
-   return visit_continue;
-}
-
-ir_visitor_status
-ir_structure_reference_visitor::visit_enter(ir_function_signature *ir)
-{
-   /* We don't have logic for structure-splitting function arguments,
-    * so just look at the body instructions and not the parameter
-    * declarations.
-    */
-   visit_list_elements(this, &ir->body);
-   return visit_continue_with_parent;
-}
-
-class ir_structure_splitting_visitor : public ir_rvalue_visitor {
-public:
-   ir_structure_splitting_visitor(exec_list *vars)
-   {
-      this->variable_list = vars;
-   }
-
-   virtual ~ir_structure_splitting_visitor()
-   {
-   }
-
-   virtual ir_visitor_status visit_leave(ir_assignment *);
-
-   void split_deref(ir_dereference **deref);
-   void handle_rvalue(ir_rvalue **rvalue);
-   variable_entry *get_splitting_entry(ir_variable *var);
-
-   exec_list *variable_list;
-};
-
-variable_entry *
-ir_structure_splitting_visitor::get_splitting_entry(ir_variable *var)
-{
-   assert(var);
-
-   if (!var->type->is_struct())
-      return NULL;
-
-   foreach_in_list(variable_entry, entry, this->variable_list) {
-      if (entry->var == var) {
-	 return entry;
-      }
-   }
-
-   return NULL;
-}
-
-void
-ir_structure_splitting_visitor::split_deref(ir_dereference **deref)
-{
-   if ((*deref)->ir_type != ir_type_dereference_record)
-      return;
-
-   ir_dereference_record *deref_record = (ir_dereference_record *)*deref;
-   ir_dereference_variable *deref_var = deref_record->record->as_dereference_variable();
-   if (!deref_var)
-      return;
-
-   variable_entry *entry = get_splitting_entry(deref_var->var);
-   if (!entry)
-      return;
-
-   int i = deref_record->field_idx;
-   assert(i >= 0);
-   assert((unsigned) i < entry->var->type->length);
-
-   *deref = new(entry->mem_ctx) ir_dereference_variable(entry->components[i]);
-}
-
-void
-ir_structure_splitting_visitor::handle_rvalue(ir_rvalue **rvalue)
-{
-   if (!*rvalue)
-      return;
-
-   ir_dereference *deref = (*rvalue)->as_dereference();
-
-   if (!deref)
-      return;
-
-   split_deref(&deref);
-   *rvalue = deref;
-}
-
-ir_visitor_status
-ir_structure_splitting_visitor::visit_leave(ir_assignment *ir)
-{
-   ir_dereference_variable *lhs_deref = ir->lhs->as_dereference_variable();
-   ir_dereference_variable *rhs_deref = ir->rhs->as_dereference_variable();
-   variable_entry *lhs_entry = lhs_deref ? get_splitting_entry(lhs_deref->var) : NULL;
-   variable_entry *rhs_entry = rhs_deref ? get_splitting_entry(rhs_deref->var) : NULL;
-   const glsl_type *type = ir->rhs->type;
-
-   if (lhs_entry || rhs_entry) {
-      for (unsigned int i = 0; i < type->length; i++) {
-	 ir_dereference *new_lhs, *new_rhs;
-	 void *mem_ctx = lhs_entry ? lhs_entry->mem_ctx : rhs_entry->mem_ctx;
-
-	 if (lhs_entry) {
-	    new_lhs = new(mem_ctx) ir_dereference_variable(lhs_entry->components[i]);
-	 } else {
-	    new_lhs = new(mem_ctx)
-	       ir_dereference_record(ir->lhs->clone(mem_ctx, NULL),
-				     type->fields.structure[i].name);
-	 }
-
-	 if (rhs_entry) {
-	    new_rhs = new(mem_ctx) ir_dereference_variable(rhs_entry->components[i]);
-	 } else {
-	    new_rhs = new(mem_ctx)
-	       ir_dereference_record(ir->rhs->clone(mem_ctx, NULL),
-				     type->fields.structure[i].name);
-	 }
-
-         ir->insert_before(new(mem_ctx) ir_assignment(new_lhs, new_rhs));
-      }
-      ir->remove();
-   } else {
-      handle_rvalue(&ir->rhs);
-      split_deref(&ir->lhs);
-   }
-
-   return visit_continue;
-}
-
-} /* unnamed namespace */
-
-bool
-do_structure_splitting(exec_list *instructions)
-{
-   ir_structure_reference_visitor refs;
-
-   visit_list_elements(&refs, instructions);
-
-   /* Trim out variables we can't split. */
-   foreach_in_list_safe(variable_entry, entry, &refs.variable_list) {
-      if (debug) {
-         printf("structure %s@%p: decl %d, whole_access %d\n",
-                entry->var->name, (void *) entry->var, entry->declaration,
-                entry->whole_structure_access);
-      }
-
-      if (!entry->declaration || entry->whole_structure_access) {
-         entry->remove();
-      }
-   }
-
-   if (refs.variable_list.is_empty())
-      return false;
-
-   void *mem_ctx = ralloc_context(NULL);
-
-   /* Replace the decls of the structures to be split with their split
-    * components.
-    */
-   foreach_in_list_safe(variable_entry, entry, &refs.variable_list) {
-      const struct glsl_type *type = entry->var->type;
-
-      entry->mem_ctx = ralloc_parent(entry->var);
-
-      entry->components = ralloc_array(mem_ctx, ir_variable *, type->length);
-
-      for (unsigned int i = 0; i < entry->var->type->length; i++) {
-         const char *name = ralloc_asprintf(mem_ctx, "%s_%s", entry->var->name,
-                                            type->fields.structure[i].name);
-         ir_variable *new_var =
-            new(entry->mem_ctx) ir_variable(type->fields.structure[i].type,
-                                            name,
-                                            (ir_variable_mode) entry->var->data.mode);
-
-         if (type->fields.structure[i].type->without_array()->is_image()) {
-            /* Do not lose memory/format qualifiers for images declared inside
-             * structures as allowed by ARB_bindless_texture.
-             */
-            new_var->data.memory_read_only =
-               type->fields.structure[i].memory_read_only;
-            new_var->data.memory_write_only =
-               type->fields.structure[i].memory_write_only;
-            new_var->data.memory_coherent =
-               type->fields.structure[i].memory_coherent;
-            new_var->data.memory_volatile =
-               type->fields.structure[i].memory_volatile;
-            new_var->data.memory_restrict =
-               type->fields.structure[i].memory_restrict;
-            new_var->data.image_format =
-               type->fields.structure[i].image_format;
-         }
-
-         entry->components[i] = new_var;
-         entry->var->insert_before(entry->components[i]);
-      }
-
-      entry->var->remove();
-   }
-
-   ir_structure_splitting_visitor split(&refs.variable_list);
-   visit_list_elements(&split, instructions);
-
-   ralloc_free(mem_ctx);
-
-   return true;
-}
diff --git a/src/compiler/glsl/test_optpass.cpp b/src/compiler/glsl/test_optpass.cpp
index da72ff6adf7a..a34e00be38cc 100644
--- a/src/compiler/glsl/test_optpass.cpp
+++ b/src/compiler/glsl/test_optpass.cpp
@@ -95,8 +95,6 @@ do_optimization(struct exec_list *ir, const char *optimization,
       return do_if_simplification(ir);
    } else if (strcmp(optimization, "do_mat_op_to_vec") == 0) {
       return do_mat_op_to_vec(ir);
-   } else if (strcmp(optimization, "do_structure_splitting") == 0) {
-      return do_structure_splitting(ir);
    } else if (strcmp(optimization, "do_tree_grafting") == 0) {
       return do_tree_grafting(ir);
    } else if (strcmp(optimization, "do_vec_index_to_cond_assign") == 0) {
-- 
GitLab


From 103cb9a98a8bdc6fbc06f8d1e8eebc014fd22722 Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Wed, 7 Sep 2022 07:03:43 -0700
Subject: [PATCH 5/5] glsl: Remove lower_vec_index_to_swizzle.

GLSL's lower_vector_derefs already does this, and even if it didn't
nir_vector_extract() would when glsl-to-nir happens.

No effect on freedreno shader-db.
---
 src/compiler/glsl/glsl_parser_extras.cpp      |   1 -
 src/compiler/glsl/ir_optimization.h           |   1 -
 src/compiler/glsl/linker.cpp                  |   1 -
 .../glsl/lower_vec_index_to_swizzle.cpp       | 102 ------------------
 src/compiler/glsl/meson.build                 |   1 -
 src/compiler/glsl/test_optpass.cpp            |   2 -
 6 files changed, 108 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_vec_index_to_swizzle.cpp

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index cd25fd7c3aa6..870128f9dec9 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -2411,7 +2411,6 @@ do_common_optimization(exec_list *ir, bool linked,
    OPT(do_algebraic, ir, native_integers, options);
    OPT(do_lower_jumps, ir, true, true, options->EmitNoMainReturn,
        options->EmitNoCont);
-   OPT(do_vec_index_to_swizzle, ir);
    OPT(lower_vector_insert, ir, false);
 
    /* If an optimization pass fails to preserve the invariant flag, calling
diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 8156b541ef61..5cd96c9bf951 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -105,7 +105,6 @@ bool do_mat_op_to_vec(exec_list *instructions);
 bool do_minmax_prune(exec_list *instructions);
 bool do_tree_grafting(exec_list *instructions);
 bool do_vec_index_to_cond_assign(exec_list *instructions);
-bool do_vec_index_to_swizzle(exec_list *instructions);
 bool lower_discard(exec_list *instructions);
 void lower_discard_flow(exec_list *instructions);
 bool lower_instructions(exec_list *instructions, unsigned what_to_lower);
diff --git a/src/compiler/glsl/linker.cpp b/src/compiler/glsl/linker.cpp
index d61fe0136c25..4c0db3552169 100644
--- a/src/compiler/glsl/linker.cpp
+++ b/src/compiler/glsl/linker.cpp
@@ -3546,7 +3546,6 @@ link_varyings(const struct gl_constants *consts, struct gl_shader_program *prog,
          continue;
 
       lower_vector_derefs(prog->_LinkedShaders[i]);
-      do_vec_index_to_swizzle(prog->_LinkedShaders[i]->ir);
    }
 
    return true;
diff --git a/src/compiler/glsl/lower_vec_index_to_swizzle.cpp b/src/compiler/glsl/lower_vec_index_to_swizzle.cpp
deleted file mode 100644
index fdbad16a34f1..000000000000
--- a/src/compiler/glsl/lower_vec_index_to_swizzle.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright © 2010 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_vec_index_to_swizzle.cpp
- *
- * Turns constant indexing into vector types to swizzles.  This will
- * let other swizzle-aware optimization passes catch these constructs,
- * and codegen backends not have to worry about this case.
- */
-
-#include "ir.h"
-#include "ir_rvalue_visitor.h"
-#include "ir_optimization.h"
-#include "compiler/glsl_types.h"
-#include "main/macros.h"
-
-namespace {
-
-class ir_vec_index_to_swizzle_visitor : public ir_rvalue_visitor {
-public:
-   ir_vec_index_to_swizzle_visitor()
-   {
-      progress = false;
-   }
-
-   ir_rvalue *convert_vector_extract_to_swizzle(ir_rvalue *val);
-
-   virtual void handle_rvalue(ir_rvalue **);
-
-   bool progress;
-};
-
-} /* anonymous namespace */
-
-void
-ir_vec_index_to_swizzle_visitor::handle_rvalue(ir_rvalue **rv)
-{
-   if (*rv == NULL)
-      return;
-
-   ir_expression *const expr = (*rv)->as_expression();
-   if (expr == NULL || expr->operation != ir_binop_vector_extract)
-      return;
-
-   void *mem_ctx = ralloc_parent(expr);
-   ir_constant *const idx =
-      expr->operands[1]->constant_expression_value(mem_ctx);
-   if (idx == NULL)
-      return;
-
-   this->progress = true;
-
-   /* Page 40 of the GLSL 1.20 spec says:
-    *
-    *     "When indexing with non-constant expressions, behavior is undefined
-    *     if the index is negative, or greater than or equal to the size of
-    *     the vector."
-    *
-    * The quoted spec text mentions non-constant expressions, but this code
-    * operates on constants.  These constants are the result of non-constant
-    * expressions that have been optimized to constants.  The common case here
-    * is a loop counter from an unrolled loop that is used to index a vector.
-    *
-    * The ir_swizzle constructor gets angry if the index is negative or too
-    * large.  For simplicity sake, just clamp the index to [0, size-1].
-    */
-   const int i = CLAMP(idx->value.i[0], 0,
-                       (int) expr->operands[0]->type->vector_elements - 1);
-
-   *rv = new(mem_ctx) ir_swizzle(expr->operands[0], i, 0, 0, 0, 1);
-}
-
-bool
-do_vec_index_to_swizzle(exec_list *instructions)
-{
-   ir_vec_index_to_swizzle_visitor v;
-
-   v.run(instructions);
-
-   return v.progress;
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 72b19865e586..ac7cc3339136 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -168,7 +168,6 @@ files_libglsl = files(
   'lower_subroutine.cpp',
   'lower_tess_level.cpp',
   'lower_vec_index_to_cond_assign.cpp',
-  'lower_vec_index_to_swizzle.cpp',
   'lower_vector_derefs.cpp',
   'lower_vector_insert.cpp',
   'opt_algebraic.cpp',
diff --git a/src/compiler/glsl/test_optpass.cpp b/src/compiler/glsl/test_optpass.cpp
index a34e00be38cc..da9a8e699a4a 100644
--- a/src/compiler/glsl/test_optpass.cpp
+++ b/src/compiler/glsl/test_optpass.cpp
@@ -99,8 +99,6 @@ do_optimization(struct exec_list *ir, const char *optimization,
       return do_tree_grafting(ir);
    } else if (strcmp(optimization, "do_vec_index_to_cond_assign") == 0) {
       return do_vec_index_to_cond_assign(ir);
-   } else if (strcmp(optimization, "do_vec_index_to_swizzle") == 0) {
-      return do_vec_index_to_swizzle(ir);
    } else if (strcmp(optimization, "lower_discard") == 0) {
       return lower_discard(ir);
    } else if (sscanf(optimization, "lower_instructions ( %d ) ",
-- 
GitLab

