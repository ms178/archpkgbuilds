From 20bcf8e08dbb5f450e6810f787180df160803b4f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 30 May 2023 15:47:20 +0800
Subject: [PATCH 1/2] ac/nir,radv: add 1 dword to LS/HS vertex stride

This reduce LDS bank conflict and align with radeonsi,
so we don't assume LDS access 16 byte aligned for both
driver.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 18 ++++++------------
 src/amd/vulkan/nir/radv_nir_lower_abi.c      |  2 +-
 src/amd/vulkan/radv_shader.h                 | 16 ++++++++++++++--
 3 files changed, 21 insertions(+), 15 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index d1dbee3e0ae00..29167499e0a30 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -245,8 +245,7 @@ lower_ls_output_store(nir_builder *b,
    unsigned write_mask = nir_intrinsic_write_mask(intrin);

    nir_ssa_def *off = nir_iadd_nuw(b, base_off_var, io_off);
-   nir_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask,
-                    .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+   nir_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask);

    /* NOTE: don't remove the store_output intrinsic on GFX9+ when tcs_in_out_eq,
     * it will be used by same-invocation TCS input loads.
@@ -403,8 +402,7 @@ lower_hs_per_vertex_input_load(nir_builder *b,
    nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);

    nir_ssa_def *off = hs_per_vertex_input_lds_offset(b, st, intrin);
-   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off,
-                          .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off);
 }

 static nir_ssa_def *
@@ -453,8 +451,7 @@ lower_hs_output_store(nir_builder *b,

    if (write_to_lds) {
       nir_ssa_def *lds_off = hs_output_lds_offset(b, st, intrin);
-      nir_store_shared(b, store_val, lds_off, .write_mask = write_mask,
-                       .align_mul = 16u, .align_offset = (component * 4u) % 16u);
+      nir_store_shared(b, store_val, lds_off, .write_mask = write_mask);
    }

    nir_ssa_def *ret = NIR_LOWER_INSTR_PROGRESS_REPLACE;
@@ -483,8 +480,7 @@ lower_hs_output_load(nir_builder *b,
                      lower_tess_io_state *st)
 {
    nir_ssa_def *off = hs_output_lds_offset(b, st, intrin);
-   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off,
-                          .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off);
 }

 static void
@@ -611,14 +607,12 @@ hs_emit_write_tess_factors(nir_shader *shader,
       /* Load all tessellation factors (aka. tess levels) from LDS. */
       if (tess_lvl_out_written) {
          tessfactors_outer = nir_load_shared(b, outer_comps, 32, lds_base,
-                                             .base = st->tcs_tess_lvl_out_loc,
-                                             .align_mul = 16u);
+                                             .base = st->tcs_tess_lvl_out_loc);
       }

       if (inner_comps && tess_lvl_in_written) {
          tessfactors_inner = nir_load_shared(b, inner_comps, 32, lds_base,
-                                             .base = st->tcs_tess_lvl_in_loc,
-                                             .align_mul = 16u);
+                                             .base = st->tcs_tess_lvl_in_loc);
       }
    }

diff --git a/src/amd/vulkan/nir/radv_nir_lower_abi.c b/src/amd/vulkan/nir/radv_nir_lower_abi.c
index 898affcbdc684..301f4f03ec594 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_abi.c
@@ -277,7 +277,7 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
    case nir_intrinsic_load_lshs_vertex_stride_amd: {
       unsigned io_num = stage == MESA_SHADER_VERTEX ? s->info->vs.num_linked_outputs
                                                     : s->info->tcs.num_linked_inputs;
-      replacement = nir_imm_int(b, io_num * 16);
+      replacement = nir_imm_int(b, get_tcs_input_vertex_stride(io_num));
       break;
    }
    case nir_intrinsic_load_esgs_vertex_stride_amd: {
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 5e893e5746994..fcf9db835389a 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -682,13 +682,25 @@ radv_shader_part_unref(struct radv_device *device, struct radv_shader_part *shad
       radv_shader_part_destroy(device, shader_part);
 }

+static inline unsigned
+get_tcs_input_vertex_stride(unsigned tcs_num_inputs)
+{
+   unsigned stride = tcs_num_inputs * 16;
+
+   /* Add 1 dword to reduce LDS bank conflicts. */
+   if (stride)
+      stride += 4;
+
+   return stride;
+}
+
 static inline unsigned
 calculate_tess_lds_size(enum amd_gfx_level gfx_level, unsigned tcs_num_input_vertices,
                         unsigned tcs_num_output_vertices, unsigned tcs_num_inputs,
                         unsigned tcs_num_patches, unsigned tcs_num_outputs,
                         unsigned tcs_num_patch_outputs)
 {
-   unsigned input_vertex_size = tcs_num_inputs * 16;
+   unsigned input_vertex_size = get_tcs_input_vertex_stride(tcs_num_inputs);
    unsigned output_vertex_size = tcs_num_outputs * 16;

    unsigned input_patch_size = tcs_num_input_vertices * input_vertex_size;
@@ -717,7 +729,7 @@ get_tcs_num_patches(unsigned tcs_num_input_vertices, unsigned tcs_num_output_ver
                     unsigned tcs_num_patch_outputs, unsigned tess_offchip_block_dw_size,
                     enum amd_gfx_level gfx_level, enum radeon_family family)
 {
-   uint32_t input_vertex_size = tcs_num_inputs * 16;
+   uint32_t input_vertex_size = get_tcs_input_vertex_stride(tcs_num_inputs);
    uint32_t input_patch_size = tcs_num_input_vertices * input_vertex_size;
    uint32_t output_vertex_size = tcs_num_outputs * 16;
    uint32_t pervertex_output_patch_size = tcs_num_output_vertices * output_vertex_size;
--
GitLab


From fbba8818e0abd1037216c4e23fe2519a66556389 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 31 May 2023 16:33:34 +0800
Subject: [PATCH 2/2] ac/nir,radv: add 1 dword to ES/GS item size

This reduce LDS bank conflict and align with radeonsi,
so we don't assume LDS access 16 byte aligned for both
driver.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 6 ++----
 src/amd/vulkan/radv_shader_info.c            | 6 ++++++
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 45b64177b0985..badeb07db165a 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -166,8 +166,7 @@ lower_es_output_store(nir_builder *b,
       /* GFX9+: ES is merged into GS, data is passed through LDS. */
       nir_ssa_def *vertex_idx = nir_build_load_local_invocation_index(b);
       nir_ssa_def *off = nir_iadd(b, nir_imul_imm(b, vertex_idx, st->esgs_itemsize), io_off);
-      nir_build_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask,
-                             .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+      nir_build_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask);
    }

    nir_instr_remove(instr);
@@ -273,8 +272,7 @@ lower_gs_per_vertex_input_load(nir_builder *b,
    nir_ssa_def *off = gs_per_vertex_input_offset(b, st, intrin);

    if (st->gfx_level >= GFX9)
-      return nir_build_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off,
-                                   .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+      return nir_build_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off);

    unsigned wave_size = 64u; /* GFX6-8 only support wave64 */
    nir_ssa_def *ring = nir_build_load_ring_esgs_amd(b);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 2deb4496b0ef1..c8f73ad7597fe 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1478,6 +1478,12 @@ radv_link_shaders_info(struct radv_device *device,

          /* Compute the ESGS item size for VS or TES as ES. */
          producer->info.esgs_itemsize = num_outputs_written * 16;
+
+          /* For the ESGS ring in LDS, add 1 dword to reduce LDS bank
+           * conflicts, i.e. each vertex will start on a different bank.
+           */
+         if (device->physical_device->rad_info.gfx_level >= GFX9 && producer->info.esgs_itemsize)
+            producer->info.esgs_itemsize += 4;
       }

       /* Compute NGG info (GFX10+) or GS info. */
--
GitLab

From e723b95a9ae28a81ec7cb98af6f405636a8209dd Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 11:10:18 +0800
Subject: [PATCH 04/15] radeonsi: add scratch_offset arg for aco tcs

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index f6ce7585e6e20..1c580362b0a3e 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -431,6 +431,10 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tess_offchip_offset);
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tcs_factor_offset);
 
+      /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
+      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+         ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
+
       /* VGPRs */
       ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.tcs_patch_id);
       ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.tcs_rel_ids);
-- 
GitLab


From df9483e681957879970e0e27b0c96d844c917239 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 13:50:22 +0800
Subject: [PATCH 05/15] radeonsi: lower nir_load_tess_rel_patch_id_amd in abi
 for aco

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_nir_lower_abi.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 3c6660cbbdf2b..c6661df43ff70 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -586,6 +586,18 @@ static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_s
       assert(s->esgs_ring);
       replacement = s->esgs_ring;
       break;
+   case nir_intrinsic_load_tess_rel_patch_id_amd:
+      /* LLVM need to replace patch id arg, so have to be done in LLVM backend. */
+      if (!shader->use_aco)
+         return false;
+
+      if (stage == MESA_SHADER_TESS_CTRL) {
+         replacement = ac_nir_unpack_arg(b, &args->ac, args->ac.tcs_rel_ids, 0, 8);
+      } else {
+         assert(stage == MESA_SHADER_TESS_EVAL);
+         replacement = ac_nir_load_arg(b, &args->ac, args->ac.tes_rel_patch_id);
+      }
+      break;
    default:
       return false;
    }
-- 
GitLab


From 284992e854b26afdc3453fd22421dcd85a758aa3 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 14:58:37 +0800
Subject: [PATCH 06/15] ac/llvm,radeonsi: lower nir_load_ring_tess_offchip_amd
 in abi

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  1 -
 .../drivers/radeonsi/si_nir_lower_abi.c       | 33 ++++++++++++++-----
 .../drivers/radeonsi/si_shader_internal.h     |  2 --
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  8 -----
 .../drivers/radeonsi/si_shader_llvm_tess.c    |  6 ----
 5 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index c318502da106e..cb5f9d8e40390 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3200,7 +3200,6 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_base_vertex:
    case nir_intrinsic_load_first_vertex:
    case nir_intrinsic_load_tess_rel_patch_id_amd:
-   case nir_intrinsic_load_ring_tess_offchip_amd:
    case nir_intrinsic_load_ring_attr_amd:
    case nir_intrinsic_load_ring_gsvs_amd:
    case nir_intrinsic_load_lds_ngg_scratch_base_amd:
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index c6661df43ff70..192b6c9cc0e2b 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -18,6 +18,7 @@ struct lower_abi_state {
    struct si_shader_args *args;
 
    nir_ssa_def *esgs_ring;
+   nir_ssa_def *tess_offchip_ring;
 };
 
 #define GET_FIELD_NIR(field) \
@@ -157,13 +158,18 @@ fetch_framebuffer(nir_builder *b, struct si_shader_args *args,
                                   .access = ACCESS_CAN_REORDER);
 }
 
-static nir_ssa_def *build_tess_factor_ring_desc(nir_builder *b, struct si_screen *screen,
-                                                struct si_shader_args *args)
+static nir_ssa_def *build_tess_ring_desc(nir_builder *b, struct si_screen *screen,
+                                         struct si_shader_args *args)
 {
-   nir_ssa_def *addr = ac_nir_load_arg(b, &args->ac, args->tcs_out_lds_layout);
-   /* TCS only receives high 13 bits of the address. */
-   addr = nir_iand_imm(b, addr, 0xfff80000);
-   addr = nir_iadd_imm(b, addr, screen->hs.tess_offchip_ring_size);
+   nir_ssa_def *addr;
+   if (b->shader->info.stage == MESA_SHADER_TESS_CTRL) {
+      addr = ac_nir_load_arg(b, &args->ac, args->tcs_out_lds_layout);
+      /* TCS only receives high 13 bits of the address. */
+      addr = nir_iand_imm(b, addr, 0xfff80000);
+   } else {
+      assert(b->shader->info.stage == MESA_SHADER_TESS_EVAL);
+      addr = ac_nir_load_arg(b, &args->ac, args->tes_offchip_addr);
+   }
 
    uint32_t rsrc3 =
       S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
@@ -229,6 +235,9 @@ static void preload_reusable_variables(nir_builder *b, struct lower_abi_state *s
        (key->ge.as_es || sel->stage == MESA_SHADER_GEOMETRY)) {
       s->esgs_ring = build_esgs_ring_desc(b, sel->screen->info.gfx_level, s->args);
    }
+
+   if (sel->stage == MESA_SHADER_TESS_CTRL || sel->stage == MESA_SHADER_TESS_EVAL)
+      s->tess_offchip_ring = build_tess_ring_desc(b, sel->screen, s->args);
 }
 
 static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_state *s)
@@ -496,9 +505,13 @@ static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_s
       replacement = fetch_framebuffer(b, args, sel, key);
       break;
    }
-   case nir_intrinsic_load_ring_tess_factors_amd:
-      replacement = build_tess_factor_ring_desc(b, sel->screen, args);
+   case nir_intrinsic_load_ring_tess_factors_amd: {
+      assert(s->tess_offchip_ring);
+      nir_ssa_def *addr = nir_channel(b, s->tess_offchip_ring, 0);
+      addr = nir_iadd_imm(b, addr, sel->screen->hs.tess_offchip_ring_size);
+      replacement = nir_vector_insert_imm(b, s->tess_offchip_ring, addr, 0);
       break;
+   }
    case nir_intrinsic_load_ring_tess_factors_offset_amd:
       replacement = ac_nir_load_arg(b, &args->ac, args->ac.tcs_factor_offset);
       break;
@@ -598,6 +611,10 @@ static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_s
          replacement = ac_nir_load_arg(b, &args->ac, args->ac.tes_rel_patch_id);
       }
       break;
+   case nir_intrinsic_load_ring_tess_offchip_amd:
+      assert(s->tess_offchip_ring);
+      replacement = s->tess_offchip_ring;
+      break;
    default:
       return false;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 28f7e16636df0..e2b493256941a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -98,7 +98,6 @@ struct si_shader_context {
 
    /* Preloaded descriptors. */
    LLVMValueRef gsvs_ring[4];
-   LLVMValueRef tess_offchip_ring;
    LLVMValueRef instance_divisor_constbuf;
 
    LLVMValueRef gs_ngg_emit;
@@ -200,7 +199,6 @@ void si_llvm_gs_build_end(struct si_shader_context *ctx);
 
 /* si_shader_llvm_tess.c */
 LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx);
-void si_llvm_preload_tess_rings(struct si_shader_context *ctx);
 void si_llvm_ls_build_end(struct si_shader_context *ctx);
 void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key,
                               bool separate_epilog);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 1c5a11dc9278e..b79c4493988e1 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -672,9 +672,6 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
 
    switch (intrin->intrinsic) {
-   case nir_intrinsic_load_ring_tess_offchip_amd:
-      return ctx->tess_offchip_ring;
-
    case nir_intrinsic_load_tess_rel_patch_id_amd:
       return si_get_rel_patch_id(ctx);
 
@@ -780,11 +777,6 @@ static bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shade
 
    case MESA_SHADER_TESS_CTRL:
       si_llvm_init_tcs_callbacks(ctx);
-      si_llvm_preload_tess_rings(ctx);
-      break;
-
-   case MESA_SHADER_TESS_EVAL:
-      si_llvm_preload_tess_rings(ctx);
       break;
 
    case MESA_SHADER_GEOMETRY:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 66053b02a55b9..b5bbc3b7f3606 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -212,12 +212,6 @@ static LLVMValueRef get_tess_ring_descriptor(struct si_shader_context *ctx, enum
    return ac_build_gather_values(&ctx->ac, desc, 4);
 }
 
-void si_llvm_preload_tess_rings(struct si_shader_context *ctx)
-{
-   ctx->tess_offchip_ring = get_tess_ring_descriptor(
-      ctx, ctx->stage == MESA_SHADER_TESS_CTRL ? TESS_OFFCHIP_RING_TCS : TESS_OFFCHIP_RING_TES);
-}
-
 static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMTypeRef type,
                                              LLVMValueRef vertex_index, LLVMValueRef param_index,
                                              unsigned driver_location, unsigned component,
-- 
GitLab


From 80ec655e42ffa4b57e8c42ae8682418ab50f1526 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 15:10:10 +0800
Subject: [PATCH 07/15] radeonsi: enable aco support for mono standalone tcs

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 1c580362b0a3e..952975c93fbf4 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2331,6 +2331,7 @@ static void si_determine_use_aco(struct si_shader *shader)
 
    switch (sel->stage) {
    case MESA_SHADER_VERTEX:
+   case MESA_SHADER_TESS_CTRL:
       shader->use_aco = shader->is_monolithic && !si_is_multi_part_shader(shader);
       break;
    case MESA_SHADER_FRAGMENT:
-- 
GitLab


From 5eab3eb5d5d71fa32a777dafda6d71168c0438ca Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 15:44:01 +0800
Subject: [PATCH 08/15] radeonsi: add scratch_offset arg for aco tes

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 952975c93fbf4..b1a6027699122 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -621,6 +621,10 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tess_offchip_offset);
       }
 
+      /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
+      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+         ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
+
       /* VGPRs */
       declare_tes_input_vgprs(args);
       break;
-- 
GitLab


From 9a4a2ac5cdb8602aa4ee9582e32091f034d09f58 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 16:25:58 +0800
Subject: [PATCH 09/15] radeonsi: init tes aco shader info fields

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 7c60a623375f9..ea9878ec1daff 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -82,6 +82,9 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info)
       info->vs.as_es = key->ge.as_es;
       info->vs.as_ls = key->ge.as_ls;
       break;
+   case MESA_SHADER_TESS_EVAL:
+      info->tes.as_es = key->ge.as_es;
+      break;
    case MESA_SHADER_FRAGMENT:
       info->ps.num_interp = si_get_ps_num_interp(shader);
       info->ps.spi_ps_input = shader->config.spi_ps_input_ena;
-- 
GitLab


From 3ef86eaa0101a52fb6a8cda5694129fdf0057a08 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 17:40:02 +0800
Subject: [PATCH 10/15] radeonsi: update lds size for tes

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index b1a6027699122..681b352837843 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -936,7 +936,8 @@ static bool upload_binary_elf(struct si_screen *sscreen, struct si_shader *shade
 
 static void calculate_needed_lds_size(struct si_screen *sscreen, struct si_shader *shader)
 {
-   if (shader->selector->stage == MESA_SHADER_VERTEX && !shader->key.ge.as_ls) {
+   if ((shader->selector->stage == MESA_SHADER_VERTEX && !shader->key.ge.as_ls) ||
+       shader->selector->stage == MESA_SHADER_TESS_EVAL) {
       unsigned size_in_dw = 0;
       if (shader->key.ge.as_es || shader->key.ge.as_ngg)
          size_in_dw += shader->gs_info.esgs_ring_size;
-- 
GitLab


From ef7c859dc8a7a0c4babdfdd16e3c5b0c5d5b7020 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Tue, 23 May 2023 15:45:20 +0800
Subject: [PATCH 11/15] radeonsi: enable aco support for standalone tes

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 681b352837843..9a4365990f316 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2339,6 +2339,9 @@ static void si_determine_use_aco(struct si_shader *shader)
    case MESA_SHADER_TESS_CTRL:
       shader->use_aco = shader->is_monolithic && !si_is_multi_part_shader(shader);
       break;
+   case MESA_SHADER_TESS_EVAL:
+      shader->use_aco = !si_is_multi_part_shader(shader);
+      break;
    case MESA_SHADER_FRAGMENT:
       shader->use_aco = shader->is_monolithic;
       break;
-- 
GitLab


From a800a52ec0bf6d5c67ab7a06fe1b5c0edb08de37 Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Thu, 1 Jun 2023 15:12:50 +0800
Subject: [PATCH 12/15] radeonsi: add scratch_offset arg for aco gs

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 9a4365990f316..b3e464df707d8 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -635,6 +635,10 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.gs2vs_offset);
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.gs_wave_id);
 
+      /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
+      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+         ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
+
       /* VGPRs */
       ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[0]);
       ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[1]);
-- 
GitLab


From 7a5b303325617f375618b9fd89cbbeb2c528bc2d Mon Sep 17 00:00:00 2001
From: Qiang Yu <qiang.yu@amd.com>
Date: Fri, 2 Jun 2023 16:25:47 +0800
Subject: [PATCH 13/15] ac/llvm,radeonsi: lower nir_load_ring_gsvs_amd in abi

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  1 -
 .../drivers/radeonsi/si_nir_lower_abi.c       | 84 +++++++++++++++++++
 .../drivers/radeonsi/si_shader_internal.h     |  2 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 14 ----
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 80 ------------------
 5 files changed, 84 insertions(+), 97 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index cb5f9d8e40390..8e8d3c7864f6a 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3201,7 +3201,6 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_first_vertex:
    case nir_intrinsic_load_tess_rel_patch_id_amd:
    case nir_intrinsic_load_ring_attr_amd:
-   case nir_intrinsic_load_ring_gsvs_amd:
    case nir_intrinsic_load_lds_ngg_scratch_base_amd:
    case nir_intrinsic_load_lds_ngg_gs_out_vertex_base_amd:
       result = ctx->abi->intrinsic_load(ctx->abi, instr);
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 192b6c9cc0e2b..a28cbd2c8eaec 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -19,6 +19,7 @@ struct lower_abi_state {
 
    nir_ssa_def *esgs_ring;
    nir_ssa_def *tess_offchip_ring;
+   nir_ssa_def *gsvs_ring[4];
 };
 
 #define GET_FIELD_NIR(field) \
@@ -224,6 +225,80 @@ static nir_ssa_def *build_esgs_ring_desc(nir_builder *b, enum amd_gfx_level gfx_
    return nir_vec(b, vec, 4);
 }
 
+static void build_gsvs_ring_desc(nir_builder *b, struct lower_abi_state *s)
+{
+   const struct si_shader_selector *sel = s->shader->selector;
+   const union si_shader_key *key = &s->shader->key;
+
+   if (s->shader->is_gs_copy_shader) {
+      s->gsvs_ring[0] = si_nir_load_internal_binding(b, s->args, SI_RING_GSVS, 4);
+   } else if (sel->stage == MESA_SHADER_GEOMETRY && !key->ge.as_ngg) {
+      nir_ssa_def *base_addr = si_nir_load_internal_binding(b, s->args, SI_RING_GSVS, 2);
+      base_addr = nir_pack_64_2x32(b, base_addr);
+
+      /* The conceptual layout of the GSVS ring is
+       *   v0c0 .. vLv0 v0c1 .. vLc1 ..
+       * but the real memory layout is swizzled across
+       * threads:
+       *   t0v0c0 .. t15v0c0 t0v1c0 .. t15v1c0 ... t15vLcL
+       *   t16v0c0 ..
+       * Override the buffer descriptor accordingly.
+       */
+
+      for (unsigned stream = 0; stream < 4; stream++) {
+         unsigned num_components = sel->info.num_stream_output_components[stream];
+         if (!num_components)
+            continue;
+
+         nir_ssa_def *desc[4];
+         desc[0] = nir_unpack_64_2x32_split_x(b, base_addr);
+         desc[1] = nir_unpack_64_2x32_split_y(b, base_addr);
+
+         unsigned stride = 4 * num_components * sel->info.base.gs.vertices_out;
+         /* Limit on the stride field for <= GFX7. */
+         assert(stride < (1 << 14));
+
+         desc[1] = nir_ior_imm(
+            b, desc[1], S_008F04_STRIDE(stride) | S_008F04_SWIZZLE_ENABLE_GFX6(1));
+
+         unsigned num_records = s->shader->wave_size;
+         desc[2] = nir_imm_int(b, num_records);
+
+         uint32_t rsrc3 =
+            S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) |
+            S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
+            S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) |
+            S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
+            S_008F0C_INDEX_STRIDE(1) | /* index_stride = 16 (elements) */
+            S_008F0C_ADD_TID_ENABLE(1);
+
+         if (sel->screen->info.gfx_level >= GFX10) {
+            rsrc3 |=
+               S_008F0C_FORMAT(V_008F0C_GFX10_FORMAT_32_FLOAT) |
+               S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_DISABLED) |
+               S_008F0C_RESOURCE_LEVEL(1);
+         } else {
+            /* If MUBUF && ADD_TID_ENABLE, DATA_FORMAT means STRIDE[14:17] on gfx8-9, so set 0. */
+            unsigned data_format =
+               sel->screen->info.gfx_level == GFX8 || sel->screen->info.gfx_level == GFX9 ?
+               0 : V_008F0C_BUF_DATA_FORMAT_32;
+
+            rsrc3 |=
+               S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
+               S_008F0C_DATA_FORMAT(data_format) |
+               S_008F0C_ELEMENT_SIZE(1); /* element_size = 4 (bytes) */
+         }
+
+         desc[3] = nir_imm_int(b, rsrc3);
+
+         s->gsvs_ring[stream] = nir_vec(b, desc, 4);
+
+         /* next stream's desc addr */
+         base_addr = nir_iadd_imm(b, base_addr, stride * num_records);
+      }
+   }
+}
+
 static void preload_reusable_variables(nir_builder *b, struct lower_abi_state *s)
 {
    const struct si_shader_selector *sel = s->shader->selector;
@@ -238,6 +313,8 @@ static void preload_reusable_variables(nir_builder *b, struct lower_abi_state *s
 
    if (sel->stage == MESA_SHADER_TESS_CTRL || sel->stage == MESA_SHADER_TESS_EVAL)
       s->tess_offchip_ring = build_tess_ring_desc(b, sel->screen, s->args);
+
+   build_gsvs_ring_desc(b, s);
 }
 
 static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_state *s)
@@ -615,6 +692,13 @@ static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_s
       assert(s->tess_offchip_ring);
       replacement = s->tess_offchip_ring;
       break;
+   case nir_intrinsic_load_ring_gsvs_amd: {
+      unsigned stream_id = nir_intrinsic_stream_id(intrin);
+      /* Unused nir_load_ring_gsvs_amd may not be eliminated yet. */
+      replacement = s->gsvs_ring[stream_id] ?
+         s->gsvs_ring[stream_id] : nir_ssa_undef(b, 4, 32);
+      break;
+   }
    default:
       return false;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index e2b493256941a..3914c896f5945 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -97,7 +97,6 @@ struct si_shader_context {
    struct ac_llvm_compiler *compiler;
 
    /* Preloaded descriptors. */
-   LLVMValueRef gsvs_ring[4];
    LLVMValueRef instance_divisor_constbuf;
 
    LLVMValueRef gs_ngg_emit;
@@ -194,7 +193,6 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
 LLVMValueRef si_is_es_thread(struct si_shader_context *ctx);
 LLVMValueRef si_is_gs_thread(struct si_shader_context *ctx);
 void si_llvm_es_build_end(struct si_shader_context *ctx);
-void si_preload_gs_rings(struct si_shader_context *ctx);
 void si_llvm_gs_build_end(struct si_shader_context *ctx);
 
 /* si_shader_llvm_tess.c */
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index b79c4493988e1..3580d73e81613 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -675,9 +675,6 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_tess_rel_patch_id_amd:
       return si_get_rel_patch_id(ctx);
 
-   case nir_intrinsic_load_ring_gsvs_amd:
-      return ctx->gsvs_ring[nir_intrinsic_stream_id(intrin)];
-
    case nir_intrinsic_load_lds_ngg_scratch_base_amd:
       return LLVMBuildPtrToInt(ctx->ac.builder, ctx->gs_ngg_scratch.value, ctx->ac.i32, "");
 
@@ -764,15 +761,6 @@ static bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shade
             ac_build_load_to_sgpr(
                &ctx->ac, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
       }
-
-      /* preload GSVS ring for GS copy shader */
-      if (shader->is_gs_copy_shader) {
-         ctx->gsvs_ring[0] =
-            ac_build_load_to_sgpr(
-               &ctx->ac,
-               ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings),
-               LLVMConstInt(ctx->ac.i32, SI_RING_GSVS, 0));
-      }
       break;
 
    case MESA_SHADER_TESS_CTRL:
@@ -793,8 +781,6 @@ static bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shade
             ctx->ac.module, LLVMArrayType(ctx->ac.i32, 0), "ngg_emit", AC_ADDR_SPACE_LDS);
          LLVMSetLinkage(ctx->gs_ngg_emit, LLVMExternalLinkage);
          LLVMSetAlignment(ctx->gs_ngg_emit, 4);
-      } else {
-         si_preload_gs_rings(ctx);
       }
       break;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 2dd04d4a199c6..d13e373b75129 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -75,83 +75,3 @@ void si_llvm_gs_build_end(struct si_shader_context *ctx)
    if (ctx->screen->info.gfx_level >= GFX9)
       ac_build_endif(&ctx->ac, ctx->merged_wrap_if_label);
 }
-
-void si_preload_gs_rings(struct si_shader_context *ctx)
-{
-   if (ctx->ac.gfx_level >= GFX11)
-      return;
-
-   const struct si_shader_selector *sel = ctx->shader->selector;
-   LLVMBuilderRef builder = ctx->ac.builder;
-   LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_RING_GSVS, 0);
-   LLVMValueRef base_ring = ac_build_load_to_sgpr(&ctx->ac,
-      ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings), offset);
-
-   /* The conceptual layout of the GSVS ring is
-    *   v0c0 .. vLv0 v0c1 .. vLc1 ..
-    * but the real memory layout is swizzled across
-    * threads:
-    *   t0v0c0 .. t15v0c0 t0v1c0 .. t15v1c0 ... t15vLcL
-    *   t16v0c0 ..
-    * Override the buffer descriptor accordingly.
-    */
-   LLVMTypeRef v2i64 = LLVMVectorType(ctx->ac.i64, 2);
-   uint64_t stream_offset = 0;
-
-   for (unsigned stream = 0; stream < 4; ++stream) {
-      unsigned num_components;
-      unsigned stride;
-      unsigned num_records;
-      LLVMValueRef ring, tmp;
-
-      num_components = sel->info.num_stream_output_components[stream];
-      if (!num_components)
-         continue;
-
-      stride = 4 * num_components * sel->info.base.gs.vertices_out;
-
-      /* Limit on the stride field for <= GFX7. */
-      assert(stride < (1 << 14));
-
-      num_records = ctx->ac.wave_size;
-
-      ring = LLVMBuildBitCast(builder, base_ring, v2i64, "");
-      tmp = LLVMBuildExtractElement(builder, ring, ctx->ac.i32_0, "");
-      tmp = LLVMBuildAdd(builder, tmp, LLVMConstInt(ctx->ac.i64, stream_offset, 0), "");
-      stream_offset += stride * ctx->ac.wave_size;
-
-      ring = LLVMBuildInsertElement(builder, ring, tmp, ctx->ac.i32_0, "");
-      ring = LLVMBuildBitCast(builder, ring, ctx->ac.v4i32, "");
-      tmp = LLVMBuildExtractElement(builder, ring, ctx->ac.i32_1, "");
-      tmp = LLVMBuildOr(
-         builder, tmp,
-         LLVMConstInt(ctx->ac.i32, S_008F04_STRIDE(stride) | S_008F04_SWIZZLE_ENABLE_GFX6(1), 0), "");
-      ring = LLVMBuildInsertElement(builder, ring, tmp, ctx->ac.i32_1, "");
-      ring = LLVMBuildInsertElement(builder, ring, LLVMConstInt(ctx->ac.i32, num_records, 0),
-                                    LLVMConstInt(ctx->ac.i32, 2, 0), "");
-
-      uint32_t rsrc3 =
-         S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) | S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
-         S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) | S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W) |
-         S_008F0C_INDEX_STRIDE(1) | /* index_stride = 16 (elements) */
-         S_008F0C_ADD_TID_ENABLE(1);
-
-      if (ctx->ac.gfx_level >= GFX10) {
-         rsrc3 |= S_008F0C_FORMAT(V_008F0C_GFX10_FORMAT_32_FLOAT) |
-                  S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_DISABLED) | S_008F0C_RESOURCE_LEVEL(1);
-      } else {
-         /* If MUBUF && ADD_TID_ENABLE, DATA_FORMAT means STRIDE[14:17] on gfx8-9, so set 0. */
-         unsigned data_format = ctx->ac.gfx_level == GFX8 || ctx->ac.gfx_level == GFX9 ?
-                                   0 : V_008F0C_BUF_DATA_FORMAT_32;
-
-         rsrc3 |= S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
-                  S_008F0C_DATA_FORMAT(data_format) |
-                  S_008F0C_ELEMENT_SIZE(1); /* element_size = 4 (bytes) */
-      }
-
-      ring = LLVMBuildInsertElement(builder, ring, LLVMConstInt(ctx->ac.i32, rsrc3, false),
-                                    LLVMConstInt(ctx->ac.i32, 3, 0), "");
-
-      ctx->gsvs_ring[stream] = ring;
-   }
-}
-- 
GitLab


From b5f21ed4a1350c070c6112080ae1753c851af122 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 1 Jun 2023 14:45:18 +0800
Subject: [PATCH 14/15] radeonsi: enable aco for standalone gs

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index b3e464df707d8..8128fb50dcd85 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2344,6 +2344,7 @@ static void si_determine_use_aco(struct si_shader *shader)
       shader->use_aco = shader->is_monolithic && !si_is_multi_part_shader(shader);
       break;
    case MESA_SHADER_TESS_EVAL:
+   case MESA_SHADER_GEOMETRY:
       shader->use_aco = !si_is_multi_part_shader(shader);
       break;
    case MESA_SHADER_FRAGMENT:
-- 
GitLab


From 36d25ac9deef10c22a74a867895a2e21d4942bfd Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 5 Jun 2023 17:31:23 +0800
Subject: [PATCH 15/15] radeonsi: enable aco support for gs copy shader

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c     | 20 ++++++++++++++++----
 src/gallium/drivers/radeonsi/si_shader_aco.c |  5 +++--
 2 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 8128fb50dcd85..03350e3c5a104 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -184,7 +184,10 @@ static void declare_streamout_params(struct si_shader_args *args, struct si_shad
 
 unsigned si_get_max_workgroup_size(const struct si_shader *shader)
 {
-   switch (shader->selector->stage) {
+   gl_shader_stage stage = shader->is_gs_copy_shader ?
+      MESA_SHADER_VERTEX : shader->selector->stage;
+
+   switch (stage) {
    case MESA_SHADER_VERTEX:
    case MESA_SHADER_TESS_EVAL:
       /* Use the largest workgroup size for streamout */
@@ -2345,7 +2348,7 @@ static void si_determine_use_aco(struct si_shader *shader)
       break;
    case MESA_SHADER_TESS_EVAL:
    case MESA_SHADER_GEOMETRY:
-      shader->use_aco = !si_is_multi_part_shader(shader);
+      shader->use_aco = !si_is_multi_part_shader(shader) || shader->is_gs_copy_shader;
       break;
    case MESA_SHADER_FRAGMENT:
       shader->use_aco = shader->is_monolithic;
@@ -2415,6 +2418,8 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
                                    sscreen->options.vrs2x2,
                                    output_info);
 
+   si_determine_use_aco(shader);
+
    struct si_shader_args args;
    si_init_shader_args(shader, &args);
 
@@ -2422,13 +2427,20 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
 
    si_nir_opts(gs_selector->screen, nir, false);
 
+   /* aco only accept scalar const */
+   if (shader->use_aco)
+      NIR_PASS_V(nir, nir_lower_load_const_to_scalar);
+
    if (si_can_dump_shader(sscreen, MESA_SHADER_GEOMETRY, SI_DUMP_NIR)) {
       fprintf(stderr, "GS Copy Shader:\n");
       nir_print_shader(nir, stderr);
    }
 
-   bool ok = false;
-   if (si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir)) {
+   bool ok = shader->use_aco ?
+      si_aco_compile_shader(shader, &args, nir, debug) :
+      si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir);
+
+   if (ok) {
       assert(!shader->config.scratch_bytes_per_wave);
       ok = si_shader_binary_upload(sscreen, shader, 0);
       si_shader_dump(sscreen, shader, debug, stderr, true);
diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index ea9878ec1daff..0836ed36840ec 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -62,6 +62,7 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info)
 {
    const struct si_shader_selector *sel = shader->selector;
    const union si_shader_key *key = &shader->key;
+   gl_shader_stage stage = shader->is_gs_copy_shader ? MESA_SHADER_VERTEX : sel->stage;
 
    info->wave_size = shader->wave_size;
    info->workgroup_size = si_get_max_workgroup_size(shader);
@@ -71,13 +72,13 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info)
 
    info->image_2d_view_of_3d = sel->screen->info.gfx_level == GFX9;
 
-   if (sel->stage <= MESA_SHADER_GEOMETRY && key->ge.as_ngg && !key->ge.as_es) {
+   if (stage <= MESA_SHADER_GEOMETRY && key->ge.as_ngg && !key->ge.as_es) {
       info->is_ngg = true;
       info->has_ngg_culling = key->ge.opt.ngg_culling;
       info->has_ngg_early_prim_export = gfx10_ngg_export_prim_early(shader);
    }
 
-   switch (sel->stage) {
+   switch (stage) {
    case MESA_SHADER_VERTEX:
       info->vs.as_es = key->ge.as_es;
       info->vs.as_ls = key->ge.as_ls;
-- 
GitLab

