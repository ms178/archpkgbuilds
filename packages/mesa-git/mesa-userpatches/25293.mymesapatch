From b122f1ced70445875ad49e25a993a5542caaaee9 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Tue, 19 Sep 2023 11:04:25 +0200
Subject: [PATCH 1/3] ac/llvm: Fix DENORM_FLUSH_TO_ZERO with exact instructions

cc: mesa-stable
---
 src/amd/ci/radv-navi21-llvm-fails.txt |  4 ----
 src/amd/llvm/ac_nir_to_llvm.c         | 17 +++++------------
 2 files changed, 5 insertions(+), 16 deletions(-)

diff --git a/src/amd/ci/radv-navi21-llvm-fails.txt b/src/amd/ci/radv-navi21-llvm-fails.txt
index de7e83135d98e..084239e3dc670 100644
--- a/src/amd/ci/radv-navi21-llvm-fails.txt
+++ b/src/amd/ci/radv-navi21-llvm-fails.txt
@@ -1,8 +1,4 @@
 
-dEQP-VK.spirv_assembly.instruction.compute.float_controls.fp32.input_args.tanh_denorm_flush_to_zero,Fail
-dEQP-VK.spirv_assembly.instruction.graphics.float_controls.fp32.input_args.tanh_denorm_flush_to_zero_frag,Fail
-dEQP-VK.spirv_assembly.instruction.graphics.float_controls.fp32.input_args.tanh_denorm_flush_to_zero_vert,Fail
-
 dEQP-VK.draw.renderpass.shader_invocation.helper_invocation,Fail
 
 dEQP-VK.fragment_shading_barycentric.weights.pipeline_topology_dynamic.msaa_interpolate_at_offset.triangle_fan.perspective,Fail
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index dae2473802fba..91f9fc4402d35 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -585,12 +585,6 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
    case nir_op_fneg:
       src[0] = ac_to_float(&ctx->ac, src[0]);
       result = LLVMBuildFNeg(ctx->ac.builder, src[0], "");
-      if (ctx->ac.float_mode == AC_FLOAT_MODE_DENORM_FLUSH_TO_ZERO) {
-         /* fneg will be optimized by backend compiler with sign
-          * bit removed via XOR. This is probably a LLVM bug.
-          */
-         result = ac_build_canonicalize(&ctx->ac, result, instr->def.bit_size);
-      }
       break;
    case nir_op_inot:
       result = LLVMBuildNot(ctx->ac.builder, src[0], "");
@@ -734,12 +728,6 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
    case nir_op_fabs:
       result =
          emit_intrin_1f_param(&ctx->ac, "llvm.fabs", ac_to_float_type(&ctx->ac, def_type), src[0]);
-      if (ctx->ac.float_mode == AC_FLOAT_MODE_DENORM_FLUSH_TO_ZERO) {
-         /* fabs will be optimized by backend compiler with sign
-          * bit removed via AND.
-          */
-         result = ac_build_canonicalize(&ctx->ac, result, instr->def.bit_size);
-      }
       break;
    case nir_op_fsat:
       src[0] = ac_to_float(&ctx->ac, src[0]);
@@ -1279,6 +1267,11 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
    }
 
    if (result) {
+      LLVMTypeKind type_kind = LLVMGetTypeKind(LLVMTypeOf(result));
+      bool is_float = type_kind == LLVMHalfTypeKind || type_kind == LLVMFloatTypeKind || type_kind == LLVMDoubleTypeKind;
+      if (ctx->ac.float_mode == AC_FLOAT_MODE_DENORM_FLUSH_TO_ZERO && is_float)
+         result = ac_build_canonicalize(&ctx->ac, result, instr->def.bit_size);
+
       result = ac_to_integer_or_pointer(&ctx->ac, result);
       ctx->ssa_defs[instr->def.index] = result;
    }
-- 
GitLab


From 7eea04c45afc15a7bd6d7cdbb3cbe7c42d9608bf Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Tue, 19 Sep 2023 16:00:33 +0200
Subject: [PATCH 2/3] ac/llvm: Enable helper invocations for vote_all/any

cc: mesa-stable
---
 src/amd/ci/radv-navi21-llvm-fails.txt | 15 ---------------
 src/amd/llvm/ac_llvm_build.c          | 14 ++++++++++++--
 src/amd/llvm/ac_llvm_build.h          |  2 ++
 src/amd/llvm/ac_nir_to_llvm.c         |  2 ++
 4 files changed, 16 insertions(+), 17 deletions(-)

diff --git a/src/amd/ci/radv-navi21-llvm-fails.txt b/src/amd/ci/radv-navi21-llvm-fails.txt
index 084239e3dc670..ee15c84115a6d 100644
--- a/src/amd/ci/radv-navi21-llvm-fails.txt
+++ b/src/amd/ci/radv-navi21-llvm-fails.txt
@@ -15,18 +15,3 @@ dEQP-VK.pipeline.monolithic.multisample.storage_image.79x31_1.r32g32b32a32_sfloa
 dEQP-VK.pipeline.monolithic.multisample.storage_image.79x31_1.r8g8b8a8_unorm.samples_8,Fail
 dEQP-VK.pipeline.monolithic.multisample.storage_image.79x31_4.r32g32b32a32_sfloat.samples_8,Fail
 dEQP-VK.pipeline.monolithic.multisample.storage_image.79x31_4.r8g8b8a8_unorm.samples_8,Fail
-
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_double_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_f16vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_i16vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_i64vec2_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_i64vec3_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_i64vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_i8vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_int64_t_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_u16vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_u64vec3_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_u64vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_u8vec4_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_uint64_t_fragment,Fail
-dEQP-VK.subgroups.vote.frag_helper.subgroupallequal_vec4_fragment,Fail
diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 6aa6ce1f7e5a7..aebb6255d034d 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -2985,7 +2985,7 @@ LLVMValueRef ac_build_ds_swizzle(struct ac_llvm_context *ctx, LLVMValueRef src,
    return LLVMBuildBitCast(ctx->builder, ret, src_type, "");
 }
 
-static LLVMValueRef ac_build_wwm(struct ac_llvm_context *ctx, LLVMValueRef src)
+static LLVMValueRef ac_build_mode(struct ac_llvm_context *ctx, LLVMValueRef src, const char *mode)
 {
    LLVMTypeRef src_type = LLVMTypeOf(src);
    unsigned bitsize = ac_get_elem_bits(ctx, src_type);
@@ -2998,7 +2998,7 @@ static LLVMValueRef ac_build_wwm(struct ac_llvm_context *ctx, LLVMValueRef src)
       src = LLVMBuildZExt(ctx->builder, src, ctx->i32, "");
 
    ac_build_type_name_for_intr(LLVMTypeOf(src), type, sizeof(type));
-   snprintf(name, sizeof(name), "llvm.amdgcn.wwm.%s", type);
+   snprintf(name, sizeof(name), "llvm.amdgcn.%s.%s", mode, type);
    ret = ac_build_intrinsic(ctx, name, LLVMTypeOf(src), (LLVMValueRef[]){src}, 1, 0);
 
    if (bitsize < 32)
@@ -3007,6 +3007,16 @@ static LLVMValueRef ac_build_wwm(struct ac_llvm_context *ctx, LLVMValueRef src)
    return LLVMBuildBitCast(ctx->builder, ret, src_type, "");
 }
 
+static LLVMValueRef ac_build_wwm(struct ac_llvm_context *ctx, LLVMValueRef src)
+{
+   return ac_build_mode(ctx, src, "wwm");
+}
+
+LLVMValueRef ac_build_wqm(struct ac_llvm_context *ctx, LLVMValueRef src)
+{
+   return ac_build_mode(ctx, src, "wqm");
+}
+
 static LLVMValueRef ac_build_set_inactive(struct ac_llvm_context *ctx, LLVMValueRef src,
                                           LLVMValueRef inactive)
 {
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 00ce0a9ed390c..3d373ff9d705c 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -467,6 +467,8 @@ LLVMValueRef ac_build_writelane(struct ac_llvm_context *ctx, LLVMValueRef src, L
 LLVMValueRef ac_build_mbcnt_add(struct ac_llvm_context *ctx, LLVMValueRef mask, LLVMValueRef add_src);
 LLVMValueRef ac_build_mbcnt(struct ac_llvm_context *ctx, LLVMValueRef mask);
 
+LLVMValueRef ac_build_wqm(struct ac_llvm_context *ctx, LLVMValueRef src);
+
 LLVMValueRef ac_build_inclusive_scan(struct ac_llvm_context *ctx, LLVMValueRef src, nir_op op);
 
 LLVMValueRef ac_build_exclusive_scan(struct ac_llvm_context *ctx, LLVMValueRef src, nir_op op);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 91f9fc4402d35..ba8adfe377cc8 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3347,10 +3347,12 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    }
    case nir_intrinsic_vote_all: {
       result = ac_build_vote_all(&ctx->ac, get_src(ctx, instr->src[0]));
+      result = ac_build_wqm(&ctx->ac, result);
       break;
    }
    case nir_intrinsic_vote_any: {
       result = ac_build_vote_any(&ctx->ac, get_src(ctx, instr->src[0]));
+      result = ac_build_wqm(&ctx->ac, result);
       break;
    }
    case nir_intrinsic_shuffle:
-- 
GitLab


From 14ae679464fc9adf04823d16672aa34f097f8a99 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Tue, 19 Sep 2023 16:07:46 +0200
Subject: [PATCH 3/3] ac/llvm: Enable helper invocations for quad OPs

cc: mesa-stable
---
 src/amd/ci/radv-navi21-llvm-fails.txt | 2 --
 src/amd/llvm/ac_llvm_build.c          | 4 ++--
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index aebb6255d034d..947e08ede1366 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -3569,9 +3569,9 @@ LLVMValueRef ac_build_quad_swizzle(struct ac_llvm_context *ctx, LLVMValueRef src
 {
    unsigned mask = dpp_quad_perm(lane0, lane1, lane2, lane3);
    if (ctx->gfx_level >= GFX8) {
-      return ac_build_dpp(ctx, src, src, mask, 0xf, 0xf, false);
+      return ac_build_wqm(ctx, ac_build_dpp(ctx, src, src, mask, 0xf, 0xf, false));
    } else {
-      return ac_build_ds_swizzle(ctx, src, (1 << 15) | mask);
+      return ac_build_wqm(ctx, ac_build_ds_swizzle(ctx, src, (1 << 15) | mask));
    }
 }
 
-- 
GitLab

