From 94df28edf15bf30e261fba713ea9b6a2284a756c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 20 Apr 2023 12:35:01 +0200
Subject: [PATCH 1/6] nir/opt_dead_cf: Remove if branches with undef condition.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Treat them as if the undef were false.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/compiler/nir/nir_opt_dead_cf.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/compiler/nir/nir_opt_dead_cf.c b/src/compiler/nir/nir_opt_dead_cf.c
index 36675ab3de4b..6f85fa127f7c 100644
--- a/src/compiler/nir/nir_opt_dead_cf.c
+++ b/src/compiler/nir/nir_opt_dead_cf.c
@@ -280,6 +280,9 @@ dead_cf_block(nir_block *block)
       if (nir_src_is_const(following_if->condition)) {
          opt_constant_if(following_if, nir_src_as_bool(following_if->condition));
          return true;
+      } else if (nir_src_is_undef(following_if->condition)) {
+         opt_constant_if(following_if, false);
+         return true;
       }
 
       if (node_is_dead(&following_if->cf_node)) {
-- 
GitLab


From fd5eaa8b6901491cd69bf933b0e040c4c0579ad1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 8 Jul 2023 18:00:45 -0400
Subject: [PATCH 2/6] nir: fix constant evaluation of fddx/fddy sourcing Inf &
 NaN constant

A derivative of NaN is NaN.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/compiler/nir/nir_opcodes.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_opcodes.py b/src/compiler/nir/nir_opcodes.py
index e4d87aa61267..a66c37b4c0d1 100644
--- a/src/compiler/nir/nir_opcodes.py
+++ b/src/compiler/nir/nir_opcodes.py
@@ -332,12 +332,12 @@ unop_convert("frexp_sig", tfloat, tfloat, "int n; dst = frexp(src0, &n);")
 deriv_template = """
 Calculate the screen-space partial derivative using {} derivatives of the input
 with respect to the {}-axis. The constant folding is trivial as the derivative
-of a constant is 0.
+of a constant is 0 if the constant is not Inf or NaN.
 """
 
 for mode, suffix in [("either fine or coarse", ""), ("fine", "_fine"), ("coarse", "_coarse")]:
     for axis in ["x", "y"]:
-        unop(f"fdd{axis}{suffix}", tfloat, "0.0",
+        unop(f"fdd{axis}{suffix}", tfloat, "isfinite(src0) ? 0.0 : NAN",
              description = deriv_template.format(mode, axis.upper()))
 
 # Floating point pack and unpack operations.
-- 
GitLab


From d69d332018e49a2ceff28f6dd1cd9b05ccc598af Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 8 Jul 2023 17:09:15 -0400
Subject: [PATCH 3/6] nir/algebraic: collapse ALU opcodes sourcing NaN

Undef will be replaced by NaN whenever it leads to elimination of FP
instructions. This implements the elimination part.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/compiler/nir/nir_opt_algebraic.py | 43 +++++++++++++++++++++++++++
 src/compiler/nir/nir_search_helpers.h | 32 ++++++++++++++++++++
 2 files changed, 75 insertions(+)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 374ddb681260..e3c92b9be6d5 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -35,6 +35,7 @@ b = 'b'
 c = 'c'
 d = 'd'
 e = 'e'
+NAN = math.nan
 
 signed_zero_inf_nan_preserve_16 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 16)'
 signed_zero_inf_nan_preserve_32 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 32)'
@@ -2742,6 +2743,48 @@ for s in range(0, 31):
          'options->avoid_ternary_with_two_constants'),
     ])
 
+# NaN propagation: Binary opcodes. If any operand is NaN, replace it with NaN.
+# (unary opcodes with NaN are evaluated by nir_opt_constant_folding, not here)
+for op in ['fadd', 'fdiv', 'fmod', 'fmul', 'fpow', 'frem', 'fsub']:
+    optimizations += [((op, '#a(is_nan)', b), NAN)]
+    optimizations += [((op, a, '#b(is_nan)'), NAN)] # some opcodes are not commutative
+
+# NaN propagation: Trinary opcodes. If any operand is NaN, replace it with NaN.
+for op in ['ffma', 'flrp']:
+    optimizations += [((op, '#a(is_nan)', b, c), NAN)]
+    optimizations += [((op, a, '#b(is_nan)', c), NAN)] # some opcodes are not commutative
+    optimizations += [((op, a, b, '#c(is_nan)'), NAN)]
+
+# NaN propagation: FP min/max. Pick the non-NaN operand.
+for op in ['fmin', 'fmax']:
+    optimizations += [((op, '#a(is_nan)', b), b)] # commutative
+
+# NaN propagation: ldexp is NaN if the first operand is NaN.
+optimizations += [(('ldexp', '#a(is_nan)', b), NAN)]
+
+# NaN propagation: Dot opcodes. If any component is NaN, replace it with NaN.
+for op in ['fdot2', 'fdot3', 'fdot4', 'fdot5', 'fdot8', 'fdot16']:
+    optimizations += [((op, '#a(is_any_comp_nan)', b), NAN)] # commutative
+
+# NaN propagation: FP comparison opcodes except !=. Replace it with false.
+for op in ['feq', 'fge', 'flt']:
+    optimizations += [((op, '#a(is_nan)', b), False)]
+    optimizations += [((op, a, '#b(is_nan)'), False)] # some opcodes are not commutative
+
+# NaN propagation: FP comparison opcodes using !=. Replace it with true.
+# Operator != is the only opcode where a comparison with NaN returns true.
+for op in ['fneu']:
+    optimizations += [((op, '#a(is_nan)', b), True)] # commutative
+
+# NaN propagation: FP comparison opcodes except != returning FP 0 or 1.
+for op in ['seq', 'sge', 'slt']:
+    optimizations += [((op, '#a(is_nan)', b), 0.0)]
+    optimizations += [((op, a, '#b(is_nan)'), 0.0)] # some opcodes are not commutative
+
+# NaN propagation: FP comparison opcodes using != returning FP 0 or 1.
+# Operator != is the only opcode where a comparison with NaN returns true.
+optimizations += [(('sne', '#a(is_nan)', b), 1.0)] # commutative
+
 # This section contains optimizations to propagate downsizing conversions of
 # constructed vectors into vectors of downsized components. Whether this is
 # useful depends on the SIMD semantics of the backend. On a true SIMD machine,
diff --git a/src/compiler/nir/nir_search_helpers.h b/src/compiler/nir/nir_search_helpers.h
index a9d19963a7a1..1e2c0d65e3be 100644
--- a/src/compiler/nir/nir_search_helpers.h
+++ b/src/compiler/nir/nir_search_helpers.h
@@ -111,6 +111,38 @@ is_bitcount2(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
    return true;
 }
 
+static inline bool
+is_nan(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
+       unsigned src, unsigned num_components, const uint8_t *swizzle)
+{
+   /* only constant srcs: */
+   if (!nir_src_is_const(instr->src[src].src))
+      return false;
+
+   for (unsigned i = 0; i < num_components; i++) {
+      if (!isnan(nir_src_comp_as_float(instr->src[src].src, swizzle[i])))
+         return false;
+   }
+
+   return true;
+}
+
+static inline bool
+is_any_comp_nan(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
+                unsigned src, unsigned num_components, const uint8_t *swizzle)
+{
+   /* only constant srcs: */
+   if (!nir_src_is_const(instr->src[src].src))
+      return false;
+
+   for (unsigned i = 0; i < num_components; i++) {
+      if (isnan(nir_src_comp_as_float(instr->src[src].src, swizzle[i])))
+         return true;
+   }
+
+   return false;
+}
+
 #define MULTIPLE(test)                                                  \
 static inline bool                                                      \
 is_unsigned_multiple_of_ ## test(UNUSED struct hash_table *ht,          \
-- 
GitLab


From a63283c270ad70147fbe3e844b82a36d025136c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 6 Jul 2023 04:52:16 -0400
Subject: [PATCH 4/6] nir: replace undef only used by ALU opcodes with 0 or NaN

If undef is consumed by an FP opcode, replace it with NaN to eliminate
that opcode, else replace it with 0, but there are exceptions, such as
when undef is used by stores or phis, it's not touched.

This also contains workarounds for viewperf shaders.

radeonsi:
TOTALS FROM AFFECTED SHADERS (1987/58918)
  Code Size: 5158692 -> 5143796 (-0.29 %) bytes
  Max Waves: 22456 -> 22513 (0.25 %)
  Outputs: 3726 -> 3726 (0.00 %)
  Patch Outputs: 0 -> 0 (0.00 %)

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/compiler/nir/nir_opt_undef.c | 152 ++++++++++++++++++++++++++++++-
 1 file changed, 150 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_opt_undef.c b/src/compiler/nir/nir_opt_undef.c
index effd9d0057a4..980a283ea1c0 100644
--- a/src/compiler/nir/nir_opt_undef.c
+++ b/src/compiler/nir/nir_opt_undef.c
@@ -23,12 +23,18 @@
 
 #include "nir.h"
 #include "nir_builder.h"
+#include "util/mesa-sha1.h"
+#include <math.h>
 
 /** @file nir_opt_undef.c
  *
  * Handles optimization of operations involving ssa_undef.
  */
 
+struct undef_options {
+   bool disallow_undef_to_nan;
+};
+
 /**
  * Turn conditional selects between an undef and some other value into a move
  * of that other value (on the assumption that the condition's going to be
@@ -189,10 +195,124 @@ opt_undef_pack(nir_builder *b, nir_alu_instr *alu)
    return true;
 }
 
+struct visit_info {
+   bool replace_undef_with_constant;
+   bool prefer_nan;
+   bool must_keep_undef;
+};
+
+/**
+ * Analyze an undef use to see if replacing undef with a constant is
+ * beneficial.
+ */
+static void
+visit_undef_use(nir_src *src, struct visit_info *info)
+{
+   nir_instr *instr = src->parent_instr;
+
+   if (src->is_if) {
+      /* If the use is "if", keep undef because the branch will be eliminated
+       * by nir_opt_dead_cf.
+       */
+      info->must_keep_undef = true;
+      return;
+   }
+
+   if (instr->type == nir_instr_type_alu) {
+      /* Replacing undef with a constant is only beneficial with ALU
+       * instructions because it can eliminate them or simplify them.
+       */
+      nir_alu_instr *alu = nir_instr_as_alu(instr);
+
+      /* Follow movs and vecs.
+       *
+       * Note that all vector component uses are followed and swizzles are
+       * ignored.
+       */
+      if (alu->op == nir_op_mov || nir_op_is_vec(alu->op)) {
+         if (alu->dest.dest.is_ssa) {
+            nir_foreach_use_including_if(next_src, &alu->dest.dest.ssa) {
+               visit_undef_use(next_src, info);
+            }
+         }
+         return;
+      }
+
+      unsigned num_srcs = nir_op_infos[alu->op].num_inputs;
+
+      for (unsigned i = 0; i < num_srcs; i++) {
+         if (&alu->src[i].src != src)
+            continue;
+
+         if (nir_op_is_selection(alu->op) && i != 0) {
+            /* nir_opt_algebraic can eliminate a select opcode only if src0 is
+             * a constant. If the undef use is src1 or src2, it will be
+             * handled by opt_undef_csel.
+             */
+            continue;
+         }
+
+         info->replace_undef_with_constant = true;
+         if (nir_op_infos[alu->op].input_types[i] & nir_type_float &&
+             alu->op != nir_op_fmulz &&
+             (alu->op != nir_op_ffmaz || i == 2))
+            info->prefer_nan = true;
+      }
+   } else {
+      /* If the use is not ALU, don't replace undef. We need to preserve
+       * undef for stores and phis because those are handled differently,
+       * and replacing undef with a constant would result in worse code.
+       */
+      info->must_keep_undef = true;
+      return;
+   }
+}
+
+/**
+ * Replace ssa_undef used by ALU opcodes with 0 or NaN, whichever eliminates
+ * more code.
+ *
+ * Replace it with NaN if an FP opcode uses undef, which will cause the opcode
+ * to be eliminated by nir_opt_algebraic. 0 would not eliminate the FP opcode.
+ */
+static bool
+replace_ssa_undef(nir_builder *b, nir_instr *instr,
+                  const struct undef_options *options)
+{
+   nir_ssa_undef_instr *undef = nir_instr_as_ssa_undef(instr);
+   struct visit_info info = {0};
+
+   nir_foreach_use_including_if(src, &undef->def) {
+      visit_undef_use(src, &info);
+   }
+
+   if (info.must_keep_undef || !info.replace_undef_with_constant)
+      return false;
+
+   /* If undef is used as float, replace it with NaN, which will
+    * eliminate all FP instructions that consume it. Else, replace it
+    * with 0, which is more likely to eliminate non-FP instructions.
+    */
+   float new_value =
+      info.prefer_nan && !options->disallow_undef_to_nan ? NAN : 0;
+
+   b->cursor = nir_before_instr(&undef->instr);
+   nir_ssa_def *replacement =
+      nir_replicate(b, nir_imm_floatN_t(b, new_value, undef->def.bit_size),
+                    undef->def.num_components);
+   nir_ssa_def_rewrite_uses_after(&undef->def, replacement, &undef->instr);
+   nir_instr_remove(&undef->instr);
+   return true;
+}
+
 static bool
 nir_opt_undef_instr(nir_builder *b, nir_instr *instr, void *data)
 {
-   if (instr->type == nir_instr_type_alu) {
+   const struct undef_options *options = data;
+
+   if (instr->type == nir_instr_type_ssa_undef) {
+      return replace_ssa_undef(b, instr, options);
+   } else if (instr->type == nir_instr_type_alu) {
       nir_alu_instr *alu = nir_instr_as_alu(instr);
       return opt_undef_csel(alu) || opt_undef_vecN(b, alu) || opt_undef_pack(b, alu);
    } else if (instr->type == nir_instr_type_intrinsic) {
@@ -206,9 +326,37 @@ nir_opt_undef_instr(nir_builder *b, nir_instr *instr, void *data)
 bool
 nir_opt_undef(nir_shader *shader)
 {
+   struct undef_options options = {0};
+
+   /* Disallow the undef->NaN transformation only for those shaders where
+    * it's known to break rendering. These are shader source SHA1s printed by
+    * nir_print_shader().
+    */
+   uint32_t shader_sha1s[][SHA1_DIGEST_LENGTH32] = {
+      /* Viewperf13/CATIA_car_01 */
+      {0x4746a4a4, 0xe3b27d27, 0xe6d2b0fb, 0xb7e9ceb3, 0x973e6152}, /* Taillights */
+      {0xc49cc90d, 0xd7208212, 0x726502ea, 0xe1fe62c0, 0xb62fbd1f}, /* Grill */
+      {0xde23f35b, 0xb6fa45ae, 0x96da7e6b, 0x5a6e4a60, 0xce0b6b31}, /* Headlights */
+      {0xdf36242c, 0x0705db59, 0xf1ddac9b, 0xcd1c8466, 0x4c73203b}, /* Rims */
+
+      /* Viewperf13/CATIA_car_04 */
+      {0x631da72a, 0xc971e849, 0xd6489a15, 0xf7c8dddb, 0xe8efd982}, /* Headlights */
+      {0x85984b88, 0xd16b8fee, 0x0d49d97b, 0x5f6cc66e, 0xadcafad9}, /* Rims */
+      {0xad023488, 0x09930735, 0xb0567e58, 0x336dce36, 0xe3c1e448}, /* Tires */
+      {0xdcc4a549, 0x587873fa, 0xeed94361, 0x9a47cbff, 0x846d0167}, /* Windows */
+      {0xfa0074a2, 0xef868430, 0x87935a0c, 0x19bc96be, 0xb5b95c74}, /* Body */
+   };
+
+   for (unsigned i = 0; i < ARRAY_SIZE(shader_sha1s); i++) {
+      if (_mesa_printed_sha1_equal(shader->info.source_sha1, shader_sha1s[i])) {
+         options.disallow_undef_to_nan = true;
+         break;
+      }
+   }
+
    return nir_shader_instructions_pass(shader,
                                        nir_opt_undef_instr,
                                        nir_metadata_block_index |
                                        nir_metadata_dominance,
-                                       NULL);
+                                       &options);
 }
-- 
GitLab


From 6901d31a3ce1449c57d44e285d9e87dc51e2b270 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 8 Jul 2023 19:33:31 -0400
Subject: [PATCH 5/6] nir: remove nir_op_unpack_64 handling from nir_opt_undef

It's no longer needed because undef is replaced with 0 in this case.

It also has a bug that it doesn't freeze the undef value if undef has
multiple uses.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/compiler/nir/nir_opt_undef.c | 23 +----------------------
 1 file changed, 1 insertion(+), 22 deletions(-)

diff --git a/src/compiler/nir/nir_opt_undef.c b/src/compiler/nir/nir_opt_undef.c
index 980a283ea1c0..5765aae78777 100644
--- a/src/compiler/nir/nir_opt_undef.c
+++ b/src/compiler/nir/nir_opt_undef.c
@@ -174,27 +174,6 @@ opt_undef_store(nir_intrinsic_instr *intrin)
    return true;
 }
 
-static bool
-opt_undef_pack(nir_builder *b, nir_alu_instr *alu)
-{
-   switch (alu->op) {
-   case nir_op_unpack_64_2x32_split_x:
-   case nir_op_unpack_64_2x32_split_y:
-   case nir_op_unpack_64_2x32:
-      if (nir_src_is_undef(alu->src[0].src))
-         break;
-      return false;
-   default:
-      return false;
-   }
-   unsigned num_components = nir_dest_num_components(alu->dest.dest);
-   b->cursor = nir_before_instr(&alu->instr);
-   nir_ssa_def *def = nir_ssa_undef(b, num_components, 32);
-   nir_ssa_def_rewrite_uses_after(&alu->dest.dest.ssa, def, &alu->instr);
-   nir_instr_remove(&alu->instr);
-   return true;
-}
-
 struct visit_info {
    bool replace_undef_with_constant;
    bool prefer_nan;
@@ -314,7 +293,7 @@ nir_opt_undef_instr(nir_builder *b, nir_instr *instr, void *data)
       return replace_ssa_undef(b, instr, options);
    } else if (instr->type == nir_instr_type_alu) {
       nir_alu_instr *alu = nir_instr_as_alu(instr);
-      return opt_undef_csel(alu) || opt_undef_vecN(b, alu) || opt_undef_pack(b, alu);
+      return opt_undef_csel(alu) || opt_undef_vecN(b, alu);
    } else if (instr->type == nir_instr_type_intrinsic) {
       nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
       return opt_undef_store(intrin);
-- 
GitLab


From deae0378079e63c64182ac04f2d90c63f9e8b4b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 8 Jul 2023 22:25:19 -0400
Subject: [PATCH 6/6] ac/llvm: don't convert undef to 0 because nir_opt_undef
 does it now

TOTALS FROM AFFECTED SHADERS (29663/58918)
  Code Size: 39163724 -> 37842360 (-3.37 %) bytes
  Max Waves: 394813 -> 396334 (0.39 %)
  Outputs: 84616 -> 84616 (0.00 %)
  Patch Outputs: 0 -> 0 (0.00 %)
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 37 +++----------------
 src/amd/llvm/ac_shader_abi.h                  |  3 --
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  1 -
 3 files changed, 6 insertions(+), 35 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 0f63dc5c1fa3..632bb32c5c58 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4141,44 +4141,19 @@ static void phi_post_pass(struct ac_nir_context *ctx)
    }
 }
 
-static bool is_def_used_in_an_export(const nir_ssa_def *def)
-{
-   nir_foreach_use (use_src, def) {
-      if (use_src->parent_instr->type == nir_instr_type_intrinsic) {
-         nir_intrinsic_instr *instr = nir_instr_as_intrinsic(use_src->parent_instr);
-         if (instr->intrinsic == nir_intrinsic_store_deref)
-            return true;
-      } else if (use_src->parent_instr->type == nir_instr_type_alu) {
-         nir_alu_instr *instr = nir_instr_as_alu(use_src->parent_instr);
-         if (instr->op == nir_op_vec4 && is_def_used_in_an_export(&instr->dest.dest.ssa)) {
-            return true;
-         }
-      }
-   }
-   return false;
-}
-
 static void visit_ssa_undef(struct ac_nir_context *ctx, const nir_ssa_undef_instr *instr)
 {
    unsigned num_components = instr->def.num_components;
    LLVMTypeRef type = LLVMIntTypeInContext(ctx->ac.context, instr->def.bit_size);
 
-   if (!ctx->abi->convert_undef_to_zero || is_def_used_in_an_export(&instr->def)) {
-      LLVMValueRef undef;
+   LLVMValueRef undef;
 
-      if (num_components == 1)
-         undef = LLVMGetUndef(type);
-      else {
-         undef = LLVMGetUndef(LLVMVectorType(type, num_components));
-      }
-      ctx->ssa_defs[instr->def.index] = undef;
-   } else {
-      LLVMValueRef zero = LLVMConstInt(type, 0, false);
-      if (num_components > 1) {
-         zero = ac_build_gather_values_extended(&ctx->ac, &zero, num_components, 0, false);
-      }
-      ctx->ssa_defs[instr->def.index] = zero;
+   if (num_components == 1)
+      undef = LLVMGetUndef(type);
+   else {
+      undef = LLVMGetUndef(LLVMVectorType(type, num_components));
    }
+   ctx->ssa_defs[instr->def.index] = undef;
 }
 
 static bool visit_jump(struct ac_llvm_context *ctx, const nir_jump_instr *instr)
diff --git a/src/amd/llvm/ac_shader_abi.h b/src/amd/llvm/ac_shader_abi.h
index d505482b77ff..4dee4ad2813a 100644
--- a/src/amd/llvm/ac_shader_abi.h
+++ b/src/amd/llvm/ac_shader_abi.h
@@ -79,9 +79,6 @@ struct ac_shader_abi {
    /* Check for Inf interpolation coeff */
    bool kill_ps_if_inf_interp;
 
-   /* Whether undef values must be converted to zero */
-   bool convert_undef_to_zero;
-
    /* Clamp div by 0 (so it won't produce NaN) */
    bool clamp_div_by_zero;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index a2f3ed2232e4..c8b72457b70a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -921,7 +921,6 @@ static bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shade
 
    ctx->abi.clamp_shadow_reference = true;
    ctx->abi.robust_buffer_access = true;
-   ctx->abi.convert_undef_to_zero = true;
    ctx->abi.load_grid_size_from_user_sgpr = true;
    ctx->abi.clamp_div_by_zero = ctx->screen->options.clamp_div_by_zero ||
                                 info->options & SI_PROFILE_CLAMP_DIV_BY_ZERO;
-- 
GitLab

