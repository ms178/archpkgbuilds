--- a/src/amd/vulkan/radv_video.c	2025-06-23 15:01:06.887821752 +0200
+++ b/src/amd/vulkan/radv_video.c	2025-06-23 15:27:25.849511792 +0200
@@ -10,6 +10,14 @@
 #include "drm-uapi/amdgpu_drm.h"
 #endif
 
+#if defined(__GNUC__) || defined(__clang__)
+#define LIKELY(x)   __builtin_expect(!!(x), 1)
+#define UNLIKELY(x) __builtin_expect(!!(x), 0)
+#else
+#define LIKELY(x)   (x)
+#define UNLIKELY(x) (x)
+#endif
+
 #include "util/vl_zscan_data.h"
 #include "vk_video/vulkan_video_codecs_common.h"
 #include "ac_uvd_dec.h"
@@ -113,7 +121,6 @@ radv_vcn_sq_tail(struct radeon_cmdbuf *c
 {
    uint32_t *end;
    uint32_t size_in_dw;
-   uint32_t checksum = 0;
 
    end = &cs->buf[cs->cdw];
 
@@ -128,9 +135,24 @@ radv_vcn_sq_tail(struct radeon_cmdbuf *c
       *sq->signature_ib_total_size_in_dw = size_in_dw;
       *sq->engine_ib_size_of_packages = size_in_dw * sizeof(uint32_t);
 
-      for (int i = 0; i < size_in_dw; i++)
-         checksum += *(sq->signature_ib_checksum + 2 + i);
-
+      uint32_t checksum = 0;
+      const uint32_t *p = sq->signature_ib_checksum + 2;
+      if (LIKELY(size_in_dw >= 4)) {
+         uint32_t c[4] = {0, 0, 0, 0};
+         uint32_t i = 0;
+         for (; i <= size_in_dw - 4; i += 4) {
+            c[0] += p[i + 0];
+            c[1] += p[i + 1];
+            c[2] += p[i + 2];
+            c[3] += p[i + 3];
+         }
+         checksum = c[0] + c[1] + c[2] + c[3];
+         for (; i < size_in_dw; i++)
+            checksum += p[i];
+      } else {
+         for (unsigned i = 0; i < size_in_dw; i++)
+            checksum += p[i];
+      }
       *sq->signature_ib_checksum = checksum;
    }
 }
@@ -369,8 +391,6 @@ calc_ctx_size_h265_main(struct radv_vide
    else
       max_references = MAX2(max_references, 17);
 
-   width = align(width, 16);
-   height = align(height, 16);
    return ((width + 255) / 16) * ((height + 255) / 16) * 16 * max_references + 52 * 1024;
 }
 
@@ -401,7 +421,7 @@ calc_ctx_size_h265_main10(struct radv_vi
 
    num_16x16_block_per_ctb = ((1 << log2_ctb_size) >> 4) * ((1 << log2_ctb_size) >> 4);
    context_buffer_size_per_ctb_row = align(width_in_ctb * num_16x16_block_per_ctb * 16, 256);
-   max_mb_address = (unsigned)ceil(height * 8 / 2048.0);
+   max_mb_address = ((height << 3) + 2047) >> 11;
 
    cm_buffer_size = max_references * context_buffer_size_per_ctb_row * height_in_ctb;
    db_left_tile_pxl_size = coeff_10bit * (max_mb_address * 2 * 2048 + 1024);
@@ -475,7 +495,7 @@ radv_CreateVideoSessionKHR(VkDevice _dev
 
    struct radv_video_session *vid =
       vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*vid), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
-   if (!vid)
+   if (UNLIKELY(!vid))
       return vk_error(instance, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    memset(vid, 0, sizeof(struct radv_video_session));
@@ -580,7 +600,7 @@ radv_DestroyVideoSessionKHR(VkDevice _de
 {
    VK_FROM_HANDLE(radv_device, device, _device);
    VK_FROM_HANDLE(radv_video_session, vid, _session);
-   if (!_session)
+   if (UNLIKELY(!_session))
       return;
 
    vk_object_base_finish(&vid->vk.base);
@@ -599,7 +619,7 @@ radv_CreateVideoSessionParametersKHR(VkD
    const struct radv_instance *instance = radv_physical_device_instance(pdev);
    struct radv_video_session_params *params =
       vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*params), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
-   if (!params)
+   if (UNLIKELY(!params))
       return vk_error(instance, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    VkResult result =
@@ -658,10 +678,10 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
       break;
 #endif
    default:
-      unreachable("unsupported operation");
+      __builtin_unreachable();
    }
 
-   if (cap && !cap->valid)
+   if (UNLIKELY(cap && !cap->valid))
       cap = NULL;
 
    pCapabilities->flags = 0;
@@ -730,7 +750,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
       ext->fieldOffsetGranularity.x = 0;
       ext->fieldOffsetGranularity.y = 0;
       ext->maxLevelIdc = STD_VIDEO_H264_LEVEL_IDC_5_1;
-      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME);
+      memcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME, sizeof(VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_EXTENSION_NAME));
       pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_H264_DECODE_SPEC_VERSION;
       break;
    }
@@ -761,7 +781,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
       if (radv_enable_tier2(pdev))
          pCapabilities->flags |= VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
       ext->maxLevelIdc = STD_VIDEO_H265_LEVEL_IDC_5_1;
-      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME);
+      memcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME, sizeof(VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME));
       pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_SPEC_VERSION;
       break;
    }
@@ -791,7 +811,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
       pCapabilities->maxActiveReferencePictures = RADV_VIDEO_AV1_MAX_NUM_REF_FRAME;
       pCapabilities->flags |= VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
       ext->maxLevel = STD_VIDEO_AV1_LEVEL_6_1; /* For VCN3/4, the only h/w currently with AV1 decode support */
-      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME);
+      memcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME, sizeof(VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_EXTENSION_NAME));
       pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_AV1_DECODE_SPEC_VERSION;
       break;
    }
@@ -803,7 +823,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
       if (pdev->info.vcn_ip_version >= VCN_3_0_0)
          pCapabilities->flags |= VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
       ext->maxLevel = STD_VIDEO_VP9_LEVEL_6_2;
-      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_EXTENSION_NAME);
+      memcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_EXTENSION_NAME, sizeof(VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_EXTENSION_NAME));
       pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_VP9_DECODE_SPEC_VERSION;
       pCapabilities->minCodedExtent.width = 64;
       pCapabilities->minCodedExtent.height = 64;
@@ -843,7 +863,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
       if (pdev->enc_hw_ver >= RADV_VIDEO_ENC_HW_3)
          ext->stdSyntaxFlags |= VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR;
 
-      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME);
+      memcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME, sizeof(VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_EXTENSION_NAME));
       pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_H264_ENCODE_SPEC_VERSION;
       pCapabilities->maxDpbSlots = RADV_VIDEO_H264_MAX_DPB_SLOTS;
       pCapabilities->maxActiveReferencePictures = MAX2(ext->maxPPictureL0ReferenceCount, ext->maxBPictureL0ReferenceCount + ext->maxL1ReferenceCount);
@@ -900,7 +920,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesK
 
       if (pdev->enc_hw_ver >= RADV_VIDEO_ENC_HW_3)
          ext->stdSyntaxFlags |= VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR;
-      strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME);
+      memcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME, sizeof(VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_EXTENSION_NAME));
       pCapabilities->stdHeaderVersion.specVersion = VK_STD_VULKAN_VIDEO_CODEC_H265_ENCODE_SPEC_VERSION;
       pCapabilities->maxDpbSlots = RADV_VIDEO_H265_MAX_DPB_SLOTS;
       pCapabilities->maxActiveReferencePictures = MAX2(ext->maxPPictureL0ReferenceCount, ext->maxBPictureL0ReferenceCount + ext->maxL1ReferenceCount);
@@ -1249,7 +1269,7 @@ send_cmd(struct radv_cmd_buffer *cmd_buf
       cmd_buffer->video.decode_buffer->context_buffer_address_lo = (addr);
       break;
    default:
-      assert(0);
+      __builtin_unreachable();
    }
 }
 
@@ -1316,7 +1336,7 @@ get_h264_msg(struct radv_video_session *
              const struct VkVideoDecodeInfoKHR *frame_info, uint32_t *slice_offset, uint32_t *width_in_samples,
              uint32_t *height_in_samples, void *it_ptr)
 {
-   rvcn_dec_message_avc_t result;
+   rvcn_dec_message_avc_t result = {0};
    const struct VkVideoDecodeH264PictureInfoKHR *h264_pic_info =
       vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_H264_PICTURE_INFO_KHR);
 
@@ -1327,8 +1347,6 @@ get_h264_msg(struct radv_video_session *
 
    *slice_offset = h264_pic_info->pSliceOffsets[0];
 
-   memset(&result, 0, sizeof(result));
-
    switch (sps->profile_idc) {
    case STD_VIDEO_H264_PROFILE_IDC_BASELINE:
       result.profile = RDECODE_H264_PROFILE_BASELINE;
@@ -1442,11 +1460,10 @@ get_h265_msg(struct radv_device *device,
              uint32_t *height_in_samples,
              void *it_ptr)
 {
-   rvcn_dec_message_hevc_t result;
+   rvcn_dec_message_hevc_t result = {0};
    int i, j;
    const struct VkVideoDecodeH265PictureInfoKHR *h265_pic_info =
       vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_H265_PICTURE_INFO_KHR);
-   memset(&result, 0, sizeof(result));
 
    const StdVideoH265SequenceParameterSet *sps = NULL;
    const StdVideoH265PictureParameterSet *pps = NULL;
@@ -1527,11 +1544,8 @@ get_h265_msg(struct radv_device *device,
    result.log2_parallel_merge_level_minus2 = pps->log2_parallel_merge_level_minus2;
    result.init_qp_minus26 = pps->init_qp_minus26;
 
-   for (i = 0; i < 19; ++i)
-      result.column_width_minus1[i] = pps->column_width_minus1[i];
-
-   for (i = 0; i < 21; ++i)
-      result.row_height_minus1[i] = pps->row_height_minus1[i];
+   memcpy(result.column_width_minus1, pps->column_width_minus1, sizeof(result.column_width_minus1));
+   memcpy(result.row_height_minus1, pps->row_height_minus1, sizeof(result.row_height_minus1));
 
    result.num_delta_pocs_ref_rps_idx = h265_pic_info->pStdPictureInfo->NumDeltaPocsOfRefRpsIdx;
    result.curr_poc = h265_pic_info->pStdPictureInfo->PicOrderCntVal;
@@ -1575,11 +1589,10 @@ get_h265_msg(struct radv_device *device,
    }
 
    if (vid->vk.h265.profile_idc == STD_VIDEO_H265_PROFILE_IDC_MAIN_10) {
-      if (vid->vk.picture_format == VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16) {
-         result.p010_mode = 1;
-         result.msb_mode = 1;
-      } else {
-         result.p010_mode = 0;
+      const bool is_native_p010 = (vid->vk.picture_format == VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16);
+      result.p010_mode = is_native_p010;
+      result.msb_mode = is_native_p010;
+      if (UNLIKELY(!is_native_p010)) {
          result.luma_10to8 = 5;
          result.chroma_10to8 = 5;
          result.hevc_reserved[0] = 4; /* sclr_luma10to8 */
@@ -1597,7 +1610,7 @@ get_vp9_msg(struct radv_device *device,
             void *probs_ptr,
             int *update_reference_slot)
 {
-   rvcn_dec_message_vp9_t result;
+   rvcn_dec_message_vp9_t result = {0};
    const struct VkVideoDecodeVP9PictureInfoKHR *vp9_pic_info =
       vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_VP9_PICTURE_INFO_KHR);
    const struct StdVideoDecodeVP9PictureInfo *std_pic_info =
@@ -1608,8 +1621,6 @@ get_vp9_msg(struct radv_device *device,
       assert(frame_info->pSetupReferenceSlot == NULL);
    *update_reference_slot = !intra_only_decoding;
 
-   memset(&result, 0, sizeof(result));
-
    bool lossless = std_pic_info->base_q_idx == 0 && std_pic_info->delta_q_y_dc == 0 &&
       std_pic_info->delta_q_uv_dc == 0 && std_pic_info->delta_q_uv_ac == 0;
 
@@ -1751,7 +1762,7 @@ get_vp9_msg(struct radv_device *device,
       result.ref_frame_map[idx] = slotIndex;
       used_slots |= 1 << slotIndex;
    }
-   for (unsigned j = 0; j < STD_VIDEO_VP9_NUM_REF_FRAMES + 1; j++) {
+   for (unsigned j = 0; j < STD_VIDEO_VP9_NUM_REF_FRAMES + 1 && idx < 8; j++) {
       if ((used_slots & (1 << j)) == 0) {
          result.ref_frame_map[idx] = j;
          used_slots |= 1 << j;
@@ -1795,7 +1806,7 @@ get_av1_msg(struct radv_device *device,
             const struct VkVideoDecodeInfoKHR *frame_info, void *probs_ptr, int *update_reference_slot)
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
-   rvcn_dec_message_av1_t result;
+   rvcn_dec_message_av1_t result = {0};
    unsigned i, j;
    const struct VkVideoDecodeAV1PictureInfoKHR *av1_pic_info =
       vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_AV1_PICTURE_INFO_KHR);
@@ -1805,8 +1816,6 @@ get_av1_msg(struct radv_device *device,
 
    vk_video_get_av1_parameters(&vid->vk, params ? &params->vk : NULL, frame_info, &seq_hdr);
 
-   memset(&result, 0, sizeof(result));
-
    const int intra_only_decoding = vid->vk.max_dpb_slots == 0;
    if (intra_only_decoding)
       assert(frame_info->pSetupReferenceSlot == NULL);
@@ -2088,86 +2097,86 @@ get_av1_msg(struct radv_device *device,
    result.preskip_segid = 0;
    result.last_active_segid = 0;
    for (i = 0; i < 8; i++) {
-      for (j = 0; j < 8; j++) {
-         if (result.feature_mask[i] & (1 << j)) {
-            result.last_active_segid = i;
-            if (j >= 5)
-               result.preskip_segid = 1;
+         for (j = 0; j < 8; j++) {
+               if (result.feature_mask[i] & (1 << j)) {
+                     result.last_active_segid = i;
+                     if (j >= 5)
+                           result.preskip_segid = 1;
+               }
          }
-      }
    }
    result.seg_lossless_flag = 0;
    for (i = 0; i < 8; ++i) {
-      int av1_get_qindex, qindex;
-      int segfeature_active = result.feature_mask[i] & (1 << 0);
-      if (segfeature_active) {
-         int seg_qindex = result.base_qindex + result.feature_data[i][0];
-         av1_get_qindex = seg_qindex < 0 ? 0 : (seg_qindex > 255 ? 255 : seg_qindex);
-      } else {
-         av1_get_qindex = result.base_qindex;
-      }
-      qindex = pi->flags.segmentation_enabled ? av1_get_qindex : result.base_qindex;
-      result.seg_lossless_flag |= (((qindex == 0) && result.y_dc_delta_q == 0 && result.u_dc_delta_q == 0 &&
-                                    result.v_dc_delta_q == 0 && result.u_ac_delta_q == 0 && result.v_ac_delta_q == 0)
-                                   << i);
+         int av1_get_qindex, qindex;
+         int segfeature_active = result.feature_mask[i] & (1 << 0);
+         if (segfeature_active) {
+               int seg_qindex = result.base_qindex + result.feature_data[i][0];
+               av1_get_qindex = seg_qindex < 0 ? 0 : (seg_qindex > 255 ? 255 : seg_qindex);
+         } else {
+               av1_get_qindex = result.base_qindex;
+         }
+         qindex = pi->flags.segmentation_enabled ? av1_get_qindex : result.base_qindex;
+         result.seg_lossless_flag |= (((qindex == 0) && result.y_dc_delta_q == 0 && result.u_dc_delta_q == 0 &&
+         result.v_dc_delta_q == 0 && result.u_ac_delta_q == 0 && result.v_ac_delta_q == 0)
+         << i);
    }
 
    rvcn_dec_film_grain_params_t *fg_params = &result.film_grain;
    fg_params->apply_grain = pi->flags.apply_grain;
    if (fg_params->apply_grain) {
-      rvcn_dec_av1_fg_init_buf_t *fg_buf = (rvcn_dec_av1_fg_init_buf_t *)((char *)probs_ptr + 256);
-      fg_params->random_seed = pi->pFilmGrain->grain_seed;
-      fg_params->grain_scale_shift = pi->pFilmGrain->grain_scale_shift;
-      fg_params->scaling_shift = pi->pFilmGrain->grain_scaling_minus_8 + 8;
-      fg_params->chroma_scaling_from_luma = pi->pFilmGrain->flags.chroma_scaling_from_luma;
-      fg_params->num_y_points = pi->pFilmGrain->num_y_points;
-      fg_params->num_cb_points = pi->pFilmGrain->num_cb_points;
-      fg_params->num_cr_points = pi->pFilmGrain->num_cr_points;
-      fg_params->cb_mult = pi->pFilmGrain->cb_mult;
-      fg_params->cb_luma_mult = pi->pFilmGrain->cb_luma_mult;
-      fg_params->cb_offset = pi->pFilmGrain->cb_offset;
-      fg_params->cr_mult = pi->pFilmGrain->cr_mult;
-      fg_params->cr_luma_mult = pi->pFilmGrain->cr_luma_mult;
-      fg_params->cr_offset = pi->pFilmGrain->cr_offset;
-      fg_params->bit_depth_minus_8 = result.bit_depth_luma_minus8;
-      for (i = 0; i < fg_params->num_y_points; ++i) {
-         fg_params->scaling_points_y[i][0] = pi->pFilmGrain->point_y_value[i];
-         fg_params->scaling_points_y[i][1] = pi->pFilmGrain->point_y_scaling[i];
-      }
-      for (i = 0; i < fg_params->num_cb_points; ++i) {
-         fg_params->scaling_points_cb[i][0] = pi->pFilmGrain->point_cb_value[i];
-         fg_params->scaling_points_cb[i][1] = pi->pFilmGrain->point_cb_scaling[i];
-      }
-      for (i = 0; i < fg_params->num_cr_points; ++i) {
-         fg_params->scaling_points_cr[i][0] = pi->pFilmGrain->point_cr_value[i];
-         fg_params->scaling_points_cr[i][1] = pi->pFilmGrain->point_cr_scaling[i];
-      }
-
-      fg_params->ar_coeff_lag = pi->pFilmGrain->ar_coeff_lag;
-      fg_params->ar_coeff_shift = pi->pFilmGrain->ar_coeff_shift_minus_6 + 6;
-
-      for (i = 0; i < 24; ++i)
-         fg_params->ar_coeffs_y[i] = pi->pFilmGrain->ar_coeffs_y_plus_128[i] - 128;
-
-      for (i = 0; i < 25; ++i) {
-         fg_params->ar_coeffs_cb[i] = pi->pFilmGrain->ar_coeffs_cb_plus_128[i] - 128;
-         fg_params->ar_coeffs_cr[i] = pi->pFilmGrain->ar_coeffs_cr_plus_128[i] - 128;
-      }
-
-      fg_params->overlap_flag = pi->pFilmGrain->flags.overlap_flag;
-      fg_params->clip_to_restricted_range = pi->pFilmGrain->flags.clip_to_restricted_range;
-      ac_vcn_av1_init_film_grain_buffer(pdev->av1_version, fg_params, fg_buf);
+         rvcn_dec_av1_fg_init_buf_t *fg_buf = (rvcn_dec_av1_fg_init_buf_t *)((char *)probs_ptr + 256);
+         fg_params->random_seed = pi->pFilmGrain->grain_seed;
+         fg_params->grain_scale_shift = pi->pFilmGrain->grain_scale_shift;
+         fg_params->scaling_shift = pi->pFilmGrain->grain_scaling_minus_8 + 8;
+         fg_params->chroma_scaling_from_luma = pi->pFilmGrain->flags.chroma_scaling_from_luma;
+         fg_params->num_y_points = pi->pFilmGrain->num_y_points;
+         fg_params->num_cb_points = pi->pFilmGrain->num_cb_points;
+         fg_params->num_cr_points = pi->pFilmGrain->num_cr_points;
+         fg_params->cb_mult = pi->pFilmGrain->cb_mult;
+         fg_params->cb_luma_mult = pi->pFilmGrain->cb_luma_mult;
+         fg_params->cb_offset = pi->pFilmGrain->cb_offset;
+         fg_params->cr_mult = pi->pFilmGrain->cr_mult;
+         fg_params->cr_luma_mult = pi->pFilmGrain->cr_luma_mult;
+         fg_params->cr_offset = pi->pFilmGrain->cr_offset;
+         fg_params->bit_depth_minus_8 = result.bit_depth_luma_minus8;
+         for (i = 0; i < fg_params->num_y_points; ++i) {
+               fg_params->scaling_points_y[i][0] = pi->pFilmGrain->point_y_value[i];
+               fg_params->scaling_points_y[i][1] = pi->pFilmGrain->point_y_scaling[i];
+         }
+         for (i = 0; i < fg_params->num_cb_points; ++i) {
+               fg_params->scaling_points_cb[i][0] = pi->pFilmGrain->point_cb_value[i];
+               fg_params->scaling_points_cb[i][1] = pi->pFilmGrain->point_cb_scaling[i];
+         }
+         for (i = 0; i < fg_params->num_cr_points; ++i) {
+               fg_params->scaling_points_cr[i][0] = pi->pFilmGrain->point_cr_value[i];
+               fg_params->scaling_points_cr[i][1] = pi->pFilmGrain->point_cr_scaling[i];
+         }
+
+         fg_params->ar_coeff_lag = pi->pFilmGrain->ar_coeff_lag;
+         fg_params->ar_coeff_shift = pi->pFilmGrain->ar_coeff_shift_minus_6 + 6;
+
+         for (i = 0; i < 24; ++i)
+               fg_params->ar_coeffs_y[i] = pi->pFilmGrain->ar_coeffs_y_plus_128[i] - 128;
+
+         for (i = 0; i < 25; ++i) {
+               fg_params->ar_coeffs_cb[i] = pi->pFilmGrain->ar_coeffs_cb_plus_128[i] - 128;
+               fg_params->ar_coeffs_cr[i] = pi->pFilmGrain->ar_coeffs_cr_plus_128[i] - 128;
+         }
+
+         fg_params->overlap_flag = pi->pFilmGrain->flags.overlap_flag;
+         fg_params->clip_to_restricted_range = pi->pFilmGrain->flags.clip_to_restricted_range;
+         ac_vcn_av1_init_film_grain_buffer(pdev->av1_version, fg_params, fg_buf);
    }
 
    result.uncompressed_header_size = 0;
    for (i = 0; i < STD_VIDEO_AV1_NUM_REF_FRAMES; ++i) {
-      result.global_motion[i].wmtype = pi->pGlobalMotion->GmType[i];
-      for (j = 0; j < STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS; ++j)
-         result.global_motion[i].wmmat[j] = pi->pGlobalMotion->gm_params[i][j];
+         result.global_motion[i].wmtype = pi->pGlobalMotion->GmType[i];
+         for (j = 0; j < STD_VIDEO_AV1_GLOBAL_MOTION_PARAMS; ++j)
+               result.global_motion[i].wmmat[j] = pi->pGlobalMotion->gm_params[i][j];
    }
    for (i = 0; i < av1_pic_info->tileCount && i < 256; ++i) {
-      result.tile_info[i].offset = av1_pic_info->pTileOffsets[i];
-      result.tile_info[i].size = av1_pic_info->pTileSizes[i];
+         result.tile_info[i].offset = av1_pic_info->pTileOffsets[i];
+         result.tile_info[i].size = av1_pic_info->pTileSizes[i];
    }
 
    return result;
@@ -2179,264 +2188,264 @@ rvcn_dec_message_decode(struct radv_cmd_
                         struct radv_video_session_params *params, void *ptr, void *it_probs_ptr, uint32_t *slice_offset,
                         const struct VkVideoDecodeInfoKHR *frame_info)
 {
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   const struct radv_physical_device *pdev = radv_device_physical(device);
-   rvcn_dec_message_header_t *header;
-   rvcn_dec_message_index_t *index_codec;
-   rvcn_dec_message_decode_t *decode;
-   rvcn_dec_message_index_t *index_dynamic_dpb = NULL;
-   rvcn_dec_message_dynamic_dpb_t *dynamic_dpb = NULL;
-   rvcn_dec_message_dynamic_dpb_t2_t *dynamic_dpb_t2 = NULL;
-   void *codec;
-   unsigned sizes = 0, offset_decode, offset_codec, offset_dynamic_dpb;
-   struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
-   struct radv_image *img = dst_iv->image;
-   struct radv_image_plane *luma = &img->planes[0];
-   struct radv_image_plane *chroma = &img->planes[1];
-   bool use_intra_only_allocation_for_dpb = false;
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      const struct radv_physical_device *pdev = radv_device_physical(device);
+      rvcn_dec_message_header_t *header;
+      rvcn_dec_message_index_t *index_codec;
+      rvcn_dec_message_decode_t *decode;
+      rvcn_dec_message_index_t *index_dynamic_dpb = NULL;
+      rvcn_dec_message_dynamic_dpb_t *dynamic_dpb = NULL;
+      rvcn_dec_message_dynamic_dpb_t2_t *dynamic_dpb_t2 = NULL;
+      void *codec;
+      unsigned sizes = 0, offset_decode, offset_codec, offset_dynamic_dpb;
+      struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
+      struct radv_image *img = dst_iv->image;
+      struct radv_image_plane *luma = &img->planes[0];
+      struct radv_image_plane *chroma = &img->planes[1];
+      bool use_intra_only_allocation_for_dpb = false;
 
-   header = ptr;
-   sizes += sizeof(rvcn_dec_message_header_t);
+      header = ptr;
+      sizes += sizeof(rvcn_dec_message_header_t);
 
-   index_codec = (void *)((char *)header + sizes);
-   sizes += sizeof(rvcn_dec_message_index_t);
-
-   if (vid->dpb_type == DPB_DYNAMIC_TIER_1 || vid->dpb_type == DPB_DYNAMIC_TIER_2) {
-      index_dynamic_dpb = (void *)((char *)header + sizes);
+      index_codec = (void *)((char *)header + sizes);
       sizes += sizeof(rvcn_dec_message_index_t);
-   }
-
-   offset_decode = sizes;
-   decode = (void *)((char *)header + sizes);
-   sizes += sizeof(rvcn_dec_message_decode_t);
-
-   if (vid->dpb_type == DPB_DYNAMIC_TIER_1 || vid->dpb_type == DPB_DYNAMIC_TIER_2) {
-      offset_dynamic_dpb = sizes;
-      if (vid->dpb_type == DPB_DYNAMIC_TIER_1) {
-         dynamic_dpb = (void *)((char *)header + sizes);
-         sizes += sizeof(rvcn_dec_message_dynamic_dpb_t);
-      } else {
-         dynamic_dpb_t2 = (void *)((char *)header + sizes);
-         sizes += sizeof(rvcn_dec_message_dynamic_dpb_t2_t);
-      }
-   }
-
-   offset_codec = sizes;
-   codec = (void *)((char *)header + sizes);
 
-   memset(ptr, 0, sizes);
-
-   header->header_size = sizeof(rvcn_dec_message_header_t);
-   header->total_size = sizes;
-   header->msg_type = RDECODE_MSG_DECODE;
-   header->stream_handle = vid->stream_handle;
-   header->status_report_feedback_number = vid->dbg_frame_cnt++;
+      if (vid->dpb_type == DPB_DYNAMIC_TIER_1 || vid->dpb_type == DPB_DYNAMIC_TIER_2) {
+            index_dynamic_dpb = (void *)((char *)header + sizes);
+            sizes += sizeof(rvcn_dec_message_index_t);
+      }
+
+      offset_decode = sizes;
+      decode = (void *)((char *)header + sizes);
+      sizes += sizeof(rvcn_dec_message_decode_t);
+
+      if (vid->dpb_type == DPB_DYNAMIC_TIER_1 || vid->dpb_type == DPB_DYNAMIC_TIER_2) {
+            offset_dynamic_dpb = sizes;
+            if (vid->dpb_type == DPB_DYNAMIC_TIER_1) {
+                  dynamic_dpb = (void *)((char *)header + sizes);
+                  sizes += sizeof(rvcn_dec_message_dynamic_dpb_t);
+            } else {
+                  dynamic_dpb_t2 = (void *)((char *)header + sizes);
+                  sizes += sizeof(rvcn_dec_message_dynamic_dpb_t2_t);
+            }
+      }
+
+      offset_codec = sizes;
+      codec = (void *)((char *)header + sizes);
+
+      memset(ptr, 0, sizes);
+
+      header->header_size = sizeof(rvcn_dec_message_header_t);
+      header->total_size = sizes;
+      header->msg_type = RDECODE_MSG_DECODE;
+      header->stream_handle = vid->stream_handle;
+      header->status_report_feedback_number = vid->dbg_frame_cnt++;
+
+      header->index[0].message_id = RDECODE_MESSAGE_DECODE;
+      header->index[0].offset = offset_decode;
+      header->index[0].size = sizeof(rvcn_dec_message_decode_t);
+      header->index[0].filled = 0;
+      header->num_buffers = 1;
 
-   header->index[0].message_id = RDECODE_MESSAGE_DECODE;
-   header->index[0].offset = offset_decode;
-   header->index[0].size = sizeof(rvcn_dec_message_decode_t);
-   header->index[0].filled = 0;
-   header->num_buffers = 1;
-
-   index_codec->offset = offset_codec;
-   index_codec->filled = 0;
-   ++header->num_buffers;
-
-   if (vid->dpb_type == DPB_DYNAMIC_TIER_1 || vid->dpb_type == DPB_DYNAMIC_TIER_2) {
-      index_dynamic_dpb->message_id = RDECODE_MESSAGE_DYNAMIC_DPB;
-      index_dynamic_dpb->offset = offset_dynamic_dpb;
-      index_dynamic_dpb->filled = 0;
+      index_codec->offset = offset_codec;
+      index_codec->filled = 0;
       ++header->num_buffers;
-      if (vid->dpb_type == DPB_DYNAMIC_TIER_1)
-         index_dynamic_dpb->size = sizeof(rvcn_dec_message_dynamic_dpb_t);
-      else if (vid->dpb_type == DPB_DYNAMIC_TIER_2)
-         index_dynamic_dpb->size = sizeof(rvcn_dec_message_dynamic_dpb_t2_t);
-   }
 
-   decode->stream_type = vid->stream_type;
-   decode->decode_flags = 0;
-   decode->width_in_samples = frame_info->dstPictureResource.codedExtent.width;
-   decode->height_in_samples = frame_info->dstPictureResource.codedExtent.height;
+      if (vid->dpb_type == DPB_DYNAMIC_TIER_1 || vid->dpb_type == DPB_DYNAMIC_TIER_2) {
+            index_dynamic_dpb->message_id = RDECODE_MESSAGE_DYNAMIC_DPB;
+            index_dynamic_dpb->offset = offset_dynamic_dpb;
+            index_dynamic_dpb->filled = 0;
+            ++header->num_buffers;
+            if (vid->dpb_type == DPB_DYNAMIC_TIER_1)
+                  index_dynamic_dpb->size = sizeof(rvcn_dec_message_dynamic_dpb_t);
+            else if (vid->dpb_type == DPB_DYNAMIC_TIER_2)
+                  index_dynamic_dpb->size = sizeof(rvcn_dec_message_dynamic_dpb_t2_t);
+      }
 
-   decode->bsd_size = frame_info->srcBufferRange;
+      decode->stream_type = vid->stream_type;
+      decode->decode_flags = 0;
+      decode->width_in_samples = frame_info->dstPictureResource.codedExtent.width;
+      decode->height_in_samples = frame_info->dstPictureResource.codedExtent.height;
 
-   decode->dt_size = dst_iv->image->planes[0].surface.total_size + dst_iv->image->planes[1].surface.total_size;
-   decode->sct_size = 0;
-   decode->sc_coeff_size = 0;
+      decode->bsd_size = frame_info->srcBufferRange;
 
-   decode->sw_ctxt_size = RDECODE_SESSION_CONTEXT_SIZE;
+      decode->dt_size = dst_iv->image->planes[0].surface.total_size + dst_iv->image->planes[1].surface.total_size;
+      decode->sct_size = 0;
+      decode->sc_coeff_size = 0;
 
-   decode->dt_pitch = luma->surface.u.gfx9.surf_pitch * luma->surface.blk_w;
-   decode->dt_uv_pitch = chroma->surface.u.gfx9.surf_pitch * chroma->surface.blk_w;
+      decode->sw_ctxt_size = RDECODE_SESSION_CONTEXT_SIZE;
 
-   if (luma->surface.meta_offset) {
-      fprintf(stderr, "DCC SURFACES NOT SUPPORTED.\n");
-      return false;
-   }
+      decode->dt_pitch = luma->surface.u.gfx9.surf_pitch * luma->surface.blk_w;
+      decode->dt_uv_pitch = chroma->surface.u.gfx9.surf_pitch * chroma->surface.blk_w;
 
-   decode->dt_tiling_mode = 0;
-   decode->dt_swizzle_mode = luma->surface.u.gfx9.swizzle_mode;
-   decode->dt_array_mode = pdev->vid_addr_gfx_mode;
-   decode->dt_field_mode = 0;
-   decode->dt_surf_tile_config = 0;
-   decode->dt_uv_surf_tile_config = 0;
+      if (UNLIKELY(luma->surface.meta_offset)) {
+            fprintf(stderr, "DCC SURFACES NOT SUPPORTED.\n");
+            return false;
+      }
 
-   int dt_array_idx = frame_info->dstPictureResource.baseArrayLayer + dst_iv->vk.base_array_layer;
+      decode->dt_tiling_mode = 0;
+      decode->dt_swizzle_mode = luma->surface.u.gfx9.swizzle_mode;
+      decode->dt_array_mode = pdev->vid_addr_gfx_mode;
+      decode->dt_field_mode = 0;
+      decode->dt_surf_tile_config = 0;
+      decode->dt_uv_surf_tile_config = 0;
 
-   decode->dt_luma_top_offset = luma->surface.u.gfx9.surf_offset +
+      int dt_array_idx = frame_info->dstPictureResource.baseArrayLayer + dst_iv->vk.base_array_layer;
+
+      decode->dt_luma_top_offset = luma->surface.u.gfx9.surf_offset +
       dt_array_idx * luma->surface.u.gfx9.surf_slice_size;
-   decode->dt_chroma_top_offset = chroma->surface.u.gfx9.surf_offset +
+      decode->dt_chroma_top_offset = chroma->surface.u.gfx9.surf_offset +
       dt_array_idx * chroma->surface.u.gfx9.surf_slice_size;
-   decode->dt_luma_bottom_offset = decode->dt_luma_top_offset;
-   decode->dt_chroma_bottom_offset = decode->dt_chroma_top_offset;
-
-   if (vid->stream_type == RDECODE_CODEC_AV1)
-      decode->db_pitch_uv = chroma->surface.u.gfx9.surf_pitch * chroma->surface.blk_w;
+      decode->dt_luma_bottom_offset = decode->dt_luma_top_offset;
+      decode->dt_chroma_bottom_offset = decode->dt_chroma_top_offset;
 
-   *slice_offset = 0;
+      if (vid->stream_type == RDECODE_CODEC_AV1)
+            decode->db_pitch_uv = chroma->surface.u.gfx9.surf_pitch * chroma->surface.blk_w;
 
-   /* Intra-only decoding will only work without a setup slot for AV1
-    * (non-filmgrain) currently, other codecs require the application to pass a
-    * setup slot for this use-case, since the FW is not able to skip write-out
-    * for H26X. In order to fix that properly, additional scratch space will
-    * be needed in the video session just for intra-only DPB targets.
-    */
-   int dpb_update_required = 1;
+      *slice_offset = 0;
 
-   switch (vid->vk.op) {
-   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
-      index_codec->size = sizeof(rvcn_dec_message_avc_t);
-      rvcn_dec_message_avc_t avc = get_h264_msg(vid, params, frame_info, slice_offset, &decode->width_in_samples,
-                                                &decode->height_in_samples, it_probs_ptr);
-      memcpy(codec, (void *)&avc, sizeof(rvcn_dec_message_avc_t));
-      index_codec->message_id = RDECODE_MESSAGE_AVC;
-      break;
-   }
-   case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: {
-      index_codec->size = sizeof(rvcn_dec_message_hevc_t);
-      rvcn_dec_message_hevc_t hevc = get_h265_msg(device, vid, params, frame_info,
-                                                  &decode->width_in_samples,
-                                                  &decode->height_in_samples,
-                                                  it_probs_ptr);
-      memcpy(codec, (void *)&hevc, sizeof(rvcn_dec_message_hevc_t));
-      index_codec->message_id = RDECODE_MESSAGE_HEVC;
-      break;
-   }
-   case VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR: {
-      index_codec->size = sizeof(rvcn_dec_message_av1_t);
-      rvcn_dec_message_av1_t av1 = get_av1_msg(device, vid, params, frame_info, it_probs_ptr, &dpb_update_required);
-      memcpy(codec, (void *)&av1, sizeof(rvcn_dec_message_av1_t));
-      index_codec->message_id = RDECODE_MESSAGE_AV1;
-      assert(frame_info->referenceSlotCount < 9);
-      break;
-   }
-   case VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR: {
-      index_codec->size = sizeof(rvcn_dec_message_vp9_t);
-      rvcn_dec_message_vp9_t vp9 = get_vp9_msg(device, vid, params, frame_info, it_probs_ptr, &dpb_update_required);
-      memcpy(codec, (void *)&vp9, sizeof(rvcn_dec_message_vp9_t));
-      index_codec->message_id = RDECODE_MESSAGE_VP9;
-      if (vid->vk.max_dpb_slots == 0)
-         use_intra_only_allocation_for_dpb = true;
-      break;
-   }
-   default:
-      unreachable("unknown operation");
-   }
-
-   header->total_size += index_codec->size;
-
-   if (dpb_update_required)
-      assert(frame_info->pSetupReferenceSlot != NULL);
-
-   struct radv_image_view *dpb_iv =
-      frame_info->pSetupReferenceSlot
-         ? radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding)
-         : NULL;
-   struct radv_image *dpb = dpb_iv ? dpb_iv->image : img;
-
-   int dpb_array_idx = 0;
-   if (dpb_update_required)
-      dpb_array_idx = frame_info->pSetupReferenceSlot->pPictureResource->baseArrayLayer + dpb_iv->vk.base_array_layer;
-
-   decode->dpb_size = (vid->dpb_type < DPB_DYNAMIC_TIER_2) ? dpb->size : 0;
-   decode->db_pitch = dpb->planes[0].surface.u.gfx9.surf_pitch;
-   decode->db_aligned_height = dpb->planes[0].surface.u.gfx9.surf_height;
-   decode->db_swizzle_mode = dpb->planes[0].surface.u.gfx9.swizzle_mode;
-   decode->db_array_mode = pdev->vid_addr_gfx_mode;
-
-   decode->hw_ctxt_size = vid->ctx.size;
-
-   if (vid->dpb_type == DPB_DYNAMIC_TIER_1) {
-      decode->decode_flags |= (RDECODE_FLAGS_USE_DYNAMIC_DPB_MASK | RDECODE_FLAGS_USE_PAL_MASK);
-
-      dynamic_dpb->dpbArraySize = RADV_VIDEO_VP9_MAX_DPB_SLOTS;
-      dynamic_dpb->dpbLumaPitch = dpb->planes[0].surface.u.gfx9.surf_pitch;
-      dynamic_dpb->dpbLumaAlignedHeight = dpb->planes[0].surface.u.gfx9.surf_height;
-      dynamic_dpb->dpbLumaAlignedSize =
-         dpb->planes[0].surface.u.gfx9.surf_slice_size;
-      dynamic_dpb->dpbChromaPitch = dpb->planes[1].surface.u.gfx9.surf_pitch;
-      dynamic_dpb->dpbChromaAlignedHeight = dpb->planes[1].surface.u.gfx9.surf_height;
-      dynamic_dpb->dpbChromaAlignedSize = dpb->planes[1].surface.u.gfx9.surf_slice_size;
-      dynamic_dpb->dpbReserved0[0] = vid->db_alignment;
-   }
-
-   if (vid->dpb_type != DPB_DYNAMIC_TIER_2)
-      return true;
-
-   uint64_t addr;
-
-   if (use_intra_only_allocation_for_dpb) {
-      addr = radv_buffer_get_va(vid->intra_only_dpb.mem->bo) + vid->intra_only_dpb.offset;
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, vid->intra_only_dpb.mem->bo);
-   } else {
-      addr = dpb->bindings[0].addr;
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, dpb->bindings[0].bo);
-      addr += dpb_array_idx * (dpb->planes[0].surface.u.gfx9.surf_slice_size + dpb->planes[1].surface.u.gfx9.surf_slice_size);
-   }
-
-   dynamic_dpb_t2->dpbCurrLo = addr;
-   dynamic_dpb_t2->dpbCurrHi = addr >> 32;
-
-   if (vid->vk.op == VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR) {
-      /* The following loop will fill in the references for the current frame,
-       * this ensures all DPB addresses are "valid" (pointing at the current
-       * decode target), so that the firmware doesn't evict things it should not.
-       * It will not perform any actual writes to these dummy slots.
+      /* Intra-only decoding will only work without a setup slot for AV1
+       * (non-filmgrain) currently, other codecs require the application to pass a
+       * setup slot for this use-case, since the FW is not able to skip write-out
+       * for H26X. In order to fix that properly, additional scratch space will
+       * be needed in the video session just for intra-only DPB targets.
        */
-      for (int i = 0; i < STD_VIDEO_AV1_NUM_REF_FRAMES; i++) {
-         dynamic_dpb_t2->dpbAddrHi[i] = addr;
-         dynamic_dpb_t2->dpbAddrLo[i] = addr >> 32;
+      int dpb_update_required = 1;
+
+      switch (vid->vk.op) {
+            case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
+                  index_codec->size = sizeof(rvcn_dec_message_avc_t);
+                  rvcn_dec_message_avc_t avc = get_h264_msg(vid, params, frame_info, slice_offset, &decode->width_in_samples,
+                                                            &decode->height_in_samples, it_probs_ptr);
+                  memcpy(codec, (void *)&avc, sizeof(rvcn_dec_message_avc_t));
+                  index_codec->message_id = RDECODE_MESSAGE_AVC;
+                  break;
+            }
+            case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: {
+                  index_codec->size = sizeof(rvcn_dec_message_hevc_t);
+                  rvcn_dec_message_hevc_t hevc = get_h265_msg(device, vid, params, frame_info,
+                                                              &decode->width_in_samples,
+                                                              &decode->height_in_samples,
+                                                              it_probs_ptr);
+                  memcpy(codec, (void *)&hevc, sizeof(rvcn_dec_message_hevc_t));
+                  index_codec->message_id = RDECODE_MESSAGE_HEVC;
+                  break;
+            }
+            case VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR: {
+                  index_codec->size = sizeof(rvcn_dec_message_av1_t);
+                  rvcn_dec_message_av1_t av1 = get_av1_msg(device, vid, params, frame_info, it_probs_ptr, &dpb_update_required);
+                  memcpy(codec, (void *)&av1, sizeof(rvcn_dec_message_av1_t));
+                  index_codec->message_id = RDECODE_MESSAGE_AV1;
+                  assert(frame_info->referenceSlotCount < 9);
+                  break;
+            }
+            case VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR: {
+                  index_codec->size = sizeof(rvcn_dec_message_vp9_t);
+                  rvcn_dec_message_vp9_t vp9 = get_vp9_msg(device, vid, params, frame_info, it_probs_ptr, &dpb_update_required);
+                  memcpy(codec, (void *)&vp9, sizeof(rvcn_dec_message_vp9_t));
+                  index_codec->message_id = RDECODE_MESSAGE_VP9;
+                  if (vid->vk.max_dpb_slots == 0)
+                        use_intra_only_allocation_for_dpb = true;
+                  break;
+            }
+            default:
+                  unreachable("unknown operation");
       }
-   }
 
-   for (int i = 0; i < frame_info->referenceSlotCount; i++) {
-      struct radv_image_view *f_dpb_iv =
-         radv_image_view_from_handle(frame_info->pReferenceSlots[i].pPictureResource->imageViewBinding);
-      assert(f_dpb_iv != NULL);
-      struct radv_image *dpb_img = f_dpb_iv->image;
-      int f_dpb_array_idx = frame_info->pReferenceSlots[i].pPictureResource->baseArrayLayer + f_dpb_iv->vk.base_array_layer;
+      header->total_size += index_codec->size;
 
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, dpb_img->bindings[0].bo);
-      addr = dpb_img->bindings[0].addr;
-      addr += f_dpb_array_idx * (dpb_img->planes[0].surface.u.gfx9.surf_slice_size + dpb_img->planes[1].surface.u.gfx9.surf_slice_size);
-      dynamic_dpb_t2->dpbAddrLo[i] = addr;
-      dynamic_dpb_t2->dpbAddrHi[i] = addr >> 32;
+      if (dpb_update_required)
+            assert(frame_info->pSetupReferenceSlot != NULL);
 
-      ++dynamic_dpb_t2->dpbArraySize;
-   }
+      struct radv_image_view *dpb_iv =
+      frame_info->pSetupReferenceSlot
+      ? radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding)
+      : NULL;
+      struct radv_image *dpb = dpb_iv ? dpb_iv->image : img;
+
+      int dpb_array_idx = 0;
+      if (dpb_update_required)
+            dpb_array_idx = frame_info->pSetupReferenceSlot->pPictureResource->baseArrayLayer + dpb_iv->vk.base_array_layer;
+
+      decode->dpb_size = (vid->dpb_type < DPB_DYNAMIC_TIER_2) ? dpb->size : 0;
+      decode->db_pitch = dpb->planes[0].surface.u.gfx9.surf_pitch;
+      decode->db_aligned_height = dpb->planes[0].surface.u.gfx9.surf_height;
+      decode->db_swizzle_mode = dpb->planes[0].surface.u.gfx9.swizzle_mode;
+      decode->db_array_mode = pdev->vid_addr_gfx_mode;
 
-   decode->decode_flags = 1;
-   dynamic_dpb_t2->dpbConfigFlags = 0;
+      decode->hw_ctxt_size = vid->ctx.size;
 
-   dynamic_dpb_t2->dpbLumaPitch = dpb->planes[0].surface.u.gfx9.surf_pitch;
-   dynamic_dpb_t2->dpbLumaAlignedHeight = dpb->planes[0].surface.u.gfx9.surf_height;
-   dynamic_dpb_t2->dpbLumaAlignedSize = dpb->planes[0].surface.u.gfx9.surf_slice_size;
+      if (vid->dpb_type == DPB_DYNAMIC_TIER_1) {
+            decode->decode_flags |= (RDECODE_FLAGS_USE_DYNAMIC_DPB_MASK | RDECODE_FLAGS_USE_PAL_MASK);
 
-   dynamic_dpb_t2->dpbChromaPitch = dpb->planes[1].surface.u.gfx9.surf_pitch;
-   dynamic_dpb_t2->dpbChromaAlignedHeight = dpb->planes[1].surface.u.gfx9.surf_height;
-   dynamic_dpb_t2->dpbChromaAlignedSize = dpb->planes[1].surface.u.gfx9.surf_slice_size;
+            dynamic_dpb->dpbArraySize = RADV_VIDEO_VP9_MAX_DPB_SLOTS;
+            dynamic_dpb->dpbLumaPitch = dpb->planes[0].surface.u.gfx9.surf_pitch;
+            dynamic_dpb->dpbLumaAlignedHeight = dpb->planes[0].surface.u.gfx9.surf_height;
+            dynamic_dpb->dpbLumaAlignedSize =
+            dpb->planes[0].surface.u.gfx9.surf_slice_size;
+            dynamic_dpb->dpbChromaPitch = dpb->planes[1].surface.u.gfx9.surf_pitch;
+            dynamic_dpb->dpbChromaAlignedHeight = dpb->planes[1].surface.u.gfx9.surf_height;
+            dynamic_dpb->dpbChromaAlignedSize = dpb->planes[1].surface.u.gfx9.surf_slice_size;
+            dynamic_dpb->dpbReserved0[0] = vid->db_alignment;
+      }
+
+      if (vid->dpb_type != DPB_DYNAMIC_TIER_2)
+            return true;
+
+      uint64_t addr;
+
+      if (use_intra_only_allocation_for_dpb) {
+            addr = radv_buffer_get_va(vid->intra_only_dpb.mem->bo) + vid->intra_only_dpb.offset;
+            radv_cs_add_buffer(device->ws, cmd_buffer->cs, vid->intra_only_dpb.mem->bo);
+      } else {
+            addr = dpb->bindings[0].addr;
+            radv_cs_add_buffer(device->ws, cmd_buffer->cs, dpb->bindings[0].bo);
+            addr += dpb_array_idx * (dpb->planes[0].surface.u.gfx9.surf_slice_size + dpb->planes[1].surface.u.gfx9.surf_slice_size);
+      }
+
+      dynamic_dpb_t2->dpbCurrLo = addr;
+      dynamic_dpb_t2->dpbCurrHi = addr >> 32;
+
+      if (vid->vk.op == VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR) {
+            /* The following loop will fill in the references for the current frame,
+             * this ensures all DPB addresses are "valid" (pointing at the current
+             * decode target), so that the firmware doesn't evict things it should not.
+             * It will not perform any actual writes to these dummy slots.
+             */
+            for (int i = 0; i < STD_VIDEO_AV1_NUM_REF_FRAMES; i++) {
+                  dynamic_dpb_t2->dpbAddrHi[i] = addr;
+                  dynamic_dpb_t2->dpbAddrLo[i] = addr >> 32;
+            }
+      }
+
+      for (int i = 0; i < frame_info->referenceSlotCount; i++) {
+            struct radv_image_view *f_dpb_iv =
+            radv_image_view_from_handle(frame_info->pReferenceSlots[i].pPictureResource->imageViewBinding);
+            assert(f_dpb_iv != NULL);
+            struct radv_image *dpb_img = f_dpb_iv->image;
+            int f_dpb_array_idx = frame_info->pReferenceSlots[i].pPictureResource->baseArrayLayer + f_dpb_iv->vk.base_array_layer;
+
+            radv_cs_add_buffer(device->ws, cmd_buffer->cs, dpb_img->bindings[0].bo);
+            addr = dpb_img->bindings[0].addr;
+            addr += f_dpb_array_idx * (dpb_img->planes[0].surface.u.gfx9.surf_slice_size + dpb_img->planes[1].surface.u.gfx9.surf_slice_size);
+            dynamic_dpb_t2->dpbAddrLo[i] = addr;
+            dynamic_dpb_t2->dpbAddrHi[i] = addr >> 32;
+
+            ++dynamic_dpb_t2->dpbArraySize;
+      }
+
+      decode->decode_flags = 1;
+      dynamic_dpb_t2->dpbConfigFlags = 0;
+
+      dynamic_dpb_t2->dpbLumaPitch = dpb->planes[0].surface.u.gfx9.surf_pitch;
+      dynamic_dpb_t2->dpbLumaAlignedHeight = dpb->planes[0].surface.u.gfx9.surf_height;
+      dynamic_dpb_t2->dpbLumaAlignedSize = dpb->planes[0].surface.u.gfx9.surf_slice_size;
+
+      dynamic_dpb_t2->dpbChromaPitch = dpb->planes[1].surface.u.gfx9.surf_pitch;
+      dynamic_dpb_t2->dpbChromaAlignedHeight = dpb->planes[1].surface.u.gfx9.surf_height;
+      dynamic_dpb_t2->dpbChromaAlignedSize = dpb->planes[1].surface.u.gfx9.surf_slice_size;
 
-   return true;
+      return true;
 }
 
 static struct ruvd_h264
@@ -2444,108 +2453,106 @@ get_uvd_h264_msg(struct radv_video_sessi
                  const struct VkVideoDecodeInfoKHR *frame_info, uint32_t *slice_offset, uint32_t *width_in_samples,
                  uint32_t *height_in_samples, void *it_ptr)
 {
-   struct ruvd_h264 result;
-   const struct VkVideoDecodeH264PictureInfoKHR *h264_pic_info =
+      struct ruvd_h264 result = {0};
+      const struct VkVideoDecodeH264PictureInfoKHR *h264_pic_info =
       vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_H264_PICTURE_INFO_KHR);
 
-   const StdVideoH264SequenceParameterSet *sps;
-   const StdVideoH264PictureParameterSet *pps;
-
-   vk_video_get_h264_parameters(&vid->vk, params ? &params->vk : NULL, frame_info, h264_pic_info, &sps, &pps);
-
-   *slice_offset = h264_pic_info->pSliceOffsets[0];
+      const StdVideoH264SequenceParameterSet *sps;
+      const StdVideoH264PictureParameterSet *pps;
 
-   memset(&result, 0, sizeof(result));
+      vk_video_get_h264_parameters(&vid->vk, params ? &params->vk : NULL, frame_info, h264_pic_info, &sps, &pps);
 
-   switch (sps->profile_idc) {
-   case STD_VIDEO_H264_PROFILE_IDC_BASELINE:
-      result.profile = RUVD_H264_PROFILE_BASELINE;
-      break;
-   case STD_VIDEO_H264_PROFILE_IDC_MAIN:
-      result.profile = RUVD_H264_PROFILE_MAIN;
-      break;
-   case STD_VIDEO_H264_PROFILE_IDC_HIGH:
-      result.profile = RUVD_H264_PROFILE_HIGH;
-      break;
-   default:
-      fprintf(stderr, "UNSUPPORTED CODEC %d\n", sps->profile_idc);
-      result.profile = RUVD_H264_PROFILE_MAIN;
-      break;
-   }
+      *slice_offset = h264_pic_info->pSliceOffsets[0];
 
-   *width_in_samples = (sps->pic_width_in_mbs_minus1 + 1) * 16;
-   *height_in_samples = (sps->pic_height_in_map_units_minus1 + 1) * 16;
-   if (!sps->flags.frame_mbs_only_flag)
-      *height_in_samples *= 2;
-   result.level = get_h264_level(sps->level_idc);
-
-   result.sps_info_flags = 0;
-
-   result.sps_info_flags |= sps->flags.direct_8x8_inference_flag << 0;
-   result.sps_info_flags |= sps->flags.mb_adaptive_frame_field_flag << 1;
-   result.sps_info_flags |= sps->flags.frame_mbs_only_flag << 2;
-   result.sps_info_flags |= sps->flags.delta_pic_order_always_zero_flag << 3;
-   result.sps_info_flags |= 1 << RDECODE_SPS_INFO_H264_EXTENSION_SUPPORT_FLAG_SHIFT;
-
-   result.bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
-   result.bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
-   result.log2_max_frame_num_minus4 = sps->log2_max_frame_num_minus4;
-   result.pic_order_cnt_type = sps->pic_order_cnt_type;
-   result.log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
-
-   result.chroma_format = sps->chroma_format_idc;
-
-   result.pps_info_flags = 0;
-   result.pps_info_flags |= pps->flags.transform_8x8_mode_flag << 0;
-   result.pps_info_flags |= pps->flags.redundant_pic_cnt_present_flag << 1;
-   result.pps_info_flags |= pps->flags.constrained_intra_pred_flag << 2;
-   result.pps_info_flags |= pps->flags.deblocking_filter_control_present_flag << 3;
-   result.pps_info_flags |= pps->weighted_bipred_idc << 4;
-   result.pps_info_flags |= pps->flags.weighted_pred_flag << 6;
-   result.pps_info_flags |= pps->flags.bottom_field_pic_order_in_frame_present_flag << 7;
-   result.pps_info_flags |= pps->flags.entropy_coding_mode_flag << 8;
-
-   result.pic_init_qp_minus26 = pps->pic_init_qp_minus26;
-   result.chroma_qp_index_offset = pps->chroma_qp_index_offset;
-   result.second_chroma_qp_index_offset = pps->second_chroma_qp_index_offset;
-
-   StdVideoH264ScalingLists scaling_lists;
-   vk_video_derive_h264_scaling_list(sps, pps, &scaling_lists);
-   update_h264_scaling(result.scaling_list_4x4, result.scaling_list_8x8, &scaling_lists);
-
-   memset(it_ptr, 0, IT_SCALING_TABLE_SIZE);
-   memcpy(it_ptr, result.scaling_list_4x4, 6 * 16);
-   memcpy((char *)it_ptr + 96, result.scaling_list_8x8, 2 * 64);
-
-   result.num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_default_active_minus1;
-   result.num_ref_idx_l1_active_minus1 = pps->num_ref_idx_l1_default_active_minus1;
-
-   result.curr_field_order_cnt_list[0] = h264_pic_info->pStdPictureInfo->PicOrderCnt[0];
-   result.curr_field_order_cnt_list[1] = h264_pic_info->pStdPictureInfo->PicOrderCnt[1];
-
-   result.frame_num = h264_pic_info->pStdPictureInfo->frame_num;
-
-   result.num_ref_frames = sps->max_num_ref_frames;
-   memset(result.ref_frame_list, 0xff, sizeof(unsigned char) * 16);
-   memset(result.frame_num_list, 0, sizeof(unsigned int) * 16);
-   for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
-      int idx = frame_info->pReferenceSlots[i].slotIndex;
-      const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
-         vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
+      switch (sps->profile_idc) {
+            case STD_VIDEO_H264_PROFILE_IDC_BASELINE:
+                  result.profile = RUVD_H264_PROFILE_BASELINE;
+                  break;
+            case STD_VIDEO_H264_PROFILE_IDC_MAIN:
+                  result.profile = RUVD_H264_PROFILE_MAIN;
+                  break;
+            case STD_VIDEO_H264_PROFILE_IDC_HIGH:
+                  result.profile = RUVD_H264_PROFILE_HIGH;
+                  break;
+            default:
+                  fprintf(stderr, "UNSUPPORTED CODEC %d\n", sps->profile_idc);
+                  result.profile = RUVD_H264_PROFILE_MAIN;
+                  break;
+      }
+
+      *width_in_samples = (sps->pic_width_in_mbs_minus1 + 1) * 16;
+      *height_in_samples = (sps->pic_height_in_map_units_minus1 + 1) * 16;
+      if (!sps->flags.frame_mbs_only_flag)
+            *height_in_samples *= 2;
+      result.level = get_h264_level(sps->level_idc);
+
+      result.sps_info_flags = 0;
+
+      result.sps_info_flags |= sps->flags.direct_8x8_inference_flag << 0;
+      result.sps_info_flags |= sps->flags.mb_adaptive_frame_field_flag << 1;
+      result.sps_info_flags |= sps->flags.frame_mbs_only_flag << 2;
+      result.sps_info_flags |= sps->flags.delta_pic_order_always_zero_flag << 3;
+      result.sps_info_flags |= 1 << RDECODE_SPS_INFO_H264_EXTENSION_SUPPORT_FLAG_SHIFT;
 
-      result.frame_num_list[i] = dpb_slot->pStdReferenceInfo->FrameNum;
-      result.field_order_cnt_list[i][0] = dpb_slot->pStdReferenceInfo->PicOrderCnt[0];
-      result.field_order_cnt_list[i][1] = dpb_slot->pStdReferenceInfo->PicOrderCnt[1];
+      result.bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
+      result.bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
+      result.log2_max_frame_num_minus4 = sps->log2_max_frame_num_minus4;
+      result.pic_order_cnt_type = sps->pic_order_cnt_type;
+      result.log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
+
+      result.chroma_format = sps->chroma_format_idc;
+
+      result.pps_info_flags = 0;
+      result.pps_info_flags |= pps->flags.transform_8x8_mode_flag << 0;
+      result.pps_info_flags |= pps->flags.redundant_pic_cnt_present_flag << 1;
+      result.pps_info_flags |= pps->flags.constrained_intra_pred_flag << 2;
+      result.pps_info_flags |= pps->flags.deblocking_filter_control_present_flag << 3;
+      result.pps_info_flags |= pps->weighted_bipred_idc << 4;
+      result.pps_info_flags |= pps->flags.weighted_pred_flag << 6;
+      result.pps_info_flags |= pps->flags.bottom_field_pic_order_in_frame_present_flag << 7;
+      result.pps_info_flags |= pps->flags.entropy_coding_mode_flag << 8;
+
+      result.pic_init_qp_minus26 = pps->pic_init_qp_minus26;
+      result.chroma_qp_index_offset = pps->chroma_qp_index_offset;
+      result.second_chroma_qp_index_offset = pps->second_chroma_qp_index_offset;
+
+      StdVideoH264ScalingLists scaling_lists;
+      vk_video_derive_h264_scaling_list(sps, pps, &scaling_lists);
+      update_h264_scaling(result.scaling_list_4x4, result.scaling_list_8x8, &scaling_lists);
+
+      memset(it_ptr, 0, IT_SCALING_TABLE_SIZE);
+      memcpy(it_ptr, result.scaling_list_4x4, 6 * 16);
+      memcpy((char *)it_ptr + 96, result.scaling_list_8x8, 2 * 64);
+
+      result.num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_default_active_minus1;
+      result.num_ref_idx_l1_active_minus1 = pps->num_ref_idx_l1_default_active_minus1;
+
+      result.curr_field_order_cnt_list[0] = h264_pic_info->pStdPictureInfo->PicOrderCnt[0];
+      result.curr_field_order_cnt_list[1] = h264_pic_info->pStdPictureInfo->PicOrderCnt[1];
+
+      result.frame_num = h264_pic_info->pStdPictureInfo->frame_num;
+
+      result.num_ref_frames = sps->max_num_ref_frames;
+      memset(result.ref_frame_list, 0xff, sizeof(unsigned char) * 16);
+      memset(result.frame_num_list, 0, sizeof(unsigned int) * 16);
+      for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
+            int idx = frame_info->pReferenceSlots[i].slotIndex;
+            const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
+            vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
+
+            result.frame_num_list[i] = dpb_slot->pStdReferenceInfo->FrameNum;
+            result.field_order_cnt_list[i][0] = dpb_slot->pStdReferenceInfo->PicOrderCnt[0];
+            result.field_order_cnt_list[i][1] = dpb_slot->pStdReferenceInfo->PicOrderCnt[1];
 
-      result.ref_frame_list[i] = idx;
+            result.ref_frame_list[i] = idx;
 
-      if (dpb_slot->pStdReferenceInfo->flags.used_for_long_term_reference)
-         result.ref_frame_list[i] |= 0x80;
-   }
-   result.curr_pic_ref_frame_num = frame_info->referenceSlotCount;
-   result.decoded_pic_idx = frame_info->pSetupReferenceSlot->slotIndex;
+            if (dpb_slot->pStdReferenceInfo->flags.used_for_long_term_reference)
+                  result.ref_frame_list[i] |= 0x80;
+      }
+      result.curr_pic_ref_frame_num = frame_info->referenceSlotCount;
+      result.decoded_pic_idx = frame_info->pSetupReferenceSlot->slotIndex;
 
-   return result;
+      return result;
 }
 
 static struct ruvd_h265
@@ -2553,158 +2560,152 @@ get_uvd_h265_msg(struct radv_device *dev
                  const struct VkVideoDecodeInfoKHR *frame_info, uint32_t *width_in_samples,
                  uint32_t *height_in_samples, void *it_ptr)
 {
-   const struct radv_physical_device *pdev = radv_device_physical(device);
-   struct ruvd_h265 result;
-   int i, j;
-   const struct VkVideoDecodeH265PictureInfoKHR *h265_pic_info =
+      const struct radv_physical_device *pdev = radv_device_physical(device);
+      struct ruvd_h265 result = {0};
+      int i, j;
+      const struct VkVideoDecodeH265PictureInfoKHR *h265_pic_info =
       vk_find_struct_const(frame_info->pNext, VIDEO_DECODE_H265_PICTURE_INFO_KHR);
 
-   memset(&result, 0, sizeof(result));
+      const StdVideoH265SequenceParameterSet *sps = NULL;
+      const StdVideoH265PictureParameterSet *pps = NULL;
 
-   const StdVideoH265SequenceParameterSet *sps = NULL;
-   const StdVideoH265PictureParameterSet *pps = NULL;
+      vk_video_get_h265_parameters(&vid->vk, params ? &params->vk : NULL, frame_info, h265_pic_info, &sps, &pps);
 
-   vk_video_get_h265_parameters(&vid->vk, params ? &params->vk : NULL, frame_info, h265_pic_info, &sps, &pps);
-
-   result.sps_info_flags = 0;
-   result.sps_info_flags |= sps->flags.scaling_list_enabled_flag << 0;
-   result.sps_info_flags |= sps->flags.amp_enabled_flag << 1;
-   result.sps_info_flags |= sps->flags.sample_adaptive_offset_enabled_flag << 2;
-   result.sps_info_flags |= sps->flags.pcm_enabled_flag << 3;
-   result.sps_info_flags |= sps->flags.pcm_loop_filter_disabled_flag << 4;
-   result.sps_info_flags |= sps->flags.long_term_ref_pics_present_flag << 5;
-   result.sps_info_flags |= sps->flags.sps_temporal_mvp_enabled_flag << 6;
-   result.sps_info_flags |= sps->flags.strong_intra_smoothing_enabled_flag << 7;
-   result.sps_info_flags |= sps->flags.separate_colour_plane_flag << 8;
-
-   if (pdev->info.family == CHIP_CARRIZO)
-      result.sps_info_flags |= 1 << 9;
-
-   *width_in_samples = sps->pic_width_in_luma_samples;
-   *height_in_samples = sps->pic_height_in_luma_samples;
-   result.chroma_format = sps->chroma_format_idc;
-   result.bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
-   result.bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
-   result.log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
-   result.sps_max_dec_pic_buffering_minus1 =
+      result.sps_info_flags = 0;
+      result.sps_info_flags |= sps->flags.scaling_list_enabled_flag << 0;
+      result.sps_info_flags |= sps->flags.amp_enabled_flag << 1;
+      result.sps_info_flags |= sps->flags.sample_adaptive_offset_enabled_flag << 2;
+      result.sps_info_flags |= sps->flags.pcm_enabled_flag << 3;
+      result.sps_info_flags |= sps->flags.pcm_loop_filter_disabled_flag << 4;
+      result.sps_info_flags |= sps->flags.long_term_ref_pics_present_flag << 5;
+      result.sps_info_flags |= sps->flags.sps_temporal_mvp_enabled_flag << 6;
+      result.sps_info_flags |= sps->flags.strong_intra_smoothing_enabled_flag << 7;
+      result.sps_info_flags |= sps->flags.separate_colour_plane_flag << 8;
+
+      if (pdev->info.family == CHIP_CARRIZO)
+            result.sps_info_flags |= 1 << 9;
+
+      *width_in_samples = sps->pic_width_in_luma_samples;
+      *height_in_samples = sps->pic_height_in_luma_samples;
+      result.chroma_format = sps->chroma_format_idc;
+      result.bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
+      result.bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
+      result.log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
+      result.sps_max_dec_pic_buffering_minus1 =
       sps->pDecPicBufMgr->max_dec_pic_buffering_minus1[sps->sps_max_sub_layers_minus1];
-   result.log2_min_luma_coding_block_size_minus3 = sps->log2_min_luma_coding_block_size_minus3;
-   result.log2_diff_max_min_luma_coding_block_size = sps->log2_diff_max_min_luma_coding_block_size;
-   result.log2_min_transform_block_size_minus2 = sps->log2_min_luma_transform_block_size_minus2;
-   result.log2_diff_max_min_transform_block_size = sps->log2_diff_max_min_luma_transform_block_size;
-   result.max_transform_hierarchy_depth_inter = sps->max_transform_hierarchy_depth_inter;
-   result.max_transform_hierarchy_depth_intra = sps->max_transform_hierarchy_depth_intra;
-   if (sps->flags.pcm_enabled_flag) {
-      result.pcm_sample_bit_depth_luma_minus1 = sps->pcm_sample_bit_depth_luma_minus1;
-      result.pcm_sample_bit_depth_chroma_minus1 = sps->pcm_sample_bit_depth_chroma_minus1;
-      result.log2_min_pcm_luma_coding_block_size_minus3 = sps->log2_min_pcm_luma_coding_block_size_minus3;
-      result.log2_diff_max_min_pcm_luma_coding_block_size = sps->log2_diff_max_min_pcm_luma_coding_block_size;
-   }
-   result.num_short_term_ref_pic_sets = sps->num_short_term_ref_pic_sets;
-
-   result.pps_info_flags = 0;
-   result.pps_info_flags |= pps->flags.dependent_slice_segments_enabled_flag << 0;
-   result.pps_info_flags |= pps->flags.output_flag_present_flag << 1;
-   result.pps_info_flags |= pps->flags.sign_data_hiding_enabled_flag << 2;
-   result.pps_info_flags |= pps->flags.cabac_init_present_flag << 3;
-   result.pps_info_flags |= pps->flags.constrained_intra_pred_flag << 4;
-   result.pps_info_flags |= pps->flags.transform_skip_enabled_flag << 5;
-   result.pps_info_flags |= pps->flags.cu_qp_delta_enabled_flag << 6;
-   result.pps_info_flags |= pps->flags.pps_slice_chroma_qp_offsets_present_flag << 7;
-   result.pps_info_flags |= pps->flags.weighted_pred_flag << 8;
-   result.pps_info_flags |= pps->flags.weighted_bipred_flag << 9;
-   result.pps_info_flags |= pps->flags.transquant_bypass_enabled_flag << 10;
-   result.pps_info_flags |= pps->flags.tiles_enabled_flag << 11;
-   result.pps_info_flags |= pps->flags.entropy_coding_sync_enabled_flag << 12;
-   result.pps_info_flags |= pps->flags.uniform_spacing_flag << 13;
-   result.pps_info_flags |= pps->flags.loop_filter_across_tiles_enabled_flag << 14;
-   result.pps_info_flags |= pps->flags.pps_loop_filter_across_slices_enabled_flag << 15;
-   result.pps_info_flags |= pps->flags.deblocking_filter_override_enabled_flag << 16;
-   result.pps_info_flags |= pps->flags.pps_deblocking_filter_disabled_flag << 17;
-   result.pps_info_flags |= pps->flags.lists_modification_present_flag << 18;
-   result.pps_info_flags |= pps->flags.slice_segment_header_extension_present_flag << 19;
-
-   result.num_extra_slice_header_bits = pps->num_extra_slice_header_bits;
-   result.num_long_term_ref_pic_sps = sps->num_long_term_ref_pics_sps;
-   result.num_ref_idx_l0_default_active_minus1 = pps->num_ref_idx_l0_default_active_minus1;
-   result.num_ref_idx_l1_default_active_minus1 = pps->num_ref_idx_l1_default_active_minus1;
-   result.pps_cb_qp_offset = pps->pps_cb_qp_offset;
-   result.pps_cr_qp_offset = pps->pps_cr_qp_offset;
-   result.pps_beta_offset_div2 = pps->pps_beta_offset_div2;
-   result.pps_tc_offset_div2 = pps->pps_tc_offset_div2;
-   result.diff_cu_qp_delta_depth = pps->diff_cu_qp_delta_depth;
-   result.num_tile_columns_minus1 = pps->num_tile_columns_minus1;
-   result.num_tile_rows_minus1 = pps->num_tile_rows_minus1;
-   result.log2_parallel_merge_level_minus2 = pps->log2_parallel_merge_level_minus2;
-   result.init_qp_minus26 = pps->init_qp_minus26;
-
-   for (i = 0; i < 19; ++i)
-      result.column_width_minus1[i] = pps->column_width_minus1[i];
-
-   for (i = 0; i < 21; ++i)
-      result.row_height_minus1[i] = pps->row_height_minus1[i];
-
-   result.num_delta_pocs_ref_rps_idx = h265_pic_info->pStdPictureInfo->NumDeltaPocsOfRefRpsIdx;
-   result.curr_poc = h265_pic_info->pStdPictureInfo->PicOrderCntVal;
-
-   uint8_t idxs[16];
-   memset(result.poc_list, 0, 16 * sizeof(int));
-   memset(result.ref_pic_list, 0x7f, 16);
-   memset(idxs, 0xff, 16);
-   for (i = 0; i < frame_info->referenceSlotCount; i++) {
-      const struct VkVideoDecodeH265DpbSlotInfoKHR *dpb_slot =
-         vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR);
-      int idx = frame_info->pReferenceSlots[i].slotIndex;
-      result.poc_list[i] = dpb_slot->pStdReferenceInfo->PicOrderCntVal;
-      result.ref_pic_list[i] = idx;
-      idxs[idx] = i;
-   }
-   result.curr_idx = frame_info->pSetupReferenceSlot->slotIndex;
-
-#define IDXS(x) ((x) == 0xff ? 0xff : idxs[(x)])
-   for (i = 0; i < 8; ++i)
-      result.ref_pic_set_st_curr_before[i] = IDXS(h265_pic_info->pStdPictureInfo->RefPicSetStCurrBefore[i]);
-
-   for (i = 0; i < 8; ++i)
-      result.ref_pic_set_st_curr_after[i] = IDXS(h265_pic_info->pStdPictureInfo->RefPicSetStCurrAfter[i]);
-
-   for (i = 0; i < 8; ++i)
-      result.ref_pic_set_lt_curr[i] = IDXS(h265_pic_info->pStdPictureInfo->RefPicSetLtCurr[i]);
-
-   const StdVideoH265ScalingLists *scaling_lists = NULL;
-   vk_video_derive_h265_scaling_list(sps, pps, &scaling_lists);
-   if (scaling_lists) {
-      memcpy(it_ptr, scaling_lists, IT_SCALING_TABLE_SIZE);
-      memcpy(result.ucScalingListDCCoefSizeID2, scaling_lists->ScalingListDCCoef16x16, 6);
-      memcpy(result.ucScalingListDCCoefSizeID3, scaling_lists->ScalingListDCCoef32x32, 2);
-   }
-
-   for (i = 0; i < 2; i++) {
-      for (j = 0; j < 15; j++)
-         result.direct_reflist[i][j] = 0xff;
-   }
-
-   if (vid->vk.h265.profile_idc == STD_VIDEO_H265_PROFILE_IDC_MAIN_10) {
-      if (vid->vk.picture_format == VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16) {
-         result.p010_mode = 1;
-         result.msb_mode = 1;
-      } else {
-         result.p010_mode = 0;
-         result.luma_10to8 = 5;
-         result.chroma_10to8 = 5;
-         result.sclr_luma10to8 = 4;
-         result.sclr_chroma10to8 = 4;
+      result.log2_min_luma_coding_block_size_minus3 = sps->log2_min_luma_coding_block_size_minus3;
+      result.log2_diff_max_min_luma_coding_block_size = sps->log2_diff_max_min_luma_coding_block_size;
+      result.log2_min_transform_block_size_minus2 = sps->log2_min_luma_transform_block_size_minus2;
+      result.log2_diff_max_min_transform_block_size = sps->log2_diff_max_min_luma_transform_block_size;
+      result.max_transform_hierarchy_depth_inter = sps->max_transform_hierarchy_depth_inter;
+      result.max_transform_hierarchy_depth_intra = sps->max_transform_hierarchy_depth_intra;
+      if (sps->flags.pcm_enabled_flag) {
+            result.pcm_sample_bit_depth_luma_minus1 = sps->pcm_sample_bit_depth_luma_minus1;
+            result.pcm_sample_bit_depth_chroma_minus1 = sps->pcm_sample_bit_depth_chroma_minus1;
+            result.log2_min_pcm_luma_coding_block_size_minus3 = sps->log2_min_pcm_luma_coding_block_size_minus3;
+            result.log2_diff_max_min_pcm_luma_coding_block_size = sps->log2_diff_max_min_pcm_luma_coding_block_size;
+      }
+      result.num_short_term_ref_pic_sets = sps->num_short_term_ref_pic_sets;
+
+      result.pps_info_flags = 0;
+      result.pps_info_flags |= pps->flags.dependent_slice_segments_enabled_flag << 0;
+      result.pps_info_flags |= pps->flags.output_flag_present_flag << 1;
+      result.pps_info_flags |= pps->flags.sign_data_hiding_enabled_flag << 2;
+      result.pps_info_flags |= pps->flags.cabac_init_present_flag << 3;
+      result.pps_info_flags |= pps->flags.constrained_intra_pred_flag << 4;
+      result.pps_info_flags |= pps->flags.transform_skip_enabled_flag << 5;
+      result.pps_info_flags |= pps->flags.cu_qp_delta_enabled_flag << 6;
+      result.pps_info_flags |= pps->flags.pps_slice_chroma_qp_offsets_present_flag << 7;
+      result.pps_info_flags |= pps->flags.weighted_pred_flag << 8;
+      result.pps_info_flags |= pps->flags.weighted_bipred_flag << 9;
+      result.pps_info_flags |= pps->flags.transquant_bypass_enabled_flag << 10;
+      result.pps_info_flags |= pps->flags.tiles_enabled_flag << 11;
+      result.pps_info_flags |= pps->flags.entropy_coding_sync_enabled_flag << 12;
+      result.pps_info_flags |= pps->flags.uniform_spacing_flag << 13;
+      result.pps_info_flags |= pps->flags.loop_filter_across_tiles_enabled_flag << 14;
+      result.pps_info_flags |= pps->flags.pps_loop_filter_across_slices_enabled_flag << 15;
+      result.pps_info_flags |= pps->flags.deblocking_filter_override_enabled_flag << 16;
+      result.pps_info_flags |= pps->flags.pps_deblocking_filter_disabled_flag << 17;
+      result.pps_info_flags |= pps->flags.lists_modification_present_flag << 18;
+      result.pps_info_flags |= pps->flags.slice_segment_header_extension_present_flag << 19;
+
+      result.num_extra_slice_header_bits = pps->num_extra_slice_header_bits;
+      result.num_long_term_ref_pic_sps = sps->num_long_term_ref_pics_sps;
+      result.num_ref_idx_l0_default_active_minus1 = pps->num_ref_idx_l0_default_active_minus1;
+      result.num_ref_idx_l1_default_active_minus1 = pps->num_ref_idx_l1_default_active_minus1;
+      result.pps_cb_qp_offset = pps->pps_cb_qp_offset;
+      result.pps_cr_qp_offset = pps->pps_cr_qp_offset;
+      result.pps_beta_offset_div2 = pps->pps_beta_offset_div2;
+      result.pps_tc_offset_div2 = pps->pps_tc_offset_div2;
+      result.diff_cu_qp_delta_depth = pps->diff_cu_qp_delta_depth;
+      result.num_tile_columns_minus1 = pps->num_tile_columns_minus1;
+      result.num_tile_rows_minus1 = pps->num_tile_rows_minus1;
+      result.log2_parallel_merge_level_minus2 = pps->log2_parallel_merge_level_minus2;
+      result.init_qp_minus26 = pps->init_qp_minus26;
+
+      memcpy(result.column_width_minus1, pps->column_width_minus1, sizeof(result.column_width_minus1));
+      memcpy(result.row_height_minus1, pps->row_height_minus1, sizeof(result.row_height_minus1));
+
+      result.num_delta_pocs_ref_rps_idx = h265_pic_info->pStdPictureInfo->NumDeltaPocsOfRefRpsIdx;
+      result.curr_poc = h265_pic_info->pStdPictureInfo->PicOrderCntVal;
+
+      uint8_t idxs[16];
+      memset(result.poc_list, 0, 16 * sizeof(int));
+      memset(result.ref_pic_list, 0x7f, 16);
+      memset(idxs, 0xff, 16);
+      for (i = 0; i < frame_info->referenceSlotCount; i++) {
+            const struct VkVideoDecodeH265DpbSlotInfoKHR *dpb_slot =
+            vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR);
+            int idx = frame_info->pReferenceSlots[i].slotIndex;
+            result.poc_list[i] = dpb_slot->pStdReferenceInfo->PicOrderCntVal;
+            result.ref_pic_list[i] = idx;
+            idxs[idx] = i;
+      }
+      result.curr_idx = frame_info->pSetupReferenceSlot->slotIndex;
+
+      #define IDXS(x) ((x) == 0xff ? 0xff : idxs[(x)])
+      for (i = 0; i < 8; ++i)
+            result.ref_pic_set_st_curr_before[i] = IDXS(h265_pic_info->pStdPictureInfo->RefPicSetStCurrBefore[i]);
+
+      for (i = 0; i < 8; ++i)
+            result.ref_pic_set_st_curr_after[i] = IDXS(h265_pic_info->pStdPictureInfo->RefPicSetStCurrAfter[i]);
+
+      for (i = 0; i < 8; ++i)
+            result.ref_pic_set_lt_curr[i] = IDXS(h265_pic_info->pStdPictureInfo->RefPicSetLtCurr[i]);
+
+      const StdVideoH265ScalingLists *scaling_lists = NULL;
+      vk_video_derive_h265_scaling_list(sps, pps, &scaling_lists);
+      if (scaling_lists) {
+            memcpy(it_ptr, scaling_lists, IT_SCALING_TABLE_SIZE);
+            memcpy(result.ucScalingListDCCoefSizeID2, scaling_lists->ScalingListDCCoef16x16, 6);
+            memcpy(result.ucScalingListDCCoefSizeID3, scaling_lists->ScalingListDCCoef32x32, 2);
+      }
+
+      for (i = 0; i < 2; i++) {
+            for (j = 0; j < 15; j++)
+                  result.direct_reflist[i][j] = 0xff;
+      }
+
+      if (vid->vk.h265.profile_idc == STD_VIDEO_H265_PROFILE_IDC_MAIN_10) {
+            const bool is_native_p010 = (vid->vk.picture_format == VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16);
+            result.p010_mode = is_native_p010;
+            result.msb_mode = is_native_p010;
+            if (UNLIKELY(!is_native_p010)) {
+                  result.luma_10to8 = 5;
+                  result.chroma_10to8 = 5;
+                  result.sclr_luma10to8 = 4;
+                  result.sclr_chroma10to8 = 4;
+            }
       }
-   }
 
-   return result;
+      return result;
 }
 
 static unsigned
 texture_offset_legacy(struct radeon_surf *surface, unsigned layer)
 {
-   return (uint64_t)surface->u.legacy.level[0].offset_256B * 256 +
-          layer * (uint64_t)surface->u.legacy.level[0].slice_size_dw * 4;
+      return (uint64_t)surface->u.legacy.level[0].offset_256B * 256 +
+      layer * (uint64_t)surface->u.legacy.level[0].slice_size_dw * 4;
 }
 
 static bool
@@ -2712,231 +2713,231 @@ ruvd_dec_message_decode(struct radv_devi
                         struct radv_video_session_params *params, void *ptr, void *it_ptr, uint32_t *slice_offset,
                         const struct VkVideoDecodeInfoKHR *frame_info)
 {
-   const struct radv_physical_device *pdev = radv_device_physical(device);
-   struct ruvd_msg *msg = ptr;
-   struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
-   struct radv_image *img = dst_iv->image;
-   struct radv_image_plane *luma = &img->planes[0];
-   struct radv_image_plane *chroma = &img->planes[1];
-   struct radv_image_view *dpb_iv =
+      const struct radv_physical_device *pdev = radv_device_physical(device);
+      struct ruvd_msg *msg = ptr;
+      struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
+      struct radv_image *img = dst_iv->image;
+      struct radv_image_plane *luma = &img->planes[0];
+      struct radv_image_plane *chroma = &img->planes[1];
+      struct radv_image_view *dpb_iv =
       radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding);
-   struct radv_image *dpb = dpb_iv->image;
-
-   memset(msg, 0, sizeof(struct ruvd_msg));
-   msg->size = sizeof(*msg);
-   msg->msg_type = RUVD_MSG_DECODE;
-   msg->stream_handle = vid->stream_handle;
-   msg->status_report_feedback_number = vid->dbg_frame_cnt++;
-
-   msg->body.decode.stream_type = vid->stream_type;
-   msg->body.decode.decode_flags = 0x1;
-   msg->body.decode.width_in_samples = frame_info->dstPictureResource.codedExtent.width;
-   msg->body.decode.height_in_samples = frame_info->dstPictureResource.codedExtent.height;
-
-   msg->body.decode.dpb_size = (vid->dpb_type != DPB_DYNAMIC_TIER_2) ? dpb->size : 0;
-   msg->body.decode.bsd_size = frame_info->srcBufferRange;
-   msg->body.decode.db_pitch = align(frame_info->dstPictureResource.codedExtent.width, vid->db_alignment);
-
-   if (vid->stream_type == RUVD_CODEC_H264_PERF && pdev->info.family >= CHIP_POLARIS10)
-      msg->body.decode.dpb_reserved = vid->ctx.size;
-
-   *slice_offset = 0;
-   switch (vid->vk.op) {
-   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
-      msg->body.decode.codec.h264 =
-         get_uvd_h264_msg(vid, params, frame_info, slice_offset, &msg->body.decode.width_in_samples,
-                          &msg->body.decode.height_in_samples, it_ptr);
-      break;
-   }
-   case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: {
-      msg->body.decode.codec.h265 = get_uvd_h265_msg(device, vid, params, frame_info,
-                                                     &msg->body.decode.width_in_samples,
-                                                     &msg->body.decode.height_in_samples,
-                                                     it_ptr);
-
-      if (vid->ctx.mem)
-         msg->body.decode.dpb_reserved = vid->ctx.size;
-      break;
-   }
-   default:
-      return false;
-   }
-
-   msg->body.decode.dt_field_mode = false;
-
-   int dt_array_idx = frame_info->dstPictureResource.baseArrayLayer + dst_iv->vk.base_array_layer;
-
-   if (pdev->info.gfx_level >= GFX9) {
-      msg->body.decode.dt_pitch = luma->surface.u.gfx9.surf_pitch * luma->surface.blk_w;
-      msg->body.decode.dt_tiling_mode = RUVD_TILE_LINEAR;
-      msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_LINEAR;
-      msg->body.decode.dt_luma_top_offset = luma->surface.u.gfx9.surf_offset +
-         dt_array_idx * luma->surface.u.gfx9.surf_slice_size;
-      msg->body.decode.dt_chroma_top_offset = chroma->surface.u.gfx9.surf_offset +
-         dt_array_idx * chroma->surface.u.gfx9.surf_slice_size;
-      msg->body.decode.dt_luma_bottom_offset = msg->body.decode.dt_luma_top_offset;
-      msg->body.decode.dt_chroma_bottom_offset = msg->body.decode.dt_chroma_top_offset;
-      msg->body.decode.dt_surf_tile_config = 0;
-   } else {
-      msg->body.decode.dt_pitch = luma->surface.u.legacy.level[0].nblk_x * luma->surface.blk_w;
-      switch (luma->surface.u.legacy.level[0].mode) {
-      case RADEON_SURF_MODE_LINEAR_ALIGNED:
-         msg->body.decode.dt_tiling_mode = RUVD_TILE_LINEAR;
-         msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_LINEAR;
-         break;
-      case RADEON_SURF_MODE_1D:
-         msg->body.decode.dt_tiling_mode = RUVD_TILE_8X8;
-         msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_1D_THIN;
-         break;
-      case RADEON_SURF_MODE_2D:
-         msg->body.decode.dt_tiling_mode = RUVD_TILE_8X8;
-         msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_2D_THIN;
-         break;
-      default:
-         assert(0);
-         break;
-      }
-
-      msg->body.decode.dt_luma_top_offset = texture_offset_legacy(&luma->surface, dt_array_idx);
-      if (chroma)
-         msg->body.decode.dt_chroma_top_offset = texture_offset_legacy(&chroma->surface, dt_array_idx);
-      msg->body.decode.dt_luma_bottom_offset = msg->body.decode.dt_luma_top_offset;
-      msg->body.decode.dt_chroma_bottom_offset = msg->body.decode.dt_chroma_top_offset;
+      struct radv_image *dpb = dpb_iv->image;
 
-      if (chroma) {
-         assert(luma->surface.u.legacy.bankw == chroma->surface.u.legacy.bankw);
-         assert(luma->surface.u.legacy.bankh == chroma->surface.u.legacy.bankh);
-         assert(luma->surface.u.legacy.mtilea == chroma->surface.u.legacy.mtilea);
+      *msg = (struct ruvd_msg){0};
+      msg->size = sizeof(*msg);
+      msg->msg_type = RUVD_MSG_DECODE;
+      msg->stream_handle = vid->stream_handle;
+      msg->status_report_feedback_number = vid->dbg_frame_cnt++;
+
+      msg->body.decode.stream_type = vid->stream_type;
+      msg->body.decode.decode_flags = 0x1;
+      msg->body.decode.width_in_samples = frame_info->dstPictureResource.codedExtent.width;
+      msg->body.decode.height_in_samples = frame_info->dstPictureResource.codedExtent.height;
+
+      msg->body.decode.dpb_size = (vid->dpb_type != DPB_DYNAMIC_TIER_2) ? dpb->size : 0;
+      msg->body.decode.bsd_size = frame_info->srcBufferRange;
+      msg->body.decode.db_pitch = align(frame_info->dstPictureResource.codedExtent.width, vid->db_alignment);
+
+      if (vid->stream_type == RUVD_CODEC_H264_PERF && pdev->info.family >= CHIP_POLARIS10)
+            msg->body.decode.dpb_reserved = vid->ctx.size;
+
+      *slice_offset = 0;
+      switch (vid->vk.op) {
+            case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
+                  msg->body.decode.codec.h264 =
+                  get_uvd_h264_msg(vid, params, frame_info, slice_offset, &msg->body.decode.width_in_samples,
+                                   &msg->body.decode.height_in_samples, it_ptr);
+                  break;
+            }
+            case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: {
+                  msg->body.decode.codec.h265 = get_uvd_h265_msg(device, vid, params, frame_info,
+                                                                 &msg->body.decode.width_in_samples,
+                                                                 &msg->body.decode.height_in_samples,
+                                                                 it_ptr);
+
+                  if (vid->ctx.mem)
+                        msg->body.decode.dpb_reserved = vid->ctx.size;
+                  break;
+            }
+            default:
+                  return false;
+      }
+
+      msg->body.decode.dt_field_mode = false;
+
+      int dt_array_idx = frame_info->dstPictureResource.baseArrayLayer + dst_iv->vk.base_array_layer;
+
+      if (pdev->info.gfx_level >= GFX9) {
+            msg->body.decode.dt_pitch = luma->surface.u.gfx9.surf_pitch * luma->surface.blk_w;
+            msg->body.decode.dt_tiling_mode = RUVD_TILE_LINEAR;
+            msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_LINEAR;
+            msg->body.decode.dt_luma_top_offset = luma->surface.u.gfx9.surf_offset +
+            dt_array_idx * luma->surface.u.gfx9.surf_slice_size;
+            msg->body.decode.dt_chroma_top_offset = chroma->surface.u.gfx9.surf_offset +
+            dt_array_idx * chroma->surface.u.gfx9.surf_slice_size;
+            msg->body.decode.dt_luma_bottom_offset = msg->body.decode.dt_luma_top_offset;
+            msg->body.decode.dt_chroma_bottom_offset = msg->body.decode.dt_chroma_top_offset;
+            msg->body.decode.dt_surf_tile_config = 0;
+      } else {
+            msg->body.decode.dt_pitch = luma->surface.u.legacy.level[0].nblk_x * luma->surface.blk_w;
+            switch (luma->surface.u.legacy.level[0].mode) {
+                  case RADEON_SURF_MODE_LINEAR_ALIGNED:
+                        msg->body.decode.dt_tiling_mode = RUVD_TILE_LINEAR;
+                        msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_LINEAR;
+                        break;
+                  case RADEON_SURF_MODE_1D:
+                        msg->body.decode.dt_tiling_mode = RUVD_TILE_8X8;
+                        msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_1D_THIN;
+                        break;
+                  case RADEON_SURF_MODE_2D:
+                        msg->body.decode.dt_tiling_mode = RUVD_TILE_8X8;
+                        msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_2D_THIN;
+                        break;
+                  default:
+                        assert(0);
+                        break;
+            }
+
+            msg->body.decode.dt_luma_top_offset = texture_offset_legacy(&luma->surface, dt_array_idx);
+            if (chroma)
+                  msg->body.decode.dt_chroma_top_offset = texture_offset_legacy(&chroma->surface, dt_array_idx);
+            msg->body.decode.dt_luma_bottom_offset = msg->body.decode.dt_luma_top_offset;
+            msg->body.decode.dt_chroma_bottom_offset = msg->body.decode.dt_chroma_top_offset;
+
+            if (chroma) {
+                  assert(luma->surface.u.legacy.bankw == chroma->surface.u.legacy.bankw);
+                  assert(luma->surface.u.legacy.bankh == chroma->surface.u.legacy.bankh);
+                  assert(luma->surface.u.legacy.mtilea == chroma->surface.u.legacy.mtilea);
+            }
+
+            msg->body.decode.dt_surf_tile_config |= RUVD_BANK_WIDTH(util_logbase2(luma->surface.u.legacy.bankw));
+            msg->body.decode.dt_surf_tile_config |= RUVD_BANK_HEIGHT(util_logbase2(luma->surface.u.legacy.bankh));
+            msg->body.decode.dt_surf_tile_config |=
+            RUVD_MACRO_TILE_ASPECT_RATIO(util_logbase2(luma->surface.u.legacy.mtilea));
       }
 
-      msg->body.decode.dt_surf_tile_config |= RUVD_BANK_WIDTH(util_logbase2(luma->surface.u.legacy.bankw));
-      msg->body.decode.dt_surf_tile_config |= RUVD_BANK_HEIGHT(util_logbase2(luma->surface.u.legacy.bankh));
-      msg->body.decode.dt_surf_tile_config |=
-         RUVD_MACRO_TILE_ASPECT_RATIO(util_logbase2(luma->surface.u.legacy.mtilea));
-   }
-
-   if (pdev->info.family >= CHIP_STONEY)
-      msg->body.decode.dt_wa_chroma_top_offset = msg->body.decode.dt_pitch / 2;
+      if (pdev->info.family >= CHIP_STONEY)
+            msg->body.decode.dt_wa_chroma_top_offset = msg->body.decode.dt_pitch / 2;
 
-   msg->body.decode.db_surf_tile_config = msg->body.decode.dt_surf_tile_config;
-   msg->body.decode.extension_support = 0x1;
+      msg->body.decode.db_surf_tile_config = msg->body.decode.dt_surf_tile_config;
+      msg->body.decode.extension_support = 0x1;
 
-   return true;
+      return true;
 }
 
 static void
 ruvd_dec_message_create(struct radv_video_session *vid, void *ptr)
 {
-   struct ruvd_msg *msg = ptr;
+      struct ruvd_msg *msg = ptr;
 
-   memset(ptr, 0, sizeof(*msg));
-   msg->size = sizeof(*msg);
-   msg->msg_type = RUVD_MSG_CREATE;
-   msg->stream_handle = vid->stream_handle;
-   msg->body.create.stream_type = vid->stream_type;
-   msg->body.create.width_in_samples = vid->vk.max_coded.width;
-   msg->body.create.height_in_samples = vid->vk.max_coded.height;
+      *msg = (struct ruvd_msg){0};
+      msg->size = sizeof(*msg);
+      msg->msg_type = RUVD_MSG_CREATE;
+      msg->stream_handle = vid->stream_handle;
+      msg->body.create.stream_type = vid->stream_type;
+      msg->body.create.width_in_samples = vid->vk.max_coded.width;
+      msg->body.create.height_in_samples = vid->vk.max_coded.height;
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo)
 {
-   VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
-   VK_FROM_HANDLE(radv_video_session, vid, pBeginInfo->videoSession);
-   VK_FROM_HANDLE(radv_video_session_params, params, pBeginInfo->videoSessionParameters);
+      VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+      VK_FROM_HANDLE(radv_video_session, vid, pBeginInfo->videoSession);
+      VK_FROM_HANDLE(radv_video_session_params, params, pBeginInfo->videoSessionParameters);
 
-   cmd_buffer->video.vid = vid;
-   cmd_buffer->video.params = params;
+      cmd_buffer->video.vid = vid;
+      cmd_buffer->video.params = params;
 }
 
 static void
 radv_vcn_cmd_reset(struct radv_cmd_buffer *cmd_buffer)
 {
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   const struct radv_physical_device *pdev = radv_device_physical(device);
-   struct radv_video_session *vid = cmd_buffer->video.vid;
-   uint32_t size = sizeof(rvcn_dec_message_header_t) + sizeof(rvcn_dec_message_create_t);
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      const struct radv_physical_device *pdev = radv_device_physical(device);
+      struct radv_video_session *vid = cmd_buffer->video.vid;
+      uint32_t size = sizeof(rvcn_dec_message_header_t) + sizeof(rvcn_dec_message_create_t);
+
+      void *ptr;
+      uint32_t out_offset;
+
+      if (vid->stream_type == RDECODE_CODEC_VP9) {
+            uint8_t *ctxptr = radv_buffer_map(device->ws, vid->ctx.mem->bo);
+            ctxptr += vid->ctx.offset;
+            ac_vcn_vp9_fill_probs_table(ctxptr);
+            device->ws->buffer_unmap(device->ws, vid->ctx.mem->bo, false);
+      }
+      if (vid->stream_type == RDECODE_CODEC_AV1) {
+            uint8_t *ctxptr = radv_buffer_map(device->ws, vid->ctx.mem->bo);
+            ctxptr += vid->ctx.offset;
+            ac_vcn_av1_init_probs(pdev->av1_version, ctxptr);
+            device->ws->buffer_unmap(device->ws, vid->ctx.mem->bo, false);
+      }
+      radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
 
-   void *ptr;
-   uint32_t out_offset;
+      if (pdev->vid_decode_ip == AMD_IP_VCN_UNIFIED)
+            radv_vcn_sq_start(cmd_buffer);
 
-   if (vid->stream_type == RDECODE_CODEC_VP9) {
-      uint8_t *ctxptr = radv_buffer_map(device->ws, vid->ctx.mem->bo);
-      ctxptr += vid->ctx.offset;
-      ac_vcn_vp9_fill_probs_table(ctxptr);
-      device->ws->buffer_unmap(device->ws, vid->ctx.mem->bo, false);
-   }
-   if (vid->stream_type == RDECODE_CODEC_AV1) {
-      uint8_t *ctxptr = radv_buffer_map(device->ws, vid->ctx.mem->bo);
-      ctxptr += vid->ctx.offset;
-      ac_vcn_av1_init_probs(pdev->av1_version, ctxptr);
-      device->ws->buffer_unmap(device->ws, vid->ctx.mem->bo, false);
-   }
-   radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
-
-   if (pdev->vid_decode_ip == AMD_IP_VCN_UNIFIED)
-      radv_vcn_sq_start(cmd_buffer);
-
-   rvcn_dec_message_create(vid, ptr, size);
-   send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
-            radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
-   send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, cmd_buffer->upload.upload_bo,
-            radv_buffer_get_va(cmd_buffer->upload.upload_bo) + out_offset);
-   /* pad out the IB to the 16 dword boundary - otherwise the fw seems to be unhappy */
-
-   if (pdev->vid_decode_ip != AMD_IP_VCN_UNIFIED) {
-      radeon_check_space(device->ws, cmd_buffer->cs, 8);
-      radeon_begin(cmd_buffer->cs);
-      for (unsigned i = 0; i < 8; i++)
-         radeon_emit(0x81ff);
-      radeon_end();
-   } else
-      radv_vcn_sq_tail(cmd_buffer->cs, &cmd_buffer->video.sq);
+      rvcn_dec_message_create(vid, ptr, size);
+      send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
+               radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
+      send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, cmd_buffer->upload.upload_bo,
+               radv_buffer_get_va(cmd_buffer->upload.upload_bo) + out_offset);
+      /* pad out the IB to the 16 dword boundary - otherwise the fw seems to be unhappy */
+
+      if (pdev->vid_decode_ip != AMD_IP_VCN_UNIFIED) {
+            radeon_check_space(device->ws, cmd_buffer->cs, 8);
+            radeon_begin(cmd_buffer->cs);
+            for (unsigned i = 0; i < 8; i++)
+                  radeon_emit(0x81ff);
+            radeon_end();
+      } else
+            radv_vcn_sq_tail(cmd_buffer->cs, &cmd_buffer->video.sq);
 }
 
 static void
 radv_uvd_cmd_reset(struct radv_cmd_buffer *cmd_buffer)
 {
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   struct radv_video_session *vid = cmd_buffer->video.vid;
-   uint32_t size = sizeof(struct ruvd_msg);
-   void *ptr;
-   uint32_t out_offset;
-   radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
-
-   ruvd_dec_message_create(vid, ptr);
-   if (vid->sessionctx.mem)
-      send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
-               radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
-   send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, cmd_buffer->upload.upload_bo,
-            radv_buffer_get_va(cmd_buffer->upload.upload_bo) + out_offset);
-
-   /* pad out the IB to the 16 dword boundary - otherwise the fw seems to be unhappy */
-   int padsize = vid->sessionctx.mem ? 4 : 6;
-   radeon_check_space(device->ws, cmd_buffer->cs, padsize);
-   radeon_begin(cmd_buffer->cs);
-   for (unsigned i = 0; i < padsize; i++)
-      radeon_emit(PKT2_NOP_PAD);
-   radeon_end();
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      struct radv_video_session *vid = cmd_buffer->video.vid;
+      uint32_t size = sizeof(struct ruvd_msg);
+      void *ptr;
+      uint32_t out_offset;
+      radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
+
+      ruvd_dec_message_create(vid, ptr);
+      if (vid->sessionctx.mem)
+            send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
+                     radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
+            send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, cmd_buffer->upload.upload_bo,
+                     radv_buffer_get_va(cmd_buffer->upload.upload_bo) + out_offset);
+
+            /* pad out the IB to the 16 dword boundary - otherwise the fw seems to be unhappy */
+            int padsize = vid->sessionctx.mem ? 4 : 6;
+      radeon_check_space(device->ws, cmd_buffer->cs, padsize);
+      radeon_begin(cmd_buffer->cs);
+      for (unsigned i = 0; i < padsize; i++)
+            radeon_emit(PKT2_NOP_PAD);
+      radeon_end();
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo)
 {
-   VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   struct radv_physical_device *pdev = radv_device_physical(device);
-
-   if (cmd_buffer->video.vid->encode) {
-      radv_video_enc_control_video_coding(cmd_buffer, pCodingControlInfo);
-      return;
-   }
-   if (pCodingControlInfo->flags & VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR) {
-      if (radv_has_uvd(pdev))
-         radv_uvd_cmd_reset(cmd_buffer);
-      else
-         radv_vcn_cmd_reset(cmd_buffer);
-   }
+      VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      struct radv_physical_device *pdev = radv_device_physical(device);
+
+      if (cmd_buffer->video.vid->encode) {
+            radv_video_enc_control_video_coding(cmd_buffer, pCodingControlInfo);
+            return;
+      }
+      if (pCodingControlInfo->flags & VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR) {
+            if (radv_has_uvd(pdev))
+                  radv_uvd_cmd_reset(cmd_buffer);
+            else
+                  radv_vcn_cmd_reset(cmd_buffer);
+      }
 }
 
 VKAPI_ATTR void VKAPI_CALL
@@ -2947,215 +2948,215 @@ radv_CmdEndVideoCodingKHR(VkCommandBuffe
 static void
 radv_uvd_decode_video(struct radv_cmd_buffer *cmd_buffer, const VkVideoDecodeInfoKHR *frame_info)
 {
-   VK_FROM_HANDLE(radv_buffer, src_buffer, frame_info->srcBuffer);
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   const struct radv_physical_device *pdev = radv_device_physical(device);
-   struct radv_video_session *vid = cmd_buffer->video.vid;
-   struct radv_video_session_params *params = cmd_buffer->video.params;
-   unsigned size = sizeof(struct ruvd_msg);
-   void *ptr, *fb_ptr, *it_probs_ptr = NULL;
-   uint32_t out_offset, fb_offset, it_probs_offset = 0;
-   struct radeon_winsys_bo *msg_bo, *fb_bo, *it_probs_bo = NULL;
-   unsigned fb_size = (pdev->info.family == CHIP_TONGA) ? FB_BUFFER_SIZE_TONGA : FB_BUFFER_SIZE;
-
-   radv_vid_buffer_upload_alloc(cmd_buffer, fb_size, &fb_offset, &fb_ptr);
-   fb_bo = cmd_buffer->upload.upload_bo;
-   if (have_it(vid)) {
-      radv_vid_buffer_upload_alloc(cmd_buffer, IT_SCALING_TABLE_SIZE, &it_probs_offset, &it_probs_ptr);
-      it_probs_bo = cmd_buffer->upload.upload_bo;
-   }
-
-   radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
-   msg_bo = cmd_buffer->upload.upload_bo;
-
-   uint32_t slice_offset;
-   ruvd_dec_message_decode(device, vid, params, ptr, it_probs_ptr, &slice_offset, frame_info);
-   rvcn_dec_message_feedback(fb_ptr);
-   if (vid->sessionctx.mem)
-      send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
-               radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
-   send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, msg_bo, radv_buffer_get_va(msg_bo) + out_offset);
+      VK_FROM_HANDLE(radv_buffer, src_buffer, frame_info->srcBuffer);
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      const struct radv_physical_device *pdev = radv_device_physical(device);
+      struct radv_video_session *vid = cmd_buffer->video.vid;
+      struct radv_video_session_params *params = cmd_buffer->video.params;
+      unsigned size = sizeof(struct ruvd_msg);
+      void *ptr, *fb_ptr, *it_probs_ptr = NULL;
+      uint32_t out_offset, fb_offset, it_probs_offset = 0;
+      struct radeon_winsys_bo *msg_bo, *fb_bo, *it_probs_bo = NULL;
+      unsigned fb_size = (pdev->info.family == CHIP_TONGA) ? FB_BUFFER_SIZE_TONGA : FB_BUFFER_SIZE;
+
+      radv_vid_buffer_upload_alloc(cmd_buffer, fb_size, &fb_offset, &fb_ptr);
+      fb_bo = cmd_buffer->upload.upload_bo;
+      if (have_it(vid)) {
+            radv_vid_buffer_upload_alloc(cmd_buffer, IT_SCALING_TABLE_SIZE, &it_probs_offset, &it_probs_ptr);
+            it_probs_bo = cmd_buffer->upload.upload_bo;
+      }
+
+      radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
+      msg_bo = cmd_buffer->upload.upload_bo;
+
+      uint32_t slice_offset;
+      ruvd_dec_message_decode(device, vid, params, ptr, it_probs_ptr, &slice_offset, frame_info);
+      rvcn_dec_message_feedback(fb_ptr);
+      if (vid->sessionctx.mem)
+            send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
+                     radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
+            send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, msg_bo, radv_buffer_get_va(msg_bo) + out_offset);
 
-   if (vid->dpb_type != DPB_DYNAMIC_TIER_2) {
-      struct radv_image_view *dpb_iv =
-         radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding);
-      struct radv_image *dpb = dpb_iv->image;
-      send_cmd(cmd_buffer, RDECODE_CMD_DPB_BUFFER, dpb->bindings[0].bo, dpb->bindings[0].addr);
-   }
+      if (vid->dpb_type != DPB_DYNAMIC_TIER_2) {
+            struct radv_image_view *dpb_iv =
+            radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding);
+            struct radv_image *dpb = dpb_iv->image;
+            send_cmd(cmd_buffer, RDECODE_CMD_DPB_BUFFER, dpb->bindings[0].bo, dpb->bindings[0].addr);
+      }
 
-   if (vid->ctx.mem)
-      send_cmd(cmd_buffer, RDECODE_CMD_CONTEXT_BUFFER, vid->ctx.mem->bo,
-               radv_buffer_get_va(vid->ctx.mem->bo) + vid->ctx.offset);
-
-   send_cmd(cmd_buffer, RDECODE_CMD_BITSTREAM_BUFFER, src_buffer->bo,
-            vk_buffer_address(&src_buffer->vk, frame_info->srcBufferOffset + slice_offset));
-
-   struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
-   struct radv_image *img = dst_iv->image;
-   send_cmd(cmd_buffer, RDECODE_CMD_DECODING_TARGET_BUFFER, img->bindings[0].bo, img->bindings[0].addr);
-   send_cmd(cmd_buffer, RDECODE_CMD_FEEDBACK_BUFFER, fb_bo, radv_buffer_get_va(fb_bo) + fb_offset);
-   if (have_it(vid))
-      send_cmd(cmd_buffer, RDECODE_CMD_IT_SCALING_TABLE_BUFFER, it_probs_bo,
-               radv_buffer_get_va(it_probs_bo) + it_probs_offset);
+      if (vid->ctx.mem)
+            send_cmd(cmd_buffer, RDECODE_CMD_CONTEXT_BUFFER, vid->ctx.mem->bo,
+                     radv_buffer_get_va(vid->ctx.mem->bo) + vid->ctx.offset);
+
+            send_cmd(cmd_buffer, RDECODE_CMD_BITSTREAM_BUFFER, src_buffer->bo,
+                     vk_buffer_address(&src_buffer->vk, frame_info->srcBufferOffset + slice_offset));
 
-   radeon_check_space(device->ws, cmd_buffer->cs, 2);
-   set_reg(cmd_buffer, pdev->vid_dec_reg.cntl, 1);
+            struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
+      struct radv_image *img = dst_iv->image;
+      send_cmd(cmd_buffer, RDECODE_CMD_DECODING_TARGET_BUFFER, img->bindings[0].bo, img->bindings[0].addr);
+      send_cmd(cmd_buffer, RDECODE_CMD_FEEDBACK_BUFFER, fb_bo, radv_buffer_get_va(fb_bo) + fb_offset);
+      if (have_it(vid))
+            send_cmd(cmd_buffer, RDECODE_CMD_IT_SCALING_TABLE_BUFFER, it_probs_bo,
+                     radv_buffer_get_va(it_probs_bo) + it_probs_offset);
+
+            radeon_check_space(device->ws, cmd_buffer->cs, 2);
+      set_reg(cmd_buffer, pdev->vid_dec_reg.cntl, 1);
 }
 
 static void
 radv_vcn_decode_video(struct radv_cmd_buffer *cmd_buffer, const VkVideoDecodeInfoKHR *frame_info)
 {
-   VK_FROM_HANDLE(radv_buffer, src_buffer, frame_info->srcBuffer);
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   const struct radv_physical_device *pdev = radv_device_physical(device);
-   struct radv_video_session *vid = cmd_buffer->video.vid;
-   struct radv_video_session_params *params = cmd_buffer->video.params;
-   unsigned size = 0;
-   void *ptr, *fb_ptr, *it_probs_ptr = NULL;
-   uint32_t out_offset, fb_offset, it_probs_offset = 0;
-   struct radeon_winsys_bo *msg_bo, *fb_bo, *it_probs_bo = NULL;
-
-   size += sizeof(rvcn_dec_message_header_t); /* header */
-   size += sizeof(rvcn_dec_message_index_t);  /* codec */
-   if (vid->dpb_type == DPB_DYNAMIC_TIER_1) {
-      size += sizeof(rvcn_dec_message_index_t);
-      size += sizeof(rvcn_dec_message_dynamic_dpb_t);
-   } else  if (vid->dpb_type == DPB_DYNAMIC_TIER_2) {
-      size += sizeof(rvcn_dec_message_index_t);
-      size += sizeof(rvcn_dec_message_dynamic_dpb_t2_t);
-   }
-   size += sizeof(rvcn_dec_message_decode_t); /* decode */
-   switch (vid->vk.op) {
-   case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
-      size += sizeof(rvcn_dec_message_avc_t);
-      break;
-   case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR:
-      size += sizeof(rvcn_dec_message_hevc_t);
-      break;
-   case VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR:
-      size += sizeof(rvcn_dec_message_av1_t);
-      break;
-   case VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR:
-      size += sizeof(rvcn_dec_message_vp9_t);
-      break;
-   default:
-      unreachable("unsupported codec.");
-   }
+      VK_FROM_HANDLE(radv_buffer, src_buffer, frame_info->srcBuffer);
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      const struct radv_physical_device *pdev = radv_device_physical(device);
+      struct radv_video_session *vid = cmd_buffer->video.vid;
+      struct radv_video_session_params *params = cmd_buffer->video.params;
+      unsigned size = 0;
+      void *ptr, *fb_ptr, *it_probs_ptr = NULL;
+      uint32_t out_offset, fb_offset, it_probs_offset = 0;
+      struct radeon_winsys_bo *msg_bo, *fb_bo, *it_probs_bo = NULL;
 
-   radv_vid_buffer_upload_alloc(cmd_buffer, FB_BUFFER_SIZE, &fb_offset, &fb_ptr);
-   fb_bo = cmd_buffer->upload.upload_bo;
-   if (have_it(vid)) {
-      radv_vid_buffer_upload_alloc(cmd_buffer, IT_SCALING_TABLE_SIZE, &it_probs_offset, &it_probs_ptr);
-      it_probs_bo = cmd_buffer->upload.upload_bo;
-   } else if (have_probs(vid)) {
-      size_t sz = 0;
+      size += sizeof(rvcn_dec_message_header_t); /* header */
+      size += sizeof(rvcn_dec_message_index_t);  /* codec */
+      if (vid->dpb_type == DPB_DYNAMIC_TIER_1) {
+            size += sizeof(rvcn_dec_message_index_t);
+            size += sizeof(rvcn_dec_message_dynamic_dpb_t);
+      } else  if (vid->dpb_type == DPB_DYNAMIC_TIER_2) {
+            size += sizeof(rvcn_dec_message_index_t);
+            size += sizeof(rvcn_dec_message_dynamic_dpb_t2_t);
+      }
+      size += sizeof(rvcn_dec_message_decode_t); /* decode */
+      switch (vid->vk.op) {
+            case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
+                  size += sizeof(rvcn_dec_message_avc_t);
+                  break;
+            case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR:
+                  size += sizeof(rvcn_dec_message_hevc_t);
+                  break;
+            case VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR:
+                  size += sizeof(rvcn_dec_message_av1_t);
+                  break;
+            case VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR:
+                  size += sizeof(rvcn_dec_message_vp9_t);
+                  break;
+            default:
+                  unreachable("unsupported codec.");
+      }
+
+      radv_vid_buffer_upload_alloc(cmd_buffer, FB_BUFFER_SIZE, &fb_offset, &fb_ptr);
+      fb_bo = cmd_buffer->upload.upload_bo;
+      if (have_it(vid)) {
+            radv_vid_buffer_upload_alloc(cmd_buffer, IT_SCALING_TABLE_SIZE, &it_probs_offset, &it_probs_ptr);
+            it_probs_bo = cmd_buffer->upload.upload_bo;
+      } else if (have_probs(vid)) {
+            size_t sz = 0;
+
+            if (vid->stream_type == RDECODE_CODEC_AV1) {
+                  sz = sizeof(rvcn_dec_av1_segment_fg_t);
+            } else if (vid->stream_type == RDECODE_CODEC_VP9) {
+                  sz = sizeof(rvcn_dec_vp9_probs_t) + 256;
+            }
+            radv_vid_buffer_upload_alloc(cmd_buffer, sz, &it_probs_offset, &it_probs_ptr);
+            it_probs_bo = cmd_buffer->upload.upload_bo;
+      }
+
+      radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
+      msg_bo = cmd_buffer->upload.upload_bo;
+
+      if (pdev->vid_decode_ip == AMD_IP_VCN_UNIFIED)
+            radv_vcn_sq_start(cmd_buffer);
+
+      uint32_t slice_offset;
+      rvcn_dec_message_decode(cmd_buffer, vid, params, ptr, it_probs_ptr, &slice_offset, frame_info);
+      rvcn_dec_message_feedback(fb_ptr);
+      send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
+               radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
+      send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, msg_bo, radv_buffer_get_va(msg_bo) + out_offset);
 
-      if (vid->stream_type == RDECODE_CODEC_AV1) {
-         sz = sizeof(rvcn_dec_av1_segment_fg_t);
-      } else if (vid->stream_type == RDECODE_CODEC_VP9) {
-         sz = sizeof(rvcn_dec_vp9_probs_t) + 256;
+      if (vid->dpb_type != DPB_DYNAMIC_TIER_2) {
+            if (vid->vk.max_dpb_slots == 0) {
+                  uint64_t addr = radv_buffer_get_va(vid->intra_only_dpb.mem->bo) + vid->intra_only_dpb.offset;
+                  send_cmd(cmd_buffer, RDECODE_CMD_DPB_BUFFER, vid->intra_only_dpb.mem->bo, addr);
+            } else {
+                  struct radv_image_view *dpb_iv =
+                  radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding);
+                  struct radv_image *dpb = dpb_iv->image;
+                  send_cmd(cmd_buffer, RDECODE_CMD_DPB_BUFFER, dpb->bindings[0].bo, dpb->bindings[0].addr);
+            }
       }
-      radv_vid_buffer_upload_alloc(cmd_buffer, sz, &it_probs_offset, &it_probs_ptr);
-      it_probs_bo = cmd_buffer->upload.upload_bo;
-   }
-
-   radv_vid_buffer_upload_alloc(cmd_buffer, size, &out_offset, &ptr);
-   msg_bo = cmd_buffer->upload.upload_bo;
 
-   if (pdev->vid_decode_ip == AMD_IP_VCN_UNIFIED)
-      radv_vcn_sq_start(cmd_buffer);
-
-   uint32_t slice_offset;
-   rvcn_dec_message_decode(cmd_buffer, vid, params, ptr, it_probs_ptr, &slice_offset, frame_info);
-   rvcn_dec_message_feedback(fb_ptr);
-   send_cmd(cmd_buffer, RDECODE_CMD_SESSION_CONTEXT_BUFFER, vid->sessionctx.mem->bo,
-            radv_buffer_get_va(vid->sessionctx.mem->bo) + vid->sessionctx.offset);
-   send_cmd(cmd_buffer, RDECODE_CMD_MSG_BUFFER, msg_bo, radv_buffer_get_va(msg_bo) + out_offset);
-
-   if (vid->dpb_type != DPB_DYNAMIC_TIER_2) {
-      if (vid->vk.max_dpb_slots == 0) {
-         uint64_t addr = radv_buffer_get_va(vid->intra_only_dpb.mem->bo) + vid->intra_only_dpb.offset;
-         send_cmd(cmd_buffer, RDECODE_CMD_DPB_BUFFER, vid->intra_only_dpb.mem->bo, addr);
-      } else {
-         struct radv_image_view *dpb_iv =
-            radv_image_view_from_handle(frame_info->pSetupReferenceSlot->pPictureResource->imageViewBinding);
-         struct radv_image *dpb = dpb_iv->image;
-         send_cmd(cmd_buffer, RDECODE_CMD_DPB_BUFFER, dpb->bindings[0].bo, dpb->bindings[0].addr);
-      }
-   }
+      if (vid->ctx.mem)
+            send_cmd(cmd_buffer, RDECODE_CMD_CONTEXT_BUFFER, vid->ctx.mem->bo,
+                     radv_buffer_get_va(vid->ctx.mem->bo) + vid->ctx.offset);
 
-   if (vid->ctx.mem)
-      send_cmd(cmd_buffer, RDECODE_CMD_CONTEXT_BUFFER, vid->ctx.mem->bo,
-               radv_buffer_get_va(vid->ctx.mem->bo) + vid->ctx.offset);
-
-   send_cmd(cmd_buffer, RDECODE_CMD_BITSTREAM_BUFFER, src_buffer->bo,
-            vk_buffer_address(&src_buffer->vk, frame_info->srcBufferOffset + slice_offset));
-
-   struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
-   struct radv_image *img = dst_iv->image;
-   send_cmd(cmd_buffer, RDECODE_CMD_DECODING_TARGET_BUFFER, img->bindings[0].bo, img->bindings[0].addr);
-   send_cmd(cmd_buffer, RDECODE_CMD_FEEDBACK_BUFFER, fb_bo, radv_buffer_get_va(fb_bo) + fb_offset);
-   if (have_it(vid))
-      send_cmd(cmd_buffer, RDECODE_CMD_IT_SCALING_TABLE_BUFFER, it_probs_bo,
-               radv_buffer_get_va(it_probs_bo) + it_probs_offset);
-   else if (have_probs(vid))
-      send_cmd(cmd_buffer, RDECODE_CMD_PROB_TBL_BUFFER, it_probs_bo, radv_buffer_get_va(it_probs_bo) + it_probs_offset);
+            send_cmd(cmd_buffer, RDECODE_CMD_BITSTREAM_BUFFER, src_buffer->bo,
+                     vk_buffer_address(&src_buffer->vk, frame_info->srcBufferOffset + slice_offset));
 
-   if (pdev->vid_decode_ip != AMD_IP_VCN_UNIFIED) {
-      radeon_check_space(device->ws, cmd_buffer->cs, 2);
-      set_reg(cmd_buffer, pdev->vid_dec_reg.cntl, 1);
-   } else
-      radv_vcn_sq_tail(cmd_buffer->cs, &cmd_buffer->video.sq);
+            struct radv_image_view *dst_iv = radv_image_view_from_handle(frame_info->dstPictureResource.imageViewBinding);
+      struct radv_image *img = dst_iv->image;
+      send_cmd(cmd_buffer, RDECODE_CMD_DECODING_TARGET_BUFFER, img->bindings[0].bo, img->bindings[0].addr);
+      send_cmd(cmd_buffer, RDECODE_CMD_FEEDBACK_BUFFER, fb_bo, radv_buffer_get_va(fb_bo) + fb_offset);
+      if (have_it(vid))
+            send_cmd(cmd_buffer, RDECODE_CMD_IT_SCALING_TABLE_BUFFER, it_probs_bo,
+                     radv_buffer_get_va(it_probs_bo) + it_probs_offset);
+            else if (have_probs(vid))
+                  send_cmd(cmd_buffer, RDECODE_CMD_PROB_TBL_BUFFER, it_probs_bo, radv_buffer_get_va(it_probs_bo) + it_probs_offset);
+
+      if (pdev->vid_decode_ip != AMD_IP_VCN_UNIFIED) {
+            radeon_check_space(device->ws, cmd_buffer->cs, 2);
+            set_reg(cmd_buffer, pdev->vid_dec_reg.cntl, 1);
+      } else
+            radv_vcn_sq_tail(cmd_buffer->cs, &cmd_buffer->video.sq);
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *frame_info)
 {
-   VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
-   struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
-   struct radv_physical_device *pdev = radv_device_physical(device);
+      VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+      struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+      struct radv_physical_device *pdev = radv_device_physical(device);
 
-   if (radv_has_uvd(pdev))
-      radv_uvd_decode_video(cmd_buffer, frame_info);
-   else
-      radv_vcn_decode_video(cmd_buffer, frame_info);
+      if (radv_has_uvd(pdev))
+            radv_uvd_decode_video(cmd_buffer, frame_info);
+      else
+            radv_vcn_decode_video(cmd_buffer, frame_info);
 }
 
 void
 radv_video_get_profile_alignments(struct radv_physical_device *pdev, const VkVideoProfileListInfoKHR *profile_list,
                                   uint32_t *width_align_out, uint32_t *height_align_out)
 {
-   vk_video_get_profile_alignments(profile_list, width_align_out, height_align_out);
-   bool is_h265_main_10 = false;
+      vk_video_get_profile_alignments(profile_list, width_align_out, height_align_out);
+      bool is_h265_main_10 = false;
 
-   if (profile_list) {
-      for (unsigned i = 0; i < profile_list->profileCount; i++) {
-         if (profile_list->pProfiles[i].videoCodecOperation == VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR) {
-            const struct VkVideoDecodeH265ProfileInfoKHR *h265_profile =
-               vk_find_struct_const(profile_list->pProfiles[i].pNext, VIDEO_DECODE_H265_PROFILE_INFO_KHR);
-            if (h265_profile->stdProfileIdc == STD_VIDEO_H265_PROFILE_IDC_MAIN_10)
-               is_h265_main_10 = true;
-         }
-      }
-   } else
-      is_h265_main_10 = true;
-
-   uint32_t db_alignment = radv_video_get_db_alignment(pdev, 64, is_h265_main_10);
-   *width_align_out = MAX2(*width_align_out, db_alignment);
-   *height_align_out = MAX2(*height_align_out, db_alignment);
+      if (profile_list) {
+            for (unsigned i = 0; i < profile_list->profileCount; i++) {
+                  if (profile_list->pProfiles[i].videoCodecOperation == VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR) {
+                        const struct VkVideoDecodeH265ProfileInfoKHR *h265_profile =
+                        vk_find_struct_const(profile_list->pProfiles[i].pNext, VIDEO_DECODE_H265_PROFILE_INFO_KHR);
+                        if (h265_profile->stdProfileIdc == STD_VIDEO_H265_PROFILE_IDC_MAIN_10)
+                              is_h265_main_10 = true;
+                  }
+            }
+      } else
+            is_h265_main_10 = true;
+
+      uint32_t db_alignment = radv_video_get_db_alignment(pdev, 64, is_h265_main_10);
+      *width_align_out = MAX2(*width_align_out, db_alignment);
+      *height_align_out = MAX2(*height_align_out, db_alignment);
 }
 
 bool
 radv_video_decode_vp9_supported(const struct radv_physical_device *pdev)
 {
-   if (pdev->info.vcn_ip_version >= VCN_5_0_0)
-      return radv_check_vcn_fw_version(pdev, 9, 7, 18);
-   else if (pdev->info.vcn_ip_version >= VCN_4_0_0)
-      return radv_check_vcn_fw_version(pdev, 9, 23, 13);
-   else if (pdev->info.vcn_ip_version >= VCN_3_0_0)
-      return radv_check_vcn_fw_version(pdev, 4, 33, 7);
-   else if (pdev->info.vcn_ip_version >= VCN_2_0_0)
-      return radv_check_vcn_fw_version(pdev, 8, 24, 4);
-   else
-      return false;
+      if (pdev->info.vcn_ip_version >= VCN_5_0_0)
+            return radv_check_vcn_fw_version(pdev, 9, 7, 18);
+      else if (pdev->info.vcn_ip_version >= VCN_4_0_0)
+            return radv_check_vcn_fw_version(pdev, 9, 23, 13);
+      else if (pdev->info.vcn_ip_version >= VCN_3_0_0)
+            return radv_check_vcn_fw_version(pdev, 4, 33, 7);
+      else if (pdev->info.vcn_ip_version >= VCN_2_0_0)
+            return radv_check_vcn_fw_version(pdev, 8, 24, 4);
+      else
+            return false;
 }
