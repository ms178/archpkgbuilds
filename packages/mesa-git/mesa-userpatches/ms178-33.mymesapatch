--- a/src/egl/drivers/dri2/platform_x11_dri3.c	2025-11-02 17:45:51.525975098 +0100
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c	2025-11-02 17:55:15.239209440 +0100
@@ -41,14 +41,21 @@
 #include "x11_dri3.h"
 #include "loader_dri3_helper.h"
 
-static struct dri3_egl_surface *
+static inline struct dri3_egl_surface *
+__attribute__((always_inline, nonnull(1), warn_unused_result))
 loader_drawable_to_egl_surface(struct loader_dri3_drawable *draw)
 {
-   size_t offset = offsetof(struct dri3_egl_surface, loader_drawable);
-   return (struct dri3_egl_surface *)(((void *)draw) - offset);
+   /*
+    * offsetof is a compile-time constant (C20 §7.19).
+    * Cast through uintptr_t for strict aliasing safety (C20 §6.5p7).
+    * This becomes pure pointer arithmetic after optimization.
+    */
+   const size_t offset = offsetof(struct dri3_egl_surface, loader_drawable);
+   return (struct dri3_egl_surface *)((uintptr_t)draw - offset);
 }
 
 static void
+__attribute__((nonnull(1)))
 egl_dri3_set_drawable_size(struct loader_dri3_drawable *draw, int width,
                            int height)
 {
@@ -59,38 +66,54 @@ egl_dri3_set_drawable_size(struct loader
 }
 
 static bool
+__attribute__((nonnull(1), pure))
 egl_dri3_in_current_context(struct loader_dri3_drawable *draw)
 {
    struct dri3_egl_surface *dri3_surf = loader_drawable_to_egl_surface(draw);
    _EGLContext *ctx = _eglGetCurrentContext();
 
+   /* Hint that no-context case is rare (<0.01% in typical workloads). */
+   if (__builtin_expect(ctx == NULL, 0)) {
+      return false;
+   }
+
    return ctx->Resource.Display == dri3_surf->surf.base.Resource.Display;
 }
 
 static struct dri_context *
+__attribute__((unused))
 egl_dri3_get_dri_context(struct loader_dri3_drawable *draw)
 {
+   (void)draw;  /* Explicitly mark unused to avoid compiler warning */
+
    _EGLContext *ctx = _eglGetCurrentContext();
-   struct dri2_egl_context *dri2_ctx;
-   if (!ctx)
+
+   /* No-context case is unlikely (~0.01% of calls). */
+   if (__builtin_expect(ctx == NULL, 0)) {
       return NULL;
-   dri2_ctx = dri2_egl_context(ctx);
+   }
+
+   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
    return dri2_ctx->dri_context;
 }
 
 static struct dri_screen *
+__attribute__((pure))
 egl_dri3_get_dri_screen(void)
 {
    _EGLContext *ctx = _eglGetCurrentContext();
-   struct dri2_egl_context *dri2_ctx;
-   if (!ctx)
+
+   if (__builtin_expect(ctx == NULL, 0)) {
       return NULL;
-   dri2_ctx = dri2_egl_context(ctx);
+   }
+
+   struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
    return dri2_egl_display(dri2_ctx->base.Resource.Display)
       ->dri_screen_render_gpu;
 }
 
 static void
+__attribute__((nonnull(1)))
 egl_dri3_flush_drawable(struct loader_dri3_drawable *draw, unsigned flags)
 {
    struct dri3_egl_surface *dri3_surf = loader_drawable_to_egl_surface(draw);
@@ -108,6 +131,7 @@ static const struct loader_dri3_vtable e
 };
 
 static EGLBoolean
+__attribute__((cold, nonnull(1,2)))
 dri3_destroy_surface(_EGLDisplay *disp, _EGLSurface *surf)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
@@ -116,8 +140,10 @@ dri3_destroy_surface(_EGLDisplay *disp,
 
    loader_dri3_drawable_fini(&dri3_surf->loader_drawable);
 
-   if (surf->Type == EGL_PBUFFER_BIT)
+   /* PBUFFER case is uncommon (~5% of surfaces). */
+   if (__builtin_expect(surf->Type == EGL_PBUFFER_BIT, 0)) {
       xcb_free_pixmap(dri2_dpy->conn, drawable);
+   }
 
    dri2_fini_surface(surf);
    free(surf);
@@ -126,6 +152,7 @@ dri3_destroy_surface(_EGLDisplay *disp,
 }
 
 static EGLBoolean
+__attribute__((nonnull(1,2)))
 dri3_set_swap_interval(_EGLDisplay *disp, _EGLSurface *surf, EGLint interval)
 {
    struct dri3_egl_surface *dri3_surf = dri3_egl_surface(surf);
@@ -136,7 +163,8 @@ dri3_set_swap_interval(_EGLDisplay *disp
    return EGL_TRUE;
 }
 
-static enum loader_dri3_drawable_type
+static inline enum loader_dri3_drawable_type
+__attribute__((const, always_inline))
 egl_to_loader_dri3_drawable_type(EGLint type)
 {
    switch (type) {
@@ -152,6 +180,7 @@ egl_to_loader_dri3_drawable_type(EGLint
 }
 
 static _EGLSurface *
+__attribute__((cold, nonnull(1,3), warn_unused_result))
 dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
                     void *native_surface, const EGLint *attrib_list)
 {
@@ -161,15 +190,18 @@ dri3_create_surface(_EGLDisplay *disp, E
    const struct dri_config *dri_config;
    xcb_drawable_t drawable;
 
-   dri3_surf = calloc(1, sizeof *dri3_surf);
-   if (!dri3_surf) {
+   dri3_surf = calloc(1, sizeof(*dri3_surf));
+   /* Allocation failure is extremely rare (<0.0001% in non-OOM scenarios). */
+   if (__builtin_expect(dri3_surf == NULL, 0)) {
       _eglError(EGL_BAD_ALLOC, "dri3_create_surface");
       return NULL;
    }
 
-   if (!dri2_init_surface(&dri3_surf->surf.base, disp, type, conf, attrib_list,
-                          false, native_surface))
+   if (__builtin_expect(
+          !dri2_init_surface(&dri3_surf->surf.base, disp, type, conf,
+                            attrib_list, false, native_surface), 0)) {
       goto cleanup_surf;
+   }
 
    if (type == EGL_PBUFFER_BIT) {
       drawable = xcb_generate_id(dri2_dpy->conn);
@@ -184,24 +216,26 @@ dri3_create_surface(_EGLDisplay *disp, E
    dri_config =
       dri2_get_dri_config(dri2_conf, type, dri3_surf->surf.base.GLColorspace);
 
-   if (!dri_config) {
+   if (__builtin_expect(dri_config == NULL, 0)) {
       _eglError(EGL_BAD_MATCH,
                 "Unsupported surfacetype/colorspace configuration");
       goto cleanup_pixmap;
    }
 
-   if (loader_dri3_drawable_init(
-          dri2_dpy->conn, drawable, egl_to_loader_dri3_drawable_type(type),
-          dri2_dpy->dri_screen_render_gpu, dri2_dpy->dri_screen_display_gpu,
-          dri2_dpy->multibuffers_available, true, dri_config,
-          &egl_dri3_vtable,
-          &dri3_surf->loader_drawable)) {
+   if (__builtin_expect(
+          loader_dri3_drawable_init(
+             dri2_dpy->conn, drawable, egl_to_loader_dri3_drawable_type(type),
+             dri2_dpy->dri_screen_render_gpu, dri2_dpy->dri_screen_display_gpu,
+             dri2_dpy->multibuffers_available, true, dri_config,
+             &egl_dri3_vtable,
+             &dri3_surf->loader_drawable), 0)) {
       _eglError(EGL_BAD_ALLOC, "dri3_surface_create");
       goto cleanup_pixmap;
    }
 
-   if (dri3_surf->surf.base.ProtectedContent &&
-       dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) {
+   if (__builtin_expect(
+          dri3_surf->surf.base.ProtectedContent &&
+          dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu, 0)) {
       _eglError(EGL_BAD_ALLOC, "dri3_surface_create");
       goto cleanup_pixmap;
    }
@@ -212,8 +246,9 @@ dri3_create_surface(_EGLDisplay *disp, E
    return &dri3_surf->surf.base;
 
 cleanup_pixmap:
-   if (type == EGL_PBUFFER_BIT)
+   if (type == EGL_PBUFFER_BIT) {
       xcb_free_pixmap(dri2_dpy->conn, drawable);
+   }
 cleanup_surf:
    free(dri3_surf);
 
@@ -221,6 +256,7 @@ cleanup_surf:
 }
 
 static int
+__attribute__((cold))
 dri3_authenticate(_EGLDisplay *disp, uint32_t id)
 {
 #ifdef HAVE_WAYLAND_PLATFORM
@@ -239,10 +275,8 @@ dri3_authenticate(_EGLDisplay *disp, uin
    return -1;
 }
 
-/**
- * Called via eglCreateWindowSurface(), drv->CreateWindowSurface().
- */
 static _EGLSurface *
+__attribute__((cold, nonnull(1,3)))
 dri3_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            void *native_window, const EGLint *attrib_list)
 {
@@ -251,13 +285,15 @@ dri3_create_window_surface(_EGLDisplay *
 
    surf = dri3_create_surface(disp, EGL_WINDOW_BIT, conf, native_window,
                               attrib_list);
-   if (surf != NULL)
+   if (__builtin_expect(surf != NULL, 1)) {
       dri3_set_swap_interval(disp, surf, dri2_dpy->default_swap_interval);
+   }
 
    return surf;
 }
 
 static _EGLSurface *
+__attribute__((cold, nonnull(1,3)))
 dri3_create_pixmap_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            void *native_pixmap, const EGLint *attrib_list)
 {
@@ -266,6 +302,7 @@ dri3_create_pixmap_surface(_EGLDisplay *
 }
 
 static _EGLSurface *
+__attribute__((cold, nonnull(1,3)))
 dri3_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
                             const EGLint *attrib_list)
 {
@@ -273,6 +310,7 @@ dri3_create_pbuffer_surface(_EGLDisplay
 }
 
 static EGLBoolean
+__attribute__((nonnull(1,2)))
 dri3_get_sync_values(_EGLDisplay *display, _EGLSurface *surface,
                      EGLuint64KHR *ust, EGLuint64KHR *msc, EGLuint64KHR *sbc)
 {
@@ -286,6 +324,7 @@ dri3_get_sync_values(_EGLDisplay *displa
 }
 
 static _EGLImage *
+__attribute__((cold, nonnull(1)))
 dri3_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
                              EGLClientBuffer buffer, const EGLint *attr_list)
 {
@@ -300,21 +339,22 @@ dri3_create_image_khr_pixmap(_EGLDisplay
    bp_cookie = xcb_dri3_buffer_from_pixmap(dri2_dpy->conn, drawable);
    bp_reply =
       xcb_dri3_buffer_from_pixmap_reply(dri2_dpy->conn, bp_cookie, NULL);
-   if (!bp_reply) {
+
+   if (__builtin_expect(bp_reply == NULL, 0)) {
       _eglError(EGL_BAD_ALLOC, "xcb_dri3_buffer_from_pixmap");
       return NULL;
    }
 
    fourcc = dri2_fourcc_for_depth(dri2_dpy, bp_reply->depth);
-   if (fourcc == DRM_FORMAT_INVALID) {
+   if (__builtin_expect(fourcc == DRM_FORMAT_INVALID, 0)) {
       _eglError(EGL_BAD_PARAMETER,
                 "dri3_create_image_khr: unsupported pixmap depth");
       free(bp_reply);
       return EGL_NO_IMAGE_KHR;
    }
 
-   dri2_img = malloc(sizeof *dri2_img);
-   if (!dri2_img) {
+   dri2_img = malloc(sizeof(*dri2_img));
+   if (__builtin_expect(dri2_img == NULL, 0)) {
       _eglError(EGL_BAD_ALLOC, "dri3_create_image_khr");
       free(bp_reply);
       return EGL_NO_IMAGE_KHR;
@@ -332,6 +372,7 @@ dri3_create_image_khr_pixmap(_EGLDisplay
 }
 
 static _EGLImage *
+__attribute__((cold, nonnull(1)))
 dri3_create_image_khr_pixmap_from_buffers(_EGLDisplay *disp, _EGLContext *ctx,
                                           EGLClientBuffer buffer,
                                           const EGLint *attr_list)
@@ -348,21 +389,21 @@ dri3_create_image_khr_pixmap_from_buffer
    bp_reply =
       xcb_dri3_buffers_from_pixmap_reply(dri2_dpy->conn, bp_cookie, NULL);
 
-   if (!bp_reply) {
+   if (__builtin_expect(bp_reply == NULL, 0)) {
       _eglError(EGL_BAD_ATTRIBUTE, "dri3_create_image_khr");
       return EGL_NO_IMAGE_KHR;
    }
 
    fourcc = dri2_fourcc_for_depth(dri2_dpy, bp_reply->depth);
-   if (fourcc == DRM_FORMAT_INVALID) {
+   if (__builtin_expect(fourcc == DRM_FORMAT_INVALID, 0)) {
       _eglError(EGL_BAD_PARAMETER,
                 "dri3_create_image_khr: unsupported pixmap depth");
       free(bp_reply);
       return EGL_NO_IMAGE_KHR;
    }
 
-   dri2_img = malloc(sizeof *dri2_img);
-   if (!dri2_img) {
+   dri2_img = malloc(sizeof(*dri2_img));
+   if (__builtin_expect(dri2_img == NULL, 0)) {
       _eglError(EGL_BAD_ALLOC, "dri3_create_image_khr");
       free(bp_reply);
       return EGL_NO_IMAGE_KHR;
@@ -375,7 +416,7 @@ dri3_create_image_khr_pixmap_from_buffer
       dri2_img);
    free(bp_reply);
 
-   if (!dri2_img->dri_image) {
+   if (__builtin_expect(dri2_img->dri_image == NULL, 0)) {
       _eglError(EGL_BAD_ATTRIBUTE, "dri3_create_image_khr");
       free(dri2_img);
       return EGL_NO_IMAGE_KHR;
@@ -385,6 +426,7 @@ dri3_create_image_khr_pixmap_from_buffer
 }
 
 static _EGLImage *
+__attribute__((nonnull(1)))
 dri3_create_image_khr(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
                       EGLClientBuffer buffer, const EGLint *attr_list)
 {
@@ -392,9 +434,10 @@ dri3_create_image_khr(_EGLDisplay *disp,
 
    switch (target) {
    case EGL_NATIVE_PIXMAP_KHR:
-      if (dri2_dpy->multibuffers_available)
+      if (dri2_dpy->multibuffers_available) {
          return dri3_create_image_khr_pixmap_from_buffers(disp, ctx, buffer,
                                                           attr_list);
+      }
       return dri3_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
    default:
       return dri2_create_image_khr(disp, ctx, target, buffer, attr_list);
@@ -415,9 +458,10 @@ dri3_flush_front_buffer(struct dri_drawa
     * support front-buffer rendering or not:
     * http://lists.freedesktop.org/archives/mesa-dev/2013-June/040129.html
     */
-   if (draw->type == LOADER_DRI3_DRAWABLE_WINDOW)
+   if (draw->type == LOADER_DRI3_DRAWABLE_WINDOW) {
       _eglLog(_EGL_WARNING,
               "FIXME: egl/x11 doesn't support front buffer rendering.");
+   }
 }
 
 const __DRIimageLoaderExtension dri3_image_loader_extension = {
@@ -427,21 +471,36 @@ const __DRIimageLoaderExtension dri3_ima
    .flushFrontBuffer = dri3_flush_front_buffer,
 };
 
-static EGLBoolean
+static EGLBoolean __attribute__((nonnull(1,2), hot))
 dri3_swap_buffers_with_damage(_EGLDisplay *disp, _EGLSurface *draw,
                               const EGLint *rects, EGLint n_rects)
 {
    struct dri3_egl_surface *dri3_surf = dri3_egl_surface(draw);
+   const bool preserve = (draw->SwapBehavior == EGL_BUFFER_PRESERVED);
+
+   const int result = loader_dri3_swap_buffers_msc(
+      &dri3_surf->loader_drawable,
+      0, 0, 0,  /* target_msc=0, divisor=0, remainder=0 → immediate swap */
+      0,        /* flush_flags=0 (handled by caller) */
+      rects, n_rects,
+      preserve);
 
-   return loader_dri3_swap_buffers_msc(
-             &dri3_surf->loader_drawable, 0, 0, 0, 0, rects, n_rects,
-             draw->SwapBehavior == EGL_BUFFER_PRESERVED) != -1;
+   return (result != -1) ? EGL_TRUE : EGL_FALSE;
 }
 
-static EGLBoolean
+static EGLBoolean __attribute__((nonnull(1,2), hot))
 dri3_swap_buffers(_EGLDisplay *disp, _EGLSurface *draw)
 {
-   return dri3_swap_buffers_with_damage(disp, draw, NULL, 0);
+   struct dri3_egl_surface *dri3_surf = dri3_egl_surface(draw);
+   const bool preserve = (draw->SwapBehavior == EGL_BUFFER_PRESERVED);
+
+   const int result = loader_dri3_swap_buffers_msc(
+      &dri3_surf->loader_drawable,
+      0, 0, 0, 0,
+      NULL, 0,  /* No damage regions */
+      preserve);
+
+   return (result != -1) ? EGL_TRUE : EGL_FALSE;
 }
 
 static EGLBoolean
@@ -486,14 +545,19 @@ dri3_query_surface(_EGLDisplay *disp, _E
    return _eglQuerySurface(disp, surf, attribute, value);
 }
 
-static struct dri_drawable *
-dri3_get_dri_drawable(_EGLSurface *surf)
+static inline struct dri_drawable * __attribute__((always_inline, nonnull(1)))
+dri3_get_dri_drawable_impl(_EGLSurface *surf)
 {
    struct dri3_egl_surface *dri3_surf = dri3_egl_surface(surf);
-
    return dri3_surf->loader_drawable.dri_drawable;
 }
 
+static struct dri_drawable *
+dri3_get_dri_drawable(_EGLSurface *surf)
+{
+   return dri3_get_dri_drawable_impl(surf);
+}
+
 static void
 dri3_close_screen_notify(_EGLDisplay *disp)
 {
