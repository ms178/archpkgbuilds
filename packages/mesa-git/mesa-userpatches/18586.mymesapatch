From e69a6d7ba123873192c1457879f29d37506003f1 Mon Sep 17 00:00:00 2001
From: Eric Engestrom <eric@engestrom.ch>
Date: Sat, 8 Apr 2017 23:52:07 +0200
Subject: [PATCH 1/4] egl: split display attrib list parsing to a common
 function

Signed-off-by: Eric Engestrom <eric@engestrom.ch>
Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
---
 src/egl/main/egldisplay.c | 172 ++++++++++++++++++--------------------
 1 file changed, 82 insertions(+), 90 deletions(-)

diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index 9d49ec55dadb..80ae1951dc2a 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -222,6 +222,82 @@ _eglFiniDisplay(void)
    _eglGlobal.DisplayList = NULL;
 }
 
+static EGLBoolean
+_eglParseDisplayAttribList(_EGLPlatformType platform,
+                           void *native_display,
+                           _EGLDisplay *display,
+                           const EGLAttrib *attrib_list)
+{
+   _EGLDevice *dev = NULL;
+   int fd = -1;
+
+   if (platform == _EGL_PLATFORM_DEVICE) {
+      dev = _eglLookupDevice(native_display);
+      if (!dev) {
+         _eglError(EGL_BAD_PARAMETER, "eglGetPlatformDisplay");
+         return EGL_FALSE;
+      }
+   }
+
+   for (int i = 0; attrib_list && attrib_list[i] != EGL_NONE; i += 2) {
+      EGLAttrib attrib = attrib_list[i];
+      EGLAttrib value = attrib_list[i + 1];
+
+      switch (attrib) {
+      /* EGL_EXT_platform_x11 recognizes exactly one attribute,
+       * EGL_PLATFORM_X11_SCREEN_EXT, which is optional.
+       */
+      case EGL_PLATFORM_X11_SCREEN_EXT:
+         if (platform != _EGL_PLATFORM_X11)
+            goto bad_attribute;
+         break;
+
+      /* EGL_EXT_platform_xcb recognizes exactly one attribute,
+       * EGL_PLATFORM_XCB_SCREEN_EXT, which is optional.
+       */
+      case EGL_PLATFORM_XCB_SCREEN_EXT:
+         if (platform != _EGL_PLATFORM_XCB)
+            goto bad_attribute;
+         break;
+
+      /* EGL_EXT_platform_device does not recognize any attributes,
+       * EGL_EXT_device_drm adds the optional EGL_DRM_MASTER_FD_EXT.
+       */
+      case EGL_DRM_MASTER_FD_EXT:
+         if (platform != _EGL_PLATFORM_DEVICE ||
+             !_eglDeviceSupports(dev, _EGL_DEVICE_DRM))
+            goto bad_attribute;
+         fd = (int) value;
+         break;
+
+      default:
+         goto bad_attribute;
+      }
+   }
+
+   if (platform == _EGL_PLATFORM_DEVICE) {
+      /* If the fd is explicitly provided and we did not dup() it yet, do so.
+       * The spec mandates that we do so, since we'll need it past the
+       * eglGetPlatformDispay call.
+       *
+       * The new fd is guaranteed to be 3 or greater.
+       */
+      if (fd != -1 && display->Options.fd == 0) {
+         display->Options.fd = os_dupfd_cloexec(fd);
+         if (display->Options.fd == -1) {
+            _eglError(EGL_BAD_ALLOC, "eglGetPlatformDisplay");
+            return EGL_FALSE;
+         }
+      }
+   }
+
+   return EGL_TRUE;
+
+bad_attribute:
+   _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
+   return EGL_FALSE;
+}
+
 static EGLBoolean
 _eglSameAttribs(const EGLAttrib *a, const EGLAttrib *b)
 {
@@ -294,6 +370,12 @@ _eglFindDisplay(_EGLPlatformType plat, void *plat_dpy,
              num_attribs * sizeof(EGLAttrib));
    }
 
+   if (!_eglParseDisplayAttribList(plat, plat_dpy, disp, attrib_list)) {
+      free(disp);
+      disp = NULL;
+      goto out;
+   }
+
    /* add to the display list */
    disp->Next = _eglGlobal.DisplayList;
    _eglGlobal.DisplayList = disp;
@@ -511,17 +593,6 @@ _EGLDisplay*
 _eglGetX11Display(Display *native_display,
                   const EGLAttrib *attrib_list)
 {
-   /* EGL_EXT_platform_x11 recognizes exactly one attribute,
-    * EGL_PLATFORM_X11_SCREEN_EXT, which is optional.
-    */
-   if (attrib_list != NULL) {
-      for (int i = 0; attrib_list[i] != EGL_NONE; i += 2) {
-         if (attrib_list[i] != EGL_PLATFORM_X11_SCREEN_EXT) {
-            _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-            return NULL;
-         }
-      }
-   }
    return _eglFindDisplay(_EGL_PLATFORM_X11, native_display, attrib_list);
 }
 #endif /* HAVE_X11_PLATFORM */
@@ -531,18 +602,6 @@ _EGLDisplay*
 _eglGetXcbDisplay(xcb_connection_t *native_display,
                   const EGLAttrib *attrib_list)
 {
-   /* EGL_EXT_platform_xcb recognizes exactly one attribute,
-    * EGL_PLATFORM_XCB_SCREEN_EXT, which is optional.
-    */
-   if (attrib_list != NULL) {
-      for (int i = 0; attrib_list[i] != EGL_NONE; i += 2) {
-         if (attrib_list[i] != EGL_PLATFORM_XCB_SCREEN_EXT) {
-            _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-            return NULL;
-         }
-      }
-   }
-
    return _eglFindDisplay(_EGL_PLATFORM_XCB, native_display, attrib_list);
 }
 #endif /* HAVE_XCB_PLATFORM */
@@ -552,12 +611,6 @@ _EGLDisplay*
 _eglGetGbmDisplay(struct gbm_device *native_display,
                   const EGLAttrib *attrib_list)
 {
-   /* EGL_MESA_platform_gbm recognizes no attributes. */
-   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
-      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-      return NULL;
-   }
-
    return _eglFindDisplay(_EGL_PLATFORM_DRM, native_display, attrib_list);
 }
 #endif /* HAVE_DRM_PLATFORM */
@@ -567,12 +620,6 @@ _EGLDisplay*
 _eglGetWaylandDisplay(struct wl_display *native_display,
                       const EGLAttrib *attrib_list)
 {
-   /* EGL_EXT_platform_wayland recognizes no attributes. */
-   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
-      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-      return NULL;
-   }
-
    return _eglFindDisplay(_EGL_PLATFORM_WAYLAND, native_display, attrib_list);
 }
 #endif /* HAVE_WAYLAND_PLATFORM */
@@ -587,12 +634,6 @@ _eglGetSurfacelessDisplay(void *native_display,
       return NULL;
    }
 
-   /* This platform recognizes no display attributes. */
-   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
-      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-      return NULL;
-   }
-
    return _eglFindDisplay(_EGL_PLATFORM_SURFACELESS, native_display,
                           attrib_list);
 }
@@ -602,13 +643,6 @@ _EGLDisplay*
 _eglGetAndroidDisplay(void *native_display,
                           const EGLAttrib *attrib_list)
 {
-
-   /* This platform recognizes no display attributes. */
-   if (attrib_list != NULL && attrib_list[0] != EGL_NONE) {
-      _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-      return NULL;
-   }
-
    return _eglFindDisplay(_EGL_PLATFORM_ANDROID, native_display,
                           attrib_list);
 }
@@ -618,34 +652,7 @@ _EGLDisplay*
 _eglGetDeviceDisplay(void *native_display,
                      const EGLAttrib *attrib_list)
 {
-   _EGLDevice *dev;
    _EGLDisplay *display;
-   int fd = -1;
-
-   dev = _eglLookupDevice(native_display);
-   if (!dev) {
-      _eglError(EGL_BAD_PARAMETER, "eglGetPlatformDisplay");
-      return NULL;
-   }
-
-   if (attrib_list) {
-      for (int i = 0; attrib_list[i] != EGL_NONE; i += 2) {
-         EGLAttrib attrib = attrib_list[i];
-         EGLAttrib value = attrib_list[i + 1];
-
-         /* EGL_EXT_platform_device does not recognize any attributes,
-          * EGL_EXT_device_drm adds the optional EGL_DRM_MASTER_FD_EXT.
-          */
-
-         if (!_eglDeviceSupports(dev, _EGL_DEVICE_DRM) ||
-             attrib != EGL_DRM_MASTER_FD_EXT) {
-            _eglError(EGL_BAD_ATTRIBUTE, "eglGetPlatformDisplay");
-            return NULL;
-         }
-
-         fd = (int) value;
-      }
-   }
 
    display = _eglFindDisplay(_EGL_PLATFORM_DEVICE, native_display, attrib_list);
    if (!display) {
@@ -653,20 +660,5 @@ _eglGetDeviceDisplay(void *native_display,
       return NULL;
    }
 
-   /* If the fd is explicitly provided and we did not dup() it yet, do so.
-    * The spec mandates that we do so, since we'll need it past the
-    * eglGetPlatformDispay call.
-    *
-    * The new fd is guaranteed to be 3 or greater.
-    */
-   if (fd != -1 && display->Options.fd == 0) {
-      display->Options.fd = os_dupfd_cloexec(fd);
-      if (display->Options.fd == -1) {
-         /* Do not (really) need to teardown the display */
-         _eglError(EGL_BAD_ALLOC, "eglGetPlatformDisplay");
-         return NULL;
-      }
-   }
-
    return display;
 }
-- 
GitLab


From 7e5acdf467b46462edf75117f42826b167c69afe Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Tue, 13 Sep 2022 16:39:07 -0400
Subject: [PATCH 2/4] egl/dri2: Respect the arguments to
 dri2_set_blob_cache_funcs

This is no functional change, since this is effectively what the caller
is passing in, but it's still a layering violation.
---
 src/egl/drivers/dri2/egl_dri2.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 7614ff5a798d..d9502eaeb0a2 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -3648,9 +3648,7 @@ dri2_set_blob_cache_funcs(_EGLDisplay *disp,
                           EGLGetBlobFuncANDROID get)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
-   dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen,
-                                   disp->BlobCacheSet,
-                                   disp->BlobCacheGet);
+   dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen, set, get);
    mtx_unlock(&dri2_dpy->lock);
 }
 
-- 
GitLab


From 2c634ef2a44a50ef863e79e7d05adc5fe60fa35a Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Tue, 13 Sep 2022 17:41:10 -0400
Subject: [PATCH 3/4] egl/dri2: Fix a typo in a comment

---
 src/egl/drivers/dri2/egl_dri2.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index d9502eaeb0a2..adc272c7aca6 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1887,7 +1887,7 @@ dri2_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
          /* dri2_dpy->core->bindContext succeeded, so take a reference on the
           * dri2_dpy. This prevents dri2_dpy from being reinitialized when a
           * EGLDisplay is terminated and then initialized again while a
-          * context is still bound. See dri2_intitialize() for a more in depth
+          * context is still bound. See dri2_initialize() for a more in depth
           * explanation. */
          p_atomic_inc(&dri2_dpy->ref_count);
       }
-- 
GitLab


From 60366f88a0f510f0bf59d635d5bab9ddbf99ab18 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Tue, 13 Sep 2022 17:41:29 -0400
Subject: [PATCH 4/4] egl/dri2: Fix some thinkos in old context release

All of the objects here should be relative to the old context / display
/ surfaces. Calling disp->unbindContext() on a context that disp did not
create is likely to go poorly.
---
 src/egl/drivers/dri2/egl_dri2.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index adc272c7aca6..ba3ea867528b 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1822,10 +1822,10 @@ dri2_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
          old_dri2_dpy->vtbl->set_shared_buffer_mode(old_disp, old_dsurf, false);
       }
 
-      dri2_dpy->core->unbindContext(old_cctx);
+      old_dri2_dpy->core->unbindContext(old_cctx);
 
       if (old_dsurf)
-         dri2_surf_update_fence_fd(old_ctx, disp, old_dsurf);
+         dri2_surf_update_fence_fd(old_ctx, old_disp, old_dsurf);
    }
 
    ddraw = (dsurf) ? dri2_dpy->vtbl->get_dri_drawable(dsurf) : NULL;
-- 
GitLab

