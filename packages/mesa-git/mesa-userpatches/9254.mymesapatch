From 3afeb81be8333587a21c331902524ff8225cd754 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 4 Sep 2020 15:57:40 +0100
Subject: [PATCH 01/12] lavapipe,nv50/ir,lima: run nir_opt_algebraic_late

This will become necessary to lower fcanonicalize without creating a
fmul(a, 1.0)<->fcanonicalize(a) optimization loop.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Vasily Khoruzhick <anarsoul@gmail.com> (lima)
---
 src/gallium/drivers/lima/lima_program.c       | 4 ++++
 src/gallium/frontends/lavapipe/lvp_pipeline.c | 2 ++
 src/nouveau/codegen/nv50_ir_from_nir.cpp      | 3 +++
 3 files changed, 9 insertions(+)

diff --git a/src/gallium/drivers/lima/lima_program.c b/src/gallium/drivers/lima/lima_program.c
index 418808afcba9..983f3b998a88 100644
--- a/src/gallium/drivers/lima/lima_program.c
+++ b/src/gallium/drivers/lima/lima_program.c
@@ -150,6 +150,7 @@ lima_program_optimize_vs_nir(struct nir_shader *s)
    NIR_PASS_V(s, nir_lower_bool_to_float, true);
 
    NIR_PASS_V(s, nir_copy_prop);
+   NIR_PASS_V(s, nir_opt_algebraic_late);
    NIR_PASS_V(s, nir_opt_dce);
    NIR_PASS_V(s, lima_nir_split_loads);
    NIR_PASS_V(s, nir_lower_locals_to_regs);
@@ -264,6 +265,9 @@ lima_program_optimize_fs_nir(struct nir_shader *s,
       NIR_PASS(progress, s, nir_opt_algebraic);
    } while (progress);
 
+   NIR_PASS_V(s, nir_opt_algebraic_late);
+   NIR_PASS_V(s, nir_opt_dce);
+
    /* Must be run after optimization loop */
    NIR_PASS_V(s, lima_nir_scale_trig);
 
diff --git a/src/gallium/frontends/lavapipe/lvp_pipeline.c b/src/gallium/frontends/lavapipe/lvp_pipeline.c
index 1288223c031c..1b9194effb45 100644
--- a/src/gallium/frontends/lavapipe/lvp_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_pipeline.c
@@ -348,6 +348,8 @@ void
 lvp_shader_optimize(nir_shader *nir)
 {
    optimize(nir);
+   NIR_PASS_V(nir, nir_opt_algebraic_late);
+   NIR_PASS_V(nir, nir_opt_dce);
    NIR_PASS_V(nir, nir_lower_var_copies);
    NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp, NULL);
    NIR_PASS_V(nir, nir_opt_dce);
diff --git a/src/nouveau/codegen/nv50_ir_from_nir.cpp b/src/nouveau/codegen/nv50_ir_from_nir.cpp
index 6970dcd63bb3..771c09552e13 100644
--- a/src/nouveau/codegen/nv50_ir_from_nir.cpp
+++ b/src/nouveau/codegen/nv50_ir_from_nir.cpp
@@ -3368,6 +3368,9 @@ Converter::run()
       NIR_PASS(progress, nir, nir_lower_64bit_phis);
    } while (progress);
 
+   NIR_PASS_V(nir, nir_opt_algebraic_late);
+   NIR_PASS_V(nir, nir_opt_dce);
+
    nir_move_options move_options =
       (nir_move_options)(nir_move_const_undef |
                          nir_move_load_ubo |
-- 
GitLab


From 2781406844b4fcfbed931f14b0f0b0204fe5d157 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 26 May 2021 17:48:09 +0100
Subject: [PATCH 02/12] glsl,glsl/nir: emit exact comparisons for isnan() and
 isinf()

Comparisons in GLSL assume operands are not NaN/Inf, so we need separate
opcodes which don't have this assumtion to implement the isnan() and
isinf() builtins without being optimized away by NIR.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
---
 src/compiler/glsl/builtin_functions.cpp      |  4 ++--
 src/compiler/glsl/glsl_to_nir.cpp            | 10 ++++++++++
 src/compiler/glsl/ir.cpp                     |  2 ++
 src/compiler/glsl/ir_builder.cpp             | 12 ++++++++++++
 src/compiler/glsl/ir_builder.h               |  2 ++
 src/compiler/glsl/ir_expression_operation.py |  3 +++
 src/compiler/glsl/ir_validate.cpp            |  2 ++
 7 files changed, 33 insertions(+), 2 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index e07ac6117180..aa046e9dbe61 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -6179,7 +6179,7 @@ builtin_builder::_isnan(builtin_available_predicate avail, const glsl_type *type
    ir_variable *x = in_var(type, "x");
    MAKE_SIG(glsl_type::bvec(type->vector_elements), avail, 1, x);
 
-   body.emit(ret(nequal(x, x)));
+   body.emit(ret(nequal_exact(x, x)));
 
    return sig;
 }
@@ -6204,7 +6204,7 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
       }
    }
 
-   body.emit(ret(equal(abs(x), imm(type, infinities))));
+   body.emit(ret(equal_exact(abs(x), imm(type, infinities))));
 
    return sig;
 }
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 492caa0d854b..79f22892f928 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -2257,17 +2257,27 @@ nir_visitor::visit(ir_expression *ir)
          result = nir_uge(&b, srcs[0], srcs[1]);
       break;
    case ir_binop_equal:
+   case ir_binop_equal_exact: {
+      bool save_exact = b.exact;
+      b.exact |= ir->operation == ir_binop_equal_exact;
       if (type_is_float(types[0]))
          result = nir_feq(&b, srcs[0], srcs[1]);
       else
          result = nir_ieq(&b, srcs[0], srcs[1]);
+      b.exact = save_exact;
       break;
+   }
    case ir_binop_nequal:
+   case ir_binop_nequal_exact: {
+      bool save_exact = b.exact;
+      b.exact |= ir->operation == ir_binop_nequal_exact;
       if (type_is_float(types[0]))
          result = nir_fneu(&b, srcs[0], srcs[1]);
       else
          result = nir_ine(&b, srcs[0], srcs[1]);
+      b.exact = save_exact;
       break;
+   }
    case ir_binop_all_equal:
       if (type_is_float(types[0])) {
          switch (ir->operands[0]->type->vector_elements) {
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index 08b62ddfafbe..9c7c3ae61ebd 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -520,6 +520,8 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
 
    case ir_binop_equal:
    case ir_binop_nequal:
+   case ir_binop_equal_exact:
+   case ir_binop_nequal_exact:
    case ir_binop_gequal:
    case ir_binop_less:
       assert(op0->type == op1->type);
diff --git a/src/compiler/glsl/ir_builder.cpp b/src/compiler/glsl/ir_builder.cpp
index 770ba692efde..b330f8818808 100644
--- a/src/compiler/glsl/ir_builder.cpp
+++ b/src/compiler/glsl/ir_builder.cpp
@@ -349,6 +349,18 @@ nequal(operand a, operand b)
    return expr(ir_binop_nequal, a, b);
 }
 
+ir_expression*
+equal_exact(operand a, operand b)
+{
+   return expr(ir_binop_equal_exact, a, b);
+}
+
+ir_expression*
+nequal_exact(operand a, operand b)
+{
+   return expr(ir_binop_nequal_exact, a, b);
+}
+
 ir_expression*
 less(operand a, operand b)
 {
diff --git a/src/compiler/glsl/ir_builder.h b/src/compiler/glsl/ir_builder.h
index 2a1d3643e568..ad5937a79c3b 100644
--- a/src/compiler/glsl/ir_builder.h
+++ b/src/compiler/glsl/ir_builder.h
@@ -158,6 +158,8 @@ ir_expression *sign(operand a);
 ir_expression *subr_to_int(operand a);
 ir_expression *equal(operand a, operand b);
 ir_expression *nequal(operand a, operand b);
+ir_expression *equal_exact(operand a, operand b);
+ir_expression *nequal_exact(operand a, operand b);
 ir_expression *less(operand a, operand b);
 ir_expression *greater(operand a, operand b);
 ir_expression *lequal(operand a, operand b);
diff --git a/src/compiler/glsl/ir_expression_operation.py b/src/compiler/glsl/ir_expression_operation.py
index c9f9831c346d..f8ad5d92ca95 100644
--- a/src/compiler/glsl/ir_expression_operation.py
+++ b/src/compiler/glsl/ir_expression_operation.py
@@ -653,6 +653,9 @@ ir_expression_operation = [
    operation("gequal", 2, printable_name=">=", source_types=numeric_types, dest_type=bool_type, c_expression="{src0} >= {src1}"),
    operation("equal", 2, printable_name="==", source_types=all_types, dest_type=bool_type, c_expression="{src0} == {src1}"),
    operation("nequal", 2, printable_name="!=", source_types=all_types, dest_type=bool_type, c_expression="{src0} != {src1}"),
+   # Unlike the non-_exact versions, these should not be optimized in a way which assumes sources are not NaN.
+   operation("equal_exact", 2, source_types=real_types, dest_type=bool_type, c_expression="{src0} == {src1}"),
+   operation("nequal_exact", 2, source_types=real_types, dest_type=bool_type, c_expression="{src0} != {src1}"),
 
    # Returns single boolean for whether all components of operands[0]
    # equal the components of operands[1].
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index 2e120db4ea82..8c83596c6897 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -780,6 +780,8 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_binop_gequal:
    case ir_binop_equal:
    case ir_binop_nequal:
+   case ir_binop_equal_exact:
+   case ir_binop_nequal_exact:
       /* The semantics of the IR operators differ from the GLSL <, >, <=, >=,
        * ==, and != operators.  The IR operators perform a component-wise
        * comparison on scalar or vector types and return a boolean scalar or
-- 
GitLab


From cc86d82d6a3fa11cca71a06100b393cc6bc8df1e Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 15 Feb 2021 16:10:55 +0000
Subject: [PATCH 03/12] nir/search: add wrappers to replace inexact

By separating "inexact" into "imprecise" and "unsafe", we can enable
imprecise optimizations for shaders which use float controls.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_algebraic.py     | 36 ++++++++++++++++++++++++---
 src/compiler/nir/nir_opt_algebraic.py |  1 +
 src/compiler/nir/nir_search.c         | 10 +++++---
 src/compiler/nir/nir_search.h         | 10 ++++++--
 4 files changed, 47 insertions(+), 10 deletions(-)

diff --git a/src/compiler/nir/nir_algebraic.py b/src/compiler/nir/nir_algebraic.py
index 4bda78d2d2d6..e8182f561e34 100644
--- a/src/compiler/nir/nir_algebraic.py
+++ b/src/compiler/nir/nir_algebraic.py
@@ -103,6 +103,8 @@ class SearchExpression(object):
       self.opcode = expr[0]
       self.sources = expr[1:]
       self.ignore_exact = False
+      self.unsafe = False
+      self.imprecise = False
 
    @staticmethod
    def create(val):
@@ -116,6 +118,10 @@ class SearchExpression(object):
       l = [self.opcode, *self.sources]
       if self.ignore_exact:
          l.append('ignore_exact')
+      if self.unsafe:
+         l.append('unsafe')
+      if self.imprecise:
+         l.append('imprecise')
       return repr((*l,))
 
 class Value(object):
@@ -205,7 +211,8 @@ class Value(object):
       ${val.cond_index},
       ${val.swizzle()},
 % elif isinstance(val, Expression):
-      ${'true' if val.inexact else 'false'},
+      ${'true' if val.unsafe else 'false'},
+      ${'true' if val.imprecise else 'false'},
       ${'true' if val.exact else 'false'},
       ${'true' if val.ignore_exact else 'false'},
       ${val.c_opcode()},
@@ -369,13 +376,14 @@ class Expression(Value):
 
       self.opcode = m.group('opcode')
       self._bit_size = int(m.group('bits')) if m.group('bits') else None
-      self.inexact = m.group('inexact') is not None
+      self.unsafe = (m.group('inexact') is not None) or expr.unsafe
+      self.imprecise = (m.group('inexact') is not None) or expr.imprecise
       self.exact = m.group('exact') is not None
       self.ignore_exact = expr.ignore_exact
       self.cond = m.group('cond')
 
-      assert not self.inexact or not self.exact, \
-            'Expression cannot be both exact and inexact.'
+      assert not (self.unsafe or self.imprecise) or not self.exact, \
+            'Expression cannot be both exact and unsafe/imprecise.'
 
       # "many-comm-expr" isn't really a condition.  It's notification to the
       # generator that this pattern is known to have too many commutative
@@ -1288,3 +1296,23 @@ def ignore_exact(*expr):
    expr = SearchExpression.create(expr)
    expr.ignore_exact = True
    return expr
+
+# Don't match precise/invariant expressions
+def imprecise(*expr):
+   expr = SearchExpression.create(expr)
+   expr.imprecise = True
+   return expr
+
+# Don't match if NaN/Inf/-0.0 guarantees are required.
+def unsafe(*expr):
+   expr = SearchExpression.create(expr)
+   expr.unsafe = True
+   return expr
+
+# Disable the optimization for precise/invariant expressions or if NaN/Inf/-0.0
+# guarantees are required.
+def unsafe_imprecise(*expr):
+   expr = SearchExpression.create(expr)
+   expr.unsafe = True
+   expr.imprecise = True
+   return expr
diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index cd83ded3a08b..06d957655f53 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -43,6 +43,7 @@ signed_zero_inf_nan_preserve_16 = 'nir_is_float_control_signed_zero_inf_nan_pres
 signed_zero_inf_nan_preserve_32 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 32)'
 
 ignore_exact = nir_algebraic.ignore_exact
+imprecise = nir_algebraic.imprecise
 
 # Written in the form (<search>, <replace>) where <search> is an expression
 # and <replace> is either an expression or a value.  An expression is
diff --git a/src/compiler/nir/nir_search.c b/src/compiler/nir/nir_search.c
index e5b3c56c4e2c..79ae40955c23 100644
--- a/src/compiler/nir/nir_search.c
+++ b/src/compiler/nir/nir_search.c
@@ -380,7 +380,7 @@ match_expression(const nir_algebraic_table *table, const nir_search_expression *
        instr->dest.dest.ssa.bit_size != expr->value.bit_size)
       return false;
 
-   state->inexact_match = expr->inexact || state->inexact_match;
+   state->inexact_match = expr->imprecise || state->inexact_match;
    state->has_exact_alu = (instr->exact && !expr->ignore_exact) || state->has_exact_alu;
    if (state->inexact_match && state->has_exact_alu)
       return false;
@@ -586,8 +586,10 @@ UNUSED static void dump_value(const nir_algebraic_table *table, const nir_search
    case nir_search_value_expression: {
       const nir_search_expression *expr = nir_search_value_as_expression(val);
       fprintf(stderr, "(");
-      if (expr->inexact)
+      if (expr->unsafe)
          fprintf(stderr, "~");
+      if (expr->imprecise || expr->exact)
+         fprintf(stderr, "!");
       switch (expr->opcode) {
 #define CASE(n) \
       case nir_search_op_##n: fprintf(stderr, #n); break;
@@ -854,7 +856,7 @@ nir_algebraic_instr(nir_builder *build, nir_instr *instr,
    unsigned bit_size = alu->dest.dest.ssa.bit_size;
    const unsigned execution_mode =
       build->shader->info.float_controls_execution_mode;
-   const bool ignore_inexact =
+   const bool ignore_unsafe =
       nir_is_float_control_signed_zero_inf_nan_preserve(execution_mode, bit_size) ||
       nir_is_denorm_flush_to_zero(execution_mode, bit_size);
 
@@ -864,7 +866,7 @@ nir_algebraic_instr(nir_builder *build, nir_instr *instr,
         xform->condition_offset != ~0;
         xform++) {
       if (condition_flags[xform->condition_offset] &&
-          !(table->values[xform->search].expression.inexact && ignore_inexact) &&
+          !(table->values[xform->search].expression.unsafe && ignore_unsafe) &&
           nir_replace_instr(build, alu, range_ht, states, table,
                             &table->values[xform->search].expression,
                             &table->values[xform->replace].value, worklist, dead_instrs)) {
diff --git a/src/compiler/nir/nir_search.h b/src/compiler/nir/nir_search.h
index 953a245f5247..b3e5adb14a78 100644
--- a/src/compiler/nir/nir_search.h
+++ b/src/compiler/nir/nir_search.h
@@ -131,11 +131,17 @@ uint16_t nir_search_op_for_nir_op(nir_op op);
 typedef struct {
    nir_search_value value;
 
+   /* When set on a search expression, the expression will only match for
+    * shaders which do not require that denormals are flushed or -0.0/inf/NaN
+    * are preserved.
+    */
+   bool unsafe : 1;
+
    /* When set on a search expression, the expression will only match an SSA
     * value that does *not* have the exact bit set.  If unset, the exact bit
     * on the SSA value is ignored.
     */
-   bool inexact : 1;
+   bool imprecise : 1;
 
    /** In a replacement, requests that the instruction be marked exact. */
    bool exact : 1;
@@ -144,7 +150,7 @@ typedef struct {
    bool ignore_exact : 1;
 
    /* One of nir_op or nir_search_op */
-   uint16_t opcode : 13;
+   uint16_t opcode : 12;
 
    /* Commutative expression index.  This is assigned by opt_algebraic.py when
     * search structures are constructed and is a unique (to this structure)
-- 
GitLab


From 4eb46dc19a5958455fd757f679c4669693cdf90f Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 4 Sep 2020 13:30:39 +0100
Subject: [PATCH 04/12] nir: add fcanonicalize

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
---
 src/compiler/nir/nir.h                |  5 ++++
 src/compiler/nir/nir_opcodes.py       |  5 ++++
 src/compiler/nir/nir_opt_algebraic.py | 43 +++++++++++++++++++++++++--
 src/compiler/nir/nir_search_helpers.h | 14 +++++++++
 4 files changed, 65 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 238f071038cf..bbba0dbac179 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3658,6 +3658,11 @@ typedef struct nir_shader_compiler_options {
    /** Backend supports sdot_2x16 and udot_2x16 opcodes. */
    bool has_dot_2x16;
 
+   /** Backend supports fcanonicalize, if not set fcanonicalize will be lowered
+    * to fmul(a, 1.0)
+    */
+   bool has_fcanonicalize;
+
    /* Whether to generate only scoped_barrier intrinsics instead of the set of
     * memory and control barrier intrinsics based on GLSL.
     */
diff --git a/src/compiler/nir/nir_opcodes.py b/src/compiler/nir/nir_opcodes.py
index 06d6a2da25e6..07056ef4d584 100644
--- a/src/compiler/nir/nir_opcodes.py
+++ b/src/compiler/nir/nir_opcodes.py
@@ -192,6 +192,11 @@ def unop_numeric_convert(name, out_type, in_type, const_expr):
    opcode(name, 0, out_type, [0], [in_type], True, "", const_expr)
 
 unop("mov", tuint, "src0")
+# Flush subnormal values to zero with the same sign if required by
+# the float controls execution mode.  See
+# https://llvm.org/docs/LangRef.html#llvm-canonicalize-intrinsic
+# for more details.
+unop("fcanonicalize", tfloat, "src0")
 
 unop("ineg", tint, "-src0")
 unop("fneg", tfloat, "-src0")
diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 06d957655f53..5bece162828e 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -39,6 +39,14 @@ c = 'c'
 d = 'd'
 e = 'e'
 
+denorm_ftz_16 = 'nir_is_denorm_flush_to_zero(info->float_controls_execution_mode, 16)'
+denorm_ftz_32 = 'nir_is_denorm_flush_to_zero(info->float_controls_execution_mode, 32)'
+denorm_ftz_64 = 'nir_is_denorm_flush_to_zero(info->float_controls_execution_mode, 64)'
+
+denorm_preserve_16 = 'nir_is_denorm_preserve(info->float_controls_execution_mode, 16)'
+denorm_preserve_32 = 'nir_is_denorm_preserve(info->float_controls_execution_mode, 32)'
+denorm_preserve_64 = 'nir_is_denorm_preserve(info->float_controls_execution_mode, 64)'
+
 signed_zero_inf_nan_preserve_16 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 16)'
 signed_zero_inf_nan_preserve_32 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 32)'
 
@@ -94,6 +102,26 @@ def lowered_sincos(c):
 def intBitsToFloat(i):
     return struct.unpack('!f', struct.pack('!I', i))[0]
 
+optimize_fcanonicalize = [
+   # Eliminate all fcanonicalize if we are required to not flush denormals.
+   (('fcanonicalize', 'a@16'), a, denorm_preserve_16),
+   (('fcanonicalize', 'a@32'), a, denorm_preserve_32),
+   (('fcanonicalize', 'a@64'), a, denorm_preserve_64),
+
+   # Eliminate inexact fcanonicalize if we are not required to flush denormals.
+   (imprecise('fcanonicalize', 'a@16'), a, '!'+denorm_ftz_16),
+   (imprecise('fcanonicalize', 'a@32'), a, '!'+denorm_ftz_32),
+   (imprecise('fcanonicalize', 'a@64'), a, '!'+denorm_ftz_64),
+
+   # If denormals are required to be flushed or it's exact, we can still
+   # eliminate it if any denormals are already flushed or will be flushed.
+   (('fcanonicalize(is_only_used_as_float)', a), a),
+   (('fcanonicalize', 'a(is_created_as_float)'), a),
+
+   # Integral numbers are not denormal.
+   (('fcanonicalize', 'a(is_integral)'), a),
+]
+
 optimizations = [
 
    (('imul', a, '#b(is_pos_power_of_two)'), ('ishl', a, ('find_lsb', b)), '!options->lower_bitops'),
@@ -435,6 +463,8 @@ optimizations.extend([
    (('ishl', ('imul', a, '#b'), '#c'), ('imul', a, ('ishl', b, c))),
 ])
 
+optimizations.extend(optimize_fcanonicalize)
+
 # Care must be taken here.  Shifts in NIR uses only the lower log2(bitsize)
 # bits of the second source.  These replacements must correctly handle the
 # case where (b % bitsize) + (c % bitsize) >= bitsize.
@@ -2611,12 +2641,12 @@ for op in ['fpow']:
         (('bcsel', a, (op, b, c), (op + '(is_used_once)', d, c)), (op, ('bcsel', a, b, d), c)),
     ]
 
-for op in ['frcp', 'frsq', 'fsqrt', 'fexp2', 'flog2', 'fsign', 'fsin', 'fcos', 'fsin_amd', 'fcos_amd', 'fsin_mdg', 'fcos_mdg', 'fsin_agx', 'fneg', 'fabs', 'fsign']:
+for op in ['frcp', 'frsq', 'fsqrt', 'fexp2', 'flog2', 'fsign', 'fsin', 'fcos', 'fsin_amd', 'fcos_amd', 'fsin_mdg', 'fcos_mdg', 'fsin_agx', 'fneg', 'fabs', 'fsign', 'fcanonicalize']:
     optimizations += [
         (('bcsel', c, (op + '(is_used_once)', a), (op + '(is_used_once)', b)), (op, ('bcsel', c, a, b))),
     ]
 
-for op in ['ineg', 'iabs', 'inot', 'isign']:
+for op in ['ineg', 'iabs', 'inot', 'isign', 'fcanonicalize']:
     optimizations += [
         ((op, ('bcsel', c, '#a', '#b')), ('bcsel', c, (op, a), (op, b))),
     ]
@@ -2962,6 +2992,15 @@ late_optimizations.extend([
    (('extract_u8', ('extract_u8', a, b), 0), ('extract_u8', a, b)),
 ])
 
+# late_optimizations has a fneg(fneg(a)) optimization that can create fcanonicalize
+late_optimizations += optimize_fcanonicalize
+
+late_optimizations += [
+   # If we can't eliminate it, lower it so that backends don't have to deal with
+   # it.
+   (('fcanonicalize', a), ('fmul', a, 1.0), '!options->has_fcanonicalize'),
+]
+
 # A few more extract cases we'd rather leave late
 for N in [16, 32]:
     aN = 'a@{0}'.format(N)
diff --git a/src/compiler/nir/nir_search_helpers.h b/src/compiler/nir/nir_search_helpers.h
index b02885112105..4090d691cf9d 100644
--- a/src/compiler/nir/nir_search_helpers.h
+++ b/src/compiler/nir/nir_search_helpers.h
@@ -349,6 +349,20 @@ is_not_const_and_not_fsign(struct hash_table *ht, const nir_alu_instr *instr,
           !is_fsign(instr, src, num_components, swizzle);
 }
 
+static inline bool
+is_created_as_float(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
+                    UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+{
+   nir_alu_instr *src_alu =
+      nir_src_as_alu_instr(instr->src[src].src);
+
+   if (src_alu == NULL)
+      return false;
+
+   nir_alu_type output_type = nir_op_infos[src_alu->op].output_type;
+   return nir_alu_type_get_base_type(output_type) == nir_type_float;
+}
+
 static inline bool
 is_used_once(const nir_alu_instr *instr)
 {
-- 
GitLab


From c691a8c0af221626b732e77365bf014738333b7b Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 4 Sep 2020 14:44:10 +0100
Subject: [PATCH 05/12] nir: add shader_info to search variable condition
 signature

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
---
 src/compiler/nir/nir_opt_comparison_pre.c  |   4 +-
 src/compiler/nir/nir_search.c              |   6 +-
 src/compiler/nir/nir_search.h              |   2 +-
 src/compiler/nir/nir_search_helpers.h      | 139 +++++++++++----------
 src/gallium/auxiliary/gallivm/lp_bld_nir.c |   4 +-
 5 files changed, 83 insertions(+), 72 deletions(-)

diff --git a/src/compiler/nir/nir_opt_comparison_pre.c b/src/compiler/nir/nir_opt_comparison_pre.c
index d8b08ff706f1..7c3a2c581c3b 100644
--- a/src/compiler/nir/nir_opt_comparison_pre.c
+++ b/src/compiler/nir/nir_opt_comparison_pre.c
@@ -349,8 +349,8 @@ comparison_pre_block(nir_block *block, struct block_queue *bq, nir_builder *bld)
           * and neither operand is immediate value 0, add it to the set.
           */
          if (is_compatible_condition(alu) &&
-             is_not_const_zero(NULL, alu, 0, 1, swizzle) &&
-             is_not_const_zero(NULL, alu, 1, 1, swizzle))
+             is_not_const_zero(NULL, NULL, alu, 0, 1, swizzle) &&
+             is_not_const_zero(NULL, NULL, alu, 1, 1, swizzle))
             add_instruction_for_block(bi, alu);
 
          break;
diff --git a/src/compiler/nir/nir_search.c b/src/compiler/nir/nir_search.c
index 79ae40955c23..9c8a3fb26f3c 100644
--- a/src/compiler/nir/nir_search.c
+++ b/src/compiler/nir/nir_search.c
@@ -47,6 +47,7 @@ struct match_state {
 
    nir_alu_src variables[NIR_SEARCH_MAX_VARIABLES];
    struct hash_table *range_ht;
+   nir_shader *shader;
 };
 
 static bool
@@ -288,8 +289,8 @@ match_value(const nir_algebraic_table *table,
              instr->src[src].src.ssa->parent_instr->type != nir_instr_type_load_const)
             return false;
 
-         if (var->cond_index != -1 && !table->variable_cond[var->cond_index](state->range_ht, instr,
-                                                                             src, num_components, new_swizzle))
+         if (var->cond_index != -1 && !table->variable_cond[var->cond_index](state->range_ht, &state->shader->info,
+                                                                             instr, src, num_components, new_swizzle))
             return false;
 
          if (var->type != nir_type_invalid &&
@@ -679,6 +680,7 @@ nir_replace_instr(nir_builder *build, nir_alu_instr *instr,
    state.inexact_match = false;
    state.has_exact_alu = false;
    state.range_ht = range_ht;
+   state.shader = build->shader;
    state.pass_op_table = table->pass_op_table;
    state.table = table;
 
diff --git a/src/compiler/nir/nir_search.h b/src/compiler/nir/nir_search.h
index b3e5adb14a78..5b8b3157f4cf 100644
--- a/src/compiler/nir/nir_search.h
+++ b/src/compiler/nir/nir_search.h
@@ -197,7 +197,7 @@ typedef union {
 } nir_search_value_union;
 
 typedef bool (*nir_search_expression_cond)(const nir_alu_instr *instr);
-typedef bool (*nir_search_variable_cond)(struct hash_table *range_ht,
+typedef bool (*nir_search_variable_cond)(struct hash_table *range_ht, const shader_info *info,
                                          const nir_alu_instr *instr,
                                          unsigned src, unsigned num_components,
                                          const uint8_t *swizzle);
diff --git a/src/compiler/nir/nir_search_helpers.h b/src/compiler/nir/nir_search_helpers.h
index 4090d691cf9d..48bc524fcb28 100644
--- a/src/compiler/nir/nir_search_helpers.h
+++ b/src/compiler/nir/nir_search_helpers.h
@@ -33,8 +33,8 @@
 #include <math.h>
 
 static inline bool
-is_pos_power_of_two(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                    unsigned src, unsigned num_components,
+is_pos_power_of_two(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                    const nir_alu_instr *instr, unsigned src, unsigned num_components,
                     const uint8_t *swizzle)
 {
    /* only constant srcs: */
@@ -65,8 +65,8 @@ is_pos_power_of_two(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_neg_power_of_two(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                    unsigned src, unsigned num_components,
+is_neg_power_of_two(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                    const nir_alu_instr *instr, unsigned src, unsigned num_components,
                     const uint8_t *swizzle)
 {
    /* only constant srcs: */
@@ -94,8 +94,8 @@ is_neg_power_of_two(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_bitcount2(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-             unsigned src, unsigned num_components,
+is_bitcount2(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+             const nir_alu_instr *instr, unsigned src, unsigned num_components,
              const uint8_t *swizzle)
 {
    /* only constant srcs: */
@@ -114,6 +114,7 @@ is_bitcount2(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 #define MULTIPLE(test)                                                  \
 static inline bool                                                      \
 is_unsigned_multiple_of_ ## test(UNUSED struct hash_table *ht,          \
+                                 UNUSED const shader_info *info,        \
                                  const nir_alu_instr *instr,            \
                                  unsigned src, unsigned num_components, \
                                  const uint8_t *swizzle)                \
@@ -139,8 +140,8 @@ MULTIPLE(32)
 MULTIPLE(64)
 
 static inline bool
-is_zero_to_one(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-               unsigned src, unsigned num_components,
+is_zero_to_one(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+               const nir_alu_instr *instr, unsigned src, unsigned num_components,
                const uint8_t *swizzle)
 {
    /* only constant srcs: */
@@ -171,8 +172,8 @@ is_zero_to_one(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
  * 1 while this function tests 0 < src < 1.
  */
 static inline bool
-is_gt_0_and_lt_1(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                 unsigned src, unsigned num_components,
+is_gt_0_and_lt_1(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                 const nir_alu_instr *instr, unsigned src, unsigned num_components,
                  const uint8_t *swizzle)
 {
    /* only constant srcs: */
@@ -197,8 +198,8 @@ is_gt_0_and_lt_1(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_not_const_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                  unsigned src, unsigned num_components,
+is_not_const_zero(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                  const nir_alu_instr *instr, unsigned src, unsigned num_components,
                   const uint8_t *swizzle)
 {
    if (nir_src_as_const_value(instr->src[src].src) == NULL)
@@ -247,7 +248,7 @@ is_ult(const nir_alu_instr *instr, unsigned src, unsigned num_components, const
 
 /** Is value unsigned less than 32? */
 static inline bool
-is_ult_32(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
+is_ult_32(UNUSED struct hash_table *ht, UNUSED const shader_info *info, const nir_alu_instr *instr,
           unsigned src, unsigned num_components,
           const uint8_t *swizzle)
 {
@@ -256,8 +257,8 @@ is_ult_32(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 
 /** Is value unsigned less than 0xfffc07fc? */
 static inline bool
-is_ult_0xfffc07fc(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                  unsigned src, unsigned num_components,
+is_ult_0xfffc07fc(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                  const nir_alu_instr *instr, unsigned src, unsigned num_components,
                   const uint8_t *swizzle)
 {
    return is_ult(instr, src, num_components, swizzle, 0xfffc07fcU);
@@ -265,8 +266,8 @@ is_ult_0xfffc07fc(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 
 /** Is the first 5 bits of value unsigned greater than or equal 2? */
 static inline bool
-is_first_5_bits_uge_2(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                      unsigned src, unsigned num_components,
+is_first_5_bits_uge_2(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                      const nir_alu_instr *instr, unsigned src, unsigned num_components,
                       const uint8_t *swizzle)
 {
    /* only constant srcs: */
@@ -285,16 +286,17 @@ is_first_5_bits_uge_2(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_not_const(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-             unsigned src, UNUSED unsigned num_components,
+is_not_const(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+             const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
              UNUSED const uint8_t *swizzle)
 {
    return !nir_src_is_const(instr->src[src].src);
 }
 
 static inline bool
-is_not_fmul(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
-            UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+is_not_fmul(struct hash_table *ht, UNUSED const shader_info *info,
+            const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
+            UNUSED const uint8_t *swizzle)
 {
    nir_alu_instr *src_alu =
       nir_src_as_alu_instr(instr->src[src].src);
@@ -303,14 +305,15 @@ is_not_fmul(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
       return true;
 
    if (src_alu->op == nir_op_fneg)
-      return is_not_fmul(ht, src_alu, 0, 0, NULL);
+      return is_not_fmul(ht, info, src_alu, 0, 0, NULL);
 
    return src_alu->op != nir_op_fmul && src_alu->op != nir_op_fmulz;
 }
 
 static inline bool
-is_fmul(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
-        UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+is_fmul(struct hash_table *ht, UNUSED const shader_info *info,
+        const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
+        UNUSED const uint8_t *swizzle)
 {
    nir_alu_instr *src_alu =
       nir_src_as_alu_instr(instr->src[src].src);
@@ -319,7 +322,7 @@ is_fmul(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
       return false;
 
    if (src_alu->op == nir_op_fneg)
-      return is_fmul(ht, src_alu, 0, 0, NULL);
+      return is_fmul(ht, info, src_alu, 0, 0, NULL);
 
    return src_alu->op == nir_op_fmul || src_alu->op == nir_op_fmulz;
 }
@@ -341,16 +344,17 @@ is_fsign(const nir_alu_instr *instr, unsigned src,
 }
 
 static inline bool
-is_not_const_and_not_fsign(struct hash_table *ht, const nir_alu_instr *instr,
-                           unsigned src, unsigned num_components,
-                           const uint8_t *swizzle)
+is_not_const_and_not_fsign(struct hash_table *ht, UNUSED const shader_info *info,
+                           const nir_alu_instr *instr, unsigned src,
+                           unsigned num_components, const uint8_t *swizzle)
 {
-   return is_not_const(ht, instr, src, num_components, swizzle) &&
+   return is_not_const(ht, info, instr, src, num_components, swizzle) &&
           !is_fsign(instr, src, num_components, swizzle);
 }
 
 static inline bool
-is_created_as_float(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
+is_created_as_float(struct hash_table *ht, UNUSED const shader_info *info,
+                    const nir_alu_instr *instr, unsigned src,
                     UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
 {
    nir_alu_instr *src_alu =
@@ -476,8 +480,8 @@ only_lower_16_bits_used(const nir_alu_instr *instr)
  * of all its components is zero.
  */
 static inline bool
-is_upper_half_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                   unsigned src, unsigned num_components,
+is_upper_half_zero(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                   const nir_alu_instr *instr, unsigned src, unsigned num_components,
                    const uint8_t *swizzle)
 {
    if (nir_src_as_const_value(instr->src[src].src) == NULL)
@@ -501,8 +505,8 @@ is_upper_half_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
  * of all its components is zero.
  */
 static inline bool
-is_lower_half_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                   unsigned src, unsigned num_components,
+is_lower_half_zero(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                   const nir_alu_instr *instr, unsigned src, unsigned num_components,
                    const uint8_t *swizzle)
 {
    if (nir_src_as_const_value(instr->src[src].src) == NULL)
@@ -518,8 +522,8 @@ is_lower_half_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_upper_half_negative_one(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                           unsigned src, unsigned num_components,
+is_upper_half_negative_one(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                           const nir_alu_instr *instr, unsigned src, unsigned num_components,
                            const uint8_t *swizzle)
 {
    if (nir_src_as_const_value(instr->src[src].src) == NULL)
@@ -538,8 +542,8 @@ is_upper_half_negative_one(UNUSED struct hash_table *ht, const nir_alu_instr *in
 }
 
 static inline bool
-is_lower_half_negative_one(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                           unsigned src, unsigned num_components,
+is_lower_half_negative_one(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                           const nir_alu_instr *instr, unsigned src, unsigned num_components,
                            const uint8_t *swizzle)
 {
    if (nir_src_as_const_value(instr->src[src].src) == NULL)
@@ -567,8 +571,9 @@ no_unsigned_wrap(const nir_alu_instr *instr)
 }
 
 static inline bool
-is_integral(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
-            UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+is_integral(struct hash_table *ht, UNUSED const shader_info *info,
+            const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
+            UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range r = nir_analyze_range(ht, instr, src);
 
@@ -579,9 +584,9 @@ is_integral(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
  * Is the value finite?
  */
 static inline bool
-is_finite(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-          unsigned src, UNUSED unsigned num_components,
-          UNUSED const uint8_t *swizzle)
+is_finite(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+          const nir_alu_instr *instr, unsigned src, unsigned num_components,
+          const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
 
@@ -589,8 +594,8 @@ is_finite(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_finite_not_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
-                   unsigned src, UNUSED unsigned num_components,
+is_finite_not_zero(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
+                   const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
                    UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
@@ -602,17 +607,18 @@ is_finite_not_zero(UNUSED struct hash_table *ht, const nir_alu_instr *instr,
 
 #define RELATION(r)                                                     \
 static inline bool                                                      \
-is_ ## r (struct hash_table *ht, const nir_alu_instr *instr,            \
-          unsigned src, UNUSED unsigned num_components,                 \
-          UNUSED const uint8_t *swizzle)                                \
+is_ ## r (struct hash_table *ht, UNUSED const shader_info *info,        \
+          const nir_alu_instr *instr, unsigned src,                     \
+          UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)\
 {                                                                       \
-   const struct ssa_result_range v = nir_analyze_range(ht, instr, src);  \
+   const struct ssa_result_range v = nir_analyze_range(ht, instr, src); \
    return v.range == r;                                                 \
 }                                                                       \
                                                                         \
 static inline bool                                                      \
-is_a_number_ ## r (struct hash_table *ht, const nir_alu_instr *instr,   \
-                   unsigned src, UNUSED unsigned num_components,        \
+is_a_number_ ## r (struct hash_table *ht, UNUSED const shader_info *info, \
+                   const nir_alu_instr *instr, unsigned src,            \
+                   UNUSED unsigned num_components,                      \
                    UNUSED const uint8_t *swizzle)                       \
 {                                                                       \
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src); \
@@ -626,7 +632,8 @@ RELATION(ge_zero)
 RELATION(ne_zero)
 
 static inline bool
-is_not_negative(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
+is_not_negative(struct hash_table *ht, UNUSED const shader_info *info,
+                const nir_alu_instr *instr, unsigned src,
                 UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
@@ -634,8 +641,8 @@ is_not_negative(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
 }
 
 static inline bool
-is_a_number_not_negative(struct hash_table *ht, const nir_alu_instr *instr,
-                         unsigned src, UNUSED unsigned num_components,
+is_a_number_not_negative(struct hash_table *ht, UNUSED const shader_info *info,
+                         const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
                          UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
@@ -645,17 +652,18 @@ is_a_number_not_negative(struct hash_table *ht, const nir_alu_instr *instr,
 
 
 static inline bool
-is_not_positive(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
-                UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+is_not_positive(struct hash_table *ht, UNUSED const shader_info *info,
+                const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
+                UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
    return v.range == le_zero || v.range == lt_zero || v.range == eq_zero;
 }
 
 static inline bool
-is_a_number_not_positive(struct hash_table *ht, const nir_alu_instr *instr,
-                         unsigned src, UNUSED unsigned num_components,
-                         UNUSED const uint8_t *swizzle)
+is_a_number_not_positive(struct hash_table *ht, UNUSED const shader_info *info,
+                         const nir_alu_instr *instr, unsigned src,
+                         UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
    return v.is_a_number &&
@@ -663,16 +671,17 @@ is_a_number_not_positive(struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_not_zero(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
-            UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+is_not_zero(struct hash_table *ht, UNUSED const shader_info *info,
+            const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
+            UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
    return v.range == lt_zero || v.range == gt_zero || v.range == ne_zero;
 }
 
 static inline bool
-is_a_number_not_zero(struct hash_table *ht, const nir_alu_instr *instr,
-                     unsigned src, UNUSED unsigned num_components,
+is_a_number_not_zero(struct hash_table *ht, UNUSED const shader_info *info,
+                     const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
                      UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
@@ -681,8 +690,8 @@ is_a_number_not_zero(struct hash_table *ht, const nir_alu_instr *instr,
 }
 
 static inline bool
-is_a_number(struct hash_table *ht, const nir_alu_instr *instr, unsigned src,
-            UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+is_a_number(struct hash_table *ht, UNUSED const shader_info *info, const nir_alu_instr *instr,
+            unsigned src, UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
 {
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
    return v.is_a_number;
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_nir.c b/src/gallium/auxiliary/gallivm/lp_bld_nir.c
index 3a127c25abde..110789a9dbf5 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_nir.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_nir.c
@@ -846,11 +846,11 @@ do_alu_action(struct lp_build_nir_context *bld_base,
       /* If one of the sources is known to be a number (i.e., not NaN), then
        * better code can be generated by passing that information along.
        */
-      if (is_a_number(bld_base->range_ht, instr, 1,
+      if (is_a_number(bld_base->range_ht, &bld_base->shader->info, instr, 1,
                       0 /* unused num_components */,
                       NULL /* unused swizzle */)) {
          minmax_nan = GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN;
-      } else if (is_a_number(bld_base->range_ht, instr, 0,
+      } else if (is_a_number(bld_base->range_ht, &bld_base->shader->info, instr, 0,
                              0 /* unused num_components */,
                              NULL /* unused swizzle */)) {
          first = 1;
-- 
GitLab


From 3b64393601e9372a21c0dcd25f6dd5e2960a8cf1 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 4 Sep 2020 14:34:59 +0100
Subject: [PATCH 06/12] nir: use float controls in is_finite, is_a_number and
 add helpers for -0.0

fossil-db (GFX10.3):
Totals from 6914 (4.73% of 146267) affected shaders:
VGPRs: 534816 -> 534800 (-0.00%)
CodeSize: 67746152 -> 67760484 (+0.02%); split: -0.00%, +0.02%
Instrs: 12914451 -> 12914101 (-0.00%); split: -0.00%, +0.00%

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_search_helpers.h | 102 +++++++++++++++++++-------
 1 file changed, 76 insertions(+), 26 deletions(-)

diff --git a/src/compiler/nir/nir_search_helpers.h b/src/compiler/nir/nir_search_helpers.h
index 48bc524fcb28..11d8564c07f5 100644
--- a/src/compiler/nir/nir_search_helpers.h
+++ b/src/compiler/nir/nir_search_helpers.h
@@ -580,31 +580,6 @@ is_integral(struct hash_table *ht, UNUSED const shader_info *info,
    return r.is_integral;
 }
 
-/**
- * Is the value finite?
- */
-static inline bool
-is_finite(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
-          const nir_alu_instr *instr, unsigned src, unsigned num_components,
-          const uint8_t *swizzle)
-{
-   const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
-
-   return v.is_finite;
-}
-
-static inline bool
-is_finite_not_zero(UNUSED struct hash_table *ht, UNUSED const shader_info *info,
-                   const nir_alu_instr *instr, unsigned src, UNUSED unsigned num_components,
-                   UNUSED const uint8_t *swizzle)
-{
-   const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
-
-   return v.is_finite &&
-          (v.range == lt_zero || v.range == gt_zero || v.range == ne_zero);
-}
-
-
 #define RELATION(r)                                                     \
 static inline bool                                                      \
 is_ ## r (struct hash_table *ht, UNUSED const shader_info *info,        \
@@ -690,11 +665,86 @@ is_a_number_not_zero(struct hash_table *ht, UNUSED const shader_info *info,
 }
 
 static inline bool
-is_a_number(struct hash_table *ht, UNUSED const shader_info *info, const nir_alu_instr *instr,
+is_signed_zero_preserve_for_instr(const shader_info *info, const nir_alu_instr *instr, unsigned src)
+{
+   if (instr->exact) {
+      /* These instructions produce a non-NaN result for a NaN input.
+       * Additional care must be taken in these cases.
+       */
+      if (instr->op == nir_op_fmin || instr->op == nir_op_fmax ||
+          instr->op == nir_op_fsat || instr->op == nir_op_fsign ||
+          nir_alu_instr_is_comparison(instr))
+         return true;
+   }
+
+   nir_ssa_def *def = instr->src[src].src.ssa;
+   uint16_t controls = info->float_controls_execution_mode;
+   return nir_is_float_control_signed_zero_inf_nan_preserve(controls, def->bit_size);
+}
+
+static inline bool
+is_signed_zero_inf_nan_preserve_for_instr(const shader_info *info, const nir_alu_instr *instr,
+                                          unsigned src)
+{
+   /* These always have defined behaviour with NaN inputs. */
+   if (instr->op == nir_op_fmulz || instr->op == nir_op_ffmaz)
+      return true;
+
+   return is_signed_zero_preserve_for_instr(info, instr, src);
+}
+
+/**
+ * Is the value finite and not NaN?
+ */
+static inline bool
+is_finite(struct hash_table *ht, const shader_info *info, const nir_alu_instr *instr,
+          unsigned src, UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+{
+   if (!is_signed_zero_inf_nan_preserve_for_instr(info, instr, src))
+      return true;
+
+   const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
+   return v.is_finite;
+}
+
+static inline bool
+is_finite_not_zero(struct hash_table *ht, const shader_info *info, const nir_alu_instr *instr,
+          unsigned src, UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
+{
+   const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
+   return (v.is_finite || !is_signed_zero_inf_nan_preserve_for_instr(info, instr, src)) &&
+          (v.range == lt_zero || v.range == gt_zero || v.range == ne_zero);
+}
+
+static inline bool
+is_a_number(struct hash_table *ht, const shader_info *info, const nir_alu_instr *instr,
             unsigned src, UNUSED unsigned num_components, UNUSED const uint8_t *swizzle)
 {
+   if (!is_signed_zero_inf_nan_preserve_for_instr(info, instr, src))
+      return true;
+
    const struct ssa_result_range v = nir_analyze_range(ht, instr, src);
    return v.is_a_number;
 }
 
+static inline bool
+can_elim_negative_zero(struct hash_table *ht, const shader_info *info,
+                       const nir_alu_instr *instr, unsigned src,
+                       unsigned num_components, const uint8_t *swizzle)
+{
+   if (!is_signed_zero_preserve_for_instr(info, instr, src))
+      return true;
+
+   if (!nir_src_is_const(instr->src[src].src))
+      return is_not_zero(ht, info, instr, src, num_components, swizzle);
+
+   for (unsigned i = 0; i < num_components; i++) {
+      double val = nir_src_comp_as_float(instr->src[src].src, swizzle[i]);
+      if (val == 0.0 && signbit(val))
+         return false;
+   }
+
+   return true;
+}
+
 #endif /* _NIR_SEARCH_ */
-- 
GitLab


From 222fa6e9284f2c04c0264c2ba189a3787e8fd81a Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 4 Feb 2021 16:59:07 +0000
Subject: [PATCH 07/12] nir/algebraic: mark several optimizations as imprecise
 instead of inexact

This enables the optimizations even if float controls are used.

There are probably more.

fossil-db (GFX10.3, dxvk float controls):
Totals from 72756 (49.74% of 146267) affected shaders:
VGPRs: 3249200 -> 3261712 (+0.39%); split: -0.09%, +0.48%
SpillSGPRs: 12269 -> 12267 (-0.02%); split: -0.06%, +0.04%
CodeSize: 260352544 -> 259045808 (-0.50%); split: -0.56%, +0.06%
MaxWaves: 1730252 -> 1726434 (-0.22%); split: +0.04%, -0.26%
Instrs: 49455234 -> 49061239 (-0.80%); split: -0.84%, +0.05%

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
---
 src/compiler/nir/nir_opt_algebraic.py | 33 +++++++++++++++------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 5bece162828e..536ce3676300 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -177,6 +177,9 @@ optimizations = [
    (('usub_sat', a, 0), a),
    (('usadd_4x8_vc4', a, 0), a),
    (('usadd_4x8_vc4', a, ~0), ~0),
+   # This does not preserve the sign of zero. For example:
+   # "-1.0*0.0 + 0.0*0.0" -> "0.0 * (-1.0+0.0)"
+   # "-1.0*-1.0 + -1.0*1.0" -> "-1.0 * (-1.0 + 1.0)"
    (('~fadd', ('fmul', a, b), ('fmul', a, c)), ('fmul', a, ('fadd', b, c))),
    (('~fadd', ('fmulz', a, b), ('fmulz', a, c)), ('fmulz', a, ('fadd', b, c))),
    (('~ffma', a, b, ('ffma(is_used_once)', a, c, d)), ('ffma', a, ('fadd', b, c), d)),
@@ -1394,12 +1397,12 @@ optimizations.extend([
    (('~fexp2', ('fmul', ('flog2', a), 0.5)), ('fsqrt', a)),
    (('~fexp2', ('fmul', ('flog2', a), 2.0)), ('fmul', a, a)),
    (('~fexp2', ('fmul', ('flog2', a), 4.0)), ('fmul', ('fmul', a, a), ('fmul', a, a))),
-   (('~fpow', a, 1.0), a),
-   (('~fpow', a, 2.0), ('fmul', a, a)),
-   (('~fpow', a, 4.0), ('fmul', ('fmul', a, a), ('fmul', a, a))),
-   (('~fpow', 2.0, a), ('fexp2', a)),
-   (('~fpow', ('fpow', a, 2.2), 0.454545), a),
-   (('~fpow', ('fabs', ('fpow', a, 2.2)), 0.454545), ('fabs', a)),
+   (imprecise('fpow', a, 1.0), ('fcanonicalize', a)),
+   (imprecise('fpow', a, 2.0), ('fmul', a, a)),
+   (imprecise('fpow', a, 4.0), ('fmul', ('fmul', a, a), ('fmul', a, a))),
+   (imprecise('fpow', 2.0, a), ('fexp2', a)),
+   (imprecise('fpow', ('fpow', a, 2.2), 0.454545), ('fcanonicalize', a)),
+   (imprecise('fpow', ('fabs', ('fpow', a, 2.2)), 0.454545), ('fabs', a)),
    (('~fsqrt', ('fexp2', a)), ('fexp2', ('fmul', 0.5, a))),
    (('~frcp', ('fexp2', a)), ('fexp2', ('fneg', a))),
    (('~frsq', ('fexp2', a)), ('fexp2', ('fmul', -0.5, a))),
@@ -1412,12 +1415,12 @@ optimizations.extend([
    (('~fmul', ('fsqrt', a), ('fsqrt', a)), ('fabs',a)),
    (('~fmulz', ('fsqrt', a), ('fsqrt', a)), ('fabs', a)),
    # Division and reciprocal
-   (('~fdiv', 1.0, a), ('frcp', a)),
+   (imprecise('fdiv', 1.0, a), ('frcp', a)),
    (('fdiv', a, b), ('fmul', a, ('frcp', b)), 'options->lower_fdiv'),
    (('~frcp', ('frcp', a)), a),
-   (('~frcp', ('fsqrt', a)), ('frsq', a)),
+   (imprecise('frcp', ('fsqrt', a)), ('frsq', a)),
    (('fsqrt', a), ('frcp', ('frsq', a)), 'options->lower_fsqrt'),
-   (('~frcp', ('frsq', a)), ('fsqrt', a), '!options->lower_fsqrt'),
+   (imprecise('frcp', ('frsq', a)), ('fsqrt', a), '!options->lower_fsqrt'),
    # Trig
    (('fsin', a), lowered_sincos(0.5), 'options->lower_sincos'),
    (('fcos', a), lowered_sincos(0.75), 'options->lower_sincos'),
@@ -1746,7 +1749,7 @@ optimizations.extend([
    (('imul', ('ineg', a), b), ('ineg', ('imul', a, b))),
 
    # Propagate constants up multiplication chains
-   (('~fmul(is_used_once)', ('fmul(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c'), ('fmul', ('fmul', a, c), b)),
+   (imprecise('fmul(is_used_once)', ('fmul(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c'), ('fmul', ('fmul', a, c), b)),
    (('~fmulz(is_used_once)', ('fmulz(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c'), ('fmulz', ('fmulz', a, c), b)),
    (('~fmul(is_used_once)', ('fmulz(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c(is_finite_not_zero)'), ('fmulz', ('fmul', a, c), b)),
    (('imul(is_used_once)', ('imul(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c'), ('imul', ('imul', a, c), b)),
@@ -1754,8 +1757,8 @@ optimizations.extend([
    (('~ffmaz', ('fmulz(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c', d), ('ffmaz', ('fmulz', a, c), b, d)),
    (('~ffma', ('fmulz(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c(is_finite_not_zero)', d), ('ffmaz', ('fmul', a, c), b, d)),
    # Prefer moving out a multiplication for more MAD/FMA-friendly code
-   (('~fadd(is_used_once)', ('fadd(is_used_once)', 'a(is_not_const)', 'b(is_fmul)'), '#c'), ('fadd', ('fadd', a, c), b)),
-   (('~fadd(is_used_once)', ('fadd(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c'), ('fadd', ('fadd', a, c), b)),
+   (imprecise('fadd(is_used_once)', ('fadd(is_used_once)', 'a(is_not_const)', 'b(is_fmul)'), '#c(is_finite)'), ('fadd', ('fadd', a, c), b)),
+   (imprecise('fadd(is_used_once)', ('fadd(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c(is_finite)'), ('fadd', ('fadd', a, c), b)),
    (('~fadd(is_used_once)', ('ffma(is_used_once)', 'a(is_not_const)', b, 'c(is_not_const)'), '#d'), ('fadd', ('ffma', a, b, d), c)),
    (('~fadd(is_used_once)', ('ffmaz(is_used_once)', 'a(is_not_const)', b, 'c(is_not_const)'), '#d'), ('fadd', ('ffmaz', a, b, d), c)),
    (('iadd(is_used_once)', ('iadd(is_used_once)', 'a(is_not_const)', 'b(is_not_const)'), '#c'), ('iadd', ('iadd', a, c), b)),
@@ -1763,15 +1766,15 @@ optimizations.extend([
    # Reassociate constants in add/mul chains so they can be folded together.
    # For now, we mostly only handle cases where the constants are separated by
    # a single non-constant.  We could do better eventually.
-   (('~fmul', '#a', ('fmul', 'b(is_not_const)', '#c')), ('fmul', ('fmul', a, c), b)),
+   (imprecise('fmul', '#a', ('fmul', 'b(is_not_const)', '#c')), ('fmul', ('fmul', a, c), b)),
    (('~fmulz', '#a', ('fmulz', 'b(is_not_const)', '#c')), ('fmulz', ('fmulz', a, c), b)),
    (('~fmul', '#a(is_finite_not_zero)', ('fmulz', 'b(is_not_const)', '#c')), ('fmulz', ('fmul', a, c), b)),
    (('~ffma', '#a', ('fmul', 'b(is_not_const)', '#c'), d), ('ffma', ('fmul', a, c), b, d)),
    (('~ffmaz', '#a', ('fmulz', 'b(is_not_const)', '#c'), d), ('ffmaz', ('fmulz', a, c), b, d)),
    (('~ffmaz', '#a(is_finite_not_zero)', ('fmulz', 'b(is_not_const)', '#c'), d), ('ffmaz', ('fmul', a, c), b, d)),
    (('imul', '#a', ('imul', 'b(is_not_const)', '#c')), ('imul', ('imul', a, c), b)),
-   (('~fadd', '#a',          ('fadd', 'b(is_not_const)', '#c')),  ('fadd', ('fadd', a,          c),           b)),
-   (('~fadd', '#a', ('fneg', ('fadd', 'b(is_not_const)', '#c'))), ('fadd', ('fadd', a, ('fneg', c)), ('fneg', b))),
+   (imprecise('fadd', '#a',          ('fadd', 'b(is_not_const)', '#c')),  ('fadd', ('fadd', a,          c),           b)),
+   (imprecise('fadd', '#a', ('fneg', ('fadd', 'b(is_not_const)', '#c'))), ('fadd', ('fadd', a, ('fneg', c)), ('fneg', b))),
    (('~fadd', '#a',          ('ffma', 'b(is_not_const)', 'c(is_not_const)', '#d')),  ('ffma',          b,  c, ('fadd', a,          d))),
    (('~fadd', '#a', ('fneg', ('ffma', 'b(is_not_const)', 'c(is_not_const)', '#d'))), ('ffma', ('fneg', b), c, ('fadd', a, ('fneg', d)))),
    (('~fadd', '#a',          ('ffmaz', 'b(is_not_const)', 'c(is_not_const)', '#d')),  ('ffmaz',          b,  c, ('fadd', a,          d))),
-- 
GitLab


From 6dd58ad756f70dcb9a7d249a409f63874b803192 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 24 Feb 2021 10:31:06 +0000
Subject: [PATCH 08/12] nir/algebraic: make several safe using fcanonicalize
 and search helpers

fossil-db (GFX10.3):
Totals from 1830 (1.25% of 146267) affected shaders:
VGPRs: 124504 -> 124528 (+0.02%); split: -0.03%, +0.04%
CodeSize: 14211268 -> 14205716 (-0.04%); split: -0.06%, +0.02%
MaxWaves: 31346 -> 31316 (-0.10%); split: +0.03%, -0.13%
Instrs: 2661768 -> 2660899 (-0.03%); split: -0.06%, +0.02%

fossil-db (GFX10.3, dxvk float controls):
Totals from 20972 (14.34% of 146267) affected shaders:
VGPRs: 1321496 -> 1318680 (-0.21%); split: -0.34%, +0.12%
CodeSize: 132952848 -> 131962576 (-0.74%); split: -0.75%, +0.00%
MaxWaves: 375254 -> 377140 (+0.50%); split: +0.54%, -0.04%
Instrs: 25243319 -> 25018928 (-0.89%); split: -0.90%, +0.01%

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_opt_algebraic.py | 45 ++++++++++-----------------
 1 file changed, 17 insertions(+), 28 deletions(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 536ce3676300..b3133a02fc53 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -158,18 +158,13 @@ optimizations = [
     '!options->lower_bitops'),
    (('irem', a, '#b(is_neg_power_of_two)'), ('irem', a, ('iabs', b)), '!options->lower_bitops'),
 
-   (('~fneg', ('fneg', a)), a),
+   (('fneg', ('fneg', a)), ('fcanonicalize', a)),
    (('ineg', ('ineg', a)), a),
    (('fabs', ('fneg', a)), ('fabs', a)),
    (('fabs', ('u2f', a)), ('u2f', a)),
    (('iabs', ('iabs', a)), ('iabs', a)),
    (('iabs', ('ineg', a)), ('iabs', a)),
-   (('~fadd', a, 0.0), a),
-   # a+0.0 is 'a' unless 'a' is denormal or -0.0. If it's only used by a
-   # floating point instruction, they should flush any input denormals and we
-   # can replace -0.0 with 0.0 if the float execution mode allows it.
-   (('fadd(is_only_used_as_float)', 'a@16', 0.0), a, '!'+signed_zero_inf_nan_preserve_16),
-   (('fadd(is_only_used_as_float)', 'a@32', 0.0), a, '!'+signed_zero_inf_nan_preserve_32),
+   (('fadd', 'a(can_elim_negative_zero)', 0.0), ('fcanonicalize', a)),
    (('iadd', a, 0), a),
    (('iadd_sat', a, 0), a),
    (('isub_sat', a, 0), a),
@@ -219,12 +214,8 @@ optimizations = [
    (('imul', a, 0), 0),
    (('umul_unorm_4x8_vc4', a, 0), 0),
    (('umul_unorm_4x8_vc4', a, ~0), a),
-   (('~fmul', a, 1.0), a),
-   (('~fmulz', a, 1.0), a),
-   # The only effect a*1.0 can have is flushing denormals. If it's only used by
-   # a floating point instruction, they should flush any input denormals and
-   # this multiplication isn't needed.
-   (('fmul(is_only_used_as_float)', a, 1.0), a),
+   (('fmul', a, 1.0), ('fcanonicalize', a)),
+   (('fmulz', 'a(can_elim_negative_zero)', 1.0), ('fcanonicalize', a)),
    (('imul', a, 1), a),
    (('fmul', a, -1.0), ('fneg', a)),
    (('imul', a, -1), ('ineg', a)),
@@ -248,8 +239,8 @@ optimizations = [
    (('ffmaz', -1.0, a, b), ('fadd', ('fneg', a), b), '!'+signed_zero_inf_nan_preserve_32),
    (('~ffma', '#a', '#b', c), ('fadd', ('fmul', a, b), c)),
    (('~ffmaz', '#a', '#b', c), ('fadd', ('fmulz', a, b), c)),
-   (('~flrp', a, b, 0.0), a),
-   (('~flrp', a, b, 1.0), b),
+   (('flrp', a, 'b(is_finite)', 0.0), ('fcanonicalize', a)),
+   (('flrp', 'a(is_finite)', b, 1.0), ('fcanonicalize', b)),
    (('~flrp', a, a, b), a),
    (('~flrp', 0.0, a, b), ('fmul', a, b)),
 
@@ -765,8 +756,8 @@ optimizations.extend([
    (('bcsel', a, a, b), ('ior', a, b)),
    (('bcsel', a, b, False), ('iand', a, b)),
    (('bcsel', a, b, a), ('iand', a, b)),
-   (('~fmin', a, a), a),
-   (('~fmax', a, a), a),
+   (('fmin', a, a), ('fcanonicalize', a)),
+   (('fmax', a, a), ('fcanonicalize', a)),
    (('imin', a, a), a),
    (('imax', a, a), a),
    (('umin', a, a), a),
@@ -828,9 +819,9 @@ optimizations.extend([
    (('imin', a, ('ineg', a)), ('ineg', ('iabs', a))),
    (('fmin', a, ('fneg', ('fabs', a))), ('fneg', ('fabs', a))),
    (('imin', a, ('ineg', ('iabs', a))), ('ineg', ('iabs', a))),
-   (('~fmin', a, ('fabs', a)), a),
+   (('fmin', a, ('fabs', a)), ('fcanonicalize', a)),
    (('imin', a, ('iabs', a)), a),
-   (('~fmax', a, ('fneg', ('fabs', a))), a),
+   (('fmax', a, ('fneg', ('fabs', a))), ('fcanonicalize', a)),
    (('imax', a, ('ineg', ('iabs', a))), a),
    (('fmax', a, ('fabs', a)), ('fabs', a)),
    (('imax', a, ('iabs', a)), ('iabs', a)),
@@ -1417,7 +1408,7 @@ optimizations.extend([
    # Division and reciprocal
    (imprecise('fdiv', 1.0, a), ('frcp', a)),
    (('fdiv', a, b), ('fmul', a, ('frcp', b)), 'options->lower_fdiv'),
-   (('~frcp', ('frcp', a)), a),
+   (imprecise('frcp', ('frcp', a)), ('fcanonicalize', a)),
    (imprecise('frcp', ('fsqrt', a)), ('frsq', a)),
    (('fsqrt', a), ('frcp', ('frsq', a)), 'options->lower_fsqrt'),
    (imprecise('frcp', ('frsq', a)), ('fsqrt', a), '!options->lower_fsqrt'),
@@ -1448,7 +1439,7 @@ optimizations.extend([
    (('bcsel@64', a, -0.0, -1.0), ('fneg', ('b2f', ('inot', a))), '!(options->lower_doubles_options & nir_lower_fp64_full_software)'),
 
    (('bcsel', a, b, b), b),
-   (('~fcsel', a, b, b), b),
+   (('fcsel', a, b, b), ('fcanonicalize', b)),
 
    # D3D Boolean emulation
    (('bcsel', a, -1, 0), ('ineg', ('b2i', 'a@1'))),
@@ -1487,7 +1478,7 @@ optimizations.extend([
    (('f2u', ('ftrunc', a)), ('f2u', a)),
 
    # Conversions from 16 bits to 32 bits and back can always be removed
-   (('f2fmp', ('f2f32', 'a@16')), a),
+   (('f2fmp', ('f2f32', 'a@16')), ('fcanonicalize', a)),
    (('i2imp', ('i2i32', 'a@16')), a),
    (('i2imp', ('u2u32', 'a@16')), a),
 
@@ -1507,7 +1498,7 @@ optimizations.extend([
 
    # Conversions to 16 bits would be lossy so they should only be removed if
    # the instruction was generated by the precision lowering pass.
-   (('f2f32', ('f2fmp', 'a@32')), a),
+   (('f2f32', ('f2fmp', 'a@32')), ('fcanonicalize', a)),
    (('i2i32', ('i2imp', 'a@32')), a),
    (('u2u32', ('i2imp', 'a@32')), a),
 
@@ -1516,9 +1507,7 @@ optimizations.extend([
    (('f2f32', ('i2fmp', 'a@32')), ('i2f32', a)),
    (('f2f32', ('u2fmp', 'a@32')), ('u2f32', a)),
 
-   # Conversions from float32 to float64 and back can be removed as long as
-   # it doesn't need to be precise, since the conversion may e.g. flush denorms
-   (('~f2f32', ('f2f64', 'a@32')), a),
+   (('f2f32', ('f2f64', 'a@32')), ('fcanonicalize', a)),
 
    (('ffloor', 'a(is_integral)'), a),
    (('fceil', 'a(is_integral)'), a),
@@ -1527,7 +1516,7 @@ optimizations.extend([
 
    # fract(x) = x - floor(x), so fract(NaN) = NaN
    (('~ffract', 'a(is_integral)'), 0.0),
-   (('fabs', 'a(is_not_negative)'), a),
+   (('fabs', 'a(is_not_negative)'), ('fcanonicalize', a)),
    (('iabs', 'a(is_not_negative)'), a),
    (('fsat', 'a(is_not_positive)'), 0.0),
 
@@ -2784,7 +2773,7 @@ late_optimizations = [
 
    # nir_lower_to_source_mods will collapse this, but its existence during the
    # optimization loop can prevent other optimizations.
-   (('fneg', ('fneg', a)), a)
+   (('fneg', ('fneg', a)), ('fcanonicalize', a)),
 ]
 
 # re-combine inexact mul+add to ffma. Do this before fsub so that a * b - c
-- 
GitLab


From 06de0305b647df337a444d314ed99abaf3108db8 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 24 Feb 2021 12:53:46 +0000
Subject: [PATCH 09/12] nir: look through bcsel in is_only_used_as_float and
 is_created_as_float

fossil-db (GFX10.3):
Totals from 1 (0.00% of 146267) affected shaders:
CodeSize: 1740 -> 1736 (-0.23%)
Instrs: 313 -> 312 (-0.32%)

fossil-db (GFX10.3, dxvk float controls):
Totals from 143 (0.10% of 146267) affected shaders:
CodeSize: 1492300 -> 1491152 (-0.08%)
Instrs: 300391 -> 300101 (-0.10%)

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
---
 src/compiler/nir/nir.h                | 14 ++++++++++++++
 src/compiler/nir/nir_search_helpers.h | 17 ++++++++++++++---
 2 files changed, 28 insertions(+), 3 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index bbba0dbac179..59d58738a9c8 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -1282,6 +1282,20 @@ nir_op_vec(unsigned components);
 bool
 nir_op_is_vec(nir_op op);
 
+static inline bool
+nir_op_is_bcsel(nir_op op)
+{
+   switch (op) {
+   case nir_op_bcsel:
+   case nir_op_b8csel:
+   case nir_op_b16csel:
+   case nir_op_b32csel:
+      return true;
+   default:
+      return false;
+   }
+}
+
 static inline bool
 nir_is_float_control_signed_zero_inf_nan_preserve(unsigned execution_mode, unsigned bit_size)
 {
diff --git a/src/compiler/nir/nir_search_helpers.h b/src/compiler/nir/nir_search_helpers.h
index 11d8564c07f5..dbc3f6f1c46f 100644
--- a/src/compiler/nir/nir_search_helpers.h
+++ b/src/compiler/nir/nir_search_helpers.h
@@ -363,6 +363,11 @@ is_created_as_float(struct hash_table *ht, UNUSED const shader_info *info,
    if (src_alu == NULL)
       return false;
 
+   if (nir_op_is_bcsel(src_alu->op)) {
+      return is_created_as_float(ht, info, src_alu, 1, 0, NULL) &&
+             is_created_as_float(ht, info, src_alu, 2, 0, NULL);
+   }
+
    nir_alu_type output_type = nir_op_infos[src_alu->op].output_type;
    return nir_alu_type_get_base_type(output_type) == nir_type_float;
 }
@@ -432,9 +437,15 @@ is_only_used_as_float(const nir_alu_instr *instr)
       assert(instr != user_alu);
 
       unsigned index = (nir_alu_src*)container_of(src, nir_alu_src, src) - user_alu->src;
-      nir_alu_type type = nir_op_infos[user_alu->op].input_types[index];
-      if (nir_alu_type_get_base_type(type) != nir_type_float)
-         return false;
+
+      if (index != 0 && nir_op_is_bcsel(user_alu->op)) {
+         if (!is_only_used_as_float(user_alu))
+            return false;
+      } else {
+         nir_alu_type type = nir_op_infos[user_alu->op].input_types[index];
+         if (nir_alu_type_get_base_type(type) != nir_type_float)
+            return false;
+      }
    }
 
    return true;
-- 
GitLab


From 90b321b5889f07d7e6d723d0c6df2bf10b412210 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 7 Feb 2023 13:24:59 +0000
Subject: [PATCH 10/12] vtn: make OpenCLstd_{FClamp,Fmax,Fmin,Maxmag,Minmag}
 exact

These are supposed to always handle NaNs.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/spirv/vtn_opencl.c | 44 +++++++++++++++++++++++++--------
 1 file changed, 34 insertions(+), 10 deletions(-)

diff --git a/src/compiler/spirv/vtn_opencl.c b/src/compiler/spirv/vtn_opencl.c
index af76bef9a6ee..6ec69ec89f23 100644
--- a/src/compiler/spirv/vtn_opencl.c
+++ b/src/compiler/spirv/vtn_opencl.c
@@ -223,8 +223,10 @@ handle_instr(struct vtn_builder *b, uint32_t opcode,
 
 static nir_op
 nir_alu_op_for_opencl_opcode(struct vtn_builder *b,
-                             enum OpenCLstd_Entrypoints opcode)
+                             enum OpenCLstd_Entrypoints opcode,
+                             bool *exact)
 {
+   *exact = false;
    switch (opcode) {
    case OpenCLstd_Fabs: return nir_op_fabs;
    case OpenCLstd_SAbs: return nir_op_iabs;
@@ -234,10 +236,10 @@ nir_alu_op_for_opencl_opcode(struct vtn_builder *b,
    case OpenCLstd_Floor: return nir_op_ffloor;
    case OpenCLstd_SHadd: return nir_op_ihadd;
    case OpenCLstd_UHadd: return nir_op_uhadd;
-   case OpenCLstd_Fmax: return nir_op_fmax;
+   case OpenCLstd_Fmax: *exact = true; return nir_op_fmax;
    case OpenCLstd_SMax: return nir_op_imax;
    case OpenCLstd_UMax: return nir_op_umax;
-   case OpenCLstd_Fmin: return nir_op_fmin;
+   case OpenCLstd_Fmin: *exact = true; return nir_op_fmin;
    case OpenCLstd_SMin: return nir_op_imin;
    case OpenCLstd_UMin: return nir_op_umin;
    case OpenCLstd_Mix: return nir_op_flrp;
@@ -276,10 +278,19 @@ handle_alu(struct vtn_builder *b, uint32_t opcode,
            unsigned num_srcs, nir_ssa_def **srcs, struct vtn_type **src_types,
            const struct vtn_type *dest_type)
 {
-   nir_ssa_def *ret = nir_build_alu(&b->nb, nir_alu_op_for_opencl_opcode(b, (enum OpenCLstd_Entrypoints)opcode),
+   bool exact;
+   nir_op op = nir_alu_op_for_opencl_opcode(b, (enum OpenCLstd_Entrypoints)opcode, &exact);
+
+   bool restore_exact = b->nb.exact;
+   b->nb.exact |= exact;
+
+   nir_ssa_def *ret = nir_build_alu(&b->nb, op,
                                     srcs[0], srcs[1], srcs[2], NULL);
    if (opcode == OpenCLstd_Popcount)
       ret = nir_u2uN(&b->nb, ret, glsl_get_bit_size(dest_type->type));
+
+   b->nb.exact = restore_exact;
+
    return ret;
 }
 
@@ -474,6 +485,7 @@ handle_special(struct vtn_builder *b, uint32_t opcode,
    nir_builder *nb = &b->nb;
    enum OpenCLstd_Entrypoints cl_opcode = (enum OpenCLstd_Entrypoints)opcode;
 
+   bool restore_exact = b->nb.exact;
    switch (cl_opcode) {
    case OpenCLstd_SAbs_diff:
      /* these works easier in direct NIR */
@@ -494,8 +506,12 @@ handle_special(struct vtn_builder *b, uint32_t opcode,
       return nir_iadd(nb, nir_imul24_relaxed(nb, srcs[0], srcs[1]), srcs[2]);
    case OpenCLstd_UMad24:
       return nir_umad24_relaxed(nb, srcs[0], srcs[1], srcs[2]);
-   case OpenCLstd_FClamp:
-      return nir_fclamp(nb, srcs[0], srcs[1], srcs[2]);
+   case OpenCLstd_FClamp: {
+      b->nb.exact = true;
+      nir_ssa_def *res = nir_fclamp(nb, srcs[0], srcs[1], srcs[2]);
+      b->nb.exact = restore_exact;
+      return res;
+   }
    case OpenCLstd_SClamp:
       return nir_iclamp(nb, srcs[0], srcs[1], srcs[2]);
    case OpenCLstd_UClamp:
@@ -514,10 +530,18 @@ handle_special(struct vtn_builder *b, uint32_t opcode,
       return nir_fmod(nb, srcs[0], srcs[1]);
    case OpenCLstd_Mad:
       return nir_fmad(nb, srcs[0], srcs[1], srcs[2]);
-   case OpenCLstd_Maxmag:
-      return nir_maxmag(nb, srcs[0], srcs[1]);
-   case OpenCLstd_Minmag:
-      return nir_minmag(nb, srcs[0], srcs[1]);
+   case OpenCLstd_Maxmag: {
+      b->nb.exact = true;
+      nir_ssa_def *res = nir_maxmag(nb, srcs[0], srcs[1]);
+      b->nb.exact = restore_exact;
+      return res;
+   }
+   case OpenCLstd_Minmag: {
+      b->nb.exact = true;
+      nir_ssa_def *res = nir_minmag(nb, srcs[0], srcs[1]);
+      b->nb.exact = restore_exact;
+      return res;
+   }
    case OpenCLstd_Nan:
       return nir_nan(nb, srcs[0]);
    case OpenCLstd_Nextafter:
-- 
GitLab


From bf6f142d7323e2f6eae36eb37df954b092cc6d9f Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 7 Feb 2023 14:12:06 +0000
Subject: [PATCH 11/12] glsl/nir: emit exact fmin/fmax

Some piglit tests (such as fs-nan-builtin-max.shader_test), prusa-slicer
and bgfx's assao example assumes min()/max() handles NaNs.

prusa-slider: https://gitlab.freedesktop.org/mesa/mesa/-/issues/4254

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/glsl/glsl_to_nir.cpp | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 79f22892f928..0bd903b8b22d 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -2200,22 +2200,30 @@ nir_visitor::visit(ir_expression *ir)
       result = type_is_float(out_type) ? nir_fmod(&b, srcs[0], srcs[1])
                                        : nir_umod(&b, srcs[0], srcs[1]);
       break;
-   case ir_binop_min:
+   case ir_binop_min: {
+      bool save_exact = b.exact;
+      b.exact |= type_is_float(out_type);
       if (type_is_float(out_type))
          result = nir_fmin(&b, srcs[0], srcs[1]);
       else if (type_is_signed(out_type))
          result = nir_imin(&b, srcs[0], srcs[1]);
       else
          result = nir_umin(&b, srcs[0], srcs[1]);
+      b.exact = save_exact;
       break;
-   case ir_binop_max:
+   }
+   case ir_binop_max: {
+      bool save_exact = b.exact;
+      b.exact |= type_is_float(out_type);
       if (type_is_float(out_type))
          result = nir_fmax(&b, srcs[0], srcs[1]);
       else if (type_is_signed(out_type))
          result = nir_imax(&b, srcs[0], srcs[1]);
       else
          result = nir_umax(&b, srcs[0], srcs[1]);
+      b.exact = save_exact;
       break;
+   }
    case ir_binop_pow: result = nir_fpow(&b, srcs[0], srcs[1]); break;
    case ir_binop_bit_and: result = nir_iand(&b, srcs[0], srcs[1]); break;
    case ir_binop_bit_or: result = nir_ior(&b, srcs[0], srcs[1]); break;
-- 
GitLab


From d3097681228fd446685c2ddeae4721b5c8541112 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 7 Feb 2023 13:38:47 +0000
Subject: [PATCH 12/12] ci: update traces and expected fails

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/broadcom/ci/broadcom-rpi3-fails.txt             |  3 +++
 src/broadcom/ci/broadcom-rpi4-fails.txt             |  3 +++
 src/freedreno/ci/freedreno-a630-fails.txt           |  3 +++
 src/freedreno/ci/traces-freedreno.yml               |  8 ++++----
 src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt |  3 +++
 src/gallium/drivers/lima/ci/lima-fails.txt          |  3 +++
 src/gallium/drivers/llvmpipe/ci/llvmpipe-fails.txt  |  3 +++
 src/gallium/drivers/softpipe/ci/softpipe-fails.txt  |  2 ++
 src/gallium/drivers/virgl/ci/traces-virgl.yml       | 12 ++++++------
 src/gallium/drivers/virgl/ci/virgl-gl-fails.txt     |  3 +++
 src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt   |  3 +++
 src/gallium/drivers/zink/ci/zink-lvp-fails.txt      |  3 +++
 12 files changed, 39 insertions(+), 10 deletions(-)

diff --git a/src/broadcom/ci/broadcom-rpi3-fails.txt b/src/broadcom/ci/broadcom-rpi3-fails.txt
index 34a1a1b8d445..7cb03e5ae582 100644
--- a/src/broadcom/ci/broadcom-rpi3-fails.txt
+++ b/src/broadcom/ci/broadcom-rpi3-fails.txt
@@ -1224,3 +1224,6 @@ wayland-dEQP-EGL.functional.negative_api.create_pixmap_surface,Fail
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
 spec@glsl-1.10@execution@variable-indexing@vs-output-array-vec2-index-wr-no-unroll,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/broadcom/ci/broadcom-rpi4-fails.txt b/src/broadcom/ci/broadcom-rpi4-fails.txt
index 1e7694f9f258..f5a8444a9c01 100644
--- a/src/broadcom/ci/broadcom-rpi4-fails.txt
+++ b/src/broadcom/ci/broadcom-rpi4-fails.txt
@@ -375,3 +375,6 @@ dEQP-VK.compute.workgroup_memory_explicit_layout.zero_ext.block_with_offset,Cras
 wayland-dEQP-EGL.functional.negative_api.create_pixmap_surface,Fail
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/freedreno/ci/freedreno-a630-fails.txt b/src/freedreno/ci/freedreno-a630-fails.txt
index b36e643c1100..cacb1445a633 100644
--- a/src/freedreno/ci/freedreno-a630-fails.txt
+++ b/src/freedreno/ci/freedreno-a630-fails.txt
@@ -433,3 +433,6 @@ wayland-dEQP-EGL.functional.wide_color.window_fp16_default_colorspace,Fail
 SRGBReadWritePixels,Fail
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/freedreno/ci/traces-freedreno.yml b/src/freedreno/ci/traces-freedreno.yml
index dc94740bc50f..b1949e3da15d 100644
--- a/src/freedreno/ci/traces-freedreno.yml
+++ b/src/freedreno/ci/traces-freedreno.yml
@@ -25,9 +25,9 @@ traces:
       checksum: 8f5929c82e7d990e8c3d2bea14688224
       label: [skip, slow]
     freedreno-a530:
-      checksum: f7e6f426d7b9c82742f00baed830797f
+      checksum: 15e1553b2e11e4b09cf8151b5cc80509
     freedreno-a630:
-      checksum: 6aef509acd1257cc56612141e24dc11c
+      checksum: 641414866e325bf0b6c367f16fbdf455
     zink-a630:
       checksum: 45bdbb33bf87ed114bd548248be13408
 
@@ -48,9 +48,9 @@ traces:
       label: [skip, broken, slow]
       text: Broken minimap rendering since around !14643
     freedreno-a530:
-      checksum: a00c5007c26daab3eccb778e68fb2730
+      checksum: 58ff66b5ab69a19d2723adfcb1900417
     freedreno-a630:
-      checksum: 339dce29ae08569652438116829510c7
+      checksum: 24c2666636cb05fdb5d448d255704d8d
     zink-a630:
       checksum: 2eb996b7d308087c73c57872231f7baa
 
diff --git a/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt b/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt
index f1b8094e03e8..d5fcf3578803 100644
--- a/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt
+++ b/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt
@@ -52,3 +52,6 @@ spec@glsl-1.50@execution@primitive-id-no-gs-line,Fail
 spec@glsl-1.50@execution@primitive-id-no-gs-quad-strip,Fail
 spec@glsl-1.50@execution@primitive-id-no-gs-quads,Fail
 spec@glsl-1.50@execution@variable-indexing@gs-output-array-vec4-index-wr,Crash
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/gallium/drivers/lima/ci/lima-fails.txt b/src/gallium/drivers/lima/ci/lima-fails.txt
index c82a9e70db56..fb15ad96a7b0 100644
--- a/src/gallium/drivers/lima/ci/lima-fails.txt
+++ b/src/gallium/drivers/lima/ci/lima-fails.txt
@@ -663,3 +663,6 @@ spec@ext_texture_compression_s3tc@compressedteximage gl_compressed_srgb_alpha_s3
 spec@ext_texture_compression_s3tc@compressedteximage gl_compressed_srgb_s3tc_dxt1_ext,Fail
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/gallium/drivers/llvmpipe/ci/llvmpipe-fails.txt b/src/gallium/drivers/llvmpipe/ci/llvmpipe-fails.txt
index 835fc4802f30..ef06c48d5e8c 100644
--- a/src/gallium/drivers/llvmpipe/ci/llvmpipe-fails.txt
+++ b/src/gallium/drivers/llvmpipe/ci/llvmpipe-fails.txt
@@ -218,6 +218,9 @@ spec@arb_texture_buffer_object@texture-buffer-size-clamp@rgba8ui_texture_buffer_
 # https://gitlab.freedesktop.org/mesa/mesa/-/issues/7152
 spec@ext_transform_feedback@builtin-varyings gl_culldistance,Fail
 
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
+
 # EGL_BAD_DISPLAY is generated if display is not an EGL display connection
 # eglCreatePixmapSurface(0, 0x0000000000000000, 0x0000000000000000, { EGL_NONE });
 # // 0x0000000000000000 returned
diff --git a/src/gallium/drivers/softpipe/ci/softpipe-fails.txt b/src/gallium/drivers/softpipe/ci/softpipe-fails.txt
index f6a87933e9cc..4894956ebfb3 100644
--- a/src/gallium/drivers/softpipe/ci/softpipe-fails.txt
+++ b/src/gallium/drivers/softpipe/ci/softpipe-fails.txt
@@ -1327,3 +1327,5 @@ spec@arb_texture_buffer_object@texture-buffer-size-clamp,Fail
 # https://gitlab.freedesktop.org/mesa/mesa/-/issues/7152
 spec@ext_transform_feedback@builtin-varyings gl_culldistance,Fail
 
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/gallium/drivers/virgl/ci/traces-virgl.yml b/src/gallium/drivers/virgl/ci/traces-virgl.yml
index 8c0d980a53e3..9ebab763a3b9 100644
--- a/src/gallium/drivers/virgl/ci/traces-virgl.yml
+++ b/src/gallium/drivers/virgl/ci/traces-virgl.yml
@@ -12,7 +12,7 @@ traces:
       checksum: 57ddd36b117adc9216c65c10d914a37e
   gputest/pixmark-piano-v2.trace:
     gl-virgl:
-      checksum: 0d875bda7edc01698342b157c6f51500
+      checksum: 08121f3f84975f5f9dda94f986626a4a
   gputest/triangle-v2.trace:
     gl-virgl:
       checksum: 7812de00011a3a059892e36cea19c696
@@ -21,7 +21,7 @@ traces:
       checksum: b697edce7776f1afe294a7e80dfc013e
   0ad/0ad-v2.trace:
     gl-virgl:
-      checksum: 350e0cf64d124ba98d90106f61775eb4
+      checksum: bc560e5be892807d7712f2d06977bd22
   gputest/gimark-v2.trace:
     gl-virgl:
       label: [crash]
@@ -33,7 +33,7 @@ traces:
       checksum: 73ccaff82ea764057fb0f93f0024cf84
   gputest/pixmark-volplosion-v2.trace:
     gl-virgl:
-      checksum: aef0b32ce99a3b25d35304ca08032833
+      checksum: 2fa7db577ba479640bec6e3e5af3caff
   gputest/plot3d-v2.trace:
     gl-virgl:
       checksum: 96f9fdf530e6041a4f56762b8378f22e
@@ -84,10 +84,10 @@ traces:
       checksum: f4af4067b37c00861fa5911e4c0a6629
   supertuxkart/supertuxkart-mansion-egl-gles-v2.trace:
     gl-virgl:
-      checksum: 4ac8b872bfa701632d76801a3f77c5db
+      checksum: 271af6584237d91383ba1044feb05fb7
   xonotic/xonotic-keybench-high-v2.trace:
     gl-virgl:
-      checksum: f3b184bf8858a6ebccd09e7ca032197e
+      checksum: a3337acf7899980c53f96c1545e26d26
   valve/counterstrike-v2.trace:
     gl-virgl:
       checksum: 3bc0e0e39cb3c29f6d76ff07f1f02860
@@ -111,7 +111,7 @@ traces:
       label: [crash]
   godot/Material Testers.x86_64_2020.04.08_13.38_frame799.rdc:
     gl-virgl:
-      checksum: 0258b50142f47396b4ad1d9d6d6331cf
+      checksum: e25c320362a5725b59e4b7a14459b96b
   ror/ror-default.trace:
     gl-virgl:
       label: [crash]
diff --git a/src/gallium/drivers/virgl/ci/virgl-gl-fails.txt b/src/gallium/drivers/virgl/ci/virgl-gl-fails.txt
index 723badee2880..3fde02395b7b 100644
--- a/src/gallium/drivers/virgl/ci/virgl-gl-fails.txt
+++ b/src/gallium/drivers/virgl/ci/virgl-gl-fails.txt
@@ -46,3 +46,6 @@ KHR-GL32.transform_feedback_overflow_query_ARB.basic-single-stream-interleaved-a
 KHR-GL32.transform_feedback_overflow_query_ARB.basic-single-stream-separate-attribs,Fail
 KHR-GL32.transform_feedback_overflow_query_ARB.multiple-streams-multiple-buffers-per-stream,Fail
 KHR-GL32.transform_feedback_overflow_query_ARB.multiple-streams-one-buffer-per-stream,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt b/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt
index a121c77e672d..74f0c5bc900d 100644
--- a/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt
+++ b/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt
@@ -726,3 +726,6 @@ spec@arb_enhanced_layouts@matching_fp64_types_2,Crash
 spec@arb_enhanced_layouts@matching_fp64_types_3,Crash
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
diff --git a/src/gallium/drivers/zink/ci/zink-lvp-fails.txt b/src/gallium/drivers/zink/ci/zink-lvp-fails.txt
index 094e5ad5fc17..c34095c06d07 100644
--- a/src/gallium/drivers/zink/ci/zink-lvp-fails.txt
+++ b/src/gallium/drivers/zink/ci/zink-lvp-fails.txt
@@ -262,3 +262,6 @@ spec@glsl-4.00@execution@conversion@vert-conversion-explicit-dvec2-vec2,Fail
 spec@glsl-4.00@execution@conversion@vert-conversion-explicit-dvec3-vec3,Fail
 spec@glsl-4.00@execution@conversion@vert-conversion-explicit-dvec4-vec4,Fail
 spec@glsl-4.50@execution@ssbo-atomiccompswap-int,Fail
+
+# piglit bug.
+spec@glsl-1.10@linker@override-builtin-uniform-08,Fail
-- 
GitLab

