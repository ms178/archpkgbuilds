From 1e7f97269b664e03717cf9e6ad41d0b5ada5dfae Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 8 Mar 2023 12:13:05 -0500
Subject: [PATCH 1/7] aux/tc: flag late zs clears as partial clears

this ensures drivers can't optimize out a zs attachment that gets
a late clear

Fixes: 07017aa137b ("util/tc: implement renderpass tracking")
---
 src/gallium/auxiliary/util/u_threaded_context.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index f6001386c767..d92bbc704ac9 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -4363,8 +4363,13 @@ tc_clear(struct pipe_context *_pipe, unsigned buffers, const struct pipe_scissor
       if (info) {
          /* full clears use a different load operation, but are only valid if draws haven't occurred yet */
          info->cbuf_clear |= (buffers >> 2) & ~info->cbuf_load;
-         if (buffers & PIPE_CLEAR_DEPTHSTENCIL && !info->zsbuf_load && !info->zsbuf_clear_partial)
-            info->zsbuf_clear = true;
+         if (buffers & PIPE_CLEAR_DEPTHSTENCIL) {
+            if (!info->zsbuf_load && !info->zsbuf_clear_partial)
+               info->zsbuf_clear = true;
+            else if (!info->zsbuf_clear)
+               /* this is a clear that occurred after a draw: flag as partial to ensure it isn't ignored */
+               info->zsbuf_clear_partial = true;
+         }
       }
    }
    p->scissor_state_set = !!scissor_state;
-- 
GitLab


From 85db6efdb352c2078af2d6a04fd90534bd5be021 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 8 Mar 2023 15:05:39 -0500
Subject: [PATCH 2/7] aux/tc: fix build with TC_DEBUG

---
 src/gallium/auxiliary/util/u_threaded_context.c | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index d92bbc704ac9..3e4eec705556 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -87,7 +87,6 @@ tc_buffer_subdata(struct pipe_context *_pipe,
 static void
 tc_batch_check(UNUSED struct tc_batch *batch)
 {
-   tc_assert(batch->sentinel == TC_SENTINEL);
    tc_assert(batch->num_total_slots <= TC_SLOTS_PER_BATCH);
 }
 
@@ -310,8 +309,6 @@ batch_execute(struct tc_batch *batch, struct pipe_context *pipe, uint64_t *last,
    for (uint64_t *iter = batch->slots; iter != last;) {
       struct tc_call_base *call = (struct tc_call_base *)iter;
 
-      tc_assert(call->sentinel == TC_SENTINEL);
-
 #if TC_DEBUG >= 3
       tc_printf("CALL: %s", tc_call_names[call->call_id]);
 #endif
@@ -470,9 +467,6 @@ tc_add_sized_call(struct threaded_context *tc, enum tc_call_id id,
    struct tc_call_base *call = (struct tc_call_base*)&next->slots[next->num_total_slots];
    next->num_total_slots += num_slots;
 
-#if !defined(NDEBUG) && TC_DEBUG >= 1
-   call->sentinel = TC_SENTINEL;
-#endif
    call->call_id = id;
    call->num_slots = num_slots;
 
@@ -4878,9 +4872,6 @@ threaded_context_create(struct pipe_context *pipe,
       goto fail;
 
    for (unsigned i = 0; i < TC_MAX_BATCHES; i++) {
-#if !defined(NDEBUG) && TC_DEBUG >= 1
-      tc->batch_slots[i].sentinel = TC_SENTINEL;
-#endif
       tc->batch_slots[i].tc = tc;
       util_queue_fence_init(&tc->batch_slots[i].fence);
       tc->batch_slots[i].renderpass_info_idx = -1;
-- 
GitLab


From f13432734dccbf17a78d0aa67a46f9763a9ffce2 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 8 Mar 2023 15:06:10 -0500
Subject: [PATCH 3/7] aux/tc: use a local 'deferred' variable in tc_flush()

no functional changes
---
 src/gallium/auxiliary/util/u_threaded_context.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 3e4eec705556..4f4cc1c82c25 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -3413,6 +3413,7 @@ tc_flush(struct pipe_context *_pipe, struct pipe_fence_handle **fence,
    struct pipe_context *pipe = tc->pipe;
    struct pipe_screen *screen = pipe->screen;
    bool async = flags & (PIPE_FLUSH_DEFERRED | PIPE_FLUSH_ASYNC);
+   bool deferred = (flags & PIPE_FLUSH_DEFERRED) > 0;
 
    tc->in_renderpass = false;
 
@@ -3436,7 +3437,7 @@ tc_flush(struct pipe_context *_pipe, struct pipe_fence_handle **fence,
       }
 
       struct tc_flush_call *p;
-      if (flags & PIPE_FLUSH_DEFERRED) {
+      if (deferred) {
          /* these have identical fields */
          p = (struct tc_flush_call *)tc_add_call(tc, TC_CALL_flush_deferred, tc_flush_deferred_call);
       } else {
@@ -3446,7 +3447,7 @@ tc_flush(struct pipe_context *_pipe, struct pipe_fence_handle **fence,
       p->fence = fence ? *fence : NULL;
       p->flags = flags | TC_FLUSH_ASYNC;
 
-      if (!(flags & PIPE_FLUSH_DEFERRED)) {
+      if (!deferred) {
          /* non-deferred async flushes indicate completion of existing renderpass info */
          tc_signal_renderpass_info_ready(tc);
          tc_batch_flush(tc, false);
@@ -3461,7 +3462,7 @@ out_of_memory:
    tc_sync_msg(tc, flags & PIPE_FLUSH_END_OF_FRAME ? "end of frame" :
                    flags & PIPE_FLUSH_DEFERRED ? "deferred fence" : "normal");
 
-   if (!(flags & PIPE_FLUSH_DEFERRED)) {
+   if (!deferred) {
       tc_flush_queries(tc);
       tc->seen_fb_state = false;
       tc->query_ended = false;
-- 
GitLab


From 9f8d310949674408b2bebe5a5923e0269769386a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 8 Mar 2023 15:06:49 -0500
Subject: [PATCH 4/7] aux/tc: fix renderpass splitting on flush

it's expected that a driver won't immediately trigger a deferred flush
if a fence is present, so don't split the renderpass in this case since
that breaks everything

Fixes: 07017aa137b ("util/tc: implement renderpass tracking")
---
 src/gallium/auxiliary/util/u_threaded_context.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 4f4cc1c82c25..4876d61dc804 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -3415,7 +3415,8 @@ tc_flush(struct pipe_context *_pipe, struct pipe_fence_handle **fence,
    bool async = flags & (PIPE_FLUSH_DEFERRED | PIPE_FLUSH_ASYNC);
    bool deferred = (flags & PIPE_FLUSH_DEFERRED) > 0;
 
-   tc->in_renderpass = false;
+   if (!deferred || !fence)
+      tc->in_renderpass = false;
 
    if (async && tc->options.create_fence) {
       if (fence) {
-- 
GitLab


From 44c8f1d463445e33481d83eb2fa6f64c2102de59 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 9 Mar 2023 07:18:23 -0500
Subject: [PATCH 5/7] aux/tc: track the number of active queries

---
 src/gallium/auxiliary/util/u_threaded_context.c | 2 ++
 src/gallium/auxiliary/util/u_threaded_context.h | 1 +
 2 files changed, 3 insertions(+)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 4876d61dc804..de3c0b17c62f 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -1088,6 +1088,7 @@ static bool
 tc_begin_query(struct pipe_context *_pipe, struct pipe_query *query)
 {
    struct threaded_context *tc = threaded_context(_pipe);
+   tc->num_queries_active++;
 
    tc_add_call(tc, TC_CALL_begin_query, tc_query_call)->query = query;
    return true; /* we don't care about the return value for this call */
@@ -1119,6 +1120,7 @@ tc_end_query(struct pipe_context *_pipe, struct pipe_query *query)
    struct threaded_query *tq = threaded_query(query);
    struct tc_end_query_call *call =
       tc_add_call(tc, TC_CALL_end_query, tc_end_query_call);
+   tc->num_queries_active--;
 
    call->tc = tc;
    call->query = query;
diff --git a/src/gallium/auxiliary/util/u_threaded_context.h b/src/gallium/auxiliary/util/u_threaded_context.h
index 937c99db4c83..e376d688fd30 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.h
+++ b/src/gallium/auxiliary/util/u_threaded_context.h
@@ -563,6 +563,7 @@ struct threaded_context {
    bool use_forced_staging_uploads;
    bool add_all_gfx_bindings_to_buffer_list;
    bool add_all_compute_bindings_to_buffer_list;
+   uint8_t num_queries_active;
 
    /* Estimation of how much vram/gtt bytes are mmap'd in
     * the current tc_batch.
-- 
GitLab


From 895e5900865ff8e2fd55bfd585c1ff077e02caaa Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 8 Mar 2023 18:36:24 -0500
Subject: [PATCH 6/7] aux/tc: handle renderpass tracking corner case

this is stupid, but there's no solution besides reducing the
amount of syncing that tc does to try and avoid it
---
 .../auxiliary/util/u_threaded_context.c       | 27 ++++++++++++++++++-
 .../auxiliary/util/u_threaded_context.h       |  2 ++
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index de3c0b17c62f..eac01a585104 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -556,6 +556,29 @@ _tc_sync(struct threaded_context *tc, UNUSED const char *info, UNUSED const char
 
    tc_debug_check(tc);
 
+   if (tc->options.parse_renderpass_info && tc->in_renderpass && !tc->flushing) {
+      /* corner case: if tc syncs for any reason but a driver flush during a renderpass,
+       * then the current renderpass info MUST be signaled to avoid deadlocking the driver
+       *
+       * this is not a "complete" signal operation, however, as it's unknown what calls may
+       * come after this one, which means that framebuffer attachment data is unreliable
+       * 
+       * to avoid erroneously passing bad state to the driver (e.g., allowing zsbuf elimination),
+       * force all attachments active and assume the app was going to get bad perf here anyway
+       */
+      for (unsigned i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
+         if (tc->fb_resources[i] && !(tc->renderpass_info_recording->cbuf_clear & BITFIELD_BIT(i)))
+            /* ensure existing data is preserved; driver can always detect invalidation */
+            tc->renderpass_info_recording->cbuf_load |= BITFIELD_BIT(i);
+      }
+      if (tc->fb_resources[PIPE_MAX_COLOR_BUFS] && !tc_renderpass_info_is_zsbuf_used(tc->renderpass_info_recording))
+         /* this should be a "safe" way to indicate to the driver that both loads and stores are required;
+          * driver can always detect invalidation
+          */
+         tc->renderpass_info_recording->zsbuf_clear_partial = true;
+      if (tc->num_queries_active)
+         tc->renderpass_info_recording->has_query_ends = true;
+   }
    tc_signal_renderpass_info_ready(tc);
 
    /* Only wait for queued calls... */
@@ -3461,6 +3484,7 @@ tc_flush(struct pipe_context *_pipe, struct pipe_fence_handle **fence,
    }
 
 out_of_memory:
+   tc->flushing = true;
    /* renderpass info is signaled during sync */
    tc_sync_msg(tc, flags & PIPE_FLUSH_END_OF_FRAME ? "end of frame" :
                    flags & PIPE_FLUSH_DEFERRED ? "deferred fence" : "normal");
@@ -3473,6 +3497,7 @@ out_of_memory:
    tc_set_driver_thread(tc);
    pipe->flush(pipe, fence, flags);
    tc_clear_driver_thread(tc);
+   tc->flushing = false;
 }
 
 struct tc_draw_single {
@@ -5070,4 +5095,4 @@ threaded_context_get_renderpass_info(struct threaded_context *tc, bool wait)
    if (tc->renderpass_info && wait)
       util_queue_fence_wait(&tc->renderpass_info->ready);
    return tc->renderpass_info;
-}
\ No newline at end of file
+}
diff --git a/src/gallium/auxiliary/util/u_threaded_context.h b/src/gallium/auxiliary/util/u_threaded_context.h
index e376d688fd30..68ac2c2fcc3e 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.h
+++ b/src/gallium/auxiliary/util/u_threaded_context.h
@@ -592,6 +592,8 @@ struct threaded_context {
    bool in_renderpass;
    /* whether a query has ended more recently than a draw */
    bool query_ended;
+   /* whether pipe_context::flush has been called */
+   bool flushing;
 
    bool seen_streamout_buffers;
    bool seen_shader_buffers[PIPE_SHADER_TYPES];
-- 
GitLab


From d842101359ab354b4082cd0adfd8824bdf36c22f Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 9 Mar 2023 07:37:02 -0500
Subject: [PATCH 7/7] aux/tc: don't sync for get_sample_position

no drivers actually use the context for this, so a sync is pointless
---
 src/gallium/auxiliary/util/u_threaded_context.c | 1 -
 src/gallium/auxiliary/util/u_threaded_context.h | 1 +
 2 files changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index eac01a585104..11629467d101 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -3151,7 +3151,6 @@ tc_get_sample_position(struct pipe_context *_pipe,
    struct threaded_context *tc = threaded_context(_pipe);
    struct pipe_context *pipe = tc->pipe;
 
-   tc_sync(tc);
    pipe->get_sample_position(pipe, sample_count, sample_index,
                              out_value);
 }
diff --git a/src/gallium/auxiliary/util/u_threaded_context.h b/src/gallium/auxiliary/util/u_threaded_context.h
index 68ac2c2fcc3e..621b67fa90ca 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.h
+++ b/src/gallium/auxiliary/util/u_threaded_context.h
@@ -78,6 +78,7 @@
  * - transfer_map (only unsychronized buffer mappings)
  * - get_query_result (when threaded_query::flushed == true)
  * - create_stream_output_target
+ * - get_sample_position
  *
  *
  * Transfer_map rules for buffer mappings
-- 
GitLab

