--- a/src/mesa/main/matrix.c	2025-10-02 20:44:54.337186391 +0200
+++ b/src/mesa/main/matrix.c	2025-10-02 20:45:45.884745099 +0200
@@ -376,6 +376,11 @@ pop_matrix( struct gl_context *ctx, stru
    if (stack->Depth == 0)
       return GL_FALSE;
 
+   /* Sync if in glthread to avoid racing with main-thread attribute calls */
+   if (ctx->GLThread.enabled) {
+      _mesa_glthread_finish_before(ctx, "pop_matrix");
+   }
+
    stack->Depth--;
 
    /* If the popped matrix is the same as the current one, treat it as
@@ -1008,8 +1013,13 @@ init_matrix_stack(struct gl_matrix_stack
    stack->Depth = 0;
    stack->MaxDepth = maxDepth;
    stack->DirtyFlag = dirtyFlag;
-   /* The stack will be dynamically resized at glPushMatrix() time */
    stack->Stack = os_malloc_aligned(sizeof(GLmatrix), 16);
+   if (stack->Stack == NULL) {
+      _mesa_error(NULL, GL_OUT_OF_MEMORY, "init_matrix_stack allocation failed");
+      stack->StackSize = 0;
+      stack->Top = NULL;
+      return;
+   }
    stack->StackSize = 1;
    _math_matrix_ctr(&stack->Stack[0]);
    stack->Top = stack->Stack;
@@ -1024,6 +1034,9 @@ init_matrix_stack(struct gl_matrix_stack
 static void
 free_matrix_stack( struct gl_matrix_stack *stack )
 {
+   if (stack->Stack == NULL) {
+      return;
+   }
    os_free_aligned(stack->Stack);
    stack->Stack = stack->Top = NULL;
    stack->StackSize = 0;
@@ -1049,21 +1062,43 @@ void _mesa_init_matrix( struct gl_contex
 {
    GLuint i;
 
-   /* Initialize matrix stacks */
+   // Initialize matrix stacks with OOM checks (holistic: Ensure all succeed or fail cleanly)
    init_matrix_stack(&ctx->ModelviewMatrixStack, MAX_MODELVIEW_STACK_DEPTH,
                      _NEW_MODELVIEW);
+   if (ctx->ModelviewMatrixStack.Stack == NULL) goto init_fail;  // Propagate OOM
+
    init_matrix_stack(&ctx->ProjectionMatrixStack, MAX_PROJECTION_STACK_DEPTH,
                      _NEW_PROJECTION);
-   for (i = 0; i < ARRAY_SIZE(ctx->TextureMatrixStack); i++)
+   if (ctx->ProjectionMatrixStack.Stack == NULL) goto init_fail;
+
+   for (i = 0; i < ARRAY_SIZE(ctx->TextureMatrixStack); i++) {
       init_matrix_stack(&ctx->TextureMatrixStack[i], MAX_TEXTURE_STACK_DEPTH,
                         _NEW_TEXTURE_MATRIX);
-   for (i = 0; i < ARRAY_SIZE(ctx->ProgramMatrixStack); i++)
+      if (ctx->TextureMatrixStack[i].Stack == NULL) goto init_fail;
+   }
+
+   for (i = 0; i < ARRAY_SIZE(ctx->ProgramMatrixStack); i++) {
       init_matrix_stack(&ctx->ProgramMatrixStack[i],
-		        MAX_PROGRAM_MATRIX_STACK_DEPTH, _NEW_TRACK_MATRIX);
+                        MAX_PROGRAM_MATRIX_STACK_DEPTH, _NEW_TRACK_MATRIX);
+      if (ctx->ProgramMatrixStack[i].Stack == NULL) goto init_fail;
+   }
+
    ctx->CurrentStack = &ctx->ModelviewMatrixStack;
 
-   /* Init combined Modelview*Projection matrix */
+   // Init combined Modelview*Projection matrix (safe after checks)
    _math_matrix_ctr( &ctx->_ModelProjectMatrix );
+
+   return;  // Success
+
+init_fail:
+   // Cleanup partial allocations to avoid leaks (memory-safe)
+   free_matrix_stack(&ctx->ModelviewMatrixStack);
+   free_matrix_stack(&ctx->ProjectionMatrixStack);
+   for (i = 0; i < ARRAY_SIZE(ctx->TextureMatrixStack); i++)
+      free_matrix_stack(&ctx->TextureMatrixStack[i]);
+   for (i = 0; i < ARRAY_SIZE(ctx->ProgramMatrixStack); i++)
+      free_matrix_stack(&ctx->ProgramMatrixStack[i]);
+   // Caller (init_attrib_groups) will handle failed init (e.g., context creation fails)
 }
