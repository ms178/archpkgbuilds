From a29263d2a8854cc675504457d37b830abb07c10f Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Fri, 1 Sep 2023 16:26:02 -0700
Subject: [PATCH 1/7] compiler/types: Move the C++ inline functions in
 glsl_type out of the struct body

Just move code, will make easier to flip these to be wrappers to the C code.  Keep
those in a separate header file to reduce cluttering glsl_types.h.
---
 src/compiler/glsl_types.h      | 335 ++++++---------------------------
 src/compiler/glsl_types_impl.h | 333 ++++++++++++++++++++++++++++++++
 src/compiler/meson.build       |   1 +
 3 files changed, 387 insertions(+), 282 deletions(-)
 create mode 100644 src/compiler/glsl_types_impl.h

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 562bc8d6dee7..2bb445444173 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -515,10 +515,7 @@ struct glsl_type {
    /**
     * Query the total number of scalars that make up a scalar, vector or matrix
     */
-   unsigned components() const
-   {
-      return vector_elements * matrix_columns;
-   }
+   unsigned components() const;
 
    /**
     * Calculate the number of components slots required to hold this type
@@ -585,9 +582,7 @@ struct glsl_type {
     * Vulkan doesn’t make this distinction so the argument should always be
     * false.
     */
-   unsigned count_attribute_slots(bool is_gl_vertex_input) const {
-      return count_vec4_slots(is_gl_vertex_input, true);
-   }
+   unsigned count_attribute_slots(bool is_gl_vertex_input) const;
 
    /**
     * Alignment in bytes of the start of this type in a std140 uniform
@@ -684,98 +679,57 @@ struct glsl_type {
    /**
     * Query whether or not a type is a scalar (non-vector and non-matrix).
     */
-   bool is_scalar() const
-   {
-      return (vector_elements == 1)
-	 && (base_type >= GLSL_TYPE_UINT)
-	 && (base_type <= GLSL_TYPE_IMAGE);
-   }
+   bool is_scalar() const;
 
    /**
     * Query whether or not a type is a vector
     */
-   bool is_vector() const
-   {
-      return (vector_elements > 1)
-	 && (matrix_columns == 1)
-	 && (base_type >= GLSL_TYPE_UINT)
-	 && (base_type <= GLSL_TYPE_BOOL);
-   }
+   bool is_vector() const;
 
    /**
     * Query whether or not a type is a matrix
     */
-   bool is_matrix() const
-   {
-      /* GLSL only has float matrices. */
-      return (matrix_columns > 1) && (base_type == GLSL_TYPE_FLOAT ||
-                                      base_type == GLSL_TYPE_DOUBLE ||
-                                      base_type == GLSL_TYPE_FLOAT16);
-   }
+   bool is_matrix() const;
 
    /**
     * Query whether or not a type is a non-array numeric type
     */
-   bool is_numeric() const
-   {
-      return (base_type >= GLSL_TYPE_UINT) && (base_type <= GLSL_TYPE_INT64);
-   }
+   bool is_numeric() const;
 
    /**
     * Query whether or not a type is an integer.
     */
-   bool is_integer() const
-   {
-      return glsl_base_type_is_integer(base_type);
-   }
+   bool is_integer() const;
 
    /**
     * Query whether or not a type is a 16-bit integer.
     */
-   bool is_integer_16() const
-   {
-      return base_type == GLSL_TYPE_UINT16 || base_type == GLSL_TYPE_INT16;
-   }
+   bool is_integer_16() const;
 
    /**
     * Query whether or not a type is an 32-bit integer.
     */
-   bool is_integer_32() const
-   {
-      return (base_type == GLSL_TYPE_UINT) || (base_type == GLSL_TYPE_INT);
-   }
+   bool is_integer_32() const;
 
    /**
     * Query whether or not a type is a 64-bit integer.
     */
-   bool is_integer_64() const
-   {
-      return base_type == GLSL_TYPE_UINT64 || base_type == GLSL_TYPE_INT64;
-   }
+   bool is_integer_64() const;
 
    /**
     * Query whether or not a type is a 32-bit or 64-bit integer
     */
-   bool is_integer_32_64() const
-   {
-      return is_integer_32() || is_integer_64();
-   }
+   bool is_integer_32_64() const;
 
    /**
     * Query whether or not a type is a 16-bit or 32-bit integer
     */
-   bool is_integer_16_32() const
-   {
-      return is_integer_16() || is_integer_32();
-   }
+   bool is_integer_16_32() const;
 
    /**
     * Query whether or not a type is a 16-bit, 32-bit or 64-bit integer
     */
-   bool is_integer_16_32_64() const
-   {
-      return is_integer_16() || is_integer_32() || is_integer_64();
-   }
+   bool is_integer_16_32_64() const;
 
    /**
     * Query whether or not type is an integral type, or for struct and array
@@ -798,126 +752,70 @@ struct glsl_type {
    /**
     * Query whether or not a type is a float type
     */
-   bool is_float() const
-   {
-      return base_type == GLSL_TYPE_FLOAT;
-   }
+   bool is_float() const;
 
    /**
     * Query whether or not a type is a half-float or float type
     */
-   bool is_float_16_32() const
-   {
-      return base_type == GLSL_TYPE_FLOAT16 || is_float();
-   }
+   bool is_float_16_32() const;
 
    /**
     * Query whether or not a type is a half-float, float or double
     */
-   bool is_float_16_32_64() const
-   {
-      return base_type == GLSL_TYPE_FLOAT16 || is_float() || is_double();
-   }
+   bool is_float_16_32_64() const;
 
    /**
     * Query whether or not a type is a float or double
     */
-   bool is_float_32_64() const
-   {
-      return is_float() || is_double();
-   }
+   bool is_float_32_64() const;
 
-   bool is_int_16_32_64() const
-   {
-      return base_type == GLSL_TYPE_INT16 ||
-             base_type == GLSL_TYPE_INT ||
-             base_type == GLSL_TYPE_INT64;
-   }
+   bool is_int_16_32_64() const;
 
-   bool is_uint_16_32_64() const
-   {
-      return base_type == GLSL_TYPE_UINT16 ||
-             base_type == GLSL_TYPE_UINT ||
-             base_type == GLSL_TYPE_UINT64;
-   }
+   bool is_uint_16_32_64() const;
 
-   bool is_int_16_32() const
-   {
-      return base_type == GLSL_TYPE_INT ||
-             base_type == GLSL_TYPE_INT16;
-   }
+   bool is_int_16_32() const;
 
-   bool is_uint_16_32() const
-   {
-      return base_type == GLSL_TYPE_UINT ||
-             base_type == GLSL_TYPE_UINT16;
-   }
+   bool is_uint_16_32() const;
 
    /**
     * Query whether or not a type is a double type
     */
-   bool is_double() const
-   {
-      return base_type == GLSL_TYPE_DOUBLE;
-   }
+   bool is_double() const;
 
    /**
     * Query whether a 64-bit type takes two slots.
     */
-   bool is_dual_slot() const
-   {
-      return is_64bit() && vector_elements > 2;
-   }
+   bool is_dual_slot() const;
 
    /**
     * Query whether or not a type is 64-bit
     */
-   bool is_64bit() const
-   {
-      return glsl_base_type_is_64bit(base_type);
-   }
+   bool is_64bit() const;
 
    /**
     * Query whether or not a type is 16-bit
     */
-   bool is_16bit() const
-   {
-      return glsl_base_type_is_16bit(base_type);
-   }
+   bool is_16bit() const;
 
    /**
     * Query whether or not a type is 32-bit
     */
-   bool is_32bit() const
-   {
-      return base_type == GLSL_TYPE_UINT ||
-             base_type == GLSL_TYPE_INT ||
-             base_type == GLSL_TYPE_FLOAT;
-   }
+   bool is_32bit() const;
 
    /**
     * Query whether or not a type is a non-array boolean type
     */
-   bool is_boolean() const
-   {
-      return base_type == GLSL_TYPE_BOOL;
-   }
+   bool is_boolean() const;
 
    /**
     * Query whether or not a type is a sampler
     */
-   bool is_sampler() const
-   {
-      return base_type == GLSL_TYPE_SAMPLER;
-   }
+   bool is_sampler() const;
 
    /**
     * Query whether or not a type is a texture
     */
-   bool is_texture() const
-   {
-      return base_type == GLSL_TYPE_TEXTURE;
-   }
+   bool is_texture() const;
 
    /**
     * Query whether or not type is a sampler, or for struct, interface and
@@ -940,75 +838,44 @@ struct glsl_type {
    /**
     * Query whether or not a type is an image
     */
-   bool is_image() const
-   {
-      return base_type == GLSL_TYPE_IMAGE;
-   }
+   bool is_image() const;
 
    /**
     * Query whether or not a type is an array
     */
-   bool is_array() const
-   {
-      return base_type == GLSL_TYPE_ARRAY;
-   }
+   bool is_array() const;
 
-   bool is_array_of_arrays() const
-   {
-      return is_array() && fields.array->is_array();
-   }
+   bool is_array_of_arrays() const;
 
-   bool is_cmat() const
-   {
-      return base_type == GLSL_TYPE_COOPERATIVE_MATRIX;
-   }
+   bool is_cmat() const;
 
    /**
     * Query whether or not a type is a record
     */
-   bool is_struct() const
-   {
-      return base_type == GLSL_TYPE_STRUCT;
-   }
+   bool is_struct() const;
 
    /**
     * Query whether or not a type is an interface
     */
-   bool is_interface() const
-   {
-      return base_type == GLSL_TYPE_INTERFACE;
-   }
+   bool is_interface() const;
 
    /**
     * Query whether or not a type is the void type singleton.
     */
-   bool is_void() const
-   {
-      return base_type == GLSL_TYPE_VOID;
-   }
+   bool is_void() const;
 
    /**
     * Query whether or not a type is the error type singleton.
     */
-   bool is_error() const
-   {
-      return base_type == GLSL_TYPE_ERROR;
-   }
+   bool is_error() const;
 
    /**
     * Query if a type is unnamed/anonymous (named by the parser)
     */
 
-   bool is_subroutine() const
-   {
-      return base_type == GLSL_TYPE_SUBROUTINE;
-   }
+   bool is_subroutine() const;
    bool contains_subroutine() const;
-
-   bool is_anonymous() const
-   {
-      return !strncmp(glsl_get_type_name(this), "#anon", 5);
-   }
+   bool is_anonymous() const;
 
    /**
     * Get the type stripped of any arrays
@@ -1017,72 +884,34 @@ struct glsl_type {
     * Pointer to the type of elements of the first non-array type for array
     * types, or pointer to itself for non-array types.
     */
-   const glsl_type *without_array() const
-   {
-      const glsl_type *t = this;
-
-      while (t->is_array())
-         t = t->fields.array;
-
-      return t;
-   }
+   const glsl_type *without_array() const;
 
    /**
     * Return the total number of elements in an array including the elements
     * in arrays of arrays.
     */
-   unsigned arrays_of_arrays_size() const
-   {
-      if (!is_array())
-         return 0;
-
-      unsigned size = length;
-      const glsl_type *array_base_type = fields.array;
-
-      while (array_base_type->is_array()) {
-         size = size * array_base_type->length;
-         array_base_type = array_base_type->fields.array;
-      }
-      return size;
-   }
+   unsigned arrays_of_arrays_size() const;
 
    /**
     * Return bit size for this type.
     */
-   unsigned bit_size() const
-   {
-      return glsl_base_type_bit_size(this->base_type);
-   }
+   unsigned bit_size() const;
 
 
    /**
     * Query whether or not a type is an atomic_uint.
     */
-   bool is_atomic_uint() const
-   {
-      return base_type == GLSL_TYPE_ATOMIC_UINT;
-   }
+   bool is_atomic_uint() const;
 
    /**
     * Return the amount of atomic counter storage required for a type.
     */
-   unsigned atomic_size() const
-   {
-      if (is_atomic_uint())
-         return 4; /* ATOMIC_COUNTER_SIZE */
-      else if (is_array())
-         return length * fields.array->atomic_size();
-      else
-         return 0;
-   }
+   unsigned atomic_size() const;
 
    /**
     * Return whether a type contains any atomic counters.
     */
-   bool contains_atomic() const
-   {
-      return atomic_size() > 0;
-   }
+   bool contains_atomic() const;
 
    /**
     * Return whether a type contains any opaque types.
@@ -1096,16 +925,7 @@ struct glsl_type {
     * If the type is not a matrix, \c glsl_type::error_type is returned.
     * Otherwise a type matching the rows of the matrix is returned.
     */
-   const glsl_type *row_type() const
-   {
-      if (!is_matrix())
-         return error_type;
-
-      if (explicit_stride && !interface_row_major)
-         return get_instance(base_type, matrix_columns, 1, explicit_stride);
-      else
-         return get_instance(base_type, matrix_columns, 1);
-   }
+   const glsl_type *row_type() const;
 
    /**
     * Query the full type of a matrix column
@@ -1114,27 +934,7 @@ struct glsl_type {
     * If the type is not a matrix, \c glsl_type::error_type is returned.
     * Otherwise a type matching the columns of the matrix is returned.
     */
-   const glsl_type *column_type() const
-   {
-      if (!is_matrix())
-         return error_type;
-
-      if (interface_row_major) {
-         /* If we're row-major, the vector element stride is the same as the
-          * matrix stride and we have no alignment (i.e. component-aligned).
-          */
-         return get_instance(base_type, vector_elements, 1,
-                             explicit_stride, false, 0);
-      } else {
-         /* Otherwise, the vector is tightly packed (stride=0).  For
-          * alignment, we treat a matrix as an array of columns make the same
-          * assumption that the alignment of the column is the same as the
-          * alignment of the whole matrix.
-          */
-         return get_instance(base_type, vector_elements, 1,
-                             0, false, explicit_alignment);
-      }
-   }
+   const glsl_type *column_type() const;
 
    /**
     * Get the type of a structure field
@@ -1158,18 +958,12 @@ struct glsl_type {
     * types.  If the number of elements in the array has not yet been declared,
     * zero is returned.
     */
-   int array_size() const
-   {
-      return is_array() ? length : -1;
-   }
+   int array_size() const;
 
    /**
     * Query whether the array size for all dimensions has been declared.
     */
-   bool is_unsized_array() const
-   {
-      return is_array() && length == 0;
-   }
+   bool is_unsized_array() const;
 
    /**
     * Return the number of coordinate components needed for this
@@ -1210,39 +1004,18 @@ struct glsl_type {
    /**
     * Get the type interface packing.
     */
-   enum glsl_interface_packing get_interface_packing() const
-   {
-      return (enum glsl_interface_packing)interface_packing;
-   }
+   enum glsl_interface_packing get_interface_packing() const;
 
    /**
     * Get the type interface packing used internally. For shared and packing
     * layouts this is implementation defined.
     */
-   enum glsl_interface_packing get_internal_ifc_packing(bool std430_supported) const
-   {
-      enum glsl_interface_packing packing = this->get_interface_packing();
-      if (packing == GLSL_INTERFACE_PACKING_STD140 ||
-          (!std430_supported &&
-           (packing == GLSL_INTERFACE_PACKING_SHARED ||
-            packing == GLSL_INTERFACE_PACKING_PACKED))) {
-         return GLSL_INTERFACE_PACKING_STD140;
-      } else {
-         assert(packing == GLSL_INTERFACE_PACKING_STD430 ||
-                (std430_supported &&
-                 (packing == GLSL_INTERFACE_PACKING_SHARED ||
-                  packing == GLSL_INTERFACE_PACKING_PACKED)));
-         return GLSL_INTERFACE_PACKING_STD430;
-      }
-   }
+   enum glsl_interface_packing get_internal_ifc_packing(bool std430_supported) const;
 
    /**
     * Check if the type interface is row major
     */
-   bool get_interface_row_major() const
-   {
-      return (bool) interface_row_major;
-   }
+   bool get_interface_row_major() const;
 
 #endif /* __cplusplus */
 };
@@ -1386,9 +1159,7 @@ struct glsl_struct_field {
 #endif
 
 #ifdef __cplusplus
-#define BUILTIN_TYPES_CPP_DEFINITIONS
-#include "builtin_types_cpp.h"
-#undef BUILTIN_TYPES_CPP_DEFINITIONS
+#include "glsl_types_impl.h"
 #endif
 
 #endif /* GLSL_TYPES_H */
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
new file mode 100644
index 000000000000..bf4a4290f297
--- /dev/null
+++ b/src/compiler/glsl_types_impl.h
@@ -0,0 +1,333 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ * SPDX-License-Identifier: MIT
+ */
+
+#ifndef GLSL_TYPES_IMPL_H
+#define GLSL_TYPES_IMPL_H
+
+#ifdef __cplusplus
+
+#define BUILTIN_TYPES_CPP_DEFINITIONS
+#include "compiler/builtin_types_cpp.h"
+#undef BUILTIN_TYPES_CPP_DEFINITIONS
+
+inline bool glsl_type::is_boolean() const { return base_type == GLSL_TYPE_BOOL; }
+inline bool glsl_type::is_sampler() const { return base_type == GLSL_TYPE_SAMPLER; }
+inline bool glsl_type::is_texture() const { return base_type == GLSL_TYPE_TEXTURE; }
+inline bool glsl_type::is_image() const { return base_type == GLSL_TYPE_IMAGE; }
+inline bool glsl_type::is_array() const { return base_type == GLSL_TYPE_ARRAY; }
+inline bool glsl_type::is_struct() const { return base_type == GLSL_TYPE_STRUCT; }
+inline bool glsl_type::is_interface() const { return base_type == GLSL_TYPE_INTERFACE; }
+inline bool glsl_type::is_cmat() const { return base_type == GLSL_TYPE_COOPERATIVE_MATRIX; }
+inline bool glsl_type::is_void() const { return base_type == GLSL_TYPE_VOID; }
+inline bool glsl_type::is_error() const { return base_type == GLSL_TYPE_ERROR; }
+inline bool glsl_type::is_subroutine() const { return base_type == GLSL_TYPE_SUBROUTINE; }
+inline bool glsl_type::is_atomic_uint() const { return base_type == GLSL_TYPE_ATOMIC_UINT; }
+
+
+inline bool
+glsl_type::is_scalar() const
+{
+   return (vector_elements == 1)
+          && (base_type >= GLSL_TYPE_UINT)
+          && (base_type <= GLSL_TYPE_IMAGE);
+}
+
+inline bool
+glsl_type::is_vector() const
+{
+   return (vector_elements > 1)
+          && (matrix_columns == 1)
+          && (base_type >= GLSL_TYPE_UINT)
+          && (base_type <= GLSL_TYPE_BOOL);
+}
+
+inline bool
+glsl_type::is_matrix() const
+{
+   /* GLSL only has float matrices. */
+   return (matrix_columns > 1) && (base_type == GLSL_TYPE_FLOAT ||
+                                   base_type == GLSL_TYPE_DOUBLE ||
+                                   base_type == GLSL_TYPE_FLOAT16);
+}
+
+inline bool
+glsl_type::is_numeric() const
+{
+   return (base_type >= GLSL_TYPE_UINT) && (base_type <= GLSL_TYPE_INT64);
+}
+
+inline bool glsl_type::is_integer() const { return glsl_base_type_is_integer(base_type); }
+inline bool glsl_type::is_double() const { return base_type == GLSL_TYPE_DOUBLE; }
+
+inline bool
+glsl_type::is_array_of_arrays() const
+{
+   return is_array() && fields.array->is_array();
+}
+
+inline bool
+glsl_type::is_dual_slot() const
+{
+   return is_64bit() && vector_elements > 2;
+}
+
+inline bool
+glsl_type::is_64bit() const
+{
+   return glsl_base_type_is_64bit(base_type);
+}
+
+inline bool
+glsl_type::is_16bit() const
+{
+   return glsl_base_type_is_16bit(base_type);
+}
+
+inline bool
+glsl_type::is_32bit() const
+{
+   return base_type == GLSL_TYPE_UINT ||
+          base_type == GLSL_TYPE_INT ||
+          base_type == GLSL_TYPE_FLOAT;
+}
+
+inline unsigned
+glsl_type::components() const
+{
+   return vector_elements * matrix_columns;
+}
+
+inline unsigned
+glsl_type::count_attribute_slots(bool is_gl_vertex_input) const
+{
+   return count_vec4_slots(is_gl_vertex_input, true);
+}
+
+inline bool
+glsl_type::is_integer_16() const
+{
+   return base_type == GLSL_TYPE_UINT16 || base_type == GLSL_TYPE_INT16;
+}
+
+inline bool
+glsl_type::is_integer_32() const
+{
+   return (base_type == GLSL_TYPE_UINT) || (base_type == GLSL_TYPE_INT);
+}
+
+inline bool
+glsl_type::is_integer_64() const
+{
+   return base_type == GLSL_TYPE_UINT64 || base_type == GLSL_TYPE_INT64;
+}
+
+inline bool
+glsl_type::is_integer_32_64() const
+{
+   return is_integer_32() || is_integer_64();
+}
+
+inline bool
+glsl_type::is_integer_16_32() const
+{
+   return is_integer_16() || is_integer_32();
+}
+
+inline bool
+glsl_type::is_integer_16_32_64() const
+{
+   return is_integer_16() || is_integer_32() || is_integer_64();
+}
+
+inline bool
+glsl_type::is_float() const
+{
+   return base_type == GLSL_TYPE_FLOAT;
+}
+
+inline bool
+glsl_type::is_float_16_32() const
+{
+   return base_type == GLSL_TYPE_FLOAT16 || is_float();
+}
+
+inline bool
+glsl_type::is_float_16_32_64() const
+{
+   return base_type == GLSL_TYPE_FLOAT16 || is_float() || is_double();
+}
+
+inline bool
+glsl_type::is_float_32_64() const
+{
+   return is_float() || is_double();
+}
+
+inline bool
+glsl_type::is_int_16_32_64() const
+{
+   return base_type == GLSL_TYPE_INT16 ||
+          base_type == GLSL_TYPE_INT ||
+          base_type == GLSL_TYPE_INT64;
+}
+
+inline bool
+glsl_type::is_uint_16_32_64() const
+{
+   return base_type == GLSL_TYPE_UINT16 ||
+          base_type == GLSL_TYPE_UINT ||
+          base_type == GLSL_TYPE_UINT64;
+}
+
+inline bool
+glsl_type::is_int_16_32() const
+{
+   return base_type == GLSL_TYPE_INT ||
+          base_type == GLSL_TYPE_INT16;
+}
+
+inline bool
+glsl_type::is_uint_16_32() const
+{
+   return base_type == GLSL_TYPE_UINT ||
+          base_type == GLSL_TYPE_UINT16;
+}
+
+inline bool
+glsl_type::is_anonymous() const
+{
+   return !strncmp(glsl_get_type_name(this), "#anon", 5);
+}
+
+inline const glsl_type *
+glsl_type::without_array() const
+{
+   const glsl_type *t = this;
+
+   while (t->is_array())
+      t = t->fields.array;
+
+   return t;
+}
+
+inline unsigned
+glsl_type::arrays_of_arrays_size() const
+{
+   if (!is_array())
+      return 0;
+
+   unsigned size = length;
+   const glsl_type *array_base_type = fields.array;
+
+   while (array_base_type->is_array()) {
+      size = size * array_base_type->length;
+      array_base_type = array_base_type->fields.array;
+   }
+   return size;
+}
+
+inline unsigned
+glsl_type::bit_size() const
+{
+   return glsl_base_type_bit_size(this->base_type);
+}
+
+inline unsigned
+glsl_type::atomic_size() const
+{
+   if (is_atomic_uint())
+      return 4; /* ATOMIC_COUNTER_SIZE */
+   else if (is_array())
+      return length * fields.array->atomic_size();
+   else
+      return 0;
+}
+
+inline bool
+glsl_type::contains_atomic() const
+{
+   return atomic_size() > 0;
+}
+
+inline const glsl_type *
+glsl_type::row_type() const
+{
+   if (!is_matrix())
+      return error_type;
+
+   if (explicit_stride && !interface_row_major)
+      return get_instance(base_type, matrix_columns, 1, explicit_stride);
+   else
+      return get_instance(base_type, matrix_columns, 1);
+}
+
+inline const glsl_type *
+glsl_type::column_type() const
+{
+   if (!is_matrix())
+      return error_type;
+
+   if (interface_row_major) {
+      /* If we're row-major, the vector element stride is the same as the
+       * matrix stride and we have no alignment (i.e. component-aligned).
+       */
+      return get_instance(base_type, vector_elements, 1,
+                          explicit_stride, false, 0);
+   } else {
+      /* Otherwise, the vector is tightly packed (stride=0).  For
+       * alignment, we treat a matrix as an array of columns make the same
+       * assumption that the alignment of the column is the same as the
+       * alignment of the whole matrix.
+       */
+      return get_instance(base_type, vector_elements, 1,
+                          0, false, explicit_alignment);
+   }
+}
+
+inline int
+glsl_type::array_size() const
+{
+   return is_array() ? length : -1;
+}
+
+inline bool
+glsl_type::is_unsized_array() const
+{
+   return is_array() && length == 0;
+}
+
+inline enum glsl_interface_packing
+glsl_type::get_interface_packing() const
+{
+   return (enum glsl_interface_packing)interface_packing;
+}
+
+inline enum glsl_interface_packing
+glsl_type::get_internal_ifc_packing(bool std430_supported) const
+{
+   enum glsl_interface_packing packing = this->get_interface_packing();
+   if (packing == GLSL_INTERFACE_PACKING_STD140 ||
+       (!std430_supported &&
+        (packing == GLSL_INTERFACE_PACKING_SHARED ||
+         packing == GLSL_INTERFACE_PACKING_PACKED))) {
+      return GLSL_INTERFACE_PACKING_STD140;
+   } else {
+      assert(packing == GLSL_INTERFACE_PACKING_STD430 ||
+             (std430_supported &&
+              (packing == GLSL_INTERFACE_PACKING_SHARED ||
+               packing == GLSL_INTERFACE_PACKING_PACKED)));
+      return GLSL_INTERFACE_PACKING_STD430;
+   }
+}
+
+inline bool
+glsl_type::get_interface_row_major() const
+{
+   return (bool) interface_row_major;
+}
+
+#endif /* __cplusplus */
+
+#endif /* GLSL_TYPES_H */
diff --git a/src/compiler/meson.build b/src/compiler/meson.build
index 4dfe21b0dabd..1d8a6d5b17ed 100644
--- a/src/compiler/meson.build
+++ b/src/compiler/meson.build
@@ -51,6 +51,7 @@ float64_glsl_file = files('glsl/float64.glsl')
 files_libcompiler = files(
   'glsl_types.cpp',
   'glsl_types.h',
+  'glsl_types_impl.h',
   'nir_types.cpp',
   'nir_types.h',
   'shader_enums.c',
-- 
GitLab


From df487dd989f728ce5bc6a0c94e219d77126dd22c Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Fri, 29 Sep 2023 11:09:55 -0700
Subject: [PATCH 2/7] compiler/types: Move C declarations into glsl_types.h

This ensures they'll be visible for the C++ inline implementations.
Reordered the functions to better organize them: queries, getters,
transformers, layout functions.
---
 src/compiler/glsl_types.h | 193 +++++++++++++++++++++++++++++++
 src/compiler/nir_types.h  | 231 --------------------------------------
 2 files changed, 193 insertions(+), 231 deletions(-)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 2bb445444173..f292b0df07e7 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1154,6 +1154,199 @@ struct glsl_struct_field {
 #endif
 };
 
+enum glsl_base_type glsl_get_base_type(const struct glsl_type *t);
+
+static inline unsigned
+glsl_get_bit_size(const struct glsl_type *t)
+{
+   return glsl_base_type_get_bit_size(glsl_get_base_type(t));
+}
+
+bool glsl_type_is_boolean(const struct glsl_type *t);
+bool glsl_type_is_sampler(const struct glsl_type *t);
+bool glsl_type_is_texture(const struct glsl_type *t);
+bool glsl_type_is_image(const struct glsl_type *t);
+bool glsl_type_is_atomic_uint(const struct glsl_type *t);
+bool glsl_type_is_struct(const struct glsl_type *t);
+bool glsl_type_is_interface(const struct glsl_type *t);
+bool glsl_type_is_array(const struct glsl_type *t);
+bool glsl_type_is_cmat(const struct glsl_type *t);
+bool glsl_type_is_void(const struct glsl_type *t);
+bool glsl_type_is_subroutine(const struct glsl_type *t);
+bool glsl_type_is_error(const struct glsl_type *t);
+
+bool glsl_type_is_struct_or_ifc(const struct glsl_type *t);
+bool glsl_type_is_packed(const struct glsl_type *t);
+bool glsl_type_is_16bit(const struct glsl_type *t);
+bool glsl_type_is_32bit(const struct glsl_type *t);
+bool glsl_type_is_64bit(const struct glsl_type *t);
+
+bool glsl_type_is_unsized_array(const struct glsl_type *t);
+bool glsl_type_is_numeric(const struct glsl_type *t);
+bool glsl_type_is_integer(const struct glsl_type *t);
+bool glsl_type_is_double(const struct glsl_type *t);
+bool glsl_type_is_array_of_arrays(const struct glsl_type *t);
+bool glsl_type_is_bare_sampler(const struct glsl_type *t);
+bool glsl_type_is_vector(const struct glsl_type *t);
+bool glsl_type_is_scalar(const struct glsl_type *t);
+bool glsl_type_is_vector_or_scalar(const struct glsl_type *t);
+bool glsl_type_is_matrix(const struct glsl_type *t);
+bool glsl_type_is_array_or_matrix(const struct glsl_type *t);
+bool glsl_type_is_dual_slot(const struct glsl_type *t);
+bool glsl_type_is_leaf(const struct glsl_type *type);
+
+bool glsl_matrix_type_is_row_major(const struct glsl_type *t);
+bool glsl_sampler_type_is_shadow(const struct glsl_type *t);
+bool glsl_sampler_type_is_array(const struct glsl_type *t);
+bool glsl_struct_type_is_packed(const struct glsl_type *t);
+
+const struct glsl_type *glsl_get_bare_type(const struct glsl_type *t);
+
+unsigned glsl_get_length(const struct glsl_type *t);
+unsigned glsl_get_vector_elements(const struct glsl_type *t);
+unsigned glsl_get_components(const struct glsl_type *t);
+unsigned glsl_get_matrix_columns(const struct glsl_type *t);
+
+int glsl_array_size(const struct glsl_type *t);
+unsigned glsl_get_aoa_size(const struct glsl_type *t);
+const struct glsl_type *glsl_get_array_element(const struct glsl_type *t);
+const struct glsl_type *glsl_without_array(const struct glsl_type *t);
+const struct glsl_type *glsl_without_array_or_matrix(const struct glsl_type *t);
+const struct glsl_type *glsl_type_wrap_in_arrays(const struct glsl_type *t,
+                                                 const struct glsl_type *arrays);
+
+const struct glsl_type *glsl_get_cmat_element(const struct glsl_type *t);
+const struct glsl_cmat_description *glsl_get_cmat_description(const struct glsl_type *t);
+
+unsigned glsl_atomic_size(const struct glsl_type *type);
+
+bool glsl_type_contains_64bit(const struct glsl_type *t);
+bool glsl_type_contains_image(const struct glsl_type *t);
+bool glsl_contains_atomic(const struct glsl_type *t);
+bool glsl_contains_double(const struct glsl_type *t);
+bool glsl_contains_integer(const struct glsl_type *t);
+bool glsl_contains_opaque(const struct glsl_type *t);
+
+enum glsl_sampler_dim glsl_get_sampler_dim(const struct glsl_type *t);
+enum glsl_base_type glsl_get_sampler_result_type(const struct glsl_type *t);
+int glsl_get_sampler_coordinate_components(const struct glsl_type *t);
+
+bool glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b,
+                         bool match_name, bool match_locations,
+                         bool match_precision);
+
+const struct glsl_type *glsl_get_struct_field(const struct glsl_type *t, unsigned index);
+const struct glsl_struct_field *glsl_get_struct_field_data(const struct glsl_type *t, unsigned index);
+unsigned glsl_get_struct_location_offset(const struct glsl_type *t, unsigned length);
+int glsl_get_field_index(const struct glsl_type *t, const char *name);
+int glsl_get_struct_field_offset(const struct glsl_type *t, unsigned index);
+const char *glsl_get_struct_elem_name(const struct glsl_type *t, unsigned index);
+
+const struct glsl_type *glsl_void_type(void);
+const struct glsl_type *glsl_float_type(void);
+const struct glsl_type *glsl_float16_t_type(void);
+const struct glsl_type *glsl_double_type(void);
+const struct glsl_type *glsl_vec4_type(void);
+const struct glsl_type *glsl_uvec4_type(void);
+const struct glsl_type *glsl_ivec4_type(void);
+const struct glsl_type *glsl_int_type(void);
+const struct glsl_type *glsl_uint_type(void);
+const struct glsl_type *glsl_int64_t_type(void);
+const struct glsl_type *glsl_uint64_t_type(void);
+const struct glsl_type *glsl_int16_t_type(void);
+const struct glsl_type *glsl_uint16_t_type(void);
+const struct glsl_type *glsl_int8_t_type(void);
+const struct glsl_type *glsl_uint8_t_type(void);
+const struct glsl_type *glsl_bool_type(void);
+const struct glsl_type *glsl_atomic_uint_type(void);
+
+const struct glsl_type *glsl_floatN_t_type(unsigned bit_size);
+const struct glsl_type *glsl_intN_t_type(unsigned bit_size);
+const struct glsl_type *glsl_uintN_t_type(unsigned bit_size);
+
+const struct glsl_type *glsl_vec_type(unsigned components);
+const struct glsl_type *glsl_dvec_type(unsigned components);
+
+const struct glsl_type *glsl_sampler_type(enum glsl_sampler_dim dim,
+                                          bool shadow,
+                                          bool array,
+                                          enum glsl_base_type type);
+const struct glsl_type *glsl_bare_sampler_type(void);
+const struct glsl_type *glsl_bare_shadow_sampler_type(void);
+const struct glsl_type *glsl_texture_type(enum glsl_sampler_dim dim,
+                                          bool array,
+                                          enum glsl_base_type type);
+const struct glsl_type *glsl_image_type(enum glsl_sampler_dim dim,
+                                        bool array, enum glsl_base_type type);
+const struct glsl_type *glsl_array_type(const struct glsl_type *element,
+                                        unsigned array_size,
+                                        unsigned explicit_stride);
+const struct glsl_type *glsl_cmat_type(const struct glsl_cmat_description *desc);
+const struct glsl_type *glsl_struct_type(
+   const struct glsl_struct_field *fields, unsigned num_fields, const char *name, bool packed);
+const struct glsl_type *glsl_interface_type(const struct glsl_struct_field *fields,
+                                            unsigned num_fields,
+                                            enum glsl_interface_packing packing,
+                                            bool row_major,
+                                            const char *block_name);
+const struct glsl_type *glsl_subroutine_type(const char *subroutine_name);
+
+const struct glsl_type *glsl_get_row_type(const struct glsl_type *t);
+const struct glsl_type *glsl_get_column_type(const struct glsl_type *t);
+const struct glsl_type *glsl_get_explicit_type_for_size_align(const struct glsl_type *type,
+                                                              glsl_type_size_align_func type_info,
+                                                              unsigned *size, unsigned *align);
+const struct glsl_type *glsl_type_replace_vec3_with_vec4(const struct glsl_type *type);
+
+const struct glsl_type *glsl_float16_type(const struct glsl_type *t);
+const struct glsl_type *glsl_int16_type(const struct glsl_type *t);
+const struct glsl_type *glsl_uint16_type(const struct glsl_type *t);
+const struct glsl_type *glsl_type_to_16bit(const struct glsl_type *old_type);
+
+const struct glsl_type *glsl_scalar_type(enum glsl_base_type base_type);
+const struct glsl_type *glsl_vector_type(enum glsl_base_type base_type, unsigned components);
+const struct glsl_type *glsl_matrix_type(enum glsl_base_type base_type,
+                                         unsigned rows, unsigned columns);
+const struct glsl_type *glsl_explicit_matrix_type(const struct glsl_type *mat,
+                                                  unsigned stride,
+                                                  bool row_major);
+
+const struct glsl_type *glsl_transposed_type(const struct glsl_type *t);
+const struct glsl_type *glsl_texture_type_to_sampler(const struct glsl_type *t, bool is_shadow);
+const struct glsl_type *glsl_sampler_type_to_texture(const struct glsl_type *t);
+const struct glsl_type *glsl_replace_vector_type(const struct glsl_type *t, unsigned components);
+const struct glsl_type *glsl_channel_type(const struct glsl_type *t);
+
+unsigned glsl_type_get_sampler_count(const struct glsl_type *t);
+unsigned glsl_type_get_texture_count(const struct glsl_type *t);
+unsigned glsl_type_get_image_count(const struct glsl_type *t);
+
+unsigned glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool is_bindless);
+unsigned glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless);
+unsigned glsl_get_component_slots(const struct glsl_type *t);
+unsigned glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset);
+unsigned glsl_varying_count(const struct glsl_type *t);
+unsigned glsl_count_attribute_slots(const struct glsl_type *t, bool is_gl_vertex_input);
+
+int glsl_get_cl_size(const struct glsl_type *t);
+int glsl_get_cl_alignment(const struct glsl_type *t);
+void glsl_get_cl_type_size_align(const struct glsl_type *t,
+                                 unsigned *size, unsigned *align);
+
+enum glsl_interface_packing glsl_get_internal_ifc_packing(const struct glsl_type *t, bool std430_supported);
+enum glsl_interface_packing glsl_get_ifc_packing(const struct glsl_type *t);
+
+unsigned glsl_get_std140_base_alignment(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std140_size(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std430_base_alignment(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std430_size(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_explicit_size(const struct glsl_type *t, bool align_to_stride);
+unsigned glsl_get_explicit_stride(const struct glsl_type *t);
+unsigned glsl_get_explicit_alignment(const struct glsl_type *t);
+
+void glsl_get_natural_size_align_bytes(const struct glsl_type *t, unsigned *size, unsigned *align);
+void glsl_get_vec4_size_align_bytes(const struct glsl_type *type, unsigned *size, unsigned *align);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
diff --git a/src/compiler/nir_types.h b/src/compiler/nir_types.h
index ff6172a1cb4b..7886d734c944 100644
--- a/src/compiler/nir_types.h
+++ b/src/compiler/nir_types.h
@@ -31,237 +31,6 @@
 #include <stdio.h>
 #include <stdbool.h>
 
-/* C wrapper around compiler/glsl_types.h */
-
 #include "glsl_types.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-const struct glsl_type *glsl_get_struct_field(const struct glsl_type *type,
-                                              unsigned index);
-
-int glsl_get_struct_field_offset(const struct glsl_type *type,
-                                 unsigned index);
-
-const struct glsl_struct_field *
-glsl_get_struct_field_data(const struct glsl_type *type, unsigned index);
-
-enum glsl_interface_packing
-glsl_get_internal_ifc_packing(const struct glsl_type *type,
-                              bool std430_supported);
-enum glsl_interface_packing
-glsl_get_ifc_packing(const struct glsl_type *type);
-
-unsigned glsl_get_std140_base_alignment(const struct glsl_type *type,
-                                        bool row_major);
-unsigned glsl_get_std140_size(const struct glsl_type *type, bool row_major);
-unsigned glsl_get_std430_base_alignment(const struct glsl_type *type,
-                                        bool row_major);
-unsigned glsl_get_std430_size(const struct glsl_type *type, bool row_major);
-unsigned glsl_get_explicit_stride(const struct glsl_type *type);
-int glsl_array_size(const struct glsl_type *type);
-const struct glsl_type *glsl_get_array_element(const struct glsl_type *type);
-const struct glsl_type *glsl_without_array(const struct glsl_type *type);
-const struct glsl_type *glsl_without_array_or_matrix(const struct glsl_type *type);
-const struct glsl_type *glsl_get_bare_type(const struct glsl_type *type);
-
-const struct glsl_type *glsl_get_column_type(const struct glsl_type *type);
-
-const struct glsl_type *
-glsl_texture_type_to_sampler(const struct glsl_type *type, bool is_shadow);
-const struct glsl_type *
-glsl_sampler_type_to_texture(const struct glsl_type *type);
-
-enum glsl_base_type glsl_get_base_type(const struct glsl_type *type);
-
-unsigned glsl_get_vector_elements(const struct glsl_type *type);
-
-unsigned glsl_get_components(const struct glsl_type *type);
-
-unsigned glsl_get_matrix_columns(const struct glsl_type *type);
-
-unsigned glsl_get_length(const struct glsl_type *type);
-
-unsigned glsl_get_aoa_size(const struct glsl_type *type);
-
-unsigned glsl_count_vec4_slots(const struct glsl_type *type,
-                               bool is_gl_vertex_input, bool is_bindless);
-unsigned glsl_count_dword_slots(const struct glsl_type *type, bool is_bindless);
-unsigned glsl_count_attribute_slots(const struct glsl_type *type,
-                                    bool is_gl_vertex_input);
-unsigned glsl_get_component_slots(const struct glsl_type *type);
-unsigned glsl_get_component_slots_aligned(const struct glsl_type *type,
-                                          unsigned offset);
-unsigned glsl_varying_count(const struct glsl_type *type);
-
-const char *glsl_get_struct_elem_name(const struct glsl_type *type,
-                                      unsigned index);
-
-enum glsl_sampler_dim glsl_get_sampler_dim(const struct glsl_type *type);
-enum glsl_base_type glsl_get_sampler_result_type(const struct glsl_type *type);
-unsigned glsl_get_sampler_target(const struct glsl_type *type);
-int glsl_get_sampler_coordinate_components(const struct glsl_type *type);
-
-unsigned glsl_get_struct_location_offset(const struct glsl_type *type,
-                                         unsigned length);
-
-unsigned glsl_atomic_size(const struct glsl_type *type);
-
-int glsl_get_cl_size(const struct glsl_type *type);
-
-int glsl_get_cl_alignment(const struct glsl_type *type);
-
-void glsl_get_cl_type_size_align(const struct glsl_type *type,
-                                 unsigned *size, unsigned *align);
-
-unsigned glsl_get_explicit_size(const struct glsl_type *type, bool align_to_stride);
-unsigned glsl_get_explicit_alignment(const struct glsl_type *type);
-
-static inline unsigned
-glsl_get_bit_size(const struct glsl_type *type)
-{
-   return glsl_base_type_get_bit_size(glsl_get_base_type(type));
-}
-
-bool glsl_type_is_packed(const struct glsl_type *type);
-bool glsl_type_is_16bit(const struct glsl_type *type);
-bool glsl_type_is_32bit(const struct glsl_type *type);
-bool glsl_type_is_64bit(const struct glsl_type *type);
-bool glsl_type_is_void(const struct glsl_type *type);
-bool glsl_type_is_error(const struct glsl_type *type);
-bool glsl_type_is_vector(const struct glsl_type *type);
-bool glsl_type_is_scalar(const struct glsl_type *type);
-bool glsl_type_is_vector_or_scalar(const struct glsl_type *type);
-bool glsl_type_is_matrix(const struct glsl_type *type);
-bool glsl_matrix_type_is_row_major(const struct glsl_type *type);
-bool glsl_type_is_array(const struct glsl_type *type);
-bool glsl_type_is_unsized_array(const struct glsl_type *type);
-bool glsl_type_is_array_of_arrays(const struct glsl_type *type);
-bool glsl_type_is_array_or_matrix(const struct glsl_type *type);
-bool glsl_type_is_cmat(const struct glsl_type *type);
-bool glsl_type_is_struct(const struct glsl_type *type);
-bool glsl_type_is_interface(const struct glsl_type *type);
-bool glsl_type_is_struct_or_ifc(const struct glsl_type *type);
-bool glsl_type_is_sampler(const struct glsl_type *type);
-bool glsl_type_is_bare_sampler(const struct glsl_type *type);
-bool glsl_type_is_texture(const struct glsl_type *type);
-bool glsl_type_is_image(const struct glsl_type *type);
-bool glsl_type_is_dual_slot(const struct glsl_type *type);
-bool glsl_type_is_numeric(const struct glsl_type *type);
-bool glsl_type_is_boolean(const struct glsl_type *type);
-bool glsl_type_is_integer(const struct glsl_type *type);
-bool glsl_type_contains_64bit(const struct glsl_type *type);
-bool glsl_type_contains_image(const struct glsl_type *type);
-bool glsl_sampler_type_is_shadow(const struct glsl_type *type);
-bool glsl_sampler_type_is_array(const struct glsl_type *type);
-bool glsl_struct_type_is_packed(const struct glsl_type *type);
-bool glsl_contains_atomic(const struct glsl_type *type);
-bool glsl_contains_double(const struct glsl_type *type);
-bool glsl_contains_integer(const struct glsl_type *type);
-bool glsl_contains_opaque(const struct glsl_type *type);
-bool glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b,
-                         bool match_name, bool match_locations,
-                         bool match_precision);
-
-const struct glsl_type *glsl_void_type(void);
-const struct glsl_type *glsl_float_type(void);
-const struct glsl_type *glsl_float16_t_type(void);
-const struct glsl_type *glsl_double_type(void);
-const struct glsl_type *glsl_floatN_t_type(unsigned bit_size);
-const struct glsl_type *glsl_vec_type(unsigned n);
-const struct glsl_type *glsl_dvec_type(unsigned n);
-const struct glsl_type *glsl_vec4_type(void);
-const struct glsl_type *glsl_uvec4_type(void);
-const struct glsl_type *glsl_ivec4_type(void);
-const struct glsl_type *glsl_int_type(void);
-const struct glsl_type *glsl_uint_type(void);
-const struct glsl_type *glsl_int64_t_type(void);
-const struct glsl_type *glsl_uint64_t_type(void);
-const struct glsl_type *glsl_int16_t_type(void);
-const struct glsl_type *glsl_uint16_t_type(void);
-const struct glsl_type *glsl_int8_t_type(void);
-const struct glsl_type *glsl_uint8_t_type(void);
-const struct glsl_type *glsl_intN_t_type(unsigned bit_size);
-const struct glsl_type *glsl_uintN_t_type(unsigned bit_size);
-const struct glsl_type *glsl_bool_type(void);
-
-const struct glsl_type *glsl_scalar_type(enum glsl_base_type base_type);
-const struct glsl_type *glsl_vector_type(enum glsl_base_type base_type,
-                                         unsigned components);
-const struct glsl_type * glsl_replace_vector_type(const struct glsl_type *t,
-                                                  unsigned components);
-const struct glsl_type *glsl_matrix_type(enum glsl_base_type base_type,
-                                         unsigned rows, unsigned columns);
-const struct glsl_type *glsl_explicit_matrix_type(const struct glsl_type *mat,
-                                                  unsigned stride,
-                                                  bool row_major);
-
-const struct glsl_type *glsl_array_type(const struct glsl_type *element,
-                                        unsigned array_size,
-                                        unsigned explicit_stride);
-
-const struct glsl_type *glsl_cmat_type(const struct glsl_cmat_description *desc);
-
-const struct glsl_type *glsl_struct_type(const struct glsl_struct_field *fields,
-                                         unsigned num_fields, const char *name,
-                                         bool packed);
-const struct glsl_type *glsl_interface_type(const struct glsl_struct_field *fields,
-                                            unsigned num_fields,
-                                            enum glsl_interface_packing packing,
-                                            bool row_major,
-                                            const char *block_name);
-const struct glsl_type *glsl_sampler_type(enum glsl_sampler_dim dim,
-                                          bool is_shadow, bool is_array,
-                                          enum glsl_base_type base_type);
-const struct glsl_type *glsl_bare_sampler_type();
-const struct glsl_type *glsl_bare_shadow_sampler_type();
-const struct glsl_type *glsl_texture_type(enum glsl_sampler_dim dim,
-                                          bool is_array,
-                                          enum glsl_base_type base_type);
-const struct glsl_type *glsl_image_type(enum glsl_sampler_dim dim,
-                                        bool is_array,
-                                        enum glsl_base_type base_type);
-
-const struct glsl_type *glsl_transposed_type(const struct glsl_type *type);
-
-const struct glsl_type *glsl_channel_type(const struct glsl_type *type);
-
-const struct glsl_type *glsl_float16_type(const struct glsl_type *type);
-const struct glsl_type *glsl_int16_type(const struct glsl_type *type);
-const struct glsl_type *glsl_uint16_type(const struct glsl_type *type);
-const struct glsl_type *glsl_type_to_16bit(const struct glsl_type *old_type);
-
-void glsl_get_natural_size_align_bytes(const struct glsl_type *type,
-                                       unsigned *size, unsigned *align);
-void glsl_get_vec4_size_align_bytes(const struct glsl_type *type,
-                                    unsigned *size, unsigned *align);
-
-const struct glsl_type *glsl_atomic_uint_type(void);
-
-const struct glsl_type *glsl_get_explicit_type_for_size_align(const struct glsl_type *type,
-                                                              glsl_type_size_align_func type_info,
-                                                              unsigned *size, unsigned *align);
-
-const struct glsl_type *glsl_type_wrap_in_arrays(const struct glsl_type *type,
-                                                 const struct glsl_type *arrays);
-
-const struct glsl_type *glsl_type_replace_vec3_with_vec4(const struct glsl_type *type);
-
-unsigned glsl_type_get_sampler_count(const struct glsl_type *type);
-unsigned glsl_type_get_texture_count(const struct glsl_type *type);
-unsigned glsl_type_get_image_count(const struct glsl_type *type);
-
-int glsl_get_field_index(const struct glsl_type *type, const char *name);
-
-bool glsl_type_is_leaf(const struct glsl_type *type);
-
-const struct glsl_type *glsl_get_cmat_element(const struct glsl_type *type);
-const struct glsl_cmat_description *glsl_get_cmat_description(const struct glsl_type *type);
-
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* NIR_TYPES_H */
-- 
GitLab


From f8eb7b8aa0f06ded9634dcad95a344cab0beb899 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Fri, 1 Sep 2023 22:35:26 -0700
Subject: [PATCH 3/7] compiler/types: Flip wrapping of base_type checks

---
 src/compiler/glsl_types.h      | 33 +++++++++--------
 src/compiler/glsl_types_impl.h | 25 +++++++------
 src/compiler/nir_types.cpp     | 65 ----------------------------------
 3 files changed, 31 insertions(+), 92 deletions(-)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index f292b0df07e7..da91a449755f 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1162,20 +1162,25 @@ glsl_get_bit_size(const struct glsl_type *t)
    return glsl_base_type_get_bit_size(glsl_get_base_type(t));
 }
 
-bool glsl_type_is_boolean(const struct glsl_type *t);
-bool glsl_type_is_sampler(const struct glsl_type *t);
-bool glsl_type_is_texture(const struct glsl_type *t);
-bool glsl_type_is_image(const struct glsl_type *t);
-bool glsl_type_is_atomic_uint(const struct glsl_type *t);
-bool glsl_type_is_struct(const struct glsl_type *t);
-bool glsl_type_is_interface(const struct glsl_type *t);
-bool glsl_type_is_array(const struct glsl_type *t);
-bool glsl_type_is_cmat(const struct glsl_type *t);
-bool glsl_type_is_void(const struct glsl_type *t);
-bool glsl_type_is_subroutine(const struct glsl_type *t);
-bool glsl_type_is_error(const struct glsl_type *t);
-
-bool glsl_type_is_struct_or_ifc(const struct glsl_type *t);
+static inline bool glsl_type_is_boolean(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_BOOL; }
+static inline bool glsl_type_is_sampler(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_SAMPLER; }
+static inline bool glsl_type_is_texture(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_TEXTURE; }
+static inline bool glsl_type_is_image(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_IMAGE; }
+static inline bool glsl_type_is_atomic_uint(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ATOMIC_UINT; }
+static inline bool glsl_type_is_struct(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_STRUCT; }
+static inline bool glsl_type_is_interface(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_INTERFACE; }
+static inline bool glsl_type_is_array(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ARRAY; }
+static inline bool glsl_type_is_cmat(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_COOPERATIVE_MATRIX; }
+static inline bool glsl_type_is_void(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_VOID; }
+static inline bool glsl_type_is_subroutine(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_SUBROUTINE; }
+static inline bool glsl_type_is_error(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ERROR; }
+
+static inline bool
+glsl_type_is_struct_or_ifc(const struct glsl_type *t)
+{
+   return glsl_type_is_struct(t) || glsl_type_is_interface(t);
+}
+
 bool glsl_type_is_packed(const struct glsl_type *t);
 bool glsl_type_is_16bit(const struct glsl_type *t);
 bool glsl_type_is_32bit(const struct glsl_type *t);
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
index bf4a4290f297..b2ccac7f1b3a 100644
--- a/src/compiler/glsl_types_impl.h
+++ b/src/compiler/glsl_types_impl.h
@@ -12,19 +12,18 @@
 #include "compiler/builtin_types_cpp.h"
 #undef BUILTIN_TYPES_CPP_DEFINITIONS
 
-inline bool glsl_type::is_boolean() const { return base_type == GLSL_TYPE_BOOL; }
-inline bool glsl_type::is_sampler() const { return base_type == GLSL_TYPE_SAMPLER; }
-inline bool glsl_type::is_texture() const { return base_type == GLSL_TYPE_TEXTURE; }
-inline bool glsl_type::is_image() const { return base_type == GLSL_TYPE_IMAGE; }
-inline bool glsl_type::is_array() const { return base_type == GLSL_TYPE_ARRAY; }
-inline bool glsl_type::is_struct() const { return base_type == GLSL_TYPE_STRUCT; }
-inline bool glsl_type::is_interface() const { return base_type == GLSL_TYPE_INTERFACE; }
-inline bool glsl_type::is_cmat() const { return base_type == GLSL_TYPE_COOPERATIVE_MATRIX; }
-inline bool glsl_type::is_void() const { return base_type == GLSL_TYPE_VOID; }
-inline bool glsl_type::is_error() const { return base_type == GLSL_TYPE_ERROR; }
-inline bool glsl_type::is_subroutine() const { return base_type == GLSL_TYPE_SUBROUTINE; }
-inline bool glsl_type::is_atomic_uint() const { return base_type == GLSL_TYPE_ATOMIC_UINT; }
-
+inline bool glsl_type::is_boolean() const { return glsl_type_is_boolean(this); }
+inline bool glsl_type::is_sampler() const { return glsl_type_is_sampler(this); }
+inline bool glsl_type::is_texture() const { return glsl_type_is_texture(this); }
+inline bool glsl_type::is_image() const { return glsl_type_is_image(this); }
+inline bool glsl_type::is_array() const { return glsl_type_is_array(this); }
+inline bool glsl_type::is_struct() const { return glsl_type_is_struct(this); }
+inline bool glsl_type::is_interface() const { return glsl_type_is_interface(this); }
+inline bool glsl_type::is_cmat() const { return glsl_type_is_cmat(this); }
+inline bool glsl_type::is_void() const { return glsl_type_is_void(this); }
+inline bool glsl_type::is_error() const { return glsl_type_is_error(this); }
+inline bool glsl_type::is_subroutine() const { return glsl_type_is_subroutine(this); }
+inline bool glsl_type::is_atomic_uint() const { return glsl_type_is_atomic_uint(this); }
 
 inline bool
 glsl_type::is_scalar() const
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
index 59064c46fdc1..1c603e695452 100644
--- a/src/compiler/nir_types.cpp
+++ b/src/compiler/nir_types.cpp
@@ -268,18 +268,6 @@ glsl_type_is_64bit(const struct glsl_type *type)
    return type->is_64bit();
 }
 
-bool
-glsl_type_is_void(const struct glsl_type *type)
-{
-   return type->is_void();
-}
-
-bool
-glsl_type_is_error(const struct glsl_type *type)
-{
-   return type->is_error();
-}
-
 bool
 glsl_type_is_vector(const struct glsl_type *type)
 {
@@ -311,12 +299,6 @@ glsl_matrix_type_is_row_major(const struct glsl_type *type)
    return type->interface_row_major;
 }
 
-bool
-glsl_type_is_array(const struct glsl_type *type)
-{
-   return type->is_array();
-}
-
 bool
 glsl_type_is_unsized_array(const struct glsl_type *type)
 {
@@ -335,54 +317,12 @@ glsl_type_is_array_or_matrix(const struct glsl_type *type)
    return type->is_array() || type->is_matrix();
 }
 
-bool
-glsl_type_is_cmat(const struct glsl_type *type)
-{
-   return type->is_cmat();
-}
-
-bool
-glsl_type_is_struct(const struct glsl_type *type)
-{
-   return type->is_struct();
-}
-
-bool
-glsl_type_is_interface(const struct glsl_type *type)
-{
-   return type->is_interface();
-}
-
-bool
-glsl_type_is_struct_or_ifc(const struct glsl_type *type)
-{
-   return type->is_struct() || type->is_interface();
-}
-
-bool
-glsl_type_is_sampler(const struct glsl_type *type)
-{
-   return type->is_sampler();
-}
-
 bool
 glsl_type_is_bare_sampler(const struct glsl_type *type)
 {
    return type->is_sampler() && type->sampled_type == GLSL_TYPE_VOID;
 }
 
-bool
-glsl_type_is_texture(const struct glsl_type *type)
-{
-   return type->is_texture();
-}
-
-bool
-glsl_type_is_image(const struct glsl_type *type)
-{
-   return type->is_image();
-}
-
 bool
 glsl_sampler_type_is_shadow(const struct glsl_type *type)
 {
@@ -418,11 +358,6 @@ glsl_type_is_numeric(const struct glsl_type *type)
    return type->is_numeric();
 }
 
-bool
-glsl_type_is_boolean(const struct glsl_type *type)
-{
-   return type->is_boolean();
-}
 bool
 glsl_type_is_integer(const struct glsl_type *type)
 {
-- 
GitLab


From 38b85a0cfee9302eb4d5f14bf6aa8ada4dbf6117 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Fri, 1 Sep 2023 23:49:26 -0700
Subject: [PATCH 4/7] compiler/types: Flip wrapping of various type
 identification checks

---
 src/compiler/glsl_types.cpp    |  67 +++++++++++++++
 src/compiler/glsl_types.h      | 102 +++++++++++++++++++----
 src/compiler/glsl_types_impl.h |  84 +++----------------
 src/compiler/nir_types.cpp     | 143 ---------------------------------
 4 files changed, 167 insertions(+), 229 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 7e6eccd611d4..4c72b2e9c021 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -3364,4 +3364,71 @@ glsl_get_sampler_dim_coordinate_components(enum glsl_sampler_dim dim)
    }
 }
 
+bool
+glsl_type_is_vector(const struct glsl_type *t)
+{
+   return t->vector_elements > 1 &&
+          t->matrix_columns == 1 &&
+          t->base_type >= GLSL_TYPE_UINT &&
+          t->base_type <= GLSL_TYPE_BOOL;
+}
+
+bool
+glsl_type_is_scalar(const struct glsl_type *t)
+{
+   return t->vector_elements == 1 &&
+          t->base_type >= GLSL_TYPE_UINT &&
+          t->base_type <= GLSL_TYPE_IMAGE;
+}
+
+bool
+glsl_type_is_vector_or_scalar(const struct glsl_type *t)
+{
+   return glsl_type_is_vector(t) || glsl_type_is_scalar(t);
+}
+
+bool
+glsl_type_is_matrix(const struct glsl_type *t)
+{
+   /* GLSL only has float matrices. */
+   return t->matrix_columns > 1 && (t->base_type == GLSL_TYPE_FLOAT ||
+                                    t->base_type == GLSL_TYPE_DOUBLE ||
+                                    t->base_type == GLSL_TYPE_FLOAT16);
+}
+
+bool
+glsl_type_is_array_or_matrix(const struct glsl_type *t)
+{
+   return glsl_type_is_array(t) || glsl_type_is_matrix(t);
+}
+
+bool
+glsl_type_is_dual_slot(const struct glsl_type *t)
+{
+   return glsl_type_is_64bit(t) && t->vector_elements > 2;
+}
+
+const struct glsl_type *
+glsl_get_array_element(const struct glsl_type *t)
+{
+   if (glsl_type_is_matrix(t))
+      return t->column_type();
+   else if (glsl_type_is_vector(t))
+      return t->get_scalar_type();
+   return t->fields.array;
+}
+
+bool
+glsl_type_is_leaf(const struct glsl_type *t)
+{
+   if (glsl_type_is_struct_or_ifc(t) ||
+       (glsl_type_is_array(t) &&
+        (glsl_type_is_array(glsl_get_array_element(t)) ||
+         glsl_type_is_struct_or_ifc(glsl_get_array_element(t))))) {
+      return false;
+   } else {
+      return true;
+   }
+}
+
 }
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index da91a449755f..1ac247be3a4e 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1174,6 +1174,20 @@ static inline bool glsl_type_is_cmat(const struct glsl_type *t) { return t->base
 static inline bool glsl_type_is_void(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_VOID; }
 static inline bool glsl_type_is_subroutine(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_SUBROUTINE; }
 static inline bool glsl_type_is_error(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ERROR; }
+static inline bool glsl_type_is_double(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_DOUBLE; }
+
+static inline bool
+glsl_type_is_numeric(const struct glsl_type *t)
+{
+   return t->base_type >= GLSL_TYPE_UINT &&
+          t->base_type <= GLSL_TYPE_INT64;
+}
+
+static inline bool
+glsl_type_is_integer(const struct glsl_type *t)
+{
+   return glsl_base_type_is_integer(t->base_type);
+}
 
 static inline bool
 glsl_type_is_struct_or_ifc(const struct glsl_type *t)
@@ -1181,17 +1195,50 @@ glsl_type_is_struct_or_ifc(const struct glsl_type *t)
    return glsl_type_is_struct(t) || glsl_type_is_interface(t);
 }
 
-bool glsl_type_is_packed(const struct glsl_type *t);
-bool glsl_type_is_16bit(const struct glsl_type *t);
-bool glsl_type_is_32bit(const struct glsl_type *t);
-bool glsl_type_is_64bit(const struct glsl_type *t);
-
-bool glsl_type_is_unsized_array(const struct glsl_type *t);
-bool glsl_type_is_numeric(const struct glsl_type *t);
-bool glsl_type_is_integer(const struct glsl_type *t);
-bool glsl_type_is_double(const struct glsl_type *t);
-bool glsl_type_is_array_of_arrays(const struct glsl_type *t);
-bool glsl_type_is_bare_sampler(const struct glsl_type *t);
+static inline bool
+glsl_type_is_packed(const struct glsl_type *t)
+{
+   return t->packed;
+}
+
+static inline bool
+glsl_type_is_16bit(const struct glsl_type *t)
+{
+   return glsl_base_type_is_16bit(t->base_type);
+}
+
+static inline bool
+glsl_type_is_32bit(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_UINT ||
+          t->base_type == GLSL_TYPE_INT ||
+          t->base_type == GLSL_TYPE_FLOAT;
+}
+
+static inline bool
+glsl_type_is_64bit(const struct glsl_type *t)
+{
+   return glsl_base_type_is_64bit(t->base_type);
+}
+
+static inline bool
+glsl_type_is_unsized_array(const struct glsl_type *t)
+{
+   return glsl_type_is_array(t) && t->length == 0;
+}
+
+static inline bool
+glsl_type_is_array_of_arrays(const struct glsl_type *t)
+{
+   return glsl_type_is_array(t) && glsl_type_is_array(t->fields.array);
+}
+
+static inline bool
+glsl_type_is_bare_sampler(const struct glsl_type *t)
+{
+   return glsl_type_is_sampler(t) && t->sampled_type == GLSL_TYPE_VOID;
+}
+
 bool glsl_type_is_vector(const struct glsl_type *t);
 bool glsl_type_is_scalar(const struct glsl_type *t);
 bool glsl_type_is_vector_or_scalar(const struct glsl_type *t);
@@ -1200,10 +1247,35 @@ bool glsl_type_is_array_or_matrix(const struct glsl_type *t);
 bool glsl_type_is_dual_slot(const struct glsl_type *t);
 bool glsl_type_is_leaf(const struct glsl_type *type);
 
-bool glsl_matrix_type_is_row_major(const struct glsl_type *t);
-bool glsl_sampler_type_is_shadow(const struct glsl_type *t);
-bool glsl_sampler_type_is_array(const struct glsl_type *t);
-bool glsl_struct_type_is_packed(const struct glsl_type *t);
+static inline bool
+glsl_matrix_type_is_row_major(const struct glsl_type *t)
+{
+   assert((glsl_type_is_matrix(t) && t->explicit_stride) || glsl_type_is_interface(t));
+   return t->interface_row_major;
+}
+
+static inline bool
+glsl_sampler_type_is_shadow(const struct glsl_type *t)
+{
+   assert(glsl_type_is_sampler(t));
+   return t->sampler_shadow;
+}
+
+static inline bool
+glsl_sampler_type_is_array(const struct glsl_type *t)
+{
+   assert(glsl_type_is_sampler(t) ||
+          glsl_type_is_texture(t) ||
+          glsl_type_is_image(t));
+   return t->sampler_array;
+}
+
+static inline bool
+glsl_struct_type_is_packed(const struct glsl_type *t)
+{
+   assert(glsl_type_is_struct(t));
+   return t->packed;
+}
 
 const struct glsl_type *glsl_get_bare_type(const struct glsl_type *t);
 
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
index b2ccac7f1b3a..d5e9033a3879 100644
--- a/src/compiler/glsl_types_impl.h
+++ b/src/compiler/glsl_types_impl.h
@@ -25,72 +25,18 @@ inline bool glsl_type::is_error() const { return glsl_type_is_error(this); }
 inline bool glsl_type::is_subroutine() const { return glsl_type_is_subroutine(this); }
 inline bool glsl_type::is_atomic_uint() const { return glsl_type_is_atomic_uint(this); }
 
-inline bool
-glsl_type::is_scalar() const
-{
-   return (vector_elements == 1)
-          && (base_type >= GLSL_TYPE_UINT)
-          && (base_type <= GLSL_TYPE_IMAGE);
-}
-
-inline bool
-glsl_type::is_vector() const
-{
-   return (vector_elements > 1)
-          && (matrix_columns == 1)
-          && (base_type >= GLSL_TYPE_UINT)
-          && (base_type <= GLSL_TYPE_BOOL);
-}
-
-inline bool
-glsl_type::is_matrix() const
-{
-   /* GLSL only has float matrices. */
-   return (matrix_columns > 1) && (base_type == GLSL_TYPE_FLOAT ||
-                                   base_type == GLSL_TYPE_DOUBLE ||
-                                   base_type == GLSL_TYPE_FLOAT16);
-}
-
-inline bool
-glsl_type::is_numeric() const
-{
-   return (base_type >= GLSL_TYPE_UINT) && (base_type <= GLSL_TYPE_INT64);
-}
-
-inline bool glsl_type::is_integer() const { return glsl_base_type_is_integer(base_type); }
-inline bool glsl_type::is_double() const { return base_type == GLSL_TYPE_DOUBLE; }
-
-inline bool
-glsl_type::is_array_of_arrays() const
-{
-   return is_array() && fields.array->is_array();
-}
-
-inline bool
-glsl_type::is_dual_slot() const
-{
-   return is_64bit() && vector_elements > 2;
-}
-
-inline bool
-glsl_type::is_64bit() const
-{
-   return glsl_base_type_is_64bit(base_type);
-}
-
-inline bool
-glsl_type::is_16bit() const
-{
-   return glsl_base_type_is_16bit(base_type);
-}
-
-inline bool
-glsl_type::is_32bit() const
-{
-   return base_type == GLSL_TYPE_UINT ||
-          base_type == GLSL_TYPE_INT ||
-          base_type == GLSL_TYPE_FLOAT;
-}
+inline bool glsl_type::is_scalar() const { return glsl_type_is_scalar(this); }
+inline bool glsl_type::is_vector() const { return glsl_type_is_vector(this); }
+inline bool glsl_type::is_matrix() const { return glsl_type_is_matrix(this); }
+inline bool glsl_type::is_numeric() const { return glsl_type_is_numeric(this); }
+inline bool glsl_type::is_integer() const { return glsl_type_is_integer(this); }
+inline bool glsl_type::is_double() const { return glsl_type_is_double(this); }
+
+inline bool glsl_type::is_array_of_arrays() const { return glsl_type_is_array_of_arrays(this); }
+inline bool glsl_type::is_dual_slot() const { return glsl_type_is_dual_slot(this); }
+inline bool glsl_type::is_16bit() const { return glsl_type_is_16bit(this); }
+inline bool glsl_type::is_32bit() const { return glsl_type_is_32bit(this); }
+inline bool glsl_type::is_64bit() const { return glsl_type_is_64bit(this); }
 
 inline unsigned
 glsl_type::components() const
@@ -291,11 +237,7 @@ glsl_type::array_size() const
    return is_array() ? length : -1;
 }
 
-inline bool
-glsl_type::is_unsized_array() const
-{
-   return is_array() && length == 0;
-}
+inline bool glsl_type::is_unsized_array() const { return glsl_type_is_unsized_array(this); }
 
 inline enum glsl_interface_packing
 glsl_type::get_interface_packing() const
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
index 1c603e695452..296c398a619a 100644
--- a/src/compiler/nir_types.cpp
+++ b/src/compiler/nir_types.cpp
@@ -46,16 +46,6 @@ glsl_array_size(const struct glsl_type *type)
    return type->array_size();
 }
 
-const struct glsl_type *
-glsl_get_array_element(const struct glsl_type* type)
-{
-   if (type->is_matrix())
-      return type->column_type();
-   else if (type->is_vector())
-      return type->get_scalar_type();
-   return type->fields.array;
-}
-
 const struct glsl_type *
 glsl_without_array(const struct glsl_type *type)
 {
@@ -250,120 +240,6 @@ glsl_get_struct_location_offset(const struct glsl_type *type,
    return type->struct_location_offset(length);
 }
 
-bool
-glsl_type_is_16bit(const struct glsl_type *type)
-{
-   return type->is_16bit();
-}
-
-bool
-glsl_type_is_32bit(const struct glsl_type *type)
-{
-   return type->is_32bit();
-}
-
-bool
-glsl_type_is_64bit(const struct glsl_type *type)
-{
-   return type->is_64bit();
-}
-
-bool
-glsl_type_is_vector(const struct glsl_type *type)
-{
-   return type->is_vector();
-}
-
-bool
-glsl_type_is_scalar(const struct glsl_type *type)
-{
-   return type->is_scalar();
-}
-
-bool
-glsl_type_is_vector_or_scalar(const struct glsl_type *type)
-{
-   return type->is_vector() || type->is_scalar();
-}
-
-bool
-glsl_type_is_matrix(const struct glsl_type *type)
-{
-   return type->is_matrix();
-}
-
-bool
-glsl_matrix_type_is_row_major(const struct glsl_type *type)
-{
-   assert((type->is_matrix() && type->explicit_stride) || type->is_interface());
-   return type->interface_row_major;
-}
-
-bool
-glsl_type_is_unsized_array(const struct glsl_type *type)
-{
-   return type->is_unsized_array();
-}
-
-bool
-glsl_type_is_array_of_arrays(const struct glsl_type *type)
-{
-   return type->is_array_of_arrays();
-}
-
-bool
-glsl_type_is_array_or_matrix(const struct glsl_type *type)
-{
-   return type->is_array() || type->is_matrix();
-}
-
-bool
-glsl_type_is_bare_sampler(const struct glsl_type *type)
-{
-   return type->is_sampler() && type->sampled_type == GLSL_TYPE_VOID;
-}
-
-bool
-glsl_sampler_type_is_shadow(const struct glsl_type *type)
-{
-   assert(glsl_type_is_sampler(type));
-   return type->sampler_shadow;
-}
-
-bool
-glsl_sampler_type_is_array(const struct glsl_type *type)
-{
-   assert(glsl_type_is_sampler(type) ||
-          glsl_type_is_texture(type) ||
-          glsl_type_is_image(type));
-   return type->sampler_array;
-}
-
-bool
-glsl_struct_type_is_packed(const struct glsl_type *type)
-{
-   assert(glsl_type_is_struct(type));
-   return type->packed;
-}
-
-bool
-glsl_type_is_dual_slot(const struct glsl_type *type)
-{
-   return type->is_dual_slot();
-}
-
-bool
-glsl_type_is_numeric(const struct glsl_type *type)
-{
-   return type->is_numeric();
-}
-
-bool
-glsl_type_is_integer(const struct glsl_type *type)
-{
-   return type->is_integer();
-}
-
 bool
 glsl_type_contains_64bit(const struct glsl_type *type)
 {
@@ -1006,25 +882,6 @@ glsl_get_explicit_alignment(const struct glsl_type *type)
    return type->explicit_alignment;
 }
 
-bool
-glsl_type_is_packed(const struct glsl_type *type)
-{
-   return type->packed;
-}
-
-bool
-glsl_type_is_leaf(const struct glsl_type *type)
-{
-   if (glsl_type_is_struct_or_ifc(type) ||
-       (glsl_type_is_array(type) &&
-        (glsl_type_is_array(glsl_get_array_element(type)) ||
-         glsl_type_is_struct_or_ifc(glsl_get_array_element(type))))) {
-      return false;
-   } else {
-      return true;
-   }
-}
-
 const struct glsl_type *
 glsl_get_explicit_type_for_size_align(const struct glsl_type *type,
                                       glsl_type_size_align_func type_info,
-- 
GitLab


From c2c8e9a2fed08d9dc158cfd75c75c1715e27163b Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 7 Sep 2023 16:49:47 -0700
Subject: [PATCH 5/7] compiler/types: Flip wrapping of convenience accessors
 for vector types

---
 src/compiler/glsl_types.cpp    | 23 +++++++++++++----------
 src/compiler/glsl_types.h      | 11 ++++++++++-
 src/compiler/glsl_types_impl.h | 13 +++++++++++++
 src/compiler/nir_types.cpp     | 12 ------------
 4 files changed, 36 insertions(+), 23 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 4c72b2e9c021..220dc475d6c9 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -543,8 +543,8 @@ glsl_cmat_use_to_string(enum glsl_cmat_use use)
    }
 };
 
-const struct glsl_type *
-glsl_type::vec(unsigned components, const struct glsl_type *const ts[])
+static const struct glsl_type *
+vec_helper(unsigned components, const struct glsl_type *const ts[])
 {
    unsigned n = components;
 
@@ -554,22 +554,25 @@ glsl_type::vec(unsigned components, const struct glsl_type *const ts[])
       n = 7;
 
    if (n == 0 || n > 7)
-      return error_type;
+      return &glsl_type_builtin_error;
 
    return ts[n - 1];
 }
 
 #define VECN(components, sname, vname)           \
-const struct glsl_type *                                \
-glsl_type:: vname (unsigned components)          \
+extern "C" const struct glsl_type *              \
+glsl_ ## vname ## _type (unsigned components)    \
 {                                                \
    static const struct glsl_type *const ts[] = { \
-      sname ## _type, vname ## 2_type,           \
-      vname ## 3_type, vname ## 4_type,          \
-      vname ## 5_type,                           \
-      vname ## 8_type, vname ## 16_type,         \
+      &glsl_type_builtin_ ## sname,              \
+      &glsl_type_builtin_ ## vname ## 2,         \
+      &glsl_type_builtin_ ## vname ## 3,         \
+      &glsl_type_builtin_ ## vname ## 4,         \
+      &glsl_type_builtin_ ## vname ## 5,         \
+      &glsl_type_builtin_ ## vname ## 8,         \
+      &glsl_type_builtin_ ## vname ## 16,        \
    };                                            \
-   return glsl_type::vec(components, ts);        \
+   return vec_helper(components, ts);            \
 }
 
 VECN(components, float, vec)
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 1ac247be3a4e..1ca58719934f 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -391,7 +391,6 @@ struct glsl_type {
     * Convenience accessors for vector types (shorter than get_instance()).
     * @{
     */
-   static const glsl_type *vec(unsigned components, const glsl_type *const ts[]);
    static const glsl_type *vec(unsigned components);
    static const glsl_type *f16vec(unsigned components);
    static const glsl_type *dvec(unsigned components);
@@ -1342,7 +1341,17 @@ const struct glsl_type *glsl_intN_t_type(unsigned bit_size);
 const struct glsl_type *glsl_uintN_t_type(unsigned bit_size);
 
 const struct glsl_type *glsl_vec_type(unsigned components);
+const struct glsl_type *glsl_f16vec_type(unsigned components);
 const struct glsl_type *glsl_dvec_type(unsigned components);
+const struct glsl_type *glsl_ivec_type(unsigned components);
+const struct glsl_type *glsl_uvec_type(unsigned components);
+const struct glsl_type *glsl_bvec_type(unsigned components);
+const struct glsl_type *glsl_i64vec_type(unsigned components);
+const struct glsl_type *glsl_u64vec_type(unsigned components);
+const struct glsl_type *glsl_i16vec_type(unsigned components);
+const struct glsl_type *glsl_u16vec_type(unsigned components);
+const struct glsl_type *glsl_i8vec_type(unsigned components);
+const struct glsl_type *glsl_u8vec_type(unsigned components);
 
 const struct glsl_type *glsl_sampler_type(enum glsl_sampler_dim dim,
                                           bool shadow,
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
index d5e9033a3879..405a644754c8 100644
--- a/src/compiler/glsl_types_impl.h
+++ b/src/compiler/glsl_types_impl.h
@@ -50,6 +50,19 @@ glsl_type::count_attribute_slots(bool is_gl_vertex_input) const
    return count_vec4_slots(is_gl_vertex_input, true);
 }
 
+inline const glsl_type *glsl_type::vec(unsigned components) { return glsl_vec_type(components); }
+inline const glsl_type *glsl_type::f16vec(unsigned components) { return glsl_f16vec_type(components); }
+inline const glsl_type *glsl_type::dvec(unsigned components) { return glsl_dvec_type(components); }
+inline const glsl_type *glsl_type::ivec(unsigned components) { return glsl_ivec_type(components); }
+inline const glsl_type *glsl_type::uvec(unsigned components) { return glsl_uvec_type(components); }
+inline const glsl_type *glsl_type::bvec(unsigned components) { return glsl_bvec_type(components); }
+inline const glsl_type *glsl_type::i64vec(unsigned components) { return glsl_i64vec_type(components); }
+inline const glsl_type *glsl_type::u64vec(unsigned components) { return glsl_u64vec_type(components); }
+inline const glsl_type *glsl_type::i16vec(unsigned components) { return glsl_i16vec_type(components); }
+inline const glsl_type *glsl_type::u16vec(unsigned components) { return glsl_u16vec_type(components); }
+inline const glsl_type *glsl_type::i8vec(unsigned components) { return glsl_i8vec_type(components); }
+inline const glsl_type *glsl_type::u8vec(unsigned components) { return glsl_u8vec_type(components); }
+
 inline bool
 glsl_type::is_integer_16() const
 {
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
index 296c398a619a..8062238fd3ed 100644
--- a/src/compiler/nir_types.cpp
+++ b/src/compiler/nir_types.cpp
@@ -307,18 +307,6 @@ glsl_floatN_t_type(unsigned bit_size)
    }
 }
 
-const struct glsl_type *
-glsl_vec_type(unsigned n)
-{
-   return glsl_type::vec(n);
-}
-
-const struct glsl_type *
-glsl_dvec_type(unsigned n)
-{
-   return glsl_type::dvec(n);
-}
-
 const struct glsl_type *
 glsl_vec4_type(void)
 {
-- 
GitLab


From 118c911467422be36bbd634fc7634b2aeb727c1b Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Fri, 29 Sep 2023 00:36:13 -0700
Subject: [PATCH 6/7] compiler/types: Flip wrapping of basic "get type"
 functions

---
 src/compiler/glsl_types.h  |  76 ++++++++++++++------
 src/compiler/nir_types.cpp | 140 -------------------------------------
 2 files changed, 55 insertions(+), 161 deletions(-)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 1ca58719934f..ec35048df387 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1318,27 +1318,61 @@ int glsl_get_field_index(const struct glsl_type *t, const char *name);
 int glsl_get_struct_field_offset(const struct glsl_type *t, unsigned index);
 const char *glsl_get_struct_elem_name(const struct glsl_type *t, unsigned index);
 
-const struct glsl_type *glsl_void_type(void);
-const struct glsl_type *glsl_float_type(void);
-const struct glsl_type *glsl_float16_t_type(void);
-const struct glsl_type *glsl_double_type(void);
-const struct glsl_type *glsl_vec4_type(void);
-const struct glsl_type *glsl_uvec4_type(void);
-const struct glsl_type *glsl_ivec4_type(void);
-const struct glsl_type *glsl_int_type(void);
-const struct glsl_type *glsl_uint_type(void);
-const struct glsl_type *glsl_int64_t_type(void);
-const struct glsl_type *glsl_uint64_t_type(void);
-const struct glsl_type *glsl_int16_t_type(void);
-const struct glsl_type *glsl_uint16_t_type(void);
-const struct glsl_type *glsl_int8_t_type(void);
-const struct glsl_type *glsl_uint8_t_type(void);
-const struct glsl_type *glsl_bool_type(void);
-const struct glsl_type *glsl_atomic_uint_type(void);
-
-const struct glsl_type *glsl_floatN_t_type(unsigned bit_size);
-const struct glsl_type *glsl_intN_t_type(unsigned bit_size);
-const struct glsl_type *glsl_uintN_t_type(unsigned bit_size);
+static inline const struct glsl_type *glsl_void_type(void) { return &glsl_type_builtin_void; }
+static inline const struct glsl_type *glsl_float_type(void) { return &glsl_type_builtin_float; }
+static inline const struct glsl_type *glsl_float16_t_type(void) { return &glsl_type_builtin_float16_t; }
+static inline const struct glsl_type *glsl_double_type(void) { return &glsl_type_builtin_double; }
+static inline const struct glsl_type *glsl_vec4_type(void) { return &glsl_type_builtin_vec4; }
+static inline const struct glsl_type *glsl_uvec4_type(void) { return &glsl_type_builtin_uvec4; }
+static inline const struct glsl_type *glsl_ivec4_type(void) { return &glsl_type_builtin_ivec4; }
+static inline const struct glsl_type *glsl_int_type(void) { return &glsl_type_builtin_int; }
+static inline const struct glsl_type *glsl_uint_type(void) { return &glsl_type_builtin_uint; }
+static inline const struct glsl_type *glsl_int64_t_type(void) { return &glsl_type_builtin_int64_t; }
+static inline const struct glsl_type *glsl_uint64_t_type(void) { return &glsl_type_builtin_uint64_t; }
+static inline const struct glsl_type *glsl_int16_t_type(void) { return &glsl_type_builtin_int16_t; }
+static inline const struct glsl_type *glsl_uint16_t_type(void) { return &glsl_type_builtin_uint16_t; }
+static inline const struct glsl_type *glsl_int8_t_type(void) { return &glsl_type_builtin_int8_t; }
+static inline const struct glsl_type *glsl_uint8_t_type(void) { return &glsl_type_builtin_uint8_t; }
+static inline const struct glsl_type *glsl_bool_type(void) { return &glsl_type_builtin_bool; }
+static inline const struct glsl_type *glsl_atomic_uint_type(void) { return &glsl_type_builtin_atomic_uint; }
+
+static inline const struct glsl_type *
+glsl_floatN_t_type(unsigned bit_size)
+{
+   switch (bit_size) {
+   case 16: return &glsl_type_builtin_float16_t;
+   case 32: return &glsl_type_builtin_float;
+   case 64: return &glsl_type_builtin_double;
+   default:
+      unreachable("Unsupported bit size");
+   }
+}
+
+static inline const struct glsl_type *
+glsl_intN_t_type(unsigned bit_size)
+{
+   switch (bit_size) {
+   case 8:  return &glsl_type_builtin_int8_t;
+   case 16: return &glsl_type_builtin_int16_t;
+   case 32: return &glsl_type_builtin_int;
+   case 64: return &glsl_type_builtin_int64_t;
+   default:
+      unreachable("Unsupported bit size");
+   }
+}
+
+static inline const struct glsl_type *
+glsl_uintN_t_type(unsigned bit_size)
+{
+   switch (bit_size) {
+   case 8:  return &glsl_type_builtin_uint8_t;
+   case 16: return &glsl_type_builtin_uint16_t;
+   case 32: return &glsl_type_builtin_uint;
+   case 64: return &glsl_type_builtin_uint64_t;
+   default:
+      unreachable("Unsupported bit size");
+   }
+}
 
 const struct glsl_type *glsl_vec_type(unsigned components);
 const struct glsl_type *glsl_f16vec_type(unsigned components);
diff --git a/src/compiler/nir_types.cpp b/src/compiler/nir_types.cpp
index 8062238fd3ed..e694c3e00383 100644
--- a/src/compiler/nir_types.cpp
+++ b/src/compiler/nir_types.cpp
@@ -271,140 +271,6 @@ glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b,
    return a->record_compare(b, match_name, match_locations, match_precision);
 }
 
-const struct glsl_type *
-glsl_void_type(void)
-{
-   return glsl_type::void_type;
-}
-
-const struct glsl_type *
-glsl_float_type(void)
-{
-   return glsl_type::float_type;
-}
-
-const struct glsl_type *
-glsl_double_type(void)
-{
-   return glsl_type::double_type;
-}
-
-const struct glsl_type *
-glsl_float16_t_type(void)
-{
-   return glsl_type::float16_t_type;
-}
-
-const struct glsl_type *
-glsl_floatN_t_type(unsigned bit_size)
-{
-   switch (bit_size) {
-   case 16: return glsl_type::float16_t_type;
-   case 32: return glsl_type::float_type;
-   case 64: return glsl_type::double_type;
-   default:
-      unreachable("Unsupported bit size");
-   }
-}
-
-const struct glsl_type *
-glsl_vec4_type(void)
-{
-   return glsl_type::vec4_type;
-}
-
-const struct glsl_type *
-glsl_uvec4_type(void)
-{
-   return glsl_type::uvec4_type;
-}
-
-const struct glsl_type *
-glsl_ivec4_type(void)
-{
-   return glsl_type::ivec4_type;
-}
-
-const struct glsl_type *
-glsl_int_type(void)
-{
-   return glsl_type::int_type;
-}
-
-const struct glsl_type *
-glsl_uint_type(void)
-{
-   return glsl_type::uint_type;
-}
-
-const struct glsl_type *
-glsl_int64_t_type(void)
-{
-   return glsl_type::int64_t_type;
-}
-
-const struct glsl_type *
-glsl_uint64_t_type(void)
-{
-   return glsl_type::uint64_t_type;
-}
-
-const struct glsl_type *
-glsl_int16_t_type(void)
-{
-   return glsl_type::int16_t_type;
-}
-
-const struct glsl_type *
-glsl_uint16_t_type(void)
-{
-   return glsl_type::uint16_t_type;
-}
-
-const struct glsl_type *
-glsl_int8_t_type(void)
-{
-   return glsl_type::int8_t_type;
-}
-
-const struct glsl_type *
-glsl_uint8_t_type(void)
-{
-   return glsl_type::uint8_t_type;
-}
-
-const struct glsl_type *
-glsl_intN_t_type(unsigned bit_size)
-{
-   switch (bit_size) {
-   case 8:  return glsl_type::int8_t_type;
-   case 16: return glsl_type::int16_t_type;
-   case 32: return glsl_type::int_type;
-   case 64: return glsl_type::int64_t_type;
-   default:
-      unreachable("Unsupported bit size");
-   }
-}
-
-const struct glsl_type *
-glsl_uintN_t_type(unsigned bit_size)
-{
-   switch (bit_size) {
-   case 8:  return glsl_type::uint8_t_type;
-   case 16: return glsl_type::uint16_t_type;
-   case 32: return glsl_type::uint_type;
-   case 64: return glsl_type::uint64_t_type;
-   default:
-      unreachable("Unsupported bit size");
-   }
-}
-
-const struct glsl_type *
-glsl_bool_type(void)
-{
-   return glsl_type::bool_type;
-}
-
 const struct glsl_type *
 glsl_scalar_type(enum glsl_base_type base_type)
 {
@@ -729,12 +595,6 @@ glsl_get_vec4_size_align_bytes(const struct glsl_type *type,
    }
 }
 
-const struct glsl_type *
-glsl_atomic_uint_type(void)
-{
-   return glsl_type::atomic_uint_type;
-}
-
 unsigned
 glsl_atomic_size(const struct glsl_type *type)
 {
-- 
GitLab


From d809e42fa7e299456bcbd282e54d7018d48a946d Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Sat, 16 Sep 2023 10:19:22 -0700
Subject: [PATCH 7/7] rusticl: Add Rust bindings for inline glsl_types
 functions

---
 .../rusticl_mesa_inline_bindings_wrapper.c    | 42 +++++++++++++++++++
 .../rusticl_mesa_inline_bindings_wrapper.h    | 22 ++++++++++
 2 files changed, 64 insertions(+)

diff --git a/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.c b/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.c
index d89fb5b95c02..56c403c710aa 100644
--- a/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.c
+++ b/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.c
@@ -54,3 +54,45 @@ mesa_version_string(void)
 {
     return PACKAGE_VERSION MESA_GIT_SHA1;
 }
+
+bool
+glsl_type_is_sampler(const struct glsl_type *t)
+{
+    return __glsl_type_is_sampler(t);
+}
+
+bool
+glsl_type_is_image(const struct glsl_type *t)
+{
+    return __glsl_type_is_image(t);
+}
+
+bool
+glsl_type_is_texture(const struct glsl_type *t)
+{
+    return __glsl_type_is_texture(t);
+}
+
+const struct glsl_type *
+glsl_uint_type(void)
+{
+    return __glsl_uint_type();
+}
+
+const struct glsl_type *
+glsl_uint8_t_type(void)
+{
+    return __glsl_uint8_t_type();
+}
+
+const struct glsl_type *
+glsl_uint64_t_type(void)
+{
+    return __glsl_uint64_t_type();
+}
+
+const struct glsl_type *
+glsl_int16_t_type(void)
+{
+    return __glsl_int16_t_type();
+}
diff --git a/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.h b/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.h
index 8e7a458ea5f2..6f4ef1be20d8 100644
--- a/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.h
+++ b/src/gallium/frontends/rusticl/rusticl_mesa_inline_bindings_wrapper.h
@@ -6,12 +6,20 @@
 #define should_print_nir __should_print_nir
 #define should_skip_nir __should_skip_nir
 #define util_format_pack_rgba __util_format_pack_rgba
+#define glsl_type_is_sampler __glsl_type_is_sampler
+#define glsl_type_is_image __glsl_type_is_image
+#define glsl_type_is_texture __glsl_type_is_texture
+#define glsl_uint_type __glsl_uint_type
+#define glsl_uint8_t_type __glsl_uint8_t_type
+#define glsl_uint64_t_type __glsl_uint64_t_type
+#define glsl_int16_t_type __glsl_int16_t_type
 #include "nir.h"
 #include "util/blob.h"
 #include "util/disk_cache.h"
 #include "util/hex.h"
 #include "util/u_inlines.h"
 #include "util/format/u_format.h"
+#include "compiler/glsl_types.h"
 #undef blob_finish
 #undef mesa_bytes_to_hex
 #undef disk_cache_get_function_identifier
@@ -20,6 +28,13 @@
 #undef should_print_nir
 #undef should_skip_nir
 #undef util_format_pack_rgba
+#undef glsl_type_is_sampler
+#undef glsl_type_is_image
+#undef glsl_type_is_texture
+#undef glsl_uint_type
+#undef glsl_uint8_t_type
+#undef glsl_uint64_t_type
+#undef glsl_int16_t_type
 
 void blob_finish(struct blob *);
 char *mesa_bytes_to_hex(char *buf, const uint8_t *hex_id, unsigned size);
@@ -30,3 +45,10 @@ void pipe_resource_reference(struct pipe_resource **dst, struct pipe_resource *s
 bool should_skip_nir(const char *);
 bool should_print_nir(nir_shader *);
 void util_format_pack_rgba(enum pipe_format format, void *dst, const void *src, unsigned w);
+bool glsl_type_is_sampler(const struct glsl_type *t);
+bool glsl_type_is_image(const struct glsl_type *t);
+bool glsl_type_is_texture(const struct glsl_type *t);
+const struct glsl_type *glsl_uint_type(void);
+const struct glsl_type *glsl_uint8_t_type(void);
+const struct glsl_type *glsl_uint64_t_type(void);
+const struct glsl_type *glsl_int16_t_type(void);
-- 
GitLab

