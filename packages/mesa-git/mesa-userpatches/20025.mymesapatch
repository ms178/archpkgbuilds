From 72a3bc4778775f5e77724f31fdb247a3a65febe1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 27 Nov 2022 10:39:49 -0500
Subject: [PATCH 1/5] gallium: add the u_vbuf pointer into pipe_context

This will allow removing the draw_vbo wrapping in cso_context.
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 4 ++++
 src/gallium/include/pipe/p_context.h          | 2 ++
 2 files changed, 6 insertions(+)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index efce6f6737ef..dbad1b2b4168 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -259,7 +259,9 @@ cso_init_vbuf(struct cso_context *cso, unsigned flags)
    if (caps.fallback_always ||
        (uses_user_vertex_buffers &&
         caps.fallback_only_for_user_vbuffers)) {
+      assert(!cso->pipe->vbuf);
       cso->vbuf = u_vbuf_create(cso->pipe, &caps);
+      cso->pipe->vbuf = cso->vbuf;
       cso->always_use_vbuf = caps.fallback_always;
       cso->vbuf_current = caps.fallback_always ? cso->vbuf : NULL;
    }
@@ -451,6 +453,8 @@ cso_destroy_context(struct cso_context *ctx)
 
    if (ctx->vbuf)
       u_vbuf_destroy(ctx->vbuf);
+
+   ctx->pipe->vbuf = NULL;
    FREE(ctx);
 }
 
diff --git a/src/gallium/include/pipe/p_context.h b/src/gallium/include/pipe/p_context.h
index 9eff0d87e505..c59dde608ca8 100644
--- a/src/gallium/include/pipe/p_context.h
+++ b/src/gallium/include/pipe/p_context.h
@@ -83,6 +83,7 @@ union pipe_query_result;
 struct u_log_context;
 struct u_upload_mgr;
 struct util_debug_callback;
+struct u_vbuf;
 
 /**
  * Gallium rendering context.  Basically:
@@ -95,6 +96,7 @@ struct pipe_context {
 
    void *priv;  /**< context private data (for DRI for example) */
    void *draw;  /**< private, for draw module (temporary?) */
+   struct u_vbuf *vbuf; /**< for cso_context, don't use in drivers */
 
    /**
     * Stream uploaders created by the driver. All drivers, gallium frontends, and
-- 
GitLab


From db7be202cd81a1e7526072f355252351a4b5927e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 27 Nov 2022 10:44:29 -0500
Subject: [PATCH 2/5] gallium/u_vbuf: change u_vbuf_draw_vbo to accept
 pipe_context as first param

This makes the parameters equal to pipe_context::draw_vbo.
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 17 +++++++----------
 src/gallium/auxiliary/util/u_vbuf.c           |  6 +++---
 src/gallium/auxiliary/util/u_vbuf.h           |  3 ++-
 3 files changed, 12 insertions(+), 14 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index dbad1b2b4168..94a357c2fcbf 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1746,8 +1746,6 @@ cso_draw_vbo(struct cso_context *cso,
              const struct pipe_draw_indirect_info *indirect,
              const struct pipe_draw_start_count_bias draw)
 {
-   struct u_vbuf *vbuf = cso->vbuf_current;
-
    /* We can't have both indirect drawing and SO-vertex-count drawing */
    assert(!indirect ||
           indirect->buffer == NULL ||
@@ -1758,10 +1756,11 @@ cso_draw_vbo(struct cso_context *cso,
           !indirect ||
           indirect->count_from_stream_output == NULL);
 
-   if (vbuf) {
-      u_vbuf_draw_vbo(vbuf, info, drawid_offset, indirect, &draw, 1);
+   struct pipe_context *pipe = cso->pipe;
+
+   if (cso->vbuf_current) {
+      u_vbuf_draw_vbo(pipe, info, drawid_offset, indirect, &draw, 1);
    } else {
-      struct pipe_context *pipe = cso->pipe;
       pipe->draw_vbo(pipe, info, drawid_offset, indirect, &draw, 1);
    }
 }
@@ -1774,13 +1773,11 @@ cso_multi_draw(struct cso_context *cso,
                const struct pipe_draw_start_count_bias *draws,
                unsigned num_draws)
 {
-   struct u_vbuf *vbuf = cso->vbuf_current;
+   struct pipe_context *pipe = cso->pipe;
 
-   if (vbuf) {
-      u_vbuf_draw_vbo(vbuf, info, drawid_offset, NULL, draws, num_draws);
+   if (cso->vbuf_current) {
+      u_vbuf_draw_vbo(pipe, info, drawid_offset, NULL, draws, num_draws);
    } else {
-      struct pipe_context *pipe = cso->pipe;
-
       pipe->draw_vbo(pipe, info, drawid_offset, NULL, draws, num_draws);
    }
 }
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 7e8999308b6a..80f37dc96535 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -1450,17 +1450,17 @@ u_vbuf_split_indexed_multidraw(struct u_vbuf *mgr, struct pipe_draw_info *info,
       draw.index_bias = indirect_data[offset + 3];
       info->start_instance = indirect_data[offset + 4];
 
-      u_vbuf_draw_vbo(mgr, info, drawid_offset, NULL, &draw, 1);
+      u_vbuf_draw_vbo(mgr->pipe, info, drawid_offset, NULL, &draw, 1);
    }
 }
 
-void u_vbuf_draw_vbo(struct u_vbuf *mgr, const struct pipe_draw_info *info,
+void u_vbuf_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info,
                      unsigned drawid_offset,
                      const struct pipe_draw_indirect_info *indirect,
                      const struct pipe_draw_start_count_bias *draws,
                      unsigned num_draws)
 {
-   struct pipe_context *pipe = mgr->pipe;
+   struct u_vbuf *mgr = pipe->vbuf;
    int start_vertex;
    unsigned min_index;
    unsigned num_vertices;
diff --git a/src/gallium/auxiliary/util/u_vbuf.h b/src/gallium/auxiliary/util/u_vbuf.h
index 93d45ee6f156..bb3568fb3dc0 100644
--- a/src/gallium/auxiliary/util/u_vbuf.h
+++ b/src/gallium/auxiliary/util/u_vbuf.h
@@ -85,7 +85,8 @@ void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
                                unsigned unbind_num_trailing_slots,
                                bool take_ownership,
                                const struct pipe_vertex_buffer *bufs);
-void u_vbuf_draw_vbo(struct u_vbuf *mgr, const struct pipe_draw_info *info,
+void u_vbuf_draw_vbo(struct pipe_context *pipe,
+                     const struct pipe_draw_info *info,
                      unsigned drawid_offset,
                      const struct pipe_draw_indirect_info *indirect,
                      const struct pipe_draw_start_count_bias *draws,
-- 
GitLab


From 18cd725768921293c20cea63b1363c05eb6eb214 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 27 Nov 2022 10:56:52 -0500
Subject: [PATCH 3/5] cso: unify cso_draw_vbo and cso_multi_draw

This is going to be inlined.
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 31 ++++++-------------
 src/gallium/auxiliary/cso_cache/cso_context.h | 13 ++------
 src/mesa/state_tracker/st_draw.c              | 16 +++++-----
 3 files changed, 20 insertions(+), 40 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 94a357c2fcbf..01022d259807 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1741,10 +1741,11 @@ cso_restore_compute_state(struct cso_context *cso)
 
 void
 cso_draw_vbo(struct cso_context *cso,
-             const struct pipe_draw_info *info,
+             struct pipe_draw_info *info,
              unsigned drawid_offset,
              const struct pipe_draw_indirect_info *indirect,
-             const struct pipe_draw_start_count_bias draw)
+             const struct pipe_draw_start_count_bias *draws,
+             unsigned num_draws)
 {
    /* We can't have both indirect drawing and SO-vertex-count drawing */
    assert(!indirect ||
@@ -1756,29 +1757,15 @@ cso_draw_vbo(struct cso_context *cso,
           !indirect ||
           indirect->count_from_stream_output == NULL);
 
-   struct pipe_context *pipe = cso->pipe;
-
-   if (cso->vbuf_current) {
-      u_vbuf_draw_vbo(pipe, info, drawid_offset, indirect, &draw, 1);
-   } else {
-      pipe->draw_vbo(pipe, info, drawid_offset, indirect, &draw, 1);
-   }
-}
+   /* Indirect only uses indirect->draw_count, not num_draws. */
+   assert(!indirect || num_draws == 1);
 
-/* info->draw_id can be changed by the callee if increment_draw_id is true. */
-void
-cso_multi_draw(struct cso_context *cso,
-               struct pipe_draw_info *info,
-               unsigned drawid_offset,
-               const struct pipe_draw_start_count_bias *draws,
-               unsigned num_draws)
-{
    struct pipe_context *pipe = cso->pipe;
 
    if (cso->vbuf_current) {
-      u_vbuf_draw_vbo(pipe, info, drawid_offset, NULL, draws, num_draws);
+      u_vbuf_draw_vbo(pipe, info, drawid_offset, indirect, draws, num_draws);
    } else {
-      pipe->draw_vbo(pipe, info, drawid_offset, NULL, draws, num_draws);
+      pipe->draw_vbo(pipe, info, drawid_offset, indirect, draws, num_draws);
    }
 }
 
@@ -1800,7 +1787,7 @@ cso_draw_arrays(struct cso_context *cso, uint mode, uint start, uint count)
    draw.count = count;
    draw.index_bias = 0;
 
-   cso_draw_vbo(cso, &info, 0, NULL, draw);
+   cso_draw_vbo(cso, &info, 0, NULL, &draw, 1);
 }
 
 
@@ -1825,5 +1812,5 @@ cso_draw_arrays_instanced(struct cso_context *cso, uint mode,
    draw.count = count;
    draw.index_bias = 0;
 
-   cso_draw_vbo(cso, &info, 0, NULL, draw);
+   cso_draw_vbo(cso, &info, 0, NULL, &draw, 1);
 }
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.h b/src/gallium/auxiliary/cso_cache/cso_context.h
index 4b9ec2098bf1..aaa07360bad0 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.h
+++ b/src/gallium/auxiliary/cso_cache/cso_context.h
@@ -211,18 +211,11 @@ cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
 
 void
 cso_draw_vbo(struct cso_context *cso,
-             const struct pipe_draw_info *info,
+             struct pipe_draw_info *info,
              unsigned drawid_offset,
              const struct pipe_draw_indirect_info *indirect,
-             const struct pipe_draw_start_count_bias draw);
-
-/* info->draw_id can be changed by the callee if increment_draw_id is true. */
-void
-cso_multi_draw(struct cso_context *cso,
-               struct pipe_draw_info *info,
-               unsigned drawid_offset,
-               const struct pipe_draw_start_count_bias *draws,
-               unsigned num_draws);
+             const struct pipe_draw_start_count_bias *draws,
+             unsigned num_draws);
 
 void
 cso_draw_arrays_instanced(struct cso_context *cso, uint mode,
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 18c27c7f4595..104c10d24a66 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -171,7 +171,7 @@ st_draw_gallium(struct gl_context *ctx,
    if (!prepare_indexed_draw(st, ctx, info, draws, num_draws))
       return;
 
-   cso_multi_draw(st->cso_context, info, drawid_offset, draws, num_draws);
+   cso_draw_vbo(st->cso_context, info, drawid_offset, NULL, draws, num_draws);
 }
 
 static void
@@ -195,7 +195,7 @@ st_draw_gallium_multimode(struct gl_context *ctx,
    for (i = 0, first = 0; i <= num_draws; i++) {
       if (i == num_draws || mode[i] != mode[first]) {
          info->mode = mode[first];
-         cso_multi_draw(cso, info, 0, &draws[first], i - first);
+         cso_draw_vbo(cso, info, 0, NULL, &draws[first], i - first);
          first = i;
 
          /* We can pass the reference only once. st_buffer_object keeps
@@ -217,7 +217,7 @@ rewrite_partial_stride_indirect(struct st_context *st,
    if (!new_draws)
       return;
    for (unsigned i = 0; i < draw_count; i++)
-      cso_draw_vbo(st->cso_context, &new_draws[i].info, i, NULL, new_draws[i].draw);
+      cso_draw_vbo(st->cso_context, &new_draws[i].info, i, NULL, &new_draws[i].draw, 1);
    free(new_draws);
 }
 
@@ -286,7 +286,7 @@ st_indirect_draw_vbo(struct gl_context *ctx,
       assert(!indirect_draw_count);
       indirect.draw_count = 1;
       for (i = 0; i < draw_count; i++) {
-         cso_draw_vbo(st->cso_context, &info, i, &indirect, draw);
+         cso_draw_vbo(st->cso_context, &info, i, &indirect, &draw, 1);
          indirect.offset += stride;
       }
    } else {
@@ -306,7 +306,7 @@ st_indirect_draw_vbo(struct gl_context *ctx,
             indirect_draw_count->buffer;
          indirect.indirect_draw_count_offset = indirect_draw_count_offset;
       }
-      cso_draw_vbo(st->cso_context, &info, 0, &indirect, draw);
+      cso_draw_vbo(st->cso_context, &info, 0, &indirect, &draw, 1);
    }
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH)
@@ -337,7 +337,7 @@ st_draw_transform_feedback(struct gl_context *ctx, GLenum mode,
    if (indirect.count_from_stream_output == NULL)
       return;
 
-   cso_draw_vbo(st->cso_context, &info, 0, &indirect, draw);
+   cso_draw_vbo(st->cso_context, &info, 0, &indirect, &draw, 1);
 }
 
 static void
@@ -542,7 +542,7 @@ st_hw_select_draw_gallium(struct gl_context *ctx,
        !st_draw_hw_select_prepare_mode(ctx, info))
       return;
 
-   cso_multi_draw(st->cso_context, info, drawid_offset, draws, num_draws);
+   cso_draw_vbo(st->cso_context, info, drawid_offset, NULL, draws, num_draws);
 }
 
 static void
@@ -571,7 +571,7 @@ st_hw_select_draw_gallium_multimode(struct gl_context *ctx,
          info->mode = mode[first];
 
          if (st_draw_hw_select_prepare_mode(ctx, info))
-            cso_multi_draw(cso, info, 0, &draws[first], i - first);
+            cso_draw_vbo(cso, info, 0, NULL, &draws[first], i - first);
 
          first = i;
 
-- 
GitLab


From 0aa2a14ab07c0123a853cfa29ac354eee581be71 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 27 Nov 2022 11:01:58 -0500
Subject: [PATCH 4/5] cso: add a base class cso_context_base holding
 pipe_context*

We'll add more stuff there. The first change is that we need pipe_context*
there.
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 169 +++++++++---------
 src/gallium/auxiliary/cso_cache/cso_context.h |  17 +-
 2 files changed, 95 insertions(+), 91 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 01022d259807..c8be6c4410de 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -63,7 +63,7 @@ struct sampler_info
 
 
 struct cso_context {
-   struct pipe_context *pipe;
+   struct cso_context_base base;
 
    struct u_vbuf *vbuf;
    struct u_vbuf *vbuf_current;
@@ -124,13 +124,6 @@ struct cso_context {
 };
 
 
-struct pipe_context *
-cso_get_pipe_context(struct cso_context *cso)
-{
-   return cso->pipe;
-}
-
-
 static inline boolean
 delete_cso(struct cso_context *ctx,
            void *state, enum cso_cache_type type)
@@ -163,7 +156,7 @@ delete_cso(struct cso_context *ctx,
       assert(0);
    }
 
-   cso_delete_state(ctx->pipe, state, type);
+   cso_delete_state(ctx->base.pipe, state, type);
    return true;
 }
 
@@ -253,15 +246,15 @@ cso_init_vbuf(struct cso_context *cso, unsigned flags)
    bool uses_user_vertex_buffers = !(flags & CSO_NO_USER_VERTEX_BUFFERS);
    bool needs64b = !(flags & CSO_NO_64B_VERTEX_BUFFERS);
 
-   u_vbuf_get_caps(cso->pipe->screen, &caps, needs64b);
+   u_vbuf_get_caps(cso->base.pipe->screen, &caps, needs64b);
 
    /* Enable u_vbuf if needed. */
    if (caps.fallback_always ||
        (uses_user_vertex_buffers &&
         caps.fallback_only_for_user_vbuffers)) {
-      assert(!cso->pipe->vbuf);
-      cso->vbuf = u_vbuf_create(cso->pipe, &caps);
-      cso->pipe->vbuf = cso->vbuf;
+      assert(!cso->base.pipe->vbuf);
+      cso->vbuf = u_vbuf_create(cso->base.pipe, &caps);
+      cso->base.pipe->vbuf = cso->vbuf;
       cso->always_use_vbuf = caps.fallback_always;
       cso->vbuf_current = caps.fallback_always ? cso->vbuf : NULL;
    }
@@ -278,7 +271,7 @@ cso_create_context(struct pipe_context *pipe, unsigned flags)
    cso_cache_init(&ctx->cache, pipe);
    cso_cache_set_sanitize_callback(&ctx->cache, sanitize_hash, ctx);
 
-   ctx->pipe = pipe;
+   ctx->base.pipe = pipe;
    ctx->sample_mask = ~0;
 
    if (!(flags & CSO_NO_VBUF))
@@ -332,15 +325,15 @@ cso_unbind_context(struct cso_context *ctx)
    bool dumping = trace_dumping_enabled_locked();
    if (dumping)
       trace_dumping_stop_locked();
-   if (ctx->pipe) {
-      ctx->pipe->bind_blend_state(ctx->pipe, NULL);
-      ctx->pipe->bind_rasterizer_state(ctx->pipe, NULL);
+   if (ctx->base.pipe) {
+      ctx->base.pipe->bind_blend_state(ctx->base.pipe, NULL);
+      ctx->base.pipe->bind_rasterizer_state(ctx->base.pipe, NULL);
 
       {
          static struct pipe_sampler_view *views[PIPE_MAX_SHADER_SAMPLER_VIEWS] = { NULL };
          static struct pipe_shader_buffer ssbos[PIPE_MAX_SHADER_BUFFERS] = { 0 };
          static void *zeros[PIPE_MAX_SAMPLERS] = { NULL };
-         struct pipe_screen *scr = ctx->pipe->screen;
+         struct pipe_screen *scr = ctx->base.pipe->screen;
          enum pipe_shader_type sh;
          for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
             switch (sh) {
@@ -377,44 +370,44 @@ cso_unbind_context(struct cso_context *ctx)
             assert(maxcb <= PIPE_MAX_CONSTANT_BUFFERS);
             assert(maximg <= PIPE_MAX_SHADER_IMAGES);
             if (maxsam > 0) {
-               ctx->pipe->bind_sampler_states(ctx->pipe, sh, 0, maxsam, zeros);
+               ctx->base.pipe->bind_sampler_states(ctx->base.pipe, sh, 0, maxsam, zeros);
             }
             if (maxview > 0) {
-               ctx->pipe->set_sampler_views(ctx->pipe, sh, 0, maxview, 0, false, views);
+               ctx->base.pipe->set_sampler_views(ctx->base.pipe, sh, 0, maxview, 0, false, views);
             }
             if (maxssbo > 0) {
-               ctx->pipe->set_shader_buffers(ctx->pipe, sh, 0, maxssbo, ssbos, 0);
+               ctx->base.pipe->set_shader_buffers(ctx->base.pipe, sh, 0, maxssbo, ssbos, 0);
             }
             if (maximg > 0) {
-               ctx->pipe->set_shader_images(ctx->pipe, sh, 0, 0, maximg, NULL);
+               ctx->base.pipe->set_shader_images(ctx->base.pipe, sh, 0, 0, maximg, NULL);
             }
             for (int i = 0; i < maxcb; i++) {
-               ctx->pipe->set_constant_buffer(ctx->pipe, sh, i, false, NULL);
+               ctx->base.pipe->set_constant_buffer(ctx->base.pipe, sh, i, false, NULL);
             }
          }
       }
 
-      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe, NULL);
+      ctx->base.pipe->bind_depth_stencil_alpha_state(ctx->base.pipe, NULL);
       struct pipe_stencil_ref sr = {0};
-      ctx->pipe->set_stencil_ref(ctx->pipe, sr);
-      ctx->pipe->bind_fs_state(ctx->pipe, NULL);
-      ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_FRAGMENT, 0, false, NULL);
-      ctx->pipe->bind_vs_state(ctx->pipe, NULL);
-      ctx->pipe->set_constant_buffer(ctx->pipe, PIPE_SHADER_VERTEX, 0, false, NULL);
+      ctx->base.pipe->set_stencil_ref(ctx->base.pipe, sr);
+      ctx->base.pipe->bind_fs_state(ctx->base.pipe, NULL);
+      ctx->base.pipe->set_constant_buffer(ctx->base.pipe, PIPE_SHADER_FRAGMENT, 0, false, NULL);
+      ctx->base.pipe->bind_vs_state(ctx->base.pipe, NULL);
+      ctx->base.pipe->set_constant_buffer(ctx->base.pipe, PIPE_SHADER_VERTEX, 0, false, NULL);
       if (ctx->has_geometry_shader) {
-         ctx->pipe->bind_gs_state(ctx->pipe, NULL);
+         ctx->base.pipe->bind_gs_state(ctx->base.pipe, NULL);
       }
       if (ctx->has_tessellation) {
-         ctx->pipe->bind_tcs_state(ctx->pipe, NULL);
-         ctx->pipe->bind_tes_state(ctx->pipe, NULL);
+         ctx->base.pipe->bind_tcs_state(ctx->base.pipe, NULL);
+         ctx->base.pipe->bind_tes_state(ctx->base.pipe, NULL);
       }
       if (ctx->has_compute_shader) {
-         ctx->pipe->bind_compute_state(ctx->pipe, NULL);
+         ctx->base.pipe->bind_compute_state(ctx->base.pipe, NULL);
       }
-      ctx->pipe->bind_vertex_elements_state(ctx->pipe, NULL);
+      ctx->base.pipe->bind_vertex_elements_state(ctx->base.pipe, NULL);
 
       if (ctx->has_streamout)
-         ctx->pipe->set_stream_output_targets(ctx->pipe, 0, NULL, NULL);
+         ctx->base.pipe->set_stream_output_targets(ctx->base.pipe, 0, NULL, NULL);
    }
 
    util_unreference_framebuffer_state(&ctx->fb);
@@ -434,9 +427,9 @@ cso_unbind_context(struct cso_context *ctx)
     * If the cso context is reused (with the same pipe context),
     * need to really make sure the context state doesn't get out of sync.
     */
-   ctx->pipe->set_sample_mask(ctx->pipe, ctx->sample_mask);
-   if (ctx->pipe->set_min_samples)
-      ctx->pipe->set_min_samples(ctx->pipe, ctx->min_samples);
+   ctx->base.pipe->set_sample_mask(ctx->base.pipe, ctx->sample_mask);
+   if (ctx->base.pipe->set_min_samples)
+      ctx->base.pipe->set_min_samples(ctx->base.pipe, ctx->min_samples);
    if (dumping)
       trace_dumping_start_locked();
 }
@@ -454,7 +447,7 @@ cso_destroy_context(struct cso_context *ctx)
    if (ctx->vbuf)
       u_vbuf_destroy(ctx->vbuf);
 
-   ctx->pipe->vbuf = NULL;
+   ctx->base.pipe->vbuf = NULL;
    FREE(ctx);
 }
 
@@ -503,7 +496,7 @@ cso_set_blend(struct cso_context *ctx,
 
       memset(&cso->state, 0, sizeof cso->state);
       memcpy(&cso->state, templ, key_size);
-      cso->data = ctx->pipe->create_blend_state(ctx->pipe, &cso->state);
+      cso->data = ctx->base.pipe->create_blend_state(ctx->base.pipe, &cso->state);
 
       iter = cso_insert_state(&ctx->cache, hash_key, CSO_BLEND, cso);
       if (cso_hash_iter_is_null(iter)) {
@@ -518,7 +511,7 @@ cso_set_blend(struct cso_context *ctx,
 
    if (ctx->blend != handle) {
       ctx->blend = handle;
-      ctx->pipe->bind_blend_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_blend_state(ctx->base.pipe, handle);
    }
    return PIPE_OK;
 }
@@ -537,7 +530,7 @@ cso_restore_blend(struct cso_context *ctx)
 {
    if (ctx->blend != ctx->blend_saved) {
       ctx->blend = ctx->blend_saved;
-      ctx->pipe->bind_blend_state(ctx->pipe, ctx->blend_saved);
+      ctx->base.pipe->bind_blend_state(ctx->base.pipe, ctx->blend_saved);
    }
    ctx->blend_saved = NULL;
 }
@@ -562,7 +555,7 @@ cso_set_depth_stencil_alpha(struct cso_context *ctx,
          return PIPE_ERROR_OUT_OF_MEMORY;
 
       memcpy(&cso->state, templ, sizeof(*templ));
-      cso->data = ctx->pipe->create_depth_stencil_alpha_state(ctx->pipe,
+      cso->data = ctx->base.pipe->create_depth_stencil_alpha_state(ctx->base.pipe,
                                                               &cso->state);
 
       iter = cso_insert_state(&ctx->cache, hash_key,
@@ -580,7 +573,7 @@ cso_set_depth_stencil_alpha(struct cso_context *ctx,
 
    if (ctx->depth_stencil != handle) {
       ctx->depth_stencil = handle;
-      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_depth_stencil_alpha_state(ctx->base.pipe, handle);
    }
    return PIPE_OK;
 }
@@ -599,7 +592,7 @@ cso_restore_depth_stencil_alpha(struct cso_context *ctx)
 {
    if (ctx->depth_stencil != ctx->depth_stencil_saved) {
       ctx->depth_stencil = ctx->depth_stencil_saved;
-      ctx->pipe->bind_depth_stencil_alpha_state(ctx->pipe,
+      ctx->base.pipe->bind_depth_stencil_alpha_state(ctx->base.pipe,
                                                 ctx->depth_stencil_saved);
    }
    ctx->depth_stencil_saved = NULL;
@@ -629,7 +622,7 @@ cso_set_rasterizer(struct cso_context *ctx,
          return PIPE_ERROR_OUT_OF_MEMORY;
 
       memcpy(&cso->state, templ, sizeof(*templ));
-      cso->data = ctx->pipe->create_rasterizer_state(ctx->pipe, &cso->state);
+      cso->data = ctx->base.pipe->create_rasterizer_state(ctx->base.pipe, &cso->state);
 
       iter = cso_insert_state(&ctx->cache, hash_key, CSO_RASTERIZER, cso);
       if (cso_hash_iter_is_null(iter)) {
@@ -647,7 +640,7 @@ cso_set_rasterizer(struct cso_context *ctx,
       ctx->flatshade_first = templ->flatshade_first;
       if (ctx->vbuf)
          u_vbuf_set_flatshade_first(ctx->vbuf, ctx->flatshade_first);
-      ctx->pipe->bind_rasterizer_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_rasterizer_state(ctx->base.pipe, handle);
    }
    return PIPE_OK;
 }
@@ -670,7 +663,7 @@ cso_restore_rasterizer(struct cso_context *ctx)
       ctx->flatshade_first = ctx->flatshade_first_saved;
       if (ctx->vbuf)
          u_vbuf_set_flatshade_first(ctx->vbuf, ctx->flatshade_first);
-      ctx->pipe->bind_rasterizer_state(ctx->pipe, ctx->rasterizer_saved);
+      ctx->base.pipe->bind_rasterizer_state(ctx->base.pipe, ctx->rasterizer_saved);
    }
    ctx->rasterizer_saved = NULL;
 }
@@ -681,7 +674,7 @@ cso_set_fragment_shader_handle(struct cso_context *ctx, void *handle)
 {
    if (ctx->fragment_shader != handle) {
       ctx->fragment_shader = handle;
-      ctx->pipe->bind_fs_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_fs_state(ctx->base.pipe, handle);
    }
 }
 
@@ -698,7 +691,7 @@ static void
 cso_restore_fragment_shader(struct cso_context *ctx)
 {
    if (ctx->fragment_shader_saved != ctx->fragment_shader) {
-      ctx->pipe->bind_fs_state(ctx->pipe, ctx->fragment_shader_saved);
+      ctx->base.pipe->bind_fs_state(ctx->base.pipe, ctx->fragment_shader_saved);
       ctx->fragment_shader = ctx->fragment_shader_saved;
    }
    ctx->fragment_shader_saved = NULL;
@@ -710,7 +703,7 @@ cso_set_vertex_shader_handle(struct cso_context *ctx, void *handle)
 {
    if (ctx->vertex_shader != handle) {
       ctx->vertex_shader = handle;
-      ctx->pipe->bind_vs_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_vs_state(ctx->base.pipe, handle);
    }
 }
 
@@ -727,7 +720,7 @@ static void
 cso_restore_vertex_shader(struct cso_context *ctx)
 {
    if (ctx->vertex_shader_saved != ctx->vertex_shader) {
-      ctx->pipe->bind_vs_state(ctx->pipe, ctx->vertex_shader_saved);
+      ctx->base.pipe->bind_vs_state(ctx->base.pipe, ctx->vertex_shader_saved);
       ctx->vertex_shader = ctx->vertex_shader_saved;
    }
    ctx->vertex_shader_saved = NULL;
@@ -740,7 +733,7 @@ cso_set_framebuffer(struct cso_context *ctx,
 {
    if (memcmp(&ctx->fb, fb, sizeof(*fb)) != 0) {
       util_copy_framebuffer_state(&ctx->fb, fb);
-      ctx->pipe->set_framebuffer_state(ctx->pipe, fb);
+      ctx->base.pipe->set_framebuffer_state(ctx->base.pipe, fb);
    }
 }
 
@@ -757,7 +750,7 @@ cso_restore_framebuffer(struct cso_context *ctx)
 {
    if (memcmp(&ctx->fb, &ctx->fb_saved, sizeof(ctx->fb))) {
       util_copy_framebuffer_state(&ctx->fb, &ctx->fb_saved);
-      ctx->pipe->set_framebuffer_state(ctx->pipe, &ctx->fb);
+      ctx->base.pipe->set_framebuffer_state(ctx->base.pipe, &ctx->fb);
       util_unreference_framebuffer_state(&ctx->fb_saved);
    }
 }
@@ -769,7 +762,7 @@ cso_set_viewport(struct cso_context *ctx,
 {
    if (memcmp(&ctx->vp, vp, sizeof(*vp))) {
       ctx->vp = *vp;
-      ctx->pipe->set_viewport_states(ctx->pipe, 0, 1, vp);
+      ctx->base.pipe->set_viewport_states(ctx->base.pipe, 0, 1, vp);
    }
 }
 
@@ -809,7 +802,7 @@ cso_restore_viewport(struct cso_context *ctx)
 {
    if (memcmp(&ctx->vp, &ctx->vp_saved, sizeof(ctx->vp))) {
       ctx->vp = ctx->vp_saved;
-      ctx->pipe->set_viewport_states(ctx->pipe, 0, 1, &ctx->vp);
+      ctx->base.pipe->set_viewport_states(ctx->base.pipe, 0, 1, &ctx->vp);
    }
 }
 
@@ -819,7 +812,7 @@ cso_set_sample_mask(struct cso_context *ctx, unsigned sample_mask)
 {
    if (ctx->sample_mask != sample_mask) {
       ctx->sample_mask = sample_mask;
-      ctx->pipe->set_sample_mask(ctx->pipe, sample_mask);
+      ctx->base.pipe->set_sample_mask(ctx->base.pipe, sample_mask);
    }
 }
 
@@ -841,9 +834,9 @@ cso_restore_sample_mask(struct cso_context *ctx)
 void
 cso_set_min_samples(struct cso_context *ctx, unsigned min_samples)
 {
-   if (ctx->min_samples != min_samples && ctx->pipe->set_min_samples) {
+   if (ctx->min_samples != min_samples && ctx->base.pipe->set_min_samples) {
       ctx->min_samples = min_samples;
-      ctx->pipe->set_min_samples(ctx->pipe, min_samples);
+      ctx->base.pipe->set_min_samples(ctx->base.pipe, min_samples);
    }
 }
 
@@ -868,7 +861,7 @@ cso_set_stencil_ref(struct cso_context *ctx,
 {
    if (memcmp(&ctx->stencil_ref, &sr, sizeof(ctx->stencil_ref))) {
       ctx->stencil_ref = sr;
-      ctx->pipe->set_stencil_ref(ctx->pipe, sr);
+      ctx->base.pipe->set_stencil_ref(ctx->base.pipe, sr);
    }
 }
 
@@ -886,7 +879,7 @@ cso_restore_stencil_ref(struct cso_context *ctx)
    if (memcmp(&ctx->stencil_ref, &ctx->stencil_ref_saved,
               sizeof(ctx->stencil_ref))) {
       ctx->stencil_ref = ctx->stencil_ref_saved;
-      ctx->pipe->set_stencil_ref(ctx->pipe, ctx->stencil_ref);
+      ctx->base.pipe->set_stencil_ref(ctx->base.pipe, ctx->stencil_ref);
    }
 }
 
@@ -897,7 +890,7 @@ cso_set_render_condition(struct cso_context *ctx,
                          boolean condition,
                          enum pipe_render_cond_flag mode)
 {
-   struct pipe_context *pipe = ctx->pipe;
+   struct pipe_context *pipe = ctx->base.pipe;
 
    if (ctx->render_condition != query ||
        ctx->render_condition_mode != mode ||
@@ -935,7 +928,7 @@ cso_set_geometry_shader_handle(struct cso_context *ctx, void *handle)
 
    if (ctx->has_geometry_shader && ctx->geometry_shader != handle) {
       ctx->geometry_shader = handle;
-      ctx->pipe->bind_gs_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_gs_state(ctx->base.pipe, handle);
    }
 }
 
@@ -960,7 +953,7 @@ cso_restore_geometry_shader(struct cso_context *ctx)
    }
 
    if (ctx->geometry_shader_saved != ctx->geometry_shader) {
-      ctx->pipe->bind_gs_state(ctx->pipe, ctx->geometry_shader_saved);
+      ctx->base.pipe->bind_gs_state(ctx->base.pipe, ctx->geometry_shader_saved);
       ctx->geometry_shader = ctx->geometry_shader_saved;
    }
    ctx->geometry_shader_saved = NULL;
@@ -974,7 +967,7 @@ cso_set_tessctrl_shader_handle(struct cso_context *ctx, void *handle)
 
    if (ctx->has_tessellation && ctx->tessctrl_shader != handle) {
       ctx->tessctrl_shader = handle;
-      ctx->pipe->bind_tcs_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_tcs_state(ctx->base.pipe, handle);
    }
 }
 
@@ -999,7 +992,7 @@ cso_restore_tessctrl_shader(struct cso_context *ctx)
    }
 
    if (ctx->tessctrl_shader_saved != ctx->tessctrl_shader) {
-      ctx->pipe->bind_tcs_state(ctx->pipe, ctx->tessctrl_shader_saved);
+      ctx->base.pipe->bind_tcs_state(ctx->base.pipe, ctx->tessctrl_shader_saved);
       ctx->tessctrl_shader = ctx->tessctrl_shader_saved;
    }
    ctx->tessctrl_shader_saved = NULL;
@@ -1013,7 +1006,7 @@ cso_set_tesseval_shader_handle(struct cso_context *ctx, void *handle)
 
    if (ctx->has_tessellation && ctx->tesseval_shader != handle) {
       ctx->tesseval_shader = handle;
-      ctx->pipe->bind_tes_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_tes_state(ctx->base.pipe, handle);
    }
 }
 
@@ -1038,7 +1031,7 @@ cso_restore_tesseval_shader(struct cso_context *ctx)
    }
 
    if (ctx->tesseval_shader_saved != ctx->tesseval_shader) {
-      ctx->pipe->bind_tes_state(ctx->pipe, ctx->tesseval_shader_saved);
+      ctx->base.pipe->bind_tes_state(ctx->base.pipe, ctx->tesseval_shader_saved);
       ctx->tesseval_shader = ctx->tesseval_shader_saved;
    }
    ctx->tesseval_shader_saved = NULL;
@@ -1052,7 +1045,7 @@ cso_set_compute_shader_handle(struct cso_context *ctx, void *handle)
 
    if (ctx->has_compute_shader && ctx->compute_shader != handle) {
       ctx->compute_shader = handle;
-      ctx->pipe->bind_compute_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_compute_state(ctx->base.pipe, handle);
    }
 }
 
@@ -1077,7 +1070,7 @@ cso_restore_compute_shader(struct cso_context *ctx)
    }
 
    if (ctx->compute_shader_saved != ctx->compute_shader) {
-      ctx->pipe->bind_compute_state(ctx->pipe, ctx->compute_shader_saved);
+      ctx->base.pipe->bind_compute_state(ctx->base.pipe, ctx->compute_shader_saved);
       ctx->compute_shader = ctx->compute_shader_saved;
    }
    ctx->compute_shader_saved = NULL;
@@ -1147,7 +1140,7 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
       struct pipe_vertex_element tmp[PIPE_MAX_ATTRIBS];
       util_lower_uint64_vertex_elements(&new_elems, &new_count, tmp);
 
-      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, new_count,
+      cso->data = ctx->base.pipe->create_vertex_elements_state(ctx->base.pipe, new_count,
                                                           new_elems);
 
       iter = cso_insert_state(&ctx->cache, hash_key, CSO_VELEMENTS, cso);
@@ -1163,7 +1156,7 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
 
    if (ctx->velements != handle) {
       ctx->velements = handle;
-      ctx->pipe->bind_vertex_elements_state(ctx->pipe, handle);
+      ctx->base.pipe->bind_vertex_elements_state(ctx->base.pipe, handle);
    }
 }
 
@@ -1211,7 +1204,7 @@ cso_restore_vertex_elements(struct cso_context *ctx)
 
    if (ctx->velements != ctx->velements_saved) {
       ctx->velements = ctx->velements_saved;
-      ctx->pipe->bind_vertex_elements_state(ctx->pipe, ctx->velements_saved);
+      ctx->base.pipe->bind_vertex_elements_state(ctx->base.pipe, ctx->velements_saved);
    }
    ctx->velements_saved = NULL;
 }
@@ -1236,7 +1229,7 @@ cso_set_vertex_buffers(struct cso_context *ctx,
       return;
    }
 
-   struct pipe_context *pipe = ctx->pipe;
+   struct pipe_context *pipe = ctx->base.pipe;
    pipe->set_vertex_buffers(pipe, start_slot, count, unbind_trailing_count,
                             take_ownership, buffers);
 }
@@ -1264,7 +1257,7 @@ cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
                                     const struct pipe_vertex_buffer *vbuffers)
 {
    struct u_vbuf *vbuf = ctx->vbuf;
-   struct pipe_context *pipe = ctx->pipe;
+   struct pipe_context *pipe = ctx->base.pipe;
 
    if (vbuf && (ctx->always_use_vbuf || uses_user_vertex_buffers)) {
       if (!ctx->vbuf_current) {
@@ -1326,7 +1319,7 @@ set_sampler(struct cso_context *ctx, enum pipe_shader_type shader_stage,
          return false;
 
       memcpy(&cso->state, templ, sizeof(*templ));
-      cso->data = ctx->pipe->create_sampler_state(ctx->pipe, &cso->state);
+      cso->data = ctx->base.pipe->create_sampler_state(ctx->base.pipe, &cso->state);
       cso->hash_key = hash_key;
 
       iter = cso_insert_state(&ctx->cache, hash_key, CSO_SAMPLER, cso);
@@ -1385,7 +1378,7 @@ cso_single_sampler_done(struct cso_context *ctx,
    if (ctx->max_sampler_seen == -1)
       return;
 
-   ctx->pipe->bind_sampler_states(ctx->pipe, shader_stage, 0,
+   ctx->base.pipe->bind_sampler_states(ctx->base.pipe, shader_stage, 0,
                                   ctx->max_sampler_seen + 1,
                                   info->samplers);
    ctx->max_sampler_seen = -1;
@@ -1501,7 +1494,7 @@ cso_set_stream_outputs(struct cso_context *ctx,
                        struct pipe_stream_output_target **targets,
                        const unsigned *offsets)
 {
-   struct pipe_context *pipe = ctx->pipe;
+   struct pipe_context *pipe = ctx->base.pipe;
    uint i;
 
    if (!ctx->has_streamout) {
@@ -1548,7 +1541,7 @@ cso_save_stream_outputs(struct cso_context *ctx)
 static void
 cso_restore_stream_outputs(struct cso_context *ctx)
 {
-   struct pipe_context *pipe = ctx->pipe;
+   struct pipe_context *pipe = ctx->base.pipe;
    uint i;
    unsigned offset[PIPE_MAX_SO_BUFFERS];
 
@@ -1628,7 +1621,7 @@ cso_save_state(struct cso_context *cso, unsigned state_mask)
    if (state_mask & CSO_BIT_VIEWPORT)
       cso_save_viewport(cso);
    if (state_mask & CSO_BIT_PAUSE_QUERIES)
-      cso->pipe->set_active_query_state(cso->pipe, false);
+      cso->base.pipe->set_active_query_state(cso->base.pipe, false);
 }
 
 
@@ -1657,15 +1650,15 @@ cso_restore_state(struct cso_context *cso, unsigned unbind)
    if (state_mask & CSO_BIT_VERTEX_SHADER)
       cso_restore_vertex_shader(cso);
    if (unbind & CSO_UNBIND_FS_SAMPLERVIEWS)
-      cso->pipe->set_sampler_views(cso->pipe, PIPE_SHADER_FRAGMENT, 0, 0,
+      cso->base.pipe->set_sampler_views(cso->base.pipe, PIPE_SHADER_FRAGMENT, 0, 0,
                                    cso->max_fs_samplerviews, false, NULL);
    if (unbind & CSO_UNBIND_FS_SAMPLERVIEW0)
-      cso->pipe->set_sampler_views(cso->pipe, PIPE_SHADER_FRAGMENT, 0, 0,
+      cso->base.pipe->set_sampler_views(cso->base.pipe, PIPE_SHADER_FRAGMENT, 0, 0,
                                    1, false, NULL);
    if (state_mask & CSO_BIT_FRAGMENT_SAMPLERS)
       cso_restore_fragment_samplers(cso);
    if (unbind & CSO_UNBIND_FS_IMAGE0)
-      cso->pipe->set_shader_images(cso->pipe, PIPE_SHADER_FRAGMENT, 0, 0, 1, NULL);
+      cso->base.pipe->set_shader_images(cso->base.pipe, PIPE_SHADER_FRAGMENT, 0, 0, 1, NULL);
    if (state_mask & CSO_BIT_FRAMEBUFFER)
       cso_restore_framebuffer(cso);
    if (state_mask & CSO_BIT_BLEND)
@@ -1681,17 +1674,17 @@ cso_restore_state(struct cso_context *cso, unsigned unbind)
    if (state_mask & CSO_BIT_VIEWPORT)
       cso_restore_viewport(cso);
    if (unbind & CSO_UNBIND_VS_CONSTANTS)
-      cso->pipe->set_constant_buffer(cso->pipe, PIPE_SHADER_VERTEX, 0, false, NULL);
+      cso->base.pipe->set_constant_buffer(cso->base.pipe, PIPE_SHADER_VERTEX, 0, false, NULL);
    if (unbind & CSO_UNBIND_FS_CONSTANTS)
-      cso->pipe->set_constant_buffer(cso->pipe, PIPE_SHADER_FRAGMENT, 0, false, NULL);
+      cso->base.pipe->set_constant_buffer(cso->base.pipe, PIPE_SHADER_FRAGMENT, 0, false, NULL);
    if (state_mask & CSO_BIT_VERTEX_ELEMENTS)
       cso_restore_vertex_elements(cso);
    if (unbind & CSO_UNBIND_VERTEX_BUFFER0)
-      cso->pipe->set_vertex_buffers(cso->pipe, 0, 0, 1, false, NULL);
+      cso->base.pipe->set_vertex_buffers(cso->base.pipe, 0, 0, 1, false, NULL);
    if (state_mask & CSO_BIT_STREAM_OUTPUTS)
       cso_restore_stream_outputs(cso);
    if (state_mask & CSO_BIT_PAUSE_QUERIES)
-      cso->pipe->set_active_query_state(cso->pipe, true);
+      cso->base.pipe->set_active_query_state(cso->base.pipe, true);
 
    cso->saved_state = 0;
 }
@@ -1760,7 +1753,7 @@ cso_draw_vbo(struct cso_context *cso,
    /* Indirect only uses indirect->draw_count, not num_draws. */
    assert(!indirect || num_draws == 1);
 
-   struct pipe_context *pipe = cso->pipe;
+   struct pipe_context *pipe = cso->base.pipe;
 
    if (cso->vbuf_current) {
       u_vbuf_draw_vbo(pipe, info, drawid_offset, indirect, draws, num_draws);
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.h b/src/gallium/auxiliary/cso_cache/cso_context.h
index aaa07360bad0..222fc8860e77 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.h
+++ b/src/gallium/auxiliary/cso_cache/cso_context.h
@@ -42,6 +42,10 @@ extern "C" {
 struct cso_context;
 struct u_vbuf;
 
+struct cso_context_base {
+   struct pipe_context *pipe;
+};
+
 #define CSO_NO_USER_VERTEX_BUFFERS (1 << 0)
 #define CSO_NO_64B_VERTEX_BUFFERS  (1 << 1)
 #define CSO_NO_VBUF  (1 << 2)
@@ -55,9 +59,6 @@ cso_unbind_context(struct cso_context *ctx);
 void
 cso_destroy_context(struct cso_context *cso);
 
-struct pipe_context *
-cso_get_pipe_context(struct cso_context *cso);
-
 enum pipe_error
 cso_set_blend(struct cso_context *cso, const struct pipe_blend_state *blend);
 
@@ -225,6 +226,16 @@ cso_draw_arrays_instanced(struct cso_context *cso, uint mode,
 void
 cso_draw_arrays(struct cso_context *cso, uint mode, uint start, uint count);
 
+/* Inline functions. */
+
+static inline struct pipe_context *
+cso_get_pipe_context(struct cso_context *cso)
+{
+   struct cso_context_base *cso_base = (struct cso_context_base *)cso;
+
+   return cso_base->pipe;
+}
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab


From 30e891fbec4914381505cc26a233ea463454413c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 27 Nov 2022 11:28:45 -0500
Subject: [PATCH 5/5] cso: remove cso_draw_vbo from all draws, call the driver
 or u_vbuf directly

Instead of calling like this:
    st_draw_gallium -> cso_draw_vbo -> driver_draw_vbo

Do it like this:
    st_draw_gallium -> driver_draw_vbo
OR
    st_draw_gallium -> u_vbuf_draw_vbo

It's accomplished by adding a draw_vbo function pointer into cso_context.
The pointer is equal to pipe_context::draw_vbo when needed, so there is
no call overhead from this if cso's draw_vbo callback is indeed equal to
driver_draw_vbo. We just call cso_context_base::draw_vbo to jump into
the driver directly, or u_vbuf if needed.

The cso function with the indirect function call is inlined, so draws
don't actually visit any cso_context function.
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 38 +++-------------
 src/gallium/auxiliary/cso_cache/cso_context.h | 43 +++++++++++++++----
 2 files changed, 42 insertions(+), 39 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index c8be6c4410de..d8eef995231d 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -277,6 +277,11 @@ cso_create_context(struct pipe_context *pipe, unsigned flags)
    if (!(flags & CSO_NO_VBUF))
       cso_init_vbuf(ctx, flags);
 
+   if (ctx->vbuf_current)
+      ctx->base.draw_vbo = u_vbuf_draw_vbo;
+   else
+      ctx->base.draw_vbo = pipe->draw_vbo;
+
    /* Enable for testing: */
    if (0) cso_set_maximum_cache_size(&ctx->cache, 4);
 
@@ -1269,6 +1274,7 @@ cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
          /* Unset this to make sure the CSO is re-bound on the next use. */
          ctx->velements = NULL;
          ctx->vbuf_current = vbuf;
+         ctx->base.draw_vbo = u_vbuf_draw_vbo;
          unbind_trailing_vb_count = 0;
       }
 
@@ -1290,6 +1296,7 @@ cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
       /* Unset this to make sure the CSO is re-bound on the next use. */
       u_vbuf_unset_vertex_elements(vbuf);
       ctx->vbuf_current = NULL;
+      ctx->base.draw_vbo = pipe->draw_vbo;
       unbind_trailing_vb_count = 0;
    }
 
@@ -1732,37 +1739,6 @@ cso_restore_compute_state(struct cso_context *cso)
 
 /* drawing */
 
-void
-cso_draw_vbo(struct cso_context *cso,
-             struct pipe_draw_info *info,
-             unsigned drawid_offset,
-             const struct pipe_draw_indirect_info *indirect,
-             const struct pipe_draw_start_count_bias *draws,
-             unsigned num_draws)
-{
-   /* We can't have both indirect drawing and SO-vertex-count drawing */
-   assert(!indirect ||
-          indirect->buffer == NULL ||
-          indirect->count_from_stream_output == NULL);
-
-   /* We can't have SO-vertex-count drawing with an index buffer */
-   assert(info->index_size == 0 ||
-          !indirect ||
-          indirect->count_from_stream_output == NULL);
-
-   /* Indirect only uses indirect->draw_count, not num_draws. */
-   assert(!indirect || num_draws == 1);
-
-   struct pipe_context *pipe = cso->base.pipe;
-
-   if (cso->vbuf_current) {
-      u_vbuf_draw_vbo(pipe, info, drawid_offset, indirect, draws, num_draws);
-   } else {
-      pipe->draw_vbo(pipe, info, drawid_offset, indirect, draws, num_draws);
-   }
-}
-
-
 void
 cso_draw_arrays(struct cso_context *cso, uint mode, uint start, uint count)
 {
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.h b/src/gallium/auxiliary/cso_cache/cso_context.h
index 222fc8860e77..85f98644d1e5 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.h
+++ b/src/gallium/auxiliary/cso_cache/cso_context.h
@@ -44,6 +44,14 @@ struct u_vbuf;
 
 struct cso_context_base {
    struct pipe_context *pipe;
+
+   /* This is equal to either pipe_context::draw_vbo or u_vbuf_draw_vbo. */
+   void (*draw_vbo)(struct pipe_context *pipe,
+                    const struct pipe_draw_info *info,
+                    unsigned drawid_offset,
+                    const struct pipe_draw_indirect_info *indirect,
+                    const struct pipe_draw_start_count_bias *draws,
+                    unsigned num_draws);
 };
 
 #define CSO_NO_USER_VERTEX_BUFFERS (1 << 0)
@@ -210,14 +218,6 @@ cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
                                     bool uses_user_vertex_buffers,
                                     const struct pipe_vertex_buffer *vbuffers);
 
-void
-cso_draw_vbo(struct cso_context *cso,
-             struct pipe_draw_info *info,
-             unsigned drawid_offset,
-             const struct pipe_draw_indirect_info *indirect,
-             const struct pipe_draw_start_count_bias *draws,
-             unsigned num_draws);
-
 void
 cso_draw_arrays_instanced(struct cso_context *cso, uint mode,
                           uint start, uint count,
@@ -236,6 +236,33 @@ cso_get_pipe_context(struct cso_context *cso)
    return cso_base->pipe;
 }
 
+static ALWAYS_INLINE void
+cso_draw_vbo(struct cso_context *cso,
+             struct pipe_draw_info *info,
+             unsigned drawid_offset,
+             const struct pipe_draw_indirect_info *indirect,
+             const struct pipe_draw_start_count_bias *draws,
+             unsigned num_draws)
+{
+   /* We can't have both indirect drawing and SO-vertex-count drawing */
+   assert(!indirect ||
+          indirect->buffer == NULL ||
+          indirect->count_from_stream_output == NULL);
+
+   /* We can't have SO-vertex-count drawing with an index buffer */
+   assert(info->index_size == 0 ||
+          !indirect ||
+          indirect->count_from_stream_output == NULL);
+
+   /* Indirect only uses indirect->draw_count, not num_draws. */
+   assert(!indirect || num_draws == 1);
+
+   struct cso_context_base *cso_base = (struct cso_context_base *)cso;
+
+   cso_base->draw_vbo(cso_base->pipe, info, drawid_offset, indirect, draws,
+                      num_draws);
+}
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab

