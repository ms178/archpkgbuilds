From 996ffa605f9fa5486dce3f8e0a65ccacfa89a88f Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 19 Feb 2024 00:26:43 +0100
Subject: [PATCH 1/6] radv: Add winsys argument to buffer map/unmap.

To use later.
---
 src/amd/vulkan/radv_cmd_buffer.c              | 2 +-
 src/amd/vulkan/radv_cp_reg_shadowing.c        | 4 ++--
 src/amd/vulkan/radv_debug.c                   | 4 ++--
 src/amd/vulkan/radv_descriptor_set.c          | 2 +-
 src/amd/vulkan/radv_device.c                  | 2 +-
 src/amd/vulkan/radv_device_memory.c           | 4 ++--
 src/amd/vulkan/radv_event.c                   | 2 +-
 src/amd/vulkan/radv_query.c                   | 2 +-
 src/amd/vulkan/radv_queue.c                   | 8 ++++----
 src/amd/vulkan/radv_radeon_winsys.h           | 4 ++--
 src/amd/vulkan/radv_shader.c                  | 4 ++--
 src/amd/vulkan/radv_spm.c                     | 2 +-
 src/amd/vulkan/radv_sqtt.c                    | 4 ++--
 src/amd/vulkan/si_cmd_buffer.c                | 4 ++--
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c | 4 ++--
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c | 8 ++++----
 src/amd/vulkan/winsys/null/radv_null_bo.c     | 4 ++--
 17 files changed, 32 insertions(+), 32 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6452b3e41800d..463f5c55d95ec 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -521,7 +521,7 @@ radv_cmd_buffer_resize_upload_buf(struct radv_cmd_buffer *cmd_buffer, uint64_t m
    cmd_buffer->upload.upload_bo = bo;
    cmd_buffer->upload.size = new_size;
    cmd_buffer->upload.offset = 0;
-   cmd_buffer->upload.map = device->ws->buffer_map(cmd_buffer->upload.upload_bo);
+   cmd_buffer->upload.map = device->ws->buffer_map(device->ws, cmd_buffer->upload.upload_bo);
 
    if (!cmd_buffer->upload.map) {
       vk_command_buffer_set_error(&cmd_buffer->vk, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_cp_reg_shadowing.c b/src/amd/vulkan/radv_cp_reg_shadowing.c
index f846bf51b3390..b19a276d75582 100644
--- a/src/amd/vulkan/radv_cp_reg_shadowing.c
+++ b/src/amd/vulkan/radv_cp_reg_shadowing.c
@@ -76,7 +76,7 @@ radv_create_shadow_regs_preamble(const struct radv_device *device, struct radv_q
    /* copy the cs to queue_state->shadow_regs_ib. This will be the first preamble ib
     * added in radv_update_preamble_cs.
     */
-   void *map = ws->buffer_map(queue_state->shadow_regs_ib);
+   void *map = ws->buffer_map(ws, queue_state->shadow_regs_ib);
    if (!map) {
       result = VK_ERROR_MEMORY_MAP_FAILED;
       goto fail_map;
@@ -84,7 +84,7 @@ radv_create_shadow_regs_preamble(const struct radv_device *device, struct radv_q
    memcpy(map, cs->buf, cs->cdw * 4);
    queue_state->shadow_regs_ib_size_dw = cs->cdw;
 
-   ws->buffer_unmap(queue_state->shadow_regs_ib);
+   ws->buffer_unmap(ws, queue_state->shadow_regs_ib);
    ws->cs_destroy(cs);
    return VK_SUCCESS;
 fail_map:
diff --git a/src/amd/vulkan/radv_debug.c b/src/amd/vulkan/radv_debug.c
index b6243a10e2439..dbd93efa4f56d 100644
--- a/src/amd/vulkan/radv_debug.c
+++ b/src/amd/vulkan/radv_debug.c
@@ -80,7 +80,7 @@ radv_init_trace(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->trace_id_ptr = ws->buffer_map(device->trace_bo);
+   device->trace_id_ptr = ws->buffer_map(ws, device->trace_bo);
    if (!device->trace_id_ptr)
       return false;
 
@@ -920,7 +920,7 @@ radv_trap_handler_init(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->tma_ptr = ws->buffer_map(device->tma_bo);
+   device->tma_ptr = ws->buffer_map(ws, device->tma_bo);
    if (!device->tma_ptr)
       return false;
 
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index e0a4afa1de20d..331c19eba6fd9 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -922,7 +922,7 @@ radv_create_descriptor_pool(struct radv_device *device, const VkDescriptorPoolCr
             radv_destroy_descriptor_pool(device, pAllocator, pool);
             return vk_error(device, result);
          }
-         pool->mapped_ptr = (uint8_t *)device->ws->buffer_map(pool->bo);
+         pool->mapped_ptr = (uint8_t *)device->ws->buffer_map(device->ws, pool->bo);
          if (!pool->mapped_ptr) {
             radv_destroy_descriptor_pool(device, pAllocator, pool);
             return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index e4b7247175845..8648cbe6a917c 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -141,7 +141,7 @@ radv_device_init_border_color(struct radv_device *device)
    if (result != VK_SUCCESS)
       return vk_error(device, result);
 
-   device->border_color_data.colors_gpu_ptr = device->ws->buffer_map(device->border_color_data.bo);
+   device->border_color_data.colors_gpu_ptr = device->ws->buffer_map(device->ws, device->border_color_data.bo);
    if (!device->border_color_data.colors_gpu_ptr)
       return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
    mtx_init(&device->border_color_data.mutex, mtx_plain);
diff --git a/src/amd/vulkan/radv_device_memory.c b/src/amd/vulkan/radv_device_memory.c
index 180583573da02..23d07ef39425f 100644
--- a/src/amd/vulkan/radv_device_memory.c
+++ b/src/amd/vulkan/radv_device_memory.c
@@ -300,7 +300,7 @@ radv_MapMemory2KHR(VkDevice _device, const VkMemoryMapInfoKHR *pMemoryMapInfo, v
    if (mem->user_ptr)
       *ppData = mem->user_ptr;
    else
-      *ppData = device->ws->buffer_map(mem->bo);
+      *ppData = device->ws->buffer_map(device->ws, mem->bo);
 
    if (*ppData) {
       vk_rmv_log_cpu_map(&device->vk, mem->bo->va, false);
@@ -319,7 +319,7 @@ radv_UnmapMemory2KHR(VkDevice _device, const VkMemoryUnmapInfoKHR *pMemoryUnmapI
 
    vk_rmv_log_cpu_map(&device->vk, mem->bo->va, true);
    if (mem->user_ptr == NULL)
-      device->ws->buffer_unmap(mem->bo);
+      device->ws->buffer_unmap(device->ws, mem->bo);
 
    return VK_SUCCESS;
 }
diff --git a/src/amd/vulkan/radv_event.c b/src/amd/vulkan/radv_event.c
index 56414dc2dfa90..653e2c2e9ac17 100644
--- a/src/amd/vulkan/radv_event.c
+++ b/src/amd/vulkan/radv_event.c
@@ -69,7 +69,7 @@ radv_create_event(struct radv_device *device, const VkEventCreateInfo *pCreateIn
    }
 
    if (!(pCreateInfo->flags & VK_EVENT_CREATE_DEVICE_ONLY_BIT)) {
-      event->map = (uint64_t *)device->ws->buffer_map(event->bo);
+      event->map = (uint64_t *)device->ws->buffer_map(device->ws, event->bo);
       if (!event->map) {
          radv_destroy_event(device, pAllocator, event);
          return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 74e9efddcc361..3b3425d5e8283 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1301,7 +1301,7 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
       return vk_error(device, result);
    }
 
-   pool->ptr = device->ws->buffer_map(pool->bo);
+   pool->ptr = device->ws->buffer_map(device->ws, pool->bo);
    if (!pool->ptr) {
       radv_destroy_query_pool(device, pAllocator, pool);
       return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index 0120c7aa1d87a..355089731248f 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -577,7 +577,7 @@ radv_emit_tess_factor_ring(struct radv_device *device, struct radeon_cmdbuf *cs,
 static VkResult
 radv_initialise_task_control_buffer(struct radv_device *device, struct radeon_winsys_bo *task_rings_bo)
 {
-   uint32_t *ptr = (uint32_t *)device->ws->buffer_map(task_rings_bo);
+   uint32_t *ptr = (uint32_t *)device->ws->buffer_map(device->ws, task_rings_bo);
    if (!ptr)
       return VK_ERROR_OUT_OF_DEVICE_MEMORY;
 
@@ -601,7 +601,7 @@ radv_initialise_task_control_buffer(struct radv_device *device, struct radeon_wi
    ptr[7] = task_draw_ring_va;
    ptr[8] = task_draw_ring_va >> 32;
 
-   device->ws->buffer_unmap(task_rings_bo);
+   device->ws->buffer_unmap(device->ws, task_rings_bo);
    return VK_SUCCESS;
 }
 
@@ -982,7 +982,7 @@ radv_update_preamble_cs(struct radv_queue_state *queue, struct radv_device *devi
    }
 
    if (descriptor_bo != queue->descriptor_bo) {
-      uint32_t *map = (uint32_t *)ws->buffer_map(descriptor_bo);
+      uint32_t *map = (uint32_t *)ws->buffer_map(ws, descriptor_bo);
       if (!map) {
          result = VK_ERROR_OUT_OF_DEVICE_MEMORY;
          goto fail;
@@ -992,7 +992,7 @@ radv_update_preamble_cs(struct radv_queue_state *queue, struct radv_device *devi
                              gsvs_ring_bo, tess_rings_bo, task_rings_bo, mesh_scratch_ring_bo, needs->attr_ring_size,
                              attr_ring_bo);
 
-      ws->buffer_unmap(descriptor_bo);
+      ws->buffer_unmap(ws, descriptor_bo);
    }
 
    for (int i = 0; i < 3; ++i) {
diff --git a/src/amd/vulkan/radv_radeon_winsys.h b/src/amd/vulkan/radv_radeon_winsys.h
index 33454960b92ae..d68366a839f19 100644
--- a/src/amd/vulkan/radv_radeon_winsys.h
+++ b/src/amd/vulkan/radv_radeon_winsys.h
@@ -251,7 +251,7 @@ struct radeon_winsys {
                              struct radeon_winsys_bo **out_bo);
 
    void (*buffer_destroy)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo);
-   void *(*buffer_map)(struct radeon_winsys_bo *bo);
+   void *(*buffer_map)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo);
 
    VkResult (*buffer_from_ptr)(struct radeon_winsys *ws, void *pointer, uint64_t size, unsigned priority,
                                struct radeon_winsys_bo **out_bo);
@@ -264,7 +264,7 @@ struct radeon_winsys {
    bool (*buffer_get_flags_from_fd)(struct radeon_winsys *ws, int fd, enum radeon_bo_domain *domains,
                                     enum radeon_bo_flag *flags);
 
-   void (*buffer_unmap)(struct radeon_winsys_bo *bo);
+   void (*buffer_unmap)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo);
 
    void (*buffer_set_metadata)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, struct radeon_bo_metadata *md);
    void (*buffer_get_metadata)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, struct radeon_bo_metadata *md);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 8af1dac0fb8af..684ce48f23edf 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1014,7 +1014,7 @@ radv_create_shader_arena(struct radv_device *device, struct radv_shader_free_lis
       add_hole(free_list, alloc);
 
    if (!(flags & RADEON_FLAG_NO_CPU_ACCESS)) {
-      arena->ptr = (char *)device->ws->buffer_map(arena->bo);
+      arena->ptr = (char *)device->ws->buffer_map(device->ws, arena->bo);
       if (!arena->ptr)
          goto fail;
    }
@@ -1949,7 +1949,7 @@ radv_shader_dma_resize_upload_buf(struct radv_shader_dma_submission *submission,
    if (result != VK_SUCCESS)
       return result;
 
-   submission->ptr = ws->buffer_map(submission->bo);
+   submission->ptr = ws->buffer_map(ws, submission->bo);
    submission->bo_size = size;
 
    return VK_SUCCESS;
diff --git a/src/amd/vulkan/radv_spm.c b/src/amd/vulkan/radv_spm.c
index ba8b7057fc503..9ecfa9f50b48a 100644
--- a/src/amd/vulkan/radv_spm.c
+++ b/src/amd/vulkan/radv_spm.c
@@ -52,7 +52,7 @@ radv_spm_init_bo(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->spm.ptr = ws->buffer_map(device->spm.bo);
+   device->spm.ptr = ws->buffer_map(ws, device->spm.bo);
    if (!device->spm.ptr)
       return false;
 
diff --git a/src/amd/vulkan/radv_sqtt.c b/src/amd/vulkan/radv_sqtt.c
index 20151460c11f0..6f1f4ef284840 100644
--- a/src/amd/vulkan/radv_sqtt.c
+++ b/src/amd/vulkan/radv_sqtt.c
@@ -512,7 +512,7 @@ radv_sqtt_acquire_gpu_timestamp(struct radv_device *device, struct radeon_winsys
          return result;
       }
 
-      map = device->ws->buffer_map(bo);
+      map = device->ws->buffer_map(device->ws, bo);
       if (!map) {
          ws->buffer_destroy(ws, bo);
          simple_mtx_unlock(&device->sqtt_timestamp_mtx);
@@ -652,7 +652,7 @@ radv_sqtt_init_bo(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->sqtt.ptr = ws->buffer_map(device->sqtt.bo);
+   device->sqtt.ptr = ws->buffer_map(ws, device->sqtt.bo);
    if (!device->sqtt.ptr)
       return false;
 
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 9fb6c1b5f90f0..e9215549fbaa5 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -645,7 +645,7 @@ radv_create_gfx_config(struct radv_device *device)
    if (result != VK_SUCCESS)
       goto fail;
 
-   void *map = device->ws->buffer_map(device->gfx_init);
+   void *map = device->ws->buffer_map(device->ws, device->gfx_init);
    if (!map) {
       device->ws->buffer_destroy(device->ws, device->gfx_init);
       device->gfx_init = NULL;
@@ -653,7 +653,7 @@ radv_create_gfx_config(struct radv_device *device)
    }
    memcpy(map, cs->buf, cs->cdw * 4);
 
-   device->ws->buffer_unmap(device->gfx_init);
+   device->ws->buffer_unmap(device->ws, device->gfx_init);
    device->gfx_init_size_dw = cs->cdw;
 fail:
    device->ws->cs_destroy(cs);
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
index 1a32f9b58d7fc..4d6139204eb56 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
@@ -560,7 +560,7 @@ error_va_alloc:
 }
 
 static void *
-radv_amdgpu_winsys_bo_map(struct radeon_winsys_bo *_bo)
+radv_amdgpu_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
 {
    struct radv_amdgpu_winsys_bo *bo = radv_amdgpu_winsys_bo(_bo);
    int ret;
@@ -572,7 +572,7 @@ radv_amdgpu_winsys_bo_map(struct radeon_winsys_bo *_bo)
 }
 
 static void
-radv_amdgpu_winsys_bo_unmap(struct radeon_winsys_bo *_bo)
+radv_amdgpu_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
 {
    struct radv_amdgpu_winsys_bo *bo = radv_amdgpu_winsys_bo(_bo);
    amdgpu_bo_cpu_unmap(bo->bo);
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index 889284f932f7f..6d2e886b365d5 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -272,7 +272,7 @@ radv_amdgpu_cs_get_new_ib(struct radeon_cmdbuf *_cs, uint32_t ib_size)
    if (result != VK_SUCCESS)
       return result;
 
-   cs->ib_mapped = cs->ws->base.buffer_map(cs->ib_buffer);
+   cs->ib_mapped = cs->ws->base.buffer_map(&cs->ws->base, cs->ib_buffer);
    if (!cs->ib_mapped) {
       cs->ws->base.buffer_destroy(&cs->ws->base, cs->ib_buffer);
       return VK_ERROR_OUT_OF_DEVICE_MEMORY;
@@ -404,7 +404,7 @@ radv_amdgpu_cs_grow(struct radeon_cmdbuf *_cs, size_t min_size)
       radv_amdgpu_restore_last_ib(cs);
    }
 
-   cs->ib_mapped = cs->ws->base.buffer_map(cs->ib_buffer);
+   cs->ib_mapped = cs->ws->base.buffer_map(&cs->ws->base, cs->ib_buffer);
    if (!cs->ib_mapped) {
       cs->ws->base.buffer_destroy(&cs->ws->base, cs->ib_buffer);
       cs->base.cdw = 0;
@@ -748,7 +748,7 @@ radv_amdgpu_cs_execute_secondary(struct radeon_cmdbuf *_parent, struct radeon_cm
 
          parent->base.reserved_dw = MAX2(parent->base.reserved_dw, parent->base.cdw + cdw);
 
-         mapped = ws->base.buffer_map(ib->bo);
+         mapped = ws->base.buffer_map(&ws->base, ib->bo);
          if (!mapped) {
             parent->status = VK_ERROR_OUT_OF_DEVICE_MEMORY;
             return;
@@ -1400,7 +1400,7 @@ radv_amdgpu_winsys_cs_dump(struct radeon_cmdbuf *_cs, FILE *file, const int *tra
          char name[64];
          void *mapped;
 
-         mapped = ws->base.buffer_map(ib->bo);
+         mapped = ws->base.buffer_map(&ws->base, ib->bo);
          if (!mapped)
             continue;
 
diff --git a/src/amd/vulkan/winsys/null/radv_null_bo.c b/src/amd/vulkan/winsys/null/radv_null_bo.c
index a13a75c8cb4e9..621c0bdb67e5e 100644
--- a/src/amd/vulkan/winsys/null/radv_null_bo.c
+++ b/src/amd/vulkan/winsys/null/radv_null_bo.c
@@ -54,14 +54,14 @@ error_ptr_alloc:
 }
 
 static void *
-radv_null_winsys_bo_map(struct radeon_winsys_bo *_bo)
+radv_null_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
 {
    struct radv_null_winsys_bo *bo = radv_null_winsys_bo(_bo);
    return bo->ptr;
 }
 
 static void
-radv_null_winsys_bo_unmap(struct radeon_winsys_bo *_bo)
+radv_null_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
 {
 }
 
-- 
GitLab


From d92f5ed26a704b030e45d8cff27b03567661ade1 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 19 Feb 2024 00:53:01 +0100
Subject: [PATCH 2/6] radv/winsys: Use radv_buffer_map wrapper.

So we can have 1 function ptr and then have a version with default
args.
---
 src/amd/vulkan/radv_cmd_buffer.c              | 2 +-
 src/amd/vulkan/radv_cp_reg_shadowing.c        | 2 +-
 src/amd/vulkan/radv_debug.c                   | 4 ++--
 src/amd/vulkan/radv_descriptor_set.c          | 2 +-
 src/amd/vulkan/radv_device.c                  | 2 +-
 src/amd/vulkan/radv_device_memory.c           | 2 +-
 src/amd/vulkan/radv_event.c                   | 2 +-
 src/amd/vulkan/radv_query.c                   | 2 +-
 src/amd/vulkan/radv_queue.c                   | 4 ++--
 src/amd/vulkan/radv_radeon_winsys.h           | 6 ++++++
 src/amd/vulkan/radv_shader.c                  | 4 ++--
 src/amd/vulkan/radv_spm.c                     | 2 +-
 src/amd/vulkan/radv_sqtt.c                    | 4 ++--
 src/amd/vulkan/si_cmd_buffer.c                | 2 +-
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c | 8 ++++----
 15 files changed, 27 insertions(+), 21 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 463f5c55d95ec..0e14d73de0861 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -521,7 +521,7 @@ radv_cmd_buffer_resize_upload_buf(struct radv_cmd_buffer *cmd_buffer, uint64_t m
    cmd_buffer->upload.upload_bo = bo;
    cmd_buffer->upload.size = new_size;
    cmd_buffer->upload.offset = 0;
-   cmd_buffer->upload.map = device->ws->buffer_map(device->ws, cmd_buffer->upload.upload_bo);
+   cmd_buffer->upload.map = radv_buffer_map(device->ws, cmd_buffer->upload.upload_bo);
 
    if (!cmd_buffer->upload.map) {
       vk_command_buffer_set_error(&cmd_buffer->vk, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_cp_reg_shadowing.c b/src/amd/vulkan/radv_cp_reg_shadowing.c
index b19a276d75582..e6f57d768a7f9 100644
--- a/src/amd/vulkan/radv_cp_reg_shadowing.c
+++ b/src/amd/vulkan/radv_cp_reg_shadowing.c
@@ -76,7 +76,7 @@ radv_create_shadow_regs_preamble(const struct radv_device *device, struct radv_q
    /* copy the cs to queue_state->shadow_regs_ib. This will be the first preamble ib
     * added in radv_update_preamble_cs.
     */
-   void *map = ws->buffer_map(ws, queue_state->shadow_regs_ib);
+   void *map = radv_buffer_map(ws, queue_state->shadow_regs_ib);
    if (!map) {
       result = VK_ERROR_MEMORY_MAP_FAILED;
       goto fail_map;
diff --git a/src/amd/vulkan/radv_debug.c b/src/amd/vulkan/radv_debug.c
index dbd93efa4f56d..2e89db5f728e6 100644
--- a/src/amd/vulkan/radv_debug.c
+++ b/src/amd/vulkan/radv_debug.c
@@ -80,7 +80,7 @@ radv_init_trace(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->trace_id_ptr = ws->buffer_map(ws, device->trace_bo);
+   device->trace_id_ptr = radv_buffer_map(ws, device->trace_bo);
    if (!device->trace_id_ptr)
       return false;
 
@@ -920,7 +920,7 @@ radv_trap_handler_init(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->tma_ptr = ws->buffer_map(ws, device->tma_bo);
+   device->tma_ptr = radv_buffer_map(ws, device->tma_bo);
    if (!device->tma_ptr)
       return false;
 
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 331c19eba6fd9..bac65868e5297 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -922,7 +922,7 @@ radv_create_descriptor_pool(struct radv_device *device, const VkDescriptorPoolCr
             radv_destroy_descriptor_pool(device, pAllocator, pool);
             return vk_error(device, result);
          }
-         pool->mapped_ptr = (uint8_t *)device->ws->buffer_map(device->ws, pool->bo);
+         pool->mapped_ptr = (uint8_t *)radv_buffer_map(device->ws, pool->bo);
          if (!pool->mapped_ptr) {
             radv_destroy_descriptor_pool(device, pAllocator, pool);
             return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 8648cbe6a917c..aae998c295c8c 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -141,7 +141,7 @@ radv_device_init_border_color(struct radv_device *device)
    if (result != VK_SUCCESS)
       return vk_error(device, result);
 
-   device->border_color_data.colors_gpu_ptr = device->ws->buffer_map(device->ws, device->border_color_data.bo);
+   device->border_color_data.colors_gpu_ptr = radv_buffer_map(device->ws, device->border_color_data.bo);
    if (!device->border_color_data.colors_gpu_ptr)
       return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
    mtx_init(&device->border_color_data.mutex, mtx_plain);
diff --git a/src/amd/vulkan/radv_device_memory.c b/src/amd/vulkan/radv_device_memory.c
index 23d07ef39425f..e4c0037d34136 100644
--- a/src/amd/vulkan/radv_device_memory.c
+++ b/src/amd/vulkan/radv_device_memory.c
@@ -300,7 +300,7 @@ radv_MapMemory2KHR(VkDevice _device, const VkMemoryMapInfoKHR *pMemoryMapInfo, v
    if (mem->user_ptr)
       *ppData = mem->user_ptr;
    else
-      *ppData = device->ws->buffer_map(device->ws, mem->bo);
+      *ppData = radv_buffer_map(device->ws, mem->bo);
 
    if (*ppData) {
       vk_rmv_log_cpu_map(&device->vk, mem->bo->va, false);
diff --git a/src/amd/vulkan/radv_event.c b/src/amd/vulkan/radv_event.c
index 653e2c2e9ac17..ad27d2210642b 100644
--- a/src/amd/vulkan/radv_event.c
+++ b/src/amd/vulkan/radv_event.c
@@ -69,7 +69,7 @@ radv_create_event(struct radv_device *device, const VkEventCreateInfo *pCreateIn
    }
 
    if (!(pCreateInfo->flags & VK_EVENT_CREATE_DEVICE_ONLY_BIT)) {
-      event->map = (uint64_t *)device->ws->buffer_map(device->ws, event->bo);
+      event->map = (uint64_t *)radv_buffer_map(device->ws, event->bo);
       if (!event->map) {
          radv_destroy_event(device, pAllocator, event);
          return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 3b3425d5e8283..42137c3a20627 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1301,7 +1301,7 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
       return vk_error(device, result);
    }
 
-   pool->ptr = device->ws->buffer_map(device->ws, pool->bo);
+   pool->ptr = radv_buffer_map(device->ws, pool->bo);
    if (!pool->ptr) {
       radv_destroy_query_pool(device, pAllocator, pool);
       return vk_error(device, VK_ERROR_OUT_OF_DEVICE_MEMORY);
diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index 355089731248f..fca844400a185 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -577,7 +577,7 @@ radv_emit_tess_factor_ring(struct radv_device *device, struct radeon_cmdbuf *cs,
 static VkResult
 radv_initialise_task_control_buffer(struct radv_device *device, struct radeon_winsys_bo *task_rings_bo)
 {
-   uint32_t *ptr = (uint32_t *)device->ws->buffer_map(device->ws, task_rings_bo);
+   uint32_t *ptr = (uint32_t *)radv_buffer_map(device->ws, task_rings_bo);
    if (!ptr)
       return VK_ERROR_OUT_OF_DEVICE_MEMORY;
 
@@ -982,7 +982,7 @@ radv_update_preamble_cs(struct radv_queue_state *queue, struct radv_device *devi
    }
 
    if (descriptor_bo != queue->descriptor_bo) {
-      uint32_t *map = (uint32_t *)ws->buffer_map(ws, descriptor_bo);
+      uint32_t *map = (uint32_t *)radv_buffer_map(ws, descriptor_bo);
       if (!map) {
          result = VK_ERROR_OUT_OF_DEVICE_MEMORY;
          goto fail;
diff --git a/src/amd/vulkan/radv_radeon_winsys.h b/src/amd/vulkan/radv_radeon_winsys.h
index d68366a839f19..f599dca540c6c 100644
--- a/src/amd/vulkan/radv_radeon_winsys.h
+++ b/src/amd/vulkan/radv_radeon_winsys.h
@@ -360,4 +360,10 @@ radv_cs_add_buffer(struct radeon_winsys *ws, struct radeon_cmdbuf *cs, struct ra
    ws->cs_add_buffer(cs, bo);
 }
 
+static inline void *
+radv_buffer_map(struct radeon_winsys *ws, struct radeon_winsys_bo *bo)
+{
+   return ws->buffer_map(ws, bo);
+}
+
 #endif /* RADV_RADEON_WINSYS_H */
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 684ce48f23edf..5750774c08d6b 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1014,7 +1014,7 @@ radv_create_shader_arena(struct radv_device *device, struct radv_shader_free_lis
       add_hole(free_list, alloc);
 
    if (!(flags & RADEON_FLAG_NO_CPU_ACCESS)) {
-      arena->ptr = (char *)device->ws->buffer_map(device->ws, arena->bo);
+      arena->ptr = (char *)radv_buffer_map(device->ws, arena->bo);
       if (!arena->ptr)
          goto fail;
    }
@@ -1949,7 +1949,7 @@ radv_shader_dma_resize_upload_buf(struct radv_shader_dma_submission *submission,
    if (result != VK_SUCCESS)
       return result;
 
-   submission->ptr = ws->buffer_map(ws, submission->bo);
+   submission->ptr = radv_buffer_map(ws, submission->bo);
    submission->bo_size = size;
 
    return VK_SUCCESS;
diff --git a/src/amd/vulkan/radv_spm.c b/src/amd/vulkan/radv_spm.c
index 9ecfa9f50b48a..a7b76db2c8e34 100644
--- a/src/amd/vulkan/radv_spm.c
+++ b/src/amd/vulkan/radv_spm.c
@@ -52,7 +52,7 @@ radv_spm_init_bo(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->spm.ptr = ws->buffer_map(ws, device->spm.bo);
+   device->spm.ptr = radv_buffer_map(ws, device->spm.bo);
    if (!device->spm.ptr)
       return false;
 
diff --git a/src/amd/vulkan/radv_sqtt.c b/src/amd/vulkan/radv_sqtt.c
index 6f1f4ef284840..c06cb1ba8bd9c 100644
--- a/src/amd/vulkan/radv_sqtt.c
+++ b/src/amd/vulkan/radv_sqtt.c
@@ -512,7 +512,7 @@ radv_sqtt_acquire_gpu_timestamp(struct radv_device *device, struct radeon_winsys
          return result;
       }
 
-      map = device->ws->buffer_map(device->ws, bo);
+      map = radv_buffer_map(device->ws, bo);
       if (!map) {
          ws->buffer_destroy(ws, bo);
          simple_mtx_unlock(&device->sqtt_timestamp_mtx);
@@ -652,7 +652,7 @@ radv_sqtt_init_bo(struct radv_device *device)
    if (result != VK_SUCCESS)
       return false;
 
-   device->sqtt.ptr = ws->buffer_map(ws, device->sqtt.bo);
+   device->sqtt.ptr = radv_buffer_map(ws, device->sqtt.bo);
    if (!device->sqtt.ptr)
       return false;
 
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index e9215549fbaa5..a604d6e3d321d 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -645,7 +645,7 @@ radv_create_gfx_config(struct radv_device *device)
    if (result != VK_SUCCESS)
       goto fail;
 
-   void *map = device->ws->buffer_map(device->ws, device->gfx_init);
+   void *map = radv_buffer_map(device->ws, device->gfx_init);
    if (!map) {
       device->ws->buffer_destroy(device->ws, device->gfx_init);
       device->gfx_init = NULL;
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index 6d2e886b365d5..138fb96da4343 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -272,7 +272,7 @@ radv_amdgpu_cs_get_new_ib(struct radeon_cmdbuf *_cs, uint32_t ib_size)
    if (result != VK_SUCCESS)
       return result;
 
-   cs->ib_mapped = cs->ws->base.buffer_map(&cs->ws->base, cs->ib_buffer);
+   cs->ib_mapped = radv_buffer_map(&cs->ws->base, cs->ib_buffer);
    if (!cs->ib_mapped) {
       cs->ws->base.buffer_destroy(&cs->ws->base, cs->ib_buffer);
       return VK_ERROR_OUT_OF_DEVICE_MEMORY;
@@ -404,7 +404,7 @@ radv_amdgpu_cs_grow(struct radeon_cmdbuf *_cs, size_t min_size)
       radv_amdgpu_restore_last_ib(cs);
    }
 
-   cs->ib_mapped = cs->ws->base.buffer_map(&cs->ws->base, cs->ib_buffer);
+   cs->ib_mapped = radv_buffer_map(&cs->ws->base, cs->ib_buffer);
    if (!cs->ib_mapped) {
       cs->ws->base.buffer_destroy(&cs->ws->base, cs->ib_buffer);
       cs->base.cdw = 0;
@@ -748,7 +748,7 @@ radv_amdgpu_cs_execute_secondary(struct radeon_cmdbuf *_parent, struct radeon_cm
 
          parent->base.reserved_dw = MAX2(parent->base.reserved_dw, parent->base.cdw + cdw);
 
-         mapped = ws->base.buffer_map(&ws->base, ib->bo);
+         mapped = radv_buffer_map(&ws->base, ib->bo);
          if (!mapped) {
             parent->status = VK_ERROR_OUT_OF_DEVICE_MEMORY;
             return;
@@ -1400,7 +1400,7 @@ radv_amdgpu_winsys_cs_dump(struct radeon_cmdbuf *_cs, FILE *file, const int *tra
          char name[64];
          void *mapped;
 
-         mapped = ws->base.buffer_map(&ws->base, ib->bo);
+         mapped = radv_buffer_map(&ws->base, ib->bo);
          if (!mapped)
             continue;
 
-- 
GitLab


From 204393ccbe0eababbebd1e44cc3b4a8e8a2f9e91 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 19 Feb 2024 00:39:05 +0100
Subject: [PATCH 3/6] radv/amdgpu: Use mmap directly.

To give more control.
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c | 40 +++++++++++++++++--
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h |  2 +
 2 files changed, 38 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
index 4d6139204eb56..2b2f71b03bdc0 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
@@ -35,7 +35,9 @@
 #include <inttypes.h>
 #include <pthread.h>
 #include <unistd.h>
+#include <xf86drm.h>
 #include "drm-uapi/amdgpu_drm.h"
+#include <sys/mman.h>
 
 #include "util/os_time.h"
 #include "util/u_atomic.h"
@@ -344,6 +346,9 @@ radv_amdgpu_winsys_bo_destroy(struct radeon_winsys *_ws, struct radeon_winsys_bo
       free(bo->ranges);
       u_rwlock_destroy(&bo->lock);
    } else {
+      if (bo->cpu_map)
+         munmap(bo->cpu_map, bo->size);
+
       if (ws->debug_all_bos)
          radv_amdgpu_global_bo_list_del(ws, bo);
       radv_amdgpu_bo_va_op(ws, bo->bo, 0, bo->size, bo->base.va, 0, 0, AMDGPU_VA_OP_UNMAP);
@@ -516,6 +521,7 @@ radv_amdgpu_winsys_bo_create(struct radeon_winsys *_ws, uint64_t size, unsigned
    bo->base.initial_domain = initial_domain;
    bo->base.use_global_list = false;
    bo->priority = priority;
+   bo->cpu_map = NULL;
 
    r = amdgpu_bo_export(buf_handle, amdgpu_bo_handle_type_kms, &bo->bo_handle);
    assert(!r);
@@ -563,11 +569,28 @@ static void *
 radv_amdgpu_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
 {
    struct radv_amdgpu_winsys_bo *bo = radv_amdgpu_winsys_bo(_bo);
-   int ret;
-   void *data;
-   ret = amdgpu_bo_cpu_map(bo->bo, &data);
+
+   /* Safeguard for the Quantic Dream layer skipping unmaps. */
+   if (bo->cpu_map)
+      return bo->cpu_map;
+
+   assert(!bo->cpu_map);
+
+   union drm_amdgpu_gem_mmap args;
+   memset(&args, 0, sizeof(args));
+   args.in.handle = bo->bo_handle;
+
+   int ret =
+      drmCommandWriteRead(amdgpu_device_get_fd(radv_amdgpu_winsys(_ws)->dev), DRM_AMDGPU_GEM_MMAP, &args, sizeof(args));
    if (ret)
       return NULL;
+
+   void *data = mmap(NULL, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+                     amdgpu_device_get_fd(radv_amdgpu_winsys(_ws)->dev), args.out.addr_ptr);
+   if (data == MAP_FAILED)
+      return NULL;
+
+   bo->cpu_map = data;
    return data;
 }
 
@@ -575,7 +598,14 @@ static void
 radv_amdgpu_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
 {
    struct radv_amdgpu_winsys_bo *bo = radv_amdgpu_winsys_bo(_bo);
-   amdgpu_bo_cpu_unmap(bo->bo);
+
+   /* Defense in depth against buggy apps. */
+   if (!bo->cpu_map)
+      return;
+
+   assert(bo->cpu_map);
+   munmap(bo->cpu_map, bo->size);
+   bo->cpu_map = NULL;
 }
 
 static uint64_t
@@ -654,6 +684,7 @@ radv_amdgpu_winsys_bo_from_ptr(struct radeon_winsys *_ws, void *pointer, uint64_
    bo->base.initial_domain = RADEON_DOMAIN_GTT;
    bo->base.use_global_list = false;
    bo->priority = priority;
+   bo->cpu_map = NULL;
 
    ASSERTED int r = amdgpu_bo_export(buf_handle, amdgpu_bo_handle_type_kms, &bo->bo_handle);
    assert(!r);
@@ -742,6 +773,7 @@ radv_amdgpu_winsys_bo_from_fd(struct radeon_winsys *_ws, int fd, unsigned priori
    bo->base.use_global_list = false;
    bo->size = result.alloc_size;
    bo->priority = priority;
+   bo->cpu_map = NULL;
 
    r = amdgpu_bo_export(result.buf_handle, amdgpu_bo_handle_type_kms, &bo->bo_handle);
    assert(!r);
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h
index f108d8ba35963..3e2604222df54 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h
@@ -50,6 +50,8 @@ struct radv_amdgpu_winsys_bo {
       struct {
          amdgpu_bo_handle bo;
          uint32_t bo_handle;
+
+         void *cpu_map;
       };
       /* virtual bo */
       struct {
-- 
GitLab


From 07f92a08ffc5f07ef76d45101fe489314dc27266 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 19 Feb 2024 00:39:23 +0100
Subject: [PATCH 4/6] radv: Support for mapping a buffer at a fixed address.

Doing the separate bool to support mapping at 0.
---
 src/amd/vulkan/radv_device_memory.c           | 13 ++++++++++++-
 src/amd/vulkan/radv_radeon_winsys.h           |  4 ++--
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c |  7 ++++---
 src/amd/vulkan/winsys/null/radv_null_bo.c     |  2 +-
 4 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/src/amd/vulkan/radv_device_memory.c b/src/amd/vulkan/radv_device_memory.c
index e4c0037d34136..d8af3afb4ed84 100644
--- a/src/amd/vulkan/radv_device_memory.c
+++ b/src/amd/vulkan/radv_device_memory.c
@@ -296,11 +296,22 @@ radv_MapMemory2KHR(VkDevice _device, const VkMemoryMapInfoKHR *pMemoryMapInfo, v
 {
    RADV_FROM_HANDLE(radv_device, device, _device);
    RADV_FROM_HANDLE(radv_device_memory, mem, pMemoryMapInfo->memory);
+   void *fixed_address = NULL;
+   bool use_fixed_address = false;
+
+   if (pMemoryMapInfo->flags & VK_MEMORY_MAP_PLACED_BIT_EXT) {
+      const VkMemoryMapPlacedInfoEXT *placed_info =
+         vk_find_struct_const(pMemoryMapInfo->pNext, MEMORY_MAP_PLACED_INFO_EXT);
+      if (placed_info) {
+         fixed_address = placed_info->pPlacedAddress;
+         use_fixed_address = true;
+      }
+   }
 
    if (mem->user_ptr)
       *ppData = mem->user_ptr;
    else
-      *ppData = radv_buffer_map(device->ws, mem->bo);
+      *ppData = device->ws->buffer_map(device->ws, mem->bo, use_fixed_address, fixed_address);
 
    if (*ppData) {
       vk_rmv_log_cpu_map(&device->vk, mem->bo->va, false);
diff --git a/src/amd/vulkan/radv_radeon_winsys.h b/src/amd/vulkan/radv_radeon_winsys.h
index f599dca540c6c..41ad84a83d93f 100644
--- a/src/amd/vulkan/radv_radeon_winsys.h
+++ b/src/amd/vulkan/radv_radeon_winsys.h
@@ -251,7 +251,7 @@ struct radeon_winsys {
                              struct radeon_winsys_bo **out_bo);
 
    void (*buffer_destroy)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo);
-   void *(*buffer_map)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo);
+   void *(*buffer_map)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, bool use_fixed_addr, void *fixed_addr);
 
    VkResult (*buffer_from_ptr)(struct radeon_winsys *ws, void *pointer, uint64_t size, unsigned priority,
                                struct radeon_winsys_bo **out_bo);
@@ -363,7 +363,7 @@ radv_cs_add_buffer(struct radeon_winsys *ws, struct radeon_cmdbuf *cs, struct ra
 static inline void *
 radv_buffer_map(struct radeon_winsys *ws, struct radeon_winsys_bo *bo)
 {
-   return ws->buffer_map(ws, bo);
+   return ws->buffer_map(ws, bo, false, NULL);
 }
 
 #endif /* RADV_RADEON_WINSYS_H */
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
index 2b2f71b03bdc0..3260027d4066b 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
@@ -566,12 +566,13 @@ error_va_alloc:
 }
 
 static void *
-radv_amdgpu_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
+radv_amdgpu_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo, bool use_fixed_addr,
+                          void *fixed_addr)
 {
    struct radv_amdgpu_winsys_bo *bo = radv_amdgpu_winsys_bo(_bo);
 
    /* Safeguard for the Quantic Dream layer skipping unmaps. */
-   if (bo->cpu_map)
+   if (bo->cpu_map && !use_fixed_addr)
       return bo->cpu_map;
 
    assert(!bo->cpu_map);
@@ -585,7 +586,7 @@ radv_amdgpu_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_b
    if (ret)
       return NULL;
 
-   void *data = mmap(NULL, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+   void *data = mmap(fixed_addr, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED | (use_fixed_addr ? MAP_FIXED : 0),
                      amdgpu_device_get_fd(radv_amdgpu_winsys(_ws)->dev), args.out.addr_ptr);
    if (data == MAP_FAILED)
       return NULL;
diff --git a/src/amd/vulkan/winsys/null/radv_null_bo.c b/src/amd/vulkan/winsys/null/radv_null_bo.c
index 621c0bdb67e5e..38423586cccf8 100644
--- a/src/amd/vulkan/winsys/null/radv_null_bo.c
+++ b/src/amd/vulkan/winsys/null/radv_null_bo.c
@@ -54,7 +54,7 @@ error_ptr_alloc:
 }
 
 static void *
-radv_null_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
+radv_null_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo, bool use_fixed_addr, void *fixed_addr)
 {
    struct radv_null_winsys_bo *bo = radv_null_winsys_bo(_bo);
    return bo->ptr;
-- 
GitLab


From 248d8ed384257991c685fc460fd9567b5fb75a0e Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 19 Feb 2024 01:21:53 +0100
Subject: [PATCH 5/6] radv: Implement reserving the VA range on unmap.

---
 src/amd/vulkan/radv_cp_reg_shadowing.c        |  2 +-
 src/amd/vulkan/radv_device_memory.c           |  2 +-
 src/amd/vulkan/radv_queue.c                   |  4 ++--
 src/amd/vulkan/radv_radeon_winsys.h           |  2 +-
 src/amd/vulkan/si_cmd_buffer.c                |  2 +-
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c | 10 +++++++---
 src/amd/vulkan/winsys/null/radv_null_bo.c     |  2 +-
 7 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cp_reg_shadowing.c b/src/amd/vulkan/radv_cp_reg_shadowing.c
index e6f57d768a7f9..94c3c45451b24 100644
--- a/src/amd/vulkan/radv_cp_reg_shadowing.c
+++ b/src/amd/vulkan/radv_cp_reg_shadowing.c
@@ -84,7 +84,7 @@ radv_create_shadow_regs_preamble(const struct radv_device *device, struct radv_q
    memcpy(map, cs->buf, cs->cdw * 4);
    queue_state->shadow_regs_ib_size_dw = cs->cdw;
 
-   ws->buffer_unmap(ws, queue_state->shadow_regs_ib);
+   ws->buffer_unmap(ws, queue_state->shadow_regs_ib, false);
    ws->cs_destroy(cs);
    return VK_SUCCESS;
 fail_map:
diff --git a/src/amd/vulkan/radv_device_memory.c b/src/amd/vulkan/radv_device_memory.c
index d8af3afb4ed84..126527c5b2b2b 100644
--- a/src/amd/vulkan/radv_device_memory.c
+++ b/src/amd/vulkan/radv_device_memory.c
@@ -330,7 +330,7 @@ radv_UnmapMemory2KHR(VkDevice _device, const VkMemoryUnmapInfoKHR *pMemoryUnmapI
 
    vk_rmv_log_cpu_map(&device->vk, mem->bo->va, true);
    if (mem->user_ptr == NULL)
-      device->ws->buffer_unmap(device->ws, mem->bo);
+      device->ws->buffer_unmap(device->ws, mem->bo, (pMemoryUnmapInfo->flags & VK_MEMORY_UNMAP_RESERVE_BIT_EXT));
 
    return VK_SUCCESS;
 }
diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index fca844400a185..ecc67de5a2df7 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -601,7 +601,7 @@ radv_initialise_task_control_buffer(struct radv_device *device, struct radeon_wi
    ptr[7] = task_draw_ring_va;
    ptr[8] = task_draw_ring_va >> 32;
 
-   device->ws->buffer_unmap(device->ws, task_rings_bo);
+   device->ws->buffer_unmap(device->ws, task_rings_bo, false);
    return VK_SUCCESS;
 }
 
@@ -992,7 +992,7 @@ radv_update_preamble_cs(struct radv_queue_state *queue, struct radv_device *devi
                              gsvs_ring_bo, tess_rings_bo, task_rings_bo, mesh_scratch_ring_bo, needs->attr_ring_size,
                              attr_ring_bo);
 
-      ws->buffer_unmap(ws, descriptor_bo);
+      ws->buffer_unmap(ws, descriptor_bo, false);
    }
 
    for (int i = 0; i < 3; ++i) {
diff --git a/src/amd/vulkan/radv_radeon_winsys.h b/src/amd/vulkan/radv_radeon_winsys.h
index 41ad84a83d93f..4f85c6cc39daf 100644
--- a/src/amd/vulkan/radv_radeon_winsys.h
+++ b/src/amd/vulkan/radv_radeon_winsys.h
@@ -264,7 +264,7 @@ struct radeon_winsys {
    bool (*buffer_get_flags_from_fd)(struct radeon_winsys *ws, int fd, enum radeon_bo_domain *domains,
                                     enum radeon_bo_flag *flags);
 
-   void (*buffer_unmap)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo);
+   void (*buffer_unmap)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, bool replace);
 
    void (*buffer_set_metadata)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, struct radeon_bo_metadata *md);
    void (*buffer_get_metadata)(struct radeon_winsys *ws, struct radeon_winsys_bo *bo, struct radeon_bo_metadata *md);
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index a604d6e3d321d..44567ffc44e4a 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -653,7 +653,7 @@ radv_create_gfx_config(struct radv_device *device)
    }
    memcpy(map, cs->buf, cs->cdw * 4);
 
-   device->ws->buffer_unmap(device->ws, device->gfx_init);
+   device->ws->buffer_unmap(device->ws, device->gfx_init, false);
    device->gfx_init_size_dw = cs->cdw;
 fail:
    device->ws->cs_destroy(cs);
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
index 3260027d4066b..71a3198b68361 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
@@ -596,16 +596,20 @@ radv_amdgpu_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_b
 }
 
 static void
-radv_amdgpu_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
+radv_amdgpu_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo, bool replace)
 {
    struct radv_amdgpu_winsys_bo *bo = radv_amdgpu_winsys_bo(_bo);
 
    /* Defense in depth against buggy apps. */
-   if (!bo->cpu_map)
+   if (!bo->cpu_map && !replace)
       return;
 
    assert(bo->cpu_map);
-   munmap(bo->cpu_map, bo->size);
+   if (replace) {
+      (void)mmap(bo->cpu_map, bo->size, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
+   } else {
+      munmap(bo->cpu_map, bo->size);
+   }
    bo->cpu_map = NULL;
 }
 
diff --git a/src/amd/vulkan/winsys/null/radv_null_bo.c b/src/amd/vulkan/winsys/null/radv_null_bo.c
index 38423586cccf8..90de8e15df7e1 100644
--- a/src/amd/vulkan/winsys/null/radv_null_bo.c
+++ b/src/amd/vulkan/winsys/null/radv_null_bo.c
@@ -61,7 +61,7 @@ radv_null_winsys_bo_map(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo,
 }
 
 static void
-radv_null_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo)
+radv_null_winsys_bo_unmap(struct radeon_winsys *_ws, struct radeon_winsys_bo *_bo, bool replace)
 {
 }
 
-- 
GitLab


From 1b5a06c9ab06baea13c4c749001ba272927ed587 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 19 Feb 2024 01:25:15 +0100
Subject: [PATCH 6/6] radv: Expose VK_EXT_map_memory_placed.

---
 docs/relnotes/new_features.txt        |  1 +
 src/amd/vulkan/radv_physical_device.c | 11 +++++++++++
 2 files changed, 12 insertions(+)

diff --git a/docs/relnotes/new_features.txt b/docs/relnotes/new_features.txt
index 0d5fea70fb4b4..4e989b4599aea 100644
--- a/docs/relnotes/new_features.txt
+++ b/docs/relnotes/new_features.txt
@@ -1,3 +1,4 @@
+VK_EXT_map_memory_placed on RADV
 VK_KHR_shader_subgroup_rotate on RADV
 VK_KHR_load_store_op_none on RADV
 VK_KHR_line_rasterization on RADV
diff --git a/src/amd/vulkan/radv_physical_device.c b/src/amd/vulkan/radv_physical_device.c
index 5f34a05e933ed..77c7f131fac67 100644
--- a/src/amd/vulkan/radv_physical_device.c
+++ b/src/amd/vulkan/radv_physical_device.c
@@ -576,6 +576,7 @@ radv_physical_device_get_supported_extensions(const struct radv_physical_device
       .EXT_inline_uniform_block = true,
       .EXT_line_rasterization = true,
       .EXT_load_store_op_none = true,
+      .EXT_map_memory_placed = true,
       .EXT_memory_budget = true,
       .EXT_memory_priority = true,
       .EXT_mesh_shader = radv_taskmesh_enabled(device),
@@ -927,6 +928,11 @@ radv_physical_device_get_features(const struct radv_physical_device *pdevice, st
       /* VK_KHR_shader_subgroup_uniform_control_flow */
       .shaderSubgroupUniformControlFlow = true,
 
+      /* VK_EXT_map_memory_placed */
+      .memoryMapPlaced = true,
+      .memoryMapRangePlaced = false,
+      .memoryUnmapReserve = true,
+
       /* VK_EXT_multi_draw */
       .multiDraw = true,
 
@@ -1829,6 +1835,11 @@ radv_get_physical_device_properties(struct radv_physical_device *pdevice)
    /* VK_EXT_shader_object */
    radv_device_get_cache_uuid(pdevice, p->shaderBinaryUUID);
    p->shaderBinaryVersion = 1;
+
+   /* VK_EXT_map_memory_placed */
+   uint64_t os_page_size = 4096;
+   os_get_page_size(&os_page_size);
+   p->minPlacedMemoryMapAlignment = os_page_size;
 }
 
 static VkResult
-- 
GitLab

