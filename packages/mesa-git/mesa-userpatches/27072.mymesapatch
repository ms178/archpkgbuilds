From 3a08fa6e2464551c916f5684f63574b7bf09c5fe Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Sat, 13 Jan 2024 14:56:39 +0100
Subject: [PATCH] aco: Eliminate SCC copies when possible.

Foz-DB Navi31:
Totals from 2517 (3.22% of 78112) affected shaders:
Instrs: 5992126 -> 5972611 (-0.33%); split: -0.33%, +0.00%
CodeSize: 30986404 -> 30914536 (-0.23%); split: -0.23%, +0.00%
Latency: 43221112 -> 43217422 (-0.01%); split: -0.02%, +0.01%
InvThroughput: 6675983 -> 6674598 (-0.02%); split: -0.02%, +0.00%
SClause: 181987 -> 181976 (-0.01%); split: -0.01%, +0.00%
Copies: 538852 -> 519419 (-3.61%)

Co-authored-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 97 +++++++++++++++++++++++
 1 file changed, 97 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index cee1fd0cb579..fe302418fb9c 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -470,6 +470,99 @@ try_optimize_scc_nocompare(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
+static bool
+is_scc_copy(const Instruction* instr)
+{
+   return instr->opcode == aco_opcode::p_parallelcopy && instr->operands.size() == 1 &&
+          instr->operands[0].isTemp() && instr->operands[0].physReg().reg() == scc;
+}
+
+void
+save_scc_copy_producer(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   if (!is_scc_copy(instr.get()))
+      return;
+
+   Idx wr_idx = last_writer_idx(ctx, instr->operands[0]);
+   if (wr_idx.found() && wr_idx.block == ctx.current_block->index)
+      instr->pass_flags = wr_idx.instr;
+   else
+      instr->pass_flags = UINT32_MAX;
+}
+
+void
+try_eliminate_scc_copy(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   /* Try to eliminate an SCC copy by duplicating the instruction that produced the SCC. */
+
+   if (instr->opcode != aco_opcode::p_parallelcopy || instr->definitions.size() != 1 ||
+       instr->definitions[0].physReg().reg() != scc)
+      return;
+
+   /* Find the instruction that copied SCC into an SGPR. */
+   Idx wr_idx = last_writer_idx(ctx, instr->operands[0]);
+   if (!wr_idx.found())
+      return;
+
+   const Instruction* wr_instr = ctx.get(wr_idx);
+   if (!is_scc_copy(wr_instr) || wr_instr->pass_flags == UINT32_MAX)
+      return;
+
+   Idx producer_idx = {wr_idx.block, wr_instr->pass_flags};
+   Instruction* producer_instr = ctx.get(producer_idx);
+
+   if (!producer_instr)
+      return;
+
+   /* Verify that the operands of the producer instruction haven't been overwritten. */
+   for (const Operand& op : producer_instr->operands) {
+      if (is_overwritten_since(ctx, op, producer_idx))
+         return;
+   }
+
+   /* Verify that the definitions (except SCC) of the producer haven't been overwritten. */
+   for (const Definition& def : producer_instr->definitions) {
+      if (def.physReg().reg() == scc)
+         continue;
+      if (is_overwritten_since(ctx, def, producer_idx))
+         return;
+   }
+
+   /* Duplicate the original producer of the SCC */
+   if (producer_instr->isSOP1())
+      instr.reset(create_instruction<SOP1_instruction>(producer_instr->opcode, Format::SOP1,
+                                                       producer_instr->operands.size(),
+                                                       producer_instr->definitions.size()));
+   else if (producer_instr->isSOP2())
+      instr.reset(create_instruction<SOP2_instruction>(producer_instr->opcode, Format::SOP2,
+                                                       producer_instr->operands.size(),
+                                                       producer_instr->definitions.size()));
+   else if (producer_instr->isSOPC())
+      instr.reset(create_instruction<SOPC_instruction>(producer_instr->opcode, Format::SOPC,
+                                                       producer_instr->operands.size(),
+                                                       producer_instr->definitions.size()));
+   else
+      return;
+
+   /* The copy is no longer needed. */
+   if (--ctx.uses[wr_instr->definitions[0].tempId()] == 0)
+      ctx.uses[wr_instr->operands[0].tempId()]--;
+
+   /* Copy the operands of the original producer. */
+   for (unsigned i = 0; i < producer_instr->operands.size(); ++i) {
+      instr->operands[i] = producer_instr->operands[i];
+      if (producer_instr->operands[i].isTemp() && !is_dead(ctx.uses, producer_instr))
+         ctx.uses[producer_instr->operands[i].tempId()]++;
+   }
+
+   /* Copy the definitions of the original producer,
+    * but mark them as non-temp to keep SSA quasi-intact.
+    */
+   for (unsigned i = 0; i < producer_instr->definitions.size(); ++i)
+      instr->definitions[i] = Definition(producer_instr->definitions[i].physReg(),
+                                         producer_instr->definitions[i].regClass());
+}
+
 void
 try_combine_dpp(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -718,6 +811,8 @@ process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
       return;
    }
 
+   save_scc_copy_producer(ctx, instr);
+
    try_apply_branch_vcc(ctx, instr);
 
    try_optimize_scc_nocompare(ctx, instr);
@@ -726,6 +821,8 @@ process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
    try_reassign_split_vector(ctx, instr);
 
+   try_eliminate_scc_copy(ctx, instr);
+
    if (instr)
       save_reg_writes(ctx, instr);
 
-- 
GitLab

