From 170a3b05f8535a866a7d469c70d2f73bbe4bb55c Mon Sep 17 00:00:00 2001
From: Tony Wasserka <tony.wasserka@gmx.de>
Date: Tue, 20 Jul 2021 17:05:43 +0200
Subject: [PATCH 1/2] aco/spill: Use arena allocator for next use distances
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Speedup of aco::spill(): ~50%

Co-authored-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_spill.cpp | 20 ++++++++++++--------
 1 file changed, 12 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 3f8426921ae79..21abce1854545 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -25,6 +25,7 @@
 
 #include "aco_builder.h"
 #include "aco_ir.h"
+#include "aco_util.h"
 
 #include "common/sid.h"
 
@@ -65,6 +66,8 @@ struct remat_info {
 struct spill_ctx {
    RegisterDemand target_pressure;
    Program* program;
+   aco::monotonic_buffer_resource memory;
+
    std::vector<std::vector<RegisterDemand>> register_demand;
    std::vector<std::map<Temp, Temp>> renames;
    std::vector<std::unordered_map<Temp, uint32_t>> spills_entry;
@@ -72,8 +75,10 @@ struct spill_ctx {
 
    std::vector<bool> processed;
    std::stack<Block*, std::vector<Block*>> loop_header;
-   std::vector<std::unordered_map<Temp, std::pair<uint32_t, uint32_t>>> next_use_distances_start;
-   std::vector<std::unordered_map<Temp, std::pair<uint32_t, uint32_t>>> next_use_distances_end;
+
+   using next_use_distance_startend_type = aco::unordered_map<Temp, std::pair<uint32_t, uint32_t>>;
+   std::vector<next_use_distance_startend_type> next_use_distances_start;
+   std::vector<next_use_distance_startend_type> next_use_distances_end;
    std::vector<std::vector<std::pair<Temp, uint32_t>>> local_next_use_distance; /* Working buffer */
    std::vector<std::pair<RegClass, std::unordered_set<uint32_t>>> interferences;
    std::vector<std::vector<uint32_t>> affinities;
@@ -88,11 +93,13 @@ struct spill_ctx {
 
    spill_ctx(const RegisterDemand target_pressure_, Program* program_,
              std::vector<std::vector<RegisterDemand>> register_demand_)
-       : target_pressure(target_pressure_), program(program_),
+       : target_pressure(target_pressure_), program(program_), memory(),
          register_demand(std::move(register_demand_)), renames(program->blocks.size()),
          spills_entry(program->blocks.size()), spills_exit(program->blocks.size()),
-         processed(program->blocks.size(), false), wave_size(program->wave_size),
-         sgpr_spill_slots(0), vgpr_spill_slots(0)
+         processed(program->blocks.size(), false),
+         next_use_distances_start(program->blocks.size(), next_use_distance_startend_type(memory)),
+         next_use_distances_end(program->blocks.size(), next_use_distance_startend_type(memory)),
+         wave_size(program->wave_size), sgpr_spill_slots(0), vgpr_spill_slots(0)
    {}
 
    void add_affinity(uint32_t first, uint32_t second)
@@ -273,9 +280,6 @@ next_uses_per_block(spill_ctx& ctx, unsigned block_idx, uint32_t& worklist)
 void
 compute_global_next_uses(spill_ctx& ctx)
 {
-   ctx.next_use_distances_start.resize(ctx.program->blocks.size());
-   ctx.next_use_distances_end.resize(ctx.program->blocks.size());
-
    uint32_t worklist = ctx.program->blocks.size();
    while (worklist) {
       unsigned block_idx = --worklist;
-- 
GitLab


From f8d2c45fba9ff3a3f42bda468f89c5f9261e20aa Mon Sep 17 00:00:00 2001
From: Tony Wasserka <tony.wasserka@gmx.de>
Date: Wed, 21 Jul 2021 17:19:13 +0200
Subject: [PATCH 2/2] aco/spill: Use arena allocator for spills
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Gives a marginal speedup.

Co-authored-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_spill.cpp | 19 ++++++++++---------
 src/amd/compiler/aco_util.h    |  2 +-
 2 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 21abce1854545..ed39d2cd9c3a2 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -69,9 +69,9 @@ struct spill_ctx {
    aco::monotonic_buffer_resource memory;
 
    std::vector<std::vector<RegisterDemand>> register_demand;
-   std::vector<std::map<Temp, Temp>> renames;
-   std::vector<std::unordered_map<Temp, uint32_t>> spills_entry;
-   std::vector<std::unordered_map<Temp, uint32_t>> spills_exit;
+   std::vector<aco::map<Temp, Temp>> renames;
+   std::vector<aco::unordered_map<Temp, uint32_t>> spills_entry;
+   std::vector<aco::unordered_map<Temp, uint32_t>> spills_exit;
 
    std::vector<bool> processed;
    std::stack<Block*, std::vector<Block*>> loop_header;
@@ -83,7 +83,7 @@ struct spill_ctx {
    std::vector<std::pair<RegClass, std::unordered_set<uint32_t>>> interferences;
    std::vector<std::vector<uint32_t>> affinities;
    std::vector<bool> is_reloaded;
-   std::unordered_map<Temp, remat_info> remat;
+   aco::unordered_map<Temp, remat_info> remat;
    std::set<Instruction*> unused_remats;
    unsigned wave_size;
 
@@ -94,12 +94,13 @@ struct spill_ctx {
    spill_ctx(const RegisterDemand target_pressure_, Program* program_,
              std::vector<std::vector<RegisterDemand>> register_demand_)
        : target_pressure(target_pressure_), program(program_), memory(),
-         register_demand(std::move(register_demand_)), renames(program->blocks.size()),
-         spills_entry(program->blocks.size()), spills_exit(program->blocks.size()),
+         register_demand(std::move(register_demand_)), renames(program->blocks.size(), aco::map<Temp, Temp>(memory)),
+         spills_entry(program->blocks.size(), aco::unordered_map<Temp, uint32_t>(memory)),
+         spills_exit(program->blocks.size(), aco::unordered_map<Temp, uint32_t>(memory)),
          processed(program->blocks.size(), false),
          next_use_distances_start(program->blocks.size(), next_use_distance_startend_type(memory)),
          next_use_distances_end(program->blocks.size(), next_use_distance_startend_type(memory)),
-         wave_size(program->wave_size), sgpr_spill_slots(0), vgpr_spill_slots(0)
+         remat(memory), wave_size(program->wave_size), sgpr_spill_slots(0), vgpr_spill_slots(0)
    {}
 
    void add_affinity(uint32_t first, uint32_t second)
@@ -1329,7 +1330,7 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
    Block* loop_header = ctx.loop_header.top();
 
    /* preserve original renames at end of loop header block */
-   std::map<Temp, Temp> renames = std::move(ctx.renames[loop_header->index]);
+   aco::map<Temp, Temp> renames = std::move(ctx.renames[loop_header->index]);
 
    /* add coupling code to all loop header predecessors */
    add_coupling_code(ctx, loop_header, loop_header->index);
@@ -1676,7 +1677,7 @@ assign_spill_slots_helper(spill_ctx& ctx, RegType type, std::vector<bool>& is_as
 void
 end_unused_spill_vgprs(spill_ctx& ctx, Block& block, std::vector<Temp>& vgpr_spill_temps,
                        const std::vector<uint32_t>& slots,
-                       const std::unordered_map<Temp, uint32_t>& spills)
+                       const aco::unordered_map<Temp, uint32_t>& spills)
 {
    std::vector<bool> is_used(vgpr_spill_temps.size());
    for (std::pair<Temp, uint32_t> pair : spills) {
diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 5f9630f2dd182..9659f5a98f623 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -520,7 +520,7 @@ private:
  * as memory resource. The advantage of this specialization is the absence of
  * virtual function calls and the propagation on swap, copy- and move assignment.
  */
-template <typename T> class monotonic_allocator final {
+template <typename T> class monotonic_allocator {
 public:
    monotonic_allocator() = delete;
    monotonic_allocator(monotonic_buffer_resource& m) : memory_resource(m) {}
-- 
GitLab

