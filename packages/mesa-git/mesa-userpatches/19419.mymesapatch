From 514ca22e1861a40728886829fd7462ba76249f71 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 28 Oct 2022 17:14:55 -0400
Subject: [PATCH 1/6] ac/llvm: remove unnecessary gfx11 condition for
 nir_intrinsic_store_buffer_amd

ac_build_buffer_store_dword is responsible for this.
---
 src/amd/llvm/ac_nir_to_llvm.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 05a1aee69a39..0528b90f04a9 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4254,7 +4254,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       enum ac_image_cache_policy cache_policy = 0;
       if (swizzled)
          cache_policy |= ac_swizzled;
-      if (coherent && ctx->ac.gfx_level < GFX11)
+      if (coherent)
          cache_policy |= ac_glc;
       if (slc)
          cache_policy |= ac_slc;
-- 
GitLab


From 54d6cb90bb793196395019b5227bfcba0fbc8d4b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 21 Oct 2022 14:01:31 -0400
Subject: [PATCH 2/6] amd/registers: fix parse_kernel_headers.py warnings by
 adding missing enums

---
 src/amd/registers/gfx9.json               | 22 +++++++++++++++---
 src/amd/registers/parse_kernel_headers.py | 28 +++++++++++++++++++----
 2 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/src/amd/registers/gfx9.json b/src/amd/registers/gfx9.json
index 6d0f3c9d14cb..22918a70b1a9 100644
--- a/src/amd/registers/gfx9.json
+++ b/src/amd/registers/gfx9.json
@@ -68,6 +68,15 @@
     {"name": "ADDR_SURF_BANK_WIDTH_8", "value": 3}
    ]
   },
+  "BinSizeExtend": {
+   "entries": [
+    {"name": "BIN_SIZE_32_PIXELS", "value": 0},
+    {"name": "BIN_SIZE_64_PIXELS", "value": 1},
+    {"name": "BIN_SIZE_128_PIXELS", "value": 2},
+    {"name": "BIN_SIZE_256_PIXELS", "value": 3},
+    {"name": "BIN_SIZE_512_PIXELS", "value": 4}
+   ]
+  },
   "BinningMode": {
    "entries": [
     {"name": "BINNING_ALLOWED", "value": 0},
@@ -822,6 +831,13 @@
     {"name": "RASTER_CONFIG_SC_MAP_3", "value": 3}
    ]
   },
+  "ScUncertaintyRegionMode": {
+   "entries": [
+    {"name": "SC_HALF_LSB", "value": 0},
+    {"name": "SC_LSB_ONE_SIDED", "value": 1},
+    {"name": "SC_LSB_TWO_SIDED", "value": 2}
+   ]
+  },
   "ScXsel": {
    "entries": [
     {"name": "RASTER_CONFIG_SC_XSEL_8_WIDE_TILE", "value": 0},
@@ -11972,8 +11988,8 @@
     {"bits": [0, 1], "enum_ref": "BinningMode", "name": "BINNING_MODE"},
     {"bits": [2, 2], "name": "BIN_SIZE_X"},
     {"bits": [3, 3], "name": "BIN_SIZE_Y"},
-    {"bits": [4, 6], "name": "BIN_SIZE_X_EXTEND"},
-    {"bits": [7, 9], "name": "BIN_SIZE_Y_EXTEND"},
+    {"bits": [4, 6], "enum_ref": "BinSizeExtend", "name": "BIN_SIZE_X_EXTEND"},
+    {"bits": [7, 9], "enum_ref": "BinSizeExtend", "name": "BIN_SIZE_Y_EXTEND"},
     {"bits": [10, 12], "name": "CONTEXT_STATES_PER_BIN"},
     {"bits": [13, 17], "name": "PERSISTENT_STATES_PER_BIN"},
     {"bits": [18, 18], "name": "DISABLE_START_OF_PRIM"},
@@ -12035,7 +12051,7 @@
     {"bits": [13, 13], "name": "OVERRIDE_OVER_RAST_INNER_TO_NORMAL"},
     {"bits": [14, 14], "name": "OVERRIDE_UNDER_RAST_INNER_TO_NORMAL"},
     {"bits": [15, 15], "name": "DEGENERATE_OVERRIDE_INNER_TO_NORMAL_DISABLE"},
-    {"bits": [16, 17], "name": "UNCERTAINTY_REGION_MODE"},
+    {"bits": [16, 17], "enum_ref": "ScUncertaintyRegionMode", "name": "UNCERTAINTY_REGION_MODE"},
     {"bits": [18, 18], "name": "OUTER_UNCERTAINTY_EDGERULE_OVERRIDE"},
     {"bits": [19, 19], "name": "INNER_UNCERTAINTY_EDGERULE_OVERRIDE"},
     {"bits": [20, 20], "name": "NULL_SQUAD_AA_MASK_ENABLE"},
diff --git a/src/amd/registers/parse_kernel_headers.py b/src/amd/registers/parse_kernel_headers.py
index 67883f409756..580df37d9bfc 100644
--- a/src/amd/registers/parse_kernel_headers.py
+++ b/src/amd/registers/parse_kernel_headers.py
@@ -564,6 +564,29 @@ missing_enums_gfx81plus = {
   },
 }
 
+missing_enums_gfx9 = {
+  **missing_enums_gfx81plus,
+  "DB_DFSM_CONTROL__PUNCHOUT_MODE": DB_DFSM_CONTROL__PUNCHOUT_MODE,
+  "IMG_DATA_FORMAT_STENCIL": IMG_DATA_FORMAT_STENCIL,
+  "SQ_IMG_RSRC_WORD4__BC_SWIZZLE": SQ_IMG_RSRC_WORD4__BC_SWIZZLE,
+  "BinSizeExtend": {
+    "entries": [
+      {"name": "BIN_SIZE_32_PIXELS", "value": 0},
+      {"name": "BIN_SIZE_64_PIXELS", "value": 1},
+      {"name": "BIN_SIZE_128_PIXELS", "value": 2},
+      {"name": "BIN_SIZE_256_PIXELS", "value": 3},
+      {"name": "BIN_SIZE_512_PIXELS", "value": 4}
+    ]
+  },
+  "ScUncertaintyRegionMode": {
+    "entries": [
+      {"name": "SC_HALF_LSB", "value": 0},
+      {"name": "SC_LSB_ONE_SIDED", "value": 1},
+      {"name": "SC_LSB_TWO_SIDED", "value": 2}
+    ]
+  },
+}
+
 missing_enums_gfx103plus = {
   **missing_enums_gfx81plus,
   "ColorFormat": ColorFormat,
@@ -624,10 +647,7 @@ enums_missing = {
     **missing_enums_gfx81plus,
   },
   'gfx9': {
-    **missing_enums_gfx81plus,
-    "DB_DFSM_CONTROL__PUNCHOUT_MODE": DB_DFSM_CONTROL__PUNCHOUT_MODE,
-    "IMG_DATA_FORMAT_STENCIL": IMG_DATA_FORMAT_STENCIL,
-    "SQ_IMG_RSRC_WORD4__BC_SWIZZLE": SQ_IMG_RSRC_WORD4__BC_SWIZZLE,
+    **missing_enums_gfx9,
   },
   'gfx10': {
     **missing_enums_gfx81plus,
-- 
GitLab


From ea820526e17302d3af625ed7c9633bb30220e2f9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 21 Oct 2022 15:00:03 -0400
Subject: [PATCH 3/6] amd/registers: describe allowed register ranges better

---
 src/amd/registers/parse_kernel_headers.py | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/amd/registers/parse_kernel_headers.py b/src/amd/registers/parse_kernel_headers.py
index 580df37d9bfc..f19af8a14177 100644
--- a/src/amd/registers/parse_kernel_headers.py
+++ b/src/amd/registers/parse_kernel_headers.py
@@ -69,8 +69,18 @@ re_shift = re.compile(r'^#define (?P<name>\w+)__(?P<field>\w+)__SHIFT\s+(?P<valu
 re_mask = re.compile(r'^#define (?P<name>\w+)__(?P<field>\w+)_MASK\s+(?P<value>[0-9a-fA-Fx]+)L?\n')
 
 def register_filter(gfx_level, name, offset, already_added):
+    # Compute shader registers
+    umd_ranges = [0xB]
+
+    # Gfx context, uconfig, and perf counter registers
+    umd_ranges += [0x28, 0x30, 0x31, 0x34, 0x35, 0x36, 0x37]
+
+    # Add all registers in the 0x8000 range for gfx6
+    if gfx_level == 'gfx6':
+        umd_ranges += [0x8]
+
     # Only accept writeable registers and debug registers
-    return ((offset // 0x1000 in [0xB, 0x28, 0x30, 0x31, 0x34, 0x35, 0x36, 0x37] or
+    return ((offset // 0x1000 in umd_ranges or
              # Add SQ_WAVE registers for trap handlers
              name.startswith('SQ_WAVE_') or
              # Add registers in the 0x8000 range used by all generations
@@ -80,8 +90,6 @@ def register_filter(gfx_level, name, offset, already_added):
                name.startswith('SQ_THREAD') or
                name.startswith('GRBM_STATUS') or
                name.startswith('CP_CP'))) or
-             # Add all registers in the 0x8000 range for gfx6
-             (gfx_level == 'gfx6' and offset // 0x1000 == 0x8) or
              # Add registers in the 0x9000 range
              (offset // 0x1000 == 0x9 and
               (name in ['TA_CS_BC_BASE_ADDR', 'GB_ADDR_CONFIG', 'SPI_CONFIG_CNTL'] or
-- 
GitLab


From 41cf3bc92163651b48a5b440a9d414c2d16353cf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 21 Oct 2022 15:03:22 -0400
Subject: [PATCH 4/6] amd/registers: regenerate gfx11 headers from
 amd-staging-drm-next

---
 src/amd/registers/gfx11.json | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/amd/registers/gfx11.json b/src/amd/registers/gfx11.json
index 38308f066414..088b3a221cac 100644
--- a/src/amd/registers/gfx11.json
+++ b/src/amd/registers/gfx11.json
@@ -2366,6 +2366,12 @@
    "name": "GL1C_STATUS",
    "type_ref": "GL1C_STATUS"
   },
+  {
+   "chips": ["gfx11"],
+   "map": {"at": 46344, "to": "mm"},
+   "name": "GL1C_UTCL0_CNTL1",
+   "type_ref": "GL1C_UTCL0_CNTL1"
+  },
   {
    "chips": ["gfx11"],
    "map": {"at": 46348, "to": "mm"},
@@ -12464,6 +12470,22 @@
     {"bits": [31, 31], "name": "TRACKER_LAST_SET_MATCHES_CURRENT_SET"}
    ]
   },
+  "GL1C_UTCL0_CNTL1": {
+   "fields": [
+    {"bits": [0, 0], "name": "FORCE_4K_L2_RESP"},
+    {"bits": [1, 1], "name": "GPUVM_64K_DEF"},
+    {"bits": [2, 2], "name": "GPUVM_PERM_MODE"},
+    {"bits": [3, 4], "name": "RESP_MODE"},
+    {"bits": [5, 6], "name": "RESP_FAULT_MODE"},
+    {"bits": [7, 15], "name": "CLIENTID"},
+    {"bits": [19, 22], "name": "REG_INV_VMID"},
+    {"bits": [24, 24], "name": "REG_INV_TOGGLE"},
+    {"bits": [26, 26], "name": "FORCE_MISS"},
+    {"bits": [27, 28], "name": "FORCE_IN_ORDER"},
+    {"bits": [28, 29], "name": "REDUCE_FIFO_DEPTH_BY_2"},
+    {"bits": [30, 31], "name": "REDUCE_CACHE_SIZE_BY_2"}
+   ]
+  },
   "GL1C_UTCL0_CNTL2": {
    "fields": [
     {"bits": [0, 7], "name": "SPARE"},
-- 
GitLab


From 5fd6ce126717b93d3aa68d2e6822f215e9c7560e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 21 Oct 2022 15:08:15 -0400
Subject: [PATCH 5/6] ac/gpu_info: simplify how has_accelerated_dot_product is
 set

---
 src/amd/common/ac_gpu_info.c                  | 4 ++--
 src/amd/vulkan/winsys/null/radv_null_winsys.c | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 00dec3bba3b3..900268d7d708 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1063,8 +1063,8 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
     * instruction encoding which accumulates with the destination.
     */
    info->has_accelerated_dot_product =
-      info->family == CHIP_ARCTURUS || info->family == CHIP_ALDEBARAN ||
-      info->family == CHIP_VEGA20 || info->family >= CHIP_NAVI12;
+      info->family == CHIP_VEGA20 ||
+      (info->family >= CHIP_ARCTURUS && info->family != CHIP_NAVI10);
 
    /* TODO: Figure out how to use LOAD_CONTEXT_REG on GFX6-GFX7. */
    info->has_load_ctx_reg_pkt =
diff --git a/src/amd/vulkan/winsys/null/radv_null_winsys.c b/src/amd/vulkan/winsys/null/radv_null_winsys.c
index c7bc1f3bb4c0..967156aaea5d 100644
--- a/src/amd/vulkan/winsys/null/radv_null_winsys.c
+++ b/src/amd/vulkan/winsys/null/radv_null_winsys.c
@@ -142,8 +142,8 @@ radv_null_winsys_query_info(struct radeon_winsys *rws, struct radeon_info *info)
       info->family == CHIP_NAVI23 || info->family == CHIP_VANGOGH;
 
    info->has_accelerated_dot_product =
-      info->family == CHIP_ARCTURUS || info->family == CHIP_ALDEBARAN ||
-      info->family == CHIP_VEGA20 || info->family >= CHIP_NAVI12;
+      info->family == CHIP_VEGA20 ||
+      (info->family >= CHIP_ARCTURUS && info->family != CHIP_NAVI10);
 
    info->address32_hi = info->gfx_level >= GFX9 ? 0xffff8000u : 0x0;
 
-- 
GitLab


From cb11a05bbf615324a7c5718f80ea55aa84dfadf8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 21 Oct 2022 15:30:53 -0400
Subject: [PATCH 6/6] ac: fix IB parsing for Stoney

We need to pass the family to register parsing functions.
---
 src/amd/common/ac_debug.c                     | 120 ++++++++++--------
 src/amd/common/ac_debug.h                     |  12 +-
 src/amd/common/ac_gpu_info.c                  |   3 +-
 src/amd/common/ac_shadowed_regs.c             |   8 +-
 src/amd/vulkan/radv_debug.c                   |  54 ++++----
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c |   2 +-
 src/gallium/drivers/radeonsi/si_debug.c       |  44 ++++---
 7 files changed, 134 insertions(+), 109 deletions(-)

diff --git a/src/amd/common/ac_debug.c b/src/amd/common/ac_debug.c
index ddc89b3cc8fb..0f0aae3a4302 100644
--- a/src/amd/common/ac_debug.c
+++ b/src/amd/common/ac_debug.c
@@ -68,6 +68,7 @@ struct ac_ib_parser {
    const int *trace_ids;
    unsigned trace_id_count;
    enum amd_gfx_level gfx_level;
+   enum radeon_family family;
    ac_debug_addr_callback addr_callback;
    void *addr_callback_data;
 
@@ -109,7 +110,8 @@ static void print_named_value(FILE *file, const char *name, uint32_t value, int
    print_value(file, value, bits);
 }
 
-static const struct si_reg *find_register(enum amd_gfx_level gfx_level, unsigned offset)
+static const struct si_reg *find_register(enum amd_gfx_level gfx_level, enum radeon_family family,
+                                          unsigned offset)
 {
    const struct si_reg *table;
    unsigned table_size;
@@ -129,6 +131,11 @@ static const struct si_reg *find_register(enum amd_gfx_level gfx_level, unsigned
       table_size = ARRAY_SIZE(gfx9_reg_table);
       break;
    case GFX8:
+      if (family == CHIP_STONEY) {
+         table = gfx81_reg_table;
+         table_size = ARRAY_SIZE(gfx81_reg_table);
+         break;
+      }
       table = gfx8_reg_table;
       table_size = ARRAY_SIZE(gfx8_reg_table);
       break;
@@ -154,17 +161,18 @@ static const struct si_reg *find_register(enum amd_gfx_level gfx_level, unsigned
    return NULL;
 }
 
-const char *ac_get_register_name(enum amd_gfx_level gfx_level, unsigned offset)
+const char *ac_get_register_name(enum amd_gfx_level gfx_level, enum radeon_family family,
+                                 unsigned offset)
 {
-   const struct si_reg *reg = find_register(gfx_level, offset);
+   const struct si_reg *reg = find_register(gfx_level, family, offset);
 
    return reg ? sid_strings + reg->name_offset : "(no name)";
 }
 
-void ac_dump_reg(FILE *file, enum amd_gfx_level gfx_level, unsigned offset, uint32_t value,
-                 uint32_t field_mask)
+void ac_dump_reg(FILE *file, enum amd_gfx_level gfx_level, enum radeon_family family,
+                 unsigned offset, uint32_t value, uint32_t field_mask)
 {
-   const struct si_reg *reg = find_register(gfx_level, offset);
+   const struct si_reg *reg = find_register(gfx_level, family, offset);
 
    if (reg) {
       const char *reg_name = sid_strings + reg->name_offset;
@@ -252,7 +260,7 @@ static void ac_parse_set_reg_packet(FILE *f, unsigned count, unsigned reg_offset
    }
 
    for (i = 0; i < count; i++)
-      ac_dump_reg(f, ib->gfx_level, reg + i * 4, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, reg + i * 4, ac_ib_get(ib), ~0);
 }
 
 static void ac_parse_packet3(FILE *f, uint32_t header, struct ac_ib_parser *ib,
@@ -298,39 +306,39 @@ static void ac_parse_packet3(FILE *f, uint32_t header, struct ac_ib_parser *ib,
       break;
    case PKT3_ACQUIRE_MEM:
       if (ib->gfx_level >= GFX11 && G_585_PWS_ENA(ib->ib[ib->cur_dw + 5])) {
-         ac_dump_reg(f, ib->gfx_level, R_580_ACQUIRE_MEM_PWS_2, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_580_ACQUIRE_MEM_PWS_2, ac_ib_get(ib), ~0);
          print_named_value(f, "GCR_SIZE", ac_ib_get(ib), 32);
          print_named_value(f, "GCR_SIZE_HI", ac_ib_get(ib), 25);
          print_named_value(f, "GCR_BASE_LO", ac_ib_get(ib), 32);
          print_named_value(f, "GCR_BASE_HI", ac_ib_get(ib), 32);
-         ac_dump_reg(f, ib->gfx_level, R_585_ACQUIRE_MEM_PWS_7, ac_ib_get(ib), ~0);
-         ac_dump_reg(f, ib->gfx_level, R_586_GCR_CNTL, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_585_ACQUIRE_MEM_PWS_7, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_586_GCR_CNTL, ac_ib_get(ib), ~0);
          break;
       }
-      ac_dump_reg(f, ib->gfx_level, R_0301F0_CP_COHER_CNTL, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0301F4_CP_COHER_SIZE, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_030230_CP_COHER_SIZE_HI, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0301F8_CP_COHER_BASE, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0301E4_CP_COHER_BASE_HI, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0301F0_CP_COHER_CNTL, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0301F4_CP_COHER_SIZE, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_030230_CP_COHER_SIZE_HI, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0301F8_CP_COHER_BASE, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0301E4_CP_COHER_BASE_HI, ac_ib_get(ib), ~0);
       print_named_value(f, "POLL_INTERVAL", ac_ib_get(ib), 16);
       if (ib->gfx_level >= GFX10)
-         ac_dump_reg(f, ib->gfx_level, R_586_GCR_CNTL, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_586_GCR_CNTL, ac_ib_get(ib), ~0);
       break;
    case PKT3_SURFACE_SYNC:
       if (ib->gfx_level >= GFX7) {
-         ac_dump_reg(f, ib->gfx_level, R_0301F0_CP_COHER_CNTL, ac_ib_get(ib), ~0);
-         ac_dump_reg(f, ib->gfx_level, R_0301F4_CP_COHER_SIZE, ac_ib_get(ib), ~0);
-         ac_dump_reg(f, ib->gfx_level, R_0301F8_CP_COHER_BASE, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_0301F0_CP_COHER_CNTL, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_0301F4_CP_COHER_SIZE, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_0301F8_CP_COHER_BASE, ac_ib_get(ib), ~0);
       } else {
-         ac_dump_reg(f, ib->gfx_level, R_0085F0_CP_COHER_CNTL, ac_ib_get(ib), ~0);
-         ac_dump_reg(f, ib->gfx_level, R_0085F4_CP_COHER_SIZE, ac_ib_get(ib), ~0);
-         ac_dump_reg(f, ib->gfx_level, R_0085F8_CP_COHER_BASE, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_0085F0_CP_COHER_CNTL, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_0085F4_CP_COHER_SIZE, ac_ib_get(ib), ~0);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_0085F8_CP_COHER_BASE, ac_ib_get(ib), ~0);
       }
       print_named_value(f, "POLL_INTERVAL", ac_ib_get(ib), 16);
       break;
    case PKT3_EVENT_WRITE: {
       uint32_t event_dw = ac_ib_get(ib);
-      ac_dump_reg(f, ib->gfx_level, R_028A90_VGT_EVENT_INITIATOR, event_dw,
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_028A90_VGT_EVENT_INITIATOR, event_dw,
                   S_028A90_EVENT_TYPE(~0));
       print_named_value(f, "EVENT_INDEX", (event_dw >> 8) & 0xf, 4);
       print_named_value(f, "INV_L2", (event_dw >> 20) & 0x1, 1);
@@ -342,7 +350,7 @@ static void ac_parse_packet3(FILE *f, uint32_t header, struct ac_ib_parser *ib,
    }
    case PKT3_EVENT_WRITE_EOP: {
       uint32_t event_dw = ac_ib_get(ib);
-      ac_dump_reg(f, ib->gfx_level, R_028A90_VGT_EVENT_INITIATOR, event_dw,
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_028A90_VGT_EVENT_INITIATOR, event_dw,
                   S_028A90_EVENT_TYPE(~0));
       print_named_value(f, "EVENT_INDEX", (event_dw >> 8) & 0xf, 4);
       print_named_value(f, "TCL1_VOL_ACTION_ENA", (event_dw >> 12) & 0x1, 1);
@@ -363,9 +371,9 @@ static void ac_parse_packet3(FILE *f, uint32_t header, struct ac_ib_parser *ib,
    case PKT3_RELEASE_MEM: {
       uint32_t event_dw = ac_ib_get(ib);
       if (ib->gfx_level >= GFX10) {
-         ac_dump_reg(f, ib->gfx_level, R_490_RELEASE_MEM_OP, event_dw, ~0u);
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_490_RELEASE_MEM_OP, event_dw, ~0u);
       } else {
-         ac_dump_reg(f, ib->gfx_level, R_028A90_VGT_EVENT_INITIATOR, event_dw,
+         ac_dump_reg(f, ib->gfx_level, ib->family, R_028A90_VGT_EVENT_INITIATOR, event_dw,
                      S_028A90_EVENT_TYPE(~0));
          print_named_value(f, "EVENT_INDEX", (event_dw >> 8) & 0xf, 4);
          print_named_value(f, "TCL1_VOL_ACTION_ENA", (event_dw >> 12) & 0x1, 1);
@@ -397,52 +405,52 @@ static void ac_parse_packet3(FILE *f, uint32_t header, struct ac_ib_parser *ib,
       print_named_value(f, "POLL_INTERVAL", ac_ib_get(ib), 16);
       break;
    case PKT3_DRAW_INDEX_AUTO:
-      ac_dump_reg(f, ib->gfx_level, R_030930_VGT_NUM_INDICES, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0287F0_VGT_DRAW_INITIATOR, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_030930_VGT_NUM_INDICES, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0287F0_VGT_DRAW_INITIATOR, ac_ib_get(ib), ~0);
       break;
    case PKT3_DRAW_INDEX_2:
-      ac_dump_reg(f, ib->gfx_level, R_028A78_VGT_DMA_MAX_SIZE, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0287E8_VGT_DMA_BASE, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0287E4_VGT_DMA_BASE_HI, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_030930_VGT_NUM_INDICES, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_0287F0_VGT_DRAW_INITIATOR, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_028A78_VGT_DMA_MAX_SIZE, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0287E8_VGT_DMA_BASE, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0287E4_VGT_DMA_BASE_HI, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_030930_VGT_NUM_INDICES, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_0287F0_VGT_DRAW_INITIATOR, ac_ib_get(ib), ~0);
       break;
    case PKT3_INDEX_TYPE:
-      ac_dump_reg(f, ib->gfx_level, R_028A7C_VGT_DMA_INDEX_TYPE, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_028A7C_VGT_DMA_INDEX_TYPE, ac_ib_get(ib), ~0);
       break;
    case PKT3_NUM_INSTANCES:
-      ac_dump_reg(f, ib->gfx_level, R_030934_VGT_NUM_INSTANCES, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_030934_VGT_NUM_INSTANCES, ac_ib_get(ib), ~0);
       break;
    case PKT3_WRITE_DATA:
-      ac_dump_reg(f, ib->gfx_level, R_370_CONTROL, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_371_DST_ADDR_LO, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_372_DST_ADDR_HI, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_370_CONTROL, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_371_DST_ADDR_LO, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_372_DST_ADDR_HI, ac_ib_get(ib), ~0);
       /* The payload is written automatically */
       break;
    case PKT3_CP_DMA:
-      ac_dump_reg(f, ib->gfx_level, R_410_CP_DMA_WORD0, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_411_CP_DMA_WORD1, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_412_CP_DMA_WORD2, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_413_CP_DMA_WORD3, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_415_COMMAND, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_410_CP_DMA_WORD0, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_411_CP_DMA_WORD1, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_412_CP_DMA_WORD2, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_413_CP_DMA_WORD3, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_415_COMMAND, ac_ib_get(ib), ~0);
       break;
    case PKT3_DMA_DATA:
-      ac_dump_reg(f, ib->gfx_level, R_500_DMA_DATA_WORD0, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_501_SRC_ADDR_LO, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_502_SRC_ADDR_HI, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_503_DST_ADDR_LO, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_504_DST_ADDR_HI, ac_ib_get(ib), ~0);
-      ac_dump_reg(f, ib->gfx_level, R_415_COMMAND, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_500_DMA_DATA_WORD0, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_501_SRC_ADDR_LO, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_502_SRC_ADDR_HI, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_503_DST_ADDR_LO, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_504_DST_ADDR_HI, ac_ib_get(ib), ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_415_COMMAND, ac_ib_get(ib), ~0);
       break;
    case PKT3_INDIRECT_BUFFER_SI:
    case PKT3_INDIRECT_BUFFER_CONST:
    case PKT3_INDIRECT_BUFFER_CIK: {
       uint32_t base_lo_dw = ac_ib_get(ib);
-      ac_dump_reg(f, ib->gfx_level, R_3F0_IB_BASE_LO, base_lo_dw, ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_3F0_IB_BASE_LO, base_lo_dw, ~0);
       uint32_t base_hi_dw = ac_ib_get(ib);
-      ac_dump_reg(f, ib->gfx_level, R_3F1_IB_BASE_HI, base_hi_dw, ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_3F1_IB_BASE_HI, base_hi_dw, ~0);
       uint32_t control_dw = ac_ib_get(ib);
-      ac_dump_reg(f, ib->gfx_level, R_3F2_IB_CONTROL, control_dw, ~0);
+      ac_dump_reg(f, ib->gfx_level, ib->family, R_3F2_IB_CONTROL, control_dw, ~0);
 
       if (!ib->addr_callback)
          break;
@@ -610,6 +618,7 @@ static void format_ib_output(FILE *f, char *out)
  */
 void ac_parse_ib_chunk(FILE *f, uint32_t *ib_ptr, int num_dw, const int *trace_ids,
                        unsigned trace_id_count, enum amd_gfx_level gfx_level,
+                       enum radeon_family family,
                        ac_debug_addr_callback addr_callback, void *addr_callback_data)
 {
    struct ac_ib_parser ib = {0};
@@ -618,6 +627,7 @@ void ac_parse_ib_chunk(FILE *f, uint32_t *ib_ptr, int num_dw, const int *trace_i
    ib.trace_ids = trace_ids;
    ib.trace_id_count = trace_id_count;
    ib.gfx_level = gfx_level;
+   ib.family = family;
    ib.addr_callback = addr_callback;
    ib.addr_callback_data = addr_callback_data;
 
@@ -656,12 +666,12 @@ void ac_parse_ib_chunk(FILE *f, uint32_t *ib_ptr, int num_dw, const int *trace_i
  * \param addr_callback_data user data for addr_callback
  */
 void ac_parse_ib(FILE *f, uint32_t *ib, int num_dw, const int *trace_ids, unsigned trace_id_count,
-                 const char *name, enum amd_gfx_level gfx_level, ac_debug_addr_callback addr_callback,
-                 void *addr_callback_data)
+                 const char *name, enum amd_gfx_level gfx_level, enum radeon_family family,
+                 ac_debug_addr_callback addr_callback, void *addr_callback_data)
 {
    fprintf(f, "------------------ %s begin ------------------\n", name);
 
-   ac_parse_ib_chunk(f, ib, num_dw, trace_ids, trace_id_count, gfx_level, addr_callback,
+   ac_parse_ib_chunk(f, ib, num_dw, trace_ids, trace_id_count, gfx_level, family, addr_callback,
                      addr_callback_data);
 
    fprintf(f, "------------------- %s end -------------------\n\n", name);
diff --git a/src/amd/common/ac_debug.h b/src/amd/common/ac_debug.h
index 9ced4de06ae8..ffbc06bc0369 100644
--- a/src/amd/common/ac_debug.h
+++ b/src/amd/common/ac_debug.h
@@ -56,15 +56,17 @@ struct ac_wave_info {
 
 typedef void *(*ac_debug_addr_callback)(void *data, uint64_t addr);
 
-const char *ac_get_register_name(enum amd_gfx_level gfx_level, unsigned offset);
-void ac_dump_reg(FILE *file, enum amd_gfx_level gfx_level, unsigned offset, uint32_t value,
-                 uint32_t field_mask);
+const char *ac_get_register_name(enum amd_gfx_level gfx_level, enum radeon_family family,
+                                 unsigned offset);
+void ac_dump_reg(FILE *file, enum amd_gfx_level gfx_level, enum radeon_family family,
+                 unsigned offset, uint32_t value, uint32_t field_mask);
 void ac_parse_ib_chunk(FILE *f, uint32_t *ib, int num_dw, const int *trace_ids,
                        unsigned trace_id_count, enum amd_gfx_level gfx_level,
+                       enum radeon_family family,
                        ac_debug_addr_callback addr_callback, void *addr_callback_data);
 void ac_parse_ib(FILE *f, uint32_t *ib, int num_dw, const int *trace_ids, unsigned trace_id_count,
-                 const char *name, enum amd_gfx_level gfx_level, ac_debug_addr_callback addr_callback,
-                 void *addr_callback_data);
+                 const char *name, enum amd_gfx_level gfx_level, enum radeon_family family,
+                 ac_debug_addr_callback addr_callback, void *addr_callback_data);
 
 bool ac_vm_fault_occured(enum amd_gfx_level gfx_level, uint64_t *old_dmesg_timestamp,
                          uint64_t *out_addr);
diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 900268d7d708..94280bcee2c8 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1352,7 +1352,8 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
             exit(1);
          }
 
-         ac_parse_ib(stdout, ib, size / 4, NULL, 0, "IB", info->gfx_level, NULL, NULL);
+         ac_parse_ib(stdout, ib, size / 4, NULL, 0, "IB", info->gfx_level, info->family,
+                     NULL, NULL);
          free(ib);
          exit(0);
       }
diff --git a/src/amd/common/ac_shadowed_regs.c b/src/amd/common/ac_shadowed_regs.c
index 65a49bd9cc22..b8abcb192321 100644
--- a/src/amd/common/ac_shadowed_regs.c
+++ b/src/amd/common/ac_shadowed_regs.c
@@ -4080,10 +4080,10 @@ void ac_check_shadowed_regs(enum amd_gfx_level gfx_level, enum radeon_family fam
    if (!found || !shadowed) {
       printf("register %s: ", !found ? "not found" : "not shadowed");
       if (count > 1) {
-         printf("%s .. %s\n", ac_get_register_name(gfx_level, reg_offset),
-                ac_get_register_name(gfx_level, reg_offset + (count - 1) * 4));
+         printf("%s .. %s\n", ac_get_register_name(gfx_level, family, reg_offset),
+                ac_get_register_name(gfx_level, family, reg_offset + (count - 1) * 4));
       } else {
-         printf("%s\n", ac_get_register_name(gfx_level, reg_offset));
+         printf("%s\n", ac_get_register_name(gfx_level, family, reg_offset));
       }
    }
 }
@@ -4108,7 +4108,7 @@ void ac_print_shadowed_regs(const struct radeon_info *info)
          for (unsigned j = 0; j < ranges[i].size / 4; j++) {
             unsigned offset = ranges[i].offset + j * 4;
 
-            const char *name = ac_get_register_name(info->gfx_level, offset);
+            const char *name = ac_get_register_name(info->gfx_level, info->family, offset);
             unsigned value = -1;
 
 #ifndef _WIN32
diff --git a/src/amd/vulkan/radv_debug.c b/src/amd/vulkan/radv_debug.c
index 56706ddec8c0..5dd6d8e00b00 100644
--- a/src/amd/vulkan/radv_debug.c
+++ b/src/amd/vulkan/radv_debug.c
@@ -114,7 +114,8 @@ radv_dump_mmapped_reg(struct radv_device *device, FILE *f, unsigned offset)
    uint32_t value;
 
    if (ws->read_registers(ws, offset, 1, &value))
-      ac_dump_reg(f, device->physical_device->rad_info.gfx_level, offset, value, ~0);
+      ac_dump_reg(f, device->physical_device->rad_info.gfx_level,
+                  device->physical_device->rad_info.family, offset, value, ~0);
 }
 
 static void
@@ -151,43 +152,47 @@ radv_dump_debug_registers(struct radv_device *device, FILE *f)
 }
 
 static void
-radv_dump_buffer_descriptor(enum amd_gfx_level gfx_level, const uint32_t *desc, FILE *f)
+radv_dump_buffer_descriptor(enum amd_gfx_level gfx_level, enum radeon_family family,
+                            const uint32_t *desc, FILE *f)
 {
    fprintf(f, COLOR_CYAN "    Buffer:" COLOR_RESET "\n");
    for (unsigned j = 0; j < 4; j++)
-      ac_dump_reg(f, gfx_level, R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, desc[j], 0xffffffff);
+      ac_dump_reg(f, gfx_level, family, R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, desc[j], 0xffffffff);
 }
 
 static void
-radv_dump_image_descriptor(enum amd_gfx_level gfx_level, const uint32_t *desc, FILE *f)
+radv_dump_image_descriptor(enum amd_gfx_level gfx_level, enum radeon_family family,
+                           const uint32_t *desc, FILE *f)
 {
    unsigned sq_img_rsrc_word0 =
       gfx_level >= GFX10 ? R_00A000_SQ_IMG_RSRC_WORD0 : R_008F10_SQ_IMG_RSRC_WORD0;
 
    fprintf(f, COLOR_CYAN "    Image:" COLOR_RESET "\n");
    for (unsigned j = 0; j < 8; j++)
-      ac_dump_reg(f, gfx_level, sq_img_rsrc_word0 + j * 4, desc[j], 0xffffffff);
+      ac_dump_reg(f, gfx_level, family, sq_img_rsrc_word0 + j * 4, desc[j], 0xffffffff);
 
    fprintf(f, COLOR_CYAN "    FMASK:" COLOR_RESET "\n");
    for (unsigned j = 0; j < 8; j++)
-      ac_dump_reg(f, gfx_level, sq_img_rsrc_word0 + j * 4, desc[8 + j], 0xffffffff);
+      ac_dump_reg(f, gfx_level, family, sq_img_rsrc_word0 + j * 4, desc[8 + j], 0xffffffff);
 }
 
 static void
-radv_dump_sampler_descriptor(enum amd_gfx_level gfx_level, const uint32_t *desc, FILE *f)
+radv_dump_sampler_descriptor(enum amd_gfx_level gfx_level, enum radeon_family family,
+                             const uint32_t *desc, FILE *f)
 {
    fprintf(f, COLOR_CYAN "    Sampler state:" COLOR_RESET "\n");
    for (unsigned j = 0; j < 4; j++) {
-      ac_dump_reg(f, gfx_level, R_008F30_SQ_IMG_SAMP_WORD0 + j * 4, desc[j], 0xffffffff);
+      ac_dump_reg(f, gfx_level, family, R_008F30_SQ_IMG_SAMP_WORD0 + j * 4, desc[j], 0xffffffff);
    }
 }
 
 static void
-radv_dump_combined_image_sampler_descriptor(enum amd_gfx_level gfx_level, const uint32_t *desc,
+radv_dump_combined_image_sampler_descriptor(enum amd_gfx_level gfx_level,
+                                            enum radeon_family family, const uint32_t *desc,
                                             FILE *f)
 {
-   radv_dump_image_descriptor(gfx_level, desc, f);
-   radv_dump_sampler_descriptor(gfx_level, desc + 16, f);
+   radv_dump_image_descriptor(gfx_level, family, desc, f);
+   radv_dump_sampler_descriptor(gfx_level, family, desc + 16, f);
 }
 
 static void
@@ -195,6 +200,7 @@ radv_dump_descriptor_set(struct radv_device *device, struct radv_descriptor_set
                          FILE *f)
 {
    enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   enum radeon_family family = device->physical_device->rad_info.family;
    const struct radv_descriptor_set_layout *layout;
    int i;
 
@@ -210,18 +216,18 @@ radv_dump_descriptor_set(struct radv_device *device, struct radv_descriptor_set
       case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
       case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
       case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
-         radv_dump_buffer_descriptor(gfx_level, desc, f);
+         radv_dump_buffer_descriptor(gfx_level, family, desc, f);
          break;
       case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
       case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
       case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
-         radv_dump_image_descriptor(gfx_level, desc, f);
+         radv_dump_image_descriptor(gfx_level, family, desc, f);
          break;
       case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
-         radv_dump_combined_image_sampler_descriptor(gfx_level, desc, f);
+         radv_dump_combined_image_sampler_descriptor(gfx_level, family, desc, f);
          break;
       case VK_DESCRIPTOR_TYPE_SAMPLER:
-         radv_dump_sampler_descriptor(gfx_level, desc, f);
+         radv_dump_sampler_descriptor(gfx_level, family, desc, f);
          break;
       case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
       case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
@@ -967,26 +973,28 @@ struct radv_sq_hw_reg {
 static void
 radv_dump_sq_hw_regs(struct radv_device *device)
 {
+   enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   enum radeon_family family = device->physical_device->rad_info.family;
    struct radv_sq_hw_reg *regs = (struct radv_sq_hw_reg *)&device->tma_ptr[6];
 
    fprintf(stderr, "\nHardware registers:\n");
    if (device->physical_device->rad_info.gfx_level >= GFX10) {
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_000408_SQ_WAVE_STATUS,
+      ac_dump_reg(stderr, gfx_level, family, R_000408_SQ_WAVE_STATUS,
                   regs->status, ~0);
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_00040C_SQ_WAVE_TRAPSTS,
+      ac_dump_reg(stderr, gfx_level, family, R_00040C_SQ_WAVE_TRAPSTS,
                   regs->trap_sts, ~0);
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_00045C_SQ_WAVE_HW_ID1,
+      ac_dump_reg(stderr, gfx_level, family, R_00045C_SQ_WAVE_HW_ID1,
                   regs->hw_id, ~0);
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_00041C_SQ_WAVE_IB_STS,
+      ac_dump_reg(stderr, gfx_level, family, R_00041C_SQ_WAVE_IB_STS,
                   regs->ib_sts, ~0);
    } else {
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_000048_SQ_WAVE_STATUS,
+      ac_dump_reg(stderr, gfx_level, family, R_000048_SQ_WAVE_STATUS,
                   regs->status, ~0);
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_00004C_SQ_WAVE_TRAPSTS,
+      ac_dump_reg(stderr, gfx_level, family, R_00004C_SQ_WAVE_TRAPSTS,
                   regs->trap_sts, ~0);
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_000050_SQ_WAVE_HW_ID,
+      ac_dump_reg(stderr, gfx_level, family, R_000050_SQ_WAVE_HW_ID,
                   regs->hw_id, ~0);
-      ac_dump_reg(stderr, device->physical_device->rad_info.gfx_level, R_00005C_SQ_WAVE_IB_STS,
+      ac_dump_reg(stderr, gfx_level, family, R_00005C_SQ_WAVE_IB_STS,
                   regs->ib_sts, ~0);
    }
    fprintf(stderr, "\n\n");
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index 0b49ae221a5f..b86f0550ff62 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -1509,7 +1509,7 @@ radv_amdgpu_winsys_cs_dump(struct radeon_cmdbuf *_cs, FILE *file, const int *tra
    }
    assert(ib);
    ac_parse_ib(file, ib, num_dw, trace_ids, trace_id_count, "main IB", cs->ws->info.gfx_level,
-               radv_amdgpu_winsys_get_cpu_addr, cs);
+               cs->ws->info.family, radv_amdgpu_winsys_get_cpu_addr, cs);
 }
 
 static uint32_t
diff --git a/src/gallium/drivers/radeonsi/si_debug.c b/src/gallium/drivers/radeonsi/si_debug.c
index b62e4ca87f23..48292b773c36 100644
--- a/src/gallium/drivers/radeonsi/si_debug.c
+++ b/src/gallium/drivers/radeonsi/si_debug.c
@@ -297,7 +297,7 @@ static void si_dump_mmapped_reg(struct si_context *sctx, FILE *f, unsigned offse
    uint32_t value;
 
    if (ws->read_registers(ws, offset, 1, &value))
-      ac_dump_reg(f, sctx->gfx_level, offset, value, ~0);
+      ac_dump_reg(f, sctx->gfx_level, sctx->family, offset, value, ~0);
 }
 
 static void si_dump_debug_registers(struct si_context *sctx, FILE *f)
@@ -352,7 +352,7 @@ static void si_log_chunk_type_cs_destroy(void *data)
 
 static void si_parse_current_ib(FILE *f, struct radeon_cmdbuf *cs, unsigned begin, unsigned end,
                                 int *last_trace_id, unsigned trace_id_count, const char *name,
-                                enum amd_gfx_level gfx_level)
+                                enum amd_gfx_level gfx_level, enum radeon_family family)
 {
    unsigned orig_end = end;
 
@@ -365,7 +365,7 @@ static void si_parse_current_ib(FILE *f, struct radeon_cmdbuf *cs, unsigned begi
 
       if (begin < chunk->cdw) {
          ac_parse_ib_chunk(f, chunk->buf + begin, MIN2(end, chunk->cdw) - begin, last_trace_id,
-                           trace_id_count, gfx_level, NULL, NULL);
+                           trace_id_count, gfx_level, family, NULL, NULL);
       }
 
       if (end <= chunk->cdw)
@@ -381,7 +381,7 @@ static void si_parse_current_ib(FILE *f, struct radeon_cmdbuf *cs, unsigned begi
    assert(end <= cs->current.cdw);
 
    ac_parse_ib_chunk(f, cs->current.buf + begin, end - begin, last_trace_id, trace_id_count,
-                     gfx_level, NULL, NULL);
+                     gfx_level, family, NULL, NULL);
 
    fprintf(f, "------------------- %s end (dw = %u) -------------------\n\n", name, orig_end);
 }
@@ -389,7 +389,7 @@ static void si_parse_current_ib(FILE *f, struct radeon_cmdbuf *cs, unsigned begi
 void si_print_current_ib(struct si_context *sctx, FILE *f)
 {
    si_parse_current_ib(f, &sctx->gfx_cs, 0, sctx->gfx_cs.prev_dw + sctx->gfx_cs.current.cdw,
-                       NULL, 0, "GFX", sctx->gfx_level);
+                       NULL, 0, "GFX", sctx->gfx_level, sctx->family);
 }
 
 static void si_log_chunk_type_cs_print(void *data, FILE *f)
@@ -412,15 +412,15 @@ static void si_log_chunk_type_cs_print(void *data, FILE *f)
       if (chunk->gfx_begin == 0) {
          if (ctx->cs_preamble_state)
             ac_parse_ib(f, ctx->cs_preamble_state->pm4, ctx->cs_preamble_state->ndw, NULL, 0,
-                        "IB2: Init config", ctx->gfx_level, NULL, NULL);
+                        "IB2: Init config", ctx->gfx_level, ctx->family, NULL, NULL);
       }
 
       if (scs->flushed) {
          ac_parse_ib(f, scs->gfx.ib + chunk->gfx_begin, chunk->gfx_end - chunk->gfx_begin,
-                     &last_trace_id, map ? 1 : 0, "IB", ctx->gfx_level, NULL, NULL);
+                     &last_trace_id, map ? 1 : 0, "IB", ctx->gfx_level, ctx->family, NULL, NULL);
       } else {
          si_parse_current_ib(f, &ctx->gfx_cs, chunk->gfx_begin, chunk->gfx_end, &last_trace_id,
-                             map ? 1 : 0, "IB", ctx->gfx_level);
+                             map ? 1 : 0, "IB", ctx->gfx_level, ctx->family);
       }
    }
 
@@ -615,6 +615,7 @@ struct si_log_chunk_desc_list {
    const char *elem_name;
    slot_remap_func slot_remap;
    enum amd_gfx_level gfx_level;
+   enum radeon_family family;
    unsigned element_dw_size;
    unsigned num_elements;
 
@@ -647,36 +648,38 @@ static void si_log_chunk_desc_list_print(void *data, FILE *f)
       switch (chunk->element_dw_size) {
       case 4:
          for (unsigned j = 0; j < 4; j++)
-            ac_dump_reg(f, chunk->gfx_level, R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, gpu_list[j],
-                        0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level, chunk->family,
+                        R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, gpu_list[j], 0xffffffff);
          break;
       case 8:
          for (unsigned j = 0; j < 8; j++)
-            ac_dump_reg(f, chunk->gfx_level, sq_img_rsrc_word0 + j * 4, gpu_list[j], 0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level, chunk->family,
+                        sq_img_rsrc_word0 + j * 4, gpu_list[j], 0xffffffff);
 
          fprintf(f, COLOR_CYAN "    Buffer:" COLOR_RESET "\n");
          for (unsigned j = 0; j < 4; j++)
-            ac_dump_reg(f, chunk->gfx_level, R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, gpu_list[4 + j],
-                        0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level, chunk->family,
+                        R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, gpu_list[4 + j], 0xffffffff);
          break;
       case 16:
          for (unsigned j = 0; j < 8; j++)
-            ac_dump_reg(f, chunk->gfx_level, sq_img_rsrc_word0 + j * 4, gpu_list[j], 0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level,  chunk->family,
+                        sq_img_rsrc_word0 + j * 4, gpu_list[j], 0xffffffff);
 
          fprintf(f, COLOR_CYAN "    Buffer:" COLOR_RESET "\n");
          for (unsigned j = 0; j < 4; j++)
-            ac_dump_reg(f, chunk->gfx_level, R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, gpu_list[4 + j],
-                        0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level, chunk->family,
+                        R_008F00_SQ_BUF_RSRC_WORD0 + j * 4, gpu_list[4 + j], 0xffffffff);
 
          fprintf(f, COLOR_CYAN "    FMASK:" COLOR_RESET "\n");
          for (unsigned j = 0; j < 8; j++)
-            ac_dump_reg(f, chunk->gfx_level, sq_img_rsrc_word0 + j * 4, gpu_list[8 + j],
-                        0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level, chunk->family,
+                        sq_img_rsrc_word0 + j * 4, gpu_list[8 + j], 0xffffffff);
 
          fprintf(f, COLOR_CYAN "    Sampler state:" COLOR_RESET "\n");
          for (unsigned j = 0; j < 4; j++)
-            ac_dump_reg(f, chunk->gfx_level, R_008F30_SQ_IMG_SAMP_WORD0 + j * 4, gpu_list[12 + j],
-                        0xffffffff);
+            ac_dump_reg(f, chunk->gfx_level, chunk->family,
+                        R_008F30_SQ_IMG_SAMP_WORD0 + j * 4, gpu_list[12 + j], 0xffffffff);
          break;
       }
 
@@ -726,6 +729,7 @@ static void si_dump_descriptor_list(struct si_screen *screen, struct si_descript
    chunk->num_elements = num_elements;
    chunk->slot_remap = slot_remap;
    chunk->gfx_level = screen->info.gfx_level;
+   chunk->family = screen->info.family;
 
    si_resource_reference(&chunk->buf, desc->buffer);
    chunk->gpu_list = desc->gpu_list;
-- 
GitLab

