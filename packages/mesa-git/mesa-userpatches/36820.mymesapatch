From 38aa006506b745221ac0ecb1babef93222cadb64 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Sat, 9 Aug 2025 06:43:13 +0200
Subject: [PATCH 1/2] radv: Add comment to document CP DMA prefetch

Explain which caches (MALL, L2) the prefetch works with.
---
 src/amd/vulkan/radv_cp_dma.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/amd/vulkan/radv_cp_dma.c b/src/amd/vulkan/radv_cp_dma.c
index 2deee13b73a7e..7d5b6383f1211 100644
--- a/src/amd/vulkan/radv_cp_dma.c
+++ b/src/amd/vulkan/radv_cp_dma.c
@@ -132,6 +132,24 @@ radv_emit_cp_dma(struct radv_cmd_buffer *cmd_buffer, uint64_t dst_va, uint64_t s
       radv_cmd_buffer_trace_emit(cmd_buffer);
 }
 
+/* Emit a CP DMA prefetch.
+ * This is useful for warming up caches before draw commands,
+ * for example we use it to load shader binaries and VBO descriptors into the cache.
+ * Implemented by starting a CP DMA copy where the source and destination are the same.
+ *
+ * On GPUs where CP DMA uses L2, it loads binaries into L2.
+ * On GPUs that have MALL (infinity cache), it loads binaries into MALL.
+ *
+ * More specifically:
+ *
+ * | GPU generation  | CP DMA L2 | MALL | Prefetch location |
+ * | --------------- | --------- | ---- | ----------------- |
+ * | GFX6            | -         | -    | -                 |
+ * | GFX7 - 10       | yes       | -    | L2                |
+ * | GFX10.3 - 11.5  | yes       | yes  | L2, MALL          |
+ * | GFX12           | -         | yes  | MALL              |
+ *
+ */
 void
 radv_cs_cp_dma_prefetch(const struct radv_device *device, struct radv_cmd_stream *cs, uint64_t va, unsigned size,
                         bool predicating)
-- 
GitLab


From 6644af7c9b72767e65296409c8cd8b3a4f2af395 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Sat, 9 Aug 2025 06:44:09 +0200
Subject: [PATCH 2/2] radv: Flush L2 before CP DMA copy/fill when CP DMA
 doesn't use L2

In case the source or destination were previously written
through L2, we need to writeback L2 to avoid the CP DMA accessing
stale data.

However, as the CP DMA doesn't write L2 either, an invalidation
is also needed to make sure other clients don't access stale data
when they read it through L2 after the CP DMA is complete.

Doing an invalidation before the CP DMA operation should take
care of both.

Additionally, radv_src_access_flush also invalidates L2 before
the copied data can be read.

Cc: mesa-stable
---
 src/amd/vulkan/radv_cp_dma.c | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_cp_dma.c b/src/amd/vulkan/radv_cp_dma.c
index 7d5b6383f1211..c386ee0e19368 100644
--- a/src/amd/vulkan/radv_cp_dma.c
+++ b/src/amd/vulkan/radv_cp_dma.c
@@ -250,6 +250,11 @@ radv_cp_dma_copy_memory(struct radv_cmd_buffer *cmd_buffer, uint64_t src_va, uin
    uint64_t main_src_va, main_dest_va;
    uint64_t skipped_size = 0, realign_size = 0;
 
+   if (!(pdev->info.cp_dma_use_L2 && pdev->info.gfx_level >= GFX9)) {
+      /* Invalidate L2 in case "src_va" or "dest_va" were previously written through L2. */
+      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_INV_L2;
+   }
+
    /* Assume that we are not going to sync after the last DMA operation. */
    cmd_buffer->state.dma_is_busy = true;
 
@@ -314,9 +319,6 @@ radv_cp_dma_copy_memory(struct radv_cmd_buffer *cmd_buffer, uint64_t src_va, uin
    }
    if (realign_size)
       radv_cp_dma_realign_engine(cmd_buffer, realign_size);
-
-   if (pdev->info.cp_sdma_ge_use_system_memory_scope)
-      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_INV_L2;
 }
 
 void
@@ -328,6 +330,11 @@ radv_cp_dma_fill_memory(struct radv_cmd_buffer *cmd_buffer, uint64_t va, uint64_
    if (!size)
       return;
 
+   if (!(pdev->info.cp_dma_use_L2 && pdev->info.gfx_level >= GFX9)) {
+      /* Invalidate L2 in case "va" was previously written through L2. */
+      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_INV_L2;
+   }
+
    assert(va % 4 == 0 && size % 4 == 0);
 
    enum amd_gfx_level gfx_level = pdev->info.gfx_level;
@@ -357,9 +364,6 @@ radv_cp_dma_fill_memory(struct radv_cmd_buffer *cmd_buffer, uint64_t va, uint64_
       size -= byte_count;
       va += byte_count;
    }
-
-   if (pdev->info.cp_sdma_ge_use_system_memory_scope)
-      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_INV_L2;
 }
 
 void
-- 
GitLab

