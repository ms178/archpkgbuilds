From 9edb7a982d33fa843861f203d0170d326cea25a9 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Thu, 23 Mar 2023 14:19:29 -0700
Subject: [PATCH 1/2] intel/fs: Don't copy propagate from saturate to sel

There are already NIR algebraic optimizations (see also ac6646129f7
("nir: Move fsat outside of fmin/fmax if second arg is 0 to 1.") that
will try to remove the saturate from things like

    fmax(0.5, fsat(x))

This basically reverts 40aeb558ce8 ("i965/fs: Allow propagation of
instructions with saturate flag to sel"). That commit message had no
shader-db information, so it's unclear whether this actually helped
anything ever.

No shader-db changes on any Intel platform.

One shader in Far Cry New Dawn was affected.

Cycles in all programs: 10933090738 -> 10933090736 (-0.0%)
Cycles helped: 1

Reviewed-by: Matt Turner <mattst88@gmail.com>
---
 .../compiler/brw_fs_copy_propagation.cpp      | 24 +------------------
 .../compiler/test_fs_copy_propagation.cpp     | 12 +++++-----
 2 files changed, 7 insertions(+), 29 deletions(-)

diff --git a/src/intel/compiler/brw_fs_copy_propagation.cpp b/src/intel/compiler/brw_fs_copy_propagation.cpp
index 60603ba45572..05556943dfc0 100644
--- a/src/intel/compiler/brw_fs_copy_propagation.cpp
+++ b/src/intel/compiler/brw_fs_copy_propagation.cpp
@@ -51,7 +51,6 @@ struct acp_entry : public exec_node {
    unsigned size_written;
    unsigned size_read;
    enum opcode opcode;
-   bool saturate;
    bool is_partial_write;
    bool force_writemask_all;
 };
@@ -722,22 +721,6 @@ fs_visitor::try_copy_propagate(fs_inst *inst, int arg, acp_entry *entry)
       return false;
    }
 
-   if (entry->saturate) {
-      switch(inst->opcode) {
-      case BRW_OPCODE_SEL:
-         if ((inst->conditional_mod != BRW_CONDITIONAL_GE &&
-              inst->conditional_mod != BRW_CONDITIONAL_L) ||
-             inst->src[1].file != IMM ||
-             inst->src[1].f < 0.0 ||
-             inst->src[1].f > 1.0) {
-            return false;
-         }
-         break;
-      default:
-         return false;
-      }
-   }
-
    /* Save the offset of inst->src[arg] relative to entry->dst for it to be
     * applied later.
     */
@@ -772,9 +755,6 @@ fs_visitor::try_copy_propagate(fs_inst *inst, int arg, acp_entry *entry)
       inst->src[arg].stride *= entry->src.stride;
    }
 
-   /* Compose any saturate modifiers. */
-   inst->saturate = inst->saturate || entry->saturate;
-
    /* Compute the first component of the copy that the instruction is
     * reading, and the base byte offset within that component.
     */
@@ -821,8 +801,6 @@ fs_visitor::try_constant_propagate(fs_inst *inst, acp_entry *entry)
       return false;
    if (type_sz(entry->src.type) > 4)
       return false;
-   if (entry->saturate)
-      return false;
 
    for (int i = inst->sources - 1; i >= 0; i--) {
       if (inst->src[i].file != VGRF)
@@ -1105,6 +1083,7 @@ can_propagate_from(fs_inst *inst)
             (inst->src[0].file == FIXED_GRF &&
              inst->src[0].is_contiguous())) &&
            inst->src[0].type == inst->dst.type &&
+           !inst->saturate &&
            /* Subset of !is_partial_write() conditions. */
            !((inst->predicate && inst->opcode != BRW_OPCODE_SEL) ||
              !inst->dst.is_contiguous())) ||
@@ -1168,7 +1147,6 @@ fs_visitor::opt_copy_propagation_local(void *copy_prop_ctx, bblock_t *block,
          for (unsigned i = 0; i < inst->sources; i++)
             entry->size_read += inst->size_read(i);
          entry->opcode = inst->opcode;
-         entry->saturate = inst->saturate;
          entry->is_partial_write = inst->is_partial_write();
          entry->force_writemask_all = inst->force_writemask_all;
          acp[entry->dst.nr % ACP_HASH_SIZE].push_tail(entry);
diff --git a/src/intel/compiler/test_fs_copy_propagation.cpp b/src/intel/compiler/test_fs_copy_propagation.cpp
index 2de13476032a..c66f64fd139d 100644
--- a/src/intel/compiler/test_fs_copy_propagation.cpp
+++ b/src/intel/compiler/test_fs_copy_propagation.cpp
@@ -164,12 +164,12 @@ TEST_F(copy_propagation_test, maxmax_sat_imm)
       bool expected_result;
    } test[] = {
       /*   conditional mod,     imm, expected_result */
-      { BRW_CONDITIONAL_GE  ,  0.1f, true },
-      { BRW_CONDITIONAL_L   ,  0.1f, true },
-      { BRW_CONDITIONAL_GE  ,  0.5f, true },
-      { BRW_CONDITIONAL_L   ,  0.5f, true },
-      { BRW_CONDITIONAL_GE  ,  0.9f, true },
-      { BRW_CONDITIONAL_L   ,  0.9f, true },
+      { BRW_CONDITIONAL_GE  ,  0.1f, false },
+      { BRW_CONDITIONAL_L   ,  0.1f, false },
+      { BRW_CONDITIONAL_GE  ,  0.5f, false },
+      { BRW_CONDITIONAL_L   ,  0.5f, false },
+      { BRW_CONDITIONAL_GE  ,  0.9f, false },
+      { BRW_CONDITIONAL_L   ,  0.9f, false },
       { BRW_CONDITIONAL_GE  , -1.5f, false },
       { BRW_CONDITIONAL_L   , -1.5f, false },
       { BRW_CONDITIONAL_GE  ,  1.5f, false },
-- 
GitLab


From cdfbcebaac2b7cb4ccfc1464c5e6b79a5d8f8afb Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Thu, 23 Mar 2023 16:01:13 -0700
Subject: [PATCH 2/2] nir/algebraic: Undistribute fsat from fmax

To be helpful, the thing inside the fsat has to be used with and without
the fsat. Otherwise it just moves a saturate destination modifier
around. To not be harmful, the fsat has to only be used by the bcsel.

All Broadwell and newer Intel platforms had similar results. (Ice Lake shown)
total instructions in shared programs: 20174475 -> 20174449 (<.01%)
instructions in affected programs: 3913 -> 3887 (-0.66%)
helped: 13 / HURT: 0

total cycles in shared programs: 866844832 -> 866844719 (<.01%)
cycles in affected programs: 46037 -> 45924 (-0.25%)
helped: 10 / HURT: 1

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 161491468 -> 161491372 (-0.0%)
helped: 31 / HURT: 8

Cycles in all programs: 10933090736 -> 10933024716 (-0.0%)
helped: 32 / HURT: 18

Reviewed-by: Matt Turner <mattst88@gmail.com>
---
 src/compiler/nir/nir_opt_algebraic.py | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 1e4ea528764c..1c553c4038bd 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -833,6 +833,7 @@ optimizations.extend([
    (('umin', ('umax', ('umin', ('umax', a, b), c), b), c), ('umin', ('umax', a, b), c)),
    # Both the left and right patterns are "b" when isnan(a), so this is exact.
    (('fmax', ('fsat', a), '#b(is_zero_to_one)'), ('fsat', ('fmax', a, b))),
+   (('fmax', ('fsat(is_used_once)', a), ('fsat(is_used_once)', b)), ('fsat', ('fmax', a, b))),
    # The left pattern is 0.0 when isnan(a) (because fmin(fsat(NaN), b) ->
    # fmin(0.0, b)) while the right one is "b", so this optimization is inexact.
    (('~fmin', ('fsat', a), '#b(is_zero_to_one)'), ('fsat', ('fmin', a, b))),
-- 
GitLab

