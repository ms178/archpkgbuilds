From f5a7c06bb726c9c9c5cc32d0038bd6e2c966d06b Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Sun, 10 Jul 2022 18:04:12 +0900
Subject: [PATCH 1/6] radv: Add a radeon_cmdbuf variant for CP DMA copy helper.

For use in shader uploads. We want to avoid radv_cmd_buffer due to the
heavyweight state initialization as well as more verbose object management.
---
 src/amd/vulkan/radv_private.h  |  2 ++
 src/amd/vulkan/si_cmd_buffer.c | 31 +++++++++++++++++++++++++++++++
 2 files changed, 33 insertions(+)

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 8151dc476641..f6c38340e859 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1700,6 +1700,8 @@ void si_emit_set_predication_state(struct radv_cmd_buffer *cmd_buffer, bool draw
                                    unsigned pred_op, uint64_t va);
 void si_cp_dma_buffer_copy(struct radv_cmd_buffer *cmd_buffer, uint64_t src_va, uint64_t dest_va,
                            uint64_t size);
+void si_cs_cp_dma_buffer_copy(struct radv_device *device, struct radeon_cmdbuf *cs, uint64_t src_va,
+                              uint64_t dest_va, uint64_t size);
 void si_cs_cp_dma_prefetch(const struct radv_device *device, struct radeon_cmdbuf *cs, uint64_t va,
                            unsigned size, bool predicating);
 void si_cp_dma_prefetch(struct radv_cmd_buffer *cmd_buffer, uint64_t va, unsigned size);
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index fdc8ab5ddd6d..fbf59bdda6d6 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -1782,6 +1782,37 @@ si_cp_dma_buffer_copy(struct radv_cmd_buffer *cmd_buffer, uint64_t src_va, uint6
       si_cp_dma_realign_engine(cmd_buffer, realign_size);
 }
 
+/* A simplified version of si_cp_dma_buffer_copy for internal copies.
+ * Differences:
+ * - src_va, dest_va, size must be aligned to SI_CPDMA_ALIGNMENT.
+ * - Automatically syncs after the copy.
+ */
+void
+si_cs_cp_dma_buffer_copy(struct radv_device *device, struct radeon_cmdbuf *cs, uint64_t src_va,
+                         uint64_t dest_va, uint64_t size)
+{
+   enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+
+   while (size) {
+      unsigned dma_flags = 0;
+      unsigned byte_count = MIN2(size, cp_dma_max_byte_count(gfx_level));
+
+      if (device->physical_device->rad_info.gfx_level >= GFX9) {
+         /* See si_cp_dma_buffer_copy above for reason to use L2. */
+         dma_flags |= CP_DMA_USE_L2;
+      }
+
+      if (byte_count == size)
+         dma_flags |= CP_DMA_SYNC;
+
+      si_cs_emit_cp_dma(device, cs, false, dest_va, src_va, byte_count, dma_flags);
+
+      size -= byte_count;
+      src_va += byte_count;
+      dest_va += byte_count;
+   }
+}
+
 void
 si_cp_dma_clear_buffer(struct radv_cmd_buffer *cmd_buffer, uint64_t va, uint64_t size,
                        unsigned value)
-- 
GitLab


From 2af225aabb1f11a595895d7b171d847148fb7c03 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Sun, 10 Jul 2022 22:36:07 +0900
Subject: [PATCH 2/6] radv: Make radv_upload_shaders return bool instead of
 VkResult.

In a following patch we're going to call radv_queue_internal_submit which
returns a bool that can map to multiple VkResult.

The error codes were synthetic and the caller didn't care about the kind of
the error anyway, so simplify it to return a boolean instead.
---
 src/amd/vulkan/radv_pipeline.c       | 10 +++++-----
 src/amd/vulkan/radv_pipeline_cache.c |  5 ++---
 src/amd/vulkan/radv_private.h        |  6 +++---
 3 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index a26c5e742bf0..2ff1fcb57132 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3743,7 +3743,7 @@ non_uniform_access_callback(const nir_src *src, void *_)
 }
 
 
-VkResult
+bool
 radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
                     struct radv_shader_binary **binaries, struct radv_shader_binary *gs_copy_binary)
 {
@@ -3765,7 +3765,7 @@ radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
    /* Allocate memory for all shader binaries. */
    pipeline->slab = radv_pipeline_slab_create(device, pipeline, code_size);
    if (!pipeline->slab)
-      return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+      return false;
 
    pipeline->slab_bo = pipeline->slab->alloc->arena->bo;
 
@@ -3783,7 +3783,7 @@ radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
 
       void *dest_ptr = slab_ptr + slab_offset;
       if (!radv_shader_binary_upload(device, binaries[i], shader, dest_ptr))
-         return VK_ERROR_OUT_OF_HOST_MEMORY;
+         return false;
 
       slab_offset += align(shader->code_size, RADV_SHADER_ALLOC_ALIGNMENT);
    }
@@ -3793,10 +3793,10 @@ radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
 
       void *dest_ptr = slab_ptr + slab_offset;
       if (!radv_shader_binary_upload(device, gs_copy_binary, pipeline->gs_copy_shader, dest_ptr))
-         return VK_ERROR_OUT_OF_HOST_MEMORY;
+         return false;
    }
 
-   return VK_SUCCESS;
+   return true;
 }
 
 static bool
diff --git a/src/amd/vulkan/radv_pipeline_cache.c b/src/amd/vulkan/radv_pipeline_cache.c
index 8621b7368d98..ff6400e67a19 100644
--- a/src/amd/vulkan/radv_pipeline_cache.c
+++ b/src/amd/vulkan/radv_pipeline_cache.c
@@ -317,7 +317,6 @@ radv_create_shaders_from_pipeline_cache(
    uint32_t *num_stack_sizes, bool *found_in_application_cache)
 {
    struct cache_entry *entry;
-   VkResult result;
 
    if (!cache) {
       cache = device->mem_cache;
@@ -397,7 +396,7 @@ radv_create_shaders_from_pipeline_cache(
    }
 
    if (needs_upload) {
-      result = radv_upload_shaders(device, pipeline, binaries, gs_copy_binary);
+      bool upload_result = radv_upload_shaders(device, pipeline, binaries, gs_copy_binary);
 
       for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; ++i) {
          if (pipeline->shaders[i])
@@ -405,7 +404,7 @@ radv_create_shaders_from_pipeline_cache(
       }
       free(gs_copy_binary);
 
-      if (result != VK_SUCCESS) {
+      if (!upload_result) {
          radv_pipeline_cache_unlock(cache);
          return false;
       }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index f6c38340e859..0bf64b3b87db 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -411,9 +411,9 @@ void radv_pipeline_cache_insert_shaders(
    struct radv_pipeline *pipeline, struct radv_shader_binary *const *binaries,
    const struct radv_pipeline_shader_stack_size *stack_sizes, uint32_t num_stack_sizes);
 
-VkResult radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
-                             struct radv_shader_binary **binaries,
-                             struct radv_shader_binary *gs_copy_binary);
+bool radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
+                         struct radv_shader_binary **binaries,
+                         struct radv_shader_binary *gs_copy_binary);
 
 enum radv_blit_ds_layout {
    RADV_BLIT_DS_LAYOUT_TILE_ENABLE,
-- 
GitLab


From f93d0a7246e86b5c1f56792942a229aaaad18293 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Tue, 12 Jul 2022 17:21:15 +0900
Subject: [PATCH 3/6] radv: Upload shaders to invisible VRAM on small BAR
 systems.

Following PAL's implementation, this patch avoids allocating shader code
buffers in BAR and use compute DMA to upload them to invisible VRAM
directly.

For some games like HZD, shaders can take as much as 400MB, which exceeds
the non-resizable BAR size (256MB) and cause inconsistent spilling
behavior. The kernel will normally move these to invisible VRAM on its own,
but there are a few cases that it does not reliably happen. This patch does
the moving explicitly in the driver to ensure predictable results.

In this patch, we upload the shaders synchronously; so the shader will be
ready as soon as vkCreate*Pipeline returns. A following patch will make
this asynchronous and don't block until we see a use of the pipeline.

As a side effect, when SQTT is used we now store the shaders on a cacheable
buffer which would speed up writing the trace to the disk.
---
 src/amd/vulkan/radv_constants.h |   2 +
 src/amd/vulkan/radv_device.c    |  17 ++-
 src/amd/vulkan/radv_pipeline.c  |  49 +++++--
 src/amd/vulkan/radv_private.h   |  20 +++
 src/amd/vulkan/radv_shader.c    | 244 +++++++++++++++++++++++++++++---
 src/amd/vulkan/radv_shader.h    |  12 +-
 6 files changed, 305 insertions(+), 39 deletions(-)

diff --git a/src/amd/vulkan/radv_constants.h b/src/amd/vulkan/radv_constants.h
index 38af1d448da7..ebbd84b0555f 100644
--- a/src/amd/vulkan/radv_constants.h
+++ b/src/amd/vulkan/radv_constants.h
@@ -136,4 +136,6 @@
 #define PERF_CTR_BO_LOCK_OFFSET  0
 #define PERF_CTR_BO_FENCE_OFFSET 8
 
+#define RADV_SHADER_UPLOAD_CS_COUNT 16
+
 #endif /* RADV_CONSTANTS_H */
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 6720ac1bcc6f..54f59da44af9 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -50,6 +50,8 @@
 #include "radv_private.h"
 #include "radv_shader.h"
 #include "vk_util.h"
+#include "vk_common_entrypoints.h"
+#include "vk_semaphore.h"
 #ifdef _WIN32
 typedef void *drmDevicePtr;
 #include <io.h>
@@ -3501,8 +3503,6 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
    device->primitives_generated_query = primitives_generated_query;
    device->uses_device_generated_commands = use_dgc;
 
-   radv_init_shader_arenas(device);
-
    device->overallocation_disallowed = overallocation_disallowed;
    mtx_init(&device->overallocation_mutex, mtx_plain);
 
@@ -3518,7 +3518,7 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
 
       result = device->ws->ctx_create(device->ws, priority, &device->hw_ctx[priority]);
       if (result != VK_SUCCESS)
-         goto fail;
+         goto fail_queue;
    }
 
    for (unsigned i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
@@ -3532,7 +3532,7 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
                   VK_SYSTEM_ALLOCATION_SCOPE_DEVICE);
       if (!device->queues[qfi]) {
          result = VK_ERROR_OUT_OF_HOST_MEMORY;
-         goto fail;
+         goto fail_queue;
       }
 
       memset(device->queues[qfi], 0, queue_create->queueCount * sizeof(struct radv_queue));
@@ -3542,11 +3542,16 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
       for (unsigned q = 0; q < queue_create->queueCount; q++) {
          result = radv_queue_init(device, &device->queues[qfi][q], q, queue_create, global_priority);
          if (result != VK_SUCCESS)
-            goto fail;
+            goto fail_queue;
       }
    }
    device->private_sdma_queue = VK_NULL_HANDLE;
 
+   device->shader_use_invisible_vram = radv_shader_use_invisible_vram(&device->physical_device->rad_info, device->instance->perftest_flags);
+   device->keep_shader_staging_buf = radv_thread_trace_enabled();
+   if ((result = radv_init_shader_arenas(device)) != VK_SUCCESS)
+      goto fail;
+
    device->pbb_allowed = device->physical_device->rad_info.gfx_level >= GFX9 &&
                          !(device->instance->debug_flags & RADV_DEBUG_NOBINNING);
 
@@ -3763,6 +3768,8 @@ fail:
    radv_device_finish_vs_prologs(device);
    radv_device_finish_border_color(device);
 
+   radv_destroy_shader_arenas(device);
+fail_queue:
    for (unsigned i = 0; i < RADV_MAX_QUEUE_FAMILIES; i++) {
       for (unsigned q = 0; q < device->queue_count[i]; q++)
          radv_queue_finish(&device->queues[i][q]);
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 2ff1fcb57132..9b4b0f045aa0 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3748,6 +3748,7 @@ radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
                     struct radv_shader_binary **binaries, struct radv_shader_binary *gs_copy_binary)
 {
    uint32_t code_size = 0;
+   char *staging = NULL;
 
    /* Compute the total code size. */
    for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; i++) {
@@ -3765,38 +3766,60 @@ radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
    /* Allocate memory for all shader binaries. */
    pipeline->slab = radv_pipeline_slab_create(device, pipeline, code_size);
    if (!pipeline->slab)
-      return false;
+      goto fail;
+
+   staging = calloc(1, code_size);
 
    pipeline->slab_bo = pipeline->slab->alloc->arena->bo;
 
    /* Upload shader binaries. */
-   uint64_t slab_va = radv_buffer_get_va(pipeline->slab_bo);
-   uint32_t slab_offset = pipeline->slab->alloc->offset;
-   char *slab_ptr = pipeline->slab->alloc->arena->ptr;
+   uint64_t slab_va = radv_buffer_get_va(pipeline->slab_bo) + pipeline->slab->alloc->offset;
+   uint32_t offset = 0;
+   char *slab_ptr = pipeline->slab->alloc->arena->ptr + pipeline->slab->alloc->offset;
 
    for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; ++i) {
       struct radv_shader *shader = pipeline->shaders[i];
       if (!shader)
          continue;
 
-      shader->va = slab_va + slab_offset;
+      shader->va = slab_va + offset;
 
-      void *dest_ptr = slab_ptr + slab_offset;
-      if (!radv_shader_binary_upload(device, binaries[i], shader, dest_ptr))
-         return false;
+      if (!radv_shader_binary_reloc(device, binaries[i], shader, staging + offset))
+         goto fail;
 
-      slab_offset += align(shader->code_size, RADV_SHADER_ALLOC_ALIGNMENT);
+      if (device->keep_shader_staging_buf) {
+         shader->code_ptr = (uint8_t *)staging + offset;
+      }
+
+      offset += align(shader->code_size, RADV_SHADER_ALLOC_ALIGNMENT);
    }
 
    if (pipeline->gs_copy_shader) {
-      pipeline->gs_copy_shader->va = slab_va + slab_offset;
+      struct radv_shader *shader = pipeline->gs_copy_shader;
+      shader->va = slab_va + offset;
 
-      void *dest_ptr = slab_ptr + slab_offset;
-      if (!radv_shader_binary_upload(device, gs_copy_binary, pipeline->gs_copy_shader, dest_ptr))
-         return false;
+      if (!radv_shader_binary_reloc(device, gs_copy_binary, shader, staging + offset))
+         goto fail;
+
+      if (device->keep_shader_staging_buf) {
+         shader->code_ptr = (uint8_t *)staging + offset;
+      }
+   }
+
+   if (radv_shader_binary_upload(device, pipeline->slab->alloc->arena->bo, slab_va, slab_ptr,
+                                  staging, code_size, NULL) != VK_SUCCESS)
+      goto fail;
+
+   if (device->keep_shader_staging_buf) {
+      pipeline->shader_upload_buf = staging;
+   } else {
+      free(staging);
    }
 
    return true;
+fail:
+   free(staging);
+   return false;
 }
 
 static bool
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 0bf64b3b87db..e7981fd5f2fd 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -769,6 +769,13 @@ struct radv_queue {
    struct radv_queue_state *ace_internal_state;
 };
 
+struct radv_shader_upload_cs {
+   struct radeon_cmdbuf *cs;
+   struct radeon_winsys_bo *bo;
+   uint64_t bo_size;
+   void *map;
+};
+
 #define RADV_BORDER_COLOR_COUNT       4096
 #define RADV_BORDER_COLOR_BUFFER_SIZE (sizeof(VkClearColorValue) * RADV_BORDER_COLOR_COUNT)
 
@@ -851,6 +858,17 @@ struct radv_device {
    struct list_head shader_block_obj_pool;
    mtx_t shader_arena_mutex;
 
+   mtx_t shader_upload_queue_mutex;
+   struct radeon_winsys_ctx *shader_upload_hw_ctx;
+   uint64_t shader_upload_sem_val;
+   VkSemaphore shader_upload_sem;
+   struct radv_shader_upload_cs shader_upload_cs[RADV_SHADER_UPLOAD_CS_COUNT];
+
+   /* Whether to DMA shaders to invisible VRAM or to upload directly through BAR. */
+   bool shader_use_invisible_vram;
+   /* If true, retain shaders in system RAM to allow dumping to SQTT traces. */
+   bool keep_shader_staging_buf;
+
    /* For detecting VM faults reported by dmesg. */
    uint64_t dmesg_timestamp;
 
@@ -1972,6 +1990,8 @@ struct radv_pipeline {
    struct radv_shader *shaders[MESA_VULKAN_SHADER_STAGES];
    struct radv_shader *gs_copy_shader;
 
+   char *shader_upload_buf;
+
    struct radeon_cmdbuf cs;
    uint32_t ctx_cs_hash;
    struct radeon_cmdbuf ctx_cs;
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index b08c587785ff..7e14fbdca627 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -33,6 +33,7 @@
 #include "util/memstream.h"
 #include "util/mesa-sha1.h"
 #include "util/u_atomic.h"
+#include "radv_cs.h"
 #include "radv_debug.h"
 #include "radv_meta.h"
 #include "radv_private.h"
@@ -45,6 +46,8 @@
 #include "aco_interface.h"
 #include "sid.h"
 #include "vk_format.h"
+#include "vk_sync.h"
+#include "vk_semaphore.h"
 
 #include "aco_shader_info.h"
 #include "radv_aco_shader_info.h"
@@ -1399,6 +1402,26 @@ free_block_obj(struct radv_device *device, union radv_shader_arena_block *block)
    list_add(&block->pool, &device->shader_block_obj_pool);
 }
 
+bool
+radv_shader_use_invisible_vram(const struct radeon_info *info, uint32_t perftest)
+{
+   return !(perftest & RADV_PERFTEST_SAM) &&
+          ((perftest & RADV_PERFTEST_NO_SAM) || !info->all_vram_visible);
+}
+
+VkResult
+radv_shader_wait_for_upload(struct radv_device *device, uint64_t sem_val)
+{
+   const VkSemaphoreWaitInfo wait_info = {
+      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
+      .pSemaphores = &device->shader_upload_sem,
+      .semaphoreCount = 1,
+      .pValues = &sem_val,
+   };
+   return device->vk.dispatch_table.WaitSemaphores(radv_device_to_handle(device), &wait_info,
+                                            UINT64_MAX);
+}
+
 /* Segregated fit allocator, implementing a good-fit allocation policy.
  *
  * This is an variation of sequential fit allocation with several lists of free blocks ("holes")
@@ -1474,20 +1497,32 @@ radv_alloc_shader_memory(struct radv_device *device, uint32_t size, void *ptr)
       MAX2(RADV_SHADER_ALLOC_MIN_ARENA_SIZE
               << MIN2(RADV_SHADER_ALLOC_MAX_ARENA_SIZE_SHIFT, device->shader_arena_shift),
            size);
-   VkResult result = device->ws->buffer_create(
-      device->ws, arena_size, RADV_SHADER_ALLOC_ALIGNMENT, RADEON_DOMAIN_VRAM,
-      RADEON_FLAG_NO_INTERPROCESS_SHARING | RADEON_FLAG_32BIT |
-         (device->physical_device->rad_info.cpdma_prefetch_writes_memory ? 0
-                                                                         : RADEON_FLAG_READ_ONLY),
-      RADV_BO_PRIORITY_SHADER, 0, &arena->bo);
+   bool use_invisible = device->shader_use_invisible_vram;
+   VkResult result;
+   if (use_invisible) {
+      result = device->ws->buffer_create(
+         device->ws, arena_size, RADV_SHADER_ALLOC_ALIGNMENT, RADEON_DOMAIN_VRAM,
+         RADEON_FLAG_NO_INTERPROCESS_SHARING | RADEON_FLAG_32BIT | RADEON_FLAG_NO_CPU_ACCESS,
+         RADV_BO_PRIORITY_SHADER, 0, &arena->bo);
+   } else {
+      result = device->ws->buffer_create(
+         device->ws, arena_size, RADV_SHADER_ALLOC_ALIGNMENT, RADEON_DOMAIN_VRAM,
+         RADEON_FLAG_NO_INTERPROCESS_SHARING | RADEON_FLAG_32BIT | RADEON_FLAG_CPU_ACCESS |
+            (device->physical_device->rad_info.cpdma_prefetch_writes_memory
+                ? 0
+                : RADEON_FLAG_READ_ONLY),
+         RADV_BO_PRIORITY_SHADER, 0, &arena->bo);
+   }
    if (result != VK_SUCCESS)
       goto fail;
 
    list_inithead(&arena->entries);
 
-   arena->ptr = (char *)device->ws->buffer_map(arena->bo);
-   if (!arena->ptr)
-      goto fail;
+   if (!use_invisible) {
+      arena->ptr = (char *)device->ws->buffer_map(arena->bo);
+      if (!arena->ptr)
+         goto fail;
+   }
 
    alloc = alloc_block_obj(device);
    hole = arena_size - size > 0 ? alloc_block_obj(device) : alloc;
@@ -1582,9 +1617,15 @@ radv_free_shader_memory(struct radv_device *device, union radv_shader_arena_bloc
    mtx_unlock(&device->shader_arena_mutex);
 }
 
-void
+VkResult
 radv_init_shader_arenas(struct radv_device *device)
 {
+   VkDevice vk_device = radv_device_to_handle(device);
+   struct radeon_winsys *ws = device->ws;
+
+   const struct vk_device_dispatch_table *disp = &device->vk.dispatch_table;
+   VkResult result = VK_SUCCESS;
+
    mtx_init(&device->shader_arena_mutex, mtx_plain);
 
    device->shader_free_list_mask = 0;
@@ -1593,11 +1634,59 @@ radv_init_shader_arenas(struct radv_device *device)
    list_inithead(&device->shader_block_obj_pool);
    for (unsigned i = 0; i < RADV_SHADER_ALLOC_NUM_FREE_LISTS; i++)
       list_inithead(&device->shader_free_lists[i]);
+
+   if (device->shader_use_invisible_vram) {
+      enum radv_queue_family qf = RADV_QUEUE_COMPUTE;
+      result = ws->ctx_create(ws, RADEON_CTX_PRIORITY_MEDIUM, &device->shader_upload_hw_ctx);
+      if (result != VK_SUCCESS)
+         return result;
+      mtx_init(&device->shader_upload_queue_mutex, mtx_plain);
+
+      for (unsigned i = 0; i < RADV_SHADER_UPLOAD_CS_COUNT; i++) {
+         device->shader_upload_cs[i].cs =
+            ws->cs_create(ws, radv_queue_family_to_ring(device->physical_device, qf));
+         if (!device->shader_upload_cs[i].cs) {
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+         }
+      }
+
+      const VkSemaphoreTypeCreateInfo sem_type = {
+         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
+         .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
+         .initialValue = 0,
+      };
+      const VkSemaphoreCreateInfo sem_create = {
+         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
+         .pNext = &sem_type,
+      };
+      result = disp->CreateSemaphore(vk_device, &sem_create, NULL, &device->shader_upload_sem);
+      if (result != VK_SUCCESS)
+         return result;
+   }
+
+   return VK_SUCCESS;
 }
 
 void
 radv_destroy_shader_arenas(struct radv_device *device)
 {
+   struct vk_device_dispatch_table *disp = &device->vk.dispatch_table;
+   struct radeon_winsys *ws = device->ws;
+
+   /* Upload queue should be idle assuming that pipelines are not leaked */
+   if (device->shader_upload_sem)
+      disp->DestroySemaphore(radv_device_to_handle(device), device->shader_upload_sem, NULL);
+   for (unsigned i = 0; i < RADV_SHADER_UPLOAD_CS_COUNT; i++) {
+      if (device->shader_upload_cs[i].cs)
+         ws->cs_destroy(device->shader_upload_cs[i].cs);
+      if (device->shader_upload_cs[i].bo)
+         ws->buffer_destroy(ws, device->shader_upload_cs[i].bo);
+   }
+   if (device->shader_upload_hw_ctx) {
+      mtx_destroy(&device->shader_upload_queue_mutex);
+      ws->ctx_destroy(device->shader_upload_hw_ctx);
+   }
+
    list_for_each_entry_safe(union radv_shader_arena_block, block, &device->shader_block_obj_pool,
                             pool) free(block);
 
@@ -1952,7 +2041,7 @@ radv_open_rtld_binary(struct radv_device *device, const struct radv_shader *shad
 }
 
 bool
-radv_shader_binary_upload(struct radv_device *device, const struct radv_shader_binary *binary,
+radv_shader_binary_reloc(struct radv_device *device, const struct radv_shader_binary *binary,
                           struct radv_shader *shader, void *dest_ptr)
 {
    if (binary->type == RADV_BINARY_TYPE_RTLD) {
@@ -1975,7 +2064,6 @@ radv_shader_binary_upload(struct radv_device *device, const struct radv_shader_b
          return false;
       }
 
-      shader->code_ptr = dest_ptr;
       ac_rtld_close(&rtld_binary);
    } else {
       struct radv_shader_binary_legacy *bin = (struct radv_shader_binary_legacy *)binary;
@@ -1985,13 +2073,114 @@ radv_shader_binary_upload(struct radv_device *device, const struct radv_shader_b
       uint32_t *ptr32 = (uint32_t *)dest_ptr + bin->code_size / 4;
       for (unsigned i = 0; i < DEBUGGER_NUM_MARKERS; i++)
          ptr32[i] = DEBUGGER_END_OF_CODE_MARKER;
-
-      shader->code_ptr = dest_ptr;
    }
 
    return true;
 }
 
+/**
+ * When using invisible VRAM for shaders, schedule the upload using DMA. Otherwise, memcpy staging
+ * to mapped.
+ * If out_sem_val is NULL, this function blocks until the DMA is complete. Otherwise, the semaphore
+ * value to wait on device->shader_upload_sem is stored in *out_sem_val.
+ */
+VkResult
+radv_shader_binary_upload(struct radv_device *device, struct radeon_winsys_bo *bo, uint64_t va,
+                          char *mapped, char *staging, unsigned len, uint64_t *out_sem_val)
+{
+   if (!device->shader_use_invisible_vram) {
+      memcpy(mapped, staging, len);
+      return VK_SUCCESS;
+   }
+
+   uint64_t sem_val = p_atomic_inc_return(&device->shader_upload_sem_val);
+   uint64_t i = sem_val % RADV_SHADER_UPLOAD_CS_COUNT;
+
+   struct radv_shader_upload_cs *upload_cs = &device->shader_upload_cs[i];
+   struct radeon_cmdbuf *cs = upload_cs->cs;
+   struct radeon_winsys *ws = device->ws;
+
+   VkResult result;
+
+   /* Make sure we don't reset an in-flight command buffer */
+   uint64_t wait_val = MAX2(RADV_SHADER_UPLOAD_CS_COUNT, sem_val) - RADV_SHADER_UPLOAD_CS_COUNT;
+   result = radv_shader_wait_for_upload(device, wait_val);
+   if (unlikely(result != VK_SUCCESS))
+      return result;
+
+   ws->cs_reset(cs);
+
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+   const bool is_mec = gfx_level >= GFX7; /* Shader upload always uses compute */
+   enum rgp_flush_bits sqtt_flush_bits = 0;
+   enum radv_cmd_flush_bits flush_bits = RADV_CMD_FLAG_INV_L2;
+   radeon_check_space(ws, cs, 32);
+   if (device->physical_device->rad_info.gfx_level >= GFX9 &&
+       device->physical_device->rad_info.gfx_level < GFX11) {
+      radeon_set_uconfig_reg(cs, R_0301EC_CP_COHER_START_DELAY,
+                             device->physical_device->rad_info.gfx_level >= GFX10 ? 0x20 : 0);
+   }
+   si_cs_emit_cache_flush(cs, gfx_level, NULL, 0, is_mec, flush_bits, &sqtt_flush_bits, 0);
+
+   if (upload_cs->bo_size < len) {
+      if (upload_cs->bo) {
+         ws->buffer_destroy(ws, upload_cs->bo);
+      }
+      result = ws->buffer_create(ws, len, RADV_SHADER_ALLOC_ALIGNMENT, ws->cs_domain(ws),
+                                 RADEON_FLAG_CPU_ACCESS | RADEON_FLAG_NO_INTERPROCESS_SHARING |
+                                    RADEON_FLAG_32BIT | RADEON_FLAG_GTT_WC,
+                                 RADV_BO_PRIORITY_UPLOAD_BUFFER, 0, &upload_cs->bo);
+      if (unlikely(result != VK_SUCCESS))
+         return result;
+      upload_cs->map = ws->buffer_map(upload_cs->bo);
+      upload_cs->bo_size = len;
+   }
+   memcpy(upload_cs->map, staging, len);
+   radv_cs_add_buffer(ws, cs, upload_cs->bo);
+   radv_cs_add_buffer(ws, cs, bo);
+   /* Compute-based copy requires shaders which might not have been uploaded yet, so use CP DMA
+    * even if it might be slightly slower */
+   si_cs_cp_dma_buffer_copy(device, cs, radv_buffer_get_va(upload_cs->bo), va, len);
+
+   result = ws->cs_finalize(cs);
+   if (unlikely(result != VK_SUCCESS))
+      return result;
+
+   struct vk_semaphore *semaphore = vk_semaphore_from_handle(device->shader_upload_sem);
+   struct vk_sync *sync = vk_semaphore_get_active_sync(semaphore);
+   const struct vk_sync_signal signal_info = {
+      .sync = sync,
+      .signal_value = sem_val,
+      .stage_mask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
+   };
+
+   struct radv_winsys_submit_info submit = {
+      .ip_type = AMD_IP_COMPUTE,
+      .queue_index = 0,
+      .cs_array = &cs,
+      .cs_count = 1,
+   };
+
+   mtx_lock(&device->shader_upload_queue_mutex);
+   result =
+      ws->cs_submit(device->shader_upload_hw_ctx, 1, &submit, 0, NULL, 1, &signal_info, false);
+   if (unlikely(result != VK_SUCCESS)) {
+      mtx_unlock(&device->shader_upload_queue_mutex);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+   }
+   mtx_unlock(&device->shader_upload_queue_mutex);
+
+   if (out_sem_val) {
+      *out_sem_val = sem_val;
+   } else {
+      result = radv_shader_wait_for_upload(device, sem_val);
+      if (unlikely(result != VK_SUCCESS))
+         return result;
+   }
+
+   return VK_SUCCESS;
+}
+
 struct radv_shader *
 radv_shader_create(struct radv_device *device, const struct radv_shader_binary *binary,
                    bool keep_shader_info, bool from_cache, const struct radv_shader_args *args)
@@ -2315,10 +2504,18 @@ radv_create_trap_handler_shader(struct radv_device *device)
    trap->alloc = radv_alloc_shader_memory(device, shader->code_size, NULL);
 
    trap->bo = trap->alloc->arena->bo;
+   uint64_t dest_va = radv_buffer_get_va(trap->alloc->arena->bo) + trap->alloc->offset;
    char *dest_ptr = trap->alloc->arena->ptr + trap->alloc->offset;
 
    struct radv_shader_binary_legacy *bin = (struct radv_shader_binary_legacy *)binary;
-   memcpy(dest_ptr, bin->data, bin->code_size);
+   if (radv_shader_binary_upload(device, trap->bo, dest_va, dest_ptr, (char *)bin->data,
+                                 bin->code_size, NULL) != VK_SUCCESS) {
+      radv_free_shader_memory(device, trap->alloc);
+      ralloc_free(b.shader);
+      free(shader);
+      free(binary);
+      return NULL;
+   }
 
    ralloc_free(b.shader);
    free(shader);
@@ -2346,7 +2543,7 @@ static struct radv_shader_part *
 upload_shader_part(struct radv_device *device, struct radv_shader_part_binary *bin, unsigned wave_size)
 {
    uint32_t code_size = radv_get_shader_binary_size(bin->code_size);
-   struct radv_shader_part *shader_part = malloc(sizeof(struct radv_shader_part));
+   struct radv_shader_part *shader_part = calloc(1, sizeof(struct radv_shader_part));
    if (!shader_part)
       return NULL;
 
@@ -2361,10 +2558,11 @@ upload_shader_part(struct radv_device *device, struct radv_shader_part_binary *b
    shader_part->bo = shader_part->alloc->arena->bo;
    char *dest_ptr = shader_part->alloc->arena->ptr + shader_part->alloc->offset;
 
-   memcpy(dest_ptr, bin->data, bin->code_size);
+   char *staging = calloc(1, code_size);
+   memcpy(staging, bin->data, bin->code_size);
 
    /* Add end-of-code markers for the UMR disassembler. */
-   uint32_t *ptr32 = (uint32_t *)dest_ptr + bin->code_size / 4;
+   uint32_t *ptr32 = (uint32_t *)staging + bin->code_size / 4;
    for (unsigned i = 0; i < DEBUGGER_NUM_MARKERS; i++)
       ptr32[i] = DEBUGGER_END_OF_CODE_MARKER;
 
@@ -2373,6 +2571,16 @@ upload_shader_part(struct radv_device *device, struct radv_shader_part_binary *b
    shader_part->num_preserved_sgprs = bin->num_preserved_sgprs;
    shader_part->disasm_string = NULL;
 
+   uint64_t slab_va = radv_buffer_get_va(shader_part->alloc->arena->bo);
+   uint32_t slab_offset = shader_part->alloc->offset;
+   if (radv_shader_binary_upload(device, shader_part->bo, slab_va + slab_offset, dest_ptr, staging,
+                                 bin->code_size, NULL) != VK_SUCCESS) {
+      free(staging);
+      free(shader_part);
+      return NULL;
+   }
+   free(staging);
+
    return shader_part;
 }
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index b224005ec5aa..22790fd47748 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -548,7 +548,7 @@ void radv_nir_lower_abi(nir_shader *shader, enum amd_gfx_level gfx_level,
                         const struct radv_shader_info *info, const struct radv_shader_args *args,
                         const struct radv_pipeline_key *pl_key, bool use_llvm);
 
-void radv_init_shader_arenas(struct radv_device *device);
+VkResult radv_init_shader_arenas(struct radv_device *device);
 void radv_destroy_shader_arenas(struct radv_device *device);
 
 struct radv_pipeline_shader_stack_size;
@@ -576,8 +576,14 @@ struct radv_shader *radv_shader_nir_to_asm(
    int shader_count, const struct radv_pipeline_key *key, bool keep_shader_info, bool keep_statistic_info,
    struct radv_shader_binary **binary_out);
 
-bool radv_shader_binary_upload(struct radv_device *device, const struct radv_shader_binary *binary,
-                               struct radv_shader *shader, void *dest_ptr);
+bool radv_shader_binary_reloc(struct radv_device *device, const struct radv_shader_binary *binary,
+                              struct radv_shader *shader, void *dest_ptr);
+VkResult radv_shader_binary_upload(struct radv_device *device, struct radeon_winsys_bo *bo,
+                                   uint64_t va, char *mapped, char *staging, unsigned len,
+                                   uint64_t *out_sem_val);
+
+bool radv_shader_use_invisible_vram(const struct radeon_info *info, uint32_t perftest);
+VkResult radv_shader_wait_for_upload(struct radv_device *device, uint64_t sem_val);
 
 union radv_shader_arena_block *radv_alloc_shader_memory(struct radv_device *device, uint32_t size,
                                                         void *ptr);
-- 
GitLab


From ca2ebf80baa7d689c79fda9d7ea48f477f50ae29 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Tue, 12 Jul 2022 17:25:00 +0900
Subject: [PATCH 4/6] radv: Wait for shader uploads asynchronously.

This introduces tracking of the required semaphore values in pipelines,
which is then propagated to cmd_buffers on bind. Each queue also keeps
track the maximum count it has waited for, so that we can avoid the waiting
overhead once all the shaders are loaded and referenced.
---
 src/amd/vulkan/radv_cmd_buffer.c |  8 ++++++++
 src/amd/vulkan/radv_device.c     | 33 +++++++++++++++++++++++++++++++-
 src/amd/vulkan/radv_pipeline.c   | 10 +++++++++-
 src/amd/vulkan/radv_private.h    |  5 +++++
 src/amd/vulkan/radv_shader.c     |  7 ++++++-
 src/amd/vulkan/radv_shader.h     |  1 +
 6 files changed, 61 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 2b1924788b0a..2dd7f2d5e8d9 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -430,6 +430,7 @@ radv_reset_cmd_buffer(struct radv_cmd_buffer *cmd_buffer)
    cmd_buffer->ace_internal.sem.gfx2ace_value = 0;
    cmd_buffer->ace_internal.sem.emitted_gfx2ace_value = 0;
    cmd_buffer->ace_internal.sem.va = 0;
+   cmd_buffer->shader_upload_sem_val = 0;
 
    if (cmd_buffer->upload.upload_bo)
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, cmd_buffer->upload.upload_bo);
@@ -3210,6 +3211,7 @@ radv_emit_vertex_input(struct radv_cmd_buffer *cmd_buffer, bool pipeline_is_dirt
       cmd_buffer->record_result = VK_ERROR_OUT_OF_HOST_MEMORY;
       return;
    }
+   cmd_buffer->shader_upload_sem_val = MAX2(cmd_buffer->shader_upload_sem_val, prolog->upload_sem_val);
    emit_prolog_regs(cmd_buffer, vs_shader, prolog, pipeline_is_dirty);
    emit_prolog_inputs(cmd_buffer, vs_shader, nontrivial_divisors, pipeline_is_dirty);
 
@@ -5419,6 +5421,10 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
    RADV_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
    RADV_FROM_HANDLE(radv_pipeline, pipeline, _pipeline);
 
+   if (pipeline)
+      cmd_buffer->shader_upload_sem_val =
+         MAX2(cmd_buffer->shader_upload_sem_val, pipeline->shader_upload_sem_val);
+
    switch (pipelineBindPoint) {
    case VK_PIPELINE_BIND_POINT_COMPUTE: {
       struct radv_compute_pipeline *compute_pipeline = radv_pipeline_to_compute(pipeline);
@@ -6086,6 +6092,8 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
       if (secondary->gds_needed)
          primary->gds_needed = true;
 
+      primary->shader_upload_sem_val = MAX2(primary->shader_upload_sem_val, secondary->shader_upload_sem_val);
+
       if (!secondary->state.framebuffer && primary->state.pass && (primary->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)) {
          /* Emit the framebuffer state from primary if secondary
           * has been recorded without a framebuffer, otherwise
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 54f59da44af9..b8dca99bf121 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -5068,6 +5068,19 @@ radv_queue_submit_empty(struct radv_queue *queue, struct vk_queue_submit *submis
                                        submission->signal_count, submission->signals, false);
 }
 
+static void
+radv_get_shader_upload_sync_wait(struct radv_device *device, uint64_t shader_upload_sem_val,
+                                 struct vk_sync_wait *out_sync_wait)
+{
+   struct vk_semaphore *semaphore = vk_semaphore_from_handle(device->shader_upload_sem);
+   struct vk_sync *sync = vk_semaphore_get_active_sync(semaphore);
+   *out_sync_wait = (struct vk_sync_wait){
+      .sync = sync,
+      .wait_value = shader_upload_sem_val,
+      .stage_mask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
+   };
+}
+
 static VkResult
 radv_queue_submit_with_ace(struct radv_queue *queue, struct vk_queue_submit *submission,
                            struct radeon_cmdbuf **cs_array, unsigned cs_count, unsigned cs_offset,
@@ -5169,6 +5182,9 @@ radv_queue_submit_normal(struct radv_queue *queue, struct vk_queue_submit *submi
    uint32_t advance;
    VkResult result;
    bool uses_perf_counters = false;
+   uint64_t shader_upload_sem_val = 0;
+   uint32_t wait_count = submission->wait_count;
+   struct vk_sync_wait *waits = submission->waits;
 
    result = radv_update_preambles(&queue->state, queue->device, submission->command_buffers,
                                   submission->command_buffer_count, &uses_perf_counters);
@@ -5196,6 +5212,16 @@ radv_queue_submit_normal(struct radv_queue *queue, struct vk_queue_submit *submi
 
       cmd_buffer->status = RADV_CMD_BUFFER_STATUS_PENDING;
       use_ace |= radv_cmd_buffer_needs_ace(cmd_buffer);
+      shader_upload_sem_val = MAX2(shader_upload_sem_val, cmd_buffer->shader_upload_sem_val);
+   }
+
+   if (shader_upload_sem_val > queue->last_shader_upload_sem_val) {
+      /* Patch `waits` to additionally wait for the referenced shaders to be uploaded */
+      waits = malloc(sizeof(struct vk_sync_wait) * (wait_count + 1));
+      wait_count += 1;
+      memcpy(waits, submission->waits, sizeof(struct vk_sync_wait) * submission->wait_count);
+      radv_get_shader_upload_sync_wait(queue->device, shader_upload_sem_val,
+                                       &waits[submission->wait_count]);
    }
 
    if (uses_perf_counters) {
@@ -5240,7 +5266,7 @@ radv_queue_submit_normal(struct radv_queue *queue, struct vk_queue_submit *submi
       submit.cs_count = advance;
 
       result = queue->device->ws->cs_submit(
-         ctx, 1, &submit, j == 0 ? submission->wait_count : 0, submission->waits,
+         ctx, 1, &submit, j == 0 ? wait_count : 0, waits,
          last_submit ? submission->signal_count : 0, submission->signals, can_patch);
 
       if (result != VK_SUCCESS)
@@ -5258,8 +5284,13 @@ radv_queue_submit_normal(struct radv_queue *queue, struct vk_queue_submit *submi
       submit.initial_preamble_cs = queue->state.initial_preamble_cs;
    }
 
+   queue->last_shader_upload_sem_val =
+      MAX2(queue->last_shader_upload_sem_val, shader_upload_sem_val);
+
 fail:
    free(cs_array);
+   if (waits != submission->waits)
+      free(waits);
    if (queue->device->trace_bo)
       simple_mtx_unlock(&queue->device->trace_mtx);
 
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 9b4b0f045aa0..5b016be48ede 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -194,6 +194,11 @@ void
 radv_pipeline_destroy(struct radv_device *device, struct radv_pipeline *pipeline,
                       const VkAllocationCallbacks *allocator)
 {
+   if (device->shader_use_invisible_vram) {
+      /* Wait for any pending upload to complete, or we'll be writing into freed shader memory. */
+      radv_shader_wait_for_upload(device, pipeline->shader_upload_sem_val);
+   }
+
    if (pipeline->type == RADV_PIPELINE_GRAPHICS) {
       struct radv_graphics_pipeline *graphics_pipeline = radv_pipeline_to_graphics(pipeline);
 
@@ -240,6 +245,9 @@ radv_pipeline_destroy(struct radv_device *device, struct radv_pipeline *pipeline
    if (pipeline->gs_copy_shader)
       radv_shader_unref(device, pipeline->gs_copy_shader);
 
+   if (pipeline->shader_upload_buf)
+      free(pipeline->shader_upload_buf);
+
    if (pipeline->cs.buf)
       free(pipeline->cs.buf);
 
@@ -3807,7 +3815,7 @@ radv_upload_shaders(struct radv_device *device, struct radv_pipeline *pipeline,
    }
 
    if (radv_shader_binary_upload(device, pipeline->slab->alloc->arena->bo, slab_va, slab_ptr,
-                                  staging, code_size, NULL) != VK_SUCCESS)
+                                  staging, code_size, &pipeline->shader_upload_sem_val) != VK_SUCCESS)
       goto fail;
 
    if (device->keep_shader_staging_buf) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index e7981fd5f2fd..00a9a34430de 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -767,6 +767,8 @@ struct radv_queue {
    enum radeon_ctx_priority priority;
    struct radv_queue_state state;
    struct radv_queue_state *ace_internal_state;
+
+   uint64_t last_shader_upload_sem_val;
 };
 
 struct radv_shader_upload_cs {
@@ -1680,6 +1682,8 @@ struct radv_cmd_buffer {
     * Bitmask of pending active query flushes.
     */
    enum radv_cmd_flush_bits active_query_flush_bits;
+
+   uint64_t shader_upload_sem_val;
 };
 
 struct radv_image;
@@ -1991,6 +1995,7 @@ struct radv_pipeline {
    struct radv_shader *gs_copy_shader;
 
    char *shader_upload_buf;
+   uint64_t shader_upload_sem_val;
 
    struct radeon_cmdbuf cs;
    uint32_t ctx_cs_hash;
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 7e14fbdca627..d9686cb90f29 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2574,7 +2574,7 @@ upload_shader_part(struct radv_device *device, struct radv_shader_part_binary *b
    uint64_t slab_va = radv_buffer_get_va(shader_part->alloc->arena->bo);
    uint32_t slab_offset = shader_part->alloc->offset;
    if (radv_shader_binary_upload(device, shader_part->bo, slab_va + slab_offset, dest_ptr, staging,
-                                 bin->code_size, NULL) != VK_SUCCESS) {
+                                 bin->code_size, &shader_part->upload_sem_val) != VK_SUCCESS) {
       free(staging);
       free(shader_part);
       return NULL;
@@ -2743,6 +2743,11 @@ radv_shader_part_destroy(struct radv_device *device, struct radv_shader_part *sh
 {
    assert(shader_part->ref_count == 0);
 
+   if (device->shader_use_invisible_vram) {
+      /* Wait for any pending upload to complete, or we'll be writing into freed shader memory. */
+      radv_shader_wait_for_upload(device, shader_part->upload_sem_val);
+   }
+
    radv_free_shader_memory(device, shader_part->alloc);
    free(shader_part->disasm_string);
    free(shader_part);
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 22790fd47748..2bf7ee263eb6 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -520,6 +520,7 @@ struct radv_shader_part {
    uint32_t rsrc1;
    uint8_t num_preserved_sgprs;
    bool nontrivial_divisors;
+   uint64_t upload_sem_val;
 
    /* debug only */
    char *disasm_string;
-- 
GitLab


From 584048eadccca24fb7a81c061f988560b49271b1 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Sun, 10 Jul 2022 23:16:39 +0900
Subject: [PATCH 5/6] radv: Assume all_vram_vis in null winsys.

To disable the staged-upload mechanism which requires GPU command execution
to operate.
---
 src/amd/vulkan/winsys/null/radv_null_winsys.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/amd/vulkan/winsys/null/radv_null_winsys.c b/src/amd/vulkan/winsys/null/radv_null_winsys.c
index c7bc1f3bb4c0..11a49089652d 100644
--- a/src/amd/vulkan/winsys/null/radv_null_winsys.c
+++ b/src/amd/vulkan/winsys/null/radv_null_winsys.c
@@ -136,6 +136,8 @@ radv_null_winsys_query_info(struct radeon_winsys *rws, struct radeon_info *info)
    info->max_render_backends = gpu_info[info->family].num_render_backends;
 
    info->has_dedicated_vram = gpu_info[info->family].has_dedicated_vram;
+   /* Avoid use of staged shader uploads which requires CS submissions */
+   info->all_vram_visible = true;
    info->has_packed_math_16bit = info->gfx_level >= GFX9;
 
    info->has_image_load_dcc_bug =
-- 
GitLab


From 44212a4ddafb247fa7dbeb094ad4513c1a7410fa Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Sun, 24 Jul 2022 15:22:15 +0900
Subject: [PATCH 6/6] radv: Gate invisible VRAM shader uploads behind
 RADV_PERFTEST=dmashaders.

Since this code path is new, gate it behind a flag until we can confirm
stability and its performance implications.
---
 docs/envvars.rst             | 2 ++
 src/amd/vulkan/radv_debug.h  | 1 +
 src/amd/vulkan/radv_device.c | 3 ++-
 src/amd/vulkan/radv_shader.c | 3 +--
 4 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/docs/envvars.rst b/docs/envvars.rst
index 9cdfe36904e0..db16577a1213 100644
--- a/docs/envvars.rst
+++ b/docs/envvars.rst
@@ -765,6 +765,8 @@ RADV driver environment variables
       enable wave32 for compute shaders (GFX10+)
    ``dccmsaa``
       enable DCC for MSAA images
+   ``dmashaders``
+      upload shaders to invisible VRAM (might be useful for non-resizable BAR systems)
    ``emulate_rt``
       forces ray-tracing to be emulated in software on GFX10_3+ and enables
       rt extensions with older hardware.
diff --git a/src/amd/vulkan/radv_debug.h b/src/amd/vulkan/radv_debug.h
index 930dbd1c56f2..17edba4955b5 100644
--- a/src/amd/vulkan/radv_debug.h
+++ b/src/amd/vulkan/radv_debug.h
@@ -84,6 +84,7 @@ enum {
    RADV_PERFTEST_NV_MS = 1u << 11,
    RADV_PERFTEST_RT_WAVE_64 = 1u << 12,
    RADV_PERFTEST_GPL = 1u << 13,
+   RADV_PERFTEST_DMA_SHADERS = 1u << 14,
 };
 
 bool radv_init_trace(struct radv_device *device);
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index b8dca99bf121..c8b7071fa2ee 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1005,6 +1005,7 @@ static const struct debug_control radv_perftest_options[] = {{"localbos", RADV_P
                                                              {"nv_ms", RADV_PERFTEST_NV_MS},
                                                              {"rtwave64", RADV_PERFTEST_RT_WAVE_64},
                                                              {"gpl", RADV_PERFTEST_GPL},
+                                                             {"dmashaders", RADV_PERFTEST_DMA_SHADERS},
                                                              {NULL, 0}};
 
 const char *
@@ -6688,7 +6689,7 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
             ds->db_stencil_info |= S_02803C_TILE_STENCIL_DISABLE(1);
          }
 
-         va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset + 
+         va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset +
             surf->meta_offset;
          ds->db_htile_data_base = va >> 8;
          ds->db_htile_surface = S_028ABC_FULL_CACHE(1) | S_028ABC_PIPE_ALIGNED(1);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index d9686cb90f29..2efafa2a09c8 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1405,8 +1405,7 @@ free_block_obj(struct radv_device *device, union radv_shader_arena_block *block)
 bool
 radv_shader_use_invisible_vram(const struct radeon_info *info, uint32_t perftest)
 {
-   return !(perftest & RADV_PERFTEST_SAM) &&
-          ((perftest & RADV_PERFTEST_NO_SAM) || !info->all_vram_visible);
+   return perftest & RADV_PERFTEST_DMA_SHADERS;
 }
 
 VkResult
-- 
GitLab

