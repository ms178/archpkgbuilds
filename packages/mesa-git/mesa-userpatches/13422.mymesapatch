From 8ed7877581d14cc4820ce11fbef93a891208c015 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Sun, 17 Oct 2021 22:24:10 +0530
Subject: [PATCH 1/8] egl: add fd_display_gpu to struct dri2_egl_display

fd opened on display gpu is saved in fd_display_gpu. It is later used
to create dri screen on display gpu.

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.h             | 1 +
 src/egl/drivers/dri2/platform_android.c     | 1 +
 src/egl/drivers/dri2/platform_device.c      | 1 +
 src/egl/drivers/dri2/platform_drm.c         | 1 +
 src/egl/drivers/dri2/platform_surfaceless.c | 1 +
 src/egl/drivers/dri2/platform_wayland.c     | 1 +
 src/egl/drivers/dri2/platform_x11.c         | 3 +++
 7 files changed, 9 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 1c840a966b3c..f0c570266a91 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -237,6 +237,7 @@ struct dri2_egl_display
    const __DRIconfigOptionsExtension *configOptions;
    const __DRImutableRenderBufferDriverExtension *mutable_render_buffer;
    int fd;
+   int fd_display_gpu;
 
    /* dri2_initialize/dri2_terminate increment/decrement this count, so does
     * dri2_make_current (tracks if there are active contexts/surfaces). */
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index e0ec9ae795cd..29031a5967c4 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -1684,6 +1684,7 @@ dri2_initialize_android(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID,
                        (const hw_module_t **)&dri2_dpy->gralloc);
    if (ret) {
diff --git a/src/egl/drivers/dri2/platform_device.c b/src/egl/drivers/dri2/platform_device.c
index 66b2eee08ee4..34c2e82c85b4 100644
--- a/src/egl/drivers/dri2/platform_device.c
+++ b/src/egl/drivers/dri2/platform_device.c
@@ -352,6 +352,7 @@ dri2_initialize_device(_EGLDisplay *disp)
    dev = disp->PlatformDisplay;
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->Device = dev;
    disp->DriverData = (void *) dri2_dpy;
    err = "DRI2: failed to load driver";
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index 45895a88b6c0..ce906e977141 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -692,6 +692,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    gbm = disp->PlatformDisplay;
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index df88c54cf84b..82d44e3cd224 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -334,6 +334,7 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    /* When ForceSoftware is false, we try the HW driver.  When ForceSoftware
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 634c6062d4f3..c7548ccb9d55 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2081,6 +2081,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    if (dri2_wl_formats_init(&dri2_dpy->formats) < 0)
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index 53302981fc26..15b497ce4b21 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -1413,6 +1413,7 @@ dri2_initialize_x11_swrast(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
@@ -1497,6 +1498,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
@@ -1605,6 +1607,7 @@ dri2_initialize_x11_dri2(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
-- 
GitLab


From 92eec735eac0baff1068ca1a4ecc2c4029495506 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 22 Nov 2021 21:04:53 +0530
Subject: [PATCH 2/8] egl,egl/x11: keep display fd open for prime

Keep the display fd open for creating DRI screen on display gpu in
case of prime. Also close the fd opened in dri2_display_destroy()

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c          | 2 ++
 src/egl/drivers/dri2/platform_x11_dri3.c | 6 ++++++
 2 files changed, 8 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 3682d05be954..7df135f0ecde 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1236,6 +1236,8 @@ dri2_display_destroy(_EGLDisplay *disp)
    }
    if (dri2_dpy->fd >= 0)
       close(dri2_dpy->fd);
+   if (dri2_dpy->fd_display_gpu >= 0)
+      close(dri2_dpy->fd_display_gpu);
 
    /* Don't dlclose the driver when building with the address sanitizer, so you
     * get good symbols from the leak reports.
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index 3d7c2ae44012..45291ce85711 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -24,6 +24,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <fcntl.h>
 
 #include <xcb/xcb.h>
 #include <xcb/dri3.h>
@@ -633,7 +634,12 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
       return EGL_FALSE;
    }
 
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
    dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd, &dri2_dpy->is_different_gpu);
+   if (!dri2_dpy->is_different_gpu) {
+      close(dri2_dpy->fd_display_gpu);
+      dri2_dpy->fd_display_gpu = -1;
+   }
 
    dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
    if (!dri2_dpy->driver_name) {
-- 
GitLab


From 3b5489e24d2b7bb988b550896bf6e84b22d8847a Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 18 Oct 2021 09:52:16 +0530
Subject: [PATCH 3/8] egl: create DRI screen for display GPU in case of prime
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The created DRI screen can be used to allocate VRAM memory from
display GPU in case of prime.

v2: remove extra whitespace (Marek Olšák)
Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 26 ++++++++++++++++++++++++++
 src/egl/drivers/dri2/egl_dri2.h |  1 +
 2 files changed, 27 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 7df135f0ecde..5a275c9995e4 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1062,8 +1062,30 @@ EGLBoolean
 dri2_create_screen(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   char *driver_name_display_gpu;
 
    if (dri2_dpy->image_driver) {
+      /* create screen on display gpu in case of prime */
+      if (dri2_dpy->fd_display_gpu >= 0) {
+         driver_name_display_gpu = loader_get_driver_for_fd(dri2_dpy->fd_display_gpu);
+         if (driver_name_display_gpu) {
+            /* check if driver name is matching so that non mesa drivers
+             * will not crash. Also need this check since image extension
+             * pointer from render gpu is shared with display gpu. Image
+             * extension pointer is shared because it keeps things simple.
+             */
+            if (strcmp(dri2_dpy->driver_name, driver_name_display_gpu) == 0) {
+               dri2_dpy->dri_screen_display_gpu =
+                  dri2_dpy->image_driver->createNewScreen2(0, dri2_dpy->fd_display_gpu,
+                                                           dri2_dpy->loader_extensions,
+                                                           dri2_dpy->driver_extensions,
+                                                           &dri2_dpy->driver_configs,
+                                                           disp);
+            }
+            free(driver_name_display_gpu);
+         }
+      }
+
       dri2_dpy->dri_screen =
          dri2_dpy->image_driver->createNewScreen2(0, dri2_dpy->fd,
                                                   dri2_dpy->loader_extensions,
@@ -1232,7 +1254,11 @@ dri2_display_destroy(_EGLDisplay *disp)
    if (dri2_dpy->own_dri_screen) {
       if (dri2_dpy->vtbl && dri2_dpy->vtbl->close_screen_notify)
          dri2_dpy->vtbl->close_screen_notify(disp);
+
       dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
+
+      if (dri2_dpy->dri_screen_display_gpu)
+         dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_display_gpu);
    }
    if (dri2_dpy->fd >= 0)
       close(dri2_dpy->fd);
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index f0c570266a91..4881a623790f 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -215,6 +215,7 @@ struct dri2_egl_display
    int dri2_major;
    int dri2_minor;
    __DRIscreen *dri_screen;
+   __DRIscreen *dri_screen_display_gpu;
    bool own_dri_screen;
    const __DRIconfig **driver_configs;
    void *driver;
-- 
GitLab


From fab505335347d50c572d5e710e279e69f9b1135d Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 18 Oct 2021 21:44:25 +0530
Subject: [PATCH 4/8] loader,glx,egl/x11: init dri_screen_display_gpu in struct
 loader_dri3_drawable

Initialize dri_screendisplay_gpu variable in struct laoder_dri3_drawable.
Also make dri_screen_display_gpu variable as input parameter to function
loader_dri3_drawable_init() since dri_screen variable is initialized this way.
This also helps to avoid duplicate initializing dri_screen_display_gpu
in glx and egl code.

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/platform_x11_dri3.c | 1 +
 src/glx/dri3_glx.c                       | 3 +--
 src/loader/loader_dri3_helper.c          | 2 ++
 src/loader/loader_dri3_helper.h          | 1 +
 4 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index 45291ce85711..f474cc60b077 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -190,6 +190,7 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
    if (loader_dri3_drawable_init(dri2_dpy->conn, drawable,
                                  egl_to_loader_dri3_drawable_type(type),
                                  dri2_dpy->dri_screen,
+                                 dri2_dpy->dri_screen_display_gpu,
                                  dri2_dpy->is_different_gpu,
                                  dri2_dpy->multibuffers_available,
                                  true,
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 6370ca05beb3..b211e6d0a128 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -399,7 +399,7 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
    if (loader_dri3_drawable_init(XGetXCBConnection(base->dpy),
                                  xDrawable,
                                  glx_to_loader_dri3_drawable_type(type),
-                                 psc->driScreen,
+                                 psc->driScreen, psc->driScreenDisplayGPU,
                                  psc->is_different_gpu, has_multibuffer,
                                  psc->prefer_back_buffer_reuse,
                                  config->driConfig,
@@ -409,7 +409,6 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
       return NULL;
    }
 
-   pdraw->loader_drawable.dri_screen_display_gpu = psc->driScreenDisplayGPU;
    return &pdraw->base;
 }
 
diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 364695d06674..078092ffa790 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -386,6 +386,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
                           xcb_drawable_t drawable,
                           enum loader_dri3_drawable_type type,
                           __DRIscreen *dri_screen,
+                          __DRIscreen *dri_screen_display_gpu,
                           bool is_different_gpu,
                           bool multiplanes_available,
                           bool prefer_back_buffer_reuse,
@@ -407,6 +408,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    draw->type = type;
    draw->region = 0;
    draw->dri_screen = dri_screen;
+   draw->dri_screen_display_gpu = dri_screen_display_gpu;
    draw->is_different_gpu = is_different_gpu;
    draw->multiplanes_available = multiplanes_available;
    draw->prefer_back_buffer_reuse = prefer_back_buffer_reuse;
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index 792f72700988..6e846cce4538 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -207,6 +207,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
                           xcb_drawable_t drawable,
                           enum loader_dri3_drawable_type type,
                           __DRIscreen *dri_screen,
+                          __DRIscreen *dri_screen_display_gpu,
                           bool is_different_gpu,
                           bool is_multiplanes_available,
                           bool prefer_back_buffer_reuse,
-- 
GitLab


From 7d27017a52d6df5d20d18fbf524d3216b08fae0d Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 22 Nov 2021 18:45:18 +0530
Subject: [PATCH 5/8] egl/wayland: keep display fd open for prime

Keep the display fd open for creating DRI screen on display gpu in
case of prime.

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/platform_wayland.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index c7548ccb9d55..cb146bf3dd4a 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2153,8 +2153,14 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
          goto cleanup;
    }
 
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
    dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd,
                                                &dri2_dpy->is_different_gpu);
+   if (!dri2_dpy->is_different_gpu) {
+      close(dri2_dpy->fd_display_gpu);
+      dri2_dpy->fd_display_gpu = -1;
+   }
+
    dev = _eglAddDevice(dri2_dpy->fd, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
-- 
GitLab


From 9f5e694a853eac8d297790a70093e9111fe1e08e Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 22 Nov 2021 19:55:41 +0530
Subject: [PATCH 6/8] loader: make image_format_to_fourcc() non-static
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

the image_format_to_fourcc() function will be used from
egl/wayland hence make it non-static.

v2: add loader tag to extern image_format_to_fourcc() (Marek Olšák)
Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/loader/loader_dri3_helper.c | 14 +++++++-------
 src/loader/loader_dri3_helper.h |  3 +++
 2 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 078092ffa790..8c7abc99ab60 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -1348,8 +1348,8 @@ dri3_linear_format_for_format(struct loader_dri3_drawable *draw, uint32_t format
  * complete confusion, just deal in __DRI_IMAGE_FORMAT codes for now and
  * translate to DRM_FORMAT codes in the call to createImageFromFds
  */
-static int
-image_format_to_fourcc(int format)
+int
+loader_image_format_to_fourcc(int format)
 {
 
    /* Convert from __DRI_IMAGE_FORMAT to DRM_FORMAT (sigh) */
@@ -1485,7 +1485,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
                    xcb_dri3_get_supported_modifiers_window_modifiers(mod_reply),
                    count * sizeof(uint64_t));
 
-            if (!has_supported_modifier(draw, image_format_to_fourcc(format),
+            if (!has_supported_modifier(draw, loader_image_format_to_fourcc(format),
                                         modifiers, count)) {
                free(modifiers);
                count = 0;
@@ -1619,7 +1619,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
             draw->ext->image->createImageFromFds2(draw->dri_screen,
                                                   width,
                                                   height,
-                                                  image_format_to_fourcc(format),
+                                                  loader_image_format_to_fourcc(format),
                                                   &buffer_fds[0], num_planes,
                                                   __DRI_IMAGE_PRIME_LINEAR_BUFFER,
                                                   &buffer->strides[0],
@@ -1630,7 +1630,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
             draw->ext->image->createImageFromFds(draw->dri_screen,
                                                  width,
                                                  height,
-                                                 image_format_to_fourcc(format),
+                                                 loader_image_format_to_fourcc(format),
                                                  &buffer_fds[0], num_planes,
                                                  &buffer->strides[0],
                                                  &buffer->offsets[0],
@@ -1855,7 +1855,7 @@ loader_dri3_create_image(xcb_connection_t *c,
    image_planar = image->createImageFromFds(dri_screen,
                                             bp_reply->width,
                                             bp_reply->height,
-                                            image_format_to_fourcc(format),
+                                            loader_image_format_to_fourcc(format),
                                             fds, 1,
                                             &stride, &offset, loaderPrivate);
    close(fds[0]);
@@ -1902,7 +1902,7 @@ loader_dri3_create_image_from_buffers(xcb_connection_t *c,
    ret = image->createImageFromDmaBufs2(dri_screen,
                                         bp_reply->width,
                                         bp_reply->height,
-                                        image_format_to_fourcc(format),
+                                        loader_image_format_to_fourcc(format),
                                         bp_reply->modifier,
                                         fds, bp_reply->nfd,
                                         strides, offsets,
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index 6e846cce4538..240ea9e93796 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -294,4 +294,7 @@ loader_dri3_swapbuffer_barrier(struct loader_dri3_drawable *draw);
 
 void
 loader_dri3_close_screen(__DRIscreen *dri_screen);
+
+int
+loader_image_format_to_fourcc(int format);
 #endif
-- 
GitLab


From 099cf343ea79fd5fdca9aa4ae75c34b81c4decbb Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Wed, 20 Oct 2021 20:18:05 +0530
Subject: [PATCH 7/8] egl/wayland: for prime, allocate linear_copy from display
 GPU VRAM
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Allocates VRAM in display GPU in case of prime. Then the dma_buf is imported
into prime GPU.

v4: add image tag to __DRIimage (Marek Olšák)
v3: move display fd opening to separate commit (Pierre-Eric)
    image_format_to_fourcc() non-static to seperate commit (Pierre-Eric)
v2: close query fds after linear_copy buffer import (Marek Olšák)
    use image_format_to_fourcc() from loader_dri3_helper.c (Marek Olšák)
Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/platform_wayland.c | 109 +++++++++++++++++++-----
 1 file changed, 87 insertions(+), 22 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index cb146bf3dd4a..6b90aa0e5385 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -41,6 +41,7 @@
 
 #include "egl_dri2.h"
 #include "loader_dri_helper.h"
+#include "loader_dri3_helper.h"
 #include "loader.h"
 #include "util/u_vector.h"
 #include "util/anon_file.h"
@@ -884,26 +885,6 @@ dri2_wl_release_buffers(struct dri2_egl_surface *dri2_surf)
       dri2_egl_surface_free_local_buffers(dri2_surf);
 }
 
-static void
-create_dri_image_diff_gpu(struct dri2_egl_surface *dri2_surf,
-                          unsigned int linear_dri_image_format, uint32_t use_flags)
-{
-   struct dri2_egl_display *dri2_dpy =
-      dri2_egl_display(dri2_surf->base.Resource.Display);
-   uint64_t linear_mod;
-
-   /* The LINEAR modifier should be a perfect alias of the LINEAR use flag */
-   linear_mod = DRM_FORMAT_MOD_LINEAR;
-
-   dri2_surf->back->linear_copy =
-      loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
-                              dri2_surf->base.Width,
-                              dri2_surf->base.Height,
-                              linear_dri_image_format,
-                              use_flags | __DRI_IMAGE_USE_LINEAR,
-                              &linear_mod, 1, NULL);
-}
-
 static void
 create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
                                       unsigned int dri_image_format, uint32_t use_flags)
@@ -1068,9 +1049,93 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
    }
 
    if (dri2_dpy->is_different_gpu && dri2_surf->back->linear_copy == NULL) {
-      create_dri_image_diff_gpu(dri2_surf, linear_dri_image_format, use_flags);
+      uint64_t linear_mod = DRM_FORMAT_MOD_LINEAR;
+      __DRIimage *linear_copy_display_gpu_image = NULL;
+
+      if (dri2_dpy->dri_screen_display_gpu) {
+         linear_copy_display_gpu_image =
+               loader_dri_create_image(dri2_dpy->dri_screen_display_gpu,
+                                       dri2_dpy->image,
+                                       dri2_surf->base.Width,
+                                       dri2_surf->base.Height,
+                                       linear_dri_image_format,
+                                       use_flags | __DRI_IMAGE_USE_LINEAR,
+                                       &linear_mod, 1, NULL);
+
+         if (linear_copy_display_gpu_image) {
+            int i, ret;
+            int num_planes = 0;
+            int buffer_fds[4];
+            int strides[4];
+            int offsets[4];
+
+            if (!dri2_dpy->image->queryImage(linear_copy_display_gpu_image,
+                                             __DRI_IMAGE_ATTRIB_NUM_PLANES, &num_planes))
+               num_planes = 1;
+
+            for (i = 0; i < num_planes; i++) {
+               __DRIimage *image = dri2_dpy->image->fromPlanar(
+                                      linear_copy_display_gpu_image, i, NULL);
+
+               if (!image) {
+                  assert(i == 0);
+                  image = linear_copy_display_gpu_image;
+               }
+
+               buffer_fds[i] = -1;
+               ret = dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_FD,
+                                                 &buffer_fds[i]);
+               ret &= dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE,
+                                                  &strides[i]);
+               ret &= dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_OFFSET,
+                                                  &offsets[i]);
+
+               if (image != linear_copy_display_gpu_image)
+                  dri2_dpy->image->destroyImage(image);
+
+               if (!ret) {
+                  do {
+                     if (buffer_fds[i] != -1)
+                        close(buffer_fds[i]);
+                  } while (--i >= 0);
+                  dri2_dpy->image->destroyImage(linear_copy_display_gpu_image);
+                  return -1;
+               }
+            }
+
+            /* The linear buffer was created in the display GPU's vram, so we
+             * need to make it visible to render GPU
+             */
+            dri2_surf->back->linear_copy =
+               dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
+                                                   dri2_surf->base.Width,
+                                                   dri2_surf->base.Height,
+                                                   loader_image_format_to_fourcc(
+                                                      linear_dri_image_format),
+                                                   &buffer_fds[0], num_planes,
+                                                   &strides[0],
+                                                   &offsets[0],
+                                                   dri2_surf->back);
+            do {
+               if (buffer_fds[i] != -1)
+                  close(buffer_fds[i]);
+            } while (--i >= 0);
+            dri2_dpy->image->destroyImage(linear_copy_display_gpu_image);
+         }
+      }
+
+      if (!dri2_surf->back->linear_copy) {
+         dri2_surf->back->linear_copy =
+               loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+                                       dri2_surf->base.Width,
+                                       dri2_surf->base.Height,
+                                       linear_dri_image_format,
+                                       use_flags | __DRI_IMAGE_USE_LINEAR,
+                                       &linear_mod, 1, NULL);
+      }
+
       if (dri2_surf->back->linear_copy == NULL)
-          return -1;
+         return -1;
    }
 
    if (dri2_surf->back->dri_image == NULL) {
-- 
GitLab


From 7dad310eaf0db55ccd25a5f0104986716716f81a Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 28 Nov 2022 00:17:38 +0530
Subject: [PATCH 8/8] egl: add render_gpu tag to dri2_dpy->fd and
 dri2_dpy->dri_screen variable

v1: add render_gpu_tag (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c             | 93 +++++++++++----------
 src/egl/drivers/dri2/egl_dri2.h             |  6 +-
 src/egl/drivers/dri2/platform_android.c     | 38 ++++-----
 src/egl/drivers/dri2/platform_device.c      | 18 ++--
 src/egl/drivers/dri2/platform_drm.c         | 20 ++---
 src/egl/drivers/dri2/platform_surfaceless.c | 26 +++---
 src/egl/drivers/dri2/platform_wayland.c     | 44 +++++-----
 src/egl/drivers/dri2/platform_x11.c         | 26 +++---
 src/egl/drivers/dri2/platform_x11_dri3.c    | 25 +++---
 9 files changed, 149 insertions(+), 147 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 5a275c9995e4..b9c9a35d2d30 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -856,7 +856,7 @@ dri2_renderer_query_integer(struct dri2_egl_display *dri2_dpy, int param)
    unsigned int value = 0;
 
    if (!rendererQuery ||
-       rendererQuery->queryInteger(dri2_dpy->dri_screen, param, &value) == -1)
+       rendererQuery->queryInteger(dri2_dpy->dri_screen_render_gpu, param, &value) == -1)
       return 0;
 
    return value;
@@ -901,9 +901,9 @@ dri2_setup_screen(_EGLDisplay *disp)
    dri2_dpy->default_swap_interval = 1;
 
    if (dri2_dpy->image_driver) {
-      api_mask = dri2_dpy->image_driver->getAPIMask(dri2_dpy->dri_screen);
+      api_mask = dri2_dpy->image_driver->getAPIMask(dri2_dpy->dri_screen_render_gpu);
    } else if (dri2_dpy->dri2) {
-      api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
+      api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen_render_gpu);
    } else {
       assert(dri2_dpy->swrast);
       api_mask = 1 << __DRI_API_OPENGL |
@@ -962,7 +962,7 @@ dri2_setup_screen(_EGLDisplay *disp)
       if (dri2_dpy->fence->base.version >= 2 &&
           dri2_dpy->fence->get_capabilities) {
          unsigned capabilities =
-            dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen);
+            dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen_render_gpu);
          disp->Extensions.ANDROID_native_fence_sync =
             (capabilities & __DRI_FENCE_CAP_NATIVE_FD) != 0;
       }
@@ -978,7 +978,7 @@ dri2_setup_screen(_EGLDisplay *disp)
           dri2_dpy->image->getCapabilities != NULL) {
          int capabilities;
 
-         capabilities = dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen);
+         capabilities = dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen_render_gpu);
          disp->Extensions.MESA_drm_image = (capabilities & __DRI_IMAGE_CAP_GLOBAL_NAMES) != 0;
 
          if (dri2_dpy->image->base.version >= 11)
@@ -1028,7 +1028,7 @@ dri2_setup_swap_interval(_EGLDisplay *disp, int max_swap_interval)
 
    /* Allow driconf to override applications.*/
    if (dri2_dpy->config)
-      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen,
+      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen_render_gpu,
                                      "vblank_mode", &vblank_mode);
    switch (vblank_mode) {
    case DRI_CONF_VBLANK_NEVER:
@@ -1086,40 +1086,40 @@ dri2_create_screen(_EGLDisplay *disp)
          }
       }
 
-      dri2_dpy->dri_screen =
-         dri2_dpy->image_driver->createNewScreen2(0, dri2_dpy->fd,
+      dri2_dpy->dri_screen_render_gpu =
+         dri2_dpy->image_driver->createNewScreen2(0, dri2_dpy->fd_render_gpu,
                                                   dri2_dpy->loader_extensions,
                                                   dri2_dpy->driver_extensions,
                                                   &dri2_dpy->driver_configs,
                                                   disp);
    } else if (dri2_dpy->dri2) {
       if (dri2_dpy->dri2->base.version >= 4) {
-         dri2_dpy->dri_screen =
-            dri2_dpy->dri2->createNewScreen2(0, dri2_dpy->fd,
+         dri2_dpy->dri_screen_render_gpu =
+            dri2_dpy->dri2->createNewScreen2(0, dri2_dpy->fd_render_gpu,
                                              dri2_dpy->loader_extensions,
                                              dri2_dpy->driver_extensions,
                                              &dri2_dpy->driver_configs, disp);
       } else {
-         dri2_dpy->dri_screen =
-            dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd,
+         dri2_dpy->dri_screen_render_gpu =
+            dri2_dpy->dri2->createNewScreen(0, dri2_dpy->fd_render_gpu,
                                             dri2_dpy->loader_extensions,
                                             &dri2_dpy->driver_configs, disp);
       }
    } else {
       assert(dri2_dpy->swrast);
       if (dri2_dpy->swrast->base.version >= 4) {
-         dri2_dpy->dri_screen =
+         dri2_dpy->dri_screen_render_gpu =
             dri2_dpy->swrast->createNewScreen2(0, dri2_dpy->loader_extensions,
                                                dri2_dpy->driver_extensions,
                                                &dri2_dpy->driver_configs, disp);
       } else {
-         dri2_dpy->dri_screen =
+         dri2_dpy->dri_screen_render_gpu =
             dri2_dpy->swrast->createNewScreen(0, dri2_dpy->loader_extensions,
                                               &dri2_dpy->driver_configs, disp);
       }
    }
 
-   if (dri2_dpy->dri_screen == NULL) {
+   if (dri2_dpy->dri_screen_render_gpu == NULL) {
       _eglLog(_EGL_WARNING, "egl: failed to create dri2 screen");
       return EGL_FALSE;
    }
@@ -1135,7 +1135,7 @@ dri2_setup_extensions(_EGLDisplay *disp)
    const struct dri2_extension_match *mandatory_core_extensions;
    const __DRIextension **extensions;
 
-   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
+   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen_render_gpu);
 
    if (dri2_dpy->image_driver || dri2_dpy->dri2)
       mandatory_core_extensions = dri2_core_extensions;
@@ -1255,13 +1255,13 @@ dri2_display_destroy(_EGLDisplay *disp)
       if (dri2_dpy->vtbl && dri2_dpy->vtbl->close_screen_notify)
          dri2_dpy->vtbl->close_screen_notify(disp);
 
-      dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
+      dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_render_gpu);
 
       if (dri2_dpy->dri_screen_display_gpu)
          dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_display_gpu);
    }
-   if (dri2_dpy->fd >= 0)
-      close(dri2_dpy->fd);
+   if (dri2_dpy->fd_render_gpu >= 0)
+      close(dri2_dpy->fd_render_gpu);
    if (dri2_dpy->fd_display_gpu >= 0)
       close(dri2_dpy->fd_display_gpu);
 
@@ -1319,7 +1319,7 @@ dri2_egl_surface_alloc_local_buffer(struct dri2_egl_surface *dri2_surf,
 
    if (!dri2_surf->local_buffers[att]) {
       dri2_surf->local_buffers[att] =
-         dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen, att, format,
+         dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen_render_gpu, att, format,
                                         dri2_surf->base.Width, dri2_surf->base.Height);
    }
 
@@ -1334,7 +1334,7 @@ dri2_egl_surface_free_local_buffers(struct dri2_egl_surface *dri2_surf)
 
    for (int i = 0; i < ARRAY_SIZE(dri2_surf->local_buffers); i++) {
       if (dri2_surf->local_buffers[i]) {
-         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
+         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen_render_gpu,
                                        dri2_surf->local_buffers[i]);
          dri2_surf->local_buffers[i] = NULL;
       }
@@ -1614,7 +1614,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
 
    if (dri2_dpy->image_driver) {
       dri2_ctx->dri_context =
-         dri2_dpy->image_driver->createContextAttribs(dri2_dpy->dri_screen,
+         dri2_dpy->image_driver->createContextAttribs(dri2_dpy->dri_screen_render_gpu,
                                                       api,
                                                       dri_config,
                                                       shared,
@@ -1626,7 +1626,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
    } else if (dri2_dpy->dri2) {
       if (dri2_dpy->dri2->base.version >= 3) {
          dri2_ctx->dri_context =
-            dri2_dpy->dri2->createContextAttribs(dri2_dpy->dri_screen,
+            dri2_dpy->dri2->createContextAttribs(dri2_dpy->dri_screen_render_gpu,
                                                  api,
                                                  dri_config,
                                                  shared,
@@ -1637,7 +1637,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
          dri2_create_context_attribs_error(error);
       } else {
          dri2_ctx->dri_context =
-            dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen,
+            dri2_dpy->dri2->createNewContextForAPI(dri2_dpy->dri_screen_render_gpu,
                                                    api,
                                                    dri_config,
                                                    shared,
@@ -1647,7 +1647,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
       assert(dri2_dpy->swrast);
       if (dri2_dpy->swrast->base.version >= 3) {
          dri2_ctx->dri_context =
-            dri2_dpy->swrast->createContextAttribs(dri2_dpy->dri_screen,
+            dri2_dpy->swrast->createContextAttribs(dri2_dpy->dri_screen_render_gpu,
                                                    api,
                                                    dri_config,
                                                    shared,
@@ -1658,7 +1658,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
          dri2_create_context_attribs_error(error);
       } else {
          dri2_ctx->dri_context =
-            dri2_dpy->swrast->createNewContextForAPI(dri2_dpy->dri_screen,
+            dri2_dpy->swrast->createNewContextForAPI(dri2_dpy->dri_screen_render_gpu,
                                                      api,
                                                      dri_config,
                                                      shared,
@@ -1705,7 +1705,7 @@ dri2_init_surface(_EGLSurface *surf, _EGLDisplay *disp, EGLint type,
    dri2_surf->enable_out_fence = false;
    if (dri2_dpy->fence && dri2_dpy->fence->base.version >= 2 &&
        dri2_dpy->fence->get_capabilities &&
-       (dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen) &
+       (dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen_render_gpu) &
         __DRI_FENCE_CAP_NATIVE_FD)) {
       dri2_surf->enable_out_fence = enable_out_fence;
    }
@@ -1759,9 +1759,9 @@ dri2_surf_update_fence_fd(_EGLContext *ctx,
 
    fence = dri2_dpy->fence->create_fence_fd(dri_ctx, -1);
    if (fence) {
-      fence_fd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen,
+      fence_fd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen_render_gpu,
                                                fence);
-      dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen, fence);
+      dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen_render_gpu, fence);
    }
    dri2_surface_set_out_fence_fd(surf, fence_fd);
 }
@@ -1774,7 +1774,8 @@ dri2_create_drawable(struct dri2_egl_display *dri2_dpy,
 {
    if (dri2_dpy->kopper) {
       dri2_surf->dri_drawable =
-          dri2_dpy->kopper->createNewDrawable(dri2_dpy->dri_screen, config, loaderPrivate,
+          dri2_dpy->kopper->createNewDrawable(dri2_dpy->dri_screen_render_gpu,
+                                              config, loaderPrivate,
                                               dri2_surf->base.Type == EGL_PBUFFER_BIT ||
                                               dri2_surf->base.Type == EGL_PIXMAP_BIT);
    } else {
@@ -1788,7 +1789,7 @@ dri2_create_drawable(struct dri2_egl_display *dri2_dpy,
       else
          return _eglError(EGL_BAD_ALLOC, "no createNewDrawable");
 
-      dri2_surf->dri_drawable = createNewDrawable(dri2_dpy->dri_screen,
+      dri2_surf->dri_drawable = createNewDrawable(dri2_dpy->dri_screen_render_gpu,
                                                   config, loaderPrivate);
    }
    if (dri2_surf->dri_drawable == NULL)
@@ -2565,7 +2566,7 @@ dri2_create_image_mesa_drm_buffer(_EGLDisplay *disp, _EGLContext *ctx,
    }
 
    dri_image =
-      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen_render_gpu,
                                            attrs.Width,
                                            attrs.Height,
                                            format,
@@ -2809,7 +2810,7 @@ dri2_query_dma_buf_formats(_EGLDisplay *disp, EGLint max,
        dri2_dpy->image->queryDmaBufFormats == NULL)
       return EGL_FALSE;
 
-   if (!dri2_dpy->image->queryDmaBufFormats(dri2_dpy->dri_screen, max,
+   if (!dri2_dpy->image->queryDmaBufFormats(dri2_dpy->dri_screen_render_gpu, max,
                                             formats, count))
       return EGL_FALSE;
 
@@ -2848,7 +2849,7 @@ dri2_query_dma_buf_modifiers(_EGLDisplay *disp, EGLint format,
        dri2_dpy->image->queryDmaBufModifiers == NULL)
       return EGL_FALSE;
 
-   if (dri2_dpy->image->queryDmaBufModifiers(dri2_dpy->dri_screen, format,
+   if (dri2_dpy->image->queryDmaBufModifiers(dri2_dpy->dri_screen_render_gpu, format,
                                              max, modifiers,
                                              (unsigned int *) external_only,
                                              count) == false)
@@ -2929,7 +2930,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
          modifier = DRM_FORMAT_MOD_INVALID;
 
       dri_image =
-         dri2_dpy->image->createImageFromDmaBufs3(dri2_dpy->dri_screen,
+         dri2_dpy->image->createImageFromDmaBufs3(dri2_dpy->dri_screen_render_gpu,
             attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
             modifier, fds, num_fds, pitches, offsets,
             attrs.DMABufYuvColorSpaceHint.Value,
@@ -2947,7 +2948,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
          return EGL_NO_IMAGE_KHR;
       }
       dri_image =
-         dri2_dpy->image->createImageFromDmaBufs2(dri2_dpy->dri_screen,
+         dri2_dpy->image->createImageFromDmaBufs2(dri2_dpy->dri_screen_render_gpu,
             attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
             modifier, fds, num_fds, pitches, offsets,
             attrs.DMABufYuvColorSpaceHint.Value,
@@ -2959,7 +2960,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
    }
    else {
       dri_image =
-         dri2_dpy->image->createImageFromDmaBufs(dri2_dpy->dri_screen,
+         dri2_dpy->image->createImageFromDmaBufs(dri2_dpy->dri_screen_render_gpu,
             attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
             fds, num_fds, pitches, offsets,
             attrs.DMABufYuvColorSpaceHint.Value,
@@ -3035,7 +3036,7 @@ dri2_create_drm_image_mesa(_EGLDisplay *disp, const EGLint *attr_list)
    _eglInitImage(&dri2_img->base, disp);
 
    dri2_img->dri_image =
-      dri2_dpy->image->createImage(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImage(dri2_dpy->dri_screen_render_gpu,
                                    attrs.Width, attrs.Height,
                                    format, dri_use, dri2_img);
    if (dri2_img->dri_image == NULL) {
@@ -3235,7 +3236,7 @@ dri2_wl_reference_buffer(void *user_data, uint32_t name, int fd,
    int dri_components = 0;
 
    if (fd == -1)
-      img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen,
+      img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen_render_gpu,
                                                   buffer->width,
                                                   buffer->height,
                                                   buffer->format,
@@ -3244,7 +3245,7 @@ dri2_wl_reference_buffer(void *user_data, uint32_t name, int fd,
                                                   buffer->offset,
                                                   NULL);
    else
-      img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
+      img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen_render_gpu,
                                                 buffer->width,
                                                 buffer->height,
                                                 buffer->format,
@@ -3295,13 +3296,13 @@ dri2_bind_wayland_display_wl(_EGLDisplay *disp, struct wl_display *wl_dpy)
    if (dri2_dpy->wl_server_drm)
            return EGL_FALSE;
 
-   device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd);
+   device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd_render_gpu);
    if (!device_name)
       device_name = strdup(dri2_dpy->device_name);
    if (!device_name)
       return EGL_FALSE;
 
-   if (drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap) == 0 &&
+   if (drmGetCap(dri2_dpy->fd_render_gpu, DRM_CAP_PRIME, &cap) == 0 &&
        cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
        dri2_dpy->image->base.version >= 7 &&
        dri2_dpy->image->createImageFromFds != NULL)
@@ -3393,7 +3394,7 @@ dri2_egl_unref_sync(struct dri2_egl_display *dri2_dpy,
       }
 
       if (dri2_sync->fence)
-         dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen, dri2_sync->fence);
+         dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen_render_gpu, dri2_sync->fence);
 
       free(dri2_sync);
    }
@@ -3435,7 +3436,7 @@ dri2_create_sync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
 
    case EGL_SYNC_CL_EVENT_KHR:
       dri2_sync->fence = dri2_dpy->fence->get_fence_from_cl_event(
-                                 dri2_dpy->dri_screen,
+                                 dri2_dpy->dri_screen_render_gpu,
                                  dri2_sync->base.CLEvent);
       /* this can only happen if the cl_event passed in is invalid. */
       if (!dri2_sync->fence) {
@@ -3540,7 +3541,7 @@ dri2_dup_native_fence_fd(_EGLDisplay *disp, _EGLSync *sync)
       /* try to retrieve the actual native fence fd.. if rendering is
        * not flushed this will just return -1, aka NO_NATIVE_FENCE_FD:
        */
-      sync->SyncFd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen,
+      sync->SyncFd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen_render_gpu,
                                                    dri2_sync->fence);
    }
 
@@ -3561,7 +3562,7 @@ dri2_set_blob_cache_funcs(_EGLDisplay *disp,
                           EGLGetBlobFuncANDROID get)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen,
+   dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen_render_gpu,
                                    disp->BlobCacheSet,
                                    disp->BlobCacheGet);
 }
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 4881a623790f..c6ca64bde931 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -214,7 +214,7 @@ struct dri2_egl_display
 
    int dri2_major;
    int dri2_minor;
-   __DRIscreen *dri_screen;
+   __DRIscreen *dri_screen_render_gpu;
    __DRIscreen *dri_screen_display_gpu;
    bool own_dri_screen;
    const __DRIconfig **driver_configs;
@@ -237,7 +237,7 @@ struct dri2_egl_display
    const __DRI2interopExtension *interop;
    const __DRIconfigOptionsExtension *configOptions;
    const __DRImutableRenderBufferDriverExtension *mutable_render_buffer;
-   int fd;
+   int fd_render_gpu;
    int fd_display_gpu;
 
    /* dri2_initialize/dri2_terminate increment/decrement this count, so does
@@ -594,7 +594,7 @@ dri2_set_WL_bind_wayland_display(_EGLDisplay *disp)
            int capabilities;
 
            capabilities =
-               dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen);
+               dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen_render_gpu);
            disp->Extensions.WL_bind_wayland_display =
                (capabilities & __DRI_IMAGE_CAP_GLOBAL_NAMES) != 0;
        } else {
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index 29031a5967c4..cf51c61768ce 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -419,7 +419,7 @@ droid_create_image_from_buffer_info(struct dri2_egl_display *dri2_dpy,
    if (dri2_dpy->image->base.version >= 15 &&
        dri2_dpy->image->createImageFromDmaBufs2 != NULL) {
       return dri2_dpy->image->createImageFromDmaBufs2(
-         dri2_dpy->dri_screen, buf_info->width, buf_info->height,
+         dri2_dpy->dri_screen_render_gpu, buf_info->width, buf_info->height,
          buf_info->drm_fourcc, buf_info->modifier, buf_info->fds,
          buf_info->num_planes, buf_info->pitches, buf_info->offsets,
          buf_info->yuv_color_space, buf_info->sample_range,
@@ -428,7 +428,7 @@ droid_create_image_from_buffer_info(struct dri2_egl_display *dri2_dpy,
    }
 
    return dri2_dpy->image->createImageFromDmaBufs(
-      dri2_dpy->dri_screen, buf_info->width, buf_info->height,
+      dri2_dpy->dri_screen_render_gpu, buf_info->width, buf_info->height,
       buf_info->drm_fourcc, buf_info->fds, buf_info->num_planes,
       buf_info->pitches, buf_info->offsets, buf_info->yuv_color_space,
       buf_info->sample_range, buf_info->horizontal_siting,
@@ -843,7 +843,7 @@ get_front_bo(struct dri2_egl_surface *dri2_surf, unsigned int format)
       _eglLog(_EGL_DEBUG, "DRI driver requested unsupported front buffer for window surface");
    } else if (dri2_surf->base.Type == EGL_PBUFFER_BIT) {
       dri2_surf->dri_image_front =
-          dri2_dpy->image->createImage(dri2_dpy->dri_screen,
+          dri2_dpy->image->createImage(dri2_dpy->dri_screen_render_gpu,
                                               dri2_surf->base.Width,
                                               dri2_surf->base.Height,
                                               format,
@@ -1074,7 +1074,7 @@ droid_create_image_from_name(_EGLDisplay *disp,
        return NULL;
 
    return
-      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen_render_gpu,
 					   buf->width,
 					   buf->height,
 					   format,
@@ -1477,7 +1477,7 @@ droid_load_driver(_EGLDisplay *disp, bool swrast)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (dri2_dpy->driver_name == NULL)
       return false;
 
@@ -1582,11 +1582,11 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
       return EGL_FALSE;
    }
 
-   dri2_dpy->fd = os_dupfd_cloexec(fd);
-   if (dri2_dpy->fd < 0)
+   dri2_dpy->fd_render_gpu = os_dupfd_cloexec(fd);
+   if (dri2_dpy->fd_render_gpu < 0)
       return EGL_FALSE;
 
-   if (drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER)
+   if (drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER)
       return EGL_FALSE;
 
    return droid_probe_device(disp, swrast);
@@ -1622,8 +1622,8 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
       if (!(device->available_nodes & (1 << node_type)))
          continue;
 
-      dri2_dpy->fd = loader_open_device(device->nodes[node_type]);
-      if (dri2_dpy->fd < 0) {
+      dri2_dpy->fd_render_gpu = loader_open_device(device->nodes[node_type]);
+      if (dri2_dpy->fd_render_gpu < 0) {
          _eglLog(_EGL_WARNING, "%s() Failed to open DRM device %s",
                  __func__, device->nodes[node_type]);
          continue;
@@ -1633,10 +1633,10 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
        * Otherwise we fall-back the first device that is supported.
        */
       if (vendor_name) {
-         if (droid_filter_device(disp, dri2_dpy->fd, vendor_name)) {
+         if (droid_filter_device(disp, dri2_dpy->fd_render_gpu, vendor_name)) {
             /* Device does not match - try next device */
-            close(dri2_dpy->fd);
-            dri2_dpy->fd = -1;
+            close(dri2_dpy->fd_render_gpu);
+            dri2_dpy->fd_render_gpu = -1;
             continue;
          }
          /* If the requested device matches - use it. Regardless if
@@ -1644,7 +1644,7 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
           */
          if (!droid_probe_device(disp, false)) {
             close(dri2_dpy->fd);
-            dri2_dpy->fd = -1;
+            dri2_dpy->fd_render_gpu = -1;
          }
 
          break;
@@ -1653,12 +1653,12 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
          break;
 
       /* No explicit request - attempt the next device */
-      close(dri2_dpy->fd);
-      dri2_dpy->fd = -1;
+      close(dri2_dpy->fd_render_gpu);
+      dri2_dpy->fd_render_gpu = -1;
    }
    drmFreeDevices(devices, num_devices);
 
-   if (dri2_dpy->fd < 0) {
+   if (dri2_dpy->fd_render_gpu < 0) {
       _eglLog(_EGL_WARNING, "Failed to open %s DRM device",
             vendor_name ? "desired": "any");
       return EGL_FALSE;
@@ -1683,7 +1683,7 @@ dri2_initialize_android(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID,
                        (const hw_module_t **)&dri2_dpy->gralloc);
@@ -1700,7 +1700,7 @@ dri2_initialize_android(_EGLDisplay *disp)
       goto cleanup;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       err = "DRI2: failed to find EGLDevice";
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_device.c b/src/egl/drivers/dri2/platform_device.c
index 34c2e82c85b4..15fd69975a22 100644
--- a/src/egl/drivers/dri2/platform_device.c
+++ b/src/egl/drivers/dri2/platform_device.c
@@ -49,7 +49,7 @@ device_alloc_image(struct dri2_egl_display *dri2_dpy,
                    struct dri2_egl_surface *dri2_surf)
 {
    return dri2_dpy->image->createImage(
-            dri2_dpy->dri_screen,
+            dri2_dpy->dri_screen_render_gpu,
             dri2_surf->base.Width,
             dri2_surf->base.Height,
             dri2_surf->visual,
@@ -279,11 +279,11 @@ device_probe_device(_EGLDisplay *disp)
    if (request_software)
       _eglLog(_EGL_WARNING, "Not allowed to force software rendering when "
                             "API explicitly selects a hardware device.");
-   dri2_dpy->fd = device_get_fd(disp, disp->Device);
-   if (dri2_dpy->fd < 0)
+   dri2_dpy->fd_render_gpu = device_get_fd(disp, disp->Device);
+   if (dri2_dpy->fd_render_gpu < 0)
       return false;
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (!dri2_dpy->driver_name)
       goto err_name;
 
@@ -310,8 +310,8 @@ err_load:
    dri2_dpy->driver_name = NULL;
 
 err_name:
-   close(dri2_dpy->fd);
-   dri2_dpy->fd = -1;
+   close(dri2_dpy->fd_render_gpu);
+   dri2_dpy->fd_render_gpu = -1;
    return false;
 
 }
@@ -321,7 +321,7 @@ device_probe_device_sw(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->driver_name = strdup(disp->Options.Zink ? "zink" : "swrast");
    if (!dri2_dpy->driver_name)
       return false;
@@ -351,7 +351,7 @@ dri2_initialize_device(_EGLDisplay *disp)
    /* Extension requires a PlatformDisplay - the EGLDevice. */
    dev = disp->PlatformDisplay;
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->Device = dev;
    disp->DriverData = (void *) dri2_dpy;
@@ -379,7 +379,7 @@ dri2_initialize_device(_EGLDisplay *disp)
 
    dri2_setup_screen(disp);
 #ifdef HAVE_WAYLAND_PLATFORM
-   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
 #endif
    dri2_set_WL_bind_wayland_display(disp);
 
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index ce906e977141..e506288bba1f 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -507,7 +507,7 @@ dri2_drm_authenticate(_EGLDisplay *disp, uint32_t id)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   return drmAuthMagic(dri2_dpy->fd, id);
+   return drmAuthMagic(dri2_dpy->fd_render_gpu, id);
 }
 
 static void
@@ -691,7 +691,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
@@ -700,16 +700,16 @@ dri2_initialize_drm(_EGLDisplay *disp)
       char buf[64];
       int n = snprintf(buf, sizeof(buf), DRM_DEV_NAME, DRM_DIR_NAME, 0);
       if (n != -1 && n < sizeof(buf))
-         dri2_dpy->fd = loader_open_device(buf);
-      gbm = gbm_create_device(dri2_dpy->fd);
+         dri2_dpy->fd_render_gpu = loader_open_device(buf);
+      gbm = gbm_create_device(dri2_dpy->fd_render_gpu);
       if (gbm == NULL) {
          err = "DRI2: failed to create gbm device";
          goto cleanup;
       }
       dri2_dpy->own_device = true;
    } else {
-      dri2_dpy->fd = os_dupfd_cloexec(gbm_device_get_fd(gbm));
-      if (dri2_dpy->fd < 0) {
+      dri2_dpy->fd_render_gpu = os_dupfd_cloexec(gbm_device_get_fd(gbm));
+      if (dri2_dpy->fd_render_gpu < 0) {
          err = "DRI2: failed to fcntl() existing gbm device";
          goto cleanup;
       }
@@ -721,7 +721,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       goto cleanup;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, dri2_dpy->gbm_dri->software);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, dri2_dpy->gbm_dri->software);
    if (!dev) {
       err = "DRI2: failed to find EGLDevice";
       goto cleanup;
@@ -730,7 +730,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
    disp->Device = dev;
 
    dri2_dpy->driver_name = strdup(dri2_dpy->gbm_dri->driver_name);
-   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER;
+   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER;
 
    /* render nodes cannot use Gem names, and thus do not support
     * the __DRI_DRI2_LOADER extension */
@@ -746,7 +746,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       }
    }
 
-   dri2_dpy->dri_screen = dri2_dpy->gbm_dri->screen;
+   dri2_dpy->dri_screen_render_gpu = dri2_dpy->gbm_dri->screen;
    dri2_dpy->core = dri2_dpy->gbm_dri->core;
    dri2_dpy->dri2 = dri2_dpy->gbm_dri->dri2;
    dri2_dpy->swrast = dri2_dpy->gbm_dri->swrast;
@@ -786,7 +786,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       disp->Extensions.EXT_buffer_age = EGL_TRUE;
 
 #ifdef HAVE_WAYLAND_PLATFORM
-   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
 #endif
    dri2_set_WL_bind_wayland_display(disp);
 
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index 82d44e3cd224..8f59aa9290cf 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -42,7 +42,7 @@ surfaceless_alloc_image(struct dri2_egl_display *dri2_dpy,
                      struct dri2_egl_surface *dri2_surf)
 {
    return dri2_dpy->image->createImage(
-            dri2_dpy->dri_screen,
+            dri2_dpy->dri_screen_render_gpu,
             dri2_surf->base.Width,
             dri2_surf->base.Height,
             dri2_surf->visual,
@@ -250,18 +250,18 @@ surfaceless_probe_device(_EGLDisplay *disp, bool swrast)
       if (!(device->available_nodes & (1 << node_type)))
          continue;
 
-      dri2_dpy->fd = loader_open_device(device->nodes[node_type]);
-      if (dri2_dpy->fd < 0)
+      dri2_dpy->fd_render_gpu = loader_open_device(device->nodes[node_type]);
+      if (dri2_dpy->fd_render_gpu < 0)
          continue;
 
-      disp->Device = _eglAddDevice(dri2_dpy->fd, swrast);
+      disp->Device = _eglAddDevice(dri2_dpy->fd_render_gpu, swrast);
       if (!disp->Device) {
-         close(dri2_dpy->fd);
-         dri2_dpy->fd = -1;
+         close(dri2_dpy->fd_render_gpu);
+         dri2_dpy->fd_render_gpu = -1;
          continue;
       }
 
-      char *driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+      char *driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
       if (swrast) {
          /* Use kms swrast only with vgem / virtio_gpu.
           * virtio-gpu fallbacks to software rendering when 3D features
@@ -283,8 +283,8 @@ surfaceless_probe_device(_EGLDisplay *disp, bool swrast)
 
       free(dri2_dpy->driver_name);
       dri2_dpy->driver_name = NULL;
-      close(dri2_dpy->fd);
-      dri2_dpy->fd = -1;
+      close(dri2_dpy->fd_render_gpu);
+      dri2_dpy->fd_render_gpu = -1;
    }
    drmFreeDevices(devices, num_devices);
 
@@ -304,8 +304,8 @@ surfaceless_probe_device_sw(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   dri2_dpy->fd = -1;
-   disp->Device = _eglAddDevice(dri2_dpy->fd, true);
+   dri2_dpy->fd_render_gpu = -1;
+   disp->Device = _eglAddDevice(dri2_dpy->fd_render_gpu, true);
    assert(disp->Device);
 
    dri2_dpy->driver_name = strdup(disp->Options.Zink ? "zink" : "swrast");
@@ -333,7 +333,7 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
@@ -363,7 +363,7 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
 
    dri2_setup_screen(disp);
 #ifdef HAVE_WAYLAND_PLATFORM
-   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
 #endif
    dri2_set_WL_bind_wayland_display(disp);
 
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 6b90aa0e5385..208cf5b6ac99 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -934,7 +934,7 @@ create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
          flags |= __DRI_IMAGE_USE_SCANOUT;
 
       dri2_surf->back->dri_image =
-         loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+         loader_dri_create_image(dri2_dpy->dri_screen_render_gpu, dri2_dpy->image,
                                  dri2_surf->base.Width,
                                  dri2_surf->base.Height,
                                  dri_image_format,
@@ -972,7 +972,7 @@ create_dri_image(struct dri2_egl_surface *dri2_surf,
     * then fall back to the old createImage, and hope it allocates an image
     * which is acceptable to the winsys. */
    dri2_surf->back->dri_image =
-      loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+      loader_dri_create_image(dri2_dpy->dri_screen_render_gpu, dri2_dpy->image,
                               dri2_surf->base.Width,
                               dri2_surf->base.Height,
                               dri_image_format,
@@ -1107,7 +1107,7 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
              * need to make it visible to render GPU
              */
             dri2_surf->back->linear_copy =
-               dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
+               dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen_render_gpu,
                                                    dri2_surf->base.Width,
                                                    dri2_surf->base.Height,
                                                    loader_image_format_to_fourcc(
@@ -1126,7 +1126,7 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
 
       if (!dri2_surf->back->linear_copy) {
          dri2_surf->back->linear_copy =
-               loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+               loader_dri_create_image(dri2_dpy->dri_screen_render_gpu, dri2_dpy->image,
                                        dri2_surf->base.Width,
                                        dri2_surf->base.Height,
                                        linear_dri_image_format,
@@ -1765,8 +1765,8 @@ drm_handle_device(void *data, struct wl_drm *drm, const char *device)
    if (!dri2_dpy->device_name)
       return;
 
-   dri2_dpy->fd = loader_open_device(dri2_dpy->device_name);
-   if (dri2_dpy->fd == -1) {
+   dri2_dpy->fd_render_gpu = loader_open_device(dri2_dpy->device_name);
+   if (dri2_dpy->fd_render_gpu == -1) {
       _eglLog(_EGL_WARNING, "wayland-egl: could not open %s (%s)",
               dri2_dpy->device_name, strerror(errno));
       free(dri2_dpy->device_name);
@@ -1774,12 +1774,12 @@ drm_handle_device(void *data, struct wl_drm *drm, const char *device)
       return;
    }
 
-   if (drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER) {
+   if (drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER) {
       dri2_dpy->authenticated = true;
    } else {
-      if (drmGetMagic(dri2_dpy->fd, &magic)) {
-         close(dri2_dpy->fd);
-         dri2_dpy->fd = -1;
+      if (drmGetMagic(dri2_dpy->fd_render_gpu, &magic)) {
+         close(dri2_dpy->fd_render_gpu);
+         dri2_dpy->fd_render_gpu = -1;
          free(dri2_dpy->device_name);
          dri2_dpy->device_name = NULL;
          _eglLog(_EGL_WARNING, "wayland-egl: drmGetMagic failed");
@@ -1904,7 +1904,7 @@ default_dmabuf_feedback_main_device(void *data,
    }
 
    dri2_dpy->device_name = node;
-   dri2_dpy->fd = fd;
+   dri2_dpy->fd_render_gpu = fd;
    dri2_dpy->authenticated = true;
 }
 
@@ -2145,7 +2145,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
@@ -2202,7 +2202,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    /* We couldn't retrieve a render node from the dma-buf feedback (or the
     * feedback was not advertised at all), so we must fallback to wl_drm. */
-   if (dri2_dpy->fd == -1) {
+   if (dri2_dpy->fd_render_gpu == -1) {
       /* wl_drm not advertised by compositor, so can't continue */
       if (dri2_dpy->wl_drm_name == 0)
          goto cleanup;
@@ -2210,7 +2210,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
       if (dri2_dpy->wl_drm == NULL)
          goto cleanup;
-      if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd == -1)
+      if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd_render_gpu == -1)
          goto cleanup;
 
       if (!dri2_dpy->authenticated &&
@@ -2218,15 +2218,15 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
          goto cleanup;
    }
 
-   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
-   dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd,
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
+   dri2_dpy->fd_render_gpu = loader_get_user_preferred_fd(dri2_dpy->fd_render_gpu,
                                                &dri2_dpy->is_different_gpu);
    if (!dri2_dpy->is_different_gpu) {
       close(dri2_dpy->fd_display_gpu);
       dri2_dpy->fd_display_gpu = -1;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
@@ -2236,7 +2236,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    if (dri2_dpy->is_different_gpu) {
       free(dri2_dpy->device_name);
-      dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+      dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
       if (!dri2_dpy->device_name) {
          _eglError(EGL_BAD_ALLOC, "wayland-egl: failed to get device name "
                                   "for requested GPU");
@@ -2248,9 +2248,9 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
     * will return a render-node when the requested gpu is different
     * to the server, but also if the client asks for the same gpu than
     * the server by requesting its pci-id */
-   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER;
+   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER;
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (dri2_dpy->driver_name == NULL) {
       _eglError(EGL_BAD_ALLOC, "DRI2: failed to get driver name");
       goto cleanup;
@@ -2753,7 +2753,7 @@ dri2_initialize_wayland_swrast(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    if (dri2_wl_formats_init(&dri2_dpy->formats) < 0)
@@ -2768,7 +2768,7 @@ dri2_initialize_wayland_swrast(_EGLDisplay *disp)
       dri2_dpy->wl_dpy = disp->PlatformDisplay;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, true);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, true);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index 15b497ce4b21..0ef33da573fc 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -636,7 +636,7 @@ dri2_x11_local_authenticate(struct dri2_egl_display *dri2_dpy)
 #ifdef HAVE_LIBDRM
    drm_magic_t magic;
 
-   if (drmGetMagic(dri2_dpy->fd, &magic)) {
+   if (drmGetMagic(dri2_dpy->fd_render_gpu, &magic)) {
       _eglLog(_EGL_WARNING, "DRI2: failed to get drm magic");
       return EGL_FALSE;
    }
@@ -718,8 +718,8 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
 
    device_name = xcb_dri2_connect_device_name (connect);
 
-   dri2_dpy->fd = loader_open_device(device_name);
-   if (dri2_dpy->fd == -1) {
+   dri2_dpy->fd_render_gpu = loader_open_device(device_name);
+   if (dri2_dpy->fd_render_gpu == -1) {
       _eglLog(_EGL_WARNING,
               "DRI2: could not open %s (%s)", device_name, strerror(errno));
       free(connect);
@@ -727,7 +727,7 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
    }
 
    if (!dri2_x11_local_authenticate(dri2_dpy)) {
-      close(dri2_dpy->fd);
+      close(dri2_dpy->fd_render_gpu);
       free(connect);
       return EGL_FALSE;
    }
@@ -737,7 +737,7 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
    /* If Mesa knows about the appropriate driver for this fd, then trust it.
     * Otherwise, default to the server's value.
     */
-   loader_driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   loader_driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (loader_driver_name) {
       dri2_dpy->driver_name = loader_driver_name;
    } else {
@@ -747,7 +747,7 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
    }
 
    if (dri2_dpy->driver_name == NULL) {
-      close(dri2_dpy->fd);
+      close(dri2_dpy->fd_render_gpu);
       free(connect);
       return EGL_FALSE;
    }
@@ -1144,7 +1144,7 @@ dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
 
    stride = buffers[0].pitch / buffers[0].cpp;
    dri2_img->dri_image =
-      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen_render_gpu,
 					   buffers_reply->width,
 					   buffers_reply->height,
 					   format,
@@ -1412,12 +1412,12 @@ dri2_initialize_x11_swrast(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
-   dev = _eglAddDevice(dri2_dpy->fd, true);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, true);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
@@ -1497,7 +1497,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
@@ -1505,7 +1505,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
    if (!dri3_x11_connect(dri2_dpy))
       goto cleanup;
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
@@ -1606,7 +1606,7 @@ dri2_initialize_x11_dri2(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
@@ -1614,7 +1614,7 @@ dri2_initialize_x11_dri2(_EGLDisplay *disp)
    if (!dri2_x11_connect(dri2_dpy))
       goto cleanup;
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index f474cc60b077..0f4e0f806728 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -84,7 +84,7 @@ egl_dri3_get_dri_screen(void)
    if (!ctx)
       return NULL;
    dri2_ctx = dri2_egl_context(ctx);
-   return dri2_egl_display(dri2_ctx->base.Resource.Display)->dri_screen;
+   return dri2_egl_display(dri2_ctx->base.Resource.Display)->dri_screen_render_gpu;
 }
 
 static void
@@ -189,7 +189,7 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
 
    if (loader_dri3_drawable_init(dri2_dpy->conn, drawable,
                                  egl_to_loader_dri3_drawable_type(type),
-                                 dri2_dpy->dri_screen,
+                                 dri2_dpy->dri_screen_render_gpu,
                                  dri2_dpy->dri_screen_display_gpu,
                                  dri2_dpy->is_different_gpu,
                                  dri2_dpy->multibuffers_available,
@@ -327,7 +327,7 @@ dri3_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
    dri2_img->dri_image = loader_dri3_create_image(dri2_dpy->conn,
                                                   bp_reply,
                                                   format,
-                                                  dri2_dpy->dri_screen,
+                                                  dri2_dpy->dri_screen_render_gpu,
                                                   dri2_dpy->image,
                                                   dri2_img);
 
@@ -379,7 +379,7 @@ dri3_create_image_khr_pixmap_from_buffers(_EGLDisplay *disp, _EGLContext *ctx,
    dri2_img->dri_image = loader_dri3_create_image_from_buffers(dri2_dpy->conn,
                                                                bp_reply,
                                                                format,
-                                                               dri2_dpy->dri_screen,
+                                                               dri2_dpy->dri_screen_render_gpu,
                                                                dri2_dpy->image,
                                                                dri2_img);
    free(bp_reply);
@@ -512,7 +512,7 @@ dri3_close_screen_notify(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   loader_dri3_close_screen(dri2_dpy->dri_screen);
+   loader_dri3_close_screen(dri2_dpy->dri_screen_render_gpu);
 }
 
 struct dri2_egl_display_vtbl dri3_x11_display_vtbl = {
@@ -624,8 +624,8 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
    }
    free(xfixes_query);
 
-   dri2_dpy->fd = loader_dri3_open(dri2_dpy->conn, dri2_dpy->screen->root, 0);
-   if (dri2_dpy->fd < 0) {
+   dri2_dpy->fd_render_gpu = loader_dri3_open(dri2_dpy->conn, dri2_dpy->screen->root, 0);
+   if (dri2_dpy->fd_render_gpu < 0) {
       int conn_error = xcb_connection_has_error(dri2_dpy->conn);
       _eglLog(_EGL_WARNING, "DRI3: Screen seems not DRI3 capable");
 
@@ -635,17 +635,18 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
       return EGL_FALSE;
    }
 
-   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
-   dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd, &dri2_dpy->is_different_gpu);
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
+   dri2_dpy->fd_render_gpu = loader_get_user_preferred_fd(dri2_dpy->fd_render_gpu,
+                                                          &dri2_dpy->is_different_gpu);
    if (!dri2_dpy->is_different_gpu) {
       close(dri2_dpy->fd_display_gpu);
       dri2_dpy->fd_display_gpu = -1;
    }
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (!dri2_dpy->driver_name) {
       _eglLog(_EGL_WARNING, "DRI3: No driver found");
-      close(dri2_dpy->fd);
+      close(dri2_dpy->fd_render_gpu);
       return EGL_FALSE;
    }
 
@@ -653,7 +654,7 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
    /* Only try to get a render device name since dri3 doesn't provide a
     * mechanism for authenticating client opened device node fds. If this
     * fails then don't advertise the extension. */
-   dri2_dpy->device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd);
+   dri2_dpy->device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd_render_gpu);
 #endif
 
    return EGL_TRUE;
-- 
GitLab

