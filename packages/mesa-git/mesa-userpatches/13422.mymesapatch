From 3ad65f268a4714d8987b34d17c8d309c375e7eb7 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Sun, 17 Oct 2021 22:24:10 +0530
Subject: [PATCH 01/13] egl: add fd_display_gpu to struct dri2_egl_display

fd opened on display gpu is saved in fd_display_gpu. It is later used
to create dri screen on display gpu.

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.h             | 1 +
 src/egl/drivers/dri2/platform_android.c     | 1 +
 src/egl/drivers/dri2/platform_device.c      | 1 +
 src/egl/drivers/dri2/platform_drm.c         | 1 +
 src/egl/drivers/dri2/platform_surfaceless.c | 1 +
 src/egl/drivers/dri2/platform_wayland.c     | 1 +
 src/egl/drivers/dri2/platform_x11.c         | 3 +++
 7 files changed, 9 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 588803cd3e77..a1d77f5fcb04 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -244,6 +244,7 @@ struct dri2_egl_display
    const __DRIconfigOptionsExtension *configOptions;
    const __DRImutableRenderBufferDriverExtension *mutable_render_buffer;
    int fd;
+   int fd_display_gpu;
 
    /* dri2_initialize/dri2_terminate increment/decrement this count, so does
     * dri2_make_current (tracks if there are active contexts/surfaces). */
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index af7b3291f8b2..937a9415f3a5 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -1676,6 +1676,7 @@ dri2_initialize_android(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID,
                        (const hw_module_t **)&dri2_dpy->gralloc);
    if (ret) {
diff --git a/src/egl/drivers/dri2/platform_device.c b/src/egl/drivers/dri2/platform_device.c
index bd16f3fdd7eb..1181fb08053e 100644
--- a/src/egl/drivers/dri2/platform_device.c
+++ b/src/egl/drivers/dri2/platform_device.c
@@ -352,6 +352,7 @@ dri2_initialize_device(_EGLDisplay *disp)
    dev = disp->PlatformDisplay;
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->Device = dev;
    disp->DriverData = (void *) dri2_dpy;
    err = "DRI2: failed to load driver";
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index 45895a88b6c0..ce906e977141 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -692,6 +692,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    gbm = disp->PlatformDisplay;
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index df88c54cf84b..82d44e3cd224 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -334,6 +334,7 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    /* When ForceSoftware is false, we try the HW driver.  When ForceSoftware
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 248d217f5e76..b55cbcb8c9ff 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2093,6 +2093,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    if (dri2_wl_formats_init(&dri2_dpy->formats) < 0)
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index 6e050c0928f6..93a7d6a3c706 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -1452,6 +1452,7 @@ dri2_initialize_x11_swrast(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
@@ -1541,6 +1542,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
@@ -1650,6 +1652,7 @@ dri2_initialize_x11_dri2(_EGLDisplay *disp)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    dri2_dpy->fd = -1;
+   dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
-- 
GitLab


From a49807a5d75e5da01b9b7dd4e1c35d2e0ee19c60 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 22 Nov 2021 21:04:53 +0530
Subject: [PATCH 02/13] egl,egl/x11: keep display fd open for prime

Keep the display fd open for creating DRI screen on display gpu in
case of prime. Also close the fd opened in dri2_display_destroy()

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c          | 2 ++
 src/egl/drivers/dri2/platform_x11_dri3.c | 6 ++++++
 2 files changed, 8 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 239dc6d9f170..31610f57fd1c 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1119,6 +1119,8 @@ dri2_display_destroy(_EGLDisplay *disp)
    }
    if (dri2_dpy->fd >= 0)
       close(dri2_dpy->fd);
+   if (dri2_dpy->fd_display_gpu >= 0)
+      close(dri2_dpy->fd_display_gpu);
 
    /* Don't dlclose the driver when building with the address sanitizer, so you
     * get good symbols from the leak reports.
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index c529f426f5ec..c298fe464f6b 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -24,6 +24,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <fcntl.h>
 
 #include <xcb/xcb.h>
 #include <xcb/dri3.h>
@@ -634,7 +635,12 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
       return EGL_FALSE;
    }
 
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
    dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd, &dri2_dpy->is_different_gpu);
+   if (!dri2_dpy->is_different_gpu) {
+      close(dri2_dpy->fd_display_gpu);
+      dri2_dpy->fd_display_gpu = -1;
+   }
 
    dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
    if (!dri2_dpy->driver_name) {
-- 
GitLab


From d44d433addf57b134f4b07e2a20f107420775d23 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 18 Oct 2021 09:52:16 +0530
Subject: [PATCH 03/13] egl: create DRI screen for display GPU in case of prime
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The created DRI screen can be used to allocate VRAM memory from
display GPU in case of prime.

v2: remove extra whitespace (Marek Olšák)
Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 23 +++++++++++++++++++++++
 src/egl/drivers/dri2/egl_dri2.h |  1 +
 2 files changed, 24 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 31610f57fd1c..f75d19da318c 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -972,6 +972,25 @@ EGLBoolean
 dri2_create_screen(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   char *driver_name_display_gpu;
+
+   if (dri2_dpy->fd_display_gpu >= 0) {
+      driver_name_display_gpu = loader_get_driver_for_fd(dri2_dpy->fd_display_gpu);
+      if (driver_name_display_gpu) {
+         /* check if driver name is matching so that non mesa drivers
+          * will not crash.
+          */
+         if (strcmp(dri2_dpy->driver_name, driver_name_display_gpu) == 0) {
+            dri2_dpy->dri_screen_display_gpu =
+               dri2_dpy->mesa->createNewScreen(0, dri2_dpy->fd_display_gpu,
+                                               dri2_dpy->loader_extensions,
+                                               dri2_dpy->driver_extensions,
+                                               &dri2_dpy->driver_configs,
+                                               disp);
+         }
+         free(driver_name_display_gpu);
+      }
+   }
 
    int screen_fd = dri2_dpy->swrast ? -1 : dri2_dpy->fd;
    dri2_dpy->dri_screen = dri2_dpy->mesa->createNewScreen(0, screen_fd,
@@ -1115,7 +1134,11 @@ dri2_display_destroy(_EGLDisplay *disp)
    if (dri2_dpy->own_dri_screen) {
       if (dri2_dpy->vtbl && dri2_dpy->vtbl->close_screen_notify)
          dri2_dpy->vtbl->close_screen_notify(disp);
+
       dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
+
+      if (dri2_dpy->dri_screen_display_gpu)
+         dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_display_gpu);
    }
    if (dri2_dpy->fd >= 0)
       close(dri2_dpy->fd);
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index a1d77f5fcb04..31c0d405ca78 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -223,6 +223,7 @@ struct dri2_egl_display
    int dri2_major;
    int dri2_minor;
    __DRIscreen *dri_screen;
+   __DRIscreen *dri_screen_display_gpu;
    bool own_dri_screen;
    const __DRIconfig **driver_configs;
    void *driver;
-- 
GitLab


From b30428e57299f28cbc48f73303659283d7af2096 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 18 Oct 2021 21:44:25 +0530
Subject: [PATCH 04/13] loader,glx,egl/x11: init dri_screen_display_gpu in
 struct loader_dri3_drawable

Initialize dri_screendisplay_gpu variable in struct laoder_dri3_drawable.
Also make dri_screen_display_gpu variable as input parameter to function
loader_dri3_drawable_init() since dri_screen variable is initialized this way.
This also helps to avoid duplicate initializing dri_screen_display_gpu
in glx and egl code.

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/platform_x11_dri3.c | 1 +
 src/glx/dri3_glx.c                       | 3 +--
 src/loader/loader_dri3_helper.c          | 2 ++
 src/loader/loader_dri3_helper.h          | 1 +
 4 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index c298fe464f6b..8a2bee9650bc 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -190,6 +190,7 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
    if (loader_dri3_drawable_init(dri2_dpy->conn, drawable,
                                  egl_to_loader_dri3_drawable_type(type),
                                  dri2_dpy->dri_screen,
+                                 dri2_dpy->dri_screen_display_gpu,
                                  dri2_dpy->is_different_gpu,
                                  dri2_dpy->multibuffers_available,
                                  true,
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 9407879e1cc4..76ce028ee36c 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -393,7 +393,7 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
    if (loader_dri3_drawable_init(XGetXCBConnection(base->dpy),
                                  xDrawable,
                                  glx_to_loader_dri3_drawable_type(type),
-                                 psc->driScreen,
+                                 psc->driScreen, psc->driScreenDisplayGPU,
                                  psc->is_different_gpu, has_multibuffer,
                                  psc->prefer_back_buffer_reuse,
                                  config->driConfig,
@@ -403,7 +403,6 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
       return NULL;
    }
 
-   pdraw->loader_drawable.dri_screen_display_gpu = psc->driScreenDisplayGPU;
    return &pdraw->base;
 }
 
diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 0caaa148179e..10117842532d 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -380,6 +380,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
                           xcb_drawable_t drawable,
                           enum loader_dri3_drawable_type type,
                           __DRIscreen *dri_screen,
+                          __DRIscreen *dri_screen_display_gpu,
                           bool is_different_gpu,
                           bool multiplanes_available,
                           bool prefer_back_buffer_reuse,
@@ -399,6 +400,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    draw->type = type;
    draw->region = 0;
    draw->dri_screen = dri_screen;
+   draw->dri_screen_display_gpu = dri_screen_display_gpu;
    draw->is_different_gpu = is_different_gpu;
    draw->multiplanes_available = multiplanes_available;
    draw->prefer_back_buffer_reuse = prefer_back_buffer_reuse;
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index 81f66a0615e6..39c96bdb35c1 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -209,6 +209,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
                           xcb_drawable_t drawable,
                           enum loader_dri3_drawable_type type,
                           __DRIscreen *dri_screen,
+                          __DRIscreen *dri_screen_display_gpu,
                           bool is_different_gpu,
                           bool is_multiplanes_available,
                           bool prefer_back_buffer_reuse,
-- 
GitLab


From feb875a57190cbdddd818d2d4d252cf5338ea3d4 Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 22 Nov 2021 18:45:18 +0530
Subject: [PATCH 05/13] egl/wayland: keep display fd open for prime

Keep the display fd open for creating DRI screen on display gpu in
case of prime.

Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/platform_wayland.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index b55cbcb8c9ff..9ad738843a25 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2165,8 +2165,14 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
          goto cleanup;
    }
 
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
    dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd,
                                                &dri2_dpy->is_different_gpu);
+   if (!dri2_dpy->is_different_gpu) {
+      close(dri2_dpy->fd_display_gpu);
+      dri2_dpy->fd_display_gpu = -1;
+   }
+
    dev = _eglAddDevice(dri2_dpy->fd, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
-- 
GitLab


From 24e804fe2e2536dfe27a9cefb4ce0b762bec0e8d Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 22 Nov 2021 19:55:41 +0530
Subject: [PATCH 06/13] loader: make image_format_to_fourcc() non-static
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

the image_format_to_fourcc() function will be used from
egl/wayland hence make it non-static.

v2: add loader tag to extern image_format_to_fourcc() (Marek Olšák)
Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/loader/loader_dri3_helper.c | 14 +++++++-------
 src/loader/loader_dri3_helper.h |  3 +++
 2 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 10117842532d..c6da524b29a6 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -1382,8 +1382,8 @@ dri3_linear_format_for_format(struct loader_dri3_drawable *draw, uint32_t format
  * complete confusion, just deal in __DRI_IMAGE_FORMAT codes for now and
  * translate to DRM_FORMAT codes in the call to createImageFromFds
  */
-static int
-image_format_to_fourcc(int format)
+int
+loader_image_format_to_fourcc(int format)
 {
 
    /* Convert from __DRI_IMAGE_FORMAT to DRM_FORMAT (sigh) */
@@ -1521,7 +1521,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
                    xcb_dri3_get_supported_modifiers_window_modifiers(mod_reply),
                    count * sizeof(uint64_t));
 
-            if (!has_supported_modifier(draw, image_format_to_fourcc(format),
+            if (!has_supported_modifier(draw, loader_image_format_to_fourcc(format),
                                         modifiers, count)) {
                free(modifiers);
                count = 0;
@@ -1654,7 +1654,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
             draw->ext->image->createImageFromFds2(draw->dri_screen,
                                                   width,
                                                   height,
-                                                  image_format_to_fourcc(format),
+                                                  loader_image_format_to_fourcc(format),
                                                   &buffer_fds[0], num_planes,
                                                   __DRI_IMAGE_PRIME_LINEAR_BUFFER,
                                                   &buffer->strides[0],
@@ -1665,7 +1665,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
             draw->ext->image->createImageFromFds(draw->dri_screen,
                                                  width,
                                                  height,
-                                                 image_format_to_fourcc(format),
+                                                 loader_image_format_to_fourcc(format),
                                                  &buffer_fds[0], num_planes,
                                                  &buffer->strides[0],
                                                  &buffer->offsets[0],
@@ -1890,7 +1890,7 @@ loader_dri3_create_image(xcb_connection_t *c,
    image_planar = image->createImageFromFds(dri_screen,
                                             bp_reply->width,
                                             bp_reply->height,
-                                            image_format_to_fourcc(format),
+                                            loader_image_format_to_fourcc(format),
                                             fds, 1,
                                             &stride, &offset, loaderPrivate);
    close(fds[0]);
@@ -1937,7 +1937,7 @@ loader_dri3_create_image_from_buffers(xcb_connection_t *c,
    ret = image->createImageFromDmaBufs2(dri_screen,
                                         bp_reply->width,
                                         bp_reply->height,
-                                        image_format_to_fourcc(format),
+                                        loader_image_format_to_fourcc(format),
                                         bp_reply->modifier,
                                         fds, bp_reply->nfd,
                                         strides, offsets,
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index 39c96bdb35c1..7228855a1261 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -296,4 +296,7 @@ loader_dri3_swapbuffer_barrier(struct loader_dri3_drawable *draw);
 
 void
 loader_dri3_close_screen(__DRIscreen *dri_screen);
+
+int
+loader_image_format_to_fourcc(int format);
 #endif
-- 
GitLab


From a5693a02ea4c224a273563bfb79489ef36c84b8d Mon Sep 17 00:00:00 2001
From: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Wed, 20 Oct 2021 20:18:05 +0530
Subject: [PATCH 07/13] egl/wayland: for prime, allocate linear_copy from
 display GPU VRAM
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Allocates VRAM in display GPU in case of prime. Then the dma_buf is imported
into prime GPU.

v4: add image tag to __DRIimage (Marek Olšák)
v3: move display fd opening to separate commit (Pierre-Eric)
    image_format_to_fourcc() non-static to seperate commit (Pierre-Eric)
v2: close query fds after linear_copy buffer import (Marek Olšák)
    use image_format_to_fourcc() from loader_dri3_helper.c (Marek Olšák)
Signed-off-by: Yogesh Mohanmarimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/platform_wayland.c | 109 +++++++++++++++++++-----
 1 file changed, 87 insertions(+), 22 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 9ad738843a25..e68f824eed19 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -42,6 +42,7 @@
 
 #include "egl_dri2.h"
 #include "loader_dri_helper.h"
+#include "loader_dri3_helper.h"
 #include "loader.h"
 #include "util/u_vector.h"
 #include "util/anon_file.h"
@@ -885,26 +886,6 @@ dri2_wl_release_buffers(struct dri2_egl_surface *dri2_surf)
       dri2_egl_surface_free_local_buffers(dri2_surf);
 }
 
-static void
-create_dri_image_diff_gpu(struct dri2_egl_surface *dri2_surf,
-                          unsigned int linear_dri_image_format, uint32_t use_flags)
-{
-   struct dri2_egl_display *dri2_dpy =
-      dri2_egl_display(dri2_surf->base.Resource.Display);
-   uint64_t linear_mod;
-
-   /* The LINEAR modifier should be a perfect alias of the LINEAR use flag */
-   linear_mod = DRM_FORMAT_MOD_LINEAR;
-
-   dri2_surf->back->linear_copy =
-      loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
-                              dri2_surf->base.Width,
-                              dri2_surf->base.Height,
-                              linear_dri_image_format,
-                              use_flags | __DRI_IMAGE_USE_LINEAR,
-                              &linear_mod, 1, NULL);
-}
-
 static void
 create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
                                       unsigned int dri_image_format, uint32_t use_flags)
@@ -1072,9 +1053,93 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
    }
 
    if (dri2_dpy->is_different_gpu && dri2_surf->back->linear_copy == NULL) {
-      create_dri_image_diff_gpu(dri2_surf, linear_dri_image_format, use_flags);
+      uint64_t linear_mod = DRM_FORMAT_MOD_LINEAR;
+      __DRIimage *linear_copy_display_gpu_image = NULL;
+
+      if (dri2_dpy->dri_screen_display_gpu) {
+         linear_copy_display_gpu_image =
+               loader_dri_create_image(dri2_dpy->dri_screen_display_gpu,
+                                       dri2_dpy->image,
+                                       dri2_surf->base.Width,
+                                       dri2_surf->base.Height,
+                                       linear_dri_image_format,
+                                       use_flags | __DRI_IMAGE_USE_LINEAR,
+                                       &linear_mod, 1, NULL);
+
+         if (linear_copy_display_gpu_image) {
+            int i, ret;
+            int num_planes = 0;
+            int buffer_fds[4];
+            int strides[4];
+            int offsets[4];
+
+            if (!dri2_dpy->image->queryImage(linear_copy_display_gpu_image,
+                                             __DRI_IMAGE_ATTRIB_NUM_PLANES, &num_planes))
+               num_planes = 1;
+
+            for (i = 0; i < num_planes; i++) {
+               __DRIimage *image = dri2_dpy->image->fromPlanar(
+                                      linear_copy_display_gpu_image, i, NULL);
+
+               if (!image) {
+                  assert(i == 0);
+                  image = linear_copy_display_gpu_image;
+               }
+
+               buffer_fds[i] = -1;
+               ret = dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_FD,
+                                                 &buffer_fds[i]);
+               ret &= dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE,
+                                                  &strides[i]);
+               ret &= dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_OFFSET,
+                                                  &offsets[i]);
+
+               if (image != linear_copy_display_gpu_image)
+                  dri2_dpy->image->destroyImage(image);
+
+               if (!ret) {
+                  do {
+                     if (buffer_fds[i] != -1)
+                        close(buffer_fds[i]);
+                  } while (--i >= 0);
+                  dri2_dpy->image->destroyImage(linear_copy_display_gpu_image);
+                  return -1;
+               }
+            }
+
+            /* The linear buffer was created in the display GPU's vram, so we
+             * need to make it visible to render GPU
+             */
+            dri2_surf->back->linear_copy =
+               dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
+                                                   dri2_surf->base.Width,
+                                                   dri2_surf->base.Height,
+                                                   loader_image_format_to_fourcc(
+                                                      linear_dri_image_format),
+                                                   &buffer_fds[0], num_planes,
+                                                   &strides[0],
+                                                   &offsets[0],
+                                                   dri2_surf->back);
+            do {
+               if (buffer_fds[i] != -1)
+                  close(buffer_fds[i]);
+            } while (--i >= 0);
+            dri2_dpy->image->destroyImage(linear_copy_display_gpu_image);
+         }
+      }
+
+      if (!dri2_surf->back->linear_copy) {
+         dri2_surf->back->linear_copy =
+               loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+                                       dri2_surf->base.Width,
+                                       dri2_surf->base.Height,
+                                       linear_dri_image_format,
+                                       use_flags | __DRI_IMAGE_USE_LINEAR,
+                                       &linear_mod, 1, NULL);
+      }
+
       if (dri2_surf->back->linear_copy == NULL)
-          return -1;
+         return -1;
    }
 
    if (dri2_surf->back->dri_image == NULL) {
-- 
GitLab


From d9dff80b4523e372265fab2633b5435a941ccbf8 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Thu, 1 Dec 2022 14:59:34 +0530
Subject: [PATCH 08/13] egl: add render_gpu tag to dri2_dpy->fd and
 dri2_dpy->dri_screen variable

v1: add render_gpu_tag (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c             | 80 +++++++++++----------
 src/egl/drivers/dri2/egl_dri2.h             |  6 +-
 src/egl/drivers/dri2/platform_android.c     | 38 +++++-----
 src/egl/drivers/dri2/platform_device.c      | 18 ++---
 src/egl/drivers/dri2/platform_drm.c         | 20 +++---
 src/egl/drivers/dri2/platform_surfaceless.c | 26 +++----
 src/egl/drivers/dri2/platform_wayland.c     | 46 ++++++------
 src/egl/drivers/dri2/platform_x11.c         | 26 +++----
 src/egl/drivers/dri2/platform_x11_dri3.c    | 25 +++----
 9 files changed, 144 insertions(+), 141 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index f75d19da318c..ce783c56b0f0 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -811,7 +811,7 @@ static int
 get_screen_param(_EGLDisplay *disp, enum pipe_cap param)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri_screen *screen = dri_screen(dri2_dpy->dri_screen);
+   struct dri_screen *screen = dri_screen(dri2_dpy->dri_screen_render_gpu);
    return screen->base.screen->get_param(screen->base.screen, param);
 }
 
@@ -819,7 +819,7 @@ void
 dri2_setup_screen(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct dri_screen *screen = dri_screen(dri2_dpy->dri_screen);
+   struct dri_screen *screen = dri_screen(dri2_dpy->dri_screen_render_gpu);
    struct pipe_screen *pscreen = screen->base.screen;
    unsigned int api_mask = screen->api_mask;
 
@@ -875,7 +875,7 @@ dri2_setup_screen(_EGLDisplay *disp)
       if (dri2_dpy->fence->get_fence_from_cl_event)
          disp->Extensions.KHR_cl_event2 = EGL_TRUE;
       unsigned capabilities =
-         dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen);
+         dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen_render_gpu);
       disp->Extensions.ANDROID_native_fence_sync =
          (capabilities & __DRI_FENCE_CAP_NATIVE_FD) != 0;
    }
@@ -890,7 +890,7 @@ dri2_setup_screen(_EGLDisplay *disp)
           dri2_dpy->image->getCapabilities != NULL) {
          int capabilities;
 
-         capabilities = dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen);
+         capabilities = dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen_render_gpu);
          disp->Extensions.MESA_drm_image = (capabilities & __DRI_IMAGE_CAP_GLOBAL_NAMES) != 0;
 
          if (dri2_dpy->image->base.version >= 11)
@@ -938,7 +938,7 @@ dri2_setup_swap_interval(_EGLDisplay *disp, int max_swap_interval)
 
    /* Allow driconf to override applications.*/
    if (dri2_dpy->config)
-      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen,
+      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen_render_gpu,
                                      "vblank_mode", &vblank_mode);
    switch (vblank_mode) {
    case DRI_CONF_VBLANK_NEVER:
@@ -992,14 +992,15 @@ dri2_create_screen(_EGLDisplay *disp)
       }
    }
 
-   int screen_fd = dri2_dpy->swrast ? -1 : dri2_dpy->fd;
-   dri2_dpy->dri_screen = dri2_dpy->mesa->createNewScreen(0, screen_fd,
-                                                          dri2_dpy->loader_extensions,
-                                                          dri2_dpy->driver_extensions,
-                                                          &dri2_dpy->driver_configs,
-                                                          disp);
+   int screen_fd = dri2_dpy->swrast ? -1 : dri2_dpy->fd_render_gpu;
+   dri2_dpy->dri_screen_render_gpu =
+      dri2_dpy->mesa->createNewScreen(0, screen_fd,
+                                      dri2_dpy->loader_extensions,
+                                      dri2_dpy->driver_extensions,
+                                      &dri2_dpy->driver_configs,
+                                      disp);
 
-   if (dri2_dpy->dri_screen == NULL) {
+   if (dri2_dpy->dri_screen_render_gpu == NULL) {
       _eglLog(_EGL_WARNING, "egl: failed to create dri2 screen");
       return EGL_FALSE;
    }
@@ -1014,7 +1015,7 @@ dri2_setup_extensions(_EGLDisplay *disp)
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    const __DRIextension **extensions;
 
-   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen);
+   extensions = dri2_dpy->core->getExtensions(dri2_dpy->dri_screen_render_gpu);
 
    if (dri2_dpy->image_driver || dri2_dpy->dri2) {
       if (!loader_bind_extensions(dri2_dpy, dri2_core_extensions, ARRAY_SIZE(dri2_core_extensions), extensions))
@@ -1135,13 +1136,13 @@ dri2_display_destroy(_EGLDisplay *disp)
       if (dri2_dpy->vtbl && dri2_dpy->vtbl->close_screen_notify)
          dri2_dpy->vtbl->close_screen_notify(disp);
 
-      dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen);
+      dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_render_gpu);
 
       if (dri2_dpy->dri_screen_display_gpu)
          dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_display_gpu);
    }
-   if (dri2_dpy->fd >= 0)
-      close(dri2_dpy->fd);
+   if (dri2_dpy->fd_render_gpu >= 0)
+      close(dri2_dpy->fd_render_gpu);
    if (dri2_dpy->fd_display_gpu >= 0)
       close(dri2_dpy->fd_display_gpu);
 
@@ -1199,7 +1200,7 @@ dri2_egl_surface_alloc_local_buffer(struct dri2_egl_surface *dri2_surf,
 
    if (!dri2_surf->local_buffers[att]) {
       dri2_surf->local_buffers[att] =
-         dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen, att, format,
+         dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen_render_gpu, att, format,
                                         dri2_surf->base.Width, dri2_surf->base.Height);
    }
 
@@ -1214,7 +1215,7 @@ dri2_egl_surface_free_local_buffers(struct dri2_egl_surface *dri2_surf)
 
    for (int i = 0; i < ARRAY_SIZE(dri2_surf->local_buffers); i++) {
       if (dri2_surf->local_buffers[i]) {
-         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
+         dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen_render_gpu,
                                        dri2_surf->local_buffers[i]);
          dri2_surf->local_buffers[i] = NULL;
       }
@@ -1452,7 +1453,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
       goto cleanup;
 
    dri2_ctx->dri_context =
-       dri2_dpy->mesa->createContext(dri2_dpy->dri_screen,
+       dri2_dpy->mesa->createContext(dri2_dpy->dri_screen_render_gpu,
                                      api,
                                      dri_config,
                                      shared,
@@ -1503,7 +1504,7 @@ dri2_init_surface(_EGLSurface *surf, _EGLDisplay *disp, EGLint type,
    dri2_surf->out_fence_fd = -1;
    dri2_surf->enable_out_fence = false;
    if (dri2_dpy->fence &&
-       (dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen) &
+       (dri2_dpy->fence->get_capabilities(dri2_dpy->dri_screen_render_gpu) &
         __DRI_FENCE_CAP_NATIVE_FD)) {
       dri2_surf->enable_out_fence = enable_out_fence;
    }
@@ -1558,9 +1559,9 @@ dri2_surf_update_fence_fd(_EGLContext *ctx,
 
    fence = dri2_dpy->fence->create_fence_fd(dri_ctx, -1);
    if (fence) {
-      fence_fd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen,
+      fence_fd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen_render_gpu,
                                                fence);
-      dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen, fence);
+      dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen_render_gpu, fence);
    }
    dri2_surface_set_out_fence_fd(surf, fence_fd);
 }
@@ -1573,7 +1574,8 @@ dri2_create_drawable(struct dri2_egl_display *dri2_dpy,
 {
    if (dri2_dpy->kopper) {
       dri2_surf->dri_drawable =
-          dri2_dpy->kopper->createNewDrawable(dri2_dpy->dri_screen, config, loaderPrivate,
+          dri2_dpy->kopper->createNewDrawable(dri2_dpy->dri_screen_render_gpu,
+                                              config, loaderPrivate,
                                               dri2_surf->base.Type == EGL_PBUFFER_BIT ||
                                               dri2_surf->base.Type == EGL_PIXMAP_BIT);
    } else {
@@ -1587,7 +1589,7 @@ dri2_create_drawable(struct dri2_egl_display *dri2_dpy,
       else
          return _eglError(EGL_BAD_ALLOC, "no createNewDrawable");
 
-      dri2_surf->dri_drawable = createNewDrawable(dri2_dpy->dri_screen,
+      dri2_surf->dri_drawable = createNewDrawable(dri2_dpy->dri_screen_render_gpu,
                                                   config, loaderPrivate);
    }
    if (dri2_surf->dri_drawable == NULL)
@@ -2430,7 +2432,7 @@ dri2_create_image_mesa_drm_buffer(_EGLDisplay *disp, _EGLContext *ctx,
    }
 
    dri_image =
-      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen_render_gpu,
                                            attrs.Width,
                                            attrs.Height,
                                            format,
@@ -2679,7 +2681,7 @@ dri2_query_dma_buf_formats(_EGLDisplay *disp, EGLint max,
        dri2_dpy->image->queryDmaBufFormats == NULL)
       goto fail;
 
-   if (!dri2_dpy->image->queryDmaBufFormats(dri2_dpy->dri_screen, max,
+   if (!dri2_dpy->image->queryDmaBufFormats(dri2_dpy->dri_screen_render_gpu, max,
                                             formats, count))
       goto fail;
 
@@ -2726,7 +2728,7 @@ dri2_query_dma_buf_modifiers(_EGLDisplay *disp, EGLint format,
       return EGL_FALSE;
    }
 
-   if (dri2_dpy->image->queryDmaBufModifiers(dri2_dpy->dri_screen, format,
+   if (dri2_dpy->image->queryDmaBufModifiers(dri2_dpy->dri_screen_render_gpu, format,
                                              max, modifiers,
                                              (unsigned int *) external_only,
                                              count) == false)
@@ -2810,7 +2812,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
          modifier = DRM_FORMAT_MOD_INVALID;
 
       dri_image =
-         dri2_dpy->image->createImageFromDmaBufs3(dri2_dpy->dri_screen,
+         dri2_dpy->image->createImageFromDmaBufs3(dri2_dpy->dri_screen_render_gpu,
             attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
             modifier, fds, num_fds, pitches, offsets,
             attrs.DMABufYuvColorSpaceHint.Value,
@@ -2828,7 +2830,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
          return EGL_NO_IMAGE_KHR;
       }
       dri_image =
-         dri2_dpy->image->createImageFromDmaBufs2(dri2_dpy->dri_screen,
+         dri2_dpy->image->createImageFromDmaBufs2(dri2_dpy->dri_screen_render_gpu,
             attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
             modifier, fds, num_fds, pitches, offsets,
             attrs.DMABufYuvColorSpaceHint.Value,
@@ -2840,7 +2842,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
    }
    else {
       dri_image =
-         dri2_dpy->image->createImageFromDmaBufs(dri2_dpy->dri_screen,
+         dri2_dpy->image->createImageFromDmaBufs(dri2_dpy->dri_screen_render_gpu,
             attrs.Width, attrs.Height, attrs.DMABufFourCC.Value,
             fds, num_fds, pitches, offsets,
             attrs.DMABufYuvColorSpaceHint.Value,
@@ -2919,7 +2921,7 @@ dri2_create_drm_image_mesa(_EGLDisplay *disp, const EGLint *attr_list)
    _eglInitImage(&dri2_img->base, disp);
 
    dri2_img->dri_image =
-      dri2_dpy->image->createImage(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImage(dri2_dpy->dri_screen_render_gpu,
                                    attrs.Width, attrs.Height,
                                    format, dri_use, dri2_img);
    if (dri2_img->dri_image == NULL) {
@@ -3135,7 +3137,7 @@ dri2_wl_reference_buffer(void *user_data, uint32_t name, int fd,
    int dri_components = 0;
 
    if (fd == -1)
-      img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen,
+      img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen_render_gpu,
                                                   buffer->width,
                                                   buffer->height,
                                                   buffer->format,
@@ -3144,7 +3146,7 @@ dri2_wl_reference_buffer(void *user_data, uint32_t name, int fd,
                                                   buffer->offset,
                                                   NULL);
    else
-      img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
+      img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen_render_gpu,
                                                 buffer->width,
                                                 buffer->height,
                                                 buffer->format,
@@ -3195,13 +3197,13 @@ dri2_bind_wayland_display_wl(_EGLDisplay *disp, struct wl_display *wl_dpy)
    if (dri2_dpy->wl_server_drm)
       goto fail;
 
-   device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd);
+   device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd_render_gpu);
    if (!device_name)
       device_name = strdup(dri2_dpy->device_name);
    if (!device_name)
       goto fail;
 
-   if (drmGetCap(dri2_dpy->fd, DRM_CAP_PRIME, &cap) == 0 &&
+   if (drmGetCap(dri2_dpy->fd_render_gpu, DRM_CAP_PRIME, &cap) == 0 &&
        cap == (DRM_PRIME_CAP_IMPORT | DRM_PRIME_CAP_EXPORT) &&
        dri2_dpy->image->base.version >= 7 &&
        dri2_dpy->image->createImageFromFds != NULL)
@@ -3298,7 +3300,7 @@ dri2_egl_unref_sync(struct dri2_egl_display *dri2_dpy,
       }
 
       if (dri2_sync->fence)
-         dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen, dri2_sync->fence);
+         dri2_dpy->fence->destroy_fence(dri2_dpy->dri_screen_render_gpu, dri2_sync->fence);
 
       free(dri2_sync);
    }
@@ -3338,7 +3340,7 @@ dri2_create_sync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
 
    case EGL_SYNC_CL_EVENT_KHR:
       dri2_sync->fence = dri2_dpy->fence->get_fence_from_cl_event(
-                                 dri2_dpy->dri_screen,
+                                 dri2_dpy->dri_screen_render_gpu,
                                  dri2_sync->base.CLEvent);
       /* this can only happen if the cl_event passed in is invalid. */
       if (!dri2_sync->fence) {
@@ -3447,7 +3449,7 @@ dri2_dup_native_fence_fd(_EGLDisplay *disp, _EGLSync *sync)
       /* try to retrieve the actual native fence fd.. if rendering is
        * not flushed this will just return -1, aka NO_NATIVE_FENCE_FD:
        */
-      sync->SyncFd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen,
+      sync->SyncFd = dri2_dpy->fence->get_fence_fd(dri2_dpy->dri_screen_render_gpu,
                                                    dri2_sync->fence);
    }
 
@@ -3470,7 +3472,7 @@ dri2_set_blob_cache_funcs(_EGLDisplay *disp,
                           EGLGetBlobFuncANDROID get)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
-   dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen, set, get);
+   dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen_render_gpu, set, get);
    mtx_unlock(&dri2_dpy->lock);
 }
 
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 31c0d405ca78..d97371c14b17 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -222,7 +222,7 @@ struct dri2_egl_display
 
    int dri2_major;
    int dri2_minor;
-   __DRIscreen *dri_screen;
+   __DRIscreen *dri_screen_render_gpu;
    __DRIscreen *dri_screen_display_gpu;
    bool own_dri_screen;
    const __DRIconfig **driver_configs;
@@ -244,7 +244,7 @@ struct dri2_egl_display
    const __DRI2interopExtension *interop;
    const __DRIconfigOptionsExtension *configOptions;
    const __DRImutableRenderBufferDriverExtension *mutable_render_buffer;
-   int fd;
+   int fd_render_gpu;
    int fd_display_gpu;
 
    /* dri2_initialize/dri2_terminate increment/decrement this count, so does
@@ -613,7 +613,7 @@ dri2_set_WL_bind_wayland_display(_EGLDisplay *disp)
            int capabilities;
 
            capabilities =
-               dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen);
+               dri2_dpy->image->getCapabilities(dri2_dpy->dri_screen_render_gpu);
            disp->Extensions.WL_bind_wayland_display =
                (capabilities & __DRI_IMAGE_CAP_GLOBAL_NAMES) != 0;
        } else {
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index 937a9415f3a5..31826736bb68 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -419,7 +419,7 @@ droid_create_image_from_buffer_info(struct dri2_egl_display *dri2_dpy,
    if (dri2_dpy->image->base.version >= 15 &&
        dri2_dpy->image->createImageFromDmaBufs2 != NULL) {
       return dri2_dpy->image->createImageFromDmaBufs2(
-         dri2_dpy->dri_screen, buf_info->width, buf_info->height,
+         dri2_dpy->dri_screen_render_gpu, buf_info->width, buf_info->height,
          buf_info->drm_fourcc, buf_info->modifier, buf_info->fds,
          buf_info->num_planes, buf_info->pitches, buf_info->offsets,
          buf_info->yuv_color_space, buf_info->sample_range,
@@ -428,7 +428,7 @@ droid_create_image_from_buffer_info(struct dri2_egl_display *dri2_dpy,
    }
 
    return dri2_dpy->image->createImageFromDmaBufs(
-      dri2_dpy->dri_screen, buf_info->width, buf_info->height,
+      dri2_dpy->dri_screen_render_gpu, buf_info->width, buf_info->height,
       buf_info->drm_fourcc, buf_info->fds, buf_info->num_planes,
       buf_info->pitches, buf_info->offsets, buf_info->yuv_color_space,
       buf_info->sample_range, buf_info->horizontal_siting,
@@ -835,7 +835,7 @@ get_front_bo(struct dri2_egl_surface *dri2_surf, unsigned int format)
       _eglLog(_EGL_DEBUG, "DRI driver requested unsupported front buffer for window surface");
    } else if (dri2_surf->base.Type == EGL_PBUFFER_BIT) {
       dri2_surf->dri_image_front =
-          dri2_dpy->image->createImage(dri2_dpy->dri_screen,
+          dri2_dpy->image->createImage(dri2_dpy->dri_screen_render_gpu,
                                               dri2_surf->base.Width,
                                               dri2_surf->base.Height,
                                               format,
@@ -1066,7 +1066,7 @@ droid_create_image_from_name(_EGLDisplay *disp,
        return NULL;
 
    return
-      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen_render_gpu,
 					   buf->width,
 					   buf->height,
 					   format,
@@ -1469,7 +1469,7 @@ droid_load_driver(_EGLDisplay *disp, bool swrast)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (dri2_dpy->driver_name == NULL)
       return false;
 
@@ -1574,11 +1574,11 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
       return EGL_FALSE;
    }
 
-   dri2_dpy->fd = os_dupfd_cloexec(fd);
-   if (dri2_dpy->fd < 0)
+   dri2_dpy->fd_render_gpu = os_dupfd_cloexec(fd);
+   if (dri2_dpy->fd_render_gpu < 0)
       return EGL_FALSE;
 
-   if (drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER)
+   if (drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER)
       return EGL_FALSE;
 
    return droid_probe_device(disp, swrast);
@@ -1614,8 +1614,8 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
       if (!(device->available_nodes & (1 << node_type)))
          continue;
 
-      dri2_dpy->fd = loader_open_device(device->nodes[node_type]);
-      if (dri2_dpy->fd < 0) {
+      dri2_dpy->fd_render_gpu = loader_open_device(device->nodes[node_type]);
+      if (dri2_dpy->fd_render_gpu < 0) {
          _eglLog(_EGL_WARNING, "%s() Failed to open DRM device %s",
                  __func__, device->nodes[node_type]);
          continue;
@@ -1625,10 +1625,10 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
        * Otherwise we fall-back the first device that is supported.
        */
       if (vendor_name) {
-         if (droid_filter_device(disp, dri2_dpy->fd, vendor_name)) {
+         if (droid_filter_device(disp, dri2_dpy->fd_render_gpu, vendor_name)) {
             /* Device does not match - try next device */
-            close(dri2_dpy->fd);
-            dri2_dpy->fd = -1;
+            close(dri2_dpy->fd_render_gpu);
+            dri2_dpy->fd_render_gpu = -1;
             continue;
          }
          /* If the requested device matches - use it. Regardless if
@@ -1636,7 +1636,7 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
           */
          if (!droid_probe_device(disp, false)) {
             close(dri2_dpy->fd);
-            dri2_dpy->fd = -1;
+            dri2_dpy->fd_render_gpu = -1;
          }
 
          break;
@@ -1645,12 +1645,12 @@ droid_open_device(_EGLDisplay *disp, bool swrast)
          break;
 
       /* No explicit request - attempt the next device */
-      close(dri2_dpy->fd);
-      dri2_dpy->fd = -1;
+      close(dri2_dpy->fd_render_gpu);
+      dri2_dpy->fd_render_gpu = -1;
    }
    drmFreeDevices(devices, num_devices);
 
-   if (dri2_dpy->fd < 0) {
+   if (dri2_dpy->fd_render_gpu < 0) {
       _eglLog(_EGL_WARNING, "Failed to open %s DRM device",
             vendor_name ? "desired": "any");
       return EGL_FALSE;
@@ -1675,7 +1675,7 @@ dri2_initialize_android(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID,
                        (const hw_module_t **)&dri2_dpy->gralloc);
@@ -1692,7 +1692,7 @@ dri2_initialize_android(_EGLDisplay *disp)
       goto cleanup;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       err = "DRI2: failed to find EGLDevice";
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_device.c b/src/egl/drivers/dri2/platform_device.c
index 1181fb08053e..d107697ae51f 100644
--- a/src/egl/drivers/dri2/platform_device.c
+++ b/src/egl/drivers/dri2/platform_device.c
@@ -49,7 +49,7 @@ device_alloc_image(struct dri2_egl_display *dri2_dpy,
                    struct dri2_egl_surface *dri2_surf)
 {
    return dri2_dpy->image->createImage(
-            dri2_dpy->dri_screen,
+            dri2_dpy->dri_screen_render_gpu,
             dri2_surf->base.Width,
             dri2_surf->base.Height,
             dri2_surf->visual,
@@ -279,11 +279,11 @@ device_probe_device(_EGLDisplay *disp)
    if (request_software)
       _eglLog(_EGL_WARNING, "Not allowed to force software rendering when "
                             "API explicitly selects a hardware device.");
-   dri2_dpy->fd = device_get_fd(disp, disp->Device);
-   if (dri2_dpy->fd < 0)
+   dri2_dpy->fd_render_gpu = device_get_fd(disp, disp->Device);
+   if (dri2_dpy->fd_render_gpu < 0)
       return false;
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (!dri2_dpy->driver_name)
       goto err_name;
 
@@ -310,8 +310,8 @@ err_load:
    dri2_dpy->driver_name = NULL;
 
 err_name:
-   close(dri2_dpy->fd);
-   dri2_dpy->fd = -1;
+   close(dri2_dpy->fd_render_gpu);
+   dri2_dpy->fd_render_gpu = -1;
    return false;
 
 }
@@ -321,7 +321,7 @@ device_probe_device_sw(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->driver_name = strdup(disp->Options.Zink ? "zink" : "swrast");
    if (!dri2_dpy->driver_name)
       return false;
@@ -351,7 +351,7 @@ dri2_initialize_device(_EGLDisplay *disp)
    /* Extension requires a PlatformDisplay - the EGLDevice. */
    dev = disp->PlatformDisplay;
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->Device = dev;
    disp->DriverData = (void *) dri2_dpy;
@@ -379,7 +379,7 @@ dri2_initialize_device(_EGLDisplay *disp)
 
    dri2_setup_screen(disp);
 #ifdef HAVE_WAYLAND_PLATFORM
-   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
 #endif
    dri2_set_WL_bind_wayland_display(disp);
 
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index ce906e977141..e506288bba1f 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -507,7 +507,7 @@ dri2_drm_authenticate(_EGLDisplay *disp, uint32_t id)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   return drmAuthMagic(dri2_dpy->fd, id);
+   return drmAuthMagic(dri2_dpy->fd_render_gpu, id);
 }
 
 static void
@@ -691,7 +691,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
@@ -700,16 +700,16 @@ dri2_initialize_drm(_EGLDisplay *disp)
       char buf[64];
       int n = snprintf(buf, sizeof(buf), DRM_DEV_NAME, DRM_DIR_NAME, 0);
       if (n != -1 && n < sizeof(buf))
-         dri2_dpy->fd = loader_open_device(buf);
-      gbm = gbm_create_device(dri2_dpy->fd);
+         dri2_dpy->fd_render_gpu = loader_open_device(buf);
+      gbm = gbm_create_device(dri2_dpy->fd_render_gpu);
       if (gbm == NULL) {
          err = "DRI2: failed to create gbm device";
          goto cleanup;
       }
       dri2_dpy->own_device = true;
    } else {
-      dri2_dpy->fd = os_dupfd_cloexec(gbm_device_get_fd(gbm));
-      if (dri2_dpy->fd < 0) {
+      dri2_dpy->fd_render_gpu = os_dupfd_cloexec(gbm_device_get_fd(gbm));
+      if (dri2_dpy->fd_render_gpu < 0) {
          err = "DRI2: failed to fcntl() existing gbm device";
          goto cleanup;
       }
@@ -721,7 +721,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       goto cleanup;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, dri2_dpy->gbm_dri->software);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, dri2_dpy->gbm_dri->software);
    if (!dev) {
       err = "DRI2: failed to find EGLDevice";
       goto cleanup;
@@ -730,7 +730,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
    disp->Device = dev;
 
    dri2_dpy->driver_name = strdup(dri2_dpy->gbm_dri->driver_name);
-   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER;
+   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER;
 
    /* render nodes cannot use Gem names, and thus do not support
     * the __DRI_DRI2_LOADER extension */
@@ -746,7 +746,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       }
    }
 
-   dri2_dpy->dri_screen = dri2_dpy->gbm_dri->screen;
+   dri2_dpy->dri_screen_render_gpu = dri2_dpy->gbm_dri->screen;
    dri2_dpy->core = dri2_dpy->gbm_dri->core;
    dri2_dpy->dri2 = dri2_dpy->gbm_dri->dri2;
    dri2_dpy->swrast = dri2_dpy->gbm_dri->swrast;
@@ -786,7 +786,7 @@ dri2_initialize_drm(_EGLDisplay *disp)
       disp->Extensions.EXT_buffer_age = EGL_TRUE;
 
 #ifdef HAVE_WAYLAND_PLATFORM
-   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
 #endif
    dri2_set_WL_bind_wayland_display(disp);
 
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index 82d44e3cd224..8f59aa9290cf 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -42,7 +42,7 @@ surfaceless_alloc_image(struct dri2_egl_display *dri2_dpy,
                      struct dri2_egl_surface *dri2_surf)
 {
    return dri2_dpy->image->createImage(
-            dri2_dpy->dri_screen,
+            dri2_dpy->dri_screen_render_gpu,
             dri2_surf->base.Width,
             dri2_surf->base.Height,
             dri2_surf->visual,
@@ -250,18 +250,18 @@ surfaceless_probe_device(_EGLDisplay *disp, bool swrast)
       if (!(device->available_nodes & (1 << node_type)))
          continue;
 
-      dri2_dpy->fd = loader_open_device(device->nodes[node_type]);
-      if (dri2_dpy->fd < 0)
+      dri2_dpy->fd_render_gpu = loader_open_device(device->nodes[node_type]);
+      if (dri2_dpy->fd_render_gpu < 0)
          continue;
 
-      disp->Device = _eglAddDevice(dri2_dpy->fd, swrast);
+      disp->Device = _eglAddDevice(dri2_dpy->fd_render_gpu, swrast);
       if (!disp->Device) {
-         close(dri2_dpy->fd);
-         dri2_dpy->fd = -1;
+         close(dri2_dpy->fd_render_gpu);
+         dri2_dpy->fd_render_gpu = -1;
          continue;
       }
 
-      char *driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+      char *driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
       if (swrast) {
          /* Use kms swrast only with vgem / virtio_gpu.
           * virtio-gpu fallbacks to software rendering when 3D features
@@ -283,8 +283,8 @@ surfaceless_probe_device(_EGLDisplay *disp, bool swrast)
 
       free(dri2_dpy->driver_name);
       dri2_dpy->driver_name = NULL;
-      close(dri2_dpy->fd);
-      dri2_dpy->fd = -1;
+      close(dri2_dpy->fd_render_gpu);
+      dri2_dpy->fd_render_gpu = -1;
    }
    drmFreeDevices(devices, num_devices);
 
@@ -304,8 +304,8 @@ surfaceless_probe_device_sw(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   dri2_dpy->fd = -1;
-   disp->Device = _eglAddDevice(dri2_dpy->fd, true);
+   dri2_dpy->fd_render_gpu = -1;
+   disp->Device = _eglAddDevice(dri2_dpy->fd_render_gpu, true);
    assert(disp->Device);
 
    dri2_dpy->driver_name = strdup(disp->Options.Zink ? "zink" : "swrast");
@@ -333,7 +333,7 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
@@ -363,7 +363,7 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
 
    dri2_setup_screen(disp);
 #ifdef HAVE_WAYLAND_PLATFORM
-   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+   dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
 #endif
    dri2_set_WL_bind_wayland_display(disp);
 
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index e68f824eed19..a1256f00ba74 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -935,7 +935,7 @@ create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
          flags |= __DRI_IMAGE_USE_SCANOUT;
 
       dri2_surf->back->dri_image =
-         loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+         loader_dri_create_image(dri2_dpy->dri_screen_render_gpu, dri2_dpy->image,
                                  dri2_surf->base.Width,
                                  dri2_surf->base.Height,
                                  dri_image_format,
@@ -973,7 +973,7 @@ create_dri_image(struct dri2_egl_surface *dri2_surf,
     * then fall back to the old createImage, and hope it allocates an image
     * which is acceptable to the winsys. */
    dri2_surf->back->dri_image =
-      loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+      loader_dri_create_image(dri2_dpy->dri_screen_render_gpu, dri2_dpy->image,
                               dri2_surf->base.Width,
                               dri2_surf->base.Height,
                               dri_image_format,
@@ -1111,7 +1111,7 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
              * need to make it visible to render GPU
              */
             dri2_surf->back->linear_copy =
-               dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
+               dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen_render_gpu,
                                                    dri2_surf->base.Width,
                                                    dri2_surf->base.Height,
                                                    loader_image_format_to_fourcc(
@@ -1130,7 +1130,7 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
 
       if (!dri2_surf->back->linear_copy) {
          dri2_surf->back->linear_copy =
-               loader_dri_create_image(dri2_dpy->dri_screen, dri2_dpy->image,
+               loader_dri_create_image(dri2_dpy->dri_screen_render_gpu, dri2_dpy->image,
                                        dri2_surf->base.Width,
                                        dri2_surf->base.Height,
                                        linear_dri_image_format,
@@ -1777,8 +1777,8 @@ drm_handle_device(void *data, struct wl_drm *drm, const char *device)
    if (!dri2_dpy->device_name)
       return;
 
-   dri2_dpy->fd = loader_open_device(dri2_dpy->device_name);
-   if (dri2_dpy->fd == -1) {
+   dri2_dpy->fd_render_gpu = loader_open_device(dri2_dpy->device_name);
+   if (dri2_dpy->fd_render_gpu == -1) {
       _eglLog(_EGL_WARNING, "wayland-egl: could not open %s (%s)",
               dri2_dpy->device_name, strerror(errno));
       free(dri2_dpy->device_name);
@@ -1786,12 +1786,12 @@ drm_handle_device(void *data, struct wl_drm *drm, const char *device)
       return;
    }
 
-   if (drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER) {
+   if (drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER) {
       dri2_dpy->authenticated = true;
    } else {
-      if (drmGetMagic(dri2_dpy->fd, &magic)) {
-         close(dri2_dpy->fd);
-         dri2_dpy->fd = -1;
+      if (drmGetMagic(dri2_dpy->fd_render_gpu, &magic)) {
+         close(dri2_dpy->fd_render_gpu);
+         dri2_dpy->fd_render_gpu = -1;
          free(dri2_dpy->device_name);
          dri2_dpy->device_name = NULL;
          _eglLog(_EGL_WARNING, "wayland-egl: drmGetMagic failed");
@@ -1916,7 +1916,7 @@ default_dmabuf_feedback_main_device(void *data,
    }
 
    dri2_dpy->device_name = node;
-   dri2_dpy->fd = fd;
+   dri2_dpy->fd_render_gpu = fd;
    dri2_dpy->authenticated = true;
 }
 
@@ -2157,7 +2157,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
@@ -2214,7 +2214,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    /* We couldn't retrieve a render node from the dma-buf feedback (or the
     * feedback was not advertised at all), so we must fallback to wl_drm. */
-   if (dri2_dpy->fd == -1) {
+   if (dri2_dpy->fd_render_gpu == -1) {
       /* wl_drm not advertised by compositor, so can't continue */
       if (dri2_dpy->wl_drm_name == 0)
          goto cleanup;
@@ -2222,7 +2222,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
       if (dri2_dpy->wl_drm == NULL)
          goto cleanup;
-      if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd == -1)
+      if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd_render_gpu == -1)
          goto cleanup;
 
       if (!dri2_dpy->authenticated &&
@@ -2230,15 +2230,15 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
          goto cleanup;
    }
 
-   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
-   dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd,
-                                               &dri2_dpy->is_different_gpu);
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
+   dri2_dpy->fd_render_gpu = loader_get_user_preferred_fd(dri2_dpy->fd_render_gpu,
+                                                          &dri2_dpy->is_different_gpu);
    if (!dri2_dpy->is_different_gpu) {
       close(dri2_dpy->fd_display_gpu);
       dri2_dpy->fd_display_gpu = -1;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
@@ -2248,7 +2248,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    if (dri2_dpy->is_different_gpu) {
       free(dri2_dpy->device_name);
-      dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd);
+      dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
       if (!dri2_dpy->device_name) {
          _eglError(EGL_BAD_ALLOC, "wayland-egl: failed to get device name "
                                   "for requested GPU");
@@ -2260,9 +2260,9 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
     * will return a render-node when the requested gpu is different
     * to the server, but also if the client asks for the same gpu than
     * the server by requesting its pci-id */
-   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd) == DRM_NODE_RENDER;
+   dri2_dpy->is_render_node = drmGetNodeTypeFromFd(dri2_dpy->fd_render_gpu) == DRM_NODE_RENDER;
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (dri2_dpy->driver_name == NULL) {
       _eglError(EGL_BAD_ALLOC, "DRI2: failed to get driver name");
       goto cleanup;
@@ -2770,7 +2770,7 @@ dri2_initialize_wayland_swrast(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    disp->DriverData = (void *) dri2_dpy;
 
    if (dri2_wl_formats_init(&dri2_dpy->formats) < 0)
@@ -2785,7 +2785,7 @@ dri2_initialize_wayland_swrast(_EGLDisplay *disp)
       dri2_dpy->wl_dpy = disp->PlatformDisplay;
    }
 
-   dev = _eglAddDevice(dri2_dpy->fd, true);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, true);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index 93a7d6a3c706..f9b82557e087 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -634,7 +634,7 @@ dri2_x11_local_authenticate(struct dri2_egl_display *dri2_dpy)
 #ifdef HAVE_LIBDRM
    drm_magic_t magic;
 
-   if (drmGetMagic(dri2_dpy->fd, &magic)) {
+   if (drmGetMagic(dri2_dpy->fd_render_gpu, &magic)) {
       _eglLog(_EGL_WARNING, "DRI2: failed to get drm magic");
       return EGL_FALSE;
    }
@@ -716,8 +716,8 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
 
    device_name = xcb_dri2_connect_device_name (connect);
 
-   dri2_dpy->fd = loader_open_device(device_name);
-   if (dri2_dpy->fd == -1) {
+   dri2_dpy->fd_render_gpu = loader_open_device(device_name);
+   if (dri2_dpy->fd_render_gpu == -1) {
       _eglLog(_EGL_WARNING,
               "DRI2: could not open %s (%s)", device_name, strerror(errno));
       free(connect);
@@ -725,7 +725,7 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
    }
 
    if (!dri2_x11_local_authenticate(dri2_dpy)) {
-      close(dri2_dpy->fd);
+      close(dri2_dpy->fd_render_gpu);
       free(connect);
       return EGL_FALSE;
    }
@@ -735,7 +735,7 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
    /* If Mesa knows about the appropriate driver for this fd, then trust it.
     * Otherwise, default to the server's value.
     */
-   loader_driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   loader_driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (loader_driver_name) {
       dri2_dpy->driver_name = loader_driver_name;
    } else {
@@ -745,7 +745,7 @@ dri2_x11_connect(struct dri2_egl_display *dri2_dpy)
    }
 
    if (dri2_dpy->driver_name == NULL) {
-      close(dri2_dpy->fd);
+      close(dri2_dpy->fd_render_gpu);
       free(connect);
       return EGL_FALSE;
    }
@@ -1142,7 +1142,7 @@ dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
 
    stride = buffers[0].pitch / buffers[0].cpp;
    dri2_img->dri_image =
-      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen,
+      dri2_dpy->image->createImageFromName(dri2_dpy->dri_screen_render_gpu,
 					   buffers_reply->width,
 					   buffers_reply->height,
 					   format,
@@ -1451,12 +1451,12 @@ dri2_initialize_x11_swrast(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
 
-   dev = _eglAddDevice(dri2_dpy->fd, true);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, true);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
@@ -1541,7 +1541,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
@@ -1549,7 +1549,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
    if (!dri3_x11_connect(dri2_dpy))
       goto cleanup;
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
@@ -1651,7 +1651,7 @@ dri2_initialize_x11_dri2(_EGLDisplay *disp)
    if (!dri2_dpy)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
-   dri2_dpy->fd = -1;
+   dri2_dpy->fd_render_gpu = -1;
    dri2_dpy->fd_display_gpu = -1;
    if (!dri2_get_xcb_connection(disp, dri2_dpy))
       goto cleanup;
@@ -1659,7 +1659,7 @@ dri2_initialize_x11_dri2(_EGLDisplay *disp)
    if (!dri2_x11_connect(dri2_dpy))
       goto cleanup;
 
-   dev = _eglAddDevice(dri2_dpy->fd, false);
+   dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       _eglError(EGL_NOT_INITIALIZED, "DRI2: failed to find EGLDevice");
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index 8a2bee9650bc..a0e6366daffb 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -84,7 +84,7 @@ egl_dri3_get_dri_screen(void)
    if (!ctx)
       return NULL;
    dri2_ctx = dri2_egl_context(ctx);
-   return dri2_egl_display(dri2_ctx->base.Resource.Display)->dri_screen;
+   return dri2_egl_display(dri2_ctx->base.Resource.Display)->dri_screen_render_gpu;
 }
 
 static void
@@ -189,7 +189,7 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
 
    if (loader_dri3_drawable_init(dri2_dpy->conn, drawable,
                                  egl_to_loader_dri3_drawable_type(type),
-                                 dri2_dpy->dri_screen,
+                                 dri2_dpy->dri_screen_render_gpu,
                                  dri2_dpy->dri_screen_display_gpu,
                                  dri2_dpy->is_different_gpu,
                                  dri2_dpy->multibuffers_available,
@@ -327,7 +327,7 @@ dri3_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
    dri2_img->dri_image = loader_dri3_create_image(dri2_dpy->conn,
                                                   bp_reply,
                                                   format,
-                                                  dri2_dpy->dri_screen,
+                                                  dri2_dpy->dri_screen_render_gpu,
                                                   dri2_dpy->image,
                                                   dri2_img);
 
@@ -379,7 +379,7 @@ dri3_create_image_khr_pixmap_from_buffers(_EGLDisplay *disp, _EGLContext *ctx,
    dri2_img->dri_image = loader_dri3_create_image_from_buffers(dri2_dpy->conn,
                                                                bp_reply,
                                                                format,
-                                                               dri2_dpy->dri_screen,
+                                                               dri2_dpy->dri_screen_render_gpu,
                                                                dri2_dpy->image,
                                                                dri2_img);
    free(bp_reply);
@@ -512,7 +512,7 @@ dri3_close_screen_notify(_EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   loader_dri3_close_screen(dri2_dpy->dri_screen);
+   loader_dri3_close_screen(dri2_dpy->dri_screen_render_gpu);
 }
 
 struct dri2_egl_display_vtbl dri3_x11_display_vtbl = {
@@ -625,8 +625,8 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
    }
    free(xfixes_query);
 
-   dri2_dpy->fd = loader_dri3_open(dri2_dpy->conn, dri2_dpy->screen->root, 0);
-   if (dri2_dpy->fd < 0) {
+   dri2_dpy->fd_render_gpu = loader_dri3_open(dri2_dpy->conn, dri2_dpy->screen->root, 0);
+   if (dri2_dpy->fd_render_gpu < 0) {
       int conn_error = xcb_connection_has_error(dri2_dpy->conn);
       _eglLog(_EGL_WARNING, "DRI3: Screen seems not DRI3 capable");
 
@@ -636,17 +636,18 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
       return EGL_FALSE;
    }
 
-   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd, F_DUPFD_CLOEXEC, 3);
-   dri2_dpy->fd = loader_get_user_preferred_fd(dri2_dpy->fd, &dri2_dpy->is_different_gpu);
+   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
+   dri2_dpy->fd_render_gpu = loader_get_user_preferred_fd(dri2_dpy->fd_render_gpu,
+                                                          &dri2_dpy->is_different_gpu);
    if (!dri2_dpy->is_different_gpu) {
       close(dri2_dpy->fd_display_gpu);
       dri2_dpy->fd_display_gpu = -1;
    }
 
-   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd);
+   dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (!dri2_dpy->driver_name) {
       _eglLog(_EGL_WARNING, "DRI3: No driver found");
-      close(dri2_dpy->fd);
+      close(dri2_dpy->fd_render_gpu);
       return EGL_FALSE;
    }
 
@@ -654,7 +655,7 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
    /* Only try to get a render device name since dri3 doesn't provide a
     * mechanism for authenticating client opened device node fds. If this
     * fails then don't advertise the extension. */
-   dri2_dpy->device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd);
+   dri2_dpy->device_name = drmGetRenderDeviceNameFromFd(dri2_dpy->fd_render_gpu);
 #endif
 
    return EGL_TRUE;
-- 
GitLab


From be9a06fe4ed0f2728b29976defd0dfc74a392e0f Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Thu, 1 Dec 2022 18:27:23 +0530
Subject: [PATCH 09/13] loader,glx: add render_gpu tag psc->driScreen and
 psc->fd

v1: add render_gpu_tag (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/glx/dri3_glx.c                  | 76 ++++++++++++++---------------
 src/glx/dri3_priv.h                 |  9 ++--
 src/glx/dri_common_query_renderer.c |  4 +-
 src/loader/loader_dri3_helper.c     | 34 ++++++-------
 src/loader/loader_dri3_helper.h     |  7 ++-
 5 files changed, 64 insertions(+), 66 deletions(-)

diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 76ce028ee36c..2ba768dfa7ae 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -122,7 +122,7 @@ glx_dri3_get_dri_screen(void)
    struct glx_context *gc = __glXGetCurrentContext();
    struct dri3_screen *psc = (struct dri3_screen *) gc->psc;
 
-   return (gc != &dummyContext && psc) ? psc->driScreen : NULL;
+   return (gc != &dummyContext && psc) ? psc->driScreenRenderGPU : NULL;
 }
 
 static void
@@ -309,15 +309,15 @@ dri3_create_context_attribs(struct glx_screen *base,
    pcp->renderType = dca.render_type;
 
    pcp->driContext =
-      psc->image_driver->createContextAttribs(psc->driScreen,
-                                                  dca.api,
-                                                  config ? config->driConfig
-                                                         : NULL,
-                                                  shared,
-                                                  num_ctx_attribs / 2,
-                                                  ctx_attribs,
-                                                  error,
-                                                  pcp);
+      psc->image_driver->createContextAttribs(psc->driScreenRenderGPU,
+                                              dca.api,
+                                              config ? config->driConfig
+                                              : NULL,
+                                              shared,
+                                              num_ctx_attribs / 2,
+                                              ctx_attribs,
+                                              error,
+                                              pcp);
 
    if (pcp->driContext == NULL)
       goto error_exit;
@@ -393,7 +393,7 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
    if (loader_dri3_drawable_init(XGetXCBConnection(base->dpy),
                                  xDrawable,
                                  glx_to_loader_dri3_drawable_type(type),
-                                 psc->driScreen, psc->driScreenDisplayGPU,
+                                 psc->driScreenRenderGPU, psc->driScreenDisplayGPU,
                                  psc->is_different_gpu, has_multibuffer,
                                  psc->prefer_back_buffer_reuse,
                                  config->driConfig,
@@ -621,10 +621,10 @@ dri3_destroy_screen(struct glx_screen *base)
       }
       close(psc->fd_display_gpu);
    }
-   loader_dri3_close_screen(psc->driScreen);
-   psc->core->destroyScreen(psc->driScreen);
+   loader_dri3_close_screen(psc->driScreenRenderGPU);
+   psc->core->destroyScreen(psc->driScreenRenderGPU);
    driDestroyConfigs(psc->driver_configs);
-   close(psc->fd);
+   close(psc->fd_render_gpu);
    free(psc);
 }
 
@@ -640,7 +640,7 @@ dri3_set_swap_interval(__GLXDRIdrawable *pdraw, int interval)
    struct dri3_drawable *priv =  (struct dri3_drawable *) pdraw;
    struct dri3_screen *psc = (struct dri3_screen *) priv->base.psc;
 
-   if (!dri_valid_swap_interval(psc->driScreen, psc->config, interval))
+   if (!dri_valid_swap_interval(psc->driScreenRenderGPU, psc->config, interval))
       return GLX_BAD_VALUE;
 
    loader_dri3_set_swap_interval(&priv->loader_drawable, interval);
@@ -725,7 +725,7 @@ dri3_bind_extensions(struct dri3_screen *psc, struct glx_display * priv,
    unsigned mask;
    int i;
 
-   extensions = psc->core->getExtensions(psc->driScreen);
+   extensions = psc->core->getExtensions(psc->driScreenRenderGPU);
 
    __glXEnableDirectExtension(&psc->base, "GLX_EXT_swap_control");
    __glXEnableDirectExtension(&psc->base, "GLX_EXT_swap_control_tear");
@@ -734,7 +734,7 @@ dri3_bind_extensions(struct dri3_screen *psc, struct glx_display * priv,
    __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");
    __glXEnableDirectExtension(&psc->base, "GLX_INTEL_swap_event");
 
-   mask = psc->image_driver->getAPIMask(psc->driScreen);
+   mask = psc->image_driver->getAPIMask(psc->driScreenRenderGPU);
 
    __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context");
    __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context_profile");
@@ -788,7 +788,7 @@ dri3_get_driver_name(struct glx_screen *glx_screen)
 {
     struct dri3_screen *psc = (struct dri3_screen *)glx_screen;
 
-    return loader_get_driver_for_fd(psc->fd);
+    return loader_get_driver_for_fd(psc->fd_render_gpu);
 }
 
 static const struct glx_screen_vtable dri3_screen_vtable = {
@@ -828,7 +828,7 @@ dri3_create_screen(int screen, struct glx_display * priv)
    if (psc == NULL)
       return NULL;
 
-   psc->fd = -1;
+   psc->fd_render_gpu = -1;
    psc->fd_display_gpu = -1;
 
    if (!glx_screen_init(&psc->base, screen, priv)) {
@@ -836,8 +836,8 @@ dri3_create_screen(int screen, struct glx_display * priv)
       return NULL;
    }
 
-   psc->fd = loader_dri3_open(c, RootWindow(priv->dpy, screen), None);
-   if (psc->fd < 0) {
+   psc->fd_render_gpu = loader_dri3_open(c, RootWindow(priv->dpy, screen), None);
+   if (psc->fd_render_gpu < 0) {
       int conn_error = xcb_connection_has_error(c);
 
       glx_screen_cleanup(&psc->base);
@@ -850,14 +850,14 @@ dri3_create_screen(int screen, struct glx_display * priv)
       return NULL;
    }
 
-   psc->fd_display_gpu = fcntl(psc->fd, F_DUPFD_CLOEXEC, 3);
-   psc->fd = loader_get_user_preferred_fd(psc->fd, &psc->is_different_gpu);
+   psc->fd_display_gpu = fcntl(psc->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
+   psc->fd_render_gpu = loader_get_user_preferred_fd(psc->fd_render_gpu, &psc->is_different_gpu);
    if (!psc->is_different_gpu) {
       close(psc->fd_display_gpu);
       psc->fd_display_gpu = -1;
    }
 
-   driverName = loader_get_driver_for_fd(psc->fd);
+   driverName = loader_get_driver_for_fd(psc->fd_render_gpu);
    if (!driverName) {
       ErrorMessageF("No driver found\n");
       goto handle_error;
@@ -896,13 +896,13 @@ dri3_create_screen(int screen, struct glx_display * priv)
       }
    }
 
-   psc->driScreen =
-      psc->image_driver->createNewScreen2(screen, psc->fd,
+   psc->driScreenRenderGPU =
+      psc->image_driver->createNewScreen2(screen, psc->fd_render_gpu,
                                           pdp->loader_extensions,
                                           extensions,
                                           &driver_configs, psc);
 
-   if (psc->driScreen == NULL) {
+   if (psc->driScreenRenderGPU == NULL) {
       ErrorMessageF("glx: failed to create dri3 screen\n");
       goto handle_error;
    }
@@ -986,32 +986,32 @@ dri3_create_screen(int screen, struct glx_display * priv)
    __glXEnableDirectExtension(&psc->base, "GLX_EXT_buffer_age");
 
    if (psc->config->base.version > 1 &&
-          psc->config->configQuerys(psc->driScreen, "glx_extension_override",
+          psc->config->configQuerys(psc->driScreenRenderGPU, "glx_extension_override",
                                     &tmp) == 0)
       __glXParseExtensionOverride(&psc->base, tmp);
 
    if (psc->config->base.version > 1 &&
-          psc->config->configQuerys(psc->driScreen,
+          psc->config->configQuerys(psc->driScreenRenderGPU,
                                     "indirect_gl_extension_override",
                                     &tmp) == 0)
       __IndirectGlParseExtensionOverride(&psc->base, tmp);
 
    if (psc->config->base.version > 1) {
       uint8_t force = false;
-      if (psc->config->configQueryb(psc->driScreen, "force_direct_glx_context",
+      if (psc->config->configQueryb(psc->driScreenRenderGPU, "force_direct_glx_context",
                                     &force) == 0) {
          psc->base.force_direct_context = force;
       }
 
       uint8_t invalid_glx_destroy_window = false;
-      if (psc->config->configQueryb(psc->driScreen,
+      if (psc->config->configQueryb(psc->driScreenRenderGPU,
                                     "allow_invalid_glx_destroy_window",
                                     &invalid_glx_destroy_window) == 0) {
          psc->base.allow_invalid_glx_destroy_window = invalid_glx_destroy_window;
       }
 
       uint8_t keep_native_window_glx_drawable = false;
-      if (psc->config->configQueryb(psc->driScreen,
+      if (psc->config->configQueryb(psc->driScreenRenderGPU,
                                     "keep_native_window_glx_drawable",
                                     &keep_native_window_glx_drawable) == 0) {
          psc->base.keep_native_window_glx_drawable = keep_native_window_glx_drawable;
@@ -1030,7 +1030,7 @@ dri3_create_screen(int screen, struct glx_display * priv)
    psc->prefer_back_buffer_reuse = 1;
    if (psc->is_different_gpu && psc->rendererQuery) {
       unsigned value;
-      if (psc->rendererQuery->queryInteger(psc->driScreen,
+      if (psc->rendererQuery->queryInteger(psc->driScreenRenderGPU,
                                            __DRI2_RENDERER_PREFER_BACK_BUFFER_REUSE,
                                            &value) == 0)
          psc->prefer_back_buffer_reuse = value;
@@ -1045,14 +1045,14 @@ handle_error:
        glx_config_destroy_list(configs);
    if (visuals)
        glx_config_destroy_list(visuals);
-   if (psc->driScreen)
-       psc->core->destroyScreen(psc->driScreen);
-   psc->driScreen = NULL;
+   if (psc->driScreenRenderGPU)
+       psc->core->destroyScreen(psc->driScreenRenderGPU);
+   psc->driScreenRenderGPU = NULL;
    if (psc->driScreenDisplayGPU)
        psc->core->destroyScreen(psc->driScreenDisplayGPU);
    psc->driScreenDisplayGPU = NULL;
-   if (psc->fd >= 0)
-      close(psc->fd);
+   if (psc->fd_render_gpu >= 0)
+      close(psc->fd_render_gpu);
    if (psc->fd_display_gpu >= 0)
       close(psc->fd_display_gpu);
    if (psc->driver)
diff --git a/src/glx/dri3_priv.h b/src/glx/dri3_priv.h
index 7820033035ff..16454638453b 100644
--- a/src/glx/dri3_priv.h
+++ b/src/glx/dri3_priv.h
@@ -81,7 +81,7 @@ struct dri3_display
 struct dri3_screen {
    struct glx_screen base;
 
-   __DRIscreen *driScreen;
+   __DRIscreen *driScreenRenderGPU;
    __GLXDRIscreen vtable;
 
    /* DRI screen is created for display GPU in case of prime.
@@ -102,12 +102,11 @@ struct dri3_screen {
    const __DRIconfig **driver_configs;
 
    void *driver;
-   int fd;
-   bool is_different_gpu;
-   bool prefer_back_buffer_reuse;
-
+   int fd_render_gpu;
    /* fd for display GPU in case of prime */
    int fd_display_gpu;
+   bool is_different_gpu;
+   bool prefer_back_buffer_reuse;
 
    int show_fps_interval;
 
diff --git a/src/glx/dri_common_query_renderer.c b/src/glx/dri_common_query_renderer.c
index 672e3bf314a5..6d2a06689a96 100644
--- a/src/glx/dri_common_query_renderer.c
+++ b/src/glx/dri_common_query_renderer.c
@@ -137,7 +137,7 @@ dri3_query_renderer_integer(struct glx_screen *base, int attribute,
    if (psc->rendererQuery == NULL)
       return -1;
 
-   ret = psc->rendererQuery->queryInteger(psc->driScreen, dri_attribute,
+   ret = psc->rendererQuery->queryInteger(psc->driScreenRenderGPU, dri_attribute,
                                           value);
    dri_convert_context_profile_bits(attribute, value);
 
@@ -159,7 +159,7 @@ dri3_query_renderer_string(struct glx_screen *base, int attribute,
    if (psc->rendererQuery == NULL)
       return -1;
 
-   return psc->rendererQuery->queryString(psc->driScreen, dri_attribute, value);
+   return psc->rendererQuery->queryString(psc->driScreenRenderGPU, dri_attribute, value);
 }
 #endif /* HAVE_DRI3 */
 
diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index c6da524b29a6..edaa85399b39 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -164,15 +164,15 @@ loader_dri3_blit_context_get(struct loader_dri3_drawable *draw)
 {
    mtx_lock(&blit_context.mtx);
 
-   if (blit_context.ctx && blit_context.cur_screen != draw->dri_screen) {
+   if (blit_context.ctx && blit_context.cur_screen != draw->dri_screen_render_gpu) {
       blit_context.core->destroyContext(blit_context.ctx);
       blit_context.ctx = NULL;
    }
 
    if (!blit_context.ctx) {
-      blit_context.ctx = draw->ext->core->createNewContext(draw->dri_screen,
+      blit_context.ctx = draw->ext->core->createNewContext(draw->dri_screen_render_gpu,
                                                            NULL, NULL, NULL);
-      blit_context.cur_screen = draw->dri_screen;
+      blit_context.cur_screen = draw->dri_screen_render_gpu;
       blit_context.core = draw->ext->core;
    }
 
@@ -379,7 +379,7 @@ int
 loader_dri3_drawable_init(xcb_connection_t *conn,
                           xcb_drawable_t drawable,
                           enum loader_dri3_drawable_type type,
-                          __DRIscreen *dri_screen,
+                          __DRIscreen *dri_screen_render_gpu,
                           __DRIscreen *dri_screen_display_gpu,
                           bool is_different_gpu,
                           bool multiplanes_available,
@@ -399,7 +399,7 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    draw->drawable = drawable;
    draw->type = type;
    draw->region = 0;
-   draw->dri_screen = dri_screen;
+   draw->dri_screen_render_gpu = dri_screen_render_gpu;
    draw->dri_screen_display_gpu = dri_screen_display_gpu;
    draw->is_different_gpu = is_different_gpu;
    draw->multiplanes_available = multiplanes_available;
@@ -422,13 +422,13 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
       unsigned char adaptive_sync = 0;
       unsigned char block_on_depleted_buffers = 0;
 
-      draw->ext->config->configQueryb(draw->dri_screen,
+      draw->ext->config->configQueryb(draw->dri_screen_render_gpu,
                                       "adaptive_sync",
                                       &adaptive_sync);
 
       draw->adaptive_sync = adaptive_sync;
 
-      draw->ext->config->configQueryb(draw->dri_screen,
+      draw->ext->config->configQueryb(draw->dri_screen_render_gpu,
                                       "block_on_depleted_buffers",
                                       &block_on_depleted_buffers);
 
@@ -438,14 +438,14 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    if (!draw->adaptive_sync)
       set_adaptive_sync_property(conn, draw->drawable, false);
 
-   draw->swap_interval = dri_get_initial_swap_interval(draw->dri_screen,
+   draw->swap_interval = dri_get_initial_swap_interval(draw->dri_screen_render_gpu,
                                                        draw->ext->config);
 
    dri3_update_max_num_back(draw);
 
    /* Create a new drawable */
    draw->dri_drawable =
-      draw->ext->image_driver->createNewDrawable(dri_screen,
+      draw->ext->image_driver->createNewDrawable(dri_screen_render_gpu,
                                                  dri_config,
                                                  draw);
 
@@ -1418,7 +1418,7 @@ has_supported_modifier(struct loader_dri3_drawable *draw, unsigned int format,
    bool found = false;
    int i, j;
 
-   if (!draw->ext->image->queryDmaBufModifiers(draw->dri_screen,
+   if (!draw->ext->image->queryDmaBufModifiers(draw->dri_screen_render_gpu,
                                                format, 0, NULL, NULL,
                                                &supported_modifiers_count) ||
        supported_modifiers_count == 0)
@@ -1428,7 +1428,7 @@ has_supported_modifier(struct loader_dri3_drawable *draw, unsigned int format,
    if (!supported_modifiers)
       return false;
 
-   draw->ext->image->queryDmaBufModifiers(draw->dri_screen, format,
+   draw->ext->image->queryDmaBufModifiers(draw->dri_screen_render_gpu, format,
                                           supported_modifiers_count,
                                           supported_modifiers, NULL,
                                           &supported_modifiers_count);
@@ -1545,7 +1545,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
          free(mod_reply);
       }
 #endif
-      buffer->image = loader_dri_create_image(draw->dri_screen, draw->ext->image,
+      buffer->image = loader_dri_create_image(draw->dri_screen_render_gpu, draw->ext->image,
                                               width, height, format,
                                               __DRI_IMAGE_USE_SHARE |
                                               __DRI_IMAGE_USE_SCANOUT |
@@ -1560,7 +1560,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
       if (!buffer->image)
          goto no_image;
    } else {
-      buffer->image = draw->ext->image->createImage(draw->dri_screen,
+      buffer->image = draw->ext->image->createImage(draw->dri_screen_render_gpu,
                                                     width, height,
                                                     format,
                                                     0,
@@ -1588,7 +1588,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
 
       if (!pixmap_buffer) {
          buffer->linear_buffer =
-           draw->ext->image->createImage(draw->dri_screen,
+           draw->ext->image->createImage(draw->dri_screen_render_gpu,
                                          width, height,
                                          dri3_linear_format_for_format(draw, format),
                                          __DRI_IMAGE_USE_SHARE |
@@ -1651,7 +1651,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
        */
       if (draw->ext->image->base.version >= 20)
          buffer->linear_buffer =
-            draw->ext->image->createImageFromFds2(draw->dri_screen,
+            draw->ext->image->createImageFromFds2(draw->dri_screen_render_gpu,
                                                   width,
                                                   height,
                                                   loader_image_format_to_fourcc(format),
@@ -1662,7 +1662,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
                                                   buffer);
       else
          buffer->linear_buffer =
-            draw->ext->image->createImageFromFds(draw->dri_screen,
+            draw->ext->image->createImageFromFds(draw->dri_screen_render_gpu,
                                                  width,
                                                  height,
                                                  loader_image_format_to_fourcc(format),
@@ -1995,7 +1995,7 @@ dri3_get_pixmap_buffer(__DRIdrawable *driDrawable, unsigned int format,
     */
    cur_screen = draw->vtable->get_dri_screen();
    if (!cur_screen) {
-       cur_screen = draw->dri_screen;
+       cur_screen = draw->dri_screen_render_gpu;
    }
 
    xcb_dri3_fence_from_fd(draw->conn,
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index 7228855a1261..e6ed3ef022c4 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -138,13 +138,12 @@ struct loader_dri3_drawable {
    enum loader_dri3_drawable_type type;
 
    /* Information about the GPU owning the buffer */
-   __DRIscreen *dri_screen;
-   bool is_different_gpu;
    bool multiplanes_available;
    bool prefer_back_buffer_reuse;
-
+   __DRIscreen *dri_screen_render_gpu;
    /* DRI screen created for display GPU in case of prime */
    __DRIscreen *dri_screen_display_gpu;
+   bool is_different_gpu;
 
    /* SBC numbers are tracked by using the serial numbers
     * in the present request and complete events
@@ -208,7 +207,7 @@ int
 loader_dri3_drawable_init(xcb_connection_t *conn,
                           xcb_drawable_t drawable,
                           enum loader_dri3_drawable_type type,
-                          __DRIscreen *dri_screen,
+                          __DRIscreen *dri_screen_render_gpu,
                           __DRIscreen *dri_screen_display_gpu,
                           bool is_different_gpu,
                           bool is_multiplanes_available,
-- 
GitLab


From 2e12c038963531d4ba20a84047273f1aadc09887 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Sat, 17 Dec 2022 22:51:08 +0530
Subject: [PATCH 10/13] loader,glx,egl,vl,d3d: loader_get_user_preferred_fd()
 function to return original_fd

v1: return original_fd in loader_get_user_preferred_fd() (Pierre-Eric)
v2: fix *original_id crash for android, haiku... (Pierre-Eric)
    remove extra comment (Pierre-Eric)
v2: also return render fd in case of original_fd passed is NULL (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/platform_wayland.c   |  9 +----
 src/egl/drivers/dri2/platform_x11_dri3.c  |  9 +----
 src/gallium/auxiliary/vl/vl_winsys_dri3.c |  2 +-
 src/gallium/targets/d3dadapter9/drm.c     |  2 +-
 src/glx/dri3_glx.c                        |  8 +---
 src/loader/loader.c                       | 46 +++++++++++++----------
 src/loader/loader.h                       | 11 +++---
 7 files changed, 41 insertions(+), 46 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index a1256f00ba74..64a76fd7c436 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2230,13 +2230,8 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
          goto cleanup;
    }
 
-   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
-   dri2_dpy->fd_render_gpu = loader_get_user_preferred_fd(dri2_dpy->fd_render_gpu,
-                                                          &dri2_dpy->is_different_gpu);
-   if (!dri2_dpy->is_different_gpu) {
-      close(dri2_dpy->fd_display_gpu);
-      dri2_dpy->fd_display_gpu = -1;
-   }
+   dri2_dpy->is_different_gpu =
+      loader_get_user_preferred_fd(&dri2_dpy->fd_render_gpu, &dri2_dpy->fd_display_gpu);
 
    dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index a0e6366daffb..947a1a2254ff 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -636,13 +636,8 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
       return EGL_FALSE;
    }
 
-   dri2_dpy->fd_display_gpu = fcntl(dri2_dpy->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
-   dri2_dpy->fd_render_gpu = loader_get_user_preferred_fd(dri2_dpy->fd_render_gpu,
-                                                          &dri2_dpy->is_different_gpu);
-   if (!dri2_dpy->is_different_gpu) {
-      close(dri2_dpy->fd_display_gpu);
-      dri2_dpy->fd_display_gpu = -1;
-   }
+   dri2_dpy->is_different_gpu =
+      loader_get_user_preferred_fd(&dri2_dpy->fd_render_gpu, &dri2_dpy->fd_display_gpu);
 
    dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (!dri2_dpy->driver_name) {
diff --git a/src/gallium/auxiliary/vl/vl_winsys_dri3.c b/src/gallium/auxiliary/vl/vl_winsys_dri3.c
index baa12fa95d07..8d7e6fa9c465 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_dri3.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_dri3.c
@@ -811,7 +811,7 @@ vl_dri3_screen_create(Display *display, int screen)
    fcntl(fd, F_SETFD, FD_CLOEXEC);
    free(open_reply);
 
-   fd = loader_get_user_preferred_fd(fd, &scrn->is_different_gpu);
+   scrn->is_different_gpu = loader_get_user_preferred_fd(&fd, NULL);
 
    geom_cookie = xcb_get_geometry(scrn->conn, RootWindow(display, screen));
    geom_reply = xcb_get_geometry_reply(scrn->conn, geom_cookie, NULL);
diff --git a/src/gallium/targets/d3dadapter9/drm.c b/src/gallium/targets/d3dadapter9/drm.c
index 64873409e2a4..ca7f9abb0c96 100644
--- a/src/gallium/targets/d3dadapter9/drm.c
+++ b/src/gallium/targets/d3dadapter9/drm.c
@@ -230,7 +230,7 @@ drm_create_adapter( int fd,
 
     /* Although the fd is provided from external source, mesa/nine
      * takes ownership of it. */
-    fd = loader_get_user_preferred_fd(fd, &different_device);
+    different_device = loader_get_user_preferred_fd(&fd, NULL);
     ctx->fd = fd;
     ctx->base.linear_framebuffer = different_device;
 
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 2ba768dfa7ae..5195a0b3e103 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -850,12 +850,8 @@ dri3_create_screen(int screen, struct glx_display * priv)
       return NULL;
    }
 
-   psc->fd_display_gpu = fcntl(psc->fd_render_gpu, F_DUPFD_CLOEXEC, 3);
-   psc->fd_render_gpu = loader_get_user_preferred_fd(psc->fd_render_gpu, &psc->is_different_gpu);
-   if (!psc->is_different_gpu) {
-      close(psc->fd_display_gpu);
-      psc->fd_display_gpu = -1;
-   }
+   psc->is_different_gpu =
+      loader_get_user_preferred_fd(&psc->fd_render_gpu, &psc->fd_display_gpu);
 
    driverName = loader_get_driver_for_fd(psc->fd_render_gpu);
    if (!driverName) {
diff --git a/src/loader/loader.c b/src/loader/loader.c
index dd6f837911a2..75968bdcdfc7 100644
--- a/src/loader/loader.c
+++ b/src/loader/loader.c
@@ -325,7 +325,7 @@ static char *drm_get_id_path_tag_for_fd(int fd)
    return tag;
 }
 
-int loader_get_user_preferred_fd(int default_fd, bool *different_device)
+bool loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd)
 {
    const char *dri_prime = getenv("DRI_PRIME");
    char *default_tag, *prime = NULL;
@@ -341,14 +341,12 @@ int loader_get_user_preferred_fd(int default_fd, bool *different_device)
       prime = loader_get_dri_config_device_id();
 #endif
 
-   if (prime == NULL) {
-      *different_device = false;
-      return default_fd;
-   } else {
+   if (prime == NULL)
+      goto no_prime_gpu_offloading;
+   else
       prime_is_vid_did = sscanf(prime, "%hx:%hx", &vendor_id, &device_id) == 2;
-   }
 
-   default_tag = drm_get_id_path_tag_for_fd(default_fd);
+   default_tag = drm_get_id_path_tag_for_fd(*fd_render_gpu);
    if (default_tag == NULL)
       goto err;
 
@@ -394,20 +392,30 @@ int loader_get_user_preferred_fd(int default_fd, bool *different_device)
    if (fd < 0)
       goto err;
 
-   close(default_fd);
-
-   *different_device = !!strcmp(default_tag, prime);
+   bool is_render_and_display_gpu_diff = !!strcmp(default_tag, prime);
+   if (original_fd) {
+      if (is_render_and_display_gpu_diff) {
+         *original_fd = *fd_render_gpu;
+         *fd_render_gpu = fd;
+      } else {
+         *original_fd = *fd_render_gpu;
+         close(fd);
+      }
+   } else {
+      close(*fd_render_gpu);
+      *fd_render_gpu = fd;
+   }
 
    free(default_tag);
    free(prime);
-   return fd;
-
+   return is_render_and_display_gpu_diff;
  err:
-   *different_device = false;
-
    free(default_tag);
    free(prime);
-   return default_fd;
+ no_prime_gpu_offloading:
+   if (original_fd)
+      *original_fd = *fd_render_gpu;
+   return false;
 }
 #else
 int
@@ -422,10 +430,10 @@ loader_get_render_node(dev_t device)
    return NULL;
 }
 
-int loader_get_user_preferred_fd(int default_fd, bool *different_device)
-{
-   *different_device = false;
-   return default_fd;
+bool loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd)
+   if (original_fd)
+      *original_fd = *fd_render_gpu;
+   return false;
 }
 #endif
 
diff --git a/src/loader/loader.h b/src/loader/loader.h
index 68e24a1ec1d2..2480b62d4f38 100644
--- a/src/loader/loader.h
+++ b/src/loader/loader.h
@@ -70,13 +70,14 @@ loader_open_driver(const char *driver_name,
 char *
 loader_get_device_name_for_fd(int fd);
 
-/* Function to get a different device than the one we are to use by default,
- * if the user requests so and it is possible. The initial fd will be closed
- * if necessary. The returned fd is potentially a render-node.
+/* For dri prime gpu offloading this function will take current render fd and possibly
+ * update it with new prime gpu offloading fd. For dri prime gpu offloading optionally
+ * this function can return the original fd. Also this function returns true/false based
+ * on render gpu is different from display gpu.
  */
 
-int
-loader_get_user_preferred_fd(int default_fd, bool *different_device);
+bool
+loader_get_user_preferred_fd(int *fd_render_gpu, int *original_fd);
 
 /* for logging.. keep this aligned with egllog.h so we can just use
  * _eglLog directly.
-- 
GitLab


From da2f32638cc1bcbb8a87db0157445e8af2979ec0 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Sat, 17 Dec 2022 23:17:15 +0530
Subject: [PATCH 11/13] egl: remove is_different_gpu variable from struct
 dri2_egl_display

v2: fd number is different (Pierre-Eric)
v1: remove is_different_gpu (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/egl_dri2.c             | 12 ++++++----
 src/egl/drivers/dri2/egl_dri2.h             | 12 +++++++++-
 src/egl/drivers/dri2/platform_android.c     |  2 ++
 src/egl/drivers/dri2/platform_surfaceless.c |  2 ++
 src/egl/drivers/dri2/platform_wayland.c     | 26 ++++++++++-----------
 src/egl/drivers/dri2/platform_x11.c         |  4 ++--
 src/egl/drivers/dri2/platform_x11_dri3.c    |  7 +++---
 7 files changed, 41 insertions(+), 24 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index ce783c56b0f0..4a2372095f80 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -974,7 +974,7 @@ dri2_create_screen(_EGLDisplay *disp)
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    char *driver_name_display_gpu;
 
-   if (dri2_dpy->fd_display_gpu >= 0) {
+   if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) {
       driver_name_display_gpu = loader_get_driver_for_fd(dri2_dpy->fd_display_gpu);
       if (driver_name_display_gpu) {
          /* check if driver name is matching so that non mesa drivers
@@ -1005,6 +1005,9 @@ dri2_create_screen(_EGLDisplay *disp)
       return EGL_FALSE;
    }
 
+   if (dri2_dpy->fd_render_gpu == dri2_dpy->fd_display_gpu)
+      dri2_dpy->dri_screen_display_gpu = dri2_dpy->dri_screen_render_gpu;
+
    dri2_dpy->own_dri_screen = true;
    return EGL_TRUE;
 }
@@ -1138,13 +1141,14 @@ dri2_display_destroy(_EGLDisplay *disp)
 
       dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_render_gpu);
 
-      if (dri2_dpy->dri_screen_display_gpu)
+      if (dri2_dpy->dri_screen_display_gpu &&
+          dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu)
          dri2_dpy->core->destroyScreen(dri2_dpy->dri_screen_display_gpu);
    }
+   if (dri2_dpy->fd_display_gpu >= 0 &&dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu)
+      close(dri2_dpy->fd_display_gpu);
    if (dri2_dpy->fd_render_gpu >= 0)
       close(dri2_dpy->fd_render_gpu);
-   if (dri2_dpy->fd_display_gpu >= 0)
-      close(dri2_dpy->fd_display_gpu);
 
    /* Don't dlclose the driver when building with the address sanitizer, so you
     * get good symbols from the leak reports.
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index d97371c14b17..c23083634e43 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -223,6 +223,12 @@ struct dri2_egl_display
    int dri2_major;
    int dri2_minor;
    __DRIscreen *dri_screen_render_gpu;
+   /* dri_screen_display_gpu holds display GPU in case of prime gpu offloading else
+    * dri_screen_render_gpu and dri_screen_display_gpu is same.
+    * In case of prime gpu offloading, if display and render driver names are different
+    * (potentially not compatible), dri_screen_display_gpu will be NULL but fd_display_gpu
+    * will still hold fd for display driver.
+    */
    __DRIscreen *dri_screen_display_gpu;
    bool own_dri_screen;
    const __DRIconfig **driver_configs;
@@ -244,7 +250,12 @@ struct dri2_egl_display
    const __DRI2interopExtension *interop;
    const __DRIconfigOptionsExtension *configOptions;
    const __DRImutableRenderBufferDriverExtension *mutable_render_buffer;
+   /* fd of the GPU used for rendering. */
    int fd_render_gpu;
+   /* fd of the GPU used for display. If the same GPU is used for display
+    * and rendering, then fd_render_gpu == fd_display_gpu (no need to use
+    * os_same_file_description).
+    */
    int fd_display_gpu;
 
    /* dri2_initialize/dri2_terminate increment/decrement this count, so does
@@ -304,7 +315,6 @@ struct dri2_egl_display
 #endif
 
    bool is_render_node;
-   bool is_different_gpu;
 };
 
 struct dri2_egl_context
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index 31826736bb68..d326e1c31fec 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -1692,6 +1692,8 @@ dri2_initialize_android(_EGLDisplay *disp)
       goto cleanup;
    }
 
+   dri2_dpy->fd_display_gpu = dri2_dpy->fd_render_gpu;
+
    dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
       err = "DRI2: failed to find EGLDevice";
diff --git a/src/egl/drivers/dri2/platform_surfaceless.c b/src/egl/drivers/dri2/platform_surfaceless.c
index 8f59aa9290cf..15c98ac29fc5 100644
--- a/src/egl/drivers/dri2/platform_surfaceless.c
+++ b/src/egl/drivers/dri2/platform_surfaceless.c
@@ -351,6 +351,8 @@ dri2_initialize_surfaceless(_EGLDisplay *disp)
       goto cleanup;
    }
 
+   dri2_dpy->fd_display_gpu = dri2_dpy->fd_render_gpu;
+
    if (!dri2_create_screen(disp)) {
       err = "DRI2: failed to create screen";
       goto cleanup;
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 64a76fd7c436..e2210a374663 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -939,7 +939,7 @@ create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
                                  dri2_surf->base.Width,
                                  dri2_surf->base.Height,
                                  dri_image_format,
-                                 dri2_dpy->is_different_gpu ? 0 : flags,
+                                 (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) ? 0 : flags,
                                  modifiers, num_modifiers, NULL);
 
       if (dri2_surf->back->dri_image)
@@ -977,7 +977,7 @@ create_dri_image(struct dri2_egl_surface *dri2_surf,
                               dri2_surf->base.Width,
                               dri2_surf->base.Height,
                               dri_image_format,
-                              dri2_dpy->is_different_gpu ? 0 : use_flags,
+                              (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) ? 0 : use_flags,
                               modifiers, num_modifiers, NULL);
 }
 
@@ -1047,12 +1047,13 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
 
    if (dri2_surf->base.ProtectedContent) {
       /* Protected buffers can't be read from another GPU */
-      if (dri2_dpy->is_different_gpu)
+      if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu)
          return -1;
       use_flags |= __DRI_IMAGE_USE_PROTECTED;
    }
 
-   if (dri2_dpy->is_different_gpu && dri2_surf->back->linear_copy == NULL) {
+   if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu &&
+       dri2_surf->back->linear_copy == NULL) {
       uint64_t linear_mod = DRM_FORMAT_MOD_LINEAR;
       __DRIimage *linear_copy_display_gpu_image = NULL;
 
@@ -1223,7 +1224,7 @@ update_buffers(struct dri2_egl_surface *dri2_surf)
           dri2_surf->color_buffers[i].age > BUFFER_TRIM_AGE_HYSTERESIS) {
          wl_buffer_destroy(dri2_surf->color_buffers[i].wl_buffer);
          dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].dri_image);
-         if (dri2_dpy->is_different_gpu)
+         if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu)
             dri2_dpy->image->destroyImage(dri2_surf->color_buffers[i].linear_copy);
          dri2_surf->color_buffers[i].wl_buffer = NULL;
          dri2_surf->color_buffers[i].dri_image = NULL;
@@ -1626,7 +1627,7 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
    if (!dri2_surf->current->wl_buffer) {
       __DRIimage *image;
 
-      if (dri2_dpy->is_different_gpu)
+      if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu)
          image = dri2_surf->current->linear_copy;
       else
          image = dri2_surf->current->dri_image;
@@ -1657,7 +1658,7 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
       wl_surface_damage(dri2_surf->wl_surface_wrapper,
                         0, 0, INT32_MAX, INT32_MAX);
 
-   if (dri2_dpy->is_different_gpu) {
+   if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) {
       _EGLContext *ctx = _eglGetCurrentContext();
       struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
       dri2_dpy->image->blitImage(dri2_ctx->dri_context,
@@ -2098,7 +2099,7 @@ dri2_wl_add_configs_for_visuals(_EGLDisplay *disp)
          }
       }
 
-      if (!assigned && dri2_dpy->is_different_gpu) {
+      if (!assigned && dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) {
          struct dri2_egl_config *dri2_conf;
          int alt_dri_image_format, c, s;
 
@@ -2230,8 +2231,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
          goto cleanup;
    }
 
-   dri2_dpy->is_different_gpu =
-      loader_get_user_preferred_fd(&dri2_dpy->fd_render_gpu, &dri2_dpy->fd_display_gpu);
+   loader_get_user_preferred_fd(&dri2_dpy->fd_render_gpu, &dri2_dpy->fd_display_gpu);
 
    dev = _eglAddDevice(dri2_dpy->fd_render_gpu, false);
    if (!dev) {
@@ -2241,7 +2241,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    disp->Device = dev;
 
-   if (dri2_dpy->is_different_gpu) {
+   if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) {
       free(dri2_dpy->device_name);
       dri2_dpy->device_name = loader_get_device_name_for_fd(dri2_dpy->fd_render_gpu);
       if (!dri2_dpy->device_name) {
@@ -2302,7 +2302,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
       }
    }
 
-   if (dri2_dpy->is_different_gpu &&
+   if (dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu &&
        (dri2_dpy->image->base.version < 9 ||
         dri2_dpy->image->blitImage == NULL)) {
       _eglLog(_EGL_WARNING, "wayland-egl: Different GPU selected, but the "
@@ -2322,7 +2322,7 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
     * because the buffer of the EGLImage has likely a tiling mode the server
     * gpu won't support. These is no way to check for now. Thus do not support the
     * extension */
-   if (!dri2_dpy->is_different_gpu)
+   if (dri2_dpy->fd_render_gpu == dri2_dpy->fd_display_gpu)
       disp->Extensions.WL_create_wayland_buffer_from_image = EGL_TRUE;
 
    disp->Extensions.EXT_buffer_age = EGL_TRUE;
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index f9b82557e087..ba1049964098 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -1489,7 +1489,7 @@ dri2_initialize_x11_swrast(_EGLDisplay *disp)
 #endif
       dri2_dpy->swap_available = EGL_TRUE;
       dri2_x11_setup_swap_interval(disp);
-      if (!dri2_dpy->is_different_gpu)
+      if (dri2_dpy->fd_render_gpu == dri2_dpy->fd_display_gpu)
          disp->Extensions.KHR_image_pixmap = EGL_TRUE;
       disp->Extensions.NOK_texture_from_pixmap = EGL_TRUE;
       disp->Extensions.CHROMIUM_sync_control = EGL_TRUE;
@@ -1575,7 +1575,7 @@ dri2_initialize_x11_dri3(_EGLDisplay *disp)
 
    dri2_x11_setup_swap_interval(disp);
 
-   if (!dri2_dpy->is_different_gpu)
+   if (dri2_dpy->fd_render_gpu == dri2_dpy->fd_display_gpu)
       disp->Extensions.KHR_image_pixmap = EGL_TRUE;
    disp->Extensions.NOK_texture_from_pixmap = EGL_TRUE;
    disp->Extensions.CHROMIUM_sync_control = EGL_TRUE;
diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index 947a1a2254ff..b01eb65f2bb6 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -191,7 +191,7 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
                                  egl_to_loader_dri3_drawable_type(type),
                                  dri2_dpy->dri_screen_render_gpu,
                                  dri2_dpy->dri_screen_display_gpu,
-                                 dri2_dpy->is_different_gpu,
+                                 dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu,
                                  dri2_dpy->multibuffers_available,
                                  true,
                                  dri_config,
@@ -203,7 +203,7 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
    }
 
    if (dri3_surf->surf.base.ProtectedContent &&
-       dri2_dpy->is_different_gpu) {
+       dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu) {
       _eglError(EGL_BAD_ALLOC, "dri3_surface_create");
       goto cleanup_pixmap;
    }
@@ -636,8 +636,7 @@ dri3_x11_connect(struct dri2_egl_display *dri2_dpy)
       return EGL_FALSE;
    }
 
-   dri2_dpy->is_different_gpu =
-      loader_get_user_preferred_fd(&dri2_dpy->fd_render_gpu, &dri2_dpy->fd_display_gpu);
+   loader_get_user_preferred_fd(&dri2_dpy->fd_render_gpu, &dri2_dpy->fd_display_gpu);
 
    dri2_dpy->driver_name = loader_get_driver_for_fd(dri2_dpy->fd_render_gpu);
    if (!dri2_dpy->driver_name) {
-- 
GitLab


From 2c4314b19ec7e44a70b414fb3890721b2995f36e Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Sat, 17 Dec 2022 23:25:20 +0530
Subject: [PATCH 12/13] glx: remove is_different_gpu variable from struct
 dri_screen

v2: fd number is different (Pierre-Eric)
v1: remove is_different_gpu (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/glx/dri3_glx.c  | 37 +++++++++++++++++++------------------
 src/glx/dri3_priv.h | 16 ++++++++++++----
 2 files changed, 31 insertions(+), 22 deletions(-)

diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 5195a0b3e103..39caea24d023 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -394,7 +394,7 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
                                  xDrawable,
                                  glx_to_loader_dri3_drawable_type(type),
                                  psc->driScreenRenderGPU, psc->driScreenDisplayGPU,
-                                 psc->is_different_gpu, has_multibuffer,
+                                 psc->fd_render_gpu != psc->fd_display_gpu, has_multibuffer,
                                  psc->prefer_back_buffer_reuse,
                                  config->driConfig,
                                  &psc->loader_dri3_ext, &glx_dri3_vtable,
@@ -614,13 +614,12 @@ dri3_destroy_screen(struct glx_screen *base)
    struct dri3_screen *psc = (struct dri3_screen *) base;
 
    /* Free the direct rendering per screen data */
-   if (psc->is_different_gpu) {
-      if (psc->driScreenDisplayGPU) {
-         loader_dri3_close_screen(psc->driScreenDisplayGPU);
-         psc->core->destroyScreen(psc->driScreenDisplayGPU);
-      }
-      close(psc->fd_display_gpu);
+   if (psc->fd_render_gpu != psc->fd_display_gpu && psc->driScreenDisplayGPU) {
+      loader_dri3_close_screen(psc->driScreenDisplayGPU);
+      psc->core->destroyScreen(psc->driScreenDisplayGPU);
    }
+   if (psc->fd_render_gpu != psc->fd_display_gpu)
+      close(psc->fd_display_gpu);
    loader_dri3_close_screen(psc->driScreenRenderGPU);
    psc->core->destroyScreen(psc->driScreenRenderGPU);
    driDestroyConfigs(psc->driver_configs);
@@ -764,7 +763,7 @@ dri3_bind_extensions(struct dri3_screen *psc, struct glx_display * priv,
        * can have a tiling mode we can't read. Thus we can't create
        * a texture from them.
        */
-      if (!psc->is_different_gpu &&
+      if (psc->fd_render_gpu == psc->fd_display_gpu &&
          (strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
          psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
          __glXEnableDirectExtension(&psc->base, "GLX_EXT_texture_from_pixmap");
@@ -850,8 +849,7 @@ dri3_create_screen(int screen, struct glx_display * priv)
       return NULL;
    }
 
-   psc->is_different_gpu =
-      loader_get_user_preferred_fd(&psc->fd_render_gpu, &psc->fd_display_gpu);
+   loader_get_user_preferred_fd(&psc->fd_render_gpu, &psc->fd_display_gpu);
 
    driverName = loader_get_driver_for_fd(psc->fd_render_gpu);
    if (!driverName) {
@@ -871,7 +869,7 @@ dri3_create_screen(int screen, struct glx_display * priv)
    if (!loader_bind_extensions(psc, exts, ARRAY_SIZE(exts), extensions))
       goto handle_error;
 
-   if (psc->is_different_gpu) {
+   if (psc->fd_render_gpu != psc->fd_display_gpu) {
       driverNameDisplayGPU = loader_get_driver_for_fd(psc->fd_display_gpu);
       if (driverNameDisplayGPU) {
 
@@ -903,6 +901,9 @@ dri3_create_screen(int screen, struct glx_display * priv)
       goto handle_error;
    }
 
+   if (psc->fd_render_gpu == psc->fd_display_gpu)
+      psc->driScreenDisplayGPU = psc->driScreenRenderGPU;
+
    dri3_bind_extensions(psc, priv, driverName);
 
    if (!psc->image || psc->image->base.version < 7 || !psc->image->createImageFromFds) {
@@ -915,17 +916,17 @@ dri3_create_screen(int screen, struct glx_display * priv)
       goto handle_error;
    }
 
-   if (psc->is_different_gpu && psc->image->base.version < 9) {
+   if (psc->fd_render_gpu != psc->fd_display_gpu && psc->image->base.version < 9) {
       ErrorMessageF("Different GPU, but image extension version 9 or later not found\n");
       goto handle_error;
    }
 
-   if (psc->is_different_gpu && !psc->image->blitImage) {
+   if (psc->fd_render_gpu != psc->fd_display_gpu && !psc->image->blitImage) {
       ErrorMessageF("Different GPU, but blitImage not implemented for this driver\n");
       goto handle_error;
    }
 
-   if (!psc->is_different_gpu && (
+   if (psc->fd_render_gpu == psc->fd_display_gpu && (
        !psc->texBuffer || psc->texBuffer->base.version < 2 ||
        !psc->texBuffer->setTexBuffer2
        )) {
@@ -1024,7 +1025,7 @@ dri3_create_screen(int screen, struct glx_display * priv)
    InfoMessageF("Using DRI3 for screen %d\n", screen);
 
    psc->prefer_back_buffer_reuse = 1;
-   if (psc->is_different_gpu && psc->rendererQuery) {
+   if (psc->fd_render_gpu != psc->fd_display_gpu && psc->rendererQuery) {
       unsigned value;
       if (psc->rendererQuery->queryInteger(psc->driScreenRenderGPU,
                                            __DRI2_RENDERER_PREFER_BACK_BUFFER_REUSE,
@@ -1044,13 +1045,13 @@ handle_error:
    if (psc->driScreenRenderGPU)
        psc->core->destroyScreen(psc->driScreenRenderGPU);
    psc->driScreenRenderGPU = NULL;
-   if (psc->driScreenDisplayGPU)
+   if (psc->fd_render_gpu != psc->fd_display_gpu && psc->driScreenDisplayGPU)
        psc->core->destroyScreen(psc->driScreenDisplayGPU);
    psc->driScreenDisplayGPU = NULL;
+   if (psc->fd_display_gpu >= 0 && psc->fd_render_gpu != psc->fd_display_gpu)
+      close(psc->fd_display_gpu);
    if (psc->fd_render_gpu >= 0)
       close(psc->fd_render_gpu);
-   if (psc->fd_display_gpu >= 0)
-      close(psc->fd_display_gpu);
    if (psc->driver)
       dlclose(psc->driver);
 
diff --git a/src/glx/dri3_priv.h b/src/glx/dri3_priv.h
index 16454638453b..d95534093b86 100644
--- a/src/glx/dri3_priv.h
+++ b/src/glx/dri3_priv.h
@@ -81,14 +81,19 @@ struct dri3_display
 struct dri3_screen {
    struct glx_screen base;
 
-   __DRIscreen *driScreenRenderGPU;
    __GLXDRIscreen vtable;
 
-   /* DRI screen is created for display GPU in case of prime.
+   /* DRI screen is created for display GPU in case of prime gpu offloading.
     * This screen is used to allocate linear_buffer from
     * display GPU space in dri3_alloc_render_buffer() function.
+    * In case of not gpu offloading driScreenDisplayGPU will be assigned with
+    * driScreenRenderGPU.
+    * In case of prime gpu offloading if display and render driver names are different
+    * (potentially not compatible), driScreenDisplayGPU will be NULL but
+    * fd_display_gpu will still hold fd for display driver.
     */
    __DRIscreen *driScreenDisplayGPU;
+   __DRIscreen *driScreenRenderGPU;
 
    const __DRIimageExtension *image;
    const __DRIimageDriverExtension *image_driver;
@@ -102,10 +107,13 @@ struct dri3_screen {
    const __DRIconfig **driver_configs;
 
    void *driver;
+   /* fd of the GPU used for rendering. */
    int fd_render_gpu;
-   /* fd for display GPU in case of prime */
+   /* fd of the GPU used for display. If the same GPU is used for display
+    * and rendering, then fd_render_gpu == fd_display_gpu (no need to use
+    * os_same_file_description).
+    */
    int fd_display_gpu;
-   bool is_different_gpu;
    bool prefer_back_buffer_reuse;
 
    int show_fps_interval;
-- 
GitLab


From 0be88b186dc0f9069b409fcc69b2d8007ca068c2 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Sat, 17 Dec 2022 23:57:50 +0530
Subject: [PATCH 13/13] loader,glx,egl: remove is_different_gpu variable from
 loader

v2: fd number is different (Pierre-Eric)
v1: remove is_different_gpu (Pierre-Eric)
Signed-off-by: Yogesh Mohan Marmithu's avatarYogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/egl/drivers/dri2/platform_x11_dri3.c |  1 -
 src/glx/dri3_glx.c                       |  2 +-
 src/loader/loader_dri3_helper.c          | 27 ++++++++++++------------
 src/loader/loader_dri3_helper.h          |  9 +++++---
 4 files changed, 20 insertions(+), 19 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index b01eb65f2bb6..841ce94aec06 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -191,7 +191,6 @@ dri3_create_surface(_EGLDisplay *disp, EGLint type, _EGLConfig *conf,
                                  egl_to_loader_dri3_drawable_type(type),
                                  dri2_dpy->dri_screen_render_gpu,
                                  dri2_dpy->dri_screen_display_gpu,
-                                 dri2_dpy->fd_render_gpu != dri2_dpy->fd_display_gpu,
                                  dri2_dpy->multibuffers_available,
                                  true,
                                  dri_config,
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 39caea24d023..d59ea6883134 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -394,7 +394,7 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
                                  xDrawable,
                                  glx_to_loader_dri3_drawable_type(type),
                                  psc->driScreenRenderGPU, psc->driScreenDisplayGPU,
-                                 psc->fd_render_gpu != psc->fd_display_gpu, has_multibuffer,
+                                 has_multibuffer,
                                  psc->prefer_back_buffer_reuse,
                                  config->driConfig,
                                  &psc->loader_dri3_ext, &glx_dri3_vtable,
diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index edaa85399b39..ff0719d57beb 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -381,7 +381,6 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
                           enum loader_dri3_drawable_type type,
                           __DRIscreen *dri_screen_render_gpu,
                           __DRIscreen *dri_screen_display_gpu,
-                          bool is_different_gpu,
                           bool multiplanes_available,
                           bool prefer_back_buffer_reuse,
                           const __DRIconfig *dri_config,
@@ -401,7 +400,6 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    draw->region = 0;
    draw->dri_screen_render_gpu = dri_screen_render_gpu;
    draw->dri_screen_display_gpu = dri_screen_display_gpu;
-   draw->is_different_gpu = is_different_gpu;
    draw->multiplanes_available = multiplanes_available;
    draw->prefer_back_buffer_reuse = prefer_back_buffer_reuse;
    draw->queries_buffer_age = false;
@@ -858,7 +856,7 @@ loader_dri3_copy_sub_buffer(struct loader_dri3_drawable *draw,
 
    y = draw->height - y - height;
 
-   if (draw->is_different_gpu) {
+   if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu) {
       /* Update the linear buffer part of the back buffer
        * for the dri3_copy_area operation
        */
@@ -886,7 +884,7 @@ loader_dri3_copy_sub_buffer(struct loader_dri3_drawable *draw,
                                back->image,
                                x, y, width, height,
                                x, y, __BLIT_FLAG_FLUSH) &&
-       !draw->is_different_gpu) {
+       draw->dri_screen_render_gpu == draw->dri_screen_display_gpu) {
       dri3_fence_reset(draw->conn, dri3_front_buffer(draw));
       dri3_copy_area(draw->conn,
                      back->pixmap,
@@ -938,7 +936,7 @@ loader_dri3_wait_x(struct loader_dri3_drawable *draw)
     * Copy back to the tiled buffer we use for rendering.
     * Note that we don't need flushing.
     */
-   if (draw->is_different_gpu)
+   if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu)
       (void) loader_dri3_blit_image(draw,
                                     front->image,
                                     front->linear_buffer,
@@ -959,7 +957,7 @@ loader_dri3_wait_gl(struct loader_dri3_drawable *draw)
    /* In the psc->is_different_gpu case, we update the linear_buffer
     * before updating the real front.
     */
-   if (draw->is_different_gpu)
+   if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu)
       (void) loader_dri3_blit_image(draw,
                                     front->linear_buffer,
                                     front->image,
@@ -1050,7 +1048,7 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
       draw->adaptive_sync_active = true;
    }
 
-   if (draw->is_different_gpu) {
+   if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu) {
       /* Update the linear buffer before presenting the pixmap */
       (void) loader_dri3_blit_image(draw,
                                     back->linear_buffer,
@@ -1191,7 +1189,7 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
        * locally blit back buffer image to it is enough. Otherwise front buffer
        * is a fake one which needs to be synced with pixmap by xserver remotely.
        */
-      if (draw->is_different_gpu ||
+      if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu ||
           !loader_dri3_blit_image(draw,
                                   dri3_front_buffer(draw)->image,
                                   back->image,
@@ -1490,7 +1488,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
    if (!buffer->cpp)
       goto no_image;
 
-   if (!draw->is_different_gpu) {
+   if (draw->dri_screen_render_gpu == draw->dri_screen_display_gpu) {
 #ifdef HAVE_DRI3_MODIFIERS
       if (draw->multiplanes_available &&
           draw->ext->image->base.version >= 15 &&
@@ -1644,8 +1642,8 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int format,
    if (!ret)
       buffer->modifier = DRM_FORMAT_MOD_INVALID;
 
-   if (draw->is_different_gpu && draw->dri_screen_display_gpu &&
-       linear_buffer_display_gpu) {
+   if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu &&
+       draw->dri_screen_display_gpu && linear_buffer_display_gpu) {
       /* The linear buffer was created in the display GPU's vram, so we
        * need to make it visible to render GPU
        */
@@ -1730,7 +1728,7 @@ no_buffer_attrib:
    } while (--i >= 0);
    draw->ext->image->destroyImage(pixmap_buffer);
 no_linear_buffer:
-   if (draw->is_different_gpu)
+   if (draw->dri_screen_render_gpu != draw->dri_screen_display_gpu)
       draw->ext->image->destroyImage(buffer->image);
 no_image:
    free(buffer);
@@ -2287,7 +2285,8 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
        * content will get synced with the fake front
        * buffer.
        */
-      if (draw->type != LOADER_DRI3_DRAWABLE_WINDOW && !draw->is_different_gpu)
+      if (draw->type != LOADER_DRI3_DRAWABLE_WINDOW &&
+          draw->dri_screen_render_gpu == draw->dri_screen_display_gpu)
          front = dri3_get_pixmap_buffer(driDrawable,
                                                format,
                                                loader_dri3_buffer_front,
@@ -2322,7 +2321,7 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
       buffers->image_mask |= __DRI_IMAGE_BUFFER_FRONT;
       buffers->front = front->image;
       draw->have_fake_front =
-         draw->is_different_gpu ||
+         draw->dri_screen_render_gpu != draw->dri_screen_display_gpu ||
          draw->type == LOADER_DRI3_DRAWABLE_WINDOW;
    }
 
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index e6ed3ef022c4..d08753c31e10 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -141,9 +141,13 @@ struct loader_dri3_drawable {
    bool multiplanes_available;
    bool prefer_back_buffer_reuse;
    __DRIscreen *dri_screen_render_gpu;
-   /* DRI screen created for display GPU in case of prime */
+   /* dri_screen_display_gpu holds display GPU in case of prime gpu offloading else
+    * dri_screen_render_gpu and dri_screen_display_gpu is same.
+    * In case of prime gpu offloading, if display and render driver names are different
+    * (potentially not compatible), dri_screen_display_gpu will be NULL but fd_display_gpu
+    * will still hold fd for display driver.
+    */
    __DRIscreen *dri_screen_display_gpu;
-   bool is_different_gpu;
 
    /* SBC numbers are tracked by using the serial numbers
     * in the present request and complete events
@@ -209,7 +213,6 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
                           enum loader_dri3_drawable_type type,
                           __DRIscreen *dri_screen_render_gpu,
                           __DRIscreen *dri_screen_display_gpu,
-                          bool is_different_gpu,
                           bool is_multiplanes_available,
                           bool prefer_back_buffer_reuse,
                           const __DRIconfig *dri_config,
-- 
GitLab

