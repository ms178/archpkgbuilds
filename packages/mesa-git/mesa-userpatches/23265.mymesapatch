From 194b5bc34a0f72ccbd3127dc8df18d8744639d09 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Thu, 25 May 2023 23:11:54 -0700
Subject: [PATCH 1/2] ac, radeonsi: add and use ac_get_ps_iter_mask

It is more natural for ac_get_ps_iter_mask to take sample count.
Replace samplemask_log_ps_iter by ps_iter_smples in
ac_nir_lower_ps_options accordingly.
---
 src/amd/common/ac_nir.h                          |  2 +-
 src/amd/common/ac_nir_lower_ps.c                 | 13 ++-----------
 src/amd/common/ac_shader_util.c                  | 16 ++++++++++++++++
 src/amd/common/ac_shader_util.h                  |  2 ++
 src/gallium/drivers/radeonsi/si_shader.c         |  2 +-
 src/gallium/drivers/radeonsi/si_shader_llvm_ps.c | 11 ++---------
 6 files changed, 24 insertions(+), 22 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index be21bc9e158e..119e575cfb5c 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -293,7 +293,7 @@ typedef struct {
    bool force_linear_sample_interp;
    bool force_persp_center_interp;
    bool force_linear_center_interp;
-   unsigned samplemask_log_ps_iter;
+   unsigned ps_iter_samples;
 
    /* OpenGL only */
    bool clamp_color;
diff --git a/src/amd/common/ac_nir_lower_ps.c b/src/amd/common/ac_nir_lower_ps.c
index 13e8e63895cc..155488aaa337 100644
--- a/src/amd/common/ac_nir_lower_ps.c
+++ b/src/amd/common/ac_nir_lower_ps.c
@@ -248,16 +248,7 @@ lower_ps_load_sample_mask_in(nir_builder *b, nir_intrinsic_instr *intrin, lower_
 
    b->cursor = nir_before_instr(&intrin->instr);
 
-   /* The bit pattern matches that used by fixed function fragment
-    * processing.
-    */
-   static const uint16_t ps_iter_masks[] = {
-      0xffff, /* not used */
-      0x5555, 0x1111, 0x0101, 0x0001,
-   };
-   assert(s->options->samplemask_log_ps_iter < ARRAY_SIZE(ps_iter_masks));
-   uint32_t ps_iter_mask = ps_iter_masks[s->options->samplemask_log_ps_iter];
-
+   uint32_t ps_iter_mask = ac_get_ps_iter_mask(s->options->ps_iter_samples);
    nir_ssa_def *sampleid = nir_load_sample_id(b);
    nir_ssa_def *submask = nir_ishl(b, nir_imm_int(b, ps_iter_mask), sampleid);
 
@@ -290,7 +281,7 @@ lower_ps_intrinsic(nir_builder *b, nir_instr *instr, void *state)
          return lower_ps_load_barycentric(b, intrin, s);
       break;
    case nir_intrinsic_load_sample_mask_in:
-      if (s->options->samplemask_log_ps_iter)
+      if (s->options->ps_iter_samples > 1)
          return lower_ps_load_sample_mask_in(b, intrin, s);
       break;
    default:
diff --git a/src/amd/common/ac_shader_util.c b/src/amd/common/ac_shader_util.c
index e5d4b8734bfc..fbdb0d0e6d4d 100644
--- a/src/amd/common/ac_shader_util.c
+++ b/src/amd/common/ac_shader_util.c
@@ -678,6 +678,22 @@ unsigned ac_get_fs_input_vgpr_cnt(const struct ac_shader_config *config,
    return num_input_vgprs;
 }
 
+uint16_t ac_get_ps_iter_mask(unsigned ps_iter_samples)
+{
+   /* The bit pattern matches that used by fixed function fragment
+    * processing.
+    */
+   switch (ps_iter_samples) {
+   case 1: return 0xffff;
+   case 2: return 0x5555;
+   case 4: return 0x1111;
+   case 8: return 0x0101;
+   case 16: return 0x0001;
+   default:
+      unreachable("invalid sample count");
+   }
+}
+
 void ac_choose_spi_color_formats(unsigned format, unsigned swap, unsigned ntype,
                                  bool is_depth, bool use_rbplus,
                                  struct ac_spi_color_formats *formats)
diff --git a/src/amd/common/ac_shader_util.h b/src/amd/common/ac_shader_util.h
index b06ecd73c2b8..a11debbd8f9d 100644
--- a/src/amd/common/ac_shader_util.h
+++ b/src/amd/common/ac_shader_util.h
@@ -173,6 +173,8 @@ unsigned ac_get_fs_input_vgpr_cnt(const struct ac_shader_config *config,
                                   signed char *face_vgpr_index, signed char *ancillary_vgpr_index,
                                   signed char *sample_coverage_vgpr_index_ptr);
 
+uint16_t ac_get_ps_iter_mask(unsigned ps_iter_samples);
+
 void ac_choose_spi_color_formats(unsigned format, unsigned swap, unsigned ntype,
                                  bool is_depth, bool use_rbplus,
                                  struct ac_spi_color_formats *formats);
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 0eeb9622c5f5..e6b3ac8f4b01 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2239,7 +2239,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader,
          .force_linear_sample_interp = key->ps.part.prolog.force_linear_sample_interp,
          .force_persp_center_interp = key->ps.part.prolog.force_persp_center_interp,
          .force_linear_center_interp = key->ps.part.prolog.force_linear_center_interp,
-         .samplemask_log_ps_iter = key->ps.part.prolog.samplemask_log_ps_iter,
+         .ps_iter_samples = 1 << key->ps.part.prolog.samplemask_log_ps_iter,
       };
 
       NIR_PASS_V(nir, ac_nir_lower_ps, &options);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index 30334bdab26e..6bbe7c248dfc 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -687,15 +687,8 @@ void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part
     * entire pixel/fragment, so mask bits out based on the sample ID.
     */
    if (key->ps_prolog.states.samplemask_log_ps_iter) {
-      /* The bit pattern matches that used by fixed function fragment
-       * processing. */
-      static const uint16_t ps_iter_masks[] = {
-         0xffff, /* not used */
-         0x5555, 0x1111, 0x0101, 0x0001,
-      };
-      assert(key->ps_prolog.states.samplemask_log_ps_iter < ARRAY_SIZE(ps_iter_masks));
-
-      uint32_t ps_iter_mask = ps_iter_masks[key->ps_prolog.states.samplemask_log_ps_iter];
+      uint32_t ps_iter_mask =
+         ac_get_ps_iter_mask(1 << key->ps_prolog.states.samplemask_log_ps_iter);
       LLVMValueRef sampleid = si_unpack_param(ctx, ancillary, 8, 4);
       LLVMValueRef samplemask = ac_get_arg(&ctx->ac, param_sample_mask);
 
-- 
GitLab


From 73087d399e528941cfc5ee2a0f3df05b85de91c8 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Thu, 25 May 2023 22:36:51 -0700
Subject: [PATCH 2/2] radv: fix gl_SampleMaskIn for sample shading

When sample shading, we need

  gl_SampleMaskIn = SampleCoverage & (PsIterMask << gl_SampleID);

Add a new shader arg, ps_iter_mask, to pass PsIterMask to ps.
---
 .../vulkan/nir/radv_nir_lower_fs_intrinsics.c |  6 ++++--
 src/amd/vulkan/radv_cmd_buffer.c              | 19 ++++++++++++-------
 src/amd/vulkan/radv_shader.h                  |  1 +
 src/amd/vulkan/radv_shader_args.c             |  4 ++++
 src/amd/vulkan/radv_shader_args.h             |  1 +
 5 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/src/amd/vulkan/nir/radv_nir_lower_fs_intrinsics.c b/src/amd/vulkan/nir/radv_nir_lower_fs_intrinsics.c
index 136ae2ae3fc1..ccff0897051e 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_fs_intrinsics.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_fs_intrinsics.c
@@ -55,9 +55,11 @@ radv_nir_lower_fs_intrinsics(nir_shader *nir, const struct radv_pipeline_stage *
 
             nir_ssa_def *def = NULL;
             if (info->ps.uses_sample_shading || key->ps.sample_shading_enable) {
-               /* gl_SampleMaskIn[0] = (SampleCoverage & (1 << gl_SampleID)). */
+               /* gl_SampleMaskIn[0] = (SampleCoverage & (PsIterMask << gl_SampleID)). */
+               nir_ssa_def *ps_iter_mask =
+                  nir_load_scalar_arg_amd(&b, 1, .base = args->ps_iter_mask.arg_index);
                nir_ssa_def *sample_id = nir_load_sample_id(&b);
-               def = nir_iand(&b, sample_coverage, nir_ishl(&b, nir_imm_int(&b, 1u), sample_id));
+               def = nir_iand(&b, sample_coverage, nir_ishl(&b, ps_iter_mask, sample_id));
             } else {
                def = sample_coverage;
             }
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d6cabfbf26a8..e74f10e4a5c0 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2658,6 +2658,7 @@ radv_emit_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
    const struct radv_physical_device *pdevice = cmd_buffer->device->physical_device;
    const struct radv_shader *ps = cmd_buffer->state.shaders[MESA_SHADER_FRAGMENT];
    unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+   unsigned ps_iter_samples = radv_get_ps_iter_samples(cmd_buffer);
    const struct radv_rendering_state *render = &cmd_buffer->state.render;
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
    unsigned spi_baryc_cntl = S_0286E0_FRONT_FACE_ALL_BITS(1);
@@ -2682,13 +2683,9 @@ radv_emit_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
    if (!d->sample_location.count)
       radv_emit_default_sample_locations(cmd_buffer->cs, rasterization_samples);
 
-   if (rasterization_samples > 1) {
-      unsigned ps_iter_samples = radv_get_ps_iter_samples(cmd_buffer);
-
-      if (ps_iter_samples > 1) {
-         spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
-         pa_sc_mode_cntl_1 |= S_028A4C_PS_ITER_SAMPLE(1);
-      }
+   if (ps_iter_samples > 1) {
+      spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
+      pa_sc_mode_cntl_1 |= S_028A4C_PS_ITER_SAMPLE(1);
    }
 
    if (pdevice->rad_info.gfx_level >= GFX10_3 &&
@@ -2739,6 +2736,14 @@ radv_emit_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
          uint32_t base_reg = cmd_buffer->state.shaders[MESA_SHADER_FRAGMENT]->info.user_data_0;
          radeon_set_sh_reg(cmd_buffer->cs, base_reg + loc->sgpr_idx * 4, rasterization_samples);
       }
+
+      loc =
+         radv_get_user_sgpr(cmd_buffer->state.shaders[MESA_SHADER_FRAGMENT], AC_UD_PS_ITER_MASK);
+      if (loc->sgpr_idx != -1) {
+         const uint16_t ps_iter_mask = ac_get_ps_iter_mask(ps_iter_samples);
+         uint32_t base_reg = cmd_buffer->state.shaders[MESA_SHADER_FRAGMENT]->info.user_data_0;
+         radeon_set_sh_reg(cmd_buffer->cs, base_reg + loc->sgpr_idx * 4, ps_iter_mask);
+      }
    }
 }
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 5e893e574699..f31d23424d00 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -170,6 +170,7 @@ enum radv_ud_index {
    AC_UD_PS_EPILOG_PC,
    AC_UD_PS_NUM_SAMPLES,
    AC_UD_PS_LINE_RAST_MODE,
+   AC_UD_PS_ITER_MASK,
    AC_UD_PS_MAX_UD,
    AC_UD_CS_GRID_SIZE = AC_UD_SHADER_START,
    AC_UD_CS_SBT_DESCRIPTORS,
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index dfe11e9aa2b9..f257a182ff50 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -647,6 +647,10 @@ declare_shader_args(const struct radv_device *device, const struct radv_pipeline
       if (key->dynamic_line_rast_mode)
          add_ud_arg(args, 1, AC_ARG_INT, &args->ps_line_rast_mode, AC_UD_PS_LINE_RAST_MODE);
 
+      if (info->ps.reads_sample_mask_in && (info->ps.uses_sample_shading ||
+                                            key->ps.sample_shading_enable))
+         add_ud_arg(args, 1, AC_ARG_INT, &args->ps_iter_mask, AC_UD_PS_ITER_MASK);
+
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.prim_mask);
       if (args->explicit_scratch_args && gfx_level < GFX11) {
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
diff --git a/src/amd/vulkan/radv_shader_args.h b/src/amd/vulkan/radv_shader_args.h
index 49928b63986b..3095b7dfe328 100644
--- a/src/amd/vulkan/radv_shader_args.h
+++ b/src/amd/vulkan/radv_shader_args.h
@@ -61,6 +61,7 @@ struct radv_shader_args {
    struct ac_arg ps_epilog_pc;
    struct ac_arg ps_num_samples;
    struct ac_arg ps_line_rast_mode;
+   struct ac_arg ps_iter_mask;
 
    struct ac_arg prolog_inputs;
    struct ac_arg vs_inputs[MAX_VERTEX_ATTRIBS];
-- 
GitLab

