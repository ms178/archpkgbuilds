From e7a1c3799bcc9943816596c511bf413b6ef498d8 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 27 Oct 2025 16:32:42 +0100
Subject: [PATCH 1/3] ac/surface,radv: add RADEON_SURF_VIEW_3D_AS_2D_ARRAY

Only compatible with non-sparse 3D images.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/common/ac_surface.c | 9 +++++++++
 src/amd/common/ac_surface.h | 1 +
 src/amd/vulkan/radv_image.c | 3 +++
 3 files changed, 13 insertions(+)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 4ecc085fa0e3b..03ea97572475c 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -1532,6 +1532,9 @@ static int gfx6_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
                if (!modes[i].supported)
                   continue;
 
+               if (modes[i].align_depth > 1 && surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY)
+                  continue;
+
                uint64_t size = ac_estimate_size(config, surf->blk_w, surf->blk_h, surf->bpe * 8,
                                                 config->info.width, config->info.height,
                                                 modes[i].align_width, modes[i].align_height,
@@ -2695,6 +2698,9 @@ static int gfx9_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
    AddrSurfInfoIn.flags.prt = (surf->flags & RADEON_SURF_PRT) != 0 &&
                               (config->info.samples <= 1 || info->gfx_level < GFX10) &&
                               is_color_surface;
+   /* Only compatible with non-sparse because 3D sparse requires 3D tiling. */
+   AddrSurfInfoIn.flags.view3dAs2dArray = !AddrSurfInfoIn.flags.prt &&
+                                          (surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY) != 0;
 
    AddrSurfInfoIn.numMipLevels = config->info.levels;
    AddrSurfInfoIn.numSamples = MAX2(1, config->info.samples);
@@ -3483,6 +3489,9 @@ static bool gfx12_compute_surface(struct ac_addrlib *addrlib, const struct radeo
    AddrSurfInfoIn.flags.blockCompressed = compressed;
    AddrSurfInfoIn.flags.isVrsImage = !!(surf->flags & RADEON_SURF_VRS_RATE);
    AddrSurfInfoIn.flags.standardPrt = !!(surf->flags & RADEON_SURF_PRT);
+   /* Only compatible with non-sparse because 3D sparse requires 3D tiling. */
+   AddrSurfInfoIn.flags.view3dAs2dArray = !AddrSurfInfoIn.flags.standardPrt &&
+                                          (surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY) != 0;
 
    if (config->is_3d)
       AddrSurfInfoIn.resourceType = ADDR_RSRC_TEX_3D;
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index c3bda8b75a2a7..f46c86e91430a 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -79,6 +79,7 @@ enum radeon_micro_mode
 #define RADEON_SURF_ENCODE_SRC            (1ull << 41)
 #define RADEON_SURF_ALIASED               (1ull << 42)
 #define RADEON_SURF_REPLAYABLE            (1ull << 43)
+#define RADEON_SURF_VIEW_3D_AS_2D_ARRAY   (1ull << 44)
 
 struct legacy_surf_level {
    uint32_t offset_256B;   /* divided by 256, the hw can only do 40-bit addresses */
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 88ca30fb33673..d940d20dc51df 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -659,6 +659,9 @@ radv_get_surface_flags(struct radv_device *device, struct radv_image *image, uns
       UNREACHABLE("unhandled image type");
    }
 
+   if (image->vk.create_flags & (VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT | VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT))
+      flags |= RADEON_SURF_VIEW_3D_AS_2D_ARRAY;
+
    /* Required for clearing/initializing a specific layer on GFX8. */
    flags |= RADEON_SURF_CONTIGUOUS_DCC_LAYERS;
 
-- 
GitLab


From 7e280eaf7de8e1df2a1333b3e9db012b63d77ff4 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 29 Oct 2025 08:18:53 +0100
Subject: [PATCH 2/3] ac/surface,radv: add RADEON_SURF_CB_RENDER_TARGET

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/common/ac_surface.h | 1 +
 src/amd/vulkan/radv_image.c | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index f46c86e91430a..573089ae94310 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -80,6 +80,7 @@ enum radeon_micro_mode
 #define RADEON_SURF_ALIASED               (1ull << 42)
 #define RADEON_SURF_REPLAYABLE            (1ull << 43)
 #define RADEON_SURF_VIEW_3D_AS_2D_ARRAY   (1ull << 44)
+#define RADEON_SURF_CB_RENDER_TARGET      (1ull << 45)
 
 struct legacy_surf_level {
    uint32_t offset_256B;   /* divided by 256, the hw can only do 40-bit addresses */
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index d940d20dc51df..2d734ca81bbae 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -662,6 +662,9 @@ radv_get_surface_flags(struct radv_device *device, struct radv_image *image, uns
    if (image->vk.create_flags & (VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT | VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT))
       flags |= RADEON_SURF_VIEW_3D_AS_2D_ARRAY;
 
+   if (image->vk.usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
+      flags |= RADEON_SURF_CB_RENDER_TARGET;
+
    /* Required for clearing/initializing a specific layer on GFX8. */
    flags |= RADEON_SURF_CONTIGUOUS_DCC_LAYERS;
 
-- 
GitLab


From 0d58e25b6f841584eb4cb8c7fe971eb9448d86e4 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 27 Oct 2025 19:41:16 +0100
Subject: [PATCH 3/3] ac/surface: use 2D swizzle modes for 3D CB render targets

Much faster because CB is optimal with 2D swizzle modes.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/common/ac_surface.c | 59 +++++++++++++++++++++++++++++--------
 1 file changed, 46 insertions(+), 13 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 03ea97572475c..bc91fa8785eee 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -1532,7 +1532,11 @@ static int gfx6_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
                if (!modes[i].supported)
                   continue;
 
-               if (modes[i].align_depth > 1 && surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY)
+               /* 2D swizzle modes are optimal for 2D compatible images or 3D
+                * CB render targets.
+                */
+               if (modes[i].align_depth > 1 &&
+                   surf->flags & (RADEON_SURF_VIEW_3D_AS_2D_ARRAY | RADEON_SURF_CB_RENDER_TARGET))
                   continue;
 
                uint64_t size = ac_estimate_size(config, surf->blk_w, surf->blk_h, surf->bpe * 8,
@@ -2674,6 +2678,13 @@ static int gfx9_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
                                 const struct ac_surf_config *config, enum radeon_surf_mode mode,
                                 struct radeon_surf *surf)
 {
+   bool is_color_surface = !(surf->flags & RADEON_SURF_Z_OR_SBUFFER);
+   bool is_cb_render_target = !!(surf->flags & RADEON_SURF_CB_RENDER_TARGET);
+   /* For GFX10+ MSAA PRT surface won't use the prt flag because it's not supported. */
+   bool is_prt_surface = (surf->flags & RADEON_SURF_PRT) != 0 &&
+                         (config->info.samples <= 1 || info->gfx_level < GFX10) &&
+                         is_color_surface;
+   bool view3dAs2dArray = false;
    bool compressed;
    ADDR2_COMPUTE_SURFACE_INFO_INPUT AddrSurfInfoIn = {0};
    int r;
@@ -2686,7 +2697,19 @@ static int gfx9_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
    if (!compressed)
       AddrSurfInfoIn.bpp = surf->bpe * 8;
 
-   bool is_color_surface = !(surf->flags & RADEON_SURF_Z_OR_SBUFFER);
+   /* Only compatible with non-sparse because 3D sparse requires 3D tiling. */
+   if (!is_prt_surface) {
+      /* Try to select a better swizzle for 2D compatible images. */
+      if (surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY)
+         view3dAs2dArray = true;
+
+      /* 2D swizzle modes for 3D CB render targets are optimal regardless of
+       * the access pattern because CB prefers thin tiling.
+       */
+      if (config->is_3d && is_cb_render_target)
+         view3dAs2dArray = true;
+   }
+
    AddrSurfInfoIn.flags.color = is_color_surface && !(surf->flags & RADEON_SURF_NO_RENDER_TARGET);
    AddrSurfInfoIn.flags.depth = (surf->flags & RADEON_SURF_ZBUFFER) != 0;
    AddrSurfInfoIn.flags.display = get_display_flag(config, surf);
@@ -2694,13 +2717,8 @@ static int gfx9_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
    AddrSurfInfoIn.flags.texture = (is_color_surface && !(surf->flags & RADEON_SURF_NO_TEXTURE)) ||
                                   (surf->flags & RADEON_SURF_TC_COMPATIBLE_HTILE);
    AddrSurfInfoIn.flags.opt4space = 1;
-   /* For GFX10+ MSAA PRT surface won't use the prt flag because it's not supported. */
-   AddrSurfInfoIn.flags.prt = (surf->flags & RADEON_SURF_PRT) != 0 &&
-                              (config->info.samples <= 1 || info->gfx_level < GFX10) &&
-                              is_color_surface;
-   /* Only compatible with non-sparse because 3D sparse requires 3D tiling. */
-   AddrSurfInfoIn.flags.view3dAs2dArray = !AddrSurfInfoIn.flags.prt &&
-                                          (surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY) != 0;
+   AddrSurfInfoIn.flags.prt = is_prt_surface;
+   AddrSurfInfoIn.flags.view3dAs2dArray = view3dAs2dArray;
 
    AddrSurfInfoIn.numMipLevels = config->info.levels;
    AddrSurfInfoIn.numSamples = MAX2(1, config->info.samples);
@@ -3471,6 +3489,10 @@ static bool gfx12_compute_surface(struct ac_addrlib *addrlib, const struct radeo
 {
    bool compressed = surf->blk_w == 4 && surf->blk_h == 4;
    bool stencil_only = (surf->flags & RADEON_SURF_SBUFFER) && !(surf->flags & RADEON_SURF_ZBUFFER);
+   bool is_cb_render_target = !!(surf->flags & RADEON_SURF_CB_RENDER_TARGET);
+   bool is_prt_surface = !!(surf->flags & RADEON_SURF_PRT);
+   bool view3dAs2dArray = false;
+
    ADDR3_COMPUTE_SURFACE_INFO_INPUT AddrSurfInfoIn = {0};
 
    AddrSurfInfoIn.size = sizeof(ADDR3_COMPUTE_SURFACE_INFO_INPUT);
@@ -3484,14 +3506,25 @@ static bool gfx12_compute_surface(struct ac_addrlib *addrlib, const struct radeo
          AddrSurfInfoIn.bpp = surf->bpe * 8;
    }
 
+   /* Only compatible with non-sparse because 3D sparse requires 3D tiling. */
+   if (!is_prt_surface) {
+      /* Try to select a better swizzle for 2D compatible images. */
+      if (surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY)
+         view3dAs2dArray = true;
+
+      /* 2D swizzle modes for 3D CB render targets are optimal regardless of
+       * the access pattern because CB prefers thin tiling.
+       */
+      if (config->is_3d && is_cb_render_target)
+         view3dAs2dArray = true;
+   }
+
    AddrSurfInfoIn.flags.depth = !!(surf->flags & RADEON_SURF_ZBUFFER);
    AddrSurfInfoIn.flags.stencil = stencil_only;
    AddrSurfInfoIn.flags.blockCompressed = compressed;
    AddrSurfInfoIn.flags.isVrsImage = !!(surf->flags & RADEON_SURF_VRS_RATE);
-   AddrSurfInfoIn.flags.standardPrt = !!(surf->flags & RADEON_SURF_PRT);
-   /* Only compatible with non-sparse because 3D sparse requires 3D tiling. */
-   AddrSurfInfoIn.flags.view3dAs2dArray = !AddrSurfInfoIn.flags.standardPrt &&
-                                          (surf->flags & RADEON_SURF_VIEW_3D_AS_2D_ARRAY) != 0;
+   AddrSurfInfoIn.flags.standardPrt = is_prt_surface;
+   AddrSurfInfoIn.flags.view3dAs2dArray = view3dAs2dArray;
 
    if (config->is_3d)
       AddrSurfInfoIn.resourceType = ADDR_RSRC_TEX_3D;
-- 
GitLab

