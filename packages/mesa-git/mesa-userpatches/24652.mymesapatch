From 9c3f36202c4f683da2836f7fdfb5bf39138f0872 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Tue, 15 Aug 2023 14:55:10 +0200
Subject: [PATCH] aco/spill: Make sure that offset stays in bounds

If a shader spills a lot, the offset can be above the HW limit.

cc: mesa-stable
---
 src/amd/compiler/aco_spill.cpp | 124 +++++++++++++++++++--------------
 1 file changed, 72 insertions(+), 52 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 93b7c97525249..78dcf4d8532e2 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -1397,32 +1397,8 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
 }
 
 Temp
-load_scratch_resource(spill_ctx& ctx, Temp& scratch_offset, Block& block,
-                      std::vector<aco_ptr<Instruction>>& instructions, unsigned offset)
+load_scratch_resource(spill_ctx& ctx, Builder& bld)
 {
-   Builder bld(ctx.program);
-   if (block.kind & block_kind_top_level) {
-      bld.reset(&instructions);
-   } else {
-      for (int block_idx = block.index; block_idx >= 0; block_idx--) {
-         if (!(ctx.program->blocks[block_idx].kind & block_kind_top_level))
-            continue;
-
-         /* find p_logical_end */
-         std::vector<aco_ptr<Instruction>>& prev_instructions =
-            ctx.program->blocks[block_idx].instructions;
-         unsigned idx = prev_instructions.size() - 1;
-         while (prev_instructions[idx]->opcode != aco_opcode::p_logical_end)
-            idx--;
-         bld.reset(&prev_instructions, std::next(prev_instructions.begin(), idx));
-         break;
-      }
-   }
-
-   /* GFX9+ uses scratch_* instructions, which don't use a resource. Return a SADDR instead. */
-   if (ctx.program->gfx_level >= GFX9)
-      return bld.copy(bld.def(s1), Operand::c32(offset));
-
    Temp private_segment_buffer = ctx.program->private_segment_buffer;
    if (!private_segment_buffer.bytes()) {
       Temp addr_lo =
@@ -1436,10 +1412,6 @@ load_scratch_resource(spill_ctx& ctx, Temp& scratch_offset, Block& block,
          bld.smem(aco_opcode::s_load_dwordx2, bld.def(s2), private_segment_buffer, Operand::zero());
    }
 
-   if (offset)
-      scratch_offset = bld.sop2(aco_opcode::s_add_u32, bld.def(s1), bld.def(s1, scc),
-                                scratch_offset, Operand::c32(offset));
-
    uint32_t rsrc_conf =
       S_008F0C_ADD_TID_ENABLE(1) | S_008F0C_INDEX_STRIDE(ctx.program->wave_size == 64 ? 3 : 2);
 
@@ -1463,33 +1435,78 @@ load_scratch_resource(spill_ctx& ctx, Temp& scratch_offset, Block& block,
 void
 setup_vgpr_spill_reload(spill_ctx& ctx, Block& block,
                         std::vector<aco_ptr<Instruction>>& instructions, uint32_t spill_slot,
-                        unsigned* offset)
+                        uint32_t spill_count, Temp& scratch_offset, unsigned* offset)
 {
-   Temp scratch_offset = ctx.program->scratch_offset;
+   Builder rsrc_bld(ctx.program);
+   if (block.kind & block_kind_top_level) {
+      rsrc_bld.reset(&instructions);
+   } else {
+      for (int block_idx = block.index; block_idx >= 0; block_idx--) {
+         if (!(ctx.program->blocks[block_idx].kind & block_kind_top_level))
+            continue;
+
+         /* find p_logical_end */
+         std::vector<aco_ptr<Instruction>>& prev_instructions =
+            ctx.program->blocks[block_idx].instructions;
+         unsigned idx = prev_instructions.size() - 1;
+         while (prev_instructions[idx]->opcode != aco_opcode::p_logical_end)
+            idx--;
+         rsrc_bld.reset(&prev_instructions, std::next(prev_instructions.begin(), idx));
+         break;
+      }
+   }
+
+   uint32_t offset_range = 4096;
+   if (ctx.program->gfx_level >= GFX9)
+      offset_range =
+         ctx.program->dev.scratch_global_offset_max - ctx.program->dev.scratch_global_offset_min;
+
+   /* If spilling overflows the constant offset range at any point, we need to emit the soffset
+    * before every spill/reload to avoid increasing register demand.
+    */
+   bool overflow = (ctx.vgpr_spill_slots - 1) * 4 > offset_range;
+   Builder offset_bld = rsrc_bld;
+   if (overflow)
+      offset_bld.reset(&instructions);
 
    *offset = spill_slot * 4;
    if (ctx.program->gfx_level >= GFX9) {
       *offset += ctx.program->dev.scratch_global_offset_min;
 
-      if (ctx.scratch_rsrc == Temp()) {
+      if (ctx.scratch_rsrc == Temp() || overflow) {
          int32_t saddr = ctx.program->config->scratch_bytes_per_wave / ctx.program->wave_size -
                          ctx.program->dev.scratch_global_offset_min;
-         ctx.scratch_rsrc = load_scratch_resource(ctx, scratch_offset, block, instructions, saddr);
+
+         if ((int32_t)*offset > (int32_t)ctx.program->dev.scratch_global_offset_max) {
+            saddr += (int32_t)*offset;
+            *offset = 0;
+         }
+
+         /* GFX9+ uses scratch_* instructions, which don't use a resource. */
+         ctx.scratch_rsrc = offset_bld.copy(offset_bld.def(s1), Operand::c32(saddr));
       }
    } else {
       bool add_offset_to_sgpr =
          ctx.program->config->scratch_bytes_per_wave / ctx.program->wave_size +
             ctx.vgpr_spill_slots * 4 >
          4096;
-      if (!add_offset_to_sgpr)
-         *offset += ctx.program->config->scratch_bytes_per_wave / ctx.program->wave_size;
 
-      if (ctx.scratch_rsrc == Temp()) {
-         unsigned rsrc_offset =
-            add_offset_to_sgpr ? ctx.program->config->scratch_bytes_per_wave : 0;
-         ctx.scratch_rsrc =
-            load_scratch_resource(ctx, scratch_offset, block, instructions, rsrc_offset);
+      if (add_offset_to_sgpr || overflow) {
+         uint32_t soffset = ctx.program->config->scratch_bytes_per_wave;
+         if (*offset > 4096) {
+            soffset += *offset;
+            *offset = 0;
+         }
+
+         scratch_offset =
+            offset_bld.sop2(aco_opcode::s_add_u32, offset_bld.def(s1), offset_bld.def(s1, scc),
+                            scratch_offset, Operand::c32(soffset));
+      } else {
+         *offset += ctx.program->config->scratch_bytes_per_wave / ctx.program->wave_size;
       }
+
+      if (ctx.scratch_rsrc == Temp())
+         ctx.scratch_rsrc = load_scratch_resource(ctx, rsrc_bld);
    }
 }
 
@@ -1502,13 +1519,15 @@ spill_vgpr(spill_ctx& ctx, Block& block, std::vector<aco_ptr<Instruction>>& inst
    uint32_t spill_id = spill->operands[1].constantValue();
    uint32_t spill_slot = slots[spill_id];
 
-   unsigned offset;
-   setup_vgpr_spill_reload(ctx, block, instructions, spill_slot, &offset);
-
    assert(spill->operands[0].isTemp());
    Temp temp = spill->operands[0].getTemp();
    assert(temp.type() == RegType::vgpr && !temp.is_linear());
 
+   Temp scratch_offset = ctx.program->scratch_offset;
+   unsigned offset;
+   setup_vgpr_spill_reload(ctx, block, instructions, spill_slot, temp.size(), scratch_offset,
+                           &offset);
+
    Builder bld(ctx.program, &instructions);
    if (temp.size() > 1) {
       Instruction* split{create_instruction<Pseudo_instruction>(aco_opcode::p_split_vector,
@@ -1523,9 +1542,8 @@ spill_vgpr(spill_ctx& ctx, Block& block, std::vector<aco_ptr<Instruction>>& inst
             bld.scratch(aco_opcode::scratch_store_dword, Operand(v1), ctx.scratch_rsrc, elem,
                         offset, memory_sync_info(storage_vgpr_spill, semantic_private));
          } else {
-            Instruction* instr =
-               bld.mubuf(aco_opcode::buffer_store_dword, ctx.scratch_rsrc, Operand(v1),
-                         ctx.program->scratch_offset, elem, offset, false, true);
+            Instruction* instr = bld.mubuf(aco_opcode::buffer_store_dword, ctx.scratch_rsrc,
+                                           Operand(v1), scratch_offset, elem, offset, false, true);
             instr->mubuf().sync = memory_sync_info(storage_vgpr_spill, semantic_private);
          }
       }
@@ -1534,7 +1552,7 @@ spill_vgpr(spill_ctx& ctx, Block& block, std::vector<aco_ptr<Instruction>>& inst
                   memory_sync_info(storage_vgpr_spill, semantic_private));
    } else {
       Instruction* instr = bld.mubuf(aco_opcode::buffer_store_dword, ctx.scratch_rsrc, Operand(v1),
-                                     ctx.program->scratch_offset, temp, offset, false, true);
+                                     scratch_offset, temp, offset, false, true);
       instr->mubuf().sync = memory_sync_info(storage_vgpr_spill, semantic_private);
    }
 }
@@ -1546,11 +1564,13 @@ reload_vgpr(spill_ctx& ctx, Block& block, std::vector<aco_ptr<Instruction>>& ins
    uint32_t spill_id = reload->operands[0].constantValue();
    uint32_t spill_slot = slots[spill_id];
 
-   unsigned offset;
-   setup_vgpr_spill_reload(ctx, block, instructions, spill_slot, &offset);
-
    Definition def = reload->definitions[0];
 
+   Temp scratch_offset = ctx.program->scratch_offset;
+   unsigned offset;
+   setup_vgpr_spill_reload(ctx, block, instructions, spill_slot, def.size(), scratch_offset,
+                           &offset);
+
    Builder bld(ctx.program, &instructions);
    if (def.size() > 1) {
       Instruction* vec{create_instruction<Pseudo_instruction>(aco_opcode::p_create_vector,
@@ -1566,7 +1586,7 @@ reload_vgpr(spill_ctx& ctx, Block& block, std::vector<aco_ptr<Instruction>>& ins
          } else {
             Instruction* instr =
                bld.mubuf(aco_opcode::buffer_load_dword, Definition(tmp), ctx.scratch_rsrc,
-                         Operand(v1), ctx.program->scratch_offset, offset, false, true);
+                         Operand(v1), scratch_offset, offset, false, true);
             instr->mubuf().sync = memory_sync_info(storage_vgpr_spill, semantic_private);
          }
       }
@@ -1576,7 +1596,7 @@ reload_vgpr(spill_ctx& ctx, Block& block, std::vector<aco_ptr<Instruction>>& ins
                   memory_sync_info(storage_vgpr_spill, semantic_private));
    } else {
       Instruction* instr = bld.mubuf(aco_opcode::buffer_load_dword, def, ctx.scratch_rsrc,
-                                     Operand(v1), ctx.program->scratch_offset, offset, false, true);
+                                     Operand(v1), scratch_offset, offset, false, true);
       instr->mubuf().sync = memory_sync_info(storage_vgpr_spill, semantic_private);
    }
 }
-- 
GitLab

