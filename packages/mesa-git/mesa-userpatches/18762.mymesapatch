From 15961960ed732f47dcd98304a9009be360e30ed4 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 22 Sep 2022 13:44:19 -0400
Subject: [PATCH 2/3] egl: Invalidate ancillary buffers on eglSwapBuffers

This is a little uglier than I hoped, I could cheat and use the DSA
version even in GLES but you'd still need to call it twice if read/draw
are different, and there's no knowing that without the GetIntegerv...

Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 src/egl/main/eglapi.c     | 52 +++++++++++++++++++++++++++++++++++++++
 src/egl/main/eglcontext.h |  5 ++++
 2 files changed, 57 insertions(+)

diff --git a/src/egl/main/eglapi.c b/src/egl/main/eglapi.c
index c3b55919d496..1b7a56917911 100644
--- a/src/egl/main/eglapi.c
+++ b/src/egl/main/eglapi.c
@@ -112,6 +112,7 @@
 #include "eglsync.h"
 #include "egllog.h"
 
+#include <GL/gl.h>
 #include "GL/mesa_glinterop.h"
 
 /**
@@ -886,6 +887,18 @@ eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_list,
    context = disp->Driver->CreateContext(disp, conf, share, attrib_list);
    ret = (context) ? _eglLinkContext(context) : EGL_NO_CONTEXT;
 
+   /* Some of our own behavior is naturally expressed as client API calls, so
+    * we fill those in here. We're not being cautious about checking for
+    * extension support yet because Mesa has supported the extensions for
+    * years,
+    */
+   context->GetIntegerv = (void *) eglGetProcAddress("glGetIntegerv");
+   context->BindFramebuffer = (void *) eglGetProcAddress("glBindFramebuffer");
+   if (context->ClientAPI == EGL_OPENGL_API)
+      context->InvalidateFramebuffer = (void *) eglGetProcAddress("glInvalidateFramebuffer");
+   else if (context->ClientAPI == EGL_OPENGL_ES_API)
+      context->InvalidateFramebuffer = (void *) eglGetProcAddress("glDiscardFramebufferEXT");
+
    RETURN_EGL_EVAL(disp, ret);
 }
 
@@ -1412,6 +1425,44 @@ eglSwapInterval(EGLDisplay dpy, EGLint interval)
 }
 
 
+/* From the EGL 1.4 spec (page 52):
+ *
+ *    "The contents of ancillary buffers are always undefined after calling
+ *     eglSwapBuffers."
+ *
+ * And we're going to make sure of it. We have to save and restore the prior
+ * read/draw framebuffer bindings, since the app may have pointed them at
+ * their own FBOs instead.
+ */
+static void
+_eglSwapInvalidateAncillary(_EGLContext *ctx)
+{
+   const GLenum attachments[] = { GL_DEPTH, GL_STENCIL };
+   GLuint read = 0, draw = 0;
+
+   ctx->GetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, (GLint *) &draw);
+   ctx->GetIntegerv(GL_READ_FRAMEBUFFER_BINDING, (GLint *) &read);
+
+   if (draw)
+      ctx->BindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
+   if (read)
+      ctx->BindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+
+   ctx->InvalidateFramebuffer(GL_DRAW_FRAMEBUFFER,
+                              ARRAY_SIZE(attachments),
+                              attachments);
+   if (ctx->DrawSurface != ctx->ReadSurface)
+      ctx->InvalidateFramebuffer(GL_READ_FRAMEBUFFER,
+                                 ARRAY_SIZE(attachments),
+                                 attachments);
+
+   if (draw)
+      ctx->BindFramebuffer(GL_DRAW_FRAMEBUFFER, draw);
+   if (read)
+      ctx->BindFramebuffer(GL_READ_FRAMEBUFFER, read);
+}
+
+
 EGLBoolean EGLAPIENTRY
 eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
 {
@@ -1443,6 +1494,7 @@ eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
       RETURN_EGL_ERROR(disp, EGL_BAD_NATIVE_WINDOW, EGL_FALSE);
 
    egl_relax (disp, &surf->Resource) {
+      _eglSwapInvalidateAncillary(ctx);
       ret = disp->Driver->SwapBuffers(disp, surf);
    }
 
diff --git a/src/egl/main/eglcontext.h b/src/egl/main/eglcontext.h
index cbdefa3432ff..3844c98bf1f8 100644
--- a/src/egl/main/eglcontext.h
+++ b/src/egl/main/eglcontext.h
@@ -54,6 +54,11 @@ struct _egl_context
 
    _EGLConfig *Config;
 
+   void (*GetIntegerv)(unsigned int pname, int *data);
+   void (*BindFramebuffer)(unsigned int target, unsigned int framebuffer);
+   void (*InvalidateFramebuffer)(unsigned int target, int numAttachments,
+                                 const unsigned int *attachments);
+
    EGLint ClientAPI; /**< EGL_OPENGL_ES_API, EGL_OPENGL_API, EGL_OPENVG_API */
    EGLint ClientMajorVersion;
    EGLint ClientMinorVersion;
-- 
GitLab


From 6f33370e2aa38a1bedff5687c104a109af798c57 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 22 Sep 2022 14:41:18 -0400
Subject: [PATCH 3/3] egl/dri: Disconnect and deprecate
 __DRI2_FLUSH_INVALIDATE_ANCILLARY

We're handling this from libEGL instead now.

Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 include/GL/internal/dri_interface.h      | 2 +-
 src/egl/drivers/dri2/egl_dri2.c          | 8 +-------
 src/gallium/frontends/dri/dri_drawable.c | 8 --------
 3 files changed, 2 insertions(+), 16 deletions(-)

diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
index 09ed565fd8b7..c6968651f435 100644
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -225,7 +225,7 @@ struct __DRItexBufferExtensionRec {
 
 #define __DRI2_FLUSH_DRAWABLE (1 << 0) /* the drawable should be flushed. */
 #define __DRI2_FLUSH_CONTEXT  (1 << 1) /* glFlush should be called */
-#define __DRI2_FLUSH_INVALIDATE_ANCILLARY (1 << 2)
+#define __DRI2_FLUSH_INVALIDATE_ANCILLARY (1 << 2) /* deprecated */
 
 enum __DRI2throttleReason {
    __DRI2_THROTTLE_SWAPBUFFER,
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index bb1c36765ab9..d05e1aafd4a1 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -2013,15 +2013,9 @@ dri2_flush_drawable_for_swapbuffers(_EGLDisplay *disp, _EGLSurface *draw)
          _EGLContext *ctx = _eglGetCurrentContext();
          struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
 
-         /* From the EGL 1.4 spec (page 52):
-          *
-          *     "The contents of ancillary buffers are always undefined
-          *      after calling eglSwapBuffers."
-          */
          dri2_dpy->flush->flush_with_flags(dri2_ctx->dri_context,
                                            dri_drawable,
-                                           __DRI2_FLUSH_DRAWABLE |
-                                           __DRI2_FLUSH_INVALIDATE_ANCILLARY,
+                                           __DRI2_FLUSH_DRAWABLE,
                                            __DRI2_THROTTLE_SWAPBUFFER);
       } else {
          dri2_dpy->flush->flush(dri_drawable);
diff --git a/src/gallium/frontends/dri/dri_drawable.c b/src/gallium/frontends/dri/dri_drawable.c
index f9df73ee896d..817847920524 100644
--- a/src/gallium/frontends/dri/dri_drawable.c
+++ b/src/gallium/frontends/dri/dri_drawable.c
@@ -440,14 +440,6 @@ notify_before_flush_cb(void* _args)
 
    dri_postprocessing(args->ctx, args->drawable, ST_ATTACHMENT_BACK_LEFT);
 
-   if (pipe->invalidate_resource &&
-       (args->flags & __DRI2_FLUSH_INVALIDATE_ANCILLARY)) {
-      if (args->drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL])
-         pipe->invalidate_resource(pipe, args->drawable->textures[ST_ATTACHMENT_DEPTH_STENCIL]);
-      if (args->drawable->msaa_textures[ST_ATTACHMENT_DEPTH_STENCIL])
-         pipe->invalidate_resource(pipe, args->drawable->msaa_textures[ST_ATTACHMENT_DEPTH_STENCIL]);
-   }
-
    if (args->ctx->hud) {
       hud_run(args->ctx->hud, args->ctx->st->cso_context,
               args->drawable->textures[ST_ATTACHMENT_BACK_LEFT]);
-- 
GitLab

