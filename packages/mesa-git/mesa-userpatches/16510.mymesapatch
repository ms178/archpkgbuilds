From 3f3539d9b8f69479b2a7b4a3fc9cb844314bf032 Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Sun, 8 May 2022 14:24:41 -0400
Subject: [PATCH 1/4] radv: refactor image binding into struct

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_cmd_buffer.c      | 13 +++++-----
 src/amd/vulkan/radv_descriptor_set.c  |  4 +--
 src/amd/vulkan/radv_device.c          | 31 ++++++++++++----------
 src/amd/vulkan/radv_image.c           | 32 ++++++++++++-----------
 src/amd/vulkan/radv_meta_bufimage.c   |  4 +--
 src/amd/vulkan/radv_meta_clear.c      | 37 +++++++++++++++------------
 src/amd/vulkan/radv_meta_copy.c       |  2 +-
 src/amd/vulkan/radv_meta_dcc_retile.c |  2 +-
 src/amd/vulkan/radv_meta_fast_clear.c |  2 +-
 src/amd/vulkan/radv_meta_fmask_copy.c |  7 ++---
 src/amd/vulkan/radv_private.h         | 30 ++++++++++++----------
 src/amd/vulkan/radv_sdma_copy_image.c |  2 +-
 12 files changed, 90 insertions(+), 76 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index e17c7b230e19..0e52f374f74c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2582,7 +2582,7 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       VkImageLayout layout = subpass->color_attachments[i].layout;
       bool in_render_loop = subpass->color_attachments[i].in_render_loop;
 
-      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, iview->image->bo);
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
 
       assert(iview->vk.aspects & (VK_IMAGE_ASPECT_COLOR_BIT | VK_IMAGE_ASPECT_PLANE_0_BIT |
                                   VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT));
@@ -2610,7 +2610,7 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       bool in_render_loop = subpass->depth_stencil_attachment->in_render_loop;
       struct radv_image_view *iview = cmd_buffer->state.attachments[idx].iview;
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
-                         cmd_buffer->state.attachments[idx].iview->image->bo);
+                         cmd_buffer->state.attachments[idx].iview->image->bindings[0].bo);
 
       radv_emit_fb_ds_state(cmd_buffer, &cmd_buffer->state.attachments[idx].ds, iview, layout,
                             in_render_loop);
@@ -6136,12 +6136,12 @@ radv_cmd_buffer_begin_subpass(struct radv_cmd_buffer *cmd_buffer, uint32_t subpa
          };
 
          /* HTILE buffer */
-         uint64_t htile_offset = ds_image->offset + ds_image->planes[0].surface.meta_offset +
+         uint64_t htile_offset = ds_image->bindings[0].offset + ds_image->planes[0].surface.meta_offset +
                                  ds_image->planes[0].surface.u.gfx9.meta_levels[level].offset;
          uint64_t htile_size = ds_image->planes[0].surface.u.gfx9.meta_levels[level].size;
          struct radv_buffer htile_buffer;
 
-         radv_buffer_init(&htile_buffer, cmd_buffer->device, ds_image->bo, htile_size, htile_offset);
+         radv_buffer_init(&htile_buffer, cmd_buffer->device, ds_image->bindings[0].bo, htile_size, htile_offset);
 
          /* Copy the VRS rates to the HTILE buffer. */
          radv_copy_vrs_htile(cmd_buffer, vrs_iview->image, &extent, ds_image, &htile_buffer, true);
@@ -8544,8 +8544,9 @@ radv_init_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
 
       /* Initialize the mipmap levels without DCC. */
       if (size != image->planes[0].surface.meta_size) {
-         flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bo,
-                                        radv_buffer_get_va(image->bo) + image->offset +
+         flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                        radv_buffer_get_va(image->bindings[0].bo) +
+                                           image->bindings[0].offset +
                                            image->planes[0].surface.meta_offset + size,
                                         image->planes[0].surface.meta_size - size, 0xffffffff);
       }
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 42729bdd588f..1e56c72c366f 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -1162,9 +1162,9 @@ write_image_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_b
    memcpy(dst, descriptor, size);
 
    if (cmd_buffer)
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bo);
+      radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
    else
-      *buffer_list = iview->image->bo;
+      *buffer_list = iview->image->bindings[0].bo;
 }
 
 static ALWAYS_INLINE void
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index b5ebad24e9dc..67b0e4c2e900 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -4740,7 +4740,7 @@ radv_sparse_image_opaque_bind_memory(struct radv_device *device,
       if (bind->pBinds[i].memory != VK_NULL_HANDLE)
          mem = radv_device_memory_from_handle(bind->pBinds[i].memory);
 
-      result = device->ws->buffer_virtual_bind(device->ws, image->bo,
+      result = device->ws->buffer_virtual_bind(device->ws, image->bindings[0].bo,
                                                bind->pBinds[i].resourceOffset, bind->pBinds[i].size,
                                                mem ? mem->bo : NULL, bind->pBinds[i].memoryOffset);
       if (result != VK_SUCCESS)
@@ -4797,7 +4797,7 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
          uint32_t aligned_extent_height = ALIGN(bind_extent.height, surface->prt_tile_height);
 
          uint32_t size = aligned_extent_width * aligned_extent_height * bs;
-         result = device->ws->buffer_virtual_bind(device->ws, image->bo, offset, size,
+         result = device->ws->buffer_virtual_bind(device->ws, image->bindings[0].bo, offset, size,
                                                   mem ? mem->bo : NULL, mem_offset);
          if (result != VK_SUCCESS)
             return result;
@@ -4806,8 +4806,8 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
          uint32_t mem_increment = aligned_extent_width * bs;
          uint32_t size = mem_increment * surface->prt_tile_height;
          for (unsigned y = 0; y < bind_extent.height; y += surface->prt_tile_height) {
-            result = device->ws->buffer_virtual_bind(
-               device->ws, image->bo, offset + img_increment * y, size, mem ? mem->bo : NULL,
+            result = device->ws->buffer_virtual_bind(device->ws,
+               image->bindings[0].bo, offset + img_increment * y, size, mem ? mem->bo : NULL,
                mem_offset + mem_increment * y);
             if (result != VK_SUCCESS)
                return result;
@@ -5180,7 +5180,7 @@ bool
 radv_get_memory_fd(struct radv_device *device, struct radv_device_memory *memory, int *pFD)
 {
    /* Only set BO metadata for the first plane */
-   if (memory->image && memory->image->offset == 0) {
+   if (memory->image && memory->image->bindings[0].offset == 0) {
       struct radeon_bo_metadata metadata;
       radv_init_metadata(device, memory->image, &metadata);
       device->ws->buffer_set_metadata(device->ws, memory->bo, &metadata);
@@ -5702,8 +5702,8 @@ radv_BindImageMemory2(VkDevice _device, uint32_t bindInfoCount,
          }
       }
 
-      image->bo = mem->bo;
-      image->offset = pBindInfos[i].memoryOffset;
+      image->bindings[0].bo = mem->bo;
+      image->bindings[0].offset = pBindInfos[i].memoryOffset;
    }
    return VK_SUCCESS;
 }
@@ -6041,7 +6041,7 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    else
       cb->cb_color_attrib = S_028C74_FORCE_DST_ALPHA_1_GFX6(desc->swizzle[3] == PIPE_SWIZZLE_1);
 
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
 
    cb->cb_color_base = va >> 8;
 
@@ -6106,11 +6106,11 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    }
 
    /* CMASK variables */
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
    va += surf->cmask_offset;
    cb->cb_color_cmask = va >> 8;
 
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
    va += surf->meta_offset;
 
    if (radv_dcc_enabled(iview->image, iview->vk.base_mip_level) &&
@@ -6139,7 +6139,8 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    }
 
    if (radv_image_has_fmask(iview->image)) {
-      va = radv_buffer_get_va(iview->image->bo) + iview->image->offset + surf->fmask_offset;
+      va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset +
+         surf->fmask_offset;
       cb->cb_color_fmask = va >> 8;
       cb->cb_color_fmask |= surf->fmask_tile_swizzle;
    } else {
@@ -6371,7 +6372,7 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
    ds->db_htile_data_base = 0;
    ds->db_htile_surface = 0;
 
-   va = radv_buffer_get_va(iview->image->bo) + iview->image->offset;
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
    s_offs = z_offs = va;
 
    if (device->physical_device->rad_info.gfx_level >= GFX9) {
@@ -6422,7 +6423,8 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
             ds->db_stencil_info |= S_02803C_TILE_STENCIL_DISABLE(1);
          }
 
-         va = radv_buffer_get_va(iview->image->bo) + iview->image->offset + surf->meta_offset;
+         va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset + 
+            surf->meta_offset;
          ds->db_htile_data_base = va >> 8;
          ds->db_htile_surface = S_028ABC_FULL_CACHE(1) | S_028ABC_PIPE_ALIGNED(1);
 
@@ -6491,7 +6493,8 @@ radv_initialise_ds_surface(struct radv_device *device, struct radv_ds_buffer_inf
             ds->db_stencil_info |= S_028044_TILE_STENCIL_DISABLE(1);
          }
 
-         va = radv_buffer_get_va(iview->image->bo) + iview->image->offset + surf->meta_offset;
+         va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset +
+            surf->meta_offset;
          ds->db_htile_data_base = va >> 8;
          ds->db_htile_surface = S_028ABC_FULL_CACHE(1);
 
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 2d303bd4e1bc..0521980af6a0 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -766,7 +766,8 @@ si_set_mutable_tex_desc_fields(struct radv_device *device, struct radv_image *im
                                bool enable_write_compression, uint32_t *state)
 {
    struct radv_image_plane *plane = &image->planes[plane_id];
-   uint64_t gpu_address = image->bo ? radv_buffer_get_va(image->bo) + image->offset : 0;
+   struct radv_image_binding *binding = &image->bindings[0];
+   uint64_t gpu_address = binding->bo ? radv_buffer_get_va(binding->bo) + binding->offset : 0;
    uint64_t va = gpu_address;
    enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
    uint64_t meta_va = 0;
@@ -1051,13 +1052,13 @@ gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *ima
    /* Initialize the sampler view for FMASK. */
    if (fmask_state) {
       if (radv_image_has_fmask(image)) {
-         uint64_t gpu_address = radv_buffer_get_va(image->bo);
+         uint64_t gpu_address = radv_buffer_get_va(image->bindings[0].bo);
          uint32_t format;
          uint64_t va;
 
          assert(image->plane_count == 1);
 
-         va = gpu_address + image->offset + image->planes[0].surface.fmask_offset;
+         va = gpu_address + image->bindings[0].offset + image->planes[0].surface.fmask_offset;
 
          switch (image->info.samples) {
          case 2:
@@ -1090,7 +1091,7 @@ gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *ima
          fmask_state[7] = 0;
 
          if (radv_image_is_tc_compat_cmask(image)) {
-            va = gpu_address + image->offset + image->planes[0].surface.cmask_offset;
+            va = gpu_address + image->bindings[0].offset + image->planes[0].surface.cmask_offset;
 
             fmask_state[6] |= S_00A018_COMPRESSION_EN(1);
             fmask_state[6] |= S_00A018_META_DATA_ADDRESS_LO(va >> 8);
@@ -1230,12 +1231,12 @@ si_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
    if (fmask_state) {
       if (radv_image_has_fmask(image)) {
          uint32_t fmask_format;
-         uint64_t gpu_address = radv_buffer_get_va(image->bo);
+         uint64_t gpu_address = radv_buffer_get_va(image->bindings[0].bo);
          uint64_t va;
 
          assert(image->plane_count == 1);
 
-         va = gpu_address + image->offset + image->planes[0].surface.fmask_offset;
+         va = gpu_address + image->bindings[0].offset + image->planes[0].surface.fmask_offset;
 
          if (device->physical_device->rad_info.gfx_level == GFX9) {
             fmask_format = V_008F14_IMG_DATA_FORMAT_FMASK;
@@ -1292,7 +1293,7 @@ si_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
             fmask_state[5] |= S_008F24_META_PIPE_ALIGNED(1) | S_008F24_META_RB_ALIGNED(1);
 
             if (radv_image_is_tc_compat_cmask(image)) {
-               va = gpu_address + image->offset + image->planes[0].surface.cmask_offset;
+               va = gpu_address + image->bindings[0].offset + image->planes[0].surface.cmask_offset;
 
                fmask_state[5] |= S_008F24_META_DATA_ADDRESS(va >> 40);
                fmask_state[6] |= S_008F28_COMPRESSION_EN(1);
@@ -1307,7 +1308,7 @@ si_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
             fmask_state[5] |= S_008F24_LAST_ARRAY(last_layer);
 
             if (radv_image_is_tc_compat_cmask(image)) {
-               va = gpu_address + image->offset + image->planes[0].surface.cmask_offset;
+               va = gpu_address + image->bindings[0].offset + image->planes[0].surface.cmask_offset;
 
                fmask_state[6] |= S_008F28_COMPRESSION_EN(1);
                fmask_state[7] |= va >> 8;
@@ -1369,7 +1370,7 @@ radv_init_metadata(struct radv_device *device, struct radv_image *image,
 
    if (device->physical_device->rad_info.gfx_level >= GFX9) {
       uint64_t dcc_offset =
-         image->offset +
+         image->bindings[0].offset +
          (surface->display_dcc_offset ? surface->display_dcc_offset : surface->meta_offset);
       metadata->u.gfx9.swizzle_mode = surface->u.gfx9.swizzle_mode;
       metadata->u.gfx9.dcc_offset_256b = dcc_offset >> 8;
@@ -1732,8 +1733,8 @@ static void
 radv_destroy_image(struct radv_device *device, const VkAllocationCallbacks *pAllocator,
                    struct radv_image *image)
 {
-   if ((image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) && image->bo)
-      device->ws->buffer_destroy(device->ws, image->bo);
+   if ((image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) && image->bindings[0].bo)
+      device->ws->buffer_destroy(device->ws, image->bindings[0].bo);
 
    if (image->owned_memory != VK_NULL_HANDLE) {
       RADV_FROM_HANDLE(radv_device_memory, mem, image->owned_memory);
@@ -1751,8 +1752,8 @@ radv_image_print_info(struct radv_device *device, struct radv_image *image)
    fprintf(stderr,
            "  Info: size=%" PRIu64 ", alignment=%" PRIu32 ", "
            "width=%" PRIu32 ", height=%" PRIu32 ", "
-           "offset=%" PRIu64 ", array_size=%" PRIu32 ", levels=%" PRIu32 "\n",
-           image->size, image->alignment, image->info.width, image->info.height, image->offset,
+           "array_size=%" PRIu32 ", levels=%" PRIu32 "\n",
+           image->size, image->alignment, image->info.width, image->info.height,
            image->info.array_size, image->info.levels);
    for (unsigned i = 0; i < image->plane_count; ++i) {
       const struct radv_image_plane *plane = &image->planes[i];
@@ -1901,11 +1902,12 @@ radv_image_create(VkDevice _device, const struct radv_image_create_info *create_
    if (image->vk.create_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) {
       image->alignment = MAX2(image->alignment, 4096);
       image->size = align64(image->size, image->alignment);
-      image->offset = 0;
+      image->bindings[0].offset = 0;
 
       result =
          device->ws->buffer_create(device->ws, image->size, image->alignment, 0,
-                                   RADEON_FLAG_VIRTUAL, RADV_BO_PRIORITY_VIRTUAL, 0, &image->bo);
+                                   RADEON_FLAG_VIRTUAL, RADV_BO_PRIORITY_VIRTUAL, 0,
+                                   &image->bindings[0].bo);
       if (result != VK_SUCCESS) {
          radv_destroy_image(device, alloc, image);
          return vk_error(device, result);
diff --git a/src/amd/vulkan/radv_meta_bufimage.c b/src/amd/vulkan/radv_meta_bufimage.c
index 444a02280fee..93e360a6ac1e 100644
--- a/src/amd/vulkan/radv_meta_bufimage.c
+++ b/src/amd/vulkan/radv_meta_bufimage.c
@@ -1264,7 +1264,7 @@ create_buffer_from_image(struct radv_cmd_buffer *cmd_buffer, struct radv_meta_bl
    struct radv_device *device = cmd_buffer->device;
    struct radv_device_memory mem;
 
-   radv_device_memory_init(&mem, device, surf->image->bo);
+   radv_device_memory_init(&mem, device, surf->image->bindings[0].bo);
 
    radv_CreateBuffer(radv_device_to_handle(device),
                      &(VkBufferCreateInfo){
@@ -1281,7 +1281,7 @@ create_buffer_from_image(struct radv_cmd_buffer *cmd_buffer, struct radv_meta_bl
                              .sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
                              .buffer = *buffer,
                              .memory = radv_device_memory_to_handle(&mem),
-                             .memoryOffset = surf->image->offset,
+                             .memoryOffset = surf->image->bindings[0].offset,
                           }});
 
    radv_device_memory_finish(&mem);
diff --git a/src/amd/vulkan/radv_meta_clear.c b/src/amd/vulkan/radv_meta_clear.c
index 30a510d569ea..91d34275f172 100644
--- a/src/amd/vulkan/radv_meta_clear.c
+++ b/src/amd/vulkan/radv_meta_clear.c
@@ -1265,7 +1265,7 @@ uint32_t
 radv_clear_cmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
                  const VkImageSubresourceRange *range, uint32_t value)
 {
-   uint64_t offset = image->offset + image->planes[0].surface.cmask_offset;
+   uint64_t offset = image->bindings[0].offset + image->planes[0].surface.cmask_offset;
    uint64_t size;
 
    if (cmd_buffer->device->physical_device->rad_info.gfx_level == GFX9) {
@@ -1278,15 +1278,15 @@ radv_clear_cmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
       size = slice_size * radv_get_layerCount(image, range);
    }
 
-   return radv_fill_buffer(cmd_buffer, image, image->bo, radv_buffer_get_va(image->bo) + offset,
-                           size, value);
+   return radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+         radv_buffer_get_va(image->bindings[0].bo) + offset, size, value);
 }
 
 uint32_t
 radv_clear_fmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
                  const VkImageSubresourceRange *range, uint32_t value)
 {
-   uint64_t offset = image->offset + image->planes[0].surface.fmask_offset;
+   uint64_t offset = image->bindings[0].offset + image->planes[0].surface.fmask_offset;
    unsigned slice_size = image->planes[0].surface.fmask_slice_size;
    uint64_t size;
 
@@ -1296,8 +1296,8 @@ radv_clear_fmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
    offset += slice_size * range->baseArrayLayer;
    size = slice_size * radv_get_layerCount(image, range);
 
-   return radv_fill_buffer(cmd_buffer, image, image->bo, radv_buffer_get_va(image->bo) + offset,
-                           size, value);
+   return radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+         radv_buffer_get_va(image->bindings[0].bo) + offset, size, value);
 }
 
 uint32_t
@@ -1312,7 +1312,7 @@ radv_clear_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
    radv_update_dcc_metadata(cmd_buffer, image, range, true);
 
    for (uint32_t l = 0; l < level_count; l++) {
-      uint64_t offset = image->offset + image->planes[0].surface.meta_offset;
+      uint64_t offset = image->bindings[0].offset + image->planes[0].surface.meta_offset;
       uint32_t level = range->baseMipLevel + l;
       uint64_t size;
 
@@ -1344,8 +1344,9 @@ radv_clear_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image,
       if (!size)
          continue;
 
-      flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bo,
-                                     radv_buffer_get_va(image->bo) + offset, size, value);
+      flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                     radv_buffer_get_va(image->bindings[0].bo) + offset,
+                                     size, value);
    }
 
    return flush_bits;
@@ -1480,7 +1481,7 @@ radv_clear_htile(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
       /* Clear individuals levels separately. */
       for (uint32_t l = 0; l < level_count; l++) {
          uint32_t level = range->baseMipLevel + l;
-         uint64_t offset = image->offset + image->planes[0].surface.meta_offset +
+         uint64_t offset = image->bindings[0].offset + image->planes[0].surface.meta_offset +
                            image->planes[0].surface.u.gfx9.meta_levels[level].offset;
          uint32_t size = image->planes[0].surface.u.gfx9.meta_levels[level].size;
 
@@ -1490,28 +1491,30 @@ radv_clear_htile(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
 
          if (htile_mask == UINT_MAX) {
             /* Clear the whole HTILE buffer. */
-            flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bo,
-                                           radv_buffer_get_va(image->bo) + offset, size, value);
+            flush_bits |= radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                           radv_buffer_get_va(image->bindings[0].bo) + offset,
+                                           size, value);
          } else {
             /* Only clear depth or stencil bytes in the HTILE buffer. */
             flush_bits |=
-               clear_htile_mask(cmd_buffer, image, image->bo, offset, size, value, htile_mask);
+               clear_htile_mask(cmd_buffer, image, image->bindings[0].bo, offset, size, value, htile_mask);
          }
       }
    } else {
       unsigned layer_count = radv_get_layerCount(image, range);
       uint64_t size = image->planes[0].surface.meta_slice_size * layer_count;
-      uint64_t offset = image->offset + image->planes[0].surface.meta_offset +
+      uint64_t offset = image->bindings[0].offset + image->planes[0].surface.meta_offset +
                         image->planes[0].surface.meta_slice_size * range->baseArrayLayer;
 
       if (htile_mask == UINT_MAX) {
          /* Clear the whole HTILE buffer. */
-         flush_bits = radv_fill_buffer(cmd_buffer, image, image->bo,
-                                       radv_buffer_get_va(image->bo) + offset, size, value);
+         flush_bits = radv_fill_buffer(cmd_buffer, image, image->bindings[0].bo,
+                                       radv_buffer_get_va(image->bindings[0].bo) + offset,
+                                       size, value);
       } else {
          /* Only clear depth or stencil bytes in the HTILE buffer. */
          flush_bits =
-            clear_htile_mask(cmd_buffer, image, image->bo, offset, size, value, htile_mask);
+            clear_htile_mask(cmd_buffer, image, image->bindings[0].bo, offset, size, value, htile_mask);
       }
    }
 
diff --git a/src/amd/vulkan/radv_meta_copy.c b/src/amd/vulkan/radv_meta_copy.c
index dc5522a1840d..1f9818ad390a 100644
--- a/src/amd/vulkan/radv_meta_copy.c
+++ b/src/amd/vulkan/radv_meta_copy.c
@@ -244,7 +244,7 @@ copy_image_to_buffer(struct radv_cmd_buffer *cmd_buffer, struct radv_buffer *buf
       assert(image->info.height == region->imageExtent.height);
       ASSERTED bool res = radv_sdma_copy_image(cmd_buffer, image, buffer, region);
       assert(res);
-      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, image->bo);
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, image->bindings[0].bo);
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, buffer->bo);
       return;
    }
diff --git a/src/amd/vulkan/radv_meta_dcc_retile.c b/src/amd/vulkan/radv_meta_dcc_retile.c
index b77063b482d9..df623283a890 100644
--- a/src/amd/vulkan/radv_meta_dcc_retile.c
+++ b/src/amd/vulkan/radv_meta_dcc_retile.c
@@ -213,7 +213,7 @@ radv_retile_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image)
    radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_COMPUTE,
                         device->meta_state.dcc_retile.pipeline[swizzle_mode]);
 
-   radv_buffer_init(&buffer, device, image->bo, image->size, image->offset);
+   radv_buffer_init(&buffer, device, image->bindings[0].bo, image->size, image->bindings[0].offset);
 
    struct radv_buffer_view views[2];
    VkBufferView view_handles[2];
diff --git a/src/amd/vulkan/radv_meta_fast_clear.c b/src/amd/vulkan/radv_meta_fast_clear.c
index c213ea43aa22..d5ced737f3b2 100644
--- a/src/amd/vulkan/radv_meta_fast_clear.c
+++ b/src/amd/vulkan/radv_meta_fast_clear.c
@@ -472,7 +472,7 @@ radv_emit_set_predication_state_from_image(struct radv_cmd_buffer *cmd_buffer,
    uint64_t va = 0;
 
    if (value) {
-      va = radv_buffer_get_va(image->bo) + image->offset;
+      va = radv_buffer_get_va(image->bindings[0].bo) + image->bindings[0].offset;
       va += pred_offset;
    }
 
diff --git a/src/amd/vulkan/radv_meta_fmask_copy.c b/src/amd/vulkan/radv_meta_fmask_copy.c
index 389aa96bd6fb..d90110e0a313 100644
--- a/src/amd/vulkan/radv_meta_fmask_copy.c
+++ b/src/amd/vulkan/radv_meta_fmask_copy.c
@@ -239,10 +239,11 @@ radv_fixup_copy_dst_metadata(struct radv_cmd_buffer *cmd_buffer, const struct ra
 
    /* Copy CMASK+FMASK. */
    size = src_image->planes[0].surface.cmask_size + src_image->planes[0].surface.fmask_size;
-   src_offset = src_image->offset + src_image->planes[0].surface.fmask_offset;
-   dst_offset = dst_image->offset + dst_image->planes[0].surface.fmask_offset;
+   src_offset = src_image->bindings[0].offset + src_image->planes[0].surface.fmask_offset;
+   dst_offset = dst_image->bindings[0].offset + dst_image->planes[0].surface.fmask_offset;
 
-   radv_copy_buffer(cmd_buffer, src_image->bo, dst_image->bo, src_offset, dst_offset, size);
+   radv_copy_buffer(cmd_buffer, src_image->bindings[0].bo, dst_image->bindings[0].bo,
+                    src_offset, dst_offset, size);
 }
 
 bool
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index ca1df44922c1..36421a6b3c25 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2331,6 +2331,12 @@ struct radv_image_plane {
    struct radeon_surf surface;
 };
 
+struct radv_image_binding {
+   /* Set when bound */
+   struct radeon_winsys_bo *bo;
+   VkDeviceSize offset;
+};
+
 struct radv_image {
    struct vk_image vk;
 
@@ -2346,9 +2352,7 @@ struct radv_image {
    bool dcc_sign_reinterpret;
    bool support_comp_to_single;
 
-   /* Set when bound */
-   struct radeon_winsys_bo *bo;
-   VkDeviceSize offset;
+   struct radv_image_binding bindings[3];
    bool tc_compatible_cmask;
 
    uint64_t clear_value_offset;
@@ -2514,8 +2518,8 @@ radv_image_get_fast_clear_va(const struct radv_image *image, uint32_t base_level
 {
    assert(radv_image_has_clear_value(image));
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->clear_value_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->clear_value_offset + base_level * 8;
    return va;
 }
 
@@ -2524,8 +2528,8 @@ radv_image_get_fce_pred_va(const struct radv_image *image, uint32_t base_level)
 {
    assert(image->fce_pred_offset != 0);
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->fce_pred_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->fce_pred_offset + base_level * 8;
    return va;
 }
 
@@ -2534,8 +2538,8 @@ radv_image_get_dcc_pred_va(const struct radv_image *image, uint32_t base_level)
 {
    assert(image->dcc_pred_offset != 0);
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->dcc_pred_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->dcc_pred_offset + base_level * 8;
    return va;
 }
 
@@ -2544,8 +2548,8 @@ radv_get_tc_compat_zrange_va(const struct radv_image *image, uint32_t base_level
 {
    assert(image->tc_compat_zrange_offset != 0);
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->tc_compat_zrange_offset + base_level * 4;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->tc_compat_zrange_offset + base_level * 4;
    return va;
 }
 
@@ -2554,8 +2558,8 @@ radv_get_ds_clear_value_va(const struct radv_image *image, uint32_t base_level)
 {
    assert(radv_image_has_clear_value(image));
 
-   uint64_t va = radv_buffer_get_va(image->bo);
-   va += image->offset + image->clear_value_offset + base_level * 8;
+   uint64_t va = radv_buffer_get_va(image->bindings[0].bo);
+   va += image->bindings[0].offset + image->clear_value_offset + base_level * 8;
    return va;
 }
 
diff --git a/src/amd/vulkan/radv_sdma_copy_image.c b/src/amd/vulkan/radv_sdma_copy_image.c
index 3bb2d0779088..93044c6e6754 100644
--- a/src/amd/vulkan/radv_sdma_copy_image.c
+++ b/src/amd/vulkan/radv_sdma_copy_image.c
@@ -76,7 +76,7 @@ radv_sdma_v4_v5_copy_image_to_buffer(struct radv_cmd_buffer *cmd_buffer, struct
    struct radv_device *device = cmd_buffer->device;
    unsigned bpp = image->planes[0].surface.bpe;
    uint64_t dst_address = buffer->bo->va;
-   uint64_t src_address = image->bo->va + image->planes[0].surface.u.gfx9.surf_offset;
+   uint64_t src_address = image->bindings[0].bo->va + image->planes[0].surface.u.gfx9.surf_offset;
    unsigned src_pitch = image->planes[0].surface.u.gfx9.surf_pitch;
    unsigned copy_width = DIV_ROUND_UP(image->info.width, image->planes[0].surface.blk_w);
    unsigned copy_height = DIV_ROUND_UP(image->info.height, image->planes[0].surface.blk_h);
-- 
GitLab


From 92b6792b8702cf2349be7285be5eb6bdfa25ebff Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Mon, 6 Jun 2022 13:31:25 -0400
Subject: [PATCH 2/4] radv: consolidate descriptor set buffer counts

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_descriptor_set.c | 33 ++++++++++++++++------------
 1 file changed, 19 insertions(+), 14 deletions(-)

diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 1e56c72c366f..393939172aaf 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -33,6 +33,19 @@
 #include "vk_format.h"
 #include "vk_util.h"
 
+static unsigned
+radv_descriptor_type_buffer_count(VkDescriptorType type)
+{
+   switch (type) {
+      case VK_DESCRIPTOR_TYPE_SAMPLER:
+      case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
+      case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR:
+         return 0;
+      default:
+         return 1;
+   }
+}
+
 static bool
 has_equal_immutable_samplers(const VkSampler *samplers, uint32_t count)
 {
@@ -196,7 +209,8 @@ radv_CreateDescriptorSetLayout(VkDevice _device, const VkDescriptorSetLayoutCrea
       const VkDescriptorSetLayoutBinding *binding = bindings + j;
       uint32_t b = binding->binding;
       uint32_t alignment = 0;
-      unsigned binding_buffer_count = 0;
+      unsigned binding_buffer_count =
+         radv_descriptor_type_buffer_count(binding->descriptorType);
       uint32_t descriptor_count = binding->descriptorCount;
       bool has_ycbcr_sampler = false;
 
@@ -226,7 +240,6 @@ radv_CreateDescriptorSetLayout(VkDevice _device, const VkDescriptorSetLayoutCrea
          if (binding->stageFlags & RADV_RT_STAGE_BITS)
             set_layout->dynamic_shader_stages |= VK_SHADER_STAGE_COMPUTE_BIT;
          set_layout->binding[b].size = 0;
-         binding_buffer_count = 1;
          alignment = 1;
          break;
       case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
@@ -234,25 +247,21 @@ radv_CreateDescriptorSetLayout(VkDevice _device, const VkDescriptorSetLayoutCrea
       case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
       case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
          set_layout->binding[b].size = 16;
-         binding_buffer_count = 1;
          alignment = 16;
          break;
       case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
          set_layout->binding[b].size = 32;
-         binding_buffer_count = 1;
          alignment = 32;
          break;
       case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
       case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
          /* main descriptor + fmask descriptor */
          set_layout->binding[b].size = 64;
-         binding_buffer_count = 1;
          alignment = 32;
          break;
       case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
          /* main descriptor + fmask descriptor + sampler */
          set_layout->binding[b].size = 96;
-         binding_buffer_count = 1;
          alignment = 32;
          break;
       case VK_DESCRIPTOR_TYPE_SAMPLER:
@@ -265,7 +274,6 @@ radv_CreateDescriptorSetLayout(VkDevice _device, const VkDescriptorSetLayoutCrea
                                                      &mutable_size, &mutable_align);
          assert(mutable_size && mutable_align);
          set_layout->binding[b].size = mutable_size;
-         binding_buffer_count = 1;
          alignment = mutable_align;
          break;
       }
@@ -631,11 +639,8 @@ radv_descriptor_set_create(struct radv_device *device, struct radv_descriptor_po
    struct radv_descriptor_set *set;
    uint32_t buffer_count = layout->buffer_count;
    if (variable_count) {
-      unsigned stride = 1;
-      if (layout->binding[layout->binding_count - 1].type == VK_DESCRIPTOR_TYPE_SAMPLER ||
-          layout->binding[layout->binding_count - 1].type ==
-             VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK)
-         stride = 0;
+      unsigned stride =
+         radv_descriptor_type_buffer_count(layout->binding[layout->binding_count - 1].type);
       buffer_count =
          layout->binding[layout->binding_count - 1].buffer_offset + *variable_count * stride;
    }
@@ -815,8 +820,8 @@ radv_CreateDescriptorPool(VkDevice _device, const VkDescriptorPoolCreateInfo *pC
    }
 
    for (unsigned i = 0; i < pCreateInfo->poolSizeCount; ++i) {
-      if (pCreateInfo->pPoolSizes[i].type != VK_DESCRIPTOR_TYPE_SAMPLER)
-         bo_count += pCreateInfo->pPoolSizes[i].descriptorCount;
+      bo_count += radv_descriptor_type_buffer_count(pCreateInfo->pPoolSizes[i].type) *
+         pCreateInfo->pPoolSizes[i].descriptorCount;
 
       switch (pCreateInfo->pPoolSizes[i].type) {
       case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
-- 
GitLab


From 5f443686f0fa3f231496a267c1088950fb19121a Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Fri, 6 May 2022 15:54:18 -0400
Subject: [PATCH 3/4] radv: implement disjoint memory for multiplane images

For descriptor binding, we need to allow up to three buffers to be
referenced by any image.

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_cmd_buffer.c     | 14 ++++++++++-
 src/amd/vulkan/radv_descriptor_set.c | 37 ++++++++++++++++++++--------
 src/amd/vulkan/radv_device.c         | 30 +++++++++++++++++++---
 src/amd/vulkan/radv_image.c          |  6 +++--
 src/amd/vulkan/radv_private.h        |  1 +
 5 files changed, 72 insertions(+), 16 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 0e52f374f74c..381bb782cc88 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2585,7 +2585,19 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
 
       assert(iview->vk.aspects & (VK_IMAGE_ASPECT_COLOR_BIT | VK_IMAGE_ASPECT_PLANE_0_BIT |
-                                  VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT));
+                                   VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT));
+
+      if (iview->image->disjoint && iview->vk.aspects == VK_IMAGE_ASPECT_COLOR_BIT) {
+         for (uint32_t plane_id = 0; plane_id < iview->image->plane_count; plane_id++) {
+            radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
+                  iview->image->bindings[plane_id].bo);
+         }
+      } else {
+         uint32_t plane_id = iview->image->disjoint ? iview->plane_id : 0;
+         radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs,
+               iview->image->bindings[plane_id].bo);
+      }
+
       radv_emit_fb_color_state(cmd_buffer, i, &cmd_buffer->state.attachments[idx].cb, iview, layout,
                                in_render_loop);
 
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 393939172aaf..d71de46003d4 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -41,6 +41,12 @@ radv_descriptor_type_buffer_count(VkDescriptorType type)
       case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
       case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR:
          return 0;
+      case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
+      case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
+      case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
+      case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
+      case VK_DESCRIPTOR_TYPE_MUTABLE_VALVE:
+         return 3;
       default:
          return 1;
    }
@@ -1166,10 +1172,17 @@ write_image_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_b
 
    memcpy(dst, descriptor, size);
 
-   if (cmd_buffer)
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[0].bo);
-   else
-      *buffer_list = iview->image->bindings[0].bo;
+   const uint32_t max_bindings = sizeof(iview->image->bindings) /
+                                 sizeof(iview->image->bindings[0]);
+   for (uint32_t b = 0; b < max_bindings; b++) {
+      if (cmd_buffer) {
+         if (iview->image->bindings[b].bo)
+            radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[b].bo);
+      } else {
+         *buffer_list = iview->image->bindings[b].bo;
+         buffer_list++;
+      }
+   }
 }
 
 static ALWAYS_INLINE void
@@ -1364,13 +1377,17 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf
          src_ptr += src_binding_layout->size / 4;
          dst_ptr += dst_binding_layout->size / 4;
 
-         if (src_binding_layout->type != VK_DESCRIPTOR_TYPE_SAMPLER &&
-             dst_binding_layout->type != VK_DESCRIPTOR_TYPE_SAMPLER &&
-             src_binding_layout->type != VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR &&
-             dst_binding_layout->type != VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR) {
-            /* Sampler/acceleration structure descriptors don't have a buffer list. */
-            dst_buffer_list[j] = src_buffer_list[j];
+         unsigned src_buffer_count = radv_descriptor_type_buffer_count(src_binding_layout->type);
+         unsigned dst_buffer_count = radv_descriptor_type_buffer_count(dst_binding_layout->type);
+         for (unsigned k = 0; k < dst_buffer_count; k++) {
+            if (k < src_buffer_count)
+               dst_buffer_list[k] = src_buffer_list[k];
+            else
+               dst_buffer_list[k] = NULL;
          }
+
+         dst_buffer_list += dst_buffer_count;
+         src_buffer_list += src_buffer_count;
       }
    }
 }
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 67b0e4c2e900..1c7984983219 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -5702,8 +5702,30 @@ radv_BindImageMemory2(VkDevice _device, uint32_t bindInfoCount,
          }
       }
 
-      image->bindings[0].bo = mem->bo;
-      image->bindings[0].offset = pBindInfos[i].memoryOffset;
+      if (image->disjoint) {
+         const VkBindImagePlaneMemoryInfo *plane_info =
+            vk_find_struct_const(pBindInfos[i].pNext, BIND_IMAGE_PLANE_MEMORY_INFO);
+
+         switch (plane_info->planeAspect) {
+            case VK_IMAGE_ASPECT_PLANE_0_BIT:
+               image->bindings[0].bo = mem->bo;
+               image->bindings[0].offset = pBindInfos[i].memoryOffset;
+               break;
+            case VK_IMAGE_ASPECT_PLANE_1_BIT:
+               image->bindings[1].bo = mem->bo;
+               image->bindings[1].offset = pBindInfos[i].memoryOffset;
+               break;
+            case VK_IMAGE_ASPECT_PLANE_2_BIT:
+               image->bindings[2].bo = mem->bo;
+               image->bindings[2].offset = pBindInfos[i].memoryOffset;
+               break;
+            default:
+               break;
+         }
+      } else {
+         image->bindings[0].bo = mem->bo;
+         image->bindings[0].offset = pBindInfos[i].memoryOffset;
+      }
    }
    return VK_SUCCESS;
 }
@@ -6041,7 +6063,9 @@ radv_initialise_color_surface(struct radv_device *device, struct radv_color_buff
    else
       cb->cb_color_attrib = S_028C74_FORCE_DST_ALPHA_1_GFX6(desc->swizzle[3] == PIPE_SWIZZLE_1);
 
-   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
+   uint32_t plane_id = iview->image->disjoint ? iview->plane_id : 0;
+   va = radv_buffer_get_va(iview->image->bindings[plane_id].bo) +
+      iview->image->bindings[plane_id].offset;
 
    cb->cb_color_base = va >> 8;
 
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 0521980af6a0..3b3afd19d483 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -766,7 +766,7 @@ si_set_mutable_tex_desc_fields(struct radv_device *device, struct radv_image *im
                                bool enable_write_compression, uint32_t *state)
 {
    struct radv_image_plane *plane = &image->planes[plane_id];
-   struct radv_image_binding *binding = &image->bindings[0];
+   struct radv_image_binding *binding = image->disjoint ? &image->bindings[plane_id] : &image->bindings[0];
    uint64_t gpu_address = binding->bo ? radv_buffer_get_va(binding->bo) + binding->offset : 0;
    uint64_t va = gpu_address;
    enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
@@ -1684,7 +1684,8 @@ radv_image_create_layout(struct radv_device *device, struct radv_image_create_in
          offset = mod_info->pPlaneLayouts[plane].offset;
          stride = mod_info->pPlaneLayouts[plane].rowPitch / image->planes[plane].surface.bpe;
       } else {
-         offset = align64(image->size, 1 << image->planes[plane].surface.alignment_log2);
+         offset = image->disjoint ? 0 :
+            align64(image->size, 1 << image->planes[plane].surface.alignment_log2);
          stride = 0; /* 0 means no override */
       }
 
@@ -1850,6 +1851,7 @@ radv_image_create(VkDevice _device, const struct radv_image_create_info *create_
    image->info.num_channels = vk_format_get_nr_components(format);
 
    image->plane_count = vk_format_get_plane_count(format);
+   image->disjoint = image->plane_count > 1 && pCreateInfo->flags & VK_IMAGE_CREATE_DISJOINT_BIT;
 
    image->exclusive = pCreateInfo->sharingMode == VK_SHARING_MODE_EXCLUSIVE;
    if (pCreateInfo->sharingMode == VK_SHARING_MODE_CONCURRENT) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 36421a6b3c25..83cf6019e615 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2371,6 +2371,7 @@ struct radv_image {
    VkDeviceMemory owned_memory;
 
    unsigned plane_count;
+   bool disjoint;
    struct radv_image_plane planes[0];
 };
 
-- 
GitLab


From fc60ff8682d3b18c65ed2597891372f35f495091 Mon Sep 17 00:00:00 2001
From: Benjamin Cheng <ben@bcheng.me>
Date: Fri, 13 May 2022 21:24:12 -0400
Subject: [PATCH 4/4] radv: expose disjoint image support

Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_formats.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index f9c5614ac3f7..3fd4fc2903ba 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -716,7 +716,8 @@ radv_physical_device_get_format_properties(struct radv_physical_device *physical
       return;
    }
 
-   if (vk_format_get_plane_count(format) > 1 || desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED) {
+   const bool multiplanar = vk_format_get_plane_count(format) > 1;
+   if (multiplanar || desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED) {
       uint64_t tiling = VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT |
                         VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
                         VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT |
@@ -728,6 +729,9 @@ radv_physical_device_get_format_properties(struct radv_physical_device *physical
          tiling |= VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
       }
 
+      if (multiplanar)
+         tiling |= VK_FORMAT_FEATURE_2_DISJOINT_BIT;
+
       /* Fails for unknown reasons with linear tiling & subsampled formats. */
       out_properties->linearTilingFeatures =
          desc->layout == UTIL_FORMAT_LAYOUT_SUBSAMPLED ? 0 : tiling;
@@ -1211,6 +1215,9 @@ radv_get_modifier_flags(struct radv_physical_device *dev, VkFormat format, uint6
    else
       features = props->optimalTilingFeatures;
 
+   /* Unconditionally disable DISJOINT support for modifiers for now */
+   features &= ~VK_FORMAT_FEATURE_2_DISJOINT_BIT;
+
    if (ac_modifier_has_dcc(modifier)) {
       /* Only disable support for STORAGE_IMAGE on modifiers that
        * do not support DCC image stores.
-- 
GitLab

