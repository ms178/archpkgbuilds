From 50999d563055968e3c9c0ca9738c4e5563b80327 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 3 Aug 2023 17:08:17 +0800
Subject: [PATCH 01/10] aco: use is_shader_part when setup_isel_context

We are going to add more shader parts.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp  |  8 +++-----
 src/amd/compiler/aco_instruction_selection.h    |  3 +--
 .../aco_instruction_selection_setup.cpp         | 17 +++++++++--------
 3 files changed, 13 insertions(+), 15 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 7f665ecba324f..bed7313e18f8d 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11517,7 +11517,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
                const struct aco_shader_info* info, const struct ac_shader_args* args)
 {
    isel_context ctx =
-      setup_isel_context(program, shader_count, shaders, config, options, info, args, false, false);
+      setup_isel_context(program, shader_count, shaders, config, options, info, args, false);
 
    if (ctx.stage == raytracing_cs)
       return select_program_rt(ctx, shader_count, shaders, args);
@@ -12101,8 +12101,7 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
                  const struct ac_shader_args* args)
 {
    const struct aco_ps_epilog_info* einfo = (const struct aco_ps_epilog_info*)pinfo;
-   isel_context ctx =
-      setup_isel_context(program, 0, NULL, config, options, info, args, true, false);
+   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, true);
 
    ctx.block->fp_mode = program->next_fp_mode;
 
@@ -12171,8 +12170,7 @@ select_tcs_epilog(Program* program, void* pinfo, ac_shader_config* config,
                   const struct ac_shader_args* args)
 {
    const struct aco_tcs_epilog_info* einfo = (const struct aco_tcs_epilog_info*)pinfo;
-   isel_context ctx =
-      setup_isel_context(program, 0, NULL, config, options, info, args, false, true);
+   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, true);
 
    ctx.block->fp_mode = program->next_fp_mode;
 
diff --git a/src/amd/compiler/aco_instruction_selection.h b/src/amd/compiler/aco_instruction_selection.h
index fd88622943510..e8e01702c0f20 100644
--- a/src/amd/compiler/aco_instruction_selection.h
+++ b/src/amd/compiler/aco_instruction_selection.h
@@ -123,8 +123,7 @@ isel_context setup_isel_context(Program* program, unsigned shader_count,
                                 struct nir_shader* const* shaders, ac_shader_config* config,
                                 const struct aco_compiler_options* options,
                                 const struct aco_shader_info* info,
-                                const struct ac_shader_args* args, bool is_ps_epilog,
-                                bool is_tcs_epilog);
+                                const struct ac_shader_args* args, bool is_shader_part);
 
 } // namespace aco
 
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index c87572a23659d..8aad0846d51a8 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -649,7 +649,7 @@ isel_context
 setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* const* shaders,
                    ac_shader_config* config, const struct aco_compiler_options* options,
                    const struct aco_shader_info* info, const struct ac_shader_args* args,
-                   bool is_ps_epilog, bool is_tcs_epilog)
+                   bool is_shader_part)
 {
    SWStage sw_stage = SWStage::None;
    for (unsigned i = 0; i < shader_count; i++) {
@@ -673,14 +673,15 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
       }
    }
 
-   if (is_ps_epilog) {
+   if (is_shader_part) {
       assert(shader_count == 0 && !shaders);
-      sw_stage = SWStage::FS;
-   }
 
-   if (is_tcs_epilog) {
-      assert(shader_count == 0 && !shaders);
-      sw_stage = SWStage::TCS;
+      switch (info->hw_stage) {
+      case AC_HW_PIXEL_SHADER: sw_stage = SWStage::FS; break;
+      case AC_HW_HULL_SHADER: sw_stage = SWStage::TCS; break;
+      case AC_HW_COMPUTE_SHADER: sw_stage = SWStage::CS; break;
+      default: unreachable("Invalid stage shader part");
+      }
    }
 
    init_program(program, Stage{info->hw_stage, sw_stage}, info, options->gfx_level, options->family,
@@ -699,7 +700,7 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
    ASSERTED bool mesh_shading = ctx.stage.has(SWStage::TS) || ctx.stage.has(SWStage::MS);
    assert(!mesh_shading || ctx.program->gfx_level >= GFX10_3);
 
-   if (ctx.stage == tess_control_hs && !is_tcs_epilog)
+   if (ctx.stage == tess_control_hs && !is_shader_part)
       setup_tcs_info(&ctx, shaders[0], NULL);
    else if (ctx.stage == vertex_tess_control_hs)
       setup_tcs_info(&ctx, shaders[1], shaders[0]);
-- 
GitLab


From 38f79af4ccb79b14fe8339763a6184f0db3a448f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 4 Aug 2023 20:14:30 +0800
Subject: [PATCH 02/10] aco: prepare fix_ls_vgpr_init_bug to be used by gl vs
 prolog

Prolog does not have nir shader.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index bed7313e18f8d..b67374cd5895c 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11021,9 +11021,8 @@ add_startpgm(struct isel_context* ctx)
 }
 
 void
-fix_ls_vgpr_init_bug(isel_context* ctx, Pseudo_instruction* startpgm)
+fix_ls_vgpr_init_bug(isel_context* ctx)
 {
-   assert(ctx->shader->info.stage == MESA_SHADER_VERTEX);
    Builder bld(ctx->program, ctx->block);
    constexpr unsigned hs_idx = 1u;
    Builder::Result hs_thread_count =
@@ -11343,7 +11342,7 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
       append_logical_start(ctx.block);
 
       if (unlikely(ctx.options->has_ls_vgpr_init_bug && ctx.stage == vertex_tess_control_hs))
-         fix_ls_vgpr_init_bug(&ctx, startpgm);
+         fix_ls_vgpr_init_bug(&ctx);
 
       split_arguments(&ctx, startpgm);
 
-- 
GitLab


From e1ff44cb484e7611d8155c8a1e6bcdc64ba9c201 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 5 Aug 2023 16:17:02 +0800
Subject: [PATCH 03/10] aco: add vs prolog instruction selection for radeonsi

Port from llvm si_llvm_build_vs_prolog().

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 128 +++++++++++++++++-
 src/amd/compiler/aco_ir.h                     |   4 +
 src/amd/compiler/aco_shader_info.h            |  10 ++
 3 files changed, 135 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index b67374cd5895c..7d9ac4ae2a82e 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10876,6 +10876,28 @@ get_arg_for_end(isel_context* ctx, struct ac_arg arg)
    return Operand(get_arg(ctx, arg), get_arg_reg(ctx->args, arg));
 }
 
+static void
+passthrough_all_args(isel_context* ctx, std::vector<Operand>& regs)
+{
+   struct ac_arg arg;
+   arg.used = true;
+
+   for (arg.arg_index = 0; arg.arg_index < ctx->args->arg_count; arg.arg_index++)
+      regs.emplace_back(get_arg_for_end(ctx, arg));
+}
+
+static void
+build_end_with_regs(isel_context* ctx, std::vector<Operand>& regs)
+{
+   aco_ptr<Pseudo_instruction> end{create_instruction<Pseudo_instruction>(
+      aco_opcode::p_end_with_regs, Format::PSEUDO, regs.size(), 0)};
+
+   for (unsigned i = 0; i < regs.size(); i++)
+      end->operands[i] = regs[i];
+
+   ctx->block->instructions.emplace_back(std::move(end));
+}
+
 static void
 create_tcs_jump_to_epilog(isel_context* ctx)
 {
@@ -10935,13 +10957,7 @@ create_tcs_end_for_epilog(isel_context* ctx)
       regs.emplace_back(Operand(tf_lds_offset, PhysReg{vgpr}));
    }
 
-   aco_ptr<Pseudo_instruction> end{create_instruction<Pseudo_instruction>(
-      aco_opcode::p_end_with_regs, Format::PSEUDO, regs.size(), 0)};
-
-   for (unsigned i = 0; i < regs.size(); i++)
-      end->operands[i] = regs[i];
-
-   ctx->block->instructions.emplace_back(std::move(end));
+   build_end_with_regs(ctx, regs);
 }
 
 Pseudo_instruction*
@@ -11508,6 +11524,55 @@ store_tess_factor_to_tess_ring(isel_context* ctx, Temp tess_ring_desc, Temp fact
                            memory_sync_info(storage_vmem_output), true, false, false);
 }
 
+Temp
+build_fast_udiv_nuw(isel_context* ctx, Temp num, Temp multiplier, Temp pre_shift, Temp post_shift,
+                    Temp increment)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   num = bld.vop2(aco_opcode::v_lshrrev_b32, bld.def(v1), pre_shift, num);
+   num = bld.nuw().vadd32(bld.def(v1), num, increment);
+   num = bld.vop3(aco_opcode::v_mul_hi_u32, bld.def(v1), num, multiplier);
+   return bld.vop2(aco_opcode::v_lshrrev_b32, bld.def(v1), post_shift, num);
+}
+
+Temp
+get_gl_vs_prolog_vertex_index(isel_context* ctx, const struct aco_gl_vs_prolog_info* vinfo,
+                              unsigned input_index, Temp instance_divisor_constbuf)
+{
+   bool divisor_is_one = vinfo->instance_divisor_is_one & (1u << input_index);
+   bool divisor_is_fetched = vinfo->instance_divisor_is_fetched & (1u << input_index);
+
+   Builder bld(ctx->program, ctx->block);
+
+   Temp index;
+   if (divisor_is_one) {
+      index = get_arg(ctx, ctx->args->instance_id);
+   } else if (divisor_is_fetched) {
+      Temp instance_id = get_arg(ctx, ctx->args->instance_id);
+
+      Temp udiv_factors = bld.smem(aco_opcode::s_buffer_load_dwordx4, bld.def(s4),
+                                   instance_divisor_constbuf, Operand::c32(input_index * 16));
+      emit_split_vector(ctx, udiv_factors, 4);
+
+      index = build_fast_udiv_nuw(ctx, instance_id, emit_extract_vector(ctx, udiv_factors, 0, s1),
+                                  emit_extract_vector(ctx, udiv_factors, 1, s1),
+                                  emit_extract_vector(ctx, udiv_factors, 2, s1),
+                                  emit_extract_vector(ctx, udiv_factors, 3, s1));
+   }
+
+   if (divisor_is_one || divisor_is_fetched) {
+      Temp start_instance = get_arg(ctx, ctx->args->start_instance);
+      index = bld.vadd32(bld.def(v1), index, start_instance);
+   } else {
+      Temp base_vertex = get_arg(ctx, ctx->args->base_vertex);
+      Temp vertex_id = get_arg(ctx, ctx->args->vertex_id);
+      index = bld.vadd32(bld.def(v1), base_vertex, vertex_id);
+   }
+
+   return index;
+}
+
 } /* end namespace */
 
 void
@@ -12348,4 +12413,53 @@ select_tcs_epilog(Program* program, void* pinfo, ac_shader_config* config,
    cleanup_cfg(program);
 }
 
+void
+select_gl_vs_prolog(Program* program, void* pinfo, ac_shader_config* config,
+                    const struct aco_compiler_options* options, const struct aco_shader_info* info,
+                    const struct ac_shader_args* args)
+{
+   const struct aco_gl_vs_prolog_info* vinfo = (const struct aco_gl_vs_prolog_info*)pinfo;
+   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, true);
+
+   ctx.block->fp_mode = program->next_fp_mode;
+
+   add_startpgm(&ctx);
+   append_logical_start(ctx.block);
+
+   Builder bld(ctx.program, ctx.block);
+
+   bld.sopp(aco_opcode::s_setprio, -1u, 0x3u);
+
+   if (vinfo->as_ls && options->has_ls_vgpr_init_bug)
+      fix_ls_vgpr_init_bug(&ctx);
+
+   std::vector<Operand> regs;
+   passthrough_all_args(&ctx, regs);
+
+   Temp instance_divisor_constbuf;
+
+   if (vinfo->instance_divisor_is_fetched) {
+      Temp list = get_arg(&ctx, vinfo->internal_bindings);
+      list = convert_pointer_to_64_bit(&ctx, list);
+
+      instance_divisor_constbuf = bld.smem(aco_opcode::s_load_dwordx4, bld.def(s4), list,
+                                           Operand::c32(vinfo->instance_diviser_buf_offset));
+   }
+
+   unsigned vgpr = 256 + ctx.args->num_vgprs_used;
+
+   for (unsigned i = 0; i < vinfo->num_inputs; i++) {
+      Temp index = get_gl_vs_prolog_vertex_index(&ctx, vinfo, i, instance_divisor_constbuf);
+      regs.emplace_back(Operand(index, PhysReg{vgpr + i}));
+   }
+
+   program->config->float_mode = program->blocks[0].fp_mode.val;
+
+   append_logical_end(ctx.block);
+
+   build_end_with_regs(&ctx, regs);
+
+   cleanup_cfg(program);
+}
+
 } // namespace aco
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 94ae241a9660a..6de37e5ba1e55 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2239,6 +2239,10 @@ void select_tcs_epilog(Program* program, void* pinfo, ac_shader_config* config,
                        const struct aco_compiler_options* options,
                        const struct aco_shader_info* info, const struct ac_shader_args* args);
 
+void select_gl_vs_prolog(Program* program, void* pinfo, ac_shader_config* config,
+                         const struct aco_compiler_options* options,
+                         const struct aco_shader_info* info, const struct ac_shader_args* args);
+
 void lower_phis(Program* program);
 void calc_min_waves(Program* program);
 void update_vgpr_sgpr_demand(Program* program, const RegisterDemand new_demand);
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 952f980a0af6c..2fa01cef87c9e 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -93,6 +93,16 @@ struct aco_tcs_epilog_info {
    struct ac_arg tcs_offchip_layout;
 };
 
+struct aco_gl_vs_prolog_info {
+   uint16_t instance_divisor_is_one;
+   uint16_t instance_divisor_is_fetched;
+   unsigned instance_diviser_buf_offset;
+   unsigned num_inputs;
+   bool as_ls;
+
+   struct ac_arg internal_bindings;
+};
+
 struct aco_shader_info {
    enum ac_hw_stage hw_stage;
    uint8_t wave_size;
-- 
GitLab


From 42426321e6c7a45d7f2533e8d823cc0841fe5cf4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 5 Aug 2023 16:18:47 +0800
Subject: [PATCH 04/10] aco: add aco compile interface for radeonsi vs prolog

Radeonsi prolog does not need s_endpgm.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_interface.cpp | 19 ++++++++++++++++---
 src/amd/compiler/aco_interface.h   |  6 ++++++
 2 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 3b5148b6be459..51f0cbdcfc298 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -348,7 +348,8 @@ static void
 aco_compile_shader_part(const struct aco_compiler_options* options,
                         const struct aco_shader_info* info, const struct ac_shader_args* args,
                         select_shader_part_callback select_shader_part, void* pinfo,
-                        aco_shader_part_callback* build_epilog, void** binary)
+                        aco_shader_part_callback* build_binary, void** binary,
+                        bool is_prolog = false)
 {
    aco::init();
 
@@ -369,7 +370,8 @@ aco_compile_shader_part(const struct aco_compiler_options* options,
 
    /* assembly */
    std::vector<uint32_t> code;
-   unsigned exec_size = aco::emit_program(program.get(), code);
+   bool append_endpgm = !(options->is_opengl && is_prolog);
+   unsigned exec_size = aco::emit_program(program.get(), code, NULL, append_endpgm);
 
    bool get_disasm = options->dump_shader || options->record_ir;
 
@@ -377,7 +379,7 @@ aco_compile_shader_part(const struct aco_compiler_options* options,
    if (get_disasm)
       disasm = get_disasm_string(program.get(), code, exec_size);
 
-   (*build_epilog)(binary, config.num_sgprs, config.num_vgprs, code.data(), code.size(),
+   (*build_binary)(binary, config.num_sgprs, config.num_vgprs, code.data(), code.size(),
                    disasm.data(), disasm.size());
 }
 
@@ -400,3 +402,14 @@ aco_compile_tcs_epilog(const struct aco_compiler_options* options,
    aco_compile_shader_part(options, info, args, aco::select_tcs_epilog, (void*)pinfo, build_epilog,
                            binary);
 }
+
+void
+aco_compile_gl_vs_prolog(const struct aco_compiler_options* options,
+                         const struct aco_shader_info* info,
+                         const struct aco_gl_vs_prolog_info* pinfo,
+                         const struct ac_shader_args* args, aco_shader_part_callback* build_prolog,
+                         void** binary)
+{
+   aco_compile_shader_part(options, info, args, aco::select_gl_vs_prolog, (void*)pinfo,
+                           build_prolog, binary, true);
+}
diff --git a/src/amd/compiler/aco_interface.h b/src/amd/compiler/aco_interface.h
index 44c0fad3ef8f7..e08b6b6a2e5c5 100644
--- a/src/amd/compiler/aco_interface.h
+++ b/src/amd/compiler/aco_interface.h
@@ -83,6 +83,12 @@ void aco_compile_tcs_epilog(const struct aco_compiler_options* options,
                             const struct ac_shader_args* args,
                             aco_shader_part_callback* build_epilog, void** binary);
 
+void aco_compile_gl_vs_prolog(const struct aco_compiler_options* options,
+                              const struct aco_shader_info* info,
+                              const struct aco_gl_vs_prolog_info* pinfo,
+                              const struct ac_shader_args* args,
+                              aco_shader_part_callback* build_prolog, void** binary);
+
 uint64_t aco_get_codegen_flags();
 
 #ifdef __cplusplus
-- 
GitLab


From 4b6c14b939f4c4838f69c98efe13a6c5ce7ecf00 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 4 Aug 2023 17:49:04 +0800
Subject: [PATCH 05/10] radeonsi: remove is_monolithic from vs prolog key

We do not generate vs prolog for monolithic shader any more.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.h         | 2 --
 src/gallium/drivers/radeonsi/si_shader_llvm_vs.c | 3 +--
 2 files changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 5f9860049bf4f..de5a669ce9b03 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -665,8 +665,6 @@ union si_shader_part_key {
       unsigned as_ls : 1;
       unsigned as_es : 1;
       unsigned as_ngg : 1;
-      /* Prologs for monolithic shaders shouldn't set EXEC. */
-      unsigned is_monolithic : 1;
    } vs_prolog;
    struct {
       struct si_tcs_epilog_bits states;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index c2786028ff77c..a7edd159ad29c 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -118,8 +118,7 @@ void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part
    }
 
    if (key->vs_prolog.num_merged_next_stage_vgprs) {
-      if (!key->vs_prolog.is_monolithic)
-         ac_init_exec_full_mask(&ctx->ac);
+      ac_init_exec_full_mask(&ctx->ac);
 
       if (key->vs_prolog.as_ls && ctx->screen->info.has_ls_vgpr_init_bug) {
          /* If there are no HS threads, SPI loads the LS VGPRs
-- 
GitLab


From 04b85be172d00c4ed40140b7c971d577494a1888 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 4 Aug 2023 20:06:18 +0800
Subject: [PATCH 06/10] radeonsi: extract si_get_vs_prolog_args to be shared
 with aco

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      |  37 ++++++
 .../drivers/radeonsi/si_shader_internal.h     |   3 +
 .../drivers/radeonsi/si_shader_llvm_vs.c      | 111 +++++++-----------
 3 files changed, 83 insertions(+), 68 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index d001394f6a52c..6e8411ae1892f 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -3549,3 +3549,40 @@ void si_get_tcs_epilog_args(enum amd_gfx_level gfx_level,
    for (unsigned i = 0; i < 6; i++)
       ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &tess_factors[i]);
 }
+
+void si_get_vs_prolog_args(enum amd_gfx_level gfx_level,
+                           struct si_shader_args *args,
+                           const union si_shader_part_key *key)
+{
+   memset(args, 0, sizeof(*args));
+
+   unsigned num_input_sgprs = key->vs_prolog.num_input_sgprs;
+   unsigned num_input_vgprs = key->vs_prolog.num_merged_next_stage_vgprs + 4;
+
+   struct ac_arg input_sgprs[num_input_sgprs];
+   for (unsigned i = 0; i < num_input_sgprs; i++)
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, input_sgprs + i);
+
+   struct ac_arg input_vgprs[num_input_vgprs];
+   for (unsigned i = 0; i < num_input_vgprs; i++)
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, input_vgprs + i);
+
+   if (key->vs_prolog.num_merged_next_stage_vgprs)
+      args->ac.merged_wave_info = input_sgprs[3];
+
+   unsigned first_vs_vgpr = key->vs_prolog.num_merged_next_stage_vgprs;
+   unsigned vertex_id_vgpr = first_vs_vgpr;
+   unsigned instance_id_vgpr = gfx_level >= GFX10 ?
+      first_vs_vgpr + 3 : first_vs_vgpr + (key->vs_prolog.as_ls ? 2 : 1);
+
+   args->ac.vertex_id = input_vgprs[vertex_id_vgpr];
+   args->ac.instance_id = input_vgprs[instance_id_vgpr];
+
+   if (key->vs_prolog.as_ls && gfx_level < GFX11)
+      args->ac.vs_rel_patch_id = input_vgprs[first_vs_vgpr + 1];
+
+   unsigned user_sgpr_base = key->vs_prolog.num_merged_next_stage_vgprs ? 8 : 0;
+   args->internal_bindings = input_sgprs[user_sgpr_base + SI_SGPR_INTERNAL_BINDINGS];
+   args->ac.start_instance = input_sgprs[user_sgpr_base + SI_SGPR_START_INSTANCE];
+   args->ac.base_vertex = input_sgprs[user_sgpr_base + SI_SGPR_BASE_VERTEX];
+}
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 7c3697a9675b3..95d8c3dfbe792 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -142,6 +142,9 @@ void si_get_tcs_epilog_args(enum amd_gfx_level gfx_level,
                             struct ac_arg *invocation_id,
                             struct ac_arg *tf_lds_offset,
                             struct ac_arg tess_factors[6]);
+void si_get_vs_prolog_args(enum amd_gfx_level gfx_level,
+                           struct si_shader_args *args,
+                           const union si_shader_part_key *key);
 
 /* gfx10_shader_ngg.c */
 unsigned gfx10_ngg_get_vertices_per_prim(struct si_shader *shader);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index a7edd159ad29c..6023d78c4357e 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -12,13 +12,10 @@
 
 static LLVMValueRef get_vertex_index(struct si_shader_context *ctx,
                                      struct si_vs_prolog_bits *key, unsigned input_index,
-                                     LLVMValueRef instance_divisor_constbuf,
-                                     unsigned start_instance, unsigned base_vertex)
+                                     LLVMValueRef instance_divisor_constbuf)
 {
-   LLVMValueRef instance_id = ctx->abi.instance_id_replaced ?
-      ctx->abi.instance_id_replaced : ctx->abi.instance_id;
-   LLVMValueRef vertex_id = ctx->abi.vertex_id_replaced ?
-      ctx->abi.vertex_id_replaced : ctx->abi.vertex_id;
+   LLVMValueRef instance_id = ctx->abi.instance_id;
+   LLVMValueRef vertex_id = ctx->abi.vertex_id;
 
    bool divisor_is_one = key->instance_divisor_is_one & (1u << input_index);
    bool divisor_is_fetched =key->instance_divisor_is_fetched & (1u << input_index);
@@ -46,12 +43,12 @@ static LLVMValueRef get_vertex_index(struct si_shader_context *ctx,
 
    if (divisor_is_one || divisor_is_fetched) {
       /* Add StartInstance. */
-      index = LLVMBuildAdd(ctx->ac.builder, index,
-                           LLVMGetParam(ctx->main_fn.value, start_instance), "");
+      LLVMValueRef start_instance = ac_get_arg(&ctx->ac, ctx->args->ac.start_instance);
+      index = LLVMBuildAdd(ctx->ac.builder, index, start_instance, "");
    } else {
       /* VertexID + BaseVertex */
-      index = LLVMBuildAdd(ctx->ac.builder, vertex_id,
-                           LLVMGetParam(ctx->main_fn.value, base_vertex), "");
+      LLVMValueRef base_vertex = ac_get_arg(&ctx->ac, ctx->args->ac.base_vertex);
+      index = LLVMBuildAdd(ctx->ac.builder, vertex_id, base_vertex, "");
    }
 
    return index;
@@ -75,47 +72,37 @@ static LLVMValueRef get_vertex_index(struct si_shader_context *ctx,
  */
 void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key)
 {
-   LLVMTypeRef *returns;
-   LLVMValueRef ret, func;
-   int num_returns, i;
-   unsigned first_vs_vgpr = key->vs_prolog.num_merged_next_stage_vgprs;
-   unsigned num_input_vgprs =
-      key->vs_prolog.num_merged_next_stage_vgprs + 4;
-   struct ac_arg input_sgpr_param[key->vs_prolog.num_input_sgprs];
-   struct ac_arg input_vgpr_param[10];
-   LLVMValueRef input_vgprs[10];
-   unsigned num_all_input_regs = key->vs_prolog.num_input_sgprs + num_input_vgprs;
-   unsigned user_sgpr_base = key->vs_prolog.num_merged_next_stage_vgprs ? 8 : 0;
-
-   memset(ctx->args, 0, sizeof(*ctx->args));
+   struct si_shader_args *args = ctx->args;
+   si_get_vs_prolog_args(ctx->screen->info.gfx_level, args, key);
+
+   const unsigned num_input_sgprs = args->ac.num_sgprs_used;
+   const unsigned num_input_vgprs = args->ac.num_vgprs_used;
 
    /* 4 preloaded VGPRs + vertex load indices as prolog outputs */
-   returns = alloca((num_all_input_regs + key->vs_prolog.num_inputs) * sizeof(LLVMTypeRef));
-   num_returns = 0;
+   const unsigned num_output_gprs =
+      num_input_sgprs + num_input_vgprs + key->vs_prolog.num_inputs;
+   LLVMTypeRef returns[num_output_gprs];
+   int num_returns = 0;
 
-   /* Declare input and output SGPRs. */
-   for (i = 0; i < key->vs_prolog.num_input_sgprs; i++) {
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &input_sgpr_param[i]);
+   /* Output SGPRs. */
+   for (int i = 0; i < num_input_sgprs; i++)
       returns[num_returns++] = ctx->ac.i32;
-   }
 
-   /* Preloaded VGPRs (outputs must be floats) */
-   for (i = 0; i < num_input_vgprs; i++) {
-      ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &input_vgpr_param[i]);
+   /* Output VGPRs */
+   for (int i = 0; i < num_input_vgprs; i++)
       returns[num_returns++] = ctx->ac.f32;
-   }
 
    /* Vertex load indices. */
-   for (i = 0; i < key->vs_prolog.num_inputs; i++)
+   for (int i = 0; i < key->vs_prolog.num_inputs; i++)
       returns[num_returns++] = ctx->ac.f32;
 
    /* Create the function. */
    si_llvm_create_func(ctx, "vs_prolog", returns, num_returns, 0);
-   func = ctx->main_fn.value;
+   LLVMValueRef func = ctx->main_fn.value;
 
-   for (i = 0; i < num_input_vgprs; i++) {
-      input_vgprs[i] = ac_get_arg(&ctx->ac, input_vgpr_param[i]);
-   }
+   LLVMValueRef input_vgprs[num_input_vgprs];
+   for (int i = 0; i < num_input_vgprs; i++)
+      input_vgprs[i] = LLVMGetParam(func, num_input_sgprs + i);
 
    if (key->vs_prolog.num_merged_next_stage_vgprs) {
       ac_init_exec_full_mask(&ctx->ac);
@@ -125,65 +112,53 @@ void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part
           * starting at VGPR 0. Shift them back to where they
           * belong.
           */
+         LLVMValueRef hs_thread_count =
+            si_unpack_param(ctx, args->ac.merged_wave_info, 8, 8);
          LLVMValueRef has_hs_threads =
-            LLVMBuildICmp(ctx->ac.builder, LLVMIntNE,
-                          si_unpack_param(ctx, input_sgpr_param[3], 8, 8), ctx->ac.i32_0, "");
+            LLVMBuildICmp(ctx->ac.builder, LLVMIntNE, hs_thread_count, ctx->ac.i32_0, "");
 
-         for (i = 4; i > 0; --i) {
+         for (int i = 4; i > 0; --i) {
             input_vgprs[i + 1] = LLVMBuildSelect(ctx->ac.builder, has_hs_threads,
                                                  input_vgprs[i + 1], input_vgprs[i - 1], "");
          }
       }
    }
 
-   unsigned vertex_id_vgpr = first_vs_vgpr;
-   unsigned instance_id_vgpr = ctx->screen->info.gfx_level >= GFX10
-                                  ? first_vs_vgpr + 3
-                                  : first_vs_vgpr + (key->vs_prolog.as_ls ? 2 : 1);
-
-   ctx->abi.vertex_id = input_vgprs[vertex_id_vgpr];
-   ctx->abi.instance_id = input_vgprs[instance_id_vgpr];
-   ctx->abi.vertex_id_replaced = NULL;
-   ctx->abi.instance_id_replaced = NULL;
+   ctx->abi.vertex_id = input_vgprs[args->ac.vertex_id.arg_index - num_input_sgprs];
+   ctx->abi.instance_id = input_vgprs[args->ac.instance_id.arg_index - num_input_sgprs];
 
    /* Copy inputs to outputs. This should be no-op, as the registers match,
     * but it will prevent the compiler from overwriting them unintentionally.
     */
-   ret = ctx->return_value;
-   for (i = 0; i < key->vs_prolog.num_input_sgprs; i++) {
+   LLVMValueRef ret = ctx->return_value;
+   for (int i = 0; i < num_input_sgprs; i++) {
       LLVMValueRef p = LLVMGetParam(func, i);
       ret = LLVMBuildInsertValue(ctx->ac.builder, ret, p, i, "");
    }
-   for (i = 0; i < num_input_vgprs; i++) {
-      LLVMValueRef p = input_vgprs[i];
-
-      if (i == vertex_id_vgpr)
-         p = ctx->abi.vertex_id;
-      else if (i == instance_id_vgpr)
-         p = ctx->abi.instance_id;
-
-      p = ac_to_float(&ctx->ac, p);
-      ret = LLVMBuildInsertValue(ctx->ac.builder, ret, p, key->vs_prolog.num_input_sgprs + i, "");
+   for (int i = 0; i < num_input_vgprs; i++) {
+      LLVMValueRef p = ac_to_float(&ctx->ac, input_vgprs[i]);
+      ret = LLVMBuildInsertValue(ctx->ac.builder, ret, p, num_input_sgprs + i, "");
    }
 
    /* Compute vertex load indices from instance divisors. */
    LLVMValueRef instance_divisor_constbuf = NULL;
 
    if (key->vs_prolog.states.instance_divisor_is_fetched) {
-      LLVMValueRef list = si_prolog_get_internal_bindings(ctx);
+      LLVMValueRef list = ac_get_arg(&ctx->ac, args->internal_bindings);
+      list = LLVMBuildIntToPtr(ctx->ac.builder, list,
+                               ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
+
       LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0);
       instance_divisor_constbuf = ac_build_load_to_sgpr(&ctx->ac,
          (struct ac_llvm_pointer) { .v = list, .t = ctx->ac.v4i32 }, buf_index);
    }
 
-   for (i = 0; i < key->vs_prolog.num_inputs; i++) {
+   for (int i = 0; i < key->vs_prolog.num_inputs; i++) {
       LLVMValueRef index = get_vertex_index(ctx, &key->vs_prolog.states, i,
-                                            instance_divisor_constbuf,
-                                            user_sgpr_base + SI_SGPR_START_INSTANCE,
-                                            user_sgpr_base + SI_SGPR_BASE_VERTEX);
+                                            instance_divisor_constbuf);
 
       index = ac_to_float(&ctx->ac, index);
-      ret = LLVMBuildInsertValue(ctx->ac.builder, ret, index, ctx->args->ac.arg_count + i, "");
+      ret = LLVMBuildInsertValue(ctx->ac.builder, ret, index, args->ac.arg_count + i, "");
    }
 
    si_llvm_build_ret(ctx, ret);
-- 
GitLab


From 22d4b5e2815a186ad683077d7a4d6b9b7d2d390f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 4 Aug 2023 20:50:28 +0800
Subject: [PATCH 07/10] radeonsi: fix aco options has_ls_vgpr_init_bug setup

Fixes: b313d950e23 ("radeonsi: enable aco compile for mono merged LS/HS")
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index aaf2c2188a3f3..5c92affb651e2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -48,6 +48,7 @@ si_fill_aco_options(struct si_screen *screen, gl_shader_stage stage,
    options->record_ir = screen->record_llvm_ir;
    options->is_opengl = true;
 
+   options->has_ls_vgpr_init_bug = screen->info.has_ls_vgpr_init_bug;
    options->load_grid_size_from_user_sgpr = true;
    options->family = screen->info.family;
    options->gfx_level = screen->info.gfx_level;
-- 
GitLab


From c899c02035e862e8187cd35062fb2f1b4090c1b8 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 5 Aug 2023 16:56:33 +0800
Subject: [PATCH 08/10] radeonsi: add vs prolog aco build

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 31 ++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 5c92affb651e2..592fd1d4e99e2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -299,6 +299,35 @@ si_aco_build_tcs_epilog(struct si_screen *screen,
    return true;
 }
 
+static bool
+si_aco_build_vs_prolog(struct si_screen *screen,
+                       struct aco_compiler_options *options,
+                       struct si_shader_part *result)
+{
+   const union si_shader_part_key *key = &result->key;
+
+   struct si_shader_args args;
+   si_get_vs_prolog_args(screen->info.gfx_level, &args, key);
+
+   struct aco_gl_vs_prolog_info pinfo = {
+      .instance_divisor_is_one = key->vs_prolog.states.instance_divisor_is_one,
+      .instance_divisor_is_fetched = key->vs_prolog.states.instance_divisor_is_fetched,
+      .instance_diviser_buf_offset = SI_VS_CONST_INSTANCE_DIVISORS * 16,
+      .num_inputs = key->vs_prolog.num_inputs,
+      .as_ls = key->vs_prolog.as_ls,
+
+      .internal_bindings = args.internal_bindings,
+   };
+
+   struct aco_shader_info info = {0};
+   info.hw_stage = AC_HW_COMPUTE_SHADER;
+   info.workgroup_size = info.wave_size = key->vs_prolog.wave32 ? 32 : 64,
+
+   aco_compile_gl_vs_prolog(options, &info, &pinfo, &args.ac,
+                            si_aco_build_shader_part_binary, (void **)result);
+   return true;
+}
+
 bool
 si_aco_build_shader_part(struct si_screen *screen, gl_shader_stage stage, bool prolog,
                          struct util_debug_callback *debug, const char *name,
@@ -308,6 +337,8 @@ si_aco_build_shader_part(struct si_screen *screen, gl_shader_stage stage, bool p
    si_fill_aco_options(screen, stage, &options, debug);
 
    switch (stage) {
+   case MESA_SHADER_VERTEX:
+      return si_aco_build_vs_prolog(screen, &options, result);
    case MESA_SHADER_TESS_CTRL:
       return si_aco_build_tcs_epilog(screen, &options, result);
       break;
-- 
GitLab


From 829066c1c3d32c1200908e829e351873aabb6989 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 5 Aug 2023 20:30:05 +0800
Subject: [PATCH 09/10] radeonsi: set vs has prolog aco shader info

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 592fd1d4e99e2..a6b5a8279afbd 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -82,7 +82,13 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info,
    }
 
    switch (stage) {
-   case MESA_SHADER_TESS_CTRL:
+   case MESA_SHADER_VERTEX:
+      if (!shader->is_gs_copy_shader)
+         info->vs.has_prolog = si_vs_needs_prolog(sel, &key->ge.part.vs.prolog);
+      break;
+   case MESA_SHADER_TESS_CTRL: {
+      const struct si_shader_selector *ls = key->ge.part.tcs.ls;
+      info->vs.has_prolog = ls ? si_vs_needs_prolog(ls, &key->ge.part.tcs.ls_prolog) : false;
       info->vs.tcs_in_out_eq = key->ge.opt.same_patch_vertices;
       info->vs.tcs_temp_only_input_mask = sel->info.tcs_vgpr_only_inputs;
       info->has_epilog = !shader->is_monolithic;
@@ -92,6 +98,13 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info,
       info->tcs.tes_offchip_addr = args->tes_offchip_addr;
       info->tcs.vs_state_bits = args->vs_state_bits;
       break;
+   }
+   case MESA_SHADER_GEOMETRY: {
+      const struct si_shader_selector *es = key->ge.part.gs.es;
+      if (es && es->stage == MESA_SHADER_VERTEX)
+         info->vs.has_prolog = si_vs_needs_prolog(es, &key->ge.part.gs.vs_prolog);
+      break;
+   }
    case MESA_SHADER_FRAGMENT:
       info->ps.num_interp = si_get_ps_num_interp(shader);
       info->ps.spi_ps_input = shader->config.spi_ps_input_ena;
-- 
GitLab


From 72c322ff528dac112c8c72a45121aa8a60a89405 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 5 Aug 2023 17:24:55 +0800
Subject: [PATCH 10/10] radeonsi: enable aco compile for part mode standalone
 vs

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 20 +++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 6e8411ae1892f..eb3ce793f0bce 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2399,8 +2399,6 @@ static void si_determine_use_aco(struct si_shader *shader)
 
    switch (sel->stage) {
    case MESA_SHADER_VERTEX:
-      shader->use_aco = shader->is_monolithic;
-      break;
    case MESA_SHADER_TESS_CTRL:
    case MESA_SHADER_TESS_EVAL:
    case MESA_SHADER_GEOMETRY:
@@ -2899,9 +2897,21 @@ si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
    result = CALLOC_STRUCT(si_shader_part);
    result->key = *key;
 
-   bool use_aco =
-      (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics &&
-      stage == MESA_SHADER_TESS_CTRL && sscreen->info.gfx_level <= GFX8;
+   bool use_aco = (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics;
+   if (use_aco) {
+      switch (stage) {
+      case MESA_SHADER_VERTEX:
+         use_aco = sscreen->info.gfx_level <= GFX8 ||
+            !(key->vs_prolog.as_ls || key->vs_prolog.as_es);
+         break;
+      case MESA_SHADER_TESS_CTRL:
+         use_aco = sscreen->info.gfx_level <= GFX8;
+         break;
+      default:
+         use_aco = false;
+         break;
+      }
+   }
 
    bool ok = use_aco ?
       si_aco_build_shader_part(sscreen, stage, prolog, debug, name, result) :
-- 
GitLab

