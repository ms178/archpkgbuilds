From e53265896ee244a1dabc2d40cf742f7d9a643fde Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 30 Sep 2022 19:31:47 +0100
Subject: [PATCH 03/10] radv: switch to pipe_stream_output_info

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_aco_shader_info.h | 12 ++++++++++--
 src/amd/vulkan/radv_cmd_buffer.c      |  6 +++---
 src/amd/vulkan/radv_nir_to_llvm.c     | 16 ++++++++--------
 src/amd/vulkan/radv_shader.c          |  4 ++--
 src/amd/vulkan/radv_shader.h          | 20 ++++----------------
 src/amd/vulkan/radv_shader_args.c     |  2 +-
 src/amd/vulkan/radv_shader_info.c     | 19 ++++++++++---------
 7 files changed, 38 insertions(+), 41 deletions(-)

diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 175a2ab53f1b..bd20336f22fe 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -39,8 +39,16 @@ radv_aco_convert_shader_so_info(struct aco_shader_info *aco_info,
                        const struct radv_shader_info *radv)
 {
    ASSIGN_FIELD(so.num_outputs);
-   ASSIGN_FIELD_CP(so.outputs);
-   ASSIGN_FIELD_CP(so.strides);
+   for (unsigned i = 0; i < ACO_MAX_SO_OUTPUTS; i++) {
+      struct aco_stream_output *dst = &aco_info->so.outputs[i];
+      const struct pipe_stream_output *src = &radv->so.output[i];
+      dst->location = src->register_index;
+      dst->buffer = src->output_buffer;
+      dst->offset = src->dst_offset * 4;
+      dst->component_mask = u_bit_consecutive(src->start_component, src->num_components);
+      dst->stream = src->stream;
+   }
+   memcpy(&aco_info->so.strides, radv->so.stride, sizeof(radv->so.stride));
    /* enabled_stream_buffers_mask unused */
 }
 
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f7cbd2d33c58..6a4205be7d0a 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9823,7 +9823,7 @@ radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer)
    uint32_t enabled_stream_buffers_mask = 0;
 
    if (pipeline && pipeline->streamout_shader) {
-      enabled_stream_buffers_mask = pipeline->streamout_shader->info.so.enabled_stream_buffers_mask;
+      enabled_stream_buffers_mask = pipeline->streamout_shader->info.enabled_stream_buffers_mask;
    }
 
    radeon_set_context_reg_seq(cs, R_028B94_VGT_STRMOUT_CONFIG, 2);
@@ -9920,8 +9920,8 @@ radv_emit_streamout_begin(struct radv_cmd_buffer *cmd_buffer, uint32_t firstCoun
        * SGPRs what to do.
        */
       radeon_set_context_reg_seq(cs, R_028AD0_VGT_STRMOUT_BUFFER_SIZE_0 + 16 * i, 2);
-      radeon_emit(cs, sb[i].size >> 2);     /* BUFFER_SIZE (in DW) */
-      radeon_emit(cs, info->so.strides[i]); /* VTX_STRIDE (in DW) */
+      radeon_emit(cs, sb[i].size >> 2);    /* BUFFER_SIZE (in DW) */
+      radeon_emit(cs, info->so.stride[i]); /* VTX_STRIDE (in DW) */
 
       cmd_buffer->state.context_roll_without_scissor_emitted = true;
 
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index f597cfe55f84..1c543ae7b22d 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -728,12 +728,12 @@ radv_load_output(struct radv_shader_context *ctx, unsigned index, unsigned chan)
 static void
 radv_emit_stream_output(struct radv_shader_context *ctx, LLVMValueRef const *so_buffers,
                         LLVMValueRef const *so_write_offsets,
-                        const struct radv_stream_output *output,
+                        const struct pipe_stream_output *output,
                         struct radv_shader_output_values *shader_out)
 {
-   unsigned num_comps = util_bitcount(output->component_mask);
-   unsigned buf = output->buffer;
-   unsigned offset = output->offset;
+   unsigned num_comps = output->num_components;
+   unsigned buf = output->output_buffer;
+   unsigned offset = output->dst_offset * 4;
    unsigned start;
    LLVMValueRef out[4];
 
@@ -742,7 +742,7 @@ radv_emit_stream_output(struct radv_shader_context *ctx, LLVMValueRef const *so_
       return;
 
    /* Get the first component. */
-   start = ffs(output->component_mask) - 1;
+   start = output->start_component;
 
    /* Load the output as int. */
    for (int i = 0; i < num_comps; i++) {
@@ -809,7 +809,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
       struct ac_llvm_pointer buf_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
 
       for (i = 0; i < 4; i++) {
-         uint16_t stride = ctx->shader_info->so.strides[i];
+         uint16_t stride = ctx->shader_info->so.stride[i];
 
          if (!stride)
             continue;
@@ -830,13 +830,13 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
       /* Write streamout data. */
       for (i = 0; i < ctx->shader_info->so.num_outputs; i++) {
          struct radv_shader_output_values shader_out = {0};
-         const struct radv_stream_output *output = &ctx->shader_info->so.outputs[i];
+         const struct pipe_stream_output *output = &ctx->shader_info->so.output[i];
 
          if (stream != output->stream)
             continue;
 
          for (int j = 0; j < 4; j++) {
-            shader_out.values[j] = radv_load_output(ctx, output->location, j);
+            shader_out.values[j] = radv_load_output(ctx, output->register_index, j);
          }
 
          radv_emit_stream_output(ctx, so_buffers, so_write_offset, output, &shader_out);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 1b18d3a6d854..209b4329ded4 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1736,8 +1736,8 @@ radv_postprocess_config(const struct radv_device *device, const struct ac_shader
 
    if (!pdevice->use_ngg_streamout) {
       config_out->rsrc2 |=
-         S_00B12C_SO_BASE0_EN(!!info->so.strides[0]) | S_00B12C_SO_BASE1_EN(!!info->so.strides[1]) |
-         S_00B12C_SO_BASE2_EN(!!info->so.strides[2]) | S_00B12C_SO_BASE3_EN(!!info->so.strides[3]) |
+         S_00B12C_SO_BASE0_EN(!!info->so.stride[0]) | S_00B12C_SO_BASE1_EN(!!info->so.stride[1]) |
+         S_00B12C_SO_BASE2_EN(!!info->so.stride[2]) | S_00B12C_SO_BASE3_EN(!!info->so.stride[3]) |
          S_00B12C_SO_EN(!!info->so.num_outputs);
    }
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 25156ea0c691..5181a42777b4 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -41,6 +41,8 @@
 
 #include "aco_shader_info.h"
 
+#include "pipe/p_state.h"
+
 #define RADV_VERT_ATTRIB_MAX MAX2(VERT_ATTRIB_MAX, VERT_ATTRIB_GENERIC0 + MAX_VERTEX_ATTRIBS)
 
 struct radv_physical_device;
@@ -168,21 +170,6 @@ enum radv_ud_index {
    AC_UD_MAX_UD = AC_UD_CS_MAX_UD,
 };
 
-struct radv_stream_output {
-   uint8_t location;
-   uint8_t buffer;
-   uint16_t offset;
-   uint8_t component_mask;
-   uint8_t stream;
-};
-
-struct radv_streamout_info {
-   uint16_t num_outputs;
-   struct radv_stream_output outputs[MAX_SO_OUTPUTS];
-   uint16_t strides[MAX_SO_BUFFERS];
-   uint32_t enabled_stream_buffers_mask;
-};
-
 struct radv_userdata_info {
    int8_t sgpr_idx;
    uint8_t num_sgprs;
@@ -365,7 +352,8 @@ struct radv_shader_info {
       bool has_task; /* If mesh shader is used together with a task shader. */
    } ms;
 
-   struct radv_streamout_info so;
+   struct pipe_stream_output_info so;
+   uint32_t enabled_stream_buffers_mask;
 
    struct gfx9_gs_info gs_ring_info;
    struct gfx10_ngg_info ngg_info;
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index 10b83fef4eca..a5778661553c 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -389,7 +389,7 @@ declare_streamout_sgprs(const struct radv_shader_info *info, struct radv_shader_
 
    /* A streamout buffer offset is loaded if the stride is non-zero. */
    for (i = 0; i < 4; i++) {
-      if (!info->so.strides[i])
+      if (!info->so.stride[i])
          continue;
 
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.streamout_offset[i]);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 72d4e586edca..d5c319fa5059 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -277,7 +277,7 @@ mark_16bit_ps_input(struct radv_shader_info *info, const struct glsl_type *type,
 static void
 gather_xfb_info(const nir_shader *nir, struct radv_shader_info *info)
 {
-   struct radv_streamout_info *so = &info->so;
+   struct pipe_stream_output_info *so = &info->so;
 
    if (!nir->xfb_info)
       return;
@@ -287,19 +287,20 @@ gather_xfb_info(const nir_shader *nir, struct radv_shader_info *info)
    so->num_outputs = xfb->output_count;
 
    for (unsigned i = 0; i < xfb->output_count; i++) {
-      struct radv_stream_output *output = &so->outputs[i];
+      struct pipe_stream_output *output = &so->output[i];
 
-      output->buffer = xfb->outputs[i].buffer;
+      output->output_buffer = xfb->outputs[i].buffer;
       output->stream = xfb->buffer_to_stream[xfb->outputs[i].buffer];
-      output->offset = xfb->outputs[i].offset;
-      output->location = xfb->outputs[i].location;
-      output->component_mask = xfb->outputs[i].component_mask;
+      output->dst_offset = xfb->outputs[i].offset / 4;
+      output->register_index = xfb->outputs[i].location;
+      output->start_component = xfb->outputs[i].component_offset;
+      output->num_components = util_bitcount(xfb->outputs[i].component_mask);
 
-      so->enabled_stream_buffers_mask |= (1 << output->buffer) << (output->stream * 4);
+      info->enabled_stream_buffers_mask |= (1 << output->output_buffer) << (output->stream * 4);
    }
 
    for (unsigned i = 0; i < NIR_MAX_XFB_BUFFERS; i++) {
-      so->strides[i] = xfb->buffers[i].stride / 4;
+      so->stride[i] = xfb->buffers[i].stride / 4;
    }
 }
 
@@ -1046,7 +1047,7 @@ gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage
    } else {
       /* VS and TES. */
       /* LDS size for passing data from GS to ES. */
-      struct radv_streamout_info *so_info = &es_info->so;
+      struct pipe_stream_output_info *so_info = &es_info->so;
 
       if (so_info->num_outputs)
          esvert_lds_size = 4 * so_info->num_outputs + 1;
-- 
GitLab


From d7584750912e2b96f44d85f146f578ce7da8dcd7 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 27 Sep 2022 19:26:11 +0100
Subject: [PATCH 04/10] radv,aco: export legacy vertex outputs in NIR

This new behaviour will let us insert exports in GS copy shader control
flow.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    |  5 +-
 src/amd/vulkan/radv_nir_to_llvm.c             | 26 ++-------
 src/amd/vulkan/radv_pipeline.c                | 56 ++-----------------
 src/amd/vulkan/radv_shader_info.c             |  2 +-
 4 files changed, 11 insertions(+), 78 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 16babf604535..e364588785dd 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -9126,7 +9126,6 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       break;
    }
    case nir_intrinsic_export_vertex_amd: {
-      ctx->block->kind |= block_kind_export_end;
       create_vs_exports(ctx);
       break;
    }
@@ -11895,9 +11894,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
       if (ctx.program->info.so.num_outputs && ctx.stage.hw == HWStage::VS)
          emit_streamout(&ctx, 0);
 
-      if (ctx.stage.hw == HWStage::VS) {
-         create_vs_exports(&ctx);
-      } else if (nir->info.stage == MESA_SHADER_GEOMETRY && !ngg_gs) {
+      if (nir->info.stage == MESA_SHADER_GEOMETRY && !ngg_gs) {
          Builder bld(ctx.program, ctx.block);
          bld.barrier(aco_opcode::p_barrier,
                      memory_sync_info(storage_vmem_output, semantic_release, scope_device));
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 1c543ae7b22d..bf865f7e296f 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -1133,15 +1133,9 @@ handle_shader_outputs_post(struct ac_shader_abi *abi)
 
    switch (ctx->stage) {
    case MESA_SHADER_VERTEX:
-      if (ctx->shader_info->vs.as_ls)
-         break; /* Lowered in NIR */
-      else if (ctx->shader_info->vs.as_es)
-         break; /* Lowered in NIR */
-      else if (ctx->shader_info->is_ngg)
-         break; /* Lowered in NIR */
-      else
-         handle_vs_outputs_post(ctx);
-      break;
+   case MESA_SHADER_TESS_CTRL:
+   case MESA_SHADER_TESS_EVAL:
+      break; /* Lowered in NIR */
    case MESA_SHADER_FRAGMENT:
       handle_fs_outputs_post(ctx);
       break;
@@ -1151,16 +1145,6 @@ handle_shader_outputs_post(struct ac_shader_abi *abi)
       else
          emit_gs_epilogue(ctx);
       break;
-   case MESA_SHADER_TESS_CTRL:
-      break; /* Lowered in NIR */
-   case MESA_SHADER_TESS_EVAL:
-      if (ctx->shader_info->tes.as_es)
-         break; /* Lowered in NIR */
-      else if (ctx->shader_info->is_ngg)
-         break; /* Lowered in NIR */
-      else
-         handle_vs_outputs_post(ctx);
-      break;
    default:
       break;
    }
@@ -1393,8 +1377,6 @@ ac_translate_nir_to_llvm(struct ac_llvm_compiler *ac_llvm,
       ac_nir_fixup_ls_hs_input_vgprs(&ctx);
 
    if (is_ngg) {
-      ctx.abi.export_vertex = radv_llvm_visit_export_vertex;
-
       if (!info->is_ngg_passthrough)
          declare_esgs_ring(&ctx);
 
@@ -1429,7 +1411,9 @@ ac_translate_nir_to_llvm(struct ac_llvm_compiler *ac_llvm,
          ctx.abi.emit_vertex_with_counter = visit_emit_vertex_with_counter;
          ctx.abi.emit_primitive = visit_end_primitive;
       } else if (shaders[shader_idx]->info.stage == MESA_SHADER_TESS_EVAL) {
+         ctx.abi.export_vertex = radv_llvm_visit_export_vertex;
       } else if (shaders[shader_idx]->info.stage == MESA_SHADER_VERTEX) {
+         ctx.abi.export_vertex = radv_llvm_visit_export_vertex;
          ctx.abi.load_inputs = radv_load_vs_inputs;
       }
 
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 598b1de83823..9c29a9aa6c55 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2193,50 +2193,6 @@ radv_export_multiview(nir_shader *nir)
    return progress;
 }
 
-static bool
-radv_should_export_implicit_primitive_id(const struct radv_pipeline_stage *producer,
-                                         const struct radv_pipeline_stage *consumer)
-{
-   /* When the primitive ID is read by FS, we must ensure that it's exported by the previous vertex
-    * stage because it's implicit for VS or TES (but required by the Vulkan spec for GS or MS).
-    *
-    * There is two situations to handle:
-    *  - when the next stage is unknown (with graphics pipeline library), the primitive ID is
-    *  exported unconditionally
-    *  - when the pipeline uses NGG, the primitive ID is exported during NGG lowering
-    */
-   assert(producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL);
-
-   if ((producer->nir->info.outputs_written & VARYING_BIT_PRIMITIVE_ID) || producer->info.is_ngg)
-      return false;
-
-   return !consumer || (consumer->stage == MESA_SHADER_FRAGMENT &&
-          (consumer->nir->info.inputs_read & VARYING_BIT_PRIMITIVE_ID));
-}
-
-static bool
-radv_export_implicit_primitive_id(nir_shader *nir)
-{
-   nir_function_impl *impl = nir_shader_get_entrypoint(nir);
-   nir_builder b;
-   nir_builder_init(&b, impl);
-
-   b.cursor = nir_after_cf_list(&impl->body);
-
-   nir_variable *var = nir_variable_create(nir, nir_var_shader_out, glsl_int_type(), NULL);
-   var->data.location = VARYING_SLOT_PRIMITIVE_ID;
-   var->data.interpolation = INTERP_MODE_NONE;
-
-   nir_store_var(&b, var, nir_load_primitive_id(&b), 1);
-
-   /* Update outputs_written to reflect that the pass added a new output. */
-   nir->info.outputs_written |= BITFIELD64_BIT(VARYING_SLOT_PRIMITIVE_ID);
-
-   nir_metadata_preserve(impl, nir_metadata_block_index | nir_metadata_dominance);
-
-   return true;
-}
-
 static void
 radv_remove_point_size(const struct radv_pipeline_key *pipeline_key,
                        nir_shader *producer, nir_shader *consumer)
@@ -2519,10 +2475,6 @@ radv_pipeline_link_vs(const struct radv_device *device, struct radv_pipeline_sta
 {
    assert(vs_stage->nir->info.stage == MESA_SHADER_VERTEX);
 
-   if (radv_should_export_implicit_primitive_id(vs_stage, next_stage)) {
-      NIR_PASS(_, vs_stage->nir, radv_export_implicit_primitive_id);
-   }
-
    if (radv_should_export_multiview(vs_stage, next_stage, pipeline_key)) {
       NIR_PASS(_, vs_stage->nir, radv_export_multiview);
    }
@@ -2589,10 +2541,6 @@ radv_pipeline_link_tes(const struct radv_device *device, struct radv_pipeline_st
 {
    assert(tes_stage->nir->info.stage == MESA_SHADER_TESS_EVAL);
 
-   if (radv_should_export_implicit_primitive_id(tes_stage, next_stage)) {
-      NIR_PASS(_, tes_stage->nir, radv_export_implicit_primitive_id);
-   }
-
    if (radv_should_export_multiview(tes_stage, next_stage, pipeline_key)) {
       NIR_PASS(_, tes_stage->nir, radv_export_multiview);
    }
@@ -3893,6 +3841,10 @@ radv_postprocess_nir(struct radv_pipeline *pipeline,
    if (lowered_ngg)
       radv_lower_ngg(device, stage, pipeline_key);
 
+   if (stage->stage == last_vgt_api_stage && stage->stage != MESA_SHADER_GEOMETRY && !lowered_ngg)
+      NIR_PASS_V(stage->nir, ac_nir_lower_legacy_vs,
+                 stage->info.outinfo.export_prim_id ? VARYING_SLOT_PRIMITIVE_ID : -1, NULL);
+
    NIR_PASS(_, stage->nir, ac_nir_lower_global_access);
    NIR_PASS_V(stage->nir, radv_nir_lower_abi, gfx_level, &stage->info, &stage->args, pipeline_key,
               radv_use_llvm_for_stage(device, stage->stage),
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index d5c319fa5059..e33d104b0bd1 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1261,7 +1261,7 @@ radv_link_shaders_info(struct radv_device *device,
 
       if (ps_prim_id_in &&
           (producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL)) {
-         /* Mark the primitive ID as output when it's implicitly exported by VS or TES with NGG. */
+         /* Mark the primitive ID as output when it's implicitly exported by VS or TES. */
          if (outinfo->vs_output_param_offset[VARYING_SLOT_PRIMITIVE_ID] == AC_EXP_PARAM_UNDEFINED)
             outinfo->vs_output_param_offset[VARYING_SLOT_PRIMITIVE_ID] = outinfo->param_exports++;
 
-- 
GitLab


From 20a8cdad5e9b9bfb1fd3421c89860ca788603613 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 28 Sep 2022 17:17:35 +0100
Subject: [PATCH 05/10] radv: lower streamout in NIR

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 3 ---
 src/amd/vulkan/radv_nir_to_llvm.c              | 5 -----
 src/amd/vulkan/radv_pipeline.c                 | 3 ++-
 3 files changed, 2 insertions(+), 9 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index e364588785dd..ceeb333c9a3d 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11891,9 +11891,6 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
 
       visit_cf_list(&ctx, &func->body);
 
-      if (ctx.program->info.so.num_outputs && ctx.stage.hw == HWStage::VS)
-         emit_streamout(&ctx, 0);
-
       if (nir->info.stage == MESA_SHADER_GEOMETRY && !ngg_gs) {
          Builder bld(ctx.program, ctx.block);
          bld.barrier(aco_opcode::p_barrier,
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index bf865f7e296f..c29f41c13444 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -1001,11 +1001,6 @@ handle_vs_outputs_post(struct radv_shader_context *ctx)
    struct radv_shader_output_values *outputs;
    unsigned noutput = 0;
 
-   if (ctx->shader_info->so.num_outputs && !ctx->args->is_gs_copy_shader && ctx->stage != MESA_SHADER_GEOMETRY) {
-      /* The GS copy shader emission already emits streamout. */
-      radv_emit_streamout(ctx, 0);
-   }
-
    /* Allocate a temporary array for the output values. */
    unsigned num_outputs = util_bitcount64(ctx->output_mask);
    outputs = malloc(num_outputs * sizeof(outputs[0]));
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 9c29a9aa6c55..c269894408e6 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3843,7 +3843,8 @@ radv_postprocess_nir(struct radv_pipeline *pipeline,
 
    if (stage->stage == last_vgt_api_stage && stage->stage != MESA_SHADER_GEOMETRY && !lowered_ngg)
       NIR_PASS_V(stage->nir, ac_nir_lower_legacy_vs,
-                 stage->info.outinfo.export_prim_id ? VARYING_SLOT_PRIMITIVE_ID : -1, NULL);
+                 stage->info.outinfo.export_prim_id ? VARYING_SLOT_PRIMITIVE_ID : -1,
+                 &stage->info.so);
 
    NIR_PASS(_, stage->nir, ac_nir_lower_global_access);
    NIR_PASS_V(stage->nir, radv_nir_lower_abi, gfx_level, &stage->info, &stage->args, pipeline_key,
-- 
GitLab


From 87fbb0d7af2b661475caa57c66e3fcf02d435f04 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 30 Sep 2022 11:40:18 +0100
Subject: [PATCH 06/10] radv: make radv_use_llvm_for_stage device parameter
 const

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_private.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index e0ce26a2bdbf..5e529b3b8948 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3138,7 +3138,7 @@ radv_queue_ring(struct radv_queue *queue)
  * specific shader stage (developers only).
  */
 static inline bool
-radv_use_llvm_for_stage(struct radv_device *device, UNUSED gl_shader_stage stage)
+radv_use_llvm_for_stage(const struct radv_device *device, UNUSED gl_shader_stage stage)
 {
    return device->physical_device->use_llvm;
 }
-- 
GitLab


From f3b5536be7e242167b2713f3877c764099c9170b Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 29 Sep 2022 12:43:05 +0100
Subject: [PATCH 07/10] radv,aco: implement GS copy shaders using NIR

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    |  7 +++--
 src/amd/compiler/aco_interface.cpp            |  4 +--
 src/amd/vulkan/radv_nir_to_llvm.c             | 16 +++++------
 src/amd/vulkan/radv_pipeline.c                | 27 +++++++++++++------
 src/amd/vulkan/radv_shader.c                  | 21 +++++++--------
 src/amd/vulkan/radv_shader_info.c             |  2 +-
 6 files changed, 41 insertions(+), 36 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index ceeb333c9a3d..f257e5406402 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -7769,10 +7769,9 @@ visit_emit_vertex_with_counter(isel_context* ctx, nir_intrinsic_instr* instr)
 
    unsigned offset = 0;
    for (unsigned i = 0; i <= VARYING_SLOT_VAR31; i++) {
-      if (ctx->program->info.gs.output_streams[i] != stream)
-         continue;
-
       for (unsigned j = 0; j < 4; j++) {
+         if (((ctx->program->info.gs.output_streams[i] >> (j * 2)) & 0x3) != stream)
+            continue;
          if (!(ctx->program->info.gs.output_usage_mask[i] & (1 << j)))
             continue;
 
@@ -11975,7 +11974,7 @@ select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_
 
       unsigned offset = 0;
       for (unsigned i = 0; i <= VARYING_SLOT_VAR31; ++i) {
-         if (program->info.gs.output_streams[i] != stream)
+         if ((program->info.gs.output_streams[i] & 0x3) != stream)
             continue;
 
          unsigned output_usage_mask = program->info.gs.output_usage_mask[i];
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 03544424c2e7..b2bf8dedf821 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -231,9 +231,7 @@ aco_compile_shader(const struct aco_compiler_options* options,
    program->debug.private_data = options->debug.private_data;
 
    /* Instruction Selection */
-   if (args->is_gs_copy_shader)
-      aco::select_gs_copy_shader(program.get(), shaders[0], &config, options, info, args);
-   else if (args->is_trap_handler_shader)
+   if (args->is_trap_handler_shader)
       aco::select_trap_handler_shader(program.get(), shaders[0], &config, options, info, args);
    else
       aco::select_program(program.get(), shader_count, shaders, &config, options, info, args);
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index c29f41c13444..323e48a2405f 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -205,10 +205,12 @@ visit_emit_vertex_with_counter(struct ac_shader_abi *abi, unsigned stream, LLVMV
       bool *is_16bit_ptr = &abi->is_16bit[i * 4];
       int length = util_last_bit(output_usage_mask);
 
-      if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
+      if (!(ctx->output_mask & (1ull << i)))
          continue;
 
       for (unsigned j = 0; j < length; j++) {
+         if (((output_stream >> (j * 2)) & 0x3) != stream)
+            continue;
          if (!(output_usage_mask & (1 << j)))
             continue;
 
@@ -1012,11 +1014,11 @@ handle_vs_outputs_post(struct radv_shader_context *ctx)
       outputs[noutput].slot_name = i;
       outputs[noutput].slot_index = i == VARYING_SLOT_CLIP_DIST1;
 
-      if (ctx->stage == MESA_SHADER_VERTEX && !ctx->args->is_gs_copy_shader) {
+      if (ctx->stage == MESA_SHADER_VERTEX) {
          outputs[noutput].usage_mask = ctx->shader_info->vs.output_usage_mask[i];
       } else if (ctx->stage == MESA_SHADER_TESS_EVAL) {
          outputs[noutput].usage_mask = ctx->shader_info->tes.output_usage_mask[i];
-      } else if (ctx->args->is_gs_copy_shader|| ctx->stage == MESA_SHADER_GEOMETRY) {
+      } else if (ctx->stage == MESA_SHADER_GEOMETRY) {
          outputs[noutput].usage_mask = ctx->shader_info->gs.output_usage_mask[i];
       }
 
@@ -1627,7 +1629,7 @@ ac_gs_copy_shader_emit(struct radv_shader_context *ctx)
       offset = 0;
       for (unsigned i = 0; i < AC_LLVM_MAX_OUTPUTS; ++i) {
          unsigned output_usage_mask = ctx->shader_info->gs.output_usage_mask[i];
-         unsigned output_stream = ctx->shader_info->gs.output_streams[i];
+         unsigned output_stream = ctx->shader_info->gs.output_streams[i] & 0x3;
          int length = util_last_bit(output_usage_mask);
 
          if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
@@ -1730,9 +1732,5 @@ llvm_compile_shader(const struct radv_nir_compiler_options *options,
 
    radv_init_llvm_compiler(&ac_llvm, options->family, tm_options, info->wave_size);
 
-   if (args->is_gs_copy_shader) {
-      radv_compile_gs_copy_shader(&ac_llvm, options, info, *shaders, binary, args);
-   } else {
-      radv_compile_nir_shader(&ac_llvm, options, info, binary, args, shaders, shader_count);
-   }
+   radv_compile_nir_shader(&ac_llvm, options, info, binary, args, shaders, shader_count);
 }
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index c269894408e6..0457c77c2ea6 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3585,15 +3585,23 @@ radv_pipeline_create_gs_copy_shader(struct radv_pipeline *pipeline,
                                     bool keep_executable_info, bool keep_statistic_info)
 {
    struct radv_device *device = pipeline->device;
-   struct radv_shader_info info = {0};
 
-   radv_nir_shader_info_pass(device, stages[MESA_SHADER_GEOMETRY].nir, pipeline_layout, pipeline_key,
-                             &info);
+   const struct radv_shader_info *gs_info = &stages[MESA_SHADER_GEOMETRY].info;
+   nir_shader *nir = ac_nir_create_gs_copy_shader(stages[MESA_SHADER_GEOMETRY].nir,
+                                                  &gs_info->so, VARYING_SLOT_MAX,
+                                                  gs_info->gs.output_usage_mask,
+                                                  gs_info->gs.output_streams, NULL,
+                                                  gs_info->gs.num_stream_output_components);
+   nir_validate_shader(nir, "after ac_nir_create_gs_copy_shader");
+   nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
+
+   struct radv_shader_info info = {0};
+   radv_nir_shader_info_pass(device, nir, pipeline_layout, pipeline_key, &info);
    info.wave_size = 64; /* Wave32 not supported. */
    info.workgroup_size = 64; /* HW VS: separate waves, no workgroups */
-   info.ballot_bit_size = 64;
+   info.so = gs_info->so;
 
-   if (stages[MESA_SHADER_GEOMETRY].info.outinfo.export_clip_dists) {
+   if (gs_info->outinfo.export_clip_dists) {
       if (stages[MESA_SHADER_GEOMETRY].nir->info.outputs_written & VARYING_BIT_CLIP_DIST0)
          info.outinfo.vs_output_param_offset[VARYING_SLOT_CLIP_DIST0] = info.outinfo.param_exports++;
       if (stages[MESA_SHADER_GEOMETRY].nir->info.outputs_written & VARYING_BIT_CLIP_DIST1)
@@ -3610,9 +3618,12 @@ radv_pipeline_create_gs_copy_shader(struct radv_pipeline *pipeline,
    info.user_sgprs_locs = gs_copy_args.user_sgprs_locs;
    info.inline_push_constant_mask = gs_copy_args.ac.inline_push_const_mask;
 
-   return radv_create_gs_copy_shader(device, stages[MESA_SHADER_GEOMETRY].nir, &info, &gs_copy_args,
-                                     keep_executable_info, keep_statistic_info,
-                                     pipeline_key->optimisations_disabled);
+   NIR_PASS_V(nir, radv_nir_lower_abi, device->physical_device->rad_info.gfx_level, &info,
+              &gs_copy_args, pipeline_key, radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX),
+              device->physical_device->rad_info.address32_hi);
+
+   return radv_create_gs_copy_shader(device, nir, &info, &gs_copy_args, keep_executable_info,
+                                     keep_statistic_info, pipeline_key->optimisations_disabled);
 }
 
 static void
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 209b4329ded4..2d468b82036e 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2278,9 +2278,9 @@ radv_aco_build_shader_binary(void **bin,
 }
 
 static struct radv_shader *
-shader_compile(struct radv_device *device, struct nir_shader *const *shaders, int shader_count, gl_shader_stage stage,
-               const struct radv_shader_info *info, const struct radv_shader_args *args,
-               struct radv_nir_compiler_options *options, bool gs_copy_shader,
+shader_compile(struct radv_device *device, struct nir_shader *const *shaders, int shader_count,
+               gl_shader_stage stage, const struct radv_shader_info *info,
+               const struct radv_shader_args *args, struct radv_nir_compiler_options *options,
                bool trap_handler_shader, bool keep_shader_info, bool keep_statistic_info)
 {
    enum radeon_family chip_family = device->physical_device->rad_info.family;
@@ -2294,7 +2294,7 @@ shader_compile(struct radv_device *device, struct nir_shader *const *shaders, in
    options->family = chip_family;
    options->gfx_level = device->physical_device->rad_info.gfx_level;
    options->has_3d_cube_border_color_mipmap = device->physical_device->rad_info.has_3d_cube_border_color_mipmap;
-   options->dump_shader = radv_can_dump_shader(device, shaders[0], gs_copy_shader || trap_handler_shader);
+   options->dump_shader = radv_can_dump_shader(device, shaders[0], trap_handler_shader);
    options->dump_preoptir =
       options->dump_shader && device->instance->debug_flags & RADV_DEBUG_PREOPTIR;
    options->record_ir = keep_shader_info;
@@ -2365,9 +2365,8 @@ radv_shader_nir_to_asm(struct radv_device *device, struct radv_pipeline_stage *p
    options.robust_buffer_access = device->robust_buffer_access;
    options.wgp_mode = radv_should_use_wgp_mode(device, stage, &pl_stage->info);
 
-   return shader_compile(device, shaders, shader_count, stage, &pl_stage->info,
-                         &pl_stage->args, &options, false, false, keep_shader_info,
-                         keep_statistic_info);
+   return shader_compile(device, shaders, shader_count, stage, &pl_stage->info, &pl_stage->args,
+                         &options, false, keep_shader_info, keep_statistic_info);
 }
 
 struct radv_shader *
@@ -2381,8 +2380,8 @@ radv_create_gs_copy_shader(struct radv_device *device, struct nir_shader *shader
 
    options.key.optimisations_disabled = disable_optimizations;
 
-   return shader_compile(device, &shader, 1, stage, info, args, &options, true, false,
-                         keep_shader_info, keep_statistic_info);
+   return shader_compile(device, &shader, 1, stage, info, args, &options, false, keep_shader_info,
+                         keep_statistic_info);
 }
 
 struct radv_trap_handler_shader *
@@ -2409,8 +2408,8 @@ radv_create_trap_handler_shader(struct radv_device *device)
    radv_declare_shader_args(device->physical_device->rad_info.gfx_level, &key, &info,
                             MESA_SHADER_COMPUTE, false, MESA_SHADER_VERTEX, &args);
 
-   shader = shader_compile(device, &b.shader, 1, MESA_SHADER_COMPUTE, &info, &args, &options,
-                           false, true, false, false);
+   shader = shader_compile(device, &b.shader, 1, MESA_SHADER_COMPUTE, &info, &args, &options, true,
+                           false, false);
 
    trap->alloc = radv_alloc_shader_memory(device, shader->code_size, NULL);
 
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index e33d104b0bd1..4a27c2507691 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -464,7 +464,7 @@ gather_shader_info_gs(const nir_shader *nir, struct radv_shader_info *info)
       assert(stream < 4);
 
       info->gs.num_stream_output_components[stream] += num_components;
-      info->gs.output_streams[idx] = stream;
+      info->gs.output_streams[idx] = stream | (stream << 2) | (stream << 4) | (stream << 6);
    }
 }
 
-- 
GitLab


From 63be0bda5bff23ee58efa888c719f3e24f324cf8 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 17 Oct 2022 20:26:51 +0100
Subject: [PATCH 08/10] radv,aco: remove old GS copy shader code

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 103 +------------
 src/amd/compiler/aco_instruction_selection.h  |   3 +-
 .../aco_instruction_selection_setup.cpp       |  28 ++--
 src/amd/compiler/aco_interface.cpp            |   1 -
 src/amd/compiler/aco_interface.h              |   1 -
 src/amd/compiler/aco_ir.h                     |   6 -
 src/amd/compiler/aco_print_ir.cpp             |   2 -
 src/amd/vulkan/radv_nir_to_llvm.c             | 139 +-----------------
 src/amd/vulkan/radv_shader.c                  |   5 +-
 src/amd/vulkan/radv_shader.h                  |   1 -
 10 files changed, 15 insertions(+), 274 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index f257e5406402..7ffbfc33b2fc 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11808,7 +11808,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
                const struct aco_shader_info* info,
                const struct radv_shader_args* args)
 {
-   isel_context ctx = setup_isel_context(program, shader_count, shaders, config, options, info, args, false, false);
+   isel_context ctx = setup_isel_context(program, shader_count, shaders, config, options, info, args, false);
    if_context ic_merged_wave_info;
    bool ngg_gs = ctx.stage.hw == HWStage::NGG && ctx.stage.has(SWStage::GS);
 
@@ -11926,105 +11926,6 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
    cleanup_cfg(program);
 }
 
-void
-select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_config* config,
-                      const struct aco_compiler_options* options,
-                      const struct aco_shader_info* info,
-                      const struct radv_shader_args* args)
-{
-   isel_context ctx = setup_isel_context(program, 1, &gs_shader, config, options, info, args, true, false);
-
-   ctx.block->fp_mode = program->next_fp_mode;
-
-   add_startpgm(&ctx);
-   append_logical_start(ctx.block);
-
-   Builder bld(ctx.program, ctx.block);
-
-   Temp gsvs_ring = bld.smem(aco_opcode::s_load_dwordx4, bld.def(s4),
-                             program->private_segment_buffer, Operand::c32(RING_GSVS_VS * 16u));
-
-   Operand stream_id = Operand::zero();
-   if (program->info.so.num_outputs)
-      stream_id = bld.sop2(aco_opcode::s_bfe_u32, bld.def(s1), bld.def(s1, scc),
-                           get_arg(&ctx, ctx.args->ac.streamout_config), Operand::c32(0x20018u));
-
-   Temp vtx_offset = bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(2u),
-                              get_arg(&ctx, ctx.args->ac.vertex_id));
-
-   std::stack<if_context, std::vector<if_context>> if_contexts;
-
-   for (unsigned stream = 0; stream < 4; stream++) {
-      if (stream_id.isConstant() && stream != stream_id.constantValue())
-         continue;
-
-      unsigned num_components = program->info.gs.num_stream_output_components[stream];
-      if (stream > 0 && (!num_components || !program->info.so.num_outputs))
-         continue;
-
-      memset(ctx.outputs.mask, 0, sizeof(ctx.outputs.mask));
-
-      if (!stream_id.isConstant()) {
-         Temp cond =
-            bld.sopc(aco_opcode::s_cmp_eq_u32, bld.def(s1, scc), stream_id, Operand::c32(stream));
-         if_contexts.emplace();
-         begin_uniform_if_then(&ctx, &if_contexts.top(), cond);
-         bld.reset(ctx.block);
-      }
-
-      unsigned offset = 0;
-      for (unsigned i = 0; i <= VARYING_SLOT_VAR31; ++i) {
-         if ((program->info.gs.output_streams[i] & 0x3) != stream)
-            continue;
-
-         unsigned output_usage_mask = program->info.gs.output_usage_mask[i];
-         unsigned length = util_last_bit(output_usage_mask);
-         for (unsigned j = 0; j < length; ++j) {
-            if (!(output_usage_mask & (1 << j)))
-               continue;
-
-            Temp val = bld.tmp(v1);
-            unsigned const_offset = offset * program->info.gs.vertices_out * 16 * 4;
-            load_vmem_mubuf(&ctx, val, gsvs_ring, vtx_offset, Temp(), Temp(), const_offset, 4, 1, 0, true,
-                            true, memory_sync_info());
-
-            ctx.outputs.mask[i] |= 1 << j;
-            ctx.outputs.temps[i * 4u + j] = val;
-
-            offset++;
-         }
-      }
-
-      if (program->info.so.num_outputs) {
-         emit_streamout(&ctx, stream);
-         bld.reset(ctx.block);
-      }
-
-      if (stream == 0) {
-         create_vs_exports(&ctx);
-      }
-
-      if (!stream_id.isConstant()) {
-         begin_uniform_if_else(&ctx, &if_contexts.top());
-         bld.reset(ctx.block);
-      }
-   }
-
-   while (!if_contexts.empty()) {
-      end_uniform_if(&ctx, &if_contexts.top());
-      if_contexts.pop();
-   }
-
-   program->config->float_mode = program->blocks[0].fp_mode.val;
-
-   append_logical_end(ctx.block);
-   ctx.block->kind |= block_kind_uniform;
-   bld.reset(ctx.block);
-   bld.sopp(aco_opcode::s_endpgm);
-
-   cleanup_cfg(program);
-}
-
 void
 select_trap_handler_shader(Program* program, struct nir_shader* shader, ac_shader_config* config,
                            const struct aco_compiler_options* options,
@@ -12441,7 +12342,7 @@ select_ps_epilog(Program* program, const struct aco_ps_epilog_key* key, ac_shade
                  const struct aco_shader_info* info,
                  const struct radv_shader_args* args)
 {
-   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, false, true);
+   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, true);
 
    ctx.block->fp_mode = program->next_fp_mode;
 
diff --git a/src/amd/compiler/aco_instruction_selection.h b/src/amd/compiler/aco_instruction_selection.h
index 4c3717818028..9f40a1ebf46a 100644
--- a/src/amd/compiler/aco_instruction_selection.h
+++ b/src/amd/compiler/aco_instruction_selection.h
@@ -127,8 +127,7 @@ isel_context setup_isel_context(Program* program, unsigned shader_count,
                                 struct nir_shader* const* shaders, ac_shader_config* config,
                                 const struct aco_compiler_options* options,
                                 const struct aco_shader_info* info,
-                                const struct radv_shader_args* args,
-                                bool is_gs_copy_shader, bool is_ps_epilog);
+                                const struct radv_shader_args* args, bool is_ps_epilog);
 
 } // namespace aco
 
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index e655726755a2..7a13f1ef4607 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -443,7 +443,7 @@ init_context(isel_context* ctx, nir_shader* shader)
    /* we'll need these for isel */
    nir_metadata_require(impl, nir_metadata_block_index);
 
-   if (!ctx->stage.has(SWStage::GSCopy) && ctx->options->dump_preoptir) {
+   if (ctx->options->dump_preoptir) {
       fprintf(stderr, "NIR shader before instruction selection:\n");
       nir_print_shader(shader, stderr);
    }
@@ -814,8 +814,7 @@ isel_context
 setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* const* shaders,
                    ac_shader_config* config, const struct aco_compiler_options* options,
                    const struct aco_shader_info* info,
-                   const struct radv_shader_args* args, bool is_gs_copy_shader,
-                   bool is_ps_epilog)
+                   const struct radv_shader_args* args, bool is_ps_epilog)
 {
    SWStage sw_stage = SWStage::None;
    for (unsigned i = 0; i < shader_count; i++) {
@@ -823,9 +822,7 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
       case MESA_SHADER_VERTEX: sw_stage = sw_stage | SWStage::VS; break;
       case MESA_SHADER_TESS_CTRL: sw_stage = sw_stage | SWStage::TCS; break;
       case MESA_SHADER_TESS_EVAL: sw_stage = sw_stage | SWStage::TES; break;
-      case MESA_SHADER_GEOMETRY:
-         sw_stage = sw_stage | (is_gs_copy_shader ? SWStage::GSCopy : SWStage::GS);
-         break;
+      case MESA_SHADER_GEOMETRY: sw_stage = sw_stage | SWStage::GS; break;
       case MESA_SHADER_FRAGMENT: sw_stage = sw_stage | SWStage::FS; break;
       case MESA_SHADER_COMPUTE: sw_stage = sw_stage | SWStage::CS; break;
       case MESA_SHADER_TASK: sw_stage = sw_stage | SWStage::TS; break;
@@ -854,8 +851,6 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
       hw_stage = HWStage::FS;
    else if (sw_stage == SWStage::CS)
       hw_stage = HWStage::CS;
-   else if (sw_stage == SWStage::GSCopy)
-      hw_stage = HWStage::VS;
    else if (sw_stage == SWStage::TS)
       hw_stage = HWStage::CS; /* Task shaders are implemented with compute shaders. */
    else if (sw_stage == SWStage::MS)
@@ -907,19 +902,14 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
    calc_min_waves(program);
 
    unsigned scratch_size = 0;
-   if (program->stage == gs_copy_vs) {
-      assert(shader_count == 1);
-      setup_vs_output_info(&ctx, shaders[0]);
-   } else {
-      for (unsigned i = 0; i < shader_count; i++) {
-         nir_shader* nir = shaders[i];
-         setup_nir(&ctx, nir);
-      }
-
-      for (unsigned i = 0; i < shader_count; i++)
-         scratch_size = std::max(scratch_size, shaders[i]->scratch_size);
+   for (unsigned i = 0; i < shader_count; i++) {
+      nir_shader* nir = shaders[i];
+      setup_nir(&ctx, nir);
    }
 
+   for (unsigned i = 0; i < shader_count; i++)
+      scratch_size = std::max(scratch_size, shaders[i]->scratch_size);
+
    ctx.program->config->scratch_bytes_per_wave = align(scratch_size * ctx.program->wave_size, 1024);
 
    unsigned nir_num_blocks = 0;
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index b2bf8dedf821..c3d89712cc7f 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -257,7 +257,6 @@ aco_compile_shader(const struct aco_compiler_options* options,
 
    (*build_binary)(binary,
                    shaders[shader_count - 1]->info.stage,
-                   args->is_gs_copy_shader,
                    &config,
                    llvm_ir.c_str(),
                    llvm_ir.size(),
diff --git a/src/amd/compiler/aco_interface.h b/src/amd/compiler/aco_interface.h
index c404038c42d7..09410faf2e58 100644
--- a/src/amd/compiler/aco_interface.h
+++ b/src/amd/compiler/aco_interface.h
@@ -46,7 +46,6 @@ struct aco_compiler_statistic_info {
 
 typedef void (aco_callback)(void **priv_ptr,
                             gl_shader_stage stage,
-                            bool is_gs_copy_shader,
                             const struct ac_shader_config *config,
                             const char *llvm_ir_str,
                             unsigned llvm_ir_size,
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 9220fec588ec..81ce936a9ae1 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2024,7 +2024,6 @@ enum class SWStage : uint16_t {
    CS = 1 << 5,     /* Compute Shader */
    TS = 1 << 6,     /* Task Shader */
    MS = 1 << 7,     /* Mesh Shader */
-   GSCopy = 1 << 8, /* GS Copy Shader (internal) */
 
    /* Stage combinations merged to run on a single HWStage */
    VS_GS = VS | GS,
@@ -2089,7 +2088,6 @@ static constexpr Stage vertex_vs(HWStage::VS, SWStage::VS);
 static constexpr Stage fragment_fs(HWStage::FS, SWStage::FS);
 static constexpr Stage compute_cs(HWStage::CS, SWStage::CS);
 static constexpr Stage tess_eval_vs(HWStage::VS, SWStage::TES);
-static constexpr Stage gs_copy_vs(HWStage::VS, SWStage::GSCopy);
 /* Mesh shading pipeline */
 static constexpr Stage task_cs(HWStage::CS, SWStage::TS);
 static constexpr Stage mesh_ngg(HWStage::NGG, SWStage::MS);
@@ -2265,10 +2263,6 @@ void select_program(Program* program, unsigned shader_count, struct nir_shader*
                     ac_shader_config* config, const struct aco_compiler_options* options,
                     const struct aco_shader_info* info,
                     const struct radv_shader_args* args);
-void select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_config* config,
-                           const struct aco_compiler_options* options,
-                           const struct aco_shader_info* info,
-                           const struct radv_shader_args* args);
 void select_trap_handler_shader(Program* program, struct nir_shader* shader,
                                 ac_shader_config* config,
                                 const struct aco_compiler_options* options,
diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index 9b77a6996b80..044fc2d183e6 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -859,8 +859,6 @@ print_stage(Stage stage, FILE* output)
       fprintf(output, "compute_cs");
    else if (stage == fragment_fs)
       fprintf(output, "fragment_fs");
-   else if (stage == gs_copy_vs)
-      fprintf(output, "gs_copy_vs");
    else if (stage == vertex_ls)
       fprintf(output, "vertex_ls");
    else if (stage == vertex_es)
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 323e48a2405f..271165e6204a 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -996,8 +996,9 @@ radv_llvm_export_vs(struct radv_shader_context *ctx, struct radv_shader_output_v
 }
 
 static void
-handle_vs_outputs_post(struct radv_shader_context *ctx)
+radv_llvm_visit_export_vertex(struct ac_shader_abi *abi)
 {
+   struct radv_shader_context *ctx = radv_shader_context_from_abi(abi);
    const struct radv_vs_output_info *outinfo = &ctx->shader_info->outinfo;
    const bool export_clip_dists = outinfo->export_clip_dists;
    struct radv_shader_output_values *outputs;
@@ -1156,14 +1157,6 @@ ac_llvm_finalize_module(struct radv_shader_context *ctx, LLVMPassManagerRef pass
    ac_llvm_context_dispose(&ctx->ac);
 }
 
-static void
-radv_llvm_visit_export_vertex(struct ac_shader_abi *abi)
-{
-   struct radv_shader_context *ctx = radv_shader_context_from_abi(abi);
-
-   handle_vs_outputs_post(ctx);
-}
-
 static void
 ac_setup_rings(struct radv_shader_context *ctx)
 {
@@ -1589,134 +1582,6 @@ radv_compile_nir_shader(struct ac_llvm_compiler *ac_llvm,
                           options);
 }
 
-static void
-ac_gs_copy_shader_emit(struct radv_shader_context *ctx)
-{
-   LLVMValueRef vtx_offset =
-      LLVMBuildMul(ctx->ac.builder, ac_get_arg(&ctx->ac, ctx->args->ac.vertex_id),
-                   LLVMConstInt(ctx->ac.i32, 4, false), "");
-   LLVMValueRef stream_id;
-
-   /* Fetch the vertex stream ID. */
-   if (ctx->shader_info->so.num_outputs) {
-      stream_id =
-         ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->ac.streamout_config), 24, 2);
-   } else {
-      stream_id = ctx->ac.i32_0;
-   }
-
-   LLVMBasicBlockRef end_bb;
-   LLVMValueRef switch_inst;
-
-   end_bb = LLVMAppendBasicBlockInContext(ctx->ac.context, ctx->main_function.value, "end");
-   switch_inst = LLVMBuildSwitch(ctx->ac.builder, stream_id, end_bb, 4);
-
-   for (unsigned stream = 0; stream < 4; stream++) {
-      unsigned num_components = ctx->shader_info->gs.num_stream_output_components[stream];
-      LLVMBasicBlockRef bb;
-      unsigned offset;
-
-      if (stream > 0 && !num_components)
-         continue;
-
-      if (stream > 0 && !ctx->shader_info->so.num_outputs)
-         continue;
-
-      bb = LLVMInsertBasicBlockInContext(ctx->ac.context, end_bb, "out");
-      LLVMAddCase(switch_inst, LLVMConstInt(ctx->ac.i32, stream, 0), bb);
-      LLVMPositionBuilderAtEnd(ctx->ac.builder, bb);
-
-      offset = 0;
-      for (unsigned i = 0; i < AC_LLVM_MAX_OUTPUTS; ++i) {
-         unsigned output_usage_mask = ctx->shader_info->gs.output_usage_mask[i];
-         unsigned output_stream = ctx->shader_info->gs.output_streams[i] & 0x3;
-         int length = util_last_bit(output_usage_mask);
-
-         if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
-            continue;
-
-         for (unsigned j = 0; j < length; j++) {
-            LLVMValueRef value, soffset;
-
-            if (!(output_usage_mask & (1 << j)))
-               continue;
-
-            soffset = LLVMConstInt(ctx->ac.i32, offset * ctx->shader->info.gs.vertices_out * 16 * 4,
-                                   false);
-
-            offset++;
-
-            value = ac_build_buffer_load(&ctx->ac, ctx->gsvs_ring[0], 1, ctx->ac.i32_0, vtx_offset,
-                                         soffset, ctx->ac.f32, ac_glc | ac_slc, true, false);
-
-            LLVMTypeRef type = LLVMGetAllocatedType(ctx->abi.outputs[ac_llvm_reg_index_soa(i, j)]);
-            if (ac_get_type_size(type) == 2) {
-               value = LLVMBuildBitCast(ctx->ac.builder, value, ctx->ac.i32, "");
-               value = LLVMBuildTrunc(ctx->ac.builder, value, ctx->ac.i16, "");
-            }
-
-            LLVMBuildStore(ctx->ac.builder, ac_to_float(&ctx->ac, value),
-                           ctx->abi.outputs[ac_llvm_reg_index_soa(i, j)]);
-         }
-      }
-
-      if (ctx->shader_info->so.num_outputs)
-         radv_emit_streamout(ctx, stream);
-
-      if (stream == 0) {
-         handle_vs_outputs_post(ctx);
-      }
-
-      LLVMBuildBr(ctx->ac.builder, end_bb);
-   }
-
-   LLVMPositionBuilderAtEnd(ctx->ac.builder, end_bb);
-}
-
-static void
-radv_compile_gs_copy_shader(struct ac_llvm_compiler *ac_llvm,
-                            const struct radv_nir_compiler_options *options,
-                            const struct radv_shader_info *info,
-                            struct nir_shader *geom_shader,
-                            struct radv_shader_binary **rbinary,
-                            const struct radv_shader_args *args)
-{
-   struct radv_shader_context ctx = {0};
-   ctx.args = args;
-   ctx.options = options;
-   ctx.shader_info = info;
-
-   assert(args->is_gs_copy_shader);
-
-   ac_llvm_context_init(&ctx.ac, ac_llvm, options->gfx_level, options->family,
-                        options->has_3d_cube_border_color_mipmap,
-                        AC_FLOAT_MODE_DEFAULT, 64, 64);
-   ctx.context = ctx.ac.context;
-
-   ctx.stage = MESA_SHADER_VERTEX;
-   ctx.shader = geom_shader;
-
-   create_function(&ctx, MESA_SHADER_VERTEX, false);
-
-   ac_setup_rings(&ctx);
-
-   nir_foreach_shader_out_variable(variable, geom_shader)
-   {
-      scan_shader_output_decl(&ctx, variable, geom_shader, MESA_SHADER_VERTEX);
-      ac_handle_shader_output_decl(&ctx.ac, &ctx.abi, geom_shader, variable, MESA_SHADER_VERTEX);
-   }
-
-   ac_gs_copy_shader_emit(&ctx);
-
-   LLVMBuildRetVoid(ctx.ac.builder);
-
-   ac_llvm_finalize_module(&ctx, ac_llvm->passmgr);
-
-   ac_compile_llvm_module(ac_llvm, ctx.ac.module, rbinary, MESA_SHADER_VERTEX, "GS Copy Shader",
-                          options);
-   (*rbinary)->is_gs_copy_shader = true;
-}
-
 void
 llvm_compile_shader(const struct radv_nir_compiler_options *options,
                     const struct radv_shader_info *info, unsigned shader_count,
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 2d468b82036e..f4f1075d575a 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1971,8 +1971,7 @@ radv_open_rtld_binary(struct radv_device *device, const struct radv_shader *shad
    unsigned num_lds_symbols = 0;
 
    if (device->physical_device->rad_info.gfx_level >= GFX9 &&
-       (binary->stage == MESA_SHADER_GEOMETRY || binary->info.is_ngg) &&
-       !binary->is_gs_copy_shader) {
+       (binary->stage == MESA_SHADER_GEOMETRY || binary->info.is_ngg)) {
       struct ac_rtld_symbol *sym = &lds_symbols[num_lds_symbols++];
       sym->name = "esgs_ring";
       sym->size = binary->info.ngg_info.esgs_ring_size;
@@ -2222,7 +2221,6 @@ radv_dump_nir_shaders(struct nir_shader *const *shaders, int shader_count)
 static void
 radv_aco_build_shader_binary(void **bin,
                              gl_shader_stage stage,
-                             bool is_gs_copy_shader,
                              const struct ac_shader_config *config,
                              const char *llvm_ir_str,
                              unsigned llvm_ir_size,
@@ -2249,7 +2247,6 @@ radv_aco_build_shader_binary(void **bin,
    struct radv_shader_binary_legacy *legacy_binary = (struct radv_shader_binary_legacy *)calloc(size, 1);
    legacy_binary->base.type = RADV_BINARY_TYPE_LEGACY;
    legacy_binary->base.stage = stage;
-   legacy_binary->base.is_gs_copy_shader = is_gs_copy_shader;
    legacy_binary->base.total_size = size;
    legacy_binary->base.config = *config;
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 5181a42777b4..e83fe503dc22 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -409,7 +409,6 @@ enum radv_shader_binary_type { RADV_BINARY_TYPE_LEGACY, RADV_BINARY_TYPE_RTLD };
 struct radv_shader_binary {
    enum radv_shader_binary_type type;
    gl_shader_stage stage;
-   bool is_gs_copy_shader;
 
    struct ac_shader_config config;
    struct radv_shader_info info;
-- 
GitLab


From 7df0d41bbb8fdbe8cadada90f124f38365919fbe Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 30 Sep 2022 19:49:56 +0100
Subject: [PATCH 09/10] radv,aco: remove old streamout code

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 113 -----------------
 .../aco_instruction_selection_setup.cpp       |  14 +-
 src/amd/compiler/aco_shader_info.h            |  15 ---
 src/amd/vulkan/radv_aco_shader_info.h         |  19 ---
 src/amd/vulkan/radv_nir_to_llvm.c             | 120 ------------------
 5 files changed, 2 insertions(+), 279 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 7ffbfc33b2fc..6b23eb235c41 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11345,119 +11345,6 @@ create_fs_exports(isel_context* ctx)
    ctx->block->kind |= block_kind_export_end;
 }
 
-static void
-emit_stream_output(isel_context* ctx, Temp const* so_buffers, Temp const* so_write_offset,
-                   const struct aco_stream_output* output)
-{
-   assert(ctx->stage.hw == HWStage::VS);
-
-   unsigned loc = output->location;
-   unsigned buf = output->buffer;
-
-   unsigned writemask = output->component_mask & ctx->outputs.mask[loc];
-   while (writemask) {
-      int start, count;
-      u_bit_scan_consecutive_range(&writemask, &start, &count);
-      if (count == 3 && ctx->options->gfx_level == GFX6) {
-         /* GFX6 doesn't support storing vec3, split it. */
-         writemask |= 1u << (start + 2);
-         count = 2;
-      }
-
-      unsigned offset = output->offset + (start - (ffs(output->component_mask) - 1)) * 4;
-
-      Temp write_data = ctx->program->allocateTmp(RegClass(RegType::vgpr, count));
-      aco_ptr<Pseudo_instruction> vec{create_instruction<Pseudo_instruction>(
-         aco_opcode::p_create_vector, Format::PSEUDO, count, 1)};
-      for (int i = 0; i < count; ++i)
-         vec->operands[i] = Operand(ctx->outputs.temps[loc * 4 + start + i]);
-      vec->definitions[0] = Definition(write_data);
-      ctx->block->instructions.emplace_back(std::move(vec));
-
-      aco_opcode opcode = get_buffer_store_op(count * 4);
-      aco_ptr<MUBUF_instruction> store{
-         create_instruction<MUBUF_instruction>(opcode, Format::MUBUF, 4, 0)};
-      store->operands[0] = Operand(so_buffers[buf]);
-      store->operands[1] = Operand(so_write_offset[buf]);
-      store->operands[2] = Operand::c32(0);
-      store->operands[3] = Operand(write_data);
-      if (offset > 4095) {
-         /* Don't think this can happen in RADV, but maybe GL? It's easy to do this anyway. */
-         Builder bld(ctx->program, ctx->block);
-         store->operands[1] =
-            bld.vadd32(bld.def(v1), Operand::c32(offset), Operand(so_write_offset[buf]));
-      } else {
-         store->offset = offset;
-      }
-      store->offen = true;
-      store->glc = ctx->program->gfx_level < GFX11;
-      store->dlc = false;
-      store->slc = true;
-      ctx->block->instructions.emplace_back(std::move(store));
-   }
-}
-
-static void
-emit_streamout(isel_context* ctx, unsigned stream)
-{
-   Builder bld(ctx->program, ctx->block);
-
-   Temp so_vtx_count =
-      bld.sop2(aco_opcode::s_bfe_u32, bld.def(s1), bld.def(s1, scc),
-               get_arg(ctx, ctx->args->ac.streamout_config), Operand::c32(0x70010u));
-
-   Temp tid = emit_mbcnt(ctx, bld.tmp(v1));
-
-   Temp can_emit = bld.vopc(aco_opcode::v_cmp_gt_i32, bld.def(bld.lm), so_vtx_count, tid);
-
-   if_context ic;
-   begin_divergent_if_then(ctx, &ic, can_emit);
-
-   bld.reset(ctx->block);
-
-   Temp so_write_index =
-      bld.vadd32(bld.def(v1), get_arg(ctx, ctx->args->ac.streamout_write_index), tid);
-
-   Temp so_buffers[4];
-   Temp so_write_offset[4];
-   Temp buf_ptr = convert_pointer_to_64_bit(ctx, get_arg(ctx, ctx->args->streamout_buffers));
-
-   for (unsigned i = 0; i < 4; i++) {
-      unsigned stride = ctx->program->info.so.strides[i];
-      if (!stride)
-         continue;
-
-      so_buffers[i] = bld.smem(aco_opcode::s_load_dwordx4, bld.def(s4), buf_ptr,
-                               bld.copy(bld.def(s1), Operand::c32(i * 16u)));
-
-      if (stride == 1) {
-         Temp offset = bld.sop2(aco_opcode::s_add_i32, bld.def(s1), bld.def(s1, scc),
-                                get_arg(ctx, ctx->args->ac.streamout_write_index),
-                                get_arg(ctx, ctx->args->ac.streamout_offset[i]));
-         Temp new_offset = bld.vadd32(bld.def(v1), offset, tid);
-
-         so_write_offset[i] =
-            bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(2u), new_offset);
-      } else {
-         Temp offset = bld.v_mul_imm(bld.def(v1), so_write_index, stride * 4u);
-         Temp offset2 = bld.sop2(aco_opcode::s_mul_i32, bld.def(s1), Operand::c32(4u),
-                                 get_arg(ctx, ctx->args->ac.streamout_offset[i]));
-         so_write_offset[i] = bld.vadd32(bld.def(v1), offset, offset2);
-      }
-   }
-
-   for (unsigned i = 0; i < ctx->program->info.so.num_outputs; i++) {
-      const struct aco_stream_output* output = &ctx->program->info.so.outputs[i];
-      if (stream != output->stream)
-         continue;
-
-      emit_stream_output(ctx, so_buffers, so_write_offset, output);
-   }
-
-   begin_divergent_if_else(ctx, &ic);
-   end_divergent_if(ctx, &ic);
-}
-
 Pseudo_instruction*
 add_startpgm(struct isel_context* ctx)
 {
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 7a13f1ef4607..261d4b6fcd4f 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -269,14 +269,9 @@ setup_vs_output_info(isel_context* ctx, nir_shader* nir)
 void
 setup_vs_variables(isel_context* ctx, nir_shader* nir)
 {
-   if (ctx->stage == vertex_vs || ctx->stage == vertex_ngg) {
+   if (ctx->stage == vertex_vs || ctx->stage == vertex_ngg)
       setup_vs_output_info(ctx, nir);
 
-      /* TODO: NGG streamout */
-      if (ctx->stage.hw == HWStage::NGG)
-         assert(!ctx->program->info.so.num_outputs);
-   }
-
    if (ctx->stage == vertex_ngg) {
       ctx->program->config->lds_size =
          DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
@@ -310,14 +305,9 @@ setup_tcs_info(isel_context* ctx, nir_shader* nir, nir_shader* vs)
 void
 setup_tes_variables(isel_context* ctx, nir_shader* nir)
 {
-   if (ctx->stage == tess_eval_vs || ctx->stage == tess_eval_ngg) {
+   if (ctx->stage == tess_eval_vs || ctx->stage == tess_eval_ngg)
       setup_vs_output_info(ctx, nir);
 
-      /* TODO: NGG streamout */
-      if (ctx->stage.hw == HWStage::NGG)
-         assert(!ctx->program->info.so.num_outputs);
-   }
-
    if (ctx->stage == tess_eval_ngg) {
       ctx->program->config->lds_size =
          DIV_ROUND_UP(nir->info.shared_size, ctx->program->dev.lds_encoding_granule);
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index b09e25c1a8d6..a870b487f2b7 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -86,20 +86,6 @@ struct aco_vp_output_info {
    bool export_clip_dists;
 };
 
-struct aco_stream_output {
-   uint8_t location;
-   uint8_t buffer;
-   uint16_t offset;
-   uint8_t component_mask;
-   uint8_t stream;
-};
-
-struct aco_streamout_info {
-   uint16_t num_outputs;
-   struct aco_stream_output outputs[ACO_MAX_SO_OUTPUTS];
-   uint16_t strides[ACO_MAX_SO_BUFFERS];
-};
-
 struct aco_shader_info {
    uint8_t wave_size;
    bool is_ngg;
@@ -141,7 +127,6 @@ struct aco_shader_info {
    struct {
       uint8_t subgroup_size;
    } cs;
-   struct aco_streamout_info so;
 
    uint32_t gfx9_gs_ring_lds_size;
 };
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index bd20336f22fe..db80d7327226 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -34,24 +34,6 @@
 #define ASSIGN_FIELD(x) aco_info->x = radv->x
 #define ASSIGN_FIELD_CP(x) memcpy(&aco_info->x, &radv->x, sizeof(radv->x))
 
-static inline void
-radv_aco_convert_shader_so_info(struct aco_shader_info *aco_info,
-                       const struct radv_shader_info *radv)
-{
-   ASSIGN_FIELD(so.num_outputs);
-   for (unsigned i = 0; i < ACO_MAX_SO_OUTPUTS; i++) {
-      struct aco_stream_output *dst = &aco_info->so.outputs[i];
-      const struct pipe_stream_output *src = &radv->so.output[i];
-      dst->location = src->register_index;
-      dst->buffer = src->output_buffer;
-      dst->offset = src->dst_offset * 4;
-      dst->component_mask = u_bit_consecutive(src->start_component, src->num_components);
-      dst->stream = src->stream;
-   }
-   memcpy(&aco_info->so.strides, radv->so.stride, sizeof(radv->so.stride));
-   /* enabled_stream_buffers_mask unused */
-}
-
 static inline void
 radv_aco_convert_shader_vp_info(struct aco_vp_output_info *aco_info,
 				const struct radv_vs_output_info *radv)
@@ -105,7 +87,6 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info,
    ASSIGN_FIELD(ps.num_interp);
    ASSIGN_FIELD(ps.spi_ps_input);
    ASSIGN_FIELD(cs.subgroup_size);
-   radv_aco_convert_shader_so_info(aco_info, radv);
    aco_info->gfx9_gs_ring_lds_size = radv->gs_ring_info.lds_size;
 }
 
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 271165e6204a..3c0ddd6af3d6 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -727,126 +727,6 @@ radv_load_output(struct radv_shader_context *ctx, unsigned index, unsigned chan)
    return LLVMBuildLoad2(ctx->ac.builder, type, output, "");
 }
 
-static void
-radv_emit_stream_output(struct radv_shader_context *ctx, LLVMValueRef const *so_buffers,
-                        LLVMValueRef const *so_write_offsets,
-                        const struct pipe_stream_output *output,
-                        struct radv_shader_output_values *shader_out)
-{
-   unsigned num_comps = output->num_components;
-   unsigned buf = output->output_buffer;
-   unsigned offset = output->dst_offset * 4;
-   unsigned start;
-   LLVMValueRef out[4];
-
-   assert(num_comps && num_comps <= 4);
-   if (!num_comps || num_comps > 4)
-      return;
-
-   /* Get the first component. */
-   start = output->start_component;
-
-   /* Load the output as int. */
-   for (int i = 0; i < num_comps; i++) {
-      out[i] = ac_to_integer(&ctx->ac, shader_out->values[start + i]);
-   }
-
-   /* Pack the output. */
-   LLVMValueRef vdata = NULL;
-
-   switch (num_comps) {
-   case 1: /* as i32 */
-      vdata = out[0];
-      break;
-   case 2: /* as v2i32 */
-   case 3: /* as v3i32 */
-   case 4: /* as v4i32 */
-      vdata = ac_build_gather_values(&ctx->ac, out, num_comps);
-      break;
-   }
-
-   LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, so_write_offsets[buf],
-                                       LLVMConstInt(ctx->ac.i32, offset, 0), "");
-   ac_build_buffer_store_dword(&ctx->ac, so_buffers[buf], vdata, NULL, voffset, ctx->ac.i32_0,
-                               ac_glc | ac_slc);
-}
-
-static void
-radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
-{
-   int i;
-
-   /* Get bits [22:16], i.e. (so_param >> 16) & 127; */
-   assert(ctx->args->ac.streamout_config.used);
-   LLVMValueRef so_vtx_count = ac_build_bfe(
-      &ctx->ac, ac_get_arg(&ctx->ac, ctx->args->ac.streamout_config),
-      LLVMConstInt(ctx->ac.i32, 16, false), LLVMConstInt(ctx->ac.i32, 7, false), false);
-
-   LLVMValueRef tid = ac_get_thread_id(&ctx->ac);
-
-   /* can_emit = tid < so_vtx_count; */
-   LLVMValueRef can_emit = LLVMBuildICmp(ctx->ac.builder, LLVMIntULT, tid, so_vtx_count, "");
-
-   /* Emit the streamout code conditionally. This actually avoids
-    * out-of-bounds buffer access. The hw tells us via the SGPR
-    * (so_vtx_count) which threads are allowed to emit streamout data.
-    */
-   ac_build_ifcc(&ctx->ac, can_emit, 6501);
-   {
-      /* The buffer offset is computed as follows:
-       *   ByteOffset = streamout_offset[buffer_id]*4 +
-       *                (streamout_write_index + thread_id)*stride[buffer_id] +
-       *                attrib_offset
-       */
-      LLVMValueRef so_write_index = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_write_index);
-
-      /* Compute (streamout_write_index + thread_id). */
-      so_write_index = LLVMBuildAdd(ctx->ac.builder, so_write_index, tid, "");
-
-      /* Load the descriptor and compute the write offset for each
-       * enabled buffer.
-       */
-      LLVMValueRef so_write_offset[4] = {0};
-      LLVMValueRef so_buffers[4] = {0};
-      struct ac_llvm_pointer buf_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
-
-      for (i = 0; i < 4; i++) {
-         uint16_t stride = ctx->shader_info->so.stride[i];
-
-         if (!stride)
-            continue;
-
-         LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, i, false);
-
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
-
-         LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_offset[i]);
-
-         so_offset =
-            LLVMBuildMul(ctx->ac.builder, so_offset, LLVMConstInt(ctx->ac.i32, 4, false), "");
-
-         so_write_offset[i] = ac_build_imad(
-            &ctx->ac, so_write_index, LLVMConstInt(ctx->ac.i32, stride * 4, false), so_offset);
-      }
-
-      /* Write streamout data. */
-      for (i = 0; i < ctx->shader_info->so.num_outputs; i++) {
-         struct radv_shader_output_values shader_out = {0};
-         const struct pipe_stream_output *output = &ctx->shader_info->so.output[i];
-
-         if (stream != output->stream)
-            continue;
-
-         for (int j = 0; j < 4; j++) {
-            shader_out.values[j] = radv_load_output(ctx, output->register_index, j);
-         }
-
-         radv_emit_stream_output(ctx, so_buffers, so_write_offset, output, &shader_out);
-      }
-   }
-   ac_build_endif(&ctx->ac, 6501);
-}
-
 static void
 radv_build_param_exports(struct radv_shader_context *ctx, struct radv_shader_output_values *outputs,
                          unsigned noutput, const struct radv_vs_output_info *outinfo,
-- 
GitLab


From 196877af74601ed6e3fd83144dba8e44e4eb5516 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 28 Sep 2022 20:24:14 +0100
Subject: [PATCH 10/10] radv: compile GS copy shader after geometry shader

This affects the pipeline feedback durations.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 0457c77c2ea6..0300e5734c1a 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3644,12 +3644,6 @@ radv_pipeline_nir_to_asm(struct radv_pipeline *pipeline, struct radv_pipeline_st
    bool pipeline_has_ngg = last_vgt_api_stage != MESA_SHADER_NONE &&
                            stages[last_vgt_api_stage].info.is_ngg;
 
-   if (stages[MESA_SHADER_GEOMETRY].nir && !pipeline_has_ngg) {
-      pipeline->gs_copy_shader =
-         radv_pipeline_create_gs_copy_shader(pipeline, stages, pipeline_key, pipeline_layout,
-                                             keep_executable_info, keep_statistic_info);
-   }
-
    for (int s = MESA_VULKAN_SHADER_STAGES - 1; s >= 0; s--) {
       if (!(active_stages & (1 << s)) || pipeline->shaders[s])
          continue;
@@ -3679,6 +3673,12 @@ radv_pipeline_nir_to_asm(struct radv_pipeline *pipeline, struct radv_pipeline_st
                                                     pipeline_key, keep_executable_info,
                                                     keep_statistic_info);
 
+      if (s == MESA_SHADER_GEOMETRY && !pipeline_has_ngg) {
+         pipeline->gs_copy_shader =
+            radv_pipeline_create_gs_copy_shader(pipeline, stages, pipeline_key, pipeline_layout,
+                                                keep_executable_info, keep_statistic_info);
+      }
+
       stages[s].feedback.duration += os_time_get_nano() - stage_start;
 
       active_stages &= ~(1 << shaders[0]->info.stage);
-- 
GitLab

