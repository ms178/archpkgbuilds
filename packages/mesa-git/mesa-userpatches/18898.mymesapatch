From 22aaae0c274a28f50316d1700d76e793a8e0918f Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 30 Sep 2022 19:31:47 +0100
Subject: [PATCH 1/8] radv: switch to pipe_stream_output_info

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_aco_shader_info.h | 12 ++++++++++--
 src/amd/vulkan/radv_cmd_buffer.c      |  6 +++---
 src/amd/vulkan/radv_nir_to_llvm.c     | 16 ++++++++--------
 src/amd/vulkan/radv_shader.c          |  4 ++--
 src/amd/vulkan/radv_shader.h          | 20 ++++----------------
 src/amd/vulkan/radv_shader_args.c     |  2 +-
 src/amd/vulkan/radv_shader_info.c     | 19 ++++++++++---------
 7 files changed, 38 insertions(+), 41 deletions(-)

diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 175a2ab53f1b..bd20336f22fe 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -39,8 +39,16 @@ radv_aco_convert_shader_so_info(struct aco_shader_info *aco_info,
                        const struct radv_shader_info *radv)
 {
    ASSIGN_FIELD(so.num_outputs);
-   ASSIGN_FIELD_CP(so.outputs);
-   ASSIGN_FIELD_CP(so.strides);
+   for (unsigned i = 0; i < ACO_MAX_SO_OUTPUTS; i++) {
+      struct aco_stream_output *dst = &aco_info->so.outputs[i];
+      const struct pipe_stream_output *src = &radv->so.output[i];
+      dst->location = src->register_index;
+      dst->buffer = src->output_buffer;
+      dst->offset = src->dst_offset * 4;
+      dst->component_mask = u_bit_consecutive(src->start_component, src->num_components);
+      dst->stream = src->stream;
+   }
+   memcpy(&aco_info->so.strides, radv->so.stride, sizeof(radv->so.stride));
    /* enabled_stream_buffers_mask unused */
 }
 
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 52943114b11a..549a37a11e22 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9840,7 +9840,7 @@ radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer)
    uint32_t enabled_stream_buffers_mask = 0;
 
    if (pipeline && pipeline->streamout_shader) {
-      enabled_stream_buffers_mask = pipeline->streamout_shader->info.so.enabled_stream_buffers_mask;
+      enabled_stream_buffers_mask = pipeline->streamout_shader->info.enabled_stream_buffers_mask;
    }
 
    radeon_set_context_reg_seq(cs, R_028B94_VGT_STRMOUT_CONFIG, 2);
@@ -9937,8 +9937,8 @@ radv_emit_streamout_begin(struct radv_cmd_buffer *cmd_buffer, uint32_t firstCoun
        * SGPRs what to do.
        */
       radeon_set_context_reg_seq(cs, R_028AD0_VGT_STRMOUT_BUFFER_SIZE_0 + 16 * i, 2);
-      radeon_emit(cs, sb[i].size >> 2);     /* BUFFER_SIZE (in DW) */
-      radeon_emit(cs, info->so.strides[i]); /* VTX_STRIDE (in DW) */
+      radeon_emit(cs, sb[i].size >> 2);    /* BUFFER_SIZE (in DW) */
+      radeon_emit(cs, info->so.stride[i]); /* VTX_STRIDE (in DW) */
 
       cmd_buffer->state.context_roll_without_scissor_emitted = true;
 
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 1ca2a31f0684..17202f85f455 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -728,12 +728,12 @@ radv_load_output(struct radv_shader_context *ctx, unsigned index, unsigned chan)
 static void
 radv_emit_stream_output(struct radv_shader_context *ctx, LLVMValueRef const *so_buffers,
                         LLVMValueRef const *so_write_offsets,
-                        const struct radv_stream_output *output,
+                        const struct pipe_stream_output *output,
                         struct radv_shader_output_values *shader_out)
 {
-   unsigned num_comps = util_bitcount(output->component_mask);
-   unsigned buf = output->buffer;
-   unsigned offset = output->offset;
+   unsigned num_comps = output->num_components;
+   unsigned buf = output->output_buffer;
+   unsigned offset = output->dst_offset * 4;
    unsigned start;
    LLVMValueRef out[4];
 
@@ -742,7 +742,7 @@ radv_emit_stream_output(struct radv_shader_context *ctx, LLVMValueRef const *so_
       return;
 
    /* Get the first component. */
-   start = ffs(output->component_mask) - 1;
+   start = output->start_component;
 
    /* Load the output as int. */
    for (int i = 0; i < num_comps; i++) {
@@ -809,7 +809,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
       struct ac_llvm_pointer buf_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
 
       for (i = 0; i < 4; i++) {
-         uint16_t stride = ctx->shader_info->so.strides[i];
+         uint16_t stride = ctx->shader_info->so.stride[i];
 
          if (!stride)
             continue;
@@ -830,13 +830,13 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
       /* Write streamout data. */
       for (i = 0; i < ctx->shader_info->so.num_outputs; i++) {
          struct radv_shader_output_values shader_out = {0};
-         const struct radv_stream_output *output = &ctx->shader_info->so.outputs[i];
+         const struct pipe_stream_output *output = &ctx->shader_info->so.output[i];
 
          if (stream != output->stream)
             continue;
 
          for (int j = 0; j < 4; j++) {
-            shader_out.values[j] = radv_load_output(ctx, output->location, j);
+            shader_out.values[j] = radv_load_output(ctx, output->register_index, j);
          }
 
          radv_emit_stream_output(ctx, so_buffers, so_write_offset, output, &shader_out);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index f83ea059fc15..d35ba8533bde 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1800,8 +1800,8 @@ radv_postprocess_config(const struct radv_device *device, const struct ac_shader
 
    if (!pdevice->use_ngg_streamout) {
       config_out->rsrc2 |=
-         S_00B12C_SO_BASE0_EN(!!info->so.strides[0]) | S_00B12C_SO_BASE1_EN(!!info->so.strides[1]) |
-         S_00B12C_SO_BASE2_EN(!!info->so.strides[2]) | S_00B12C_SO_BASE3_EN(!!info->so.strides[3]) |
+         S_00B12C_SO_BASE0_EN(!!info->so.stride[0]) | S_00B12C_SO_BASE1_EN(!!info->so.stride[1]) |
+         S_00B12C_SO_BASE2_EN(!!info->so.stride[2]) | S_00B12C_SO_BASE3_EN(!!info->so.stride[3]) |
          S_00B12C_SO_EN(!!info->so.num_outputs);
    }
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index a0d75fd96f3b..e5c75d3f2ab2 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -41,6 +41,8 @@
 
 #include "aco_shader_info.h"
 
+#include "pipe/p_state.h"
+
 #define RADV_VERT_ATTRIB_MAX MAX2(VERT_ATTRIB_MAX, VERT_ATTRIB_GENERIC0 + MAX_VERTEX_ATTRIBS)
 
 struct radv_physical_device;
@@ -168,21 +170,6 @@ enum radv_ud_index {
    AC_UD_MAX_UD = AC_UD_CS_MAX_UD,
 };
 
-struct radv_stream_output {
-   uint8_t location;
-   uint8_t buffer;
-   uint16_t offset;
-   uint8_t component_mask;
-   uint8_t stream;
-};
-
-struct radv_streamout_info {
-   uint16_t num_outputs;
-   struct radv_stream_output outputs[MAX_SO_OUTPUTS];
-   uint16_t strides[MAX_SO_BUFFERS];
-   uint32_t enabled_stream_buffers_mask;
-};
-
 struct radv_userdata_info {
    int8_t sgpr_idx;
    uint8_t num_sgprs;
@@ -366,7 +353,8 @@ struct radv_shader_info {
       bool has_task; /* If mesh shader is used together with a task shader. */
    } ms;
 
-   struct radv_streamout_info so;
+   struct pipe_stream_output_info so;
+   uint32_t enabled_stream_buffers_mask;
 
    struct gfx9_gs_info gs_ring_info;
    struct gfx10_ngg_info ngg_info;
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index 10b83fef4eca..a5778661553c 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -389,7 +389,7 @@ declare_streamout_sgprs(const struct radv_shader_info *info, struct radv_shader_
 
    /* A streamout buffer offset is loaded if the stride is non-zero. */
    for (i = 0; i < 4; i++) {
-      if (!info->so.strides[i])
+      if (!info->so.stride[i])
          continue;
 
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.streamout_offset[i]);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 72d4e586edca..d5c319fa5059 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -277,7 +277,7 @@ mark_16bit_ps_input(struct radv_shader_info *info, const struct glsl_type *type,
 static void
 gather_xfb_info(const nir_shader *nir, struct radv_shader_info *info)
 {
-   struct radv_streamout_info *so = &info->so;
+   struct pipe_stream_output_info *so = &info->so;
 
    if (!nir->xfb_info)
       return;
@@ -287,19 +287,20 @@ gather_xfb_info(const nir_shader *nir, struct radv_shader_info *info)
    so->num_outputs = xfb->output_count;
 
    for (unsigned i = 0; i < xfb->output_count; i++) {
-      struct radv_stream_output *output = &so->outputs[i];
+      struct pipe_stream_output *output = &so->output[i];
 
-      output->buffer = xfb->outputs[i].buffer;
+      output->output_buffer = xfb->outputs[i].buffer;
       output->stream = xfb->buffer_to_stream[xfb->outputs[i].buffer];
-      output->offset = xfb->outputs[i].offset;
-      output->location = xfb->outputs[i].location;
-      output->component_mask = xfb->outputs[i].component_mask;
+      output->dst_offset = xfb->outputs[i].offset / 4;
+      output->register_index = xfb->outputs[i].location;
+      output->start_component = xfb->outputs[i].component_offset;
+      output->num_components = util_bitcount(xfb->outputs[i].component_mask);
 
-      so->enabled_stream_buffers_mask |= (1 << output->buffer) << (output->stream * 4);
+      info->enabled_stream_buffers_mask |= (1 << output->output_buffer) << (output->stream * 4);
    }
 
    for (unsigned i = 0; i < NIR_MAX_XFB_BUFFERS; i++) {
-      so->strides[i] = xfb->buffers[i].stride / 4;
+      so->stride[i] = xfb->buffers[i].stride / 4;
    }
 }
 
@@ -1046,7 +1047,7 @@ gfx10_get_ngg_info(const struct radv_device *device, struct radv_pipeline_stage
    } else {
       /* VS and TES. */
       /* LDS size for passing data from GS to ES. */
-      struct radv_streamout_info *so_info = &es_info->so;
+      struct pipe_stream_output_info *so_info = &es_info->so;
 
       if (so_info->num_outputs)
          esvert_lds_size = 4 * so_info->num_outputs + 1;
-- 
GitLab


From de474bf3cdb015a2c05a3a0e2664fd064f3ea543 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 27 Sep 2022 19:26:11 +0100
Subject: [PATCH 2/8] radv,aco: export legacy vertex outputs in NIR

This new behaviour will let us insert exports in GS copy shader control
flow.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    |  5 +-
 src/amd/vulkan/radv_nir_to_llvm.c             | 26 ++-------
 src/amd/vulkan/radv_pipeline.c                | 56 ++-----------------
 src/amd/vulkan/radv_shader_info.c             |  2 +-
 4 files changed, 11 insertions(+), 78 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 393fbf6d6e45..4a94e7f2d1eb 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -9148,7 +9148,6 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       break;
    }
    case nir_intrinsic_export_vertex_amd: {
-      ctx->block->kind |= block_kind_export_end;
       create_vs_exports(ctx);
       break;
    }
@@ -11971,9 +11970,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
       if (ctx.program->info.so.num_outputs && ctx.stage.hw == HWStage::VS)
          emit_streamout(&ctx, 0);
 
-      if (ctx.stage.hw == HWStage::VS) {
-         create_vs_exports(&ctx);
-      } else if (nir->info.stage == MESA_SHADER_GEOMETRY && !ngg_gs) {
+      if (nir->info.stage == MESA_SHADER_GEOMETRY && !ngg_gs) {
          Builder bld(ctx.program, ctx.block);
          bld.barrier(aco_opcode::p_barrier,
                      memory_sync_info(storage_vmem_output, semantic_release, scope_device));
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 17202f85f455..47bd3df2eea7 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -1144,15 +1144,9 @@ handle_shader_outputs_post(struct ac_shader_abi *abi)
 
    switch (ctx->stage) {
    case MESA_SHADER_VERTEX:
-      if (ctx->shader_info->vs.as_ls)
-         break; /* Lowered in NIR */
-      else if (ctx->shader_info->vs.as_es)
-         break; /* Lowered in NIR */
-      else if (ctx->shader_info->is_ngg)
-         break; /* Lowered in NIR */
-      else
-         handle_vs_outputs_post(ctx);
-      break;
+   case MESA_SHADER_TESS_CTRL:
+   case MESA_SHADER_TESS_EVAL:
+      break; /* Lowered in NIR */
    case MESA_SHADER_FRAGMENT:
       handle_fs_outputs_post(ctx);
       break;
@@ -1162,16 +1156,6 @@ handle_shader_outputs_post(struct ac_shader_abi *abi)
       else
          emit_gs_epilogue(ctx);
       break;
-   case MESA_SHADER_TESS_CTRL:
-      break; /* Lowered in NIR */
-   case MESA_SHADER_TESS_EVAL:
-      if (ctx->shader_info->tes.as_es)
-         break; /* Lowered in NIR */
-      else if (ctx->shader_info->is_ngg)
-         break; /* Lowered in NIR */
-      else
-         handle_vs_outputs_post(ctx);
-      break;
    default:
       break;
    }
@@ -1409,8 +1393,6 @@ ac_translate_nir_to_llvm(struct ac_llvm_compiler *ac_llvm,
       ac_nir_fixup_ls_hs_input_vgprs(&ctx);
 
    if (is_ngg) {
-      ctx.abi.export_vertex = radv_llvm_visit_export_vertex;
-
       if (!info->is_ngg_passthrough)
          declare_esgs_ring(&ctx);
 
@@ -1445,7 +1427,9 @@ ac_translate_nir_to_llvm(struct ac_llvm_compiler *ac_llvm,
          ctx.abi.emit_vertex_with_counter = visit_emit_vertex_with_counter;
          ctx.abi.emit_primitive = visit_end_primitive;
       } else if (shaders[shader_idx]->info.stage == MESA_SHADER_TESS_EVAL) {
+         ctx.abi.export_vertex = radv_llvm_visit_export_vertex;
       } else if (shaders[shader_idx]->info.stage == MESA_SHADER_VERTEX) {
+         ctx.abi.export_vertex = radv_llvm_visit_export_vertex;
          ctx.abi.load_inputs = radv_load_vs_inputs;
       }
 
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index e343403bc5e4..dc76e584efbd 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2193,50 +2193,6 @@ radv_export_multiview(nir_shader *nir)
    return progress;
 }
 
-static bool
-radv_should_export_implicit_primitive_id(const struct radv_pipeline_stage *producer,
-                                         const struct radv_pipeline_stage *consumer)
-{
-   /* When the primitive ID is read by FS, we must ensure that it's exported by the previous vertex
-    * stage because it's implicit for VS or TES (but required by the Vulkan spec for GS or MS).
-    *
-    * There is two situations to handle:
-    *  - when the next stage is unknown (with graphics pipeline library), the primitive ID is
-    *  exported unconditionally
-    *  - when the pipeline uses NGG, the primitive ID is exported during NGG lowering
-    */
-   assert(producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL);
-
-   if ((producer->nir->info.outputs_written & VARYING_BIT_PRIMITIVE_ID) || producer->info.is_ngg)
-      return false;
-
-   return !consumer || (consumer->stage == MESA_SHADER_FRAGMENT &&
-          (consumer->nir->info.inputs_read & VARYING_BIT_PRIMITIVE_ID));
-}
-
-static bool
-radv_export_implicit_primitive_id(nir_shader *nir)
-{
-   nir_function_impl *impl = nir_shader_get_entrypoint(nir);
-   nir_builder b;
-   nir_builder_init(&b, impl);
-
-   b.cursor = nir_after_cf_list(&impl->body);
-
-   nir_variable *var = nir_variable_create(nir, nir_var_shader_out, glsl_int_type(), NULL);
-   var->data.location = VARYING_SLOT_PRIMITIVE_ID;
-   var->data.interpolation = INTERP_MODE_NONE;
-
-   nir_store_var(&b, var, nir_load_primitive_id(&b), 1);
-
-   /* Update outputs_written to reflect that the pass added a new output. */
-   nir->info.outputs_written |= BITFIELD64_BIT(VARYING_SLOT_PRIMITIVE_ID);
-
-   nir_metadata_preserve(impl, nir_metadata_block_index | nir_metadata_dominance);
-
-   return true;
-}
-
 static void
 radv_remove_point_size(const struct radv_pipeline_key *pipeline_key,
                        nir_shader *producer, nir_shader *consumer)
@@ -2519,10 +2475,6 @@ radv_pipeline_link_vs(const struct radv_device *device, struct radv_pipeline_sta
 {
    assert(vs_stage->nir->info.stage == MESA_SHADER_VERTEX);
 
-   if (radv_should_export_implicit_primitive_id(vs_stage, next_stage)) {
-      NIR_PASS(_, vs_stage->nir, radv_export_implicit_primitive_id);
-   }
-
    if (radv_should_export_multiview(vs_stage, next_stage, pipeline_key)) {
       NIR_PASS(_, vs_stage->nir, radv_export_multiview);
    }
@@ -2589,10 +2541,6 @@ radv_pipeline_link_tes(const struct radv_device *device, struct radv_pipeline_st
 {
    assert(tes_stage->nir->info.stage == MESA_SHADER_TESS_EVAL);
 
-   if (radv_should_export_implicit_primitive_id(tes_stage, next_stage)) {
-      NIR_PASS(_, tes_stage->nir, radv_export_implicit_primitive_id);
-   }
-
    if (radv_should_export_multiview(tes_stage, next_stage, pipeline_key)) {
       NIR_PASS(_, tes_stage->nir, radv_export_multiview);
    }
@@ -3889,6 +3837,10 @@ radv_postprocess_nir(struct radv_pipeline *pipeline,
    if (lowered_ngg)
       radv_lower_ngg(device, stage, pipeline_key);
 
+   if (stage->stage == last_vgt_api_stage && stage->stage != MESA_SHADER_GEOMETRY && !lowered_ngg)
+      NIR_PASS_V(stage->nir, ac_nir_lower_legacy_vs,
+                 stage->info.outinfo.export_prim_id ? VARYING_SLOT_PRIMITIVE_ID : -1, NULL);
+
    NIR_PASS(_, stage->nir, nir_opt_idiv_const, 8);
 
    NIR_PASS(_, stage->nir, nir_lower_idiv,
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index d5c319fa5059..e33d104b0bd1 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1261,7 +1261,7 @@ radv_link_shaders_info(struct radv_device *device,
 
       if (ps_prim_id_in &&
           (producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL)) {
-         /* Mark the primitive ID as output when it's implicitly exported by VS or TES with NGG. */
+         /* Mark the primitive ID as output when it's implicitly exported by VS or TES. */
          if (outinfo->vs_output_param_offset[VARYING_SLOT_PRIMITIVE_ID] == AC_EXP_PARAM_UNDEFINED)
             outinfo->vs_output_param_offset[VARYING_SLOT_PRIMITIVE_ID] = outinfo->param_exports++;
 
-- 
GitLab


From 0c689e40b19d27f55c48b226b1f376950af66065 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 28 Sep 2022 17:17:35 +0100
Subject: [PATCH 3/8] radv: lower streamout in NIR

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 3 ---
 src/amd/vulkan/radv_nir_to_llvm.c              | 6 ------
 src/amd/vulkan/radv_pipeline.c                 | 3 ++-
 3 files changed, 2 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 4a94e7f2d1eb..7b7aace2d82a 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11967,9 +11967,6 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
 
       visit_cf_list(&ctx, &func->body);
 
-      if (ctx.program->info.so.num_outputs && ctx.stage.hw == HWStage::VS)
-         emit_streamout(&ctx, 0);
-
       if (nir->info.stage == MESA_SHADER_GEOMETRY && !ngg_gs) {
          Builder bld(ctx.program, ctx.block);
          bld.barrier(aco_opcode::p_barrier,
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 47bd3df2eea7..3037658c161d 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -1001,12 +1001,6 @@ handle_vs_outputs_post(struct radv_shader_context *ctx)
    struct radv_shader_output_values *outputs;
    unsigned noutput = 0;
 
-   if (ctx->shader_info->so.num_outputs && !ctx->args->is_gs_copy_shader &&
-       ctx->stage != MESA_SHADER_GEOMETRY && !ctx->shader_info->is_ngg) {
-      /* The GS copy shader emission already emits streamout. */
-      radv_emit_streamout(ctx, 0);
-   }
-
    /* Allocate a temporary array for the output values. */
    unsigned num_outputs = util_bitcount64(ctx->output_mask);
    outputs = malloc(num_outputs * sizeof(outputs[0]));
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index dc76e584efbd..bf87e9ac8395 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3839,7 +3839,8 @@ radv_postprocess_nir(struct radv_pipeline *pipeline,
 
    if (stage->stage == last_vgt_api_stage && stage->stage != MESA_SHADER_GEOMETRY && !lowered_ngg)
       NIR_PASS_V(stage->nir, ac_nir_lower_legacy_vs,
-                 stage->info.outinfo.export_prim_id ? VARYING_SLOT_PRIMITIVE_ID : -1, NULL);
+                 stage->info.outinfo.export_prim_id ? VARYING_SLOT_PRIMITIVE_ID : -1,
+                 &stage->info.so);
 
    NIR_PASS(_, stage->nir, nir_opt_idiv_const, 8);
 
-- 
GitLab


From 3d248dab369ebd2f0305853313d9a2da56d32bc9 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 30 Sep 2022 11:40:18 +0100
Subject: [PATCH 4/8] radv: make radv_use_llvm_for_stage device parameter const

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_private.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 56efccf62559..42be132fbbdd 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3149,7 +3149,7 @@ radv_queue_ring(struct radv_queue *queue)
  * specific shader stage (developers only).
  */
 static inline bool
-radv_use_llvm_for_stage(struct radv_device *device, UNUSED gl_shader_stage stage)
+radv_use_llvm_for_stage(const struct radv_device *device, UNUSED gl_shader_stage stage)
 {
    return device->physical_device->use_llvm;
 }
-- 
GitLab


From eba8a0d6dd79093671cd567a4bf8de54280bcd56 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 29 Sep 2022 12:43:05 +0100
Subject: [PATCH 5/8] radv,aco: implement GS copy shaders using NIR

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    |  7 +++--
 src/amd/compiler/aco_interface.cpp            |  4 +--
 src/amd/vulkan/radv_nir_to_llvm.c             | 16 +++++-------
 src/amd/vulkan/radv_pipeline.c                | 26 ++++++++++++++-----
 src/amd/vulkan/radv_shader.c                  | 12 ++++-----
 src/amd/vulkan/radv_shader_info.c             |  2 +-
 6 files changed, 37 insertions(+), 30 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 7b7aace2d82a..613e6e7e118d 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -7770,10 +7770,9 @@ visit_emit_vertex_with_counter(isel_context* ctx, nir_intrinsic_instr* instr)
 
    unsigned offset = 0;
    for (unsigned i = 0; i <= VARYING_SLOT_VAR31; i++) {
-      if (ctx->program->info.gs.output_streams[i] != stream)
-         continue;
-
       for (unsigned j = 0; j < 4; j++) {
+         if (((ctx->program->info.gs.output_streams[i] >> (j * 2)) & 0x3) != stream)
+            continue;
          if (!(ctx->program->info.gs.output_usage_mask[i] & (1 << j)))
             continue;
 
@@ -12051,7 +12050,7 @@ select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_
 
       unsigned offset = 0;
       for (unsigned i = 0; i <= VARYING_SLOT_VAR31; ++i) {
-         if (program->info.gs.output_streams[i] != stream)
+         if ((program->info.gs.output_streams[i] & 0x3) != stream)
             continue;
 
          unsigned output_usage_mask = program->info.gs.output_usage_mask[i];
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 03544424c2e7..b2bf8dedf821 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -231,9 +231,7 @@ aco_compile_shader(const struct aco_compiler_options* options,
    program->debug.private_data = options->debug.private_data;
 
    /* Instruction Selection */
-   if (args->is_gs_copy_shader)
-      aco::select_gs_copy_shader(program.get(), shaders[0], &config, options, info, args);
-   else if (args->is_trap_handler_shader)
+   if (args->is_trap_handler_shader)
       aco::select_trap_handler_shader(program.get(), shaders[0], &config, options, info, args);
    else
       aco::select_program(program.get(), shader_count, shaders, &config, options, info, args);
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 3037658c161d..6595c11ea3ec 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -205,10 +205,12 @@ visit_emit_vertex_with_counter(struct ac_shader_abi *abi, unsigned stream, LLVMV
       bool *is_16bit_ptr = &abi->is_16bit[i * 4];
       int length = util_last_bit(output_usage_mask);
 
-      if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
+      if (!(ctx->output_mask & (1ull << i)))
          continue;
 
       for (unsigned j = 0; j < length; j++) {
+         if (((output_stream >> (j * 2)) & 0x3) != stream)
+            continue;
          if (!(output_usage_mask & (1 << j)))
             continue;
 
@@ -1012,11 +1014,11 @@ handle_vs_outputs_post(struct radv_shader_context *ctx)
       outputs[noutput].slot_name = i;
       outputs[noutput].slot_index = i == VARYING_SLOT_CLIP_DIST1;
 
-      if (ctx->stage == MESA_SHADER_VERTEX && !ctx->args->is_gs_copy_shader) {
+      if (ctx->stage == MESA_SHADER_VERTEX) {
          outputs[noutput].usage_mask = ctx->shader_info->vs.output_usage_mask[i];
       } else if (ctx->stage == MESA_SHADER_TESS_EVAL) {
          outputs[noutput].usage_mask = ctx->shader_info->tes.output_usage_mask[i];
-      } else if (ctx->args->is_gs_copy_shader|| ctx->stage == MESA_SHADER_GEOMETRY) {
+      } else if (ctx->stage == MESA_SHADER_GEOMETRY) {
          outputs[noutput].usage_mask = ctx->shader_info->gs.output_usage_mask[i];
       }
 
@@ -1642,7 +1644,7 @@ ac_gs_copy_shader_emit(struct radv_shader_context *ctx)
       offset = 0;
       for (unsigned i = 0; i < AC_LLVM_MAX_OUTPUTS; ++i) {
          unsigned output_usage_mask = ctx->shader_info->gs.output_usage_mask[i];
-         unsigned output_stream = ctx->shader_info->gs.output_streams[i];
+         unsigned output_stream = ctx->shader_info->gs.output_streams[i] & 0x3;
          int length = util_last_bit(output_usage_mask);
 
          if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
@@ -1745,9 +1747,5 @@ llvm_compile_shader(const struct radv_nir_compiler_options *options,
 
    radv_init_llvm_compiler(&ac_llvm, options->family, tm_options, info->wave_size);
 
-   if (args->is_gs_copy_shader) {
-      radv_compile_gs_copy_shader(&ac_llvm, options, info, *shaders, binary, args);
-   } else {
-      radv_compile_nir_shader(&ac_llvm, options, info, binary, args, shaders, shader_count);
-   }
+   radv_compile_nir_shader(&ac_llvm, options, info, binary, args, shaders, shader_count);
 }
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index bf87e9ac8395..f39367837573 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3586,15 +3586,23 @@ radv_pipeline_create_gs_copy_shader(struct radv_pipeline *pipeline,
                                     struct radv_shader_binary **gs_copy_binary)
 {
    struct radv_device *device = pipeline->device;
-   struct radv_shader_info info = {0};
 
-   radv_nir_shader_info_pass(device, stages[MESA_SHADER_GEOMETRY].nir, pipeline_layout, pipeline_key,
-                             &info);
+   const struct radv_shader_info *gs_info = &stages[MESA_SHADER_GEOMETRY].info;
+   nir_shader *nir = ac_nir_create_gs_copy_shader(stages[MESA_SHADER_GEOMETRY].nir,
+                                                  &gs_info->so, VARYING_SLOT_MAX,
+                                                  gs_info->gs.output_usage_mask,
+                                                  gs_info->gs.output_streams, NULL,
+                                                  gs_info->gs.num_stream_output_components);
+   nir_validate_shader(nir, "after ac_nir_create_gs_copy_shader");
+   nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
+
+   struct radv_shader_info info = {0};
+   radv_nir_shader_info_pass(device, nir, pipeline_layout, pipeline_key, &info);
    info.wave_size = 64; /* Wave32 not supported. */
    info.workgroup_size = 64; /* HW VS: separate waves, no workgroups */
-   info.ballot_bit_size = 64;
+   info.so = gs_info->so;
 
-   if (stages[MESA_SHADER_GEOMETRY].info.outinfo.export_clip_dists) {
+   if (gs_info->outinfo.export_clip_dists) {
       if (stages[MESA_SHADER_GEOMETRY].nir->info.outputs_written & VARYING_BIT_CLIP_DIST0)
          info.outinfo.vs_output_param_offset[VARYING_SLOT_CLIP_DIST0] = info.outinfo.param_exports++;
       if (stages[MESA_SHADER_GEOMETRY].nir->info.outputs_written & VARYING_BIT_CLIP_DIST1)
@@ -3611,8 +3619,12 @@ radv_pipeline_create_gs_copy_shader(struct radv_pipeline *pipeline,
    info.user_sgprs_locs = gs_copy_args.user_sgprs_locs;
    info.inline_push_constant_mask = gs_copy_args.ac.inline_push_const_mask;
 
-   return radv_create_gs_copy_shader(device, stages[MESA_SHADER_GEOMETRY].nir, &info, &gs_copy_args,
-                                     gs_copy_binary, keep_executable_info, keep_statistic_info,
+   NIR_PASS_V(nir, radv_nir_lower_abi, device->physical_device->rad_info.gfx_level, &info,
+              &gs_copy_args, pipeline_key, radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX),
+              device->physical_device->rad_info.address32_hi);
+
+   return radv_create_gs_copy_shader(device, nir, &info, &gs_copy_args, gs_copy_binary,
+                                     keep_executable_info, keep_statistic_info,
                                      pipeline_key->optimisations_disabled);
 }
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index d35ba8533bde..0fcf7817311f 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2343,8 +2343,8 @@ radv_aco_build_shader_binary(void **bin,
 static struct radv_shader *
 shader_compile(struct radv_device *device, struct nir_shader *const *shaders, int shader_count, gl_shader_stage stage,
                const struct radv_shader_info *info, const struct radv_shader_args *args,
-               struct radv_nir_compiler_options *options, bool gs_copy_shader,
-               bool trap_handler_shader, bool keep_shader_info, bool keep_statistic_info,
+               struct radv_nir_compiler_options *options, bool trap_handler_shader,
+               bool keep_shader_info, bool keep_statistic_info,
                struct radv_shader_binary **binary_out)
 {
    enum radeon_family chip_family = device->physical_device->rad_info.family;
@@ -2358,7 +2358,7 @@ shader_compile(struct radv_device *device, struct nir_shader *const *shaders, in
    options->family = chip_family;
    options->gfx_level = device->physical_device->rad_info.gfx_level;
    options->has_3d_cube_border_color_mipmap = device->physical_device->rad_info.has_3d_cube_border_color_mipmap;
-   options->dump_shader = radv_can_dump_shader(device, shaders[0], gs_copy_shader || trap_handler_shader);
+   options->dump_shader = radv_can_dump_shader(device, shaders[0], trap_handler_shader);
    options->dump_preoptir =
       options->dump_shader && device->instance->debug_flags & RADV_DEBUG_PREOPTIR;
    options->record_ir = keep_shader_info;
@@ -2431,7 +2431,7 @@ radv_shader_nir_to_asm(struct radv_device *device, struct radv_pipeline_stage *p
    options.wgp_mode = radv_should_use_wgp_mode(device, stage, &pl_stage->info);
 
    return shader_compile(device, shaders, shader_count, stage, &pl_stage->info,
-                         &pl_stage->args, &options, false, false, keep_shader_info,
+                         &pl_stage->args, &options, false, keep_shader_info,
                          keep_statistic_info, binary_out);
 }
 
@@ -2446,7 +2446,7 @@ radv_create_gs_copy_shader(struct radv_device *device, struct nir_shader *shader
 
    options.key.optimisations_disabled = disable_optimizations;
 
-   return shader_compile(device, &shader, 1, stage, info, args, &options, true, false,
+   return shader_compile(device, &shader, 1, stage, info, args, &options, false,
                          keep_shader_info, keep_statistic_info, binary_out);
 }
 
@@ -2476,7 +2476,7 @@ radv_create_trap_handler_shader(struct radv_device *device)
                             MESA_SHADER_COMPUTE, false, MESA_SHADER_VERTEX, &args);
 
    shader = shader_compile(device, &b.shader, 1, MESA_SHADER_COMPUTE, &info, &args, &options,
-                           false, true, false, false, &binary);
+                           true, false, false, &binary);
 
    trap->alloc = radv_alloc_shader_memory(device, shader->code_size, NULL);
 
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index e33d104b0bd1..4a27c2507691 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -464,7 +464,7 @@ gather_shader_info_gs(const nir_shader *nir, struct radv_shader_info *info)
       assert(stream < 4);
 
       info->gs.num_stream_output_components[stream] += num_components;
-      info->gs.output_streams[idx] = stream;
+      info->gs.output_streams[idx] = stream | (stream << 2) | (stream << 4) | (stream << 6);
    }
 }
 
-- 
GitLab


From ffe591f705786c247123ed812d0a469228e40f33 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 17 Oct 2022 20:26:51 +0100
Subject: [PATCH 6/8] radv,aco: remove old GS copy shader code

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 103 +------------
 src/amd/compiler/aco_instruction_selection.h  |   3 +-
 .../aco_instruction_selection_setup.cpp       |  28 ++--
 src/amd/compiler/aco_interface.cpp            |   1 -
 src/amd/compiler/aco_interface.h              |   1 -
 src/amd/compiler/aco_ir.h                     |   6 -
 src/amd/compiler/aco_print_ir.cpp             |   2 -
 src/amd/vulkan/radv_nir_to_llvm.c             | 139 +-----------------
 src/amd/vulkan/radv_shader.c                  |   5 +-
 src/amd/vulkan/radv_shader.h                  |   1 -
 10 files changed, 15 insertions(+), 274 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 613e6e7e118d..ab311ae57098 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11884,7 +11884,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
                const struct aco_shader_info* info,
                const struct radv_shader_args* args)
 {
-   isel_context ctx = setup_isel_context(program, shader_count, shaders, config, options, info, args, false, false);
+   isel_context ctx = setup_isel_context(program, shader_count, shaders, config, options, info, args, false);
    if_context ic_merged_wave_info;
    bool ngg_gs = ctx.stage.hw == HWStage::NGG && ctx.stage.has(SWStage::GS);
 
@@ -12002,105 +12002,6 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
    cleanup_cfg(program);
 }
 
-void
-select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_config* config,
-                      const struct aco_compiler_options* options,
-                      const struct aco_shader_info* info,
-                      const struct radv_shader_args* args)
-{
-   isel_context ctx = setup_isel_context(program, 1, &gs_shader, config, options, info, args, true, false);
-
-   ctx.block->fp_mode = program->next_fp_mode;
-
-   add_startpgm(&ctx);
-   append_logical_start(ctx.block);
-
-   Builder bld(ctx.program, ctx.block);
-
-   Temp gsvs_ring = bld.smem(aco_opcode::s_load_dwordx4, bld.def(s4),
-                             program->private_segment_buffer, Operand::c32(RING_GSVS_VS * 16u));
-
-   Operand stream_id = Operand::zero();
-   if (program->info.so.num_outputs)
-      stream_id = bld.sop2(aco_opcode::s_bfe_u32, bld.def(s1), bld.def(s1, scc),
-                           get_arg(&ctx, ctx.args->ac.streamout_config), Operand::c32(0x20018u));
-
-   Temp vtx_offset = bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(2u),
-                              get_arg(&ctx, ctx.args->ac.vertex_id));
-
-   std::stack<if_context, std::vector<if_context>> if_contexts;
-
-   for (unsigned stream = 0; stream < 4; stream++) {
-      if (stream_id.isConstant() && stream != stream_id.constantValue())
-         continue;
-
-      unsigned num_components = program->info.gs.num_stream_output_components[stream];
-      if (stream > 0 && (!num_components || !program->info.so.num_outputs))
-         continue;
-
-      memset(ctx.outputs.mask, 0, sizeof(ctx.outputs.mask));
-
-      if (!stream_id.isConstant()) {
-         Temp cond =
-            bld.sopc(aco_opcode::s_cmp_eq_u32, bld.def(s1, scc), stream_id, Operand::c32(stream));
-         if_contexts.emplace();
-         begin_uniform_if_then(&ctx, &if_contexts.top(), cond);
-         bld.reset(ctx.block);
-      }
-
-      unsigned offset = 0;
-      for (unsigned i = 0; i <= VARYING_SLOT_VAR31; ++i) {
-         if ((program->info.gs.output_streams[i] & 0x3) != stream)
-            continue;
-
-         unsigned output_usage_mask = program->info.gs.output_usage_mask[i];
-         unsigned length = util_last_bit(output_usage_mask);
-         for (unsigned j = 0; j < length; ++j) {
-            if (!(output_usage_mask & (1 << j)))
-               continue;
-
-            Temp val = bld.tmp(v1);
-            unsigned const_offset = offset * program->info.gs.vertices_out * 16 * 4;
-            load_vmem_mubuf(&ctx, val, gsvs_ring, vtx_offset, Temp(), Temp(), const_offset, 4, 1, 0, true,
-                            true, memory_sync_info());
-
-            ctx.outputs.mask[i] |= 1 << j;
-            ctx.outputs.temps[i * 4u + j] = val;
-
-            offset++;
-         }
-      }
-
-      if (program->info.so.num_outputs) {
-         emit_streamout(&ctx, stream);
-         bld.reset(ctx.block);
-      }
-
-      if (stream == 0) {
-         create_vs_exports(&ctx);
-      }
-
-      if (!stream_id.isConstant()) {
-         begin_uniform_if_else(&ctx, &if_contexts.top());
-         bld.reset(ctx.block);
-      }
-   }
-
-   while (!if_contexts.empty()) {
-      end_uniform_if(&ctx, &if_contexts.top());
-      if_contexts.pop();
-   }
-
-   program->config->float_mode = program->blocks[0].fp_mode.val;
-
-   append_logical_end(ctx.block);
-   ctx.block->kind |= block_kind_uniform;
-   bld.reset(ctx.block);
-   bld.sopp(aco_opcode::s_endpgm);
-
-   cleanup_cfg(program);
-}
-
 void
 select_trap_handler_shader(Program* program, struct nir_shader* shader, ac_shader_config* config,
                            const struct aco_compiler_options* options,
@@ -12517,7 +12418,7 @@ select_ps_epilog(Program* program, const struct aco_ps_epilog_key* key, ac_shade
                  const struct aco_shader_info* info,
                  const struct radv_shader_args* args)
 {
-   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, false, true);
+   isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, true);
 
    ctx.block->fp_mode = program->next_fp_mode;
 
diff --git a/src/amd/compiler/aco_instruction_selection.h b/src/amd/compiler/aco_instruction_selection.h
index 4c3717818028..9f40a1ebf46a 100644
--- a/src/amd/compiler/aco_instruction_selection.h
+++ b/src/amd/compiler/aco_instruction_selection.h
@@ -127,8 +127,7 @@ isel_context setup_isel_context(Program* program, unsigned shader_count,
                                 struct nir_shader* const* shaders, ac_shader_config* config,
                                 const struct aco_compiler_options* options,
                                 const struct aco_shader_info* info,
-                                const struct radv_shader_args* args,
-                                bool is_gs_copy_shader, bool is_ps_epilog);
+                                const struct radv_shader_args* args, bool is_ps_epilog);
 
 } // namespace aco
 
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 61064622988f..c7356e452e3d 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -435,7 +435,7 @@ init_context(isel_context* ctx, nir_shader* shader)
    /* we'll need these for isel */
    nir_metadata_require(impl, nir_metadata_block_index);
 
-   if (!ctx->stage.has(SWStage::GSCopy) && ctx->options->dump_preoptir) {
+   if (ctx->options->dump_preoptir) {
       fprintf(stderr, "NIR shader before instruction selection:\n");
       nir_print_shader(shader, stderr);
    }
@@ -805,8 +805,7 @@ isel_context
 setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* const* shaders,
                    ac_shader_config* config, const struct aco_compiler_options* options,
                    const struct aco_shader_info* info,
-                   const struct radv_shader_args* args, bool is_gs_copy_shader,
-                   bool is_ps_epilog)
+                   const struct radv_shader_args* args, bool is_ps_epilog)
 {
    SWStage sw_stage = SWStage::None;
    for (unsigned i = 0; i < shader_count; i++) {
@@ -814,9 +813,7 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
       case MESA_SHADER_VERTEX: sw_stage = sw_stage | SWStage::VS; break;
       case MESA_SHADER_TESS_CTRL: sw_stage = sw_stage | SWStage::TCS; break;
       case MESA_SHADER_TESS_EVAL: sw_stage = sw_stage | SWStage::TES; break;
-      case MESA_SHADER_GEOMETRY:
-         sw_stage = sw_stage | (is_gs_copy_shader ? SWStage::GSCopy : SWStage::GS);
-         break;
+      case MESA_SHADER_GEOMETRY: sw_stage = sw_stage | SWStage::GS; break;
       case MESA_SHADER_FRAGMENT: sw_stage = sw_stage | SWStage::FS; break;
       case MESA_SHADER_COMPUTE: sw_stage = sw_stage | SWStage::CS; break;
       case MESA_SHADER_TASK: sw_stage = sw_stage | SWStage::TS; break;
@@ -845,8 +842,6 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
       hw_stage = HWStage::FS;
    else if (sw_stage == SWStage::CS)
       hw_stage = HWStage::CS;
-   else if (sw_stage == SWStage::GSCopy)
-      hw_stage = HWStage::VS;
    else if (sw_stage == SWStage::TS)
       hw_stage = HWStage::CS; /* Task shaders are implemented with compute shaders. */
    else if (sw_stage == SWStage::MS)
@@ -898,19 +893,14 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
    calc_min_waves(program);
 
    unsigned scratch_size = 0;
-   if (program->stage == gs_copy_vs) {
-      assert(shader_count == 1);
-      setup_vs_output_info(&ctx, shaders[0]);
-   } else {
-      for (unsigned i = 0; i < shader_count; i++) {
-         nir_shader* nir = shaders[i];
-         setup_nir(&ctx, nir);
-      }
-
-      for (unsigned i = 0; i < shader_count; i++)
-         scratch_size = std::max(scratch_size, shaders[i]->scratch_size);
+   for (unsigned i = 0; i < shader_count; i++) {
+      nir_shader* nir = shaders[i];
+      setup_nir(&ctx, nir);
    }
 
+   for (unsigned i = 0; i < shader_count; i++)
+      scratch_size = std::max(scratch_size, shaders[i]->scratch_size);
+
    ctx.program->config->scratch_bytes_per_wave = align(scratch_size * ctx.program->wave_size, 1024);
 
    unsigned nir_num_blocks = 0;
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index b2bf8dedf821..c3d89712cc7f 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -257,7 +257,6 @@ aco_compile_shader(const struct aco_compiler_options* options,
 
    (*build_binary)(binary,
                    shaders[shader_count - 1]->info.stage,
-                   args->is_gs_copy_shader,
                    &config,
                    llvm_ir.c_str(),
                    llvm_ir.size(),
diff --git a/src/amd/compiler/aco_interface.h b/src/amd/compiler/aco_interface.h
index c404038c42d7..09410faf2e58 100644
--- a/src/amd/compiler/aco_interface.h
+++ b/src/amd/compiler/aco_interface.h
@@ -46,7 +46,6 @@ struct aco_compiler_statistic_info {
 
 typedef void (aco_callback)(void **priv_ptr,
                             gl_shader_stage stage,
-                            bool is_gs_copy_shader,
                             const struct ac_shader_config *config,
                             const char *llvm_ir_str,
                             unsigned llvm_ir_size,
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index b2c9db441e08..91976875455e 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2024,7 +2024,6 @@ enum class SWStage : uint16_t {
    CS = 1 << 5,     /* Compute Shader */
    TS = 1 << 6,     /* Task Shader */
    MS = 1 << 7,     /* Mesh Shader */
-   GSCopy = 1 << 8, /* GS Copy Shader (internal) */
 
    /* Stage combinations merged to run on a single HWStage */
    VS_GS = VS | GS,
@@ -2089,7 +2088,6 @@ static constexpr Stage vertex_vs(HWStage::VS, SWStage::VS);
 static constexpr Stage fragment_fs(HWStage::FS, SWStage::FS);
 static constexpr Stage compute_cs(HWStage::CS, SWStage::CS);
 static constexpr Stage tess_eval_vs(HWStage::VS, SWStage::TES);
-static constexpr Stage gs_copy_vs(HWStage::VS, SWStage::GSCopy);
 /* Mesh shading pipeline */
 static constexpr Stage task_cs(HWStage::CS, SWStage::TS);
 static constexpr Stage mesh_ngg(HWStage::NGG, SWStage::MS);
@@ -2265,10 +2263,6 @@ void select_program(Program* program, unsigned shader_count, struct nir_shader*
                     ac_shader_config* config, const struct aco_compiler_options* options,
                     const struct aco_shader_info* info,
                     const struct radv_shader_args* args);
-void select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_config* config,
-                           const struct aco_compiler_options* options,
-                           const struct aco_shader_info* info,
-                           const struct radv_shader_args* args);
 void select_trap_handler_shader(Program* program, struct nir_shader* shader,
                                 ac_shader_config* config,
                                 const struct aco_compiler_options* options,
diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index 2dcf088a7013..b0f4ae471c12 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -869,8 +869,6 @@ print_stage(Stage stage, FILE* output)
       fprintf(output, "compute_cs");
    else if (stage == fragment_fs)
       fprintf(output, "fragment_fs");
-   else if (stage == gs_copy_vs)
-      fprintf(output, "gs_copy_vs");
    else if (stage == vertex_ls)
       fprintf(output, "vertex_ls");
    else if (stage == vertex_es)
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 6595c11ea3ec..158d7edd5c38 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -996,8 +996,9 @@ radv_llvm_export_vs(struct radv_shader_context *ctx, struct radv_shader_output_v
 }
 
 static void
-handle_vs_outputs_post(struct radv_shader_context *ctx)
+radv_llvm_visit_export_vertex(struct ac_shader_abi *abi)
 {
+   struct radv_shader_context *ctx = radv_shader_context_from_abi(abi);
    const struct radv_vs_output_info *outinfo = &ctx->shader_info->outinfo;
    const bool export_clip_dists = outinfo->export_clip_dists;
    struct radv_shader_output_values *outputs;
@@ -1166,14 +1167,6 @@ ac_llvm_finalize_module(struct radv_shader_context *ctx, LLVMPassManagerRef pass
    ac_llvm_context_dispose(&ctx->ac);
 }
 
-static void
-radv_llvm_visit_export_vertex(struct ac_shader_abi *abi)
-{
-   struct radv_shader_context *ctx = radv_shader_context_from_abi(abi);
-
-   handle_vs_outputs_post(ctx);
-}
-
 static void
 ac_setup_rings(struct radv_shader_context *ctx)
 {
@@ -1604,134 +1597,6 @@ radv_compile_nir_shader(struct ac_llvm_compiler *ac_llvm,
                           options);
 }
 
-static void
-ac_gs_copy_shader_emit(struct radv_shader_context *ctx)
-{
-   LLVMValueRef vtx_offset =
-      LLVMBuildMul(ctx->ac.builder, ac_get_arg(&ctx->ac, ctx->args->ac.vertex_id),
-                   LLVMConstInt(ctx->ac.i32, 4, false), "");
-   LLVMValueRef stream_id;
-
-   /* Fetch the vertex stream ID. */
-   if (ctx->shader_info->so.num_outputs) {
-      stream_id =
-         ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->ac.streamout_config), 24, 2);
-   } else {
-      stream_id = ctx->ac.i32_0;
-   }
-
-   LLVMBasicBlockRef end_bb;
-   LLVMValueRef switch_inst;
-
-   end_bb = LLVMAppendBasicBlockInContext(ctx->ac.context, ctx->main_function.value, "end");
-   switch_inst = LLVMBuildSwitch(ctx->ac.builder, stream_id, end_bb, 4);
-
-   for (unsigned stream = 0; stream < 4; stream++) {
-      unsigned num_components = ctx->shader_info->gs.num_stream_output_components[stream];
-      LLVMBasicBlockRef bb;
-      unsigned offset;
-
-      if (stream > 0 && !num_components)
-         continue;
-
-      if (stream > 0 && !ctx->shader_info->so.num_outputs)
-         continue;
-
-      bb = LLVMInsertBasicBlockInContext(ctx->ac.context, end_bb, "out");
-      LLVMAddCase(switch_inst, LLVMConstInt(ctx->ac.i32, stream, 0), bb);
-      LLVMPositionBuilderAtEnd(ctx->ac.builder, bb);
-
-      offset = 0;
-      for (unsigned i = 0; i < AC_LLVM_MAX_OUTPUTS; ++i) {
-         unsigned output_usage_mask = ctx->shader_info->gs.output_usage_mask[i];
-         unsigned output_stream = ctx->shader_info->gs.output_streams[i] & 0x3;
-         int length = util_last_bit(output_usage_mask);
-
-         if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
-            continue;
-
-         for (unsigned j = 0; j < length; j++) {
-            LLVMValueRef value, soffset;
-
-            if (!(output_usage_mask & (1 << j)))
-               continue;
-
-            soffset = LLVMConstInt(ctx->ac.i32, offset * ctx->shader->info.gs.vertices_out * 16 * 4,
-                                   false);
-
-            offset++;
-
-            value = ac_build_buffer_load(&ctx->ac, ctx->gsvs_ring[0], 1, ctx->ac.i32_0, vtx_offset,
-                                         soffset, ctx->ac.f32, ac_glc | ac_slc, true, false);
-
-            LLVMTypeRef type = LLVMGetAllocatedType(ctx->abi.outputs[ac_llvm_reg_index_soa(i, j)]);
-            if (ac_get_type_size(type) == 2) {
-               value = LLVMBuildBitCast(ctx->ac.builder, value, ctx->ac.i32, "");
-               value = LLVMBuildTrunc(ctx->ac.builder, value, ctx->ac.i16, "");
-            }
-
-            LLVMBuildStore(ctx->ac.builder, ac_to_float(&ctx->ac, value),
-                           ctx->abi.outputs[ac_llvm_reg_index_soa(i, j)]);
-         }
-      }
-
-      if (ctx->shader_info->so.num_outputs)
-         radv_emit_streamout(ctx, stream);
-
-      if (stream == 0) {
-         handle_vs_outputs_post(ctx);
-      }
-
-      LLVMBuildBr(ctx->ac.builder, end_bb);
-   }
-
-   LLVMPositionBuilderAtEnd(ctx->ac.builder, end_bb);
-}
-
-static void
-radv_compile_gs_copy_shader(struct ac_llvm_compiler *ac_llvm,
-                            const struct radv_nir_compiler_options *options,
-                            const struct radv_shader_info *info,
-                            struct nir_shader *geom_shader,
-                            struct radv_shader_binary **rbinary,
-                            const struct radv_shader_args *args)
-{
-   struct radv_shader_context ctx = {0};
-   ctx.args = args;
-   ctx.options = options;
-   ctx.shader_info = info;
-
-   assert(args->is_gs_copy_shader);
-
-   ac_llvm_context_init(&ctx.ac, ac_llvm, options->gfx_level, options->family,
-                        options->has_3d_cube_border_color_mipmap,
-                        AC_FLOAT_MODE_DEFAULT, 64, 64);
-   ctx.context = ctx.ac.context;
-
-   ctx.stage = MESA_SHADER_VERTEX;
-   ctx.shader = geom_shader;
-
-   create_function(&ctx, MESA_SHADER_VERTEX, false);
-
-   ac_setup_rings(&ctx);
-
-   nir_foreach_shader_out_variable(variable, geom_shader)
-   {
-      scan_shader_output_decl(&ctx, variable, geom_shader, MESA_SHADER_VERTEX);
-      ac_handle_shader_output_decl(&ctx.ac, &ctx.abi, geom_shader, variable, MESA_SHADER_VERTEX);
-   }
-
-   ac_gs_copy_shader_emit(&ctx);
-
-   LLVMBuildRetVoid(ctx.ac.builder);
-
-   ac_llvm_finalize_module(&ctx, ac_llvm->passmgr);
-
-   ac_compile_llvm_module(ac_llvm, ctx.ac.module, rbinary, MESA_SHADER_VERTEX, "GS Copy Shader",
-                          options);
-   (*rbinary)->is_gs_copy_shader = true;
-}
-
 void
 llvm_compile_shader(const struct radv_nir_compiler_options *options,
                     const struct radv_shader_info *info, unsigned shader_count,
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 0fcf7817311f..bf1bc57d80db 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2035,8 +2035,7 @@ radv_open_rtld_binary(struct radv_device *device, const struct radv_shader *shad
    unsigned num_lds_symbols = 0;
 
    if (device->physical_device->rad_info.gfx_level >= GFX9 &&
-       (binary->stage == MESA_SHADER_GEOMETRY || binary->info.is_ngg) &&
-       !binary->is_gs_copy_shader) {
+       (binary->stage == MESA_SHADER_GEOMETRY || binary->info.is_ngg)) {
       struct ac_rtld_symbol *sym = &lds_symbols[num_lds_symbols++];
       sym->name = "esgs_ring";
       sym->size = binary->info.ngg_info.esgs_ring_size;
@@ -2285,7 +2284,6 @@ radv_dump_nir_shaders(struct nir_shader *const *shaders, int shader_count)
 static void
 radv_aco_build_shader_binary(void **bin,
                              gl_shader_stage stage,
-                             bool is_gs_copy_shader,
                              const struct ac_shader_config *config,
                              const char *llvm_ir_str,
                              unsigned llvm_ir_size,
@@ -2312,7 +2310,6 @@ radv_aco_build_shader_binary(void **bin,
    struct radv_shader_binary_legacy *legacy_binary = (struct radv_shader_binary_legacy *)calloc(size, 1);
    legacy_binary->base.type = RADV_BINARY_TYPE_LEGACY;
    legacy_binary->base.stage = stage;
-   legacy_binary->base.is_gs_copy_shader = is_gs_copy_shader;
    legacy_binary->base.total_size = size;
    legacy_binary->base.config = *config;
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index e5c75d3f2ab2..3aa5a503d65e 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -410,7 +410,6 @@ enum radv_shader_binary_type { RADV_BINARY_TYPE_LEGACY, RADV_BINARY_TYPE_RTLD };
 struct radv_shader_binary {
    enum radv_shader_binary_type type;
    gl_shader_stage stage;
-   bool is_gs_copy_shader;
 
    struct ac_shader_config config;
    struct radv_shader_info info;
-- 
GitLab


From 585094a852d36974f92b2507bbf527275ea56fa5 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 30 Sep 2022 19:49:56 +0100
Subject: [PATCH 7/8] radv,aco: remove old streamout code

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 113 -----------------
 src/amd/compiler/aco_shader_info.h            |  15 ---
 src/amd/vulkan/radv_aco_shader_info.h         |  19 ---
 src/amd/vulkan/radv_nir_to_llvm.c             | 120 ------------------
 4 files changed, 267 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index ab311ae57098..c4cb68eb2bb2 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11425,119 +11425,6 @@ create_fs_exports(isel_context* ctx)
    ctx->block->kind |= block_kind_export_end;
 }
 
-static void
-emit_stream_output(isel_context* ctx, Temp const* so_buffers, Temp const* so_write_offset,
-                   const struct aco_stream_output* output)
-{
-   assert(ctx->stage.hw == HWStage::VS);
-
-   unsigned loc = output->location;
-   unsigned buf = output->buffer;
-
-   unsigned writemask = output->component_mask & ctx->outputs.mask[loc];
-   while (writemask) {
-      int start, count;
-      u_bit_scan_consecutive_range(&writemask, &start, &count);
-      if (count == 3 && ctx->options->gfx_level == GFX6) {
-         /* GFX6 doesn't support storing vec3, split it. */
-         writemask |= 1u << (start + 2);
-         count = 2;
-      }
-
-      unsigned offset = output->offset + (start - (ffs(output->component_mask) - 1)) * 4;
-
-      Temp write_data = ctx->program->allocateTmp(RegClass(RegType::vgpr, count));
-      aco_ptr<Pseudo_instruction> vec{create_instruction<Pseudo_instruction>(
-         aco_opcode::p_create_vector, Format::PSEUDO, count, 1)};
-      for (int i = 0; i < count; ++i)
-         vec->operands[i] = Operand(ctx->outputs.temps[loc * 4 + start + i]);
-      vec->definitions[0] = Definition(write_data);
-      ctx->block->instructions.emplace_back(std::move(vec));
-
-      aco_opcode opcode = get_buffer_store_op(count * 4);
-      aco_ptr<MUBUF_instruction> store{
-         create_instruction<MUBUF_instruction>(opcode, Format::MUBUF, 4, 0)};
-      store->operands[0] = Operand(so_buffers[buf]);
-      store->operands[1] = Operand(so_write_offset[buf]);
-      store->operands[2] = Operand::c32(0);
-      store->operands[3] = Operand(write_data);
-      if (offset > 4095) {
-         /* Don't think this can happen in RADV, but maybe GL? It's easy to do this anyway. */
-         Builder bld(ctx->program, ctx->block);
-         store->operands[1] =
-            bld.vadd32(bld.def(v1), Operand::c32(offset), Operand(so_write_offset[buf]));
-      } else {
-         store->offset = offset;
-      }
-      store->offen = true;
-      store->glc = ctx->program->gfx_level < GFX11;
-      store->dlc = false;
-      store->slc = true;
-      ctx->block->instructions.emplace_back(std::move(store));
-   }
-}
-
-static void
-emit_streamout(isel_context* ctx, unsigned stream)
-{
-   Builder bld(ctx->program, ctx->block);
-
-   Temp so_vtx_count =
-      bld.sop2(aco_opcode::s_bfe_u32, bld.def(s1), bld.def(s1, scc),
-               get_arg(ctx, ctx->args->ac.streamout_config), Operand::c32(0x70010u));
-
-   Temp tid = emit_mbcnt(ctx, bld.tmp(v1));
-
-   Temp can_emit = bld.vopc(aco_opcode::v_cmp_gt_i32, bld.def(bld.lm), so_vtx_count, tid);
-
-   if_context ic;
-   begin_divergent_if_then(ctx, &ic, can_emit);
-
-   bld.reset(ctx->block);
-
-   Temp so_write_index =
-      bld.vadd32(bld.def(v1), get_arg(ctx, ctx->args->ac.streamout_write_index), tid);
-
-   Temp so_buffers[4];
-   Temp so_write_offset[4];
-   Temp buf_ptr = convert_pointer_to_64_bit(ctx, get_arg(ctx, ctx->args->streamout_buffers));
-
-   for (unsigned i = 0; i < 4; i++) {
-      unsigned stride = ctx->program->info.so.strides[i];
-      if (!stride)
-         continue;
-
-      so_buffers[i] = bld.smem(aco_opcode::s_load_dwordx4, bld.def(s4), buf_ptr,
-                               bld.copy(bld.def(s1), Operand::c32(i * 16u)));
-
-      if (stride == 1) {
-         Temp offset = bld.sop2(aco_opcode::s_add_i32, bld.def(s1), bld.def(s1, scc),
-                                get_arg(ctx, ctx->args->ac.streamout_write_index),
-                                get_arg(ctx, ctx->args->ac.streamout_offset[i]));
-         Temp new_offset = bld.vadd32(bld.def(v1), offset, tid);
-
-         so_write_offset[i] =
-            bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(2u), new_offset);
-      } else {
-         Temp offset = bld.v_mul_imm(bld.def(v1), so_write_index, stride * 4u);
-         Temp offset2 = bld.sop2(aco_opcode::s_mul_i32, bld.def(s1), Operand::c32(4u),
-                                 get_arg(ctx, ctx->args->ac.streamout_offset[i]));
-         so_write_offset[i] = bld.vadd32(bld.def(v1), offset, offset2);
-      }
-   }
-
-   for (unsigned i = 0; i < ctx->program->info.so.num_outputs; i++) {
-      const struct aco_stream_output* output = &ctx->program->info.so.outputs[i];
-      if (stream != output->stream)
-         continue;
-
-      emit_stream_output(ctx, so_buffers, so_write_offset, output);
-   }
-
-   begin_divergent_if_else(ctx, &ic);
-   end_divergent_if(ctx, &ic);
-}
-
 Pseudo_instruction*
 add_startpgm(struct isel_context* ctx)
 {
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index b09e25c1a8d6..a870b487f2b7 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -86,20 +86,6 @@ struct aco_vp_output_info {
    bool export_clip_dists;
 };
 
-struct aco_stream_output {
-   uint8_t location;
-   uint8_t buffer;
-   uint16_t offset;
-   uint8_t component_mask;
-   uint8_t stream;
-};
-
-struct aco_streamout_info {
-   uint16_t num_outputs;
-   struct aco_stream_output outputs[ACO_MAX_SO_OUTPUTS];
-   uint16_t strides[ACO_MAX_SO_BUFFERS];
-};
-
 struct aco_shader_info {
    uint8_t wave_size;
    bool is_ngg;
@@ -141,7 +127,6 @@ struct aco_shader_info {
    struct {
       uint8_t subgroup_size;
    } cs;
-   struct aco_streamout_info so;
 
    uint32_t gfx9_gs_ring_lds_size;
 };
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index bd20336f22fe..db80d7327226 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -34,24 +34,6 @@
 #define ASSIGN_FIELD(x) aco_info->x = radv->x
 #define ASSIGN_FIELD_CP(x) memcpy(&aco_info->x, &radv->x, sizeof(radv->x))
 
-static inline void
-radv_aco_convert_shader_so_info(struct aco_shader_info *aco_info,
-                       const struct radv_shader_info *radv)
-{
-   ASSIGN_FIELD(so.num_outputs);
-   for (unsigned i = 0; i < ACO_MAX_SO_OUTPUTS; i++) {
-      struct aco_stream_output *dst = &aco_info->so.outputs[i];
-      const struct pipe_stream_output *src = &radv->so.output[i];
-      dst->location = src->register_index;
-      dst->buffer = src->output_buffer;
-      dst->offset = src->dst_offset * 4;
-      dst->component_mask = u_bit_consecutive(src->start_component, src->num_components);
-      dst->stream = src->stream;
-   }
-   memcpy(&aco_info->so.strides, radv->so.stride, sizeof(radv->so.stride));
-   /* enabled_stream_buffers_mask unused */
-}
-
 static inline void
 radv_aco_convert_shader_vp_info(struct aco_vp_output_info *aco_info,
 				const struct radv_vs_output_info *radv)
@@ -105,7 +87,6 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info,
    ASSIGN_FIELD(ps.num_interp);
    ASSIGN_FIELD(ps.spi_ps_input);
    ASSIGN_FIELD(cs.subgroup_size);
-   radv_aco_convert_shader_so_info(aco_info, radv);
    aco_info->gfx9_gs_ring_lds_size = radv->gs_ring_info.lds_size;
 }
 
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 158d7edd5c38..e4b98d663636 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -727,126 +727,6 @@ radv_load_output(struct radv_shader_context *ctx, unsigned index, unsigned chan)
    return LLVMBuildLoad2(ctx->ac.builder, type, output, "");
 }
 
-static void
-radv_emit_stream_output(struct radv_shader_context *ctx, LLVMValueRef const *so_buffers,
-                        LLVMValueRef const *so_write_offsets,
-                        const struct pipe_stream_output *output,
-                        struct radv_shader_output_values *shader_out)
-{
-   unsigned num_comps = output->num_components;
-   unsigned buf = output->output_buffer;
-   unsigned offset = output->dst_offset * 4;
-   unsigned start;
-   LLVMValueRef out[4];
-
-   assert(num_comps && num_comps <= 4);
-   if (!num_comps || num_comps > 4)
-      return;
-
-   /* Get the first component. */
-   start = output->start_component;
-
-   /* Load the output as int. */
-   for (int i = 0; i < num_comps; i++) {
-      out[i] = ac_to_integer(&ctx->ac, shader_out->values[start + i]);
-   }
-
-   /* Pack the output. */
-   LLVMValueRef vdata = NULL;
-
-   switch (num_comps) {
-   case 1: /* as i32 */
-      vdata = out[0];
-      break;
-   case 2: /* as v2i32 */
-   case 3: /* as v3i32 */
-   case 4: /* as v4i32 */
-      vdata = ac_build_gather_values(&ctx->ac, out, num_comps);
-      break;
-   }
-
-   LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, so_write_offsets[buf],
-                                       LLVMConstInt(ctx->ac.i32, offset, 0), "");
-   ac_build_buffer_store_dword(&ctx->ac, so_buffers[buf], vdata, NULL, voffset, ctx->ac.i32_0,
-                               ac_glc | ac_slc);
-}
-
-static void
-radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
-{
-   int i;
-
-   /* Get bits [22:16], i.e. (so_param >> 16) & 127; */
-   assert(ctx->args->ac.streamout_config.used);
-   LLVMValueRef so_vtx_count = ac_build_bfe(
-      &ctx->ac, ac_get_arg(&ctx->ac, ctx->args->ac.streamout_config),
-      LLVMConstInt(ctx->ac.i32, 16, false), LLVMConstInt(ctx->ac.i32, 7, false), false);
-
-   LLVMValueRef tid = ac_get_thread_id(&ctx->ac);
-
-   /* can_emit = tid < so_vtx_count; */
-   LLVMValueRef can_emit = LLVMBuildICmp(ctx->ac.builder, LLVMIntULT, tid, so_vtx_count, "");
-
-   /* Emit the streamout code conditionally. This actually avoids
-    * out-of-bounds buffer access. The hw tells us via the SGPR
-    * (so_vtx_count) which threads are allowed to emit streamout data.
-    */
-   ac_build_ifcc(&ctx->ac, can_emit, 6501);
-   {
-      /* The buffer offset is computed as follows:
-       *   ByteOffset = streamout_offset[buffer_id]*4 +
-       *                (streamout_write_index + thread_id)*stride[buffer_id] +
-       *                attrib_offset
-       */
-      LLVMValueRef so_write_index = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_write_index);
-
-      /* Compute (streamout_write_index + thread_id). */
-      so_write_index = LLVMBuildAdd(ctx->ac.builder, so_write_index, tid, "");
-
-      /* Load the descriptor and compute the write offset for each
-       * enabled buffer.
-       */
-      LLVMValueRef so_write_offset[4] = {0};
-      LLVMValueRef so_buffers[4] = {0};
-      struct ac_llvm_pointer buf_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
-
-      for (i = 0; i < 4; i++) {
-         uint16_t stride = ctx->shader_info->so.stride[i];
-
-         if (!stride)
-            continue;
-
-         LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, i, false);
-
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
-
-         LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_offset[i]);
-
-         so_offset =
-            LLVMBuildMul(ctx->ac.builder, so_offset, LLVMConstInt(ctx->ac.i32, 4, false), "");
-
-         so_write_offset[i] = ac_build_imad(
-            &ctx->ac, so_write_index, LLVMConstInt(ctx->ac.i32, stride * 4, false), so_offset);
-      }
-
-      /* Write streamout data. */
-      for (i = 0; i < ctx->shader_info->so.num_outputs; i++) {
-         struct radv_shader_output_values shader_out = {0};
-         const struct pipe_stream_output *output = &ctx->shader_info->so.output[i];
-
-         if (stream != output->stream)
-            continue;
-
-         for (int j = 0; j < 4; j++) {
-            shader_out.values[j] = radv_load_output(ctx, output->register_index, j);
-         }
-
-         radv_emit_stream_output(ctx, so_buffers, so_write_offset, output, &shader_out);
-      }
-   }
-   ac_build_endif(&ctx->ac, 6501);
-}
-
 static void
 radv_build_param_exports(struct radv_shader_context *ctx, struct radv_shader_output_values *outputs,
                          unsigned noutput, const struct radv_vs_output_info *outinfo,
-- 
GitLab


From e0ea78249656a32f6c0ab4134adc9184766b0f79 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 28 Sep 2022 20:24:14 +0100
Subject: [PATCH 8/8] radv: compile GS copy shader after geometry shader

This affects the pipeline feedback durations.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index f39367837573..cc58ca0f6af9 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3648,13 +3648,6 @@ radv_pipeline_nir_to_asm(struct radv_pipeline *pipeline, struct radv_pipeline_st
    bool pipeline_has_ngg = last_vgt_api_stage != MESA_SHADER_NONE &&
                            stages[last_vgt_api_stage].info.is_ngg;
 
-   if (stages[MESA_SHADER_GEOMETRY].nir && !pipeline_has_ngg) {
-      pipeline->gs_copy_shader =
-         radv_pipeline_create_gs_copy_shader(pipeline, stages, pipeline_key, pipeline_layout,
-                                             keep_executable_info, keep_statistic_info,
-                                             gs_copy_binary);
-   }
-
    for (int s = MESA_VULKAN_SHADER_STAGES - 1; s >= 0; s--) {
       if (!(active_stages & (1 << s)) || pipeline->shaders[s])
          continue;
@@ -3684,6 +3677,13 @@ radv_pipeline_nir_to_asm(struct radv_pipeline *pipeline, struct radv_pipeline_st
                                                     pipeline_key, keep_executable_info,
                                                     keep_statistic_info, &binaries[s]);
 
+      if (s == MESA_SHADER_GEOMETRY && !pipeline_has_ngg) {
+         pipeline->gs_copy_shader =
+            radv_pipeline_create_gs_copy_shader(pipeline, stages, pipeline_key, pipeline_layout,
+                                                keep_executable_info, keep_statistic_info,
+                                                gs_copy_binary);
+      }
+
       stages[s].feedback.duration += os_time_get_nano() - stage_start;
 
       active_stages &= ~(1 << shaders[0]->info.stage);
-- 
GitLab

