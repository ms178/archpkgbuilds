From 0582f6b5ef575ff1dd0a62d2be9212e068032bc5 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 31 Aug 2022 11:00:10 +0200
Subject: [PATCH 01/13] radv: rework a comment about dynamic states when
 rasterization is disabled

Make it more generic instead of listing all states.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 71b3580346f5..df987f296be2 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1343,11 +1343,7 @@ radv_pipeline_needed_dynamic_state(const struct radv_graphics_pipeline *pipeline
                   RADV_DYNAMIC_PRIMITIVE_RESTART_ENABLE | RADV_DYNAMIC_PRIMITIVE_TOPOLOGY);
    }
 
-   /* If rasterization is disabled we do not care about any of the
-    * dynamic states, since they are all rasterization related only,
-    * except primitive topology, primitive restart enable, vertex
-    * binding stride and rasterization discard itself.
-    */
+   /* Disable dynamic states that are useless when rasterization is disabled. */
    if (!raster_enabled) {
       return RADV_DYNAMIC_PRIMITIVE_TOPOLOGY | RADV_DYNAMIC_VERTEX_INPUT_BINDING_STRIDE |
              RADV_DYNAMIC_PRIMITIVE_RESTART_ENABLE | RADV_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
-- 
GitLab


From 9b8e47d8cf70d570239a86af9fd0cb513e0c6062 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 31 Aug 2022 11:16:05 +0200
Subject: [PATCH 02/13] radv: emit the LDS size for TCS directly from the
 pipeline on GFX9+

To be consistent with the LDS shader config for LS, and this will
be emitted from the cmdbuf for dynamic patch control points.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 8 +++++++-
 src/amd/vulkan/radv_shader.c   | 6 ++----
 2 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index df987f296be2..dcceb4425263 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -4960,15 +4960,21 @@ radv_pipeline_emit_hw_hs(struct radeon_cmdbuf *cs, const struct radv_graphics_pi
    uint64_t va = radv_shader_get_va(shader);
 
    if (pdevice->rad_info.gfx_level >= GFX9) {
+      uint32_t rsrc2 = shader->config.rsrc2;
+
       if (pdevice->rad_info.gfx_level >= GFX10) {
+         rsrc2 |= S_00B42C_LDS_SIZE_GFX10(shader->info.tcs.num_lds_blocks);
+
          radeon_set_sh_reg(cs, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
       } else {
+         rsrc2 |= S_00B42C_LDS_SIZE_GFX9(shader->info.tcs.num_lds_blocks);
+
          radeon_set_sh_reg(cs, R_00B410_SPI_SHADER_PGM_LO_LS, va >> 8);
       }
 
       radeon_set_sh_reg_seq(cs, R_00B428_SPI_SHADER_PGM_RSRC1_HS, 2);
       radeon_emit(cs, shader->config.rsrc1);
-      radeon_emit(cs, shader->config.rsrc2);
+      radeon_emit(cs, rsrc2);
    } else {
       radeon_set_sh_reg_seq(cs, R_00B420_SPI_SHADER_PGM_LO_HS, 4);
       radeon_emit(cs, va >> 8);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 6f9b9a47ddb3..fa4e45ea17f7 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1725,12 +1725,10 @@ radv_postprocess_config(const struct radv_device *device, const struct ac_shader
             } else if (pdevice->rad_info.gfx_level <= GFX10_3) {
                vgpr_comp_cnt = 1;
             }
-            config_out->rsrc2 |=
-               S_00B42C_LDS_SIZE_GFX10(info->tcs.num_lds_blocks) | S_00B42C_EXCP_EN_GFX6(excp_en);
+            config_out->rsrc2 |= S_00B42C_EXCP_EN_GFX6(excp_en);
          } else {
             vgpr_comp_cnt = info->vs.needs_instance_id ? 2 : 1;
-            config_out->rsrc2 |=
-               S_00B42C_LDS_SIZE_GFX9(info->tcs.num_lds_blocks) | S_00B42C_EXCP_EN_GFX9(excp_en);
+            config_out->rsrc2 |= S_00B42C_EXCP_EN_GFX9(excp_en);
          }
       } else {
          config_out->rsrc2 |= S_00B12C_OC_LDS_EN(1) | S_00B12C_EXCP_EN(excp_en);
-- 
GitLab


From 3e2352aab0f327a9dd353274c9cb2389ccc40eb7 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 30 Aug 2022 16:34:14 +0200
Subject: [PATCH 03/13] radv: add
 radv_pipeline_key::dynamic_patch_control_points

This will be used to compile different tessellation shaders when
patch control points is dynamic.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 4 ++++
 src/amd/vulkan/radv_shader.h   | 1 +
 2 files changed, 5 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index dcceb4425263..8827d8c7fb14 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2734,6 +2734,10 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
 
    key.ps.has_epilog = false; /* TODO: hook up PS epilogs */
 
+   if (pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
+      key.dynamic_patch_control_points = true;
+   }
+
    return key;
 }
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 16d3dab1db3d..8a1098ff775a 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -62,6 +62,7 @@ struct radv_pipeline_key {
    uint32_t disable_sinking_load_input_fs : 1;
    uint32_t image_2d_view_of_3d : 1;
    uint32_t primitives_generated_query : 1;
+   uint32_t dynamic_patch_control_points : 1;
 
    struct {
       uint32_t instance_rate_inputs;
-- 
GitLab


From b465f766ea58f0197f10f56351a7587d658d7d57 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 31 Aug 2022 15:00:43 +0200
Subject: [PATCH 04/13] radv: skip computing some tess info when patch control
 points is dynamic

We don't know the value.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_shader_info.c | 82 ++++++++++++++++---------------
 1 file changed, 43 insertions(+), 39 deletions(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index d61d4399e6c0..bce47201e4bc 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -404,22 +404,24 @@ gather_shader_info_tcs(struct radv_device *device, const nir_shader *nir,
 {
    info->tcs.tcs_vertices_out = nir->info.tess.tcs_vertices_out;
 
-   /* Number of tessellation patches per workgroup processed by the current pipeline. */
-   info->num_tess_patches =
-      get_tcs_num_patches(pipeline_key->tcs.tess_input_vertices, nir->info.tess.tcs_vertices_out,
-                          info->tcs.num_linked_inputs, info->tcs.num_linked_outputs,
-                          info->tcs.num_linked_patch_outputs,
-                          device->physical_device->hs.tess_offchip_block_dw_size,
-                          device->physical_device->rad_info.gfx_level,
-                          device->physical_device->rad_info.family);
-
-   /* LDS size used by VS+TCS for storing TCS inputs and outputs. */
-   info->tcs.num_lds_blocks =
-      calculate_tess_lds_size(device->physical_device->rad_info.gfx_level,
-                              pipeline_key->tcs.tess_input_vertices,
-                              nir->info.tess.tcs_vertices_out, info->tcs.num_linked_inputs,
-                              info->num_tess_patches, info->tcs.num_linked_outputs,
-                              info->tcs.num_linked_patch_outputs);
+   if (!(pipeline_key->dynamic_patch_control_points)) {
+      /* Number of tessellation patches per workgroup processed by the current pipeline. */
+      info->num_tess_patches =
+         get_tcs_num_patches(pipeline_key->tcs.tess_input_vertices, nir->info.tess.tcs_vertices_out,
+                             info->tcs.num_linked_inputs, info->tcs.num_linked_outputs,
+                             info->tcs.num_linked_patch_outputs,
+                             device->physical_device->hs.tess_offchip_block_dw_size,
+                             device->physical_device->rad_info.gfx_level,
+                             device->physical_device->rad_info.family);
+
+      /* LDS size used by VS+TCS for storing TCS inputs and outputs. */
+      info->tcs.num_lds_blocks =
+         calculate_tess_lds_size(device->physical_device->rad_info.gfx_level,
+                                 pipeline_key->tcs.tess_input_vertices,
+                                 nir->info.tess.tcs_vertices_out, info->tcs.num_linked_inputs,
+                                 info->num_tess_patches, info->tcs.num_linked_outputs,
+                                 info->tcs.num_linked_patch_outputs);
+   }
 }
 
 static void
@@ -1316,29 +1318,31 @@ radv_link_shaders_info(struct radv_device *device,
                                         pipeline_key->tcs.tess_input_vertices,
                                         tcs_stage->info.tcs.tcs_vertices_out);
 
-      if (!radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
-         /* When the number of TCS input and output vertices are the same (typically 3):
-          * - There is an equal amount of LS and HS invocations
-          * - In case of merged LSHS shaders, the LS and HS halves of the shader always process the
-          *   exact same vertex. We can use this knowledge to optimize them.
-          *
-          * We don't set tcs_in_out_eq if the float controls differ because that might involve
-          * different float modes for the same block and our optimizer doesn't handle a instruction
-          * dominating another with a different mode.
-          */
-         vs_stage->info.vs.tcs_in_out_eq =
-            device->physical_device->rad_info.gfx_level >= GFX9 &&
-            pipeline_key->tcs.tess_input_vertices == tcs_stage->info.tcs.tcs_vertices_out &&
-            vs_stage->nir->info.float_controls_execution_mode ==
-               tcs_stage->nir->info.float_controls_execution_mode;
-
-         if (vs_stage->info.vs.tcs_in_out_eq)
-            vs_stage->info.vs.tcs_temp_only_input_mask =
-               tcs_stage->nir->info.inputs_read &
-               vs_stage->nir->info.outputs_written &
-               ~tcs_stage->nir->info.tess.tcs_cross_invocation_inputs_read &
-               ~tcs_stage->nir->info.inputs_read_indirectly &
-               ~vs_stage->nir->info.outputs_accessed_indirectly;
+      if (!(pipeline_key->dynamic_patch_control_points)) {
+         if (!radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
+            /* When the number of TCS input and output vertices are the same (typically 3):
+             * - There is an equal amount of LS and HS invocations
+             * - In case of merged LSHS shaders, the LS and HS halves of the shader always process
+             *   the exact same vertex. We can use this knowledge to optimize them.
+             *
+             * We don't set tcs_in_out_eq if the float controls differ because that might involve
+             * different float modes for the same block and our optimizer doesn't handle a
+             * instruction dominating another with a different mode.
+             */
+            vs_stage->info.vs.tcs_in_out_eq =
+               device->physical_device->rad_info.gfx_level >= GFX9 &&
+               pipeline_key->tcs.tess_input_vertices == tcs_stage->info.tcs.tcs_vertices_out &&
+               vs_stage->nir->info.float_controls_execution_mode ==
+                  tcs_stage->nir->info.float_controls_execution_mode;
+
+            if (vs_stage->info.vs.tcs_in_out_eq)
+               vs_stage->info.vs.tcs_temp_only_input_mask =
+                  tcs_stage->nir->info.inputs_read &
+                  vs_stage->nir->info.outputs_written &
+                  ~tcs_stage->nir->info.tess.tcs_cross_invocation_inputs_read &
+                  ~tcs_stage->nir->info.inputs_read_indirectly &
+                  ~vs_stage->nir->info.outputs_accessed_indirectly;
+         }
       }
    }
 
-- 
GitLab


From 36d27f2d980b1b6601dc945725f0db27d5511ec4 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 31 Aug 2022 15:01:02 +0200
Subject: [PATCH 05/13] radv: set workgroup_size to 256 when patch control
 points is dynamic

It's the maximum possible value. This is to ensure that compilers
don't optimize away barriers, like in ACO when workgroup_size is less
than or equal to wave_size, s_barrier is considered a no-op.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_shader_info.c | 32 ++++++++++++++++++-------------
 1 file changed, 19 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index bce47201e4bc..d31667b7cf68 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1306,19 +1306,25 @@ radv_link_shaders_info(struct radv_device *device,
 
       vs_stage->info.vs.as_ls = true;
 
-      vs_stage->info.workgroup_size =
-         ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
-                                        MESA_SHADER_VERTEX, tcs_stage->info.num_tess_patches,
-                                        pipeline_key->tcs.tess_input_vertices,
-                                        tcs_stage->info.tcs.tcs_vertices_out);
-
-      tcs_stage->info.workgroup_size =
-         ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
-                                        MESA_SHADER_TESS_CTRL, tcs_stage->info.num_tess_patches,
-                                        pipeline_key->tcs.tess_input_vertices,
-                                        tcs_stage->info.tcs.tcs_vertices_out);
-
-      if (!(pipeline_key->dynamic_patch_control_points)) {
+      if (pipeline_key->dynamic_patch_control_points) {
+         /* Set the workgroup size to the maximum possible value to ensure that compilers don't
+          * optimize barriers.
+          */
+         vs_stage->info.workgroup_size = 256;
+         tcs_stage->info.workgroup_size = 256;
+      } else {
+         vs_stage->info.workgroup_size =
+            ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
+                                           MESA_SHADER_VERTEX, tcs_stage->info.num_tess_patches,
+                                           pipeline_key->tcs.tess_input_vertices,
+                                           tcs_stage->info.tcs.tcs_vertices_out);
+
+         tcs_stage->info.workgroup_size =
+            ac_compute_lshs_workgroup_size(device->physical_device->rad_info.gfx_level,
+                                           MESA_SHADER_TESS_CTRL, tcs_stage->info.num_tess_patches,
+                                           pipeline_key->tcs.tess_input_vertices,
+                                           tcs_stage->info.tcs.tcs_vertices_out);
+
          if (!radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX)) {
             /* When the number of TCS input and output vertices are the same (typically 3):
              * - There is an equal amount of LS and HS invocations
-- 
GitLab


From dc6a34439e3138b7785f9c1745b579e701959bc8 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 30 Aug 2022 17:49:34 +0200
Subject: [PATCH 06/13] aco: do not skip a TCS barrier when patch control
 points is dynamic

We can't know these information at compile time.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 2 ++
 src/amd/compiler/aco_shader_info.h             | 1 +
 src/amd/vulkan/radv_aco_shader_info.h          | 1 +
 3 files changed, 4 insertions(+)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index cfb20a4a8b14..b465765f5f31 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11858,11 +11858,13 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
 
          /* Skip s_barrier from TCS when VS outputs are not stored in the LDS. */
          bool tcs_skip_barrier = ctx.stage == vertex_tess_control_hs &&
+                                 !ctx.options->key.dynamic_patch_control_points &&
                                  ctx.tcs_temp_only_inputs == nir->info.inputs_read;
 
          if (!ngg_gs && !tcs_skip_barrier) {
             sync_scope scope =
                ctx.stage == vertex_tess_control_hs &&
+                     !ctx.options->key.dynamic_patch_control_points &&
                      program->wave_size % ctx.options->key.tcs.tess_input_vertices == 0 &&
                      ctx.options->key.tcs.tess_input_vertices == nir->info.tess.tcs_vertices_out
                   ? scope_subgroup
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 3aa9cf46152a..61e99d116f71 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -154,6 +154,7 @@ enum aco_compiler_debug_level {
 struct aco_stage_input {
    uint32_t optimisations_disabled : 1;
    uint32_t image_2d_view_of_3d : 1;
+   uint32_t dynamic_patch_control_points : 1;
    struct {
       uint32_t instance_rate_inputs;
       uint32_t instance_rate_divisors[ACO_MAX_VERTEX_ATTRIBS];
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 0c966f33c263..d9b96df3e1b7 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -136,6 +136,7 @@ radv_aco_convert_pipe_key(struct aco_stage_input *aco_info,
 {
    ASSIGN_FIELD(optimisations_disabled);
    ASSIGN_FIELD(image_2d_view_of_3d);
+   ASSIGN_FIELD(dynamic_patch_control_points);
    ASSIGN_FIELD(vs.instance_rate_inputs);
    ASSIGN_FIELD_CP(vs.instance_rate_divisors);
    ASSIGN_FIELD_CP(vs.vertex_attribute_formats);
-- 
GitLab


From 27ed87e65742db30fcce90cea91aa3ce70a6982d Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 30 Aug 2022 17:05:11 +0200
Subject: [PATCH 07/13] radv: add shader arguments for dynamic patch control
 points

The number of patch control points (TCS) and the number of patches
(TCS+TES) would be passed through user SGPRs.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_shader.h      |  4 ++-
 src/amd/vulkan/radv_shader_args.c | 42 ++++++++++++++++++++++++++++++-
 src/amd/vulkan/radv_shader_args.h |  9 +++++++
 3 files changed, 53 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 8a1098ff775a..d0faa612c382 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -158,9 +158,11 @@ enum radv_ud_index {
    AC_UD_CS_TASK_IB,
    AC_UD_CS_MAX_UD,
    AC_UD_GS_MAX_UD,
+   AC_UD_TCS_OFFCHIP_LAYOUT = AC_UD_VS_MAX_UD,
    AC_UD_TCS_MAX_UD,
+   AC_UD_TES_NUM_PATCHES = AC_UD_SHADER_START,
    AC_UD_TES_MAX_UD,
-   AC_UD_MAX_UD = AC_UD_TCS_MAX_UD,
+   AC_UD_MAX_UD = AC_UD_CS_MAX_UD,
 };
 
 struct radv_stream_output {
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index 28cf810e9ed9..058fbbd48c8e 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -91,6 +91,17 @@ count_vs_user_sgprs(const struct radv_shader_info *info)
    return count;
 }
 
+static uint8_t
+count_tes_user_sgprs(const struct radv_pipeline_key *key)
+{
+   unsigned count = 0;
+
+   if (key->dynamic_patch_control_points)
+      count++; /* tes_num_patches */
+
+   return count;
+}
+
 static uint8_t
 count_ms_user_sgprs(const struct radv_shader_info *info)
 {
@@ -152,6 +163,7 @@ static void
 allocate_user_sgprs(enum amd_gfx_level gfx_level, const struct radv_shader_info *info,
                     struct radv_shader_args *args, gl_shader_stage stage, bool has_previous_stage,
                     gl_shader_stage previous_stage, bool needs_view_index, bool has_ngg_query,
+                    const struct radv_pipeline_key *key,
                     struct user_sgpr_info *user_sgpr_info)
 {
    uint8_t user_sgpr_count = 0;
@@ -196,8 +208,11 @@ allocate_user_sgprs(enum amd_gfx_level gfx_level, const struct radv_shader_info
          if (previous_stage == MESA_SHADER_VERTEX)
             user_sgpr_count += count_vs_user_sgprs(info);
       }
+      if (key->dynamic_patch_control_points)
+         user_sgpr_count += 1; /* tcs_offchip_layout */
       break;
    case MESA_SHADER_TESS_EVAL:
+      count_tes_user_sgprs(key);
       break;
    case MESA_SHADER_GEOMETRY:
       if (has_previous_stage) {
@@ -206,6 +221,8 @@ allocate_user_sgprs(enum amd_gfx_level gfx_level, const struct radv_shader_info
 
          if (previous_stage == MESA_SHADER_VERTEX) {
             user_sgpr_count += count_vs_user_sgprs(info);
+         } else if (previous_stage == MESA_SHADER_TESS_EVAL) {
+            user_sgpr_count += count_tes_user_sgprs(key);
          } else if (previous_stage == MESA_SHADER_MESH) {
             user_sgpr_count += count_ms_user_sgprs(info);
          }
@@ -555,7 +572,7 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
       args->user_sgprs_locs.shader_data[i].sgpr_idx = -1;
 
    allocate_user_sgprs(gfx_level, info, args, stage, has_previous_stage, previous_stage,
-                       needs_view_index, has_ngg_query, &user_sgpr_info);
+                       needs_view_index, has_ngg_query, key, &user_sgpr_info);
 
    if (args->explicit_scratch_args) {
       ac_add_arg(&args->ac, AC_ARG_SGPR, 2, AC_ARG_CONST_DESC_PTR, &args->ring_offsets);
@@ -671,6 +688,10 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
             ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.view_index);
          }
 
+         if (key->dynamic_patch_control_points) {
+            ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tcs_offchip_layout);
+         }
+
          ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.tcs_patch_id);
          ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.tcs_rel_ids);
 
@@ -682,6 +703,10 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
             ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.view_index);
          }
 
+         if (key->dynamic_patch_control_points) {
+            ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tcs_offchip_layout);
+         }
+
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tess_offchip_offset);
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tcs_factor_offset);
          if (args->explicit_scratch_args) {
@@ -700,6 +725,9 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
       if (needs_view_index)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.view_index);
 
+      if (key->dynamic_patch_control_points)
+         ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tes_num_patches);
+
       if (info->tes.as_es) {
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tess_offchip_offset);
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
@@ -744,6 +772,9 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
             ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.view_index);
          }
 
+         if (previous_stage == MESA_SHADER_TESS_EVAL && key->dynamic_patch_control_points)
+            ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tes_num_patches);
+
          if (info->force_vrs_per_vertex) {
             ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.force_vrs_rates);
          }
@@ -861,15 +892,24 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
    case MESA_SHADER_TESS_CTRL:
       if (args->ac.view_index.used)
          set_loc_shader(args, AC_UD_VIEW_INDEX, &user_sgpr_idx, 1);
+
+      if (args->tcs_offchip_layout.used)
+         set_loc_shader(args, AC_UD_TCS_OFFCHIP_LAYOUT, &user_sgpr_idx, 1);
       break;
    case MESA_SHADER_TESS_EVAL:
       if (args->ac.view_index.used)
          set_loc_shader(args, AC_UD_VIEW_INDEX, &user_sgpr_idx, 1);
+
+      if (args->tes_num_patches.used)
+         set_loc_shader(args, AC_UD_TES_NUM_PATCHES, &user_sgpr_idx, 1);
       break;
    case MESA_SHADER_GEOMETRY:
       if (args->ac.view_index.used)
          set_loc_shader(args, AC_UD_VIEW_INDEX, &user_sgpr_idx, 1);
 
+      if (args->tes_num_patches.used)
+         set_loc_shader(args, AC_UD_TES_NUM_PATCHES, &user_sgpr_idx, 1);
+
       if (args->ac.force_vrs_rates.used)
          set_loc_shader(args, AC_UD_FORCE_VRS_RATES, &user_sgpr_idx, 1);
 
diff --git a/src/amd/vulkan/radv_shader_args.h b/src/amd/vulkan/radv_shader_args.h
index 7d20a64d179f..32ece0b3ff2e 100644
--- a/src/amd/vulkan/radv_shader_args.h
+++ b/src/amd/vulkan/radv_shader_args.h
@@ -65,6 +65,15 @@ struct radv_shader_args {
    /* PS epilogs */
    struct ac_arg ps_epilog_inputs[MAX_RTS];
 
+   /* TCS */
+   /* # [0:5] = the number of patch control points
+    * # [6:13] = the number of tessellation patches
+    */
+   struct ac_arg tcs_offchip_layout;
+
+   /* TES */
+   struct ac_arg tes_num_patches;
+
    struct radv_userdata_locations user_sgprs_locs;
    unsigned num_user_sgprs;
 
-- 
GitLab


From 34b2d87c84a4823840febbd82ef6c4e21fb14a40 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 30 Aug 2022 16:39:22 +0200
Subject: [PATCH 08/13] radv: add ABI lowering support for dynamic patch
 control points

The number of patch control points (TCS) and the number of patches
(TCS/TES) is read from user SGPRs.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_nir_lower_abi.c | 40 ++++++++++++++++++++++++-----
 1 file changed, 34 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_nir_lower_abi.c b/src/amd/vulkan/radv_nir_lower_abi.c
index 320b15d48d9f..ae94fbff9fe1 100644
--- a/src/amd/vulkan/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/radv_nir_lower_abi.c
@@ -92,7 +92,16 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
       replacement = ac_nir_load_arg(b, &s->args->ac, s->args->ac.tess_offchip_offset);
       break;
    case nir_intrinsic_load_tcs_num_patches_amd:
-      replacement = nir_imm_int(b, s->info->num_tess_patches);
+      if (s->pl_key->dynamic_patch_control_points) {
+         if (stage == MESA_SHADER_TESS_CTRL) {
+            nir_ssa_def *arg = ac_nir_load_arg(b, &s->args->ac, s->args->tcs_offchip_layout);
+            replacement = nir_ubfe(b, arg, nir_imm_int(b, 6), nir_imm_int(b, 8));
+         } else {
+            replacement = ac_nir_load_arg(b, &s->args->ac, s->args->tes_num_patches);
+         }
+      } else {
+         replacement = nir_imm_int(b, s->info->num_tess_patches);
+      }
       break;
    case nir_intrinsic_load_ring_esgs_amd:
       if (s->use_llvm)
@@ -121,10 +130,16 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
       }
       break;
    case nir_intrinsic_load_patch_vertices_in:
-      if (stage == MESA_SHADER_TESS_CTRL)
-         replacement = nir_imm_int(b, s->pl_key->tcs.tess_input_vertices);
-      else if (stage == MESA_SHADER_TESS_EVAL)
+      if (stage == MESA_SHADER_TESS_CTRL) {
+         if (s->pl_key->dynamic_patch_control_points) {
+            nir_ssa_def *arg = ac_nir_load_arg(b, &s->args->ac, s->args->tcs_offchip_layout);
+            replacement = nir_ubfe(b, arg, nir_imm_int(b, 0), nir_imm_int(b, 6));
+         } else {
+            replacement = nir_imm_int(b, s->pl_key->tcs.tess_input_vertices);
+         }
+      } else if (stage == MESA_SHADER_TESS_EVAL) {
          replacement = nir_imm_int(b, b->shader->info.tess.tcs_vertices_out);
+      }
       else
          unreachable("invalid tessellation shader stage");
       break;
@@ -218,12 +233,25 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
       break;
    }
    case nir_intrinsic_load_hs_out_patch_data_offset_amd: {
-      unsigned num_patches = s->info->num_tess_patches;
       unsigned out_vertices_per_patch = b->shader->info.tess.tcs_vertices_out;
       unsigned num_tcs_outputs = stage == MESA_SHADER_TESS_CTRL ?
          s->info->tcs.num_linked_outputs : s->info->tes.num_linked_inputs;
       int per_vertex_output_patch_size = out_vertices_per_patch * num_tcs_outputs * 16u;
-      replacement = nir_imm_int(b, num_patches * per_vertex_output_patch_size);
+
+      if (s->pl_key->dynamic_patch_control_points) {
+         nir_ssa_def *num_patches;
+
+         if (stage == MESA_SHADER_TESS_CTRL) {
+            nir_ssa_def *arg = ac_nir_load_arg(b, &s->args->ac, s->args->tcs_offchip_layout);
+            num_patches = nir_ubfe(b, arg, nir_imm_int(b, 6), nir_imm_int(b, 8));
+         } else {
+            num_patches = ac_nir_load_arg(b, &s->args->ac, s->args->tes_num_patches);
+         }
+         replacement = nir_imul_imm(b, num_patches, per_vertex_output_patch_size);
+      } else {
+         unsigned num_patches = s->info->num_tess_patches;
+         replacement = nir_imm_int(b, num_patches * per_vertex_output_patch_size);
+      }
       break;
    }
    default:
-- 
GitLab


From b09663bbf02f49e46f1c13734f7be274a5d25637 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 29 Aug 2022 18:12:23 +0200
Subject: [PATCH 09/13] radv: pass the number of patch control points to
 si_get_ia_multi_vgt_param()

To prepare for dynamic patch control points.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 4 +++-
 src/amd/vulkan/radv_private.h    | 2 +-
 src/amd/vulkan/si_cmd_buffer.c   | 5 +++--
 3 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6842ed6d5996..fb7ad21e1adf 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3984,12 +3984,14 @@ si_emit_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dr
    struct radv_cmd_state *state = &cmd_buffer->state;
    unsigned topology = state->dynamic.primitive_topology;
    bool prim_restart_enable = state->dynamic.primitive_restart_enable;
+   unsigned patch_control_points = state->graphics_pipeline->tess_patch_control_points;
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    unsigned ia_multi_vgt_param;
 
    ia_multi_vgt_param =
       si_get_ia_multi_vgt_param(cmd_buffer, instanced_draw, indirect_draw, count_from_stream_output,
-                                draw_vertex_count, topology, prim_restart_enable);
+                                draw_vertex_count, topology, prim_restart_enable,
+                                patch_control_points);
 
    if (state->last_ia_multi_vgt_param != ia_multi_vgt_param) {
       if (info->gfx_level == GFX9) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 0ec72ad1aa0f..1fc649e26b85 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1678,7 +1678,7 @@ void si_write_guardband(struct radeon_cmdbuf *cs, int count, const VkViewport *v
 uint32_t si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_draw,
                                    bool indirect_draw, bool count_from_stream_output,
                                    uint32_t draw_vertex_count, unsigned topology,
-                                   bool prim_restart_enable);
+                                   bool prim_restart_enable, unsigned patch_control_points);
 void si_cs_emit_write_event_eop(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level, bool is_mec,
                                 unsigned event, unsigned event_flags, unsigned dst_sel,
                                 unsigned data_sel, uint64_t va, uint32_t new_fence,
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index fc2140737f0b..795a161096a4 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -815,7 +815,8 @@ static const struct radv_prim_vertex_count prim_size_table[] = {
 uint32_t
 si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_draw,
                           bool indirect_draw, bool count_from_stream_output,
-                          uint32_t draw_vertex_count, unsigned topology, bool prim_restart_enable)
+                          uint32_t draw_vertex_count, unsigned topology, bool prim_restart_enable,
+                          unsigned patch_control_points)
 {
    enum amd_gfx_level gfx_level = cmd_buffer->device->physical_device->rad_info.gfx_level;
    enum radeon_family family = cmd_buffer->device->physical_device->rad_info.family;
@@ -832,7 +833,7 @@ si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dra
 
    if (radv_pipeline_has_stage(cmd_buffer->state.graphics_pipeline, MESA_SHADER_TESS_CTRL)) {
       if (topology == V_008958_DI_PT_PATCH) {
-         prim_vertex_count.min = cmd_buffer->state.graphics_pipeline->tess_patch_control_points;
+         prim_vertex_count.min = patch_control_points;
          prim_vertex_count.incr = 1;
       }
    }
-- 
GitLab


From de5e3ae9112eda317270f8e32fb4ade007237d1e Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 29 Aug 2022 18:27:52 +0200
Subject: [PATCH 10/13] radv: move emitting PRIMGROUP_SIZE for <= GFX9 from the
 cmdbuf

The number of tessellation patches that is computed from the number
of patch control points might change dynamically too.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c |  8 +++++++-
 src/amd/vulkan/radv_pipeline.c   | 15 ---------------
 src/amd/vulkan/radv_private.h    |  4 ++--
 src/amd/vulkan/si_cmd_buffer.c   | 22 ++++++++++++++++++++--
 4 files changed, 29 insertions(+), 20 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index fb7ad21e1adf..7e7aa7cf93f7 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3986,12 +3986,18 @@ si_emit_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dr
    bool prim_restart_enable = state->dynamic.primitive_restart_enable;
    unsigned patch_control_points = state->graphics_pipeline->tess_patch_control_points;
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
+   unsigned num_tess_patches = 0;
    unsigned ia_multi_vgt_param;
 
+   if (radv_pipeline_has_stage(state->graphics_pipeline, MESA_SHADER_TESS_CTRL)) {
+      struct radv_shader *tcs = state->graphics_pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+      num_tess_patches = tcs->info.num_tess_patches;
+   }
+
    ia_multi_vgt_param =
       si_get_ia_multi_vgt_param(cmd_buffer, instanced_draw, indirect_draw, count_from_stream_output,
                                 draw_vertex_count, topology, prim_restart_enable,
-                                patch_control_points);
+                                patch_control_points, num_tess_patches);
 
    if (state->last_ia_multi_vgt_param != ia_multi_vgt_param) {
       if (info->gfx_level == GFX9) {
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 8827d8c7fb14..7eafbd6d294a 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1390,20 +1390,6 @@ radv_compute_ia_multi_vgt_param_helpers(struct radv_graphics_pipeline *pipeline)
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
    struct radv_ia_multi_vgt_param_helpers ia_multi_vgt_param = {0};
 
-   if (radv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_CTRL))
-      ia_multi_vgt_param.primgroup_size =
-         pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.num_tess_patches;
-   else if (radv_pipeline_has_stage(pipeline, MESA_SHADER_GEOMETRY))
-      ia_multi_vgt_param.primgroup_size = 64;
-   else
-      ia_multi_vgt_param.primgroup_size = 128; /* recommended without a GS */
-
-   /* GS requirement. */
-   ia_multi_vgt_param.partial_es_wave = false;
-   if (radv_pipeline_has_stage(pipeline, MESA_SHADER_GEOMETRY) && pdevice->rad_info.gfx_level <= GFX8)
-      if (SI_GS_PER_ES / ia_multi_vgt_param.primgroup_size >= pdevice->gs_table_depth - 3)
-         ia_multi_vgt_param.partial_es_wave = true;
-
    ia_multi_vgt_param.ia_switch_on_eoi = false;
    if (pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.prim_id_input)
       ia_multi_vgt_param.ia_switch_on_eoi = true;
@@ -1456,7 +1442,6 @@ radv_compute_ia_multi_vgt_param_helpers(struct radv_graphics_pipeline *pipeline)
    }
 
    ia_multi_vgt_param.base =
-      S_028AA8_PRIMGROUP_SIZE(ia_multi_vgt_param.primgroup_size - 1) |
       /* The following field was moved to VGT_SHADER_STAGES_EN in GFX9. */
       S_028AA8_MAX_PRIMGRP_IN_WAVE(pdevice->rad_info.gfx_level == GFX8 ? 2 : 0) |
       S_030960_EN_INST_OPT_BASIC(pdevice->rad_info.gfx_level >= GFX9) |
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 1fc649e26b85..155203ba2135 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1678,7 +1678,8 @@ void si_write_guardband(struct radeon_cmdbuf *cs, int count, const VkViewport *v
 uint32_t si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_draw,
                                    bool indirect_draw, bool count_from_stream_output,
                                    uint32_t draw_vertex_count, unsigned topology,
-                                   bool prim_restart_enable, unsigned patch_control_points);
+                                   bool prim_restart_enable, unsigned patch_control_points,
+                                   unsigned num_tess_patches);
 void si_cs_emit_write_event_eop(struct radeon_cmdbuf *cs, enum amd_gfx_level gfx_level, bool is_mec,
                                 unsigned event, unsigned event_flags, unsigned dst_sel,
                                 unsigned data_sel, uint64_t va, uint32_t new_fence,
@@ -1904,7 +1905,6 @@ struct radv_prim_vertex_count {
 struct radv_ia_multi_vgt_param_helpers {
    uint32_t base;
    bool partial_es_wave;
-   uint8_t primgroup_size;
    bool ia_switch_on_eoi;
    bool partial_vs_wave;
 };
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 795a161096a4..70aa5a009e3a 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -816,7 +816,7 @@ uint32_t
 si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_draw,
                           bool indirect_draw, bool count_from_stream_output,
                           uint32_t draw_vertex_count, unsigned topology, bool prim_restart_enable,
-                          unsigned patch_control_points)
+                          unsigned patch_control_points, unsigned num_tess_patches)
 {
    enum amd_gfx_level gfx_level = cmd_buffer->device->physical_device->rad_info.gfx_level;
    enum radeon_family family = cmd_buffer->device->physical_device->rad_info.family;
@@ -830,6 +830,23 @@ si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dra
    bool partial_es_wave = cmd_buffer->state.graphics_pipeline->ia_multi_vgt_param.partial_es_wave;
    bool multi_instances_smaller_than_primgroup;
    struct radv_prim_vertex_count prim_vertex_count = prim_size_table[topology];
+   unsigned primgroup_size;
+
+   if (radv_pipeline_has_stage(cmd_buffer->state.graphics_pipeline, MESA_SHADER_TESS_CTRL)) {
+      primgroup_size = num_tess_patches;
+   } else if (radv_pipeline_has_stage(cmd_buffer->state.graphics_pipeline, MESA_SHADER_GEOMETRY)) {
+      primgroup_size = 64;
+   } else {
+      primgroup_size = 128; /* recommended without a GS */
+   }
+
+   /* GS requirement. */
+   if (radv_pipeline_has_stage(cmd_buffer->state.graphics_pipeline, MESA_SHADER_GEOMETRY) &&
+       gfx_level <= GFX8) {
+      unsigned gs_table_depth = cmd_buffer->device->physical_device->gs_table_depth;
+      if (SI_GS_PER_ES / primgroup_size >= gs_table_depth - 3)
+         partial_es_wave = true;
+   }
 
    if (radv_pipeline_has_stage(cmd_buffer->state.graphics_pipeline, MESA_SHADER_TESS_CTRL)) {
       if (topology == V_008958_DI_PT_PATCH) {
@@ -841,7 +858,7 @@ si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dra
    multi_instances_smaller_than_primgroup = indirect_draw;
    if (!multi_instances_smaller_than_primgroup && instanced_draw) {
       uint32_t num_prims = radv_prims_for_vertices(&prim_vertex_count, draw_vertex_count);
-      if (num_prims < cmd_buffer->state.graphics_pipeline->ia_multi_vgt_param.primgroup_size)
+      if (num_prims < primgroup_size)
          multi_instances_smaller_than_primgroup = true;
    }
 
@@ -930,6 +947,7 @@ si_get_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dra
    }
 
    return cmd_buffer->state.graphics_pipeline->ia_multi_vgt_param.base |
+          S_028AA8_PRIMGROUP_SIZE(primgroup_size - 1) |
           S_028AA8_SWITCH_ON_EOP(ia_switch_on_eop) | S_028AA8_SWITCH_ON_EOI(ia_switch_on_eoi) |
           S_028AA8_PARTIAL_VS_WAVE_ON(partial_vs_wave) |
           S_028AA8_PARTIAL_ES_WAVE_ON(partial_es_wave) |
-- 
GitLab


From 71b82e11a074f540988ff84bf5da27e7c09b01e2 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 29 Aug 2022 18:35:52 +0200
Subject: [PATCH 11/13] radv: move emitting GE_CNTL for non-NGG pipelines from
 the cmdbuf

GE_CNTL is the equivalent of IA_MULTI_VGT_PARAM on GFX9 and older.
Calling this function for every draw shouldn't really hurt in practice
because only non-NGG pipelines need this.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 46 +++++++++++++++++++++++++++++++-
 src/amd/vulkan/radv_pipeline.c   | 37 +------------------------
 src/amd/vulkan/radv_private.h    |  3 +++
 3 files changed, 49 insertions(+), 37 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 7e7aa7cf93f7..56c2ebf1811b 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4012,6 +4012,44 @@ si_emit_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dr
    }
 }
 
+static void
+gfx10_emit_ge_cntl(struct radv_cmd_buffer *cmd_buffer)
+{
+   const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   struct radv_cmd_state *state = &cmd_buffer->state;
+   bool break_wave_at_eoi = false;
+   unsigned primgroup_size;
+   unsigned ge_cntl;
+
+   if (radv_pipeline_has_ngg(pipeline))
+      return;
+
+   if (radv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_CTRL)) {
+      primgroup_size = pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.num_tess_patches;
+
+      if (pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.uses_prim_id ||
+          radv_get_shader(&pipeline->base, MESA_SHADER_TESS_EVAL)->info.uses_prim_id) {
+         break_wave_at_eoi = true;
+      }
+   } else if (radv_pipeline_has_stage(pipeline, MESA_SHADER_GEOMETRY)) {
+      const struct gfx9_gs_info *gs_state =
+         &pipeline->base.shaders[MESA_SHADER_GEOMETRY]->info.gs_ring_info;
+      primgroup_size = G_028A44_GS_PRIMS_PER_SUBGRP(gs_state->vgt_gs_onchip_cntl);
+   } else {
+      primgroup_size = 128; /* recommended without a GS and tess */
+   }
+
+   ge_cntl = S_03096C_PRIM_GRP_SIZE_GFX10(primgroup_size) |
+             S_03096C_VERT_GRP_SIZE(256) | /* disable vertex grouping */
+             S_03096C_PACKET_TO_ONE_PA(0) /* line stipple */ |
+             S_03096C_BREAK_WAVE_AT_EOI(break_wave_at_eoi);
+
+   if (state->last_ge_cntl != ge_cntl) {
+      radeon_set_uconfig_reg(cmd_buffer->cs, R_03096C_GE_CNTL, ge_cntl);
+      state->last_ge_cntl = ge_cntl;
+   }
+}
+
 static void
 radv_emit_draw_registers(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info *draw_info)
 {
@@ -4022,7 +4060,9 @@ radv_emit_draw_registers(struct radv_cmd_buffer *cmd_buffer, const struct radv_d
    bool disable_instance_packing = false;
 
    /* Draw state. */
-   if (info->gfx_level < GFX10) {
+   if (info->gfx_level >= GFX10) {
+      gfx10_emit_ge_cntl(cmd_buffer);
+   } else {
       si_emit_ia_multi_vgt_param(cmd_buffer, draw_info->instance_count > 1, draw_info->indirect,
                                  !!draw_info->strmout_buffer,
                                  draw_info->indirect ? 0 : draw_info->count);
@@ -6082,6 +6122,10 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
          primary->state.last_ia_multi_vgt_param = secondary->state.last_ia_multi_vgt_param;
       }
 
+      if (secondary->state.last_ge_cntl) {
+         primary->state.last_ge_cntl = secondary->state.last_ge_cntl;
+      }
+
       primary->state.last_first_instance = secondary->state.last_first_instance;
       primary->state.last_num_instances = secondary->state.last_num_instances;
       primary->state.last_drawid = secondary->state.last_drawid;
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 7eafbd6d294a..e5f9dac8cef5 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -135,7 +135,7 @@ radv_pipeline_has_color_attachments(const struct vk_render_pass_state *rp)
    return false;
 }
 
-static bool
+bool
 radv_pipeline_has_ngg(const struct radv_graphics_pipeline *pipeline)
 {
    struct radv_shader *shader = pipeline->base.shaders[pipeline->last_vgt_api_stage];
@@ -5563,38 +5563,6 @@ radv_pipeline_emit_cliprect_rule(struct radeon_cmdbuf *ctx_cs,
    radeon_set_context_reg(ctx_cs, R_02820C_PA_SC_CLIPRECT_RULE, cliprect_rule);
 }
 
-static void
-gfx10_pipeline_emit_ge_cntl(struct radeon_cmdbuf *ctx_cs,
-                            const struct radv_graphics_pipeline *pipeline)
-{
-   bool break_wave_at_eoi = false;
-   unsigned primgroup_size;
-   unsigned vertgroup_size = 256; /* 256 = disable vertex grouping */
-
-   if (radv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_CTRL)) {
-      primgroup_size = pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.num_tess_patches;
-   } else if (radv_pipeline_has_stage(pipeline, MESA_SHADER_GEOMETRY)) {
-      const struct gfx9_gs_info *gs_state =
-         &pipeline->base.shaders[MESA_SHADER_GEOMETRY]->info.gs_ring_info;
-      unsigned vgt_gs_onchip_cntl = gs_state->vgt_gs_onchip_cntl;
-      primgroup_size = G_028A44_GS_PRIMS_PER_SUBGRP(vgt_gs_onchip_cntl);
-   } else {
-      primgroup_size = 128; /* recommended without a GS and tess */
-   }
-
-   if (radv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_CTRL)) {
-      if (pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.uses_prim_id ||
-          radv_get_shader(&pipeline->base, MESA_SHADER_TESS_EVAL)->info.uses_prim_id)
-         break_wave_at_eoi = true;
-   }
-
-   radeon_set_uconfig_reg(ctx_cs, R_03096C_GE_CNTL,
-                          S_03096C_PRIM_GRP_SIZE_GFX10(primgroup_size) |
-                             S_03096C_VERT_GRP_SIZE(vertgroup_size) |
-                             S_03096C_PACKET_TO_ONE_PA(0) /* line stipple */ |
-                             S_03096C_BREAK_WAVE_AT_EOI(break_wave_at_eoi));
-}
-
 static void
 radv_pipeline_emit_vgt_gs_out(struct radeon_cmdbuf *ctx_cs,
                               const struct radv_graphics_pipeline *pipeline,
@@ -5731,9 +5699,6 @@ radv_pipeline_emit_pm4(struct radv_graphics_pipeline *pipeline,
    radv_pipeline_emit_cliprect_rule(ctx_cs, state);
    radv_pipeline_emit_vgt_gs_out(ctx_cs, pipeline, vgt_gs_out_prim_type);
 
-   if (pdevice->rad_info.gfx_level >= GFX10 && !radv_pipeline_has_ngg(pipeline))
-      gfx10_pipeline_emit_ge_cntl(ctx_cs, pipeline);
-
    if (pdevice->rad_info.gfx_level >= GFX10_3) {
       gfx103_pipeline_emit_vgt_draw_payload_cntl(ctx_cs, pipeline, state);
       gfx103_pipeline_emit_vrs_state(ctx_cs, pipeline, state);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 155203ba2135..eb5b07295469 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1483,6 +1483,7 @@ struct radv_cmd_state {
    bool prims_gen_query_enabled;
    uint32_t trace_id;
    uint32_t last_ia_multi_vgt_param;
+   uint32_t last_ge_cntl;
 
    uint32_t last_num_instances;
    uint32_t last_first_instance;
@@ -2126,6 +2127,8 @@ radv_pipeline_has_stage(const struct radv_graphics_pipeline *pipeline, gl_shader
    return pipeline->base.shaders[stage];
 }
 
+bool radv_pipeline_has_ngg(const struct radv_graphics_pipeline *pipeline);
+
 bool radv_pipeline_has_ngg_passthrough(const struct radv_graphics_pipeline *pipeline);
 
 bool radv_pipeline_has_gs_copy_shader(const struct radv_pipeline *pipeline);
-- 
GitLab


From b66a761a9b6c02c0eaff32661f3281acc0172132 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 30 Aug 2022 17:11:57 +0200
Subject: [PATCH 12/13] radv: implement dynamic patch control points

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 127 ++++++++++++++++++++++++++++---
 src/amd/vulkan/radv_pipeline.c   |  59 +++++---------
 src/amd/vulkan/radv_private.h    |   7 +-
 3 files changed, 139 insertions(+), 54 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 56c2ebf1811b..d7e5ee6557be 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -120,6 +120,7 @@ const struct radv_dynamic_state default_dynamic_state = {
    .rasterizer_discard_enable = 0u,
    .logic_op = 0u,
    .color_write_enable = 0u,
+   .patch_control_points = 0,
 };
 
 static void
@@ -251,6 +252,8 @@ radv_bind_dynamic_state(struct radv_cmd_buffer *cmd_buffer, const struct radv_dy
 
    RADV_CMP_COPY(color_write_enable, RADV_DYNAMIC_COLOR_WRITE_ENABLE);
 
+   RADV_CMP_COPY(patch_control_points, RADV_DYNAMIC_PATCH_CONTROL_POINTS);
+
 #undef RADV_CMP_COPY
 
    cmd_buffer->state.dirty |= dest_mask;
@@ -1414,7 +1417,8 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
                                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
                                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE |
                                  RADV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_STENCIL_OP;
+                                 RADV_CMD_DIRTY_DYNAMIC_STENCIL_OP |
+                                 RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS;
 
    if (!cmd_buffer->state.emitted_graphics_pipeline ||
        cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
@@ -1826,6 +1830,61 @@ radv_emit_color_write_enable(struct radv_cmd_buffer *cmd_buffer)
                           pipeline->cb_target_mask & d->color_write_enable);
 }
 
+static void
+radv_emit_patch_control_points(struct radv_cmd_buffer *cmd_buffer)
+{
+   const struct radv_physical_device *pdevice = cmd_buffer->device->physical_device;
+   struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+   struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+   unsigned ls_hs_config, base_reg;
+   struct radv_userdata_info *loc;
+
+   ls_hs_config = S_028B58_NUM_PATCHES(cmd_buffer->state.tess_num_patches) |
+                  S_028B58_HS_NUM_INPUT_CP(d->patch_control_points) |
+                  S_028B58_HS_NUM_OUTPUT_CP(tcs->info.tcs.tcs_vertices_out);
+
+   if (pdevice->rad_info.gfx_level >= GFX7) {
+      radeon_set_context_reg_idx(cmd_buffer->cs, R_028B58_VGT_LS_HS_CONFIG, 2, ls_hs_config);
+   } else {
+      radeon_set_context_reg(cmd_buffer->cs, R_028B58_VGT_LS_HS_CONFIG, ls_hs_config);
+   }
+
+   if (pdevice->rad_info.gfx_level >= GFX9) {
+      unsigned hs_rsrc2 = tcs->config.rsrc2;
+
+      if (pdevice->rad_info.gfx_level >= GFX10) {
+         hs_rsrc2 |= S_00B42C_LDS_SIZE_GFX10(cmd_buffer->state.tess_lds_size);
+      } else {
+         hs_rsrc2 |= S_00B42C_LDS_SIZE_GFX9(cmd_buffer->state.tess_lds_size);
+      }
+
+      radeon_set_sh_reg(cmd_buffer->cs, R_00B42C_SPI_SHADER_PGM_RSRC2_HS, hs_rsrc2);
+   } else {
+      struct radv_shader *vs = pipeline->base.shaders[MESA_SHADER_VERTEX];
+      unsigned ls_rsrc2 = vs->config.rsrc2 | S_00B52C_LDS_SIZE(cmd_buffer->state.tess_lds_size);
+
+      radeon_set_sh_reg(cmd_buffer->cs, R_00B52C_SPI_SHADER_PGM_RSRC2_LS, ls_rsrc2);
+   }
+
+   /* Emit user SGPRs for dynamic patch control points. */
+   loc = radv_lookup_user_sgpr(&pipeline->base, MESA_SHADER_TESS_CTRL, AC_UD_TCS_OFFCHIP_LAYOUT);
+   if (loc->sgpr_idx == -1)
+      return;
+   assert(loc->num_sgprs == 1);
+
+   base_reg = pipeline->base.user_data_0[MESA_SHADER_TESS_CTRL];
+   radeon_set_sh_reg(cmd_buffer->cs, base_reg + loc->sgpr_idx * 4,
+                     (cmd_buffer->state.tess_num_patches << 6) | d->patch_control_points);
+
+   loc = radv_lookup_user_sgpr(&pipeline->base, MESA_SHADER_TESS_EVAL, AC_UD_TES_NUM_PATCHES);
+   assert(loc->sgpr_idx != -1 && loc->num_sgprs == 1);
+
+   base_reg = pipeline->base.user_data_0[MESA_SHADER_TESS_EVAL];
+   radeon_set_sh_reg(cmd_buffer->cs, base_reg + loc->sgpr_idx * 4,
+                     cmd_buffer->state.tess_num_patches);
+}
+
 static void
 radv_emit_fb_color_state(struct radv_cmd_buffer *cmd_buffer, int index,
                          struct radv_color_buffer_info *cb, struct radv_image_view *iview,
@@ -3275,6 +3334,9 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (states & RADV_CMD_DIRTY_DYNAMIC_VERTEX_INPUT)
       radv_emit_vertex_input(cmd_buffer, pipeline_is_dirty);
 
+   if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS)
+      radv_emit_patch_control_points(cmd_buffer);
+
    cmd_buffer->state.dirty &= ~states;
 }
 
@@ -3984,20 +4046,14 @@ si_emit_ia_multi_vgt_param(struct radv_cmd_buffer *cmd_buffer, bool instanced_dr
    struct radv_cmd_state *state = &cmd_buffer->state;
    unsigned topology = state->dynamic.primitive_topology;
    bool prim_restart_enable = state->dynamic.primitive_restart_enable;
-   unsigned patch_control_points = state->graphics_pipeline->tess_patch_control_points;
+   unsigned patch_control_points = state->dynamic.patch_control_points;
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
-   unsigned num_tess_patches = 0;
    unsigned ia_multi_vgt_param;
 
-   if (radv_pipeline_has_stage(state->graphics_pipeline, MESA_SHADER_TESS_CTRL)) {
-      struct radv_shader *tcs = state->graphics_pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
-      num_tess_patches = tcs->info.num_tess_patches;
-   }
-
    ia_multi_vgt_param =
       si_get_ia_multi_vgt_param(cmd_buffer, instanced_draw, indirect_draw, count_from_stream_output,
                                 draw_vertex_count, topology, prim_restart_enable,
-                                patch_control_points, num_tess_patches);
+                                patch_control_points, state->tess_num_patches);
 
    if (state->last_ia_multi_vgt_param != ia_multi_vgt_param) {
       if (info->gfx_level == GFX9) {
@@ -4025,7 +4081,7 @@ gfx10_emit_ge_cntl(struct radv_cmd_buffer *cmd_buffer)
       return;
 
    if (radv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_CTRL)) {
-      primgroup_size = pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.num_tess_patches;
+      primgroup_size = state->tess_num_patches;
 
       if (pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.uses_prim_id ||
           radv_get_shader(&pipeline->base, MESA_SHADER_TESS_EVAL)->info.uses_prim_id) {
@@ -5485,6 +5541,19 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
          cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
       }
 
+      if (radv_pipeline_has_stage(graphics_pipeline, MESA_SHADER_TESS_CTRL) &&
+          !(graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS)) {
+         /* Bind the tessellation state from the pipeline when it's not dynamic and make sure to
+          * emit it if the number of patches or the LDS size changed.
+          */
+         struct radv_shader *tcs = graphics_pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+
+         cmd_buffer->state.tess_num_patches = tcs->info.num_tess_patches;
+         cmd_buffer->state.tess_lds_size = tcs->info.tcs.num_lds_blocks;
+
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS;
+      }
+
       radv_bind_dynamic_state(cmd_buffer, &graphics_pipeline->dynamic_state);
 
       if (graphics_pipeline->esgs_ring_size > cmd_buffer->esgs_ring_size_needed)
@@ -5885,7 +5954,12 @@ radv_CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 raste
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints)
 {
-   /* not implemented */
+   RADV_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+   struct radv_cmd_state *state = &cmd_buffer->state;
+
+   state->dynamic.patch_control_points = patchControlPoints;
+
+   state->dirty |= RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS;
 }
 
 VKAPI_ATTR void VKAPI_CALL
@@ -7500,6 +7574,37 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       }
    }
 
+   /* Pre-compute some tessellation info that depend on the number of patch control points when the
+    * bound pipeline declared this state as dynamic.
+    */
+   if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
+      uint64_t dynamic_states =
+         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+
+      if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
+         const struct radv_physical_device *pdevice = device->physical_device;
+         const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+         const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+         const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+
+         /* Compute the number of patches and emit the context register. */
+         cmd_buffer->state.tess_num_patches =
+            get_tcs_num_patches(d->patch_control_points, tcs->info.tcs.tcs_vertices_out,
+                                tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
+                                tcs->info.tcs.num_linked_patch_outputs,
+                                pdevice->hs.tess_offchip_block_dw_size, pdevice->rad_info.gfx_level,
+                                pdevice->rad_info.family);
+
+         /* Compute the LDS size and emit the shader register. */
+         cmd_buffer->state.tess_lds_size =
+            calculate_tess_lds_size(pdevice->rad_info.gfx_level, d->patch_control_points,
+                                    tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
+                                    cmd_buffer->state.tess_num_patches,
+                                    tcs->info.tcs.num_linked_outputs,
+                                    tcs->info.tcs.num_linked_patch_outputs);
+      }
+   }
+
    radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
 
    radv_emit_draw_registers(cmd_buffer, info);
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index e5f9dac8cef5..742d36805a8d 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1345,9 +1345,14 @@ radv_pipeline_needed_dynamic_state(const struct radv_graphics_pipeline *pipeline
 
    /* Disable dynamic states that are useless when rasterization is disabled. */
    if (!raster_enabled) {
-      return RADV_DYNAMIC_PRIMITIVE_TOPOLOGY | RADV_DYNAMIC_VERTEX_INPUT_BINDING_STRIDE |
-             RADV_DYNAMIC_PRIMITIVE_RESTART_ENABLE | RADV_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
-             RADV_DYNAMIC_VERTEX_INPUT;
+      states = RADV_DYNAMIC_PRIMITIVE_TOPOLOGY | RADV_DYNAMIC_VERTEX_INPUT_BINDING_STRIDE |
+               RADV_DYNAMIC_PRIMITIVE_RESTART_ENABLE | RADV_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
+               RADV_DYNAMIC_VERTEX_INPUT;
+
+      if (pipeline->active_stages & VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT)
+         states |= RADV_DYNAMIC_PATCH_CONTROL_POINTS;
+
+      return states;
    }
 
    if (!state->rs->depth_bias.enable &&
@@ -1381,6 +1386,9 @@ radv_pipeline_needed_dynamic_state(const struct radv_graphics_pipeline *pipeline
    if (!has_color_att)
       states &= ~RADV_DYNAMIC_COLOR_WRITE_ENABLE;
 
+   if (!(pipeline->active_stages & VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT))
+      states &= ~RADV_DYNAMIC_PATCH_CONTROL_POINTS;
+
    return states;
 }
 
@@ -1775,6 +1783,10 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
       }
    }
 
+   if (states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
+      dynamic->patch_control_points = state->ts->patch_control_points;
+   }
+
    pipeline->dynamic_state.mask = states;
 }
 
@@ -4746,20 +4758,11 @@ static void
 radv_pipeline_emit_hw_ls(struct radeon_cmdbuf *cs, const struct radv_graphics_pipeline *pipeline,
                          const struct radv_shader *shader)
 {
-   const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-   unsigned num_lds_blocks = pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.tcs.num_lds_blocks;
    uint64_t va = radv_shader_get_va(shader);
-   uint32_t rsrc2 = shader->config.rsrc2;
 
    radeon_set_sh_reg(cs, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
 
-   rsrc2 |= S_00B52C_LDS_SIZE(num_lds_blocks);
-   if (pdevice->rad_info.gfx_level == GFX7 && pdevice->rad_info.family != CHIP_HAWAII)
-      radeon_set_sh_reg(cs, R_00B52C_SPI_SHADER_PGM_RSRC2_LS, rsrc2);
-
-   radeon_set_sh_reg_seq(cs, R_00B528_SPI_SHADER_PGM_RSRC1_LS, 2);
-   radeon_emit(cs, shader->config.rsrc1);
-   radeon_emit(cs, rsrc2);
+   radeon_set_sh_reg(cs, R_00B528_SPI_SHADER_PGM_RSRC1_LS, shader->config.rsrc1);
 }
 
 static void
@@ -4949,21 +4952,13 @@ radv_pipeline_emit_hw_hs(struct radeon_cmdbuf *cs, const struct radv_graphics_pi
    uint64_t va = radv_shader_get_va(shader);
 
    if (pdevice->rad_info.gfx_level >= GFX9) {
-      uint32_t rsrc2 = shader->config.rsrc2;
-
       if (pdevice->rad_info.gfx_level >= GFX10) {
-         rsrc2 |= S_00B42C_LDS_SIZE_GFX10(shader->info.tcs.num_lds_blocks);
-
          radeon_set_sh_reg(cs, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
       } else {
-         rsrc2 |= S_00B42C_LDS_SIZE_GFX9(shader->info.tcs.num_lds_blocks);
-
          radeon_set_sh_reg(cs, R_00B410_SPI_SHADER_PGM_LO_LS, va >> 8);
       }
 
-      radeon_set_sh_reg_seq(cs, R_00B428_SPI_SHADER_PGM_RSRC1_HS, 2);
-      radeon_emit(cs, shader->config.rsrc1);
-      radeon_emit(cs, rsrc2);
+      radeon_set_sh_reg(cs, R_00B428_SPI_SHADER_PGM_RSRC1_HS, shader->config.rsrc1);
    } else {
       radeon_set_sh_reg_seq(cs, R_00B420_SPI_SHADER_PGM_LO_HS, 4);
       radeon_emit(cs, va >> 8);
@@ -5031,22 +5026,6 @@ radv_pipeline_emit_tess_state(struct radeon_cmdbuf *ctx_cs,
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
    struct radv_shader *tes = radv_get_shader(&pipeline->base, MESA_SHADER_TESS_EVAL);
    unsigned type = 0, partitioning = 0, topology = 0, distribution_mode = 0;
-   unsigned num_tcs_input_cp, num_tcs_output_cp, num_patches;
-   unsigned ls_hs_config;
-
-   num_tcs_input_cp = state->ts->patch_control_points;
-   num_tcs_output_cp =
-      pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.tcs.tcs_vertices_out; // TCS VERTICES OUT
-   num_patches = pipeline->base.shaders[MESA_SHADER_TESS_CTRL]->info.num_tess_patches;
-
-   ls_hs_config = S_028B58_NUM_PATCHES(num_patches) | S_028B58_HS_NUM_INPUT_CP(num_tcs_input_cp) |
-                  S_028B58_HS_NUM_OUTPUT_CP(num_tcs_output_cp);
-
-   if (pdevice->rad_info.gfx_level >= GFX7) {
-      radeon_set_context_reg_idx(ctx_cs, R_028B58_VGT_LS_HS_CONFIG, 2, ls_hs_config);
-   } else {
-      radeon_set_context_reg(ctx_cs, R_028B58_VGT_LS_HS_CONFIG, ls_hs_config);
-   }
 
    switch (tes->info.tes._primitive_mode) {
    case TESS_PRIMITIVE_TRIANGLES:
@@ -6017,10 +5996,6 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       radv_pipeline_init_gs_ring_state(pipeline, &gs->info.gs_ring_info);
    }
 
-   if (radv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_CTRL)) {
-      pipeline->tess_patch_control_points = state.ts->patch_control_points;
-   }
-
    if (!radv_pipeline_has_stage(pipeline, MESA_SHADER_MESH))
       radv_pipeline_init_vertex_input_state(pipeline, &state);
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index eb5b07295469..370e317905eb 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1331,6 +1331,8 @@ struct radv_dynamic_state {
    unsigned logic_op;
 
    uint32_t color_write_enable;
+
+   uint32_t patch_control_points;
 };
 
 extern const struct radv_dynamic_state default_dynamic_state;
@@ -1552,6 +1554,10 @@ struct radv_cmd_state {
 
    /* Whether this commandbuffer uses performance counters. */
    bool uses_perf_counters;
+
+   /* Tessellation info when patch control points is dynamic. */
+   unsigned tess_num_patches;
+   unsigned tess_lds_size;
 };
 
 struct radv_cmd_pool {
@@ -2003,7 +2009,6 @@ struct radv_graphics_pipeline {
    struct radv_ia_multi_vgt_param_helpers ia_multi_vgt_param;
    uint8_t vtx_emit_num;
    uint64_t needed_dynamic_state;
-   unsigned tess_patch_control_points;
    unsigned pa_su_sc_mode_cntl;
    unsigned pa_cl_clip_cntl;
    unsigned cb_color_control;
-- 
GitLab


From cdb5bebb961ab33762afddbee053e72164dc8613 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 29 Aug 2022 18:38:01 +0200
Subject: [PATCH 13/13] radv: advertise extendedDynamicState2PatchControlPoints

For less stuttering with Zink, also required by Zink for full GPL.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/6584
Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 7994a34bb364..daeef0a7a637 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1616,7 +1616,7 @@ radv_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
             (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *)ext;
          features->extendedDynamicState2 = true;
          features->extendedDynamicState2LogicOp = true;
-         features->extendedDynamicState2PatchControlPoints = false;
+         features->extendedDynamicState2PatchControlPoints = true;
          break;
       }
       case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {
-- 
GitLab

