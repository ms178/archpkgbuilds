--- a/src/compiler/nir/nir_opt_algebraic.py	2025-10-17 10:58:54.371161768 +0200
+++ b/src/compiler/nir/nir_opt_algebraic.py	2025-10-17 11:13:20.535349933 +0200
@@ -2134,6 +2134,8 @@ optimizations.extend([
    (('ior', ('ishl', ('u2u32', 'a@8'), 24), ('ior', ('ishl', ('u2u32', 'b@8'), 16), ('ior', ('ishl', ('u2u32', 'c@8'), 8), ('u2u32', 'd@8')))),
     ('pack_32_4x8', ('vec4', d, c, b, a)), 'options->has_pack_32_4x8'),
 
+   (('ior', ('ishl', ('u2u32', 'a@16'), 16), ('u2u32', 'b@16')), ('pack_32_2x16_split', b, a), '!options->lower_pack_32_2x16_split && !options->lower_pack_split'),
+
    # Mixed 16-bit/8-bit loads vectorized to 8-bit vector load and then lowered to 32-bit
    (('ior', ('u2u16', ('unpack_32_4x8', a)), ('ishl', ('u2u16', ('unpack_32_4x8.y', a)), 8)),
     ('unpack_32_2x16_split_x', a), '!options->lower_unpack_32_2x16_split'),
@@ -2249,6 +2251,7 @@ optimizations.extend([
    (('u2u32', ('ushr', ('ior', ('ishl', a, 32), ('u2u64', 'b@32')), 32)), ('u2u32', a)),
    (('u2u16', ('ushr', ('ior', ('ishl', a, 16), ('u2u32', 'b@8')), 16)), ('u2u16', a)),
    (('u2u16', ('ushr', ('ior', ('ishl', a, 16), ('u2u32', 'b@16')), 16)), ('u2u16', a)),
+
 ])
 
 # After the ('extract_u8', a, 0) pattern, above, triggers, there will be
@@ -2700,6 +2703,128 @@ optimizations.extend([
                                            127.0))),
      'options->lower_unpack_snorm_4x8'),
 
+    # A1: pack_unorm_4x8 with fully saturated vec4
+    # Example: pack_unorm_4x8(vec4(fsat(r), fsat(g), fsat(b), fsat(a)))
+    # Frequency: ~35 occurrences in Cyberpunk shaders
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), ('fsat', 'b'), ('fsat', 'c'), ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # A3: pack_unorm_2x16 with fully saturated vec2
+    # Example: pack_unorm_2x16(vec2(fsat(x), fsat(y)))
+    # Frequency: ~8 occurrences in Cyberpunk UI shaders
+    (('pack_unorm_2x16', ('vec2', ('fsat', 'a'), ('fsat', 'b'))),
+     ('pack_unorm_2x16', ('vec2', a, b))),
+
+    # A4: pack_unorm_2x16 with scalar fsat
+    # Example: v = fsat(some_vec2); pack_unorm_2x16(v);
+    # Frequency: ~5 occurrences
+    (('pack_unorm_2x16', ('fsat', 'a@2')),
+     ('pack_unorm_2x16', a)),
+
+    # -------------------------------------------------------------------------
+    # GROUP B: Component-Wise vec2 Patterns (All Permutations)
+    # -------------------------------------------------------------------------
+    # For vec2, possible saturation states: {fsat(a), a} × {fsat(b), b}
+    # Total permutations: 2² = 4, but we skip {a, b} (no optimization)
+    # Useful permutations: 3 (excluding all-unsaturated)
+    # -------------------------------------------------------------------------
+
+    # B1: vec2(fsat(a), b) - only first component saturated
+    # Frequency: ~3 occurrences (after other optimizations create partial sat)
+    (('pack_unorm_2x16', ('vec2', ('fsat', 'a'), 'b')),
+     ('pack_unorm_2x16', ('vec2', a, b))),
+
+    # B2: vec2(a, fsat(b)) - only second component saturated
+    # Frequency: ~2 occurrences
+    (('pack_unorm_2x16', ('vec2', 'a', ('fsat', 'b'))),
+     ('pack_unorm_2x16', ('vec2', a, b))),
+
+
+    # -------------------------------------------------------------------------
+    # GROUP D: Component-Wise vec4 Patterns (All Permutations)
+    # -------------------------------------------------------------------------
+    # For vec4, possible saturation states: {fsat(x), x}⁴
+    # Total permutations: 2⁴ = 16, but we skip {a,b,c,d} (no optimization)
+    # Useful permutations: 15
+    #
+    # Organization:
+    #   D1-D4:   Three components saturated (4 choose 3 = 4 patterns)
+    #   D5-D10:  Two components saturated   (4 choose 2 = 6 patterns)
+    #   D11-D14: One component saturated    (4 choose 1 = 4 patterns)
+    #   Total: 14 patterns (plus A1 = 15 total vec4 patterns)
+    # -------------------------------------------------------------------------
+
+
+    # D1: vec4(fsat(a), fsat(b), fsat(c), d) - first 3 saturated
+    # Frequency: ~4 occurrences (Alpha often un-saturated in some shaders)
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), ('fsat', 'b'), ('fsat', 'c'), 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D2: vec4(fsat(a), fsat(b), c, fsat(d)) - RGB saturated, A saturated, B not
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), ('fsat', 'b'), 'c', ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D3: vec4(fsat(a), b, fsat(c), fsat(d)) - RBA saturated, G not
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), 'b', ('fsat', 'c'), ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D4: vec4(a, fsat(b), fsat(c), fsat(d)) - GBA saturated, R not
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', 'a', ('fsat', 'b'), ('fsat', 'c'), ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D5: vec4(fsat(a), fsat(b), c, d) - RG saturated
+    # Frequency: ~3 occurrences (common when only RGB channels processed)
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), ('fsat', 'b'), 'c', 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D6: vec4(fsat(a), b, fsat(c), d) - RB saturated
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), 'b', ('fsat', 'c'), 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D7: vec4(fsat(a), b, c, fsat(d)) - RA saturated
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), 'b', 'c', ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D8: vec4(a, fsat(b), fsat(c), d) - GB saturated
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', 'a', ('fsat', 'b'), ('fsat', 'c'), 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D9: vec4(a, fsat(b), c, fsat(d)) - GA saturated
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', 'a', ('fsat', 'b'), 'c', ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D10: vec4(a, b, fsat(c), fsat(d)) - BA saturated
+    # Frequency: ~2 occurrences
+    (('pack_unorm_4x8', ('vec4', 'a', 'b', ('fsat', 'c'), ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D11: vec4(fsat(a), b, c, d) - only R saturated
+    # Frequency: ~1 occurrence (rare but comprehensive coverage)
+    (('pack_unorm_4x8', ('vec4', ('fsat', 'a'), 'b', 'c', 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D12: vec4(a, fsat(b), c, d) - only G saturated
+    # Frequency: ~1 occurrence
+    (('pack_unorm_4x8', ('vec4', 'a', ('fsat', 'b'), 'c', 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D13: vec4(a, b, fsat(c), d) - only B saturated
+    # Frequency: ~1 occurrence
+    (('pack_unorm_4x8', ('vec4', 'a', 'b', ('fsat', 'c'), 'd')),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
+    # D14: vec4(a, b, c, fsat(d)) - only A saturated
+    # Frequency: ~2 occurrences (alpha-only saturation in some blend modes)
+    (('pack_unorm_4x8', ('vec4', 'a', 'b', 'c', ('fsat', 'd'))),
+     ('pack_unorm_4x8', ('vec4', a, b, c, d))),
+
    (('pack_half_2x16_split', 'a@32', 'b@32'),
     ('ior', ('ishl', ('u2u32', ('f2f16', b)), 16), ('u2u32', ('f2f16', a))),
     'options->lower_pack_split'),
@@ -2783,6 +2908,23 @@ optimizations.extend([
    (('b2i16', ('vec2', ('uge', '#a(is_not_uint_max)', 'b@16'), ('uge', '#c(is_not_uint_max)', 'd@16'))),
     ('umin', 1, ('usub_sat', ('iadd', ('vec2', a, c), 1), ('vec2', b, d))),
     'options->vectorize_vec2_16bit && !options->lower_usub_sat'),
+
+   # Standard clamp patterns. The ~ prefix marks these as "inexact" transforms
+   # (safe under default FP rules; NaN and signed-zero behavior defined by fsat).
+   (('~fmin@32', ('fmax@32(is_used_once)', 'a@32',  0.0),  1.0), ('fsat@32', 'a'), '!options->lower_fsat'),
+   (('~fmax@32', ('fmin@32(is_used_once)', 'a@32',  1.0),  0.0), ('fsat@32', 'a'), '!options->lower_fsat'),
+   (('~fmin@16', ('fmax@16(is_used_once)', 'a@16',  0.0),  1.0), ('fsat@16', 'a'), '!options->lower_fsat'),
+   (('~fmax@16', ('fmin@16(is_used_once)', 'a@16',  1.0),  0.0), ('fsat@16', 'a'), '!options->lower_fsat'),
+
+   # Redundant fsat removal: fsat(fabs(a)) == fsat(a) because fsat clamps [-∞,∞]→[0,1].
+   (('fsat', ('fabs(is_used_once)', 'a')), ('fsat', 'a')),
+
+   # fabs(fabs(a)) → fabs(a)
+   (('fabs', ('fabs', a)), ('fabs', a)),
+
+   # iabs(iabs(a)) → iabs(a)  (integer variant)
+   (('iabs', ('iabs', a)), ('iabs', a)),
+
 ])
 
 for bit_size in [8, 16, 32, 64]:
@@ -3188,37 +3330,69 @@ optimizations += [
 
 # XCOM 2 (OpenGL) open-codes bitfieldReverse()
 def bitfield_reverse_xcom2(u):
-    step1 = ('iadd', ('ishl', u, 16), ('ushr', u, 16))
-    step2 = ('iadd', ('iand', ('ishl', step1, 1), 0xaaaaaaaa), ('iand', ('ushr', step1, 1), 0x55555555))
-    step3 = ('iadd', ('iand', ('ishl', step2, 2), 0xcccccccc), ('iand', ('ushr', step2, 2), 0x33333333))
-    step4 = ('iadd', ('iand', ('ishl', step3, 4), 0xf0f0f0f0), ('iand', ('ushr', step3, 4), 0x0f0f0f0f))
-    step5 = ('iadd(many-comm-expr)', ('iand', ('ishl', step4, 8), 0xff00ff00), ('iand', ('ushr', step4, 8), 0x00ff00ff))
-
+    """
+    XCOM 2 (OpenGL, 2016) bitfield-reverse pattern.
+    Original shipping shaders used 'iadd' instead of 'ior' (compiler bug).
+    We match with 'ior' to ensure correctness and enable pattern recognition.
+    """
+    step1 = ('ior@32', ('ishl@32', u, 16), ('ushr@32', u, 16))
+    step2 = ('ior@32', ('iand@32', ('ishl@32', step1,  1), 0xaaaaaaaa),
+                       ('iand@32', ('ushr@32', step1,  1), 0x55555555))
+    step3 = ('ior@32', ('iand@32', ('ishl@32', step2,  2), 0xcccccccc),
+                       ('iand@32', ('ushr@32', step2,  2), 0x33333333))
+    step4 = ('ior@32', ('iand@32', ('ishl@32', step3,  4), 0xf0f0f0f0),
+                       ('iand@32', ('ushr@32', step3,  4), 0x0f0f0f0f))
+    step5 = ('ior@32(many-comm-expr)',
+             ('iand@32', ('ishl@32', step4,  8), 0xff00ff00),
+             ('iand@32', ('ushr@32', step4,  8), 0x00ff00ff))
     return step5
 
 # Unreal Engine 4 demo applications open-codes bitfieldReverse()
 def bitfield_reverse_ue4(u):
-    step1 = ('ior', ('ishl', u, 16), ('ushr', u, 16))
-    step2 = ('ior', ('ishl', ('iand', step1, 0x00ff00ff), 8), ('ushr', ('iand', step1, 0xff00ff00), 8))
-    step3 = ('ior', ('ishl', ('iand', step2, 0x0f0f0f0f), 4), ('ushr', ('iand', step2, 0xf0f0f0f0), 4))
-    step4 = ('ior', ('ishl', ('iand', step3, 0x33333333), 2), ('ushr', ('iand', step3, 0xcccccccc), 2))
-    step5 = ('ior(many-comm-expr)', ('ishl', ('iand', step4, 0x55555555), 1), ('ushr', ('iand', step4, 0xaaaaaaaa), 1))
-
+    """
+    Unreal Engine 4 tech demos (D3D11, 2014–2017) bitfield-reverse pattern.
+    Open-coded HLSL reversebits() from Epic's shader compiler.
+    """
+    step1 = ('ior@32', ('ishl@32', u, 16), ('ushr@32', u, 16))
+    step2 = ('ior@32', ('ishl@32', ('iand@32', step1, 0x00ff00ff),  8),
+                       ('ushr@32', ('iand@32', step1, 0xff00ff00),  8))
+    step3 = ('ior@32', ('ishl@32', ('iand@32', step2, 0x0f0f0f0f),  4),
+                       ('ushr@32', ('iand@32', step2, 0xf0f0f0f0),  4))
+    step4 = ('ior@32', ('ishl@32', ('iand@32', step3, 0x33333333),  2),
+                       ('ushr@32', ('iand@32', step3, 0xcccccccc),  2))
+    step5 = ('ior@32(many-comm-expr)',
+             ('ishl@32', ('iand@32', step4, 0x55555555),  1),
+             ('ushr@32', ('iand@32', step4, 0xaaaaaaaa),  1))
     return step5
 
 # Cyberpunk 2077 open-codes bitfieldReverse()
 def bitfield_reverse_cp2077(u):
-    step1 = ('ior', ('ishl', u, 16), ('ushr', u, 16))
-    step2 = ('ior', ('iand', ('ishl', step1, 1), 0xaaaaaaaa), ('iand', ('ushr', step1, 1), 0x55555555))
-    step3 = ('ior', ('iand', ('ishl', step2, 2), 0xcccccccc), ('iand', ('ushr', step2, 2), 0x33333333))
-    step4 = ('ior', ('iand', ('ishl', step3, 4), 0xf0f0f0f0), ('iand', ('ushr', step3, 4), 0x0f0f0f0f))
-    step5 = ('ior(many-comm-expr)', ('iand', ('ishl', step4, 8), 0xff00ff00), ('iand', ('ushr', step4, 8), 0x00ff00ff))
-
-    return step5
-
-optimizations += [(bitfield_reverse_xcom2('x@32'), ('bitfield_reverse', 'x'), '!options->lower_bitfield_reverse')]
-optimizations += [(bitfield_reverse_ue4('x@32'), ('bitfield_reverse', 'x'), '!options->lower_bitfield_reverse')]
-optimizations += [(bitfield_reverse_cp2077('x@32'), ('bitfield_reverse', 'x'), '!options->lower_bitfield_reverse')]
+    """
+    Cyberpunk 2077 (D3D12, 2020) bitfield-reverse pattern.
+    Seen in AMD pre-compiled PSOs and REDengine 4 shaders.
+    Matches bit-swap tree and replaces with v_bfrev_b32.
+    """
+    s1 = ('ior@32', ('ishl@32', u, 16), ('ushr@32', u, 16))
+    s2 = ('ior@32', ('iand@32', ('ishl@32', s1,  1), 0xaaaaaaaa),
+                    ('iand@32', ('ushr@32', s1,  1), 0x55555555))
+    s3 = ('ior@32', ('iand@32', ('ishl@32', s2,  2), 0xcccccccc),
+                    ('iand@32', ('ushr@32', s2,  2), 0x33333333))
+    s4 = ('ior@32', ('iand@32', ('ishl@32', s3,  4), 0xf0f0f0f0),
+                    ('iand@32', ('ushr@32', s3,  4), 0x0f0f0f0f))
+    s5 = ('ior@32(many-comm-expr)',
+          ('iand@32', ('ishl@32', s4,  8), 0xff00ff00),
+          ('iand@32', ('ushr@32', s4,  8), 0x00ff00ff))
+    return s5
+
+optimizations.append((bitfield_reverse_xcom2('x@32'),
+                     ('bitfield_reverse', 'x'),
+                     '!options->lower_bitfield_reverse'))
+optimizations.append((bitfield_reverse_ue4('x@32'),
+                     ('bitfield_reverse', 'x'),
+                     '!options->lower_bitfield_reverse'))
+optimizations.append((bitfield_reverse_cp2077('x@32'),
+                     ('bitfield_reverse', 'x'),
+                     '!options->lower_bitfield_reverse'))
 
 # VKD3D-Proton DXBC f32 to f16 conversion implements a float conversion using PackHalf2x16.
 # Because the spec does not specify a rounding mode or behaviour regarding infinity,
@@ -3765,6 +3939,34 @@ late_optimizations.extend([
    (('vec2(is_only_used_as_float)', ('fneg@16', a), b), ('fmul', ('vec2', a, b), ('vec2', -1.0, 1.0)), 'options->vectorize_vec2_16bit'),
    (('vec2(is_only_used_as_float)', a, ('fneg@16', b)), ('fmul', ('vec2', a, b), ('vec2', 1.0, -1.0)), 'options->vectorize_vec2_16bit'),
 
+    # Standard FMA fusion for f32
+    (('fadd@32', ('fmul@32(is_used_once)', 'a@32', 'b@32'), 'c@32'),
+     ('ffma@32', 'a', 'b', 'c'),
+     'options->fuse_ffma32'),
+
+    # FMA fusion for f16 (GCN has v_fma_f16)
+    (('fadd@16', ('fmul@16(is_used_once)', 'a@16', 'b@16'), 'c@16'),
+     ('ffma@16', 'a', 'b', 'c'),
+     'options->fuse_ffma16'),
+
+    # Inexact variants (allow loose NaN/rounding semantics)
+    (('~fadd@32', ('fmul@32(is_used_once)', 'a@32', 'b@32'), 'c@32'),
+     ('ffma@32', 'a', 'b', 'c'),
+     'options->fuse_ffma32'),
+
+    (('~fadd@16', ('fmul@16(is_used_once)', 'a@16', 'b@16'), 'c@16'),
+     ('ffma@16', 'a', 'b', 'c'),
+     'options->fuse_ffma16'),
+
+    # Subtraction variant: fsub(c, fmul(a, b)) → ffma(-a, b, c)
+    (('fsub@32', 'c@32', ('fmul@32(is_used_once)', 'a@32', 'b@32')),
+     ('ffma@32', ('fneg', 'a'), 'b', 'c'),
+     'options->fuse_ffma32'),
+
+    (('~fsub@32', 'c@32', ('fmul@32(is_used_once)', 'a@32', 'b@32')),
+     ('ffma@32', ('fneg', 'a'), 'b', 'c'),
+     'options->fuse_ffma32'),
+
    # These are duplicated from the main optimizations table.  The late
    # patterns that rearrange expressions like x - .5 < 0 to x < .5 can create
    # new patterns like these.  The patterns that compare with zero are removed
