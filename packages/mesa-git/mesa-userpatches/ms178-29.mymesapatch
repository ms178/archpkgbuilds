--- a/src/compiler/nir/nir_opt_algebraic.py	2025-10-17 10:58:54.371161768 +0200
+++ b/src/compiler/nir/nir_opt_algebraic.py	2025-10-17 11:13:20.535349933 +0200
@@ -2783,6 +2783,17 @@ optimizations.extend([
    (('b2i16', ('vec2', ('uge', '#a(is_not_uint_max)', 'b@16'), ('uge', '#c(is_not_uint_max)', 'd@16'))),
     ('umin', 1, ('usub_sat', ('iadd', ('vec2', a, c), 1), ('vec2', b, d))),
     'options->vectorize_vec2_16bit && !options->lower_usub_sat'),
+
+   # Standard clamp patterns. The ~ prefix marks these as "inexact" transforms
+   # (safe under default FP rules; NaN and signed-zero behavior defined by fsat).
+   (('~fmin@32', ('fmax@32(is_used_once)', 'a@32',  0.0),  1.0), ('fsat@32', 'a'), '!options->lower_fsat'),
+   (('~fmax@32', ('fmin@32(is_used_once)', 'a@32',  1.0),  0.0), ('fsat@32', 'a'), '!options->lower_fsat'),
+   (('~fmin@16', ('fmax@16(is_used_once)', 'a@16',  0.0),  1.0), ('fsat@16', 'a'), '!options->lower_fsat'),
+   (('~fmax@16', ('fmin@16(is_used_once)', 'a@16',  1.0),  0.0), ('fsat@16', 'a'), '!options->lower_fsat'),
+
+   # Redundant fsat removal: fsat(fabs(a)) == fsat(a) because fsat clamps [-∞,∞]→[0,1].
+   (('fsat', ('fabs(is_used_once)', 'a')), ('fsat', 'a')),
+
 ])
 
 for bit_size in [8, 16, 32, 64]:
@@ -3188,37 +3199,69 @@ optimizations += [
 
 # XCOM 2 (OpenGL) open-codes bitfieldReverse()
 def bitfield_reverse_xcom2(u):
-    step1 = ('iadd', ('ishl', u, 16), ('ushr', u, 16))
-    step2 = ('iadd', ('iand', ('ishl', step1, 1), 0xaaaaaaaa), ('iand', ('ushr', step1, 1), 0x55555555))
-    step3 = ('iadd', ('iand', ('ishl', step2, 2), 0xcccccccc), ('iand', ('ushr', step2, 2), 0x33333333))
-    step4 = ('iadd', ('iand', ('ishl', step3, 4), 0xf0f0f0f0), ('iand', ('ushr', step3, 4), 0x0f0f0f0f))
-    step5 = ('iadd(many-comm-expr)', ('iand', ('ishl', step4, 8), 0xff00ff00), ('iand', ('ushr', step4, 8), 0x00ff00ff))
-
+    """
+    XCOM 2 (OpenGL, 2016) bitfield-reverse pattern.
+    Original shipping shaders used 'iadd' instead of 'ior' (compiler bug).
+    We match with 'ior' to ensure correctness and enable pattern recognition.
+    """
+    step1 = ('ior@32', ('ishl@32', u, 16), ('ushr@32', u, 16))
+    step2 = ('ior@32', ('iand@32', ('ishl@32', step1,  1), 0xaaaaaaaa),
+                       ('iand@32', ('ushr@32', step1,  1), 0x55555555))
+    step3 = ('ior@32', ('iand@32', ('ishl@32', step2,  2), 0xcccccccc),
+                       ('iand@32', ('ushr@32', step2,  2), 0x33333333))
+    step4 = ('ior@32', ('iand@32', ('ishl@32', step3,  4), 0xf0f0f0f0),
+                       ('iand@32', ('ushr@32', step3,  4), 0x0f0f0f0f))
+    step5 = ('ior@32(many-comm-expr)',
+             ('iand@32', ('ishl@32', step4,  8), 0xff00ff00),
+             ('iand@32', ('ushr@32', step4,  8), 0x00ff00ff))
     return step5
 
 # Unreal Engine 4 demo applications open-codes bitfieldReverse()
 def bitfield_reverse_ue4(u):
-    step1 = ('ior', ('ishl', u, 16), ('ushr', u, 16))
-    step2 = ('ior', ('ishl', ('iand', step1, 0x00ff00ff), 8), ('ushr', ('iand', step1, 0xff00ff00), 8))
-    step3 = ('ior', ('ishl', ('iand', step2, 0x0f0f0f0f), 4), ('ushr', ('iand', step2, 0xf0f0f0f0), 4))
-    step4 = ('ior', ('ishl', ('iand', step3, 0x33333333), 2), ('ushr', ('iand', step3, 0xcccccccc), 2))
-    step5 = ('ior(many-comm-expr)', ('ishl', ('iand', step4, 0x55555555), 1), ('ushr', ('iand', step4, 0xaaaaaaaa), 1))
-
+    """
+    Unreal Engine 4 tech demos (D3D11, 2014–2017) bitfield-reverse pattern.
+    Open-coded HLSL reversebits() from Epic's shader compiler.
+    """
+    step1 = ('ior@32', ('ishl@32', u, 16), ('ushr@32', u, 16))
+    step2 = ('ior@32', ('ishl@32', ('iand@32', step1, 0x00ff00ff),  8),
+                       ('ushr@32', ('iand@32', step1, 0xff00ff00),  8))
+    step3 = ('ior@32', ('ishl@32', ('iand@32', step2, 0x0f0f0f0f),  4),
+                       ('ushr@32', ('iand@32', step2, 0xf0f0f0f0),  4))
+    step4 = ('ior@32', ('ishl@32', ('iand@32', step3, 0x33333333),  2),
+                       ('ushr@32', ('iand@32', step3, 0xcccccccc),  2))
+    step5 = ('ior@32(many-comm-expr)',
+             ('ishl@32', ('iand@32', step4, 0x55555555),  1),
+             ('ushr@32', ('iand@32', step4, 0xaaaaaaaa),  1))
     return step5
 
 # Cyberpunk 2077 open-codes bitfieldReverse()
 def bitfield_reverse_cp2077(u):
-    step1 = ('ior', ('ishl', u, 16), ('ushr', u, 16))
-    step2 = ('ior', ('iand', ('ishl', step1, 1), 0xaaaaaaaa), ('iand', ('ushr', step1, 1), 0x55555555))
-    step3 = ('ior', ('iand', ('ishl', step2, 2), 0xcccccccc), ('iand', ('ushr', step2, 2), 0x33333333))
-    step4 = ('ior', ('iand', ('ishl', step3, 4), 0xf0f0f0f0), ('iand', ('ushr', step3, 4), 0x0f0f0f0f))
-    step5 = ('ior(many-comm-expr)', ('iand', ('ishl', step4, 8), 0xff00ff00), ('iand', ('ushr', step4, 8), 0x00ff00ff))
-
-    return step5
-
-optimizations += [(bitfield_reverse_xcom2('x@32'), ('bitfield_reverse', 'x'), '!options->lower_bitfield_reverse')]
-optimizations += [(bitfield_reverse_ue4('x@32'), ('bitfield_reverse', 'x'), '!options->lower_bitfield_reverse')]
-optimizations += [(bitfield_reverse_cp2077('x@32'), ('bitfield_reverse', 'x'), '!options->lower_bitfield_reverse')]
+    """
+    Cyberpunk 2077 (D3D12, 2020) bitfield-reverse pattern.
+    Seen in AMD pre-compiled PSOs and REDengine 4 shaders.
+    Matches bit-swap tree and replaces with v_bfrev_b32.
+    """
+    s1 = ('ior@32', ('ishl@32', u, 16), ('ushr@32', u, 16))
+    s2 = ('ior@32', ('iand@32', ('ishl@32', s1,  1), 0xaaaaaaaa),
+                    ('iand@32', ('ushr@32', s1,  1), 0x55555555))
+    s3 = ('ior@32', ('iand@32', ('ishl@32', s2,  2), 0xcccccccc),
+                    ('iand@32', ('ushr@32', s2,  2), 0x33333333))
+    s4 = ('ior@32', ('iand@32', ('ishl@32', s3,  4), 0xf0f0f0f0),
+                    ('iand@32', ('ushr@32', s3,  4), 0x0f0f0f0f))
+    s5 = ('ior@32(many-comm-expr)',
+          ('iand@32', ('ishl@32', s4,  8), 0xff00ff00),
+          ('iand@32', ('ushr@32', s4,  8), 0x00ff00ff))
+    return s5
+
+optimizations.append((bitfield_reverse_xcom2('x@32'),
+                     ('bitfield_reverse', 'x'),
+                     '!options->lower_bitfield_reverse'))
+optimizations.append((bitfield_reverse_ue4('x@32'),
+                     ('bitfield_reverse', 'x'),
+                     '!options->lower_bitfield_reverse'))
+optimizations.append((bitfield_reverse_cp2077('x@32'),
+                     ('bitfield_reverse', 'x'),
+                     '!options->lower_bitfield_reverse'))
 
 # VKD3D-Proton DXBC f32 to f16 conversion implements a float conversion using PackHalf2x16.
 # Because the spec does not specify a rounding mode or behaviour regarding infinity,
@@ -3765,6 +3808,34 @@ late_optimizations.extend([
    (('vec2(is_only_used_as_float)', ('fneg@16', a), b), ('fmul', ('vec2', a, b), ('vec2', -1.0, 1.0)), 'options->vectorize_vec2_16bit'),
    (('vec2(is_only_used_as_float)', a, ('fneg@16', b)), ('fmul', ('vec2', a, b), ('vec2', 1.0, -1.0)), 'options->vectorize_vec2_16bit'),
 
+    # Standard FMA fusion for f32
+    (('fadd@32', ('fmul@32(is_used_once)', 'a@32', 'b@32'), 'c@32'),
+     ('ffma@32', 'a', 'b', 'c'),
+     'options->fuse_ffma32'),
+
+    # FMA fusion for f16 (GCN has v_fma_f16)
+    (('fadd@16', ('fmul@16(is_used_once)', 'a@16', 'b@16'), 'c@16'),
+     ('ffma@16', 'a', 'b', 'c'),
+     'options->fuse_ffma16'),
+
+    # Inexact variants (allow loose NaN/rounding semantics)
+    (('~fadd@32', ('fmul@32(is_used_once)', 'a@32', 'b@32'), 'c@32'),
+     ('ffma@32', 'a', 'b', 'c'),
+     'options->fuse_ffma32'),
+
+    (('~fadd@16', ('fmul@16(is_used_once)', 'a@16', 'b@16'), 'c@16'),
+     ('ffma@16', 'a', 'b', 'c'),
+     'options->fuse_ffma16'),
+
+    # Subtraction variant: fsub(c, fmul(a, b)) → ffma(-a, b, c)
+    (('fsub@32', 'c@32', ('fmul@32(is_used_once)', 'a@32', 'b@32')),
+     ('ffma@32', ('fneg', 'a'), 'b', 'c'),
+     'options->fuse_ffma32'),
+
+    (('~fsub@32', 'c@32', ('fmul@32(is_used_once)', 'a@32', 'b@32')),
+     ('ffma@32', ('fneg', 'a'), 'b', 'c'),
+     'options->fuse_ffma32'),
+
    # These are duplicated from the main optimizations table.  The late
    # patterns that rearrange expressions like x - .5 < 0 to x < .5 can create
    # new patterns like these.  The patterns that compare with zero are removed
