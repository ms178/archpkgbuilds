From ac55ff6ff9f473907d7310ce016bd7fe241aea11 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 20 Sep 2023 14:44:28 -0400
Subject: [PATCH 1/3] nir: split
 FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP* flags

GLSL doesn't preserve NaNs, but it optionally preserves Infs.
---
 src/compiler/nir/nir.h         | 24 +++++++++++++++
 src/compiler/nir/nir_print.c   |  2 +-
 src/compiler/shader_enums.h    | 53 ++++++++++++++++++++++++----------
 src/compiler/shader_info.h     |  2 +-
 src/compiler/spirv/nir_spirv.h |  2 +-
 5 files changed, 64 insertions(+), 19 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 2c367ab1d6ea2..1e437d3f95d0d 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -1256,6 +1256,30 @@ nir_op_is_vec_or_mov(nir_op op)
    return op == nir_op_mov || nir_op_is_vec(op);
 }
 
+static inline bool
+nir_is_float_control_signed_zero_preserve(unsigned execution_mode, unsigned bit_size)
+{
+   return (16 == bit_size && execution_mode & FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP16) ||
+          (32 == bit_size && execution_mode & FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP32) ||
+          (64 == bit_size && execution_mode & FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP64);
+}
+
+static inline bool
+nir_is_float_control_inf_preserve(unsigned execution_mode, unsigned bit_size)
+{
+   return (16 == bit_size && execution_mode & FLOAT_CONTROLS_INF_PRESERVE_FP16) ||
+          (32 == bit_size && execution_mode & FLOAT_CONTROLS_INF_PRESERVE_FP32) ||
+          (64 == bit_size && execution_mode & FLOAT_CONTROLS_INF_PRESERVE_FP64);
+}
+
+static inline bool
+nir_is_float_control_nan_preserve(unsigned execution_mode, unsigned bit_size)
+{
+   return (16 == bit_size && execution_mode & FLOAT_CONTROLS_NAN_PRESERVE_FP16) ||
+          (32 == bit_size && execution_mode & FLOAT_CONTROLS_NAN_PRESERVE_FP32) ||
+          (64 == bit_size && execution_mode & FLOAT_CONTROLS_NAN_PRESERVE_FP64);
+}
+
 static inline bool
 nir_is_float_control_signed_zero_inf_nan_preserve(unsigned execution_mode, unsigned bit_size)
 {
diff --git a/src/compiler/nir/nir_print.c b/src/compiler/nir/nir_print.c
index 48fa1577f6924..91577b68b1013 100644
--- a/src/compiler/nir/nir_print.c
+++ b/src/compiler/nir/nir_print.c
@@ -2367,7 +2367,7 @@ print_shader_info(const struct shader_info *info, FILE *fp)
    print_nz_bitset(fp, "image_buffers", info->image_buffers, ARRAY_SIZE(info->image_buffers));
    print_nz_bitset(fp, "msaa_images", info->msaa_images, ARRAY_SIZE(info->msaa_images));
 
-   print_nz_x16(fp, "float_controls_execution_mode", info->float_controls_execution_mode);
+   print_nz_x32(fp, "float_controls_execution_mode", info->float_controls_execution_mode);
 
    print_nz_unsigned(fp, "shared_size", info->shared_size);
 
diff --git a/src/compiler/shader_enums.h b/src/compiler/shader_enums.h
index 31e8ebb897ce2..f71cf01c3015f 100644
--- a/src/compiler/shader_enums.h
+++ b/src/compiler/shader_enums.h
@@ -1242,22 +1242,43 @@ enum gl_derivative_group {
 
 enum float_controls
 {
-   FLOAT_CONTROLS_DEFAULT_FLOAT_CONTROL_MODE        = 0x0000,
-   FLOAT_CONTROLS_DENORM_PRESERVE_FP16              = 0x0001,
-   FLOAT_CONTROLS_DENORM_PRESERVE_FP32              = 0x0002,
-   FLOAT_CONTROLS_DENORM_PRESERVE_FP64              = 0x0004,
-   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP16         = 0x0008,
-   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP32         = 0x0010,
-   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP64         = 0x0020,
-   FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP16 = 0x0040,
-   FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP32 = 0x0080,
-   FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP64 = 0x0100,
-   FLOAT_CONTROLS_ROUNDING_MODE_RTE_FP16            = 0x0200,
-   FLOAT_CONTROLS_ROUNDING_MODE_RTE_FP32            = 0x0400,
-   FLOAT_CONTROLS_ROUNDING_MODE_RTE_FP64            = 0x0800,
-   FLOAT_CONTROLS_ROUNDING_MODE_RTZ_FP16            = 0x1000,
-   FLOAT_CONTROLS_ROUNDING_MODE_RTZ_FP32            = 0x2000,
-   FLOAT_CONTROLS_ROUNDING_MODE_RTZ_FP64            = 0x4000,
+   FLOAT_CONTROLS_DEFAULT_FLOAT_CONTROL_MODE = 0,
+   FLOAT_CONTROLS_DENORM_PRESERVE_FP16       = BITFIELD_BIT(0),
+   FLOAT_CONTROLS_DENORM_PRESERVE_FP32       = BITFIELD_BIT(1),
+   FLOAT_CONTROLS_DENORM_PRESERVE_FP64       = BITFIELD_BIT(2),
+   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP16  = BITFIELD_BIT(3),
+   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP32  = BITFIELD_BIT(4),
+   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP64  = BITFIELD_BIT(5),
+   FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP16  = BITFIELD_BIT(6),
+   FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP32  = BITFIELD_BIT(7),
+   FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP64  = BITFIELD_BIT(8),
+   FLOAT_CONTROLS_INF_PRESERVE_FP16          = BITFIELD_BIT(9),
+   FLOAT_CONTROLS_INF_PRESERVE_FP32          = BITFIELD_BIT(10),
+   FLOAT_CONTROLS_INF_PRESERVE_FP64          = BITFIELD_BIT(11),
+   FLOAT_CONTROLS_NAN_PRESERVE_FP16          = BITFIELD_BIT(12),
+   FLOAT_CONTROLS_NAN_PRESERVE_FP32          = BITFIELD_BIT(13),
+   FLOAT_CONTROLS_NAN_PRESERVE_FP64          = BITFIELD_BIT(14),
+   FLOAT_CONTROLS_ROUNDING_MODE_RTE_FP16     = BITFIELD_BIT(15),
+   FLOAT_CONTROLS_ROUNDING_MODE_RTE_FP32     = BITFIELD_BIT(16),
+   FLOAT_CONTROLS_ROUNDING_MODE_RTE_FP64     = BITFIELD_BIT(17),
+   FLOAT_CONTROLS_ROUNDING_MODE_RTZ_FP16     = BITFIELD_BIT(18),
+   FLOAT_CONTROLS_ROUNDING_MODE_RTZ_FP32     = BITFIELD_BIT(19),
+   FLOAT_CONTROLS_ROUNDING_MODE_RTZ_FP64     = BITFIELD_BIT(20),
+
+   FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP16 =
+      FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP16 |
+      FLOAT_CONTROLS_INF_PRESERVE_FP16 |
+      FLOAT_CONTROLS_NAN_PRESERVE_FP16,
+
+   FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP32 =
+      FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP32 |
+      FLOAT_CONTROLS_INF_PRESERVE_FP32 |
+      FLOAT_CONTROLS_NAN_PRESERVE_FP32,
+
+   FLOAT_CONTROLS_SIGNED_ZERO_INF_NAN_PRESERVE_FP64 =
+      FLOAT_CONTROLS_SIGNED_ZERO_PRESERVE_FP64 |
+      FLOAT_CONTROLS_INF_PRESERVE_FP64 |
+      FLOAT_CONTROLS_NAN_PRESERVE_FP64,
 };
 
 /**
diff --git a/src/compiler/shader_info.h b/src/compiler/shader_info.h
index 785473a85a2ec..8ad4419c27a55 100644
--- a/src/compiler/shader_info.h
+++ b/src/compiler/shader_info.h
@@ -224,7 +224,7 @@ typedef struct shader_info {
    BITSET_DECLARE(msaa_images, 64);
 
    /* SPV_KHR_float_controls: execution mode for floating point ops */
-   uint16_t float_controls_execution_mode;
+   uint32_t float_controls_execution_mode;
 
    /**
     * Size of shared variables accessed by compute/task/mesh shaders.
diff --git a/src/compiler/spirv/nir_spirv.h b/src/compiler/spirv/nir_spirv.h
index 85eeccc2e2c9c..1369a0e6b47b5 100644
--- a/src/compiler/spirv/nir_spirv.h
+++ b/src/compiler/spirv/nir_spirv.h
@@ -64,7 +64,7 @@ struct spirv_to_nir_options {
    /* Initial value for shader_info::float_controls_execution_mode,
     * indicates hardware requirements rather than shader author intent
     */
-   uint16_t float_controls_execution_mode;
+   uint32_t float_controls_execution_mode;
 
    /* Initial subgroup size.  This may be overwritten for CL kernels */
    enum gl_subgroup_size subgroup_size;
-- 
GitLab


From 257f212b799b4c10671220bb46c616a9685ec70c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 20 Sep 2023 22:28:31 -0400
Subject: [PATCH 2/3] nir/algebraic: use only signed_zero_preserve_* for
 addition by 0 patterns

Some GLSL versions will set inf_preserve but not the other flags.
Additions by 0 only affect signed zeros.
---
 src/compiler/nir/nir_opt_algebraic.py | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 5177b3852e647..b530f3349bb1b 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -37,6 +37,8 @@ d = 'd'
 e = 'e'
 NAN = math.nan
 
+signed_zero_preserve_16 = 'nir_is_float_control_signed_zero_preserve(info->float_controls_execution_mode, 16)'
+signed_zero_preserve_32 = 'nir_is_float_control_signed_zero_preserve(info->float_controls_execution_mode, 32)'
 signed_zero_inf_nan_preserve_16 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 16)'
 signed_zero_inf_nan_preserve_32 = 'nir_is_float_control_signed_zero_inf_nan_preserve(info->float_controls_execution_mode, 32)'
 
@@ -139,8 +141,8 @@ optimizations = [
    # a+0.0 is 'a' unless 'a' is denormal or -0.0. If it's only used by a
    # floating point instruction, they should flush any input denormals and we
    # can replace -0.0 with 0.0 if the float execution mode allows it.
-   (('fadd(is_only_used_as_float)', 'a@16', 0.0), a, '!'+signed_zero_inf_nan_preserve_16),
-   (('fadd(is_only_used_as_float)', 'a@32', 0.0), a, '!'+signed_zero_inf_nan_preserve_32),
+   (('fadd(is_only_used_as_float)', 'a@16', 0.0), a, '!'+signed_zero_preserve_16),
+   (('fadd(is_only_used_as_float)', 'a@32', 0.0), a, '!'+signed_zero_preserve_32),
    (('iadd', a, 0), a),
    (('iadd_sat', a, 0), a),
    (('isub_sat', a, 0), a),
@@ -207,9 +209,9 @@ optimizations = [
    (('ffma@32(is_only_used_as_float)', 0.0, a, b), b, '!'+signed_zero_inf_nan_preserve_32),
    (('ffmaz', 0.0, a, b), ('fadd', 0.0, b)),
    (('~ffma', a, b, 0.0), ('fmul', a, b)),
-   (('ffma@16', a, b, 0.0), ('fmul', a, b), '!'+signed_zero_inf_nan_preserve_16),
-   (('ffma@32', a, b, 0.0), ('fmul', a, b), '!'+signed_zero_inf_nan_preserve_32),
-   (('ffmaz', a, b, 0.0), ('fmulz', a, b), '!'+signed_zero_inf_nan_preserve_32),
+   (('ffma@16', a, b, 0.0), ('fmul', a, b), '!'+signed_zero_preserve_16),
+   (('ffma@32', a, b, 0.0), ('fmul', a, b), '!'+signed_zero_preserve_32),
+   (('ffmaz', a, b, 0.0), ('fmulz', a, b), '!'+signed_zero_preserve_32),
    (('ffma', 1.0, a, b), ('fadd', a, b)),
    (('ffmaz', 1.0, a, b), ('fadd', a, b), '!'+signed_zero_inf_nan_preserve_32),
    (('ffma', -1.0, a, b), ('fadd', ('fneg', a), b)),
-- 
GitLab


From 02f5e63c9e7a2d4e65909a9f1103fd944769d714 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 20 Sep 2023 17:38:18 -0400
Subject: [PATCH 3/3] glsl: set execution mode to preserve Infs for GLSL 4.10,
 ES 3.00, etc.

The ARB_shader_precision flag is propagated to glsl_to_nir, which then
sets the execution mode.
---
 src/compiler/glsl/glsl_parser_extras.cpp |  1 +
 src/compiler/glsl/glsl_to_nir.cpp        | 13 +++++++++++++
 src/compiler/glsl/linker.cpp             |  5 +++++
 src/mesa/main/shader_types.h             |  3 +++
 4 files changed, 22 insertions(+)

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 048c719444ba6..01c4fed9c264c 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -2065,6 +2065,7 @@ set_shader_inout_layout(struct gl_shader *shader,
       break;
    }
 
+   shader->ARB_shader_precision_enable = state->ARB_shader_precision_enable;
    shader->bindless_sampler = state->bindless_sampler_specified;
    shader->bindless_image = state->bindless_image_specified;
    shader->bound_sampler = state->bound_sampler_specified;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 4ff0614e9308d..26036f2272972 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -260,6 +260,19 @@ glsl_to_nir(const struct gl_constants *consts,
    nir_shader *shader = nir_shader_create(NULL, stage, options,
                                           &sh->Program->info);
 
+   /* This must be set before optimizations because they use it.
+    *
+    * GLSL 4.10, GLSL ES 3.00, and GL_ARB_shader_precision have roughly
+    * the same text requiring infinities to be generated.
+    */
+   if ((!shader_prog->IsES &&
+        (shader_prog->GLSL_Version >= 410 || sh->ARB_shader_precision_enable)) ||
+       (shader_prog->IsES && shader_prog->GLSL_Version >= 300)) {
+      shader->info.float_controls_execution_mode |=
+         FLOAT_CONTROLS_INF_PRESERVE_FP32 |
+         FLOAT_CONTROLS_INF_PRESERVE_FP64;
+   }
+
    nir_visitor v1(consts, shader);
    nir_function_visitor v2(&v1);
    v2.run(sh->ir);
diff --git a/src/compiler/glsl/linker.cpp b/src/compiler/glsl/linker.cpp
index a87cc9150f89f..308c7d7f64549 100644
--- a/src/compiler/glsl/linker.cpp
+++ b/src/compiler/glsl/linker.cpp
@@ -2527,6 +2527,11 @@ link_intrastage_shaders(void *mem_ctx,
       }
    }
 
+   for (unsigned i = 0; i < num_shaders; i++) {
+      if (shader_list[i] && shader_list[i]->ARB_shader_precision_enable)
+         linked->ARB_shader_precision_enable = true;
+   }
+
    /* Set the linked source SHA1. */
    if (num_shaders == 1) {
       memcpy(linked->linked_source_sha1, shader_list[0]->compiled_source_sha1,
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index adb5e575981fb..84cc6081c0566 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -185,6 +185,7 @@ struct gl_shader
    bool EarlyFragmentTests;
 
    bool ARB_fragment_coord_conventions_enable;
+   bool ARB_shader_precision_enable;
    bool OES_geometry_point_size_enable;
    bool OES_tessellation_point_size_enable;
 
@@ -241,6 +242,8 @@ struct gl_linked_shader
 
    struct gl_program *Program;  /**< Post-compile assembly code */
 
+   bool ARB_shader_precision_enable;
+
    /**
     * \name Sampler tracking
     *
-- 
GitLab

