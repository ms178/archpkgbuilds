From 00ddbb94b830403a62944a74a2e2a62ca14fe93e Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 17 Apr 2022 21:17:18 +0200
Subject: [PATCH 1/6] aco/ra: Static assert that changing instruction type to
 VOP2 is valid.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It's not obvious that this is correct.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_register_allocation.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 6193e4bf6001..922c5b849e55 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2695,6 +2695,10 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
                   use_vop2 = false;
             }
             if (use_vop2) {
+               static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3_instruction),
+                             "Invalid direct instruction cast.");
+               static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3P_instruction),
+                             "Invalid direct instruction cast.");
                instr->format = Format::VOP2;
                switch (instr->opcode) {
                case aco_opcode::v_mad_f32: instr->opcode = aco_opcode::v_mac_f32; break;
-- 
GitLab


From e20acbb992b71edcc4e51c8ca69c2cec77a0cea9 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 19 May 2022 15:50:30 +0200
Subject: [PATCH 2/6] aco/ra: Move mac encoding optimization to its own
 function.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_register_allocation.cpp | 114 ++++++++++---------
 1 file changed, 60 insertions(+), 54 deletions(-)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 922c5b849e55..32ddca431b0c 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2541,6 +2541,65 @@ get_affinities(ra_ctx& ctx, std::vector<IDSet>& live_out_per_block)
    }
 }
 
+void
+optimize_encoding_vop2(Program* program, ra_ctx& ctx, RegisterFile& register_file,
+                       aco_ptr<Instruction>& instr)
+{
+   /* try to optimize v_mad_f32 -> v_mac_f32 */
+   if ((instr->opcode != aco_opcode::v_mad_f32 &&
+        (instr->opcode != aco_opcode::v_fma_f32 || program->gfx_level < GFX10) &&
+        instr->opcode != aco_opcode::v_mad_f16 && instr->opcode != aco_opcode::v_mad_legacy_f16 &&
+        (instr->opcode != aco_opcode::v_fma_f16 || program->gfx_level < GFX10) &&
+        (instr->opcode != aco_opcode::v_pk_fma_f16 || program->gfx_level < GFX10) &&
+        (instr->opcode != aco_opcode::v_mad_legacy_f32 || !program->dev.has_mac_legacy32) &&
+        (instr->opcode != aco_opcode::v_fma_legacy_f32 || !program->dev.has_mac_legacy32) &&
+        (instr->opcode != aco_opcode::v_dot4_i32_i8 || program->family == CHIP_VEGA20)) ||
+       !instr->operands[2].isTemp() || !instr->operands[2].isKillBeforeDef() ||
+       instr->operands[2].getTemp().type() != RegType::vgpr ||
+       ((!instr->operands[0].isTemp() || instr->operands[0].getTemp().type() != RegType::vgpr) &&
+        (!instr->operands[1].isTemp() || instr->operands[1].getTemp().type() != RegType::vgpr)) ||
+       instr->usesModifiers() || instr->operands[0].physReg().byte() != 0 ||
+       instr->operands[1].physReg().byte() != 0 || instr->operands[2].physReg().byte() != 0)
+      return;
+
+   if (!instr->operands[1].isTemp() || instr->operands[1].getTemp().type() != RegType::vgpr)
+      std::swap(instr->operands[0], instr->operands[1]);
+
+   unsigned def_id = instr->definitions[0].tempId();
+   if (ctx.assignments[def_id].affinity) {
+      assignment& affinity = ctx.assignments[ctx.assignments[def_id].affinity];
+      if (affinity.assigned && affinity.reg != instr->operands[2].physReg() &&
+          !register_file.test(affinity.reg, instr->operands[2].bytes()))
+         return;
+   }
+
+   static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3_instruction),
+                 "Invalid direct instruction cast.");
+   static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3P_instruction),
+                 "Invalid direct instruction cast.");
+   instr->format = Format::VOP2;
+   switch (instr->opcode) {
+   case aco_opcode::v_mad_f32: instr->opcode = aco_opcode::v_mac_f32; break;
+   case aco_opcode::v_fma_f32: instr->opcode = aco_opcode::v_fmac_f32; break;
+   case aco_opcode::v_mad_f16:
+   case aco_opcode::v_mad_legacy_f16: instr->opcode = aco_opcode::v_mac_f16; break;
+   case aco_opcode::v_fma_f16: instr->opcode = aco_opcode::v_fmac_f16; break;
+   case aco_opcode::v_pk_fma_f16: instr->opcode = aco_opcode::v_pk_fmac_f16; break;
+   case aco_opcode::v_dot4_i32_i8: instr->opcode = aco_opcode::v_dot4c_i32_i8; break;
+   case aco_opcode::v_mad_legacy_f32: instr->opcode = aco_opcode::v_mac_legacy_f32; break;
+   case aco_opcode::v_fma_legacy_f32: instr->opcode = aco_opcode::v_fmac_legacy_f32; break;
+   default: break;
+   }
+}
+
+void
+optimize_encoding(Program* program, ra_ctx& ctx, RegisterFile& register_file,
+                  aco_ptr<Instruction>& instr)
+{
+   if (instr->isVALU())
+      optimize_encoding_vop2(program, ctx, register_file, instr);
+}
+
 } /* end namespace */
 
 void
@@ -2664,60 +2723,7 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
                register_file.clear(op);
          }
 
-         /* try to optimize v_mad_f32 -> v_mac_f32 */
-         if ((instr->opcode == aco_opcode::v_mad_f32 ||
-              (instr->opcode == aco_opcode::v_fma_f32 && program->gfx_level >= GFX10) ||
-              instr->opcode == aco_opcode::v_mad_f16 ||
-              instr->opcode == aco_opcode::v_mad_legacy_f16 ||
-              (instr->opcode == aco_opcode::v_fma_f16 && program->gfx_level >= GFX10) ||
-              (instr->opcode == aco_opcode::v_pk_fma_f16 && program->gfx_level >= GFX10) ||
-              (instr->opcode == aco_opcode::v_mad_legacy_f32 && program->dev.has_mac_legacy32) ||
-              (instr->opcode == aco_opcode::v_fma_legacy_f32 && program->dev.has_mac_legacy32) ||
-              (instr->opcode == aco_opcode::v_dot4_i32_i8 && program->family != CHIP_VEGA20)) &&
-             instr->operands[2].isTemp() && instr->operands[2].isKillBeforeDef() &&
-             instr->operands[2].getTemp().type() == RegType::vgpr &&
-             ((instr->operands[0].isTemp() &&
-               instr->operands[0].getTemp().type() == RegType::vgpr) ||
-              (instr->operands[1].isTemp() &&
-               instr->operands[1].getTemp().type() == RegType::vgpr)) &&
-             !instr->usesModifiers() && instr->operands[0].physReg().byte() == 0 &&
-             instr->operands[1].physReg().byte() == 0 && instr->operands[2].physReg().byte() == 0) {
-            if (!instr->operands[1].isTemp() ||
-                instr->operands[1].getTemp().type() != RegType::vgpr)
-               std::swap(instr->operands[0], instr->operands[1]);
-
-            unsigned def_id = instr->definitions[0].tempId();
-            bool use_vop2 = true;
-            if (ctx.assignments[def_id].affinity) {
-               assignment& affinity = ctx.assignments[ctx.assignments[def_id].affinity];
-               if (affinity.assigned && affinity.reg != instr->operands[2].physReg() &&
-                   !register_file.test(affinity.reg, instr->operands[2].bytes()))
-                  use_vop2 = false;
-            }
-            if (use_vop2) {
-               static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3_instruction),
-                             "Invalid direct instruction cast.");
-               static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3P_instruction),
-                             "Invalid direct instruction cast.");
-               instr->format = Format::VOP2;
-               switch (instr->opcode) {
-               case aco_opcode::v_mad_f32: instr->opcode = aco_opcode::v_mac_f32; break;
-               case aco_opcode::v_fma_f32: instr->opcode = aco_opcode::v_fmac_f32; break;
-               case aco_opcode::v_mad_f16:
-               case aco_opcode::v_mad_legacy_f16: instr->opcode = aco_opcode::v_mac_f16; break;
-               case aco_opcode::v_fma_f16: instr->opcode = aco_opcode::v_fmac_f16; break;
-               case aco_opcode::v_pk_fma_f16: instr->opcode = aco_opcode::v_pk_fmac_f16; break;
-               case aco_opcode::v_dot4_i32_i8: instr->opcode = aco_opcode::v_dot4c_i32_i8; break;
-               case aco_opcode::v_mad_legacy_f32:
-                  instr->opcode = aco_opcode::v_mac_legacy_f32;
-                  break;
-               case aco_opcode::v_fma_legacy_f32:
-                  instr->opcode = aco_opcode::v_fmac_legacy_f32;
-                  break;
-               default: break;
-               }
-            }
-         }
+         optimize_encoding(program, ctx, register_file, instr);
 
          /* Handle definitions which must have the same register as an operand.
           * We expect that the definition has the same size as the operand, otherwise the new
-- 
GitLab


From 7706d4f7f71c51bba7b218c91cbce62de4619ac7 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 17 Apr 2022 21:09:15 +0200
Subject: [PATCH 3/6] aco/ir: Pad SOP2 and SOPC to the same size as SOPK.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Being able to directly cast instructions simplifies optimizations.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_ir.h | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index aa85f933938c..47b0e36c009c 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1341,14 +1341,18 @@ struct SOPP_instruction : public Instruction {
 };
 static_assert(sizeof(SOPP_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
 
-struct SOPC_instruction : public Instruction {};
-static_assert(sizeof(SOPC_instruction) == sizeof(Instruction) + 0, "Unexpected padding");
+struct SOPC_instruction : public Instruction {
+   uint32_t padding;
+};
+static_assert(sizeof(SOPC_instruction) == sizeof(Instruction) + 4, "Unexpected padding");
 
 struct SOP1_instruction : public Instruction {};
 static_assert(sizeof(SOP1_instruction) == sizeof(Instruction) + 0, "Unexpected padding");
 
-struct SOP2_instruction : public Instruction {};
-static_assert(sizeof(SOP2_instruction) == sizeof(Instruction) + 0, "Unexpected padding");
+struct SOP2_instruction : public Instruction {
+   uint32_t padding;
+};
+static_assert(sizeof(SOP2_instruction) == sizeof(Instruction) + 4, "Unexpected padding");
 
 /**
  * Scalar Memory Format:
-- 
GitLab


From 5f2918024baa8afe8f7e7b5bb4456b330ae06dfe Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 17 Apr 2022 13:17:20 +0200
Subject: [PATCH 4/6] aco/ra: Optimize some SOP2 instructions with literal to
 SOPK.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_register_allocation.cpp | 61 +++++++++++++++++++-
 1 file changed, 60 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 32ddca431b0c..5bd1602a36bf 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2592,12 +2592,70 @@ optimize_encoding_vop2(Program* program, ra_ctx& ctx, RegisterFile& register_fil
    }
 }
 
+void
+optimize_encoding_sopk(Program* program, ra_ctx& ctx, RegisterFile& register_file,
+                       aco_ptr<Instruction>& instr)
+{
+   /* try to optimize sop2 with literal source to sopk */
+   if (instr->opcode != aco_opcode::s_add_i32 && instr->opcode != aco_opcode::s_mul_i32 &&
+       instr->opcode != aco_opcode::s_cselect_b32)
+      return;
+
+   uint32_t literal_idx = 0;
+
+   if (instr->opcode != aco_opcode::s_cselect_b32 && instr->operands[1].isLiteral())
+      literal_idx = 1;
+
+   if (!instr->operands[!literal_idx].isTemp() ||
+       !instr->operands[!literal_idx].isKillBeforeDef() ||
+       instr->operands[!literal_idx].getTemp().type() != RegType::sgpr ||
+       instr->operands[!literal_idx].physReg() == scc)
+      return;
+
+   if (!instr->operands[literal_idx].isLiteral())
+      return;
+
+   const uint32_t i16_mask = 0xffff8000u;
+   uint32_t value = instr->operands[literal_idx].constantValue();
+   if ((value & i16_mask) && (value & i16_mask) != i16_mask)
+      return;
+
+   unsigned def_id = instr->definitions[0].tempId();
+   if (ctx.assignments[def_id].affinity) {
+      assignment& affinity = ctx.assignments[ctx.assignments[def_id].affinity];
+      if (affinity.assigned && affinity.reg != instr->operands[!literal_idx].physReg() &&
+          !register_file.test(affinity.reg, instr->operands[!literal_idx].bytes()))
+         return;
+   }
+
+   static_assert(sizeof(SOPK_instruction) <= sizeof(SOP2_instruction),
+                 "Invalid direct instruction cast.");
+   instr->format = Format::SOPK;
+   SOPK_instruction* instr_sopk = &instr->sopk();
+
+   instr_sopk->imm = instr_sopk->operands[literal_idx].constantValue() & 0xffff;
+   if (literal_idx == 0)
+      std::swap(instr_sopk->operands[0], instr_sopk->operands[1]);
+   if (instr_sopk->operands.size() > 2)
+      std::swap(instr_sopk->operands[1], instr_sopk->operands[2]);
+   instr_sopk->operands.pop_back();
+
+   switch (instr_sopk->opcode) {
+   case aco_opcode::s_add_i32: instr_sopk->opcode = aco_opcode::s_addk_i32; break;
+   case aco_opcode::s_mul_i32: instr_sopk->opcode = aco_opcode::s_mulk_i32; break;
+   case aco_opcode::s_cselect_b32: instr_sopk->opcode = aco_opcode::s_cmovk_i32; break;
+   default: unreachable("illegal instruction");
+   }
+}
+
 void
 optimize_encoding(Program* program, ra_ctx& ctx, RegisterFile& register_file,
                   aco_ptr<Instruction>& instr)
 {
    if (instr->isVALU())
       optimize_encoding_vop2(program, ctx, register_file, instr);
+   if (instr->isSALU())
+      optimize_encoding_sopk(program, ctx, register_file, instr);
 }
 
 } /* end namespace */
@@ -2744,7 +2802,8 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
                    instr->operands[2].regClass() == v1);
             instr->definitions[0].setFixed(instr->operands[2].physReg());
          } else if (instr->opcode == aco_opcode::s_addk_i32 ||
-                    instr->opcode == aco_opcode::s_mulk_i32) {
+                    instr->opcode == aco_opcode::s_mulk_i32 ||
+                    instr->opcode == aco_opcode::s_cmovk_i32) {
             assert(instr->definitions[0].bytes() == instr->operands[0].bytes());
             instr->definitions[0].setFixed(instr->operands[0].physReg());
          } else if (instr->isMUBUF() && instr->definitions.size() == 1 &&
-- 
GitLab


From 01f09de49c0115a67fb2a8fc77fb78c95702a4c8 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 17 Apr 2022 14:32:34 +0200
Subject: [PATCH 5/6] aco/optimizer: Convert s_add_u32 with literals to
 s_add_i32 if carry is not used.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To allow further optimizations to s_addk_i32.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_optimizer.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 87052efdd2b5..6787cacfb462 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4555,6 +4555,11 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       }
    }
 
+   /* allow more s_addk_i32 optimizations if carry isn't used */
+   if (instr->opcode == aco_opcode::s_add_u32 && ctx.uses[instr->definitions[1].tempId()] == 0 &&
+       (instr->operands[0].isLiteral() || instr->operands[1].isLiteral()))
+      instr->opcode = aco_opcode::s_add_i32;
+
    ctx.instructions.emplace_back(std::move(instr));
 }
 
-- 
GitLab


From 2c4e4094576d2133075393d1d7ca125712f14875 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 17 Apr 2022 22:14:30 +0200
Subject: [PATCH 6/6] aco/optimizer: Optimize SOPC with literal to SOPK.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/compiler/aco_optimizer.cpp | 110 +++++++++++++++++++++++++++++
 1 file changed, 110 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 6787cacfb462..930a79cd31ac 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4497,6 +4497,113 @@ select_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
+static aco_opcode
+sopk_opcode_for_sopc(aco_opcode opcode)
+{
+#define CTOK(op)                                                                                   \
+   case aco_opcode::s_cmp_##op##_i32: return aco_opcode::s_cmpk_##op##_i32;                        \
+   case aco_opcode::s_cmp_##op##_u32: return aco_opcode::s_cmpk_##op##_u32;
+   switch (opcode) {
+      CTOK(eq)
+      CTOK(lg)
+      CTOK(gt)
+      CTOK(ge)
+      CTOK(lt)
+      CTOK(le)
+   default: return aco_opcode::num_opcodes;
+   }
+#undef CTOK
+}
+
+static bool
+sopc_is_signed(aco_opcode opcode)
+{
+#define SOPC(op)                                                                                   \
+   case aco_opcode::s_cmp_##op##_i32: return true;                                                 \
+   case aco_opcode::s_cmp_##op##_u32: return false;
+   switch (opcode) {
+      SOPC(eq)
+      SOPC(lg)
+      SOPC(gt)
+      SOPC(ge)
+      SOPC(lt)
+      SOPC(le)
+   default: unreachable("Not a valid SOPC instruction.");
+   }
+#undef SOPC
+}
+
+static aco_opcode
+sopc_32_inverse(aco_opcode opcode)
+{
+#define SOPC(op1, op2)                                                                             \
+   case aco_opcode::s_cmp_##op1##_i32: return aco_opcode::s_cmp_##op2##_i32;                       \
+   case aco_opcode::s_cmp_##op1##_u32: return aco_opcode::s_cmp_##op2##_u32;
+   switch (opcode) {
+      SOPC(eq, eq)
+      SOPC(lg, lg)
+      SOPC(gt, le)
+      SOPC(ge, lt)
+      SOPC(lt, ge)
+      SOPC(le, gt)
+   default: return aco_opcode::num_opcodes;
+   }
+#undef SOPC
+}
+
+static void
+try_convert_sopc_to_sopk(aco_ptr<Instruction>& instr)
+{
+   if (sopk_opcode_for_sopc(instr->opcode) == aco_opcode::num_opcodes)
+      return;
+
+   if (instr->operands[0].isLiteral()) {
+      std::swap(instr->operands[0], instr->operands[1]);
+      instr->opcode = sopc_32_inverse(instr->opcode);
+   }
+
+   if (!instr->operands[1].isLiteral())
+      return;
+
+   if (instr->operands[0].isConstant())
+      return;
+
+   uint32_t value = instr->operands[1].constantValue();
+
+   const uint32_t i16_mask = 0xffff8000u;
+
+   bool value_is_i16 = (value & i16_mask) == 0 || (value & i16_mask) == i16_mask;
+   bool value_is_u16 = !(value & 0xffff0000u);
+
+   if (!value_is_i16 && !value_is_u16)
+      return;
+
+   if (!value_is_i16 && sopc_is_signed(instr->opcode)) {
+      if (instr->opcode == aco_opcode::s_cmp_lg_i32)
+         instr->opcode = aco_opcode::s_cmp_lg_u32;
+      else if (instr->opcode == aco_opcode::s_cmp_eq_i32)
+         instr->opcode = aco_opcode::s_cmp_eq_u32;
+      else
+         return;
+   } else if (!value_is_u16 && !sopc_is_signed(instr->opcode)) {
+      if (instr->opcode == aco_opcode::s_cmp_lg_u32)
+         instr->opcode = aco_opcode::s_cmp_lg_i32;
+      else if (instr->opcode == aco_opcode::s_cmp_eq_u32)
+         instr->opcode = aco_opcode::s_cmp_eq_i32;
+      else
+         return;
+   }
+
+   static_assert(sizeof(SOPK_instruction) <= sizeof(SOPC_instruction),
+                 "Invalid direct instruction cast.");
+   instr->format = Format::SOPK;
+   SOPK_instruction* instr_sopk = &instr->sopk();
+
+   instr_sopk->imm = instr_sopk->operands[1].constantValue() & 0xffff;
+   instr_sopk->opcode = sopk_opcode_for_sopc(instr_sopk->opcode);
+   instr_sopk->operands.pop_back();
+}
+
 void
 apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -4555,6 +4662,9 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       }
    }
 
+   if (instr->isSOPC())
+      try_convert_sopc_to_sopk(instr);
+
    /* allow more s_addk_i32 optimizations if carry isn't used */
    if (instr->opcode == aco_opcode::s_add_u32 && ctx.uses[instr->definitions[1].tempId()] == 0 &&
        (instr->operands[0].isLiteral() || instr->operands[1].isLiteral()))
-- 
GitLab

