From 7968cd52abbaf9597bbec593d5b9ee194c6f0d96 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Mon, 2 Oct 2023 22:35:04 -0700
Subject: [PATCH] util: Add a way to set the min_buffer_size in linear_alloc
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The default value remains 2048, which is also used for rounding up
any user provided size.

The option is useful in cases where there's a better idea of the
amount of data that's going to be used.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/util/ralloc.c              | 22 ++++++++++++++++++----
 src/util/ralloc.h              |  6 ++++++
 src/util/tests/linear_test.cpp | 18 ++++++++++++++++++
 3 files changed, 42 insertions(+), 4 deletions(-)

diff --git a/src/util/ralloc.c b/src/util/ralloc.c
index c85c61e3d8aa..811942d66bbe 100644
--- a/src/util/ralloc.c
+++ b/src/util/ralloc.c
@@ -964,7 +964,6 @@ gc_sweep_end(gc_ctx *ctx)
  * other buffers.
  */
 
-#define MIN_LINEAR_BUFSIZE 2048
 #define SUBALLOC_ALIGNMENT 8
 #define LMAGIC_CONTEXT 0x87b9c7d3
 #define LMAGIC_NODE    0x87b910d3
@@ -976,6 +975,8 @@ struct linear_ctx {
 #ifndef NDEBUG
    unsigned magic;   /* for debugging */
 #endif
+   unsigned min_buffer_size;
+
    unsigned offset;  /* points to the first unused byte in the latest buffer */
    unsigned size;    /* size of the latest buffer */
    void *latest;     /* the only buffer that has free space */
@@ -1021,8 +1022,8 @@ linear_alloc_child(linear_ctx *ctx, unsigned size)
    if (unlikely(ctx->offset + size > ctx->size)) {
       /* allocate a new node */
       unsigned node_size = size;
-      if (likely(node_size < MIN_LINEAR_BUFSIZE))
-         node_size = MIN_LINEAR_BUFSIZE;
+      if (likely(node_size < ctx->min_buffer_size))
+         node_size = ctx->min_buffer_size;
       
       const unsigned canary_size = get_node_canary_size();
       const unsigned full_size = canary_size + node_size;
@@ -1070,13 +1071,24 @@ linear_alloc_child(linear_ctx *ctx, unsigned size)
 
 linear_ctx *
 linear_context(void *ralloc_ctx)
+{
+   const linear_opts opts = {};
+   return linear_context_with_opts(ralloc_ctx, &opts);
+}
+
+linear_ctx *
+linear_context_with_opts(void *ralloc_ctx, const linear_opts *opts)
 {
    linear_ctx *ctx;
 
    if (unlikely(!ralloc_ctx))
       return NULL;
 
-   const unsigned size = MIN_LINEAR_BUFSIZE;
+   const unsigned default_min_buffer_size = 2048;
+   const unsigned min_buffer_size =
+      ALIGN_POT(opts->min_buffer_size, default_min_buffer_size);
+
+   const unsigned size = min_buffer_size;
    const unsigned canary_size = get_node_canary_size();
    const unsigned full_size =
       sizeof(linear_ctx) + canary_size + size;                 
@@ -1085,6 +1097,8 @@ linear_context(void *ralloc_ctx)
    if (unlikely(!ctx))
       return NULL;
 
+   ctx->min_buffer_size = min_buffer_size;
+
    ctx->offset = 0;
    ctx->size = size;
    ctx->latest = (char *)&ctx[1] + canary_size;
diff --git a/src/util/ralloc.h b/src/util/ralloc.h
index 58d851f18239..2078a88ff07a 100644
--- a/src/util/ralloc.h
+++ b/src/util/ralloc.h
@@ -579,6 +579,10 @@ typedef struct linear_ctx linear_ctx;
  */
 void *linear_alloc_child(linear_ctx *ctx, unsigned size);
 
+typedef struct {
+   unsigned min_buffer_size;
+} linear_opts;
+
 /**
  * Allocate a linear context that will internally hold linear buffers.
  * Use it for all child node allocations.
@@ -587,6 +591,8 @@ void *linear_alloc_child(linear_ctx *ctx, unsigned size);
  */
 linear_ctx *linear_context(void *ralloc_ctx);
 
+linear_ctx *linear_context_with_opts(void *ralloc_ctx, const linear_opts *opts);
+
 /**
  * Same as linear_alloc_child, but also clears memory.
  */
diff --git a/src/util/tests/linear_test.cpp b/src/util/tests/linear_test.cpp
index 2b5731845157..dfcaeb344392 100644
--- a/src/util/tests/linear_test.cpp
+++ b/src/util/tests/linear_test.cpp
@@ -70,3 +70,21 @@ TEST(LinearAlloc, AvoidWasteAfterLargeAlloc)
 
    ralloc_free(ctx);
 }
+
+TEST(LinearAlloc, Options)
+{
+   void *ctx = ralloc_context(NULL);
+   const linear_opts opts = {
+      .min_buffer_size = 8192,
+   };
+   linear_ctx *lin_ctx = linear_context_with_opts(ctx, &opts);
+
+   /* Assert allocations spanning the first 8192 bytes are contiguous. */
+   char *first = (char *)linear_alloc_child(lin_ctx, 1024);
+   for (int i = 1; i < 8; i++) {
+      char *ptr = (char *)linear_alloc_child(lin_ctx, 1024);
+      EXPECT_EQ(ptr - first, 1024 * i);
+   }
+
+   ralloc_free(ctx);
+}
-- 
GitLab

