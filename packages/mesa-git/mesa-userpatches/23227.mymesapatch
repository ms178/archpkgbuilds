From be079ce8e9aee271576ee4e69d4e777eeafc5d7f Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 25 May 2023 11:33:49 +1000
Subject: [PATCH 1/6] radv/video: fix h264/265 dpb usage.

This seems to be the best compromise I can come up with so far.

I can't figure out to get the tier2 programming to match between
264 and 265, maybe they are just programmed different here, good
old firmware.

Fixes: 1693c03a3963 ("radv/video: add initial h264 decoder for VCN")
---
 src/amd/vulkan/radv_video.c | 51 +++++++++++++++++++++++--------------
 1 file changed, 32 insertions(+), 19 deletions(-)

diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index 120abd6e7616..9f72f22888d5 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -829,25 +829,25 @@ static rvcn_dec_message_avc_t get_h264_msg(struct radv_video_session *vid,
       const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
          vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
 
-      result.frame_num_list[idx] = idx;
-      result.field_order_cnt_list[idx][0] = dpb_slot->pStdReferenceInfo->PicOrderCnt[0];
-      result.field_order_cnt_list[idx][1] = dpb_slot->pStdReferenceInfo->PicOrderCnt[1];
+      result.frame_num_list[i] = idx;
+      result.field_order_cnt_list[i][0] = dpb_slot->pStdReferenceInfo->PicOrderCnt[0];
+      result.field_order_cnt_list[i][1] = dpb_slot->pStdReferenceInfo->PicOrderCnt[1];
 
-      result.ref_frame_list[idx] = idx;
+      result.ref_frame_list[i] = idx;
 
       if (dpb_slot->pStdReferenceInfo->flags.top_field_flag)
-         result.used_for_reference_flags |= (1 << (2 * idx));
+         result.used_for_reference_flags |= (1 << (2 * i));
       if (dpb_slot->pStdReferenceInfo->flags.bottom_field_flag)
-         result.used_for_reference_flags |= (1 << (2 * idx + 1));
+         result.used_for_reference_flags |= (1 << (2 * i + 1));
 
       if (!dpb_slot->pStdReferenceInfo->flags.top_field_flag &&
           !dpb_slot->pStdReferenceInfo->flags.bottom_field_flag)
-         result.used_for_reference_flags |= (3 << (2 * idx));
+         result.used_for_reference_flags |= (3 << (2 * i));
 
       if (dpb_slot->pStdReferenceInfo->flags.used_for_long_term_reference)
-        result.ref_frame_list[idx] |= 0x80;
+        result.ref_frame_list[i] |= 0x80;
       if (dpb_slot->pStdReferenceInfo->flags.is_non_existing)
-         result.non_existing_frame_flags |= 1 << idx;
+         result.non_existing_frame_flags |= 1 << i;
 
    }
    result.curr_pic_ref_frame_num = frame_info->referenceSlotCount;
@@ -1131,6 +1131,7 @@ static bool rvcn_dec_message_decode(struct radv_cmd_buffer *cmd_buffer,
    }
 
    *slice_offset = 0;
+   bool tier_2_use_slot = false;
    switch (vid->vk.op) {
    case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
       rvcn_dec_message_avc_t avc = get_h264_msg(vid, params, frame_info, slice_offset, &decode->width_in_samples, &decode->height_in_samples, it_ptr);
@@ -1142,6 +1143,7 @@ static bool rvcn_dec_message_decode(struct radv_cmd_buffer *cmd_buffer,
       rvcn_dec_message_hevc_t hevc = get_h265_msg(device, vid, params, frame_info, it_ptr);
       memcpy(codec, (void *)&hevc, sizeof(rvcn_dec_message_hevc_t));
       index_codec->message_id = RDECODE_MESSAGE_HEVC;
+      tier_2_use_slot = true;
       break;
    }
    default:
@@ -1157,7 +1159,7 @@ static bool rvcn_dec_message_decode(struct radv_cmd_buffer *cmd_buffer,
    for (int i = 0; i < frame_info->referenceSlotCount; i++) {
       struct radv_image_view *f_dpb_iv = radv_image_view_from_handle(frame_info->pReferenceSlots[i].pPictureResource->imageViewBinding);
       struct radv_image *dpb_img = f_dpb_iv->image;
-      int idx = frame_info->pReferenceSlots[i].slotIndex;
+      int idx = tier_2_use_slot ? frame_info->pReferenceSlots[i].slotIndex : i;
 
       radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, dpb_img->bindings[0].bo);
       addr = radv_buffer_get_va(dpb_img->bindings[0].bo) + dpb_img->bindings[0].offset;
@@ -1269,6 +1271,7 @@ static struct ruvd_h264 get_uvd_h264_msg(struct radv_video_session *vid,
       memset(result.scaling_list_8x8, 0x10, 2*64);
    }
 
+   memset(it_ptr, 0, IT_SCALING_TABLE_SIZE);
    memcpy(it_ptr, result.scaling_list_4x4, 6 * 16);
    memcpy((char *)it_ptr + 96, result.scaling_list_8x8, 2 * 64);
 
@@ -1281,15 +1284,23 @@ static struct ruvd_h264 get_uvd_h264_msg(struct radv_video_session *vid,
    result.frame_num = h264_pic_info->pStdPictureInfo->frame_num;
 
    result.num_ref_frames = sps->max_num_ref_frames;
+   memset(result.ref_frame_list, 0xff, sizeof(unsigned char) * 16);
+   memset(result.frame_num_list, 0, sizeof(unsigned int) * 16);
    for (unsigned i = 0; i < frame_info->referenceSlotCount; i++) {
       int idx = frame_info->pReferenceSlots[i].slotIndex;
       const struct VkVideoDecodeH264DpbSlotInfoKHR *dpb_slot =
          vk_find_struct_const(frame_info->pReferenceSlots[i].pNext, VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR);
 
-      result.frame_num_list[idx] = dpb_slot->pStdReferenceInfo->FrameNum;
-      result.field_order_cnt_list[idx][0] = dpb_slot->pStdReferenceInfo->PicOrderCnt[0];
-      result.field_order_cnt_list[idx][1] = dpb_slot->pStdReferenceInfo->PicOrderCnt[1];
+      result.frame_num_list[i] = dpb_slot->pStdReferenceInfo->FrameNum;
+      result.field_order_cnt_list[i][0] = dpb_slot->pStdReferenceInfo->PicOrderCnt[0];
+      result.field_order_cnt_list[i][1] = dpb_slot->pStdReferenceInfo->PicOrderCnt[1];
+
+      result.ref_frame_list[i] = idx;
+
+      if (dpb_slot->pStdReferenceInfo->flags.used_for_long_term_reference)
+        result.ref_frame_list[i] |= 0x80;
    }
+   result.curr_pic_ref_frame_num = frame_info->referenceSlotCount;
    result.decoded_pic_idx = frame_info->pSetupReferenceSlot->slotIndex;
 
    return result;
@@ -1340,12 +1351,14 @@ static struct ruvd_h265 get_uvd_h265_msg(struct radv_device *device,
       sps->log2_diff_max_min_luma_transform_block_size;
    result.max_transform_hierarchy_depth_inter = sps->max_transform_hierarchy_depth_inter;
    result.max_transform_hierarchy_depth_intra = sps->max_transform_hierarchy_depth_intra;
-   result.pcm_sample_bit_depth_luma_minus1 = sps->pcm_sample_bit_depth_luma_minus1;
-   result.pcm_sample_bit_depth_chroma_minus1 = sps->pcm_sample_bit_depth_chroma_minus1;
-   result.log2_min_pcm_luma_coding_block_size_minus3 =
-      sps->log2_min_pcm_luma_coding_block_size_minus3;
-   result.log2_diff_max_min_pcm_luma_coding_block_size =
-      sps->log2_diff_max_min_pcm_luma_coding_block_size;
+   if (sps->flags.pcm_enabled_flag) {
+      result.pcm_sample_bit_depth_luma_minus1 = sps->pcm_sample_bit_depth_luma_minus1;
+      result.pcm_sample_bit_depth_chroma_minus1 = sps->pcm_sample_bit_depth_chroma_minus1;
+      result.log2_min_pcm_luma_coding_block_size_minus3 =
+         sps->log2_min_pcm_luma_coding_block_size_minus3;
+      result.log2_diff_max_min_pcm_luma_coding_block_size =
+         sps->log2_diff_max_min_pcm_luma_coding_block_size;
+   }
    result.num_short_term_ref_pic_sets = sps->num_short_term_ref_pic_sets;
 
    result.pps_info_flags = 0;
-- 
GitLab


From e2e17d91d0390e59edd6f5803639e4de3ebda88a Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 25 May 2023 11:32:46 +1000
Subject: [PATCH 2/6] radv/video: add missing offset to the dpb binding.

This doesn't affect anything I've seen yet.

Fixes: 3e2c768aa860 ("radv/vcn: enable dynamic dpb tier 2 for h264/h265 on navi21+")
---
 src/amd/vulkan/radv_video.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index 9f72f22888d5..6745f4acd59b 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -1170,7 +1170,7 @@ static bool rvcn_dec_message_decode(struct radv_cmd_buffer *cmd_buffer,
    }
 
    radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, dpb->bindings[0].bo);
-   addr = radv_buffer_get_va(dpb->bindings[0].bo);
+   addr = radv_buffer_get_va(dpb->bindings[0].bo) + dpb->bindings[0].offset;
 
    dynamic_dpb_t2->dpbCurrLo = addr;
    dynamic_dpb_t2->dpbCurrHi = addr >> 32;
-- 
GitLab


From dc2d2f85cf74e00271ba9beca0d059c3f84d5206 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 25 May 2023 11:31:44 +1000
Subject: [PATCH 3/6] radv/video: rework stream handle generation.

This shouldn't change anything, except move some calcs to an
earlier spot to avoid redoing them
---
 src/amd/vulkan/radv_private.h |  2 ++
 src/amd/vulkan/radv_video.c   | 20 ++++++++++----------
 2 files changed, 12 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index ad227b61a8e4..650663715731 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -376,6 +376,8 @@ struct radv_physical_device {
    } vid_dec_reg;
    enum amd_ip_type vid_decode_ip;
    uint32_t vid_addr_gfx_mode;
+   uint32_t stream_handle_base;
+   uint32_t stream_handle_counter;
 };
 
 uint32_t radv_find_memory_index(const struct radv_physical_device *pdevice, VkMemoryPropertyFlags flags);
diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index 6745f4acd59b..983a6b1fbf41 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -97,17 +97,12 @@ radv_vcn_sq_tail(struct radeon_cmdbuf *cs,
 }
 
 /* generate an stream handle */
-static unsigned si_vid_alloc_stream_handle()
+static
+unsigned si_vid_alloc_stream_handle(struct radv_physical_device *pdevice)
 {
-   static unsigned counter = 0;
-   unsigned stream_handle = 0;
-   unsigned pid = getpid();
-   int i;
+   unsigned stream_handle = pdevice->stream_handle_base;
 
-   for (i = 0; i < 32; ++i)
-      stream_handle |= ((pid >> i) & 1) << (31 - i);
-
-   stream_handle ^= ++counter;
+   stream_handle ^= ++pdevice->stream_handle_counter;
    return stream_handle;
 }
 
@@ -122,6 +117,11 @@ radv_init_physical_device_decoder(struct radv_physical_device *pdevice)
    else
       pdevice->vid_decode_ip = AMD_IP_VCN_DEC;
 
+   pdevice->stream_handle_counter = 0;
+   pdevice->stream_handle_base = 0;
+
+   pdevice->stream_handle_base = util_bitreverse(getpid());
+
    pdevice->vid_addr_gfx_mode = RDECODE_ARRAY_MODE_LINEAR;
 
    switch (pdevice->rad_info.family) {
@@ -297,7 +297,7 @@ radv_CreateVideoSessionKHR(VkDevice _device,
       return VK_ERROR_FEATURE_NOT_PRESENT;
    }
 
-   vid->stream_handle = si_vid_alloc_stream_handle();
+   vid->stream_handle = si_vid_alloc_stream_handle(device->physical_device);
    vid->dbg_frame_cnt = 0;
    vid->db_alignment = (device->physical_device->rad_info.family >= CHIP_RENOIR &&
                         vid->vk.max_coded.width > 32 &&
-- 
GitLab


From 4d93f3bdf69ee9e771fc9f7fbfaebb852b48da26 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 25 May 2023 11:33:33 +1000
Subject: [PATCH 4/6] radv/video: fix some whitespace.

this just removes some TABs.
---
 src/amd/vulkan/radv_video.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index 983a6b1fbf41..df8d8c2056d6 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -1505,10 +1505,10 @@ static bool ruvd_dec_message_decode(struct radv_device *device,
    switch (vid->vk.op) {
    case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: {
       msg->body.decode.codec.h264 = get_uvd_h264_msg(vid, params, frame_info,
-						     slice_offset,
-						     &msg->body.decode.width_in_samples,
-						     &msg->body.decode.height_in_samples,
-						     it_ptr);
+                                                     slice_offset,
+                                                     &msg->body.decode.width_in_samples,
+                                                     &msg->body.decode.height_in_samples,
+                                                     it_ptr);
       break;
    }
    case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: {
-- 
GitLab


From bc945f5930421c8f658d42921149911932a357cd Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 25 May 2023 14:04:40 +1000
Subject: [PATCH 5/6] radv/video: add debug flag to enable dpb image array on
 newer GPUs.

This is useful to test the paths on newer GPUs that work on older GPUs.
---
 src/amd/vulkan/radv_debug.h    |  1 +
 src/amd/vulkan/radv_instance.c |  1 +
 src/amd/vulkan/radv_video.c    | 18 ++++++++++++++----
 3 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_debug.h b/src/amd/vulkan/radv_debug.h
index 070e0cbeeddb..8598b0a6ae82 100644
--- a/src/amd/vulkan/radv_debug.h
+++ b/src/amd/vulkan/radv_debug.h
@@ -70,6 +70,7 @@ enum {
    RADV_DEBUG_SHADOW_REGS = 1ull << 39,
    RADV_DEBUG_EXTRA_MD = 1ull << 40,
    RADV_DEBUG_NO_GPL = 1ull << 41,
+   RADV_DEBUG_VIDEO_ARRAY_PATH = 1ull << 42,
 };
 
 enum {
diff --git a/src/amd/vulkan/radv_instance.c b/src/amd/vulkan/radv_instance.c
index f1e23ee1a6a1..1204a80151dc 100644
--- a/src/amd/vulkan/radv_instance.c
+++ b/src/amd/vulkan/radv_instance.c
@@ -76,6 +76,7 @@ static const struct debug_control radv_debug_options[] = {
    {"shadowregs", RADV_DEBUG_SHADOW_REGS},
    {"extra_md", RADV_DEBUG_EXTRA_MD},
    {"nogpl", RADV_DEBUG_NO_GPL},
+   {"videoarraypath", RADV_DEBUG_VIDEO_ARRAY_PATH},
    {NULL, 0}};
 
 const char *
diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index df8d8c2056d6..393d7f7eca12 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -32,6 +32,7 @@
 #include "ac_uvd_dec.h"
 
 #include "radv_cs.h"
+#include "radv_debug.h"
 
 #define NUM_H264_REFS 17
 #define NUM_H265_REFS 8
@@ -44,6 +45,15 @@
 /* Not 100% sure this isn't too much but works */
 #define VID_DEFAULT_ALIGNMENT 256
 
+static bool
+radv_enable_tier2(struct radv_physical_device *pdevice)
+{
+   if (pdevice->rad_info.family >= CHIP_NAVI21 &&
+       !(pdevice->instance->debug_flags & RADV_DEBUG_VIDEO_ARRAY_PATH))
+      return true;
+   return false;
+}
+
 static bool
 radv_vid_buffer_upload_alloc(struct radv_cmd_buffer *cmd_buffer, unsigned size,
                              unsigned *out_offset, void **ptr)
@@ -285,12 +295,12 @@ radv_CreateVideoSessionKHR(VkDevice _device,
    switch (vid->vk.op) {
    case VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR:
       vid->stream_type = RDECODE_CODEC_H264_PERF;
-      if (device->physical_device->rad_info.family >= CHIP_NAVI21)
+      if (radv_enable_tier2(device->physical_device))
          vid->dpb_type = DPB_DYNAMIC_TIER_2;
       break;
    case VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR:
       vid->stream_type = RDECODE_CODEC_H265;
-      if (device->physical_device->rad_info.family >= CHIP_NAVI21)
+      if (radv_enable_tier2(device->physical_device))
          vid->dpb_type = DPB_DYNAMIC_TIER_2;
       break;
    default:
@@ -406,7 +416,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice,
       pCapabilities->maxActiveReferencePictures = NUM_H264_REFS;
 
       /* for h264 on navi21+ separate dpb images should work */
-      if (pdevice->rad_info.family >= CHIP_NAVI21)
+      if (radv_enable_tier2(pdevice))
          pCapabilities->flags |= VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
       ext->fieldOffsetGranularity.x = 0;
       ext->fieldOffsetGranularity.y = 0;
@@ -421,7 +431,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice,
       pCapabilities->maxDpbSlots = NUM_H264_REFS;
       pCapabilities->maxActiveReferencePictures = NUM_H265_REFS;
       /* for h265 on navi21+ separate dpb images should work */
-      if (pdevice->rad_info.family >= CHIP_NAVI21)
+      if (radv_enable_tier2(pdevice))
          pCapabilities->flags |= VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR;
       ext->maxLevelIdc = 51;
       strcpy(pCapabilities->stdHeaderVersion.extensionName, VK_STD_VULKAN_VIDEO_CODEC_H265_DECODE_EXTENSION_NAME);
-- 
GitLab


From c0f06ddfb68df7f6ae940051f7a3b722bb296b55 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Fri, 26 May 2023 05:12:10 +1000
Subject: [PATCH 6/6] radv/video: fix physical device format property count.

This was returning bad values

Fixes: db62c38091a3 ("radv: add vcn h265 decode.")
---
 src/amd/vulkan/radv_video.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index 393d7f7eca12..9050ef13df90 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -476,7 +476,7 @@ radv_GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice,
        (VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR | VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR))
       return VK_ERROR_FORMAT_NOT_SUPPORTED;
 
-   *pVideoFormatPropertyCount = 1;
+   *pVideoFormatPropertyCount = 0;
 
    bool need_10bit = false;
    const struct VkVideoProfileListInfoKHR *prof_list = (struct VkVideoProfileListInfoKHR *)
-- 
GitLab

