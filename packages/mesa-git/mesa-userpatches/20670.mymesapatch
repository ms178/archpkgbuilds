From cd82ddacd5c36926168f88e5f6dbc2baa82192b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Tue, 10 Jan 2023 12:58:52 +0100
Subject: [PATCH 1/2] radv, aco: Add always_full_subgroups to compute shader
 info.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Allow the compiler to assume that the shader always has full subgroups,
meaning that the initial EXEC mask is -1 in all waves (all lanes enabled).
This assumption is incorrect for ray tracing and internal (meta) shaders
because they can use unaligned dispatch.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_shader_info.h    |  1 +
 src/amd/vulkan/radv_aco_shader_info.h |  1 +
 src/amd/vulkan/radv_pipeline.c        |  3 ++-
 src/amd/vulkan/radv_private.h         |  1 +
 src/amd/vulkan/radv_shader.h          |  1 +
 src/amd/vulkan/radv_shader_info.c     | 11 +++++++++++
 6 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index e292262261d8..7aa9ea6956cc 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -117,6 +117,7 @@ struct aco_shader_info {
    } ps;
    struct {
       uint8_t subgroup_size;
+      bool always_full_subgroups;
    } cs;
 
    uint32_t gfx9_gs_ring_lds_size;
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 8394b5ec71f6..8bb5634e5b57 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -87,6 +87,7 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info,
    ASSIGN_FIELD(ps.num_interp);
    ASSIGN_FIELD(ps.spi_ps_input);
    ASSIGN_FIELD(cs.subgroup_size);
+   ASSIGN_FIELD(cs.always_full_subgroups);
    aco_info->gfx9_gs_ring_lds_size = radv->gs_ring_info.lds_size;
 }
 
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 7ad689484d19..68a70a962a85 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2684,6 +2684,7 @@ radv_fill_shader_info(struct radv_pipeline *pipeline,
 
       radv_nir_shader_info_init(&stages[i].info);
       radv_nir_shader_info_pass(device, stages[i].nir, pipeline_layout, pipeline_key,
+                                pipeline->type,
                                 &stages[i].info);
    }
 
@@ -3211,7 +3212,7 @@ radv_pipeline_create_gs_copy_shader(struct radv_pipeline *pipeline,
    nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
 
    struct radv_shader_info info = {0};
-   radv_nir_shader_info_pass(device, nir, pipeline_layout, pipeline_key, &info);
+   radv_nir_shader_info_pass(device, nir, pipeline_layout, pipeline_key, pipeline->type, &info);
    info.wave_size = 64; /* Wave32 not supported. */
    info.workgroup_size = 64; /* HW VS: separate waves, no workgroups */
    info.so = gs_info->so;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index f545aba58583..8c945f13d3ab 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2813,6 +2813,7 @@ struct radv_shader_info;
 void radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *nir,
                                const struct radv_pipeline_layout *layout,
                                const struct radv_pipeline_key *pipeline_key,
+                               const enum radv_pipeline_type pipeline_type,
                                struct radv_shader_info *info);
 
 void radv_nir_shader_info_init(struct radv_shader_info *info);
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 50bc984bf001..3e12513e6277 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -361,6 +361,7 @@ struct radv_shader_info {
       bool uses_ray_launch_size;
       bool uses_dynamic_rt_callable_stack;
       bool uses_rt;
+      bool always_full_subgroups;
    } cs;
    struct {
       uint64_t tes_inputs_read;
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 6c7ccf24a8b5..b1449dffb784 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -683,6 +683,7 @@ void
 radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *nir,
                           const struct radv_pipeline_layout *layout,
                           const struct radv_pipeline_key *pipeline_key,
+                          const enum radv_pipeline_type pipeline_type,
                           struct radv_shader_info *info)
 {
    struct nir_function *func = (struct nir_function *)exec_list_get_head_const(&nir->functions);
@@ -823,6 +824,16 @@ radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *n
    case MESA_SHADER_TASK:
       info->workgroup_size =
          ac_compute_cs_workgroup_size(nir->info.workgroup_size, false, UINT32_MAX);
+
+      /* Allow the compiler to assume that the shader always has full subgroups,
+       * meaning that the initial EXEC mask is -1 in all waves (all lanes enabled).
+       * This assumption is incorrect for ray tracing and internal (meta) shaders
+       * because they can use unaligned dispatch.
+       */
+      info->cs.always_full_subgroups =
+         pipeline_type != RADV_PIPELINE_RAY_TRACING &&
+         !nir->info.internal &&
+         (info->workgroup_size % info->wave_size) == 0;
       break;
    case MESA_SHADER_MESH:
       /* Already computed in gather_shader_info_mesh(). */
-- 
GitLab


From e1cbc7aefdc8211706f3b52fb272a101e538e8e0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Tue, 10 Jan 2023 19:15:25 +0100
Subject: [PATCH 2/2] aco: Enable constant exec mask based optimization on
 compute shaders.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We know for sure exec is initially -1 when the shader always has full subgroups.

Fossil DB stats on Rembrandt (RDNA2):
Totals from 3884 (2.88% of 134913) affected shaders:
VGPRs: 155904 -> 155912 (+0.01%)
SpillSGPRs: 1673 -> 1685 (+0.72%); split: -1.67%, +2.39%
SpillVGPRs: 2284 -> 2290 (+0.26%); split: -0.35%, +0.61%
CodeSize: 16692012 -> 16678852 (-0.08%); split: -0.11%, +0.03%
Scratch: 217088 -> 218112 (+0.47%)
MaxWaves: 97646 -> 97644 (-0.00%)
Instrs: 3070211 -> 3066909 (-0.11%); split: -0.13%, +0.03%
Latency: 39743908 -> 39718677 (-0.06%); split: -0.13%, +0.07%
InvThroughput: 8826291 -> 8816933 (-0.11%); split: -0.25%, +0.15%
VClause: 74241 -> 74213 (-0.04%); split: -0.04%, +0.01%
SClause: 103495 -> 103616 (+0.12%); split: -0.02%, +0.14%
Copies: 264277 -> 266476 (+0.83%); split: -0.69%, +1.52%
Branches: 92033 -> 92035 (+0.00%); split: -0.02%, +0.02%
PreSGPRs: 156447 -> 150442 (-3.84%)

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index feffd5acd714..c270fca4bd0b 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -268,6 +268,12 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
          bld.copy(Definition(exec, bld.lm), start_exec);
       }
 
+      /* EXEC is automatically initialized by the HW for compute shaders.
+       * We know for sure exec is initially -1 when the shader always has full subgroups.
+       */
+      if (ctx.program->stage == compute_cs && ctx.program->info.cs.always_full_subgroups)
+         start_exec = Operand::c32_or_c64(-1u, bld.lm == s2);
+
       if (ctx.handle_wqm) {
          ctx.info[0].exec.emplace_back(start_exec, mask_type_global | mask_type_exact);
          /* if this block needs WQM, initialize already */
-- 
GitLab

