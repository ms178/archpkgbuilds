From 7f2c3570e62ebd6fbfa74c17188c443031a169b7 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 11 Jul 2022 15:27:37 -0400
Subject: [PATCH 1/2] mesa: track which sampler wrap params use GL_CLAMP

this adds a bitmask to sampler objects for tracking whether GL_CLAMP
is active
---
 src/mesa/main/mtypes.h     | 10 ++++++++++
 src/mesa/main/samplerobj.c | 21 +++++++++++++++------
 src/mesa/main/texparam.c   | 21 +++++++++++++++------
 3 files changed, 40 insertions(+), 12 deletions(-)

diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 82fdcace95bd..a7682f4538b0 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -876,6 +876,14 @@ struct gl_texture_object_attrib
    GLubyte NumLevels;          /**< GL_ARB_texture_view */
 };
 
+
+typedef enum
+{
+   WRAP_S = (1<<0),
+   WRAP_T = (1<<1),
+   WRAP_R = (1<<2),
+} gl_sampler_wrap;
+
 /**
  * Sampler object state.  These objects are new with GL_ARB_sampler_objects
  * and OpenGL 3.3.  Legacy texture objects also contain a sampler object.
@@ -888,6 +896,8 @@ struct gl_sampler_object
 
    struct gl_sampler_attrib Attrib;  /**< State saved by glPushAttrib */
 
+   uint8_t glclamp_mask; /**< mask of GL_CLAMP wraps active */
+
    /** GL_ARB_bindless_texture */
    bool HandleAllocated;
    struct util_dynarray Handles;
diff --git a/src/mesa/main/samplerobj.c b/src/mesa/main/samplerobj.c
index bb86b0f4d671..731eac842091 100644
--- a/src/mesa/main/samplerobj.c
+++ b/src/mesa/main/samplerobj.c
@@ -538,6 +538,18 @@ is_wrap_gl_clamp(GLint param)
    return param == GL_CLAMP || param == GL_MIRROR_CLAMP_EXT;
 }
 
+ALWAYS_INLINE static void
+update_gl_clamp(struct gl_context *ctx, struct gl_sampler_object *samp, bool cur_state, bool new_state, gl_sampler_wrap wrap)
+{
+   if (cur_state == new_state)
+      return;
+   ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+   if (new_state)
+      samp->glclamp_mask |= wrap;
+   else
+      samp->glclamp_mask &= ~wrap;
+}
+
 static GLuint
 set_sampler_wrap_s(struct gl_context *ctx, struct gl_sampler_object *samp,
                    GLint param)
@@ -546,8 +558,7 @@ set_sampler_wrap_s(struct gl_context *ctx, struct gl_sampler_object *samp,
       return GL_FALSE;
    if (validate_texture_wrap_mode(ctx, param)) {
       flush(ctx);
-      if (is_wrap_gl_clamp(samp->Attrib.WrapS) != is_wrap_gl_clamp(param))
-         ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+      update_gl_clamp(ctx, samp, is_wrap_gl_clamp(samp->Attrib.WrapS), is_wrap_gl_clamp(param), WRAP_S);
       samp->Attrib.WrapS = param;
       samp->Attrib.state.wrap_s = wrap_to_gallium(param);
       _mesa_lower_gl_clamp(ctx, samp);
@@ -565,8 +576,7 @@ set_sampler_wrap_t(struct gl_context *ctx, struct gl_sampler_object *samp,
       return GL_FALSE;
    if (validate_texture_wrap_mode(ctx, param)) {
       flush(ctx);
-      if (is_wrap_gl_clamp(samp->Attrib.WrapT) != is_wrap_gl_clamp(param))
-         ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+      update_gl_clamp(ctx, samp, is_wrap_gl_clamp(samp->Attrib.WrapT), is_wrap_gl_clamp(param), WRAP_T);
       samp->Attrib.WrapT = param;
       samp->Attrib.state.wrap_t = wrap_to_gallium(param);
       _mesa_lower_gl_clamp(ctx, samp);
@@ -584,8 +594,7 @@ set_sampler_wrap_r(struct gl_context *ctx, struct gl_sampler_object *samp,
       return GL_FALSE;
    if (validate_texture_wrap_mode(ctx, param)) {
       flush(ctx);
-      if (is_wrap_gl_clamp(samp->Attrib.WrapR) != is_wrap_gl_clamp(param))
-         ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+      update_gl_clamp(ctx, samp, is_wrap_gl_clamp(samp->Attrib.WrapR), is_wrap_gl_clamp(param), WRAP_R);
       samp->Attrib.WrapR = param;
       samp->Attrib.state.wrap_r = wrap_to_gallium(param);
       _mesa_lower_gl_clamp(ctx, samp);
diff --git a/src/mesa/main/texparam.c b/src/mesa/main/texparam.c
index c2936cbbe083..c77992ba6c44 100644
--- a/src/mesa/main/texparam.c
+++ b/src/mesa/main/texparam.c
@@ -254,6 +254,18 @@ is_wrap_gl_clamp(GLint param)
    return param == GL_CLAMP || param == GL_MIRROR_CLAMP_EXT;
 }
 
+ALWAYS_INLINE static void
+update_gl_clamp(struct gl_context *ctx, struct gl_texture_object *texObj, bool cur_state, bool new_state, gl_sampler_wrap wrap)
+{
+   if (cur_state == new_state)
+      return;
+   ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+   if (new_state)
+      texObj->Sampler.glclamp_mask |= wrap;
+   else
+      texObj->Sampler.glclamp_mask &= ~wrap;
+}
+
 /**
  * Set an integer-valued texture parameter
  * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
@@ -340,8 +352,7 @@ set_tex_parameteri(struct gl_context *ctx,
          return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
          flush(ctx);
-         if (is_wrap_gl_clamp(texObj->Sampler.Attrib.WrapS) != is_wrap_gl_clamp(params[0]))
-            ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+         update_gl_clamp(ctx, texObj, is_wrap_gl_clamp(texObj->Sampler.Attrib.WrapS), is_wrap_gl_clamp(params[0]), WRAP_S);
          texObj->Sampler.Attrib.WrapS = params[0];
          texObj->Sampler.Attrib.state.wrap_s = wrap_to_gallium(params[0]);
          _mesa_lower_gl_clamp(ctx, &texObj->Sampler);
@@ -357,8 +368,7 @@ set_tex_parameteri(struct gl_context *ctx,
          return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
          flush(ctx);
-         if (is_wrap_gl_clamp(texObj->Sampler.Attrib.WrapT) != is_wrap_gl_clamp(params[0]))
-            ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+         update_gl_clamp(ctx, texObj, is_wrap_gl_clamp(texObj->Sampler.Attrib.WrapT), is_wrap_gl_clamp(params[0]), WRAP_T);
          texObj->Sampler.Attrib.WrapT = params[0];
          texObj->Sampler.Attrib.state.wrap_t = wrap_to_gallium(params[0]);
          _mesa_lower_gl_clamp(ctx, &texObj->Sampler);
@@ -374,8 +384,7 @@ set_tex_parameteri(struct gl_context *ctx,
          return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
          flush(ctx);
-         if (is_wrap_gl_clamp(texObj->Sampler.Attrib.WrapR) != is_wrap_gl_clamp(params[0]))
-            ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+         update_gl_clamp(ctx, texObj, is_wrap_gl_clamp(texObj->Sampler.Attrib.WrapR), is_wrap_gl_clamp(params[0]), WRAP_R);
          texObj->Sampler.Attrib.WrapR = params[0];
          texObj->Sampler.Attrib.state.wrap_r = wrap_to_gallium(params[0]);
          _mesa_lower_gl_clamp(ctx, &texObj->Sampler);
-- 
GitLab


From 4bfa03f04c9d192504377d154712a5cebd497b18 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 11 Jul 2022 08:44:00 -0400
Subject: [PATCH 2/2] mesa: update GL_CLAMP emulation when binding/unbinding
 textures

binding/unbinding a texture affects the previously specified parameters,
so ensure the driver flag for clamp emulation is also set to perform
updates as needed

Fixes: e8f71f6ac48 ("mesa/st: add PIPE_CAP_GL_CLAMP")
---
 src/mesa/main/texobj.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index 266384ad18e6..db2fb9f7b6e6 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -1573,6 +1573,12 @@ _mesa_tex_target_to_index(const struct gl_context *ctx, GLenum target)
 }
 
 
+static inline GLboolean
+is_wrap_gl_clamp(GLint param)
+{
+   return param == GL_CLAMP || param == GL_MIRROR_CLAMP_EXT;
+}
+
 /**
  * Do actual texture binding.  All error checking should have been done prior
  * to calling this function.  Note that the texture target (1D, 2D, etc) is
@@ -1616,6 +1622,14 @@ bind_texture_object(struct gl_context *ctx, unsigned unit,
     */
    FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT, GL_TEXTURE_BIT);
 
+   /* if the previously bound texture uses GL_CLAMP, flag the driver here
+    * to ensure any emulation is disabled
+    */
+   if (texUnit->CurrentTex[targetIndex] &&
+       texUnit->CurrentTex[targetIndex]->Sampler.glclamp_mask !=
+       texObj->Sampler.glclamp_mask)
+      ctx->NewDriverState |= ctx->DriverFlags.NewSamplersWithClamp;
+
    /* If the refcount on the previously bound texture is decremented to
     * zero, it'll be deleted here.
     */
-- 
GitLab

