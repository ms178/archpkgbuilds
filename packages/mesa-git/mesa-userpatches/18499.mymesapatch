From 193610f886d8c00630d0584cbcd94185b0eaff6d Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 13 Sep 2022 13:08:59 -0400
Subject: [PATCH 01/20] radv: prefetch graphics pipeline pointers during draw

these are guaranteed to be accessed, and not having them already loaded
at these exact spots hurts perf in some cases
---
 src/amd/vulkan/radv_cmd_buffer.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d03265a9783b..8feb31ea2853 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7342,6 +7342,13 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
    if (cmd_buffer->state.flush_bits &
        (RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_DB |
         RADV_CMD_FLAG_PS_PARTIAL_FLUSH | RADV_CMD_FLAG_CS_PARTIAL_FLUSH)) {
+
+      /* prefetch pipeline pointers since they'll be used in non-inlined functions */
+      if (pipeline_is_dirty) {
+         __builtin_prefetch(&cmd_buffer->state.graphics_pipeline);
+         __builtin_prefetch(&cmd_buffer->state.emitted_graphics_pipeline, 1, 3);
+      }
+
       /* If we have to wait for idle, set all states first, so that
        * all SET packets are processed in parallel with previous draw
        * calls. Then upload descriptors, set shader pointers, and
@@ -7367,6 +7374,12 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
          radv_emit_prefetch_L2(cmd_buffer, cmd_buffer->state.graphics_pipeline, true);
       }
 
+      /* prefetch pipeline pointers since they'll be used in non-inlined functions */
+      if (pipeline_is_dirty) {
+         __builtin_prefetch(&cmd_buffer->state.graphics_pipeline);
+         __builtin_prefetch(&cmd_buffer->state.emitted_graphics_pipeline, 1, 3);
+      }
+
       radv_upload_graphics_shader_descriptors(cmd_buffer, pipeline_is_dirty);
 
       radv_emit_all_graphics_states(cmd_buffer, info, pipeline_is_dirty);
-- 
GitLab


From d673204329feeee5997827777b83a57070571182 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 15:13:28 -0400
Subject: [PATCH 02/20] radv: remove some pipeline comparisons from draw
 emission

these help poorly-optimized apps and hurt well-optimized ones
---
 src/amd/vulkan/radv_cmd_buffer.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 8feb31ea2853..e58eb18dc3d8 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1425,9 +1425,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    const struct radv_device *device = cmd_buffer->device;
 
-   if (cmd_buffer->state.emitted_graphics_pipeline == pipeline)
-      return;
-
    radv_update_multisample_state(cmd_buffer, pipeline);
    radv_update_binning_state(cmd_buffer, pipeline);
 
@@ -7313,8 +7310,7 @@ ALWAYS_INLINE static bool
 radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info *info, uint32_t drawCount)
 {
    const bool has_prefetch = cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7;
-   const bool pipeline_is_dirty = (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE) &&
-                                  cmd_buffer->state.graphics_pipeline != cmd_buffer->state.emitted_graphics_pipeline;
+   const bool pipeline_is_dirty = cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE;
 
    ASSERTED const unsigned cdw_max =
       radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4096 + 128 * (drawCount - 1));
-- 
GitLab


From 879428a94edf10c120c27e6365c6696038ce37eb Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 15:27:19 -0400
Subject: [PATCH 03/20] radv: avoid another pipeline comparison for emitting
 framebuffer state

this isn't technically the same check, but for a well-optimized app
it should result in no change except for one fewer memcmp
---
 src/amd/vulkan/radv_cmd_buffer.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index e58eb18dc3d8..41eaacded7bc 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7202,8 +7202,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    const struct radv_device *device = cmd_buffer->device;
    bool late_scissor_emission;
 
-   if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER) ||
-       cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
+   if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_FRAMEBUFFER))
       radv_emit_rbplus_state(cmd_buffer);
 
    if (cmd_buffer->device->physical_device->use_ngg_culling &&
-- 
GitLab


From fd0d19c50ba3d5eb95b29c84473788a8f0be65fe Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:04:57 -0400
Subject: [PATCH 04/20] radv: eliminate more null checks during pipeline
 emission

this avoids unnecessary null checks when updating flag bits, but it
requires moving the flag-setting to location where emitted_graphics_pipeline
cannot be null
---
 src/amd/vulkan/radv_cmd_buffer.c | 107 ++++++++++++++++---------------
 1 file changed, 56 insertions(+), 51 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 41eaacded7bc..7785f9eab682 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1432,46 +1432,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       MAX2(cmd_buffer->scratch_size_per_wave_needed, pipeline->base.scratch_bytes_per_wave);
    cmd_buffer->scratch_waves_wanted = MAX2(cmd_buffer->scratch_waves_wanted, pipeline->base.max_waves);
 
-   if (!cmd_buffer->state.emitted_graphics_pipeline)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS |
-                                 RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_STENCIL_OP |
-                                 RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
-       cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       radv_rast_prim_is_points_or_lines(cmd_buffer->state.emitted_graphics_pipeline->rast_prim) != radv_rast_prim_is_points_or_lines(pipeline->rast_prim))
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_GUARDBAND;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->pa_su_sc_mode_cntl != pipeline->pa_su_sc_mode_cntl)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
-                                 RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->pa_cl_clip_cntl != pipeline->pa_cl_clip_cntl)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->cb_color_control != pipeline->cb_color_control)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->cb_target_mask != pipeline->cb_target_mask)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
-
    radeon_emit_array(cmd_buffer->cs, pipeline->base.cs.buf, pipeline->base.cs.cdw);
 
    if (pipeline->has_ngg_culling &&
@@ -4650,7 +4610,25 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
       radv_cmd_buffer_trace_emit(cmd_buffer);
 
    radv_describe_begin_cmd_buffer(cmd_buffer);
-
+   cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS |
+                              RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_STENCIL_OP |
+                              RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
+                              RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS |
+                              RADV_CMD_DIRTY_GUARDBAND |
+                              RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+                              RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
+                              RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP |
+                              RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
    cmd_buffer->status = RADV_CMD_BUFFER_STATUS_RECORDING;
 
    return result;
@@ -5079,6 +5057,31 @@ radv_mark_descriptor_sets_dirty(struct radv_cmd_buffer *cmd_buffer, VkPipelineBi
    descriptors_state->dirty |= descriptors_state->valid;
 }
 
+static void
+radv_check_dynamic_state(struct radv_cmd_buffer *cmd_buffer, struct radv_graphics_pipeline *pipeline)
+{
+   if (cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
+       cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
+
+   if (radv_rast_prim_is_points_or_lines(cmd_buffer->state.emitted_graphics_pipeline->rast_prim) != radv_rast_prim_is_points_or_lines(pipeline->rast_prim))
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_GUARDBAND;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->pa_su_sc_mode_cntl != pipeline->pa_su_sc_mode_cntl)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+                                 RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
+                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->pa_cl_clip_cntl != pipeline->pa_cl_clip_cntl)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->cb_color_control != pipeline->cb_color_control)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->cb_target_mask != pipeline->cb_target_mask)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                      VkPipeline _pipeline)
@@ -5150,16 +5153,18 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
       /* Prefetch all pipeline shaders at first draw time. */
       cmd_buffer->state.prefetch_L2_mask |= RADV_PREFETCH_SHADERS;
 
-      if (cmd_buffer->device->physical_device->rad_info.has_vgt_flush_ngg_legacy_bug &&
-          cmd_buffer->state.emitted_graphics_pipeline &&
-          cmd_buffer->state.emitted_graphics_pipeline->is_ngg &&
-          !cmd_buffer->state.graphics_pipeline->is_ngg) {
-         /* Transitioning from NGG to legacy GS requires
-          * VGT_FLUSH on GFX10 and Navi21. VGT_FLUSH
-          * is also emitted at the beginning of IBs when legacy
-          * GS ring pointers are set.
-          */
-         cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
+      if (cmd_buffer->state.emitted_graphics_pipeline) {
+         radv_check_dynamic_state(cmd_buffer, graphics_pipeline);
+         if (cmd_buffer->device->physical_device->rad_info.has_vgt_flush_ngg_legacy_bug &&
+             cmd_buffer->state.emitted_graphics_pipeline->is_ngg &&
+             !cmd_buffer->state.graphics_pipeline->is_ngg) {
+            /* Transitioning from NGG to legacy GS requires
+             * VGT_FLUSH on GFX10 and Navi21. VGT_FLUSH
+             * is also emitted at the beginning of IBs when legacy
+             * GS ring pointers are set.
+             */
+            cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
+         }
       }
 
       if (radv_pipeline_has_stage(graphics_pipeline, MESA_SHADER_TESS_CTRL) &&
-- 
GitLab


From 423a1800fb1720cbebd5b3b77f5cecc04eb804ee Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:06:15 -0400
Subject: [PATCH 05/20] radv: store pointer to sgprs for last vertex stage

---
 src/amd/vulkan/radv_pipeline.c | 1 +
 src/amd/vulkan/radv_private.h  | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 5ae0be499a2e..60b20b5fb9fa 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -6084,6 +6084,7 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       pipeline->base.shaders[pipeline->last_vgt_api_stage]->info.force_vrs_per_vertex;
    pipeline->uses_user_sample_locations = state.ms && state.ms->sample_locations_enable;
    pipeline->rast_prim = vgt_gs_out_prim_type;
+   pipeline->last_vgt_api_stage_locs = pipeline->base.shaders[pipeline->last_vgt_api_stage]->info.user_sgprs_locs.shader_data;
 
    pipeline->base.push_constant_size = pipeline_layout.push_constant_size;
    pipeline->base.dynamic_offset_count = pipeline_layout.dynamic_offset_count;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index e1869a1dc715..6b72ee2b1fcb 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2022,6 +2022,7 @@ struct radv_graphics_pipeline {
 
    /* Last pre-PS API stage */
    gl_shader_stage last_vgt_api_stage;
+   struct radv_userdata_info *last_vgt_api_stage_locs;
 
    /* Used for rbplus */
    uint32_t col_format;
-- 
GitLab


From cc33f2bc51b82dad0589500d33c9702b70588af2 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:14:45 -0400
Subject: [PATCH 06/20] radv: use direct access to last_vgt_api_stage_locs for
 sgpr emission

radv_lookup_user_sgpr is heavy, stop using it
---
 src/amd/vulkan/radv_cmd_buffer.c | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 7785f9eab682..9d8e214c62c3 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3851,11 +3851,10 @@ radv_flush_ngg_query_state(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    const unsigned stage = pipeline->last_vgt_api_stage;
-   struct radv_userdata_info *loc;
+   const struct radv_userdata_info *loc = &pipeline->last_vgt_api_stage_locs[AC_UD_NGG_QUERY_STATE];
    uint32_t ngg_query_state = 0;
    uint32_t base_reg;
 
-   loc = radv_lookup_user_sgpr(&pipeline->base, stage, AC_UD_NGG_QUERY_STATE);
    if (loc->sgpr_idx == -1)
       return;
 
@@ -3882,7 +3881,7 @@ radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    enum amd_gfx_level gfx_level = pipeline->base.device->physical_device->rad_info.gfx_level;
    const unsigned stage = pipeline->last_vgt_api_stage;
-   struct radv_userdata_info *loc;
+   struct radv_userdata_info *loc = &pipeline->last_vgt_api_stage_locs[AC_UD_FORCE_VRS_RATES];
    uint32_t vrs_rates = 0;
    uint32_t base_reg;
 
@@ -3892,7 +3891,6 @@ radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
       return;
    }
 
-   loc = radv_lookup_user_sgpr(&pipeline->base, stage, AC_UD_FORCE_VRS_RATES);
    assert(loc->sgpr_idx != -1);
 
    base_reg = pipeline->base.user_data_0[stage];
@@ -6402,14 +6400,13 @@ radv_cs_emit_dispatch_taskmesh_indirect_multi_ace_packet(struct radv_cmd_buffer
 ALWAYS_INLINE static void
 radv_cs_emit_dispatch_taskmesh_gfx_packet(struct radv_cmd_buffer *cmd_buffer)
 {
-   struct radv_pipeline *pipeline = &cmd_buffer->state.graphics_pipeline->base;
+   struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    bool predicating = cmd_buffer->state.predicating;
 
-   struct radv_userdata_info *ring_entry_loc =
-      radv_lookup_user_sgpr(pipeline, MESA_SHADER_MESH, AC_UD_TASK_RING_ENTRY);
+   struct radv_userdata_info *ring_entry_loc = &pipeline->last_vgt_api_stage_locs[AC_UD_TASK_RING_ENTRY];
 
-   assert(ring_entry_loc && ring_entry_loc->sgpr_idx != -1);
+   assert(ring_entry_loc->sgpr_idx != -1);
 
    uint32_t base_reg = cmd_buffer->state.graphics_pipeline->vtx_base_sgpr;
    uint32_t xyz_dim_reg = ((base_reg + 4) - SI_SH_REG_OFFSET) >> 2;
@@ -7124,7 +7121,7 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
 
    /* Find the user SGPR. */
    const uint32_t base_reg = pipeline->base.user_data_0[stage];
-   const int8_t nggc_sgpr_idx = v->info.user_sgprs_locs.shader_data[AC_UD_NGG_CULLING_SETTINGS].sgpr_idx;
+   const int8_t nggc_sgpr_idx = pipeline->last_vgt_api_stage_locs[AC_UD_NGG_CULLING_SETTINGS].sgpr_idx;
    assert(!nggc_supported || nggc_sgpr_idx != -1);
 
    /* Get viewport transform. */
@@ -7157,7 +7154,7 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
       }
 
       uint32_t vp_reg_values[4] = {fui(vp_scale[0]), fui(vp_scale[1]), fui(vp_translate[0]), fui(vp_translate[1])};
-      const int8_t vp_sgpr_idx = v->info.user_sgprs_locs.shader_data[AC_UD_NGG_VIEWPORT].sgpr_idx;
+      const int8_t vp_sgpr_idx = pipeline->last_vgt_api_stage_locs[AC_UD_NGG_VIEWPORT].sgpr_idx;
       assert(vp_sgpr_idx != -1);
       radeon_set_sh_reg_seq(cmd_buffer->cs, base_reg + vp_sgpr_idx * 4, 4);
       radeon_emit_array(cmd_buffer->cs, vp_reg_values, 4);
-- 
GitLab


From 19e1553a24b0b676585482de68725d366e36fee9 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:24:56 -0400
Subject: [PATCH 07/20] radv: make ngg query emission a dirty flag

if this state doesn't change, it doesn't need to be emitted

+5% draw perf
---
 src/amd/vulkan/radv_cmd_buffer.c | 12 ++++++++++--
 src/amd/vulkan/radv_meta.c       |  4 ++++
 src/amd/vulkan/radv_private.h    |  1 +
 src/amd/vulkan/radv_query.c      |  8 ++++++++
 4 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 9d8e214c62c3..33c588ddc358 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3929,7 +3929,10 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer, bool
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_MESH_BIT_EXT;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
    radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_ngg_query_state(cmd_buffer);
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY) {
+      radv_flush_ngg_query_state(cmd_buffer);
+      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_NGG_QUERY;
+   }
    radv_flush_force_vrs_state(cmd_buffer);
 }
 
@@ -4600,6 +4603,9 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
             render->ds_att.format = inheritance_info->stencilAttachmentFormat;
       }
 
+      if (!!(pBeginInfo->pInheritanceInfo->pipelineStatistics & VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT) !=
+          !!cmd_buffer->state.active_pipeline_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       cmd_buffer->state.inherited_pipeline_statistics =
          pBeginInfo->pInheritanceInfo->pipelineStatistics;
    }
@@ -4626,7 +4632,8 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
                               RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
                               RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
                               RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP |
-                              RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
+                              RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE |
+                              RADV_CMD_DIRTY_NGG_QUERY;
    cmd_buffer->status = RADV_CMD_BUFFER_STATUS_RECORDING;
 
    return result;
@@ -5058,6 +5065,7 @@ radv_mark_descriptor_sets_dirty(struct radv_cmd_buffer *cmd_buffer, VkPipelineBi
 static void
 radv_check_dynamic_state(struct radv_cmd_buffer *cmd_buffer, struct radv_graphics_pipeline *pipeline)
 {
+   cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
    if (cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
        cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
diff --git a/src/amd/vulkan/radv_meta.c b/src/amd/vulkan/radv_meta.c
index 13dbeaabdb06..42d7964e53c4 100644
--- a/src/amd/vulkan/radv_meta.c
+++ b/src/amd/vulkan/radv_meta.c
@@ -57,6 +57,8 @@ radv_suspend_queries(struct radv_meta_saved_state *state, struct radv_cmd_buffer
        * increment the counters via GDS.
        */
       state->active_pipeline_gds_queries = cmd_buffer->state.active_pipeline_gds_queries;
+      if (cmd_buffer->state.active_pipeline_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       cmd_buffer->state.active_pipeline_gds_queries = 0;
    }
 }
@@ -81,6 +83,8 @@ radv_resume_queries(const struct radv_meta_saved_state *state, struct radv_cmd_b
       radv_emit_streamout_enable(cmd_buffer);
 
       /* Restore the number of active GDS queries to resume counting. */
+      if (!!cmd_buffer->state.active_pipeline_gds_queries != !!state->active_pipeline_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       cmd_buffer->state.active_pipeline_gds_queries = state->active_pipeline_gds_queries;
    }
 }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 6b72ee2b1fcb..af34d57191d9 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1140,6 +1140,7 @@ enum radv_cmd_dirty_bits {
    RADV_CMD_DIRTY_VERTEX_BUFFER = 1ull << 33,
    RADV_CMD_DIRTY_STREAMOUT_BUFFER = 1ull << 34,
    RADV_CMD_DIRTY_GUARDBAND = 1ull << 35,
+   RADV_CMD_DIRTY_NGG_QUERY = 1ull << 36,
 };
 
 enum radv_cmd_flush_bits {
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index b875f4e5d36d..e32bd4dac3c3 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1816,6 +1816,8 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
          /* Record that the command buffer needs GDS. */
          cmd_buffer->gds_needed = true;
 
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
          cmd_buffer->state.active_pipeline_gds_queries++;
       }
       break;
@@ -1842,6 +1844,8 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
          /* Record that the command buffer needs GDS. */
          cmd_buffer->gds_needed = true;
 
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
          cmd_buffer->state.active_pipeline_gds_queries++;
       }
       break;
@@ -1910,6 +1914,8 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
          gfx10_copy_gds_query(cmd_buffer, 0, va); /* NGG GS */
 
          cmd_buffer->state.active_pipeline_gds_queries--;
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       }
       break;
    case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
@@ -1933,6 +1939,8 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
          gfx10_copy_gds_query(cmd_buffer, 4, va + 56); /* NGG VS/TES */
 
          cmd_buffer->state.active_pipeline_gds_queries--;
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       }
       break;
    }
-- 
GitLab


From 6febf8f6fad9afbf451f0ef5a7bf07946c41fd5a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 13:55:44 -0400
Subject: [PATCH 08/20] radv: hoist indirect check up from
 radv_emit_index_buffer()

avoid calling the function entirely when possible, as info->indirect
should be possible to inline as a nullable stack value
---
 src/amd/vulkan/radv_cmd_buffer.c | 13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 33c588ddc358..4198cf58279b 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2781,7 +2781,7 @@ radv_emit_guardband_state(struct radv_cmd_buffer *cmd_buffer)
 }
 
 static void
-radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
+radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    struct radv_cmd_state *state = &cmd_buffer->state;
@@ -2791,11 +2791,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
    if (state->index_type < 0)
       return;
 
-   /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-    * the index_va and max_index_count already. */
-   if (!indirect)
-      return;
-
    if (state->max_index_count ||
        !cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug) {
       radeon_emit(cs, PKT3(PKT3_INDEX_BASE, 1, 0));
@@ -7234,8 +7229,10 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       radv_emit_guardband_state(cmd_buffer);
 
    if (info->indexed) {
-      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
-         radv_emit_index_buffer(cmd_buffer, info->indirect);
+      /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+       * the index_va and max_index_count already. */
+      if (info->indirect && cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
+         radv_emit_index_buffer(cmd_buffer);
    } else {
       /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
        * so the state must be re-emitted before the next indexed
-- 
GitLab


From 91c7b526473c29498af9bd978c2d9f7c8b4fa0e6 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 14:13:10 -0400
Subject: [PATCH 09/20] radv: ALWAYS_INLINE radv_after_draw

---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 4198cf58279b..cab961856ddd 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7465,7 +7465,7 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    return true;
 }
 
-static void
+ALWAYS_INLINE static void
 radv_after_draw(struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radeon_info *rad_info = &cmd_buffer->device->physical_device->rad_info;
-- 
GitLab


From 5d4dc7aa5df36cb4a8b15dfb1b4791d519bcb122 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 13 Sep 2022 10:14:58 -0400
Subject: [PATCH 10/20] radv: flag missing dynamic states on pipeline bind

ensure that these are always emitted
---
 src/amd/vulkan/radv_cmd_buffer.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index cab961856ddd..8ef3f7e37d8d 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5061,6 +5061,7 @@ static void
 radv_check_dynamic_state(struct radv_cmd_buffer *cmd_buffer, struct radv_graphics_pipeline *pipeline)
 {
    cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
+   cmd_buffer->state.dirty |= pipeline->dynamic_states & ~cmd_buffer->state.emitted_graphics_pipeline->dynamic_states;
    if (cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
        cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
-- 
GitLab


From c909e189f2b7e0af231a2dc21e0e61b360ac6da7 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:01:37 -0400
Subject: [PATCH 11/20] radv: unset all dynamic state flags after
 radv_cmd_buffer_flush_dynamic_state()

it's irrelevant whether the states are actually updated here, as unused states
will be flagged again when a new pipeline is bound
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 8ef3f7e37d8d..efef8a0d3571 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3287,7 +3287,7 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS)
       radv_emit_patch_control_points(cmd_buffer);
 
-   cmd_buffer->state.dirty &= ~states;
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
 }
 
 static void
-- 
GitLab


From bbed5a074e0b553033f390898d72f5d2b3730b42 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:04:12 -0400
Subject: [PATCH 12/20] radv: rework VGT_INDEX_TYPE flagging on draw -> indexed
 draw cmdbuf

previously, this mechanic would force RADV_CMD_DIRTY_INDEX_BUFFER on
every non-indexed draw, ensuring that non-indexed draws always had at
least 1 bit set in cmd_buffer->state.dirty

instead, track whether the previous draw was indexed and set the flag
appropriately if it will be consumed

this enables successive non-indexed draws to execute without setting any
dirty flags
---
 src/amd/vulkan/radv_cmd_buffer.c | 36 +++++++++++++++-----------------
 src/amd/vulkan/radv_private.h    |  1 +
 2 files changed, 18 insertions(+), 19 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index efef8a0d3571..e31919aec74c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2800,8 +2800,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer)
       radeon_emit(cs, PKT3(PKT3_INDEX_BUFFER_SIZE, 0, 0));
       radeon_emit(cs, state->max_index_count);
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
 }
 
 void
@@ -5837,6 +5835,7 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
       primary->state.last_sx_ps_downconvert = secondary->state.last_sx_ps_downconvert;
       primary->state.last_sx_blend_opt_epsilon = secondary->state.last_sx_blend_opt_epsilon;
       primary->state.last_sx_blend_opt_control = secondary->state.last_sx_blend_opt_control;
+      primary->state.last_draw_indexed = secondary->state.last_draw_indexed;
 
       if (secondary->state.last_index_type != -1) {
          primary->state.last_index_type = secondary->state.last_index_type;
@@ -7218,31 +7217,19 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
       radv_emit_graphics_pipeline(cmd_buffer);
 
-   /* This should be before the cmd_buffer->state.dirty is cleared
-    * (excluding RADV_CMD_DIRTY_PIPELINE) and after
-    * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
-   late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
-
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
       radv_emit_framebuffer_state(cmd_buffer);
 
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
       radv_emit_guardband_state(cmd_buffer);
 
-   if (info->indexed) {
-      /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-       * the index_va and max_index_count already. */
-      if (info->indirect && cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER) {
+      if (info->indexed && info->indirect) {
+         /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+          * the index_va and max_index_count already. */
          radv_emit_index_buffer(cmd_buffer);
-   } else {
-      /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
-       * so the state must be re-emitted before the next indexed
-       * draw.
-       */
-      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
-         cmd_buffer->state.last_index_type = -1;
-         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_INDEX_BUFFER;
       }
+      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
    }
 
    if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
@@ -7333,8 +7320,19 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
       /* Handle count == 0. */
       if (unlikely(!info->count && !info->strmout_buffer))
          return false;
+   } else if (info->indexed && !cmd_buffer->state.last_draw_indexed) {
+      /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
+       * so the state must be re-emitted before the next indexed
+       * draw.
+       */
+      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
+         cmd_buffer->state.last_index_type = -1;
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_INDEX_BUFFER;
+      }
    }
 
+   cmd_buffer->state.last_draw_indexed = info->indexed;
+
    /* Need to apply this workaround early as it can set flush flags. */
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
       radv_emit_fb_mip_change_flush(cmd_buffer);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index af34d57191d9..ff42d048bba5 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1457,6 +1457,7 @@ struct radv_cmd_state {
    uint64_t vb_va;
 
    bool predicating;
+   bool last_draw_indexed;
    uint64_t dirty;
 
    uint32_t prefetch_L2_mask;
-- 
GitLab


From ec9f1ab89f4f403b5bb65db7870fb50fdb319e99 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:07:05 -0400
Subject: [PATCH 13/20] radv: group flag checking in
 radv_emit_all_graphics_states()

this improves branch selection for successive draws in optimized builds
---
 src/amd/vulkan/radv_cmd_buffer.c | 144 ++++++++++++++++---------------
 1 file changed, 75 insertions(+), 69 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index e31919aec74c..781049a059a7 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7207,91 +7207,97 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    const struct radv_device *device = cmd_buffer->device;
    bool late_scissor_emission;
 
-   if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_FRAMEBUFFER))
-      radv_emit_rbplus_state(cmd_buffer);
+   /* This should be before the cmd_buffer->state.dirty is cleared
+    * (excluding RADV_CMD_DIRTY_PIPELINE) and after
+    * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
+   late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
 
    if (cmd_buffer->device->physical_device->use_ngg_culling &&
        cmd_buffer->state.graphics_pipeline->is_ngg)
       radv_emit_ngg_culling_state(cmd_buffer, info);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
-      radv_emit_graphics_pipeline(cmd_buffer);
+   if (cmd_buffer->state.dirty) {
+      if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_FRAMEBUFFER))
+         radv_emit_rbplus_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
-      radv_emit_framebuffer_state(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
+         radv_emit_graphics_pipeline(cmd_buffer);
+
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
+         radv_emit_framebuffer_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
-      radv_emit_guardband_state(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
+         radv_emit_guardband_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER) {
-      if (info->indexed && info->indirect) {
-         /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-          * the index_va and max_index_count already. */
-         radv_emit_index_buffer(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER) {
+         if (info->indexed && info->indirect) {
+            /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+             * the index_va and max_index_count already. */
+            radv_emit_index_buffer(cmd_buffer);
+         }
+         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
       }
-      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
-   }
 
-   if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
-      struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+      if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
+         struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+         uint64_t dynamic_states =
+            cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
 
-      if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
-          d->fragment_shading_rate.size.width == 1 &&
-          d->fragment_shading_rate.size.height == 1 &&
-          d->fragment_shading_rate.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
-          d->fragment_shading_rate.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
-         /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
-          * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
-          */
-         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
+             d->fragment_shading_rate.size.width == 1 &&
+             d->fragment_shading_rate.size.height == 1 &&
+             d->fragment_shading_rate.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
+             d->fragment_shading_rate.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
+            /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
+             * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
+             */
+            cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         }
       }
-   }
 
-   if (device->pbb_allowed) {
-      struct radv_binning_settings *settings = &device->physical_device->binning_settings;
+      if (device->pbb_allowed) {
+         struct radv_binning_settings *settings = &device->physical_device->binning_settings;
 
-      if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
-          settings->context_states_per_bin > 1) {
-         /* Break the batch on CB_TARGET_MASK changes. */
-         radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
-         radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+         if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
+             settings->context_states_per_bin > 1) {
+            /* Break the batch on CB_TARGET_MASK changes. */
+            radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
+            radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+         }
       }
-   }
 
-   /* Pre-compute some tessellation info that depend on the number of patch control points when the
-    * bound pipeline declared this state as dynamic.
-    */
-   if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
-
-      if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
-         const struct radv_physical_device *pdevice = device->physical_device;
-         const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
-         const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
-         const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-
-         /* Compute the number of patches and emit the context register. */
-         cmd_buffer->state.tess_num_patches =
-            get_tcs_num_patches(d->patch_control_points, tcs->info.tcs.tcs_vertices_out,
-                                tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
-                                tcs->info.tcs.num_linked_patch_outputs,
-                                pdevice->hs.tess_offchip_block_dw_size, pdevice->rad_info.gfx_level,
-                                pdevice->rad_info.family);
-
-         /* Compute the LDS size and emit the shader register. */
-         cmd_buffer->state.tess_lds_size =
-            calculate_tess_lds_size(pdevice->rad_info.gfx_level, d->patch_control_points,
-                                    tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
-                                    cmd_buffer->state.tess_num_patches,
-                                    tcs->info.tcs.num_linked_outputs,
-                                    tcs->info.tcs.num_linked_patch_outputs);
-      }
-   }
-
-   radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+      /* Pre-compute some tessellation info that depend on the number of patch control points when the
+       * bound pipeline declared this state as dynamic.
+       */
+      if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
+         uint64_t dynamic_states =
+            cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+
+         if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
+            const struct radv_physical_device *pdevice = device->physical_device;
+            const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+            const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+            const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+
+            /* Compute the number of patches and emit the context register. */
+            cmd_buffer->state.tess_num_patches =
+               get_tcs_num_patches(d->patch_control_points, tcs->info.tcs.tcs_vertices_out,
+                                   tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
+                                   tcs->info.tcs.num_linked_patch_outputs,
+                                   pdevice->hs.tess_offchip_block_dw_size, pdevice->rad_info.gfx_level,
+                                   pdevice->rad_info.family);
+
+            /* Compute the LDS size and emit the shader register. */
+            cmd_buffer->state.tess_lds_size =
+               calculate_tess_lds_size(pdevice->rad_info.gfx_level, d->patch_control_points,
+                                       tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
+                                       cmd_buffer->state.tess_num_patches,
+                                       tcs->info.tcs.num_linked_outputs,
+                                       tcs->info.tcs.num_linked_patch_outputs);
+         }
+      }
+      radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+   }
 
    radv_emit_draw_registers(cmd_buffer, info);
 
-- 
GitLab


From 0716009d3bd2b48d0fc8717064aff4c402f30a30 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:16:32 -0400
Subject: [PATCH 14/20] radv: add an early out in
 radv_cmd_buffer_flush_dynamic_state()

no point checking all the states if they're known to be unset
---
 src/amd/vulkan/radv_cmd_buffer.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 781049a059a7..f30c2bcd816e 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3215,6 +3215,10 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    uint64_t states =
       cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
 
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
+   if (!states)
+      return;
+
    if (states & (RADV_CMD_DIRTY_DYNAMIC_VIEWPORT))
       radv_emit_viewport(cmd_buffer);
 
@@ -3285,7 +3289,6 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS)
       radv_emit_patch_control_points(cmd_buffer);
 
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
 }
 
 static void
-- 
GitLab


From fb4ad6b301a5ec1463f2266d175086b59704e1a4 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:38:35 -0400
Subject: [PATCH 15/20] radv: break out radv_flush_constants check

---
 src/amd/vulkan/radv_cmd_buffer.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f30c2bcd816e..d54dea887466 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3459,6 +3459,12 @@ radv_emit_all_inline_push_consts(struct radv_device *device, struct radeon_cmdbu
    }
 }
 
+ALWAYS_INLINE static bool
+radv_must_flush_constants(const struct radv_cmd_buffer *cmd_buffer, const struct radv_pipeline *pipeline, VkShaderStageFlags stages)
+{
+   return (stages & cmd_buffer->push_constant_stages) && (pipeline->push_constant_size || pipeline->dynamic_offset_count);
+}
+
 static void
 radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stages,
                      struct radv_pipeline *pipeline, VkPipelineBindPoint bind_point)
@@ -3475,8 +3481,7 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
    uint32_t internal_stages;
    uint32_t dirty_stages = 0;
 
-   stages &= cmd_buffer->push_constant_stages;
-   if (!stages || (!pipeline->push_constant_size && !pipeline->dynamic_offset_count))
+   if (!radv_must_flush_constants(cmd_buffer, pipeline, stages))
       return;
 
    internal_stages = stages;
-- 
GitLab


From 57aa00baac1945c6b19033b780398e7c57f42d84 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:41:03 -0400
Subject: [PATCH 16/20] radv: move constant flushing check out to callers

---
 src/amd/vulkan/radv_cmd_buffer.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d54dea887466..17f88a33814a 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3481,9 +3481,6 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
    uint32_t internal_stages;
    uint32_t dirty_stages = 0;
 
-   if (!radv_must_flush_constants(cmd_buffer, pipeline, stages))
-      return;
-
    internal_stages = stages;
    switch (bind_point) {
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
@@ -3929,7 +3926,8 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer, bool
 
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_MESH_BIT_EXT;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY) {
       radv_flush_ngg_query_state(cmd_buffer);
       cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_NGG_QUERY;
@@ -7471,8 +7469,9 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    /* Flush descriptors and push constants for task shaders. */
    radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_EXT, &pipeline->base,
                           VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_EXT, &pipeline->base,
-                        VK_PIPELINE_BIND_POINT_GRAPHICS);
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, VK_SHADER_STAGE_TASK_BIT_NV))
+      radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
+                           VK_PIPELINE_BIND_POINT_GRAPHICS);
 
    assert(ace_cs->cdw <= ace_cdw_max);
    return true;
@@ -8341,11 +8340,12 @@ radv_upload_compute_shader_descriptors(struct radv_cmd_buffer *cmd_buffer,
                                        VkPipelineBindPoint bind_point)
 {
    radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_COMPUTE_BIT, &pipeline->base, bind_point);
-   radv_flush_constants(cmd_buffer,
-                        bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
-                           ? RADV_RT_STAGE_BITS
-                           : VK_SHADER_STAGE_COMPUTE_BIT,
-                        &pipeline->base, bind_point);
+   VkShaderStageFlags stages = bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
+                               ? RADV_RT_STAGE_BITS
+                               : VK_SHADER_STAGE_COMPUTE_BIT;
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages,
+                           &pipeline->base, bind_point);
 }
 
 static void
-- 
GitLab


From 3c36ef25539d6b5ebb335eac6d71fe1ea36f0553 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:48:59 -0400
Subject: [PATCH 17/20] radv: move mesh shader descriptor emission to task
 shader emission

avoid incurring overhead on gfx emit
---
 src/amd/vulkan/radv_cmd_buffer.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 17f88a33814a..96e198d50d8c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3924,7 +3924,7 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer, bool
    radv_flush_vertex_descriptors(cmd_buffer, pipeline_is_dirty);
    radv_flush_streamout_descriptors(cmd_buffer);
 
-   VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_MESH_BIT_EXT;
+   VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
    if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
       radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
@@ -7467,10 +7467,10 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    descriptors_state->dirty = desc_dirty;
 
    /* Flush descriptors and push constants for task shaders. */
-   radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_EXT, &pipeline->base,
+   radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_MESH_BIT_NV | VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
                           VK_PIPELINE_BIND_POINT_GRAPHICS);
-   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, VK_SHADER_STAGE_TASK_BIT_NV))
-      radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, VK_SHADER_STAGE_MESH_BIT_NV | VK_SHADER_STAGE_TASK_BIT_NV))
+      radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_MESH_BIT_NV | VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
                            VK_PIPELINE_BIND_POINT_GRAPHICS);
 
    assert(ace_cs->cdw <= ace_cdw_max);
-- 
GitLab


From 4fbf702db82fbf61b5247156aeaed9c5314b8c7c Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:52:46 -0400
Subject: [PATCH 18/20] radv: fix bit checking in
 radv_need_late_scissor_emission()

this was needlessly obfuscated
---
 src/amd/vulkan/radv_cmd_buffer.c | 9 +--------
 1 file changed, 1 insertion(+), 8 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 96e198d50d8c..257b7f3d4317 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7009,14 +7009,7 @@ radv_need_late_scissor_emission(struct radv_cmd_buffer *cmd_buffer,
       return true;
 
    uint64_t used_states =
-      cmd_buffer->state.graphics_pipeline->needed_dynamic_state | ~RADV_CMD_DIRTY_DYNAMIC_ALL;
-
-   /* Index, vertex and streamout buffers don't change context regs, and
-    * pipeline is already handled.
-    */
-   used_states &= ~(RADV_CMD_DIRTY_INDEX_BUFFER | RADV_CMD_DIRTY_VERTEX_BUFFER |
-                    RADV_CMD_DIRTY_DYNAMIC_VERTEX_INPUT | RADV_CMD_DIRTY_STREAMOUT_BUFFER |
-                    RADV_CMD_DIRTY_PIPELINE);
+      cmd_buffer->state.graphics_pipeline->needed_dynamic_state & (RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND);
 
    if (cmd_buffer->state.dirty & used_states)
       return true;
-- 
GitLab


From 6cfe62ac6b2dfa0d4a890ecbaec7070b881456e4 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 16:00:32 -0400
Subject: [PATCH 19/20] radv: ALWAYS_INLINE radv_flush_descriptors

B I G  P E R F
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 257b7f3d4317..d5fdcf483aef 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3370,7 +3370,7 @@ radv_flush_indirect_descriptor_sets(struct radv_cmd_buffer *cmd_buffer,
    }
 }
 
-static void
+ALWAYS_INLINE static void
 radv_flush_descriptors(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stages,
                        struct radv_pipeline *pipeline, VkPipelineBindPoint bind_point)
 {
-- 
GitLab


From 955f48dd24e6a6735c967c1d1df52d0ae2926692 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 16:03:01 -0400
Subject: [PATCH 20/20] radv: ALWAYS_INLINE radv_is_streamout_enabled()

---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d5fdcf483aef..9ac246a7192f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9388,7 +9388,7 @@ radv_CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t
    cmd_buffer->state.dirty |= RADV_CMD_DIRTY_STREAMOUT_BUFFER;
 }
 
-bool
+ALWAYS_INLINE bool
 radv_is_streamout_enabled(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_streamout_state *so = &cmd_buffer->state.streamout;
-- 
GitLab

