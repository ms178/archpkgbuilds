From 6fedceedccca3203c056d505d4c973d72b520780 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 13 Sep 2022 13:08:59 -0400
Subject: [PATCH 01/21] radv: prefetch graphics pipeline pointers during draw

these are guaranteed to be accessed, and not having them already loaded
at these exact spots hurts perf in some cases
---
 src/amd/vulkan/radv_cmd_buffer.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 362aceff4530..0b991f325841 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7382,6 +7382,13 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
    if (cmd_buffer->state.flush_bits &
        (RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_DB |
         RADV_CMD_FLAG_PS_PARTIAL_FLUSH | RADV_CMD_FLAG_CS_PARTIAL_FLUSH)) {
+
+      /* prefetch pipeline pointers since they'll be used in non-inlined functions */
+      if (pipeline_is_dirty) {
+         __builtin_prefetch(&cmd_buffer->state.graphics_pipeline);
+         __builtin_prefetch(&cmd_buffer->state.emitted_graphics_pipeline, 1, 3);
+      }
+
       /* If we have to wait for idle, set all states first, so that
        * all SET packets are processed in parallel with previous draw
        * calls. Then upload descriptors, set shader pointers, and
@@ -7407,6 +7414,12 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
          radv_emit_prefetch_L2(cmd_buffer, cmd_buffer->state.graphics_pipeline, true);
       }
 
+      /* prefetch pipeline pointers since they'll be used in non-inlined functions */
+      if (pipeline_is_dirty) {
+         __builtin_prefetch(&cmd_buffer->state.graphics_pipeline);
+         __builtin_prefetch(&cmd_buffer->state.emitted_graphics_pipeline, 1, 3);
+      }
+
       radv_upload_graphics_shader_descriptors(cmd_buffer, pipeline_is_dirty);
 
       radv_emit_all_graphics_states(cmd_buffer, info, pipeline_is_dirty);
-- 
GitLab


From 03743e2ff128289ec3476b650f8bc225e05e63ec Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 15:13:28 -0400
Subject: [PATCH 02/21] radv: remove some pipeline comparisons from draw
 emission

these help poorly-optimized apps and hurt well-optimized ones
---
 src/amd/vulkan/radv_cmd_buffer.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 0b991f325841..c91831c6247f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1427,9 +1427,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    const struct radv_device *device = cmd_buffer->device;
 
-   if (cmd_buffer->state.emitted_graphics_pipeline == pipeline)
-      return;
-
    radv_update_multisample_state(cmd_buffer, pipeline);
    radv_update_binning_state(cmd_buffer, pipeline);
 
@@ -7353,8 +7350,7 @@ ALWAYS_INLINE static bool
 radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info *info, uint32_t drawCount)
 {
    const bool has_prefetch = cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7;
-   const bool pipeline_is_dirty = (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE) &&
-                                  cmd_buffer->state.graphics_pipeline != cmd_buffer->state.emitted_graphics_pipeline;
+   const bool pipeline_is_dirty = cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE;
 
    ASSERTED const unsigned cdw_max =
       radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4096 + 128 * (drawCount - 1));
-- 
GitLab


From d2734caea2077d2789b3d5ef9f22fbb39a607958 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 15:27:19 -0400
Subject: [PATCH 03/21] radv: avoid another pipeline comparison for emitting
 framebuffer state

this isn't technically the same check, but for a well-optimized app
it should result in no change except for one fewer memcmp
---
 src/amd/vulkan/radv_cmd_buffer.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index c91831c6247f..a6a21e960373 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7242,8 +7242,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    const struct radv_device *device = cmd_buffer->device;
    bool late_scissor_emission;
 
-   if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER) ||
-       cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
+   if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_FRAMEBUFFER))
       radv_emit_rbplus_state(cmd_buffer);
 
    if (cmd_buffer->device->physical_device->use_ngg_culling &&
-- 
GitLab


From 4e18066306054a94a6fb62f8c9a30b792e30cd80 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:04:57 -0400
Subject: [PATCH 04/21] radv: eliminate more null checks during pipeline
 emission

this avoids unnecessary null checks when updating flag bits, but it
requires moving the flag-setting to location where emitted_graphics_pipeline
cannot be null
---
 src/amd/vulkan/radv_cmd_buffer.c | 107 ++++++++++++++++---------------
 1 file changed, 56 insertions(+), 51 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index a6a21e960373..ef9217e80388 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1434,46 +1434,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       MAX2(cmd_buffer->scratch_size_per_wave_needed, pipeline->base.scratch_bytes_per_wave);
    cmd_buffer->scratch_waves_wanted = MAX2(cmd_buffer->scratch_waves_wanted, pipeline->base.max_waves);
 
-   if (!cmd_buffer->state.emitted_graphics_pipeline)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS |
-                                 RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_STENCIL_OP |
-                                 RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
-       cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       radv_rast_prim_is_points_or_lines(cmd_buffer->state.emitted_graphics_pipeline->rast_prim) != radv_rast_prim_is_points_or_lines(pipeline->rast_prim))
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_GUARDBAND;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->pa_su_sc_mode_cntl != pipeline->pa_su_sc_mode_cntl)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
-                                 RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
-                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->pa_cl_clip_cntl != pipeline->pa_cl_clip_cntl)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->cb_color_control != pipeline->cb_color_control)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP;
-
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->cb_target_mask != pipeline->cb_target_mask)
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
-
    radeon_emit_array(cmd_buffer->cs, pipeline->base.cs.buf, pipeline->base.cs.cdw);
 
    if (pipeline->has_ngg_culling &&
@@ -4662,7 +4622,25 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
       radv_cmd_buffer_trace_emit(cmd_buffer);
 
    radv_describe_begin_cmd_buffer(cmd_buffer);
-
+   cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS |
+                              RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_STENCIL_OP |
+                              RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
+                              RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS |
+                              RADV_CMD_DIRTY_GUARDBAND |
+                              RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+                              RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
+                              RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
+                              RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
+                              RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP |
+                              RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
    cmd_buffer->status = RADV_CMD_BUFFER_STATUS_RECORDING;
 
    return result;
@@ -5112,6 +5090,31 @@ radv_bind_vs_input_state(struct radv_cmd_buffer *cmd_buffer,
    cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VERTEX_INPUT;
 }
 
+static void
+radv_check_dynamic_state(struct radv_cmd_buffer *cmd_buffer, struct radv_graphics_pipeline *pipeline)
+{
+   if (cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
+       cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
+
+   if (radv_rast_prim_is_points_or_lines(cmd_buffer->state.emitted_graphics_pipeline->rast_prim) != radv_rast_prim_is_points_or_lines(pipeline->rast_prim))
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_GUARDBAND;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->pa_su_sc_mode_cntl != pipeline->pa_su_sc_mode_cntl)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+                                 RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
+                                 RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->pa_cl_clip_cntl != pipeline->pa_cl_clip_cntl)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->cb_color_control != pipeline->cb_color_control)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP;
+
+   if (cmd_buffer->state.emitted_graphics_pipeline->cb_target_mask != pipeline->cb_target_mask)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                      VkPipeline _pipeline)
@@ -5181,16 +5184,18 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
       /* Prefetch all pipeline shaders at first draw time. */
       cmd_buffer->state.prefetch_L2_mask |= RADV_PREFETCH_SHADERS;
 
-      if (cmd_buffer->device->physical_device->rad_info.has_vgt_flush_ngg_legacy_bug &&
-          cmd_buffer->state.emitted_graphics_pipeline &&
-          cmd_buffer->state.emitted_graphics_pipeline->is_ngg &&
-          !cmd_buffer->state.graphics_pipeline->is_ngg) {
-         /* Transitioning from NGG to legacy GS requires
-          * VGT_FLUSH on GFX10 and Navi21. VGT_FLUSH
-          * is also emitted at the beginning of IBs when legacy
-          * GS ring pointers are set.
-          */
-         cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
+      if (cmd_buffer->state.emitted_graphics_pipeline) {
+         radv_check_dynamic_state(cmd_buffer, graphics_pipeline);
+         if (cmd_buffer->device->physical_device->rad_info.has_vgt_flush_ngg_legacy_bug &&
+             cmd_buffer->state.emitted_graphics_pipeline->is_ngg &&
+             !cmd_buffer->state.graphics_pipeline->is_ngg) {
+            /* Transitioning from NGG to legacy GS requires
+             * VGT_FLUSH on GFX10 and Navi21. VGT_FLUSH
+             * is also emitted at the beginning of IBs when legacy
+             * GS ring pointers are set.
+             */
+            cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
+         }
       }
 
       if (radv_pipeline_has_stage(graphics_pipeline, MESA_SHADER_TESS_CTRL) &&
-- 
GitLab


From a2424cb02ef12fd3b81dd76198427836239ddf6e Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:06:15 -0400
Subject: [PATCH 05/21] radv: store pointer to sgprs for last vertex stage

---
 src/amd/vulkan/radv_pipeline.c | 1 +
 src/amd/vulkan/radv_private.h  | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 0810ca126e38..858ee2693653 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -6117,6 +6117,7 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       pipeline->base.shaders[pipeline->last_vgt_api_stage]->info.force_vrs_per_vertex;
    pipeline->uses_user_sample_locations = state.ms && state.ms->sample_locations_enable;
    pipeline->rast_prim = vgt_gs_out_prim_type;
+   pipeline->last_vgt_api_stage_locs = pipeline->base.shaders[pipeline->last_vgt_api_stage]->info.user_sgprs_locs.shader_data;
 
    pipeline->base.push_constant_size = pipeline_layout.push_constant_size;
    pipeline->base.dynamic_offset_count = pipeline_layout.dynamic_offset_count;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index e6c59a445707..c47912e5b2ac 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2024,6 +2024,7 @@ struct radv_graphics_pipeline {
 
    /* Last pre-PS API stage */
    gl_shader_stage last_vgt_api_stage;
+   struct radv_userdata_info *last_vgt_api_stage_locs;
 
    /* Used for rbplus */
    uint32_t col_format;
-- 
GitLab


From 969c85cb24f0325809e07d81b63b583bbf7ce255 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:14:45 -0400
Subject: [PATCH 06/21] radv: use direct access to last_vgt_api_stage_locs for
 sgpr emission

radv_lookup_user_sgpr is heavy, stop using it
---
 src/amd/vulkan/radv_cmd_buffer.c | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ef9217e80388..9b5bb79ecfc0 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3863,11 +3863,10 @@ radv_flush_ngg_query_state(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    const unsigned stage = pipeline->last_vgt_api_stage;
-   struct radv_userdata_info *loc;
+   const struct radv_userdata_info *loc = &pipeline->last_vgt_api_stage_locs[AC_UD_NGG_QUERY_STATE];
    uint32_t ngg_query_state = 0;
    uint32_t base_reg;
 
-   loc = radv_lookup_user_sgpr(&pipeline->base, stage, AC_UD_NGG_QUERY_STATE);
    if (loc->sgpr_idx == -1)
       return;
 
@@ -3894,7 +3893,7 @@ radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    enum amd_gfx_level gfx_level = pipeline->base.device->physical_device->rad_info.gfx_level;
    const unsigned stage = pipeline->last_vgt_api_stage;
-   struct radv_userdata_info *loc;
+   struct radv_userdata_info *loc = &pipeline->last_vgt_api_stage_locs[AC_UD_FORCE_VRS_RATES];
    uint32_t vrs_rates = 0;
    uint32_t base_reg;
 
@@ -3904,7 +3903,6 @@ radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
       return;
    }
 
-   loc = radv_lookup_user_sgpr(&pipeline->base, stage, AC_UD_FORCE_VRS_RATES);
    assert(loc->sgpr_idx != -1);
 
    base_reg = pipeline->base.user_data_0[stage];
@@ -6442,14 +6440,13 @@ radv_cs_emit_dispatch_taskmesh_indirect_multi_ace_packet(struct radv_cmd_buffer
 ALWAYS_INLINE static void
 radv_cs_emit_dispatch_taskmesh_gfx_packet(struct radv_cmd_buffer *cmd_buffer)
 {
-   struct radv_pipeline *pipeline = &cmd_buffer->state.graphics_pipeline->base;
+   struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    bool predicating = cmd_buffer->state.predicating;
 
-   struct radv_userdata_info *ring_entry_loc =
-      radv_lookup_user_sgpr(pipeline, MESA_SHADER_MESH, AC_UD_TASK_RING_ENTRY);
+   struct radv_userdata_info *ring_entry_loc = &pipeline->last_vgt_api_stage_locs[AC_UD_TASK_RING_ENTRY];
 
-   assert(ring_entry_loc && ring_entry_loc->sgpr_idx != -1);
+   assert(ring_entry_loc->sgpr_idx != -1);
 
    uint32_t base_reg = cmd_buffer->state.graphics_pipeline->vtx_base_sgpr;
    uint32_t xyz_dim_reg = ((base_reg + 4) - SI_SH_REG_OFFSET) >> 2;
@@ -7164,7 +7161,7 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
 
    /* Find the user SGPR. */
    const uint32_t base_reg = pipeline->base.user_data_0[stage];
-   const int8_t nggc_sgpr_idx = v->info.user_sgprs_locs.shader_data[AC_UD_NGG_CULLING_SETTINGS].sgpr_idx;
+   const int8_t nggc_sgpr_idx = pipeline->last_vgt_api_stage_locs[AC_UD_NGG_CULLING_SETTINGS].sgpr_idx;
    assert(!nggc_supported || nggc_sgpr_idx != -1);
 
    /* Get viewport transform. */
@@ -7197,7 +7194,7 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
       }
 
       uint32_t vp_reg_values[4] = {fui(vp_scale[0]), fui(vp_scale[1]), fui(vp_translate[0]), fui(vp_translate[1])};
-      const int8_t vp_sgpr_idx = v->info.user_sgprs_locs.shader_data[AC_UD_NGG_VIEWPORT].sgpr_idx;
+      const int8_t vp_sgpr_idx = pipeline->last_vgt_api_stage_locs[AC_UD_NGG_VIEWPORT].sgpr_idx;
       assert(vp_sgpr_idx != -1);
       radeon_set_sh_reg_seq(cmd_buffer->cs, base_reg + vp_sgpr_idx * 4, 4);
       radeon_emit_array(cmd_buffer->cs, vp_reg_values, 4);
-- 
GitLab


From fd8480a2333fba243e076177dfe7a88f5f02dc16 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 7 Sep 2022 16:24:56 -0400
Subject: [PATCH 07/21] radv: make ngg query emission a dirty flag

if this state doesn't change, it doesn't need to be emitted

+5% draw perf
---
 src/amd/vulkan/radv_cmd_buffer.c | 12 ++++++++++--
 src/amd/vulkan/radv_meta.c       |  4 ++++
 src/amd/vulkan/radv_private.h    |  1 +
 src/amd/vulkan/radv_query.c      |  8 ++++++++
 4 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 9b5bb79ecfc0..b8452dbc075a 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3941,7 +3941,10 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer, bool
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_MESH_BIT_EXT;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
    radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_ngg_query_state(cmd_buffer);
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY) {
+      radv_flush_ngg_query_state(cmd_buffer);
+      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_NGG_QUERY;
+   }
    radv_flush_force_vrs_state(cmd_buffer);
 }
 
@@ -4612,6 +4615,9 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
             render->ds_att.format = inheritance_info->stencilAttachmentFormat;
       }
 
+      if (!!(pBeginInfo->pInheritanceInfo->pipelineStatistics & VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT) !=
+          !!cmd_buffer->state.active_pipeline_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       cmd_buffer->state.inherited_pipeline_statistics =
          pBeginInfo->pInheritanceInfo->pipelineStatistics;
    }
@@ -4638,7 +4644,8 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
                               RADV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
                               RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
                               RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP |
-                              RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE;
+                              RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE |
+                              RADV_CMD_DIRTY_NGG_QUERY;
    cmd_buffer->status = RADV_CMD_BUFFER_STATUS_RECORDING;
 
    return result;
@@ -5091,6 +5098,7 @@ radv_bind_vs_input_state(struct radv_cmd_buffer *cmd_buffer,
 static void
 radv_check_dynamic_state(struct radv_cmd_buffer *cmd_buffer, struct radv_graphics_pipeline *pipeline)
 {
+   cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
    if (cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
        cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
diff --git a/src/amd/vulkan/radv_meta.c b/src/amd/vulkan/radv_meta.c
index 2ea349ddacdb..28fe23b8f36d 100644
--- a/src/amd/vulkan/radv_meta.c
+++ b/src/amd/vulkan/radv_meta.c
@@ -57,6 +57,8 @@ radv_suspend_queries(struct radv_meta_saved_state *state, struct radv_cmd_buffer
        * increment the counters via GDS.
        */
       state->active_pipeline_gds_queries = cmd_buffer->state.active_pipeline_gds_queries;
+      if (cmd_buffer->state.active_pipeline_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       cmd_buffer->state.active_pipeline_gds_queries = 0;
    }
 }
@@ -81,6 +83,8 @@ radv_resume_queries(const struct radv_meta_saved_state *state, struct radv_cmd_b
       radv_emit_streamout_enable(cmd_buffer);
 
       /* Restore the number of active GDS queries to resume counting. */
+      if (!!cmd_buffer->state.active_pipeline_gds_queries != !!state->active_pipeline_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       cmd_buffer->state.active_pipeline_gds_queries = state->active_pipeline_gds_queries;
    }
 }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index c47912e5b2ac..f417fb18f200 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1140,6 +1140,7 @@ enum radv_cmd_dirty_bits {
    RADV_CMD_DIRTY_VERTEX_BUFFER = 1ull << 33,
    RADV_CMD_DIRTY_STREAMOUT_BUFFER = 1ull << 34,
    RADV_CMD_DIRTY_GUARDBAND = 1ull << 35,
+   RADV_CMD_DIRTY_NGG_QUERY = 1ull << 36,
 };
 
 enum radv_cmd_flush_bits {
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index d160bec26341..0c63a4380023 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1816,6 +1816,8 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
          /* Record that the command buffer needs GDS. */
          cmd_buffer->gds_needed = true;
 
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
          cmd_buffer->state.active_pipeline_gds_queries++;
       }
       break;
@@ -1842,6 +1844,8 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
          /* Record that the command buffer needs GDS. */
          cmd_buffer->gds_needed = true;
 
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
          cmd_buffer->state.active_pipeline_gds_queries++;
       }
       break;
@@ -1910,6 +1914,8 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
          gfx10_copy_gds_query(cmd_buffer, 0, va); /* NGG GS */
 
          cmd_buffer->state.active_pipeline_gds_queries--;
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       }
       break;
    case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
@@ -1933,6 +1939,8 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
          gfx10_copy_gds_query(cmd_buffer, 4, va + 56); /* NGG VS/TES */
 
          cmd_buffer->state.active_pipeline_gds_queries--;
+         if (!cmd_buffer->state.active_pipeline_gds_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
       }
       break;
    }
-- 
GitLab


From fd7f730711b3cf5eb335e55de9961d909344eabe Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 13:55:44 -0400
Subject: [PATCH 08/21] radv: hoist indirect check up from
 radv_emit_index_buffer()

avoid calling the function entirely when possible, as info->indirect
should be possible to inline as a nullable stack value
---
 src/amd/vulkan/radv_cmd_buffer.c | 13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index b8452dbc075a..90c480af8a39 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2783,7 +2783,7 @@ radv_emit_guardband_state(struct radv_cmd_buffer *cmd_buffer)
 }
 
 static void
-radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
+radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    struct radv_cmd_state *state = &cmd_buffer->state;
@@ -2793,11 +2793,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
    if (state->index_type < 0)
       return;
 
-   /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-    * the index_va and max_index_count already. */
-   if (!indirect)
-      return;
-
    if (state->max_index_count ||
        !cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug) {
       radeon_emit(cs, PKT3(PKT3_INDEX_BASE, 1, 0));
@@ -7274,8 +7269,10 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       radv_emit_guardband_state(cmd_buffer);
 
    if (info->indexed) {
-      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
-         radv_emit_index_buffer(cmd_buffer, info->indirect);
+      /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+       * the index_va and max_index_count already. */
+      if (info->indirect && cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
+         radv_emit_index_buffer(cmd_buffer);
    } else {
       /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
        * so the state must be re-emitted before the next indexed
-- 
GitLab


From 4175ceeb1b1b3cdb92ebfcc3fcd6d354864fd931 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 14:13:10 -0400
Subject: [PATCH 09/21] radv: ALWAYS_INLINE radv_after_draw

---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 90c480af8a39..ec827ec7e8d6 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7505,7 +7505,7 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    return true;
 }
 
-static void
+ALWAYS_INLINE static void
 radv_after_draw(struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radeon_info *rad_info = &cmd_buffer->device->physical_device->rad_info;
-- 
GitLab


From df570b834710d969c2c27dfec8bbc88df2b14c7c Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 13 Sep 2022 10:14:58 -0400
Subject: [PATCH 10/21] radv: flag missing dynamic states on pipeline bind

ensure that these are always emitted
---
 src/amd/vulkan/radv_cmd_buffer.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ec827ec7e8d6..ae5e3117d4d1 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5094,6 +5094,7 @@ static void
 radv_check_dynamic_state(struct radv_cmd_buffer *cmd_buffer, struct radv_graphics_pipeline *pipeline)
 {
    cmd_buffer->state.dirty |= RADV_CMD_DIRTY_NGG_QUERY;
+   cmd_buffer->state.dirty |= pipeline->needed_dynamic_state & ~cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
    if (cmd_buffer->state.emitted_graphics_pipeline->negative_one_to_one != pipeline->negative_one_to_one ||
        cmd_buffer->state.emitted_graphics_pipeline->depth_clamp_mode != pipeline->depth_clamp_mode)
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_VIEWPORT;
-- 
GitLab


From a9a8806287313c12c5cc16b7eb7b1e097c9b66e9 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:01:37 -0400
Subject: [PATCH 11/21] radv: unset all dynamic state flags after
 radv_cmd_buffer_flush_dynamic_state()

it's irrelevant whether the states are actually updated here, as unused states
will be flagged again when a new pipeline is bound
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ae5e3117d4d1..59d99b7745c7 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3289,7 +3289,7 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS)
       radv_emit_patch_control_points(cmd_buffer);
 
-   cmd_buffer->state.dirty &= ~states;
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
 }
 
 static void
-- 
GitLab


From 29f651016f111cc8317924873a94aec1b3c23151 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:04:12 -0400
Subject: [PATCH 12/21] radv: rework VGT_INDEX_TYPE flagging on draw -> indexed
 draw cmdbuf

previously, this mechanic would force RADV_CMD_DIRTY_INDEX_BUFFER on
every non-indexed draw, ensuring that non-indexed draws always had at
least 1 bit set in cmd_buffer->state.dirty

instead, track whether the previous draw was indexed and set the flag
appropriately if it will be consumed

this enables successive non-indexed draws to execute without setting any
dirty flags
---
 src/amd/vulkan/radv_cmd_buffer.c | 36 +++++++++++++++-----------------
 src/amd/vulkan/radv_private.h    |  1 +
 2 files changed, 18 insertions(+), 19 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 59d99b7745c7..f27f155cf1de 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2802,8 +2802,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer)
       radeon_emit(cs, PKT3(PKT3_INDEX_BUFFER_SIZE, 0, 0));
       radeon_emit(cs, state->max_index_count);
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
 }
 
 void
@@ -5877,6 +5875,7 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
       primary->state.last_sx_ps_downconvert = secondary->state.last_sx_ps_downconvert;
       primary->state.last_sx_blend_opt_epsilon = secondary->state.last_sx_blend_opt_epsilon;
       primary->state.last_sx_blend_opt_control = secondary->state.last_sx_blend_opt_control;
+      primary->state.last_draw_indexed = secondary->state.last_draw_indexed;
 
       if (secondary->state.last_index_type != -1) {
          primary->state.last_index_type = secondary->state.last_index_type;
@@ -7258,31 +7257,19 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
       radv_emit_graphics_pipeline(cmd_buffer);
 
-   /* This should be before the cmd_buffer->state.dirty is cleared
-    * (excluding RADV_CMD_DIRTY_PIPELINE) and after
-    * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
-   late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
-
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
       radv_emit_framebuffer_state(cmd_buffer);
 
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
       radv_emit_guardband_state(cmd_buffer);
 
-   if (info->indexed) {
-      /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-       * the index_va and max_index_count already. */
-      if (info->indirect && cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER) {
+      if (info->indexed && info->indirect) {
+         /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+          * the index_va and max_index_count already. */
          radv_emit_index_buffer(cmd_buffer);
-   } else {
-      /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
-       * so the state must be re-emitted before the next indexed
-       * draw.
-       */
-      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
-         cmd_buffer->state.last_index_type = -1;
-         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_INDEX_BUFFER;
       }
+      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
    }
 
    if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
@@ -7373,8 +7360,19 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
       /* Handle count == 0. */
       if (unlikely(!info->count && !info->strmout_buffer))
          return false;
+   } else if (info->indexed && !cmd_buffer->state.last_draw_indexed) {
+      /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
+       * so the state must be re-emitted before the next indexed
+       * draw.
+       */
+      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
+         cmd_buffer->state.last_index_type = -1;
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_INDEX_BUFFER;
+      }
    }
 
+   cmd_buffer->state.last_draw_indexed = info->indexed;
+
    /* Need to apply this workaround early as it can set flush flags. */
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
       radv_emit_fb_mip_change_flush(cmd_buffer);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index f417fb18f200..046454d26788 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1457,6 +1457,7 @@ struct radv_cmd_state {
    uint64_t vb_va;
 
    bool predicating;
+   bool last_draw_indexed;
    uint64_t dirty;
 
    uint32_t prefetch_L2_mask;
-- 
GitLab


From 305c7aac0ad5752143b0eddd71db3048d41f9305 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:07:05 -0400
Subject: [PATCH 13/21] radv: group flag checking in
 radv_emit_all_graphics_states()

this improves branch selection for successive draws in optimized builds
---
 src/amd/vulkan/radv_cmd_buffer.c | 144 ++++++++++++++++---------------
 1 file changed, 75 insertions(+), 69 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f27f155cf1de..02f4fba6f865 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7247,91 +7247,97 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    const struct radv_device *device = cmd_buffer->device;
    bool late_scissor_emission;
 
-   if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_FRAMEBUFFER))
-      radv_emit_rbplus_state(cmd_buffer);
+   /* This should be before the cmd_buffer->state.dirty is cleared
+    * (excluding RADV_CMD_DIRTY_PIPELINE) and after
+    * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
+   late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
 
    if (cmd_buffer->device->physical_device->use_ngg_culling &&
        cmd_buffer->state.graphics_pipeline->is_ngg)
       radv_emit_ngg_culling_state(cmd_buffer, info);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
-      radv_emit_graphics_pipeline(cmd_buffer);
+   if (cmd_buffer->state.dirty) {
+      if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_FRAMEBUFFER))
+         radv_emit_rbplus_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
-      radv_emit_framebuffer_state(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
+         radv_emit_graphics_pipeline(cmd_buffer);
+
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
+         radv_emit_framebuffer_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
-      radv_emit_guardband_state(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
+         radv_emit_guardband_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER) {
-      if (info->indexed && info->indirect) {
-         /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-          * the index_va and max_index_count already. */
-         radv_emit_index_buffer(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER) {
+         if (info->indexed && info->indirect) {
+            /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+             * the index_va and max_index_count already. */
+            radv_emit_index_buffer(cmd_buffer);
+         }
+         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
       }
-      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
-   }
 
-   if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
-      struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+      if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
+         struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+         uint64_t dynamic_states =
+            cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
 
-      if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
-          d->fragment_shading_rate.size.width == 1 &&
-          d->fragment_shading_rate.size.height == 1 &&
-          d->fragment_shading_rate.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
-          d->fragment_shading_rate.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
-         /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
-          * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
-          */
-         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
+             d->fragment_shading_rate.size.width == 1 &&
+             d->fragment_shading_rate.size.height == 1 &&
+             d->fragment_shading_rate.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
+             d->fragment_shading_rate.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
+            /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
+             * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
+             */
+            cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         }
       }
-   }
 
-   if (device->pbb_allowed) {
-      struct radv_binning_settings *settings = &device->physical_device->binning_settings;
+      if (device->pbb_allowed) {
+         struct radv_binning_settings *settings = &device->physical_device->binning_settings;
 
-      if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
-          settings->context_states_per_bin > 1) {
-         /* Break the batch on CB_TARGET_MASK changes. */
-         radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
-         radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+         if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
+             settings->context_states_per_bin > 1) {
+            /* Break the batch on CB_TARGET_MASK changes. */
+            radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
+            radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+         }
       }
-   }
 
-   /* Pre-compute some tessellation info that depend on the number of patch control points when the
-    * bound pipeline declared this state as dynamic.
-    */
-   if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
-
-      if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
-         const struct radv_physical_device *pdevice = device->physical_device;
-         const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
-         const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
-         const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-
-         /* Compute the number of patches and emit the context register. */
-         cmd_buffer->state.tess_num_patches =
-            get_tcs_num_patches(d->patch_control_points, tcs->info.tcs.tcs_vertices_out,
-                                tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
-                                tcs->info.tcs.num_linked_patch_outputs,
-                                pdevice->hs.tess_offchip_block_dw_size, pdevice->rad_info.gfx_level,
-                                pdevice->rad_info.family);
-
-         /* Compute the LDS size and emit the shader register. */
-         cmd_buffer->state.tess_lds_size =
-            calculate_tess_lds_size(pdevice->rad_info.gfx_level, d->patch_control_points,
-                                    tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
-                                    cmd_buffer->state.tess_num_patches,
-                                    tcs->info.tcs.num_linked_outputs,
-                                    tcs->info.tcs.num_linked_patch_outputs);
-      }
-   }
-
-   radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+      /* Pre-compute some tessellation info that depend on the number of patch control points when the
+       * bound pipeline declared this state as dynamic.
+       */
+      if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
+         uint64_t dynamic_states =
+            cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+
+         if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
+            const struct radv_physical_device *pdevice = device->physical_device;
+            const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+            const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+            const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+
+            /* Compute the number of patches and emit the context register. */
+            cmd_buffer->state.tess_num_patches =
+               get_tcs_num_patches(d->patch_control_points, tcs->info.tcs.tcs_vertices_out,
+                                   tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
+                                   tcs->info.tcs.num_linked_patch_outputs,
+                                   pdevice->hs.tess_offchip_block_dw_size, pdevice->rad_info.gfx_level,
+                                   pdevice->rad_info.family);
+
+            /* Compute the LDS size and emit the shader register. */
+            cmd_buffer->state.tess_lds_size =
+               calculate_tess_lds_size(pdevice->rad_info.gfx_level, d->patch_control_points,
+                                       tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
+                                       cmd_buffer->state.tess_num_patches,
+                                       tcs->info.tcs.num_linked_outputs,
+                                       tcs->info.tcs.num_linked_patch_outputs);
+         }
+      }
+      radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+   }
 
    radv_emit_draw_registers(cmd_buffer, info);
 
-- 
GitLab


From e2baf220b3f0efb2c86b6dd5e38fb98603a16ef6 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:16:32 -0400
Subject: [PATCH 14/21] radv: add an early out in
 radv_cmd_buffer_flush_dynamic_state()

no point checking all the states if they're known to be unset
---
 src/amd/vulkan/radv_cmd_buffer.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 02f4fba6f865..41f88221556e 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3217,6 +3217,10 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    uint64_t states =
       cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
 
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
+   if (!states)
+      return;
+
    if (states & (RADV_CMD_DIRTY_DYNAMIC_VIEWPORT))
       radv_emit_viewport(cmd_buffer);
 
@@ -3287,7 +3291,6 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS)
       radv_emit_patch_control_points(cmd_buffer);
 
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
 }
 
 static void
-- 
GitLab


From c7c2cba20edf934ef637c23b4de9831077bd8f99 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:38:35 -0400
Subject: [PATCH 15/21] radv: break out radv_flush_constants check

---
 src/amd/vulkan/radv_cmd_buffer.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 41f88221556e..bf205e6b43fa 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3461,6 +3461,12 @@ radv_emit_all_inline_push_consts(struct radv_device *device, struct radeon_cmdbu
    }
 }
 
+ALWAYS_INLINE static bool
+radv_must_flush_constants(const struct radv_cmd_buffer *cmd_buffer, const struct radv_pipeline *pipeline, VkShaderStageFlags stages)
+{
+   return (stages & cmd_buffer->push_constant_stages) && (pipeline->push_constant_size || pipeline->dynamic_offset_count);
+}
+
 static void
 radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stages,
                      struct radv_pipeline *pipeline, VkPipelineBindPoint bind_point)
@@ -3477,8 +3483,7 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
    uint32_t internal_stages;
    uint32_t dirty_stages = 0;
 
-   stages &= cmd_buffer->push_constant_stages;
-   if (!stages || (!pipeline->push_constant_size && !pipeline->dynamic_offset_count))
+   if (!radv_must_flush_constants(cmd_buffer, pipeline, stages))
       return;
 
    internal_stages = stages;
-- 
GitLab


From 4a46d9a37253974addf8759df364f9ea7ec4dd3a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:41:03 -0400
Subject: [PATCH 16/21] radv: move constant flushing check out to callers

---
 src/amd/vulkan/radv_cmd_buffer.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index bf205e6b43fa..f6c68043203f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3483,9 +3483,6 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
    uint32_t internal_stages;
    uint32_t dirty_stages = 0;
 
-   if (!radv_must_flush_constants(cmd_buffer, pipeline, stages))
-      return;
-
    internal_stages = stages;
    switch (bind_point) {
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
@@ -3941,7 +3938,8 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer, bool
 
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_MESH_BIT_EXT;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY) {
       radv_flush_ngg_query_state(cmd_buffer);
       cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_NGG_QUERY;
@@ -7511,8 +7509,9 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    /* Flush descriptors and push constants for task shaders. */
    radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_EXT, &pipeline->base,
                           VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_EXT, &pipeline->base,
-                        VK_PIPELINE_BIND_POINT_GRAPHICS);
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, VK_SHADER_STAGE_TASK_BIT_NV))
+      radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
+                           VK_PIPELINE_BIND_POINT_GRAPHICS);
 
    assert(ace_cs->cdw <= ace_cdw_max);
    return true;
@@ -8381,11 +8380,12 @@ radv_upload_compute_shader_descriptors(struct radv_cmd_buffer *cmd_buffer,
                                        VkPipelineBindPoint bind_point)
 {
    radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_COMPUTE_BIT, &pipeline->base, bind_point);
-   radv_flush_constants(cmd_buffer,
-                        bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
-                           ? RADV_RT_STAGE_BITS
-                           : VK_SHADER_STAGE_COMPUTE_BIT,
-                        &pipeline->base, bind_point);
+   VkShaderStageFlags stages = bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
+                               ? RADV_RT_STAGE_BITS
+                               : VK_SHADER_STAGE_COMPUTE_BIT;
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages,
+                           &pipeline->base, bind_point);
 }
 
 static void
-- 
GitLab


From d906b9871818214b9bef56fa8d9e6e45bee3759b Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:48:59 -0400
Subject: [PATCH 17/21] radv: move mesh shader descriptor emission to task
 shader emission

avoid incurring overhead on gfx emit
---
 src/amd/vulkan/radv_cmd_buffer.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f6c68043203f..e4442e13a0d9 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3936,7 +3936,7 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer, bool
    radv_flush_vertex_descriptors(cmd_buffer, pipeline_is_dirty);
    radv_flush_streamout_descriptors(cmd_buffer);
 
-   VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS | VK_SHADER_STAGE_MESH_BIT_EXT;
+   VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
    if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
       radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
@@ -7507,10 +7507,10 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    descriptors_state->dirty = desc_dirty;
 
    /* Flush descriptors and push constants for task shaders. */
-   radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_EXT, &pipeline->base,
+   radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_MESH_BIT_NV | VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
                           VK_PIPELINE_BIND_POINT_GRAPHICS);
-   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, VK_SHADER_STAGE_TASK_BIT_NV))
-      radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, VK_SHADER_STAGE_MESH_BIT_NV | VK_SHADER_STAGE_TASK_BIT_NV))
+      radv_flush_constants(cmd_buffer, VK_SHADER_STAGE_MESH_BIT_NV | VK_SHADER_STAGE_TASK_BIT_NV, &pipeline->base,
                            VK_PIPELINE_BIND_POINT_GRAPHICS);
 
    assert(ace_cs->cdw <= ace_cdw_max);
-- 
GitLab


From c8194846c0ac3748d6f5dcf3fdc96057d4d10930 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 16:00:32 -0400
Subject: [PATCH 18/21] radv: ALWAYS_INLINE radv_flush_descriptors

B I G  P E R F
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index e4442e13a0d9..bb33ec212076 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3372,7 +3372,7 @@ radv_flush_indirect_descriptor_sets(struct radv_cmd_buffer *cmd_buffer,
    }
 }
 
-static void
+ALWAYS_INLINE static void
 radv_flush_descriptors(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stages,
                        struct radv_pipeline *pipeline, VkPipelineBindPoint bind_point)
 {
-- 
GitLab


From 65dfd4406f9fc0bab777c6398c034e58d03fbc18 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 16:03:01 -0400
Subject: [PATCH 19/21] radv: inline radv_is_streamout_enabled()

---
 src/amd/vulkan/radv_cmd_buffer.c | 10 ----------
 src/amd/vulkan/radv_private.h    | 11 ++++++++++-
 2 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index bb33ec212076..bda7e1df9e3e 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9435,16 +9435,6 @@ radv_CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t
    cmd_buffer->state.dirty |= RADV_CMD_DIRTY_STREAMOUT_BUFFER;
 }
 
-bool
-radv_is_streamout_enabled(struct radv_cmd_buffer *cmd_buffer)
-{
-   struct radv_streamout_state *so = &cmd_buffer->state.streamout;
-
-   /* Streamout must be enabled for the PRIMITIVES_GENERATED query to work. */
-   return (so->streamout_enabled || cmd_buffer->state.prims_gen_query_enabled) &&
-          !cmd_buffer->state.suspend_streamout;
-}
-
 void
 radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer)
 {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 046454d26788..db86c3c02da2 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1665,7 +1665,6 @@ struct radv_image_view;
 
 bool radv_cmd_buffer_uses_mec(struct radv_cmd_buffer *cmd_buffer);
 
-bool radv_is_streamout_enabled(struct radv_cmd_buffer *cmd_buffer);
 void radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer);
 
 void si_emit_graphics(struct radv_device *device, struct radeon_cmdbuf *cs);
@@ -3023,6 +3022,16 @@ si_translate_blend_logic_op(VkLogicOp op)
    }
 }
 
+static inline bool
+radv_is_streamout_enabled(struct radv_cmd_buffer *cmd_buffer)
+{
+   struct radv_streamout_state *so = &cmd_buffer->state.streamout;
+
+   /* Streamout must be enabled for the PRIMITIVES_GENERATED query to work. */
+   return (so->streamout_enabled || cmd_buffer->state.prims_gen_query_enabled) &&
+          !cmd_buffer->state.suspend_streamout;
+}
+
 /*
  * Queue helper to get ring.
  * placed here as it needs queue + device structs.
-- 
GitLab


From 54a9ef49b1116972d887b4c470e51f1e96e150e8 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 14 Sep 2022 16:40:33 -0400
Subject: [PATCH 20/21] radv: consolidate indexed draw paths

this reworks the existing code to behave identically, but with less code
by forcing inlined values
---
 src/amd/vulkan/radv_cmd_buffer.c | 184 +++++++++++++------------------
 1 file changed, 74 insertions(+), 110 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index bda7e1df9e3e..df28d35262d4 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -6610,82 +6610,21 @@ radv_emit_userdata_task(struct radv_cmd_buffer *cmd_buffer, uint32_t x, uint32_t
 }
 
 ALWAYS_INLINE static void
-radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer,
-                               const struct radv_draw_info *info,
-                               uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *minfo,
-                               uint32_t stride,
-                               const int32_t *vertexOffset)
-
+radv_emit_draw_packets_indexed_internal(struct radv_cmd_buffer *cmd_buffer,
+                                        const struct radv_draw_info *info,
+                                        uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *minfo,
+                                        uint32_t stride,
+                                        const int32_t *vertexOffset,
+                                        const bool uses_drawid,
+                                        const bool can_eop)
 {
    struct radv_cmd_state *state = &cmd_buffer->state;
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    const int index_size = radv_get_vgt_index_size(state->index_type);
    unsigned i = 0;
-   const bool uses_drawid = state->graphics_pipeline->uses_drawid;
-   const bool can_eop =
-      !uses_drawid && cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX10;
-
-   if (uses_drawid) {
-      if (vertexOffset) {
-         radv_emit_userdata_vertex(cmd_buffer, info, *vertexOffset);
-         vk_foreach_multi_draw_indexed(draw, i, minfo, drawCount, stride) {
-            const uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-
-            /* Skip draw calls with 0-sized index buffers if the GPU can't handle them */
-            if (!remaining_indexes &&
-                cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug)
-               continue;
-
-            if (i > 0)
-               radeon_set_sh_reg(cs, state->graphics_pipeline->vtx_base_sgpr + sizeof(uint32_t), i);
-
-            const uint64_t index_va = state->index_va + draw->firstIndex * index_size;
-
-            if (!state->render.view_mask) {
-               radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
-            } else {
-               u_foreach_bit(view, state->render.view_mask) {
-                  radv_emit_view_index(cmd_buffer, view);
-
-                  radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
-               }
-            }
-         }
-      } else {
-         vk_foreach_multi_draw_indexed(draw, i, minfo, drawCount, stride) {
-            const uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-
-            /* Skip draw calls with 0-sized index buffers if the GPU can't handle them */
-            if (!remaining_indexes &&
-                cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug)
-               continue;
-
-            if (i > 0) {
-               if (state->last_vertex_offset != draw->vertexOffset)
-                  radv_emit_userdata_vertex_drawid(cmd_buffer, draw->vertexOffset, i);
-               else
-                  radeon_set_sh_reg(cs, state->graphics_pipeline->vtx_base_sgpr + sizeof(uint32_t), i);
-            } else
-               radv_emit_userdata_vertex(cmd_buffer, info, draw->vertexOffset);
-
-            const uint64_t index_va = state->index_va + draw->firstIndex * index_size;
 
-            if (!state->render.view_mask) {
-               radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
-            } else {
-               u_foreach_bit(view, state->render.view_mask) {
-                  radv_emit_view_index(cmd_buffer, view);
-
-                  radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
-               }
-            }
-         }
-      }
-      if (drawCount > 1) {
-         state->last_drawid = drawCount - 1;
-      }
-   } else {
-      if (vertexOffset) {
+   if (vertexOffset) {
+      if (!uses_drawid) {
          if (cmd_buffer->device->physical_device->rad_info.gfx_level == GFX10) {
             /* GFX10 has a bug that consecutive draw packets with NOT_EOP must not have
              * count == 0 for the last draw that doesn't have NOT_EOP.
@@ -6698,56 +6637,81 @@ radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer,
             }
          }
 
-         radv_emit_userdata_vertex(cmd_buffer, info, *vertexOffset);
-         vk_foreach_multi_draw_indexed(draw, i, minfo, drawCount, stride) {
-            const uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-
-            /* Skip draw calls with 0-sized index buffers if the GPU can't handle them */
-            if (!remaining_indexes &&
-                cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug)
-               continue;
-
-            const uint64_t index_va = state->index_va + draw->firstIndex * index_size;
+      }
+      radv_emit_userdata_vertex(cmd_buffer, info, *vertexOffset);
+   }
 
-            if (!state->render.view_mask) {
-               radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, can_eop && i < drawCount - 1);
-            } else {
-               u_foreach_bit(view, state->render.view_mask) {
-                  radv_emit_view_index(cmd_buffer, view);
+   vk_foreach_multi_draw_indexed(draw, i, minfo, drawCount, stride) {
+      const uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
+      bool offset_changes = false;
 
-                  radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
-               }
-            }
-         }
-      } else {
-         vk_foreach_multi_draw_indexed(draw, i, minfo, drawCount, stride) {
-            const uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-
-            /* Skip draw calls with 0-sized index buffers if the GPU can't handle them */
-            if (!remaining_indexes &&
-                cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug)
-               continue;
+      /* Skip draw calls with 0-sized index buffers if the GPU can't handle them */
+      if (!remaining_indexes &&
+          cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug)
+         continue;
 
+      if (!vertexOffset) {
+         if (uses_drawid) {
+            if (i > 0) {
+               if (state->last_vertex_offset != draw->vertexOffset)
+                  radv_emit_userdata_vertex_drawid(cmd_buffer, draw->vertexOffset, i);
+               else
+                  radeon_set_sh_reg(cs, state->graphics_pipeline->vtx_base_sgpr + sizeof(uint32_t), i);
+            } else
+               radv_emit_userdata_vertex(cmd_buffer, info, draw->vertexOffset);
+         } else {
             const VkMultiDrawIndexedInfoEXT *next = (const VkMultiDrawIndexedInfoEXT*)(i < drawCount - 1 ? ((uint8_t*)draw + stride) : NULL);
-            const bool offset_changes = next && next->vertexOffset != draw->vertexOffset;
+            offset_changes = next && next->vertexOffset != draw->vertexOffset;
             radv_emit_userdata_vertex(cmd_buffer, info, draw->vertexOffset);
+         }
+      }
 
-            const uint64_t index_va = state->index_va + draw->firstIndex * index_size;
+      if (vertexOffset && uses_drawid) {
+         if (i > 0)
+            radeon_set_sh_reg(cs, state->graphics_pipeline->vtx_base_sgpr + sizeof(uint32_t), i);
+      }
 
-            if (!state->render.view_mask) {
-               radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, can_eop && !offset_changes && i < drawCount - 1);
-            } else {
-               u_foreach_bit(view, state->render.view_mask) {
-                  radv_emit_view_index(cmd_buffer, view);
+      const uint64_t index_va = state->index_va + draw->firstIndex * index_size;
 
-                  radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
-               }
-            }
+      if (!state->render.view_mask) {
+         radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, can_eop && !offset_changes && i < drawCount - 1);
+      } else {
+         u_foreach_bit(view, state->render.view_mask) {
+            radv_emit_view_index(cmd_buffer, view);
+
+            radv_cs_emit_draw_indexed_packet(cmd_buffer, index_va, remaining_indexes, draw->indexCount, false);
          }
       }
-      if (drawCount > 1) {
-         state->last_drawid = drawCount - 1;
-      }
+   }
+
+   if (drawCount > 1) {
+      state->last_drawid = drawCount - 1;
+   }
+}
+
+ALWAYS_INLINE static void
+radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer,
+                               const struct radv_draw_info *info,
+                               uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *minfo,
+                               uint32_t stride,
+                               const int32_t *vertexOffset)
+
+{
+   struct radv_cmd_state *state = &cmd_buffer->state;
+   const bool uses_drawid = state->graphics_pipeline->uses_drawid;
+   const bool can_eop =
+      !uses_drawid && cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX10;
+
+   if (uses_drawid) {
+      if (vertexOffset)
+         radv_emit_draw_packets_indexed_internal(cmd_buffer, info, drawCount, minfo, stride, vertexOffset, true, can_eop);
+      else
+         radv_emit_draw_packets_indexed_internal(cmd_buffer, info, drawCount, minfo, stride, NULL, true, can_eop);
+   } else {
+      if (vertexOffset)
+         radv_emit_draw_packets_indexed_internal(cmd_buffer, info, drawCount, minfo, stride, vertexOffset, false, can_eop);
+      else
+         radv_emit_draw_packets_indexed_internal(cmd_buffer, info, drawCount, minfo, stride, NULL, false, can_eop);
    }
 }
 
-- 
GitLab


From 053d90b8f42f1a5aa522d65a16749408c678d962 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 14 Sep 2022 21:00:15 -0400
Subject: [PATCH 21/21] radv: use the vertexOffset path for indexed draws

this is slightly (~1%) faster
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index df28d35262d4..0c17d49d5ac0 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7720,7 +7720,7 @@ radv_CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t
    if (!radv_before_draw(cmd_buffer, &info, 1))
       return;
    const VkMultiDrawIndexedInfoEXT minfo = { firstIndex, indexCount, vertexOffset };
-   radv_emit_draw_packets_indexed(cmd_buffer, &info, 1, &minfo, 0, NULL);
+   radv_emit_draw_packets_indexed(cmd_buffer, &info, 1, &minfo, 0, &vertexOffset);
    radv_after_draw(cmd_buffer);
 }
 
-- 
GitLab

