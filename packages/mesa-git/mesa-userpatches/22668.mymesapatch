From 47c235da721907f99d99af591dc6074a01457a67 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 24 Apr 2023 14:46:04 +0200
Subject: [PATCH 1/5] radv/amdgpu: Remove unused extra BO array.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Not needed anymore.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c | 16 ++++------------
 1 file changed, 4 insertions(+), 12 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index c6fae4f977a8..8a9dcb3f5d1f 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -756,8 +756,7 @@ radv_amdgpu_add_cs_to_bo_list(struct radv_amdgpu_cs *cs, struct drm_amdgpu_bo_li
 
 static VkResult
 radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs_array,
-                        unsigned count, struct radv_amdgpu_winsys_bo **extra_bo_array,
-                        unsigned num_extra_bo, struct radeon_cmdbuf **extra_cs_array,
+                        unsigned count, struct radeon_cmdbuf **extra_cs_array,
                         unsigned num_extra_cs, unsigned *rnum_handles,
                         struct drm_amdgpu_bo_list_entry **rhandles)
 {
@@ -775,8 +774,7 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
          handles[i].bo_priority = ws->global_bo_list.bos[i]->priority;
          num_handles++;
       }
-   } else if (count == 1 && !num_extra_bo && !num_extra_cs &&
-              !radv_amdgpu_cs(cs_array[0])->num_virtual_buffers &&
+   } else if (count == 1 && !num_extra_cs && !radv_amdgpu_cs(cs_array[0])->num_virtual_buffers &&
               !radv_amdgpu_cs(cs_array[0])->chained_to && !ws->global_bo_list.count) {
       struct radv_amdgpu_cs *cs = (struct radv_amdgpu_cs *)cs_array[0];
       if (cs->num_buffers == 0)
@@ -789,8 +787,7 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
       memcpy(handles, cs->handles, sizeof(handles[0]) * cs->num_buffers);
       num_handles = cs->num_buffers;
    } else {
-      unsigned total_buffer_count = num_extra_bo;
-      num_handles = num_extra_bo;
+      unsigned total_buffer_count = 0;
       for (unsigned i = 0; i < count; ++i) {
          struct radv_amdgpu_cs *start_cs = (struct radv_amdgpu_cs *)cs_array[i];
          for (struct radv_amdgpu_cs *cs = start_cs; cs; cs = cs->chained_to) {
@@ -814,11 +811,6 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
       if (!handles)
          return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-      for (unsigned i = 0; i < num_extra_bo; i++) {
-         handles[i].bo_handle = extra_bo_array[i]->bo_handle;
-         handles[i].bo_priority = extra_bo_array[i]->priority;
-      }
-
       for (unsigned i = 0; i < count + num_extra_cs; ++i) {
          struct radv_amdgpu_cs *start_cs = i >= count
                                               ? (struct radv_amdgpu_cs *)extra_cs_array[i - count]
@@ -889,7 +881,7 @@ radv_amdgpu_winsys_cs_submit_internal(
       extra_cs[extra_cs_idx++] = postamble_cs[i];
 
    u_rwlock_rdlock(&ws->global_bo_list.lock);
-   result = radv_amdgpu_get_bo_list(ws, &cs_array[0], cs_count, NULL, 0, extra_cs, num_extra_cs,
+   result = radv_amdgpu_get_bo_list(ws, &cs_array[0], cs_count, extra_cs, num_extra_cs,
                                     &num_handles, &handles);
    if (result != VK_SUCCESS)
       goto fail;
-- 
GitLab


From 85d449b141483f8c506c246b484817d843f11bea Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 24 Apr 2023 15:11:49 +0200
Subject: [PATCH 2/5] radv/amdgpu: Split radv_amdgpu_get_bo_list to smaller
 functions.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c | 111 ++++++++++--------
 1 file changed, 63 insertions(+), 48 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index 8a9dcb3f5d1f..fe38cefe1528 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -706,6 +706,35 @@ radv_amdgpu_cs_execute_secondary(struct radeon_cmdbuf *_parent, struct radeon_cm
    }
 }
 
+static unsigned
+radv_amdgpu_count_cs_bo(struct radv_amdgpu_cs *start_cs)
+{
+   unsigned num_bo = 0;
+
+   for (struct radv_amdgpu_cs *cs = start_cs; cs; cs = cs->chained_to) {
+      num_bo += cs->num_buffers;
+      for (unsigned j = 0; j < cs->num_virtual_buffers; ++j)
+         num_bo += radv_amdgpu_winsys_bo(cs->virtual_buffers[j])->bo_count;
+   }
+
+   return num_bo;
+}
+
+static unsigned
+radv_amdgpu_count_cs_array_bo(struct radeon_cmdbuf **cs_array, unsigned num_cs)
+{
+   if (!num_cs)
+      return 0;
+
+   unsigned num_bo = 0;
+
+   for (unsigned i = 0; i < num_cs; ++i) {
+      num_bo += radv_amdgpu_count_cs_bo(radv_amdgpu_cs(cs_array[i]));
+   }
+
+   return num_bo;
+}
+
 static unsigned
 radv_amdgpu_add_cs_to_bo_list(struct radv_amdgpu_cs *cs, struct drm_amdgpu_bo_list_entry *handles,
                               unsigned num_handles)
@@ -754,6 +783,31 @@ radv_amdgpu_add_cs_to_bo_list(struct radv_amdgpu_cs *cs, struct drm_amdgpu_bo_li
    return num_handles;
 }
 
+static unsigned
+radv_amdgpu_add_cs_array_to_bo_list(struct radeon_cmdbuf **cs_array, unsigned num_cs,
+                                    struct drm_amdgpu_bo_list_entry *handles, unsigned num_handles)
+{
+   for (unsigned i = 0; i < num_cs; ++i) {
+      for (struct radv_amdgpu_cs *cs = radv_amdgpu_cs(cs_array[i]); cs; cs = cs->chained_to) {
+         num_handles = radv_amdgpu_add_cs_to_bo_list(cs, handles, num_handles);
+      }
+   }
+
+   return num_handles;
+}
+
+static unsigned
+radv_amdgpu_copy_all_bo_list(struct radv_amdgpu_winsys *ws,
+                             struct drm_amdgpu_bo_list_entry *handles)
+{
+   for (uint32_t i = 0; i < ws->global_bo_list.count; i++) {
+      handles[i].bo_handle = ws->global_bo_list.bos[i]->bo_handle;
+      handles[i].bo_priority = ws->global_bo_list.bos[i]->priority;
+   }
+
+   return ws->global_bo_list.count;
+}
+
 static VkResult
 radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs_array,
                         unsigned count, struct radeon_cmdbuf **extra_cs_array,
@@ -765,15 +819,10 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
 
    if (ws->debug_all_bos) {
       handles = malloc(sizeof(handles[0]) * ws->global_bo_list.count);
-      if (!handles) {
+      if (!handles)
          return VK_ERROR_OUT_OF_HOST_MEMORY;
-      }
 
-      for (uint32_t i = 0; i < ws->global_bo_list.count; i++) {
-         handles[i].bo_handle = ws->global_bo_list.bos[i]->bo_handle;
-         handles[i].bo_priority = ws->global_bo_list.bos[i]->priority;
-         num_handles++;
-      }
+      num_handles = radv_amdgpu_copy_all_bo_list(ws, handles);
    } else if (count == 1 && !num_extra_cs && !radv_amdgpu_cs(cs_array[0])->num_virtual_buffers &&
               !radv_amdgpu_cs(cs_array[0])->chained_to && !ws->global_bo_list.count) {
       struct radv_amdgpu_cs *cs = (struct radv_amdgpu_cs *)cs_array[0];
@@ -787,22 +836,9 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
       memcpy(handles, cs->handles, sizeof(handles[0]) * cs->num_buffers);
       num_handles = cs->num_buffers;
    } else {
-      unsigned total_buffer_count = 0;
-      for (unsigned i = 0; i < count; ++i) {
-         struct radv_amdgpu_cs *start_cs = (struct radv_amdgpu_cs *)cs_array[i];
-         for (struct radv_amdgpu_cs *cs = start_cs; cs; cs = cs->chained_to) {
-            total_buffer_count += cs->num_buffers;
-            for (unsigned j = 0; j < cs->num_virtual_buffers; ++j)
-               total_buffer_count += radv_amdgpu_winsys_bo(cs->virtual_buffers[j])->bo_count;
-         }
-      }
-
-      if (num_extra_cs) {
-         for (unsigned i = 0; i < num_extra_cs; ++i)
-            total_buffer_count += ((struct radv_amdgpu_cs *)extra_cs_array[i])->num_buffers;
-      }
-
-      total_buffer_count += ws->global_bo_list.count;
+      unsigned total_buffer_count = ws->global_bo_list.count;
+      total_buffer_count += radv_amdgpu_count_cs_array_bo(cs_array, count);
+      total_buffer_count += radv_amdgpu_count_cs_array_bo(extra_cs_array, num_extra_cs);
 
       if (total_buffer_count == 0)
          return VK_SUCCESS;
@@ -811,31 +847,10 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
       if (!handles)
          return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-      for (unsigned i = 0; i < count + num_extra_cs; ++i) {
-         struct radv_amdgpu_cs *start_cs = i >= count
-                                              ? (struct radv_amdgpu_cs *)extra_cs_array[i - count]
-                                              : (struct radv_amdgpu_cs *)cs_array[i];
-
-         for (struct radv_amdgpu_cs *cs = start_cs; cs; cs = cs->chained_to)
-            num_handles = radv_amdgpu_add_cs_to_bo_list(cs, handles, num_handles);
-      }
-
-      unsigned unique_bo_so_far = num_handles;
-      for (unsigned i = 0; i < ws->global_bo_list.count; ++i) {
-         struct radv_amdgpu_winsys_bo *bo = ws->global_bo_list.bos[i];
-         bool found = false;
-         for (unsigned j = 0; j < unique_bo_so_far; ++j) {
-            if (bo->bo_handle == handles[j].bo_handle) {
-               found = true;
-               break;
-            }
-         }
-         if (!found) {
-            handles[num_handles].bo_handle = bo->bo_handle;
-            handles[num_handles].bo_priority = bo->priority;
-            ++num_handles;
-         }
-      }
+      num_handles = radv_amdgpu_copy_all_bo_list(ws, handles);
+      num_handles = radv_amdgpu_add_cs_array_to_bo_list(cs_array, count, handles, num_handles);
+      num_handles =
+         radv_amdgpu_add_cs_array_to_bo_list(extra_cs_array, num_extra_cs, handles, num_handles);
    }
 
    *rhandles = handles;
-- 
GitLab


From edfa92ce9558268c0146aca033eafeb1c796b82f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 24 Apr 2023 16:25:11 +0200
Subject: [PATCH 3/5] radv/amdgpu: Pass preambles to get_bo_list.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Instead of allocating an array for them.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c | 40 +++++++++----------
 1 file changed, 20 insertions(+), 20 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index fe38cefe1528..2ed33a170389 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -810,8 +810,11 @@ radv_amdgpu_copy_all_bo_list(struct radv_amdgpu_winsys *ws,
 
 static VkResult
 radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs_array,
-                        unsigned count, struct radeon_cmdbuf **extra_cs_array,
-                        unsigned num_extra_cs, unsigned *rnum_handles,
+                        unsigned count, struct radeon_cmdbuf **initial_preamble_array,
+                        unsigned num_initial_preambles,
+                        struct radeon_cmdbuf **continue_preamble_array,
+                        unsigned num_continue_preambles, struct radeon_cmdbuf **postamble_array,
+                        unsigned num_postambles, unsigned *rnum_handles,
                         struct drm_amdgpu_bo_list_entry **rhandles)
 {
    struct drm_amdgpu_bo_list_entry *handles = NULL;
@@ -823,7 +826,8 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
          return VK_ERROR_OUT_OF_HOST_MEMORY;
 
       num_handles = radv_amdgpu_copy_all_bo_list(ws, handles);
-   } else if (count == 1 && !num_extra_cs && !radv_amdgpu_cs(cs_array[0])->num_virtual_buffers &&
+   } else if (count == 1 && !num_initial_preambles && !num_continue_preambles && !num_postambles &&
+              !radv_amdgpu_cs(cs_array[0])->num_virtual_buffers &&
               !radv_amdgpu_cs(cs_array[0])->chained_to && !ws->global_bo_list.count) {
       struct radv_amdgpu_cs *cs = (struct radv_amdgpu_cs *)cs_array[0];
       if (cs->num_buffers == 0)
@@ -838,7 +842,11 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
    } else {
       unsigned total_buffer_count = ws->global_bo_list.count;
       total_buffer_count += radv_amdgpu_count_cs_array_bo(cs_array, count);
-      total_buffer_count += radv_amdgpu_count_cs_array_bo(extra_cs_array, num_extra_cs);
+      total_buffer_count +=
+         radv_amdgpu_count_cs_array_bo(initial_preamble_array, num_initial_preambles);
+      total_buffer_count +=
+         radv_amdgpu_count_cs_array_bo(continue_preamble_array, num_continue_preambles);
+      total_buffer_count += radv_amdgpu_count_cs_array_bo(postamble_array, num_postambles);
 
       if (total_buffer_count == 0)
          return VK_SUCCESS;
@@ -849,8 +857,12 @@ radv_amdgpu_get_bo_list(struct radv_amdgpu_winsys *ws, struct radeon_cmdbuf **cs
 
       num_handles = radv_amdgpu_copy_all_bo_list(ws, handles);
       num_handles = radv_amdgpu_add_cs_array_to_bo_list(cs_array, count, handles, num_handles);
+      num_handles = radv_amdgpu_add_cs_array_to_bo_list(
+         initial_preamble_array, num_initial_preambles, handles, num_handles);
+      num_handles = radv_amdgpu_add_cs_array_to_bo_list(
+         continue_preamble_array, num_continue_preambles, handles, num_handles);
       num_handles =
-         radv_amdgpu_add_cs_array_to_bo_list(extra_cs_array, num_extra_cs, handles, num_handles);
+         radv_amdgpu_add_cs_array_to_bo_list(postamble_array, num_postambles, handles, num_handles);
    }
 
    *rhandles = handles;
@@ -883,21 +895,10 @@ radv_amdgpu_winsys_cs_submit_internal(
    struct drm_amdgpu_bo_list_entry *handles = NULL;
    unsigned num_handles = 0;
 
-   unsigned num_extra_cs = initial_preamble_count + continue_preamble_count + postamble_count;
-   unsigned extra_cs_idx = 0;
-
-   STACK_ARRAY(struct radeon_cmdbuf *, extra_cs, num_extra_cs);
-
-   for (unsigned i = 0; i < initial_preamble_count; i++)
-      extra_cs[extra_cs_idx++] = initial_preamble_cs[i];
-   for (unsigned i = 0; i < continue_preamble_count; i++)
-      extra_cs[extra_cs_idx++] = continue_preamble_cs[i];
-   for (unsigned i = 0; i < postamble_count; i++)
-      extra_cs[extra_cs_idx++] = postamble_cs[i];
-
    u_rwlock_rdlock(&ws->global_bo_list.lock);
-   result = radv_amdgpu_get_bo_list(ws, &cs_array[0], cs_count, extra_cs, num_extra_cs,
-                                    &num_handles, &handles);
+   result = radv_amdgpu_get_bo_list(
+      ws, &cs_array[0], cs_count, initial_preamble_cs, initial_preamble_count, continue_preamble_cs,
+      continue_preamble_count, postamble_cs, postamble_count, &num_handles, &handles);
    if (result != VK_SUCCESS)
       goto fail;
 
@@ -1010,7 +1011,6 @@ radv_amdgpu_winsys_cs_submit_internal(
    radv_assign_last_submit(ctx, &request);
 
 fail:
-   STACK_ARRAY_FINISH(extra_cs);
    u_rwlock_rdunlock(&ws->global_bo_list.lock);
    return result;
 }
-- 
GitLab


From 065e2c35b5599dd55f9a0874c120f099e360955e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 24 Apr 2023 16:46:41 +0200
Subject: [PATCH 4/5] radv/amdgpu: Use STACK_ARRAY for IB array to reduce stack
 usage.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index 2ed33a170389..9092f0c9d830 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -902,9 +902,15 @@ radv_amdgpu_winsys_cs_submit_internal(
    if (result != VK_SUCCESS)
       goto fail;
 
+   assert(cs_count);
+   const unsigned num_pre_post_cs =
+      MAX2(initial_preamble_count, continue_preamble_count) + postamble_count;
+   assert(num_pre_post_cs < RADV_MAX_IBS_PER_SUBMIT);
+   const unsigned ib_array_size = MIN2(RADV_MAX_IBS_PER_SUBMIT, num_pre_post_cs + cs_count);
+   STACK_ARRAY(struct radv_amdgpu_cs_ib_info, ibs, ib_array_size);
+
    /* Configure the CS request. */
    const uint8_t *max_ib_per_ip = ws->info.max_submitted_ibs;
-   struct radv_amdgpu_cs_ib_info ibs[RADV_MAX_IBS_PER_SUBMIT];
    struct radv_amdgpu_cs_request request = {
       .ip_type = last_cs->hw_ip,
       .ip_instance = 0,
@@ -915,10 +921,6 @@ radv_amdgpu_winsys_cs_submit_internal(
       .number_of_ibs = 0, /* set below */
    };
 
-   assert(cs_count);
-   assert(MAX2(initial_preamble_count, continue_preamble_count) + postamble_count <
-          RADV_MAX_IBS_PER_SUBMIT);
-
    for (unsigned cs_idx = 0, cs_ib_idx = 0; cs_idx < cs_count;) {
       struct radeon_cmdbuf **preambles = cs_idx ? continue_preamble_cs : initial_preamble_cs;
       const unsigned preamble_count = cs_idx ? continue_preamble_count : initial_preamble_count;
@@ -1004,6 +1006,7 @@ radv_amdgpu_winsys_cs_submit_internal(
    }
 
    free(request.handles);
+   STACK_ARRAY_FINISH(ibs);
 
    if (result != VK_SUCCESS)
       goto fail;
-- 
GitLab


From 312ce6f4b07376c1b1ee7dffed3ed12bed8c05e2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 24 Apr 2023 17:13:38 +0200
Subject: [PATCH 5/5] radv: Move perf counter CS creation to where it's used.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/vulkan/radv_queue.c | 33 ++++++++++++++-------------------
 1 file changed, 14 insertions(+), 19 deletions(-)

diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index 4ec2e6329d1f..b40668811df7 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -1617,25 +1617,6 @@ radv_queue_submit_normal(struct radv_queue *queue, struct vk_queue_submit *submi
       wait_count += 1;
    }
 
-   struct radeon_cmdbuf *perf_ctr_lock_cs = NULL;
-   struct radeon_cmdbuf *perf_ctr_unlock_cs = NULL;
-
-   if (use_perf_counters) {
-      /* Create the lock/unlock CS. */
-      perf_ctr_lock_cs =
-         radv_create_perf_counter_lock_cs(queue->device, submission->perf_pass_index, false);
-      perf_ctr_unlock_cs =
-         radv_create_perf_counter_lock_cs(queue->device, submission->perf_pass_index, true);
-
-      /* RADV only supports perf counters on the GFX queue currently. */
-      assert(radv_queue_ring(queue) == AMD_IP_GFX);
-
-      if (!perf_ctr_lock_cs || !perf_ctr_unlock_cs) {
-         result = VK_ERROR_OUT_OF_HOST_MEMORY;
-         goto fail;
-      }
-   }
-
    /* For fences on the same queue/vm amdgpu doesn't wait till all processing is finished
     * before starting the next cmdbuffer, so we need to do it here.
     */
@@ -1654,6 +1635,20 @@ radv_queue_submit_normal(struct radv_queue *queue, struct vk_queue_submit *submi
       continue_preambles[num_continue_preambles++] = queue->state.continue_preamble_cs;
 
       if (use_perf_counters) {
+         /* RADV only supports perf counters on the GFX queue currently. */
+         assert(radv_queue_ring(queue) == AMD_IP_GFX);
+
+         /* Create the lock/unlock CS. */
+         struct radeon_cmdbuf *perf_ctr_lock_cs =
+            radv_create_perf_counter_lock_cs(queue->device, submission->perf_pass_index, false);
+         struct radeon_cmdbuf *perf_ctr_unlock_cs =
+            radv_create_perf_counter_lock_cs(queue->device, submission->perf_pass_index, true);
+
+         if (!perf_ctr_lock_cs || !perf_ctr_unlock_cs) {
+            result = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto fail;
+         }
+
          initial_preambles[num_initial_preambles++] = perf_ctr_lock_cs;
          continue_preambles[num_continue_preambles++] = perf_ctr_lock_cs;
          postambles[num_postambles++] = perf_ctr_unlock_cs;
-- 
GitLab

