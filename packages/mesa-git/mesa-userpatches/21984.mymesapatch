From 79164b2f96459f5019a449d89072e07e296f2e43 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 17 Mar 2023 13:57:00 +0100
Subject: [PATCH 1/6] mesa: fix CopyImageSubDataOES with
 GL_TEXTURE_EXTERNAL_OES
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

GL_TEXTURE_EXTERNAL_OES is allowed on GLES (any version) and glCopyImageSubDataOES
is implemented as an alias of CopyImageSubData.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/mesa/main/copyimage.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/mesa/main/copyimage.c b/src/mesa/main/copyimage.c
index 91746dddec9b..29dac7358cbf 100644
--- a/src/mesa/main/copyimage.c
+++ b/src/mesa/main/copyimage.c
@@ -103,6 +103,9 @@ prepare_target_err(struct gl_context *ctx, GLuint name, GLenum target,
       break;
    case GL_TEXTURE_EXTERNAL_OES:
       /* Only exists in ES */
+      if (_mesa_is_gles(ctx))
+         break;
+      /* fallthrough */
    case GL_TEXTURE_BUFFER:
    default:
       _mesa_error(ctx, GL_INVALID_ENUM,
-- 
GitLab


From 0f8fa51fcc0e7c21e11a4aae607b1799af29cccb Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 21 Mar 2023 10:54:16 +0100
Subject: [PATCH 2/6] amd/surface: rename metadata functions
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Use more specific verbs to avoid confusion:
   set -> apply
   get -> compute

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/amd/common/ac_surface.c               | 20 ++++++++++----------
 src/amd/common/ac_surface.h               | 22 +++++++++++-----------
 src/amd/vulkan/radv_image.c               | 12 ++++++------
 src/gallium/drivers/radeonsi/si_texture.c | 16 ++++++++--------
 src/gallium/winsys/amdgpu/drm/amdgpu_bo.c |  6 +++---
 5 files changed, 38 insertions(+), 38 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 2fa029900ad2..45aaf6b773cd 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -2634,8 +2634,8 @@ static unsigned eg_tile_split_rev(unsigned eg_tile_split)
 #define AMDGPU_TILING_DCC_MAX_COMPRESSED_BLOCK_SIZE_MASK  0x3
 
 /* This should be called before ac_compute_surface. */
-void ac_surface_set_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                uint64_t tiling_flags, enum radeon_surf_mode *mode)
+void ac_surface_apply_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                  uint64_t tiling_flags, enum radeon_surf_mode *mode)
 {
    bool scanout;
 
@@ -2674,8 +2674,8 @@ void ac_surface_set_bo_metadata(const struct radeon_info *info, struct radeon_su
       surf->flags &= ~RADEON_SURF_SCANOUT;
 }
 
-void ac_surface_get_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                uint64_t *tiling_flags)
+void ac_surface_compute_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                    uint64_t *tiling_flags)
 {
    *tiling_flags = 0;
 
@@ -2727,9 +2727,9 @@ static uint32_t ac_get_umd_metadata_word1(const struct radeon_info *info)
 }
 
 /* This should be called after ac_compute_surface. */
-bool ac_surface_set_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                 unsigned num_storage_samples, unsigned num_mipmap_levels,
-                                 unsigned size_metadata, const uint32_t metadata[64])
+bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                   unsigned num_storage_samples, unsigned num_mipmap_levels,
+                                   unsigned size_metadata, const uint32_t metadata[64])
 {
    const uint32_t *desc = &metadata[2];
    uint64_t offset;
@@ -2819,9 +2819,9 @@ bool ac_surface_set_umd_metadata(const struct radeon_info *info, struct radeon_s
    return true;
 }
 
-void ac_surface_get_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                 unsigned num_mipmap_levels, uint32_t desc[8],
-                                 unsigned *size_metadata, uint32_t metadata[64])
+void ac_surface_compute_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                     unsigned num_mipmap_levels, uint32_t desc[8],
+                                     unsigned *size_metadata, uint32_t metadata[64])
 {
    /* Clear the base address and set the relative DCC offset. */
    desc[0] = 0;
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index c8d3da7325c8..98d06019d3cd 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -440,17 +440,17 @@ int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *inf
                        struct radeon_surf *surf);
 void ac_surface_zero_dcc_fields(struct radeon_surf *surf);
 
-void ac_surface_set_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                uint64_t tiling_flags, enum radeon_surf_mode *mode);
-void ac_surface_get_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                uint64_t *tiling_flags);
-
-bool ac_surface_set_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                 unsigned num_storage_samples, unsigned num_mipmap_levels,
-                                 unsigned size_metadata, const uint32_t metadata[64]);
-void ac_surface_get_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
-                                 unsigned num_mipmap_levels, uint32_t desc[8],
-                                 unsigned *size_metadata, uint32_t metadata[64]);
+void ac_surface_apply_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                  uint64_t tiling_flags, enum radeon_surf_mode *mode);
+void ac_surface_compute_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                    uint64_t *tiling_flags);
+
+bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                   unsigned num_storage_samples, unsigned num_mipmap_levels,
+                                   unsigned size_metadata, const uint32_t metadata[64]);
+void ac_surface_compute_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
+                                     unsigned num_mipmap_levels, uint32_t desc[8],
+                                     unsigned *size_metadata, uint32_t metadata[64]);
 
 bool ac_surface_override_offset_stride(const struct radeon_info *info, struct radeon_surf *surf,
                                        unsigned num_mipmap_levels, uint64_t offset, unsigned pitch);
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index bf3c7a3b4743..836ad97bcaa3 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -1426,8 +1426,8 @@ radv_query_opaque_metadata(struct radv_device *device, struct radv_image *image,
                                   0, image->planes[0].surface.blk_w, false, false, false, false,
                                   desc, NULL);
 
-   ac_surface_get_umd_metadata(&device->physical_device->rad_info, &image->planes[0].surface,
-                               image->info.levels, desc, &md->size_metadata, md->metadata);
+   ac_surface_compute_umd_metadata(&device->physical_device->rad_info, &image->planes[0].surface,
+                                   image->info.levels, desc, &md->size_metadata, md->metadata);
 }
 
 void
@@ -1736,10 +1736,10 @@ radv_image_create_layout(struct radv_device *device, struct radv_image_create_in
       }
 
       if (create_info.bo_metadata && !mod_info &&
-          !ac_surface_set_umd_metadata(&device->physical_device->rad_info,
-                                       &image->planes[plane].surface, image_info.storage_samples,
-                                       image_info.levels, create_info.bo_metadata->size_metadata,
-                                       create_info.bo_metadata->metadata))
+          !ac_surface_apply_umd_metadata(&device->physical_device->rad_info,
+                                         &image->planes[plane].surface, image_info.storage_samples,
+                                         image_info.levels, create_info.bo_metadata->size_metadata,
+                                         create_info.bo_metadata->metadata))
          return VK_ERROR_INVALID_EXTERNAL_HANDLE;
 
       if (!create_info.no_metadata_planes && !create_info.bo_metadata && plane_count == 1 &&
diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index 43ac610e747c..b32055351102 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -553,9 +553,9 @@ static void si_set_tex_bo_metadata(struct si_screen *sscreen, struct si_texture
    si_set_mutable_tex_desc_fields(sscreen, tex, &tex->surface.u.legacy.level[0], 0, 0,
                                   tex->surface.blk_w, false, 0, desc);
 
-   ac_surface_get_umd_metadata(&sscreen->info, &tex->surface,
-                               tex->buffer.b.b.last_level + 1,
-                               desc, &md.size_metadata, md.metadata);
+   ac_surface_compute_umd_metadata(&sscreen->info, &tex->surface,
+                                   tex->buffer.b.b.last_level + 1,
+                                   desc, &md.size_metadata, md.metadata);
    sscreen->ws->buffer_set_metadata(sscreen->ws, tex->buffer.buf, &md, &tex->surface);
 }
 
@@ -1628,11 +1628,11 @@ static struct pipe_resource *si_texture_from_winsys_buffer(struct si_screen *ssc
       return NULL;
    }
 
-   if (!ac_surface_set_umd_metadata(&sscreen->info, &tex->surface,
-                                    tex->buffer.b.b.nr_storage_samples,
-                                    tex->buffer.b.b.last_level + 1,
-                                    metadata.size_metadata,
-                                    metadata.metadata)) {
+   if (!ac_surface_apply_umd_metadata(&sscreen->info, &tex->surface,
+                                      tex->buffer.b.b.nr_storage_samples,
+                                      tex->buffer.b.b.last_level + 1,
+                                      metadata.size_metadata,
+                                      metadata.metadata)) {
       si_texture_reference(&tex, NULL);
       return NULL;
    }
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
index d39ef610ed68..55b44eea8ed9 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
@@ -1312,8 +1312,8 @@ static void amdgpu_buffer_get_metadata(struct radeon_winsys *rws,
    if (r)
       return;
 
-   ac_surface_set_bo_metadata(&ws->info, surf, info.metadata.tiling_info,
-                              &md->mode);
+   ac_surface_apply_bo_metadata(&ws->info, surf, info.metadata.tiling_info,
+                                &md->mode);
 
    md->size_metadata = info.metadata.size_metadata;
    memcpy(md->metadata, info.metadata.umd_metadata, sizeof(md->metadata));
@@ -1330,7 +1330,7 @@ static void amdgpu_buffer_set_metadata(struct radeon_winsys *rws,
 
    assert(bo->bo && "must not be called for slab entries");
 
-   ac_surface_get_bo_metadata(&ws->info, surf, &metadata.tiling_info);
+   ac_surface_compute_bo_metadata(&ws->info, surf, &metadata.tiling_info);
 
    metadata.size_metadata = md->size_metadata;
    memcpy(metadata.umd_metadata, md->metadata, sizeof(md->metadata));
-- 
GitLab


From 8001a55c381a88a1357b79418ebd6c44c121d462 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 21 Mar 2023 10:46:39 +0100
Subject: [PATCH 3/6] ac/surface: introduce umd metadata v2

Update the metadata format. For gfx8- chips nothing change.

For gfx9 chips:
* for textures without a valid modifier a dw is added at index=10
  containing the stride
* for textures with a valid modifier the modifier is stored at
  index 10 and 11. Then the number of planes is stored at 12.
  Then for each plane the offset and the stride are stored.

The goal here is to be able to create textures from dmabuf from
umr - without these changes this is impossible because these
values can't be guessed.

The new layout is compatible with version=1 so old/new UMD can
be used together without issues and isn't used by default.
For radeonsi, it will be possible to use it with a AMD_DEBUG=...
option.
---
 src/amd/common/ac_surface.c               | 42 +++++++++++++++++++----
 src/amd/common/ac_surface.h               |  3 +-
 src/amd/vulkan/radv_image.c               |  3 +-
 src/gallium/drivers/radeonsi/si_texture.c |  3 +-
 4 files changed, 41 insertions(+), 10 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 45aaf6b773cd..acfa2a77c65d 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -2744,7 +2744,7 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
 
    if (offset ||                 /* Non-zero planes ignore metadata. */
        size_metadata < 10 * 4 || /* at least 2(header) + 8(desc) dwords */
-       metadata[0] == 0 ||       /* invalid version number */
+       metadata[0] == 0 ||       /* invalid version number (1 and 2 layouts are compatible) */
        metadata[1] != ac_get_umd_metadata_word1(info)) /* invalid PCI ID */ {
       /* Disable DCC because it might not be enabled. */
       ac_surface_zero_dcc_fields(surf);
@@ -2821,7 +2821,8 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
 
 void ac_surface_compute_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
                                      unsigned num_mipmap_levels, uint32_t desc[8],
-                                     unsigned *size_metadata, uint32_t metadata[64])
+                                     unsigned *size_metadata, uint32_t metadata[64],
+                                     bool include_tool_md)
 {
    /* Clear the base address and set the relative DCC offset. */
    desc[0] = 0;
@@ -2850,17 +2851,23 @@ void ac_surface_compute_umd_metadata(const struct radeon_info *info, struct rade
       assert(0);
    }
 
-   /* Metadata image format format version 1:
-    * [0] = 1 (metadata format identifier)
+   /* Metadata image format format version 1 and 2. Version 2 uses the same layout as
+    * version 1 with some additional fields (used if include_tool_md=true).
+    * [0] = metadata_format_identifier
     * [1] = (VENDOR_ID << 16) | PCI_ID
     * [2:9] = image descriptor for the whole resource
     *         [2] is always 0, because the base address is cleared
     *         [9] is the DCC offset bits [39:8] from the beginning of
     *             the buffer
-    * [10:10+LAST_LEVEL] = mipmap level offset bits [39:8] for each level
+    * gfx8-: [10:10+LAST_LEVEL] = mipmap level offset bits [39:8] for each level (gfx8-)
+    * ---- The data below is only set in version=2.
+    *      It shouldn't be used by the driver as it's only present to help
+    *      tools (eg: umr) that would want to access this buffer.
+    * gfx9+ if valid modifier: [10:11] = modifier
+    *                          [12:12+3*nplane] = [offset, stride]
+    *       else: [10]: stride
     */
-
-   metadata[0] = 1; /* metadata image format version 1 */
+   metadata[0] = include_tool_md ? 2 : 1; /* metadata image format version */
 
    /* Tiling modes are ambiguous without a PCI ID. */
    metadata[1] = ac_get_umd_metadata_word1(info);
@@ -2875,6 +2882,27 @@ void ac_surface_compute_umd_metadata(const struct radeon_info *info, struct rade
          metadata[10 + i] = surf->u.legacy.level[i].offset_256B;
 
       *size_metadata += num_mipmap_levels * 4;
+   } else if (include_tool_md) {
+      if (surf->modifier != DRM_FORMAT_MOD_INVALID) {
+         /* Modifier */
+         metadata[10] = surf->modifier;
+         metadata[11] = surf->modifier >> 32;
+         /* Num planes */
+         int nplanes = ac_surface_get_nplanes(surf);
+         metadata[12] = nplanes;
+         int ndw = 13;
+         for (int i = 0; i < nplanes; i++) {
+            metadata[ndw++] = ac_surface_get_plane_offset(info->gfx_level,
+                                                          surf, i, 0);
+            metadata[ndw++] = ac_surface_get_plane_stride(info->gfx_level,
+                                                          surf, i, 0);
+         }
+         *size_metadata = ndw * 4;
+      } else {
+         metadata[10] = ac_surface_get_plane_stride(info->gfx_level,
+                                                    surf, 0, 0);
+         *size_metadata = 11 * 4;
+      }
    }
 }
 
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index 98d06019d3cd..41a47b90e8d8 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -450,7 +450,8 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
                                    unsigned size_metadata, const uint32_t metadata[64]);
 void ac_surface_compute_umd_metadata(const struct radeon_info *info, struct radeon_surf *surf,
                                      unsigned num_mipmap_levels, uint32_t desc[8],
-                                     unsigned *size_metadata, uint32_t metadata[64]);
+                                     unsigned *size_metadata, uint32_t metadata[64],
+                                     bool include_tool_md);
 
 bool ac_surface_override_offset_stride(const struct radeon_info *info, struct radeon_surf *surf,
                                        unsigned num_mipmap_levels, uint64_t offset, unsigned pitch);
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 836ad97bcaa3..06f7f649a5b4 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -1427,7 +1427,8 @@ radv_query_opaque_metadata(struct radv_device *device, struct radv_image *image,
                                   desc, NULL);
 
    ac_surface_compute_umd_metadata(&device->physical_device->rad_info, &image->planes[0].surface,
-                                   image->info.levels, desc, &md->size_metadata, md->metadata);
+                                   image->info.levels, desc, &md->size_metadata, md->metadata,
+                                   false);
 }
 
 void
diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index b32055351102..f7ef69d1a979 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -555,7 +555,8 @@ static void si_set_tex_bo_metadata(struct si_screen *sscreen, struct si_texture
 
    ac_surface_compute_umd_metadata(&sscreen->info, &tex->surface,
                                    tex->buffer.b.b.last_level + 1,
-                                   desc, &md.size_metadata, md.metadata);
+                                   desc, &md.size_metadata, md.metadata,
+                                   false);
    sscreen->ws->buffer_set_metadata(sscreen->ws, tex->buffer.buf, &md, &tex->surface);
 }
 
-- 
GitLab


From d938fddf9710928a199f79b79c70abaa8900f22a Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 21 Mar 2023 10:46:53 +0100
Subject: [PATCH 4/6] radeonsi: add AMD_DEBUG=extra_md

When this debug flag is set, the driver sets the umd metadata for
all color textures and enables the use of extended metadata.

Extended metadata allows umr to import textures and setting these
on all color texture allows to import non-exported textures
(eg: dGPU draw surface when DRI_PRIME=1 is used).
---
 docs/envvars.rst                          | 2 ++
 src/gallium/drivers/radeonsi/si_pipe.c    | 2 ++
 src/gallium/drivers/radeonsi/si_pipe.h    | 2 ++
 src/gallium/drivers/radeonsi/si_texture.c | 9 ++++++++-
 4 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/docs/envvars.rst b/docs/envvars.rst
index 85d19303c816..de973e6ff3b4 100644
--- a/docs/envvars.rst
+++ b/docs/envvars.rst
@@ -1368,6 +1368,8 @@ RadeonSI driver environment variables
       Enable DPBB.
    ``dfsm``
       Enable DFSM.
+   ``extra_md``
+      add extra information in bo metadatas to help tools (umr)
 
 r600 driver environment variables
 ---------------------------------
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index c83716d29539..55b903502fde 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -119,6 +119,8 @@ static const struct debug_named_value radeonsi_debug_options[] = {
    {"nofmask", DBG(NO_FMASK), "Disable MSAA compression"},
    {"nodma", DBG(NO_DMA), "Disable SDMA-copy for DRI_PRIME"},
 
+   {"extra_md", DBG(EXTRA_METADATA), "Set UMD metadata for all textures and with additional fields for umr"},
+
    {"tmz", DBG(TMZ), "Force allocation of scanout/depth/stencil buffer as encrypted"},
    {"sqtt", DBG(SQTT), "Enable SQTT"},
 
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index cfa380480b94..91efb8b188d1 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -256,6 +256,8 @@ enum
    DBG_NO_FMASK,
    DBG_NO_DMA,
 
+   DBG_EXTRA_METADATA,
+
    DBG_TMZ,
    DBG_SQTT,
 
diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index f7ef69d1a979..8c5051e74f0a 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -556,7 +556,7 @@ static void si_set_tex_bo_metadata(struct si_screen *sscreen, struct si_texture
    ac_surface_compute_umd_metadata(&sscreen->info, &tex->surface,
                                    tex->buffer.b.b.last_level + 1,
                                    desc, &md.size_metadata, md.metadata,
-                                   false);
+                                   sscreen->debug_flags & DBG(EXTRA_METADATA));
    sscreen->ws->buffer_set_metadata(sscreen->ws, tex->buffer.buf, &md, &tex->surface);
 }
 
@@ -1307,6 +1307,11 @@ si_texture_create_with_modifier(struct pipe_screen *screen,
        */
       if (num_planes > 1)
          plane_templ[i].bind |= PIPE_BIND_SHARED;
+      /* Setting metadata on suballocated buffers is impossible. So use PIPE_BIND_CUSTOM to
+       * request a non-suballocated buffer.
+       */
+      if (!is_zs && sscreen->debug_flags & DBG(EXTRA_METADATA))
+         plane_templ[i].bind |= PIPE_BIND_CUSTOM;
 
       if (si_init_surface(sscreen, &surface[i], &plane_templ[i], tile_mode, modifier,
                           false, plane_templ[i].bind & PIPE_BIND_SCANOUT,
@@ -1340,6 +1345,8 @@ si_texture_create_with_modifier(struct pipe_screen *screen,
          last_plane->buffer.b.b.next = &tex->buffer.b.b;
          last_plane = tex;
       }
+      if (i == 0 && !is_zs && sscreen->debug_flags & DBG(EXTRA_METADATA))
+         si_set_tex_bo_metadata(sscreen, tex);
    }
 
    return (struct pipe_resource *)plane0;
-- 
GitLab


From 7c0a8e0685d452fa34f471b70afcfe767cdfdd74 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 22 Mar 2023 15:24:28 +0100
Subject: [PATCH 5/6] radeonsi: don't use si_decompress_dcc if the blitter is
 running
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Otherwise this will cause a blitter recursion which will crash at
some point.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/gallium/drivers/radeonsi/si_blit.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_blit.c b/src/gallium/drivers/radeonsi/si_blit.c
index 0450de767e6c..4d5adbbcef7b 100644
--- a/src/gallium/drivers/radeonsi/si_blit.c
+++ b/src/gallium/drivers/radeonsi/si_blit.c
@@ -1325,8 +1325,10 @@ void si_decompress_dcc(struct si_context *sctx, struct si_texture *tex)
 
    /* If graphics is disabled, we can't decompress DCC, but it shouldn't
     * be compressed either. The caller should simply discard it.
+    * If blitter is running, we can't decompress DCC either because it
+    * will cause a blitter recursion.
     */
-   if (!tex->surface.meta_offset || !sctx->has_graphics)
+   if (!tex->surface.meta_offset || !sctx->has_graphics || sctx->blitter_running)
       return;
 
    si_blit_decompress_color(sctx, tex, 0, tex->buffer.b.b.last_level, 0,
-- 
GitLab


From 380277c8ae40886fb99a6e7dbc674f282dd3aea3 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 24 Mar 2023 10:18:17 +0100
Subject: [PATCH 6/6] radv: add RADV_DEBUG=extra_md

This enables the use of UMD metadata v2. This allows tools (eg umr)
import buffers.
---
 docs/envvars.rst               | 2 ++
 src/amd/vulkan/radv_debug.h    | 1 +
 src/amd/vulkan/radv_image.c    | 2 +-
 src/amd/vulkan/radv_instance.c | 1 +
 4 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/docs/envvars.rst b/docs/envvars.rst
index de973e6ff3b4..105da9f7b890 100644
--- a/docs/envvars.rst
+++ b/docs/envvars.rst
@@ -1063,6 +1063,8 @@ RADV driver environment variables
       validate the LLVM IR before LLVM compiles the shader
    ``epilogs``
       dump fragment shader epilogs
+   ``extra_md``
+      add extra information in bo metadatas to help tools (umr)
    ``forcecompress``
       Enables DCC,FMASK,CMASK,HTILE in situations where the driver supports it
       but normally does not deem it beneficial.
diff --git a/src/amd/vulkan/radv_debug.h b/src/amd/vulkan/radv_debug.h
index 07d3033adbe8..74a373b22ea2 100644
--- a/src/amd/vulkan/radv_debug.h
+++ b/src/amd/vulkan/radv_debug.h
@@ -68,6 +68,7 @@ enum {
    RADV_DEBUG_DUMP_EPILOGS = 1ull << 37,
    RADV_DEBUG_NO_FMASK = 1ull << 38,
    RADV_DEBUG_SHADOW_REGS = 1ull << 39,
+   RADV_DEBUG_EXTRA_MD = 1ull << 40,
 };
 
 enum {
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 06f7f649a5b4..855d454248dd 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -1428,7 +1428,7 @@ radv_query_opaque_metadata(struct radv_device *device, struct radv_image *image,
 
    ac_surface_compute_umd_metadata(&device->physical_device->rad_info, &image->planes[0].surface,
                                    image->info.levels, desc, &md->size_metadata, md->metadata,
-                                   false);
+                                   device->instance->debug_flags & RADV_DEBUG_EXTRA_MD);
 }
 
 void
diff --git a/src/amd/vulkan/radv_instance.c b/src/amd/vulkan/radv_instance.c
index 14aa0c983ca0..032e03153140 100644
--- a/src/amd/vulkan/radv_instance.c
+++ b/src/amd/vulkan/radv_instance.c
@@ -74,6 +74,7 @@ static const struct debug_control radv_debug_options[] = {
    {"epilogs", RADV_DEBUG_DUMP_EPILOGS},
    {"nofmask", RADV_DEBUG_NO_FMASK},
    {"shadowregs", RADV_DEBUG_SHADOW_REGS},
+   {"extra_md", RADV_DEBUG_EXTRA_MD},
    {NULL, 0}};
 
 const char *
-- 
GitLab

