From 14c7247edf903af148b2ebe5127ef4c38a57435e Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 29 Aug 2022 10:53:28 +0530
Subject: [PATCH 1/5] radv: add shadowregs variable to RADV_DEBUG environment
 variable

Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
---
 docs/envvars.rst             | 2 ++
 src/amd/vulkan/radv_debug.h  | 1 +
 src/amd/vulkan/radv_device.c | 1 +
 3 files changed, 4 insertions(+)

diff --git a/docs/envvars.rst b/docs/envvars.rst
index 9cdfe36904e0..1533843fce01 100644
--- a/docs/envvars.rst
+++ b/docs/envvars.rst
@@ -743,6 +743,8 @@ RADV driver environment variables
       check for VM memory faults via dmesg
    ``zerovram``
       initialize all memory allocated in VRAM as zero
+   ``shadowregs``
+      enable register shadowing
 
 :envvar:`RADV_FORCE_FAMILY`
    create a null device to compile shaders without a AMD GPU (e.g. VEGA10)
diff --git a/src/amd/vulkan/radv_debug.h b/src/amd/vulkan/radv_debug.h
index 930dbd1c56f2..f83d2ffc933a 100644
--- a/src/amd/vulkan/radv_debug.h
+++ b/src/amd/vulkan/radv_debug.h
@@ -67,6 +67,7 @@ enum {
    RADV_DEBUG_NO_DMA_BLIT = 1ull << 36,
    RADV_DEBUG_SPLIT_FMA = 1ull << 37,
    RADV_DEBUG_DUMP_EPILOGS = 1ull << 38,
+   RADV_DEBUG_SHADOW_REGS = 1ull << 39,
 };
 
 enum {
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index a311e65a573f..007e17148d3e 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -980,6 +980,7 @@ static const struct debug_control radv_debug_options[] = {
    {"prologs", RADV_DEBUG_DUMP_PROLOGS},
    {"nodma", RADV_DEBUG_NO_DMA_BLIT},
    {"epilogs", RADV_DEBUG_DUMP_EPILOGS},
+   {"shadowregs", RADV_DEBUG_SHADOW_REGS},
    {NULL, 0}};
 
 const char *
-- 
GitLab


From 1b146ecfe9d1fbc7ada904797b94cf8ceca2558e Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 29 Aug 2022 20:46:15 +0530
Subject: [PATCH 2/5] radv: add shadowed_regs bo variable to struct radv_device

---
 src/amd/vulkan/radv_private.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index dc5c6738d8a6..73f03f933cc4 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -826,6 +826,8 @@ struct radv_device {
    uint32_t gfx_init_size_dw;
    struct radeon_winsys_bo *gfx_init;
 
+   struct radeon_winsys_bo *shadowed_regs;
+
    struct radeon_winsys_bo *trace_bo;
    uint32_t *trace_id_ptr;
 
-- 
GitLab


From ba39a93ad7713f7b157682da601bbefdb731bc77 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 29 Aug 2022 21:07:32 +0530
Subject: [PATCH 3/5] radv: port si_cp_reg_shadowing from radeonsi to radv

---
 src/amd/vulkan/meson.build           |   1 +
 src/amd/vulkan/radv_private.h        |   2 +
 src/amd/vulkan/si_cp_reg_shadowing.c | 197 +++++++++++++++++++++++++++
 3 files changed, 200 insertions(+)
 create mode 100644 src/amd/vulkan/si_cp_reg_shadowing.c

diff --git a/src/amd/vulkan/meson.build b/src/amd/vulkan/meson.build
index 0074b323cac1..262a352d0ac1 100644
--- a/src/amd/vulkan/meson.build
+++ b/src/amd/vulkan/meson.build
@@ -94,6 +94,7 @@ libradv_files = files(
   'radv_query.c',
   'radv_wsi.c',
   'si_cmd_buffer.c',
+  'si_cp_reg_shadowing.c',
   'vk_format.h',
 )
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 73f03f933cc4..ddca6dcde34d 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1708,6 +1708,8 @@ void si_cp_dma_clear_buffer(struct radv_cmd_buffer *cmd_buffer, uint64_t va, uin
                             unsigned value);
 void si_cp_dma_wait_for_idle(struct radv_cmd_buffer *cmd_buffer);
 
+void si_init_cp_reg_shadowing(struct radv_device *device, struct radeon_cmdbuf *cs);
+
 void radv_set_db_count_control(struct radv_cmd_buffer *cmd_buffer, bool enable_occlusion_queries);
 uint32_t radv_get_pa_su_sc_mode_cntl(const struct radv_cmd_buffer *cmd_buffer);
 uint32_t radv_get_vgt_index_size(uint32_t type);
diff --git a/src/amd/vulkan/si_cp_reg_shadowing.c b/src/amd/vulkan/si_cp_reg_shadowing.c
new file mode 100644
index 000000000000..0af33bea4c1c
--- /dev/null
+++ b/src/amd/vulkan/si_cp_reg_shadowing.c
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2020 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "radv_cs.h"
+#include "radv_private.h"
+#include "radv_debug.h"
+#include "sid.h"
+#include "ac_shadowed_regs.h"
+
+
+static void si_build_load_reg (struct radv_device *device, struct radeon_cmdbuf *cs,
+                               enum ac_reg_range_type type,
+                               uint64_t gpu_address)
+{
+   unsigned packet, num_ranges, offset;
+   const struct ac_reg_range *ranges;
+
+   ac_get_reg_ranges(device->physical_device->rad_info.gfx_level,
+                     device->physical_device->rad_info.family,
+                     type, &num_ranges, &ranges);
+
+
+   switch (type) {
+   case SI_REG_RANGE_UCONFIG:
+      gpu_address += SI_SHADOWED_UCONFIG_REG_OFFSET;
+      offset = CIK_UCONFIG_REG_OFFSET;
+      packet = PKT3_LOAD_UCONFIG_REG;
+      break;
+   case SI_REG_RANGE_CONTEXT:
+      gpu_address += SI_SHADOWED_CONTEXT_REG_OFFSET;
+      offset = SI_CONTEXT_REG_OFFSET;
+      packet = PKT3_LOAD_CONTEXT_REG;
+      break;
+   default:
+      gpu_address += SI_SHADOWED_SH_REG_OFFSET;
+      offset = SI_SH_REG_OFFSET;
+      packet = PKT3_LOAD_SH_REG;
+      break;
+   }
+
+   radeon_emit(cs, PKT3(packet, 1 + num_ranges * 2, 0));
+   radeon_emit(cs, gpu_address);
+   radeon_emit(cs, gpu_address >> 32);
+   for (unsigned i = 0; i < num_ranges; i++) {
+      radeon_emit(cs, (ranges[i].offset - offset) / 4);
+      radeon_emit(cs, ranges[i].size / 4);
+   }
+}
+
+static void
+si_create_shadowing_ib_preamble(struct radv_device *device, struct radeon_cmdbuf *cs,
+                                uint64_t gpu_address)
+{
+   struct radv_physical_device *physical_device = device->physical_device;
+
+   /* Wait for idle, because we'll update VGT ring pointers. */
+   radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
+   radeon_emit(cs, EVENT_TYPE(V_028A90_VS_PARTIAL_FLUSH) | EVENT_INDEX(4));
+
+   /* VGT_FLUSH is required even if VGT is idle. It resets VGT pointers. */
+   radeon_emit(cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
+   radeon_emit(cs, EVENT_TYPE(V_028A90_VGT_FLUSH) | EVENT_INDEX(0));
+
+   if (physical_device->rad_info.gfx_level >= GFX11) {
+      /* We must wait for idle using an EOP event before changing the attribute ring registers.
+       * Use the bottom-of-pipe EOP event, but increment the PWS counter instead of writing memory.
+       */
+      radeon_emit(cs, PKT3(PKT3_RELEASE_MEM, 6, 0));
+      radeon_emit(cs, S_490_EVENT_TYPE(V_028A90_BOTTOM_OF_PIPE_TS) |
+                          S_490_EVENT_INDEX(5) |
+                          S_490_PWS_ENABLE(1));
+      radeon_emit(cs, 0); /* DST_SEL, INT_SEL, DATA_SEL */
+      radeon_emit(cs, 0); /* ADDRESS_LO */
+      radeon_emit(cs, 0); /* ADDRESS_HI */
+      radeon_emit(cs, 0); /* DATA_LO */
+      radeon_emit(cs, 0); /* DATA_HI */
+      radeon_emit(cs, 0); /* INT_CTXID */
+
+      unsigned gcr_cntl = S_586_GL2_INV(1) | S_586_GL2_WB(1) |
+                          S_586_GLM_INV(1) | S_586_GLM_WB(1) |
+                          S_586_GL1_INV(1) | S_586_GLV_INV(1) |
+                          S_586_GLK_INV(1) | S_586_GLI_INV(V_586_GLI_ALL);
+
+      /* Wait for the PWS counter. */
+      radeon_emit(cs, PKT3(PKT3_ACQUIRE_MEM, 6, 0));
+      radeon_emit(cs, S_580_PWS_STAGE_SEL(V_580_CP_PFP) |
+                          S_580_PWS_COUNTER_SEL(V_580_TS_SELECT) |
+                          S_580_PWS_ENA2(1) |
+                          S_580_PWS_COUNT(0));
+      radeon_emit(cs, 0xffffffff); /* GCR_SIZE */
+      radeon_emit(cs, 0x01ffffff); /* GCR_SIZE_HI */
+      radeon_emit(cs, 0); /* GCR_BASE_LO */
+      radeon_emit(cs, 0); /* GCR_BASE_HI */
+      radeon_emit(cs, S_585_PWS_ENA(1));
+      radeon_emit(cs, gcr_cntl); /* GCR_CNTL */
+   } else if (physical_device->rad_info.gfx_level >= GFX10) {
+      unsigned gcr_cntl = S_586_GL2_INV(1) | S_586_GL2_WB(1) |
+                          S_586_GLM_INV(1) | S_586_GLM_WB(1) |
+                          S_586_GL1_INV(1) | S_586_GLV_INV(1) |
+                          S_586_GLK_INV(1) | S_586_GLI_INV(V_586_GLI_ALL);
+
+      radeon_emit(cs, PKT3(PKT3_ACQUIRE_MEM, 6, 0));
+      radeon_emit(cs, 0);           /* CP_COHER_CNTL */
+      radeon_emit(cs, 0xffffffff);  /* CP_COHER_SIZE */
+      radeon_emit(cs, 0xffffff);    /* CP_COHER_SIZE_HI */
+      radeon_emit(cs, 0);           /* CP_COHER_BASE */
+      radeon_emit(cs, 0);           /* CP_COHER_BASE_HI */
+      radeon_emit(cs, 0x0000000A);  /* POLL_INTERVAL */
+      radeon_emit(cs, gcr_cntl);    /* GCR_CNTL */
+
+      radeon_emit(cs, PKT3(PKT3_PFP_SYNC_ME, 0, 0));
+      radeon_emit(cs, 0);
+   } else if (physical_device->rad_info.gfx_level == GFX9) {
+      unsigned cp_coher_cntl = S_0301F0_SH_ICACHE_ACTION_ENA(1) |
+                               S_0301F0_SH_KCACHE_ACTION_ENA(1) |
+                               S_0301F0_TC_ACTION_ENA(1) |
+                               S_0301F0_TCL1_ACTION_ENA(1) |
+                               S_0301F0_TC_WB_ACTION_ENA(1);
+
+      radeon_emit(cs, PKT3(PKT3_ACQUIRE_MEM, 5, 0));
+      radeon_emit(cs, cp_coher_cntl); /* CP_COHER_CNTL */
+      radeon_emit(cs, 0xffffffff);    /* CP_COHER_SIZE */
+      radeon_emit(cs, 0xffffff);      /* CP_COHER_SIZE_HI */
+      radeon_emit(cs, 0);             /* CP_COHER_BASE */
+      radeon_emit(cs, 0);             /* CP_COHER_BASE_HI */
+      radeon_emit(cs, 0x0000000A);    /* POLL_INTERVAL */
+
+      radeon_emit(cs, PKT3(PKT3_PFP_SYNC_ME, 0, 0));
+      radeon_emit(cs, 0);
+   } else {
+      unreachable("invalid chip");
+   }
+
+   radeon_emit(cs, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
+   radeon_emit(cs,
+                  CC0_UPDATE_LOAD_ENABLES(1) |
+                  CC0_LOAD_PER_CONTEXT_STATE(1) |
+                  CC0_LOAD_CS_SH_REGS(1) |
+                  CC0_LOAD_GFX_SH_REGS(1) |
+                  CC0_LOAD_GLOBAL_UCONFIG(1));
+   radeon_emit(cs,
+                  CC1_UPDATE_SHADOW_ENABLES(1) |
+                  CC1_SHADOW_PER_CONTEXT_STATE(1) |
+                  CC1_SHADOW_CS_SH_REGS(1) |
+                  CC1_SHADOW_GFX_SH_REGS(1) |
+                  CC1_SHADOW_GLOBAL_UCONFIG(1));
+
+   for (unsigned i = 0; i < SI_NUM_SHADOWED_REG_RANGES; i++)
+      si_build_load_reg(device, cs, i, gpu_address);
+
+   return;
+}
+
+static void si_set_context_reg_array(struct radeon_cmdbuf *cs, unsigned reg, unsigned num,
+                                     const uint32_t *values)
+{
+   radeon_set_context_reg_seq(cs, reg, num);
+   radeon_emit_array(cs, values, num);
+}
+
+void si_init_cp_reg_shadowing(struct radv_device *device, struct radeon_cmdbuf *cs)
+{
+   struct radv_physical_device *physical_device = device->physical_device;
+   VkResult result;
+
+   /* freeing device->shadowed_regs done in separate patch */
+   result = device->ws->buffer_create(device->ws, SI_SHADOWED_REG_BUFFER_SIZE,
+                                      4096, RADEON_DOMAIN_VRAM,
+                                      RADEON_FLAG_ZERO_VRAM | RADEON_FLAG_NO_INTERPROCESS_SHARING,
+                                      RADV_BO_PRIORITY_SCRATCH, 0, &device->shadowed_regs);
+   if (result != VK_SUCCESS)
+      return;
+
+   si_create_shadowing_ib_preamble(device, cs, device->shadowed_regs->va);
+   ac_emulate_clear_state(&physical_device->rad_info, cs, si_set_context_reg_array);
+}
-- 
GitLab


From 6b0edfc4429de5aff69da0c903c8213d25761f96 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 29 Aug 2022 21:59:22 +0530
Subject: [PATCH 4/5] radv: destroy device->shadowed_regs bo

Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/amd/vulkan/radv_device.c         | 4 ++++
 src/amd/vulkan/si_cp_reg_shadowing.c | 1 -
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 007e17148d3e..8bcac6330b42 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -3761,6 +3761,8 @@ fail:
       device->ws->buffer_destroy(device->ws, device->perf_counter_bo);
    if (device->gfx_init)
       device->ws->buffer_destroy(device->ws, device->gfx_init);
+   if (device->shadowed_regs)
+      device->ws->buffer_destroy(device->ws, device->shadowed_regs);
 
    radv_device_finish_notifier(device);
    radv_device_finish_vs_prologs(device);
@@ -3801,6 +3803,8 @@ radv_DestroyDevice(VkDevice _device, const VkAllocationCallbacks *pAllocator)
 
    if (device->gfx_init)
       device->ws->buffer_destroy(device->ws, device->gfx_init);
+   if (device->shadowed_regs)
+      device->ws->buffer_destroy(device->ws, device->shadowed_regs);
 
    radv_device_finish_notifier(device);
    radv_device_finish_vs_prologs(device);
diff --git a/src/amd/vulkan/si_cp_reg_shadowing.c b/src/amd/vulkan/si_cp_reg_shadowing.c
index 0af33bea4c1c..fc5c6e7c7fb9 100644
--- a/src/amd/vulkan/si_cp_reg_shadowing.c
+++ b/src/amd/vulkan/si_cp_reg_shadowing.c
@@ -184,7 +184,6 @@ void si_init_cp_reg_shadowing(struct radv_device *device, struct radeon_cmdbuf *
    struct radv_physical_device *physical_device = device->physical_device;
    VkResult result;
 
-   /* freeing device->shadowed_regs done in separate patch */
    result = device->ws->buffer_create(device->ws, SI_SHADOWED_REG_BUFFER_SIZE,
                                       4096, RADEON_DOMAIN_VRAM,
                                       RADEON_FLAG_ZERO_VRAM | RADEON_FLAG_NO_INTERPROCESS_SHARING,
-- 
GitLab


From 5de29f752314a68aacfadf49d55ce87ab87c93ec Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 29 Aug 2022 22:14:27 +0530
Subject: [PATCH 5/5] radv: enable shadowed regs for mcbp

Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/amd/vulkan/radv_device.c   |  2 ++
 src/amd/vulkan/si_cmd_buffer.c | 18 ++++++++++++------
 2 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 8bcac6330b42..ae211202106d 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -4356,6 +4356,8 @@ radv_init_graphics_state(struct radeon_cmdbuf *cs, struct radv_device *device)
       radeon_emit(cs, device->gfx_init_size_dw & 0xffff);
 
       radv_cs_add_buffer(device->ws, cs, device->gfx_init);
+      if (device->shadowed_regs)
+         radv_cs_add_buffer(device->ws, cs, device->shadowed_regs);
    } else {
       si_emit_graphics(device, cs);
    }
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index fdc8ab5ddd6d..872d47152b08 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -30,6 +30,7 @@
 #include "radv_cs.h"
 #include "radv_private.h"
 #include "radv_shader.h"
+#include "radv_debug.h"
 #include "sid.h"
 
 static void
@@ -201,13 +202,18 @@ si_emit_graphics(struct radv_device *device, struct radeon_cmdbuf *cs)
    bool has_clear_state = physical_device->rad_info.has_clear_state;
    int i;
 
-   radeon_emit(cs, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
-   radeon_emit(cs, CC0_UPDATE_LOAD_ENABLES(1));
-   radeon_emit(cs, CC1_UPDATE_SHADOW_ENABLES(1));
+   if (physical_device->rad_info.mid_command_buffer_preemption_enabled ||
+       device->instance->debug_flags & RADV_DEBUG_SHADOW_REGS) {
+      si_init_cp_reg_shadowing(device, cs);
+   } else {
+      radeon_emit(cs, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
+      radeon_emit(cs, CC0_UPDATE_LOAD_ENABLES(1));
+      radeon_emit(cs, CC1_UPDATE_SHADOW_ENABLES(1));
 
-   if (has_clear_state) {
-      radeon_emit(cs, PKT3(PKT3_CLEAR_STATE, 0, 0));
-      radeon_emit(cs, 0);
+      if (has_clear_state) {
+         radeon_emit(cs, PKT3(PKT3_CLEAR_STATE, 0, 0));
+         radeon_emit(cs, 0);
+      }
    }
 
    if (physical_device->rad_info.gfx_level <= GFX8)
-- 
GitLab

