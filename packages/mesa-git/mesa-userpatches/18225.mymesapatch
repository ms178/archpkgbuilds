From a8f7d132f71d4f713e6223d0f8e91e0b4577dc08 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 29 Jul 2022 15:47:13 +0100
Subject: [PATCH 1/6] radv: remove claimed support for sRGB vertex buffer
 formats

These probably don't work.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Cc: mesa-stable
---
 src/amd/vulkan/radv_formats.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index bef8df6d97ac..b8d88dff31ae 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -747,9 +747,10 @@ radv_physical_device_get_format_properties(struct radv_physical_device *physical
    }
 
    if (radv_is_buffer_format_supported(format, &scaled)) {
-      if (format != VK_FORMAT_R64_UINT && format != VK_FORMAT_R64_SINT) {
+      if (format != VK_FORMAT_R64_UINT && format != VK_FORMAT_R64_SINT &&
+          !vk_format_is_srgb(format)) {
          buffer |= VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT;
-         if (!scaled && !vk_format_is_srgb(format))
+         if (!scaled)
             buffer |= VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT;
       }
       buffer |= VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT |
-- 
GitLab


From 8260e1e3624cda731fdd0db782269d9b52257ec5 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 4 Aug 2022 17:54:56 +0100
Subject: [PATCH 2/6] radv: fix 16-bit support in radv_lower_vs_input

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Fixes: b366fef091d ("radv: optimize the number of loaded components for VS inputs in NIR")
---
 src/amd/vulkan/radv_pipeline.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 40ec9cbdb343..44ed64ccfa8f 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -4022,9 +4022,10 @@ radv_lower_vs_input(nir_shader *nir, const struct radv_pipeline_key *pipeline_ke
             if (swizzle[i + component] < num_channels) {
                channels[i] = nir_channel(&b, &intrin->dest.ssa, swizzle[idx]);
             } else if (i + component == 3) {
-               channels[i] = is_float ? nir_imm_float(&b, 1.0f) : nir_imm_int(&b, 1u);
+               channels[i] = is_float ? nir_imm_floatN_t(&b, 1.0f, intrin->dest.ssa.bit_size)
+                                      : nir_imm_intN_t(&b, 1u, intrin->dest.ssa.bit_size);
             } else {
-               channels[i] = nir_imm_zero(&b, 1, 32);
+               channels[i] = nir_imm_zero(&b, 1, intrin->dest.ssa.bit_size);
             }
          }
 
-- 
GitLab


From a9e69d4e99bee9ca42184b6e422da3f8d769100a Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 4 Aug 2022 17:56:20 +0100
Subject: [PATCH 3/6] aco: fix 16-bit VS inputs

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Fixes: 3fba5bb9cc4 ("aco: implement 16-bit vertex fetches with tbuffer_load_format_d16_*")
---
 src/amd/compiler/aco_instruction_selection.cpp | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 88f833812eb4..8af82507a635 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5561,7 +5561,7 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
          bool use_mubuf =
             (nfmt == V_008F0C_BUF_NUM_FORMAT_FLOAT || nfmt == V_008F0C_BUF_NUM_FORMAT_UINT ||
              nfmt == V_008F0C_BUF_NUM_FORMAT_SINT) &&
-            vtx_info->chan_byte_size == 4;
+            vtx_info->chan_byte_size == 4 && bitsize != 16;
          unsigned fetch_dfmt = V_008F0C_BUF_DATA_FORMAT_INVALID;
          if (!use_mubuf) {
             fetch_dfmt =
@@ -5652,7 +5652,7 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
             mtbuf->mtbuf().vtx_binding = attrib_binding + 1;
          }
 
-         emit_split_vector(ctx, fetch_dst, fetch_dst.size());
+         emit_split_vector(ctx, fetch_dst, fetch_dst.bytes() * 8 / bitsize);
 
          if (fetch_component == 1) {
             channels[channel_start] = fetch_dst;
@@ -5684,11 +5684,11 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
                num_temp++;
                elems[i] = channel;
             } else if (is_float && idx == 3) {
-               vec->operands[i] = Operand::c32(0x3f800000u);
+               vec->operands[i] = bitsize == 16 ? Operand::c16(0x3c00u) : Operand::c32(0x3f800000u);
             } else if (!is_float && idx == 3) {
-               vec->operands[i] = Operand::c32(1u);
+               vec->operands[i] = Operand::get_const(ctx->options->gfx_level, 1u, bitsize / 8u);
             } else {
-               vec->operands[i] = Operand::zero();
+               vec->operands[i] = Operand::zero(bitsize / 8u);
             }
          }
          vec->definitions[0] = Definition(dst);
-- 
GitLab


From 4e18ba992db2d944c7740b8322ae27331d847afd Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 4 Aug 2022 20:44:47 +0100
Subject: [PATCH 4/6] radv/llvm: fix packed VS inputs on GFX6/GFX10+

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/ci/radv-navi21-llvm-fails.txt | 38 ---------------------------
 src/amd/vulkan/radv_nir_to_llvm.c     |  4 +--
 2 files changed, 1 insertion(+), 41 deletions(-)

diff --git a/src/amd/ci/radv-navi21-llvm-fails.txt b/src/amd/ci/radv-navi21-llvm-fails.txt
index b41dc1088172..ae89187eea71 100644
--- a/src/amd/ci/radv-navi21-llvm-fails.txt
+++ b/src/amd/ci/radv-navi21-llvm-fails.txt
@@ -7,44 +7,6 @@ dEQP-VK.rasterization.rasterization_order_attachment_access.stencil.samples_8.mu
 dEQP-VK.graphicsfuzz.cov-fold-shift-gte32,Fail
 dEQP-VK.graphicsfuzz.cov-tail-duplicator-for-for-for,Fail
 
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.ivec4.as_a2r10g10b10_sint_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.ivec4.as_a2r10g10b10_sint_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat3.as_b10g11r11_ufloat_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat3.as_b10g11r11_ufloat_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2b10g10r10_snorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2b10g10r10_snorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2b10g10r10_unorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2b10g10r10_unorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_snorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_snorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_sscaled_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_sscaled_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_unorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_unorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_uscaled_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.mat4.as_a2r10g10b10_uscaled_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.uvec4.as_a2r10g10b10_uint_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.uvec4.as_a2r10g10b10_uint_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec3.as_b10g11r11_ufloat_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec3.as_b10g11r11_ufloat_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2b10g10r10_snorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2b10g10r10_snorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2b10g10r10_unorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2b10g10r10_unorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_snorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_snorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_sscaled_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_sscaled_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_unorm_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_unorm_pack32_rate_vertex,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_uscaled_pack32_rate_instance,Fail
-dEQP-VK.pipeline.monolithic.vertex_input.single_attribute.vec4.as_a2r10g10b10_uscaled_pack32_rate_vertex,Fail
-dEQP-VK.robustness.vertex_access.a2b10g10r10_unorm_pack32.draw.instance_out_of_bounds,Fail
-dEQP-VK.robustness.vertex_access.a2b10g10r10_unorm_pack32.draw.vertex_incomplete,Fail
-dEQP-VK.robustness.vertex_access.a2b10g10r10_unorm_pack32.draw.vertex_out_of_bounds,Fail
-dEQP-VK.robustness.vertex_access.a2b10g10r10_unorm_pack32.draw_indexed.indices_out_of_bounds,Fail
-dEQP-VK.robustness.vertex_access.a2b10g10r10_unorm_pack32.draw_indexed.last_index_out_of_bounds,Fail
-dEQP-VK.robustness.vertex_access.a2b10g10r10_unorm_pack32.draw_indexed.triangle_out_of_bounds,Fail
 dEQP-VK.spirv_assembly.instruction.compute.16bit_storage.uniform_16_to_32_chainaccess.uniform_0_1_0_1_float,Fail
 dEQP-VK.spirv_assembly.instruction.compute.16bit_storage.uniform_16_to_32_chainaccess.uniform_0_1_1_1_float,Fail
 dEQP-VK.spirv_assembly.instruction.compute.16bit_storage.uniform_16_to_32_chainaccess.uniform_0_1_2_1_float,Fail
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 7b36799be3d8..86a902ea6b37 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -444,12 +444,10 @@ load_vs_input(struct radv_shader_context *ctx, unsigned driver_location, LLVMTyp
     * dynamic) is unaligned and also if the VBO offset is aligned to a scalar (eg. stride is 8 and
     * VBO offset is 2 for R16G16B16A16_SNORM).
     */
-   if (ctx->ac.gfx_level == GFX6 || ctx->ac.gfx_level >= GFX10) {
+   if ((ctx->ac.gfx_level == GFX6 || ctx->ac.gfx_level >= GFX10) && vtx_info->chan_byte_size) {
       unsigned chan_format = vtx_info->chan_format;
       LLVMValueRef values[4];
 
-      assert(ctx->ac.gfx_level == GFX6 || ctx->ac.gfx_level >= GFX10);
-
       for (unsigned chan = 0; chan < num_channels; chan++) {
          unsigned chan_offset = attrib_offset + chan * vtx_info->chan_byte_size;
          LLVMValueRef chan_index = buffer_index;
-- 
GitLab


From 27befdb24bd83cde47d44654079116076afadf4e Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 10 Aug 2022 14:44:20 +0100
Subject: [PATCH 5/6] aco: don't expand vec3 VS input load to vec4 on GFX6

Removes the (small) possibility of invalid memory access.

fossil-db (pitcairn):
Totals from 35456 (26.15% of 135610) affected shaders:
MaxWaves: 259508 -> 260642 (+0.44%); split: +0.44%, -0.01%
Instrs: 7915383 -> 7965774 (+0.64%); split: -0.09%, +0.72%
CodeSize: 37163748 -> 37524804 (+0.97%); split: -0.04%, +1.01%
SGPRs: 1515128 -> 1513576 (-0.10%); split: -0.27%, +0.17%
VGPRs: 1218376 -> 1211160 (-0.59%); split: -0.71%, +0.12%
SpillSGPRs: 1152 -> 1144 (-0.69%)
Latency: 83777626 -> 83867137 (+0.11%); split: -0.61%, +0.72%
InvThroughput: 25722445 -> 25727745 (+0.02%); split: -0.23%, +0.25%
VClause: 232058 -> 230464 (-0.69%); split: -2.53%, +1.84%
SClause: 322579 -> 322108 (-0.15%); split: -0.76%, +0.61%
Copies: 547032 -> 547954 (+0.17%); split: -1.83%, +2.00%
Branches: 72538 -> 72542 (+0.01%)
PreVGPRs: 898453 -> 897584 (-0.10%); split: -0.13%, +0.03%

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Cc: mesa-stable
---
 src/amd/compiler/aco_instruction_selection.cpp | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 8af82507a635..9a0b7544698a 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5554,7 +5554,6 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
       while (channel_start < num_channels) {
          unsigned fetch_component = num_channels - channel_start;
          unsigned fetch_offset = attrib_offset + channel_start * vtx_info->chan_byte_size;
-         bool expanded = false;
 
          /* use MUBUF when possible to avoid possible alignment issues */
          /* TODO: we could use SDWA to unpack 8/16-bit attributes without extra instructions */
@@ -5568,11 +5567,9 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
                get_fetch_data_format(ctx, vtx_info, fetch_offset, &fetch_component,
                                      vtx_info->num_channels - channel_start, binding_align);
          } else {
-            if (fetch_component == 3 && ctx->options->gfx_level == GFX6) {
-               /* GFX6 only supports loading vec3 with MTBUF, expand to vec4. */
-               fetch_component = 4;
-               expanded = true;
-            }
+            /* GFX6 only supports loading vec3 with MTBUF, split to vec2,scalar. */
+            if (fetch_component == 3 && ctx->options->gfx_level == GFX6)
+               fetch_component = 2;
          }
 
          unsigned fetch_bytes = fetch_component * bitsize / 8;
@@ -5632,8 +5629,7 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
          }
 
          Temp fetch_dst;
-         if (channel_start == 0 && fetch_bytes == dst.bytes() && !expanded &&
-             num_channels <= 3) {
+         if (channel_start == 0 && fetch_bytes == dst.bytes() && num_channels <= 3) {
             direct_fetch = true;
             fetch_dst = dst;
          } else {
-- 
GitLab


From dc91c4b12a47a55d24730353e372401426ac9588 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 10 Aug 2022 14:45:06 +0100
Subject: [PATCH 6/6] aco: allow direct_fetch=true for vec4 VS input loads

This seems to be a (mostly harmless) mistake from 369b8cffea2.

fossil-db (navi21):
Totals from 15 (0.01% of 135636) affected shaders:
Instrs: 1992 -> 1999 (+0.35%)
Latency: 13557 -> 13567 (+0.07%); split: -0.24%, +0.31%
InvThroughput: 4059 -> 4065 (+0.15%); split: -0.20%, +0.34%
Copies: 186 -> 193 (+3.76%)

fossil-db (polaris10):
Totals from 5 (0.00% of 135610) affected shaders:

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 9a0b7544698a..03043a4a8331 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5629,7 +5629,7 @@ visit_load_input(isel_context* ctx, nir_intrinsic_instr* instr)
          }
 
          Temp fetch_dst;
-         if (channel_start == 0 && fetch_bytes == dst.bytes() && num_channels <= 3) {
+         if (channel_start == 0 && fetch_bytes == dst.bytes()) {
             direct_fetch = true;
             fetch_dst = dst;
          } else {
-- 
GitLab

