From 24b96f5155ca99df74a990db65d3c23d8adb180b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Sat, 6 Apr 2024 10:59:09 +0200
Subject: [PATCH 01/10] aco/lower_phis: simplify check for uniform predecessors

---
 src/amd/compiler/aco_lower_phis.cpp | 14 +-------------
 1 file changed, 1 insertion(+), 13 deletions(-)

diff --git a/src/amd/compiler/aco_lower_phis.cpp b/src/amd/compiler/aco_lower_phis.cpp
index d8813ce3d8308..c140aef5c4df0 100644
--- a/src/amd/compiler/aco_lower_phis.cpp
+++ b/src/amd/compiler/aco_lower_phis.cpp
@@ -25,8 +25,6 @@ enum class pred_defined : uint8_t {
 MESA_DEFINE_CPP_ENUM_BITFIELD_OPERATORS(pred_defined);
 
 struct ssa_state {
-   bool checked_preds_for_uniform;
-   bool all_preds_uniform;
    unsigned loop_nest_depth;
 
    std::vector<pred_defined> any_pred_defined;
@@ -302,16 +300,7 @@ void
 lower_divergent_bool_phi(Program* program, ssa_state* state, Block* block,
                          aco_ptr<Instruction>& phi)
 {
-   if (!state->checked_preds_for_uniform) {
-      state->all_preds_uniform = !(block->kind & block_kind_merge) &&
-                                 block->linear_preds.size() == block->logical_preds.size();
-      for (unsigned pred : block->logical_preds)
-         state->all_preds_uniform =
-            state->all_preds_uniform && (program->blocks[pred].kind & block_kind_uniform);
-      state->checked_preds_for_uniform = true;
-   }
-
-   if (state->all_preds_uniform) {
+   if (block->linear_preds == block->logical_preds) {
       phi->opcode = aco_opcode::p_linear_phi;
       return;
    }
@@ -377,7 +366,6 @@ lower_phis(Program* program)
    ssa_state state;
 
    for (Block& block : program->blocks) {
-      state.checked_preds_for_uniform = false;
       for (aco_ptr<Instruction>& phi : block.instructions) {
          if (phi->opcode == aco_opcode::p_phi) {
             assert(program->wave_size == 64 ? phi->definitions[0].regClass() != s1
-- 
GitLab


From b6b818deab90823ed7fb6eb2e8c8a5e9d1b77993 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 8 Apr 2024 16:15:53 +0200
Subject: [PATCH 02/10] aco: introduce aco_opcode::p_boolean_phi

This opcode is only used during instruction selection and
immediately lowered to linear phis afterwards.
---
 src/amd/compiler/aco_instruction_selection.cpp |  4 ++++
 src/amd/compiler/aco_lower_phis.cpp            | 12 ++++++------
 src/amd/compiler/aco_opcodes.py                |  1 +
 3 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 61515c3a789a3..91f6e7e30eef1 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10027,6 +10027,10 @@ visit_phi(isel_context* ctx, nir_phi_instr* instr)
    bool logical = !dst.is_linear() || instr->def.divergent;
    logical |= (ctx->block->kind & block_kind_merge) != 0;
    aco_opcode opcode = logical ? aco_opcode::p_phi : aco_opcode::p_linear_phi;
+   if (instr->def.bit_size == 1) {
+      logical = true;
+      opcode = aco_opcode::p_boolean_phi;
+   }
 
    /* we want a sorted list of sources, since the predecessor list is also sorted */
    std::map<unsigned, nir_def*> phi_src;
diff --git a/src/amd/compiler/aco_lower_phis.cpp b/src/amd/compiler/aco_lower_phis.cpp
index c140aef5c4df0..69d46fa743a51 100644
--- a/src/amd/compiler/aco_lower_phis.cpp
+++ b/src/amd/compiler/aco_lower_phis.cpp
@@ -367,12 +367,12 @@ lower_phis(Program* program)
 
    for (Block& block : program->blocks) {
       for (aco_ptr<Instruction>& phi : block.instructions) {
-         if (phi->opcode == aco_opcode::p_phi) {
-            assert(program->wave_size == 64 ? phi->definitions[0].regClass() != s1
-                                            : phi->definitions[0].regClass() != s2);
-            if (phi->definitions[0].regClass() == program->lane_mask)
-               lower_divergent_bool_phi(program, &state, &block, phi);
-            else if (phi->definitions[0].regClass().is_subdword())
+         if (phi->opcode == aco_opcode::p_boolean_phi) {
+            assert(program->wave_size == 64 ? phi->definitions[0].regClass() == s2
+                                            : phi->definitions[0].regClass() == s1);
+            lower_divergent_bool_phi(program, &state, &block, phi);
+         } else if (phi->opcode == aco_opcode::p_phi) {
+            if (phi->definitions[0].regClass().is_subdword())
                lower_subdword_phis(program, &block, phi);
          } else if (!is_phi(phi)) {
             break;
diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index 7f6a63bd1cdb0..aabfec6fb98a4 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -326,6 +326,7 @@ insn("p_startpgm")
 insn("p_return")
 insn("p_phi")
 insn("p_linear_phi")
+insn("p_boolean_phi")
 insn("p_as_uniform")
 insn("p_unit_test")
 
-- 
GitLab


From 1a66756baf88ae007edfea0558976760704af7ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 8 Apr 2024 13:47:25 +0200
Subject: [PATCH 03/10] aco/vn: copy-propagate trivial phis

Totals from 267 (0.34% of 79395) affected shaders: (GFX10.3)
Instrs: 591240 -> 590909 (-0.06%); split: -0.14%, +0.08%
CodeSize: 3165484 -> 3161896 (-0.11%); split: -0.20%, +0.08%
SpillSGPRs: 1252 -> 1243 (-0.72%); split: -0.80%, +0.08%
Latency: 7258799 -> 7257095 (-0.02%); split: -0.04%, +0.01%
InvThroughput: 2605495 -> 2604066 (-0.05%); split: -0.07%, +0.01%
VClause: 10440 -> 10439 (-0.01%)
SClause: 18415 -> 18412 (-0.02%); split: -0.02%, +0.01%
Copies: 68809 -> 68509 (-0.44%); split: -1.10%, +0.66%
Branches: 19840 -> 19841 (+0.01%); split: -0.14%, +0.14%
PreVGPRs: 15503 -> 15479 (-0.15%); split: -0.16%, +0.01%
VALU: 407817 -> 407491 (-0.08%); split: -0.18%, +0.10%
SALU: 81116 -> 81121 (+0.01%); split: -0.04%, +0.04%
---
 src/amd/compiler/aco_opt_value_numbering.cpp | 24 ++++++++++++++------
 1 file changed, 17 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_opt_value_numbering.cpp b/src/amd/compiler/aco_opt_value_numbering.cpp
index 281e1119a8a09..42797f0024675 100644
--- a/src/amd/compiler/aco_opt_value_numbering.cpp
+++ b/src/amd/compiler/aco_opt_value_numbering.cpp
@@ -316,6 +316,16 @@ can_eliminate(aco_ptr<Instruction>& instr)
    return true;
 }
 
+bool
+is_trivial_phi(Instruction* instr)
+{
+   if (!is_phi(instr))
+      return false;
+
+   return std::all_of(instr->operands.begin(), instr->operands.end(),
+                      [&](Operand& op) { return op == instr->operands[0]; });
+}
+
 void
 process_block(vn_ctx& ctx, Block& block)
 {
@@ -336,14 +346,9 @@ process_block(vn_ctx& ctx, Block& block)
           instr->opcode == aco_opcode::p_demote_to_helper || instr->opcode == aco_opcode::p_end_wqm)
          ctx.exec_id++;
 
-      if (!can_eliminate(instr)) {
-         new_instructions.emplace_back(std::move(instr));
-         continue;
-      }
-
       /* simple copy-propagation through renaming */
       bool copy_instr =
-         instr->opcode == aco_opcode::p_parallelcopy ||
+         is_trivial_phi(instr.get()) || instr->opcode == aco_opcode::p_parallelcopy ||
          (instr->opcode == aco_opcode::p_create_vector && instr->operands.size() == 1);
       if (copy_instr && !instr->definitions[0].isFixed() && instr->operands[0].isTemp() &&
           instr->operands[0].regClass() == instr->definitions[0].regClass()) {
@@ -351,6 +356,11 @@ process_block(vn_ctx& ctx, Block& block)
          continue;
       }
 
+      if (!can_eliminate(instr)) {
+         new_instructions.emplace_back(std::move(instr));
+         continue;
+      }
+
       instr->pass_flags = ctx.exec_id;
       std::pair<expr_set::iterator, bool> res = ctx.expr_values.emplace(instr.get(), block.index);
 
@@ -391,7 +401,7 @@ void
 rename_phi_operands(Block& block, aco::unordered_map<uint32_t, Temp>& renames)
 {
    for (aco_ptr<Instruction>& phi : block.instructions) {
-      if (phi->opcode != aco_opcode::p_phi && phi->opcode != aco_opcode::p_linear_phi)
+      if (!is_phi(phi))
          break;
 
       for (Operand& op : phi->operands) {
-- 
GitLab


From 4e14b5177f9c107ecefced0693c28bc872a43df8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 9 Apr 2024 14:39:34 +0200
Subject: [PATCH 04/10] aco/lower_phis: generalize init_state() so that it
 works with any scalar phis

---
 src/amd/compiler/aco_lower_phis.cpp | 69 +++++++++++++++--------------
 1 file changed, 35 insertions(+), 34 deletions(-)

diff --git a/src/amd/compiler/aco_lower_phis.cpp b/src/amd/compiler/aco_lower_phis.cpp
index 69d46fa743a51..3b1026e18096b 100644
--- a/src/amd/compiler/aco_lower_phis.cpp
+++ b/src/amd/compiler/aco_lower_phis.cpp
@@ -26,6 +26,7 @@ MESA_DEFINE_CPP_ENUM_BITFIELD_OPERATORS(pred_defined);
 
 struct ssa_state {
    unsigned loop_nest_depth;
+   RegClass rc;
 
    std::vector<pred_defined> any_pred_defined;
    std::vector<bool> visited;
@@ -37,7 +38,7 @@ Operand get_output(Program* program, unsigned block_idx, ssa_state* state);
 void
 init_outputs(Program* program, ssa_state* state, unsigned start, unsigned end)
 {
-   for (unsigned i = start; i < end; ++i) {
+   for (unsigned i = start; i <= end; ++i) {
       if (state->visited[i])
          continue;
       state->outputs[i] = get_output(program, i, state);
@@ -51,11 +52,11 @@ get_output(Program* program, unsigned block_idx, ssa_state* state)
    Block& block = program->blocks[block_idx];
 
    if (state->any_pred_defined[block_idx] == pred_defined::undef)
-      return Operand(program->lane_mask);
+      return Operand(state->rc);
 
    if (block.loop_nest_depth < state->loop_nest_depth)
       /* loop-carried value for loop exit phis */
-      return Operand::zero(program->lane_mask.bytes());
+      return Operand::zero(state->rc.bytes());
 
    size_t num_preds = block.linear_preds.size();
 
@@ -75,7 +76,7 @@ get_output(Program* program, unsigned block_idx, ssa_state* state)
       unsigned start_idx = block_idx + 1;
       unsigned end_idx = block.linear_preds.back() + 1;
 
-      state->outputs[block_idx] = Operand(Temp(program->allocateTmp(program->lane_mask)));
+      state->outputs[block_idx] = Operand(Temp(program->allocateTmp(state->rc)));
       init_outputs(program, state, start_idx, end_idx);
       output = state->outputs[block_idx];
    } else if (std::all_of(block.linear_preds.begin() + 1, block.linear_preds.end(),
@@ -84,7 +85,7 @@ get_output(Program* program, unsigned block_idx, ssa_state* state)
                           })) {
       return state->outputs[block.linear_preds[0]];
    } else {
-      output = Operand(Temp(program->allocateTmp(program->lane_mask)));
+      output = Operand(Temp(program->allocateTmp(state->rc)));
    }
 
    /* create phi */
@@ -95,7 +96,7 @@ get_output(Program* program, unsigned block_idx, ssa_state* state)
    phi->definitions[0] = Definition(output.getTemp());
    block.instructions.emplace(block.instructions.begin(), std::move(phi));
 
-   assert(output.size() == program->lane_mask.size());
+   assert(output.size() == state->rc.size());
 
    return output;
 }
@@ -122,7 +123,7 @@ build_merge_code(Program* program, ssa_state* state, Block* block, Operand cur)
    Definition dst = Definition(state->outputs[block_idx].getTemp());
    Operand prev = get_output(program, block_idx, state);
    if (cur.isUndefined())
-      cur = Operand::zero(program->lane_mask.bytes());
+      return;
 
    Builder bld(program);
    auto IsLogicalEnd = [](const aco_ptr<Instruction>& instr) -> bool
@@ -223,6 +224,7 @@ init_state(Program* program, Block* block, ssa_state* state, aco_ptr<Instruction
    Builder bld(program);
 
    /* do this here to avoid resizing in case of no boolean phis */
+   state->rc = phi->definitions[0].regClass();
    state->visited.resize(program->blocks.size());
    state->outputs.resize(program->blocks.size());
    state->any_pred_defined.resize(program->blocks.size());
@@ -236,45 +238,37 @@ init_state(Program* program, Block* block, ssa_state* state, aco_ptr<Instruction
       if (phi->operands[i].isUndefined())
          continue;
       pred_defined defined = pred_defined::temp;
-      if (phi->operands[i].isConstant())
+      if (phi->operands[i].isConstant() && phi->opcode == aco_opcode::p_boolean_phi)
          defined = phi->operands[i].constantValue() ? pred_defined::const_1 : pred_defined::const_0;
       for (unsigned succ : program->blocks[block->logical_preds[i]].linear_succs)
          state->any_pred_defined[succ] |= defined;
    }
 
    unsigned start = block->logical_preds[0];
-   unsigned end = block->index;
+   unsigned end = block->linear_preds.back();
 
-   /* for loop exit phis, start at the loop pre-header */
-   if (block->kind & block_kind_loop_exit) {
+   /* For boolean loop exit phis, start at the loop pre-header */
+   if (block->kind & block_kind_loop_exit && phi->opcode == aco_opcode::p_boolean_phi) {
       while (program->blocks[start].loop_nest_depth >= state->loop_nest_depth)
          start--;
+      end = block->index - 1;
       /* If the loop-header has a back-edge, we need to insert a phi.
        * This will contain a defined value */
-      if (program->blocks[start + 1].linear_preds.size() > 1)
-         state->any_pred_defined[start + 1] = pred_defined::temp;
-   }
-   /* for loop header phis, end at the loop exit */
-   if (block->kind & block_kind_loop_header) {
-      while (program->blocks[end].loop_nest_depth >= state->loop_nest_depth)
-         end++;
-      /* don't propagate the incoming value */
-      state->any_pred_defined[block->index] = pred_defined::undef;
-   }
-
-   /* add dominating zero: this allows to emit simpler merge sequences
-    * if we can ensure that all disabled lanes are always zero on incoming values */
-   // TODO: find more occasions where pred_defined::zero is beneficial (e.g. with 2+ temp merges)
-   if (block->kind & block_kind_loop_exit) {
-      /* zero the loop-carried variable */
       if (program->blocks[start + 1].linear_preds.size() > 1) {
-         state->any_pred_defined[start + 1] |= pred_defined::zero;
-         // TODO: emit this zero explicitly
+         state->any_pred_defined[start + 1] = pred_defined::temp | pred_defined::zero;
+         /* add dominating zero: this allows to emit simpler merge sequences
+          * if we can ensure that all disabled lanes are always zero on incoming values
+          */
          state->any_pred_defined[start] = pred_defined::const_0;
       }
    }
 
-   for (unsigned j = start; j < end; j++) {
+   /* For loop header phis, don't propagate the incoming value */
+   if (block->kind & block_kind_loop_header) {
+      state->any_pred_defined[block->index] = pred_defined::undef;
+   }
+
+   for (unsigned j = start; j <= end; j++) {
       if (state->any_pred_defined[j] == pred_defined::undef)
          continue;
       for (unsigned succ : program->blocks[j].linear_succs)
@@ -284,12 +278,19 @@ init_state(Program* program, Block* block, ssa_state* state, aco_ptr<Instruction
    state->any_pred_defined[block->index] = pred_defined::undef;
 
    for (unsigned i = 0; i < phi->operands.size(); i++) {
+      /* If the Operand is undefined, just propagate the previous value. */
+      if (phi->operands[i].isUndefined())
+         continue;
+
       unsigned pred = block->logical_preds[i];
-      if (state->any_pred_defined[pred] != pred_defined::undef)
-         state->outputs[pred] = Operand(bld.tmp(bld.lm));
-      else
+      if (phi->opcode == aco_opcode::p_boolean_phi &&
+          state->any_pred_defined[pred] != pred_defined::undef) {
+         /* Needs merge code sequence. */
+         state->outputs[pred] = Operand(bld.tmp(state->rc));
+      } else {
          state->outputs[pred] = phi->operands[i];
-      assert(state->outputs[pred].size() == bld.lm.size());
+      }
+      assert(state->outputs[pred].size() == state->rc.size());
       state->visited[pred] = true;
    }
 
-- 
GitLab


From 78ba49833ddd76c6d093e7dc702c2c4badcfd903 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 9 Apr 2024 17:56:29 +0200
Subject: [PATCH 05/10] aco/lower_phis: implement scalar phi lowering

---
 src/amd/compiler/aco_lower_phis.cpp | 31 ++++++++++++++++++++++++++++-
 src/amd/compiler/tests/helpers.cpp  |  2 ++
 2 files changed, 32 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_lower_phis.cpp b/src/amd/compiler/aco_lower_phis.cpp
index 3b1026e18096b..a97ba24eda49b 100644
--- a/src/amd/compiler/aco_lower_phis.cpp
+++ b/src/amd/compiler/aco_lower_phis.cpp
@@ -334,6 +334,33 @@ lower_divergent_bool_phi(Program* program, ssa_state* state, Block* block,
    return;
 }
 
+void
+lower_scalar_phi(Program* program, ssa_state* state, Block* block, aco_ptr<Instruction>& phi)
+{
+   if (block->linear_preds == block->logical_preds) {
+      phi->opcode = aco_opcode::p_linear_phi;
+      return;
+   }
+
+   init_state(program, block, state, phi);
+
+   unsigned num_preds = block->linear_preds.size();
+   if (phi->operands.size() != num_preds) {
+      Instruction* new_phi{
+         create_instruction(aco_opcode::p_linear_phi, Format::PSEUDO, num_preds, 1)};
+      new_phi->definitions[0] = phi->definitions[0];
+      phi.reset(new_phi);
+   } else {
+      phi->opcode = aco_opcode::p_linear_phi;
+   }
+   assert(phi->operands.size() == num_preds);
+
+   for (unsigned i = 0; i < num_preds; i++)
+      phi->operands[i] = state->outputs[block->linear_preds[i]];
+
+   return;
+}
+
 void
 lower_subdword_phis(Program* program, Block* block, aco_ptr<Instruction>& phi)
 {
@@ -373,7 +400,9 @@ lower_phis(Program* program)
                                             : phi->definitions[0].regClass() == s1);
             lower_divergent_bool_phi(program, &state, &block, phi);
          } else if (phi->opcode == aco_opcode::p_phi) {
-            if (phi->definitions[0].regClass().is_subdword())
+            if (phi->definitions[0].regClass().type() == RegType::sgpr)
+               lower_scalar_phi(program, &state, &block, phi);
+            else if (phi->definitions[0].regClass().is_subdword())
                lower_subdword_phis(program, &block, phi);
          } else if (!is_phi(phi)) {
             break;
diff --git a/src/amd/compiler/tests/helpers.cpp b/src/amd/compiler/tests/helpers.cpp
index 4e1d57d231ab5..1dbc2bd4548db 100644
--- a/src/amd/compiler/tests/helpers.cpp
+++ b/src/amd/compiler/tests/helpers.cpp
@@ -344,6 +344,8 @@ finish_isel_test(enum ac_hw_stage hw_stage, unsigned wave_size)
    memset(&config, 0, sizeof(config));
 
    select_program(program.get(), 1, &nb->shader, &config, &options, &info, &args);
+   dominator_tree(program.get());
+   lower_phis(program.get());
 
    ralloc_free(nb->shader);
    glsl_type_singleton_decref();
-- 
GitLab


From 5dcb5dddc60e914fbc468b50cfcf4b13831eee22 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 9 Apr 2024 17:57:11 +0200
Subject: [PATCH 06/10] aco: use scalar phi lowering for uniform phis in
 divergent merge blocks

The fossil changes are due to a slightly different register allocation
from a reversed order of phi instructions.

Totals from 1620 (2.04% of 79395) affected shaders: (GFX10.3)
Instrs: 730683 -> 732621 (+0.27%); split: -0.02%, +0.28%
CodeSize: 3888464 -> 3898488 (+0.26%); split: -0.00%, +0.26%
Latency: 3274291 -> 3275549 (+0.04%); split: -0.02%, +0.06%
InvThroughput: 606625 -> 606661 (+0.01%); split: -0.00%, +0.01%
VClause: 9541 -> 9538 (-0.03%)
SClause: 17296 -> 17272 (-0.14%); split: -0.16%, +0.02%
Copies: 81392 -> 83231 (+2.26%); split: -0.17%, +2.43%
Branches: 27023 -> 27020 (-0.01%); split: -0.03%, +0.02%
VALU: 383380 -> 382749 (-0.16%)
SALU: 160895 -> 163369 (+1.54%); split: -0.03%, +1.57%
---
 .../compiler/aco_instruction_selection.cpp    | 28 -------------------
 1 file changed, 28 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 91f6e7e30eef1..a5bded1f9ec93 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10041,7 +10041,6 @@ visit_phi(isel_context* ctx, nir_phi_instr* instr)
    unsigned num_operands = 0;
    Operand* const operands = (Operand*)alloca(
       (std::max(exec_list_length(&instr->srcs), (unsigned)preds.size()) + 1) * sizeof(Operand));
-   unsigned num_defined = 0;
    unsigned cur_pred_idx = 0;
    for (std::pair<unsigned, nir_def*> src : phi_src) {
       if (cur_pred_idx < preds.size()) {
@@ -10066,7 +10065,6 @@ visit_phi(isel_context* ctx, nir_phi_instr* instr)
       cur_pred_idx++;
       Operand op = get_phi_operand(ctx, src.second, dst.regClass(), logical);
       operands[num_operands++] = op;
-      num_defined += !op.isUndefined();
    }
    /* handle block_kind_continue_or_break at loop exit blocks */
    while (cur_pred_idx++ < preds.size())
@@ -10083,32 +10081,6 @@ visit_phi(isel_context* ctx, nir_phi_instr* instr)
          operands[num_operands++] = Operand(RegClass());
    }
 
-   /* we can use a linear phi in some cases if one src is undef */
-   if (dst.is_linear() && ctx->block->kind & block_kind_merge && num_defined == 1) {
-      phi.reset(create_instruction(aco_opcode::p_linear_phi, Format::PSEUDO, num_operands, 1));
-
-      Block* linear_else = &ctx->program->blocks[ctx->block->linear_preds[1]];
-      Block* invert = &ctx->program->blocks[linear_else->linear_preds[0]];
-      assert(invert->kind & block_kind_invert);
-
-      unsigned then_block = invert->linear_preds[0];
-
-      Block* insert_block = NULL;
-      for (unsigned i = 0; i < num_operands; i++) {
-         Operand op = operands[i];
-         if (op.isUndefined())
-            continue;
-         insert_block = ctx->block->logical_preds[i] == then_block ? invert : ctx->block;
-         phi->operands[0] = op;
-         break;
-      }
-      assert(insert_block); /* should be handled by the "num_defined == 0" case above */
-      phi->operands[1] = Operand(dst.regClass());
-      phi->definitions[0] = Definition(dst);
-      insert_block->instructions.emplace(insert_block->instructions.begin(), std::move(phi));
-      return;
-   }
-
    phi.reset(create_instruction(opcode, Format::PSEUDO, num_operands, 1));
    for (unsigned i = 0; i < num_operands; i++)
       phi->operands[i] = operands[i];
-- 
GitLab


From 8202b7e3c01cf17a45680547b619e09be9f8b5ad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 9 Apr 2024 18:03:00 +0200
Subject: [PATCH 07/10] aco: use scalar phi lowering for all loop header phis

No fossil-db changes.
---
 .../compiler/aco_instruction_selection.cpp    | 80 +------------------
 1 file changed, 1 insertion(+), 79 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index a5bded1f9ec93..d9260a39a4edc 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10025,7 +10025,7 @@ visit_phi(isel_context* ctx, nir_phi_instr* instr)
    assert(instr->def.bit_size != 1 || dst.regClass() == ctx->program->lane_mask);
 
    bool logical = !dst.is_linear() || instr->def.divergent;
-   logical |= (ctx->block->kind & block_kind_merge) != 0;
+   logical |= ctx->block->kind & (block_kind_merge | block_kind_loop_header);
    aco_opcode opcode = logical ? aco_opcode::p_phi : aco_opcode::p_linear_phi;
    if (instr->def.bit_size == 1) {
       logical = true;
@@ -10070,17 +10070,6 @@ visit_phi(isel_context* ctx, nir_phi_instr* instr)
    while (cur_pred_idx++ < preds.size())
       operands[num_operands++] = Operand(dst.regClass());
 
-   /* If the loop ends with a break, still add a linear continue edge in case
-    * that break is divergent or continue_or_break is used. We'll either remove
-    * this operand later in visit_loop() if it's not necessary or replace the
-    * undef with something correct. */
-   if (!logical && ctx->block->kind & block_kind_loop_header) {
-      nir_loop* loop = nir_cf_node_as_loop(instr->instr.block->cf_node.parent);
-      nir_block* last = nir_loop_last_block(loop);
-      if (last->successors[0] != instr->instr.block)
-         operands[num_operands++] = Operand(RegClass());
-   }
-
    phi.reset(create_instruction(opcode, Format::PSEUDO, num_operands, 1));
    for (unsigned i = 0; i < num_operands; i++)
       phi->operands[i] = operands[i];
@@ -10324,52 +10313,6 @@ visit_block(isel_context* ctx, nir_block* block)
       ctx->cf_info.nir_to_aco[block->index] = ctx->block->index;
 }
 
-static Operand
-create_continue_phis(isel_context* ctx, unsigned first, unsigned last,
-                     aco_ptr<Instruction>& header_phi, Operand* vals)
-{
-   vals[0] = Operand(header_phi->definitions[0].getTemp());
-   RegClass rc = vals[0].regClass();
-
-   unsigned loop_nest_depth = ctx->program->blocks[first].loop_nest_depth;
-
-   unsigned next_pred = 1;
-
-   for (unsigned idx = first + 1; idx <= last; idx++) {
-      Block& block = ctx->program->blocks[idx];
-      if (block.loop_nest_depth != loop_nest_depth) {
-         vals[idx - first] = vals[idx - 1 - first];
-         continue;
-      }
-
-      if ((block.kind & block_kind_continue) && block.index != last) {
-         vals[idx - first] = header_phi->operands[next_pred];
-         next_pred++;
-         continue;
-      }
-
-      bool all_same = true;
-      for (unsigned i = 1; all_same && (i < block.linear_preds.size()); i++)
-         all_same = vals[block.linear_preds[i] - first] == vals[block.linear_preds[0] - first];
-
-      Operand val;
-      if (all_same) {
-         val = vals[block.linear_preds[0] - first];
-      } else {
-         aco_ptr<Instruction> phi(create_instruction(aco_opcode::p_linear_phi, Format::PSEUDO,
-                                                     block.linear_preds.size(), 1));
-         for (unsigned i = 0; i < block.linear_preds.size(); i++)
-            phi->operands[i] = vals[block.linear_preds[i] - first];
-         val = Operand(ctx->program->allocateTmp(rc));
-         phi->definitions[0] = Definition(val.getTemp());
-         block.instructions.emplace(block.instructions.begin(), std::move(phi));
-      }
-      vals[idx - first] = val;
-   }
-
-   return vals[last - first];
-}
-
 static void begin_uniform_if_then(isel_context* ctx, if_context* ic, Temp cond);
 static void begin_uniform_if_else(isel_context* ctx, if_context* ic);
 static void end_uniform_if(isel_context* ctx, if_context* ic);
@@ -10383,27 +10326,6 @@ visit_loop(isel_context* ctx, nir_loop* loop)
 
    visit_cf_list(ctx, &loop->body);
 
-   unsigned loop_header_idx = ctx->cf_info.parent_loop.header_idx;
-
-   /* We add an operand when creating ACO phis for NIR ones in case if it might end with a divergent
-    * break, in which case we need to insert a linear continue edge. Fixup linear phis by either
-    * removing that operand if it's not actually necessary, or give it the correct value. */
-   if (nir_loop_last_block(loop)->successors[0] != nir_loop_first_block(loop)) {
-      unsigned num_vals = ctx->cf_info.has_branch ? 1 : (ctx->block->index - loop_header_idx + 1);
-      Operand* const vals = (Operand*)alloca(num_vals * sizeof(Operand));
-      for (aco_ptr<Instruction>& instr : ctx->program->blocks[loop_header_idx].instructions) {
-         if (instr->opcode == aco_opcode::p_linear_phi) {
-            if (ctx->cf_info.has_branch)
-               instr->operands.pop_back();
-            else
-               instr->operands.back() =
-                  create_continue_phis(ctx, loop_header_idx, ctx->block->index, instr, vals);
-         } else if (!is_phi(instr)) {
-            break;
-         }
-      }
-   }
-
    end_loop(ctx, &lc);
 }
 
-- 
GitLab


From 6a69fea68c8c521f9192211790d178474f1ee6da Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 9 Apr 2024 18:13:53 +0200
Subject: [PATCH 08/10] aco: use scalar phi lowering for all scalar phis

No fossil-db changes.
---
 .../compiler/aco_instruction_selection.cpp    | 55 +++----------------
 1 file changed, 7 insertions(+), 48 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index d9260a39a4edc..ad7bd8b3a1bf0 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10003,13 +10003,12 @@ visit_tex(isel_context* ctx, nir_tex_instr* instr)
 }
 
 Operand
-get_phi_operand(isel_context* ctx, nir_def* ssa, RegClass rc, bool logical)
+get_phi_operand(isel_context* ctx, nir_def* ssa, RegClass rc)
 {
    Temp tmp = get_ssa_temp(ctx, ssa);
    if (ssa->parent_instr->type == nir_instr_type_undef) {
       return Operand(rc);
-   } else if (logical && ssa->bit_size == 1 &&
-              ssa->parent_instr->type == nir_instr_type_load_const) {
+   } else if (ssa->bit_size == 1 && ssa->parent_instr->type == nir_instr_type_load_const) {
       bool val = nir_instr_as_load_const(ssa->parent_instr)->value[0].b;
       return Operand::c32_or_c64(val ? -1 : 0, ctx->program->lane_mask == s2);
    } else {
@@ -10020,59 +10019,19 @@ get_phi_operand(isel_context* ctx, nir_def* ssa, RegClass rc, bool logical)
 void
 visit_phi(isel_context* ctx, nir_phi_instr* instr)
 {
-   aco_ptr<Instruction> phi;
    Temp dst = get_ssa_temp(ctx, &instr->def);
    assert(instr->def.bit_size != 1 || dst.regClass() == ctx->program->lane_mask);
-
-   bool logical = !dst.is_linear() || instr->def.divergent;
-   logical |= ctx->block->kind & (block_kind_merge | block_kind_loop_header);
-   aco_opcode opcode = logical ? aco_opcode::p_phi : aco_opcode::p_linear_phi;
-   if (instr->def.bit_size == 1) {
-      logical = true;
-      opcode = aco_opcode::p_boolean_phi;
-   }
+   aco_opcode opcode = instr->def.bit_size == 1 ? aco_opcode::p_boolean_phi : aco_opcode::p_phi;
 
    /* we want a sorted list of sources, since the predecessor list is also sorted */
    std::map<unsigned, nir_def*> phi_src;
    nir_foreach_phi_src (src, instr)
       phi_src[src->pred->index] = src->src.ssa;
 
-   Block::edge_vec& preds = logical ? ctx->block->logical_preds : ctx->block->linear_preds;
-   unsigned num_operands = 0;
-   Operand* const operands = (Operand*)alloca(
-      (std::max(exec_list_length(&instr->srcs), (unsigned)preds.size()) + 1) * sizeof(Operand));
-   unsigned cur_pred_idx = 0;
-   for (std::pair<unsigned, nir_def*> src : phi_src) {
-      if (cur_pred_idx < preds.size()) {
-         /* handle missing preds (IF merges with discard/break) and extra preds
-          * (loop exit with discard) */
-         unsigned block = ctx->cf_info.nir_to_aco[src.first];
-         unsigned skipped = 0;
-         while (cur_pred_idx + skipped < preds.size() && preds[cur_pred_idx + skipped] != block)
-            skipped++;
-         if (cur_pred_idx + skipped < preds.size()) {
-            for (unsigned i = 0; i < skipped; i++)
-               operands[num_operands++] = Operand(dst.regClass());
-            cur_pred_idx += skipped;
-         } else {
-            continue;
-         }
-      }
-      /* Handle missing predecessors at the end. This shouldn't happen with loop
-       * headers and we can't ignore these sources for loop header phis. */
-      if (!(ctx->block->kind & block_kind_loop_header) && cur_pred_idx >= preds.size())
-         continue;
-      cur_pred_idx++;
-      Operand op = get_phi_operand(ctx, src.second, dst.regClass(), logical);
-      operands[num_operands++] = op;
-   }
-   /* handle block_kind_continue_or_break at loop exit blocks */
-   while (cur_pred_idx++ < preds.size())
-      operands[num_operands++] = Operand(dst.regClass());
-
-   phi.reset(create_instruction(opcode, Format::PSEUDO, num_operands, 1));
-   for (unsigned i = 0; i < num_operands; i++)
-      phi->operands[i] = operands[i];
+   Instruction* phi = create_instruction(opcode, Format::PSEUDO, phi_src.size(), 1);
+   unsigned i = 0;
+   for (std::pair<unsigned, nir_def*> src : phi_src)
+      phi->operands[i++] = get_phi_operand(ctx, src.second, dst.regClass());
    phi->definitions[0] = Definition(dst);
    ctx->block->instructions.emplace(ctx->block->instructions.begin(), std::move(phi));
 }
-- 
GitLab


From 40518598d6557e3f392e4ebb98b169f2af3d3de7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 8 Apr 2024 13:49:48 +0200
Subject: [PATCH 09/10] aco/optimizer: remove p_linear_phi handling from
 optimizer

We remove trivial phis during value numbering, now.
And the undef optimization seems to have no positive effect.

Totals from 22 (0.03% of 79206) affected shaders: (GFX10.3)
Instrs: 168529 -> 168260 (-0.16%)
CodeSize: 912692 -> 911704 (-0.11%)
Latency: 2607549 -> 2607335 (-0.01%)
InvThroughput: 1124171 -> 1124109 (-0.01%)
SClause: 5694 -> 5698 (+0.07%)
Copies: 23503 -> 23364 (-0.59%)
Branches: 8185 -> 8058 (-1.55%)
PreSGPRs: 1536 -> 1531 (-0.33%)
---
 src/amd/compiler/aco_optimizer.cpp | 24 ------------------------
 1 file changed, 24 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 6d1e05f36eb99..1a77ac7ad4f20 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -1961,30 +1961,6 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          ctx.info[instr->definitions[0].tempId()].set_temp(
             ctx.info[instr->operands[1].tempId()].temp);
       break;
-   case aco_opcode::p_linear_phi: {
-      /* lower_bool_phis() can create phis like this */
-      bool all_same_temp = instr->operands[0].isTemp();
-      /* this check is needed when moving uniform loop counters out of a divergent loop */
-      if (all_same_temp)
-         all_same_temp = instr->definitions[0].regClass() == instr->operands[0].regClass();
-      for (unsigned i = 1; all_same_temp && (i < instr->operands.size()); i++) {
-         if (!instr->operands[i].isTemp() ||
-             instr->operands[i].tempId() != instr->operands[0].tempId())
-            all_same_temp = false;
-      }
-      if (all_same_temp) {
-         ctx.info[instr->definitions[0].tempId()].set_temp(instr->operands[0].getTemp());
-      } else {
-         bool all_undef = instr->operands[0].isUndefined();
-         for (unsigned i = 1; all_undef && (i < instr->operands.size()); i++) {
-            if (!instr->operands[i].isUndefined())
-               all_undef = false;
-         }
-         if (all_undef)
-            ctx.info[instr->definitions[0].tempId()].set_undefined();
-      }
-      break;
-   }
    case aco_opcode::v_add_u32:
    case aco_opcode::v_add_co_u32:
    case aco_opcode::v_add_co_u32_e64:
-- 
GitLab


From 6dc60fe86c07302fa307b5ba6903b21f5df7d3b7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 11 Apr 2024 13:38:36 +0200
Subject: [PATCH 10/10] aco/lower_phis: fix uniform phis with undef src after
 divergent CF

---
 src/amd/compiler/aco_instruction_selection_setup.cpp |  6 +++++-
 src/amd/compiler/aco_lower_phis.cpp                  | 11 +++++++++++
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index ba45464d0633f..ee4e8904171d7 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -583,8 +583,12 @@ init_context(isel_context* ctx, nir_shader* shader)
                   type = RegType::vgpr;
                } else {
                   nir_foreach_phi_src (src, phi) {
-                     if (regclasses[src->src.ssa->index].type() == RegType::vgpr)
+                     if (nir_src_is_undef(src->src)) {
+                        type = RegType::sgpr;
+                        break;
+                     } else if (regclasses[src->src.ssa->index].type() == RegType::vgpr) {
                         type = RegType::vgpr;
+                     }
                   }
                }
 
diff --git a/src/amd/compiler/aco_lower_phis.cpp b/src/amd/compiler/aco_lower_phis.cpp
index a97ba24eda49b..881af1090f6cf 100644
--- a/src/amd/compiler/aco_lower_phis.cpp
+++ b/src/amd/compiler/aco_lower_phis.cpp
@@ -337,6 +337,17 @@ lower_divergent_bool_phi(Program* program, ssa_state* state, Block* block,
 void
 lower_scalar_phi(Program* program, ssa_state* state, Block* block, aco_ptr<Instruction>& phi)
 {
+   Builder bld(program);
+   for (unsigned i = 0; i < phi->operands.size(); i++) {
+      if (phi->operands[i].isOfType(RegType::vgpr)) {
+         Temp tmp = bld.tmp(phi->definitions[0].regClass());
+         insert_before_logical_end(
+            &program->blocks[block->logical_preds[i]],
+            bld.pseudo(aco_opcode::p_as_uniform, Definition(tmp), phi->operands[i]).get_ptr());
+         phi->operands[i].setTemp(tmp);
+      }
+   }
+
    if (block->linear_preds == block->logical_preds) {
       phi->opcode = aco_opcode::p_linear_phi;
       return;
-- 
GitLab

