From eddf3afe6c222a8a696c23a07188a9dff26c6dc5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 8 Jan 2024 15:12:17 +0100
Subject: [PATCH 1/3] aco/insert_exec_mask: unify exec restore code after
 divergent control flow

No fossil-db changes.
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 28 ++++++++++-------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index 4f4fb7eba5e0..37201622eefe 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -177,6 +177,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
    unsigned idx = block->index;
    Builder bld(ctx.program, &instructions);
    std::vector<unsigned>& preds = block->linear_preds;
+   bool restore_exec = false;
 
    /* start block */
    if (preds.empty()) {
@@ -280,23 +281,14 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       }
 
       /* create a parallelcopy to move the active mask to exec */
-      unsigned i = 0;
       if (info.has_divergent_continue) {
-         while (block->instructions[i]->opcode != aco_opcode::p_logical_start) {
-            bld.insert(std::move(block->instructions[i]));
-            i++;
-         }
+         restore_exec = true;
          uint8_t mask_type = ctx.info[idx].exec.back().second & (mask_type_wqm | mask_type_exact);
-         assert(ctx.info[idx].exec.back().first.size() == bld.lm.size());
-         ctx.info[idx].exec.emplace_back(
-            bld.copy(Definition(exec, bld.lm), ctx.info[idx].exec.back().first), mask_type);
+         ctx.info[idx].exec.emplace_back(ctx.info[idx].exec.back().first, mask_type);
       }
 
-      return i;
-   }
-
    /* loop exit block */
-   if (block->kind & block_kind_loop_exit) {
+   } else if (block->kind & block_kind_loop_exit) {
       Block* header = ctx.loop.back().loop_header;
       loop_info& info = ctx.loop.back();
 
@@ -325,6 +317,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       }
 
       if (info.has_divergent_break) {
+         restore_exec = true;
          aco_ptr<Instruction>& phi = header->instructions[instr_idx];
          assert(phi->opcode == aco_opcode::p_linear_phi);
          for (unsigned i = 1; i < phi->operands.size(); i++)
@@ -354,6 +347,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
             phi->definitions[0] = bld.def(bld.lm);
             if (exec_idx == info.num_exec_masks - 1u) {
                phi->definitions[0] = Definition(exec, bld.lm);
+               restore_exec = false;
             }
             for (unsigned i = 0; i < phi->operands.size(); i++)
                phi->operands[i] = get_exec_op(ctx.info[preds[i]].exec[exec_idx].first);
@@ -372,8 +366,10 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       unsigned num_exec_masks =
          std::min(ctx.info[preds[0]].exec.size(), ctx.info[preds[1]].exec.size());
 
-      if (block->kind & block_kind_merge)
+      if (block->kind & block_kind_merge) {
+         restore_exec = true;
          num_exec_masks--;
+      }
       if (block->kind & block_kind_top_level)
          num_exec_masks = std::min(num_exec_masks, 2u);
 
@@ -412,15 +408,15 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
             ctx.info[idx].exec.back().second |= mask_type_global;
             transition_to_Exact(ctx, bld, idx);
             ctx.handle_wqm = false;
+            restore_exec = false;
             i++;
          }
       }
    }
 
    /* restore exec mask after divergent control flow */
-   if (block->kind & (block_kind_loop_exit | block_kind_merge) &&
-       !ctx.info[idx].exec.back().first.isUndefined()) {
-      Operand restore = ctx.info[idx].exec.back().first;
+   if (restore_exec) {
+      Operand restore = get_exec_op(ctx.info[idx].exec.back().first);
       assert(restore.size() == bld.lm.size());
       bld.copy(Definition(exec, bld.lm), restore);
       if (!restore.isConstant())
-- 
GitLab


From c16dae0a1d8744fc2cf0a916b161f4f1f1f1a50f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Sat, 6 Jan 2024 12:59:51 +0100
Subject: [PATCH 2/3] aco/insert_exec_mask: replace phi for loop restore mask
 with explicit copies

Totals from 1785 (2.25% of 79242) affected shaders: (GFX11)
Instrs: 6787574 -> 6787041 (-0.01%); split: -0.01%, +0.00%
CodeSize: 34906500 -> 34904704 (-0.01%); split: -0.01%, +0.01%
SpillSGPRs: 5848 -> 5816 (-0.55%)
Latency: 88616877 -> 88617209 (+0.00%); split: -0.00%, +0.00%
InvThroughput: 16644948 -> 16644717 (-0.00%); split: -0.00%, +0.00%
VClause: 141122 -> 141121 (-0.00%)
SClause: 178929 -> 178906 (-0.01%); split: -0.03%, +0.02%
Copies: 569444 -> 569081 (-0.06%); split: -0.09%, +0.03%
Branches: 186980 -> 186961 (-0.01%); split: -0.01%, +0.00%
PreSGPRs: 133648 -> 133369 (-0.21%)
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 52 ++++++++---------------
 1 file changed, 17 insertions(+), 35 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index 37201622eefe..4d7e165c8279 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -235,8 +235,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       assert(preds[0] == idx - 1);
       ctx.info[idx].exec = ctx.info[idx - 1].exec;
       loop_info& info = ctx.loop.back();
-      while (ctx.info[idx].exec.size() > info.num_exec_masks)
-         ctx.info[idx].exec.pop_back();
+      assert(ctx.info[idx].exec.size() == info.num_exec_masks);
 
       /* create ssa names for outer exec masks */
       if (info.has_discard) {
@@ -250,17 +249,6 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
          }
       }
 
-      /* create ssa name for restore mask */
-      if (info.has_divergent_break) {
-         // TODO: this phi is unnecessary if we end WQM immediately after the loop
-         /* this phi might be trivial but ensures a parallelcopy on the loop header */
-         aco_ptr<Pseudo_instruction> phi{create_instruction<Pseudo_instruction>(
-            aco_opcode::p_linear_phi, Format::PSEUDO, preds.size(), 1)};
-         phi->definitions[0] = bld.def(bld.lm);
-         phi->operands[0] = get_exec_op(ctx.info[preds[0]].exec[info.num_exec_masks - 1].first);
-         ctx.info[idx].exec.back().first = bld.insert(std::move(phi));
-      }
-
       /* create ssa name for loop active mask */
       aco_ptr<Pseudo_instruction> phi{create_instruction<Pseudo_instruction>(
          aco_opcode::p_linear_phi, Format::PSEUDO, preds.size(), 1)};
@@ -269,16 +257,8 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       else
          phi->definitions[0] = Definition(exec, bld.lm);
       phi->operands[0] = get_exec_op(ctx.info[preds[0]].exec.back().first);
-      Temp loop_active = bld.insert(std::move(phi));
-
-      if (info.has_divergent_break) {
-         uint8_t mask_type =
-            (ctx.info[idx].exec.back().second & (mask_type_wqm | mask_type_exact)) | mask_type_loop;
-         ctx.info[idx].exec.emplace_back(loop_active, mask_type);
-      } else {
-         ctx.info[idx].exec.back().first = Operand(loop_active);
-         ctx.info[idx].exec.back().second |= mask_type_loop;
-      }
+      ctx.info[idx].exec.back().first = bld.insert(std::move(phi));
+      ctx.info[idx].exec.back().second |= mask_type_loop;
 
       /* create a parallelcopy to move the active mask to exec */
       if (info.has_divergent_continue) {
@@ -318,13 +298,8 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
 
       if (info.has_divergent_break) {
          restore_exec = true;
-         aco_ptr<Instruction>& phi = header->instructions[instr_idx];
-         assert(phi->opcode == aco_opcode::p_linear_phi);
-         for (unsigned i = 1; i < phi->operands.size(); i++)
-            phi->operands[i] =
-               get_exec_op(ctx.info[header_preds[i]].exec[info.num_exec_masks].first);
+         info.num_exec_masks--;
       }
-
       assert(!(block->kind & block_kind_top_level) || info.num_exec_masks <= 2);
 
       /* create the loop exit phis if not trivial */
@@ -345,10 +320,6 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
             aco_ptr<Pseudo_instruction> phi{create_instruction<Pseudo_instruction>(
                aco_opcode::p_linear_phi, Format::PSEUDO, preds.size(), 1)};
             phi->definitions[0] = bld.def(bld.lm);
-            if (exec_idx == info.num_exec_masks - 1u) {
-               phi->definitions[0] = Definition(exec, bld.lm);
-               restore_exec = false;
-            }
             for (unsigned i = 0; i < phi->operands.size(); i++)
                phi->operands[i] = get_exec_op(ctx.info[preds[i]].exec[exec_idx].first);
             ctx.info[idx].exec.emplace_back(bld.insert(std::move(phi)), type);
@@ -659,9 +630,20 @@ add_branch_code(exec_ctx& ctx, Block* block)
             has_divergent_continue = true;
       }
 
+      if (has_divergent_break) {
+         /* save restore exec mask */
+         uint8_t mask = ctx.info[idx].exec.back().second;
+         if (ctx.info[idx].exec.back().first.constantEquals(-1u)) {
+            ctx.info[idx].exec.emplace_back(Operand(exec, bld.lm), mask);
+         } else {
+            bld.reset(bld.instructions, std::prev(bld.instructions->end()));
+            Operand restore = bld.copy(bld.def(bld.lm), Operand(exec, bld.lm));
+            ctx.info[idx].exec.emplace(std::prev(ctx.info[idx].exec.end()), restore, mask);
+            bld.reset(bld.instructions);
+         }
+         ctx.info[idx].exec.back().second &= (mask_type_wqm | mask_type_exact);
+      }
       unsigned num_exec_masks = ctx.info[idx].exec.size();
-      if (block->kind & block_kind_top_level)
-         num_exec_masks = std::min(num_exec_masks, 2u);
 
       ctx.loop.emplace_back(&ctx.program->blocks[block->linear_succs[0]], num_exec_masks,
                             has_divergent_break, has_divergent_continue, has_discard);
-- 
GitLab


From a772c97c842547f0932ea8c0598390f6edd8f025 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Sat, 6 Jan 2024 16:46:54 +0100
Subject: [PATCH 3/3] aco/insert_exec_mask: only create loop phis for exec mask
 if necessary

Totals from 195 (0.25% of 79242) affected shaders: (GFX11)
Instrs: 476457 -> 476031 (-0.09%); split: -0.23%, +0.14%
CodeSize: 2453964 -> 2452108 (-0.08%); split: -0.23%, +0.16%
SpillSGPRs: 944 -> 913 (-3.28%); split: -3.39%, +0.11%
SpillVGPRs: 838 -> 835 (-0.36%); split: -0.95%, +0.60%
Latency: 10811026 -> 10810125 (-0.01%); split: -0.08%, +0.07%
InvThroughput: 2276677 -> 2276698 (+0.00%); split: -0.12%, +0.12%
VClause: 9223 -> 9233 (+0.11%); split: -0.10%, +0.21%
SClause: 9025 -> 9005 (-0.22%); split: -0.38%, +0.16%
Copies: 67419 -> 67382 (-0.05%); split: -0.97%, +0.92%
PreSGPRs: 10830 -> 10668 (-1.50%)
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 23 ++++++++++-------------
 1 file changed, 10 insertions(+), 13 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index 4d7e165c8279..5aa9dc28a6e3 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -238,7 +238,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       assert(ctx.info[idx].exec.size() == info.num_exec_masks);
 
       /* create ssa names for outer exec masks */
-      if (info.has_discard) {
+      if (info.has_discard && preds.size() > 1) {
          aco_ptr<Pseudo_instruction> phi;
          for (int i = 0; i < info.num_exec_masks - 1; i++) {
             phi.reset(create_instruction<Pseudo_instruction>(aco_opcode::p_linear_phi,
@@ -249,19 +249,16 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
          }
       }
 
-      /* create ssa name for loop active mask */
-      aco_ptr<Pseudo_instruction> phi{create_instruction<Pseudo_instruction>(
-         aco_opcode::p_linear_phi, Format::PSEUDO, preds.size(), 1)};
-      if (info.has_divergent_continue)
-         phi->definitions[0] = bld.def(bld.lm);
-      else
-         phi->definitions[0] = Definition(exec, bld.lm);
-      phi->operands[0] = get_exec_op(ctx.info[preds[0]].exec.back().first);
-      ctx.info[idx].exec.back().first = bld.insert(std::move(phi));
       ctx.info[idx].exec.back().second |= mask_type_loop;
 
-      /* create a parallelcopy to move the active mask to exec */
       if (info.has_divergent_continue) {
+         /* create ssa name for loop active mask */
+         aco_ptr<Pseudo_instruction> phi{create_instruction<Pseudo_instruction>(
+            aco_opcode::p_linear_phi, Format::PSEUDO, preds.size(), 1)};
+         phi->definitions[0] = bld.def(bld.lm);
+         phi->operands[0] = get_exec_op(ctx.info[preds[0]].exec.back().first);
+         ctx.info[idx].exec.back().first = bld.insert(std::move(phi));
+
          restore_exec = true;
          uint8_t mask_type = ctx.info[idx].exec.back().second & (mask_type_wqm | mask_type_exact);
          ctx.info[idx].exec.emplace_back(ctx.info[idx].exec.back().first, mask_type);
@@ -278,7 +275,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       /* fill the loop header phis */
       std::vector<unsigned>& header_preds = header->linear_preds;
       int instr_idx = 0;
-      if (info.has_discard) {
+      if (info.has_discard && header_preds.size() > 1) {
          while (instr_idx < info.num_exec_masks - 1) {
             aco_ptr<Instruction>& phi = header->instructions[instr_idx];
             assert(phi->opcode == aco_opcode::p_linear_phi);
@@ -288,7 +285,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
          }
       }
 
-      {
+      if (info.has_divergent_continue) {
          aco_ptr<Instruction>& phi = header->instructions[instr_idx++];
          assert(phi->opcode == aco_opcode::p_linear_phi);
          for (unsigned i = 1; i < phi->operands.size(); i++)
-- 
GitLab

