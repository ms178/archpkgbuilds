From c9ca58477150761ec4bb24c9367d7fee5f1247cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 29 Jan 2024 14:42:18 -0500
Subject: [PATCH 01/32] glthread: re-enable thread scheduling in st/mesa when
 glthread is disabled

This happens when GL_DEBUG_OUTPUT_SYNCHRONOUS is enabled.
---
 src/mesa/main/glthread.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 163bf3164166..54bddb95f6cc 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -251,9 +251,6 @@ _mesa_glthread_init(struct gl_context *ctx)
    _mesa_glthread_init_call_fence(&glthread->LastProgramChangeBatch);
    _mesa_glthread_init_call_fence(&glthread->LastDListChangeBatchIndex);
 
-   /* glthread takes over all L3 pinning */
-   ctx->st->pin_thread_counter = ST_THREAD_SCHEDULER_DISABLED;
-
    _mesa_glthread_enable(ctx);
 
    /* Execute the thread initialization function in the thread. */
@@ -305,6 +302,9 @@ void _mesa_glthread_enable(struct gl_context *ctx)
    ctx->GLThread.enabled = true;
    ctx->GLApi = ctx->MarshalExec;
 
+   /* glthread takes over all thread scheduling. */
+   ctx->st->pin_thread_counter = ST_THREAD_SCHEDULER_DISABLED;
+
    /* Update the dispatch only if the dispatch is current. */
    if (_glapi_get_dispatch() == ctx->Dispatch.Current) {
        _glapi_set_dispatch(ctx->GLApi);
@@ -321,6 +321,10 @@ void _mesa_glthread_disable(struct gl_context *ctx)
    ctx->GLThread.enabled = false;
    ctx->GLApi = ctx->Dispatch.Current;
 
+   /* Re-enable thread scheduling in st/mesa when glthread is disabled. */
+   if (ctx->pipe->set_context_param && util_thread_scheduler_enabled())
+      ctx->st->pin_thread_counter = 0;
+
    /* Update the dispatch only if the dispatch is current. */
    if (_glapi_get_dispatch() == ctx->MarshalExec) {
        _glapi_set_dispatch(ctx->GLApi);
-- 
GitLab


From 4485f43b4f98b2e5b5941ccf9bafc64ad577a529 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 29 Jan 2024 14:45:34 -0500
Subject: [PATCH 02/32] glthread: use _mesa_glthread_fence_call() instead of
 duplicating that code

no change in behavior
---
 src/mesa/main/glthread_shaderobj.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/mesa/main/glthread_shaderobj.c b/src/mesa/main/glthread_shaderobj.c
index 6c8b386a3f01..d994958d7d0c 100644
--- a/src/mesa/main/glthread_shaderobj.c
+++ b/src/mesa/main/glthread_shaderobj.c
@@ -31,9 +31,8 @@ _mesa_glthread_ProgramChanged(struct gl_context *ctx)
 {
    struct glthread_state *glthread = &ctx->GLThread;
 
-   /* Track the last change. */
-   p_atomic_set(&glthread->LastProgramChangeBatch, glthread->next);
-   _mesa_glthread_flush_batch(ctx);
+   /* Track the last change to shader programs. */
+   _mesa_glthread_fence_call(ctx, &glthread->LastProgramChangeBatch);
 }
 
 uint32_t
-- 
GitLab


From bdf4406319f5f308f99c17ba854c31b22f0d4584 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 13:43:26 -0500
Subject: [PATCH 03/32] glthread: add no_error variants of glDrawElements*

The main motivation is that no_error allows us to drop count==0 draws
at the beginning of the marshal function, instead of forwarding them
to the frontend thread. Such draws are plentiful with Viewperf.
---
 src/mapi/glapi/gen/ARB_base_instance.xml      |   5 +-
 .../gen/ARB_draw_elements_base_vertex.xml     |   8 +-
 src/mapi/glapi/gen/ARB_draw_instanced.xml     |   2 +-
 src/mapi/glapi/gen/gl_API.dtd                 |   3 +
 src/mapi/glapi/gen/gl_API.xml                 |   6 +-
 src/mapi/glapi/gen/gl_marshal.py              |  12 +-
 src/mapi/glapi/gen/gl_marshal_h.py            |   2 +
 src/mapi/glapi/gen/marshal_XML.py             |   1 +
 src/mesa/main/glthread_draw.c                 | 125 +++++++++++++++---
 9 files changed, 135 insertions(+), 29 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_base_instance.xml b/src/mapi/glapi/gen/ARB_base_instance.xml
index 5dbf895a4ddd..d6c17c155b94 100644
--- a/src/mapi/glapi/gen/ARB_base_instance.xml
+++ b/src/mapi/glapi/gen/ARB_base_instance.xml
@@ -17,7 +17,8 @@
     <param name="baseinstance" type="GLuint"/>
   </function>
 
-  <function name="DrawElementsInstancedBaseInstance" marshal="custom" exec="dlist">
+  <function name="DrawElementsInstancedBaseInstance" marshal="custom" exec="dlist"
+            marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="count" type="GLsizei"/>
     <param name="type" type="GLenum"/>
@@ -27,7 +28,7 @@
   </function>
 
   <function name="DrawElementsInstancedBaseVertexBaseInstance" marshal="custom" exec="dlist"
-            marshal_struct="public">
+            marshal_struct="public" marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="count" type="GLsizei"/>
     <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml b/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
index 736eda82e4a2..a7353c544ff1 100644
--- a/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
+++ b/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
@@ -9,7 +9,7 @@
 <category name="GL_ARB_draw_elements_base_vertex" number="62">
 
     <function name="DrawElementsBaseVertex" es2="3.2" marshal="custom" exec="dlist"
-              marshal_struct="public">
+              marshal_struct="public" marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="count" type="GLsizei"/>
         <param name="type" type="GLenum"/>
@@ -17,7 +17,8 @@
         <param name="basevertex" type="GLint"/>
     </function>
 
-    <function name="DrawRangeElementsBaseVertex" es2="3.2" marshal="custom" exec="dlist">
+    <function name="DrawRangeElementsBaseVertex" es2="3.2" marshal="custom" exec="dlist"
+              marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="start" type="GLuint"/>
         <param name="end" type="GLuint"/>
@@ -36,7 +37,8 @@
         <param name="basevertex" type="const GLint *" count="primcount"/>
     </function>
 
-    <function name="DrawElementsInstancedBaseVertex" es2="2.0" marshal="custom" exec="dlist">
+    <function name="DrawElementsInstancedBaseVertex" es2="2.0" marshal="custom" exec="dlist"
+              marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="count" type="GLsizei"/>
         <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/ARB_draw_instanced.xml b/src/mapi/glapi/gen/ARB_draw_instanced.xml
index 9ff2a56cc0a9..5418fd629171 100644
--- a/src/mapi/glapi/gen/ARB_draw_instanced.xml
+++ b/src/mapi/glapi/gen/ARB_draw_instanced.xml
@@ -16,7 +16,7 @@
   </function>
 
   <function name="DrawElementsInstanced" marshal="custom" exec="dlist" es2="2.0"
-            marshal_struct="public">
+            marshal_struct="public" marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="count" type="GLsizei"/>
     <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/gl_API.dtd b/src/mapi/glapi/gen/gl_API.dtd
index a5aae816c48e..0358dc9609da 100644
--- a/src/mapi/glapi/gen/gl_API.dtd
+++ b/src/mapi/glapi/gen/gl_API.dtd
@@ -45,6 +45,7 @@
                    marshal_call_before CDATA #IMPLIED>
                    marshal_call_after  CDATA #IMPLIED>
                    marshal_struct      CDATA #IMPLIED>
+                   marshal_no_error    CDATA #IMPLIED>
 <!ATTLIST size     name                NMTOKEN #REQUIRED
                    count               NMTOKEN #IMPLIED
                    mode                (get | set) "set">
@@ -143,6 +144,8 @@ param:
         header file instead of the C file. It's done even with
         marshal="custom", in which case you don't have to define the structure
         manually.
+     marshal_no_error - indicate that a no_error marshal function will be
+        generated, only useful with marshal="custom"
 
 glx:
      rop - Opcode value for "render" commands
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 874ec8dd552d..44c1ff401dbc 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -3218,7 +3218,8 @@
         <glx rop="193" handcode="true"/>
     </function>
 
-    <function name="DrawElements" es1="1.0" es2="2.0" marshal="custom" exec="dlist">
+    <function name="DrawElements" es1="1.0" es2="2.0" marshal="custom" exec="dlist"
+              marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="count" type="GLsizei"/>
         <param name="type" type="GLenum"/>
@@ -3791,7 +3792,8 @@
         <glx rop="4097"/>
     </function>
 
-    <function name="DrawRangeElements" es2="3.0" marshal="custom" exec="dlist">
+    <function name="DrawRangeElements" es2="3.0" marshal="custom" exec="dlist"
+              marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="start" type="GLuint"/>
         <param name="end" type="GLuint"/>
diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index d571f0475327..233a60d5db08 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -279,8 +279,16 @@ class PrintCode(gl_XML.gl_print_base):
                 if not condition:
                     continue
 
-                settings_by_condition[condition].append(
-                    'SET_{0}(table, _mesa_marshal_{0});'.format(func.name))
+                if func.marshal_no_error:
+                    no_error_condition = '_mesa_is_no_error_enabled(ctx) && ({0})'.format(condition)
+                    error_condition = '!_mesa_is_no_error_enabled(ctx) && ({0})'.format(condition)
+                    settings_by_condition[no_error_condition].append(
+                        'SET_{0}(table, _mesa_marshal_{0}_no_error);'.format(func.name))
+                    settings_by_condition[error_condition].append(
+                        'SET_{0}(table, _mesa_marshal_{0});'.format(func.name))
+                else:
+                    settings_by_condition[condition].append(
+                        'SET_{0}(table, _mesa_marshal_{0});'.format(func.name))
 
             # Print out an if statement for each unique condition, with
             # the SET_* calls nested inside it.
diff --git a/src/mapi/glapi/gen/gl_marshal_h.py b/src/mapi/glapi/gen/gl_marshal_h.py
index d155d233340d..4dd8acc3dfd6 100644
--- a/src/mapi/glapi/gen/gl_marshal_h.py
+++ b/src/mapi/glapi/gen/gl_marshal_h.py
@@ -76,6 +76,8 @@ class PrintCode(gl_XML.gl_print_base):
 
             if flavor in ('custom', 'async', 'sync') and not func.marshal_is_static():
                 print('{0} GLAPIENTRY _mesa_marshal_{1}({2});'.format(func.return_type, func.name, func.get_parameter_string()))
+                if func.marshal_no_error:
+                    print('{0} GLAPIENTRY _mesa_marshal_{1}_no_error({2});'.format(func.return_type, func.name, func.get_parameter_string()))
 
 
 def show_usage():
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 49314fd14bb2..ffaeb1498a94 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -116,6 +116,7 @@ class marshal_function(gl_XML.gl_function):
         self.marshal_call_before = element.get('marshal_call_before')
         self.marshal_call_after = element.get('marshal_call_after')
         self.marshal_struct = element.get('marshal_struct')
+        self.marshal_no_error = gl_XML.is_attr_true(element, 'marshal_no_error')
 
     def marshal_flavor(self):
         """Find out how this function should be marshalled between
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 4e55d8c25ab0..99946dd30a24 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -745,14 +745,20 @@ should_convert_to_begin_end(struct gl_context *ctx, unsigned count,
           !(vao->NonZeroDivisorMask & vao->BufferEnabled); /* no instanced attribs */
 }
 
-static void
+static ALWAYS_INLINE void
 draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
               const GLvoid *indices, GLsizei instance_count, GLint basevertex,
               GLuint baseinstance, bool index_bounds_valid, GLuint min_index,
-              GLuint max_index, bool compiled_into_dlist)
+              GLuint max_index, bool compiled_into_dlist, bool no_error)
 {
    GET_CURRENT_CONTEXT(ctx);
 
+   /* The main benefit of no_error is that we can discard no-op draws
+    * immediately. These are plentiful in Viewperf2020/Catia1.
+    */
+   if (no_error && (count <= 0 || instance_count <= 0))
+      return;
+
    if (unlikely(compiled_into_dlist && ctx->GLThread.ListMode)) {
       _mesa_glthread_finish_before(ctx, "DrawElements");
 
@@ -769,7 +775,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
       return;
    }
 
-   if (unlikely(index_bounds_valid && max_index < min_index)) {
+   if (unlikely(!no_error && index_bounds_valid && max_index < min_index)) {
       _mesa_marshal_InternalSetError(GL_INVALID_VALUE);
       return;
    }
@@ -784,13 +790,14 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
     * This is also an error path. Zero counts should still call the driver
     * for possible GL errors.
     */
-   if (count <= 0 || instance_count <= 0 ||
-       !is_index_type_valid(type) ||
-       (!user_buffer_mask && !has_user_indices) ||
-       ctx->Dispatch.Current == ctx->Dispatch.ContextLost ||
-       /* This will just generate GL_INVALID_OPERATION, as it should. */
-       ctx->GLThread.inside_begin_end ||
-       ctx->GLThread.ListMode) {
+   if ((!user_buffer_mask && !has_user_indices) ||
+       (!no_error &&
+        /* zeros are discarded for no_error at the beginning */
+        (count <= 0 || instance_count <= 0 ||   /* GL_INVALID_VALUE / no-op */
+         !is_index_type_valid(type) ||          /* GL_INVALID_VALUE */
+         ctx->Dispatch.Current == ctx->Dispatch.ContextLost || /* GL_INVALID_OPERATION */
+         ctx->GLThread.inside_begin_end ||      /* GL_INVALID_OPERATION */
+         ctx->GLThread.ListMode))) {            /* GL_INVALID_OPERATION */
       if (instance_count == 1 && baseinstance == 0 && drawid == 0) {
          int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
          struct marshal_cmd_DrawElementsBaseVertex *cmd =
@@ -1289,7 +1296,7 @@ lower_draw_elements_indirect(struct gl_context *ctx, GLenum mode, GLenum type,
                     params[i * stride / 4 + 1],
                     params[i * stride / 4 + 3],
                     params[i * stride / 4 + 4],
-                    false, 0, 0, false);
+                    false, 0, 0, false, false);
    }
    unmap_draw_indirect_params(ctx);
 }
@@ -1615,7 +1622,16 @@ void GLAPIENTRY
 _mesa_marshal_DrawElements(GLenum mode, GLsizei count, GLenum type,
                            const GLvoid *indices)
 {
-   draw_elements(0, mode, count, type, indices, 1, 0, 0, false, 0, 0, true);
+   draw_elements(0, mode, count, type, indices, 1, 0,
+                 0, false, 0, 0, true, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElements_no_error(GLenum mode, GLsizei count, GLenum type,
+                                    const GLvoid *indices)
+{
+   draw_elements(0, mode, count, type, indices, 1, 0,
+                 0, false, 0, 0, true, true);
 }
 
 void GLAPIENTRY
@@ -1623,21 +1639,51 @@ _mesa_marshal_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                                 GLsizei count, GLenum type,
                                 const GLvoid *indices)
 {
-   draw_elements(0, mode, count, type, indices, 1, 0, 0, true, start, end, true);
+   draw_elements(0, mode, count, type, indices, 1, 0,
+                 0, true, start, end, true, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawRangeElements_no_error(GLenum mode, GLuint start, GLuint end,
+                                         GLsizei count, GLenum type,
+                                         const GLvoid *indices)
+{
+   draw_elements(0, mode, count, type, indices, 1, 0,
+                 0, true, start, end, true, true);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type,
                                     const GLvoid *indices, GLsizei instance_count)
 {
-   draw_elements(0, mode, count, type, indices, instance_count, 0, 0, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, 0,
+                 0, false, 0, 0, false, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsInstanced_no_error(GLenum mode, GLsizei count,
+                                             GLenum type, const GLvoid *indices,
+                                             GLsizei instance_count)
+{
+   draw_elements(0, mode, count, type, indices, instance_count, 0,
+                 0, false, 0, 0, false, true);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
                                      const GLvoid *indices, GLint basevertex)
 {
-   draw_elements(0, mode, count, type, indices, 1, basevertex, 0, false, 0, 0, true);
+   draw_elements(0, mode, count, type, indices, 1, basevertex,
+                 0, false, 0, 0, true, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsBaseVertex_no_error(GLenum mode, GLsizei count,
+                                              GLenum type, const GLvoid *indices,
+                                              GLint basevertex)
+{
+   draw_elements(0, mode, count, type, indices, 1, basevertex,
+                 0, false, 0, 0, true, true);
 }
 
 void GLAPIENTRY
@@ -1645,7 +1691,17 @@ _mesa_marshal_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
                                           GLsizei count, GLenum type,
                                           const GLvoid *indices, GLint basevertex)
 {
-   draw_elements(0, mode, count, type, indices, 1, basevertex, 0, true, start, end, true);
+   draw_elements(0, mode, count, type, indices, 1, basevertex,
+                 0, true, start, end, true, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawRangeElementsBaseVertex_no_error(GLenum mode, GLuint start,
+                                                   GLuint end, GLsizei count, GLenum type,
+                                                   const GLvoid *indices, GLint basevertex)
+{
+   draw_elements(0, mode, count, type, indices, 1, basevertex,
+                 0, true, start, end, true, true);
 }
 
 void GLAPIENTRY
@@ -1653,7 +1709,17 @@ _mesa_marshal_DrawElementsInstancedBaseVertex(GLenum mode, GLsizei count,
                                               GLenum type, const GLvoid *indices,
                                               GLsizei instance_count, GLint basevertex)
 {
-   draw_elements(0, mode, count, type, indices, instance_count, basevertex, 0, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, basevertex,
+                 0, false, 0, 0, false, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsInstancedBaseVertex_no_error(GLenum mode, GLsizei count,
+                                                       GLenum type, const GLvoid *indices,
+                                                       GLsizei instance_count, GLint basevertex)
+{
+   draw_elements(0, mode, count, type, indices, instance_count, basevertex,
+                 0, false, 0, 0, false, true);
 }
 
 void GLAPIENTRY
@@ -1661,7 +1727,17 @@ _mesa_marshal_DrawElementsInstancedBaseInstance(GLenum mode, GLsizei count,
                                                 GLenum type, const GLvoid *indices,
                                                 GLsizei instance_count, GLuint baseinstance)
 {
-   draw_elements(0, mode, count, type, indices, instance_count, 0, baseinstance, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, 0,
+                 baseinstance, false, 0, 0, false, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsInstancedBaseInstance_no_error(GLenum mode, GLsizei count,
+                                                         GLenum type, const GLvoid *indices,
+                                                         GLsizei instance_count, GLuint baseinstance)
+{
+   draw_elements(0, mode, count, type, indices, instance_count, 0,
+                 baseinstance, false, 0, 0, false, true);
 }
 
 void GLAPIENTRY
@@ -1670,7 +1746,18 @@ _mesa_marshal_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei c
                                                           GLsizei instance_count, GLint basevertex,
                                                           GLuint baseinstance)
 {
-   draw_elements(0, mode, count, type, indices, instance_count, basevertex, baseinstance, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, basevertex,
+                 baseinstance, false, 0, 0, false, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsInstancedBaseVertexBaseInstance_no_error(GLenum mode, GLsizei count,
+                                                                   GLenum type, const GLvoid *indices,
+                                                                   GLsizei instance_count,
+                                                                   GLint basevertex, GLuint baseinstance)
+{
+   draw_elements(0, mode, count, type, indices, instance_count, basevertex,
+                 baseinstance, false, 0, 0, false, true);
 }
 
 void GLAPIENTRY
-- 
GitLab


From d046e0254e454cf8c099f62669a3fcae17b941cf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 13:43:26 -0500
Subject: [PATCH 04/32] glthread: add no_error variants of glDrawArrays*

The main motivation is that no_error allows us to drop count==0 draws
at the beginning of the marshal function, instead of forwarding them
to the frontend thread. Such draws are plentiful with Viewperf.
---
 src/mapi/glapi/gen/ARB_base_instance.xml  |  2 +-
 src/mapi/glapi/gen/ARB_draw_instanced.xml |  3 +-
 src/mapi/glapi/gen/gl_API.xml             |  2 +-
 src/mesa/main/glthread_draw.c             | 48 ++++++++++++++++++-----
 4 files changed, 42 insertions(+), 13 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_base_instance.xml b/src/mapi/glapi/gen/ARB_base_instance.xml
index d6c17c155b94..768b14478706 100644
--- a/src/mapi/glapi/gen/ARB_base_instance.xml
+++ b/src/mapi/glapi/gen/ARB_base_instance.xml
@@ -9,7 +9,7 @@
 <category name="GL_ARB_base_instance" number="107">
 
   <function name="DrawArraysInstancedBaseInstance" marshal="custom" exec="dlist"
-            marshal_struct="public">
+            marshal_struct="public" marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="first" type="GLint"/>
     <param name="count" type="GLsizei"/>
diff --git a/src/mapi/glapi/gen/ARB_draw_instanced.xml b/src/mapi/glapi/gen/ARB_draw_instanced.xml
index 5418fd629171..cadf9f538462 100644
--- a/src/mapi/glapi/gen/ARB_draw_instanced.xml
+++ b/src/mapi/glapi/gen/ARB_draw_instanced.xml
@@ -8,7 +8,8 @@
 
 <category name="GL_ARB_draw_instanced" number="44">
 
-  <function name="DrawArraysInstanced" marshal="custom" exec="dlist" es2="2.0">
+  <function name="DrawArraysInstanced" marshal="custom" exec="dlist" es2="2.0"
+            marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="first" type="GLint"/>
     <param name="count" type="GLsizei"/>
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 44c1ff401dbc..5437558be63c 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -3211,7 +3211,7 @@
     </function>
 
     <function name="DrawArrays" es1="1.0" es2="2.0" marshal="custom" exec="dlist"
-              marshal_struct="public">
+              marshal_struct="public" marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="first" type="GLint"/>
         <param name="count" type="GLsizei"/>
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 99946dd30a24..8c48aef859dd 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -406,10 +406,16 @@ get_user_buffer_mask(struct gl_context *ctx)
 static ALWAYS_INLINE void
 draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
             GLsizei instance_count, GLuint baseinstance,
-            bool compiled_into_dlist)
+            bool compiled_into_dlist, bool no_error)
 {
    GET_CURRENT_CONTEXT(ctx);
 
+   /* The main benefit of no_error is that we can discard no-op draws
+    * immediately.
+    */
+   if (no_error && (count <= 0 || instance_count <= 0))
+      return;
+
    if (unlikely(compiled_into_dlist && ctx->GLThread.ListMode)) {
       _mesa_glthread_finish_before(ctx, "DrawArrays");
       /* Use the function that's compiled into a display list. */
@@ -425,11 +431,12 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
     * This is also an error path. Zero counts should still call the driver
     * for possible GL errors.
     */
-   if (!user_buffer_mask || count <= 0 || instance_count <= 0 ||
-       /* This will just generate GL_INVALID_OPERATION, as it should. */
-       ctx->GLThread.inside_begin_end ||
-       ctx->Dispatch.Current == ctx->Dispatch.ContextLost ||
-       ctx->GLThread.ListMode) {
+   if (!user_buffer_mask ||
+       (!no_error &&
+        (count <= 0 || instance_count <= 0 ||   /* GL_INVALID_VALUE / no-op */
+         ctx->GLThread.inside_begin_end ||      /* GL_INVALID_OPERATION */
+         ctx->Dispatch.Current == ctx->Dispatch.ContextLost || /* GL_INVALID_OPERATION */
+         ctx->GLThread.ListMode))) {            /* GL_INVALID_OPERATION */
       if (instance_count == 1 && baseinstance == 0 && drawid == 0) {
          int cmd_size = sizeof(struct marshal_cmd_DrawArrays);
          struct marshal_cmd_DrawArrays *cmd =
@@ -1269,7 +1276,7 @@ lower_draw_arrays_indirect(struct gl_context *ctx, GLenum mode,
                   params[i * stride / 4 + 2],
                   params[i * stride / 4 + 0],
                   params[i * stride / 4 + 1],
-                  params[i * stride / 4 + 3], false);
+                  params[i * stride / 4 + 3], false, false);
    }
 
    unmap_draw_indirect_params(ctx);
@@ -1600,14 +1607,27 @@ _mesa_marshal_MultiDrawElementsIndirectCountARB(GLenum mode, GLenum type,
 void GLAPIENTRY
 _mesa_marshal_DrawArrays(GLenum mode, GLint first, GLsizei count)
 {
-   draw_arrays(0, mode, first, count, 1, 0, true);
+   draw_arrays(0, mode, first, count, 1, 0, true, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawArrays_no_error(GLenum mode, GLint first, GLsizei count)
+{
+   draw_arrays(0, mode, first, count, 1, 0, true, true);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawArraysInstanced(GLenum mode, GLint first, GLsizei count,
                                   GLsizei instance_count)
 {
-   draw_arrays(0, mode, first, count, instance_count, 0, false);
+   draw_arrays(0, mode, first, count, instance_count, 0, false, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawArraysInstanced_no_error(GLenum mode, GLint first, GLsizei count,
+                                           GLsizei instance_count)
+{
+   draw_arrays(0, mode, first, count, instance_count, 0, false, true);
 }
 
 void GLAPIENTRY
@@ -1615,7 +1635,15 @@ _mesa_marshal_DrawArraysInstancedBaseInstance(GLenum mode, GLint first,
                                               GLsizei count, GLsizei instance_count,
                                               GLuint baseinstance)
 {
-   draw_arrays(0, mode, first, count, instance_count, baseinstance, false);
+   draw_arrays(0, mode, first, count, instance_count, baseinstance, false, false);
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawArraysInstancedBaseInstance_no_error(GLenum mode, GLint first,
+                                                       GLsizei count, GLsizei instance_count,
+                                                       GLuint baseinstance)
+{
+   draw_arrays(0, mode, first, count, instance_count, baseinstance, false, true);
 }
 
 void GLAPIENTRY
-- 
GitLab


From fee940c6e19499bd84b244b24d0c99ffaf8f23da Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 19:03:46 -0500
Subject: [PATCH 05/32] glthread: remove cmd_size from constant-sized calls

Only variable-sized calls keep cmd_size in their structures, and it's
renamed to num_slots because it's in units of 8-byte elements.

The motivation is to make room for reducing call sizes.
---
 src/mapi/glapi/gen/gl_marshal.py   |  8 +--
 src/mapi/glapi/gen/marshal_XML.py  |  2 +
 src/mesa/main/glthread_bufferobj.c | 18 ++++---
 src/mesa/main/glthread_draw.c      | 83 +++++++++---------------------
 src/mesa/main/glthread_list.c      | 17 +++---
 src/mesa/main/glthread_marshal.h   | 12 ++---
 6 files changed, 54 insertions(+), 86 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 233a60d5db08..afde88e61dc4 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -154,12 +154,10 @@ class PrintCode(gl_XML.gl_print_base):
 
             self.print_call(func, unmarshal=1)
             if variable_params:
-                out('return cmd->cmd_base.cmd_size;')
+                out('return cmd->num_slots;')
             else:
                 struct = 'struct marshal_cmd_{0}'.format(func.name)
-                out('const unsigned cmd_size = (align(sizeof({0}), 8) / 8);'.format(struct))
-                out('assert(cmd_size == cmd->cmd_base.cmd_size);')
-                out('return cmd_size;')
+                out('return align(sizeof({0}), 8) / 8;'.format(struct))
         out('}')
 
         out('{0}{1} GLAPIENTRY'.format('static ' if func.marshal_is_static() else '', func.return_type))
@@ -218,6 +216,8 @@ class PrintCode(gl_XML.gl_print_base):
             # Add the call into the batch.
             out('cmd = _mesa_glthread_allocate_command(ctx, '
                 'DISPATCH_CMD_{0}, cmd_size);'.format(func.name))
+            if variable_params:
+                out('cmd->num_slots = align(cmd_size, 8) / 8;')
 
             for p in fixed_params:
                 type = marshal_XML.get_marshal_type(func.name, p)
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index ffaeb1498a94..41c411cbfdfe 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -174,6 +174,8 @@ class marshal_function(gl_XML.gl_function):
             print('struct marshal_cmd_{0}'.format(self.name))
             print('{')
             print('   struct marshal_cmd_base cmd_base;')
+            if variable_params:
+                print('   uint16_t num_slots;')
 
             # Sort the parameters according to their size to pack the structure optimally
             for p in sorted(fixed_params, key=lambda p: get_type_size(self.name, p)):
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index 100e810c3f48..07a9285ad7fb 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -240,9 +240,7 @@ _mesa_unmarshal_BindBuffer(struct gl_context *ctx,
    if (cmd->target[1])
       CALL_BindBuffer(ctx->Dispatch.Current, (cmd->target[1], cmd->buffer[1]));
 
-   const unsigned cmd_size = (align(sizeof(struct marshal_cmd_BindBuffer), 8) / 8);
-   assert (cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_BindBuffer), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -251,11 +249,13 @@ _mesa_marshal_BindBuffer(GLenum target, GLuint buffer)
    GET_CURRENT_CONTEXT(ctx);
    struct glthread_state *glthread = &ctx->GLThread;
    struct marshal_cmd_BindBuffer *last = glthread->LastBindBuffer;
+   int cmd_size = sizeof(struct marshal_cmd_BindBuffer);
 
    _mesa_glthread_BindBuffer(ctx, target, buffer);
 
    /* If the last call is BindBuffer... */
-   if (_mesa_glthread_call_is_last(glthread, &last->cmd_base)) {
+   if (_mesa_glthread_call_is_last(glthread, &last->cmd_base,
+                                   align(cmd_size, 8) / 8)) {
       /* If the target is in the last call and unbinding the buffer, overwrite
        * the buffer ID there.
        *
@@ -279,7 +279,6 @@ _mesa_marshal_BindBuffer(GLenum target, GLuint buffer)
       }
    }
 
-   int cmd_size = sizeof(struct marshal_cmd_BindBuffer);
    struct marshal_cmd_BindBuffer *cmd =
       _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_BindBuffer, cmd_size);
 
@@ -319,6 +318,7 @@ _mesa_glthread_DeleteBuffers(struct gl_context *ctx, GLsizei n,
 struct marshal_cmd_BufferData
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    GLuint target_or_name;
    GLsizeiptr size;
    GLenum usage;
@@ -355,7 +355,7 @@ _mesa_unmarshal_BufferData(struct gl_context *ctx,
       CALL_BufferData(ctx->Dispatch.Current,
                       (target_or_name, size, data, usage));
    }
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 uint32_t
@@ -401,7 +401,7 @@ _mesa_marshal_BufferData_merged(GLuint target_or_name, GLsizeiptr size,
    struct marshal_cmd_BufferData *cmd =
       _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_BufferData,
                                       cmd_size);
-
+   cmd->num_slots = align(cmd_size, 8) / 8;
    cmd->target_or_name = target_or_name;
    cmd->size = size;
    cmd->usage = usage;
@@ -445,6 +445,7 @@ _mesa_marshal_NamedBufferDataEXT(GLuint buffer, GLsizeiptr size,
 struct marshal_cmd_BufferSubData
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    GLenum target_or_name;
    GLintptr offset;
    GLsizeiptr size;
@@ -472,7 +473,7 @@ _mesa_unmarshal_BufferSubData(struct gl_context *ctx,
       CALL_BufferSubData(ctx->Dispatch.Current,
                          (target_or_name, offset, size, data));
    }
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 uint32_t
@@ -542,6 +543,7 @@ _mesa_marshal_BufferSubData_merged(GLuint target_or_name, GLintptr offset,
    struct marshal_cmd_BufferSubData *cmd =
       _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_BufferSubData,
                                       cmd_size);
+   cmd->num_slots = align(cmd_size, 8) / 8;
    cmd->target_or_name = target_or_name;
    cmd->offset = offset;
    cmd->size = size;
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 8c48aef859dd..cde43be7b35a 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -291,9 +291,7 @@ _mesa_unmarshal_DrawArrays(struct gl_context *ctx,
    const GLsizei count = cmd->count;
 
    CALL_DrawArrays(ctx->Dispatch.Current, (mode, first, count));
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 /* DrawArraysInstancedBaseInstance without user buffers. */
@@ -310,9 +308,7 @@ _mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
    CALL_DrawArraysInstancedBaseInstance(ctx->Dispatch.Current,
                                         (mode, first, count, instance_count,
                                          baseinstance));
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID
@@ -341,16 +337,14 @@ _mesa_unmarshal_DrawArraysInstancedBaseInstanceDrawID(struct gl_context *ctx,
                                         (mode, first, count, instance_count,
                                          baseinstance));
    ctx->DrawID = 0;
-
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 /* DrawArraysInstancedBaseInstance with user buffers. */
 struct marshal_cmd_DrawArraysUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    GLenum mode;
    GLint first;
    GLsizei count;
@@ -383,7 +377,7 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
                                         (mode, first, count, instance_count,
                                          baseinstance));
    ctx->DrawID = 0;
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 static inline unsigned
@@ -484,6 +478,7 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
 
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysUserBuf,
                                          cmd_size);
+   cmd->num_slots = align(cmd_size, 8) / 8;
    cmd->mode = mode;
    cmd->first = first;
    cmd->count = count;
@@ -500,6 +495,7 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
 struct marshal_cmd_MultiDrawArraysUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    GLenum mode;
    GLsizei draw_count;
    GLuint user_buffer_mask;
@@ -527,7 +523,7 @@ _mesa_unmarshal_MultiDrawArraysUserBuf(struct gl_context *ctx,
 
    CALL_MultiDrawArrays(ctx->Dispatch.Current,
                         (mode, first, count, draw_count));
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 void GLAPIENTRY
@@ -594,6 +590,7 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
    if (cmd_size <= MARSHAL_MAX_CMD_SIZE) {
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysUserBuf,
                                             cmd_size);
+      cmd->num_slots = align(cmd_size, 8) / 8;
       cmd->mode = mode;
       cmd->draw_count = draw_count;
       cmd->user_buffer_mask = user_buffer_mask;
@@ -632,9 +629,7 @@ _mesa_unmarshal_DrawElementsInstanced(struct gl_context *ctx,
 
    CALL_DrawElementsInstanced(ctx->Dispatch.Current,
                               (mode, count, type, indices, instance_count));
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 /* DrawElementsBaseVertex without user buffers. */
@@ -650,9 +645,7 @@ _mesa_unmarshal_DrawElementsBaseVertex(struct gl_context *ctx,
 
    CALL_DrawElementsBaseVertex(ctx->Dispatch.Current,
                                (mode, count, type, indices, basevertex));
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 /* DrawElementsInstancedBaseVertexBaseInstance without user buffers. */
@@ -672,9 +665,7 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *c
                                                     (mode, count, type, indices,
                                                      instance_count, basevertex,
                                                      baseinstance));
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID
@@ -709,9 +700,7 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(struct gl_cont
                                                      baseinstance));
    ctx->DrawID = 0;
 
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(*cmd), 8) / 8;
 }
 
 uint32_t
@@ -731,7 +720,7 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
 
    struct gl_buffer_object *index_buffer = cmd->index_buffer;
    _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 static inline bool
@@ -920,6 +909,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
    struct marshal_cmd_DrawElementsUserBuf *cmd;
 
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
+   cmd->num_slots = align(cmd_size, 8) / 8;
    cmd->mode = MIN2(mode, 0xffff);
    cmd->type = MIN2(type, 0xffff);
    cmd->count = count;
@@ -938,6 +928,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
 struct marshal_cmd_MultiDrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    bool has_base_vertex;
    GLenum8 mode;
    GLenum16 type;
@@ -980,7 +971,7 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
                                  ((GLintptr)index_buffer, mode, count, type,
                                   indices, draw_count, basevertex));
    _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 static void
@@ -1004,6 +995,7 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
    /* Make sure cmd can fit the queue buffer */
    if (cmd_size <= MARSHAL_MAX_CMD_SIZE) {
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsUserBuf, cmd_size);
+      cmd->num_slots = align(cmd_size, 8) / 8;
       cmd->mode = MIN2(mode, 0xff); /* primitive types go from 0 to 14 */
       cmd->type = MIN2(type, 0xffff);
       cmd->draw_count = draw_count;
@@ -1330,10 +1322,7 @@ _mesa_unmarshal_DrawArraysIndirect(struct gl_context *ctx,
 
    CALL_DrawArraysIndirect(ctx->Dispatch.Current, (mode, indirect));
 
-   const unsigned cmd_size =
-      (align(sizeof(struct marshal_cmd_DrawArraysIndirect), 8) / 8);
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_DrawArraysIndirect), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -1367,11 +1356,7 @@ _mesa_unmarshal_DrawElementsIndirect(struct gl_context *ctx,
    const GLvoid * indirect = cmd->indirect;
 
    CALL_DrawElementsIndirect(ctx->Dispatch.Current, (mode, type, indirect));
-
-   const unsigned cmd_size =
-      (align(sizeof(struct marshal_cmd_DrawElementsIndirect), 8) / 8);
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_DrawElementsIndirect), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -1409,11 +1394,7 @@ _mesa_unmarshal_MultiDrawArraysIndirect(struct gl_context *ctx,
 
    CALL_MultiDrawArraysIndirect(ctx->Dispatch.Current,
                                 (mode, indirect, primcount, stride));
-
-   const unsigned cmd_size =
-      (align(sizeof(struct marshal_cmd_MultiDrawArraysIndirect), 8) / 8);
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_MultiDrawArraysIndirect), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -1456,11 +1437,7 @@ _mesa_unmarshal_MultiDrawElementsIndirect(struct gl_context *ctx,
 
    CALL_MultiDrawElementsIndirect(ctx->Dispatch.Current,
                                   (mode, type, indirect, primcount, stride));
-
-   const unsigned cmd_size =
-      (align(sizeof(struct marshal_cmd_MultiDrawElementsIndirect), 8) / 8);
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_MultiDrawElementsIndirect), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -1508,11 +1485,7 @@ _mesa_unmarshal_MultiDrawArraysIndirectCountARB(struct gl_context *ctx,
    CALL_MultiDrawArraysIndirectCountARB(ctx->Dispatch.Current,
                                         (mode, indirect, drawcount,
                                          maxdrawcount, stride));
-
-   const unsigned cmd_size =
-      (align(sizeof(struct marshal_cmd_MultiDrawArraysIndirectCountARB), 8) / 8);
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_MultiDrawArraysIndirectCountARB), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -1563,9 +1536,7 @@ _mesa_unmarshal_MultiDrawElementsIndirectCountARB(struct gl_context *ctx,
 
    CALL_MultiDrawElementsIndirectCountARB(ctx->Dispatch.Current, (mode, type, indirect, drawcount, maxdrawcount, stride));
 
-   const unsigned cmd_size = (align(sizeof(struct marshal_cmd_MultiDrawElementsIndirectCountARB), 8) / 8);
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
+   return align(sizeof(struct marshal_cmd_MultiDrawElementsIndirectCountARB), 8) / 8;
 }
 
 void GLAPIENTRY
@@ -1975,8 +1946,6 @@ _mesa_unmarshal_PushMatrix(struct gl_context *ctx,
       next2 = _mesa_glthread_next_cmd(next1, draw_elements_size);
 
       if (_mesa_glthread_get_cmd(next2)->cmd_id == DISPATCH_CMD_PopMatrix) {
-         assert(_mesa_glthread_get_cmd(next2)->cmd_size == pop_matrix_size);
-
          /* The beauty of this is that this is inlined. */
          _mesa_unmarshal_DrawElementsBaseVertex(ctx, (void*)next1);
          return push_matrix_size + draw_elements_size + pop_matrix_size;
@@ -1991,10 +1960,8 @@ _mesa_unmarshal_PushMatrix(struct gl_context *ctx,
        */
       next2 = _mesa_glthread_next_cmd(next1, mult_matrixf_size);
 
-      if (_mesa_glthread_get_cmd(next2)->cmd_id == DISPATCH_CMD_PopMatrix) {
-         assert(_mesa_glthread_get_cmd(next2)->cmd_size == pop_matrix_size);
+      if (_mesa_glthread_get_cmd(next2)->cmd_id == DISPATCH_CMD_PopMatrix)
          return push_matrix_size + mult_matrixf_size + pop_matrix_size;
-      }
       break;
    }
 
diff --git a/src/mesa/main/glthread_list.c b/src/mesa/main/glthread_list.c
index b27671859c41..46d8ee460796 100644
--- a/src/mesa/main/glthread_list.c
+++ b/src/mesa/main/glthread_list.c
@@ -29,6 +29,7 @@
 struct marshal_cmd_CallList
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    GLuint num;
    GLuint list[];
 };
@@ -39,13 +40,13 @@ _mesa_unmarshal_CallList(struct gl_context *ctx,
 {
    const GLuint num = cmd->num;
 
-   if (cmd->cmd_base.cmd_size == sizeof(*cmd) / 8) {
+   if (cmd->num_slots == sizeof(*cmd) / 8) {
       CALL_CallList(ctx->Dispatch.Current, (num));
    } else {
       CALL_CallLists(ctx->Dispatch.Current, (num, GL_UNSIGNED_INT, cmd->list));
    }
 
-   return cmd->cmd_base.cmd_size;
+   return cmd->num_slots;
 }
 
 void GLAPIENTRY
@@ -58,15 +59,16 @@ _mesa_marshal_CallList(GLuint list)
    _mesa_glthread_CallList(ctx, list);
 
    /* If the last call is CallList and there is enough space to append another list... */
-   if (_mesa_glthread_call_is_last(glthread, &last->cmd_base) &&
+   if (last &&
+       _mesa_glthread_call_is_last(glthread, &last->cmd_base, last->num_slots) &&
        glthread->used + 1 <= MARSHAL_MAX_CMD_SIZE / 8) {
       STATIC_ASSERT(sizeof(*last) == 8);
 
       /* Add the list to the last call. */
-      if (last->cmd_base.cmd_size > sizeof(*last) / 8) {
+      if (last->num_slots > sizeof(*last) / 8) {
          last->list[last->num++] = list;
          if (last->num % 2 == 1) {
-            last->cmd_base.cmd_size++;
+            last->num_slots++;
             glthread->used++;
          }
       } else {
@@ -76,16 +78,17 @@ _mesa_marshal_CallList(GLuint list)
          last->list[0] = last->num;
          last->list[1] = list;
          last->num = 2;
-         last->cmd_base.cmd_size++;
+         last->num_slots++;
          glthread->used++;
       }
-      assert(align(sizeof(*last) + last->num * 4, 8) / 8 == last->cmd_base.cmd_size);
+      assert(align(sizeof(*last) + last->num * 4, 8) / 8 == last->num_slots);
       return;
    }
 
    int cmd_size = sizeof(struct marshal_cmd_CallList);
    struct marshal_cmd_CallList *cmd;
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_CallList, cmd_size);
+   cmd->num_slots = align(cmd_size, 8) / 8;
    cmd->num = list;
 
    glthread->LastCallList = cmd;
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 09a65640f000..cf199de28675 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -41,11 +41,6 @@ struct marshal_cmd_base
     * Type of command.  See enum marshal_dispatch_cmd_id.
     */
    uint16_t cmd_id;
-
-   /**
-    * Number of uint64_t elements used by the command.
-    */
-   uint16_t cmd_size;
 };
 
 /* This must be included after "struct marshal_cmd_base" because it uses it. */
@@ -59,6 +54,7 @@ extern const char *_mesa_unmarshal_func_name[NUM_DISPATCH_CMD];
 struct marshal_cmd_DrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   uint16_t num_slots;
    GLenum16 mode;
    GLenum16 type;
    GLsizei count;
@@ -89,7 +85,6 @@ _mesa_glthread_allocate_command(struct gl_context *ctx,
       (struct marshal_cmd_base *)&next->buffer[glthread->used];
    glthread->used += num_elements;
    cmd_base->cmd_id = cmd_id;
-   cmd_base->cmd_size = num_elements;
    return cmd_base;
 }
 
@@ -102,16 +97,15 @@ _mesa_glthread_get_cmd(uint64_t *opaque_cmd)
 static inline uint64_t *
 _mesa_glthread_next_cmd(uint64_t *opaque_cmd, unsigned cmd_size)
 {
-   assert(_mesa_glthread_get_cmd(opaque_cmd)->cmd_size == cmd_size);
    return opaque_cmd + cmd_size;
 }
 
 static inline bool
 _mesa_glthread_call_is_last(struct glthread_state *glthread,
-                            struct marshal_cmd_base *last)
+                            struct marshal_cmd_base *last, uint16_t num_slots)
 {
    return last &&
-          (uint64_t*)last + last->cmd_size ==
+          (uint64_t*)last + num_slots ==
           &glthread->next_batch->buffer[glthread->used];
 }
 
-- 
GitLab


From 17bc601d688a1e2fc8f4e68ae58e159e2a4d9aca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 19:50:55 -0500
Subject: [PATCH 06/32] glthread: clean up how vertex stride is packed

Use a better type name. Also check the function name more accurately
(no change in behavior).
---
 src/mapi/glapi/gen/gl_marshal.py  |  2 +-
 src/mapi/glapi/gen/marshal_XML.py | 15 ++++++++++-----
 src/mesa/main/glthread_marshal.h  |  3 +++
 3 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index afde88e61dc4..4aec2d438f53 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -227,7 +227,7 @@ class PrintCode(gl_XML.gl_print_base):
                             p.name, p.size_string()))
                 elif type == 'GLenum16':
                     out('cmd->{0} = MIN2({0}, 0xffff); /* clamped to 0xffff (invalid enum) */'.format(p.name))
-                elif type == 'int16_t':
+                elif type == 'GLclamped16i':
                     out('cmd->{0} = CLAMP({0}, INT16_MIN, INT16_MAX);'.format(p.name))
                 else:
                     out('cmd->{0} = {0};'.format(p.name))
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 41c411cbfdfe..8c52df6a3790 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -33,10 +33,15 @@ def get_marshal_type(func_name, param):
     if type == 'GLenum':
         return 'GLenum16' # clamped to 0xffff (always invalid enum)
 
-    # Use int16_t for the vertex stride, the max value is usually 2048.
-    if ((type, param.name) == ('GLsizei', 'stride') and
-        ('Vertex' in func_name or 'Pointer' in func_name or 'Interleaved' in func_name)):
-        return 'int16_t' # clamped to INT16_MAX (always invalid value)
+    if (func_name == 'InterleavedArrays' or
+        func_name.endswith('VertexBuffer') or
+        func_name.endswith('VertexBufferEXT') or
+        func_name.endswith('Pointer') or
+        func_name.endswith('PointerEXT') or
+        func_name.endswith('PointerOES') or
+        func_name.endswith('OffsetEXT')):
+        if (type, param.name) == ('GLsizei', 'stride'):
+            return 'GLclamped16i'
 
     return type
 
@@ -54,7 +59,7 @@ def get_type_size(func_name, param):
         'GLshort': 2,
         'GLushort': 2,
         'GLhalfNV': 2,
-        'int16_t': 2, # clamped by glthread
+        'GLclamped16i': 2, # clamped by glthread
         'GLint': 4,
         'GLuint': 4,
         'GLbitfield': 4,
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index cf199de28675..d4ebfe090f91 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -35,6 +35,9 @@
 #include "main/macros.h"
 #include "main/matrix.h"
 
+/* 32-bit signed integer clamped to 16 bits. */
+typedef int16_t GLclamped16i;
+
 struct marshal_cmd_base
 {
    /**
-- 
GitLab


From ced3e6064e8f1ea38e5d86e8eff074a42c9f3bd6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 02:04:55 -0500
Subject: [PATCH 07/32] glthread: pack "size" in Pointer calls as 16 bits

The only legal values are {1, 2, 3, 4, GL_BGRA}.
We need GLpacked16i to be unsigned, not signed, because GL_BGRA is
greater than 0x8000.

This decreases the size of 1 frame by 10% in Viewperf2020/Catia1.
It decreases the size of many Pointer calls by 8 bytes.
---
 src/mapi/glapi/gen/gl_marshal.py  | 2 ++
 src/mapi/glapi/gen/marshal_XML.py | 4 ++++
 src/mesa/main/glthread_marshal.h  | 6 ++++++
 3 files changed, 12 insertions(+)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 4aec2d438f53..1458c33fc766 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -229,6 +229,8 @@ class PrintCode(gl_XML.gl_print_base):
                     out('cmd->{0} = MIN2({0}, 0xffff); /* clamped to 0xffff (invalid enum) */'.format(p.name))
                 elif type == 'GLclamped16i':
                     out('cmd->{0} = CLAMP({0}, INT16_MIN, INT16_MAX);'.format(p.name))
+                elif type == 'GLpacked16i':
+                    out('cmd->{0} = {0} < 0 ? UINT16_MAX : MIN2({0}, UINT16_MAX);'.format(p.name))
                 else:
                     out('cmd->{0} = {0};'.format(p.name))
             if variable_params:
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 8c52df6a3790..9aa99d196825 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -43,6 +43,9 @@ def get_marshal_type(func_name, param):
         if (type, param.name) == ('GLsizei', 'stride'):
             return 'GLclamped16i'
 
+        if (type, param.name) == ('GLint', 'size'):
+            return 'GLpacked16i'
+
     return type
 
 def get_type_size(func_name, param):
@@ -60,6 +63,7 @@ def get_type_size(func_name, param):
         'GLushort': 2,
         'GLhalfNV': 2,
         'GLclamped16i': 2, # clamped by glthread
+        'GLpacked16i': 2, # clamped by glthread
         'GLint': 4,
         'GLuint': 4,
         'GLbitfield': 4,
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index d4ebfe090f91..3cc1853e8906 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -35,6 +35,12 @@
 #include "main/macros.h"
 #include "main/matrix.h"
 
+/* 32-bit signed integer clamped to 0..UINT16_MAX to compress parameters
+ * for glthread. All values < 0 and >= UINT16_MAX are expected to throw
+ * GL_INVALID_VALUE. Negative values are mapped to UINT16_MAX.
+ */
+typedef uint16_t GLpacked16i;
+
 /* 32-bit signed integer clamped to 16 bits. */
 typedef int16_t GLclamped16i;
 
-- 
GitLab


From 59ef802b1d51f7cd8ad8f871c07815ef4538efd0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 20:18:08 -0500
Subject: [PATCH 08/32] mesa: deduplicate get_index_size_shift code

---
 src/mesa/main/draw.c          | 20 +++-----------------
 src/mesa/main/draw.h          | 14 ++++++++++++++
 src/mesa/main/glthread_draw.c |  8 +-------
 3 files changed, 18 insertions(+), 24 deletions(-)

diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index f97f70e801df..0ceb3c496ce9 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1018,20 +1018,6 @@ check_array_data(struct gl_context *ctx, struct gl_vertex_array_object *vao,
 }
 
 
-static inline unsigned
-get_index_size_shift(GLenum type)
-{
-   /* The type is already validated, so use a fast conversion.
-    *
-    * GL_UNSIGNED_BYTE  - GL_UNSIGNED_BYTE = 0
-    * GL_UNSIGNED_SHORT - GL_UNSIGNED_BYTE = 2
-    * GL_UNSIGNED_INT   - GL_UNSIGNED_BYTE = 4
-    *
-    * Divide by 2 to get 0,1,2.
-    */
-   return (type - GL_UNSIGNED_BYTE) >> 1;
-}
-
 /**
  * Examine the array's data for NaNs, etc.
  * For debug purposes; not normally used.
@@ -1620,7 +1606,7 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
       assert(end == ~0u);
    }
 
-   unsigned index_size_shift = get_index_size_shift(type);
+   unsigned index_size_shift = _mesa_get_index_size_shift(type);
 
    if (index_bo) {
       if (!indices_aligned(index_size_shift, indices))
@@ -2018,7 +2004,7 @@ _mesa_validated_multidrawelements(struct gl_context *ctx,
    if (primcount == 0)
       return;
 
-   unsigned index_size_shift = get_index_size_shift(type);
+   unsigned index_size_shift = _mesa_get_index_size_shift(type);
 
    min_index_ptr = (uintptr_t) indices[0];
    max_index_ptr = 0;
@@ -2531,7 +2517,7 @@ _mesa_MultiDrawElementsIndirect(GLenum mode, GLenum type,
            !_mesa_validate_DrawElements(ctx, mode, 1, type)))
          return;
 
-      unsigned index_size_shift = get_index_size_shift(type);
+      unsigned index_size_shift = _mesa_get_index_size_shift(type);
 
       struct pipe_draw_info info;
       info.mode = mode;
diff --git a/src/mesa/main/draw.h b/src/mesa/main/draw.h
index a0a1a0d22999..39cfb70ff891 100644
--- a/src/mesa/main/draw.h
+++ b/src/mesa/main/draw.h
@@ -100,6 +100,20 @@ _mesa_bitmap(struct gl_context *ctx, GLsizei width, GLsizei height,
              GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove,
              const GLubyte *bitmap, struct pipe_resource *tex);
 
+static inline unsigned
+_mesa_get_index_size_shift(GLenum type)
+{
+   /* The type is already validated, so use a fast conversion.
+    *
+    * GL_UNSIGNED_BYTE  - GL_UNSIGNED_BYTE = 0
+    * GL_UNSIGNED_SHORT - GL_UNSIGNED_BYTE = 2
+    * GL_UNSIGNED_INT   - GL_UNSIGNED_BYTE = 4
+    *
+    * Divide by 2 to get 0,1,2.
+    */
+   return (type - GL_UNSIGNED_BYTE) >> 1;
+}
+
 #ifdef __cplusplus
 } // extern "C"
 #endif
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index cde43be7b35a..8f393690cec6 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -37,13 +37,7 @@
 static inline unsigned
 get_index_size(GLenum type)
 {
-   /* GL_UNSIGNED_BYTE  - GL_UNSIGNED_BYTE = 0
-    * GL_UNSIGNED_SHORT - GL_UNSIGNED_BYTE = 2
-    * GL_UNSIGNED_INT   - GL_UNSIGNED_BYTE = 4
-    *
-    * Divide by 2 to get n=0,1,2, then the index size is: 1 << n
-    */
-   return 1 << ((type - GL_UNSIGNED_BYTE) >> 1);
+   return 1 << _mesa_get_index_size_shift(type);
 }
 
 static inline bool
-- 
GitLab


From 8be25dd98b468d743f495b183776040fff573ca6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 20:18:47 -0500
Subject: [PATCH 09/32] mesa: deduplicate is_index_type_valid code

---
 src/mesa/main/draw.c          | 13 +------------
 src/mesa/main/draw.h          | 14 ++++++++++++++
 src/mesa/main/glthread_draw.c | 24 +++++-------------------
 3 files changed, 20 insertions(+), 31 deletions(-)

diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 0ceb3c496ce9..d1c6e4bd15e2 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -223,18 +223,7 @@ valid_prim_mode_indexed(struct gl_context *ctx, GLenum mode)
 static GLenum
 valid_elements_type(struct gl_context *ctx, GLenum type)
 {
-   /* GL_UNSIGNED_BYTE  = 0x1401
-    * GL_UNSIGNED_SHORT = 0x1403
-    * GL_UNSIGNED_INT   = 0x1405
-    *
-    * The trick is that bit 1 and bit 2 mean USHORT and UINT, respectively.
-    * After clearing those two bits (with ~6), we should get UBYTE.
-    * Both bits can't be set, because the enum would be greater than UINT.
-    */
-   if (!(type <= GL_UNSIGNED_INT && (type & ~6) == GL_UNSIGNED_BYTE))
-      return GL_INVALID_ENUM;
-
-   return GL_NO_ERROR;
+   return _mesa_is_index_type_valid(type) ? GL_NO_ERROR : GL_INVALID_ENUM;
 }
 
 static inline bool
diff --git a/src/mesa/main/draw.h b/src/mesa/main/draw.h
index 39cfb70ff891..64f8c9ca6ab1 100644
--- a/src/mesa/main/draw.h
+++ b/src/mesa/main/draw.h
@@ -114,6 +114,20 @@ _mesa_get_index_size_shift(GLenum type)
    return (type - GL_UNSIGNED_BYTE) >> 1;
 }
 
+static inline bool
+_mesa_is_index_type_valid(GLenum type)
+{
+   /* GL_UNSIGNED_BYTE  = 0x1401
+    * GL_UNSIGNED_SHORT = 0x1403
+    * GL_UNSIGNED_INT   = 0x1405
+    *
+    * The trick is that bit 1 and bit 2 mean USHORT and UINT, respectively.
+    * After clearing those two bits (with ~6), we should get UBYTE.
+    * Both bits can't be set, because the enum would be greater than UINT.
+    */
+   return type <= GL_UNSIGNED_INT && (type & ~6) == GL_UNSIGNED_BYTE;
+}
+
 #ifdef __cplusplus
 } // extern "C"
 #endif
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 8f393690cec6..2511089af157 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -40,20 +40,6 @@ get_index_size(GLenum type)
    return 1 << _mesa_get_index_size_shift(type);
 }
 
-static inline bool
-is_index_type_valid(GLenum type)
-{
-   /* GL_UNSIGNED_BYTE  = 0x1401
-    * GL_UNSIGNED_SHORT = 0x1403
-    * GL_UNSIGNED_INT   = 0x1405
-    *
-    * The trick is that bit 1 and bit 2 mean USHORT and UINT, respectively.
-    * After clearing those two bits (with ~6), we should get UBYTE.
-    * Both bits can't be set, because the enum would be greater than UINT.
-    */
-   return type <= GL_UNSIGNED_INT && (type & ~6) == GL_UNSIGNED_BYTE;
-}
-
 static ALWAYS_INLINE struct gl_buffer_object *
 upload_indices(struct gl_context *ctx, unsigned count, unsigned index_size,
                const GLvoid **indices)
@@ -784,7 +770,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
        (!no_error &&
         /* zeros are discarded for no_error at the beginning */
         (count <= 0 || instance_count <= 0 ||   /* GL_INVALID_VALUE / no-op */
-         !is_index_type_valid(type) ||          /* GL_INVALID_VALUE */
+         !_mesa_is_index_type_valid(type) ||    /* GL_INVALID_VALUE */
          ctx->Dispatch.Current == ctx->Dispatch.ContextLost || /* GL_INVALID_OPERATION */
          ctx->GLThread.inside_begin_end ||      /* GL_INVALID_OPERATION */
          ctx->GLThread.ListMode))) {            /* GL_INVALID_OPERATION */
@@ -1057,7 +1043,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
     * When nothing needs to be uploaded or the draw is no-op or generates
     * a GL error, we don't upload anything.
     */
-   if (draw_count > 0 && is_index_type_valid(type) &&
+   if (draw_count > 0 && _mesa_is_index_type_valid(type) &&
        ctx->Dispatch.Current != ctx->Dispatch.ContextLost &&
        !ctx->GLThread.inside_begin_end) {
       user_buffer_mask = _mesa_is_desktop_gl_core(ctx) ? 0 : get_user_buffer_mask(ctx);
@@ -1362,7 +1348,7 @@ _mesa_marshal_DrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indir
       _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
 
    if (draw_indirect_async_allowed(ctx, user_buffer_mask) ||
-       !is_index_type_valid(type)) {
+       !_mesa_is_index_type_valid(type)) {
       int cmd_size = sizeof(struct marshal_cmd_DrawElementsIndirect);
       struct marshal_cmd_DrawElementsIndirect *cmd;
 
@@ -1446,7 +1432,7 @@ _mesa_marshal_MultiDrawElementsIndirect(GLenum mode, GLenum type,
 
    if (draw_indirect_async_allowed(ctx, user_buffer_mask) ||
        primcount <= 0 ||
-       !is_index_type_valid(type)) {
+       !_mesa_is_index_type_valid(type)) {
       int cmd_size = sizeof(struct marshal_cmd_MultiDrawElementsIndirect);
       struct marshal_cmd_MultiDrawElementsIndirect *cmd;
 
@@ -1549,7 +1535,7 @@ _mesa_marshal_MultiDrawElementsIndirectCountARB(GLenum mode, GLenum type,
        /* This will just generate GL_INVALID_OPERATION because Draw*IndirectCount
         * functions forbid a user indirect buffer in the Compat profile. */
        !ctx->GLThread.CurrentDrawIndirectBufferName ||
-       !is_index_type_valid(type)) {
+       !_mesa_is_index_type_valid(type)) {
       int cmd_size = sizeof(struct marshal_cmd_MultiDrawElementsIndirectCountARB);
       struct marshal_cmd_MultiDrawElementsIndirectCountARB *cmd =
          _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirectCountARB, cmd_size);
-- 
GitLab


From f536094ec9337c7349f6e223c94803a0ae711ef6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 20:42:14 -0500
Subject: [PATCH 10/32] glthread: pack the primitive type to 8 bits

The maximum valid enum is only 14.
---
 src/mapi/glapi/gen/gl_marshal.py  |  2 ++
 src/mapi/glapi/gen/marshal_XML.py |  8 ++++++
 src/mesa/main/glthread_draw.c     | 42 +++++++++++++++----------------
 src/mesa/main/glthread_marshal.h  |  2 +-
 4 files changed, 32 insertions(+), 22 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 1458c33fc766..69a5b1d4a085 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -225,6 +225,8 @@ class PrintCode(gl_XML.gl_print_base):
                 if p.count:
                     out('memcpy(cmd->{0}, {0}, {1});'.format(
                             p.name, p.size_string()))
+                elif type == 'GLenum8':
+                    out('cmd->{0} = MIN2({0}, 0xff); /* clamped to 0xff (invalid enum) */'.format(p.name))
                 elif type == 'GLenum16':
                     out('cmd->{0} = MIN2({0}, 0xffff); /* clamped to 0xffff (invalid enum) */'.format(p.name))
                 elif type == 'GLclamped16i':
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 9aa99d196825..165c0b73a1a4 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -30,6 +30,13 @@ import gl_XML
 def get_marshal_type(func_name, param):
     type = param.type_string()
 
+    if ('Draw' in func_name and
+        ('Arrays' in func_name or
+         'Elements' in func_name or
+         'TransformFeedback' in func_name)):
+        if (type, param.name) == ('GLenum', 'mode'):
+            return 'GLenum8'
+
     if type == 'GLenum':
         return 'GLenum16' # clamped to 0xffff (always invalid enum)
 
@@ -58,6 +65,7 @@ def get_type_size(func_name, param):
         'GLboolean': 1,
         'GLbyte': 1,
         'GLubyte': 1,
+        'GLenum8': 1, # clamped by glthread
         'GLenum16': 2, # clamped by glthread
         'GLshort': 2,
         'GLushort': 2,
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 2511089af157..4dbddcdfd326 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -294,7 +294,7 @@ _mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
 struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID
 {
    struct marshal_cmd_base cmd_base;
-   GLenum mode;
+   GLenum8 mode;
    GLint first;
    GLsizei count;
    GLsizei instance_count;
@@ -324,8 +324,8 @@ _mesa_unmarshal_DrawArraysInstancedBaseInstanceDrawID(struct gl_context *ctx,
 struct marshal_cmd_DrawArraysUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   GLenum8 mode;
    uint16_t num_slots;
-   GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei instance_count;
@@ -416,7 +416,7 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
          struct marshal_cmd_DrawArrays *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArrays, cmd_size);
 
-         cmd->mode = mode;
+         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
          cmd->first = first;
          cmd->count = count;
       } else if (drawid == 0) {
@@ -424,7 +424,7 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
          struct marshal_cmd_DrawArraysInstancedBaseInstance *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstance, cmd_size);
 
-         cmd->mode = mode;
+         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
          cmd->first = first;
          cmd->count = count;
          cmd->instance_count = instance_count;
@@ -434,7 +434,7 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
          struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstanceDrawID, cmd_size);
 
-         cmd->mode = mode;
+         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
          cmd->first = first;
          cmd->count = count;
          cmd->instance_count = instance_count;
@@ -459,7 +459,7 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysUserBuf,
                                          cmd_size);
    cmd->num_slots = align(cmd_size, 8) / 8;
-   cmd->mode = mode;
+   cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
    cmd->first = first;
    cmd->count = count;
    cmd->instance_count = instance_count;
@@ -475,8 +475,8 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
 struct marshal_cmd_MultiDrawArraysUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   GLenum8 mode;
    uint16_t num_slots;
-   GLenum mode;
    GLsizei draw_count;
    GLuint user_buffer_mask;
 };
@@ -571,7 +571,7 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysUserBuf,
                                             cmd_size);
       cmd->num_slots = align(cmd_size, 8) / 8;
-      cmd->mode = mode;
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->draw_count = draw_count;
       cmd->user_buffer_mask = user_buffer_mask;
 
@@ -651,7 +651,7 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *c
 struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID
 {
    struct marshal_cmd_base cmd_base;
-   GLenum16 mode;
+   GLenum8 mode;
    GLenum16 type;
    GLsizei count;
    GLsizei instance_count;
@@ -779,7 +779,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
          struct marshal_cmd_DrawElementsBaseVertex *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
 
-         cmd->mode = MIN2(mode, 0xffff);
+         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
          cmd->type = MIN2(type, 0xffff);
          cmd->count = count;
          cmd->indices = indices;
@@ -790,7 +790,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
             struct marshal_cmd_DrawElementsInstanced *cmd =
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstanced, cmd_size);
 
-            cmd->mode = MIN2(mode, 0xffff);
+            cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
             cmd->type = MIN2(type, 0xffff);
             cmd->count = count;
             cmd->instance_count = instance_count;
@@ -800,7 +800,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
             struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *cmd =
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstance, cmd_size);
 
-            cmd->mode = MIN2(mode, 0xffff);
+            cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
             cmd->type = MIN2(type, 0xffff);
             cmd->count = count;
             cmd->instance_count = instance_count;
@@ -812,7 +812,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
             struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID *cmd =
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstanceDrawID, cmd_size);
 
-            cmd->mode = MIN2(mode, 0xffff);
+            cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
             cmd->type = MIN2(type, 0xffff);
             cmd->count = count;
             cmd->instance_count = instance_count;
@@ -890,7 +890,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
 
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
    cmd->num_slots = align(cmd_size, 8) / 8;
-   cmd->mode = MIN2(mode, 0xffff);
+   cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
    cmd->type = MIN2(type, 0xffff);
    cmd->count = count;
    cmd->indices = indices;
@@ -908,10 +908,10 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
 struct marshal_cmd_MultiDrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
-   uint16_t num_slots;
    bool has_base_vertex;
    GLenum8 mode;
    GLenum16 type;
+   uint16_t num_slots;
    GLsizei draw_count;
    GLuint user_buffer_mask;
    struct gl_buffer_object *index_buffer;
@@ -1318,7 +1318,7 @@ _mesa_marshal_DrawArraysIndirect(GLenum mode, const GLvoid *indirect)
       struct marshal_cmd_DrawArraysIndirect *cmd;
 
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysIndirect, cmd_size);
-      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->indirect = indirect;
       return;
    }
@@ -1353,7 +1353,7 @@ _mesa_marshal_DrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indir
       struct marshal_cmd_DrawElementsIndirect *cmd;
 
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsIndirect, cmd_size);
-      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
       cmd->indirect = indirect;
       return;
@@ -1393,7 +1393,7 @@ _mesa_marshal_MultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect,
 
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysIndirect,
                                             cmd_size);
-      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->indirect = indirect;
       cmd->primcount = primcount;
       cmd->stride = stride;
@@ -1438,7 +1438,7 @@ _mesa_marshal_MultiDrawElementsIndirect(GLenum mode, GLenum type,
 
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirect,
                                             cmd_size);
-      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
       cmd->indirect = indirect;
       cmd->primcount = primcount;
@@ -1489,7 +1489,7 @@ _mesa_marshal_MultiDrawArraysIndirectCountARB(GLenum mode, GLintptr indirect,
          _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysIndirectCountARB,
                                          cmd_size);
 
-      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->indirect = indirect;
       cmd->drawcount = drawcount;
       cmd->maxdrawcount = maxdrawcount;
@@ -1540,7 +1540,7 @@ _mesa_marshal_MultiDrawElementsIndirectCountARB(GLenum mode, GLenum type,
       struct marshal_cmd_MultiDrawElementsIndirectCountARB *cmd =
          _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirectCountARB, cmd_size);
 
-      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
       cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
       cmd->indirect = indirect;
       cmd->drawcount = drawcount;
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 3cc1853e8906..c687adb58c02 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -63,8 +63,8 @@ extern const char *_mesa_unmarshal_func_name[NUM_DISPATCH_CMD];
 struct marshal_cmd_DrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
+   GLenum8 mode;
    uint16_t num_slots;
-   GLenum16 mode;
    GLenum16 type;
    GLsizei count;
    GLsizei instance_count;
-- 
GitLab


From 1476efd432a43c4e2144b8691f6972ced6a3d9da Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 20:53:37 -0500
Subject: [PATCH 11/32] glthread: pack the index type to 8 bits

---
 src/mapi/glapi/gen/marshal_XML.py |  4 +++
 src/mesa/main/draw.c              |  2 +-
 src/mesa/main/glthread_draw.c     | 57 ++++++++++++++++++++-----------
 src/mesa/main/glthread_marshal.h  |  8 ++++-
 src/util/glheader.h               |  7 ++++
 5 files changed, 57 insertions(+), 21 deletions(-)

diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 165c0b73a1a4..f60257430524 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -37,6 +37,9 @@ def get_marshal_type(func_name, param):
         if (type, param.name) == ('GLenum', 'mode'):
             return 'GLenum8'
 
+        if (type, param.name) == ('GLenum', 'type'):
+            return 'GLindextype'
+
     if type == 'GLenum':
         return 'GLenum16' # clamped to 0xffff (always invalid enum)
 
@@ -66,6 +69,7 @@ def get_type_size(func_name, param):
         'GLbyte': 1,
         'GLubyte': 1,
         'GLenum8': 1, # clamped by glthread
+        'GLindextype': 1,
         'GLenum16': 2, # clamped by glthread
         'GLshort': 2,
         'GLushort': 2,
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index d1c6e4bd15e2..764c1284ecda 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1950,7 +1950,7 @@ _mesa_DrawElementsUserBuf(const GLvoid *ptr)
       (const struct marshal_cmd_DrawElementsUserBuf *)ptr;
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLsizei instance_count = cmd->instance_count;
 
    if (!_mesa_is_no_error_enabled(ctx) &&
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 4dbddcdfd326..90e6d4f028ad 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -40,6 +40,25 @@ get_index_size(GLenum type)
    return 1 << _mesa_get_index_size_shift(type);
 }
 
+static inline GLindextype
+encode_index_type(GLenum type)
+{
+   /* Map invalid values less than GL_UNSIGNED_BYTE to GL_UNSIGNED_BYTE - 1,
+    * and invalid values greater than GL_UNSIGNED_INT to GL_UNSIGNED_INT + 1,
+    * Then subtract GL_UNSIGNED_BYTE - 1. Final encoding:
+    *    0 = invalid value
+    *    1 = GL_UNSIGNED_BYTE
+    *    2 = invalid value
+    *    3 = GL_UNSIGNED_SHORT
+    *    4 = invalid value
+    *    5 = GL_UNSIGNED_INT
+    *    6 = invalid value
+    */
+   const unsigned min = GL_UNSIGNED_BYTE - 1;
+   const unsigned max = GL_UNSIGNED_INT + 1;
+   return (GLindextype){CLAMP(type, min, max) - min};
+}
+
 static ALWAYS_INLINE struct gl_buffer_object *
 upload_indices(struct gl_context *ctx, unsigned count, unsigned index_size,
                const GLvoid **indices)
@@ -603,7 +622,7 @@ _mesa_unmarshal_DrawElementsInstanced(struct gl_context *ctx,
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
    const GLsizei instance_count = cmd->instance_count;
 
@@ -619,7 +638,7 @@ _mesa_unmarshal_DrawElementsBaseVertex(struct gl_context *ctx,
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
    const GLint basevertex = cmd->basevertex;
 
@@ -635,7 +654,7 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *c
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
    const GLsizei instance_count = cmd->instance_count;
    const GLint basevertex = cmd->basevertex;
@@ -652,7 +671,7 @@ struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID
 {
    struct marshal_cmd_base cmd_base;
    GLenum8 mode;
-   GLenum16 type;
+   GLindextype type;
    GLsizei count;
    GLsizei instance_count;
    GLint basevertex;
@@ -667,7 +686,7 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(struct gl_cont
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
    const GLsizei instance_count = cmd->instance_count;
    const GLint basevertex = cmd->basevertex;
@@ -780,7 +799,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
 
          cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-         cmd->type = MIN2(type, 0xffff);
+         cmd->type = encode_index_type(type);
          cmd->count = count;
          cmd->indices = indices;
          cmd->basevertex = basevertex;
@@ -791,7 +810,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstanced, cmd_size);
 
             cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-            cmd->type = MIN2(type, 0xffff);
+            cmd->type = encode_index_type(type);
             cmd->count = count;
             cmd->instance_count = instance_count;
             cmd->indices = indices;
@@ -801,7 +820,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstance, cmd_size);
 
             cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-            cmd->type = MIN2(type, 0xffff);
+            cmd->type = encode_index_type(type);
             cmd->count = count;
             cmd->instance_count = instance_count;
             cmd->basevertex = basevertex;
@@ -813,7 +832,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstanceDrawID, cmd_size);
 
             cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-            cmd->type = MIN2(type, 0xffff);
+            cmd->type = encode_index_type(type);
             cmd->count = count;
             cmd->instance_count = instance_count;
             cmd->basevertex = basevertex;
@@ -891,7 +910,7 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
    cmd->num_slots = align(cmd_size, 8) / 8;
    cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-   cmd->type = MIN2(type, 0xffff);
+   cmd->type = encode_index_type(type);
    cmd->count = count;
    cmd->indices = indices;
    cmd->instance_count = instance_count;
@@ -910,7 +929,7 @@ struct marshal_cmd_MultiDrawElementsUserBuf
    struct marshal_cmd_base cmd_base;
    bool has_base_vertex;
    GLenum8 mode;
-   GLenum16 type;
+   GLindextype type;
    uint16_t num_slots;
    GLsizei draw_count;
    GLuint user_buffer_mask;
@@ -944,7 +963,7 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
 
    /* Draw. */
    const GLenum mode = cmd->mode;
-   const GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    struct gl_buffer_object *index_buffer = cmd->index_buffer;
 
    CALL_MultiDrawElementsUserBuf(ctx->Dispatch.Current,
@@ -977,7 +996,7 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsUserBuf, cmd_size);
       cmd->num_slots = align(cmd_size, 8) / 8;
       cmd->mode = MIN2(mode, 0xff); /* primitive types go from 0 to 14 */
-      cmd->type = MIN2(type, 0xffff);
+      cmd->type = encode_index_type(type);
       cmd->draw_count = draw_count;
       cmd->user_buffer_mask = user_buffer_mask;
       cmd->index_buffer = index_buffer;
@@ -1332,7 +1351,7 @@ _mesa_unmarshal_DrawElementsIndirect(struct gl_context *ctx,
                                      const struct marshal_cmd_DrawElementsIndirect *cmd)
 {
    GLenum mode = cmd->mode;
-   GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid * indirect = cmd->indirect;
 
    CALL_DrawElementsIndirect(ctx->Dispatch.Current, (mode, type, indirect));
@@ -1354,7 +1373,7 @@ _mesa_marshal_DrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indir
 
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsIndirect, cmd_size);
       cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->type = encode_index_type(type);
       cmd->indirect = indirect;
       return;
    }
@@ -1410,7 +1429,7 @@ _mesa_unmarshal_MultiDrawElementsIndirect(struct gl_context *ctx,
                                           const struct marshal_cmd_MultiDrawElementsIndirect *cmd)
 {
    GLenum mode = cmd->mode;
-   GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid * indirect = cmd->indirect;
    GLsizei primcount = cmd->primcount;
    GLsizei stride = cmd->stride;
@@ -1439,7 +1458,7 @@ _mesa_marshal_MultiDrawElementsIndirect(GLenum mode, GLenum type,
       cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirect,
                                             cmd_size);
       cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->type = encode_index_type(type);
       cmd->indirect = indirect;
       cmd->primcount = primcount;
       cmd->stride = stride;
@@ -1508,7 +1527,7 @@ _mesa_unmarshal_MultiDrawElementsIndirectCountARB(struct gl_context *ctx,
                                                   const struct marshal_cmd_MultiDrawElementsIndirectCountARB *cmd)
 {
    GLenum mode = cmd->mode;
-   GLenum type = cmd->type;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
    GLintptr indirect = cmd->indirect;
    GLintptr drawcount = cmd->drawcount;
    GLsizei maxdrawcount = cmd->maxdrawcount;
@@ -1541,7 +1560,7 @@ _mesa_marshal_MultiDrawElementsIndirectCountARB(GLenum mode, GLenum type,
          _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirectCountARB, cmd_size);
 
       cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->type = encode_index_type(type);
       cmd->indirect = indirect;
       cmd->drawcount = drawcount;
       cmd->maxdrawcount = maxdrawcount;
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index c687adb58c02..f8e0bb6d3912 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -64,8 +64,8 @@ struct marshal_cmd_DrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
    GLenum8 mode;
+   GLindextype type;
    uint16_t num_slots;
-   GLenum16 type;
    GLsizei count;
    GLsizei instance_count;
    GLint basevertex;
@@ -97,6 +97,12 @@ _mesa_glthread_allocate_command(struct gl_context *ctx,
    return cmd_base;
 }
 
+static inline GLenum
+_mesa_decode_index_type(GLindextype type)
+{
+   return (GLenum)type.value + GL_UNSIGNED_BYTE - 1;
+}
+
 static inline struct marshal_cmd_base *
 _mesa_glthread_get_cmd(uint64_t *opaque_cmd)
 {
diff --git a/src/util/glheader.h b/src/util/glheader.h
index 8ac8ee3ba3c1..b068417521ae 100644
--- a/src/util/glheader.h
+++ b/src/util/glheader.h
@@ -90,6 +90,13 @@ typedef unsigned char GLbitfield8;
 typedef unsigned short GLbitfield16;
 typedef GLuint64 GLbitfield64;
 
+/* This is for packing the GL index type. The reason it's a structure is that
+ * we don't want it to be used as integer accidentally.
+ */
+typedef struct {
+   uint8_t value;
+} GLindextype;
+
 /* There is no formal spec for the following extension. */
 #ifndef GL_ATI_texture_compression_3dc
 #define GL_ATI_texture_compression_3dc                          1
-- 
GitLab


From 9c57a6ecac42a6652973a724bee8259001d0399a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 23:34:07 -0500
Subject: [PATCH 12/32] glthread: rewrite glDrawElements call packing

Since changing 2 fields to 8 bits and the removal of cmd_size, call sizes
have decreased by 4 bytes, so we have 4 unused bytes in most DrawElements
structures. So far we have used these calls for all DrawElements variants:

- DrawElementsBaseVertex
- DrawElementsInstanced
- DrawElementsInstancedBaseVertexBaseInstance
- DrawElementsInstancedBaseVertexBaseInstanceDrawID

Change them to these by either removing 4 more bytes or adding 4 bytes,
so that we don't waste space.

- DrawElements
- DrawElementsInstancedBaseVertex
- DrawElementsInstancedBaseInstance
- DrawElementsInstancedBaseVertexBaseInstanceDrawID

This decreases the size of 1 frame in glthread batches by 12%
in Viewperf2020/Catia1.
---
 src/mapi/glapi/gen/ARB_base_instance.xml      |   4 +-
 .../gen/ARB_draw_elements_base_vertex.xml     |   4 +-
 src/mapi/glapi/gen/ARB_draw_instanced.xml     |   2 +-
 src/mapi/glapi/gen/gl_API.xml                 |  12 +-
 src/mesa/main/glthread_draw.c                 | 157 ++++++++----------
 5 files changed, 87 insertions(+), 92 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_base_instance.xml b/src/mapi/glapi/gen/ARB_base_instance.xml
index 768b14478706..7e8ec3b2ecfc 100644
--- a/src/mapi/glapi/gen/ARB_base_instance.xml
+++ b/src/mapi/glapi/gen/ARB_base_instance.xml
@@ -18,7 +18,7 @@
   </function>
 
   <function name="DrawElementsInstancedBaseInstance" marshal="custom" exec="dlist"
-            marshal_no_error="true">
+            marshal_no_error="true" marshal_struct="public">
     <param name="mode" type="GLenum"/>
     <param name="count" type="GLsizei"/>
     <param name="type" type="GLenum"/>
@@ -28,7 +28,7 @@
   </function>
 
   <function name="DrawElementsInstancedBaseVertexBaseInstance" marshal="custom" exec="dlist"
-            marshal_struct="public" marshal_no_error="true">
+            marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="count" type="GLsizei"/>
     <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml b/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
index a7353c544ff1..27ea26ba60a3 100644
--- a/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
+++ b/src/mapi/glapi/gen/ARB_draw_elements_base_vertex.xml
@@ -9,7 +9,7 @@
 <category name="GL_ARB_draw_elements_base_vertex" number="62">
 
     <function name="DrawElementsBaseVertex" es2="3.2" marshal="custom" exec="dlist"
-              marshal_struct="public" marshal_no_error="true">
+              marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="count" type="GLsizei"/>
         <param name="type" type="GLenum"/>
@@ -38,7 +38,7 @@
     </function>
 
     <function name="DrawElementsInstancedBaseVertex" es2="2.0" marshal="custom" exec="dlist"
-              marshal_no_error="true">
+              marshal_no_error="true" marshal_struct="public">
         <param name="mode" type="GLenum"/>
         <param name="count" type="GLsizei"/>
         <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/ARB_draw_instanced.xml b/src/mapi/glapi/gen/ARB_draw_instanced.xml
index cadf9f538462..d43f10397980 100644
--- a/src/mapi/glapi/gen/ARB_draw_instanced.xml
+++ b/src/mapi/glapi/gen/ARB_draw_instanced.xml
@@ -17,7 +17,7 @@
   </function>
 
   <function name="DrawElementsInstanced" marshal="custom" exec="dlist" es2="2.0"
-            marshal_struct="public" marshal_no_error="true">
+            marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="count" type="GLsizei"/>
     <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 5437558be63c..9727ecaab35a 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -3219,7 +3219,7 @@
     </function>
 
     <function name="DrawElements" es1="1.0" es2="2.0" marshal="custom" exec="dlist"
-              marshal_no_error="true">
+              marshal_no_error="true" marshal_struct="public">
         <param name="mode" type="GLenum"/>
         <param name="count" type="GLsizei"/>
         <param name="type" type="GLenum"/>
@@ -12959,7 +12959,15 @@
     </function>
 
     <function name="DrawElementsInstancedBaseVertexBaseInstanceDrawID"
-              es1="1.0" es2="2.0" marshal="custom">
+              es1="1.0" es2="2.0" marshal="custom" marshal_struct="public">
+        <param name="mode" type="GLenum"/>
+        <param name="count" type="GLsizei"/>
+        <param name="type" type="GLenum"/>
+        <param name="indices" type="const GLvoid *"/>
+        <param name="instance_count" type="GLsizei"/>
+        <param name="basevertex" type="GLint"/>
+        <param name="baseinstance" type="GLuint"/>
+        <param name="drawid" type="GLuint"/>
     </function>
 
     <!-- Internal function for glthread to implement ancillary buffer invalidation. -->
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 90e6d4f028ad..2bbbeec57746 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -615,71 +615,53 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
    }
 }
 
-/* DrawElementsInstanced without user buffers. */
 uint32_t
-_mesa_unmarshal_DrawElementsInstanced(struct gl_context *ctx,
-                                      const struct marshal_cmd_DrawElementsInstanced *restrict cmd)
+_mesa_unmarshal_DrawElements(struct gl_context *ctx,
+                             const struct marshal_cmd_DrawElements *restrict cmd)
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
    const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
-   const GLsizei instance_count = cmd->instance_count;
 
-   CALL_DrawElementsInstanced(ctx->Dispatch.Current,
-                              (mode, count, type, indices, instance_count));
+   CALL_DrawElements(ctx->Dispatch.Current, (mode, count, type, indices));
    return align(sizeof(*cmd), 8) / 8;
 }
 
-/* DrawElementsBaseVertex without user buffers. */
 uint32_t
-_mesa_unmarshal_DrawElementsBaseVertex(struct gl_context *ctx,
-                                       const struct marshal_cmd_DrawElementsBaseVertex *restrict cmd)
+_mesa_unmarshal_DrawElementsInstancedBaseVertex(struct gl_context *ctx,
+                                                const struct marshal_cmd_DrawElementsInstancedBaseVertex *restrict cmd)
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
    const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
+   const GLsizei instance_count = cmd->primcount;
    const GLint basevertex = cmd->basevertex;
 
-   CALL_DrawElementsBaseVertex(ctx->Dispatch.Current,
-                               (mode, count, type, indices, basevertex));
+   CALL_DrawElementsInstancedBaseVertex(ctx->Dispatch.Current,
+                                        (mode, count, type, indices,
+                                         instance_count, basevertex));
    return align(sizeof(*cmd), 8) / 8;
 }
 
-/* DrawElementsInstancedBaseVertexBaseInstance without user buffers. */
 uint32_t
-_mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *ctx,
-                                                            const struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *restrict cmd)
+_mesa_unmarshal_DrawElementsInstancedBaseInstance(struct gl_context *ctx,
+                                                  const struct marshal_cmd_DrawElementsInstancedBaseInstance *restrict cmd)
 {
    const GLenum mode = cmd->mode;
    const GLsizei count = cmd->count;
    const GLenum type = _mesa_decode_index_type(cmd->type);
    const GLvoid *indices = cmd->indices;
-   const GLsizei instance_count = cmd->instance_count;
-   const GLint basevertex = cmd->basevertex;
-   const GLuint baseinstance = cmd->baseinstance;
+   const GLsizei instance_count = cmd->primcount;
+   const GLint baseinstance = cmd->baseinstance;
 
-   CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->Dispatch.Current,
-                                                    (mode, count, type, indices,
-                                                     instance_count, basevertex,
-                                                     baseinstance));
+   CALL_DrawElementsInstancedBaseInstance(ctx->Dispatch.Current,
+                                          (mode, count, type, indices,
+                                           instance_count, baseinstance));
    return align(sizeof(*cmd), 8) / 8;
 }
 
-struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID
-{
-   struct marshal_cmd_base cmd_base;
-   GLenum8 mode;
-   GLindextype type;
-   GLsizei count;
-   GLsizei instance_count;
-   GLint basevertex;
-   GLuint baseinstance;
-   GLuint drawid;
-   const GLvoid *indices;
-};
-
 uint32_t
 _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(struct gl_context *ctx,
                                                                   const struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID *restrict cmd)
@@ -793,53 +775,52 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
          ctx->Dispatch.Current == ctx->Dispatch.ContextLost || /* GL_INVALID_OPERATION */
          ctx->GLThread.inside_begin_end ||      /* GL_INVALID_OPERATION */
          ctx->GLThread.ListMode))) {            /* GL_INVALID_OPERATION */
-      if (instance_count == 1 && baseinstance == 0 && drawid == 0) {
-         int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
-         struct marshal_cmd_DrawElementsBaseVertex *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
-
-         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-         cmd->type = encode_index_type(type);
-         cmd->count = count;
-         cmd->indices = indices;
-         cmd->basevertex = basevertex;
-      } else {
-         if (basevertex == 0 && baseinstance == 0 && drawid == 0) {
-            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstanced);
-            struct marshal_cmd_DrawElementsInstanced *cmd =
-               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstanced, cmd_size);
-
-            cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-            cmd->type = encode_index_type(type);
-            cmd->count = count;
-            cmd->instance_count = instance_count;
-            cmd->indices = indices;
-         } else if (drawid == 0) {
-            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance);
-            struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *cmd =
-               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstance, cmd_size);
+      if (drawid == 0 && baseinstance == 0) {
+         if (instance_count == 1 && basevertex == 0) {
+            int cmd_size = sizeof(struct marshal_cmd_DrawElements);
+            struct marshal_cmd_DrawElements *cmd =
+                  _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElements, cmd_size);
 
             cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
             cmd->type = encode_index_type(type);
             cmd->count = count;
-            cmd->instance_count = instance_count;
-            cmd->basevertex = basevertex;
-            cmd->baseinstance = baseinstance;
             cmd->indices = indices;
          } else {
-            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID);
-            struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID *cmd =
-               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstanceDrawID, cmd_size);
+            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertex);
+            struct marshal_cmd_DrawElementsInstancedBaseVertex *cmd =
+                  _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertex, cmd_size);
 
             cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
             cmd->type = encode_index_type(type);
             cmd->count = count;
-            cmd->instance_count = instance_count;
+            cmd->primcount = instance_count;
             cmd->basevertex = basevertex;
-            cmd->baseinstance = baseinstance;
-            cmd->drawid = drawid;
             cmd->indices = indices;
          }
+      } else if (drawid == 0 && basevertex == 0) {
+         int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseInstance);
+         struct marshal_cmd_DrawElementsInstancedBaseInstance *cmd =
+               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseInstance, cmd_size);
+
+         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
+         cmd->type = encode_index_type(type);
+         cmd->count = count;
+         cmd->primcount = instance_count;
+         cmd->baseinstance = baseinstance;
+         cmd->indices = indices;
+      } else {
+         int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID);
+         struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID *cmd =
+            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstanceDrawID, cmd_size);
+
+         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
+         cmd->type = encode_index_type(type);
+         cmd->count = count;
+         cmd->instance_count = instance_count;
+         cmd->basevertex = basevertex;
+         cmd->baseinstance = baseinstance;
+         cmd->drawid = drawid;
+         cmd->indices = indices;
       }
       return;
    }
@@ -1784,40 +1765,40 @@ _mesa_unmarshal_MultiDrawArrays(struct gl_context *ctx,
 }
 
 uint32_t
-_mesa_unmarshal_DrawElements(struct gl_context *ctx,
-                             const struct marshal_cmd_DrawElements *restrict cmd)
+_mesa_unmarshal_DrawRangeElements(struct gl_context *ctx,
+                                  const struct marshal_cmd_DrawRangeElements *restrict cmd)
 {
    unreachable("should never end up here");
    return 0;
 }
 
 uint32_t
-_mesa_unmarshal_DrawRangeElements(struct gl_context *ctx,
-                                  const struct marshal_cmd_DrawRangeElements *restrict cmd)
+_mesa_unmarshal_DrawRangeElementsBaseVertex(struct gl_context *ctx,
+                                            const struct marshal_cmd_DrawRangeElementsBaseVertex *cmd)
 {
    unreachable("should never end up here");
    return 0;
 }
 
 uint32_t
-_mesa_unmarshal_DrawRangeElementsBaseVertex(struct gl_context *ctx,
-                                            const struct marshal_cmd_DrawRangeElementsBaseVertex *cmd)
+_mesa_unmarshal_DrawElementsInstanced(struct gl_context *ctx,
+                                      const struct marshal_cmd_DrawElementsInstanced *restrict cmd)
 {
    unreachable("should never end up here");
    return 0;
 }
 
 uint32_t
-_mesa_unmarshal_DrawElementsInstancedBaseVertex(struct gl_context *ctx,
-                                                const struct marshal_cmd_DrawElementsInstancedBaseVertex *restrict cmd)
+_mesa_unmarshal_DrawElementsBaseVertex(struct gl_context *ctx,
+                                       const struct marshal_cmd_DrawElementsBaseVertex *restrict cmd)
 {
    unreachable("should never end up here");
    return 0;
 }
 
 uint32_t
-_mesa_unmarshal_DrawElementsInstancedBaseInstance(struct gl_context *ctx,
-                                                  const struct marshal_cmd_DrawElementsInstancedBaseInstance *restrict cmd)
+_mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *ctx,
+                                                            const struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *restrict cmd)
 {
    unreachable("should never end up here");
    return 0;
@@ -1890,7 +1871,10 @@ _mesa_marshal_DrawArraysInstancedBaseInstanceDrawID(void)
 }
 
 void GLAPIENTRY
-_mesa_marshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(void)
+_mesa_marshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(GLenum mode, GLsizei count,
+                                                                GLenum type, const GLvoid *indices,
+                                                                GLsizei instance_count, GLint basevertex,
+                                                                GLuint baseinstance, GLuint drawid)
 {
    unreachable("should never end up here");
 }
@@ -1914,7 +1898,10 @@ _mesa_DrawArraysInstancedBaseInstanceDrawID(void)
 }
 
 void GLAPIENTRY
-_mesa_DrawElementsInstancedBaseVertexBaseInstanceDrawID(void)
+_mesa_DrawElementsInstancedBaseVertexBaseInstanceDrawID(GLenum mode, GLsizei count,
+                                                        GLenum type, const GLvoid *indices,
+                                                        GLsizei instance_count, GLint basevertex,
+                                                        GLuint baseinstance, GLuint drawid)
 {
    unreachable("should never end up here");
 }
@@ -1926,27 +1913,27 @@ _mesa_unmarshal_PushMatrix(struct gl_context *ctx,
    const unsigned push_matrix_size = 1;
    const unsigned mult_matrixf_size = 9;
    const unsigned draw_elements_size =
-      (align(sizeof(struct marshal_cmd_DrawElementsBaseVertex), 8) / 8);
+      (align(sizeof(struct marshal_cmd_DrawElements), 8) / 8);
    const unsigned pop_matrix_size = 1;
    uint64_t *next1 = _mesa_glthread_next_cmd((uint64_t *)cmd, push_matrix_size);
    uint64_t *next2;
 
    /* Viewperf has these call patterns. */
    switch (_mesa_glthread_get_cmd(next1)->cmd_id) {
-   case DISPATCH_CMD_DrawElementsBaseVertex:
+   case DISPATCH_CMD_DrawElements:
       /* Execute this sequence:
        *    glPushMatrix
        *    (glMultMatrixf with identity is eliminated by the marshal function)
-       *    glDrawElementsBaseVertex (also used by glDraw{Range}Elements)
+       *    glDrawElements
        *    glPopMatrix
        * as:
-       *    glDrawElementsBaseVertex (also used by glDraw{Range}Elements)
+       *    glDrawElements
        */
       next2 = _mesa_glthread_next_cmd(next1, draw_elements_size);
 
       if (_mesa_glthread_get_cmd(next2)->cmd_id == DISPATCH_CMD_PopMatrix) {
          /* The beauty of this is that this is inlined. */
-         _mesa_unmarshal_DrawElementsBaseVertex(ctx, (void*)next1);
+         _mesa_unmarshal_DrawElements(ctx, (void*)next1);
          return push_matrix_size + draw_elements_size + pop_matrix_size;
       }
       break;
-- 
GitLab


From 92bcb362ae8eb3e2535ba3848b88333872d367e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 23:34:07 -0500
Subject: [PATCH 13/32] glthread: rewrite glDrawArrays call packing

Since changing 1 field to 8 bits and the removal of cmd_size, call sizes
have decreased, so we have 4 unused bytes in 2 DrawArrays structures
So far we use:

- DrawArrays
- DrawArraysInstancedBaseInstance
- DrawArraysInstancedBaseInstanceDrawID

Change them to these by either removing 4 more bytes or adding 4 bytes,
so that we don't waste space, which drops the number of used calls by 1:

- DrawArraysInstanced
- DrawArraysInstancedBaseInstanceDrawID
---
 src/mapi/glapi/gen/ARB_base_instance.xml  |  2 +-
 src/mapi/glapi/gen/ARB_draw_instanced.xml |  2 +-
 src/mapi/glapi/gen/gl_API.xml             |  2 +-
 src/mesa/main/glthread_draw.c             | 57 ++++++++---------------
 4 files changed, 23 insertions(+), 40 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_base_instance.xml b/src/mapi/glapi/gen/ARB_base_instance.xml
index 7e8ec3b2ecfc..53774731daf0 100644
--- a/src/mapi/glapi/gen/ARB_base_instance.xml
+++ b/src/mapi/glapi/gen/ARB_base_instance.xml
@@ -9,7 +9,7 @@
 <category name="GL_ARB_base_instance" number="107">
 
   <function name="DrawArraysInstancedBaseInstance" marshal="custom" exec="dlist"
-            marshal_struct="public" marshal_no_error="true">
+            marshal_no_error="true">
     <param name="mode" type="GLenum"/>
     <param name="first" type="GLint"/>
     <param name="count" type="GLsizei"/>
diff --git a/src/mapi/glapi/gen/ARB_draw_instanced.xml b/src/mapi/glapi/gen/ARB_draw_instanced.xml
index d43f10397980..0d52295d3788 100644
--- a/src/mapi/glapi/gen/ARB_draw_instanced.xml
+++ b/src/mapi/glapi/gen/ARB_draw_instanced.xml
@@ -9,7 +9,7 @@
 <category name="GL_ARB_draw_instanced" number="44">
 
   <function name="DrawArraysInstanced" marshal="custom" exec="dlist" es2="2.0"
-            marshal_no_error="true">
+            marshal_no_error="true" marshal_struct="public">
     <param name="mode" type="GLenum"/>
     <param name="first" type="GLint"/>
     <param name="count" type="GLsizei"/>
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 9727ecaab35a..e682b08e84d9 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -3211,7 +3211,7 @@
     </function>
 
     <function name="DrawArrays" es1="1.0" es2="2.0" marshal="custom" exec="dlist"
-              marshal_struct="public" marshal_no_error="true">
+              marshal_no_error="true">
         <param name="mode" type="GLenum"/>
         <param name="first" type="GLint"/>
         <param name="count" type="GLsizei"/>
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 2bbbeec57746..7c5a48d6f9a2 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -280,33 +280,17 @@ upload_vertices(struct gl_context *ctx, unsigned user_buffer_mask,
    return true;
 }
 
-/* DrawArrays without user buffers. */
+/* DrawArraysInstanced without user buffers. */
 uint32_t
-_mesa_unmarshal_DrawArrays(struct gl_context *ctx,
-                           const struct marshal_cmd_DrawArrays *restrict cmd)
-{
-   const GLenum mode = cmd->mode;
-   const GLint first = cmd->first;
-   const GLsizei count = cmd->count;
-
-   CALL_DrawArrays(ctx->Dispatch.Current, (mode, first, count));
-   return align(sizeof(*cmd), 8) / 8;
-}
-
-/* DrawArraysInstancedBaseInstance without user buffers. */
-uint32_t
-_mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
-                                                const struct marshal_cmd_DrawArraysInstancedBaseInstance *restrict cmd)
+_mesa_unmarshal_DrawArraysInstanced(struct gl_context *ctx,
+                                    const struct marshal_cmd_DrawArraysInstanced *restrict cmd)
 {
    const GLenum mode = cmd->mode;
    const GLint first = cmd->first;
    const GLsizei count = cmd->count;
-   const GLsizei instance_count = cmd->instance_count;
-   const GLuint baseinstance = cmd->baseinstance;
+   const GLsizei instance_count = cmd->primcount;
 
-   CALL_DrawArraysInstancedBaseInstance(ctx->Dispatch.Current,
-                                        (mode, first, count, instance_count,
-                                         baseinstance));
+   CALL_DrawArraysInstanced(ctx->Dispatch.Current, (mode, first, count, instance_count));
    return align(sizeof(*cmd), 8) / 8;
 }
 
@@ -430,24 +414,15 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
          ctx->GLThread.inside_begin_end ||      /* GL_INVALID_OPERATION */
          ctx->Dispatch.Current == ctx->Dispatch.ContextLost || /* GL_INVALID_OPERATION */
          ctx->GLThread.ListMode))) {            /* GL_INVALID_OPERATION */
-      if (instance_count == 1 && baseinstance == 0 && drawid == 0) {
-         int cmd_size = sizeof(struct marshal_cmd_DrawArrays);
-         struct marshal_cmd_DrawArrays *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArrays, cmd_size);
-
-         cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-         cmd->first = first;
-         cmd->count = count;
-      } else if (drawid == 0) {
-         int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstancedBaseInstance);
-         struct marshal_cmd_DrawArraysInstancedBaseInstance *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstance, cmd_size);
+      if (baseinstance == 0 && drawid == 0) {
+         int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstanced);
+         struct marshal_cmd_DrawArraysInstanced *cmd =
+            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstanced, cmd_size);
 
          cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
          cmd->first = first;
          cmd->count = count;
-         cmd->instance_count = instance_count;
-         cmd->baseinstance = baseinstance;
+         cmd->primcount = instance_count;
       } else {
          int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID);
          struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID *cmd =
@@ -1749,8 +1724,16 @@ _mesa_marshal_MultiDrawElements(GLenum mode, const GLsizei *count,
 }
 
 uint32_t
-_mesa_unmarshal_DrawArraysInstanced(struct gl_context *ctx,
-                                    const struct marshal_cmd_DrawArraysInstanced *restrict cmd)
+_mesa_unmarshal_DrawArrays(struct gl_context *ctx,
+                           const struct marshal_cmd_DrawArrays *restrict cmd)
+{
+   unreachable("should never end up here");
+   return 0;
+}
+
+uint32_t
+_mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
+                                                const struct marshal_cmd_DrawArraysInstancedBaseInstance *restrict cmd)
 {
    unreachable("should never end up here");
    return 0;
-- 
GitLab


From 194e39632728068fdb37fc8be0c12b05d4bbd2f1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 18:18:46 -0500
Subject: [PATCH 14/32] glapi: fix type names for glthread and handle all types

glthread will compare the whole type string, so the string must not have
trailing spaces.

No functional change.
---
 src/mapi/glapi/gen/ARB_program_interface_query.xml | 6 +++---
 src/mapi/glapi/gen/gl_API.xml                      | 2 +-
 src/mapi/glapi/gen/marshal_XML.py                  | 4 +++-
 3 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_program_interface_query.xml b/src/mapi/glapi/gen/ARB_program_interface_query.xml
index c3162f5ed16f..c14cb6ba7679 100644
--- a/src/mapi/glapi/gen/ARB_program_interface_query.xml
+++ b/src/mapi/glapi/gen/ARB_program_interface_query.xml
@@ -74,7 +74,7 @@
         <param name="program" type="GLuint"/>
         <param name="programInterface" type="GLenum"/>
         <param name="index" type="GLuint"/>
-        <param name="bufSize" type="GLsizei "/>
+        <param name="bufSize" type="GLsizei"/>
         <param name="length" type="GLsizei *" output="true"/>
         <param name="name" type="GLchar *" output="true"/>
     </function>
@@ -83,9 +83,9 @@
         <param name="program" type="GLuint"/>
         <param name="programInterface" type="GLenum"/>
         <param name="index" type="GLuint"/>
-        <param name="propCount" type="GLsizei "/>
+        <param name="propCount" type="GLsizei"/>
         <param name="props" type="const GLenum *" output="true"/>
-        <param name="bufSize" type="GLsizei "/>
+        <param name="bufSize" type="GLsizei"/>
         <param name="length" type="GLsizei *" output="true"/>
         <param name="params" type="GLint *" output="true"/>
     </function>
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index e682b08e84d9..199cf72c703d 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -5410,7 +5410,7 @@
     <function name="GetActiveAttrib" es2="2.0">
         <param name="program" type="GLuint"/>
         <param name="index" type="GLuint"/>
-        <param name="bufSize" type="GLsizei "/>
+        <param name="bufSize" type="GLsizei"/>
         <param name="length" type="GLsizei *" output="true"/>
         <param name="size" type="GLint *" output="true"/>
         <param name="type" type="GLenum *" output="true"/>
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index f60257430524..b2465438710b 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -24,6 +24,7 @@
 # building thread marshalling code.
 
 import gl_XML
+import sys
 
 # We decrease the type size when it's safe, such as when the maximum value
 # and all greater values are invalid.
@@ -95,10 +96,11 @@ def get_type_size(func_name, param):
         'GLuint64': 8,
         'GLuint64EXT': 8,
         'GLsync': 8,
+        'GLDEBUGPROC': 8,
     }
     val = mapping.get(type, 9999)
     if val == 9999:
-        print('Unhandled type in marshal_XML.get_type_size: ' + type, file=sys.stderr)
+        print('Unhandled type in marshal_XML.get_type_size: "{0}"'.format(type), file=sys.stderr)
         assert False
     return val
 
-- 
GitLab


From 10c8113a4d2480d71acdc2201cd7b75fc52ff714 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 18:19:47 -0500
Subject: [PATCH 15/32] glthread: sort fixed-sized parameters before returning
 them

No functional change.
---
 src/mapi/glapi/gen/marshal_XML.py | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index b2465438710b..e492dbb69855 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -179,9 +179,11 @@ class marshal_function(gl_XML.gl_function):
         # path towards handling PBOs in glthread, which use marshal_sync to check whether
         # a PBO is bound.
         if self.marshal_sync:
-            return self.fixed_params + self.variable_params
+            list = self.fixed_params + self.variable_params
         else:
-            return self.fixed_params
+            list = self.fixed_params
+
+        return sorted(list, key=lambda p: get_type_size(self.name, p))
 
     def get_variable_params(self):
         if self.marshal_sync:
@@ -200,8 +202,7 @@ class marshal_function(gl_XML.gl_function):
             if variable_params:
                 print('   uint16_t num_slots;')
 
-            # Sort the parameters according to their size to pack the structure optimally
-            for p in sorted(fixed_params, key=lambda p: get_type_size(self.name, p)):
+            for p in fixed_params:
                 if p.count:
                     print('   {0} {1}[{2}];'.format(
                             p.get_base_type_string(), p.name, p.count))
-- 
GitLab


From dce64e8bcef59e188645ddc24db9368f6371ac69 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 18:39:03 -0500
Subject: [PATCH 16/32] glthread: move global marshal_XML.py functions into
 class marshal_function

No functional change.
---
 src/mapi/glapi/gen/gl_marshal.py  |   4 +-
 src/mapi/glapi/gen/marshal_XML.py | 160 +++++++++++++++---------------
 2 files changed, 83 insertions(+), 81 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 69a5b1d4a085..cef84e6175b8 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -121,7 +121,7 @@ class PrintCode(gl_XML.gl_print_base):
                             p.get_base_type_string(), p.name)
                 else:
                     p_decl = '{0} {1} = cmd->{1};'.format(
-                            marshal_XML.get_marshal_type(func.name, p), p.name)
+                            func.get_marshal_type(p), p.name)
 
                 if not p_decl.startswith('const ') and p.count:
                     # Declare all local function variables as const, even if
@@ -220,7 +220,7 @@ class PrintCode(gl_XML.gl_print_base):
                 out('cmd->num_slots = align(cmd_size, 8) / 8;')
 
             for p in fixed_params:
-                type = marshal_XML.get_marshal_type(func.name, p)
+                type = func.get_marshal_type(p)
 
                 if p.count:
                     out('memcpy(cmd->{0}, {0}, {1});'.format(
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index e492dbb69855..8837d84e1199 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -26,83 +26,6 @@
 import gl_XML
 import sys
 
-# We decrease the type size when it's safe, such as when the maximum value
-# and all greater values are invalid.
-def get_marshal_type(func_name, param):
-    type = param.type_string()
-
-    if ('Draw' in func_name and
-        ('Arrays' in func_name or
-         'Elements' in func_name or
-         'TransformFeedback' in func_name)):
-        if (type, param.name) == ('GLenum', 'mode'):
-            return 'GLenum8'
-
-        if (type, param.name) == ('GLenum', 'type'):
-            return 'GLindextype'
-
-    if type == 'GLenum':
-        return 'GLenum16' # clamped to 0xffff (always invalid enum)
-
-    if (func_name == 'InterleavedArrays' or
-        func_name.endswith('VertexBuffer') or
-        func_name.endswith('VertexBufferEXT') or
-        func_name.endswith('Pointer') or
-        func_name.endswith('PointerEXT') or
-        func_name.endswith('PointerOES') or
-        func_name.endswith('OffsetEXT')):
-        if (type, param.name) == ('GLsizei', 'stride'):
-            return 'GLclamped16i'
-
-        if (type, param.name) == ('GLint', 'size'):
-            return 'GLpacked16i'
-
-    return type
-
-def get_type_size(func_name, param):
-    type = get_marshal_type(func_name, param)
-
-    if type.find('*') != -1:
-        return 8;
-
-    mapping = {
-        'GLboolean': 1,
-        'GLbyte': 1,
-        'GLubyte': 1,
-        'GLenum8': 1, # clamped by glthread
-        'GLindextype': 1,
-        'GLenum16': 2, # clamped by glthread
-        'GLshort': 2,
-        'GLushort': 2,
-        'GLhalfNV': 2,
-        'GLclamped16i': 2, # clamped by glthread
-        'GLpacked16i': 2, # clamped by glthread
-        'GLint': 4,
-        'GLuint': 4,
-        'GLbitfield': 4,
-        'GLsizei': 4,
-        'GLfloat': 4,
-        'GLclampf': 4,
-        'GLfixed': 4,
-        'GLclampx': 4,
-        'GLhandleARB': 4,
-        'int': 4,
-        'float': 4,
-        'GLdouble': 8,
-        'GLclampd': 8,
-        'GLintptr': 8,
-        'GLsizeiptr': 8,
-        'GLint64': 8,
-        'GLuint64': 8,
-        'GLuint64EXT': 8,
-        'GLsync': 8,
-        'GLDEBUGPROC': 8,
-    }
-    val = mapping.get(type, 9999)
-    if val == 9999:
-        print('Unhandled type in marshal_XML.get_type_size: "{0}"'.format(type), file=sys.stderr)
-        assert False
-    return val
 
 class marshal_item_factory(gl_XML.gl_item_factory):
     """Factory to create objects derived from gl_item containing
@@ -113,6 +36,78 @@ class marshal_item_factory(gl_XML.gl_item_factory):
 
 
 class marshal_function(gl_XML.gl_function):
+    # We decrease the type size when it's safe, such as when the maximum value
+    # and all greater values are invalid.
+    def get_marshal_type(self, param):
+        type = param.type_string()
+
+        if ('Draw' in self.name and
+            ('Arrays' in self.name or
+             'Elements' in self.name or
+             'TransformFeedback' in self.name)):
+            if (type, param.name) == ('GLenum', 'mode'):
+                return 'GLenum8'
+
+            if (type, param.name) == ('GLenum', 'type'):
+                return 'GLindextype'
+
+        if type == 'GLenum':
+            return 'GLenum16' # clamped to 0xffff (always invalid enum)
+
+        if self.is_vertex_pointer_call:
+            if (type, param.name) == ('GLsizei', 'stride'):
+                return 'GLclamped16i'
+
+            if (type, param.name) == ('GLint', 'size'):
+                return 'GLpacked16i'
+
+        return type
+
+    def get_type_size(self, param):
+        type = self.get_marshal_type(param)
+
+        if type.find('*') != -1:
+            return 8;
+
+        mapping = {
+            'GLboolean': 1,
+            'GLbyte': 1,
+            'GLubyte': 1,
+            'GLenum8': 1, # clamped by glthread
+            'GLindextype': 1,
+            'GLenum16': 2, # clamped by glthread
+            'GLshort': 2,
+            'GLushort': 2,
+            'GLhalfNV': 2,
+            'GLclamped16i': 2, # clamped by glthread
+            'GLpacked16i': 2, # clamped by glthread
+            'GLint': 4,
+            'GLuint': 4,
+            'GLbitfield': 4,
+            'GLsizei': 4,
+            'GLfloat': 4,
+            'GLclampf': 4,
+            'GLfixed': 4,
+            'GLclampx': 4,
+            'GLhandleARB': 4,
+            'int': 4,
+            'float': 4,
+            'GLdouble': 8,
+            'GLclampd': 8,
+            'GLintptr': 8,
+            'GLsizeiptr': 8,
+            'GLint64': 8,
+            'GLuint64': 8,
+            'GLuint64EXT': 8,
+            'GLsync': 8,
+            'GLDEBUGPROC': 8,
+        }
+        val = mapping.get(type, 9999)
+        if val == 9999:
+            print('Unhandled type in marshal_XML.get_type_size: "{0}"'.format(type), file=sys.stderr)
+            assert False
+        return val
+
     def process_element(self, element):
         # Do normal processing.
         super(marshal_function, self).process_element(element)
@@ -140,6 +135,13 @@ class marshal_function(gl_XML.gl_function):
         self.marshal_call_after = element.get('marshal_call_after')
         self.marshal_struct = element.get('marshal_struct')
         self.marshal_no_error = gl_XML.is_attr_true(element, 'marshal_no_error')
+        self.is_vertex_pointer_call = (self.name == 'InterleavedArrays' or
+                                       self.name.endswith('VertexBuffer') or
+                                       self.name.endswith('VertexBufferEXT') or
+                                       self.name.endswith('Pointer') or
+                                       self.name.endswith('PointerEXT') or
+                                       self.name.endswith('PointerOES') or
+                                       self.name.endswith('OffsetEXT'))
 
     def marshal_flavor(self):
         """Find out how this function should be marshalled between
@@ -183,7 +185,7 @@ class marshal_function(gl_XML.gl_function):
         else:
             list = self.fixed_params
 
-        return sorted(list, key=lambda p: get_type_size(self.name, p))
+        return sorted(list, key=lambda p: self.get_type_size(p))
 
     def get_variable_params(self):
         if self.marshal_sync:
@@ -207,7 +209,7 @@ class marshal_function(gl_XML.gl_function):
                     print('   {0} {1}[{2}];'.format(
                             p.get_base_type_string(), p.name, p.count))
                 else:
-                    print('   {0} {1};'.format(get_marshal_type(self.name, p), p.name))
+                    print('   {0} {1};'.format(self.get_marshal_type(p), p.name))
 
             for p in variable_params:
                 if p.img_null_flag:
-- 
GitLab


From 513cdd0c881c003d3b8fb6d54cfc67f2912b772d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 18:54:34 -0500
Subject: [PATCH 17/32] glthread: precompute fixed_params and variable_params
 lists

This removes functions get_fixed_params and get_variable_params.

No functional change.
---
 src/mapi/glapi/gen/gl_marshal.py  | 31 ++++++++++------------
 src/mapi/glapi/gen/marshal_XML.py | 44 +++++++++++++------------------
 2 files changed, 32 insertions(+), 43 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index cef84e6175b8..0d652eac7db3 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -104,9 +104,6 @@ class PrintCode(gl_XML.gl_print_base):
         out('')
 
     def print_async_body(self, func):
-        fixed_params = func.get_fixed_params()
-        variable_params = func.get_variable_params()
-
         out('/* {0}: marshalled asynchronously */'.format(func.name))
         func.print_struct()
 
@@ -115,7 +112,7 @@ class PrintCode(gl_XML.gl_print_base):
              'const struct marshal_cmd_{0} *restrict cmd)').format(func.name))
         out('{')
         with indent():
-            for p in fixed_params:
+            for p in func.fixed_params:
                 if p.count:
                     p_decl = '{0} *{1} = cmd->{1};'.format(
                             p.get_base_type_string(), p.name)
@@ -130,13 +127,13 @@ class PrintCode(gl_XML.gl_print_base):
 
                 out(p_decl)
 
-            if variable_params:
-                for p in variable_params:
+            if func.variable_params:
+                for p in func.variable_params:
                     out('{0} *{1};'.format(
                             p.get_base_type_string(), p.name))
                 out('const char *variable_data = (const char *) (cmd + 1);')
                 i = 1
-                for p in variable_params:
+                for p in func.variable_params:
                     out('{0} = ({1} *) variable_data;'.format(
                             p.name, p.get_base_type_string()))
 
@@ -144,16 +141,16 @@ class PrintCode(gl_XML.gl_print_base):
                         out('if (cmd->{0}_null)'.format(p.name))
                         with indent():
                             out('{0} = NULL;'.format(p.name))
-                        if i < len(variable_params):
+                        if i < len(func.variable_params):
                             out('else')
                             with indent():
                                 out('variable_data += {0};'.format(p.size_string(False, marshal=1)))
-                    elif i < len(variable_params):
+                    elif i < len(func.variable_params):
                         out('variable_data += {0};'.format(p.size_string(False, marshal=1)))
                     i += 1
 
             self.print_call(func, unmarshal=1)
-            if variable_params:
+            if func.variable_params:
                 out('return cmd->num_slots;')
             else:
                 struct = 'struct marshal_cmd_{0}'.format(func.name)
@@ -216,10 +213,10 @@ class PrintCode(gl_XML.gl_print_base):
             # Add the call into the batch.
             out('cmd = _mesa_glthread_allocate_command(ctx, '
                 'DISPATCH_CMD_{0}, cmd_size);'.format(func.name))
-            if variable_params:
+            if func.variable_params:
                 out('cmd->num_slots = align(cmd_size, 8) / 8;')
 
-            for p in fixed_params:
+            for p in func.fixed_params:
                 type = func.get_marshal_type(p)
 
                 if p.count:
@@ -235,25 +232,25 @@ class PrintCode(gl_XML.gl_print_base):
                     out('cmd->{0} = {0} < 0 ? UINT16_MAX : MIN2({0}, UINT16_MAX);'.format(p.name))
                 else:
                     out('cmd->{0} = {0};'.format(p.name))
-            if variable_params:
+            if func.variable_params:
                 out('char *variable_data = (char *) (cmd + 1);')
                 i = 1
-                for p in variable_params:
+                for p in func.variable_params:
                     if p.img_null_flag:
                         out('cmd->{0}_null = !{0};'.format(p.name))
                         out('if (!cmd->{0}_null) {{'.format(p.name))
                         with indent():
                             out(('memcpy(variable_data, {0}, {0}_size);').format(p.name))
-                            if i < len(variable_params):
+                            if i < len(func.variable_params):
                                 out('variable_data += {0}_size;'.format(p.name))
                         out('}')
                     else:
                         out(('memcpy(variable_data, {0}, {0}_size);').format(p.name))
-                        if i < len(variable_params):
+                        if i < len(func.variable_params):
                             out('variable_data += {0}_size;'.format(p.name))
                     i += 1
 
-            if not fixed_params and not variable_params:
+            if not func.fixed_params and not func.variable_params:
                 out('(void) cmd;')
 
             if func.marshal_call_after:
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 8837d84e1199..11c3715601de 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -143,6 +143,20 @@ class marshal_function(gl_XML.gl_function):
                                        self.name.endswith('PointerOES') or
                                        self.name.endswith('OffsetEXT'))
 
+        # marshal_sync means whether a function should be called to determine
+        # whether we should sync.
+        if self.marshal_sync:
+            # This is a case of a pointer with an unknown size. Move
+            # variable-sized pointer parameters to fixed parameters because
+            # they will be passed as-is if the marshal_sync function evaluates
+            # to true.
+            self.fixed_params = self.fixed_params + self.variable_params
+            self.variable_params = []
+
+        # Sort the parameters, so that the marshal structure fields are sorted
+        # from smallest to biggest.
+        self.fixed_params = sorted(self.fixed_params, key=lambda p: self.get_type_size(p))
+
     def marshal_flavor(self):
         """Find out how this function should be marshalled between
         client and server threads."""
@@ -174,49 +188,27 @@ class marshal_function(gl_XML.gl_function):
                 self.name[0:8] != 'Internal' and
                 self.exec_flavor != 'beginend')
 
-    def get_fixed_params(self):
-        # We want glthread to ignore variable-sized parameters if the only thing
-        # we want is to pass the pointer parameter as-is, e.g. when a PBO is bound.
-        # Making it conditional on marshal_sync is kinda hacky, but it's the easiest
-        # path towards handling PBOs in glthread, which use marshal_sync to check whether
-        # a PBO is bound.
-        if self.marshal_sync:
-            list = self.fixed_params + self.variable_params
-        else:
-            list = self.fixed_params
-
-        return sorted(list, key=lambda p: self.get_type_size(p))
-
-    def get_variable_params(self):
-        if self.marshal_sync:
-            return []
-        else:
-            return self.variable_params
-
     def print_struct(self, is_header=False):
-        fixed_params = self.get_fixed_params()
-        variable_params = self.get_variable_params()
-
         if (self.marshal_struct == 'public') == is_header:
             print('struct marshal_cmd_{0}'.format(self.name))
             print('{')
             print('   struct marshal_cmd_base cmd_base;')
-            if variable_params:
+            if self.variable_params:
                 print('   uint16_t num_slots;')
 
-            for p in fixed_params:
+            for p in self.fixed_params:
                 if p.count:
                     print('   {0} {1}[{2}];'.format(
                             p.get_base_type_string(), p.name, p.count))
                 else:
                     print('   {0} {1};'.format(self.get_marshal_type(p), p.name))
 
-            for p in variable_params:
+            for p in self.variable_params:
                 if p.img_null_flag:
                     print('   bool {0}_null; /* If set, no data follows '
                         'for "{0}" */'.format(p.name))
 
-            for p in variable_params:
+            for p in self.variable_params:
                 if p.count_scale != 1:
                     print(('   /* Next {0} bytes are '
                          '{1} {2}[{3}][{4}] */').format(
-- 
GitLab


From 052a834c449d97be65631e384788b42695214cd2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 22:10:59 -0500
Subject: [PATCH 18/32] gltrhead: merge 3 blocks conditional on marshal_sync in
 print_async_body

There are 3 blocks next to each other that check marshal_sync. Merge them.

No functional change.
---
 src/mapi/glapi/gen/gl_marshal.py | 29 ++++++++++++++---------------
 1 file changed, 14 insertions(+), 15 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 0d652eac7db3..d370b4521ed5 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -166,22 +166,11 @@ class PrintCode(gl_XML.gl_print_base):
             if func.marshal_call_before:
                 out(func.marshal_call_before);
 
-            if not func.marshal_sync:
-                for p in func.variable_params:
-                    out('int {0}_size = {1};'.format(p.name, p.size_string(marshal=1)))
-
             struct = 'struct marshal_cmd_{0}'.format(func.name)
-            size_terms = ['sizeof({0})'.format(struct)]
-            if not func.marshal_sync:
-                for p in func.variable_params:
-                    if p.img_null_flag:
-                        size_terms.append('({0} ? {0}_size : 0)'.format(p.name))
-                    else:
-                        size_terms.append('{0}_size'.format(p.name))
-            out('int cmd_size = {0};'.format(' + '.join(size_terms)))
-            out('{0} *cmd;'.format(struct))
 
             if func.marshal_sync:
+                out('int cmd_size = sizeof({0});'.format(struct))
+
                 out('if ({0}) {{'.format(func.marshal_sync))
                 with indent():
                     out('_mesa_glthread_finish_before(ctx, "{0}");'.format(func.name))
@@ -189,6 +178,16 @@ class PrintCode(gl_XML.gl_print_base):
                     out('return;')
                 out('}')
             else:
+                size_terms = ['sizeof({0})'.format(struct)]
+                for p in func.variable_params:
+                    out('int {0}_size = {1};'.format(p.name, p.size_string(marshal=1)))
+                    if p.img_null_flag:
+                        size_terms.append('({0} ? {0}_size : 0)'.format(p.name))
+                    else:
+                        size_terms.append('{0}_size'.format(p.name))
+
+                out('int cmd_size = {0};'.format(' + '.join(size_terms)))
+
                 # Fall back to syncing if variable-length sizes can't be handled.
                 #
                 # Check that any counts for variable-length arguments might be < 0, in
@@ -211,8 +210,8 @@ class PrintCode(gl_XML.gl_print_base):
                     out('}')
 
             # Add the call into the batch.
-            out('cmd = _mesa_glthread_allocate_command(ctx, '
-                'DISPATCH_CMD_{0}, cmd_size);'.format(func.name))
+            out('{0} *cmd = _mesa_glthread_allocate_command(ctx, '
+                'DISPATCH_CMD_{1}, cmd_size);'.format(struct, func.name))
             if func.variable_params:
                 out('cmd->num_slots = align(cmd_size, 8) / 8;')
 
-- 
GitLab


From 11513fd98b6bbb53084f97004c6bb939f82fb6d7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 23:35:52 -0500
Subject: [PATCH 19/32] glthread: separate unmarshal function generation into
 print_unmarshal_func

No functional change.
---
 src/mapi/glapi/gen/gl_marshal.py | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index d370b4521ed5..45e48e5cb29c 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -103,10 +103,7 @@ class PrintCode(gl_XML.gl_print_base):
         out('')
         out('')
 
-    def print_async_body(self, func):
-        out('/* {0}: marshalled asynchronously */'.format(func.name))
-        func.print_struct()
-
+    def print_unmarshal_func(self, func):
         out('uint32_t')
         out(('_mesa_unmarshal_{0}(struct gl_context *ctx, '
              'const struct marshal_cmd_{0} *restrict cmd)').format(func.name))
@@ -157,6 +154,11 @@ class PrintCode(gl_XML.gl_print_base):
                 out('return align(sizeof({0}), 8) / 8;'.format(struct))
         out('}')
 
+    def print_async_body(self, func):
+        out('/* {0}: marshalled asynchronously */'.format(func.name))
+        func.print_struct()
+        self.print_unmarshal_func(func)
+
         out('{0}{1} GLAPIENTRY'.format('static ' if func.marshal_is_static() else '', func.return_type))
         out('_mesa_marshal_{0}({1})'.format(
                 func.name, func.get_parameter_string()))
-- 
GitLab


From 3bbcd9af9f1bc9b27665cbe16990a00dd7fff190 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 23:35:52 -0500
Subject: [PATCH 20/32] glthread: separate marshal code generation into
 print_marshal_async_code

I added "if True" to make the diff readable.

No functional change.
---
 src/mapi/glapi/gen/gl_marshal.py | 32 ++++++++++++++++++--------------
 1 file changed, 18 insertions(+), 14 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 45e48e5cb29c..ff096d58acbf 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -154,20 +154,8 @@ class PrintCode(gl_XML.gl_print_base):
                 out('return align(sizeof({0}), 8) / 8;'.format(struct))
         out('}')
 
-    def print_async_body(self, func):
-        out('/* {0}: marshalled asynchronously */'.format(func.name))
-        func.print_struct()
-        self.print_unmarshal_func(func)
-
-        out('{0}{1} GLAPIENTRY'.format('static ' if func.marshal_is_static() else '', func.return_type))
-        out('_mesa_marshal_{0}({1})'.format(
-                func.name, func.get_parameter_string()))
-        out('{')
-        with indent():
-            out('GET_CURRENT_CONTEXT(ctx);')
-            if func.marshal_call_before:
-                out(func.marshal_call_before);
-
+    def print_marshal_async_code(self, func):
+        if True:
             struct = 'struct marshal_cmd_{0}'.format(func.name)
 
             if func.marshal_sync:
@@ -254,6 +242,22 @@ class PrintCode(gl_XML.gl_print_base):
             if not func.fixed_params and not func.variable_params:
                 out('(void) cmd;')
 
+    def print_async_body(self, func):
+        out('/* {0}: marshalled asynchronously */'.format(func.name))
+        func.print_struct()
+        self.print_unmarshal_func(func)
+
+        out('{0}{1} GLAPIENTRY'.format('static ' if func.marshal_is_static() else '', func.return_type))
+        out('_mesa_marshal_{0}({1})'.format(
+                func.name, func.get_parameter_string()))
+        out('{')
+        with indent():
+            out('GET_CURRENT_CONTEXT(ctx);')
+            if func.marshal_call_before:
+                out(func.marshal_call_before);
+
+            self.print_marshal_async_code(func)
+
             if func.marshal_call_after:
                 out(func.marshal_call_after)
 
-- 
GitLab


From 143d8bc5d20078636fbc7d0e4473530f58250fd3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 23:39:22 -0500
Subject: [PATCH 21/32] glthread: remove "if True" from
 print_marshal_async_code

This only changes indentation. No functional change.
---
 src/mapi/glapi/gen/gl_marshal.py | 145 +++++++++++++++----------------
 1 file changed, 72 insertions(+), 73 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index ff096d58acbf..6b8e0136e4c2 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -155,92 +155,91 @@ class PrintCode(gl_XML.gl_print_base):
         out('}')
 
     def print_marshal_async_code(self, func):
-        if True:
-            struct = 'struct marshal_cmd_{0}'.format(func.name)
+        struct = 'struct marshal_cmd_{0}'.format(func.name)
+
+        if func.marshal_sync:
+            out('int cmd_size = sizeof({0});'.format(struct))
+
+            out('if ({0}) {{'.format(func.marshal_sync))
+            with indent():
+                out('_mesa_glthread_finish_before(ctx, "{0}");'.format(func.name))
+                self.print_call(func)
+                out('return;')
+            out('}')
+        else:
+            size_terms = ['sizeof({0})'.format(struct)]
+            for p in func.variable_params:
+                out('int {0}_size = {1};'.format(p.name, p.size_string(marshal=1)))
+                if p.img_null_flag:
+                    size_terms.append('({0} ? {0}_size : 0)'.format(p.name))
+                else:
+                    size_terms.append('{0}_size'.format(p.name))
+
+            out('int cmd_size = {0};'.format(' + '.join(size_terms)))
+
+            # Fall back to syncing if variable-length sizes can't be handled.
+            #
+            # Check that any counts for variable-length arguments might be < 0, in
+            # which case the command alloc or the memcpy would blow up before we
+            # get to the validation in Mesa core.
+            list = []
+            for p in func.parameters:
+                if p.is_variable_length():
+                    list.append('{0}_size < 0'.format(p.name))
+                    list.append('({0}_size > 0 && !{0})'.format(p.name))
 
-            if func.marshal_sync:
-                out('int cmd_size = sizeof({0});'.format(struct))
+            if len(list) != 0:
+                list.append('(unsigned)cmd_size > MARSHAL_MAX_CMD_SIZE')
 
-                out('if ({0}) {{'.format(func.marshal_sync))
+                out('if (unlikely({0})) {{'.format(' || '.join(list)))
                 with indent():
                     out('_mesa_glthread_finish_before(ctx, "{0}");'.format(func.name))
                     self.print_call(func)
                     out('return;')
                 out('}')
+
+        # Add the call into the batch.
+        out('{0} *cmd = _mesa_glthread_allocate_command(ctx, '
+            'DISPATCH_CMD_{1}, cmd_size);'.format(struct, func.name))
+        if func.variable_params:
+            out('cmd->num_slots = align(cmd_size, 8) / 8;')
+
+        for p in func.fixed_params:
+            type = func.get_marshal_type(p)
+
+            if p.count:
+                out('memcpy(cmd->{0}, {0}, {1});'.format(
+                        p.name, p.size_string()))
+            elif type == 'GLenum8':
+                out('cmd->{0} = MIN2({0}, 0xff); /* clamped to 0xff (invalid enum) */'.format(p.name))
+            elif type == 'GLenum16':
+                out('cmd->{0} = MIN2({0}, 0xffff); /* clamped to 0xffff (invalid enum) */'.format(p.name))
+            elif type == 'GLclamped16i':
+                out('cmd->{0} = CLAMP({0}, INT16_MIN, INT16_MAX);'.format(p.name))
+            elif type == 'GLpacked16i':
+                out('cmd->{0} = {0} < 0 ? UINT16_MAX : MIN2({0}, UINT16_MAX);'.format(p.name))
             else:
-                size_terms = ['sizeof({0})'.format(struct)]
-                for p in func.variable_params:
-                    out('int {0}_size = {1};'.format(p.name, p.size_string(marshal=1)))
-                    if p.img_null_flag:
-                        size_terms.append('({0} ? {0}_size : 0)'.format(p.name))
-                    else:
-                        size_terms.append('{0}_size'.format(p.name))
-
-                out('int cmd_size = {0};'.format(' + '.join(size_terms)))
-
-                # Fall back to syncing if variable-length sizes can't be handled.
-                #
-                # Check that any counts for variable-length arguments might be < 0, in
-                # which case the command alloc or the memcpy would blow up before we
-                # get to the validation in Mesa core.
-                list = []
-                for p in func.parameters:
-                    if p.is_variable_length():
-                        list.append('{0}_size < 0'.format(p.name))
-                        list.append('({0}_size > 0 && !{0})'.format(p.name))
-
-                if len(list) != 0:
-                    list.append('(unsigned)cmd_size > MARSHAL_MAX_CMD_SIZE')
-
-                    out('if (unlikely({0})) {{'.format(' || '.join(list)))
+                out('cmd->{0} = {0};'.format(p.name))
+        if func.variable_params:
+            out('char *variable_data = (char *) (cmd + 1);')
+            i = 1
+            for p in func.variable_params:
+                if p.img_null_flag:
+                    out('cmd->{0}_null = !{0};'.format(p.name))
+                    out('if (!cmd->{0}_null) {{'.format(p.name))
                     with indent():
-                        out('_mesa_glthread_finish_before(ctx, "{0}");'.format(func.name))
-                        self.print_call(func)
-                        out('return;')
-                    out('}')
-
-            # Add the call into the batch.
-            out('{0} *cmd = _mesa_glthread_allocate_command(ctx, '
-                'DISPATCH_CMD_{1}, cmd_size);'.format(struct, func.name))
-            if func.variable_params:
-                out('cmd->num_slots = align(cmd_size, 8) / 8;')
-
-            for p in func.fixed_params:
-                type = func.get_marshal_type(p)
-
-                if p.count:
-                    out('memcpy(cmd->{0}, {0}, {1});'.format(
-                            p.name, p.size_string()))
-                elif type == 'GLenum8':
-                    out('cmd->{0} = MIN2({0}, 0xff); /* clamped to 0xff (invalid enum) */'.format(p.name))
-                elif type == 'GLenum16':
-                    out('cmd->{0} = MIN2({0}, 0xffff); /* clamped to 0xffff (invalid enum) */'.format(p.name))
-                elif type == 'GLclamped16i':
-                    out('cmd->{0} = CLAMP({0}, INT16_MIN, INT16_MAX);'.format(p.name))
-                elif type == 'GLpacked16i':
-                    out('cmd->{0} = {0} < 0 ? UINT16_MAX : MIN2({0}, UINT16_MAX);'.format(p.name))
-                else:
-                    out('cmd->{0} = {0};'.format(p.name))
-            if func.variable_params:
-                out('char *variable_data = (char *) (cmd + 1);')
-                i = 1
-                for p in func.variable_params:
-                    if p.img_null_flag:
-                        out('cmd->{0}_null = !{0};'.format(p.name))
-                        out('if (!cmd->{0}_null) {{'.format(p.name))
-                        with indent():
-                            out(('memcpy(variable_data, {0}, {0}_size);').format(p.name))
-                            if i < len(func.variable_params):
-                                out('variable_data += {0}_size;'.format(p.name))
-                        out('}')
-                    else:
                         out(('memcpy(variable_data, {0}, {0}_size);').format(p.name))
                         if i < len(func.variable_params):
                             out('variable_data += {0}_size;'.format(p.name))
-                    i += 1
+                    out('}')
+                else:
+                    out(('memcpy(variable_data, {0}, {0}_size);').format(p.name))
+                    if i < len(func.variable_params):
+                        out('variable_data += {0}_size;'.format(p.name))
+                i += 1
 
-            if not func.fixed_params and not func.variable_params:
-                out('(void) cmd;')
+        if not func.fixed_params and not func.variable_params:
+            out('(void) cmd;')
 
     def print_async_body(self, func):
         out('/* {0}: marshalled asynchronously */'.format(func.name))
-- 
GitLab


From 06cbed0500918954110253d388bb2ef064e33be8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Jan 2024 00:11:54 -0500
Subject: [PATCH 22/32] glapi: pass pointer size to python for glthread from
 meson

glthread (the python generator) needs to know the pointer size at compile
time to sort structure fields of calls for optimal structure packing based
on the CPU.
---
 meson.build                              |  2 ++
 src/mapi/glapi/gen/glX_XML.py            |  4 ++--
 src/mapi/glapi/gen/gl_XML.py             | 13 +++++++------
 src/mapi/glapi/gen/gl_marshal.py         |  4 +++-
 src/mapi/glapi/gen/gl_marshal_h.py       | 12 ++++--------
 src/mapi/glapi/gen/gl_unmarshal_table.py |  4 +++-
 src/mapi/glapi/gen/marshal_XML.py        |  8 ++++----
 src/mapi/glapi/gen/meson.build           |  4 ++--
 src/mesa/main/meson.build                |  2 +-
 9 files changed, 28 insertions(+), 25 deletions(-)

diff --git a/meson.build b/meson.build
index a8d84c00b202..f3ecbe7fcc91 100644
--- a/meson.build
+++ b/meson.build
@@ -37,6 +37,8 @@ project(
 cc = meson.get_compiler('c')
 cpp = meson.get_compiler('cpp')
 
+sizeof_pointer = meson.get_compiler('c', native : true).sizeof('void*').to_string()
+
 null_dep = dependency('', required : false)
 
 if get_option('layout') != 'mirror'
diff --git a/src/mapi/glapi/gen/glX_XML.py b/src/mapi/glapi/gen/glX_XML.py
index 3b54a967fdcb..bb63bb52d3fd 100644
--- a/src/mapi/glapi/gen/glX_XML.py
+++ b/src/mapi/glapi/gen/glX_XML.py
@@ -38,8 +38,8 @@ class glx_item_factory(gl_XML.gl_item_factory):
     def create_enum(self, element, context, category):
         return glx_enum(element, context, category)
 
-    def create_api(self):
-        return glx_api(self)
+    def create_api(self, pointer_type):
+        return glx_api(self, pointer_type)
 
 
 class glx_enum(gl_XML.gl_enum):
diff --git a/src/mapi/glapi/gen/gl_XML.py b/src/mapi/glapi/gen/gl_XML.py
index 3ee3fd2bcdd4..f7802bb48a59 100644
--- a/src/mapi/glapi/gen/gl_XML.py
+++ b/src/mapi/glapi/gen/gl_XML.py
@@ -33,13 +33,13 @@ import typeexpr
 import static_data
 
 
-def parse_GL_API( file_name, factory = None ):
+def parse_GL_API(file_name, factory=None, pointer_size=0):
 
     if not factory:
         factory = gl_item_factory()
 
-    api = factory.create_api()
-    api.parse_file( file_name )
+    api = factory.create_api(pointer_size)
+    api.parse_file(file_name)
 
     # After the XML has been processed, we need to go back and assign
     # dispatch offsets to the functions that request that their offsets
@@ -855,12 +855,12 @@ class gl_item_factory(object):
     def create_parameter(self, element, context):
         return gl_parameter(element, context)
 
-    def create_api(self):
-        return gl_api(self)
+    def create_api(self, pointer_size):
+        return gl_api(self, pointer_size)
 
 
 class gl_api(object):
-    def __init__(self, factory):
+    def __init__(self, factory, pointer_size):
         self.functions_by_name = OrderedDict()
         self.enums_by_name = {}
         self.types_by_name = {}
@@ -871,6 +871,7 @@ class gl_api(object):
         self.factory = factory
 
         self.next_offset = 0
+        self.pointer_size = pointer_size
 
         typeexpr.create_initial_types()
         return
diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index 6b8e0136e4c2..f82194603fa6 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -341,10 +341,12 @@ if __name__ == '__main__':
         file_name = sys.argv[1]
         file_index = int(sys.argv[2])
         file_count = int(sys.argv[3])
+        pointer_size = int(sys.argv[4])
     except Exception:
         show_usage()
 
     printer = PrintCode()
 
-    api = gl_XML.parse_GL_API(file_name, marshal_XML.marshal_item_factory())
+    assert pointer_size != 0
+    api = gl_XML.parse_GL_API(file_name, marshal_XML.marshal_item_factory(), pointer_size)
     printer.Print(api)
diff --git a/src/mapi/glapi/gen/gl_marshal_h.py b/src/mapi/glapi/gen/gl_marshal_h.py
index 4dd8acc3dfd6..467998ec9f69 100644
--- a/src/mapi/glapi/gen/gl_marshal_h.py
+++ b/src/mapi/glapi/gen/gl_marshal_h.py
@@ -86,18 +86,14 @@ def show_usage():
 
 
 if __name__ == '__main__':
-    file_name = 'gl_API.xml'
-
     try:
-        (args, trail) = getopt.getopt(sys.argv[1:], 'm:f:')
+        file_name = sys.argv[1]
+        pointer_size = int(sys.argv[2])
     except Exception:
         show_usage()
 
-    for (arg,val) in args:
-        if arg == '-f':
-            file_name = val
-
     printer = PrintCode()
 
-    api = gl_XML.parse_GL_API(file_name, marshal_XML.marshal_item_factory())
+    assert pointer_size != 0
+    api = gl_XML.parse_GL_API(file_name, marshal_XML.marshal_item_factory(), pointer_size)
     printer.Print(api)
diff --git a/src/mapi/glapi/gen/gl_unmarshal_table.py b/src/mapi/glapi/gen/gl_unmarshal_table.py
index 1cd04a6d8345..07c6ad371fa7 100644
--- a/src/mapi/glapi/gen/gl_unmarshal_table.py
+++ b/src/mapi/glapi/gen/gl_unmarshal_table.py
@@ -89,10 +89,12 @@ def show_usage():
 if __name__ == '__main__':
     try:
         file_name = sys.argv[1]
+        pointer_size = int(sys.argv[2])
     except Exception:
         show_usage()
 
     printer = PrintCode()
 
-    api = gl_XML.parse_GL_API(file_name, marshal_XML.marshal_item_factory())
+    assert pointer_size != 0
+    api = gl_XML.parse_GL_API(file_name, marshal_XML.marshal_item_factory(), pointer_size)
     printer.Print(api)
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 11c3715601de..fba077a75dae 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -92,15 +92,15 @@ class marshal_function(gl_XML.gl_function):
             'GLhandleARB': 4,
             'int': 4,
             'float': 4,
+            'GLintptr': self.context.pointer_size,
+            'GLsizeiptr': self.context.pointer_size,
+            'GLsync': self.context.pointer_size,
+            'GLDEBUGPROC': self.context.pointer_size,
             'GLdouble': 8,
             'GLclampd': 8,
-            'GLintptr': 8,
-            'GLsizeiptr': 8,
             'GLint64': 8,
             'GLuint64': 8,
             'GLuint64EXT': 8,
-            'GLsync': 8,
-            'GLDEBUGPROC': 8,
         }
         val = mapping.get(type, 9999)
         if val == 9999:
diff --git a/src/mapi/glapi/gen/meson.build b/src/mapi/glapi/gen/meson.build
index 7baa275ed147..3516e37ef190 100644
--- a/src/mapi/glapi/gen/meson.build
+++ b/src/mapi/glapi/gen/meson.build
@@ -274,7 +274,7 @@ main_unmarshal_table_c = custom_target(
   'unmarshal_table.c',
   input : ['gl_unmarshal_table.py', 'gl_and_es_API.xml'],
   output : 'unmarshal_table.c',
-  command : [prog_python, '@INPUT0@', '@INPUT1@'],
+  command : [prog_python, '@INPUT0@', '@INPUT1@', sizeof_pointer],
   depend_files : files('marshal_XML.py') + glapi_gen_depends,
   capture : true,
 )
@@ -285,7 +285,7 @@ foreach x : ['0', '1', '2', '3', '4', '5', '6', '7']
     'marshal_generated' + x + '.c',
     input : ['gl_marshal.py', 'gl_and_es_API.xml'],
     output : 'marshal_generated' + x + '.c',
-    command : [prog_python, '@INPUT0@', '@INPUT1@', x, '8'],
+    command : [prog_python, '@INPUT0@', '@INPUT1@', x, '8', sizeof_pointer],
     depend_files : files('marshal_XML.py') + glapi_gen_depends,
     capture : true,
   )
diff --git a/src/mesa/main/meson.build b/src/mesa/main/meson.build
index a46375971598..c8171e89ae53 100644
--- a/src/mesa/main/meson.build
+++ b/src/mesa/main/meson.build
@@ -31,7 +31,7 @@ main_marshal_generated_h = custom_target(
   'marshal_generated.h',
   input : [files('../../mapi/glapi/gen/gl_marshal_h.py'), gl_and_es_api_files],
   output : 'marshal_generated.h',
-  command : [prog_python, '@INPUT0@', '-f', '@INPUT1@'],
+  command : [prog_python, '@INPUT0@', '@INPUT1@', sizeof_pointer],
   depend_files : files('../../mapi/glapi/gen/marshal_XML.py') + glapi_gen_depends,
   capture : true,
 )
-- 
GitLab


From 6df03cfc9b707ad48e46cee18adb56d076dd9a84 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Jan 2024 01:49:39 -0500
Subject: [PATCH 23/32] glthread: pack glVertexAttribPointer calls better

These parameters can use 8 bits.
---
 src/mapi/glapi/gen/marshal_XML.py | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index fba077a75dae..3ef91dd8a402 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -61,6 +61,12 @@ class marshal_function(gl_XML.gl_function):
             if (type, param.name) == ('GLint', 'size'):
                 return 'GLpacked16i'
 
+            # glVertexAttrib*Pointer(index)
+            # glVertexArrayVertexBuffer(bindingindex)
+            if ((type, param.name) == ('GLuint', 'index') or
+                (type, param.name) == ('GLuint', 'bindingindex')):
+                return 'GLenum8' # clamped to 0xff
+
         return type
 
     def get_type_size(self, param):
-- 
GitLab


From 656598d9f69d33eab2cb85547a487993e6a64946 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Jan 2024 03:19:54 -0500
Subject: [PATCH 24/32] glthread: fix multi draws with a negative draw count

This fixes the invalid pointers when draw_count is invalid.
I don't know if it had any adverse affect.
---
 src/mesa/main/glthread_draw.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 7c5a48d6f9a2..889cb6a176a7 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -481,13 +481,14 @@ _mesa_unmarshal_MultiDrawArraysUserBuf(struct gl_context *ctx,
 {
    const GLenum mode = cmd->mode;
    const GLsizei draw_count = cmd->draw_count;
+   const GLsizei real_draw_count = MAX2(draw_count, 0);
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
 
    const char *variable_data = (const char *)(cmd + 1);
    const GLint *first = (GLint *)variable_data;
-   variable_data += sizeof(GLint) * draw_count;
+   variable_data += sizeof(GLint) * real_draw_count;
    const GLsizei *count = (GLsizei *)variable_data;
-   variable_data += sizeof(GLsizei) * draw_count;
+   variable_data += sizeof(GLsizei) * real_draw_count;
    const struct glthread_attrib_binding *buffers =
       (const struct glthread_attrib_binding *)variable_data;
 
@@ -897,18 +898,19 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
                                          const struct marshal_cmd_MultiDrawElementsUserBuf *restrict cmd)
 {
    const GLsizei draw_count = cmd->draw_count;
+   const GLsizei real_draw_count = MAX2(draw_count, 0);
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
    const bool has_base_vertex = cmd->has_base_vertex;
 
    const char *variable_data = (const char *)(cmd + 1);
    const GLsizei *count = (GLsizei *)variable_data;
-   variable_data += sizeof(GLsizei) * draw_count;
+   variable_data += sizeof(GLsizei) * real_draw_count;
    const GLvoid *const *indices = (const GLvoid *const *)variable_data;
-   variable_data += sizeof(const GLvoid *const *) * draw_count;
+   variable_data += sizeof(const GLvoid *const *) * real_draw_count;
    const GLsizei *basevertex = NULL;
    if (has_base_vertex) {
       basevertex = (GLsizei *)variable_data;
-      variable_data += sizeof(GLsizei) * draw_count;
+      variable_data += sizeof(GLsizei) * real_draw_count;
    }
    const struct glthread_attrib_binding *buffers =
       (const struct glthread_attrib_binding *)variable_data;
-- 
GitLab


From 36d60043eec0238e3e1149a3325cfc3508d8c34a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Jan 2024 02:43:48 -0500
Subject: [PATCH 25/32] glthread: pack uploaded user vertex buffers and offsets
 better

glthread_attrib_binding has 2 fields and 4 bytes of padding, which is
arranged in array. This removes the padding by splitting the structure
into 2 arrays, one for each field.

This also fixes the pointer alignment.
---
 src/mesa/main/glthread.h      |   5 -
 src/mesa/main/glthread_draw.c | 186 +++++++++++++++++++++++-----------
 src/mesa/main/varray.c        |   8 +-
 src/mesa/main/varray.h        |   4 +-
 4 files changed, 132 insertions(+), 71 deletions(-)

diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index bc4740336481..5fb822852d56 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -90,11 +90,6 @@ union gl_vertex_format_user {
       .Doubles = doubles \
    }}
 
-struct glthread_attrib_binding {
-   struct gl_buffer_object *buffer; /**< where non-VBO data was uploaded */
-   int offset;                      /**< offset to uploaded non-VBO data */
-};
-
 struct glthread_attrib {
    /* Per attrib: */
    uint8_t ElementSize;       /**< max 32 */
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 889cb6a176a7..9b53be12714d 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -118,7 +118,7 @@ static ALWAYS_INLINE bool
 upload_vertices(struct gl_context *ctx, unsigned user_buffer_mask,
                 unsigned start_vertex, unsigned num_vertices,
                 unsigned start_instance, unsigned num_instances,
-                struct glthread_attrib_binding *buffers)
+                struct gl_buffer_object **buffers, int *offsets)
 {
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    unsigned attrib_mask_iter = vao->Enabled;
@@ -206,14 +206,14 @@ upload_vertices(struct gl_context *ctx, unsigned user_buffer_mask,
                                &upload_buffer, NULL, ctx->Const.VertexBufferOffsetIsInt32 ? 0 : start);
          if (!upload_buffer) {
             for (unsigned i = 0; i < num_buffers; i++)
-               _mesa_reference_buffer_object(ctx, &buffers[i].buffer, NULL);
+               _mesa_reference_buffer_object(ctx, &buffers[i], NULL);
 
             _mesa_marshal_InternalSetError(GL_OUT_OF_MEMORY);
             return false;
          }
 
-         buffers[num_buffers].buffer = upload_buffer;
-         buffers[num_buffers].offset = upload_offset - start;
+         buffers[num_buffers] = upload_buffer;
+         offsets[num_buffers] = upload_offset - start;
          num_buffers++;
       }
 
@@ -266,14 +266,14 @@ upload_vertices(struct gl_context *ctx, unsigned user_buffer_mask,
                             ctx->Const.VertexBufferOffsetIsInt32 ? 0 : offset);
       if (!upload_buffer) {
          for (unsigned i = 0; i < num_buffers; i++)
-            _mesa_reference_buffer_object(ctx, &buffers[i].buffer, NULL);
+            _mesa_reference_buffer_object(ctx, &buffers[i], NULL);
 
          _mesa_marshal_InternalSetError(GL_OUT_OF_MEMORY);
          return false;
       }
 
-      buffers[num_buffers].buffer = upload_buffer;
-      buffers[num_buffers].offset = upload_offset - offset;
+      buffers[num_buffers] = upload_buffer;
+      offsets[num_buffers] = upload_offset - offset;
       num_buffers++;
    }
 
@@ -342,12 +342,14 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
                                   const struct marshal_cmd_DrawArraysUserBuf *restrict cmd)
 {
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
-   const struct glthread_attrib_binding *buffers =
-      (const struct glthread_attrib_binding *)(cmd + 1);
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask)
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
+   if (user_buffer_mask) {
+      struct gl_buffer_object **buffers = (struct gl_buffer_object **)(cmd + 1);
+      const int *offsets = (const int *)(buffers + util_bitcount(user_buffer_mask));
+
+      _mesa_InternalBindVertexBuffers(ctx, buffers, offsets, user_buffer_mask);
+   }
 
    const GLenum mode = cmd->mode;
    const GLint first = cmd->first;
@@ -439,15 +441,18 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
    }
 
    /* Upload and draw. */
-   struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
+   struct gl_buffer_object *buffers[VERT_ATTRIB_MAX];
+   int offsets[VERT_ATTRIB_MAX];
 
    if (!upload_vertices(ctx, user_buffer_mask, first, count, baseinstance,
-                        instance_count, buffers))
+                        instance_count, buffers, offsets))
       return; /* the error is set by upload_vertices */
 
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   unsigned num_buffers = util_bitcount(user_buffer_mask);
+   int buffers_size = num_buffers * sizeof(buffers[0]);
+   int offsets_size = num_buffers * sizeof(int);
    int cmd_size = sizeof(struct marshal_cmd_DrawArraysUserBuf) +
-                  buffers_size;
+                  buffers_size + offsets_size;
    struct marshal_cmd_DrawArraysUserBuf *cmd;
 
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysUserBuf,
@@ -461,8 +466,12 @@ draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
    cmd->drawid = drawid;
    cmd->user_buffer_mask = user_buffer_mask;
 
-   if (user_buffer_mask)
-      memcpy(cmd + 1, buffers, buffers_size);
+   if (user_buffer_mask) {
+      char *variable_data = (char*)(cmd + 1);
+      memcpy(variable_data, buffers, buffers_size);
+      variable_data += buffers_size;
+      memcpy(variable_data, offsets, offsets_size);
+   }
 }
 
 /* MultiDrawArrays with user buffers. */
@@ -488,13 +497,21 @@ _mesa_unmarshal_MultiDrawArraysUserBuf(struct gl_context *ctx,
    const GLint *first = (GLint *)variable_data;
    variable_data += sizeof(GLint) * real_draw_count;
    const GLsizei *count = (GLsizei *)variable_data;
-   variable_data += sizeof(GLsizei) * real_draw_count;
-   const struct glthread_attrib_binding *buffers =
-      (const struct glthread_attrib_binding *)variable_data;
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask)
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
+   if (user_buffer_mask) {
+      variable_data += sizeof(GLsizei) * real_draw_count;
+      const int *offsets = (const int *)variable_data;
+      variable_data += sizeof(int) * util_bitcount(user_buffer_mask);
+
+      /* Align for pointers. */
+      if ((uintptr_t)variable_data % sizeof(uintptr_t))
+         variable_data += 4;
+
+      struct gl_buffer_object **buffers = (struct gl_buffer_object **)variable_data;
+
+      _mesa_InternalBindVertexBuffers(ctx, buffers, offsets, user_buffer_mask);
+   }
 
    CALL_MultiDrawArrays(ctx->Dispatch.Current,
                         (mode, first, count, draw_count));
@@ -514,7 +531,8 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
       return;
    }
 
-   struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
+   struct gl_buffer_object *buffers[VERT_ATTRIB_MAX];
+   int offsets[VERT_ATTRIB_MAX];
    unsigned user_buffer_mask =
       _mesa_is_desktop_gl_core(ctx) || draw_count <= 0 ||
       ctx->Dispatch.Current == ctx->Dispatch.ContextLost ||
@@ -547,7 +565,7 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
          unsigned num_vertices = max_index_exclusive - min_index;
 
          if (!upload_vertices(ctx, user_buffer_mask, min_index, num_vertices,
-                              0, 1, buffers))
+                              0, 1, buffers, offsets))
             return; /* the error is set by upload_vertices */
       }
    }
@@ -556,9 +574,11 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
    int real_draw_count = MAX2(draw_count, 0);
    int first_size = sizeof(GLint) * real_draw_count;
    int count_size = sizeof(GLsizei) * real_draw_count;
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   unsigned num_buffers = util_bitcount(user_buffer_mask);
+   int buffers_size = num_buffers * sizeof(buffers[0]);
+   int offsets_size = num_buffers * sizeof(int);
    int cmd_size = sizeof(struct marshal_cmd_MultiDrawArraysUserBuf) +
-                  first_size + count_size + buffers_size;
+                  first_size + count_size + buffers_size + offsets_size;
    struct marshal_cmd_MultiDrawArraysUserBuf *cmd;
 
    /* Make sure cmd can fit in the batch buffer */
@@ -577,14 +597,23 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
 
       if (user_buffer_mask) {
          variable_data += count_size;
+         memcpy(variable_data, offsets, offsets_size);
+         variable_data += offsets_size;
+
+         /* Align for pointers. */
+         if ((uintptr_t)variable_data % sizeof(uintptr_t))
+            variable_data += 4;
+
          memcpy(variable_data, buffers, buffers_size);
       }
    } else {
       /* The call is too large, so sync and execute the unmarshal code here. */
       _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
 
-      if (user_buffer_mask)
-         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
+      if (user_buffer_mask) {
+         _mesa_InternalBindVertexBuffers(ctx, buffers, offsets,
+                                         user_buffer_mask);
+      }
 
       CALL_MultiDrawArrays(ctx->Dispatch.Current,
                            (mode, first, count, draw_count));
@@ -665,12 +694,14 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
                                     const struct marshal_cmd_DrawElementsUserBuf *restrict cmd)
 {
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
-   const struct glthread_attrib_binding *buffers =
-      (const struct glthread_attrib_binding *)(cmd + 1);
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask)
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
+   if (user_buffer_mask) {
+      struct gl_buffer_object **buffers = (struct gl_buffer_object **)(cmd + 1);
+      const int *offsets = (const int *)(buffers + util_bitcount(user_buffer_mask));
+
+      _mesa_InternalBindVertexBuffers(ctx, buffers, offsets, user_buffer_mask);
+   }
 
    /* Draw. */
    CALL_DrawElementsUserBuf(ctx->Dispatch.Current, (cmd));
@@ -843,10 +874,12 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
       return;
    }
 
-   struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
+   struct gl_buffer_object *buffers[VERT_ATTRIB_MAX];
+   int offsets[VERT_ATTRIB_MAX];
+
    if (user_buffer_mask) {
       if (!upload_vertices(ctx, user_buffer_mask, start_vertex, num_vertices,
-                           baseinstance, instance_count, buffers))
+                           baseinstance, instance_count, buffers, offsets))
          return; /* the error is set by upload_vertices */
    }
 
@@ -859,9 +892,11 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
    }
 
    /* Draw asynchronously. */
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   unsigned num_buffers = util_bitcount(user_buffer_mask);
+   int buffers_size = num_buffers * sizeof(buffers[0]);
+   int offsets_size = num_buffers * sizeof(int);
    int cmd_size = sizeof(struct marshal_cmd_DrawElementsUserBuf) +
-                  buffers_size;
+                  buffers_size + offsets_size;
    struct marshal_cmd_DrawElementsUserBuf *cmd;
 
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
@@ -877,8 +912,12 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
    cmd->index_buffer = index_buffer;
    cmd->drawid = drawid;
 
-   if (user_buffer_mask)
-      memcpy(cmd + 1, buffers, buffers_size);
+   if (user_buffer_mask) {
+      char *variable_data = (char*)(cmd + 1);
+      memcpy(variable_data, buffers, buffers_size);
+      variable_data += buffers_size;
+      memcpy(variable_data, offsets, offsets_size);
+   }
 }
 
 struct marshal_cmd_MultiDrawElementsUserBuf
@@ -905,19 +944,30 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
    const char *variable_data = (const char *)(cmd + 1);
    const GLsizei *count = (GLsizei *)variable_data;
    variable_data += sizeof(GLsizei) * real_draw_count;
-   const GLvoid *const *indices = (const GLvoid *const *)variable_data;
-   variable_data += sizeof(const GLvoid *const *) * real_draw_count;
    const GLsizei *basevertex = NULL;
    if (has_base_vertex) {
       basevertex = (GLsizei *)variable_data;
       variable_data += sizeof(GLsizei) * real_draw_count;
    }
-   const struct glthread_attrib_binding *buffers =
-      (const struct glthread_attrib_binding *)variable_data;
+   const int *offsets = NULL;
+   if (user_buffer_mask) {
+      offsets = (const int *)variable_data;
+      variable_data += sizeof(int) * util_bitcount(user_buffer_mask);
+   }
+
+   /* Align for pointers. */
+   if ((uintptr_t)variable_data % sizeof(uintptr_t))
+      variable_data += 4;
+
+   const GLvoid *const *indices = (const GLvoid *const *)variable_data;
+   variable_data += sizeof(const GLvoid *const *) * real_draw_count;
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask)
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
+   if (user_buffer_mask) {
+      struct gl_buffer_object **buffers = (struct gl_buffer_object **)variable_data;
+
+      _mesa_InternalBindVertexBuffers(ctx, buffers, offsets, user_buffer_mask);
+   }
 
    /* Draw. */
    const GLenum mode = cmd->mode;
@@ -938,15 +988,19 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
                           const GLsizei *basevertex,
                           struct gl_buffer_object *index_buffer,
                           unsigned user_buffer_mask,
-                          const struct glthread_attrib_binding *buffers)
+                          struct gl_buffer_object **buffers,
+                          const int *offsets)
 {
    int real_draw_count = MAX2(draw_count, 0);
    int count_size = sizeof(GLsizei) * real_draw_count;
    int indices_size = sizeof(indices[0]) * real_draw_count;
    int basevertex_size = basevertex ? sizeof(GLsizei) * real_draw_count : 0;
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   unsigned num_buffers = util_bitcount(user_buffer_mask);
+   int buffers_size = num_buffers * sizeof(buffers[0]);
+   int offsets_size = num_buffers * sizeof(int);
    int cmd_size = sizeof(struct marshal_cmd_MultiDrawElementsUserBuf) +
-                  count_size + indices_size + basevertex_size + buffers_size;
+                  count_size + indices_size + basevertex_size + buffers_size +
+                  offsets_size;
    struct marshal_cmd_MultiDrawElementsUserBuf *cmd;
 
    /* Make sure cmd can fit the queue buffer */
@@ -963,13 +1017,21 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
       char *variable_data = (char*)(cmd + 1);
       memcpy(variable_data, count, count_size);
       variable_data += count_size;
-      memcpy(variable_data, indices, indices_size);
-      variable_data += indices_size;
-
       if (basevertex) {
          memcpy(variable_data, basevertex, basevertex_size);
          variable_data += basevertex_size;
       }
+      if (user_buffer_mask) {
+         memcpy(variable_data, offsets, offsets_size);
+         variable_data += offsets_size;
+      }
+
+      /* Align for pointers. */
+      if ((uintptr_t)variable_data % sizeof(uintptr_t))
+         variable_data += 4;
+
+      memcpy(variable_data, indices, indices_size);
+      variable_data += indices_size;
 
       if (user_buffer_mask)
          memcpy(variable_data, buffers, buffers_size);
@@ -978,8 +1040,10 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
       _mesa_glthread_finish_before(ctx, "DrawElements");
 
       /* Bind uploaded buffers if needed. */
-      if (user_buffer_mask)
-         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
+      if (user_buffer_mask) {
+         _mesa_InternalBindVertexBuffers(ctx, buffers, offsets,
+                                         user_buffer_mask);
+      }
 
       /* Draw. */
       CALL_MultiDrawElementsUserBuf(ctx->Dispatch.Current,
@@ -1030,7 +1094,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
    /* Fast path when we don't need to upload anything. */
    if (!user_buffer_mask && !has_user_indices) {
       multi_draw_elements_async(ctx, mode, count, type, indices,
-                                draw_count, basevertex, NULL, 0, NULL);
+                                draw_count, basevertex, NULL, 0, NULL, NULL);
       return;
    }
 
@@ -1054,7 +1118,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
          if (vertex_count < 0) {
             /* Just call the driver to set the error. */
             multi_draw_elements_async(ctx, mode, count, type, indices, draw_count,
-                                      basevertex, NULL, 0, NULL);
+                                      basevertex, NULL, 0, NULL, NULL);
             return;
          }
          if (vertex_count == 0)
@@ -1092,7 +1156,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
       if (total_count == 0 || num_vertices == 0) {
          /* Nothing to do, but call the driver to set possible GL errors. */
          multi_draw_elements_async(ctx, mode, count, type, indices, draw_count,
-                                   basevertex, NULL, 0, NULL);
+                                   basevertex, NULL, 0, NULL, NULL);
          return;
       }
    } else if (has_user_indices) {
@@ -1103,7 +1167,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
          if (vertex_count < 0) {
             /* Just call the driver to set the error. */
             multi_draw_elements_async(ctx, mode, count, type, indices, draw_count,
-                                      basevertex, NULL, 0, NULL);
+                                      basevertex, NULL, 0, NULL, NULL);
             return;
          }
          if (vertex_count == 0)
@@ -1115,16 +1179,18 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
       if (total_count == 0) {
          /* Nothing to do, but call the driver to set possible GL errors. */
          multi_draw_elements_async(ctx, mode, count, type, indices, draw_count,
-                                   basevertex, NULL, 0, NULL);
+                                   basevertex, NULL, 0, NULL, NULL);
          return;
       }
    }
 
    /* Upload vertices. */
-   struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
+   struct gl_buffer_object *buffers[VERT_ATTRIB_MAX];
+   int offsets[VERT_ATTRIB_MAX];
+
    if (user_buffer_mask) {
       if (!upload_vertices(ctx, user_buffer_mask, min_index, num_vertices,
-                           0, 1, buffers))
+                           0, 1, buffers, offsets))
          return; /* the error is set by upload_vertices */
    }
 
@@ -1145,7 +1211,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
    /* Draw asynchronously. */
    multi_draw_elements_async(ctx, mode, count, type, indices, draw_count,
                              basevertex, index_buffer, user_buffer_mask,
-                             buffers);
+                             buffers, offsets);
 }
 
 void GLAPIENTRY
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index f428e2a7e945..f4840e14154e 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -3540,18 +3540,18 @@ _mesa_BindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers,
 
 void
 _mesa_InternalBindVertexBuffers(struct gl_context *ctx,
-                                const struct glthread_attrib_binding *buffers,
-                                GLbitfield buffer_mask)
+                                struct gl_buffer_object **buffers,
+                                const int *offsets, GLbitfield buffer_mask)
 {
    struct gl_vertex_array_object *vao = ctx->Array.VAO;
    unsigned param_index = 0;
 
    while (buffer_mask) {
       unsigned i = u_bit_scan(&buffer_mask);
-      struct gl_buffer_object *buf = buffers[param_index].buffer;
+      struct gl_buffer_object *buf = buffers[param_index];
 
       /* The buffer reference is passed to _mesa_bind_vertex_buffer. */
-      _mesa_bind_vertex_buffer(ctx, vao, i, buf, buffers[param_index].offset,
+      _mesa_bind_vertex_buffer(ctx, vao, i, buf, offsets[param_index],
                                vao->BufferBinding[i].Stride, true, true);
       param_index++;
    }
diff --git a/src/mesa/main/varray.h b/src/mesa/main/varray.h
index 903f89fe816e..98412547115f 100644
--- a/src/mesa/main/varray.h
+++ b/src/mesa/main/varray.h
@@ -155,8 +155,8 @@ _mesa_primitive_restart_index(const struct gl_context *ctx,
 
 void
 _mesa_InternalBindVertexBuffers(struct gl_context *ctx,
-                                const struct glthread_attrib_binding *buffers,
-                                GLbitfield buffer_mask);
+                                struct gl_buffer_object **buffers,
+                                const int *offsets, GLbitfield buffer_mask);
 
 extern void
 _mesa_print_arrays(struct gl_context *ctx);
-- 
GitLab


From 9bf1eb52a5c5010e34e6ff92425c837d6fdb2f30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 29 Jan 2024 17:22:36 -0500
Subject: [PATCH 26/32] glthread: deduplicate batch finalization code

---
 src/mesa/main/glthread.c | 44 +++++++++++++++++++---------------------
 1 file changed, 21 insertions(+), 23 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 54bddb95f6cc..6542b79e00da 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -337,6 +337,25 @@ void _mesa_glthread_disable(struct gl_context *ctx)
       _mesa_glthread_unbind_uploaded_vbos(ctx);
 }
 
+static void
+glthread_finalize_batch(struct glthread_state *glthread,
+                        unsigned *num_items_counter)
+{
+   struct glthread_batch *next = glthread->next_batch;
+
+   /* Mark the end of the batch, but don't increment "used". */
+   struct marshal_cmd_base *last =
+      (struct marshal_cmd_base *)&next->buffer[glthread->used];
+   last->cmd_id = NUM_DISPATCH_CMD;
+
+   p_atomic_add(num_items_counter, glthread->used);
+   next->used = glthread->used;
+   glthread->used = 0;
+
+   glthread->LastCallList = NULL;
+   glthread->LastBindBuffer = NULL;
+}
+
 void
 _mesa_glthread_flush_batch(struct gl_context *ctx)
 {
@@ -353,26 +372,15 @@ _mesa_glthread_flush_batch(struct gl_context *ctx)
       return; /* the batch is empty */
 
    glthread_apply_thread_sched_policy(ctx, false);
+   glthread_finalize_batch(glthread, &glthread->stats.num_offloaded_items);
 
    struct glthread_batch *next = glthread->next_batch;
 
-   /* Mark the end of the batch, but don't increment "used". */
-   struct marshal_cmd_base *last =
-      (struct marshal_cmd_base *)&next->buffer[glthread->used];
-   last->cmd_id = NUM_DISPATCH_CMD;
-
-   p_atomic_add(&glthread->stats.num_offloaded_items, glthread->used);
-   next->used = glthread->used;
-
    util_queue_add_job(&glthread->queue, next, &next->fence,
                       glthread_unmarshal_batch, NULL, 0);
    glthread->last = glthread->next;
    glthread->next = (glthread->next + 1) % MARSHAL_MAX_BATCHES;
    glthread->next_batch = &glthread->batches[glthread->next];
-   glthread->used = 0;
-
-   glthread->LastCallList = NULL;
-   glthread->LastBindBuffer = NULL;
 }
 
 /**
@@ -408,17 +416,7 @@ _mesa_glthread_finish(struct gl_context *ctx)
    glthread_apply_thread_sched_policy(ctx, false);
 
    if (glthread->used) {
-      /* Mark the end of the batch, but don't increment "used". */
-      struct marshal_cmd_base *last =
-         (struct marshal_cmd_base *)&next->buffer[glthread->used];
-      last->cmd_id = NUM_DISPATCH_CMD;
-
-      p_atomic_add(&glthread->stats.num_direct_items, glthread->used);
-      next->used = glthread->used;
-      glthread->used = 0;
-
-      glthread->LastCallList = NULL;
-      glthread->LastBindBuffer = NULL;
+      glthread_finalize_batch(glthread, &glthread->stats.num_direct_items);
 
       /* Since glthread_unmarshal_batch changes the dispatch to direct,
        * restore it after it's done.
-- 
GitLab


From 2c8bf602d7bb8608f9a889bebc9066df0eca24ec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 29 Jan 2024 19:23:41 -0500
Subject: [PATCH 27/32] glthread: don't check cmd_size for small variable-sized
 calls

This removes the size checking, syncing, and direct execution if
the variable-sized call is always small. Don't use safe_mul in that case
either. Only calls already using marshal_count are affected. Example:

Before:

static void GLAPIENTRY
_mesa_marshal_PointParameterfv(GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   int params_size = safe_mul(_mesa_point_param_enum_to_count(pname), 1 * sizeof(GLfloat));
   int cmd_size = sizeof(struct marshal_cmd_PointParameterfv) + params_size;
   if (unlikely(params_size < 0 || (params_size > 0 && !params) || (unsigned)cmd_size > MARSHAL_MAX_CMD_SIZE)) {
      _mesa_glthread_finish_before(ctx, "PointParameterfv");
      CALL_PointParameterfv(ctx->Dispatch.Current, (pname, params));
      return;
   }
   struct marshal_cmd_PointParameterfv *cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_PointParameterfv, cmd_size);
   cmd->num_slots = align(cmd_size, 8) / 8;
   cmd->pname = MIN2(pname, 0xffff); /* clamped to 0xffff (invalid enum) */
   char *variable_data = (char *) (cmd + 1);
   memcpy(variable_data, params, params_size);
}

After:

static void GLAPIENTRY
_mesa_marshal_PointParameterfv(GLenum pname, const GLfloat *params)
{
   GET_CURRENT_CONTEXT(ctx);
   int params_size = _mesa_point_param_enum_to_count(pname) * 1 * sizeof(GLfloat);
   int cmd_size = sizeof(struct marshal_cmd_PointParameterfv) + params_size;
   assert(cmd_size >= 0 && cmd_size <= MARSHAL_MAX_CMD_SIZE);
   struct marshal_cmd_PointParameterfv *cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_PointParameterfv, cmd_size);
   cmd->num_slots = align(cmd_size, 8) / 8;
   cmd->pname = MIN2(pname, 0xffff); /* clamped to 0xffff (invalid enum) */
   char *variable_data = (char *) (cmd + 1);
   memcpy(variable_data, params, params_size);
}
---
 src/mapi/glapi/gen/gl_API.dtd     | 13 +++++++++++--
 src/mapi/glapi/gen/gl_API.xml     |  2 +-
 src/mapi/glapi/gen/gl_XML.py      | 16 ++++++++++++----
 src/mapi/glapi/gen/gl_marshal.py  | 10 ++++++++--
 src/mapi/glapi/gen/marshal_XML.py |  5 +++--
 5 files changed, 35 insertions(+), 11 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.dtd b/src/mapi/glapi/gen/gl_API.dtd
index 0358dc9609da..45df8e9fd7ff 100644
--- a/src/mapi/glapi/gen/gl_API.dtd
+++ b/src/mapi/glapi/gen/gl_API.dtd
@@ -42,6 +42,7 @@
                    marshal             NMTOKEN #IMPLIED
                    marshal_sync        CDATA #IMPLIED>
                    marshal_count       CDATA #IMPLIED>
+                   marshal_large_count CDATA #IMPLIED>
                    marshal_call_before CDATA #IMPLIED>
                    marshal_call_after  CDATA #IMPLIED>
                    marshal_struct      CDATA #IMPLIED>
@@ -135,8 +136,16 @@ param:
         generated but a custom implementation will be present in marshal.c.
      marshal_sync - an expression that, if it evaluates true, causes glthread
         to sync and execute the call directly.
-     marshal_count - same as count, but variable_param is ignored. Used by
-        glthread.
+     marshal_count - alternative to using "count" for pointer parameters.
+        It contains an expression computing the size of the array pointed to
+        by the pointer parameter. The maximum size must be small enough that
+        it always fits into a glthread batch, so that glthread never has to
+        sync and execute directly.
+     marshal_large_count - alternative to using "count" for pointer parameters.
+        It contains an expression computing the size of the array pointed to
+        by the pointer parameter. It can be an arbitrary size, which may cause
+        glthread to flush, sync, and execute directly if the size is greater
+        than the maximum call size that fits in a glthread batch.
      marshal_call_before - insert the string at the beginning of the marshal
         function
      marshal_call_after - insert the string at the end of the marshal function
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 199cf72c703d..ff202c3ef4c9 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -1132,7 +1132,7 @@
         <param name="n" type="GLsizei" counter="true"/>
         <param name="type" type="GLenum"/>
         <param name="lists" type="const GLvoid *" variable_param="type" count="n"
-               marshal_count="(n * _mesa_calllists_enum_to_count(type))"/>
+               marshal_large_count="(n * _mesa_calllists_enum_to_count(type))"/>
         <glx rop="2" large="true"/>
     </function>
 
diff --git a/src/mapi/glapi/gen/gl_XML.py b/src/mapi/glapi/gen/gl_XML.py
index f7802bb48a59..4dcaaeb463e2 100644
--- a/src/mapi/glapi/gen/gl_XML.py
+++ b/src/mapi/glapi/gen/gl_XML.py
@@ -430,6 +430,7 @@ class gl_parameter(object):
             self.counter = c
 
         self.marshal_count = element.get("marshal_count")
+        self.marshal_large_count = element.get("marshal_large_count")
         self.count_scale = int(element.get( "count_scale", "1" ))
 
         elements = (count * self.count_scale)
@@ -492,7 +493,8 @@ class gl_parameter(object):
 
 
     def is_variable_length(self):
-        return len(self.count_parameter_list) or self.counter or self.marshal_count
+        return (len(self.count_parameter_list) or self.counter or
+                self.marshal_count or self.marshal_large_count)
 
 
     def is_64_bit(self):
@@ -575,11 +577,14 @@ class gl_parameter(object):
 
         base_size_str += "sizeof(%s)" % ( self.get_base_type_string() )
 
-        if self.counter or self.count_parameter_list or (self.marshal_count and marshal):
+        if (self.counter or self.count_parameter_list or
+            (marshal and (self.marshal_count or self.marshal_large_count))):
             list = [ "compsize" ]
 
-            if self.marshal_count and marshal:
+            if marshal and self.marshal_count:
                 list = [ self.marshal_count ]
+            elif marshal and self.marshal_large_count:
+                list = [ self.marshal_large_count ]
             elif self.counter and self.count_parameter_list:
                 list.append( self.counter )
             elif self.counter:
@@ -588,7 +593,9 @@ class gl_parameter(object):
             if self.size() > 1:
                 list.append( base_size_str )
 
-            if len(list) > 1 and use_parens :
+            # Don't use safe_mul if marshal_count is used, which indicates
+            # a small size.
+            if len(list) > 1 and use_parens and not self.marshal_count:
                 return "safe_mul(%s)" % ", ".join(list)
             else:
                 return " * ".join(list)
@@ -658,6 +665,7 @@ class gl_function( gl_item ):
         # marshal isn't allowed with alias
         assert not alias or not element.get('marshal')
         assert not alias or not element.get('marshal_count')
+        assert not alias or not element.get('marshal_large_count')
         assert not alias or not element.get('marshal_sync')
         assert not alias or not element.get('marshal_call_before')
         assert not alias or not element.get('marshal_call_after')
diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index f82194603fa6..cf51608557b8 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -183,10 +183,14 @@ class PrintCode(gl_XML.gl_print_base):
             # which case the command alloc or the memcpy would blow up before we
             # get to the validation in Mesa core.
             list = []
+            assert_size = False
             for p in func.parameters:
                 if p.is_variable_length():
-                    list.append('{0}_size < 0'.format(p.name))
-                    list.append('({0}_size > 0 && !{0})'.format(p.name))
+                    if p.marshal_count:
+                        assert_size = True
+                    else:
+                        list.append('{0}_size < 0'.format(p.name))
+                        list.append('({0}_size > 0 && !{0})'.format(p.name))
 
             if len(list) != 0:
                 list.append('(unsigned)cmd_size > MARSHAL_MAX_CMD_SIZE')
@@ -197,6 +201,8 @@ class PrintCode(gl_XML.gl_print_base):
                     self.print_call(func)
                     out('return;')
                 out('}')
+            elif assert_size:
+                out('assert(cmd_size >= 0 && cmd_size <= MARSHAL_MAX_CMD_SIZE);')
 
         # Add the call into the batch.
         out('{0} *cmd = _mesa_glthread_allocate_command(ctx, '
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 3ef91dd8a402..2a00fa61b52d 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -181,9 +181,10 @@ class marshal_function(gl_XML.gl_function):
         for p in self.parameters:
             if p.is_output:
                 return 'sync'
-            if (p.is_pointer() and not (p.count or p.counter or p.marshal_count)):
+            if (p.is_pointer() and not
+                (p.count or p.counter or p.marshal_count or p.marshal_large_count)):
                 return 'sync'
-            if p.count_parameter_list and not p.marshal_count:
+            if p.count_parameter_list and not (p.marshal_count or p.marshal_large_count):
                 # Parameter size is determined by enums; haven't
                 # written logic to handle this yet.  TODO: fix.
                 return 'sync'
-- 
GitLab


From 5c8ad7f79e4557ebe653d6dd1f03498398a78e3d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 29 Jan 2024 19:55:14 -0500
Subject: [PATCH 28/32] glthread: use marshal_count instead of count for more
 functions

Same as the previous commit, just applied to more functions.
This removes safe_mul and checking whether cmd_size is too large
because the size is always small with these functions.
---
 .../glapi/gen/ARB_direct_state_access.xml     | 14 +++++-----
 src/mapi/glapi/gen/ARB_sampler_objects.xml    |  8 +++---
 .../glapi/gen/ARB_tessellation_shader.xml     |  2 +-
 .../glapi/gen/EXT_direct_state_access.xml     | 26 +++++++++----------
 src/mapi/glapi/gen/EXT_external_objects.xml   |  4 +--
 src/mapi/glapi/gen/GL3x.xml                   | 10 +++----
 src/mapi/glapi/gen/OES_fixed_point.xml        |  2 +-
 src/mapi/glapi/gen/gl_API.xml                 |  2 +-
 src/mapi/glapi/gen/gl_and_es_API.xml          |  2 +-
 9 files changed, 35 insertions(+), 35 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_direct_state_access.xml b/src/mapi/glapi/gen/ARB_direct_state_access.xml
index 0be8db19b668..21bf9acfea66 100644
--- a/src/mapi/glapi/gen/ARB_direct_state_access.xml
+++ b/src/mapi/glapi/gen/ARB_direct_state_access.xml
@@ -222,21 +222,21 @@
       <param name="framebuffer" type="GLuint" />
       <param name="buffer" type="GLenum" />
       <param name="drawbuffer" type="GLint" />
-      <param name="value" type="const GLint *" count="_mesa_buffer_enum_to_count(buffer)"/>
+      <param name="value" type="const GLint *" marshal_count="_mesa_buffer_enum_to_count(buffer)"/>
    </function>
 
    <function name="ClearNamedFramebufferuiv">
       <param name="framebuffer" type="GLuint" />
       <param name="buffer" type="GLenum" />
       <param name="drawbuffer" type="GLint" />
-      <param name="value" type="const GLuint *" count="_mesa_buffer_enum_to_count(buffer)"/>
+      <param name="value" type="const GLuint *" marshal_count="_mesa_buffer_enum_to_count(buffer)"/>
    </function>
 
    <function name="ClearNamedFramebufferfv">
       <param name="framebuffer" type="GLuint" />
       <param name="buffer" type="GLenum" />
       <param name="drawbuffer" type="GLint" />
-      <param name="value" type="const GLfloat *" count="_mesa_buffer_enum_to_count(buffer)"/>
+      <param name="value" type="const GLfloat *" marshal_count="_mesa_buffer_enum_to_count(buffer)"/>
    </function>
 
    <function name="ClearNamedFramebufferfi">
@@ -493,7 +493,7 @@
    <function name="TextureParameterfv">
       <param name="texture" type="GLuint" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLfloat *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="param" type="const GLfloat *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="TextureParameteri">
@@ -505,19 +505,19 @@
    <function name="TextureParameterIiv">
       <param name="texture" type="GLuint" />
       <param name="pname" type="GLenum" />
-      <param name="params" type="const GLint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="TextureParameterIuiv">
       <param name="texture" type="GLuint" />
       <param name="pname" type="GLenum" />
-      <param name="params" type="const GLuint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLuint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="TextureParameteriv">
       <param name="texture" type="GLuint" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="param" type="const GLint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="GenerateTextureMipmap" no_error="true">
diff --git a/src/mapi/glapi/gen/ARB_sampler_objects.xml b/src/mapi/glapi/gen/ARB_sampler_objects.xml
index e4dc0f6241c2..f4b2ad7a50b6 100644
--- a/src/mapi/glapi/gen/ARB_sampler_objects.xml
+++ b/src/mapi/glapi/gen/ARB_sampler_objects.xml
@@ -42,25 +42,25 @@
     <function name="SamplerParameteriv" es2="2.0" exec="dlist">
       <param name="sampler" type="GLuint"/>
       <param name="pname" type="GLenum"/>
-      <param name="params" type="const GLint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
     <function name="SamplerParameterfv" es2="2.0" exec="dlist">
       <param name="sampler" type="GLuint"/>
       <param name="pname" type="GLenum"/>
-      <param name="params" type="const GLfloat *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLfloat *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
     <function name="SamplerParameterIiv" es2="3.2" exec="dlist">
       <param name="sampler" type="GLuint"/>
       <param name="pname" type="GLenum"/>
-      <param name="params" type="const GLint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
     <function name="SamplerParameterIuiv" es2="3.2" exec="dlist">
       <param name="sampler" type="GLuint"/>
       <param name="pname" type="GLenum"/>
-      <param name="params" type="const GLuint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLuint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
     <function name="GetSamplerParameteriv" es2="2.0">
diff --git a/src/mapi/glapi/gen/ARB_tessellation_shader.xml b/src/mapi/glapi/gen/ARB_tessellation_shader.xml
index 88d47851c65a..674988af4a11 100644
--- a/src/mapi/glapi/gen/ARB_tessellation_shader.xml
+++ b/src/mapi/glapi/gen/ARB_tessellation_shader.xml
@@ -56,7 +56,7 @@
     </function>
     <function name="PatchParameterfv" exec="dlist">
         <param name="pname" type="GLenum"/>
-        <param name="values" type="const GLfloat *" count="_mesa_patch_param_enum_to_count(pname)"/>
+        <param name="values" type="const GLfloat *" marshal_count="_mesa_patch_param_enum_to_count(pname)"/>
     </function>
 
     <function name="PatchParameteriEXT" es2="3.1" alias="PatchParameteri">
diff --git a/src/mapi/glapi/gen/EXT_direct_state_access.xml b/src/mapi/glapi/gen/EXT_direct_state_access.xml
index db9d9af76083..0f1055c80d24 100644
--- a/src/mapi/glapi/gen/EXT_direct_state_access.xml
+++ b/src/mapi/glapi/gen/EXT_direct_state_access.xml
@@ -156,7 +156,7 @@
        <param name="texture" type="GLuint" />
        <param name="target" type="GLenum" />
        <param name="pname" type="GLenum" />
-       <param name="params" type="const GLint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+       <param name="params" type="const GLint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
     <function name="TextureParameterfEXT" deprecated="3.1" exec="dlist">
@@ -170,7 +170,7 @@
        <param name="texture" type="GLuint" />
        <param name="target" type="GLenum" />
        <param name="pname" type="GLenum" />
-       <param name="params" type="const float *" count="_mesa_tex_param_enum_to_count(pname)"/>
+       <param name="params" type="const float *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
    <function name="TextureImage1DEXT" deprecated="3.1" exec="dlist"
@@ -372,7 +372,7 @@
       <param name="texunit" type="GLenum" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLint *" count="_mesa_texenv_enum_to_count(pname)"/>
+      <param name="param" type="const GLint *" marshal_count="_mesa_texenv_enum_to_count(pname)"/>
    </function>
 
    <function name="MultiTexEnvfEXT" deprecated="3.1" exec="dlist">
@@ -386,7 +386,7 @@
       <param name="texunit" type="GLenum" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLfloat *" count="_mesa_texenv_enum_to_count(pname)"/>
+      <param name="param" type="const GLfloat *" marshal_count="_mesa_texenv_enum_to_count(pname)"/>
    </function>
 
    <function name="GetMultiTexEnvivEXT" deprecated="3.1">
@@ -414,7 +414,7 @@
       <param name="texunit" type="GLenum" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLint*" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="param" type="const GLint*" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="MultiTexParameterfEXT" deprecated="3.1" exec="dlist">
@@ -428,7 +428,7 @@
       <param name="texunit" type="GLenum" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLfloat*" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="param" type="const GLfloat*" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="GetMultiTexParameterivEXT" deprecated="3.1">
@@ -624,7 +624,7 @@
       <param name="texunit" type="GLenum" />
       <param name="coord" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLdouble*" count="_mesa_texgen_enum_to_count(pname)"/>
+      <param name="param" type="const GLdouble*" marshal_count="_mesa_texgen_enum_to_count(pname)"/>
    </function>
 
    <function name="MultiTexGenfEXT" deprecated="3.1">
@@ -638,7 +638,7 @@
       <param name="texunit" type="GLenum" />
       <param name="coord" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLfloat *" count="_mesa_texgen_enum_to_count(pname)"/>
+      <param name="param" type="const GLfloat *" marshal_count="_mesa_texgen_enum_to_count(pname)"/>
    </function>
 
    <function name="MultiTexGeniEXT" deprecated="3.1">
@@ -652,7 +652,7 @@
       <param name="texunit" type="GLenum" />
       <param name="coord" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="param" type="const GLint *" count="_mesa_texgen_enum_to_count(pname)"/>
+      <param name="param" type="const GLint *" marshal_count="_mesa_texgen_enum_to_count(pname)"/>
    </function>
 
    <function name="GetMultiTexGendvEXT" deprecated="3.1">
@@ -1342,14 +1342,14 @@
       <param name="texture" type="GLuint" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="params" type="const GLint*" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLint*" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="TextureParameterIuivEXT" deprecated="3.1" exec="dlist">
       <param name="texture" type="GLuint" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="params" type="const GLuint*" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLuint*" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="GetTextureParameterIivEXT" deprecated="3.1">
@@ -1370,14 +1370,14 @@
       <param name="texunit" type="GLenum" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="params" type="const GLint*" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLint*" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="MultiTexParameterIuivEXT" deprecated="3.1" exec="dlist">
       <param name="texunit" type="GLenum" />
       <param name="target" type="GLenum" />
       <param name="pname" type="GLenum" />
-      <param name="params" type="const GLuint*" count="_mesa_tex_param_enum_to_count(pname)"/>
+      <param name="params" type="const GLuint*" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
    </function>
 
    <function name="GetMultiTexParameterIivEXT" deprecated="3.1">
diff --git a/src/mapi/glapi/gen/EXT_external_objects.xml b/src/mapi/glapi/gen/EXT_external_objects.xml
index 89bd98946d93..297b5f4e7b47 100644
--- a/src/mapi/glapi/gen/EXT_external_objects.xml
+++ b/src/mapi/glapi/gen/EXT_external_objects.xml
@@ -55,7 +55,7 @@
     <function name="MemoryObjectParameterivEXT" es2="3.2">
         <param name="memoryObject" type="GLuint"/>
         <param name="pname" type="GLenum"/>
-        <param name="params" type="const GLint *" count="_mesa_memobj_enum_to_count(pname)"/>
+        <param name="params" type="const GLint *" marshal_count="_mesa_memobj_enum_to_count(pname)"/>
     </function>
 
     <function name="GetMemoryObjectParameterivEXT" es2="3.2">
@@ -202,7 +202,7 @@
     <function name="SemaphoreParameterui64vEXT" es2="3.2">
         <param name="semaphore" type="GLuint"/>
         <param name="pname" type="GLenum"/>
-        <param name="params" type="const GLuint64 *" count="_mesa_semaphore_enum_to_count(pname)"/>
+        <param name="params" type="const GLuint64 *" marshal_count="_mesa_semaphore_enum_to_count(pname)"/>
     </function>
 
     <function name="GetSemaphoreParameterui64vEXT" es2="3.2">
diff --git a/src/mapi/glapi/gen/GL3x.xml b/src/mapi/glapi/gen/GL3x.xml
index 8aae7f85a120..1c38e7723d29 100644
--- a/src/mapi/glapi/gen/GL3x.xml
+++ b/src/mapi/glapi/gen/GL3x.xml
@@ -120,19 +120,19 @@
   <function name="ClearBufferiv" es2="3.0" no_error="true" exec="dlist">
     <param name="buffer" type="GLenum"/>
     <param name="drawbuffer" type="GLint"/>
-    <param name="value" type="const GLint *" count="_mesa_buffer_enum_to_count(buffer)"/>
+    <param name="value" type="const GLint *" marshal_count="_mesa_buffer_enum_to_count(buffer)"/>
   </function>
 
   <function name="ClearBufferuiv" es2="3.0" no_error="true" exec="dlist">
     <param name="buffer" type="GLenum"/>
     <param name="drawbuffer" type="GLint"/>
-    <param name="value" type="const GLuint *" count="_mesa_buffer_enum_to_count(buffer)"/>
+    <param name="value" type="const GLuint *" marshal_count="_mesa_buffer_enum_to_count(buffer)"/>
   </function>
 
   <function name="ClearBufferfv" es2="3.0" no_error="true" exec="dlist">
     <param name="buffer" type="GLenum"/>
     <param name="drawbuffer" type="GLint"/>
-    <param name="value" type="const GLfloat *" count="_mesa_buffer_enum_to_count(buffer)"/>
+    <param name="value" type="const GLfloat *" marshal_count="_mesa_buffer_enum_to_count(buffer)"/>
   </function>
 
   <function name="ClearBufferfi" es2="3.0" no_error="true" exec="dlist">
@@ -451,13 +451,13 @@
   <function name="TexParameterIiv" es2="3.2" exec="dlist">
     <param name="target" type="GLenum"/>
     <param name="pname" type="GLenum"/>
-    <param name="params" type="const GLint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+    <param name="params" type="const GLint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
   </function>
 
   <function name="TexParameterIuiv" es2="3.2" exec="dlist">
     <param name="target" type="GLenum"/>
     <param name="pname" type="GLenum"/>
-    <param name="params" type="const GLuint *" count="_mesa_tex_param_enum_to_count(pname)"/>
+    <param name="params" type="const GLuint *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
   </function>
 
   <function name="GetTexParameterIiv" es2="3.2">
diff --git a/src/mapi/glapi/gen/OES_fixed_point.xml b/src/mapi/glapi/gen/OES_fixed_point.xml
index 73293346ca1e..355d730add8c 100644
--- a/src/mapi/glapi/gen/OES_fixed_point.xml
+++ b/src/mapi/glapi/gen/OES_fixed_point.xml
@@ -234,7 +234,7 @@
     <function name="TexParameterxvOES" es1="1.0" alias="TexParameterxv">
         <param name="target" type="GLenum"/>
         <param name="pname" type="GLenum"/>
-        <param name="params" type="const GLfixed *" count="_mesa_tex_param_enum_to_count(pname)"/>
+        <param name="params" type="const GLfixed *" marshal_count="_mesa_tex_param_enum_to_count(pname)"/>
     </function>
 
     <!-- texgen -->
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index ff202c3ef4c9..ce479a20eb10 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -5321,7 +5321,7 @@
 
     <function name="DrawBuffers" es2="3.0" no_error="true" exec="dlist">
         <param name="n" type="GLsizei" counter="true"/>
-        <param name="bufs" type="const GLenum *" count="n"/>
+        <param name="bufs" type="const GLenum *" count="n" marshal_count="CLAMP(n, 0, MAX_DRAW_BUFFERS)"/>
         <glx rop="233" large="true"/>
     </function>
 
diff --git a/src/mapi/glapi/gen/gl_and_es_API.xml b/src/mapi/glapi/gen/gl_and_es_API.xml
index 0c8a1d5a9d10..5adfbd35194c 100644
--- a/src/mapi/glapi/gen/gl_and_es_API.xml
+++ b/src/mapi/glapi/gen/gl_and_es_API.xml
@@ -259,7 +259,7 @@
     <function name="PointParameterxv" es1="1.1" deprecated="3.1">
         <param name="pname" type="GLenum"/>
         <param name="params" type="const GLfixed *"
-               count="_mesa_point_param_enum_to_count(pname)"/>
+               marshal_count="_mesa_point_param_enum_to_count(pname)"/>
     </function>
 
     <function name="TexParameterxv" es1="1.1" deprecated="3.1">
-- 
GitLab


From 544e58c62fc5b6468e04663f5dde8e6caf919bab Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 01:23:50 -0500
Subject: [PATCH 29/32] glthread: rewrite glBindBuffer packing

We always reserved space for a doubled glBindBuffer call, occupying
2 slots. Thanks to the removal of cmd_size, we can finally represent
glBindBuffer in only 1 slot, so do that. This saves space if there is
only 1 glBindBuffer call.

The combining of back-to-back BindBuffer calls is preserved by keeping
track of 2 last BindBuffer calls.
---
 src/mesa/main/glthread.c           |  3 +-
 src/mesa/main/glthread.h           |  3 +-
 src/mesa/main/glthread_bufferobj.c | 80 ++++++++++++++----------------
 3 files changed, 40 insertions(+), 46 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 6542b79e00da..1eb373860659 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -353,7 +353,8 @@ glthread_finalize_batch(struct glthread_state *glthread,
    glthread->used = 0;
 
    glthread->LastCallList = NULL;
-   glthread->LastBindBuffer = NULL;
+   glthread->LastBindBuffer1 = NULL;
+   glthread->LastBindBuffer2 = NULL;
 }
 
 void
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index 5fb822852d56..8225d5031ccf 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -274,7 +274,8 @@ struct glthread_state
 
    /** The last added call of the given function. */
    struct marshal_cmd_CallList *LastCallList;
-   struct marshal_cmd_BindBuffer *LastBindBuffer;
+   struct marshal_cmd_BindBuffer *LastBindBuffer1;
+   struct marshal_cmd_BindBuffer *LastBindBuffer2;
 
    /** Global mutex update info. */
    unsigned GlobalLockUpdateBatchCounter;
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index 07a9285ad7fb..499a480a339a 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -213,33 +213,18 @@ _mesa_glthread_BindBuffer(struct gl_context *ctx, GLenum target, GLuint buffer)
    }
 }
 
-/* This can hold up to 2 BindBuffer calls. This is used to eliminate
- * duplicated BindBuffer calls, which are plentiful in viewperf2020/catia.
- * In this example, the first 2 calls are eliminated by glthread by keeping
- * track of the last 2 BindBuffer calls and overwriting them if the target
- * matches.
- *
- *   glBindBuffer(GL_ARRAY_BUFFER, 0);
- *   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
- *   glBindBuffer(GL_ARRAY_BUFFER, 6);
- *   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 7);
- */
 struct marshal_cmd_BindBuffer
 {
    struct marshal_cmd_base cmd_base;
-   GLenum16 target[2];
-   GLuint buffer[2];
+   GLenum16 target;
+   GLuint buffer;
 };
 
 uint32_t
 _mesa_unmarshal_BindBuffer(struct gl_context *ctx,
                            const struct marshal_cmd_BindBuffer *restrict cmd)
 {
-   CALL_BindBuffer(ctx->Dispatch.Current, (cmd->target[0], cmd->buffer[0]));
-
-   if (cmd->target[1])
-      CALL_BindBuffer(ctx->Dispatch.Current, (cmd->target[1], cmd->buffer[1]));
-
+   CALL_BindBuffer(ctx->Dispatch.Current, (cmd->target, cmd->buffer));
    return align(sizeof(struct marshal_cmd_BindBuffer), 8) / 8;
 }
 
@@ -247,46 +232,53 @@ void GLAPIENTRY
 _mesa_marshal_BindBuffer(GLenum target, GLuint buffer)
 {
    GET_CURRENT_CONTEXT(ctx);
+   _mesa_glthread_BindBuffer(ctx, target, buffer);
+
    struct glthread_state *glthread = &ctx->GLThread;
-   struct marshal_cmd_BindBuffer *last = glthread->LastBindBuffer;
+   struct marshal_cmd_BindBuffer *last1 = glthread->LastBindBuffer1;
+   struct marshal_cmd_BindBuffer *last2 = glthread->LastBindBuffer2;
    int cmd_size = sizeof(struct marshal_cmd_BindBuffer);
 
-   _mesa_glthread_BindBuffer(ctx, target, buffer);
-
-   /* If the last call is BindBuffer... */
-   if (_mesa_glthread_call_is_last(glthread, &last->cmd_base,
+   /* Eliminate duplicated BindBuffer calls, which are plentiful
+    * in viewperf2020/catia. In this example, the first 2 calls are eliminated
+    * by glthread by keeping track of the last 2 BindBuffer calls and
+    * overwriting them if the target matches.
+    *
+    *   glBindBuffer(GL_ARRAY_BUFFER, 0);
+    *   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+    *   glBindBuffer(GL_ARRAY_BUFFER, 6);
+    *   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 7);
+    *
+    * If the last call is BindBuffer...
+    * last2 is more recent. last1 is before last2.
+    */
+   if (_mesa_glthread_call_is_last(glthread, &last2->cmd_base,
                                    align(cmd_size, 8) / 8)) {
       /* If the target is in the last call and unbinding the buffer, overwrite
        * the buffer ID there.
-       *
-       * We can't optimize out binding non-zero buffers because binding also
-       * creates the GL objects (like glCreateBuffers), which can't be skipped.
        */
-      if (target == last->target[0] && !last->buffer[0]) {
-         last->buffer[0] = buffer;
-         return;
-      }
-      if (target == last->target[1] && !last->buffer[1]) {
-         last->buffer[1] = buffer;
-         return;
-      }
-
-      /* If the last call has an unused buffer field, add this call to it. */
-      if (last->target[1] == 0) {
-         last->target[1] = MIN2(target, 0xffff); /* clamped to 0xffff (invalid enum) */
-         last->buffer[1] = buffer;
+      if (target == last2->target) {
+         /* We can't overwrite binding non-zero buffers because binding also
+          * creates the GL objects (like glCreateBuffers), which can't be skipped.
+          */
+         if (!last2->buffer) {
+            last2->buffer = buffer;
+            return;
+         }
+      } else if (last1 + 1 == last2 && target == last1->target &&
+                 !last1->buffer) {
+         last1->buffer = buffer;
          return;
       }
    }
 
    struct marshal_cmd_BindBuffer *cmd =
       _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_BindBuffer, cmd_size);
+   cmd->target = MIN2(target, 0xffff); /* clamped to 0xffff (invalid enum) */
+   cmd->buffer = buffer;
 
-   cmd->target[0] = MIN2(target, 0xffff); /* clamped to 0xffff (invalid enum) */
-   cmd->target[1] = 0;
-   cmd->buffer[0] = buffer;
-
-   glthread->LastBindBuffer = cmd;
+   glthread->LastBindBuffer1 = last2;
+   glthread->LastBindBuffer2 = cmd;
 }
 
 void
-- 
GitLab


From c454108dad3b366db5d3eeb90a5314beb67ea2fd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Jan 2024 23:34:07 -0500
Subject: [PATCH 30/32] glthread: add a packed variant of glDrawElements with
 16-bit count and indices

This is just to decrease the size of glDrawElements by 8 more bytes.
This packed glDrawElements call occupies only 1 slot in glthread_batch.

This decreases the size of 1 frame in glthread batches by 13%
in Viewperf2020/Catia1.
---
 src/mapi/glapi/gen/gl_API.xml     |  8 ++++
 src/mapi/glapi/gen/static_data.py |  1 +
 src/mesa/main/glthread_draw.c     | 68 +++++++++++++++++++++++++++----
 3 files changed, 69 insertions(+), 8 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index ce479a20eb10..2b12a5466a1d 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -12970,6 +12970,14 @@
         <param name="drawid" type="GLuint"/>
     </function>
 
+    <function name="DrawElementsPacked" es1="1.0" es2="2.0" marshal="custom"
+              marshal_struct="public">
+        <param name="mode" type="GLenum"/>
+        <param name="type" type="GLenum"/>
+        <param name="count" type="GLushort"/>
+        <param name="indices" type="GLushort"/>
+    </function>
+
     <!-- Internal function for glthread to implement ancillary buffer invalidation. -->
     <function name="InternalInvalidateFramebufferAncillaryMESA" es2="3.0">
     </function>
diff --git a/src/mapi/glapi/gen/static_data.py b/src/mapi/glapi/gen/static_data.py
index 58e303e5bfae..9c4ce55f6b4d 100644
--- a/src/mapi/glapi/gen/static_data.py
+++ b/src/mapi/glapi/gen/static_data.py
@@ -1704,6 +1704,7 @@ offsets = {
     "DrawArraysInstancedBaseInstanceDrawID": 1668,
     "DrawElementsInstancedBaseVertexBaseInstanceDrawID": 1669,
     "InternalInvalidateFramebufferAncillaryMESA": 1670,
+    "DrawElementsPacked": 1671,
 }
 
 functions = [
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 9b53be12714d..9fc41c813935 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -633,6 +633,19 @@ _mesa_unmarshal_DrawElements(struct gl_context *ctx,
    return align(sizeof(*cmd), 8) / 8;
 }
 
+uint32_t
+_mesa_unmarshal_DrawElementsPacked(struct gl_context *ctx,
+                                   const struct marshal_cmd_DrawElementsPacked *restrict cmd)
+{
+   const GLenum mode = cmd->mode;
+   const GLsizei count = cmd->count;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
+   const GLvoid *indices = (void*)(uintptr_t)cmd->indices;
+
+   CALL_DrawElements(ctx->Dispatch.Current, (mode, count, type, indices));
+   return align(sizeof(*cmd), 8) / 8;
+}
+
 uint32_t
 _mesa_unmarshal_DrawElementsInstancedBaseVertex(struct gl_context *ctx,
                                                 const struct marshal_cmd_DrawElementsInstancedBaseVertex *restrict cmd)
@@ -784,14 +797,29 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
          ctx->GLThread.ListMode))) {            /* GL_INVALID_OPERATION */
       if (drawid == 0 && baseinstance == 0) {
          if (instance_count == 1 && basevertex == 0) {
-            int cmd_size = sizeof(struct marshal_cmd_DrawElements);
-            struct marshal_cmd_DrawElements *cmd =
-                  _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElements, cmd_size);
-
-            cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-            cmd->type = encode_index_type(type);
-            cmd->count = count;
-            cmd->indices = indices;
+            if ((count & 0xffff) == count && (uintptr_t)indices <= UINT16_MAX) {
+               /* Packed version of DrawElements: 16-bit count and 16-bit index offset,
+                * reducing the call size by 8 bytes.
+                * This is the most common case in Viewperf2020/Catia1.
+                */
+               int cmd_size = sizeof(struct marshal_cmd_DrawElementsPacked);
+               struct marshal_cmd_DrawElementsPacked *cmd =
+                     _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsPacked, cmd_size);
+
+               cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
+               cmd->type = encode_index_type(type);
+               cmd->count = count;
+               cmd->indices = (uintptr_t)indices;
+            } else {
+               int cmd_size = sizeof(struct marshal_cmd_DrawElements);
+               struct marshal_cmd_DrawElements *cmd =
+                     _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElements, cmd_size);
+
+               cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
+               cmd->type = encode_index_type(type);
+               cmd->count = count;
+               cmd->indices = indices;
+            }
          } else {
             int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertex);
             struct marshal_cmd_DrawElementsInstancedBaseVertex *cmd =
@@ -1921,6 +1949,12 @@ _mesa_marshal_DrawArraysInstancedBaseInstanceDrawID(void)
    unreachable("should never end up here");
 }
 
+void GLAPIENTRY _mesa_marshal_DrawElementsPacked(GLenum mode, GLenum type,
+                                                 GLushort count, GLushort indices)
+{
+   unreachable("should never end up here");
+}
+
 void GLAPIENTRY
 _mesa_marshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(GLenum mode, GLsizei count,
                                                                 GLenum type, const GLvoid *indices,
@@ -1948,6 +1982,12 @@ _mesa_DrawArraysInstancedBaseInstanceDrawID(void)
    unreachable("should never end up here");
 }
 
+void GLAPIENTRY _mesa_DrawElementsPacked(GLenum mode, GLenum type,
+                                         GLushort count, GLushort indices)
+{
+   unreachable("should never end up here");
+}
+
 void GLAPIENTRY
 _mesa_DrawElementsInstancedBaseVertexBaseInstanceDrawID(GLenum mode, GLsizei count,
                                                         GLenum type, const GLvoid *indices,
@@ -1965,6 +2005,8 @@ _mesa_unmarshal_PushMatrix(struct gl_context *ctx,
    const unsigned mult_matrixf_size = 9;
    const unsigned draw_elements_size =
       (align(sizeof(struct marshal_cmd_DrawElements), 8) / 8);
+   const unsigned draw_elements_packed_size =
+      (align(sizeof(struct marshal_cmd_DrawElementsPacked), 8) / 8);
    const unsigned pop_matrix_size = 1;
    uint64_t *next1 = _mesa_glthread_next_cmd((uint64_t *)cmd, push_matrix_size);
    uint64_t *next2;
@@ -1989,6 +2031,16 @@ _mesa_unmarshal_PushMatrix(struct gl_context *ctx,
       }
       break;
 
+   case DISPATCH_CMD_DrawElementsPacked:
+      next2 = _mesa_glthread_next_cmd(next1, draw_elements_packed_size);
+
+      if (_mesa_glthread_get_cmd(next2)->cmd_id == DISPATCH_CMD_PopMatrix) {
+         /* The beauty of this is that this is inlined. */
+         _mesa_unmarshal_DrawElementsPacked(ctx, (void*)next1);
+         return push_matrix_size + draw_elements_packed_size + pop_matrix_size;
+      }
+      break;
+
    case DISPATCH_CMD_MultMatrixf:
       /* Skip this sequence:
        *    glPushMatrix
-- 
GitLab


From 4aa8d8114fc30e7100f214fccde071c44429b1f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 9 Jan 2024 03:48:00 -0500
Subject: [PATCH 31/32] glthread: add a packed version of DrawElementsUserBuf

The reduces the call size by 24 bytes.
---
 src/mapi/glapi/gen/gl_API.xml     |  4 ++
 src/mapi/glapi/gen/static_data.py |  1 +
 src/mesa/main/draw.c              | 34 +++++++++++++
 src/mesa/main/glthread_draw.c     | 80 ++++++++++++++++++++++++-------
 src/mesa/main/glthread_marshal.h  | 12 +++++
 5 files changed, 115 insertions(+), 16 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 2b12a5466a1d..ce6b36ce36a8 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -12941,6 +12941,10 @@
         <param name="cmd" type="const GLvoid *"/> <!-- struct marshal_cmd_DrawElementsUserBuf -->
     </function>
 
+    <function name="DrawElementsUserBufPacked" es1="1.0" es2="2.0" marshal="custom">
+        <param name="cmd" type="const GLvoid *"/> <!-- struct marshal_cmd_DrawElementsUserBufPacked -->
+    </function>
+
     <function name="MultiDrawArraysUserBuf" es1="1.0" es2="2.0" marshal="custom">
     </function>
 
diff --git a/src/mapi/glapi/gen/static_data.py b/src/mapi/glapi/gen/static_data.py
index 9c4ce55f6b4d..f4f1f4bf0f56 100644
--- a/src/mapi/glapi/gen/static_data.py
+++ b/src/mapi/glapi/gen/static_data.py
@@ -1705,6 +1705,7 @@ offsets = {
     "DrawElementsInstancedBaseVertexBaseInstanceDrawID": 1669,
     "InternalInvalidateFramebufferAncillaryMESA": 1670,
     "DrawElementsPacked": 1671,
+    "DrawElementsUserBufPacked": 1672,
 }
 
 functions = [
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 764c1284ecda..26a074dd2e7a 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1973,6 +1973,40 @@ _mesa_DrawElementsUserBuf(const GLvoid *ptr)
    ctx->DrawID = 0;
 }
 
+/**
+ * Same as glDrawElementsInstancedBaseVertexBaseInstance, but the index
+ * buffer is set by the indexBuf parameter instead of using the bound
+ * GL_ELEMENT_ARRAY_BUFFER if indexBuf != NULL.
+ */
+void GLAPIENTRY
+_mesa_DrawElementsUserBufPacked(const GLvoid *ptr)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   FLUSH_FOR_DRAW(ctx);
+
+   _mesa_set_varying_vp_inputs(ctx, ctx->VertexProgram._VPModeInputFilter &
+                               ctx->Array._DrawVAO->_EnabledWithMapMode);
+   if (ctx->NewState)
+      _mesa_update_state(ctx);
+
+   const struct marshal_cmd_DrawElementsUserBufPacked *cmd =
+      (const struct marshal_cmd_DrawElementsUserBufPacked *)ptr;
+   const GLenum mode = cmd->mode;
+   const GLsizei count = cmd->count;
+   const GLenum type = _mesa_decode_index_type(cmd->type);
+
+   if (!_mesa_is_no_error_enabled(ctx) &&
+       !_mesa_validate_DrawElements(ctx, mode, count, type))
+      return;
+
+   struct gl_buffer_object *index_bo =
+      cmd->index_buffer ? cmd->index_buffer : ctx->Array.VAO->IndexBufferObj;
+
+   const GLvoid *indices = (void*)(uintptr_t)cmd->indices;
+
+   _mesa_validated_drawrangeelements(ctx, index_bo, mode, false, 0, ~0,
+                                     count, type, indices, 0, 1, 0);
+}
 
 /**
  * Inner support for both _mesa_MultiDrawElements() and
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 9fc41c813935..1bef35b0d71a 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -724,6 +724,28 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    return cmd->num_slots;
 }
 
+uint32_t
+_mesa_unmarshal_DrawElementsUserBufPacked(struct gl_context *ctx,
+                                    const struct marshal_cmd_DrawElementsUserBufPacked *restrict cmd)
+{
+   const GLuint user_buffer_mask = cmd->user_buffer_mask;
+
+   /* Bind uploaded buffers if needed. */
+   if (user_buffer_mask) {
+      struct gl_buffer_object **buffers = (struct gl_buffer_object **)(cmd + 1);
+      const int *offsets = (const int *)(buffers + util_bitcount(user_buffer_mask));
+
+      _mesa_InternalBindVertexBuffers(ctx, buffers, offsets, user_buffer_mask);
+   }
+
+   /* Draw. */
+   CALL_DrawElementsUserBufPacked(ctx->Dispatch.Current, (cmd));
+
+   struct gl_buffer_object *index_buffer = cmd->index_buffer;
+   _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
+   return cmd->num_slots;
+}
+
 static inline bool
 should_convert_to_begin_end(struct gl_context *ctx, unsigned count,
                             unsigned num_upload_vertices,
@@ -923,25 +945,45 @@ draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
    unsigned num_buffers = util_bitcount(user_buffer_mask);
    int buffers_size = num_buffers * sizeof(buffers[0]);
    int offsets_size = num_buffers * sizeof(int);
-   int cmd_size = sizeof(struct marshal_cmd_DrawElementsUserBuf) +
-                  buffers_size + offsets_size;
-   struct marshal_cmd_DrawElementsUserBuf *cmd;
+   char *variable_data;
 
-   cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
-   cmd->num_slots = align(cmd_size, 8) / 8;
-   cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
-   cmd->type = encode_index_type(type);
-   cmd->count = count;
-   cmd->indices = indices;
-   cmd->instance_count = instance_count;
-   cmd->basevertex = basevertex;
-   cmd->baseinstance = baseinstance;
-   cmd->user_buffer_mask = user_buffer_mask;
-   cmd->index_buffer = index_buffer;
-   cmd->drawid = drawid;
+   if (instance_count == 1 && basevertex == 0 && baseinstance == 0 &&
+       drawid == 0 && (count & 0xffff) == count &&
+       (uintptr_t)indices <= UINT32_MAX) {
+      int cmd_size = sizeof(struct marshal_cmd_DrawElementsUserBufPacked) +
+                     buffers_size + offsets_size;
+      struct marshal_cmd_DrawElementsUserBufPacked *cmd;
+
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBufPacked, cmd_size);
+      cmd->num_slots = align(cmd_size, 8) / 8;
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
+      cmd->type = encode_index_type(type);
+      cmd->count = count; /* truncated */
+      cmd->indices = (uintptr_t)indices; /* truncated */
+      cmd->user_buffer_mask = user_buffer_mask;
+      cmd->index_buffer = index_buffer;
+      variable_data = (char*)(cmd + 1);
+   } else {
+      int cmd_size = sizeof(struct marshal_cmd_DrawElementsUserBuf) +
+                     buffers_size + offsets_size;
+      struct marshal_cmd_DrawElementsUserBuf *cmd;
+
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
+      cmd->num_slots = align(cmd_size, 8) / 8;
+      cmd->mode = MIN2(mode, 0xff); /* clamped to 0xff (invalid enum) */
+      cmd->type = encode_index_type(type);
+      cmd->count = count;
+      cmd->indices = indices;
+      cmd->instance_count = instance_count;
+      cmd->basevertex = basevertex;
+      cmd->baseinstance = baseinstance;
+      cmd->user_buffer_mask = user_buffer_mask;
+      cmd->index_buffer = index_buffer;
+      cmd->drawid = drawid;
+      variable_data = (char*)(cmd + 1);
+   }
 
    if (user_buffer_mask) {
-      char *variable_data = (char*)(cmd + 1);
       memcpy(variable_data, buffers, buffers_size);
       variable_data += buffers_size;
       memcpy(variable_data, offsets, offsets_size);
@@ -1927,6 +1969,12 @@ _mesa_marshal_DrawElementsUserBuf(const GLvoid *cmd)
    unreachable("should never end up here");
 }
 
+void GLAPIENTRY
+_mesa_marshal_DrawElementsUserBufPacked(const GLvoid *cmd)
+{
+   unreachable("should never end up here");
+}
+
 void GLAPIENTRY
 _mesa_marshal_MultiDrawArraysUserBuf(void)
 {
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index f8e0bb6d3912..5084301ebbfb 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -76,6 +76,18 @@ struct marshal_cmd_DrawElementsUserBuf
    struct gl_buffer_object *index_buffer;
 };
 
+struct marshal_cmd_DrawElementsUserBufPacked
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum8 mode;
+   GLindextype type;
+   uint16_t num_slots;
+   GLushort count;
+   GLuint user_buffer_mask;
+   GLuint indices;
+   struct gl_buffer_object *index_buffer;
+};
+
 static inline void *
 _mesa_glthread_allocate_command(struct gl_context *ctx,
                                 uint16_t cmd_id,
-- 
GitLab


From eea00dea2455e7df28f4276090d393aa17cde613 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Jan 2024 20:59:37 -0500
Subject: [PATCH 32/32] glthread: generate packed versions of gl*Pointer/Offset
 calls

The pointer/offset parameter is often NULL or a small number with VBOs.

The idea is:
- If the pointer/offset parameter is NULL/0, use a different cmd structure
  and unmarshal function that doesn't contain the pointer/offset parameter
  to save 8 bytes per call.
- If the cmd structure has a hole and the pointer/offset parameter is
  a small number that fits into the hole, use a different cmd structure
  and unmarshal function that stores the value within the hole using
  a smaller type to save 8 bytes per call.

This implements those ideas. It will continue generating the most optimal
code even if we change the packing of other parameters.

This decreases the size of 1 frame in glthread batches by 21%
in Viewperf2020/Catia1.

Example of generated code for glVertexPointer with and without the pointer
parameter if it's NULL. See the arrows for comments.

/* VertexPointer: marshalled asynchronously */
struct marshal_cmd_VertexPointer
{
   struct marshal_cmd_base cmd_base;
   GLpacked16i size;
   GLenum16 type;
   GLclamped16i stride;
   const GLvoid * pointer;
};
struct marshal_cmd_VertexPointer_packed
{
   struct marshal_cmd_base cmd_base;
   GLpacked16i size;
   GLenum16 type;
   GLclamped16i stride;                                 // <------- no "pointer"
};
uint32_t _mesa_unmarshal_VertexPointer(struct gl_context *ctx, const struct marshal_cmd_VertexPointer *restrict cmd)
{
   GLpacked16i size = cmd->size;
   GLenum16 type = cmd->type;
   GLclamped16i stride = cmd->stride;
   const GLvoid * pointer = cmd->pointer;
   CALL_VertexPointer(ctx->Dispatch.Current, (size, type, stride, pointer));
   return align(sizeof(struct marshal_cmd_VertexPointer), 8) / 8;
}
uint32_t _mesa_unmarshal_VertexPointer_packed(struct gl_context *ctx, const struct marshal_cmd_VertexPointer_packed *restrict cmd)
{
   GLpacked16i size = cmd->size;
   GLenum16 type = cmd->type;
   GLclamped16i stride = cmd->stride;
   const GLvoid * pointer = (const GLvoid *)(uintptr_t)0;       // <------- using NULL
   CALL_VertexPointer(ctx->Dispatch.Current, (size, type, stride, pointer));
   return align(sizeof(struct marshal_cmd_VertexPointer_packed), 8) / 8;
}
static void GLAPIENTRY
_mesa_marshal_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   GET_CURRENT_CONTEXT(ctx);
   if (!pointer) {                              // <------- the condition
      int cmd_size = sizeof(struct marshal_cmd_VertexPointer_packed);
      struct marshal_cmd_VertexPointer_packed *cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_VertexPointer_packed, cmd_size);
      cmd->size = size < 0 ? UINT16_MAX : MIN2(size, UINT16_MAX);
      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
      cmd->stride = CLAMP(stride, INT16_MIN, INT16_MAX);
   } else {
      int cmd_size = sizeof(struct marshal_cmd_VertexPointer);
      struct marshal_cmd_VertexPointer *cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_VertexPointer, cmd_size);
      cmd->size = size < 0 ? UINT16_MAX : MIN2(size, UINT16_MAX);
      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
      cmd->stride = CLAMP(stride, INT16_MIN, INT16_MAX);
      cmd->pointer = pointer;
   }
   _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS, MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, pointer);
}

Example of generated code for glNormalPointer using a smaller type:

/* NormalPointer: marshalled asynchronously */
struct marshal_cmd_NormalPointer
{
   struct marshal_cmd_base cmd_base;
   GLenum16 type;
   GLclamped16i stride;
   const GLvoid * pointer;
};
struct marshal_cmd_NormalPointer_packed
{
   struct marshal_cmd_base cmd_base;
   GLenum16 type;
   GLclamped16i stride;
   GLushort pointer;                                    // <-------- truncated "pointer"
};
uint32_t _mesa_unmarshal_NormalPointer(struct gl_context *ctx, const struct marshal_cmd_NormalPointer *restrict cmd)
{
   GLenum16 type = cmd->type;
   GLclamped16i stride = cmd->stride;
   const GLvoid * pointer = cmd->pointer;
   CALL_NormalPointer(ctx->Dispatch.Current, (type, stride, pointer));
   return align(sizeof(struct marshal_cmd_NormalPointer), 8) / 8;
}
uint32_t _mesa_unmarshal_NormalPointer_packed(struct gl_context *ctx, const struct marshal_cmd_NormalPointer_packed *restrict cmd)
{
   GLenum16 type = cmd->type;
   GLclamped16i stride = cmd->stride;
   const GLvoid * pointer = (const GLvoid *)(uintptr_t)cmd->pointer;  // <-------- upcasting
   CALL_NormalPointer(ctx->Dispatch.Current, (type, stride, pointer));
   return align(sizeof(struct marshal_cmd_NormalPointer_packed), 8) / 8;
}
static void GLAPIENTRY
_mesa_marshal_NormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   GET_CURRENT_CONTEXT(ctx);
   if (((uintptr_t)pointer & 0xffff) == (uintptr_t)pointer) {        // <-------- the condition
      int cmd_size = sizeof(struct marshal_cmd_NormalPointer_packed);
      struct marshal_cmd_NormalPointer_packed *cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_NormalPointer_packed, cmd_size);
      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
      cmd->stride = CLAMP(stride, INT16_MIN, INT16_MAX);
      cmd->pointer = (uintptr_t)pointer; /* truncated */             // <-------- the truncation
   } else {
      int cmd_size = sizeof(struct marshal_cmd_NormalPointer);
      struct marshal_cmd_NormalPointer *cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_NormalPointer, cmd_size);
      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
      cmd->stride = CLAMP(stride, INT16_MIN, INT16_MAX);
      cmd->pointer = pointer;
   }
   _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL, MESA_PACK_VFORMAT(type, 3, 1, 0, 0), stride, pointer);
}
---
 src/mapi/glapi/gen/gl_marshal.py         | 60 ++++++++++-----
 src/mapi/glapi/gen/gl_marshal_h.py       |  7 +-
 src/mapi/glapi/gen/gl_unmarshal_table.py |  4 +
 src/mapi/glapi/gen/marshal_XML.py        | 93 +++++++++++++++++++++++-
 4 files changed, 141 insertions(+), 23 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_marshal.py b/src/mapi/glapi/gen/gl_marshal.py
index cf51608557b8..4da469a6b8ba 100644
--- a/src/mapi/glapi/gen/gl_marshal.py
+++ b/src/mapi/glapi/gen/gl_marshal.py
@@ -103,19 +103,23 @@ class PrintCode(gl_XML.gl_print_base):
         out('')
         out('')
 
-    def print_unmarshal_func(self, func):
-        out('uint32_t')
-        out(('_mesa_unmarshal_{0}(struct gl_context *ctx, '
-             'const struct marshal_cmd_{0} *restrict cmd)').format(func.name))
+    def print_unmarshal_func(self, func, is_packed=False):
+        func.print_unmarshal_prototype(is_packed=is_packed)
         out('{')
         with indent():
             for p in func.fixed_params:
+                type = func.get_marshal_type(p)
+
                 if p.count:
                     p_decl = '{0} *{1} = cmd->{1};'.format(
                             p.get_base_type_string(), p.name)
+                elif is_packed and func.packed_param_name == p.name:
+                    if func.packed_param_size == 0:
+                        p_decl = '{0} {1} = ({0})(uintptr_t)0;'.format(type, p.name)
+                    else:
+                        p_decl = '{0} {1} = ({0})(uintptr_t)cmd->{1};'.format(type, p.name)
                 else:
-                    p_decl = '{0} {1} = cmd->{1};'.format(
-                            func.get_marshal_type(p), p.name)
+                    p_decl = '{0} {1} = cmd->{1};'.format(type, p.name)
 
                 if not p_decl.startswith('const ') and p.count:
                     # Declare all local function variables as const, even if
@@ -150,12 +154,14 @@ class PrintCode(gl_XML.gl_print_base):
             if func.variable_params:
                 out('return cmd->num_slots;')
             else:
-                struct = 'struct marshal_cmd_{0}'.format(func.name)
-                out('return align(sizeof({0}), 8) / 8;'.format(struct))
+                out('return align(sizeof({0}), 8) / 8;'.format(func.get_marshal_struct_name(is_packed)))
         out('}')
 
-    def print_marshal_async_code(self, func):
-        struct = 'struct marshal_cmd_{0}'.format(func.name)
+        if not is_packed and func.packed_fixed_params:
+            self.print_unmarshal_func(func, is_packed=True)
+
+    def print_marshal_async_code(self, func, is_packed=False):
+        struct = func.get_marshal_struct_name(is_packed)
 
         if func.marshal_sync:
             out('int cmd_size = sizeof({0});'.format(struct))
@@ -205,17 +211,24 @@ class PrintCode(gl_XML.gl_print_base):
                 out('assert(cmd_size >= 0 && cmd_size <= MARSHAL_MAX_CMD_SIZE);')
 
         # Add the call into the batch.
-        out('{0} *cmd = _mesa_glthread_allocate_command(ctx, '
-            'DISPATCH_CMD_{1}, cmd_size);'.format(struct, func.name))
+        dispatch_cmd = 'DISPATCH_CMD_{0}{1}'.format(func.name, '_packed' if is_packed else '')
+        if func.get_fixed_params(is_packed) or func.variable_params:
+            out('{0} *cmd = _mesa_glthread_allocate_command(ctx, {1}, cmd_size);'
+                .format(struct, dispatch_cmd))
+        else:
+            out('_mesa_glthread_allocate_command(ctx, {0}, cmd_size);'.format(dispatch_cmd))
+
         if func.variable_params:
             out('cmd->num_slots = align(cmd_size, 8) / 8;')
 
-        for p in func.fixed_params:
+        for p in func.get_fixed_params(is_packed):
             type = func.get_marshal_type(p)
 
             if p.count:
                 out('memcpy(cmd->{0}, {0}, {1});'.format(
                         p.name, p.size_string()))
+            elif is_packed and p.name == func.packed_param_name:
+                out('cmd->{0} = (uintptr_t){0}; /* truncated */'.format(p.name))
             elif type == 'GLenum8':
                 out('cmd->{0} = MIN2({0}, 0xff); /* clamped to 0xff (invalid enum) */'.format(p.name))
             elif type == 'GLenum16':
@@ -226,6 +239,7 @@ class PrintCode(gl_XML.gl_print_base):
                 out('cmd->{0} = {0} < 0 ? UINT16_MAX : MIN2({0}, UINT16_MAX);'.format(p.name))
             else:
                 out('cmd->{0} = {0};'.format(p.name))
+
         if func.variable_params:
             out('char *variable_data = (char *) (cmd + 1);')
             i = 1
@@ -244,9 +258,6 @@ class PrintCode(gl_XML.gl_print_base):
                         out('variable_data += {0}_size;'.format(p.name))
                 i += 1
 
-        if not func.fixed_params and not func.variable_params:
-            out('(void) cmd;')
-
     def print_async_body(self, func):
         out('/* {0}: marshalled asynchronously */'.format(func.name))
         func.print_struct()
@@ -261,7 +272,22 @@ class PrintCode(gl_XML.gl_print_base):
             if func.marshal_call_before:
                 out(func.marshal_call_before);
 
-            self.print_marshal_async_code(func)
+            if func.packed_fixed_params:
+                if func.packed_param_size > 0:
+                    out('if (((uintptr_t){0} & 0x{1}) == (uintptr_t){0}) {{'
+                        .format(func.packed_param_name,
+                                'ff' * func.packed_param_size))
+                else:
+                    out('if (!{0}) {{'.format(func.packed_param_name))
+
+                with indent():
+                    self.print_marshal_async_code(func, is_packed=True)
+                out('} else {')
+                with indent():
+                    self.print_marshal_async_code(func)
+                out('}')
+            else:
+                self.print_marshal_async_code(func)
 
             if func.marshal_call_after:
                 out(func.marshal_call_after)
diff --git a/src/mapi/glapi/gen/gl_marshal_h.py b/src/mapi/glapi/gen/gl_marshal_h.py
index 467998ec9f69..47da88481db3 100644
--- a/src/mapi/glapi/gen/gl_marshal_h.py
+++ b/src/mapi/glapi/gen/gl_marshal_h.py
@@ -61,6 +61,8 @@ class PrintCode(gl_XML.gl_print_base):
             if flavor in ('skip', 'sync'):
                 continue
             print('   DISPATCH_CMD_{0},'.format(func.name))
+            if func.packed_fixed_params:
+                print('   DISPATCH_CMD_{0}_packed,'.format(func.name))
         print('   NUM_DISPATCH_CMD,')
         print('};')
         print('')
@@ -71,8 +73,9 @@ class PrintCode(gl_XML.gl_print_base):
             flavor = func.marshal_flavor()
 
             if flavor in ('custom', 'async'):
-                print(('uint32_t _mesa_unmarshal_{0}(struct gl_context *ctx, '
-                       'const struct marshal_cmd_{0} *restrict cmd);').format(func.name))
+                func.print_unmarshal_prototype(suffix=';')
+                if func.packed_fixed_params:
+                    func.print_unmarshal_prototype(suffix=';', is_packed=True)
 
             if flavor in ('custom', 'async', 'sync') and not func.marshal_is_static():
                 print('{0} GLAPIENTRY _mesa_marshal_{1}({2});'.format(func.return_type, func.name, func.get_parameter_string()))
diff --git a/src/mapi/glapi/gen/gl_unmarshal_table.py b/src/mapi/glapi/gen/gl_unmarshal_table.py
index 07c6ad371fa7..1d446e72e7cf 100644
--- a/src/mapi/glapi/gen/gl_unmarshal_table.py
+++ b/src/mapi/glapi/gen/gl_unmarshal_table.py
@@ -68,6 +68,8 @@ class PrintCode(gl_XML.gl_print_base):
                 if func.marshal_flavor() in ('skip', 'sync'):
                     continue
                 out('[DISPATCH_CMD_{0}] = (_mesa_unmarshal_func)_mesa_unmarshal_{0},'.format(func.name))
+                if func.packed_fixed_params:
+                    out('[DISPATCH_CMD_{0}_packed] = (_mesa_unmarshal_func)_mesa_unmarshal_{0}_packed,'.format(func.name))
         out('};')
 
         # Print the string table of function names.
@@ -78,6 +80,8 @@ class PrintCode(gl_XML.gl_print_base):
                 if func.marshal_flavor() in ('skip', 'sync'):
                     continue
                 out('[DISPATCH_CMD_{0}] = "{0}",'.format(func.name))
+                if func.packed_fixed_params:
+                    out('[DISPATCH_CMD_{0}_packed] = "{0}_packed",'.format(func.name))
         out('};')
 
 
diff --git a/src/mapi/glapi/gen/marshal_XML.py b/src/mapi/glapi/gen/marshal_XML.py
index 2a00fa61b52d..de09e2186cc5 100644
--- a/src/mapi/glapi/gen/marshal_XML.py
+++ b/src/mapi/glapi/gen/marshal_XML.py
@@ -25,6 +25,11 @@
 
 import gl_XML
 import sys
+import copy
+import typeexpr
+
+def pot_align(base, pot_alignment):
+    return (base + pot_alignment - 1) & ~(pot_alignment - 1);
 
 
 class marshal_item_factory(gl_XML.gl_item_factory):
@@ -163,6 +168,74 @@ class marshal_function(gl_XML.gl_function):
         # from smallest to biggest.
         self.fixed_params = sorted(self.fixed_params, key=lambda p: self.get_type_size(p))
 
+        # Compute the marshal structure size and the largest hole
+        self.struct_size = 2 # sizeof(struct marshal_cmd_base)
+        largest_hole = 0
+
+        for p in self.fixed_params:
+            type_size = self.get_type_size(p)
+            aligned_size = pot_align(self.struct_size, type_size)
+            largest_hole = max(aligned_size - self.struct_size, largest_hole)
+            self.struct_size = aligned_size
+            self.struct_size = self.struct_size + type_size
+
+        # Round down largest_hole to a power of two.
+        largest_hole = int(2 ** (largest_hole.bit_length() - 1))
+
+        # Align the structure to 8 bytes.
+        aligned_size = pot_align(self.struct_size, 8)
+        padding_hole = aligned_size - self.struct_size
+        self.struct_size = aligned_size
+
+        # Determine whether to generate a packed version of gl*Pointer calls.
+        # If there is a hole in the cmd structure, the pointer/offset parameter
+        # can be truncated and stored in the hole to save 8 bytes per call.
+        # The version of the structure is determined at runtime based on
+        # whether the truncation doesn't change the value. This is common with
+        # VBOs because the pointer/offset is usually small.
+        #
+        # If there is no hole, the packed version completely removes
+        # the pointer/offset parameter and is used when the value is NULL/0
+        # to remove 8 bytes per call. This is common with VBOs.
+        self.packed_param_name = None
+
+        if (self.is_vertex_pointer_call and
+            # 32-bit CPUs only benefit if we remove the whole 8-byte slot,
+            # which means there must be exactly 4-byte padding after the 4-byte
+            # pointer/offset parameter.
+            (self.context.pointer_size != 4 or padding_hole == 4)):
+            for pname in ['pointer', 'offset']:
+                if pname in [p.name for p in self.fixed_params]:
+                    self.packed_param_name = pname
+
+            assert self.packed_param_name
+            assert not self.variable_params
+            assert not self.marshal_sync
+
+        # Prepare the parameters for the packed version by replacing the type
+        # of the packed variable or removing it completely.
+        self.packed_fixed_params = []
+        if self.packed_param_name:
+            for p in self.fixed_params:
+                if p.name == self.packed_param_name:
+                    if largest_hole > 0:
+                        # Select the truncated type.
+                        type = ['GLubyte', 'GLushort', 'GLuint'][largest_hole.bit_length() - 1]
+
+                        # Clone the parameter and change its type
+                        new_param = copy.deepcopy(p)
+                        new_param.type_expr = typeexpr.type_expression(type, self.context)
+                        self.packed_fixed_params.append(new_param)
+                else:
+                    self.packed_fixed_params.append(p)
+            self.packed_param_size = largest_hole
+        # Sort the parameters by size to move the truncated type into the hole.
+        self.packed_fixed_params = sorted(self.packed_fixed_params, key=lambda p: self.get_type_size(p))
+
+
+    def get_fixed_params(self, is_packed):
+        return self.packed_fixed_params if is_packed else self.fixed_params
+
     def marshal_flavor(self):
         """Find out how this function should be marshalled between
         client and server threads."""
@@ -195,15 +268,15 @@ class marshal_function(gl_XML.gl_function):
                 self.name[0:8] != 'Internal' and
                 self.exec_flavor != 'beginend')
 
-    def print_struct(self, is_header=False):
+    def print_struct(self, is_header=False, is_packed=False):
         if (self.marshal_struct == 'public') == is_header:
-            print('struct marshal_cmd_{0}'.format(self.name))
+            print(self.get_marshal_struct_name(is_packed))
             print('{')
             print('   struct marshal_cmd_base cmd_base;')
             if self.variable_params:
                 print('   uint16_t num_slots;')
 
-            for p in self.fixed_params:
+            for p in self.get_fixed_params(is_packed):
                 if p.count:
                     print('   {0} {1}[{2}];'.format(
                             p.get_base_type_string(), p.name, p.count))
@@ -228,4 +301,16 @@ class marshal_function(gl_XML.gl_function):
                             p.name, p.counter))
             print('};')
         elif self.marshal_flavor() in ('custom', 'async'):
-            print('struct marshal_cmd_{0};'.format(self.name))
+            print('{0};'.format(self.get_marshal_struct_name(is_packed)))
+
+        if not is_packed and self.packed_fixed_params:
+            self.print_struct(is_header, True)
+
+    def get_marshal_struct_name(self, is_packed=False):
+        return 'struct marshal_cmd_{0}{1}'.format(self.name, '_packed' if is_packed else '')
+
+    def print_unmarshal_prototype(self, is_packed=False, suffix=''):
+        print(('uint32_t _mesa_unmarshal_{0}{1}(struct gl_context *ctx, '
+               'const {2} *restrict cmd){3}')
+               .format(self.name, '_packed' if is_packed else '',
+                       self.get_marshal_struct_name(is_packed), suffix))
-- 
GitLab

