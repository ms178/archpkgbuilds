From dedf8bd2cc59608e184abed1b4326996633a88ad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 19 Jan 2023 19:57:02 -0500
Subject: [PATCH] glthread: fix an upload buffer leak

Fixes: befbd54864d29 - glthread: don't use atomics for refcounting to decrease overhead on AMD Zen
---
 src/mesa/main/glthread.c           |  1 +
 src/mesa/main/glthread.h           |  1 +
 src/mesa/main/glthread_bufferobj.c | 21 +++++++++++++++------
 3 files changed, 17 insertions(+), 6 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 2e2f2de9bcf9..af9da31e106c 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -189,6 +189,7 @@ _mesa_glthread_destroy(struct gl_context *ctx, const char *reason)
 
    _mesa_HashDeleteAll(glthread->VAOs, free_vao, NULL);
    _mesa_DeleteHashTable(glthread->VAOs);
+   _mesa_glthread_release_upload_buffer(ctx);
 
    ctx->GLThread.enabled = false;
    ctx->CurrentClientDispatch = ctx->CurrentServerDispatch;
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index f536865cb446..ce0faf69ca96 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -274,6 +274,7 @@ void _mesa_glthread_init_dispatch7(struct gl_context *ctx,
 void _mesa_glthread_flush_batch(struct gl_context *ctx);
 void _mesa_glthread_finish(struct gl_context *ctx);
 void _mesa_glthread_finish_before(struct gl_context *ctx, const char *func);
+void _mesa_glthread_release_upload_buffer(struct gl_context *ctx);
 void _mesa_glthread_upload(struct gl_context *ctx, const void *data,
                            GLsizeiptr size, unsigned *out_offset,
                            struct gl_buffer_object **out_buffer,
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index b21f3fd76f19..00d79942720e 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -62,6 +62,19 @@ new_upload_buffer(struct gl_context *ctx, GLsizeiptr size, uint8_t **ptr)
    return obj;
 }
 
+void
+_mesa_glthread_release_upload_buffer(struct gl_context *ctx)
+{
+   struct glthread_state *glthread = &ctx->GLThread;
+
+   if (glthread->upload_buffer_private_refcount > 0) {
+      p_atomic_add(&glthread->upload_buffer->RefCount,
+                   -glthread->upload_buffer_private_refcount);
+      glthread->upload_buffer_private_refcount = 0;
+   }
+   _mesa_reference_buffer_object(ctx, &glthread->upload_buffer, NULL);
+}
+
 void
 _mesa_glthread_upload(struct gl_context *ctx, const void *data,
                       GLsizeiptr size, unsigned *out_offset,
@@ -100,12 +113,8 @@ _mesa_glthread_upload(struct gl_context *ctx, const void *data,
          return;
       }
 
-      if (glthread->upload_buffer_private_refcount > 0) {
-         p_atomic_add(&glthread->upload_buffer->RefCount,
-                      -glthread->upload_buffer_private_refcount);
-         glthread->upload_buffer_private_refcount = 0;
-      }
-      _mesa_reference_buffer_object(ctx, &glthread->upload_buffer, NULL);
+      _mesa_glthread_release_upload_buffer(ctx);
+
       glthread->upload_buffer =
          new_upload_buffer(ctx, default_size, &glthread->upload_ptr);
       glthread->upload_offset = 0;
-- 
GitLab

