From 2aae7b72ac42677789b64c4af9b5e2ffa8523e85 Mon Sep 17 00:00:00 2001
From: Sergei Chernyadyev
 <28547-Cherser-s@users.noreply.gitlab.freedesktop.org>
Date: Wed, 26 Oct 2022 17:57:01 +0300
Subject: [PATCH 1/4] radv: moved blend translation functions to radv_private.h

---
 src/amd/vulkan/radv_pipeline.c | 160 --------------------------------
 src/amd/vulkan/radv_private.h  | 161 +++++++++++++++++++++++++++++++++
 2 files changed, 161 insertions(+), 160 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 8fe7b52465f7..78719a004be8 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -318,166 +318,6 @@ radv_pipeline_init_scratch(const struct radv_device *device, struct radv_pipelin
    pipeline->max_waves = max_waves;
 }
 
-static uint32_t
-si_translate_blend_function(VkBlendOp op)
-{
-   switch (op) {
-   case VK_BLEND_OP_ADD:
-      return V_028780_COMB_DST_PLUS_SRC;
-   case VK_BLEND_OP_SUBTRACT:
-      return V_028780_COMB_SRC_MINUS_DST;
-   case VK_BLEND_OP_REVERSE_SUBTRACT:
-      return V_028780_COMB_DST_MINUS_SRC;
-   case VK_BLEND_OP_MIN:
-      return V_028780_COMB_MIN_DST_SRC;
-   case VK_BLEND_OP_MAX:
-      return V_028780_COMB_MAX_DST_SRC;
-   default:
-      return 0;
-   }
-}
-
-static uint32_t
-si_translate_blend_factor(enum amd_gfx_level gfx_level, VkBlendFactor factor)
-{
-   switch (factor) {
-   case VK_BLEND_FACTOR_ZERO:
-      return V_028780_BLEND_ZERO;
-   case VK_BLEND_FACTOR_ONE:
-      return V_028780_BLEND_ONE;
-   case VK_BLEND_FACTOR_SRC_COLOR:
-      return V_028780_BLEND_SRC_COLOR;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
-      return V_028780_BLEND_ONE_MINUS_SRC_COLOR;
-   case VK_BLEND_FACTOR_DST_COLOR:
-      return V_028780_BLEND_DST_COLOR;
-   case VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:
-      return V_028780_BLEND_ONE_MINUS_DST_COLOR;
-   case VK_BLEND_FACTOR_SRC_ALPHA:
-      return V_028780_BLEND_SRC_ALPHA;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
-      return V_028780_BLEND_ONE_MINUS_SRC_ALPHA;
-   case VK_BLEND_FACTOR_DST_ALPHA:
-      return V_028780_BLEND_DST_ALPHA;
-   case VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:
-      return V_028780_BLEND_ONE_MINUS_DST_ALPHA;
-   case VK_BLEND_FACTOR_CONSTANT_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_COLOR_GFX11
-                                : V_028780_BLEND_CONSTANT_COLOR_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX11
-                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX6;
-   case VK_BLEND_FACTOR_CONSTANT_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_ALPHA_GFX11
-                                 : V_028780_BLEND_CONSTANT_ALPHA_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX11
-                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX6;
-   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
-      return V_028780_BLEND_SRC_ALPHA_SATURATE;
-   case VK_BLEND_FACTOR_SRC1_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_COLOR_GFX11 : V_028780_BLEND_SRC1_COLOR_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_COLOR_GFX11
-                                 : V_028780_BLEND_INV_SRC1_COLOR_GFX6;
-   case VK_BLEND_FACTOR_SRC1_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_ALPHA_GFX11 : V_028780_BLEND_SRC1_ALPHA_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_ALPHA_GFX11
-                                 : V_028780_BLEND_INV_SRC1_ALPHA_GFX6;
-   default:
-      return 0;
-   }
-}
-
-static uint32_t
-si_translate_blend_opt_function(VkBlendOp op)
-{
-   switch (op) {
-   case VK_BLEND_OP_ADD:
-      return V_028760_OPT_COMB_ADD;
-   case VK_BLEND_OP_SUBTRACT:
-      return V_028760_OPT_COMB_SUBTRACT;
-   case VK_BLEND_OP_REVERSE_SUBTRACT:
-      return V_028760_OPT_COMB_REVSUBTRACT;
-   case VK_BLEND_OP_MIN:
-      return V_028760_OPT_COMB_MIN;
-   case VK_BLEND_OP_MAX:
-      return V_028760_OPT_COMB_MAX;
-   default:
-      return V_028760_OPT_COMB_BLEND_DISABLED;
-   }
-}
-
-static uint32_t
-si_translate_blend_opt_factor(VkBlendFactor factor, bool is_alpha)
-{
-   switch (factor) {
-   case VK_BLEND_FACTOR_ZERO:
-      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_ALL;
-   case VK_BLEND_FACTOR_ONE:
-      return V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE;
-   case VK_BLEND_FACTOR_SRC_COLOR:
-      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0
-                      : V_028760_BLEND_OPT_PRESERVE_C1_IGNORE_C0;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
-      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1
-                      : V_028760_BLEND_OPT_PRESERVE_C0_IGNORE_C1;
-   case VK_BLEND_FACTOR_SRC_ALPHA:
-      return V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
-      return V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1;
-   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
-      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE
-                      : V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
-   default:
-      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
-   }
-}
-
-/**
- * Get rid of DST in the blend factors by commuting the operands:
- *    func(src * DST, dst * 0) ---> func(src * 0, dst * SRC)
- */
-static void
-si_blend_remove_dst(VkBlendOp *func, VkBlendFactor *src_factor, VkBlendFactor *dst_factor,
-                    VkBlendFactor expected_dst, VkBlendFactor replacement_src)
-{
-   if (*src_factor == expected_dst && *dst_factor == VK_BLEND_FACTOR_ZERO) {
-      *src_factor = VK_BLEND_FACTOR_ZERO;
-      *dst_factor = replacement_src;
-
-      /* Commuting the operands requires reversing subtractions. */
-      if (*func == VK_BLEND_OP_SUBTRACT)
-         *func = VK_BLEND_OP_REVERSE_SUBTRACT;
-      else if (*func == VK_BLEND_OP_REVERSE_SUBTRACT)
-         *func = VK_BLEND_OP_SUBTRACT;
-   }
-}
-
-static bool
-si_blend_factor_uses_dst(VkBlendFactor factor)
-{
-   return factor == VK_BLEND_FACTOR_DST_COLOR || factor == VK_BLEND_FACTOR_DST_ALPHA ||
-          factor == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE ||
-          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA ||
-          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
-}
-
-static bool
-is_dual_src(VkBlendFactor factor)
-{
-   switch (factor) {
-   case VK_BLEND_FACTOR_SRC1_COLOR:
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
-   case VK_BLEND_FACTOR_SRC1_ALPHA:
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
-      return true;
-   default:
-      return false;
-   }
-}
-
 static unsigned
 radv_choose_spi_color_format(const struct radv_device *device, VkFormat vk_format,
                              bool blend_enable, bool blend_need_alpha)
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 56efccf62559..d16ae33666a4 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2990,6 +2990,167 @@ si_translate_prim(unsigned topology)
    }
 }
 
+
+static inline uint32_t
+si_translate_blend_function(VkBlendOp op)
+{
+   switch (op) {
+   case VK_BLEND_OP_ADD:
+      return V_028780_COMB_DST_PLUS_SRC;
+   case VK_BLEND_OP_SUBTRACT:
+      return V_028780_COMB_SRC_MINUS_DST;
+   case VK_BLEND_OP_REVERSE_SUBTRACT:
+      return V_028780_COMB_DST_MINUS_SRC;
+   case VK_BLEND_OP_MIN:
+      return V_028780_COMB_MIN_DST_SRC;
+   case VK_BLEND_OP_MAX:
+      return V_028780_COMB_MAX_DST_SRC;
+   default:
+      return 0;
+   }
+}
+
+static uint32_t
+si_translate_blend_factor(enum amd_gfx_level gfx_level, VkBlendFactor factor)
+{
+   switch (factor) {
+   case VK_BLEND_FACTOR_ZERO:
+      return V_028780_BLEND_ZERO;
+   case VK_BLEND_FACTOR_ONE:
+      return V_028780_BLEND_ONE;
+   case VK_BLEND_FACTOR_SRC_COLOR:
+      return V_028780_BLEND_SRC_COLOR;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
+      return V_028780_BLEND_ONE_MINUS_SRC_COLOR;
+   case VK_BLEND_FACTOR_DST_COLOR:
+      return V_028780_BLEND_DST_COLOR;
+   case VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:
+      return V_028780_BLEND_ONE_MINUS_DST_COLOR;
+   case VK_BLEND_FACTOR_SRC_ALPHA:
+      return V_028780_BLEND_SRC_ALPHA;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
+      return V_028780_BLEND_ONE_MINUS_SRC_ALPHA;
+   case VK_BLEND_FACTOR_DST_ALPHA:
+      return V_028780_BLEND_DST_ALPHA;
+   case VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:
+      return V_028780_BLEND_ONE_MINUS_DST_ALPHA;
+   case VK_BLEND_FACTOR_CONSTANT_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_COLOR_GFX11
+                                : V_028780_BLEND_CONSTANT_COLOR_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX11
+                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX6;
+   case VK_BLEND_FACTOR_CONSTANT_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_ALPHA_GFX11
+                                 : V_028780_BLEND_CONSTANT_ALPHA_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX11
+                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX6;
+   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
+      return V_028780_BLEND_SRC_ALPHA_SATURATE;
+   case VK_BLEND_FACTOR_SRC1_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_COLOR_GFX11 : V_028780_BLEND_SRC1_COLOR_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_COLOR_GFX11
+                                 : V_028780_BLEND_INV_SRC1_COLOR_GFX6;
+   case VK_BLEND_FACTOR_SRC1_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_ALPHA_GFX11 : V_028780_BLEND_SRC1_ALPHA_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_ALPHA_GFX11
+                                 : V_028780_BLEND_INV_SRC1_ALPHA_GFX6;
+   default:
+      return 0;
+   }
+}
+
+static uint32_t
+si_translate_blend_opt_function(VkBlendOp op)
+{
+   switch (op) {
+   case VK_BLEND_OP_ADD:
+      return V_028760_OPT_COMB_ADD;
+   case VK_BLEND_OP_SUBTRACT:
+      return V_028760_OPT_COMB_SUBTRACT;
+   case VK_BLEND_OP_REVERSE_SUBTRACT:
+      return V_028760_OPT_COMB_REVSUBTRACT;
+   case VK_BLEND_OP_MIN:
+      return V_028760_OPT_COMB_MIN;
+   case VK_BLEND_OP_MAX:
+      return V_028760_OPT_COMB_MAX;
+   default:
+      return V_028760_OPT_COMB_BLEND_DISABLED;
+   }
+}
+
+static inline bool
+si_blend_factor_uses_dst(VkBlendFactor factor)
+{
+   return factor == VK_BLEND_FACTOR_DST_COLOR || factor == VK_BLEND_FACTOR_DST_ALPHA ||
+          factor == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE ||
+          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA ||
+          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
+}
+
+static inline bool
+is_dual_src(VkBlendFactor factor)
+{
+   switch (factor) {
+   case VK_BLEND_FACTOR_SRC1_COLOR:
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
+   case VK_BLEND_FACTOR_SRC1_ALPHA:
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
+      return true;
+   default:
+      return false;
+   }
+}
+
+static inline uint32_t
+si_translate_blend_opt_factor(VkBlendFactor factor, bool is_alpha)
+{
+   switch (factor) {
+   case VK_BLEND_FACTOR_ZERO:
+      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_ALL;
+   case VK_BLEND_FACTOR_ONE:
+      return V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE;
+   case VK_BLEND_FACTOR_SRC_COLOR:
+      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0
+                      : V_028760_BLEND_OPT_PRESERVE_C1_IGNORE_C0;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
+      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1
+                      : V_028760_BLEND_OPT_PRESERVE_C0_IGNORE_C1;
+   case VK_BLEND_FACTOR_SRC_ALPHA:
+      return V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
+      return V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1;
+   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
+      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE
+                      : V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
+   default:
+      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
+   }
+}
+
+/**
+ * Get rid of DST in the blend factors by commuting the operands:
+ *    func(src * DST, dst * 0) ---> func(src * 0, dst * SRC)
+ */
+static inline void
+si_blend_remove_dst(VkBlendOp *func, VkBlendFactor *src_factor, VkBlendFactor *dst_factor,
+                    VkBlendFactor expected_dst, VkBlendFactor replacement_src)
+{
+   if (*src_factor == expected_dst && *dst_factor == VK_BLEND_FACTOR_ZERO) {
+      *src_factor = VK_BLEND_FACTOR_ZERO;
+      *dst_factor = replacement_src;
+
+      /* Commuting the operands requires reversing subtractions. */
+      if (*func == VK_BLEND_OP_SUBTRACT)
+         *func = VK_BLEND_OP_REVERSE_SUBTRACT;
+      else if (*func == VK_BLEND_OP_REVERSE_SUBTRACT)
+         *func = VK_BLEND_OP_SUBTRACT;
+   }
+}
+
 static inline bool
 radv_prim_is_points_or_lines(unsigned topology)
 {
-- 
GitLab


From 8170f2e8e5df4becb72c9f12bb12567f1e4b3451 Mon Sep 17 00:00:00 2001
From: Sergei Chernyadyev
 <28547-Cherser-s@users.noreply.gitlab.freedesktop.org>
Date: Sun, 30 Oct 2022 23:13:51 +0300
Subject: [PATCH 2/4] radv: rename mrt0_is_dual_src to mrt0_may_be_dual_src for
 radv_pipeline_key due to dynamic blend equation

---
 src/amd/vulkan/radv_nir_to_llvm.c | 4 ++--
 src/amd/vulkan/radv_pipeline.c    | 4 ++--
 src/amd/vulkan/radv_shader.h      | 2 +-
 3 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 1ca2a31f0684..0df49dc2f0fd 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -1044,7 +1044,7 @@ si_export_mrt_color(struct radv_shader_context *ctx, LLVMValueRef *color, unsign
 {
    unsigned mrt_target = V_008DFC_SQ_EXP_MRT + target;
 
-   if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.mrt0_is_dual_src &&
+   if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.mrt0_may_be_dual_src &&
        (target == 0 || target == 1)) {
       mrt_target += 21;
    }
@@ -1113,7 +1113,7 @@ handle_fs_outputs_post(struct radv_shader_context *ctx)
       color_args[last].valid_mask = 1; /* whether the EXEC mask is valid */
       color_args[last].done = 1;       /* DONE bit */
 
-      if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.mrt0_is_dual_src) {
+      if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.mrt0_may_be_dual_src) {
          ac_build_dual_src_blend_swizzle(&ctx->ac, &color_args[0], &color_args[1]);
       }
    }
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 78719a004be8..068b4b8e2462 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2136,7 +2136,7 @@ radv_remove_color_exports(const struct radv_pipeline_key *pipeline_key, nir_shad
 
       if (col_format == V_028714_SPI_SHADER_ZERO ||
           (col_format == V_028714_SPI_SHADER_32_R && !cb_target_mask &&
-           !pipeline_key->ps.mrt0_is_dual_src)) {
+           !pipeline_key->ps.mrt0_may_be_dual_src)) {
          /* Remove the color export if it's unused or in presence of holes. */
          nir->info.outputs_written &= ~BITFIELD64_BIT(var->data.location);
          var->data.location = 0;
@@ -2674,7 +2674,7 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
 
    key.ps.col_format = blend->spi_shader_col_format;
    key.ps.cb_target_mask = blend->cb_target_mask;
-   key.ps.mrt0_is_dual_src = blend->mrt0_is_dual_src;
+   key.ps.mrt0_may_be_dual_src = blend->mrt0_is_dual_src;
    if (device->physical_device->rad_info.gfx_level < GFX8) {
       key.ps.is_int8 = blend->col_format_is_int8;
       key.ps.is_int10 = blend->col_format_is_int10;
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index a0d75fd96f3b..d3c86d4caec0 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -89,7 +89,7 @@ struct radv_pipeline_key {
       uint32_t cb_target_mask;
       uint8_t log2_ps_iter_samples;
       uint8_t num_samples;
-      bool mrt0_is_dual_src;
+      bool mrt0_may_be_dual_src;
 
       bool lower_discard_to_demote;
       uint8_t enable_mrt_output_nan_fixup;
-- 
GitLab


From 225b9fe928b32d21c576a647585c17bb281b28c5 Mon Sep 17 00:00:00 2001
From: Sergei Chernyadyev
 <28547-Cherser-s@users.noreply.gitlab.freedesktop.org>
Date: Sun, 30 Oct 2022 23:14:52 +0300
Subject: [PATCH 3/4] radv: add support for dynamic blend enable and dynamic
 blend equation

---
 src/amd/vulkan/radv_cmd_buffer.c | 209 ++++++++++++++++++++++++++++++-
 src/amd/vulkan/radv_device.c     |   4 +-
 src/amd/vulkan/radv_pipeline.c   | 176 ++++++++++++--------------
 src/amd/vulkan/radv_private.h    |  47 +++++--
 4 files changed, 328 insertions(+), 108 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ab72186155e9..f7dae33573c2 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -133,6 +133,11 @@ const struct radv_dynamic_state default_dynamic_state = {
    .depth_clip_negative_one_to_one = 0u,
    .provoking_vertex_mode = VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
    .depth_clamp_enable = 0u,
+   .color_blend_enable = {false, false, false, false, false, false, false, false},
+   .color_blend_equations =
+      {
+         { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }
+      },
 };
 
 static void
@@ -202,6 +207,19 @@ radv_bind_dynamic_state(struct radv_cmd_buffer *cmd_buffer, const struct radv_dy
       }
    }
 
+   if (copy_mask & RADV_DYNAMIC_BLEND_ENABLE) {
+      if (memcmp(dest->color_blend_enable, src->color_blend_enable, sizeof(src->color_blend_enable))) {
+         typed_memcpy(dest->color_blend_enable, src->color_blend_enable, 8);
+         dest_mask |= RADV_DYNAMIC_BLEND_ENABLE;
+      }
+   }
+
+   if (copy_mask & RADV_DYNAMIC_BLEND_EQUATION) {
+      if (memcmp(dest->color_blend_equations, src->color_blend_equations, sizeof(src->color_blend_equations))) {
+         typed_memcpy(dest->color_blend_equations, src->color_blend_equations, 8);
+         dest_mask |= RADV_DYNAMIC_BLEND_EQUATION;
+      }
+   }
 #define RADV_CMP_COPY(field, flag)                                \
    if (copy_mask & flag) {                                        \
       if (dest->field != src->field) {                            \
@@ -1520,6 +1538,11 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
        cmd_buffer->state.emitted_graphics_pipeline->ms.db_eqaa != pipeline->ms.db_eqaa)
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE;
 
+   if (!cmd_buffer->state.emitted_graphics_pipeline ||
+       cmd_buffer->state.emitted_graphics_pipeline->spi_shader_col_format != pipeline->spi_shader_col_format ||
+       cmd_buffer->state.emitted_graphics_pipeline->cb_shader_mask != pipeline->cb_shader_mask)
+      cmd_buffer->state.dirty |= (RADV_CMD_DIRTY_DYNAMIC_BLEND_ENABLE | RADV_CMD_DIRTY_DYNAMIC_BLEND_EQUATION);
+
    radeon_emit_array(cmd_buffer->cs, pipeline->base.cs.buf, pipeline->base.cs.cdw);
 
    if (pipeline->has_ngg_culling &&
@@ -1948,7 +1971,15 @@ radv_emit_logic_op(struct radv_cmd_buffer *cmd_buffer)
    }
 
    if (cmd_buffer->device->physical_device->rad_info.has_rbplus) {
-      cb_color_control |= S_028808_DISABLE_DUAL_QUAD(d->logic_op_enable);
+      bool disable_dual_quad = d->logic_op_enable;
+      if (!d->logic_op_enable
+          && (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)
+          && cmd_buffer->state.render.color_att_count > 0) {
+         if (radv_can_enable_dual_src(&d->color_blend_equations[0]))
+            disable_dual_quad = true;
+      }
+
+      cb_color_control |= S_028808_DISABLE_DUAL_QUAD(disable_dual_quad);
    }
 
    radeon_set_context_reg(cmd_buffer->cs, R_028808_CB_COLOR_CONTROL, cb_color_control);
@@ -2073,6 +2104,146 @@ radv_emit_depth_clamp_enable(struct radv_cmd_buffer *cmd_buffer)
                           S_02800C_DISABLE_VIEWPORT_CLAMP(mode == RADV_DEPTH_CLAMP_MODE_DISABLED));
 }
 
+static void
+radv_emit_blend_state(struct radv_cmd_buffer *cmd_buffer)
+{
+   const struct radv_physical_device *pdevice = cmd_buffer->device->physical_device;
+   struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+   const enum amd_gfx_level gfx_level = pdevice->rad_info.gfx_level;
+
+   uint32_t sx_mrt_blend_opt[8];
+   uint32_t cb_blend_control[8];
+   uint32_t spi_shader_col_format = pipeline->spi_shader_col_format;
+   uint32_t cb_shader_mask = pipeline->cb_shader_mask;
+   bool mrt0_is_dual_src = false;
+
+   int i;
+   for (i = 0; i < cmd_buffer->state.render.color_att_count; i++) {
+      unsigned blend_cntl = 0;
+      unsigned srcRGB_opt, dstRGB_opt, srcA_opt, dstA_opt;
+      VkBlendOp eqRGB = d->color_blend_equations[i].colorBlendOp;
+      VkBlendFactor srcRGB = d->color_blend_equations[i].srcColorBlendFactor;
+      VkBlendFactor dstRGB = d->color_blend_equations[i].dstColorBlendFactor;
+      VkBlendOp eqA = d->color_blend_equations[i].alphaBlendOp;
+      VkBlendFactor srcA = d->color_blend_equations[i].srcAlphaBlendFactor;
+      VkBlendFactor dstA = d->color_blend_equations[i].dstAlphaBlendFactor;
+
+      sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED) |
+         S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED);
+
+      /* Ignore other blend targets if dual-source blending
+       * is enabled to prevent wrong behaviour.
+       */
+      if (mrt0_is_dual_src)
+         continue;
+
+      if (!d->color_blend_enable[i]) {
+         cb_blend_control[i] = blend_cntl;
+         continue;
+      }
+
+      if (i == 0 && radv_can_enable_dual_src(&d->color_blend_equations[i]))
+         mrt0_is_dual_src = true;
+
+      if (eqRGB == VK_BLEND_OP_MIN || eqRGB == VK_BLEND_OP_MAX) {
+         srcRGB = VK_BLEND_FACTOR_ONE;
+         dstRGB = VK_BLEND_FACTOR_ONE;
+      }
+      if (eqA == VK_BLEND_OP_MIN || eqA == VK_BLEND_OP_MAX) {
+         srcA = VK_BLEND_FACTOR_ONE;
+         dstA = VK_BLEND_FACTOR_ONE;
+      }
+
+      /* Blending optimizations for RB+.
+       * These transformations don't change the behavior.
+       *
+       * First, get rid of DST in the blend factors:
+       *    func(src * DST, dst * 0) ---> func(src * 0, dst * SRC)
+       */
+      si_blend_remove_dst(&eqRGB, &srcRGB, &dstRGB, VK_BLEND_FACTOR_DST_COLOR,
+                          VK_BLEND_FACTOR_SRC_COLOR);
+
+      si_blend_remove_dst(&eqA, &srcA, &dstA, VK_BLEND_FACTOR_DST_COLOR,
+                          VK_BLEND_FACTOR_SRC_COLOR);
+
+      si_blend_remove_dst(&eqA, &srcA, &dstA, VK_BLEND_FACTOR_DST_ALPHA,
+                          VK_BLEND_FACTOR_SRC_ALPHA);
+
+      /* Look up the ideal settings from tables. */
+      srcRGB_opt = si_translate_blend_opt_factor(srcRGB, false);
+      dstRGB_opt = si_translate_blend_opt_factor(dstRGB, false);
+      srcA_opt = si_translate_blend_opt_factor(srcA, true);
+      dstA_opt = si_translate_blend_opt_factor(dstA, true);
+
+      /* Handle interdependencies. */
+      if (si_blend_factor_uses_dst(srcRGB))
+         dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
+      if (si_blend_factor_uses_dst(srcA))
+         dstA_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
+
+      if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE &&
+          (dstRGB == VK_BLEND_FACTOR_ZERO || dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
+           dstRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE))
+         dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
+
+      /* Set the final value. */
+      sx_mrt_blend_opt[i] =
+         S_028760_COLOR_SRC_OPT(srcRGB_opt) | S_028760_COLOR_DST_OPT(dstRGB_opt) |
+         S_028760_COLOR_COMB_FCN(si_translate_blend_opt_function(eqRGB)) |
+         S_028760_ALPHA_SRC_OPT(srcA_opt) | S_028760_ALPHA_DST_OPT(dstA_opt) |
+         S_028760_ALPHA_COMB_FCN(si_translate_blend_opt_function(eqA));
+      blend_cntl |= S_028780_ENABLE(1);
+
+      blend_cntl |= S_028780_COLOR_COMB_FCN(si_translate_blend_function(eqRGB));
+      blend_cntl |= S_028780_COLOR_SRCBLEND(si_translate_blend_factor(gfx_level, srcRGB));
+      blend_cntl |= S_028780_COLOR_DESTBLEND(si_translate_blend_factor(gfx_level, dstRGB));
+      if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB) {
+         blend_cntl |= S_028780_SEPARATE_ALPHA_BLEND(1);
+         blend_cntl |= S_028780_ALPHA_COMB_FCN(si_translate_blend_function(eqA));
+         blend_cntl |= S_028780_ALPHA_SRCBLEND(si_translate_blend_factor(gfx_level, srcA));
+         blend_cntl |= S_028780_ALPHA_DESTBLEND(si_translate_blend_factor(gfx_level, dstA));
+      }
+      cb_blend_control[i] = blend_cntl;
+   }
+   for (i = cmd_buffer->state.render.color_att_count; i < 8; i++) {
+      cb_blend_control[i] = 0;
+      sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED) |
+         S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED);
+   }
+
+   if (pdevice->rad_info.has_rbplus && mrt0_is_dual_src) {
+      /* Disable RB+ blend optimizations for dual source blending. */
+      for (i = 0; i < 8; i++) {
+         sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_NONE) |
+            S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_NONE);
+      }
+   }
+
+   /* The output for dual source blending should have the same format as
+    * the first output.
+    */
+   if (mrt0_is_dual_src) {
+      assert(!(spi_shader_col_format >> 4));
+      spi_shader_col_format |= (spi_shader_col_format & 0xf) << 4;
+      /* no extra modes are being used here, so it is safe to copy flags around */
+      cb_shader_mask |= (cb_shader_mask & 0xf) << 4;
+   }
+
+   radeon_set_context_reg_seq(cmd_buffer->cs, R_028780_CB_BLEND0_CONTROL, 8);
+   radeon_emit_array(cmd_buffer->cs, cb_blend_control, 8);
+
+   if (pdevice->rad_info.has_rbplus) {
+
+      radeon_set_context_reg_seq(cmd_buffer->cs, R_028760_SX_MRT0_BLEND_OPT, 8);
+      radeon_emit_array(cmd_buffer->cs, sx_mrt_blend_opt, 8);
+   }
+
+   radeon_set_context_reg(cmd_buffer->cs, R_028714_SPI_SHADER_COL_FORMAT, spi_shader_col_format);
+
+   radeon_set_context_reg(cmd_buffer->cs, R_02823C_CB_SHADER_MASK, cb_shader_mask);
+}
+
 static void
 radv_emit_fb_color_state(struct radv_cmd_buffer *cmd_buffer, int index,
                          struct radv_color_buffer_info *cb, struct radv_image_view *iview,
@@ -3563,7 +3734,9 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE))
       radv_emit_clipping(cmd_buffer);
 
-   if (states & (RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP | RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP_ENABLE))
+   if ((states & (RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP | RADV_CMD_DIRTY_DYNAMIC_LOGIC_OP_ENABLE)) ||
+       /* emit logic op in the case if blend equation is dynamic, since DISABLE_DUAL_QUAD may be not handled yet */
+       ((states & RADV_CMD_DIRTY_DYNAMIC_BLEND_EQUATION) && (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)))
       radv_emit_logic_op(cmd_buffer);
 
    if (states & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE)
@@ -3590,6 +3763,9 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (states & RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLAMP_ENABLE)
       radv_emit_depth_clamp_enable(cmd_buffer);
 
+   if (states & (RADV_CMD_DIRTY_DYNAMIC_BLEND_ENABLE | RADV_CMD_DIRTY_DYNAMIC_BLEND_EQUATION))
+      radv_emit_blend_state(cmd_buffer);
+
    cmd_buffer->state.dirty &= ~states;
 }
 
@@ -6114,6 +6290,35 @@ radv_CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClam
    state->dirty |= RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLAMP_ENABLE;
 }
 
+VKAPI_ATTR void VKAPI_CALL
+radv_CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
+    uint32_t attachmentCount, const VkBool32* pColorBlendEnables)
+{
+   RADV_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+   struct radv_cmd_state *state = &cmd_buffer->state;
+
+   assert((firstAttachment + attachmentCount) <= MAX_RTS);
+
+   int i;
+   for (i = 0; i < attachmentCount; i++) {
+      state->dynamic.color_blend_enable[firstAttachment + i] = pColorBlendEnables[i];
+   }
+   state->dirty |= RADV_CMD_DIRTY_DYNAMIC_BLEND_ENABLE;
+}
+
+VKAPI_ATTR void VKAPI_CALL
+radv_CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
+    uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations)
+{
+   RADV_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+   struct radv_cmd_state *state = &cmd_buffer->state;
+
+   assert((firstAttachment + attachmentCount) <= MAX_RTS);
+
+   typed_memcpy(&state->dynamic.color_blend_equations[firstAttachment], pColorBlendEquations, attachmentCount);
+   state->dirty |= RADV_CMD_DIRTY_DYNAMIC_BLEND_EQUATION;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                         const VkCommandBuffer *pCmdBuffers)
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 7c44781ad6f1..ae676edbefaa 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1885,7 +1885,7 @@ radv_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
          features->extendedDynamicState3AlphaToCoverageEnable = pdevice->rad_info.gfx_level < GFX11;
          features->extendedDynamicState3LogicOpEnable = true;
          features->extendedDynamicState3LineStippleEnable = true;
-         features->extendedDynamicState3ColorBlendEnable = false; /* TODO: Zink */
+         features->extendedDynamicState3ColorBlendEnable = true;
          features->extendedDynamicState3DepthClipEnable = true;
          features->extendedDynamicState3ConservativeRasterizationMode = true;
          features->extendedDynamicState3DepthClipNegativeOneToOne = true;
@@ -1893,7 +1893,7 @@ radv_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
          features->extendedDynamicState3DepthClampEnable = true;
          features->extendedDynamicState3ColorWriteMask = false; /* TODO: Zink */
          features->extendedDynamicState3RasterizationSamples = false; /* TODO: Zink */
-         features->extendedDynamicState3ColorBlendEquation = false; /* TODO: Zink */
+         features->extendedDynamicState3ColorBlendEquation = true;
          features->extendedDynamicState3SampleLocationsEnable = false; /* TODO: Zink */
          features->extendedDynamicState3LineRasterizationMode = false; /* TODO: Zink */
          features->extendedDynamicState3ExtraPrimitiveOverestimationSize = false;
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 068b4b8e2462..f496324e9836 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -55,8 +55,6 @@ struct radv_blend_state {
 
    uint32_t cb_target_mask;
    uint32_t cb_target_enabled_4bit;
-   uint32_t sx_mrt_blend_opt[8];
-   uint32_t cb_blend_control[8];
 
    uint32_t spi_shader_col_format;
    uint32_t col_format_is_int8;
@@ -458,14 +456,6 @@ radv_pipeline_compute_spi_color_formats(const struct radv_graphics_pipeline *pip
       }
    }
 
-   /* The output for dual source blending should have the same format as
-    * the first output.
-    */
-   if (blend->mrt0_is_dual_src) {
-      assert(!(col_format >> 4));
-      col_format |= (col_format & 0xf) << 4;
-   }
-
    blend->cb_shader_mask = ac_get_cb_shader_mask(col_format);
    blend->spi_shader_col_format = col_format;
    blend->col_format_is_int8 = is_int8;
@@ -545,7 +535,7 @@ radv_blend_check_commutativity(struct radv_blend_state *blend, VkBlendOp op, VkB
 }
 
 static bool
-radv_can_enable_dual_src(const struct vk_color_blend_attachment_state *att)
+radv_can_enable_dual_src_attachment(const struct vk_color_blend_attachment_state *att)
 {
    VkBlendOp eqRGB = att->color_blend_op;
    VkBlendFactor srcRGB = att->src_color_blend_factor;
@@ -573,7 +563,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    const struct radv_device *device = pipeline->base.device;
    struct radv_blend_state blend = {0};
    unsigned cb_color_control = 0;
-   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
    int i;
 
    if (state->ms && ((pipeline->dynamic_states & RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE) ||
@@ -586,10 +575,26 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    }
 
    blend.cb_target_mask = 0;
-   if (state->cb) {
+
+   if (state->cb && (pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)) {
+      /* When dynamic blending is enabled, the driver needs to select a color export format with
+       * alpha. When this state is dynamic, always select a format with alpha because it's hard to
+       * change color export formats dynamically (note that it's suboptimal).
+       */
+      blend.need_src_alpha = ~0;
+      for (i = 0; i < state->cb->attachment_count; ++i) {
+         if (!state->cb->attachments[i].write_mask)
+            continue;
+         blend.cb_target_mask |= (unsigned)state->cb->attachments[i].write_mask << (4 * i);
+         blend.cb_target_enabled_4bit |= 0xfu << (4 * i);
+         blend.need_src_alpha |= 1 << i;
+
+         if ((pipeline->dynamic_states & RADV_DYNAMIC_BLEND_ENABLE) || state->cb->attachments[i].blend_enable) {
+            blend.blend_enable_4bit |= 0xfu << (i * 4);
+         }
+      }
+   } else if (state->cb && !(pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)) {
       for (i = 0; i < state->cb->attachment_count; i++) {
-         unsigned blend_cntl = 0;
-         unsigned srcRGB_opt, dstRGB_opt, srcA_opt, dstA_opt;
          VkBlendOp eqRGB = state->cb->attachments[i].color_blend_op;
          VkBlendFactor srcRGB = state->cb->attachments[i].src_color_blend_factor;
          VkBlendFactor dstRGB = state->cb->attachments[i].dst_color_blend_factor;
@@ -597,9 +602,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
          VkBlendFactor srcA = state->cb->attachments[i].src_alpha_blend_factor;
          VkBlendFactor dstA = state->cb->attachments[i].dst_alpha_blend_factor;
 
-         blend.sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED) |
-                                     S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED);
-
          if (!state->cb->attachments[i].write_mask)
             continue;
 
@@ -611,12 +613,11 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
 
          blend.cb_target_mask |= (unsigned)state->cb->attachments[i].write_mask << (4 * i);
          blend.cb_target_enabled_4bit |= 0xfu << (4 * i);
-         if (!state->cb->attachments[i].blend_enable) {
-            blend.cb_blend_control[i] = blend_cntl;
+         if (!state->cb->attachments[i].blend_enable && !(pipeline->dynamic_states & RADV_DYNAMIC_BLEND_ENABLE)) {
             continue;
          }
 
-         if (i == 0 && radv_can_enable_dual_src(&state->cb->attachments[i])) {
+         if (i == 0 && radv_can_enable_dual_src_attachment(&state->cb->attachments[i])) {
             blend.mrt0_is_dual_src = true;
          }
 
@@ -647,42 +648,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
          si_blend_remove_dst(&eqA, &srcA, &dstA, VK_BLEND_FACTOR_DST_ALPHA,
                              VK_BLEND_FACTOR_SRC_ALPHA);
 
-         /* Look up the ideal settings from tables. */
-         srcRGB_opt = si_translate_blend_opt_factor(srcRGB, false);
-         dstRGB_opt = si_translate_blend_opt_factor(dstRGB, false);
-         srcA_opt = si_translate_blend_opt_factor(srcA, true);
-         dstA_opt = si_translate_blend_opt_factor(dstA, true);
-
-         /* Handle interdependencies. */
-         if (si_blend_factor_uses_dst(srcRGB))
-            dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
-         if (si_blend_factor_uses_dst(srcA))
-            dstA_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
-
-         if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE &&
-             (dstRGB == VK_BLEND_FACTOR_ZERO || dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
-              dstRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE))
-            dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
-
-         /* Set the final value. */
-         blend.sx_mrt_blend_opt[i] =
-            S_028760_COLOR_SRC_OPT(srcRGB_opt) | S_028760_COLOR_DST_OPT(dstRGB_opt) |
-            S_028760_COLOR_COMB_FCN(si_translate_blend_opt_function(eqRGB)) |
-            S_028760_ALPHA_SRC_OPT(srcA_opt) | S_028760_ALPHA_DST_OPT(dstA_opt) |
-            S_028760_ALPHA_COMB_FCN(si_translate_blend_opt_function(eqA));
-         blend_cntl |= S_028780_ENABLE(1);
-
-         blend_cntl |= S_028780_COLOR_COMB_FCN(si_translate_blend_function(eqRGB));
-         blend_cntl |= S_028780_COLOR_SRCBLEND(si_translate_blend_factor(gfx_level, srcRGB));
-         blend_cntl |= S_028780_COLOR_DESTBLEND(si_translate_blend_factor(gfx_level, dstRGB));
-         if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB) {
-            blend_cntl |= S_028780_SEPARATE_ALPHA_BLEND(1);
-            blend_cntl |= S_028780_ALPHA_COMB_FCN(si_translate_blend_function(eqA));
-            blend_cntl |= S_028780_ALPHA_SRCBLEND(si_translate_blend_factor(gfx_level, srcA));
-            blend_cntl |= S_028780_ALPHA_DESTBLEND(si_translate_blend_factor(gfx_level, dstA));
-         }
-         blend.cb_blend_control[i] = blend_cntl;
-
          blend.blend_enable_4bit |= 0xfu << (i * 4);
 
          if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA || dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
@@ -692,22 +657,9 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
              dstRGB == VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA)
             blend.need_src_alpha |= 1 << i;
       }
-      for (i = state->cb->attachment_count; i < 8; i++) {
-         blend.cb_blend_control[i] = 0;
-         blend.sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED) |
-                                     S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED);
-      }
    }
 
    if (device->physical_device->rad_info.has_rbplus) {
-      /* Disable RB+ blend optimizations for dual source blending. */
-      if (blend.mrt0_is_dual_src) {
-         for (i = 0; i < 8; i++) {
-            blend.sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_NONE) |
-                                        S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_NONE);
-         }
-      }
-
       /* RB+ doesn't work with dual source blending, logic op and
        * RESOLVE.
        */
@@ -915,6 +867,10 @@ radv_pipeline_out_of_order_rast(struct radv_graphics_pipeline *pipeline,
    unsigned blendmask = colormask & blend->blend_enable_4bit;
 
    if (blendmask) {
+      /* No out of order when there is dynamic blend equation being used. */
+      if (pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)
+         return false;
+
       /* Only commutative blending. */
       if (blendmask & ~blend->commutative_4bit)
          return false;
@@ -1185,6 +1141,10 @@ radv_dynamic_state_mask(VkDynamicState state)
       return RADV_DYNAMIC_PROVOKING_VERTEX_MODE;
    case VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT:
       return RADV_DYNAMIC_DEPTH_CLAMP_ENABLE;
+   case VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT:
+      return RADV_DYNAMIC_BLEND_ENABLE;
+   case VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT:
+      return RADV_DYNAMIC_BLEND_EQUATION;
    default:
       unreachable("Unhandled dynamic state");
    }
@@ -1260,7 +1220,7 @@ radv_pipeline_needed_dynamic_state(const struct radv_graphics_pipeline *pipeline
    if (!radv_is_vrs_enabled(pipeline, state))
       states &= ~RADV_DYNAMIC_FRAGMENT_SHADING_RATE;
 
-   if (!has_color_att || !radv_pipeline_is_blend_enabled(pipeline, state->cb))
+   if (!has_color_att || (!radv_pipeline_is_blend_enabled(pipeline, state->cb) && !(pipeline->dynamic_states & (RADV_DYNAMIC_BLEND_ENABLE | RADV_DYNAMIC_BLEND_EQUATION))))
       states &= ~RADV_DYNAMIC_BLEND_CONSTANTS;
 
    if (!has_color_att)
@@ -1765,6 +1725,29 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
       dynamic->depth_clamp_enable = state->rs->depth_clamp_enable;
    }
 
+   if (states & (RADV_DYNAMIC_BLEND_EQUATION)) {
+      if (state->cb) {
+         for (int i = 0; i < state->cb->attachment_count; i++)
+            dynamic->color_blend_equations[i] = (VkColorBlendEquationEXT) {
+               .srcColorBlendFactor = state->cb->attachments[i].src_color_blend_factor,
+               .dstColorBlendFactor = state->cb->attachments[i].dst_color_blend_factor,
+               .colorBlendOp = state->cb->attachments[i].color_blend_op,
+               .srcAlphaBlendFactor = state->cb->attachments[i].src_alpha_blend_factor,
+               .dstAlphaBlendFactor = state->cb->attachments[i].dst_alpha_blend_factor,
+               .alphaBlendOp = state->cb->attachments[i].alpha_blend_op,
+            };
+      }
+   }
+
+   if (states & (RADV_DYNAMIC_BLEND_ENABLE)) {
+      if (state->cb) {
+         for (int i = 0; i < state->cb->attachment_count; i++)
+            dynamic->color_blend_enable[i] = state->cb->attachments[i].blend_enable;
+      } else {
+         memset(&dynamic->color_blend_enable, 0, sizeof(dynamic->color_blend_enable));
+      }
+   }
+
    pipeline->dynamic_state.mask = states;
 }
 
@@ -2672,9 +2655,29 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
       key.ps.log2_ps_iter_samples = util_logbase2(ps_iter_samples);
    }
 
-   key.ps.col_format = blend->spi_shader_col_format;
-   key.ps.cb_target_mask = blend->cb_target_mask;
-   key.ps.mrt0_may_be_dual_src = blend->mrt0_is_dual_src;
+   bool dyn_mrt_possible = false;
+   if (state->cb && (pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)) {
+      int i;
+      for (i = 0; i < state->cb->attachment_count; i++) {
+         if (state->cb->attachments[i].write_mask) {
+            if (i == 0) {
+               dyn_mrt_possible = true;
+            } else {
+               dyn_mrt_possible = false;
+               break;
+            }
+         }
+      }
+   }
+   key.ps.mrt0_may_be_dual_src = blend->mrt0_is_dual_src || dyn_mrt_possible;
+   if (key.ps.mrt0_may_be_dual_src) {
+      key.ps.col_format = ((blend->spi_shader_col_format & 0xf) << 4) | (blend->spi_shader_col_format & 0xf);
+      /* no extra modes are being used here, so it is safe to copy flags around */
+      key.ps.cb_target_mask = ((blend->cb_target_mask & 0xf) << 4) | (blend->cb_target_mask & 0xf);
+   } else {
+      key.ps.col_format = blend->spi_shader_col_format;
+      key.ps.cb_target_mask = blend->cb_target_mask;
+   }
    if (device->physical_device->rad_info.gfx_level < GFX8) {
       key.ps.is_int8 = blend->col_format_is_int8;
       key.ps.is_int10 = blend->col_format_is_int10;
@@ -4603,27 +4606,6 @@ radv_pipeline_emit_depth_stencil_state(struct radeon_cmdbuf *ctx_cs,
    radeon_set_context_reg(ctx_cs, R_028010_DB_RENDER_OVERRIDE2, ds_state->db_render_override2);
 }
 
-static void
-radv_pipeline_emit_blend_state(struct radeon_cmdbuf *ctx_cs,
-                               const struct radv_graphics_pipeline *pipeline,
-                               const struct radv_blend_state *blend)
-{
-   const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-
-   radeon_set_context_reg_seq(ctx_cs, R_028780_CB_BLEND0_CONTROL, 8);
-   radeon_emit_array(ctx_cs, blend->cb_blend_control, 8);
-
-   if (pdevice->rad_info.has_rbplus) {
-
-      radeon_set_context_reg_seq(ctx_cs, R_028760_SX_MRT0_BLEND_OPT, 8);
-      radeon_emit_array(ctx_cs, blend->sx_mrt_blend_opt, 8);
-   }
-
-   radeon_set_context_reg(ctx_cs, R_028714_SPI_SHADER_COL_FORMAT, blend->spi_shader_col_format);
-
-   radeon_set_context_reg(ctx_cs, R_02823C_CB_SHADER_MASK, blend->cb_shader_mask);
-}
-
 static void
 radv_pipeline_emit_multisample_state(struct radeon_cmdbuf *ctx_cs,
                                      const struct radv_graphics_pipeline *pipeline)
@@ -5606,7 +5588,6 @@ radv_pipeline_emit_pm4(struct radv_graphics_pipeline *pipeline,
    ctx_cs->buf = cs->buf + cs->max_dw;
 
    radv_pipeline_emit_depth_stencil_state(ctx_cs, ds_state);
-   radv_pipeline_emit_blend_state(ctx_cs, pipeline, blend);
    radv_pipeline_emit_multisample_state(ctx_cs, pipeline);
    radv_pipeline_emit_vgt_gs_mode(ctx_cs, pipeline);
    radv_pipeline_emit_vertex_shader(ctx_cs, cs, pipeline);
@@ -6082,6 +6063,9 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       radv_pipeline_init_extra(pipeline, extra, &blend, &ds_state, &state, &vgt_gs_out_prim_type);
    }
 
+   pipeline->spi_shader_col_format = blend.spi_shader_col_format;
+   pipeline->cb_shader_mask = blend.cb_shader_mask;
+
    radv_pipeline_emit_pm4(pipeline, &blend, &ds_state, vgt_gs_out_prim_type, &state);
 
    radv_pipeline_layout_finish(device, &pipeline_layout);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index d16ae33666a4..83e22820b13a 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1111,7 +1111,9 @@ enum radv_dynamic_state_bits {
    RADV_DYNAMIC_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE = 1ull << 38,
    RADV_DYNAMIC_PROVOKING_VERTEX_MODE = 1ull << 39,
    RADV_DYNAMIC_DEPTH_CLAMP_ENABLE = 1ull << 40,
-   RADV_DYNAMIC_ALL = (1ull << 41) - 1,
+   RADV_DYNAMIC_BLEND_ENABLE = 1ull << 41,
+   RADV_DYNAMIC_BLEND_EQUATION = 1ull << 42,
+   RADV_DYNAMIC_ALL = (1ull << 43) - 1,
 };
 
 enum radv_cmd_dirty_bits {
@@ -1158,13 +1160,15 @@ enum radv_cmd_dirty_bits {
    RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE = 1ull << 38,
    RADV_CMD_DIRTY_DYNAMIC_PROVOKING_VERTEX_MODE = 1ull << 39,
    RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLAMP_ENABLE = 1ull << 40,
-   RADV_CMD_DIRTY_DYNAMIC_ALL = (1ull << 41) - 1,
-   RADV_CMD_DIRTY_PIPELINE = 1ull << 41,
-   RADV_CMD_DIRTY_INDEX_BUFFER = 1ull << 42,
-   RADV_CMD_DIRTY_FRAMEBUFFER = 1ull << 43,
-   RADV_CMD_DIRTY_VERTEX_BUFFER = 1ull << 44,
-   RADV_CMD_DIRTY_STREAMOUT_BUFFER = 1ull << 45,
-   RADV_CMD_DIRTY_GUARDBAND = 1ull << 46,
+   RADV_CMD_DIRTY_DYNAMIC_BLEND_ENABLE = 1ull << 41,
+   RADV_CMD_DIRTY_DYNAMIC_BLEND_EQUATION = 1ull << 42,
+   RADV_CMD_DIRTY_DYNAMIC_ALL = (1ull << 43) - 1,
+   RADV_CMD_DIRTY_PIPELINE = 1ull << 43,
+   RADV_CMD_DIRTY_INDEX_BUFFER = 1ull << 44,
+   RADV_CMD_DIRTY_FRAMEBUFFER = 1ull << 45,
+   RADV_CMD_DIRTY_VERTEX_BUFFER = 1ull << 46,
+   RADV_CMD_DIRTY_STREAMOUT_BUFFER = 1ull << 47,
+   RADV_CMD_DIRTY_GUARDBAND = 1ull << 48,
 };
 
 enum radv_cmd_flush_bits {
@@ -1384,6 +1388,10 @@ struct radv_dynamic_state {
    VkProvokingVertexModeEXT provoking_vertex_mode;
 
    bool depth_clamp_enable;
+
+   bool color_blend_enable[8];
+
+   VkColorBlendEquationEXT color_blend_equations[8];
 };
 
 extern const struct radv_dynamic_state default_dynamic_state;
@@ -2090,6 +2098,10 @@ struct radv_graphics_pipeline {
    uint32_t col_format_non_compacted;
    uint32_t cb_target_mask;
 
+   /*used for blend state*/
+   uint32_t spi_shader_col_format;
+   uint32_t cb_shader_mask;
+
    bool disable_out_of_order_rast_for_occlusion;
    bool uses_drawid;
    bool uses_baseinstance;
@@ -3282,6 +3294,25 @@ si_translate_blend_logic_op(VkLogicOp op)
    }
 }
 
+static bool
+radv_can_enable_dual_src(const struct VkColorBlendEquationEXT *equation)
+{
+   VkBlendOp eqRGB = equation->colorBlendOp;
+   VkBlendFactor srcRGB = equation->srcColorBlendFactor;
+   VkBlendFactor dstRGB = equation->dstColorBlendFactor;
+   VkBlendOp eqA = equation->alphaBlendOp;
+   VkBlendFactor srcA = equation->srcAlphaBlendFactor;
+   VkBlendFactor dstA = equation->dstAlphaBlendFactor;
+   bool eqRGB_minmax = eqRGB == VK_BLEND_OP_MIN || eqRGB == VK_BLEND_OP_MAX;
+   bool eqA_minmax = eqA == VK_BLEND_OP_MIN || eqA == VK_BLEND_OP_MAX;
+
+   if (!eqRGB_minmax && (is_dual_src(srcRGB) || is_dual_src(dstRGB)))
+      return true;
+   if (!eqA_minmax && (is_dual_src(srcA) || is_dual_src(dstA)))
+      return true;
+   return false;
+}
+
 uint32_t radv_get_tess_output_topology(const struct radv_graphics_pipeline *pipeline,
                                        VkTessellationDomainOrigin domain_origin);
 
-- 
GitLab


From 26e5ca05c09f9b363580a7ec10ed1051d5e880b2 Mon Sep 17 00:00:00 2001
From: Sergei Chernyadyev
 <28547-Cherser-s@users.noreply.gitlab.freedesktop.org>
Date: Fri, 4 Nov 2022 11:20:03 +0300
Subject: [PATCH 4/4] radv: remove mrt0_is_be_dual_src from pipeline_key

Replace mrt0_is_be_dual_src flag from radv_pipeline_key with usage of color_is_dual_source from NIR shader metadata
---
 src/amd/vulkan/radv_nir_to_llvm.c |  4 ++--
 src/amd/vulkan/radv_pipeline.c    | 37 ++++++++++---------------------
 src/amd/vulkan/radv_shader.h      |  3 +--
 3 files changed, 15 insertions(+), 29 deletions(-)

diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 0df49dc2f0fd..61b73eb430b3 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -1044,7 +1044,7 @@ si_export_mrt_color(struct radv_shader_context *ctx, LLVMValueRef *color, unsign
 {
    unsigned mrt_target = V_008DFC_SQ_EXP_MRT + target;
 
-   if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.mrt0_may_be_dual_src &&
+   if (ctx->options->gfx_level >= GFX11 && ctx->shader->info.fs.color_is_dual_source &&
        (target == 0 || target == 1)) {
       mrt_target += 21;
    }
@@ -1113,7 +1113,7 @@ handle_fs_outputs_post(struct radv_shader_context *ctx)
       color_args[last].valid_mask = 1; /* whether the EXEC mask is valid */
       color_args[last].done = 1;       /* DONE bit */
 
-      if (ctx->options->gfx_level >= GFX11 && ctx->options->key.ps.mrt0_may_be_dual_src) {
+      if (ctx->options->gfx_level >= GFX11 && ctx->shader->info.fs.color_is_dual_source) {
          ac_build_dual_src_blend_swizzle(&ctx->ac, &color_args[0], &color_args[1]);
       }
    }
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index f496324e9836..cc883cafb98a 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2119,7 +2119,7 @@ radv_remove_color_exports(const struct radv_pipeline_key *pipeline_key, nir_shad
 
       if (col_format == V_028714_SPI_SHADER_ZERO ||
           (col_format == V_028714_SPI_SHADER_32_R && !cb_target_mask &&
-           !pipeline_key->ps.mrt0_may_be_dual_src)) {
+           !nir->info.fs.color_is_dual_source)) {
          /* Remove the color export if it's unused or in presence of holes. */
          nir->info.outputs_written &= ~BITFIELD64_BIT(var->data.location);
          var->data.location = 0;
@@ -2655,29 +2655,9 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
       key.ps.log2_ps_iter_samples = util_logbase2(ps_iter_samples);
    }
 
-   bool dyn_mrt_possible = false;
-   if (state->cb && (pipeline->dynamic_states & RADV_DYNAMIC_BLEND_EQUATION)) {
-      int i;
-      for (i = 0; i < state->cb->attachment_count; i++) {
-         if (state->cb->attachments[i].write_mask) {
-            if (i == 0) {
-               dyn_mrt_possible = true;
-            } else {
-               dyn_mrt_possible = false;
-               break;
-            }
-         }
-      }
-   }
-   key.ps.mrt0_may_be_dual_src = blend->mrt0_is_dual_src || dyn_mrt_possible;
-   if (key.ps.mrt0_may_be_dual_src) {
-      key.ps.col_format = ((blend->spi_shader_col_format & 0xf) << 4) | (blend->spi_shader_col_format & 0xf);
-      /* no extra modes are being used here, so it is safe to copy flags around */
-      key.ps.cb_target_mask = ((blend->cb_target_mask & 0xf) << 4) | (blend->cb_target_mask & 0xf);
-   } else {
-      key.ps.col_format = blend->spi_shader_col_format;
-      key.ps.cb_target_mask = blend->cb_target_mask;
-   }
+   key.ps.col_format = blend->spi_shader_col_format;
+   key.ps.cb_target_mask = blend->cb_target_mask;
+
    if (device->physical_device->rad_info.gfx_level < GFX8) {
       key.ps.is_int8 = blend->col_format_is_int8;
       key.ps.is_int10 = blend->col_format_is_int10;
@@ -3830,7 +3810,7 @@ radv_pipeline_create_ps_epilog(struct radv_graphics_pipeline *pipeline,
 VkResult
 radv_create_shaders(struct radv_pipeline *pipeline, struct radv_pipeline_layout *pipeline_layout,
                     struct radv_device *device, struct radv_pipeline_cache *cache,
-                    const struct radv_pipeline_key *pipeline_key,
+                    struct radv_pipeline_key *pipeline_key,
                     const VkPipelineShaderStageCreateInfo *pStages,
                     uint32_t stageCount,
                     const VkPipelineCreateFlags flags, const uint8_t *custom_hash,
@@ -3978,6 +3958,13 @@ radv_create_shaders(struct radv_pipeline *pipeline, struct radv_pipeline_layout
       NIR_PASS(_, stages[MESA_SHADER_GEOMETRY].nir, nir_lower_gs_intrinsics, nir_gs_flags);
    }
 
+   if (stages[MESA_SHADER_FRAGMENT].nir && stages[MESA_SHADER_FRAGMENT].nir->info.fs.color_is_dual_source) {
+      /* add extra output to col_format and cb_shader_flags for dual src blending */
+      pipeline_key->ps.col_format = ((pipeline_key->ps.col_format & 0xf) << 4) | (pipeline_key->ps.col_format & 0xf);
+      /* no extra modes are being used here, so it is safe to copy flags around */
+      pipeline_key->ps.cb_target_mask = ((pipeline_key->ps.cb_target_mask & 0xf) << 4) | (pipeline_key->ps.cb_target_mask & 0xf);
+   }
+
    radv_graphics_pipeline_link(pipeline, pipeline_key, stages);
 
    for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; ++i) {
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index d3c86d4caec0..1f663f43cebc 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -89,7 +89,6 @@ struct radv_pipeline_key {
       uint32_t cb_target_mask;
       uint8_t log2_ps_iter_samples;
       uint8_t num_samples;
-      bool mrt0_may_be_dual_src;
 
       bool lower_discard_to_demote;
       uint8_t enable_mrt_output_nan_fixup;
@@ -558,7 +557,7 @@ struct radv_pipeline_shader_stack_size;
 VkResult radv_create_shaders(struct radv_pipeline *pipeline,
                              struct radv_pipeline_layout *pipeline_layout,
                              struct radv_device *device, struct radv_pipeline_cache *cache,
-                             const struct radv_pipeline_key *key,
+                             struct radv_pipeline_key *key,
                              const VkPipelineShaderStageCreateInfo *pStages,
                              uint32_t stageCount,
                              const VkPipelineCreateFlags flags, const uint8_t *custom_hash,
-- 
GitLab

