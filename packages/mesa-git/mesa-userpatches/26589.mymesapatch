From 52d7309d8a3644ec9d8590a4af308cc721b3454f Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 8 Dec 2023 09:28:24 +0100
Subject: [PATCH] radv: remove the fb miptail flush workaround completely

This shouldn't have any effects because:
- PAL only enables this workaround on GFX9
- DCC/HTILE with mips aren't supported on GFX9
- MSAA images can't have mips on Vulkan (ie. no FMASK)
- CMASK isn't supposed to have any mipmaps support

By the time we introduced this (October 2020), I think we had metadata
cache cohereny issues that have been properly fixed since.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 72 --------------------------------
 src/amd/vulkan/radv_private.h    |  2 -
 2 files changed, 74 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 52926ff5ee4e..12b759f25aa6 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3421,66 +3421,6 @@ radv_load_color_clear_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_i
    }
 }
 
-/* GFX9+ metadata cache flushing workaround. metadata cache coherency is
- * broken if the CB caches data of multiple mips of the same image at the
- * same time.
- *
- * Insert some flushes to avoid this.
- */
-static void
-radv_emit_fb_mip_change_flush(struct radv_cmd_buffer *cmd_buffer)
-{
-   struct radv_rendering_state *render = &cmd_buffer->state.render;
-   bool color_mip_changed = false;
-
-   /* Entire workaround is not applicable before GFX9 */
-   if (cmd_buffer->device->physical_device->rad_info.gfx_level < GFX9)
-      return;
-
-   for (int i = 0; i < render->color_att_count; ++i) {
-      struct radv_image_view *iview = render->color_att[i].iview;
-      if (!iview)
-         continue;
-
-      if ((radv_image_has_CB_metadata(iview->image) || radv_dcc_enabled(iview->image, iview->vk.base_mip_level) ||
-           radv_dcc_enabled(iview->image, cmd_buffer->state.cb_mip[i])) &&
-          cmd_buffer->state.cb_mip[i] != iview->vk.base_mip_level)
-         color_mip_changed = true;
-
-      cmd_buffer->state.cb_mip[i] = iview->vk.base_mip_level;
-   }
-
-   if (color_mip_changed) {
-      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-   }
-}
-
-/* This function does the flushes for mip changes if the levels are not zero for
- * all render targets. This way we can assume at the start of the next cmd_buffer
- * that rendering to mip 0 doesn't need any flushes. As that is the most common
- * case that saves some flushes. */
-static void
-radv_emit_mip_change_flush_default(struct radv_cmd_buffer *cmd_buffer)
-{
-   /* Entire workaround is not applicable before GFX9 */
-   if (cmd_buffer->device->physical_device->rad_info.gfx_level < GFX9)
-      return;
-
-   bool need_color_mip_flush = false;
-   for (unsigned i = 0; i < 8; ++i) {
-      if (cmd_buffer->state.cb_mip[i]) {
-         need_color_mip_flush = true;
-         break;
-      }
-   }
-
-   if (need_color_mip_flush) {
-      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-   }
-
-   memset(cmd_buffer->state.cb_mip, 0, sizeof(cmd_buffer->state.cb_mip));
-}
-
 static void
 radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -6110,8 +6050,6 @@ radv_EndCommandBuffer(VkCommandBuffer commandBuffer)
    if (cmd_buffer->qf == RADV_QUEUE_SPARSE)
       return vk_command_buffer_end(&cmd_buffer->vk);
 
-   radv_emit_mip_change_flush_default(cmd_buffer);
-
    const bool is_gfx_or_ace = cmd_buffer->qf == RADV_QUEUE_GENERAL || cmd_buffer->qf == RADV_QUEUE_COMPUTE;
 
    if (is_gfx_or_ace) {
@@ -7374,8 +7312,6 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
 
    assert(commandBufferCount > 0);
 
-   radv_emit_mip_change_flush_default(primary);
-
    /* Emit pending flushes on primary prior to executing secondary */
    si_emit_cache_flush(primary);
 
@@ -7424,7 +7360,6 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
           * has been recorded without a framebuffer, otherwise
           * fast color/depth clears can't work.
           */
-         radv_emit_fb_mip_change_flush(primary);
          radv_emit_framebuffer_state(primary);
       }
 
@@ -8979,10 +8914,6 @@ radv_before_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info
       cmd_buffer->state.last_index_type = -1;
    }
 
-   /* Need to apply this workaround early as it can set flush flags. */
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
-      radv_emit_fb_mip_change_flush(cmd_buffer);
-
    /* Use optimal packet order based on whether we need to sync the
     * pipeline.
     */
@@ -9065,9 +8996,6 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    ASSERTED const unsigned ace_cdw_max =
       !ace_cs ? 0 : radeon_check_space(cmd_buffer->device->ws, ace_cs, 4096 + 128 * (drawCount - 1));
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
-      radv_emit_fb_mip_change_flush(cmd_buffer);
-
    radv_emit_all_graphics_states(cmd_buffer, info);
    if (task_shader && pipeline_is_dirty) {
       radv_emit_compute_shader(pdevice, ace_cs, task_shader);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 36959847e84f..01ced1c2b3c4 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1732,8 +1732,6 @@ struct radv_cmd_state {
    /* Mesh shading state. */
    bool mesh_shading;
 
-   uint8_t cb_mip[MAX_RTS];
-
    /* Whether DRAW_{INDEX}_INDIRECT_{MULTI} is emitted. */
    bool uses_draw_indirect;
 
-- 
GitLab

