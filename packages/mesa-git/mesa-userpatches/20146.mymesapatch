From cf7eae160719f9503909c0d5c5e1e9a21568e520 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 01:33:33 -0500
Subject: [PATCH 01/14] ac/llvm: remove AC_FUNC_ATTR_INACCESSIBLE_MEM_ONLY
 because LLVM 16 removed it

We didn't use it reasonably anyway.
---
 src/amd/llvm/ac_llvm_build.c | 4 ++--
 src/amd/llvm/ac_llvm_util.c  | 2 --
 src/amd/llvm/ac_llvm_util.h  | 3 +--
 3 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 8f08ca47c50e..65154a064fb0 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1250,7 +1250,7 @@ static void ac_build_buffer_store_common(struct ac_llvm_context *ctx, LLVMValueR
       snprintf(name, sizeof(name), "llvm.amdgcn.%s.buffer.store.%s", indexing_kind, type_name);
    }
 
-   ac_build_intrinsic(ctx, name, ctx->voidt, args, idx, AC_FUNC_ATTR_INACCESSIBLE_MEM_ONLY);
+   ac_build_intrinsic(ctx, name, ctx->voidt, args, idx, 0);
 }
 
 void ac_build_buffer_store_format(struct ac_llvm_context *ctx, LLVMValueRef rsrc, LLVMValueRef data,
@@ -4349,7 +4349,7 @@ LLVMValueRef ac_build_load_helper_invocation(struct ac_llvm_context *ctx)
 
    if (LLVM_VERSION_MAJOR >= 13) {
       result = ac_build_intrinsic(ctx, "llvm.amdgcn.live.mask", ctx->i1, NULL, 0,
-                                  AC_FUNC_ATTR_READONLY | AC_FUNC_ATTR_INACCESSIBLE_MEM_ONLY);
+                                  AC_FUNC_ATTR_READONLY);
    } else {
       result = ac_build_intrinsic(ctx, "llvm.amdgcn.ps.live", ctx->i1, NULL, 0,
                                   AC_FUNC_ATTR_READNONE);
diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index be81084b57f9..3116471b326b 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -265,8 +265,6 @@ static const char *attr_to_str(enum ac_func_attr attr)
       return "readonly";
    case AC_FUNC_ATTR_WRITEONLY:
       return "writeonly";
-   case AC_FUNC_ATTR_INACCESSIBLE_MEM_ONLY:
-      return "inaccessiblememonly";
    case AC_FUNC_ATTR_CONVERGENT:
       return "convergent";
    default:
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index f35c3aecbe44..a670500e970f 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -49,8 +49,7 @@ enum ac_func_attr
    AC_FUNC_ATTR_READNONE = (1 << 5),
    AC_FUNC_ATTR_READONLY = (1 << 6),
    AC_FUNC_ATTR_WRITEONLY = (1 << 7),
-   AC_FUNC_ATTR_INACCESSIBLE_MEM_ONLY = (1 << 8),
-   AC_FUNC_ATTR_CONVERGENT = (1 << 9),
+   AC_FUNC_ATTR_CONVERGENT = (1 << 8),
 
    /* Legacy intrinsic that needs attributes on function declarations
     * and they must match the internal LLVM definition exactly, otherwise
-- 
GitLab


From b46f3b4593cda06f4cf1a16cee1bba9a81fbefe2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 01:35:33 -0500
Subject: [PATCH 02/14] ac/llvm: remove unused AC_FUNC_ATTR_LEGACY

---
 src/amd/llvm/ac_llvm_build.c | 7 +------
 src/amd/llvm/ac_llvm_util.c  | 1 -
 src/amd/llvm/ac_llvm_util.h  | 6 ------
 3 files changed, 1 insertion(+), 13 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 65154a064fb0..cd1724aebabb 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -289,7 +289,6 @@ LLVMValueRef ac_build_intrinsic(struct ac_llvm_context *ctx, const char *name,
                                 unsigned attrib_mask)
 {
    LLVMValueRef call;
-   bool set_callsite_attrs = !(attrib_mask & AC_FUNC_ATTR_LEGACY);
 
    LLVMTypeRef param_types[32];
    assert(param_count <= 32);
@@ -306,14 +305,10 @@ LLVMValueRef ac_build_intrinsic(struct ac_llvm_context *ctx, const char *name,
 
       LLVMSetFunctionCallConv(function, LLVMCCallConv);
       LLVMSetLinkage(function, LLVMExternalLinkage);
-
-      if (!set_callsite_attrs)
-         ac_add_func_attributes(ctx->context, function, attrib_mask);
    }
 
    call = LLVMBuildCall2(ctx->builder, function_type, function, params, param_count, "");
-   if (set_callsite_attrs)
-      ac_add_func_attributes(ctx->context, call, attrib_mask);
+   ac_add_func_attributes(ctx->context, call, attrib_mask);
    return call;
 }
 
diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index 3116471b326b..a82f5efe8546 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -289,7 +289,6 @@ void ac_add_function_attr(LLVMContextRef ctx, LLVMValueRef function, int attr_id
 void ac_add_func_attributes(LLVMContextRef ctx, LLVMValueRef function, unsigned attrib_mask)
 {
    attrib_mask |= AC_FUNC_ATTR_NOUNWIND;
-   attrib_mask &= ~AC_FUNC_ATTR_LEGACY;
 
    while (attrib_mask) {
       enum ac_func_attr attr = 1u << u_bit_scan(&attrib_mask);
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index a670500e970f..6fd4a5ff4107 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -50,12 +50,6 @@ enum ac_func_attr
    AC_FUNC_ATTR_READONLY = (1 << 6),
    AC_FUNC_ATTR_WRITEONLY = (1 << 7),
    AC_FUNC_ATTR_CONVERGENT = (1 << 8),
-
-   /* Legacy intrinsic that needs attributes on function declarations
-    * and they must match the internal LLVM definition exactly, otherwise
-    * intrinsic selection fails.
-    */
-   AC_FUNC_ATTR_LEGACY = (1u << 31),
 };
 
 enum ac_target_machine_options
-- 
GitLab


From ba1580cdd92423f3bc387415a29aadd3b67fc02a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 01:36:44 -0500
Subject: [PATCH 03/14] gallivm: remove unused
 LP_FUNC_ATTR_INACCESSIBLE_MEM_ONLY

LLVM 16 removed it anyway.
---
 src/gallium/auxiliary/gallivm/lp_bld_intr.c | 1 -
 src/gallium/auxiliary/gallivm/lp_bld_intr.h | 5 ++---
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.c b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
index 6d718305c9a0..ba18627d48e0 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
@@ -141,7 +141,6 @@ static const char *attr_to_str(enum lp_func_attr attr)
    case LP_FUNC_ATTR_READNONE: return "readnone";
    case LP_FUNC_ATTR_READONLY: return "readonly";
    case LP_FUNC_ATTR_WRITEONLY: return "writeonly";
-   case LP_FUNC_ATTR_INACCESSIBLE_MEM_ONLY: return "inaccessiblememonly";
    case LP_FUNC_ATTR_CONVERGENT: return "convergent";
    case LP_FUNC_ATTR_PRESPLITCORO: return "presplitcoroutine";
    default:
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.h b/src/gallium/auxiliary/gallivm/lp_bld_intr.h
index a73f64c0d915..7714f9640c15 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.h
@@ -56,9 +56,8 @@ enum lp_func_attr {
    LP_FUNC_ATTR_READNONE     = (1 << 5),
    LP_FUNC_ATTR_READONLY     = (1 << 6),
    LP_FUNC_ATTR_WRITEONLY    = (1 << 7),
-   LP_FUNC_ATTR_INACCESSIBLE_MEM_ONLY = (1 << 8),
-   LP_FUNC_ATTR_CONVERGENT   = (1 << 9),
-   LP_FUNC_ATTR_PRESPLITCORO = (1 << 10),
+   LP_FUNC_ATTR_CONVERGENT   = (1 << 8),
+   LP_FUNC_ATTR_PRESPLITCORO = (1 << 9),
 
    /* Legacy intrinsic that needs attributes on function declarations
     * and they must match the internal LLVM definition exactly, otherwise
-- 
GitLab


From 42a499f750cddd5b1935359962bd0f6e773a90f6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 01:37:46 -0500
Subject: [PATCH 04/14] gallivm: remove unused LP_FUNC_ATTR_LEGACY

---
 src/gallium/auxiliary/gallivm/lp_bld_intr.c | 8 +-------
 src/gallium/auxiliary/gallivm/lp_bld_intr.h | 6 ------
 2 files changed, 1 insertion(+), 13 deletions(-)

diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.c b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
index ba18627d48e0..425d5459d0ca 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
@@ -181,7 +181,6 @@ lp_add_func_attributes(LLVMValueRef function, unsigned attrib_mask)
     * Set it for all intrinsics.
     */
    attrib_mask |= LP_FUNC_ATTR_NOUNWIND;
-   attrib_mask &= ~LP_FUNC_ATTR_LEGACY;
 
    while (attrib_mask) {
       enum lp_func_attr attr = 1u << u_bit_scan(&attrib_mask);
@@ -199,7 +198,6 @@ lp_build_intrinsic(LLVMBuilderRef builder,
 {
    LLVMModuleRef module = LLVMGetGlobalParent(LLVMGetBasicBlockParent(LLVMGetInsertBlock(builder)));
    LLVMValueRef function, call;
-   bool set_callsite_attrs = !(attr_mask & LP_FUNC_ATTR_LEGACY);
 
    LLVMTypeRef arg_types[LP_MAX_FUNC_ARGS];
 
@@ -228,17 +226,13 @@ lp_build_intrinsic(LLVMBuilderRef builder,
          abort();
       }
 
-      if (!set_callsite_attrs)
-         lp_add_func_attributes(function, attr_mask);
-
       if (gallivm_debug & GALLIVM_DEBUG_IR) {
          lp_debug_dump_value(function);
       }
    }
 
    call = LLVMBuildCall2(builder, function_type, function, args, num_args, "");
-   if (set_callsite_attrs)
-      lp_add_func_attributes(call, attr_mask);
+   lp_add_func_attributes(call, attr_mask);
    return call;
 }
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.h b/src/gallium/auxiliary/gallivm/lp_bld_intr.h
index 7714f9640c15..a3ecf0c28267 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.h
@@ -58,12 +58,6 @@ enum lp_func_attr {
    LP_FUNC_ATTR_WRITEONLY    = (1 << 7),
    LP_FUNC_ATTR_CONVERGENT   = (1 << 8),
    LP_FUNC_ATTR_PRESPLITCORO = (1 << 9),
-
-   /* Legacy intrinsic that needs attributes on function declarations
-    * and they must match the internal LLVM definition exactly, otherwise
-    * intrinsic selection fails.
-    */
-   LP_FUNC_ATTR_LEGACY       = (1u << 31),
 };
 
 void
-- 
GitLab


From d8df0b910618d2fa7e0d774b58593babe85554c7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 04:13:30 -0500
Subject: [PATCH 05/14] gallivm: remove illegal and unused function attributes

READONLY is illegal on calls. Others were unused.
---
 src/gallium/auxiliary/gallivm/lp_bld_intr.c            | 3 ---
 src/gallium/auxiliary/gallivm/lp_bld_intr.h            | 7 ++-----
 src/gallium/drivers/llvmpipe/lp_state_fs_linear_llvm.c | 4 ----
 3 files changed, 2 insertions(+), 12 deletions(-)

diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.c b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
index 425d5459d0ca..542a4ba0d206 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
@@ -138,9 +138,6 @@ static const char *attr_to_str(enum lp_func_attr attr)
    case LP_FUNC_ATTR_INREG: return "inreg";
    case LP_FUNC_ATTR_NOALIAS: return "noalias";
    case LP_FUNC_ATTR_NOUNWIND: return "nounwind";
-   case LP_FUNC_ATTR_READNONE: return "readnone";
-   case LP_FUNC_ATTR_READONLY: return "readonly";
-   case LP_FUNC_ATTR_WRITEONLY: return "writeonly";
    case LP_FUNC_ATTR_CONVERGENT: return "convergent";
    case LP_FUNC_ATTR_PRESPLITCORO: return "presplitcoroutine";
    default:
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.h b/src/gallium/auxiliary/gallivm/lp_bld_intr.h
index a3ecf0c28267..47a81cba20bd 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.h
@@ -53,11 +53,8 @@ enum lp_func_attr {
    LP_FUNC_ATTR_INREG        = (1 << 2),
    LP_FUNC_ATTR_NOALIAS      = (1 << 3),
    LP_FUNC_ATTR_NOUNWIND     = (1 << 4),
-   LP_FUNC_ATTR_READNONE     = (1 << 5),
-   LP_FUNC_ATTR_READONLY     = (1 << 6),
-   LP_FUNC_ATTR_WRITEONLY    = (1 << 7),
-   LP_FUNC_ATTR_CONVERGENT   = (1 << 8),
-   LP_FUNC_ATTR_PRESPLITCORO = (1 << 9),
+   LP_FUNC_ATTR_CONVERGENT   = (1 << 5),
+   LP_FUNC_ATTR_PRESPLITCORO = (1 << 6),
 };
 
 void
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs_linear_llvm.c b/src/gallium/drivers/llvmpipe/lp_state_fs_linear_llvm.c
index 4d87ad8355a1..0136632dfdf1 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs_linear_llvm.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs_linear_llvm.c
@@ -405,8 +405,6 @@ llvmpipe_fs_variant_linear_llvm(struct llvmpipe_context *lp,
       LLVMValueRef inputs_ptr = LLVMBuildCall2(builder, call_type, fetch_ptr, &elem, 1, "");
       assert(LLVMGetTypeKind(LLVMTypeOf(inputs_ptr)) == LLVMPointerTypeKind);
 
-      /* Mark the function read-only so that LLVM can optimize it away */
-      lp_add_function_attr(inputs_ptr, -1, LP_FUNC_ATTR_READONLY);
       lp_add_function_attr(inputs_ptr, -1, LP_FUNC_ATTR_NOUNWIND);
 
       lp_build_name(inputs_ptr, "input%u_ptr", attrib);
@@ -445,8 +443,6 @@ llvmpipe_fs_variant_linear_llvm(struct llvmpipe_context *lp,
       LLVMValueRef texels_ptr = LLVMBuildCall2(builder, call_type, fetch_ptr, &elem, 1, "");
       assert(LLVMGetTypeKind(LLVMTypeOf(texels_ptr)) == LLVMPointerTypeKind);
 
-      /* Mark the function read-only so that LLVM can optimize it away */
-      lp_add_function_attr(texels_ptr, -1, LP_FUNC_ATTR_READONLY);
       lp_add_function_attr(texels_ptr, -1, LP_FUNC_ATTR_NOUNWIND);
 
       lp_build_name(texels_ptr, "tex%u_ptr", attrib);
-- 
GitLab


From eac8ff243d58a498850d0910a398a477187f8cf5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 04:30:16 -0500
Subject: [PATCH 06/14] ac/llvm: remove illegal function attributes READONLY
 and WRITEONLY

They are only legal on parameters.
---
 src/amd/llvm/ac_llvm_build.c  | 3 +--
 src/amd/llvm/ac_llvm_util.c   | 4 ----
 src/amd/llvm/ac_llvm_util.h   | 6 +-----
 src/amd/llvm/ac_nir_to_llvm.c | 2 +-
 4 files changed, 3 insertions(+), 12 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index cd1724aebabb..40d5ff49f058 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -4343,8 +4343,7 @@ LLVMValueRef ac_build_load_helper_invocation(struct ac_llvm_context *ctx)
    LLVMValueRef result;
 
    if (LLVM_VERSION_MAJOR >= 13) {
-      result = ac_build_intrinsic(ctx, "llvm.amdgcn.live.mask", ctx->i1, NULL, 0,
-                                  AC_FUNC_ATTR_READONLY);
+      result = ac_build_intrinsic(ctx, "llvm.amdgcn.live.mask", ctx->i1, NULL, 0, 0);
    } else {
       result = ac_build_intrinsic(ctx, "llvm.amdgcn.ps.live", ctx->i1, NULL, 0,
                                   AC_FUNC_ATTR_READNONE);
diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index a82f5efe8546..f98ef4f32d19 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -261,10 +261,6 @@ static const char *attr_to_str(enum ac_func_attr attr)
       return "nounwind";
    case AC_FUNC_ATTR_READNONE:
       return "readnone";
-   case AC_FUNC_ATTR_READONLY:
-      return "readonly";
-   case AC_FUNC_ATTR_WRITEONLY:
-      return "writeonly";
    case AC_FUNC_ATTR_CONVERGENT:
       return "convergent";
    default:
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index 6fd4a5ff4107..919dead860a6 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -47,8 +47,6 @@ enum ac_func_attr
    AC_FUNC_ATTR_NOALIAS = (1 << 3),
    AC_FUNC_ATTR_NOUNWIND = (1 << 4),
    AC_FUNC_ATTR_READNONE = (1 << 5),
-   AC_FUNC_ATTR_READONLY = (1 << 6),
-   AC_FUNC_ATTR_WRITEONLY = (1 << 7),
    AC_FUNC_ATTR_CONVERGENT = (1 << 8),
 };
 
@@ -104,9 +102,7 @@ void ac_llvm_set_target_features(LLVMValueRef F, struct ac_llvm_context *ctx);
 
 static inline unsigned ac_get_load_intr_attribs(bool can_speculate)
 {
-   /* READNONE means writes can't affect it, while READONLY means that
-    * writes can affect it. */
-   return can_speculate ? AC_FUNC_ATTR_READNONE : AC_FUNC_ATTR_READONLY;
+   return can_speculate ? AC_FUNC_ATTR_READNONE : 0;
 }
 
 LLVMTargetLibraryInfoRef ac_create_target_library_info(const char *triple);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 796fb2e2c78f..4ca98bca5eed 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -2667,7 +2667,7 @@ static LLVMValueRef visit_image_load(struct ac_nir_context *ctx, const nir_intri
       if (!level_zero)
          args.lod = get_src(ctx, instr->src[3]);
       args.dmask = 15;
-      args.attributes = AC_FUNC_ATTR_READONLY;
+      args.attributes = 0;
 
       assert(instr->dest.is_ssa);
       args.d16 = instr->dest.ssa.bit_size == 16;
-- 
GitLab


From a2b564e16e91d78fb2e367d20af4b114c19a0146 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 04:23:00 -0500
Subject: [PATCH 07/14] ac/llvm: simplify how call attributes are set

set them directly in ac_build_intrinsic, the only place that sets them
---
 src/amd/llvm/ac_llvm_build.c  | 13 ++++++++++---
 src/amd/llvm/ac_llvm_util.c   | 29 ++++++-----------------------
 src/amd/llvm/ac_llvm_util.h   | 14 ++++++++------
 src/amd/llvm/ac_nir_to_llvm.c |  2 +-
 4 files changed, 25 insertions(+), 33 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 40d5ff49f058..2adfec1ad757 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -308,7 +308,14 @@ LLVMValueRef ac_build_intrinsic(struct ac_llvm_context *ctx, const char *name,
    }
 
    call = LLVMBuildCall2(ctx->builder, function_type, function, params, param_count, "");
-   ac_add_func_attributes(ctx->context, call, attrib_mask);
+
+   if (attrib_mask & AC_FUNC_ATTR_READNONE)
+      LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "readnone"));
+
+   if (attrib_mask & AC_FUNC_ATTR_CONVERGENT)
+      LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "convergent"));
+
+   LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "nounwind"));
    return call;
 }
 
@@ -505,7 +512,7 @@ LLVMValueRef ac_build_ballot(struct ac_llvm_context *ctx, LLVMValueRef value)
 
    return ac_build_intrinsic(
       ctx, name, ctx->iN_wavemask, args, 3,
-      AC_FUNC_ATTR_NOUNWIND | AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+      AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
 }
 
 LLVMValueRef ac_get_i1_sgpr_mask(struct ac_llvm_context *ctx, LLVMValueRef value)
@@ -525,7 +532,7 @@ LLVMValueRef ac_get_i1_sgpr_mask(struct ac_llvm_context *ctx, LLVMValueRef value
 
    return ac_build_intrinsic(
       ctx, name, ctx->iN_wavemask, args, 3,
-      AC_FUNC_ATTR_NOUNWIND | AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+      AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
 }
 
 LLVMValueRef ac_build_vote_all(struct ac_llvm_context *ctx, LLVMValueRef value)
diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index f98ef4f32d19..558d726ec826 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -257,39 +257,22 @@ static const char *attr_to_str(enum ac_func_attr attr)
       return "inreg";
    case AC_FUNC_ATTR_NOALIAS:
       return "noalias";
-   case AC_FUNC_ATTR_NOUNWIND:
-      return "nounwind";
-   case AC_FUNC_ATTR_READNONE:
-      return "readnone";
-   case AC_FUNC_ATTR_CONVERGENT:
-      return "convergent";
    default:
       fprintf(stderr, "Unhandled function attribute: %x\n", attr);
       return 0;
    }
 }
 
-void ac_add_function_attr(LLVMContextRef ctx, LLVMValueRef function, int attr_idx,
-                          enum ac_func_attr attr)
+LLVMAttributeRef ac_get_llvm_attribute(LLVMContextRef ctx, const char *str)
 {
-   const char *attr_name = attr_to_str(attr);
-   unsigned kind_id = LLVMGetEnumAttributeKindForName(attr_name, strlen(attr_name));
-   LLVMAttributeRef llvm_attr = LLVMCreateEnumAttribute(ctx, kind_id, 0);
-
-   if (LLVMIsAFunction(function))
-      LLVMAddAttributeAtIndex(function, attr_idx, llvm_attr);
-   else
-      LLVMAddCallSiteAttribute(function, attr_idx, llvm_attr);
+   return LLVMCreateEnumAttribute(ctx, LLVMGetEnumAttributeKindForName(str, strlen(str)), 0);
 }
 
-void ac_add_func_attributes(LLVMContextRef ctx, LLVMValueRef function, unsigned attrib_mask)
+void ac_add_function_attr(LLVMContextRef ctx, LLVMValueRef function, int attr_idx,
+                          enum ac_func_attr attr)
 {
-   attrib_mask |= AC_FUNC_ATTR_NOUNWIND;
-
-   while (attrib_mask) {
-      enum ac_func_attr attr = 1u << u_bit_scan(&attrib_mask);
-      ac_add_function_attr(ctx, function, -1, attr);
-   }
+   assert(LLVMIsAFunction(function));
+   LLVMAddAttributeAtIndex(function, attr_idx, ac_get_llvm_attribute(ctx, attr_to_str(attr)));
 }
 
 void ac_dump_module(LLVMModuleRef module)
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index 919dead860a6..a3f1ced47907 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -42,12 +42,14 @@ struct ac_llvm_context;
 
 enum ac_func_attr
 {
+   /* Function and parameter attributes. */
    AC_FUNC_ATTR_ALWAYSINLINE = (1 << 0),
-   AC_FUNC_ATTR_INREG = (1 << 2),
-   AC_FUNC_ATTR_NOALIAS = (1 << 3),
-   AC_FUNC_ATTR_NOUNWIND = (1 << 4),
-   AC_FUNC_ATTR_READNONE = (1 << 5),
-   AC_FUNC_ATTR_CONVERGENT = (1 << 8),
+   AC_FUNC_ATTR_INREG = (1 << 1),
+   AC_FUNC_ATTR_NOALIAS = (1 << 2),
+
+   /* Call attributes. */
+   AC_FUNC_ATTR_READNONE = (1 << 3),
+   AC_FUNC_ATTR_CONVERGENT = (1 << 4),
 };
 
 enum ac_target_machine_options
@@ -87,9 +89,9 @@ void ac_reset_llvm_all_options_occurences();
 void ac_add_attr_dereferenceable(LLVMValueRef val, uint64_t bytes);
 void ac_add_attr_alignment(LLVMValueRef val, uint64_t bytes);
 bool ac_is_sgpr_param(LLVMValueRef param);
+LLVMAttributeRef ac_get_llvm_attribute(LLVMContextRef ctx, const char *str);
 void ac_add_function_attr(LLVMContextRef ctx, LLVMValueRef function, int attr_idx,
                           enum ac_func_attr attr);
-void ac_add_func_attributes(LLVMContextRef ctx, LLVMValueRef function, unsigned attrib_mask);
 void ac_dump_module(LLVMModuleRef module);
 LLVMModuleRef ac_create_module(LLVMTargetMachineRef tm, LLVMContextRef ctx);
 LLVMBuilderRef ac_create_builder(LLVMContextRef ctx, enum ac_float_mode float_mode);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 4ca98bca5eed..015cc1ff9d46 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3081,7 +3081,7 @@ static LLVMValueRef visit_first_invocation(struct ac_nir_context *ctx)
    /* The second argument is whether cttz(0) should be defined, but we do not care. */
    LLVMValueRef args[] = {active_set, ctx->ac.i1false};
    LLVMValueRef result = ac_build_intrinsic(&ctx->ac, intr, ctx->ac.iN_wavemask, args, 2,
-                                            AC_FUNC_ATTR_NOUNWIND | AC_FUNC_ATTR_READNONE);
+                                            AC_FUNC_ATTR_READNONE);
 
    return LLVMBuildTrunc(ctx->ac.builder, result, ctx->ac.i32, "");
 }
-- 
GitLab


From e564e17f2971ffc392ddfa80a08a144b1c385dec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 06:07:32 -0500
Subject: [PATCH 08/14] ac/llvm: simplify how function attributes are set

---
 src/amd/llvm/ac_llvm_build.c                  |  4 ++--
 src/amd/llvm/ac_llvm_util.c                   | 19 ++-----------------
 src/amd/llvm/ac_llvm_util.h                   |  7 +------
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  4 ++--
 4 files changed, 7 insertions(+), 27 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 2adfec1ad757..447f32e03efd 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -4629,10 +4629,10 @@ struct ac_llvm_pointer ac_build_main(const struct ac_shader_args *args, struct a
       if (args->args[i].file != AC_ARG_SGPR)
          continue;
 
-      ac_add_function_attr(ctx->context, main_function, i + 1, AC_FUNC_ATTR_INREG);
+      ac_add_function_attr(ctx->context, main_function, i + 1, "inreg");
 
       if (LLVMGetTypeKind(LLVMTypeOf(P)) == LLVMPointerTypeKind) {
-         ac_add_function_attr(ctx->context, main_function, i + 1, AC_FUNC_ATTR_NOALIAS);
+         ac_add_function_attr(ctx->context, main_function, i + 1, "noalias");
          ac_add_attr_dereferenceable(P, UINT64_MAX);
          ac_add_attr_alignment(P, 4);
       }
diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index 558d726ec826..ff936af3195a 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -248,31 +248,16 @@ static LLVMPassManagerRef ac_create_passmgr(LLVMTargetLibraryInfoRef target_libr
    return passmgr;
 }
 
-static const char *attr_to_str(enum ac_func_attr attr)
-{
-   switch (attr) {
-   case AC_FUNC_ATTR_ALWAYSINLINE:
-      return "alwaysinline";
-   case AC_FUNC_ATTR_INREG:
-      return "inreg";
-   case AC_FUNC_ATTR_NOALIAS:
-      return "noalias";
-   default:
-      fprintf(stderr, "Unhandled function attribute: %x\n", attr);
-      return 0;
-   }
-}
-
 LLVMAttributeRef ac_get_llvm_attribute(LLVMContextRef ctx, const char *str)
 {
    return LLVMCreateEnumAttribute(ctx, LLVMGetEnumAttributeKindForName(str, strlen(str)), 0);
 }
 
 void ac_add_function_attr(LLVMContextRef ctx, LLVMValueRef function, int attr_idx,
-                          enum ac_func_attr attr)
+                          const char *attr)
 {
    assert(LLVMIsAFunction(function));
-   LLVMAddAttributeAtIndex(function, attr_idx, ac_get_llvm_attribute(ctx, attr_to_str(attr)));
+   LLVMAddAttributeAtIndex(function, attr_idx, ac_get_llvm_attribute(ctx, attr));
 }
 
 void ac_dump_module(LLVMModuleRef module)
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index a3f1ced47907..efd9aa82820a 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -42,11 +42,6 @@ struct ac_llvm_context;
 
 enum ac_func_attr
 {
-   /* Function and parameter attributes. */
-   AC_FUNC_ATTR_ALWAYSINLINE = (1 << 0),
-   AC_FUNC_ATTR_INREG = (1 << 1),
-   AC_FUNC_ATTR_NOALIAS = (1 << 2),
-
    /* Call attributes. */
    AC_FUNC_ATTR_READNONE = (1 << 3),
    AC_FUNC_ATTR_CONVERGENT = (1 << 4),
@@ -91,7 +86,7 @@ void ac_add_attr_alignment(LLVMValueRef val, uint64_t bytes);
 bool ac_is_sgpr_param(LLVMValueRef param);
 LLVMAttributeRef ac_get_llvm_attribute(LLVMContextRef ctx, const char *str);
 void ac_add_function_attr(LLVMContextRef ctx, LLVMValueRef function, int attr_idx,
-                          enum ac_func_attr attr);
+                          const char *attr);
 void ac_dump_module(LLVMModuleRef module);
 LLVMModuleRef ac_create_module(LLVMTargetMachineRef tm, LLVMContextRef ctx);
 LLVMBuilderRef ac_create_builder(LLVMContextRef ctx, enum ac_float_mode float_mode);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 307662ba8561..054f2c0dfebd 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -446,7 +446,7 @@ void si_build_wrapper_function(struct si_shader_context *ctx, struct ac_llvm_poi
    memset(ctx->args, 0, sizeof(*ctx->args));
 
    for (unsigned i = 0; i < num_parts; ++i) {
-      ac_add_function_attr(ctx->ac.context, parts[i].value, -1, AC_FUNC_ATTR_ALWAYSINLINE);
+      ac_add_function_attr(ctx->ac.context, parts[i].value, -1, "alwaysinline");
       LLVMSetLinkage(parts[i].value, LLVMPrivateLinkage);
    }
 
@@ -601,7 +601,7 @@ void si_build_wrapper_function(struct si_shader_context *ctx, struct ac_llvm_poi
          is_sgpr = ac_is_sgpr_param(param);
 
          if (is_sgpr) {
-            ac_add_function_attr(ctx->ac.context, parts[part].value, param_idx + 1, AC_FUNC_ATTR_INREG);
+            ac_add_function_attr(ctx->ac.context, parts[part].value, param_idx + 1, "inreg");
          } else if (out_idx < num_out_sgpr) {
             /* Skip returned SGPRs the current part doesn't
              * declare on the input. */
-- 
GitLab


From e51851e5f466a3db7ea8254e313be18e35dc5a45 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 05:22:48 -0500
Subject: [PATCH 09/14] ac/llvm: don't set "convergent" on intrinsics where
 it's automatic

LLVM adds the flag automatically.
---
 src/amd/llvm/ac_llvm_build.c                  | 27 +++++++++----------
 src/amd/llvm/ac_nir_to_llvm.c                 |  4 +--
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  3 +--
 3 files changed, 16 insertions(+), 18 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 447f32e03efd..04ca1c5b9bc2 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -398,7 +398,7 @@ void ac_build_s_barrier(struct ac_llvm_context *ctx, gl_shader_stage stage)
    if (ctx->gfx_level == GFX6 && stage == MESA_SHADER_TESS_CTRL)
       return;
 
-   ac_build_intrinsic(ctx, "llvm.amdgcn.s.barrier", ctx->voidt, NULL, 0, AC_FUNC_ATTR_CONVERGENT);
+   ac_build_intrinsic(ctx, "llvm.amdgcn.s.barrier", ctx->voidt, NULL, 0, 0);
 }
 
 /* Prevent optimizations (at least of memory accesses) across the current
@@ -512,7 +512,7 @@ LLVMValueRef ac_build_ballot(struct ac_llvm_context *ctx, LLVMValueRef value)
 
    return ac_build_intrinsic(
       ctx, name, ctx->iN_wavemask, args, 3,
-      AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+      AC_FUNC_ATTR_READNONE);
 }
 
 LLVMValueRef ac_get_i1_sgpr_mask(struct ac_llvm_context *ctx, LLVMValueRef value)
@@ -532,7 +532,7 @@ LLVMValueRef ac_get_i1_sgpr_mask(struct ac_llvm_context *ctx, LLVMValueRef value
 
    return ac_build_intrinsic(
       ctx, name, ctx->iN_wavemask, args, 3,
-      AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+      AC_FUNC_ATTR_READNONE);
 }
 
 LLVMValueRef ac_build_vote_all(struct ac_llvm_context *ctx, LLVMValueRef value)
@@ -2790,8 +2790,7 @@ LLVMValueRef ac_build_sudot_4x8(struct ac_llvm_context *ctx, LLVMValueRef s0, LL
 void ac_init_exec_full_mask(struct ac_llvm_context *ctx)
 {
    LLVMValueRef full_mask = LLVMConstInt(ctx->i64, ~0ull, 0);
-   ac_build_intrinsic(ctx, "llvm.amdgcn.init.exec", ctx->voidt, &full_mask, 1,
-                      AC_FUNC_ATTR_CONVERGENT);
+   ac_build_intrinsic(ctx, "llvm.amdgcn.init.exec", ctx->voidt, &full_mask, 1, 0);
 }
 
 void ac_declare_lds_as_pointer(struct ac_llvm_context *ctx)
@@ -3224,7 +3223,7 @@ static LLVMValueRef _ac_build_readlane(struct ac_llvm_context *ctx, LLVMValueRef
    result =
       ac_build_intrinsic(ctx, lane == NULL ? "llvm.amdgcn.readfirstlane" : "llvm.amdgcn.readlane",
                          ctx->i32, (LLVMValueRef[]){src, lane}, lane == NULL ? 1 : 2,
-                         AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                         AC_FUNC_ATTR_READNONE);
 
    return LLVMBuildTrunc(ctx->builder, result, type, "");
 }
@@ -3288,7 +3287,7 @@ LLVMValueRef ac_build_writelane(struct ac_llvm_context *ctx, LLVMValueRef src, L
 {
    return ac_build_intrinsic(ctx, "llvm.amdgcn.writelane", ctx->i32,
                              (LLVMValueRef[]){value, lane, src}, 3,
-                             AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                             AC_FUNC_ATTR_READNONE);
 }
 
 LLVMValueRef ac_build_mbcnt_add(struct ac_llvm_context *ctx, LLVMValueRef mask, LLVMValueRef add_src)
@@ -3372,7 +3371,7 @@ static LLVMValueRef _ac_build_dpp(struct ac_llvm_context *ctx, LLVMValueRef old,
       (LLVMValueRef[]){old, src, LLVMConstInt(ctx->i32, dpp_ctrl, 0),
                        LLVMConstInt(ctx->i32, row_mask, 0), LLVMConstInt(ctx->i32, bank_mask, 0),
                        LLVMConstInt(ctx->i1, bound_ctrl, 0)},
-      6, AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+      6, AC_FUNC_ATTR_READNONE);
 
    return LLVMBuildTrunc(ctx->builder, res, type, "");
 }
@@ -3425,7 +3424,7 @@ static LLVMValueRef _ac_build_permlane16(struct ac_llvm_context *ctx, LLVMValueR
 
    result =
       ac_build_intrinsic(ctx, exchange_rows ? "llvm.amdgcn.permlanex16" : "llvm.amdgcn.permlane16",
-                         ctx->i32, args, 6, AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                         ctx->i32, args, 6, AC_FUNC_ATTR_READNONE);
 
    return LLVMBuildTrunc(ctx->builder, result, type, "");
 }
@@ -3470,7 +3469,7 @@ static LLVMValueRef _ac_build_ds_swizzle(struct ac_llvm_context *ctx, LLVMValueR
 
    ret = ac_build_intrinsic(ctx, "llvm.amdgcn.ds.swizzle", ctx->i32,
                             (LLVMValueRef[]){src, LLVMConstInt(ctx->i32, mask, 0)}, 2,
-                            AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                            AC_FUNC_ATTR_READNONE);
 
    return LLVMBuildTrunc(ctx->builder, ret, src_type, "");
 }
@@ -3539,7 +3538,7 @@ static LLVMValueRef ac_build_set_inactive(struct ac_llvm_context *ctx, LLVMValue
    snprintf(name, sizeof(name), "llvm.amdgcn.set.inactive.%s", type);
    LLVMValueRef ret =
       ac_build_intrinsic(ctx, name, LLVMTypeOf(src), (LLVMValueRef[]){src, inactive}, 2,
-                         AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                         AC_FUNC_ATTR_READNONE);
    if (bitsize < 32)
       ret = LLVMBuildTrunc(ctx->builder, ret, src_type, "");
 
@@ -4203,7 +4202,7 @@ static void _ac_build_dual_src_blend_swizzle(struct ac_llvm_context *ctx,
    params[0] = src0;
    params[1] = LLVMConstInt(ctx->i32, 0xde54c1, 0);
    src0 = ac_build_intrinsic(ctx, "llvm.amdgcn.mov.dpp8.i32",
-                             ctx->i32, params, 2, AC_FUNC_ATTR_CONVERGENT);
+                             ctx->i32, params, 2, 0);
 
    /* swap even lanes between arg_0 and arg_1 */
    tid = ac_get_thread_id(ctx);
@@ -4218,7 +4217,7 @@ static void _ac_build_dual_src_blend_swizzle(struct ac_llvm_context *ctx,
    params[0] = src0;
    params[1] = LLVMConstInt(ctx->i32, 0xde54c1, 0);
    src0 = ac_build_intrinsic(ctx, "llvm.amdgcn.mov.dpp8.i32",
-                             ctx->i32, params, 2, AC_FUNC_ATTR_CONVERGENT);
+                             ctx->i32, params, 2, 0);
 
    *arg0 = src0;
    *arg1 = src1;
@@ -4258,7 +4257,7 @@ LLVMValueRef ac_build_shuffle(struct ac_llvm_context *ctx, LLVMValueRef src, LLV
 
    result =
       ac_build_intrinsic(ctx, "llvm.amdgcn.ds.bpermute", ctx->i32, (LLVMValueRef[]){index, src}, 2,
-                         AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                         AC_FUNC_ATTR_READNONE);
    return LLVMBuildTrunc(ctx->builder, result, type, "");
 }
 
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 015cc1ff9d46..4d014fd50e43 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4073,7 +4073,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
 
          result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.readlane", ctx->ac.i32,
                                      (LLVMValueRef[]){src, index_val}, 2,
-                                     AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                                     AC_FUNC_ATTR_READNONE);
 
          result = LLVMBuildTrunc(ctx->ac.builder, result, type, "");
 
@@ -4355,7 +4355,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
                                                    get_src(ctx, instr->src[2]),
                                                    ctx->ac.i1false,
                                                    ctx->ac.i1false},
-                                  6, AC_FUNC_ATTR_READNONE | AC_FUNC_ATTR_CONVERGENT);
+                                  6, AC_FUNC_ATTR_READNONE);
       break;
    case nir_intrinsic_load_force_vrs_rates_amd:
       result = ac_get_arg(&ctx->ac, ctx->args->force_vrs_rates);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 054f2c0dfebd..5a241c8140b2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -346,8 +346,7 @@ static void si_init_exec_from_input(struct si_shader_context *ctx, struct ac_arg
       ac_get_arg(&ctx->ac, param),
       LLVMConstInt(ctx->ac.i32, bitoffset, 0),
    };
-   ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.init.exec.from.input", ctx->ac.voidt, args, 2,
-                      AC_FUNC_ATTR_CONVERGENT);
+   ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.init.exec.from.input", ctx->ac.voidt, args, 2, 0);
 }
 
 /**
-- 
GitLab


From 184401f3dc5e23b092ad74f4d5429ed79f3a3276 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 06:00:15 -0500
Subject: [PATCH 10/14] ac/llvm: don't set "readnone" on non-memory intrinsics

It's illegal and LLVM always knows which intrinsics don't read memory.
This started failing IR validation with LLVM 16.
---
 src/amd/llvm/ac_llvm_build.c      | 173 ++++++++++++------------------
 src/amd/llvm/ac_nir_to_llvm.c     |  63 +++++------
 src/amd/vulkan/radv_nir_to_llvm.c |   5 +-
 3 files changed, 99 insertions(+), 142 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 04ca1c5b9bc2..0a79b6bb6706 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -510,9 +510,7 @@ LLVMValueRef ac_build_ballot(struct ac_llvm_context *ctx, LLVMValueRef value)
 
    args[0] = ac_to_integer(ctx, args[0]);
 
-   return ac_build_intrinsic(
-      ctx, name, ctx->iN_wavemask, args, 3,
-      AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, ctx->iN_wavemask, args, 3, 0);
 }
 
 LLVMValueRef ac_get_i1_sgpr_mask(struct ac_llvm_context *ctx, LLVMValueRef value)
@@ -530,9 +528,7 @@ LLVMValueRef ac_get_i1_sgpr_mask(struct ac_llvm_context *ctx, LLVMValueRef value
       LLVMConstInt(ctx->i32, LLVMIntNE, 0),
    };
 
-   return ac_build_intrinsic(
-      ctx, name, ctx->iN_wavemask, args, 3,
-      AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, ctx->iN_wavemask, args, 3, 0);
 }
 
 LLVMValueRef ac_build_vote_all(struct ac_llvm_context *ctx, LLVMValueRef value)
@@ -694,7 +690,7 @@ LLVMValueRef ac_build_round(struct ac_llvm_context *ctx, LLVMValueRef value)
    else
       name = "llvm.rint.f64";
 
-   return ac_build_intrinsic(ctx, name, LLVMTypeOf(value), &value, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, LLVMTypeOf(value), &value, 1, 0);
 }
 
 LLVMValueRef ac_build_fdiv(struct ac_llvm_context *ctx, LLVMValueRef num, LLVMValueRef den)
@@ -714,7 +710,7 @@ LLVMValueRef ac_build_fdiv(struct ac_llvm_context *ctx, LLVMValueRef num, LLVMVa
       name = "llvm.amdgcn.rcp.f64";
 
    LLVMValueRef rcp =
-      ac_build_intrinsic(ctx, name, LLVMTypeOf(den), &den, 1, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, name, LLVMTypeOf(den), &den, 1, 0);
 
    return LLVMBuildFMul(ctx->builder, num, rcp, "");
 }
@@ -783,10 +779,10 @@ static void build_cube_intrinsic(struct ac_llvm_context *ctx, LLVMValueRef in[3]
 {
    LLVMTypeRef f32 = ctx->f32;
 
-   out->stc[1] = ac_build_intrinsic(ctx, "llvm.amdgcn.cubetc", f32, in, 3, AC_FUNC_ATTR_READNONE);
-   out->stc[0] = ac_build_intrinsic(ctx, "llvm.amdgcn.cubesc", f32, in, 3, AC_FUNC_ATTR_READNONE);
-   out->ma = ac_build_intrinsic(ctx, "llvm.amdgcn.cubema", f32, in, 3, AC_FUNC_ATTR_READNONE);
-   out->id = ac_build_intrinsic(ctx, "llvm.amdgcn.cubeid", f32, in, 3, AC_FUNC_ATTR_READNONE);
+   out->stc[1] = ac_build_intrinsic(ctx, "llvm.amdgcn.cubetc", f32, in, 3, 0);
+   out->stc[0] = ac_build_intrinsic(ctx, "llvm.amdgcn.cubesc", f32, in, 3, 0);
+   out->ma = ac_build_intrinsic(ctx, "llvm.amdgcn.cubema", f32, in, 3, 0);
+   out->id = ac_build_intrinsic(ctx, "llvm.amdgcn.cubeid", f32, in, 3, 0);
 }
 
 /**
@@ -839,7 +835,7 @@ static void build_cube_select(struct ac_llvm_context *ctx,
    /* Select ma */
    tmp = LLVMBuildSelect(builder, is_ma_z, coords[2],
                          LLVMBuildSelect(builder, is_ma_y, coords[1], coords[0], ""), "");
-   tmp = ac_build_intrinsic(ctx, "llvm.fabs.f32", ctx->f32, &tmp, 1, AC_FUNC_ATTR_READNONE);
+   tmp = ac_build_intrinsic(ctx, "llvm.fabs.f32", ctx->f32, &tmp, 1, 0);
    *out_ma = LLVMBuildFMul(builder, tmp, LLVMConstReal(f32, 2.0), "");
 }
 
@@ -886,7 +882,7 @@ void ac_prepare_cube_coords(struct ac_llvm_context *ctx, bool is_deriv, bool is_
    build_cube_intrinsic(ctx, coords_arg, &selcoords);
 
    invma =
-      ac_build_intrinsic(ctx, "llvm.fabs.f32", ctx->f32, &selcoords.ma, 1, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.fabs.f32", ctx->f32, &selcoords.ma, 1, 0);
    invma = ac_build_fdiv(ctx, LLVMConstReal(ctx->f32, 1.0), invma);
 
    for (int i = 0; i < 2; ++i)
@@ -967,21 +963,21 @@ LLVMValueRef ac_build_fs_interp(struct ac_llvm_context *ctx, LLVMValueRef llvm_c
       args[2] = params;
 
       p = ac_build_intrinsic(ctx, "llvm.amdgcn.lds.param.load",
-                             ctx->f32, args, 3, AC_FUNC_ATTR_READNONE);
+                             ctx->f32, args, 3, 0);
 
       args[0] = p;
       args[1] = i;
       args[2] = p;
 
       p10 = ac_build_intrinsic(ctx, "llvm.amdgcn.interp.inreg.p10",
-                               ctx->f32, args, 3, AC_FUNC_ATTR_READNONE);
+                               ctx->f32, args, 3, 0);
 
       args[0] = p;
       args[1] = j;
       args[2] = p10;
 
       return ac_build_intrinsic(ctx, "llvm.amdgcn.interp.inreg.p2",
-                                ctx->f32, args, 3, AC_FUNC_ATTR_READNONE);
+                                ctx->f32, args, 3, 0);
 
    } else {
       LLVMValueRef p1;
@@ -992,7 +988,7 @@ LLVMValueRef ac_build_fs_interp(struct ac_llvm_context *ctx, LLVMValueRef llvm_c
       args[3] = params;
 
       p1 = ac_build_intrinsic(ctx, "llvm.amdgcn.interp.p1",
-                              ctx->f32, args, 4, AC_FUNC_ATTR_READNONE);
+                              ctx->f32, args, 4, 0);
 
       args[0] = p1;
       args[1] = j;
@@ -1001,7 +997,7 @@ LLVMValueRef ac_build_fs_interp(struct ac_llvm_context *ctx, LLVMValueRef llvm_c
       args[4] = params;
 
       return ac_build_intrinsic(ctx, "llvm.amdgcn.interp.p2",
-                                ctx->f32, args, 5, AC_FUNC_ATTR_READNONE);
+                                ctx->f32, args, 5, 0);
    }
 }
 
@@ -1020,7 +1016,7 @@ LLVMValueRef ac_build_fs_interp_f16(struct ac_llvm_context *ctx, LLVMValueRef ll
       args[2] = params;
 
       p = ac_build_intrinsic(ctx, "llvm.amdgcn.lds.param.load",
-                             ctx->f32, args, 3, AC_FUNC_ATTR_READNONE);
+                             ctx->f32, args, 3, 0);
 
       args[0] = p;
       args[1] = i;
@@ -1028,7 +1024,7 @@ LLVMValueRef ac_build_fs_interp_f16(struct ac_llvm_context *ctx, LLVMValueRef ll
       args[3] = high_16bits ? ctx->i1true : ctx->i1false;
 
       p10 = ac_build_intrinsic(ctx, "llvm.amdgcn.interp.inreg.p10.f16",
-                               ctx->f32, args, 4, AC_FUNC_ATTR_READNONE);
+                               ctx->f32, args, 4, 0);
 
       args[0] = p;
       args[1] = j;
@@ -1036,7 +1032,7 @@ LLVMValueRef ac_build_fs_interp_f16(struct ac_llvm_context *ctx, LLVMValueRef ll
       args[3] = high_16bits ? ctx->i1true : ctx->i1false;
 
       return ac_build_intrinsic(ctx, "llvm.amdgcn.interp.inreg.p2.f16",
-                                ctx->f16, args, 4, AC_FUNC_ATTR_READNONE);
+                                ctx->f16, args, 4, 0);
 
    } else {
       LLVMValueRef p1;
@@ -1048,7 +1044,7 @@ LLVMValueRef ac_build_fs_interp_f16(struct ac_llvm_context *ctx, LLVMValueRef ll
       args[4] = params;
 
       p1 = ac_build_intrinsic(ctx, "llvm.amdgcn.interp.p1.f16", ctx->f32, args, 5,
-                              AC_FUNC_ATTR_READNONE);
+                              0);
 
       args[0] = p1;
       args[1] = j;
@@ -1058,7 +1054,7 @@ LLVMValueRef ac_build_fs_interp_f16(struct ac_llvm_context *ctx, LLVMValueRef ll
       args[5] = params;
 
       return ac_build_intrinsic(ctx, "llvm.amdgcn.interp.p2.f16", ctx->f16, args, 6,
-                                AC_FUNC_ATTR_READNONE);
+                                0);
    }
 }
 
@@ -1076,17 +1072,16 @@ LLVMValueRef ac_build_fs_interp_mov(struct ac_llvm_context *ctx, LLVMValueRef pa
       args[2] = params;
 
       p = ac_build_intrinsic(ctx, "llvm.amdgcn.lds.param.load",
-                             ctx->f32, args, 3, AC_FUNC_ATTR_READNONE);
+                             ctx->f32, args, 3, 0);
       p = ac_build_quad_swizzle(ctx, p, 0, 0, 0 ,0);
-      return ac_build_intrinsic(ctx, "llvm.amdgcn.wqm.f32", ctx->f32, &p, 1, AC_FUNC_ATTR_READNONE);
+      return ac_build_intrinsic(ctx, "llvm.amdgcn.wqm.f32", ctx->f32, &p, 1, 0);
    } else {
       args[0] = parameter;
       args[1] = llvm_chan;
       args[2] = attr_number;
       args[3] = params;
 
-      return ac_build_intrinsic(ctx, "llvm.amdgcn.interp.mov", ctx->f32, args, 4,
-                                AC_FUNC_ATTR_READNONE);
+      return ac_build_intrinsic(ctx, "llvm.amdgcn.interp.mov", ctx->f32, args, 4, 0);
    }
 }
 
@@ -1502,7 +1497,7 @@ static LLVMValueRef ac_ufN_to_float(struct ac_llvm_context *ctx, LLVMValueRef sr
       mantissa, ctx->i1true, /* result can be undef when arg is 0 */
    };
    LLVMValueRef ctlz =
-      ac_build_intrinsic(ctx, "llvm.ctlz.i32", ctx->i32, params, 2, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.ctlz.i32", ctx->i32, params, 2, 0);
 
    /* Shift such that the leading 1 ends up as the LSB of the exponent field. */
    tmp = LLVMBuildSub(ctx->builder, ctlz, LLVMConstInt(ctx->i32, 8, false), "");
@@ -1872,7 +1867,7 @@ void ac_build_sendmsg(struct ac_llvm_context *ctx, uint32_t msg, LLVMValueRef wa
 LLVMValueRef ac_build_imsb(struct ac_llvm_context *ctx, LLVMValueRef arg, LLVMTypeRef dst_type)
 {
    LLVMValueRef msb =
-      ac_build_intrinsic(ctx, "llvm.amdgcn.sffbh.i32", dst_type, &arg, 1, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.amdgcn.sffbh.i32", dst_type, &arg, 1, 0);
 
    /* The HW returns the last bit index from MSB, but NIR/TGSI wants
     * the index from LSB. Invert it by doing "31 - msb". */
@@ -1931,7 +1926,7 @@ LLVMValueRef ac_build_umsb(struct ac_llvm_context *ctx, LLVMValueRef arg, LLVMTy
       ctx->i1true,
    };
 
-   LLVMValueRef msb = ac_build_intrinsic(ctx, intrin_name, type, params, 2, AC_FUNC_ATTR_READNONE);
+   LLVMValueRef msb = ac_build_intrinsic(ctx, intrin_name, type, params, 2, 0);
 
    if (!rev) {
       /* The HW returns the last bit index from MSB, but TGSI/NIR wants
@@ -1957,7 +1952,7 @@ LLVMValueRef ac_build_fmin(struct ac_llvm_context *ctx, LLVMValueRef a, LLVMValu
    ac_build_type_name_for_intr(LLVMTypeOf(a), type, sizeof(type));
    snprintf(name, sizeof(name), "llvm.minnum.%s", type);
    LLVMValueRef args[2] = {a, b};
-   return ac_build_intrinsic(ctx, name, LLVMTypeOf(a), args, 2, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, LLVMTypeOf(a), args, 2, 0);
 }
 
 LLVMValueRef ac_build_fmax(struct ac_llvm_context *ctx, LLVMValueRef a, LLVMValueRef b)
@@ -1967,7 +1962,7 @@ LLVMValueRef ac_build_fmax(struct ac_llvm_context *ctx, LLVMValueRef a, LLVMValu
    ac_build_type_name_for_intr(LLVMTypeOf(a), type, sizeof(type));
    snprintf(name, sizeof(name), "llvm.maxnum.%s", type);
    LLVMValueRef args[2] = {a, b};
-   return ac_build_intrinsic(ctx, name, LLVMTypeOf(a), args, 2, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, LLVMTypeOf(a), args, 2, 0);
 }
 
 LLVMValueRef ac_build_imin(struct ac_llvm_context *ctx, LLVMValueRef a, LLVMValueRef b)
@@ -2373,21 +2368,18 @@ LLVMValueRef ac_build_image_get_sample_count(struct ac_llvm_context *ctx, LLVMVa
 
 LLVMValueRef ac_build_cvt_pkrtz_f16(struct ac_llvm_context *ctx, LLVMValueRef args[2])
 {
-   return ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pkrtz", ctx->v2f16, args, 2,
-                             AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pkrtz", ctx->v2f16, args, 2, 0);
 }
 
 LLVMValueRef ac_build_cvt_pknorm_i16(struct ac_llvm_context *ctx, LLVMValueRef args[2])
 {
-   LLVMValueRef res = ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pknorm.i16", ctx->v2i16, args, 2,
-                                         AC_FUNC_ATTR_READNONE);
+   LLVMValueRef res = ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pknorm.i16", ctx->v2i16, args, 2, 0);
    return LLVMBuildBitCast(ctx->builder, res, ctx->i32, "");
 }
 
 LLVMValueRef ac_build_cvt_pknorm_u16(struct ac_llvm_context *ctx, LLVMValueRef args[2])
 {
-   LLVMValueRef res = ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pknorm.u16", ctx->v2i16, args, 2,
-                                         AC_FUNC_ATTR_READNONE);
+   LLVMValueRef res = ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pknorm.u16", ctx->v2i16, args, 2, 0);
    return LLVMBuildBitCast(ctx->builder, res, ctx->i32, "");
 }
 
@@ -2438,7 +2430,7 @@ LLVMValueRef ac_build_cvt_pk_i16(struct ac_llvm_context *ctx, LLVMValueRef args[
    }
 
    LLVMValueRef res =
-      ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pk.i16", ctx->v2i16, args, 2, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pk.i16", ctx->v2i16, args, 2, 0);
    return LLVMBuildBitCast(ctx->builder, res, ctx->i32, "");
 }
 
@@ -2460,13 +2452,13 @@ LLVMValueRef ac_build_cvt_pk_u16(struct ac_llvm_context *ctx, LLVMValueRef args[
    }
 
    LLVMValueRef res =
-      ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pk.u16", ctx->v2i16, args, 2, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.amdgcn.cvt.pk.u16", ctx->v2i16, args, 2, 0);
    return LLVMBuildBitCast(ctx->builder, res, ctx->i32, "");
 }
 
 LLVMValueRef ac_build_wqm_vote(struct ac_llvm_context *ctx, LLVMValueRef i1)
 {
-   return ac_build_intrinsic(ctx, "llvm.amdgcn.wqm.vote", ctx->i1, &i1, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, "llvm.amdgcn.wqm.vote", ctx->i1, &i1, 1, 0);
 }
 
 void ac_build_kill_if_false(struct ac_llvm_context *ctx, LLVMValueRef i1)
@@ -2484,7 +2476,7 @@ LLVMValueRef ac_build_bfe(struct ac_llvm_context *ctx, LLVMValueRef input, LLVMV
    };
 
    return ac_build_intrinsic(ctx, is_signed ? "llvm.amdgcn.sbfe.i32" : "llvm.amdgcn.ubfe.i32",
-                             ctx->i32, args, 3, AC_FUNC_ATTR_READNONE);
+                             ctx->i32, args, 3, 0);
 }
 
 LLVMValueRef ac_build_imad(struct ac_llvm_context *ctx, LLVMValueRef s0, LLVMValueRef s1,
@@ -2497,10 +2489,8 @@ LLVMValueRef ac_build_fmad(struct ac_llvm_context *ctx, LLVMValueRef s0, LLVMVal
                            LLVMValueRef s2)
 {
    /* FMA is better on GFX10, because it has FMA units instead of MUL-ADD units. */
-   if (ctx->gfx_level >= GFX10) {
-      return ac_build_intrinsic(ctx, "llvm.fma.f32", ctx->f32, (LLVMValueRef[]){s0, s1, s2}, 3,
-                                AC_FUNC_ATTR_READNONE);
-   }
+   if (ctx->gfx_level >= GFX10)
+      return ac_build_intrinsic(ctx, "llvm.fma.f32", ctx->f32, (LLVMValueRef[]){s0, s1, s2}, 3, 0);
 
    return LLVMBuildFAdd(ctx->builder, LLVMBuildFMul(ctx->builder, s0, s1, ""), s2, "");
 }
@@ -2582,8 +2572,7 @@ LLVMValueRef ac_build_fsat(struct ac_llvm_context *ctx, LLVMValueRef src,
          src,
       };
 
-      result = ac_build_intrinsic(ctx, intr, type, params, 3,
-                                  AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(ctx, intr, type, params, 3, 0);
    }
 
    if (ctx->gfx_level < GFX9 && bitsize == 32) {
@@ -2613,7 +2602,7 @@ LLVMValueRef ac_build_fract(struct ac_llvm_context *ctx, LLVMValueRef src0, unsi
    LLVMValueRef params[] = {
       src0,
    };
-   return ac_build_intrinsic(ctx, intr, type, params, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, intr, type, params, 1, 0);
 }
 
 LLVMValueRef ac_const_uint_vec(struct ac_llvm_context *ctx, LLVMTypeRef type, uint64_t value)
@@ -2699,30 +2688,22 @@ LLVMValueRef ac_build_bit_count(struct ac_llvm_context *ctx, LLVMValueRef src0)
 
    switch (bitsize) {
    case 128:
-      result = ac_build_intrinsic(ctx, "llvm.ctpop.i128", ctx->i128, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(ctx, "llvm.ctpop.i128", ctx->i128, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildTrunc(ctx->builder, result, ctx->i32, "");
       break;
    case 64:
-      result = ac_build_intrinsic(ctx, "llvm.ctpop.i64", ctx->i64, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
-
+      result = ac_build_intrinsic(ctx, "llvm.ctpop.i64", ctx->i64, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildTrunc(ctx->builder, result, ctx->i32, "");
       break;
    case 32:
-      result = ac_build_intrinsic(ctx, "llvm.ctpop.i32", ctx->i32, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(ctx, "llvm.ctpop.i32", ctx->i32, (LLVMValueRef[]){src0}, 1, 0);
       break;
    case 16:
-      result = ac_build_intrinsic(ctx, "llvm.ctpop.i16", ctx->i16, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
-
+      result = ac_build_intrinsic(ctx, "llvm.ctpop.i16", ctx->i16, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildZExt(ctx->builder, result, ctx->i32, "");
       break;
    case 8:
-      result = ac_build_intrinsic(ctx, "llvm.ctpop.i8", ctx->i8, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
-
+      result = ac_build_intrinsic(ctx, "llvm.ctpop.i8", ctx->i8, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildZExt(ctx->builder, result, ctx->i32, "");
       break;
    default:
@@ -2742,25 +2723,18 @@ LLVMValueRef ac_build_bitfield_reverse(struct ac_llvm_context *ctx, LLVMValueRef
 
    switch (bitsize) {
    case 64:
-      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i64", ctx->i64, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
-
+      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i64", ctx->i64, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildTrunc(ctx->builder, result, ctx->i32, "");
       break;
    case 32:
-      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i32", ctx->i32, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i32", ctx->i32, (LLVMValueRef[]){src0}, 1, 0);
       break;
    case 16:
-      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i16", ctx->i16, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
-
+      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i16", ctx->i16, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildZExt(ctx->builder, result, ctx->i32, "");
       break;
    case 8:
-      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i8", ctx->i8, (LLVMValueRef[]){src0}, 1,
-                                  AC_FUNC_ATTR_READNONE);
-
+      result = ac_build_intrinsic(ctx, "llvm.bitreverse.i8", ctx->i8, (LLVMValueRef[]){src0}, 1, 0);
       result = LLVMBuildZExt(ctx->builder, result, ctx->i32, "");
       break;
    default:
@@ -2784,7 +2758,7 @@ LLVMValueRef ac_build_sudot_4x8(struct ac_llvm_context *ctx, LLVMValueRef s0, LL
    src[4] = s2;
    src[5] = LLVMConstInt(ctx->i1, clamp, false);
 
-   return ac_build_intrinsic(ctx, name, ctx->i32, src, 6, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, ctx->i32, src, 6, 0);
 }
 
 void ac_init_exec_full_mask(struct ac_llvm_context *ctx)
@@ -2863,7 +2837,7 @@ LLVMValueRef ac_find_lsb(struct ac_llvm_context *ctx, LLVMTypeRef dst_type, LLVM
       ctx->i1true,
    };
 
-   LLVMValueRef lsb = ac_build_intrinsic(ctx, intrin_name, type, params, 2, AC_FUNC_ATTR_READNONE);
+   LLVMValueRef lsb = ac_build_intrinsic(ctx, intrin_name, type, params, 2, 0);
 
    if (src0_bitsize == 64) {
       lsb = LLVMBuildTrunc(ctx->builder, lsb, ctx->i32, "");
@@ -3222,8 +3196,7 @@ static LLVMValueRef _ac_build_readlane(struct ac_llvm_context *ctx, LLVMValueRef
 
    result =
       ac_build_intrinsic(ctx, lane == NULL ? "llvm.amdgcn.readfirstlane" : "llvm.amdgcn.readlane",
-                         ctx->i32, (LLVMValueRef[]){src, lane}, lane == NULL ? 1 : 2,
-                         AC_FUNC_ATTR_READNONE);
+                         ctx->i32, (LLVMValueRef[]){src, lane}, lane == NULL ? 1 : 2, 0);
 
    return LLVMBuildTrunc(ctx->builder, result, type, "");
 }
@@ -3286,8 +3259,7 @@ LLVMValueRef ac_build_writelane(struct ac_llvm_context *ctx, LLVMValueRef src, L
                                 LLVMValueRef lane)
 {
    return ac_build_intrinsic(ctx, "llvm.amdgcn.writelane", ctx->i32,
-                             (LLVMValueRef[]){value, lane, src}, 3,
-                             AC_FUNC_ATTR_READNONE);
+                             (LLVMValueRef[]){value, lane, src}, 3, 0);
 }
 
 LLVMValueRef ac_build_mbcnt_add(struct ac_llvm_context *ctx, LLVMValueRef mask, LLVMValueRef add_src)
@@ -3297,15 +3269,15 @@ LLVMValueRef ac_build_mbcnt_add(struct ac_llvm_context *ctx, LLVMValueRef mask,
 
    if (ctx->wave_size == 32) {
       val = ac_build_intrinsic(ctx, "llvm.amdgcn.mbcnt.lo", ctx->i32,
-                               (LLVMValueRef[]){mask, add}, 2, AC_FUNC_ATTR_READNONE);
+                               (LLVMValueRef[]){mask, add}, 2, 0);
    } else {
       LLVMValueRef mask_vec = LLVMBuildBitCast(ctx->builder, mask, ctx->v2i32, "");
       LLVMValueRef mask_lo = LLVMBuildExtractElement(ctx->builder, mask_vec, ctx->i32_0, "");
       LLVMValueRef mask_hi = LLVMBuildExtractElement(ctx->builder, mask_vec, ctx->i32_1, "");
       val = ac_build_intrinsic(ctx, "llvm.amdgcn.mbcnt.lo", ctx->i32,
-                               (LLVMValueRef[]){mask_lo, add}, 2, AC_FUNC_ATTR_READNONE);
+                               (LLVMValueRef[]){mask_lo, add}, 2, 0);
       val = ac_build_intrinsic(ctx, "llvm.amdgcn.mbcnt.hi", ctx->i32, (LLVMValueRef[]){mask_hi, val},
-                               2, AC_FUNC_ATTR_READNONE);
+                               2, 0);
    }
 
    if (add == ctx->i32_0)
@@ -3371,7 +3343,7 @@ static LLVMValueRef _ac_build_dpp(struct ac_llvm_context *ctx, LLVMValueRef old,
       (LLVMValueRef[]){old, src, LLVMConstInt(ctx->i32, dpp_ctrl, 0),
                        LLVMConstInt(ctx->i32, row_mask, 0), LLVMConstInt(ctx->i32, bank_mask, 0),
                        LLVMConstInt(ctx->i1, bound_ctrl, 0)},
-      6, AC_FUNC_ATTR_READNONE);
+      6, 0);
 
    return LLVMBuildTrunc(ctx->builder, res, type, "");
 }
@@ -3424,7 +3396,7 @@ static LLVMValueRef _ac_build_permlane16(struct ac_llvm_context *ctx, LLVMValueR
 
    result =
       ac_build_intrinsic(ctx, exchange_rows ? "llvm.amdgcn.permlanex16" : "llvm.amdgcn.permlane16",
-                         ctx->i32, args, 6, AC_FUNC_ATTR_READNONE);
+                         ctx->i32, args, 6, 0);
 
    return LLVMBuildTrunc(ctx->builder, result, type, "");
 }
@@ -3469,7 +3441,7 @@ static LLVMValueRef _ac_build_ds_swizzle(struct ac_llvm_context *ctx, LLVMValueR
 
    ret = ac_build_intrinsic(ctx, "llvm.amdgcn.ds.swizzle", ctx->i32,
                             (LLVMValueRef[]){src, LLVMConstInt(ctx->i32, mask, 0)}, 2,
-                            AC_FUNC_ATTR_READNONE);
+                            0);
 
    return LLVMBuildTrunc(ctx->builder, ret, src_type, "");
 }
@@ -3511,8 +3483,7 @@ static LLVMValueRef ac_build_wwm(struct ac_llvm_context *ctx, LLVMValueRef src)
 
    ac_build_type_name_for_intr(LLVMTypeOf(src), type, sizeof(type));
    snprintf(name, sizeof(name), "llvm.amdgcn.wwm.%s", type);
-   ret = ac_build_intrinsic(ctx, name, LLVMTypeOf(src), (LLVMValueRef[]){src}, 1,
-                            AC_FUNC_ATTR_READNONE);
+   ret = ac_build_intrinsic(ctx, name, LLVMTypeOf(src), (LLVMValueRef[]){src}, 1, 0);
 
    if (bitsize < 32)
       ret = LLVMBuildTrunc(ctx->builder, ret, ac_to_integer_type(ctx, src_type), "");
@@ -3537,8 +3508,7 @@ static LLVMValueRef ac_build_set_inactive(struct ac_llvm_context *ctx, LLVMValue
    ac_build_type_name_for_intr(LLVMTypeOf(src), type, sizeof(type));
    snprintf(name, sizeof(name), "llvm.amdgcn.set.inactive.%s", type);
    LLVMValueRef ret =
-      ac_build_intrinsic(ctx, name, LLVMTypeOf(src), (LLVMValueRef[]){src, inactive}, 2,
-                         AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, name, LLVMTypeOf(src), (LLVMValueRef[]){src, inactive}, 2, 0);
    if (bitsize < 32)
       ret = LLVMBuildTrunc(ctx->builder, ret, src_type, "");
 
@@ -3701,8 +3671,7 @@ static LLVMValueRef ac_build_alu_op(struct ac_llvm_context *ctx, LLVMValueRef lh
    case nir_op_fmin:
       return ac_build_intrinsic(
          ctx, _64bit ? "llvm.minnum.f64" : _32bit ? "llvm.minnum.f32" : "llvm.minnum.f16",
-         _64bit ? ctx->f64 : _32bit ? ctx->f32 : ctx->f16, (LLVMValueRef[]){lhs, rhs}, 2,
-         AC_FUNC_ATTR_READNONE);
+         _64bit ? ctx->f64 : _32bit ? ctx->f32 : ctx->f16, (LLVMValueRef[]){lhs, rhs}, 2, 0);
    case nir_op_imax:
       return LLVMBuildSelect(ctx->builder, LLVMBuildICmp(ctx->builder, LLVMIntSGT, lhs, rhs, ""),
                              lhs, rhs, "");
@@ -3712,8 +3681,7 @@ static LLVMValueRef ac_build_alu_op(struct ac_llvm_context *ctx, LLVMValueRef lh
    case nir_op_fmax:
       return ac_build_intrinsic(
          ctx, _64bit ? "llvm.maxnum.f64" : _32bit ? "llvm.maxnum.f32" : "llvm.maxnum.f16",
-         _64bit ? ctx->f64 : _32bit ? ctx->f32 : ctx->f16, (LLVMValueRef[]){lhs, rhs}, 2,
-         AC_FUNC_ATTR_READNONE);
+         _64bit ? ctx->f64 : _32bit ? ctx->f32 : ctx->f16, (LLVMValueRef[]){lhs, rhs}, 2, 0);
    case nir_op_iand:
       return LLVMBuildAnd(ctx->builder, lhs, rhs, "");
    case nir_op_ior:
@@ -4256,8 +4224,7 @@ LLVMValueRef ac_build_shuffle(struct ac_llvm_context *ctx, LLVMValueRef src, LLV
    src = LLVMBuildZExt(ctx->builder, src, ctx->i32, "");
 
    result =
-      ac_build_intrinsic(ctx, "llvm.amdgcn.ds.bpermute", ctx->i32, (LLVMValueRef[]){index, src}, 2,
-                         AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.amdgcn.ds.bpermute", ctx->i32, (LLVMValueRef[]){index, src}, 2, 0);
    return LLVMBuildTrunc(ctx->builder, result, type, "");
 }
 
@@ -4280,7 +4247,7 @@ LLVMValueRef ac_build_frexp_exp(struct ac_llvm_context *ctx, LLVMValueRef src0,
    LLVMValueRef params[] = {
       src0,
    };
-   return ac_build_intrinsic(ctx, intr, type, params, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, intr, type, params, 1, 0);
 }
 LLVMValueRef ac_build_frexp_mant(struct ac_llvm_context *ctx, LLVMValueRef src0, unsigned bitsize)
 {
@@ -4301,7 +4268,7 @@ LLVMValueRef ac_build_frexp_mant(struct ac_llvm_context *ctx, LLVMValueRef src0,
    LLVMValueRef params[] = {
       src0,
    };
-   return ac_build_intrinsic(ctx, intr, type, params, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, intr, type, params, 1, 0);
 }
 
 LLVMValueRef ac_build_canonicalize(struct ac_llvm_context *ctx, LLVMValueRef src0, unsigned bitsize)
@@ -4323,7 +4290,7 @@ LLVMValueRef ac_build_canonicalize(struct ac_llvm_context *ctx, LLVMValueRef src
    LLVMValueRef params[] = {
       src0,
    };
-   return ac_build_intrinsic(ctx, intr, type, params, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, intr, type, params, 1, 0);
 }
 
 /*
@@ -4351,8 +4318,7 @@ LLVMValueRef ac_build_load_helper_invocation(struct ac_llvm_context *ctx)
    if (LLVM_VERSION_MAJOR >= 13) {
       result = ac_build_intrinsic(ctx, "llvm.amdgcn.live.mask", ctx->i1, NULL, 0, 0);
    } else {
-      result = ac_build_intrinsic(ctx, "llvm.amdgcn.ps.live", ctx->i1, NULL, 0,
-                                  AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(ctx, "llvm.amdgcn.ps.live", ctx->i1, NULL, 0, 0);
    }
    return LLVMBuildNot(ctx->builder, result, "");
 }
@@ -4367,7 +4333,7 @@ LLVMValueRef ac_build_is_helper_invocation(struct ac_llvm_context *ctx)
 
    /* !(exact && postponed) */
    LLVMValueRef exact =
-      ac_build_intrinsic(ctx, "llvm.amdgcn.ps.live", ctx->i1, NULL, 0, AC_FUNC_ATTR_READNONE);
+      ac_build_intrinsic(ctx, "llvm.amdgcn.ps.live", ctx->i1, NULL, 0, 0);
 
    LLVMValueRef postponed = LLVMBuildLoad2(ctx->builder, ctx->i1, ctx->postponed_kill, "");
    return LLVMBuildNot(ctx->builder, LLVMBuildAnd(ctx->builder, exact, postponed, ""), "");
@@ -4691,6 +4657,5 @@ LLVMValueRef ac_build_is_inf_or_nan(struct ac_llvm_context *ctx, LLVMValueRef a)
       a,
       LLVMConstInt(ctx->i32, S_NAN | Q_NAN | N_INFINITY | P_INFINITY, 0),
    };
-   return ac_build_intrinsic(ctx, "llvm.amdgcn.class.f32", ctx->i1, args, 2,
-                             AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, "llvm.amdgcn.class.f32", ctx->i1, args, 2, 0);
 }
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 4d014fd50e43..252f54316bd6 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -155,7 +155,7 @@ static LLVMValueRef emit_intrin_1f_param(struct ac_llvm_context *ctx, const char
    ac_build_type_name_for_intr(LLVMTypeOf(params[0]), type, sizeof(type));
    ASSERTED const int length = snprintf(name, sizeof(name), "%s.%s", intrin, type);
    assert(length < sizeof(name));
-   return ac_build_intrinsic(ctx, name, result_type, params, 1, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, result_type, params, 1, 0);
 }
 
 static LLVMValueRef emit_intrin_1f_param_scalar(struct ac_llvm_context *ctx, const char *intrin,
@@ -179,7 +179,7 @@ static LLVMValueRef emit_intrin_1f_param_scalar(struct ac_llvm_context *ctx, con
       assert(length < sizeof(name));
       ret = LLVMBuildInsertElement(
          ctx->builder, ret,
-         ac_build_intrinsic(ctx, name, elem_type, params, 1, AC_FUNC_ATTR_READNONE),
+         ac_build_intrinsic(ctx, name, elem_type, params, 1, 0),
          LLVMConstInt(ctx->i32, i, 0), "");
    }
    return ret;
@@ -198,7 +198,7 @@ static LLVMValueRef emit_intrin_2f_param(struct ac_llvm_context *ctx, const char
    ac_build_type_name_for_intr(LLVMTypeOf(params[0]), type, sizeof(type));
    ASSERTED const int length = snprintf(name, sizeof(name), "%s.%s", intrin, type);
    assert(length < sizeof(name));
-   return ac_build_intrinsic(ctx, name, result_type, params, 2, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, result_type, params, 2, 0);
 }
 
 static LLVMValueRef emit_intrin_3f_param(struct ac_llvm_context *ctx, const char *intrin,
@@ -215,7 +215,7 @@ static LLVMValueRef emit_intrin_3f_param(struct ac_llvm_context *ctx, const char
    ac_build_type_name_for_intr(LLVMTypeOf(params[0]), type, sizeof(type));
    ASSERTED const int length = snprintf(name, sizeof(name), "%s.%s", intrin, type);
    assert(length < sizeof(name));
-   return ac_build_intrinsic(ctx, name, result_type, params, 3, AC_FUNC_ATTR_READNONE);
+   return ac_build_intrinsic(ctx, name, result_type, params, 3, 0);
 }
 
 static LLVMValueRef emit_bcsel(struct ac_llvm_context *ctx, LLVMValueRef src0, LLVMValueRef src1,
@@ -250,7 +250,7 @@ static LLVMValueRef emit_uint_carry(struct ac_llvm_context *ctx, const char *int
    LLVMValueRef params[] = {src0, src1};
    ret_type = LLVMStructTypeInContext(ctx->context, types, 2, true);
 
-   res = ac_build_intrinsic(ctx, intrin, ret_type, params, 2, AC_FUNC_ATTR_READNONE);
+   res = ac_build_intrinsic(ctx, intrin, ret_type, params, 2, 0);
 
    res = LLVMBuildExtractValue(ctx->builder, res, 1, "");
    res = LLVMBuildZExt(ctx->builder, res, ctx->i32, "");
@@ -326,7 +326,7 @@ static LLVMValueRef emit_f2f16(struct ac_llvm_context *ctx, LLVMValueRef src0)
       args[0] = result;
       args[1] = LLVMConstInt(ctx->i32, N_SUBNORMAL | P_SUBNORMAL, false);
       cond =
-         ac_build_intrinsic(ctx, "llvm.amdgcn.class.f16", ctx->i1, args, 2, AC_FUNC_ATTR_READNONE);
+         ac_build_intrinsic(ctx, "llvm.amdgcn.class.f16", ctx->i1, args, 2, 0);
    }
 
    /* need to convert back up to f32 */
@@ -627,7 +627,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       ac_build_type_name_for_intr(def_type, type, sizeof(type));
       snprintf(name, sizeof(name), "llvm.%cadd.sat.%s",
                instr->op == nir_op_uadd_sat ? 'u' : 's', type);
-      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 2, AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 2, 0);
       break;
    }
    case nir_op_usub_sat:
@@ -636,7 +636,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       ac_build_type_name_for_intr(def_type, type, sizeof(type));
       snprintf(name, sizeof(name), "llvm.%csub.sat.%s",
                instr->op == nir_op_usub_sat ? 'u' : 's', type);
-      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 2, AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 2, 0);
       break;
    }
    case nir_op_fadd:
@@ -690,7 +690,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       src[0] = ac_to_float(&ctx->ac, src[0]);
       src[1] = ac_to_float(&ctx->ac, src[1]);
       result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.fmul.legacy", ctx->ac.f32,
-                                  src, 2, AC_FUNC_ATTR_READNONE);
+                                  src, 2, 0);
       break;
    case nir_op_frcp:
       /* For doubles, we need precise division to pass GLCTS. */
@@ -889,7 +889,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
                                        ac_to_float_type(&ctx->ac, def_type), src[0]);
          result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.fmul.legacy", ctx->ac.f32,
                                      (LLVMValueRef[]){result, ac_to_float(&ctx->ac, src[1])},
-                                     2, AC_FUNC_ATTR_READNONE);
+                                     2, 0);
          result = emit_intrin_1f_param(&ctx->ac, "llvm.exp2",
                                        ac_to_float_type(&ctx->ac, def_type), result);
          break;
@@ -926,19 +926,19 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       src[1] = ac_to_float(&ctx->ac, src[1]);
       src[2] = ac_to_float(&ctx->ac, src[2]);
       result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.fma.legacy", ctx->ac.f32,
-                                  src, 3, AC_FUNC_ATTR_READNONE);
+                                  src, 3, 0);
       break;
    case nir_op_ldexp:
       src[0] = ac_to_float(&ctx->ac, src[0]);
       if (ac_get_elem_bits(&ctx->ac, def_type) == 32)
          result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.ldexp.f32", ctx->ac.f32, src, 2,
-                                     AC_FUNC_ATTR_READNONE);
+                                     0);
       else if (ac_get_elem_bits(&ctx->ac, def_type) == 16)
          result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.ldexp.f16", ctx->ac.f16, src, 2,
-                                     AC_FUNC_ATTR_READNONE);
+                                     0);
       else
          result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.ldexp.f64", ctx->ac.f64, src, 2,
-                                     AC_FUNC_ATTR_READNONE);
+                                     0);
       break;
    case nir_op_bfm:
       result = emit_bfm(&ctx->ac, src[0], src[1]);
@@ -1082,14 +1082,14 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       break;
    case nir_op_ifind_msb_rev:
       result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.sffbh.i32", ctx->ac.i32, &src[0], 1,
-                                  AC_FUNC_ATTR_READNONE);
+                                  0);
       break;
    case nir_op_uclz: {
       LLVMValueRef params[2] = {
          src[0],
          ctx->ac.i1false,
       };
-      result = ac_build_intrinsic(&ctx->ac, "llvm.ctlz.i32", ctx->ac.i32, params, 2, AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(&ctx->ac, "llvm.ctlz.i32", ctx->ac.i32, params, 2, 0);
       break;
    }
    case nir_op_uadd_carry:
@@ -1262,11 +1262,10 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       for (unsigned chan = 0; chan < 3; chan++)
          in[chan] = ac_llvm_extract_elem(&ctx->ac, src[0], chan);
       results[0] = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.cubesc", ctx->ac.f32, in, 3,
-                                      AC_FUNC_ATTR_READNONE);
+                                      0);
       results[1] = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.cubetc", ctx->ac.f32, in, 3,
-                                      AC_FUNC_ATTR_READNONE);
-      LLVMValueRef ma = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.cubema", ctx->ac.f32, in, 3,
-                                           AC_FUNC_ATTR_READNONE);
+                                      0);
+      LLVMValueRef ma = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.cubema", ctx->ac.f32, in, 3, 0);
       results[0] = ac_build_fdiv(&ctx->ac, results[0], ma);
       results[1] = ac_build_fdiv(&ctx->ac, results[1], ma);
       LLVMValueRef offset = LLVMConstReal(ctx->ac.f32, 0.5);
@@ -1281,8 +1280,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       LLVMValueRef in[3];
       for (unsigned chan = 0; chan < 3; chan++)
          in[chan] = ac_llvm_extract_elem(&ctx->ac, src[0], chan);
-      result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.cubeid", ctx->ac.f32, in, 3,
-                                  AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.cubeid", ctx->ac.f32, in, 3, 0);
       break;
    }
 
@@ -1319,7 +1317,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       } else {
          const char *name = "llvm.amdgcn.sdot4";
          src[3] = LLVMConstInt(ctx->ac.i1, instr->op == nir_op_sdot_4x8_iadd_sat, false);
-         result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 4, AC_FUNC_ATTR_READNONE);
+         result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 4, 0);
       }
       break;
    }
@@ -1333,7 +1331,7 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
    case nir_op_udot_4x8_uadd_sat: {
       const char *name = "llvm.amdgcn.udot4";
       src[3] = LLVMConstInt(ctx->ac.i1, instr->op == nir_op_udot_4x8_uadd_sat, false);
-      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 4, AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 4, 0);
       break;
    }
 
@@ -1348,14 +1346,13 @@ static bool visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       src[1] = LLVMBuildBitCast(ctx->ac.builder, src[1], ctx->ac.v2i16, "");
       src[3] = LLVMConstInt(ctx->ac.i1, instr->op == nir_op_sdot_2x16_iadd_sat ||
                                         instr->op == nir_op_udot_2x16_uadd_sat, false);
-      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 4, AC_FUNC_ATTR_READNONE);
+      result = ac_build_intrinsic(&ctx->ac, name, def_type, src, 4, 0);
       break;
    }
 
    case nir_op_sad_u8x4:
       result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.sad.u8", ctx->ac.i32,
-                                  (LLVMValueRef[]){src[0], src[1], src[2]}, 3,
-                                  AC_FUNC_ATTR_READNONE);
+                                  (LLVMValueRef[]){src[0], src[1], src[2]}, 3, 0);
       break;
 
    default:
@@ -3080,8 +3077,7 @@ static LLVMValueRef visit_first_invocation(struct ac_nir_context *ctx)
 
    /* The second argument is whether cttz(0) should be defined, but we do not care. */
    LLVMValueRef args[] = {active_set, ctx->ac.i1false};
-   LLVMValueRef result = ac_build_intrinsic(&ctx->ac, intr, ctx->ac.iN_wavemask, args, 2,
-                                            AC_FUNC_ATTR_READNONE);
+   LLVMValueRef result = ac_build_intrinsic(&ctx->ac, intr, ctx->ac.iN_wavemask, args, 2, 0);
 
    return LLVMBuildTrunc(ctx->ac.builder, result, ctx->ac.i32, "");
 }
@@ -4072,8 +4068,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
          src = LLVMBuildZExt(ctx->ac.builder, src, ctx->ac.i32, "");
 
          result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.readlane", ctx->ac.i32,
-                                     (LLVMValueRef[]){src, index_val}, 2,
-                                     AC_FUNC_ATTR_READNONE);
+                                     (LLVMValueRef[]){src, index_val}, 2, 0);
 
          result = LLVMBuildTrunc(ctx->ac.builder, result, type, "");
 
@@ -4344,8 +4339,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.perm", ctx->ac.i32,
                                   (LLVMValueRef[]){get_src(ctx, instr->src[0]),
                                                    get_src(ctx, instr->src[1]),
-                                                   get_src(ctx, instr->src[2])},
-                                  3, AC_FUNC_ATTR_READNONE);
+                                                   get_src(ctx, instr->src[2])}, 3, 0);
       break;
    case nir_intrinsic_lane_permute_16_amd:
       result = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.permlane16", ctx->ac.i32,
@@ -4354,8 +4348,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
                                                    get_src(ctx, instr->src[1]),
                                                    get_src(ctx, instr->src[2]),
                                                    ctx->ac.i1false,
-                                                   ctx->ac.i1false},
-                                  6, AC_FUNC_ATTR_READNONE);
+                                                   ctx->ac.i1false}, 6, 0);
       break;
    case nir_intrinsic_load_force_vrs_rates_amd:
       result = ac_get_arg(&ctx->ac, ctx->args->force_vrs_rates);
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index e2f9361be239..c6fd844c2445 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -175,8 +175,7 @@ create_function(struct radv_shader_context *ctx, gl_shader_stage stage, bool has
                            ctx->max_workgroup_size, ctx->options);
 
    ctx->ring_offsets = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.implicit.buffer.ptr",
-                                          LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_CONST), NULL, 0,
-                                          AC_FUNC_ATTR_READNONE);
+                                          LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_CONST), NULL, 0, 0);
    ctx->ring_offsets = LLVMBuildBitCast(ctx->ac.builder, ctx->ring_offsets,
                                         ac_array_in_const_addr_space(ctx->ac.v4i32), "");
 
@@ -657,7 +656,7 @@ si_llvm_init_export_args(struct radv_shader_context *ctx, LLVMValueRef *values,
             LLVMValueRef class_args[2] = {values[i],
                                           LLVMConstInt(ctx->ac.i32, S_NAN | Q_NAN, false)};
             LLVMValueRef isnan = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.class.f32", ctx->ac.i1,
-                                                    class_args, 2, AC_FUNC_ATTR_READNONE);
+                                                    class_args, 2, 0);
             values[i] = LLVMBuildSelect(ctx->ac.builder, isnan, ctx->ac.f32_0, values[i], "");
          }
       }
-- 
GitLab


From 99d0392c22c08b6f6db209a15b5dcb50ef66b7c6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 06:14:10 -0500
Subject: [PATCH 11/14] ac/llvm: use invariant.load metadata on load intrinsics
 instead of readnone

readnone is illegal now and we should be using invariant.load since LLVM 15.
(suggested by Nicolai)
---
 src/amd/llvm/ac_llvm_build.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 0a79b6bb6706..e43f6d6dac1b 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -309,8 +309,12 @@ LLVMValueRef ac_build_intrinsic(struct ac_llvm_context *ctx, const char *name,
 
    call = LLVMBuildCall2(ctx->builder, function_type, function, params, param_count, "");
 
-   if (attrib_mask & AC_FUNC_ATTR_READNONE)
-      LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "readnone"));
+   if (attrib_mask & AC_FUNC_ATTR_READNONE) {
+      if (LLVM_VERSION_MAJOR >= 15)
+         LLVMSetMetadata(call, ctx->invariant_load_md_kind, ctx->empty_md);
+      else
+         LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "readnone"));
+   }
 
    if (attrib_mask & AC_FUNC_ATTR_CONVERGENT)
       LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "convergent"));
-- 
GitLab


From ba1d0cf680534e2962cffe21ee34cdb95765a3a2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 06:19:56 -0500
Subject: [PATCH 12/14] ac/llvm: rename attribute enums

---
 src/amd/llvm/ac_llvm_build.c                     |  8 ++++----
 src/amd/llvm/ac_llvm_util.h                      | 11 +++++------
 src/amd/llvm/ac_nir_to_llvm.c                    | 10 +++++-----
 src/gallium/drivers/radeonsi/si_shader_llvm_ps.c |  2 +-
 4 files changed, 15 insertions(+), 16 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index e43f6d6dac1b..bf7c25ccf3aa 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -309,14 +309,14 @@ LLVMValueRef ac_build_intrinsic(struct ac_llvm_context *ctx, const char *name,
 
    call = LLVMBuildCall2(ctx->builder, function_type, function, params, param_count, "");
 
-   if (attrib_mask & AC_FUNC_ATTR_READNONE) {
+   if (attrib_mask & AC_ATTR_INVARIANT_LOAD) {
       if (LLVM_VERSION_MAJOR >= 15)
          LLVMSetMetadata(call, ctx->invariant_load_md_kind, ctx->empty_md);
       else
          LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "readnone"));
    }
 
-   if (attrib_mask & AC_FUNC_ATTR_CONVERGENT)
+   if (attrib_mask & AC_ATTR_CONVERGENT)
       LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "convergent"));
 
    LLVMAddCallSiteAttribute(call, -1, ac_get_llvm_attribute(ctx->context, "nounwind"));
@@ -1350,7 +1350,7 @@ LLVMValueRef ac_build_buffer_load(struct ac_llvm_context *ctx, LLVMValueRef rsrc
             LLVMConstInt(ctx->i32, get_load_cache_policy(ctx, cache_policy), 0),
          };
          result[i] = ac_build_intrinsic(ctx, "llvm.amdgcn.s.buffer.load.f32", ctx->f32, args, 3,
-                                        AC_FUNC_ATTR_READNONE);
+                                        AC_ATTR_INVARIANT_LOAD);
       }
       if (num_channels == 1)
          return result[0];
@@ -3150,7 +3150,7 @@ void ac_apply_fmask_to_sample(struct ac_llvm_context *ac, LLVMValueRef fmask, LL
    fmask_load.resource = fmask;
    fmask_load.dmask = 0xf;
    fmask_load.dim = is_array_tex ? ac_image_2darray : ac_image_2d;
-   fmask_load.attributes = AC_FUNC_ATTR_READNONE;
+   fmask_load.attributes = AC_ATTR_INVARIANT_LOAD;
 
    fmask_load.coords[0] = addr[0];
    fmask_load.coords[1] = addr[1];
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index efd9aa82820a..c8bd6e7667e3 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -40,11 +40,10 @@ extern "C" {
 struct ac_compiler_passes;
 struct ac_llvm_context;
 
-enum ac_func_attr
-{
-   /* Call attributes. */
-   AC_FUNC_ATTR_READNONE = (1 << 3),
-   AC_FUNC_ATTR_CONVERGENT = (1 << 4),
+/* Attributes at call sites of intrinsics. */
+enum ac_call_site_attr {
+   AC_ATTR_INVARIANT_LOAD = 1 << 0,
+   AC_ATTR_CONVERGENT = 1 << 1,
 };
 
 enum ac_target_machine_options
@@ -99,7 +98,7 @@ void ac_llvm_set_target_features(LLVMValueRef F, struct ac_llvm_context *ctx);
 
 static inline unsigned ac_get_load_intr_attribs(bool can_speculate)
 {
-   return can_speculate ? AC_FUNC_ATTR_READNONE : 0;
+   return can_speculate ? AC_ATTR_INVARIANT_LOAD : 0;
 }
 
 LLVMTargetLibraryInfoRef ac_create_target_library_info(const char *triple);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 252f54316bd6..8522b03b2ee7 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -1497,7 +1497,7 @@ static LLVMValueRef lower_gather4_integer(struct ac_llvm_context *ctx, struct ac
       resinfo.dmask = 0xf;
       resinfo.lod = ctx->i32_0;
       resinfo.resource = args->resource;
-      resinfo.attributes = AC_FUNC_ATTR_READNONE;
+      resinfo.attributes = AC_ATTR_INVARIANT_LOAD;
       LLVMValueRef size = ac_build_image_opcode(ctx, &resinfo);
 
       /* Compute -0.5 / size. */
@@ -1526,7 +1526,7 @@ static LLVMValueRef lower_gather4_integer(struct ac_llvm_context *ctx, struct ac
       args->coords[c] = LLVMBuildFAdd(ctx->builder, tmp, half_texel[c], "");
    }
 
-   args->attributes = AC_FUNC_ATTR_READNONE;
+   args->attributes = AC_ATTR_INVARIANT_LOAD;
    result = ac_build_image_opcode(ctx, args);
 
    if (instr->sampler_dim == GLSL_SAMPLER_DIM_CUBE) {
@@ -1627,7 +1627,7 @@ static LLVMValueRef build_tex_intrinsic(struct ac_nir_context *ctx, const nir_te
       }
    }
 
-   args->attributes = AC_FUNC_ATTR_READNONE;
+   args->attributes = AC_ATTR_INVARIANT_LOAD;
    bool cs_derivs =
       ctx->stage == MESA_SHADER_COMPUTE && ctx->info->cs.derivative_group != DERIVATIVE_GROUP_NONE;
    if (ctx->stage == MESA_SHADER_FRAGMENT || cs_derivs) {
@@ -1637,7 +1637,7 @@ static LLVMValueRef build_tex_intrinsic(struct ac_nir_context *ctx, const nir_te
       case nir_texop_tex:
       case nir_texop_txb:
       case nir_texop_lod:
-         args->attributes |= AC_FUNC_ATTR_CONVERGENT;
+         args->attributes |= AC_ATTR_CONVERGENT;
          break;
       default:
          break;
@@ -2648,7 +2648,7 @@ static LLVMValueRef visit_image_load(struct ac_nir_context *ctx, const nir_intri
       get_image_coords(ctx, instr, dynamic_index, &args, GLSL_SAMPLER_DIM_2D, is_array);
       args.dmask = 0xf;
       args.dim = is_array ? ac_image_2darray : ac_image_2d;
-      args.attributes = AC_FUNC_ATTR_READNONE;
+      args.attributes = AC_ATTR_INVARIANT_LOAD;
       args.a16 = ac_get_elem_bits(&ctx->ac, LLVMTypeOf(args.coords[0])) == 16;
 
       res = ac_build_image_opcode(&ctx->ac, &args);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index 9e8d9fa50d91..9ea75d44fc89 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -99,7 +99,7 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
    args.opcode = ac_image_load;
    args.resource = image;
    args.dmask = 0xf;
-   args.attributes = AC_FUNC_ATTR_READNONE;
+   args.attributes = AC_ATTR_INVARIANT_LOAD;
 
    if (ctx->shader->key.ps.mono.fbfetch_msaa)
       args.dim =
-- 
GitLab


From 0de354c07021bbc151d0c089ab62549c3cbf643f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 06:25:55 -0500
Subject: [PATCH 13/14] ac/llvm: inline ac_get_load_intr_attribs

---
 src/amd/llvm/ac_llvm_build.c | 6 ++++--
 src/amd/llvm/ac_llvm_util.h  | 5 -----
 2 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index bf7c25ccf3aa..d46b7321ad9f 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1322,7 +1322,8 @@ static LLVMValueRef ac_build_buffer_load_common(struct ac_llvm_context *ctx, LLV
       snprintf(name, sizeof(name), "llvm.amdgcn.%s.buffer.load.%s", indexing_kind, type_name);
    }
 
-   return ac_build_intrinsic(ctx, name, type, args, idx, ac_get_load_intr_attribs(can_speculate));
+   return ac_build_intrinsic(ctx, name, type, args, idx,
+                             can_speculate ? AC_ATTR_INVARIANT_LOAD : 0);
 }
 
 LLVMValueRef ac_build_buffer_load(struct ac_llvm_context *ctx, LLVMValueRef rsrc, int num_channels,
@@ -1435,7 +1436,8 @@ static LLVMValueRef ac_build_tbuffer_load(struct ac_llvm_context *ctx, LLVMValue
 
    snprintf(name, sizeof(name), "llvm.amdgcn.%s.tbuffer.load.%s", indexing_kind, type_name);
 
-   return ac_build_intrinsic(ctx, name, type, args, idx, ac_get_load_intr_attribs(can_speculate));
+   return ac_build_intrinsic(ctx, name, type, args, idx,
+                             can_speculate ? AC_ATTR_INVARIANT_LOAD : 0);
 }
 
 LLVMValueRef ac_build_struct_tbuffer_load(struct ac_llvm_context *ctx, LLVMValueRef rsrc,
diff --git a/src/amd/llvm/ac_llvm_util.h b/src/amd/llvm/ac_llvm_util.h
index c8bd6e7667e3..5006950255a0 100644
--- a/src/amd/llvm/ac_llvm_util.h
+++ b/src/amd/llvm/ac_llvm_util.h
@@ -96,11 +96,6 @@ void ac_llvm_add_target_dep_function_attr(LLVMValueRef F, const char *name, unsi
 void ac_llvm_set_workgroup_size(LLVMValueRef F, unsigned size);
 void ac_llvm_set_target_features(LLVMValueRef F, struct ac_llvm_context *ctx);
 
-static inline unsigned ac_get_load_intr_attribs(bool can_speculate)
-{
-   return can_speculate ? AC_ATTR_INVARIANT_LOAD : 0;
-}
-
 LLVMTargetLibraryInfoRef ac_create_target_library_info(const char *triple);
 void ac_dispose_target_library_info(LLVMTargetLibraryInfoRef library_info);
 PUBLIC void ac_init_shared_llvm_once(void); /* Do not use directly, use ac_init_llvm_once */
-- 
GitLab


From 5c747bd5bd41dcecad2477ecb3fb86e405995ebb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 4 Dec 2022 06:32:19 -0500
Subject: [PATCH 14/14] ac/llvm: set invariant.load on image loads with
 ACCESS_CAN_REORDER

---
 src/amd/llvm/ac_nir_to_llvm.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 8522b03b2ee7..58f12a17043c 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -2664,7 +2664,7 @@ static LLVMValueRef visit_image_load(struct ac_nir_context *ctx, const nir_intri
       if (!level_zero)
          args.lod = get_src(ctx, instr->src[3]);
       args.dmask = 15;
-      args.attributes = 0;
+      args.attributes = access & ACCESS_CAN_REORDER ? AC_ATTR_INVARIANT_LOAD : 0;
 
       assert(instr->dest.is_ssa);
       args.d16 = instr->dest.ssa.bit_size == 16;
-- 
GitLab

