From 3792ee36932e87d1a45e5d61071ce6ea6031a11a Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 31 Jan 2023 16:15:50 +0000
Subject: [PATCH] aco: make IDSet sparse

Improves compilation time of huge shaders.

A ray tracing pipeline of Hellblade: Senua's Sacrifice compiles in about
half the time, with this patch.

For typical shaders, live_var_analysis seems ~16% slower, but overall
compilation times seems unaffected.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Gitlab: https://gitlab.freedesktop.org/mesa/mesa/-/issues/8179
---
 src/amd/compiler/aco_util.h | 172 +++++++++++++++++++++---------------
 1 file changed, 102 insertions(+), 70 deletions(-)

diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 71c783274023..aef0abd8c45c 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -238,22 +238,16 @@ private:
  * Cache-friendly set of 32-bit IDs with O(1) insert/erase/lookup and
  * the ability to efficiently iterate over contained elements.
  *
- * Internally implemented as a bit vector: If the set contains an ID, the
- * corresponding bit is set. It doesn't use std::vector<bool> since we then
- * couldn't efficiently iterate over the elements.
+ * Internally implemented as a vector of size-limited bit vectors: If the set contains an ID, the
+ * corresponding bit in the appropriate bit vector is set. It doesn't use std::vector<bool> since
+ * we then couldn't efficiently iterate over the elements.
  *
  * The interface resembles a subset of std::set/std::unordered_set.
  */
 struct IDSet {
    struct Iterator {
       const IDSet* set;
-      union {
-         struct {
-            uint32_t bit : 6;
-            uint32_t word : 26;
-         };
-         uint32_t id;
-      };
+      uint32_t id;
 
       Iterator& operator++();
 
@@ -264,53 +258,62 @@ struct IDSet {
 
    size_t count(uint32_t id) const
    {
-      if (id >= words.size() * 64)
+      uint32_t block_index = id / block_size;
+      if (block_index >= words.size())
          return 0;
 
-      return words[id / 64u] & (1ull << (id % 64u)) ? 1 : 0;
-   }
+      const std::vector<uint64_t>& block = words[block_index];
+      uint32_t sub_id = id % block_size;
 
-   Iterator find(uint32_t id) const
-   {
-      if (!count(id))
-         return end();
+      if (sub_id / 64u >= block.size())
+         return 0;
 
-      Iterator it;
-      it.set = this;
-      it.bit = id % 64u;
-      it.word = id / 64u;
-      return it;
+      return block[sub_id / 64u] & (1ull << (sub_id % 64u)) ? 1 : 0;
    }
 
+   Iterator find(uint32_t id) const { return count(id) ? Iterator{this, id} : end(); }
+
    std::pair<Iterator, bool> insert(uint32_t id)
    {
-      if (words.size() * 64u <= id)
-         words.resize(id / 64u + 1);
+      uint32_t block_index = id / block_size;
+      if (block_index >= words.size())
+         words.resize(block_index + 1);
 
-      Iterator it;
-      it.set = this;
-      it.bit = id % 64u;
-      it.word = id / 64u;
+      std::vector<uint64_t>& block = words[block_index];
+      uint32_t sub_id = id % block_size;
 
-      uint64_t mask = 1ull << it.bit;
-      if (words[it.word] & mask)
-         return std::make_pair(it, false);
+      if (sub_id / 64u >= block.size())
+         block.resize(sub_id / 64u + 1);
 
-      words[it.word] |= mask;
+      uint64_t* word = &block[sub_id / 64u];
+      uint64_t mask = 1ull << (sub_id % 64u);
+      if (*word & mask)
+         return std::make_pair(Iterator{this, id}, false);
+
+      *word |= mask;
       bits_set++;
-      return std::make_pair(it, true);
+      return std::make_pair(Iterator{this, id}, true);
    }
 
    bool insert(const IDSet other)
    {
       bool inserted = false;
-      words.resize(std::max(words.size(), other.words.size()));
-      for (unsigned i = 0; i < other.words.size(); i++) {
-         uint64_t new_bits = other.words[i] & ~words[i];
-         if (new_bits) {
-            inserted = true;
-            bits_set += util_bitcount64(new_bits);
-            words[i] |= new_bits;
+
+      if (other.words.size() > words.size())
+         words.resize(other.words.size());
+
+      for (uint32_t i = 0; i < std::min(words.size(), other.words.size()); i++) {
+         std::vector<uint64_t>& dst = words[i];
+         const std::vector<uint64_t>& src = other.words[i];
+
+         dst.resize(std::max(dst.size(), src.size()));
+         for (unsigned j = 0; j < src.size(); j++) {
+            uint64_t new_bits = src[j] & ~dst[j];
+            if (new_bits) {
+               inserted = true;
+               bits_set += util_bitcount64(new_bits);
+               dst[j] |= new_bits;
+            }
          }
       }
       return inserted;
@@ -318,10 +321,22 @@ struct IDSet {
 
    size_t erase(uint32_t id)
    {
-      if (!count(id))
+      uint32_t block_index = id / block_size;
+      if (block_index >= words.size())
          return 0;
 
-      words[id / 64u] ^= 1ull << (id % 64u);
+      std::vector<uint64_t>& block = words[block_index];
+      uint32_t sub_id = id % block_size;
+
+      if (sub_id / 64u >= block.size())
+         return 0;
+
+      uint64_t* word = &block[sub_id / 64u];
+      uint64_t mask = 1ull << (sub_id % 64u);
+      if (!(*word & mask))
+         return 0;
+
+      *word ^= mask;
       bits_set--;
       return 1;
    }
@@ -330,25 +345,20 @@ struct IDSet {
    {
       Iterator it;
       it.set = this;
-      for (size_t i = 0; i < words.size(); i++) {
-         if (words[i]) {
-            it.word = i;
-            it.bit = ffsll(words[i]) - 1;
+
+      for (uint32_t i = 0; i < words.size(); i++) {
+         uint32_t first = get_first_set(words[i]);
+         if (first != UINT32_MAX) {
+            it.id = i * block_size + first;
             return it;
          }
       }
-      return end();
-   }
 
-   Iterator cend() const
-   {
-      Iterator it;
-      it.set = this;
-      it.word = words.size();
-      it.bit = 0;
-      return it;
+      return cend();
    }
 
+   Iterator cend() const { return Iterator{this, UINT32_MAX}; }
+
    Iterator begin() const { return cbegin(); }
 
    Iterator end() const { return cend(); }
@@ -357,31 +367,53 @@ struct IDSet {
 
    size_t size() const { return bits_set; }
 
-   std::vector<uint64_t> words;
+private:
+   static uint32_t get_first_set(const std::vector<uint64_t>& words)
+   {
+      for (size_t i = 0; i < words.size(); i++) {
+         if (words[i])
+            return i * 64u + (ffsll(words[i]) - 1);
+      }
+      return UINT32_MAX;
+   }
+
+   static const uint32_t block_size = 8192u;
+
+   std::vector<std::vector<uint64_t>> words;
    uint32_t bits_set = 0;
 };
 
 inline IDSet::Iterator&
 IDSet::Iterator::operator++()
 {
-   uint64_t m = set->words[word];
+   uint32_t block_index = id / block_size;
+   const std::vector<uint64_t>& block = set->words[block_index];
+   uint32_t sub_id = id % block_size;
+
+   uint64_t m = block[sub_id / 64u];
+   uint32_t bit = sub_id % 64u;
    m &= ~((2ull << bit) - 1ull);
-   if (!m) {
-      /* don't continue past the end */
-      if (word == set->words.size())
+   if (m) {
+      id += (ffsll(m) - 1) - bit;
+      return *this;
+   }
+
+   for (uint32_t i = sub_id / 64u + 1; i < block.size(); i++) {
+      if (block[i]) {
+         id = block_index * block_size + i * 64u + ffsll(block[i]) - 1;
          return *this;
+      }
+   }
 
-      word++;
-      for (; word < set->words.size(); word++) {
-         if (set->words[word]) {
-            bit = ffsll(set->words[word]) - 1;
-            return *this;
-         }
+   for (uint32_t i = block_index + 1; i < set->words.size(); i++) {
+      uint32_t first = get_first_set(set->words[i]);
+      if (first != UINT32_MAX) {
+         id = i * block_size + first;
+         return *this;
       }
-      bit = 0;
-   } else {
-      bit = ffsll(m) - 1;
    }
+
+   id = UINT32_MAX;
    return *this;
 }
 
@@ -395,7 +427,7 @@ IDSet::Iterator::operator!=(const IDSet::Iterator& other) const
 inline uint32_t
 IDSet::Iterator::operator*() const
 {
-   return (word << 6) | bit;
+   return id;
 }
 
 /*
-- 
GitLab

