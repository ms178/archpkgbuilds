From dbeaa0b53ec524b13559c8b1b4900c6741cab88b Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Wed, 2 Nov 2022 16:33:48 -0500
Subject: [PATCH 1/3] nir: Add more opcodes to nir_tex_instr_is_query()

---
 src/compiler/nir/nir.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 6d2a1263e8a8..1e9b2cd15cc6 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3263,6 +3263,9 @@ nir_tex_instr_is_query(const nir_tex_instr *instr)
    case nir_texop_txf_ms_fb:
    case nir_texop_txf_ms_mcs_intel:
    case nir_texop_tg4:
+   case nir_texop_samples_identical:
+   case nir_texop_fragment_mask_fetch_amd:
+   case nir_texop_fragment_fetch_amd:
       return false;
    default:
       unreachable("Invalid texture opcode");
-- 
GitLab


From 67503850433c81fda3b1a115e6267b3a9e4df2d5 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Wed, 2 Nov 2022 13:37:06 -0500
Subject: [PATCH 2/3] nir/builder: Add some texture helpers

---
 src/compiler/nir/nir_builder.c | 104 ++++++++++++++++++++++++++++++++
 src/compiler/nir/nir_builder.h | 106 +++++++++++++++++++++++++++++++++
 2 files changed, 210 insertions(+)

diff --git a/src/compiler/nir/nir_builder.c b/src/compiler/nir/nir_builder.c
index ca10a294f792..3de48c9101bd 100644
--- a/src/compiler/nir/nir_builder.c
+++ b/src/compiler/nir/nir_builder.c
@@ -215,6 +215,110 @@ nir_build_alu_src_arr(nir_builder *build, nir_op op, nir_ssa_def **srcs)
    return nir_builder_alu_instr_finish_and_insert(build, instr);
 }
 
+nir_ssa_def *
+nir_build_tex_deref_instr(nir_builder *build, nir_texop op,
+                          nir_deref_instr *texture,
+                          nir_deref_instr *sampler,
+                          unsigned num_extra_srcs,
+                          const nir_tex_src *extra_srcs)
+{
+   assert(texture != NULL);
+   assert(glsl_type_is_texture(texture->type) ||
+          glsl_type_is_sampler(texture->type));
+
+   const unsigned num_srcs = 1 + (sampler != NULL) + num_extra_srcs;
+
+   nir_tex_instr *tex = nir_tex_instr_create(build->shader, num_srcs);
+   tex->op = op;
+   tex->sampler_dim = glsl_get_sampler_dim(texture->type);
+   tex->is_array = glsl_sampler_type_is_array(texture->type);
+   tex->is_shadow = false;
+
+   switch (op) {
+   case nir_texop_txs:
+   case nir_texop_texture_samples:
+   case nir_texop_query_levels:
+   case nir_texop_txf_ms_mcs_intel:
+   case nir_texop_fragment_mask_fetch_amd:
+   case nir_texop_descriptor_amd:
+      tex->dest_type = nir_type_int32;
+      break;
+   case nir_texop_lod:
+      tex->dest_type = nir_type_float32;
+      break;
+   case nir_texop_samples_identical:
+      tex->dest_type = nir_type_bool1;
+      break;
+   default:
+      assert(!nir_tex_instr_is_query(tex));
+      tex->dest_type = nir_get_nir_type_for_glsl_base_type(
+         glsl_get_sampler_result_type(texture->type));
+      break;
+   }
+
+   unsigned src_idx = 0;
+   tex->src[src_idx++] = (nir_tex_src) {
+      .src_type = nir_tex_src_texture_deref,
+      .src = nir_src_for_ssa(&texture->dest.ssa),
+   };
+   if (sampler != NULL) {
+      assert(glsl_type_is_sampler(sampler->type));
+      tex->src[src_idx++] = (nir_tex_src) {
+         .src_type = nir_tex_src_sampler_deref,
+         .src = nir_src_for_ssa(&sampler->dest.ssa),
+      };
+   }
+   for (unsigned i = 0; i < num_extra_srcs; i++) {
+      switch (extra_srcs[i].src_type) {
+      case nir_tex_src_coord:
+         tex->coord_components = nir_src_num_components(extra_srcs[i].src);
+         assert(tex->coord_components == tex->is_array +
+                glsl_get_sampler_dim_coordinate_components(tex->sampler_dim));
+         break;
+
+      case nir_tex_src_lod:
+         assert(tex->sampler_dim == GLSL_SAMPLER_DIM_1D ||
+                tex->sampler_dim == GLSL_SAMPLER_DIM_2D ||
+                tex->sampler_dim == GLSL_SAMPLER_DIM_3D ||
+                tex->sampler_dim == GLSL_SAMPLER_DIM_CUBE);
+         break;
+
+      case nir_tex_src_ms_index:
+         assert(tex->sampler_dim == GLSL_SAMPLER_DIM_MS);
+         break;
+
+      case nir_tex_src_comparator:
+         /* Assume 1-component shadow for the builder helper */
+         tex->is_shadow = true;
+         tex->is_new_style_shadow = true;
+         break;
+
+      case nir_tex_src_texture_deref:
+      case nir_tex_src_sampler_deref:
+      case nir_tex_src_texture_offset:
+      case nir_tex_src_sampler_offset:
+      case nir_tex_src_texture_handle:
+      case nir_tex_src_sampler_handle:
+         unreachable("Texture and sampler must be provided directly as derefs");
+         break;
+
+      default:
+         break;
+      }
+
+      tex->src[src_idx++] = extra_srcs[i];
+   }
+   assert(src_idx == num_srcs);
+
+   nir_ssa_dest_init(&tex->instr, &tex->dest,
+                     nir_tex_instr_dest_size(tex),
+                     nir_alu_type_get_type_size(tex->dest_type),
+                     NULL);
+   nir_builder_instr_insert(build, &tex->instr);
+
+   return &tex->dest.ssa;
+}
+
 nir_ssa_def *
 nir_vec_scalars(nir_builder *build, nir_ssa_scalar *comp, unsigned num_components)
 {
diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index 04f33fa74765..1309639e7049 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -129,6 +129,13 @@ nir_build_alu4(nir_builder *build, nir_op op, nir_ssa_def *src0,
 
 nir_ssa_def *nir_build_alu_src_arr(nir_builder *build, nir_op op, nir_ssa_def **srcs);
 
+nir_ssa_def *
+nir_build_tex_deref_instr(nir_builder *build, nir_texop op,
+                          nir_deref_instr *texture,
+                          nir_deref_instr *sampler,
+                          unsigned num_extra_srcs,
+                          const nir_tex_src *extra_srcs);
+
 nir_instr *nir_builder_last_instr(nir_builder *build);
 
 void nir_builder_cf_insert(nir_builder *build, nir_cf_node *cf);
@@ -1550,6 +1557,105 @@ nir_load_param(nir_builder *build, uint32_t param_idx)
    return nir_build_load_param(build, param->num_components, param->bit_size, param_idx);
 }
 
+static inline nir_ssa_def *
+nir_tex_deref(nir_builder *b, nir_deref_instr *t, nir_deref_instr *s,
+              nir_ssa_def *coord)
+{
+   nir_tex_src srcs[] = {{
+      nir_src_for_ssa(coord),
+      nir_tex_src_coord,
+   }};
+
+   return nir_build_tex_deref_instr(b, nir_texop_tex, t, s,
+                                    ARRAY_SIZE(srcs), srcs);
+}
+
+static inline nir_ssa_def *
+nir_txl_deref(nir_builder *b, nir_deref_instr *t, nir_deref_instr *s,
+              nir_ssa_def *coord, nir_ssa_def *lod)
+{
+   nir_tex_src srcs[] = {{
+      nir_src_for_ssa(coord),
+      nir_tex_src_coord,
+   }, {
+      nir_src_for_ssa(lod),
+      nir_tex_src_lod,
+   }};
+
+   return nir_build_tex_deref_instr(b, nir_texop_txl, t, s,
+                                    ARRAY_SIZE(srcs), srcs);
+}
+
+static inline nir_ssa_def *
+nir_txl_zero_deref(nir_builder *b, nir_deref_instr *t, nir_deref_instr *s,
+                   nir_ssa_def *coord)
+{
+   return nir_txl_deref(b, t, s, coord, nir_imm_float(b, 0));
+}
+
+static inline nir_ssa_def *
+nir_txf_deref(nir_builder *b, nir_deref_instr *t,
+              nir_ssa_def *coord, nir_ssa_def *lod)
+{
+   nir_tex_src srcs[2];
+   unsigned num_srcs = 0;
+
+   srcs[num_srcs].src_type = nir_tex_src_coord;
+   srcs[num_srcs].src = nir_src_for_ssa(coord);
+   num_srcs++;
+
+   if (lod == NULL) {
+      switch (glsl_get_sampler_dim(t->type)) {
+      case GLSL_SAMPLER_DIM_1D:
+      case GLSL_SAMPLER_DIM_2D:
+      case GLSL_SAMPLER_DIM_3D:
+      case GLSL_SAMPLER_DIM_CUBE:
+         lod = nir_imm_int(b, 0);
+         break;
+      default:
+         break;
+      }
+   }
+
+   if (lod != NULL) {
+      srcs[num_srcs].src_type = nir_tex_src_lod;
+      srcs[num_srcs].src = nir_src_for_ssa(lod);
+      num_srcs++;
+   }
+
+   return nir_build_tex_deref_instr(b, nir_texop_txf, t, NULL,
+                                    num_srcs, srcs);
+}
+
+static inline nir_ssa_def *
+nir_txf_ms_deref(nir_builder *b, nir_deref_instr *t,
+                 nir_ssa_def *coord, nir_ssa_def *ms_index)
+{
+   nir_tex_src srcs[] = {{
+      nir_src_for_ssa(coord),
+      nir_tex_src_coord,
+   }, {
+      nir_src_for_ssa(ms_index),
+      nir_tex_src_ms_index,
+   }};
+
+   return nir_build_tex_deref_instr(b, nir_texop_txf_ms, t, NULL,
+                                    ARRAY_SIZE(srcs), srcs);
+}
+
+static inline nir_ssa_def *
+nir_samples_identical_deref(nir_builder *b, nir_deref_instr *t,
+                            nir_ssa_def *coord)
+{
+   nir_tex_src srcs[] = {{
+      nir_src_for_ssa(coord),
+      nir_tex_src_coord,
+   }};
+
+   return nir_build_tex_deref_instr(b, nir_texop_samples_identical, t, NULL,
+                                    ARRAY_SIZE(srcs), srcs);
+}
+
 /* calculate a `(1 << value) - 1` in ssa without overflows */
 static inline nir_ssa_def *
 nir_mask(nir_builder *b, nir_ssa_def *bits, unsigned dst_bit_size)
-- 
GitLab


From 4ec76b6f6aa1d8e57ffb6bdf18f1c1ac4daea059 Mon Sep 17 00:00:00 2001
From: Jason Ekstrand <jason.ekstrand@collabora.com>
Date: Wed, 2 Nov 2022 13:57:56 -0500
Subject: [PATCH 3/3] radv: Use the new NIR builder tex helpers for meta

---
 src/amd/vulkan/radv_meta.c                |  70 +++----------
 src/amd/vulkan/radv_meta_blit.c           |  63 ++----------
 src/amd/vulkan/radv_meta_blit2d.c         |  45 ++-------
 src/amd/vulkan/radv_meta_bufimage.c       | 114 +++-------------------
 src/amd/vulkan/radv_meta_copy_vrs_htile.c |  22 +----
 src/amd/vulkan/radv_meta_etc_decode.c     |  42 ++------
 src/amd/vulkan/radv_meta_fmask_copy.c     |  57 ++++-------
 src/amd/vulkan/radv_meta_fmask_expand.c   |  26 +----
 src/amd/vulkan/radv_meta_resolve_cs.c     |  49 ++--------
 src/amd/vulkan/radv_meta_resolve_fs.c     |  51 ++--------
 10 files changed, 91 insertions(+), 448 deletions(-)

diff --git a/src/amd/vulkan/radv_meta.c b/src/amd/vulkan/radv_meta.c
index ca4c30f119bb..fcc1460dcf99 100644
--- a/src/amd/vulkan/radv_meta.c
+++ b/src/amd/vulkan/radv_meta.c
@@ -598,79 +598,31 @@ radv_meta_build_resolve_shader_core(nir_builder *b, bool is_integer, int samples
                                     nir_variable *input_img, nir_variable *color,
                                     nir_ssa_def *img_coord, enum amd_gfx_level gfx_level)
 {
-   /* do a txf_ms on each sample */
-   nir_ssa_def *tmp;
-
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(b, input_img)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b->shader, 3);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_MS;
-   tex->op = nir_texop_txf_ms;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(img_coord);
-   tex->src[1].src_type = nir_tex_src_ms_index;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_img_deref);
-   tex->dest_type = nir_get_nir_type_for_glsl_base_type(glsl_get_sampler_result_type(input_img->type));
-   tex->is_array = false;
-   tex->coord_components = 2;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(b, &tex->instr);
-
-   tmp = &tex->dest.ssa;
+   nir_deref_instr *input_img_deref = nir_build_deref_var(b, input_img);
+   nir_ssa_def *sample0 = nir_txf_ms_deref(b, input_img_deref, img_coord, nir_imm_int(b, 0));
 
    if (is_integer || samples <= 1) {
-      nir_store_var(b, color, &tex->dest.ssa, 0xf);
+      nir_store_var(b, color, sample0, 0xf);
       return;
    }
 
    if (gfx_level < GFX11) {
-      nir_tex_instr *tex_all_same = nir_tex_instr_create(b->shader, 2);
-      tex_all_same->sampler_dim = GLSL_SAMPLER_DIM_MS;
-      tex_all_same->op = nir_texop_samples_identical;
-      tex_all_same->src[0].src_type = nir_tex_src_coord;
-      tex_all_same->src[0].src = nir_src_for_ssa(img_coord);
-      tex_all_same->src[1].src_type = nir_tex_src_texture_deref;
-      tex_all_same->src[1].src = nir_src_for_ssa(input_img_deref);
-      tex_all_same->dest_type = nir_type_bool1;
-      tex_all_same->is_array = false;
-      tex_all_same->coord_components = 2;
-
-      nir_ssa_dest_init(&tex_all_same->instr, &tex_all_same->dest, 1, 1, "tex");
-      nir_builder_instr_insert(b, &tex_all_same->instr);
-
-      nir_ssa_def *not_all_same = nir_inot(b, &tex_all_same->dest.ssa);
-      nir_push_if(b, not_all_same);
+      nir_ssa_def *all_same = nir_samples_identical_deref(b, input_img_deref, img_coord);
+      nir_push_if(b, nir_inot(b, all_same));
    }
 
+   nir_ssa_def *accum = sample0;
    for (int i = 1; i < samples; i++) {
-      nir_tex_instr *tex_add = nir_tex_instr_create(b->shader, 3);
-      tex_add->sampler_dim = GLSL_SAMPLER_DIM_MS;
-      tex_add->op = nir_texop_txf_ms;
-      tex_add->src[0].src_type = nir_tex_src_coord;
-      tex_add->src[0].src = nir_src_for_ssa(img_coord);
-      tex_add->src[1].src_type = nir_tex_src_ms_index;
-      tex_add->src[1].src = nir_src_for_ssa(nir_imm_int(b, i));
-      tex_add->src[2].src_type = nir_tex_src_texture_deref;
-      tex_add->src[2].src = nir_src_for_ssa(input_img_deref);
-      tex_add->dest_type = nir_type_float32;
-      tex_add->is_array = false;
-      tex_add->coord_components = 2;
-
-      nir_ssa_dest_init(&tex_add->instr, &tex_add->dest, 4, 32, "tex");
-      nir_builder_instr_insert(b, &tex_add->instr);
-
-      tmp = nir_fadd(b, tmp, &tex_add->dest.ssa);
+      nir_ssa_def *sample = nir_txf_ms_deref(b, input_img_deref, img_coord, nir_imm_int(b, i));
+      accum = nir_fadd(b, accum, sample);
    }
 
-   tmp = nir_fdiv(b, tmp, nir_imm_float(b, samples));
-   nir_store_var(b, color, tmp, 0xf);
+   accum = nir_fdiv(b, accum, nir_imm_float(b, samples));
+   nir_store_var(b, color, accum, 0xf);
 
    if (gfx_level < GFX11) {
       nir_push_else(b, NULL);
-      nir_store_var(b, color, &tex->dest.ssa, 0xf);
+      nir_store_var(b, color, sample0, 0xf);
       nir_pop_if(b, NULL);
    }
 }
diff --git a/src/amd/vulkan/radv_meta_blit.c b/src/amd/vulkan/radv_meta_blit.c
index 4f8ff87eaa17..fc47ad395e71 100644
--- a/src/amd/vulkan/radv_meta_blit.c
+++ b/src/amd/vulkan/radv_meta_blit.c
@@ -100,27 +100,12 @@ build_nir_copy_fragment_shader(struct radv_device *dev, enum glsl_sampler_dim te
    sampler->data.descriptor_set = 0;
    sampler->data.binding = 0;
 
-   nir_ssa_def *tex_deref = &nir_build_deref_var(&b, sampler)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = tex_dim;
-   tex->op = nir_texop_tex;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(tex_pos);
-   tex->src[1].src_type = nir_tex_src_texture_deref;
-   tex->src[1].src = nir_src_for_ssa(tex_deref);
-   tex->src[2].src_type = nir_tex_src_sampler_deref;
-   tex->src[2].src = nir_src_for_ssa(tex_deref);
-   tex->dest_type = nir_type_float32; /* TODO */
-   tex->is_array = glsl_sampler_type_is_array(sampler_type);
-   tex->coord_components = tex_pos->num_components;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
+   nir_deref_instr *tex_deref = nir_build_deref_var(&b, sampler);
+   nir_ssa_def *color = nir_tex_deref(&b, tex_deref, tex_deref, tex_pos);
 
    nir_variable *color_out = nir_variable_create(b.shader, nir_var_shader_out, vec4, "f_color");
    color_out->data.location = FRAG_RESULT_DATA0;
-   nir_store_var(&b, color_out, &tex->dest.ssa, 0xf);
+   nir_store_var(&b, color_out, color, 0xf);
 
    return b.shader;
 }
@@ -148,27 +133,12 @@ build_nir_copy_fragment_shader_depth(struct radv_device *dev, enum glsl_sampler_
    sampler->data.descriptor_set = 0;
    sampler->data.binding = 0;
 
-   nir_ssa_def *tex_deref = &nir_build_deref_var(&b, sampler)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = tex_dim;
-   tex->op = nir_texop_tex;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(tex_pos);
-   tex->src[1].src_type = nir_tex_src_texture_deref;
-   tex->src[1].src = nir_src_for_ssa(tex_deref);
-   tex->src[2].src_type = nir_tex_src_sampler_deref;
-   tex->src[2].src = nir_src_for_ssa(tex_deref);
-   tex->dest_type = nir_type_float32; /* TODO */
-   tex->is_array = glsl_sampler_type_is_array(sampler_type);
-   tex->coord_components = tex_pos->num_components;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
+   nir_deref_instr *tex_deref = nir_build_deref_var(&b, sampler);
+   nir_ssa_def *color = nir_tex_deref(&b, tex_deref, tex_deref, tex_pos);
 
    nir_variable *color_out = nir_variable_create(b.shader, nir_var_shader_out, vec4, "f_color");
    color_out->data.location = FRAG_RESULT_DEPTH;
-   nir_store_var(&b, color_out, &tex->dest.ssa, 0x1);
+   nir_store_var(&b, color_out, color, 0x1);
 
    return b.shader;
 }
@@ -196,27 +166,12 @@ build_nir_copy_fragment_shader_stencil(struct radv_device *dev, enum glsl_sample
    sampler->data.descriptor_set = 0;
    sampler->data.binding = 0;
 
-   nir_ssa_def *tex_deref = &nir_build_deref_var(&b, sampler)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = tex_dim;
-   tex->op = nir_texop_tex;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(tex_pos);
-   tex->src[1].src_type = nir_tex_src_texture_deref;
-   tex->src[1].src = nir_src_for_ssa(tex_deref);
-   tex->src[2].src_type = nir_tex_src_sampler_deref;
-   tex->src[2].src = nir_src_for_ssa(tex_deref);
-   tex->dest_type = nir_type_float32; /* TODO */
-   tex->is_array = glsl_sampler_type_is_array(sampler_type);
-   tex->coord_components = tex_pos->num_components;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
+   nir_deref_instr *tex_deref = nir_build_deref_var(&b, sampler);
+   nir_ssa_def *color = nir_tex_deref(&b, tex_deref, tex_deref, tex_pos);
 
    nir_variable *color_out = nir_variable_create(b.shader, nir_var_shader_out, vec4, "f_color");
    color_out->data.location = FRAG_RESULT_STENCIL;
-   nir_store_var(&b, color_out, &tex->dest.ssa, 0x1);
+   nir_store_var(&b, color_out, color, 0x1);
 
    return b.shader;
 }
diff --git a/src/amd/vulkan/radv_meta_blit2d.c b/src/amd/vulkan/radv_meta_blit2d.c
index 57d4d0f32844..48b7191b0ab9 100644
--- a/src/amd/vulkan/radv_meta_blit2d.c
+++ b/src/amd/vulkan/radv_meta_blit2d.c
@@ -454,29 +454,13 @@ build_nir_texel_fetch(struct nir_builder *b, struct radv_device *device, nir_ssa
       sample_idx = nir_load_sample_id(b);
    }
 
-   nir_ssa_def *tex_deref = &nir_build_deref_var(b, sampler)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b->shader, is_multisampled ? 4 : 3);
-   tex->sampler_dim = dim;
-   tex->op = is_multisampled ? nir_texop_txf_ms : nir_texop_txf;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(is_3d ? tex_pos_3d : tex_pos);
-   tex->src[1].src_type = is_multisampled ? nir_tex_src_ms_index : nir_tex_src_lod;
-   tex->src[1].src = nir_src_for_ssa(is_multisampled ? sample_idx : nir_imm_int(b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(tex_deref);
+   nir_deref_instr *tex_deref = nir_build_deref_var(b, sampler);
+
    if (is_multisampled) {
-      tex->src[3].src_type = nir_tex_src_lod;
-      tex->src[3].src = nir_src_for_ssa(nir_imm_int(b, 0));
+      return nir_txf_ms_deref(b, tex_deref, tex_pos, sample_idx);
+   } else {
+      return nir_txf_deref(b, tex_deref, is_3d ? tex_pos_3d : tex_pos, NULL);
    }
-   tex->dest_type = nir_type_uint32;
-   tex->is_array = false;
-   tex->coord_components = is_3d ? 3 : 2;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(b, &tex->instr);
-
-   return &tex->dest.ssa;
 }
 
 static nir_ssa_def *
@@ -496,23 +480,8 @@ build_nir_buffer_fetch(struct nir_builder *b, struct radv_device *device, nir_ss
    pos_y = nir_imul(b, pos_y, width);
    pos_x = nir_iadd(b, pos_x, pos_y);
 
-   nir_ssa_def *tex_deref = &nir_build_deref_var(b, sampler)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b->shader, 2);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_BUF;
-   tex->op = nir_texop_txf;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(pos_x);
-   tex->src[1].src_type = nir_tex_src_texture_deref;
-   tex->src[1].src = nir_src_for_ssa(tex_deref);
-   tex->dest_type = nir_type_uint32;
-   tex->is_array = false;
-   tex->coord_components = 1;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(b, &tex->instr);
-
-   return &tex->dest.ssa;
+   nir_deref_instr *tex_deref = nir_build_deref_var(b, sampler);
+   return nir_txf_deref(b, tex_deref, pos_x, NULL);
 }
 
 static const VkPipelineVertexInputStateCreateInfo normal_vi_create_info = {
diff --git a/src/amd/vulkan/radv_meta_bufimage.c b/src/amd/vulkan/radv_meta_bufimage.c
index 8991c8047791..aef686a4b819 100644
--- a/src/amd/vulkan/radv_meta_bufimage.c
+++ b/src/amd/vulkan/radv_meta_bufimage.c
@@ -54,23 +54,8 @@ build_nir_itob_compute_shader(struct radv_device *dev, bool is_3d)
    nir_ssa_def *stride = nir_load_push_constant(&b, 1, 32, nir_imm_int(&b, 12), .range = 16);
 
    nir_ssa_def *img_coord = nir_iadd(&b, global_id, offset);
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = dim;
-   tex->op = nir_texop_txf;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(nir_trim_vector(&b, img_coord, 2 + is_3d));
-   tex->src[1].src_type = nir_tex_src_lod;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_img_deref);
-   tex->dest_type = nir_type_float32;
-   tex->is_array = false;
-   tex->coord_components = is_3d ? 3 : 2;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
+   nir_ssa_def *outval = nir_txf_deref(&b, nir_build_deref_var(&b, input_img),
+                                       nir_trim_vector(&b, img_coord, 2 + is_3d), NULL);
 
    nir_ssa_def *pos_x = nir_channel(&b, global_id, 0);
    nir_ssa_def *pos_y = nir_channel(&b, global_id, 1);
@@ -80,7 +65,6 @@ build_nir_itob_compute_shader(struct radv_device *dev, bool is_3d)
 
    nir_ssa_def *coord = nir_vec4(&b, tmp, tmp, tmp, tmp);
 
-   nir_ssa_def *outval = &tex->dest.ssa;
    nir_image_deref_store(&b, &nir_build_deref_var(&b, output_img)->dest.ssa, coord,
                          nir_ssa_undef(&b, 1, 32), outval, nir_imm_int(&b, 0),
                          .image_dim = GLSL_SAMPLER_DIM_BUF);
@@ -236,25 +220,7 @@ build_nir_btoi_compute_shader(struct radv_device *dev, bool is_3d)
    buf_coord = nir_iadd(&b, buf_coord, pos_x);
 
    nir_ssa_def *coord = nir_iadd(&b, global_id, offset);
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_BUF;
-   tex->op = nir_texop_txf;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(buf_coord);
-   tex->src[1].src_type = nir_tex_src_lod;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_img_deref);
-   tex->dest_type = nir_type_float32;
-   tex->is_array = false;
-   tex->coord_components = 1;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
-
-   nir_ssa_def *outval = &tex->dest.ssa;
+   nir_ssa_def *outval = nir_txf_deref(&b, nir_build_deref_var(&b, input_img), buf_coord, NULL);
 
    nir_ssa_def *img_coord = nir_vec4(&b, nir_channel(&b, coord, 0),
                                          nir_channel(&b, coord, 1),
@@ -415,24 +381,7 @@ build_nir_btoi_r32g32b32_compute_shader(struct radv_device *dev)
    nir_ssa_def *global_pos = nir_iadd(&b, nir_imul(&b, nir_channel(&b, img_coord, 1), pitch),
                                       nir_imul_imm(&b, nir_channel(&b, img_coord, 0), 3));
 
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_BUF;
-   tex->op = nir_texop_txf;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(buf_coord);
-   tex->src[1].src_type = nir_tex_src_lod;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_img_deref);
-   tex->dest_type = nir_type_float32;
-   tex->is_array = false;
-   tex->coord_components = 1;
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
-
-   nir_ssa_def *outval = &tex->dest.ssa;
+   nir_ssa_def *outval = nir_txf_deref(&b, nir_build_deref_var(&b, input_img), buf_coord, NULL);
 
    for (int chan = 0; chan < 3; chan++) {
       nir_ssa_def *local_pos = nir_iadd_imm(&b, global_pos, chan);
@@ -558,33 +507,19 @@ build_nir_itoi_compute_shader(struct radv_device *dev, bool is_3d, int samples)
       nir_load_push_constant(&b, is_3d ? 3 : 2, 32, nir_imm_int(&b, 12), .range = is_3d ? 24 : 20);
 
    nir_ssa_def *src_coord = nir_iadd(&b, global_id, src_offset);
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
+   nir_deref_instr *input_img_deref = nir_build_deref_var(&b, input_img);
 
    nir_ssa_def *dst_coord = nir_iadd(&b, global_id, dst_offset);
 
-   nir_tex_instr *tex_instr[8];
-   for (uint32_t i = 0; i < samples; i++) {
-      tex_instr[i] = nir_tex_instr_create(b.shader, is_multisampled ? 4 : 3);
-
-      nir_tex_instr *tex = tex_instr[i];
-      tex->sampler_dim = dim;
-      tex->op = is_multisampled ? nir_texop_txf_ms : nir_texop_txf;
-      tex->src[0].src_type = nir_tex_src_coord;
-      tex->src[0].src = nir_src_for_ssa(nir_trim_vector(&b, src_coord, 2 + is_3d));
-      tex->src[1].src_type = nir_tex_src_lod;
-      tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-      tex->src[2].src_type = nir_tex_src_texture_deref;
-      tex->src[2].src = nir_src_for_ssa(input_img_deref);
-      if (is_multisampled) {
-         tex->src[3].src_type = nir_tex_src_ms_index;
-         tex->src[3].src = nir_src_for_ssa(nir_imm_int(&b, i));
+   nir_ssa_def *tex_vals[8];
+   if (is_multisampled) {
+      for (uint32_t i = 0; i < samples; i++) {
+         tex_vals[i] = nir_txf_ms_deref(&b, input_img_deref, nir_trim_vector(&b, src_coord, 2),
+                                        nir_imm_int(&b, i));
       }
-      tex->dest_type = nir_type_float32;
-      tex->is_array = false;
-      tex->coord_components = is_3d ? 3 : 2;
-
-      nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-      nir_builder_instr_insert(&b, &tex->instr);
+   } else {
+      tex_vals[0] = nir_txf_deref(&b, input_img_deref, nir_trim_vector(&b, src_coord, 2 + is_3d),
+                                  nir_imm_int(&b, 0));
    }
 
    nir_ssa_def *img_coord = nir_vec4(&b, nir_channel(&b, dst_coord, 0),
@@ -593,9 +528,8 @@ build_nir_itoi_compute_shader(struct radv_device *dev, bool is_3d, int samples)
                                          nir_ssa_undef(&b, 1, 32));
 
    for (uint32_t i = 0; i < samples; i++) {
-      nir_ssa_def *outval = &tex_instr[i]->dest.ssa;
       nir_image_deref_store(&b, &nir_build_deref_var(&b, output_img)->dest.ssa, img_coord,
-                            nir_imm_int(&b, i), outval, nir_imm_int(&b, 0), .image_dim = dim);
+                            nir_imm_int(&b, i), tex_vals[i], nir_imm_int(&b, 0), .image_dim = dim);
    }
 
    return b.shader;
@@ -768,24 +702,8 @@ build_nir_itoi_r32g32b32_compute_shader(struct radv_device *dev)
    for (int chan = 0; chan < 3; chan++) {
       /* src */
       nir_ssa_def *src_local_pos = nir_iadd_imm(&b, src_global_pos, chan);
-      nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-      nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-      tex->sampler_dim = GLSL_SAMPLER_DIM_BUF;
-      tex->op = nir_texop_txf;
-      tex->src[0].src_type = nir_tex_src_coord;
-      tex->src[0].src = nir_src_for_ssa(src_local_pos);
-      tex->src[1].src_type = nir_tex_src_lod;
-      tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-      tex->src[2].src_type = nir_tex_src_texture_deref;
-      tex->src[2].src = nir_src_for_ssa(input_img_deref);
-      tex->dest_type = nir_type_float32;
-      tex->is_array = false;
-      tex->coord_components = 1;
-      nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-      nir_builder_instr_insert(&b, &tex->instr);
-
-      nir_ssa_def *outval = &tex->dest.ssa;
+      nir_ssa_def *outval = nir_txf_deref(&b, nir_build_deref_var(&b, input_img), src_local_pos,
+                                          NULL);
 
       /* dst */
       nir_ssa_def *dst_local_pos = nir_iadd_imm(&b, dst_global_pos, chan);
diff --git a/src/amd/vulkan/radv_meta_copy_vrs_htile.c b/src/amd/vulkan/radv_meta_copy_vrs_htile.c
index 782c02ced2c2..8f494842abd1 100644
--- a/src/amd/vulkan/radv_meta_copy_vrs_htile.c
+++ b/src/amd/vulkan/radv_meta_copy_vrs_htile.c
@@ -76,24 +76,8 @@ build_copy_vrs_htile_shader(struct radv_device *device, struct radeon_surf *surf
    input_vrs_img->data.descriptor_set = 0;
    input_vrs_img->data.binding = 0;
 
-   nir_ssa_def *input_vrs_img_deref = &nir_build_deref_var(&b, input_vrs_img)->dest.ssa;
-
    /* Load the VRS rates from the 2D image. */
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_2D;
-   tex->op = nir_texop_txf;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(global_id);
-   tex->src[1].src_type = nir_tex_src_lod;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_vrs_img_deref);
-   tex->dest_type = nir_type_float32;
-   tex->is_array = false;
-   tex->coord_components = 2;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
+   nir_ssa_def *value = nir_txf_deref(&b, nir_build_deref_var(&b, input_vrs_img), global_id, NULL);
 
    /* Extract the X/Y rates and clamp them because the maximum supported VRS rate is 2x2 (1x1 in
     * hardware).
@@ -101,10 +85,10 @@ build_copy_vrs_htile_shader(struct radv_device *device, struct radeon_surf *surf
     * VRS rate X = min(value >> 2, 1)
     * VRS rate Y = min(value & 3, 1)
     */
-   nir_ssa_def *x_rate = nir_ushr_imm(&b, nir_channel(&b, &tex->dest.ssa, 0), 2);
+   nir_ssa_def *x_rate = nir_ushr_imm(&b, nir_channel(&b, value, 0), 2);
    x_rate = nir_umin(&b, x_rate, nir_imm_int(&b, 1));
 
-   nir_ssa_def *y_rate = nir_iand_imm(&b, nir_channel(&b, &tex->dest.ssa, 0), 3);
+   nir_ssa_def *y_rate = nir_iand_imm(&b, nir_channel(&b, value, 0), 3);
    y_rate = nir_umin(&b, y_rate, nir_imm_int(&b, 1));
 
    /* Compute the final VRS rate. */
diff --git a/src/amd/vulkan/radv_meta_etc_decode.c b/src/amd/vulkan/radv_meta_etc_decode.c
index 4320c2a0e33d..c015f34ec108 100644
--- a/src/amd/vulkan/radv_meta_etc_decode.c
+++ b/src/amd/vulkan/radv_meta_etc_decode.c
@@ -210,45 +210,15 @@ build_shader(struct radv_device *dev)
       nir_variable_create(b.shader, nir_var_shader_temp, glsl_vec4_type(), "payload");
    nir_push_if(&b, is_3d);
    {
-      nir_ssa_def *tex_deref = &nir_build_deref_var(&b, input_img_3d)->dest.ssa;
-
-      nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-      tex->sampler_dim = GLSL_SAMPLER_DIM_3D;
-      tex->op = nir_texop_txf;
-      tex->src[0].src_type = nir_tex_src_coord;
-      tex->src[0].src = nir_src_for_ssa(src_coord);
-      tex->src[1].src_type = nir_tex_src_lod;
-      tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-      tex->src[2].src_type = nir_tex_src_texture_deref;
-      tex->src[2].src = nir_src_for_ssa(tex_deref);
-      tex->dest_type = nir_type_uint32;
-      tex->is_array = false;
-      tex->coord_components = 3;
-
-      nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-      nir_builder_instr_insert(&b, &tex->instr);
-      nir_store_var(&b, payload_var, &tex->dest.ssa, 0xf);
+      nir_ssa_def *color = nir_txf_deref(&b, nir_build_deref_var(&b, input_img_3d), src_coord,
+                                         nir_imm_int(&b, 0));
+      nir_store_var(&b, payload_var, color, 0xf);
    }
    nir_push_else(&b, NULL);
    {
-      nir_ssa_def *tex_deref = &nir_build_deref_var(&b, input_img_2d)->dest.ssa;
-
-      nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-      tex->sampler_dim = GLSL_SAMPLER_DIM_2D;
-      tex->op = nir_texop_txf;
-      tex->src[0].src_type = nir_tex_src_coord;
-      tex->src[0].src = nir_src_for_ssa(src_coord);
-      tex->src[1].src_type = nir_tex_src_lod;
-      tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-      tex->src[2].src_type = nir_tex_src_texture_deref;
-      tex->src[2].src = nir_src_for_ssa(tex_deref);
-      tex->dest_type = nir_type_uint32;
-      tex->is_array = true;
-      tex->coord_components = 3;
-
-      nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-      nir_builder_instr_insert(&b, &tex->instr);
-      nir_store_var(&b, payload_var, &tex->dest.ssa, 0xf);
+      nir_ssa_def *color = nir_txf_deref(&b, nir_build_deref_var(&b, input_img_2d), src_coord,
+                                         nir_imm_int(&b, 0));
+      nir_store_var(&b, payload_var, color, 0xf);
    }
    nir_pop_if(&b, NULL);
 
diff --git a/src/amd/vulkan/radv_meta_fmask_copy.c b/src/amd/vulkan/radv_meta_fmask_copy.c
index 3b4eebec499b..09b08cc8942e 100644
--- a/src/amd/vulkan/radv_meta_fmask_copy.c
+++ b/src/amd/vulkan/radv_meta_fmask_copy.c
@@ -58,26 +58,13 @@ build_fmask_copy_compute_shader(struct radv_device *dev, int samples)
                                          nir_ssa_undef(&b, 1, 32),
                                          nir_ssa_undef(&b, 1, 32));
 
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-   /* Fetch the mask for this fragment. */
-   nir_tex_instr *frag_mask_fetch = nir_tex_instr_create(b.shader, 3);
-   frag_mask_fetch->sampler_dim = GLSL_SAMPLER_DIM_MS;
-   frag_mask_fetch->op = nir_texop_fragment_mask_fetch_amd;
-   frag_mask_fetch->src[0].src_type = nir_tex_src_coord;
-   frag_mask_fetch->src[0].src = nir_src_for_ssa(src_coord);
-   frag_mask_fetch->src[1].src_type = nir_tex_src_lod;
-   frag_mask_fetch->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   frag_mask_fetch->src[2].src_type = nir_tex_src_texture_deref;
-   frag_mask_fetch->src[2].src = nir_src_for_ssa(input_img_deref);
-   frag_mask_fetch->dest_type = nir_type_uint32;
-   frag_mask_fetch->is_array = false;
-   frag_mask_fetch->coord_components = 2;
-
-   nir_ssa_dest_init(&frag_mask_fetch->instr, &frag_mask_fetch->dest, 1, 32, "frag_mask_fetch");
-   nir_builder_instr_insert(&b, &frag_mask_fetch->instr);
-
-   nir_ssa_def *frag_mask = &frag_mask_fetch->dest.ssa;
+   nir_tex_src frag_mask_srcs[] = {{
+      .src_type = nir_tex_src_coord,
+      .src = nir_src_for_ssa(src_coord),
+   }};
+   nir_ssa_def *frag_mask = nir_build_tex_deref_instr(&b, nir_texop_fragment_mask_fetch_amd,
+                                                      nir_build_deref_var(&b, input_img), NULL,
+                                                      ARRAY_SIZE(frag_mask_srcs), frag_mask_srcs);
 
    /* Get the maximum sample used in this fragment. */
    nir_ssa_def *max_sample_index = nir_imm_int(&b, 0);
@@ -95,25 +82,17 @@ build_fmask_copy_compute_shader(struct radv_device *dev, int samples)
    {
       nir_ssa_def *sample_id = nir_load_var(&b, counter);
 
-      nir_tex_instr *frag_fetch = nir_tex_instr_create(b.shader, 4);
-      frag_fetch->sampler_dim = GLSL_SAMPLER_DIM_MS;
-      frag_fetch->op = nir_texop_fragment_fetch_amd;
-      frag_fetch->src[0].src_type = nir_tex_src_coord;
-      frag_fetch->src[0].src = nir_src_for_ssa(src_coord);
-      frag_fetch->src[1].src_type = nir_tex_src_lod;
-      frag_fetch->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-      frag_fetch->src[2].src_type = nir_tex_src_texture_deref;
-      frag_fetch->src[2].src = nir_src_for_ssa(input_img_deref);
-      frag_fetch->src[3].src_type = nir_tex_src_ms_index;
-      frag_fetch->src[3].src = nir_src_for_ssa(sample_id);
-      frag_fetch->dest_type = nir_type_float32;
-      frag_fetch->is_array = false;
-      frag_fetch->coord_components = 2;
-
-      nir_ssa_dest_init(&frag_fetch->instr, &frag_fetch->dest, 4, 32, "frag_fetch");
-      nir_builder_instr_insert(&b, &frag_fetch->instr);
-
-      nir_ssa_def *outval = &frag_fetch->dest.ssa;
+      nir_tex_src frag_fetch_srcs[] = {{
+         .src_type = nir_tex_src_coord,
+         .src = nir_src_for_ssa(src_coord),
+      }, {
+         .src_type = nir_tex_src_ms_index,
+         .src = nir_src_for_ssa(sample_id),
+      }};
+      nir_ssa_def *outval = nir_build_tex_deref_instr(&b, nir_texop_fragment_fetch_amd,
+                                                      nir_build_deref_var(&b, input_img), NULL,
+                                                      ARRAY_SIZE(frag_fetch_srcs), frag_fetch_srcs);
+
       nir_image_deref_store(&b, &nir_build_deref_var(&b, output_img)->dest.ssa, dst_coord,
                             sample_id, outval, nir_imm_int(&b, 0),
                             .image_dim = GLSL_SAMPLER_DIM_MS);
diff --git a/src/amd/vulkan/radv_meta_fmask_expand.c b/src/amd/vulkan/radv_meta_fmask_expand.c
index 1f3df57b12b6..e69d331b5df7 100644
--- a/src/amd/vulkan/radv_meta_fmask_expand.c
+++ b/src/amd/vulkan/radv_meta_fmask_expand.c
@@ -47,30 +47,14 @@ build_fmask_expand_compute_shader(struct radv_device *device, int samples)
    output_img->data.binding = 1;
    output_img->data.access = ACCESS_NON_READABLE;
 
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
+   nir_deref_instr *input_img_deref = nir_build_deref_var(&b, input_img);
    nir_ssa_def *output_img_deref = &nir_build_deref_var(&b, output_img)->dest.ssa;
 
    nir_ssa_def *tex_coord = get_global_ids(&b, 3);
 
-   nir_tex_instr *tex_instr[8];
+   nir_ssa_def *tex_vals[8];
    for (uint32_t i = 0; i < samples; i++) {
-      tex_instr[i] = nir_tex_instr_create(b.shader, 3);
-
-      nir_tex_instr *tex = tex_instr[i];
-      tex->sampler_dim = GLSL_SAMPLER_DIM_MS;
-      tex->op = nir_texop_txf_ms;
-      tex->src[0].src_type = nir_tex_src_coord;
-      tex->src[0].src = nir_src_for_ssa(tex_coord);
-      tex->src[1].src_type = nir_tex_src_ms_index;
-      tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, i));
-      tex->src[2].src_type = nir_tex_src_texture_deref;
-      tex->src[2].src = nir_src_for_ssa(input_img_deref);
-      tex->dest_type = nir_type_float32;
-      tex->is_array = true;
-      tex->coord_components = 3;
-
-      nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-      nir_builder_instr_insert(&b, &tex->instr);
+      tex_vals[i] = nir_txf_ms_deref(&b, input_img_deref, tex_coord, nir_imm_int(&b, i));
    }
 
    nir_ssa_def *img_coord =
@@ -78,9 +62,7 @@ build_fmask_expand_compute_shader(struct radv_device *device, int samples)
                nir_channel(&b, tex_coord, 2), nir_ssa_undef(&b, 1, 32));
 
    for (uint32_t i = 0; i < samples; i++) {
-      nir_ssa_def *outval = &tex_instr[i]->dest.ssa;
-
-      nir_image_deref_store(&b, output_img_deref, img_coord, nir_imm_int(&b, i), outval,
+      nir_image_deref_store(&b, output_img_deref, img_coord, nir_imm_int(&b, i), tex_vals[i],
                             nir_imm_int(&b, 0), .image_dim = GLSL_SAMPLER_DIM_MS, .image_array = true);
    }
 
diff --git a/src/amd/vulkan/radv_meta_resolve_cs.c b/src/amd/vulkan/radv_meta_resolve_cs.c
index a6038d189787..6656bae7223c 100644
--- a/src/amd/vulkan/radv_meta_resolve_cs.c
+++ b/src/amd/vulkan/radv_meta_resolve_cs.c
@@ -161,62 +161,29 @@ build_depth_stencil_resolve_compute_shader(struct radv_device *dev, int samples,
                                          nir_channel(&b, resolve_coord, 1),
                                          nir_channel(&b, global_id, 2));
 
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-   nir_alu_type type = index == DEPTH_RESOLVE ? nir_type_float32 : nir_type_uint32;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_MS;
-   tex->op = nir_texop_txf_ms;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(img_coord);
-   tex->src[1].src_type = nir_tex_src_ms_index;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_img_deref);
-   tex->dest_type = type;
-   tex->is_array = true;
-   tex->coord_components = 3;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
-
-   nir_ssa_def *outval = &tex->dest.ssa;
+   nir_deref_instr *input_img_deref = nir_build_deref_var(&b, input_img);
+   nir_ssa_def *outval = nir_txf_ms_deref(&b, input_img_deref, img_coord, nir_imm_int(&b, 0));
 
    if (resolve_mode != VK_RESOLVE_MODE_SAMPLE_ZERO_BIT) {
       for (int i = 1; i < samples; i++) {
-         nir_tex_instr *tex_add = nir_tex_instr_create(b.shader, 3);
-         tex_add->sampler_dim = GLSL_SAMPLER_DIM_MS;
-         tex_add->op = nir_texop_txf_ms;
-         tex_add->src[0].src_type = nir_tex_src_coord;
-         tex_add->src[0].src = nir_src_for_ssa(img_coord);
-         tex_add->src[1].src_type = nir_tex_src_ms_index;
-         tex_add->src[1].src = nir_src_for_ssa(nir_imm_int(&b, i));
-         tex_add->src[2].src_type = nir_tex_src_texture_deref;
-         tex_add->src[2].src = nir_src_for_ssa(input_img_deref);
-         tex_add->dest_type = type;
-         tex_add->is_array = true;
-         tex_add->coord_components = 3;
-
-         nir_ssa_dest_init(&tex_add->instr, &tex_add->dest, 4, 32, "tex");
-         nir_builder_instr_insert(&b, &tex_add->instr);
+         nir_ssa_def *si = nir_txf_ms_deref(&b, input_img_deref, img_coord, nir_imm_int(&b, i));
 
          switch (resolve_mode) {
          case VK_RESOLVE_MODE_AVERAGE_BIT:
             assert(index == DEPTH_RESOLVE);
-            outval = nir_fadd(&b, outval, &tex_add->dest.ssa);
+            outval = nir_fadd(&b, outval, si);
             break;
          case VK_RESOLVE_MODE_MIN_BIT:
             if (index == DEPTH_RESOLVE)
-               outval = nir_fmin(&b, outval, &tex_add->dest.ssa);
+               outval = nir_fmin(&b, outval, si);
             else
-               outval = nir_umin(&b, outval, &tex_add->dest.ssa);
+               outval = nir_umin(&b, outval, si);
             break;
          case VK_RESOLVE_MODE_MAX_BIT:
             if (index == DEPTH_RESOLVE)
-               outval = nir_fmax(&b, outval, &tex_add->dest.ssa);
+               outval = nir_fmax(&b, outval, si);
             else
-               outval = nir_umax(&b, outval, &tex_add->dest.ssa);
+               outval = nir_umax(&b, outval, si);
             break;
          default:
             unreachable("invalid resolve mode");
diff --git a/src/amd/vulkan/radv_meta_resolve_fs.c b/src/amd/vulkan/radv_meta_resolve_fs.c
index 7aad741e45df..5b2636321d49 100644
--- a/src/amd/vulkan/radv_meta_resolve_fs.c
+++ b/src/amd/vulkan/radv_meta_resolve_fs.c
@@ -255,7 +255,7 @@ build_depth_stencil_resolve_fragment_shader(struct radv_device *dev, int samples
    enum glsl_base_type img_base_type = index == DEPTH_RESOLVE ? GLSL_TYPE_FLOAT : GLSL_TYPE_UINT;
    const struct glsl_type *vec4 = glsl_vec4_type();
    const struct glsl_type *sampler_type =
-      glsl_sampler_type(GLSL_SAMPLER_DIM_2D, false, false, img_base_type);
+      glsl_sampler_type(GLSL_SAMPLER_DIM_MS, false, false, img_base_type);
 
    nir_builder b = radv_meta_init_shader(dev, MESA_SHADER_FRAGMENT, "meta_resolve_fs_%s-%s-%d",
                                          index == DEPTH_RESOLVE ? "depth" : "stencil",
@@ -274,62 +274,29 @@ build_depth_stencil_resolve_fragment_shader(struct radv_device *dev, int samples
 
    nir_ssa_def *img_coord = nir_channels(&b, pos_int, 0x3);
 
-   nir_ssa_def *input_img_deref = &nir_build_deref_var(&b, input_img)->dest.ssa;
-
-   nir_alu_type type = index == DEPTH_RESOLVE ? nir_type_float32 : nir_type_uint32;
-
-   nir_tex_instr *tex = nir_tex_instr_create(b.shader, 3);
-   tex->sampler_dim = GLSL_SAMPLER_DIM_MS;
-   tex->op = nir_texop_txf_ms;
-   tex->src[0].src_type = nir_tex_src_coord;
-   tex->src[0].src = nir_src_for_ssa(img_coord);
-   tex->src[1].src_type = nir_tex_src_ms_index;
-   tex->src[1].src = nir_src_for_ssa(nir_imm_int(&b, 0));
-   tex->src[2].src_type = nir_tex_src_texture_deref;
-   tex->src[2].src = nir_src_for_ssa(input_img_deref);
-   tex->dest_type = type;
-   tex->is_array = false;
-   tex->coord_components = 2;
-
-   nir_ssa_dest_init(&tex->instr, &tex->dest, 4, 32, "tex");
-   nir_builder_instr_insert(&b, &tex->instr);
-
-   nir_ssa_def *outval = &tex->dest.ssa;
+   nir_deref_instr *input_img_deref = nir_build_deref_var(&b, input_img);
+   nir_ssa_def *outval = nir_txf_ms_deref(&b, input_img_deref, img_coord, nir_imm_int(&b, 0));
 
    if (resolve_mode != VK_RESOLVE_MODE_SAMPLE_ZERO_BIT) {
       for (int i = 1; i < samples; i++) {
-         nir_tex_instr *tex_add = nir_tex_instr_create(b.shader, 3);
-         tex_add->sampler_dim = GLSL_SAMPLER_DIM_MS;
-         tex_add->op = nir_texop_txf_ms;
-         tex_add->src[0].src_type = nir_tex_src_coord;
-         tex_add->src[0].src = nir_src_for_ssa(img_coord);
-         tex_add->src[1].src_type = nir_tex_src_ms_index;
-         tex_add->src[1].src = nir_src_for_ssa(nir_imm_int(&b, i));
-         tex_add->src[2].src_type = nir_tex_src_texture_deref;
-         tex_add->src[2].src = nir_src_for_ssa(input_img_deref);
-         tex_add->dest_type = type;
-         tex_add->is_array = false;
-         tex_add->coord_components = 2;
-
-         nir_ssa_dest_init(&tex_add->instr, &tex_add->dest, 4, 32, "tex");
-         nir_builder_instr_insert(&b, &tex_add->instr);
+         nir_ssa_def *si = nir_txf_ms_deref(&b, input_img_deref, img_coord, nir_imm_int(&b, i));
 
          switch (resolve_mode) {
          case VK_RESOLVE_MODE_AVERAGE_BIT:
             assert(index == DEPTH_RESOLVE);
-            outval = nir_fadd(&b, outval, &tex_add->dest.ssa);
+            outval = nir_fadd(&b, outval, si);
             break;
          case VK_RESOLVE_MODE_MIN_BIT:
             if (index == DEPTH_RESOLVE)
-               outval = nir_fmin(&b, outval, &tex_add->dest.ssa);
+               outval = nir_fmin(&b, outval, si);
             else
-               outval = nir_umin(&b, outval, &tex_add->dest.ssa);
+               outval = nir_umin(&b, outval, si);
             break;
          case VK_RESOLVE_MODE_MAX_BIT:
             if (index == DEPTH_RESOLVE)
-               outval = nir_fmax(&b, outval, &tex_add->dest.ssa);
+               outval = nir_fmax(&b, outval, si);
             else
-               outval = nir_umax(&b, outval, &tex_add->dest.ssa);
+               outval = nir_umax(&b, outval, si);
             break;
          default:
             unreachable("invalid resolve mode");
-- 
GitLab

