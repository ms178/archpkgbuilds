From 74656730cad3acca9f3c7970e97b01dc5d8e6c7a Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Sat, 20 Aug 2022 20:16:30 +0200
Subject: [PATCH 1/3] radv: Add binding code for 3d sparse images.

GFX7-8 code is kinda expected. For GFX9 and GFX10 the entire
mipchain is duplicated by "layer" even though smaller mips also
have less layers.

Reviewed-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device.c | 45 ++++++++++++++++++++++--------------
 1 file changed, 28 insertions(+), 17 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 488cd5f5ff4b..14de8d5411b2 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -4817,7 +4817,7 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
 
    for (uint32_t i = 0; i < bind->bindCount; ++i) {
       struct radv_device_memory *mem = NULL;
-      uint32_t offset, pitch;
+      uint32_t offset, pitch, depth_pitch;
       uint32_t mem_offset = bind->pBinds[i].memoryOffset;
       const uint32_t layer = bind->pBinds[i].subresource.arrayLayer;
       const uint32_t level = bind->pBinds[i].subresource.mipLevel;
@@ -4838,36 +4838,47 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
       if (device->physical_device->rad_info.gfx_level >= GFX9) {
          offset = surface->u.gfx9.surf_slice_size * layer + surface->u.gfx9.prt_level_offset[level];
          pitch = surface->u.gfx9.prt_level_pitch[level];
+         depth_pitch = surface->u.gfx9.surf_slice_size;
       } else {
-         offset = (uint64_t)surface->u.legacy.level[level].offset_256B * 256 +
-                  surface->u.legacy.level[level].slice_size_dw * 4 * layer;
+         depth_pitch = surface->u.legacy.level[level].slice_size_dw * 4;
+         offset = (uint64_t)surface->u.legacy.level[level].offset_256B * 256 + depth_pitch * layer;
          pitch = surface->u.legacy.level[level].nblk_x;
       }
 
-      offset += (bind_offset.y * pitch * bs) + (bind_offset.x * surface->prt_tile_height * bs);
+      offset += bind_offset.z * depth_pitch +
+                (bind_offset.y * pitch * surface->prt_tile_depth +
+                 bind_offset.x * surface->prt_tile_height * surface->prt_tile_depth) *
+                   bs;
 
       uint32_t aligned_extent_width = ALIGN(bind_extent.width, surface->prt_tile_width);
+      uint32_t aligned_extent_height = ALIGN(bind_extent.height, surface->prt_tile_height);
+      uint32_t aligned_extent_depth = ALIGN(bind_extent.depth, surface->prt_tile_depth);
 
-      bool whole_subres = bind_offset.x == 0 && aligned_extent_width == pitch;
+      bool whole_subres =
+         (bind_extent.height <= surface->prt_tile_height || aligned_extent_width == pitch) &&
+         (bind_extent.depth <= surface->prt_tile_depth ||
+          aligned_extent_width * aligned_extent_height * bs == depth_pitch);
 
       if (whole_subres) {
-         uint32_t aligned_extent_height = ALIGN(bind_extent.height, surface->prt_tile_height);
-
-         uint32_t size = aligned_extent_width * aligned_extent_height * bs;
+         uint32_t size = aligned_extent_width * aligned_extent_height * aligned_extent_depth * bs;
          result = device->ws->buffer_virtual_bind(device->ws, image->bindings[0].bo, offset, size,
                                                   mem ? mem->bo : NULL, mem_offset);
          if (result != VK_SUCCESS)
             return result;
       } else {
-         uint32_t img_increment = pitch * bs;
-         uint32_t mem_increment = aligned_extent_width * bs;
-         uint32_t size = mem_increment * surface->prt_tile_height;
-         for (unsigned y = 0; y < bind_extent.height; y += surface->prt_tile_height) {
-            result = device->ws->buffer_virtual_bind(device->ws,
-               image->bindings[0].bo, offset + img_increment * y, size, mem ? mem->bo : NULL,
-               mem_offset + mem_increment * y);
-            if (result != VK_SUCCESS)
-               return result;
+         uint32_t img_y_increment = pitch * bs * surface->prt_tile_depth;
+         uint32_t mem_y_increment = aligned_extent_width * bs * surface->prt_tile_depth;
+         uint32_t mem_z_increment = aligned_extent_width * aligned_extent_height * bs;
+         uint32_t size = mem_y_increment * surface->prt_tile_height;
+         for (unsigned z = 0; z < bind_extent.depth;
+              z += surface->prt_tile_depth, offset += depth_pitch) {
+            for (unsigned y = 0; y < bind_extent.height; y += surface->prt_tile_height) {
+               result = device->ws->buffer_virtual_bind(
+                  device->ws, image->bindings[0].bo, offset + img_y_increment * y, size,
+                  mem ? mem->bo : NULL, mem_offset + mem_y_increment * y + mem_z_increment * z);
+               if (result != VK_SUCCESS)
+                  return result;
+            }
          }
       }
    }
-- 
GitLab


From f2271fda2a0581351467e74de177fa81b7405cdd Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Sat, 20 Aug 2022 20:17:07 +0200
Subject: [PATCH 2/3] radv: Add 3d tile shapes for sparse binding.

Reviewed-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_formats.c | 39 ++++++++++++++++++++++++++---------
 1 file changed, 29 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index bef8df6d97ac..421e0f59c370 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -1880,8 +1880,8 @@ fail:
 }
 
 static void
-fill_sparse_image_format_properties(struct radv_physical_device *pdev, VkFormat format,
-                                    VkSparseImageFormatProperties *prop)
+fill_sparse_image_format_properties(struct radv_physical_device *pdev, VkImageType type,
+                                    VkFormat format, VkSparseImageFormatProperties *prop)
 {
    prop->aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    prop->flags = 0;
@@ -1892,12 +1892,29 @@ fill_sparse_image_format_properties(struct radv_physical_device *pdev, VkFormat
    if (pdev->rad_info.gfx_level < GFX9)
       prop->flags |= VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT;
 
-   /* This assumes the sparse image tile size is always 64 KiB (1 << 16) */
-   unsigned l2_size = 16 - util_logbase2(vk_format_get_blocksize(format));
-   unsigned w = (1u << ((l2_size + 1) / 2)) * vk_format_get_blockwidth(format);
-   unsigned h = (1u << (l2_size / 2)) * vk_format_get_blockheight(format);
-
-   prop->imageGranularity = (VkExtent3D){w, h, 1};
+   unsigned w, h;
+   unsigned d = 1;
+   if (type == VK_IMAGE_TYPE_3D) {
+      if (pdev->rad_info.gfx_level >= GFX9) {
+         unsigned l2_size = 16 - util_logbase2(vk_format_get_blocksize(format));
+         w = (1u << ((l2_size + 2) / 3)) * vk_format_get_blockwidth(format);
+         h = (1u << ((l2_size + 1) / 3)) * vk_format_get_blockheight(format);
+         d = (1u << ((l2_size + 0) / 3));
+      } else {
+         /* GFX7/GFX8 thick tiling modes */
+         unsigned bs = vk_format_get_blocksize(format);
+         unsigned l2_size = 16 - util_logbase2(bs) - (bs <= 4 ? 2 : 0);
+         w = (1u << ((l2_size + 1) / 2)) * vk_format_get_blockwidth(format);
+         h = (1u << (l2_size / 2)) * vk_format_get_blockheight(format);
+         d = bs <= 4 ? 4 : 1;
+      }
+   } else {
+      /* This assumes the sparse image tile size is always 64 KiB (1 << 16) */
+      unsigned l2_size = 16 - util_logbase2(vk_format_get_blocksize(format));
+      w = (1u << ((l2_size + 1) / 2)) * vk_format_get_blockwidth(format);
+      h = (1u << (l2_size / 2)) * vk_format_get_blockheight(format);
+   }
+   prop->imageGranularity = (VkExtent3D){w, h, d};
 }
 
 VKAPI_ATTR void VKAPI_CALL
@@ -1932,7 +1949,8 @@ radv_GetPhysicalDeviceSparseImageFormatProperties2(
 
    vk_outarray_append_typed(VkSparseImageFormatProperties2, &out, prop)
    {
-      fill_sparse_image_format_properties(pdev, pFormatInfo->format, &prop->properties);
+      fill_sparse_image_format_properties(pdev, pFormatInfo->type, pFormatInfo->format,
+                                          &prop->properties);
    };
 }
 
@@ -1955,7 +1973,8 @@ radv_GetImageSparseMemoryRequirements2(VkDevice _device,
 
    vk_outarray_append_typed(VkSparseImageMemoryRequirements2, &out, req)
    {
-      fill_sparse_image_format_properties(device->physical_device, image->vk.format,
+      fill_sparse_image_format_properties(device->physical_device, image->vk.image_type,
+                                          image->vk.format,
                                           &req->memoryRequirements.formatProperties);
       req->memoryRequirements.imageMipTailFirstLod = image->planes[0].surface.first_mip_tail_level;
 
-- 
GitLab


From a7b99130de167b00d6756be297e4bac41ab92dcd Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Sat, 20 Aug 2022 20:19:19 +0200
Subject: [PATCH 3/3] radv: Expose 3d sparse images.

Tested-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Reviewed-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device.c                    | 2 ++
 src/amd/vulkan/radv_formats.c                   | 2 +-
 src/gallium/drivers/zink/ci/zink-radv-fails.txt | 5 -----
 3 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 14de8d5411b2..f616fc1f1047 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1321,6 +1321,7 @@ radv_GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDevice
       .sparseBinding = true,
       .sparseResidencyBuffer = pdevice->rad_info.family >= CHIP_POLARIS10,
       .sparseResidencyImage2D = pdevice->rad_info.family >= CHIP_POLARIS10,
+      .sparseResidencyImage3D = pdevice->rad_info.family >= CHIP_POLARIS10,
       .sparseResidencyAliased = pdevice->rad_info.family >= CHIP_POLARIS10,
       .variableMultisampleRate = true,
       .shaderResourceMinLod = true,
@@ -2038,6 +2039,7 @@ radv_GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice,
          {
             .residencyNonResidentStrict = pdevice->rad_info.family >= CHIP_POLARIS10,
             .residencyStandard2DBlockShape = pdevice->rad_info.family >= CHIP_POLARIS10,
+            .residencyStandard3DBlockShape = pdevice->rad_info.gfx_level >= GFX9,
          },
    };
 
diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index 421e0f59c370..fd75ba1b6be9 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -1631,7 +1631,7 @@ radv_get_image_format_properties(struct radv_physical_device *physical_device,
       if (physical_device->rad_info.gfx_level < GFX8)
          goto unsupported;
 
-      if (vk_format_get_plane_count(format) > 1 || info->type != VK_IMAGE_TYPE_2D ||
+      if (vk_format_get_plane_count(format) > 1 || info->type == VK_IMAGE_TYPE_1D ||
           info->tiling != VK_IMAGE_TILING_OPTIMAL || vk_format_is_depth_or_stencil(format))
          goto unsupported;
    }

