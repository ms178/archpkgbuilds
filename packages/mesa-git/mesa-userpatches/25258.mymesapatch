From 4069c5f06f33e29ee175c63e7611d3890723525d Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Wed, 30 Aug 2023 13:18:30 +0200
Subject: [PATCH 1/4] gallium/auxiliary/vl: Add RGB to YUV compute shader

Compared to fragment shader that was being used before, it supports
chroma location and fixes wrong color at right/bottom edge when scaling.
---
 src/gallium/auxiliary/vl/vl_compositor.c    |  23 +--
 src/gallium/auxiliary/vl/vl_compositor.h    |   5 +
 src/gallium/auxiliary/vl/vl_compositor_cs.c | 162 ++++++++++++++++++++
 3 files changed, 180 insertions(+), 10 deletions(-)

diff --git a/src/gallium/auxiliary/vl/vl_compositor.c b/src/gallium/auxiliary/vl/vl_compositor.c
index 95b6e42636c66..42285d1b61c07 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.c
+++ b/src/gallium/auxiliary/vl/vl_compositor.c
@@ -61,6 +61,13 @@ init_shaders(struct vl_compositor *c)
          debug_printf("Unable to create YCbCr i-to-YCbCr p deint fragment shader.\n");
          return false;
       }
+
+      c->fs_rgb_yuv.y = create_frag_shader_rgb_yuv(c, true);
+      c->fs_rgb_yuv.uv = create_frag_shader_rgb_yuv(c, false);
+      if (!c->fs_rgb_yuv.y || !c->fs_rgb_yuv.uv) {
+         debug_printf("Unable to create RGB-to-YUV fragment shader.\n");
+         return false;
+      }
    }
 
    if (c->pipe_gfx_supported) {
@@ -82,13 +89,6 @@ init_shaders(struct vl_compositor *c)
          return false;
       }
 
-      c->fs_rgb_yuv.y = create_frag_shader_rgb_yuv(c, true);
-      c->fs_rgb_yuv.uv = create_frag_shader_rgb_yuv(c, false);
-      if (!c->fs_rgb_yuv.y || !c->fs_rgb_yuv.uv) {
-         debug_printf("Unable to create RGB-to-YUV fragment shader.\n");
-         return false;
-      }
-
       c->fs_rgba = create_frag_shader_rgba(c);
       if (!c->fs_rgba) {
          debug_printf("Unable to create RGB-to-RGB fragment shader.\n");
@@ -112,14 +112,14 @@ static void cleanup_shaders(struct vl_compositor *c)
       c->pipe->delete_fs_state(c->pipe, c->fs_yuv.weave.uv);
       c->pipe->delete_fs_state(c->pipe, c->fs_yuv.bob.y);
       c->pipe->delete_fs_state(c->pipe, c->fs_yuv.bob.uv);
+      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.y);
+      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.uv);
    }
 
    if (c->pipe_gfx_supported) {
       c->pipe->delete_vs_state(c->pipe, c->vs);
       c->pipe->delete_fs_state(c->pipe, c->fs_palette.yuv);
       c->pipe->delete_fs_state(c->pipe, c->fs_palette.rgb);
-      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.y);
-      c->pipe->delete_fs_state(c->pipe, c->fs_rgb_yuv.uv);
       c->pipe->delete_fs_state(c->pipe, c->fs_rgba);
    }
 }
@@ -392,7 +392,10 @@ set_rgb_to_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
 
    s->used_layers |= 1 << layer;
 
-   s->layers[layer].fs = y? c->fs_rgb_yuv.y : c->fs_rgb_yuv.uv;
+   if (c->pipe_cs_composit_supported)
+      s->layers[layer].cs = y ? c->cs_rgb_yuv.y : c->cs_rgb_yuv.uv;
+   else if (c->pipe_gfx_supported)
+      s->layers[layer].fs = y ? c->fs_rgb_yuv.y : c->fs_rgb_yuv.uv;
 
    s->layers[layer].samplers[0] = c->sampler_linear;
    s->layers[layer].samplers[1] = NULL;
diff --git a/src/gallium/auxiliary/vl/vl_compositor.h b/src/gallium/auxiliary/vl/vl_compositor.h
index 91ea5c5c72053..8966e032cde17 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.h
+++ b/src/gallium/auxiliary/vl/vl_compositor.h
@@ -178,6 +178,11 @@ struct vl_compositor
       void *y;
       void *uv;
    } fs_rgb_yuv;
+
+   struct {
+      void *y;
+      void *uv;
+   } cs_rgb_yuv;
 };
 
 /**
diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.c b/src/gallium/auxiliary/vl/vl_compositor_cs.c
index 598f79b655b32..ae56a19c0b182 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.c
@@ -756,6 +756,157 @@ static const char *compute_shader_yuv_uv =
 
       "END\n";
 
+static const char *compute_shader_rgb_yuv_y =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..7]\n"
+      "DCL SVIEW[0], RECT, FLOAT\n"
+      "DCL SAMP[0]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..4]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 2.0, 0.5, 0.0}\n"
+
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1]\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[0], -CONST[5].xyxy\n"
+         "U2F TEMP[2], TEMP[2]\n"
+
+         /* Texture offset */
+         "ADD TEMP[2].xy, TEMP[2].xyxx, IMM[1].zzzz\n"
+
+         /* Scale */
+         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
+
+         /* Crop */
+         "MOV TEMP[4].xy, CONST[6].zwww\n"
+         "I2F TEMP[4], TEMP[4]\n"
+         "ADD TEMP[2], TEMP[2], TEMP[4]\n"
+
+         /* Clamp coords */
+         "MIN TEMP[2].xy, TEMP[2].xyyy, CONST[7].xyxy\n"
+
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].xyz, TEMP[2], SAMP[0], RECT\n"
+
+         "MOV TEMP[4].w, IMM[1].xxxx\n"
+
+         /* Color Space Conversion */
+         "DP4 TEMP[4].x, CONST[0], TEMP[4]\n"
+
+         "MOV TEMP[4].yzw, IMM[1].xxxx\n"
+
+         "STORE IMAGE[0], TEMP[0], TEMP[4], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
+static const char *compute_shader_rgb_yuv_uv =
+      "COMP\n"
+      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
+      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
+      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
+
+      "DCL SV[0], THREAD_ID\n"
+      "DCL SV[1], BLOCK_ID\n"
+
+      "DCL CONST[0..8]\n"
+      "DCL SVIEW[0], RECT, FLOAT\n"
+      "DCL SAMP[0]\n"
+
+      "DCL IMAGE[0], 2D, WR\n"
+      "DCL TEMP[0..9]\n"
+
+      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
+      "IMM[1] FLT32 { 1.0, 0.25, 0.5, -0.25}\n"
+
+      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
+
+      /* Drawn area check */
+      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
+      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
+      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
+
+      "UIF TEMP[1]\n"
+         /* Translate */
+         "UADD TEMP[2].xy, TEMP[0], -CONST[5].xyxy\n"
+         "U2F TEMP[2], TEMP[2]\n"
+
+         /* Texture offset */
+         "ADD TEMP[2].xy, TEMP[2].xyyy, IMM[1].zzzz\n"
+
+         /* Chroma offset */
+         "MAD TEMP[2].xy, CONST[8].xyxy, -IMM[1].zzzz, TEMP[2].xyxy\n"
+
+         /* Sample offset */
+         "ADD TEMP[3].xy, TEMP[2].xyyy, IMM[1].yyyy\n"
+         "ADD TEMP[6].xy, TEMP[2].xyyy, IMM[1].wwww\n"
+         "ADD TEMP[7].xy, TEMP[2].xyyy, IMM[1].wyyy\n"
+         "ADD TEMP[2].xy, TEMP[2].xyyy, IMM[1].ywww\n"
+
+         /* Scale */
+         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
+         "DIV TEMP[3], TEMP[3], CONST[3].zwzw\n"
+         "DIV TEMP[6], TEMP[6], CONST[3].zwzw\n"
+         "DIV TEMP[7], TEMP[7], CONST[3].zwzw\n"
+
+         /* Crop */
+         "MOV TEMP[4].xy, CONST[6].zwww\n"
+         "I2F TEMP[4], TEMP[4]\n"
+         "ADD TEMP[2], TEMP[2], TEMP[4]\n"
+         "ADD TEMP[3], TEMP[3], TEMP[4]\n"
+         "ADD TEMP[6], TEMP[6], TEMP[4]\n"
+         "ADD TEMP[7], TEMP[7], TEMP[4]\n"
+
+         /* Clamp coords */
+         "MIN TEMP[2].xy, TEMP[2].xyyy, CONST[7].zwzw\n"
+         "MIN TEMP[3].xy, TEMP[3].xyyy, CONST[7].zwzw\n"
+         "MIN TEMP[6].xy, TEMP[6].xyyy, CONST[7].zwzw\n"
+         "MIN TEMP[7].xy, TEMP[7].xyyy, CONST[7].zwzw\n"
+
+         /* Fetch texels */
+         "TEX_LZ TEMP[4].xyz, TEMP[2], SAMP[0], RECT\n"
+         "TEX_LZ TEMP[5].xyz, TEMP[3], SAMP[0], RECT\n"
+         "TEX_LZ TEMP[8].xyz, TEMP[6], SAMP[0], RECT\n"
+         "TEX_LZ TEMP[9].xyz, TEMP[7], SAMP[0], RECT\n"
+
+         "ADD TEMP[4].xyz, TEMP[4].xyzz, TEMP[5].xyzz\n"
+         "ADD TEMP[4].xyz, TEMP[4].xyzz, TEMP[8].xyzz\n"
+         "ADD TEMP[4].xyz, TEMP[4].xyzz, TEMP[9].xyzz\n"
+         "MUL TEMP[4].xyz, TEMP[4].xyzz, IMM[1].yyyy\n"
+
+         "MOV TEMP[4].w, IMM[1].xxxx\n"
+
+         /* Color Space Conversion */
+         "DP4 TEMP[5].x, CONST[1], TEMP[4]\n"
+         "DP4 TEMP[5].y, CONST[2], TEMP[4]\n"
+
+         "MOV TEMP[5].zw, IMM[1].xxxx\n"
+
+         "STORE IMAGE[0], TEMP[0], TEMP[5], 2D\n"
+      "ENDIF\n"
+
+      "END\n";
+
 static void
 cs_launch(struct vl_compositor *c,
           void                 *cs,
@@ -1059,6 +1210,13 @@ bool vl_compositor_cs_init_shaders(struct vl_compositor *c)
                 return false;
         }
 
+        c->cs_rgb_yuv.y = vl_compositor_cs_create_shader(c, compute_shader_rgb_yuv_y);
+        c->cs_rgb_yuv.uv = vl_compositor_cs_create_shader(c, compute_shader_rgb_yuv_uv);
+        if (!c->cs_rgb_yuv.y || !c->cs_rgb_yuv.uv) {
+                debug_printf("Unable to create RGB-to-NV12 compute shader.\n");
+                return false;
+        }
+
         return true;
 }
 
@@ -1082,4 +1240,8 @@ void vl_compositor_cs_cleanup_shaders(struct vl_compositor *c)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.progressive.y);
         if (c->cs_yuv.progressive.uv)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.progressive.uv);
+        if (c->cs_rgb_yuv.y)
+                c->pipe->delete_compute_state(c->pipe, c->cs_rgb_yuv.y);
+        if (c->cs_rgb_yuv.uv)
+                c->pipe->delete_compute_state(c->pipe, c->cs_rgb_yuv.uv);
 }
-- 
GitLab


From 5f5689c64f1102edcc2c9a551ea6ab784351209b Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Sat, 2 Sep 2023 17:19:44 +0200
Subject: [PATCH 2/4] gallium/auxiliary/vl: Use chroma offset in YUV to RGB
 weave compute shader

---
 src/gallium/auxiliary/vl/vl_compositor_cs.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.c b/src/gallium/auxiliary/vl/vl_compositor_cs.c
index ae56a19c0b182..5889f93a72b70 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.c
@@ -130,7 +130,7 @@ const char *compute_shader_weave =
       "DCL SV[0], THREAD_ID\n"
       "DCL SV[1], BLOCK_ID\n"
 
-      "DCL CONST[0..7]\n"
+      "DCL CONST[0..8]\n"
       "DCL SVIEW[0..2], 2D_ARRAY, FLOAT\n"
       "DCL SAMP[0..2]\n"
 
@@ -160,8 +160,9 @@ const char *compute_shader_weave =
 
          /* Top UV */
          "MOV TEMP[3].xy, TEMP[2].xyyy\n"
+         /* Chroma offset */
+         "ADD TEMP[3].xy, TEMP[3].xyyy, CONST[8].xyxy\n"
          "DIV TEMP[3].xy, TEMP[3], IMM[1].yyyy\n"
-         "TRUNC TEMP[3].xy, TEMP[3].xyyy\n"
          "DIV TEMP[3].y, TEMP[3].yyyy, IMM[1].yyyy\n"
          /* Down UV */
          "MOV TEMP[13].xy, TEMP[3].xyyy\n"
-- 
GitLab


From 23f16a4ef258508d405ac3fbf7a268dcd44ef9a0 Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Sun, 3 Sep 2023 09:40:05 +0200
Subject: [PATCH 3/4] gallium/auxiliary/vl: Fix YUV to RGB bob compute shader
 deinterlacing

This reverts commit ef0d92459c3f and instead removes the y coordinate
divide by two in weave shaders. The scale ratio now works correctly
with interlaced input.

Also remove the YUV to YUV bob shader and reuse the progressive shader
for bob deinterlacing, same as in YUV to RGB case (video_buffer shader).
---
 src/gallium/auxiliary/vl/vl_compositor.c    |   7 +-
 src/gallium/auxiliary/vl/vl_compositor.h    |   4 -
 src/gallium/auxiliary/vl/vl_compositor_cs.c | 179 +++-----------------
 3 files changed, 22 insertions(+), 168 deletions(-)

diff --git a/src/gallium/auxiliary/vl/vl_compositor.c b/src/gallium/auxiliary/vl/vl_compositor.c
index 42285d1b61c07..ebb88fd4d340c 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.c
+++ b/src/gallium/auxiliary/vl/vl_compositor.c
@@ -330,7 +330,6 @@ set_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
 
    assert(layer < VL_COMPOSITOR_MAX_LAYERS);
 
-   s->interlaced = buffer->interlaced;
    s->used_layers |= 1 << layer;
    sampler_views = buffer->get_sampler_view_components(buffer);
    for (i = 0; i < 3; ++i) {
@@ -352,7 +351,7 @@ set_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
       if (c->pipe_gfx_supported)
           s->layers[layer].fs = (y) ? c->fs_yuv.bob.y : c->fs_yuv.bob.uv;
       if (c->pipe_cs_composit_supported)
-          s->layers[layer].cs = (y) ? c->cs_yuv.bob.y : c->cs_yuv.bob.uv;
+          s->layers[layer].cs = (y) ? c->cs_yuv.progressive.y : c->cs_yuv.progressive.uv;
       break;
 
    case VL_COMPOSITOR_BOB_BOTTOM:
@@ -362,7 +361,7 @@ set_yuv_layer(struct vl_compositor_state *s, struct vl_compositor *c,
       if (c->pipe_gfx_supported)
           s->layers[layer].fs = (y) ? c->fs_yuv.bob.y : c->fs_yuv.bob.uv;
       if (c->pipe_cs_composit_supported)
-          s->layers[layer].cs = (y) ? c->cs_yuv.bob.y : c->cs_yuv.bob.uv;
+          s->layers[layer].cs = (y) ? c->cs_yuv.progressive.y : c->cs_yuv.progressive.uv;
       break;
 
    case VL_COMPOSITOR_NONE:
@@ -443,7 +442,6 @@ vl_compositor_clear_layers(struct vl_compositor_state *s)
    unsigned i, j;
 
    assert(s);
-   s->interlaced = false;
    s->used_layers = 0;
    for ( i = 0; i < VL_COMPOSITOR_MAX_LAYERS; ++i) {
       struct vertex4f v_one = { 1.0f, 1.0f, 1.0f, 1.0f };
@@ -563,7 +561,6 @@ vl_compositor_set_buffer_layer(struct vl_compositor_state *s,
 
    assert(layer < VL_COMPOSITOR_MAX_LAYERS);
 
-   s->interlaced = buffer->interlaced;
    s->used_layers |= 1 << layer;
    sampler_views = buffer->get_sampler_view_components(buffer);
    for (i = 0; i < 3; ++i) {
diff --git a/src/gallium/auxiliary/vl/vl_compositor.h b/src/gallium/auxiliary/vl/vl_compositor.h
index 8966e032cde17..c8f2515d5ea3d 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.h
+++ b/src/gallium/auxiliary/vl/vl_compositor.h
@@ -159,10 +159,6 @@ struct vl_compositor
          void *y;
          void *uv;
       } weave;
-      struct {
-         void *y;
-         void *uv;
-      } bob;
       struct {
          void *y;
          void *uv;
diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.c b/src/gallium/auxiliary/vl/vl_compositor_cs.c
index 5889f93a72b70..dec2b9c8f2bfc 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.c
@@ -156,32 +156,25 @@ const char *compute_shader_weave =
          /* Translate */
          "UADD TEMP[2].xy, TEMP[2].xyyy, -CONST[5].xyxy\n"
 
-         "U2F TEMP[2].xy, TEMP[2].xyyy\n"
+         /* Top Y */
+         "U2F TEMP[2], TEMP[2]\n"
+         /* Down Y */
+         "MOV TEMP[12], TEMP[2]\n"
 
          /* Top UV */
-         "MOV TEMP[3].xy, TEMP[2].xyyy\n"
+         "MOV TEMP[3], TEMP[2]\n"
          /* Chroma offset */
          "ADD TEMP[3].xy, TEMP[3].xyyy, CONST[8].xyxy\n"
-         "DIV TEMP[3].xy, TEMP[3], IMM[1].yyyy\n"
-         "DIV TEMP[3].y, TEMP[3].yyyy, IMM[1].yyyy\n"
+         "DIV TEMP[3].xy, TEMP[3].xyyy, IMM[1].yyyy\n"
          /* Down UV */
-         "MOV TEMP[13].xy, TEMP[3].xyyy\n"
-
-         /* Top Y */
-         "DIV TEMP[2].y, TEMP[2].yyyy, IMM[1].yyyy\n"
-         /* Down Y */
-         "MOV TEMP[12].xy, TEMP[2].xyyy\n"
+         "MOV TEMP[13], TEMP[3]\n"
 
          /* Texture offset */
-         "ADD TEMP[2].x, TEMP[2].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
-         "ADD TEMP[12].x, TEMP[12].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[12].y, TEMP[12].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[2].xy, TEMP[2].xyyy, IMM[3].yyyy\n"
+         "ADD TEMP[12].xy, TEMP[12].xyyy, IMM[3].yyyy\n"
 
-         "ADD TEMP[3].x, TEMP[3].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].xxxx\n"
-         "ADD TEMP[13].x, TEMP[13].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[13].y, TEMP[13].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[3].xy, TEMP[3].xyyy, IMM[3].xxxx\n"
+         "ADD TEMP[13].xy, TEMP[13].xyyy, IMM[3].xxxx\n"
 
          /* Scale */
          "DIV TEMP[2].xy, TEMP[2].xyyy, CONST[3].zwzw\n"
@@ -329,7 +322,6 @@ static const char *compute_shader_yuv_weave_y =
 
          /* Top Y */
          "U2F TEMP[2], TEMP[2]\n"
-         "DIV TEMP[2].y, TEMP[2].yyyy, IMM[1].yyyy\n"
          /* Down Y */
          "MOV TEMP[12], TEMP[2]\n"
 
@@ -340,15 +332,11 @@ static const char *compute_shader_yuv_weave_y =
          "MOV TEMP[13], TEMP[3]\n"
 
          /* Texture offset */
-         "ADD TEMP[2].x, TEMP[2].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
-         "ADD TEMP[12].x, TEMP[12].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[12].y, TEMP[12].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[2].xy, TEMP[2].xyyy, IMM[3].yyyy\n"
+         "ADD TEMP[12].xy, TEMP[12].xyyy, IMM[3].yyyy\n"
 
-         "ADD TEMP[3].x, TEMP[3].xxxx, IMM[3].xxxx\n"
-         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].wwww\n"
-         "ADD TEMP[13].x, TEMP[13].xxxx, IMM[3].xxxx\n"
-         "ADD TEMP[13].y, TEMP[13].yyyy, IMM[3].wwww\n"
+         "ADD TEMP[3].xy, TEMP[3].xyyy, IMM[3].xxxx\n"
+         "ADD TEMP[13].xy, TEMP[13].xyyy, IMM[3].xxxx\n"
 
          /* Scale */
          "DIV TEMP[2].xy, TEMP[2], CONST[3].zwzw\n"
@@ -441,7 +429,6 @@ static const char *compute_shader_yuv_weave_uv =
 
          /* Top Y */
          "U2F TEMP[2], TEMP[2]\n"
-         "DIV TEMP[2].y, TEMP[2].yyyy, IMM[1].yyyy\n"
          /* Down Y */
          "MOV TEMP[12], TEMP[2]\n"
 
@@ -452,15 +439,11 @@ static const char *compute_shader_yuv_weave_uv =
          "MOV TEMP[13], TEMP[3]\n"
 
          /* Texture offset */
-         "ADD TEMP[2].x, TEMP[2].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[2].y, TEMP[2].yyyy, IMM[3].xxxx\n"
-         "ADD TEMP[12].x, TEMP[12].xxxx, IMM[3].yyyy\n"
-         "ADD TEMP[12].y, TEMP[12].yyyy, IMM[3].xxxx\n"
+         "ADD TEMP[2].xy, TEMP[2].xyyy, IMM[3].yyyy\n"
+         "ADD TEMP[12].xy, TEMP[12].xyyy, IMM[3].yyyy\n"
 
-         "ADD TEMP[3].x, TEMP[3].xxxx, IMM[3].xxxx\n"
-         "ADD TEMP[3].y, TEMP[3].yyyy, IMM[3].wwww\n"
-         "ADD TEMP[13].x, TEMP[13].xxxx, IMM[3].xxxx\n"
-         "ADD TEMP[13].y, TEMP[13].yyyy, IMM[3].wwww\n"
+         "ADD TEMP[3].xy, TEMP[3].xyyy, IMM[3].xxxx\n"
+         "ADD TEMP[13].xy, TEMP[13].xyyy, IMM[3].xxxx\n"
 
          /* Scale */
          "DIV TEMP[2].xy, TEMP[2], CONST[3].zwzw\n"
@@ -518,120 +501,6 @@ static const char *compute_shader_yuv_weave_uv =
 
       "END\n";
 
-static const char *compute_shader_yuv_bob_y =
-      "COMP\n"
-      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
-      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
-      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
-
-      "DCL SV[0], THREAD_ID\n"
-      "DCL SV[1], BLOCK_ID\n"
-
-      "DCL CONST[0..7]\n"
-      "DCL SVIEW[0..2], RECT, FLOAT\n"
-      "DCL SAMP[0..2]\n"
-
-      "DCL IMAGE[0], 2D, WR\n"
-      "DCL TEMP[0..4]\n"
-
-      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
-      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
-
-      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
-
-      /* Drawn area check */
-      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
-      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
-      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
-      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
-      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
-
-      "UIF TEMP[1]\n"
-         /* Translate */
-         "UADD TEMP[2].xy, TEMP[0], -CONST[5].xyxy\n"
-         "U2F TEMP[2], TEMP[2]\n"
-         "DIV TEMP[3], TEMP[2], IMM[1].yyyy\n"
-
-         /* Scale */
-         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
-         "DIV TEMP[2], TEMP[2], IMM[1].xyxy\n"
-         "DIV TEMP[3], TEMP[3], CONST[3].zwzw\n"
-         "DIV TEMP[3], TEMP[3], IMM[1].xyxy\n"
-
-         /* Clamp coords */
-         "MIN TEMP[2].xy, TEMP[2].xyyy, CONST[7].xyxy\n"
-         "MIN TEMP[3].xy, TEMP[3].xyyy, CONST[7].zwzw\n"
-
-         /* Fetch texels */
-         "TEX_LZ TEMP[4].x, TEMP[2], SAMP[0], RECT\n"
-         "TEX_LZ TEMP[4].y, TEMP[3], SAMP[1], RECT\n"
-         "TEX_LZ TEMP[4].z, TEMP[3], SAMP[2], RECT\n"
-
-         "MOV TEMP[4].w, IMM[1].xxxx\n"
-
-         "STORE IMAGE[0], TEMP[0], TEMP[4], 2D\n"
-      "ENDIF\n"
-
-      "END\n";
-
-static const char *compute_shader_yuv_bob_uv =
-      "COMP\n"
-      "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
-      "PROPERTY CS_FIXED_BLOCK_HEIGHT 8\n"
-      "PROPERTY CS_FIXED_BLOCK_DEPTH 1\n"
-
-      "DCL SV[0], THREAD_ID\n"
-      "DCL SV[1], BLOCK_ID\n"
-
-      "DCL CONST[0..7]\n"
-      "DCL SVIEW[0..2], RECT, FLOAT\n"
-      "DCL SAMP[0..2]\n"
-
-      "DCL IMAGE[0], 2D, WR\n"
-      "DCL TEMP[0..5]\n"
-
-      "IMM[0] UINT32 { 8, 8, 1, 0}\n"
-      "IMM[1] FLT32 { 1.0, 2.0, 0.0, 0.0}\n"
-
-      "UMAD TEMP[0], SV[1], IMM[0], SV[0]\n"
-
-      /* Drawn area check */
-      "USGE TEMP[1].xy, TEMP[0].xyxy, CONST[4].xyxy\n"
-      "USLT TEMP[1].zw, TEMP[0].xyxy, CONST[4].zwzw\n"
-      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].yyyy\n"
-      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].zzzz\n"
-      "AND TEMP[1].x, TEMP[1].xxxx, TEMP[1].wwww\n"
-
-      "UIF TEMP[1]\n"
-         /* Translate */
-         "UADD TEMP[2].xy, TEMP[0], -CONST[5].xyxy\n"
-         "U2F TEMP[2], TEMP[2]\n"
-         "DIV TEMP[3], TEMP[2], IMM[1].yyyy\n"
-
-         /* Scale */
-         "DIV TEMP[2], TEMP[2], CONST[3].zwzw\n"
-         "DIV TEMP[2], TEMP[2], IMM[1].xyxy\n"
-         "DIV TEMP[3], TEMP[3], CONST[3].zwzw\n"
-         "DIV TEMP[3], TEMP[3], IMM[1].xyxy\n"
-
-         /* Clamp coords */
-         "MIN TEMP[2].xy, TEMP[2].xyyy, CONST[7].xyxy\n"
-         "MIN TEMP[3].xy, TEMP[3].xyyy, CONST[7].zwzw\n"
-
-         /* Fetch texels */
-         "TEX_LZ TEMP[4].x, TEMP[2], SAMP[0], RECT\n"
-         "TEX_LZ TEMP[4].y, TEMP[3], SAMP[1], RECT\n"
-         "TEX_LZ TEMP[4].z, TEMP[3], SAMP[2], RECT\n"
-
-         "MOV TEMP[4].w, IMM[1].xxxx\n"
-
-         "MOV TEMP[5].xy, TEMP[4].yzww\n"
-
-         "STORE IMAGE[0], TEMP[0], TEMP[5], 2D\n"
-      "ENDIF\n"
-
-      "END\n";
-
 static const char *compute_shader_yuv_y =
       "COMP\n"
       "PROPERTY CS_FIXED_BLOCK_WIDTH 8\n"
@@ -1077,7 +946,6 @@ draw_layers(struct vl_compositor       *c,
              (layer->src.br.x - layer->src.tl.x));
          drawn.scale_y  = layer->viewport.scale[1] /
             ((float)layer->sampler_views[0]->texture->height0 *
-             (s->interlaced ? 2.0 : 1.0) *
              (layer->src.br.y - layer->src.tl.y));
          drawn.crop_x = (int)(layer->src.tl.x * layer->sampler_views[0]->texture->width0);
          drawn.translate_x = layer->viewport.translate[0];
@@ -1197,12 +1065,9 @@ bool vl_compositor_cs_init_shaders(struct vl_compositor *c)
 
         c->cs_yuv.weave.y = vl_compositor_cs_create_shader(c, compute_shader_yuv_weave_y);
         c->cs_yuv.weave.uv = vl_compositor_cs_create_shader(c, compute_shader_yuv_weave_uv);
-        c->cs_yuv.bob.y = vl_compositor_cs_create_shader(c, compute_shader_yuv_bob_y);
-        c->cs_yuv.bob.uv = vl_compositor_cs_create_shader(c, compute_shader_yuv_bob_uv);
         c->cs_yuv.progressive.y = vl_compositor_cs_create_shader(c, compute_shader_yuv_y);
         c->cs_yuv.progressive.uv = vl_compositor_cs_create_shader(c, compute_shader_yuv_uv);
-        if (!c->cs_yuv.weave.y || !c->cs_yuv.weave.uv ||
-            !c->cs_yuv.bob.y || !c->cs_yuv.bob.uv) {
+        if (!c->cs_yuv.weave.y || !c->cs_yuv.weave.uv) {
                 debug_printf("Unable to create YCbCr i-to-YCbCr p deint compute shader.\n");
                 return false;
         }
@@ -1233,10 +1098,6 @@ void vl_compositor_cs_cleanup_shaders(struct vl_compositor *c)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.weave.y);
         if (c->cs_yuv.weave.uv)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.weave.uv);
-        if (c->cs_yuv.bob.y)
-                c->pipe->delete_compute_state(c->pipe, c->cs_yuv.bob.y);
-        if (c->cs_yuv.bob.uv)
-                c->pipe->delete_compute_state(c->pipe, c->cs_yuv.bob.uv);
         if (c->cs_yuv.progressive.y)
                 c->pipe->delete_compute_state(c->pipe, c->cs_yuv.progressive.y);
         if (c->cs_yuv.progressive.uv)
-- 
GitLab


From 3decbd8907702bf9fd7436e264bd210243c7a586 Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Sat, 2 Sep 2023 10:00:09 +0200
Subject: [PATCH 4/4] gallium/auxiliary/vl: Only map the shader constants
 buffer in render

Don't map the buffer in vl_compositor_set_csc_matrix.
This avoids mapping the buffer twice with compute shaders.
---
 src/gallium/auxiliary/vl/vl_compositor.c     | 19 +++--------------
 src/gallium/auxiliary/vl/vl_compositor.h     |  3 +++
 src/gallium/auxiliary/vl/vl_compositor_cs.c  | 13 +++++++-----
 src/gallium/auxiliary/vl/vl_compositor_gfx.c | 22 ++++++++++++++++++++
 4 files changed, 36 insertions(+), 21 deletions(-)

diff --git a/src/gallium/auxiliary/vl/vl_compositor.c b/src/gallium/auxiliary/vl/vl_compositor.c
index ebb88fd4d340c..91a10a678c483 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.c
+++ b/src/gallium/auxiliary/vl/vl_compositor.c
@@ -479,24 +479,11 @@ vl_compositor_set_csc_matrix(struct vl_compositor_state *s,
                              vl_csc_matrix const *matrix,
                              float luma_min, float luma_max)
 {
-   struct pipe_transfer *buf_transfer;
-
    assert(s);
 
-   float *ptr = pipe_buffer_map(s->pipe, s->shader_params,
-                               PIPE_MAP_WRITE | PIPE_MAP_DISCARD_RANGE,
-                               &buf_transfer);
-
-   if (!ptr)
-      return false;
-
-   memcpy(ptr, matrix, sizeof(vl_csc_matrix));
-
-   ptr += sizeof(vl_csc_matrix)/sizeof(float);
-   ptr[0] = luma_min;
-   ptr[1] = luma_max;
-
-   pipe_buffer_unmap(s->pipe, buf_transfer);
+   memcpy(&s->csc_matrix, matrix, sizeof(vl_csc_matrix));
+   s->luma_min = luma_min;
+   s->luma_max = luma_max;
 
    return true;
 }
diff --git a/src/gallium/auxiliary/vl/vl_compositor.h b/src/gallium/auxiliary/vl/vl_compositor.h
index c8f2515d5ea3d..8e49008be44bd 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.h
+++ b/src/gallium/auxiliary/vl/vl_compositor.h
@@ -114,6 +114,9 @@ struct vl_compositor_state
    struct vl_compositor_layer layers[VL_COMPOSITOR_MAX_LAYERS];
    bool interlaced;
    unsigned chroma_location;
+
+   vl_csc_matrix csc_matrix;
+   float luma_min, luma_max;
 };
 
 struct vl_compositor
diff --git a/src/gallium/auxiliary/vl/vl_compositor_cs.c b/src/gallium/auxiliary/vl/vl_compositor_cs.c
index dec2b9c8f2bfc..3f4f0cee79c2f 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_cs.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_cs.c
@@ -866,16 +866,19 @@ set_viewport(struct vl_compositor_state *s,
 
    assert(s && drawn);
 
-   void *ptr = pipe_buffer_map_range(s->pipe, s->shader_params,
-                                     sizeof(vl_csc_matrix) + sizeof(float) * 2,
-                                     sizeof(float) * 12 + sizeof(int) * 8,
-                                     PIPE_MAP_WRITE | PIPE_MAP_DISCARD_RANGE,
-                                     &buf_transfer);
+   void *ptr = pipe_buffer_map(s->pipe, s->shader_params,
+                               PIPE_MAP_WRITE | PIPE_MAP_DISCARD_WHOLE_RESOURCE,
+                               &buf_transfer);
 
    if (!ptr)
      return false;
 
+   memcpy(ptr, &s->csc_matrix, sizeof(vl_csc_matrix));
+
    float *ptr_float = (float *)ptr;
+   ptr_float += sizeof(vl_csc_matrix) / sizeof(float);
+   *ptr_float++ = s->luma_min;
+   *ptr_float++ = s->luma_max;
    *ptr_float++ = drawn->scale_x;
    *ptr_float++ = drawn->scale_y;
 
diff --git a/src/gallium/auxiliary/vl/vl_compositor_gfx.c b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
index 7244aeb7a1df0..f6fef79066f23 100644
--- a/src/gallium/auxiliary/vl/vl_compositor_gfx.c
+++ b/src/gallium/auxiliary/vl/vl_compositor_gfx.c
@@ -645,6 +645,27 @@ gen_vertex_data(struct vl_compositor *c, struct vl_compositor_state *s, struct u
    u_upload_unmap(c->pipe->stream_uploader);
 }
 
+static void
+set_csc_matrix(struct vl_compositor_state *s)
+{
+   struct pipe_transfer *buf_transfer;
+
+   float *ptr = pipe_buffer_map(s->pipe, s->shader_params,
+                                PIPE_MAP_WRITE | PIPE_MAP_DISCARD_WHOLE_RESOURCE,
+                                &buf_transfer);
+
+   if (!ptr)
+     return;
+
+   memcpy(ptr, &s->csc_matrix, sizeof(vl_csc_matrix));
+
+   ptr += sizeof(vl_csc_matrix) / sizeof(float);
+   *ptr++ = s->luma_min;
+   *ptr++ = s->luma_max;
+
+   pipe_buffer_unmap(s->pipe, buf_transfer);
+}
+
 static void
 draw_layers(struct vl_compositor *c, struct vl_compositor_state *s, struct u_rect *dirty)
 {
@@ -705,6 +726,7 @@ vl_compositor_gfx_render(struct vl_compositor_state *s,
    c->pipe->set_scissor_states(c->pipe, 0, 1, &s->scissor);
 
    gen_vertex_data(c, s, dirty_area);
+   set_csc_matrix(s);
 
    if (clear_dirty && dirty_area &&
        (dirty_area->x0 < dirty_area->x1 || dirty_area->y0 < dirty_area->y1)) {
-- 
GitLab

