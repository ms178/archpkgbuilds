From cdfe42d4151977bf590c8170cbf75367d8c3cd18 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 3 Feb 2023 13:08:14 +0100
Subject: [PATCH 1/9] aco: treat VINTERP_INREG as VALU

It's just v_fma with fixed DPP8 and builtin s_waitcnt_expcnt, so it can mostly
be handled as a pure VALU instruction.
---
 src/amd/compiler/aco_insert_NOPs.cpp         | 12 ++++++------
 src/amd/compiler/aco_insert_waitcnt.cpp      |  4 ++--
 src/amd/compiler/aco_ir.cpp                  |  2 +-
 src/amd/compiler/aco_ir.h                    |  2 +-
 src/amd/compiler/aco_lower_to_hw_instr.cpp   |  2 +-
 src/amd/compiler/aco_optimizer_postRA.cpp    |  2 +-
 src/amd/compiler/aco_register_allocation.cpp |  8 ++++----
 src/amd/compiler/aco_validate.cpp            |  6 +++---
 8 files changed, 19 insertions(+), 19 deletions(-)

diff --git a/src/amd/compiler/aco_insert_NOPs.cpp b/src/amd/compiler/aco_insert_NOPs.cpp
index e9a0c328f2d8..243388a17f09 100644
--- a/src/amd/compiler/aco_insert_NOPs.cpp
+++ b/src/amd/compiler/aco_insert_NOPs.cpp
@@ -1054,7 +1054,7 @@ handle_lds_direct_valu_hazard_instr(LdsDirectVALUHazardGlobalState& global_state
                                     LdsDirectVALUHazardBlockState& block_state,
                                     aco_ptr<Instruction>& instr)
 {
-   if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU()) {
       block_state.has_trans |= instr->isTrans();
 
       bool uses_vgpr = false;
@@ -1153,7 +1153,7 @@ handle_valu_partial_forwarding_hazard_instr(VALUPartialForwardingHazardGlobalSta
    if (instr->isSALU() && !instr->definitions.empty()) {
       if (block_state.state == written_after_exec_write && instr_writes_exec(instr))
          block_state.state = exec_written;
-   } else if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   } else if (instr->isVALU()) {
       bool vgpr_write = false;
       for (Definition& def : instr->definitions) {
          if (def.physReg().reg() < 256)
@@ -1239,7 +1239,7 @@ handle_valu_partial_forwarding_hazard(State& state, aco_ptr<Instruction>& instr)
     * For the hazard, there must be less than 3 VALU between the first and second VGPR writes.
     * There also must be less than 5 VALU between the second VGPR write and the current instruction.
     */
-   if (state.program->wave_size != 64 || (!instr->isVALU() && !instr->isVINTERP_INREG()))
+   if (state.program->wave_size != 64 || !instr->isVALU())
       return false;
 
    unsigned num_vgprs = 0;
@@ -1319,7 +1319,7 @@ handle_instruction_gfx11(State& state, NOP_ctx_gfx11& ctx, aco_ptr<Instruction>&
     * VALU reads VGPR written by transcendental instruction without 6+ VALU or 2+ transcendental
     * in-between.
     */
-   if (va_vdst > 0 && (instr->isVALU() || instr->isVINTERP_INREG())) {
+   if (va_vdst > 0 && instr->isVALU()) {
       uint8_t num_valu = 15;
       uint8_t num_trans = 15;
       for (Operand& op : instr->operands) {
@@ -1362,7 +1362,7 @@ handle_instruction_gfx11(State& state, NOP_ctx_gfx11& ctx, aco_ptr<Instruction>&
    if (sa_sdst == 0)
       ctx.sgpr_read_by_valu_as_lanemask_then_wr_by_salu.reset();
 
-   if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU()) {
       bool is_trans = instr->isTrans();
 
       ctx.valu_since_wr_by_trans.inc();
@@ -1419,7 +1419,7 @@ handle_instruction_gfx11(State& state, NOP_ctx_gfx11& ctx, aco_ptr<Instruction>&
       for (Operand& op : instr->operands)
          fill_vgpr_bitset(ctx.vgpr_used_by_ds, op.physReg(), op.bytes());
    }
-   if (instr->isVALU() || instr->isVINTERP_INREG() || instr->isEXP() || vm_vsrc == 0) {
+   if (instr->isVALU() || instr->isEXP() || vm_vsrc == 0) {
       ctx.vgpr_used_by_vmem_load.reset();
       ctx.vgpr_used_by_vmem_store.reset();
       ctx.vgpr_used_by_ds.reset();
diff --git a/src/amd/compiler/aco_insert_waitcnt.cpp b/src/amd/compiler/aco_insert_waitcnt.cpp
index b7edf0446294..948799f1f3ed 100644
--- a/src/amd/compiler/aco_insert_waitcnt.cpp
+++ b/src/amd/compiler/aco_insert_waitcnt.cpp
@@ -372,7 +372,7 @@ check_instr(wait_ctx& ctx, wait_imm& wait, alu_delay_info& delay, Instruction* i
             continue;
 
          wait.combine(it->second.imm);
-         if (instr->isVALU() || instr->isSALU() || instr->isVINTERP_INREG())
+         if (instr->isVALU() || instr->isSALU())
             delay.combine(it->second.delay);
       }
    }
@@ -788,7 +788,7 @@ void
 gen_alu(Instruction* instr, wait_ctx& ctx)
 {
    Instruction_cycle_info cycle_info = get_cycle_info(*ctx.program, *instr);
-   bool is_valu = instr->isVALU() || instr->isVINTERP_INREG();
+   bool is_valu = instr->isVALU();
    bool is_trans = instr->isTrans();
    bool clear = instr->isEXP() || instr->isDS() || instr->isMIMG() || instr->isFlatLike() ||
                 instr->isMUBUF() || instr->isMTBUF();
diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index 4652af8ddb92..c4f33673dc6a 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -343,7 +343,7 @@ can_use_DPP(const aco_ptr<Instruction>& instr, bool pre_ra, bool dpp8)
    if (instr->operands.size() && instr->operands[0].isLiteral())
       return false;
 
-   if (instr->isSDWA() || instr->isVOP3P())
+   if (instr->isSDWA() || instr->isVINTERP_INREG() || instr->isVOP3P())
       return false;
 
    if (!pre_ra && (instr->isVOPC() || instr->definitions.size() > 1) &&
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index f57ba4a92688..c3ad28a3f90e 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1372,7 +1372,7 @@ struct Instruction {
 
    constexpr bool isVALU() const noexcept
    {
-      return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P();
+      return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P() || isVINTERP_INREG();
    }
 
    constexpr bool isSALU() const noexcept
diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index b0be28aed15f..34775638bae3 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -2675,7 +2675,7 @@ lower_to_hw_instr(Program* program)
                         can_remove = false;
                   } else if (inst->isSALU()) {
                      num_scalar++;
-                  } else if (inst->isVALU() || inst->isVINTRP() || inst->isVINTERP_INREG()) {
+                  } else if (inst->isVALU() || inst->isVINTRP()) {
                      num_vector++;
                      /* VALU which writes SGPRs are always executed on GFX10+ */
                      if (ctx.program->gfx_level >= GFX10) {
diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 6435a54ef4e4..b39af7bd5ae0 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -568,7 +568,7 @@ num_encoded_alu_operands(const aco_ptr<Instruction>& instr)
       else if (instr->opcode == aco_opcode::v_writelane_b32_e64 ||
                instr->opcode == aco_opcode::v_writelane_b32)
          return 2; /* potentially VOP3, but reads VDST as SRC2 */
-      else if (instr->isVOP3() || instr->isVOP3P())
+      else if (instr->isVOP3() || instr->isVOP3P() || instr->isVINTERP_INREG())
          return instr->operands.size();
    }
 
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index e8a1095de83d..54d417429271 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -504,7 +504,7 @@ get_subdword_operand_stride(amd_gfx_level gfx_level, const aco_ptr<Instruction>&
    }
 
    assert(rc.bytes() <= 2);
-   if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU()) {
       if (can_use_SDWA(gfx_level, instr, false))
          return rc.bytes();
       if (can_use_opsel(gfx_level, instr->opcode, idx))
@@ -539,7 +539,7 @@ add_subdword_operand(ra_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, uns
       return;
 
    assert(rc.bytes() <= 2);
-   if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU()) {
       /* check if we can use opsel */
       if (instr->format == Format::VOP3) {
          assert(byte == 2);
@@ -616,7 +616,7 @@ get_subdword_definition_info(Program* program, const aco_ptr<Instruction>& instr
          return std::make_pair(4, rc.size() * 4u);
    }
 
-   if (instr->isVALU() || instr->isVINTRP() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU() || instr->isVINTRP()) {
       assert(rc.bytes() <= 2);
 
       if (can_use_SDWA(gfx_level, instr, false))
@@ -684,7 +684,7 @@ add_subdword_definition(Program* program, aco_ptr<Instruction>& instr, PhysReg r
    if (instr->isPseudo())
       return;
 
-   if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU()) {
       amd_gfx_level gfx_level = program->gfx_level;
       assert(instr->definitions[0].bytes() <= 2);
 
diff --git a/src/amd/compiler/aco_validate.cpp b/src/amd/compiler/aco_validate.cpp
index 0494f4cc5a24..599eb318233f 100644
--- a/src/amd/compiler/aco_validate.cpp
+++ b/src/amd/compiler/aco_validate.cpp
@@ -284,7 +284,7 @@ validate_ir(Program* program)
                      instr.get());
          }
 
-         if (instr->isSALU() || instr->isVALU() || instr->isVINTERP_INREG()) {
+         if (instr->isSALU() || instr->isVALU()) {
             /* check literals */
             Operand literal(s1);
             for (unsigned i = 0; i < instr->operands.size(); i++) {
@@ -306,7 +306,7 @@ validate_ir(Program* program)
             }
 
             /* check num sgprs for VALU */
-            if (instr->isVALU() || instr->isVINTERP_INREG()) {
+            if (instr->isVALU()) {
                bool is_shift64 = instr->opcode == aco_opcode::v_lshlrev_b64 ||
                                  instr->opcode == aco_opcode::v_lshrrev_b64 ||
                                  instr->opcode == aco_opcode::v_ashrrev_i64;
@@ -929,7 +929,7 @@ get_subdword_bytes_written(Program* program, const aco_ptr<Instruction>& instr,
 
    if (instr->isPseudo())
       return gfx_level >= GFX8 ? def.bytes() : def.size() * 4u;
-   if (instr->isVALU() || instr->isVINTERP_INREG()) {
+   if (instr->isVALU()) {
       assert(def.bytes() <= 2);
       if (instr->isSDWA())
          return instr->sdwa().dst_sel.size();
-- 
GitLab


From 2e4858a774a9aa6bb133201ecb6ad6f25769d1a9 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 11 Jan 2023 12:12:33 +0100
Subject: [PATCH 2/9] aco/ir: rework IR to have one common valu instruction
 struct

---
 src/amd/compiler/aco_ir.h | 100 ++++++++++++++++++--------------------
 1 file changed, 47 insertions(+), 53 deletions(-)

diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index c3ad28a3f90e..f426f21c3734 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1013,12 +1013,13 @@ struct FLAT_instruction;
 struct Pseudo_branch_instruction;
 struct Pseudo_barrier_instruction;
 struct Pseudo_reduction_instruction;
-struct VOP3P_instruction;
+struct VALU_instruction;
+typedef VALU_instruction VOP3P_instruction;
 struct VINTERP_inreg_instruction;
-struct VOP1_instruction;
-struct VOP2_instruction;
-struct VOPC_instruction;
-struct VOP3_instruction;
+typedef VALU_instruction VOP1_instruction;
+typedef VALU_instruction VOP2_instruction;
+typedef VALU_instruction VOPC_instruction;
+typedef VALU_instruction VOP3_instruction;
 struct VINTRP_instruction;
 struct DPP16_instruction;
 struct DPP8_instruction;
@@ -1370,6 +1371,16 @@ struct Instruction {
 
    constexpr bool isFlatLike() const noexcept { return isFlat() || isGlobal() || isScratch(); }
 
+   VALU_instruction& valu() noexcept
+   {
+      assert(isVALU());
+      return *(VALU_instruction*)this;
+   }
+   const VALU_instruction& valu() const noexcept
+   {
+      assert(isVALU());
+      return *(VALU_instruction*)this;
+   }
    constexpr bool isVALU() const noexcept
    {
       return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P() || isVINTERP_INREG();
@@ -1433,44 +1444,33 @@ struct SMEM_instruction : public Instruction {
 };
 static_assert(sizeof(SMEM_instruction) == sizeof(Instruction) + 4, "Unexpected padding");
 
-struct VOP1_instruction : public Instruction {};
-static_assert(sizeof(VOP1_instruction) == sizeof(Instruction) + 0, "Unexpected padding");
-
-struct VOP2_instruction : public Instruction {};
-static_assert(sizeof(VOP2_instruction) == sizeof(Instruction) + 0, "Unexpected padding");
-
-struct VOPC_instruction : public Instruction {};
-static_assert(sizeof(VOPC_instruction) == sizeof(Instruction) + 0, "Unexpected padding");
-
-struct VOP3_instruction : public Instruction {
-   bool abs[3];
-   bool neg[3];
-   uint8_t opsel : 4;
-   uint8_t omod : 2;
-   bool clamp : 1;
-   uint8_t padding0 : 1;
-   uint8_t padding1;
-};
-static_assert(sizeof(VOP3_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
-
-struct VOP3P_instruction : public Instruction {
-   bool neg_lo[3];
-   bool neg_hi[3]; /* abs modifier, for v_mad_mix/v_fma_mix */
-   uint8_t opsel_lo : 3;
-   uint8_t opsel_hi : 3;
-   bool clamp : 1;
-   uint8_t padding0 : 1;
-   uint8_t padding1;
+struct VALU_instruction : public Instruction {
+   union {
+      bool neg[3];    /* VOP3, SDWA, DPP16, v_fma_mix, VINTERP_inreg */
+      bool neg_lo[3]; /* VOP3P */
+   };
+   union {
+      bool abs[3];    /* VOP3, SDWA, DPP16, v_fma_mix */
+      bool neg_hi[3]; /* VOP3P */
+   };
+   uint8_t opsel : 4; /* VOP3, VOPC12(GFX11+), VINTERP_inreg */
+   uint8_t omod : 2;  /* VOP3, SDWA(GFX9+) */
+   uint8_t padding0 : 2;
+   uint8_t opsel_lo : 3; /* VOP3P */
+   uint8_t opsel_hi : 3; /* VOP3P */
+   bool clamp : 1; /* VOP3, VOP3P, SDWA, VINTERP_inreg */
+   uint8_t padding1 : 1;
 };
-static_assert(sizeof(VOP3P_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
+static_assert(sizeof(VALU_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
 
-struct VINTERP_inreg_instruction : public Instruction {
+struct VINTERP_inreg_instruction : public VALU_instruction {
    uint8_t wait_exp : 3;
-   bool clamp : 1;
-   uint8_t opsel : 4;
-   bool neg[3];
+   uint8_t padding3 : 5;
+   uint8_t padding4;
+   uint8_t padding5;
+   uint8_t padding6;
 };
-static_assert(sizeof(VINTERP_inreg_instruction) == sizeof(Instruction) + 4, "Unexpected padding");
+static_assert(sizeof(VINTERP_inreg_instruction) == sizeof(VALU_instruction) + 4, "Unexpected padding");
 
 /**
  * Data Parallel Primitives Format:
@@ -1478,21 +1478,19 @@ static_assert(sizeof(VINTERP_inreg_instruction) == sizeof(Instruction) + 4, "Une
  * The swizzle applies to the src0 operand.
  *
  */
-struct DPP16_instruction : public Instruction {
-   bool abs[2];
-   bool neg[2];
+struct DPP16_instruction : public VALU_instruction {
    uint16_t dpp_ctrl;
    uint8_t row_mask : 4;
    uint8_t bank_mask : 4;
    bool bound_ctrl : 1;
-   uint8_t padding : 7;
+   uint8_t padding3 : 7;
 };
-static_assert(sizeof(DPP16_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
+static_assert(sizeof(DPP16_instruction) == sizeof(VALU_instruction) + 4, "Unexpected padding");
 
-struct DPP8_instruction : public Instruction {
+struct DPP8_instruction : public VALU_instruction {
    uint8_t lane_sel[8];
 };
-static_assert(sizeof(DPP8_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
+static_assert(sizeof(DPP8_instruction) == sizeof(VALU_instruction) + 8, "Unexpected padding");
 
 struct SubdwordSel {
    enum sdwa_sel : uint8_t {
@@ -1551,18 +1549,14 @@ private:
  * the definition doesn't have to be VCC on GFX9+.
  *
  */
-struct SDWA_instruction : public Instruction {
+struct SDWA_instruction : public VALU_instruction {
    /* these destination modifiers aren't available with VOPC except for
     * clamp on GFX8 */
    SubdwordSel sel[2];
    SubdwordSel dst_sel;
-   bool neg[2];
-   bool abs[2];
-   bool clamp : 1;
-   uint8_t omod : 2; /* GFX9+ */
-   uint8_t padding : 5;
+   uint8_t padding3;
 };
-static_assert(sizeof(SDWA_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
+static_assert(sizeof(SDWA_instruction) == sizeof(VALU_instruction) + 4, "Unexpected padding");
 
 struct VINTRP_instruction : public Instruction {
    uint8_t attribute;
-- 
GitLab


From 0e1d49b1dfe7cf41511eb591257f60b8d9a8ba3e Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 31 Jan 2023 18:04:29 +0100
Subject: [PATCH 3/9] aco/ra: set opsel_hi to zero when converting to VOP2

Otherwise the new modifier validation will fail.
---
 src/amd/compiler/aco_register_allocation.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 54d417429271..5a7adb3460be 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2637,6 +2637,7 @@ optimize_encoding_vop2(Program* program, ra_ctx& ctx, RegisterFile& register_fil
    static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3P_instruction),
                  "Invalid direct instruction cast.");
    instr->format = Format::VOP2;
+   instr->valu().opsel_hi = 0;
    switch (instr->opcode) {
    case aco_opcode::v_mad_f32: instr->opcode = aco_opcode::v_mac_f32; break;
    case aco_opcode::v_fma_f32: instr->opcode = aco_opcode::v_fmac_f32; break;
-- 
GitLab


From 29b821d39024ab883fbbf27462bab2018d332c4b Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 31 Jan 2023 13:14:46 +0100
Subject: [PATCH 4/9] aco: validate VALU modifiers

---
 src/amd/compiler/aco_validate.cpp | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/amd/compiler/aco_validate.cpp b/src/amd/compiler/aco_validate.cpp
index 599eb318233f..1b5ed3eaa425 100644
--- a/src/amd/compiler/aco_validate.cpp
+++ b/src/amd/compiler/aco_validate.cpp
@@ -382,6 +382,30 @@ validate_ir(Program* program)
                }
                check(num_sgprs + (literal.isUndefined() ? 0 : 1) <= const_bus_limit,
                      "Too many SGPRs/literals", instr.get());
+
+               /* Validate modifiers. */
+               check(!instr->valu().opsel || instr->isVOP3() || instr->isVINTERP_INREG(),
+                     "OPSEL set for unsupported instruction format", instr.get());
+               check(!instr->valu().opsel_lo || instr->isVOP3P(),
+                     "OPSEL_LO set for unsupported instruction format", instr.get());
+               check(!instr->valu().opsel_hi || instr->isVOP3P(),
+                     "OPSEL_HI set for unsupported instruction format", instr.get());
+               check(!instr->valu().omod || instr->isVOP3() ||instr->isSDWA(),
+                     "OMOD set for unsupported instruction format", instr.get());
+               check(!instr->valu().clamp || instr->isVOP3() || instr->isVOP3P() ||
+                        instr->isSDWA() || instr->isVINTERP_INREG(),
+                     "CLAMP set for unsupported instruction format", instr.get());
+
+               for (bool abs : instr->valu().abs) {
+                  check(!abs || instr->isVOP3() || instr->isVOP3P() || instr->isSDWA() ||
+                           instr->isDPP16(),
+                        "ABS/NEG_HI set for unsupported instruction format", instr.get());
+               }
+               for (bool neg : instr->valu().neg) {
+                  check(!neg || instr->isVOP3() || instr->isVOP3P() || instr->isSDWA() ||
+                           instr->isDPP16() || instr->isVINTERP_INREG(),
+                        "NEG/NEG_LO set for unsupported instruction format", instr.get());
+               }
             }
 
             if (instr->isSOP1() || instr->isSOP2()) {
-- 
GitLab


From 74187264683c156c6a8b5e0bd03e69583c6fe4d3 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 11 Jan 2023 13:09:20 +0100
Subject: [PATCH 5/9] aco/print_ir: simplify using VALU instruction

---
 src/amd/compiler/aco_print_ir.cpp | 62 +++++++------------------------
 1 file changed, 13 insertions(+), 49 deletions(-)

diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index c1f5a11bf067..74fb7e58c254 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -620,27 +620,24 @@ print_instr_format_specific(enum amd_gfx_level gfx_level, const Instruction* ins
       print_sync(mtbuf.sync, output);
       break;
    }
-   case Format::VOP3P: {
-      if (instr->vop3p().clamp)
-         fprintf(output, " clamp");
-      break;
-   }
    default: {
       break;
    }
    }
-   if (instr->isVOP3()) {
-      const VOP3_instruction& vop3 = instr->vop3();
-      switch (vop3.omod) {
+   if (instr->isVALU()) {
+      const VALU_instruction& valu = instr->valu();
+      switch (valu.omod) {
       case 1: fprintf(output, " *2"); break;
       case 2: fprintf(output, " *4"); break;
       case 3: fprintf(output, " *0.5"); break;
       }
-      if (vop3.clamp)
+      if (valu.clamp)
          fprintf(output, " clamp");
-      if (vop3.opsel & (1 << 3))
+      if (valu.opsel & (1 << 3))
          fprintf(output, " opsel_hi");
-   } else if (instr->isDPP16()) {
+   }
+
+   if (instr->isDPP16()) {
       const DPP16_instruction& dpp = instr->dpp16();
       if (dpp.dpp_ctrl <= 0xff) {
          fprintf(output, " quad_perm:[%d,%d,%d,%d]", dpp.dpp_ctrl & 0x3, (dpp.dpp_ctrl >> 2) & 0x3,
@@ -687,13 +684,6 @@ print_instr_format_specific(enum amd_gfx_level gfx_level, const Instruction* ins
               dpp.lane_sel[7]);
    } else if (instr->isSDWA()) {
       const SDWA_instruction& sdwa = instr->sdwa();
-      switch (sdwa.omod) {
-      case 1: fprintf(output, " *2"); break;
-      case 2: fprintf(output, " *4"); break;
-      case 3: fprintf(output, " *0.5"); break;
-      }
-      if (sdwa.clamp)
-         fprintf(output, " clamp");
       if (!instr->isVOPC()) {
          char sext = sdwa.dst_sel.sign_extend() ? 's' : 'u';
          unsigned offset = sdwa.dst_sel.offset();
@@ -720,12 +710,6 @@ print_instr_format_specific(enum amd_gfx_level gfx_level, const Instruction* ins
          default: break;
          }
       }
-   } else if (instr->isVINTERP_INREG()) {
-      const VINTERP_inreg_instruction& vinterp = instr->vinterp_inreg();
-      if (vinterp.clamp)
-         fprintf(output, " clamp");
-      if (vinterp.opsel & (1 << 3))
-         fprintf(output, " opsel_hi");
    }
 }
 
@@ -757,26 +741,12 @@ aco_print_instr(enum amd_gfx_level gfx_level, const Instruction* instr, FILE* ou
       bool is_mad_mix = instr->opcode == aco_opcode::v_fma_mix_f32 ||
                         instr->opcode == aco_opcode::v_fma_mixlo_f16 ||
                         instr->opcode == aco_opcode::v_fma_mixhi_f16;
-      if (instr->isVOP3()) {
-         const VOP3_instruction& vop3 = instr->vop3();
+      if (instr->isVALU() && !instr->isVOP3P()) {
+         const VALU_instruction& valu = instr->valu();
          for (unsigned i = 0; i < MIN2(num_operands, 3); ++i) {
-            abs[i] = vop3.abs[i];
-            neg[i] = vop3.neg[i];
-            opsel[i] = vop3.opsel & (1 << i);
-         }
-      } else if (instr->isDPP16()) {
-         const DPP16_instruction& dpp = instr->dpp16();
-         for (unsigned i = 0; i < MIN2(num_operands, 2); ++i) {
-            abs[i] = dpp.abs[i];
-            neg[i] = dpp.neg[i];
-            opsel[i] = false;
-         }
-      } else if (instr->isSDWA()) {
-         const SDWA_instruction& sdwa = instr->sdwa();
-         for (unsigned i = 0; i < MIN2(num_operands, 2); ++i) {
-            abs[i] = sdwa.abs[i];
-            neg[i] = sdwa.neg[i];
-            opsel[i] = false;
+            abs[i] = valu.abs[i];
+            neg[i] = valu.neg[i];
+            opsel[i] = valu.opsel & (1 << i);
          }
       } else if (instr->isVOP3P() && is_mad_mix) {
          const VOP3P_instruction& vop3p = instr->vop3p();
@@ -786,12 +756,6 @@ aco_print_instr(enum amd_gfx_level gfx_level, const Instruction* instr, FILE* ou
             f2f32[i] = vop3p.opsel_hi & (1 << i);
             opsel[i] = f2f32[i] && (vop3p.opsel_lo & (1 << i));
          }
-      } else if (instr->isVINTERP_INREG()) {
-         const VINTERP_inreg_instruction& vinterp = instr->vinterp_inreg();
-         for (unsigned i = 0; i < MIN2(num_operands, 3); ++i) {
-            neg[i] = vinterp.neg[i];
-            opsel[i] = vinterp.opsel & (1 << i);
-         }
       }
       for (unsigned i = 0; i < num_operands; ++i) {
          if (i)
-- 
GitLab


From 0062224cc8de7b37787935d1a073230ff4d79341 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 31 Jan 2023 18:03:01 +0100
Subject: [PATCH 6/9] aco/optimizer: simplify using VALU instruction

---
 src/amd/compiler/aco_optimizer.cpp | 191 ++++++++++-------------------
 1 file changed, 68 insertions(+), 123 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index e576c730a402..eb976b92cd32 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -1423,24 +1423,15 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             if (!instr->isDPP() && !instr->isSDWA())
                to_VOP3(ctx, instr);
             instr->operands[i].setTemp(info.temp);
-            if (instr->isDPP16() && !instr->dpp16().abs[i])
-               instr->dpp16().neg[i] = true;
-            else if (instr->isSDWA() && !instr->sdwa().abs[i])
-               instr->sdwa().neg[i] = true;
-            else if (instr->isVOP3() && !instr->vop3().abs[i])
-               instr->vop3().neg[i] = true;
+            if (!instr->valu().abs[i])
+               instr->valu().neg[i] = true;
          }
          if (info.is_abs() && can_use_mod && mod_bitsize_compat &&
              can_eliminate_fcanonicalize(ctx, instr, info.temp)) {
             if (!instr->isDPP() && !instr->isSDWA())
                to_VOP3(ctx, instr);
             instr->operands[i] = Operand(info.temp);
-            if (instr->isDPP16())
-               instr->dpp16().abs[i] = true;
-            else if (instr->isSDWA())
-               instr->sdwa().abs[i] = true;
-            else
-               instr->vop3().abs[i] = true;
+            instr->valu().abs[i] = true;
             continue;
          }
 
@@ -3511,25 +3502,6 @@ apply_sgprs(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
-template <typename T>
-bool
-apply_omod_clamp_helper(opt_ctx& ctx, T* instr, ssa_info& def_info)
-{
-   if (!def_info.is_clamp() && (instr->clamp || instr->omod))
-      return false;
-
-   if (def_info.is_omod2())
-      instr->omod = 1;
-   else if (def_info.is_omod4())
-      instr->omod = 2;
-   else if (def_info.is_omod5())
-      instr->omod = 3;
-   else if (def_info.is_clamp())
-      instr->clamp = true;
-
-   return true;
-}
-
 /* apply omod / clamp modifiers if the def is used only once and the instruction can have modifiers */
 bool
 apply_omod_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
@@ -3569,17 +3541,20 @@ apply_omod_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    /* MADs/FMAs are created later, so we don't have to update the original add */
    assert(!ctx.info[instr->definitions[0].tempId()].is_mad());
 
-   if (instr->isSDWA()) {
-      if (!apply_omod_clamp_helper(ctx, &instr->sdwa(), def_info))
-         return false;
-   } else if (instr->isVOP3P()) {
-      assert(def_info.is_clamp());
-      instr->vop3p().clamp = true;
-   } else {
+   if (!instr->isSDWA() && !instr->isVOP3P())
       to_VOP3(ctx, instr);
-      if (!apply_omod_clamp_helper(ctx, &instr->vop3(), def_info))
-         return false;
-   }
+
+   if (!def_info.is_clamp() && (instr->valu().clamp || instr->valu().omod))
+      return false;
+
+   if (def_info.is_omod2())
+      instr->valu().omod = 1;
+   else if (def_info.is_omod4())
+      instr->valu().omod = 2;
+   else if (def_info.is_omod5())
+      instr->valu().omod = 3;
+   else if (def_info.is_clamp())
+      instr->valu().clamp = true;
 
    instr->definitions[0].swapTemp(def_info.instr->definitions[0]);
    ctx.info[instr->definitions[0].tempId()].label &= label_clamp | label_insert | label_f2f16;
@@ -3998,10 +3973,8 @@ to_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    vop3p->opsel_hi = 0x0;
    for (unsigned i = 0; i < instr->operands.size(); i++) {
       vop3p->operands[is_add + i] = instr->operands[i];
-      vop3p->neg_lo[is_add + i] = instr->isVOP3() && instr->vop3().neg[i];
-      vop3p->neg_lo[is_add + i] |= instr->isSDWA() && instr->sdwa().neg[i];
-      vop3p->neg_hi[is_add + i] = instr->isVOP3() && instr->vop3().abs[i];
-      vop3p->neg_hi[is_add + i] |= instr->isSDWA() && instr->sdwa().abs[i];
+      vop3p->neg_lo[is_add + i] = instr->valu().neg[i];
+      vop3p->neg_hi[is_add + i] = instr->valu().abs[i];
       vop3p->opsel_lo |= (instr->isSDWA() && instr->sdwa().sel[i].offset()) << (is_add + i);
    }
    if (instr->opcode == aco_opcode::v_mul_f32) {
@@ -4105,11 +4078,11 @@ combine_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       instr->vop3p().opsel_hi ^= 1u << i;
       if (conv->isSDWA() && conv->sdwa().sel[0].offset() == 2)
          instr->vop3p().opsel_lo |= 1u << i;
-      bool neg = (conv->isVOP3() && conv->vop3().neg[0]) || (conv->isSDWA() && conv->sdwa().neg[0]);
-      bool abs = (conv->isVOP3() && conv->vop3().abs[0]) || (conv->isSDWA() && conv->sdwa().abs[0]);
-      if (!instr->vop3p().neg_hi[i]) {
-         instr->vop3p().neg_lo[i] ^= neg;
-         instr->vop3p().neg_hi[i] = abs;
+      bool neg = conv->valu().neg[0];
+      bool abs = conv->valu().abs[0];
+      if (!instr->vop3p().abs[i]) {
+         instr->vop3p().neg[i] ^= neg;
+         instr->vop3p().abs[i] = abs;
       }
    }
 }
@@ -4375,55 +4348,32 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          bool clamp = false;
          uint8_t opsel_lo = 0;
          uint8_t opsel_hi = 0;
-
-         if (mul_instr->isVOP3()) {
-            VOP3_instruction& vop3 = mul_instr->vop3();
-            neg[0] = vop3.neg[0];
-            neg[1] = vop3.neg[1];
-            abs[0] = vop3.abs[0];
-            abs[1] = vop3.abs[1];
-         } else if (mul_instr->isVOP3P()) {
-            VOP3P_instruction& vop3p = mul_instr->vop3p();
-            neg[0] = vop3p.neg_lo[0];
-            neg[1] = vop3p.neg_lo[1];
-            abs[0] = vop3p.neg_hi[0];
-            abs[1] = vop3p.neg_hi[1];
-            opsel_lo = vop3p.opsel_lo & 0x3;
-            opsel_hi = vop3p.opsel_hi & 0x3;
-         }
-
-         if (instr->isVOP3()) {
-            VOP3_instruction& vop3 = instr->vop3();
-            neg[2] = vop3.neg[add_op_idx];
-            abs[2] = vop3.abs[add_op_idx];
-            omod = vop3.omod;
-            clamp = vop3.clamp;
-            /* abs of the multiplication result */
-            if (vop3.abs[1 - add_op_idx]) {
-               neg[0] = false;
-               neg[1] = false;
-               abs[0] = true;
-               abs[1] = true;
-            }
-            /* neg of the multiplication result */
-            neg[1] = neg[1] ^ vop3.neg[1 - add_op_idx];
-         } else if (instr->isVOP3P()) {
-            VOP3P_instruction& vop3p = instr->vop3p();
-            neg[2] = vop3p.neg_lo[add_op_idx];
-            abs[2] = vop3p.neg_hi[add_op_idx];
-            opsel_lo |= vop3p.opsel_lo & (1 << add_op_idx) ? 0x4 : 0x0;
-            opsel_hi |= vop3p.opsel_hi & (1 << add_op_idx) ? 0x4 : 0x0;
-            clamp = vop3p.clamp;
-            /* abs of the multiplication result */
-            if (vop3p.neg_hi[3 - add_op_idx]) {
-               neg[0] = false;
-               neg[1] = false;
-               abs[0] = true;
-               abs[1] = true;
-            }
-            /* neg of the multiplication result */
-            neg[1] = neg[1] ^ vop3p.neg_lo[3 - add_op_idx];
+         unsigned mul_op_idx = (instr->isVOP3P() ? 3 : 1) - add_op_idx;
+
+         VALU_instruction& valu_mul = mul_instr->valu();
+         neg[0] = valu_mul.neg[0];
+         neg[1] = valu_mul.neg[1];
+         abs[0] = valu_mul.abs[0];
+         abs[1] = valu_mul.abs[1];
+         opsel_lo = valu_mul.opsel_lo & 0x3;
+         opsel_hi = valu_mul.opsel_hi & 0x3;
+
+         VALU_instruction& valu = instr->valu();
+         neg[2] = valu.neg[add_op_idx];
+         abs[2] = valu.abs[add_op_idx];
+         opsel_lo |= valu.opsel_lo & (1 << add_op_idx) ? 0x4 : 0x0;
+         opsel_hi |= valu.opsel_hi & (1 << add_op_idx) ? 0x4 : 0x0;
+         omod = valu.omod;
+         clamp = valu.clamp;
+         /* abs of the multiplication result */
+         if (valu.abs[mul_op_idx]) {
+            neg[0] = false;
+            neg[1] = false;
+            abs[0] = true;
+            abs[1] = true;
          }
+         /* neg of the multiplication result */
+         neg[1] ^= valu.neg[mul_op_idx];
 
          if (instr->opcode == aco_opcode::v_sub_f32 || instr->opcode == aco_opcode::v_sub_f16)
             neg[1 + add_op_idx] = neg[1 + add_op_idx] ^ true;
@@ -4432,24 +4382,17 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             neg[2 - add_op_idx] = neg[2 - add_op_idx] ^ true;
 
          aco_ptr<Instruction> add_instr = std::move(instr);
+         aco_ptr<VALU_instruction> mad;
          if (add_instr->isVOP3P() || mul_instr->isVOP3P()) {
             assert(!omod);
 
             aco_opcode mad_op = add_instr->definitions[0].bytes() == 2 ? aco_opcode::v_fma_mixlo_f16
                                                                        : aco_opcode::v_fma_mix_f32;
-            aco_ptr<VOP3P_instruction> mad{
-               create_instruction<VOP3P_instruction>(mad_op, Format::VOP3P, 3, 1)};
-            for (unsigned i = 0; i < 3; i++) {
-               mad->operands[i] = op[i];
-               mad->neg_lo[i] = neg[i];
-               mad->neg_hi[i] = abs[i];
-            }
-            mad->clamp = clamp;
-            mad->opsel_lo = opsel_lo;
-            mad->opsel_hi = opsel_hi;
-
-            instr = std::move(mad);
+            mad.reset(create_instruction<VOP3P_instruction>(mad_op, Format::VOP3P, 3, 1));
          } else {
+            assert(!opsel_lo);
+            assert(!opsel_hi);
+
             aco_opcode mad_op = emit_fma ? aco_opcode::v_fma_f32 : aco_opcode::v_mad_f32;
             if (mul_instr->opcode == aco_opcode::v_mul_legacy_f32) {
                assert(emit_fma == (ctx.program->gfx_level >= GFX10_3));
@@ -4463,21 +4406,23 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                mad_op = aco_opcode::v_fma_f64;
             }
 
-            aco_ptr<VOP3_instruction> mad{
-               create_instruction<VOP3_instruction>(mad_op, Format::VOP3, 3, 1)};
-            for (unsigned i = 0; i < 3; i++) {
-               mad->operands[i] = op[i];
-               mad->neg[i] = neg[i];
-               mad->abs[i] = abs[i];
-            }
-            mad->omod = omod;
-            mad->clamp = clamp;
+            mad.reset(create_instruction<VOP3_instruction>(mad_op, Format::VOP3, 3, 1));
+         }
 
-            instr = std::move(mad);
+         for (unsigned i = 0; i < 3; i++) {
+            mad->operands[i] = op[i];
+            mad->neg[i] = neg[i];
+            mad->abs[i] = abs[i];
          }
-         instr->definitions[0] = add_instr->definitions[0];
-         instr->definitions[0].setPrecise(add_instr->definitions[0].isPrecise() ||
-                                          mul_instr->definitions[0].isPrecise());
+         mad->omod = omod;
+         mad->clamp = clamp;
+         mad->opsel_lo = opsel_lo;
+         mad->opsel_hi = opsel_hi;
+         mad->definitions[0] = add_instr->definitions[0];
+         mad->definitions[0].setPrecise(add_instr->definitions[0].isPrecise() ||
+                                        mul_instr->definitions[0].isPrecise());
+
+         instr = std::move(mad);
 
          /* mark this ssa_def to be re-checked for profitability and literals */
          ctx.mad_infos.emplace_back(std::move(add_instr), mul_instr->definitions[0].tempId());
-- 
GitLab


From cb4c63f0176bf7f1c8bfe0fd6db7c3bd3f528e1d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 21 Feb 2023 20:08:42 +0100
Subject: [PATCH 7/9] aco: remove VOP[123C]P? structs

---
 src/amd/compiler/aco_assembler.cpp            |   4 +-
 src/amd/compiler/aco_builder_h.py             |  20 +--
 .../compiler/aco_instruction_selection.cpp    |  68 ++++----
 src/amd/compiler/aco_ir.cpp                   |   8 +-
 src/amd/compiler/aco_ir.h                     |  59 +------
 src/amd/compiler/aco_lower_to_hw_instr.cpp    |  22 +--
 src/amd/compiler/aco_opt_value_numbering.cpp  |  10 +-
 src/amd/compiler/aco_optimizer.cpp            | 155 +++++++++---------
 src/amd/compiler/aco_print_ir.cpp             |   4 +-
 src/amd/compiler/aco_register_allocation.cpp  |  18 +-
 src/amd/compiler/aco_spill.cpp                |   2 +-
 src/amd/compiler/aco_ssa_elimination.cpp      |   8 +-
 src/amd/compiler/aco_validate.cpp             |   8 +-
 src/amd/compiler/tests/helpers.cpp            |   4 +-
 src/amd/compiler/tests/test_assembler.cpp     |   6 +-
 src/amd/compiler/tests/test_optimizer.cpp     |  12 +-
 .../compiler/tests/test_optimizer_postRA.cpp  |   8 +-
 src/amd/compiler/tests/test_sdwa.cpp          |   5 +-
 18 files changed, 183 insertions(+), 238 deletions(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index a49b466eca9d..c2b4f9c78949 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -780,7 +780,7 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
        * except abs/neg is ignored). src2 cannot be literal and src0/src1 must be VGPR.
        */
       if (instr->isVOP3()) {
-         VOP3_instruction& vop3 = instr->vop3();
+         VALU_instruction& vop3 = instr->valu();
 
          if (instr->isVOP2()) {
             opcode = opcode + 0x100;
@@ -840,7 +840,7 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
          out.push_back(encoding);
 
       } else if (instr->isVOP3P()) {
-         VOP3P_instruction& vop3 = instr->vop3p();
+         VALU_instruction& vop3 = instr->valu();
 
          uint32_t encoding;
          if (ctx.gfx_level == GFX9) {
diff --git a/src/amd/compiler/aco_builder_h.py b/src/amd/compiler/aco_builder_h.py
index 0cc869b1073d..9ab0a2aaa0df 100644
--- a/src/amd/compiler/aco_builder_h.py
+++ b/src/amd/compiler/aco_builder_h.py
@@ -517,9 +517,9 @@ public:
       int num_defs = carry_out ? 2 : 1;
       aco_ptr<Instruction> sub;
       if (vop3)
-        sub.reset(create_instruction<VOP3_instruction>(op, Format::VOP3, num_ops, num_defs));
+        sub.reset(create_instruction<VALU_instruction>(op, Format::VOP3, num_ops, num_defs));
       else
-        sub.reset(create_instruction<VOP2_instruction>(op, Format::VOP2, num_ops, num_defs));
+        sub.reset(create_instruction<VALU_instruction>(op, Format::VOP2, num_ops, num_defs));
       sub->operands[0] = a.op;
       sub->operands[1] = b.op;
       if (!borrow.op.isUndefined())
@@ -562,14 +562,14 @@ formats = [("pseudo", [Format.PSEUDO], 'Pseudo_instruction', list(itertools.prod
            ("branch", [Format.PSEUDO_BRANCH], 'Pseudo_branch_instruction', itertools.product([1], [0, 1])),
            ("barrier", [Format.PSEUDO_BARRIER], 'Pseudo_barrier_instruction', [(0, 0)]),
            ("reduction", [Format.PSEUDO_REDUCTION], 'Pseudo_reduction_instruction', [(3, 3)]),
-           ("vop1", [Format.VOP1], 'VOP1_instruction', [(0, 0), (1, 1), (2, 2)]),
+           ("vop1", [Format.VOP1], 'VALU_instruction', [(0, 0), (1, 1), (2, 2)]),
            ("vop1_sdwa", [Format.VOP1, Format.SDWA], 'SDWA_instruction', [(1, 1)]),
-           ("vop2", [Format.VOP2], 'VOP2_instruction', itertools.product([1, 2], [2, 3])),
+           ("vop2", [Format.VOP2], 'VALU_instruction', itertools.product([1, 2], [2, 3])),
            ("vop2_sdwa", [Format.VOP2, Format.SDWA], 'SDWA_instruction', itertools.product([1, 2], [2, 3])),
-           ("vopc", [Format.VOPC], 'VOPC_instruction', itertools.product([1, 2], [2])),
+           ("vopc", [Format.VOPC], 'VALU_instruction', itertools.product([1, 2], [2])),
            ("vopc_sdwa", [Format.VOPC, Format.SDWA], 'SDWA_instruction', itertools.product([1, 2], [2])),
-           ("vop3", [Format.VOP3], 'VOP3_instruction', [(1, 3), (1, 2), (1, 1), (2, 2)]),
-           ("vop3p", [Format.VOP3P], 'VOP3P_instruction', [(1, 2), (1, 3)]),
+           ("vop3", [Format.VOP3], 'VALU_instruction', [(1, 3), (1, 2), (1, 1), (2, 2)]),
+           ("vop3p", [Format.VOP3P], 'VALU_instruction', [(1, 2), (1, 3)]),
            ("vinterp_inreg", [Format.VINTERP_INREG], 'VINTERP_inreg_instruction', [(1, 3)]),
            ("vintrp", [Format.VINTRP], 'VINTRP_instruction', [(1, 2), (1, 3)]),
            ("vop1_dpp", [Format.VOP1, Format.DPP16], 'DPP16_instruction', [(1, 1)]),
@@ -578,9 +578,9 @@ formats = [("pseudo", [Format.PSEUDO], 'Pseudo_instruction', list(itertools.prod
            ("vop1_dpp8", [Format.VOP1, Format.DPP8], 'DPP8_instruction', [(1, 1)]),
            ("vop2_dpp8", [Format.VOP2, Format.DPP8], 'DPP8_instruction', itertools.product([1, 2], [2, 3])),
            ("vopc_dpp8", [Format.VOPC, Format.DPP8], 'DPP8_instruction', itertools.product([1, 2], [2])),
-           ("vop1_e64", [Format.VOP1, Format.VOP3], 'VOP3_instruction', itertools.product([1], [1])),
-           ("vop2_e64", [Format.VOP2, Format.VOP3], 'VOP3_instruction', itertools.product([1, 2], [2, 3])),
-           ("vopc_e64", [Format.VOPC, Format.VOP3], 'VOP3_instruction', itertools.product([1, 2], [2])),
+           ("vop1_e64", [Format.VOP1, Format.VOP3], 'VALU_instruction', itertools.product([1], [1])),
+           ("vop2_e64", [Format.VOP2, Format.VOP3], 'VALU_instruction', itertools.product([1, 2], [2, 3])),
+           ("vopc_e64", [Format.VOPC, Format.VOP3], 'VALU_instruction', itertools.product([1, 2], [2])),
            ("flat", [Format.FLAT], 'FLAT_instruction', [(0, 3), (1, 2)]),
            ("global", [Format.GLOBAL], 'FLAT_instruction', [(0, 3), (1, 2)]),
            ("scratch", [Format.SCRATCH], 'FLAT_instruction', [(0, 3), (1, 2)])]
diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index cccc628d2dae..2beaa9e79fa1 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -286,7 +286,7 @@ emit_masked_swizzle(isel_context* ctx, Builder& bld, Temp src, unsigned mask)
          Temp op1 = bld.copy(bld.def(s1), Operand::c32(lane_mask & 0xffffffff));
          Temp op2 = bld.copy(bld.def(s1), Operand::c32(lane_mask >> 32));
          Builder::Result ret = bld.vop3(opcode, bld.def(v1), src, op1, op2);
-         ret->vop3().opsel = 0x3; /* set BOUND_CTRL/FETCH_INACTIVE */
+         ret->valu().opsel = 0x3; /* set BOUND_CTRL/FETCH_INACTIVE */
          return ret;
       }
 
@@ -1035,8 +1035,8 @@ emit_idot_instruction(isel_context* ctx, nir_alu_instr* instr, aco_opcode op, Te
 
    Builder bld(ctx->program, ctx->block);
    bld.is_precise = instr->exact;
-   VOP3P_instruction& vop3p =
-      bld.vop3p(op, Definition(dst), src[0], src[1], src[2], 0x0, 0x7)->vop3p();
+   VALU_instruction& vop3p =
+      bld.vop3p(op, Definition(dst), src[0], src[1], src[2], 0x0, 0x7)->valu();
    vop3p.clamp = clamp;
    u_foreach_bit (i, neg_lo)
       vop3p.neg_lo[i] = true;
@@ -1363,7 +1363,7 @@ emit_floor_f64(isel_context* ctx, Builder& bld, Definition dst, Temp val)
    Temp v = bld.pseudo(aco_opcode::p_create_vector, bld.def(v2), dst0, dst1);
 
    Instruction* add = bld.vop3(aco_opcode::v_add_f64, Definition(dst), src0, v);
-   add->vop3().neg[1] = true;
+   add->valu().neg[1] = true;
 
    return add->definitions[0].getTemp();
 }
@@ -1383,7 +1383,7 @@ uadd32_sat(Builder& bld, Definition dst, Temp src0, Temp src1)
    } else {
       add = bld.vop2_e64(aco_opcode::v_add_co_u32, dst, bld.def(bld.lm), src0, src1);
    }
-   add->vop3().clamp = 1;
+   add->valu().clamp = 1;
    return dst.getTemp();
 }
 
@@ -1402,7 +1402,7 @@ usub32_sat(Builder& bld, Definition dst, Temp src0, Temp src1)
    } else {
       sub = bld.vop2_e64(aco_opcode::v_sub_co_u32, dst, bld.def(bld.lm), src0, src1);
    }
-   sub->vop3().clamp = 1;
+   sub->valu().clamp = 1;
    return dst.getTemp();
 }
 
@@ -1936,7 +1936,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
       if (dst.regClass() == v1 && instr->dest.dest.ssa.bit_size == 16) {
          Instruction* add_instr =
             emit_vop3p_instruction(ctx, instr, aco_opcode::v_pk_add_u16, dst);
-         add_instr->vop3p().clamp = 1;
+         add_instr->valu().clamp = 1;
          break;
       }
       Temp src0 = get_alu_src(ctx, instr->src[0]);
@@ -1957,7 +1957,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             add_instr =
                bld.vop2_e64(aco_opcode::v_add_u16, Definition(dst), src0, as_vgpr(ctx, src1)).instr;
          }
-         add_instr->vop3().clamp = 1;
+         add_instr->valu().clamp = 1;
          break;
       } else if (dst.regClass() == v1) {
          uadd32_sat(bld, Definition(dst), src0, src1);
@@ -1998,7 +1998,8 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             carry1 = bld.tmp(bld.lm);
             bld.vop2_e64(aco_opcode::v_addc_co_u32, Definition(dst1), Definition(carry1),
                          as_vgpr(ctx, src01), as_vgpr(ctx, src11), carry0)
-               ->vop3().clamp = 1;
+               ->valu()
+               .clamp = 1;
          } else {
             Temp no_sat1 = bld.tmp(v1);
             carry1 = bld.vadd32(Definition(no_sat1), src01, src11, true, carry0).def(1).getTemp();
@@ -2018,7 +2019,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
       if (dst.regClass() == v1 && instr->dest.dest.ssa.bit_size == 16) {
          Instruction* add_instr =
             emit_vop3p_instruction(ctx, instr, aco_opcode::v_pk_add_i16, dst);
-         add_instr->vop3p().clamp = 1;
+         add_instr->valu().clamp = 1;
          break;
       }
       Temp src0 = get_alu_src(ctx, instr->src[0]);
@@ -2039,11 +2040,11 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
       if (dst.regClass() == v2b) {
          Instruction* add_instr =
             bld.vop3(aco_opcode::v_add_i16, Definition(dst), src0, src1).instr;
-         add_instr->vop3().clamp = 1;
+         add_instr->valu().clamp = 1;
       } else if (dst.regClass() == v1) {
          Instruction* add_instr =
             bld.vop3(aco_opcode::v_add_i32, Definition(dst), src0, src1).instr;
-         add_instr->vop3().clamp = 1;
+         add_instr->valu().clamp = 1;
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
@@ -2178,7 +2179,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
    case nir_op_usub_sat: {
       if (dst.regClass() == v1 && instr->dest.dest.ssa.bit_size == 16) {
          Instruction* sub_instr = emit_vop3p_instruction(ctx, instr, aco_opcode::v_pk_sub_u16, dst);
-         sub_instr->vop3p().clamp = 1;
+         sub_instr->valu().clamp = 1;
          break;
       }
       Temp src0 = get_alu_src(ctx, instr->src[0]);
@@ -2200,7 +2201,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             }
             sub_instr = bld.vop2_e64(op, Definition(dst), src0, as_vgpr(ctx, src1)).instr;
          }
-         sub_instr->vop3().clamp = 1;
+         sub_instr->valu().clamp = 1;
          break;
       } else if (dst.regClass() == v1) {
          usub32_sat(bld, Definition(dst), src0, as_vgpr(ctx, src1));
@@ -2240,7 +2241,8 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             carry1 = bld.tmp(bld.lm);
             bld.vop2_e64(aco_opcode::v_subb_co_u32, Definition(dst1), Definition(carry1),
                          as_vgpr(ctx, src01), as_vgpr(ctx, src11), carry0)
-               ->vop3().clamp = 1;
+               ->valu()
+               .clamp = 1;
          } else {
             Temp no_sat1 = bld.tmp(v1);
             carry1 = bld.vsub32(Definition(no_sat1), src01, src11, true, carry0).def(1).getTemp();
@@ -2259,7 +2261,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
    case nir_op_isub_sat: {
       if (dst.regClass() == v1 && instr->dest.dest.ssa.bit_size == 16) {
          Instruction* sub_instr = emit_vop3p_instruction(ctx, instr, aco_opcode::v_pk_sub_i16, dst);
-         sub_instr->vop3p().clamp = 1;
+         sub_instr->valu().clamp = 1;
          break;
       }
       Temp src0 = get_alu_src(ctx, instr->src[0]);
@@ -2280,11 +2282,11 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
       if (dst.regClass() == v2b) {
          Instruction* sub_instr =
             bld.vop3(aco_opcode::v_sub_i16, Definition(dst), src0, src1).instr;
-         sub_instr->vop3().clamp = 1;
+         sub_instr->valu().clamp = 1;
       } else if (dst.regClass() == v1) {
          Instruction* sub_instr =
             bld.vop3(aco_opcode::v_sub_i32, Definition(dst), src0, src1).instr;
-         sub_instr->vop3().clamp = 1;
+         sub_instr->valu().clamp = 1;
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
@@ -2395,7 +2397,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
    case nir_op_fsub: {
       if (dst.regClass() == v1 && instr->dest.dest.ssa.bit_size == 16) {
          Instruction* add = emit_vop3p_instruction(ctx, instr, aco_opcode::v_pk_add_f16, dst);
-         VOP3P_instruction& sub = add->vop3p();
+         VALU_instruction& sub = add->valu();
          sub.neg_lo[1] = true;
          sub.neg_hi[1] = true;
          break;
@@ -2416,7 +2418,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
       } else if (dst.regClass() == v2) {
          Instruction* add = bld.vop3(aco_opcode::v_add_f64, Definition(dst), as_vgpr(ctx, src0),
                                      as_vgpr(ctx, src1));
-         add->vop3().neg[1] = true;
+         add->valu().neg[1] = true;
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
@@ -2585,8 +2587,8 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          Instruction* vop3p =
             bld.vop3p(aco_opcode::v_pk_mul_f16, Definition(dst), src, Operand::c16(0x3C00),
                       instr->src[0].swizzle[0] & 1, instr->src[0].swizzle[1] & 1);
-         vop3p->vop3p().neg_lo[0] = true;
-         vop3p->vop3p().neg_hi[0] = true;
+         vop3p->valu().neg_lo[0] = true;
+         vop3p->valu().neg_hi[0] = true;
          break;
       }
       Temp src = get_alu_src(ctx, instr->src[0]);
@@ -2615,8 +2617,8 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             bld.vop3p(aco_opcode::v_pk_max_f16, Definition(dst), src, src,
                       instr->src[0].swizzle[0] & 1 ? 3 : 0, instr->src[0].swizzle[1] & 1 ? 3 : 0)
                .instr;
-         vop3p->vop3p().neg_lo[1] = true;
-         vop3p->vop3p().neg_hi[1] = true;
+         vop3p->valu().neg_lo[1] = true;
+         vop3p->valu().neg_hi[1] = true;
          break;
       }
       Temp src = get_alu_src(ctx, instr->src[0]);
@@ -2624,12 +2626,12 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          Instruction* mul = bld.vop2_e64(aco_opcode::v_mul_f16, Definition(dst),
                                          Operand::c16(0x3c00), as_vgpr(ctx, src))
                                .instr;
-         mul->vop3().abs[1] = true;
+         mul->valu().abs[1] = true;
       } else if (dst.regClass() == v1) {
          Instruction* mul = bld.vop2_e64(aco_opcode::v_mul_f32, Definition(dst),
                                          Operand::c32(0x3f800000u), as_vgpr(ctx, src))
                                .instr;
-         mul->vop3().abs[1] = true;
+         mul->valu().abs[1] = true;
       } else if (dst.regClass() == v2) {
          if (ctx->block->fp_mode.must_flush_denorms16_64)
             src = bld.vop3(aco_opcode::v_mul_f64, bld.def(v2), Operand::c64(0x3FF0000000000000),
@@ -2649,7 +2651,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          Instruction* vop3p =
             bld.vop3p(aco_opcode::v_pk_mul_f16, Definition(dst), src, Operand::c16(0x3C00),
                       instr->src[0].swizzle[0] & 1, instr->src[0].swizzle[1] & 1);
-         vop3p->vop3p().clamp = true;
+         vop3p->valu().clamp = true;
          break;
       }
       Temp src = get_alu_src(ctx, instr->src[0]);
@@ -2664,7 +2666,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          // TODO: confirm that this holds under any circumstances
       } else if (dst.regClass() == v2) {
          Instruction* add = bld.vop3(aco_opcode::v_add_f64, Definition(dst), src, Operand::zero());
-         add->vop3().clamp = true;
+         add->valu().clamp = true;
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
@@ -2814,13 +2816,13 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             Instruction* sub =
                bld.vop3(aco_opcode::v_add_f64, bld.def(v2), tmp,
                         bld.pseudo(aco_opcode::p_create_vector, bld.def(v2), Operand::zero(), bfi));
-            sub->vop3().neg[1] = true;
+            sub->valu().neg[1] = true;
             tmp = sub->definitions[0].getTemp();
 
             Temp v = bld.pseudo(aco_opcode::p_create_vector, bld.def(v2), Operand::c32(-1u),
                                 Operand::c32(0x432fffffu));
             Instruction* vop3 = bld.vopc_e64(aco_opcode::v_cmp_gt_f64, bld.def(bld.lm), src0, v);
-            vop3->vop3().abs[0] = true;
+            vop3->valu().abs[0] = true;
             Temp cond = vop3->definitions[0].getTemp();
 
             Temp tmp_lo = bld.tmp(v1), tmp_hi = bld.tmp(v1);
@@ -3663,7 +3665,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          f32 = bld.vop1(aco_opcode::v_cvt_f32_f16, bld.def(v1), f16);
          Temp smallest = bld.copy(bld.def(s1), Operand::c32(0x38800000u));
          Instruction* tmp0 = bld.vopc_e64(aco_opcode::v_cmp_lt_f32, bld.def(bld.lm), f32, smallest);
-         tmp0->vop3().abs[0] = true;
+         tmp0->valu().abs[0] = true;
          Temp tmp1 = bld.vopc(aco_opcode::v_cmp_lg_f32, bld.def(bld.lm), Operand::zero(), f32);
          cmp_res = bld.sop2(aco_opcode::s_nand_b64, bld.def(s2), bld.def(s1, scc),
                             tmp0->definitions[0].getTemp(), tmp1);
@@ -9240,8 +9242,8 @@ prepare_cube_coords(isel_context* ctx, std::vector<Temp>& coords, Temp* ddx, Tem
 
    ma = bld.vop3(aco_opcode::v_cubema_f32, bld.def(v1), coords[0], coords[1], coords[2]);
 
-   aco_ptr<VOP3_instruction> vop3a{
-      create_instruction<VOP3_instruction>(aco_opcode::v_rcp_f32, asVOP3(Format::VOP1), 1, 1)};
+   aco_ptr<VALU_instruction> vop3a{
+      create_instruction<VALU_instruction>(aco_opcode::v_rcp_f32, asVOP3(Format::VOP1), 1, 1)};
    vop3a->operands[0] = Operand(ma);
    vop3a->abs[0] = true;
    Temp invma = bld.tmp(v1);
diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index c4f33673dc6a..a657f4db4a9a 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -231,7 +231,7 @@ can_use_SDWA(amd_gfx_level gfx_level, const aco_ptr<Instruction>& instr, bool pr
       return true;
 
    if (instr->isVOP3()) {
-      VOP3_instruction& vop3 = instr->vop3();
+      VALU_instruction& vop3 = instr->valu();
       if (instr->format == Format::VOP3)
          return false;
       if (vop3.clamp && instr->isVOPC() && gfx_level != GFX8)
@@ -303,7 +303,7 @@ convert_to_SDWA(amd_gfx_level gfx_level, aco_ptr<Instruction>& instr)
    SDWA_instruction& sdwa = instr->sdwa();
 
    if (tmp->isVOP3()) {
-      VOP3_instruction& vop3 = tmp->vop3();
+      VALU_instruction& vop3 = tmp->valu();
       memcpy(sdwa.neg, vop3.neg, sizeof(sdwa.neg));
       memcpy(sdwa.abs, vop3.abs, sizeof(sdwa.abs));
       sdwa.omod = vop3.omod;
@@ -354,7 +354,7 @@ can_use_DPP(const aco_ptr<Instruction>& instr, bool pre_ra, bool dpp8)
       return false;
 
    if (instr->isVOP3()) {
-      const VOP3_instruction* vop3 = &instr->vop3();
+      const VALU_instruction* vop3 = &instr->valu();
       if (vop3->clamp || vop3->omod || vop3->opsel)
          return false;
       if (dpp8)
@@ -405,7 +405,7 @@ convert_to_DPP(aco_ptr<Instruction>& instr, bool dpp8)
       dpp->bank_mask = 0xf;
 
       if (tmp->isVOP3()) {
-         const VOP3_instruction* vop3 = &tmp->vop3();
+         const VALU_instruction* vop3 = &tmp->valu();
          memcpy(dpp->neg, vop3->neg, sizeof(dpp->neg));
          memcpy(dpp->abs, vop3->abs, sizeof(dpp->abs));
       }
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index f426f21c3734..d4b81ce9a28c 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1014,12 +1014,7 @@ struct Pseudo_branch_instruction;
 struct Pseudo_barrier_instruction;
 struct Pseudo_reduction_instruction;
 struct VALU_instruction;
-typedef VALU_instruction VOP3P_instruction;
 struct VINTERP_inreg_instruction;
-typedef VALU_instruction VOP1_instruction;
-typedef VALU_instruction VOP2_instruction;
-typedef VALU_instruction VOPC_instruction;
-typedef VALU_instruction VOP3_instruction;
 struct VINTRP_instruction;
 struct DPP16_instruction;
 struct DPP8_instruction;
@@ -1253,16 +1248,6 @@ struct Instruction {
       return *(Pseudo_reduction_instruction*)this;
    }
    constexpr bool isReduction() const noexcept { return format == Format::PSEUDO_REDUCTION; }
-   VOP3P_instruction& vop3p() noexcept
-   {
-      assert(isVOP3P());
-      return *(VOP3P_instruction*)this;
-   }
-   const VOP3P_instruction& vop3p() const noexcept
-   {
-      assert(isVOP3P());
-      return *(VOP3P_instruction*)this;
-   }
    constexpr bool isVOP3P() const noexcept { return format == Format::VOP3P; }
    VINTERP_inreg_instruction& vinterp_inreg() noexcept
    {
@@ -1275,49 +1260,9 @@ struct Instruction {
       return *(VINTERP_inreg_instruction*)this;
    }
    constexpr bool isVINTERP_INREG() const noexcept { return format == Format::VINTERP_INREG; }
-   VOP1_instruction& vop1() noexcept
-   {
-      assert(isVOP1());
-      return *(VOP1_instruction*)this;
-   }
-   const VOP1_instruction& vop1() const noexcept
-   {
-      assert(isVOP1());
-      return *(VOP1_instruction*)this;
-   }
    constexpr bool isVOP1() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP1; }
-   VOP2_instruction& vop2() noexcept
-   {
-      assert(isVOP2());
-      return *(VOP2_instruction*)this;
-   }
-   const VOP2_instruction& vop2() const noexcept
-   {
-      assert(isVOP2());
-      return *(VOP2_instruction*)this;
-   }
    constexpr bool isVOP2() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP2; }
-   VOPC_instruction& vopc() noexcept
-   {
-      assert(isVOPC());
-      return *(VOPC_instruction*)this;
-   }
-   const VOPC_instruction& vopc() const noexcept
-   {
-      assert(isVOPC());
-      return *(VOPC_instruction*)this;
-   }
    constexpr bool isVOPC() const noexcept { return (uint16_t)format & (uint16_t)Format::VOPC; }
-   VOP3_instruction& vop3() noexcept
-   {
-      assert(isVOP3());
-      return *(VOP3_instruction*)this;
-   }
-   const VOP3_instruction& vop3() const noexcept
-   {
-      assert(isVOP3());
-      return *(VOP3_instruction*)this;
-   }
    constexpr bool isVOP3() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP3; }
    VINTRP_instruction& vintrp() noexcept
    {
@@ -1814,7 +1759,7 @@ Instruction::usesModifiers() const noexcept
       return true;
 
    if (isVOP3P()) {
-      const VOP3P_instruction& vop3p = this->vop3p();
+      const VALU_instruction& vop3p = this->valu();
       for (unsigned i = 0; i < operands.size(); i++) {
          if (vop3p.neg_lo[i] || vop3p.neg_hi[i])
             return true;
@@ -1825,7 +1770,7 @@ Instruction::usesModifiers() const noexcept
       }
       return vop3p.opsel_lo || vop3p.clamp;
    } else if (isVOP3()) {
-      const VOP3_instruction& vop3 = this->vop3();
+      const VALU_instruction& vop3 = this->valu();
       for (unsigned i = 0; i < operands.size(); i++) {
          if (vop3.abs[i] || vop3.neg[i])
             return true;
diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index 34775638bae3..af26eadfd28b 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -655,7 +655,7 @@ emit_reduction(lower_context* ctx, aco_opcode op, ReduceOp reduce_op, unsigned c
                         Operand(PhysReg{tmp + i}, v1), Operand::c32(0xffffffffu),
                         Operand::c32(0xffffffffu))
                   .instr;
-            perm->vop3().opsel = 1; /* FI (Fetch Inactive) */
+            perm->valu().opsel = 1; /* FI (Fetch Inactive) */
          }
          bld.sop1(Builder::s_mov, Definition(exec, bld.lm), Operand::c64(UINT64_MAX));
 
@@ -789,7 +789,7 @@ emit_reduction(lower_context* ctx, aco_opcode op, ReduceOp reduce_op, unsigned c
                         Operand(PhysReg{tmp + i}, v1), Operand::c32(0xffffffffu),
                         Operand::c32(0xffffffffu))
                   .instr;
-            perm->vop3().opsel = 1; /* FI (Fetch Inactive) */
+            perm->valu().opsel = 1; /* FI (Fetch Inactive) */
          }
          emit_op(ctx, tmp, tmp, vtmp, PhysReg{0}, reduce_op, src.size());
 
@@ -1110,7 +1110,7 @@ emit_v_mov_b16(Builder& bld, Definition dst, Operand op)
          /* v_add_f16 is smaller because it can use 16bit fp inline constants. */
          Instruction* instr = bld.vop2_e64(aco_opcode::v_add_f16, dst, op, Operand::zero());
          if (dst.physReg().byte() == 2)
-            instr->vop3().opsel = 0x8;
+            instr->valu().opsel = 0x8;
          return;
       }
       op = Operand::c32((int32_t)(int16_t)op.constantValue());
@@ -1122,9 +1122,9 @@ emit_v_mov_b16(Builder& bld, Definition dst, Operand op)
       // TODO: this can use VOP1 for vgpr0-127 with assembler support
       Instruction* instr = bld.vop1_e64(aco_opcode::v_mov_b16, dst, op);
       if (op.physReg().byte() == 2)
-         instr->vop3().opsel |= 0x1;
+         instr->valu().opsel |= 0x1;
       if (dst.physReg().byte() == 2)
-         instr->vop3().opsel |= 0x8;
+         instr->valu().opsel |= 0x8;
    }
 }
 
@@ -1226,12 +1226,12 @@ copy_constant(lower_context* ctx, Builder& bld, Definition dst, Operand op)
          if (dst.physReg().byte() == 2) {
             Operand def_lo(dst.physReg().advance(-2), v2b);
             Instruction* instr = bld.vop3(aco_opcode::v_pack_b32_f16, dst, def_lo, op);
-            instr->vop3().opsel = 0;
+            instr->valu().opsel = 0;
          } else {
             assert(dst.physReg().byte() == 0);
             Operand def_hi(dst.physReg().advance(2), v2b);
             Instruction* instr = bld.vop3(aco_opcode::v_pack_b32_f16, dst, op, def_hi);
-            instr->vop3().opsel = 2;
+            instr->valu().opsel = 2;
          }
       } else if (can_use_perm) {
          uint8_t swiz[] = {4, 5, 6, 7};
@@ -1307,11 +1307,11 @@ addsub_subdword_gfx11(Builder& bld, Definition dst, Operand src0, Operand src1,
    Instruction* instr =
       bld.vop3(sub ? aco_opcode::v_sub_u16_e64 : aco_opcode::v_add_u16_e64, dst, src0, src1).instr;
    if (src0.physReg().byte() == 2)
-      instr->vop3().opsel |= 0x1;
+      instr->valu().opsel |= 0x1;
    if (src1.physReg().byte() == 2)
-      instr->vop3().opsel |= 0x2;
+      instr->valu().opsel |= 0x2;
    if (dst.physReg().byte() == 2)
-      instr->vop3().opsel |= 0x8;
+      instr->valu().opsel |= 0x8;
 }
 
 bool
@@ -1555,7 +1555,7 @@ do_pack_2x16(lower_context* ctx, Builder& bld, Definition def, Operand lo, Opera
    if (can_use_pack) {
       Instruction* instr = bld.vop3(aco_opcode::v_pack_b32_f16, def, lo, hi);
       /* opsel: 0 = select low half, 1 = select high half. [0] = src0, [1] = src1 */
-      instr->vop3().opsel = hi.physReg().byte() | (lo.physReg().byte() >> 1);
+      instr->valu().opsel = hi.physReg().byte() | (lo.physReg().byte() >> 1);
       return;
    }
 
diff --git a/src/amd/compiler/aco_opt_value_numbering.cpp b/src/amd/compiler/aco_opt_value_numbering.cpp
index db977fe486bd..4ce05c2572ee 100644
--- a/src/amd/compiler/aco_opt_value_numbering.cpp
+++ b/src/amd/compiler/aco_opt_value_numbering.cpp
@@ -85,7 +85,7 @@ struct InstrHash {
    std::size_t operator()(Instruction* instr) const
    {
       if (instr->isVOP3())
-         return hash_murmur_32<VOP3_instruction>(instr);
+         return hash_murmur_32<VALU_instruction>(instr);
 
       if (instr->isDPP16())
          return hash_murmur_32<DPP16_instruction>(instr);
@@ -168,8 +168,8 @@ struct InstrPred {
          return a->pass_flags == b->pass_flags;
 
       if (a->isVOP3()) {
-         VOP3_instruction& a3 = a->vop3();
-         VOP3_instruction& b3 = b->vop3();
+         VALU_instruction& a3 = a->valu();
+         VALU_instruction& b3 = b->valu();
          for (unsigned i = 0; i < 3; i++) {
             if (a3.abs[i] != b3.abs[i] || a3.neg[i] != b3.neg[i])
                return false;
@@ -233,8 +233,8 @@ struct InstrPred {
          return true;
       }
       case Format::VOP3P: {
-         VOP3P_instruction& a3P = a->vop3p();
-         VOP3P_instruction& b3P = b->vop3p();
+         VALU_instruction& a3P = a->valu();
+         VALU_instruction& b3P = b->valu();
          for (unsigned i = 0; i < 3; i++) {
             if (a3P.neg_lo[i] != b3P.neg_lo[i] || a3P.neg_hi[i] != b3P.neg_hi[i])
                return false;
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index eb976b92cd32..bafb55c073a9 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -640,7 +640,7 @@ to_VOP3(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
    aco_ptr<Instruction> tmp = std::move(instr);
    Format format = asVOP3(tmp->format);
-   instr.reset(create_instruction<VOP3_instruction>(tmp->opcode, format, tmp->operands.size(),
+   instr.reset(create_instruction<VALU_instruction>(tmp->opcode, format, tmp->operands.size(),
                                                     tmp->definitions.size()));
    std::copy(tmp->operands.cbegin(), tmp->operands.cend(), instr->operands.begin());
    for (unsigned i = 0; i < instr->definitions.size(); i++) {
@@ -940,7 +940,7 @@ get_operand_size(aco_ptr<Instruction>& instr, unsigned index)
       return index == 2 ? 64 : 32;
    else if (instr->opcode == aco_opcode::v_fma_mix_f32 ||
             instr->opcode == aco_opcode::v_fma_mixlo_f16)
-      return instr->vop3p().opsel_hi & (1u << index) ? 16 : 32;
+      return instr->valu().opsel_hi & (1u << index) ? 16 : 32;
    else if (instr->isVALU() || instr->isSALU())
       return instr_info.operand_size[(int)instr->opcode];
    else
@@ -978,7 +978,7 @@ propagate_constants_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr, ssa_info& i
       return;
 
    /* try to fold inline constants */
-   VOP3P_instruction* vop3p = &instr->vop3p();
+   VALU_instruction* vop3p = &instr->valu();
    bool opsel_lo = (vop3p->opsel_lo >> i) & 1;
    bool opsel_hi = (vop3p->opsel_hi >> i) & 1;
 
@@ -1128,7 +1128,7 @@ can_apply_extract(opt_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, ssa_i
       return true;
    } else if (instr->isVOP3() && sel.size() == 2 &&
               can_use_opsel(ctx.program->gfx_level, instr->opcode, idx) &&
-              !(instr->vop3().opsel & (1 << idx))) {
+              !(instr->valu().opsel & (1 << idx))) {
       return true;
    } else if (instr->opcode == aco_opcode::p_extract) {
       SubdwordSel instrSel = parse_extract(instr.get());
@@ -1182,12 +1182,12 @@ apply_extract(opt_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, ssa_info&
               (instr->operands[!idx].is16bit() ||
                instr->operands[!idx].constantValue() <= UINT16_MAX)) {
       Instruction* mad =
-         create_instruction<VOP3_instruction>(aco_opcode::v_mad_u32_u16, Format::VOP3, 3, 1);
+         create_instruction<VALU_instruction>(aco_opcode::v_mad_u32_u16, Format::VOP3, 3, 1);
       mad->definitions[0] = instr->definitions[0];
       mad->operands[0] = instr->operands[0];
       mad->operands[1] = instr->operands[1];
       mad->operands[2] = Operand::zero();
-      mad->vop3().opsel = (sel.offset() / 2) << idx;
+      mad->valu().opsel = (sel.offset() / 2) << idx;
       instr.reset(mad);
    } else if (can_use_SDWA(ctx.program->gfx_level, instr, true) &&
               (tmp.type() == RegType::vgpr || ctx.program->gfx_level >= GFX9)) {
@@ -1195,7 +1195,7 @@ apply_extract(opt_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, ssa_info&
       static_cast<SDWA_instruction*>(instr.get())->sel[idx] = sel;
    } else if (instr->isVOP3()) {
       if (sel.offset())
-         instr->vop3().opsel |= 1 << idx;
+         instr->valu().opsel |= 1 << idx;
    } else if (instr->opcode == aco_opcode::p_extract) {
       SubdwordSel instrSel = parse_extract(instr.get());
 
@@ -1871,7 +1871,7 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                  instr->operands[!i].constantEquals(fp16 ? 0xbc00 : 0xbf800000u))) { /* -1.0 */
                bool neg1 = instr->operands[!i].constantEquals(fp16 ? 0xbc00 : 0xbf800000u);
 
-               VOP3_instruction* vop3 = instr->isVOP3() ? &instr->vop3() : NULL;
+               VALU_instruction* vop3 = instr->isVOP3() ? &instr->valu() : NULL;
                if (vop3 && (vop3->abs[!i] || vop3->neg[!i] || vop3->clamp || vop3->omod))
                   continue;
 
@@ -1918,7 +1918,7 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       break;
    case aco_opcode::v_med3_f16:
    case aco_opcode::v_med3_f32: { /* clamp */
-      VOP3_instruction& vop3 = instr->vop3();
+      VALU_instruction& vop3 = instr->valu();
       if (vop3.abs[0] || vop3.abs[1] || vop3.abs[2] || vop3.neg[0] || vop3.neg[1] || vop3.neg[2] ||
           vop3.omod != 0 || vop3.opsel != 0)
          break;
@@ -2260,7 +2260,7 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          return false;
 
       if (op_instr[i]->isVOP3()) {
-         VOP3_instruction& vop3 = op_instr[i]->vop3();
+         VALU_instruction& vop3 = op_instr[i]->valu();
          if (vop3.neg[0] != vop3.neg[1] || vop3.abs[0] != vop3.abs[1] || vop3.opsel == 1 ||
              vop3.opsel == 2)
             return false;
@@ -2294,8 +2294,8 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
    Instruction* new_instr;
    if (neg[0] || neg[1] || abs[0] || abs[1] || opsel || num_sgprs > 1) {
-      VOP3_instruction* vop3 =
-         create_instruction<VOP3_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
+      VALU_instruction* vop3 =
+         create_instruction<VALU_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
       for (unsigned i = 0; i < 2; i++) {
          vop3->neg[i] = neg[i];
          vop3->abs[i] = abs[i];
@@ -2303,7 +2303,7 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       vop3->opsel = opsel;
       new_instr = static_cast<Instruction*>(vop3);
    } else {
-      new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
+      new_instr = create_instruction<VALU_instruction>(new_op, Format::VOPC, 2, 1);
    }
    new_instr->operands[0] = copy_operand(ctx, Operand(op[0]));
    new_instr->operands[1] = copy_operand(ctx, Operand(op[1]));
@@ -2365,9 +2365,9 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    aco_opcode new_op = is_or ? get_unordered(cmp->opcode) : get_ordered(cmp->opcode);
    Instruction* new_instr;
    if (cmp->isVOP3()) {
-      VOP3_instruction* new_vop3 =
-         create_instruction<VOP3_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
-      VOP3_instruction& cmp_vop3 = cmp->vop3();
+      VALU_instruction* new_vop3 =
+         create_instruction<VALU_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
+      VALU_instruction& cmp_vop3 = cmp->valu();
       memcpy(new_vop3->abs, cmp_vop3.abs, sizeof(new_vop3->abs));
       memcpy(new_vop3->neg, cmp_vop3.neg, sizeof(new_vop3->neg));
       new_vop3->clamp = cmp_vop3.clamp;
@@ -2375,7 +2375,7 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       new_vop3->opsel = cmp_vop3.opsel;
       new_instr = new_vop3;
    } else {
-      new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
+      new_instr = create_instruction<VALU_instruction>(new_op, Format::VOPC, 2, 1);
    }
    new_instr->operands[0] = copy_operand(ctx, cmp->operands[0]);
    new_instr->operands[1] = copy_operand(ctx, cmp->operands[1]);
@@ -2540,7 +2540,7 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       return false;
 
    if (nan_test->isVOP3()) {
-      VOP3_instruction& vop3 = nan_test->vop3();
+      VALU_instruction& vop3 = nan_test->valu();
       if (vop3.neg[0] != vop3.neg[1] || vop3.abs[0] != vop3.abs[1] || vop3.opsel == 1 ||
           vop3.opsel == 2)
          return false;
@@ -2566,9 +2566,9 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    aco_opcode new_op = is_or ? get_unordered(cmp->opcode) : get_ordered(cmp->opcode);
    Instruction* new_instr;
    if (cmp->isVOP3()) {
-      VOP3_instruction* new_vop3 =
-         create_instruction<VOP3_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
-      VOP3_instruction& cmp_vop3 = cmp->vop3();
+      VALU_instruction* new_vop3 =
+         create_instruction<VALU_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
+      VALU_instruction& cmp_vop3 = cmp->valu();
       memcpy(new_vop3->abs, cmp_vop3.abs, sizeof(new_vop3->abs));
       memcpy(new_vop3->neg, cmp_vop3.neg, sizeof(new_vop3->neg));
       new_vop3->clamp = cmp_vop3.clamp;
@@ -2576,7 +2576,7 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       new_vop3->opsel = cmp_vop3.opsel;
       new_instr = new_vop3;
    } else {
-      new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
+      new_instr = create_instruction<VALU_instruction>(new_op, Format::VOPC, 2, 1);
    }
    new_instr->operands[0] = copy_operand(ctx, cmp->operands[0]);
    new_instr->operands[1] = copy_operand(ctx, cmp->operands[1]);
@@ -2635,8 +2635,8 @@ match_op3_for_vop3(opt_ctx& ctx, aco_opcode op1, aco_opcode op2, Instruction* op
    if (!op2_instr || op2_instr->opcode != op2)
       return false;
 
-   VOP3_instruction* op1_vop3 = op1_instr->isVOP3() ? &op1_instr->vop3() : NULL;
-   VOP3_instruction* op2_vop3 = op2_instr->isVOP3() ? &op2_instr->vop3() : NULL;
+   VALU_instruction* op1_vop3 = op1_instr->isVOP3() ? &op1_instr->valu() : NULL;
+   VALU_instruction* op2_vop3 = op2_instr->isVOP3() ? &op2_instr->valu() : NULL;
 
    if (op1_instr->isSDWA() || op2_instr->isSDWA())
       return false;
@@ -2699,7 +2699,7 @@ create_vop3_for_op3(opt_ctx& ctx, aco_opcode opcode, aco_ptr<Instruction>& instr
                     Operand operands[3], bool neg[3], bool abs[3], uint8_t opsel, bool clamp,
                     unsigned omod)
 {
-   VOP3_instruction* new_instr = create_instruction<VOP3_instruction>(opcode, Format::VOP3, 3, 1);
+   VALU_instruction* new_instr = create_instruction<VALU_instruction>(opcode, Format::VOP3, 3, 1);
    memcpy(new_instr->abs, abs, sizeof(bool[3]));
    memcpy(new_instr->neg, neg, sizeof(bool[3]));
    new_instr->clamp = clamp;
@@ -2795,7 +2795,7 @@ combine_add_or_then_and_lshl(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       uint8_t opsel = 0, omod = 0;
       bool clamp = false;
       if (instr->isVOP3())
-         clamp = instr->vop3().clamp;
+         clamp = instr->valu().clamp;
 
       ctx.uses[instr->operands[i].tempId()]--;
       create_vop3_for_op3(ctx, op, instr, operands, neg, abs, opsel, clamp, omod);
@@ -3164,11 +3164,11 @@ combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op
          aco_ptr<Instruction> new_instr;
          if (instr->operands[!i].isTemp() &&
              instr->operands[!i].getTemp().type() == RegType::vgpr) {
-            new_instr.reset(create_instruction<VOP2_instruction>(new_op, Format::VOP2, 3, 2));
+            new_instr.reset(create_instruction<VALU_instruction>(new_op, Format::VOP2, 3, 2));
          } else if (ctx.program->gfx_level >= GFX10 ||
                     (instr->operands[!i].isConstant() && !instr->operands[!i].isLiteral())) {
             new_instr.reset(
-               create_instruction<VOP3_instruction>(new_op, asVOP3(Format::VOP2), 3, 2));
+               create_instruction<VALU_instruction>(new_op, asVOP3(Format::VOP2), 3, 2));
          } else {
             return false;
          }
@@ -3209,7 +3209,7 @@ combine_add_bcnt(opt_ctx& ctx, aco_ptr<Instruction>& instr)
           op_instr->operands[0].getTemp().type() == RegType::vgpr &&
           op_instr->operands[1].constantEquals(0)) {
          aco_ptr<Instruction> new_instr{
-            create_instruction<VOP3_instruction>(aco_opcode::v_bcnt_u32_b32, Format::VOP3, 2, 1)};
+            create_instruction<VALU_instruction>(aco_opcode::v_bcnt_u32_b32, Format::VOP3, 2, 1)};
          ctx.uses[instr->operands[i].tempId()]--;
          new_instr->operands[0] = op_instr->operands[0];
          new_instr->operands[1] = instr->operands[!i];
@@ -3669,10 +3669,10 @@ combine_and_subbrev(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          if (instr->operands[!i].isTemp() &&
              instr->operands[!i].getTemp().type() == RegType::vgpr) {
             new_instr.reset(
-               create_instruction<VOP2_instruction>(aco_opcode::v_cndmask_b32, Format::VOP2, 3, 1));
+               create_instruction<VALU_instruction>(aco_opcode::v_cndmask_b32, Format::VOP2, 3, 1));
          } else if (ctx.program->gfx_level >= GFX10 ||
                     (instr->operands[!i].isConstant() && !instr->operands[!i].isLiteral())) {
-            new_instr.reset(create_instruction<VOP3_instruction>(aco_opcode::v_cndmask_b32,
+            new_instr.reset(create_instruction<VALU_instruction>(aco_opcode::v_cndmask_b32,
                                                                  asVOP3(Format::VOP2), 3, 1));
          } else {
             return false;
@@ -3744,8 +3744,8 @@ combine_add_lshl(opt_ctx& ctx, aco_ptr<Instruction>& instr, bool is_sub)
          ctx.uses[instr->operands[i].tempId()]--;
 
          aco_opcode mad_op = is_sub ? aco_opcode::v_mad_i32_i24 : aco_opcode::v_mad_u32_u24;
-         aco_ptr<VOP3_instruction> new_instr{
-            create_instruction<VOP3_instruction>(mad_op, Format::VOP3, 3, 1)};
+         aco_ptr<VALU_instruction> new_instr{
+            create_instruction<VALU_instruction>(mad_op, Format::VOP3, 3, 1)};
          for (unsigned op_idx = 0; op_idx < 3; ++op_idx)
             new_instr->operands[op_idx] = ops[op_idx];
          new_instr->definitions[0] = instr->definitions[0];
@@ -3759,7 +3759,7 @@ combine_add_lshl(opt_ctx& ctx, aco_ptr<Instruction>& instr, bool is_sub)
 }
 
 void
-propagate_swizzles(VOP3P_instruction* instr, uint8_t opsel_lo, uint8_t opsel_hi)
+propagate_swizzles(VALU_instruction* instr, uint8_t opsel_lo, uint8_t opsel_hi)
 {
    /* propagate swizzles which apply to a result down to the instruction's operands:
     * result = a.xy + b.xx -> result.yx = a.yx + b.xx */
@@ -3784,7 +3784,7 @@ propagate_swizzles(VOP3P_instruction* instr, uint8_t opsel_lo, uint8_t opsel_hi)
 void
 combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
-   VOP3P_instruction* vop3p = &instr->vop3p();
+   VALU_instruction* vop3p = &instr->valu();
 
    /* apply clamp */
    if (instr->opcode == aco_opcode::v_pk_mul_f16 && instr->operands[1].constantEquals(0x3C00) &&
@@ -3793,7 +3793,7 @@ combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
       ssa_info& info = ctx.info[instr->operands[0].tempId()];
       if (info.is_vop3p() && instr_info.can_use_output_modifiers[(int)info.instr->opcode]) {
-         VOP3P_instruction* candidate = &ctx.info[instr->operands[0].tempId()].instr->vop3p();
+         VALU_instruction* candidate = &ctx.info[instr->operands[0].tempId()].instr->valu();
          candidate->clamp = true;
          propagate_swizzles(candidate, vop3p->opsel_lo, vop3p->opsel_hi);
          instr->definitions[0].swapTemp(candidate->definitions[0]);
@@ -3814,7 +3814,7 @@ combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          if (info.is_vop3p() && info.instr->opcode == aco_opcode::v_pk_mul_f16 &&
              info.instr->operands[1].constantEquals(0x3C00)) {
 
-            VOP3P_instruction* fneg = &info.instr->vop3p();
+            VALU_instruction* fneg = &info.instr->valu();
 
             if ((fneg->opsel_lo | fneg->opsel_hi) & 2)
                continue;
@@ -3878,7 +3878,7 @@ combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             continue;
 
          /* no clamp allowed between mul and add */
-         if (info.instr->vop3p().clamp)
+         if (info.instr->valu().clamp)
             continue;
 
          mul_instr = info.instr;
@@ -3904,9 +3904,8 @@ combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       /* turn packed mul+add into v_pk_fma_f16 */
       assert(mul_instr->isVOP3P());
       aco_opcode mad = fadd ? aco_opcode::v_pk_fma_f16 : aco_opcode::v_pk_mad_u16;
-      aco_ptr<VOP3P_instruction> fma{
-         create_instruction<VOP3P_instruction>(mad, Format::VOP3P, 3, 1)};
-      VOP3P_instruction* mul = &mul_instr->vop3p();
+      aco_ptr<VALU_instruction> fma{create_instruction<VALU_instruction>(mad, Format::VOP3P, 3, 1)};
+      VALU_instruction* mul = &mul_instr->valu();
       for (unsigned i = 0; i < 2; i++) {
          fma->operands[i] = op[i];
          fma->neg_lo[i] = mul->neg_lo[i];
@@ -3956,7 +3955,7 @@ can_use_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       return false;
 
    if (instr->isVOP3())
-      return !instr->vop3().omod && !(instr->vop3().opsel & 0x8);
+      return !instr->valu().omod && !(instr->valu().opsel & 0x8);
 
    return instr->format == Format::VOP2;
 }
@@ -3966,10 +3965,10 @@ to_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
    bool is_add = instr->opcode != aco_opcode::v_mul_f32 && instr->opcode != aco_opcode::v_fma_f32;
 
-   aco_ptr<VOP3P_instruction> vop3p{
-      create_instruction<VOP3P_instruction>(aco_opcode::v_fma_mix_f32, Format::VOP3P, 3, 1)};
+   aco_ptr<VALU_instruction> vop3p{
+      create_instruction<VALU_instruction>(aco_opcode::v_fma_mix_f32, Format::VOP3P, 3, 1)};
 
-   vop3p->opsel_lo = instr->isVOP3() ? ((instr->vop3().opsel & 0x7) << (is_add ? 1 : 0)) : 0x0;
+   vop3p->opsel_lo = instr->isVOP3() ? ((instr->valu().opsel & 0x7) << (is_add ? 1 : 0)) : 0x0;
    vop3p->opsel_hi = 0x0;
    for (unsigned i = 0; i < instr->operands.size(); i++) {
       vop3p->operands[is_add + i] = instr->operands[i];
@@ -3990,7 +3989,7 @@ to_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          vop3p->neg_lo[1] ^= true;
    }
    vop3p->definitions[0] = instr->definitions[0];
-   vop3p->clamp = instr->isVOP3() && instr->vop3().clamp;
+   vop3p->clamp = instr->isVOP3() && instr->valu().clamp;
    instr = std::move(vop3p);
 
    ctx.info[instr->definitions[0].tempId()].label &= label_f2f16 | label_clamp | label_mul;
@@ -4045,7 +4044,7 @@ combine_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (conv->isSDWA() && (conv->sdwa().dst_sel.size() != 4 || conv->sdwa().sel[0].size() != 2 ||
                              conv->sdwa().clamp || conv->sdwa().omod)) {
          continue;
-      } else if (conv->isVOP3() && (conv->vop3().clamp || conv->vop3().omod)) {
+      } else if (conv->isVOP3() && (conv->valu().clamp || conv->valu().omod)) {
          continue;
       } else if (conv->isDPP()) {
          continue;
@@ -4075,14 +4074,14 @@ combine_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       instr->operands[i].setTemp(conv->operands[0].getTemp());
       if (conv->definitions[0].isPrecise())
          instr->definitions[0].setPrecise(true);
-      instr->vop3p().opsel_hi ^= 1u << i;
+      instr->valu().opsel_hi ^= 1u << i;
       if (conv->isSDWA() && conv->sdwa().sel[0].offset() == 2)
-         instr->vop3p().opsel_lo |= 1u << i;
+         instr->valu().opsel_lo |= 1u << i;
       bool neg = conv->valu().neg[0];
       bool abs = conv->valu().abs[0];
-      if (!instr->vop3p().abs[i]) {
-         instr->vop3p().neg[i] ^= neg;
-         instr->vop3p().abs[i] = abs;
+      if (!instr->valu().abs[i]) {
+         instr->valu().neg[i] ^= neg;
+         instr->valu().abs[i] = abs;
       }
    }
 }
@@ -4205,7 +4204,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
       if (mul_instr->operands[0].isLiteral())
          return;
-      if (mul_instr->isVOP3() && mul_instr->vop3().clamp)
+      if (mul_instr->isVOP3() && mul_instr->valu().clamp)
          return;
       if (mul_instr->isSDWA() || mul_instr->isDPP() || mul_instr->isVOP3P())
          return;
@@ -4221,13 +4220,13 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       bool is_neg = ctx.info[instr->definitions[0].tempId()].is_neg();
       bool is_abs = ctx.info[instr->definitions[0].tempId()].is_abs();
       instr.reset(
-         create_instruction<VOP3_instruction>(mul_instr->opcode, asVOP3(Format::VOP2), 2, 1));
+         create_instruction<VALU_instruction>(mul_instr->opcode, asVOP3(Format::VOP2), 2, 1));
       instr->operands[0] = mul_instr->operands[0];
       instr->operands[1] = mul_instr->operands[1];
       instr->definitions[0] = def;
-      VOP3_instruction& new_mul = instr->vop3();
+      VALU_instruction& new_mul = instr->valu();
       if (mul_instr->isVOP3()) {
-         VOP3_instruction& mul = mul_instr->vop3();
+         VALU_instruction& mul = mul_instr->valu();
          new_mul.neg[0] = mul.neg[0];
          new_mul.neg[1] = mul.neg[1];
          new_mul.abs[0] = mul.abs[0];
@@ -4249,10 +4248,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    bool is_add_mix =
       (instr->opcode == aco_opcode::v_fma_mix_f32 ||
        instr->opcode == aco_opcode::v_fma_mixlo_f16) &&
-      !instr->vop3p().neg_lo[0] &&
-      ((instr->operands[0].constantEquals(0x3f800000) && (instr->vop3p().opsel_hi & 0x1) == 0) ||
-       (instr->operands[0].constantEquals(0x3C00) && (instr->vop3p().opsel_hi & 0x1) &&
-        !(instr->vop3p().opsel_lo & 0x1)));
+      !instr->valu().neg_lo[0] &&
+      ((instr->operands[0].constantEquals(0x3f800000) && (instr->valu().opsel_hi & 0x1) == 0) ||
+       (instr->operands[0].constantEquals(0x3C00) && (instr->valu().opsel_hi & 0x1) &&
+        !(instr->valu().opsel_lo & 0x1)));
    bool mad32 = instr->opcode == aco_opcode::v_add_f32 || instr->opcode == aco_opcode::v_sub_f32 ||
                 instr->opcode == aco_opcode::v_subrev_f32;
    bool mad16 = instr->opcode == aco_opcode::v_add_f16 || instr->opcode == aco_opcode::v_sub_f16 ||
@@ -4270,12 +4269,12 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          ssa_info& info = ctx.info[instr->operands[i].tempId()];
 
          /* no clamp/omod allowed between mul and add */
-         if (info.instr->isVOP3() && (info.instr->vop3().clamp || info.instr->vop3().omod))
+         if (info.instr->isVOP3() && (info.instr->valu().clamp || info.instr->valu().omod))
             continue;
-         if (info.instr->isVOP3P() && info.instr->vop3p().clamp)
+         if (info.instr->isVOP3P() && info.instr->valu().clamp)
             continue;
          /* v_fma_mix_f32/etc can't do omod */
-         if (info.instr->isVOP3P() && instr->isVOP3() && instr->vop3().omod)
+         if (info.instr->isVOP3P() && instr->isVOP3() && instr->valu().omod)
             continue;
          /* don't promote fp16 to fp32 or remove fp32->fp16->fp32 conversions */
          if (is_add_mix && info.instr->definitions[0].bytes() == 2)
@@ -4388,7 +4387,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
             aco_opcode mad_op = add_instr->definitions[0].bytes() == 2 ? aco_opcode::v_fma_mixlo_f16
                                                                        : aco_opcode::v_fma_mix_f32;
-            mad.reset(create_instruction<VOP3P_instruction>(mad_op, Format::VOP3P, 3, 1));
+            mad.reset(create_instruction<VALU_instruction>(mad_op, Format::VOP3P, 3, 1));
          } else {
             assert(!opsel_lo);
             assert(!opsel_hi);
@@ -4406,7 +4405,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                mad_op = aco_opcode::v_fma_f64;
             }
 
-            mad.reset(create_instruction<VOP3_instruction>(mad_op, Format::VOP3, 3, 1));
+            mad.reset(create_instruction<VALU_instruction>(mad_op, Format::VOP3, 3, 1));
          }
 
          for (unsigned i = 0; i < 3; i++) {
@@ -4442,8 +4441,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             ctx.uses[instr->operands[i].tempId()]--;
             ctx.uses[ctx.info[instr->operands[i].tempId()].temp.id()]++;
 
-            aco_ptr<VOP2_instruction> new_instr{
-               create_instruction<VOP2_instruction>(aco_opcode::v_cndmask_b32, Format::VOP2, 3, 1)};
+            aco_ptr<VALU_instruction> new_instr{
+               create_instruction<VALU_instruction>(aco_opcode::v_cndmask_b32, Format::VOP2, 3, 1)};
             new_instr->operands[0] = Operand::zero();
             new_instr->operands[1] = instr->operands[!i];
             new_instr->operands[2] = Operand(ctx.info[instr->operands[i].tempId()].temp);
@@ -4767,7 +4766,7 @@ select_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
          if ((instr->opcode == aco_opcode::v_fma_f32 ||
               (instr->opcode == aco_opcode::v_mad_f32 && !instr->definitions[0].isPrecise())) &&
-             !instr->vop3().omod && ctx.program->gfx_level >= GFX10 &&
+             !instr->valu().omod && ctx.program->gfx_level >= GFX10 &&
              util_bitcount(fp16_mask) > std::max<uint32_t>(util_bitcount(literal_mask), 1)) {
             assert(ctx.program->dev.fused_mad_mix);
             u_foreach_bit (i, fp16_mask)
@@ -5091,7 +5090,7 @@ unswizzle_vop3p_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (instr->opcode != aco_opcode::v_pk_fma_f16)
       return;
 
-   VOP3P_instruction& vop3p = instr->vop3p();
+   VALU_instruction& vop3p = instr->valu();
 
    unsigned literal_swizzle = ~0u;
    for (unsigned i = 0; i < instr->operands.size(); i++) {
@@ -5135,21 +5134,21 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
       if (has_dead_literal && info->fp16_mask) {
          aco_ptr<Instruction> fma_mix(
-            create_instruction<VOP3P_instruction>(aco_opcode::v_fma_mix_f32, Format::VOP3P, 3, 1));
+            create_instruction<VALU_instruction>(aco_opcode::v_fma_mix_f32, Format::VOP3P, 3, 1));
 
-         fma_mix->vop3p().clamp = instr->vop3().clamp;
-         std::copy(std::cbegin(instr->vop3().abs), std::cend(instr->vop3().abs),
-                   std::begin(fma_mix->vop3p().neg_hi));
-         std::copy(std::cbegin(instr->vop3().neg), std::cend(instr->vop3().neg),
-                   std::begin(fma_mix->vop3p().neg_lo));
+         fma_mix->valu().clamp = instr->valu().clamp;
+         std::copy(std::cbegin(instr->valu().abs), std::cend(instr->valu().abs),
+                   std::begin(fma_mix->valu().neg_hi));
+         std::copy(std::cbegin(instr->valu().neg), std::cend(instr->valu().neg),
+                   std::begin(fma_mix->valu().neg_lo));
 
          uint32_t literal = 0;
          bool second = false;
          u_foreach_bit (i, info->fp16_mask) {
             float value = uif(ctx.info[instr->operands[i].tempId()].val);
             literal |= _mesa_float_to_half(value) << (second * 16);
-            fma_mix->vop3p().opsel_lo |= second << i;
-            fma_mix->vop3p().opsel_hi |= 1 << i;
+            fma_mix->valu().opsel_lo |= second << i;
+            fma_mix->valu().opsel_hi |= 1 << i;
             second = true;
          }
 
@@ -5178,7 +5177,7 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             new_op = madak ? aco_opcode::v_fmaak_f16 : aco_opcode::v_fmamk_f16;
 
          uint32_t literal = ctx.info[instr->operands[ffs(info->literal_mask) - 1].tempId()].val;
-         new_mad.reset(create_instruction<VOP2_instruction>(new_op, Format::VOP2, 3, 1));
+         new_mad.reset(create_instruction<VALU_instruction>(new_op, Format::VOP2, 3, 1));
          for (unsigned i = 0; i < 3; i++) {
             if (info->literal_mask & (1 << i))
                new_mad->operands[i] = Operand::literal32(literal);
diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index 74fb7e58c254..623538bbfb8a 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -749,7 +749,7 @@ aco_print_instr(enum amd_gfx_level gfx_level, const Instruction* instr, FILE* ou
             opsel[i] = valu.opsel & (1 << i);
          }
       } else if (instr->isVOP3P() && is_mad_mix) {
-         const VOP3P_instruction& vop3p = instr->vop3p();
+         const VALU_instruction& vop3p = instr->valu();
          for (unsigned i = 0; i < MIN2(num_operands, 3); ++i) {
             abs[i] = vop3p.neg_hi[i];
             neg[i] = vop3p.neg_lo[i];
@@ -778,7 +778,7 @@ aco_print_instr(enum amd_gfx_level gfx_level, const Instruction* instr, FILE* ou
             fprintf(output, "|");
 
          if (instr->isVOP3P() && !is_mad_mix) {
-            const VOP3P_instruction& vop3 = instr->vop3p();
+            const VALU_instruction& vop3 = instr->valu();
             if ((vop3.opsel_lo & (1 << i)) || !(vop3.opsel_hi & (1 << i))) {
                fprintf(output, ".%c%c", vop3.opsel_lo & (1 << i) ? 'y' : 'x',
                        vop3.opsel_hi & (1 << i) ? 'y' : 'x');
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 5a7adb3460be..af055abc9461 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -543,7 +543,7 @@ add_subdword_operand(ra_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, uns
       /* check if we can use opsel */
       if (instr->format == Format::VOP3) {
          assert(byte == 2);
-         instr->vop3().opsel |= 1 << idx;
+         instr->valu().opsel |= 1 << idx;
          return;
       }
       if (instr->isVINTERP_INREG()) {
@@ -552,9 +552,9 @@ add_subdword_operand(ra_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, uns
          return;
       }
       if (instr->isVOP3P()) {
-         assert(byte == 2 && !(instr->vop3p().opsel_lo & (1 << idx)));
-         instr->vop3p().opsel_lo |= 1 << idx;
-         instr->vop3p().opsel_hi |= 1 << idx;
+         assert(byte == 2 && !(instr->valu().opsel_lo & (1 << idx)));
+         instr->valu().opsel_lo |= 1 << idx;
+         instr->valu().opsel_hi |= 1 << idx;
          return;
       }
       if (instr->opcode == aco_opcode::v_cvt_f32_ubyte0) {
@@ -695,7 +695,7 @@ add_subdword_definition(Program* program, aco_ptr<Instruction>& instr, PhysReg r
       if (instr->format == Format::VOP3) {
          assert(reg.byte() == 2);
          assert(can_use_opsel(gfx_level, instr->opcode, -1));
-         instr->vop3().opsel |= (1 << 3); /* dst in high half */
+         instr->valu().opsel |= (1 << 3); /* dst in high half */
          return;
       } else if (instr->isVINTERP_INREG()) {
          assert(reg.byte() == 2);
@@ -2632,10 +2632,6 @@ optimize_encoding_vop2(Program* program, ra_ctx& ctx, RegisterFile& register_fil
          return;
    }
 
-   static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3_instruction),
-                 "Invalid direct instruction cast.");
-   static_assert(sizeof(VOP2_instruction) <= sizeof(VOP3P_instruction),
-                 "Invalid direct instruction cast.");
    instr->format = Format::VOP2;
    instr->valu().opsel_hi = 0;
    switch (instr->opcode) {
@@ -3120,7 +3116,7 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
                   mov.reset(create_instruction<SOP1_instruction>(aco_opcode::s_mov_b32,
                                                                  Format::SOP1, 1, 1));
                else
-                  mov.reset(create_instruction<VOP1_instruction>(aco_opcode::v_mov_b32,
+                  mov.reset(create_instruction<VALU_instruction>(aco_opcode::v_mov_b32,
                                                                  Format::VOP1, 1, 1));
                mov->operands[0] = instr->operands[0];
                mov->definitions[0] = Definition(tmp);
@@ -3136,7 +3132,7 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
             /* change the instruction to VOP3 to enable an arbitrary register pair as dst */
             aco_ptr<Instruction> tmp = std::move(instr);
             Format format = asVOP3(tmp->format);
-            instr.reset(create_instruction<VOP3_instruction>(
+            instr.reset(create_instruction<VALU_instruction>(
                tmp->opcode, format, tmp->operands.size(), tmp->definitions.size()));
             std::copy(tmp->operands.begin(), tmp->operands.end(), instr->operands.begin());
             std::copy(tmp->definitions.begin(), tmp->definitions.end(), instr->definitions.begin());
diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 52e0d3685890..f6fac869e55a 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -326,7 +326,7 @@ do_reload(spill_ctx& ctx, Temp tmp, Temp new_name, uint32_t spill_id)
 
       aco_ptr<Instruction> res;
       if (instr->isVOP1()) {
-         res.reset(create_instruction<VOP1_instruction>(
+         res.reset(create_instruction<VALU_instruction>(
             instr->opcode, instr->format, instr->operands.size(), instr->definitions.size()));
       } else if (instr->isSOP1()) {
          res.reset(create_instruction<SOP1_instruction>(
diff --git a/src/amd/compiler/aco_ssa_elimination.cpp b/src/amd/compiler/aco_ssa_elimination.cpp
index 9a1a3dcf590b..3ec17f8abdea 100644
--- a/src/amd/compiler/aco_ssa_elimination.cpp
+++ b/src/amd/compiler/aco_ssa_elimination.cpp
@@ -461,21 +461,21 @@ try_optimize_branching_sequence(ssa_elimination_ctx& ctx, Block& block, const in
             return;
          } else if (!exec_val->isVOP3()) {
             aco_ptr<Instruction> tmp = std::move(exec_val);
-            exec_val.reset(create_instruction<VOPC_instruction>(
+            exec_val.reset(create_instruction<VALU_instruction>(
                tmp->opcode, tmp->format, tmp->operands.size(), tmp->definitions.size() + 1));
             std::copy(tmp->operands.cbegin(), tmp->operands.cend(), exec_val->operands.begin());
             std::copy(tmp->definitions.cbegin(), tmp->definitions.cend(),
                       exec_val->definitions.begin());
          } else {
             aco_ptr<Instruction> tmp = std::move(exec_val);
-            exec_val.reset(create_instruction<VOP3_instruction>(
+            exec_val.reset(create_instruction<VALU_instruction>(
                tmp->opcode, tmp->format, tmp->operands.size(), tmp->definitions.size() + 1));
             std::copy(tmp->operands.cbegin(), tmp->operands.cend(), exec_val->operands.begin());
             std::copy(tmp->definitions.cbegin(), tmp->definitions.cend(),
                       exec_val->definitions.begin());
 
-            VOP3_instruction& src = tmp->vop3();
-            VOP3_instruction& dst = exec_val->vop3();
+            VALU_instruction& src = tmp->valu();
+            VALU_instruction& dst = exec_val->valu();
             dst.opsel = src.opsel;
             dst.omod = src.omod;
             dst.clamp = src.clamp;
diff --git a/src/amd/compiler/aco_validate.cpp b/src/amd/compiler/aco_validate.cpp
index 1b5ed3eaa425..996b49cd419e 100644
--- a/src/amd/compiler/aco_validate.cpp
+++ b/src/amd/compiler/aco_validate.cpp
@@ -224,7 +224,7 @@ validate_ir(Program* program)
 
          /* check opsel */
          if (instr->isVOP3()) {
-            VOP3_instruction& vop3 = instr->vop3();
+            VALU_instruction& vop3 = instr->valu();
             check(vop3.opsel == 0 || program->gfx_level >= GFX9, "Opsel is only supported on GFX9+",
                   instr.get());
 
@@ -244,7 +244,7 @@ validate_ir(Program* program)
                      (instr->opcode == aco_opcode::v_fma_mix_f32 ? v1 : v2b),
                   "v_fma_mix_f32/v_fma_mix_f16 must have v1/v2b definition", instr.get());
          } else if (instr->isVOP3P()) {
-            VOP3P_instruction& vop3p = instr->vop3p();
+            VALU_instruction& vop3p = instr->valu();
             for (unsigned i = 0; i < instr->operands.size(); i++) {
                if (instr->operands[i].hasRegClass() &&
                    instr->operands[i].regClass().is_subdword() && !instr->operands[i].isFixed())
@@ -866,8 +866,8 @@ validate_subdword_operand(amd_gfx_level gfx_level, const aco_ptr<Instruction>& i
       bool fma_mix = instr->opcode == aco_opcode::v_fma_mixlo_f16 ||
                      instr->opcode == aco_opcode::v_fma_mixhi_f16 ||
                      instr->opcode == aco_opcode::v_fma_mix_f32;
-      return ((instr->vop3p().opsel_lo >> index) & 1) == (byte >> 1) &&
-             ((instr->vop3p().opsel_hi >> index) & 1) == (fma_mix || (byte >> 1));
+      return ((instr->valu().opsel_lo >> index) & 1) == (byte >> 1) &&
+             ((instr->valu().opsel_hi >> index) & 1) == (fma_mix || (byte >> 1));
    }
    if (byte == 2 && can_use_opsel(gfx_level, instr->opcode, index))
       return true;
diff --git a/src/amd/compiler/tests/helpers.cpp b/src/amd/compiler/tests/helpers.cpp
index 85365a539422..68158abfa794 100644
--- a/src/amd/compiler/tests/helpers.cpp
+++ b/src/amd/compiler/tests/helpers.cpp
@@ -302,11 +302,11 @@ Temp fabs(Temp src, Builder b)
 {
    if (src.bytes() == 2) {
       Builder::Result res = b.vop2_e64(aco_opcode::v_mul_f16, b.def(v2b), Operand::c16(0x3c00), src);
-      res->vop3().abs[1] = true;
+      res->valu().abs[1] = true;
       return res;
    } else {
       Builder::Result res = b.vop2_e64(aco_opcode::v_mul_f32, b.def(v1), Operand::c32(0x3f800000u), src);
-      res->vop3().abs[1] = true;
+      res->valu().abs[1] = true;
       return res;
    }
 }
diff --git a/src/amd/compiler/tests/test_assembler.cpp b/src/amd/compiler/tests/test_assembler.cpp
index 8cc06f9596b1..82f903898de6 100644
--- a/src/amd/compiler/tests/test_assembler.cpp
+++ b/src/amd/compiler/tests/test_assembler.cpp
@@ -269,7 +269,8 @@ BEGIN_TEST(assembler.v_add3)
 
       //~gfx9>> v_add3_u32 v0, 0, 0, 0 ; d1ff0000 02010080
       //~gfx10>> v_add3_u32 v0, 0, 0, 0 ; d76d0000 02010080
-      aco_ptr<VOP3_instruction> add3{create_instruction<VOP3_instruction>(aco_opcode::v_add3_u32, Format::VOP3, 3, 1)};
+      aco_ptr<VALU_instruction> add3{
+         create_instruction<VALU_instruction>(aco_opcode::v_add3_u32, Format::VOP3, 3, 1)};
       add3->operands[0] = Operand::zero();
       add3->operands[1] = Operand::zero();
       add3->operands[2] = Operand::zero();
@@ -287,7 +288,8 @@ BEGIN_TEST(assembler.v_add3_clamp)
 
       //~gfx9>> integer addition + clamp ; d1ff8000 02010080
       //~gfx10>> integer addition + clamp ; d76d8000 02010080
-      aco_ptr<VOP3_instruction> add3{create_instruction<VOP3_instruction>(aco_opcode::v_add3_u32, Format::VOP3, 3, 1)};
+      aco_ptr<VALU_instruction> add3{
+         create_instruction<VALU_instruction>(aco_opcode::v_add3_u32, Format::VOP3, 3, 1)};
       add3->operands[0] = Operand::zero();
       add3->operands[1] = Operand::zero();
       add3->operands[2] = Operand::zero();
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 205c1ef65e7a..68730214a530 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -698,7 +698,7 @@ BEGIN_TEST(optimize.add3)
    //! v1: %res1 = v_add_u32 %a, %tmp1
    //! p_unit_test 1, %res1
    tmp = bld.vop2_e64(aco_opcode::v_add_u32, bld.def(v1), inputs[1], inputs[2]);
-   tmp->vop3().clamp = true;
+   tmp->valu().clamp = true;
    writeout(1, bld.vop2(aco_opcode::v_add_u32, bld.def(v1), inputs[0], tmp));
 
    //! v1: %tmp2 = v_add_u32 %b, %c
@@ -706,7 +706,7 @@ BEGIN_TEST(optimize.add3)
    //! p_unit_test 2, %res2
    tmp = bld.vop2(aco_opcode::v_add_u32, bld.def(v1), inputs[1], inputs[2]);
    tmp = bld.vop2_e64(aco_opcode::v_add_u32, bld.def(v1), inputs[0], tmp);
-   tmp->vop3().clamp = true;
+   tmp->valu().clamp = true;
    writeout(2, tmp);
 
    finish_opt_test();
@@ -1038,7 +1038,7 @@ BEGIN_TEST(optimizer.dpp)
    //! p_unit_test 4, %res4
    Temp tmp4 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1), a, dpp_row_mirror);
    auto res4 = bld.vop2_e64(aco_opcode::v_add_f32, bld.def(v1), tmp4, b);
-   res4->vop3().neg[0] = true;
+   res4->valu().neg[0] = true;
    writeout(4, res4);
 
    //! v1: %tmp5 = v_mov_b32 %a row_mirror bound_ctrl:1
@@ -1046,7 +1046,7 @@ BEGIN_TEST(optimizer.dpp)
    //! p_unit_test 5, %res5
    Temp tmp5 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1), a, dpp_row_mirror);
    auto res5 = bld.vop2_e64(aco_opcode::v_add_f32, bld.def(v1), tmp5, b);
-   res5->vop3().clamp = true;
+   res5->valu().clamp = true;
    writeout(5, res5);
 
    //! v1: %res6 = v_add_f32 |%a|, %b row_mirror bound_ctrl:1
@@ -1054,14 +1054,14 @@ BEGIN_TEST(optimizer.dpp)
    auto tmp6 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1), a, dpp_row_mirror);
    tmp6->dpp16().neg[0] = true;
    auto res6 = bld.vop2_e64(aco_opcode::v_add_f32, bld.def(v1), tmp6, b);
-   res6->vop3().abs[0] = true;
+   res6->valu().abs[0] = true;
    writeout(6, res6);
 
    //! v1: %res7 = v_subrev_f32 %a, |%b| row_mirror bound_ctrl:1
    //! p_unit_test 7, %res7
    Temp tmp7 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1), a, dpp_row_mirror);
    auto res7 = bld.vop2_e64(aco_opcode::v_sub_f32, bld.def(v1), b, tmp7);
-   res7->vop3().abs[0] = true;
+   res7->valu().abs[0] = true;
    writeout(7, res7);
 
    //! v1: %tmp11 = v_mov_b32 -%a row_mirror bound_ctrl:1
diff --git a/src/amd/compiler/tests/test_optimizer_postRA.cpp b/src/amd/compiler/tests/test_optimizer_postRA.cpp
index 066f74f7510d..d6cc3208ecbd 100644
--- a/src/amd/compiler/tests/test_optimizer_postRA.cpp
+++ b/src/amd/compiler/tests/test_optimizer_postRA.cpp
@@ -383,7 +383,7 @@ BEGIN_TEST(optimizer_postRA.dpp)
    //! p_unit_test 4, %res4:v[2]
    Temp tmp4 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1, reg_v2), a, dpp_row_mirror);
    auto res4 = bld.vop2_e64(aco_opcode::v_add_f32, bld.def(v1, reg_v2), Operand(tmp4, reg_v2), b);
-   res4->vop3().neg[0] = true;
+   res4->valu().neg[0] = true;
    writeout(4, Operand(res4, reg_v2));
 
    //! v1: %tmp5:v[2] = v_mov_b32 %a:v[0] row_mirror bound_ctrl:1
@@ -391,7 +391,7 @@ BEGIN_TEST(optimizer_postRA.dpp)
    //! p_unit_test 5, %res5:v[2]
    Temp tmp5 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1, reg_v2), a, dpp_row_mirror);
    auto res5 = bld.vop2_e64(aco_opcode::v_add_f32, bld.def(v1, reg_v2), Operand(tmp5, reg_v2), b);
-   res5->vop3().clamp = true;
+   res5->valu().clamp = true;
    writeout(5, Operand(res5, reg_v2));
 
    //! v1: %res6:v[2] = v_add_f32 |%a:v[0]|, %b:v[1] row_mirror bound_ctrl:1
@@ -399,14 +399,14 @@ BEGIN_TEST(optimizer_postRA.dpp)
    auto tmp6 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1, reg_v2), a, dpp_row_mirror);
    tmp6->dpp16().neg[0] = true;
    auto res6 = bld.vop2_e64(aco_opcode::v_add_f32, bld.def(v1, reg_v2), Operand(tmp6, reg_v2), b);
-   res6->vop3().abs[0] = true;
+   res6->valu().abs[0] = true;
    writeout(6, Operand(res6, reg_v2));
 
    //! v1: %res7:v[2] = v_subrev_f32 %a:v[0], |%b:v[1]| row_mirror bound_ctrl:1
    //! p_unit_test 7, %res7:v[2]
    Temp tmp7 = bld.vop1_dpp(aco_opcode::v_mov_b32, bld.def(v1, reg_v2), a, dpp_row_mirror);
    auto res7 = bld.vop2_e64(aco_opcode::v_sub_f32, bld.def(v1, reg_v2), b, Operand(tmp7, reg_v2));
-   res7->vop3().abs[0] = true;
+   res7->valu().abs[0] = true;
    writeout(7, Operand(res7, reg_v2));
 
    //! v1: %tmp12:v[2] = v_mov_b32 -%a:v[0] row_mirror bound_ctrl:1
diff --git a/src/amd/compiler/tests/test_sdwa.cpp b/src/amd/compiler/tests/test_sdwa.cpp
index 3942869e0d27..45f8c3e96c0c 100644
--- a/src/amd/compiler/tests/test_sdwa.cpp
+++ b/src/amd/compiler/tests/test_sdwa.cpp
@@ -385,7 +385,8 @@ BEGIN_TEST(optimize.sdwa.from_vop3)
       //! p_unit_test 0, %res0
       Temp byte0_b = bld.pseudo(aco_opcode::p_extract, bld.def(v1), inputs[1], Operand::zero(),
                                 Operand::c32(8u), Operand::zero());
-      VOP3_instruction *mul = &bld.vop2_e64(aco_opcode::v_mul_f32, bld.def(v1), inputs[0], byte0_b)->vop3();
+      VALU_instruction* mul =
+         &bld.vop2_e64(aco_opcode::v_mul_f32, bld.def(v1), inputs[0], byte0_b)->valu();
       mul->neg[0] = true;
       mul->abs[0] = true;
       writeout(0, mul->definitions[0].getTemp());
@@ -396,7 +397,7 @@ BEGIN_TEST(optimize.sdwa.from_vop3)
       //! p_unit_test 1, %res1
       byte0_b = bld.pseudo(aco_opcode::p_extract, bld.def(v1), inputs[1], Operand::zero(),
                            Operand::c32(8u), Operand::zero());
-      mul = &bld.vop2_e64(aco_opcode::v_mul_f32, bld.def(v1), inputs[0], byte0_b)->vop3();
+      mul = &bld.vop2_e64(aco_opcode::v_mul_f32, bld.def(v1), inputs[0], byte0_b)->valu();
       mul->omod = 2;
       writeout(1, mul->definitions[0].getTemp());
 
-- 
GitLab


From d1b1cddffc64df276ce880c4708e667cbbf87871 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 14 Feb 2023 16:39:20 +0100
Subject: [PATCH 8/9] aco: add bitfield array helper classes

---
 src/amd/compiler/aco_util.h | 431 ++++++++++++++++++++++++++++++++++++
 1 file changed, 431 insertions(+)

diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 71c783274023..08660bdc3e3f 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -27,6 +27,7 @@
 #define ACO_UTIL_H
 
 #include "util/bitscan.h"
+#include "util/macros.h"
 #include "util/u_math.h"
 
 #include <cassert>
@@ -34,6 +35,7 @@
 #include <functional>
 #include <iterator>
 #include <map>
+#include <type_traits>
 #include <unordered_map>
 #include <vector>
 
@@ -557,6 +559,435 @@ template <class Key, class T, class Hash = std::hash<Key>, class Pred = std::equ
 using unordered_map =
    std::unordered_map<Key, T, Hash, Pred, aco::monotonic_allocator<std::pair<const Key, T>>>;
 
+/*
+ * Helper class for a integer/bool (access_type) packed into
+ * a bigger integer (data_type) with an offset and size.
+ * It can be implicitly converted to access_type and supports
+ * all arithmetic assignment operators.
+ *
+ * When used together with a union, this allows storing
+ * multiple fields packed into a single integer.
+ *
+ * Example usage:
+ * union {
+ *    bitfield_uint<uint32_t, 0,  5,  uint8_t> int5;
+ *    bitfield_uint<uint32_t, 5,  26, uint32_t> int26;
+ *    bitfield_uint<uint32_t, 31, 1,  bool> bool1;
+ * };
+ *
+ */
+template <typename data_type, unsigned offset, unsigned size, typename access_type>
+class bitfield_uint {
+public:
+   static_assert(sizeof(data_type) >= sizeof(access_type), "");
+   static_assert(std::is_unsigned<access_type>::value, "");
+   static_assert(std::is_unsigned<data_type>::value, "");
+   static_assert(sizeof(data_type) * 8 >= offset + size, "");
+   static_assert(sizeof(access_type) * 8 >= size, "");
+   static_assert(size > 0, "");
+   static_assert(!std::is_same_v<access_type, bool> || size == 1, "");
+
+   bitfield_uint() = default;
+
+   constexpr bitfield_uint(const access_type& value) { *this = value; }
+
+   constexpr operator access_type() const { return (storage >> offset) & mask; }
+
+   constexpr bitfield_uint& operator=(const access_type& value)
+   {
+      storage &= ~(mask << offset);
+      storage |= data_type(value & mask) << offset;
+      return *this;
+   }
+
+   constexpr bitfield_uint& operator|=(const access_type& value)
+   {
+      storage |= data_type(value & mask) << offset;
+      return *this;
+   }
+
+   constexpr bitfield_uint& operator^=(const access_type& value)
+   {
+      storage ^= data_type(value & mask) << offset;
+      return *this;
+   }
+
+   constexpr bitfield_uint& operator&=(const access_type& value)
+   {
+      storage &= (data_type(value & mask) << offset) | ~(mask << offset);
+      return *this;
+   }
+
+   constexpr bitfield_uint& operator<<=(const access_type& shift)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      assert(shift < size);
+      return *this = access_type(*this) << shift;
+   }
+
+   constexpr bitfield_uint& operator>>=(const access_type& shift)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      assert(shift < size);
+      return *this = access_type(*this) >> shift;
+   }
+
+   constexpr bitfield_uint& operator*=(const access_type& op)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this = access_type(*this) * op;
+   }
+
+   constexpr bitfield_uint& operator/=(const access_type& op)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this = access_type(*this) / op;
+   }
+
+   constexpr bitfield_uint& operator%=(const access_type& op)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this = access_type(*this) % op;
+   }
+
+   constexpr bitfield_uint& operator+=(const access_type& op)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this = access_type(*this) + op;
+   }
+
+   constexpr bitfield_uint& operator-=(const access_type& op)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this = access_type(*this) - op;
+   }
+
+   constexpr bitfield_uint& operator++()
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this += 1;
+   }
+
+   constexpr access_type operator++(int)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      access_type temp = *this;
+      ++*this;
+      return temp;
+   }
+
+   constexpr bitfield_uint& operator--()
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      return *this -= 1;
+   }
+
+   constexpr access_type operator--(int)
+   {
+      static_assert(!std::is_same_v<access_type, bool>, "");
+      access_type temp = *this;
+      --*this;
+      return temp;
+   }
+
+   constexpr void swap(access_type& other)
+   {
+      access_type tmp = *this;
+      *this = other;
+      other = tmp;
+   }
+
+   template <typename other_dt, unsigned other_off, unsigned other_s>
+   constexpr void swap(bitfield_uint<other_dt, other_off, other_s, access_type>& other)
+   {
+      access_type tmp = *this;
+      *this = other;
+      other = tmp;
+   }
+
+protected:
+   static const data_type mask = BITFIELD64_MASK(size);
+
+   data_type storage;
+};
+
+/*
+ * Reference to a single bit in an integer that can be converted to a bool
+ * and supports bool (bitwise) assignment operators.
+ */
+template <typename T> struct bit_reference {
+   constexpr bit_reference(T& s, unsigned b) : storage(s), bit(b) {}
+
+   constexpr bit_reference& operator=(const bit_reference& other) { return *this = (bool)other; }
+
+   constexpr bit_reference& operator=(bool val)
+   {
+      storage &= ~(T(0x1) << bit);
+      storage |= T(val) << bit;
+      return *this;
+   }
+
+   constexpr bit_reference& operator^=(bool val)
+   {
+      storage ^= T(val) << bit;
+      return *this;
+   }
+
+   constexpr bit_reference& operator|=(bool val)
+   {
+      storage |= T(val) << bit;
+      return *this;
+   }
+
+   constexpr bit_reference& operator&=(bool val)
+   {
+      storage &= T(val) << bit;
+      return *this;
+   }
+
+   constexpr operator bool() const { return (storage >> bit) & 0x1; }
+
+   constexpr void swap(bool& other)
+   {
+      bool tmp = (bool)*this;
+      *this = other;
+      other = tmp;
+   }
+
+   template <typename other_T> constexpr void swap(bit_reference<other_T> other)
+   {
+      bool tmp = (bool)*this;
+      *this = (bool)other;
+      other = tmp;
+   }
+
+   T& storage;
+   unsigned bit;
+};
+
+/*
+ * Base template for (const) bit iterators over an integer.
+ * Only intended to be used with the two specializations
+ * bitfield_array::iterator and bitfield_array::const_iterator.
+ */
+template <typename T, typename refT, typename ptrT> struct bitfield_iterator {
+   using difference_type = int;
+   using value_type = bool;
+   using iterator_category = std::random_access_iterator_tag;
+   using reference = refT;
+   using const_reference = bool;
+   using pointer = ptrT;
+   using iterator = bitfield_iterator<T, refT, ptrT>;
+   using ncT = std::remove_const_t<T>;
+
+   constexpr bitfield_iterator() : bf(nullptr), index(0) {}
+   constexpr bitfield_iterator(T* p, unsigned i) : bf(p), index(i) {}
+
+   /* const iterator must be constructable from iterator */
+   constexpr bitfield_iterator(
+      const bitfield_iterator<ncT, bit_reference<ncT>, bit_reference<ncT>*>& x)
+       : bf(x.bf), index(x.index)
+   {}
+
+   constexpr bool operator==(const bitfield_iterator& other) const
+   {
+      return bf == other.bf && index == other.index;
+   }
+
+   constexpr bool operator<(const bitfield_iterator& other) const { return index < other.index; }
+
+   constexpr bool operator!=(const bitfield_iterator& other) const { return !(*this == other); }
+
+   constexpr bool operator>(const bitfield_iterator& other) const { return other < *this; }
+
+   constexpr bool operator<=(const bitfield_iterator& other) const { return !(other < *this); }
+
+   constexpr bool operator>=(const bitfield_iterator& other) const { return !(*this < other); }
+
+   constexpr reference operator*() const { return bit_reference<T>(*bf, index); }
+
+   constexpr iterator& operator++()
+   {
+      index++;
+      return *this;
+   }
+
+   constexpr iterator operator++(int)
+   {
+      iterator tmp = *this;
+      index++;
+      return tmp;
+   }
+
+   constexpr iterator& operator--()
+   {
+      index--;
+      return *this;
+   }
+
+   constexpr iterator operator--(int)
+   {
+      iterator tmp = *this;
+      index--;
+      return tmp;
+   }
+
+   constexpr iterator& operator+=(difference_type value)
+   {
+      index += value;
+      return *this;
+   }
+
+   constexpr iterator& operator-=(difference_type value)
+   {
+      *this += -value;
+      return *this;
+   }
+
+   constexpr iterator operator+(difference_type value) const
+   {
+      iterator tmp = *this;
+      return tmp += value;
+   }
+
+   constexpr iterator operator-(difference_type value) const
+   {
+      iterator tmp = *this;
+      return tmp -= value;
+   }
+
+   constexpr reference operator[](difference_type value) const { return *(*this + value); }
+
+   T* bf;
+   unsigned index;
+};
+
+template <typename T, typename refT, typename ptrT>
+constexpr inline bitfield_iterator<T, refT, ptrT>
+operator+(int n, const bitfield_iterator<T, refT, ptrT>& x)
+{
+   return x + n;
+}
+
+template <typename T, typename refT, typename ptrT>
+constexpr inline int
+operator-(const bitfield_iterator<T, refT, ptrT> x, const bitfield_iterator<T, refT, ptrT>& y)
+{
+   return x.index - y.index;
+}
+
+/*
+ * Extends bitfield_uint with operator[] and iterators that
+ * allow accessing single bits within the uint. Can be used
+ * as a more compact version of bool arrays that also still
+ * allows accessing the whole array as an integer.
+ */
+template <typename data_type, unsigned offset, unsigned size, typename access_type>
+class bitfield_array : public bitfield_uint<data_type, offset, size, access_type> {
+public:
+   using value_type = bool;
+   using size_type = unsigned;
+   using difference_type = int;
+   using reference = bit_reference<data_type>;
+   using const_reference = bool;
+   using pointer = bit_reference<data_type>*;
+   using const_pointer = const bool*;
+   using iterator =
+      bitfield_iterator<data_type, bit_reference<data_type>, bit_reference<data_type>*>;
+   using const_iterator = bitfield_iterator<const data_type, bool, const bool*>;
+   using reverse_iterator = std::reverse_iterator<iterator>;
+   using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+
+   bitfield_array() = default;
+
+   constexpr bitfield_array(const access_type& value) { *this = value; }
+
+   constexpr bitfield_array& operator=(const access_type& value)
+   {
+      storage &= ~(mask << offset);
+      storage |= data_type(value & mask) << offset;
+      return *this;
+   }
+
+   constexpr reference operator[](unsigned index)
+   {
+      assert(index < size);
+      return reference(storage, offset + index);
+   }
+
+   constexpr bool operator[](unsigned index) const
+   {
+      assert(index < size);
+      return (storage >> (offset + index)) & 0x1;
+   }
+
+   constexpr iterator begin() noexcept { return iterator(&storage, offset); }
+
+   constexpr const_iterator begin() const noexcept { return const_iterator(&storage, offset); }
+
+   constexpr iterator end() noexcept { return std::next(begin(), size); }
+
+   constexpr const_iterator end() const noexcept { return std::next(begin(), size); }
+
+   constexpr const_iterator cbegin() const noexcept { return begin(); }
+
+   constexpr const_iterator cend() const noexcept { return std::next(begin(), size); }
+
+   constexpr reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
+
+   constexpr const_reverse_iterator rbegin() const noexcept
+   {
+      return const_reverse_iterator(end());
+   }
+
+   constexpr reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
+
+   constexpr const_reverse_iterator rend() const noexcept
+   {
+      return const_reverse_iterator(begin());
+   }
+
+   constexpr const_reverse_iterator crbegin() const noexcept
+   {
+      return const_reverse_iterator(cend());
+   }
+
+   constexpr const_reverse_iterator crend() const noexcept
+   {
+      return const_reverse_iterator(cbegin());
+   }
+
+private:
+   using bitfield_uint<data_type, offset, size, access_type>::storage;
+   using bitfield_uint<data_type, offset, size, access_type>::mask;
+};
+
+template <typename T, unsigned offset> using bitfield_bool = bitfield_uint<T, offset, 1, bool>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_uint8 = bitfield_uint<T, offset, size, uint8_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_uint16 = bitfield_uint<T, offset, size, uint16_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_uint32 = bitfield_uint<T, offset, size, uint32_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_uint64 = bitfield_uint<T, offset, size, uint64_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_array8 = bitfield_array<T, offset, size, uint8_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_array16 = bitfield_array<T, offset, size, uint16_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_array32 = bitfield_array<T, offset, size, uint32_t>;
+
+template <typename T, unsigned offset, unsigned size>
+using bitfield_array64 = bitfield_array<T, offset, size, uint64_t>;
+
 } // namespace aco
 
 #endif // ACO_UTIL_H
-- 
GitLab


From 17603ebc3893b0b0ede3912c197fccda5124495d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 14 Feb 2023 16:47:40 +0100
Subject: [PATCH 9/9] aco: use bitfield array helpers for valu modifiers

---
 src/amd/compiler/aco_ir.cpp               |  8 +++----
 src/amd/compiler/aco_ir.h                 | 26 +++++++++++------------
 src/amd/compiler/aco_optimizer.cpp        | 26 +++++++++++------------
 src/amd/compiler/aco_optimizer_postRA.cpp |  4 ++--
 4 files changed, 31 insertions(+), 33 deletions(-)

diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index a657f4db4a9a..4ce91fae505f 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -304,8 +304,8 @@ convert_to_SDWA(amd_gfx_level gfx_level, aco_ptr<Instruction>& instr)
 
    if (tmp->isVOP3()) {
       VALU_instruction& vop3 = tmp->valu();
-      memcpy(sdwa.neg, vop3.neg, sizeof(sdwa.neg));
-      memcpy(sdwa.abs, vop3.abs, sizeof(sdwa.abs));
+      std::copy(std::cbegin(vop3.neg), std::cend(vop3.neg), std::begin(sdwa.neg));
+      std::copy(std::cbegin(vop3.abs), std::cend(vop3.abs), std::begin(sdwa.abs));
       sdwa.omod = vop3.omod;
       sdwa.clamp = vop3.clamp;
    }
@@ -406,8 +406,8 @@ convert_to_DPP(aco_ptr<Instruction>& instr, bool dpp8)
 
       if (tmp->isVOP3()) {
          const VALU_instruction* vop3 = &tmp->valu();
-         memcpy(dpp->neg, vop3->neg, sizeof(dpp->neg));
-         memcpy(dpp->abs, vop3->abs, sizeof(dpp->abs));
+         std::copy(std::cbegin(vop3->neg), std::cend(vop3->neg), std::begin(dpp->neg));
+         std::copy(std::cbegin(vop3->abs), std::cend(vop3->abs), std::begin(dpp->abs));
       }
    }
 
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index d4b81ce9a28c..6eda59892fa2 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1391,22 +1391,20 @@ static_assert(sizeof(SMEM_instruction) == sizeof(Instruction) + 4, "Unexpected p
 
 struct VALU_instruction : public Instruction {
    union {
-      bool neg[3];    /* VOP3, SDWA, DPP16, v_fma_mix, VINTERP_inreg */
-      bool neg_lo[3]; /* VOP3P */
-   };
-   union {
-      bool abs[3];    /* VOP3, SDWA, DPP16, v_fma_mix */
-      bool neg_hi[3]; /* VOP3P */
+      bitfield_array8<uint32_t, 0, 3> neg;    /* VOP3, SDWA, DPP16, v_fma_mix, VINTERP_inreg */
+      bitfield_array8<uint32_t, 0, 3> neg_lo; /* VOP3P */
+
+      bitfield_array8<uint32_t, 3, 3> abs;    /* VOP3, SDWA, DPP16, v_fma_mix */
+      bitfield_array8<uint32_t, 3, 3> neg_hi; /* VOP3P */
+
+      bitfield_array8<uint32_t, 6, 4> opsel;     /* VOP3, VOPC12(GFX11+), VINTERP_inreg */
+      bitfield_uint8<uint32_t, 10, 2> omod;      /* VOP3, SDWA(GFX9+) */
+      bitfield_array8<uint32_t, 12, 3> opsel_lo; /* VOP3P */
+      bitfield_array8<uint32_t, 15, 3> opsel_hi; /* VOP3P */
+      bitfield_bool<uint32_t, 18> clamp;         /* VOP3, VOP3P, SDWA, VINTERP_inreg */
    };
-   uint8_t opsel : 4; /* VOP3, VOPC12(GFX11+), VINTERP_inreg */
-   uint8_t omod : 2;  /* VOP3, SDWA(GFX9+) */
-   uint8_t padding0 : 2;
-   uint8_t opsel_lo : 3; /* VOP3P */
-   uint8_t opsel_hi : 3; /* VOP3P */
-   bool clamp : 1; /* VOP3, VOP3P, SDWA, VINTERP_inreg */
-   uint8_t padding1 : 1;
 };
-static_assert(sizeof(VALU_instruction) == sizeof(Instruction) + 8, "Unexpected padding");
+static_assert(sizeof(VALU_instruction) == sizeof(Instruction) + 4, "Unexpected padding");
 
 struct VINTERP_inreg_instruction : public VALU_instruction {
    uint8_t wait_exp : 3;
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index bafb55c073a9..d67fe93e65ed 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2368,8 +2368,8 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       VALU_instruction* new_vop3 =
          create_instruction<VALU_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
       VALU_instruction& cmp_vop3 = cmp->valu();
-      memcpy(new_vop3->abs, cmp_vop3.abs, sizeof(new_vop3->abs));
-      memcpy(new_vop3->neg, cmp_vop3.neg, sizeof(new_vop3->neg));
+      std::copy(std::cbegin(cmp_vop3.neg), std::cend(cmp_vop3.neg), std::begin(new_vop3->neg));
+      std::copy(std::cbegin(cmp_vop3.abs), std::cend(cmp_vop3.abs), std::begin(new_vop3->abs));
       new_vop3->clamp = cmp_vop3.clamp;
       new_vop3->omod = cmp_vop3.omod;
       new_vop3->opsel = cmp_vop3.opsel;
@@ -2569,8 +2569,8 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       VALU_instruction* new_vop3 =
          create_instruction<VALU_instruction>(new_op, asVOP3(Format::VOPC), 2, 1);
       VALU_instruction& cmp_vop3 = cmp->valu();
-      memcpy(new_vop3->abs, cmp_vop3.abs, sizeof(new_vop3->abs));
-      memcpy(new_vop3->neg, cmp_vop3.neg, sizeof(new_vop3->neg));
+      std::copy(std::cbegin(cmp_vop3.neg), std::cend(cmp_vop3.neg), std::begin(new_vop3->neg));
+      std::copy(std::cbegin(cmp_vop3.abs), std::cend(cmp_vop3.abs), std::begin(new_vop3->abs));
       new_vop3->clamp = cmp_vop3.clamp;
       new_vop3->omod = cmp_vop3.omod;
       new_vop3->opsel = cmp_vop3.opsel;
@@ -2648,8 +2648,8 @@ match_op3_for_vop3(opt_ctx& ctx, aco_opcode op1, aco_opcode op2, Instruction* op
       return false;
 
    /* get operands and modifiers and check inbetween modifiers */
-   *op1_clamp = op1_vop3 ? op1_vop3->clamp : false;
-   *op1_omod = op1_vop3 ? op1_vop3->omod : 0u;
+   *op1_clamp = op1_vop3 ? (bool)op1_vop3->clamp : false;
+   *op1_omod = op1_vop3 ? (unsigned)op1_vop3->omod : 0u;
 
    if (inbetween_neg)
       *inbetween_neg = op1_vop3 ? op1_vop3->neg[swap] : false;
@@ -2696,12 +2696,12 @@ match_op3_for_vop3(opt_ctx& ctx, aco_opcode op1, aco_opcode op2, Instruction* op
 
 void
 create_vop3_for_op3(opt_ctx& ctx, aco_opcode opcode, aco_ptr<Instruction>& instr,
-                    Operand operands[3], bool neg[3], bool abs[3], uint8_t opsel, bool clamp,
+                    Operand operands[3], bool (&neg)[3], bool (&abs)[3], uint8_t opsel, bool clamp,
                     unsigned omod)
 {
    VALU_instruction* new_instr = create_instruction<VALU_instruction>(opcode, Format::VOP3, 3, 1);
-   memcpy(new_instr->abs, abs, sizeof(bool[3]));
-   memcpy(new_instr->neg, neg, sizeof(bool[3]));
+   std::copy(std::cbegin(neg), std::cend(neg), std::begin(new_instr->neg));
+   std::copy(std::cbegin(abs), std::cend(abs), std::begin(new_instr->abs));
    new_instr->clamp = clamp;
    new_instr->omod = omod;
    new_instr->opsel = opsel;
@@ -3840,8 +3840,8 @@ combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             bool neg_hi = fneg->neg_hi[0] ^ fneg->neg_hi[1];
             vop3p->neg_lo[i] ^= opsel_lo ? neg_hi : neg_lo;
             vop3p->neg_hi[i] ^= opsel_hi ? neg_hi : neg_lo;
-            vop3p->opsel_lo ^= ((opsel_lo ? ~fneg->opsel_hi : fneg->opsel_lo) & 1) << i;
-            vop3p->opsel_hi ^= ((opsel_hi ? ~fneg->opsel_hi : fneg->opsel_lo) & 1) << i;
+            vop3p->opsel_lo ^= ((opsel_lo ? ~fneg->opsel_hi : (unsigned)fneg->opsel_lo) & 1) << i;
+            vop3p->opsel_hi ^= ((opsel_hi ? ~fneg->opsel_hi : (unsigned)fneg->opsel_lo) & 1) << i;
 
             if (--ctx.uses[fneg->definitions[0].tempId()])
                ctx.uses[fneg->operands[0].tempId()]++;
@@ -4882,8 +4882,8 @@ select_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             if (i) {
                instr->opcode = swapped_op;
                std::swap(instr->operands[0], instr->operands[1]);
-               std::swap(dpp->neg[0], dpp->neg[1]);
-               std::swap(dpp->abs[0], dpp->abs[1]);
+               dpp->neg[0].swap(dpp->neg[1]);
+               dpp->abs[0].swap(dpp->abs[1]);
             }
             dpp->dpp_ctrl = info.instr->dpp16().dpp_ctrl;
             dpp->bound_ctrl = info.instr->dpp16().bound_ctrl;
diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index b39af7bd5ae0..2555b8c01e03 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -535,8 +535,8 @@ try_combine_dpp(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
          DPP16_instruction* dpp = &instr->dpp16();
          if (i) {
             std::swap(dpp->operands[0], dpp->operands[1]);
-            std::swap(dpp->neg[0], dpp->neg[1]);
-            std::swap(dpp->abs[0], dpp->abs[1]);
+            dpp->neg[0].swap(dpp->neg[1]);
+            dpp->abs[0].swap(dpp->abs[1]);
          }
          dpp->operands[0] = mov->operands[0];
          dpp->dpp_ctrl = mov->dpp16().dpp_ctrl;
-- 
GitLab

