From b5f804800d51db9e46f17da70e594e75c3a77c15 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 17 Oct 2022 17:01:35 +0800
Subject: [PATCH 01/14] radeonsi: implement nir_load_ring_gsvs_amd

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 7eec50683458..b6a978e73b6d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -715,6 +715,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_ring_esgs_amd:
       return ctx->esgs_ring;
 
+   case nir_intrinsic_load_ring_gsvs_amd:
+      return ctx->gsvs_ring[nir_intrinsic_stream_id(intrin)];
+
    case nir_intrinsic_load_lds_ngg_scratch_base_amd:
       return LLVMBuildPtrToInt(ctx->ac.builder, ctx->gs_ngg_scratch.value, ctx->ac.i32, "");
 
-- 
GitLab


From 310f43f22de5fa3814693ce65b927e1f40aaadd3 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 1 Dec 2022 09:27:26 +0800
Subject: [PATCH 02/14] radeonsi: implement nir_load_ring_gs2vs_offset_amd

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_nir_lower_abi.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 146b9041fc48..902095650927 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -295,6 +295,9 @@ static bool lower_abi_instr(nir_builder *b, nir_instr *instr, struct lower_abi_s
       replacement = nir_ishl_imm(b, offset, 9);
       break;
    }
+   case nir_intrinsic_load_ring_gs2vs_offset_amd:
+      replacement = ac_nir_load_arg(b, &args->ac, args->ac.gs2vs_offset);
+      break;
    default:
       return false;
    }
-- 
GitLab


From 1de177ec3c62d12017b36a83499313a56fce80e6 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 17 Oct 2022 17:16:40 +0800
Subject: [PATCH 03/14] radeonsi: lower nir streamout intrinsics in abi

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_nir_lower_abi.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 902095650927..b0684d98ef0a 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -298,6 +298,16 @@ static bool lower_abi_instr(nir_builder *b, nir_instr *instr, struct lower_abi_s
    case nir_intrinsic_load_ring_gs2vs_offset_amd:
       replacement = ac_nir_load_arg(b, &args->ac, args->ac.gs2vs_offset);
       break;
+   case nir_intrinsic_load_streamout_config_amd:
+      replacement = ac_nir_load_arg(b, &args->ac, args->ac.streamout_config);
+      break;
+   case nir_intrinsic_load_streamout_write_index_amd:
+      replacement = ac_nir_load_arg(b, &args->ac, args->ac.streamout_write_index);
+      break;
+   case nir_intrinsic_load_streamout_offset_amd:
+      replacement =
+         ac_nir_load_arg(b, &args->ac, args->ac.streamout_offset[nir_intrinsic_base(intrin)]);
+      break;
    default:
       return false;
    }
-- 
GitLab


From 5f46db80b347c6180331fe8883392bf9daa7a338 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 25 Nov 2022 10:01:57 +0800
Subject: [PATCH 04/14] radeonsi: use nir_print_xfb_info to replace
 si_dump_streamout

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 28 ++++--------------------
 1 file changed, 4 insertions(+), 24 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 2ea1645b3ad4..1dd1d77700bc 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -27,6 +27,7 @@
 #include "nir.h"
 #include "nir_builder.h"
 #include "nir_serialize.h"
+#include "nir_xfb_info.h"
 #include "nir/nir_helpers.h"
 #include "si_pipe.h"
 #include "si_shader_internal.h"
@@ -173,29 +174,6 @@ unsigned si_shader_io_get_unique_index(unsigned semantic, bool is_varying)
    }
 }
 
-static void si_dump_streamout(struct pipe_stream_output_info *so)
-{
-   unsigned i;
-
-   if (so->num_outputs) {
-      fprintf(stderr, "STREAMOUT\n");
-
-      fprintf(stderr, "  STRIDES: {");
-      for (i = 0; i < PIPE_MAX_SO_BUFFERS; i++)
-         fprintf(stderr, "%u%s", so->stride[i], i < 3 ? ", " : "");
-      fprintf(stderr, "}\n");
-   }
-
-   for (i = 0; i < so->num_outputs; i++) {
-      unsigned mask = ((1 << so->output[i].num_components) - 1) << so->output[i].start_component;
-      fprintf(stderr, "  %i: STREAM%u: BUF%i[%i..%i] <- OUT[%i].%s%s%s%s\n",
-              i, so->output[i].stream, so->output[i].output_buffer,
-              so->output[i].dst_offset, so->output[i].dst_offset + so->output[i].num_components - 1,
-              so->output[i].register_index, mask & 1 ? "x" : "", mask & 2 ? "y" : "",
-              mask & 4 ? "z" : "", mask & 8 ? "w" : "");
-   }
-}
-
 static void declare_streamout_params(struct si_shader_args *args, struct si_shader *shader)
 {
    struct si_shader_selector *sel = shader->selector;
@@ -1992,7 +1970,9 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
    if (si_can_dump_shader(sscreen, sel->stage) &&
        !(sscreen->debug_flags & DBG(NO_NIR))) {
       nir_print_shader(nir, stderr);
-      si_dump_streamout(&so);
+
+      if (nir->xfb_info)
+         nir_print_xfb_info(nir->xfb_info, stderr);
    }
 
    /* Initialize vs_output_ps_input_cntl to default. */
-- 
GitLab


From 39cf32c89efb72dc49ee34a6d44de5fc10823790 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 18 Oct 2022 14:04:12 +0800
Subject: [PATCH 05/14] radeonsi: use ac_nir_lower_legacy_vs to replace
 si_llvm_vs_build_end

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 46 +++++++++++++------
 .../drivers/radeonsi/si_shader_internal.h     |  5 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 19 ++++----
 .../drivers/radeonsi/si_shader_llvm_vs.c      | 38 ---------------
 4 files changed, 40 insertions(+), 68 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 1dd1d77700bc..12b283b23e89 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1898,14 +1898,22 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader, struct si_shader_
 
    bool opt_offsets = si_lower_io_to_mem(shader, nir, tcs_vgpr_only_inputs);
 
-   /* Assign param export indices. */
-   if (is_last_vgt_stage)
+   if (is_last_vgt_stage) {
+      /* Assign param export indices. */
       si_assign_param_offsets(nir, shader);
 
-   /* Only lower last VGT NGG shader stage. */
-   if (sel->stage <= MESA_SHADER_GEOMETRY && key->ge.as_ngg && !key->ge.as_es) {
-      si_lower_ngg(shader, nir);
-      opt_offsets = true;
+      if (key->ge.as_ngg) {
+         /* Lower last VGT NGG shader stage. */
+         si_lower_ngg(shader, nir);
+         opt_offsets = true;
+      } else if (sel->stage == MESA_SHADER_VERTEX || sel->stage == MESA_SHADER_TESS_EVAL) {
+         /* Lower last VGT none-NGG VS/TES shader stage. */
+         int primitive_id_location =
+            shader->key.ge.mono.u.vs_export_prim_id ? sel->info.num_outputs : -1;
+
+         NIR_PASS_V(nir, ac_nir_lower_legacy_vs, primitive_id_location,
+                    key->ge.opt.remove_streamout);
+      }
    }
 
    NIR_PASS(progress2, nir, si_nir_lower_abi, shader, args);
@@ -1952,6 +1960,7 @@ void si_update_shader_binary_info(struct si_shader *shader, nir_shader *nir)
 bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                        struct si_shader *shader, struct util_debug_callback *debug)
 {
+   bool ret = true;
    struct si_shader_selector *sel = shader->selector;
 
    struct si_shader_args args;
@@ -1960,11 +1969,6 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
    bool free_nir;
    struct nir_shader *nir = si_get_nir_shader(shader, &args, &free_nir, 0);
 
-   struct pipe_stream_output_info so = {};
-   /* NGG streamout has been lowered to buffer store in nir. */
-   if (!sscreen->use_ngg_streamout && si_shader_uses_streamout(shader))
-      nir_gather_stream_output_info(nir, &so);
-
    /* Dump NIR before doing NIR->LLVM conversion in case the
     * conversion fails. */
    if (si_can_dump_shader(sscreen, sel->stage) &&
@@ -2016,17 +2020,24 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
     * with PS and NGG VS), but monolithic shaders should be compiled
     * by LLVM due to more complicated compilation.
     */
-   if (!si_llvm_compile_shader(sscreen, compiler, shader, &args, &so, debug, nir, free_nir))
-      return false;
+   if (!si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir)) {
+      ret = false;
+      goto out;
+   }
 
    shader->config.float_mode = float_mode;
 
    /* The GS copy shader is compiled next. */
    if (sel->stage == MESA_SHADER_GEOMETRY && !shader->key.ge.as_ngg) {
+      struct pipe_stream_output_info so = {};
+      if (si_shader_uses_streamout(shader))
+         nir_gather_stream_output_info(nir, &so);
+
       shader->gs_copy_shader = si_generate_gs_copy_shader(sscreen, compiler, sel, &so, debug);
       if (!shader->gs_copy_shader) {
          fprintf(stderr, "radeonsi: can't create GS copy shader\n");
-         return false;
+         ret = false;
+         goto out;
       }
    }
 
@@ -2111,7 +2122,12 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
 
    si_calculate_max_simd_waves(shader);
    si_shader_dump_stats_for_shader_db(sscreen, shader, debug);
-   return true;
+
+out:
+   if (free_nir)
+      ralloc_free(nir);
+
+   return ret;
 }
 
 /**
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 2d9ba9b6ef75..ede39887c298 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -229,9 +229,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
                            struct nir_shader *nir, bool free_nir);
 bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                             struct si_shader *shader, struct si_shader_args *args,
-                            const struct pipe_stream_output_info *so,
-                            struct util_debug_callback *debug, struct nir_shader *nir,
-                            bool free_nir);
+                            struct util_debug_callback *debug, struct nir_shader *nir);
 
 /* si_shader_llvm_gs.c */
 LLVMValueRef si_is_es_thread(struct si_shader_context *ctx);
@@ -269,7 +267,6 @@ void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_outp
                             unsigned noutput, unsigned stream);
 void si_llvm_build_vs_exports(struct si_shader_context *ctx,
                               struct si_shader_output_values *outputs, unsigned noutput);
-void si_llvm_vs_build_end(struct si_shader_context *ctx);
 void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_init_vs_callbacks(struct si_shader_context *ctx);
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index b6a978e73b6d..3c1d344f6a46 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1020,8 +1020,8 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    ctx->abi.disable_aniso_single_level = true;
 
    unsigned num_outputs = info->num_outputs;
-   /* need extra output to hold primitive id added by nir ngg lower */
-   if (ctx->stage <= MESA_SHADER_GEOMETRY && shader->key.ge.as_ngg &&
+   /* need extra output to hold primitive id added by nir lower */
+   if (ctx->stage <= MESA_SHADER_GEOMETRY &&
        ctx->shader->key.ge.mono.u.vs_export_prim_id)
       num_outputs++;
 
@@ -1048,8 +1048,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
          si_llvm_ls_build_end(ctx);
       else if (shader->key.ge.as_es)
          si_llvm_es_build_end(ctx);
-      else if (!shader->key.ge.as_ngg)
-         si_llvm_vs_build_end(ctx);
       break;
 
    case MESA_SHADER_TESS_CTRL:
@@ -1059,8 +1057,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    case MESA_SHADER_TESS_EVAL:
       if (ctx->shader->key.ge.as_es)
          si_llvm_es_build_end(ctx);
-      else if (!ctx->shader->key.ge.as_ngg)
-         si_llvm_vs_build_end(ctx);
       break;
 
    case MESA_SHADER_GEOMETRY:
@@ -1099,9 +1095,7 @@ static bool si_should_optimize_less(struct ac_llvm_compiler *compiler,
 
 bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                             struct si_shader *shader, struct si_shader_args *args,
-                            const struct pipe_stream_output_info *so,
-                            struct util_debug_callback *debug, struct nir_shader *nir,
-                            bool free_nir)
+                            struct util_debug_callback *debug, struct nir_shader *nir)
 {
    struct si_shader_selector *sel = shader->selector;
    struct si_shader_context ctx;
@@ -1112,10 +1106,9 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
       exports_color_null = si_shader_uses_discard(shader) || sscreen->info.gfx_level < GFX10;
 
    si_llvm_context_init(&ctx, sscreen, compiler, shader->wave_size, exports_color_null, exports_mrtz);
-   ctx.so = *so;
    ctx.args = args;
 
-   if (!si_llvm_translate_nir(&ctx, shader, nir, free_nir)) {
+   if (!si_llvm_translate_nir(&ctx, shader, nir, false)) {
       si_llvm_dispose(&ctx);
       return false;
    }
@@ -1168,6 +1161,8 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_ls.is_monolithic = true;
 
          si_init_shader_args(&shader_ls, ctx.args);
+
+         bool free_nir;
          nir = si_get_nir_shader(&shader_ls, ctx.args, &free_nir, sel->info.tcs_vgpr_only_inputs);
          si_update_shader_binary_info(shader, nir);
 
@@ -1240,6 +1235,8 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_es.is_monolithic = true;
 
          si_init_shader_args(&shader_es, ctx.args);
+
+         bool free_nir;
          nir = si_get_nir_shader(&shader_es, ctx.args, &free_nir, 0);
          si_update_shader_binary_info(shader, nir);
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index 734a15504b89..1aadd00b360d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -724,44 +724,6 @@ void si_llvm_build_vs_exports(struct si_shader_context *ctx,
       ac_build_export(&ctx->ac, &param_exports[i]);
 }
 
-void si_llvm_vs_build_end(struct si_shader_context *ctx)
-{
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   struct si_shader_output_values *outputs = NULL;
-   LLVMValueRef *addrs = ctx->abi.outputs;
-   int i, j;
-
-   assert(!ctx->shader->is_gs_copy_shader);
-   assert(info->num_outputs <= AC_LLVM_MAX_OUTPUTS);
-
-   outputs = MALLOC((info->num_outputs + 1) * sizeof(outputs[0]));
-
-   for (i = 0; i < info->num_outputs; i++) {
-      outputs[i].semantic = info->output_semantic[i];
-
-      for (j = 0; j < 4; j++) {
-         outputs[i].values[j] = LLVMBuildLoad2(ctx->ac.builder, ctx->ac.f32, addrs[4 * i + j], "");
-         outputs[i].vertex_streams = info->output_streams[i];
-      }
-   }
-
-   if (!ctx->screen->use_ngg_streamout && ctx->so.num_outputs)
-      si_llvm_emit_streamout(ctx, outputs, i, 0);
-
-   /* Export PrimitiveID. */
-   if (ctx->shader->key.ge.mono.u.vs_export_prim_id) {
-      outputs[i].semantic = VARYING_SLOT_PRIMITIVE_ID;
-      outputs[i].vertex_streams = 0;
-      outputs[i].values[0] = ac_to_float(&ctx->ac, si_get_primitive_id(ctx, 0));
-      for (j = 1; j < 4; j++)
-         outputs[i].values[j] = LLVMConstReal(ctx->ac.f32, 0);
-      i++;
-   }
-
-   si_llvm_build_vs_exports(ctx, outputs, i);
-   FREE(outputs);
-}
-
 /**
  * Build the vertex shader prolog function.
  *
-- 
GitLab


From b7ac5068057ad58069d71c004d45d06fd421e243 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 11:29:18 +0800
Subject: [PATCH 06/14] radeonsi: add nir implementation of gs copy shader
 generation

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 85 ++++++++++++++++++++++++
 1 file changed, 85 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 12b283b23e89..671d0bc714a9 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1957,6 +1957,91 @@ void si_update_shader_binary_info(struct si_shader *shader, nir_shader *nir)
    shader->info.uses_vmem_sampler_or_bvh |= info.uses_vmem_sampler_or_bvh;
 }
 
+/* Generate code for the hardware VS shader stage to go with a geometry shader */
+static struct si_shader *
+si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
+                               struct ac_llvm_compiler *compiler,
+                               struct si_shader *gs_shader,
+                               nir_shader *gs_nir,
+                               struct util_debug_callback *debug,
+                               ac_nir_gs_output_info *output_info)
+{
+   struct si_shader *shader;
+   struct si_shader_selector *gs_selector = gs_shader->selector;
+   struct si_shader_info *gsinfo = &gs_selector->info;
+   union si_shader_key *gskey = &gs_shader->key;
+
+   shader = CALLOC_STRUCT(si_shader);
+   if (!shader)
+      return NULL;
+
+   /* We can leave the fence as permanently signaled because the GS copy
+    * shader only becomes visible globally after it has been compiled. */
+   util_queue_fence_init(&shader->ready);
+
+   shader->selector = gs_selector;
+   shader->is_gs_copy_shader = true;
+   shader->wave_size = si_determine_wave_size(sscreen, shader);
+
+   STATIC_ASSERT(sizeof(shader->info.vs_output_param_offset[0]) == 1);
+   memset(shader->info.vs_output_param_offset, AC_EXP_PARAM_DEFAULT_VAL_0000,
+          sizeof(shader->info.vs_output_param_offset));
+
+   for (unsigned i = 0; i < gsinfo->num_outputs; i++) {
+      unsigned semantic = gsinfo->output_semantic[i];
+
+      /* Skip if no channel writes to stream 0. */
+      if (!nir_slot_is_varying(semantic) ||
+          (gsinfo->output_streams[i] & 0x03 &&
+           gsinfo->output_streams[i] & 0x0c &&
+           gsinfo->output_streams[i] & 0x30 &&
+           gsinfo->output_streams[i] & 0xc0))
+         continue;
+
+      shader->info.vs_output_param_offset[semantic] = shader->info.nr_param_exports++;
+      shader->info.vs_output_param_mask |= BITFIELD64_BIT(i);
+   }
+
+   nir_shader *nir =
+      ac_nir_create_gs_copy_shader(gs_nir,
+                                   gskey->ge.opt.remove_streamout,
+                                   output_info);
+
+   /* used in si_nir_clamp_vertex_color */
+   nir->info.outputs_written = gsinfo->base.outputs_written;
+   nir->info.outputs_written_16bit = gsinfo->base.outputs_written_16bit;
+   NIR_PASS_V(nir, si_nir_clamp_vertex_color);
+
+   struct si_shader_args args;
+   si_init_shader_args(shader, &args);
+
+   NIR_PASS_V(nir, si_nir_lower_abi, shader, &args);
+
+   si_nir_opts(gs_selector->screen, nir, false);
+
+   if (si_can_dump_shader(sscreen, MESA_SHADER_GEOMETRY)) {
+      fprintf(stderr, "GS Copy Shader:\n");
+      if (!(sscreen->debug_flags & DBG(NO_NIR)))
+         nir_print_shader(nir, stderr);
+   }
+
+   bool ok = false;
+   if (si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir)) {
+      assert(!shader->config.scratch_bytes_per_wave);
+      ok = si_shader_binary_upload(sscreen, shader, 0);
+      si_shader_dump(sscreen, shader, debug, stderr, true);
+   }
+   ralloc_free(nir);
+
+   if (!ok) {
+      FREE(shader);
+      shader = NULL;
+   } else {
+      si_fix_resource_usage(sscreen, shader);
+   }
+   return shader;
+}
+
 bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                        struct si_shader *shader, struct util_debug_callback *debug)
 {
-- 
GitLab


From a7ef0c81e0a0e4d7a0b762dc323575336e612616 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 12:33:55 +0800
Subject: [PATCH 07/14] radeonsi: build legacy gs output info when shader
 compile

To be used by both legacy gs lowering and gs copy shader
generation.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 58 ++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 671d0bc714a9..82f1e76ee9e6 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2042,12 +2042,68 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
    return shader;
 }
 
+static ac_nir_gs_output_info *
+si_get_gs_output_info(struct si_shader_info *info)
+{
+   ac_nir_gs_output_info *ret = ralloc(NULL, ac_nir_gs_output_info);
+
+   struct {
+      uint8_t streams[64];
+      uint8_t streams_16bit_lo[16];
+      uint8_t streams_16bit_hi[16];
+
+      uint8_t usage_mask[64];
+      uint8_t usage_mask_16bit_lo[16];
+      uint8_t usage_mask_16bit_hi[16];
+
+      uint8_t slot_to_location[64];
+      uint8_t slot_to_location_16bit[16];
+   } *data = rzalloc_size(ret, sizeof(*data));
+
+   for (int i = 0; i < info->num_outputs; i++) {
+      unsigned slot = info->output_semantic[i];
+      if (slot < VARYING_SLOT_VAR0_16BIT) {
+         data->streams[slot] = info->output_streams[i];
+         data->usage_mask[slot] = info->output_usagemask[i];
+         data->slot_to_location[slot] = i;
+      } else {
+         unsigned index = slot - VARYING_SLOT_VAR0_16BIT;
+         /* TODO: 16bit need separated fields for lo/hi part. */
+         data->streams_16bit_lo[index] = info->output_streams[i];
+         data->streams_16bit_hi[index] = info->output_streams[i];
+         data->usage_mask_16bit_lo[index] = info->output_usagemask[i];
+         data->usage_mask_16bit_hi[index] = info->output_usagemask[i];
+         data->slot_to_location_16bit[index] = i;
+      }
+   }
+
+   ret->streams = data->streams;
+   ret->streams_16bit_lo = data->streams_16bit_lo;
+   ret->streams_16bit_hi = data->streams_16bit_hi;
+
+   ret->usage_mask = data->usage_mask;
+   ret->usage_mask_16bit_lo = data->usage_mask_16bit_lo;
+   ret->usage_mask_16bit_hi = data->usage_mask_16bit_hi;
+
+   /* TODO: construct 16bit slot per component store type. */
+   ret->types_16bit_lo = ret->types_16bit_hi = NULL;
+
+   ret->slot_to_location = data->slot_to_location;
+   ret->slot_to_location_16bit = data->slot_to_location_16bit;
+
+   return ret;
+}
+
 bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                        struct si_shader *shader, struct util_debug_callback *debug)
 {
    bool ret = true;
    struct si_shader_selector *sel = shader->selector;
 
+   ac_nir_gs_output_info *legacy_gs_output_info = NULL;
+   if (sel->stage == MESA_SHADER_GEOMETRY && !shader->key.ge.as_ngg)
+      legacy_gs_output_info = si_get_gs_output_info(&sel->info);
+
    struct si_shader_args args;
    si_init_shader_args(shader, &args);
 
@@ -2212,6 +2268,8 @@ out:
    if (free_nir)
       ralloc_free(nir);
 
+   ralloc_free(legacy_gs_output_info);
+
    return ret;
 }
 
-- 
GitLab


From 0dbc2adfa9ace61b5685c266ebea91761f467b06 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 13:29:29 +0800
Subject: [PATCH 08/14] radeonsi: replace llvm gs copy shader generation with
 nir

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 10 ++++------
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 13 +++++++++++--
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 82f1e76ee9e6..0a85a6c21f49 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -71,7 +71,7 @@ bool si_is_multi_part_shader(struct si_shader *shader)
 /** Whether the shader runs on a merged HW stage (LSHS or ESGS) */
 bool si_is_merged_shader(struct si_shader *shader)
 {
-   if (shader->selector->stage > MESA_SHADER_GEOMETRY)
+   if (shader->selector->stage > MESA_SHADER_GEOMETRY || shader->is_gs_copy_shader)
       return false;
 
    return shader->key.ge.as_ngg || si_is_multi_part_shader(shader);
@@ -2170,11 +2170,9 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
 
    /* The GS copy shader is compiled next. */
    if (sel->stage == MESA_SHADER_GEOMETRY && !shader->key.ge.as_ngg) {
-      struct pipe_stream_output_info so = {};
-      if (si_shader_uses_streamout(shader))
-         nir_gather_stream_output_info(nir, &so);
-
-      shader->gs_copy_shader = si_generate_gs_copy_shader(sscreen, compiler, sel, &so, debug);
+      shader->gs_copy_shader =
+         si_nir_generate_gs_copy_shader(sscreen, compiler, shader, nir, debug,
+                                        legacy_gs_output_info);
       if (!shader->gs_copy_shader) {
          fprintf(stderr, "radeonsi: can't create GS copy shader\n");
          ret = false;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 3c1d344f6a46..37f491eb47aa 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -781,7 +781,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    const struct si_shader_info *info = &sel->info;
 
    ctx->shader = shader;
-   ctx->stage = sel->stage;
+   ctx->stage = shader->is_gs_copy_shader ? MESA_SHADER_VERTEX : sel->stage;
 
    ctx->num_const_buffers = info->base.num_ubos;
    ctx->num_shader_buffers = info->base.num_ssbos;
@@ -811,6 +811,15 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
             ac_build_load_to_sgpr(
                &ctx->ac, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
       }
+
+      /* preload GSVS ring for GS copy shader */
+      if (shader->is_gs_copy_shader) {
+         ctx->gsvs_ring[0] =
+            ac_build_load_to_sgpr(
+               &ctx->ac,
+               ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings),
+               LLVMConstInt(ctx->ac.i32, SI_RING_GSVS, 0));
+      }
       break;
 
    case MESA_SHADER_TESS_CTRL:
@@ -1042,7 +1051,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    if (!ac_nir_translate(&ctx->ac, &ctx->abi, &ctx->args->ac, nir))
       return false;
 
-   switch (sel->stage) {
+   switch (ctx->stage) {
    case MESA_SHADER_VERTEX:
       if (shader->key.ge.as_ls)
          si_llvm_ls_build_end(ctx);
-- 
GitLab


From d047044ba2ba6a60acfa97894b07b1b274bd32d1 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 13:38:53 +0800
Subject: [PATCH 09/14] radeonsi: remove llvm gs copy shader generate

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.h      |   7 -
 .../drivers/radeonsi/si_shader_internal.h     |   7 -
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 228 ------------------
 .../drivers/radeonsi/si_shader_llvm_vs.c      | 114 ---------
 4 files changed, 356 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 53c589f2e8b1..3937c7bbb3b5 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -993,13 +993,6 @@ bool si_get_external_symbol(enum amd_gfx_level gfx_level, void *data, const char
 void si_nir_scan_shader(struct si_screen *sscreen,  const struct nir_shader *nir,
                         struct si_shader_info *info);
 
-/* si_shader_llvm_gs.c */
-struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
-                                             struct ac_llvm_compiler *compiler,
-                                             struct si_shader_selector *gs_selector,
-                                             const struct pipe_stream_output_info *so,
-                                             struct util_debug_callback *debug);
-
 /* si_shader_nir.c */
 extern const nir_lower_subgroups_options si_nir_subgroups_options;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index ede39887c298..4f7a6b80ab34 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -118,7 +118,6 @@ struct si_shader_context {
    struct ac_llvm_context ac;
    struct si_shader *shader;
    struct si_screen *screen;
-   struct pipe_stream_output_info so;
 
    gl_shader_stage stage;
 
@@ -259,12 +258,6 @@ void si_llvm_init_ps_callbacks(struct si_shader_context *ctx);
 /* si_shader_llvm_vs.c */
 void si_llvm_clipvertex_to_clipdist(struct si_shader_context *ctx,
                                     struct ac_export_args clipdist[2], LLVMValueRef clipvertex[4]);
-void si_llvm_streamout_store_output(struct si_shader_context *ctx, LLVMValueRef const *so_buffers,
-                                    LLVMValueRef const *so_write_offsets,
-                                    struct pipe_stream_output *stream_out,
-                                    struct si_shader_output_values *shader_out);
-void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_output_values *outputs,
-                            unsigned noutput, unsigned stream);
 void si_llvm_build_vs_exports(struct si_shader_context *ctx,
                               struct si_shader_output_values *outputs, unsigned noutput);
 void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index d682725bd0d0..36c07d21a7e1 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -339,234 +339,6 @@ void si_preload_gs_rings(struct si_shader_context *ctx)
    }
 }
 
-/**
- * Vertex color clamping.
- *
- * This uses a state constant loaded in a user data SGPR and
- * an IF statement is added that clamps all colors if the constant
- * is true.
- */
-static void si_vertex_color_clamping(struct si_shader_context *ctx,
-                                     struct si_shader_output_values *outputs, unsigned noutput)
-{
-   LLVMValueRef addr[SI_MAX_VS_OUTPUTS][4];
-   bool has_colors = false;
-
-   /* Store original colors to alloca variables. */
-   for (unsigned i = 0; i < noutput; i++) {
-      if (outputs[i].semantic != VARYING_SLOT_COL0 &&
-          outputs[i].semantic != VARYING_SLOT_COL1 &&
-          outputs[i].semantic != VARYING_SLOT_BFC0 &&
-          outputs[i].semantic != VARYING_SLOT_BFC1)
-         continue;
-
-      for (unsigned j = 0; j < 4; j++)
-         addr[i][j] = ac_build_alloca_init(&ctx->ac, outputs[i].values[j], "");
-
-      has_colors = true;
-   }
-
-   if (!has_colors)
-      return;
-
-   /* The state is in the first bit of the user SGPR. */
-   LLVMValueRef cond = GET_FIELD(ctx, VS_STATE_CLAMP_VERTEX_COLOR);
-   cond = LLVMBuildTrunc(ctx->ac.builder, cond, ctx->ac.i1, "");
-
-   ac_build_ifcc(&ctx->ac, cond, 6502);
-
-   /* Store clamped colors to alloca variables within the conditional block. */
-   for (unsigned i = 0; i < noutput; i++) {
-      if (outputs[i].semantic != VARYING_SLOT_COL0 &&
-          outputs[i].semantic != VARYING_SLOT_COL1 &&
-          outputs[i].semantic != VARYING_SLOT_BFC0 &&
-          outputs[i].semantic != VARYING_SLOT_BFC1)
-         continue;
-
-      for (unsigned j = 0; j < 4; j++) {
-         LLVMBuildStore(ctx->ac.builder, ac_build_clamp(&ctx->ac, outputs[i].values[j]),
-                        addr[i][j]);
-      }
-   }
-   ac_build_endif(&ctx->ac, 6502);
-
-   /* Load clamped colors */
-   for (unsigned i = 0; i < noutput; i++) {
-      if (outputs[i].semantic != VARYING_SLOT_COL0 &&
-          outputs[i].semantic != VARYING_SLOT_COL1 &&
-          outputs[i].semantic != VARYING_SLOT_BFC0 &&
-          outputs[i].semantic != VARYING_SLOT_BFC1)
-         continue;
-
-      for (unsigned j = 0; j < 4; j++) {
-         outputs[i].values[j] = LLVMBuildLoad2(ctx->ac.builder, ctx->ac.f32, addr[i][j], "");
-      }
-   }
-}
-
-/* Generate code for the hardware VS shader stage to go with a geometry shader */
-struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
-                                             struct ac_llvm_compiler *compiler,
-                                             struct si_shader_selector *gs_selector,
-                                             const struct pipe_stream_output_info *so,
-                                             struct util_debug_callback *debug)
-{
-   struct si_shader_context ctx;
-   struct si_shader *shader;
-   LLVMBuilderRef builder;
-   struct si_shader_output_values outputs[SI_MAX_VS_OUTPUTS];
-   struct si_shader_info *gsinfo = &gs_selector->info;
-   int i;
-
-   shader = CALLOC_STRUCT(si_shader);
-   if (!shader)
-      return NULL;
-
-   /* We can leave the fence as permanently signaled because the GS copy
-    * shader only becomes visible globally after it has been compiled. */
-   util_queue_fence_init(&shader->ready);
-
-   shader->selector = gs_selector;
-   shader->is_gs_copy_shader = true;
-   shader->wave_size = si_determine_wave_size(sscreen, shader);
-
-   STATIC_ASSERT(sizeof(shader->info.vs_output_param_offset[0]) == 1);
-   memset(shader->info.vs_output_param_offset, AC_EXP_PARAM_DEFAULT_VAL_0000,
-          sizeof(shader->info.vs_output_param_offset));
-
-   for (unsigned i = 0; i < gsinfo->num_outputs; i++) {
-      unsigned semantic = gsinfo->output_semantic[i];
-
-      /* Skip if no channel writes to stream 0. */
-      if (!nir_slot_is_varying(semantic) ||
-          (gsinfo->output_streams[i] & 0x03 &&
-           gsinfo->output_streams[i] & 0x0c &&
-           gsinfo->output_streams[i] & 0x30 &&
-           gsinfo->output_streams[i] & 0xc0))
-         continue;
-
-      shader->info.vs_output_param_offset[semantic] = shader->info.nr_param_exports++;
-      shader->info.vs_output_param_mask |= BITFIELD64_BIT(i);
-   }
-
-   si_llvm_context_init(&ctx, sscreen, compiler, shader->wave_size, false, false);
-   ctx.shader = shader;
-   ctx.stage = MESA_SHADER_VERTEX;
-   ctx.so = *so;
-
-   struct si_shader_args args;
-   si_init_shader_args(shader, &args);
-   ctx.args = &args;
-
-   builder = ctx.ac.builder;
-
-   /* Build the main function. */
-   si_llvm_create_main_func(&ctx);
-
-   ctx.gsvs_ring[0] =
-      ac_build_load_to_sgpr(&ctx.ac,
-         ac_get_ptr_arg(&ctx.ac, &ctx.args->ac, ctx.args->internal_bindings), LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
-
-   LLVMValueRef voffset =
-      LLVMBuildMul(ctx.ac.builder, ctx.abi.vertex_id, LLVMConstInt(ctx.ac.i32, 4, 0), "");
-
-   /* Fetch the vertex stream ID.*/
-   LLVMValueRef stream_id;
-
-   if (!sscreen->use_ngg_streamout && ctx.so.num_outputs)
-      stream_id = si_unpack_param(&ctx, ctx.args->ac.streamout_config, 24, 2);
-   else
-      stream_id = ctx.ac.i32_0;
-
-   /* Fill in output information. */
-   for (i = 0; i < gsinfo->num_outputs; ++i) {
-      outputs[i].semantic = gsinfo->output_semantic[i];
-      outputs[i].vertex_streams = gsinfo->output_streams[i];
-   }
-
-   LLVMBasicBlockRef end_bb;
-   LLVMValueRef switch_inst;
-
-   end_bb = LLVMAppendBasicBlockInContext(ctx.ac.context, ctx.main_fn.value, "end");
-   switch_inst = LLVMBuildSwitch(builder, stream_id, end_bb, 4);
-
-   for (int stream = 0; stream < 4; stream++) {
-      LLVMBasicBlockRef bb;
-      unsigned offset;
-
-      if (!gsinfo->num_stream_output_components[stream])
-         continue;
-
-      if (stream > 0 && !ctx.so.num_outputs)
-         continue;
-
-      bb = LLVMInsertBasicBlockInContext(ctx.ac.context, end_bb, "out");
-      LLVMAddCase(switch_inst, LLVMConstInt(ctx.ac.i32, stream, 0), bb);
-      LLVMPositionBuilderAtEnd(builder, bb);
-
-      /* Fetch vertex data from GSVS ring */
-      offset = 0;
-      for (i = 0; i < gsinfo->num_outputs; ++i) {
-         for (unsigned chan = 0; chan < 4; chan++) {
-            if (!(gsinfo->output_usagemask[i] & (1 << chan)) ||
-                ((outputs[i].vertex_streams >> (chan * 2)) & 0x3) != stream) {
-               outputs[i].values[chan] = LLVMGetUndef(ctx.ac.f32);
-               continue;
-            }
-
-            LLVMValueRef soffset =
-               LLVMConstInt(ctx.ac.i32, offset * gs_selector->info.base.gs.vertices_out * 16 * 4, 0);
-            offset++;
-
-            outputs[i].values[chan] =
-               ac_build_buffer_load(&ctx.ac, ctx.gsvs_ring[0], 1, ctx.ac.i32_0, voffset, soffset,
-                                    ctx.ac.f32, ac_glc | ac_slc, true, false);
-         }
-      }
-
-      /* Streamout and exports. */
-      if (!sscreen->use_ngg_streamout && ctx.so.num_outputs) {
-         si_llvm_emit_streamout(&ctx, outputs, gsinfo->num_outputs, stream);
-      }
-
-      if (stream == 0) {
-         si_vertex_color_clamping(&ctx, outputs, gsinfo->num_outputs);
-         si_llvm_build_vs_exports(&ctx, outputs, gsinfo->num_outputs);
-      }
-
-      LLVMBuildBr(builder, end_bb);
-   }
-
-   LLVMPositionBuilderAtEnd(builder, end_bb);
-
-   LLVMBuildRetVoid(ctx.ac.builder);
-
-   ctx.stage = MESA_SHADER_GEOMETRY; /* override for shader dumping */
-   si_llvm_optimize_module(&ctx);
-
-   bool ok = false;
-   if (si_compile_llvm(sscreen, &ctx.shader->binary, &ctx.shader->config, ctx.compiler, &ctx.ac,
-                       debug, MESA_SHADER_GEOMETRY, "GS Copy Shader", false)) {
-      assert(!ctx.shader->config.scratch_bytes_per_wave);
-      if (!ctx.shader->config.scratch_bytes_per_wave)
-         ok = si_shader_binary_upload(sscreen, ctx.shader, 0);
-
-      if (si_can_dump_shader(sscreen, MESA_SHADER_GEOMETRY))
-         fprintf(stderr, "GS Copy Shader:\n");
-      si_shader_dump(sscreen, ctx.shader, debug, stderr, true);
-   }
-
-   si_llvm_dispose(&ctx);
-
-   if (!ok) {
-      FREE(shader);
-      shader = NULL;
-   } else {
-      si_fix_resource_usage(sscreen, shader);
-   }
-   return shader;
-}
-
 void si_llvm_init_gs_callbacks(struct si_shader_context *ctx)
 {
    ctx->abi.emit_vertex_with_counter = si_llvm_emit_vertex;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index 1aadd00b360d..1679f6863eb2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -330,120 +330,6 @@ static LLVMValueRef si_load_vs_input(struct ac_shader_abi *abi, unsigned driver_
    return ac_build_varying_gather_values(&ctx->ac, values, num_components, component);
 }
 
-void si_llvm_streamout_store_output(struct si_shader_context *ctx, LLVMValueRef const *so_buffers,
-                                    LLVMValueRef const *so_write_offsets,
-                                    struct pipe_stream_output *stream_out,
-                                    struct si_shader_output_values *shader_out)
-{
-   unsigned buf_idx = stream_out->output_buffer;
-   unsigned start = stream_out->start_component;
-   unsigned num_comps = stream_out->num_components;
-   LLVMValueRef out[4];
-
-   assert(num_comps && num_comps <= 4);
-   if (!num_comps || num_comps > 4)
-      return;
-
-   /* Load the output as int. */
-   for (int j = 0; j < num_comps; j++) {
-      assert(stream_out->stream == ((shader_out->vertex_streams >> ((start + j) * 2)) & 0x3));
-
-      out[j] = ac_to_integer(&ctx->ac, shader_out->values[start + j]);
-   }
-
-   /* Pack the output. */
-   LLVMValueRef vdata = NULL;
-
-   switch (num_comps) {
-   case 1: /* as i32 */
-      vdata = out[0];
-      break;
-   case 2: /* as v2i32 */
-   case 3: /* as v3i32 */
-   case 4: /* as v4i32 */
-      vdata = ac_build_gather_values(&ctx->ac, out, num_comps);
-      break;
-   }
-
-   ac_build_buffer_store_dword(&ctx->ac, so_buffers[buf_idx], vdata, NULL,
-                               LLVMBuildAdd(ctx->ac.builder, so_write_offsets[buf_idx],
-                                            LLVMConstInt(ctx->ac.i32, stream_out->dst_offset * 4, 0), ""),
-                               ctx->ac.i32_0, ac_glc | ac_slc);
-}
-
-/**
- * Write streamout data to buffers for vertex stream @p stream (different
- * vertex streams can occur for GS copy shaders).
- */
-void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_output_values *outputs,
-                            unsigned noutput, unsigned stream)
-{
-   struct pipe_stream_output_info *so = &ctx->so;
-   LLVMBuilderRef builder = ctx->ac.builder;
-   int i;
-
-   /* Get bits [22:16], i.e. (so_param >> 16) & 127; */
-   LLVMValueRef so_vtx_count = si_unpack_param(ctx, ctx->args->ac.streamout_config, 16, 7);
-
-   LLVMValueRef tid = ac_get_thread_id(&ctx->ac);
-
-   /* can_emit = tid < so_vtx_count; */
-   LLVMValueRef can_emit = LLVMBuildICmp(builder, LLVMIntULT, tid, so_vtx_count, "");
-
-   /* Emit the streamout code conditionally. This actually avoids
-    * out-of-bounds buffer access. The hw tells us via the SGPR
-    * (so_vtx_count) which threads are allowed to emit streamout data. */
-   ac_build_ifcc(&ctx->ac, can_emit, 6501);
-   {
-      /* The buffer offset is computed as follows:
-       *   ByteOffset = streamout_offset[buffer_id]*4 +
-       *                (streamout_write_index + thread_id)*stride[buffer_id] +
-       *                attrib_offset
-       */
-
-      LLVMValueRef so_write_index = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_write_index);
-
-      /* Compute (streamout_write_index + thread_id). */
-      so_write_index = LLVMBuildAdd(builder, so_write_index, tid, "");
-
-      /* Load the descriptor and compute the write offset for each
-       * enabled buffer. */
-      LLVMValueRef so_write_offset[4] = {};
-      LLVMValueRef so_buffers[4];
-      struct ac_llvm_pointer arg = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings);
-
-      for (i = 0; i < 4; i++) {
-         if (!so->stride[i])
-            continue;
-
-         LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + i, 0);
-
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, arg, offset);
-
-         LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_offset[i]);
-         so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(ctx->ac.i32, 4, 0), "");
-
-         so_write_offset[i] = ac_build_imad(
-            &ctx->ac, so_write_index, LLVMConstInt(ctx->ac.i32, so->stride[i] * 4, 0), so_offset);
-      }
-
-      /* Write streamout data. */
-      for (i = 0; i < so->num_outputs; i++) {
-         unsigned reg = so->output[i].register_index;
-
-         if (reg >= noutput)
-            continue;
-
-         if (stream != so->output[i].stream)
-            continue;
-
-         si_llvm_streamout_store_output(ctx, so_buffers, so_write_offset, &so->output[i],
-                                        &outputs[reg]);
-      }
-   }
-   ac_build_endif(&ctx->ac, 6501);
-}
-
 void si_llvm_clipvertex_to_clipdist(struct si_shader_context *ctx,
                                     struct ac_export_args clipdist[2], LLVMValueRef clipvertex[4])
 {
-- 
GitLab


From 8ae582d34d8e8a85bdb552cdbd5a97247590f8c4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 1 Dec 2022 09:55:57 +0800
Subject: [PATCH 10/14] radeonsi: replace llvm legacy gs code with nir lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 13 ++-
 .../drivers/radeonsi/si_shader_internal.h     |  8 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  7 +-
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 85 +------------------
 4 files changed, 21 insertions(+), 92 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 0a85a6c21f49..3236623daf3e 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1767,8 +1767,11 @@ static void si_assign_param_offsets(nir_shader *nir, struct si_shader *shader)
    si_nir_assign_param_offsets(nir, shader, slot_remap);
 }
 
-struct nir_shader *si_get_nir_shader(struct si_shader *shader, struct si_shader_args *args,
-                                     bool *free_nir, uint64_t tcs_vgpr_only_inputs)
+struct nir_shader *si_get_nir_shader(struct si_shader *shader,
+                                     struct si_shader_args *args,
+                                     bool *free_nir,
+                                     uint64_t tcs_vgpr_only_inputs,
+                                     ac_nir_gs_output_info *output_info)
 {
    struct si_shader_selector *sel = shader->selector;
    const union si_shader_key *key = &shader->key;
@@ -1916,6 +1919,9 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader, struct si_shader_
       }
    }
 
+   if (sel->stage == MESA_SHADER_GEOMETRY && !key->ge.as_ngg)
+      NIR_PASS_V(nir, ac_nir_lower_legacy_gs, false, sel->screen->use_ngg, output_info);
+
    NIR_PASS(progress2, nir, si_nir_lower_abi, shader, args);
 
    if (progress2 || opt_offsets)
@@ -2108,7 +2114,8 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
    si_init_shader_args(shader, &args);
 
    bool free_nir;
-   struct nir_shader *nir = si_get_nir_shader(shader, &args, &free_nir, 0);
+   struct nir_shader *nir =
+      si_get_nir_shader(shader, &args, &free_nir, 0, legacy_gs_output_info);
 
    /* Dump NIR before doing NIR->LLVM conversion in case the
     * conversion fails. */
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 4f7a6b80ab34..3207c52c547f 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -147,8 +147,6 @@ struct si_shader_context {
    LLVMValueRef gs_ngg_emit;
    struct ac_llvm_pointer gs_ngg_scratch;
    LLVMValueRef return_value;
-
-   LLVMValueRef gs_emitted_vertices;
 };
 
 static inline struct si_shader_context *si_shader_context_from_abi(struct ac_shader_abi *abi)
@@ -156,6 +154,9 @@ static inline struct si_shader_context *si_shader_context_from_abi(struct ac_sha
    return container_of(abi, struct si_shader_context, abi);
 }
 
+struct ac_nir_gs_output_info;
+typedef struct ac_nir_gs_output_info ac_nir_gs_output_info;
+
 /* si_shader.c */
 bool si_is_multi_part_shader(struct si_shader *shader);
 bool si_is_merged_shader(struct si_shader *shader);
@@ -169,7 +170,8 @@ void si_get_vs_prolog_key(const struct si_shader_info *info, unsigned num_input_
                           const struct si_vs_prolog_bits *prolog_key,
                           struct si_shader *shader_out, union si_shader_part_key *key);
 struct nir_shader *si_get_nir_shader(struct si_shader *shader, struct si_shader_args *args,
-                                     bool *free_nir, uint64_t tcs_vgpr_only_inputs);
+                                     bool *free_nir, uint64_t tcs_vgpr_only_inputs,
+                                     ac_nir_gs_output_info *output_info);
 void si_get_tcs_epilog_key(struct si_shader *shader, union si_shader_part_key *key);
 bool si_need_ps_prolog(const union si_shader_part_key *key);
 void si_get_ps_prolog_key(struct si_shader *shader, union si_shader_part_key *key,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 37f491eb47aa..aa9cf565db17 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -849,8 +849,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
          LLVMSetAlignment(ctx->gs_ngg_emit, 4);
       } else {
          si_preload_gs_rings(ctx);
-
-         ctx->gs_emitted_vertices = LLVMConstInt(ctx->ac.i32, 0, false);
       }
       break;
 
@@ -1172,7 +1170,8 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          si_init_shader_args(&shader_ls, ctx.args);
 
          bool free_nir;
-         nir = si_get_nir_shader(&shader_ls, ctx.args, &free_nir, sel->info.tcs_vgpr_only_inputs);
+         nir = si_get_nir_shader(&shader_ls, ctx.args, &free_nir,
+                                 sel->info.tcs_vgpr_only_inputs, NULL);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_ls, nir, free_nir)) {
@@ -1246,7 +1245,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          si_init_shader_args(&shader_es, ctx.args);
 
          bool free_nir;
-         nir = si_get_nir_shader(&shader_es, ctx.args, &free_nir, 0);
+         nir = si_get_nir_shader(&shader_es, ctx.args, &free_nir, 0, NULL);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_es, nir, free_nir)) {
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 36c07d21a7e1..30befe58f530 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -105,57 +105,9 @@ static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
 
 void si_llvm_gs_build_end(struct si_shader_context *ctx)
 {
-   struct si_shader_info UNUSED *info = &ctx->shader->selector->info;
-
-   assert(info->num_outputs <= AC_LLVM_MAX_OUTPUTS);
-
    if (ctx->screen->info.gfx_level >= GFX10)
       ac_build_waitcnt(&ctx->ac, AC_WAIT_VSTORE);
 
-   if (ctx->screen->use_ngg) {
-      /* Implement PIPE_STAT_QUERY_GS_PRIMITIVES for non-ngg draws because we can't
-       * use pipeline statistics (they would be correct but when screen->use_ngg, we
-       * can't know when the query is started if the next draw(s) will use ngg or not).
-       */
-      LLVMValueRef tmp = GET_FIELD(ctx, GS_STATE_PIPELINE_STATS_EMU);
-      tmp = LLVMBuildTrunc(ctx->ac.builder, tmp, ctx->ac.i1, "");
-      ac_build_ifcc(&ctx->ac, tmp, 5229); /* if (GS_PIPELINE_STATS_EMU) */
-      {
-         LLVMValueRef prim = ctx->ac.i32_0;
-         switch (ctx->shader->selector->info.base.gs.output_primitive) {
-         case SHADER_PRIM_POINTS:
-            prim = ctx->gs_emitted_vertices;
-            break;
-         case SHADER_PRIM_LINE_STRIP:
-            prim = LLVMBuildSub(ctx->ac.builder, ctx->gs_emitted_vertices, ctx->ac.i32_1, "");
-            prim = ac_build_imax(&ctx->ac, prim, ctx->ac.i32_0);
-            break;
-         case SHADER_PRIM_TRIANGLE_STRIP:
-            prim = LLVMBuildSub(ctx->ac.builder, ctx->gs_emitted_vertices, LLVMConstInt(ctx->ac.i32, 2, 0), "");
-            prim = ac_build_imax(&ctx->ac, prim, ctx->ac.i32_0);
-            break;
-         }
-
-         LLVMValueRef args[] = {
-            prim,
-            ngg_get_emulated_counters_buf(ctx),
-            LLVMConstInt(ctx->ac.i32,
-                         si_query_pipestat_end_dw_offset(ctx->screen, PIPE_STAT_QUERY_GS_PRIMITIVES) * 4,
-                         false),
-            ctx->ac.i32_0,                            /* soffset */
-            ctx->ac.i32_0,                            /* cachepolicy */
-         };
-         ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.raw.buffer.atomic.add.i32", ctx->ac.i32, args, 5, 0);
-
-         args[0] = ctx->ac.i32_1;
-         args[2] = LLVMConstInt(ctx->ac.i32,
-                                si_query_pipestat_end_dw_offset(ctx->screen, PIPE_STAT_QUERY_GS_INVOCATIONS) * 4,
-                                false);
-         ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.raw.buffer.atomic.add.i32", ctx->ac.i32, args, 5, 0);
-      }
-      ac_build_endif(&ctx->ac, 5229);
-   }
-
    ac_build_sendmsg(&ctx->ac, AC_SENDMSG_GS_OP_NOP | AC_SENDMSG_GS_DONE, si_get_gs_wave_id(ctx));
 
    if (ctx->screen->info.gfx_level >= GFX9)
@@ -170,40 +122,9 @@ static void si_llvm_emit_vertex(struct ac_shader_abi *abi, unsigned stream,
 
    assert(!ctx->shader->key.ge.as_ngg);
 
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   struct si_shader *shader = ctx->shader;
-   LLVMValueRef soffset = ac_get_arg(&ctx->ac, ctx->args->ac.gs2vs_offset);
-
-   unsigned offset = 0;
-   for (unsigned i = 0; i < info->num_outputs; i++) {
-      for (unsigned chan = 0; chan < 4; chan++) {
-         if (!(info->output_usagemask[i] & (1 << chan)) ||
-             ((info->output_streams[i] >> (2 * chan)) & 3) != stream)
-            continue;
-
-         LLVMValueRef out_val = LLVMBuildLoad2(ctx->ac.builder, ctx->ac.f32, addrs[4 * i + chan], "");
-         LLVMValueRef voffset =
-            LLVMConstInt(ctx->ac.i32, offset * shader->selector->info.base.gs.vertices_out, 0);
-         offset++;
-
-         voffset = LLVMBuildAdd(ctx->ac.builder, voffset, vertexidx, "");
-         voffset = LLVMBuildMul(ctx->ac.builder, voffset, LLVMConstInt(ctx->ac.i32, 4, 0), "");
-
-         out_val = ac_to_integer(&ctx->ac, out_val);
-
-         ac_build_buffer_store_dword(&ctx->ac, ctx->gsvs_ring[stream], out_val, NULL,
-                                     voffset, soffset, ac_glc | ac_slc | ac_swizzled);
-      }
-   }
-
-   /* Signal vertex emission if vertex data was written. */
-   if (offset) {
-      ac_build_sendmsg(&ctx->ac, AC_SENDMSG_GS_OP_EMIT | AC_SENDMSG_GS | (stream << 8),
-                       si_get_gs_wave_id(ctx));
-
-      ctx->gs_emitted_vertices = LLVMBuildAdd(ctx->ac.builder, ctx->gs_emitted_vertices,
-                                              ctx->ac.i32_1, "vert");
-   }
+   /* Signal vertex emission */
+   ac_build_sendmsg(&ctx->ac, AC_SENDMSG_GS_OP_EMIT | AC_SENDMSG_GS | (stream << 8),
+                    si_get_gs_wave_id(ctx));
 }
 
 /* Cut one primitive from the geometry shader */
-- 
GitLab


From 73e92bbc141b5465658c8260a30cfc387f96f672 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 19 Oct 2022 10:26:14 +0800
Subject: [PATCH 11/14] radeonsi: move gfx10_ngg_export_vertex to
 si_shader_llvm.c

It's now also used by non-ngg pipeline and older GPUs.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../drivers/radeonsi/gfx10_shader_ngg.c       | 29 -----------------
 .../drivers/radeonsi/si_shader_internal.h     |  1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 31 ++++++++++++++++++-
 3 files changed, 30 insertions(+), 31 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 2392e73bee2a..c053d436426a 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -95,35 +95,6 @@ bool gfx10_ngg_export_prim_early(struct si_shader *shader)
           !gfx10_ngg_writes_user_edgeflags(shader);
 }
 
-void gfx10_ngg_export_vertex(struct ac_shader_abi *abi)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   struct si_shader_output_values outputs[PIPE_MAX_SHADER_OUTPUTS];
-   LLVMValueRef *addrs = ctx->abi.outputs;
-
-   unsigned num_outputs = info->num_outputs;
-   /* if needed, nir ngg lower will append primitive id export at last */
-   if (ctx->shader->key.ge.mono.u.vs_export_prim_id)
-      num_outputs++;
-
-   for (unsigned i = 0; i < num_outputs; i++) {
-      if (i < info->num_outputs) {
-         outputs[i].semantic = info->output_semantic[i];
-         outputs[i].vertex_streams = info->output_streams[i];
-      } else {
-         outputs[i].semantic = VARYING_SLOT_PRIMITIVE_ID;
-         outputs[i].vertex_streams = 0;
-      }
-
-      for (unsigned j = 0; j < 4; j++)
-         outputs[i].values[j] =
-            LLVMBuildLoad2(ctx->ac.builder, ctx->ac.f32, addrs[4 * i + j], "");
-   }
-
-   si_llvm_build_vs_exports(ctx, outputs, num_outputs);
-}
-
 static void clamp_gsprims_to_esverts(unsigned *max_gsprims, unsigned max_esverts,
                                      unsigned min_verts_per_prim, bool use_adjacency)
 {
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 3207c52c547f..d5066476f078 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -183,7 +183,6 @@ void si_fix_resource_usage(struct si_screen *sscreen, struct si_shader *shader);
 LLVMValueRef gfx10_get_thread_id_in_tg(struct si_shader_context *ctx);
 unsigned gfx10_ngg_get_vertices_per_prim(struct si_shader *shader);
 bool gfx10_ngg_export_prim_early(struct si_shader *shader);
-void gfx10_ngg_export_vertex(struct ac_shader_abi *abi);
 unsigned gfx10_ngg_get_scratch_dw_size(struct si_shader *shader);
 bool gfx10_ngg_calculate_subgroup_info(struct si_shader *shader);
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index aa9cf565db17..d809d216c91e 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -774,6 +774,35 @@ static LLVMValueRef si_llvm_load_sampler_desc(struct ac_shader_abi *abi, LLVMVal
    return index;
 }
 
+static void si_llvm_export_vertex(struct ac_shader_abi *abi)
+{
+   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
+   struct si_shader_info *info = &ctx->shader->selector->info;
+   struct si_shader_output_values outputs[PIPE_MAX_SHADER_OUTPUTS];
+   LLVMValueRef *addrs = ctx->abi.outputs;
+
+   unsigned num_outputs = info->num_outputs;
+   /* if needed, nir lower will append primitive id export at last */
+   if (ctx->shader->key.ge.mono.u.vs_export_prim_id)
+      num_outputs++;
+
+   for (unsigned i = 0; i < num_outputs; i++) {
+      if (i < info->num_outputs) {
+         outputs[i].semantic = info->output_semantic[i];
+         outputs[i].vertex_streams = info->output_streams[i];
+      } else {
+         outputs[i].semantic = VARYING_SLOT_PRIMITIVE_ID;
+         outputs[i].vertex_streams = 0;
+      }
+
+      for (unsigned j = 0; j < 4; j++)
+         outputs[i].values[j] =
+            LLVMBuildLoad2(ctx->ac.builder, ctx->ac.f32, addrs[4 * i + j], "");
+   }
+
+   si_llvm_build_vs_exports(ctx, outputs, num_outputs);
+}
+
 bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
                            struct nir_shader *nir, bool free_nir)
 {
@@ -790,7 +819,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    ctx->num_images = info->base.num_images;
 
    ctx->abi.intrinsic_load = si_llvm_load_intrinsic;
-   ctx->abi.export_vertex = gfx10_ngg_export_vertex;
+   ctx->abi.export_vertex = si_llvm_export_vertex;
    ctx->abi.load_sampler_desc = si_llvm_load_sampler_desc;
 
    si_llvm_create_main_func(ctx);
-- 
GitLab


From 389aa3b22f249b4e8ee10a9d0d0a56749f38633e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 16:51:15 +0800
Subject: [PATCH 12/14] gallium/aux: remove nir_helpers

Not used by anyone.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/auxiliary/meson.build        |  2 -
 src/gallium/auxiliary/nir/nir_helpers.c  | 56 ------------------------
 src/gallium/auxiliary/nir/nir_helpers.h  | 36 ---------------
 src/gallium/drivers/radeonsi/si_shader.c |  1 -
 4 files changed, 95 deletions(-)
 delete mode 100644 src/gallium/auxiliary/nir/nir_helpers.c
 delete mode 100644 src/gallium/auxiliary/nir/nir_helpers.h

diff --git a/src/gallium/auxiliary/meson.build b/src/gallium/auxiliary/meson.build
index 63a2a9120929..c3e70bf32d79 100644
--- a/src/gallium/auxiliary/meson.build
+++ b/src/gallium/auxiliary/meson.build
@@ -290,8 +290,6 @@ files_libgallium = files(
   'nir/nir_to_tgsi.h',
   'nir/nir_draw_helpers.c',
   'nir/nir_draw_helpers.h',
-  'nir/nir_helpers.c',
-  'nir/nir_helpers.h',
 )
 
 if dep_libdrm.found()
diff --git a/src/gallium/auxiliary/nir/nir_helpers.c b/src/gallium/auxiliary/nir/nir_helpers.c
deleted file mode 100644
index 1b5b7968ef57..000000000000
--- a/src/gallium/auxiliary/nir/nir_helpers.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2021 Advanced Micro Devices, Inc.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- **************************************************************************/
-
-#include "nir_helpers.h"
-#include "nir_xfb_info.h"
-
-void
-nir_gather_stream_output_info(nir_shader *nir,
-                              struct pipe_stream_output_info *so)
-{
-   int slot_to_register[NUM_TOTAL_VARYING_SLOTS];
-   nir_xfb_info *info = nir_gather_xfb_info_from_intrinsics(nir, slot_to_register);
-
-   memset(so, 0, sizeof(*so));
-
-   if (!info)
-      return;
-
-   so->num_outputs = info->output_count;
-
-   for (unsigned i = 0; i < info->output_count; i++) {
-      so->output[i].start_component = info->outputs[i].component_offset;
-      so->output[i].num_components = util_bitcount(info->outputs[i].component_mask);
-      so->output[i].output_buffer = info->outputs[i].buffer;
-      so->output[i].dst_offset = info->outputs[i].offset / 4;
-      so->output[i].stream = info->buffer_to_stream[info->outputs[i].buffer];
-      so->output[i].register_index = slot_to_register[info->outputs[i].location];
-   }
-
-   for (unsigned i = 0; i < MAX_XFB_BUFFERS; i++)
-      so->stride[i] = info->buffers[i].stride;
-
-   free(info);
-}
diff --git a/src/gallium/auxiliary/nir/nir_helpers.h b/src/gallium/auxiliary/nir/nir_helpers.h
deleted file mode 100644
index 08761b0455ae..000000000000
--- a/src/gallium/auxiliary/nir/nir_helpers.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2021 Advanced Micro Devices, Inc.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- **************************************************************************/
-
-#ifndef GALLIUM_NIR_HELPERS
-#define GALLIUM_NIR_HELPERS
-
-#include "nir.h"
-#include "pipe/p_state.h"
-
-void
-nir_gather_stream_output_info(nir_shader *nir,
-                              struct pipe_stream_output_info *so);
-
-#endif
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 3236623daf3e..b45dbe7ed7d0 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -28,7 +28,6 @@
 #include "nir_builder.h"
 #include "nir_serialize.h"
 #include "nir_xfb_info.h"
-#include "nir/nir_helpers.h"
 #include "si_pipe.h"
 #include "si_shader_internal.h"
 #include "sid.h"
-- 
GitLab


From 5f446ef88542f6d25ef49ea934793d7f379c9a38 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 21:42:08 +0800
Subject: [PATCH 13/14] nir/xfb_info: nir_gather_xfb_info_from_intrinsics
 update nir xfb_info

Use this function to update nir_shader->xfb_info.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/compiler/nir/nir_gather_xfb_info.c | 26 ++++++++++----------------
 src/compiler/nir/nir_xfb_info.h        |  5 ++---
 2 files changed, 12 insertions(+), 19 deletions(-)

diff --git a/src/compiler/nir/nir_gather_xfb_info.c b/src/compiler/nir/nir_gather_xfb_info.c
index 2a7871a9eae0..306cab85050c 100644
--- a/src/compiler/nir/nir_gather_xfb_info.c
+++ b/src/compiler/nir/nir_gather_xfb_info.c
@@ -317,20 +317,14 @@ compare_xfb_out(const void *pa, const void *pb)
  * Optionally return slot_to_register, an optional table to translate
  * gl_varying_slot to "base" indices.
  */
-nir_xfb_info *
-nir_gather_xfb_info_from_intrinsics(nir_shader *nir,
-                                    int slot_to_register[NUM_TOTAL_VARYING_SLOTS])
+void
+nir_gather_xfb_info_from_intrinsics(nir_shader *nir)
 {
    nir_function_impl *impl = nir_shader_get_entrypoint(nir);
    uint8_t buffer_to_stream[MAX_XFB_BUFFERS] = {0};
    uint8_t buffer_mask = 0;
    uint8_t stream_mask = 0;
 
-   if (slot_to_register) {
-      memset(slot_to_register, -1,
-             sizeof(slot_to_register[0] * NUM_TOTAL_VARYING_SLOTS));
-   }
-
    /* Gather xfb outputs. */
    struct util_dynarray array = {0};
 
@@ -368,9 +362,6 @@ nir_gather_xfb_info_from_intrinsics(nir_shader *nir,
                buffer_mask |= BITFIELD_BIT(out.buffer);
                stream_mask |= BITFIELD_BIT(stream);
 
-               if (slot_to_register)
-                  slot_to_register[sem.location] = nir_intrinsic_base(intr);
-
                /* No elements before component_offset are allowed to be set. */
                assert(!(out.component_mask & BITFIELD_MASK(out.component_offset)));
             }
@@ -382,7 +373,7 @@ nir_gather_xfb_info_from_intrinsics(nir_shader *nir,
    int count = util_dynarray_num_elements(&array, nir_xfb_output_info);
 
    if (!count)
-      return NULL;
+      return;
 
    if (count > 1) {
       /* Sort outputs by buffer, location, and component. */
@@ -436,10 +427,10 @@ nir_gather_xfb_info_from_intrinsics(nir_shader *nir,
       assert(outputs[i].component_mask);
 
    /* Create nir_xfb_info. */
-   nir_xfb_info *info = calloc(1, nir_xfb_info_size(count));
+   nir_xfb_info *info = nir_xfb_info_create(nir, count);
    if (!info) {
       util_dynarray_fini(&array);
-      return NULL;
+      return;
    }
 
    /* Fill nir_xfb_info. */
@@ -452,15 +443,18 @@ nir_gather_xfb_info_from_intrinsics(nir_shader *nir,
    /* Set strides. */
    for (unsigned i = 0; i < MAX_XFB_BUFFERS; i++) {
       if (buffer_mask & BITFIELD_BIT(i))
-         info->buffers[i].stride = nir->info.xfb_stride[i];
+         info->buffers[i].stride = nir->info.xfb_stride[i] * 4;
    }
 
    /* Set varying_count. */
    for (unsigned i = 0; i < count; i++)
       info->buffers[outputs[i].buffer].varying_count++;
 
+   /* Replace original xfb info. */
+   ralloc_free(nir->xfb_info);
+   nir->xfb_info = info;
+
    util_dynarray_fini(&array);
-   return info;
 }
 
 void
diff --git a/src/compiler/nir/nir_xfb_info.h b/src/compiler/nir/nir_xfb_info.h
index 98e8a356950b..9848dbd2d448 100644
--- a/src/compiler/nir/nir_xfb_info.h
+++ b/src/compiler/nir/nir_xfb_info.h
@@ -82,9 +82,8 @@ nir_gather_xfb_info_with_varyings(nir_shader *shader,
                                   void *mem_ctx,
                                   nir_xfb_varyings_info **varyings_info);
 
-nir_xfb_info *
-nir_gather_xfb_info_from_intrinsics(nir_shader *nir,
-                                    int slot_to_register[NUM_TOTAL_VARYING_SLOTS]);
+void
+nir_gather_xfb_info_from_intrinsics(nir_shader *nir);
 
 void
 nir_print_xfb_info(nir_xfb_info *info, FILE *fp);
-- 
GitLab


From 3e017d002dba3345724de260c19f354ca9cec8d4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 4 Dec 2022 21:47:16 +0800
Subject: [PATCH 14/14] radeonsi: update nir xfb info after medium io lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_nir.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index acff79a16531..f2d588a2fe09 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -23,6 +23,7 @@
  */
 
 #include "nir_builder.h"
+#include "nir_xfb_info.h"
 #include "si_pipe.h"
 
 
@@ -372,6 +373,10 @@ char *si_finalize_nir(struct pipe_screen *screen, void *nirptr)
    si_lower_nir(sscreen, nir);
    nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
 
+   /* Update xfb info after we did medium io lowering. */
+   if (nir->xfb_info && nir->info.outputs_written_16bit)
+      nir_gather_xfb_info_from_intrinsics(nir);
+
    if (sscreen->options.inline_uniforms)
       nir_find_inlinable_uniforms(nir);
 
-- 
GitLab

