From ec5a14ca34defcd3817f405dd71ab56d53c50f6c Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Thu, 2 Jan 2025 11:01:29 +0100
Subject: [PATCH 01/32] radeonsi: Add radeon_bitstream and use it in
 radeon_vcn_enc

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/meson.build      |   2 +
 .../drivers/radeonsi/radeon_bitstream.c       | 349 +++++++
 .../drivers/radeonsi/radeon_bitstream.h       |  53 ++
 src/gallium/drivers/radeonsi/radeon_vcn_enc.c | 191 +---
 src/gallium/drivers/radeonsi/radeon_vcn_enc.h |  62 +-
 .../drivers/radeonsi/radeon_vcn_enc_1_2.c     | 896 +++++++-----------
 .../drivers/radeonsi/radeon_vcn_enc_4_0.c     | 301 +++---
 .../drivers/radeonsi/radeon_vcn_enc_5_0.c     |  94 +-
 8 files changed, 972 insertions(+), 976 deletions(-)
 create mode 100644 src/gallium/drivers/radeonsi/radeon_bitstream.c
 create mode 100644 src/gallium/drivers/radeonsi/radeon_bitstream.h

diff --git a/src/gallium/drivers/radeonsi/meson.build b/src/gallium/drivers/radeonsi/meson.build
index 09e31d41fa3a2..bb8fe874253af 100644
--- a/src/gallium/drivers/radeonsi/meson.build
+++ b/src/gallium/drivers/radeonsi/meson.build
@@ -101,6 +101,8 @@ files_libradeonsi = files(
   'radeon_vcn_enc_5_0.c',
   'radeon_video.c',
   'radeon_video.h',
+  'radeon_bitstream.h',
+  'radeon_bitstream.c',
 )
 
 radeonsi_include_dirs = [inc_src, inc_include, inc_gallium, inc_gallium_aux, inc_amd_common,
diff --git a/src/gallium/drivers/radeonsi/radeon_bitstream.c b/src/gallium/drivers/radeonsi/radeon_bitstream.c
new file mode 100644
index 0000000000000..fbebe87ed9707
--- /dev/null
+++ b/src/gallium/drivers/radeonsi/radeon_bitstream.c
@@ -0,0 +1,349 @@
+/*
+ * Copyright 2025 Advanced Micro Devices, Inc.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#include "radeon_bitstream.h"
+
+static const uint32_t index_to_shifts[4] = {24, 16, 8, 0};
+
+static void radeon_bs_output_one_byte(struct radeon_bitstream *bs, uint8_t byte)
+{
+   if (bs->buf) {
+      *(bs->buf++) = byte;
+      return;
+   }
+
+   if (bs->byte_index == 0)
+      bs->cs->current.buf[bs->cs->current.cdw] = 0;
+   bs->cs->current.buf[bs->cs->current.cdw] |=
+      ((uint32_t)(byte) << index_to_shifts[bs->byte_index]);
+   bs->byte_index++;
+
+   if (bs->byte_index >= 4) {
+      bs->byte_index = 0;
+      bs->cs->current.cdw++;
+   }
+}
+
+static void radeon_bs_emulation_prevention(struct radeon_bitstream *bs, uint8_t byte)
+{
+   if (bs->emulation_prevention) {
+      if ((bs->num_zeros >= 2) && ((byte == 0x00) || (byte == 0x01) ||
+         (byte == 0x02) || (byte == 0x03))) {
+         radeon_bs_output_one_byte(bs, 0x03);
+         bs->bits_output += 8;
+         bs->num_zeros = 0;
+      }
+      bs->num_zeros = (byte == 0 ? (bs->num_zeros + 1) : 0);
+   }
+}
+
+void radeon_bs_reset(struct radeon_bitstream *bs, uint8_t *out, struct radeon_cmdbuf *cs)
+{
+   memset(bs, 0, sizeof(*bs));
+   bs->buf = out;
+   bs->cs = cs;
+}
+
+void radeon_bs_set_emulation_prevention(struct radeon_bitstream *bs, bool set)
+{
+   if (set != bs->emulation_prevention) {
+      bs->emulation_prevention = set;
+      bs->num_zeros = 0;
+   }
+}
+
+void radeon_bs_byte_align(struct radeon_bitstream *bs)
+{
+   uint32_t num_padding_zeros = (32 - bs->bits_in_shifter) % 8;
+
+   if (num_padding_zeros > 0)
+      radeon_bs_code_fixed_bits(bs, 0, num_padding_zeros);
+}
+
+void radeon_bs_flush_headers(struct radeon_bitstream *bs)
+{
+   if (bs->bits_in_shifter != 0) {
+      uint8_t output_byte = bs->shifter >> 24;
+      radeon_bs_emulation_prevention(bs, output_byte);
+      radeon_bs_output_one_byte(bs, output_byte);
+      bs->bits_output += bs->bits_in_shifter;
+      bs->shifter = 0;
+      bs->bits_in_shifter = 0;
+      bs->num_zeros = 0;
+   }
+
+   if (bs->byte_index > 0) {
+      bs->cs->current.cdw++;
+      bs->byte_index = 0;
+   }
+}
+
+void radeon_bs_code_fixed_bits(struct radeon_bitstream *bs, uint32_t value, uint32_t num_bits)
+{
+   uint32_t bits_to_pack = 0;
+   bs->bits_size += num_bits;
+
+   while (num_bits > 0) {
+      uint32_t value_to_pack = value & (0xffffffff >> (32 - num_bits));
+      bits_to_pack =
+         num_bits > (32 - bs->bits_in_shifter) ? (32 - bs->bits_in_shifter) : num_bits;
+
+      if (bits_to_pack < num_bits)
+         value_to_pack = value_to_pack >> (num_bits - bits_to_pack);
+
+      bs->shifter |= value_to_pack << (32 - bs->bits_in_shifter - bits_to_pack);
+      num_bits -= bits_to_pack;
+      bs->bits_in_shifter += bits_to_pack;
+
+      while (bs->bits_in_shifter >= 8) {
+         uint8_t output_byte = bs->shifter >> 24;
+         bs->shifter <<= 8;
+         radeon_bs_emulation_prevention(bs, output_byte);
+         radeon_bs_output_one_byte(bs, output_byte);
+         bs->bits_in_shifter -= 8;
+         bs->bits_output += 8;
+      }
+   }
+}
+
+void radeon_bs_code_ue(struct radeon_bitstream *bs, uint32_t value)
+{
+   uint32_t x = 0;
+   uint32_t ue_code = value + 1;
+   value += 1;
+
+   while (value) {
+      value = value >> 1;
+      x += 1;
+   }
+
+   if (x > 1)
+     radeon_bs_code_fixed_bits(bs, 0, x - 1);
+   radeon_bs_code_fixed_bits(bs, ue_code, x);
+}
+
+void radeon_bs_code_se(struct radeon_bitstream *bs, int32_t value)
+{
+   uint32_t v = 0;
+
+   if (value != 0)
+      v = (value < 0 ? ((uint32_t)(0 - value) << 1) : (((uint32_t)(value) << 1) - 1));
+
+   radeon_bs_code_ue(bs, v);
+}
+
+void radeon_bs_code_uvlc(struct radeon_bitstream *bs, uint32_t value)
+{
+   uint32_t num_bits = 0;
+   uint64_t value_plus1 = (uint64_t)value + 1;
+   uint32_t num_leading_zeros = 0;
+
+   while ((uint64_t)1 << num_bits <= value_plus1)
+      num_bits++;
+
+   num_leading_zeros = num_bits - 1;
+   radeon_bs_code_fixed_bits(bs, 0, num_leading_zeros);
+   radeon_bs_code_fixed_bits(bs, 1, 1);
+   radeon_bs_code_fixed_bits(bs, (uint32_t)value_plus1, num_leading_zeros);
+}
+
+void radeon_bs_code_ns(struct radeon_bitstream *bs, uint32_t value, uint32_t max)
+{
+   uint32_t w = 0;
+   uint32_t m;
+   uint32_t max_num = max;
+
+   while ( max_num ) {
+      max_num >>= 1;
+      w++;
+   }
+
+   m = (1 << w) - max;
+
+   assert(w > 1);
+
+   if (value < m) {
+      radeon_bs_code_fixed_bits(bs, value, (w - 1));
+   } else {
+      uint32_t diff = value - m;
+      uint32_t out = (((diff >> 1) + m) << 1) | (diff & 0x1);
+      radeon_bs_code_fixed_bits(bs, out, w);
+   }
+}
+
+void radeon_bs_h264_hrd_parameters(struct radeon_bitstream *bs,
+                                   struct pipe_h264_enc_hrd_params *hrd)
+{
+   radeon_bs_code_ue(bs, hrd->cpb_cnt_minus1);
+   radeon_bs_code_fixed_bits(bs, hrd->bit_rate_scale, 4);
+   radeon_bs_code_fixed_bits(bs, hrd->cpb_size_scale, 4);
+   for (uint32_t i = 0; i <= hrd->cpb_cnt_minus1; i++) {
+      radeon_bs_code_ue(bs, hrd->bit_rate_value_minus1[i]);
+      radeon_bs_code_ue(bs, hrd->cpb_size_value_minus1[i]);
+      radeon_bs_code_fixed_bits(bs, hrd->cbr_flag[i], 1);
+   }
+   radeon_bs_code_fixed_bits(bs, hrd->initial_cpb_removal_delay_length_minus1, 5);
+   radeon_bs_code_fixed_bits(bs, hrd->cpb_removal_delay_length_minus1, 5);
+   radeon_bs_code_fixed_bits(bs, hrd->dpb_output_delay_length_minus1, 5);
+   radeon_bs_code_fixed_bits(bs, hrd->time_offset_length, 5);
+}
+
+static void radeon_bs_hevc_profile_tier(struct radeon_bitstream *bs,
+                                        struct pipe_h265_profile_tier *pt)
+{
+   radeon_bs_code_fixed_bits(bs, pt->general_profile_space, 2);
+   radeon_bs_code_fixed_bits(bs, pt->general_tier_flag, 1);
+   radeon_bs_code_fixed_bits(bs, pt->general_profile_idc, 5);
+   radeon_bs_code_fixed_bits(bs, pt->general_profile_compatibility_flag, 32);
+   radeon_bs_code_fixed_bits(bs, pt->general_progressive_source_flag, 1);
+   radeon_bs_code_fixed_bits(bs, pt->general_interlaced_source_flag, 1);
+   radeon_bs_code_fixed_bits(bs, pt->general_non_packed_constraint_flag, 1);
+   radeon_bs_code_fixed_bits(bs, pt->general_frame_only_constraint_flag, 1);
+   /* general_reserved_zero_44bits */
+   radeon_bs_code_fixed_bits(bs, 0x0, 16);
+   radeon_bs_code_fixed_bits(bs, 0x0, 16);
+   radeon_bs_code_fixed_bits(bs, 0x0, 12);
+}
+
+void radeon_bs_hevc_profile_tier_level(struct radeon_bitstream *bs,
+                                       uint32_t max_num_sub_layers_minus1,
+                                       struct pipe_h265_profile_tier_level *ptl)
+{
+   uint32_t i;
+
+   radeon_bs_hevc_profile_tier(bs, &ptl->profile_tier);
+   radeon_bs_code_fixed_bits(bs, ptl->general_level_idc, 8);
+
+   for (i = 0; i < max_num_sub_layers_minus1; ++i) {
+      radeon_bs_code_fixed_bits(bs, ptl->sub_layer_profile_present_flag[i], 1);
+      radeon_bs_code_fixed_bits(bs, ptl->sub_layer_level_present_flag[i], 1);
+   }
+
+   if (max_num_sub_layers_minus1 > 0) {
+      for (i = max_num_sub_layers_minus1; i < 8; ++i)
+         radeon_bs_code_fixed_bits(bs, 0x0, 2); /* reserved_zero_2bits */
+   }
+
+   for (i = 0; i < max_num_sub_layers_minus1; ++i) {
+      if (ptl->sub_layer_profile_present_flag[i])
+         radeon_bs_hevc_profile_tier(bs, &ptl->sub_layer_profile_tier[i]);
+
+      if (ptl->sub_layer_level_present_flag[i])
+         radeon_bs_code_fixed_bits(bs, ptl->sub_layer_level_idc[i], 8);
+   }
+}
+
+static void radeon_bs_hevc_sub_layer_hrd_parameters(struct radeon_bitstream *bs,
+                                                    uint32_t cpb_cnt,
+                                                    uint32_t sub_pic_hrd_params_present_flag,
+                                                    struct pipe_h265_enc_sublayer_hrd_params *hrd)
+{
+   for (uint32_t i = 0; i < cpb_cnt; i++) {
+      radeon_bs_code_ue(bs, hrd->bit_rate_value_minus1[i]);
+      radeon_bs_code_ue(bs, hrd->cpb_size_value_minus1[i]);
+      if (sub_pic_hrd_params_present_flag) {
+         radeon_bs_code_ue(bs, hrd->cpb_size_du_value_minus1[i]);
+         radeon_bs_code_ue(bs, hrd->bit_rate_du_value_minus1[i]);
+      }
+      radeon_bs_code_fixed_bits(bs, hrd->cbr_flag[i], 1);
+   }
+}
+
+void radeon_bs_hevc_hrd_parameters(struct radeon_bitstream *bs,
+                                   uint32_t common_inf_present_flag,
+                                   uint32_t max_sub_layers_minus1,
+                                   struct pipe_h265_enc_hrd_params *hrd)
+{
+   if (common_inf_present_flag) {
+      radeon_bs_code_fixed_bits(bs, hrd->nal_hrd_parameters_present_flag, 1);
+      radeon_bs_code_fixed_bits(bs, hrd->vcl_hrd_parameters_present_flag, 1);
+      if (hrd->nal_hrd_parameters_present_flag || hrd->vcl_hrd_parameters_present_flag) {
+         radeon_bs_code_fixed_bits(bs, hrd->sub_pic_hrd_params_present_flag, 1);
+         if (hrd->sub_pic_hrd_params_present_flag) {
+            radeon_bs_code_fixed_bits(bs, hrd->tick_divisor_minus2, 8);
+            radeon_bs_code_fixed_bits(bs, hrd->du_cpb_removal_delay_increment_length_minus1, 5);
+            radeon_bs_code_fixed_bits(bs, hrd->sub_pic_hrd_params_present_flag, 1);
+            radeon_bs_code_fixed_bits(bs, hrd->dpb_output_delay_du_length_minus1, 5);
+         }
+         radeon_bs_code_fixed_bits(bs, hrd->bit_rate_scale, 4);
+         radeon_bs_code_fixed_bits(bs, hrd->cpb_rate_scale, 4);
+         if (hrd->sub_pic_hrd_params_present_flag)
+            radeon_bs_code_fixed_bits(bs, hrd->cpb_size_du_scale, 4);
+         radeon_bs_code_fixed_bits(bs, hrd->initial_cpb_removal_delay_length_minus1, 5);
+         radeon_bs_code_fixed_bits(bs, hrd->au_cpb_removal_delay_length_minus1, 5);
+         radeon_bs_code_fixed_bits(bs, hrd->dpb_output_delay_length_minus1, 5);
+      }
+   }
+
+   for (uint32_t i = 0; i <= max_sub_layers_minus1; i++) {
+      radeon_bs_code_fixed_bits(bs, hrd->fixed_pic_rate_general_flag[i], 1);
+      if (!hrd->fixed_pic_rate_general_flag[i])
+         radeon_bs_code_fixed_bits(bs, hrd->fixed_pic_rate_within_cvs_flag[i], 1);
+      if (hrd->fixed_pic_rate_within_cvs_flag[i])
+         radeon_bs_code_ue(bs, hrd->elemental_duration_in_tc_minus1[i]);
+      else
+         radeon_bs_code_fixed_bits(bs, hrd->low_delay_hrd_flag[i], 1);
+      if (!hrd->low_delay_hrd_flag[i])
+         radeon_bs_code_ue(bs, hrd->cpb_cnt_minus1[i]);
+      if (hrd->nal_hrd_parameters_present_flag) {
+         radeon_bs_hevc_sub_layer_hrd_parameters(bs,
+                                                 hrd->cpb_cnt_minus1[i] + 1,
+                                                 hrd->sub_pic_hrd_params_present_flag,
+                                                 &hrd->nal_hrd_parameters[i]);
+      }
+      if (hrd->vcl_hrd_parameters_present_flag) {
+         radeon_bs_hevc_sub_layer_hrd_parameters(bs,
+                                                 hrd->cpb_cnt_minus1[i] + 1,
+                                                 hrd->sub_pic_hrd_params_present_flag,
+                                                 &hrd->vlc_hrd_parameters[i]);
+      }
+   }
+}
+
+/* returns NumPicTotalCurr */
+uint32_t radeon_bs_hevc_st_ref_pic_set(struct radeon_bitstream *bs,
+                                       uint32_t index,
+                                       uint32_t num_short_term_ref_pic_sets,
+                                       struct pipe_h265_st_ref_pic_set *st_rps)
+{
+   struct pipe_h265_st_ref_pic_set *ref_rps = NULL;
+   struct pipe_h265_st_ref_pic_set *rps = &st_rps[index];
+   uint32_t i, num_pic_total_curr = 0;
+
+   if (index)
+      radeon_bs_code_fixed_bits(bs, rps->inter_ref_pic_set_prediction_flag, 1);
+
+   if (rps->inter_ref_pic_set_prediction_flag) {
+      if (index == num_short_term_ref_pic_sets)
+         radeon_bs_code_ue(bs, rps->delta_idx_minus1);
+      radeon_bs_code_fixed_bits(bs, rps->delta_rps_sign, 1);
+      radeon_bs_code_ue(bs, rps->abs_delta_rps_minus1);
+      ref_rps = st_rps + index +
+         (1 - 2 * rps->delta_rps_sign) * (st_rps->delta_idx_minus1 + 1);
+      for (i = 0; i <= (ref_rps->num_negative_pics + ref_rps->num_positive_pics); i++) {
+         radeon_bs_code_fixed_bits(bs, rps->used_by_curr_pic_flag[i], 1);
+         if (!rps->used_by_curr_pic_flag[i])
+            radeon_bs_code_fixed_bits(bs, rps->use_delta_flag[i], 1);
+      }
+   } else {
+      radeon_bs_code_ue(bs, rps->num_negative_pics);
+      radeon_bs_code_ue(bs, rps->num_positive_pics);
+      for (i = 0; i < rps->num_negative_pics; i++) {
+         radeon_bs_code_ue(bs, rps->delta_poc_s0_minus1[i]);
+         radeon_bs_code_fixed_bits(bs, rps->used_by_curr_pic_s0_flag[i], 1);
+         if (rps->used_by_curr_pic_s0_flag[i])
+            num_pic_total_curr++;
+      }
+      for (i = 0; i < st_rps->num_positive_pics; i++) {
+         radeon_bs_code_ue(bs, rps->delta_poc_s1_minus1[i]);
+         radeon_bs_code_fixed_bits(bs, rps->used_by_curr_pic_s1_flag[i], 1);
+         if (rps->used_by_curr_pic_s1_flag[i])
+            num_pic_total_curr++;
+      }
+   }
+
+   return num_pic_total_curr;
+}
diff --git a/src/gallium/drivers/radeonsi/radeon_bitstream.h b/src/gallium/drivers/radeonsi/radeon_bitstream.h
new file mode 100644
index 0000000000000..2713cdfae6bff
--- /dev/null
+++ b/src/gallium/drivers/radeonsi/radeon_bitstream.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2025 Advanced Micro Devices, Inc.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#ifndef RADEON_BITSTREAM_H
+#define RADEON_BITSTREAM_H
+
+#include "pipe/p_video_state.h"
+#include "winsys/radeon_winsys.h"
+
+struct radeon_bitstream {
+   bool emulation_prevention;
+   uint32_t shifter;
+   uint32_t bits_in_shifter;
+   uint32_t num_zeros;
+   uint32_t byte_index;
+   uint32_t bits_output;
+   uint32_t bits_size;
+   uint8_t *buf;
+   struct radeon_cmdbuf *cs;
+};
+
+void radeon_bs_reset(struct radeon_bitstream *bs, uint8_t *out, struct radeon_cmdbuf *cs);
+void radeon_bs_set_emulation_prevention(struct radeon_bitstream *bs, bool set);
+void radeon_bs_byte_align(struct radeon_bitstream *bs);
+void radeon_bs_flush_headers(struct radeon_bitstream *bs);
+
+void radeon_bs_code_fixed_bits(struct radeon_bitstream *bs, uint32_t value, uint32_t num_bits);
+void radeon_bs_code_ue(struct radeon_bitstream *bs, uint32_t value);
+void radeon_bs_code_se(struct radeon_bitstream *bs, int32_t value);
+void radeon_bs_code_uvlc(struct radeon_bitstream *bs, uint32_t value);
+void radeon_bs_code_ns(struct radeon_bitstream *bs, uint32_t value, uint32_t max);
+
+void radeon_bs_h264_hrd_parameters(struct radeon_bitstream *bs,
+                                   struct pipe_h264_enc_hrd_params *hrd);
+
+void radeon_bs_hevc_profile_tier_level(struct radeon_bitstream *bs,
+                                       uint32_t max_num_sub_layers_minus1,
+                                       struct pipe_h265_profile_tier_level *ptl);
+
+void radeon_bs_hevc_hrd_parameters(struct radeon_bitstream *bs,
+                                   uint32_t common_inf_present_flag,
+                                   uint32_t max_sub_layers_minus1,
+                                   struct pipe_h265_enc_hrd_params *hrd);
+
+uint32_t radeon_bs_hevc_st_ref_pic_set(struct radeon_bitstream *bs,
+                                       uint32_t index,
+                                       uint32_t num_short_term_ref_pic_sets,
+                                       struct pipe_h265_st_ref_pic_set *st_rps);
+
+#endif
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
index 3eb6b198e8a84..a828f80d909a8 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
@@ -17,8 +17,6 @@
 #include "util/u_video.h"
 #include "vl/vl_video_buffer.h"
 
-static const unsigned index_to_shifts[4] = {24, 16, 8, 0};
-
 /* set quality modes from the input */
 static void radeon_vcn_enc_quality_modes(struct radeon_encoder *enc,
                                          struct pipe_enc_quality_modes *in)
@@ -1980,7 +1978,6 @@ struct pipe_video_codec *radeon_create_encoder(struct pipe_context *context,
    enc->base.fence_wait = radeon_enc_fence_wait;
    enc->base.destroy_fence = radeon_enc_destroy_fence;
    enc->get_buffer = get_buffer;
-   enc->bits_in_shifter = 0;
    enc->screen = context->screen;
    enc->ws = ws;
 
@@ -2048,96 +2045,6 @@ void radeon_enc_add_buffer(struct radeon_encoder *enc, struct pb_buffer_lean *bu
    RADEON_ENC_CS(addr);
 }
 
-void radeon_enc_set_emulation_prevention(struct radeon_encoder *enc, bool set)
-{
-   if (set != enc->emulation_prevention) {
-      enc->emulation_prevention = set;
-      enc->num_zeros = 0;
-   }
-}
-
-void radeon_enc_set_output_buffer(struct radeon_encoder *enc, uint8_t *buffer)
-{
-   enc->bits_buf = buffer;
-   enc->bits_buf_pos = 0;
-}
-
-void radeon_enc_output_one_byte(struct radeon_encoder *enc, unsigned char byte)
-{
-   if (enc->bits_buf) {
-      enc->bits_buf[enc->bits_buf_pos++] = byte;
-      return;
-   }
-
-   if (enc->byte_index == 0)
-      enc->cs.current.buf[enc->cs.current.cdw] = 0;
-   enc->cs.current.buf[enc->cs.current.cdw] |=
-      ((unsigned int)(byte) << index_to_shifts[enc->byte_index]);
-   enc->byte_index++;
-
-   if (enc->byte_index >= 4) {
-      enc->byte_index = 0;
-      enc->cs.current.cdw++;
-   }
-}
-
-void radeon_enc_emulation_prevention(struct radeon_encoder *enc, unsigned char byte)
-{
-   if (enc->emulation_prevention) {
-      if ((enc->num_zeros >= 2) && ((byte == 0x00) || (byte == 0x01) ||
-         (byte == 0x02) || (byte == 0x03))) {
-         radeon_enc_output_one_byte(enc, 0x03);
-         enc->bits_output += 8;
-         enc->num_zeros = 0;
-      }
-      enc->num_zeros = (byte == 0 ? (enc->num_zeros + 1) : 0);
-   }
-}
-
-void radeon_enc_code_fixed_bits(struct radeon_encoder *enc, unsigned int value,
-                                unsigned int num_bits)
-{
-   unsigned int bits_to_pack = 0;
-   enc->bits_size += num_bits;
-
-   while (num_bits > 0) {
-      unsigned int value_to_pack = value & (0xffffffff >> (32 - num_bits));
-      bits_to_pack =
-         num_bits > (32 - enc->bits_in_shifter) ? (32 - enc->bits_in_shifter) : num_bits;
-
-      if (bits_to_pack < num_bits)
-         value_to_pack = value_to_pack >> (num_bits - bits_to_pack);
-
-      enc->shifter |= value_to_pack << (32 - enc->bits_in_shifter - bits_to_pack);
-      num_bits -= bits_to_pack;
-      enc->bits_in_shifter += bits_to_pack;
-
-      while (enc->bits_in_shifter >= 8) {
-         unsigned char output_byte = (unsigned char)(enc->shifter >> 24);
-         enc->shifter <<= 8;
-         radeon_enc_emulation_prevention(enc, output_byte);
-         radeon_enc_output_one_byte(enc, output_byte);
-         enc->bits_in_shifter -= 8;
-         enc->bits_output += 8;
-      }
-   }
-}
-
-void radeon_enc_code_uvlc(struct radeon_encoder *enc, unsigned int value)
-{
-   uint32_t num_bits = 0;
-   uint64_t value_plus1 = (uint64_t)value + 1;
-   uint32_t num_leading_zeros = 0;
-
-   while ((uint64_t)1 << num_bits <= value_plus1)
-      num_bits++;
-
-   num_leading_zeros = num_bits - 1;
-   radeon_enc_code_fixed_bits(enc, 0, num_leading_zeros);
-   radeon_enc_code_fixed_bits(enc, 1, 1);
-   radeon_enc_code_fixed_bits(enc, (uint32_t)value_plus1, num_leading_zeros);
-}
-
 void radeon_enc_code_leb128(uint8_t *buf, uint32_t value,
                             uint32_t num_bytes)
 {
@@ -2156,71 +2063,6 @@ void radeon_enc_code_leb128(uint8_t *buf, uint32_t value,
    } while((leb128_byte & 0x80));
 }
 
-void radeon_enc_reset(struct radeon_encoder *enc)
-{
-   enc->emulation_prevention = false;
-   enc->shifter = 0;
-   enc->bits_in_shifter = 0;
-   enc->bits_output = 0;
-   enc->num_zeros = 0;
-   enc->byte_index = 0;
-   enc->bits_size = 0;
-   enc->bits_buf = NULL;
-   enc->bits_buf_pos = 0;
-}
-
-void radeon_enc_byte_align(struct radeon_encoder *enc)
-{
-   unsigned int num_padding_zeros = (32 - enc->bits_in_shifter) % 8;
-
-   if (num_padding_zeros > 0)
-      radeon_enc_code_fixed_bits(enc, 0, num_padding_zeros);
-}
-
-void radeon_enc_flush_headers(struct radeon_encoder *enc)
-{
-   if (enc->bits_in_shifter != 0) {
-      unsigned char output_byte = (unsigned char)(enc->shifter >> 24);
-      radeon_enc_emulation_prevention(enc, output_byte);
-      radeon_enc_output_one_byte(enc, output_byte);
-      enc->bits_output += enc->bits_in_shifter;
-      enc->shifter = 0;
-      enc->bits_in_shifter = 0;
-      enc->num_zeros = 0;
-   }
-
-   if (enc->byte_index > 0) {
-      enc->cs.current.cdw++;
-      enc->byte_index = 0;
-   }
-}
-
-void radeon_enc_code_ue(struct radeon_encoder *enc, unsigned int value)
-{
-   unsigned int x = 0;
-   unsigned int ue_code = value + 1;
-   value += 1;
-
-   while (value) {
-      value = (value >> 1);
-      x += 1;
-   }
-
-   if (x > 1)
-     radeon_enc_code_fixed_bits(enc, 0, x - 1);
-   radeon_enc_code_fixed_bits(enc, ue_code, x);
-}
-
-void radeon_enc_code_se(struct radeon_encoder *enc, int value)
-{
-   unsigned int v = 0;
-
-   if (value != 0)
-      v = (value < 0 ? ((unsigned int)(0 - value) << 1) : (((unsigned int)(value) << 1) - 1));
-
-   radeon_enc_code_ue(enc, v);
-}
-
 unsigned int radeon_enc_av1_tile_log2(unsigned int blk_size, unsigned int max)
 {
    unsigned int k;
@@ -2231,30 +2073,6 @@ unsigned int radeon_enc_av1_tile_log2(unsigned int blk_size, unsigned int max)
    return k;
 }
 
-void radeon_enc_code_ns(struct radeon_encoder *enc, unsigned int value, unsigned int max)
-{
-   unsigned w = 0;
-   unsigned m;
-   unsigned max_num = max;
-
-   while ( max_num ) {
-      max_num >>= 1;
-      w++;
-   }
-
-   m = ( 1 << w ) - max;
-
-   assert(w > 1);
-
-   if ( value < m )
-      radeon_enc_code_fixed_bits(enc, value, (w - 1));
-   else {
-      unsigned diff = value - m;
-      unsigned out = (((diff >> 1) + m) << 1) | (diff & 0x1);
-      radeon_enc_code_fixed_bits(enc, out, w);
-   }
-}
-
 /* dummy function for re-using the same pipeline */
 void radeon_enc_dummy(struct radeon_encoder *enc) {}
 
@@ -2269,13 +2087,14 @@ static void radeon_enc_av1_bs_copy_end(struct radeon_encoder *enc, uint32_t bits
 
 /* av1 bitstream instruction type */
 void radeon_enc_av1_bs_instruction_type(struct radeon_encoder *enc,
+                                        struct radeon_bitstream *bs,
                                         uint32_t inst,
                                         uint32_t obu_type)
 {
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(bs);
 
-   if (enc->bits_output)
-      radeon_enc_av1_bs_copy_end(enc, enc->bits_output);
+   if (bs->bits_output)
+      radeon_enc_av1_bs_copy_end(enc, bs->bits_output);
 
    enc->enc_pic.copy_start = &enc->cs.current.buf[enc->cs.current.cdw++];
    RADEON_ENC_CS(inst);
@@ -2289,7 +2108,7 @@ void radeon_enc_av1_bs_instruction_type(struct radeon_encoder *enc,
    } else
       RADEON_ENC_CS(0); /* allocate a dword for number of bits */
 
-   radeon_enc_reset(enc);
+   radeon_bs_reset(bs, NULL, &enc->cs);
 }
 
 uint32_t radeon_enc_value_bits(uint32_t value)
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.h b/src/gallium/drivers/radeonsi/radeon_vcn_enc.h
index 763a80cfaf238..298004902b6f7 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.h
@@ -11,6 +11,7 @@
 
 #include "radeon_vcn.h"
 #include "util/macros.h"
+#include "radeon_bitstream.h"
 
 #include "ac_vcn_enc.h"
 
@@ -248,19 +249,10 @@ struct radeon_encoder {
    rvcn_enc_cmd_t cmd;
 
    unsigned alignment;
-   unsigned shifter;
-   unsigned bits_in_shifter;
-   unsigned num_zeros;
-   unsigned byte_index;
-   unsigned bits_output;
-   unsigned bits_size;
-   uint8_t *bits_buf;
-   uint32_t bits_buf_pos;
    uint32_t total_task_size;
    uint32_t *p_task_size;
    struct rvcn_sq_var sq;
 
-   bool emulation_prevention;
    bool need_feedback;
    bool need_rate_control;
    bool need_rc_per_pic;
@@ -312,35 +304,9 @@ void radeon_enc_add_buffer(struct radeon_encoder *enc, struct pb_buffer_lean *bu
 
 void radeon_enc_dummy(struct radeon_encoder *enc);
 
-void radeon_enc_set_emulation_prevention(struct radeon_encoder *enc, bool set);
-
-void radeon_enc_set_output_buffer(struct radeon_encoder *enc, uint8_t *buffer);
-
-void radeon_enc_output_one_byte(struct radeon_encoder *enc, unsigned char byte);
-
-void radeon_enc_emulation_prevention(struct radeon_encoder *enc, unsigned char byte);
-
-void radeon_enc_code_fixed_bits(struct radeon_encoder *enc, unsigned int value,
-                                unsigned int num_bits);
-
-void radeon_enc_reset(struct radeon_encoder *enc);
-
-void radeon_enc_byte_align(struct radeon_encoder *enc);
-
-void radeon_enc_flush_headers(struct radeon_encoder *enc);
-
-void radeon_enc_code_ue(struct radeon_encoder *enc, unsigned int value);
-
-void radeon_enc_code_se(struct radeon_encoder *enc, int value);
-
-void radeon_enc_code_uvlc(struct radeon_encoder *enc, unsigned int value);
-
 void radeon_enc_code_leb128(unsigned char *buf, unsigned int value,
                             unsigned int num_bytes);
 
-void radeon_enc_code_ns(struct radeon_encoder *enc, unsigned int value,
-                        unsigned int max);
-
 void radeon_enc_1_2_init(struct radeon_encoder *enc);
 
 void radeon_enc_2_0_init(struct radeon_encoder *enc);
@@ -363,33 +329,15 @@ unsigned int radeon_enc_write_pps_hevc(struct radeon_encoder *enc, uint8_t *out)
 
 unsigned int radeon_enc_write_sequence_header(struct radeon_encoder *enc, uint8_t *obu_bytes, uint8_t *out);
 
-void radeon_enc_hrd_parameters(struct radeon_encoder *enc,
-                               struct pipe_h264_enc_hrd_params *hrd);
-
-void radeon_enc_hevc_profile_tier_level(struct radeon_encoder *enc,
-                                        unsigned int max_num_sub_layers_minus1,
-                                        struct pipe_h265_profile_tier_level *ptl);
-
-void radeon_enc_hevc_hrd_parameters(struct radeon_encoder *enc,
-                                    unsigned int common_inf_present_flag,
-                                    unsigned int max_sub_layers_minus1,
-                                    struct pipe_h265_enc_hrd_params *hrd);
-
-unsigned int radeon_enc_hevc_st_ref_pic_set(struct radeon_encoder *enc,
-                                            unsigned int index,
-                                            unsigned int num_short_term_ref_pic_sets,
-                                            struct pipe_h265_st_ref_pic_set *st_rps);
-
 void radeon_enc_av1_bs_instruction_type(struct radeon_encoder *enc,
+                                        struct radeon_bitstream *bs,
                                         unsigned int inst, unsigned int obu_type);
 
-void radeon_enc_av1_obu_header(struct radeon_encoder *enc, uint32_t obu_type);
-
-void radeon_enc_av1_frame_header_common(struct radeon_encoder *enc, bool frame_header);
+void radeon_enc_av1_obu_header(struct radeon_encoder *enc, struct radeon_bitstream *bs, uint32_t obu_type);
 
-void radeon_enc_av1_tile_group(struct radeon_encoder *enc);
+void radeon_enc_av1_frame_header_common(struct radeon_encoder *enc, struct radeon_bitstream *bs, bool frame_header);
 
-unsigned char *radeon_enc_av1_header_size_offset(struct radeon_encoder *enc);
+void radeon_enc_av1_tile_group(struct radeon_encoder *enc, struct radeon_bitstream *bs);
 
 unsigned int radeon_enc_value_bits(unsigned int value);
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
index b1ec27ed7eaf5..50fac94fcf295 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
@@ -179,157 +179,154 @@ static void radeon_enc_quality_params(struct radeon_encoder *enc)
 
 unsigned int radeon_enc_write_sps(struct radeon_encoder *enc, uint8_t nal_byte, uint8_t *out)
 {
+   struct radeon_bitstream bs;
    struct radeon_enc_pic *pic = &enc->enc_pic;
    struct pipe_h264_enc_seq_param *sps = &pic->h264.desc->seq;
 
-   radeon_enc_reset(enc);
-   radeon_enc_set_output_buffer(enc, out);
-   radeon_enc_set_emulation_prevention(enc, false);
-   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_enc_code_fixed_bits(enc, nal_byte, 8);
-   radeon_enc_byte_align(enc);
-   radeon_enc_set_emulation_prevention(enc, true);
-   radeon_enc_code_fixed_bits(enc, pic->spec_misc.profile_idc, 8);
-   radeon_enc_code_fixed_bits(enc, sps->enc_constraint_set_flags, 6);
-   radeon_enc_code_fixed_bits(enc, 0x0, 2); /* reserved_zero_2bits */
-   radeon_enc_code_fixed_bits(enc, pic->spec_misc.level_idc, 8);
-   radeon_enc_code_ue(enc, 0x0); /* seq_parameter_set_id */
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, nal_byte, 8);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_fixed_bits(&bs, pic->spec_misc.profile_idc, 8);
+   radeon_bs_code_fixed_bits(&bs, sps->enc_constraint_set_flags, 6);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* reserved_zero_2bits */
+   radeon_bs_code_fixed_bits(&bs, pic->spec_misc.level_idc, 8);
+   radeon_bs_code_ue(&bs, 0x0); /* seq_parameter_set_id */
 
    if (pic->spec_misc.profile_idc == 100 || pic->spec_misc.profile_idc == 110 ||
        pic->spec_misc.profile_idc == 122 || pic->spec_misc.profile_idc == 244 ||
        pic->spec_misc.profile_idc == 44  || pic->spec_misc.profile_idc == 83 ||
        pic->spec_misc.profile_idc == 86  || pic->spec_misc.profile_idc == 118 ||
        pic->spec_misc.profile_idc == 128 || pic->spec_misc.profile_idc == 138) {
-      radeon_enc_code_ue(enc, 0x1); /* chroma_format_idc */
-      radeon_enc_code_ue(enc, 0x0); /* bit_depth_luma_minus8 */
-      radeon_enc_code_ue(enc, 0x0); /* bit_depth_chroma_minus8 */
-      radeon_enc_code_fixed_bits(enc, 0x0, 2); /* qpprime_y_zero_transform_bypass_flag + seq_scaling_matrix_present_flag */
+      radeon_bs_code_ue(&bs, 0x1); /* chroma_format_idc */
+      radeon_bs_code_ue(&bs, 0x0); /* bit_depth_luma_minus8 */
+      radeon_bs_code_ue(&bs, 0x0); /* bit_depth_chroma_minus8 */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* qpprime_y_zero_transform_bypass_flag + seq_scaling_matrix_present_flag */
    }
 
-   radeon_enc_code_ue(enc, sps->log2_max_frame_num_minus4);
-   radeon_enc_code_ue(enc, sps->pic_order_cnt_type);
+   radeon_bs_code_ue(&bs, sps->log2_max_frame_num_minus4);
+   radeon_bs_code_ue(&bs, sps->pic_order_cnt_type);
 
    if (sps->pic_order_cnt_type == 0)
-      radeon_enc_code_ue(enc, sps->log2_max_pic_order_cnt_lsb_minus4);
+      radeon_bs_code_ue(&bs, sps->log2_max_pic_order_cnt_lsb_minus4);
 
-   radeon_enc_code_ue(enc, sps->max_num_ref_frames);
-   radeon_enc_code_fixed_bits(enc, sps->gaps_in_frame_num_value_allowed_flag, 1);
-   radeon_enc_code_ue(enc, (pic->session_init.aligned_picture_width / 16 - 1));
-   radeon_enc_code_ue(enc, (pic->session_init.aligned_picture_height / 16 - 1));
-   radeon_enc_code_fixed_bits(enc, 0x1, 1); /* frame_mbs_only_flag */
-   radeon_enc_code_fixed_bits(enc, 0x1, 1); /* direct_8x8_inference_flag */
+   radeon_bs_code_ue(&bs, sps->max_num_ref_frames);
+   radeon_bs_code_fixed_bits(&bs, sps->gaps_in_frame_num_value_allowed_flag, 1);
+   radeon_bs_code_ue(&bs, (pic->session_init.aligned_picture_width / 16 - 1));
+   radeon_bs_code_ue(&bs, (pic->session_init.aligned_picture_height / 16 - 1));
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* frame_mbs_only_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* direct_8x8_inference_flag */
 
-   radeon_enc_code_fixed_bits(enc, sps->enc_frame_cropping_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, sps->enc_frame_cropping_flag, 1);
    if (sps->enc_frame_cropping_flag) {
-      radeon_enc_code_ue(enc, sps->enc_frame_crop_left_offset);
-      radeon_enc_code_ue(enc, sps->enc_frame_crop_right_offset);
-      radeon_enc_code_ue(enc, sps->enc_frame_crop_top_offset);
-      radeon_enc_code_ue(enc, sps->enc_frame_crop_bottom_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_left_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_right_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_top_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_bottom_offset);
    }
 
-   radeon_enc_code_fixed_bits(enc, sps->vui_parameters_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, sps->vui_parameters_present_flag, 1);
    if (sps->vui_parameters_present_flag) {
-      radeon_enc_code_fixed_bits(enc, (sps->vui_flags.aspect_ratio_info_present_flag), 1);
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.aspect_ratio_info_present_flag), 1);
       if (sps->vui_flags.aspect_ratio_info_present_flag) {
-         radeon_enc_code_fixed_bits(enc, (sps->aspect_ratio_idc), 8);
+         radeon_bs_code_fixed_bits(&bs, (sps->aspect_ratio_idc), 8);
          if (sps->aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
-            radeon_enc_code_fixed_bits(enc, (sps->sar_width), 16);
-            radeon_enc_code_fixed_bits(enc, (sps->sar_height), 16);
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_width), 16);
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_height), 16);
          }
       }
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.overscan_info_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_info_present_flag, 1);
       if (sps->vui_flags.overscan_info_present_flag)
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.overscan_appropriate_flag, 1);
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.video_signal_type_present_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_appropriate_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.video_signal_type_present_flag, 1);
       if (sps->vui_flags.video_signal_type_present_flag) {
-         radeon_enc_code_fixed_bits(enc, sps->video_format, 3);
-         radeon_enc_code_fixed_bits(enc, sps->video_full_range_flag, 1);
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.colour_description_present_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->video_format, 3);
+         radeon_bs_code_fixed_bits(&bs, sps->video_full_range_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.colour_description_present_flag, 1);
          if (sps->vui_flags.colour_description_present_flag) {
-            radeon_enc_code_fixed_bits(enc, sps->colour_primaries, 8);
-            radeon_enc_code_fixed_bits(enc, sps->transfer_characteristics, 8);
-            radeon_enc_code_fixed_bits(enc, sps->matrix_coefficients, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->colour_primaries, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->transfer_characteristics, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->matrix_coefficients, 8);
          }
       }
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.chroma_loc_info_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.chroma_loc_info_present_flag, 1);
       if (sps->vui_flags.chroma_loc_info_present_flag) {
-         radeon_enc_code_ue(enc, sps->chroma_sample_loc_type_top_field);
-         radeon_enc_code_ue(enc, sps->chroma_sample_loc_type_bottom_field);
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_top_field);
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_bottom_field);
       }
-      radeon_enc_code_fixed_bits(enc, (sps->vui_flags.timing_info_present_flag), 1);
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.timing_info_present_flag), 1);
       if (sps->vui_flags.timing_info_present_flag) {
-         radeon_enc_code_fixed_bits(enc, (sps->num_units_in_tick), 32);
-         radeon_enc_code_fixed_bits(enc, (sps->time_scale), 32);
-         radeon_enc_code_fixed_bits(enc, (sps->vui_flags.fixed_frame_rate_flag), 1);
+         radeon_bs_code_fixed_bits(&bs, (sps->num_units_in_tick), 32);
+         radeon_bs_code_fixed_bits(&bs, (sps->time_scale), 32);
+         radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.fixed_frame_rate_flag), 1);
       }
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.nal_hrd_parameters_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.nal_hrd_parameters_present_flag, 1);
       if (sps->vui_flags.nal_hrd_parameters_present_flag)
-         radeon_enc_hrd_parameters(enc, &sps->nal_hrd_parameters);
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.vcl_hrd_parameters_present_flag, 1);
+         radeon_bs_h264_hrd_parameters(&bs, &sps->nal_hrd_parameters);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.vcl_hrd_parameters_present_flag, 1);
       if (sps->vui_flags.vcl_hrd_parameters_present_flag)
-         radeon_enc_hrd_parameters(enc, &sps->vcl_hrd_parameters);
+         radeon_bs_h264_hrd_parameters(&bs, &sps->vcl_hrd_parameters);
       if (sps->vui_flags.nal_hrd_parameters_present_flag || sps->vui_flags.vcl_hrd_parameters_present_flag)
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.low_delay_hrd_flag, 1);
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.pic_struct_present_flag, 1);
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.bitstream_restriction_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.low_delay_hrd_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.pic_struct_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.bitstream_restriction_flag, 1);
       if (sps->vui_flags.bitstream_restriction_flag) {
-         radeon_enc_code_fixed_bits(enc, 0x1, 1); /* motion_vectors_over_pic_boundaries_flag */
-         radeon_enc_code_ue(enc, 0x0); /* max_bytes_per_pic_denom */
-         radeon_enc_code_ue(enc, 0x0); /* max_bits_per_mb_denom */
-         radeon_enc_code_ue(enc, 16); /* log2_max_mv_length_horizontal */
-         radeon_enc_code_ue(enc, 16); /* log2_max_mv_length_vertical */
-         radeon_enc_code_ue(enc, sps->max_num_reorder_frames);
-         radeon_enc_code_ue(enc, sps->max_dec_frame_buffering);
+         radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* motion_vectors_over_pic_boundaries_flag */
+         radeon_bs_code_ue(&bs, 0x0); /* max_bytes_per_pic_denom */
+         radeon_bs_code_ue(&bs, 0x0); /* max_bits_per_mb_denom */
+         radeon_bs_code_ue(&bs, 16); /* log2_max_mv_length_horizontal */
+         radeon_bs_code_ue(&bs, 16); /* log2_max_mv_length_vertical */
+         radeon_bs_code_ue(&bs, sps->max_num_reorder_frames);
+         radeon_bs_code_ue(&bs, sps->max_dec_frame_buffering);
       }
    }
 
-   radeon_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_enc_byte_align(enc);
-   radeon_enc_flush_headers(enc);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   return enc->bits_buf_pos;
+   return bs.bits_output / 8;
 }
 
 unsigned int radeon_enc_write_sps_hevc(struct radeon_encoder *enc, uint8_t *out)
 {
+   struct radeon_bitstream bs;
    struct radeon_enc_pic *pic = &enc->enc_pic;
    struct pipe_h265_enc_seq_param *sps = &pic->hevc.desc->seq;
    int i;
 
-   radeon_enc_reset(enc);
-   radeon_enc_set_output_buffer(enc, out);
-   radeon_enc_set_emulation_prevention(enc, false);
-   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_enc_code_fixed_bits(enc, 0x4201, 16);
-   radeon_enc_byte_align(enc);
-   radeon_enc_set_emulation_prevention(enc, true);
-   radeon_enc_code_fixed_bits(enc, 0x0, 4); /* sps_video_parameter_set_id */
-   radeon_enc_code_fixed_bits(enc, sps->sps_max_sub_layers_minus1, 3);
-   radeon_enc_code_fixed_bits(enc, sps->sps_temporal_id_nesting_flag, 1);
-   radeon_enc_hevc_profile_tier_level(enc, sps->sps_max_sub_layers_minus1, &sps->profile_tier_level);
-   radeon_enc_code_ue(enc, 0x0); /* sps_seq_parameter_set_id */
-   radeon_enc_code_ue(enc, sps->chroma_format_idc);
-   radeon_enc_code_ue(enc, pic->session_init.aligned_picture_width);
-   radeon_enc_code_ue(enc, pic->session_init.aligned_picture_height);
-
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, 0x4201, 16);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 4); /* sps_video_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, sps->sps_max_sub_layers_minus1, 3);
+   radeon_bs_code_fixed_bits(&bs, sps->sps_temporal_id_nesting_flag, 1);
+   radeon_bs_hevc_profile_tier_level(&bs, sps->sps_max_sub_layers_minus1, &sps->profile_tier_level);
+   radeon_bs_code_ue(&bs, 0x0); /* sps_seq_parameter_set_id */
+   radeon_bs_code_ue(&bs, sps->chroma_format_idc);
+   radeon_bs_code_ue(&bs, pic->session_init.aligned_picture_width);
+   radeon_bs_code_ue(&bs, pic->session_init.aligned_picture_height);
+
+   radeon_bs_code_fixed_bits(&bs, sps->conformance_window_flag, 1);
    if (sps->conformance_window_flag) {
-      radeon_enc_code_fixed_bits(enc, 0x1, 1);
-      radeon_enc_code_ue(enc, sps->conf_win_left_offset);
-      radeon_enc_code_ue(enc, sps->conf_win_right_offset);
-      radeon_enc_code_ue(enc, sps->conf_win_top_offset);
-      radeon_enc_code_ue(enc, sps->conf_win_bottom_offset);
-   } else
-      radeon_enc_code_fixed_bits(enc, 0x0, 1);
-
-   radeon_enc_code_ue(enc, sps->bit_depth_luma_minus8);
-   radeon_enc_code_ue(enc, sps->bit_depth_chroma_minus8);
-   radeon_enc_code_ue(enc, sps->log2_max_pic_order_cnt_lsb_minus4);
-   radeon_enc_code_fixed_bits(enc, sps->sps_sub_layer_ordering_info_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+      radeon_bs_code_ue(&bs, sps->conf_win_left_offset);
+      radeon_bs_code_ue(&bs, sps->conf_win_right_offset);
+      radeon_bs_code_ue(&bs, sps->conf_win_top_offset);
+      radeon_bs_code_ue(&bs, sps->conf_win_bottom_offset);
+   }
+
+   radeon_bs_code_ue(&bs, sps->bit_depth_luma_minus8);
+   radeon_bs_code_ue(&bs, sps->bit_depth_chroma_minus8);
+   radeon_bs_code_ue(&bs, sps->log2_max_pic_order_cnt_lsb_minus4);
+   radeon_bs_code_fixed_bits(&bs, sps->sps_sub_layer_ordering_info_present_flag, 1);
    i = sps->sps_sub_layer_ordering_info_present_flag ? 0 : sps->sps_max_sub_layers_minus1;
    for (; i <= sps->sps_max_sub_layers_minus1; i++) {
-      radeon_enc_code_ue(enc, sps->sps_max_dec_pic_buffering_minus1[i]);
-      radeon_enc_code_ue(enc, sps->sps_max_num_reorder_pics[i]);
-      radeon_enc_code_ue(enc, sps->sps_max_latency_increase_plus1[i]);
+      radeon_bs_code_ue(&bs, sps->sps_max_dec_pic_buffering_minus1[i]);
+      radeon_bs_code_ue(&bs, sps->sps_max_num_reorder_pics[i]);
+      radeon_bs_code_ue(&bs, sps->sps_max_latency_increase_plus1[i]);
    }
 
    unsigned log2_diff_max_min_luma_coding_block_size =
@@ -340,234 +337,228 @@ unsigned int radeon_enc_write_sps_hevc(struct radeon_encoder *enc, uint8_t *out)
    unsigned max_transform_hierarchy_depth_inter = log2_diff_max_min_luma_coding_block_size + 1;
    unsigned max_transform_hierarchy_depth_intra = max_transform_hierarchy_depth_inter;
 
-   radeon_enc_code_ue(enc, pic->hevc_spec_misc.log2_min_luma_coding_block_size_minus3);
-   radeon_enc_code_ue(enc, log2_diff_max_min_luma_coding_block_size);
-   radeon_enc_code_ue(enc, log2_min_transform_block_size_minus2);
-   radeon_enc_code_ue(enc, log2_diff_max_min_transform_block_size);
-   radeon_enc_code_ue(enc, max_transform_hierarchy_depth_inter);
-   radeon_enc_code_ue(enc, max_transform_hierarchy_depth_intra);
+   radeon_bs_code_ue(&bs, pic->hevc_spec_misc.log2_min_luma_coding_block_size_minus3);
+   radeon_bs_code_ue(&bs, log2_diff_max_min_luma_coding_block_size);
+   radeon_bs_code_ue(&bs, log2_min_transform_block_size_minus2);
+   radeon_bs_code_ue(&bs, log2_diff_max_min_transform_block_size);
+   radeon_bs_code_ue(&bs, max_transform_hierarchy_depth_inter);
+   radeon_bs_code_ue(&bs, max_transform_hierarchy_depth_intra);
 
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* scaling_list_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, !pic->hevc_spec_misc.amp_disabled, 1);
-   radeon_enc_code_fixed_bits(enc, !pic->hevc_deblock.disable_sao, 1);
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* pcm_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* scaling_list_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, !pic->hevc_spec_misc.amp_disabled, 1);
+   radeon_bs_code_fixed_bits(&bs, !pic->hevc_deblock.disable_sao, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pcm_enabled_flag */
 
-   radeon_enc_code_ue(enc, sps->num_short_term_ref_pic_sets);
+   radeon_bs_code_ue(&bs, sps->num_short_term_ref_pic_sets);
    for (i = 0; i < sps->num_short_term_ref_pic_sets; i++)
-      radeon_enc_hevc_st_ref_pic_set(enc, i, sps->num_short_term_ref_pic_sets, sps->st_ref_pic_set);
+      radeon_bs_hevc_st_ref_pic_set(&bs, i, sps->num_short_term_ref_pic_sets, sps->st_ref_pic_set);
 
-   radeon_enc_code_fixed_bits(enc, sps->long_term_ref_pics_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, sps->long_term_ref_pics_present_flag, 1);
    if (sps->long_term_ref_pics_present_flag) {
-      radeon_enc_code_ue(enc, sps->num_long_term_ref_pics_sps);
+      radeon_bs_code_ue(&bs, sps->num_long_term_ref_pics_sps);
       for (i = 0; i < sps->num_long_term_ref_pics_sps; i++) {
-         radeon_enc_code_fixed_bits(enc, sps->lt_ref_pic_poc_lsb_sps[i], sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
-         radeon_enc_code_fixed_bits(enc, sps->used_by_curr_pic_lt_sps_flag[i], 1);
+         radeon_bs_code_fixed_bits(&bs, sps->lt_ref_pic_poc_lsb_sps[i], sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+         radeon_bs_code_fixed_bits(&bs, sps->used_by_curr_pic_lt_sps_flag[i], 1);
       }
    }
 
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* sps_temporal_mvp_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, pic->hevc_spec_misc.strong_intra_smoothing_enabled, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* sps_temporal_mvp_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, pic->hevc_spec_misc.strong_intra_smoothing_enabled, 1);
 
    /* VUI parameters present flag */
-   radeon_enc_code_fixed_bits(enc, (sps->vui_parameters_present_flag), 1);
+   radeon_bs_code_fixed_bits(&bs, (sps->vui_parameters_present_flag), 1);
    if (sps->vui_parameters_present_flag) {
       /* aspect ratio present flag */
-      radeon_enc_code_fixed_bits(enc, (sps->vui_flags.aspect_ratio_info_present_flag), 1);
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.aspect_ratio_info_present_flag), 1);
       if (sps->vui_flags.aspect_ratio_info_present_flag) {
-         radeon_enc_code_fixed_bits(enc, (sps->aspect_ratio_idc), 8);
+         radeon_bs_code_fixed_bits(&bs, (sps->aspect_ratio_idc), 8);
          if (sps->aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
-            radeon_enc_code_fixed_bits(enc, (sps->sar_width), 16);
-            radeon_enc_code_fixed_bits(enc, (sps->sar_height), 16);
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_width), 16);
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_height), 16);
          }
       }
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.overscan_info_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_info_present_flag, 1);
       if (sps->vui_flags.overscan_info_present_flag)
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.overscan_appropriate_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_appropriate_flag, 1);
       /* video signal type present flag  */
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.video_signal_type_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.video_signal_type_present_flag, 1);
       if (sps->vui_flags.video_signal_type_present_flag) {
-         radeon_enc_code_fixed_bits(enc, sps->video_format, 3);
-         radeon_enc_code_fixed_bits(enc, sps->video_full_range_flag, 1);
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.colour_description_present_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->video_format, 3);
+         radeon_bs_code_fixed_bits(&bs, sps->video_full_range_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.colour_description_present_flag, 1);
          if (sps->vui_flags.colour_description_present_flag) {
-            radeon_enc_code_fixed_bits(enc, sps->colour_primaries, 8);
-            radeon_enc_code_fixed_bits(enc, sps->transfer_characteristics, 8);
-            radeon_enc_code_fixed_bits(enc, sps->matrix_coefficients, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->colour_primaries, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->transfer_characteristics, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->matrix_coefficients, 8);
          }
       }
       /* chroma loc info present flag */
-      radeon_enc_code_fixed_bits(enc, sps->vui_flags.chroma_loc_info_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.chroma_loc_info_present_flag, 1);
       if (sps->vui_flags.chroma_loc_info_present_flag) {
-         radeon_enc_code_ue(enc, sps->chroma_sample_loc_type_top_field);
-         radeon_enc_code_ue(enc, sps->chroma_sample_loc_type_bottom_field);
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_top_field);
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_bottom_field);
       }
-      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* neutral chroma indication flag */
-      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* field seq flag */
-      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* frame field info present flag */
-      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* default display windows flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* neutral chroma indication flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* field seq flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* frame field info present flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* default display windows flag */
       /* vui timing info present flag */
-      radeon_enc_code_fixed_bits(enc, (sps->vui_flags.timing_info_present_flag), 1);
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.timing_info_present_flag), 1);
       if (sps->vui_flags.timing_info_present_flag) {
-         radeon_enc_code_fixed_bits(enc, (sps->num_units_in_tick), 32);
-         radeon_enc_code_fixed_bits(enc, (sps->time_scale), 32);
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.poc_proportional_to_timing_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, (sps->num_units_in_tick), 32);
+         radeon_bs_code_fixed_bits(&bs, (sps->time_scale), 32);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.poc_proportional_to_timing_flag, 1);
          if (sps->vui_flags.poc_proportional_to_timing_flag)
-            radeon_enc_code_ue(enc, sps->num_ticks_poc_diff_one_minus1);
-         radeon_enc_code_fixed_bits(enc, sps->vui_flags.hrd_parameters_present_flag, 1);
+            radeon_bs_code_ue(&bs, sps->num_ticks_poc_diff_one_minus1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.hrd_parameters_present_flag, 1);
          if (sps->vui_flags.hrd_parameters_present_flag)
-            radeon_enc_hevc_hrd_parameters(enc, 1, sps->sps_max_sub_layers_minus1, &sps->hrd_parameters);
+            radeon_bs_hevc_hrd_parameters(&bs, 1, sps->sps_max_sub_layers_minus1, &sps->hrd_parameters);
       }
-      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* bitstream restriction flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* bitstream restriction flag */
    }
-   radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* sps extension present flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* sps extension present flag */
 
-   radeon_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_enc_byte_align(enc);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   radeon_enc_flush_headers(enc);
-   return enc->bits_buf_pos;
+   return bs.bits_output / 8;
 }
 
 unsigned int radeon_enc_write_pps(struct radeon_encoder *enc, uint8_t nal_byte, uint8_t *out)
 {
-   radeon_enc_reset(enc);
-   radeon_enc_set_output_buffer(enc, out);
-   radeon_enc_set_emulation_prevention(enc, false);
-   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_enc_code_fixed_bits(enc, nal_byte, 8);
-   radeon_enc_byte_align(enc);
-   radeon_enc_set_emulation_prevention(enc, true);
-   radeon_enc_code_ue(enc, 0x0); /* pic_parameter_set_id */
-   radeon_enc_code_ue(enc, 0x0); /* seq_parameter_set_id */
-   radeon_enc_code_fixed_bits(enc, (enc->enc_pic.spec_misc.cabac_enable ? 0x1 : 0x0), 1);
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* bottom_field_pic_order_in_frame_present_flag */
-   radeon_enc_code_ue(enc, 0x0); /* num_slice_groups_minus_1 */
-   radeon_enc_code_ue(enc, enc->enc_pic.h264.desc->pic_ctrl.num_ref_idx_l0_default_active_minus1);
-   radeon_enc_code_ue(enc, enc->enc_pic.h264.desc->pic_ctrl.num_ref_idx_l1_default_active_minus1);
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* weighted_pred_flag */
-   radeon_enc_code_fixed_bits(enc, 0x0, 2); /* weighted_bipred_idc */
-   radeon_enc_code_se(enc, 0x0); /* pic_init_qp_minus26 */
-   radeon_enc_code_se(enc, 0x0); /* pic_init_qs_minus26 */
-   radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.cb_qp_offset); /* chroma_qp_index_offset */
-   radeon_enc_code_fixed_bits(enc, (enc->enc_pic.spec_misc.deblocking_filter_control_present_flag), 1);
-   radeon_enc_code_fixed_bits(enc, (enc->enc_pic.spec_misc.constrained_intra_pred_flag), 1);
-   radeon_enc_code_fixed_bits(enc, (enc->enc_pic.spec_misc.redundant_pic_cnt_present_flag), 1);
-   radeon_enc_code_fixed_bits(enc, (enc->enc_pic.spec_misc.transform_8x8_mode), 1);
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* pic_scaling_matrix_present_flag */
-   radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.cr_qp_offset); /* second_chroma_qp_index_offset */
-
-   radeon_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_enc_byte_align(enc);
-
-   radeon_enc_flush_headers(enc);
-   return enc->bits_buf_pos;
+   struct radeon_bitstream bs;
+
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, nal_byte, 8);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_ue(&bs, 0x0); /* pic_parameter_set_id */
+   radeon_bs_code_ue(&bs, 0x0); /* seq_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, (enc->enc_pic.spec_misc.cabac_enable ? 0x1 : 0x0), 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* bottom_field_pic_order_in_frame_present_flag */
+   radeon_bs_code_ue(&bs, 0x0); /* num_slice_groups_minus_1 */
+   radeon_bs_code_ue(&bs, enc->enc_pic.h264.desc->pic_ctrl.num_ref_idx_l0_default_active_minus1);
+   radeon_bs_code_ue(&bs, enc->enc_pic.h264.desc->pic_ctrl.num_ref_idx_l1_default_active_minus1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* weighted_pred_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* weighted_bipred_idc */
+   radeon_bs_code_se(&bs, 0x0); /* pic_init_qp_minus26 */
+   radeon_bs_code_se(&bs, 0x0); /* pic_init_qs_minus26 */
+   radeon_bs_code_se(&bs, enc->enc_pic.h264_deblock.cb_qp_offset); /* chroma_qp_index_offset */
+   radeon_bs_code_fixed_bits(&bs, (enc->enc_pic.spec_misc.deblocking_filter_control_present_flag), 1);
+   radeon_bs_code_fixed_bits(&bs, (enc->enc_pic.spec_misc.constrained_intra_pred_flag), 1);
+   radeon_bs_code_fixed_bits(&bs, (enc->enc_pic.spec_misc.redundant_pic_cnt_present_flag), 1);
+   radeon_bs_code_fixed_bits(&bs, (enc->enc_pic.spec_misc.transform_8x8_mode), 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pic_scaling_matrix_present_flag */
+   radeon_bs_code_se(&bs, enc->enc_pic.h264_deblock.cr_qp_offset); /* second_chroma_qp_index_offset */
+
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
+
+   return bs.bits_output / 8;
 }
 
 unsigned int radeon_enc_write_pps_hevc(struct radeon_encoder *enc, uint8_t *out)
 {
+   struct radeon_bitstream bs;
    struct pipe_h265_enc_pic_param *pps = &enc->enc_pic.hevc.desc->pic;
 
-   radeon_enc_reset(enc);
-   radeon_enc_set_output_buffer(enc, out);
-   radeon_enc_set_emulation_prevention(enc, false);
-   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_enc_code_fixed_bits(enc, 0x4401, 16);
-   radeon_enc_byte_align(enc);
-   radeon_enc_set_emulation_prevention(enc, true);
-   radeon_enc_code_ue(enc, 0x0); /* pps_pic_parameter_set_id */
-   radeon_enc_code_ue(enc, 0x0); /* pps_seq_parameter_set_id */
-   radeon_enc_code_fixed_bits(enc, 0x1, 1); /* dependent_slice_segments_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, pps->output_flag_present_flag, 1);
-   radeon_enc_code_fixed_bits(enc, 0x0, 3); /* num_extra_slice_header_bits */
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* sign_data_hiding_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, 0x1, 1); /* cabac_init_present_flag */
-   radeon_enc_code_ue(enc, pps->num_ref_idx_l0_default_active_minus1);
-   radeon_enc_code_ue(enc, pps->num_ref_idx_l1_default_active_minus1);
-   radeon_enc_code_se(enc, 0x0); /* init_qp_minus26 */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.hevc_spec_misc.constrained_intra_pred_flag, 1);
-   radeon_enc_code_fixed_bits(enc, !enc->enc_pic.hevc_spec_misc.transform_skip_disabled, 1);
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.hevc_spec_misc.cu_qp_delta_enabled_flag, 1);
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, 0x4401, 16);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_ue(&bs, 0x0); /* pps_pic_parameter_set_id */
+   radeon_bs_code_ue(&bs, 0x0); /* pps_seq_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* dependent_slice_segments_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, pps->output_flag_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 3); /* num_extra_slice_header_bits */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* sign_data_hiding_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* cabac_init_present_flag */
+   radeon_bs_code_ue(&bs, pps->num_ref_idx_l0_default_active_minus1);
+   radeon_bs_code_ue(&bs, pps->num_ref_idx_l1_default_active_minus1);
+   radeon_bs_code_se(&bs, 0x0); /* init_qp_minus26 */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_spec_misc.constrained_intra_pred_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, !enc->enc_pic.hevc_spec_misc.transform_skip_disabled, 1);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_spec_misc.cu_qp_delta_enabled_flag, 1);
    if (enc->enc_pic.hevc_spec_misc.cu_qp_delta_enabled_flag)
-      radeon_enc_code_ue(enc, 0); /* diff_cu_qp_delta_depth */
-   radeon_enc_code_se(enc, enc->enc_pic.hevc_deblock.cb_qp_offset);
-   radeon_enc_code_se(enc, enc->enc_pic.hevc_deblock.cr_qp_offset);
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* pps_slice_chroma_qp_offsets_present_flag */
-   radeon_enc_code_fixed_bits(enc, 0x0, 2); /* weighted_pred_flag + weighted_bipred_flag */
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* transquant_bypass_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* tiles_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* entropy_coding_sync_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
-   radeon_enc_code_fixed_bits(enc, 0x1, 1); /* deblocking_filter_control_present_flag */
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* deblocking_filter_override_enabled_flag */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.hevc_deblock.deblocking_filter_disabled, 1);
+      radeon_bs_code_ue(&bs, 0); /* diff_cu_qp_delta_depth */
+   radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.cb_qp_offset);
+   radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.cr_qp_offset);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pps_slice_chroma_qp_offsets_present_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* weighted_pred_flag + weighted_bipred_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* transquant_bypass_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* tiles_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* entropy_coding_sync_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* deblocking_filter_control_present_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* deblocking_filter_override_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_deblock.deblocking_filter_disabled, 1);
 
    if (!enc->enc_pic.hevc_deblock.deblocking_filter_disabled) {
-      radeon_enc_code_se(enc, enc->enc_pic.hevc_deblock.beta_offset_div2);
-      radeon_enc_code_se(enc, enc->enc_pic.hevc_deblock.tc_offset_div2);
+      radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.beta_offset_div2);
+      radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.tc_offset_div2);
    }
 
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* pps_scaling_list_data_present_flag */
-   radeon_enc_code_fixed_bits(enc, pps->lists_modification_present_flag, 1);
-   radeon_enc_code_ue(enc, pps->log2_parallel_merge_level_minus2);
-   radeon_enc_code_fixed_bits(enc, 0x0, 2);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pps_scaling_list_data_present_flag */
+   radeon_bs_code_fixed_bits(&bs, pps->lists_modification_present_flag, 1);
+   radeon_bs_code_ue(&bs, pps->log2_parallel_merge_level_minus2);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2);
 
-   radeon_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_enc_byte_align(enc);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   radeon_enc_flush_headers(enc);
-   return enc->bits_buf_pos;
+   return bs.bits_output / 8;
 }
 
 unsigned int radeon_enc_write_vps(struct radeon_encoder *enc, uint8_t *out)
 {
+   struct radeon_bitstream bs;
    struct pipe_h265_enc_vid_param *vps = &enc->enc_pic.hevc.desc->vid;
    int i;
 
-   radeon_enc_reset(enc);
-   radeon_enc_set_output_buffer(enc, out);
-   radeon_enc_set_emulation_prevention(enc, false);
-   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_enc_code_fixed_bits(enc, 0x4001, 16);
-   radeon_enc_byte_align(enc);
-   radeon_enc_set_emulation_prevention(enc, true);
-
-   radeon_enc_code_fixed_bits(enc, 0x0, 4); /* vps_video_parameter_set_id*/
-   radeon_enc_code_fixed_bits(enc, vps->vps_base_layer_internal_flag, 1);
-   radeon_enc_code_fixed_bits(enc, vps->vps_base_layer_available_flag, 1);
-   radeon_enc_code_fixed_bits(enc, 0x0, 6); /* vps_max_layers_minus1 */
-   radeon_enc_code_fixed_bits(enc, vps->vps_max_sub_layers_minus1, 3);
-   radeon_enc_code_fixed_bits(enc, vps->vps_temporal_id_nesting_flag, 1);
-   radeon_enc_code_fixed_bits(enc, 0xffff, 16); /* vps_reserved_0xffff_16bits */
-   radeon_enc_hevc_profile_tier_level(enc, vps->vps_max_sub_layers_minus1, &vps->profile_tier_level);
-   radeon_enc_code_fixed_bits(enc, vps->vps_sub_layer_ordering_info_present_flag, 1);
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, 0x4001, 16);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 4); /* vps_video_parameter_set_id*/
+   radeon_bs_code_fixed_bits(&bs, vps->vps_base_layer_internal_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, vps->vps_base_layer_available_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 6); /* vps_max_layers_minus1 */
+   radeon_bs_code_fixed_bits(&bs, vps->vps_max_sub_layers_minus1, 3);
+   radeon_bs_code_fixed_bits(&bs, vps->vps_temporal_id_nesting_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0xffff, 16); /* vps_reserved_0xffff_16bits */
+   radeon_bs_hevc_profile_tier_level(&bs, vps->vps_max_sub_layers_minus1, &vps->profile_tier_level);
+   radeon_bs_code_fixed_bits(&bs, vps->vps_sub_layer_ordering_info_present_flag, 1);
    i = vps->vps_sub_layer_ordering_info_present_flag ? 0 : vps->vps_max_sub_layers_minus1;
    for (; i <= vps->vps_max_sub_layers_minus1; i++) {
-      radeon_enc_code_ue(enc, vps->vps_max_dec_pic_buffering_minus1[i]);
-      radeon_enc_code_ue(enc, vps->vps_max_num_reorder_pics[i]);
-      radeon_enc_code_ue(enc, vps->vps_max_latency_increase_plus1[i]);
+      radeon_bs_code_ue(&bs, vps->vps_max_dec_pic_buffering_minus1[i]);
+      radeon_bs_code_ue(&bs, vps->vps_max_num_reorder_pics[i]);
+      radeon_bs_code_ue(&bs, vps->vps_max_latency_increase_plus1[i]);
    }
-   radeon_enc_code_fixed_bits(enc, 0x0, 6); /* vps_max_layer_id */
-   radeon_enc_code_ue(enc, 0x0); /* vps_num_layer_sets_minus1 */
-   radeon_enc_code_fixed_bits(enc, vps->vps_timing_info_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 6); /* vps_max_layer_id */
+   radeon_bs_code_ue(&bs, 0x0); /* vps_num_layer_sets_minus1 */
+   radeon_bs_code_fixed_bits(&bs, vps->vps_timing_info_present_flag, 1);
    if (vps->vps_timing_info_present_flag) {
-      radeon_enc_code_fixed_bits(enc, vps->vps_num_units_in_tick, 32);
-      radeon_enc_code_fixed_bits(enc, vps->vps_time_scale, 32);
-      radeon_enc_code_fixed_bits(enc, vps->vps_poc_proportional_to_timing_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, vps->vps_num_units_in_tick, 32);
+      radeon_bs_code_fixed_bits(&bs, vps->vps_time_scale, 32);
+      radeon_bs_code_fixed_bits(&bs, vps->vps_poc_proportional_to_timing_flag, 1);
       if (vps->vps_poc_proportional_to_timing_flag)
-         radeon_enc_code_ue(enc, vps->vps_num_ticks_poc_diff_one_minus1);
-      radeon_enc_code_ue(enc, 0x0); /* vps_num_hrd_parameters */
+         radeon_bs_code_ue(&bs, vps->vps_num_ticks_poc_diff_one_minus1);
+      radeon_bs_code_ue(&bs, 0x0); /* vps_num_hrd_parameters */
    }
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* vps_extension_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* vps_extension_flag */
 
-   radeon_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_enc_byte_align(enc);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   radeon_enc_flush_headers(enc);
-   return enc->bits_buf_pos;
+   return bs.bits_output / 8;
 }
 
 static void radeon_enc_slice_header(struct radeon_encoder *enc)
 {
+   struct radeon_bitstream bs;
    struct pipe_h264_enc_seq_param *sps = &enc->enc_pic.h264.desc->seq;
    struct pipe_h264_enc_pic_control *pps = &enc->enc_pic.h264.desc->pic_ctrl;
    struct pipe_h264_enc_slice_param *slice = &enc->enc_pic.h264.desc->slice;
@@ -577,19 +568,20 @@ static void radeon_enc_slice_header(struct radeon_encoder *enc)
    unsigned int cdw_start = 0;
    unsigned int cdw_filled = 0;
    unsigned int bits_copied = 0;
+
    RADEON_ENC_BEGIN(enc->cmd.slice_header);
-   radeon_enc_reset(enc);
-   radeon_enc_set_emulation_prevention(enc, false);
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_set_emulation_prevention(&bs, false);
 
    cdw_start = enc->cs.current.cdw;
-   radeon_enc_code_fixed_bits(enc, 0x0, 1); /* forbidden_zero_bit */
-   radeon_enc_code_fixed_bits(enc, pps->nal_ref_idc, 2);
-   radeon_enc_code_fixed_bits(enc, pps->nal_unit_type, 5);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* forbidden_zero_bit */
+   radeon_bs_code_fixed_bits(&bs, pps->nal_ref_idc, 2);
+   radeon_bs_code_fixed_bits(&bs, pps->nal_unit_type, 5);
 
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENCODE_H264_HEADER_INSTRUCTION_FIRST_MB;
@@ -598,26 +590,26 @@ static void radeon_enc_slice_header(struct radeon_encoder *enc)
    switch (enc->enc_pic.picture_type) {
    case PIPE_H2645_ENC_PICTURE_TYPE_I:
    case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
-      radeon_enc_code_fixed_bits(enc, 0x08, 7);
+      radeon_bs_code_fixed_bits(&bs, 0x08, 7);
       break;
    case PIPE_H2645_ENC_PICTURE_TYPE_P:
    case PIPE_H2645_ENC_PICTURE_TYPE_SKIP:
-      radeon_enc_code_fixed_bits(enc, 0x06, 5);
+      radeon_bs_code_fixed_bits(&bs, 0x06, 5);
       break;
    case PIPE_H2645_ENC_PICTURE_TYPE_B:
-      radeon_enc_code_fixed_bits(enc, 0x07, 5);
+      radeon_bs_code_fixed_bits(&bs, 0x07, 5);
       break;
    default:
-      radeon_enc_code_fixed_bits(enc, 0x08, 7);
+      radeon_bs_code_fixed_bits(&bs, 0x08, 7);
    }
 
-   radeon_enc_code_ue(enc, 0x0); /* pic_parameter_set_id */
-   radeon_enc_code_fixed_bits(enc, slice->frame_num, sps->log2_max_frame_num_minus4 + 4);
+   radeon_bs_code_ue(&bs, 0x0); /* pic_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, slice->frame_num, sps->log2_max_frame_num_minus4 + 4);
 
    if (enc->enc_pic.h264_enc_params.input_picture_structure !=
        RENCODE_H264_PICTURE_STRUCTURE_FRAME) {
-      radeon_enc_code_fixed_bits(enc, 0x1, 1);
-      radeon_enc_code_fixed_bits(enc,
+      radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+      radeon_bs_code_fixed_bits(&bs,
                                  enc->enc_pic.h264_enc_params.input_picture_structure ==
                                        RENCODE_H264_PICTURE_STRUCTURE_BOTTOM_FIELD
                                     ? 1
@@ -626,80 +618,80 @@ static void radeon_enc_slice_header(struct radeon_encoder *enc)
    }
 
    if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR)
-      radeon_enc_code_ue(enc, slice->idr_pic_id);
+      radeon_bs_code_ue(&bs, slice->idr_pic_id);
 
    if (sps->pic_order_cnt_type == 0)
-      radeon_enc_code_fixed_bits(enc, slice->pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+      radeon_bs_code_fixed_bits(&bs, slice->pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
 
    if (pps->redundant_pic_cnt_present_flag)
-      radeon_enc_code_ue(enc, slice->redundant_pic_cnt);
+      radeon_bs_code_ue(&bs, slice->redundant_pic_cnt);
 
    if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
-      radeon_enc_code_fixed_bits(enc, 0x1, 1); /* direct_spatial_mv_pred_flag */
+      radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* direct_spatial_mv_pred_flag */
 
    if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
        enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      radeon_enc_code_fixed_bits(enc, slice->num_ref_idx_active_override_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->num_ref_idx_active_override_flag, 1);
       if (slice->num_ref_idx_active_override_flag) {
-         radeon_enc_code_ue(enc, slice->num_ref_idx_l0_active_minus1);
+         radeon_bs_code_ue(&bs, slice->num_ref_idx_l0_active_minus1);
          if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
-            radeon_enc_code_ue(enc, slice->num_ref_idx_l1_active_minus1);
+            radeon_bs_code_ue(&bs, slice->num_ref_idx_l1_active_minus1);
       }
-      radeon_enc_code_fixed_bits(enc, slice->ref_pic_list_modification_flag_l0, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->ref_pic_list_modification_flag_l0, 1);
       if (slice->ref_pic_list_modification_flag_l0) {
          for (unsigned i = 0; i < slice->num_ref_list0_mod_operations; i++) {
             struct pipe_h264_ref_list_mod_entry *op =
                &slice->ref_list0_mod_operations[i];
-            radeon_enc_code_ue(enc, op->modification_of_pic_nums_idc);
+            radeon_bs_code_ue(&bs, op->modification_of_pic_nums_idc);
             if (op->modification_of_pic_nums_idc == 0 ||
                 op->modification_of_pic_nums_idc == 1)
-               radeon_enc_code_ue(enc, op->abs_diff_pic_num_minus1);
+               radeon_bs_code_ue(&bs, op->abs_diff_pic_num_minus1);
             else if (op->modification_of_pic_nums_idc == 2)
-               radeon_enc_code_ue(enc, op->long_term_pic_num);
+               radeon_bs_code_ue(&bs, op->long_term_pic_num);
          }
-         radeon_enc_code_ue(enc, 0x3); /* modification_of_pic_nums_idc */
+         radeon_bs_code_ue(&bs, 0x3); /* modification_of_pic_nums_idc */
       }
       if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-         radeon_enc_code_fixed_bits(enc, slice->ref_pic_list_modification_flag_l1, 1);
+         radeon_bs_code_fixed_bits(&bs, slice->ref_pic_list_modification_flag_l1, 1);
          if (slice->ref_pic_list_modification_flag_l1) {
             for (unsigned i = 0; i < slice->num_ref_list1_mod_operations; i++) {
                struct pipe_h264_ref_list_mod_entry *op =
                   &slice->ref_list1_mod_operations[i];
-               radeon_enc_code_ue(enc, op->modification_of_pic_nums_idc);
+               radeon_bs_code_ue(&bs, op->modification_of_pic_nums_idc);
                if (op->modification_of_pic_nums_idc == 0 ||
                    op->modification_of_pic_nums_idc == 1)
-                  radeon_enc_code_ue(enc, op->abs_diff_pic_num_minus1);
+                  radeon_bs_code_ue(&bs, op->abs_diff_pic_num_minus1);
                else if (op->modification_of_pic_nums_idc == 2)
-                  radeon_enc_code_ue(enc, op->long_term_pic_num);
+                  radeon_bs_code_ue(&bs, op->long_term_pic_num);
             }
-            radeon_enc_code_ue(enc, 0x3); /* modification_of_pic_nums_idc */
+            radeon_bs_code_ue(&bs, 0x3); /* modification_of_pic_nums_idc */
          }
       }
    }
 
    if (!enc->enc_pic.not_referenced) {
       if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) {
-         radeon_enc_code_fixed_bits(enc, slice->no_output_of_prior_pics_flag, 1);
-         radeon_enc_code_fixed_bits(enc, slice->long_term_reference_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, slice->no_output_of_prior_pics_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, slice->long_term_reference_flag, 1);
       } else {
-         radeon_enc_code_fixed_bits(enc, slice->adaptive_ref_pic_marking_mode_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, slice->adaptive_ref_pic_marking_mode_flag, 1);
          if (slice->adaptive_ref_pic_marking_mode_flag) {
             for (unsigned i = 0; i < slice->num_ref_pic_marking_operations; i++) {
                struct pipe_h264_ref_pic_marking_entry *op =
                   &slice->ref_pic_marking_operations[i];
-               radeon_enc_code_ue(enc, op->memory_management_control_operation);
+               radeon_bs_code_ue(&bs, op->memory_management_control_operation);
                if (op->memory_management_control_operation == 1 ||
                    op->memory_management_control_operation == 3)
-                  radeon_enc_code_ue(enc, op->difference_of_pic_nums_minus1);
+                  radeon_bs_code_ue(&bs, op->difference_of_pic_nums_minus1);
                if (op->memory_management_control_operation == 2)
-                  radeon_enc_code_ue(enc, op->long_term_pic_num);
+                  radeon_bs_code_ue(&bs, op->long_term_pic_num);
                if (op->memory_management_control_operation == 3 ||
                    op->memory_management_control_operation == 6)
-                  radeon_enc_code_ue(enc, op->long_term_frame_idx);
+                  radeon_bs_code_ue(&bs, op->long_term_frame_idx);
                if (op->memory_management_control_operation == 4)
-                  radeon_enc_code_ue(enc, op->max_long_term_frame_idx_plus1);
+                  radeon_bs_code_ue(&bs, op->max_long_term_frame_idx_plus1);
             }
-            radeon_enc_code_ue(enc, 0); /* memory_management_control_operation */
+            radeon_bs_code_ue(&bs, 0); /* memory_management_control_operation */
          }
       }
    }
@@ -707,29 +699,29 @@ static void radeon_enc_slice_header(struct radeon_encoder *enc)
    if ((enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_IDR) &&
        (enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_I) &&
        (enc->enc_pic.spec_misc.cabac_enable))
-      radeon_enc_code_ue(enc, enc->enc_pic.spec_misc.cabac_init_idc);
+      radeon_bs_code_ue(&bs, enc->enc_pic.spec_misc.cabac_init_idc);
 
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENCODE_H264_HEADER_INSTRUCTION_SLICE_QP_DELTA;
    inst_index++;
 
    if (enc->enc_pic.spec_misc.deblocking_filter_control_present_flag) {
-      radeon_enc_code_ue(enc, enc->enc_pic.h264_deblock.disable_deblocking_filter_idc);
+      radeon_bs_code_ue(&bs, enc->enc_pic.h264_deblock.disable_deblocking_filter_idc);
       if (!enc->enc_pic.h264_deblock.disable_deblocking_filter_idc) {
-         radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.alpha_c0_offset_div2);
-         radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.beta_offset_div2);
+         radeon_bs_code_se(&bs, enc->enc_pic.h264_deblock.alpha_c0_offset_div2);
+         radeon_bs_code_se(&bs, enc->enc_pic.h264_deblock.beta_offset_div2);
       }
    }
 
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_END;
@@ -748,6 +740,7 @@ static void radeon_enc_slice_header(struct radeon_encoder *enc)
 
 static void radeon_enc_slice_header_hevc(struct radeon_encoder *enc)
 {
+   struct radeon_bitstream bs;
    struct pipe_h265_enc_seq_param *sps = &enc->enc_pic.hevc.desc->seq;
    struct pipe_h265_enc_pic_param *pps = &enc->enc_pic.hevc.desc->pic;
    struct pipe_h265_enc_slice_param *slice = &enc->enc_pic.hevc.desc->slice;
@@ -758,34 +751,35 @@ static void radeon_enc_slice_header_hevc(struct radeon_encoder *enc)
    unsigned int cdw_filled = 0;
    unsigned int bits_copied = 0;
    unsigned int num_pic_total_curr = 0;
+
    RADEON_ENC_BEGIN(enc->cmd.slice_header);
-   radeon_enc_reset(enc);
-   radeon_enc_set_emulation_prevention(enc, false);
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_set_emulation_prevention(&bs, false);
 
    cdw_start = enc->cs.current.cdw;
-   radeon_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.nal_unit_type, 6);
-   radeon_enc_code_fixed_bits(enc, 0x0, 6);
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.temporal_id + 1, 3);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.nal_unit_type, 6);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 6);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.temporal_id + 1, 3);
 
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENCODE_HEVC_HEADER_INSTRUCTION_FIRST_SLICE;
    inst_index++;
 
    if ((enc->enc_pic.nal_unit_type >= 16) && (enc->enc_pic.nal_unit_type <= 23))
-      radeon_enc_code_fixed_bits(enc, slice->no_output_of_prior_pics_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->no_output_of_prior_pics_flag, 1);
 
-   radeon_enc_code_ue(enc, 0x0); /* slice_pic_parameter_set_id */
+   radeon_bs_code_ue(&bs, 0x0); /* slice_pic_parameter_set_id */
 
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENCODE_HEVC_HEADER_INSTRUCTION_SLICE_SEGMENT;
@@ -797,59 +791,59 @@ static void radeon_enc_slice_header_hevc(struct radeon_encoder *enc)
    switch (enc->enc_pic.picture_type) {
    case PIPE_H2645_ENC_PICTURE_TYPE_I:
    case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
-      radeon_enc_code_ue(enc, 0x2);
+      radeon_bs_code_ue(&bs, 0x2);
       break;
    case PIPE_H2645_ENC_PICTURE_TYPE_P:
    case PIPE_H2645_ENC_PICTURE_TYPE_SKIP:
-      radeon_enc_code_ue(enc, 0x1);
+      radeon_bs_code_ue(&bs, 0x1);
       break;
    case PIPE_H2645_ENC_PICTURE_TYPE_B:
-      radeon_enc_code_ue(enc, 0x0);
+      radeon_bs_code_ue(&bs, 0x0);
       break;
    default:
-      radeon_enc_code_ue(enc, 0x1);
+      radeon_bs_code_ue(&bs, 0x1);
    }
 
    if (pps->output_flag_present_flag)
-      radeon_enc_code_fixed_bits(enc, slice->pic_output_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->pic_output_flag, 1);
 
    if ((enc->enc_pic.nal_unit_type != 19) && (enc->enc_pic.nal_unit_type != 20)) {
-      radeon_enc_code_fixed_bits(enc, slice->slice_pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
-      radeon_enc_code_fixed_bits(enc, slice->short_term_ref_pic_set_sps_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->slice_pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+      radeon_bs_code_fixed_bits(&bs, slice->short_term_ref_pic_set_sps_flag, 1);
       if (!slice->short_term_ref_pic_set_sps_flag) {
          num_pic_total_curr =
-            radeon_enc_hevc_st_ref_pic_set(enc, sps->num_short_term_ref_pic_sets,
-                                           sps->num_short_term_ref_pic_sets, sps->st_ref_pic_set);
+            radeon_bs_hevc_st_ref_pic_set(&bs, sps->num_short_term_ref_pic_sets,
+                                          sps->num_short_term_ref_pic_sets, sps->st_ref_pic_set);
       } else if (sps->num_short_term_ref_pic_sets > 1) {
-         radeon_enc_code_fixed_bits(enc, slice->short_term_ref_pic_set_idx,
+         radeon_bs_code_fixed_bits(&bs, slice->short_term_ref_pic_set_idx,
                                     util_logbase2_ceil(sps->num_short_term_ref_pic_sets));
       }
       if (sps->long_term_ref_pics_present_flag) {
          if (sps->num_long_term_ref_pics_sps > 0)
-            radeon_enc_code_ue(enc, slice->num_long_term_sps);
-         radeon_enc_code_ue(enc, slice->num_long_term_pics);
+            radeon_bs_code_ue(&bs, slice->num_long_term_sps);
+         radeon_bs_code_ue(&bs, slice->num_long_term_pics);
          for (unsigned i = 0; i < slice->num_long_term_sps + slice->num_long_term_pics; i++) {
             if (i < slice->num_long_term_sps) {
                if (sps->num_long_term_ref_pics_sps > 1)
-                  radeon_enc_code_fixed_bits(enc, slice->lt_idx_sps[i], util_logbase2_ceil(sps->num_long_term_ref_pics_sps));
+                  radeon_bs_code_fixed_bits(&bs, slice->lt_idx_sps[i], util_logbase2_ceil(sps->num_long_term_ref_pics_sps));
             } else {
-               radeon_enc_code_fixed_bits(enc, slice->poc_lsb_lt[i], sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
-               radeon_enc_code_fixed_bits(enc, slice->used_by_curr_pic_lt_flag[i], 1);
+               radeon_bs_code_fixed_bits(&bs, slice->poc_lsb_lt[i], sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+               radeon_bs_code_fixed_bits(&bs, slice->used_by_curr_pic_lt_flag[i], 1);
                if (slice->used_by_curr_pic_lt_flag[i])
                   num_pic_total_curr++;
             }
-            radeon_enc_code_fixed_bits(enc, slice->delta_poc_msb_present_flag[i], 1);
+            radeon_bs_code_fixed_bits(&bs, slice->delta_poc_msb_present_flag[i], 1);
             if (slice->delta_poc_msb_present_flag[i])
-               radeon_enc_code_ue(enc, slice->delta_poc_msb_cycle_lt[i]);
+               radeon_bs_code_ue(&bs, slice->delta_poc_msb_cycle_lt[i]);
          }
       }
    }
 
    if (!enc->enc_pic.hevc_deblock.disable_sao) {
-      radeon_enc_flush_headers(enc);
+      radeon_bs_flush_headers(&bs);
       instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-      num_bits[inst_index] = enc->bits_output - bits_copied;
-      bits_copied = enc->bits_output;
+      num_bits[inst_index] = bs.bits_output - bits_copied;
+      bits_copied = bs.bits_output;
       inst_index++;
 
       instruction[inst_index] = RENCODE_HEVC_HEADER_INSTRUCTION_SAO_ENABLE;
@@ -858,37 +852,37 @@ static void radeon_enc_slice_header_hevc(struct radeon_encoder *enc)
 
    if ((enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P) ||
        (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)) {
-      radeon_enc_code_fixed_bits(enc, slice->num_ref_idx_active_override_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->num_ref_idx_active_override_flag, 1);
       if (slice->num_ref_idx_active_override_flag) {
-         radeon_enc_code_ue(enc, slice->num_ref_idx_l0_active_minus1);
+         radeon_bs_code_ue(&bs, slice->num_ref_idx_l0_active_minus1);
          if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
-            radeon_enc_code_ue(enc, slice->num_ref_idx_l1_active_minus1);
+            radeon_bs_code_ue(&bs, slice->num_ref_idx_l1_active_minus1);
       }
       if (pps->lists_modification_present_flag && num_pic_total_curr > 1) {
          unsigned num_bits = util_logbase2_ceil(num_pic_total_curr);
          unsigned num_ref_l0_minus1 = slice->num_ref_idx_active_override_flag ?
             slice->num_ref_idx_l0_active_minus1 : pps->num_ref_idx_l0_default_active_minus1;
-         radeon_enc_code_fixed_bits(enc, slice->ref_pic_lists_modification.ref_pic_list_modification_flag_l0, 1);
+         radeon_bs_code_fixed_bits(&bs, slice->ref_pic_lists_modification.ref_pic_list_modification_flag_l0, 1);
          for (unsigned i = 0; i <= num_ref_l0_minus1; i++)
-            radeon_enc_code_fixed_bits(enc, slice->ref_pic_lists_modification.list_entry_l0[i], num_bits);
+            radeon_bs_code_fixed_bits(&bs, slice->ref_pic_lists_modification.list_entry_l0[i], num_bits);
          if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
             unsigned num_ref_l1_minus1 = slice->num_ref_idx_active_override_flag ?
                slice->num_ref_idx_l1_active_minus1 : pps->num_ref_idx_l1_default_active_minus1;
-            radeon_enc_code_fixed_bits(enc, slice->ref_pic_lists_modification.ref_pic_list_modification_flag_l1, 1);
+            radeon_bs_code_fixed_bits(&bs, slice->ref_pic_lists_modification.ref_pic_list_modification_flag_l1, 1);
             for (unsigned i = 0; i <= num_ref_l1_minus1; i++)
-               radeon_enc_code_fixed_bits(enc, slice->ref_pic_lists_modification.list_entry_l1[i], num_bits);
+               radeon_bs_code_fixed_bits(&bs, slice->ref_pic_lists_modification.list_entry_l1[i], num_bits);
          }
       }
       if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
-         radeon_enc_code_fixed_bits(enc, 0x0, 1); /* mvd_l1_zero_flag */
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.hevc_spec_misc.cabac_init_flag, 1);
-      radeon_enc_code_ue(enc, 5 - slice->max_num_merge_cand);
+         radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* mvd_l1_zero_flag */
+      radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_spec_misc.cabac_init_flag, 1);
+      radeon_bs_code_ue(&bs, 5 - slice->max_num_merge_cand);
    }
 
-   radeon_enc_flush_headers(enc);
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENCODE_HEVC_HEADER_INSTRUCTION_SLICE_QP_DELTA;
@@ -898,20 +892,20 @@ static void radeon_enc_slice_header_hevc(struct radeon_encoder *enc)
        (!enc->enc_pic.hevc_deblock.deblocking_filter_disabled ||
         !enc->enc_pic.hevc_deblock.disable_sao)) {
        if (!enc->enc_pic.hevc_deblock.disable_sao) {
-           radeon_enc_flush_headers(enc);
+           radeon_bs_flush_headers(&bs);
            instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-           num_bits[inst_index] = enc->bits_output - bits_copied;
-           bits_copied = enc->bits_output;
+           num_bits[inst_index] = bs.bits_output - bits_copied;
+           bits_copied = bs.bits_output;
            inst_index++;
 
            instruction[inst_index] = RENCODE_HEVC_HEADER_INSTRUCTION_LOOP_FILTER_ACROSS_SLICES_ENABLE;
            inst_index++;
        } else {
-           radeon_enc_code_fixed_bits(enc, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
-           radeon_enc_flush_headers(enc);
+           radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
+           radeon_bs_flush_headers(&bs);
            instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
-           num_bits[inst_index] = enc->bits_output - bits_copied;
-           bits_copied = enc->bits_output;
+           num_bits[inst_index] = bs.bits_output - bits_copied;
+           bits_copied = bs.bits_output;
            inst_index++;
        }
    }
@@ -930,180 +924,6 @@ static void radeon_enc_slice_header_hevc(struct radeon_encoder *enc)
    RADEON_ENC_END();
 }
 
-void radeon_enc_hrd_parameters(struct radeon_encoder *enc,
-                               struct pipe_h264_enc_hrd_params *hrd)
-{
-   radeon_enc_code_ue(enc, hrd->cpb_cnt_minus1);
-   radeon_enc_code_fixed_bits(enc, hrd->bit_rate_scale, 4);
-   radeon_enc_code_fixed_bits(enc, hrd->cpb_size_scale, 4);
-   for (unsigned i = 0; i <= hrd->cpb_cnt_minus1; i++) {
-      radeon_enc_code_ue(enc, hrd->bit_rate_value_minus1[i]);
-      radeon_enc_code_ue(enc, hrd->cpb_size_value_minus1[i]);
-      radeon_enc_code_fixed_bits(enc, hrd->cbr_flag[i], 1);
-   }
-   radeon_enc_code_fixed_bits(enc, hrd->initial_cpb_removal_delay_length_minus1, 5);
-   radeon_enc_code_fixed_bits(enc, hrd->cpb_removal_delay_length_minus1, 5);
-   radeon_enc_code_fixed_bits(enc, hrd->dpb_output_delay_length_minus1, 5);
-   radeon_enc_code_fixed_bits(enc, hrd->time_offset_length, 5);
-}
-
-static void radeon_enc_hevc_profile_tier(struct radeon_encoder *enc,
-                                         struct pipe_h265_profile_tier *pt)
-{
-   radeon_enc_code_fixed_bits(enc, pt->general_profile_space, 2);
-   radeon_enc_code_fixed_bits(enc, pt->general_tier_flag, 1);
-   radeon_enc_code_fixed_bits(enc, pt->general_profile_idc, 5);
-   radeon_enc_code_fixed_bits(enc, pt->general_profile_compatibility_flag, 32);
-   radeon_enc_code_fixed_bits(enc, pt->general_progressive_source_flag, 1);
-   radeon_enc_code_fixed_bits(enc, pt->general_interlaced_source_flag, 1);
-   radeon_enc_code_fixed_bits(enc, pt->general_non_packed_constraint_flag, 1);
-   radeon_enc_code_fixed_bits(enc, pt->general_frame_only_constraint_flag, 1);
-   /* general_reserved_zero_44bits */
-   radeon_enc_code_fixed_bits(enc, 0x0, 16);
-   radeon_enc_code_fixed_bits(enc, 0x0, 16);
-   radeon_enc_code_fixed_bits(enc, 0x0, 12);
-}
-
-void radeon_enc_hevc_profile_tier_level(struct radeon_encoder *enc,
-                                        unsigned int max_num_sub_layers_minus1,
-                                        struct pipe_h265_profile_tier_level *ptl)
-{
-   unsigned i;
-
-   radeon_enc_hevc_profile_tier(enc, &ptl->profile_tier);
-   radeon_enc_code_fixed_bits(enc, ptl->general_level_idc, 8);
-
-   for (i = 0; i < max_num_sub_layers_minus1; ++i) {
-      radeon_enc_code_fixed_bits(enc, ptl->sub_layer_profile_present_flag[i], 1);
-      radeon_enc_code_fixed_bits(enc, ptl->sub_layer_level_present_flag[i], 1);
-   }
-
-   if (max_num_sub_layers_minus1 > 0) {
-      for (i = max_num_sub_layers_minus1; i < 8; ++i)
-         radeon_enc_code_fixed_bits(enc, 0x0, 2); /* reserved_zero_2bits */
-   }
-
-   for (i = 0; i < max_num_sub_layers_minus1; ++i) {
-      if (ptl->sub_layer_profile_present_flag[i])
-         radeon_enc_hevc_profile_tier(enc, &ptl->sub_layer_profile_tier[i]);
-
-      if (ptl->sub_layer_level_present_flag[i])
-         radeon_enc_code_fixed_bits(enc, ptl->sub_layer_level_idc[i], 8);
-   }
-}
-
-static void radeon_enc_hevc_sub_layer_hrd_parameters(struct radeon_encoder *enc,
-                                                     unsigned int cpb_cnt,
-                                                     unsigned int sub_pic_hrd_params_present_flag,
-                                                     struct pipe_h265_enc_sublayer_hrd_params *hrd)
-{
-   for (unsigned i = 0; i < cpb_cnt; i++) {
-      radeon_enc_code_ue(enc, hrd->bit_rate_value_minus1[i]);
-      radeon_enc_code_ue(enc, hrd->cpb_size_value_minus1[i]);
-      if (sub_pic_hrd_params_present_flag) {
-         radeon_enc_code_ue(enc, hrd->cpb_size_du_value_minus1[i]);
-         radeon_enc_code_ue(enc, hrd->bit_rate_du_value_minus1[i]);
-      }
-      radeon_enc_code_fixed_bits(enc, hrd->cbr_flag[i], 1);
-   }
-}
-
-void radeon_enc_hevc_hrd_parameters(struct radeon_encoder *enc,
-                                    unsigned int common_inf_present_flag,
-                                    unsigned int max_sub_layers_minus1,
-                                    struct pipe_h265_enc_hrd_params *hrd)
-{
-   if (common_inf_present_flag) {
-      radeon_enc_code_fixed_bits(enc, hrd->nal_hrd_parameters_present_flag, 1);
-      radeon_enc_code_fixed_bits(enc, hrd->vcl_hrd_parameters_present_flag, 1);
-      if (hrd->nal_hrd_parameters_present_flag || hrd->vcl_hrd_parameters_present_flag) {
-         radeon_enc_code_fixed_bits(enc, hrd->sub_pic_hrd_params_present_flag, 1);
-         if (hrd->sub_pic_hrd_params_present_flag) {
-            radeon_enc_code_fixed_bits(enc, hrd->tick_divisor_minus2, 8);
-            radeon_enc_code_fixed_bits(enc, hrd->du_cpb_removal_delay_increment_length_minus1, 5);
-            radeon_enc_code_fixed_bits(enc, hrd->sub_pic_hrd_params_present_flag, 1);
-            radeon_enc_code_fixed_bits(enc, hrd->dpb_output_delay_du_length_minus1, 5);
-         }
-         radeon_enc_code_fixed_bits(enc, hrd->bit_rate_scale, 4);
-         radeon_enc_code_fixed_bits(enc, hrd->cpb_rate_scale, 4);
-         if (hrd->sub_pic_hrd_params_present_flag)
-            radeon_enc_code_fixed_bits(enc, hrd->cpb_size_du_scale, 4);
-         radeon_enc_code_fixed_bits(enc, hrd->initial_cpb_removal_delay_length_minus1, 5);
-         radeon_enc_code_fixed_bits(enc, hrd->au_cpb_removal_delay_length_minus1, 5);
-         radeon_enc_code_fixed_bits(enc, hrd->dpb_output_delay_length_minus1, 5);
-      }
-   }
-
-   for (unsigned i = 0; i <= max_sub_layers_minus1; i++) {
-      radeon_enc_code_fixed_bits(enc, hrd->fixed_pic_rate_general_flag[i], 1);
-      if (!hrd->fixed_pic_rate_general_flag[i])
-         radeon_enc_code_fixed_bits(enc, hrd->fixed_pic_rate_within_cvs_flag[i], 1);
-      if (hrd->fixed_pic_rate_within_cvs_flag[i])
-         radeon_enc_code_ue(enc, hrd->elemental_duration_in_tc_minus1[i]);
-      else
-         radeon_enc_code_fixed_bits(enc, hrd->low_delay_hrd_flag[i], 1);
-      if (!hrd->low_delay_hrd_flag[i])
-         radeon_enc_code_ue(enc, hrd->cpb_cnt_minus1[i]);
-      if (hrd->nal_hrd_parameters_present_flag) {
-         radeon_enc_hevc_sub_layer_hrd_parameters(enc,
-                                                  hrd->cpb_cnt_minus1[i] + 1,
-                                                  hrd->sub_pic_hrd_params_present_flag,
-                                                  &hrd->nal_hrd_parameters[i]);
-      }
-      if (hrd->vcl_hrd_parameters_present_flag) {
-         radeon_enc_hevc_sub_layer_hrd_parameters(enc,
-                                                  hrd->cpb_cnt_minus1[i] + 1,
-                                                  hrd->sub_pic_hrd_params_present_flag,
-                                                  &hrd->vlc_hrd_parameters[i]);
-      }
-   }
-}
-
-/* returns NumPicTotalCurr */
-unsigned int radeon_enc_hevc_st_ref_pic_set(struct radeon_encoder *enc,
-                                            unsigned int index,
-                                            unsigned int num_short_term_ref_pic_sets,
-                                            struct pipe_h265_st_ref_pic_set *st_rps)
-{
-   struct pipe_h265_st_ref_pic_set *ref_rps = NULL;
-   struct pipe_h265_st_ref_pic_set *rps = &st_rps[index];
-   unsigned i, num_pic_total_curr = 0;
-
-   if (index)
-      radeon_enc_code_fixed_bits(enc, rps->inter_ref_pic_set_prediction_flag, 1);
-
-   if (rps->inter_ref_pic_set_prediction_flag) {
-      if (index == num_short_term_ref_pic_sets)
-         radeon_enc_code_ue(enc, rps->delta_idx_minus1);
-      radeon_enc_code_fixed_bits(enc, rps->delta_rps_sign, 1);
-      radeon_enc_code_ue(enc, rps->abs_delta_rps_minus1);
-      ref_rps = st_rps + index +
-         (1 - 2 * rps->delta_rps_sign) * (st_rps->delta_idx_minus1 + 1);
-      for (i = 0; i <= (ref_rps->num_negative_pics + ref_rps->num_positive_pics); i++) {
-         radeon_enc_code_fixed_bits(enc, rps->used_by_curr_pic_flag[i], 1);
-         if (!rps->used_by_curr_pic_flag[i])
-            radeon_enc_code_fixed_bits(enc, rps->use_delta_flag[i], 1);
-      }
-   } else {
-      radeon_enc_code_ue(enc, rps->num_negative_pics);
-      radeon_enc_code_ue(enc, rps->num_positive_pics);
-      for (i = 0; i < rps->num_negative_pics; i++) {
-         radeon_enc_code_ue(enc, rps->delta_poc_s0_minus1[i]);
-         radeon_enc_code_fixed_bits(enc, rps->used_by_curr_pic_s0_flag[i], 1);
-         if (rps->used_by_curr_pic_s0_flag[i])
-            num_pic_total_curr++;
-      }
-      for (i = 0; i < st_rps->num_positive_pics; i++) {
-         radeon_enc_code_ue(enc, rps->delta_poc_s1_minus1[i]);
-         radeon_enc_code_fixed_bits(enc, rps->used_by_curr_pic_s1_flag[i], 1);
-         if (rps->used_by_curr_pic_s1_flag[i])
-            num_pic_total_curr++;
-      }
-   }
-
-   return num_pic_total_curr;
-}
-
 static void radeon_enc_ctx(struct radeon_encoder *enc)
 {
    enc->enc_pic.ctx_buf.swizzle_mode = 0;
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
index 6fdd14b6a51ab..7f386ad036c50 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
@@ -157,226 +157,226 @@ static void radeon_enc_cdf_default_table(struct radeon_encoder *enc)
    RADEON_ENC_END();
 }
 
-void radeon_enc_av1_obu_header(struct radeon_encoder *enc, uint32_t obu_type)
+void radeon_enc_av1_obu_header(struct radeon_encoder *enc, struct radeon_bitstream *bs, uint32_t obu_type)
 {
    /* obu header () */
    /* obu_forbidden_bit */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
    /* obu_type */
-   radeon_enc_code_fixed_bits(enc, obu_type, 4);
+   radeon_bs_code_fixed_bits(bs, obu_type, 4);
    /* obu_extension_flag */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1.desc->obu_extension_flag ? 1 : 0, 1);
+   radeon_bs_code_fixed_bits(bs, enc->enc_pic.av1.desc->obu_extension_flag ? 1 : 0, 1);
    /* obu_has_size_field */
-   radeon_enc_code_fixed_bits(enc, 1, 1);
+   radeon_bs_code_fixed_bits(bs, 1, 1);
    /* obu_reserved_1bit */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
 
    if (enc->enc_pic.av1.desc->obu_extension_flag) {
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.temporal_id, 3);
-      radeon_enc_code_fixed_bits(enc, 0, 2);  /* spatial_id should always be zero */
-      radeon_enc_code_fixed_bits(enc, 0, 3);  /* reserved 3 bits */
+      radeon_bs_code_fixed_bits(bs, enc->enc_pic.temporal_id, 3);
+      radeon_bs_code_fixed_bits(bs, 0, 2);  /* spatial_id should always be zero */
+      radeon_bs_code_fixed_bits(bs, 0, 3);  /* reserved 3 bits */
    }
 }
 
 unsigned int radeon_enc_write_sequence_header(struct radeon_encoder *enc, uint8_t *obu_bytes, uint8_t *out)
 {
+   struct radeon_bitstream bs;
    uint8_t *size_offset;
    uint32_t obu_size;
    uint32_t width_bits;
    uint32_t height_bits;
    struct pipe_av1_enc_seq_param *seq = &enc->enc_pic.av1.desc->seq;
 
-   radeon_enc_reset(enc);
-   radeon_enc_set_output_buffer(enc, out);
-   radeon_enc_code_fixed_bits(enc, obu_bytes[0], 8);
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_code_fixed_bits(&bs, obu_bytes[0], 8);
    if (obu_bytes[0] & 0x4) /* obu_extension_flag */
-      radeon_enc_code_fixed_bits(enc, obu_bytes[1], 8);
+      radeon_bs_code_fixed_bits(&bs, obu_bytes[1], 8);
 
    /* obu_size, use one byte for header, the size will be written in afterwards */
-   size_offset = &enc->bits_buf[enc->bits_buf_pos];
-   radeon_enc_code_fixed_bits(enc, 0, 8);
+   size_offset = &out[bs.bits_output / 8];
+   radeon_bs_code_fixed_bits(&bs, 0, 8);
 
    /* sequence_header_obu() */
    /*  seq_profile  */
-   radeon_enc_code_fixed_bits(enc, seq->profile, 3);
+   radeon_bs_code_fixed_bits(&bs, seq->profile, 3);
    /*  still_picture */
-   radeon_enc_code_fixed_bits(enc, seq->seq_bits.still_picture, 1);
+   radeon_bs_code_fixed_bits(&bs, seq->seq_bits.still_picture, 1);
    /*  reduced_still_picture_header */
-   radeon_enc_code_fixed_bits(enc, seq->seq_bits.reduced_still_picture_header, 1);
+   radeon_bs_code_fixed_bits(&bs, seq->seq_bits.reduced_still_picture_header, 1);
 
    if (seq->seq_bits.reduced_still_picture_header) {
       /*  seq_level_idx[0]  */
-      radeon_enc_code_fixed_bits(enc, seq->seq_level_idx[0], 5);
+      radeon_bs_code_fixed_bits(&bs, seq->seq_level_idx[0], 5);
    } else {
       /*  timing_info_present_flag  */
-      radeon_enc_code_fixed_bits(enc, seq->seq_bits.timing_info_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, seq->seq_bits.timing_info_present_flag, 1);
 
       if (seq->seq_bits.timing_info_present_flag) {
          /*  num_units_in_display_tick  */
-         radeon_enc_code_fixed_bits(enc, seq->num_units_in_display_tick, 32);
+         radeon_bs_code_fixed_bits(&bs, seq->num_units_in_display_tick, 32);
          /*  time_scale  */
-         radeon_enc_code_fixed_bits(enc, seq->time_scale, 32);
+         radeon_bs_code_fixed_bits(&bs, seq->time_scale, 32);
          /*  equal_picture_interval  */
-         radeon_enc_code_fixed_bits(enc, seq->seq_bits.equal_picture_interval, 1);
+         radeon_bs_code_fixed_bits(&bs, seq->seq_bits.equal_picture_interval, 1);
          /*  num_ticks_per_picture_minus_1  */
           if (seq->seq_bits.equal_picture_interval)
-              radeon_enc_code_uvlc(enc, seq->num_tick_per_picture_minus1);
+              radeon_bs_code_uvlc(&bs, seq->num_tick_per_picture_minus1);
           /*  decoder_model_info_present_flag  */
-          radeon_enc_code_fixed_bits(enc, seq->seq_bits.decoder_model_info_present_flag, 1);
+          radeon_bs_code_fixed_bits(&bs, seq->seq_bits.decoder_model_info_present_flag, 1);
           if (seq->seq_bits.decoder_model_info_present_flag) {
              /*  buffer_delay_length_minus1  */
-             radeon_enc_code_fixed_bits(enc, seq->decoder_model_info.buffer_delay_length_minus1, 5);
+             radeon_bs_code_fixed_bits(&bs, seq->decoder_model_info.buffer_delay_length_minus1, 5);
              /*  num_units_in_decoding_tick  */
-             radeon_enc_code_fixed_bits(enc, seq->decoder_model_info.num_units_in_decoding_tick, 32);
+             radeon_bs_code_fixed_bits(&bs, seq->decoder_model_info.num_units_in_decoding_tick, 32);
              /*  buffer_removal_time_length_minus1  */
-             radeon_enc_code_fixed_bits(enc, seq->decoder_model_info.buffer_removal_time_length_minus1, 5);
+             radeon_bs_code_fixed_bits(&bs, seq->decoder_model_info.buffer_removal_time_length_minus1, 5);
              /*  frame_presentation_time_length_minus1  */
-             radeon_enc_code_fixed_bits(enc, seq->decoder_model_info.frame_presentation_time_length_minus1, 5);
+             radeon_bs_code_fixed_bits(&bs, seq->decoder_model_info.frame_presentation_time_length_minus1, 5);
           }
       }
 
       /*  initial_display_delay_present_flag  */
-      radeon_enc_code_fixed_bits(enc, seq->seq_bits.initial_display_delay_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, seq->seq_bits.initial_display_delay_present_flag, 1);
       /*  operating_points_cnt_minus_1  */
-      radeon_enc_code_fixed_bits(enc, seq->num_temporal_layers - 1, 5);
+      radeon_bs_code_fixed_bits(&bs, seq->num_temporal_layers - 1, 5);
 
       for (uint32_t i = 0; i < seq->num_temporal_layers; i++) {
          /*  operating_point_idc[i]  */
-         radeon_enc_code_fixed_bits(enc, seq->operating_point_idc[i], 12);
+         radeon_bs_code_fixed_bits(&bs, seq->operating_point_idc[i], 12);
          /*  seq_level_idx[i]  */
-         radeon_enc_code_fixed_bits(enc, seq->seq_level_idx[i], 5);
+         radeon_bs_code_fixed_bits(&bs, seq->seq_level_idx[i], 5);
          if (seq->seq_level_idx[i] > 7)
             /*  seq_tier[i]  */
-            radeon_enc_code_fixed_bits(enc, seq->seq_tier[i], 1);
+            radeon_bs_code_fixed_bits(&bs, seq->seq_tier[i], 1);
          if (seq->seq_bits.decoder_model_info_present_flag) {
             /*  decoder_model_present_for_this_op[i]  */
-            radeon_enc_code_fixed_bits(enc, seq->decoder_model_present_for_this_op[i], 1);
+            radeon_bs_code_fixed_bits(&bs, seq->decoder_model_present_for_this_op[i], 1);
             if (seq->decoder_model_present_for_this_op[i]) {
                uint32_t length = seq->decoder_model_info.buffer_delay_length_minus1 + 1;
                /*  decoder_buffer_delay[i]  */
-               radeon_enc_code_fixed_bits(enc, seq->decoder_buffer_delay[i], length);
+               radeon_bs_code_fixed_bits(&bs, seq->decoder_buffer_delay[i], length);
                /*  encoder_buffer_delay[i]  */
-               radeon_enc_code_fixed_bits(enc, seq->encoder_buffer_delay[i], length);
+               radeon_bs_code_fixed_bits(&bs, seq->encoder_buffer_delay[i], length);
                /*  low_delay_mode_flag[i]  */
-               radeon_enc_code_fixed_bits(enc, seq->low_delay_mode_flag[i], 1);
+               radeon_bs_code_fixed_bits(&bs, seq->low_delay_mode_flag[i], 1);
             }
          }
          if (seq->seq_bits.initial_display_delay_present_flag) {
             /*  initial_display_delay_present_for_this_op[i]  */
-            radeon_enc_code_fixed_bits(enc, seq->initial_display_delay_present_for_this_op[i], 1);
+            radeon_bs_code_fixed_bits(&bs, seq->initial_display_delay_present_for_this_op[i], 1);
             if (seq->initial_display_delay_present_for_this_op[i])
                /*  initial_display_delay_minus_1[i]  */
-               radeon_enc_code_fixed_bits(enc, seq->initial_display_delay_minus_1[i], 4);
+               radeon_bs_code_fixed_bits(&bs, seq->initial_display_delay_minus_1[i], 4);
          }
       }
    }
 
    /*  frame_width_bits_minus_1  */
    width_bits = radeon_enc_value_bits(enc->enc_pic.av1.coded_width);
-   radeon_enc_code_fixed_bits(enc, width_bits - 1, 4);
+   radeon_bs_code_fixed_bits(&bs, width_bits - 1, 4);
    /*  frame_height_bits_minus_1  */
    height_bits = radeon_enc_value_bits(enc->enc_pic.av1.coded_height);
-   radeon_enc_code_fixed_bits(enc, height_bits - 1, 4);
+   radeon_bs_code_fixed_bits(&bs, height_bits - 1, 4);
    /*  max_frame_width_minus_1  */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1.coded_width - 1,
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.av1.coded_width - 1,
                                    width_bits);
    /*  max_frame_height_minus_1  */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1.coded_height - 1,
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.av1.coded_height - 1,
                                    height_bits);
 
    if (!seq->seq_bits.reduced_still_picture_header)
       /*  frame_id_numbers_present_flag  */
-      radeon_enc_code_fixed_bits(enc, seq->seq_bits.frame_id_number_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, seq->seq_bits.frame_id_number_present_flag, 1);
 
    if (seq->seq_bits.frame_id_number_present_flag) {
       /*  delta_frame_id_length_minus_2  */
-      radeon_enc_code_fixed_bits(enc, seq->delta_frame_id_length - 2, 4);
+      radeon_bs_code_fixed_bits(&bs, seq->delta_frame_id_length - 2, 4);
       /*  additional_frame_id_length_minus_1  */
-      radeon_enc_code_fixed_bits(enc, seq->additional_frame_id_length - 1, 3);
+      radeon_bs_code_fixed_bits(&bs, seq->additional_frame_id_length - 1, 3);
    }
 
    /*  use_128x128_superblock  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
    /*  enable_filter_intra  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
    /*  enable_intra_edge_filter  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
 
    if (!seq->seq_bits.reduced_still_picture_header) {
       /*  enable_interintra_compound  */
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(&bs, 0, 1);
       /*  enable_masked_compound  */
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(&bs, 0, 1);
       /*  enable_warped_motion  */
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(&bs, 0, 1);
       /*  enable_dual_filter  */
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(&bs, 0, 1);
       /*  enable_order_hint  */
-      radeon_enc_code_fixed_bits(enc, seq->seq_bits.enable_order_hint, 1);
+      radeon_bs_code_fixed_bits(&bs, seq->seq_bits.enable_order_hint, 1);
 
       if (seq->seq_bits.enable_order_hint) {
          /*  enable_jnt_comp  */
-         radeon_enc_code_fixed_bits(enc, 0, 1);
+         radeon_bs_code_fixed_bits(&bs, 0, 1);
          /*  enable_ref_frame_mvs  */
-         radeon_enc_code_fixed_bits(enc, 0, 1);
+         radeon_bs_code_fixed_bits(&bs, 0, 1);
       }
 
       /*  seq_choose_screen_content_tools  */
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.disable_screen_content_tools ? 0 : 1, 1);
+      radeon_bs_code_fixed_bits(&bs, enc->enc_pic.disable_screen_content_tools ? 0 : 1, 1);
       if (enc->enc_pic.disable_screen_content_tools)
          /*  seq_force_screen_content_tools  */
-         radeon_enc_code_fixed_bits(enc, 0, 1);
+         radeon_bs_code_fixed_bits(&bs, 0, 1);
       else
          /*  seq_choose_integer_mv  */
-         radeon_enc_code_fixed_bits(enc, 1, 1);
+         radeon_bs_code_fixed_bits(&bs, 1, 1);
 
       if (seq->seq_bits.enable_order_hint)
          /*  order_hint_bits_minus_1  */
-         radeon_enc_code_fixed_bits(enc, seq->order_hint_bits - 1, 3);
+         radeon_bs_code_fixed_bits(&bs, seq->order_hint_bits - 1, 3);
    }
 
    /*  enable_superres  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
    /*  enable_cdef  */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1_spec_misc.cdef_mode ? 1 : 0, 1);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.av1_spec_misc.cdef_mode ? 1 : 0, 1);
    /*  enable_restoration  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
    /*  high_bitdepth  */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.enc_output_format.output_color_bit_depth, 1);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.enc_output_format.output_color_bit_depth, 1);
    /*  mono_chrome  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
    /*  color_description_present_flag  */
-   radeon_enc_code_fixed_bits(enc, seq->seq_bits.color_description_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, seq->seq_bits.color_description_present_flag, 1);
 
    if (seq->seq_bits.color_description_present_flag) {
       /*  color_primaries  */
-      radeon_enc_code_fixed_bits(enc, seq->color_config.color_primaries, 8);
+      radeon_bs_code_fixed_bits(&bs, seq->color_config.color_primaries, 8);
       /*  transfer_characteristics  */
-      radeon_enc_code_fixed_bits(enc, seq->color_config.transfer_characteristics, 8);
+      radeon_bs_code_fixed_bits(&bs, seq->color_config.transfer_characteristics, 8);
       /*  matrix_coefficients  */
-      radeon_enc_code_fixed_bits(enc, seq->color_config.matrix_coefficients, 8);
+      radeon_bs_code_fixed_bits(&bs, seq->color_config.matrix_coefficients, 8);
    }
    /*  color_range  */
-   radeon_enc_code_fixed_bits(enc, seq->color_config.color_range, 1);
+   radeon_bs_code_fixed_bits(&bs, seq->color_config.color_range, 1);
    /*  chroma_sample_position  */
-   radeon_enc_code_fixed_bits(enc, seq->color_config.chroma_sample_position, 2);
+   radeon_bs_code_fixed_bits(&bs, seq->color_config.chroma_sample_position, 2);
    /*  separate_uv_delta_q  */
    bool separate_delta_q = false;
-   radeon_enc_code_fixed_bits(enc, !!(separate_delta_q), 1);
+   radeon_bs_code_fixed_bits(&bs, !!(separate_delta_q), 1);
    /*  film_grain_params_present  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(&bs, 0, 1);
 
    /*  trailing_one_bit  */
-   radeon_enc_code_fixed_bits(enc, 1, 1);
-   radeon_enc_byte_align(enc);
+   radeon_bs_code_fixed_bits(&bs, 1, 1);
+   radeon_bs_byte_align(&bs);
 
-   obu_size = (uint32_t)(&enc->bits_buf[enc->bits_buf_pos] - size_offset - 1);
+   obu_size = (uint32_t)(&out[bs.bits_output / 8] - size_offset - 1);
    radeon_enc_code_leb128(size_offset, obu_size, 1);
 
-   return enc->bits_buf_pos;
+   return bs.bits_output / 8;
 }
 
-void radeon_enc_av1_frame_header_common(struct radeon_encoder *enc, bool frame_header)
+void radeon_enc_av1_frame_header_common(struct radeon_encoder *enc, struct radeon_bitstream *bs, bool frame_header)
 {
    uint32_t i;
    bool frame_is_intra = enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_KEY ||
@@ -386,53 +386,53 @@ void radeon_enc_av1_frame_header_common(struct radeon_encoder *enc, bool frame_h
    bool error_resilient_mode = false;
    struct pipe_av1_enc_picture_desc *av1 = enc->enc_pic.av1.desc;
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
-   radeon_enc_av1_obu_header(enc, obu_type);
+   radeon_enc_av1_obu_header(enc, bs, obu_type);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_SIZE, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_SIZE, 0);
 
    /*  uncompressed_header() */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
    if (!av1->seq.seq_bits.reduced_still_picture_header) {
-      radeon_enc_code_fixed_bits(enc, 0, 1); /* show_existing_frame */
+      radeon_bs_code_fixed_bits(bs, 0, 1); /* show_existing_frame */
       /*  frame_type  */
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.frame_type, 2);
+      radeon_bs_code_fixed_bits(bs, enc->enc_pic.frame_type, 2);
       /*  show_frame  */
-      radeon_enc_code_fixed_bits(enc, av1->show_frame, 1);
+      radeon_bs_code_fixed_bits(bs, av1->show_frame, 1);
       if (!av1->show_frame)
          /*  showable_frame  */
-         radeon_enc_code_fixed_bits(enc, av1->showable_frame, 1);
+         radeon_bs_code_fixed_bits(bs, av1->showable_frame, 1);
 
       if ((enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_SWITCH) ||
             (enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_KEY && av1->show_frame))
          error_resilient_mode = true;
       else {
          /*  error_resilient_mode  */
-         radeon_enc_code_fixed_bits(enc, enc->enc_pic.enable_error_resilient_mode ? 1 : 0, 1);
+         radeon_bs_code_fixed_bits(bs, enc->enc_pic.enable_error_resilient_mode ? 1 : 0, 1);
          error_resilient_mode = enc->enc_pic.enable_error_resilient_mode;
       }
    }
 
    /*  disable_cdf_update  */
-   radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1_spec_misc.disable_cdf_update ? 1 : 0, 1);
+   radeon_bs_code_fixed_bits(bs, enc->enc_pic.av1_spec_misc.disable_cdf_update ? 1 : 0, 1);
 
    bool allow_screen_content_tools = false;
    if (av1->seq.seq_bits.reduced_still_picture_header || !enc->enc_pic.disable_screen_content_tools) {
       /*  allow_screen_content_tools  */
       allow_screen_content_tools = enc->enc_pic.av1_spec_misc.palette_mode_enable ||
                                    enc->enc_pic.force_integer_mv;
-      radeon_enc_code_fixed_bits(enc, allow_screen_content_tools ? 1 : 0, 1);
+      radeon_bs_code_fixed_bits(bs, allow_screen_content_tools ? 1 : 0, 1);
    }
 
    if (allow_screen_content_tools)
       /*  force_integer_mv  */
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.force_integer_mv ? 1 : 0, 1);
+      radeon_bs_code_fixed_bits(bs, enc->enc_pic.force_integer_mv ? 1 : 0, 1);
 
    if (av1->seq.seq_bits.frame_id_number_present_flag)
       /*  current_frame_id  */
-      radeon_enc_code_fixed_bits(enc, av1->current_frame_id,
+      radeon_bs_code_fixed_bits(bs, av1->current_frame_id,
                                  av1->seq.delta_frame_id_length + av1->seq.additional_frame_id_length);
 
    bool frame_size_override = false;
@@ -441,176 +441,179 @@ void radeon_enc_av1_frame_header_common(struct radeon_encoder *enc, bool frame_h
    else if (!av1->seq.seq_bits.reduced_still_picture_header) {
       /*  frame_size_override_flag  */
       frame_size_override = false;
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(bs, 0, 1);
    }
 
    if (av1->seq.seq_bits.enable_order_hint)
       /*  order_hint  */
-      radeon_enc_code_fixed_bits(enc, av1->order_hint, av1->seq.order_hint_bits);
+      radeon_bs_code_fixed_bits(bs, av1->order_hint, av1->seq.order_hint_bits);
 
    if (!frame_is_intra && !error_resilient_mode)
       /*  primary_ref_frame  */
-      radeon_enc_code_fixed_bits(enc, av1->primary_ref_frame, 3);
+      radeon_bs_code_fixed_bits(bs, av1->primary_ref_frame, 3);
 
    if ((enc->enc_pic.frame_type != PIPE_AV1_ENC_FRAME_TYPE_SWITCH) &&
        (enc->enc_pic.frame_type != PIPE_AV1_ENC_FRAME_TYPE_KEY || !av1->show_frame))
       /*  refresh_frame_flags  */
-      radeon_enc_code_fixed_bits(enc, av1->refresh_frame_flags, 8);
+      radeon_bs_code_fixed_bits(bs, av1->refresh_frame_flags, 8);
 
    if ((!frame_is_intra || av1->refresh_frame_flags != 0xff) &&
                   error_resilient_mode && av1->seq.seq_bits.enable_order_hint)
       for (i = 0; i < RENCODE_AV1_NUM_REF_FRAMES; i++)
          /*  ref_order_hint  */
-         radeon_enc_code_fixed_bits(enc, av1->ref_order_hint[i], av1->seq.order_hint_bits);
+         radeon_bs_code_fixed_bits(bs, av1->ref_order_hint[i], av1->seq.order_hint_bits);
 
    if (frame_is_intra) {
       /*  render_and_frame_size_different  */
-      radeon_enc_code_fixed_bits(enc, av1->enable_render_size ? 1 : 0, 1);
+      radeon_bs_code_fixed_bits(bs, av1->enable_render_size ? 1 : 0, 1);
       if (av1->enable_render_size) {
          /*  render_width_minus_1  */
-         radeon_enc_code_fixed_bits(enc, av1->render_width_minus_1, 16);
+         radeon_bs_code_fixed_bits(bs, av1->render_width_minus_1, 16);
          /*  render_height_minus_1  */
-         radeon_enc_code_fixed_bits(enc, av1->render_height_minus_1, 16);
+         radeon_bs_code_fixed_bits(bs, av1->render_height_minus_1, 16);
       }
       if (!enc->enc_pic.disable_screen_content_tools &&
             (enc->enc_pic.av1_spec_misc.palette_mode_enable || enc->enc_pic.force_integer_mv))
          /*  allow_intrabc  */
-         radeon_enc_code_fixed_bits(enc, 0, 1);
+         radeon_bs_code_fixed_bits(bs, 0, 1);
    } else {
       if (av1->seq.seq_bits.enable_order_hint)
          /*  frame_refs_short_signaling  */
-         radeon_enc_code_fixed_bits(enc, av1->frame_refs_short_signaling, 1);
+         radeon_bs_code_fixed_bits(bs, av1->frame_refs_short_signaling, 1);
       if (av1->frame_refs_short_signaling) {
-         radeon_enc_code_fixed_bits(enc, av1->last_frame_idx, 3);
-         radeon_enc_code_fixed_bits(enc, av1->gold_frame_idx, 3);
+         radeon_bs_code_fixed_bits(bs, av1->last_frame_idx, 3);
+         radeon_bs_code_fixed_bits(bs, av1->gold_frame_idx, 3);
       }
       for (i = 0; i < RENCODE_AV1_REFS_PER_FRAME; i++) {
          /*  ref_frame_idx[i]  */
-         radeon_enc_code_fixed_bits(enc, av1->ref_frame_idx[i], 3);
+         radeon_bs_code_fixed_bits(bs, av1->ref_frame_idx[i], 3);
          if (av1->seq.seq_bits.frame_id_number_present_flag)
             /*  delta_frame_id_minus_1[i]  */
-            radeon_enc_code_fixed_bits(enc, av1->delta_frame_id_minus_1[i], av1->seq.delta_frame_id_length);
+            radeon_bs_code_fixed_bits(bs, av1->delta_frame_id_minus_1[i], av1->seq.delta_frame_id_length);
       }
 
       if (frame_size_override && !error_resilient_mode)
          /*  found_ref  */
-         radeon_enc_code_fixed_bits(enc, 1, 1);
+         radeon_bs_code_fixed_bits(bs, 1, 1);
       else {
          if(frame_size_override) {
             /*  frame_width_minus_1  */
             uint32_t used_bits =
                      radeon_enc_value_bits(enc->enc_pic.av1.coded_width - 1);
-            radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1.coded_width - 1,
-                                            used_bits);
+            radeon_bs_code_fixed_bits(bs, enc->enc_pic.av1.coded_width - 1,
+                                          used_bits);
             /*  frame_height_minus_1  */
             used_bits = radeon_enc_value_bits(enc->enc_pic.av1.coded_height - 1);
-            radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1.coded_height - 1,
-                                            used_bits);
+            radeon_bs_code_fixed_bits(bs, enc->enc_pic.av1.coded_height - 1,
+                                          used_bits);
          }
          /*  render_and_frame_size_different  */
-         radeon_enc_code_fixed_bits(enc, av1->enable_render_size ? 1 : 0, 1);
+         radeon_bs_code_fixed_bits(bs, av1->enable_render_size ? 1 : 0, 1);
          if (av1->enable_render_size) {
             /*  render_width_minus_1  */
-            radeon_enc_code_fixed_bits(enc, av1->render_width_minus_1, 16);
+            radeon_bs_code_fixed_bits(bs, av1->render_width_minus_1, 16);
             /*  render_height_minus_1  */
-            radeon_enc_code_fixed_bits(enc, av1->render_height_minus_1, 16);
+            radeon_bs_code_fixed_bits(bs, av1->render_height_minus_1, 16);
          }
       }
 
       if (enc->enc_pic.disable_screen_content_tools || !enc->enc_pic.force_integer_mv)
          /*  allow_high_precision_mv  */
-         radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_ALLOW_HIGH_PRECISION_MV, 0);
+         radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_ALLOW_HIGH_PRECISION_MV, 0);
 
       /*  read_interpolation_filter  */
-      radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_READ_INTERPOLATION_FILTER, 0);
+      radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_READ_INTERPOLATION_FILTER, 0);
 
-      radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+      radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
       /*  is_motion_mode_switchable  */
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(bs, 0, 1);
    }
 
    if (!av1->seq.seq_bits.reduced_still_picture_header && !enc->enc_pic.av1_spec_misc.disable_cdf_update)
       /*  disable_frame_end_update_cdf  */
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1_spec_misc.disable_frame_end_update_cdf ? 1 : 0, 1);
+      radeon_bs_code_fixed_bits(bs, enc->enc_pic.av1_spec_misc.disable_frame_end_update_cdf ? 1 : 0, 1);
 }
 
-static void radeon_enc_av1_frame_header(struct radeon_encoder *enc, bool frame_header)
+static void radeon_enc_av1_frame_header(struct radeon_encoder *enc, struct radeon_bitstream *bs, bool frame_header)
 {
    bool frame_is_intra = enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_KEY ||
                          enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_INTRA_ONLY;
 
-   radeon_enc_av1_frame_header_common(enc, frame_header);
+   radeon_enc_av1_frame_header_common(enc, bs, frame_header);
 
    /*  tile_info  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_V4_AV1_BITSTREAM_INSTRUCTION_TILE_INFO, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_V4_AV1_BITSTREAM_INSTRUCTION_TILE_INFO, 0);
    /*  quantization_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_V4_AV1_BITSTREAM_INSTRUCTION_QUANTIZATION_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_V4_AV1_BITSTREAM_INSTRUCTION_QUANTIZATION_PARAMS, 0);
    /*  segmentation_enable  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
    /*  delta_q_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_Q_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_Q_PARAMS, 0);
    /*  delta_lf_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_LF_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_LF_PARAMS, 0);
    /*  loop_filter_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_LOOP_FILTER_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_LOOP_FILTER_PARAMS, 0);
    /*  cdef_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_CDEF_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_CDEF_PARAMS, 0);
    /*  lr_params  */
    /*  read_tx_mode  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_READ_TX_MODE, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_READ_TX_MODE, 0);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
    if (!frame_is_intra)
       /*  reference_select  */
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(bs, 0, 1);
 
    /*  reduced_tx_set  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
 
    if (!frame_is_intra)
       for (uint32_t ref = 1 /*LAST_FRAME*/; ref <= 7 /*ALTREF_FRAME*/; ref++)
          /*  is_global  */
-         radeon_enc_code_fixed_bits(enc, 0, 1);
+         radeon_bs_code_fixed_bits(bs, 0, 1);
    /*  film_grain_params() */
 }
 
-void radeon_enc_av1_tile_group(struct radeon_encoder *enc)
+void radeon_enc_av1_tile_group(struct radeon_encoder *enc, struct radeon_bitstream *bs)
 {
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_START,
-                                           RENCODE_OBU_START_TYPE_TILE_GROUP);
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_START,
+                                               RENCODE_OBU_START_TYPE_TILE_GROUP);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
-   radeon_enc_av1_obu_header(enc, RENCODE_OBU_TYPE_TILE_GROUP);
+   radeon_enc_av1_obu_header(enc, bs, RENCODE_OBU_TYPE_TILE_GROUP);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_SIZE, 0);
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_TILE_GROUP_OBU, 0);
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_END, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_SIZE, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_TILE_GROUP_OBU, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_END, 0);
 }
 
 static void radeon_enc_obu_instruction(struct radeon_encoder *enc)
 {
+   struct radeon_bitstream bs;
    bool frame_header = !enc->enc_pic.is_obu_frame;
-   radeon_enc_reset(enc);
+
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+
    RADEON_ENC_BEGIN(enc->cmd.bitstream_instruction_av1);
 
-   radeon_enc_av1_bs_instruction_type(enc,
+   radeon_enc_av1_bs_instruction_type(enc, &bs,
          RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_START,
             frame_header ? RENCODE_OBU_START_TYPE_FRAME_HEADER
                          : RENCODE_OBU_START_TYPE_FRAME);
 
-   radeon_enc_av1_frame_header(enc, frame_header);
+   radeon_enc_av1_frame_header(enc, &bs, frame_header);
 
    if (!frame_header)
-      radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_TILE_GROUP_OBU, 0);
+      radeon_enc_av1_bs_instruction_type(enc, &bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_TILE_GROUP_OBU, 0);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_END, 0);
+   radeon_enc_av1_bs_instruction_type(enc, &bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_END, 0);
 
    if (frame_header)
-      radeon_enc_av1_tile_group(enc);
+      radeon_enc_av1_tile_group(enc, &bs);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_END, 0);
+   radeon_enc_av1_bs_instruction_type(enc, &bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_END, 0);
    RADEON_ENC_END();
 }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_5_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_5_0.c
index 58e334c49d8f9..9757fe30dbb9e 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_5_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_5_0.c
@@ -722,7 +722,7 @@ static void radeon_enc_tile_config_av1(struct radeon_encoder *enc)
    RADEON_ENC_END();
 }
 
-static void radeon_enc_av1_tile_info(struct radeon_encoder *enc)
+static void radeon_enc_av1_tile_info(struct radeon_encoder *enc, struct radeon_bitstream *bs)
 {
    rvcn_enc_av1_tile_config_t *p_config = &enc->enc_pic.av1_tile_config;
    uint32_t i = 0;
@@ -738,17 +738,17 @@ static void radeon_enc_av1_tile_info(struct radeon_encoder *enc)
    TileColsLog2 = util_logbase2_ceil(p_config->num_tile_cols);
    TileRowsLog2 = util_logbase2_ceil(p_config->num_tile_rows);
 
-   radeon_enc_code_fixed_bits(enc, p_config->uniform_tile_spacing, 1);
+   radeon_bs_code_fixed_bits(bs, p_config->uniform_tile_spacing, 1);
    if (p_config->uniform_tile_spacing) {
       for ( i = minLog2TileCols; i < TileColsLog2; i++)
-         radeon_enc_code_fixed_bits(enc, 1, 1);
+         radeon_bs_code_fixed_bits(bs, 1, 1);
 
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(bs, 0, 1);
 
       for ( i = minLog2Tiles - TileColsLog2; i < TileRowsLog2; i++)
-         radeon_enc_code_fixed_bits(enc, 1, 1);
+         radeon_bs_code_fixed_bits(bs, 1, 1);
 
-      radeon_enc_code_fixed_bits(enc, 0, 1);
+      radeon_bs_code_fixed_bits(bs, 0, 1);
    } else {
       uint32_t widestTileSb = 0;
       uint32_t maxWidthInSb = 0;
@@ -758,7 +758,7 @@ static void radeon_enc_av1_tile_info(struct radeon_encoder *enc)
 
       for (i = 0; i < p_config->num_tile_cols; i++) {
          maxWidthInSb = MIN2(sbCols - startSb, maxTileWidthSb);
-         radeon_enc_code_ns(enc, p_config->tile_widths[i] - 1, maxWidthInSb);
+         radeon_bs_code_ns(bs, p_config->tile_widths[i] - 1, maxWidthInSb);
          startSb += p_config->tile_widths[i];
          widestTileSb = MAX2( p_config->tile_widths[i], widestTileSb);
       }
@@ -773,52 +773,52 @@ static void radeon_enc_av1_tile_info(struct radeon_encoder *enc)
 
       for (i = 0; i < p_config->num_tile_rows; i++) {
          maxHeightInSb = MIN2(sbRows - startSb, maxTileHeightSb);
-         radeon_enc_code_ns(enc, p_config->tile_height[i] - 1, maxHeightInSb);
+         radeon_bs_code_ns(bs, p_config->tile_height[i] - 1, maxHeightInSb);
          startSb += p_config->tile_height[i];
       }
    }
 
    if (TileColsLog2 > 0 || TileRowsLog2 > 0) {
-      radeon_enc_av1_bs_instruction_type(enc, RENCODE_V5_AV1_BITSTREAM_INSTRUCTION_CONTEXT_UPDATE_TILE_ID, 0);
+      radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_V5_AV1_BITSTREAM_INSTRUCTION_CONTEXT_UPDATE_TILE_ID, 0);
 
-      radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+      radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
-      radeon_enc_code_fixed_bits(enc, p_config->tile_size_bytes_minus_1, 2);
+      radeon_bs_code_fixed_bits(bs, p_config->tile_size_bytes_minus_1, 2);
    }
 }
 
-static void radeon_enc_av1_write_delta_q(struct radeon_encoder *enc, int32_t q)
+static void radeon_enc_av1_write_delta_q(struct radeon_bitstream *bs, int32_t q)
 {
-   radeon_enc_code_fixed_bits(enc, !!(q), 1);
+   radeon_bs_code_fixed_bits(bs, !!(q), 1);
 
    if (q)
-      radeon_enc_code_fixed_bits(enc, q, ( 1 + 6 ));
+      radeon_bs_code_fixed_bits(bs, q, ( 1 + 6 ));
 }
 
-static void radeon_enc_av1_quantization_params(struct radeon_encoder *enc)
+static void radeon_enc_av1_quantization_params(struct radeon_encoder *enc, struct radeon_bitstream *bs)
 {
    rvcn_enc_av1_spec_misc_t *p = &enc->enc_pic.av1_spec_misc;
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_V5_AV1_BITSTREAM_INSTRUCTION_BASE_Q_IDX, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_V5_AV1_BITSTREAM_INSTRUCTION_BASE_Q_IDX, 0);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
-   radeon_enc_av1_write_delta_q(enc, p->delta_q_y_dc);
+   radeon_enc_av1_write_delta_q(bs, p->delta_q_y_dc);
 
    /* only support multi-planes at the time */
    if (p->separate_delta_q)
-      radeon_enc_code_fixed_bits(enc, 1, 1);
+      radeon_bs_code_fixed_bits(bs, 1, 1);
 
-   radeon_enc_av1_write_delta_q(enc, p->delta_q_u_dc);
-   radeon_enc_av1_write_delta_q(enc, p->delta_q_u_ac);
+   radeon_enc_av1_write_delta_q(bs, p->delta_q_u_dc);
+   radeon_enc_av1_write_delta_q(bs, p->delta_q_u_ac);
 
    if (p->separate_delta_q) {
-      radeon_enc_av1_write_delta_q(enc, p->delta_q_v_dc);
-      radeon_enc_av1_write_delta_q(enc, p->delta_q_v_ac);
+      radeon_enc_av1_write_delta_q(bs, p->delta_q_v_dc);
+      radeon_enc_av1_write_delta_q(bs, p->delta_q_v_ac);
    }
 
    /* using qmatrix */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
 }
 
 static int32_t radeon_enc_av1_get_relative_dist(struct radeon_encoder *enc, uint32_t a, uint32_t b)
@@ -886,74 +886,76 @@ bool radeon_enc_av1_skip_mode_allowed(struct radeon_encoder *enc, uint32_t frame
    return true;
 }
 
-static void radeon_enc_av1_frame_header(struct radeon_encoder *enc, bool frame_header)
+static void radeon_enc_av1_frame_header(struct radeon_encoder *enc, struct radeon_bitstream *bs, bool frame_header)
 {
    bool frame_is_intra = enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_KEY ||
                          enc->enc_pic.frame_type == PIPE_AV1_ENC_FRAME_TYPE_INTRA_ONLY;
 
-   radeon_enc_av1_frame_header_common(enc, frame_header);
+   radeon_enc_av1_frame_header_common(enc, bs, frame_header);
 
    /*  tile_info  */
-   radeon_enc_av1_tile_info(enc);
+   radeon_enc_av1_tile_info(enc, bs);
    /*  quantization_params  */
-   radeon_enc_av1_quantization_params(enc);
+   radeon_enc_av1_quantization_params(enc, bs);
    /*  segmentation_enable  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
    /*  delta_q_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_Q_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_Q_PARAMS, 0);
    /*  delta_lf_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_LF_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_DELTA_LF_PARAMS, 0);
    /*  loop_filter_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_LOOP_FILTER_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_LOOP_FILTER_PARAMS, 0);
    /*  cdef_params  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_CDEF_PARAMS, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_CDEF_PARAMS, 0);
    /*  lr_params  */
    /*  read_tx_mode  */
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_READ_TX_MODE, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_READ_TX_MODE, 0);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
+   radeon_enc_av1_bs_instruction_type(enc, bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_COPY, 0);
 
    if (!frame_is_intra)
       /*  reference_select  */
-      radeon_enc_code_fixed_bits(enc, enc->enc_pic.av1.compound, 1);
+      radeon_bs_code_fixed_bits(bs, enc->enc_pic.av1.compound, 1);
 
    if (enc->enc_pic.av1.skip_mode_allowed)
       /*  skip_mode_present  */
-      radeon_enc_code_fixed_bits(enc, !enc->enc_pic.av1_spec_misc.disallow_skip_mode, 1);
+      radeon_bs_code_fixed_bits(bs, !enc->enc_pic.av1_spec_misc.disallow_skip_mode, 1);
 
    /*  reduced_tx_set  */
-   radeon_enc_code_fixed_bits(enc, 0, 1);
+   radeon_bs_code_fixed_bits(bs, 0, 1);
 
    if (!frame_is_intra)
       for (uint32_t ref = 1 /*LAST_FRAME*/; ref <= 7 /*ALTREF_FRAME*/; ref++)
          /*  is_global  */
-         radeon_enc_code_fixed_bits(enc, 0, 1);
+         radeon_bs_code_fixed_bits(bs, 0, 1);
    /*  film_grain_params() */
 }
 
 static void radeon_enc_obu_instruction(struct radeon_encoder *enc)
 {
    bool frame_header = !enc->enc_pic.is_obu_frame;
+   struct radeon_bitstream bs;
+
+   radeon_bs_reset(&bs, NULL, &enc->cs);
 
-   radeon_enc_reset(enc);
    RADEON_ENC_BEGIN(enc->cmd.bitstream_instruction_av1);
 
-   radeon_enc_av1_bs_instruction_type(enc,
+   radeon_enc_av1_bs_instruction_type(enc, &bs,
          RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_START,
             frame_header ? RENCODE_OBU_START_TYPE_FRAME_HEADER
                          : RENCODE_OBU_START_TYPE_FRAME);
 
-   radeon_enc_av1_frame_header(enc, frame_header);
+   radeon_enc_av1_frame_header(enc, &bs, frame_header);
 
    if (!frame_header)
-      radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_TILE_GROUP_OBU, 0);
+      radeon_enc_av1_bs_instruction_type(enc, &bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_TILE_GROUP_OBU, 0);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_END, 0);
+   radeon_enc_av1_bs_instruction_type(enc, &bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_OBU_END, 0);
 
    if (frame_header)
-      radeon_enc_av1_tile_group(enc);
+      radeon_enc_av1_tile_group(enc, &bs);
 
-   radeon_enc_av1_bs_instruction_type(enc, RENCODE_AV1_BITSTREAM_INSTRUCTION_END, 0);
+   radeon_enc_av1_bs_instruction_type(enc, &bs, RENCODE_AV1_BITSTREAM_INSTRUCTION_END, 0);
    RADEON_ENC_END();
 }
 
-- 
GitLab


From 96adbf762f5eff13a55e6c68ebe501b07414edd6 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Fri, 27 Dec 2024 09:49:53 +0100
Subject: [PATCH 02/32] radeonsi/vce: Remove support for FW 50 and older

Reviewed-by: Leo Liu <leo.liu@amd.com>
---
 src/gallium/drivers/radeonsi/meson.build      |   2 -
 src/gallium/drivers/radeonsi/radeon_vce.c     |  35 +-
 src/gallium/drivers/radeonsi/radeon_vce.h     |  15 -
 .../drivers/radeonsi/radeon_vce_40_2_2.c      | 439 ------------------
 src/gallium/drivers/radeonsi/radeon_vce_50.c  | 224 ---------
 src/gallium/drivers/radeonsi/radeon_vce_52.c  |   4 +-
 6 files changed, 3 insertions(+), 716 deletions(-)
 delete mode 100644 src/gallium/drivers/radeonsi/radeon_vce_40_2_2.c
 delete mode 100644 src/gallium/drivers/radeonsi/radeon_vce_50.c

diff --git a/src/gallium/drivers/radeonsi/meson.build b/src/gallium/drivers/radeonsi/meson.build
index bb8fe874253af..96da791bbaea4 100644
--- a/src/gallium/drivers/radeonsi/meson.build
+++ b/src/gallium/drivers/radeonsi/meson.build
@@ -84,8 +84,6 @@ files_libradeonsi = files(
   'radeon_uvd_enc_1_1.c',
   'radeon_vce.c',
   'radeon_vce.h',
-  'radeon_vce_40_2_2.c',
-  'radeon_vce_50.c',
   'radeon_vce_52.c',
   'radeon_vcn.h',
   'radeon_vcn.c',
diff --git a/src/gallium/drivers/radeonsi/radeon_vce.c b/src/gallium/drivers/radeonsi/radeon_vce.c
index 2be9e001b062f..82e226edd9c11 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce.c
@@ -17,11 +17,6 @@
 
 #include <stdio.h>
 
-#define FW_40_2_2  ((40 << 24) | (2 << 16) | (2 << 8))
-#define FW_50_0_1  ((50 << 24) | (0 << 16) | (1 << 8))
-#define FW_50_1_2  ((50 << 24) | (1 << 16) | (2 << 8))
-#define FW_50_10_2 ((50 << 24) | (10 << 16) | (2 << 8))
-#define FW_50_17_3 ((50 << 24) | (17 << 16) | (3 << 8))
 #define FW_52_0_3  ((52 << 24) | (0 << 16) | (3 << 8))
 #define FW_52_4_3  ((52 << 24) | (4 << 16) | (3 << 8))
 #define FW_52_8_3  ((52 << 24) | (8 << 16) | (3 << 8))
@@ -460,30 +455,7 @@ struct pipe_video_codec *si_vce_create_encoder(struct pipe_context *context,
       goto error;
    }
 
-   switch (sscreen->info.vce_fw_version) {
-   case FW_40_2_2:
-      si_vce_40_2_2_init(enc);
-      break;
-
-   case FW_50_0_1:
-   case FW_50_1_2:
-   case FW_50_10_2:
-   case FW_50_17_3:
-      si_vce_50_init(enc);
-      break;
-
-   case FW_52_0_3:
-   case FW_52_4_3:
-   case FW_52_8_3:
-      si_vce_52_init(enc);
-      break;
-
-   default:
-      if ((sscreen->info.vce_fw_version & (0xff << 24)) >= FW_53) {
-         si_vce_52_init(enc);
-      } else
-         goto error;
-   }
+   si_vce_52_init(enc);
 
    return &enc->base;
 
@@ -500,11 +472,6 @@ error:
 bool si_vce_is_fw_version_supported(struct si_screen *sscreen)
 {
    switch (sscreen->info.vce_fw_version) {
-   case FW_40_2_2:
-   case FW_50_0_1:
-   case FW_50_1_2:
-   case FW_50_10_2:
-   case FW_50_17_3:
    case FW_52_0_3:
    case FW_52_4_3:
    case FW_52_8_3:
diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index b8eb564723c06..f8b45ca72aaa8 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -415,22 +415,7 @@ bool si_vce_is_fw_version_supported(struct si_screen *sscreen);
 void si_vce_add_buffer(struct rvce_encoder *enc, struct pb_buffer_lean *buf, unsigned usage,
                        enum radeon_bo_domain domain, signed offset);
 
-/* init vce fw 40.2.2 specific callbacks */
-void si_vce_40_2_2_init(struct rvce_encoder *enc);
-
-/* init vce fw 50 specific callbacks */
-void si_vce_50_init(struct rvce_encoder *enc);
-
 /* init vce fw 52 specific callbacks */
 void si_vce_52_init(struct rvce_encoder *enc);
 
-/* get parameters for vce 40.2.2 */
-void si_vce_40_2_2_get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic);
-
-/* get parameters for vce 50 */
-void si_vce_50_get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic);
-
-/* get parameters for vce 52 */
-void si_vce_52_get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic);
-
 #endif
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_40_2_2.c b/src/gallium/drivers/radeonsi/radeon_vce_40_2_2.c
deleted file mode 100644
index 13b3126670719..0000000000000
--- a/src/gallium/drivers/radeonsi/radeon_vce_40_2_2.c
+++ /dev/null
@@ -1,439 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Advanced Micro Devices, Inc.
- *
- * SPDX-License-Identifier: MIT
- *
- **************************************************************************/
-
-#include "pipe/p_video_codec.h"
-#include "radeon_vce.h"
-#include "radeon_video.h"
-#include "si_pipe.h"
-#include "util/u_memory.h"
-#include "util/u_video.h"
-#include "vl/vl_video_buffer.h"
-
-#include <stdio.h>
-
-static void session(struct rvce_encoder *enc)
-{
-   RVCE_BEGIN(0x00000001); // session cmd
-   RVCE_CS(enc->stream_handle);
-   RVCE_END();
-}
-
-static void task_info(struct rvce_encoder *enc, uint32_t op, uint32_t dep, uint32_t fb_idx,
-                      uint32_t ring_idx)
-{
-   RVCE_BEGIN(0x00000002); // task info
-   if (op == 0x3) {
-      if (enc->task_info_idx) {
-         uint32_t offs = enc->cs.current.cdw - enc->task_info_idx + 3;
-         // Update offsetOfNextTaskInfo
-         enc->cs.current.buf[enc->task_info_idx] = offs;
-      }
-      enc->task_info_idx = enc->cs.current.cdw;
-   }
-   RVCE_CS(0xffffffff); // offsetOfNextTaskInfo
-   RVCE_CS(op);         // taskOperation
-   RVCE_CS(dep);        // referencePictureDependency
-   RVCE_CS(0x00000000); // collocateFlagDependency
-   RVCE_CS(fb_idx);     // feedbackIndex
-   RVCE_CS(ring_idx);   // videoBitstreamRingIndex
-   RVCE_END();
-}
-
-static void feedback(struct rvce_encoder *enc)
-{
-   RVCE_BEGIN(0x05000005);                                    // feedback buffer
-   RVCE_WRITE(enc->fb->res->buf, enc->fb->res->domains, 0x0); // feedbackRingAddressHi/Lo
-   RVCE_CS(0x00000001);                                       // feedbackRingSize
-   RVCE_END();
-}
-
-static void create(struct rvce_encoder *enc)
-{
-   enc->task_info(enc, 0x00000000, 0, 0, 0);
-
-   RVCE_BEGIN(0x01000001);                                            // create cmd
-   RVCE_CS(0x00000000);                                               // encUseCircularBuffer
-   RVCE_CS(u_get_h264_profile_idc(enc->base.profile));                // encProfile
-   RVCE_CS(enc->pic.seq.level_idc);                                   // encLevel
-   RVCE_CS(0x00000000);                                               // encPicStructRestriction
-   RVCE_CS(enc->base.width);                                          // encImageWidth
-   RVCE_CS(enc->base.height);                                         // encImageHeight
-   RVCE_CS(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe);     // encRefPicLumaPitch
-   RVCE_CS(enc->chroma->u.legacy.level[0].nblk_x * enc->chroma->bpe); // encRefPicChromaPitch
-   RVCE_CS(align(enc->luma->u.legacy.level[0].nblk_y, 16) / 8);       // encRefYHeightInQw
-   RVCE_CS(0x00000000); // encRefPic(Addr|Array)Mode, encPicStructRestriction, disableRDO
-   RVCE_END();
-}
-
-static void rate_control(struct rvce_encoder *enc)
-{
-   uint32_t target_bits_picture =
-      enc->pic.rate_ctrl[0].target_bitrate *
-      ((float)enc->pic.rate_ctrl[0].frame_rate_den /
-      enc->pic.rate_ctrl[0].frame_rate_num);
-   uint32_t peak_bits_picture_integer =
-      enc->pic.rate_ctrl[0].peak_bitrate *
-      ((float)enc->pic.rate_ctrl[0].frame_rate_den /
-      enc->pic.rate_ctrl[0].frame_rate_num);
-   uint32_t peak_bits_picture_fraction =
-      (((enc->pic.rate_ctrl[0].peak_bitrate *
-      (uint64_t)enc->pic.rate_ctrl[0].frame_rate_den) %
-      enc->pic.rate_ctrl[0].frame_rate_num) << 32) /
-      enc->pic.rate_ctrl[0].frame_rate_num;
-
-   RVCE_BEGIN(0x04000005);                                 // rate control
-   RVCE_CS(enc->pic.rate_ctrl[0].rate_ctrl_method);           // encRateControlMethod
-   RVCE_CS(enc->pic.rate_ctrl[0].target_bitrate);             // encRateControlTargetBitRate
-   RVCE_CS(enc->pic.rate_ctrl[0].peak_bitrate);               // encRateControlPeakBitRate
-   RVCE_CS(enc->pic.rate_ctrl[0].frame_rate_num);             // encRateControlFrameRateNum
-   RVCE_CS(0x00000000);                                    // encGOPSize
-   RVCE_CS(enc->pic.quant_i_frames);                       // encQP_I
-   RVCE_CS(enc->pic.quant_p_frames);                       // encQP_P
-   RVCE_CS(enc->pic.quant_b_frames);                       // encQP_B
-   RVCE_CS(enc->pic.rate_ctrl[0].vbv_buffer_size);            // encVBVBufferSize
-   RVCE_CS(enc->pic.rate_ctrl[0].frame_rate_den);             // encRateControlFrameRateDen
-   RVCE_CS(0x00000000);                                    // encVBVBufferLevel
-   RVCE_CS(0x00000000);                                    // encMaxAUSize
-   RVCE_CS(0x00000000);                                    // encQPInitialMode
-   RVCE_CS(target_bits_picture);                           // encTargetBitsPerPicture
-   RVCE_CS(peak_bits_picture_integer);                     // encPeakBitsPerPictureInteger
-   RVCE_CS(peak_bits_picture_fraction);                    // encPeakBitsPerPictureFractional
-   RVCE_CS(0x00000000);                                    // encMinQP
-   RVCE_CS(0x00000033);                                    // encMaxQP
-   RVCE_CS(0x00000000);                                    // encSkipFrameEnable
-   RVCE_CS(0x00000000);                                    // encFillerDataEnable
-   RVCE_CS(0x00000000);                                    // encEnforceHRD
-   RVCE_CS(0x00000000);                                    // encBPicsDeltaQP
-   RVCE_CS(0x00000000);                                    // encReferenceBPicsDeltaQP
-   RVCE_CS(0x00000000);                                    // encRateControlReInitDisable
-   RVCE_END();
-}
-
-static void config_extension(struct rvce_encoder *enc)
-{
-   RVCE_BEGIN(0x04000001); // config extension
-   RVCE_CS(0x00000003);    // encEnablePerfLogging
-   RVCE_END();
-}
-
-static void pic_control(struct rvce_encoder *enc)
-{
-   unsigned encNumMBsPerSlice;
-
-   encNumMBsPerSlice = align(enc->base.width, 16) / 16;
-   encNumMBsPerSlice *= align(enc->base.height, 16) / 16;
-
-   RVCE_BEGIN(0x04000002);                                         // pic control
-   RVCE_CS(0x00000000);                                            // encUseConstrainedIntraPred
-   RVCE_CS(0x00000000);                                            // encCABACEnable
-   RVCE_CS(0x00000000);                                            // encCABACIDC
-   RVCE_CS(0x00000000);                                            // encLoopFilterDisable
-   RVCE_CS(0x00000000);                                            // encLFBetaOffset
-   RVCE_CS(0x00000000);                                            // encLFAlphaC0Offset
-   RVCE_CS(0x00000000);                                            // encCropLeftOffset
-   RVCE_CS((align(enc->base.width, 16) - enc->base.width) >> 1);   // encCropRightOffset
-   RVCE_CS(0x00000000);                                            // encCropTopOffset
-   RVCE_CS((align(enc->base.height, 16) - enc->base.height) >> 1); // encCropBottomOffset
-   RVCE_CS(encNumMBsPerSlice);                                     // encNumMBsPerSlice
-   RVCE_CS(0x00000000);                                            // encIntraRefreshNumMBsPerSlot
-   RVCE_CS(0x00000000);                                            // encForceIntraRefresh
-   RVCE_CS(0x00000000);                                            // encForceIMBPeriod
-   RVCE_CS(0x00000000);                                            // encPicOrderCntType
-   RVCE_CS(0x00000000);                            // log2_max_pic_order_cnt_lsb_minus4
-   RVCE_CS(0x00000000);                            // encSPSID
-   RVCE_CS(0x00000000);                            // encPPSID
-   RVCE_CS(0x00000040);                            // encConstraintSetFlags
-   RVCE_CS(MAX2(enc->base.max_references, 1) - 1); // encBPicPattern
-   RVCE_CS(0x00000000);                            // weightPredModeBPicture
-   RVCE_CS(MIN2(enc->base.max_references, 2));     // encNumberOfReferenceFrames
-   RVCE_CS(enc->base.max_references + 1);          // encMaxNumRefFrames
-   RVCE_CS(0x00000001);                            // encNumDefaultActiveRefL0
-   RVCE_CS(0x00000001);                            // encNumDefaultActiveRefL1
-   RVCE_CS(0x00000000);                            // encSliceMode
-   RVCE_CS(0x00000000);                            // encMaxSliceSize
-   RVCE_END();
-}
-
-static void motion_estimation(struct rvce_encoder *enc)
-{
-   RVCE_BEGIN(0x04000007); // motion estimation
-   RVCE_CS(0x00000001);    // encIMEDecimationSearch
-   RVCE_CS(0x00000001);    // motionEstHalfPixel
-   RVCE_CS(0x00000000);    // motionEstQuarterPixel
-   RVCE_CS(0x00000000);    // disableFavorPMVPoint
-   RVCE_CS(0x00000000);    // forceZeroPointCenter
-   RVCE_CS(0x00000000);    // LSMVert
-   RVCE_CS(0x00000010);    // encSearchRangeX
-   RVCE_CS(0x00000010);    // encSearchRangeY
-   RVCE_CS(0x00000010);    // encSearch1RangeX
-   RVCE_CS(0x00000010);    // encSearch1RangeY
-   RVCE_CS(0x00000000);    // disable16x16Frame1
-   RVCE_CS(0x00000000);    // disableSATD
-   RVCE_CS(0x00000000);    // enableAMD
-   RVCE_CS(0x000000fe);    // encDisableSubMode
-   RVCE_CS(0x00000000);    // encIMESkipX
-   RVCE_CS(0x00000000);    // encIMESkipY
-   RVCE_CS(0x00000000);    // encEnImeOverwDisSubm
-   RVCE_CS(0x00000000);    // encImeOverwDisSubmNo
-   RVCE_CS(0x00000001);    // encIME2SearchRangeX
-   RVCE_CS(0x00000001);    // encIME2SearchRangeY
-   RVCE_CS(0x00000000);    // parallelModeSpeedupEnable
-   RVCE_CS(0x00000000);    // fme0_encDisableSubMode
-   RVCE_CS(0x00000000);    // fme1_encDisableSubMode
-   RVCE_CS(0x00000000);    // imeSWSpeedupEnable
-   RVCE_END();
-}
-
-static void rdo(struct rvce_encoder *enc)
-{
-   RVCE_BEGIN(0x04000008); // rdo
-   RVCE_CS(0x00000000);    // encDisableTbePredIFrame
-   RVCE_CS(0x00000000);    // encDisableTbePredPFrame
-   RVCE_CS(0x00000000);    // useFmeInterpolY
-   RVCE_CS(0x00000000);    // useFmeInterpolUV
-   RVCE_CS(0x00000000);    // useFmeIntrapolY
-   RVCE_CS(0x00000000);    // useFmeIntrapolUV
-   RVCE_CS(0x00000000);    // useFmeInterpolY_1
-   RVCE_CS(0x00000000);    // useFmeInterpolUV_1
-   RVCE_CS(0x00000000);    // useFmeIntrapolY_1
-   RVCE_CS(0x00000000);    // useFmeIntrapolUV_1
-   RVCE_CS(0x00000000);    // enc16x16CostAdj
-   RVCE_CS(0x00000000);    // encSkipCostAdj
-   RVCE_CS(0x00000000);    // encForce16x16skip
-   RVCE_CS(0x00000000);    // encDisableThresholdCalcA
-   RVCE_CS(0x00000000);    // encLumaCoeffCost
-   RVCE_CS(0x00000000);    // encLumaMBCoeffCost
-   RVCE_CS(0x00000000);    // encChromaCoeffCost
-   RVCE_END();
-}
-
-static void vui(struct rvce_encoder *enc)
-{
-   int i;
-
-   if (!enc->pic.rate_ctrl[0].frame_rate_num)
-      return;
-
-   RVCE_BEGIN(0x04000009);                     // vui
-   RVCE_CS(0x00000000);                        // aspectRatioInfoPresentFlag
-   RVCE_CS(0x00000000);                        // aspectRatioInfo.aspectRatioIdc
-   RVCE_CS(0x00000000);                        // aspectRatioInfo.sarWidth
-   RVCE_CS(0x00000000);                        // aspectRatioInfo.sarHeight
-   RVCE_CS(0x00000000);                        // overscanInfoPresentFlag
-   RVCE_CS(0x00000000);                        // overScanInfo.overscanAppropFlag
-   RVCE_CS(0x00000000);                        // videoSignalTypePresentFlag
-   RVCE_CS(0x00000005);                        // videoSignalTypeInfo.videoFormat
-   RVCE_CS(0x00000000);                        // videoSignalTypeInfo.videoFullRangeFlag
-   RVCE_CS(0x00000000);                        // videoSignalTypeInfo.colorDescriptionPresentFlag
-   RVCE_CS(0x00000002);                        // videoSignalTypeInfo.colorPrim
-   RVCE_CS(0x00000002);                        // videoSignalTypeInfo.transferChar
-   RVCE_CS(0x00000002);                        // videoSignalTypeInfo.matrixCoef
-   RVCE_CS(0x00000000);                        // chromaLocInfoPresentFlag
-   RVCE_CS(0x00000000);                        // chromaLocInfo.chromaLocTop
-   RVCE_CS(0x00000000);                        // chromaLocInfo.chromaLocBottom
-   RVCE_CS(0x00000001);                        // timingInfoPresentFlag
-   RVCE_CS(enc->pic.rate_ctrl[0].frame_rate_den); // timingInfo.numUnitsInTick
-   RVCE_CS(enc->pic.rate_ctrl[0].frame_rate_num * 2); // timingInfo.timeScale;
-   RVCE_CS(0x00000001);                            // timingInfo.fixedFrameRateFlag
-   RVCE_CS(0x00000000);                            // nalHRDParametersPresentFlag
-   RVCE_CS(0x00000000);                            // hrdParam.cpbCntMinus1
-   RVCE_CS(0x00000004);                            // hrdParam.bitRateScale
-   RVCE_CS(0x00000006);                            // hrdParam.cpbSizeScale
-   for (i = 0; i < 32; i++) {
-      RVCE_CS(0x00000000); // hrdParam.bitRateValueMinus
-      RVCE_CS(0x00000000); // hrdParam.cpbSizeValueMinus
-      RVCE_CS(0x00000000); // hrdParam.cbrFlag
-   }
-   RVCE_CS(0x00000017); // hrdParam.initialCpbRemovalDelayLengthMinus1
-   RVCE_CS(0x00000017); // hrdParam.cpbRemovalDelayLengthMinus1
-   RVCE_CS(0x00000017); // hrdParam.dpbOutputDelayLengthMinus1
-   RVCE_CS(0x00000018); // hrdParam.timeOffsetLength
-   RVCE_CS(0x00000000); // lowDelayHRDFlag
-   RVCE_CS(0x00000000); // picStructPresentFlag
-   RVCE_CS(0x00000000); // bitstreamRestrictionPresentFlag
-   RVCE_CS(0x00000001); // bitstreamRestrictions.motionVectorsOverPicBoundariesFlag
-   RVCE_CS(0x00000002); // bitstreamRestrictions.maxBytesPerPicDenom
-   RVCE_CS(0x00000001); // bitstreamRestrictions.maxBitsPerMbDenom
-   RVCE_CS(0x00000010); // bitstreamRestrictions.log2MaxMvLengthHori
-   RVCE_CS(0x00000010); // bitstreamRestrictions.log2MaxMvLengthVert
-   RVCE_CS(0x00000003); // bitstreamRestrictions.numReorderFrames
-   RVCE_CS(0x00000003); // bitstreamRestrictions.maxDecFrameBuffering
-   RVCE_END();
-}
-
-static void config(struct rvce_encoder *enc)
-{
-   enc->task_info(enc, 0x00000002, 0, 0xffffffff, 0);
-   enc->rate_control(enc);
-   enc->config_extension(enc);
-   enc->motion_estimation(enc);
-   enc->rdo(enc);
-   if (enc->use_vui)
-      enc->vui(enc);
-   enc->pic_control(enc);
-}
-
-static void encode(struct rvce_encoder *enc)
-{
-   signed luma_offset, chroma_offset;
-   int i;
-
-   enc->task_info(enc, 0x00000003, 0, 0, 0);
-
-   RVCE_BEGIN(0x05000001);                                        // context buffer
-   RVCE_READWRITE(enc->cpb.res->buf, enc->cpb.res->domains, 0x0); // encodeContextAddressHi/Lo
-   RVCE_END();
-
-   RVCE_BEGIN(0x05000004);                             // video bitstream buffer
-   RVCE_WRITE(enc->bs_handle, RADEON_DOMAIN_GTT, 0x0); // videoBitstreamRingAddressHi/Lo
-   RVCE_CS(enc->bs_size);                              // videoBitstreamRingSize
-   RVCE_END();
-
-   RVCE_BEGIN(0x03000001); // encode
-   RVCE_CS(0x00000000);    // insertHeaders
-   RVCE_CS(0x00000000);    // pictureStructure
-   RVCE_CS(enc->bs_size);  // allowedMaxBitstreamSize
-   RVCE_CS(0x00000000);    // forceRefreshMap
-   RVCE_CS(0x00000000);    // insertAUD
-   RVCE_CS(0x00000000);    // endOfSequence
-   RVCE_CS(0x00000000);    // endOfStream
-   RVCE_READ(enc->handle, RADEON_DOMAIN_VRAM,
-             (uint64_t)enc->luma->u.legacy.level[0].offset_256B * 256); // inputPictureLumaAddressHi/Lo
-   RVCE_READ(enc->handle, RADEON_DOMAIN_VRAM,
-             (uint64_t)enc->chroma->u.legacy.level[0].offset_256B * 256);              // inputPictureChromaAddressHi/Lo
-   RVCE_CS(align(enc->luma->u.legacy.level[0].nblk_y, 16));       // encInputFrameYPitch
-   RVCE_CS(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe); // encInputPicLumaPitch
-   RVCE_CS(enc->chroma->u.legacy.level[0].nblk_x * enc->chroma->bpe); // encInputPicChromaPitch
-   RVCE_CS(0x00000000);                                               // encInputPic(Addr|Array)Mode
-   RVCE_CS(0x00000000);                                               // encInputPicTileConfig
-   RVCE_CS(enc->pic.picture_type);                                    // encPicType
-   RVCE_CS(enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR); // encIdrFlag
-   RVCE_CS(0x00000000);                                               // encIdrPicId
-   RVCE_CS(0x00000000);                                               // encMGSKeyPic
-   RVCE_CS(!enc->pic.not_referenced);                                 // encReferenceFlag
-   RVCE_CS(0x00000000);                                               // encTemporalLayerIndex
-   RVCE_CS(0x00000000); // num_ref_idx_active_override_flag
-   RVCE_CS(0x00000000); // num_ref_idx_l0_active_minus1
-   RVCE_CS(0x00000000); // num_ref_idx_l1_active_minus1
-
-   i = enc->pic.frame_num - enc->pic.ref_idx_l0_list[0];
-   if (i > 1 && enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P) {
-      RVCE_CS(0x00000001); // encRefListModificationOp
-      RVCE_CS(i - 1);      // encRefListModificationNum
-   } else {
-      RVCE_CS(0x00000000); // encRefListModificationOp
-      RVCE_CS(0x00000000); // encRefListModificationNum
-   }
-
-   for (i = 0; i < 3; ++i) {
-      RVCE_CS(0x00000000); // encRefListModificationOp
-      RVCE_CS(0x00000000); // encRefListModificationNum
-   }
-   for (i = 0; i < 4; ++i) {
-      RVCE_CS(0x00000000); // encDecodedPictureMarkingOp
-      RVCE_CS(0x00000000); // encDecodedPictureMarkingNum
-      RVCE_CS(0x00000000); // encDecodedPictureMarkingIdx
-      RVCE_CS(0x00000000); // encDecodedRefBasePictureMarkingOp
-      RVCE_CS(0x00000000); // encDecodedRefBasePictureMarkingNum
-   }
-
-   // encReferencePictureL0[0]
-   RVCE_CS(0x00000000); // pictureStructure
-   if (enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
-       enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      struct rvce_cpb_slot *l0 = si_l0_slot(enc);
-      si_vce_frame_offset(enc, l0, &luma_offset, &chroma_offset);
-      RVCE_CS(l0->picture_type);  // encPicType
-      RVCE_CS(l0->frame_num);     // frameNumber
-      RVCE_CS(l0->pic_order_cnt); // pictureOrderCount
-      RVCE_CS(luma_offset);       // lumaOffset
-      RVCE_CS(chroma_offset);     // chromaOffset
-   } else {
-      RVCE_CS(0x00000000); // encPicType
-      RVCE_CS(0x00000000); // frameNumber
-      RVCE_CS(0x00000000); // pictureOrderCount
-      RVCE_CS(0xffffffff); // lumaOffset
-      RVCE_CS(0xffffffff); // chromaOffset
-   }
-
-   // encReferencePictureL0[1]
-   RVCE_CS(0x00000000); // pictureStructure
-   RVCE_CS(0x00000000); // encPicType
-   RVCE_CS(0x00000000); // frameNumber
-   RVCE_CS(0x00000000); // pictureOrderCount
-   RVCE_CS(0xffffffff); // lumaOffset
-   RVCE_CS(0xffffffff); // chromaOffset
-
-   // encReferencePictureL1[0]
-   RVCE_CS(0x00000000); // pictureStructure
-   if (enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      struct rvce_cpb_slot *l1 = si_l1_slot(enc);
-      si_vce_frame_offset(enc, l1, &luma_offset, &chroma_offset);
-      RVCE_CS(l1->picture_type);  // encPicType
-      RVCE_CS(l1->frame_num);     // frameNumber
-      RVCE_CS(l1->pic_order_cnt); // pictureOrderCount
-      RVCE_CS(luma_offset);       // lumaOffset
-      RVCE_CS(chroma_offset);     // chromaOffset
-   } else {
-      RVCE_CS(0x00000000); // encPicType
-      RVCE_CS(0x00000000); // frameNumber
-      RVCE_CS(0x00000000); // pictureOrderCount
-      RVCE_CS(0xffffffff); // lumaOffset
-      RVCE_CS(0xffffffff); // chromaOffset
-   }
-
-   si_vce_frame_offset(enc, si_current_slot(enc), &luma_offset, &chroma_offset);
-   RVCE_CS(luma_offset);            // encReconstructedLumaOffset
-   RVCE_CS(chroma_offset);          // encReconstructedChromaOffset
-   RVCE_CS(0x00000000);             // encColocBufferOffset
-   RVCE_CS(0x00000000);             // encReconstructedRefBasePictureLumaOffset
-   RVCE_CS(0x00000000);             // encReconstructedRefBasePictureChromaOffset
-   RVCE_CS(0x00000000);             // encReferenceRefBasePictureLumaOffset
-   RVCE_CS(0x00000000);             // encReferenceRefBasePictureChromaOffset
-   RVCE_CS(0x00000000);             // pictureCount
-   RVCE_CS(enc->pic.frame_num);     // frameNumber
-   RVCE_CS(enc->pic.pic_order_cnt); // pictureOrderCount
-   RVCE_CS(0x00000000);             // numIPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // numPPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // numBPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // numIRPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // enableIntraRefresh
-   RVCE_END();
-}
-
-static void destroy(struct rvce_encoder *enc)
-{
-   enc->task_info(enc, 0x00000001, 0, 0, 0);
-
-   feedback(enc);
-
-   RVCE_BEGIN(0x02000001); // destroy
-   RVCE_END();
-}
-
-void si_vce_40_2_2_get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
-{
-}
-
-void si_vce_40_2_2_init(struct rvce_encoder *enc)
-{
-   enc->session = session;
-   enc->task_info = task_info;
-   enc->create = create;
-   enc->feedback = feedback;
-   enc->rate_control = rate_control;
-   enc->config_extension = config_extension;
-   enc->pic_control = pic_control;
-   enc->motion_estimation = motion_estimation;
-   enc->rdo = rdo;
-   enc->vui = vui;
-   enc->config = config;
-   enc->encode = encode;
-   enc->destroy = destroy;
-   enc->si_get_pic_param = si_vce_40_2_2_get_param;
-}
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_50.c b/src/gallium/drivers/radeonsi/radeon_vce_50.c
deleted file mode 100644
index 7c771bfe83ba9..0000000000000
--- a/src/gallium/drivers/radeonsi/radeon_vce_50.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Advanced Micro Devices, Inc.
- *
- * SPDX-License-Identifier: MIT
- *
- **************************************************************************/
-
-#include "pipe/p_video_codec.h"
-#include "radeon_vce.h"
-#include "radeon_video.h"
-#include "si_pipe.h"
-#include "util/u_memory.h"
-#include "util/u_video.h"
-#include "vl/vl_video_buffer.h"
-
-#include <stdio.h>
-
-static void rate_control(struct rvce_encoder *enc)
-{
-   uint32_t target_bits_picture =
-      enc->pic.rate_ctrl[0].target_bitrate *
-      ((float)enc->pic.rate_ctrl[0].frame_rate_den /
-      enc->pic.rate_ctrl[0].frame_rate_num);
-   uint32_t peak_bits_picture_integer =
-      enc->pic.rate_ctrl[0].peak_bitrate *
-      ((float)enc->pic.rate_ctrl[0].frame_rate_den /
-      enc->pic.rate_ctrl[0].frame_rate_num);
-   uint32_t peak_bits_picture_fraction =
-      (((enc->pic.rate_ctrl[0].peak_bitrate *
-      (uint64_t)enc->pic.rate_ctrl[0].frame_rate_den) %
-      enc->pic.rate_ctrl[0].frame_rate_num) << 32) /
-      enc->pic.rate_ctrl[0].frame_rate_num;
-
-   RVCE_BEGIN(0x04000005);                                 // rate control
-   RVCE_CS(enc->pic.rate_ctrl[0].rate_ctrl_method);           // encRateControlMethod
-   RVCE_CS(enc->pic.rate_ctrl[0].target_bitrate);             // encRateControlTargetBitRate
-   RVCE_CS(enc->pic.rate_ctrl[0].peak_bitrate);               // encRateControlPeakBitRate
-   RVCE_CS(enc->pic.rate_ctrl[0].frame_rate_num);             // encRateControlFrameRateNum
-   RVCE_CS(0x00000000);                                    // encGOPSize
-   RVCE_CS(enc->pic.quant_i_frames);                       // encQP_I
-   RVCE_CS(enc->pic.quant_p_frames);                       // encQP_P
-   RVCE_CS(enc->pic.quant_b_frames);                       // encQP_B
-   RVCE_CS(enc->pic.rate_ctrl[0].vbv_buffer_size);            // encVBVBufferSize
-   RVCE_CS(enc->pic.rate_ctrl[0].frame_rate_den);             // encRateControlFrameRateDen
-   RVCE_CS(0x00000000);                                    // encVBVBufferLevel
-   RVCE_CS(0x00000000);                                    // encMaxAUSize
-   RVCE_CS(0x00000000);                                    // encQPInitialMode
-   RVCE_CS(target_bits_picture);                           // encTargetBitsPerPicture
-   RVCE_CS(peak_bits_picture_integer);                     // encPeakBitsPerPictureInteger
-   RVCE_CS(peak_bits_picture_fraction);                    // encPeakBitsPerPictureFractional
-   RVCE_CS(0x00000000);                                    // encMinQP
-   RVCE_CS(0x00000033);                                    // encMaxQP
-   RVCE_CS(0x00000000);                                    // encSkipFrameEnable
-   RVCE_CS(0x00000000);                                    // encFillerDataEnable
-   RVCE_CS(0x00000000);                                    // encEnforceHRD
-   RVCE_CS(0x00000000);                                    // encBPicsDeltaQP
-   RVCE_CS(0x00000000);                                    // encReferenceBPicsDeltaQP
-   RVCE_CS(0x00000000);                                    // encRateControlReInitDisable
-   RVCE_CS(0x00000000);                                    // encLCVBRInitQPFlag
-   RVCE_CS(0x00000000); // encLCVBRSATDBasedNonlinearBitBudgetFlag
-   RVCE_END();
-}
-
-static void encode(struct rvce_encoder *enc)
-{
-   signed luma_offset, chroma_offset, bs_offset;
-   unsigned bs_idx = enc->bs_idx++;
-   int i;
-
-   enc->task_info(enc, 0x00000003, 0, 0, bs_idx);
-
-   RVCE_BEGIN(0x05000001);                                      // context buffer
-   RVCE_READWRITE(enc->cpb.res->buf, enc->cpb.res->domains, 0); // encodeContextAddressHi/Lo
-   RVCE_END();
-
-   bs_offset = -(signed)(bs_idx * enc->bs_size);
-
-   RVCE_BEGIN(0x05000004);                                   // video bitstream buffer
-   RVCE_WRITE(enc->bs_handle, RADEON_DOMAIN_GTT, bs_offset); // videoBitstreamRingAddressHi/Lo
-   RVCE_CS(enc->bs_size);                                    // videoBitstreamRingSize
-   RVCE_END();
-
-   if (enc->dual_pipe) {
-      unsigned aux_offset =
-         enc->cpb.res->buf->size - RVCE_MAX_AUX_BUFFER_NUM * RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE * 2;
-      RVCE_BEGIN(0x05000002); // auxiliary buffer
-      for (i = 0; i < 8; ++i) {
-         RVCE_CS(aux_offset);
-         aux_offset += RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE;
-      }
-      for (i = 0; i < 8; ++i)
-         RVCE_CS(RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE);
-      RVCE_END();
-   }
-
-   RVCE_BEGIN(0x03000001);                   // encode
-   RVCE_CS(enc->pic.frame_num ? 0x0 : 0x11); // insertHeaders
-   RVCE_CS(0x00000000);                      // pictureStructure
-   RVCE_CS(enc->bs_size);                    // allowedMaxBitstreamSize
-   RVCE_CS(0x00000000);                      // forceRefreshMap
-   RVCE_CS(0x00000000);                      // insertAUD
-   RVCE_CS(0x00000000);                      // endOfSequence
-   RVCE_CS(0x00000000);                      // endOfStream
-   RVCE_READ(enc->handle, RADEON_DOMAIN_VRAM,
-             (uint64_t)enc->luma->u.legacy.level[0].offset_256B * 256); // inputPictureLumaAddressHi/Lo
-   RVCE_READ(enc->handle, RADEON_DOMAIN_VRAM,
-             (uint64_t)enc->chroma->u.legacy.level[0].offset_256B * 256);              // inputPictureChromaAddressHi/Lo
-   RVCE_CS(align(enc->luma->u.legacy.level[0].nblk_y, 16));       // encInputFrameYPitch
-   RVCE_CS(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe); // encInputPicLumaPitch
-   RVCE_CS(enc->chroma->u.legacy.level[0].nblk_x * enc->chroma->bpe); // encInputPicChromaPitch
-   if (enc->dual_pipe)
-      RVCE_CS(0x00000000); // encInputPic(Addr|Array)Mode,encDisable(TwoPipeMode|MBOffloading)
-   else
-      RVCE_CS(0x00010000); // encInputPic(Addr|Array)Mode,encDisable(TwoPipeMode|MBOffloading)
-   RVCE_CS(0x00000000);    // encInputPicTileConfig
-   RVCE_CS(enc->pic.picture_type);                                   // encPicType
-   RVCE_CS(enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR);// encIdrFlag
-   RVCE_CS(0x00000000);                                              // encIdrPicId
-   RVCE_CS(0x00000000);                                              // encMGSKeyPic
-   RVCE_CS(!enc->pic.not_referenced);                                // encReferenceFlag
-   RVCE_CS(0x00000000);                                              // encTemporalLayerIndex
-   RVCE_CS(0x00000000); // num_ref_idx_active_override_flag
-   RVCE_CS(0x00000000); // num_ref_idx_l0_active_minus1
-   RVCE_CS(0x00000000); // num_ref_idx_l1_active_minus1
-
-   i = enc->pic.frame_num - enc->pic.ref_idx_l0_list[0];
-   if (i > 1 && enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P) {
-      RVCE_CS(0x00000001); // encRefListModificationOp
-      RVCE_CS(i - 1);      // encRefListModificationNum
-   } else {
-      RVCE_CS(0x00000000); // encRefListModificationOp
-      RVCE_CS(0x00000000); // encRefListModificationNum
-   }
-
-   for (i = 0; i < 3; ++i) {
-      RVCE_CS(0x00000000); // encRefListModificationOp
-      RVCE_CS(0x00000000); // encRefListModificationNum
-   }
-   for (i = 0; i < 4; ++i) {
-      RVCE_CS(0x00000000); // encDecodedPictureMarkingOp
-      RVCE_CS(0x00000000); // encDecodedPictureMarkingNum
-      RVCE_CS(0x00000000); // encDecodedPictureMarkingIdx
-      RVCE_CS(0x00000000); // encDecodedRefBasePictureMarkingOp
-      RVCE_CS(0x00000000); // encDecodedRefBasePictureMarkingNum
-   }
-
-   // encReferencePictureL0[0]
-   RVCE_CS(0x00000000); // pictureStructure
-   if (enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
-       enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      struct rvce_cpb_slot *l0 = si_l0_slot(enc);
-      si_vce_frame_offset(enc, l0, &luma_offset, &chroma_offset);
-      RVCE_CS(l0->picture_type);  // encPicType
-      RVCE_CS(l0->frame_num);     // frameNumber
-      RVCE_CS(l0->pic_order_cnt); // pictureOrderCount
-      RVCE_CS(luma_offset);       // lumaOffset
-      RVCE_CS(chroma_offset);     // chromaOffset
-   } else {
-      RVCE_CS(0x00000000); // encPicType
-      RVCE_CS(0x00000000); // frameNumber
-      RVCE_CS(0x00000000); // pictureOrderCount
-      RVCE_CS(0xffffffff); // lumaOffset
-      RVCE_CS(0xffffffff); // chromaOffset
-   }
-
-   // encReferencePictureL0[1]
-   RVCE_CS(0x00000000); // pictureStructure
-   RVCE_CS(0x00000000); // encPicType
-   RVCE_CS(0x00000000); // frameNumber
-   RVCE_CS(0x00000000); // pictureOrderCount
-   RVCE_CS(0xffffffff); // lumaOffset
-   RVCE_CS(0xffffffff); // chromaOffset
-
-   // encReferencePictureL1[0]
-   RVCE_CS(0x00000000); // pictureStructure
-   if (enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      struct rvce_cpb_slot *l1 = si_l1_slot(enc);
-      si_vce_frame_offset(enc, l1, &luma_offset, &chroma_offset);
-      RVCE_CS(l1->picture_type);  // encPicType
-      RVCE_CS(l1->frame_num);     // frameNumber
-      RVCE_CS(l1->pic_order_cnt); // pictureOrderCount
-      RVCE_CS(luma_offset);       // lumaOffset
-      RVCE_CS(chroma_offset);     // chromaOffset
-   } else {
-      RVCE_CS(0x00000000); // encPicType
-      RVCE_CS(0x00000000); // frameNumber
-      RVCE_CS(0x00000000); // pictureOrderCount
-      RVCE_CS(0xffffffff); // lumaOffset
-      RVCE_CS(0xffffffff); // chromaOffset
-   }
-
-   si_vce_frame_offset(enc, si_current_slot(enc), &luma_offset, &chroma_offset);
-   RVCE_CS(luma_offset);            // encReconstructedLumaOffset
-   RVCE_CS(chroma_offset);          // encReconstructedChromaOffset
-   RVCE_CS(0x00000000);             // encColocBufferOffset
-   RVCE_CS(0x00000000);             // encReconstructedRefBasePictureLumaOffset
-   RVCE_CS(0x00000000);             // encReconstructedRefBasePictureChromaOffset
-   RVCE_CS(0x00000000);             // encReferenceRefBasePictureLumaOffset
-   RVCE_CS(0x00000000);             // encReferenceRefBasePictureChromaOffset
-   RVCE_CS(0x00000000);             // pictureCount
-   RVCE_CS(enc->pic.frame_num);     // frameNumber
-   RVCE_CS(enc->pic.pic_order_cnt); // pictureOrderCount
-   RVCE_CS(0x00000000);             // numIPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // numPPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // numBPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // numIRPicRemainInRCGOP
-   RVCE_CS(0x00000000);             // enableIntraRefresh
-   RVCE_END();
-}
-
-void si_vce_50_get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
-{
-}
-
-void si_vce_50_init(struct rvce_encoder *enc)
-{
-   si_vce_40_2_2_init(enc);
-
-   /* only the two below are different */
-   enc->rate_control = rate_control;
-   enc->encode = encode;
-   enc->si_get_pic_param = si_vce_50_get_param;
-}
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 1155a2aa2103c..7aba67881b87f 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -145,7 +145,7 @@ static void get_vui_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture
    enc->enc_pic.vui.max_dec_frame_buffering = 0x00000003;
 }
 
-void si_vce_52_get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
+static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
 {
    get_rate_control_param(enc, pic);
    get_motion_estimation_param(enc, pic);
@@ -657,5 +657,5 @@ void si_vce_52_init(struct rvce_encoder *enc)
    enc->config = config;
    enc->encode = encode;
    enc->destroy = destroy;
-   enc->si_get_pic_param = si_vce_52_get_param;
+   enc->si_get_pic_param = get_param;
 }
-- 
GitLab


From 13ee7ef97e3a2a59168774e26e9245c454ba2cd9 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Fri, 20 Dec 2024 12:40:00 +0100
Subject: [PATCH 03/32] radeonsi/vce: Set more header params

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/1404
---
 src/gallium/drivers/radeonsi/radeon_vce.c    |  2 -
 src/gallium/drivers/radeonsi/radeon_vce.h    |  1 -
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 66 +++++++++++++-------
 3 files changed, 42 insertions(+), 27 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.c b/src/gallium/drivers/radeonsi/radeon_vce.c
index 82e226edd9c11..4ee65623357c1 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce.c
@@ -427,8 +427,6 @@ struct pipe_video_codec *si_vce_create_encoder(struct pipe_context *context,
    if (sscreen->info.is_amdgpu)
       enc->use_vm = true;
 
-   enc->use_vui = true;
-
    if (sscreen->info.family >= CHIP_TONGA && sscreen->info.family != CHIP_STONEY &&
        sscreen->info.family != CHIP_POLARIS11 && sscreen->info.family != CHIP_POLARIS12 &&
        sscreen->info.family != CHIP_VEGAM)
diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index f8b45ca72aaa8..ebb44ce4aeea1 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -394,7 +394,6 @@ struct rvce_encoder {
    unsigned bs_idx;
 
    bool use_vm;
-   bool use_vui;
    bool dual_pipe;
 };
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 7aba67881b87f..ca1d1742e9c65 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -75,19 +75,21 @@ static void get_pic_control_param(struct rvce_encoder *enc, struct pipe_h264_enc
       enc->enc_pic.pc.enc_crop_right_offset = pic->seq.enc_frame_crop_right_offset;
       enc->enc_pic.pc.enc_crop_top_offset = pic->seq.enc_frame_crop_top_offset;
       enc->enc_pic.pc.enc_crop_bottom_offset = pic->seq.enc_frame_crop_bottom_offset;
-   } else {
-      enc->enc_pic.pc.enc_crop_right_offset = (align(enc->base.width, 16) - enc->base.width) >> 1;
-      enc->enc_pic.pc.enc_crop_bottom_offset =
-         (align(enc->base.height, 16) - enc->base.height) >> 1;
    }
    enc->enc_pic.pc.enc_num_mbs_per_slice = encNumMBsPerSlice;
-   enc->enc_pic.pc.enc_b_pic_pattern = MAX2(enc->base.max_references, 1) - 1;
-   enc->enc_pic.pc.enc_number_of_reference_frames = MIN2(enc->base.max_references, 1);
-   enc->enc_pic.pc.enc_max_num_ref_frames = enc->base.max_references + 1;
-   enc->enc_pic.pc.enc_num_default_active_ref_l0 = 0x00000001;
-   enc->enc_pic.pc.enc_num_default_active_ref_l1 = 0x00000001;
+   enc->enc_pic.pc.enc_number_of_reference_frames = 1;
+   enc->enc_pic.pc.enc_max_num_ref_frames = pic->seq.max_num_ref_frames;
+   enc->enc_pic.pc.enc_num_default_active_ref_l0 = pic->pic_ctrl.num_ref_idx_l0_default_active_minus1 + 1;
+   enc->enc_pic.pc.enc_num_default_active_ref_l1 = pic->pic_ctrl.num_ref_idx_l1_default_active_minus1 + 1;
+   enc->enc_pic.pc.enc_use_constrained_intra_pred = pic->pic_ctrl.constrained_intra_pred_flag;
    enc->enc_pic.pc.enc_cabac_enable = pic->pic_ctrl.enc_cabac_enable;
-   enc->enc_pic.pc.enc_constraint_set_flags = 0x00000040;
+   enc->enc_pic.pc.enc_cabac_idc = pic->pic_ctrl.enc_cabac_init_idc;
+   enc->enc_pic.pc.enc_constraint_set_flags = pic->seq.enc_constraint_set_flags << 2;
+   enc->enc_pic.pc.enc_loop_filter_disable = !!pic->dbk.disable_deblocking_filter_idc;
+   enc->enc_pic.pc.enc_lf_beta_offset = pic->dbk.beta_offset_div2;
+   enc->enc_pic.pc.enc_lf_alpha_c0_offset = pic->dbk.alpha_c0_offset_div2;
+   enc->enc_pic.pc.enc_pic_order_cnt_type = pic->seq.pic_order_cnt_type;
+   enc->enc_pic.pc.log2_max_pic_order_cnt_lsb_minus4 = pic->seq.log2_max_pic_order_cnt_lsb_minus4;
 }
 
 static void get_task_info_param(struct rvce_encoder *enc)
@@ -107,12 +109,21 @@ static void get_config_ext_param(struct rvce_encoder *enc)
 
 static void get_vui_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
 {
+   pipe_h264_enc_hrd_params *hrd_params = NULL;
+
+   if (pic->seq.vui_flags.nal_hrd_parameters_present_flag)
+      hrd_params = &pic->seq.nal_hrd_parameters;
+   else if (pic->seq.vui_flags.vcl_hrd_parameters_present_flag)
+      hrd_params = &pic->seq.vcl_hrd_parameters;
+
    enc->enc_pic.enable_vui = pic->seq.vui_parameters_present_flag;
    enc->enc_pic.vui.aspect_ratio_info_present_flag =
       pic->seq.vui_flags.aspect_ratio_info_present_flag;
    enc->enc_pic.vui.aspect_ratio_idc = pic->seq.aspect_ratio_idc;
    enc->enc_pic.vui.sar_width = pic->seq.sar_width;
    enc->enc_pic.vui.sar_height = pic->seq.sar_height;
+   enc->enc_pic.vui.overscan_info_present_flag = pic->seq.vui_flags.overscan_info_present_flag;
+   enc->enc_pic.vui.overscan_Approp_flag = pic->seq.vui_flags.overscan_appropriate_flag;
    enc->enc_pic.vui.video_signal_type_present_flag =
       pic->seq.vui_flags.video_signal_type_present_flag;
    enc->enc_pic.vui.video_format = pic->seq.video_format;
@@ -127,22 +138,30 @@ static void get_vui_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture
    enc->enc_pic.vui.chroma_loc_top = pic->seq.chroma_sample_loc_type_top_field;
    enc->enc_pic.vui.chroma_loc_bottom = pic->seq.chroma_sample_loc_type_bottom_field;
    enc->enc_pic.vui.timing_info_present_flag = pic->seq.vui_flags.timing_info_present_flag;
-   enc->enc_pic.vui.num_units_in_tick = pic->rate_ctrl[0].frame_rate_den;
-   enc->enc_pic.vui.time_scale = pic->rate_ctrl[0].frame_rate_num * 2;
-   enc->enc_pic.vui.fixed_frame_rate_flag = 0x00000001;
-   enc->enc_pic.vui.bit_rate_scale = 0x00000004;
-   enc->enc_pic.vui.cpb_size_scale = 0x00000006;
-   enc->enc_pic.vui.initial_cpb_removal_delay_length_minus1 = 0x00000017;
-   enc->enc_pic.vui.cpb_removal_delay_length_minus1 = 0x00000017;
-   enc->enc_pic.vui.dpb_output_delay_length_minus1 = 0x00000017;
-   enc->enc_pic.vui.time_offset_length = 0x00000018;
+   enc->enc_pic.vui.num_units_in_tick = pic->seq.num_units_in_tick;
+   enc->enc_pic.vui.time_scale = pic->seq.time_scale;
+   enc->enc_pic.vui.fixed_frame_rate_flag = pic->seq.vui_flags.fixed_frame_rate_flag;
+   enc->enc_pic.vui.low_delay_hrd_flag = pic->seq.vui_flags.low_delay_hrd_flag;
+   if (hrd_params) {
+      enc->enc_pic.vui.bit_rate_scale = hrd_params->bit_rate_scale;
+      enc->enc_pic.vui.cpb_size_scale = hrd_params->cpb_size_scale;
+      enc->enc_pic.vui.initial_cpb_removal_delay_length_minus1 =
+         hrd_params->initial_cpb_removal_delay_length_minus1;
+      enc->enc_pic.vui.cpb_removal_delay_length_minus1 = hrd_params->cpb_removal_delay_length_minus1;
+      enc->enc_pic.vui.dpb_output_delay_length_minus1 = hrd_params->dpb_output_delay_length_minus1;
+      enc->enc_pic.vui.time_offset_length = hrd_params->time_offset_length;
+      enc->enc_pic.vui.bit_rate_value_minus = hrd_params->bit_rate_value_minus1[0];
+      enc->enc_pic.vui.cpb_size_value_minus = hrd_params->bit_rate_value_minus1[0];
+      enc->enc_pic.vui.cbr_flag = hrd_params->cbr_flag[0];
+   }
+   enc->enc_pic.vui.bitstream_restriction_present_flag = pic->seq.vui_flags.bitstream_restriction_flag;
    enc->enc_pic.vui.motion_vectors_over_pic_boundaries_flag = 0x00000001;
    enc->enc_pic.vui.max_bytes_per_pic_denom = 0x00000002;
    enc->enc_pic.vui.max_bits_per_mb_denom = 0x00000001;
    enc->enc_pic.vui.log2_max_mv_length_hori = 0x00000010;
    enc->enc_pic.vui.log2_max_mv_length_vert = 0x00000010;
-   enc->enc_pic.vui.num_reorder_frames = 0x00000003;
-   enc->enc_pic.vui.max_dec_frame_buffering = 0x00000003;
+   enc->enc_pic.vui.num_reorder_frames = pic->seq.max_num_reorder_frames;
+   enc->enc_pic.vui.max_dec_frame_buffering = pic->seq.max_dec_frame_buffering;
 }
 
 static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
@@ -176,7 +195,7 @@ static void create(struct rvce_encoder *enc)
 
    RVCE_BEGIN(0x01000001); // create cmd
    RVCE_CS(enc->enc_pic.ec.enc_use_circular_buffer);
-   RVCE_CS(u_get_h264_profile_idc(enc->base.profile)); // encProfile
+   RVCE_CS(enc->pic.seq.profile_idc); // encProfile
    RVCE_CS(enc->pic.seq.level_idc);                    // encLevel
    RVCE_CS(enc->enc_pic.ec.enc_pic_struct_restriction);
    RVCE_CS(enc->base.width);  // encImageWidth
@@ -440,8 +459,7 @@ static void config(struct rvce_encoder *enc)
    enc->config_extension(enc);
    enc->motion_estimation(enc);
    enc->rdo(enc);
-   if (enc->use_vui)
-      enc->vui(enc);
+   enc->vui(enc);
    enc->pic_control(enc);
 }
 
-- 
GitLab


From ca7f10949e1e0336e8b4bbb35cc122cef6611bbd Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 23 Dec 2024 14:46:59 +0100
Subject: [PATCH 04/32] radeonsi/vce: Move dual pipe context to offset 0 of CPB

Needed to allow dynamically growing CPB.
---
 src/gallium/drivers/radeonsi/radeon_vce.c    | 7 +++++--
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 3 +--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.c b/src/gallium/drivers/radeonsi/radeon_vce.c
index 4ee65623357c1..2361de2aded1d 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce.c
@@ -193,7 +193,10 @@ void si_vce_frame_offset(struct rvce_encoder *enc, struct rvce_cpb_slot *slot, s
                          signed *chroma_offset)
 {
    struct si_screen *sscreen = (struct si_screen *)enc->screen;
-   unsigned pitch, vpitch, fsize;
+   unsigned pitch, vpitch, fsize, offset = 0;
+
+   if (enc->dual_pipe)
+      offset += RVCE_MAX_AUX_BUFFER_NUM * RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE * 2;
 
    if (sscreen->info.gfx_level < GFX9) {
       pitch = align(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe, 128);
@@ -204,7 +207,7 @@ void si_vce_frame_offset(struct rvce_encoder *enc, struct rvce_cpb_slot *slot, s
    }
    fsize = pitch * (vpitch + vpitch / 2);
 
-   *luma_offset = slot->index * fsize;
+   *luma_offset = offset + slot->index * fsize;
    *chroma_offset = *luma_offset + pitch * vpitch;
 }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index ca1d1742e9c65..1ef99805ef61d 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -241,8 +241,7 @@ static void encode(struct rvce_encoder *enc)
    RVCE_END();
 
    if (enc->dual_pipe) {
-      unsigned aux_offset =
-         enc->cpb.res->buf->size - RVCE_MAX_AUX_BUFFER_NUM * RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE * 2;
+      unsigned aux_offset = 0;
       RVCE_BEGIN(0x05000002); // auxiliary buffer
       for (i = 0; i < 8; ++i) {
          RVCE_CS(aux_offset);
-- 
GitLab


From f88183ef618a6b81bee7fd0c383790d5c397650b Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Fri, 20 Dec 2024 16:16:16 +0100
Subject: [PATCH 05/32] radeonsi/vce: Use app DPB management

Same logic as VCN, we use max_num_ref_frames + 1 for initial DPB size
and resize later if needed.
---
 src/gallium/drivers/radeonsi/radeon_vce.c    | 207 ++++---------------
 src/gallium/drivers/radeonsi/radeon_vce.h    |  42 ++--
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 196 +++++++++++-------
 3 files changed, 174 insertions(+), 271 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.c b/src/gallium/drivers/radeonsi/radeon_vce.c
index 2361de2aded1d..9415639277715 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce.c
@@ -58,138 +58,10 @@ static void dump_feedback(struct rvce_encoder *enc, struct rvid_buffer *fb)
 }
 #endif
 
-/**
- * reset the CPB handling
- */
-static void reset_cpb(struct rvce_encoder *enc)
-{
-   unsigned i;
-
-   list_inithead(&enc->cpb_slots);
-   for (i = 0; i < enc->cpb_num; ++i) {
-      struct rvce_cpb_slot *slot = &enc->cpb_array[i];
-      slot->index = i;
-      slot->picture_type = PIPE_H2645_ENC_PICTURE_TYPE_SKIP;
-      slot->frame_num = 0;
-      slot->pic_order_cnt = 0;
-      list_addtail(&slot->list, &enc->cpb_slots);
-   }
-}
-
-/**
- * sort l0 and l1 to the top of the list
- */
-static void sort_cpb(struct rvce_encoder *enc)
-{
-   struct rvce_cpb_slot *i, *l0 = NULL, *l1 = NULL;
-
-   LIST_FOR_EACH_ENTRY (i, &enc->cpb_slots, list) {
-      if (i->frame_num == enc->pic.ref_idx_l0_list[0])
-         l0 = i;
-
-      if (i->frame_num == enc->pic.ref_idx_l1_list[0])
-         l1 = i;
-
-      if (enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P && l0)
-         break;
-
-      if (enc->pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B && l0 && l1)
-         break;
-   }
-
-   if (l1) {
-      list_del(&l1->list);
-      list_add(&l1->list, &enc->cpb_slots);
-   }
-
-   if (l0) {
-      list_del(&l0->list);
-      list_add(&l0->list, &enc->cpb_slots);
-   }
-}
-
-/**
- * get number of cpbs based on dpb
- */
-static unsigned get_cpb_num(struct rvce_encoder *enc, unsigned level_idc)
-{
-   unsigned w = align(enc->base.width, 16) / 16;
-   unsigned h = align(enc->base.height, 16) / 16;
-   unsigned dpb;
-
-   switch (level_idc) {
-   case 10:
-      dpb = 396;
-      break;
-   case 11:
-      dpb = 900;
-      break;
-   case 12:
-   case 13:
-   case 20:
-      dpb = 2376;
-      break;
-   case 21:
-      dpb = 4752;
-      break;
-   case 22:
-   case 30:
-      dpb = 8100;
-      break;
-   case 31:
-      dpb = 18000;
-      break;
-   case 32:
-      dpb = 20480;
-      break;
-   case 40:
-   case 41:
-      dpb = 32768;
-      break;
-   case 42:
-      dpb = 34816;
-      break;
-   case 50:
-      dpb = 110400;
-      break;
-   default:
-   case 51:
-   case 52:
-      dpb = 184320;
-      break;
-   }
-
-   return MIN2(dpb / (w * h), 16);
-}
-
-/**
- * Get the slot for the currently encoded frame
- */
-struct rvce_cpb_slot *si_current_slot(struct rvce_encoder *enc)
-{
-   return list_entry(enc->cpb_slots.prev, struct rvce_cpb_slot, list);
-}
-
-/**
- * Get the slot for L0
- */
-struct rvce_cpb_slot *si_l0_slot(struct rvce_encoder *enc)
-{
-   return list_entry(enc->cpb_slots.next, struct rvce_cpb_slot, list);
-}
-
-/**
- * Get the slot for L1
- */
-struct rvce_cpb_slot *si_l1_slot(struct rvce_encoder *enc)
-{
-   return list_entry(enc->cpb_slots.next->next, struct rvce_cpb_slot, list);
-}
-
 /**
  * Calculate the offsets into the CPB
  */
-void si_vce_frame_offset(struct rvce_encoder *enc, struct rvce_cpb_slot *slot, signed *luma_offset,
+void si_vce_frame_offset(struct rvce_encoder *enc, unsigned slot, signed *luma_offset,
                          signed *chroma_offset)
 {
    struct si_screen *sscreen = (struct si_screen *)enc->screen;
@@ -207,7 +79,7 @@ void si_vce_frame_offset(struct rvce_encoder *enc, struct rvce_cpb_slot *slot, s
    }
    fsize = pitch * (vpitch + vpitch / 2);
 
-   *luma_offset = offset + slot->index * fsize;
+   *luma_offset = offset + slot * fsize;
    *chroma_offset = *luma_offset + pitch * vpitch;
 }
 
@@ -228,10 +100,32 @@ static void rvce_destroy(struct pipe_video_codec *encoder)
    }
    si_vid_destroy_buffer(&enc->cpb);
    enc->ws->cs_destroy(&enc->cs);
-   FREE(enc->cpb_array);
    FREE(enc);
 }
 
+static unsigned get_cpb_size(struct rvce_encoder *enc, unsigned slots)
+{
+   struct si_screen *sscreen = (struct si_screen *)enc->screen;
+   unsigned cpb_size;
+
+   cpb_size = (sscreen->info.gfx_level < GFX9)
+                 ? align(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe, 128) *
+                      align(enc->luma->u.legacy.level[0].nblk_y, 32)
+                 :
+
+                 align(enc->luma->u.gfx9.surf_pitch * enc->luma->bpe, 256) *
+                    align(enc->luma->u.gfx9.surf_height, 32);
+
+   cpb_size = cpb_size * 3 / 2;
+   cpb_size = cpb_size * slots;
+   if (enc->dual_pipe)
+      cpb_size += RVCE_MAX_AUX_BUFFER_NUM * RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE * 2;
+
+   enc->dpb_slots = slots;
+
+   return cpb_size;
+}
+
 static void rvce_begin_frame(struct pipe_video_codec *encoder, struct pipe_video_buffer *source,
                              struct pipe_picture_desc *picture)
 {
@@ -249,48 +143,28 @@ static void rvce_begin_frame(struct pipe_video_codec *encoder, struct pipe_video
       enc->pic.rate_ctrl[0].frame_rate_den != pic->rate_ctrl[0].frame_rate_den;
 
    enc->pic = *pic;
-   enc->base.max_references = pic->seq.max_num_ref_frames;
    enc->si_get_pic_param(enc, pic);
 
    enc->get_buffer(vid_buf->resources[0], &enc->handle, &enc->luma);
    enc->get_buffer(vid_buf->resources[1], NULL, &enc->chroma);
 
-   if (!enc->cpb_num) {
-      struct si_screen *sscreen = (struct si_screen *)encoder->context->screen;
-      unsigned cpb_size;
+   unsigned dpb_slots = MAX2(pic->seq.max_num_ref_frames + 1, pic->dpb_size);
 
-      enc->cpb_num = get_cpb_num(enc, enc->pic.seq.level_idc);
-      if (!enc->cpb_num)
-         return;
-
-      enc->cpb_array = CALLOC(enc->cpb_num, sizeof(struct rvce_cpb_slot));
-      if (!enc->cpb_array)
-         return;
-
-      cpb_size = (sscreen->info.gfx_level < GFX9)
-                    ? align(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe, 128) *
-                         align(enc->luma->u.legacy.level[0].nblk_y, 32)
-                    :
-
-                    align(enc->luma->u.gfx9.surf_pitch * enc->luma->bpe, 256) *
-                       align(enc->luma->u.gfx9.surf_height, 32);
+   if (enc->dpb_slots < dpb_slots) {
+      unsigned cpb_size;
 
-      cpb_size = cpb_size * 3 / 2;
-      cpb_size = cpb_size * enc->cpb_num;
-      if (enc->dual_pipe)
-         cpb_size += RVCE_MAX_AUX_BUFFER_NUM * RVCE_MAX_BITSTREAM_OUTPUT_ROW_SIZE * 2;
-      if (!si_vid_create_buffer(enc->screen, &enc->cpb, cpb_size, PIPE_USAGE_DEFAULT)) {
-         RVID_ERR("Can't create CPB buffer.\n");
+      cpb_size = get_cpb_size(enc, dpb_slots);
+      if (!enc->cpb.res) {
+         if (!si_vid_create_buffer(enc->screen, &enc->cpb, cpb_size, PIPE_USAGE_DEFAULT)) {
+            RVID_ERR("Can't create CPB buffer.\n");
+            return;
+         }
+      } else if (!si_vid_resize_buffer(enc->base.context, &enc->cs, &enc->cpb, cpb_size, NULL)) {
+         RVID_ERR("Can't resize CPB buffer.\n");
          return;
       }
    }
 
-   if (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR)
-      reset_cpb(enc);
-   else if (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
-            pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
-      sort_cpb(enc);
-
    if (!enc->stream_handle) {
       struct rvid_buffer fb;
       enc->stream_handle = si_vid_alloc_stream_handle();
@@ -336,18 +210,9 @@ static int rvce_end_frame(struct pipe_video_codec *encoder, struct pipe_video_bu
                           struct pipe_picture_desc *picture)
 {
    struct rvce_encoder *enc = (struct rvce_encoder *)encoder;
-   struct rvce_cpb_slot *slot = list_entry(enc->cpb_slots.prev, struct rvce_cpb_slot, list);
 
    flush(enc, picture->flush_flags, picture->fence);
 
-   /* update the CPB backtrack with the just encoded frame */
-   slot->picture_type = enc->pic.picture_type;
-   slot->frame_num = enc->pic.frame_num;
-   slot->pic_order_cnt = enc->pic.pic_order_cnt;
-   if (!enc->pic.not_referenced) {
-      list_del(&slot->list);
-      list_add(&slot->list, &enc->cpb_slots);
-   }
    return 0;
 }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index ebb44ce4aeea1..b3bffb073733b 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -36,16 +36,6 @@ struct si_screen;
 typedef void (*rvce_get_buffer)(struct pipe_resource *resource, struct pb_buffer_lean **handle,
                                 struct radeon_surf **surface);
 
-/* Coded picture buffer slot */
-struct rvce_cpb_slot {
-   struct list_head list;
-
-   unsigned index;
-   enum pipe_h2645_enc_picture_type picture_type;
-   unsigned frame_num;
-   unsigned pic_order_cnt;
-};
-
 struct rvce_rate_control {
    uint32_t rc_method;
    uint32_t target_bitrate;
@@ -239,25 +229,28 @@ struct rvce_enc_operation {
    uint32_t num_ref_idx_active_override_flag;
    uint32_t num_ref_idx_l0_active_minus1;
    uint32_t num_ref_idx_l1_active_minus1;
-   uint32_t enc_ref_list_modification_op;
-   uint32_t enc_ref_list_modification_num;
-   uint32_t enc_decoded_picture_marking_op;
-   uint32_t enc_decoded_picture_marking_num;
-   uint32_t enc_decoded_picture_marking_idx;
-   uint32_t enc_decoded_ref_base_picture_marking_op;
-   uint32_t enc_decoded_ref_base_picture_marking_num;
+   uint32_t enc_ref_list_modification_op[4];
+   uint32_t enc_ref_list_modification_num[4];
+   uint32_t enc_decoded_picture_marking_op[4];
+   uint32_t enc_decoded_picture_marking_num[4];
+   uint32_t enc_decoded_picture_marking_idx[4];
+   uint32_t enc_decoded_ref_base_picture_marking_op[4];
+   uint32_t enc_decoded_ref_base_picture_marking_num[4];
+   uint32_t l0_dpb_idx;
    uint32_t l0_picture_structure;
    uint32_t l0_enc_pic_type;
    uint32_t l0_frame_number;
    uint32_t l0_picture_order_count;
    uint32_t l0_luma_offset;
    uint32_t l0_chroma_offset;
+   uint32_t l1_dpb_idx;
    uint32_t l1_picture_structure;
    uint32_t l1_enc_pic_type;
    uint32_t l1_frame_number;
    uint32_t l1_picture_order_count;
    uint32_t l1_luma_offset;
    uint32_t l1_chroma_offset;
+   uint32_t cur_dpb_idx;
    uint32_t enc_reconstructed_luma_offset;
    uint32_t enc_reconstructed_chroma_offset;
    ;
@@ -332,17 +325,11 @@ struct rvce_h264_enc_pic {
    unsigned gop_cnt;
    unsigned gop_size;
    unsigned pic_order_cnt;
-   unsigned ref_idx_l0;
-   unsigned ref_idx_l1;
    unsigned addrmode_arraymode_disrdo_distwoinstants;
 
    bool not_referenced;
    bool is_idr;
-   bool has_ref_pic_list;
    bool enable_vui;
-   unsigned int ref_pic_list_0[32];
-   unsigned int ref_pic_list_1[32];
-   unsigned int frame_idx[32];
 };
 
 /* VCE encoder representation */
@@ -381,9 +368,7 @@ struct rvce_encoder {
    struct pb_buffer_lean *bs_handle;
    unsigned bs_size;
 
-   struct rvce_cpb_slot *cpb_array;
-   struct list_head cpb_slots;
-   unsigned cpb_num;
+   unsigned dpb_slots;
 
    struct rvid_buffer *fb;
    struct rvid_buffer cpb;
@@ -398,10 +383,7 @@ struct rvce_encoder {
 };
 
 /* CPB handling functions */
-struct rvce_cpb_slot *si_current_slot(struct rvce_encoder *enc);
-struct rvce_cpb_slot *si_l0_slot(struct rvce_encoder *enc);
-struct rvce_cpb_slot *si_l1_slot(struct rvce_encoder *enc);
-void si_vce_frame_offset(struct rvce_encoder *enc, struct rvce_cpb_slot *slot, signed *luma_offset,
+void si_vce_frame_offset(struct rvce_encoder *enc, unsigned slot, signed *luma_offset,
                          signed *chroma_offset);
 
 struct pipe_video_codec *si_vce_create_encoder(struct pipe_context *context,
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 1ef99805ef61d..9c52e6593e72e 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -16,6 +16,11 @@
 
 #include <stdio.h>
 
+#define REF_LIST_MODIFICATION_OP_END                  0
+#define REF_LIST_MODIFICATION_OP_SHORT_TERM_SUBTRACT  1
+#define REF_LIST_MODIFICATION_OP_LONG_TERM            2
+#define REF_LIST_MODIFICATION_OP_VIEW_ADD             3
+
 static void get_rate_control_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
 {
    enc->enc_pic.rc.rc_method = pic->rate_ctrl[0].rate_ctrl_method;
@@ -166,6 +171,8 @@ static void get_vui_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture
 
 static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
 {
+   int i;
+
    get_rate_control_param(enc, pic);
    get_motion_estimation_param(enc, pic);
    get_pic_control_param(enc, pic);
@@ -176,16 +183,104 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
 
    enc->enc_pic.picture_type = pic->picture_type;
    enc->enc_pic.frame_num = pic->frame_num;
-   enc->enc_pic.frame_num_cnt = pic->frame_num_cnt;
+   enc->enc_pic.frame_num_cnt = pic->frame_num_cnt - 1;
    enc->enc_pic.p_remain = pic->p_remain;
    enc->enc_pic.i_remain = pic->i_remain;
    enc->enc_pic.gop_cnt = pic->gop_cnt;
    enc->enc_pic.pic_order_cnt = pic->pic_order_cnt;
-   enc->enc_pic.ref_idx_l0 = pic->ref_idx_l0_list[0];
-   enc->enc_pic.ref_idx_l1 = pic->ref_idx_l1_list[0];
    enc->enc_pic.not_referenced = pic->not_referenced;
    enc->enc_pic.addrmode_arraymode_disrdo_distwoinstants = 0x01000201;
    enc->enc_pic.is_idr = (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR);
+   enc->enc_pic.eo.enc_idr_pic_id = pic->idr_pic_id;
+
+   enc->enc_pic.eo.insert_headers = 0;
+   enc->enc_pic.eo.insert_aud = 0;
+   util_dynarray_foreach(&pic->raw_headers, struct pipe_enc_raw_header, header) {
+      switch (header->type) {
+      case PIPE_H264_NAL_SPS:
+         enc->enc_pic.eo.insert_headers |= 0x01;
+         break;
+      case PIPE_H264_NAL_PPS:
+         enc->enc_pic.eo.insert_headers |= 0x10;
+         break;
+      case PIPE_H264_NAL_AUD:
+         enc->enc_pic.eo.insert_aud = 1;
+         break;
+      default:
+         break;
+      }
+   }
+
+   enc->enc_pic.eo.num_ref_idx_active_override_flag = pic->slice.num_ref_idx_active_override_flag;
+   enc->enc_pic.eo.num_ref_idx_l0_active_minus1 = pic->slice.num_ref_idx_l0_active_minus1;
+   enc->enc_pic.eo.num_ref_idx_l1_active_minus1 = pic->slice.num_ref_idx_l1_active_minus1;
+
+   i = 0;
+   if (pic->slice.ref_pic_list_modification_flag_l0) {
+      for (; i < MIN2(4, pic->slice.num_ref_list0_mod_operations); i++) {
+         struct pipe_h264_ref_list_mod_entry *entry = &pic->slice.ref_list0_mod_operations[i];
+         switch (entry->modification_of_pic_nums_idc) {
+         case 0:
+            enc->enc_pic.eo.enc_ref_list_modification_op[i] = REF_LIST_MODIFICATION_OP_SHORT_TERM_SUBTRACT;
+            enc->enc_pic.eo.enc_ref_list_modification_num[i] = entry->abs_diff_pic_num_minus1;
+            break;
+         case 2:
+            enc->enc_pic.eo.enc_ref_list_modification_op[i] = REF_LIST_MODIFICATION_OP_LONG_TERM;
+            enc->enc_pic.eo.enc_ref_list_modification_num[i] = entry->long_term_pic_num;
+            break;
+         case 5:
+            enc->enc_pic.eo.enc_ref_list_modification_op[i] = REF_LIST_MODIFICATION_OP_VIEW_ADD;
+            enc->enc_pic.eo.enc_ref_list_modification_num[i] = entry->abs_diff_pic_num_minus1;
+            break;
+         default:
+         case 3:
+            enc->enc_pic.eo.enc_ref_list_modification_op[i] = REF_LIST_MODIFICATION_OP_END;
+            break;
+         }
+      }
+   }
+   if (i < 4)
+      enc->enc_pic.eo.enc_ref_list_modification_op[i] = REF_LIST_MODIFICATION_OP_END;
+
+   i = 0;
+   if (pic->pic_ctrl.nal_unit_type == PIPE_H264_NAL_IDR_SLICE) {
+      enc->enc_pic.eo.enc_decoded_picture_marking_op[i++] = pic->slice.long_term_reference_flag ? 6 : 0;
+   } else if (pic->slice.adaptive_ref_pic_marking_mode_flag) {
+      for (; i < MIN2(4, pic->slice.num_ref_pic_marking_operations); i++) {
+         struct pipe_h264_ref_pic_marking_entry *entry = &pic->slice.ref_pic_marking_operations[i];
+         enc->enc_pic.eo.enc_decoded_picture_marking_op[i] = entry->memory_management_control_operation;
+         switch (entry->memory_management_control_operation) {
+         case 1:
+            enc->enc_pic.eo.enc_decoded_picture_marking_num[i] = entry->difference_of_pic_nums_minus1;
+            break;
+         case 2:
+            enc->enc_pic.eo.enc_decoded_picture_marking_num[i] = entry->long_term_pic_num;
+            break;
+         case 3:
+            enc->enc_pic.eo.enc_decoded_picture_marking_num[i] = entry->difference_of_pic_nums_minus1;
+            enc->enc_pic.eo.enc_decoded_picture_marking_idx[i] = entry->long_term_frame_idx;
+            break;
+         case 4:
+            enc->enc_pic.eo.enc_decoded_picture_marking_idx[i] = entry->max_long_term_frame_idx_plus1;
+            break;
+         case 6:
+            enc->enc_pic.eo.enc_decoded_picture_marking_idx[i] = entry->long_term_frame_idx;
+            break;
+         default:
+            break;
+         }
+      }
+   }
+   if (i < 4)
+      enc->enc_pic.eo.enc_decoded_picture_marking_op[i] = 0;
+
+   enc->enc_pic.eo.cur_dpb_idx = pic->dpb_curr_pic;
+
+   enc->enc_pic.eo.l0_dpb_idx = pic->ref_list0[0];
+
+   enc->enc_pic.eo.l1_dpb_idx = PIPE_H2645_LIST_REF_INVALID_ENTRY;
+   enc->enc_pic.eo.l1_luma_offset = 0xffffffff;
+   enc->enc_pic.eo.l1_chroma_offset = 0xffffffff;
 }
 
 static void create(struct rvce_encoder *enc)
@@ -253,7 +348,7 @@ static void encode(struct rvce_encoder *enc)
    }
 
    RVCE_BEGIN(0x03000001);                       // encode
-   RVCE_CS(enc->enc_pic.frame_num ? 0x0 : 0x11); // insertHeaders
+   RVCE_CS(enc->enc_pic.eo.insert_headers);
    RVCE_CS(enc->enc_pic.eo.picture_structure);
    RVCE_CS(enc->bs_size); // allowedMaxBitstreamSize
    RVCE_CS(enc->enc_pic.eo.force_refresh_map);
@@ -287,11 +382,6 @@ static void encode(struct rvce_encoder *enc)
    RVCE_CS(enc->enc_pic.eo.enc_input_pic_tile_config);
    RVCE_CS(enc->enc_pic.picture_type);                                    // encPicType
    RVCE_CS(enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR); // encIdrFlag
-   if ((enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) &&
-       (enc->enc_pic.eo.enc_idr_pic_id != 0))
-      enc->enc_pic.eo.enc_idr_pic_id = enc->enc_pic.idr_pic_id - 1;
-   else
-      enc->enc_pic.eo.enc_idr_pic_id = 0x00000000;
    RVCE_CS(enc->enc_pic.eo.enc_idr_pic_id);
    RVCE_CS(enc->enc_pic.eo.enc_mgs_key_pic);
    RVCE_CS(!enc->enc_pic.not_referenced);
@@ -300,56 +390,37 @@ static void encode(struct rvce_encoder *enc)
    RVCE_CS(enc->enc_pic.eo.num_ref_idx_l0_active_minus1);
    RVCE_CS(enc->enc_pic.eo.num_ref_idx_l1_active_minus1);
 
-   i = enc->enc_pic.frame_num - enc->enc_pic.ref_idx_l0;
-   if (i > 1 && enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P) {
-      enc->enc_pic.eo.enc_ref_list_modification_op = 0x00000001;
-      enc->enc_pic.eo.enc_ref_list_modification_num = i - 1;
-      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_op);
-      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_num);
-   } else {
-      enc->enc_pic.eo.enc_ref_list_modification_op = 0x00000000;
-      enc->enc_pic.eo.enc_ref_list_modification_num = 0x00000000;
-      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_op);
-      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_num);
+   for (i = 0; i < 4; ++i) {
+      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_op[i]);
+      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_num[i]);
    }
 
-   for (i = 0; i < 3; ++i) {
-      enc->enc_pic.eo.enc_ref_list_modification_op = 0x00000000;
-      enc->enc_pic.eo.enc_ref_list_modification_num = 0x00000000;
-      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_op);
-      RVCE_CS(enc->enc_pic.eo.enc_ref_list_modification_num);
+   for (i = 0; i < 4; ++i) {
+      RVCE_CS(enc->enc_pic.eo.enc_decoded_picture_marking_op[i]);
+      RVCE_CS(enc->enc_pic.eo.enc_decoded_picture_marking_num[i]);
+      RVCE_CS(enc->enc_pic.eo.enc_decoded_picture_marking_idx[i]);
    }
+
    for (i = 0; i < 4; ++i) {
-      RVCE_CS(enc->enc_pic.eo.enc_decoded_picture_marking_op);
-      RVCE_CS(enc->enc_pic.eo.enc_decoded_picture_marking_num);
-      RVCE_CS(enc->enc_pic.eo.enc_decoded_picture_marking_idx);
-      RVCE_CS(enc->enc_pic.eo.enc_decoded_ref_base_picture_marking_op);
-      RVCE_CS(enc->enc_pic.eo.enc_decoded_ref_base_picture_marking_num);
+      RVCE_CS(enc->enc_pic.eo.enc_decoded_ref_base_picture_marking_op[i]);
+      RVCE_CS(enc->enc_pic.eo.enc_decoded_ref_base_picture_marking_num[i]);
    }
 
    // encReferencePictureL0[0]
-   RVCE_CS(0x00000000); // pictureStructure
-   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
-       enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      struct rvce_cpb_slot *l0 = si_l0_slot(enc);
-      si_vce_frame_offset(enc, l0, &luma_offset, &chroma_offset);
-      RVCE_CS(l0->picture_type);
-      RVCE_CS(l0->frame_num);
-      RVCE_CS(l0->pic_order_cnt);
-      RVCE_CS(luma_offset);
-      RVCE_CS(chroma_offset);
+   if (enc->enc_pic.eo.l0_dpb_idx != PIPE_H2645_LIST_REF_INVALID_ENTRY) {
+      si_vce_frame_offset(enc, enc->enc_pic.eo.l0_dpb_idx, &luma_offset, &chroma_offset);
+      enc->enc_pic.eo.l0_luma_offset = luma_offset;
+      enc->enc_pic.eo.l0_chroma_offset = chroma_offset;
    } else {
-      enc->enc_pic.eo.l0_enc_pic_type = 0x00000000;
-      enc->enc_pic.eo.l0_frame_number = 0x00000000;
-      enc->enc_pic.eo.l0_picture_order_count = 0x00000000;
       enc->enc_pic.eo.l0_luma_offset = 0xffffffff;
       enc->enc_pic.eo.l0_chroma_offset = 0xffffffff;
-      RVCE_CS(enc->enc_pic.eo.l0_enc_pic_type);
-      RVCE_CS(enc->enc_pic.eo.l0_frame_number);
-      RVCE_CS(enc->enc_pic.eo.l0_picture_order_count);
-      RVCE_CS(enc->enc_pic.eo.l0_luma_offset);
-      RVCE_CS(enc->enc_pic.eo.l0_chroma_offset);
    }
+   RVCE_CS(0x00000000); // pictureStructure
+   RVCE_CS(enc->enc_pic.eo.l0_enc_pic_type);
+   RVCE_CS(enc->enc_pic.eo.l0_frame_number);
+   RVCE_CS(enc->enc_pic.eo.l0_picture_order_count);
+   RVCE_CS(enc->enc_pic.eo.l0_luma_offset);
+   RVCE_CS(enc->enc_pic.eo.l0_chroma_offset);
 
    // encReferencePictureL0[1]
    enc->enc_pic.eo.l0_picture_structure = 0x00000000;
@@ -367,28 +438,13 @@ static void encode(struct rvce_encoder *enc)
 
    // encReferencePictureL1[0]
    RVCE_CS(0x00000000); // pictureStructure
-   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
-      struct rvce_cpb_slot *l1 = si_l1_slot(enc);
-      si_vce_frame_offset(enc, l1, &luma_offset, &chroma_offset);
-      RVCE_CS(l1->picture_type);
-      RVCE_CS(l1->frame_num);
-      RVCE_CS(l1->pic_order_cnt);
-      RVCE_CS(luma_offset);
-      RVCE_CS(chroma_offset);
-   } else {
-      enc->enc_pic.eo.l1_enc_pic_type = 0x00000000;
-      enc->enc_pic.eo.l1_frame_number = 0x00000000;
-      enc->enc_pic.eo.l1_picture_order_count = 0x00000000;
-      enc->enc_pic.eo.l1_luma_offset = 0xffffffff;
-      enc->enc_pic.eo.l1_chroma_offset = 0xffffffff;
-      RVCE_CS(enc->enc_pic.eo.l1_enc_pic_type);
-      RVCE_CS(enc->enc_pic.eo.l1_frame_number);
-      RVCE_CS(enc->enc_pic.eo.l1_picture_order_count);
-      RVCE_CS(enc->enc_pic.eo.l1_luma_offset);
-      RVCE_CS(enc->enc_pic.eo.l1_chroma_offset);
-   }
+   RVCE_CS(enc->enc_pic.eo.l1_enc_pic_type);
+   RVCE_CS(enc->enc_pic.eo.l1_frame_number);
+   RVCE_CS(enc->enc_pic.eo.l1_picture_order_count);
+   RVCE_CS(enc->enc_pic.eo.l1_luma_offset);
+   RVCE_CS(enc->enc_pic.eo.l1_chroma_offset);
 
-   si_vce_frame_offset(enc, si_current_slot(enc), &luma_offset, &chroma_offset);
+   si_vce_frame_offset(enc, enc->enc_pic.eo.cur_dpb_idx, &luma_offset, &chroma_offset);
    RVCE_CS(luma_offset);
    RVCE_CS(chroma_offset);
    RVCE_CS(enc->enc_pic.eo.enc_coloc_buffer_offset);
@@ -396,7 +452,7 @@ static void encode(struct rvce_encoder *enc)
    RVCE_CS(enc->enc_pic.eo.enc_reconstructed_ref_base_picture_chroma_offset);
    RVCE_CS(enc->enc_pic.eo.enc_reference_ref_base_picture_luma_offset);
    RVCE_CS(enc->enc_pic.eo.enc_reference_ref_base_picture_chroma_offset);
-   RVCE_CS(enc->enc_pic.frame_num_cnt - 1);
+   RVCE_CS(enc->enc_pic.frame_num_cnt);
    RVCE_CS(enc->enc_pic.frame_num);
    RVCE_CS(enc->enc_pic.pic_order_cnt);
    RVCE_CS(enc->enc_pic.i_remain);
-- 
GitLab


From f0162b0308728cea8bae4b87e566b7f4b8d98170 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 23 Dec 2024 16:00:06 +0100
Subject: [PATCH 06/32] radeonsi/vce: Support slice encoding

---
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 36 ++++++++++++++++----
 1 file changed, 30 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 9c52e6593e72e..2990a994323d3 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -72,20 +72,44 @@ static void get_motion_estimation_param(struct rvce_encoder *enc,
 
 static void get_pic_control_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
 {
-   unsigned encNumMBsPerSlice;
-   encNumMBsPerSlice = align(enc->base.width, 16) / 16;
-   encNumMBsPerSlice *= align(enc->base.height, 16) / 16;
+   uint32_t num_mbs_total, num_mbs_in_slice;
+
+   num_mbs_total = DIV_ROUND_UP(enc->base.width, 16) * DIV_ROUND_UP(enc->base.height, 16);
+
+   if (pic->num_slice_descriptors <= 1) {
+      num_mbs_in_slice = num_mbs_total;
+   } else {
+      bool use_app_config = true;
+      num_mbs_in_slice = pic->slices_descriptors[0].num_macroblocks;
+
+      /* All slices must have equal size */
+      for (unsigned i = 1; i < pic->num_slice_descriptors - 1; i++) {
+         if (num_mbs_in_slice != pic->slices_descriptors[i].num_macroblocks)
+            use_app_config = false;
+      }
+      /* Except last one can be smaller */
+      if (pic->slices_descriptors[pic->num_slice_descriptors - 1].num_macroblocks > num_mbs_in_slice)
+         use_app_config = false;
+
+      if (!use_app_config) {
+         assert(num_mbs_total >= pic->num_slice_descriptors);
+         num_mbs_in_slice =
+            (num_mbs_total + pic->num_slice_descriptors - 1) / pic->num_slice_descriptors;
+      }
+   }
+
    if (pic->seq.enc_frame_cropping_flag) {
       enc->enc_pic.pc.enc_crop_left_offset = pic->seq.enc_frame_crop_left_offset;
       enc->enc_pic.pc.enc_crop_right_offset = pic->seq.enc_frame_crop_right_offset;
       enc->enc_pic.pc.enc_crop_top_offset = pic->seq.enc_frame_crop_top_offset;
       enc->enc_pic.pc.enc_crop_bottom_offset = pic->seq.enc_frame_crop_bottom_offset;
    }
-   enc->enc_pic.pc.enc_num_mbs_per_slice = encNumMBsPerSlice;
+   enc->enc_pic.pc.enc_num_mbs_per_slice = num_mbs_in_slice;
    enc->enc_pic.pc.enc_number_of_reference_frames = 1;
    enc->enc_pic.pc.enc_max_num_ref_frames = pic->seq.max_num_ref_frames;
    enc->enc_pic.pc.enc_num_default_active_ref_l0 = pic->pic_ctrl.num_ref_idx_l0_default_active_minus1 + 1;
    enc->enc_pic.pc.enc_num_default_active_ref_l1 = pic->pic_ctrl.num_ref_idx_l1_default_active_minus1 + 1;
+   enc->enc_pic.pc.enc_slice_mode = 1;
    enc->enc_pic.pc.enc_use_constrained_intra_pred = pic->pic_ctrl.constrained_intra_pred_flag;
    enc->enc_pic.pc.enc_cabac_enable = pic->pic_ctrl.enc_cabac_enable;
    enc->enc_pic.pc.enc_cabac_idc = pic->pic_ctrl.enc_cabac_init_idc;
@@ -293,8 +317,8 @@ static void create(struct rvce_encoder *enc)
    RVCE_CS(enc->pic.seq.profile_idc); // encProfile
    RVCE_CS(enc->pic.seq.level_idc);                    // encLevel
    RVCE_CS(enc->enc_pic.ec.enc_pic_struct_restriction);
-   RVCE_CS(enc->base.width);  // encImageWidth
-   RVCE_CS(enc->base.height); // encImageHeight
+   RVCE_CS(align(enc->base.width, 16));  // encImageWidth
+   RVCE_CS(align(enc->base.height, 16)); // encImageHeight
 
    if (sscreen->info.gfx_level < GFX9) {
       RVCE_CS(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe);     // encRefPicLumaPitch
-- 
GitLab


From 1f4bd008b347e0bf27d9bc2eb1136c1e919d7e5f Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Sun, 29 Dec 2024 15:16:50 +0100
Subject: [PATCH 07/32] radeonsi/vce: Support VBAQ

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce.h    | 10 +++++++++-
 src/gallium/drivers/radeonsi/radeon_vce_52.c |  3 +++
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index b3bffb073733b..4ad3904561fb5 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -293,7 +293,15 @@ struct rvce_enc_create {
    uint32_t enc_pre_encode_context_buffer_offset;
    uint32_t enc_pre_encode_input_luma_buffer_offset;
    uint32_t enc_pre_encode_input_chroma_buffer_offset;
-   uint32_t enc_pre_encode_mode_chromaflag_vbaqmode_scenechangesensitivity;
+   union {
+      struct {
+         uint8_t enc_pre_encode_mode;
+         uint8_t enc_pre_encode_chroma_flag;
+         uint8_t enc_vbaq_mode;
+         uint8_t enc_scene_change_sensitivity;
+      };
+      uint32_t enc_pre_encode_mode_chromaflag_vbaqmode_scenechangesensitivity;
+   };
 };
 
 struct rvce_config_ext {
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 2990a994323d3..524ad23338695 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -216,6 +216,9 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
    enc->enc_pic.addrmode_arraymode_disrdo_distwoinstants = 0x01000201;
    enc->enc_pic.is_idr = (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR);
    enc->enc_pic.eo.enc_idr_pic_id = pic->idr_pic_id;
+   enc->enc_pic.ec.enc_vbaq_mode =
+      pic->rate_ctrl[0].rate_ctrl_method != PIPE_H2645_ENC_RATE_CONTROL_METHOD_DISABLE &&
+      pic->quality_modes.vbaq_mode;
 
    enc->enc_pic.eo.insert_headers = 0;
    enc->enc_pic.eo.insert_aud = 0;
-- 
GitLab


From e27cae79e99077c1551a75b8d026a978265651e7 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Fri, 27 Dec 2024 15:29:54 +0100
Subject: [PATCH 08/32] radeonsi/vce: Support quality presets

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 57 ++++++++++++++++----
 1 file changed, 48 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 524ad23338695..e928778a47dd5 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -55,19 +55,58 @@ static void get_rate_control_param(struct rvce_encoder *enc, struct pipe_h264_en
 static void get_motion_estimation_param(struct rvce_encoder *enc,
                                         struct pipe_h264_enc_picture_desc *pic)
 {
+   enc->enc_pic.me.enc_ime_decimation_search = 1;
+   enc->enc_pic.me.motion_est_half_pixel = 1;
    enc->enc_pic.me.motion_est_quarter_pixel = 1;
-   enc->enc_pic.me.enc_disable_sub_mode = 254;
+   enc->enc_pic.me.disable_favor_pmv_point = 0;
    enc->enc_pic.me.lsmvert = 2;
-   enc->enc_pic.me.enc_en_ime_overw_dis_subm = 0;
-   enc->enc_pic.me.enc_ime_overw_dis_subm_no = 0;
+   enc->enc_pic.me.disable_16x16_frame1 = 0;
+   enc->enc_pic.me.disable_satd = 0;
+   enc->enc_pic.me.enc_ime_skip_x = 0;
+   enc->enc_pic.me.enc_ime_skip_y = 0;
    enc->enc_pic.me.enc_ime2_search_range_x = 4;
    enc->enc_pic.me.enc_ime2_search_range_y = 4;
-   enc->enc_pic.me.enc_ime_decimation_search = 0x00000001;
-   enc->enc_pic.me.motion_est_half_pixel = 0x00000001;
-   enc->enc_pic.me.enc_search_range_x = 0x00000010;
-   enc->enc_pic.me.enc_search_range_y = 0x00000010;
-   enc->enc_pic.me.enc_search1_range_x = 0x00000010;
-   enc->enc_pic.me.enc_search1_range_y = 0x00000010;
+   enc->enc_pic.me.parallel_mode_speedup_enable = 0;
+   enc->enc_pic.me.fme0_enc_disable_sub_mode = 0;
+   enc->enc_pic.me.fme1_enc_disable_sub_mode = 0;
+   enc->enc_pic.me.ime_sw_speedup_enable = 0;
+
+   switch (pic->quality_modes.preset_mode) {
+   case 0: /* SPEED */
+      enc->enc_pic.me.force_zero_point_center = 0;
+      enc->enc_pic.me.enc_search_range_x = 16;
+      enc->enc_pic.me.enc_search_range_y = 16;
+      enc->enc_pic.me.enc_search1_range_x = 16;
+      enc->enc_pic.me.enc_search1_range_y = 16;
+      enc->enc_pic.me.enable_amd = 0;
+      enc->enc_pic.me.enc_disable_sub_mode = 126;
+      enc->enc_pic.me.enc_en_ime_overw_dis_subm = 0;
+      enc->enc_pic.me.enc_ime_overw_dis_subm_no = 0;
+      break;
+   case 1: /* BALANCED */
+      enc->enc_pic.me.force_zero_point_center = 0;
+      enc->enc_pic.me.enc_search_range_x = 16;
+      enc->enc_pic.me.enc_search_range_y = 16;
+      enc->enc_pic.me.enc_search1_range_x = 16;
+      enc->enc_pic.me.enc_search1_range_y = 16;
+      enc->enc_pic.me.enable_amd = 0;
+      enc->enc_pic.me.enc_disable_sub_mode = 120;
+      enc->enc_pic.me.enc_en_ime_overw_dis_subm = 1;
+      enc->enc_pic.me.enc_ime_overw_dis_subm_no = 1;
+      break;
+   case 2: /* QUALITY */
+   default:
+      enc->enc_pic.me.force_zero_point_center = 1;
+      enc->enc_pic.me.enc_search_range_x = 36;
+      enc->enc_pic.me.enc_search_range_y = 36;
+      enc->enc_pic.me.enc_search1_range_x = 36;
+      enc->enc_pic.me.enc_search1_range_y = 36;
+      enc->enc_pic.me.enable_amd = 1;
+      enc->enc_pic.me.enc_disable_sub_mode = 0;
+      enc->enc_pic.me.enc_en_ime_overw_dis_subm = 0;
+      enc->enc_pic.me.enc_ime_overw_dis_subm_no = 0;
+      break;
+   }
 }
 
 static void get_pic_control_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
-- 
GitLab


From 7d557c48ca6c3c42309c281123ce501d9e318798 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 30 Dec 2024 12:21:55 +0100
Subject: [PATCH 09/32] radeonsi/vce: Support min/max QP and max frame size

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index e928778a47dd5..702c775479612 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -32,7 +32,9 @@ static void get_rate_control_param(struct rvce_encoder *enc, struct pipe_h264_en
    enc->enc_pic.rc.gop_size = pic->gop_size;
    enc->enc_pic.rc.frame_rate_num = pic->rate_ctrl[0].frame_rate_num;
    enc->enc_pic.rc.frame_rate_den = pic->rate_ctrl[0].frame_rate_den;
-   enc->enc_pic.rc.max_qp = 51;
+   enc->enc_pic.rc.min_qp = pic->rate_ctrl[0].min_qp;
+   enc->enc_pic.rc.max_qp = pic->rate_ctrl[0].max_qp ? pic->rate_ctrl[0].max_qp : 51;
+   enc->enc_pic.rc.max_au_size = pic->rate_ctrl[0].max_au_size;
    enc->enc_pic.rc.vbv_buffer_size = pic->rate_ctrl[0].vbv_buffer_size;
    enc->enc_pic.rc.vbv_buf_lv = pic->rate_ctrl[0].vbv_buf_lv;
    enc->enc_pic.rc.fill_data_enable = pic->rate_ctrl[0].fill_data_enable;
-- 
GitLab


From d4afedcb0e44404ccb2f7593436e6e04cefecf49 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 30 Dec 2024 19:31:33 +0100
Subject: [PATCH 10/32] radeonsi/vce: Support intra refresh

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 702c775479612..7f5248c92cb6d 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -260,6 +260,13 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
    enc->enc_pic.ec.enc_vbaq_mode =
       pic->rate_ctrl[0].rate_ctrl_method != PIPE_H2645_ENC_RATE_CONTROL_METHOD_DISABLE &&
       pic->quality_modes.vbaq_mode;
+   if (pic->intra_refresh.mode != PIPE_VIDEO_ENC_INTRA_REFRESH_NONE) {
+      enc->enc_pic.eo.enable_intra_refresh = 1;
+      enc->enc_pic.pc.enc_force_intra_refresh = 6;
+      enc->enc_pic.pc.enc_intra_refresh_num_mbs_per_slot = pic->intra_refresh.region_size;
+   } else {
+      enc->enc_pic.eo.enable_intra_refresh = 0;
+   }
 
    enc->enc_pic.eo.insert_headers = 0;
    enc->enc_pic.eo.insert_aud = 0;
-- 
GitLab


From 0c3f6f3945b809e462f7540ecfd4342e32d3aa2c Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Thu, 2 Jan 2025 09:38:42 +0100
Subject: [PATCH 11/32] radeonsi/vce: Support encode latency

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce.h    |  2 ++
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 14 ++++++++++++++
 2 files changed, 16 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index 4ad3904561fb5..4cded533ca350 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -319,6 +319,7 @@ struct rvce_h264_enc_pic {
    struct rvce_enc_operation eo;
    struct rvce_enc_create ec;
    struct rvce_config_ext ce;
+   uint32_t encode_latency;
 
    unsigned quant_i_frames;
    unsigned quant_p_frames;
@@ -360,6 +361,7 @@ struct rvce_encoder {
    void (*task_info)(struct rvce_encoder *enc, uint32_t op, uint32_t dep, uint32_t fb_idx,
                      uint32_t ring_idx);
    void (*si_get_pic_param)(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic);
+   void (*encode_latency)(struct rvce_encoder *enc);
 
    unsigned stream_handle;
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 7f5248c92cb6d..813371bf43708 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -591,6 +591,7 @@ static void config(struct rvce_encoder *enc)
    enc->rdo(enc);
    enc->vui(enc);
    enc->pic_control(enc);
+   enc->encode_latency(enc);
 }
 
 static void config_extension(struct rvce_encoder *enc)
@@ -736,6 +737,13 @@ static void task_info(struct rvce_encoder *enc, uint32_t op, uint32_t dep, uint3
    RVCE_END();
 }
 
+static void encode_latency(struct rvce_encoder *enc)
+{
+   RVCE_BEGIN(0x05000010); // encode latency
+   RVCE_CS(enc->enc_pic.encode_latency);
+   RVCE_END();
+}
+
 static void vui(struct rvce_encoder *enc)
 {
    int i;
@@ -792,6 +800,8 @@ static void vui(struct rvce_encoder *enc)
 
 void si_vce_52_init(struct rvce_encoder *enc)
 {
+   struct si_screen *sscreen = (struct si_screen *)enc->screen;
+
    enc->session = session;
    enc->task_info = task_info;
    enc->create = create;
@@ -806,4 +816,8 @@ void si_vce_52_init(struct rvce_encoder *enc)
    enc->encode = encode;
    enc->destroy = destroy;
    enc->si_get_pic_param = get_param;
+   enc->encode_latency = encode_latency;
+
+   enc->enc_pic.encode_latency =
+      sscreen->debug_flags & DBG(LOW_LATENCY_ENCODE) ? 1000 : 0;
 }
-- 
GitLab


From aa387c829b6ed6bd570fae9c158fbd4cb489aa6a Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 30 Dec 2024 17:39:45 +0100
Subject: [PATCH 12/32] radeonsi/vce: Support raw packed headers

Same logic as VCN, but this also needs PPS/SPS encoding.
---
 src/gallium/drivers/radeonsi/radeon_vce.c    | 118 +++++++-
 src/gallium/drivers/radeonsi/radeon_vce.h    |  62 +----
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 276 ++++++++++---------
 3 files changed, 268 insertions(+), 188 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.c b/src/gallium/drivers/radeonsi/radeon_vce.c
index 9415639277715..15a09276717c0 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce.c
@@ -187,6 +187,79 @@ static void rvce_begin_frame(struct pipe_video_codec *encoder, struct pipe_video
    }
 }
 
+static void *si_vce_encode_headers(struct rvce_encoder *enc)
+{
+   unsigned num_slices = 0, num_headers = 0;
+
+   util_dynarray_foreach(&enc->pic.raw_headers, struct pipe_enc_raw_header, header) {
+      if (header->is_slice)
+         num_slices++;
+      num_headers++;
+   }
+
+   if (!num_headers || !num_slices || num_headers == num_slices)
+      return NULL;
+
+   size_t segments_size =
+      sizeof(struct rvce_output_unit_segment) * (num_headers - num_slices + 1);
+   struct rvce_feedback_data *data =
+      CALLOC_VARIANT_LENGTH_STRUCT(rvce_feedback_data, segments_size);
+   if (!data)
+      return NULL;
+
+   uint8_t *ptr = enc->ws->buffer_map(enc->ws, enc->bs_handle, &enc->cs,
+                                      PIPE_MAP_WRITE | RADEON_MAP_TEMPORARY);
+   if (!ptr) {
+      RVID_ERR("Can't map bs buffer.\n");
+      FREE(data);
+      return NULL;
+   }
+
+   unsigned offset = 0;
+   struct rvce_output_unit_segment *slice_segment = NULL;
+
+   util_dynarray_foreach(&enc->pic.raw_headers, struct pipe_enc_raw_header, header) {
+      if (header->is_slice) {
+         if (slice_segment)
+            continue;
+         slice_segment = &data->segments[data->num_segments];
+         slice_segment->is_slice = true;
+      } else {
+         unsigned size;
+         /* Startcode may be 3 or 4 bytes. */
+         const uint8_t nal_byte = header->buffer[header->buffer[2] == 0x1 ? 3 : 4];
+
+         switch (header->type) {
+         case PIPE_H264_NAL_SPS:
+            size = si_vce_write_sps(enc, nal_byte, ptr + offset);
+            break;
+         case PIPE_H264_NAL_PPS:
+            size = si_vce_write_pps(enc, nal_byte, ptr + offset);
+            break;
+         default:
+            assert(header->buffer);
+            memcpy(ptr + offset, header->buffer, header->size);
+            size = header->size;
+            break;
+         }
+         data->segments[data->num_segments].size = size;
+         data->segments[data->num_segments].offset = offset;
+         offset += size;
+      }
+      data->num_segments++;
+   }
+
+   enc->bs_offset = align(offset, 16);
+   assert(enc->bs_offset < enc->bs_size);
+
+   assert(slice_segment);
+   slice_segment->offset = enc->bs_offset;
+
+   enc->ws->buffer_unmap(enc->ws, enc->bs_handle);
+
+   return data;
+}
+
 static void rvce_encode_bitstream(struct pipe_video_codec *encoder,
                                   struct pipe_video_buffer *source,
                                   struct pipe_resource *destination, void **fb)
@@ -194,12 +267,16 @@ static void rvce_encode_bitstream(struct pipe_video_codec *encoder,
    struct rvce_encoder *enc = (struct rvce_encoder *)encoder;
    enc->get_buffer(destination, &enc->bs_handle, NULL);
    enc->bs_size = destination->width0;
+   enc->bs_offset = 0;
 
    *fb = enc->fb = CALLOC_STRUCT(rvid_buffer);
    if (!si_vid_create_buffer(enc->screen, enc->fb, 512, PIPE_USAGE_STAGING)) {
       RVID_ERR("Can't create feedback buffer.\n");
       return;
    }
+
+   enc->fb->user_data = si_vce_encode_headers(enc);
+
    if (!radeon_emitted(&enc->cs, 0))
       enc->session(enc);
    enc->encode(enc);
@@ -222,18 +299,41 @@ static void rvce_get_feedback(struct pipe_video_codec *encoder, void *feedback,
    struct rvce_encoder *enc = (struct rvce_encoder *)encoder;
    struct rvid_buffer *fb = feedback;
 
-   if (size) {
-      uint32_t *ptr = enc->ws->buffer_map(enc->ws, fb->res->buf, &enc->cs,
-                                          PIPE_MAP_READ_WRITE | RADEON_MAP_TEMPORARY);
+   uint32_t *ptr = enc->ws->buffer_map(enc->ws, fb->res->buf, &enc->cs,
+                                       PIPE_MAP_READ_WRITE | RADEON_MAP_TEMPORARY);
 
-      if (ptr[1]) {
-         *size = ptr[4] - ptr[9];
-      } else {
-         *size = 0;
-      }
+   if (ptr[1]) {
+      *size = ptr[4] - ptr[9];
+   } else {
+      *size = 0;
+   }
 
-      enc->ws->buffer_unmap(enc->ws, fb->res->buf);
+   enc->ws->buffer_unmap(enc->ws, fb->res->buf);
+
+   metadata->present_metadata = PIPE_VIDEO_FEEDBACK_METADATA_TYPE_CODEC_UNIT_LOCATION;
+
+   if (fb->user_data) {
+      struct rvce_feedback_data *data = fb->user_data;
+      metadata->codec_unit_metadata_count = data->num_segments;
+      for (unsigned i = 0; i < data->num_segments; i++) {
+         metadata->codec_unit_metadata[i].offset = data->segments[i].offset;
+         if (data->segments[i].is_slice) {
+            metadata->codec_unit_metadata[i].size = *size;
+            metadata->codec_unit_metadata[i].flags = 0;
+         } else {
+            metadata->codec_unit_metadata[i].size = data->segments[i].size;
+            metadata->codec_unit_metadata[i].flags = PIPE_VIDEO_CODEC_UNIT_LOCATION_FLAG_SINGLE_NALU;
+         }
+      }
+      FREE(fb->user_data);
+      fb->user_data = NULL;
+   } else {
+      metadata->codec_unit_metadata_count = 1;
+      metadata->codec_unit_metadata[0].offset = 0;
+      metadata->codec_unit_metadata[0].size = *size;
+      metadata->codec_unit_metadata[0].flags = 0;
    }
+
    // dump_feedback(enc, fb);
    si_vid_destroy_buffer(fb);
    FREE(fb);
diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index 4cded533ca350..c001ca54d5ee5 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -157,50 +157,6 @@ struct rvce_rdo {
    uint32_t enc_chroma_coeff_cost;
 };
 
-struct rvce_vui {
-   uint32_t aspect_ratio_info_present_flag;
-   uint32_t aspect_ratio_idc;
-   uint32_t sar_width;
-   uint32_t sar_height;
-   uint32_t overscan_info_present_flag;
-   uint32_t overscan_Approp_flag;
-   uint32_t video_signal_type_present_flag;
-   uint32_t video_format;
-   uint32_t video_full_range_flag;
-   uint32_t color_description_present_flag;
-   uint32_t color_prim;
-   uint32_t transfer_char;
-   uint32_t matrix_coef;
-   uint32_t chroma_loc_info_present_flag;
-   uint32_t chroma_loc_top;
-   uint32_t chroma_loc_bottom;
-   uint32_t timing_info_present_flag;
-   uint32_t num_units_in_tick;
-   uint32_t time_scale;
-   uint32_t fixed_frame_rate_flag;
-   uint32_t nal_hrd_parameters_present_flag;
-   uint32_t cpb_cnt_minus1;
-   uint32_t bit_rate_scale;
-   uint32_t cpb_size_scale;
-   uint32_t bit_rate_value_minus;
-   uint32_t cpb_size_value_minus;
-   uint32_t cbr_flag;
-   uint32_t initial_cpb_removal_delay_length_minus1;
-   uint32_t cpb_removal_delay_length_minus1;
-   uint32_t dpb_output_delay_length_minus1;
-   uint32_t time_offset_length;
-   uint32_t low_delay_hrd_flag;
-   uint32_t pic_struct_present_flag;
-   uint32_t bitstream_restriction_present_flag;
-   uint32_t motion_vectors_over_pic_boundaries_flag;
-   uint32_t max_bytes_per_pic_denom;
-   uint32_t max_bits_per_mb_denom;
-   uint32_t log2_max_mv_length_hori;
-   uint32_t log2_max_mv_length_vert;
-   uint32_t num_reorder_frames;
-   uint32_t max_dec_frame_buffering;
-};
-
 struct rvce_enc_operation {
    uint32_t insert_headers;
    uint32_t picture_structure;
@@ -315,7 +271,6 @@ struct rvce_h264_enc_pic {
    struct rvce_task_info ti;
    struct rvce_feedback_buf_pkg fb;
    struct rvce_rdo rdo;
-   struct rvce_vui vui;
    struct rvce_enc_operation eo;
    struct rvce_enc_create ec;
    struct rvce_config_ext ce;
@@ -338,7 +293,6 @@ struct rvce_h264_enc_pic {
 
    bool not_referenced;
    bool is_idr;
-   bool enable_vui;
 };
 
 /* VCE encoder representation */
@@ -354,7 +308,6 @@ struct rvce_encoder {
    void (*pic_control)(struct rvce_encoder *enc);
    void (*motion_estimation)(struct rvce_encoder *enc);
    void (*rdo)(struct rvce_encoder *enc);
-   void (*vui)(struct rvce_encoder *enc);
    void (*config)(struct rvce_encoder *enc);
    void (*encode)(struct rvce_encoder *enc);
    void (*destroy)(struct rvce_encoder *enc);
@@ -377,6 +330,7 @@ struct rvce_encoder {
 
    struct pb_buffer_lean *bs_handle;
    unsigned bs_size;
+   unsigned bs_offset;
 
    unsigned dpb_slots;
 
@@ -392,6 +346,20 @@ struct rvce_encoder {
    bool dual_pipe;
 };
 
+struct rvce_output_unit_segment {
+   bool is_slice;
+   unsigned size;
+   unsigned offset;
+};
+
+struct rvce_feedback_data {
+   unsigned num_segments;
+   struct rvce_output_unit_segment segments[];
+};
+
+unsigned int si_vce_write_sps(struct rvce_encoder *enc, uint8_t nal_byte, uint8_t *out);
+unsigned int si_vce_write_pps(struct rvce_encoder *enc, uint8_t nal_byte, uint8_t *out);
+
 /* CPB handling functions */
 void si_vce_frame_offset(struct rvce_encoder *enc, unsigned slot, signed *luma_offset,
                          signed *chroma_offset);
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 813371bf43708..3056c5c6ba12d 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -9,6 +9,7 @@
 #include "pipe/p_video_codec.h"
 #include "radeon_vce.h"
 #include "radeon_video.h"
+#include "radeon_bitstream.h"
 #include "radeonsi/si_pipe.h"
 #include "util/u_memory.h"
 #include "util/u_video.h"
@@ -177,63 +178,6 @@ static void get_config_ext_param(struct rvce_encoder *enc)
    enc->enc_pic.ce.enc_enable_perf_logging = 0x00000003;
 }
 
-static void get_vui_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
-{
-   pipe_h264_enc_hrd_params *hrd_params = NULL;
-
-   if (pic->seq.vui_flags.nal_hrd_parameters_present_flag)
-      hrd_params = &pic->seq.nal_hrd_parameters;
-   else if (pic->seq.vui_flags.vcl_hrd_parameters_present_flag)
-      hrd_params = &pic->seq.vcl_hrd_parameters;
-
-   enc->enc_pic.enable_vui = pic->seq.vui_parameters_present_flag;
-   enc->enc_pic.vui.aspect_ratio_info_present_flag =
-      pic->seq.vui_flags.aspect_ratio_info_present_flag;
-   enc->enc_pic.vui.aspect_ratio_idc = pic->seq.aspect_ratio_idc;
-   enc->enc_pic.vui.sar_width = pic->seq.sar_width;
-   enc->enc_pic.vui.sar_height = pic->seq.sar_height;
-   enc->enc_pic.vui.overscan_info_present_flag = pic->seq.vui_flags.overscan_info_present_flag;
-   enc->enc_pic.vui.overscan_Approp_flag = pic->seq.vui_flags.overscan_appropriate_flag;
-   enc->enc_pic.vui.video_signal_type_present_flag =
-      pic->seq.vui_flags.video_signal_type_present_flag;
-   enc->enc_pic.vui.video_format = pic->seq.video_format;
-   enc->enc_pic.vui.video_full_range_flag = pic->seq.video_full_range_flag;
-   enc->enc_pic.vui.color_description_present_flag =
-      pic->seq.vui_flags.colour_description_present_flag;
-   enc->enc_pic.vui.color_prim = pic->seq.colour_primaries;
-   enc->enc_pic.vui.transfer_char = pic->seq.transfer_characteristics;
-   enc->enc_pic.vui.matrix_coef = pic->seq.matrix_coefficients;
-   enc->enc_pic.vui.chroma_loc_info_present_flag =
-      pic->seq.vui_flags.chroma_loc_info_present_flag;
-   enc->enc_pic.vui.chroma_loc_top = pic->seq.chroma_sample_loc_type_top_field;
-   enc->enc_pic.vui.chroma_loc_bottom = pic->seq.chroma_sample_loc_type_bottom_field;
-   enc->enc_pic.vui.timing_info_present_flag = pic->seq.vui_flags.timing_info_present_flag;
-   enc->enc_pic.vui.num_units_in_tick = pic->seq.num_units_in_tick;
-   enc->enc_pic.vui.time_scale = pic->seq.time_scale;
-   enc->enc_pic.vui.fixed_frame_rate_flag = pic->seq.vui_flags.fixed_frame_rate_flag;
-   enc->enc_pic.vui.low_delay_hrd_flag = pic->seq.vui_flags.low_delay_hrd_flag;
-   if (hrd_params) {
-      enc->enc_pic.vui.bit_rate_scale = hrd_params->bit_rate_scale;
-      enc->enc_pic.vui.cpb_size_scale = hrd_params->cpb_size_scale;
-      enc->enc_pic.vui.initial_cpb_removal_delay_length_minus1 =
-         hrd_params->initial_cpb_removal_delay_length_minus1;
-      enc->enc_pic.vui.cpb_removal_delay_length_minus1 = hrd_params->cpb_removal_delay_length_minus1;
-      enc->enc_pic.vui.dpb_output_delay_length_minus1 = hrd_params->dpb_output_delay_length_minus1;
-      enc->enc_pic.vui.time_offset_length = hrd_params->time_offset_length;
-      enc->enc_pic.vui.bit_rate_value_minus = hrd_params->bit_rate_value_minus1[0];
-      enc->enc_pic.vui.cpb_size_value_minus = hrd_params->bit_rate_value_minus1[0];
-      enc->enc_pic.vui.cbr_flag = hrd_params->cbr_flag[0];
-   }
-   enc->enc_pic.vui.bitstream_restriction_present_flag = pic->seq.vui_flags.bitstream_restriction_flag;
-   enc->enc_pic.vui.motion_vectors_over_pic_boundaries_flag = 0x00000001;
-   enc->enc_pic.vui.max_bytes_per_pic_denom = 0x00000002;
-   enc->enc_pic.vui.max_bits_per_mb_denom = 0x00000001;
-   enc->enc_pic.vui.log2_max_mv_length_hori = 0x00000010;
-   enc->enc_pic.vui.log2_max_mv_length_vert = 0x00000010;
-   enc->enc_pic.vui.num_reorder_frames = pic->seq.max_num_reorder_frames;
-   enc->enc_pic.vui.max_dec_frame_buffering = pic->seq.max_dec_frame_buffering;
-}
-
 static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic)
 {
    int i;
@@ -243,7 +187,6 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
    get_pic_control_param(enc, pic);
    get_task_info_param(enc);
    get_feedback_buffer_param(enc, NULL);
-   get_vui_param(enc, pic);
    get_config_ext_param(enc);
 
    enc->enc_pic.picture_type = pic->picture_type;
@@ -268,24 +211,6 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
       enc->enc_pic.eo.enable_intra_refresh = 0;
    }
 
-   enc->enc_pic.eo.insert_headers = 0;
-   enc->enc_pic.eo.insert_aud = 0;
-   util_dynarray_foreach(&pic->raw_headers, struct pipe_enc_raw_header, header) {
-      switch (header->type) {
-      case PIPE_H264_NAL_SPS:
-         enc->enc_pic.eo.insert_headers |= 0x01;
-         break;
-      case PIPE_H264_NAL_PPS:
-         enc->enc_pic.eo.insert_headers |= 0x10;
-         break;
-      case PIPE_H264_NAL_AUD:
-         enc->enc_pic.eo.insert_aud = 1;
-         break;
-      default:
-         break;
-      }
-   }
-
    enc->enc_pic.eo.num_ref_idx_active_override_flag = pic->slice.num_ref_idx_active_override_flag;
    enc->enc_pic.eo.num_ref_idx_l0_active_minus1 = pic->slice.num_ref_idx_l0_active_minus1;
    enc->enc_pic.eo.num_ref_idx_l1_active_minus1 = pic->slice.num_ref_idx_l1_active_minus1;
@@ -393,7 +318,7 @@ static void create(struct rvce_encoder *enc)
 static void encode(struct rvce_encoder *enc)
 {
    struct si_screen *sscreen = (struct si_screen *)enc->screen;
-   signed luma_offset, chroma_offset, bs_offset;
+   signed luma_offset, chroma_offset;
    unsigned bs_idx = enc->bs_idx++;
    int i;
 
@@ -403,10 +328,8 @@ static void encode(struct rvce_encoder *enc)
    RVCE_READWRITE(enc->cpb.res->buf, enc->cpb.res->domains, 0); // encodeContextAddressHi/Lo
    RVCE_END();
 
-   bs_offset = -(signed)(bs_idx * enc->bs_size);
-
    RVCE_BEGIN(0x05000004);                                   // video bitstream buffer
-   RVCE_WRITE(enc->bs_handle, RADEON_DOMAIN_GTT, bs_offset); // videoBitstreamRingAddressHi/Lo
+   RVCE_WRITE(enc->bs_handle, RADEON_DOMAIN_GTT, enc->bs_offset); // videoBitstreamRingAddressHi/Lo
    RVCE_CS(enc->bs_size);                                    // videoBitstreamRingSize
    RVCE_END();
 
@@ -425,7 +348,7 @@ static void encode(struct rvce_encoder *enc)
    RVCE_BEGIN(0x03000001);                       // encode
    RVCE_CS(enc->enc_pic.eo.insert_headers);
    RVCE_CS(enc->enc_pic.eo.picture_structure);
-   RVCE_CS(enc->bs_size); // allowedMaxBitstreamSize
+   RVCE_CS(enc->bs_size - enc->bs_offset); // allowedMaxBitstreamSize
    RVCE_CS(enc->enc_pic.eo.force_refresh_map);
    RVCE_CS(enc->enc_pic.eo.insert_aud);
    RVCE_CS(enc->enc_pic.eo.end_of_sequence);
@@ -589,7 +512,6 @@ static void config(struct rvce_encoder *enc)
    enc->config_extension(enc);
    enc->motion_estimation(enc);
    enc->rdo(enc);
-   enc->vui(enc);
    enc->pic_control(enc);
    enc->encode_latency(enc);
 }
@@ -744,58 +666,149 @@ static void encode_latency(struct rvce_encoder *enc)
    RVCE_END();
 }
 
-static void vui(struct rvce_encoder *enc)
+unsigned int si_vce_write_sps(struct rvce_encoder *enc, uint8_t nal_byte, uint8_t *out)
 {
-   int i;
+   struct pipe_h264_enc_seq_param *sps = &enc->pic.seq;
+   struct radeon_bitstream bs;
+
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, nal_byte, 8);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_fixed_bits(&bs, sps->profile_idc, 8);
+   radeon_bs_code_fixed_bits(&bs, sps->enc_constraint_set_flags, 6);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* reserved_zero_2bits */
+   radeon_bs_code_fixed_bits(&bs, sps->level_idc, 8);
+   radeon_bs_code_ue(&bs, 0x0); /* seq_parameter_set_id */
+
+   if (sps->profile_idc == 100 || sps->profile_idc == 110 ||
+       sps->profile_idc == 122 || sps->profile_idc == 244 ||
+       sps->profile_idc == 44  || sps->profile_idc == 83 ||
+       sps->profile_idc == 86  || sps->profile_idc == 118 ||
+       sps->profile_idc == 128 || sps->profile_idc == 138) {
+      radeon_bs_code_ue(&bs, 0x1); /* chroma_format_idc */
+      radeon_bs_code_ue(&bs, 0x0); /* bit_depth_luma_minus8 */
+      radeon_bs_code_ue(&bs, 0x0); /* bit_depth_chroma_minus8 */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* qpprime_y_zero_transform_bypass_flag + seq_scaling_matrix_present_flag */
+   }
 
-   if (!enc->enc_pic.enable_vui)
-      return;
-
-   RVCE_BEGIN(0x04000009); // vui
-   RVCE_CS(enc->enc_pic.vui.aspect_ratio_info_present_flag);
-   RVCE_CS(enc->enc_pic.vui.aspect_ratio_idc);
-   RVCE_CS(enc->enc_pic.vui.sar_width);
-   RVCE_CS(enc->enc_pic.vui.sar_height);
-   RVCE_CS(enc->enc_pic.vui.overscan_info_present_flag);
-   RVCE_CS(enc->enc_pic.vui.overscan_Approp_flag);
-   RVCE_CS(enc->enc_pic.vui.video_signal_type_present_flag);
-   RVCE_CS(enc->enc_pic.vui.video_format);
-   RVCE_CS(enc->enc_pic.vui.video_full_range_flag);
-   RVCE_CS(enc->enc_pic.vui.color_description_present_flag);
-   RVCE_CS(enc->enc_pic.vui.color_prim);
-   RVCE_CS(enc->enc_pic.vui.transfer_char);
-   RVCE_CS(enc->enc_pic.vui.matrix_coef);
-   RVCE_CS(enc->enc_pic.vui.chroma_loc_info_present_flag);
-   RVCE_CS(enc->enc_pic.vui.chroma_loc_top);
-   RVCE_CS(enc->enc_pic.vui.chroma_loc_bottom);
-   RVCE_CS(enc->enc_pic.vui.timing_info_present_flag);
-   RVCE_CS(enc->enc_pic.vui.num_units_in_tick);
-   RVCE_CS(enc->enc_pic.vui.time_scale);
-   RVCE_CS(enc->enc_pic.vui.fixed_frame_rate_flag);
-   RVCE_CS(enc->enc_pic.vui.nal_hrd_parameters_present_flag);
-   RVCE_CS(enc->enc_pic.vui.cpb_cnt_minus1);
-   RVCE_CS(enc->enc_pic.vui.bit_rate_scale);
-   RVCE_CS(enc->enc_pic.vui.cpb_size_scale);
-   for (i = 0; i < 32; i++) {
-      RVCE_CS(enc->enc_pic.vui.bit_rate_value_minus);
-      RVCE_CS(enc->enc_pic.vui.cpb_size_value_minus);
-      RVCE_CS(enc->enc_pic.vui.cbr_flag);
+   radeon_bs_code_ue(&bs, 3); /* log2_max_frame_num_minus4 */
+   radeon_bs_code_ue(&bs, sps->pic_order_cnt_type);
+
+   if (sps->pic_order_cnt_type == 0)
+      radeon_bs_code_ue(&bs, sps->log2_max_pic_order_cnt_lsb_minus4);
+
+   radeon_bs_code_ue(&bs, sps->max_num_ref_frames);
+   radeon_bs_code_fixed_bits(&bs, sps->gaps_in_frame_num_value_allowed_flag, 1);
+   radeon_bs_code_ue(&bs, align(enc->base.width, 16) - 1);
+   radeon_bs_code_ue(&bs, align(enc->base.height, 16) - 1);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* frame_mbs_only_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* direct_8x8_inference_flag */
+
+   radeon_bs_code_fixed_bits(&bs, sps->enc_frame_cropping_flag, 1);
+   if (sps->enc_frame_cropping_flag) {
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_left_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_right_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_top_offset);
+      radeon_bs_code_ue(&bs, sps->enc_frame_crop_bottom_offset);
    }
-   RVCE_CS(enc->enc_pic.vui.initial_cpb_removal_delay_length_minus1);
-   RVCE_CS(enc->enc_pic.vui.cpb_removal_delay_length_minus1);
-   RVCE_CS(enc->enc_pic.vui.dpb_output_delay_length_minus1);
-   RVCE_CS(enc->enc_pic.vui.time_offset_length);
-   RVCE_CS(enc->enc_pic.vui.low_delay_hrd_flag);
-   RVCE_CS(enc->enc_pic.vui.pic_struct_present_flag);
-   RVCE_CS(enc->enc_pic.vui.bitstream_restriction_present_flag);
-   RVCE_CS(enc->enc_pic.vui.motion_vectors_over_pic_boundaries_flag);
-   RVCE_CS(enc->enc_pic.vui.max_bytes_per_pic_denom);
-   RVCE_CS(enc->enc_pic.vui.max_bits_per_mb_denom);
-   RVCE_CS(enc->enc_pic.vui.log2_max_mv_length_hori);
-   RVCE_CS(enc->enc_pic.vui.log2_max_mv_length_vert);
-   RVCE_CS(enc->enc_pic.vui.num_reorder_frames);
-   RVCE_CS(enc->enc_pic.vui.max_dec_frame_buffering);
-   RVCE_END();
+
+   radeon_bs_code_fixed_bits(&bs, sps->vui_parameters_present_flag, 1);
+   if (sps->vui_parameters_present_flag) {
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.aspect_ratio_info_present_flag), 1);
+      if (sps->vui_flags.aspect_ratio_info_present_flag) {
+         radeon_bs_code_fixed_bits(&bs, (sps->aspect_ratio_idc), 8);
+         if (sps->aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_width), 16);
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_height), 16);
+         }
+      }
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_info_present_flag, 1);
+      if (sps->vui_flags.overscan_info_present_flag)
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_appropriate_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.video_signal_type_present_flag, 1);
+      if (sps->vui_flags.video_signal_type_present_flag) {
+         radeon_bs_code_fixed_bits(&bs, sps->video_format, 3);
+         radeon_bs_code_fixed_bits(&bs, sps->video_full_range_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.colour_description_present_flag, 1);
+         if (sps->vui_flags.colour_description_present_flag) {
+            radeon_bs_code_fixed_bits(&bs, sps->colour_primaries, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->transfer_characteristics, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->matrix_coefficients, 8);
+         }
+      }
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.chroma_loc_info_present_flag, 1);
+      if (sps->vui_flags.chroma_loc_info_present_flag) {
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_top_field);
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_bottom_field);
+      }
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.timing_info_present_flag), 1);
+      if (sps->vui_flags.timing_info_present_flag) {
+         radeon_bs_code_fixed_bits(&bs, (sps->num_units_in_tick), 32);
+         radeon_bs_code_fixed_bits(&bs, (sps->time_scale), 32);
+         radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.fixed_frame_rate_flag), 1);
+      }
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.nal_hrd_parameters_present_flag, 1);
+      if (sps->vui_flags.nal_hrd_parameters_present_flag)
+         radeon_bs_h264_hrd_parameters(&bs, &sps->nal_hrd_parameters);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.vcl_hrd_parameters_present_flag, 1);
+      if (sps->vui_flags.vcl_hrd_parameters_present_flag)
+         radeon_bs_h264_hrd_parameters(&bs, &sps->vcl_hrd_parameters);
+      if (sps->vui_flags.nal_hrd_parameters_present_flag || sps->vui_flags.vcl_hrd_parameters_present_flag)
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.low_delay_hrd_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.pic_struct_present_flag, 1);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.bitstream_restriction_flag, 1);
+      if (sps->vui_flags.bitstream_restriction_flag) {
+         radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* motion_vectors_over_pic_boundaries_flag */
+         radeon_bs_code_ue(&bs, 0x2); /* max_bytes_per_pic_denom */
+         radeon_bs_code_ue(&bs, 0x1); /* max_bits_per_mb_denom */
+         radeon_bs_code_ue(&bs, 0x10); /* log2_max_mv_length_horizontal */
+         radeon_bs_code_ue(&bs, 0x10); /* log2_max_mv_length_vertical */
+         radeon_bs_code_ue(&bs, sps->max_num_reorder_frames);
+         radeon_bs_code_ue(&bs, sps->max_dec_frame_buffering);
+      }
+   }
+
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
+
+   return bs.bits_output / 8;
+}
+
+unsigned int si_vce_write_pps(struct rvce_encoder *enc, uint8_t nal_byte, uint8_t *out)
+{
+   struct radeon_bitstream bs;
+
+   radeon_bs_reset(&bs, out, NULL);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, nal_byte, 8);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_ue(&bs, 0x0); /* pic_parameter_set_id */
+   radeon_bs_code_ue(&bs, 0x0); /* seq_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.pc.enc_cabac_enable, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* bottom_field_pic_order_in_frame_present_flag */
+   radeon_bs_code_ue(&bs, 0x0); /* num_slice_groups_minus_1 */
+   radeon_bs_code_ue(&bs, enc->enc_pic.pc.enc_num_default_active_ref_l0 - 1);
+   radeon_bs_code_ue(&bs, enc->enc_pic.pc.enc_num_default_active_ref_l1 - 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* weighted_pred_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* weighted_bipred_idc */
+   radeon_bs_code_se(&bs, 0x0); /* pic_init_qp_minus26 */
+   radeon_bs_code_se(&bs, 0x0); /* pic_init_qs_minus26 */
+   radeon_bs_code_se(&bs, 0x0); /* chroma_qp_index_offset */
+   bool deblocking_filter_present_flag =
+      enc->enc_pic.pc.enc_loop_filter_disable ||
+      enc->enc_pic.pc.enc_lf_beta_offset ||
+      enc->enc_pic.pc.enc_lf_alpha_c0_offset;
+   radeon_bs_code_fixed_bits(&bs, deblocking_filter_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.pc.enc_use_constrained_intra_pred, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* redundant_pic_cnt_present_flag */
+
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
+
+   return bs.bits_output / 8;
 }
 
 void si_vce_52_init(struct rvce_encoder *enc)
@@ -811,7 +824,6 @@ void si_vce_52_init(struct rvce_encoder *enc)
    enc->pic_control = pic_control;
    enc->motion_estimation = motion_estimation;
    enc->rdo = rdo;
-   enc->vui = vui;
    enc->config = config;
    enc->encode = encode;
    enc->destroy = destroy;
-- 
GitLab


From 2b85257ef4696dcef882079ca7dbee0bd635a169 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Thu, 2 Jan 2025 09:30:19 +0100
Subject: [PATCH 13/32] radeonsi/vce: Set input pic swizzle mode on GFX9

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce.h    | 11 +++++++++--
 src/gallium/drivers/radeonsi/radeon_vce_52.c |  6 ++----
 2 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index c001ca54d5ee5..6f13c25f54da7 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -173,8 +173,15 @@ struct rvce_enc_operation {
    uint32_t enc_input_pic_luma_pitch;
    uint32_t enc_input_pic_chroma_pitch;
    ;
-   uint32_t enc_input_pic_addr_array;
-   uint32_t enc_input_pic_addr_array_disable2pipe_disablemboffload;
+   union {
+      struct {
+         uint8_t enc_input_pic_addr_mode;
+         uint8_t enc_input_pic_swizzle_mode;
+         uint8_t enc_disable_two_pipe_mode;
+         uint8_t enc_disable_mb_offloading;
+      };
+      uint32_t enc_input_pic_addr_array_disable2pipe_disablemboffload;
+   };
    uint32_t enc_input_pic_tile_config;
    uint32_t enc_pic_type;
    uint32_t enc_idr_flag;
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index 3056c5c6ba12d..e698bf6aec78c 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -370,12 +370,10 @@ static void encode(struct rvce_encoder *enc)
       RVCE_CS(align(enc->luma->u.gfx9.surf_height, 16));          // encInputFrameYPitch
       RVCE_CS(enc->luma->u.gfx9.surf_pitch * enc->luma->bpe);     // encInputPicLumaPitch
       RVCE_CS(enc->chroma->u.gfx9.surf_pitch * enc->chroma->bpe); // encInputPicChromaPitch
+      enc->enc_pic.eo.enc_input_pic_swizzle_mode = enc->luma->u.gfx9.swizzle_mode;
    }
 
-   if (enc->dual_pipe)
-      enc->enc_pic.eo.enc_input_pic_addr_array_disable2pipe_disablemboffload = 0x00000000;
-   else
-      enc->enc_pic.eo.enc_input_pic_addr_array_disable2pipe_disablemboffload = 0x00010000;
+   enc->enc_pic.eo.enc_disable_two_pipe_mode = !enc->dual_pipe;
    RVCE_CS(enc->enc_pic.eo.enc_input_pic_addr_array_disable2pipe_disablemboffload);
    RVCE_CS(enc->enc_pic.eo.enc_input_pic_tile_config);
    RVCE_CS(enc->enc_pic.picture_type);                                    // encPicType
-- 
GitLab


From 57f06960bdc877420c9b165e3e651b2af245f3d4 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Sat, 28 Dec 2024 18:08:11 +0100
Subject: [PATCH 14/32] radeonsi/vce: Cleanup

Reviewed-by: David (Ming Qiang) Wu <David.Wu3@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vce.c    |  2 --
 src/gallium/drivers/radeonsi/radeon_vce.h    |  8 +------
 src/gallium/drivers/radeonsi/radeon_vce_52.c | 25 ++++++--------------
 3 files changed, 8 insertions(+), 27 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vce.c b/src/gallium/drivers/radeonsi/radeon_vce.c
index 15a09276717c0..787ae32a24b6f 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce.c
@@ -28,8 +28,6 @@
 static void flush(struct rvce_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
 {
    enc->ws->cs_flush(&enc->cs, flags, fence);
-   enc->task_info_idx = 0;
-   enc->bs_idx = 0;
 }
 
 #if 0
diff --git a/src/gallium/drivers/radeonsi/radeon_vce.h b/src/gallium/drivers/radeonsi/radeon_vce.h
index 6f13c25f54da7..e122239c3d588 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce.h
+++ b/src/gallium/drivers/radeonsi/radeon_vce.h
@@ -293,8 +293,6 @@ struct rvce_h264_enc_pic {
    unsigned p_remain;
    unsigned i_remain;
    unsigned idr_pic_id;
-   unsigned gop_cnt;
-   unsigned gop_size;
    unsigned pic_order_cnt;
    unsigned addrmode_arraymode_disrdo_distwoinstants;
 
@@ -318,8 +316,7 @@ struct rvce_encoder {
    void (*config)(struct rvce_encoder *enc);
    void (*encode)(struct rvce_encoder *enc);
    void (*destroy)(struct rvce_encoder *enc);
-   void (*task_info)(struct rvce_encoder *enc, uint32_t op, uint32_t dep, uint32_t fb_idx,
-                     uint32_t ring_idx);
+   void (*task_info)(struct rvce_encoder *enc, uint32_t op, uint32_t fb_idx);
    void (*si_get_pic_param)(struct rvce_encoder *enc, struct pipe_h264_enc_picture_desc *pic);
    void (*encode_latency)(struct rvce_encoder *enc);
 
@@ -346,9 +343,6 @@ struct rvce_encoder {
    struct pipe_h264_enc_picture_desc pic;
    struct rvce_h264_enc_pic enc_pic;
 
-   unsigned task_info_idx;
-   unsigned bs_idx;
-
    bool use_vm;
    bool dual_pipe;
 };
diff --git a/src/gallium/drivers/radeonsi/radeon_vce_52.c b/src/gallium/drivers/radeonsi/radeon_vce_52.c
index e698bf6aec78c..2ebc92f840a86 100644
--- a/src/gallium/drivers/radeonsi/radeon_vce_52.c
+++ b/src/gallium/drivers/radeonsi/radeon_vce_52.c
@@ -194,7 +194,6 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
    enc->enc_pic.frame_num_cnt = pic->frame_num_cnt - 1;
    enc->enc_pic.p_remain = pic->p_remain;
    enc->enc_pic.i_remain = pic->i_remain;
-   enc->enc_pic.gop_cnt = pic->gop_cnt;
    enc->enc_pic.pic_order_cnt = pic->pic_order_cnt;
    enc->enc_pic.not_referenced = pic->not_referenced;
    enc->enc_pic.addrmode_arraymode_disrdo_distwoinstants = 0x01000201;
@@ -286,7 +285,7 @@ static void get_param(struct rvce_encoder *enc, struct pipe_h264_enc_picture_des
 static void create(struct rvce_encoder *enc)
 {
    struct si_screen *sscreen = (struct si_screen *)enc->screen;
-   enc->task_info(enc, 0x00000000, 0, 0, 0);
+   enc->task_info(enc, 0x00000000, 0);
 
    RVCE_BEGIN(0x01000001); // create cmd
    RVCE_CS(enc->enc_pic.ec.enc_use_circular_buffer);
@@ -319,10 +318,9 @@ static void encode(struct rvce_encoder *enc)
 {
    struct si_screen *sscreen = (struct si_screen *)enc->screen;
    signed luma_offset, chroma_offset;
-   unsigned bs_idx = enc->bs_idx++;
    int i;
 
-   enc->task_info(enc, 0x00000003, 0, 0, bs_idx);
+   enc->task_info(enc, 0x00000003, 0);
 
    RVCE_BEGIN(0x05000001);                                      // context buffer
    RVCE_READWRITE(enc->cpb.res->buf, enc->cpb.res->domains, 0); // encodeContextAddressHi/Lo
@@ -505,7 +503,7 @@ static void rate_control(struct rvce_encoder *enc)
 
 static void config(struct rvce_encoder *enc)
 {
-   enc->task_info(enc, 0x00000002, 0, 0xffffffff, 0);
+   enc->task_info(enc, 0x00000002, 0xffffffff);
    enc->rate_control(enc);
    enc->config_extension(enc);
    enc->motion_estimation(enc);
@@ -531,7 +529,7 @@ static void feedback(struct rvce_encoder *enc)
 
 static void destroy(struct rvce_encoder *enc)
 {
-   enc->task_info(enc, 0x00000001, 0, 0, 0);
+   enc->task_info(enc, 0x00000001, 0);
 
    feedback(enc);
 
@@ -632,22 +630,13 @@ static void session(struct rvce_encoder *enc)
    RVCE_END();
 }
 
-static void task_info(struct rvce_encoder *enc, uint32_t op, uint32_t dep, uint32_t fb_idx,
-                      uint32_t ring_idx)
+static void task_info(struct rvce_encoder *enc, uint32_t op, uint32_t fb_idx)
 {
    RVCE_BEGIN(0x00000002); // task info
-   if (op == 0x3) {
-      if (enc->task_info_idx) {
-         uint32_t offs = enc->cs.current.cdw - enc->task_info_idx + 3;
-         // Update offsetOfNextTaskInfo
-         enc->cs.current.buf[enc->task_info_idx] = offs;
-      }
-      enc->task_info_idx = enc->cs.current.cdw;
-   }
    enc->enc_pic.ti.task_operation = op;
-   enc->enc_pic.ti.reference_picture_dependency = dep;
+   enc->enc_pic.ti.reference_picture_dependency = 0;
    enc->enc_pic.ti.feedback_index = fb_idx;
-   enc->enc_pic.ti.video_bitstream_ring_index = ring_idx;
+   enc->enc_pic.ti.video_bitstream_ring_index = 0;
    RVCE_CS(enc->enc_pic.ti.offset_of_next_task_info);
    RVCE_CS(enc->enc_pic.ti.task_operation);
    RVCE_CS(enc->enc_pic.ti.reference_picture_dependency);
-- 
GitLab


From df6ec60539da4f6959e5ff1f7292e097f04a7199 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 08:42:15 +0100
Subject: [PATCH 15/32] radeonsi/uvd: Stop clearing decode internal buffers

FW will clear them if needed.
---
 src/gallium/drivers/radeonsi/radeon_uvd.c | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd.c b/src/gallium/drivers/radeonsi/radeon_uvd.c
index abf6c411df260..8bfa86ce2d182 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd.c
@@ -1148,7 +1148,6 @@ static int ruvd_end_frame(struct pipe_video_codec *decoder, struct pipe_video_bu
          if (!si_vid_create_buffer(dec->screen, &dec->ctx, ctx_size, PIPE_USAGE_DEFAULT)) {
             RVID_ERR("Can't allocated context buffer.\n");
          }
-         si_vid_clear_buffer(decoder->context, &dec->ctx);
       }
 
       if (dec->ctx.res)
@@ -1301,9 +1300,6 @@ struct pipe_video_codec *si_common_uvd_create_decoder(struct pipe_context *conte
          RVID_ERR("Can't allocated bitstream buffers.\n");
          goto error;
       }
-
-      si_vid_clear_buffer(context, &dec->msg_fb_it_buffers[i]);
-      si_vid_clear_buffer(context, &dec->bs_buffers[i]);
    }
 
    dpb_size = calc_dpb_size(dec);
@@ -1312,7 +1308,6 @@ struct pipe_video_codec *si_common_uvd_create_decoder(struct pipe_context *conte
          RVID_ERR("Can't allocated dpb.\n");
          goto error;
       }
-      si_vid_clear_buffer(context, &dec->dpb);
    }
 
    if (dec->stream_type == RUVD_CODEC_H264_PERF && sctx->family >= CHIP_POLARIS10) {
@@ -1321,7 +1316,6 @@ struct pipe_video_codec *si_common_uvd_create_decoder(struct pipe_context *conte
          RVID_ERR("Can't allocated context buffer.\n");
          goto error;
       }
-      si_vid_clear_buffer(context, &dec->ctx);
    }
 
    if (sctx->family >= CHIP_POLARIS10) {
@@ -1330,7 +1324,6 @@ struct pipe_video_codec *si_common_uvd_create_decoder(struct pipe_context *conte
          RVID_ERR("Can't allocated session ctx.\n");
          goto error;
       }
-      si_vid_clear_buffer(context, &dec->sessionctx);
    }
 
    if (sctx->family >= CHIP_VEGA10) {
-- 
GitLab


From 8c4655d59446315c18eaef2cdd9ad590e8cffbbd Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 08:48:30 +0100
Subject: [PATCH 16/32] radeonsi/uvd: Optimize bitstream buffer resizing

Only resize the buffer once and avoid copy if the buffer is empty.
---
 src/gallium/drivers/radeonsi/radeon_uvd.c | 40 ++++++++++++++---------
 1 file changed, 25 insertions(+), 15 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd.c b/src/gallium/drivers/radeonsi/radeon_uvd.c
index 8bfa86ce2d182..e7932cd29169b 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd.c
@@ -1046,29 +1046,39 @@ static void ruvd_decode_bitstream(struct pipe_video_codec *decoder,
    if (!dec->bs_ptr)
       return;
 
-   for (i = 0; i < num_buffers; ++i) {
-      struct rvid_buffer *buf = &dec->bs_buffers[dec->cur_buffer];
-      unsigned new_size = dec->bs_size + sizes[i];
+   unsigned long total_bs_size = dec->bs_size;
+   for (i = 0; i < num_buffers; ++i)
+      total_bs_size += sizes[i];
+
+   struct rvid_buffer *buf = &dec->bs_buffers[dec->cur_buffer];
 
-      if (new_size > buf->res->buf->size) {
-         dec->ws->buffer_unmap(dec->ws, buf->res->buf);
-         dec->bs_ptr = NULL;
+   if (total_bs_size > buf->res->buf->size) {
+      dec->ws->buffer_unmap(dec->ws, buf->res->buf);
+      dec->bs_ptr = NULL;
 
-         new_size = align(new_size, 128);
+      total_bs_size = align(total_bs_size, 128);
 
-         if (!si_vid_resize_buffer(dec->base.context, &dec->cs, buf, new_size, NULL)) {
-            RVID_ERR("Can't resize bitstream buffer!");
+      if (!dec->bs_size) {
+         struct rvid_buffer old_buf = *buf;
+         if (!si_vid_create_buffer(dec->screen, buf, total_bs_size, buf->usage)) {
+            RVID_ERR("Can't create bitstream buffer!");
             return;
          }
+         si_vid_destroy_buffer(&old_buf);
+      } else if (!si_vid_resize_buffer(dec->base.context, &dec->cs, buf, total_bs_size, NULL)) {
+         RVID_ERR("Can't resize bitstream buffer!");
+         return;
+      }
 
-         dec->bs_ptr = dec->ws->buffer_map(dec->ws, buf->res->buf, &dec->cs,
-                                           PIPE_MAP_WRITE | RADEON_MAP_TEMPORARY);
-         if (!dec->bs_ptr)
-            return;
+      dec->bs_ptr = dec->ws->buffer_map(dec->ws, buf->res->buf, &dec->cs,
+                                        PIPE_MAP_WRITE | RADEON_MAP_TEMPORARY);
+      if (!dec->bs_ptr)
+         return;
 
-         dec->bs_ptr += dec->bs_size;
-      }
+      dec->bs_ptr += dec->bs_size;
+   }
 
+   for (i = 0; i < num_buffers; ++i) {
       memcpy(dec->bs_ptr, buffers[i], sizes[i]);
       dec->bs_size += sizes[i];
       dec->bs_ptr += sizes[i];
-- 
GitLab


From e028d11c2196dcdfa41b0b383b942e31b64f9226 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Wed, 1 Jan 2025 15:22:55 +0100
Subject: [PATCH 17/32] radeonsi/uvd: Set decode target swizzle mode on GFX9

---
 src/amd/common/ac_uvd_dec.h               | 2 +-
 src/gallium/drivers/radeonsi/radeon_uvd.c | 4 +---
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/amd/common/ac_uvd_dec.h b/src/amd/common/ac_uvd_dec.h
index 826d1d1bc3a1d..94cf8a9a0cc38 100644
--- a/src/amd/common/ac_uvd_dec.h
+++ b/src/amd/common/ac_uvd_dec.h
@@ -383,7 +383,7 @@ struct ruvd_msg {
          uint32_t dt_uv_surf_tile_config;
          // re-use dt_wa_chroma_top_offset as dt_ext_info for UV pitch in stoney
          uint32_t dt_wa_chroma_top_offset;
-         uint32_t dt_wa_chroma_bottom_offset;
+         uint32_t dt_wa_chroma_bottom_offset; /* gfx9: used as dt_swizzle_mode */
 
          uint32_t reserved[16];
 
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd.c b/src/gallium/drivers/radeonsi/radeon_uvd.c
index e7932cd29169b..3764e9c492f1b 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd.c
@@ -1493,9 +1493,7 @@ void si_uvd_set_dt_surfaces(struct ruvd_msg *msg, struct radeon_surf *luma,
       break;
    case RUVD_SURFACE_TYPE_GFX9:
       msg->body.decode.dt_pitch = luma->u.gfx9.surf_pitch * luma->blk_w;
-      /* SWIZZLE LINEAR MODE */
-      msg->body.decode.dt_tiling_mode = RUVD_TILE_LINEAR;
-      msg->body.decode.dt_array_mode = RUVD_ARRAY_MODE_LINEAR;
+      msg->body.decode.dt_wa_chroma_bottom_offset = luma->u.gfx9.swizzle_mode;
       msg->body.decode.dt_luma_top_offset = texture_offset(luma, 0, type);
       msg->body.decode.dt_chroma_top_offset = texture_offset(chroma, 0, type);
       if (msg->body.decode.dt_field_mode) {
-- 
GitLab


From e95039dfb268d201c3a8b14b2475b56178899af2 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 30 Dec 2024 10:16:14 +0100
Subject: [PATCH 18/32] radeonsi/uvd_enc: Rework DPB allocation

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c | 115 ++++++------------
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h |   4 +-
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     |  26 ++--
 3 files changed, 52 insertions(+), 93 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index e04f852ae2899..26c0a0a18d639 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -17,20 +17,6 @@
 
 #include <stdio.h>
 
-#define UVD_HEVC_LEVEL_1   30
-#define UVD_HEVC_LEVEL_2   60
-#define UVD_HEVC_LEVEL_2_1 63
-#define UVD_HEVC_LEVEL_3   90
-#define UVD_HEVC_LEVEL_3_1 93
-#define UVD_HEVC_LEVEL_4   120
-#define UVD_HEVC_LEVEL_4_1 123
-#define UVD_HEVC_LEVEL_5   150
-#define UVD_HEVC_LEVEL_5_1 153
-#define UVD_HEVC_LEVEL_5_2 156
-#define UVD_HEVC_LEVEL_6   180
-#define UVD_HEVC_LEVEL_6_1 183
-#define UVD_HEVC_LEVEL_6_2 186
-
 static void radeon_uvd_enc_get_vui_param(struct radeon_uvd_encoder *enc,
                                          struct pipe_h265_enc_picture_desc *pic)
 {
@@ -130,53 +116,33 @@ static void radeon_uvd_enc_cs_flush(void *ctx, unsigned flags, struct pipe_fence
    // just ignored
 }
 
-static unsigned get_cpb_num(struct radeon_uvd_encoder *enc, unsigned level_idc)
+static uint32_t setup_dpb(struct radeon_uvd_encoder *enc, uint32_t num_reconstructed_pictures)
 {
-   unsigned w = align(enc->base.width, 16) / 16;
-   unsigned h = align(enc->base.height, 16) / 16;
-   unsigned dpb;
-
-   switch (level_idc) {
-   case UVD_HEVC_LEVEL_1:
-      dpb = 36864;
-      break;
-
-   case UVD_HEVC_LEVEL_2:
-      dpb = 122880;
-      break;
-
-   case UVD_HEVC_LEVEL_2_1:
-      dpb = 245760;
-      break;
-
-   case UVD_HEVC_LEVEL_3:
-      dpb = 552960;
-      break;
-
-   case UVD_HEVC_LEVEL_3_1:
-      dpb = 983040;
-      break;
-
-   case UVD_HEVC_LEVEL_4:
-   case UVD_HEVC_LEVEL_4_1:
-      dpb = 2228224;
-      break;
-
-   case UVD_HEVC_LEVEL_5:
-   case UVD_HEVC_LEVEL_5_1:
-   case UVD_HEVC_LEVEL_5_2:
-      dpb = 8912896;
-      break;
-
-   case UVD_HEVC_LEVEL_6:
-   case UVD_HEVC_LEVEL_6_1:
-   case UVD_HEVC_LEVEL_6_2:
-   default:
-      dpb = 35651584;
-      break;
+   uint32_t i;
+   uint32_t alignment = 256;
+   uint32_t aligned_width = align(enc->base.width, 64);
+   uint32_t aligned_height = align(enc->base.height, 16);
+   uint32_t pitch = align(aligned_width, alignment);
+   uint32_t luma_size = align(pitch * MAX2(256, aligned_height), alignment);
+   uint32_t chroma_size = align(luma_size / 2, alignment);
+   uint32_t offset = 0;
+
+   assert(num_reconstructed_pictures <= RENC_UVD_MAX_NUM_RECONSTRUCTED_PICTURES);
+
+   enc->enc_pic.ctx_buf.rec_luma_pitch = pitch;
+   enc->enc_pic.ctx_buf.rec_chroma_pitch = pitch;
+   enc->enc_pic.ctx_buf.num_reconstructed_pictures = num_reconstructed_pictures;
+
+   for (i = 0; i < num_reconstructed_pictures; i++) {
+      enc->enc_pic.ctx_buf.reconstructed_pictures[i].luma_offset = offset;
+      offset += luma_size;
+      enc->enc_pic.ctx_buf.reconstructed_pictures[i].chroma_offset = offset;
+      offset += chroma_size;
    }
 
-   return MIN2(dpb / (w * h), 16);
+   enc->dpb_slots = num_reconstructed_pictures;
+
+   return offset;
 }
 
 static void radeon_uvd_enc_begin_frame(struct pipe_video_codec *encoder,
@@ -194,25 +160,17 @@ static void radeon_uvd_enc_begin_frame(struct pipe_video_codec *encoder,
 
    enc->need_feedback = false;
 
-   if (!enc->cpb_num) {
-      struct si_screen *sscreen = (struct si_screen *)encoder->context->screen;
-      unsigned cpb_size;
-
-      enc->cpb_num = get_cpb_num(enc, pic->seq.general_level_idc);
-      if (!enc->cpb_num)
-         return;
-
-      cpb_size = (sscreen->info.gfx_level < GFX9)
-                    ? align(enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe, 128) *
-                         align(enc->luma->u.legacy.level[0].nblk_y, 32)
-                    : align(enc->luma->u.gfx9.surf_pitch * enc->luma->bpe, 256) *
-                         align(enc->luma->u.gfx9.surf_height, 32);
-
-      cpb_size = cpb_size * 3 / 2;
-      cpb_size = cpb_size * enc->cpb_num;
-
-      if (!si_vid_create_buffer(enc->screen, &enc->cpb, cpb_size, PIPE_USAGE_DEFAULT)) {
-         RVID_ERR("Can't create CPB buffer.\n");
+   unsigned dpb_slots = MAX2(pic->seq.sps_max_dec_pic_buffering_minus1[0] + 1, pic->dpb_size);
+
+   if (enc->dpb_slots < dpb_slots) {
+      uint32_t dpb_size = setup_dpb(enc, dpb_slots);
+      if (!enc->dpb.res) {
+         if (!si_vid_create_buffer(enc->screen, &enc->dpb, dpb_size, PIPE_USAGE_DEFAULT)) {
+            RVID_ERR("Can't create DPB buffer.\n");
+            return;
+         }
+      } else if (!si_vid_resize_buffer(enc->base.context, &enc->cs, &enc->dpb, dpb_size, NULL)) {
+         RVID_ERR("Can't resize DPB buffer.\n");
          return;
       }
    }
@@ -275,7 +233,8 @@ static void radeon_uvd_enc_destroy(struct pipe_video_codec *encoder)
       si_vid_destroy_buffer(&fb);
    }
 
-   si_vid_destroy_buffer(&enc->cpb);
+   if (enc->dpb.res)
+      si_vid_destroy_buffer(&enc->dpb);
    enc->ws->cs_destroy(&enc->cs);
    FREE(enc);
 }
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index 43e902913c1ed..759a3ec6e9acd 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -413,11 +413,11 @@ struct radeon_uvd_encoder {
    struct pb_buffer_lean *bs_handle;
    unsigned bs_size;
 
-   unsigned cpb_num;
+   unsigned dpb_slots;
 
    struct rvid_buffer *si;
    struct rvid_buffer *fb;
-   struct rvid_buffer cpb;
+   struct rvid_buffer dpb;
    struct radeon_uvd_enc_pic enc_pic;
 
    unsigned shifter;
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 26c849747a67d..b73f49aa74ccf 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -795,24 +795,24 @@ static void radeon_uvd_enc_ctx(struct radeon_uvd_encoder *enc)
    enc->enc_pic.ctx_buf.num_reconstructed_pictures = 2;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_ENCODE_CONTEXT_BUFFER);
-   RADEON_ENC_READWRITE(enc->cpb.res->buf, enc->cpb.res->domains, 0);
+   RADEON_ENC_READWRITE(enc->dpb.res->buf, enc->dpb.res->domains, 0);
    RADEON_ENC_CS(0x00000000); // reserved
    RADEON_ENC_CS(enc->enc_pic.ctx_buf.swizzle_mode);
    RADEON_ENC_CS(enc->enc_pic.ctx_buf.rec_luma_pitch);
    RADEON_ENC_CS(enc->enc_pic.ctx_buf.rec_chroma_pitch);
    RADEON_ENC_CS(enc->enc_pic.ctx_buf.num_reconstructed_pictures);
-   /* reconstructed_picture_1_luma_offset */
-   RADEON_ENC_CS(0x00000000);
-   /* reconstructed_picture_1_chroma_offset */
-   RADEON_ENC_CS(enc->enc_pic.ctx_buf.rec_chroma_pitch * align(enc->base.height, 16));
-   /* reconstructed_picture_2_luma_offset */
-   RADEON_ENC_CS(enc->enc_pic.ctx_buf.rec_luma_pitch * align(enc->base.height, 16) * 3 / 2);
-   /* reconstructed_picture_2_chroma_offset */
-   RADEON_ENC_CS(enc->enc_pic.ctx_buf.rec_chroma_pitch * align(enc->base.height, 16) * 5 / 2);
-
-   for (int i = 0; i < 136; i++)
-      RADEON_ENC_CS(0x00000000);
-
+   for (uint32_t i = 0; i < RENC_UVD_MAX_NUM_RECONSTRUCTED_PICTURES; i++) {
+      RADEON_ENC_CS(enc->enc_pic.ctx_buf.reconstructed_pictures[i].luma_offset);
+      RADEON_ENC_CS(enc->enc_pic.ctx_buf.reconstructed_pictures[i].chroma_offset);
+   }
+   RADEON_ENC_CS(enc->enc_pic.ctx_buf.pre_encode_picture_luma_pitch);
+   RADEON_ENC_CS(enc->enc_pic.ctx_buf.pre_encode_picture_chroma_pitch);
+   for (uint32_t i = 0; i < RENC_UVD_MAX_NUM_RECONSTRUCTED_PICTURES; i++) {
+      RADEON_ENC_CS(enc->enc_pic.ctx_buf.pre_encode_reconstructed_pictures[i].luma_offset);
+      RADEON_ENC_CS(enc->enc_pic.ctx_buf.pre_encode_reconstructed_pictures[i].chroma_offset);
+   }
+   RADEON_ENC_CS(enc->enc_pic.ctx_buf.pre_encode_input_picture.luma_offset);
+   RADEON_ENC_CS(enc->enc_pic.ctx_buf.pre_encode_input_picture.chroma_offset);
    RADEON_ENC_END();
 }
 
-- 
GitLab


From 27603300763a0ae439f6d8236630d7a8f52d73b0 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Mon, 30 Dec 2024 16:00:02 +0100
Subject: [PATCH 19/32] radeonsi/uvd_enc: Use app DPB management

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c |  70 +-
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h |  59 +-
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 704 +++++++-----------
 3 files changed, 288 insertions(+), 545 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index 26c0a0a18d639..02fb45c4d809c 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -17,47 +17,18 @@
 
 #include <stdio.h>
 
-static void radeon_uvd_enc_get_vui_param(struct radeon_uvd_encoder *enc,
-                                         struct pipe_h265_enc_picture_desc *pic)
-{
-   enc->enc_pic.vui_info.vui_parameters_present_flag =
-      pic->seq.vui_parameters_present_flag;
-   enc->enc_pic.vui_info.flags.aspect_ratio_info_present_flag =
-      pic->seq.vui_flags.aspect_ratio_info_present_flag;
-   enc->enc_pic.vui_info.flags.timing_info_present_flag =
-      pic->seq.vui_flags.timing_info_present_flag;
-   enc->enc_pic.vui_info.flags.video_signal_type_present_flag =
-      pic->seq.vui_flags.video_signal_type_present_flag;
-   enc->enc_pic.vui_info.flags.colour_description_present_flag =
-      pic->seq.vui_flags.colour_description_present_flag;
-   enc->enc_pic.vui_info.flags.chroma_loc_info_present_flag =
-      pic->seq.vui_flags.chroma_loc_info_present_flag;
-   enc->enc_pic.vui_info.aspect_ratio_idc = pic->seq.aspect_ratio_idc;
-   enc->enc_pic.vui_info.sar_width = pic->seq.sar_width;
-   enc->enc_pic.vui_info.sar_height = pic->seq.sar_height;
-   enc->enc_pic.vui_info.num_units_in_tick = pic->seq.num_units_in_tick;
-   enc->enc_pic.vui_info.time_scale = pic->seq.time_scale;
-   enc->enc_pic.vui_info.video_format = pic->seq.video_format;
-   enc->enc_pic.vui_info.video_full_range_flag = pic->seq.video_full_range_flag;
-   enc->enc_pic.vui_info.colour_primaries = pic->seq.colour_primaries;
-   enc->enc_pic.vui_info.transfer_characteristics = pic->seq.transfer_characteristics;
-   enc->enc_pic.vui_info.matrix_coefficients = pic->seq.matrix_coefficients;
-   enc->enc_pic.vui_info.chroma_sample_loc_type_top_field =
-      pic->seq.chroma_sample_loc_type_top_field;
-   enc->enc_pic.vui_info.chroma_sample_loc_type_bottom_field =
-      pic->seq.chroma_sample_loc_type_bottom_field;
-}
-
 static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
                                      struct pipe_h265_enc_picture_desc *pic)
 {
+   enc->enc_pic.desc = pic;
    enc->enc_pic.picture_type = pic->picture_type;
-   enc->enc_pic.frame_num = pic->frame_num;
-   enc->enc_pic.pic_order_cnt = pic->pic_order_cnt;
-   enc->enc_pic.pic_order_cnt_type = pic->pic_order_cnt_type;
-   enc->enc_pic.not_referenced = pic->not_referenced;
+   enc->enc_pic.nal_unit_type = pic->pic.nal_unit_type;
+   enc->enc_pic.temporal_id = pic->pic.temporal_id;
    enc->enc_pic.is_iframe = (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) ||
                             (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_I);
+   enc->enc_pic.enc_params.reference_picture_index =
+      pic->ref_list0[0] == PIPE_H2645_LIST_REF_INVALID_ENTRY ? 0xffffffff : pic->ref_list0[0];
+   enc->enc_pic.enc_params.reconstructed_picture_index = pic->dpb_curr_pic;
 
    if (pic->seq.conformance_window_flag) {
          enc->enc_pic.crop_left = pic->seq.conf_win_left_offset;
@@ -70,34 +41,6 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
          enc->enc_pic.crop_top = 0;
          enc->enc_pic.crop_bottom = 0;
    }
-
-   enc->enc_pic.general_tier_flag = pic->seq.general_tier_flag;
-   enc->enc_pic.general_profile_idc = pic->seq.general_profile_idc;
-   enc->enc_pic.general_level_idc = pic->seq.general_level_idc;
-   enc->enc_pic.max_poc = MAX2(16, util_next_power_of_two(pic->seq.intra_period));
-   enc->enc_pic.log2_max_poc = 0;
-   for (int i = enc->enc_pic.max_poc; i != 0; enc->enc_pic.log2_max_poc++)
-      i = (i >> 1);
-   enc->enc_pic.chroma_format_idc = pic->seq.chroma_format_idc;
-   enc->enc_pic.pic_width_in_luma_samples = pic->seq.pic_width_in_luma_samples;
-   enc->enc_pic.pic_height_in_luma_samples = pic->seq.pic_height_in_luma_samples;
-   enc->enc_pic.log2_diff_max_min_luma_coding_block_size =
-      pic->seq.log2_diff_max_min_luma_coding_block_size;
-   enc->enc_pic.log2_min_transform_block_size_minus2 =
-      pic->seq.log2_min_transform_block_size_minus2;
-   enc->enc_pic.log2_diff_max_min_transform_block_size =
-      pic->seq.log2_diff_max_min_transform_block_size;
-   enc->enc_pic.max_transform_hierarchy_depth_inter = pic->seq.max_transform_hierarchy_depth_inter;
-   enc->enc_pic.max_transform_hierarchy_depth_intra = pic->seq.max_transform_hierarchy_depth_intra;
-   enc->enc_pic.log2_parallel_merge_level_minus2 = pic->pic.log2_parallel_merge_level_minus2;
-   enc->enc_pic.bit_depth_luma_minus8 = pic->seq.bit_depth_luma_minus8;
-   enc->enc_pic.bit_depth_chroma_minus8 = pic->seq.bit_depth_chroma_minus8;
-   enc->enc_pic.nal_unit_type = pic->pic.nal_unit_type;
-   enc->enc_pic.max_num_merge_cand = pic->slice.max_num_merge_cand;
-   enc->enc_pic.sample_adaptive_offset_enabled_flag = pic->seq.sample_adaptive_offset_enabled_flag;
-   enc->enc_pic.pcm_enabled_flag = 0; /*HW not support PCM */
-   enc->enc_pic.sps_temporal_mvp_enabled_flag = pic->seq.sps_temporal_mvp_enabled_flag;
-   radeon_uvd_enc_get_vui_param(enc, pic);
 }
 
 static int flush(struct radeon_uvd_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
@@ -307,7 +250,6 @@ struct pipe_video_codec *radeon_uvd_create_encoder(struct pipe_context *context,
    enc->base.fence_wait = radeon_uvd_enc_fence_wait;
    enc->base.destroy_fence = radeon_uvd_enc_destroy_fence;
    enc->get_buffer = get_buffer;
-   enc->bits_in_shifter = 0;
    enc->screen = context->screen;
    enc->ws = ws;
 
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index 759a3ec6e9acd..695008c1d9e10 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -303,31 +303,6 @@ typedef struct ruvd_enc_feedback_buffer_s {
    uint32_t feedback_data_size;
 } ruvd_enc_feedback_buffer_t;
 
-typedef struct ruvd_enc_vui_info_s
-{
-   uint32_t vui_parameters_present_flag;
-   struct {
-      uint32_t aspect_ratio_info_present_flag : 1;
-      uint32_t timing_info_present_flag : 1;
-      uint32_t video_signal_type_present_flag : 1;
-      uint32_t colour_description_present_flag : 1;
-      uint32_t chroma_loc_info_present_flag : 1;
-   } flags;
-   uint32_t aspect_ratio_idc;
-   uint32_t sar_width;
-   uint32_t sar_height;
-   uint32_t num_units_in_tick;
-   uint32_t time_scale;
-   uint32_t video_format;
-   uint32_t video_full_range_flag;
-   uint32_t colour_primaries;
-   uint32_t transfer_characteristics;
-   uint32_t matrix_coefficients;
-   uint32_t chroma_sample_loc_type_top_field;
-   uint32_t chroma_sample_loc_type_bottom_field;
-   uint32_t max_num_reorder_frames;
-} ruvd_enc_vui_info;
-
 typedef void (*radeon_uvd_enc_get_buffer)(struct pipe_resource *resource, struct pb_buffer_lean **handle,
                                           struct radeon_surf **surface);
 
@@ -338,40 +313,16 @@ struct pipe_video_codec *radeon_uvd_create_encoder(struct pipe_context *context,
 
 struct radeon_uvd_enc_pic {
    enum pipe_h2645_enc_picture_type picture_type;
+   struct pipe_h265_enc_picture_desc *desc;
 
-   unsigned frame_num;
-   unsigned pic_order_cnt;
-   unsigned pic_order_cnt_type;
    unsigned crop_left;
    unsigned crop_right;
    unsigned crop_top;
    unsigned crop_bottom;
-   unsigned general_tier_flag;
-   unsigned general_profile_idc;
-   unsigned general_level_idc;
-   unsigned max_poc;
-   unsigned log2_max_poc;
-   unsigned chroma_format_idc;
-   unsigned pic_width_in_luma_samples;
-   unsigned pic_height_in_luma_samples;
-   unsigned log2_diff_max_min_luma_coding_block_size;
-   unsigned log2_min_transform_block_size_minus2;
-   unsigned log2_diff_max_min_transform_block_size;
-   unsigned max_transform_hierarchy_depth_inter;
-   unsigned max_transform_hierarchy_depth_intra;
-   unsigned log2_parallel_merge_level_minus2;
-   unsigned bit_depth_luma_minus8;
-   unsigned bit_depth_chroma_minus8;
    unsigned nal_unit_type;
-   unsigned max_num_merge_cand;
-   ruvd_enc_vui_info vui_info;
+   unsigned temporal_id;
 
-   bool not_referenced;
    bool is_iframe;
-   bool is_even_frame;
-   bool sample_adaptive_offset_enabled_flag;
-   bool pcm_enabled_flag;
-   bool sps_temporal_mvp_enabled_flag;
 
    ruvd_enc_task_info_t task_info;
    ruvd_enc_session_init_t session_init;
@@ -420,15 +371,9 @@ struct radeon_uvd_encoder {
    struct rvid_buffer dpb;
    struct radeon_uvd_enc_pic enc_pic;
 
-   unsigned shifter;
-   unsigned bits_in_shifter;
-   unsigned num_zeros;
-   unsigned byte_index;
-   unsigned bits_output;
    uint32_t total_task_size;
    uint32_t *p_task_size;
 
-   bool emulation_prevention;
    bool need_feedback;
 };
 
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index b73f49aa74ccf..7c4e06700b059 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -9,6 +9,7 @@
 #include "pipe/p_video_codec.h"
 #include "radeon_uvd_enc.h"
 #include "radeon_video.h"
+#include "radeon_bitstream.h"
 #include "radeonsi/si_pipe.h"
 #include "util/u_memory.h"
 #include "util/u_video.h"
@@ -32,8 +33,6 @@
    enc->total_task_size += *begin;                                                                 \
    }
 
-static const unsigned index_to_shifts[4] = {24, 16, 8, 0};
-
 static void radeon_uvd_enc_add_buffer(struct radeon_uvd_encoder *enc, struct pb_buffer_lean *buf,
                                       unsigned usage, enum radeon_bo_domain domain,
                                       signed offset)
@@ -46,130 +45,6 @@ static void radeon_uvd_enc_add_buffer(struct radeon_uvd_encoder *enc, struct pb_
    RADEON_ENC_CS(addr);
 }
 
-static void radeon_uvd_enc_set_emulation_prevention(struct radeon_uvd_encoder *enc, bool set)
-{
-   if (set != enc->emulation_prevention) {
-      enc->emulation_prevention = set;
-      enc->num_zeros = 0;
-   }
-}
-
-static void radeon_uvd_enc_output_one_byte(struct radeon_uvd_encoder *enc, unsigned char byte)
-{
-   if (enc->byte_index == 0)
-      enc->cs.current.buf[enc->cs.current.cdw] = 0;
-   enc->cs.current.buf[enc->cs.current.cdw] |=
-      ((unsigned int)(byte) << index_to_shifts[enc->byte_index]);
-   enc->byte_index++;
-
-   if (enc->byte_index >= 4) {
-      enc->byte_index = 0;
-      enc->cs.current.cdw++;
-   }
-}
-
-static void radeon_uvd_enc_emulation_prevention(struct radeon_uvd_encoder *enc, unsigned char byte)
-{
-   if (enc->emulation_prevention) {
-      if ((enc->num_zeros >= 2) &&
-          ((byte == 0x00) || (byte == 0x01) || (byte == 0x02) || (byte == 0x03))) {
-         radeon_uvd_enc_output_one_byte(enc, 0x03);
-         enc->bits_output += 8;
-         enc->num_zeros = 0;
-      }
-      enc->num_zeros = (byte == 0 ? (enc->num_zeros + 1) : 0);
-   }
-}
-
-static void radeon_uvd_enc_code_fixed_bits(struct radeon_uvd_encoder *enc, unsigned int value,
-                                           unsigned int num_bits)
-{
-   unsigned int bits_to_pack = 0;
-
-   while (num_bits > 0) {
-      unsigned int value_to_pack = value & (0xffffffff >> (32 - num_bits));
-      bits_to_pack =
-         num_bits > (32 - enc->bits_in_shifter) ? (32 - enc->bits_in_shifter) : num_bits;
-
-      if (bits_to_pack < num_bits)
-         value_to_pack = value_to_pack >> (num_bits - bits_to_pack);
-
-      enc->shifter |= value_to_pack << (32 - enc->bits_in_shifter - bits_to_pack);
-      num_bits -= bits_to_pack;
-      enc->bits_in_shifter += bits_to_pack;
-
-      while (enc->bits_in_shifter >= 8) {
-         unsigned char output_byte = (unsigned char)(enc->shifter >> 24);
-         enc->shifter <<= 8;
-         radeon_uvd_enc_emulation_prevention(enc, output_byte);
-         radeon_uvd_enc_output_one_byte(enc, output_byte);
-         enc->bits_in_shifter -= 8;
-         enc->bits_output += 8;
-      }
-   }
-}
-
-static void radeon_uvd_enc_reset(struct radeon_uvd_encoder *enc)
-{
-   enc->emulation_prevention = false;
-   enc->shifter = 0;
-   enc->bits_in_shifter = 0;
-   enc->bits_output = 0;
-   enc->num_zeros = 0;
-   enc->byte_index = 0;
-}
-
-static void radeon_uvd_enc_byte_align(struct radeon_uvd_encoder *enc)
-{
-   unsigned int num_padding_zeros = (32 - enc->bits_in_shifter) % 8;
-
-   if (num_padding_zeros > 0)
-      radeon_uvd_enc_code_fixed_bits(enc, 0, num_padding_zeros);
-}
-
-static void radeon_uvd_enc_flush_headers(struct radeon_uvd_encoder *enc)
-{
-   if (enc->bits_in_shifter != 0) {
-      unsigned char output_byte = (unsigned char)(enc->shifter >> 24);
-      radeon_uvd_enc_emulation_prevention(enc, output_byte);
-      radeon_uvd_enc_output_one_byte(enc, output_byte);
-      enc->bits_output += enc->bits_in_shifter;
-      enc->shifter = 0;
-      enc->bits_in_shifter = 0;
-      enc->num_zeros = 0;
-   }
-
-   if (enc->byte_index > 0) {
-      enc->cs.current.cdw++;
-      enc->byte_index = 0;
-   }
-}
-
-static void radeon_uvd_enc_code_ue(struct radeon_uvd_encoder *enc, unsigned int value)
-{
-   int x = -1;
-   unsigned int ue_code = value + 1;
-   value += 1;
-
-   while (value) {
-      value = (value >> 1);
-      x += 1;
-   }
-
-   unsigned int ue_length = (x << 1) + 1;
-   radeon_uvd_enc_code_fixed_bits(enc, ue_code, ue_length);
-}
-
-static void radeon_uvd_enc_code_se(struct radeon_uvd_encoder *enc, int value)
-{
-   unsigned int v = 0;
-
-   if (value != 0)
-      v = (value < 0 ? ((unsigned int)(0 - value) << 1) : (((unsigned int)(value) << 1) - 1));
-
-   radeon_uvd_enc_code_ue(enc, v);
-}
-
 static void radeon_uvd_enc_session_info(struct radeon_uvd_encoder *enc)
 {
    unsigned int interface_version =
@@ -374,329 +249,298 @@ static void radeon_uvd_enc_quality_params(struct radeon_uvd_encoder *enc)
 
 static void radeon_uvd_enc_nalu_sps_hevc(struct radeon_uvd_encoder *enc)
 {
+   struct radeon_bitstream bs;
+   struct pipe_h265_enc_seq_param *sps = &enc->enc_pic.desc->seq;
+   int i;
+
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
    RADEON_ENC_CS(RENC_UVD_NALU_TYPE_SPS);
    uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-   int i;
 
-   radeon_uvd_enc_reset(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, false);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x4201, 16);
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, true);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 4);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1, 3);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.general_tier_flag, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.general_profile_idc, 5);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x60000000, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0xb0000000, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 16);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.general_level_idc, 8);
-
-   for (i = 0; i < (enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1); i++)
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
-
-   if ((enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1) > 0) {
-      for (i = (enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1); i < 8; i++)
-         radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, 0x4201, 16);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 4); /* sps_video_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, sps->sps_max_sub_layers_minus1, 3);
+   radeon_bs_code_fixed_bits(&bs, sps->sps_temporal_id_nesting_flag, 1);
+   radeon_bs_hevc_profile_tier_level(&bs, sps->sps_max_sub_layers_minus1, &sps->profile_tier_level);
+   radeon_bs_code_ue(&bs, 0x0); /* sps_seq_parameter_set_id */
+   radeon_bs_code_ue(&bs, sps->chroma_format_idc);
+   radeon_bs_code_ue(&bs, enc->enc_pic.session_init.aligned_picture_width);
+   radeon_bs_code_ue(&bs, enc->enc_pic.session_init.aligned_picture_height);
+
+   radeon_bs_code_fixed_bits(&bs, sps->conformance_window_flag, 1);
+   if (sps->conformance_window_flag) {
+      radeon_bs_code_ue(&bs, sps->conf_win_left_offset);
+      radeon_bs_code_ue(&bs, sps->conf_win_right_offset);
+      radeon_bs_code_ue(&bs, sps->conf_win_top_offset);
+      radeon_bs_code_ue(&bs, sps->conf_win_bottom_offset);
    }
 
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.chroma_format_idc);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.session_init.aligned_picture_width);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.session_init.aligned_picture_height);
-
-   int conformance_window_flag = (enc->enc_pic.crop_top > 0) || (enc->enc_pic.crop_bottom > 0) ||
-                                       (enc->enc_pic.crop_left > 0) || (enc->enc_pic.crop_right > 0)
-                                    ? 0x1
-                                    : 0x0;
-   radeon_uvd_enc_code_fixed_bits(enc, conformance_window_flag, 1);
-
-   if (conformance_window_flag == 1) {
-      radeon_uvd_enc_code_ue(enc, enc->enc_pic.crop_left);
-      radeon_uvd_enc_code_ue(enc, enc->enc_pic.crop_right);
-      radeon_uvd_enc_code_ue(enc, enc->enc_pic.crop_top);
-      radeon_uvd_enc_code_ue(enc, enc->enc_pic.crop_bottom);
+   radeon_bs_code_ue(&bs, sps->bit_depth_luma_minus8);
+   radeon_bs_code_ue(&bs, sps->bit_depth_chroma_minus8);
+   radeon_bs_code_ue(&bs, sps->log2_max_pic_order_cnt_lsb_minus4);
+   radeon_bs_code_fixed_bits(&bs, sps->sps_sub_layer_ordering_info_present_flag, 1);
+   i = sps->sps_sub_layer_ordering_info_present_flag ? 0 : sps->sps_max_sub_layers_minus1;
+   for (; i <= sps->sps_max_sub_layers_minus1; i++) {
+      radeon_bs_code_ue(&bs, sps->sps_max_dec_pic_buffering_minus1[i]);
+      radeon_bs_code_ue(&bs, sps->sps_max_num_reorder_pics[i]);
+      radeon_bs_code_ue(&bs, sps->sps_max_latency_increase_plus1[i]);
    }
 
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.bit_depth_luma_minus8);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.bit_depth_chroma_minus8);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.log2_max_poc - 4);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_ue(enc, 1);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.hevc_spec_misc.log2_min_luma_coding_block_size_minus3);
-   /* Only support CTBSize 64 */
-   radeon_uvd_enc_code_ue(
-      enc, 6 - (enc->enc_pic.hevc_spec_misc.log2_min_luma_coding_block_size_minus3 + 3));
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.log2_min_transform_block_size_minus2);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.log2_diff_max_min_transform_block_size);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.max_transform_hierarchy_depth_inter);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.max_transform_hierarchy_depth_intra);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, !enc->enc_pic.hevc_spec_misc.amp_disabled, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.sample_adaptive_offset_enabled_flag, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.pcm_enabled_flag, 1);
-
-   radeon_uvd_enc_code_ue(enc, 1);
-   radeon_uvd_enc_code_ue(enc, 1);
-   radeon_uvd_enc_code_ue(enc, 0);
-   radeon_uvd_enc_code_ue(enc, 0);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.hevc_spec_misc.strong_intra_smoothing_enabled,
-                                  1);
-
-   radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.vui_parameters_present_flag), 1);
-   if (enc->enc_pic.vui_info.vui_parameters_present_flag) {
+   unsigned log2_diff_max_min_luma_coding_block_size =
+      6 - (enc->enc_pic.hevc_spec_misc.log2_min_luma_coding_block_size_minus3 + 3);
+   unsigned log2_min_transform_block_size_minus2 =
+      enc->enc_pic.hevc_spec_misc.log2_min_luma_coding_block_size_minus3;
+   unsigned log2_diff_max_min_transform_block_size = log2_diff_max_min_luma_coding_block_size;
+   unsigned max_transform_hierarchy_depth_inter = log2_diff_max_min_luma_coding_block_size + 1;
+   unsigned max_transform_hierarchy_depth_intra = max_transform_hierarchy_depth_inter;
+
+   radeon_bs_code_ue(&bs, enc->enc_pic.hevc_spec_misc.log2_min_luma_coding_block_size_minus3);
+   radeon_bs_code_ue(&bs, log2_diff_max_min_luma_coding_block_size);
+   radeon_bs_code_ue(&bs, log2_min_transform_block_size_minus2);
+   radeon_bs_code_ue(&bs, log2_diff_max_min_transform_block_size);
+   radeon_bs_code_ue(&bs, max_transform_hierarchy_depth_inter);
+   radeon_bs_code_ue(&bs, max_transform_hierarchy_depth_intra);
+
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* scaling_list_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, !enc->enc_pic.hevc_spec_misc.amp_disabled, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* sample_adaptive_offset_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pcm_enabled_flag */
+
+   radeon_bs_code_ue(&bs, sps->num_short_term_ref_pic_sets);
+   for (i = 0; i < sps->num_short_term_ref_pic_sets; i++)
+      radeon_bs_hevc_st_ref_pic_set(&bs, i, sps->num_short_term_ref_pic_sets, sps->st_ref_pic_set);
+
+   radeon_bs_code_fixed_bits(&bs, sps->long_term_ref_pics_present_flag, 1);
+   if (sps->long_term_ref_pics_present_flag) {
+      radeon_bs_code_ue(&bs, sps->num_long_term_ref_pics_sps);
+      for (i = 0; i < sps->num_long_term_ref_pics_sps; i++) {
+         radeon_bs_code_fixed_bits(&bs, sps->lt_ref_pic_poc_lsb_sps[i], sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+         radeon_bs_code_fixed_bits(&bs, sps->used_by_curr_pic_lt_sps_flag[i], 1);
+      }
+   }
+
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* sps_temporal_mvp_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_spec_misc.strong_intra_smoothing_enabled, 1);
+
+   /* VUI parameters present flag */
+   radeon_bs_code_fixed_bits(&bs, (sps->vui_parameters_present_flag), 1);
+   if (sps->vui_parameters_present_flag) {
       /* aspect ratio present flag */
-      radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.flags.aspect_ratio_info_present_flag), 1);
-      if (enc->enc_pic.vui_info.flags.aspect_ratio_info_present_flag) {
-         radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.aspect_ratio_idc), 8);
-         if (enc->enc_pic.vui_info.aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
-            radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.sar_width), 16);
-            radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.sar_height), 16);
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.aspect_ratio_info_present_flag), 1);
+      if (sps->vui_flags.aspect_ratio_info_present_flag) {
+         radeon_bs_code_fixed_bits(&bs, (sps->aspect_ratio_idc), 8);
+         if (sps->aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_width), 16);
+            radeon_bs_code_fixed_bits(&bs, (sps->sar_height), 16);
          }
       }
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);  /* overscan info present flag */
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_info_present_flag, 1);
+      if (sps->vui_flags.overscan_info_present_flag)
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.overscan_appropriate_flag, 1);
       /* video signal type present flag  */
-      radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.flags.video_signal_type_present_flag, 1);
-      if (enc->enc_pic.vui_info.flags.video_signal_type_present_flag) {
-         radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.video_format, 3);
-         radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.video_full_range_flag, 1);
-         radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.flags.colour_description_present_flag, 1);
-         if (enc->enc_pic.vui_info.flags.colour_description_present_flag) {
-            radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.colour_primaries, 8);
-            radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.transfer_characteristics, 8);
-            radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.matrix_coefficients, 8);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.video_signal_type_present_flag, 1);
+      if (sps->vui_flags.video_signal_type_present_flag) {
+         radeon_bs_code_fixed_bits(&bs, sps->video_format, 3);
+         radeon_bs_code_fixed_bits(&bs, sps->video_full_range_flag, 1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.colour_description_present_flag, 1);
+         if (sps->vui_flags.colour_description_present_flag) {
+            radeon_bs_code_fixed_bits(&bs, sps->colour_primaries, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->transfer_characteristics, 8);
+            radeon_bs_code_fixed_bits(&bs, sps->matrix_coefficients, 8);
          }
       }
       /* chroma loc info present flag */
-      radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.vui_info.flags.chroma_loc_info_present_flag, 1);
-      if (enc->enc_pic.vui_info.flags.chroma_loc_info_present_flag) {
-         radeon_uvd_enc_code_ue(enc, enc->enc_pic.vui_info.chroma_sample_loc_type_top_field);
-         radeon_uvd_enc_code_ue(enc, enc->enc_pic.vui_info.chroma_sample_loc_type_bottom_field);
+      radeon_bs_code_fixed_bits(&bs, sps->vui_flags.chroma_loc_info_present_flag, 1);
+      if (sps->vui_flags.chroma_loc_info_present_flag) {
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_top_field);
+         radeon_bs_code_ue(&bs, sps->chroma_sample_loc_type_bottom_field);
       }
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);  /* neutral chroma indication flag */
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);  /* field seq flag */
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);  /* frame field info present flag */
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);  /* default display windows flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* neutral chroma indication flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* field seq flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* frame field info present flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* default display windows flag */
       /* vui timing info present flag */
-      radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.flags.timing_info_present_flag), 1);
-      if (enc->enc_pic.vui_info.flags.timing_info_present_flag) {
-         radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.num_units_in_tick), 32);
-         radeon_uvd_enc_code_fixed_bits(enc, (enc->enc_pic.vui_info.time_scale), 32);
-         radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-         radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
+      radeon_bs_code_fixed_bits(&bs, (sps->vui_flags.timing_info_present_flag), 1);
+      if (sps->vui_flags.timing_info_present_flag) {
+         radeon_bs_code_fixed_bits(&bs, (sps->num_units_in_tick), 32);
+         radeon_bs_code_fixed_bits(&bs, (sps->time_scale), 32);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.poc_proportional_to_timing_flag, 1);
+         if (sps->vui_flags.poc_proportional_to_timing_flag)
+            radeon_bs_code_ue(&bs, sps->num_ticks_poc_diff_one_minus1);
+         radeon_bs_code_fixed_bits(&bs, sps->vui_flags.hrd_parameters_present_flag, 1);
+         if (sps->vui_flags.hrd_parameters_present_flag)
+            radeon_bs_hevc_hrd_parameters(&bs, 1, sps->sps_max_sub_layers_minus1, &sps->hrd_parameters);
       }
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);  /* bitstream restriction flag */
+      radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* bitstream restriction flag */
    }
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1);  /* sps extension present flag */
 
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_flush_headers(enc);
-   *size_in_bytes = (enc->bits_output + 7) / 8;
+   radeon_bs_flush_headers(&bs);
+   *size_in_bytes = bs.bits_output / 8;
    RADEON_ENC_END();
 }
 
 static void radeon_uvd_enc_nalu_pps_hevc(struct radeon_uvd_encoder *enc)
 {
+   struct radeon_bitstream bs;
+   struct pipe_h265_enc_pic_param *pps = &enc->enc_pic.desc->pic;
+
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
    RADEON_ENC_CS(RENC_UVD_NALU_TYPE_PPS);
    uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-   radeon_uvd_enc_reset(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, false);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x4401, 16);
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, true);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1); /* output_flag_resent_flag */
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 3); /* num_extra_slice_header_bits */
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_se(enc, 0x0);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.hevc_spec_misc.constrained_intra_pred_flag, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   if (enc->enc_pic.rc_session_init.rate_control_method == RENC_UVD_RATE_CONTROL_METHOD_NONE)
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   else {
-      radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-      radeon_uvd_enc_code_ue(enc, 0x0);
-   }
-   radeon_uvd_enc_code_se(enc, enc->enc_pic.hevc_deblock.cb_qp_offset);
-   radeon_uvd_enc_code_se(enc, enc->enc_pic.hevc_deblock.cr_qp_offset);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled,
-                                  1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.hevc_deblock.deblocking_filter_disabled, 1);
+
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, 0x4401, 16);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_ue(&bs, 0x0); /* pps_pic_parameter_set_id */
+   radeon_bs_code_ue(&bs, 0x0); /* pps_seq_parameter_set_id */
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* dependent_slice_segments_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, pps->output_flag_present_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 3); /* num_extra_slice_header_bits */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* sign_data_hiding_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* cabac_init_present_flag */
+   radeon_bs_code_ue(&bs, pps->num_ref_idx_l0_default_active_minus1);
+   radeon_bs_code_ue(&bs, pps->num_ref_idx_l1_default_active_minus1);
+   radeon_bs_code_se(&bs, 0x0); /* init_qp_minus26 */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_spec_misc.constrained_intra_pred_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* transform_skip_enabled */
+   bool cu_qp_delta_enabled_flag =
+      enc->enc_pic.rc_session_init.rate_control_method != RENC_UVD_RATE_CONTROL_METHOD_NONE;
+   radeon_bs_code_fixed_bits(&bs, cu_qp_delta_enabled_flag, 1);
+   if (cu_qp_delta_enabled_flag)
+      radeon_bs_code_ue(&bs, 0x0); /* diff_cu_qp_delta_depth */
+   radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.cb_qp_offset);
+   radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.cr_qp_offset);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pps_slice_chroma_qp_offsets_present_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2); /* weighted_pred_flag + weighted_bipred_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* transquant_bypass_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* tiles_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* entropy_coding_sync_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1); /* deblocking_filter_control_present_flag */
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* deblocking_filter_override_enabled_flag */
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_deblock.deblocking_filter_disabled, 1);
 
    if (!enc->enc_pic.hevc_deblock.deblocking_filter_disabled) {
-      radeon_uvd_enc_code_se(enc, enc->enc_pic.hevc_deblock.beta_offset_div2);
-      radeon_uvd_enc_code_se(enc, enc->enc_pic.hevc_deblock.tc_offset_div2);
+      radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.beta_offset_div2);
+      radeon_bs_code_se(&bs, enc->enc_pic.hevc_deblock.tc_offset_div2);
    }
 
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_ue(enc, enc->enc_pic.log2_parallel_merge_level_minus2);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* pps_scaling_list_data_present_flag */
+   radeon_bs_code_fixed_bits(&bs, pps->lists_modification_present_flag, 1);
+   radeon_bs_code_ue(&bs, pps->log2_parallel_merge_level_minus2);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 2);
 
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_flush_headers(enc);
-   *size_in_bytes = (enc->bits_output + 7) / 8;
+   radeon_bs_flush_headers(&bs);
+   *size_in_bytes = bs.bits_output / 8;
    RADEON_ENC_END();
 }
 
 static void radeon_uvd_enc_nalu_vps_hevc(struct radeon_uvd_encoder *enc)
 {
+   struct radeon_bitstream bs;
+   struct pipe_h265_enc_vid_param *vps = &enc->enc_pic.desc->vid;
+   int i;
+
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
    RADEON_ENC_CS(RENC_UVD_NALU_TYPE_VPS);
    uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-   int i;
 
-   radeon_uvd_enc_reset(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, false);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x4001, 16);
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, true);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 4);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x3, 2);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 6);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1, 3);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0xffff, 16);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.general_tier_flag, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.general_profile_idc, 5);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x60000000, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0xb0000000, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 16);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.general_level_idc, 8);
-
-   for (i = 0; i < (enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1); i++)
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
-
-   if ((enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1) > 0) {
-      for (i = (enc->enc_pic.layer_ctrl.max_num_temporal_layers - 1); i < 8; i++)
-         radeon_uvd_enc_code_fixed_bits(enc, 0x0, 2);
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_set_emulation_prevention(&bs, false);
+   radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
+   radeon_bs_code_fixed_bits(&bs, 0x4001, 16);
+   radeon_bs_set_emulation_prevention(&bs, true);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 4); /* vps_video_parameter_set_id*/
+   radeon_bs_code_fixed_bits(&bs, vps->vps_base_layer_internal_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, vps->vps_base_layer_available_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 6); /* vps_max_layers_minus1 */
+   radeon_bs_code_fixed_bits(&bs, vps->vps_max_sub_layers_minus1, 3);
+   radeon_bs_code_fixed_bits(&bs, vps->vps_temporal_id_nesting_flag, 1);
+   radeon_bs_code_fixed_bits(&bs, 0xffff, 16); /* vps_reserved_0xffff_16bits */
+   radeon_bs_hevc_profile_tier_level(&bs, vps->vps_max_sub_layers_minus1, &vps->profile_tier_level);
+   radeon_bs_code_fixed_bits(&bs, vps->vps_sub_layer_ordering_info_present_flag, 1);
+   i = vps->vps_sub_layer_ordering_info_present_flag ? 0 : vps->vps_max_sub_layers_minus1;
+   for (; i <= vps->vps_max_sub_layers_minus1; i++) {
+      radeon_bs_code_ue(&bs, vps->vps_max_dec_pic_buffering_minus1[i]);
+      radeon_bs_code_ue(&bs, vps->vps_max_num_reorder_pics[i]);
+      radeon_bs_code_ue(&bs, vps->vps_max_latency_increase_plus1[i]);
    }
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_ue(enc, 0x1);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 6);
-   radeon_uvd_enc_code_ue(enc, 0x0);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_flush_headers(enc);
-   *size_in_bytes = (enc->bits_output + 7) / 8;
-   RADEON_ENC_END();
-}
-
-static void radeon_uvd_enc_nalu_aud_hevc(struct radeon_uvd_encoder *enc)
-{
-   RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
-   RADEON_ENC_CS(RENC_UVD_NALU_TYPE_AUD);
-   uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-   radeon_uvd_enc_reset(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, false);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x00000001, 32);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, 35, 6);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 6);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 3);
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, true);
-   switch (enc->enc_pic.picture_type) {
-   case PIPE_H2645_ENC_PICTURE_TYPE_I:
-   case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
-      radeon_uvd_enc_code_fixed_bits(enc, 0x00, 3);
-      break;
-   case PIPE_H2645_ENC_PICTURE_TYPE_P:
-      radeon_uvd_enc_code_fixed_bits(enc, 0x01, 3);
-      break;
-   case PIPE_H2645_ENC_PICTURE_TYPE_B:
-      radeon_uvd_enc_code_fixed_bits(enc, 0x02, 3);
-      break;
-   default:
-      assert(0 && "Unsupported picture type!");
+   radeon_bs_code_fixed_bits(&bs, 0x0, 6); /* vps_max_layer_id */
+   radeon_bs_code_ue(&bs, 0x0); /* vps_num_layer_sets_minus1 */
+   radeon_bs_code_fixed_bits(&bs, vps->vps_timing_info_present_flag, 1);
+   if (vps->vps_timing_info_present_flag) {
+      radeon_bs_code_fixed_bits(&bs, vps->vps_num_units_in_tick, 32);
+      radeon_bs_code_fixed_bits(&bs, vps->vps_time_scale, 32);
+      radeon_bs_code_fixed_bits(&bs, vps->vps_poc_proportional_to_timing_flag, 1);
+      if (vps->vps_poc_proportional_to_timing_flag)
+         radeon_bs_code_ue(&bs, vps->vps_num_ticks_poc_diff_one_minus1);
+      radeon_bs_code_ue(&bs, 0x0); /* vps_num_hrd_parameters */
    }
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1); /* vps_extension_flag */
 
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
+   radeon_bs_code_fixed_bits(&bs, 0x1, 1);
+   radeon_bs_byte_align(&bs);
 
-   radeon_uvd_enc_byte_align(enc);
-   radeon_uvd_enc_flush_headers(enc);
-   *size_in_bytes = (enc->bits_output + 7) / 8;
+   radeon_bs_flush_headers(&bs);
+   *size_in_bytes = bs.bits_output / 8;
    RADEON_ENC_END();
 }
 
 static void radeon_uvd_enc_slice_header_hevc(struct radeon_uvd_encoder *enc)
 {
+   struct radeon_bitstream bs;
+   struct pipe_h265_enc_seq_param *sps = &enc->enc_pic.desc->seq;
+   struct pipe_h265_enc_pic_param *pps = &enc->enc_pic.desc->pic;
+   struct pipe_h265_enc_slice_param *slice = &enc->enc_pic.desc->slice;
    uint32_t instruction[RENC_UVD_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS] = {0};
    uint32_t num_bits[RENC_UVD_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS] = {0};
    unsigned int inst_index = 0;
-   unsigned int bit_index = 0;
+   unsigned int cdw_start = 0;
+   unsigned int cdw_filled = 0;
    unsigned int bits_copied = 0;
+   unsigned int num_pic_total_curr = 0;
+
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_SLICE_HEADER);
-   radeon_uvd_enc_reset(enc);
-   radeon_uvd_enc_set_emulation_prevention(enc, false);
+   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_set_emulation_prevention(&bs, false);
 
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-   radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.nal_unit_type, 6);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x0, 6);
-   radeon_uvd_enc_code_fixed_bits(enc, 0x1, 3);
+   cdw_start = enc->cs.current.cdw;
+   radeon_bs_code_fixed_bits(&bs, 0x0, 1);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.nal_unit_type, 6);
+   radeon_bs_code_fixed_bits(&bs, 0x0, 6);
+   radeon_bs_code_fixed_bits(&bs, enc->enc_pic.temporal_id + 1, 3);
 
-   radeon_uvd_enc_flush_headers(enc);
-   bit_index++;
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_FIRST_SLICE;
    inst_index++;
 
    if ((enc->enc_pic.nal_unit_type >= 16) && (enc->enc_pic.nal_unit_type <= 23))
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
+      radeon_bs_code_fixed_bits(&bs, slice->no_output_of_prior_pics_flag, 1);
 
-   radeon_uvd_enc_code_ue(enc, 0x0);
+   radeon_bs_code_ue(&bs, 0x0); /* slice_pic_parameter_set_id */
 
-   radeon_uvd_enc_flush_headers(enc);
-   bit_index++;
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_SLICE_SEGMENT;
@@ -708,46 +552,70 @@ static void radeon_uvd_enc_slice_header_hevc(struct radeon_uvd_encoder *enc)
    switch (enc->enc_pic.picture_type) {
    case PIPE_H2645_ENC_PICTURE_TYPE_I:
    case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
-      radeon_uvd_enc_code_ue(enc, 0x2);
+      radeon_bs_code_ue(&bs, 0x2);
       break;
    case PIPE_H2645_ENC_PICTURE_TYPE_P:
    case PIPE_H2645_ENC_PICTURE_TYPE_SKIP:
-      radeon_uvd_enc_code_ue(enc, 0x1);
-      break;
-   case PIPE_H2645_ENC_PICTURE_TYPE_B:
-      radeon_uvd_enc_code_ue(enc, 0x0);
-      break;
    default:
-      radeon_uvd_enc_code_ue(enc, 0x1);
+      radeon_bs_code_ue(&bs, 0x1);
+      break;
    }
 
+   if (pps->output_flag_present_flag)
+      radeon_bs_code_fixed_bits(&bs, slice->pic_output_flag, 1);
+
    if ((enc->enc_pic.nal_unit_type != 19) && (enc->enc_pic.nal_unit_type != 20)) {
-      radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.pic_order_cnt, enc->enc_pic.log2_max_poc);
-      if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P)
-         radeon_uvd_enc_code_fixed_bits(enc, 0x1, 1);
-      else {
-         radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-         radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-         radeon_uvd_enc_code_ue(enc, 0x0);
-         radeon_uvd_enc_code_ue(enc, 0x0);
+      radeon_bs_code_fixed_bits(&bs, slice->slice_pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+      radeon_bs_code_fixed_bits(&bs, slice->short_term_ref_pic_set_sps_flag, 1);
+      if (!slice->short_term_ref_pic_set_sps_flag) {
+         num_pic_total_curr =
+            radeon_bs_hevc_st_ref_pic_set(&bs, sps->num_short_term_ref_pic_sets,
+                                          sps->num_short_term_ref_pic_sets, sps->st_ref_pic_set);
+      } else if (sps->num_short_term_ref_pic_sets > 1) {
+         radeon_bs_code_fixed_bits(&bs, slice->short_term_ref_pic_set_idx,
+                                    util_logbase2_ceil(sps->num_short_term_ref_pic_sets));
+      }
+      if (sps->long_term_ref_pics_present_flag) {
+         if (sps->num_long_term_ref_pics_sps > 0)
+            radeon_bs_code_ue(&bs, slice->num_long_term_sps);
+         radeon_bs_code_ue(&bs, slice->num_long_term_pics);
+         for (unsigned i = 0; i < slice->num_long_term_sps + slice->num_long_term_pics; i++) {
+            if (i < slice->num_long_term_sps) {
+               if (sps->num_long_term_ref_pics_sps > 1)
+                  radeon_bs_code_fixed_bits(&bs, slice->lt_idx_sps[i], util_logbase2_ceil(sps->num_long_term_ref_pics_sps));
+            } else {
+               radeon_bs_code_fixed_bits(&bs, slice->poc_lsb_lt[i], sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+               radeon_bs_code_fixed_bits(&bs, slice->used_by_curr_pic_lt_flag[i], 1);
+               if (slice->used_by_curr_pic_lt_flag[i])
+                  num_pic_total_curr++;
+            }
+            radeon_bs_code_fixed_bits(&bs, slice->delta_poc_msb_present_flag[i], 1);
+            if (slice->delta_poc_msb_present_flag[i])
+               radeon_bs_code_ue(&bs, slice->delta_poc_msb_cycle_lt[i]);
+         }
       }
    }
 
-   if (enc->enc_pic.sample_adaptive_offset_enabled_flag)
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1); /* slice_sao_luma_flag */
-
-   if ((enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P) ||
-       (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)) {
-      radeon_uvd_enc_code_fixed_bits(enc, 0x0, 1);
-      radeon_uvd_enc_code_fixed_bits(enc, enc->enc_pic.hevc_spec_misc.cabac_init_flag, 1);
-      radeon_uvd_enc_code_ue(enc, 5 - enc->enc_pic.max_num_merge_cand);
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P) {
+      radeon_bs_code_fixed_bits(&bs, slice->num_ref_idx_active_override_flag, 1);
+      if (slice->num_ref_idx_active_override_flag)
+         radeon_bs_code_ue(&bs, slice->num_ref_idx_l0_active_minus1);
+      if (pps->lists_modification_present_flag && num_pic_total_curr > 1) {
+         unsigned num_bits = util_logbase2_ceil(num_pic_total_curr);
+         unsigned num_ref_l0_minus1 = slice->num_ref_idx_active_override_flag ?
+            slice->num_ref_idx_l0_active_minus1 : pps->num_ref_idx_l0_default_active_minus1;
+         radeon_bs_code_fixed_bits(&bs, slice->ref_pic_lists_modification.ref_pic_list_modification_flag_l0, 1);
+         for (unsigned i = 0; i <= num_ref_l0_minus1; i++)
+            radeon_bs_code_fixed_bits(&bs, slice->ref_pic_lists_modification.list_entry_l0[i], num_bits);
+      }
+      radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_spec_misc.cabac_init_flag, 1);
+      radeon_bs_code_ue(&bs, 5 - slice->max_num_merge_cand);
    }
 
-   radeon_uvd_enc_flush_headers(enc);
-   bit_index++;
+   radeon_bs_flush_headers(&bs);
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_COPY;
-   num_bits[inst_index] = enc->bits_output - bits_copied;
-   bits_copied = enc->bits_output;
+   num_bits[inst_index] = bs.bits_output - bits_copied;
+   bits_copied = bs.bits_output;
    inst_index++;
 
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_SLICE_QP_DELTA;
@@ -755,20 +623,18 @@ static void radeon_uvd_enc_slice_header_hevc(struct radeon_uvd_encoder *enc)
 
    if ((enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled) &&
        (!enc->enc_pic.hevc_deblock.deblocking_filter_disabled)) {
-      radeon_uvd_enc_code_fixed_bits(
-         enc, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
-
-      radeon_uvd_enc_flush_headers(enc);
-      bit_index++;
+      radeon_bs_code_fixed_bits(&bs, enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled, 1);
+      radeon_bs_flush_headers(&bs);
       instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_COPY;
-      num_bits[inst_index] = enc->bits_output - bits_copied;
-      bits_copied = enc->bits_output;
+      num_bits[inst_index] = bs.bits_output - bits_copied;
+      bits_copied = bs.bits_output;
       inst_index++;
    }
 
    instruction[inst_index] = RENC_UVD_HEADER_INSTRUCTION_END;
 
-   for (int i = bit_index; i < RENC_UVD_SLICE_HEADER_TEMPLATE_MAX_TEMPLATE_SIZE_IN_DWORDS; i++)
+   cdw_filled = enc->cs.current.cdw - cdw_start;
+   for (int i = 0; i < RENC_UVD_SLICE_HEADER_TEMPLATE_MAX_TEMPLATE_SIZE_IN_DWORDS - cdw_filled; i++)
       RADEON_ENC_CS(0x00000000);
 
    for (int j = 0; j < RENC_UVD_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS; j++) {
@@ -792,7 +658,6 @@ static void radeon_uvd_enc_ctx(struct radeon_uvd_encoder *enc)
       enc->enc_pic.ctx_buf.rec_luma_pitch = enc->luma->u.gfx9.surf_pitch * enc->luma->bpe;
       enc->enc_pic.ctx_buf.rec_chroma_pitch = enc->chroma->u.gfx9.surf_pitch * enc->chroma->bpe;
    }
-   enc->enc_pic.ctx_buf.num_reconstructed_pictures = 2;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_ENCODE_CONTEXT_BUFFER);
    RADEON_ENC_READWRITE(enc->dpb.res->buf, enc->dpb.res->domains, 0);
@@ -914,13 +779,6 @@ static void radeon_uvd_enc_encode_params_hevc(struct radeon_uvd_encoder *enc)
    }
    enc->enc_pic.enc_params.input_pic_swizzle_mode = RENC_UVD_SWIZZLE_MODE_LINEAR;
 
-   if (enc->enc_pic.enc_params.pic_type == RENC_UVD_PICTURE_TYPE_I)
-      enc->enc_pic.enc_params.reference_picture_index = 0xFFFFFFFF;
-   else
-      enc->enc_pic.enc_params.reference_picture_index = (enc->enc_pic.frame_num - 1) % 2;
-
-   enc->enc_pic.enc_params.reconstructed_picture_index = enc->enc_pic.frame_num % 2;
-
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_ENCODE_PARAMS);
    RADEON_ENC_CS(enc->enc_pic.enc_params.pic_type);
    RADEON_ENC_CS(enc->enc_pic.enc_params.allowed_max_bitstream_size);
@@ -1007,8 +865,6 @@ static void encode(struct radeon_uvd_encoder *enc)
    enc->total_task_size = 0;
    radeon_uvd_enc_task_info(enc, enc->need_feedback);
 
-   radeon_uvd_enc_nalu_aud_hevc(enc);
-
    if (enc->enc_pic.is_iframe) {
       radeon_uvd_enc_nalu_vps_hevc(enc);
       radeon_uvd_enc_nalu_pps_hevc(enc);
-- 
GitLab


From b7db731a1273791d8aa86c917c366ba9147c1c20 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 12:07:34 +0100
Subject: [PATCH 20/32] radeonsi/uvd_enc: Consider input surface size for
 padding

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c | 13 +-------
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h |  6 +---
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 30 ++++++++++++++++---
 3 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index 02fb45c4d809c..e65ee18923fcc 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -29,18 +29,6 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
    enc->enc_pic.enc_params.reference_picture_index =
       pic->ref_list0[0] == PIPE_H2645_LIST_REF_INVALID_ENTRY ? 0xffffffff : pic->ref_list0[0];
    enc->enc_pic.enc_params.reconstructed_picture_index = pic->dpb_curr_pic;
-
-   if (pic->seq.conformance_window_flag) {
-         enc->enc_pic.crop_left = pic->seq.conf_win_left_offset;
-         enc->enc_pic.crop_right = pic->seq.conf_win_right_offset;
-         enc->enc_pic.crop_top = pic->seq.conf_win_top_offset;
-         enc->enc_pic.crop_bottom = pic->seq.conf_win_bottom_offset;
-   } else {
-         enc->enc_pic.crop_left = 0;
-         enc->enc_pic.crop_right = 0;
-         enc->enc_pic.crop_top = 0;
-         enc->enc_pic.crop_bottom = 0;
-   }
 }
 
 static int flush(struct radeon_uvd_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
@@ -101,6 +89,7 @@ static void radeon_uvd_enc_begin_frame(struct pipe_video_codec *encoder,
    enc->get_buffer(vid_buf->resources[0], &enc->handle, &enc->luma);
    enc->get_buffer(vid_buf->resources[1], NULL, &enc->chroma);
 
+   enc->source = source;
    enc->need_feedback = false;
 
    unsigned dpb_slots = MAX2(pic->seq.sps_max_dec_pic_buffering_minus1[0] + 1, pic->dpb_size);
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index 695008c1d9e10..911ea9191d029 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -314,11 +314,6 @@ struct pipe_video_codec *radeon_uvd_create_encoder(struct pipe_context *context,
 struct radeon_uvd_enc_pic {
    enum pipe_h2645_enc_picture_type picture_type;
    struct pipe_h265_enc_picture_desc *desc;
-
-   unsigned crop_left;
-   unsigned crop_right;
-   unsigned crop_top;
-   unsigned crop_bottom;
    unsigned nal_unit_type;
    unsigned temporal_id;
 
@@ -360,6 +355,7 @@ struct radeon_uvd_encoder {
    struct pb_buffer_lean *handle;
    struct radeon_surf *luma;
    struct radeon_surf *chroma;
+   struct pipe_video_buffer *source;
 
    struct pb_buffer_lean *bs_handle;
    unsigned bs_size;
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 7c4e06700b059..953b65a67bdf5 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -75,15 +75,37 @@ static void radeon_uvd_enc_task_info(struct radeon_uvd_encoder *enc, bool need_f
 
 static void radeon_uvd_enc_session_init_hevc(struct radeon_uvd_encoder *enc)
 {
+   uint32_t padding_width = 0;
+   uint32_t padding_height = 0;
+   uint32_t max_padding_width = 64 - 2;
+   uint32_t max_padding_height = 16 - 2;
+
    enc->enc_pic.session_init.aligned_picture_width = align(enc->base.width, 64);
    enc->enc_pic.session_init.aligned_picture_height = align(enc->base.height, 16);
-   enc->enc_pic.session_init.padding_width =
-      (enc->enc_pic.crop_left + enc->enc_pic.crop_right) * 2;
-   enc->enc_pic.session_init.padding_height =
-      (enc->enc_pic.crop_top + enc->enc_pic.crop_bottom) * 2;
    enc->enc_pic.session_init.pre_encode_mode = RENC_UVD_PREENCODE_MODE_NONE;
    enc->enc_pic.session_init.pre_encode_chroma_enabled = false;
 
+   if (enc->enc_pic.session_init.aligned_picture_width > enc->source->width)
+      padding_width = enc->enc_pic.session_init.aligned_picture_width - enc->source->width;
+   if (enc->enc_pic.session_init.aligned_picture_height > enc->source->height)
+      padding_height = enc->enc_pic.session_init.aligned_picture_height - enc->source->height;
+
+   /* Input surface can be smaller if the difference is within padding bounds. */
+   if (padding_width > max_padding_width || padding_height > max_padding_height)
+      RVID_ERR("Input surface size doesn't match aligned size\n");
+
+   if (enc->enc_pic.desc->seq.conformance_window_flag) {
+      uint32_t pad_w =
+         (enc->enc_pic.desc->seq.conf_win_left_offset + enc->enc_pic.desc->seq.conf_win_right_offset) * 2;
+      uint32_t pad_h =
+         (enc->enc_pic.desc->seq.conf_win_top_offset + enc->enc_pic.desc->seq.conf_win_bottom_offset) * 2;
+      padding_width = CLAMP(pad_w, padding_width, max_padding_width);
+      padding_height = CLAMP(pad_h, padding_height, max_padding_height);
+   }
+
+   enc->enc_pic.session_init.padding_width = padding_width;
+   enc->enc_pic.session_init.padding_height = padding_height;
+
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_SESSION_INIT);
    RADEON_ENC_CS(enc->enc_pic.session_init.aligned_picture_width);
    RADEON_ENC_CS(enc->enc_pic.session_init.aligned_picture_height);
-- 
GitLab


From a9c5f777ae0f4f08c46508b7eb22a82834be66af Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 12:38:19 +0100
Subject: [PATCH 21/32] radeonsi/uvd_enc: Support Pre-Encode

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c | 30 +++++++++++++++++++
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     |  2 --
 2 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index e65ee18923fcc..e2b2a520757e5 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -29,6 +29,10 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
    enc->enc_pic.enc_params.reference_picture_index =
       pic->ref_list0[0] == PIPE_H2645_LIST_REF_INVALID_ENTRY ? 0xffffffff : pic->ref_list0[0];
    enc->enc_pic.enc_params.reconstructed_picture_index = pic->dpb_curr_pic;
+
+   enc->enc_pic.session_init.pre_encode_mode =
+      pic->quality_modes.pre_encode_mode ? RENC_UVD_PREENCODE_MODE_4X : RENC_UVD_PREENCODE_MODE_NONE;
+   enc->enc_pic.session_init.pre_encode_chroma_enabled = !!enc->enc_pic.session_init.pre_encode_mode;
 }
 
 static int flush(struct radeon_uvd_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
@@ -57,6 +61,7 @@ static uint32_t setup_dpb(struct radeon_uvd_encoder *enc, uint32_t num_reconstru
    uint32_t luma_size = align(pitch * MAX2(256, aligned_height), alignment);
    uint32_t chroma_size = align(luma_size / 2, alignment);
    uint32_t offset = 0;
+   uint32_t pre_encode_luma_size, pre_encode_chroma_size;
 
    assert(num_reconstructed_pictures <= RENC_UVD_MAX_NUM_RECONSTRUCTED_PICTURES);
 
@@ -64,11 +69,36 @@ static uint32_t setup_dpb(struct radeon_uvd_encoder *enc, uint32_t num_reconstru
    enc->enc_pic.ctx_buf.rec_chroma_pitch = pitch;
    enc->enc_pic.ctx_buf.num_reconstructed_pictures = num_reconstructed_pictures;
 
+   if (enc->enc_pic.session_init.pre_encode_mode) {
+      uint32_t pre_encode_pitch =
+         align(pitch / enc->enc_pic.session_init.pre_encode_mode, alignment);
+      uint32_t pre_encode_aligned_height =
+         align(aligned_height / enc->enc_pic.session_init.pre_encode_mode, alignment);
+      pre_encode_luma_size =
+         align(pre_encode_pitch * MAX2(256, pre_encode_aligned_height), alignment);
+      pre_encode_chroma_size = align(pre_encode_luma_size / 2, alignment);
+
+      enc->enc_pic.ctx_buf.pre_encode_picture_luma_pitch = pre_encode_pitch;
+      enc->enc_pic.ctx_buf.pre_encode_picture_chroma_pitch = pre_encode_pitch;
+
+      enc->enc_pic.ctx_buf.pre_encode_input_picture.luma_offset = offset;
+      offset += pre_encode_luma_size;
+      enc->enc_pic.ctx_buf.pre_encode_input_picture.chroma_offset = offset;
+      offset += pre_encode_chroma_size;
+   }
+
    for (i = 0; i < num_reconstructed_pictures; i++) {
       enc->enc_pic.ctx_buf.reconstructed_pictures[i].luma_offset = offset;
       offset += luma_size;
       enc->enc_pic.ctx_buf.reconstructed_pictures[i].chroma_offset = offset;
       offset += chroma_size;
+
+      if (enc->enc_pic.session_init.pre_encode_mode) {
+         enc->enc_pic.ctx_buf.pre_encode_reconstructed_pictures[i].luma_offset = offset;
+         offset += pre_encode_luma_size;
+         enc->enc_pic.ctx_buf.pre_encode_reconstructed_pictures[i].chroma_offset = offset;
+         offset += pre_encode_chroma_size;
+      }
    }
 
    enc->dpb_slots = num_reconstructed_pictures;
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 953b65a67bdf5..1f98fc9a34fe8 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -82,8 +82,6 @@ static void radeon_uvd_enc_session_init_hevc(struct radeon_uvd_encoder *enc)
 
    enc->enc_pic.session_init.aligned_picture_width = align(enc->base.width, 64);
    enc->enc_pic.session_init.aligned_picture_height = align(enc->base.height, 16);
-   enc->enc_pic.session_init.pre_encode_mode = RENC_UVD_PREENCODE_MODE_NONE;
-   enc->enc_pic.session_init.pre_encode_chroma_enabled = false;
 
    if (enc->enc_pic.session_init.aligned_picture_width > enc->source->width)
       padding_width = enc->enc_pic.session_init.aligned_picture_width - enc->source->width;
-- 
GitLab


From 84190253e1b76de385f6cb7580ab1b2fd82fb9ee Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 12:40:30 +0100
Subject: [PATCH 22/32] radeonsi/uvd_enc: Support VBAQ

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c     | 3 +++
 src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c | 1 -
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index e2b2a520757e5..2c8696255fe58 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -33,6 +33,9 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
    enc->enc_pic.session_init.pre_encode_mode =
       pic->quality_modes.pre_encode_mode ? RENC_UVD_PREENCODE_MODE_4X : RENC_UVD_PREENCODE_MODE_NONE;
    enc->enc_pic.session_init.pre_encode_chroma_enabled = !!enc->enc_pic.session_init.pre_encode_mode;
+   enc->enc_pic.quality_params.vbaq_mode =
+      pic->rc[0].rate_ctrl_method != PIPE_H2645_ENC_RATE_CONTROL_METHOD_DISABLE &&
+      pic->quality_modes.vbaq_mode;
 }
 
 static int flush(struct radeon_uvd_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 1f98fc9a34fe8..90eef80faf491 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -256,7 +256,6 @@ static void radeon_uvd_enc_deblocking_filter_hevc(struct radeon_uvd_encoder *enc
 
 static void radeon_uvd_enc_quality_params(struct radeon_uvd_encoder *enc)
 {
-   enc->enc_pic.quality_params.vbaq_mode = 0;
    enc->enc_pic.quality_params.scene_change_sensitivity = 0;
    enc->enc_pic.quality_params.scene_change_min_idr_interval = 0;
 
-- 
GitLab


From 25d94a0e02a79f437747ab99e48af81564a39bfe Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 12:47:13 +0100
Subject: [PATCH 23/32] radeonsi/uvd_enc: Support quality presets

---
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 21 ++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 90eef80faf491..72c1d51f0e96c 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -848,9 +848,24 @@ static void radeon_uvd_enc_op_init_rc_vbv(struct radeon_uvd_encoder *enc)
    RADEON_ENC_END();
 }
 
-static void radeon_uvd_enc_op_speed(struct radeon_uvd_encoder *enc)
+static void radeon_uvd_enc_op_preset(struct radeon_uvd_encoder *enc)
 {
-   RADEON_ENC_BEGIN(RENC_UVD_IB_OP_SET_SPEED_ENCODING_MODE);
+   uint32_t preset_mode;
+
+   switch (enc->enc_pic.desc->quality_modes.preset_mode) {
+   case 0: /* SPEED */
+      preset_mode = RENC_UVD_IB_OP_SET_SPEED_ENCODING_MODE;
+      break;
+   case 1: /* BALANCED */
+      preset_mode = RENC_UVD_IB_OP_SET_BALANCE_ENCODING_MODE;
+      break;
+   case 2: /* QUALITY */
+   default:
+      preset_mode = RENC_UVD_IB_OP_SET_QUALITY_ENCODING_MODE;
+      break;
+   }
+
+   RADEON_ENC_BEGIN(preset_mode);
    RADEON_ENC_END();
 }
 
@@ -897,7 +912,7 @@ static void encode(struct radeon_uvd_encoder *enc)
    radeon_uvd_enc_feedback(enc);
    radeon_uvd_enc_intra_refresh(enc);
 
-   radeon_uvd_enc_op_speed(enc);
+   radeon_uvd_enc_op_preset(enc);
    radeon_uvd_enc_op_enc(enc);
    *enc->p_task_size = (enc->total_task_size);
 }
-- 
GitLab


From d4ea3ee636aa526046ca392d82bc9ddcd0305588 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 15:02:13 +0100
Subject: [PATCH 24/32] radeonsi/uvd_enc: Support slice encoding

---
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 39 ++++++++++++++++---
 1 file changed, 34 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 72c1d51f0e96c..465ff25a0a000 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -134,13 +134,42 @@ static void radeon_uvd_enc_layer_select(struct radeon_uvd_encoder *enc)
    RADEON_ENC_END();
 }
 
-static void radeon_uvd_enc_slice_control_hevc(struct radeon_uvd_encoder *enc)
+static void radeon_uvd_enc_slice_control_hevc(struct radeon_uvd_encoder *enc,
+                                              struct pipe_picture_desc *picture)
 {
+   struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
+   uint32_t num_ctbs_total, num_ctbs_in_slice;
+
+   num_ctbs_total =
+      DIV_ROUND_UP(enc->base.width, 64) * DIV_ROUND_UP(enc->base.height, 64);
+
+   if (pic->num_slice_descriptors <= 1) {
+      num_ctbs_in_slice = num_ctbs_total;
+   } else {
+      bool use_app_config = true;
+      num_ctbs_in_slice = pic->slices_descriptors[0].num_ctu_in_slice;
+
+      /* All slices must have equal size */
+      for (unsigned i = 1; i < pic->num_slice_descriptors - 1; i++) {
+         if (num_ctbs_in_slice != pic->slices_descriptors[i].num_ctu_in_slice)
+            use_app_config = false;
+      }
+      /* Except last one can be smaller */
+      if (pic->slices_descriptors[pic->num_slice_descriptors - 1].num_ctu_in_slice > num_ctbs_in_slice)
+         use_app_config = false;
+
+      if (!use_app_config) {
+         assert(num_ctbs_total >= pic->num_slice_descriptors);
+         num_ctbs_in_slice =
+            (num_ctbs_total + pic->num_slice_descriptors - 1) / pic->num_slice_descriptors;
+      }
+   }
+
    enc->enc_pic.hevc_slice_ctrl.slice_control_mode = RENC_UVD_SLICE_CONTROL_MODE_FIXED_CTBS;
    enc->enc_pic.hevc_slice_ctrl.fixed_ctbs_per_slice.num_ctbs_per_slice =
-      align(enc->base.width, 64) / 64 * align(enc->base.height, 64) / 64;
+      num_ctbs_in_slice;
    enc->enc_pic.hevc_slice_ctrl.fixed_ctbs_per_slice.num_ctbs_per_slice_segment =
-      enc->enc_pic.hevc_slice_ctrl.fixed_ctbs_per_slice.num_ctbs_per_slice;
+      num_ctbs_in_slice;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_SLICE_CONTROL);
    RADEON_ENC_CS(enc->enc_pic.hevc_slice_ctrl.slice_control_mode);
@@ -236,7 +265,7 @@ static void radeon_uvd_enc_deblocking_filter_hevc(struct radeon_uvd_encoder *enc
 {
    struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
    enc->enc_pic.hevc_deblock.loop_filter_across_slices_enabled =
-      pic->slice.slice_loop_filter_across_slices_enabled_flag;
+      pic->pic.pps_loop_filter_across_slices_enabled_flag;
    enc->enc_pic.hevc_deblock.deblocking_filter_disabled =
       pic->slice.slice_deblocking_filter_disabled_flag;
    enc->enc_pic.hevc_deblock.beta_offset_div2 = pic->slice.slice_beta_offset_div2;
@@ -877,7 +906,7 @@ static void begin(struct radeon_uvd_encoder *enc, struct pipe_picture_desc *pic)
    radeon_uvd_enc_op_init(enc);
 
    radeon_uvd_enc_session_init_hevc(enc);
-   radeon_uvd_enc_slice_control_hevc(enc);
+   radeon_uvd_enc_slice_control_hevc(enc, pic);
    radeon_uvd_enc_spec_misc_hevc(enc, pic);
    radeon_uvd_enc_deblocking_filter_hevc(enc, pic);
 
-- 
GitLab


From 5c471235dbc84a6b55e92848fb26a80df4d6b0ef Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 16:13:35 +0100
Subject: [PATCH 25/32] radeonsi/uvd_enc: Support intra refresh

---
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 20 ++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 465ff25a0a000..a4d8f6a5a69d6 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -759,9 +759,23 @@ static void radeon_uvd_enc_feedback(struct radeon_uvd_encoder *enc)
 
 static void radeon_uvd_enc_intra_refresh(struct radeon_uvd_encoder *enc)
 {
-   enc->enc_pic.intra_ref.intra_refresh_mode = RENC_UVD_INTRA_REFRESH_MODE_NONE;
-   enc->enc_pic.intra_ref.offset = 0;
-   enc->enc_pic.intra_ref.region_size = 0;
+   switch (enc->enc_pic.desc->intra_refresh.mode) {
+   case INTRA_REFRESH_MODE_UNIT_ROWS:
+      enc->enc_pic.intra_ref.intra_refresh_mode = RENC_UVD_INTRA_REFRESH_MODE_CTB_MB_ROWS;
+      break;
+   case INTRA_REFRESH_MODE_UNIT_COLUMNS:
+      enc->enc_pic.intra_ref.intra_refresh_mode = RENC_UVD_INTRA_REFRESH_MODE_CTB_MB_COLUMNS;
+      break;
+   default:
+      enc->enc_pic.intra_ref.intra_refresh_mode = RENC_UVD_INTRA_REFRESH_MODE_NONE;
+      break;
+   };
+
+   enc->enc_pic.intra_ref.offset = enc->enc_pic.desc->intra_refresh.offset;
+   enc->enc_pic.intra_ref.region_size = enc->enc_pic.desc->intra_refresh.region_size;
+
+   if (!enc->enc_pic.hevc_deblock.deblocking_filter_disabled)
+      enc->enc_pic.intra_ref.region_size++;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INTRA_REFRESH);
    RADEON_ENC_CS(enc->enc_pic.intra_ref.intra_refresh_mode);
-- 
GitLab


From 0df4585d0097baf839177e396bab9fb2c774490c Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 16:34:55 +0100
Subject: [PATCH 26/32] radeonsi/uvd_enc: Support temporal layer rate control

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c | 20 ++++++-
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h |  2 +-
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 54 ++++++++-----------
 3 files changed, 42 insertions(+), 34 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index 2c8696255fe58..c5c0facc5f5ec 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -23,7 +23,6 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
    enc->enc_pic.desc = pic;
    enc->enc_pic.picture_type = pic->picture_type;
    enc->enc_pic.nal_unit_type = pic->pic.nal_unit_type;
-   enc->enc_pic.temporal_id = pic->pic.temporal_id;
    enc->enc_pic.is_iframe = (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) ||
                             (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_I);
    enc->enc_pic.enc_params.reference_picture_index =
@@ -36,6 +35,25 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
    enc->enc_pic.quality_params.vbaq_mode =
       pic->rc[0].rate_ctrl_method != PIPE_H2645_ENC_RATE_CONTROL_METHOD_DISABLE &&
       pic->quality_modes.vbaq_mode;
+
+   enc->enc_pic.layer_ctrl.num_temporal_layers = pic->seq.num_temporal_layers ? pic->seq.num_temporal_layers : 1;
+   enc->enc_pic.layer_ctrl.max_num_temporal_layers = enc->enc_pic.layer_ctrl.num_temporal_layers;
+   enc->enc_pic.temporal_id = MIN2(pic->pic.temporal_id, enc->enc_pic.layer_ctrl.num_temporal_layers - 1);
+
+   for (uint32_t i = 0; i < enc->enc_pic.layer_ctrl.num_temporal_layers; i++) {
+      enc->enc_pic.rc_layer_init[i].target_bit_rate = pic->rc[i].target_bitrate;
+      enc->enc_pic.rc_layer_init[i].peak_bit_rate = pic->rc[i].peak_bitrate;
+      enc->enc_pic.rc_layer_init[i].frame_rate_num = pic->rc[i].frame_rate_num;
+      enc->enc_pic.rc_layer_init[i].frame_rate_den = pic->rc[i].frame_rate_den;
+      enc->enc_pic.rc_layer_init[i].vbv_buffer_size = pic->rc[i].vbv_buffer_size;
+      enc->enc_pic.rc_layer_init[i].avg_target_bits_per_picture =
+         pic->rc[i].target_bitrate * ((float)pic->rc[i].frame_rate_den / pic->rc[i].frame_rate_num);
+      enc->enc_pic.rc_layer_init[i].peak_bits_per_picture_integer =
+         pic->rc[i].peak_bitrate * ((float)pic->rc[i].frame_rate_den / pic->rc[i].frame_rate_num);
+      enc->enc_pic.rc_layer_init[i].peak_bits_per_picture_fractional =
+         (((pic->rc[i].peak_bitrate * (uint64_t)pic->rc[i].frame_rate_den) % pic->rc[i].frame_rate_num) << 32) /
+         pic->rc[i].frame_rate_num;
+   }
 }
 
 static int flush(struct radeon_uvd_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index 911ea9191d029..bed56a7eaefb7 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -326,7 +326,7 @@ struct radeon_uvd_enc_pic {
    ruvd_enc_hevc_slice_control_t hevc_slice_ctrl;
    ruvd_enc_hevc_spec_misc_t hevc_spec_misc;
    ruvd_enc_rate_ctl_session_init_t rc_session_init;
-   ruvd_enc_rate_ctl_layer_init_t rc_layer_init;
+   ruvd_enc_rate_ctl_layer_init_t rc_layer_init[4];
    ruvd_enc_hevc_deblocking_filter_t hevc_deblock;
    ruvd_enc_rate_ctl_per_picture_t rc_per_pic;
    ruvd_enc_quality_params_t quality_params;
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index a4d8f6a5a69d6..fc294dc6d20ac 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -116,9 +116,6 @@ static void radeon_uvd_enc_session_init_hevc(struct radeon_uvd_encoder *enc)
 
 static void radeon_uvd_enc_layer_control(struct radeon_uvd_encoder *enc)
 {
-   enc->enc_pic.layer_ctrl.max_num_temporal_layers = 1;
-   enc->enc_pic.layer_ctrl.num_temporal_layers = 1;
-
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_LAYER_CONTROL);
    RADEON_ENC_CS(enc->enc_pic.layer_ctrl.max_num_temporal_layers);
    RADEON_ENC_CS(enc->enc_pic.layer_ctrl.num_temporal_layers);
@@ -127,8 +124,6 @@ static void radeon_uvd_enc_layer_control(struct radeon_uvd_encoder *enc)
 
 static void radeon_uvd_enc_layer_select(struct radeon_uvd_encoder *enc)
 {
-   enc->enc_pic.layer_sel.temporal_layer_index = 0;
-
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_LAYER_SELECT);
    RADEON_ENC_CS(enc->enc_pic.layer_sel.temporal_layer_index);
    RADEON_ENC_END();
@@ -231,32 +226,19 @@ static void radeon_uvd_enc_rc_session_init(struct radeon_uvd_encoder *enc,
    RADEON_ENC_END();
 }
 
-static void radeon_uvd_enc_rc_layer_init(struct radeon_uvd_encoder *enc,
-                                         struct pipe_picture_desc *picture)
+static void radeon_uvd_enc_rc_layer_init(struct radeon_uvd_encoder *enc)
 {
-   struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
-   enc->enc_pic.rc_layer_init.target_bit_rate = pic->rc[0].target_bitrate;
-   enc->enc_pic.rc_layer_init.peak_bit_rate = pic->rc[0].peak_bitrate;
-   enc->enc_pic.rc_layer_init.frame_rate_num = pic->rc[0].frame_rate_num;
-   enc->enc_pic.rc_layer_init.frame_rate_den = pic->rc[0].frame_rate_den;
-   enc->enc_pic.rc_layer_init.vbv_buffer_size = pic->rc[0].vbv_buffer_size;
-   enc->enc_pic.rc_layer_init.avg_target_bits_per_picture =
-      pic->rc[0].target_bitrate * ((float)pic->rc[0].frame_rate_den / pic->rc[0].frame_rate_num);
-   enc->enc_pic.rc_layer_init.peak_bits_per_picture_integer =
-      pic->rc[0].peak_bitrate * ((float)pic->rc[0].frame_rate_den / pic->rc[0].frame_rate_num);
-   enc->enc_pic.rc_layer_init.peak_bits_per_picture_fractional =
-      (((pic->rc[0].peak_bitrate * (uint64_t)pic->rc[0].frame_rate_den) % pic->rc[0].frame_rate_num) << 32) /
-      pic->rc[0].frame_rate_num;
+   uint32_t i = enc->enc_pic.layer_sel.temporal_layer_index;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_RATE_CONTROL_LAYER_INIT);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.target_bit_rate);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.peak_bit_rate);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.frame_rate_num);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.frame_rate_den);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.vbv_buffer_size);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.avg_target_bits_per_picture);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.peak_bits_per_picture_integer);
-   RADEON_ENC_CS(enc->enc_pic.rc_layer_init.peak_bits_per_picture_fractional);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].target_bit_rate);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].peak_bit_rate);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].frame_rate_num);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].frame_rate_den);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].vbv_buffer_size);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].avg_target_bits_per_picture);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].peak_bits_per_picture_integer);
+   RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].peak_bits_per_picture_fractional);
    RADEON_ENC_END();
 }
 
@@ -927,10 +909,15 @@ static void begin(struct radeon_uvd_encoder *enc, struct pipe_picture_desc *pic)
    radeon_uvd_enc_layer_control(enc);
    radeon_uvd_enc_rc_session_init(enc, pic);
    radeon_uvd_enc_quality_params(enc);
-   radeon_uvd_enc_layer_select(enc);
-   radeon_uvd_enc_rc_layer_init(enc, pic);
-   radeon_uvd_enc_layer_select(enc);
-   radeon_uvd_enc_rc_per_pic(enc, pic);
+
+   for (uint32_t i = 0; i < enc->enc_pic.layer_ctrl.num_temporal_layers; i++) {
+      enc->enc_pic.layer_sel.temporal_layer_index = i;
+      radeon_uvd_enc_layer_select(enc);
+      radeon_uvd_enc_rc_layer_init(enc);
+      radeon_uvd_enc_layer_select(enc);
+      radeon_uvd_enc_rc_per_pic(enc, pic);
+   }
+
    radeon_uvd_enc_op_init_rc(enc);
    radeon_uvd_enc_op_init_rc_vbv(enc);
    *enc->p_task_size = (enc->total_task_size);
@@ -942,6 +929,9 @@ static void encode(struct radeon_uvd_encoder *enc)
    enc->total_task_size = 0;
    radeon_uvd_enc_task_info(enc, enc->need_feedback);
 
+   enc->enc_pic.layer_sel.temporal_layer_index = enc->enc_pic.temporal_id;
+   radeon_uvd_enc_layer_select(enc);
+
    if (enc->enc_pic.is_iframe) {
       radeon_uvd_enc_nalu_vps_hevc(enc);
       radeon_uvd_enc_nalu_pps_hevc(enc);
-- 
GitLab


From 23861445d388eccd27321f8c14ba3e9b42a006e2 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 16:36:47 +0100
Subject: [PATCH 27/32] radeonsi/uvd_enc: Support min/max QP and max frame size

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index fc294dc6d20ac..00e694403f633 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -771,9 +771,9 @@ static void radeon_uvd_enc_rc_per_pic(struct radeon_uvd_encoder *enc,
 {
    struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
    enc->enc_pic.rc_per_pic.qp = pic->rc[0].quant_i_frames;
-   enc->enc_pic.rc_per_pic.min_qp_app = 0;
-   enc->enc_pic.rc_per_pic.max_qp_app = 51;
-   enc->enc_pic.rc_per_pic.max_au_size = 0;
+   enc->enc_pic.rc_per_pic.min_qp_app = pic->rc[0].min_qp;
+   enc->enc_pic.rc_per_pic.max_qp_app = pic->rc[0].max_qp ? pic->rc[0].max_qp : 51;
+   enc->enc_pic.rc_per_pic.max_au_size = pic->rc[0].max_au_size;
    enc->enc_pic.rc_per_pic.enabled_filler_data = pic->rc[0].fill_data_enable;
    enc->enc_pic.rc_per_pic.skip_frame_enable = false;
    enc->enc_pic.rc_per_pic.enforce_hrd = pic->rc[0].enforce_hrd;
-- 
GitLab


From 9e18d65d65ea844969126c44a86e9da76282fd1e Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Tue, 31 Dec 2024 17:11:42 +0100
Subject: [PATCH 28/32] radeonsi/uvd_enc: Support dynamic rate control changes

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c | 16 ++++++++++++
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h |  2 ++
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     | 25 ++++++++++---------
 3 files changed, 31 insertions(+), 12 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index c5c0facc5f5ec..41de0d43197d1 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -54,6 +54,13 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
          (((pic->rc[i].peak_bitrate * (uint64_t)pic->rc[i].frame_rate_den) % pic->rc[i].frame_rate_num) << 32) /
          pic->rc[i].frame_rate_num;
    }
+   enc->enc_pic.rc_per_pic.qp = pic->rc[0].quant_i_frames;
+   enc->enc_pic.rc_per_pic.min_qp_app = pic->rc[0].min_qp;
+   enc->enc_pic.rc_per_pic.max_qp_app = pic->rc[0].max_qp ? pic->rc[0].max_qp : 51;
+   enc->enc_pic.rc_per_pic.max_au_size = pic->rc[0].max_au_size;
+   enc->enc_pic.rc_per_pic.enabled_filler_data = pic->rc[0].fill_data_enable;
+   enc->enc_pic.rc_per_pic.skip_frame_enable = false;
+   enc->enc_pic.rc_per_pic.enforce_hrd = pic->rc[0].enforce_hrd;
 }
 
 static int flush(struct radeon_uvd_encoder *enc, unsigned flags, struct pipe_fence_handle **fence)
@@ -135,6 +142,15 @@ static void radeon_uvd_enc_begin_frame(struct pipe_video_codec *encoder,
    struct vl_video_buffer *vid_buf = (struct vl_video_buffer *)source;
    struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
 
+   enc->need_rate_control =
+      (enc->enc_pic.rc_layer_init[0].target_bit_rate != pic->rc[0].target_bitrate) ||
+      (enc->enc_pic.rc_layer_init[0].frame_rate_num != pic->rc[0].frame_rate_num) ||
+      (enc->enc_pic.rc_layer_init[0].frame_rate_den != pic->rc[0].frame_rate_den);
+
+   enc->need_rc_per_pic =
+      (enc->enc_pic.rc_per_pic.qp != pic->rc[0].quant_i_frames) ||
+      (enc->enc_pic.rc_per_pic.max_au_size != pic->rc[0].max_au_size);
+
    radeon_uvd_enc_get_param(enc, pic);
 
    enc->get_buffer(vid_buf->resources[0], &enc->handle, &enc->luma);
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index bed56a7eaefb7..821e25eb03600 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -371,6 +371,8 @@ struct radeon_uvd_encoder {
    uint32_t *p_task_size;
 
    bool need_feedback;
+   bool need_rate_control;
+   bool need_rc_per_pic;
 };
 
 struct si_screen;
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 00e694403f633..db810ba92b3a5 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -766,18 +766,8 @@ static void radeon_uvd_enc_intra_refresh(struct radeon_uvd_encoder *enc)
    RADEON_ENC_END();
 }
 
-static void radeon_uvd_enc_rc_per_pic(struct radeon_uvd_encoder *enc,
-                                      struct pipe_picture_desc *picture)
+static void radeon_uvd_enc_rc_per_pic(struct radeon_uvd_encoder *enc)
 {
-   struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
-   enc->enc_pic.rc_per_pic.qp = pic->rc[0].quant_i_frames;
-   enc->enc_pic.rc_per_pic.min_qp_app = pic->rc[0].min_qp;
-   enc->enc_pic.rc_per_pic.max_qp_app = pic->rc[0].max_qp ? pic->rc[0].max_qp : 51;
-   enc->enc_pic.rc_per_pic.max_au_size = pic->rc[0].max_au_size;
-   enc->enc_pic.rc_per_pic.enabled_filler_data = pic->rc[0].fill_data_enable;
-   enc->enc_pic.rc_per_pic.skip_frame_enable = false;
-   enc->enc_pic.rc_per_pic.enforce_hrd = pic->rc[0].enforce_hrd;
-
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_RATE_CONTROL_PER_PICTURE);
    RADEON_ENC_CS(enc->enc_pic.rc_per_pic.qp);
    RADEON_ENC_CS(enc->enc_pic.rc_per_pic.min_qp_app);
@@ -915,7 +905,7 @@ static void begin(struct radeon_uvd_encoder *enc, struct pipe_picture_desc *pic)
       radeon_uvd_enc_layer_select(enc);
       radeon_uvd_enc_rc_layer_init(enc);
       radeon_uvd_enc_layer_select(enc);
-      radeon_uvd_enc_rc_per_pic(enc, pic);
+      radeon_uvd_enc_rc_per_pic(enc);
    }
 
    radeon_uvd_enc_op_init_rc(enc);
@@ -929,6 +919,17 @@ static void encode(struct radeon_uvd_encoder *enc)
    enc->total_task_size = 0;
    radeon_uvd_enc_task_info(enc, enc->need_feedback);
 
+   if (enc->need_rate_control || enc->need_rc_per_pic) {
+      for (uint32_t i = 0; i < enc->enc_pic.layer_ctrl.num_temporal_layers; i++) {
+         enc->enc_pic.layer_sel.temporal_layer_index = i;
+         radeon_uvd_enc_layer_select(enc);
+         if (enc->need_rate_control)
+            radeon_uvd_enc_rc_layer_init(enc);
+         if (enc->need_rc_per_pic)
+            radeon_uvd_enc_rc_per_pic(enc);
+      }
+   }
+
    enc->enc_pic.layer_sel.temporal_layer_index = enc->enc_pic.temporal_id;
    radeon_uvd_enc_layer_select(enc);
 
-- 
GitLab


From 70468a85b1bab9e30a7babfd7950036b5949f0d6 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Thu, 2 Jan 2025 09:45:41 +0100
Subject: [PATCH 29/32] radeonsi/uvd_enc: Support encode latency

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h     |  6 ++++++
 src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c | 13 +++++++++++++
 2 files changed, 19 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index 821e25eb03600..74cbf32a1c2d8 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -34,6 +34,7 @@
 #define RENC_UVD_IB_PARAM_FEEDBACK_BUFFER            0x00000012
 #define RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER         0x00000013
 #define RENC_UVD_IB_PARAM_FEEDBACK_BUFFER_ADDITIONAL 0x00000014
+#define RENC_UVD_IB_PARAM_ENCODE_LATENCY             0x00000015
 
 #define RENC_UVD_IB_OP_INITIALIZE                0x08000001
 #define RENC_UVD_IB_OP_CLOSE_SESSION             0x08000002
@@ -303,6 +304,10 @@ typedef struct ruvd_enc_feedback_buffer_s {
    uint32_t feedback_data_size;
 } ruvd_enc_feedback_buffer_t;
 
+typedef struct ruvd_enc_encode_latency_s {
+   uint32_t encode_latency;
+} ruvd_enc_encode_latency_t;
+
 typedef void (*radeon_uvd_enc_get_buffer)(struct pipe_resource *resource, struct pb_buffer_lean **handle,
                                           struct radeon_surf **surface);
 
@@ -335,6 +340,7 @@ struct radeon_uvd_enc_pic {
    ruvd_enc_feedback_buffer_t fb_buf;
    ruvd_enc_intra_refresh_t intra_ref;
    ruvd_enc_encode_params_t enc_params;
+   ruvd_enc_encode_latency_t enc_latency;
 };
 
 struct radeon_uvd_encoder {
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index db810ba92b3a5..ce1d6509b876d 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -277,6 +277,13 @@ static void radeon_uvd_enc_quality_params(struct radeon_uvd_encoder *enc)
    RADEON_ENC_END();
 }
 
+static void radeon_uvd_enc_encode_latency(struct radeon_uvd_encoder *enc)
+{
+   RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_ENCODE_LATENCY);
+   RADEON_ENC_CS(enc->enc_pic.enc_latency.encode_latency);
+   RADEON_ENC_END();
+}
+
 static void radeon_uvd_enc_nalu_sps_hevc(struct radeon_uvd_encoder *enc)
 {
    struct radeon_bitstream bs;
@@ -899,6 +906,7 @@ static void begin(struct radeon_uvd_encoder *enc, struct pipe_picture_desc *pic)
    radeon_uvd_enc_layer_control(enc);
    radeon_uvd_enc_rc_session_init(enc, pic);
    radeon_uvd_enc_quality_params(enc);
+   radeon_uvd_enc_encode_latency(enc);
 
    for (uint32_t i = 0; i < enc->enc_pic.layer_ctrl.num_temporal_layers; i++) {
       enc->enc_pic.layer_sel.temporal_layer_index = i;
@@ -962,7 +970,12 @@ static void destroy(struct radeon_uvd_encoder *enc)
 
 void radeon_uvd_enc_1_1_init(struct radeon_uvd_encoder *enc)
 {
+   struct si_screen *sscreen = (struct si_screen *)enc->screen;
+
    enc->begin = begin;
    enc->encode = encode;
    enc->destroy = destroy;
+
+   enc->enc_pic.enc_latency.encode_latency =
+      sscreen->debug_flags & DBG(LOW_LATENCY_ENCODE) ? 1000 : 0;
 }
-- 
GitLab


From 9668fe80c560a7bd6f765989775458cfcdac3c42 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Wed, 1 Jan 2025 13:58:13 +0100
Subject: [PATCH 30/32] radeonsi/uvd_enc: Support raw packed headers

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc.c | 119 ++++++++++++++++--
 src/gallium/drivers/radeonsi/radeon_uvd_enc.h |  18 ++-
 .../drivers/radeonsi/radeon_uvd_enc_1_1.c     |  45 ++-----
 3 files changed, 135 insertions(+), 47 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
index 41de0d43197d1..816c320fdb4c2 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.c
@@ -23,8 +23,6 @@ static void radeon_uvd_enc_get_param(struct radeon_uvd_encoder *enc,
    enc->enc_pic.desc = pic;
    enc->enc_pic.picture_type = pic->picture_type;
    enc->enc_pic.nal_unit_type = pic->pic.nal_unit_type;
-   enc->enc_pic.is_iframe = (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) ||
-                            (pic->picture_type == PIPE_H2645_ENC_PICTURE_TYPE_I);
    enc->enc_pic.enc_params.reference_picture_index =
       pic->ref_list0[0] == PIPE_H2645_LIST_REF_INVALID_ENTRY ? 0xffffffff : pic->ref_list0[0];
    enc->enc_pic.enc_params.reconstructed_picture_index = pic->dpb_curr_pic;
@@ -187,6 +185,79 @@ static void radeon_uvd_enc_begin_frame(struct pipe_video_codec *encoder,
    }
 }
 
+static void *radeon_uvd_enc_encode_headers(struct radeon_uvd_encoder *enc)
+{
+   unsigned num_slices = 0, num_headers = 0;
+
+   util_dynarray_foreach(&enc->enc_pic.desc->raw_headers, struct pipe_enc_raw_header, header) {
+      if (header->is_slice)
+         num_slices++;
+      num_headers++;
+   }
+
+   if (!num_headers || !num_slices || num_headers == num_slices)
+      return NULL;
+
+   size_t segments_size =
+      sizeof(struct ruvd_enc_output_unit_segment) * (num_headers - num_slices + 1);
+   struct ruvd_enc_feedback_data *data =
+      CALLOC_VARIANT_LENGTH_STRUCT(ruvd_enc_feedback_data, segments_size);
+   if (!data)
+      return NULL;
+
+   uint8_t *ptr = enc->ws->buffer_map(enc->ws, enc->bs_handle, &enc->cs,
+                                      PIPE_MAP_WRITE | RADEON_MAP_TEMPORARY);
+   if (!ptr) {
+      RVID_ERR("Can't map bs buffer.\n");
+      FREE(data);
+      return NULL;
+   }
+
+   unsigned offset = 0;
+   struct ruvd_enc_output_unit_segment *slice_segment = NULL;
+
+   util_dynarray_foreach(&enc->enc_pic.desc->raw_headers, struct pipe_enc_raw_header, header) {
+      if (header->is_slice) {
+         if (slice_segment)
+            continue;
+         slice_segment = &data->segments[data->num_segments];
+         slice_segment->is_slice = true;
+      } else {
+         unsigned size;
+         switch (header->type) {
+         case PIPE_H265_NAL_VPS:
+            size = radeon_uvd_enc_write_vps(enc, ptr + offset);
+            break;
+         case PIPE_H265_NAL_SPS:
+            size = radeon_uvd_enc_write_sps(enc, ptr + offset);
+            break;
+         case PIPE_H265_NAL_PPS:
+            size = radeon_uvd_enc_write_pps(enc, ptr + offset);
+            break;
+         default:
+            assert(header->buffer);
+            memcpy(ptr + offset, header->buffer, header->size);
+            size = header->size;
+            break;
+         }
+         data->segments[data->num_segments].size = size;
+         data->segments[data->num_segments].offset = offset;
+         offset += size;
+      }
+      data->num_segments++;
+   }
+
+   enc->bs_offset = align(offset, 16);
+   assert(enc->bs_offset < enc->bs_size);
+
+   assert(slice_segment);
+   slice_segment->offset = enc->bs_offset;
+
+   enc->ws->buffer_unmap(enc->ws, enc->bs_handle);
+
+   return data;
+}
+
 static void radeon_uvd_enc_encode_bitstream(struct pipe_video_codec *encoder,
                                             struct pipe_video_buffer *source,
                                             struct pipe_resource *destination, void **fb)
@@ -194,6 +265,7 @@ static void radeon_uvd_enc_encode_bitstream(struct pipe_video_codec *encoder,
    struct radeon_uvd_encoder *enc = (struct radeon_uvd_encoder *)encoder;
    enc->get_buffer(destination, &enc->bs_handle, NULL);
    enc->bs_size = destination->width0;
+   enc->bs_offset = 0;
 
    *fb = enc->fb = CALLOC_STRUCT(rvid_buffer);
 
@@ -202,6 +274,8 @@ static void radeon_uvd_enc_encode_bitstream(struct pipe_video_codec *encoder,
       return;
    }
 
+   enc->fb->user_data = radeon_uvd_enc_encode_headers(enc);
+
    enc->need_feedback = true;
    enc->encode(enc);
 }
@@ -244,15 +318,38 @@ static void radeon_uvd_enc_get_feedback(struct pipe_video_codec *encoder, void *
    struct radeon_uvd_encoder *enc = (struct radeon_uvd_encoder *)encoder;
    struct rvid_buffer *fb = feedback;
 
-   if (NULL != size) {
-      radeon_uvd_enc_feedback_t *fb_data = (radeon_uvd_enc_feedback_t *)enc->ws->buffer_map(
-         enc->ws, fb->res->buf, &enc->cs, PIPE_MAP_READ_WRITE | RADEON_MAP_TEMPORARY);
-
-      if (!fb_data->status)
-         *size = fb_data->bitstream_size;
-      else
-         *size = 0;
-      enc->ws->buffer_unmap(enc->ws, fb->res->buf);
+   radeon_uvd_enc_feedback_t *fb_data = (radeon_uvd_enc_feedback_t *)enc->ws->buffer_map(
+      enc->ws, fb->res->buf, &enc->cs, PIPE_MAP_READ_WRITE | RADEON_MAP_TEMPORARY);
+
+   if (!fb_data->status)
+      *size = fb_data->bitstream_size;
+   else
+      *size = 0;
+
+   enc->ws->buffer_unmap(enc->ws, fb->res->buf);
+
+   metadata->present_metadata = PIPE_VIDEO_FEEDBACK_METADATA_TYPE_CODEC_UNIT_LOCATION;
+
+   if (fb->user_data) {
+      struct ruvd_enc_feedback_data *data = fb->user_data;
+      metadata->codec_unit_metadata_count = data->num_segments;
+      for (unsigned i = 0; i < data->num_segments; i++) {
+         metadata->codec_unit_metadata[i].offset = data->segments[i].offset;
+         if (data->segments[i].is_slice) {
+            metadata->codec_unit_metadata[i].size = *size;
+            metadata->codec_unit_metadata[i].flags = 0;
+         } else {
+            metadata->codec_unit_metadata[i].size = data->segments[i].size;
+            metadata->codec_unit_metadata[i].flags = PIPE_VIDEO_CODEC_UNIT_LOCATION_FLAG_SINGLE_NALU;
+         }
+      }
+      FREE(fb->user_data);
+      fb->user_data = NULL;
+   } else {
+      metadata->codec_unit_metadata_count = 1;
+      metadata->codec_unit_metadata[0].offset = 0;
+      metadata->codec_unit_metadata[0].size = *size;
+      metadata->codec_unit_metadata[0].flags = 0;
    }
 
    si_vid_destroy_buffer(fb);
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
index 74cbf32a1c2d8..01c4b636e3364 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc.h
@@ -322,8 +322,6 @@ struct radeon_uvd_enc_pic {
    unsigned nal_unit_type;
    unsigned temporal_id;
 
-   bool is_iframe;
-
    ruvd_enc_task_info_t task_info;
    ruvd_enc_session_init_t session_init;
    ruvd_enc_layer_control_t layer_ctrl;
@@ -365,6 +363,7 @@ struct radeon_uvd_encoder {
 
    struct pb_buffer_lean *bs_handle;
    unsigned bs_size;
+   unsigned bs_offset;
 
    unsigned dpb_slots;
 
@@ -381,9 +380,24 @@ struct radeon_uvd_encoder {
    bool need_rc_per_pic;
 };
 
+struct ruvd_enc_output_unit_segment {
+   bool is_slice;
+   unsigned size;
+   unsigned offset;
+};
+
+struct ruvd_enc_feedback_data {
+   unsigned num_segments;
+   struct ruvd_enc_output_unit_segment segments[];
+};
+
 struct si_screen;
 
 void radeon_uvd_enc_1_1_init(struct radeon_uvd_encoder *enc);
 bool si_radeon_uvd_enc_supported(struct si_screen *sscreen);
 
+unsigned int radeon_uvd_enc_write_vps(struct radeon_uvd_encoder *enc, uint8_t *out);
+unsigned int radeon_uvd_enc_write_sps(struct radeon_uvd_encoder *enc, uint8_t *out);
+unsigned int radeon_uvd_enc_write_pps(struct radeon_uvd_encoder *enc, uint8_t *out);
+
 #endif // _RADEON_UVD_ENC_H
diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index ce1d6509b876d..785c0fbe941bf 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -284,17 +284,13 @@ static void radeon_uvd_enc_encode_latency(struct radeon_uvd_encoder *enc)
    RADEON_ENC_END();
 }
 
-static void radeon_uvd_enc_nalu_sps_hevc(struct radeon_uvd_encoder *enc)
+unsigned int radeon_uvd_enc_write_sps(struct radeon_uvd_encoder *enc, uint8_t *out)
 {
    struct radeon_bitstream bs;
    struct pipe_h265_enc_seq_param *sps = &enc->enc_pic.desc->seq;
    int i;
 
-   RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
-   RADEON_ENC_CS(RENC_UVD_NALU_TYPE_SPS);
-   uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-
-   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_reset(&bs, out, NULL);
    radeon_bs_set_emulation_prevention(&bs, false);
    radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
    radeon_bs_code_fixed_bits(&bs, 0x4201, 16);
@@ -419,21 +415,15 @@ static void radeon_uvd_enc_nalu_sps_hevc(struct radeon_uvd_encoder *enc)
    radeon_bs_code_fixed_bits(&bs, 0x1, 1);
    radeon_bs_byte_align(&bs);
 
-   radeon_bs_flush_headers(&bs);
-   *size_in_bytes = bs.bits_output / 8;
-   RADEON_ENC_END();
+   return bs.bits_output / 8;
 }
 
-static void radeon_uvd_enc_nalu_pps_hevc(struct radeon_uvd_encoder *enc)
+unsigned int radeon_uvd_enc_write_pps(struct radeon_uvd_encoder *enc, uint8_t *out)
 {
    struct radeon_bitstream bs;
    struct pipe_h265_enc_pic_param *pps = &enc->enc_pic.desc->pic;
 
-   RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
-   RADEON_ENC_CS(RENC_UVD_NALU_TYPE_PPS);
-   uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-
-   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_reset(&bs, out, NULL);
    radeon_bs_set_emulation_prevention(&bs, false);
    radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
    radeon_bs_code_fixed_bits(&bs, 0x4401, 16);
@@ -480,22 +470,16 @@ static void radeon_uvd_enc_nalu_pps_hevc(struct radeon_uvd_encoder *enc)
    radeon_bs_code_fixed_bits(&bs, 0x1, 1);
    radeon_bs_byte_align(&bs);
 
-   radeon_bs_flush_headers(&bs);
-   *size_in_bytes = bs.bits_output / 8;
-   RADEON_ENC_END();
+   return bs.bits_output / 8;
 }
 
-static void radeon_uvd_enc_nalu_vps_hevc(struct radeon_uvd_encoder *enc)
+unsigned int radeon_uvd_enc_write_vps(struct radeon_uvd_encoder *enc, uint8_t *out)
 {
    struct radeon_bitstream bs;
    struct pipe_h265_enc_vid_param *vps = &enc->enc_pic.desc->vid;
    int i;
 
-   RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_INSERT_NALU_BUFFER);
-   RADEON_ENC_CS(RENC_UVD_NALU_TYPE_VPS);
-   uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
-
-   radeon_bs_reset(&bs, NULL, &enc->cs);
+   radeon_bs_reset(&bs, out, NULL);
    radeon_bs_set_emulation_prevention(&bs, false);
    radeon_bs_code_fixed_bits(&bs, 0x00000001, 32);
    radeon_bs_code_fixed_bits(&bs, 0x4001, 16);
@@ -531,9 +515,7 @@ static void radeon_uvd_enc_nalu_vps_hevc(struct radeon_uvd_encoder *enc)
    radeon_bs_code_fixed_bits(&bs, 0x1, 1);
    radeon_bs_byte_align(&bs);
 
-   radeon_bs_flush_headers(&bs);
-   *size_in_bytes = bs.bits_output / 8;
-   RADEON_ENC_END();
+   return bs.bits_output / 8;
 }
 
 static void radeon_uvd_enc_slice_header_hevc(struct radeon_uvd_encoder *enc)
@@ -722,7 +704,7 @@ static void radeon_uvd_enc_bitstream(struct radeon_uvd_encoder *enc)
 {
    enc->enc_pic.bit_buf.mode = RENC_UVD_SWIZZLE_MODE_LINEAR;
    enc->enc_pic.bit_buf.video_bitstream_buffer_size = enc->bs_size;
-   enc->enc_pic.bit_buf.video_bitstream_data_offset = 0;
+   enc->enc_pic.bit_buf.video_bitstream_data_offset = enc->bs_offset;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_VIDEO_BITSTREAM_BUFFER);
    RADEON_ENC_CS(enc->enc_pic.bit_buf.mode);
@@ -807,7 +789,7 @@ static void radeon_uvd_enc_encode_params_hevc(struct radeon_uvd_encoder *enc)
       enc->enc_pic.enc_params.pic_type = RENC_UVD_PICTURE_TYPE_I;
    }
 
-   enc->enc_pic.enc_params.allowed_max_bitstream_size = enc->bs_size;
+   enc->enc_pic.enc_params.allowed_max_bitstream_size = enc->bs_size - enc->bs_offset;
    if (sscreen->info.gfx_level < GFX9) {
       enc->enc_pic.enc_params.input_pic_luma_pitch =
          (enc->luma->u.legacy.level[0].nblk_x * enc->luma->bpe);
@@ -941,11 +923,6 @@ static void encode(struct radeon_uvd_encoder *enc)
    enc->enc_pic.layer_sel.temporal_layer_index = enc->enc_pic.temporal_id;
    radeon_uvd_enc_layer_select(enc);
 
-   if (enc->enc_pic.is_iframe) {
-      radeon_uvd_enc_nalu_vps_hevc(enc);
-      radeon_uvd_enc_nalu_pps_hevc(enc);
-      radeon_uvd_enc_nalu_sps_hevc(enc);
-   }
    radeon_uvd_enc_slice_header_hevc(enc);
    radeon_uvd_enc_encode_params_hevc(enc);
 
-- 
GitLab


From 009895d22319b1eb2c47c14f928a6554ef346afc Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Wed, 1 Jan 2025 15:36:40 +0100
Subject: [PATCH 31/32] radeonsi/uvd_enc: Set input pic swizzle mode on GFX9

---
 src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
index 785c0fbe941bf..cc07b954a7746 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd_enc_1_1.c
@@ -799,8 +799,8 @@ static void radeon_uvd_enc_encode_params_hevc(struct radeon_uvd_encoder *enc)
       enc->enc_pic.enc_params.input_pic_luma_pitch = enc->luma->u.gfx9.surf_pitch * enc->luma->bpe;
       enc->enc_pic.enc_params.input_pic_chroma_pitch =
          enc->chroma->u.gfx9.surf_pitch * enc->chroma->bpe;
+      enc->enc_pic.enc_params.input_pic_swizzle_mode = enc->luma->u.gfx9.swizzle_mode;
    }
-   enc->enc_pic.enc_params.input_pic_swizzle_mode = RENC_UVD_SWIZZLE_MODE_LINEAR;
 
    RADEON_ENC_BEGIN(RENC_UVD_IB_PARAM_ENCODE_PARAMS);
    RADEON_ENC_CS(enc->enc_pic.enc_params.pic_type);
@@ -815,7 +815,7 @@ static void radeon_uvd_enc_encode_params_hevc(struct radeon_uvd_encoder *enc)
    }
    RADEON_ENC_CS(enc->enc_pic.enc_params.input_pic_luma_pitch);
    RADEON_ENC_CS(enc->enc_pic.enc_params.input_pic_chroma_pitch);
-   RADEON_ENC_CS(0x00000000); // reserved
+   RADEON_ENC_CS(enc->enc_pic.enc_params.input_pic_addr_mode);
    RADEON_ENC_CS(enc->enc_pic.enc_params.input_pic_swizzle_mode);
    RADEON_ENC_CS(enc->enc_pic.enc_params.reference_picture_index);
    RADEON_ENC_CS(enc->enc_pic.enc_params.reconstructed_picture_index);
-- 
GitLab


From da4b9498eb2f0ef9a4f9bbc888d6af93a7a7ec25 Mon Sep 17 00:00:00 2001
From: David Rosca <david.rosca@amd.com>
Date: Thu, 2 Jan 2025 10:15:43 +0100
Subject: [PATCH 32/32] radeonsi: Enable implemented VCE/UVD encode features

---
 src/gallium/drivers/radeonsi/si_get.c | 29 +++++++++------------------
 1 file changed, 10 insertions(+), 19 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 936d691ecd6cd..1b70efc6775ff 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -719,12 +719,12 @@ static int si_get_video_param(struct pipe_screen *screen, enum pipe_video_profil
       case PIPE_VIDEO_CAP_STACKED_FRAMES:
          return (sscreen->info.family < CHIP_TONGA) ? 1 : 2;
       case PIPE_VIDEO_CAP_MAX_TEMPORAL_LAYERS:
-         return (codec == PIPE_VIDEO_FORMAT_MPEG4_AVC &&
+         return (sscreen->info.ip[AMD_IP_UVD_ENC].num_queues ||
                  sscreen->info.vcn_ip_version >= VCN_1_0_0) ? 4 : 0;
       case PIPE_VIDEO_CAP_ENC_QUALITY_LEVEL:
-         return (sscreen->info.vcn_ip_version >= VCN_1_0_0) ? 32 : 0;
+         return 32;
       case PIPE_VIDEO_CAP_ENC_SUPPORTS_MAX_FRAME_SIZE:
-         return (sscreen->info.vcn_ip_version >= VCN_1_0_0) ? 1 : 0;
+         return 1;
 
       case PIPE_VIDEO_CAP_ENC_HEVC_FEATURE_FLAGS:
          if (profile == PIPE_VIDEO_PROFILE_HEVC_MAIN ||
@@ -772,16 +772,12 @@ static int si_get_video_param(struct pipe_screen *screen, enum pipe_video_profil
             return 0;
 
       case PIPE_VIDEO_CAP_ENC_MAX_SLICES_PER_FRAME:
-         return (sscreen->info.vcn_ip_version >= VCN_1_0_0) ? 128 : 1;
+         return 128;
 
       case PIPE_VIDEO_CAP_ENC_SLICES_STRUCTURE:
-         if (sscreen->info.vcn_ip_version >= VCN_2_0_0) {
-            int value = (PIPE_VIDEO_CAP_SLICE_STRUCTURE_ARBITRARY_MACROBLOCKS |
-                         PIPE_VIDEO_CAP_SLICE_STRUCTURE_EQUAL_ROWS |
-                         PIPE_VIDEO_CAP_SLICE_STRUCTURE_EQUAL_MULTI_ROWS);
-            return value;
-         } else
-            return 0;
+         return PIPE_VIDEO_CAP_SLICE_STRUCTURE_ARBITRARY_MACROBLOCKS |
+                PIPE_VIDEO_CAP_SLICE_STRUCTURE_EQUAL_ROWS |
+                PIPE_VIDEO_CAP_SLICE_STRUCTURE_EQUAL_MULTI_ROWS;
 
       case PIPE_VIDEO_CAP_ENC_AV1_FEATURE:
          if (sscreen->info.vcn_ip_version >= VCN_4_0_0 && sscreen->info.vcn_ip_version != VCN_4_0_3) {
@@ -862,14 +858,9 @@ static int si_get_video_param(struct pipe_screen *screen, enum pipe_video_profil
             return 1;
 
       case PIPE_VIDEO_CAP_ENC_INTRA_REFRESH:
-         if (sscreen->info.vcn_ip_version >= VCN_1_0_0) {
-            int value = PIPE_VIDEO_ENC_INTRA_REFRESH_ROW |
-                        PIPE_VIDEO_ENC_INTRA_REFRESH_COLUMN |
-                        PIPE_VIDEO_ENC_INTRA_REFRESH_P_FRAME;
-            return value;
-         }
-         else
-            return 0;
+            return PIPE_VIDEO_ENC_INTRA_REFRESH_ROW |
+                   PIPE_VIDEO_ENC_INTRA_REFRESH_COLUMN |
+                   PIPE_VIDEO_ENC_INTRA_REFRESH_P_FRAME;
 
       case PIPE_VIDEO_CAP_ENC_ROI:
          if (sscreen->info.vcn_ip_version >= VCN_1_0_0) {
-- 
GitLab

