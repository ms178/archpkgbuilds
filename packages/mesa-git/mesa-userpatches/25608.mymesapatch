From a95936db90ea7613fe5c97b523d7ea074a2c84dd Mon Sep 17 00:00:00 2001
From: Mamoru TASAKA <mtasaka@fedoraproject.org>
Date: Mon, 9 Oct 2023 14:55:26 +0900
Subject: [PATCH] mesa: Fix glGetPixelMapuiv for I_TO_I and S_TO_S map case

For GL_PIXEL_MAP_I_TO_I and GL_PIXEL_MAP_S_TO_S map cases,
glPixelMapuiv just casts the original indexes from GLuint to GLfloat,
just as glPixelMapusv does from GLushort to GLfloat.

So for the above 2 map cases, the correspoinding glGetPixelMapuiv should
do just the reversed operation, that is to just cast from GLfloat to
GLuint the stores the results to the destination one element by one,
as same as what glGetPixelMapusv does. Here memcpy() cannot be used
because the types of source and destination differ.

Closes #9958 .
---
 src/mesa/main/pixel.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/src/mesa/main/pixel.c b/src/mesa/main/pixel.c
index ec75248ec1e88..955a67b6ec8b3 100644
--- a/src/mesa/main/pixel.c
+++ b/src/mesa/main/pixel.c
@@ -408,11 +408,19 @@ _mesa_GetnPixelMapuivARB( GLenum map, GLsizei bufSize, GLuint *values )
       return;
    }
 
-   if (map == GL_PIXEL_MAP_S_TO_S) {
-      /* special case */
-      memcpy(values, ctx->PixelMaps.StoS.Map, mapsize * sizeof(GLint));
-   }
-   else {
+   switch (map) {
+   /* special cases */
+   case GL_PIXEL_MAP_I_TO_I:
+      for (i = 0; i < mapsize; i++) {
+         values[i] = (GLuint) ctx->PixelMaps.ItoI.Map[i];
+      }
+      break;
+   case GL_PIXEL_MAP_S_TO_S:
+      for (i = 0; i < mapsize; i++) {
+         values[i] = (GLuint) ctx->PixelMaps.StoS.Map[i];
+      }
+      break;
+   default:
       for (i = 0; i < mapsize; i++) {
          values[i] = FLOAT_TO_UINT( pm->Map[i] );
       }
-- 
GitLab

