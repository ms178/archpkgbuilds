From dcd23962c13a39775274535b52c2ab2186ec98b2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Thu, 19 Aug 2021 16:03:03 +0200
Subject: [PATCH 1/4] loader/dri3: Clean up dri3_find_back logic

No need to go through the loop again for allocating a new buffer.
---
 src/loader/loader_dri3_helper.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 81245f4372bc..cf7e1ba748ad 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -707,6 +707,7 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
     */
    int current_back_id = draw->cur_back;
    for (;;) {
+      /* Find idle buffer or unallocated slot */
       for (b = 0; b < num_to_consider; b++) {
          int id = LOADER_DRI3_BACK_ID((b + draw->cur_back) % draw->cur_num_back);
          struct loader_dri3_buffer *buffer = draw->buffers[id];
@@ -719,15 +720,23 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
          }
       }
 
+      /* No idle buffer, allocate another one if possible */
       if (num_to_consider < max_num) {
-         num_to_consider = ++draw->cur_num_back;
-      } else if (prefer_a_different) {
-         prefer_a_different = false;
-      } else if (!dri3_wait_for_event_locked(draw, NULL)) {
+         b = LOADER_DRI3_BACK_ID(draw->cur_num_back++);
+         draw->cur_back = b;
          mtx_unlock(&draw->mtx);
-         return -1;
+         return b;
       }
+
+      /* Prefer re-using the same buffer over blocking */
+      if (prefer_a_different)
+         prefer_a_different = false;
+      else if (!dri3_wait_for_event_locked(draw, NULL))
+         break;
    }
+
+   mtx_unlock(&draw->mtx);
+   return -1;
 }
 
 static xcb_gcontext_t
-- 
GitLab


From 65db839a7d8c78703e91657a83ad6b0eca32f6d6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Thu, 19 Aug 2021 15:53:06 +0200
Subject: [PATCH 2/4] loader/dri3: Find idle buffer with minimum buffer age in
 dri3_find_back

This may allow applications making use of buffer age to save some effort
in some cases.
---
 src/loader/loader_dri3_helper.c | 50 ++++++++++++++++++++++++---------
 1 file changed, 36 insertions(+), 14 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index cf7e1ba748ad..d5768d5031a8 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -676,13 +676,26 @@ loader_dri3_wait_for_sbc(struct loader_dri3_drawable *draw,
 static int
 dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
 {
+   struct loader_dri3_buffer *buffer;
    int b;
    int num_to_consider;
    int max_num;
+   int best_id = -1;
+   uint64_t best_swap = 0;
 
    mtx_lock(&draw->mtx);
-   /* Increase the likelyhood of reusing current buffer */
-   dri3_flush_present_events(draw);
+
+   if (!prefer_a_different) {
+      /* Increase the likelyhood of reusing current buffer */
+      dri3_flush_present_events(draw);
+
+      /* Reuse current back buffer if it's idle */
+      buffer = draw->buffers[draw->cur_back];
+      if (buffer && !buffer->busy) {
+         best_id = draw->cur_back;
+         goto unlock;
+      }
+   }
 
    /* Check whether we need to reuse the current back buffer as new back.
     * In that case, wait until it's not busy anymore.
@@ -707,25 +720,30 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
     */
    int current_back_id = draw->cur_back;
    for (;;) {
-      /* Find idle buffer or unallocated slot */
+      /* Find idle buffer with lowest buffer age, or unallocated slot */
       for (b = 0; b < num_to_consider; b++) {
          int id = LOADER_DRI3_BACK_ID((b + draw->cur_back) % draw->cur_num_back);
-         struct loader_dri3_buffer *buffer = draw->buffers[id];
 
-         if (!buffer || (!buffer->busy &&
-                         (!prefer_a_different || id != current_back_id))) {
-            draw->cur_back = id;
-            mtx_unlock(&draw->mtx);
-            return id;
+         buffer = draw->buffers[id];
+         if (buffer) {
+            if (!buffer->busy &&
+                (!prefer_a_different || id != current_back_id) &&
+                (best_id == -1 || buffer->last_swap > best_swap)) {
+               best_id = id;
+               best_swap = buffer->last_swap;
+            }
+         } else if (best_id == -1) {
+            best_id = id;
          }
       }
 
+      if (best_id != -1)
+         break;
+
       /* No idle buffer, allocate another one if possible */
       if (num_to_consider < max_num) {
-         b = LOADER_DRI3_BACK_ID(draw->cur_num_back++);
-         draw->cur_back = b;
-         mtx_unlock(&draw->mtx);
-         return b;
+         best_id = LOADER_DRI3_BACK_ID(draw->cur_num_back++);
+         break;
       }
 
       /* Prefer re-using the same buffer over blocking */
@@ -735,8 +753,12 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
          break;
    }
 
+   if (best_id != -1)
+      draw->cur_back = best_id;
+
+unlock:
    mtx_unlock(&draw->mtx);
-   return -1;
+   return best_id;
 }
 
 static xcb_gcontext_t
-- 
GitLab


From 0c333e14aa625a4bd018df43448a295ab5732d24 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 20 Aug 2021 17:10:24 +0200
Subject: [PATCH 3/4] loader/dri3: Simplify new buffer allocation in
 dri3_find_back

We can find the idle buffer with lowest buffer age or the first
unallocated slot in the same loop.
---
 src/loader/loader_dri3_helper.c | 35 +++++++++++----------------------
 1 file changed, 12 insertions(+), 23 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index d5768d5031a8..11fb387a3a58 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -678,7 +678,6 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
 {
    struct loader_dri3_buffer *buffer;
    int b;
-   int num_to_consider;
    int max_num;
    int best_id = -1;
    uint64_t best_swap = 0;
@@ -701,11 +700,9 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
     * In that case, wait until it's not busy anymore.
     */
    if (!loader_dri3_have_image_blit(draw) && draw->cur_blit_source != -1) {
-      num_to_consider = 1;
       max_num = 1;
       draw->cur_blit_source = -1;
    } else {
-      num_to_consider = draw->cur_num_back;
       max_num = draw->max_num_back;
    }
 
@@ -719,10 +716,10 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
     * to wait for the copy to finish.
     */
    int current_back_id = draw->cur_back;
-   for (;;) {
-      /* Find idle buffer with lowest buffer age, or unallocated slot */
-      for (b = 0; b < num_to_consider; b++) {
-         int id = LOADER_DRI3_BACK_ID((b + draw->cur_back) % draw->cur_num_back);
+   do {
+      /* Find idle buffer with lowest buffer age, or first unallocated slot */
+      for (b = 0; b < max_num; b++) {
+         int id = LOADER_DRI3_BACK_ID((b + draw->cur_back) % draw->max_num_back);
 
          buffer = draw->buffers[id];
          if (buffer) {
@@ -732,29 +729,21 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
                best_id = id;
                best_swap = buffer->last_swap;
             }
-         } else if (best_id == -1) {
+         } else if (best_id == -1 || (!best_swap && id < best_id)) {
             best_id = id;
          }
       }
 
-      if (best_id != -1)
-         break;
-
-      /* No idle buffer, allocate another one if possible */
-      if (num_to_consider < max_num) {
-         best_id = LOADER_DRI3_BACK_ID(draw->cur_num_back++);
-         break;
-      }
-
       /* Prefer re-using the same buffer over blocking */
-      if (prefer_a_different)
-         prefer_a_different = false;
-      else if (!dri3_wait_for_event_locked(draw, NULL))
-         break;
-   }
+      if (prefer_a_different && best_id == -1 &&
+          !draw->buffers[LOADER_DRI3_BACK_ID(current_back_id)]->busy)
+         best_id = current_back_id;
+   } while (best_id == -1 && dri3_wait_for_event_locked(draw, NULL));
 
-   if (best_id != -1)
+   if (best_id != -1) {
       draw->cur_back = best_id;
+      draw->cur_num_back = MAX2(draw->cur_num_back, best_id + 1);
+   }
 
 unlock:
    mtx_unlock(&draw->mtx);
-- 
GitLab


From 3fd1699898144e225a6854b8d3bb50974ed78cf9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 20 Aug 2021 17:56:24 +0200
Subject: [PATCH 4/4] egl/wayland: Prefer back buffer with minimum buffer age

This may allow applications making use of buffer age to save some effort
in some cases.

v2: (Simon Ser)
* Add space between struct member and "<" operator.
* Remove break statement which prevented the change from working as
  intended in swrast_update_buffers.
---
 src/egl/drivers/dri2/platform_wayland.c | 26 +++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 634c6062d4f3..82c4e272f9a8 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -1032,12 +1032,15 @@ get_back_bo(struct dri2_egl_surface *dri2_surf)
    while (dri2_surf->back == NULL) {
       for (int i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
          /* Get an unlocked buffer, preferably one with a dri_buffer
-          * already allocated. */
+          * already allocated and with minimum age.
+          */
          if (dri2_surf->color_buffers[i].locked)
             continue;
-         if (dri2_surf->back == NULL)
-            dri2_surf->back = &dri2_surf->color_buffers[i];
-         else if (dri2_surf->back->dri_image == NULL)
+
+         if (!dri2_surf->back ||
+             !dri2_surf->back->dri_image ||
+             (dri2_surf->color_buffers[i].age > 0 &&
+              dri2_surf->color_buffers[i].age < dri2_surf->back->age))
             dri2_surf->back = &dri2_surf->color_buffers[i];
       }
 
@@ -2342,13 +2345,16 @@ swrast_update_buffers(struct dri2_egl_surface *dri2_surf)
    /* There might be a buffer release already queued that wasn't processed */
    wl_display_dispatch_queue_pending(dri2_dpy->wl_dpy, dri2_surf->wl_queue);
 
-   /* try get free buffer already created */
+   /* Try to get free buffer already created and with minimum age */
    for (int i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
-      if (!dri2_surf->color_buffers[i].locked &&
-          dri2_surf->color_buffers[i].wl_buffer) {
-          dri2_surf->back = &dri2_surf->color_buffers[i];
-          break;
-      }
+      if (dri2_surf->color_buffers[i].locked ||
+          !dri2_surf->color_buffers[i].wl_buffer)
+         continue;
+
+      if (!dri2_surf->back ||
+          (dri2_surf->color_buffers[i].age > 0 &&
+           dri2_surf->color_buffers[i].age < dri2_surf->back->age))
+         dri2_surf->back = &dri2_surf->color_buffers[i];
    }
 
    /* else choose any another free location */
-- 
GitLab

