From 1aa975ac6f03f587775cf756ca1a574bf9edbb41 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 23 Sep 2022 12:16:59 +0200
Subject: [PATCH 1/2] tc: do a GPU->CPU copy to initialize cpu_storage

If the GPU-side storage has been written to without using cpu_storage,
then we have to initialize the CPU-side storage correctly.

This requires a sync + copy but it's a one time operation so it shouldn't
affect performance much.

I don't think it fixes any existing bug, but the next commit will need
this to behave correctly.

cc: mesa-stable
---
 .../auxiliary/util/u_threaded_context.c       | 24 ++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 7731dd78ecbc..eff9e81982de 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -2282,9 +2282,31 @@ tc_buffer_map(struct pipe_context *_pipe,
       /* We can't let resource_copy_region disable the CPU storage. */
       assert(!(tres->b.flags & PIPE_RESOURCE_FLAG_DONT_MAP_DIRECTLY));
 
-      if (!tres->cpu_storage)
+      if (!tres->cpu_storage) {
          tres->cpu_storage = align_malloc(resource->width0, tc->map_buffer_alignment);
 
+         if (tres->cpu_storage && tres->valid_buffer_range.end) {
+            /* The GPU buffer contains valid data. Copy them to the CPU storage.
+             * TODO:
+             *   - GPU->CPU copy should only happen is usage & PIPE_MAP_READ
+             *   - on cpu_storage unmap we should only CPU->GPU the part that was "CPU"
+             *     mapped, not the full buffer.
+             */
+            struct pipe_box box2 = { .x = 0, .width = resource->width0 };
+            struct pipe_transfer *transfer2;
+
+            tc_sync_msg(tc, "cpu storage GPU -> CPU copy");
+            tc_set_driver_thread(tc);
+
+            void *ret = pipe->buffer_map(pipe, tres->latest ? tres->latest : resource,
+                                         0, PIPE_MAP_READ, &box2, &transfer2);
+            memcpy(tres->cpu_storage, ret, resource->width0);
+            pipe->buffer_unmap(pipe, transfer2);
+
+            tc_clear_driver_thread(tc);
+         }
+      }
+
       if (tres->cpu_storage) {
          struct threaded_transfer *ttrans = slab_zalloc(&tc->pool_transfers);
          ttrans->b.resource = resource;
-- 
GitLab


From cf57ce41038978ec8c26d68f029cd4b561ccd69c Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 23 Sep 2022 12:15:36 +0200
Subject: [PATCH 2/2] tc: don't use CPU storage for glBufferData

This fixes a performance regression with yquake2 cause by
the enablement of cpu_storage by default for radeonsi in
a5a8e197413.

Fixes: a5a8e197413 ("radeonsi: enable tc cpu_storage by default")
---
 src/gallium/auxiliary/util/u_threaded_context.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index eff9e81982de..2160268bdd0a 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -2731,6 +2731,12 @@ tc_buffer_subdata(struct pipe_context *_pipe,
 
       u_box_1d(offset, size, &box);
 
+      /* CPU storage is only useful for partial updates. It can add overhead
+       * on glBufferData calls so avoid using it.
+       */
+      if (!tres->cpu_storage && offset == 0 && size == resource->width0)
+         usage |= TC_TRANSFER_MAP_UPLOAD_CPU_STORAGE;
+
       map = tc_buffer_map(_pipe, resource, 0, usage, &box, &transfer);
       if (map) {
          memcpy(map, data, size);
-- 
GitLab

