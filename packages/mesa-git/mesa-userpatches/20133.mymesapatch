From cbaaf266faf67b3a14a7493cc7a63a62080b9766 Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Sun, 4 Dec 2022 09:12:09 -0300
Subject: [PATCH 1/8] gallium: pipe: add get_decoder_fence vfunc

Add a get_decoder_fence vfunc that can be used to query the status
of the previous decode job denoted by 'fence' given 'timeout'.

A pointer to a fence pointer can be  passed to the codecs before the
end_frame vfunc and the codec should then be responsible for allocating
a fence on command stream submission.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/include/pipe/p_video_codec.h | 14 ++++++++++++++
 src/gallium/include/pipe/p_video_state.h |  2 ++
 2 files changed, 16 insertions(+)

diff --git a/src/gallium/include/pipe/p_video_codec.h b/src/gallium/include/pipe/p_video_codec.h
index e13dc5d47867..c68d8fd672c8 100644
--- a/src/gallium/include/pipe/p_video_codec.h
+++ b/src/gallium/include/pipe/p_video_codec.h
@@ -119,6 +119,20 @@ struct pipe_video_codec
     * get encoder feedback
     */
    void (*get_feedback)(struct pipe_video_codec *codec, void *feedback, unsigned *size);
+
+   /**
+    * Get decoder fence.
+    *
+    * Can be used to query the status of the previous decode job denoted by
+    * 'fence' given 'timeout'.
+    *
+    * A pointer to a fence pointer can be passed to the codecs before the
+    * end_frame vfunc and the codec should then be responsible for allocating a
+    * fence on command stream submission.
+    */
+   int (*get_decoder_fence)(struct pipe_video_codec *codec,
+                            struct pipe_fence_handle *fence,
+                            uint64_t timeout);
 };
 
 /**
diff --git a/src/gallium/include/pipe/p_video_state.h b/src/gallium/include/pipe/p_video_state.h
index 84d70f74fc3b..784d8462b9e2 100644
--- a/src/gallium/include/pipe/p_video_state.h
+++ b/src/gallium/include/pipe/p_video_state.h
@@ -166,6 +166,8 @@ struct pipe_picture_desc
    uint32_t key_size;
    enum pipe_format input_format;
    enum pipe_format output_format;
+   /* A fence used on PIPE_VIDEO_ENTRYPOINT_DECODE to signal job completion */
+   struct pipe_fence_handle **fence;
 };
 
 struct pipe_quant_matrix
-- 
GitLab


From 56ff1a856f82c5f131b0169dd84e6b677440572e Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Mon, 5 Dec 2022 14:17:54 -0300
Subject: [PATCH 2/8] gallium: pipe: add
 PIPE_DEFAULT_DECODER_FEEDBACK_TIMEOUT_NS

Add PIPE_DEFAULT_DECODER_FEEDBACK_TIMEOUT_NS as a way to control
how much to wait for decoders if this is supported.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/include/pipe/p_video_state.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/include/pipe/p_video_state.h b/src/gallium/include/pipe/p_video_state.h
index 784d8462b9e2..271c1e8f756b 100644
--- a/src/gallium/include/pipe/p_video_state.h
+++ b/src/gallium/include/pipe/p_video_state.h
@@ -44,6 +44,7 @@ extern "C" {
 #define PIPE_DEFAULT_FRAME_RATE_DEN   1
 #define PIPE_DEFAULT_FRAME_RATE_NUM   30
 #define PIPE_H2645_EXTENDED_SAR       255
+#define PIPE_DEFAULT_DECODER_FEEDBACK_TIMEOUT_NS 100000000
 
 /*
  * see table 6-12 in the spec
-- 
GitLab


From 46b990ffdd98e48981df4c1d6b05ab112f507fa1 Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Sun, 4 Dec 2022 09:18:52 -0300
Subject: [PATCH 3/8] frontends: va: fix vaQuerySurfaceStatus and vaSyncSurface
 for decode

Use the new get_decoder_fence vfunc to  implement
vaQuerySurfaceStatus and vaSyncSurface in the va state tracker.

A pointer to the surface's fence is passed to the codecs before the
end_frame vfunc and the codec is responsible for allocating a fence on
command stream submission.

This fence is then queried on vaQuerySurfaceStatus and waited on in
vaSyncSurface.

Notably both functions were not implemented as per the VA-API docs for
PIPE_VIDEO_ENTRYPOINT_BITSTREAM.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Sil Vilerino <sivileri@microsoft.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/frontends/va/picture.c    |  2 +
 src/gallium/frontends/va/surface.c    | 55 +++++++++++++++++++++++++--
 src/gallium/frontends/va/va_private.h |  1 +
 3 files changed, 55 insertions(+), 3 deletions(-)

diff --git a/src/gallium/frontends/va/picture.c b/src/gallium/frontends/va/picture.c
index b19690603f13..9f0b922fc883 100644
--- a/src/gallium/frontends/va/picture.c
+++ b/src/gallium/frontends/va/picture.c
@@ -1024,6 +1024,8 @@ vlVaEndPicture(VADriverContextP ctx, VAContextID context_id)
       surf->feedback = feedback;
       surf->coded_buf = coded_buf;
       coded_buf->associated_encode_input_surf = context->target_id;
+   } else if (context->decoder->entrypoint == PIPE_VIDEO_ENTRYPOINT_BITSTREAM) {
+      context->desc.base.fence = &surf->fence;
    }
 
    context->decoder->end_frame(context->decoder, context->target, &context->desc.base);
diff --git a/src/gallium/frontends/va/surface.c b/src/gallium/frontends/va/surface.c
index e7aec0b0baa4..67595f5e0adc 100644
--- a/src/gallium/frontends/va/surface.c
+++ b/src/gallium/frontends/va/surface.c
@@ -114,8 +114,14 @@ vlVaSyncSurface(VADriverContextP ctx, VASurfaceID render_target)
       return VA_STATUS_ERROR_INVALID_SURFACE;
    }
 
-   if (!surf->feedback) {
-      // No outstanding operation: nothing to do.
+   /* This is checked before getting the context below as
+    * surf->ctx is only set in begin_frame
+    * and not when the surface is created
+    * Some apps try to sync/map the surface right after creation and
+    * would get VA_STATUS_ERROR_INVALID_CONTEXT
+    */
+   if ((!surf->feedback) && (!surf->fence)) {
+      // No outstanding encode/decode operation: nothing to do.
       mtx_unlock(&drv->mutex);
       return VA_STATUS_SUCCESS;
    }
@@ -126,7 +132,18 @@ vlVaSyncSurface(VADriverContextP ctx, VASurfaceID render_target)
       return VA_STATUS_ERROR_INVALID_CONTEXT;
    }
 
-   if (context->decoder->entrypoint == PIPE_VIDEO_ENTRYPOINT_ENCODE) {
+   if (context->decoder->entrypoint == PIPE_VIDEO_ENTRYPOINT_BITSTREAM) {
+      int ret = 0;
+
+      if (context->decoder->get_decoder_fence)
+         ret = context->decoder->get_decoder_fence(context->decoder,
+                                                   surf->fence,
+                                                   PIPE_DEFAULT_DECODER_FEEDBACK_TIMEOUT_NS);
+
+      mtx_unlock(&drv->mutex);
+      // Assume that the GPU has hung otherwise.
+      return ret ? VA_STATUS_SUCCESS : VA_STATUS_ERROR_TIMEDOUT;
+   } else if (context->decoder->entrypoint == PIPE_VIDEO_ENTRYPOINT_ENCODE) {
       if (!drv->pipe->screen->get_video_param(drv->pipe->screen,
                               context->decoder->profile,
                               context->decoder->entrypoint,
@@ -176,6 +193,19 @@ vlVaQuerySurfaceStatus(VADriverContextP ctx, VASurfaceID render_target, VASurfac
       return VA_STATUS_ERROR_INVALID_SURFACE;
    }
 
+   /* This is checked before getting the context below as
+    * surf->ctx is only set in begin_frame
+    * and not when the surface is created
+    * Some apps try to sync/map the surface right after creation and
+    * would get VA_STATUS_ERROR_INVALID_CONTEXT
+    */
+   if ((!surf->feedback) && (!surf->fence)) {
+      // No outstanding encode/decode operation: nothing to do.
+      *status = VASurfaceReady;
+      mtx_unlock(&drv->mutex);
+      return VA_STATUS_SUCCESS;
+   }
+
    context = handle_table_get(drv->htab, surf->ctx);
    if (!context) {
       mtx_unlock(&drv->mutex);
@@ -187,6 +217,25 @@ vlVaQuerySurfaceStatus(VADriverContextP ctx, VASurfaceID render_target, VASurfac
          *status=VASurfaceReady;
       else
          *status=VASurfaceRendering;
+   } else if (context->decoder->entrypoint == PIPE_VIDEO_ENTRYPOINT_BITSTREAM) {
+      int ret = 0;
+
+      if (context->decoder->get_decoder_fence)
+         ret = context->decoder->get_decoder_fence(context->decoder,
+                                                   surf->fence, 0);
+
+      if (ret)
+         *status = VASurfaceReady;
+      else
+      /* An approach could be to just tell the client that this is not
+       * implemented, but this breaks other code.  Compromise by at least
+       * conservatively setting the status to VASurfaceRendering if we can't
+       * query the hardware.  Note that we _must_ set the status here, otherwise
+       * it comes out of the function unchanged. As we are returning
+       * VA_STATUS_SUCCESS, the client would be within his/her rights to use a
+       * potentially uninitialized/invalid status value unknowingly.
+       */
+         *status = VASurfaceRendering;
    }
 
    mtx_unlock(&drv->mutex);
diff --git a/src/gallium/frontends/va/va_private.h b/src/gallium/frontends/va/va_private.h
index 695b47511251..b92d49477d5c 100644
--- a/src/gallium/frontends/va/va_private.h
+++ b/src/gallium/frontends/va/va_private.h
@@ -374,6 +374,7 @@ typedef struct {
    bool force_flushed;
    struct pipe_video_buffer *obsolete_buf;
    enum pipe_format encoder_format;
+   struct pipe_fence_handle *fence;
 } vlVaSurface;
 
 typedef struct {
-- 
GitLab


From bc3defa209f157ca2e7bd294397c7e6694ee955f Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Sun, 4 Dec 2022 09:20:48 -0300
Subject: [PATCH 4/8] virgl: video: implement the get_decoder_fence vfunc

Implement the get_decoder_fence vfunc by waiting on the fence
previously passed in picture->fence in the end_frame vfunc.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/drivers/virgl/virgl_video.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/virgl/virgl_video.c b/src/gallium/drivers/virgl/virgl_video.c
index eae12fb2d27f..fc2d1b5443dc 100644
--- a/src/gallium/drivers/virgl/virgl_video.c
+++ b/src/gallium/drivers/virgl/virgl_video.c
@@ -725,11 +725,21 @@ static void virgl_video_end_frame(struct pipe_video_codec *codec,
     struct virgl_video_buffer *vbuf = virgl_video_buffer(target);
 
     virgl_encode_end_frame(vctx, vcdc, vbuf);
-    virgl_flush_eq(vctx, vctx, NULL);
+    virgl_flush_eq(vctx, vctx, picture->fence);
 
     switch_buffer(vcdc);
 }
 
+static int virgl_video_get_decoder_fence(struct pipe_video_codec *decoder,
+                                         struct pipe_fence_handle *fence,
+                                         uint64_t timeout) {
+    struct virgl_video_codec *vcdc = virgl_video_codec(decoder);
+    struct virgl_context *vctx = vcdc->vctx;
+    struct virgl_screen *vs = virgl_screen(vctx->base.screen);
+
+    return vs->vws->fence_wait(vs->vws, fence, timeout);
+}
+
 static void virgl_video_flush(struct pipe_video_codec *codec)
 {
     struct pipe_context *ctx = codec->context;
@@ -836,6 +846,7 @@ virgl_video_create_codec(struct pipe_context *ctx,
     vcdc->base.end_frame = virgl_video_end_frame;
     vcdc->base.flush = virgl_video_flush;
     vcdc->base.get_feedback = virgl_video_get_feedback;
+    vcdc->base.get_decoder_fence = virgl_video_get_decoder_fence;
 
     vcdc->bs_size = 0;
     vcdc->cur_buffer = 0;
-- 
GitLab


From 4187a23152d2862a1f7035c7817d03c317a0b45a Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Sun, 4 Dec 2022 09:25:45 -0300
Subject: [PATCH 5/8] r600: uvd: implement the get_decoder_fence vfunc

Implement the get_decoder_fence vfunc by waiting on the fence
previously passed in picture->fence in the end_frame vfunc.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/drivers/r600/radeon_uvd.c | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/r600/radeon_uvd.c b/src/gallium/drivers/r600/radeon_uvd.c
index e4971c3d5c03..35471e51d6a4 100644
--- a/src/gallium/drivers/r600/radeon_uvd.c
+++ b/src/gallium/drivers/r600/radeon_uvd.c
@@ -100,9 +100,9 @@ struct ruvd_decoder {
 };
 
 /* flush IB to the hardware */
-static int flush(struct ruvd_decoder *dec, unsigned flags)
-{
-	return dec->ws->cs_flush(&dec->cs, flags, NULL);
+static int flush(struct ruvd_decoder *dec, unsigned flags,
+				 struct pipe_fence_handle **fence) {
+	return dec->ws->cs_flush(&dec->cs, flags, fence);
 }
 
 /* add a new set register command to the IB */
@@ -807,7 +807,7 @@ static void ruvd_destroy(struct pipe_video_codec *decoder)
 	dec->msg->stream_handle = dec->stream_handle;
 	send_msg_buf(dec);
 
-	flush(dec, 0);
+	flush(dec, 0, NULL);
 
 	dec->ws->cs_destroy(&dec->cs);
 
@@ -1017,7 +1017,7 @@ static void ruvd_end_frame(struct pipe_video_codec *decoder,
 			 FB_BUFFER_OFFSET + dec->fb_size, RADEON_USAGE_READ, RADEON_DOMAIN_GTT);
 	set_reg(dec, dec->reg.cntl, 1);
 
-	flush(dec, PIPE_FLUSH_ASYNC);
+	flush(dec, PIPE_FLUSH_ASYNC, picture->fence);
 	next_buffer(dec);
 }
 
@@ -1028,6 +1028,14 @@ static void ruvd_flush(struct pipe_video_codec *decoder)
 {
 }
 
+static int ruvd_get_decoder_fence(struct pipe_video_codec *decoder,
+                                  struct pipe_fence_handle *fence,
+                                  uint64_t timeout) {
+
+  struct ruvd_decoder *dec = (struct ruvd_decoder *)decoder;
+  return dec->ws->fence_wait(dec->ws, fence, timeout);
+}
+
 /**
  * create and UVD decoder
  */
@@ -1084,6 +1092,7 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 	dec->base.decode_bitstream = ruvd_decode_bitstream;
 	dec->base.end_frame = ruvd_end_frame;
 	dec->base.flush = ruvd_flush;
+	dec->base.get_decoder_fence = ruvd_get_decoder_fence;
 
 	dec->stream_type = profile2stream_type(dec, info.family);
 	dec->set_dtb = set_dtb;
@@ -1142,7 +1151,7 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 	dec->msg->body.create.height_in_samples = dec->base.height;
 	dec->msg->body.create.dpb_size = dpb_size;
 	send_msg_buf(dec);
-	r = flush(dec, 0);
+	r = flush(dec, 0, NULL);
 	if (r)
 		goto error;
 
-- 
GitLab


From 8a585e59c020379de7b67d2c36ce7e6c9e2d8789 Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Sun, 4 Dec 2022 09:27:33 -0300
Subject: [PATCH 6/8] radeonsi: uvd: implement the get_decoder_fence vfunc

Implement the get_decoder_fence vfunc by waiting on the fence
previously passed in the end_frame vfunc.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_uvd.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_uvd.c b/src/gallium/drivers/radeonsi/radeon_uvd.c
index c8b8cf540968..f9dc4dc7f37a 100644
--- a/src/gallium/drivers/radeonsi/radeon_uvd.c
+++ b/src/gallium/drivers/radeonsi/radeon_uvd.c
@@ -94,9 +94,16 @@ struct ruvd_decoder {
 };
 
 /* flush IB to the hardware */
-static int flush(struct ruvd_decoder *dec, unsigned flags)
+static int flush(struct ruvd_decoder *dec, unsigned flags, struct pipe_fence_handle **fence)
 {
-   return dec->ws->cs_flush(&dec->cs, flags, NULL);
+   return dec->ws->cs_flush(&dec->cs, flags, fence);
+}
+
+static int ruvd_dec_get_decoder_fence(struct pipe_video_codec *decoder,
+                                      struct pipe_fence_handle *fence,
+                                      uint64_t timeout) {
+   struct ruvd_decoder *dec = (struct ruvd_decoder *)decoder;
+   return dec->ws->fence_wait(dec->ws, fence, timeout);
 }
 
 /* add a new set register command to the IB */
@@ -981,7 +988,7 @@ static void ruvd_destroy(struct pipe_video_codec *decoder)
    dec->msg->stream_handle = dec->stream_handle;
    send_msg_buf(dec);
 
-   flush(dec, 0);
+   flush(dec, 0, NULL);
 
    dec->ws->cs_destroy(&dec->cs);
 
@@ -1198,7 +1205,7 @@ static void ruvd_end_frame(struct pipe_video_codec *decoder, struct pipe_video_b
                FB_BUFFER_OFFSET + dec->fb_size, RADEON_USAGE_READ, RADEON_DOMAIN_GTT);
    set_reg(dec, dec->reg.cntl, 1);
 
-   flush(dec, PIPE_FLUSH_ASYNC);
+   flush(dec, PIPE_FLUSH_ASYNC, picture->fence);
    next_buffer(dec);
 }
 
@@ -1262,6 +1269,7 @@ struct pipe_video_codec *si_common_uvd_create_decoder(struct pipe_context *conte
    dec->base.decode_bitstream = ruvd_decode_bitstream;
    dec->base.end_frame = ruvd_end_frame;
    dec->base.flush = ruvd_flush;
+   dec->base.get_decoder_fence = ruvd_dec_get_decoder_fence;
 
    dec->stream_type = profile2stream_type(dec, sctx->family);
    dec->set_dtb = set_dtb;
@@ -1347,7 +1355,7 @@ struct pipe_video_codec *si_common_uvd_create_decoder(struct pipe_context *conte
    dec->msg->body.create.height_in_samples = dec->base.height;
    dec->msg->body.create.dpb_size = dpb_size;
    send_msg_buf(dec);
-   r = flush(dec, 0);
+   r = flush(dec, 0, NULL);
    if (r)
       goto error;
 
-- 
GitLab


From c9c804074e4d80c7583133d0377a1490c85d16e7 Mon Sep 17 00:00:00 2001
From: Daniel Almeida <daniel.almeida@collabora.com>
Date: Sun, 4 Dec 2022 09:28:23 -0300
Subject: [PATCH 7/8] radeonsi: vcn: implement the get_decoder_fence vfunc

Implement the get_decoder_fence vfunc by waiting on the fence
previously passed in the end_frame vfunc.

Signed-off-by: Daniel Almeida <daniel.almeida@collabora.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/drivers/radeonsi/radeon_vcn_dec.c | 23 +++++++++++++------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_dec.c b/src/gallium/drivers/radeonsi/radeon_vcn_dec.c
index b6e39b4564bb..33dfc9bd6784 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_dec.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_dec.c
@@ -2360,11 +2360,11 @@ static void rvcn_dec_sq_tail(struct radeon_decoder *dec)
    rvcn_sq_tail(&dec->cs, &dec->sq);
 }
 /* flush IB to the hardware */
-static int flush(struct radeon_decoder *dec, unsigned flags)
-{
+static int flush(struct radeon_decoder *dec, unsigned flags,
+                 struct pipe_fence_handle **fence) {
    rvcn_dec_sq_tail(dec);
 
-   return dec->ws->cs_flush(&dec->cs, flags, NULL);
+   return dec->ws->cs_flush(&dec->cs, flags, fence);
 }
 
 /* add a new set register command to the IB */
@@ -2736,7 +2736,7 @@ static void radeon_dec_destroy(struct pipe_video_codec *decoder)
       map_msg_fb_it_probs_buf(dec);
       rvcn_dec_message_destroy(dec);
       send_msg_buf(dec);
-      flush(dec, 0);
+      flush(dec, 0, NULL);
    }
 
    dec->ws->cs_destroy(&dec->cs);
@@ -2905,7 +2905,7 @@ static void radeon_dec_end_frame(struct pipe_video_codec *decoder, struct pipe_v
       return;
 
    dec->send_cmd(dec, target, picture);
-   flush(dec, PIPE_FLUSH_ASYNC);
+   flush(dec, PIPE_FLUSH_ASYNC, picture->fence);
    next_buffer(dec);
 }
 
@@ -2923,7 +2923,7 @@ static void radeon_dec_jpeg_end_frame(struct pipe_video_codec *decoder, struct p
       return;
 
    dec->send_cmd(dec, target, picture);
-   dec->ws->cs_flush(&dec->jcs[dec->cb_idx], PIPE_FLUSH_ASYNC, NULL);
+   dec->ws->cs_flush(&dec->jcs[dec->cb_idx], PIPE_FLUSH_ASYNC, picture->fence);
    next_buffer(dec);
    dec->cb_idx = (dec->cb_idx+1) % dec->njctx;
 }
@@ -2935,6 +2935,14 @@ static void radeon_dec_flush(struct pipe_video_codec *decoder)
 {
 }
 
+static int radeon_dec_get_decoder_fence(struct pipe_video_codec *decoder,
+                                        struct pipe_fence_handle *fence,
+                                        uint64_t timeout) {
+
+   struct radeon_decoder *dec = (struct radeon_decoder *)decoder;
+   return dec->ws->fence_wait(dec->ws, fence, timeout);
+}
+
 /**
  * create and HW decoder
  */
@@ -3001,6 +3009,7 @@ struct pipe_video_codec *radeon_create_decoder(struct pipe_context *context,
    dec->base.decode_bitstream = radeon_dec_decode_bitstream;
    dec->base.end_frame = radeon_dec_end_frame;
    dec->base.flush = radeon_dec_flush;
+   dec->base.get_decoder_fence = radeon_dec_get_decoder_fence;
 
    dec->stream_type = stream_type;
    dec->stream_handle = si_vid_alloc_stream_handle();
@@ -3175,7 +3184,7 @@ struct pipe_video_codec *radeon_create_decoder(struct pipe_context *context,
       map_msg_fb_it_probs_buf(dec);
       rvcn_dec_message_create(dec);
       send_msg_buf(dec);
-      r = flush(dec, 0);
+      r = flush(dec, 0, NULL);
       if (r)
          goto error;
    }
-- 
GitLab


From 1752623d4aa27c3153ec424e76f26030e1668a7d Mon Sep 17 00:00:00 2001
From: Sil Vilerino <sivileri@microsoft.com>
Date: Sun, 4 Dec 2022 09:39:09 -0300
Subject: [PATCH 8/8] d3d12: implement the get_decoder_fence vfunc

Implement the get_decoder_fence vfunc. Note that the waiting for
completion in this driver happens in the end_frame vfunc itself.

Signed-off-by: Sil Vilerino <sivileri@microsoft.com>
Reviewed-by: Leo Liu <leo.liu@amd.com>
Reviewed-by: Boyuan Zhang <Boyuan.Zhang@amd.com>
---
 src/gallium/drivers/d3d12/d3d12_video_dec.cpp | 24 +++++++++++++++++++
 src/gallium/drivers/d3d12/d3d12_video_dec.h   |  7 ++++++
 2 files changed, 31 insertions(+)

diff --git a/src/gallium/drivers/d3d12/d3d12_video_dec.cpp b/src/gallium/drivers/d3d12/d3d12_video_dec.cpp
index 4789306ce7a6..460c33472273 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_dec.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_dec.cpp
@@ -65,6 +65,7 @@ d3d12_video_create_decoder(struct pipe_context *context, const struct pipe_video
    pD3D12Dec->base.decode_bitstream = d3d12_video_decoder_decode_bitstream;
    pD3D12Dec->base.end_frame = d3d12_video_decoder_end_frame;
    pD3D12Dec->base.flush = d3d12_video_decoder_flush;
+   pD3D12Dec->base.get_decoder_fence = d3d12_video_decoder_get_decoder_fence;
 
    pD3D12Dec->m_decodeFormat = d3d12_convert_pipe_video_profile_to_dxgi_format(codec->profile);
    pD3D12Dec->m_d3d12DecProfileType = d3d12_video_decoder_convert_pipe_video_profile_to_profile_type(codec->profile);
@@ -665,6 +666,29 @@ d3d12_video_decoder_end_frame(struct pipe_video_codec *codec,
       pD3D12Screen->base.fence_reference(&pD3D12Screen->base, &completion_fence, NULL);
       pipe_resource_reference(&pPipeSrc, NULL);
    }
+
+   // We do not use the async fence for now but set it to
+   // NULL to avoid uninitialized memory in VA frontend
+   *picture->fence = NULL;
+}
+
+/**
+ * Get decoder fence.
+ */
+int d3d12_video_decoder_get_decoder_fence(struct pipe_video_codec *codec,
+                                          struct pipe_fence_handle *fence,
+                                          uint64_t timeout)
+{
+   /* No need to wait for anything, we're already flushing
+   and waiting in d3d12_video_decoder_end_frame */
+
+   // We set NULL in d3d12_video_decoder_end_frame
+   assert(fence == NULL);
+
+   // Return semantics based on p_video_codec interface
+   // ret == 0 -> Decode in progress
+   // ret != 0 -> Decode completed
+   return 1;
 }
 
 /**
diff --git a/src/gallium/drivers/d3d12/d3d12_video_dec.h b/src/gallium/drivers/d3d12/d3d12_video_dec.h
index 2184fe0b1301..3197cc751d1e 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_dec.h
+++ b/src/gallium/drivers/d3d12/d3d12_video_dec.h
@@ -77,6 +77,13 @@ d3d12_video_decoder_end_frame(struct pipe_video_codec * codec,
 void
 d3d12_video_decoder_flush(struct pipe_video_codec *codec);
 
+/**
+ * Get decoder fence.
+ */
+int d3d12_video_decoder_get_decoder_fence(struct pipe_video_codec *codec,
+                                          struct pipe_fence_handle *fence,
+                                          uint64_t timeout);
+
 ///
 /// Pipe video interface ends
 ///
-- 
GitLab

