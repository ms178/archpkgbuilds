From 460d1ab62562b79748f22c25825bb2f6f943c046 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 23 Jul 2022 11:00:23 -0400
Subject: [PATCH 1/4] nir: add nir_shader_compiler_options* into
 nir_eval_const_opcode

Some instructions will have hw-specific constant evaluation code,
e.g. f2u will clamp to the integer range.
---
 src/compiler/nir/nir_constant_expressions.h  |  3 +-
 src/compiler/nir/nir_constant_expressions.py |  3 +-
 src/compiler/nir/nir_loop_analyze.c          | 65 ++++++++++++--------
 src/compiler/nir/nir_opt_constant_folding.c  |  3 +-
 src/compiler/spirv/spirv_to_nir.c            |  3 +-
 5 files changed, 47 insertions(+), 30 deletions(-)

diff --git a/src/compiler/nir/nir_constant_expressions.h b/src/compiler/nir/nir_constant_expressions.h
index 6450d5c3d03f..a9802d9e8b59 100644
--- a/src/compiler/nir/nir_constant_expressions.h
+++ b/src/compiler/nir/nir_constant_expressions.h
@@ -33,6 +33,7 @@
 void nir_eval_const_opcode(nir_op op, nir_const_value *dest,
                            unsigned num_components, unsigned bit_size,
                            nir_const_value **src,
-                           unsigned float_controls_execution_mode);
+                           unsigned float_controls_execution_mode,
+                           const struct nir_shader_compiler_options *options);
 
 #endif /* NIR_CONSTANT_EXPRESSIONS_H */
diff --git a/src/compiler/nir/nir_constant_expressions.py b/src/compiler/nir/nir_constant_expressions.py
index b82d96d60707..ada9e1d89ba7 100644
--- a/src/compiler/nir/nir_constant_expressions.py
+++ b/src/compiler/nir/nir_constant_expressions.py
@@ -495,7 +495,8 @@ void
 nir_eval_const_opcode(nir_op op, nir_const_value *dest,
                       unsigned num_components, unsigned bit_width,
                       nir_const_value **src,
-                      unsigned float_controls_execution_mode)
+                      unsigned float_controls_execution_mode,
+                      const struct nir_shader_compiler_options *options)
 {
    switch (op) {
 % for name in sorted(opcodes.keys()):
diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index 3b54a068429d..40344d128fb8 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -694,31 +694,34 @@ try_find_limit_of_alu(nir_ssa_scalar limit, nir_const_value *limit_val,
 
 static nir_const_value
 eval_const_unop(nir_op op, unsigned bit_size, nir_const_value src0,
-                unsigned execution_mode)
+                unsigned execution_mode,
+                const struct nir_shader_compiler_options *options)
 {
    assert(nir_op_infos[op].num_inputs == 1);
    nir_const_value dest;
    nir_const_value *src[1] = { &src0 };
-   nir_eval_const_opcode(op, &dest, 1, bit_size, src, execution_mode);
+   nir_eval_const_opcode(op, &dest, 1, bit_size, src, execution_mode, options);
    return dest;
 }
 
 static nir_const_value
 eval_const_binop(nir_op op, unsigned bit_size,
                  nir_const_value src0, nir_const_value src1,
-                 unsigned execution_mode)
+                 unsigned execution_mode,
+                 const struct nir_shader_compiler_options *options)
 {
    assert(nir_op_infos[op].num_inputs == 2);
    nir_const_value dest;
    nir_const_value *src[2] = { &src0, &src1 };
-   nir_eval_const_opcode(op, &dest, 1, bit_size, src, execution_mode);
+   nir_eval_const_opcode(op, &dest, 1, bit_size, src, execution_mode, options);
    return dest;
 }
 
 static int32_t
 get_iteration(nir_op cond_op, nir_const_value initial, nir_const_value step,
               nir_const_value limit, unsigned bit_size,
-              unsigned execution_mode)
+              unsigned execution_mode,
+              const struct nir_shader_compiler_options *options)
 {
    nir_const_value span, iter;
 
@@ -728,17 +731,17 @@ get_iteration(nir_op cond_op, nir_const_value initial, nir_const_value step,
    case nir_op_ieq:
    case nir_op_ine:
       span = eval_const_binop(nir_op_isub, bit_size, limit, initial,
-                              execution_mode);
+                              execution_mode, options);
       iter = eval_const_binop(nir_op_idiv, bit_size, span, step,
-                              execution_mode);
+                              execution_mode, options);
       break;
 
    case nir_op_uge:
    case nir_op_ult:
       span = eval_const_binop(nir_op_isub, bit_size, limit, initial,
-                              execution_mode);
+                              execution_mode, options);
       iter = eval_const_binop(nir_op_udiv, bit_size, span, step,
-                              execution_mode);
+                              execution_mode, options);
       break;
 
    case nir_op_fge:
@@ -746,10 +749,11 @@ get_iteration(nir_op cond_op, nir_const_value initial, nir_const_value step,
    case nir_op_feq:
    case nir_op_fneu:
       span = eval_const_binop(nir_op_fsub, bit_size, limit, initial,
-                              execution_mode);
+                              execution_mode, options);
       iter = eval_const_binop(nir_op_fdiv, bit_size, span,
-                              step, execution_mode);
-      iter = eval_const_unop(nir_op_f2i64, bit_size, iter, execution_mode);
+                              step, execution_mode, options);
+      iter = eval_const_unop(nir_op_f2i64, bit_size, iter, execution_mode,
+                             options);
       break;
 
    default:
@@ -768,7 +772,8 @@ will_break_on_first_iteration(nir_const_value step,
                               nir_const_value initial,
                               nir_const_value limit,
                               bool limit_rhs, bool invert_cond,
-                              unsigned execution_mode)
+                              unsigned execution_mode,
+                              const struct nir_shader_compiler_options *options)
 {
    if (trip_offset == 1) {
       nir_op add_op;
@@ -785,7 +790,7 @@ will_break_on_first_iteration(nir_const_value step,
       }
 
       initial = eval_const_binop(add_op, bit_size, initial, step,
-                                 execution_mode);
+                                 execution_mode, options);
    }
 
    nir_const_value *src[2];
@@ -794,7 +799,8 @@ will_break_on_first_iteration(nir_const_value step,
 
    /* Evaluate the loop exit condition */
    nir_const_value result;
-   nir_eval_const_opcode(cond_op, &result, 1, bit_size, src, execution_mode);
+   nir_eval_const_opcode(cond_op, &result, 1, bit_size, src, execution_mode,
+                         options);
 
    return invert_cond ? !result.b : result.b;
 }
@@ -804,7 +810,8 @@ test_iterations(int32_t iter_int, nir_const_value step,
                 nir_const_value limit, nir_op cond_op, unsigned bit_size,
                 nir_alu_type induction_base_type,
                 nir_const_value initial, bool limit_rhs, bool invert_cond,
-                unsigned execution_mode)
+                unsigned execution_mode,
+                const struct nir_shader_compiler_options *options)
 {
    assert(nir_op_infos[cond_op].num_inputs == 2);
 
@@ -831,11 +838,13 @@ test_iterations(int32_t iter_int, nir_const_value step,
     * step the induction variable each iteration.
     */
    nir_const_value mul_result =
-      eval_const_binop(mul_op, bit_size, iter_src, step, execution_mode);
+      eval_const_binop(mul_op, bit_size, iter_src, step, execution_mode,
+                       options);
 
    /* Add the initial value to the accumulated induction variable total */
    nir_const_value add_result =
-      eval_const_binop(add_op, bit_size, mul_result, initial, execution_mode);
+      eval_const_binop(add_op, bit_size, mul_result, initial, execution_mode,
+                       options);
 
    nir_const_value *src[2];
    src[limit_rhs ? 0 : 1] = &add_result;
@@ -843,7 +852,8 @@ test_iterations(int32_t iter_int, nir_const_value step,
 
    /* Evaluate the loop exit condition */
    nir_const_value result;
-   nir_eval_const_opcode(cond_op, &result, 1, bit_size, src, execution_mode);
+   nir_eval_const_opcode(cond_op, &result, 1, bit_size, src, execution_mode,
+                         options);
 
    return invert_cond ? !result.b : result.b;
 }
@@ -852,7 +862,8 @@ static int
 calculate_iterations(nir_const_value initial, nir_const_value step,
                      nir_const_value limit, nir_alu_instr *alu,
                      nir_ssa_scalar cond, nir_op alu_op, bool limit_rhs,
-                     bool invert_cond, unsigned execution_mode)
+                     bool invert_cond, unsigned execution_mode,
+                     const struct nir_shader_compiler_options *options)
 {
    /* nir_op_isub should have been lowered away by this point */
    assert(alu->op != nir_op_isub);
@@ -902,12 +913,12 @@ calculate_iterations(nir_const_value initial, nir_const_value step,
    if (will_break_on_first_iteration(step, induction_base_type, trip_offset,
                                      alu_op, bit_size, initial,
                                      limit, limit_rhs, invert_cond,
-                                     execution_mode)) {
+                                     execution_mode, options)) {
       return 0;
    }
 
    int iter_int = get_iteration(alu_op, initial, step, limit, bit_size,
-                                execution_mode);
+                                execution_mode, options);
 
    /* If iter_int is negative the loop is ill-formed or is the conditional is
     * unsigned with a huge iteration count so don't bother going any further.
@@ -929,7 +940,7 @@ calculate_iterations(nir_const_value initial, nir_const_value step,
 
       if (test_iterations(iter_bias, step, limit, alu_op, bit_size,
                           induction_base_type, initial,
-                          limit_rhs, invert_cond, execution_mode)) {
+                          limit_rhs, invert_cond, execution_mode, options)) {
          return iter_bias > 0 ? iter_bias - trip_offset : iter_bias;
       }
    }
@@ -1056,7 +1067,8 @@ try_find_trip_count_vars_in_iand(nir_ssa_scalar *cond,
  * loop.
  */
 static void
-find_trip_count(loop_info_state *state, unsigned execution_mode)
+find_trip_count(loop_info_state *state, unsigned execution_mode,
+                const struct nir_shader_compiler_options *options)
 {
    bool trip_count_known = true;
    bool guessed_trip_count = false;
@@ -1173,7 +1185,8 @@ find_trip_count(loop_info_state *state, unsigned execution_mode)
                                             ind_var->alu, cond,
                                             alu_op, limit_rhs,
                                             terminator->continue_from_then,
-                                            execution_mode);
+                                            execution_mode,
+                                            options);
 
       /* Where we not able to calculate the iteration count */
       if (iterations == -1) {
@@ -1333,7 +1346,7 @@ get_loop_info(loop_info_state *state, nir_function_impl *impl)
       return;
 
    /* Run through each of the terminators and try to compute a trip-count */
-   find_trip_count(state, impl->function->shader->info.float_controls_execution_mode);
+   find_trip_count(state, shader->info.float_controls_execution_mode, options);
 
    nir_foreach_block_in_cf_node(block, &state->loop->cf_node) {
       if (force_unroll_heuristics(state, block)) {
diff --git a/src/compiler/nir/nir_opt_constant_folding.c b/src/compiler/nir/nir_opt_constant_folding.c
index ea1e0977e296..1be300a9b06c 100644
--- a/src/compiler/nir/nir_opt_constant_folding.c
+++ b/src/compiler/nir/nir_opt_constant_folding.c
@@ -97,7 +97,8 @@ try_fold_alu(nir_builder *b, nir_alu_instr *alu)
       srcs[i] = src[i];
    nir_eval_const_opcode(alu->op, dest, alu->dest.dest.ssa.num_components,
                          bit_size, srcs,
-                         b->shader->info.float_controls_execution_mode);
+                         b->shader->info.float_controls_execution_mode,
+                         b->shader->options);
 
    b->cursor = nir_before_instr(&alu->instr);
    nir_ssa_def *imm = nir_build_imm(b, alu->dest.dest.ssa.num_components,
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index 7c10c9729cf5..018d8288d484 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -2267,7 +2267,8 @@ vtn_handle_constant(struct vtn_builder *b, SpvOp opcode,
          };
          nir_eval_const_opcode(op, val->constant->values,
                                num_components, bit_size, srcs,
-                               b->shader->info.float_controls_execution_mode);
+                               b->shader->info.float_controls_execution_mode,
+                               b->shader->options);
          break;
       } /* default */
       }
-- 
GitLab


From 2bb6c9b1822f7c6d7c8ecf675daf3d9ad6103678 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 23 Jul 2022 11:32:04 -0400
Subject: [PATCH 2/4] nir: add NIR shader option float_to_int_clamps, const
 expr. code

---
 src/compiler/nir/nir.h                       |  7 ++++++
 src/compiler/nir/nir_constant_expressions.py |  5 +++--
 src/compiler/nir/nir_opcodes.py              | 23 ++++++++++++++++++++
 3 files changed, 33 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 9cc5efb3317d..13d15a316738 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3676,6 +3676,13 @@ typedef struct nir_shader_compiler_options {
     * fragment task is far more than vertex one, so better left it disabled.
     */
    bool lower_varying_from_uniform;
+
+   /**
+    * Floating-point values outside the integer range are clamped.
+    * f2u clamps to [0, uintN_max]. f2i clamps to [intN_min, intN_max].
+    * NaN is converted to 0.
+    */
+   bool float_to_int_clamps;
 } nir_shader_compiler_options;
 
 typedef struct nir_shader {
diff --git a/src/compiler/nir/nir_constant_expressions.py b/src/compiler/nir/nir_constant_expressions.py
index ada9e1d89ba7..c45e1e2fe4db 100644
--- a/src/compiler/nir/nir_constant_expressions.py
+++ b/src/compiler/nir/nir_constant_expressions.py
@@ -466,7 +466,8 @@ evaluate_${name}(nir_const_value *_dst_val,
                  UNUSED unsigned num_components,
                  ${"UNUSED" if op_bit_sizes(op) is None else ""} unsigned bit_size,
                  UNUSED nir_const_value **_src,
-                 UNUSED unsigned execution_mode)
+                 UNUSED unsigned execution_mode,
+                 UNUSED const struct nir_shader_compiler_options *options)
 {
    % if op_bit_sizes(op) is not None:
       switch (bit_size) {
@@ -501,7 +502,7 @@ nir_eval_const_opcode(nir_op op, nir_const_value *dest,
    switch (op) {
 % for name in sorted(opcodes.keys()):
    case nir_op_${name}:
-      evaluate_${name}(dest, num_components, bit_width, src, float_controls_execution_mode);
+      evaluate_${name}(dest, num_components, bit_width, src, float_controls_execution_mode, options);
       return;
 % endfor
    default:
diff --git a/src/compiler/nir/nir_opcodes.py b/src/compiler/nir/nir_opcodes.py
index dded4a6a6355..8f1aad5c3fb4 100644
--- a/src/compiler/nir/nir_opcodes.py
+++ b/src/compiler/nir/nir_opcodes.py
@@ -276,6 +276,29 @@ for src_t in [tint, tuint, tfloat, tbool]:
               unop_numeric_convert("{0}2{1}{2}".format(src_t[0], dst_t[0],
                                                        dst_bit_size),
                                    dst_t + str(dst_bit_size), src_t, conv_expr)
+          elif dst_t == tuint and src_t == tfloat:
+              max = '(double)UINT{0}_MAX'.format(dst_bit_size) if dst_bit_size > 1 else '1'
+              conv_expr = """
+              if (options->float_to_int_clamps)
+                  dst = src0 >= {0} ? {0} : src0 >= 0 ? src0 : 0;
+              else
+                  dst = src0;
+              """.format(max)
+              unop_numeric_convert("{0}2{1}{2}".format(src_t[0], dst_t[0],
+                                                       dst_bit_size),
+                                   dst_t + str(dst_bit_size), src_t, conv_expr)
+          elif dst_t == tint and src_t == tfloat:
+              max = '(double)INT{0}_MAX'.format(dst_bit_size) if dst_bit_size > 1 else '0'
+              min = '(double)INT{0}_MIN'.format(dst_bit_size) if dst_bit_size > 1 else '-1'
+              conv_expr = """
+              if (options->float_to_int_clamps)
+                  dst = src0 >= {0} ? {0} : src0 >= {1} ? src0 : !isnan(src0) ? {1} : 0;
+              else
+                  dst = src0;
+              """.format(max, min)
+              unop_numeric_convert("{0}2{1}{2}".format(src_t[0], dst_t[0],
+                                                       dst_bit_size),
+                                   dst_t + str(dst_bit_size), src_t, conv_expr)
           else:
               conv_expr = "src0 != 0" if dst_t == tbool else "src0"
               unop_numeric_convert("{0}2{1}{2}".format(src_t[0], dst_t[0],
-- 
GitLab


From 40ebf5a76fc116b77a0cfae397876495e27944ef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 23 Jul 2022 11:34:59 -0400
Subject: [PATCH 3/4] radeonsi,radv: set float_to_int_clamps

---
 src/amd/vulkan/radv_shader.c          | 1 +
 src/gallium/drivers/radeonsi/si_get.c | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 9d31ba7bd20b..565e22e89884 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -111,6 +111,7 @@ get_nir_options_for_stage(struct radv_physical_device *device, gl_shader_stage s
                              nir_lower_iadd_sat64,
       .lower_doubles_options = nir_lower_drcp | nir_lower_dsqrt | nir_lower_drsq | nir_lower_ddiv,
       .divergence_analysis_options = nir_divergence_view_index_uniform,
+      .float_to_int_clamps = true,
    };
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index fcd4fd7b364d..2079d708f710 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -1146,6 +1146,7 @@ void si_init_screen_get_functions(struct si_screen *sscreen)
       .support_indirect_inputs = BITFIELD_BIT(MESA_SHADER_TESS_CTRL) |
                                  BITFIELD_BIT(MESA_SHADER_TESS_EVAL),
       .support_indirect_outputs = BITFIELD_BIT(MESA_SHADER_TESS_CTRL),
+      .float_to_int_clamps = true,
    };
    sscreen->nir_options = nir_options;
 }
-- 
GitLab


From 1453fa997949ee1880f522942727bce54a423d5b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 18 Jul 2022 07:29:18 -0400
Subject: [PATCH 4/4] nir/algebraic: add floor + f2i/f2u patterns

---
 src/compiler/nir/nir_opt_algebraic.py | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index f7f1da5aac57..191aa8d69672 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -362,6 +362,9 @@ optimizations.extend([
    (('~flrp', a, 0.0, c), ('fadd', ('fmul', ('fneg', a), c), a)),
    (('ftrunc', a), ('bcsel', ('flt', a, 0.0), ('fneg', ('ffloor', ('fabs', a))), ('ffloor', ('fabs', a))), 'options->lower_ftrunc'),
 
+   (('~f2i', ('ffloor', 'a(is_not_negative)')), ('f2i', a), 'options->float_to_int_clamps'),
+   (('~f2u', ('ffloor', a)), ('f2u', a), 'options->float_to_int_clamps'),
+
    (('ffloor@16', a), ('fsub', a, ('ffract', a)), 'options->lower_ffloor'),
    (('ffloor@32', a), ('fsub', a, ('ffract', a)), 'options->lower_ffloor'),
    (('ffloor@64', a), ('fsub', a, ('ffract', a)), 'options->lower_ffloor || ((options->lower_doubles_options & nir_lower_dfloor) && !(options->lower_doubles_options & nir_lower_dfloor))'),
-- 
GitLab

