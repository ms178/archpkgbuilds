--- a/src/amd/compiler/aco_register_allocation.cpp	2025-09-25 22:57:05.295169039 +0200
+++ b/src/amd/compiler/aco_register_allocation.cpp	2026-01-24 23:32:22.608138550 +0200
@@ -16,6 +16,16 @@
 #include <optional>
 #include <vector>
 
+#if defined(__clang__) || defined(__GNUC__)
+#define ACO_HOT [[gnu::hot]]
+#define LIKELY(x)   (__builtin_expect(!!(x), 1))
+#define UNLIKELY(x) (__builtin_expect(!!(x), 0))
+#else
+#define ACO_HOT
+#define LIKELY(x)   (x)
+#define UNLIKELY(x) (x)
+#endif
+
 namespace aco {
 namespace {
 
@@ -323,7 +333,11 @@ public:
    RegisterFile() { regs.fill(0); }
 
    std::array<uint32_t, 512> regs;
-   std::map<uint32_t, std::array<uint32_t, 4>> subdword_regs;
+   /* Replacing std::map with std::vector for contiguous memory and fast copies.
+    * This dramatically reduces overhead when RegisterFile is copied during backtracking.
+    * The vector is always sorted by register index. */
+   using SubDwordEntry = std::pair<unsigned, std::array<uint32_t, 4>>;
+   std::vector<SubDwordEntry> subdword_regs;
 
    const uint32_t& operator[](PhysReg index) const { return regs[index]; }
 
@@ -348,20 +362,51 @@ public:
    /* Returns true if any of the bytes in the given range are allocated or blocked */
    bool test(PhysReg start, unsigned num_bytes) const
    {
-      for (PhysReg i = start; i.reg_b < start.reg_b + num_bytes; i = PhysReg(i + 1)) {
-         assert(i <= 511);
-         if (regs[i] & 0x0FFFFFFF)
-            return true;
-         if (regs[i] == 0xF0000000) {
-            auto it = subdword_regs.find(i);
-            assert(it != subdword_regs.end());
-            for (unsigned j = i.byte(); i * 4 + j < start.reg_b + num_bytes && j < 4; j++) {
-               if (it->second[j])
-                  return true;
-            }
+         const unsigned start_b = start.reg_b;
+         const unsigned end_b = start_b + num_bytes;
+
+         if (end_b <= start_b)
+               return false;
+
+         const unsigned first_dw = start_b >> 2;
+         const unsigned last_dw_excl = (end_b + 3u) >> 2;
+
+         assert(last_dw_excl <= 512u);
+
+         for (unsigned dw = first_dw; dw < last_dw_excl; ++dw) {
+               const PhysReg dwr{dw};
+               const uint32_t val = regs[dwr];
+
+               if (val & 0x0FFFFFFFu)
+                     return true;
+
+               if (val == 0xF0000000u) {
+                     auto it = std::lower_bound(subdword_regs.begin(), subdword_regs.end(), dw,
+                                                [](const SubDwordEntry& entry, unsigned idx)
+                                                { return entry.first < idx; });
+
+                     if (it != subdword_regs.end() && it->first == dw) {
+                           const std::array<uint32_t, 4>& sub = it->second;
+
+                           const unsigned dw_lo_b = dw << 2;
+                           const unsigned lo = (dw == first_dw) ? (start_b - dw_lo_b) : 0u;
+
+                           unsigned hi_b = dw_lo_b + 4u;
+                           if (hi_b > end_b)
+                                 hi_b = end_b;
+
+                           const unsigned hi = hi_b - dw_lo_b;
+                           assert(hi <= 4u);
+
+                           for (unsigned j = lo; j < hi; ++j) {
+                                 if (sub[j] != 0u)
+                                       return true;
+                           }
+                     }
+               }
          }
-      }
-      return false;
+
+         return false;
    }
 
    void block(PhysReg start, RegClass rc)
@@ -381,11 +426,13 @@ public:
       if (regs[start] == 0xFFFFFFFF)
          return true;
       if (regs[start] == 0xF0000000) {
-         auto it = subdword_regs.find(start);
-         assert(it != subdword_regs.end());
-         for (unsigned i = start.byte(); i < 4; i++)
-            if (it->second[i] == 0xFFFFFFFF)
-               return true;
+         auto it = std::lower_bound(subdword_regs.begin(), subdword_regs.end(), start.reg(),
+            [](const SubDwordEntry& entry, unsigned val) { return entry.first < val; });
+         if (it != subdword_regs.end() && it->first == start.reg()) {
+            for (unsigned i = start.byte(); i < 4; i++)
+               if (it->second[i] == 0xFFFFFFFF)
+                  return true;
+         }
       }
       return false;
    }
@@ -395,8 +442,9 @@ public:
       /* Empty is 0, blocked is 0xFFFFFFFF, so to check both we compare the
        * incremented value to 1 */
       if (regs[start] == 0xF0000000) {
-         auto it = subdword_regs.find(start);
-         assert(it != subdword_regs.end());
+         auto it = std::lower_bound(subdword_regs.begin(), subdword_regs.end(), start.reg(),
+            [](const SubDwordEntry& entry, unsigned val) { return entry.first < val; });
+         assert(it != subdword_regs.end() && it->first == start.reg());
          return it->second[start.byte()] + 1 <= 1;
       }
       return regs[start] + 1 <= 1;
@@ -443,7 +491,12 @@ public:
 
    unsigned get_id(PhysReg reg) const
    {
-      return regs[reg] == 0xF0000000 ? subdword_regs.at(reg)[reg.byte()] : regs[reg];
+      if (regs[reg] == 0xF0000000) {
+         auto it = std::lower_bound(subdword_regs.begin(), subdword_regs.end(), reg.reg(),
+            [](const SubDwordEntry& entry, unsigned val) { return entry.first < val; });
+         return it->second[reg.byte()];
+      }
+      return regs[reg];
    }
 
 private:
@@ -455,19 +508,48 @@ private:
 
    void fill_subdword(PhysReg start, unsigned num_bytes, uint32_t val)
    {
-      fill(start, DIV_ROUND_UP(num_bytes, 4), 0xF0000000);
-      for (PhysReg i = start; i.reg_b < start.reg_b + num_bytes; i = PhysReg(i + 1)) {
-         /* emplace or get */
-         std::array<uint32_t, 4>& sub =
-            subdword_regs.emplace(i, std::array<uint32_t, 4>{0, 0, 0, 0}).first->second;
-         for (unsigned j = i.byte(); i * 4 + j < start.reg_b + num_bytes && j < 4; j++)
-            sub[j] = val;
-
-         if (sub == std::array<uint32_t, 4>{0, 0, 0, 0}) {
-            subdword_regs.erase(i);
-            regs[i] = 0;
+         const unsigned start_b = start.reg_b;
+         const unsigned end_b = start_b + num_bytes;
+
+         if (end_b <= start_b)
+               return;
+
+         const unsigned first_dw = start_b >> 2;
+         const unsigned last_dw_excl = (end_b + 3u) >> 2;
+
+         assert(last_dw_excl <= 512u);
+
+         fill(PhysReg{first_dw}, last_dw_excl - first_dw, 0xF0000000u);
+
+         for (unsigned dw = first_dw; dw < last_dw_excl; ++dw) {
+               auto it = std::lower_bound(subdword_regs.begin(), subdword_regs.end(), dw,
+                                          [](const SubDwordEntry& entry, unsigned idx)
+                                          { return entry.first < idx; });
+
+               if (it == subdword_regs.end() || it->first != dw) {
+                     it = subdword_regs.insert(it, {dw, {0u, 0u, 0u, 0u}});
+               }
+
+               std::array<uint32_t, 4>& sub = it->second;
+
+               const unsigned dw_lo_b = dw << 2;
+               const unsigned lo = (dw == first_dw) ? (start_b - dw_lo_b) : 0u;
+
+               unsigned hi_b = dw_lo_b + 4u;
+               if (hi_b > end_b)
+                     hi_b = end_b;
+
+               const unsigned hi = hi_b - dw_lo_b;
+               assert(hi <= 4u);
+
+               for (unsigned j = lo; j < hi; ++j)
+                     sub[j] = val;
+
+               if (sub == std::array<uint32_t, 4>{0u, 0u, 0u, 0u}) {
+                     subdword_regs.erase(it);
+                     regs[PhysReg{dw}] = 0u;
+               }
          }
-      }
    }
 };
 
@@ -492,11 +574,19 @@ print_reg(const RegisterFile& reg_file,
             // clang-format on
          };
          unsigned index = 0;
-         for (int i = 0; i < 4; ++i) {
-            if (reg_file.subdword_regs.at(reg)[i]) {
-               index |= 1 << i;
-            }
+
+         /* Correctly access the vector-based subdword registry */
+         auto it = std::lower_bound(reg_file.subdword_regs.begin(), reg_file.subdword_regs.end(), reg.reg(),
+            [](const RegisterFile::SubDwordEntry& entry, unsigned val) { return entry.first < val; });
+
+         if (it != reg_file.subdword_regs.end() && it->first == reg.reg()) {
+             for (int i = 0; i < 4; ++i) {
+                if (it->second[i]) {
+                   index |= 1 << i;
+                }
+             }
          }
+
          printf("%s", (const char*)(block_chars.begin()[index]));
       } else {
          /* Indicate filled register slot */
@@ -589,12 +679,15 @@ print_regs(ra_ctx& ctx, PhysRegInterval
 bool
 is_sgpr_writable_without_side_effects(amd_gfx_level gfx_level, PhysReg reg)
 {
-   assert(reg < 256);
-   bool has_flat_scr_lo_gfx89 = gfx_level >= GFX8 && gfx_level <= GFX9;
-   bool has_flat_scr_lo_gfx7_or_xnack_mask = gfx_level <= GFX9;
-   return (reg <= vcc_hi || reg == m0) &&
-          (!has_flat_scr_lo_gfx89 || (reg != flat_scr_lo && reg != flat_scr_hi)) &&
-          (!has_flat_scr_lo_gfx7_or_xnack_mask || (reg != 104 || reg != 105));
+   assert(reg.reg() < 256);
+   const bool has_flat_scr_lo_gfx89 = gfx_level >= GFX8 && gfx_level <= GFX9;
+   const bool has_flat_scr_lo_gfx7_or_xnack_mask = gfx_level <= GFX9;
+
+   return (reg.reg() <= vcc_hi.reg() || reg.reg() == m0.reg()) &&
+          (!has_flat_scr_lo_gfx89 ||
+           (reg.reg() != flat_scr_lo.reg() && reg.reg() != flat_scr_hi.reg())) &&
+          (!has_flat_scr_lo_gfx7_or_xnack_mask ||
+           (reg.reg() != 104 && reg.reg() != 105));
 }
 
 static bool
@@ -1090,60 +1183,118 @@ update_renames(ra_ctx& ctx, RegisterFile
 
 /* First value in the pair is the register. The second is the number of preserved registers used.
  * This pair can be passed as the "best" parameter for another get_reg_simple() call. */
-std::optional<std::pair<PhysReg, uint32_t>>
+ACO_HOT std::optional<std::pair<PhysReg, uint32_t>>
 get_reg_simple(ra_ctx& ctx, const RegisterFile& reg_file, DefInfo info,
                std::optional<std::pair<PhysReg, uint32_t>> best = {})
 {
    PhysRegInterval bounds = info.bounds;
-   uint32_t size = info.size;
-   uint32_t stride = DIV_ROUND_UP(info.stride, 4);
-   RegClass rc = info.rc;
+   const uint32_t size = info.size;                        /* dwords */
+   const uint32_t stride = DIV_ROUND_UP(info.stride, 4u);  /* dwords */
+   const RegClass rc = info.rc;
+
+   assert(size > 0);
+   assert(bounds.size >= size);
 
-   if (stride < size && !rc.is_subdword()) {
+   /* Try larger stride recursively (same policy as original). */
+   if (!rc.is_subdword() && stride < size) {
       DefInfo new_info = info;
-      new_info.stride = info.stride * 2;
-      if (size % (stride * 2) == 0) {
+      new_info.stride = info.stride * 2u;
+      const uint32_t new_stride = DIV_ROUND_UP(new_info.stride, 4u);
+      if (size % new_stride == 0u) {
          best = get_reg_simple(ctx, reg_file, new_info, best);
-         if (best && best->second == 0)
+         if (best && best->second == 0u)
             return best;
       }
    }
 
    PhysRegIterator& rr_it = rc.type() == RegType::vgpr ? ctx.rr_vgpr_it : ctx.rr_sgpr_it;
-   if (stride == 1) {
-      if (rr_it != bounds.begin() && bounds.contains(rr_it.reg)) {
-         assert(bounds.begin() < rr_it);
-         assert(rr_it < bounds.end());
-         info.bounds = PhysRegInterval::from_until(rr_it.reg, bounds.hi());
-         best = get_reg_simple(ctx, reg_file, info, best);
-         if (best && best->second == 0)
-            return best;
-         bounds = PhysRegInterval::from_until(bounds.lo(), rr_it.reg);
-      }
-   }
 
-   for (PhysRegInterval reg_win = {bounds.lo(), size}; reg_win.hi() <= bounds.hi();
-        reg_win += stride) {
-      bool found = true;
-      unsigned num_preserved = 0;
-      for (PhysReg reg : reg_win) {
-         if (reg_file[reg] != 0 || ctx.war_hint[reg]) {
-            found = false;
-            break;
+   if (stride == 1u && !rc.is_subdword()) {
+      const unsigned lo_dw = bounds.lo().reg();
+      const unsigned hi_dw = bounds.hi().reg();
+      assert(hi_dw > lo_dw);
+
+      const unsigned rr_dw =
+         (rr_it != bounds.begin() && bounds.contains(rr_it.reg)) ? rr_it.reg.reg() : lo_dw;
+
+      auto scan_range = [&](unsigned start_dw, unsigned end_dw,
+                            std::optional<std::pair<PhysReg, uint32_t>>& local_best) -> bool
+      {
+         const unsigned len = end_dw - start_dw;
+         assert(len <= 512u);
+
+         /* Prefix sum of preserved regs for O(1) window preserved count. */
+         std::array<unsigned, 513> prefix;
+         prefix[0] = 0u;
+         for (unsigned k = 0u; k < len; ++k)
+            prefix[k + 1u] = prefix[k] + BITSET_TEST(ctx.preserved, start_dw + k);
+
+         const uint32_t* const regs = reg_file.regs.data();
+         unsigned run_len = 0u;
+
+         for (unsigned i = start_dw; i < end_dw; ++i) {
+            const PhysReg pr{i};
+            if (LIKELY(regs[i] == 0u && !ctx.war_hint[pr])) {
+               ++run_len;
+               if (run_len >= size) {
+                  const unsigned rel = i - start_dw;
+                  const unsigned end = rel + 1u;
+                  const unsigned preserved = prefix[end] - prefix[end - size];
+                  PhysReg found{i + 1u - size};
+
+                  if (!local_best || preserved < local_best->second) {
+                     local_best.emplace(found, preserved);
+                     if (preserved == 0u)
+                        return true;
+                  }
+               }
+            } else {
+               run_len = 0u;
+            }
          }
-         num_preserved += BITSET_TEST(ctx.preserved, reg);
+         return false;
+      };
+
+      if (rr_dw > lo_dw) {
+         if (scan_range(rr_dw, hi_dw, best) && best && best->second == 0u)
+            goto finish;
+         if (scan_range(lo_dw, rr_dw, best) && best && best->second == 0u)
+            goto finish;
+      } else {
+         if (scan_range(lo_dw, hi_dw, best) && best && best->second == 0u)
+            goto finish;
       }
-      if (!found)
-         continue;
+   } else {
+      for (PhysRegInterval reg_win = {bounds.lo(), size};
+           reg_win.hi() <= bounds.hi();
+           reg_win += stride) {
+
+         bool all_free = true;
+         unsigned num_preserved = 0u;
+
+         for (PhysReg reg : reg_win) {
+            const uint32_t val = reg_file[reg];
+            if (UNLIKELY(val != 0u) || UNLIKELY(ctx.war_hint[reg])) {
+               all_free = false;
+               break;
+            }
+            num_preserved += BITSET_TEST(ctx.preserved, reg.reg());
+         }
 
-      if (!best || num_preserved < best->second) {
-         best.emplace(reg_win.lo(), num_preserved);
-         if (num_preserved == 0)
-            break;
+         if (!all_free)
+            continue;
+
+         if (!best || num_preserved < best->second) {
+            best.emplace(reg_win.lo(), num_preserved);
+            if (num_preserved == 0u)
+               break;
+         }
       }
    }
+
+finish:
    if (best) {
-      if (stride == 1) {
+      if (stride == 1u) {
          PhysRegIterator new_rr_it{PhysReg{best->first + size}};
          if (new_rr_it < bounds.end())
             rr_it = new_rr_it;
@@ -1152,33 +1303,35 @@ get_reg_simple(ra_ctx& ctx, const Regist
       return best;
    }
 
-   /* do this late because using the upper bytes of a register can require
-    * larger instruction encodings or copies
-    * TODO: don't do this in situations where it doesn't benefit */
    if (rc.is_subdword()) {
-      for (const std::pair<const uint32_t, std::array<uint32_t, 4>>& entry :
-           reg_file.subdword_regs) {
-         assert(reg_file[PhysReg{entry.first}] == 0xF0000000);
-         if (!bounds.contains({PhysReg{entry.first}, rc.size()}))
+      for (const RegisterFile::SubDwordEntry& entry : reg_file.subdword_regs) {
+         const unsigned dw = entry.first;
+         const PhysReg dw_reg{dw};
+
+         if (!bounds.contains(PhysRegInterval{dw_reg, rc.size()}))
             continue;
 
-         auto it = entry.second.begin();
-         for (unsigned i = 0; i < 4; i += info.stride) {
-            /* check if there's a block of free bytes large enough to hold the register */
-            bool reg_found =
-               std::all_of(std::next(it, i), std::next(it, std::min(4u, i + rc.bytes())),
-                           [](unsigned v) { return v == 0; });
-
-            /* check if also the neighboring reg is free if needed */
-            if (reg_found && i + rc.bytes() > 4)
-               reg_found = (reg_file[PhysReg{entry.first + 1}] == 0);
+         const std::array<uint32_t, 4>& sub = entry.second;
+
+         for (unsigned i = 0u; i < 4u; i += info.stride) {
+            bool reg_found = true;
+            for (unsigned j = 0u; j < rc.bytes() && (i + j) < 4u; ++j) {
+               if (sub[i + j] != 0u) {
+                  reg_found = false;
+                  break;
+               }
+            }
+
+            if (reg_found && (i + rc.bytes() > 4u)) {
+               if (reg_file[PhysReg{dw + 1u}] != 0u)
+                  reg_found = false;
+            }
 
             if (reg_found) {
-               PhysReg res{entry.first};
+               PhysReg res{dw};
                res.reg_b += i;
-               adjust_max_used_regs(ctx, rc, entry.first);
-               best.emplace(res, BITSET_TEST(ctx.preserved, entry.first));
-               return best;
+               adjust_max_used_regs(ctx, rc, dw);
+               return std::make_pair(res, BITSET_TEST(ctx.preserved, dw));
             }
          }
       }
@@ -1188,25 +1341,62 @@ get_reg_simple(ra_ctx& ctx, const Regist
 }
 
 /* collect variables from a register area */
-std::vector<unsigned>
+ACO_HOT std::vector<unsigned>
 find_vars(ra_ctx& ctx, const RegisterFile& reg_file, const PhysRegInterval reg_interval)
 {
    std::vector<unsigned> vars;
-   for (PhysReg j : reg_interval) {
-      if (reg_file.is_blocked(j))
+   vars.reserve(16);
+
+   unsigned j = reg_interval.lo().reg();
+   const unsigned end = reg_interval.hi().reg();
+
+   while (j < end) {
+      const PhysReg pj{j};
+
+      if (reg_file.is_blocked(pj)) {
+         ++j;
+         continue;
+      }
+
+      const uint32_t val = reg_file.regs[pj];
+
+      if (val == 0u) {
+         ++j;
          continue;
-      if (reg_file[j] == 0xF0000000) {
-         for (unsigned k = 0; k < 4; k++) {
-            unsigned id = reg_file.subdword_regs.at(j)[k];
-            if (id && (vars.empty() || id != vars.back()))
-               vars.emplace_back(id);
+      }
+
+      if (val == 0xF0000000u) {
+         auto it =
+            std::lower_bound(reg_file.subdword_regs.begin(), reg_file.subdword_regs.end(), j,
+                             [](const RegisterFile::SubDwordEntry& entry, unsigned idx)
+                             { return entry.first < idx; });
+
+         if (it != reg_file.subdword_regs.end() && it->first == j) {
+            const std::array<uint32_t, 4>& sub = it->second;
+            for (unsigned k = 0u; k < 4u; ++k) {
+               const unsigned id = sub[k];
+               if (id != 0u && (vars.empty() || id != vars.back()))
+                  vars.emplace_back(id);
+            }
          }
-      } else {
-         unsigned id = reg_file[j];
-         if (id && (vars.empty() || id != vars.back()))
-            vars.emplace_back(id);
+
+         ++j;
+         continue;
       }
+
+      const unsigned id = val;
+      const assignment& var = ctx.assignments[id];
+
+      if (vars.empty() || id != vars.back())
+         vars.emplace_back(id);
+
+      const unsigned step = var.rc.size();
+      assert(step >= 1u);
+
+      const unsigned next = j + step;
+      j = next > end ? end : next;
    }
+
    return vars;
 }
 
@@ -1214,23 +1404,31 @@ find_vars(ra_ctx& ctx, const RegisterFil
  * variables are sorted in decreasing size and
  * increasing assigned register
  */
-std::vector<unsigned>
+ACO_HOT std::vector<unsigned>
 collect_vars(ra_ctx& ctx, RegisterFile& reg_file, const PhysRegInterval reg_interval)
 {
    std::vector<unsigned> ids = find_vars(ctx, reg_file, reg_interval);
+
    std::sort(ids.begin(), ids.end(),
              [&](unsigned a, unsigned b)
              {
-                assignment& var_a = ctx.assignments[a];
-                assignment& var_b = ctx.assignments[b];
-                return var_a.rc.bytes() > var_b.rc.bytes() ||
-                       (var_a.rc.bytes() == var_b.rc.bytes() && var_a.reg < var_b.reg);
+                const assignment& var_a = ctx.assignments[a];
+                const assignment& var_b = ctx.assignments[b];
+
+                const unsigned bytes_a = var_a.rc.bytes();
+                const unsigned bytes_b = var_b.rc.bytes();
+
+                if (bytes_a != bytes_b)
+                   return bytes_a > bytes_b;
+
+                return var_a.reg < var_b.reg;
              });
 
    for (unsigned id : ids) {
-      assignment& var = ctx.assignments[id];
+      const assignment& var = ctx.assignments[id];
       reg_file.clear(var.reg, var.rc);
    }
+
    return ids;
 }
 
