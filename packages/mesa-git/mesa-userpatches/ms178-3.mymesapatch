--- a/src/amd/compiler/aco_register_allocation.cpp	2025-09-25 22:57:05.295169039 +0200
+++ b/src/amd/compiler/aco_register_allocation.cpp	2025-09-25 23:32:22.608138550 +0200
@@ -16,6 +16,16 @@
 #include <optional>
 #include <vector>
 
+#if defined(__clang__) || defined(__GNUC__)
+#define ACO_HOT [[gnu::hot]]
+#define LIKELY(x)   (__builtin_expect(!!(x), 1))
+#define UNLIKELY(x) (__builtin_expect(!!(x), 0))
+#else
+#define ACO_HOT
+#define LIKELY(x)   (x)
+#define UNLIKELY(x) (x)
+#endif
+
 namespace aco {
 namespace {
 
@@ -329,18 +339,31 @@ public:
       return res;
    }
 
-   /* Returns true if any of the bytes in the given range are allocated or blocked */
    bool test(PhysReg start, unsigned num_bytes) const
    {
-      for (PhysReg i = start; i.reg_b < start.reg_b + num_bytes; i = PhysReg(i + 1)) {
-         assert(i <= 511);
-         if (regs[i] & 0x0FFFFFFF)
+      unsigned start_b = start.reg_b;
+      unsigned end_b = start_b + num_bytes;
+      unsigned first_dw = start_b >> 2;
+      unsigned last_dw_excl = (end_b + 3) >> 2; // ceil(end_b/4)
+
+      for (unsigned dw = first_dw; dw < last_dw_excl; ++dw) {
+         PhysReg dwr{dw};
+         const uint32_t val = regs[dwr];
+         if (val & 0x0FFFFFFF) // full-slot used or blocked (except the subdword sentinel)
             return true;
-         if (regs[i] == 0xF0000000) {
-            auto it = subdword_regs.find(i);
+
+         if (val == 0xF0000000) {
+            auto it = subdword_regs.find(dw);
             assert(it != subdword_regs.end());
-            for (unsigned j = i.byte(); i * 4 + j < start.reg_b + num_bytes && j < 4; j++) {
-               if (it->second[j])
+            const auto& sub = it->second;
+
+            const unsigned dw_lo_b = dw << 2;
+            const unsigned lo = (dw == first_dw) ? (start_b - dw_lo_b) : 0;
+            const unsigned hi_b = std::min(end_b, dw_lo_b + 4);
+            const unsigned hi = hi_b - dw_lo_b;
+
+            for (unsigned j = lo; j < hi; ++j) {
+               if (sub[j])
                   return true;
             }
          }
@@ -435,17 +458,29 @@ private:
 
    void fill_subdword(PhysReg start, unsigned num_bytes, uint32_t val)
    {
-      fill(start, DIV_ROUND_UP(num_bytes, 4), 0xF0000000);
-      for (PhysReg i = start; i.reg_b < start.reg_b + num_bytes; i = PhysReg(i + 1)) {
-         /* emplace or get */
-         std::array<uint32_t, 4>& sub =
-            subdword_regs.emplace(i, std::array<uint32_t, 4>{0, 0, 0, 0}).first->second;
-         for (unsigned j = i.byte(); i * 4 + j < start.reg_b + num_bytes && j < 4; j++)
+      unsigned start_b = start.reg_b;
+      unsigned end_b = start_b + num_bytes;
+      unsigned first_dw = start_b >> 2;
+      unsigned last_dw_excl = (end_b + 3) >> 2; // ceil(end_b/4)
+
+      // Mark owning dwords with subdword sentinel
+      fill(PhysReg{first_dw}, last_dw_excl - first_dw, 0xF0000000);
+
+      for (unsigned dw = first_dw; dw < last_dw_excl; ++dw) {
+         auto& sub =
+            subdword_regs.emplace(dw, std::array<uint32_t, 4>{0, 0, 0, 0}).first->second;
+
+         const unsigned dw_lo_b = dw << 2;
+         const unsigned lo = (dw == first_dw) ? (start_b - dw_lo_b) : 0;
+         const unsigned hi_b = std::min(end_b, dw_lo_b + 4);
+         const unsigned hi = hi_b - dw_lo_b;
+
+         for (unsigned j = lo; j < hi; ++j)
             sub[j] = val;
 
          if (sub == std::array<uint32_t, 4>{0, 0, 0, 0}) {
-            subdword_regs.erase(i);
-            regs[i] = 0;
+            subdword_regs.erase(dw);
+            regs[PhysReg{dw}] = 0;
          }
       }
    }
@@ -569,12 +604,12 @@ print_regs(ra_ctx& ctx, PhysRegInterval
 bool
 is_sgpr_writable_without_side_effects(amd_gfx_level gfx_level, PhysReg reg)
 {
-   assert(reg < 256);
+   assert(reg.reg() < 256);
    bool has_flat_scr_lo_gfx89 = gfx_level >= GFX8 && gfx_level <= GFX9;
    bool has_flat_scr_lo_gfx7_or_xnack_mask = gfx_level <= GFX9;
-   return (reg <= vcc_hi || reg == m0) &&
-          (!has_flat_scr_lo_gfx89 || (reg != flat_scr_lo && reg != flat_scr_hi)) &&
-          (!has_flat_scr_lo_gfx7_or_xnack_mask || (reg != 104 || reg != 105));
+   return (reg.reg() <= vcc_hi.reg() || reg.reg() == m0.reg()) &&
+          (!has_flat_scr_lo_gfx89 || (reg.reg() != flat_scr_lo.reg() && reg.reg() != flat_scr_hi.reg())) &&
+          (!has_flat_scr_lo_gfx7_or_xnack_mask || (reg.reg() != 104 && reg.reg() != 105));
 }
 
 static bool
@@ -1056,7 +1091,7 @@ update_renames(ra_ctx& ctx, RegisterFile
    }
 }
 
-std::optional<PhysReg>
+ACO_HOT std::optional<PhysReg>
 get_reg_simple(ra_ctx& ctx, const RegisterFile& reg_file, DefInfo info)
 {
    PhysRegInterval bounds = info.bounds;
@@ -1064,70 +1099,92 @@ get_reg_simple(ra_ctx& ctx, const Regist
    uint32_t stride = DIV_ROUND_UP(info.stride, 4);
    RegClass rc = info.rc;
 
+   // Try larger stride recursively
    if (stride < size && !rc.is_subdword()) {
       DefInfo new_info = info;
       new_info.stride = info.stride * 2;
       if (size % (stride * 2) == 0) {
-         std::optional<PhysReg> res = get_reg_simple(ctx, reg_file, new_info);
-         if (res)
+         if (auto res = get_reg_simple(ctx, reg_file, new_info))
             return res;
       }
    }
 
    PhysRegIterator& rr_it = rc.type() == RegType::vgpr ? ctx.rr_vgpr_it : ctx.rr_sgpr_it;
-   if (stride == 1) {
-      if (rr_it != bounds.begin() && bounds.contains(rr_it.reg)) {
-         assert(bounds.begin() < rr_it);
-         assert(rr_it < bounds.end());
-         info.bounds = PhysRegInterval::from_until(rr_it.reg, bounds.hi());
-         std::optional<PhysReg> res = get_reg_simple(ctx, reg_file, info);
-         if (res)
-            return res;
-         bounds = PhysRegInterval::from_until(bounds.lo(), rr_it.reg);
-      }
-   }
 
-   auto is_free = [&](PhysReg reg_index)
-   { return reg_file[reg_index] == 0 && !ctx.war_hint[reg_index]; };
+   // Fast path: stride=1, non-subdword â†’ O(N) sliding window
+   if (stride == 1 && !rc.is_subdword()) {
+      auto scan_range = [&](unsigned start_dw, unsigned end_dw) -> std::optional<PhysReg> {
+         const uint32_t* regs = reg_file.regs.data();
+         unsigned run = 0;
+         const unsigned base = (rc.type() == RegType::vgpr) ? 256 : 0;
+
+         for (unsigned i = start_dw; i < end_dw; ++i) {
+            const uint32_t val = regs[i];
+            const bool is_free = (val == 0) && !ctx.war_hint[PhysReg{i}];
+            if (LIKELY(is_free)) {
+               if (++run == size) {
+                  PhysReg found{i + 1 - size};
+                  adjust_max_used_regs(ctx, rc, found);
+                  PhysRegIterator new_rr{PhysReg{found + size}};
+                  if (new_rr < bounds.end())
+                     rr_it = new_rr;
+                  return found;
+               }
+            } else {
+               run = 0;
+            }
+         }
+         return {};
+      };
 
-   for (PhysRegInterval reg_win = {bounds.lo(), size}; reg_win.hi() <= bounds.hi();
-        reg_win += stride) {
-      if (std::all_of(reg_win.begin(), reg_win.end(), is_free)) {
-         if (stride == 1) {
-            PhysRegIterator new_rr_it{PhysReg{reg_win.lo() + size}};
-            if (new_rr_it < bounds.end())
-               rr_it = new_rr_it;
+      const unsigned lo = bounds.lo().reg();
+      const unsigned hi = bounds.hi().reg();
+      const unsigned rr = (rr_it != bounds.begin() && bounds.contains(rr_it.reg)) ? rr_it.reg.reg() : lo;
+
+      // Scan from RR cursor first (better hit rate), then wrap
+      if (rr > lo) {
+         if (auto res = scan_range(rr, hi)) return res;
+         if (auto res = scan_range(lo, rr)) return res;
+      } else {
+         if (auto res = scan_range(lo, hi)) return res;
+      }
+   } else {
+      // Original path for stride > 1 or subdword
+      auto is_free = [&](PhysReg reg_index)
+      { return reg_file[reg_index] == 0 && !ctx.war_hint[reg_index]; };
+
+      for (PhysRegInterval reg_win = {bounds.lo(), size}; reg_win.hi() <= bounds.hi();
+           reg_win += stride) {
+         if (std::all_of(reg_win.begin(), reg_win.end(), is_free)) {
+            if (stride == 1) {
+               PhysRegIterator new_rr_it{PhysReg{reg_win.lo() + size}};
+               if (new_rr_it < bounds.end())
+                  rr_it = new_rr_it;
+            }
+            adjust_max_used_regs(ctx, rc, reg_win.lo());
+            return reg_win.lo();
          }
-         adjust_max_used_regs(ctx, rc, reg_win.lo());
-         return reg_win.lo();
       }
    }
 
-   /* do this late because using the upper bytes of a register can require
-    * larger instruction encodings or copies
-    * TODO: don't do this in situations where it doesn't benefit */
+   // Subdword fallback (unchanged)
    if (rc.is_subdword()) {
-      for (const std::pair<const uint32_t, std::array<uint32_t, 4>>& entry :
-           reg_file.subdword_regs) {
-         assert(reg_file[PhysReg{entry.first}] == 0xF0000000);
-         if (!bounds.contains({PhysReg{entry.first}, rc.size()}))
+      for (const auto& entry : reg_file.subdword_regs) {
+         const uint32_t key = entry.first;
+         const std::array<uint32_t, 4>& sub = entry.second;
+         if (!bounds.contains({PhysReg{key}, rc.size()}))
             continue;
-
-         auto it = entry.second.begin();
          for (unsigned i = 0; i < 4; i += info.stride) {
-            /* check if there's a block of free bytes large enough to hold the register */
-            bool reg_found =
-               std::all_of(std::next(it, i), std::next(it, std::min(4u, i + rc.bytes())),
-                           [](unsigned v) { return v == 0; });
-
-            /* check if also the neighboring reg is free if needed */
-            if (reg_found && i + rc.bytes() > 4)
-               reg_found = (reg_file[PhysReg{entry.first + 1}] == 0);
+            bool reg_found = true;
+            for (unsigned j = 0; j < rc.bytes() && (i + j) < 4; ++j)
+               reg_found &= (sub[i + j] == 0);
+            if (reg_found && (i + rc.bytes() > 4))
+               reg_found &= (reg_file[PhysReg{key + 1}] == 0);
 
             if (reg_found) {
-               PhysReg res{entry.first};
+               PhysReg res{key};
                res.reg_b += i;
-               adjust_max_used_regs(ctx, rc, entry.first);
+               adjust_max_used_regs(ctx, rc, key);
                return res;
             }
          }
@@ -1137,44 +1194,66 @@ get_reg_simple(ra_ctx& ctx, const Regist
    return {};
 }
 
-/* collect variables from a register area */
-std::vector<unsigned>
+ACO_HOT std::vector<unsigned>
 find_vars(ra_ctx& ctx, const RegisterFile& reg_file, const PhysRegInterval reg_interval)
 {
    std::vector<unsigned> vars;
-   for (PhysReg j : reg_interval) {
-      if (reg_file.is_blocked(j))
+   vars.reserve(reg_interval.size);
+
+   unsigned j = reg_interval.lo().reg();
+   const unsigned end = reg_interval.hi().reg();
+
+   while (j < end) {
+      PhysReg pj{j};
+
+      if (reg_file.is_blocked(pj)) {
+         ++j;
          continue;
-      if (reg_file[j] == 0xF0000000) {
-         for (unsigned k = 0; k < 4; k++) {
-            unsigned id = reg_file.subdword_regs.at(j)[k];
+      }
+
+      const uint32_t val = reg_file.regs[pj];
+      if (val == 0) {
+         ++j;
+         continue;
+      }
+
+      if (val == 0xF0000000) {
+         auto it = reg_file.subdword_regs.find(pj);
+         assert(it != reg_file.subdword_regs.end());
+         const auto& sub = it->second;
+         for (unsigned k = 0; k < 4; ++k) {
+            unsigned id = sub[k];
             if (id && (vars.empty() || id != vars.back()))
                vars.emplace_back(id);
          }
-      } else {
-         unsigned id = reg_file[j];
-         if (id && (vars.empty() || id != vars.back()))
-            vars.emplace_back(id);
+         ++j;
+         continue;
       }
+
+      const unsigned id = val;
+      if (vars.empty() || id != vars.back())
+         vars.emplace_back(id);
+
+      // Jump ahead by variable size (dwords)
+      j += ctx.assignments[id].rc.size();
    }
+
    return vars;
 }
 
-/* collect variables from a register area and clear reg_file
- * variables are sorted in decreasing size and
- * increasing assigned register
- */
-std::vector<unsigned>
+ACO_HOT std::vector<unsigned>
 collect_vars(ra_ctx& ctx, RegisterFile& reg_file, const PhysRegInterval reg_interval)
 {
    std::vector<unsigned> ids = find_vars(ctx, reg_file, reg_interval);
+
+   // Sort by decreasing size, then increasing assigned register (same as before)
    std::sort(ids.begin(), ids.end(),
-             [&](unsigned a, unsigned b)
-             {
-                assignment& var_a = ctx.assignments[a];
-                assignment& var_b = ctx.assignments[b];
-                return var_a.rc.bytes() > var_b.rc.bytes() ||
-                       (var_a.rc.bytes() == var_b.rc.bytes() && var_a.reg < var_b.reg);
+             [&](unsigned a, unsigned b) {
+                const assignment& var_a = ctx.assignments[a];
+                const assignment& var_b = ctx.assignments[b];
+                if (var_a.rc.bytes() != var_b.rc.bytes())
+                   return var_a.rc.bytes() > var_b.rc.bytes();
+                return var_a.reg < var_b.reg;
              });
 
    for (unsigned id : ids) {
