From 0b9baa9cb62d66fae9aebf373145deaf5945eef0 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 31 Aug 2023 20:35:25 +0100
Subject: [PATCH 01/13] nir: improve ms_cross_invocation_output_access with
 local_invocation_id

Since GFX11, RADV doesn't need to lower local_invocation_id.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_gather_info.c | 26 ++++++++++++++++++++------
 1 file changed, 20 insertions(+), 6 deletions(-)

diff --git a/src/compiler/nir/nir_gather_info.c b/src/compiler/nir/nir_gather_info.c
index 865d976a98e06..86c7ffbf5d2c7 100644
--- a/src/compiler/nir/nir_gather_info.c
+++ b/src/compiler/nir/nir_gather_info.c
@@ -36,11 +36,25 @@ src_is_invocation_id(const nir_src *src)
 }
 
 static bool
-src_is_local_invocation_index(const nir_src *src)
+src_is_local_invocation_index(nir_shader *shader, const nir_src *src)
 {
+   assert(shader->info.stage == MESA_SHADER_MESH && !shader->info.workgroup_size_variable);
+
    nir_scalar s = nir_scalar_resolved(src->ssa, 0);
-   return nir_scalar_is_intrinsic(s) &&
-          nir_scalar_intrinsic_op(s) == nir_intrinsic_load_local_invocation_index;
+   if (!nir_scalar_is_intrinsic(s))
+      return false;
+
+   const nir_intrinsic_op op = nir_scalar_intrinsic_op(s);
+   if (op == nir_intrinsic_load_local_invocation_index)
+      return true;
+   if (op != nir_intrinsic_load_local_invocation_id)
+      return false;
+
+   unsigned nz_ids = 0;
+   for (unsigned i = 0; i < 3; i++)
+      nz_ids |= (shader->info.workgroup_size[i] > 1) ? (1u << i) : 0;
+
+   return nz_ids == 0 || (util_bitcount(nz_ids) == 1 && s.comp == ffs(nz_ids) - 1);
 }
 
 static void
@@ -63,7 +77,7 @@ get_deref_info(nir_shader *shader, nir_variable *var, nir_deref_instr *deref,
       if (shader->info.stage == MESA_SHADER_TESS_CTRL)
          *cross_invocation = !src_is_invocation_id(&(*p)->arr.index);
       else if (shader->info.stage == MESA_SHADER_MESH)
-         *cross_invocation = !src_is_local_invocation_index(&(*p)->arr.index);
+         *cross_invocation = !src_is_local_invocation_index(shader, &(*p)->arr.index);
       p++;
    }
 
@@ -547,7 +561,7 @@ gather_intrinsic_info(nir_intrinsic_instr *instr, nir_shader *shader,
       if (shader->info.stage == MESA_SHADER_MESH &&
           (instr->intrinsic == nir_intrinsic_load_per_vertex_output ||
            instr->intrinsic == nir_intrinsic_load_per_primitive_output) &&
-          !src_is_local_invocation_index(nir_get_io_arrayed_index_src(instr)))
+          !src_is_local_invocation_index(shader, nir_get_io_arrayed_index_src(instr)))
          shader->info.mesh.ms_cross_invocation_output_access |= slot_mask;
 
       if (shader->info.stage == MESA_SHADER_FRAGMENT &&
@@ -575,7 +589,7 @@ gather_intrinsic_info(nir_intrinsic_instr *instr, nir_shader *shader,
       if (shader->info.stage == MESA_SHADER_MESH &&
           (instr->intrinsic == nir_intrinsic_store_per_vertex_output ||
            instr->intrinsic == nir_intrinsic_store_per_primitive_output) &&
-          !src_is_local_invocation_index(nir_get_io_arrayed_index_src(instr)))
+          !src_is_local_invocation_index(shader, nir_get_io_arrayed_index_src(instr)))
          shader->info.mesh.ms_cross_invocation_output_access |= slot_mask;
 
       if (shader->info.stage == MESA_SHADER_FRAGMENT &&
-- 
GitLab


From 1bc3e06df5fb09c2168694847365b6dfed5a7c99 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:16:29 +0100
Subject: [PATCH 02/13] aco,nir: add export_row_amd intrinsic

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 16 ++++++++++++++--
 src/compiler/nir/nir_intrinsics.py             |  3 ++-
 2 files changed, 16 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index d92bcc006c2a3..13544a2f7d5ce 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -9003,7 +9003,8 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       }
       break;
    }
-   case nir_intrinsic_export_amd: {
+   case nir_intrinsic_export_amd:
+   case nir_intrinsic_export_row_amd: {
       unsigned flags = nir_intrinsic_flags(instr);
       unsigned target = nir_intrinsic_base(instr);
       unsigned write_mask = nir_intrinsic_write_mask(instr);
@@ -9015,8 +9016,10 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       if (target < V_008DFC_SQ_EXP_MRTZ)
          ctx->program->has_color_exports = true;
 
+      const bool row_en = instr->intrinsic == nir_intrinsic_export_row_amd;
+
       aco_ptr<Export_instruction> exp{
-         create_instruction<Export_instruction>(aco_opcode::exp, Format::EXP, 4, 0)};
+         create_instruction<Export_instruction>(aco_opcode::exp, Format::EXP, 4 + row_en, 0)};
 
       exp->dest = target;
       exp->enabled_mask = write_mask;
@@ -9040,6 +9043,8 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       else
          exp->valid_mask = false;
 
+      exp->row_en = row_en;
+
       /* Compressed export uses two bits for a channel. */
       uint32_t channel_mask =
          exp->compressed ? (write_mask & 0x3 ? 1 : 0) | (write_mask & 0xc ? 2 : 0) : write_mask;
@@ -9051,6 +9056,13 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
                                : Operand(v1);
       }
 
+      if (row_en) {
+         Temp row = bld.as_uniform(get_ssa_temp(ctx, instr->src[1].ssa));
+         /* Hack to prevent the RA from moving the source into m0 and then back to a normal SGPR. */
+         row = bld.copy(bld.def(s1, m0), row);
+         exp->operands[4] = bld.m0(row);
+      }
+
       ctx->block->instructions.emplace_back(std::move(exp));
       break;
    }
diff --git a/src/compiler/nir/nir_intrinsics.py b/src/compiler/nir/nir_intrinsics.py
index 65ad47a9c2789..f84e128353f56 100644
--- a/src/compiler/nir/nir_intrinsics.py
+++ b/src/compiler/nir/nir_intrinsics.py
@@ -1615,10 +1615,11 @@ system_value("lds_ngg_scratch_base_amd", 1)
 system_value("lds_ngg_gs_out_vertex_base_amd", 1)
 
 # AMD GPU shader output export instruction
-# src[] = { export_value }
+# src[] = { export_value, row }
 # BASE = export target
 # FLAGS = AC_EXP_FLAG_*
 intrinsic("export_amd", [0], indices=[BASE, WRITE_MASK, FLAGS])
+intrinsic("export_row_amd", [0, 1], indices=[BASE, WRITE_MASK, FLAGS])
 
 # Export dual source blend outputs with swizzle operation
 # src[] = { mrt0, mrt1 }
-- 
GitLab


From b36198af9525aeda6e8421c0e88b294dc8591bcb Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:18:38 +0100
Subject: [PATCH 03/13] ac/nir: add row parameter to helpers

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir.c           | 57 +++++++++++++++++--------------
 src/amd/common/ac_nir.h           |  5 +--
 src/amd/common/ac_nir_lower_ngg.c | 16 ++++-----
 3 files changed, 43 insertions(+), 35 deletions(-)

diff --git a/src/amd/common/ac_nir.c b/src/amd/common/ac_nir.c
index 0e9709a15621c..918105de8656d 100644
--- a/src/amd/common/ac_nir.c
+++ b/src/amd/common/ac_nir.c
@@ -179,15 +179,26 @@ ac_nir_store_var_components(nir_builder *b, nir_variable *var, nir_def *value,
    nir_store_var(b, var, value, writemask);
 }
 
+static nir_intrinsic_instr *
+export(nir_builder *b, nir_def *val, nir_def *row, unsigned base, unsigned flags,
+       unsigned write_mask)
+{
+   if (row) {
+      return nir_export_row_amd(b, val, row, .base = base, .flags = flags,
+                                .write_mask = write_mask);
+   } else {
+      return nir_export_amd(b, val, .base = base, .flags = flags,
+                            .write_mask = write_mask);
+   }
+}
+
 void
-ac_nir_export_primitive(nir_builder *b, nir_def *prim)
+ac_nir_export_primitive(nir_builder *b, nir_def *prim, nir_def *row)
 {
    unsigned write_mask = BITFIELD_MASK(prim->num_components);
 
-   nir_export_amd(b, nir_pad_vec4(b, prim),
-                  .base = V_008DFC_SQ_EXP_PRIM,
-                  .flags = AC_EXP_FLAG_DONE,
-                  .write_mask = write_mask);
+   export(b, nir_pad_vec4(b, prim), row, V_008DFC_SQ_EXP_PRIM, AC_EXP_FLAG_DONE,
+          write_mask);
 }
 
 static nir_def *
@@ -231,7 +242,8 @@ ac_nir_export_position(nir_builder *b,
                        bool force_vrs,
                        bool done,
                        uint64_t outputs_written,
-                       nir_def *(*outputs)[4])
+                       nir_def *(*outputs)[4],
+                       nir_def *row)
 {
    nir_intrinsic_instr *exp[4];
    unsigned exp_num = 0;
@@ -244,9 +256,7 @@ ac_nir_export_position(nir_builder *b,
       const unsigned pos_flags = gfx_level == GFX10 ? AC_EXP_FLAG_VALID_MASK : 0;
       nir_def *pos = get_pos0_output(b, outputs[VARYING_SLOT_POS]);
 
-      exp[exp_num] = nir_export_amd(
-         b, pos, .base = V_008DFC_SQ_EXP_POS + exp_num,
-         .flags = pos_flags, .write_mask = 0xf);
+      exp[exp_num] = export(b, pos, row, V_008DFC_SQ_EXP_POS + exp_num, pos_flags, 0xf);
       exp_num++;
    } else {
       exp_pos_offset++;
@@ -274,7 +284,6 @@ ac_nir_export_position(nir_builder *b,
    if ((outputs_written & mask) || force_vrs) {
       nir_def *zero = nir_imm_float(b, 0);
       nir_def *vec[4] = { zero, zero, zero, zero };
-      unsigned flags = 0;
       unsigned write_mask = 0;
 
       if (outputs_written & VARYING_BIT_PSIZ) {
@@ -320,21 +329,19 @@ ac_nir_export_position(nir_builder *b,
          }
       }
 
-      exp[exp_num] = nir_export_amd(
-         b, nir_vec(b, vec, 4),
-         .base = V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
-         .flags = flags,
-         .write_mask = write_mask);
+      exp[exp_num] = export(b, nir_vec(b, vec, 4), row,
+                            V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
+                            0, write_mask);
       exp_num++;
    }
 
    for (int i = 0; i < 2; i++) {
       if ((outputs_written & (VARYING_BIT_CLIP_DIST0 << i)) &&
           (clip_cull_mask & BITFIELD_RANGE(i * 4, 4))) {
-         exp[exp_num] = nir_export_amd(
-            b, get_export_output(b, outputs[VARYING_SLOT_CLIP_DIST0 + i]),
-            .base = V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
-            .write_mask = (clip_cull_mask >> (i * 4)) & 0xf);
+         exp[exp_num] = export(
+            b, get_export_output(b, outputs[VARYING_SLOT_CLIP_DIST0 + i]), row,
+            V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset, 0,
+            (clip_cull_mask >> (i * 4)) & 0xf);
          exp_num++;
       }
    }
@@ -351,10 +358,10 @@ ac_nir_export_position(nir_builder *b,
 
       for (int i = 0; i < 2; i++) {
          if (clip_cull_mask & BITFIELD_RANGE(i * 4, 4)) {
-            exp[exp_num] = nir_export_amd(
-               b, get_export_output(b, clip_dist + i * 4),
-               .base = V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset,
-               .write_mask = (clip_cull_mask >> (i * 4)) & 0xf);
+            exp[exp_num] = export(
+               b, get_export_output(b, clip_dist + i * 4), row,
+               V_008DFC_SQ_EXP_POS + exp_num + exp_pos_offset, 0,
+               (clip_cull_mask >> (i * 4)) & 0xf);
             exp_num++;
          }
       }
@@ -739,7 +746,7 @@ ac_nir_create_gs_copy_shader(const nir_shader *gs_nir,
             export_outputs &= ~VARYING_BIT_PSIZ;
 
          ac_nir_export_position(&b, gfx_level, clip_cull_mask, !has_param_exports,
-                                force_vrs, true, export_outputs, outputs.data);
+                                force_vrs, true, export_outputs, outputs.data, NULL);
 
          if (has_param_exports) {
             ac_nir_export_parameters(&b, param_offsets,
@@ -846,7 +853,7 @@ ac_nir_lower_legacy_vs(nir_shader *nir,
       export_outputs &= ~VARYING_BIT_PSIZ;
 
    ac_nir_export_position(&b, gfx_level, clip_cull_mask, !has_param_exports,
-                          force_vrs, true, export_outputs, outputs.data);
+                          force_vrs, true, export_outputs, outputs.data, NULL);
 
    if (has_param_exports) {
       ac_nir_export_parameters(&b, param_offsets,
diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 85720a2ba3f57..dc0651a5fc3af 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -75,7 +75,7 @@ ac_nir_store_var_components(nir_builder *b, nir_variable *var, nir_def *value,
                             unsigned component, unsigned writemask);
 
 void
-ac_nir_export_primitive(nir_builder *b, nir_def *prim);
+ac_nir_export_primitive(nir_builder *b, nir_def *prim, nir_def *row);
 
 void
 ac_nir_export_position(nir_builder *b,
@@ -85,7 +85,8 @@ ac_nir_export_position(nir_builder *b,
                        bool force_vrs,
                        bool done,
                        uint64_t outputs_written,
-                       nir_def *(*outputs)[4]);
+                       nir_def *(*outputs)[4],
+                       nir_def *row);
 
 void
 ac_nir_export_parameters(nir_builder *b,
diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 0872c1e2f1524..5491945e73496 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -604,7 +604,7 @@ emit_ngg_nogs_prim_export(nir_builder *b, lower_ngg_nogs_state *s, nir_def *arg)
          arg = nir_iand(b, arg, mask);
       }
 
-      ac_nir_export_primitive(b, arg);
+      ac_nir_export_primitive(b, arg, NULL);
    }
    nir_pop_if(b, if_gs_thread);
 }
@@ -2351,7 +2351,7 @@ export_pos0_wait_attr_ring(nir_builder *b, nir_if *if_es_thread, nir_def *output
                              options->clipdist_enable_mask,
                              !options->has_param_exports,
                              options->force_vrs, true,
-                             VARYING_BIT_POS, &pos_output.chan);
+                             VARYING_BIT_POS, &pos_output.chan, NULL);
    }
    nir_pop_if(b, if_export_empty_pos);
 }
@@ -2603,7 +2603,7 @@ ac_nir_lower_ngg_nogs(nir_shader *shader, const ac_nir_lower_ngg_options *option
                           options->clipdist_enable_mask,
                           !options->has_param_exports,
                           options->force_vrs, !wait_attr_ring,
-                          export_outputs, state.outputs);
+                          export_outputs, state.outputs, NULL);
 
    nogs_export_vertex_params(b, impl, if_es_thread, num_es_threads, &state);
 
@@ -3027,7 +3027,7 @@ ngg_gs_export_primitives(nir_builder *b, nir_def *max_num_out_prims, nir_def *ti
 
    nir_def *arg = emit_pack_ngg_prim_exp_arg(b, s->num_vertices_per_primitive, vtx_indices,
                                                  is_null_prim);
-   ac_nir_export_primitive(b, arg);
+   ac_nir_export_primitive(b, arg, NULL);
    nir_pop_if(b, if_prim_export_thread);
 }
 
@@ -3112,7 +3112,7 @@ ngg_gs_export_vertices(nir_builder *b, nir_def *max_num_out_vtx, nir_def *tid_in
                           s->options->clipdist_enable_mask,
                           !s->options->has_param_exports,
                           s->options->force_vrs, !wait_attr_ring,
-                          export_outputs, s->outputs);
+                          export_outputs, s->outputs, NULL);
 
    nir_pop_if(b, if_vtx_export_thread);
 
@@ -4457,7 +4457,7 @@ ms_emit_primitive_export(nir_builder *b,
    nir_def *prim_exp_arg = prim_exp_arg_ch2 ?
       nir_vec2(b, prim_exp_arg_ch1, prim_exp_arg_ch2) : prim_exp_arg_ch1;
 
-   ac_nir_export_primitive(b, prim_exp_arg);
+   ac_nir_export_primitive(b, prim_exp_arg, NULL);
 }
 
 static void
@@ -4515,7 +4515,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
          if (!wait_attr_ring)
             ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
                                  !s->has_param_exports, false, true,
-                                 s->per_vertex_outputs | VARYING_BIT_POS, s->outputs);
+                                 s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, NULL);
 
          /* Export generic attributes on GFX10.3
          * (On GFX11 they are already stored in the attribute ring.)
@@ -4582,7 +4582,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
          ms_emit_arrayed_outputs(b, invocation_index, per_vertex_outputs, s);
          ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
                                 !s->has_param_exports, false, true,
-                                s->per_vertex_outputs | VARYING_BIT_POS, s->outputs);
+                                s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, NULL);
       }
       nir_pop_if(b, if_has_output_vertex);
 
-- 
GitLab


From 818e46473070be797a75f9e785396710dca4d9c0 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:29:57 +0100
Subject: [PATCH 04/13] ac/nir: remove dead code

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir_lower_ngg.c | 32 ++-----------------------------
 1 file changed, 2 insertions(+), 30 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 5491945e73496..68130693c4f2c 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -137,8 +137,8 @@ typedef struct
 enum {
    /* DW0: number of primitives */
    lds_ms_num_prims = 0,
-   /* DW1: reserved for future use */
-   lds_ms_dw1_reserved = 4,
+   /* DW1: number of vertices */
+   lds_ms_num_vtx = 4,
    /* DW2: workgroup index within the current dispatch */
    lds_ms_wg_index = 8,
    /* DW3: number of API workgroups in flight */
@@ -3639,34 +3639,6 @@ ms_store_prim_indices(nir_builder *b,
    nir_store_shared(b, nir_u2u8(b, val), offset_src, .base = s->layout.lds.indices_addr);
 }
 
-static nir_def *
-ms_load_prim_indices(nir_builder *b,
-                     nir_def *offset_src,
-                     lower_ngg_ms_state *s)
-{
-   if (!offset_src)
-      offset_src = nir_imm_int(b, 0);
-
-   return nir_load_shared(b, 1, 8, offset_src, .base = s->layout.lds.indices_addr);
-}
-
-static void
-ms_store_num_prims(nir_builder *b,
-                   nir_def *store_val,
-                   lower_ngg_ms_state *s)
-{
-   nir_def *addr = nir_imm_int(b, 0);
-   nir_store_shared(b, nir_u2u32(b, store_val), addr, .base = s->layout.lds.workgroup_info_addr + lds_ms_num_prims);
-}
-
-static nir_def *
-ms_load_num_prims(nir_builder *b,
-                  lower_ngg_ms_state *s)
-{
-   nir_def *addr = nir_imm_int(b, 0);
-   return nir_load_shared(b, 1, 32, addr, .base = s->layout.lds.workgroup_info_addr + lds_ms_num_prims);
-}
-
 static void
 ms_store_cull_flag(nir_builder *b,
                    nir_def *val,
-- 
GitLab


From 2a07e2e6384d6bbc24de51477b03b04a67758961 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:22:42 +0100
Subject: [PATCH 05/13] ac/nir: refactor mesh vertex/primitive export

To prepare for row export, move them into helpers with index and row
parameters.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir_lower_ngg.c | 127 +++++++++++++++---------------
 1 file changed, 63 insertions(+), 64 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 68130693c4f2c..9287f182ab955 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -4264,12 +4264,11 @@ set_ms_final_output_counts(nir_builder *b,
 
 static void
 ms_emit_attribute_ring_output_stores(nir_builder *b, const uint64_t outputs_mask,
-                                     lower_ngg_ms_state *s)
+                                     nir_def *idx, lower_ngg_ms_state *s)
 {
    if (!outputs_mask)
       return;
 
-   nir_def *idx = nir_load_local_invocation_index(b);
    nir_def *ring = nir_load_ring_attr_amd(b);
    nir_def *off = nir_load_ring_attr_offset_amd(b);
    nir_def *zero = nir_imm_int(b, 0);
@@ -4416,20 +4415,67 @@ ms_invocation_query(nir_builder *b,
 }
 
 static void
-ms_emit_primitive_export(nir_builder *b,
-                         nir_def *invocation_index,
-                         nir_def *num_vtx,
-                         uint64_t per_primitive_outputs,
-                         lower_ngg_ms_state *s)
+emit_ms_vertex(nir_builder *b, nir_def *index, nir_def *row, bool exports, bool parameters,
+               uint64_t per_vertex_outputs, lower_ngg_ms_state *s)
 {
-   const uint64_t outputs_mask = per_primitive_outputs & MS_PRIM_ARG_EXP_MASK;
-   nir_def *prim_exp_arg_ch1 = ms_prim_exp_arg_ch1(b, invocation_index, num_vtx, s);
-   nir_def *prim_exp_arg_ch2 = ms_prim_exp_arg_ch2(b, outputs_mask, s);
+   ms_emit_arrayed_outputs(b, index, per_vertex_outputs, s);
+
+   if (exports) {
+      ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
+                             !s->has_param_exports, false, true,
+                             s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, row);
+   }
 
-   nir_def *prim_exp_arg = prim_exp_arg_ch2 ?
-      nir_vec2(b, prim_exp_arg_ch1, prim_exp_arg_ch2) : prim_exp_arg_ch1;
+   if (parameters) {
+      /* Export generic attributes on GFX10.3
+       * (On GFX11 they are already stored in the attribute ring.)
+       */
+      if (s->has_param_exports && s->gfx_level == GFX10_3) {
+         ac_nir_export_parameters(b, s->vs_output_param_offset, per_vertex_outputs, 0, s->outputs,
+                                  NULL, NULL);
+      }
 
-   ac_nir_export_primitive(b, prim_exp_arg, NULL);
+      /* GFX11+: also store special outputs to the attribute ring so PS can load them. */
+      if (s->gfx_level >= GFX11 && (per_vertex_outputs & MS_VERT_ARG_EXP_MASK))
+         ms_emit_attribute_ring_output_stores(b, per_vertex_outputs & MS_VERT_ARG_EXP_MASK, index, s);
+   }
+}
+
+static void
+emit_ms_primitive(nir_builder *b, nir_def *index, nir_def *row, bool exports, bool parameters,
+                  uint64_t per_primitive_outputs, lower_ngg_ms_state *s)
+{
+   ms_emit_arrayed_outputs(b, index, per_primitive_outputs, s);
+
+   /* Insert layer output store if the pipeline uses multiview but the API shader doesn't write it. */
+   if (s->insert_layer_output)
+      s->outputs[VARYING_SLOT_LAYER][0] = nir_load_view_index(b);
+
+   if (exports) {
+      const uint64_t outputs_mask = per_primitive_outputs & MS_PRIM_ARG_EXP_MASK;
+      nir_def *num_vtx = nir_load_var(b, s->vertex_count_var);
+      nir_def *prim_exp_arg_ch1 = ms_prim_exp_arg_ch1(b, index, num_vtx, s);
+      nir_def *prim_exp_arg_ch2 = ms_prim_exp_arg_ch2(b, outputs_mask, s);
+
+      nir_def *prim_exp_arg = prim_exp_arg_ch2 ?
+         nir_vec2(b, prim_exp_arg_ch1, prim_exp_arg_ch2) : prim_exp_arg_ch1;
+
+      ac_nir_export_primitive(b, prim_exp_arg, row);
+   }
+
+   if (parameters) {
+      /* Export generic attributes on GFX10.3
+       * (On GFX11 they are already stored in the attribute ring.)
+       */
+      if (s->has_param_exports && s->gfx_level == GFX10_3) {
+         ac_nir_export_parameters(b, s->vs_output_param_offset, per_primitive_outputs, 0,
+                                  s->outputs, NULL, NULL);
+      }
+
+      /* GFX11+: also store special outputs to the attribute ring so PS can load them. */
+      if (s->gfx_level >= GFX11)
+         ms_emit_attribute_ring_output_stores(b, per_primitive_outputs & MS_PRIM_ARG_EXP_MASK, index, s);
+   }
 }
 
 static void
@@ -4482,25 +4528,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
       nir_def *has_output_vertex = nir_ilt(b, invocation_index, num_vtx);
       nir_if *if_has_output_vertex = nir_push_if(b, has_output_vertex);
       {
-         ms_emit_arrayed_outputs(b, invocation_index, per_vertex_outputs, s);
-
-         if (!wait_attr_ring)
-            ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
-                                 !s->has_param_exports, false, true,
-                                 s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, NULL);
-
-         /* Export generic attributes on GFX10.3
-         * (On GFX11 they are already stored in the attribute ring.)
-         */
-         if (s->has_param_exports && s->gfx_level == GFX10_3) {
-            ac_nir_export_parameters(b, s->vs_output_param_offset, per_vertex_outputs, 0, s->outputs,
-                                    NULL, NULL);
-         }
-
-         /* GFX11+: also store special outputs to the attribute ring so PS can load them. */
-         if (s->gfx_level >= GFX11 && (per_vertex_outputs & MS_VERT_ARG_EXP_MASK)) {
-            ms_emit_attribute_ring_output_stores(b, per_vertex_outputs & MS_VERT_ARG_EXP_MASK, s);
-         }
+         emit_ms_vertex(b, invocation_index, NULL, !wait_attr_ring, true, per_vertex_outputs, s);
       }
       nir_pop_if(b, if_has_output_vertex);
    }
@@ -4510,28 +4538,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
       nir_def *has_output_primitive = nir_ilt(b, invocation_index, num_prm);
       nir_if *if_has_output_primitive = nir_push_if(b, has_output_primitive);
       {
-         ms_emit_arrayed_outputs(b, invocation_index, per_primitive_outputs, s);
-
-         /* Insert layer output store if the pipeline uses multiview but the API shader doesn't write it. */
-         if (s->insert_layer_output) {
-            s->outputs[VARYING_SLOT_LAYER][0] = nir_load_view_index(b);
-         }
-
-         if (!wait_attr_ring)
-            ms_emit_primitive_export(b, invocation_index, num_vtx, per_primitive_outputs, s);
-
-         /* Export generic attributes on GFX10.3
-         * (On GFX11 they are already stored in the attribute ring.)
-         */
-         if (s->has_param_exports && s->gfx_level == GFX10_3) {
-            ac_nir_export_parameters(b, s->vs_output_param_offset, per_primitive_outputs, 0,
-                                    s->outputs, NULL, NULL);
-         }
-
-         /* GFX11+: also store special per-primitive outputs to the attribute ring so PS can load them. */
-         if (s->gfx_level >= GFX11) {
-            ms_emit_attribute_ring_output_stores(b, per_primitive_outputs & MS_PRIM_ARG_EXP_MASK, s);
-         }
+         emit_ms_primitive(b, invocation_index, NULL, !wait_attr_ring, true, per_primitive_outputs, s);
       }
       nir_pop_if(b, if_has_output_primitive);
    }
@@ -4551,22 +4558,14 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
       nir_def *has_output_vertex = nir_ilt(b, invocation_index, num_vtx);
       nir_if *if_has_output_vertex = nir_push_if(b, has_output_vertex);
       {
-         ms_emit_arrayed_outputs(b, invocation_index, per_vertex_outputs, s);
-         ac_nir_export_position(b, s->gfx_level, s->clipdist_enable_mask,
-                                !s->has_param_exports, false, true,
-                                s->per_vertex_outputs | VARYING_BIT_POS, s->outputs, NULL);
+         emit_ms_vertex(b, invocation_index, NULL, true, false, per_vertex_outputs, s);
       }
       nir_pop_if(b, if_has_output_vertex);
 
       nir_def *has_output_primitive = nir_ilt(b, invocation_index, num_prm);
       nir_if *if_has_output_primitive = nir_push_if(b, has_output_primitive);
       {
-         ms_emit_arrayed_outputs(b, invocation_index, per_primitive_outputs, s);
-         if (s->insert_layer_output) {
-            s->outputs[VARYING_SLOT_LAYER][0] = nir_load_view_index(b);
-         }
-
-         ms_emit_primitive_export(b, invocation_index, num_vtx, per_primitive_outputs, s);
+         emit_ms_primitive(b, invocation_index, NULL, true, false, per_primitive_outputs, s);
       }
       nir_pop_if(b, if_has_output_primitive);
    }
-- 
GitLab


From d7de1550e47c3651eea01ddf7566bdba86e97217 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:24:56 +0100
Subject: [PATCH 06/13] ac/nir: implement mesh shader gs_fast_launch=2

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir.h           |  3 ++-
 src/amd/common/ac_nir_lower_ngg.c | 20 ++++++++++++++------
 src/amd/vulkan/radv_shader.c      |  2 +-
 3 files changed, 17 insertions(+), 8 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index dc0651a5fc3af..0d91a7edb2c92 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -197,7 +197,8 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
                     bool *out_needs_scratch_ring,
                     unsigned wave_size,
                     bool multiview,
-                    bool has_query);
+                    bool has_query,
+                    bool fast_launch_2);
 
 void
 ac_nir_lower_task_outputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 9287f182ab955..9e6cee575a126 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -197,6 +197,7 @@ typedef struct
 typedef struct
 {
    enum amd_gfx_level gfx_level;
+   bool fast_launch_2;
 
    ms_out_mem_layout layout;
    uint64_t per_vertex_outputs;
@@ -4497,6 +4498,10 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
 
    ms_prim_gen_query(b, invocation_index, num_prm, s);
 
+   nir_def *row_start = NULL;
+   if (s->fast_launch_2)
+      row_start = s->hw_workgroup_size <= s->wave_size ? nir_imm_int(b, 0) : nir_load_subgroup_id(b);
+
    /* Load vertex/primitive attributes from shared memory and
     * emit store_output intrinsics for them.
     *
@@ -4528,7 +4533,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
       nir_def *has_output_vertex = nir_ilt(b, invocation_index, num_vtx);
       nir_if *if_has_output_vertex = nir_push_if(b, has_output_vertex);
       {
-         emit_ms_vertex(b, invocation_index, NULL, !wait_attr_ring, true, per_vertex_outputs, s);
+         emit_ms_vertex(b, invocation_index, row_start, !wait_attr_ring, true, per_vertex_outputs, s);
       }
       nir_pop_if(b, if_has_output_vertex);
    }
@@ -4538,7 +4543,7 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
       nir_def *has_output_primitive = nir_ilt(b, invocation_index, num_prm);
       nir_if *if_has_output_primitive = nir_push_if(b, has_output_primitive);
       {
-         emit_ms_primitive(b, invocation_index, NULL, !wait_attr_ring, true, per_primitive_outputs, s);
+         emit_ms_primitive(b, invocation_index, row_start, !wait_attr_ring, true, per_primitive_outputs, s);
       }
       nir_pop_if(b, if_has_output_primitive);
    }
@@ -4558,14 +4563,14 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
       nir_def *has_output_vertex = nir_ilt(b, invocation_index, num_vtx);
       nir_if *if_has_output_vertex = nir_push_if(b, has_output_vertex);
       {
-         emit_ms_vertex(b, invocation_index, NULL, true, false, per_vertex_outputs, s);
+         emit_ms_vertex(b, invocation_index, row_start, true, false, per_vertex_outputs, s);
       }
       nir_pop_if(b, if_has_output_vertex);
 
       nir_def *has_output_primitive = nir_ilt(b, invocation_index, num_prm);
       nir_if *if_has_output_primitive = nir_push_if(b, has_output_primitive);
       {
-         emit_ms_primitive(b, invocation_index, NULL, true, false, per_primitive_outputs, s);
+         emit_ms_primitive(b, invocation_index, row_start, true, false, per_primitive_outputs, s);
       }
       nir_pop_if(b, if_has_output_primitive);
    }
@@ -4850,7 +4855,8 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
                     bool *out_needs_scratch_ring,
                     unsigned wave_size,
                     bool multiview,
-                    bool has_query)
+                    bool has_query,
+                    bool fast_launch_2)
 {
    unsigned vertices_per_prim =
       num_mesh_vertices_per_primitive(shader->info.mesh.primitive_type);
@@ -4901,6 +4907,7 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
       .insert_layer_output = multiview && !(shader->info.outputs_written & VARYING_BIT_LAYER),
       .uses_cull_flags = uses_cull,
       .gfx_level = gfx_level,
+      .fast_launch_2 = fast_launch_2,
       .clipdist_enable_mask = clipdist_enable_mask,
       .vs_output_param_offset = vs_output_param_offset,
       .has_param_exports = has_param_exports,
@@ -4919,7 +4926,8 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
    nir_builder *b = &builder; /* This is to avoid the & */
 
    handle_smaller_ms_api_workgroup(b, &state);
-   ms_emit_legacy_workgroup_index(b, &state);
+   if (!fast_launch_2)
+      ms_emit_legacy_workgroup_index(b, &state);
    ms_create_same_invocation_vars(b, &state);
    nir_metadata_preserve(impl, nir_metadata_none);
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 7636a66181f3c..fe7cf6054fc35 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -912,7 +912,7 @@ radv_lower_ngg(struct radv_device *device, struct radv_shader_stage *ngg_stage,
       bool scratch_ring = false;
       NIR_PASS_V(nir, ac_nir_lower_ngg_ms, options.gfx_level, options.clipdist_enable_mask,
                  options.vs_output_param_offset, options.has_param_exports, &scratch_ring, info->wave_size,
-                 pl_key->has_multiview_view_index, info->ms.has_query);
+                 pl_key->has_multiview_view_index, info->ms.has_query, false);
       ngg_stage->info.ms.needs_ms_scratch_ring = scratch_ring;
    } else {
       unreachable("invalid SW stage passed to radv_lower_ngg");
-- 
GitLab


From 52eabed11868b1d0f4549feb64aaeb8509bb4faf Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 7 Sep 2023 17:01:14 +0100
Subject: [PATCH 07/13] ac/nir: optimize mesh shader local_invocation_index

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir_lower_ngg.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 9e6cee575a126..824654720c336 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -4942,5 +4942,18 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
    nir_lower_alu_to_scalar(shader, NULL, NULL);
    nir_lower_phis_to_scalar(shader, true);
 
+   /* Optimize load_local_invocation_index. When the API workgroup is smaller than the HW workgroup,
+    * local_invocation_id isn't initialized for all lanes and we can't perform this optimization for
+    * all load_local_invocation_index.
+    */
+   if (fast_launch_2 && api_workgroup_size == hw_workgroup_size &&
+       ((shader->info.workgroup_size[0] == 1) + (shader->info.workgroup_size[1] == 1) +
+        (shader->info.workgroup_size[2] == 1)) == 2) {
+      nir_lower_compute_system_values_options csv_options = {
+         .lower_local_invocation_index = true,
+      };
+      nir_lower_compute_system_values(shader, &csv_options);
+   }
+
    nir_validate_shader(shader, "after emitting NGG MS");
 }
-- 
GitLab


From e16a0fb0f38337c1f96099d079b75f93a4b1a7ed Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:25:00 +0100
Subject: [PATCH 08/13] radv: implement mesh shader gs_fast_launch=2

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir.c                 | 16 +++++++++++
 src/amd/common/sid.h                    |  1 +
 src/amd/vulkan/radv_cmd_buffer.c        | 35 ++++++++++++++++++++-----
 src/amd/vulkan/radv_device.c            |  2 ++
 src/amd/vulkan/radv_pipeline_graphics.c | 19 +++++++++++---
 src/amd/vulkan/radv_private.h           |  3 +++
 src/amd/vulkan/radv_shader.c            |  6 ++---
 src/amd/vulkan/radv_shader_args.c       | 28 ++++++++++++--------
 src/amd/vulkan/radv_shader_info.c       |  3 ++-
 9 files changed, 88 insertions(+), 25 deletions(-)

diff --git a/src/amd/common/ac_nir.c b/src/amd/common/ac_nir.c
index 918105de8656d..3afc33e555bdf 100644
--- a/src/amd/common/ac_nir.c
+++ b/src/amd/common/ac_nir.c
@@ -129,6 +129,22 @@ lower_intrinsic_to_arg(nir_builder *b, nir_instr *instr, void *state)
 
       break;
    }
+   case nir_intrinsic_load_workgroup_id:
+      if (b->shader->info.stage == MESA_SHADER_MESH) {
+         /* This lowering is only valid with fast_launch = 2, otherwise we assume that
+          * lower_workgroup_id_to_index removed any uses of the workgroup id by this point.
+          */
+         assert(s->gfx_level >= GFX11);
+         nir_def *xy = ac_nir_load_arg(b, s->args, s->args->tess_offchip_offset);
+         nir_def *z = ac_nir_load_arg(b, s->args, s->args->gs_attr_offset);
+         replacement = nir_vec3(b, nir_extract_u16(b, xy, nir_imm_int(b, 0)),
+                                nir_extract_u16(b, xy, nir_imm_int(b, 1)),
+                                nir_extract_u16(b, z, nir_imm_int(b, 1)));
+      } else {
+         return false;
+      }
+
+      break;
    default:
       return false;
    }
diff --git a/src/amd/common/sid.h b/src/amd/common/sid.h
index e82a2275e3a2a..c5dd0a8264cc2 100644
--- a/src/amd/common/sid.h
+++ b/src/amd/common/sid.h
@@ -222,6 +222,7 @@
 #define   S_4D1_XYZ_DIM_ENABLE(x)                     ((x & 1) << 30) /* GFX11+ */
 #define   S_4D1_MODE1_ENABLE(x)                       ((x & 1) << 29) /* GFX11+ */
 #define   S_4D1_LINEAR_DISPATCH_ENABLE(x)             ((x & 1) << 28) /* GFX11+ */
+#define PKT3_DISPATCH_MESH_DIRECT                  0x4E /* Direct mesh shader only dispatch [GFX only], GFX11+ */
 #define PKT3_DMA_DATA                              0x50 /* GFX7+ */
 #define PKT3_CONTEXT_REG_RMW                       0x51 /* older firmware versions on older chips don't have this */
 #define PKT3_ONE_REG_WRITE                         0x57 /* GFX6 only */
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f6f99c86aa146..12ff9abd5a56d 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -8054,7 +8054,7 @@ radv_cs_emit_indirect_mesh_draw_packet(struct radv_cmd_buffer *cmd_buffer, uint3
    uint32_t draw_id_reg = xyz_dim_reg + (xyz_dim_enable ? 3 : 0);
 
    uint32_t draw_id_enable = !!cmd_buffer->state.uses_drawid;
-   uint32_t mode1_enable = 1; /* legacy fast launch mode */
+   uint32_t mode1_enable = !cmd_buffer->device->mesh_fast_launch_2;
    const bool sqtt_en = !!cmd_buffer->device->sqtt.bo;
 
    radeon_emit(cs, PKT3(PKT3_DISPATCH_MESH_INDIRECT_MULTI, 7, predicating) | PKT3_RESET_FILTER_CAM_S(1));
@@ -8156,7 +8156,7 @@ radv_cs_emit_dispatch_taskmesh_gfx_packet(struct radv_cmd_buffer *cmd_buffer)
    uint32_t xyz_dim_reg = (cmd_buffer->state.vtx_base_sgpr - SI_SH_REG_OFFSET) >> 2;
    uint32_t ring_entry_reg = ((mesh_shader->info.user_data_0 - SI_SH_REG_OFFSET) >> 2) + ring_entry_loc->sgpr_idx;
    uint32_t xyz_dim_en = mesh_shader->info.cs.uses_grid_size;
-   uint32_t mode1_en = 1; /* legacy fast launch mode */
+   uint32_t mode1_en = !cmd_buffer->device->mesh_fast_launch_2;
    uint32_t linear_dispatch_en = cmd_buffer->state.shaders[MESA_SHADER_TASK]->info.cs.linear_taskmesh_dispatch;
    const bool sqtt_en = !!cmd_buffer->device->sqtt.bo;
 
@@ -8461,20 +8461,41 @@ radv_emit_direct_draw_packets(struct radv_cmd_buffer *cmd_buffer, const struct r
    }
 }
 
+static void
+radv_cs_emit_mesh_dispatch_packet(struct radv_cmd_buffer *cmd_buffer, uint32_t x, uint32_t y, uint32_t z)
+{
+   radeon_emit(cmd_buffer->cs, PKT3(PKT3_DISPATCH_MESH_DIRECT, 3, cmd_buffer->state.predicating));
+   radeon_emit(cmd_buffer->cs, x);
+   radeon_emit(cmd_buffer->cs, y);
+   radeon_emit(cmd_buffer->cs, z);
+   radeon_emit(cmd_buffer->cs, S_0287F0_SOURCE_SELECT(V_0287F0_DI_SRC_SEL_AUTO_INDEX));
+}
+
 ALWAYS_INLINE static void
 radv_emit_direct_mesh_draw_packet(struct radv_cmd_buffer *cmd_buffer, uint32_t x, uint32_t y, uint32_t z)
 {
    const uint32_t view_mask = cmd_buffer->state.render.view_mask;
-   const uint32_t count = x * y * z;
 
    radv_emit_userdata_mesh(cmd_buffer, x, y, z);
 
-   if (!view_mask) {
-      radv_cs_emit_draw_packet(cmd_buffer, count, 0);
+   if (cmd_buffer->device->mesh_fast_launch_2) {
+      if (!view_mask) {
+         radv_cs_emit_mesh_dispatch_packet(cmd_buffer, x, y, z);
+      } else {
+         u_foreach_bit (view, view_mask) {
+            radv_emit_view_index(cmd_buffer, view);
+            radv_cs_emit_mesh_dispatch_packet(cmd_buffer, x, y, z);
+         }
+      }
    } else {
-      u_foreach_bit (view, view_mask) {
-         radv_emit_view_index(cmd_buffer, view);
+      const uint32_t count = x * y * z;
+      if (!view_mask) {
          radv_cs_emit_draw_packet(cmd_buffer, count, 0);
+      } else {
+         u_foreach_bit (view, view_mask) {
+            radv_emit_view_index(cmd_buffer, view);
+            radv_cs_emit_draw_packet(cmd_buffer, count, 0);
+         }
       }
    }
 }
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 4fdfa2f258266..83e57a19d8b90 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -924,6 +924,8 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
    device->pbb_allowed =
       device->physical_device->rad_info.gfx_level >= GFX9 && !(device->instance->debug_flags & RADV_DEBUG_NOBINNING);
 
+   device->mesh_fast_launch_2 = false;
+
    /* The maximum number of scratch waves. Scratch space isn't divided
     * evenly between CUs. The number is only a function of the number of CUs.
     * We can decrease the constant to decrease the scratch buffer size.
diff --git a/src/amd/vulkan/radv_pipeline_graphics.c b/src/amd/vulkan/radv_pipeline_graphics.c
index d0f3f362b05b3..3718f965935e9 100644
--- a/src/amd/vulkan/radv_pipeline_graphics.c
+++ b/src/amd/vulkan/radv_pipeline_graphics.c
@@ -2531,7 +2531,7 @@ radv_graphics_shaders_compile(struct radv_device *device, struct vk_pipeline_cac
 
    bool optimize_conservatively = pipeline_key->optimisations_disabled;
 
-   if (stages[MESA_SHADER_MESH].nir &&
+   if (!device->mesh_fast_launch_2 && stages[MESA_SHADER_MESH].nir &&
        BITSET_TEST(stages[MESA_SHADER_MESH].nir->info.system_values_read, SYSTEM_VALUE_WORKGROUP_ID)) {
       nir_shader *mesh = stages[MESA_SHADER_MESH].nir;
       nir_shader *task = stages[MESA_SHADER_TASK].nir;
@@ -3262,8 +3262,19 @@ radv_emit_mesh_shader(const struct radv_device *device, struct radeon_cmdbuf *ct
    const struct radv_physical_device *pdevice = device->physical_device;
 
    radv_emit_hw_ngg(device, ctx_cs, cs, NULL, ms);
-   radeon_set_context_reg(ctx_cs, R_028B38_VGT_GS_MAX_VERT_OUT, ms->info.workgroup_size);
+   radeon_set_context_reg(ctx_cs, R_028B38_VGT_GS_MAX_VERT_OUT,
+                          device->mesh_fast_launch_2 ? ms->info.ngg_info.max_out_verts : ms->info.workgroup_size);
    radeon_set_uconfig_reg_idx(pdevice, ctx_cs, R_030908_VGT_PRIMITIVE_TYPE, 1, V_008958_DI_PT_POINTLIST);
+
+   if (device->mesh_fast_launch_2) {
+      radeon_set_sh_reg_seq(cs, R_00B2B0_SPI_SHADER_GS_MESHLET_DIM, 2);
+      radeon_emit(cs, S_00B2B0_MESHLET_NUM_THREAD_X(ms->info.cs.block_size[0] - 1) |
+                         S_00B2B0_MESHLET_NUM_THREAD_Y(ms->info.cs.block_size[1] - 1) |
+                         S_00B2B0_MESHLET_NUM_THREAD_Z(ms->info.cs.block_size[2] - 1) |
+                         S_00B2B0_MESHLET_THREADGROUP_SIZE(ms->info.workgroup_size - 1));
+      radeon_emit(cs, S_00B2B4_MAX_EXP_VERTS(ms->info.ngg_info.max_out_verts) |
+                         S_00B2B4_MAX_EXP_PRIMS(ms->info.ngg_info.prim_amp_factor));
+   }
 }
 
 static uint32_t
@@ -3506,7 +3517,9 @@ radv_emit_vgt_shader_config(const struct radv_device *device, struct radeon_cmdb
       stages |= S_028B54_ES_EN(V_028B54_ES_STAGE_REAL) | S_028B54_GS_EN(1);
    } else if (key->mesh) {
       assert(!key->ngg_passthrough);
-      stages |= S_028B54_GS_EN(1) | S_028B54_GS_FAST_LAUNCH(1) | S_028B54_NGG_WAVE_ID_EN(key->mesh_scratch_ring);
+      unsigned gs_fast_launch = device->mesh_fast_launch_2 ? 2 : 1;
+      stages |=
+         S_028B54_GS_EN(1) | S_028B54_GS_FAST_LAUNCH(gs_fast_launch) | S_028B54_NGG_WAVE_ID_EN(key->mesh_scratch_ring);
    } else if (key->ngg) {
       stages |= S_028B54_ES_EN(V_028B54_ES_STAGE_REAL);
    }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index fb4f6e97850a4..c9fc72e0b93d8 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1036,6 +1036,9 @@ struct radv_device {
    /* Whether primitives generated query features are enabled. */
    bool primitives_generated_query;
 
+   /* Whether to use GS_FAST_LAUNCH(2) for mesh shaders. */
+   bool mesh_fast_launch_2;
+
    /* Whether anisotropy is forced with RADV_TEX_ANISO (-1 is disabled). */
    int force_aniso;
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index fe7cf6054fc35..1a87b83a8d771 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -563,9 +563,9 @@ radv_shader_spirv_to_nir(struct radv_device *device, const struct radv_shader_st
    NIR_PASS(_, nir, nir_lower_system_values);
    nir_lower_compute_system_values_options csv_options = {
       /* Mesh shaders run as NGG which can implement local_invocation_index from
-       * the wave ID in merged_wave_info, but they don't have local_invocation_ids.
+       * the wave ID in merged_wave_info, but they don't have local_invocation_ids on GFX10.3.
        */
-      .lower_cs_local_id_to_index = nir->info.stage == MESA_SHADER_MESH,
+      .lower_cs_local_id_to_index = nir->info.stage == MESA_SHADER_MESH && !device->mesh_fast_launch_2,
       .lower_local_invocation_index = nir->info.stage == MESA_SHADER_COMPUTE &&
                                       ((nir->info.workgroup_size[0] == 1) + (nir->info.workgroup_size[1] == 1) +
                                        (nir->info.workgroup_size[2] == 1)) == 2,
@@ -912,7 +912,7 @@ radv_lower_ngg(struct radv_device *device, struct radv_shader_stage *ngg_stage,
       bool scratch_ring = false;
       NIR_PASS_V(nir, ac_nir_lower_ngg_ms, options.gfx_level, options.clipdist_enable_mask,
                  options.vs_output_param_offset, options.has_param_exports, &scratch_ring, info->wave_size,
-                 pl_key->has_multiview_view_index, info->ms.has_query, false);
+                 pl_key->has_multiview_view_index, info->ms.has_query, device->mesh_fast_launch_2);
       ngg_stage->info.ms.needs_ms_scratch_ring = scratch_ring;
    } else {
       unreachable("invalid SW stage passed to radv_lower_ngg");
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index e754123a8c978..16d9406a17165 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -254,12 +254,16 @@ declare_ms_input_sgprs(const struct radv_shader_info *info, struct radv_shader_a
 }
 
 static void
-declare_ms_input_vgprs(struct radv_shader_args *args)
+declare_ms_input_vgprs(const struct radv_device *device, struct radv_shader_args *args)
 {
-   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.vertex_id);
-   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* user vgpr */
-   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* user vgpr */
-   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* instance_id */
+   if (device->mesh_fast_launch_2) {
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.local_invocation_ids);
+   } else {
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.vertex_id);
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* user vgpr */
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* user vgpr */
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* instance_id */
+   }
 }
 
 static void
@@ -674,18 +678,20 @@ declare_shader_args(const struct radv_device *device, const struct radv_pipeline
          if (info->merged_shader_compiled_separately)
             add_ud_arg(args, 1, AC_ARG_INT, &args->next_stage_pc, AC_UD_NEXT_STAGE_PC);
 
-         ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[0]);
-         ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[1]);
-         ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_prim_id);
-         ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_invocation_id);
-         ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[2]);
+         if (previous_stage != MESA_SHADER_MESH || !device->mesh_fast_launch_2) {
+            ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[0]);
+            ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[1]);
+            ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_prim_id);
+            ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_invocation_id);
+            ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.gs_vtx_offset[2]);
+         }
 
          if (previous_stage == MESA_SHADER_VERTEX) {
             declare_vs_input_vgprs(gfx_level, info, args, false);
          } else if (previous_stage == MESA_SHADER_TESS_EVAL) {
             declare_tes_input_vgprs(args);
          } else if (previous_stage == MESA_SHADER_MESH) {
-            declare_ms_input_vgprs(args);
+            declare_ms_input_vgprs(device, args);
          }
 
          if (info->merged_shader_compiled_separately) {
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 4a3e250d91f65..03754e728eb06 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1162,7 +1162,8 @@ radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *n
                                         BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_SUBGROUP_ID) |
                                         BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_NUM_SUBGROUPS);
 
-   if (nir->info.stage == MESA_SHADER_COMPUTE || nir->info.stage == MESA_SHADER_TASK) {
+   if (nir->info.stage == MESA_SHADER_COMPUTE || nir->info.stage == MESA_SHADER_TASK ||
+       nir->info.stage == MESA_SHADER_MESH) {
       for (int i = 0; i < 3; ++i)
          info->cs.block_size[i] = nir->info.workgroup_size[i];
    }
-- 
GitLab


From 950286f87cb47cae545ac25619f6cdd9608ccb03 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 17:13:20 +0100
Subject: [PATCH 09/13] ac/nir: add emit_ms_outputs helper

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir_lower_ngg.c | 50 +++++++++++++++----------------
 1 file changed, 24 insertions(+), 26 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 824654720c336..4c2073c378fa4 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -4479,6 +4479,21 @@ emit_ms_primitive(nir_builder *b, nir_def *index, nir_def *row, bool exports, bo
    }
 }
 
+static void
+emit_ms_outputs(nir_builder *b, nir_def *invocation_index, nir_def *row_start,
+                nir_def *count, bool exports, bool parameters, uint64_t mask,
+                void (*cb)(nir_builder *, nir_def *, nir_def *, bool, bool,
+                           uint64_t, lower_ngg_ms_state *),
+                lower_ngg_ms_state *s)
+{
+   nir_def *has_output = nir_ilt(b, invocation_index, count);
+   nir_if *if_has_output = nir_push_if(b, has_output);
+   {
+      cb(b, invocation_index, row_start, exports, parameters, mask, s);
+   }
+   nir_pop_if(b, if_has_output);
+}
+
 static void
 emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
 {
@@ -4530,22 +4545,14 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
 
    /* Export vertices. */
    if ((per_vertex_outputs & ~VARYING_BIT_POS) || !wait_attr_ring) {
-      nir_def *has_output_vertex = nir_ilt(b, invocation_index, num_vtx);
-      nir_if *if_has_output_vertex = nir_push_if(b, has_output_vertex);
-      {
-         emit_ms_vertex(b, invocation_index, row_start, !wait_attr_ring, true, per_vertex_outputs, s);
-      }
-      nir_pop_if(b, if_has_output_vertex);
+      emit_ms_outputs(b, invocation_index, row_start, num_vtx, !wait_attr_ring, true,
+                      per_vertex_outputs, &emit_ms_vertex, s);
    }
 
    /* Export primitives. */
    if (per_primitive_outputs || !wait_attr_ring) {
-      nir_def *has_output_primitive = nir_ilt(b, invocation_index, num_prm);
-      nir_if *if_has_output_primitive = nir_push_if(b, has_output_primitive);
-      {
-         emit_ms_primitive(b, invocation_index, row_start, !wait_attr_ring, true, per_primitive_outputs, s);
-      }
-      nir_pop_if(b, if_has_output_primitive);
+      emit_ms_outputs(b, invocation_index, row_start, num_prm, !wait_attr_ring, true,
+                      per_primitive_outputs, &emit_ms_primitive, s);
    }
 
    /* When we need to wait for attribute ring stores, we emit both position and primitive
@@ -4559,20 +4566,11 @@ emit_ms_finale(nir_builder *b, lower_ngg_ms_state *s)
                      .memory_semantics = NIR_MEMORY_RELEASE,
                      .memory_modes = nir_var_shader_out);
 
-      /* Position export only */
-      nir_def *has_output_vertex = nir_ilt(b, invocation_index, num_vtx);
-      nir_if *if_has_output_vertex = nir_push_if(b, has_output_vertex);
-      {
-         emit_ms_vertex(b, invocation_index, row_start, true, false, per_vertex_outputs, s);
-      }
-      nir_pop_if(b, if_has_output_vertex);
-
-      nir_def *has_output_primitive = nir_ilt(b, invocation_index, num_prm);
-      nir_if *if_has_output_primitive = nir_push_if(b, has_output_primitive);
-      {
-         emit_ms_primitive(b, invocation_index, row_start, true, false, per_primitive_outputs, s);
-      }
-      nir_pop_if(b, if_has_output_primitive);
+      /* Position/primitive export only */
+      emit_ms_outputs(b, invocation_index, row_start, num_vtx, true, false,
+                      per_vertex_outputs, &emit_ms_vertex, s);
+      emit_ms_outputs(b, invocation_index, row_start, num_prm, true, false,
+                      per_primitive_outputs, &emit_ms_primitive, s);
    }
 }
 
-- 
GitLab


From b844f0189e35a562a648df850dad9e91661f09a4 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 19 Oct 2023 19:27:07 +0100
Subject: [PATCH 10/13] ac/nir,radv: pass workgroup size to ac_nir_lower_ngg_ms

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir.h           | 1 +
 src/amd/common/ac_nir_lower_ngg.c | 8 +++-----
 src/amd/vulkan/radv_shader.c      | 5 ++++-
 3 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 0d91a7edb2c92..8c7eac560315a 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -196,6 +196,7 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
                     bool has_param_exports,
                     bool *out_needs_scratch_ring,
                     unsigned wave_size,
+                    unsigned workgroup_size,
                     bool multiview,
                     bool has_query,
                     bool fast_launch_2);
diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 4c2073c378fa4..4cc93a59b2b0e 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -4852,6 +4852,7 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
                     bool has_param_exports,
                     bool *out_needs_scratch_ring,
                     unsigned wave_size,
+                    unsigned workgroup_size,
                     bool multiview,
                     bool has_query,
                     bool fast_launch_2)
@@ -4891,9 +4892,6 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
                                  shader->info.workgroup_size[1] *
                                  shader->info.workgroup_size[2];
 
-   unsigned hw_workgroup_size =
-      ALIGN(MAX3(api_workgroup_size, max_primitives, max_vertices), wave_size);
-
    lower_ngg_ms_state state = {
       .layout = layout,
       .wave_size = wave_size,
@@ -4901,7 +4899,7 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
       .per_primitive_outputs = per_primitive_outputs,
       .vertices_per_prim = vertices_per_prim,
       .api_workgroup_size = api_workgroup_size,
-      .hw_workgroup_size = hw_workgroup_size,
+      .hw_workgroup_size = workgroup_size,
       .insert_layer_output = multiview && !(shader->info.outputs_written & VARYING_BIT_LAYER),
       .uses_cull_flags = uses_cull,
       .gfx_level = gfx_level,
@@ -4944,7 +4942,7 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
     * local_invocation_id isn't initialized for all lanes and we can't perform this optimization for
     * all load_local_invocation_index.
     */
-   if (fast_launch_2 && api_workgroup_size == hw_workgroup_size &&
+   if (fast_launch_2 && api_workgroup_size == workgroup_size &&
        ((shader->info.workgroup_size[0] == 1) + (shader->info.workgroup_size[1] == 1) +
         (shader->info.workgroup_size[2] == 1)) == 2) {
       nir_lower_compute_system_values_options csv_options = {
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 1a87b83a8d771..67a254a74fe45 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -909,10 +909,13 @@ radv_lower_ngg(struct radv_device *device, struct radv_shader_stage *ngg_stage,
 
       NIR_PASS_V(nir, ac_nir_lower_ngg_gs, &options);
    } else if (nir->info.stage == MESA_SHADER_MESH) {
+      /* ACO aligns the workgroup size to the wave size. */
+      unsigned workgroup_size = ALIGN(info->workgroup_size, info->wave_size);
+
       bool scratch_ring = false;
       NIR_PASS_V(nir, ac_nir_lower_ngg_ms, options.gfx_level, options.clipdist_enable_mask,
                  options.vs_output_param_offset, options.has_param_exports, &scratch_ring, info->wave_size,
-                 pl_key->has_multiview_view_index, info->ms.has_query, device->mesh_fast_launch_2);
+                 workgroup_size, pl_key->has_multiview_view_index, info->ms.has_query, device->mesh_fast_launch_2);
       ngg_stage->info.ms.needs_ms_scratch_ring = scratch_ring;
    } else {
       unreachable("invalid SW stage passed to radv_lower_ngg");
-- 
GitLab


From 483a7218d2f505e27c6969bb4fe8ad92cd2283d1 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 19 Oct 2023 19:27:07 +0100
Subject: [PATCH 11/13] ac/nir: implement mesh shader multi-row export

Unlike AMDVLK, this has separate loops for attribute stores and exports,
so that the stores from different rows can overlap.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/common/ac_nir_lower_ngg.c | 50 +++++++++++++++++++++++++++----
 1 file changed, 45 insertions(+), 5 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_ngg.c b/src/amd/common/ac_nir_lower_ngg.c
index 4cc93a59b2b0e..5f009f45810bd 100644
--- a/src/amd/common/ac_nir_lower_ngg.c
+++ b/src/amd/common/ac_nir_lower_ngg.c
@@ -198,6 +198,8 @@ typedef struct
 {
    enum amd_gfx_level gfx_level;
    bool fast_launch_2;
+   bool vert_multirow_export;
+   bool prim_multirow_export;
 
    ms_out_mem_layout layout;
    uint64_t per_vertex_outputs;
@@ -4486,12 +4488,48 @@ emit_ms_outputs(nir_builder *b, nir_def *invocation_index, nir_def *row_start,
                            uint64_t, lower_ngg_ms_state *),
                 lower_ngg_ms_state *s)
 {
-   nir_def *has_output = nir_ilt(b, invocation_index, count);
-   nir_if *if_has_output = nir_push_if(b, has_output);
-   {
-      cb(b, invocation_index, row_start, exports, parameters, mask, s);
+   if (cb == &emit_ms_primitive ? s->prim_multirow_export : s->vert_multirow_export) {
+      assert(s->hw_workgroup_size % s->wave_size == 0);
+      const unsigned num_waves = s->hw_workgroup_size / s->wave_size;
+
+      nir_loop *row_loop = nir_push_loop(b);
+      {
+         nir_block *preheader = nir_cf_node_as_block(nir_cf_node_prev(&row_loop->cf_node));
+
+         nir_phi_instr *index = nir_phi_instr_create(b->shader);
+         nir_phi_instr *row = nir_phi_instr_create(b->shader);
+         nir_def_init(&index->instr, &index->def, 1, 32);
+         nir_def_init(&row->instr, &row->def, 1, 32);
+
+         nir_phi_instr_add_src(index, preheader, invocation_index);
+         nir_phi_instr_add_src(row, preheader, row_start);
+
+         nir_if *if_break = nir_push_if(b, nir_uge(b, &index->def, count));
+         {
+            nir_jump(b, nir_jump_break);
+         }
+         nir_pop_if(b, if_break);
+
+         cb(b, &index->def, &row->def, exports, parameters, mask, s);
+
+         nir_block *body = nir_cursor_current_block(b->cursor);
+         nir_phi_instr_add_src(index, body,
+                               nir_iadd_imm(b, &index->def, s->hw_workgroup_size));
+         nir_phi_instr_add_src(row, body,
+                               nir_iadd_imm(b, &row->def, num_waves));
+
+         nir_instr_insert_before_cf_list(&row_loop->body, &row->instr);
+         nir_instr_insert_before_cf_list(&row_loop->body, &index->instr);
+      }
+      nir_pop_loop(b, row_loop);
+   } else {
+      nir_def *has_output = nir_ilt(b, invocation_index, count);
+      nir_if *if_has_output = nir_push_if(b, has_output);
+      {
+         cb(b, invocation_index, row_start, exports, parameters, mask, s);
+      }
+      nir_pop_if(b, if_has_output);
    }
-   nir_pop_if(b, if_has_output);
 }
 
 static void
@@ -4904,6 +4942,8 @@ ac_nir_lower_ngg_ms(nir_shader *shader,
       .uses_cull_flags = uses_cull,
       .gfx_level = gfx_level,
       .fast_launch_2 = fast_launch_2,
+      .vert_multirow_export = fast_launch_2 && max_vertices > workgroup_size,
+      .prim_multirow_export = fast_launch_2 && max_primitives > workgroup_size,
       .clipdist_enable_mask = clipdist_enable_mask,
       .vs_output_param_offset = vs_output_param_offset,
       .has_param_exports = has_param_exports,
-- 
GitLab


From f449d9b28c9e60eec091d4fc3a76e1208e27e3b6 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 17:15:49 +0100
Subject: [PATCH 12/13] radv: implement mesh shader multi-row export

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_shader_info.c | 20 +++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 03754e728eb06..83b9ebf798131 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -724,14 +724,24 @@ gather_shader_info_mesh(const nir_shader *nir, const struct radv_pipeline_key *p
    ngg_info->prim_amp_factor = nir->info.mesh.max_primitives_out;
    ngg_info->vgt_esgs_ring_itemsize = 1;
 
-   unsigned min_ngg_workgroup_size = ac_compute_ngg_workgroup_size(ngg_info->hw_max_esverts, ngg_info->max_gsprims,
-                                                                   ngg_info->max_out_verts, ngg_info->prim_amp_factor);
+   info->ms.has_query = pipeline_key->mesh_shader_queries;
+}
 
+static void
+calc_mesh_workgroup_size(const struct radv_device *device, const nir_shader *nir, struct radv_shader_info *info)
+{
    unsigned api_workgroup_size = ac_compute_cs_workgroup_size(nir->info.workgroup_size, false, UINT32_MAX);
 
-   info->workgroup_size = MAX2(min_ngg_workgroup_size, api_workgroup_size);
+   if (device->mesh_fast_launch_2) {
+      /* Use multi-row export. It is also necessary to use the API workgroup size for non-emulated queries. */
+      info->workgroup_size = api_workgroup_size;
+   } else {
+      struct gfx10_ngg_info *ngg_info = &info->ngg_info;
+      unsigned min_ngg_workgroup_size = ac_compute_ngg_workgroup_size(ngg_info->hw_max_esverts, ngg_info->max_gsprims,
+                                                                      ngg_info->max_out_verts, ngg_info->prim_amp_factor);
 
-   info->ms.has_query = pipeline_key->mesh_shader_queries;
+      info->workgroup_size = MAX2(min_ngg_workgroup_size, api_workgroup_size);
+   }
 }
 
 static void
@@ -1220,7 +1230,7 @@ radv_nir_shader_info_pass(struct radv_device *device, const struct nir_shader *n
                                      (info->workgroup_size % info->wave_size) == 0;
       break;
    case MESA_SHADER_MESH:
-      /* Already computed in gather_shader_info_mesh(). */
+      calc_mesh_workgroup_size(device, nir, info);
       break;
    default:
       /* FS always operates without workgroups. Other stages are computed during linking but assume
-- 
GitLab


From 18a616c0f4f97b906767e2b9a580ccac428c0893 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Sep 2023 11:27:39 +0100
Subject: [PATCH 13/13] radv: enable mesh shader gs_fast_launch=2 and multi-row
 export

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_device.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 83e57a19d8b90..51931cfc16701 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -924,7 +924,7 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
    device->pbb_allowed =
       device->physical_device->rad_info.gfx_level >= GFX9 && !(device->instance->debug_flags & RADV_DEBUG_NOBINNING);
 
-   device->mesh_fast_launch_2 = false;
+   device->mesh_fast_launch_2 = device->physical_device->rad_info.gfx_level >= GFX11;
 
    /* The maximum number of scratch waves. Scratch space isn't divided
     * evenly between CUs. The number is only a function of the number of CUs.
-- 
GitLab

