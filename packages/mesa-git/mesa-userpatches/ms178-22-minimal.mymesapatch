--- a/src/amd/vulkan/radv_cmd_buffer.h	2025-09-07 11:04:15.515661359 +0200
+++ b/src/amd/vulkan/radv_cmd_buffer.h	2025-09-07 11:09:14.952502874 +0200

--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -688,14 +688,66 @@ radv_cmd_set_color_blend_equation(struct
 }
 
 ALWAYS_INLINE static void
-radv_cmd_set_vertex_binding_strides(struct radv_cmd_buffer *cmd_buffer, uint32_t first, uint32_t count,
-                                    const uint16_t *strides)
+radv_cmd_set_vertex_binding_strides(struct radv_cmd_buffer *cmd_buffer,
+                                   uint32_t first,
+                                   uint32_t count,
+                                   const uint16_t *strides)
 {
-   struct radv_cmd_state *state = &cmd_buffer->state;
+    assert(cmd_buffer != NULL);
 
-   typed_memcpy(state->dynamic.vk.vi_binding_strides + first, strides, count);
+    struct radv_cmd_state *state = &cmd_buffer->state;
+    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
+    const struct radv_physical_device *pdev = radv_device_physical(device);
 
-   state->dirty_dynamic |= RADV_DYNAMIC_VERTEX_INPUT_BINDING_STRIDE;
+    /* Bounds check with saturation */
+    if (unlikely(first >= MESA_VK_MAX_VERTEX_BINDINGS)) {
+        return;
+    }
+    count = MIN2(count, MESA_VK_MAX_VERTEX_BINDINGS - first);
+
+    if (unlikely(count == 0 || strides == NULL)) {
+        return;
+    }
+
+    /* Vega optimization: Fast path for single stride update */
+    if (pdev->info.gfx_level == GFX9 && count == 1) {
+        if (state->dynamic.vk.vi_binding_strides[first] != strides[0]) {
+            state->dynamic.vk.vi_binding_strides[first] = strides[0];
+            state->dirty_dynamic |= RADV_DYNAMIC_VERTEX_INPUT_BINDING_STRIDE;
+        }
+        return;
+    }
+
+    /* Check if anything actually changed */
+    bool changed = false;
+    uint16_t *dst = state->dynamic.vk.vi_binding_strides + first;
+
+    /* Vega optimization: Use vectorized comparison for common counts */
+    if (count <= 16 && ((uintptr_t)dst & 7) == 0 && ((uintptr_t)strides & 7) == 0) {
+        /* 8-byte aligned, can use 64-bit comparisons */
+        uint32_t qwords = (count + 3) / 4;
+        const uint64_t *src64 = (const uint64_t *)strides;
+        uint64_t *dst64 = (uint64_t *)dst;
+
+        for (uint32_t i = 0; i < qwords; i++) {
+            if (dst64[i] != src64[i]) {
+                changed = true;
+                dst64[i] = src64[i];
+            }
+        }
+    } else {
+        /* Fallback for unaligned or large counts */
+        for (uint32_t i = 0; i < count; i++) {
+            if (dst[i] != strides[i]) {
+                dst[i] = strides[i];
+                changed = true;
+            }
+        }
+    }
+
+    if (changed) {
+        state->dirty_dynamic |= RADV_DYNAMIC_VERTEX_INPUT_BINDING_STRIDE;
+    }
 }
 
 ALWAYS_INLINE static void
