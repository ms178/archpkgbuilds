From 24b23bdcf9d34825c742142fe074ea7f9daad751 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 Jan 2023 01:14:59 +0100
Subject: [PATCH 1/6] radv: Clear graphics states dirty flags in caller.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 36 +++++++++++++-------------------
 1 file changed, 15 insertions(+), 21 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index acd1d3931f76..b5dbe74ac26f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1806,8 +1806,6 @@ radv_emit_rbplus_state(struct radv_cmd_buffer *cmd_buffer)
       cmd_buffer->state.last_sx_blend_opt_epsilon = sx_blend_opt_epsilon;
       cmd_buffer->state.last_sx_blend_opt_control = sx_blend_opt_control;
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_RBPLUS;
 }
 
 static void
@@ -1918,8 +1916,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       radv_save_pipeline(cmd_buffer, &pipeline->base);
 
    cmd_buffer->state.emitted_graphics_pipeline = pipeline;
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_PIPELINE;
 }
 
 static enum radv_depth_clamp_mode
@@ -3443,8 +3439,6 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
                                 S_028424_DISABLE_CONSTANT_ENCODE_REG(disable_constant_encode));
       }
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_FRAMEBUFFER;
 }
 
 static void
@@ -3467,12 +3461,10 @@ radv_emit_guardband_state(struct radv_cmd_buffer *cmd_buffer)
 
    si_write_guardband(cmd_buffer->cs, d->vk.vp.viewport_count, d->vk.vp.viewports, rast_prim,
                       d->vk.rs.polygon_mode, d->vk.rs.line.width);
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_GUARDBAND;
 }
 
 static void
-radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
+radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    struct radv_cmd_state *state = &cmd_buffer->state;
@@ -3482,11 +3474,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
    if (state->index_type < 0)
       return;
 
-   /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-    * the index_va and max_index_count already. */
-   if (!indirect)
-      return;
-
    if (state->max_index_count ||
        !cmd_buffer->device->physical_device->rad_info.has_zero_index_buffer_bug) {
       radeon_emit(cs, PKT3(PKT3_INDEX_BASE, 1, 0));
@@ -3496,8 +3483,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
       radeon_emit(cs, PKT3(PKT3_INDEX_BUFFER_SIZE, 0, 0));
       radeon_emit(cs, state->max_index_count);
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
 }
 
 void
@@ -7133,6 +7118,7 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
           */
          radv_emit_fb_mip_change_flush(primary);
          radv_emit_framebuffer_state(primary);
+         primary->state.dirty &= ~RADV_CMD_DIRTY_FRAMEBUFFER;
       }
 
       if (secondary->ace_internal.cs) {
@@ -8559,10 +8545,8 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
       radv_emit_rbplus_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY) {
-      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_NGG_QUERY;
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY)
       radv_flush_ngg_query_state(cmd_buffer);
-   }
 
    if ((cmd_buffer->state.dirty &
         (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
@@ -8593,8 +8577,14 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       radv_emit_guardband_state(cmd_buffer);
 
    if (info->indexed) {
-      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
-         radv_emit_index_buffer(cmd_buffer, info->indirect);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER &&
+          info->indirect) {
+         /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+          * the index_va and max_index_count already.
+          */
+         radv_emit_index_buffer(cmd_buffer);
+         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
+      }
    } else {
       /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
        * so the state must be re-emitted before the next indexed
@@ -8605,6 +8595,10 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       }
    }
 
+   cmd_buffer->state.dirty &=
+      ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
+        RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND);
+
    if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
       struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
       uint64_t dynamic_states =
-- 
GitLab


From 978d495383e3887e86ed89746615b4c64237cefb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 Jan 2023 01:17:08 +0100
Subject: [PATCH 2/6] radv: Move pre-computing tess info to
 radv_cmd_buffer_flush_dynamic_state.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 52 ++++++++++++++------------------
 1 file changed, 23 insertions(+), 29 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index b5dbe74ac26f..c34ad07a7954 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4254,6 +4254,29 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (!states)
       return;
 
+   /* Pre-compute some tessellation info that depend on the number of patch control points when the
+    * bound pipeline declared this state as dynamic.
+    */
+   if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
+      const struct radv_physical_device *pdevice = cmd_buffer->device->physical_device;
+      const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+      const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+      const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+
+      /* Compute the number of patches and emit the context register. */
+      cmd_buffer->state.tess_num_patches = get_tcs_num_patches(
+         d->vk.ts.patch_control_points, tcs->info.tcs.tcs_vertices_out,
+         tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
+         tcs->info.tcs.num_linked_patch_outputs, pdevice->hs.tess_offchip_block_dw_size,
+         pdevice->rad_info.gfx_level, pdevice->rad_info.family);
+
+      /* Compute the LDS size and emit the shader register. */
+      cmd_buffer->state.tess_lds_size = calculate_tess_lds_size(
+         pdevice->rad_info.gfx_level, d->vk.ts.patch_control_points, tcs->info.tcs.tcs_vertices_out,
+         tcs->info.tcs.num_linked_inputs, cmd_buffer->state.tess_num_patches,
+         tcs->info.tcs.num_linked_outputs, tcs->info.tcs.num_linked_patch_outputs);
+   }
+
    if (states & (RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_ENABLE |
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE |
@@ -8615,35 +8638,6 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       }
    }
 
-   /* Pre-compute some tessellation info that depend on the number of patch control points when the
-    * bound pipeline declared this state as dynamic.
-    */
-   if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
-
-      if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
-         const struct radv_physical_device *pdevice = device->physical_device;
-         const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
-         const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
-         const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-
-         /* Compute the number of patches and emit the context register. */
-         cmd_buffer->state.tess_num_patches = get_tcs_num_patches(
-            d->vk.ts.patch_control_points, tcs->info.tcs.tcs_vertices_out,
-            tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
-            tcs->info.tcs.num_linked_patch_outputs, pdevice->hs.tess_offchip_block_dw_size,
-            pdevice->rad_info.gfx_level, pdevice->rad_info.family);
-
-         /* Compute the LDS size and emit the shader register. */
-         cmd_buffer->state.tess_lds_size = calculate_tess_lds_size(
-            pdevice->rad_info.gfx_level, d->vk.ts.patch_control_points,
-            tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
-            cmd_buffer->state.tess_num_patches, tcs->info.tcs.num_linked_outputs,
-            tcs->info.tcs.num_linked_patch_outputs);
-      }
-   }
-
    radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
 
    radv_emit_draw_registers(cmd_buffer, info);
-- 
GitLab


From cb5c128cfc5ab05728230f789bee727bcc4e3565 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 02:11:22 +0100
Subject: [PATCH 3/6] radv: Clear descriptor dirty flags in caller.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 107 +++++++++++++++----------------
 1 file changed, 52 insertions(+), 55 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index c34ad07a7954..1cf43d06356c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4841,8 +4841,6 @@ radv_flush_vertex_descriptors(struct radv_cmd_buffer *cmd_buffer)
 
    if (unlikely(cmd_buffer->device->trace_bo))
       radv_save_vertex_descriptors(cmd_buffer, (uintptr_t)vb_ptr);
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_VERTEX_BUFFER;
 }
 
 static void
@@ -4875,71 +4873,67 @@ radv_emit_streamout_buffers(struct radv_cmd_buffer *cmd_buffer, uint64_t va)
 static void
 radv_flush_streamout_descriptors(struct radv_cmd_buffer *cmd_buffer)
 {
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_STREAMOUT_BUFFER) {
-      struct radv_streamout_binding *sb = cmd_buffer->streamout_bindings;
-      struct radv_streamout_state *so = &cmd_buffer->state.streamout;
-      unsigned so_offset;
-      uint64_t desc_va;
-      void *so_ptr;
+   struct radv_streamout_binding *sb = cmd_buffer->streamout_bindings;
+   struct radv_streamout_state *so = &cmd_buffer->state.streamout;
+   unsigned so_offset;
+   uint64_t desc_va;
+   void *so_ptr;
 
-      /* Allocate some descriptor state for streamout buffers. */
-      if (!radv_cmd_buffer_upload_alloc(cmd_buffer, MAX_SO_BUFFERS * 16, &so_offset, &so_ptr))
-         return;
+   /* Allocate some descriptor state for streamout buffers. */
+   if (!radv_cmd_buffer_upload_alloc(cmd_buffer, MAX_SO_BUFFERS * 16, &so_offset, &so_ptr))
+      return;
+
+   for (uint32_t i = 0; i < MAX_SO_BUFFERS; i++) {
+      struct radv_buffer *buffer = sb[i].buffer;
+      uint32_t *desc = &((uint32_t *)so_ptr)[i * 4];
+      uint32_t size = 0;
+      uint64_t va = 0;
 
-      for (uint32_t i = 0; i < MAX_SO_BUFFERS; i++) {
-         struct radv_buffer *buffer = sb[i].buffer;
-         uint32_t *desc = &((uint32_t *)so_ptr)[i * 4];
-         uint32_t size = 0;
-         uint64_t va = 0;
+      if (so->enabled_mask & (1 << i)) {
+         va = radv_buffer_get_va(buffer->bo) + buffer->offset;
 
-         if (so->enabled_mask & (1 << i)) {
-            va = radv_buffer_get_va(buffer->bo) + buffer->offset;
+         va += sb[i].offset;
 
-            va += sb[i].offset;
+         /* Set the descriptor.
+          *
+          * On GFX8, the format must be non-INVALID, otherwise
+          * the buffer will be considered not bound and store
+          * instructions will be no-ops.
+          */
+         size = 0xffffffff;
 
-            /* Set the descriptor.
-             *
-             * On GFX8, the format must be non-INVALID, otherwise
-             * the buffer will be considered not bound and store
-             * instructions will be no-ops.
+         if (cmd_buffer->device->physical_device->use_ngg_streamout) {
+            /* With NGG streamout, the buffer size is used to determine the max emit per buffer
+             * and also acts as a disable bit when it's 0.
              */
-            size = 0xffffffff;
-
-            if (cmd_buffer->device->physical_device->use_ngg_streamout) {
-               /* With NGG streamout, the buffer size is used to determine the max emit per buffer
-                * and also acts as a disable bit when it's 0.
-                */
-               size = radv_is_streamout_enabled(cmd_buffer) ? sb[i].size : 0;
-            }
+            size = radv_is_streamout_enabled(cmd_buffer) ? sb[i].size : 0;
          }
+      }
 
-         uint32_t rsrc_word3 =
-            S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) | S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
-            S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) | S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W);
-
-         if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX11) {
-            rsrc_word3 |= S_008F0C_FORMAT(V_008F0C_GFX11_FORMAT_32_FLOAT) |
-                          S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW);
-         } else if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX10) {
-            rsrc_word3 |= S_008F0C_FORMAT(V_008F0C_GFX10_FORMAT_32_FLOAT) |
-                          S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW) | S_008F0C_RESOURCE_LEVEL(1);
-         } else {
-            rsrc_word3 |= S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);
-         }
+      uint32_t rsrc_word3 =
+         S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) | S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
+         S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) | S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W);
 
-         desc[0] = va;
-         desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32);
-         desc[2] = size;
-         desc[3] = rsrc_word3;
+      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX11) {
+         rsrc_word3 |= S_008F0C_FORMAT(V_008F0C_GFX11_FORMAT_32_FLOAT) |
+                       S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW);
+      } else if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX10) {
+         rsrc_word3 |= S_008F0C_FORMAT(V_008F0C_GFX10_FORMAT_32_FLOAT) |
+                       S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW) | S_008F0C_RESOURCE_LEVEL(1);
+      } else {
+         rsrc_word3 |= S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);
       }
 
-      desc_va = radv_buffer_get_va(cmd_buffer->upload.upload_bo);
-      desc_va += so_offset;
-
-      radv_emit_streamout_buffers(cmd_buffer, desc_va);
+      desc[0] = va;
+      desc[1] = S_008F04_BASE_ADDRESS_HI(va >> 32);
+      desc[2] = size;
+      desc[3] = rsrc_word3;
    }
 
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_STREAMOUT_BUFFER;
+   desc_va = radv_buffer_get_va(cmd_buffer->upload.upload_bo);
+   desc_va += so_offset;
+
+   radv_emit_streamout_buffers(cmd_buffer, desc_va);
 }
 
 static void
@@ -5036,7 +5030,10 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer)
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_VERTEX_BUFFER)
       radv_flush_vertex_descriptors(cmd_buffer);
 
-   radv_flush_streamout_descriptors(cmd_buffer);
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_STREAMOUT_BUFFER)
+      radv_flush_streamout_descriptors(cmd_buffer);
+
+   cmd_buffer->state.dirty &= ~(RADV_CMD_DIRTY_VERTEX_BUFFER | RADV_CMD_DIRTY_STREAMOUT_BUFFER);
 
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-- 
GitLab


From ef5e273fe0cfa1e6a2944a1dac18782470d550be Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 25 Jan 2023 18:57:53 +0100
Subject: [PATCH 4/6] radv: Slight refactor to late_scissor_emission.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There is no need to set context_roll_without_scissor_emitted
when pipeline, rbplus state, or binning state changes,
because radv_need_late_scissor_emission already checks
their dirty flags.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Acked-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 37 ++++++++++++--------------------
 1 file changed, 14 insertions(+), 23 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 1cf43d06356c..46ac00241e93 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1115,8 +1115,6 @@ radv_emit_sample_locations(struct radv_cmd_buffer *cmd_buffer)
    radeon_set_context_reg_seq(cs, R_028BD4_PA_SC_CENTROID_PRIORITY_0, 2);
    radeon_emit(cs, centroid_priority);
    radeon_emit(cs, centroid_priority >> 32);
-
-   cmd_buffer->state.context_roll_without_scissor_emitted = true;
 }
 
 static void
@@ -1588,8 +1586,6 @@ radv_emit_binning_state(struct radv_cmd_buffer *cmd_buffer)
 
    radeon_set_context_reg(cmd_buffer->cs, R_028C44_PA_SC_BINNER_CNTL_0, pa_sc_binner_cntl_0);
 
-   cmd_buffer->state.context_roll_without_scissor_emitted = true;
-
    cmd_buffer->state.last_pa_sc_binner_cntl_0 = pa_sc_binner_cntl_0;
 }
 
@@ -1800,8 +1796,6 @@ radv_emit_rbplus_state(struct radv_cmd_buffer *cmd_buffer)
       radeon_emit(cmd_buffer->cs, sx_blend_opt_epsilon);
       radeon_emit(cmd_buffer->cs, sx_blend_opt_control);
 
-      cmd_buffer->state.context_roll_without_scissor_emitted = true;
-
       cmd_buffer->state.last_sx_ps_downconvert = sx_ps_downconvert;
       cmd_buffer->state.last_sx_blend_opt_epsilon = sx_blend_opt_epsilon;
       cmd_buffer->state.last_sx_blend_opt_control = sx_blend_opt_control;
@@ -1878,7 +1872,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
        memcmp(cmd_buffer->state.emitted_graphics_pipeline->base.ctx_cs.buf, pipeline->base.ctx_cs.buf,
               pipeline->base.ctx_cs.cdw * 4)) {
       radeon_emit_array(cmd_buffer->cs, pipeline->base.ctx_cs.buf, pipeline->base.ctx_cs.cdw);
-      cmd_buffer->state.context_roll_without_scissor_emitted = true;
    }
 
    if (device->pbb_allowed) {
@@ -1999,8 +1992,6 @@ static void
 radv_emit_scissor(struct radv_cmd_buffer *cmd_buffer)
 {
    radv_write_scissors(cmd_buffer, cmd_buffer->cs);
-
-   cmd_buffer->state.context_roll_without_scissor_emitted = false;
 }
 
 static void
@@ -8395,21 +8386,17 @@ radv_need_late_scissor_emission(struct radv_cmd_buffer *cmd_buffer,
 {
    struct radv_cmd_state *state = &cmd_buffer->state;
 
-   if (!cmd_buffer->device->physical_device->rad_info.has_gfx9_scissor_bug)
-      return false;
-
    if (cmd_buffer->state.context_roll_without_scissor_emitted || info->strmout_buffer)
       return true;
 
    uint64_t used_states =
       cmd_buffer->state.graphics_pipeline->needed_dynamic_state | ~RADV_CMD_DIRTY_DYNAMIC_ALL;
 
-   /* Index, vertex and streamout buffers don't change context regs, and
-    * pipeline is already handled.
+   /* Index, vertex and streamout buffers don't change context regs.
+    * We assume that any other dirty flag causes context rolls.
     */
    used_states &= ~(RADV_CMD_DIRTY_INDEX_BUFFER | RADV_CMD_DIRTY_VERTEX_BUFFER |
-                    RADV_CMD_DIRTY_DYNAMIC_VERTEX_INPUT | RADV_CMD_DIRTY_STREAMOUT_BUFFER |
-                    RADV_CMD_DIRTY_PIPELINE);
+                    RADV_CMD_DIRTY_DYNAMIC_VERTEX_INPUT | RADV_CMD_DIRTY_STREAMOUT_BUFFER);
 
    if (cmd_buffer->state.dirty & used_states)
       return true;
@@ -8532,7 +8519,6 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
                               bool pipeline_is_dirty)
 {
    const struct radv_device *device = cmd_buffer->device;
-   bool late_scissor_emission;
 
    if (cmd_buffer->state.graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.has_epilog) {
       struct radv_shader_part *ps_epilog = NULL;
@@ -8562,6 +8548,14 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
          radv_emit_ps_epilog_state(cmd_buffer, ps_epilog, pipeline_is_dirty);
    }
 
+   /* Determine whether GFX9 late scissor workaround should be applied based on:
+    * 1. radv_need_late_scissor_emission
+    * 2. any dirty dynamic flags that may cause context rolls
+    */
+   const bool late_scissor_emission =
+      cmd_buffer->device->physical_device->rad_info.has_gfx9_scissor_bug
+      ? radv_need_late_scissor_emission(cmd_buffer, info) : false;
+
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
       radv_emit_rbplus_state(cmd_buffer);
 
@@ -8585,11 +8579,6 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
       radv_emit_graphics_pipeline(cmd_buffer);
 
-   /* This should be before the cmd_buffer->state.dirty is cleared
-    * (excluding RADV_CMD_DIRTY_PIPELINE) and after
-    * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
-   late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
-
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
       radv_emit_framebuffer_state(cmd_buffer);
 
@@ -8639,8 +8628,10 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
 
    radv_emit_draw_registers(cmd_buffer, info);
 
-   if (late_scissor_emission)
+   if (unlikely(late_scissor_emission)) {
       radv_emit_scissor(cmd_buffer);
+      cmd_buffer->state.context_roll_without_scissor_emitted = false;
+   }
 }
 
 /* MUST inline this function to avoid massive perf loss in drawoverhead */
-- 
GitLab


From 2d624abeb0b18f402ce3161e5bd485ec1e479579 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 2 Mar 2023 16:21:13 -0800
Subject: [PATCH 5/6] radv: Group dirty flag checks in
 radv_emit_all_graphics_state.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on the original idea by Mike Blumenkrantz.
Thanks to moving around some additional code in previous commits,
this now has a notable effect on VK draw overhead.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 128 ++++++++++++++++---------------
 1 file changed, 65 insertions(+), 63 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 46ac00241e93..93c7f5666d0d 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -8556,75 +8556,77 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       cmd_buffer->device->physical_device->rad_info.has_gfx9_scissor_bug
       ? radv_need_late_scissor_emission(cmd_buffer, info) : false;
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
-      radv_emit_rbplus_state(cmd_buffer);
-
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY)
-      radv_flush_ngg_query_state(cmd_buffer);
-
-   if ((cmd_buffer->state.dirty &
-        (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
-         RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
-         RADV_CMD_DIRTY_DYNAMIC_VIEWPORT | RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE |
-         RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES | RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) &&
-       cmd_buffer->state.has_nggc)
-      radv_emit_ngg_culling_state(cmd_buffer);
-
-   if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
-                                   RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
-                                   RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE)) ||
-       cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
-      radv_emit_binning_state(cmd_buffer);
-
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
-      radv_emit_graphics_pipeline(cmd_buffer);
-
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
-      radv_emit_framebuffer_state(cmd_buffer);
-
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
-      radv_emit_guardband_state(cmd_buffer);
-
-   if (info->indexed) {
-      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER &&
-          info->indirect) {
-         /* For the direct indexed draws we use DRAW_INDEX_2, which includes
-          * the index_va and max_index_count already.
-          */
-         radv_emit_index_buffer(cmd_buffer);
-         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
-      }
-   } else {
-      /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
-       * so the state must be re-emitted before the next indexed
-       * draw.
-       */
-      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
-         cmd_buffer->state.last_index_type = -1;
+   if (cmd_buffer->state.dirty) {
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
+         radv_emit_rbplus_state(cmd_buffer);
+
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY)
+         radv_flush_ngg_query_state(cmd_buffer);
+
+      if ((cmd_buffer->state.dirty &
+         (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+            RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
+            RADV_CMD_DIRTY_DYNAMIC_VIEWPORT | RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE |
+            RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES | RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) &&
+         cmd_buffer->state.has_nggc)
+         radv_emit_ngg_culling_state(cmd_buffer);
+
+      if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
+                                    RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
+                                    RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE)) ||
+         cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
+         radv_emit_binning_state(cmd_buffer);
+
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
+         radv_emit_graphics_pipeline(cmd_buffer);
+
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
+         radv_emit_framebuffer_state(cmd_buffer);
+
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
+         radv_emit_guardband_state(cmd_buffer);
+
+      if (info->indexed) {
+         if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER &&
+            info->indirect) {
+            /* For the direct indexed draws we use DRAW_INDEX_2, which includes
+             * the index_va and max_index_count already.
+             */
+            radv_emit_index_buffer(cmd_buffer);
+            cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
+         }
+      } else {
+         /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
+         * so the state must be re-emitted before the next indexed
+         * draw.
+         */
+         if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
+            cmd_buffer->state.last_index_type = -1;
+         }
       }
-   }
 
-   cmd_buffer->state.dirty &=
-      ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
-        RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND);
+      cmd_buffer->state.dirty &=
+         ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
+         RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND);
 
-   if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
-      struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+      if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
+         struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+         uint64_t dynamic_states =
+            cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
 
-      if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
-          d->vk.fsr.fragment_size.width == 1 && d->vk.fsr.fragment_size.height == 1 &&
-          d->vk.fsr.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
-          d->vk.fsr.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
-         /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
-          * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
-          */
-         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
+            d->vk.fsr.fragment_size.width == 1 && d->vk.fsr.fragment_size.height == 1 &&
+            d->vk.fsr.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
+            d->vk.fsr.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
+            /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
+            * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
+            */
+            cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         }
       }
-   }
 
-   radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+      radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+   }
 
    radv_emit_draw_registers(cmd_buffer, info);
 
-- 
GitLab


From fb234556879e3ab2e6113b203cbab9ff185e491c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 01:19:44 +0100
Subject: [PATCH 6/6] radv: Move check from radv_cmd_buffer_flush_dynamic_state
 to caller.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 18 ++++++++----------
 1 file changed, 8 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 93c7f5666d0d..9fc3a48bad8e 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4237,14 +4237,9 @@ radv_emit_line_rasterization_mode(struct radv_cmd_buffer *cmd_buffer)
 }
 
 static void
-radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pipeline_is_dirty)
+radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, const uint64_t states,
+                                    const bool pipeline_is_dirty)
 {
-   const uint64_t states =
-      cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
-
-   if (!states)
-      return;
-
    /* Pre-compute some tessellation info that depend on the number of patch control points when the
     * bound pipeline declared this state as dynamic.
     */
@@ -4387,8 +4382,6 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
                  RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
                  RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE))
       radv_emit_msaa_state(cmd_buffer);
-
-   cmd_buffer->state.dirty &= ~states;
 }
 
 static void
@@ -8625,7 +8618,12 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
          }
       }
 
-      radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+      const uint64_t states =
+         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+      if (states) {
+         radv_cmd_buffer_flush_dynamic_state(cmd_buffer, states, pipeline_is_dirty);
+         cmd_buffer->state.dirty &= ~states;
+      }
    }
 
    radv_emit_draw_registers(cmd_buffer, info);
-- 
GitLab

