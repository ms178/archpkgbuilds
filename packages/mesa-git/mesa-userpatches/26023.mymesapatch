From 16d86b57e560f12945a29934e23063f1317bdcb5 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Fri, 3 Nov 2023 19:11:44 +0900
Subject: [PATCH 1/4] aco: Replace aco_vs_input_state.divisors with bitfields.

Instead of concrete divisor value, we only pass down the information
whether the divisor is zero or nontrivial (>1).
---
 src/amd/compiler/aco_instruction_selection.cpp | 14 ++++++--------
 src/amd/compiler/aco_shader_info.h             |  2 +-
 src/amd/vulkan/radv_aco_shader_info.h          |  2 +-
 3 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index b55d60afab999..36bcf872479cf 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12799,12 +12799,11 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
             }
          }
 
-         bool needs_instance_index = false;
-         bool needs_start_instance = false;
-         u_foreach_bit (i, pinfo->state.instance_rate_inputs & attrib_mask) {
-            needs_instance_index |= pinfo->state.divisors[i] == 1;
-            needs_start_instance |= pinfo->state.divisors[i] == 0;
-         }
+         bool needs_instance_index =
+            pinfo->state.instance_rate_inputs & attrib_mask &
+            ~(pinfo->state.zero_divisors | pinfo->state.nontrivial_divisors); /* divisor is 1 */
+         bool needs_start_instance =
+            pinfo->state.instance_rate_inputs & attrib_mask & pinfo->state.zero_divisors;
          bool needs_vertex_index = ~pinfo->state.instance_rate_inputs & attrib_mask;
          if (needs_vertex_index)
             bld.vadd32(Definition(vertex_index, v1), get_arg_fixed(args, args->base_vertex),
@@ -12824,8 +12823,7 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
          /* calculate index */
          Operand fetch_index = Operand(vertex_index, v1);
          if (pinfo->state.instance_rate_inputs & (1u << loc)) {
-            uint32_t divisor = pinfo->state.divisors[loc];
-            if (divisor) {
+            if (!(pinfo->state.zero_divisors & (1u << loc))) {
                fetch_index = instance_id;
                if (pinfo->state.nontrivial_divisors & (1u << loc)) {
                   unsigned index =
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 2664fdae3f87f..5fdb96fa83349 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -44,6 +44,7 @@ extern "C" {
 struct aco_vs_input_state {
    uint32_t instance_rate_inputs;
    uint32_t nontrivial_divisors;
+   uint32_t zero_divisors;
    uint32_t post_shuffle;
    /* Having two separate fields instead of a single uint64_t makes it easier to remove attributes
     * using bitwise arithmetic.
@@ -51,7 +52,6 @@ struct aco_vs_input_state {
    uint32_t alpha_adjust_lo;
    uint32_t alpha_adjust_hi;
 
-   uint32_t divisors[ACO_MAX_VERTEX_ATTRIBS];
    uint8_t formats[ACO_MAX_VERTEX_ATTRIBS];
 };
 
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index ec235a7279bf8..b888758252524 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -80,10 +80,10 @@ radv_aco_convert_vs_prolog_key(struct aco_vs_prolog_info *aco_info, const struct
 {
    ASSIGN_VS_STATE_FIELD(instance_rate_inputs);
    ASSIGN_VS_STATE_FIELD(nontrivial_divisors);
+   ASSIGN_VS_STATE_FIELD(zero_divisors);
    ASSIGN_VS_STATE_FIELD(post_shuffle);
    ASSIGN_VS_STATE_FIELD(alpha_adjust_lo);
    ASSIGN_VS_STATE_FIELD(alpha_adjust_hi);
-   ASSIGN_VS_STATE_FIELD_CP(divisors);
    ASSIGN_VS_STATE_FIELD_CP(formats);
    ASSIGN_FIELD(num_attributes);
    ASSIGN_FIELD(misaligned_mask);
-- 
GitLab


From 6b677b132f8d979fa8337a2b58e50df86c186f49 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Fri, 3 Nov 2023 20:32:36 +0900
Subject: [PATCH 2/4] radv: Remove last VS prolog reuse logic.

This was broken as the field was never assigned to. This will also be
dropped from the upcoming prolog/epilog lookup rework, as it adds to
code complexity while the benefit of saving one hash table memory access
seems questionable.
---
 src/amd/vulkan/radv_cmd_buffer.c | 4 ----
 src/amd/vulkan/radv_private.h    | 2 --
 2 files changed, 6 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 709de1256f686..2e5314a52ae81 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3871,10 +3871,6 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
 
    uint32_t hash = radv_hash_vs_prolog(key_words);
 
-   if (cmd_buffer->state.emitted_vs_prolog && cmd_buffer->state.emitted_vs_prolog_key_hash == hash &&
-       radv_cmp_vs_prolog(key_words, cmd_buffer->state.emitted_vs_prolog_key))
-      return cmd_buffer->state.emitted_vs_prolog;
-
    u_rwlock_rdlock(&device->vs_prologs_lock);
    struct hash_entry *prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
    u_rwlock_rdunlock(&device->vs_prologs_lock);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 69d601c45b488..32c39bc91f61e 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1717,8 +1717,6 @@ struct radv_cmd_state {
    uint32_t rt_stack_size;
 
    struct radv_shader_part *emitted_vs_prolog;
-   uint32_t *emitted_vs_prolog_key;
-   uint32_t emitted_vs_prolog_key_hash;
    uint32_t vbo_misaligned_mask;
    uint32_t vbo_misaligned_mask_invalid;
    uint32_t vbo_bound_mask;
-- 
GitLab


From 301231afc4354d71f43482bd7d5a917fb03bad25 Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Fri, 3 Nov 2023 19:07:51 +0900
Subject: [PATCH 3/4] radv, aco: Rework VS prolog key handling.

The main change is to use struct radv_vs_prolog_key directly instead of
the compressed representation to simplify an upcoming rework in prolog /
epilog caching. In doing so the state struct pointer was replaced with
an inline struct.

Care was also taken to pre-mask all the states with the active attribute
mask and other masks when it makes sense; this ensures that we don't
accidentally use information not hashed into the key during compilation.
---
 .../compiler/aco_instruction_selection.cpp    |   7 +-
 src/amd/vulkan/radv_aco_shader_info.h         |   4 +-
 src/amd/vulkan/radv_cmd_buffer.c              | 112 ++++--------------
 src/amd/vulkan/radv_device.c                  |  24 +---
 src/amd/vulkan/radv_shader.c                  |   2 +-
 src/amd/vulkan/radv_shader.h                  |  16 ++-
 6 files changed, 45 insertions(+), 120 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 36bcf872479cf..336fd9260f5ef 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12739,7 +12739,7 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
    bld.sopp(aco_opcode::s_setprio, -1u, 0x3u);
 
    uint32_t attrib_mask = BITFIELD_MASK(pinfo->num_attributes);
-   bool has_nontrivial_divisors = pinfo->state.nontrivial_divisors & attrib_mask;
+   bool has_nontrivial_divisors = pinfo->state.nontrivial_divisors;
 
    wait_imm lgkm_imm;
    lgkm_imm.lgkm = 0;
@@ -12800,10 +12800,9 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
          }
 
          bool needs_instance_index =
-            pinfo->state.instance_rate_inputs & attrib_mask &
+            pinfo->state.instance_rate_inputs &
             ~(pinfo->state.zero_divisors | pinfo->state.nontrivial_divisors); /* divisor is 1 */
-         bool needs_start_instance =
-            pinfo->state.instance_rate_inputs & attrib_mask & pinfo->state.zero_divisors;
+         bool needs_start_instance = pinfo->state.instance_rate_inputs & pinfo->state.zero_divisors;
          bool needs_vertex_index = ~pinfo->state.instance_rate_inputs & attrib_mask;
          if (needs_vertex_index)
             bld.vadd32(Definition(vertex_index, v1), get_arg_fixed(args, args->base_vertex),
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index b888758252524..e75ba5826aa17 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -72,8 +72,8 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info, const struct radv
    aco_info->next_stage_pc = radv_args->next_stage_pc;
 }
 
-#define ASSIGN_VS_STATE_FIELD(x)    aco_info->state.x = radv->state->x
-#define ASSIGN_VS_STATE_FIELD_CP(x) memcpy(&aco_info->state.x, &radv->state->x, sizeof(radv->state->x))
+#define ASSIGN_VS_STATE_FIELD(x)    aco_info->state.x = radv->state.x
+#define ASSIGN_VS_STATE_FIELD_CP(x) memcpy(&aco_info->state.x, &radv->state.x, sizeof(radv->state.x))
 static inline void
 radv_aco_convert_vs_prolog_key(struct aco_vs_prolog_info *aco_info, const struct radv_vs_prolog_key *radv,
                                const struct radv_shader_args *radv_args)
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 2e5314a52ae81..8b66116e8d917 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3691,53 +3691,25 @@ radv_instance_rate_prolog_index(unsigned num_attributes, uint32_t instance_rate_
    return start_index + offset_from_start_index + first;
 }
 
-union vs_prolog_key_header {
-   struct {
-      uint32_t key_size : 8;
-      uint32_t num_attributes : 6;
-      uint32_t as_ls : 1;
-      uint32_t is_ngg : 1;
-      uint32_t wave32 : 1;
-      uint32_t next_stage : 3;
-      uint32_t instance_rate_inputs : 1;
-      uint32_t alpha_adjust_lo : 1;
-      uint32_t alpha_adjust_hi : 1;
-      uint32_t misaligned_mask : 1;
-      uint32_t post_shuffle : 1;
-      uint32_t nontrivial_divisors : 1;
-      uint32_t zero_divisors : 1;
-      /* We need this to ensure the padding is zero. It's useful even if it's unused. */
-      uint32_t padding0 : 5;
-   };
-   uint32_t v;
-};
-
 uint32_t
 radv_hash_vs_prolog(const void *key_)
 {
-   const uint32_t *key = key_;
-   union vs_prolog_key_header header;
-   header.v = key[0];
-   return _mesa_hash_data(key, header.key_size);
+   const struct radv_vs_prolog_key *key = key_;
+   return _mesa_hash_data(key, sizeof(*key));
 }
 
 bool
 radv_cmp_vs_prolog(const void *a_, const void *b_)
 {
-   const uint32_t *a = a_;
-   const uint32_t *b = b_;
-   if (a[0] != b[0])
-      return false;
+   const struct radv_vs_prolog_key *a = a_;
+   const struct radv_vs_prolog_key *b = b_;
 
-   union vs_prolog_key_header header;
-   header.v = a[0];
-   return memcmp(a, b, header.key_size) == 0;
+   return memcmp(a, b, sizeof(*a)) == 0;
 }
 
 static struct radv_shader_part *
 lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *vs_shader, uint32_t *nontrivial_divisors)
 {
-   STATIC_ASSERT(sizeof(union vs_prolog_key_header) == 4);
    assert(vs_shader->info.vs.dynamic_inputs);
 
    const struct radv_vs_input_state *state = &cmd_buffer->state.dynamic_vs_input;
@@ -3800,12 +3772,17 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    if (prolog)
       return prolog;
 
-   /* if we couldn't use a pre-compiled prolog, find one in the cache or create one */
-   uint32_t key_words[17];
-   unsigned key_size = 1;
-
    struct radv_vs_prolog_key key;
-   key.state = state;
+   memset(&key, 0, sizeof(key));
+   key.state.instance_rate_inputs = instance_rate_inputs;
+   key.state.nontrivial_divisors = *nontrivial_divisors;
+   key.state.zero_divisors = zero_divisors;
+   /* If the attribute is aligned, post shuffle is implemented using DST_SEL instead. */
+   key.state.post_shuffle = state->post_shuffle & attribute_mask & misaligned_mask;
+   key.state.alpha_adjust_hi = state->alpha_adjust_hi & attribute_mask;
+   key.state.alpha_adjust_lo = state->alpha_adjust_lo & attribute_mask;
+   u_foreach_bit (index, misaligned_mask)
+      key.state.formats[index] = state->formats[index];
    key.num_attributes = num_attributes;
    key.misaligned_mask = misaligned_mask;
    /* The instance ID input VGPR is placed differently when as_ls=true. */
@@ -3820,78 +3797,29 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
       key.next_stage = vs_shader->info.stage;
    }
 
-   union vs_prolog_key_header header;
-   header.v = 0;
-   header.num_attributes = num_attributes;
-   header.as_ls = key.as_ls;
-   header.is_ngg = key.is_ngg;
-   header.wave32 = key.wave32;
-   header.next_stage = key.next_stage;
-
-   if (instance_rate_inputs & ~*nontrivial_divisors) {
-      header.instance_rate_inputs = true;
-      key_words[key_size++] = instance_rate_inputs;
-   }
-   if (*nontrivial_divisors) {
-      header.nontrivial_divisors = true;
-      key_words[key_size++] = *nontrivial_divisors;
-   }
-   if (zero_divisors) {
-      header.zero_divisors = true;
-      key_words[key_size++] = zero_divisors;
-   }
-   if (misaligned_mask) {
-      header.misaligned_mask = true;
-      key_words[key_size++] = misaligned_mask;
-
-      uint8_t *formats = (uint8_t *)&key_words[key_size];
-      unsigned num_formats = 0;
-      u_foreach_bit (index, misaligned_mask)
-         formats[num_formats++] = state->formats[index];
-      while (num_formats & 0x3)
-         formats[num_formats++] = 0;
-      key_size += num_formats / 4u;
-
-      if (state->post_shuffle & attribute_mask) {
-         header.post_shuffle = true;
-         key_words[key_size++] = state->post_shuffle & attribute_mask;
-      }
-   }
-   if (state->alpha_adjust_lo & attribute_mask) {
-      header.alpha_adjust_lo = true;
-      key_words[key_size++] = state->alpha_adjust_lo & attribute_mask;
-   }
-   if (state->alpha_adjust_hi & attribute_mask) {
-      header.alpha_adjust_hi = true;
-      key_words[key_size++] = state->alpha_adjust_hi & attribute_mask;
-   }
-
-   header.key_size = key_size * sizeof(key_words[0]);
-   key_words[0] = header.v;
-
-   uint32_t hash = radv_hash_vs_prolog(key_words);
+   uint32_t hash = radv_hash_vs_prolog(&key);
 
    u_rwlock_rdlock(&device->vs_prologs_lock);
-   struct hash_entry *prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
+   struct hash_entry *prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, &key);
    u_rwlock_rdunlock(&device->vs_prologs_lock);
 
    if (!prolog_entry) {
       u_rwlock_wrlock(&device->vs_prologs_lock);
-      prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
+      prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, &key);
       if (prolog_entry) {
          u_rwlock_wrunlock(&device->vs_prologs_lock);
          return prolog_entry->data;
       }
 
       prolog = radv_create_vs_prolog(device, &key);
-      uint32_t *key2 = malloc(key_size * 4);
+      struct radv_vs_prolog_key *key2 = malloc(sizeof(key));
       if (!prolog || !key2) {
          radv_shader_part_unref(device, prolog);
          free(key2);
          u_rwlock_wrunlock(&device->vs_prologs_lock);
          return NULL;
       }
-      memcpy(key2, key_words, key_size * 4);
+      memcpy(key2, &key, sizeof(key));
       _mesa_hash_table_insert_pre_hashed(device->vs_prologs, hash, key2, prolog);
 
       u_rwlock_wrunlock(&device->vs_prologs_lock);
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index f3c92ed719752..d7b53d42d8b62 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -168,25 +168,15 @@ radv_device_init_vs_prologs(struct radv_device *device)
    if (device->instance->debug_flags & RADV_DEBUG_DUMP_PROLOGS)
       return VK_SUCCESS;
 
-   struct radv_vs_input_state state;
-   state.nontrivial_divisors = 0;
-   memset(state.offsets, 0, sizeof(state.offsets));
-   state.alpha_adjust_lo = 0;
-   state.alpha_adjust_hi = 0;
-   memset(state.formats, 0, sizeof(state.formats));
-
    struct radv_vs_prolog_key key;
-   key.state = &state;
-   key.misaligned_mask = 0;
+   memset(&key, 0, sizeof(key));
    key.as_ls = false;
    key.is_ngg = device->physical_device->use_ngg;
    key.next_stage = MESA_SHADER_VERTEX;
    key.wave32 = device->physical_device->ge_wave_size == 32;
 
    for (unsigned i = 1; i <= MAX_VERTEX_ATTRIBS; i++) {
-      state.attribute_mask = BITFIELD_MASK(i);
-      state.instance_rate_inputs = 0;
-
+      key.state.instance_rate_inputs = 0;
       key.num_attributes = i;
 
       device->simple_vs_prologs[i - 1] = radv_create_vs_prolog(device, &key);
@@ -196,22 +186,16 @@ radv_device_init_vs_prologs(struct radv_device *device)
 
    unsigned idx = 0;
    for (unsigned num_attributes = 1; num_attributes <= 16; num_attributes++) {
-      state.attribute_mask = BITFIELD_MASK(num_attributes);
-
-      for (unsigned i = 0; i < num_attributes; i++)
-         state.divisors[i] = 1;
-
       for (unsigned count = 1; count <= num_attributes; count++) {
          for (unsigned start = 0; start <= (num_attributes - count); start++) {
-            state.instance_rate_inputs = u_bit_consecutive(start, count);
-
+            key.state.instance_rate_inputs = u_bit_consecutive(start, count);
             key.num_attributes = num_attributes;
 
             struct radv_shader_part *prolog = radv_create_vs_prolog(device, &key);
             if (!prolog)
                return vk_error(device->physical_device->instance, VK_ERROR_OUT_OF_DEVICE_MEMORY);
 
-            assert(idx == radv_instance_rate_prolog_index(num_attributes, state.instance_rate_inputs));
+            assert(idx == radv_instance_rate_prolog_index(num_attributes, key.state.instance_rate_inputs));
             device->instance_rate_vs_prologs[idx++] = prolog;
          }
       }
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 3a0d4bf316a4b..fec40cf706544 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2581,7 +2581,7 @@ radv_create_vs_prolog(struct radv_device *device, const struct radv_vs_prolog_ke
    if (!prolog)
       goto fail;
 
-   prolog->nontrivial_divisors = key->state->nontrivial_divisors;
+   prolog->nontrivial_divisors = key->state.nontrivial_divisors;
 
    if (options.dump_shader) {
       fprintf(stderr, "Vertex prolog");
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index f902d3e1e9456..9a89067087ea0 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -481,7 +481,21 @@ struct radv_vs_input_state {
 };
 
 struct radv_vs_prolog_key {
-   const struct radv_vs_input_state *state;
+   /* All the fields are pre-masked with BITFIELD_MASK(num_attributes).
+    * Some of the fields are pre-masked by other conditions. See lookup_vs_prolog.
+    */
+   struct {
+      uint32_t instance_rate_inputs;
+      uint32_t nontrivial_divisors;
+      uint32_t zero_divisors;
+      uint32_t post_shuffle;
+      /* Having two separate fields instead of a single uint64_t makes it easier to remove attributes
+       * using bitwise arithmetic.
+       */
+      uint32_t alpha_adjust_lo;
+      uint32_t alpha_adjust_hi;
+      uint8_t formats[MAX_VERTEX_ATTRIBS];
+   } state;
    unsigned num_attributes;
    uint32_t misaligned_mask;
    bool as_ls;
-- 
GitLab


From 8d9211376f995eb6cee74f8dab122556f752584b Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Tue, 7 Nov 2023 11:12:34 +0900
Subject: [PATCH 4/4] radv, aco: Inline struct aco_vs_input_state.

Now that we no longer use the radv_vs_input_state pointer, we can simply
inline all the state-related fields.
---
 .../compiler/aco_instruction_selection.cpp    | 31 +++++++++----------
 src/amd/compiler/aco_shader_info.h            |  8 ++---
 src/amd/vulkan/radv_aco_shader_info.h         | 16 +++++-----
 src/amd/vulkan/radv_cmd_buffer.c              | 14 ++++-----
 src/amd/vulkan/radv_device.c                  |  6 ++--
 src/amd/vulkan/radv_shader.c                  |  2 +-
 src/amd/vulkan/radv_shader.h                  | 22 ++++++-------
 7 files changed, 46 insertions(+), 53 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 336fd9260f5ef..79625b6cf1fb7 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12739,7 +12739,7 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
    bld.sopp(aco_opcode::s_setprio, -1u, 0x3u);
 
    uint32_t attrib_mask = BITFIELD_MASK(pinfo->num_attributes);
-   bool has_nontrivial_divisors = pinfo->state.nontrivial_divisors;
+   bool has_nontrivial_divisors = pinfo->nontrivial_divisors;
 
    wait_imm lgkm_imm;
    lgkm_imm.lgkm = 0;
@@ -12800,10 +12800,10 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
          }
 
          bool needs_instance_index =
-            pinfo->state.instance_rate_inputs &
-            ~(pinfo->state.zero_divisors | pinfo->state.nontrivial_divisors); /* divisor is 1 */
-         bool needs_start_instance = pinfo->state.instance_rate_inputs & pinfo->state.zero_divisors;
-         bool needs_vertex_index = ~pinfo->state.instance_rate_inputs & attrib_mask;
+            pinfo->instance_rate_inputs &
+            ~(pinfo->zero_divisors | pinfo->nontrivial_divisors); /* divisor is 1 */
+         bool needs_start_instance = pinfo->instance_rate_inputs & pinfo->zero_divisors;
+         bool needs_vertex_index = ~pinfo->instance_rate_inputs & attrib_mask;
          if (needs_vertex_index)
             bld.vadd32(Definition(vertex_index, v1), get_arg_fixed(args, args->base_vertex),
                        get_arg_fixed(args, args->vertex_id), false, Operand(s2), true);
@@ -12821,12 +12821,11 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
 
          /* calculate index */
          Operand fetch_index = Operand(vertex_index, v1);
-         if (pinfo->state.instance_rate_inputs & (1u << loc)) {
-            if (!(pinfo->state.zero_divisors & (1u << loc))) {
+         if (pinfo->instance_rate_inputs & (1u << loc)) {
+            if (!(pinfo->zero_divisors & (1u << loc))) {
                fetch_index = instance_id;
-               if (pinfo->state.nontrivial_divisors & (1u << loc)) {
-                  unsigned index =
-                     util_bitcount(pinfo->state.nontrivial_divisors & BITFIELD_MASK(loc));
+               if (pinfo->nontrivial_divisors & (1u << loc)) {
+                  unsigned index = util_bitcount(pinfo->nontrivial_divisors & BITFIELD_MASK(loc));
                   fetch_index = calc_nontrivial_instance_id(
                      bld, args, pinfo, index, instance_id, start_instance, prolog_input,
                      nontrivial_tmp_vgpr0, nontrivial_tmp_vgpr1);
@@ -12841,14 +12840,14 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
          /* perform load */
          PhysReg cur_desc = desc.advance(i * 16);
          if ((pinfo->misaligned_mask & (1u << loc))) {
-            const struct ac_vtx_format_info* vtx_info = &vtx_info_table[pinfo->state.formats[loc]];
+            const struct ac_vtx_format_info* vtx_info = &vtx_info_table[pinfo->formats[loc]];
 
             assert(vtx_info->has_hw_format & 0x1);
             unsigned dfmt = vtx_info->hw_format[0] & 0xf;
             unsigned nfmt = vtx_info->hw_format[0] >> 4;
 
             for (unsigned j = 0; j < vtx_info->num_channels; j++) {
-               bool post_shuffle = pinfo->state.post_shuffle & (1u << loc);
+               bool post_shuffle = pinfo->post_shuffle & (1u << loc);
                unsigned offset = vtx_info->chan_byte_size * (post_shuffle && j < 3 ? 2 - j : j);
 
                /* Use MUBUF to workaround hangs for byte-aligned dword loads. The Vulkan spec
@@ -12894,7 +12893,7 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
       }
    }
 
-   if (pinfo->state.alpha_adjust_lo | pinfo->state.alpha_adjust_hi) {
+   if (pinfo->alpha_adjust_lo | pinfo->alpha_adjust_hi) {
       wait_imm vm_imm;
       vm_imm.vm = 0;
       bld.sopp(aco_opcode::s_waitcnt, -1, vm_imm.pack(program->gfx_level));
@@ -12902,11 +12901,11 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
 
    /* For 2_10_10_10 formats the alpha is handled as unsigned by pre-vega HW.
     * so we may need to fix it up. */
-   u_foreach_bit (loc, (pinfo->state.alpha_adjust_lo | pinfo->state.alpha_adjust_hi)) {
+   u_foreach_bit (loc, (pinfo->alpha_adjust_lo | pinfo->alpha_adjust_hi)) {
       PhysReg alpha(attributes_start.reg() + loc * 4u + 3);
 
-      unsigned alpha_adjust = (pinfo->state.alpha_adjust_lo >> loc) & 0x1;
-      alpha_adjust |= ((pinfo->state.alpha_adjust_hi >> loc) & 0x1) << 1;
+      unsigned alpha_adjust = (pinfo->alpha_adjust_lo >> loc) & 0x1;
+      alpha_adjust |= ((pinfo->alpha_adjust_hi >> loc) & 0x1) << 1;
 
       if (alpha_adjust == AC_ALPHA_ADJUST_SSCALED)
          bld.vop1(aco_opcode::v_cvt_u32_f32, Definition(alpha, v1), Operand(alpha, v1));
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 5fdb96fa83349..493d6bf33362a 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -41,7 +41,9 @@ extern "C" {
 #define ACO_MAX_VERTEX_ATTRIBS 32
 #define ACO_MAX_VBS            32
 
-struct aco_vs_input_state {
+struct aco_vs_prolog_info {
+   struct ac_arg inputs;
+
    uint32_t instance_rate_inputs;
    uint32_t nontrivial_divisors;
    uint32_t zero_divisors;
@@ -53,11 +55,7 @@ struct aco_vs_input_state {
    uint32_t alpha_adjust_hi;
 
    uint8_t formats[ACO_MAX_VERTEX_ATTRIBS];
-};
 
-struct aco_vs_prolog_info {
-   struct ac_arg inputs;
-   struct aco_vs_input_state state;
    unsigned num_attributes;
    uint32_t misaligned_mask;
    bool is_ngg;
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index e75ba5826aa17..8df3f31b3bdc5 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -72,19 +72,17 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info, const struct radv
    aco_info->next_stage_pc = radv_args->next_stage_pc;
 }
 
-#define ASSIGN_VS_STATE_FIELD(x)    aco_info->state.x = radv->state.x
-#define ASSIGN_VS_STATE_FIELD_CP(x) memcpy(&aco_info->state.x, &radv->state.x, sizeof(radv->state.x))
 static inline void
 radv_aco_convert_vs_prolog_key(struct aco_vs_prolog_info *aco_info, const struct radv_vs_prolog_key *radv,
                                const struct radv_shader_args *radv_args)
 {
-   ASSIGN_VS_STATE_FIELD(instance_rate_inputs);
-   ASSIGN_VS_STATE_FIELD(nontrivial_divisors);
-   ASSIGN_VS_STATE_FIELD(zero_divisors);
-   ASSIGN_VS_STATE_FIELD(post_shuffle);
-   ASSIGN_VS_STATE_FIELD(alpha_adjust_lo);
-   ASSIGN_VS_STATE_FIELD(alpha_adjust_hi);
-   ASSIGN_VS_STATE_FIELD_CP(formats);
+   ASSIGN_FIELD(instance_rate_inputs);
+   ASSIGN_FIELD(nontrivial_divisors);
+   ASSIGN_FIELD(zero_divisors);
+   ASSIGN_FIELD(post_shuffle);
+   ASSIGN_FIELD(alpha_adjust_lo);
+   ASSIGN_FIELD(alpha_adjust_hi);
+   ASSIGN_FIELD_CP(formats);
    ASSIGN_FIELD(num_attributes);
    ASSIGN_FIELD(misaligned_mask);
    ASSIGN_FIELD(is_ngg);
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 8b66116e8d917..f77c754a24bd9 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3774,15 +3774,15 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
 
    struct radv_vs_prolog_key key;
    memset(&key, 0, sizeof(key));
-   key.state.instance_rate_inputs = instance_rate_inputs;
-   key.state.nontrivial_divisors = *nontrivial_divisors;
-   key.state.zero_divisors = zero_divisors;
+   key.instance_rate_inputs = instance_rate_inputs;
+   key.nontrivial_divisors = *nontrivial_divisors;
+   key.zero_divisors = zero_divisors;
    /* If the attribute is aligned, post shuffle is implemented using DST_SEL instead. */
-   key.state.post_shuffle = state->post_shuffle & attribute_mask & misaligned_mask;
-   key.state.alpha_adjust_hi = state->alpha_adjust_hi & attribute_mask;
-   key.state.alpha_adjust_lo = state->alpha_adjust_lo & attribute_mask;
+   key.post_shuffle = state->post_shuffle & attribute_mask & misaligned_mask;
+   key.alpha_adjust_hi = state->alpha_adjust_hi & attribute_mask;
+   key.alpha_adjust_lo = state->alpha_adjust_lo & attribute_mask;
    u_foreach_bit (index, misaligned_mask)
-      key.state.formats[index] = state->formats[index];
+      key.formats[index] = state->formats[index];
    key.num_attributes = num_attributes;
    key.misaligned_mask = misaligned_mask;
    /* The instance ID input VGPR is placed differently when as_ls=true. */
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index d7b53d42d8b62..e251f90f58a31 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -176,7 +176,7 @@ radv_device_init_vs_prologs(struct radv_device *device)
    key.wave32 = device->physical_device->ge_wave_size == 32;
 
    for (unsigned i = 1; i <= MAX_VERTEX_ATTRIBS; i++) {
-      key.state.instance_rate_inputs = 0;
+      key.instance_rate_inputs = 0;
       key.num_attributes = i;
 
       device->simple_vs_prologs[i - 1] = radv_create_vs_prolog(device, &key);
@@ -188,14 +188,14 @@ radv_device_init_vs_prologs(struct radv_device *device)
    for (unsigned num_attributes = 1; num_attributes <= 16; num_attributes++) {
       for (unsigned count = 1; count <= num_attributes; count++) {
          for (unsigned start = 0; start <= (num_attributes - count); start++) {
-            key.state.instance_rate_inputs = u_bit_consecutive(start, count);
+            key.instance_rate_inputs = u_bit_consecutive(start, count);
             key.num_attributes = num_attributes;
 
             struct radv_shader_part *prolog = radv_create_vs_prolog(device, &key);
             if (!prolog)
                return vk_error(device->physical_device->instance, VK_ERROR_OUT_OF_DEVICE_MEMORY);
 
-            assert(idx == radv_instance_rate_prolog_index(num_attributes, key.state.instance_rate_inputs));
+            assert(idx == radv_instance_rate_prolog_index(num_attributes, key.instance_rate_inputs));
             device->instance_rate_vs_prologs[idx++] = prolog;
          }
       }
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index fec40cf706544..a73a7b2f73e40 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2581,7 +2581,7 @@ radv_create_vs_prolog(struct radv_device *device, const struct radv_vs_prolog_ke
    if (!prolog)
       goto fail;
 
-   prolog->nontrivial_divisors = key->state.nontrivial_divisors;
+   prolog->nontrivial_divisors = key->nontrivial_divisors;
 
    if (options.dump_shader) {
       fprintf(stderr, "Vertex prolog");
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 9a89067087ea0..87a8521aaef4a 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -484,18 +484,16 @@ struct radv_vs_prolog_key {
    /* All the fields are pre-masked with BITFIELD_MASK(num_attributes).
     * Some of the fields are pre-masked by other conditions. See lookup_vs_prolog.
     */
-   struct {
-      uint32_t instance_rate_inputs;
-      uint32_t nontrivial_divisors;
-      uint32_t zero_divisors;
-      uint32_t post_shuffle;
-      /* Having two separate fields instead of a single uint64_t makes it easier to remove attributes
-       * using bitwise arithmetic.
-       */
-      uint32_t alpha_adjust_lo;
-      uint32_t alpha_adjust_hi;
-      uint8_t formats[MAX_VERTEX_ATTRIBS];
-   } state;
+   uint32_t instance_rate_inputs;
+   uint32_t nontrivial_divisors;
+   uint32_t zero_divisors;
+   uint32_t post_shuffle;
+   /* Having two separate fields instead of a single uint64_t makes it easier to remove attributes
+    * using bitwise arithmetic.
+    */
+   uint32_t alpha_adjust_lo;
+   uint32_t alpha_adjust_hi;
+   uint8_t formats[MAX_VERTEX_ATTRIBS];
    unsigned num_attributes;
    uint32_t misaligned_mask;
    bool as_ls;
-- 
GitLab

