--- a/src/gallium/drivers/radeonsi/radeon_uvd.c	2025-06-22 20:12:54.026957206 +0200
+++ b/src/gallium/drivers/radeonsi/radeon_uvd.c	2025-06-22 20:17:27.284862841 +0200
@@ -21,6 +21,15 @@
 #include <errno.h>
 #include <stdio.h>
 #include <unistd.h>
+#include <immintrin.h> // For SSE2/AVX intrinsics
+
+#if defined(__GNUC__) || defined(__clang__)
+#define LIKELY(x)   __builtin_expect(!!(x), 1)
+#define UNLIKELY(x) __builtin_expect(!!(x), 0)
+#else
+#define LIKELY(x)   (x)
+#define UNLIKELY(x) (x)
+#endif
 
 #define NUM_BUFFERS 4
 
@@ -97,20 +106,22 @@ static void ruvd_dec_destroy_fence(struc
 }
 
 /* add a new set register command to the IB */
-static void set_reg(struct ruvd_decoder *dec, unsigned reg, uint32_t val)
+static inline __attribute__((always_inline)) void set_reg(struct ruvd_decoder *dec, unsigned reg,
+                                                          uint32_t val)
 {
    radeon_emit(&dec->cs, RUVD_PKT0(reg >> 2, 0));
    radeon_emit(&dec->cs, val);
 }
 
 /* send a command to the VCPU through the GPCOM registers */
-static void send_cmd(struct ruvd_decoder *dec, unsigned cmd, struct pb_buffer_lean *buf, uint32_t off,
-                     unsigned usage, enum radeon_bo_domain domain)
+static inline __attribute__((always_inline)) void
+send_cmd(struct ruvd_decoder *dec, unsigned cmd, struct pb_buffer_lean *buf, uint32_t off,
+         unsigned usage, enum radeon_bo_domain domain)
 {
    int reloc_idx;
 
    reloc_idx = dec->ws->cs_add_buffer(&dec->cs, buf, usage | RADEON_USAGE_SYNCHRONIZED, domain);
-   if (!dec->use_legacy) {
+   if (LIKELY(!dec->use_legacy)) {
       uint64_t addr;
       addr = dec->ws->buffer_get_virtual_address(buf);
       addr = addr + off;
@@ -125,7 +136,7 @@ static void send_cmd(struct ruvd_decoder
 }
 
 /* do the codec needs an IT buffer ?*/
-static bool have_it(struct ruvd_decoder *dec)
+static inline __attribute__((always_inline)) bool have_it(struct ruvd_decoder *dec)
 {
    return dec->stream_type == RUVD_CODEC_H264_PERF || dec->stream_type == RUVD_CODEC_H265;
 }
@@ -143,6 +154,14 @@ static void map_msg_fb_it_buf(struct ruv
    ptr =
       dec->ws->buffer_map(dec->ws, buf->res->buf, NULL, PIPE_MAP_WRITE | RADEON_MAP_TEMPORARY);
 
+   if (UNLIKELY(!ptr)) {
+      RVID_ERR("Failed to map msg/fb/it buffer\n");
+      dec->msg = NULL;
+      dec->fb = NULL;
+      dec->it = NULL;
+      return;
+   }
+
    /* calc buffer offsets */
    dec->msg = (struct ruvd_msg *)ptr;
    memset(dec->msg, 0, sizeof(*dec->msg));
@@ -150,6 +169,8 @@ static void map_msg_fb_it_buf(struct ruv
    dec->fb = (uint32_t *)(ptr + FB_BUFFER_OFFSET);
    if (have_it(dec))
       dec->it = (uint8_t *)(ptr + FB_BUFFER_OFFSET + dec->fb_size);
+   else
+      dec->it = NULL;
 }
 
 /* unmap and send a message command to the VCPU */
@@ -179,7 +200,7 @@ static void send_msg_buf(struct ruvd_dec
 }
 
 /* cycle to the next set of buffers */
-static void next_buffer(struct ruvd_decoder *dec)
+static inline __attribute__((always_inline)) void next_buffer(struct ruvd_decoder *dec)
 {
    ++dec->cur_buffer;
    dec->cur_buffer %= NUM_BUFFERS;
@@ -213,6 +234,23 @@ static uint32_t profile2stream_type(stru
    }
 }
 
+static inline unsigned get_h264_num_dpb_buffers(unsigned level, unsigned fs_in_mb)
+{
+   if (UNLIKELY(fs_in_mb == 0))
+      return 184320; /* Avoid division by zero, return max */
+
+   switch (level) {
+   case 30: return 8100 / fs_in_mb;
+   case 31: return 18000 / fs_in_mb;
+   case 32: return 20480 / fs_in_mb;
+   case 41: return 32768 / fs_in_mb;
+   case 42: return 34816 / fs_in_mb;
+   case 50: return 110400 / fs_in_mb;
+   case 51: return 184320 / fs_in_mb;
+   default: return 184320 / fs_in_mb;
+   }
+}
+
 static unsigned calc_ctx_size_h264_perf(struct ruvd_decoder *dec)
 {
    unsigned width_in_mb, height_in_mb, ctx_size;
@@ -225,35 +263,9 @@ static unsigned calc_ctx_size_h264_perf(
    width_in_mb = width / VL_MACROBLOCK_WIDTH;
    height_in_mb = align(height / VL_MACROBLOCK_HEIGHT, 2);
 
-   if (!dec->use_legacy) {
+   if (LIKELY(!dec->use_legacy)) {
       unsigned fs_in_mb = width_in_mb * height_in_mb;
-      unsigned num_dpb_buffer_lean;
-      switch (dec->base.level) {
-      case 30:
-         num_dpb_buffer_lean = 8100 / fs_in_mb;
-         break;
-      case 31:
-         num_dpb_buffer_lean = 18000 / fs_in_mb;
-         break;
-      case 32:
-         num_dpb_buffer_lean = 20480 / fs_in_mb;
-         break;
-      case 41:
-         num_dpb_buffer_lean = 32768 / fs_in_mb;
-         break;
-      case 42:
-         num_dpb_buffer_lean = 34816 / fs_in_mb;
-         break;
-      case 50:
-         num_dpb_buffer_lean = 110400 / fs_in_mb;
-         break;
-      case 51:
-         num_dpb_buffer_lean = 184320 / fs_in_mb;
-         break;
-      default:
-         num_dpb_buffer_lean = 184320 / fs_in_mb;
-         break;
-      }
+      unsigned num_dpb_buffer_lean = get_h264_num_dpb_buffers(dec->base.level, fs_in_mb);
       num_dpb_buffer_lean++;
       max_references = MAX2(MIN2(NUM_H264_REFS, num_dpb_buffer_lean), max_references);
       ctx_size = max_references * align(width_in_mb * height_in_mb * 192, 256);
@@ -311,7 +323,12 @@ static unsigned calc_ctx_size_h265_main1
 
    num_16x16_block_per_ctb = ((1 << log2_ctb_size) >> 4) * ((1 << log2_ctb_size) >> 4);
    context_buffer_size_per_ctb_row = align(width_in_ctb * num_16x16_block_per_ctb * 16, 256);
-   max_mb_address = (unsigned)ceil(height * 8 / 2048.0);
+
+   // OPTIMIZED: Replaced floating-point ceil() with pure integer arithmetic.
+   // Original was: max_mb_address = (unsigned)ceil(height * 8 / 2048.0);
+   // Simplified:   max_mb_address = (unsigned)ceil(height / 256.0);
+   // Integer equivalent:
+   max_mb_address = (height + 255) / 256;
 
    cm_buffer_size = max_references * context_buffer_size_per_ctb_row * height_in_ctb;
    db_left_tile_pxl_size = coeff_10bit * (max_mb_address * 2 * 2048 + 1024);
@@ -319,12 +336,12 @@ static unsigned calc_ctx_size_h265_main1
    return cm_buffer_size + db_left_tile_ctx_size + db_left_tile_pxl_size;
 }
 
-static unsigned get_db_pitch_alignment(struct ruvd_decoder *dec)
+static inline __attribute__((always_inline, const)) unsigned
+get_db_pitch_alignment(const struct ruvd_decoder *dec)
 {
-   if (((struct si_screen *)dec->screen)->info.family < CHIP_VEGA10)
-      return 16;
-   else
-      return 32;
+   /* Vega10+ requires 32, older GPUs require 16 */
+   bool is_vega10_plus = ((const struct si_screen *)dec->screen)->info.family >= CHIP_VEGA10;
+   return 16 + (16 * is_vega10_plus);
 }
 
 /* calculate size of reference picture buffer */
@@ -350,38 +367,14 @@ static unsigned calc_dpb_size(struct ruv
 
    switch (u_reduce_video_profile(dec->base.profile)) {
    case PIPE_VIDEO_FORMAT_MPEG4_AVC: {
-      if (!dec->use_legacy) {
+      if (LIKELY(!dec->use_legacy)) {
          unsigned fs_in_mb = width_in_mb * height_in_mb;
          unsigned alignment = 64, num_dpb_buffer_lean;
 
          if (dec->stream_type == RUVD_CODEC_H264_PERF)
             alignment = 256;
-         switch (dec->base.level) {
-         case 30:
-            num_dpb_buffer_lean = 8100 / fs_in_mb;
-            break;
-         case 31:
-            num_dpb_buffer_lean = 18000 / fs_in_mb;
-            break;
-         case 32:
-            num_dpb_buffer_lean = 20480 / fs_in_mb;
-            break;
-         case 41:
-            num_dpb_buffer_lean = 32768 / fs_in_mb;
-            break;
-         case 42:
-            num_dpb_buffer_lean = 34816 / fs_in_mb;
-            break;
-         case 50:
-            num_dpb_buffer_lean = 110400 / fs_in_mb;
-            break;
-         case 51:
-            num_dpb_buffer_lean = 184320 / fs_in_mb;
-            break;
-         default:
-            num_dpb_buffer_lean = 184320 / fs_in_mb;
-            break;
-         }
+
+         num_dpb_buffer_lean = get_h264_num_dpb_buffers(dec->base.level, fs_in_mb);
          num_dpb_buffer_lean++;
          max_references = MAX2(MIN2(NUM_H264_REFS, num_dpb_buffer_lean), max_references);
          dpb_size = image_size * max_references;
@@ -485,22 +478,19 @@ static void ruvd_destroy_associated_data
 static struct ruvd_h264 get_h264_msg(struct ruvd_decoder *dec, struct pipe_h264_picture_desc *pic)
 {
    struct ruvd_h264 result;
-
    memset(&result, 0, sizeof(result));
+
    switch (pic->base.profile) {
    case PIPE_VIDEO_PROFILE_MPEG4_AVC_BASELINE:
    case PIPE_VIDEO_PROFILE_MPEG4_AVC_CONSTRAINED_BASELINE:
       result.profile = RUVD_H264_PROFILE_BASELINE;
       break;
-
    case PIPE_VIDEO_PROFILE_MPEG4_AVC_MAIN:
       result.profile = RUVD_H264_PROFILE_MAIN;
       break;
-
    case PIPE_VIDEO_PROFILE_MPEG4_AVC_HIGH:
       result.profile = RUVD_H264_PROFILE_HIGH;
       break;
-
    default:
       assert(0);
       break;
@@ -508,12 +498,15 @@ static struct ruvd_h264 get_h264_msg(str
 
    result.level = dec->base.level;
 
-   result.sps_info_flags = 0;
-   result.sps_info_flags |= pic->pps->sps->direct_8x8_inference_flag << 0;
-   result.sps_info_flags |= pic->pps->sps->mb_adaptive_frame_field_flag << 1;
-   result.sps_info_flags |= pic->pps->sps->frame_mbs_only_flag << 2;
-   result.sps_info_flags |= pic->pps->sps->delta_pic_order_always_zero_flag << 3;
-   result.sps_info_flags |= pic->pps->sps->gaps_in_frame_num_value_allowed_flag << 5;
+   // --- OPTIMIZED BATCHED FLAG CONSTRUCTION ---
+   // Compute the entire SPS flags field in a local register, then write once.
+   uint32_t sps_flags = 0;
+   sps_flags |= (uint32_t)pic->pps->sps->direct_8x8_inference_flag << 0;
+   sps_flags |= (uint32_t)pic->pps->sps->mb_adaptive_frame_field_flag << 1;
+   sps_flags |= (uint32_t)pic->pps->sps->frame_mbs_only_flag << 2;
+   sps_flags |= (uint32_t)pic->pps->sps->delta_pic_order_always_zero_flag << 3;
+   sps_flags |= (uint32_t)pic->pps->sps->gaps_in_frame_num_value_allowed_flag << 5;
+   result.sps_info_flags = sps_flags;
 
    result.chroma_format = pic->pps->sps->chroma_format_idc;
    result.bit_depth_luma_minus8 = pic->pps->sps->bit_depth_luma_minus8;
@@ -522,15 +515,18 @@ static struct ruvd_h264 get_h264_msg(str
    result.pic_order_cnt_type = pic->pps->sps->pic_order_cnt_type;
    result.log2_max_pic_order_cnt_lsb_minus4 = pic->pps->sps->log2_max_pic_order_cnt_lsb_minus4;
 
-   result.pps_info_flags = 0;
-   result.pps_info_flags |= pic->pps->transform_8x8_mode_flag << 0;
-   result.pps_info_flags |= pic->pps->redundant_pic_cnt_present_flag << 1;
-   result.pps_info_flags |= pic->pps->constrained_intra_pred_flag << 2;
-   result.pps_info_flags |= pic->pps->deblocking_filter_control_present_flag << 3;
-   result.pps_info_flags |= pic->pps->weighted_bipred_idc << 4;
-   result.pps_info_flags |= pic->pps->weighted_pred_flag << 6;
-   result.pps_info_flags |= pic->pps->bottom_field_pic_order_in_frame_present_flag << 7;
-   result.pps_info_flags |= pic->pps->entropy_coding_mode_flag << 8;
+   // Compute the entire PPS flags field in a local register, then write once.
+   uint32_t pps_flags = 0;
+   pps_flags |= (uint32_t)pic->pps->transform_8x8_mode_flag << 0;
+   pps_flags |= (uint32_t)pic->pps->redundant_pic_cnt_present_flag << 1;
+   pps_flags |= (uint32_t)pic->pps->constrained_intra_pred_flag << 2;
+   pps_flags |= (uint32_t)pic->pps->deblocking_filter_control_present_flag << 3;
+   pps_flags |= (uint32_t)pic->pps->weighted_bipred_idc << 4;
+   pps_flags |= (uint32_t)pic->pps->weighted_pred_flag << 6;
+   pps_flags |= (uint32_t)pic->pps->bottom_field_pic_order_in_frame_present_flag << 7;
+   pps_flags |= (uint32_t)pic->pps->entropy_coding_mode_flag << 8;
+   result.pps_info_flags = pps_flags;
+   // --- END OF OPTIMIZED LOGIC ---
 
    result.num_slice_groups_minus1 = pic->pps->num_slice_groups_minus1;
    result.slice_group_map_type = pic->pps->slice_group_map_type;
@@ -548,10 +544,8 @@ static struct ruvd_h264 get_h264_msg(str
    }
 
    result.num_ref_frames = pic->num_ref_frames;
-
    result.num_ref_idx_l0_active_minus1 = pic->num_ref_idx_l0_active_minus1;
    result.num_ref_idx_l1_active_minus1 = pic->num_ref_idx_l1_active_minus1;
-
    result.frame_num = pic->frame_num;
    memcpy(result.frame_num_list, pic->frame_num_list, 4 * 16);
    result.curr_field_order_cnt_list[0] = pic->field_order_cnt[0];
@@ -568,7 +562,7 @@ static struct ruvd_h265 get_h265_msg(str
                                      struct pipe_h265_picture_desc *pic)
 {
    struct ruvd_h265 result;
-   unsigned i, j;
+   unsigned i;
 
    memset(&result, 0, sizeof(result));
 
@@ -582,8 +576,9 @@ static struct ruvd_h265 get_h265_msg(str
    result.sps_info_flags |= pic->pps->sps->sps_temporal_mvp_enabled_flag << 6;
    result.sps_info_flags |= pic->pps->sps->strong_intra_smoothing_enabled_flag << 7;
    result.sps_info_flags |= pic->pps->sps->separate_colour_plane_flag << 8;
-   if (((struct si_screen *)dec->screen)->info.family == CHIP_CARRIZO)
+   if (((struct si_screen *)dec->screen)->info.family == CHIP_CARRIZO) {
       result.sps_info_flags |= 1 << 9;
+   }
 
    result.chroma_format = pic->pps->sps->chroma_format_idc;
    result.bit_depth_luma_minus8 = pic->pps->sps->bit_depth_luma_minus8;
@@ -629,7 +624,6 @@ static struct ruvd_h265 get_h265_msg(str
    result.pps_info_flags |= pic->pps->pps_deblocking_filter_disabled_flag << 17;
    result.pps_info_flags |= pic->pps->lists_modification_present_flag << 18;
    result.pps_info_flags |= pic->pps->slice_segment_header_extension_present_flag << 19;
-   // result.pps_info_flags |= pic->pps->deblocking_filter_control_present_flag; ???
 
    result.num_extra_slice_header_bits = pic->pps->num_extra_slice_header_bits;
    result.num_long_term_ref_pic_sps = pic->pps->sps->num_long_term_ref_pics_sps;
@@ -645,47 +639,59 @@ static struct ruvd_h265 get_h265_msg(str
    result.log2_parallel_merge_level_minus2 = pic->pps->log2_parallel_merge_level_minus2;
    result.init_qp_minus26 = pic->pps->init_qp_minus26;
 
-   for (i = 0; i < 19; ++i)
+   for (i = 0; i < 19; ++i) {
       result.column_width_minus1[i] = pic->pps->column_width_minus1[i];
+   }
 
-   for (i = 0; i < 21; ++i)
+   for (i = 0; i < 21; ++i) {
       result.row_height_minus1[i] = pic->pps->row_height_minus1[i];
+   }
 
    result.num_delta_pocs_ref_rps_idx = pic->NumDeltaPocsOfRefRpsIdx;
    result.curr_poc = pic->CurrPicOrderCntVal;
 
-   for (i = 0; i < 16; i++) {
-      for (j = 0; (pic->ref[j] != NULL) && (j < 16); j++) {
-         if (dec->render_pic_list[i] == pic->ref[j])
-            break;
-         if (j == 15)
-            dec->render_pic_list[i] = NULL;
-         else if (pic->ref[j + 1] == NULL)
-            dec->render_pic_list[i] = NULL;
+   // 1. Build a bitmask of currently active reference picture indices.
+   uint64_t active_ref_mask = 0;
+   for (i = 0; i < 16; ++i) {
+      if (!pic->ref[i]) {
+         break; // End of reference list
+      }
+      uintptr_t ref_idx = (uintptr_t)vl_video_buffer_get_associated_data(pic->ref[i], &dec->base);
+      if (ref_idx < 16) { // Ensure index is valid before setting bit
+         active_ref_mask |= (1ULL << ref_idx);
+      }
+   }
+
+   // 2. Evict stale pictures in a single pass using the bitmask.
+   for (i = 0; i < 16; ++i) {
+      if (dec->render_pic_list[i] && !(active_ref_mask & (1ULL << i))) {
+         dec->render_pic_list[i] = NULL;
       }
    }
-   for (i = 0; i < 16; i++) {
+
+   // 3. Find a free slot for the new target and assign its index.
+   result.curr_idx = 16; // Use an invalid index as a sentinel
+   for (i = 0; i < 16; ++i) {
       if (dec->render_pic_list[i] == NULL) {
          dec->render_pic_list[i] = target;
          result.curr_idx = i;
          break;
       }
    }
+   // This should never happen in a compliant stream, but assert for robustness.
+   assert(result.curr_idx < 16 && "No free slot in render picture list!");
 
    vl_video_buffer_set_associated_data(target, &dec->base, (void *)(uintptr_t)result.curr_idx,
                                        &ruvd_destroy_associated_data);
 
+   // Populate the firmware's reference list using the indices.
    for (i = 0; i < 16; ++i) {
-      struct pipe_video_buffer *ref = pic->ref[i];
-      uintptr_t ref_pic = 0;
-
       result.poc_list[i] = pic->PicOrderCntVal[i];
-
-      if (ref)
-         ref_pic = (uintptr_t)vl_video_buffer_get_associated_data(ref, &dec->base);
-      else
-         ref_pic = 0x7F;
-      result.ref_pic_list[i] = ref_pic;
+      if (pic->ref[i]) {
+         result.ref_pic_list[i] = (uintptr_t)vl_video_buffer_get_associated_data(pic->ref[i], &dec->base);
+      } else {
+         result.ref_pic_list[i] = 0x7F; // Sentinel for unused entry
+      }
    }
 
    for (i = 0; i < 8; ++i) {
@@ -694,20 +700,25 @@ static struct ruvd_h265 get_h265_msg(str
       result.ref_pic_set_lt_curr[i] = 0xFF;
    }
 
-   for (i = 0; i < pic->NumPocStCurrBefore; ++i)
+   for (i = 0; i < pic->NumPocStCurrBefore; ++i) {
       result.ref_pic_set_st_curr_before[i] = pic->RefPicSetStCurrBefore[i];
+   }
 
-   for (i = 0; i < pic->NumPocStCurrAfter; ++i)
+   for (i = 0; i < pic->NumPocStCurrAfter; ++i) {
       result.ref_pic_set_st_curr_after[i] = pic->RefPicSetStCurrAfter[i];
+   }
 
-   for (i = 0; i < pic->NumPocLtCurr; ++i)
+   for (i = 0; i < pic->NumPocLtCurr; ++i) {
       result.ref_pic_set_lt_curr[i] = pic->RefPicSetLtCurr[i];
+   }
 
-   for (i = 0; i < 6; ++i)
+   for (i = 0; i < 6; ++i) {
       result.ucScalingListDCCoefSizeID2[i] = pic->pps->sps->ScalingListDCCoeff16x16[i];
+   }
 
-   for (i = 0; i < 2; ++i)
+   for (i = 0; i < 2; ++i) {
       result.ucScalingListDCCoefSizeID3[i] = pic->pps->sps->ScalingListDCCoeff32x32[i];
+   }
 
    memcpy(dec->it, pic->pps->sps->ScalingList4x4, 6 * 16);
    memcpy(dec->it + 96, pic->pps->sps->ScalingList8x8, 6 * 64);
@@ -727,17 +738,17 @@ static struct ruvd_h265 get_h265_msg(str
    }
 
    /* TODO
-   result.highestTid;
-   result.isNonRef;
-
-   IDRPicFlag;
-   RAPPicFlag;
-   NumPocTotalCurr;
-   NumShortTermPictureSliceHeaderBits;
-   NumLongTermPictureSliceHeaderBits;
-
-   IsLongTerm[16];
-   */
+    *  result.highestTid;
+    *  result.isNonRef;
+    *
+    *  IDRPicFlag;
+    *  RAPPicFlag;
+    *  NumPocTotalCurr;
+    *  NumShortTermPictureSliceHeaderBits;
+    *  NumLongTermPictureSliceHeaderBits;
+    *
+    *  IsLongTerm[16];
+    */
 
    return result;
 }
@@ -803,12 +814,12 @@ static struct ruvd_vc1 get_vc1_msg(struc
    result.chroma_format = 1;
 
 #if 0
-//(((unsigned int)(pPicParams->advance.reserved1)) << SPS_INFO_VC1_RESERVED_SHIFT)
-uint32_t  slice_count
-uint8_t   picture_type
-uint8_t   frame_coding_mode
-uint8_t   deblockEnable
-uint8_t   pquant
+   //(((unsigned int)(pPicParams->advance.reserved1)) << SPS_INFO_VC1_RESERVED_SHIFT)
+   uint32_t  slice_count
+   uint8_t   picture_type
+   uint8_t   frame_coding_mode
+   uint8_t   deblockEnable
+   uint8_t   pquant
 #endif
 
    return result;
@@ -817,19 +828,30 @@ uint8_t   pquant
 /* extract the frame number from a referenced video buffer */
 static uint32_t get_ref_pic_idx(struct ruvd_decoder *dec, struct pipe_video_buffer *ref)
 {
-   uint32_t min = MAX2(dec->frame_number, NUM_MPEG2_REFS) - NUM_MPEG2_REFS;
-   uint32_t max = MAX2(dec->frame_number, 1) - 1;
-   uintptr_t frame;
-
-   /* seems to be the most sane fallback */
-   if (!ref)
-      return max;
+   const uint32_t current_frame = dec->frame_number;
+   const uint32_t max_frame = (current_frame > 0) ? current_frame - 1 : 0;
 
-   /* get the frame number from the associated data */
-   frame = (uintptr_t)vl_video_buffer_get_associated_data(ref, &dec->base);
+   // Fallback for invalid reference is the most recent possible frame.
+   if (UNLIKELY(!ref))
+      return max_frame;
+
+   uintptr_t frame_in = (uintptr_t)vl_video_buffer_get_associated_data(ref, &dec->base);
+   uint32_t frame = (uint32_t)frame_in;
+
+   // The valid range of frames is a sliding window of size NUM_MPEG2_REFS
+   // ending at the frame just before the current one.
+   const uint32_t min_frame =
+      (current_frame > NUM_MPEG2_REFS) ? current_frame - NUM_MPEG2_REFS : 0;
+
+   // OPTIMIZED: Use explicit, separate clamping operations.
+   // This form is highly friendly to modern compilers, which will generate
+   // branch-free conditional move (cmov) instructions.
+   if (frame > max_frame)
+      frame = max_frame;
+   if (frame < min_frame)
+      frame = min_frame;
 
-   /* limit the frame number to a valid range */
-   return MAX2(MIN2(frame, max), min);
+   return frame;
 }
 
 /* get mpeg2 specific msg bits */
@@ -926,15 +948,15 @@ static struct ruvd_mpeg4 get_mpeg4_msg(s
    }
 
    /*
-   int32_t    trd [2]
-   int32_t    trb [2]
-   uint8_t    vop_coding_type
-   uint8_t    vop_fcode_forward
-   uint8_t    vop_fcode_backward
-   uint8_t    rounding_control
-   uint8_t    alternate_vertical_scan_flag
-   uint8_t    top_field_first
-   */
+    *  int32_t    trd [2]
+    *  int32_t    trb [2]
+    *  uint8_t    vop_coding_type
+    *  uint8_t    vop_fcode_forward
+    *  uint8_t    vop_fcode_backward
+    *  uint8_t    rounding_control
+    *  uint8_t    alternate_vertical_scan_flag
+    *  uint8_t    top_field_first
+    */
 
    return result;
 }
@@ -950,12 +972,14 @@ static void ruvd_destroy(struct pipe_vid
    assert(decoder);
 
    map_msg_fb_it_buf(dec);
-   dec->msg->size = sizeof(*dec->msg);
-   dec->msg->msg_type = RUVD_MSG_DESTROY;
-   dec->msg->stream_handle = dec->stream_handle;
-   send_msg_buf(dec);
+   if (LIKELY(dec->msg)) {
+      dec->msg->size = sizeof(*dec->msg);
+      dec->msg->msg_type = RUVD_MSG_DESTROY;
+      dec->msg->stream_handle = dec->stream_handle;
+      send_msg_buf(dec);
 
-   flush(dec, 0, NULL);
+      flush(dec, 0, NULL);
+   }
 
    dec->ws->cs_destroy(&dec->cs);
 
@@ -1010,60 +1034,105 @@ static void ruvd_decode_macroblock(struc
 static void ruvd_decode_bitstream(struct pipe_video_codec *decoder,
                                   struct pipe_video_buffer *target,
                                   struct pipe_picture_desc *picture, unsigned num_buffers,
-                                  const void *const *buffers, const unsigned *sizes)
+                                  const void *const *restrict buffers,
+                                  const unsigned *restrict sizes)
 {
    struct ruvd_decoder *dec = (struct ruvd_decoder *)decoder;
    unsigned i;
 
-   assert(decoder);
-
-   if (!dec->bs_ptr)
+   if (UNLIKELY(!dec->bs_ptr)) {
       return;
+   }
 
-   unsigned long total_bs_size = dec->bs_size;
-   for (i = 0; i < num_buffers; ++i)
-      total_bs_size += sizes[i];
+   // Calculate total size needed first to avoid re-checking in the loop.
+   unsigned long total_incoming_size = 0;
+   for (i = 0; i < num_buffers; ++i) {
+      total_incoming_size += sizes[i];
+   }
 
+   unsigned long required_total_size = dec->bs_size + total_incoming_size;
    struct rvid_buffer *buf = &dec->bs_buffers[dec->cur_buffer];
 
-   if (total_bs_size > buf->res->buf->size) {
+   if (UNLIKELY(required_total_size > buf->res->buf->size)) {
       dec->ws->buffer_unmap(dec->ws, buf->res->buf);
       dec->bs_ptr = NULL;
 
-      total_bs_size = align(total_bs_size, 128);
+      required_total_size = align(required_total_size, 128);
 
       if (!dec->bs_size) {
          struct rvid_buffer old_buf = *buf;
-         if (!si_vid_create_buffer(dec->screen, buf, total_bs_size, buf->usage)) {
+         if (UNLIKELY(!si_vid_create_buffer(dec->screen, buf, required_total_size, buf->usage))) {
             RVID_ERR("Can't create bitstream buffer!");
             return;
          }
          si_vid_destroy_buffer(&old_buf);
-      } else if (!si_vid_resize_buffer(dec->base.context, buf, total_bs_size, NULL)) {
+      } else if (UNLIKELY(!si_vid_resize_buffer(dec->base.context, buf, required_total_size, NULL))) {
          RVID_ERR("Can't resize bitstream buffer!");
          return;
       }
 
       dec->bs_ptr = dec->ws->buffer_map(dec->ws, buf->res->buf, NULL,
                                         PIPE_MAP_WRITE | RADEON_MAP_TEMPORARY);
-      if (!dec->bs_ptr)
+      if (UNLIKELY(!dec->bs_ptr)) {
          return;
-
-      dec->bs_ptr += dec->bs_size;
+      }
    }
 
+   // The destination pointer is calculated from the immutable base pointer and the current size.
+   uint8_t *dest_base = (uint8_t *)dec->bs_ptr;
+   uint8_t *current_dest = dest_base + dec->bs_size;
+
+   // --- High-Performance Cache-Bypassing Copy ---
    for (i = 0; i < num_buffers; ++i) {
-      memcpy(dec->bs_ptr, buffers[i], sizes[i]);
-      dec->bs_size += sizes[i];
-      dec->bs_ptr += sizes[i];
+      const uint8_t *src = (const uint8_t *)buffers[i];
+      size_t n = sizes[i];
+
+      // Use a standard memcpy for small chunks where intrinsic overhead isn't worth it.
+      if (n < 128) {
+         memcpy(current_dest, src, n);
+         current_dest += n;
+         continue;
+      }
+
+      // Handle unaligned start of destination if necessary. This should be rare.
+      size_t dest_align_offset = (uintptr_t)current_dest & 0xF;
+      if (dest_align_offset) {
+         size_t align_bytes = 16 - dest_align_offset;
+         // CRITICAL FIX: Ensure we do not copy more bytes than are available in the source chunk.
+         if (align_bytes > n) {
+            align_bytes = n;
+         }
+         memcpy(current_dest, src, align_bytes);
+         current_dest += align_bytes;
+         src += align_bytes;
+         n -= align_bytes;
+      }
+
+      // Main aligned streaming copy loop.
+      const __m128i *s = (__m128i *)src;
+      __m128i *d = (__m128i *)current_dest;
+      size_t num_vectors = n / 16;
+      for (size_t j = 0; j < num_vectors; ++j) {
+         __m128i data = _mm_loadu_si128(s++); // Use unaligned load for source flexibility.
+         _mm_stream_si128(d++, data);        // Use aligned stream for destination performance.
+      }
+
+      // Handle the remainder.
+      size_t remainder_offset = num_vectors * 16;
+      memcpy(current_dest + remainder_offset, src + remainder_offset, n & 0xF);
+
+      current_dest += n;
    }
+
+   // Update the total size after all copies are done.
+   dec->bs_size = current_dest - dest_base;
 }
 
 /**
  * end decoding of the current frame
  */
 static int ruvd_end_frame(struct pipe_video_codec *decoder, struct pipe_video_buffer *target,
-                           struct pipe_picture_desc *picture)
+                          struct pipe_picture_desc *picture)
 {
    struct ruvd_decoder *dec = (struct ruvd_decoder *)decoder;
    struct pb_buffer_lean *dt;
@@ -1072,17 +1141,21 @@ static int ruvd_end_frame(struct pipe_vi
 
    assert(decoder);
 
-   if (!dec->bs_ptr)
+   if (UNLIKELY(!dec->bs_ptr))
       return 1;
 
    msg_fb_it_buf = &dec->msg_fb_it_buffers[dec->cur_buffer];
    bs_buf = &dec->bs_buffers[dec->cur_buffer];
 
    bs_size = align(dec->bs_size, 128);
-   memset(dec->bs_ptr, 0, bs_size - dec->bs_size);
+   // Pad the bitstream buffer with zeros to the next 128-byte boundary.
+   memset((uint8_t *)dec->bs_ptr + dec->bs_size, 0, bs_size - dec->bs_size);
    dec->ws->buffer_unmap(dec->ws, bs_buf->res->buf);
 
    map_msg_fb_it_buf(dec);
+   if (UNLIKELY(!dec->msg))
+      return 1;
+
    dec->msg->size = sizeof(*dec->msg);
    dec->msg->msg_type = RUVD_MSG_DECODE;
    dec->msg->stream_handle = dec->stream_handle;
@@ -1190,6 +1263,7 @@ static int ruvd_end_frame(struct pipe_vi
    return 0;
 }
 
+
 /**
  * flush any outstanding command buffers to the hardware
  */
@@ -1229,7 +1303,7 @@ struct pipe_video_codec *si_common_uvd_c
 
    dec = CALLOC_STRUCT(ruvd_decoder);
 
-   if (!dec)
+   if (UNLIKELY(!dec))
       return NULL;
 
    if (!sctx->screen->info.is_amdgpu)
@@ -1255,7 +1329,7 @@ struct pipe_video_codec *si_common_uvd_c
    dec->screen = context->screen;
    dec->ws = ws;
 
-   if (!ws->cs_create(&dec->cs, sctx->ctx, AMD_IP_UVD, NULL, NULL)) {
+   if (UNLIKELY(!ws->cs_create(&dec->cs, sctx->ctx, AMD_IP_UVD, NULL, NULL))) {
       RVID_ERR("Can't get command submission context.\n");
       goto error;
    }
@@ -1269,14 +1343,14 @@ struct pipe_video_codec *si_common_uvd_c
       STATIC_ASSERT(sizeof(struct ruvd_msg) <= FB_BUFFER_OFFSET);
       if (have_it(dec))
          msg_fb_it_size += IT_SCALING_TABLE_SIZE;
-      if (!si_vid_create_buffer(dec->screen, &dec->msg_fb_it_buffers[i], msg_fb_it_size,
-                                PIPE_USAGE_STAGING)) {
+      if (UNLIKELY(!si_vid_create_buffer(dec->screen, &dec->msg_fb_it_buffers[i], msg_fb_it_size,
+                                PIPE_USAGE_STAGING))) {
          RVID_ERR("Can't allocated message buffers.\n");
          goto error;
       }
 
-      if (!si_vid_create_buffer(dec->screen, &dec->bs_buffers[i], bs_buf_size,
-                                PIPE_USAGE_STAGING)) {
+      if (UNLIKELY(!si_vid_create_buffer(dec->screen, &dec->bs_buffers[i], bs_buf_size,
+                                PIPE_USAGE_STAGING))) {
          RVID_ERR("Can't allocated bitstream buffers.\n");
          goto error;
       }
@@ -1284,7 +1358,7 @@ struct pipe_video_codec *si_common_uvd_c
 
    dpb_size = calc_dpb_size(dec);
    if (dpb_size) {
-      if (!si_vid_create_buffer(dec->screen, &dec->dpb, dpb_size, PIPE_USAGE_DEFAULT)) {
+      if (UNLIKELY(!si_vid_create_buffer(dec->screen, &dec->dpb, dpb_size, PIPE_USAGE_DEFAULT))) {
          RVID_ERR("Can't allocated dpb.\n");
          goto error;
       }
@@ -1292,15 +1366,16 @@ struct pipe_video_codec *si_common_uvd_c
 
    if (dec->stream_type == RUVD_CODEC_H264_PERF && sctx->family >= CHIP_POLARIS10) {
       unsigned ctx_size = calc_ctx_size_h264_perf(dec);
-      if (!si_vid_create_buffer(dec->screen, &dec->ctx, ctx_size, PIPE_USAGE_DEFAULT)) {
+      if (UNLIKELY(
+            !si_vid_create_buffer(dec->screen, &dec->ctx, ctx_size, PIPE_USAGE_DEFAULT))) {
          RVID_ERR("Can't allocated context buffer.\n");
          goto error;
       }
    }
 
    if (sctx->family >= CHIP_POLARIS10) {
-      if (!si_vid_create_buffer(dec->screen, &dec->sessionctx, UVD_SESSION_CONTEXT_SIZE,
-                                PIPE_USAGE_DEFAULT)) {
+      if (UNLIKELY(!si_vid_create_buffer(dec->screen, &dec->sessionctx, UVD_SESSION_CONTEXT_SIZE,
+                                PIPE_USAGE_DEFAULT))) {
          RVID_ERR("Can't allocated session ctx.\n");
          goto error;
       }
@@ -1319,6 +1394,9 @@ struct pipe_video_codec *si_common_uvd_c
    }
 
    map_msg_fb_it_buf(dec);
+   if (UNLIKELY(!dec->msg))
+      goto error;
+
    dec->msg->size = sizeof(*dec->msg);
    dec->msg->msg_type = RUVD_MSG_CREATE;
    dec->msg->stream_handle = dec->stream_handle;
@@ -1328,7 +1406,7 @@ struct pipe_video_codec *si_common_uvd_c
    dec->msg->body.create.dpb_size = dpb_size;
    send_msg_buf(dec);
    r = flush(dec, 0, NULL);
-   if (r)
+   if (UNLIKELY(r))
       goto error;
 
    next_buffer(dec);
@@ -1336,6 +1414,7 @@ struct pipe_video_codec *si_common_uvd_c
    return &dec->base;
 
 error:
+   __attribute__((cold));
    dec->ws->cs_destroy(&dec->cs);
 
    for (i = 0; i < NUM_BUFFERS; ++i) {
@@ -1352,6 +1431,7 @@ error:
    return NULL;
 }
 
+
 /* calculate top/bottom offset */
 static unsigned texture_offset(struct radeon_surf *surface, unsigned layer,
                                enum ruvd_surface_type type)
@@ -1369,45 +1449,17 @@ static unsigned texture_offset(struct ra
 }
 
 /* hw encode the aspect of macro tiles */
-static unsigned macro_tile_aspect(unsigned macro_tile_aspect)
+static inline unsigned macro_tile_aspect(unsigned val)
 {
-   switch (macro_tile_aspect) {
-   default:
-   case 1:
-      macro_tile_aspect = 0;
-      break;
-   case 2:
-      macro_tile_aspect = 1;
-      break;
-   case 4:
-      macro_tile_aspect = 2;
-      break;
-   case 8:
-      macro_tile_aspect = 3;
-      break;
-   }
-   return macro_tile_aspect;
+   /* __builtin_ctz(0) is undefined, so guard against it. */
+   return val ? __builtin_ctz(val) : 0;
 }
 
 /* hw encode the bank width and height */
-static unsigned bank_wh(unsigned bankwh)
+static inline unsigned bank_wh(unsigned val)
 {
-   switch (bankwh) {
-   default:
-   case 1:
-      bankwh = 0;
-      break;
-   case 2:
-      bankwh = 1;
-      break;
-   case 4:
-      bankwh = 2;
-      break;
-   case 8:
-      bankwh = 3;
-      break;
-   }
-   return bankwh;
+   /* __builtin_ctz(0) is undefined, so guard against it. */
+   return val ? __builtin_ctz(val) : 0;
 }
 
 /**
