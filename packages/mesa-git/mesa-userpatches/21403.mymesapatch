From d0dbd6fba35bdc6a358a9737055a30b3b5acd18a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 2 Mar 2023 00:47:30 -0500
Subject: [PATCH 01/13] ac/nir: clear nir_var_shader_out from TCS barriers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 0dfe8ab39b9d..83f8f76ede68 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -485,8 +485,10 @@ update_hs_scoped_barrier(nir_intrinsic_instr *intrin, lower_tess_io_state *st)
     * so we have to update the barriers to also reflect this.
     */
    unsigned mem_modes = nir_intrinsic_memory_modes(intrin);
-   if (mem_modes & nir_var_shader_out)
+   if (mem_modes & nir_var_shader_out) {
       mem_modes |= nir_var_mem_shared;
+      mem_modes &= ~nir_var_shader_out;
+   }
    nir_intrinsic_set_memory_modes(intrin, mem_modes);
 
    nir_scope exec_scope = nir_intrinsic_execution_scope(intrin);
-- 
GitLab


From b009f93624ecf4cd1dc73f87bf72936b4e48b109 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 01:07:58 -0500
Subject: [PATCH 02/13] radeonsi: emulate VGT_ESGS_RING_ITEMSIZE in the shader
 on gfx9-11

The hardware uses the register to premultiply GS vertex indices
in input VGPRs.

This changes the behavior as follows:
- VGT_ESGS_RING_ITEMSIZE is always 1 on gfx9-11, set in the preamble.
- The value is passed to the shader via current_gs_state (vs_state_bits).
- The shader does the multiplication.

The reason is that VGT_ESGS_RING_ITEMSIZE will be removed in the future.
---
 .../drivers/radeonsi/si_nir_lower_abi.c       |  5 ++++-
 src/gallium/drivers/radeonsi/si_shader.h      |  4 +++-
 src/gallium/drivers/radeonsi/si_shader_info.c |  4 ++--
 .../drivers/radeonsi/si_shader_llvm_gs.c      |  2 +-
 src/gallium/drivers/radeonsi/si_state.c       |  1 +
 .../drivers/radeonsi/si_state_draw.cpp        |  7 ++++---
 .../drivers/radeonsi/si_state_shaders.cpp     | 19 ++++++++++---------
 7 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 323329e737ae..a20b9847553d 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -246,7 +246,10 @@ static bool lower_abi_instr(nir_builder *b, nir_instr *instr, struct lower_abi_s
          unreachable("no nir_load_lshs_vertex_stride_amd");
       break;
    case nir_intrinsic_load_esgs_vertex_stride_amd:
-      replacement = nir_imm_int(b, 1);
+      assert(sel->screen->info.gfx_level >= GFX9);
+      replacement = shader->is_monolithic ?
+         nir_imm_int(b, key->ge.part.gs.es->info.esgs_vertex_stride / 4) :
+         GET_FIELD_NIR(GS_STATE_ESGS_VERTEX_STRIDE);
       break;
    case nir_intrinsic_load_tcs_num_patches_amd: {
       nir_ssa_def *tmp = ac_nir_unpack_arg(b, &args->ac, args->tcs_offchip_layout, 0, 6);
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 793d405b9eb4..c4f7cda73a58 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -266,6 +266,8 @@ enum
  * in the shader via vs_state_bits in legacy GS, the GS copy shader, and any NGG shader.
  */
 /* bit gap */
+#define GS_STATE_ESGS_VERTEX_STRIDE__SHIFT      10
+#define GS_STATE_ESGS_VERTEX_STRIDE__MASK       0xff /* max 32 * 4 + 1 */
 /* Small prim filter precision = num_samples / quant_mode, which can only be equal to 1/2^n
  * where n is between 4 and 12. Knowing that, we only need to store 4 bits of the FP32 exponent.
  * Set it like this: value = (fui(num_samples / quant_mode) >> 23) & 0xf;
@@ -917,7 +919,7 @@ struct si_shader {
          unsigned vgt_primitiveid_en;
          unsigned vgt_gs_onchip_cntl;
          unsigned vgt_gs_instance_cnt;
-         unsigned vgt_esgs_ring_itemsize;
+         unsigned esgs_vertex_stride;
          unsigned spi_vs_out_config;
          unsigned spi_shader_idx_format;
          unsigned spi_shader_pos_format;
diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index d120256e0099..bf073c363e6a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -791,8 +791,8 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
        */
       if (sscreen->info.gfx_level >= GFX9)
          info->esgs_vertex_stride += 4;
-
-      assert(((info->esgs_vertex_stride / 4) & C_028AAC_ITEMSIZE) == 0);
+      else
+         assert(((info->esgs_vertex_stride / 4) & C_028AAC_ITEMSIZE) == 0);
 
       info->tcs_vgpr_only_inputs = ~info->base.tess.tcs_cross_invocation_inputs_read &
                                    ~info->base.inputs_read_indirectly &
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 65bbbb4aca52..c0213111415d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -65,8 +65,8 @@ static void si_set_es_return_value_for_gs(struct si_shader_context *ctx)
    ret = si_insert_input_ptr(ctx, ret, ctx->args->internal_bindings, 8 + SI_SGPR_INTERNAL_BINDINGS);
    ret = si_insert_input_ptr(ctx, ret, ctx->args->bindless_samplers_and_images,
                              8 + SI_SGPR_BINDLESS_SAMPLERS_AND_IMAGES);
+   ret = si_insert_input_ptr(ctx, ret, ctx->args->vs_state_bits, 8 + SI_SGPR_VS_STATE_BITS);
    if (ctx->screen->use_ngg) {
-      ret = si_insert_input_ptr(ctx, ret, ctx->args->vs_state_bits, 8 + SI_SGPR_VS_STATE_BITS);
       ret = si_insert_input_ptr(ctx, ret, ctx->args->small_prim_cull_info, 8 + GFX9_SGPR_SMALL_PRIM_CULL_INFO);
       if (ctx->screen->info.gfx_level >= GFX11)
          ret = si_insert_input_ptr(ctx, ret, ctx->args->gs_attr_address, 8 + GFX9_SGPR_ATTRIBUTE_RING_ADDR);
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index a4b3b155790e..7560a07c74be 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -5804,6 +5804,7 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
       si_pm4_set_reg(pm4, R_028C4C_PA_SC_CONSERVATIVE_RASTERIZATION_CNTL,
                      S_028C4C_NULL_SQUAD_AA_MASK_ENABLE(1));
 
+      si_pm4_set_reg(pm4, R_028AAC_VGT_ESGS_RING_ITEMSIZE, 1);
       si_pm4_set_reg(pm4, R_030968_VGT_INSTANCE_BASE_ID, 0);
 
       if (sctx->gfx_level < GFX11) {
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index a8ee703b6a9a..e1a4040b8d9b 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -1214,10 +1214,11 @@ static void si_emit_vs_state(struct si_context *sctx, unsigned index_size)
       if (HAS_GS) {
          radeon_set_sh_reg(vs_base + SI_SGPR_VS_STATE_BITS * 4, vs_state);
 
-         /* NGG always uses the state bits. Legacy GS uses the state bits only for the emulation
-          * of GS pipeline statistics on gfx10.x.
+         /* GS always uses the state bits for emulating VGT_ESGS_RING_ITEMSIZE on Gfx9
+          * (via nir_load_esgs_vertex_stride_amd) and for emulating GS pipeline statistics
+          * on gfx10.x. NGG GS also has lots of states in there.
           */
-         if (NGG || (GFX_VERSION >= GFX10 && GFX_VERSION <= GFX10_3))
+         if (GFX_VERSION >= GFX9)
             radeon_set_sh_reg(gs_base + SI_SGPR_VS_STATE_BITS * 4, gs_state);
 
          /* The GS copy shader (for legacy GS) always uses the state bits. */
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 3c50148a9c07..3ddb9ffdfc76 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -934,6 +934,11 @@ static void si_emit_shader_gs(struct si_context *sctx)
 {
    struct si_shader *shader = sctx->queued.named.gs;
 
+   if (sctx->gfx_level >= GFX9) {
+      SET_FIELD(sctx->current_gs_state, GS_STATE_ESGS_VERTEX_STRIDE,
+                shader->key.ge.part.gs.es->info.esgs_vertex_stride / 4);
+   }
+
    radeon_begin(&sctx->gfx_cs);
 
    /* R_028A60_VGT_GSVS_RING_OFFSET_1, R_028A64_VGT_GSVS_RING_OFFSET_2
@@ -971,10 +976,6 @@ static void si_emit_shader_gs(struct si_context *sctx)
       radeon_opt_set_context_reg(sctx, R_028A94_VGT_GS_MAX_PRIMS_PER_SUBGROUP,
                                  SI_TRACKED_VGT_GS_MAX_PRIMS_PER_SUBGROUP,
                                  shader->gs.vgt_gs_max_prims_per_subgroup);
-      /* R_028AAC_VGT_ESGS_RING_ITEMSIZE */
-      radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
-                                 SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                                 shader->gs.vgt_esgs_ring_itemsize);
 
       if (shader->key.ge.part.gs.es->stage == MESA_SHADER_TESS_EVAL)
          radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
@@ -1175,6 +1176,9 @@ bool gfx10_is_ngg_passthrough(struct si_shader *shader)
 /* Common tail code for NGG primitive shaders. */
 static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader *shader)
 {
+   SET_FIELD(sctx->current_gs_state, GS_STATE_ESGS_VERTEX_STRIDE,
+             shader->ngg.esgs_vertex_stride);
+
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_0287FC_GE_MAX_OUTPUT_PER_SUBGROUP,
                               SI_TRACKED_GE_MAX_OUTPUT_PER_SUBGROUP,
@@ -1189,9 +1193,6 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
    }
    radeon_opt_set_context_reg(sctx, R_028B90_VGT_GS_INSTANCE_CNT, SI_TRACKED_VGT_GS_INSTANCE_CNT,
                               shader->ngg.vgt_gs_instance_cnt);
-   radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
-                              SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                              shader->ngg.vgt_esgs_ring_itemsize);
    radeon_opt_set_context_reg(sctx, R_0286C4_SPI_VS_OUT_CONFIG, SI_TRACKED_SPI_VS_OUT_CONFIG,
                               shader->ngg.spi_vs_out_config);
    radeon_opt_set_context_reg2(
@@ -1441,10 +1442,10 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                                         gs_sel->info.writes_primid);
 
    if (gs_stage == MESA_SHADER_GEOMETRY) {
-      shader->ngg.vgt_esgs_ring_itemsize = es_sel->info.esgs_vertex_stride / 4;
+      shader->ngg.esgs_vertex_stride = es_sel->info.esgs_vertex_stride / 4;
       shader->ngg.vgt_gs_max_vert_out = gs_sel->info.base.gs.vertices_out;
    } else {
-      shader->ngg.vgt_esgs_ring_itemsize = 1;
+      shader->ngg.esgs_vertex_stride = 1;
    }
 
    if (es_stage == MESA_SHADER_TESS_EVAL)
-- 
GitLab


From d34d8f5c0ffdebbe3073563bc23471669817fe5c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 22 Feb 2023 06:38:00 -0500
Subject: [PATCH 03/13] radeonsi: merge si_emit_initial_compute_regs with
 si_init_cs_preamble_state

It's better to set all immutable registers in one place.
---
 src/gallium/drivers/radeonsi/si_compute.c     | 103 ------------------
 .../drivers/radeonsi/si_cp_reg_shadowing.c    |   5 +-
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  21 ++--
 src/gallium/drivers/radeonsi/si_pipe.c        |   4 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |   1 -
 src/gallium/drivers/radeonsi/si_state.c       |  86 +++++++++++++--
 6 files changed, 93 insertions(+), 127 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index d8491fb4c0dc..7aff25772c86 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -379,102 +379,6 @@ static void si_set_global_binding(struct pipe_context *ctx, unsigned first, unsi
    }
 }
 
-void si_emit_initial_compute_regs(struct si_context *sctx, struct radeon_cmdbuf *cs)
-{
-   const struct radeon_info *info = &sctx->screen->info;
-
-   radeon_begin(cs);
-   radeon_set_sh_reg(R_00B834_COMPUTE_PGM_HI,
-                     S_00B834_DATA(sctx->screen->info.address32_hi >> 8));
-
-   radeon_set_sh_reg_seq(R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE0, 2);
-   /* R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE0 / SE1,
-    * renamed COMPUTE_DESTINATION_EN_SEn on gfx10. */
-   radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-   radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-
-   if (sctx->gfx_level == GFX6) {
-      /* This register has been moved to R_00CD20_COMPUTE_MAX_WAVE_ID
-       * and is now per pipe, so it should be handled in the
-       * kernel if we want to use something other than the default value.
-       *
-       * TODO: This should be:
-       * (number of compute units) * 4 * (waves per simd) - 1
-       */
-      radeon_set_sh_reg(R_00B82C_COMPUTE_MAX_WAVE_ID, 0x190 /* Default value */);
-      radeon_set_config_reg(R_00950C_TA_CS_BC_BASE_ADDR, sctx->border_color_buffer->gpu_address >> 8);
-   }
-
-   if (sctx->gfx_level >= GFX7) {
-      /* Also set R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE2 / SE3 */
-      radeon_set_sh_reg_seq(R_00B864_COMPUTE_STATIC_THREAD_MGMT_SE2, 2);
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-
-      /* Disable profiling on compute queues. */
-      if (cs != &sctx->gfx_cs || !sctx->screen->info.has_graphics) {
-         radeon_set_sh_reg(R_00B82C_COMPUTE_PERFCOUNT_ENABLE, 0);
-         radeon_set_sh_reg(R_00B878_COMPUTE_THREAD_TRACE_ENABLE, 0);
-      }
-
-      /* Set the pointer to border colors. */
-      /* MI200 doesn't support border colors. */
-      if (sctx->border_color_buffer) {
-         uint64_t bc_va = sctx->border_color_buffer->gpu_address;
-
-         radeon_set_uconfig_reg_seq(R_030E00_TA_CS_BC_BASE_ADDR, 2, false);
-         radeon_emit(bc_va >> 8);                    /* R_030E00_TA_CS_BC_BASE_ADDR */
-         radeon_emit(S_030E04_ADDRESS(bc_va >> 40)); /* R_030E04_TA_CS_BC_BASE_ADDR_HI */
-      }
-   }
-
-   /* cs_preamble_state initializes this for the gfx queue, so only do this
-    * if we are on a compute queue.
-    */
-   if (sctx->gfx_level >= GFX9 && sctx->gfx_level < GFX11 &&
-       (cs != &sctx->gfx_cs || !sctx->screen->info.has_graphics)) {
-      radeon_set_uconfig_reg(R_0301EC_CP_COHER_START_DELAY,
-                             sctx->gfx_level >= GFX10 ? 0x20 : 0);
-   }
-
-   if (!info->has_graphics && info->family >= CHIP_MI100) {
-      radeon_set_sh_reg_seq(R_00B894_COMPUTE_STATIC_THREAD_MGMT_SE4, 4);
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-   }
-
-   if (sctx->gfx_level >= GFX10) {
-      radeon_set_sh_reg_seq(R_00B890_COMPUTE_USER_ACCUM_0, 4);
-      radeon_emit(0); /* R_00B890_COMPUTE_USER_ACCUM_0 */
-      radeon_emit(0); /* R_00B894_COMPUTE_USER_ACCUM_1 */
-      radeon_emit(0); /* R_00B898_COMPUTE_USER_ACCUM_2 */
-      radeon_emit(0); /* R_00B89C_COMPUTE_USER_ACCUM_3 */
-
-      radeon_set_sh_reg(R_00B9F4_COMPUTE_DISPATCH_TUNNEL, 0);
-
-      if (sctx->gfx_level < GFX11)
-         radeon_set_sh_reg(R_00B8A0_COMPUTE_PGM_RSRC3, 0);
-   }
-
-   if (sctx->gfx_level >= GFX11) {
-      radeon_set_sh_reg_seq(R_00B8AC_COMPUTE_STATIC_THREAD_MGMT_SE4, 4);
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE4 */
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE5 */
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE6 */
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE7 */
-
-      /* How many threads should go to 1 SE before moving onto the next. Think of GL1 cache hits.
-       * Only these values are valid: 0 (disabled), 64, 128, 256, 512
-       * Recommendation: 64 = RT, 256 = non-RT (run benchmarks to be sure)
-       */
-      radeon_set_sh_reg(R_00B8BC_COMPUTE_DISPATCH_INTERLEAVE, S_00B8BC_INTERLEAVE(256));
-   }
-
-   radeon_end();
-}
-
 static bool si_setup_compute_scratch_buffer(struct si_context *sctx, struct si_shader *shader)
 {
    uint64_t scratch_bo_size, scratch_needed;
@@ -1019,13 +923,6 @@ static void si_launch_grid(struct pipe_context *ctx, const struct pipe_grid_info
    if (sctx->bo_list_add_all_compute_resources)
       si_compute_resources_add_all_to_bo_list(sctx);
 
-   if (!sctx->cs_shader_state.initialized) {
-      si_emit_initial_compute_regs(sctx, &sctx->gfx_cs);
-
-      sctx->cs_shader_state.emitted_program = NULL;
-      sctx->cs_shader_state.initialized = true;
-   }
-
    /* First emit registers. */
    bool prefetch;
    if (!si_switch_compute_shader(sctx, program, &program->shader, code_object, info->pc, &prefetch,
diff --git a/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c b/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
index 9b5c15ab9633..ecdbc5ec71cc 100644
--- a/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
+++ b/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
@@ -38,8 +38,9 @@ static void si_set_context_reg_array(struct radeon_cmdbuf *cs, unsigned reg, uns
 
 void si_init_cp_reg_shadowing(struct si_context *sctx)
 {
-   if (sctx->screen->info.mid_command_buffer_preemption_enabled ||
-       sctx->screen->debug_flags & DBG(SHADOW_REGS)) {
+   if (sctx->has_graphics &&
+       (sctx->screen->info.mid_command_buffer_preemption_enabled ||
+        sctx->screen->debug_flags & DBG(SHADOW_REGS))) {
       sctx->shadowed_regs =
             si_aligned_buffer_create(sctx->b.screen,
                                      PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index 0a48aee6cef7..b82e81bd53e9 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -414,9 +414,17 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
    }
 
    si_add_all_descriptors_to_bo_list(ctx);
-
    si_shader_pointers_mark_dirty(ctx);
-   ctx->cs_shader_state.initialized = false;
+   ctx->cs_shader_state.emitted_program = NULL;
+
+   /* The CS initialization should be emitted before everything else. */
+   if (ctx->cs_preamble_state) {
+      struct si_pm4_state *preamble = is_secure ? ctx->cs_preamble_state_tmz :
+                                                  ctx->cs_preamble_state;
+      ctx->ws->cs_set_preamble(&ctx->gfx_cs, preamble->pm4, preamble->ndw,
+                               preamble != ctx->last_preamble);
+      ctx->last_preamble = preamble;
+   }
 
    if (!ctx->has_graphics) {
       ctx->initial_gfx_cs_size = ctx->gfx_cs.current.cdw;
@@ -434,15 +442,6 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
     */
    si_pm4_reset_emitted(ctx);
 
-   /* The CS initialization should be emitted before everything else. */
-   if (ctx->cs_preamble_state) {
-      struct si_pm4_state *preamble = is_secure ? ctx->cs_preamble_state_tmz :
-                                                  ctx->cs_preamble_state;
-      ctx->ws->cs_set_preamble(&ctx->gfx_cs, preamble->pm4, preamble->ndw,
-                               preamble != ctx->last_preamble);
-      ctx->last_preamble = preamble;
-   }
-
    if (ctx->queued.named.ls)
       ctx->prefetch_L2_mask |= SI_PREFETCH_LS;
    if (ctx->queued.named.hs)
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index a358b620f963..06b13ba5a5b1 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -753,9 +753,7 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
    /* The remainder of this function initializes the gfx CS and must be last. */
    assert(sctx->gfx_cs.current.cdw == 0);
 
-   if (sctx->has_graphics) {
-      si_init_cp_reg_shadowing(sctx);
-   }
+   si_init_cp_reg_shadowing(sctx);
 
    /* Set immutable fields of shader keys. */
    if (sctx->gfx_level >= GFX9) {
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 792fb4aed127..368e3abc7955 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -734,7 +734,6 @@ struct si_cs_shader_state {
    struct si_compute *emitted_program;
    unsigned offset;
    uint32_t variable_shared_size;
-   bool initialized;
 };
 
 struct si_samplers {
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 7560a07c74be..d03fe3b2afa2 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -5592,7 +5592,10 @@ unsigned gfx103_get_cu_mask_ps(struct si_screen *sscreen)
 void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
 {
    struct si_screen *sscreen = sctx->screen;
-   uint64_t border_color_va = sctx->border_color_buffer->gpu_address;
+   uint64_t border_color_va =
+      sctx->border_color_buffer ? sctx->border_color_buffer->gpu_address : 0;
+   uint32_t compute_cu_en = S_00B858_SH0_CU_EN(sscreen->info.spi_cu_en) |
+                            S_00B858_SH1_CU_EN(sscreen->info.spi_cu_en);
    bool has_clear_state = sscreen->info.has_clear_state;
 
    struct si_cs_preamble {
@@ -5607,7 +5610,7 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
    /* Add all the space that we allocated. */
    pm4->max_dw = (sizeof(struct si_cs_preamble) - offsetof(struct si_cs_preamble, pm4.pm4)) / 4;
 
-   if (!uses_reg_shadowing) {
+   if (sctx->has_graphics && !uses_reg_shadowing) {
       si_pm4_cmd_add(pm4, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
       si_pm4_cmd_add(pm4, CC0_UPDATE_LOAD_ENABLES(1));
       si_pm4_cmd_add(pm4, CC1_UPDATE_SHADOW_ENABLES(1));
@@ -5623,6 +5626,79 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
       }
    }
 
+   /* Compute registers. */
+   si_pm4_set_reg(pm4, R_00B834_COMPUTE_PGM_HI, S_00B834_DATA(sctx->screen->info.address32_hi >> 8));
+   si_pm4_set_reg(pm4, R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE0, compute_cu_en);
+   si_pm4_set_reg(pm4, R_00B85C_COMPUTE_STATIC_THREAD_MGMT_SE1, compute_cu_en);
+
+   if (sctx->gfx_level == GFX6) {
+      /* This register has been moved to R_00CD20_COMPUTE_MAX_WAVE_ID and is now per pipe,
+       * so it should be handled in the kernel if we want to use something other than
+       * the default value.
+       * TODO: This should be: (number of compute units) * 4 * (waves per simd) - 1
+       */
+      si_pm4_set_reg(pm4, R_00B82C_COMPUTE_MAX_WAVE_ID, 0x190 /* Default value */);
+   }
+
+   if (sctx->gfx_level >= GFX7) {
+      si_pm4_set_reg(pm4, R_00B864_COMPUTE_STATIC_THREAD_MGMT_SE2, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B868_COMPUTE_STATIC_THREAD_MGMT_SE3, compute_cu_en);
+
+      /* Disable profiling on compute chips. */
+      if (!sscreen->info.has_graphics) {
+         si_pm4_set_reg(pm4, R_00B82C_COMPUTE_PERFCOUNT_ENABLE, 0);
+         si_pm4_set_reg(pm4, R_00B878_COMPUTE_THREAD_TRACE_ENABLE, 0);
+      }
+   }
+
+   if (sctx->gfx_level >= GFX9 && sctx->gfx_level < GFX11)
+      si_pm4_set_reg(pm4, R_0301EC_CP_COHER_START_DELAY, sctx->gfx_level >= GFX10 ? 0x20 : 0);
+
+   if (!sscreen->info.has_graphics && sscreen->info.family >= CHIP_MI100) {
+      si_pm4_set_reg(pm4, R_00B894_COMPUTE_STATIC_THREAD_MGMT_SE4, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B898_COMPUTE_STATIC_THREAD_MGMT_SE5, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B89C_COMPUTE_STATIC_THREAD_MGMT_SE6, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8A0_COMPUTE_STATIC_THREAD_MGMT_SE7, compute_cu_en);
+   }
+
+   if (sctx->gfx_level >= GFX10) {
+      si_pm4_set_reg(pm4, R_00B890_COMPUTE_USER_ACCUM_0, 0);
+      si_pm4_set_reg(pm4, R_00B894_COMPUTE_USER_ACCUM_1, 0);
+      si_pm4_set_reg(pm4, R_00B898_COMPUTE_USER_ACCUM_2, 0);
+      si_pm4_set_reg(pm4, R_00B89C_COMPUTE_USER_ACCUM_3, 0);
+
+      if (sctx->gfx_level < GFX11)
+         si_pm4_set_reg(pm4, R_00B8A0_COMPUTE_PGM_RSRC3, 0);
+
+      si_pm4_set_reg(pm4, R_00B9F4_COMPUTE_DISPATCH_TUNNEL, 0);
+   }
+
+   if (sctx->gfx_level >= GFX11) {
+      si_pm4_set_reg(pm4, R_00B8AC_COMPUTE_STATIC_THREAD_MGMT_SE4, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8B0_COMPUTE_STATIC_THREAD_MGMT_SE5, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8B4_COMPUTE_STATIC_THREAD_MGMT_SE6, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8B8_COMPUTE_STATIC_THREAD_MGMT_SE7, compute_cu_en);
+
+      /* How many threads should go to 1 SE before moving onto the next. Think of GL1 cache hits.
+       * Only these values are valid: 0 (disabled), 64, 128, 256, 512
+       * Recommendation: 64 = RT, 256 = non-RT (run benchmarks to be sure)
+       */
+      si_pm4_set_reg(pm4, R_00B8BC_COMPUTE_DISPATCH_INTERLEAVE, S_00B8BC_INTERLEAVE(256));
+   }
+
+   /* Set the pointer to border colors. MI200 doesn't support border colors. */
+   if (sctx->gfx_level >= GFX7 && sctx->border_color_buffer) {
+      si_pm4_set_reg(pm4, R_030E00_TA_CS_BC_BASE_ADDR, border_color_va >> 8);
+      si_pm4_set_reg(pm4, R_030E04_TA_CS_BC_BASE_ADDR_HI,
+                     S_030E04_ADDRESS(border_color_va >> 40));
+   } else if (sctx->gfx_level == GFX6) {
+      si_pm4_set_reg(pm4, R_00950C_TA_CS_BC_BASE_ADDR, border_color_va >> 8);
+   }
+
+   if (!sctx->has_graphics)
+      goto done;
+
+   /* Graphics registers. */
    /* CLEAR_STATE doesn't restore these correctly. */
    si_pm4_set_reg(pm4, R_028240_PA_SC_GENERIC_SCISSOR_TL, S_028240_WINDOW_OFFSET_DISABLE(1));
    si_pm4_set_reg(pm4, R_028244_PA_SC_GENERIC_SCISSOR_BR,
@@ -5806,11 +5882,6 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
 
       si_pm4_set_reg(pm4, R_028AAC_VGT_ESGS_RING_ITEMSIZE, 1);
       si_pm4_set_reg(pm4, R_030968_VGT_INSTANCE_BASE_ID, 0);
-
-      if (sctx->gfx_level < GFX11) {
-         si_pm4_set_reg(pm4, R_0301EC_CP_COHER_START_DELAY,
-                        sctx->gfx_level >= GFX10 ? 0x20 : 0);
-      }
    }
 
    if (sctx->gfx_level >= GFX10) {
@@ -5993,6 +6064,7 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
                      S_03111C_L1_POLICY(1));
    }
 
+done:
    sctx->cs_preamble_state = pm4;
 
    /* Make a copy of the preamble for TMZ. */
-- 
GitLab


From 2833662e68bb1771109f784d752dfeb54b02270b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 23 Feb 2023 13:01:45 -0500
Subject: [PATCH 04/13] radeonsi: separate nir_texop_descriptor_amd lowering

This moves the code to a separate branch to make it less intertwined
with the rest to allow sampler descriptor lowering later.
---
 .../drivers/radeonsi/si_nir_lower_resource.c  | 48 ++++++++++---------
 1 file changed, 25 insertions(+), 23 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_resource.c b/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
index c6636c8b7f60..8ee48549a086 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
@@ -531,9 +531,16 @@ static bool lower_resource_tex(nir_builder *b, nir_tex_instr *tex,
    else
       desc_type = tex->sampler_dim == GLSL_SAMPLER_DIM_BUF ? AC_DESC_BUFFER : AC_DESC_IMAGE;
 
-   bool is_descriptor_op = tex->op == nir_texop_descriptor_amd;
+   if (tex->op == nir_texop_descriptor_amd) {
+      assert(texture_deref);
+      nir_ssa_def *image = load_deref_sampler_desc(b, texture_deref, desc_type, s, true);
+      nir_ssa_def_rewrite_uses(&tex->dest.ssa, image);
+      nir_instr_remove(&tex->instr);
+      return true;
+   }
+
    nir_ssa_def *image = texture_deref ?
-      load_deref_sampler_desc(b, texture_deref, desc_type, s, is_descriptor_op) :
+      load_deref_sampler_desc(b, texture_deref, desc_type, s, false) :
       load_bindless_sampler_desc(b, texture_handle, desc_type, s);
 
    nir_ssa_def *sampler = NULL;
@@ -542,27 +549,22 @@ static bool lower_resource_tex(nir_builder *b, nir_tex_instr *tex,
    else if (sampler_handle)
       sampler = load_bindless_sampler_desc(b, sampler_handle, AC_DESC_SAMPLER, s);
 
-   if (is_descriptor_op) {
-      nir_ssa_def_rewrite_uses(&tex->dest.ssa, image);
-      nir_instr_remove(&tex->instr);
-   } else {
-      for (unsigned i = 0; i < tex->num_srcs; i++) {
-         switch (tex->src[i].src_type) {
-         case nir_tex_src_texture_deref:
-            tex->src[i].src_type = nir_tex_src_texture_handle;
-            FALLTHROUGH;
-         case nir_tex_src_texture_handle:
-            nir_instr_rewrite_src_ssa(&tex->instr, &tex->src[i].src, image);
-            break;
-         case nir_tex_src_sampler_deref:
-            tex->src[i].src_type = nir_tex_src_sampler_handle;
-            FALLTHROUGH;
-         case nir_tex_src_sampler_handle:
-            nir_instr_rewrite_src_ssa(&tex->instr, &tex->src[i].src, sampler);
-            break;
-         default:
-            break;
-         }
+   for (unsigned i = 0; i < tex->num_srcs; i++) {
+      switch (tex->src[i].src_type) {
+      case nir_tex_src_texture_deref:
+         tex->src[i].src_type = nir_tex_src_texture_handle;
+         FALLTHROUGH;
+      case nir_tex_src_texture_handle:
+         nir_instr_rewrite_src_ssa(&tex->instr, &tex->src[i].src, image);
+         break;
+      case nir_tex_src_sampler_deref:
+         tex->src[i].src_type = nir_tex_src_sampler_handle;
+         FALLTHROUGH;
+      case nir_tex_src_sampler_handle:
+         nir_instr_rewrite_src_ssa(&tex->instr, &tex->src[i].src, sampler);
+         break;
+      default:
+         break;
       }
    }
 
-- 
GitLab


From ac10fbb45e604a02f6324b52fcc846c9ea1b88a9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 23 Feb 2023 12:58:16 -0500
Subject: [PATCH 05/13] radeonsi: lower nir_texop_sampler_descriptor_amd

---
 src/gallium/drivers/radeonsi/si_nir_lower_resource.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_resource.c b/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
index 8ee48549a086..7d8dfd4147ec 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
@@ -539,6 +539,14 @@ static bool lower_resource_tex(nir_builder *b, nir_tex_instr *tex,
       return true;
    }
 
+   if (tex->op == nir_texop_sampler_descriptor_amd) {
+      assert(sampler_deref);
+      nir_ssa_def *sampler = load_deref_sampler_desc(b, sampler_deref, AC_DESC_SAMPLER, s, true);
+      nir_ssa_def_rewrite_uses(&tex->dest.ssa, sampler);
+      nir_instr_remove(&tex->instr);
+      return true;
+   }
+
    nir_ssa_def *image = texture_deref ?
       load_deref_sampler_desc(b, texture_deref, desc_type, s, false) :
       load_bindless_sampler_desc(b, texture_handle, desc_type, s);
-- 
GitLab


From d99a3d3cf4870247aaa05963eb1ed2113a7aef6e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:19:06 -0500
Subject: [PATCH 06/13] radeonsi: set pm4.atom.emit in si_get_shader_pm4_state

except gfx10_shader_ngg, which isn't as trivial
---
 .../drivers/radeonsi/si_state_shaders.cpp     | 25 ++++++++-----------
 1 file changed, 10 insertions(+), 15 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 3ddb9ffdfc76..f1283270b19d 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -623,10 +623,12 @@ static void polaris_set_vgt_vertex_reuse(struct si_screen *sscreen, struct si_sh
    }
 }
 
-static struct si_pm4_state *si_get_shader_pm4_state(struct si_shader *shader)
+static struct si_pm4_state *si_get_shader_pm4_state(struct si_shader *shader,
+                                                    void (*emit_func)(struct si_context *ctx))
 {
    si_pm4_clear_state(&shader->pm4);
    shader->pm4.is_shader = true;
+   shader->pm4.atom.emit = emit_func;
    return &shader->pm4;
 }
 
@@ -697,7 +699,7 @@ static void si_shader_ls(struct si_screen *sscreen, struct si_shader *shader)
 
    assert(sscreen->info.gfx_level <= GFX8);
 
-   pm4 = si_get_shader_pm4_state(shader);
+   pm4 = si_get_shader_pm4_state(shader, NULL);
    if (!pm4)
       return;
 
@@ -718,7 +720,7 @@ static void si_shader_hs(struct si_screen *sscreen, struct si_shader *shader)
    struct si_pm4_state *pm4;
    uint64_t va;
 
-   pm4 = si_get_shader_pm4_state(shader);
+   pm4 = si_get_shader_pm4_state(shader, NULL);
    if (!pm4)
       return;
 
@@ -801,11 +803,10 @@ static void si_shader_es(struct si_screen *sscreen, struct si_shader *shader)
 
    assert(sscreen->info.gfx_level <= GFX8);
 
-   pm4 = si_get_shader_pm4_state(shader);
+   pm4 = si_get_shader_pm4_state(shader, si_emit_shader_es);
    if (!pm4)
       return;
 
-   pm4->atom.emit = si_emit_shader_es;
    va = shader->bo->gpu_address;
 
    if (shader->selector->stage == MESA_SHADER_VERTEX) {
@@ -1014,12 +1015,10 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
 
    assert(sscreen->info.gfx_level < GFX11); /* gfx11 doesn't have the legacy pipeline */
 
-   pm4 = si_get_shader_pm4_state(shader);
+   pm4 = si_get_shader_pm4_state(shader, si_emit_shader_gs);
    if (!pm4)
       return;
 
-   pm4->atom.emit = si_emit_shader_gs;
-
    offset = num_components[0] * sel->info.base.gs.vertices_out;
    shader->gs.vgt_gsvs_ring_offset_1 = offset;
 
@@ -1329,7 +1328,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                                     MAX2(gs_info->base.gs.invocations, 1) : 0;
    unsigned input_prim = si_get_input_prim(gs_sel, &shader->key);
    bool break_wave_at_eoi = false;
-   struct si_pm4_state *pm4 = si_get_shader_pm4_state(shader);
+   struct si_pm4_state *pm4 = si_get_shader_pm4_state(shader, NULL);
    if (!pm4)
       return;
 
@@ -1614,12 +1613,10 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
 
    assert(sscreen->info.gfx_level < GFX11);
 
-   pm4 = si_get_shader_pm4_state(shader);
+   pm4 = si_get_shader_pm4_state(shader, si_emit_shader_vs);
    if (!pm4)
       return;
 
-   pm4->atom.emit = si_emit_shader_vs;
-
    /* We always write VGT_GS_MODE in the VS state, because every switch
     * between different shader pipelines involving a different GS or no
     * GS at all involves a switch of the VS (different GS use different
@@ -1890,7 +1887,7 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
 
    shader->ps.db_shader_control = db_shader_control;
 
-   pm4 = si_get_shader_pm4_state(shader);
+   pm4 = si_get_shader_pm4_state(shader, si_emit_shader_ps);
    if (!pm4)
       return;
 
@@ -1902,8 +1899,6 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
       si_pm4_cmd_add(pm4, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
    }
 
-   pm4->atom.emit = si_emit_shader_ps;
-
    /* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
     * Possible vaules:
     * 0 -> Position = pixel center
-- 
GitLab


From 8068d02ba7791a393ba95c75029fc8b9de1c6bac Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:25:56 -0500
Subject: [PATCH 07/13] radeonsi: reindent si_shader_ls, si_shader_es,
 si_shader_gs, si_shader_vs

---
 .../drivers/radeonsi/si_state_shaders.cpp     | 23 +++++++++++--------
 1 file changed, 13 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index f1283270b19d..91e797a340a8 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -709,10 +709,10 @@ static void si_shader_ls(struct si_screen *sscreen, struct si_shader *shader)
    shader->config.rsrc1 = S_00B528_VGPRS(si_shader_encode_vgprs(shader)) |
                           S_00B528_SGPRS(si_shader_encode_sgprs(shader)) |
                           S_00B528_VGPR_COMP_CNT(si_get_vs_vgpr_comp_cnt(sscreen, shader, false)) |
-                          S_00B528_DX10_CLAMP(1) | S_00B528_FLOAT_MODE(shader->config.float_mode);
-   shader->config.rsrc2 =
-      S_00B52C_USER_SGPR(si_get_num_vs_user_sgprs(shader, SI_VS_NUM_USER_SGPR)) |
-      S_00B52C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0);
+                          S_00B528_DX10_CLAMP(1) |
+                          S_00B528_FLOAT_MODE(shader->config.float_mode);
+   shader->config.rsrc2 = S_00B52C_USER_SGPR(si_get_num_vs_user_sgprs(shader, SI_VS_NUM_USER_SGPR)) |
+                          S_00B52C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0);
 }
 
 static void si_shader_hs(struct si_screen *sscreen, struct si_shader *shader)
@@ -826,11 +826,12 @@ static void si_shader_es(struct si_screen *sscreen, struct si_shader *shader)
    si_pm4_set_reg(pm4, R_00B328_SPI_SHADER_PGM_RSRC1_ES,
                   S_00B328_VGPRS(si_shader_encode_vgprs(shader)) |
                   S_00B328_SGPRS(si_shader_encode_sgprs(shader)) |
-                     S_00B328_VGPR_COMP_CNT(vgpr_comp_cnt) | S_00B328_DX10_CLAMP(1) |
-                     S_00B328_FLOAT_MODE(shader->config.float_mode));
+                  S_00B328_VGPR_COMP_CNT(vgpr_comp_cnt) |
+                  S_00B328_DX10_CLAMP(1) |
+                  S_00B328_FLOAT_MODE(shader->config.float_mode));
    si_pm4_set_reg(pm4, R_00B32C_SPI_SHADER_PGM_RSRC2_ES,
                   S_00B32C_USER_SGPR(num_user_sgprs) | S_00B32C_OC_LDS_EN(oc_lds_en) |
-                     S_00B32C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
+                  S_00B32C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
 
    if (shader->selector->stage == MESA_SHADER_TESS_EVAL)
       si_set_tesseval_regs(sscreen, shader->selector, shader);
@@ -1144,10 +1145,11 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
       si_pm4_set_reg(pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS,
                      S_00B228_VGPRS(si_shader_encode_vgprs(shader)) |
                      S_00B228_SGPRS(si_shader_encode_sgprs(shader)) |
-                        S_00B228_DX10_CLAMP(1) | S_00B228_FLOAT_MODE(shader->config.float_mode));
+                     S_00B228_DX10_CLAMP(1) |
+                     S_00B228_FLOAT_MODE(shader->config.float_mode));
       si_pm4_set_reg(pm4, R_00B22C_SPI_SHADER_PGM_RSRC2_GS,
                      S_00B22C_USER_SGPR(GFX6_GS_NUM_USER_SGPR) |
-                        S_00B22C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
+                     S_00B22C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
    }
 }
 
@@ -1706,7 +1708,8 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
    uint32_t rsrc1 =
       S_00B128_VGPRS(si_shader_encode_vgprs(shader)) |
       S_00B128_SGPRS(si_shader_encode_sgprs(shader)) |
-      S_00B128_VGPR_COMP_CNT(vgpr_comp_cnt) | S_00B128_DX10_CLAMP(1) |
+      S_00B128_VGPR_COMP_CNT(vgpr_comp_cnt) |
+      S_00B128_DX10_CLAMP(1) |
       S_00B128_MEM_ORDERED(si_shader_mem_ordered(shader)) |
       S_00B128_FLOAT_MODE(shader->config.float_mode);
    uint32_t rsrc2 = S_00B12C_USER_SGPR(num_user_sgprs) | S_00B12C_OC_LDS_EN(oc_lds_en) |
-- 
GitLab


From 2a714e386af7da5df2e461e593a1c5fc3b062634 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:26:17 -0500
Subject: [PATCH 08/13] radeonsi: reorganize si_shader_hs

To make branching based on gfx_level nicer and the code in a logical order.
---
 .../drivers/radeonsi/si_state_shaders.cpp     | 78 +++++++++----------
 1 file changed, 36 insertions(+), 42 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 91e797a340a8..40355b1c9983 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -717,60 +717,54 @@ static void si_shader_ls(struct si_screen *sscreen, struct si_shader *shader)
 
 static void si_shader_hs(struct si_screen *sscreen, struct si_shader *shader)
 {
-   struct si_pm4_state *pm4;
-   uint64_t va;
-
-   pm4 = si_get_shader_pm4_state(shader, NULL);
+   struct si_pm4_state *pm4 = si_get_shader_pm4_state(shader, NULL);
    if (!pm4)
       return;
 
-   va = shader->bo->gpu_address;
-
-   if (sscreen->info.gfx_level >= GFX9) {
-      if (sscreen->info.gfx_level >= GFX11) {
-         si_pm4_set_reg_idx3(sscreen, pm4, R_00B404_SPI_SHADER_PGM_RSRC4_HS,
-                             ac_apply_cu_en(S_00B404_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)) |
-                                            S_00B404_CU_EN(0xffff),
-                                            C_00B404_CU_EN, 16, &sscreen->info));
-      }
-      if (sscreen->info.gfx_level >= GFX10) {
-         si_pm4_set_reg_va(pm4, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
-      } else {
-         si_pm4_set_reg_va(pm4, R_00B410_SPI_SHADER_PGM_LO_LS, va >> 8);
-      }
-
-      unsigned num_user_sgprs = si_get_num_vs_user_sgprs(shader, GFX9_TCS_NUM_USER_SGPR);
+   uint64_t va = shader->bo->gpu_address;
+   unsigned num_user_sgprs = sscreen->info.gfx_level >= GFX9 ?
+                                si_get_num_vs_user_sgprs(shader, GFX9_TCS_NUM_USER_SGPR) :
+                                GFX6_TCS_NUM_USER_SGPR;
 
-      shader->config.rsrc2 = S_00B42C_USER_SGPR(num_user_sgprs) |
-                             S_00B42C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0);
-
-      if (sscreen->info.gfx_level >= GFX10)
-         shader->config.rsrc2 |= S_00B42C_USER_SGPR_MSB_GFX10(num_user_sgprs >> 5);
-      else
-         shader->config.rsrc2 |= S_00B42C_USER_SGPR_MSB_GFX9(num_user_sgprs >> 5);
+   if (sscreen->info.gfx_level >= GFX11) {
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B404_SPI_SHADER_PGM_RSRC4_HS,
+                          ac_apply_cu_en(S_00B404_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)) |
+                                         S_00B404_CU_EN(0xffff),
+                                         C_00B404_CU_EN, 16, &sscreen->info));
+
+      si_pm4_set_reg_va(pm4, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
+   } else if (sscreen->info.gfx_level >= GFX10) {
+      si_pm4_set_reg_va(pm4, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
+   } else if (sscreen->info.gfx_level >= GFX9) {
+      si_pm4_set_reg_va(pm4, R_00B410_SPI_SHADER_PGM_LO_LS, va >> 8);
    } else {
       si_pm4_set_reg_va(pm4, R_00B420_SPI_SHADER_PGM_LO_HS, va >> 8);
       si_pm4_set_reg(pm4, R_00B424_SPI_SHADER_PGM_HI_HS,
                      S_00B424_MEM_BASE(sscreen->info.address32_hi >> 8));
-
-      shader->config.rsrc2 = S_00B42C_USER_SGPR(GFX6_TCS_NUM_USER_SGPR) | S_00B42C_OC_LDS_EN(1) |
-                             S_00B42C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0);
    }
 
-   si_pm4_set_reg(
-      pm4, R_00B428_SPI_SHADER_PGM_RSRC1_HS,
-      S_00B428_VGPRS(si_shader_encode_vgprs(shader)) |
-      S_00B428_SGPRS(si_shader_encode_sgprs(shader)) |
-         S_00B428_DX10_CLAMP(1) | S_00B428_MEM_ORDERED(si_shader_mem_ordered(shader)) |
-         S_00B428_WGP_MODE(sscreen->info.gfx_level >= GFX10) |
-         S_00B428_FLOAT_MODE(shader->config.float_mode) |
-         S_00B428_LS_VGPR_COMP_CNT(sscreen->info.gfx_level >= GFX9
-                                      ? si_get_vs_vgpr_comp_cnt(sscreen, shader, false)
-                                      : 0));
+   si_pm4_set_reg(pm4, R_00B428_SPI_SHADER_PGM_RSRC1_HS,
+                  S_00B428_VGPRS(si_shader_encode_vgprs(shader)) |
+                  S_00B428_SGPRS(si_shader_encode_sgprs(shader)) |
+                  S_00B428_DX10_CLAMP(1) |
+                  S_00B428_MEM_ORDERED(si_shader_mem_ordered(shader)) |
+                  S_00B428_WGP_MODE(sscreen->info.gfx_level >= GFX10) |
+                  S_00B428_FLOAT_MODE(shader->config.float_mode) |
+                  S_00B428_LS_VGPR_COMP_CNT(sscreen->info.gfx_level >= GFX9 ?
+                                            si_get_vs_vgpr_comp_cnt(sscreen, shader, false) : 0));
 
-   if (sscreen->info.gfx_level <= GFX8) {
+   shader->config.rsrc2 = S_00B42C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0) |
+                          S_00B42C_USER_SGPR(num_user_sgprs);
+
+   if (sscreen->info.gfx_level >= GFX10)
+      shader->config.rsrc2 |= S_00B42C_USER_SGPR_MSB_GFX10(num_user_sgprs >> 5);
+   else if (sscreen->info.gfx_level >= GFX9)
+      shader->config.rsrc2 |= S_00B42C_USER_SGPR_MSB_GFX9(num_user_sgprs >> 5);
+   else
+      shader->config.rsrc2 |= S_00B42C_OC_LDS_EN(1);
+
+   if (sscreen->info.gfx_level <= GFX8)
       si_pm4_set_reg(pm4, R_00B42C_SPI_SHADER_PGM_RSRC2_HS, shader->config.rsrc2);
-   }
 }
 
 static void si_emit_shader_es(struct si_context *sctx)
-- 
GitLab


From 3d7e8e3b1f093224d80b4f1d8cb339916fa53e35 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:30:08 -0500
Subject: [PATCH 09/13] radeonsi: reorganize si_shader_ngg

To make branching based on gfx_level nicer and the code in a logical order.
---
 .../drivers/radeonsi/si_state_shaders.cpp     | 189 +++++++++---------
 1 file changed, 92 insertions(+), 97 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 40355b1c9983..ba9ed2c908e3 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -1190,9 +1190,10 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
                               shader->ngg.vgt_gs_instance_cnt);
    radeon_opt_set_context_reg(sctx, R_0286C4_SPI_VS_OUT_CONFIG, SI_TRACKED_SPI_VS_OUT_CONFIG,
                               shader->ngg.spi_vs_out_config);
-   radeon_opt_set_context_reg2(
-      sctx, R_028708_SPI_SHADER_IDX_FORMAT, SI_TRACKED_SPI_SHADER_IDX_FORMAT,
-      shader->ngg.spi_shader_idx_format, shader->ngg.spi_shader_pos_format);
+   radeon_opt_set_context_reg2(sctx, R_028708_SPI_SHADER_IDX_FORMAT,
+                               SI_TRACKED_SPI_SHADER_IDX_FORMAT,
+                               shader->ngg.spi_shader_idx_format,
+                               shader->ngg.spi_shader_pos_format);
    radeon_opt_set_context_reg(sctx, R_028818_PA_CL_VTE_CNTL, SI_TRACKED_PA_CL_VTE_CNTL,
                               shader->ngg.pa_cl_vte_cntl);
    radeon_opt_set_context_reg(sctx, R_028838_PA_CL_NGG_CNTL, SI_TRACKED_PA_CL_NGG_CNTL,
@@ -1315,7 +1316,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
    const struct si_shader_info *es_info = &es_sel->info;
    const gl_shader_stage es_stage = es_sel->stage;
    unsigned num_user_sgprs;
-   unsigned nparams, es_vgpr_comp_cnt, gs_vgpr_comp_cnt;
+   unsigned num_params, es_vgpr_comp_cnt, gs_vgpr_comp_cnt;
    uint64_t va;
    bool window_space = gs_sel->stage == MESA_SHADER_VERTEX ?
                           gs_info->base.vs.window_space_position : 0;
@@ -1324,16 +1325,17 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                                     MAX2(gs_info->base.gs.invocations, 1) : 0;
    unsigned input_prim = si_get_input_prim(gs_sel, &shader->key);
    bool break_wave_at_eoi = false;
+
    struct si_pm4_state *pm4 = si_get_shader_pm4_state(shader, NULL);
    if (!pm4)
       return;
 
    if (es_stage == MESA_SHADER_TESS_EVAL) {
       pm4->atom.emit = gs_stage == MESA_SHADER_GEOMETRY ? gfx10_emit_shader_ngg_tess_gs
-                                                       : gfx10_emit_shader_ngg_tess_nogs;
+                                                        : gfx10_emit_shader_ngg_tess_nogs;
    } else {
       pm4->atom.emit = gs_stage == MESA_SHADER_GEOMETRY ? gfx10_emit_shader_ngg_notess_gs
-                                                       : gfx10_emit_shader_ngg_notess_nogs;
+                                                        : gfx10_emit_shader_ngg_notess_nogs;
    }
 
    va = shader->bo->gpu_address;
@@ -1374,54 +1376,26 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
    else
       gs_vgpr_comp_cnt = 0; /* VGPR0 contains offsets 0, 1 */
 
-   unsigned late_alloc_wave64, cu_mask;
-
-   ac_compute_late_alloc(&sscreen->info, true, shader->key.ge.opt.ngg_culling,
-                         shader->config.scratch_bytes_per_wave > 0,
-                         &late_alloc_wave64, &cu_mask);
-
    si_pm4_set_reg_va(pm4, R_00B320_SPI_SHADER_PGM_LO_ES, va >> 8);
-   si_pm4_set_reg(
-      pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS,
-      S_00B228_VGPRS(si_shader_encode_vgprs(shader)) |
-         S_00B228_FLOAT_MODE(shader->config.float_mode) | S_00B228_DX10_CLAMP(1) |
-         S_00B228_MEM_ORDERED(si_shader_mem_ordered(shader)) |
-         /* Disable the WGP mode on gfx10.3 because it can hang. (it happened on VanGogh)
-          * Let's disable it on all chips that disable exactly 1 CU per SA for GS. */
-         S_00B228_WGP_MODE(sscreen->info.gfx_level == GFX10) |
-         S_00B228_GS_VGPR_COMP_CNT(gs_vgpr_comp_cnt));
+   si_pm4_set_reg(pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS,
+                  S_00B228_VGPRS(si_shader_encode_vgprs(shader)) |
+                  S_00B228_FLOAT_MODE(shader->config.float_mode) |
+                  S_00B228_DX10_CLAMP(1) |
+                  S_00B228_MEM_ORDERED(si_shader_mem_ordered(shader)) |
+                  /* Disable the WGP mode on gfx10.3 because it can hang. (it happened on VanGogh)
+                   * Let's disable it on all chips that disable exactly 1 CU per SA for GS. */
+                  S_00B228_WGP_MODE(sscreen->info.gfx_level == GFX10) |
+                  S_00B228_GS_VGPR_COMP_CNT(gs_vgpr_comp_cnt));
    si_pm4_set_reg(pm4, R_00B22C_SPI_SHADER_PGM_RSRC2_GS,
                   S_00B22C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0) |
-                     S_00B22C_USER_SGPR(num_user_sgprs) |
-                     S_00B22C_ES_VGPR_COMP_CNT(es_vgpr_comp_cnt) |
-                     S_00B22C_USER_SGPR_MSB_GFX10(num_user_sgprs >> 5) |
-                     S_00B22C_OC_LDS_EN(es_stage == MESA_SHADER_TESS_EVAL) |
-                     S_00B22C_LDS_SIZE(shader->config.lds_size));
-
-   shader->ngg.spi_shader_pgm_rsrc3_gs =
-      ac_apply_cu_en(S_00B21C_CU_EN(cu_mask) |
-                     S_00B21C_WAVE_LIMIT(0x3F),
-                     C_00B21C_CU_EN, 0, &sscreen->info);
-   if (sscreen->info.gfx_level >= GFX11) {
-      shader->ngg.spi_shader_pgm_rsrc4_gs =
-         ac_apply_cu_en(S_00B204_CU_EN_GFX11(0x1) |
-                        S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64) |
-                        S_00B204_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)),
-                        C_00B204_CU_EN_GFX11, 16, &sscreen->info);
-   } else {
-      shader->ngg.spi_shader_pgm_rsrc4_gs =
-         ac_apply_cu_en(S_00B204_CU_EN_GFX10(0xffff) |
-                        S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64),
-                        C_00B204_CU_EN_GFX10, 16, &sscreen->info);
-   }
-
-   nparams = MAX2(shader->info.nr_param_exports, 1);
-   shader->ngg.spi_vs_out_config =
-      S_0286C4_VS_EXPORT_COUNT(nparams - 1) |
-      S_0286C4_NO_PC_EXPORT(shader->info.nr_param_exports == 0);
-
-   shader->ngg.spi_shader_idx_format =
-      S_028708_IDX0_EXPORT_FORMAT(V_028708_SPI_SHADER_1COMP);
+                  S_00B22C_USER_SGPR(num_user_sgprs) |
+                  S_00B22C_ES_VGPR_COMP_CNT(es_vgpr_comp_cnt) |
+                  S_00B22C_USER_SGPR_MSB_GFX10(num_user_sgprs >> 5) |
+                  S_00B22C_OC_LDS_EN(es_stage == MESA_SHADER_TESS_EVAL) |
+                  S_00B22C_LDS_SIZE(shader->config.lds_size));
+
+   /* Set register values emitted conditionally in gfx10_emit_shader_ngg_*. */
+   shader->ngg.spi_shader_idx_format = S_028708_IDX0_EXPORT_FORMAT(V_028708_SPI_SHADER_1COMP);
    shader->ngg.spi_shader_pos_format =
       S_02870C_POS0_EXPORT_FORMAT(V_02870C_SPI_SHADER_4COMP) |
       S_02870C_POS1_EXPORT_FORMAT(shader->info.nr_pos_exports > 1 ? V_02870C_SPI_SHADER_4COMP
@@ -1430,11 +1404,21 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                                                                   : V_02870C_SPI_SHADER_NONE) |
       S_02870C_POS3_EXPORT_FORMAT(shader->info.nr_pos_exports > 3 ? V_02870C_SPI_SHADER_4COMP
                                                                   : V_02870C_SPI_SHADER_NONE);
+   shader->ngg.ge_max_output_per_subgroup = S_0287FC_MAX_VERTS_PER_SUBGROUP(shader->ngg.max_out_verts);
+   shader->ngg.ge_ngg_subgrp_cntl = S_028B4C_PRIM_AMP_FACTOR(shader->ngg.prim_amp_factor);
+   shader->ngg.vgt_gs_instance_cnt =
+      S_028B90_ENABLE(gs_num_invocations > 1) |
+      S_028B90_CNT(gs_num_invocations) |
+      S_028B90_EN_MAX_VERT_OUT_PER_GS_INSTANCE(shader->ngg.max_vert_out_per_gs_instance);
 
-   shader->ngg.vgt_primitiveid_en =
-      S_028A84_PRIMITIVEID_EN(es_enable_prim_id) |
-      S_028A84_NGG_DISABLE_PROVOK_REUSE(shader->key.ge.mono.u.vs_export_prim_id ||
-                                        gs_sel->info.writes_primid);
+   /* Output hw-generated edge flags if needed and pass them via the prim
+    * export to prevent drawing lines on internal edges of decomposed
+    * primitives (such as quads) with polygon mode = lines.
+    */
+   shader->ngg.pa_cl_ngg_cntl =
+      S_028838_INDEX_BUF_EDGE_FLAG_ENA(gfx10_edgeflags_have_effect(shader)) |
+      S_028838_VERTEX_REUSE_DEPTH(sscreen->info.gfx_level >= GFX10_3 ? 30 : 0);
+   shader->pa_cl_vs_out_cntl = si_get_vs_out_cntl(shader->selector, shader, true);
 
    if (gs_stage == MESA_SHADER_GEOMETRY) {
       shader->ngg.esgs_vertex_stride = es_sel->info.esgs_vertex_stride / 4;
@@ -1446,25 +1430,20 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
    if (es_stage == MESA_SHADER_TESS_EVAL)
       si_set_tesseval_regs(sscreen, es_sel, shader);
 
-   shader->ngg.ge_max_output_per_subgroup =
-      S_0287FC_MAX_VERTS_PER_SUBGROUP(shader->ngg.max_out_verts);
-   shader->ngg.ge_ngg_subgrp_cntl = S_028B4C_PRIM_AMP_FACTOR(shader->ngg.prim_amp_factor);
-   shader->ngg.vgt_gs_instance_cnt =
-      S_028B90_CNT(gs_num_invocations) | S_028B90_ENABLE(gs_num_invocations > 1) |
-      S_028B90_EN_MAX_VERT_OUT_PER_GS_INSTANCE(shader->ngg.max_vert_out_per_gs_instance);
+   num_params = MAX2(shader->info.nr_param_exports, 1);
 
-   /* Output hw-generated edge flags if needed and pass them via the prim
-    * export to prevent drawing lines on internal edges of decomposed
-    * primitives (such as quads) with polygon mode = lines.
-    */
-   shader->ngg.pa_cl_ngg_cntl =
-      S_028838_INDEX_BUF_EDGE_FLAG_ENA(gfx10_edgeflags_have_effect(shader)) |
-      /* Reuse for NGG. */
-      S_028838_VERTEX_REUSE_DEPTH(sscreen->info.gfx_level >= GFX10_3 ? 30 : 0);
-   shader->pa_cl_vs_out_cntl = si_get_vs_out_cntl(shader->selector, shader, true);
+   shader->ngg.vgt_primitiveid_en =
+      S_028A84_NGG_DISABLE_PROVOK_REUSE(shader->key.ge.mono.u.vs_export_prim_id ||
+                                        gs_sel->info.writes_primid);
+
+   unsigned late_alloc_wave64, cu_mask;
+
+   ac_compute_late_alloc(&sscreen->info, true, shader->key.ge.opt.ngg_culling,
+                         shader->config.scratch_bytes_per_wave > 0,
+                         &late_alloc_wave64, &cu_mask);
 
    /* Oversubscribe PC. This improves performance when there are too many varyings. */
-   unsigned oversub_pc_factor = 1;
+   unsigned oversub_pc_lines, oversub_pc_factor = 1;
 
    if (shader->key.ge.opt.ngg_culling) {
       /* Be more aggressive with NGG culling. */
@@ -1475,11 +1454,28 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
       else
          oversub_pc_factor = 2;
    }
-
-   unsigned oversub_pc_lines =
-      late_alloc_wave64 ? (sscreen->info.pc_lines / 4) * oversub_pc_factor : 0;
+   oversub_pc_lines = late_alloc_wave64 ? (sscreen->info.pc_lines / 4) * oversub_pc_factor : 0;
    shader->ngg.ge_pc_alloc = S_030980_OVERSUB_EN(oversub_pc_lines > 0) |
                              S_030980_NUM_PC_LINES(oversub_pc_lines - 1);
+   shader->ngg.vgt_primitiveid_en |= S_028A84_PRIMITIVEID_EN(es_enable_prim_id);
+   shader->ngg.spi_shader_pgm_rsrc3_gs =
+      ac_apply_cu_en(S_00B21C_CU_EN(cu_mask) |
+                     S_00B21C_WAVE_LIMIT(0x3F),
+                     C_00B21C_CU_EN, 0, &sscreen->info);
+   shader->ngg.spi_shader_pgm_rsrc4_gs = S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64);
+   shader->ngg.spi_vs_out_config = S_0286C4_VS_EXPORT_COUNT(num_params - 1) |
+                                   S_0286C4_NO_PC_EXPORT(shader->info.nr_param_exports == 0);
+
+   if (sscreen->info.gfx_level >= GFX11) {
+      shader->ngg.spi_shader_pgm_rsrc4_gs |=
+         ac_apply_cu_en(S_00B204_CU_EN_GFX11(0x1) |
+                        S_00B204_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)),
+                        C_00B204_CU_EN_GFX11, 16, &sscreen->info);
+   } else {
+      shader->ngg.spi_shader_pgm_rsrc4_gs |=
+         ac_apply_cu_en(S_00B204_CU_EN_GFX10(0xffff),
+                        C_00B204_CU_EN_GFX10, 16, &sscreen->info);
+   }
 
    if (sscreen->info.gfx_level >= GFX11) {
       shader->ge_cntl = S_03096C_PRIMS_PER_SUBGRP(shader->ngg.max_gsprims) |
@@ -1487,8 +1483,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                         S_03096C_BREAK_PRIMGRP_AT_EOI(break_wave_at_eoi) |
                         /* This should be <= 252 for performance. 256 works too but is slower. */
                         S_03096C_PRIM_GRP_SIZE_GFX11(
-                           CLAMP(252 / MAX2(shader->ngg.prim_amp_factor, 1),
-                                 1, 256));
+                           CLAMP(252 / MAX2(shader->ngg.prim_amp_factor, 1), 1, 256));
    } else {
       shader->ge_cntl = S_03096C_PRIM_GRP_SIZE_GFX10(shader->ngg.max_gsprims) |
                         S_03096C_VERT_GRP_SIZE(shader->ngg.hw_max_esverts) |
@@ -1498,34 +1493,34 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
          S_028A44_ES_VERTS_PER_SUBGRP(shader->ngg.hw_max_esverts) |
          S_028A44_GS_PRIMS_PER_SUBGRP(shader->ngg.max_gsprims) |
          S_028A44_GS_INST_PRIMS_IN_SUBGRP(shader->ngg.max_gsprims * gs_num_invocations);
-   }
 
-   /* On gfx10, the GE only checks against the maximum number of ES verts after
-    * allocating a full GS primitive. So we need to ensure that whenever
-    * this check passes, there is enough space for a full primitive without
-    * vertex reuse. VERT_GRP_SIZE=256 doesn't need this. We should always get 256
-    * if we have enough LDS.
-    *
-    * Tessellation is unaffected because it always sets GE_CNTL.VERT_GRP_SIZE = 0.
-    */
-   if ((sscreen->info.gfx_level == GFX10) &&
-       (es_stage == MESA_SHADER_VERTEX || gs_stage == MESA_SHADER_VERTEX) && /* = no tess */
-       shader->ngg.hw_max_esverts != 256 &&
-       shader->ngg.hw_max_esverts > 5) {
-      /* This could be based on the input primitive type. 5 is the worst case
-       * for primitive types with adjacency.
+      /* On gfx10, the GE only checks against the maximum number of ES verts after
+       * allocating a full GS primitive. So we need to ensure that whenever
+       * this check passes, there is enough space for a full primitive without
+       * vertex reuse. VERT_GRP_SIZE=256 doesn't need this. We should always get 256
+       * if we have enough LDS.
+       *
+       * Tessellation is unaffected because it always sets GE_CNTL.VERT_GRP_SIZE = 0.
        */
-      shader->ge_cntl &= C_03096C_VERT_GRP_SIZE;
-      shader->ge_cntl |= S_03096C_VERT_GRP_SIZE(shader->ngg.hw_max_esverts - 5);
+      if ((sscreen->info.gfx_level == GFX10) &&
+          (es_stage == MESA_SHADER_VERTEX || gs_stage == MESA_SHADER_VERTEX) && /* = no tess */
+          shader->ngg.hw_max_esverts != 256 &&
+          shader->ngg.hw_max_esverts > 5) {
+         /* This could be based on the input primitive type. 5 is the worst case
+          * for primitive types with adjacency.
+          */
+         shader->ge_cntl &= C_03096C_VERT_GRP_SIZE;
+         shader->ge_cntl |= S_03096C_VERT_GRP_SIZE(shader->ngg.hw_max_esverts - 5);
+      }
    }
 
    if (window_space) {
       shader->ngg.pa_cl_vte_cntl = S_028818_VTX_XY_FMT(1) | S_028818_VTX_Z_FMT(1);
    } else {
-      shader->ngg.pa_cl_vte_cntl =
-         S_028818_VTX_W0_FMT(1) | S_028818_VPORT_X_SCALE_ENA(1) | S_028818_VPORT_X_OFFSET_ENA(1) |
-         S_028818_VPORT_Y_SCALE_ENA(1) | S_028818_VPORT_Y_OFFSET_ENA(1) |
-         S_028818_VPORT_Z_SCALE_ENA(1) | S_028818_VPORT_Z_OFFSET_ENA(1);
+      shader->ngg.pa_cl_vte_cntl = S_028818_VTX_W0_FMT(1) |
+                                   S_028818_VPORT_X_SCALE_ENA(1) | S_028818_VPORT_X_OFFSET_ENA(1) |
+                                   S_028818_VPORT_Y_SCALE_ENA(1) | S_028818_VPORT_Y_OFFSET_ENA(1) |
+                                   S_028818_VPORT_Z_SCALE_ENA(1) | S_028818_VPORT_Z_OFFSET_ENA(1);
    }
 
    shader->ngg.vgt_stages.u.ngg = 1;
-- 
GitLab


From af40752d3d1ffc05536c0aa89bb891705aac0f91 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:31:31 -0500
Subject: [PATCH 10/13] radeonsi: reorganize si_shader_ps

To make branching based on gfx_level nicer and the code in a logical order.
---
 .../drivers/radeonsi/si_state_shaders.cpp     | 152 ++++++++----------
 1 file changed, 65 insertions(+), 87 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index ba9ed2c908e3..9f913f3ed221 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -1758,21 +1758,16 @@ static void si_emit_shader_ps(struct si_context *sctx)
    struct si_shader *shader = sctx->queued.named.ps;
 
    radeon_begin(&sctx->gfx_cs);
-   /* R_0286CC_SPI_PS_INPUT_ENA, R_0286D0_SPI_PS_INPUT_ADDR*/
    radeon_opt_set_context_reg2(sctx, R_0286CC_SPI_PS_INPUT_ENA, SI_TRACKED_SPI_PS_INPUT_ENA,
                                shader->ps.spi_ps_input_ena,
                                shader->ps.spi_ps_input_addr);
-
    radeon_opt_set_context_reg(sctx, R_0286E0_SPI_BARYC_CNTL, SI_TRACKED_SPI_BARYC_CNTL,
                               shader->ps.spi_baryc_cntl);
    radeon_opt_set_context_reg(sctx, R_0286D8_SPI_PS_IN_CONTROL, SI_TRACKED_SPI_PS_IN_CONTROL,
                               shader->ps.spi_ps_in_control);
-
-   /* R_028710_SPI_SHADER_Z_FORMAT, R_028714_SPI_SHADER_COL_FORMAT */
    radeon_opt_set_context_reg2(sctx, R_028710_SPI_SHADER_Z_FORMAT, SI_TRACKED_SPI_SHADER_Z_FORMAT,
                                shader->ps.spi_shader_z_format,
                                shader->ps.spi_shader_col_format);
-
    radeon_opt_set_context_reg(sctx, R_02823C_CB_SHADER_MASK, SI_TRACKED_CB_SHADER_MASK,
                               shader->ps.cb_shader_mask);
    radeon_end_update_context_roll(sctx);
@@ -1781,11 +1776,7 @@ static void si_emit_shader_ps(struct si_context *sctx)
 static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
 {
    struct si_shader_info *info = &shader->selector->info;
-   struct si_pm4_state *pm4;
-   unsigned spi_ps_in_control, spi_shader_col_format, cb_shader_mask;
-   unsigned spi_baryc_cntl = S_0286E0_FRONT_FACE_ALL_BITS(1);
-   uint64_t va;
-   unsigned input_ena = shader->config.spi_ps_input_ena;
+   const unsigned input_ena = shader->config.spi_ps_input_ena;
 
    /* we need to enable at least one of them, otherwise we hang the GPU */
    assert(G_0286CC_PERSP_SAMPLE_ENA(input_ena) || G_0286CC_PERSP_CENTER_ENA(input_ena) ||
@@ -1818,18 +1809,17 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
           !G_0286CC_LINEAR_CENTER_ENA(input_ena) || !G_0286CC_LINEAR_CENTROID_ENA(input_ena));
 
    /* DB_SHADER_CONTROL */
-   unsigned db_shader_control =
-      S_02880C_Z_EXPORT_ENABLE(info->writes_z) |
-      S_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(info->writes_stencil) |
-      S_02880C_MASK_EXPORT_ENABLE(info->writes_samplemask) |
-      S_02880C_KILL_ENABLE(si_shader_uses_discard(shader));
+   shader->ps.db_shader_control = S_02880C_Z_EXPORT_ENABLE(info->writes_z) |
+                                  S_02880C_STENCIL_TEST_VAL_EXPORT_ENABLE(info->writes_stencil) |
+                                  S_02880C_MASK_EXPORT_ENABLE(info->writes_samplemask) |
+                                  S_02880C_KILL_ENABLE(si_shader_uses_discard(shader));
 
    switch (info->base.fs.depth_layout) {
    case FRAG_DEPTH_LAYOUT_GREATER:
-      db_shader_control |= S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_GREATER_THAN_Z);
+      shader->ps.db_shader_control |= S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_GREATER_THAN_Z);
       break;
    case FRAG_DEPTH_LAYOUT_LESS:
-      db_shader_control |= S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_LESS_THAN_Z);
+      shader->ps.db_shader_control |= S_02880C_CONSERVATIVE_Z_EXPORT(V_02880C_EXPORT_LESS_THAN_Z);
       break;
    default:;
    }
@@ -1854,42 +1844,29 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
     */
    if (info->base.fs.early_fragment_tests) {
       /* Cases 3, 4. */
-      db_shader_control |= S_02880C_DEPTH_BEFORE_SHADER(1) |
-                           S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z) |
-                           S_02880C_EXEC_ON_NOOP(info->base.writes_memory);
+      shader->ps.db_shader_control |= S_02880C_DEPTH_BEFORE_SHADER(1) |
+                                      S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z) |
+                                      S_02880C_EXEC_ON_NOOP(info->base.writes_memory);
    } else if (info->base.writes_memory) {
       /* Case 2. */
-      db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z) | S_02880C_EXEC_ON_HIER_FAIL(1);
+      shader->ps.db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z) |
+                                      S_02880C_EXEC_ON_HIER_FAIL(1);
    } else {
       /* Case 1. */
-      db_shader_control |= S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z);
+      shader->ps.db_shader_control |= S_02880C_Z_ORDER(V_02880C_EARLY_Z_THEN_LATE_Z);
    }
 
    if (info->base.fs.post_depth_coverage)
-      db_shader_control |= S_02880C_PRE_SHADER_DEPTH_COVERAGE_ENABLE(1);
+      shader->ps.db_shader_control |= S_02880C_PRE_SHADER_DEPTH_COVERAGE_ENABLE(1);
 
    /* Bug workaround for smoothing (overrasterization) on GFX6. */
    if (sscreen->info.gfx_level == GFX6 && shader->key.ps.mono.poly_line_smoothing) {
-      db_shader_control &= C_02880C_Z_ORDER;
-      db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z);
+      shader->ps.db_shader_control &= C_02880C_Z_ORDER;
+      shader->ps.db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z);
    }
 
    if (sscreen->info.has_rbplus && !sscreen->info.rbplus_allowed)
-      db_shader_control |= S_02880C_DUAL_QUAD_DISABLE(1);
-
-   shader->ps.db_shader_control = db_shader_control;
-
-   pm4 = si_get_shader_pm4_state(shader, si_emit_shader_ps);
-   if (!pm4)
-      return;
-
-   /* If multiple state sets are allowed to be in a bin, break the batch on a new PS. */
-   if (sscreen->dpbb_allowed &&
-       (sscreen->pbb_context_states_per_bin > 1 ||
-        sscreen->pbb_persistent_states_per_bin > 1)) {
-      si_pm4_cmd_add(pm4, PKT3(PKT3_EVENT_WRITE, 0, 0));
-      si_pm4_cmd_add(pm4, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
-   }
+      shader->ps.db_shader_control |= S_02880C_DUAL_QUAD_DISABLE(1);
 
    /* SPI_BARYC_CNTL.POS_FLOAT_LOCATION
     * Possible vaules:
@@ -1909,13 +1886,17 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
     * the pixel. Thus, return the value at sample position, because that's
     * the most accurate one shaders can get.
     */
-   spi_baryc_cntl |= S_0286E0_POS_FLOAT_LOCATION(2);
-
-   if (info->base.fs.pixel_center_integer)
-      spi_baryc_cntl |= S_0286E0_POS_FLOAT_ULC(1);
-
-   spi_shader_col_format = si_get_spi_shader_col_format(shader);
-   cb_shader_mask = ac_get_cb_shader_mask(shader->key.ps.part.epilog.spi_shader_col_format);
+   shader->ps.spi_baryc_cntl = S_0286E0_POS_FLOAT_LOCATION(2) |
+                               S_0286E0_POS_FLOAT_ULC(info->base.fs.pixel_center_integer) |
+                               S_0286E0_FRONT_FACE_ALL_BITS(1);
+   shader->ps.spi_shader_col_format = si_get_spi_shader_col_format(shader);
+   shader->ps.cb_shader_mask = ac_get_cb_shader_mask(shader->key.ps.part.epilog.spi_shader_col_format);
+   shader->ps.spi_ps_input_ena = shader->config.spi_ps_input_ena;
+   shader->ps.spi_ps_input_addr = shader->config.spi_ps_input_addr;
+   shader->ps.num_interp = si_get_ps_num_interp(shader);
+   shader->ps.spi_shader_z_format =
+      ac_get_spi_shader_z_format(info->writes_z, info->writes_stencil, info->writes_samplemask,
+                                 shader->key.ps.part.epilog.alpha_to_coverage_via_mrtz);
 
    /* Ensure that some export memory is always allocated, for two reasons:
     *
@@ -1936,60 +1917,41 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
     */
    bool has_mrtz = info->writes_z || info->writes_stencil || info->writes_samplemask;
 
-   if (!spi_shader_col_format) {
+   if (!shader->ps.spi_shader_col_format) {
       if (shader->key.ps.part.epilog.rbplus_depth_only_opt) {
-         spi_shader_col_format = V_028714_SPI_SHADER_32_R;
+         shader->ps.spi_shader_col_format = V_028714_SPI_SHADER_32_R;
       } else if (!has_mrtz) {
          if (sscreen->info.gfx_level >= GFX10) {
-            if (G_02880C_KILL_ENABLE(db_shader_control))
-               spi_shader_col_format = V_028714_SPI_SHADER_32_R;
+            if (G_02880C_KILL_ENABLE(shader->ps.db_shader_control))
+               shader->ps.spi_shader_col_format = V_028714_SPI_SHADER_32_R;
          } else {
-            spi_shader_col_format = V_028714_SPI_SHADER_32_R;
+            shader->ps.spi_shader_col_format = V_028714_SPI_SHADER_32_R;
          }
       }
    }
 
-   shader->ps.spi_ps_input_ena = input_ena;
-   shader->ps.spi_ps_input_addr = shader->config.spi_ps_input_addr;
-
-   unsigned num_interp = si_get_ps_num_interp(shader);
-
-   /* Set interpolation controls. */
-   spi_ps_in_control = S_0286D8_NUM_INTERP(num_interp) |
-                       S_0286D8_PS_W32_EN(shader->wave_size == 32);
-
    /* Enable PARAM_GEN for point smoothing.
     * Gfx11 workaround when there are no PS inputs but LDS is used.
     */
-   if ((sscreen->info.gfx_level == GFX11 && !num_interp && shader->config.lds_size) ||
-       shader->key.ps.mono.point_smoothing)
-      spi_ps_in_control |= S_0286D8_PARAM_GEN(1);
-
-   shader->ps.num_interp = num_interp;
-   shader->ps.spi_baryc_cntl = spi_baryc_cntl;
-   shader->ps.spi_ps_in_control = spi_ps_in_control;
-   shader->ps.spi_shader_z_format =
-      ac_get_spi_shader_z_format(info->writes_z, info->writes_stencil, info->writes_samplemask,
-                                 shader->key.ps.part.epilog.alpha_to_coverage_via_mrtz);
-   shader->ps.spi_shader_col_format = spi_shader_col_format;
-   shader->ps.cb_shader_mask = cb_shader_mask;
+   bool param_gen = shader->key.ps.mono.point_smoothing ||
+                    (sscreen->info.gfx_level == GFX11 && !shader->ps.num_interp &&
+                     shader->config.lds_size);
 
-   va = shader->bo->gpu_address;
-   si_pm4_set_reg_va(pm4, R_00B020_SPI_SHADER_PGM_LO_PS, va >> 8);
-   si_pm4_set_reg(pm4, R_00B024_SPI_SHADER_PGM_HI_PS,
-                  S_00B024_MEM_BASE(sscreen->info.address32_hi >> 8));
+   shader->ps.spi_ps_in_control = S_0286D8_NUM_INTERP(shader->ps.num_interp) |
+                                  S_0286D8_PARAM_GEN(param_gen) |
+                                  S_0286D8_PS_W32_EN(shader->wave_size == 32);
 
-   uint32_t rsrc1 =
-      S_00B028_VGPRS(si_shader_encode_vgprs(shader)) |
-      S_00B028_SGPRS(si_shader_encode_sgprs(shader)) |
-      S_00B028_DX10_CLAMP(1) | S_00B028_MEM_ORDERED(si_shader_mem_ordered(shader)) |
-      S_00B028_FLOAT_MODE(shader->config.float_mode);
+   struct si_pm4_state *pm4 = si_get_shader_pm4_state(shader, si_emit_shader_ps);
+   if (!pm4)
+      return;
 
-   si_pm4_set_reg(pm4, R_00B028_SPI_SHADER_PGM_RSRC1_PS, rsrc1);
-   si_pm4_set_reg(pm4, R_00B02C_SPI_SHADER_PGM_RSRC2_PS,
-                  S_00B02C_EXTRA_LDS_SIZE(shader->config.lds_size) |
-                     S_00B02C_USER_SGPR(SI_PS_NUM_USER_SGPR) |
-                     S_00B32C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
+   /* If multiple state sets are allowed to be in a bin, break the batch on a new PS. */
+   if (sscreen->dpbb_allowed &&
+       (sscreen->pbb_context_states_per_bin > 1 ||
+        sscreen->pbb_persistent_states_per_bin > 1)) {
+      si_pm4_cmd_add(pm4, PKT3(PKT3_EVENT_WRITE, 0, 0));
+      si_pm4_cmd_add(pm4, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+   }
 
    if (sscreen->info.gfx_level >= GFX11) {
       unsigned cu_mask_ps = gfx103_get_cu_mask_ps(sscreen);
@@ -1999,6 +1961,22 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
                                          S_00B004_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)),
                                          C_00B004_CU_EN, 16, &sscreen->info));
    }
+
+   uint64_t va = shader->bo->gpu_address;
+   si_pm4_set_reg_va(pm4, R_00B020_SPI_SHADER_PGM_LO_PS, va >> 8);
+   si_pm4_set_reg(pm4, R_00B024_SPI_SHADER_PGM_HI_PS,
+                  S_00B024_MEM_BASE(sscreen->info.address32_hi >> 8));
+
+   si_pm4_set_reg(pm4, R_00B028_SPI_SHADER_PGM_RSRC1_PS,
+                  S_00B028_VGPRS(si_shader_encode_vgprs(shader)) |
+                  S_00B028_SGPRS(si_shader_encode_sgprs(shader)) |
+                  S_00B028_DX10_CLAMP(1) |
+                  S_00B028_MEM_ORDERED(si_shader_mem_ordered(shader)) |
+                  S_00B028_FLOAT_MODE(shader->config.float_mode));
+   si_pm4_set_reg(pm4, R_00B02C_SPI_SHADER_PGM_RSRC2_PS,
+                  S_00B02C_EXTRA_LDS_SIZE(shader->config.lds_size) |
+                  S_00B02C_USER_SGPR(SI_PS_NUM_USER_SGPR) |
+                  S_00B32C_SCRATCH_EN(shader->config.scratch_bytes_per_wave > 0));
 }
 
 static void si_shader_init_pm4_state(struct si_screen *sscreen, struct si_shader *shader)
-- 
GitLab


From 46c731590e433abeaa7c836f1b3a09798940d922 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:32:01 -0500
Subject: [PATCH 11/13] radeonsi: other cosmetic changes in
 si_state_shaders.cpp

VS_W32_EN has no effect on Gfx11, but we better not set it.
---
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 9f913f3ed221..e13c7e98dc7b 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -4169,8 +4169,9 @@ struct si_pm4_state *si_build_vgt_shader_config(struct si_screen *screen, union
                 S_028B54_PRIMGEN_PASSTHRU_EN(key.u.ngg_passthrough) |
                 S_028B54_PRIMGEN_PASSTHRU_NO_MSG(key.u.ngg_passthrough &&
                                                  screen->info.family >= CHIP_NAVI23);
-   } else if (key.u.gs)
+   } else if (key.u.gs) {
       stages |= S_028B54_VS_EN(V_028B54_VS_STAGE_COPY_SHADER);
+   }
 
    if (screen->info.gfx_level >= GFX9)
       stages |= S_028B54_MAX_PRIMGRP_IN_WAVE(2);
@@ -4178,7 +4179,7 @@ struct si_pm4_state *si_build_vgt_shader_config(struct si_screen *screen, union
    if (screen->info.gfx_level >= GFX10) {
       stages |= S_028B54_HS_W32_EN(key.u.hs_wave32) |
                 S_028B54_GS_W32_EN(key.u.gs_wave32) |
-                S_028B54_VS_W32_EN(key.u.vs_wave32);
+                S_028B54_VS_W32_EN(screen->info.gfx_level < GFX11 && key.u.vs_wave32);
       /* Legacy GS only supports Wave64. Read it as an implication. */
       assert(!(key.u.gs && !key.u.ngg) || !key.u.gs_wave32);
    }
-- 
GitLab


From b193d0ff529616f2c2edb25e2e1e65dacf105b09 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:41:39 -0500
Subject: [PATCH 12/13] radeonsi: allow using 64K LDS for NGG to allow larger
 workgroups

This should help with NGG streamout performance, which is limited by
the workgroup size (it should be as large as possible).
---
 src/gallium/drivers/radeonsi/gfx10_shader_ngg.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 64186055e269..6fe8b1dcc0c1 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -106,10 +106,8 @@ bool gfx10_ngg_calculate_subgroup_info(struct si_shader *shader)
    const unsigned max_verts_per_prim = u_vertices_per_prim(input_prim);
    const unsigned min_verts_per_prim = gs_stage == MESA_SHADER_GEOMETRY ? max_verts_per_prim : 1;
 
-   /* All these are in dwords: */
-   /* GE can only use 8K dwords (32KB) of LDS per workgroup.
-    */
-   const unsigned max_lds_size = 8 * 1024 - gfx10_ngg_get_scratch_dw_size(shader);
+   /* All these are in dwords. The maximum is 16K dwords (64KB) of LDS per workgroup. */
+   const unsigned max_lds_size = 16 * 1024 - gfx10_ngg_get_scratch_dw_size(shader);
    const unsigned target_lds_size = max_lds_size;
    unsigned esvert_lds_size = 0;
    unsigned gsprim_lds_size = 0;
-- 
GitLab


From 15e38854a7258f803495c1e5a4b771fc4142f88d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 25 Feb 2023 17:52:24 -0500
Subject: [PATCH 13/13] radeonsi: increase NGG workgroup size to 256 for VS/TES
 with streamout and GS

NGG streamout performance is limited by the workgroup size, so make it as
large as possible.

Since this uses si_get_max_workgroup_size() to set the NGG workgroup size,
the side effect is that all GS is also getting an increase to 256, which
is OK.
---
 src/gallium/drivers/radeonsi/gfx10_shader_ngg.c | 5 +++--
 src/gallium/drivers/radeonsi/si_pipe.c          | 2 --
 src/gallium/drivers/radeonsi/si_pipe.h          | 2 --
 src/gallium/drivers/radeonsi/si_shader.c        | 8 ++++++--
 src/gallium/drivers/radeonsi/si_shader.h        | 2 +-
 5 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 6fe8b1dcc0c1..2880f32e1626 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -117,8 +117,9 @@ bool gfx10_ngg_calculate_subgroup_info(struct si_shader *shader)
       gs_sel->screen->info.gfx_level >= GFX11 ? 3 : /* gfx11 requires at least 1 primitive per TG */
       gs_sel->screen->info.gfx_level >= GFX10_3 ? 29 : (24 - 1 + max_verts_per_prim);
    bool max_vert_out_per_gs_instance = false;
-   unsigned max_gsprims_base = gs_sel->screen->ngg_subgroup_size; /* default prim group size clamp */
-   unsigned max_esverts_base = gs_sel->screen->ngg_subgroup_size;
+   unsigned max_gsprims_base, max_esverts_base;
+
+   max_gsprims_base = max_esverts_base = si_get_max_workgroup_size(shader);
 
    if (gs_stage == MESA_SHADER_GEOMETRY) {
       bool force_multi_cycling = false;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 06b13ba5a5b1..4dfbb0d2c2b4 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1413,8 +1413,6 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
       }
    }
 
-   sscreen->ngg_subgroup_size = 128;
-
    if (sscreen->info.gfx_level >= GFX11) {
       unsigned attr_ring_size = sscreen->info.attribute_ring_size_per_se * sscreen->info.max_se;
       sscreen->attribute_ring = si_aligned_buffer_create(&sscreen->b,
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 368e3abc7955..3c3ad6af7cdc 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -694,8 +694,6 @@ struct si_screen {
     * We want to minimize the impact on multithreaded Mesa. */
    struct ac_llvm_compiler compiler_lowp[10];
 
-   unsigned ngg_subgroup_size;
-
    struct util_idalloc_mt buffer_ids;
    struct util_vertex_state_cache vertex_state_cache;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 095ed12ded58..ac97f7168109 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -206,7 +206,11 @@ unsigned si_get_max_workgroup_size(const struct si_shader *shader)
    switch (shader->selector->stage) {
    case MESA_SHADER_VERTEX:
    case MESA_SHADER_TESS_EVAL:
-      return shader->key.ge.as_ngg ? shader->selector->screen->ngg_subgroup_size : 0;
+      /* Use the largest workgroup size for streamout */
+      if (shader->key.ge.as_ngg)
+         return si_shader_uses_streamout(shader) ? 256 : 128;
+      else
+         return 0;
 
    case MESA_SHADER_TESS_CTRL:
       /* Return this so that LLVM doesn't remove s_barrier
@@ -214,7 +218,7 @@ unsigned si_get_max_workgroup_size(const struct si_shader *shader)
       return shader->selector->screen->info.gfx_level >= GFX7 ? 128 : 0;
 
    case MESA_SHADER_GEOMETRY:
-      /* ngg_subgroup_size is only the input size. GS can always generate up to 256 vertices. */
+      /* GS can always generate up to 256 vertices. */
       return shader->selector->screen->info.gfx_level >= GFX9 ? 256 : 0;
 
    case MESA_SHADER_COMPUTE:
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index c4f7cda73a58..a01944da8838 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -1058,7 +1058,7 @@ static inline bool gfx10_ngg_writes_user_edgeflags(struct si_shader *shader)
           shader->selector->info.writes_edgeflag;
 }
 
-static inline bool si_shader_uses_streamout(struct si_shader *shader)
+static inline bool si_shader_uses_streamout(const struct si_shader *shader)
 {
    return shader->selector->stage <= MESA_SHADER_GEOMETRY &&
           shader->selector->info.enabled_streamout_buffer_mask &&
-- 
GitLab

