From 04c0e9e072b755cd1ed7229cf9e85ebc9aea767c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 6 Feb 2023 00:12:50 -0500
Subject: [PATCH 01/45] radeonsi: fix COMPAT_MODE on gfx8-9

It was set in the wrong dword.

Fixes: e673bb4ae44 ("amd,util: fix how lod bias is converted to fixed-point")

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index bc984009222e..018e7ce4b490 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4826,8 +4826,8 @@ static void *si_create_sampler_state(struct pipe_context *ctx,
       rstate->val[2] |= S_008F38_LOD_BIAS(S_FIXED(CLAMP(state->lod_bias, -32, 31), 8)) |
                         S_008F38_ANISO_OVERRIDE_GFX10(1);
    } else {
-      rstate->val[2] |= S_008F30_COMPAT_MODE(sctx->gfx_level >= GFX8) |
-                        S_008F38_LOD_BIAS(S_FIXED(CLAMP(state->lod_bias, -16, 15), 8)) |
+      rstate->val[0] |= S_008F30_COMPAT_MODE(sctx->gfx_level >= GFX8);
+      rstate->val[2] |= S_008F38_LOD_BIAS(S_FIXED(CLAMP(state->lod_bias, -16, 15), 8)) |
                         S_008F38_DISABLE_LSB_CEIL(sctx->gfx_level <= GFX8) |
                         S_008F38_FILTER_PREC_FIX(1) |
                         S_008F38_ANISO_OVERRIDE_GFX8(sctx->gfx_level >= GFX8);
-- 
GitLab


From f772e6a3c4caf14075f0ef5fe8d0de290f43ae98 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 6 Feb 2023 17:47:56 -0500
Subject: [PATCH 02/45] amd: fix LOD_BIAS on gfx6-9 and adjust the lod bias CAP

Fixes: e673bb4ae44 - amd,util: fix how lod bias is converted to fixed-point

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/ci/radeonsi-raven-fails.txt     | 5 -----
 src/amd/ci/radeonsi-stoney-fails.txt    | 5 -----
 src/amd/vulkan/radv_device.c            | 2 +-
 src/gallium/drivers/radeonsi/si_get.c   | 5 ++++-
 src/gallium/drivers/radeonsi/si_state.c | 2 +-
 5 files changed, 6 insertions(+), 13 deletions(-)

diff --git a/src/amd/ci/radeonsi-raven-fails.txt b/src/amd/ci/radeonsi-raven-fails.txt
index d1c56ecd4529..5db71e556646 100644
--- a/src/amd/ci/radeonsi-raven-fails.txt
+++ b/src/amd/ci/radeonsi-raven-fails.txt
@@ -191,8 +191,3 @@ spec@!opengl 1.0@gl-1.0-user-clip-all-planes,Fail
 spec@ext_transform_feedback@builtin-varyings gl_culldistance,Fail
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
-
-# Happened during Collabora's LAVA farm downtime
-# Disablement: https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21119
-# Enablement: https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/20903
-spec@ext_texture_lod_bias@lodbias,Fail
diff --git a/src/amd/ci/radeonsi-stoney-fails.txt b/src/amd/ci/radeonsi-stoney-fails.txt
index dcef994f4818..8fe0580d0eb4 100644
--- a/src/amd/ci/radeonsi-stoney-fails.txt
+++ b/src/amd/ci/radeonsi-stoney-fails.txt
@@ -236,8 +236,3 @@ spec@khr_texture_compression_astc@sliced-3d-miptree-gles srgb-fp,Fail
 spec@khr_texture_compression_astc@sliced-3d-miptree-gles srgb-fp@sRGB decode full precision,Fail
 
 spec@!opengl 1.1@line-smooth-stipple,Fail
-
-# Happened during Collabora's LAVA farm downtime
-# Disablement: https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21119
-# Enablement: https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/20903
-spec@ext_texture_lod_bias@lodbias,Fail
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index e903c65a9570..4e21cecf2ce3 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -7757,7 +7757,7 @@ radv_init_sampler(struct radv_device *device, struct radv_sampler *sampler,
          S_008F38_ANISO_OVERRIDE_GFX10(device->instance->disable_aniso_single_level);
    } else {
       sampler->state[2] |=
-         S_008F38_LOD_BIAS(radv_float_to_sfixed(CLAMP(pCreateInfo->mipLodBias, -16, 15), 8)) |
+         S_008F38_LOD_BIAS(radv_float_to_sfixed(CLAMP(pCreateInfo->mipLodBias, -16, 16), 8)) |
          S_008F38_DISABLE_LSB_CEIL(device->physical_device->rad_info.gfx_level <= GFX8) |
          S_008F38_FILTER_PREC_FIX(1) |
          S_008F38_ANISO_OVERRIDE_GFX8(device->instance->disable_aniso_single_level &&
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index caf07a7479fe..c649aa49104e 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -415,6 +415,8 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
 
 static float si_get_paramf(struct pipe_screen *pscreen, enum pipe_capf param)
 {
+   struct si_screen *sscreen = (struct si_screen *)pscreen;
+
    switch (param) {
    case PIPE_CAPF_MIN_LINE_WIDTH:
    case PIPE_CAPF_MIN_LINE_WIDTH_AA:
@@ -435,7 +437,8 @@ static float si_get_paramf(struct pipe_screen *pscreen, enum pipe_capf param)
    case PIPE_CAPF_MAX_TEXTURE_ANISOTROPY:
       return 16.0f;
    case PIPE_CAPF_MAX_TEXTURE_LOD_BIAS:
-      return 16.0f;
+      /* This is the maximum value of the LOD_BIAS sampler field. */
+      return sscreen->info.gfx_level >= GFX10 ? 31 : 16;
    case PIPE_CAPF_MIN_CONSERVATIVE_RASTER_DILATE:
    case PIPE_CAPF_MAX_CONSERVATIVE_RASTER_DILATE:
    case PIPE_CAPF_CONSERVATIVE_RASTER_DILATE_GRANULARITY:
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 018e7ce4b490..6e69974a4380 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4827,7 +4827,7 @@ static void *si_create_sampler_state(struct pipe_context *ctx,
                         S_008F38_ANISO_OVERRIDE_GFX10(1);
    } else {
       rstate->val[0] |= S_008F30_COMPAT_MODE(sctx->gfx_level >= GFX8);
-      rstate->val[2] |= S_008F38_LOD_BIAS(S_FIXED(CLAMP(state->lod_bias, -16, 15), 8)) |
+      rstate->val[2] |= S_008F38_LOD_BIAS(S_FIXED(CLAMP(state->lod_bias, -16, 16), 8)) |
                         S_008F38_DISABLE_LSB_CEIL(sctx->gfx_level <= GFX8) |
                         S_008F38_FILTER_PREC_FIX(1) |
                         S_008F38_ANISO_OVERRIDE_GFX8(sctx->gfx_level >= GFX8);
-- 
GitLab


From 19eefd359b2af3f62c4a24d3bc2e21c51034a952 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Jan 2023 03:49:42 -0500
Subject: [PATCH 03/45] amd: add missing gfx11 register definitions

Fixes: caa09f66ae4 - amd: add chip identification for gfx1100-1103

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/registers/gfx11.json              |  8 +++++--
 src/amd/registers/parse_kernel_headers.py | 28 +++++++++++++++++++++++
 2 files changed, 34 insertions(+), 2 deletions(-)

diff --git a/src/amd/registers/gfx11.json b/src/amd/registers/gfx11.json
index 51db7b37148e..60e15b79d719 100644
--- a/src/amd/registers/gfx11.json
+++ b/src/amd/registers/gfx11.json
@@ -10921,7 +10921,10 @@
     {"bits": [21, 21], "name": "SKIP_LOW_COMP_RATIO"},
     {"bits": [22, 22], "name": "FDCC_ENABLE"},
     {"bits": [23, 23], "name": "DCC_COMPRESS_DISABLE"},
-    {"bits": [24, 24], "name": "FRAGMENT_COMPRESS_DISABLE"}
+    {"bits": [24, 24], "name": "FRAGMENT_COMPRESS_DISABLE"},
+    {"bits": [25, 25], "name": "DISABLE_OVERRIDE_INCONSISTENT_KEYS"},
+    {"bits": [26, 26], "name": "ENABLE_MAX_COMP_FRAG_OVERRIDE"},
+    {"bits": [27, 29], "name": "MAX_COMP_FRAGS"}
    ]
   },
   "CB_COLOR0_INFO": {
@@ -14584,7 +14587,8 @@
    "fields": [
     {"bits": [1, 1], "name": "EN_REG_RT_INDEX"},
     {"bits": [3, 3], "name": "EN_PRIM_PAYLOAD"},
-    {"bits": [4, 4], "name": "EN_DRAW_VP"}
+    {"bits": [4, 4], "name": "EN_DRAW_VP"},
+    {"bits": [6, 6], "name": "EN_VRS_RATE"}
    ]
   },
   "VGT_ESGS_RING_ITEMSIZE": {
diff --git a/src/amd/registers/parse_kernel_headers.py b/src/amd/registers/parse_kernel_headers.py
index 920cbcf3280a..9cd0425b852f 100644
--- a/src/amd/registers/parse_kernel_headers.py
+++ b/src/amd/registers/parse_kernel_headers.py
@@ -719,6 +719,34 @@ fields_missing = {
     "VGT_DRAW_PAYLOAD_CNTL": [["EN_VRS_RATE", 6, 6]],
     "VGT_SHADER_STAGES_EN": [["PRIMGEN_PASSTHRU_NO_MSG", 26, 26]],
   },
+  'gfx11': {
+    "VGT_DRAW_PAYLOAD_CNTL": [["EN_VRS_RATE", 6, 6]],
+    # Only GFX1103_R2:
+    "CB_COLOR0_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR1_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR2_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR3_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR4_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR5_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR6_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+    "CB_COLOR7_FDCC_CONTROL": [["DISABLE_OVERRIDE_INCONSISTENT_KEYS", 25, 25],
+                               ["ENABLE_MAX_COMP_FRAG_OVERRIDE", 26, 26],
+                               ["MAX_COMP_FRAGS", 27, 29]],
+  },
 }
 
 ######### END HARDCODED CONFIGURATION
-- 
GitLab


From f509d75ef7b109aeaea785b690c3e8719938fbb1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 03:56:57 -0500
Subject: [PATCH 04/45] amd: bump AMD_MAX_SE and change the CU mask type to 16
 bits

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/common/ac_gpu_info.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.h b/src/amd/common/ac_gpu_info.h
index d4125df62ab3..babbf698a889 100644
--- a/src/amd/common/ac_gpu_info.h
+++ b/src/amd/common/ac_gpu_info.h
@@ -39,7 +39,7 @@
 extern "C" {
 #endif
 
-#define AMD_MAX_SE         8
+#define AMD_MAX_SE         32
 #define AMD_MAX_SA_PER_SE  2
 
 struct amdgpu_gpu_info;
@@ -210,7 +210,7 @@ struct radeon_info {
    bool kernel_has_modifiers;
 
    /* Shader cores. */
-   uint32_t cu_mask[AMD_MAX_SE][AMD_MAX_SA_PER_SE];
+   uint16_t cu_mask[AMD_MAX_SE][AMD_MAX_SA_PER_SE];
    uint32_t r600_max_quad_pipes; /* wave size / 16 */
    uint32_t max_good_cu_per_sa;
    uint32_t min_good_cu_per_sa; /* min != max if SAs have different # of CUs */
-- 
GitLab


From 400ef26ac384d4b9249da4d98f9d207f57fe9425 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 5 Feb 2023 00:13:50 -0500
Subject: [PATCH 05/45] radeonsi/gfx11: fix the CU_EN clear mask for RSRC4_GS

Fixes: 9fecac091f3 - radeonsi/gfx11: scattered register deltas

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 4ad63764cc09..6658d66cd8d8 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -1228,7 +1228,8 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
                        (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
       ac_set_reg_cu_en(&sctx->gfx_cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
                        shader->ctx_reg.ngg.spi_shader_pgm_rsrc4_gs,
-                       C_00B204_CU_EN_GFX10, 16, &sctx->screen->info,
+                       sctx->gfx_level >= GFX11 ? C_00B204_CU_EN_GFX11 : C_00B204_CU_EN_GFX10, 16,
+                       &sctx->screen->info,
                        (void (*)(void*, unsigned, uint32_t))
                        (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
       sctx->tracked_regs.reg_saved &= ~BITFIELD64_BIT(SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS) &
-- 
GitLab


From 929f1ae598b7582b58c95a13574dac9bcb63d22c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 7 Feb 2023 22:48:41 -0500
Subject: [PATCH 06/45] radeonsi/gfx11: don't set non-existent
 VGT_STRMOUT_BUFFER_CONFIG

Fixes: 9fecac091f3 - radeonsi/gfx11: scattered register deltas

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 6e69974a4380..d89fef9613db 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -5634,9 +5634,9 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
       si_pm4_set_reg(pm4, R_028AC8_DB_PRELOAD_CONTROL, 0x0);
       si_pm4_set_reg(pm4, R_02800C_DB_RENDER_OVERRIDE, 0);
       si_pm4_set_reg(pm4, R_028A8C_VGT_PRIMITIVEID_RESET, 0x0);
-      si_pm4_set_reg(pm4, R_028B98_VGT_STRMOUT_BUFFER_CONFIG, 0x0);
 
       if (sctx->gfx_level < GFX11) {
+         si_pm4_set_reg(pm4, R_028B98_VGT_STRMOUT_BUFFER_CONFIG, 0x0);
          si_pm4_set_reg(pm4, R_028A5C_VGT_GS_PER_VS, 0x2);
          si_pm4_set_reg(pm4, R_028AB8_VGT_VTX_CNT_EN, 0x0);
       }
-- 
GitLab


From 93dd92a26294b883e7666888ce227818634218c6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Jan 2023 03:53:36 -0500
Subject: [PATCH 07/45] radeonsi/gfx11: set CB_COLORi_INFO.MAX_COMP_FRAG on
 GFX1103_R2

Fixes: caa09f66ae4 - amd: add chip identification for gfx1100-1103

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index d89fef9613db..211d4bce7adf 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -3323,6 +3323,11 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
                            S_028C78_DISABLE_CONSTANT_ENCODE_REG(1) |
                            S_028C78_FDCC_ENABLE(vi_dcc_enabled(tex, cb->base.u.tex.level));
 
+         if (sctx->family >= CHIP_GFX1103_R2) {
+            cb_fdcc_control |= S_028C78_ENABLE_MAX_COMP_FRAG_OVERRIDE(1) |
+                               S_028C78_MAX_COMP_FRAGS(cb->base.texture->nr_samples >= 4);
+         }
+
          radeon_set_context_reg_seq(R_028C6C_CB_COLOR0_VIEW + i * 0x3C, 4);
          radeon_emit(cb->cb_color_view);                      /* CB_COLOR0_VIEW */
          radeon_emit(cb_color_info);                          /* CB_COLOR0_INFO */
-- 
GitLab


From 38bcb8e0fa002864d8ae094554b771b823e3038b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 17 Feb 2023 22:09:34 -0500
Subject: [PATCH 08/45] radeonsi: move a few DB_SHADER_CONTROL states into
 si_shader_ps

They can be set si_shader_ps.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c           | 9 ---------
 src/gallium/drivers/radeonsi/si_state_draw.cpp    | 3 +--
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 9 +++++++++
 3 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 211d4bce7adf..72d39b5966b4 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -1593,19 +1593,10 @@ static void si_emit_db_render_state(struct si_context *sctx)
 
    db_shader_control = sctx->ps_db_shader_control;
 
-   /* Bug workaround for smoothing (overrasterization) on GFX6. */
-   if (sctx->gfx_level == GFX6 && sctx->smoothing_enabled) {
-      db_shader_control &= C_02880C_Z_ORDER;
-      db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z);
-   }
-
    /* Disable the gl_SampleMask fragment shader output if MSAA is disabled. */
    if (!rs->multisample_enable)
       db_shader_control &= C_02880C_MASK_EXPORT_ENABLE;
 
-   if (sctx->screen->info.has_rbplus && !sctx->screen->info.rbplus_allowed)
-      db_shader_control |= S_02880C_DUAL_QUAD_DISABLE(1);
-
    if (sctx->screen->info.has_export_conflict_bug &&
        sctx->queued.named.blend->blend_enable_4bit &&
        si_get_num_coverage_samples(sctx) == 1) {
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 25c403a83be3..062b78dd2942 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -296,8 +296,7 @@ static bool si_update_shaders(struct si_context *sctx)
       if (GFX_VERSION >= GFX10 && sctx->screen->use_ngg_culling)
          si_mark_atom_dirty(sctx, &sctx->atoms.s.ngg_cull_state);
 
-      if (GFX_VERSION == GFX6 ||
-          (GFX_VERSION == GFX11 && sctx->screen->info.has_export_conflict_bug))
+      if (GFX_VERSION == GFX11 && sctx->screen->info.has_export_conflict_bug)
          si_mark_atom_dirty(sctx, &sctx->atoms.s.db_render_state);
 
       if (sctx->framebuffer.nr_samples <= 1)
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 6658d66cd8d8..c170d0696191 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -1919,6 +1919,15 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
    if (info->base.fs.post_depth_coverage)
       db_shader_control |= S_02880C_PRE_SHADER_DEPTH_COVERAGE_ENABLE(1);
 
+   /* Bug workaround for smoothing (overrasterization) on GFX6. */
+   if (sscreen->info.gfx_level == GFX6 && shader->key.ps.mono.poly_line_smoothing) {
+      db_shader_control &= C_02880C_Z_ORDER;
+      db_shader_control |= S_02880C_Z_ORDER(V_02880C_LATE_Z);
+   }
+
+   if (sscreen->info.has_rbplus && !sscreen->info.rbplus_allowed)
+      db_shader_control |= S_02880C_DUAL_QUAD_DISABLE(1);
+
    shader->ctx_reg.ps.db_shader_control = db_shader_control;
 
    pm4 = si_get_shader_pm4_state(shader);
-- 
GitLab


From 47e167f10b862530b4bdc3257275dd9eb5410ca0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 17 Feb 2023 22:20:44 -0500
Subject: [PATCH 09/45] radeonsi: change si_shader::ctx_reg to a nameless union
 for better readability

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_shader.h      |  21 +-
 .../drivers/radeonsi/si_state_draw.cpp        |   8 +-
 .../drivers/radeonsi/si_state_shaders.cpp     | 218 +++++++++---------
 3 files changed, 123 insertions(+), 124 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index e8c8f2450223..9f068057ae66 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -870,15 +870,6 @@ struct si_shader {
 
    bool uses_base_instance;
 
-   struct {
-      uint16_t ngg_emit_size; /* in dwords */
-      uint16_t hw_max_esverts;
-      uint16_t max_gsprims;
-      uint16_t max_out_verts;
-      uint16_t prim_amp_factor;
-      bool max_vert_out_per_gs_instance;
-   } ngg;
-
    /* Shader key + LLVM IR + disassembly + statistics.
     * Generated for debug contexts only.
     */
@@ -908,6 +899,14 @@ struct si_shader {
       } gs;
 
       struct {
+         /* Computed by gfx10_ngg_calculate_subgroup_info. */
+         uint16_t ngg_emit_size; /* in dwords */
+         uint16_t hw_max_esverts;
+         uint16_t max_gsprims;
+         uint16_t max_out_verts;
+         uint16_t prim_amp_factor;
+         bool max_vert_out_per_gs_instance;
+         /* Register values. */
          unsigned ge_max_output_per_subgroup;
          unsigned ge_ngg_subgrp_cntl;
          unsigned vgt_primitiveid_en;
@@ -947,9 +946,9 @@ struct si_shader {
          unsigned db_shader_control;
          unsigned num_interp;
       } ps;
-   } ctx_reg;
+   };
 
-   /*For save precompute registers value */
+   /* Precomputed register values. */
    unsigned vgt_tf_param;                /* VGT_TF_PARAM */
    unsigned vgt_vertex_reuse_block_cntl; /* VGT_VERTEX_REUSE_BLOCK_CNTL */
    unsigned pa_cl_vs_out_cntl;
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 062b78dd2942..6e2e7836d6bb 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -236,7 +236,7 @@ static bool si_update_shaders(struct si_context *sctx)
    if (HAS_GS)
       key.u.gs = 1;
    if (NGG) {
-      key.index |= si_get_vs_inline(sctx, HAS_TESS, HAS_GS)->current->ctx_reg.ngg.vgt_stages.index;
+      key.index |= si_get_vs_inline(sctx, HAS_TESS, HAS_GS)->current->ngg.vgt_stages.index;
    } else if (GFX_VERSION >= GFX10) {
       if (HAS_GS) {
          key.u.gs_wave32 = sctx->shader.gs.current->wave_size == 32;
@@ -266,7 +266,7 @@ static bool si_update_shaders(struct si_context *sctx)
       return false;
    si_pm4_bind_state(sctx, ps, sctx->shader.ps.current);
 
-   unsigned db_shader_control = sctx->shader.ps.current->ctx_reg.ps.db_shader_control;
+   unsigned db_shader_control = sctx->shader.ps.current->ps.db_shader_control;
    if (sctx->ps_db_shader_control != db_shader_control) {
       sctx->ps_db_shader_control = db_shader_control;
       si_mark_atom_dirty(sctx, &sctx->atoms.s.db_render_state);
@@ -277,7 +277,7 @@ static bool si_update_shaders(struct si_context *sctx)
    if (si_pm4_state_changed(sctx, ps) ||
        (!NGG && si_pm4_state_changed(sctx, vs)) ||
        (NGG && si_pm4_state_changed(sctx, gs))) {
-      sctx->atoms.s.spi_map.emit = sctx->emit_spi_map[sctx->shader.ps.current->ctx_reg.ps.num_interp];
+      sctx->atoms.s.spi_map.emit = sctx->emit_spi_map[sctx->shader.ps.current->ps.num_interp];
       si_mark_atom_dirty(sctx, &sctx->atoms.s.spi_map);
    }
 
@@ -1316,7 +1316,7 @@ static void gfx10_emit_ge_cntl(struct si_context *sctx, unsigned num_patches)
          primgroup_size = num_patches; /* must be a multiple of NUM_PATCHES */
          vertgroup_size = 0;
       } else if (HAS_GS) {
-         unsigned vgt_gs_onchip_cntl = sctx->shader.gs.current->ctx_reg.gs.vgt_gs_onchip_cntl;
+         unsigned vgt_gs_onchip_cntl = sctx->shader.gs.current->gs.vgt_gs_onchip_cntl;
          primgroup_size = G_028A44_GS_PRIMS_PER_SUBGRP(vgt_gs_onchip_cntl);
          vertgroup_size = G_028A44_ES_VERTS_PER_SUBGRP(vgt_gs_onchip_cntl);
       } else {
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index c170d0696191..4cf1bc906eaa 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -936,41 +936,41 @@ static void si_emit_shader_gs(struct si_context *sctx)
     * R_028A68_VGT_GSVS_RING_OFFSET_3 */
    radeon_opt_set_context_reg3(
       sctx, R_028A60_VGT_GSVS_RING_OFFSET_1, SI_TRACKED_VGT_GSVS_RING_OFFSET_1,
-      shader->ctx_reg.gs.vgt_gsvs_ring_offset_1, shader->ctx_reg.gs.vgt_gsvs_ring_offset_2,
-      shader->ctx_reg.gs.vgt_gsvs_ring_offset_3);
+      shader->gs.vgt_gsvs_ring_offset_1, shader->gs.vgt_gsvs_ring_offset_2,
+      shader->gs.vgt_gsvs_ring_offset_3);
 
    /* R_028AB0_VGT_GSVS_RING_ITEMSIZE */
    radeon_opt_set_context_reg(sctx, R_028AB0_VGT_GSVS_RING_ITEMSIZE,
                               SI_TRACKED_VGT_GSVS_RING_ITEMSIZE,
-                              shader->ctx_reg.gs.vgt_gsvs_ring_itemsize);
+                              shader->gs.vgt_gsvs_ring_itemsize);
 
    /* R_028B38_VGT_GS_MAX_VERT_OUT */
    radeon_opt_set_context_reg(sctx, R_028B38_VGT_GS_MAX_VERT_OUT, SI_TRACKED_VGT_GS_MAX_VERT_OUT,
-                              shader->ctx_reg.gs.vgt_gs_max_vert_out);
+                              shader->gs.vgt_gs_max_vert_out);
 
    /* R_028B5C_VGT_GS_VERT_ITEMSIZE, R_028B60_VGT_GS_VERT_ITEMSIZE_1
     * R_028B64_VGT_GS_VERT_ITEMSIZE_2, R_028B68_VGT_GS_VERT_ITEMSIZE_3 */
    radeon_opt_set_context_reg4(
       sctx, R_028B5C_VGT_GS_VERT_ITEMSIZE, SI_TRACKED_VGT_GS_VERT_ITEMSIZE,
-      shader->ctx_reg.gs.vgt_gs_vert_itemsize, shader->ctx_reg.gs.vgt_gs_vert_itemsize_1,
-      shader->ctx_reg.gs.vgt_gs_vert_itemsize_2, shader->ctx_reg.gs.vgt_gs_vert_itemsize_3);
+      shader->gs.vgt_gs_vert_itemsize, shader->gs.vgt_gs_vert_itemsize_1,
+      shader->gs.vgt_gs_vert_itemsize_2, shader->gs.vgt_gs_vert_itemsize_3);
 
    /* R_028B90_VGT_GS_INSTANCE_CNT */
    radeon_opt_set_context_reg(sctx, R_028B90_VGT_GS_INSTANCE_CNT, SI_TRACKED_VGT_GS_INSTANCE_CNT,
-                              shader->ctx_reg.gs.vgt_gs_instance_cnt);
+                              shader->gs.vgt_gs_instance_cnt);
 
    if (sctx->gfx_level >= GFX9) {
       /* R_028A44_VGT_GS_ONCHIP_CNTL */
       radeon_opt_set_context_reg(sctx, R_028A44_VGT_GS_ONCHIP_CNTL, SI_TRACKED_VGT_GS_ONCHIP_CNTL,
-                                 shader->ctx_reg.gs.vgt_gs_onchip_cntl);
+                                 shader->gs.vgt_gs_onchip_cntl);
       /* R_028A94_VGT_GS_MAX_PRIMS_PER_SUBGROUP */
       radeon_opt_set_context_reg(sctx, R_028A94_VGT_GS_MAX_PRIMS_PER_SUBGROUP,
                                  SI_TRACKED_VGT_GS_MAX_PRIMS_PER_SUBGROUP,
-                                 shader->ctx_reg.gs.vgt_gs_max_prims_per_subgroup);
+                                 shader->gs.vgt_gs_max_prims_per_subgroup);
       /* R_028AAC_VGT_ESGS_RING_ITEMSIZE */
       radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
                                  SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                                 shader->ctx_reg.gs.vgt_esgs_ring_itemsize);
+                                 shader->gs.vgt_esgs_ring_itemsize);
 
       if (shader->key.ge.part.gs.es->stage == MESA_SHADER_TESS_EVAL)
          radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
@@ -986,7 +986,7 @@ static void si_emit_shader_gs(struct si_context *sctx)
    if (sctx->screen->info.spi_cu_en_has_effect) {
       if (sctx->gfx_level >= GFX7) {
          ac_set_reg_cu_en(&sctx->gfx_cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                          shader->ctx_reg.gs.spi_shader_pgm_rsrc3_gs,
+                          shader->gs.spi_shader_pgm_rsrc3_gs,
                           C_00B21C_CU_EN, 0, &sctx->screen->info,
                           (void (*)(void*, unsigned, uint32_t))
                           (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
@@ -994,7 +994,7 @@ static void si_emit_shader_gs(struct si_context *sctx)
       }
       if (sctx->gfx_level >= GFX10) {
          ac_set_reg_cu_en(&sctx->gfx_cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                          shader->ctx_reg.gs.spi_shader_pgm_rsrc4_gs,
+                          shader->gs.spi_shader_pgm_rsrc4_gs,
                           C_00B204_CU_EN_GFX10, 16, &sctx->screen->info,
                           (void (*)(void*, unsigned, uint32_t))
                           (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
@@ -1005,12 +1005,12 @@ static void si_emit_shader_gs(struct si_context *sctx)
       if (sctx->gfx_level >= GFX7) {
          radeon_opt_set_sh_reg_idx3(sctx, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
                                     SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS,
-                                    shader->ctx_reg.gs.spi_shader_pgm_rsrc3_gs);
+                                    shader->gs.spi_shader_pgm_rsrc3_gs);
       }
       if (sctx->gfx_level >= GFX10) {
          radeon_opt_set_sh_reg_idx3(sctx, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
                                     SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS,
-                                    shader->ctx_reg.gs.spi_shader_pgm_rsrc4_gs);
+                                    shader->gs.spi_shader_pgm_rsrc4_gs);
       }
       radeon_end();
    }
@@ -1035,31 +1035,31 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
    pm4->atom.emit = si_emit_shader_gs;
 
    offset = num_components[0] * sel->info.base.gs.vertices_out;
-   shader->ctx_reg.gs.vgt_gsvs_ring_offset_1 = offset;
+   shader->gs.vgt_gsvs_ring_offset_1 = offset;
 
    if (max_stream >= 2)
       offset += num_components[1] * sel->info.base.gs.vertices_out;
-   shader->ctx_reg.gs.vgt_gsvs_ring_offset_2 = offset;
+   shader->gs.vgt_gsvs_ring_offset_2 = offset;
 
    if (max_stream >= 3)
       offset += num_components[2] * sel->info.base.gs.vertices_out;
-   shader->ctx_reg.gs.vgt_gsvs_ring_offset_3 = offset;
+   shader->gs.vgt_gsvs_ring_offset_3 = offset;
 
    if (max_stream >= 4)
       offset += num_components[3] * sel->info.base.gs.vertices_out;
-   shader->ctx_reg.gs.vgt_gsvs_ring_itemsize = offset;
+   shader->gs.vgt_gsvs_ring_itemsize = offset;
 
    /* The GSVS_RING_ITEMSIZE register takes 15 bits */
    assert(offset < (1 << 15));
 
-   shader->ctx_reg.gs.vgt_gs_max_vert_out = sel->info.base.gs.vertices_out;
+   shader->gs.vgt_gs_max_vert_out = sel->info.base.gs.vertices_out;
 
-   shader->ctx_reg.gs.vgt_gs_vert_itemsize = num_components[0];
-   shader->ctx_reg.gs.vgt_gs_vert_itemsize_1 = (max_stream >= 2) ? num_components[1] : 0;
-   shader->ctx_reg.gs.vgt_gs_vert_itemsize_2 = (max_stream >= 3) ? num_components[2] : 0;
-   shader->ctx_reg.gs.vgt_gs_vert_itemsize_3 = (max_stream >= 4) ? num_components[3] : 0;
+   shader->gs.vgt_gs_vert_itemsize = num_components[0];
+   shader->gs.vgt_gs_vert_itemsize_1 = (max_stream >= 2) ? num_components[1] : 0;
+   shader->gs.vgt_gs_vert_itemsize_2 = (max_stream >= 3) ? num_components[2] : 0;
+   shader->gs.vgt_gs_vert_itemsize_3 = (max_stream >= 4) ? num_components[3] : 0;
 
-   shader->ctx_reg.gs.vgt_gs_instance_cnt =
+   shader->gs.vgt_gs_instance_cnt =
       S_028B90_CNT(MIN2(gs_num_invocations, 127)) | S_028B90_ENABLE(gs_num_invocations > 0);
 
    /* Copy over fields from the GS copy shader to make them easily accessible from GS. */
@@ -1125,27 +1125,27 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
       si_pm4_set_reg(pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS, rsrc1);
       si_pm4_set_reg(pm4, R_00B22C_SPI_SHADER_PGM_RSRC2_GS, rsrc2);
 
-      shader->ctx_reg.gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
-                                                   S_00B21C_WAVE_LIMIT(0x3F);
-      shader->ctx_reg.gs.spi_shader_pgm_rsrc4_gs =
+      shader->gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
+                                           S_00B21C_WAVE_LIMIT(0x3F);
+      shader->gs.spi_shader_pgm_rsrc4_gs =
          (sscreen->info.gfx_level >= GFX11 ? S_00B204_CU_EN_GFX11(1) : S_00B204_CU_EN_GFX10(0xffff)) |
          S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0);
 
-      shader->ctx_reg.gs.vgt_gs_onchip_cntl =
+      shader->gs.vgt_gs_onchip_cntl =
          S_028A44_ES_VERTS_PER_SUBGRP(shader->gs_info.es_verts_per_subgroup) |
          S_028A44_GS_PRIMS_PER_SUBGRP(shader->gs_info.gs_prims_per_subgroup) |
          S_028A44_GS_INST_PRIMS_IN_SUBGRP(shader->gs_info.gs_inst_prims_in_subgroup);
-      shader->ctx_reg.gs.vgt_gs_max_prims_per_subgroup =
+      shader->gs.vgt_gs_max_prims_per_subgroup =
          S_028A94_MAX_PRIMS_PER_SUBGROUP(shader->gs_info.max_prims_per_subgroup);
-      shader->ctx_reg.gs.vgt_esgs_ring_itemsize = shader->key.ge.part.gs.es->info.esgs_itemsize / 4;
+      shader->gs.vgt_esgs_ring_itemsize = shader->key.ge.part.gs.es->info.esgs_itemsize / 4;
 
       if (es_stage == MESA_SHADER_TESS_EVAL)
          si_set_tesseval_regs(sscreen, shader->key.ge.part.gs.es, shader);
 
       polaris_set_vgt_vertex_reuse(sscreen, shader->key.ge.part.gs.es, shader);
    } else {
-      shader->ctx_reg.gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
-                                                   S_00B21C_WAVE_LIMIT(0x3F);
+      shader->gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
+                                           S_00B21C_WAVE_LIMIT(0x3F);
 
       si_pm4_set_reg(pm4, R_00B220_SPI_SHADER_PGM_LO_GS, va >> 8);
       pm4->reg_va_low_idx = pm4->ndw - 1;
@@ -1189,45 +1189,45 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_0287FC_GE_MAX_OUTPUT_PER_SUBGROUP,
                               SI_TRACKED_GE_MAX_OUTPUT_PER_SUBGROUP,
-                              shader->ctx_reg.ngg.ge_max_output_per_subgroup);
+                              shader->ngg.ge_max_output_per_subgroup);
    radeon_opt_set_context_reg(sctx, R_028B4C_GE_NGG_SUBGRP_CNTL, SI_TRACKED_GE_NGG_SUBGRP_CNTL,
-                              shader->ctx_reg.ngg.ge_ngg_subgrp_cntl);
+                              shader->ngg.ge_ngg_subgrp_cntl);
    radeon_opt_set_context_reg(sctx, R_028A84_VGT_PRIMITIVEID_EN, SI_TRACKED_VGT_PRIMITIVEID_EN,
-                              shader->ctx_reg.ngg.vgt_primitiveid_en);
+                              shader->ngg.vgt_primitiveid_en);
    if (sctx->gfx_level < GFX11) {
       radeon_opt_set_context_reg(sctx, R_028A44_VGT_GS_ONCHIP_CNTL, SI_TRACKED_VGT_GS_ONCHIP_CNTL,
-                                 shader->ctx_reg.ngg.vgt_gs_onchip_cntl);
+                                 shader->ngg.vgt_gs_onchip_cntl);
    }
    radeon_opt_set_context_reg(sctx, R_028B90_VGT_GS_INSTANCE_CNT, SI_TRACKED_VGT_GS_INSTANCE_CNT,
-                              shader->ctx_reg.ngg.vgt_gs_instance_cnt);
+                              shader->ngg.vgt_gs_instance_cnt);
    radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
                               SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                              shader->ctx_reg.ngg.vgt_esgs_ring_itemsize);
+                              shader->ngg.vgt_esgs_ring_itemsize);
    radeon_opt_set_context_reg(sctx, R_0286C4_SPI_VS_OUT_CONFIG, SI_TRACKED_SPI_VS_OUT_CONFIG,
-                              shader->ctx_reg.ngg.spi_vs_out_config);
+                              shader->ngg.spi_vs_out_config);
    radeon_opt_set_context_reg2(
       sctx, R_028708_SPI_SHADER_IDX_FORMAT, SI_TRACKED_SPI_SHADER_IDX_FORMAT,
-      shader->ctx_reg.ngg.spi_shader_idx_format, shader->ctx_reg.ngg.spi_shader_pos_format);
+      shader->ngg.spi_shader_idx_format, shader->ngg.spi_shader_pos_format);
    radeon_opt_set_context_reg(sctx, R_028818_PA_CL_VTE_CNTL, SI_TRACKED_PA_CL_VTE_CNTL,
-                              shader->ctx_reg.ngg.pa_cl_vte_cntl);
+                              shader->ngg.pa_cl_vte_cntl);
    radeon_opt_set_context_reg(sctx, R_028838_PA_CL_NGG_CNTL, SI_TRACKED_PA_CL_NGG_CNTL,
-                              shader->ctx_reg.ngg.pa_cl_ngg_cntl);
+                              shader->ngg.pa_cl_ngg_cntl);
 
    radeon_end_update_context_roll(sctx);
 
    /* These don't cause a context roll. */
    radeon_begin_again(&sctx->gfx_cs);
    radeon_opt_set_uconfig_reg(sctx, R_030980_GE_PC_ALLOC, SI_TRACKED_GE_PC_ALLOC,
-                              shader->ctx_reg.ngg.ge_pc_alloc);
+                              shader->ngg.ge_pc_alloc);
    if (sctx->screen->info.spi_cu_en_has_effect) {
       radeon_end();
       ac_set_reg_cu_en(&sctx->gfx_cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                       shader->ctx_reg.ngg.spi_shader_pgm_rsrc3_gs,
+                       shader->ngg.spi_shader_pgm_rsrc3_gs,
                        C_00B21C_CU_EN, 0, &sctx->screen->info,
                        (void (*)(void*, unsigned, uint32_t))
                        (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
       ac_set_reg_cu_en(&sctx->gfx_cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                       shader->ctx_reg.ngg.spi_shader_pgm_rsrc4_gs,
+                       shader->ngg.spi_shader_pgm_rsrc4_gs,
                        sctx->gfx_level >= GFX11 ? C_00B204_CU_EN_GFX11 : C_00B204_CU_EN_GFX10, 16,
                        &sctx->screen->info,
                        (void (*)(void*, unsigned, uint32_t))
@@ -1237,10 +1237,10 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
    } else {
       radeon_opt_set_sh_reg_idx3(sctx, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
                                  SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS,
-                                 shader->ctx_reg.ngg.spi_shader_pgm_rsrc3_gs);
+                                 shader->ngg.spi_shader_pgm_rsrc3_gs);
       radeon_opt_set_sh_reg_idx3(sctx, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
                                  SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS,
-                                 shader->ctx_reg.ngg.spi_shader_pgm_rsrc4_gs);
+                                 shader->ngg.spi_shader_pgm_rsrc4_gs);
       radeon_end();
    }
 }
@@ -1276,7 +1276,7 @@ static void gfx10_emit_shader_ngg_notess_gs(struct si_context *sctx)
 
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_028B38_VGT_GS_MAX_VERT_OUT, SI_TRACKED_VGT_GS_MAX_VERT_OUT,
-                              shader->ctx_reg.ngg.vgt_gs_max_vert_out);
+                              shader->ngg.vgt_gs_max_vert_out);
    radeon_end_update_context_roll(sctx);
 
    gfx10_emit_shader_ngg_tail(sctx, shader);
@@ -1291,7 +1291,7 @@ static void gfx10_emit_shader_ngg_tess_gs(struct si_context *sctx)
 
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_028B38_VGT_GS_MAX_VERT_OUT, SI_TRACKED_VGT_GS_MAX_VERT_OUT,
-                              shader->ctx_reg.ngg.vgt_gs_max_vert_out);
+                              shader->ngg.vgt_gs_max_vert_out);
    radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
                               shader->vgt_tf_param);
    radeon_end_update_context_roll(sctx);
@@ -1440,25 +1440,25 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                      S_00B22C_OC_LDS_EN(es_stage == MESA_SHADER_TESS_EVAL) |
                      S_00B22C_LDS_SIZE(shader->config.lds_size));
 
-   shader->ctx_reg.ngg.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(cu_mask) |
-                                                 S_00B21C_WAVE_LIMIT(0x3F);
+   shader->ngg.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(cu_mask) |
+                                         S_00B21C_WAVE_LIMIT(0x3F);
    if (sscreen->info.gfx_level >= GFX11) {
-      shader->ctx_reg.ngg.spi_shader_pgm_rsrc4_gs =
+      shader->ngg.spi_shader_pgm_rsrc4_gs =
          S_00B204_CU_EN_GFX11(0x1) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64) |
          S_00B204_INST_PREF_SIZE(si_get_shader_prefetch_size(shader));
    } else {
-      shader->ctx_reg.ngg.spi_shader_pgm_rsrc4_gs =
+      shader->ngg.spi_shader_pgm_rsrc4_gs =
          S_00B204_CU_EN_GFX10(0xffff) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64);
    }
 
    nparams = MAX2(shader->info.nr_param_exports, 1);
-   shader->ctx_reg.ngg.spi_vs_out_config =
+   shader->ngg.spi_vs_out_config =
       S_0286C4_VS_EXPORT_COUNT(nparams - 1) |
       S_0286C4_NO_PC_EXPORT(shader->info.nr_param_exports == 0);
 
-   shader->ctx_reg.ngg.spi_shader_idx_format =
+   shader->ngg.spi_shader_idx_format =
       S_028708_IDX0_EXPORT_FORMAT(V_028708_SPI_SHADER_1COMP);
-   shader->ctx_reg.ngg.spi_shader_pos_format =
+   shader->ngg.spi_shader_pos_format =
       S_02870C_POS0_EXPORT_FORMAT(V_02870C_SPI_SHADER_4COMP) |
       S_02870C_POS1_EXPORT_FORMAT(shader->info.nr_pos_exports > 1 ? V_02870C_SPI_SHADER_4COMP
                                                                   : V_02870C_SPI_SHADER_NONE) |
@@ -1467,26 +1467,26 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
       S_02870C_POS3_EXPORT_FORMAT(shader->info.nr_pos_exports > 3 ? V_02870C_SPI_SHADER_4COMP
                                                                   : V_02870C_SPI_SHADER_NONE);
 
-   shader->ctx_reg.ngg.vgt_primitiveid_en =
+   shader->ngg.vgt_primitiveid_en =
       S_028A84_PRIMITIVEID_EN(es_enable_prim_id) |
       S_028A84_NGG_DISABLE_PROVOK_REUSE(shader->key.ge.mono.u.vs_export_prim_id ||
                                         gs_sel->info.writes_primid);
 
    if (gs_stage == MESA_SHADER_GEOMETRY) {
-      shader->ctx_reg.ngg.vgt_esgs_ring_itemsize = es_sel->info.esgs_itemsize / 4;
-      shader->ctx_reg.ngg.vgt_gs_max_vert_out = gs_sel->info.base.gs.vertices_out;
+      shader->ngg.vgt_esgs_ring_itemsize = es_sel->info.esgs_itemsize / 4;
+      shader->ngg.vgt_gs_max_vert_out = gs_sel->info.base.gs.vertices_out;
    } else {
-      shader->ctx_reg.ngg.vgt_esgs_ring_itemsize = 1;
+      shader->ngg.vgt_esgs_ring_itemsize = 1;
    }
 
    if (es_stage == MESA_SHADER_TESS_EVAL)
       si_set_tesseval_regs(sscreen, es_sel, shader);
 
-   shader->ctx_reg.ngg.ge_max_output_per_subgroup =
+   shader->ngg.ge_max_output_per_subgroup =
       S_0287FC_MAX_VERTS_PER_SUBGROUP(shader->ngg.max_out_verts);
-   shader->ctx_reg.ngg.ge_ngg_subgrp_cntl = S_028B4C_PRIM_AMP_FACTOR(shader->ngg.prim_amp_factor) |
-                                            S_028B4C_THDS_PER_SUBGRP(0); /* for fast launch */
-   shader->ctx_reg.ngg.vgt_gs_instance_cnt =
+   shader->ngg.ge_ngg_subgrp_cntl = S_028B4C_PRIM_AMP_FACTOR(shader->ngg.prim_amp_factor) |
+                                    S_028B4C_THDS_PER_SUBGRP(0); /* for fast launch */
+   shader->ngg.vgt_gs_instance_cnt =
       S_028B90_CNT(gs_num_invocations) | S_028B90_ENABLE(gs_num_invocations > 1) |
       S_028B90_EN_MAX_VERT_OUT_PER_GS_INSTANCE(shader->ngg.max_vert_out_per_gs_instance);
 
@@ -1494,7 +1494,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
     * export to prevent drawing lines on internal edges of decomposed
     * primitives (such as quads) with polygon mode = lines.
     */
-   shader->ctx_reg.ngg.pa_cl_ngg_cntl =
+   shader->ngg.pa_cl_ngg_cntl =
       S_028838_INDEX_BUF_EDGE_FLAG_ENA(gfx10_edgeflags_have_effect(shader)) |
       /* Reuse for NGG. */
       S_028838_VERTEX_REUSE_DEPTH(sscreen->info.gfx_level >= GFX10_3 ? 30 : 0);
@@ -1515,8 +1515,8 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
 
    unsigned oversub_pc_lines =
       late_alloc_wave64 ? (sscreen->info.pc_lines / 4) * oversub_pc_factor : 0;
-   shader->ctx_reg.ngg.ge_pc_alloc = S_030980_OVERSUB_EN(oversub_pc_lines > 0) |
-                                     S_030980_NUM_PC_LINES(oversub_pc_lines - 1);
+   shader->ngg.ge_pc_alloc = S_030980_OVERSUB_EN(oversub_pc_lines > 0) |
+                             S_030980_NUM_PC_LINES(oversub_pc_lines - 1);
 
    if (sscreen->info.gfx_level >= GFX11) {
       shader->ge_cntl = S_03096C_PRIMS_PER_SUBGRP(shader->ngg.max_gsprims) |
@@ -1531,7 +1531,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                         S_03096C_VERT_GRP_SIZE(shader->ngg.hw_max_esverts) |
                         S_03096C_BREAK_WAVE_AT_EOI(break_wave_at_eoi);
 
-      shader->ctx_reg.ngg.vgt_gs_onchip_cntl =
+      shader->ngg.vgt_gs_onchip_cntl =
          S_028A44_ES_VERTS_PER_SUBGRP(shader->ngg.hw_max_esverts) |
          S_028A44_GS_PRIMS_PER_SUBGRP(shader->ngg.max_gsprims) |
          S_028A44_GS_INST_PRIMS_IN_SUBGRP(shader->ngg.max_gsprims * gs_num_invocations);
@@ -1557,18 +1557,18 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
    }
 
    if (window_space) {
-      shader->ctx_reg.ngg.pa_cl_vte_cntl = S_028818_VTX_XY_FMT(1) | S_028818_VTX_Z_FMT(1);
+      shader->ngg.pa_cl_vte_cntl = S_028818_VTX_XY_FMT(1) | S_028818_VTX_Z_FMT(1);
    } else {
-      shader->ctx_reg.ngg.pa_cl_vte_cntl =
+      shader->ngg.pa_cl_vte_cntl =
          S_028818_VTX_W0_FMT(1) | S_028818_VPORT_X_SCALE_ENA(1) | S_028818_VPORT_X_OFFSET_ENA(1) |
          S_028818_VPORT_Y_SCALE_ENA(1) | S_028818_VPORT_Y_OFFSET_ENA(1) |
          S_028818_VPORT_Z_SCALE_ENA(1) | S_028818_VPORT_Z_OFFSET_ENA(1);
    }
 
-   shader->ctx_reg.ngg.vgt_stages.u.ngg = 1;
-   shader->ctx_reg.ngg.vgt_stages.u.streamout = si_shader_uses_streamout(shader);
-   shader->ctx_reg.ngg.vgt_stages.u.ngg_passthrough = gfx10_is_ngg_passthrough(shader);
-   shader->ctx_reg.ngg.vgt_stages.u.gs_wave32 = shader->wave_size == 32;
+   shader->ngg.vgt_stages.u.ngg = 1;
+   shader->ngg.vgt_stages.u.streamout = si_shader_uses_streamout(shader);
+   shader->ngg.vgt_stages.u.ngg_passthrough = gfx10_is_ngg_passthrough(shader);
+   shader->ngg.vgt_stages.u.gs_wave32 = shader->wave_size == 32;
 }
 
 static void si_emit_shader_vs(struct si_context *sctx)
@@ -1579,24 +1579,24 @@ static void si_emit_shader_vs(struct si_context *sctx)
 
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_028A40_VGT_GS_MODE, SI_TRACKED_VGT_GS_MODE,
-                              shader->ctx_reg.vs.vgt_gs_mode);
+                              shader->vs.vgt_gs_mode);
    radeon_opt_set_context_reg(sctx, R_028A84_VGT_PRIMITIVEID_EN, SI_TRACKED_VGT_PRIMITIVEID_EN,
-                              shader->ctx_reg.vs.vgt_primitiveid_en);
+                              shader->vs.vgt_primitiveid_en);
 
    if (sctx->gfx_level <= GFX8) {
       radeon_opt_set_context_reg(sctx, R_028AB4_VGT_REUSE_OFF, SI_TRACKED_VGT_REUSE_OFF,
-                                 shader->ctx_reg.vs.vgt_reuse_off);
+                                 shader->vs.vgt_reuse_off);
    }
 
    radeon_opt_set_context_reg(sctx, R_0286C4_SPI_VS_OUT_CONFIG, SI_TRACKED_SPI_VS_OUT_CONFIG,
-                              shader->ctx_reg.vs.spi_vs_out_config);
+                              shader->vs.spi_vs_out_config);
 
    radeon_opt_set_context_reg(sctx, R_02870C_SPI_SHADER_POS_FORMAT,
                               SI_TRACKED_SPI_SHADER_POS_FORMAT,
-                              shader->ctx_reg.vs.spi_shader_pos_format);
+                              shader->vs.spi_shader_pos_format);
 
    radeon_opt_set_context_reg(sctx, R_028818_PA_CL_VTE_CNTL, SI_TRACKED_PA_CL_VTE_CNTL,
-                              shader->ctx_reg.vs.pa_cl_vte_cntl);
+                              shader->vs.pa_cl_vte_cntl);
 
    if (shader->selector->stage == MESA_SHADER_TESS_EVAL)
       radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
@@ -1622,7 +1622,7 @@ static void si_emit_shader_vs(struct si_context *sctx)
    if (sctx->gfx_level >= GFX10) {
       radeon_begin_again(&sctx->gfx_cs);
       radeon_opt_set_uconfig_reg(sctx, R_030980_GE_PC_ALLOC, SI_TRACKED_GE_PC_ALLOC,
-                                 shader->ctx_reg.vs.ge_pc_alloc);
+                                 shader->vs.ge_pc_alloc);
       radeon_end();
    }
 }
@@ -1668,17 +1668,17 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
       if (enable_prim_id)
          mode = V_028A40_GS_SCENARIO_A;
 
-      shader->ctx_reg.vs.vgt_gs_mode = S_028A40_MODE(mode);
-      shader->ctx_reg.vs.vgt_primitiveid_en = enable_prim_id;
+      shader->vs.vgt_gs_mode = S_028A40_MODE(mode);
+      shader->vs.vgt_primitiveid_en = enable_prim_id;
    } else {
-      shader->ctx_reg.vs.vgt_gs_mode =
+      shader->vs.vgt_gs_mode =
          ac_vgt_gs_mode(gs->info.base.gs.vertices_out, sscreen->info.gfx_level);
-      shader->ctx_reg.vs.vgt_primitiveid_en = 0;
+      shader->vs.vgt_primitiveid_en = 0;
    }
 
    if (sscreen->info.gfx_level <= GFX8) {
       /* Reuse needs to be set off if we write oViewport. */
-      shader->ctx_reg.vs.vgt_reuse_off = S_028AB4_REUSE_OFF(info->writes_viewport_index);
+      shader->vs.vgt_reuse_off = S_028AB4_REUSE_OFF(info->writes_viewport_index);
    }
 
    va = shader->bo->gpu_address;
@@ -1702,14 +1702,14 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
 
    /* VS is required to export at least one param. */
    nparams = MAX2(shader->info.nr_param_exports, 1);
-   shader->ctx_reg.vs.spi_vs_out_config = S_0286C4_VS_EXPORT_COUNT(nparams - 1);
+   shader->vs.spi_vs_out_config = S_0286C4_VS_EXPORT_COUNT(nparams - 1);
 
    if (sscreen->info.gfx_level >= GFX10) {
-      shader->ctx_reg.vs.spi_vs_out_config |=
+      shader->vs.spi_vs_out_config |=
          S_0286C4_NO_PC_EXPORT(shader->info.nr_param_exports == 0);
    }
 
-   shader->ctx_reg.vs.spi_shader_pos_format =
+   shader->vs.spi_shader_pos_format =
       S_02870C_POS0_EXPORT_FORMAT(V_02870C_SPI_SHADER_4COMP) |
       S_02870C_POS1_EXPORT_FORMAT(shader->info.nr_pos_exports > 1 ? V_02870C_SPI_SHADER_4COMP
                                                                   : V_02870C_SPI_SHADER_NONE) |
@@ -1722,8 +1722,8 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
                          shader->config.scratch_bytes_per_wave > 0,
                          &late_alloc_wave64, &cu_mask);
 
-   shader->ctx_reg.vs.ge_pc_alloc = S_030980_OVERSUB_EN(late_alloc_wave64 > 0) |
-                                    S_030980_NUM_PC_LINES(sscreen->info.pc_lines / 4 - 1);
+   shader->vs.ge_pc_alloc = S_030980_OVERSUB_EN(late_alloc_wave64 > 0) |
+                            S_030980_NUM_PC_LINES(sscreen->info.pc_lines / 4 - 1);
    shader->pa_cl_vs_out_cntl = si_get_vs_out_cntl(shader->selector, shader, false);
 
    oc_lds_en = shader->selector->stage == MESA_SHADER_TESS_EVAL ? 1 : 0;
@@ -1770,9 +1770,9 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
    si_pm4_set_reg(pm4, R_00B12C_SPI_SHADER_PGM_RSRC2_VS, rsrc2);
 
    if (window_space)
-      shader->ctx_reg.vs.pa_cl_vte_cntl = S_028818_VTX_XY_FMT(1) | S_028818_VTX_Z_FMT(1);
+      shader->vs.pa_cl_vte_cntl = S_028818_VTX_XY_FMT(1) | S_028818_VTX_Z_FMT(1);
    else
-      shader->ctx_reg.vs.pa_cl_vte_cntl =
+      shader->vs.pa_cl_vte_cntl =
          S_028818_VTX_W0_FMT(1) | S_028818_VPORT_X_SCALE_ENA(1) | S_028818_VPORT_X_OFFSET_ENA(1) |
          S_028818_VPORT_Y_SCALE_ENA(1) | S_028818_VPORT_Y_OFFSET_ENA(1) |
          S_028818_VPORT_Z_SCALE_ENA(1) | S_028818_VPORT_Z_OFFSET_ENA(1);
@@ -1811,21 +1811,21 @@ static void si_emit_shader_ps(struct si_context *sctx)
    radeon_begin(&sctx->gfx_cs);
    /* R_0286CC_SPI_PS_INPUT_ENA, R_0286D0_SPI_PS_INPUT_ADDR*/
    radeon_opt_set_context_reg2(sctx, R_0286CC_SPI_PS_INPUT_ENA, SI_TRACKED_SPI_PS_INPUT_ENA,
-                               shader->ctx_reg.ps.spi_ps_input_ena,
-                               shader->ctx_reg.ps.spi_ps_input_addr);
+                               shader->ps.spi_ps_input_ena,
+                               shader->ps.spi_ps_input_addr);
 
    radeon_opt_set_context_reg(sctx, R_0286E0_SPI_BARYC_CNTL, SI_TRACKED_SPI_BARYC_CNTL,
-                              shader->ctx_reg.ps.spi_baryc_cntl);
+                              shader->ps.spi_baryc_cntl);
    radeon_opt_set_context_reg(sctx, R_0286D8_SPI_PS_IN_CONTROL, SI_TRACKED_SPI_PS_IN_CONTROL,
-                              shader->ctx_reg.ps.spi_ps_in_control);
+                              shader->ps.spi_ps_in_control);
 
    /* R_028710_SPI_SHADER_Z_FORMAT, R_028714_SPI_SHADER_COL_FORMAT */
    radeon_opt_set_context_reg2(sctx, R_028710_SPI_SHADER_Z_FORMAT, SI_TRACKED_SPI_SHADER_Z_FORMAT,
-                               shader->ctx_reg.ps.spi_shader_z_format,
-                               shader->ctx_reg.ps.spi_shader_col_format);
+                               shader->ps.spi_shader_z_format,
+                               shader->ps.spi_shader_col_format);
 
    radeon_opt_set_context_reg(sctx, R_02823C_CB_SHADER_MASK, SI_TRACKED_CB_SHADER_MASK,
-                              shader->ctx_reg.ps.cb_shader_mask);
+                              shader->ps.cb_shader_mask);
    radeon_end_update_context_roll(sctx);
 }
 
@@ -1928,7 +1928,7 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
    if (sscreen->info.has_rbplus && !sscreen->info.rbplus_allowed)
       db_shader_control |= S_02880C_DUAL_QUAD_DISABLE(1);
 
-   shader->ctx_reg.ps.db_shader_control = db_shader_control;
+   shader->ps.db_shader_control = db_shader_control;
 
    pm4 = si_get_shader_pm4_state(shader);
    if (!pm4)
@@ -2002,8 +2002,8 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
       }
    }
 
-   shader->ctx_reg.ps.spi_ps_input_ena = input_ena;
-   shader->ctx_reg.ps.spi_ps_input_addr = shader->config.spi_ps_input_addr;
+   shader->ps.spi_ps_input_ena = input_ena;
+   shader->ps.spi_ps_input_addr = shader->config.spi_ps_input_addr;
 
    unsigned num_interp = si_get_ps_num_interp(shader);
 
@@ -2018,14 +2018,14 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
        shader->key.ps.mono.point_smoothing)
       spi_ps_in_control |= S_0286D8_PARAM_GEN(1);
 
-   shader->ctx_reg.ps.num_interp = num_interp;
-   shader->ctx_reg.ps.spi_baryc_cntl = spi_baryc_cntl;
-   shader->ctx_reg.ps.spi_ps_in_control = spi_ps_in_control;
-   shader->ctx_reg.ps.spi_shader_z_format =
+   shader->ps.num_interp = num_interp;
+   shader->ps.spi_baryc_cntl = spi_baryc_cntl;
+   shader->ps.spi_ps_in_control = spi_ps_in_control;
+   shader->ps.spi_shader_z_format =
       ac_get_spi_shader_z_format(info->writes_z, info->writes_stencil, info->writes_samplemask,
                                  shader->key.ps.part.epilog.alpha_to_coverage_via_mrtz);
-   shader->ctx_reg.ps.spi_shader_col_format = spi_shader_col_format;
-   shader->ctx_reg.ps.cb_shader_mask = cb_shader_mask;
+   shader->ps.spi_shader_col_format = spi_shader_col_format;
+   shader->ps.cb_shader_mask = cb_shader_mask;
 
    va = shader->bo->gpu_address;
    si_pm4_set_reg(pm4, R_00B020_SPI_SHADER_PGM_LO_PS, va >> 8);
-- 
GitLab


From 441d66ed3a6ab487e15f19f63353643d58b5bde2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 17 Feb 2023 22:22:22 -0500
Subject: [PATCH 10/45] radeonsi: remove no-op setting of THDS_PER_SUBGRP

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 4cf1bc906eaa..4188584fd46d 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -1484,8 +1484,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
 
    shader->ngg.ge_max_output_per_subgroup =
       S_0287FC_MAX_VERTS_PER_SUBGROUP(shader->ngg.max_out_verts);
-   shader->ngg.ge_ngg_subgrp_cntl = S_028B4C_PRIM_AMP_FACTOR(shader->ngg.prim_amp_factor) |
-                                    S_028B4C_THDS_PER_SUBGRP(0); /* for fast launch */
+   shader->ngg.ge_ngg_subgrp_cntl = S_028B4C_PRIM_AMP_FACTOR(shader->ngg.prim_amp_factor);
    shader->ngg.vgt_gs_instance_cnt =
       S_028B90_CNT(gs_num_invocations) | S_028B90_ENABLE(gs_num_invocations > 1) |
       S_028B90_EN_MAX_VERT_OUT_PER_GS_INSTANCE(shader->ngg.max_vert_out_per_gs_instance);
-- 
GitLab


From 543cc70aa51e1d37b6a81cbce3d88a198b7b4012 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 00:09:00 -0500
Subject: [PATCH 11/45] radeonsi: use SPI_SHADER_USER_DATA_HS_0 definition
 instead of LS_0

The value is the same, but LS_0 is for gfx9 only, and HS_0 is for everything
except gfx9.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_descriptors.c  | 4 ++--
 src/gallium/drivers/radeonsi/si_state_draw.cpp | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index d22d61a2da0d..b2be510a4343 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -2713,7 +2713,7 @@ void si_init_all_descriptors(struct si_context *sctx)
       if (is_2nd) {
          if (i == PIPE_SHADER_TESS_CTRL) {
             rel_dw_offset =
-               (hs_sgpr0 - R_00B430_SPI_SHADER_USER_DATA_LS_0) / 4;
+               (hs_sgpr0 - R_00B430_SPI_SHADER_USER_DATA_HS_0) / 4;
          } else if (sctx->gfx_level >= GFX10) { /* PIPE_SHADER_GEOMETRY */
             rel_dw_offset =
                (gs_sgpr0 - R_00B230_SPI_SHADER_USER_DATA_GS_0) / 4;
@@ -2733,7 +2733,7 @@ void si_init_all_descriptors(struct si_context *sctx)
       if (is_2nd) {
          if (i == PIPE_SHADER_TESS_CTRL) {
             rel_dw_offset =
-               (hs_sgpr0 + 4 - R_00B430_SPI_SHADER_USER_DATA_LS_0) / 4;
+               (hs_sgpr0 + 4 - R_00B430_SPI_SHADER_USER_DATA_HS_0) / 4;
          } else if (sctx->gfx_level >= GFX10) { /* PIPE_SHADER_GEOMETRY */
             rel_dw_offset =
                (gs_sgpr0 + 4 - R_00B230_SPI_SHADER_USER_DATA_GS_0) / 4;
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 6e2e7836d6bb..857e64c25203 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -836,7 +836,7 @@ static void si_emit_derived_tess_state(struct si_context *sctx)
 
       /* Set userdata SGPRs for merged LS-HS. */
       radeon_set_sh_reg_seq(
-         R_00B430_SPI_SHADER_USER_DATA_LS_0 + GFX9_SGPR_TCS_OFFCHIP_LAYOUT * 4, 3);
+         R_00B430_SPI_SHADER_USER_DATA_HS_0 + GFX9_SGPR_TCS_OFFCHIP_LAYOUT * 4, 3);
       radeon_emit(offchip_layout);
       radeon_emit(tcs_out_offsets);
       radeon_emit(tcs_out_layout);
-- 
GitLab


From d890711daf9cf34a5fa30e932133bce0c3fcd89d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 00:36:23 -0500
Subject: [PATCH 12/45] radeonsi: set PA_SU_VTX_CNTL consecutively with
 PA_CL_GB_VERT_CLIP_ADJ

because they are all next to each other.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_build_pm4.h   | 26 +++++++++++++++++++
 src/gallium/drivers/radeonsi/si_state.h       |  4 +--
 .../drivers/radeonsi/si_state_viewport.c      | 14 +++++-----
 3 files changed, 35 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_build_pm4.h b/src/gallium/drivers/radeonsi/si_build_pm4.h
index 8b72cebac51f..35782704917e 100644
--- a/src/gallium/drivers/radeonsi/si_build_pm4.h
+++ b/src/gallium/drivers/radeonsi/si_build_pm4.h
@@ -246,6 +246,32 @@
    } \
 } while (0)
 
+/**
+ * Set 5 consecutive registers if any register value is different.
+ */
+#define radeon_opt_set_context_reg5(sctx, offset, reg, val0, val1, val2, val3, val4) do { \
+   unsigned __value0 = (val0), __value1 = (val1), __value2 = (val2), __value3 = (val3), __value4 = (val4); \
+   if (((sctx->tracked_regs.reg_saved >> (reg)) & 0x1f) != 0x1f || \
+       sctx->tracked_regs.reg_value[(reg) + 0] != __value0 || \
+       sctx->tracked_regs.reg_value[(reg) + 1] != __value1 || \
+       sctx->tracked_regs.reg_value[(reg) + 2] != __value2 || \
+       sctx->tracked_regs.reg_value[(reg) + 3] != __value3 || \
+       sctx->tracked_regs.reg_value[(reg) + 4] != __value4) { \
+      radeon_set_context_reg_seq(offset, 5); \
+      radeon_emit(__value0); \
+      radeon_emit(__value1); \
+      radeon_emit(__value2); \
+      radeon_emit(__value3); \
+      radeon_emit(__value4); \
+      sctx->tracked_regs.reg_value[(reg) + 0] = __value0; \
+      sctx->tracked_regs.reg_value[(reg) + 1] = __value1; \
+      sctx->tracked_regs.reg_value[(reg) + 2] = __value2; \
+      sctx->tracked_regs.reg_value[(reg) + 3] = __value3; \
+      sctx->tracked_regs.reg_value[(reg) + 4] = __value4; \
+      sctx->tracked_regs.reg_saved |= 0x1full << (reg); \
+   } \
+} while (0)
+
 /**
  * Set consecutive registers if any registers value is different.
  */
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index 62297c929ef1..c96b2eb96e58 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -279,13 +279,13 @@ enum si_tracked_reg
 
    SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
 
-   SI_TRACKED_PA_CL_GB_VERT_CLIP_ADJ, /* 4 consecutive registers */
+   SI_TRACKED_PA_SU_VTX_CNTL, /* 5 consecutive registers */
+   SI_TRACKED_PA_CL_GB_VERT_CLIP_ADJ,
    SI_TRACKED_PA_CL_GB_VERT_DISC_ADJ,
    SI_TRACKED_PA_CL_GB_HORZ_CLIP_ADJ,
    SI_TRACKED_PA_CL_GB_HORZ_DISC_ADJ,
 
    SI_TRACKED_PA_SU_HARDWARE_SCREEN_OFFSET,
-   SI_TRACKED_PA_SU_VTX_CNTL,
 
    SI_TRACKED_PA_SC_CLIPRECT_RULE,
 
diff --git a/src/gallium/drivers/radeonsi/si_state_viewport.c b/src/gallium/drivers/radeonsi/si_state_viewport.c
index 84ce2523d642..00e044bfb083 100644
--- a/src/gallium/drivers/radeonsi/si_state_viewport.c
+++ b/src/gallium/drivers/radeonsi/si_state_viewport.c
@@ -382,17 +382,17 @@ static void si_emit_guardband(struct si_context *ctx)
     * R_028BF0_PA_CL_GB_HORZ_CLIP_ADJ, R_028BF4_PA_CL_GB_HORZ_DISC_ADJ
     */
    radeon_begin(&ctx->gfx_cs);
-   radeon_opt_set_context_reg4(ctx, R_028BE8_PA_CL_GB_VERT_CLIP_ADJ,
-                               SI_TRACKED_PA_CL_GB_VERT_CLIP_ADJ, fui(guardband_y), fui(discard_y),
+   radeon_opt_set_context_reg5(ctx, R_028BE4_PA_SU_VTX_CNTL, SI_TRACKED_PA_SU_VTX_CNTL,
+                               S_028BE4_PIX_CENTER(rs->half_pixel_center) |
+                               S_028BE4_ROUND_MODE(V_028BE4_X_ROUND_TO_EVEN) |
+                               S_028BE4_QUANT_MODE(V_028BE4_X_16_8_FIXED_POINT_1_256TH +
+                                                   vp_as_scissor.quant_mode),
+                               fui(guardband_y), fui(discard_y),
                                fui(guardband_x), fui(discard_x));
    radeon_opt_set_context_reg(ctx, R_028234_PA_SU_HARDWARE_SCREEN_OFFSET,
                               SI_TRACKED_PA_SU_HARDWARE_SCREEN_OFFSET,
                               S_028234_HW_SCREEN_OFFSET_X(hw_screen_offset_x >> 4) |
-                                 S_028234_HW_SCREEN_OFFSET_Y(hw_screen_offset_y >> 4));
-   radeon_opt_set_context_reg(
-      ctx, R_028BE4_PA_SU_VTX_CNTL, SI_TRACKED_PA_SU_VTX_CNTL,
-      S_028BE4_PIX_CENTER(rs->half_pixel_center) | S_028BE4_ROUND_MODE(V_028BE4_X_ROUND_TO_EVEN) |
-         S_028BE4_QUANT_MODE(V_028BE4_X_16_8_FIXED_POINT_1_256TH + vp_as_scissor.quant_mode));
+                              S_028234_HW_SCREEN_OFFSET_Y(hw_screen_offset_y >> 4));
    radeon_end_update_context_roll(ctx);
 }
 
-- 
GitLab


From 2a8f72dfde81ed133b9946d2a68128bcc474048a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 02:33:32 -0500
Subject: [PATCH 13/45] radeonsi/gfx11: ignore alpha_is_on_msb because the hw
 ignores it

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_clear.c | 59 +++++++++++++------------
 src/gallium/drivers/radeonsi/si_pipe.h  |  4 +-
 2 files changed, 32 insertions(+), 31 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_clear.c b/src/gallium/drivers/radeonsi/si_clear.c
index c9f6ae590f06..3b388405f056 100644
--- a/src/gallium/drivers/radeonsi/si_clear.c
+++ b/src/gallium/drivers/radeonsi/si_clear.c
@@ -169,6 +169,9 @@ enum pipe_format si_simplify_cb_format(enum pipe_format format)
 
 bool vi_alpha_is_on_msb(struct si_screen *sscreen, enum pipe_format format)
 {
+   if (sscreen->info.gfx_level >= GFX11)
+      return false;
+
    format = si_simplify_cb_format(format);
    const struct util_format_description *desc = util_format_description(format);
    unsigned comp_swap = si_translate_colorswap(sscreen->info.gfx_level, format, false);
@@ -382,35 +385,33 @@ static bool gfx11_get_dcc_clear_parameters(struct si_screen *sscreen, enum pipe_
    }
 
    /* Check 0001 and 1110 cases. */
-   if (vi_alpha_is_on_msb(sscreen, surface_format)) {
-      if (desc->nr_channels == 2 && desc->channel[0].size == 8) {
-         if (value.ub[0] == 0x00 && value.ub[1] == 0xff) {
-            *clear_value = GFX11_DCC_CLEAR_0001_UNORM;
-            return true;
-         } else if (value.ub[0] == 0xff && value.ub[1] == 0x00) {
-            *clear_value = GFX11_DCC_CLEAR_1110_UNORM;
-            return true;
-         }
-      } else if (desc->nr_channels == 4 && desc->channel[0].size == 8) {
-         if (value.ub[0] == 0x00 && value.ub[1] == 0x00 &&
-             value.ub[2] == 0x00 && value.ub[3] == 0xff) {
-            *clear_value = GFX11_DCC_CLEAR_0001_UNORM;
-            return true;
-         } else if (value.ub[0] == 0xff && value.ub[1] == 0xff &&
-                    value.ub[2] == 0xff && value.ub[3] == 0x00) {
-            *clear_value = GFX11_DCC_CLEAR_1110_UNORM;
-            return true;
-         }
-      } else if (desc->nr_channels == 4 && desc->channel[0].size == 16) {
-         if (value.us[0] == 0x0000 && value.us[1] == 0x0000 &&
-             value.us[2] == 0x0000 && value.us[3] == 0xffff) {
-            *clear_value = GFX11_DCC_CLEAR_0001_UNORM;
-            return true;
-         } else if (value.us[0] == 0xffff && value.us[1] == 0xffff &&
-                    value.us[2] == 0xffff && value.us[3] == 0x0000) {
-            *clear_value = GFX11_DCC_CLEAR_1110_UNORM;
-            return true;
-         }
+   if (desc->nr_channels == 2 && desc->channel[0].size == 8) {
+      if (value.ub[0] == 0x00 && value.ub[1] == 0xff) {
+         *clear_value = GFX11_DCC_CLEAR_0001_UNORM;
+         return true;
+      } else if (value.ub[0] == 0xff && value.ub[1] == 0x00) {
+         *clear_value = GFX11_DCC_CLEAR_1110_UNORM;
+         return true;
+      }
+   } else if (desc->nr_channels == 4 && desc->channel[0].size == 8) {
+      if (value.ub[0] == 0x00 && value.ub[1] == 0x00 &&
+          value.ub[2] == 0x00 && value.ub[3] == 0xff) {
+         *clear_value = GFX11_DCC_CLEAR_0001_UNORM;
+         return true;
+      } else if (value.ub[0] == 0xff && value.ub[1] == 0xff &&
+                 value.ub[2] == 0xff && value.ub[3] == 0x00) {
+         *clear_value = GFX11_DCC_CLEAR_1110_UNORM;
+         return true;
+      }
+   } else if (desc->nr_channels == 4 && desc->channel[0].size == 16) {
+      if (value.us[0] == 0x0000 && value.us[1] == 0x0000 &&
+          value.us[2] == 0x0000 && value.us[3] == 0xffff) {
+         *clear_value = GFX11_DCC_CLEAR_0001_UNORM;
+         return true;
+      } else if (value.us[0] == 0xffff && value.us[1] == 0xffff &&
+                 value.us[2] == 0xffff && value.us[3] == 0x0000) {
+         *clear_value = GFX11_DCC_CLEAR_1110_UNORM;
+         return true;
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 69ca71727068..7a1eefede7a5 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -178,9 +178,9 @@ enum si_clear_code
    GFX11_DCC_CLEAR_1111_UNORM = DCC_CODE(0x02), /* all bits are 1 */
    GFX11_DCC_CLEAR_1111_FP16  = DCC_CODE(0x04), /* all 16-bit words are 0x3c00, max 64bpp */
    GFX11_DCC_CLEAR_1111_FP32  = DCC_CODE(0x06), /* all 32-bit words are 0x3f800000 */
-   /* Color bits are 0, alpha bits are 1; only 88, 8888, 16161616 with alpha_on_msb=1 */
+   /* Color bits are 0, alpha bits are 1; only 88, 8888, 16161616 */
    GFX11_DCC_CLEAR_0001_UNORM = DCC_CODE(0x08),
-   /* Color bits are 1, alpha bits are 0, only 88, 8888, 16161616 with alpha_on_msb=1 */
+   /* Color bits are 1, alpha bits are 0, only 88, 8888, 16161616 */
    GFX11_DCC_CLEAR_1110_UNORM = DCC_CODE(0x0A),
 };
 
-- 
GitLab


From e94d92c2c49d67edaaa38a07b2a0fbe79a3fabb8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 04:44:28 -0500
Subject: [PATCH 14/45] radeonsi: replace si_screen::has_out_of_order_rast with
 the radeon_info field

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_pipe.c            | 4 ++--
 src/gallium/drivers/radeonsi/si_pipe.h            | 1 -
 src/gallium/drivers/radeonsi/si_state.c           | 8 ++++----
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 2 +-
 4 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index e753a451b289..38d40c38ad85 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1312,8 +1312,8 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
       (sscreen->info.gfx_level == GFX6 && sscreen->info.pfp_fw_version >= 79 &&
        sscreen->info.me_fw_version >= 142);
 
-   sscreen->has_out_of_order_rast =
-      sscreen->info.has_out_of_order_rast && !(sscreen->debug_flags & DBG(NO_OUT_OF_ORDER));
+   if (sscreen->debug_flags & DBG(NO_OUT_OF_ORDER))
+      sscreen->info.has_out_of_order_rast = false;
 
    if (sscreen->info.gfx_level >= GFX11) {
       sscreen->use_ngg = true;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 7a1eefede7a5..d0392bece543 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -578,7 +578,6 @@ struct si_screen {
    unsigned pbb_context_states_per_bin;
    unsigned pbb_persistent_states_per_bin;
    bool has_draw_indirect_multi;
-   bool has_out_of_order_rast;
    bool dpbb_allowed;
    bool use_ngg;
    bool use_ngg_culling;
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 72d39b5966b4..4222b53ab40b 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -763,7 +763,7 @@ static void si_bind_blend_state(struct pipe_context *ctx, void *state)
         old_blend->cb_target_enabled_4bit != blend->cb_target_enabled_4bit))
       si_mark_atom_dirty(sctx, &sctx->atoms.s.dpbb_state);
 
-   if (sctx->screen->has_out_of_order_rast &&
+   if (sctx->screen->info.has_out_of_order_rast &&
        ((old_blend->blend_enable_4bit != blend->blend_enable_4bit ||
          old_blend->cb_target_enabled_4bit != blend->cb_target_enabled_4bit ||
          old_blend->commutative_4bit != blend->commutative_4bit ||
@@ -1446,7 +1446,7 @@ static void si_bind_dsa_state(struct pipe_context *ctx, void *state)
                                        old_dsa->db_can_write != dsa->db_can_write)))
       si_mark_atom_dirty(sctx, &sctx->atoms.s.dpbb_state);
 
-   if (sctx->screen->has_out_of_order_rast &&
+   if (sctx->screen->info.has_out_of_order_rast &&
        (memcmp(old_dsa->order_invariance, dsa->order_invariance,
                sizeof(old_dsa->order_invariance))))
       si_mark_atom_dirty(sctx, &sctx->atoms.s.msaa_config);
@@ -3134,7 +3134,7 @@ static void si_set_framebuffer_state(struct pipe_context *ctx,
    if (sctx->framebuffer.any_dst_linear != old_any_dst_linear)
       si_mark_atom_dirty(sctx, &sctx->atoms.s.msaa_config);
 
-   if (sctx->screen->has_out_of_order_rast &&
+   if (sctx->screen->info.has_out_of_order_rast &&
        (sctx->framebuffer.colorbuf_enabled_4bit != old_colorbuf_enabled_4bit ||
         !!sctx->framebuffer.state.zsbuf != old_has_zsbuf ||
         (zstex && zstex->surface.has_stencil != old_has_stencil)))
@@ -3702,7 +3702,7 @@ static bool si_out_of_order_rasterization(struct si_context *sctx)
    struct si_state_blend *blend = sctx->queued.named.blend;
    struct si_state_dsa *dsa = sctx->queued.named.dsa;
 
-   if (!sctx->screen->has_out_of_order_rast)
+   if (!sctx->screen->info.has_out_of_order_rast)
       return false;
 
    unsigned colormask = sctx->framebuffer.colorbuf_enabled_4bit;
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 4188584fd46d..0daa4866705e 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -3628,7 +3628,7 @@ static void si_bind_ps_shader(struct pipe_context *ctx, void *state)
       if (!old_sel || old_sel->info.colors_written != sel->info.colors_written)
          si_mark_atom_dirty(sctx, &sctx->atoms.s.cb_render_state);
 
-      if (sctx->screen->has_out_of_order_rast &&
+      if (sctx->screen->info.has_out_of_order_rast &&
           (!old_sel || old_sel->info.base.writes_memory != sel->info.base.writes_memory ||
            old_sel->info.base.fs.early_fragment_tests !=
               sel->info.base.fs.early_fragment_tests))
-- 
GitLab


From d0350b38b01f9f479d4ed1f60a32651abf8055c6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 04:51:28 -0500
Subject: [PATCH 15/45] radeonsi: disable Smart Access Memory because CPU
 access has large overhead

It will be remove completely in the next commit.

Related: https://gitlab.freedesktop.org/mesa/mesa/-/issues/8176

Cc: mesa-stable

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_pipe.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 38d40c38ad85..8a92a922bad6 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1140,6 +1140,8 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
                   sscreen->options.enable_sam,
                   sscreen->options.disable_sam);
 
+   sscreen->info.smart_access_memory = false; /* VRAM has slower CPU access */
+
    if (sscreen->info.gfx_level >= GFX9) {
       sscreen->se_tile_repeat = 32 * sscreen->info.max_se;
    } else {
-- 
GitLab


From 1d14638b572bce936f95104fb4550ddb8721db85 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 09:58:50 -0500
Subject: [PATCH 16/45] amd,radeonsi: remove unused LLVM functions

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 73 -------------------
 .../drivers/radeonsi/gfx10_shader_ngg.c       | 28 -------
 src/gallium/drivers/radeonsi/si_shader.c      |  3 +-
 .../drivers/radeonsi/si_shader_internal.h     |  6 --
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 26 +------
 .../drivers/radeonsi/si_shader_llvm_gs.c      |  7 --
 .../drivers/radeonsi/si_shader_llvm_ps.c      |  2 +-
 7 files changed, 5 insertions(+), 140 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 30e5dc4c6aa2..e2f84bc15e63 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -2353,12 +2353,6 @@ static LLVMValueRef visit_load_ubo_buffer(struct ac_nir_context *ctx, nir_intrin
    return exit_waterfall(ctx, &wctx, ret);
 }
 
-static unsigned type_scalar_size_bytes(const struct glsl_type *type)
-{
-   assert(glsl_type_is_vector_or_scalar(type) || glsl_type_is_matrix(type));
-   return glsl_type_is_boolean(type) ? 4 : glsl_get_bit_size(type) / 8;
-}
-
 static void visit_store_output(struct ac_nir_context *ctx, nir_intrinsic_instr *instr)
 {
    if (ctx->ac.postponed_kill) {
@@ -4345,13 +4339,6 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    return true;
 }
 
-static LLVMValueRef get_sampler_desc(struct ac_nir_context *ctx,
-                                     enum ac_descriptor_type desc_type, const nir_instr *instr,
-                                     LLVMValueRef index, bool image, bool write)
-{
-   return ctx->abi->load_sampler_desc(ctx->abi, index, desc_type);
-}
-
 /* Disable anisotropic filtering if BASE_LEVEL == LAST_LEVEL.
  *
  * GFX6-GFX7:
@@ -4841,66 +4828,6 @@ static bool visit_jump(struct ac_llvm_context *ctx, const nir_jump_instr *instr)
    return true;
 }
 
-static LLVMTypeRef glsl_base_to_llvm_type(struct ac_llvm_context *ac, enum glsl_base_type type)
-{
-   switch (type) {
-   case GLSL_TYPE_INT:
-   case GLSL_TYPE_UINT:
-   case GLSL_TYPE_BOOL:
-   case GLSL_TYPE_SUBROUTINE:
-      return ac->i32;
-   case GLSL_TYPE_INT8:
-   case GLSL_TYPE_UINT8:
-      return ac->i8;
-   case GLSL_TYPE_INT16:
-   case GLSL_TYPE_UINT16:
-      return ac->i16;
-   case GLSL_TYPE_FLOAT:
-      return ac->f32;
-   case GLSL_TYPE_FLOAT16:
-      return ac->f16;
-   case GLSL_TYPE_INT64:
-   case GLSL_TYPE_UINT64:
-      return ac->i64;
-   case GLSL_TYPE_DOUBLE:
-      return ac->f64;
-   default:
-      unreachable("unknown GLSL type");
-   }
-}
-
-static LLVMTypeRef glsl_to_llvm_type(struct ac_llvm_context *ac, const struct glsl_type *type)
-{
-   if (glsl_type_is_scalar(type)) {
-      return glsl_base_to_llvm_type(ac, glsl_get_base_type(type));
-   }
-
-   if (glsl_type_is_vector(type)) {
-      return LLVMVectorType(glsl_base_to_llvm_type(ac, glsl_get_base_type(type)),
-                            glsl_get_vector_elements(type));
-   }
-
-   if (glsl_type_is_matrix(type)) {
-      return LLVMArrayType(glsl_to_llvm_type(ac, glsl_get_column_type(type)),
-                           glsl_get_matrix_columns(type));
-   }
-
-   if (glsl_type_is_array(type)) {
-      return LLVMArrayType(glsl_to_llvm_type(ac, glsl_get_array_element(type)),
-                           glsl_get_length(type));
-   }
-
-   assert(glsl_type_is_struct_or_ifc(type));
-
-   LLVMTypeRef *const member_types = alloca(glsl_get_length(type) * sizeof(LLVMTypeRef));
-
-   for (unsigned i = 0; i < glsl_get_length(type); i++) {
-      member_types[i] = glsl_to_llvm_type(ac, glsl_get_struct_field(type, i));
-   }
-
-   return LLVMStructTypeInContext(ac->context, member_types, glsl_get_length(type), false);
-}
-
 static bool visit_cf_list(struct ac_nir_context *ctx, struct exec_list *list);
 
 static bool visit_block(struct ac_nir_context *ctx, nir_block *block)
diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index c053d436426a..64b24caff09d 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -26,34 +26,6 @@
 #include "si_shader_internal.h"
 #include "util/u_prim.h"
 
-static LLVMValueRef get_wave_id_in_tg(struct si_shader_context *ctx)
-{
-   return si_unpack_param(ctx, ctx->args->ac.merged_wave_info, 24, 4);
-}
-
-LLVMValueRef gfx10_get_thread_id_in_tg(struct si_shader_context *ctx)
-{
-   LLVMBuilderRef builder = ctx->ac.builder;
-   LLVMValueRef tmp;
-   tmp = LLVMBuildMul(builder, get_wave_id_in_tg(ctx),
-                      LLVMConstInt(ctx->ac.i32, ctx->ac.wave_size, false), "");
-   return LLVMBuildAdd(builder, tmp, ac_get_thread_id(&ctx->ac), "");
-}
-
-static LLVMValueRef ngg_get_query_buf(struct si_shader_context *ctx)
-{
-   return ac_build_load_to_sgpr(&ctx->ac,
-                                ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings),
-                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_BUF, false));
-}
-
-static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
-{
-   return ac_build_load_to_sgpr(&ctx->ac,
-                                ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings),
-                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
-}
-
 unsigned gfx10_ngg_get_vertices_per_prim(struct si_shader *shader)
 {
    const struct si_shader_info *info = &shader->selector->info;
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index ea3887316993..0d92b9a72a93 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -42,6 +42,7 @@ static const char scratch_rsrc_dword0_symbol[] = "SCRATCH_RSRC_DWORD0";
 static const char scratch_rsrc_dword1_symbol[] = "SCRATCH_RSRC_DWORD1";
 
 static void si_dump_shader_key(const struct si_shader *shader, FILE *f);
+static void si_fix_resource_usage(struct si_screen *sscreen, struct si_shader *shader);
 
 /* Get the number of all interpolated inputs */
 unsigned si_get_ps_num_interp(struct si_shader *ps)
@@ -2780,7 +2781,7 @@ void si_multiwave_lds_size_workaround(struct si_screen *sscreen, unsigned *lds_s
       *lds_size = MAX2(*lds_size, 8);
 }
 
-void si_fix_resource_usage(struct si_screen *sscreen, struct si_shader *shader)
+static void si_fix_resource_usage(struct si_screen *sscreen, struct si_shader *shader)
 {
    unsigned min_sgprs = shader->info.num_input_sgprs + 2; /* VCC */
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 77dca9e5a20e..1302f5b05d1f 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -171,10 +171,8 @@ bool si_need_ps_prolog(const union si_shader_part_key *key);
 void si_get_ps_prolog_key(struct si_shader *shader, union si_shader_part_key *key,
                           bool separate_prolog);
 void si_get_ps_epilog_key(struct si_shader *shader, union si_shader_part_key *key);
-void si_fix_resource_usage(struct si_screen *sscreen, struct si_shader *shader);
 
 /* gfx10_shader_ngg.c */
-LLVMValueRef gfx10_get_thread_id_in_tg(struct si_shader_context *ctx);
 unsigned gfx10_ngg_get_vertices_per_prim(struct si_shader *shader);
 bool gfx10_ngg_export_prim_early(struct si_shader *shader);
 unsigned gfx10_ngg_get_scratch_dw_size(struct si_shader *shader);
@@ -213,14 +211,11 @@ LLVMValueRef si_prolog_get_internal_bindings(struct si_shader_context *ctx);
 void si_llvm_declare_esgs_ring(struct si_shader_context *ctx);
 LLVMValueRef si_unpack_param(struct si_shader_context *ctx, struct ac_arg param, unsigned rshift,
                              unsigned bitwidth);
-LLVMValueRef si_get_primitive_id(struct si_shader_context *ctx, unsigned swizzle);
 void si_build_wrapper_function(struct si_shader_context *ctx, struct ac_llvm_pointer *parts,
                                unsigned num_parts, unsigned main_part,
                                unsigned next_shader_first_part,
                                enum ac_arg_type *main_arg_types,
                                bool same_thread_count);
-bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
-                           struct nir_shader *nir, bool free_nir);
 bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                             struct si_shader *shader, struct si_shader_args *args,
                             struct util_debug_callback *debug, struct nir_shader *nir);
@@ -243,7 +238,6 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx);
 
 /* si_shader_llvm_ps.c */
-LLVMValueRef si_get_sample_id(struct si_shader_context *ctx);
 void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_build_monolithic_ps(struct si_shader_context *ctx, struct si_shader *shader);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 3c199e58b7f4..7d84520b6501 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -379,28 +379,6 @@ LLVMValueRef si_unpack_param(struct si_shader_context *ctx, struct ac_arg param,
    return unpack_llvm_param(ctx, value, rshift, bitwidth);
 }
 
-LLVMValueRef si_get_primitive_id(struct si_shader_context *ctx, unsigned swizzle)
-{
-   if (swizzle > 0)
-      return ctx->ac.i32_0;
-
-   switch (ctx->stage) {
-   case MESA_SHADER_VERTEX:
-      return ac_get_arg(&ctx->ac, ctx->args->ac.vs_prim_id);
-   case MESA_SHADER_TESS_CTRL:
-      return ac_get_arg(&ctx->ac, ctx->args->ac.tcs_patch_id);
-   case MESA_SHADER_TESS_EVAL:
-      return ctx->abi.tes_patch_id_replaced ?
-         ctx->abi.tes_patch_id_replaced :
-         ac_get_arg(&ctx->ac, ctx->args->ac.tes_patch_id);
-   case MESA_SHADER_GEOMETRY:
-      return ac_get_arg(&ctx->ac, ctx->args->ac.gs_prim_id);
-   default:
-      assert(0);
-      return ctx->ac.i32_0;
-   }
-}
-
 static void si_llvm_declare_compute_memory(struct si_shader_context *ctx)
 {
    struct si_shader_selector *sel = ctx->shader->selector;
@@ -774,8 +752,8 @@ static LLVMValueRef si_llvm_load_sampler_desc(struct ac_shader_abi *abi, LLVMVal
    return index;
 }
 
-bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
-                           struct nir_shader *nir, bool free_nir)
+static bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
+                                  struct nir_shader *nir, bool free_nir)
 {
    struct si_shader_selector *sel = shader->selector;
    const struct si_shader_info *info = &sel->info;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 30befe58f530..65bbbb4aca52 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -96,13 +96,6 @@ static LLVMValueRef si_get_gs_wave_id(struct si_shader_context *ctx)
       return ac_get_arg(&ctx->ac, ctx->args->ac.gs_wave_id);
 }
 
-static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
-{
-   return ac_build_load_to_sgpr(&ctx->ac,
-                                ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->internal_bindings),
-                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
-}
-
 void si_llvm_gs_build_end(struct si_shader_context *ctx)
 {
    if (ctx->screen->info.gfx_level >= GFX10)
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index 39db5f050f44..59537688ad41 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -26,7 +26,7 @@
 #include "si_shader_internal.h"
 #include "sid.h"
 
-LLVMValueRef si_get_sample_id(struct si_shader_context *ctx)
+static LLVMValueRef si_get_sample_id(struct si_shader_context *ctx)
 {
    return si_unpack_param(ctx, ctx->args->ac.ancillary, 8, 4);
 }
-- 
GitLab


From e1edaf408760913a48812845d6316be91e752d4f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 17 Feb 2023 18:44:29 -0500
Subject: [PATCH 17/45] amd/registers: unify VRS combiner definition names
 between gfx103 and gfx11

use gfx11 names

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/registers/gfx103.json             | 10 +++++-----
 src/amd/registers/parse_kernel_headers.py | 10 +++++-----
 src/amd/vulkan/radv_cmd_buffer.c          |  6 +++---
 src/amd/vulkan/radv_pipeline.c            | 14 +++++++-------
 src/amd/vulkan/si_cmd_buffer.c            |  2 +-
 src/gallium/drivers/radeonsi/si_state.c   |  8 ++++----
 6 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/src/amd/registers/gfx103.json b/src/amd/registers/gfx103.json
index 22d7c244fd62..395c6918e033 100644
--- a/src/amd/registers/gfx103.json
+++ b/src/amd/registers/gfx103.json
@@ -909,11 +909,11 @@
   },
   "VRSCombinerModeSC": {
    "entries": [
-    {"name": "VRS_COMB_MODE_PASSTHRU", "value": 0},
-    {"name": "VRS_COMB_MODE_OVERRIDE", "value": 1},
-    {"name": "VRS_COMB_MODE_MIN", "value": 2},
-    {"name": "VRS_COMB_MODE_MAX", "value": 3},
-    {"name": "VRS_COMB_MODE_SATURATE", "value": 4}
+    {"name": "SC_VRS_COMB_MODE_PASSTHRU", "value": 0},
+    {"name": "SC_VRS_COMB_MODE_OVERRIDE", "value": 1},
+    {"name": "SC_VRS_COMB_MODE_MIN", "value": 2},
+    {"name": "SC_VRS_COMB_MODE_MAX", "value": 3},
+    {"name": "SC_VRS_COMB_MODE_SATURATE", "value": 4}
    ]
   },
   "VRSHtileEncoding": {
diff --git a/src/amd/registers/parse_kernel_headers.py b/src/amd/registers/parse_kernel_headers.py
index 9cd0425b852f..cd4c7b686902 100644
--- a/src/amd/registers/parse_kernel_headers.py
+++ b/src/amd/registers/parse_kernel_headers.py
@@ -407,11 +407,11 @@ IMG_DATA_FORMAT_STENCIL = {
 
 VRSCombinerModeSC = {
  "entries": [
-  {"name": "VRS_COMB_MODE_PASSTHRU", "value": 0},
-  {"name": "VRS_COMB_MODE_OVERRIDE", "value": 1},
-  {"name": "VRS_COMB_MODE_MIN", "value": 2},
-  {"name": "VRS_COMB_MODE_MAX", "value": 3},
-  {"name": "VRS_COMB_MODE_SATURATE", "value": 4},
+  {"name": "SC_VRS_COMB_MODE_PASSTHRU", "value": 0},
+  {"name": "SC_VRS_COMB_MODE_OVERRIDE", "value": 1},
+  {"name": "SC_VRS_COMB_MODE_MIN", "value": 2},
+  {"name": "SC_VRS_COMB_MODE_MAX", "value": 3},
+  {"name": "SC_VRS_COMB_MODE_SATURATE", "value": 4},
  ]
 }
 
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 9ef883a05f89..80100dcfe5ba 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -2240,7 +2240,7 @@ radv_emit_fragment_shading_rate(struct radv_cmd_buffer *cmd_buffer)
          /* As the result of min(A, 1x1) or replace(A, 1x1) are always 1x1, set the vertex rate
           * combiner mode as passthrough.
           */
-         pipeline_comb_mode = V_028848_VRS_COMB_MODE_PASSTHRU;
+         pipeline_comb_mode = V_028848_SC_VRS_COMB_MODE_PASSTHRU;
          break;
       case VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR:
          /* The result of max(A, 1x1) is always A. */
@@ -2261,11 +2261,11 @@ radv_emit_fragment_shading_rate(struct radv_cmd_buffer *cmd_buffer)
     * draw rate and the vertex rate.
     */
    if (cmd_buffer->state.mesh_shading) {
-      pa_cl_vrs_cntl |= S_028848_VERTEX_RATE_COMBINER_MODE(V_028848_VRS_COMB_MODE_PASSTHRU) |
+      pa_cl_vrs_cntl |= S_028848_VERTEX_RATE_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_PASSTHRU) |
                         S_028848_PRIMITIVE_RATE_COMBINER_MODE(pipeline_comb_mode);
    } else {
       pa_cl_vrs_cntl |= S_028848_VERTEX_RATE_COMBINER_MODE(pipeline_comb_mode) |
-                        S_028848_PRIMITIVE_RATE_COMBINER_MODE(V_028848_VRS_COMB_MODE_PASSTHRU);
+                        S_028848_PRIMITIVE_RATE_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_PASSTHRU);
    }
 
    /* HTILE_RATE_COMBINER_MODE controls the combiner mode between the primitive rate and the HTILE
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 759b60498537..45d5d3522d84 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -516,7 +516,7 @@ gfx103_pipeline_init_vrs_state(struct radv_graphics_pipeline *pipeline,
        *    16-bit sample coverage mask isn't enough for MSAA8x and
        *    2x2 coarse shading isn't enough.
        */
-      vrs->pa_cl_vrs_cntl = S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_VRS_COMB_MODE_OVERRIDE);
+      vrs->pa_cl_vrs_cntl = S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_OVERRIDE);
 
       /* Make sure sample shading is enabled even if only MSAA1x is
        * used because the SAMPLE_ITER combiner is in passthrough
@@ -526,7 +526,7 @@ gfx103_pipeline_init_vrs_state(struct radv_graphics_pipeline *pipeline,
       if (!G_028A4C_PS_ITER_SAMPLE(pipeline->pa_sc_mode_cntl_1))
          pipeline->pa_sc_mode_cntl_1 |= S_028A4C_PS_ITER_SAMPLE(1);
    } else {
-      vrs->pa_cl_vrs_cntl = S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_VRS_COMB_MODE_PASSTHRU);
+      vrs->pa_cl_vrs_cntl = S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_PASSTHRU);
    }
 }
 
@@ -4618,7 +4618,7 @@ gfx103_pipeline_emit_vrs_state(struct radeon_cmdbuf *ctx_cs,
                                const struct vk_graphics_pipeline_state *state)
 {
    const struct radv_physical_device *pdevice = pipeline->base.device->physical_device;
-   uint32_t mode = V_028064_VRS_COMB_MODE_PASSTHRU;
+   uint32_t mode = V_028064_SC_VRS_COMB_MODE_PASSTHRU;
    uint8_t rate_x = 0, rate_y = 0;
    bool enable_vrs = radv_is_vrs_enabled(pipeline, state);
 
@@ -4626,7 +4626,7 @@ gfx103_pipeline_emit_vrs_state(struct radeon_cmdbuf *ctx_cs,
       /* When per-draw VRS is not enabled at all, try enabling VRS coarse shading 2x2 if the driver
        * determined that it's safe to enable.
        */
-      mode = V_028064_VRS_COMB_MODE_OVERRIDE;
+      mode = V_028064_SC_VRS_COMB_MODE_OVERRIDE;
       rate_x = rate_y = 1;
    } else if (!radv_is_static_vrs_enabled(pipeline, state) && pipeline->force_vrs_per_vertex &&
               get_vs_output_info(pipeline)->writes_primitive_shading_rate) {
@@ -4635,15 +4635,15 @@ gfx103_pipeline_emit_vrs_state(struct radeon_cmdbuf *ctx_cs,
        * in DX12 it's fully dynamic.
        */
       radeon_set_context_reg(ctx_cs, R_028848_PA_CL_VRS_CNTL,
-         S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_VRS_COMB_MODE_OVERRIDE) |
-         S_028848_VERTEX_RATE_COMBINER_MODE(V_028848_VRS_COMB_MODE_OVERRIDE));
+         S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_OVERRIDE) |
+         S_028848_VERTEX_RATE_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_OVERRIDE));
 
       /* If the shader is using discard, turn off coarse shading because discard at 2x2 pixel
        * granularity degrades quality too much. MIN allows sample shading but not coarse shading.
        */
       struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
 
-      mode = ps->info.ps.can_discard ? V_028064_VRS_COMB_MODE_MIN : V_028064_VRS_COMB_MODE_PASSTHRU;
+      mode = ps->info.ps.can_discard ? V_028064_SC_VRS_COMB_MODE_MIN : V_028064_SC_VRS_COMB_MODE_PASSTHRU;
    }
 
    if (pdevice->rad_info.gfx_level >= GFX11) {
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 5e540764a05a..19486f6e0fb7 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -504,7 +504,7 @@ si_emit_graphics(struct radv_device *device, struct radeon_cmdbuf *cs)
          /* This allows sample shading. */
          radeon_set_context_reg(
             cs, R_028848_PA_CL_VRS_CNTL,
-            S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_VRS_COMB_MODE_OVERRIDE));
+            S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_OVERRIDE));
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 4222b53ab40b..2e21e971ca1f 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -1621,7 +1621,7 @@ static void si_emit_db_render_state(struct si_context *sctx)
             radeon_opt_set_context_reg(sctx, R_028064_DB_VRS_OVERRIDE_CNTL,
                                        SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
                                        S_028064_VRS_OVERRIDE_RATE_COMBINER_MODE(
-                                          V_028064_VRS_COMB_MODE_OVERRIDE) |
+                                          V_028064_SC_VRS_COMB_MODE_OVERRIDE) |
                                        S_028064_VRS_OVERRIDE_RATE_X(1) |
                                        S_028064_VRS_OVERRIDE_RATE_Y(1));
          }
@@ -1641,7 +1641,7 @@ static void si_emit_db_render_state(struct si_context *sctx)
                                        S_0283D0_VRS_RATE(V_0283D0_VRS_SHADING_RATE_1X1));
          } else {
             unsigned mode = sctx->screen->options.vrs2x2 && G_02880C_KILL_ENABLE(db_shader_control) ?
-               V_028064_VRS_COMB_MODE_MIN : V_028064_VRS_COMB_MODE_PASSTHRU;
+               V_028064_SC_VRS_COMB_MODE_MIN : V_028064_SC_VRS_COMB_MODE_PASSTHRU;
 
             radeon_opt_set_context_reg(sctx, R_028064_DB_VRS_OVERRIDE_CNTL,
                                        SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
@@ -5923,8 +5923,8 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
        * (e.g. enabled sample shading overrides the vertex rate)
        */
       si_pm4_set_reg(pm4, R_028848_PA_CL_VRS_CNTL,
-                     S_028848_VERTEX_RATE_COMBINER_MODE(V_028848_VRS_COMB_MODE_OVERRIDE) |
-                     S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_VRS_COMB_MODE_OVERRIDE));
+                     S_028848_VERTEX_RATE_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_OVERRIDE) |
+                     S_028848_SAMPLE_ITER_COMBINER_MODE(V_028848_SC_VRS_COMB_MODE_OVERRIDE));
    }
 
    if (sctx->gfx_level >= GFX11) {
-- 
GitLab


From 0c17375013c88dcee9c73835ae8595ea19e2b162 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 03:51:54 -0500
Subject: [PATCH 18/45] amd: replace SI_BIG_ENDIAN with UTIL_ARCH_BIG_ENDIAN

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/vulkan/radv_formats.c                  | 2 +-
 src/gallium/drivers/radeonsi/si_get.c          | 2 +-
 src/gallium/drivers/radeonsi/si_pipe.h         | 6 ------
 src/gallium/drivers/radeonsi/si_state.c        | 4 ++--
 src/gallium/drivers/radeonsi/si_state_draw.cpp | 2 +-
 5 files changed, 5 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index e1ff484f3ebd..a48733ed83d3 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -957,7 +957,7 @@ radv_translate_colorformat(VkFormat format)
 uint32_t
 radv_colorformat_endian_swap(uint32_t colorformat)
 {
-   if (0 /*SI_BIG_ENDIAN*/) {
+   if (0 /*UTIL_ARCH_BIG_ENDIAN*/) {
       switch (colorformat) {
          /* 8-bit buffers. */
       case V_028C70_COLOR_8:
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index c649aa49104e..8c7c8a7db843 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -206,7 +206,7 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
       return sscreen->info.has_graphics;
 
    case PIPE_CAP_RESOURCE_FROM_USER_MEMORY:
-      return !SI_BIG_ENDIAN && sscreen->info.has_userptr;
+      return !UTIL_ARCH_BIG_ENDIAN && sscreen->info.has_userptr;
 
    case PIPE_CAP_DEVICE_PROTECTED_SURFACE:
       return sscreen->info.has_tmz_support;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index d0392bece543..792fb4aed127 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -39,12 +39,6 @@
 extern "C" {
 #endif
 
-#if UTIL_ARCH_BIG_ENDIAN
-#define SI_BIG_ENDIAN 1
-#else
-#define SI_BIG_ENDIAN 0
-#endif
-
 #define ATI_VENDOR_ID         0x1002
 #define SI_NOT_QUERY          0xffffffff
 
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 2e21e971ca1f..0f4a85f2468a 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -1755,7 +1755,7 @@ uint32_t si_translate_colorformat(enum amd_gfx_level gfx_level,
 
 static uint32_t si_colorformat_endian_swap(uint32_t colorformat)
 {
-   if (SI_BIG_ENDIAN) {
+   if (UTIL_ARCH_BIG_ENDIAN) {
       switch (colorformat) {
       /* 8-bit buffers. */
       case V_028C70_COLOR_8:
@@ -2587,7 +2587,7 @@ static void si_initialize_color_surface(struct si_context *sctx, struct si_surfa
       S_028C70_NUMBER_TYPE(ntype);
 
    if (sctx->gfx_level >= GFX11) {
-      assert(!SI_BIG_ENDIAN);
+      assert(!UTIL_ARCH_BIG_ENDIAN);
       color_info |= S_028C70_FORMAT_GFX11(format);
    } else {
       color_info |= S_028C70_FORMAT_GFX6(format) | S_028C70_ENDIAN(endian);
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 857e64c25203..5f72b7f7cd77 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -1489,7 +1489,7 @@ static void si_emit_draw_packets(struct si_context *sctx, const struct pipe_draw
          index_type = (((index_size >> 2) | (index_size << 1)) & 0x3) |
                       S_028A7C_DISABLE_INSTANCE_PACKING(disable_instance_packing);
 
-         if (GFX_VERSION <= GFX7 && SI_BIG_ENDIAN) {
+         if (GFX_VERSION <= GFX7 && UTIL_ARCH_BIG_ENDIAN) {
             /* GFX7 doesn't support ubyte indices. */
             index_type |= index_size == 2 ? V_028A7C_VGT_DMA_SWAP_16_BIT
                                           : V_028A7C_VGT_DMA_SWAP_32_BIT;
-- 
GitLab


From a6044031227f8fdfc42efed8e5eae67f9d59f141 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 04:05:02 -0500
Subject: [PATCH 19/45] radeonsi: remove returns from
 si_emit_global_shader_pointers

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_descriptors.c | 21 +++++++------------
 1 file changed, 7 insertions(+), 14 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index b2be510a4343..9adda13fc78a 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -2170,37 +2170,30 @@ static void si_emit_global_shader_pointers(struct si_context *sctx, struct si_de
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B030_SPI_SHADER_USER_DATA_PS_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B230_SPI_SHADER_USER_DATA_GS_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B430_SPI_SHADER_USER_DATA_HS_0);
-      radeon_end();
-      return;
    } else if (sctx->gfx_level >= GFX10) {
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B030_SPI_SHADER_USER_DATA_PS_0);
       /* HW VS stage only used in non-NGG mode. */
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B130_SPI_SHADER_USER_DATA_VS_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B230_SPI_SHADER_USER_DATA_GS_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B430_SPI_SHADER_USER_DATA_HS_0);
-      radeon_end();
-      return;
    } else if (sctx->gfx_level == GFX9 && sctx->shadowed_regs) {
       /* We can't use the COMMON registers with register shadowing. */
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B030_SPI_SHADER_USER_DATA_PS_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B130_SPI_SHADER_USER_DATA_VS_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B330_SPI_SHADER_USER_DATA_ES_0);
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B430_SPI_SHADER_USER_DATA_LS_0);
-      radeon_end();
-      return;
    } else if (sctx->gfx_level == GFX9) {
       /* Broadcast it to all shader stages. */
       radeon_emit_one_32bit_pointer(sctx, descs, R_00B530_SPI_SHADER_USER_DATA_COMMON_0);
-      radeon_end();
-      return;
+   } else {
+      radeon_emit_one_32bit_pointer(sctx, descs, R_00B030_SPI_SHADER_USER_DATA_PS_0);
+      radeon_emit_one_32bit_pointer(sctx, descs, R_00B130_SPI_SHADER_USER_DATA_VS_0);
+      radeon_emit_one_32bit_pointer(sctx, descs, R_00B330_SPI_SHADER_USER_DATA_ES_0);
+      radeon_emit_one_32bit_pointer(sctx, descs, R_00B230_SPI_SHADER_USER_DATA_GS_0);
+      radeon_emit_one_32bit_pointer(sctx, descs, R_00B430_SPI_SHADER_USER_DATA_HS_0);
+      radeon_emit_one_32bit_pointer(sctx, descs, R_00B530_SPI_SHADER_USER_DATA_LS_0);
    }
 
-   radeon_emit_one_32bit_pointer(sctx, descs, R_00B030_SPI_SHADER_USER_DATA_PS_0);
-   radeon_emit_one_32bit_pointer(sctx, descs, R_00B130_SPI_SHADER_USER_DATA_VS_0);
-   radeon_emit_one_32bit_pointer(sctx, descs, R_00B330_SPI_SHADER_USER_DATA_ES_0);
-   radeon_emit_one_32bit_pointer(sctx, descs, R_00B230_SPI_SHADER_USER_DATA_GS_0);
-   radeon_emit_one_32bit_pointer(sctx, descs, R_00B430_SPI_SHADER_USER_DATA_HS_0);
-   radeon_emit_one_32bit_pointer(sctx, descs, R_00B530_SPI_SHADER_USER_DATA_LS_0);
    radeon_end();
 }
 
-- 
GitLab


From 2be00adfc10ef6bde07c988182d334662c4a8332 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 04:38:03 -0500
Subject: [PATCH 20/45] radeonsi: reformat emit_cb_render_state,
 create_blend_state, create_rs_state

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c       | 92 ++++++++++---------
 .../drivers/radeonsi/si_state_viewport.c      |  2 +-
 2 files changed, 48 insertions(+), 46 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 0f4a85f2468a..22ff26b1ee73 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -153,14 +153,14 @@ static void si_emit_cb_render_state(struct si_context *sctx)
          }
 
          format = sctx->gfx_level >= GFX11 ? G_028C70_FORMAT_GFX11(surf->cb_color_info):
-                                              G_028C70_FORMAT_GFX6(surf->cb_color_info);
+                                             G_028C70_FORMAT_GFX6(surf->cb_color_info);
          swap = G_028C70_COMP_SWAP(surf->cb_color_info);
          spi_format = (spi_shader_col_format >> (i * 4)) & 0xf;
          colormask = (cb_target_mask >> (i * 4)) & 0xf;
 
          /* Set if RGB and A are present. */
          has_alpha = !(sctx->gfx_level >= GFX11 ? G_028C74_FORCE_DST_ALPHA_1_GFX11(surf->cb_color_attrib):
-                                                   G_028C74_FORCE_DST_ALPHA_1_GFX6(surf->cb_color_attrib));
+                                                  G_028C74_FORCE_DST_ALPHA_1_GFX6(surf->cb_color_attrib));
 
          if (format == V_028C70_COLOR_8 || format == V_028C70_COLOR_16 ||
              format == V_028C70_COLOR_32)
@@ -475,20 +475,21 @@ static void *si_create_blend_state_mode(struct pipe_context *ctx,
       color_control |= S_028808_ROP3(0xcc);
    }
 
+   unsigned db_alpha_to_mask;
    if (state->alpha_to_coverage && state->alpha_to_coverage_dither) {
-      si_pm4_set_reg(pm4, R_028B70_DB_ALPHA_TO_MASK,
-                     S_028B70_ALPHA_TO_MASK_ENABLE(state->alpha_to_coverage) |
-                        S_028B70_ALPHA_TO_MASK_OFFSET0(3) | S_028B70_ALPHA_TO_MASK_OFFSET1(1) |
-                        S_028B70_ALPHA_TO_MASK_OFFSET2(0) | S_028B70_ALPHA_TO_MASK_OFFSET3(2) |
-                        S_028B70_OFFSET_ROUND(1));
+      db_alpha_to_mask = S_028B70_ALPHA_TO_MASK_ENABLE(state->alpha_to_coverage) |
+                         S_028B70_ALPHA_TO_MASK_OFFSET0(3) | S_028B70_ALPHA_TO_MASK_OFFSET1(1) |
+                         S_028B70_ALPHA_TO_MASK_OFFSET2(0) | S_028B70_ALPHA_TO_MASK_OFFSET3(2) |
+                         S_028B70_OFFSET_ROUND(1);
    } else {
-      si_pm4_set_reg(pm4, R_028B70_DB_ALPHA_TO_MASK,
-                     S_028B70_ALPHA_TO_MASK_ENABLE(state->alpha_to_coverage) |
-                        S_028B70_ALPHA_TO_MASK_OFFSET0(2) | S_028B70_ALPHA_TO_MASK_OFFSET1(2) |
-                        S_028B70_ALPHA_TO_MASK_OFFSET2(2) | S_028B70_ALPHA_TO_MASK_OFFSET3(2) |
-                        S_028B70_OFFSET_ROUND(0));
+      db_alpha_to_mask = S_028B70_ALPHA_TO_MASK_ENABLE(state->alpha_to_coverage) |
+                         S_028B70_ALPHA_TO_MASK_OFFSET0(2) | S_028B70_ALPHA_TO_MASK_OFFSET1(2) |
+                         S_028B70_ALPHA_TO_MASK_OFFSET2(2) | S_028B70_ALPHA_TO_MASK_OFFSET3(2) |
+                         S_028B70_OFFSET_ROUND(0);
    }
 
+   si_pm4_set_reg(pm4, R_028B70_DB_ALPHA_TO_MASK, db_alpha_to_mask);
+
    blend->cb_target_mask = 0;
    blend->cb_target_enabled_4bit = 0;
 
@@ -973,10 +974,9 @@ static void *si_create_rs_state(struct pipe_context *ctx, const struct pipe_rast
    rs->polygon_mode_is_points =
       (state->fill_front == PIPE_POLYGON_MODE_POINT && !(state->cull_face & PIPE_FACE_FRONT)) ||
       (state->fill_back == PIPE_POLYGON_MODE_POINT && !(state->cull_face & PIPE_FACE_BACK));
-   rs->pa_sc_line_stipple = state->line_stipple_enable
-                               ? S_028A0C_LINE_PATTERN(state->line_stipple_pattern) |
-                                    S_028A0C_REPEAT_COUNT(state->line_stipple_factor)
-                               : 0;
+   rs->pa_sc_line_stipple = state->line_stipple_enable ?
+                               S_028A0C_LINE_PATTERN(state->line_stipple_pattern) |
+                               S_028A0C_REPEAT_COUNT(state->line_stipple_factor) : 0;
    /* TODO: implement line stippling with perpendicular end caps. */
    /* Line width > 2 is an internal recommendation. */
    rs->perpendicular_end_caps = state->multisample &&
@@ -1022,14 +1022,16 @@ static void *si_create_rs_state(struct pipe_context *ctx, const struct pipe_rast
       }
    }
 
-   si_pm4_set_reg(
-      pm4, R_0286D4_SPI_INTERP_CONTROL_0,
-      S_0286D4_FLAT_SHADE_ENA(1) | S_0286D4_PNT_SPRITE_ENA(state->point_quad_rasterization) |
-         S_0286D4_PNT_SPRITE_OVRD_X(V_0286D4_SPI_PNT_SPRITE_SEL_S) |
-         S_0286D4_PNT_SPRITE_OVRD_Y(V_0286D4_SPI_PNT_SPRITE_SEL_T) |
-         S_0286D4_PNT_SPRITE_OVRD_Z(V_0286D4_SPI_PNT_SPRITE_SEL_0) |
-         S_0286D4_PNT_SPRITE_OVRD_W(V_0286D4_SPI_PNT_SPRITE_SEL_1) |
-         S_0286D4_PNT_SPRITE_TOP_1(state->sprite_coord_mode != PIPE_SPRITE_COORD_UPPER_LEFT));
+   unsigned spi_interp_control_0 =
+      S_0286D4_FLAT_SHADE_ENA(1) |
+      S_0286D4_PNT_SPRITE_ENA(state->point_quad_rasterization) |
+      S_0286D4_PNT_SPRITE_OVRD_X(V_0286D4_SPI_PNT_SPRITE_SEL_S) |
+      S_0286D4_PNT_SPRITE_OVRD_Y(V_0286D4_SPI_PNT_SPRITE_SEL_T) |
+      S_0286D4_PNT_SPRITE_OVRD_Z(V_0286D4_SPI_PNT_SPRITE_SEL_0) |
+      S_0286D4_PNT_SPRITE_OVRD_W(V_0286D4_SPI_PNT_SPRITE_SEL_1) |
+      S_0286D4_PNT_SPRITE_TOP_1(state->sprite_coord_mode != PIPE_SPRITE_COORD_UPPER_LEFT);
+
+   si_pm4_set_reg(pm4, R_0286D4_SPI_INTERP_CONTROL_0, spi_interp_control_0);
 
    /* point size 12.4 fixed point */
    tmp = (unsigned)(state->point_size * 8.0);
@@ -1048,16 +1050,16 @@ static void *si_create_rs_state(struct pipe_context *ctx, const struct pipe_rast
    /* Divide by two, because 0.5 = 1 pixel. */
    si_pm4_set_reg(pm4, R_028A04_PA_SU_POINT_MINMAX,
                   S_028A04_MIN_SIZE(si_pack_float_12p4(psize_min / 2)) |
-                     S_028A04_MAX_SIZE(si_pack_float_12p4(psize_max / 2)));
-
+                  S_028A04_MAX_SIZE(si_pack_float_12p4(psize_max / 2)));
    si_pm4_set_reg(pm4, R_028A08_PA_SU_LINE_CNTL,
                   S_028A08_WIDTH(si_pack_float_12p4(state->line_width / 2)));
-   si_pm4_set_reg(
-      pm4, R_028A48_PA_SC_MODE_CNTL_0,
-      S_028A48_LINE_STIPPLE_ENABLE(state->line_stipple_enable) |
-         S_028A48_MSAA_ENABLE(state->multisample || state->poly_smooth || state->line_smooth) |
-         S_028A48_VPORT_SCISSOR_ENABLE(1) |
-         S_028A48_ALTERNATE_RBS_PER_TILE(sscreen->info.gfx_level >= GFX9));
+
+   si_pm4_set_reg(pm4, R_028A48_PA_SC_MODE_CNTL_0,
+                  S_028A48_LINE_STIPPLE_ENABLE(state->line_stipple_enable) |
+                  S_028A48_MSAA_ENABLE(state->multisample || state->poly_smooth ||
+                                       state->line_smooth) |
+                  S_028A48_VPORT_SCISSOR_ENABLE(1) |
+                  S_028A48_ALTERNATE_RBS_PER_TILE(sscreen->info.gfx_level >= GFX9));
 
    bool polygon_mode_enabled =
       (state->fill_front != PIPE_POLYGON_MODE_FILL && !(state->cull_face & PIPE_FACE_FRONT)) ||
@@ -1065,19 +1067,19 @@ static void *si_create_rs_state(struct pipe_context *ctx, const struct pipe_rast
 
    si_pm4_set_reg(pm4, R_028814_PA_SU_SC_MODE_CNTL,
                   S_028814_PROVOKING_VTX_LAST(!state->flatshade_first) |
-                     S_028814_CULL_FRONT((state->cull_face & PIPE_FACE_FRONT) ? 1 : 0) |
-                     S_028814_CULL_BACK((state->cull_face & PIPE_FACE_BACK) ? 1 : 0) |
-                     S_028814_FACE(!state->front_ccw) |
-                     S_028814_POLY_OFFSET_FRONT_ENABLE(util_get_offset(state, state->fill_front)) |
-                     S_028814_POLY_OFFSET_BACK_ENABLE(util_get_offset(state, state->fill_back)) |
-                     S_028814_POLY_OFFSET_PARA_ENABLE(state->offset_point || state->offset_line) |
-                     S_028814_POLY_MODE(polygon_mode_enabled) |
-                     S_028814_POLYMODE_FRONT_PTYPE(si_translate_fill(state->fill_front)) |
-                     S_028814_POLYMODE_BACK_PTYPE(si_translate_fill(state->fill_back)) |
-                     /* this must be set if POLY_MODE or PERPENDICULAR_ENDCAP_ENA is set */
-                     S_028814_KEEP_TOGETHER_ENABLE(sscreen->info.gfx_level >= GFX10 ?
-                                                      polygon_mode_enabled ||
-                                                      rs->perpendicular_end_caps : 0));
+                  S_028814_CULL_FRONT((state->cull_face & PIPE_FACE_FRONT) ? 1 : 0) |
+                  S_028814_CULL_BACK((state->cull_face & PIPE_FACE_BACK) ? 1 : 0) |
+                  S_028814_FACE(!state->front_ccw) |
+                  S_028814_POLY_OFFSET_FRONT_ENABLE(util_get_offset(state, state->fill_front)) |
+                  S_028814_POLY_OFFSET_BACK_ENABLE(util_get_offset(state, state->fill_back)) |
+                  S_028814_POLY_OFFSET_PARA_ENABLE(state->offset_point || state->offset_line) |
+                  S_028814_POLY_MODE(polygon_mode_enabled) |
+                  S_028814_POLYMODE_FRONT_PTYPE(si_translate_fill(state->fill_front)) |
+                  S_028814_POLYMODE_BACK_PTYPE(si_translate_fill(state->fill_back)) |
+                  /* this must be set if POLY_MODE or PERPENDICULAR_ENDCAP_ENA is set */
+                  S_028814_KEEP_TOGETHER_ENABLE(sscreen->info.gfx_level >= GFX10 ?
+                                                   polygon_mode_enabled ||
+                                                   rs->perpendicular_end_caps : 0));
 
    if (state->bottom_edge_rule) {
       /* OpenGL windows should set this. */
diff --git a/src/gallium/drivers/radeonsi/si_state_viewport.c b/src/gallium/drivers/radeonsi/si_state_viewport.c
index 00e044bfb083..d32be3f6041f 100644
--- a/src/gallium/drivers/radeonsi/si_state_viewport.c
+++ b/src/gallium/drivers/radeonsi/si_state_viewport.c
@@ -641,7 +641,7 @@ static void si_emit_window_rectangles(struct si_context *sctx)
    static const unsigned outside[4] = {
       /* outside rectangle 0 */
       V_02820C_OUT | V_02820C_IN_1 | V_02820C_IN_2 | V_02820C_IN_21 | V_02820C_IN_3 |
-         V_02820C_IN_31 | V_02820C_IN_32 | V_02820C_IN_321,
+      V_02820C_IN_31 | V_02820C_IN_32 | V_02820C_IN_321,
       /* outside rectangles 0, 1 */
       V_02820C_OUT | V_02820C_IN_2 | V_02820C_IN_3 | V_02820C_IN_32,
       /* outside rectangles 0, 1, 2 */
-- 
GitLab


From 20904747437884d929b3e1f5b07d12e0d236dd69 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 23:46:46 -0500
Subject: [PATCH 21/45] radeonsi: remove a gfx11 check in si_shader_gs (legacy
 GS)

Gfx11 doesn't support legacy GS.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 0daa4866705e..69caae8e18e0 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -1127,9 +1127,8 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
 
       shader->gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
                                            S_00B21C_WAVE_LIMIT(0x3F);
-      shader->gs.spi_shader_pgm_rsrc4_gs =
-         (sscreen->info.gfx_level >= GFX11 ? S_00B204_CU_EN_GFX11(1) : S_00B204_CU_EN_GFX10(0xffff)) |
-         S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0);
+      shader->gs.spi_shader_pgm_rsrc4_gs = S_00B204_CU_EN_GFX10(0xffff) |
+                                           S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0);
 
       shader->gs.vgt_gs_onchip_cntl =
          S_028A44_ES_VERTS_PER_SUBGRP(shader->gs_info.es_verts_per_subgroup) |
-- 
GitLab


From 85c03637553fa2177c323653a583a36cc782e8ed Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 00:13:35 -0500
Subject: [PATCH 22/45] radeonsi: remove unused VS_STATE_LS_OUT_PATCH_SIZE

This became unused when we switched to nir_lower_hs_inputs_to_mem.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_shader.h          | 2 --
 src/gallium/drivers/radeonsi/si_shader_internal.h | 2 --
 src/gallium/drivers/radeonsi/si_state_draw.cpp    | 6 +-----
 3 files changed, 1 insertion(+), 9 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 9f068057ae66..91786572033a 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -259,8 +259,6 @@ enum
  * in the shader via vs_state_bits in LS/HS.
  */
 /* bit gap */
-#define VS_STATE_LS_OUT_PATCH_SIZE__SHIFT    11
-#define VS_STATE_LS_OUT_PATCH_SIZE__MASK     0x1fff
 #define VS_STATE_LS_OUT_VERTEX_SIZE__SHIFT   24
 #define VS_STATE_LS_OUT_VERTEX_SIZE__MASK    0xff
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 1302f5b05d1f..d9cd6b6fd7c4 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -63,8 +63,6 @@ struct si_shader_args {
     *            Expand to FP32 like this: ((0x70 | value) << 23);
     *            With 0x70 = 112, we get 2^(112 + value - 127) = 2^(value - 15)
     *            = 1/2^(15 - value) in FP32
-    *   [11:23] = stride between patches in DW = num_inputs * num_vertices * 4
-    *             max = 32*32*4 + 32*4
     *   [24:31] = stride between vertices in DW = num_inputs * 4
     *             max = 32*4
     */
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 5f72b7f7cd77..8204d9e1e54e 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -782,7 +782,6 @@ static void si_emit_derived_tess_state(struct si_context *sctx)
    /* Compute userdata SGPRs. */
    assert(((input_vertex_size / 4) & ~0xff) == 0);
    assert(((output_vertex_size / 4) & ~0xff) == 0);
-   assert(((input_patch_size / 4) & ~0x1fff) == 0);
    assert(((output_patch_size / 4) & ~0x1fff) == 0);
    assert(((output_patch0_offset / 4) & ~0xffff) == 0);
    assert(((perpatch_output_offset / 4) & ~0xffff) == 0);
@@ -813,7 +812,6 @@ static void si_emit_derived_tess_state(struct si_context *sctx)
    }
 
    /* Set SI_SGPR_VS_STATE_BITS. */
-   SET_FIELD(sctx->current_vs_state, VS_STATE_LS_OUT_PATCH_SIZE, input_patch_size / 4);
    SET_FIELD(sctx->current_vs_state, VS_STATE_LS_OUT_VERTEX_SIZE, input_vertex_size / 4);
 
    /* We should be able to support in-shader LDS use with LLVM >= 9
@@ -1197,9 +1195,7 @@ static void si_emit_vs_state(struct si_context *sctx, unsigned index_size)
       vs_state |= ENCODE_FIELD(VS_STATE_INDEXED, 1);
 
    /* Copy all state bits from vs_state to gs_state except the LS bits. */
-   gs_state |= vs_state &
-               CLEAR_FIELD(VS_STATE_LS_OUT_PATCH_SIZE) &
-               CLEAR_FIELD(VS_STATE_LS_OUT_VERTEX_SIZE);
+   gs_state |= vs_state & CLEAR_FIELD(VS_STATE_LS_OUT_VERTEX_SIZE);
 
    if (vs_state != sctx->last_vs_state ||
        ((HAS_GS || NGG) && gs_state != sctx->last_gs_state)) {
-- 
GitLab


From 7b8e5f1089437fffaef888fd877870577af7b572 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 00:22:48 -0500
Subject: [PATCH 23/45] radeonsi: always add 1 to lshs_vertex_stride now that
 LS_OUT_PATCH_SIZE is gone

LS_OUT_PATCH_SIZE limited the maximum value.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_shader_info.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index 68dc0f8205db..f17eea1123fb 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -783,11 +783,10 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
       /* Add 1 dword to reduce LDS bank conflicts, so that each vertex
        * will start on a different bank. (except for the maximum 32*16).
        */
-      if (info->lshs_vertex_stride < 32 * 16)
-         info->lshs_vertex_stride += 4;
+      info->lshs_vertex_stride += 4;
 
       /* For the ESGS ring in LDS, add 1 dword to reduce LDS bank
-       * conflicts, i.e. each vertex will start at a different bank.
+       * conflicts, i.e. each vertex will start on a different bank.
        */
       if (sscreen->info.gfx_level >= GFX9)
          info->esgs_itemsize += 4;
-- 
GitLab


From 61600377974dbf32752f2474229b0a0e2d01da8e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 00:25:01 -0500
Subject: [PATCH 24/45] radeonsi: correct and clean up obsolete vs_state_bits
 comments

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_shader.h        |  9 ++++++++-
 .../drivers/radeonsi/si_shader_internal.h       | 17 +----------------
 2 files changed, 9 insertions(+), 17 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 91786572033a..2dfcb1704431 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -260,12 +260,19 @@ enum
  */
 /* bit gap */
 #define VS_STATE_LS_OUT_VERTEX_SIZE__SHIFT   24
-#define VS_STATE_LS_OUT_VERTEX_SIZE__MASK    0xff
+#define VS_STATE_LS_OUT_VERTEX_SIZE__MASK    0xff /* max 32 * 4 + 1 */
 
 /* These fields are only set in current_gs_state in si_context, and they are accessible
  * in the shader via vs_state_bits in legacy GS, the GS copy shader, and any NGG shader.
  */
 /* bit gap */
+/* Small prim filter precision = num_samples / quant_mode, which can only be equal to 1/2^n
+ * where n is between 4 and 12. Knowing that, we only need to store 4 bits of the FP32 exponent.
+ * Set it like this: value = (fui(num_samples / quant_mode) >> 23) & 0xf;
+ * Expand to FP32 like this: ((0x70 | value) << 23);
+ * With 0x70 = 112, we get 2^(112 + value - 127) = 2^(value - 15), which is always a negative
+ * exponent and it's equal to 1/2^(15 - value).
+ */
 #define GS_STATE_SMALL_PRIM_PRECISION_NO_AA__SHIFT 18
 #define GS_STATE_SMALL_PRIM_PRECISION_NO_AA__MASK  0xf
 #define GS_STATE_SMALL_PRIM_PRECISION__SHIFT    22
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index d9cd6b6fd7c4..a37bef22f82c 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -50,22 +50,7 @@ struct si_shader_args {
    /* API VS */
    struct ac_arg vb_descriptors[5];
    struct ac_arg vertex_index0;
-   /* VS states and layout of LS outputs / TCS inputs at the end
-    *   [0] = clamp vertex color
-    *   [1] = indexed
-    *   [2:3] = NGG: output primitive type
-    *   [4:5] = NGG: provoking vertex index
-    *   [6]   = NGG: streamout queries enabled
-    *   [7:10] = NGG: small prim filter precision = num_samples / quant_mode,
-    *            but in reality it's: 1/2^n, from 1/16 to 1/4096 = 1/2^4 to 1/2^12
-    *            Only the first 4 bits of the exponent are stored.
-    *            Set it like this: (fui(num_samples / quant_mode) >> 23)
-    *            Expand to FP32 like this: ((0x70 | value) << 23);
-    *            With 0x70 = 112, we get 2^(112 + value - 127) = 2^(value - 15)
-    *            = 1/2^(15 - value) in FP32
-    *   [24:31] = stride between vertices in DW = num_inputs * 4
-    *             max = 32*4
-    */
+   /* VS state bits. See the VS_STATE_* and GS_STATE_* definitions. */
    struct ac_arg vs_state_bits;
    struct ac_arg vs_blit_inputs;
 
-- 
GitLab


From c0b94f29adddf7a0213e3b98749d69519d57417d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 00:26:15 -0500
Subject: [PATCH 25/45] radeonsi: rename esgs_itemsize -> esgs_vertex_stride

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/gfx10_shader_ngg.c   |  2 +-
 src/gallium/drivers/radeonsi/si_shader.c          |  6 +++---
 src/gallium/drivers/radeonsi/si_shader.h          |  2 +-
 src/gallium/drivers/radeonsi/si_shader_info.c     |  8 ++++----
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 12 ++++++------
 5 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 64b24caff09d..64186055e269 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -140,7 +140,7 @@ retry_select_mode:
          max_out_verts_per_gsprim = gs_sel->info.base.gs.vertices_out;
       }
 
-      esvert_lds_size = es_sel->info.esgs_itemsize / 4;
+      esvert_lds_size = es_sel->info.esgs_vertex_stride / 4;
       gsprim_lds_size = (gs_sel->info.gsvs_vertex_size / 4 + 1) * max_out_verts_per_gsprim;
 
       if (gsprim_lds_size > target_lds_size && !force_multi_cycling) {
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 0d92b9a72a93..91a6e1e6ff10 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1066,7 +1066,7 @@ void si_shader_dump_stats_for_shader_db(struct si_screen *screen, struct si_shad
       if (shader->gs_copy_shader)
          num_outputs = shader->gs_copy_shader->info.nr_param_exports;
       else if (shader->key.ge.as_es)
-         num_outputs = shader->selector->info.esgs_itemsize / 16;
+         num_outputs = shader->selector->info.esgs_vertex_stride / 16;
       else if (shader->key.ge.as_ls)
          num_outputs = shader->selector->info.lshs_vertex_stride / 16;
       else if (shader->selector->stage == MESA_SHADER_VERTEX ||
@@ -1562,7 +1562,7 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
          return true;
       } else if (key->ge.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, si_map_io_driver_location,
-                    sel->screen->info.gfx_level, sel->info.esgs_itemsize);
+                    sel->screen->info.gfx_level, sel->info.esgs_vertex_stride);
          return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
@@ -1585,7 +1585,7 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
 
       if (key->ge.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, si_map_io_driver_location,
-                    sel->screen->info.gfx_level, sel->info.esgs_itemsize);
+                    sel->screen->info.gfx_level, sel->info.esgs_vertex_stride);
       }
 
       return true;
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 2dfcb1704431..793d405b9eb4 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -405,7 +405,7 @@ struct si_shader_info {
    ubyte culldist_mask;
 
    uint16_t lshs_vertex_stride;
-   uint16_t esgs_itemsize; /* vertex stride */
+   uint16_t esgs_vertex_stride;
    uint16_t gsvs_vertex_size;
    ubyte gs_input_verts_per_prim;
    unsigned max_gsvs_emit_size;
diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index f17eea1123fb..77cd7d57bf5d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -777,8 +777,8 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
    if (nir->info.stage == MESA_SHADER_VERTEX ||
        nir->info.stage == MESA_SHADER_TESS_CTRL ||
        nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      info->esgs_itemsize = util_last_bit64(info->outputs_written) * 16;
-      info->lshs_vertex_stride = info->esgs_itemsize;
+      info->esgs_vertex_stride = util_last_bit64(info->outputs_written) * 16;
+      info->lshs_vertex_stride = info->esgs_vertex_stride;
 
       /* Add 1 dword to reduce LDS bank conflicts, so that each vertex
        * will start on a different bank. (except for the maximum 32*16).
@@ -789,9 +789,9 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
        * conflicts, i.e. each vertex will start on a different bank.
        */
       if (sscreen->info.gfx_level >= GFX9)
-         info->esgs_itemsize += 4;
+         info->esgs_vertex_stride += 4;
 
-      assert(((info->esgs_itemsize / 4) & C_028AAC_ITEMSIZE) == 0);
+      assert(((info->esgs_vertex_stride / 4) & C_028AAC_ITEMSIZE) == 0);
 
       info->tcs_vgpr_only_inputs = ~info->base.tess.tcs_cross_invocation_inputs_read &
                                    ~info->base.inputs_read_indirectly &
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 69caae8e18e0..9d5b3a38e1bb 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -771,7 +771,7 @@ static void si_emit_shader_es(struct si_context *sctx)
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
                               SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                              shader->selector->info.esgs_itemsize / 4);
+                              shader->selector->info.esgs_vertex_stride / 4);
 
    if (shader->selector->stage == MESA_SHADER_TESS_EVAL)
       radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
@@ -843,7 +843,7 @@ void gfx9_get_gs_info(struct si_shader_selector *es, struct si_shader_selector *
    /* We can't allow using the whole LDS, because GS waves compete with
     * other shader stages for LDS space. */
    const unsigned max_lds_size = 8 * 1024;
-   const unsigned esgs_itemsize = es->info.esgs_itemsize / 4;
+   const unsigned esgs_itemsize = es->info.esgs_vertex_stride / 4;
    unsigned esgs_lds_size;
 
    /* All these are per subgroup: */
@@ -1136,7 +1136,7 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
          S_028A44_GS_INST_PRIMS_IN_SUBGRP(shader->gs_info.gs_inst_prims_in_subgroup);
       shader->gs.vgt_gs_max_prims_per_subgroup =
          S_028A94_MAX_PRIMS_PER_SUBGROUP(shader->gs_info.max_prims_per_subgroup);
-      shader->gs.vgt_esgs_ring_itemsize = shader->key.ge.part.gs.es->info.esgs_itemsize / 4;
+      shader->gs.vgt_esgs_ring_itemsize = shader->key.ge.part.gs.es->info.esgs_vertex_stride / 4;
 
       if (es_stage == MESA_SHADER_TESS_EVAL)
          si_set_tesseval_regs(sscreen, shader->key.ge.part.gs.es, shader);
@@ -1472,7 +1472,7 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                                         gs_sel->info.writes_primid);
 
    if (gs_stage == MESA_SHADER_GEOMETRY) {
-      shader->ngg.vgt_esgs_ring_itemsize = es_sel->info.esgs_itemsize / 4;
+      shader->ngg.vgt_esgs_ring_itemsize = es_sel->info.esgs_vertex_stride / 4;
       shader->ngg.vgt_gs_max_vert_out = gs_sel->info.base.gs.vertices_out;
    } else {
       shader->ngg.vgt_esgs_ring_itemsize = 1;
@@ -3825,11 +3825,11 @@ bool si_update_gs_ring_buffers(struct si_context *sctx)
    unsigned max_size = ((unsigned)(63.999 * 1024 * 1024) & ~255) * num_se;
 
    /* Calculate the minimum size. */
-   unsigned min_esgs_ring_size = align(es->info.esgs_itemsize * gs_vertex_reuse * wave_size, alignment);
+   unsigned min_esgs_ring_size = align(es->info.esgs_vertex_stride * gs_vertex_reuse * wave_size, alignment);
 
    /* These are recommended sizes, not minimum sizes. */
    unsigned esgs_ring_size =
-      max_gs_waves * 2 * wave_size * es->info.esgs_itemsize * gs->info.gs_input_verts_per_prim;
+      max_gs_waves * 2 * wave_size * es->info.esgs_vertex_stride * gs->info.gs_input_verts_per_prim;
    unsigned gsvs_ring_size = max_gs_waves * 2 * wave_size * gs->info.max_gsvs_emit_size;
 
    min_esgs_ring_size = align(min_esgs_ring_size, alignment);
-- 
GitLab


From 02ce0adc184a55d30828986c0a3b80f2fdd97f64 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Jan 2023 20:31:19 -0500
Subject: [PATCH 26/45] amd: query the per-SIMD VGPR counts from the kernel,
 don't hardcode them

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/common/ac_gpu_info.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 47665e2f11cd..f47d007549de 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1331,12 +1331,14 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
       info->wave64_vgpr_alloc_granularity = 4;
    }
 
-   if (info->family == CHIP_GFX1100 || info->family == CHIP_GFX1101)
-      info->num_physical_wave64_vgprs_per_simd = 768;
+   /* Some GPU info was broken before DRM 3.45.0. */
+   if (info->drm_minor >= 45 && device_info.num_shader_visible_vgprs)
+      info->num_physical_wave64_vgprs_per_simd = device_info.num_shader_visible_vgprs / 2;
    else if (info->gfx_level >= GFX10)
       info->num_physical_wave64_vgprs_per_simd = 512;
    else
       info->num_physical_wave64_vgprs_per_simd = 256;
+
    info->num_simd_per_compute_unit = info->gfx_level >= GFX10 ? 2 : 4;
 
    /* BIG_PAGE is supported since gfx10.3 and requires VRAM. VRAM is only guaranteed
-- 
GitLab


From e75f3f2e8d7dd463ec1b1d2ca0b62df3b6cd3f83 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 04:33:38 -0500
Subject: [PATCH 27/45] radeonsi: don't clamp z_samples to fix Unreal
 Tournament 99

Fixes: a29218b5 - radeonsi/gfx11: always set MSAA_NUM_SAMPLES=0 for DCC_DECOMPRESS
Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/8261

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 22ff26b1ee73..78db825e708a 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -3857,7 +3857,7 @@ static void si_emit_msaa_config(struct si_context *sctx)
        sctx->smoothing_enabled) {
       if (sctx->framebuffer.state.zsbuf) {
          z_samples = sctx->framebuffer.state.zsbuf->texture->nr_samples;
-         z_samples = MIN2(MAX2(1, z_samples), coverage_samples);
+         z_samples = MAX2(1, z_samples);
       } else {
          z_samples = coverage_samples;
       }
-- 
GitLab


From 6eda8a47c96084c5a5e26c2fff5592f3494b9e82 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 4 Feb 2023 19:06:14 -0500
Subject: [PATCH 28/45] amd/registers: only define SPI and COMPUTE registers in
 the 0xB000 range

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/registers/gfx103.json             |  10 -
 src/amd/registers/gfx11.json              | 780 ----------------------
 src/amd/registers/parse_kernel_headers.py |   4 +-
 3 files changed, 3 insertions(+), 791 deletions(-)

diff --git a/src/amd/registers/gfx103.json b/src/amd/registers/gfx103.json
index 395c6918e033..2f5f1b6723dd 100644
--- a/src/amd/registers/gfx103.json
+++ b/src/amd/registers/gfx103.json
@@ -2753,16 +2753,6 @@
    "map": {"at": 47612, "to": "mm"},
    "name": "COMPUTE_NOWHERE"
   },
-  {
-   "chips": ["gfx103"],
-   "map": {"at": 47616, "to": "mm"},
-   "name": "SH_RESERVED_REG0"
-  },
-  {
-   "chips": ["gfx103"],
-   "map": {"at": 47620, "to": "mm"},
-   "name": "SH_RESERVED_REG1"
-  },
   {
    "chips": ["gfx103"],
    "map": {"at": 163840, "to": "mm"},
diff --git a/src/amd/registers/gfx11.json b/src/amd/registers/gfx11.json
index 60e15b79d719..8aa6a526f86d 100644
--- a/src/amd/registers/gfx11.json
+++ b/src/amd/registers/gfx11.json
@@ -1293,42 +1293,12 @@
    "name": "GB_ADDR_CONFIG",
    "type_ref": "GB_ADDR_CONFIG"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45056, "to": "mm"},
-   "name": "GUS_IO_RD_COMBINE_FLUSH",
-   "type_ref": "GUS_IO_RD_COMBINE_FLUSH"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 45060, "to": "mm"},
    "name": "SPI_SHADER_PGM_RSRC4_PS",
    "type_ref": "SPI_SHADER_PGM_RSRC4_PS"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45064, "to": "mm"},
-   "name": "GUS_IO_RD_PRI_AGE_RATE",
-   "type_ref": "GUS_IO_RD_PRI_AGE_RATE"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45068, "to": "mm"},
-   "name": "GUS_IO_WR_PRI_AGE_RATE",
-   "type_ref": "GUS_IO_RD_PRI_AGE_RATE"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45072, "to": "mm"},
-   "name": "GUS_IO_RD_PRI_AGE_COEFF",
-   "type_ref": "GUS_IO_RD_PRI_AGE_COEFF"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45076, "to": "mm"},
-   "name": "GUS_IO_WR_PRI_AGE_COEFF",
-   "type_ref": "GUS_IO_RD_PRI_AGE_COEFF"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 45080, "to": "mm"},
@@ -1523,42 +1493,12 @@
    "map": {"at": 45228, "to": "mm"},
    "name": "SPI_SHADER_USER_DATA_PS_31"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45232, "to": "mm"},
-   "name": "GUS_DRAM_PRI_QUANT1_PRI2",
-   "type_ref": "GUS_DRAM_PRI_QUANT1_PRI2"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45236, "to": "mm"},
-   "name": "GUS_DRAM_PRI_QUANT1_PRI3",
-   "type_ref": "GUS_DRAM_PRI_QUANT1_PRI2"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45240, "to": "mm"},
-   "name": "GUS_DRAM_PRI_QUANT1_PRI4",
-   "type_ref": "GUS_DRAM_PRI_QUANT1_PRI2"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45244, "to": "mm"},
-   "name": "GUS_DRAM_PRI_QUANT1_PRI5",
-   "type_ref": "GUS_DRAM_PRI_QUANT1_PRI2"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 45248, "to": "mm"},
    "name": "SPI_SHADER_REQ_CTRL_PS",
    "type_ref": "SPI_SHADER_REQ_CTRL_PS"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45252, "to": "mm"},
-   "name": "GUS_DRAM_GROUP_BURST",
-   "type_ref": "GUS_DRAM_GROUP_BURST"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 45256, "to": "mm"},
@@ -1583,264 +1523,6 @@
    "name": "SPI_SHADER_USER_ACCUM_PS_3",
    "type_ref": "SPI_SHADER_USER_ACCUM_PS_0"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45272, "to": "mm"},
-   "name": "GUS_SDP_TAG_RESERVE1",
-   "type_ref": "GUS_SDP_TAG_RESERVE1"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45276, "to": "mm"},
-   "name": "GUS_SDP_VCC_RESERVE0",
-   "type_ref": "GUS_SDP_VCC_RESERVE0"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45280, "to": "mm"},
-   "name": "GUS_SDP_VCC_RESERVE1",
-   "type_ref": "GUS_SDP_VCC_RESERVE1"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45284, "to": "mm"},
-   "name": "GUS_SDP_VCD_RESERVE0",
-   "type_ref": "GUS_SDP_VCC_RESERVE0"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45288, "to": "mm"},
-   "name": "GUS_SDP_VCD_RESERVE1",
-   "type_ref": "GUS_SDP_VCC_RESERVE1"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45292, "to": "mm"},
-   "name": "GUS_SDP_REQ_CNTL",
-   "type_ref": "GUS_SDP_REQ_CNTL"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45296, "to": "mm"},
-   "name": "GUS_MISC",
-   "type_ref": "GUS_MISC"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45300, "to": "mm"},
-   "name": "GUS_LATENCY_SAMPLING",
-   "type_ref": "GUS_LATENCY_SAMPLING"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45304, "to": "mm"},
-   "name": "GUS_ERR_STATUS",
-   "type_ref": "GUS_ERR_STATUS"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45308, "to": "mm"},
-   "name": "GUS_MISC2",
-   "type_ref": "GUS_MISC2"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45332, "to": "mm"},
-   "name": "GUS_SDP_ENABLE",
-   "type_ref": "GUS_SDP_ENABLE"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45336, "to": "mm"},
-   "name": "GUS_L1_CH0_CMD_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45340, "to": "mm"},
-   "name": "GUS_L1_CH0_CMD_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45344, "to": "mm"},
-   "name": "GUS_L1_CH0_DATA_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45348, "to": "mm"},
-   "name": "GUS_L1_CH0_DATA_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45352, "to": "mm"},
-   "name": "GUS_L1_CH0_DATA_U_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45356, "to": "mm"},
-   "name": "GUS_L1_CH0_DATA_U_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45360, "to": "mm"},
-   "name": "GUS_L1_CH1_CMD_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45364, "to": "mm"},
-   "name": "GUS_L1_CH1_CMD_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45368, "to": "mm"},
-   "name": "GUS_L1_CH1_DATA_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45372, "to": "mm"},
-   "name": "GUS_L1_CH1_DATA_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45376, "to": "mm"},
-   "name": "GUS_L1_CH1_DATA_U_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45380, "to": "mm"},
-   "name": "GUS_L1_CH1_DATA_U_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45384, "to": "mm"},
-   "name": "GUS_L1_SA0_CMD_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45388, "to": "mm"},
-   "name": "GUS_L1_SA0_CMD_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45392, "to": "mm"},
-   "name": "GUS_L1_SA0_DATA_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45396, "to": "mm"},
-   "name": "GUS_L1_SA0_DATA_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45400, "to": "mm"},
-   "name": "GUS_L1_SA0_DATA_U_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45404, "to": "mm"},
-   "name": "GUS_L1_SA0_DATA_U_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45408, "to": "mm"},
-   "name": "GUS_L1_SA1_CMD_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45412, "to": "mm"},
-   "name": "GUS_L1_SA1_CMD_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45416, "to": "mm"},
-   "name": "GUS_L1_SA1_DATA_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45420, "to": "mm"},
-   "name": "GUS_L1_SA1_DATA_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45424, "to": "mm"},
-   "name": "GUS_L1_SA1_DATA_U_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45428, "to": "mm"},
-   "name": "GUS_L1_SA1_DATA_U_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45432, "to": "mm"},
-   "name": "GUS_L1_SA2_CMD_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45436, "to": "mm"},
-   "name": "GUS_L1_SA2_CMD_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45440, "to": "mm"},
-   "name": "GUS_L1_SA2_DATA_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45444, "to": "mm"},
-   "name": "GUS_L1_SA2_DATA_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45448, "to": "mm"},
-   "name": "GUS_L1_SA2_DATA_U_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45452, "to": "mm"},
-   "name": "GUS_L1_SA2_DATA_U_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45456, "to": "mm"},
-   "name": "GUS_L1_SA3_CMD_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45460, "to": "mm"},
-   "name": "GUS_L1_SA3_CMD_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45464, "to": "mm"},
-   "name": "GUS_L1_SA3_DATA_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45468, "to": "mm"},
-   "name": "GUS_L1_SA3_DATA_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45472, "to": "mm"},
-   "name": "GUS_L1_SA3_DATA_U_IN"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45476, "to": "mm"},
-   "name": "GUS_L1_SA3_DATA_U_OUT"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45480, "to": "mm"},
-   "name": "GUS_MISC3",
-   "type_ref": "GUS_MISC3"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 45484, "to": "mm"},
-   "name": "GUS_WRRSP_FIFO_CNTL",
-   "type_ref": "GUS_WRRSP_FIFO_CNTL"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 45568, "to": "mm"},
@@ -2364,36 +2046,6 @@
    "name": "SPI_SHADER_USER_ACCUM_LSHS_3",
    "type_ref": "SPI_SHADER_USER_ACCUM_PS_0"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46340, "to": "mm"},
-   "name": "GL1C_STATUS",
-   "type_ref": "GL1C_STATUS"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46344, "to": "mm"},
-   "name": "GL1C_UTCL0_CNTL1",
-   "type_ref": "GL1C_UTCL0_CNTL1"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46348, "to": "mm"},
-   "name": "GL1C_UTCL0_CNTL2",
-   "type_ref": "GL1C_UTCL0_CNTL2"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46352, "to": "mm"},
-   "name": "GL1C_UTCL0_STATUS",
-   "type_ref": "GL1C_UTCL0_STATUS"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46356, "to": "mm"},
-   "name": "GL1C_UTCL0_RETRY",
-   "type_ref": "GL1C_UTCL0_RETRY"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 46368, "to": "mm"},
@@ -2405,78 +2057,6 @@
    "name": "SPI_SHADER_PGM_HI_LS",
    "type_ref": "SPI_SHADER_PGM_HI_PS"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46592, "to": "mm"},
-   "name": "CH_ARB_CTRL",
-   "type_ref": "CH_ARB_CTRL"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46600, "to": "mm"},
-   "name": "CH_DRAM_BURST_MASK",
-   "type_ref": "CH_DRAM_BURST_MASK"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46604, "to": "mm"},
-   "name": "CH_ARB_STATUS",
-   "type_ref": "CH_ARB_STATUS"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46608, "to": "mm"},
-   "name": "CH_DRAM_BURST_CTRL",
-   "type_ref": "CH_DRAM_BURST_CTRL"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46624, "to": "mm"},
-   "name": "CHA_CHC_CREDITS",
-   "type_ref": "CHA_CHC_CREDITS"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46628, "to": "mm"},
-   "name": "CHA_CLIENT_FREE_DELAY",
-   "type_ref": "CHA_CLIENT_FREE_DELAY"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46640, "to": "mm"},
-   "name": "CHI_CHR_REP_FGCG_OVERRIDE",
-   "type_ref": "CHI_CHR_REP_FGCG_OVERRIDE"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46672, "to": "mm"},
-   "name": "CH_VC5_ENABLE",
-   "type_ref": "CH_VC5_ENABLE"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46848, "to": "mm"},
-   "name": "CHC_CTRL",
-   "type_ref": "CHC_CTRL"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46852, "to": "mm"},
-   "name": "CHC_STATUS",
-   "type_ref": "CHC_STATUS"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46856, "to": "mm"},
-   "name": "CHCG_CTRL",
-   "type_ref": "CHCG_CTRL"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 46860, "to": "mm"},
-   "name": "CHCG_STATUS",
-   "type_ref": "CHCG_STATUS"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 47104, "to": "mm"},
@@ -2669,11 +2249,6 @@
    "name": "COMPUTE_REQ_CTRL",
    "type_ref": "COMPUTE_REQ_CTRL"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 47244, "to": "mm"},
-   "name": "GL2A_PRIORITY_CTRL"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 47248, "to": "mm"},
@@ -2864,16 +2439,6 @@
    "map": {"at": 47612, "to": "mm"},
    "name": "COMPUTE_NOWHERE"
   },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 47616, "to": "mm"},
-   "name": "SH_RESERVED_REG0"
-  },
-  {
-   "chips": ["gfx11"],
-   "map": {"at": 47620, "to": "mm"},
-   "name": "SH_RESERVED_REG1"
-  },
   {
    "chips": ["gfx11"],
    "map": {"at": 163840, "to": "mm"},
@@ -11034,127 +10599,6 @@
     {"bits": [28, 31], "name": "TARGET7_ENABLE"}
    ]
   },
-  "CHA_CHC_CREDITS": {
-   "fields": [
-    {"bits": [0, 7], "name": "CHC_REQ_CREDITS"},
-    {"bits": [8, 15], "name": "CHCG_REQ_CREDITS"}
-   ]
-  },
-  "CHA_CLIENT_FREE_DELAY": {
-   "fields": [
-    {"bits": [0, 2], "name": "CLIENT_TYPE_0_FREE_DELAY"},
-    {"bits": [3, 5], "name": "CLIENT_TYPE_1_FREE_DELAY"},
-    {"bits": [6, 8], "name": "CLIENT_TYPE_2_FREE_DELAY"},
-    {"bits": [9, 11], "name": "CLIENT_TYPE_3_FREE_DELAY"},
-    {"bits": [12, 14], "name": "CLIENT_TYPE_4_FREE_DELAY"}
-   ]
-  },
-  "CHCG_CTRL": {
-   "fields": [
-    {"bits": [0, 3], "name": "BUFFER_DEPTH_MAX"},
-    {"bits": [4, 7], "name": "VC0_BUFFER_DEPTH_MAX"},
-    {"bits": [8, 14], "name": "GL2_REQ_CREDITS"},
-    {"bits": [15, 21], "name": "GL2_DATA_CREDITS"},
-    {"bits": [22, 22], "name": "TO_L1_REPEATER_FGCG_DISABLE"},
-    {"bits": [23, 23], "name": "TO_L2_REPEATER_FGCG_DISABLE"}
-   ]
-  },
-  "CHCG_STATUS": {
-   "fields": [
-    {"bits": [0, 0], "name": "INPUT_BUFFER_VC0_FIFO_FULL"},
-    {"bits": [1, 1], "name": "OUTPUT_FIFOS_BUSY"},
-    {"bits": [2, 2], "name": "SRC_DATA_FIFO_VC0_FULL"},
-    {"bits": [3, 3], "name": "GL2_REQ_VC0_STALL"},
-    {"bits": [4, 4], "name": "GL2_DATA_VC0_STALL"},
-    {"bits": [5, 5], "name": "GL2_REQ_VC1_STALL"},
-    {"bits": [6, 6], "name": "GL2_DATA_VC1_STALL"},
-    {"bits": [7, 7], "name": "INPUT_BUFFER_VC0_BUSY"},
-    {"bits": [8, 8], "name": "SRC_DATA_FIFO_VC0_BUSY"},
-    {"bits": [9, 9], "name": "GL2_RH_BUSY"},
-    {"bits": [10, 19], "name": "NUM_REQ_PENDING_FROM_L2"},
-    {"bits": [20, 20], "name": "VIRTUAL_FIFO_FULL_STALL"},
-    {"bits": [21, 21], "name": "REQUEST_TRACKER_BUFFER_STALL"},
-    {"bits": [22, 22], "name": "REQUEST_TRACKER_BUSY"},
-    {"bits": [23, 23], "name": "BUFFER_FULL"},
-    {"bits": [24, 24], "name": "INPUT_BUFFER_VC1_BUSY"},
-    {"bits": [25, 25], "name": "SRC_DATA_FIFO_VC1_BUSY"},
-    {"bits": [26, 26], "name": "INPUT_BUFFER_VC1_FIFO_FULL"},
-    {"bits": [27, 27], "name": "SRC_DATA_FIFO_VC1_FULL"}
-   ]
-  },
-  "CHC_CTRL": {
-   "fields": [
-    {"bits": [0, 3], "name": "BUFFER_DEPTH_MAX"},
-    {"bits": [4, 10], "name": "GL2_REQ_CREDITS"},
-    {"bits": [11, 17], "name": "GL2_DATA_CREDITS"},
-    {"bits": [18, 18], "name": "TO_L1_REPEATER_FGCG_DISABLE"},
-    {"bits": [19, 19], "name": "TO_L2_REPEATER_FGCG_DISABLE"},
-    {"bits": [29, 29], "name": "DISABLE_PERF_WR_DATA_ALLOC_COUNT"}
-   ]
-  },
-  "CHC_STATUS": {
-   "fields": [
-    {"bits": [0, 0], "name": "INPUT_BUFFER_VC0_FIFO_FULL"},
-    {"bits": [1, 1], "name": "OUTPUT_FIFOS_BUSY"},
-    {"bits": [2, 2], "name": "SRC_DATA_FIFO_VC0_FULL"},
-    {"bits": [3, 3], "name": "GL2_REQ_VC0_STALL"},
-    {"bits": [4, 4], "name": "GL2_DATA_VC0_STALL"},
-    {"bits": [5, 5], "name": "GL2_REQ_VC1_STALL"},
-    {"bits": [6, 6], "name": "GL2_DATA_VC1_STALL"},
-    {"bits": [7, 7], "name": "INPUT_BUFFER_VC0_BUSY"},
-    {"bits": [8, 8], "name": "SRC_DATA_FIFO_VC0_BUSY"},
-    {"bits": [9, 9], "name": "GL2_RH_BUSY"},
-    {"bits": [10, 19], "name": "NUM_REQ_PENDING_FROM_L2"},
-    {"bits": [20, 20], "name": "VIRTUAL_FIFO_FULL_STALL"},
-    {"bits": [21, 21], "name": "REQUEST_TRACKER_BUFFER_STALL"},
-    {"bits": [22, 22], "name": "REQUEST_TRACKER_BUSY"},
-    {"bits": [23, 23], "name": "BUFFER_FULL"}
-   ]
-  },
-  "CHI_CHR_REP_FGCG_OVERRIDE": {
-   "fields": [
-    {"bits": [0, 0], "name": "CHA_CHIW_REP_FGCG_OVERRIDE"},
-    {"bits": [1, 1], "name": "CHA_CHIR_REP_FGCG_OVERRIDE"},
-    {"bits": [2, 2], "name": "CHA_CHR_SRC_REP_FGCG_OVERRIDE"},
-    {"bits": [3, 3], "name": "CHA_CHR_RET_REP_FGCG_OVERRIDE"}
-   ]
-  },
-  "CH_ARB_CTRL": {
-   "fields": [
-    {"bits": [0, 1], "name": "NUM_MEM_PIPES"},
-    {"bits": [2, 2], "name": "UC_IO_WR_PATH"},
-    {"bits": [3, 3], "name": "FGCG_DISABLE"},
-    {"bits": [4, 4], "name": "PERF_CNTR_EN_OVERRIDE"},
-    {"bits": [5, 12], "name": "CHICKEN_BITS"}
-   ]
-  },
-  "CH_ARB_STATUS": {
-   "fields": [
-    {"bits": [0, 0], "name": "REQ_ARB_BUSY"},
-    {"bits": [1, 1], "name": "RET_ARB_BUSY"}
-   ]
-  },
-  "CH_DRAM_BURST_CTRL": {
-   "fields": [
-    {"bits": [0, 2], "name": "MAX_DRAM_BURST"},
-    {"bits": [3, 3], "name": "BURST_DISABLE"},
-    {"bits": [4, 4], "name": "GATHER_64B_MEMORY_BURST_DISABLE"},
-    {"bits": [5, 5], "name": "GATHER_64B_IO_BURST_DISABLE"},
-    {"bits": [6, 6], "name": "GATHER_32B_MEMORY_BURST_DISABLE"},
-    {"bits": [7, 7], "name": "GATHER_32B_IO_BURST_DISABLE"},
-    {"bits": [8, 8], "name": "WRITE_BURSTABLE_STALL_DISABLE"}
-   ]
-  },
-  "CH_DRAM_BURST_MASK": {
-   "fields": [
-    {"bits": [0, 7], "name": "DRAM_BURST_ADDR_MASK"}
-   ]
-  },
-  "CH_VC5_ENABLE": {
-   "fields": [
-    {"bits": [1, 1], "name": "UTCL2_VC5_ENABLE"}
-   ]
-  },
   "COHER_DEST_BASE_HI_0": {
    "fields": [
     {"bits": [0, 7], "name": "DEST_BASE_HI_256B"}
@@ -12453,72 +11897,6 @@
     {"bits": [0, 2], "name": "SRC_STATE_ID"}
    ]
   },
-  "GL1C_STATUS": {
-   "fields": [
-    {"bits": [0, 0], "name": "INPUT_BUFFER_VC0_FIFO_FULL"},
-    {"bits": [1, 1], "name": "OUTPUT_FIFOS_BUSY"},
-    {"bits": [2, 2], "name": "SRC_DATA_FIFO_VC0_FULL"},
-    {"bits": [3, 3], "name": "GL2_REQ_VC0_STALL"},
-    {"bits": [4, 4], "name": "GL2_DATA_VC0_STALL"},
-    {"bits": [5, 5], "name": "GL2_REQ_VC1_STALL"},
-    {"bits": [6, 6], "name": "GL2_DATA_VC1_STALL"},
-    {"bits": [7, 7], "name": "INPUT_BUFFER_VC0_BUSY"},
-    {"bits": [8, 8], "name": "SRC_DATA_FIFO_VC0_BUSY"},
-    {"bits": [9, 9], "name": "GL2_RH_BUSY"},
-    {"bits": [10, 19], "name": "NUM_REQ_PENDING_FROM_L2"},
-    {"bits": [20, 20], "name": "LATENCY_FIFO_FULL_STALL"},
-    {"bits": [21, 21], "name": "TAG_STALL"},
-    {"bits": [22, 22], "name": "TAG_BUSY"},
-    {"bits": [23, 23], "name": "TAG_ACK_STALL"},
-    {"bits": [24, 24], "name": "TAG_GCR_INV_STALL"},
-    {"bits": [25, 25], "name": "TAG_NO_AVAILABLE_LINE_TO_EVICT_STALL"},
-    {"bits": [26, 26], "name": "TAG_EVICT"},
-    {"bits": [27, 30], "name": "TAG_REQUEST_STATE_OPERATION"},
-    {"bits": [31, 31], "name": "TRACKER_LAST_SET_MATCHES_CURRENT_SET"}
-   ]
-  },
-  "GL1C_UTCL0_CNTL1": {
-   "fields": [
-    {"bits": [0, 0], "name": "FORCE_4K_L2_RESP"},
-    {"bits": [1, 1], "name": "GPUVM_64K_DEF"},
-    {"bits": [2, 2], "name": "GPUVM_PERM_MODE"},
-    {"bits": [3, 4], "name": "RESP_MODE"},
-    {"bits": [5, 6], "name": "RESP_FAULT_MODE"},
-    {"bits": [7, 15], "name": "CLIENTID"},
-    {"bits": [19, 22], "name": "REG_INV_VMID"},
-    {"bits": [24, 24], "name": "REG_INV_TOGGLE"},
-    {"bits": [26, 26], "name": "FORCE_MISS"},
-    {"bits": [27, 28], "name": "FORCE_IN_ORDER"},
-    {"bits": [28, 29], "name": "REDUCE_FIFO_DEPTH_BY_2"},
-    {"bits": [30, 31], "name": "REDUCE_CACHE_SIZE_BY_2"}
-   ]
-  },
-  "GL1C_UTCL0_CNTL2": {
-   "fields": [
-    {"bits": [0, 7], "name": "SPARE"},
-    {"bits": [8, 8], "name": "COMP_SYNC_DISABLE"},
-    {"bits": [9, 9], "name": "MTYPE_OVRD_DIS"},
-    {"bits": [10, 10], "name": "ANY_LINE_VALID"},
-    {"bits": [14, 14], "name": "FORCE_SNOOP"},
-    {"bits": [17, 17], "name": "DISABLE_BURST"},
-    {"bits": [26, 26], "name": "FORCE_FRAG_2M_TO_64K"},
-    {"bits": [30, 30], "name": "FGCG_DISABLE"},
-    {"bits": [31, 31], "name": "BIG_PAGE_DISABLE"}
-   ]
-  },
-  "GL1C_UTCL0_RETRY": {
-   "fields": [
-    {"bits": [0, 7], "name": "INCR"},
-    {"bits": [8, 11], "name": "COUNT"}
-   ]
-  },
-  "GL1C_UTCL0_STATUS": {
-   "fields": [
-    {"bits": [0, 0], "name": "FAULT_DETECTED"},
-    {"bits": [1, 1], "name": "RETRY_DETECTED"},
-    {"bits": [2, 2], "name": "PRT_DETECTED"}
-   ]
-  },
   "GL2C_PERFCOUNTER0_SELECT1": {
    "fields": [
     {"bits": [0, 9], "name": "PERF_SEL2"},
@@ -12688,164 +12066,6 @@
     {"bits": [31, 31], "name": "CB_BUSY"}
    ]
   },
-  "GUS_DRAM_GROUP_BURST": {
-   "fields": [
-    {"bits": [0, 7], "name": "DRAM_LIMIT_LO"},
-    {"bits": [8, 15], "name": "DRAM_LIMIT_HI"}
-   ]
-  },
-  "GUS_DRAM_PRI_QUANT1_PRI2": {
-   "fields": [
-    {"bits": [0, 7], "name": "GROUP4_THRESHOLD"},
-    {"bits": [8, 15], "name": "GROUP5_THRESHOLD"}
-   ]
-  },
-  "GUS_ERR_STATUS": {
-   "fields": [
-    {"bits": [0, 3], "name": "SDP_RDRSP_STATUS"},
-    {"bits": [4, 7], "name": "SDP_WRRSP_STATUS"},
-    {"bits": [8, 9], "name": "SDP_RDRSP_DATASTATUS"},
-    {"bits": [10, 10], "name": "SDP_RDRSP_DATAPARITY_ERROR"},
-    {"bits": [11, 11], "name": "CLEAR_ERROR_STATUS"},
-    {"bits": [12, 12], "name": "BUSY_ON_ERROR"},
-    {"bits": [13, 13], "name": "FUE_FLAG"}
-   ]
-  },
-  "GUS_IO_RD_COMBINE_FLUSH": {
-   "fields": [
-    {"bits": [0, 3], "name": "GROUP0_TIMER"},
-    {"bits": [4, 7], "name": "GROUP1_TIMER"},
-    {"bits": [8, 11], "name": "GROUP2_TIMER"},
-    {"bits": [12, 15], "name": "GROUP3_TIMER"},
-    {"bits": [16, 19], "name": "GROUP4_TIMER"},
-    {"bits": [20, 23], "name": "GROUP5_TIMER"},
-    {"bits": [24, 25], "name": "COMB_MODE"}
-   ]
-  },
-  "GUS_IO_RD_PRI_AGE_COEFF": {
-   "fields": [
-    {"bits": [0, 2], "name": "GROUP0_AGE_COEFFICIENT"},
-    {"bits": [3, 5], "name": "GROUP1_AGE_COEFFICIENT"},
-    {"bits": [6, 8], "name": "GROUP2_AGE_COEFFICIENT"},
-    {"bits": [9, 11], "name": "GROUP3_AGE_COEFFICIENT"},
-    {"bits": [12, 14], "name": "GROUP4_AGE_COEFFICIENT"},
-    {"bits": [15, 17], "name": "GROUP5_AGE_COEFFICIENT"}
-   ]
-  },
-  "GUS_IO_RD_PRI_AGE_RATE": {
-   "fields": [
-    {"bits": [0, 2], "name": "GROUP0_AGING_RATE"},
-    {"bits": [3, 5], "name": "GROUP1_AGING_RATE"},
-    {"bits": [6, 8], "name": "GROUP2_AGING_RATE"},
-    {"bits": [9, 11], "name": "GROUP3_AGING_RATE"},
-    {"bits": [12, 14], "name": "GROUP4_AGING_RATE"},
-    {"bits": [15, 17], "name": "GROUP5_AGING_RATE"}
-   ]
-  },
-  "GUS_LATENCY_SAMPLING": {
-   "fields": [
-    {"bits": [0, 0], "name": "SAMPLER0_DRAM"},
-    {"bits": [1, 1], "name": "SAMPLER1_DRAM"},
-    {"bits": [2, 2], "name": "SAMPLER0_IO"},
-    {"bits": [3, 3], "name": "SAMPLER1_IO"},
-    {"bits": [4, 4], "name": "SAMPLER0_READ"},
-    {"bits": [5, 5], "name": "SAMPLER1_READ"},
-    {"bits": [6, 6], "name": "SAMPLER0_WRITE"},
-    {"bits": [7, 7], "name": "SAMPLER1_WRITE"},
-    {"bits": [8, 8], "name": "SAMPLER0_ATOMIC_RET"},
-    {"bits": [9, 9], "name": "SAMPLER1_ATOMIC_RET"},
-    {"bits": [10, 10], "name": "SAMPLER0_ATOMIC_NORET"},
-    {"bits": [11, 11], "name": "SAMPLER1_ATOMIC_NORET"},
-    {"bits": [12, 19], "name": "SAMPLER0_VC"},
-    {"bits": [20, 27], "name": "SAMPLER1_VC"}
-   ]
-  },
-  "GUS_MISC": {
-   "fields": [
-    {"bits": [0, 0], "name": "RELATIVE_PRI_IN_DRAM_ARB"},
-    {"bits": [1, 1], "name": "RELATIVE_PRI_IN_IO_RD_ARB"},
-    {"bits": [2, 2], "name": "RELATIVE_PRI_IN_IO_WR_ARB"},
-    {"bits": [3, 3], "name": "EARLY_SDP_ORIGDATA"},
-    {"bits": [4, 5], "name": "LINKMGR_DYNAMIC_MODE"},
-    {"bits": [6, 7], "name": "LINKMGR_HALT_THRESHOLD"},
-    {"bits": [8, 9], "name": "LINKMGR_RECONNECT_DELAY"},
-    {"bits": [10, 14], "name": "LINKMGR_IDLE_THRESHOLD"},
-    {"bits": [15, 15], "name": "SEND0_IOWR_ONLY"}
-   ]
-  },
-  "GUS_MISC2": {
-   "fields": [
-    {"bits": [0, 0], "name": "IO_RDWR_PRIORITY_ENABLE"},
-    {"bits": [1, 1], "name": "CH_L1_RO_MASK"},
-    {"bits": [2, 2], "name": "SA0_L1_RO_MASK"},
-    {"bits": [3, 3], "name": "SA1_L1_RO_MASK"},
-    {"bits": [4, 4], "name": "SA2_L1_RO_MASK"},
-    {"bits": [5, 5], "name": "SA3_L1_RO_MASK"},
-    {"bits": [6, 6], "name": "CH_L1_PERF_MASK"},
-    {"bits": [7, 7], "name": "SA0_L1_PERF_MASK"},
-    {"bits": [8, 8], "name": "SA1_L1_PERF_MASK"},
-    {"bits": [9, 9], "name": "SA2_L1_PERF_MASK"},
-    {"bits": [10, 10], "name": "SA3_L1_PERF_MASK"},
-    {"bits": [11, 11], "name": "FP_ATOMICS_ENABLE"},
-    {"bits": [12, 12], "name": "L1_RET_CLKEN"},
-    {"bits": [13, 13], "name": "FGCLKEN_HIGH"},
-    {"bits": [14, 14], "name": "BLOCK_REQUESTS"},
-    {"bits": [15, 15], "name": "REQUESTS_BLOCKED"},
-    {"bits": [16, 16], "name": "RIO_ICG_L1_ROUTER_BUSY_MASK"},
-    {"bits": [17, 17], "name": "WIO_ICG_L1_ROUTER_BUSY_MASK"},
-    {"bits": [18, 18], "name": "DRAM_ICG_L1_ROUTER_BUSY_MASK"}
-   ]
-  },
-  "GUS_MISC3": {
-   "fields": [
-    {"bits": [0, 0], "name": "FP_ATOMICS_LOG"},
-    {"bits": [1, 1], "name": "CLEAR_LOG"}
-   ]
-  },
-  "GUS_SDP_ENABLE": {
-   "fields": [
-    {"bits": [0, 0], "name": "ENABLE"}
-   ]
-  },
-  "GUS_SDP_REQ_CNTL": {
-   "fields": [
-    {"bits": [0, 0], "name": "REQ_PASS_PW_OVERRIDE_READ"},
-    {"bits": [1, 1], "name": "REQ_PASS_PW_OVERRIDE_WRITE"},
-    {"bits": [2, 2], "name": "REQ_PASS_PW_OVERRIDE_ATOMIC"},
-    {"bits": [3, 3], "name": "REQ_CHAIN_OVERRIDE_DRAM"},
-    {"bits": [4, 4], "name": "INNER_DOMAIN_MODE"}
-   ]
-  },
-  "GUS_SDP_TAG_RESERVE1": {
-   "fields": [
-    {"bits": [0, 7], "name": "VC4"},
-    {"bits": [8, 15], "name": "VC5"},
-    {"bits": [16, 23], "name": "VC6"},
-    {"bits": [24, 31], "name": "VC7"}
-   ]
-  },
-  "GUS_SDP_VCC_RESERVE0": {
-   "fields": [
-    {"bits": [0, 5], "name": "VC0_CREDITS"},
-    {"bits": [6, 11], "name": "VC1_CREDITS"},
-    {"bits": [12, 17], "name": "VC2_CREDITS"},
-    {"bits": [18, 23], "name": "VC3_CREDITS"},
-    {"bits": [24, 29], "name": "VC4_CREDITS"}
-   ]
-  },
-  "GUS_SDP_VCC_RESERVE1": {
-   "fields": [
-    {"bits": [0, 5], "name": "VC5_CREDITS"},
-    {"bits": [6, 11], "name": "VC6_CREDITS"},
-    {"bits": [12, 17], "name": "VC7_CREDITS"},
-    {"bits": [31, 31], "name": "DISTRIBUTE_POOL"}
-   ]
-  },
-  "GUS_WRRSP_FIFO_CNTL": {
-   "fields": [
-    {"bits": [0, 5], "name": "THRESHOLD"}
-   ]
-  },
   "PA_CL_CLIP_CNTL": {
    "fields": [
     {"bits": [0, 0], "name": "UCP_ENA_0"},
diff --git a/src/amd/registers/parse_kernel_headers.py b/src/amd/registers/parse_kernel_headers.py
index cd4c7b686902..f3a438649509 100644
--- a/src/amd/registers/parse_kernel_headers.py
+++ b/src/amd/registers/parse_kernel_headers.py
@@ -98,7 +98,9 @@ def register_filter(gfx_level, name, offset, already_added):
             offset // 4 not in (0x23B0, 0x23B1, 0x237F) and
             # Remove conflicts (multiple definitions for the same offset)
             not already_added and
-            'PREF_PRI_ACCUM' not in name)
+            'PREF_PRI_ACCUM' not in name and
+            # only define SPI and COMPUTE registers in the 0xB000 range.
+            (offset // 0x1000 != 0xB or name.startswith('SPI') or name.startswith('COMPUTE')))
 
 # Mapping from field names to enum types
 enum_map = {
-- 
GitLab


From 478634e3106b6a6b4c61c18113da4c35e5272301 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 04:39:47 -0500
Subject: [PATCH 29/45] radeonsi: reorganize emit_db_render_state and simplify
 VRS code

for better readability

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 99 ++++++++++++-------------
 1 file changed, 46 insertions(+), 53 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 78db825e708a..339569a0608e 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -1516,7 +1516,7 @@ void si_restore_qbo_state(struct si_context *sctx, struct si_qbo_state *st)
 static void si_emit_db_render_state(struct si_context *sctx)
 {
    struct si_state_rasterizer *rs = sctx->queued.named.rasterizer;
-   unsigned db_shader_control, db_render_control, db_count_control;
+   unsigned db_shader_control, db_render_control, db_count_control, vrs_override_cntl = 0;
 
    /* DB_RENDER_CONTROL */
    if (sctx->dbcb_depth_copy_enabled || sctx->dbcb_stencil_copy_enabled) {
@@ -1581,18 +1581,6 @@ static void si_emit_db_render_state(struct si_context *sctx)
       }
    }
 
-   radeon_begin(&sctx->gfx_cs);
-   radeon_opt_set_context_reg2(sctx, R_028000_DB_RENDER_CONTROL, SI_TRACKED_DB_RENDER_CONTROL,
-                               db_render_control, db_count_control);
-
-   /* DB_RENDER_OVERRIDE2 */
-   radeon_opt_set_context_reg(
-      sctx, R_028010_DB_RENDER_OVERRIDE2, SI_TRACKED_DB_RENDER_OVERRIDE2,
-      S_028010_DISABLE_ZMASK_EXPCLEAR_OPTIMIZATION(sctx->db_depth_disable_expclear) |
-      S_028010_DISABLE_SMEM_EXPCLEAR_OPTIMIZATION(sctx->db_stencil_disable_expclear) |
-      S_028010_DECOMPRESS_Z_ON_FLUSH(sctx->framebuffer.nr_samples >= 4) |
-      S_028010_CENTROID_COMPUTATION_MODE(sctx->gfx_level >= GFX10_3 ? 1 : 0));
-
    db_shader_control = sctx->ps_db_shader_control;
 
    /* Disable the gl_SampleMask fragment shader output if MSAA is disabled. */
@@ -1606,53 +1594,58 @@ static void si_emit_db_render_state(struct si_context *sctx)
                            S_02880C_OVERRIDE_INTRINSIC_RATE(2);
    }
 
-   radeon_opt_set_context_reg(sctx, R_02880C_DB_SHADER_CONTROL, SI_TRACKED_DB_SHADER_CONTROL,
-                              db_shader_control);
-
    if (sctx->gfx_level >= GFX10_3) {
+      /* Variable rate shading. */
+      unsigned mode, log_rate_x, log_rate_y;
+
       if (sctx->allow_flat_shading) {
-         if (sctx->gfx_level == GFX11) {
-            radeon_opt_set_context_reg(sctx, R_0283D0_PA_SC_VRS_OVERRIDE_CNTL,
-                                       SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
-                                       S_0283D0_VRS_OVERRIDE_RATE_COMBINER_MODE(
-                                          V_0283D0_SC_VRS_COMB_MODE_OVERRIDE) |
-                                       /* If the hw doesn't support VRS 4x4, it will silently
-                                        * use 2x2 instead. */
-                                       S_0283D0_VRS_RATE(V_0283D0_VRS_SHADING_RATE_4X4));
-         } else {
-            radeon_opt_set_context_reg(sctx, R_028064_DB_VRS_OVERRIDE_CNTL,
-                                       SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
-                                       S_028064_VRS_OVERRIDE_RATE_COMBINER_MODE(
-                                          V_028064_SC_VRS_COMB_MODE_OVERRIDE) |
-                                       S_028064_VRS_OVERRIDE_RATE_X(1) |
-                                       S_028064_VRS_OVERRIDE_RATE_Y(1));
-         }
+         mode = V_028064_SC_VRS_COMB_MODE_OVERRIDE;
+         log_rate_x = log_rate_y = 1; /* 2x2 VRS (log2(2) == 1) */
       } else {
-         /* If the shader is using discard, turn off coarse shading because
-          * discard at 2x2 pixel granularity degrades quality too much.
+         /* If the shader is using discard, turn off coarse shading because discarding at 2x2 pixel
+          * granularity degrades quality too much.
           *
-          * MIN allows sample shading but not coarse shading.
+          * The shader writes the VRS rate and we either pass it through or do MIN(shader, 1x1)
+          * to disable coarse shading.
           */
-         if (sctx->gfx_level == GFX11) {
-            unsigned mode = sctx->screen->options.vrs2x2 && G_02880C_KILL_ENABLE(db_shader_control) ?
-               V_0283D0_SC_VRS_COMB_MODE_MIN : V_0283D0_SC_VRS_COMB_MODE_PASSTHRU;
-
-            radeon_opt_set_context_reg(sctx, R_0283D0_PA_SC_VRS_OVERRIDE_CNTL,
-                                       SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
-                                       S_0283D0_VRS_OVERRIDE_RATE_COMBINER_MODE(mode) |
-                                       S_0283D0_VRS_RATE(V_0283D0_VRS_SHADING_RATE_1X1));
-         } else {
-            unsigned mode = sctx->screen->options.vrs2x2 && G_02880C_KILL_ENABLE(db_shader_control) ?
-               V_028064_SC_VRS_COMB_MODE_MIN : V_028064_SC_VRS_COMB_MODE_PASSTHRU;
-
-            radeon_opt_set_context_reg(sctx, R_028064_DB_VRS_OVERRIDE_CNTL,
-                                       SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL,
-                                       S_028064_VRS_OVERRIDE_RATE_COMBINER_MODE(mode) |
-                                       S_028064_VRS_OVERRIDE_RATE_X(0) |
-                                       S_028064_VRS_OVERRIDE_RATE_Y(0));
-         }
+         mode = sctx->screen->options.vrs2x2 && G_02880C_KILL_ENABLE(db_shader_control) ?
+                   V_028064_SC_VRS_COMB_MODE_MIN : V_028064_SC_VRS_COMB_MODE_PASSTHRU;
+         log_rate_x = log_rate_y = 0; /* 1x1 VRS (log2(1) == 0) */
+      }
+
+      if (sctx->gfx_level >= GFX11) {
+         vrs_override_cntl = S_0283D0_VRS_OVERRIDE_RATE_COMBINER_MODE(mode) |
+                             S_0283D0_VRS_RATE(log_rate_x * 4 + log_rate_y);
+      } else {
+         vrs_override_cntl = S_028064_VRS_OVERRIDE_RATE_COMBINER_MODE(mode) |
+                             S_028064_VRS_OVERRIDE_RATE_X(log_rate_x) |
+                             S_028064_VRS_OVERRIDE_RATE_Y(log_rate_y);
       }
    }
+
+   radeon_begin(&sctx->gfx_cs);
+   radeon_opt_set_context_reg2(sctx, R_028000_DB_RENDER_CONTROL, SI_TRACKED_DB_RENDER_CONTROL,
+                               db_render_control, db_count_control);
+
+   /* DB_RENDER_OVERRIDE2 */
+   radeon_opt_set_context_reg(
+      sctx, R_028010_DB_RENDER_OVERRIDE2, SI_TRACKED_DB_RENDER_OVERRIDE2,
+      S_028010_DISABLE_ZMASK_EXPCLEAR_OPTIMIZATION(sctx->db_depth_disable_expclear) |
+      S_028010_DISABLE_SMEM_EXPCLEAR_OPTIMIZATION(sctx->db_stencil_disable_expclear) |
+      S_028010_DECOMPRESS_Z_ON_FLUSH(sctx->framebuffer.nr_samples >= 4) |
+      S_028010_CENTROID_COMPUTATION_MODE(sctx->gfx_level >= GFX10_3 ? 1 : 0));
+
+   radeon_opt_set_context_reg(sctx, R_02880C_DB_SHADER_CONTROL, SI_TRACKED_DB_SHADER_CONTROL,
+                              db_shader_control);
+
+   if (sctx->gfx_level >= GFX11) {
+      radeon_opt_set_context_reg(sctx, R_0283D0_PA_SC_VRS_OVERRIDE_CNTL,
+                                 SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL, vrs_override_cntl);
+   } else if (sctx->gfx_level >= GFX10_3) {
+      radeon_opt_set_context_reg(sctx, R_028064_DB_VRS_OVERRIDE_CNTL,
+                                 SI_TRACKED_DB_PA_SC_VRS_OVERRIDE_CNTL, vrs_override_cntl);
+   }
+
    radeon_end_update_context_roll(sctx);
 }
 
-- 
GitLab


From beea85996a1cc59659c60e81468482a4832dadeb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 04:40:34 -0500
Subject: [PATCH 30/45] radeonsi: reorganize si_initialize_color_surface for
 better readability

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 162 +++++++++++-------------
 1 file changed, 77 insertions(+), 85 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 339569a0608e..5f53aeb0ea7f 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -2512,7 +2512,6 @@ static void si_choose_spi_color_formats(struct si_surface *surf, unsigned format
 static void si_initialize_color_surface(struct si_context *sctx, struct si_surface *surf)
 {
    struct si_texture *tex = (struct si_texture *)surf->base.texture;
-   unsigned color_info, color_attrib;
    unsigned format, swap, ntype, endian;
    const struct util_format_description *desc;
    int firstchan;
@@ -2573,47 +2572,14 @@ static void si_initialize_color_surface(struct si_context *sctx, struct si_surfa
          surf->color_is_int10 = true;
    }
 
-   color_info =
-      S_028C70_COMP_SWAP(swap) | S_028C70_BLEND_CLAMP(blend_clamp) |
-      S_028C70_BLEND_BYPASS(blend_bypass) | S_028C70_SIMPLE_FLOAT(1) |
-      S_028C70_ROUND_MODE(ntype != V_028C70_NUMBER_UNORM && ntype != V_028C70_NUMBER_SNORM &&
-                          ntype != V_028C70_NUMBER_SRGB && format != V_028C70_COLOR_8_24 &&
-                          format != V_028C70_COLOR_24_8) |
-      S_028C70_NUMBER_TYPE(ntype);
-
-   if (sctx->gfx_level >= GFX11) {
-      assert(!UTIL_ARCH_BIG_ENDIAN);
-      color_info |= S_028C70_FORMAT_GFX11(format);
-   } else {
-      color_info |= S_028C70_FORMAT_GFX6(format) | S_028C70_ENDIAN(endian);
-   }
-
+   unsigned log_samples = util_logbase2(tex->buffer.b.b.nr_samples);
+   unsigned log_fragments = util_logbase2(tex->buffer.b.b.nr_storage_samples);
    /* Intensity is implemented as Red, so treat it that way. */
-   color_attrib = sctx->gfx_level >= GFX11 ?
-      S_028C74_FORCE_DST_ALPHA_1_GFX11(desc->swizzle[3] == PIPE_SWIZZLE_1 || util_format_is_intensity(surf->base.format)):
-      S_028C74_FORCE_DST_ALPHA_1_GFX6(desc->swizzle[3] == PIPE_SWIZZLE_1 || util_format_is_intensity(surf->base.format));
-
-   if (tex->buffer.b.b.nr_samples > 1) {
-      unsigned log_samples = util_logbase2(tex->buffer.b.b.nr_samples);
-      unsigned log_fragments = util_logbase2(tex->buffer.b.b.nr_storage_samples);
-
-      if (sctx->gfx_level >= GFX11) {
-         color_attrib |= S_028C74_NUM_FRAGMENTS_GFX11(log_fragments);
-      } else {
-         color_attrib |= S_028C74_NUM_SAMPLES(log_samples) | S_028C74_NUM_FRAGMENTS_GFX6(log_fragments);
-
-         if (tex->surface.fmask_offset) {
-            color_info |= S_028C70_COMPRESSION(1);
-            unsigned fmask_bankh = util_logbase2(tex->surface.u.legacy.color.fmask.bankh);
-
-            if (sctx->gfx_level == GFX6) {
-               /* due to a hw bug, FMASK_BANK_HEIGHT must be set on GFX6 too */
-               color_attrib |= S_028C74_FMASK_BANK_HEIGHT(fmask_bankh);
-            }
-         }
-      }
-   }
-
+   bool force_dst_alpha_1 = desc->swizzle[3] == PIPE_SWIZZLE_1 ||
+                            util_format_is_intensity(surf->base.format);
+   bool round_mode = ntype != V_028C70_NUMBER_UNORM && ntype != V_028C70_NUMBER_SNORM &&
+                     ntype != V_028C70_NUMBER_SRGB &&
+                     format != V_028C70_COLOR_8_24 && format != V_028C70_COLOR_24_8;
    /* amdvlk: [min-compressed-block-size] should be set to 32 for dGPU and
     * 64 for APU because all of our APUs to date use DIMMs which have
     * a request granularity size of 64B while all other chips have a
@@ -2622,65 +2588,91 @@ static void si_initialize_color_surface(struct si_context *sctx, struct si_surfa
    if (!sctx->screen->info.has_dedicated_vram)
       min_compressed_block_size = V_028C78_MIN_BLOCK_SIZE_64B;
 
+   surf->cb_color_info = S_028C70_COMP_SWAP(swap) |
+                         S_028C70_BLEND_CLAMP(blend_clamp) |
+                         S_028C70_BLEND_BYPASS(blend_bypass) |
+                         S_028C70_SIMPLE_FLOAT(1) |
+                         S_028C70_ROUND_MODE(round_mode) |
+                         S_028C70_NUMBER_TYPE(ntype);
+
    if (sctx->gfx_level >= GFX10) {
+      /* Gfx10-11. */
+      surf->cb_color_view = S_028C6C_SLICE_START(surf->base.u.tex.first_layer) |
+                            S_028C6C_SLICE_MAX_GFX10(surf->base.u.tex.last_layer) |
+                            S_028C6C_MIP_LEVEL_GFX10(surf->base.u.tex.level);
+      surf->cb_color_attrib = 0;
+      surf->cb_color_attrib2 = S_028C68_MIP0_WIDTH(surf->width0 - 1) |
+                               S_028C68_MIP0_HEIGHT(surf->height0 - 1) |
+                               S_028C68_MAX_MIP(tex->buffer.b.b.last_level);
+      surf->cb_color_attrib3 = S_028EE0_MIP0_DEPTH(util_max_layer(&tex->buffer.b.b, 0)) |
+                               S_028EE0_RESOURCE_TYPE(tex->surface.u.gfx9.resource_type) |
+                               S_028EE0_RESOURCE_LEVEL(sctx->gfx_level >= GFX11 ? 0 : 1);
       surf->cb_dcc_control = S_028C78_MAX_UNCOMPRESSED_BLOCK_SIZE(V_028C78_MAX_BLOCK_SIZE_256B) |
                              S_028C78_MAX_COMPRESSED_BLOCK_SIZE(tex->surface.u.gfx9.color.dcc.max_compressed_block_size) |
                              S_028C78_MIN_COMPRESSED_BLOCK_SIZE(min_compressed_block_size) |
                              S_028C78_INDEPENDENT_64B_BLOCKS(tex->surface.u.gfx9.color.dcc.independent_64B_blocks);
-      if (sctx->gfx_level >= GFX11)
+
+      if (sctx->gfx_level >= GFX11) {
+         assert(!UTIL_ARCH_BIG_ENDIAN);
+         surf->cb_color_info |= S_028C70_FORMAT_GFX11(format);
+         surf->cb_color_attrib |= S_028C74_NUM_FRAGMENTS_GFX11(log_fragments) |
+                                  S_028C74_FORCE_DST_ALPHA_1_GFX11(force_dst_alpha_1);
          surf->cb_dcc_control |= S_028C78_INDEPENDENT_128B_BLOCKS_GFX11(tex->surface.u.gfx9.color.dcc.independent_128B_blocks);
-      else
+      } else {
+         surf->cb_color_info |= S_028C70_ENDIAN(endian) |
+                                S_028C70_FORMAT_GFX6(format) |
+                                S_028C70_COMPRESSION(!!tex->surface.fmask_offset);
+         surf->cb_color_attrib |= S_028C74_NUM_SAMPLES(log_samples) |
+                                  S_028C74_NUM_FRAGMENTS_GFX6(log_fragments) |
+                                  S_028C74_FORCE_DST_ALPHA_1_GFX6(force_dst_alpha_1);
          surf->cb_dcc_control |= S_028C78_INDEPENDENT_128B_BLOCKS_GFX10(tex->surface.u.gfx9.color.dcc.independent_128B_blocks);
-   } else if (sctx->gfx_level >= GFX8) {
-      unsigned max_uncompressed_block_size = V_028C78_MAX_BLOCK_SIZE_256B;
-
-      if (tex->buffer.b.b.nr_storage_samples > 1) {
-         if (tex->surface.bpe == 1)
-            max_uncompressed_block_size = V_028C78_MAX_BLOCK_SIZE_64B;
-         else if (tex->surface.bpe == 2)
-            max_uncompressed_block_size = V_028C78_MAX_BLOCK_SIZE_128B;
       }
+   } else {
+      /* Gfx6-9. */
+      surf->cb_color_info |= S_028C70_ENDIAN(endian) |
+                             S_028C70_FORMAT_GFX6(format) |
+                             S_028C70_COMPRESSION(!!tex->surface.fmask_offset);
+      surf->cb_color_view = S_028C6C_SLICE_START(surf->base.u.tex.first_layer) |
+                            S_028C6C_SLICE_MAX_GFX6(surf->base.u.tex.last_layer);
+      surf->cb_color_attrib = S_028C74_NUM_SAMPLES(log_samples) |
+                              S_028C74_NUM_FRAGMENTS_GFX6(log_fragments) |
+                              S_028C74_FORCE_DST_ALPHA_1_GFX6(force_dst_alpha_1);
+      surf->cb_color_attrib2 = 0;
+      surf->cb_dcc_control = 0;
 
-      surf->cb_dcc_control = S_028C78_MAX_UNCOMPRESSED_BLOCK_SIZE(max_uncompressed_block_size) |
-                             S_028C78_MIN_COMPRESSED_BLOCK_SIZE(min_compressed_block_size) |
-                             S_028C78_INDEPENDENT_64B_BLOCKS(1);
-   }
-
-   /* This must be set for fast clear to work without FMASK. */
-   if (!tex->surface.fmask_size && sctx->gfx_level == GFX6) {
-      unsigned bankh = util_logbase2(tex->surface.u.legacy.bankh);
-      color_attrib |= S_028C74_FMASK_BANK_HEIGHT(bankh);
-   }
+      if (sctx->gfx_level == GFX9) {
+         surf->cb_color_view |= S_028C6C_MIP_LEVEL_GFX9(surf->base.u.tex.level);
+         surf->cb_color_attrib |= S_028C74_MIP0_DEPTH(util_max_layer(&tex->buffer.b.b, 0)) |
+                                  S_028C74_RESOURCE_TYPE(tex->surface.u.gfx9.resource_type);
+         surf->cb_color_attrib2 |= S_028C68_MIP0_WIDTH(surf->width0 - 1) |
+                                   S_028C68_MIP0_HEIGHT(surf->height0 - 1) |
+                                   S_028C68_MAX_MIP(tex->buffer.b.b.last_level);
+      }
 
-   /* GFX10 field has the same base shift as the GFX6 field */
-   unsigned color_view = S_028C6C_SLICE_START(surf->base.u.tex.first_layer) |
-                         S_028C6C_SLICE_MAX_GFX10(surf->base.u.tex.last_layer);
-   unsigned mip0_width = surf->width0 - 1;
-   unsigned mip0_height = surf->height0 - 1;
-   unsigned mip0_depth = util_max_layer(&tex->buffer.b.b, 0);
+      if (sctx->gfx_level >= GFX8) {
+         unsigned max_uncompressed_block_size = V_028C78_MAX_BLOCK_SIZE_256B;
 
-   if (sctx->gfx_level >= GFX10) {
-      color_view |= S_028C6C_MIP_LEVEL_GFX10(surf->base.u.tex.level);
+         if (tex->buffer.b.b.nr_storage_samples > 1) {
+            if (tex->surface.bpe == 1)
+               max_uncompressed_block_size = V_028C78_MAX_BLOCK_SIZE_64B;
+            else if (tex->surface.bpe == 2)
+               max_uncompressed_block_size = V_028C78_MAX_BLOCK_SIZE_128B;
+         }
 
-      surf->cb_color_attrib3 = S_028EE0_MIP0_DEPTH(mip0_depth) |
-                               S_028EE0_RESOURCE_TYPE(tex->surface.u.gfx9.resource_type) |
-                               S_028EE0_RESOURCE_LEVEL(sctx->gfx_level >= GFX11 ? 0 : 1);
-   } else if (sctx->gfx_level == GFX9) {
-      color_view |= S_028C6C_MIP_LEVEL_GFX9(surf->base.u.tex.level);
-      color_attrib |= S_028C74_MIP0_DEPTH(mip0_depth) |
-                      S_028C74_RESOURCE_TYPE(tex->surface.u.gfx9.resource_type);
-   }
+         surf->cb_dcc_control |= S_028C78_MAX_UNCOMPRESSED_BLOCK_SIZE(max_uncompressed_block_size) |
+                                 S_028C78_MIN_COMPRESSED_BLOCK_SIZE(min_compressed_block_size) |
+                                 S_028C78_INDEPENDENT_64B_BLOCKS(1);
+      }
 
-   if (sctx->gfx_level >= GFX9) {
-      surf->cb_color_attrib2 = S_028C68_MIP0_WIDTH(mip0_width) |
-                               S_028C68_MIP0_HEIGHT(mip0_height) |
-                               S_028C68_MAX_MIP(tex->buffer.b.b.last_level);
+      if (sctx->gfx_level == GFX6) {
+         /* Due to a hw bug, FMASK_BANK_HEIGHT must still be set on GFX6. (inherited from GFX5) */
+         /* This must also be set for fast clear to work without FMASK. */
+         unsigned fmask_bankh = tex->surface.fmask_offset ? tex->surface.u.legacy.color.fmask.bankh
+                                                          : tex->surface.u.legacy.bankh;
+         surf->cb_color_attrib |= S_028C74_FMASK_BANK_HEIGHT(util_logbase2(fmask_bankh));
+      }
    }
 
-   surf->cb_color_view = color_view;
-   surf->cb_color_info = color_info;
-   surf->cb_color_attrib = color_attrib;
-
    /* Determine pixel shader export format */
    si_choose_spi_color_formats(surf, format, swap, ntype, tex->is_depth);
 
-- 
GitLab


From 9aaad37e95e4f90893acb7c5cc3843dab05e9558 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 04:40:59 -0500
Subject: [PATCH 31/45] radeonsi: reorganize si_init_depth_surface for better
 readability

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_state.c | 80 ++++++++++++-------------
 1 file changed, 40 insertions(+), 40 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 5f53aeb0ea7f..d51d09f246da 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -2684,7 +2684,6 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
    struct si_texture *tex = (struct si_texture *)surf->base.texture;
    unsigned level = surf->base.u.tex.level;
    unsigned format, stencil_format;
-   uint32_t z_info, s_info;
 
    format = si_translate_dbformat(tex->db_render_format);
    stencil_format = tex->surface.has_stencil ? V_028044_STENCIL_8 : V_028044_STENCIL_INVALID;
@@ -2693,51 +2692,51 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
    if (format == V_028040_Z_INVALID)
       PRINT_ERR("Invalid DB format: %d, disabling DB.\n", tex->buffer.b.b.format);
 
-   surf->db_depth_view = S_028008_SLICE_START(surf->base.u.tex.first_layer) |
-                         S_028008_SLICE_MAX(surf->base.u.tex.last_layer);
-   surf->db_htile_data_base = 0;
-   surf->db_htile_surface = 0;
-
-   if (sctx->gfx_level >= GFX10) {
-      surf->db_depth_view |= S_028008_SLICE_START_HI(surf->base.u.tex.first_layer >> 11) |
-                             S_028008_SLICE_MAX_HI(surf->base.u.tex.last_layer >> 11);
-   }
-
    if (sctx->gfx_level >= GFX9) {
+      surf->db_htile_data_base = 0;
+      surf->db_htile_surface = 0;
+      surf->db_depth_view = S_028008_SLICE_START(surf->base.u.tex.first_layer) |
+                            S_028008_SLICE_MAX(surf->base.u.tex.last_layer);
+      if (sctx->gfx_level >= GFX10) {
+         surf->db_depth_view |= S_028008_SLICE_START_HI(surf->base.u.tex.first_layer >> 11) |
+                                S_028008_SLICE_MAX_HI(surf->base.u.tex.last_layer >> 11);
+      }
+
       assert(tex->surface.u.gfx9.surf_offset == 0);
       surf->db_depth_base = tex->buffer.gpu_address >> 8;
       surf->db_stencil_base = (tex->buffer.gpu_address + tex->surface.u.gfx9.zs.stencil_offset) >> 8;
-      z_info = S_028038_FORMAT(format) |
-               S_028038_NUM_SAMPLES(util_logbase2(tex->buffer.b.b.nr_samples)) |
-               S_028038_SW_MODE(tex->surface.u.gfx9.swizzle_mode) |
-               S_028038_MAXMIP(tex->buffer.b.b.last_level) |
-               S_028040_ITERATE_256(sctx->gfx_level >= GFX11);
-      s_info = S_02803C_FORMAT(stencil_format) |
-               S_02803C_SW_MODE(tex->surface.u.gfx9.zs.stencil_swizzle_mode) |
-               S_028044_ITERATE_256(sctx->gfx_level >= GFX11);
+      surf->db_z_info = S_028038_FORMAT(format) |
+                        S_028038_NUM_SAMPLES(util_logbase2(tex->buffer.b.b.nr_samples)) |
+                        S_028038_SW_MODE(tex->surface.u.gfx9.swizzle_mode) |
+                        S_028038_MAXMIP(tex->buffer.b.b.last_level) |
+                        S_028040_ITERATE_256(sctx->gfx_level >= GFX11);
+      surf->db_stencil_info = S_02803C_FORMAT(stencil_format) |
+                              S_02803C_SW_MODE(tex->surface.u.gfx9.zs.stencil_swizzle_mode) |
+                              S_028044_ITERATE_256(sctx->gfx_level >= GFX11);
 
       if (sctx->gfx_level == GFX9) {
          surf->db_z_info2 = S_028068_EPITCH(tex->surface.u.gfx9.epitch);
          surf->db_stencil_info2 = S_02806C_EPITCH(tex->surface.u.gfx9.zs.stencil_epitch);
       }
       surf->db_depth_view |= S_028008_MIPID(level);
-      surf->db_depth_size =
-         S_02801C_X_MAX(tex->buffer.b.b.width0 - 1) | S_02801C_Y_MAX(tex->buffer.b.b.height0 - 1);
+      surf->db_depth_size = S_02801C_X_MAX(tex->buffer.b.b.width0 - 1) |
+                            S_02801C_Y_MAX(tex->buffer.b.b.height0 - 1);
 
       if (si_htile_enabled(tex, level, PIPE_MASK_ZS)) {
-         z_info |= S_028038_TILE_SURFACE_ENABLE(1) | S_028038_ALLOW_EXPCLEAR(1);
-         s_info |= S_02803C_TILE_STENCIL_DISABLE(tex->htile_stencil_disabled);
+         surf->db_z_info |= S_028038_TILE_SURFACE_ENABLE(1) |
+                            S_028038_ALLOW_EXPCLEAR(1);
+         surf->db_stencil_info |= S_02803C_TILE_STENCIL_DISABLE(tex->htile_stencil_disabled);
 
          if (tex->surface.has_stencil && !tex->htile_stencil_disabled) {
             /* Stencil buffer workaround ported from the GFX6-GFX8 code.
              * See that for explanation.
              */
-            s_info |= S_02803C_ALLOW_EXPCLEAR(tex->buffer.b.b.nr_samples <= 1);
+            surf->db_stencil_info |= S_02803C_ALLOW_EXPCLEAR(tex->buffer.b.b.nr_samples <= 1);
          }
 
          surf->db_htile_data_base = (tex->buffer.gpu_address + tex->surface.meta_offset) >> 8;
-         surf->db_htile_surface =
-            S_028ABC_FULL_CACHE(1) | S_028ABC_PIPE_ALIGNED(1);
+         surf->db_htile_surface = S_028ABC_FULL_CACHE(1) |
+                                  S_028ABC_PIPE_ALIGNED(1);
          if (sctx->gfx_level == GFX9) {
             surf->db_htile_surface |= S_028ABC_RB_ALIGNED(1);
          }
@@ -2752,10 +2751,13 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
          (tex->buffer.gpu_address >> 8) + tex->surface.u.legacy.level[level].offset_256B;
       surf->db_stencil_base =
          (tex->buffer.gpu_address >> 8) + tex->surface.u.legacy.zs.stencil_level[level].offset_256B;
-
-      z_info =
-         S_028040_FORMAT(format) | S_028040_NUM_SAMPLES(util_logbase2(tex->buffer.b.b.nr_samples));
-      s_info = S_028044_FORMAT(stencil_format);
+      surf->db_htile_data_base = 0;
+      surf->db_htile_surface = 0;
+      surf->db_depth_view = S_028008_SLICE_START(surf->base.u.tex.first_layer) |
+                            S_028008_SLICE_MAX(surf->base.u.tex.last_layer);
+      surf->db_z_info = S_028040_FORMAT(format) |
+                        S_028040_NUM_SAMPLES(util_logbase2(tex->buffer.b.b.nr_samples));
+      surf->db_stencil_info = S_028044_FORMAT(stencil_format);
       surf->db_depth_info = 0;
 
       if (sctx->gfx_level >= GFX7) {
@@ -2773,13 +2775,13 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
                                 S_02803C_BANK_HEIGHT(G_009990_BANK_HEIGHT(macro_mode)) |
                                 S_02803C_MACRO_TILE_ASPECT(G_009990_MACRO_TILE_ASPECT(macro_mode)) |
                                 S_02803C_NUM_BANKS(G_009990_NUM_BANKS(macro_mode));
-         z_info |= S_028040_TILE_SPLIT(G_009910_TILE_SPLIT(tile_mode));
-         s_info |= S_028044_TILE_SPLIT(G_009910_TILE_SPLIT(stencil_tile_mode));
+         surf->db_z_info |= S_028040_TILE_SPLIT(G_009910_TILE_SPLIT(tile_mode));
+         surf->db_stencil_info |= S_028044_TILE_SPLIT(G_009910_TILE_SPLIT(stencil_tile_mode));
       } else {
          unsigned tile_mode_index = si_tile_mode_index(tex, level, false);
-         z_info |= S_028040_TILE_MODE_INDEX(tile_mode_index);
+         surf->db_z_info |= S_028040_TILE_MODE_INDEX(tile_mode_index);
          tile_mode_index = si_tile_mode_index(tex, level, true);
-         s_info |= S_028044_TILE_MODE_INDEX(tile_mode_index);
+         surf->db_stencil_info |= S_028044_TILE_MODE_INDEX(tile_mode_index);
       }
 
       surf->db_depth_size = S_028058_PITCH_TILE_MAX((levelinfo->nblk_x / 8) - 1) |
@@ -2788,8 +2790,9 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
          S_02805C_SLICE_TILE_MAX((levelinfo->nblk_x * levelinfo->nblk_y) / 64 - 1);
 
       if (si_htile_enabled(tex, level, PIPE_MASK_ZS)) {
-         z_info |= S_028040_TILE_SURFACE_ENABLE(1) | S_028040_ALLOW_EXPCLEAR(1);
-         s_info |= S_028044_TILE_STENCIL_DISABLE(tex->htile_stencil_disabled);
+         surf->db_z_info |= S_028040_TILE_SURFACE_ENABLE(1) |
+                            S_028040_ALLOW_EXPCLEAR(1);
+         surf->db_stencil_info |= S_028044_TILE_STENCIL_DISABLE(tex->htile_stencil_disabled);
 
          if (tex->surface.has_stencil) {
             /* Workaround: For a not yet understood reason, the
@@ -2804,7 +2807,7 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
              * test if you want to try changing this.
              */
             if (tex->buffer.b.b.nr_samples <= 1)
-               s_info |= S_028044_ALLOW_EXPCLEAR(1);
+               surf->db_stencil_info |= S_028044_ALLOW_EXPCLEAR(1);
          }
 
          surf->db_htile_data_base = (tex->buffer.gpu_address + tex->surface.meta_offset) >> 8;
@@ -2812,9 +2815,6 @@ static void si_init_depth_surface(struct si_context *sctx, struct si_surface *su
       }
    }
 
-   surf->db_z_info = z_info;
-   surf->db_stencil_info = s_info;
-
    surf->depth_initialized = true;
 }
 
-- 
GitLab


From 5c882a00b3e208a30d19cfc5e3595d558d49eda9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 04:50:18 -0500
Subject: [PATCH 32/45] radeonsi: remove Smart Access Memory because CPU access
 has large overhead

Related: https://gitlab.freedesktop.org/mesa/mesa/-/issues/8176
---
 src/amd/common/ac_gpu_info.c                   |  6 ------
 src/amd/common/ac_gpu_info.h                   |  1 -
 src/gallium/drivers/r300/r300_screen.c         |  2 +-
 src/gallium/drivers/r600/r600_pipe_common.c    |  2 +-
 src/gallium/drivers/r600/radeon_uvd.c          |  2 +-
 src/gallium/drivers/r600/radeon_video.c        |  2 +-
 src/gallium/drivers/radeonsi/si_buffer.c       |  8 ++------
 src/gallium/drivers/radeonsi/si_pipe.c         | 18 +++++-------------
 src/gallium/drivers/radeonsi/si_texture.c      |  3 +--
 src/gallium/include/winsys/radeon_winsys.h     |  4 +---
 src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c  | 10 +---------
 .../winsys/radeon/drm/radeon_drm_winsys.c      |  5 +----
 12 files changed, 15 insertions(+), 48 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index f47d007549de..73ac198e7091 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -881,11 +881,6 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
       return false;
    }
 
-   info->smart_access_memory = info->all_vram_visible &&
-                               info->gfx_level >= GFX10_3 &&
-                               util_get_cpu_caps()->family >= CPU_AMD_ZEN3 &&
-                               util_get_cpu_caps()->family < CPU_AMD_LAST;
-
    info->family_id = device_info.family;
    info->chip_external_rev = device_info.external_rev;
    info->chip_rev = device_info.chip_rev;
@@ -1586,7 +1581,6 @@ void ac_print_gpu_info(struct radeon_info *info, FILE *f)
    fprintf(f, "    address32_hi = 0x%x\n", info->address32_hi);
    fprintf(f, "    has_dedicated_vram = %u\n", info->has_dedicated_vram);
    fprintf(f, "    all_vram_visible = %u\n", info->all_vram_visible);
-   fprintf(f, "    smart_access_memory = %u\n", info->smart_access_memory);
    fprintf(f, "    max_tcc_blocks = %i\n", info->max_tcc_blocks);
    fprintf(f, "    tcc_cache_line_size = %u\n", info->tcc_cache_line_size);
    fprintf(f, "    tcc_rb_non_coherent = %u\n", info->tcc_rb_non_coherent);
diff --git a/src/amd/common/ac_gpu_info.h b/src/amd/common/ac_gpu_info.h
index babbf698a889..955d6a4ea31d 100644
--- a/src/amd/common/ac_gpu_info.h
+++ b/src/amd/common/ac_gpu_info.h
@@ -145,7 +145,6 @@ struct radeon_info {
    uint32_t address32_hi;
    bool has_dedicated_vram;
    bool all_vram_visible;
-   bool smart_access_memory;
    bool has_l2_uncached;
    bool r600_has_virtual_memory;
    uint32_t max_tcc_blocks;
diff --git a/src/gallium/drivers/r300/r300_screen.c b/src/gallium/drivers/r300/r300_screen.c
index bd53c99443b9..c033ccb4469b 100644
--- a/src/gallium/drivers/r300/r300_screen.c
+++ b/src/gallium/drivers/r300/r300_screen.c
@@ -822,7 +822,7 @@ struct pipe_screen* r300_screen_create(struct radeon_winsys *rws,
         return NULL;
     }
 
-    rws->query_info(rws, &r300screen->info, false, false);
+    rws->query_info(rws, &r300screen->info);
 
     r300_init_debug(r300screen);
     r300_parse_chipset(r300screen->info.pci_id, &r300screen->caps);
diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index de9d2e244eaa..4b9e3236399f 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -1212,7 +1212,7 @@ bool r600_common_screen_init(struct r600_common_screen *rscreen,
 	struct utsname uname_data;
 	const char *chip_name;
 
-	ws->query_info(ws, &rscreen->info, false, false);
+	ws->query_info(ws, &rscreen->info);
 	rscreen->ws = ws;
 
 	chip_name = r600_get_family_name(rscreen);
diff --git a/src/gallium/drivers/r600/radeon_uvd.c b/src/gallium/drivers/r600/radeon_uvd.c
index 35471e51d6a4..7b29b2dae184 100644
--- a/src/gallium/drivers/r600/radeon_uvd.c
+++ b/src/gallium/drivers/r600/radeon_uvd.c
@@ -1052,7 +1052,7 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 	struct ruvd_decoder *dec;
 	int r, i;
 
-	ws->query_info(ws, &info, false, false);
+	ws->query_info(ws, &info);
 
 	switch(u_reduce_video_profile(templ->profile)) {
 	case PIPE_VIDEO_FORMAT_MPEG12:
diff --git a/src/gallium/drivers/r600/radeon_video.c b/src/gallium/drivers/r600/radeon_video.c
index 6ada9ba18622..c28bb7992b89 100644
--- a/src/gallium/drivers/r600/radeon_video.c
+++ b/src/gallium/drivers/r600/radeon_video.c
@@ -224,7 +224,7 @@ int rvid_get_video_param(struct pipe_screen *screen,
 	enum pipe_video_format codec = u_reduce_video_profile(profile);
 	struct radeon_info info;
 
-	rscreen->ws->query_info(rscreen->ws, &info, false, false);
+	rscreen->ws->query_info(rscreen->ws);
 
 	if (entrypoint == PIPE_VIDEO_ENTRYPOINT_ENCODE) {
 		switch (param) {
diff --git a/src/gallium/drivers/radeonsi/si_buffer.c b/src/gallium/drivers/radeonsi/si_buffer.c
index 7a07a84d362b..a650c0d57272 100644
--- a/src/gallium/drivers/radeonsi/si_buffer.c
+++ b/src/gallium/drivers/radeonsi/si_buffer.c
@@ -56,10 +56,7 @@ void si_init_resource_fields(struct si_screen *sscreen, struct si_resource *res,
    switch (res->b.b.usage) {
    case PIPE_USAGE_STREAM:
       res->flags |= RADEON_FLAG_GTT_WC;
-      if (sscreen->info.smart_access_memory)
-         res->domains = RADEON_DOMAIN_VRAM;
-      else
-         res->domains = RADEON_DOMAIN_GTT;
+      res->domains = RADEON_DOMAIN_GTT;
       break;
    case PIPE_USAGE_STAGING:
       /* Transfers are likely to occur more often with these
@@ -157,8 +154,7 @@ void si_init_resource_fields(struct si_screen *sscreen, struct si_resource *res,
        * because they might never be moved back again. If a buffer is large enough,
        * upload data by copying from a temporary GTT buffer.
        */
-      if (!sscreen->info.smart_access_memory &&
-          sscreen->info.has_dedicated_vram &&
+      if (sscreen->info.has_dedicated_vram &&
           !res->b.cpu_storage && /* TODO: The CPU storage breaks this. */
           size >= sscreen->options.max_vram_map_size)
          res->b.b.flags |= PIPE_RESOURCE_FLAG_DONT_MAP_DIRECTLY;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 8a92a922bad6..a358b620f963 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -555,24 +555,20 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
       goto fail;
    }
 
-   /* Initialize public allocators. */
-   /* Unify uploaders as follows:
-    * - dGPUs with Smart Access Memory: there is only one uploader instance writing to VRAM.
+   /* Initialize public allocators. Unify uploaders as follows:
+    * - dGPUs: The const uploader writes to VRAM and the stream uploader writes to RAM.
     * - APUs: There is only one uploader instance writing to RAM. VRAM has the same perf on APUs.
-    * - Other chips: The const uploader writes to VRAM and the stream uploader writes to RAM.
     */
-   bool smart_access_memory = sscreen->info.smart_access_memory;
    bool is_apu = !sscreen->info.has_dedicated_vram;
    sctx->b.stream_uploader =
-      u_upload_create(&sctx->b, 1024 * 1024, 0,
-                      smart_access_memory && !is_apu ? PIPE_USAGE_DEFAULT : PIPE_USAGE_STREAM,
+      u_upload_create(&sctx->b, 1024 * 1024, 0, PIPE_USAGE_STREAM,
                       SI_RESOURCE_FLAG_32BIT); /* same flags as const_uploader */
    if (!sctx->b.stream_uploader) {
       fprintf(stderr, "radeonsi: can't create stream_uploader\n");
       goto fail;
    }
 
-   if (smart_access_memory || is_apu) {
+   if (is_apu) {
       sctx->b.const_uploader = sctx->b.stream_uploader;
    } else {
       sctx->b.const_uploader =
@@ -1136,11 +1132,7 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
    }
 
    sscreen->ws = ws;
-   ws->query_info(ws, &sscreen->info,
-                  sscreen->options.enable_sam,
-                  sscreen->options.disable_sam);
-
-   sscreen->info.smart_access_memory = false; /* VRAM has slower CPU access */
+   ws->query_info(ws, &sscreen->info);
 
    if (sscreen->info.gfx_level >= GFX9) {
       sscreen->se_tile_repeat = 32 * sscreen->info.max_se;
diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index d5905189f97d..43ac610e747c 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -1878,8 +1878,7 @@ static void *si_texture_transfer_map(struct pipe_context *ctx, struct pipe_resou
        * is busy.
        */
       if (!tex->surface.is_linear || (tex->buffer.flags & RADEON_FLAG_ENCRYPTED) ||
-          (tex->buffer.domains & RADEON_DOMAIN_VRAM && sctx->screen->info.has_dedicated_vram &&
-           !sctx->screen->info.smart_access_memory))
+          (tex->buffer.domains & RADEON_DOMAIN_VRAM && sctx->screen->info.has_dedicated_vram))
          use_staging_texture = true;
       else if (usage & PIPE_MAP_READ)
          use_staging_texture =
diff --git a/src/gallium/include/winsys/radeon_winsys.h b/src/gallium/include/winsys/radeon_winsys.h
index 1bc9c1239c1a..c1d7f6dfd433 100644
--- a/src/gallium/include/winsys/radeon_winsys.h
+++ b/src/gallium/include/winsys/radeon_winsys.h
@@ -321,9 +321,7 @@ struct radeon_winsys {
     * \param ws        The winsys this function is called from.
     * \param info      Return structure
     */
-   void (*query_info)(struct radeon_winsys *ws, struct radeon_info *info,
-                      bool enable_smart_access_memory,
-                      bool disable_smart_access_memory);
+   void (*query_info)(struct radeon_winsys *ws, struct radeon_info *info);
 
    /**
     * A hint for the winsys that it should pin its execution threads to
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
index 3e4625ca4ab7..e00f6cdf3469 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
@@ -197,18 +197,10 @@ static void amdgpu_winsys_destroy(struct radeon_winsys *rws)
    amdgpu_winsys_destroy_locked(rws, false);
 }
 
-static void amdgpu_winsys_query_info(struct radeon_winsys *rws,
-                                     struct radeon_info *info,
-                                     bool enable_smart_access_memory,
-                                     bool disable_smart_access_memory)
+static void amdgpu_winsys_query_info(struct radeon_winsys *rws, struct radeon_info *info)
 {
    struct amdgpu_winsys *ws = amdgpu_winsys(rws);
 
-   if (disable_smart_access_memory)
-      ws->info.smart_access_memory = false;
-   else if (enable_smart_access_memory && ws->info.all_vram_visible)
-      ws->info.smart_access_memory = true;
-
    *info = ws->info;
 }
 
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
index 2dca061003c2..8cd8e055ef56 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
@@ -621,10 +621,7 @@ static void radeon_winsys_destroy(struct radeon_winsys *rws)
    FREE(rws);
 }
 
-static void radeon_query_info(struct radeon_winsys *rws,
-                              struct radeon_info *info,
-                              bool enable_smart_access_memory,
-                              bool disable_smart_access_memory)
+static void radeon_query_info(struct radeon_winsys *rws, struct radeon_info *info)
 {
    *info = ((struct radeon_drm_winsys *)rws)->info;
 }
-- 
GitLab


From 748cdae23004a891655398b48ef9112b388da5eb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 21 Feb 2023 02:16:37 -0500
Subject: [PATCH 33/45] radeonsi: don't set PACKET_TO_ONE_PA for line stippling

A hw guy told me this.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/vulkan/radv_cmd_buffer.c               | 2 +-
 src/gallium/drivers/radeonsi/si_state_draw.cpp | 4 +++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 80100dcfe5ba..a2fd1996312f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5157,7 +5157,7 @@ gfx10_emit_ge_cntl(struct radv_cmd_buffer *cmd_buffer)
 
    ge_cntl = S_03096C_PRIM_GRP_SIZE_GFX10(primgroup_size) |
              S_03096C_VERT_GRP_SIZE(256) | /* disable vertex grouping */
-             S_03096C_PACKET_TO_ONE_PA(0) /* line stipple */ |
+             S_03096C_PACKET_TO_ONE_PA(0) /* this should only be set if LINE_STIPPLE_TEX_ENA == 1 */ |
              S_03096C_BREAK_WAVE_AT_EOI(break_wave_at_eoi);
 
    if (state->last_ge_cntl != ge_cntl) {
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 8204d9e1e54e..a8ee703b6a9a 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -1325,7 +1325,9 @@ static void gfx10_emit_ge_cntl(struct si_context *sctx, unsigned num_patches)
                 S_03096C_BREAK_WAVE_AT_EOI(key.u.uses_tess && key.u.tess_uses_prim_id);
    }
 
-   ge_cntl |= S_03096C_PACKET_TO_ONE_PA(si_is_line_stipple_enabled(sctx));
+   /* Note: GE_CNTL.PACKET_TO_ONE_PA should only be set if LINE_STIPPLE_TEX_ENA == 1.
+    * Since we don't use that, we don't have to do anything.
+    */
 
    if (ge_cntl != sctx->last_multi_vgt_param) {
       struct radeon_cmdbuf *cs = &sctx->gfx_cs;
-- 
GitLab


From 57865ec68732dcd46071ffe4bb6e994443ccf270 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 21 Feb 2023 08:04:41 -0500
Subject: [PATCH 34/45] radeonsi/gfx11: change the default of
 COMPUTE_DISPATCH_INTERLEAVE to 256

This is an internal recommendation.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/drivers/radeonsi/si_compute.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index caf4b05a52cc..d8491fb4c0dc 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -465,7 +465,11 @@ void si_emit_initial_compute_regs(struct si_context *sctx, struct radeon_cmdbuf
       radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE6 */
       radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE7 */
 
-      radeon_set_sh_reg(R_00B8BC_COMPUTE_DISPATCH_INTERLEAVE, 64);
+      /* How many threads should go to 1 SE before moving onto the next. Think of GL1 cache hits.
+       * Only these values are valid: 0 (disabled), 64, 128, 256, 512
+       * Recommendation: 64 = RT, 256 = non-RT (run benchmarks to be sure)
+       */
+      radeon_set_sh_reg(R_00B8BC_COMPUTE_DISPATCH_INTERLEAVE, S_00B8BC_INTERLEAVE(256));
    }
 
    radeon_end();
-- 
GitLab


From 1c03891a146c83ae440585467bbfe3aec9632494 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Jan 2023 19:15:35 -0500
Subject: [PATCH 35/45] amd: implement conformant TRUNC_COORD behavior for
 gfx11

For testing, the conformant behavior can be enabled by setting
conformant_trunc_coord to true manually and running this to enable
the conformant behavior in hw:
    umr -w *.*.regTA_CNTL2 0x40000

The layer index rounding and TRUNC_COORD resetting workarounds can disabled
in the shader compiler.
---
 include/drm-uapi/amdgpu_drm.h                 |  1 +
 src/amd/common/ac_gpu_info.c                  |  6 ++++++
 src/amd/common/ac_gpu_info.h                  | 16 ++++++++++++++++
 src/amd/llvm/ac_nir_to_llvm.c                 |  8 +++++---
 src/amd/llvm/ac_shader_abi.h                  |  3 +++
 src/amd/vulkan/radv_device.c                  |  3 ++-
 src/amd/vulkan/radv_nir_to_llvm.c             |  1 +
 src/amd/vulkan/radv_shader.c                  |  3 ++-
 src/amd/vulkan/radv_shader.h                  |  1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  1 +
 src/gallium/drivers/radeonsi/si_state.c       |  7 ++++---
 11 files changed, 42 insertions(+), 8 deletions(-)

diff --git a/include/drm-uapi/amdgpu_drm.h b/include/drm-uapi/amdgpu_drm.h
index 973af6d06626..45dc7e00c898 100644
--- a/include/drm-uapi/amdgpu_drm.h
+++ b/include/drm-uapi/amdgpu_drm.h
@@ -715,6 +715,7 @@ struct drm_amdgpu_cs_chunk_data {
 #define AMDGPU_IDS_FLAGS_FUSION         0x1
 #define AMDGPU_IDS_FLAGS_PREEMPTION     0x2
 #define AMDGPU_IDS_FLAGS_TMZ            0x4
+#define AMDGPU_IDS_FLAGS_CONFORMANT_TRUNC_COORD 0x8
 
 /* indicate if acceleration can be working */
 #define AMDGPU_INFO_ACCEL_WORKING		0x00
diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 73ac198e7091..ab57797f81b0 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -64,6 +64,7 @@
 #define AMDGPU_IDS_FLAGS_FUSION 0x1
 #define AMDGPU_IDS_FLAGS_PREEMPTION 0x2
 #define AMDGPU_IDS_FLAGS_TMZ 0x4
+#define AMDGPU_IDS_FLAGS_CONFORMANT_TRUNC_COORD 0x8
 #define AMDGPU_INFO_FW_VCE 0x1
 #define AMDGPU_INFO_FW_UVD 0x2
 #define AMDGPU_INFO_FW_GFX_ME 0x04
@@ -1412,6 +1413,10 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
 
       info->has_set_reg_pairs = info->pfp_fw_version >= SET_REG_PAIRS_PFP_VERSION;
       info->has_set_sh_reg_pairs_n = info->pfp_fw_version >= SET_REG_PAIRS_PACKED_N_COUNT14_PFP_VERSION;
+
+      info->conformant_trunc_coord =
+         info->drm_minor >= 52 &&
+         device_info.ids_flags & AMDGPU_IDS_FLAGS_CONFORMANT_TRUNC_COORD;
    }
 
    set_custom_cu_en_mask(info);
@@ -1564,6 +1569,7 @@ void ac_print_gpu_info(struct radeon_info *info, FILE *f)
    fprintf(f, "    never_send_perfcounter_stop = %i\n", info->never_send_perfcounter_stop);
    fprintf(f, "    discardable_allows_big_page = %i\n", info->discardable_allows_big_page);
    fprintf(f, "    has_taskmesh_indirect0_bug = %i\n", info->has_taskmesh_indirect0_bug);
+   fprintf(f, "    conformant_trunc_coord = %i\n", info->conformant_trunc_coord);
 
    fprintf(f, "Display features:\n");
    fprintf(f, "    use_display_dcc_unaligned = %u\n", info->use_display_dcc_unaligned);
diff --git a/src/amd/common/ac_gpu_info.h b/src/amd/common/ac_gpu_info.h
index 955d6a4ea31d..367dcb9077aa 100644
--- a/src/amd/common/ac_gpu_info.h
+++ b/src/amd/common/ac_gpu_info.h
@@ -126,6 +126,22 @@ struct radeon_info {
    bool has_vrs_ds_export_bug;
    bool has_taskmesh_indirect0_bug;
 
+   /* conformant_trunc_coord is equal to TA_CNTL2.TRUNCATE_COORD_MODE, which exists since gfx11.
+    *
+    * If TA_CNTL2.TRUNCATE_COORD_MODE == 0, coordinate truncation is the same as gfx10 and older.
+    * If TA_CNTL2.TRUNCATE_COORD_MODE == 1, coordinate truncation is adjusted to be conformant
+    * if you also set TRUNC_COORD.
+    *
+    * Behavior:
+    *    truncate_coord_xy = TRUNC_COORD &&
+    *                        ((xy_filter == Point && !gather) || !TA_CNTL2.TRUNCATE_COORD_MODE);
+    *    truncate_coord_z = TRUNC_COORD && (z_filter == Point || !TA_CNTL2.TRUNCATE_COORD_MODE);
+    *    truncate_coord_layer = TRUNC_COORD && !TA_CNTL2.TRUNCATE_COORD_MODE;
+    *
+    * AnisoPoint is treated as Point.
+    */
+   bool conformant_trunc_coord;
+
    /* Display features. */
    /* There are 2 display DCC codepaths, because display expects unaligned DCC. */
    /* Disable RB and pipe alignment to skip the retile blit. (1 RB chips only) */
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index e2f84bc15e63..b4481d57eb8a 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4621,7 +4621,8 @@ static void visit_tex(struct ac_nir_context *ctx, nir_tex_instr *instr)
    /* Texture coordinates fixups */
    if (instr->coord_components > 1 && instr->sampler_dim == GLSL_SAMPLER_DIM_1D &&
        instr->is_array && instr->op != nir_texop_txf) {
-      args.coords[1] = apply_round_slice(&ctx->ac, args.coords[1]);
+      if (!ctx->abi->conformant_trunc_coord)
+         args.coords[1] = apply_round_slice(&ctx->ac, args.coords[1]);
    }
 
    if (instr->coord_components > 2 &&
@@ -4630,7 +4631,8 @@ static void visit_tex(struct ac_nir_context *ctx, nir_tex_instr *instr)
         instr->sampler_dim == GLSL_SAMPLER_DIM_SUBPASS_MS) &&
        instr->is_array && instr->op != nir_texop_txf && instr->op != nir_texop_txf_ms &&
        instr->op != nir_texop_fragment_fetch_amd && instr->op != nir_texop_fragment_mask_fetch_amd) {
-      args.coords[2] = apply_round_slice(&ctx->ac, args.coords[2]);
+      if (!ctx->abi->conformant_trunc_coord)
+         args.coords[2] = apply_round_slice(&ctx->ac, args.coords[2]);
    }
 
    if (ctx->ac.gfx_level == GFX9 && instr->sampler_dim == GLSL_SAMPLER_DIM_1D &&
@@ -4696,7 +4698,7 @@ static void visit_tex(struct ac_nir_context *ctx, nir_tex_instr *instr)
    }
 
    /* Set TRUNC_COORD=0 for textureGather(). */
-   if (instr->op == nir_texop_tg4) {
+   if (instr->op == nir_texop_tg4 && !ctx->abi->conformant_trunc_coord) {
       LLVMValueRef dword0 = LLVMBuildExtractElement(ctx->ac.builder, args.sampler, ctx->ac.i32_0, "");
       dword0 = LLVMBuildAnd(ctx->ac.builder, dword0, LLVMConstInt(ctx->ac.i32, C_008F30_TRUNC_COORD, 0), "");
       args.sampler = LLVMBuildInsertElement(ctx->ac.builder, args.sampler, dword0, ctx->ac.i32_0, "");
diff --git a/src/amd/llvm/ac_shader_abi.h b/src/amd/llvm/ac_shader_abi.h
index 4943346a0a05..470d85b36535 100644
--- a/src/amd/llvm/ac_shader_abi.h
+++ b/src/amd/llvm/ac_shader_abi.h
@@ -129,6 +129,9 @@ struct ac_shader_abi {
    /* Whether to disable anisotropic filtering. */
    bool disable_aniso_single_level;
 
+   /* Equal to radeon_info::conformant_trunc_coord. */
+   bool conformant_trunc_coord;
+
    /* Number of all interpolated inputs */
    unsigned num_interp;
 };
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 4e21cecf2ce3..c97509c875fd 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -7694,7 +7694,8 @@ radv_init_sampler(struct radv_device *device, struct radv_sampler *sampler,
    unsigned filter_mode = V_008F30_SQ_IMG_FILTER_MODE_BLEND;
    unsigned depth_compare_func = V_008F30_SQ_TEX_DEPTH_COMPARE_NEVER;
    bool trunc_coord =
-      pCreateInfo->minFilter == VK_FILTER_NEAREST && pCreateInfo->magFilter == VK_FILTER_NEAREST;
+      (pCreateInfo->minFilter == VK_FILTER_NEAREST && pCreateInfo->magFilter == VK_FILTER_NEAREST) ||
+      device->physical_device->rad_info.conformant_trunc_coord;
    bool uses_border_color = pCreateInfo->addressModeU == VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER ||
                             pCreateInfo->addressModeV == VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER ||
                             pCreateInfo->addressModeW == VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index c017bc87098e..7f162bc85d8e 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -907,6 +907,7 @@ ac_translate_nir_to_llvm(struct ac_llvm_compiler *ac_llvm,
    ctx.abi.clamp_shadow_reference = false;
    ctx.abi.robust_buffer_access = options->robust_buffer_access;
    ctx.abi.load_grid_size_from_user_sgpr = args->load_grid_size_from_user_sgpr;
+   ctx.abi.conformant_trunc_coord = options->conformant_trunc_coord;
 
    bool is_ngg = is_pre_gs_stage(shaders[0]->info.stage) && info->is_ngg;
    if (shader_count >= 2 || is_ngg)
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 3908a03baa97..59e375dd44e4 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -927,7 +927,7 @@ radv_shader_spirv_to_nir(struct radv_device *device, const struct radv_pipeline_
       .lower_to_fragment_fetch_amd = device->physical_device->use_fmask,
       .lower_lod_zero_width = true,
       .lower_invalid_implicit_lod = true,
-      .lower_array_layer_round_even = true,
+      .lower_array_layer_round_even = !device->physical_device->rad_info.conformant_trunc_coord,
    };
 
    NIR_PASS(_, nir, nir_lower_tex, &tex_options);
@@ -2323,6 +2323,7 @@ radv_fill_nir_compiler_options(struct radv_nir_compiler_options *options,
    options->family = device->physical_device->rad_info.family;
    options->gfx_level = device->physical_device->rad_info.gfx_level;
    options->has_3d_cube_border_color_mipmap = device->physical_device->rad_info.has_3d_cube_border_color_mipmap;
+   options->conformant_trunc_coord = device->physical_device->rad_info.conformant_trunc_coord;
    options->dump_shader = can_dump_shader;
    options->dump_preoptir =
       options->dump_shader && device->instance->debug_flags & RADV_DEBUG_PREOPTIR;
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index f928e3d3a75b..549daac9f4ba 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -137,6 +137,7 @@ struct radv_nir_compiler_options {
    enum amd_gfx_level gfx_level;
    uint32_t address32_hi;
    bool has_3d_cube_border_color_mipmap;
+   bool conformant_trunc_coord;
 
    struct {
       void (*func)(void *private_data, enum aco_compiler_debug_level level, const char *message);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 7d84520b6501..635070974f9a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1002,6 +1002,7 @@ static bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shade
                                 info->options & SI_PROFILE_CLAMP_DIV_BY_ZERO;
    ctx->abi.use_waterfall_for_divergent_tex_samplers = true;
    ctx->abi.disable_aniso_single_level = true;
+   ctx->abi.conformant_trunc_coord = ctx->screen->info.conformant_trunc_coord;
 
    unsigned num_outputs = info->num_outputs;
    /* need extra output to hold primitive id added by nir lower */
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index d51d09f246da..119c9ace8f59 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4765,9 +4765,10 @@ static void *si_create_sampler_state(struct pipe_context *ctx,
    struct si_sampler_state *rstate = CALLOC_STRUCT(si_sampler_state);
    unsigned max_aniso = sscreen->force_aniso >= 0 ? sscreen->force_aniso : state->max_anisotropy;
    unsigned max_aniso_ratio = si_tex_aniso_filter(max_aniso);
-   bool trunc_coord = state->min_img_filter == PIPE_TEX_FILTER_NEAREST &&
-                      state->mag_img_filter == PIPE_TEX_FILTER_NEAREST &&
-                      state->compare_mode == PIPE_TEX_COMPARE_NONE;
+   bool trunc_coord = (state->min_img_filter == PIPE_TEX_FILTER_NEAREST &&
+                       state->mag_img_filter == PIPE_TEX_FILTER_NEAREST &&
+                       state->compare_mode == PIPE_TEX_COMPARE_NONE) ||
+                      sscreen->info.conformant_trunc_coord;
    union pipe_color_union clamped_border_color;
 
    if (!rstate) {
-- 
GitLab


From 9b76bc82c7cd316da7238100c85ca369a676a39c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 03:39:42 -0500
Subject: [PATCH 36/45] amd: update amdgpu_drm.h

---
 include/drm-uapi/amdgpu_drm.h | 10 ++++++++++
 src/amd/common/ac_gpu_info.c  | 10 ++++++++++
 2 files changed, 20 insertions(+)

diff --git a/include/drm-uapi/amdgpu_drm.h b/include/drm-uapi/amdgpu_drm.h
index 45dc7e00c898..b6eb90df5d05 100644
--- a/include/drm-uapi/amdgpu_drm.h
+++ b/include/drm-uapi/amdgpu_drm.h
@@ -1116,6 +1116,16 @@ struct drm_amdgpu_info_device {
 	__u64 tcc_disabled_mask;
 	__u64 min_engine_clock;
 	__u64 min_memory_clock;
+	/* The following fields are only set on gfx11+, older chips set 0. */
+	__u32 tcp_cache_size;       /* AKA GL0, VMEM cache */
+	__u32 num_sqc_per_wgp;
+	__u32 sqc_data_cache_size;  /* AKA SMEM cache */
+	__u32 sqc_inst_cache_size;
+	__u32 gl1c_cache_size;
+	__u32 gl2c_cache_size;
+	__u64 mall_size;            /* AKA infinity cache */
+	/* high 32 bits of the rb pipes mask */
+	__u32 enabled_rb_pipes_mask_hi;
 };
 
 struct drm_amdgpu_info_hw_ip {
diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index ab57797f81b0..55c1c146bde7 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -184,6 +184,16 @@ struct drm_amdgpu_info_device {
 	uint64_t tcc_disabled_mask;
 	uint64_t min_engine_clock;
 	uint64_t min_memory_clock;
+	/* The following fields are only set on gfx11+, older chips set 0. */
+	uint32_t tcp_cache_size;       /* AKA GL0, VMEM cache */
+	uint32_t num_sqc_per_wgp;
+	uint32_t sqc_data_cache_size;  /* AKA SMEM cache */
+	uint32_t sqc_inst_cache_size;
+	uint32_t gl1c_cache_size;
+	uint32_t gl2c_cache_size;
+	uint64_t mall_size;            /* AKA infinity cache */
+	/* high 32 bits of the rb pipes mask */
+	uint32_t enabled_rb_pipes_mask_hi;
 };
 struct drm_amdgpu_info_hw_ip {
    uint32_t hw_ip_version_major;
-- 
GitLab


From 6010a68a1c22fce512c05d2e9e097cddd82b9071 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 03:40:41 -0500
Subject: [PATCH 37/45] amd,radeonsi: change enabled_rb_mask to 64 bits

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/common/ac_gpu_info.c                      | 9 ++++++---
 src/amd/common/ac_gpu_info.h                      | 2 +-
 src/gallium/drivers/r600/r600_pipe_common.c       | 2 +-
 src/gallium/drivers/radeonsi/si_query.c           | 4 ++--
 src/gallium/drivers/radeonsi/si_state.c           | 2 +-
 src/gallium/winsys/radeon/drm/radeon_drm_winsys.c | 9 ++++++---
 6 files changed, 17 insertions(+), 11 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 55c1c146bde7..501865220bdc 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1217,7 +1217,10 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
       (info->num_cu / (info->num_se * info->max_sa_per_se * cu_group)) * cu_group;
 
    memcpy(info->si_tile_mode_array, amdinfo.gb_tile_mode, sizeof(amdinfo.gb_tile_mode));
-   info->enabled_rb_mask = amdinfo.enabled_rb_pipes_mask;
+
+   info->enabled_rb_mask = device_info.enabled_rb_pipes_mask;
+   if (info->drm_minor >= 52)
+      info->enabled_rb_mask |= (uint64_t)device_info.enabled_rb_pipes_mask_hi << 32;
 
    memcpy(info->cik_macrotile_mode_array, amdinfo.gb_macro_tile_mode,
           sizeof(amdinfo.gb_macro_tile_mode));
@@ -1319,7 +1322,7 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
                                     info->family == CHIP_NAVI24 ||
                                     info->family == CHIP_REMBRANDT ||
                                     info->family == CHIP_VANGOGH) &&
-                                   util_bitcount(info->enabled_rb_mask) !=
+                                   util_bitcount64(info->enabled_rb_mask) !=
                                    info->max_render_backends;
 
    /* On GFX10.3, the polarity of AUTO_FLUSH_MODE is inverted. */
@@ -1681,7 +1684,7 @@ void ac_print_gpu_info(struct radeon_info *info, FILE *f)
    fprintf(f, "    max_render_backends = %i\n", info->max_render_backends);
    fprintf(f, "    num_tile_pipes = %i\n", info->num_tile_pipes);
    fprintf(f, "    pipe_interleave_bytes = %i\n", info->pipe_interleave_bytes);
-   fprintf(f, "    enabled_rb_mask = 0x%x\n", info->enabled_rb_mask);
+   fprintf(f, "    enabled_rb_mask = 0x%" PRIx64 "\n", info->enabled_rb_mask);
    fprintf(f, "    max_alignment = %u\n", (unsigned)info->max_alignment);
    fprintf(f, "    pbb_max_alloc_count = %u\n", info->pbb_max_alloc_count);
 
diff --git a/src/amd/common/ac_gpu_info.h b/src/amd/common/ac_gpu_info.h
index 367dcb9077aa..f856a1ae6fdf 100644
--- a/src/amd/common/ac_gpu_info.h
+++ b/src/amd/common/ac_gpu_info.h
@@ -256,7 +256,7 @@ struct radeon_info {
    uint32_t max_render_backends;  /* number of render backends incl. disabled ones */
    uint32_t num_tile_pipes; /* pipe count from PIPE_CONFIG */
    uint32_t pipe_interleave_bytes;
-   uint32_t enabled_rb_mask; /* GCN harvest config */
+   uint64_t enabled_rb_mask; /* RB harvest config */
    uint64_t max_alignment;   /* from addrlib */
    uint32_t pbb_max_alloc_count;
 
diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index 4b9e3236399f..38fbb6632504 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -1320,7 +1320,7 @@ bool r600_common_screen_init(struct r600_common_screen *rscreen,
 		printf("num_render_backends = %i\n", rscreen->info.max_render_backends);
 		printf("num_tile_pipes = %i\n", rscreen->info.num_tile_pipes);
 		printf("pipe_interleave_bytes = %i\n", rscreen->info.pipe_interleave_bytes);
-		printf("enabled_rb_mask = 0x%x\n", rscreen->info.enabled_rb_mask);
+		printf("enabled_rb_mask = 0x%" PRIx64 "\n", rscreen->info.enabled_rb_mask);
 		printf("max_alignment = %u\n", (unsigned)rscreen->info.max_alignment);
 	}
 
diff --git a/src/gallium/drivers/radeonsi/si_query.c b/src/gallium/drivers/radeonsi/si_query.c
index cd7f2501225e..d5135c61ad54 100644
--- a/src/gallium/drivers/radeonsi/si_query.c
+++ b/src/gallium/drivers/radeonsi/si_query.c
@@ -617,7 +617,7 @@ static bool si_query_hw_prepare_buffer(struct si_context *sctx, struct si_query_
        query->b.type == PIPE_QUERY_OCCLUSION_PREDICATE ||
        query->b.type == PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE) {
       unsigned max_rbs = screen->info.max_render_backends;
-      unsigned enabled_rb_mask = screen->info.enabled_rb_mask;
+      uint64_t enabled_rb_mask = screen->info.enabled_rb_mask;
       unsigned num_results;
       unsigned i, j;
 
@@ -625,7 +625,7 @@ static bool si_query_hw_prepare_buffer(struct si_context *sctx, struct si_query_
       num_results = qbuf->buf->b.b.width0 / query->result_size;
       for (j = 0; j < num_results; j++) {
          for (i = 0; i < max_rbs; i++) {
-            if (!(enabled_rb_mask & (1 << i))) {
+            if (!(enabled_rb_mask & (1ull << i))) {
                results[(i * 4) + 1] = 0x80000000;
                results[(i * 4) + 3] = 0x80000000;
             }
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 119c9ace8f59..db5ed800c204 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -2433,7 +2433,7 @@ static bool si_is_format_supported(struct pipe_screen *screen, enum pipe_format
       /* Chips with 1 RB don't increment occlusion queries at 16x MSAA sample rate,
        * so don't expose 16 samples there.
        */
-      const unsigned max_eqaa_samples = util_bitcount(sscreen->info.enabled_rb_mask) <= 1 ? 8 : 16;
+      const unsigned max_eqaa_samples = util_bitcount64(sscreen->info.enabled_rb_mask) <= 1 ? 8 : 16;
       const unsigned max_samples = 8;
 
       /* MSAA support without framebuffer attachments. */
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
index 8cd8e055ef56..b0e94422fe28 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
@@ -443,9 +443,12 @@ static bool do_winsys_init(struct radeon_drm_winsys *ws)
        * This fails (silently) on non-GCN or older kernels, overwriting the
        * default enabled_rb_mask with the result of the last query.
        */
-      if (ws->gen >= DRV_SI)
-         radeon_get_drm_value(ws->fd, RADEON_INFO_SI_BACKEND_ENABLED_MASK, NULL,
-                              &ws->info.enabled_rb_mask);
+      if (ws->gen >= DRV_SI) {
+         uint32_t mask;
+
+         radeon_get_drm_value(ws->fd, RADEON_INFO_SI_BACKEND_ENABLED_MASK, NULL, &mask);
+         ws->info.enabled_rb_mask = mask;
+      }
 
       ws->info.r600_has_virtual_memory = false;
 
-- 
GitLab


From 357471958308ae709030e29bcf0e4c7e477dcf31 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 18 Feb 2023 03:54:27 -0500
Subject: [PATCH 38/45] amd: query cache sizes from the kernel

Also rename l1_cache_size -> tcp_cache_size. L1 means shader array cache.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/common/ac_gpu_info.c | 113 +++++++++++++++++++++--------------
 src/amd/common/ac_gpu_info.h |   4 ++
 src/amd/common/ac_rgp.c      |   2 +-
 3 files changed, 73 insertions(+), 46 deletions(-)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 501865220bdc..3fc464925ec7 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -985,42 +985,64 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
 
    info->tcc_rb_non_coherent = !util_is_power_of_two_or_zero(info->num_tcc_blocks);
 
-   switch (info->family) {
-   case CHIP_TAHITI:
-   case CHIP_PITCAIRN:
-   case CHIP_OLAND:
-   case CHIP_HAWAII:
-   case CHIP_KABINI:
-   case CHIP_TONGA:
-   case CHIP_STONEY:
-   case CHIP_RAVEN2:
-      info->l2_cache_size = info->num_tcc_blocks * 64 * 1024;
-      break;
-   case CHIP_VERDE:
-   case CHIP_HAINAN:
-   case CHIP_BONAIRE:
-   case CHIP_KAVERI:
-   case CHIP_ICELAND:
-   case CHIP_CARRIZO:
-   case CHIP_FIJI:
-   case CHIP_POLARIS12:
-   case CHIP_VEGAM:
-   case CHIP_GFX1036:
-      info->l2_cache_size = info->num_tcc_blocks * 128 * 1024;
-      break;
-   default:
-      info->l2_cache_size = info->num_tcc_blocks * 256 * 1024;
-      break;
-   case CHIP_REMBRANDT:
-   case CHIP_GFX1103_R1:
-      info->l2_cache_size = info->num_tcc_blocks * 512 * 1024;
-      break;
+   if (info->drm_minor >= 52) {
+      info->sqc_inst_cache_size = device_info.sqc_inst_cache_size;
+      info->sqc_scalar_cache_size = device_info.sqc_data_cache_size;
+      info->num_sqc_per_wgp = device_info.num_sqc_per_wgp;
    }
 
-   if (info->gfx_level >= GFX11)
-      info->l1_cache_size = 32768;
-   else
-      info->l1_cache_size = 16384;
+   if (info->gfx_level >= GFX11 && info->drm_minor >= 52) {
+      info->tcp_cache_size = device_info.tcp_cache_size;
+      info->l1_cache_size = device_info.gl1c_cache_size;
+      info->l2_cache_size = device_info.gl2c_cache_size;
+      info->l3_cache_size_mb = DIV_ROUND_UP(device_info.mall_size, 1024 * 1024);
+   } else {
+      if (info->gfx_level >= GFX11) {
+         info->tcp_cache_size = 32768;
+         info->l1_cache_size = 256 * 1024;
+      } else {
+         info->tcp_cache_size = 16384;
+         info->l1_cache_size = 128 * 1024;
+      }
+
+      if (info->gfx_level >= GFX10_3 && info->has_dedicated_vram) {
+         info->l3_cache_size_mb = info->num_tcc_blocks *
+                                  (info->family == CHIP_NAVI21 ||
+                                   info->family == CHIP_NAVI22 ? 8 : 4);
+      }
+
+      switch (info->family) {
+      case CHIP_TAHITI:
+      case CHIP_PITCAIRN:
+      case CHIP_OLAND:
+      case CHIP_HAWAII:
+      case CHIP_KABINI:
+      case CHIP_TONGA:
+      case CHIP_STONEY:
+      case CHIP_RAVEN2:
+         info->l2_cache_size = info->num_tcc_blocks * 64 * 1024;
+         break;
+      case CHIP_VERDE:
+      case CHIP_HAINAN:
+      case CHIP_BONAIRE:
+      case CHIP_KAVERI:
+      case CHIP_ICELAND:
+      case CHIP_CARRIZO:
+      case CHIP_FIJI:
+      case CHIP_POLARIS12:
+      case CHIP_VEGAM:
+      case CHIP_GFX1036:
+         info->l2_cache_size = info->num_tcc_blocks * 128 * 1024;
+         break;
+      default:
+         info->l2_cache_size = info->num_tcc_blocks * 256 * 1024;
+         break;
+      case CHIP_REMBRANDT:
+      case CHIP_GFX1103_R1:
+         info->l2_cache_size = info->num_tcc_blocks * 512 * 1024;
+         break;
+      }
+   }
 
    info->mc_arb_ramcfg = amdinfo.mc_arb_ramcfg;
    info->gb_addr_config = amdinfo.gb_addr_cfg;
@@ -1400,12 +1422,6 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
       }
    }
 
-   if (info->gfx_level >= GFX10_3 && info->has_dedicated_vram) {
-      info->l3_cache_size_mb = info->num_tcc_blocks *
-                               (info->family == CHIP_NAVI21 ||
-                                info->family == CHIP_NAVI22 ? 8 : 4);
-   }
-
    if (info->gfx_level >= GFX11) {
       switch (info->family) {
       case CHIP_GFX1103_R1:
@@ -1502,13 +1518,20 @@ void ac_print_gpu_info(struct radeon_info *info, FILE *f)
    fprintf(f, "    max_gpu_freq = %i MHz\n", info->max_gpu_freq_mhz);
    fprintf(f, "    max_gflops = %u GFLOPS\n", info->max_gflops);
 
-   if (info->gfx_level >= GFX10) {
-      fprintf(f, "    l0_cache_size = %i KB\n", DIV_ROUND_UP(info->l1_cache_size, 1024));
-      fprintf(f, "    l1_cache_size = %i KB\n", info->gfx_level >= GFX11 ? 256 : 128);
-   } else {
-      fprintf(f, "    l1_cache_size = %i KB\n", DIV_ROUND_UP(info->l1_cache_size, 1024));
+   if (info->sqc_inst_cache_size) {
+      fprintf(f, "    sqc_inst_cache_size = %i KB (%u per WGP)\n",
+              DIV_ROUND_UP(info->sqc_inst_cache_size, 1024), info->num_sqc_per_wgp);
+   }
+   if (info->sqc_scalar_cache_size) {
+      fprintf(f, "    sqc_scalar_cache_size = %i KB (%u per WGP)\n",
+              DIV_ROUND_UP(info->sqc_scalar_cache_size, 1024), info->num_sqc_per_wgp);
    }
 
+   fprintf(f, "    tcp_cache_size = %i KB\n", DIV_ROUND_UP(info->tcp_cache_size, 1024));
+
+   if (info->gfx_level >= GFX10)
+      fprintf(f, "    l1_cache_size = %i KB\n", DIV_ROUND_UP(info->l1_cache_size, 1024));
+
    fprintf(f, "    l2_cache_size = %i KB\n", DIV_ROUND_UP(info->l2_cache_size, 1024));
 
    if (info->l3_cache_size_mb)
diff --git a/src/amd/common/ac_gpu_info.h b/src/amd/common/ac_gpu_info.h
index f856a1ae6fdf..2722f8d2206a 100644
--- a/src/amd/common/ac_gpu_info.h
+++ b/src/amd/common/ac_gpu_info.h
@@ -60,6 +60,10 @@ struct radeon_info {
    uint32_t num_cu;           /* only enabled CUs */
    uint32_t max_gpu_freq_mhz; /* also known as the shader clock */
    uint32_t max_gflops;
+   uint32_t sqc_inst_cache_size;
+   uint32_t sqc_scalar_cache_size;
+   uint32_t num_sqc_per_wgp;
+   uint32_t tcp_cache_size;
    uint32_t l1_cache_size;
    uint32_t l2_cache_size;
    uint32_t l3_cache_size_mb;
diff --git a/src/amd/common/ac_rgp.c b/src/amd/common/ac_rgp.c
index ca42f676d94a..7287888d25b4 100644
--- a/src/amd/common/ac_rgp.c
+++ b/src/amd/common/ac_rgp.c
@@ -456,7 +456,7 @@ static void ac_sqtt_fill_asic_info(struct radeon_info *rad_info,
    chunk->vram_bus_width = rad_info->memory_bus_width;
    chunk->vram_size = (uint64_t)rad_info->vram_size_kb * 1024;
    chunk->l2_cache_size = rad_info->l2_cache_size;
-   chunk->l1_cache_size = rad_info->l1_cache_size;
+   chunk->l1_cache_size = rad_info->tcp_cache_size;
    chunk->lds_size = rad_info->lds_size_per_workgroup;
    if (rad_info->gfx_level >= GFX10) {
       /* RGP expects the LDS size in CU mode. */
-- 
GitLab


From 8aa5e950c7f45ff4e36b6b3934501d99305d2db3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 00:00:45 -0500
Subject: [PATCH 39/45] amd/gpu_info: add a workaround for
 SI_FORCE_FAMILY=gfx1100

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/amd/common/ac_gpu_info.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 3fc464925ec7..f13a3098c2e4 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1446,6 +1446,9 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
       info->conformant_trunc_coord =
          info->drm_minor >= 52 &&
          device_info.ids_flags & AMDGPU_IDS_FLAGS_CONFORMANT_TRUNC_COORD;
+   } else {
+      /* This should be non-zero for SI_FORCE_FAMILY not to crash. */
+      info->attribute_ring_size_per_se = 64 * 1024;
    }
 
    set_custom_cu_en_mask(info);
-- 
GitLab


From c19d069b0025516045d888b5869f830d8c0c5dd3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 19 Feb 2023 04:42:01 -0500
Subject: [PATCH 40/45] radeonsi: reorganize si_emit_framebuffer_state for
 better readability

---
 src/gallium/drivers/radeonsi/si_state.c | 106 ++++++++++++++----------
 1 file changed, 63 insertions(+), 43 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index db5ed800c204..2564c2f2f348 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -3192,15 +3192,17 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
    unsigned i, nr_cbufs = state->nr_cbufs;
    struct si_texture *tex = NULL;
    struct si_surface *cb = NULL;
-   unsigned cb_color_info = 0;
+   bool is_msaa_resolve = state->nr_cbufs == 2 &&
+                          state->cbufs[0] && state->cbufs[0]->texture->nr_samples > 1 &&
+                          state->cbufs[1] && state->cbufs[1]->texture->nr_samples <= 1;
+
+   /* CB can't do MSAA resolve on gfx11. */
+   assert(!is_msaa_resolve || sctx->gfx_level < GFX11);
 
    radeon_begin(cs);
 
    /* Colorbuffers. */
    for (i = 0; i < nr_cbufs; i++) {
-      uint64_t cb_color_base, cb_color_fmask, cb_color_cmask, cb_dcc_base;
-      unsigned cb_color_attrib;
-
       if (!(sctx->framebuffer.dirty_cbufs & (1 << i)))
          continue;
 
@@ -3239,47 +3241,35 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
       }
 
       /* Compute mutable surface parameters. */
-      cb_color_base = tex->buffer.gpu_address >> 8;
-      cb_color_fmask = 0;
-      cb_color_cmask = tex->cmask_base_address_reg;
-      cb_dcc_base = 0;
-      cb_color_info = cb->cb_color_info | tex->cb_color_info;
-      cb_color_attrib = cb->cb_color_attrib;
-
-      if (tex->swap_rgb_to_bgr) {
-         /* Swap R and B channels. */
-         static unsigned rgb_to_bgr[4] = {
-            [V_028C70_SWAP_STD] = V_028C70_SWAP_ALT,
-            [V_028C70_SWAP_ALT] = V_028C70_SWAP_STD,
-            [V_028C70_SWAP_STD_REV] = V_028C70_SWAP_ALT_REV,
-            [V_028C70_SWAP_ALT_REV] = V_028C70_SWAP_STD_REV,
-         };
-         unsigned swap = rgb_to_bgr[G_028C70_COMP_SWAP(cb_color_info)];
+      uint64_t cb_color_base = tex->buffer.gpu_address >> 8;
+      uint64_t cb_dcc_base = 0;
+      unsigned cb_color_info = cb->cb_color_info | tex->cb_color_info;
 
-         cb_color_info &= C_028C70_COMP_SWAP;
-         cb_color_info |= S_028C70_COMP_SWAP(swap);
-      }
+      if (sctx->gfx_level < GFX11) {
+         if (tex->swap_rgb_to_bgr) {
+            /* Swap R and B channels. */
+            static unsigned rgb_to_bgr[4] = {
+               [V_028C70_SWAP_STD] = V_028C70_SWAP_ALT,
+               [V_028C70_SWAP_ALT] = V_028C70_SWAP_STD,
+               [V_028C70_SWAP_STD_REV] = V_028C70_SWAP_ALT_REV,
+               [V_028C70_SWAP_ALT_REV] = V_028C70_SWAP_STD_REV,
+            };
+            unsigned swap = rgb_to_bgr[G_028C70_COMP_SWAP(cb_color_info)];
+
+            cb_color_info &= C_028C70_COMP_SWAP;
+            cb_color_info |= S_028C70_COMP_SWAP(swap);
+         }
+
+         if (cb->base.u.tex.level > 0)
+            cb_color_info &= C_028C70_FAST_CLEAR;
 
-      if (sctx->gfx_level < GFX11 && cb->base.u.tex.level > 0)
-         cb_color_info &= C_028C70_FAST_CLEAR;
 
-      if (tex->surface.fmask_offset) {
-         cb_color_fmask = (tex->buffer.gpu_address + tex->surface.fmask_offset) >> 8;
-         cb_color_fmask |= tex->surface.fmask_tile_swizzle;
+         if (vi_dcc_enabled(tex, cb->base.u.tex.level) && (i != 1 || !is_msaa_resolve))
+            cb_color_info |= S_028C70_DCC_ENABLE(1);
       }
 
       /* Set up DCC. */
       if (vi_dcc_enabled(tex, cb->base.u.tex.level)) {
-         bool is_msaa_resolve_dst = state->cbufs[0] && state->cbufs[0]->texture->nr_samples > 1 &&
-                                    state->cbufs[1] == &cb->base &&
-                                    state->cbufs[1]->texture->nr_samples <= 1;
-
-         /* CB can't do MSAA resolve on gfx11. */
-         assert(!is_msaa_resolve_dst || sctx->gfx_level < GFX11);
-
-         if (!is_msaa_resolve_dst && sctx->gfx_level < GFX11)
-            cb_color_info |= S_028C70_DCC_ENABLE(1);
-
          cb_dcc_base = (tex->buffer.gpu_address + tex->surface.meta_offset) >> 8;
 
          unsigned dcc_tile_swizzle = tex->surface.tile_swizzle;
@@ -3309,7 +3299,7 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
          radeon_set_context_reg_seq(R_028C6C_CB_COLOR0_VIEW + i * 0x3C, 4);
          radeon_emit(cb->cb_color_view);                      /* CB_COLOR0_VIEW */
          radeon_emit(cb_color_info);                          /* CB_COLOR0_INFO */
-         radeon_emit(cb_color_attrib);                        /* CB_COLOR0_ATTRIB */
+         radeon_emit(cb->cb_color_attrib);                    /* CB_COLOR0_ATTRIB */
          radeon_emit(cb_fdcc_control);                        /* CB_COLOR0_FDCC_CONTROL */
 
          radeon_set_context_reg(R_028C60_CB_COLOR0_BASE + i * 0x3C, cb_color_base);
@@ -3320,14 +3310,23 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
          radeon_set_context_reg(R_028EE0_CB_COLOR0_ATTRIB3 + i * 4, cb_color_attrib3);
       } else if (sctx->gfx_level >= GFX10) {
          unsigned cb_color_attrib3;
+         uint64_t cb_color_fmask, cb_color_cmask;
 
          /* Set mutable surface parameters. */
          cb_color_base += tex->surface.u.gfx9.surf_offset >> 8;
          cb_color_base |= tex->surface.tile_swizzle;
-         if (!tex->surface.fmask_offset)
+
+         if (tex->surface.fmask_offset) {
+            cb_color_fmask = (tex->buffer.gpu_address + tex->surface.fmask_offset) >> 8;
+            cb_color_fmask |= tex->surface.fmask_tile_swizzle;
+         } else {
             cb_color_fmask = cb_color_base;
+         }
+
          if (cb->base.u.tex.level > 0)
             cb_color_cmask = cb_color_base;
+         else
+            cb_color_cmask = tex->cmask_base_address_reg;
 
          cb_color_attrib3 = cb->cb_color_attrib3 |
                             S_028EE0_COLOR_SW_MODE(tex->surface.u.gfx9.swizzle_mode) |
@@ -3341,7 +3340,7 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
          radeon_emit(0);                         /* hole */
          radeon_emit(cb->cb_color_view);         /* CB_COLOR0_VIEW */
          radeon_emit(cb_color_info);             /* CB_COLOR0_INFO */
-         radeon_emit(cb_color_attrib);           /* CB_COLOR0_ATTRIB */
+         radeon_emit(cb->cb_color_attrib);       /* CB_COLOR0_ATTRIB */
          radeon_emit(cb->cb_dcc_control);        /* CB_COLOR0_DCC_CONTROL */
          radeon_emit(cb_color_cmask);            /* CB_COLOR0_CMASK */
          radeon_emit(0);                         /* hole */
@@ -3364,6 +3363,8 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
             .rb_aligned = 1,
             .pipe_aligned = 1,
          };
+         unsigned cb_color_attrib = cb->cb_color_attrib;
+         uint64_t cb_color_fmask, cb_color_cmask;
 
          if (!tex->is_depth && tex->surface.meta_offset)
             meta = tex->surface.u.gfx9.color.dcc;
@@ -3371,10 +3372,19 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
          /* Set mutable surface parameters. */
          cb_color_base += tex->surface.u.gfx9.surf_offset >> 8;
          cb_color_base |= tex->surface.tile_swizzle;
-         if (!tex->surface.fmask_offset)
+
+         if (tex->surface.fmask_offset) {
+            cb_color_fmask = (tex->buffer.gpu_address + tex->surface.fmask_offset) >> 8;
+            cb_color_fmask |= tex->surface.fmask_tile_swizzle;
+         } else {
             cb_color_fmask = cb_color_base;
+         }
+
          if (cb->base.u.tex.level > 0)
             cb_color_cmask = cb_color_base;
+         else
+            cb_color_cmask = tex->cmask_base_address_reg;
+
          cb_color_attrib |= S_028C74_COLOR_SW_MODE(tex->surface.u.gfx9.swizzle_mode) |
                             S_028C74_FMASK_SW_MODE(tex->surface.u.gfx9.color.fmask_swizzle_mode) |
                             S_028C74_RB_ALIGNED(meta.rb_aligned) |
@@ -3405,16 +3415,26 @@ static void si_emit_framebuffer_state(struct si_context *sctx)
             &tex->surface.u.legacy.level[cb->base.u.tex.level];
          unsigned pitch_tile_max, slice_tile_max, tile_mode_index;
          unsigned cb_color_pitch, cb_color_slice, cb_color_fmask_slice;
+         unsigned cb_color_attrib = cb->cb_color_attrib;
+         uint64_t cb_color_fmask, cb_color_cmask;
 
          cb_color_base += level_info->offset_256B;
          /* Only macrotiled modes can set tile swizzle. */
          if (level_info->mode == RADEON_SURF_MODE_2D)
             cb_color_base |= tex->surface.tile_swizzle;
 
-         if (!tex->surface.fmask_offset)
+         if (tex->surface.fmask_offset) {
+            cb_color_fmask = (tex->buffer.gpu_address + tex->surface.fmask_offset) >> 8;
+            cb_color_fmask |= tex->surface.fmask_tile_swizzle;
+         } else {
             cb_color_fmask = cb_color_base;
+         }
+
          if (cb->base.u.tex.level > 0)
             cb_color_cmask = cb_color_base;
+         else
+            cb_color_cmask = tex->cmask_base_address_reg;
+
          if (cb_dcc_base)
             cb_dcc_base += tex->surface.u.legacy.color.dcc_level[cb->base.u.tex.level].dcc_offset >> 8;
 
-- 
GitLab


From d7bcb00eee8d5dccd21e83f59496af03299e90ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 00:50:24 -0500
Subject: [PATCH 41/45] nir,amd: add and use
 nir_intrinsic_load_esgs_vertex_stride_amd

This will emulate VGT_ESGS_RING_ITEMSIZE, which does the multiplication
for us. It's beneficial to stop setting VGT_ESGS_RING_ITEMSIZE to reduce
context rolls, and also the register will be removed in the future.
---
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c    | 2 ++
 src/amd/vulkan/radv_nir_lower_abi.c             | 4 ++++
 src/compiler/nir/nir_divergence_analysis.c      | 1 +
 src/compiler/nir/nir_intrinsics.py              | 3 +++
 src/gallium/drivers/radeonsi/si_nir_lower_abi.c | 3 +++
 5 files changed, 13 insertions(+)

diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 969448d4da22..e464666498e7 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -269,6 +269,8 @@ gs_per_vertex_input_offset(nir_builder *b,
       ? gs_per_vertex_input_vertex_offset_gfx9(b, st, vertex_src)
       : gs_per_vertex_input_vertex_offset_gfx6(b, st, vertex_src);
 
+   vertex_offset = nir_imul(b, vertex_offset, nir_load_esgs_vertex_stride_amd(b));
+
    unsigned base_stride = st->gfx_level >= GFX9 ? 1 : 64 /* Wave size on GFX6-8 */;
    nir_ssa_def *io_off = ac_nir_calc_io_offset(b, instr, nir_imm_int(b, base_stride * 4u), base_stride, st->map_io);
    nir_ssa_def *off = nir_iadd(b, io_off, vertex_offset);
diff --git a/src/amd/vulkan/radv_nir_lower_abi.c b/src/amd/vulkan/radv_nir_lower_abi.c
index e2ebacedba1f..f3aa5c5354e8 100644
--- a/src/amd/vulkan/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/radv_nir_lower_abi.c
@@ -281,6 +281,10 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
       replacement = nir_imm_int(b, io_num * 16);
       break;
    }
+   case nir_intrinsic_load_esgs_vertex_stride_amd:
+      /* TODO: pass the value of VGT_ESGS_RING_ITEMSIZE here and set the register to 1. */
+      replacement = nir_imm_int(b, 1);
+      break;
    case nir_intrinsic_load_hs_out_patch_data_offset_amd: {
       unsigned out_vertices_per_patch = b->shader->info.tess.tcs_vertices_out;
       unsigned num_tcs_outputs = stage == MESA_SHADER_TESS_CTRL ?
diff --git a/src/compiler/nir/nir_divergence_analysis.c b/src/compiler/nir/nir_divergence_analysis.c
index 6b359e61b663..2ebb03cca252 100644
--- a/src/compiler/nir/nir_divergence_analysis.c
+++ b/src/compiler/nir/nir_divergence_analysis.c
@@ -196,6 +196,7 @@ visit_intrinsic(nir_shader *shader, nir_intrinsic_instr *instr)
    case nir_intrinsic_load_mesh_inline_data_intel:
    case nir_intrinsic_load_ray_num_dss_rt_stacks_intel:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
+   case nir_intrinsic_load_esgs_vertex_stride_amd:
    case nir_intrinsic_load_hs_out_patch_data_offset_amd:
    case nir_intrinsic_load_clip_half_line_width_amd:
    case nir_intrinsic_load_num_vertices_per_primitive_amd:
diff --git a/src/compiler/nir/nir_intrinsics.py b/src/compiler/nir/nir_intrinsics.py
index 25cafc872532..d39fa78d9ff9 100644
--- a/src/compiler/nir/nir_intrinsics.py
+++ b/src/compiler/nir/nir_intrinsics.py
@@ -1507,6 +1507,9 @@ intrinsic("store_shared2_amd", [2, 1], indices=[OFFSET0, OFFSET1, ST64])
 # Vertex stride in LS-HS buffer
 system_value("lshs_vertex_stride_amd", 1)
 
+# Vertex stride in ES-GS buffer
+system_value("esgs_vertex_stride_amd", 1)
+
 # Per patch data offset in HS VRAM output buffer
 system_value("hs_out_patch_data_offset_amd", 1)
 
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index f76c91dc808d..5366e2b9c114 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -179,6 +179,9 @@ static bool lower_abi_instr(nir_builder *b, nir_instr *instr, struct lower_abi_s
       else
          unreachable("no nir_load_lshs_vertex_stride_amd");
       break;
+   case nir_intrinsic_load_esgs_vertex_stride_amd:
+      replacement = nir_imm_int(b, 1);
+      break;
    case nir_intrinsic_load_tcs_num_patches_amd: {
       nir_ssa_def *tmp = ac_nir_unpack_arg(b, &args->ac, args->tcs_offchip_layout, 0, 6);
       replacement = nir_iadd_imm(b, tmp, 1);
-- 
GitLab


From 363f6c236cf2f2288d94c4fa5a0ec94afb344b9f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 20 Feb 2023 01:07:58 -0500
Subject: [PATCH 42/45] radeonsi: emulate VGT_ESGS_RING_ITEMSIZE in the shader

The hardware uses the register to premultiply GS vertex indices
in input VGPRs.

This changes the behavior as follows:
- VGT_ESGS_RING_ITEMSIZE is always 1, set in the preamble.
- The value is passed to the shader via current_gs_state (vs_state_bits).
- The shader does the multiplication.

The reason is that VGT_ESGS_RING_ITEMSIZE will be removed in the future.
---
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  1 -
 .../drivers/radeonsi/si_nir_lower_abi.c       |  4 ++-
 src/gallium/drivers/radeonsi/si_shader.h      |  5 ++--
 src/gallium/drivers/radeonsi/si_shader_info.c |  2 --
 src/gallium/drivers/radeonsi/si_state.c       |  1 +
 src/gallium/drivers/radeonsi/si_state.h       |  2 --
 .../drivers/radeonsi/si_state_shaders.cpp     | 27 +++++++++----------
 7 files changed, 20 insertions(+), 22 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index 0a48aee6cef7..e9d5c3159715 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -270,7 +270,6 @@ void si_set_tracked_regs_to_clear_state(struct si_context *ctx)
    ctx->tracked_regs.reg_value[SI_TRACKED_PA_SU_VTX_CNTL] = 0x00000005;
    ctx->tracked_regs.reg_value[SI_TRACKED_PA_SC_CLIPRECT_RULE] = 0xffff;
    ctx->tracked_regs.reg_value[SI_TRACKED_PA_SC_LINE_STIPPLE] = 0;
-   ctx->tracked_regs.reg_value[SI_TRACKED_VGT_ESGS_RING_ITEMSIZE]  = 0x00000000;
    ctx->tracked_regs.reg_value[SI_TRACKED_VGT_GSVS_RING_OFFSET_1]  = 0x00000000;
    ctx->tracked_regs.reg_value[SI_TRACKED_VGT_GSVS_RING_OFFSET_2]  = 0x00000000;
    ctx->tracked_regs.reg_value[SI_TRACKED_VGT_GSVS_RING_OFFSET_3]  = 0x00000000;
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 5366e2b9c114..60a6e8bf28a0 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -180,7 +180,9 @@ static bool lower_abi_instr(nir_builder *b, nir_instr *instr, struct lower_abi_s
          unreachable("no nir_load_lshs_vertex_stride_amd");
       break;
    case nir_intrinsic_load_esgs_vertex_stride_amd:
-      replacement = nir_imm_int(b, 1);
+      replacement = sel->screen->info.gfx_level >= GFX9 && shader->is_monolithic ?
+         nir_imm_int(b, key->ge.part.gs.es->info.esgs_vertex_stride / 4) :
+         GET_FIELD_NIR(GS_STATE_ESGS_VERTEX_STRIDE);
       break;
    case nir_intrinsic_load_tcs_num_patches_amd: {
       nir_ssa_def *tmp = ac_nir_unpack_arg(b, &args->ac, args->tcs_offchip_layout, 0, 6);
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 793d405b9eb4..f4c2cfd78cd2 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -266,6 +266,8 @@ enum
  * in the shader via vs_state_bits in legacy GS, the GS copy shader, and any NGG shader.
  */
 /* bit gap */
+#define GS_STATE_ESGS_VERTEX_STRIDE__SHIFT      10
+#define GS_STATE_ESGS_VERTEX_STRIDE__MASK       0xff /* max 32 * 4 + 1 */
 /* Small prim filter precision = num_samples / quant_mode, which can only be equal to 1/2^n
  * where n is between 4 and 12. Knowing that, we only need to store 4 bits of the FP32 exponent.
  * Set it like this: value = (fui(num_samples / quant_mode) >> 23) & 0xf;
@@ -898,7 +900,6 @@ struct si_shader {
          unsigned vgt_gs_instance_cnt;
          unsigned vgt_gs_onchip_cntl;
          unsigned vgt_gs_max_prims_per_subgroup;
-         unsigned vgt_esgs_ring_itemsize;
          unsigned spi_shader_pgm_rsrc3_gs;
          unsigned spi_shader_pgm_rsrc4_gs;
       } gs;
@@ -917,7 +918,7 @@ struct si_shader {
          unsigned vgt_primitiveid_en;
          unsigned vgt_gs_onchip_cntl;
          unsigned vgt_gs_instance_cnt;
-         unsigned vgt_esgs_ring_itemsize;
+         unsigned esgs_vertex_stride;
          unsigned spi_vs_out_config;
          unsigned spi_shader_idx_format;
          unsigned spi_shader_pos_format;
diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index 77cd7d57bf5d..28e1721d0abe 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -791,8 +791,6 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
       if (sscreen->info.gfx_level >= GFX9)
          info->esgs_vertex_stride += 4;
 
-      assert(((info->esgs_vertex_stride / 4) & C_028AAC_ITEMSIZE) == 0);
-
       info->tcs_vgpr_only_inputs = ~info->base.tess.tcs_cross_invocation_inputs_read &
                                    ~info->base.inputs_read_indirectly &
                                    info->base.inputs_read;
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 2564c2f2f348..48b5d127b053 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -5627,6 +5627,7 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
    si_pm4_set_reg(pm4, R_028244_PA_SC_GENERIC_SCISSOR_BR,
                   S_028244_BR_X(16384) | S_028244_BR_Y(16384));
 
+   si_pm4_set_reg(pm4, R_028AAC_VGT_ESGS_RING_ITEMSIZE, 1);
    si_pm4_set_reg(pm4, R_028A18_VGT_HOS_MAX_TESS_LEVEL, fui(64));
    if (!has_clear_state)
       si_pm4_set_reg(pm4, R_028A1C_VGT_HOS_MIN_TESS_LEVEL, fui(0));
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index c96b2eb96e58..36bea1510c38 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -291,8 +291,6 @@ enum si_tracked_reg
 
    SI_TRACKED_PA_SC_LINE_STIPPLE,
 
-   SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-
    SI_TRACKED_VGT_GSVS_RING_OFFSET_1, /* 3 consecutive registers */
    SI_TRACKED_VGT_GSVS_RING_OFFSET_2,
    SI_TRACKED_VGT_GSVS_RING_OFFSET_3,
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 9d5b3a38e1bb..26bd9f2c926a 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -768,11 +768,10 @@ static void si_emit_shader_es(struct si_context *sctx)
    if (!shader)
       return;
 
-   radeon_begin(&sctx->gfx_cs);
-   radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
-                              SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                              shader->selector->info.esgs_vertex_stride / 4);
+   SET_FIELD(sctx->current_gs_state, GS_STATE_ESGS_VERTEX_STRIDE,
+             shader->selector->info.esgs_vertex_stride / 4);
 
+   radeon_begin(&sctx->gfx_cs);
    if (shader->selector->stage == MESA_SHADER_TESS_EVAL)
       radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
                                  shader->vgt_tf_param);
@@ -930,6 +929,11 @@ static void si_emit_shader_gs(struct si_context *sctx)
    if (!shader)
       return;
 
+   if (sctx->gfx_level >= GFX9) {
+      SET_FIELD(sctx->current_gs_state, GS_STATE_ESGS_VERTEX_STRIDE,
+                shader->key.ge.part.gs.es->info.esgs_vertex_stride / 4);
+   }
+
    radeon_begin(&sctx->gfx_cs);
 
    /* R_028A60_VGT_GSVS_RING_OFFSET_1, R_028A64_VGT_GSVS_RING_OFFSET_2
@@ -967,10 +971,6 @@ static void si_emit_shader_gs(struct si_context *sctx)
       radeon_opt_set_context_reg(sctx, R_028A94_VGT_GS_MAX_PRIMS_PER_SUBGROUP,
                                  SI_TRACKED_VGT_GS_MAX_PRIMS_PER_SUBGROUP,
                                  shader->gs.vgt_gs_max_prims_per_subgroup);
-      /* R_028AAC_VGT_ESGS_RING_ITEMSIZE */
-      radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
-                                 SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                                 shader->gs.vgt_esgs_ring_itemsize);
 
       if (shader->key.ge.part.gs.es->stage == MESA_SHADER_TESS_EVAL)
          radeon_opt_set_context_reg(sctx, R_028B6C_VGT_TF_PARAM, SI_TRACKED_VGT_TF_PARAM,
@@ -1136,7 +1136,6 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
          S_028A44_GS_INST_PRIMS_IN_SUBGRP(shader->gs_info.gs_inst_prims_in_subgroup);
       shader->gs.vgt_gs_max_prims_per_subgroup =
          S_028A94_MAX_PRIMS_PER_SUBGROUP(shader->gs_info.max_prims_per_subgroup);
-      shader->gs.vgt_esgs_ring_itemsize = shader->key.ge.part.gs.es->info.esgs_vertex_stride / 4;
 
       if (es_stage == MESA_SHADER_TESS_EVAL)
          si_set_tesseval_regs(sscreen, shader->key.ge.part.gs.es, shader);
@@ -1185,6 +1184,9 @@ bool gfx10_is_ngg_passthrough(struct si_shader *shader)
 /* Common tail code for NGG primitive shaders. */
 static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader *shader)
 {
+   SET_FIELD(sctx->current_gs_state, GS_STATE_ESGS_VERTEX_STRIDE,
+             shader->ngg.esgs_vertex_stride);
+
    radeon_begin(&sctx->gfx_cs);
    radeon_opt_set_context_reg(sctx, R_0287FC_GE_MAX_OUTPUT_PER_SUBGROUP,
                               SI_TRACKED_GE_MAX_OUTPUT_PER_SUBGROUP,
@@ -1199,9 +1201,6 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
    }
    radeon_opt_set_context_reg(sctx, R_028B90_VGT_GS_INSTANCE_CNT, SI_TRACKED_VGT_GS_INSTANCE_CNT,
                               shader->ngg.vgt_gs_instance_cnt);
-   radeon_opt_set_context_reg(sctx, R_028AAC_VGT_ESGS_RING_ITEMSIZE,
-                              SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,
-                              shader->ngg.vgt_esgs_ring_itemsize);
    radeon_opt_set_context_reg(sctx, R_0286C4_SPI_VS_OUT_CONFIG, SI_TRACKED_SPI_VS_OUT_CONFIG,
                               shader->ngg.spi_vs_out_config);
    radeon_opt_set_context_reg2(
@@ -1472,10 +1471,10 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                                         gs_sel->info.writes_primid);
 
    if (gs_stage == MESA_SHADER_GEOMETRY) {
-      shader->ngg.vgt_esgs_ring_itemsize = es_sel->info.esgs_vertex_stride / 4;
+      shader->ngg.esgs_vertex_stride = es_sel->info.esgs_vertex_stride / 4;
       shader->ngg.vgt_gs_max_vert_out = gs_sel->info.base.gs.vertices_out;
    } else {
-      shader->ngg.vgt_esgs_ring_itemsize = 1;
+      shader->ngg.esgs_vertex_stride = 1;
    }
 
    if (es_stage == MESA_SHADER_TESS_EVAL)
-- 
GitLab


From e20637b8e681bd32dcd48d8bb208b6803b4b4ac4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 21 Feb 2023 11:33:13 -0500
Subject: [PATCH 43/45] radeonsi: don't merge SET_* packets that have a
 different index in si_pm4_state

Oops.
---
 src/gallium/drivers/radeonsi/si_pm4.c | 3 ++-
 src/gallium/drivers/radeonsi/si_pm4.h | 1 +
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_pm4.c b/src/gallium/drivers/radeonsi/si_pm4.c
index 280125b65118..c8320c2d817f 100644
--- a/src/gallium/drivers/radeonsi/si_pm4.c
+++ b/src/gallium/drivers/radeonsi/si_pm4.c
@@ -63,13 +63,14 @@ static void si_pm4_set_reg_custom(struct si_pm4_state *state, unsigned reg, uint
 
    assert(state->ndw + 2 <= state->max_dw);
 
-   if (opcode != state->last_opcode || reg != (state->last_reg + 1)) {
+   if (opcode != state->last_opcode || reg != (state->last_reg + 1) || idx != state->last_idx) {
       si_pm4_cmd_begin(state, opcode);
       state->pm4[state->ndw++] = reg | (idx << 28);
    }
 
    assert(reg <= UINT16_MAX);
    state->last_reg = reg;
+   state->last_idx = idx;
    state->pm4[state->ndw++] = val;
    si_pm4_cmd_end(state, false);
 }
diff --git a/src/gallium/drivers/radeonsi/si_pm4.h b/src/gallium/drivers/radeonsi/si_pm4.h
index 486b627d540a..6af9a76d7708 100644
--- a/src/gallium/drivers/radeonsi/si_pm4.h
+++ b/src/gallium/drivers/radeonsi/si_pm4.h
@@ -47,6 +47,7 @@ struct si_pm4_state {
    uint16_t last_pm4;
    uint16_t ndw;        /* number of dwords in pm4 */
    uint8_t last_opcode;
+   uint8_t last_idx;
 
    /* For shader states only */
    bool is_shader;
-- 
GitLab


From 1421dbc7d9cc5403d87fa522d6d444a926aeef3f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 21 Feb 2023 12:22:38 -0500
Subject: [PATCH 44/45] amd: massively simplify how info->spi_cu_en is applied

Instead of having ac_set_reg_cu_en that sets the register, replace it with
ac_apply_cu_en that only returns the modified register value,
which enables a large simplification in both drivers because a lot of code
becomes duplicated after it's switched to ac_apply_cu_en.

RADV also didn't apply it to a few registers. Fixed.

This removes 82 lines of code in total.
---
 src/amd/common/ac_shader_util.c               |  11 +-
 src/amd/common/ac_shader_util.h               |   5 +-
 src/amd/vulkan/radv_cs.h                      |  11 --
 src/amd/vulkan/radv_pipeline.c                |  73 ++++------
 src/amd/vulkan/si_cmd_buffer.c                |  52 ++++---
 src/gallium/drivers/radeonsi/si_build_pm4.h   |  30 +---
 src/gallium/drivers/radeonsi/si_pm4.c         |   6 +-
 src/gallium/drivers/radeonsi/si_pm4.h         |   6 +-
 src/gallium/drivers/radeonsi/si_state.c       |  45 +++---
 .../drivers/radeonsi/si_state_shaders.cpp     | 133 +++++++-----------
 10 files changed, 145 insertions(+), 227 deletions(-)

diff --git a/src/amd/common/ac_shader_util.c b/src/amd/common/ac_shader_util.c
index 9ffb90c1408e..340d51f433c1 100644
--- a/src/amd/common/ac_shader_util.c
+++ b/src/amd/common/ac_shader_util.c
@@ -958,9 +958,8 @@ unsigned ac_compute_ngg_workgroup_size(unsigned es_verts, unsigned gs_inst_prims
    return CLAMP(workgroup_size, 1, 256);
 }
 
-void ac_set_reg_cu_en(void *cs, unsigned reg_offset, uint32_t value, uint32_t clear_mask,
-                      unsigned value_shift, const struct radeon_info *info,
-                      void set_sh_reg(void*, unsigned, uint32_t))
+uint32_t ac_apply_cu_en(uint32_t value, uint32_t clear_mask, unsigned value_shift,
+                        const struct radeon_info *info)
 {
    /* Register field position and mask. */
    uint32_t cu_en_mask = ~clear_mask;
@@ -970,10 +969,8 @@ void ac_set_reg_cu_en(void *cs, unsigned reg_offset, uint32_t value, uint32_t cl
 
    /* AND the field by spi_cu_en. */
    uint32_t spi_cu_en = info->spi_cu_en >> value_shift;
-   uint32_t new_value = (value & ~cu_en_mask) |
-                        (((cu_en & spi_cu_en) << cu_en_shift) & cu_en_mask);
-
-   set_sh_reg(cs, reg_offset, new_value);
+   return (value & ~cu_en_mask) |
+          (((cu_en & spi_cu_en) << cu_en_shift) & cu_en_mask);
 }
 
 /* Return the register value and tune bytes_per_wave to increase scratch performance. */
diff --git a/src/amd/common/ac_shader_util.h b/src/amd/common/ac_shader_util.h
index 3b28ae24e17e..1c0d2fda2f3a 100644
--- a/src/amd/common/ac_shader_util.h
+++ b/src/amd/common/ac_shader_util.h
@@ -166,9 +166,8 @@ unsigned ac_compute_esgs_workgroup_size(enum amd_gfx_level gfx_level, unsigned w
 unsigned ac_compute_ngg_workgroup_size(unsigned es_verts, unsigned gs_inst_prims,
                                        unsigned max_vtx_out, unsigned prim_amp_factor);
 
-void ac_set_reg_cu_en(void *cs, unsigned reg_offset, uint32_t value, uint32_t clear_mask,
-                      unsigned value_shift, const struct radeon_info *info,
-                      void set_sh_reg(void*, unsigned, uint32_t));
+uint32_t ac_apply_cu_en(uint32_t value, uint32_t clear_mask, unsigned value_shift,
+                        const struct radeon_info *info);
 
 void ac_get_scratch_tmpring_size(const struct radeon_info *info,
                                  unsigned bytes_per_wave, unsigned *max_seen_bytes_per_wave,
diff --git a/src/amd/vulkan/radv_cs.h b/src/amd/vulkan/radv_cs.h
index ac3d1075783e..351d8e2e026a 100644
--- a/src/amd/vulkan/radv_cs.h
+++ b/src/amd/vulkan/radv_cs.h
@@ -117,17 +117,6 @@ radeon_set_sh_reg_idx(const struct radv_physical_device *pdevice, struct radeon_
    radeon_emit(cs, value);
 }
 
-static inline void
-gfx10_set_sh_reg_idx3(struct radeon_cmdbuf *cs, unsigned reg, unsigned value)
-{
-   assert(reg >= SI_SH_REG_OFFSET && reg < SI_SH_REG_END);
-   assert(cs->cdw + 3 <= cs->max_dw);
-
-   radeon_emit(cs, PKT3(PKT3_SET_SH_REG_INDEX, 1, 0));
-   radeon_emit(cs, (reg - SI_SH_REG_OFFSET) >> 2 | (3 << 28));
-   radeon_emit(cs, value);
-}
-
 static inline void
 radeon_set_uconfig_reg_seq(struct radeon_cmdbuf *cs, unsigned reg, unsigned num)
 {
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 45d5d3522d84..39b60b727c4a 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3849,15 +3849,10 @@ radv_pipeline_emit_hw_vs(struct radeon_cmdbuf *ctx_cs, struct radeon_cmdbuf *cs,
                          &late_alloc_wave64, &cu_mask);
 
    if (pdevice->rad_info.gfx_level >= GFX7) {
-      if (pdevice->rad_info.gfx_level >= GFX10) {
-         ac_set_reg_cu_en(cs, R_00B118_SPI_SHADER_PGM_RSRC3_VS,
-                          S_00B118_CU_EN(cu_mask) | S_00B118_WAVE_LIMIT(0x3F),
-                          C_00B118_CU_EN, 0, &pdevice->rad_info,
-                          (void*)gfx10_set_sh_reg_idx3);
-      } else {
-         radeon_set_sh_reg_idx(pdevice, cs, R_00B118_SPI_SHADER_PGM_RSRC3_VS, 3,
-                               S_00B118_CU_EN(cu_mask) | S_00B118_WAVE_LIMIT(0x3F));
-      }
+      radeon_set_sh_reg_idx(pdevice, cs, R_00B118_SPI_SHADER_PGM_RSRC3_VS, 3,
+                            ac_apply_cu_en(S_00B118_CU_EN(cu_mask) |
+                                           S_00B118_WAVE_LIMIT(0x3F),
+                                           C_00B118_CU_EN, 0, &pdevice->rad_info));
       radeon_set_sh_reg(cs, R_00B11C_SPI_SHADER_LATE_ALLOC_VS, S_00B11C_LIMIT(late_alloc_wave64));
    }
    if (pdevice->rad_info.gfx_level >= GFX10) {
@@ -4026,28 +4021,21 @@ radv_pipeline_emit_hw_ngg(struct radeon_cmdbuf *ctx_cs, struct radeon_cmdbuf *cs
    ac_compute_late_alloc(&pdevice->rad_info, true, shader->info.has_ngg_culling,
                          shader->config.scratch_bytes_per_wave > 0, &late_alloc_wave64, &cu_mask);
 
+   radeon_set_sh_reg_idx(pdevice, cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS, 3,
+                         ac_apply_cu_en(S_00B21C_CU_EN(cu_mask) |
+                                        S_00B21C_WAVE_LIMIT(0x3F),
+                                        C_00B21C_CU_EN, 0, &pdevice->rad_info));
+
    if (pdevice->rad_info.gfx_level >= GFX11) {
-      /* TODO: figure out how S_00B204_CU_EN_GFX11 interacts with ac_set_reg_cu_en */
-      gfx10_set_sh_reg_idx3(cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                            S_00B21C_CU_EN(cu_mask) | S_00B21C_WAVE_LIMIT(0x3F));
-      gfx10_set_sh_reg_idx3(
-         cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-         S_00B204_CU_EN_GFX11(0x1) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64));
-   } else if (pdevice->rad_info.gfx_level >= GFX10) {
-      ac_set_reg_cu_en(cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                       S_00B21C_CU_EN(cu_mask) | S_00B21C_WAVE_LIMIT(0x3F),
-                       C_00B21C_CU_EN, 0, &pdevice->rad_info, (void*)gfx10_set_sh_reg_idx3);
-      ac_set_reg_cu_en(cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                       S_00B204_CU_EN_GFX10(0xffff) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64),
-                       C_00B204_CU_EN_GFX10, 16, &pdevice->rad_info,
-                       (void*)gfx10_set_sh_reg_idx3);
+      radeon_set_sh_reg_idx(pdevice, cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS, 3,
+                            ac_apply_cu_en(S_00B204_CU_EN_GFX11(0x1) |
+                                           S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64),
+                                           C_00B204_CU_EN_GFX11, 16, &pdevice->rad_info));
    } else {
-      radeon_set_sh_reg_idx(
-         pdevice, cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS, 3,
-         S_00B21C_CU_EN(cu_mask) | S_00B21C_WAVE_LIMIT(0x3F));
-      radeon_set_sh_reg_idx(
-         pdevice, cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS, 3,
-         S_00B204_CU_EN_GFX10(0xffff) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64));
+      radeon_set_sh_reg_idx(pdevice, cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS, 3,
+                            ac_apply_cu_en(S_00B204_CU_EN_GFX10(0xffff) |
+                                           S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64),
+                                           C_00B204_CU_EN_GFX10, 16, &pdevice->rad_info));
    }
 
    uint32_t oversub_pc_lines = late_alloc_wave64 ? pdevice->rad_info.pc_lines / 4 : 0;
@@ -4207,25 +4195,16 @@ radv_pipeline_emit_hw_gs(struct radeon_cmdbuf *ctx_cs, struct radeon_cmdbuf *cs,
       radeon_emit(cs, gs->config.rsrc2);
    }
 
-   if (pdevice->rad_info.gfx_level >= GFX10) {
-      ac_set_reg_cu_en(cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                       S_00B21C_CU_EN(0xffff) | S_00B21C_WAVE_LIMIT(0x3F),
-                       C_00B21C_CU_EN, 0, &pdevice->rad_info,
-                       (void*)gfx10_set_sh_reg_idx3);
-      ac_set_reg_cu_en(cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                       S_00B204_CU_EN_GFX10(0xffff) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0),
-                       C_00B204_CU_EN_GFX10, 16, &pdevice->rad_info,
-                       (void*)gfx10_set_sh_reg_idx3);
-   } else if (pdevice->rad_info.gfx_level >= GFX7) {
-      radeon_set_sh_reg_idx(
-         pdevice, cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS, 3,
-         S_00B21C_CU_EN(0xffff) | S_00B21C_WAVE_LIMIT(0x3F));
+   radeon_set_sh_reg_idx(pdevice, cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS, 3,
+                         ac_apply_cu_en(S_00B21C_CU_EN(0xffff) |
+                                        S_00B21C_WAVE_LIMIT(0x3F),
+                                        C_00B21C_CU_EN, 0, &pdevice->rad_info));
 
-      if (pdevice->rad_info.gfx_level >= GFX10) {
-         radeon_set_sh_reg_idx(
-            pdevice, cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS, 3,
-            S_00B204_CU_EN_GFX10(0xffff) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0));
-      }
+   if (pdevice->rad_info.gfx_level >= GFX10) {
+      radeon_set_sh_reg_idx(pdevice, cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS, 3,
+                            ac_apply_cu_en(S_00B204_CU_EN_GFX10(0xffff) |
+                                           S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0),
+                                           C_00B204_CU_EN_GFX10, 16, &pdevice->rad_info));
    }
 
    radv_pipeline_emit_hw_vs(ctx_cs, cs, pipeline, pipeline->base.gs_copy_shader);
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 19486f6e0fb7..4c7c4bc1c12f 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -353,34 +353,35 @@ si_emit_graphics(struct radv_device *device, struct radeon_cmdbuf *cs)
       if (physical_device->rad_info.gfx_level >= GFX10 &&
           physical_device->rad_info.gfx_level < GFX11) {
          /* Logical CUs 16 - 31 */
-         ac_set_reg_cu_en(cs, R_00B104_SPI_SHADER_PGM_RSRC4_VS, S_00B104_CU_EN(0xffff),
-                          C_00B104_CU_EN, 16, &physical_device->rad_info,
-                          (void*)gfx10_set_sh_reg_idx3);
+         radeon_set_sh_reg_idx(physical_device, cs, R_00B104_SPI_SHADER_PGM_RSRC4_VS, 3,
+                               ac_apply_cu_en(S_00B104_CU_EN(0xffff),
+                                              C_00B104_CU_EN, 16, &physical_device->rad_info));
       }
 
       if (physical_device->rad_info.gfx_level >= GFX10) {
-         ac_set_reg_cu_en(cs, R_00B404_SPI_SHADER_PGM_RSRC4_HS, S_00B404_CU_EN(0xffff),
-                          C_00B404_CU_EN, 16, &physical_device->rad_info,
-                          (void*)gfx10_set_sh_reg_idx3);
-         ac_set_reg_cu_en(cs, R_00B004_SPI_SHADER_PGM_RSRC4_PS, S_00B004_CU_EN(cu_mask_ps >> 16),
-                          C_00B004_CU_EN, 16, &physical_device->rad_info,
-                          (void*)gfx10_set_sh_reg_idx3);
+         radeon_set_sh_reg_idx(physical_device, cs, R_00B404_SPI_SHADER_PGM_RSRC4_HS, 3,
+                               ac_apply_cu_en(S_00B404_CU_EN(0xffff),
+                                              C_00B404_CU_EN, 16, &physical_device->rad_info));
+         radeon_set_sh_reg_idx(physical_device, cs, R_00B004_SPI_SHADER_PGM_RSRC4_PS, 3,
+                               ac_apply_cu_en(S_00B004_CU_EN(cu_mask_ps >> 16),
+                                              C_00B004_CU_EN, 16, &physical_device->rad_info));
       }
 
-      if (physical_device->rad_info.gfx_level >= GFX10) {
-         ac_set_reg_cu_en(cs, R_00B41C_SPI_SHADER_PGM_RSRC3_HS,
-                          S_00B41C_CU_EN(0xffff) | S_00B41C_WAVE_LIMIT(0x3F),
-                          C_00B41C_CU_EN, 0, &physical_device->rad_info,
-                          (void*)gfx10_set_sh_reg_idx3);
-      } else if (physical_device->rad_info.gfx_level == GFX9) {
+      if (physical_device->rad_info.gfx_level >= GFX9) {
          radeon_set_sh_reg_idx(physical_device, cs, R_00B41C_SPI_SHADER_PGM_RSRC3_HS, 3,
-                               S_00B41C_CU_EN(0xffff) | S_00B41C_WAVE_LIMIT(0x3F));
+                               ac_apply_cu_en(S_00B41C_CU_EN(0xffff) |
+                                              S_00B41C_WAVE_LIMIT(0x3F),
+                                              C_00B41C_CU_EN, 0, &physical_device->rad_info));
       } else {
          radeon_set_sh_reg(cs, R_00B51C_SPI_SHADER_PGM_RSRC3_LS,
-                           S_00B51C_CU_EN(0xffff) | S_00B51C_WAVE_LIMIT(0x3F));
+                           ac_apply_cu_en(S_00B51C_CU_EN(0xffff) |
+                                          S_00B51C_WAVE_LIMIT(0x3F),
+                                          C_00B51C_CU_EN, 0, &physical_device->rad_info));
          radeon_set_sh_reg(cs, R_00B41C_SPI_SHADER_PGM_RSRC3_HS, S_00B41C_WAVE_LIMIT(0x3F));
          radeon_set_sh_reg(cs, R_00B31C_SPI_SHADER_PGM_RSRC3_ES,
-                           S_00B31C_CU_EN(0xffff) | S_00B31C_WAVE_LIMIT(0x3F));
+                           ac_apply_cu_en(S_00B31C_CU_EN(0xffff) |
+                                          S_00B31C_WAVE_LIMIT(0x3F),
+                                          C_00B31C_CU_EN, 0, &physical_device->rad_info));
          /* If this is 0, Bonaire can hang even if GS isn't being used.
           * Other chips are unaffected. These are suboptimal values,
           * but we don't use on-chip GS.
@@ -389,16 +390,11 @@ si_emit_graphics(struct radv_device *device, struct radeon_cmdbuf *cs)
                                 S_028A44_ES_VERTS_PER_SUBGRP(64) | S_028A44_GS_PRIMS_PER_SUBGRP(4));
       }
 
-      if (physical_device->rad_info.gfx_level >= GFX10) {
-         ac_set_reg_cu_en(cs, R_00B01C_SPI_SHADER_PGM_RSRC3_PS,
-                          S_00B01C_CU_EN(cu_mask_ps) | S_00B01C_WAVE_LIMIT(0x3F) |
-                          S_00B01C_LDS_GROUP_SIZE(physical_device->rad_info.gfx_level >= GFX11),
-                          C_00B01C_CU_EN, 0, &physical_device->rad_info,
-                          (void*)gfx10_set_sh_reg_idx3);
-      } else {
-         radeon_set_sh_reg_idx(physical_device, cs, R_00B01C_SPI_SHADER_PGM_RSRC3_PS, 3,
-                               S_00B01C_CU_EN(cu_mask_ps) | S_00B01C_WAVE_LIMIT(0x3F));
-      }
+      radeon_set_sh_reg_idx(physical_device, cs, R_00B01C_SPI_SHADER_PGM_RSRC3_PS, 3,
+                            ac_apply_cu_en(S_00B01C_CU_EN(cu_mask_ps) |
+                                           S_00B01C_WAVE_LIMIT(0x3F) |
+                                           S_00B01C_LDS_GROUP_SIZE(physical_device->rad_info.gfx_level >= GFX11),
+                                           C_00B01C_CU_EN, 0, &physical_device->rad_info));
    }
 
    if (physical_device->rad_info.gfx_level >= GFX10) {
diff --git a/src/gallium/drivers/radeonsi/si_build_pm4.h b/src/gallium/drivers/radeonsi/si_build_pm4.h
index 35782704917e..eb96eff08425 100644
--- a/src/gallium/drivers/radeonsi/si_build_pm4.h
+++ b/src/gallium/drivers/radeonsi/si_build_pm4.h
@@ -125,11 +125,11 @@
    radeon_emit(((reg) - SI_SH_REG_OFFSET) >> 2); \
 } while (0)
 
-#define radeon_set_sh_reg_idx3_seq(reg, num) do { \
+#define radeon_set_sh_reg_idx3_seq(sctx, reg, num) do { \
    SI_CHECK_SHADOWED_REGS(reg, num); \
    assert((reg) >= SI_SH_REG_OFFSET && (reg) < SI_SH_REG_END); \
    radeon_emit(PKT3(PKT3_SET_SH_REG_INDEX, num, 0)); \
-   radeon_emit((((reg) - SI_SH_REG_OFFSET) >> 2) | (3 << 28)); \
+   radeon_emit((((reg) - SI_SH_REG_OFFSET) >> 2) | ((sctx)->gfx_level >= GFX10 ? 3 << 28 : 0)); \
 } while (0)
 
 #define radeon_set_sh_reg(reg, value) do { \
@@ -137,8 +137,8 @@
    radeon_emit(value); \
 } while (0)
 
-#define radeon_set_sh_reg_idx3(reg, value) do { \
-   radeon_set_sh_reg_idx3_seq(reg, 1); \
+#define radeon_set_sh_reg_idx3(sctx, reg, value) do { \
+   radeon_set_sh_reg_idx3_seq(sctx, reg, 1); \
    radeon_emit(value); \
 } while (0)
 
@@ -297,10 +297,7 @@
    unsigned __value = val; \
    if (((sctx->tracked_regs.reg_saved >> (reg)) & 0x1) != 0x1 || \
        sctx->tracked_regs.reg_value[reg] != __value) { \
-      if (sctx->gfx_level >= GFX10) \
-         radeon_set_sh_reg_idx3(offset, __value); \
-      else \
-         radeon_set_sh_reg(offset, __value); \
+      radeon_set_sh_reg_idx3(sctx, offset, __value); \
       sctx->tracked_regs.reg_saved |= BITFIELD64_BIT(reg); \
       sctx->tracked_regs.reg_value[reg] = __value; \
    } \
@@ -338,23 +335,6 @@
    radeon_emit_32bit_pointer(sctx->screen, (desc)->gpu_address); \
 } while (0)
 
-/* Wrappers that are only used when they are passed as function pointers. */
-static inline void radeon_set_sh_reg_func(struct radeon_cmdbuf *cs, unsigned reg_offset,
-                                          uint32_t value)
-{
-   radeon_begin(cs);
-   radeon_set_sh_reg(reg_offset, value);
-   radeon_end();
-}
-
-static inline void radeon_set_sh_reg_idx3_func(struct radeon_cmdbuf *cs, unsigned reg_offset,
-                                               uint32_t value)
-{
-   radeon_begin(cs);
-   radeon_set_sh_reg_idx3(reg_offset, value);
-   radeon_end();
-}
-
 /* This should be evaluated at compile time if all parameters are constants. */
 static ALWAYS_INLINE unsigned
 si_get_user_data_base(enum amd_gfx_level gfx_level, enum si_has_tess has_tess,
diff --git a/src/gallium/drivers/radeonsi/si_pm4.c b/src/gallium/drivers/radeonsi/si_pm4.c
index c8320c2d817f..635d4aa6b342 100644
--- a/src/gallium/drivers/radeonsi/si_pm4.c
+++ b/src/gallium/drivers/radeonsi/si_pm4.c
@@ -105,11 +105,13 @@ void si_pm4_set_reg(struct si_pm4_state *state, unsigned reg, uint32_t val)
    si_pm4_set_reg_custom(state, reg, val, opcode, 0);
 }
 
-void si_pm4_set_reg_idx3(struct si_pm4_state *state, unsigned reg, uint32_t val)
+void si_pm4_set_reg_idx3(struct si_screen *sscreen, struct si_pm4_state *state,
+                         unsigned reg, uint32_t val)
 {
    SI_CHECK_SHADOWED_REGS(reg, 1);
 
-   si_pm4_set_reg_custom(state, reg - SI_SH_REG_OFFSET, val, PKT3_SET_SH_REG_INDEX, 3);
+   si_pm4_set_reg_custom(state, reg - SI_SH_REG_OFFSET, val, PKT3_SET_SH_REG_INDEX,
+                         sscreen->info.gfx_level >= GFX10 ? 3 : 0);
 }
 
 void si_pm4_clear_state(struct si_pm4_state *state)
diff --git a/src/gallium/drivers/radeonsi/si_pm4.h b/src/gallium/drivers/radeonsi/si_pm4.h
index 6af9a76d7708..ac73a32fe2e1 100644
--- a/src/gallium/drivers/radeonsi/si_pm4.h
+++ b/src/gallium/drivers/radeonsi/si_pm4.h
@@ -31,7 +31,8 @@
 extern "C" {
 #endif
 
-// forward defines
+/* forward definitions */
+struct si_screen;
 struct si_context;
 
 /* State atoms are callbacks which write a sequence of packets into a GPU
@@ -65,7 +66,8 @@ struct si_pm4_state {
 
 void si_pm4_cmd_add(struct si_pm4_state *state, uint32_t dw);
 void si_pm4_set_reg(struct si_pm4_state *state, unsigned reg, uint32_t val);
-void si_pm4_set_reg_idx3(struct si_pm4_state *state, unsigned reg, uint32_t val);
+void si_pm4_set_reg_idx3(struct si_screen *sscreen, struct si_pm4_state *state,
+                         unsigned reg, uint32_t val);
 
 void si_pm4_clear_state(struct si_pm4_state *state);
 void si_pm4_free_state(struct si_context *sctx, struct si_pm4_state *state, unsigned idx);
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 48b5d127b053..22066ab358b5 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -5692,12 +5692,11 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
       cu_mask_ps = gfx103_get_cu_mask_ps(sscreen);
 
    if (sctx->gfx_level >= GFX7) {
-      ac_set_reg_cu_en(pm4, R_00B01C_SPI_SHADER_PGM_RSRC3_PS,
-                       S_00B01C_CU_EN(cu_mask_ps) |
-                       S_00B01C_WAVE_LIMIT(0x3F) |
-                       S_00B01C_LDS_GROUP_SIZE(sctx->gfx_level >= GFX11),
-                       C_00B01C_CU_EN, 0, &sscreen->info,
-                       (void*)(sctx->gfx_level >= GFX10 ? si_pm4_set_reg_idx3 : si_pm4_set_reg));
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B01C_SPI_SHADER_PGM_RSRC3_PS,
+                          ac_apply_cu_en(S_00B01C_CU_EN(cu_mask_ps) |
+                                         S_00B01C_WAVE_LIMIT(0x3F) |
+                                         S_00B01C_LDS_GROUP_SIZE(sctx->gfx_level >= GFX11),
+                                         C_00B01C_CU_EN, 0, &sscreen->info));
    }
 
    if (sctx->gfx_level <= GFX8) {
@@ -5732,13 +5731,13 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
    }
 
    if (sctx->gfx_level >= GFX7 && sctx->gfx_level <= GFX8) {
-      ac_set_reg_cu_en(pm4, R_00B51C_SPI_SHADER_PGM_RSRC3_LS,
-                       S_00B51C_CU_EN(0xffff) | S_00B51C_WAVE_LIMIT(0x3F),
-                       C_00B51C_CU_EN, 0, &sscreen->info, (void*)si_pm4_set_reg);
+      si_pm4_set_reg(pm4, R_00B51C_SPI_SHADER_PGM_RSRC3_LS,
+                     ac_apply_cu_en(S_00B51C_CU_EN(0xffff) | S_00B51C_WAVE_LIMIT(0x3F),
+                                    C_00B51C_CU_EN, 0, &sscreen->info));
       si_pm4_set_reg(pm4, R_00B41C_SPI_SHADER_PGM_RSRC3_HS, S_00B41C_WAVE_LIMIT(0x3F));
-      ac_set_reg_cu_en(pm4, R_00B31C_SPI_SHADER_PGM_RSRC3_ES,
-                       S_00B31C_CU_EN(0xffff) | S_00B31C_WAVE_LIMIT(0x3F),
-                       C_00B31C_CU_EN, 0, &sscreen->info, (void*)si_pm4_set_reg);
+      si_pm4_set_reg(pm4, R_00B31C_SPI_SHADER_PGM_RSRC3_ES,
+                     ac_apply_cu_en(S_00B31C_CU_EN(0xffff) | S_00B31C_WAVE_LIMIT(0x3F),
+                                    C_00B31C_CU_EN, 0, &sscreen->info));
 
       /* If this is 0, Bonaire can hang even if GS isn't being used.
        * Other chips are unaffected. These are suboptimal values,
@@ -5795,10 +5794,9 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
    }
 
    if (sctx->gfx_level >= GFX9) {
-      ac_set_reg_cu_en(pm4, R_00B41C_SPI_SHADER_PGM_RSRC3_HS,
-                       S_00B41C_CU_EN(0xffff) | S_00B41C_WAVE_LIMIT(0x3F), C_00B41C_CU_EN,
-                       0, &sscreen->info,
-                       (void*)(sctx->gfx_level >= GFX10 ? si_pm4_set_reg_idx3 : si_pm4_set_reg));
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B41C_SPI_SHADER_PGM_RSRC3_HS,
+                          ac_apply_cu_en(S_00B41C_CU_EN(0xffff) | S_00B41C_WAVE_LIMIT(0x3F),
+                                         C_00B41C_CU_EN, 0, &sscreen->info));
 
       si_pm4_set_reg(pm4, R_028C48_PA_SC_BINNER_CNTL_1,
                      S_028C48_MAX_ALLOC_COUNT(sscreen->info.pbb_max_alloc_count - 1) |
@@ -5906,12 +5904,15 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
 
    if (sctx->gfx_level >= GFX10 && sctx->gfx_level <= GFX10_3) {
       /* Logical CUs 16 - 31 */
-      ac_set_reg_cu_en(pm4, R_00B004_SPI_SHADER_PGM_RSRC4_PS, S_00B004_CU_EN(cu_mask_ps >> 16),
-                       C_00B004_CU_EN, 16, &sscreen->info, (void*)si_pm4_set_reg_idx3);
-      ac_set_reg_cu_en(pm4, R_00B104_SPI_SHADER_PGM_RSRC4_VS, S_00B104_CU_EN(0xffff),
-                       C_00B104_CU_EN, 16, &sscreen->info, (void*)si_pm4_set_reg_idx3);
-      ac_set_reg_cu_en(pm4, R_00B404_SPI_SHADER_PGM_RSRC4_HS, S_00B404_CU_EN(0xffff),
-                       C_00B404_CU_EN, 16, &sscreen->info, (void*)si_pm4_set_reg_idx3);
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B004_SPI_SHADER_PGM_RSRC4_PS,
+                          ac_apply_cu_en(S_00B004_CU_EN(cu_mask_ps >> 16),
+                                         C_00B004_CU_EN, 16, &sscreen->info));
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B104_SPI_SHADER_PGM_RSRC4_VS,
+                          ac_apply_cu_en(S_00B104_CU_EN(0xffff),
+                                         C_00B104_CU_EN, 16, &sscreen->info));
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B404_SPI_SHADER_PGM_RSRC4_HS,
+                          ac_apply_cu_en(S_00B404_CU_EN(0xffff),
+                                         C_00B404_CU_EN, 16, &sscreen->info));
 
       si_pm4_set_reg(pm4, R_00B1C0_SPI_SHADER_REQ_CTRL_VS, 0);
       si_pm4_set_reg(pm4, R_00B1C8_SPI_SHADER_USER_ACCUM_VS_0, 0);
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 26bd9f2c926a..b62df82a6452 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -713,11 +713,10 @@ static void si_shader_hs(struct si_screen *sscreen, struct si_shader *shader)
 
    if (sscreen->info.gfx_level >= GFX9) {
       if (sscreen->info.gfx_level >= GFX11) {
-         ac_set_reg_cu_en(pm4, R_00B404_SPI_SHADER_PGM_RSRC4_HS,
-                          S_00B404_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)) |
-                          S_00B404_CU_EN(0xffff),
-                          C_00B404_CU_EN, 16, &sscreen->info,
-                          (void (*)(void*, unsigned, uint32_t))si_pm4_set_reg_idx3);
+         si_pm4_set_reg_idx3(sscreen, pm4, R_00B404_SPI_SHADER_PGM_RSRC4_HS,
+                             ac_apply_cu_en(S_00B404_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)) |
+                                            S_00B404_CU_EN(0xffff),
+                                            C_00B404_CU_EN, 16, &sscreen->info));
       }
       if (sscreen->info.gfx_level >= GFX10) {
          si_pm4_set_reg(pm4, R_00B520_SPI_SHADER_PGM_LO_LS, va >> 8);
@@ -983,37 +982,18 @@ static void si_emit_shader_gs(struct si_context *sctx)
    radeon_end_update_context_roll(sctx);
 
    /* These don't cause any context rolls. */
-   if (sctx->screen->info.spi_cu_en_has_effect) {
-      if (sctx->gfx_level >= GFX7) {
-         ac_set_reg_cu_en(&sctx->gfx_cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                          shader->gs.spi_shader_pgm_rsrc3_gs,
-                          C_00B21C_CU_EN, 0, &sctx->screen->info,
-                          (void (*)(void*, unsigned, uint32_t))
-                          (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
-         sctx->tracked_regs.reg_saved &= ~BITFIELD64_BIT(SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS);
-      }
-      if (sctx->gfx_level >= GFX10) {
-         ac_set_reg_cu_en(&sctx->gfx_cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                          shader->gs.spi_shader_pgm_rsrc4_gs,
-                          C_00B204_CU_EN_GFX10, 16, &sctx->screen->info,
-                          (void (*)(void*, unsigned, uint32_t))
-                          (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
-         sctx->tracked_regs.reg_saved &= ~BITFIELD64_BIT(SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS);
-      }
-   } else {
-      radeon_begin_again(&sctx->gfx_cs);
-      if (sctx->gfx_level >= GFX7) {
-         radeon_opt_set_sh_reg_idx3(sctx, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                                    SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS,
-                                    shader->gs.spi_shader_pgm_rsrc3_gs);
-      }
-      if (sctx->gfx_level >= GFX10) {
-         radeon_opt_set_sh_reg_idx3(sctx, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                                    SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS,
-                                    shader->gs.spi_shader_pgm_rsrc4_gs);
-      }
-      radeon_end();
+   radeon_begin_again(&sctx->gfx_cs);
+   if (sctx->gfx_level >= GFX7) {
+      radeon_opt_set_sh_reg_idx3(sctx, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
+                                 SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS,
+                                 shader->gs.spi_shader_pgm_rsrc3_gs);
    }
+   if (sctx->gfx_level >= GFX10) {
+      radeon_opt_set_sh_reg_idx3(sctx, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
+                                 SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS,
+                                 shader->gs.spi_shader_pgm_rsrc4_gs);
+   }
+   radeon_end();
 }
 
 static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
@@ -1125,10 +1105,14 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
       si_pm4_set_reg(pm4, R_00B228_SPI_SHADER_PGM_RSRC1_GS, rsrc1);
       si_pm4_set_reg(pm4, R_00B22C_SPI_SHADER_PGM_RSRC2_GS, rsrc2);
 
-      shader->gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
-                                           S_00B21C_WAVE_LIMIT(0x3F);
-      shader->gs.spi_shader_pgm_rsrc4_gs = S_00B204_CU_EN_GFX10(0xffff) |
-                                           S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0);
+      shader->gs.spi_shader_pgm_rsrc3_gs =
+         ac_apply_cu_en(S_00B21C_CU_EN(0xffff) |
+                        S_00B21C_WAVE_LIMIT(0x3F),
+                        C_00B21C_CU_EN, 0, &sscreen->info);
+      shader->gs.spi_shader_pgm_rsrc4_gs =
+         ac_apply_cu_en(S_00B204_CU_EN_GFX10(0xffff) |
+                        S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(0),
+                        C_00B204_CU_EN_GFX10, 16, &sscreen->info);
 
       shader->gs.vgt_gs_onchip_cntl =
          S_028A44_ES_VERTS_PER_SUBGRP(shader->gs_info.es_verts_per_subgroup) |
@@ -1142,8 +1126,10 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
 
       polaris_set_vgt_vertex_reuse(sscreen, shader->key.ge.part.gs.es, shader);
    } else {
-      shader->gs.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(0xffff) |
-                                           S_00B21C_WAVE_LIMIT(0x3F);
+      shader->gs.spi_shader_pgm_rsrc3_gs =
+         ac_apply_cu_en(S_00B21C_CU_EN(0xffff) |
+                        S_00B21C_WAVE_LIMIT(0x3F),
+                        C_00B21C_CU_EN, 0, &sscreen->info);
 
       si_pm4_set_reg(pm4, R_00B220_SPI_SHADER_PGM_LO_GS, va >> 8);
       pm4->reg_va_low_idx = pm4->ndw - 1;
@@ -1217,30 +1203,13 @@ static void gfx10_emit_shader_ngg_tail(struct si_context *sctx, struct si_shader
    radeon_begin_again(&sctx->gfx_cs);
    radeon_opt_set_uconfig_reg(sctx, R_030980_GE_PC_ALLOC, SI_TRACKED_GE_PC_ALLOC,
                               shader->ngg.ge_pc_alloc);
-   if (sctx->screen->info.spi_cu_en_has_effect) {
-      radeon_end();
-      ac_set_reg_cu_en(&sctx->gfx_cs, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                       shader->ngg.spi_shader_pgm_rsrc3_gs,
-                       C_00B21C_CU_EN, 0, &sctx->screen->info,
-                       (void (*)(void*, unsigned, uint32_t))
-                       (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
-      ac_set_reg_cu_en(&sctx->gfx_cs, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                       shader->ngg.spi_shader_pgm_rsrc4_gs,
-                       sctx->gfx_level >= GFX11 ? C_00B204_CU_EN_GFX11 : C_00B204_CU_EN_GFX10, 16,
-                       &sctx->screen->info,
-                       (void (*)(void*, unsigned, uint32_t))
-                       (sctx->gfx_level >= GFX10 ? radeon_set_sh_reg_idx3_func : radeon_set_sh_reg_func));
-      sctx->tracked_regs.reg_saved &= ~BITFIELD64_BIT(SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS) &
-                                      ~BITFIELD64_BIT(SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS);
-   } else {
-      radeon_opt_set_sh_reg_idx3(sctx, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
-                                 SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS,
-                                 shader->ngg.spi_shader_pgm_rsrc3_gs);
-      radeon_opt_set_sh_reg_idx3(sctx, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
-                                 SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS,
-                                 shader->ngg.spi_shader_pgm_rsrc4_gs);
-      radeon_end();
-   }
+   radeon_opt_set_sh_reg_idx3(sctx, R_00B21C_SPI_SHADER_PGM_RSRC3_GS,
+                              SI_TRACKED_SPI_SHADER_PGM_RSRC3_GS,
+                              shader->ngg.spi_shader_pgm_rsrc3_gs);
+   radeon_opt_set_sh_reg_idx3(sctx, R_00B204_SPI_SHADER_PGM_RSRC4_GS,
+                              SI_TRACKED_SPI_SHADER_PGM_RSRC4_GS,
+                              shader->ngg.spi_shader_pgm_rsrc4_gs);
+   radeon_end();
 }
 
 static void gfx10_emit_shader_ngg_notess_nogs(struct si_context *sctx)
@@ -1438,15 +1407,21 @@ static void gfx10_shader_ngg(struct si_screen *sscreen, struct si_shader *shader
                      S_00B22C_OC_LDS_EN(es_stage == MESA_SHADER_TESS_EVAL) |
                      S_00B22C_LDS_SIZE(shader->config.lds_size));
 
-   shader->ngg.spi_shader_pgm_rsrc3_gs = S_00B21C_CU_EN(cu_mask) |
-                                         S_00B21C_WAVE_LIMIT(0x3F);
+   shader->ngg.spi_shader_pgm_rsrc3_gs =
+      ac_apply_cu_en(S_00B21C_CU_EN(cu_mask) |
+                     S_00B21C_WAVE_LIMIT(0x3F),
+                     C_00B21C_CU_EN, 0, &sscreen->info);
    if (sscreen->info.gfx_level >= GFX11) {
       shader->ngg.spi_shader_pgm_rsrc4_gs =
-         S_00B204_CU_EN_GFX11(0x1) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64) |
-         S_00B204_INST_PREF_SIZE(si_get_shader_prefetch_size(shader));
+         ac_apply_cu_en(S_00B204_CU_EN_GFX11(0x1) |
+                        S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64) |
+                        S_00B204_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)),
+                        C_00B204_CU_EN_GFX11, 16, &sscreen->info);
    } else {
       shader->ngg.spi_shader_pgm_rsrc4_gs =
-         S_00B204_CU_EN_GFX10(0xffff) | S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64);
+         ac_apply_cu_en(S_00B204_CU_EN_GFX10(0xffff) |
+                        S_00B204_SPI_SHADER_LATE_ALLOC_GS_GFX10(late_alloc_wave64),
+                        C_00B204_CU_EN_GFX10, 16, &sscreen->info);
    }
 
    nparams = MAX2(shader->info.nr_param_exports, 1);
@@ -1726,11 +1701,10 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
    oc_lds_en = shader->selector->stage == MESA_SHADER_TESS_EVAL ? 1 : 0;
 
    if (sscreen->info.gfx_level >= GFX7) {
-      ac_set_reg_cu_en(pm4, R_00B118_SPI_SHADER_PGM_RSRC3_VS,
-                       S_00B118_CU_EN(cu_mask) | S_00B118_WAVE_LIMIT(0x3F),
-                       C_00B118_CU_EN, 0, &sscreen->info,
-                       (void (*)(void*, unsigned, uint32_t))
-                       (sscreen->info.gfx_level >= GFX10 ? si_pm4_set_reg_idx3 : si_pm4_set_reg));
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B118_SPI_SHADER_PGM_RSRC3_VS,
+                          ac_apply_cu_en(S_00B118_CU_EN(cu_mask) |
+                                         S_00B118_WAVE_LIMIT(0x3F),
+                                         C_00B118_CU_EN, 0, &sscreen->info));
       si_pm4_set_reg(pm4, R_00B11C_SPI_SHADER_LATE_ALLOC_VS, S_00B11C_LIMIT(late_alloc_wave64));
    }
 
@@ -2048,11 +2022,10 @@ static void si_shader_ps(struct si_screen *sscreen, struct si_shader *shader)
    if (sscreen->info.gfx_level >= GFX11) {
       unsigned cu_mask_ps = gfx103_get_cu_mask_ps(sscreen);
 
-      ac_set_reg_cu_en(pm4, R_00B004_SPI_SHADER_PGM_RSRC4_PS,
-                       S_00B004_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)) |
-                       S_00B004_CU_EN(cu_mask_ps >> 16),
-                       C_00B004_CU_EN, 16, &sscreen->info,
-                       (void (*)(void*, unsigned, uint32_t))si_pm4_set_reg_idx3);
+      si_pm4_set_reg_idx3(sscreen, pm4, R_00B004_SPI_SHADER_PGM_RSRC4_PS,
+                          ac_apply_cu_en(S_00B004_CU_EN(cu_mask_ps >> 16) |
+                                         S_00B004_INST_PREF_SIZE(si_get_shader_prefetch_size(shader)),
+                                         C_00B004_CU_EN, 16, &sscreen->info));
    }
 }
 
-- 
GitLab


From f5dc13af18cbb95ccf6d39ec58b11890e87d0966 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 22 Feb 2023 06:38:00 -0500
Subject: [PATCH 45/45] radeonsi: merge si_emit_initial_compute_regs with
 si_init_cs_preamble_state

It's better to set all immutable registers in one place.
(of course it's a subjective opinion)
---
 src/gallium/drivers/radeonsi/si_compute.c     | 103 ------------------
 .../drivers/radeonsi/si_cp_reg_shadowing.c    |   5 +-
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  21 ++--
 src/gallium/drivers/radeonsi/si_pipe.c        |   4 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |   1 -
 src/gallium/drivers/radeonsi/si_state.c       |  86 +++++++++++++--
 6 files changed, 93 insertions(+), 127 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index d8491fb4c0dc..7aff25772c86 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -379,102 +379,6 @@ static void si_set_global_binding(struct pipe_context *ctx, unsigned first, unsi
    }
 }
 
-void si_emit_initial_compute_regs(struct si_context *sctx, struct radeon_cmdbuf *cs)
-{
-   const struct radeon_info *info = &sctx->screen->info;
-
-   radeon_begin(cs);
-   radeon_set_sh_reg(R_00B834_COMPUTE_PGM_HI,
-                     S_00B834_DATA(sctx->screen->info.address32_hi >> 8));
-
-   radeon_set_sh_reg_seq(R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE0, 2);
-   /* R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE0 / SE1,
-    * renamed COMPUTE_DESTINATION_EN_SEn on gfx10. */
-   radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-   radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-
-   if (sctx->gfx_level == GFX6) {
-      /* This register has been moved to R_00CD20_COMPUTE_MAX_WAVE_ID
-       * and is now per pipe, so it should be handled in the
-       * kernel if we want to use something other than the default value.
-       *
-       * TODO: This should be:
-       * (number of compute units) * 4 * (waves per simd) - 1
-       */
-      radeon_set_sh_reg(R_00B82C_COMPUTE_MAX_WAVE_ID, 0x190 /* Default value */);
-      radeon_set_config_reg(R_00950C_TA_CS_BC_BASE_ADDR, sctx->border_color_buffer->gpu_address >> 8);
-   }
-
-   if (sctx->gfx_level >= GFX7) {
-      /* Also set R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE2 / SE3 */
-      radeon_set_sh_reg_seq(R_00B864_COMPUTE_STATIC_THREAD_MGMT_SE2, 2);
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-
-      /* Disable profiling on compute queues. */
-      if (cs != &sctx->gfx_cs || !sctx->screen->info.has_graphics) {
-         radeon_set_sh_reg(R_00B82C_COMPUTE_PERFCOUNT_ENABLE, 0);
-         radeon_set_sh_reg(R_00B878_COMPUTE_THREAD_TRACE_ENABLE, 0);
-      }
-
-      /* Set the pointer to border colors. */
-      /* MI200 doesn't support border colors. */
-      if (sctx->border_color_buffer) {
-         uint64_t bc_va = sctx->border_color_buffer->gpu_address;
-
-         radeon_set_uconfig_reg_seq(R_030E00_TA_CS_BC_BASE_ADDR, 2, false);
-         radeon_emit(bc_va >> 8);                    /* R_030E00_TA_CS_BC_BASE_ADDR */
-         radeon_emit(S_030E04_ADDRESS(bc_va >> 40)); /* R_030E04_TA_CS_BC_BASE_ADDR_HI */
-      }
-   }
-
-   /* cs_preamble_state initializes this for the gfx queue, so only do this
-    * if we are on a compute queue.
-    */
-   if (sctx->gfx_level >= GFX9 && sctx->gfx_level < GFX11 &&
-       (cs != &sctx->gfx_cs || !sctx->screen->info.has_graphics)) {
-      radeon_set_uconfig_reg(R_0301EC_CP_COHER_START_DELAY,
-                             sctx->gfx_level >= GFX10 ? 0x20 : 0);
-   }
-
-   if (!info->has_graphics && info->family >= CHIP_MI100) {
-      radeon_set_sh_reg_seq(R_00B894_COMPUTE_STATIC_THREAD_MGMT_SE4, 4);
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-      radeon_emit(S_00B858_SH0_CU_EN(info->spi_cu_en) | S_00B858_SH1_CU_EN(info->spi_cu_en));
-   }
-
-   if (sctx->gfx_level >= GFX10) {
-      radeon_set_sh_reg_seq(R_00B890_COMPUTE_USER_ACCUM_0, 4);
-      radeon_emit(0); /* R_00B890_COMPUTE_USER_ACCUM_0 */
-      radeon_emit(0); /* R_00B894_COMPUTE_USER_ACCUM_1 */
-      radeon_emit(0); /* R_00B898_COMPUTE_USER_ACCUM_2 */
-      radeon_emit(0); /* R_00B89C_COMPUTE_USER_ACCUM_3 */
-
-      radeon_set_sh_reg(R_00B9F4_COMPUTE_DISPATCH_TUNNEL, 0);
-
-      if (sctx->gfx_level < GFX11)
-         radeon_set_sh_reg(R_00B8A0_COMPUTE_PGM_RSRC3, 0);
-   }
-
-   if (sctx->gfx_level >= GFX11) {
-      radeon_set_sh_reg_seq(R_00B8AC_COMPUTE_STATIC_THREAD_MGMT_SE4, 4);
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE4 */
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE5 */
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE6 */
-      radeon_emit(S_00B8AC_SA0_CU_EN(info->spi_cu_en) | S_00B8AC_SA1_CU_EN(info->spi_cu_en)); /* SE7 */
-
-      /* How many threads should go to 1 SE before moving onto the next. Think of GL1 cache hits.
-       * Only these values are valid: 0 (disabled), 64, 128, 256, 512
-       * Recommendation: 64 = RT, 256 = non-RT (run benchmarks to be sure)
-       */
-      radeon_set_sh_reg(R_00B8BC_COMPUTE_DISPATCH_INTERLEAVE, S_00B8BC_INTERLEAVE(256));
-   }
-
-   radeon_end();
-}
-
 static bool si_setup_compute_scratch_buffer(struct si_context *sctx, struct si_shader *shader)
 {
    uint64_t scratch_bo_size, scratch_needed;
@@ -1019,13 +923,6 @@ static void si_launch_grid(struct pipe_context *ctx, const struct pipe_grid_info
    if (sctx->bo_list_add_all_compute_resources)
       si_compute_resources_add_all_to_bo_list(sctx);
 
-   if (!sctx->cs_shader_state.initialized) {
-      si_emit_initial_compute_regs(sctx, &sctx->gfx_cs);
-
-      sctx->cs_shader_state.emitted_program = NULL;
-      sctx->cs_shader_state.initialized = true;
-   }
-
    /* First emit registers. */
    bool prefetch;
    if (!si_switch_compute_shader(sctx, program, &program->shader, code_object, info->pc, &prefetch,
diff --git a/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c b/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
index 9b5c15ab9633..ecdbc5ec71cc 100644
--- a/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
+++ b/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
@@ -38,8 +38,9 @@ static void si_set_context_reg_array(struct radeon_cmdbuf *cs, unsigned reg, uns
 
 void si_init_cp_reg_shadowing(struct si_context *sctx)
 {
-   if (sctx->screen->info.mid_command_buffer_preemption_enabled ||
-       sctx->screen->debug_flags & DBG(SHADOW_REGS)) {
+   if (sctx->has_graphics &&
+       (sctx->screen->info.mid_command_buffer_preemption_enabled ||
+        sctx->screen->debug_flags & DBG(SHADOW_REGS))) {
       sctx->shadowed_regs =
             si_aligned_buffer_create(sctx->b.screen,
                                      PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index e9d5c3159715..bfc84586c86d 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -413,9 +413,17 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
    }
 
    si_add_all_descriptors_to_bo_list(ctx);
-
    si_shader_pointers_mark_dirty(ctx);
-   ctx->cs_shader_state.initialized = false;
+   ctx->cs_shader_state.emitted_program = NULL;
+
+   /* The CS initialization should be emitted before everything else. */
+   if (ctx->cs_preamble_state) {
+      struct si_pm4_state *preamble = is_secure ? ctx->cs_preamble_state_tmz :
+                                                  ctx->cs_preamble_state;
+      ctx->ws->cs_set_preamble(&ctx->gfx_cs, preamble->pm4, preamble->ndw,
+                               preamble != ctx->last_preamble);
+      ctx->last_preamble = preamble;
+   }
 
    if (!ctx->has_graphics) {
       ctx->initial_gfx_cs_size = ctx->gfx_cs.current.cdw;
@@ -433,15 +441,6 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
     */
    si_pm4_reset_emitted(ctx);
 
-   /* The CS initialization should be emitted before everything else. */
-   if (ctx->cs_preamble_state) {
-      struct si_pm4_state *preamble = is_secure ? ctx->cs_preamble_state_tmz :
-                                                  ctx->cs_preamble_state;
-      ctx->ws->cs_set_preamble(&ctx->gfx_cs, preamble->pm4, preamble->ndw,
-                               preamble != ctx->last_preamble);
-      ctx->last_preamble = preamble;
-   }
-
    if (ctx->queued.named.ls)
       ctx->prefetch_L2_mask |= SI_PREFETCH_LS;
    if (ctx->queued.named.hs)
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index a358b620f963..06b13ba5a5b1 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -753,9 +753,7 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
    /* The remainder of this function initializes the gfx CS and must be last. */
    assert(sctx->gfx_cs.current.cdw == 0);
 
-   if (sctx->has_graphics) {
-      si_init_cp_reg_shadowing(sctx);
-   }
+   si_init_cp_reg_shadowing(sctx);
 
    /* Set immutable fields of shader keys. */
    if (sctx->gfx_level >= GFX9) {
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 792fb4aed127..368e3abc7955 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -734,7 +734,6 @@ struct si_cs_shader_state {
    struct si_compute *emitted_program;
    unsigned offset;
    uint32_t variable_shared_size;
-   bool initialized;
 };
 
 struct si_samplers {
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 22066ab358b5..00df998fd703 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -5591,7 +5591,10 @@ unsigned gfx103_get_cu_mask_ps(struct si_screen *sscreen)
 void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
 {
    struct si_screen *sscreen = sctx->screen;
-   uint64_t border_color_va = sctx->border_color_buffer->gpu_address;
+   uint64_t border_color_va =
+      sctx->border_color_buffer ? sctx->border_color_buffer->gpu_address : 0;
+   uint32_t compute_cu_en = S_00B858_SH0_CU_EN(sscreen->info.spi_cu_en) |
+                            S_00B858_SH1_CU_EN(sscreen->info.spi_cu_en);
    bool has_clear_state = sscreen->info.has_clear_state;
 
    struct si_cs_preamble {
@@ -5606,7 +5609,7 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
    /* Add all the space that we allocated. */
    pm4->max_dw = (sizeof(struct si_cs_preamble) - offsetof(struct si_cs_preamble, pm4.pm4)) / 4;
 
-   if (!uses_reg_shadowing) {
+   if (sctx->has_graphics && !uses_reg_shadowing) {
       si_pm4_cmd_add(pm4, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
       si_pm4_cmd_add(pm4, CC0_UPDATE_LOAD_ENABLES(1));
       si_pm4_cmd_add(pm4, CC1_UPDATE_SHADOW_ENABLES(1));
@@ -5622,6 +5625,79 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
       }
    }
 
+   /* Compute registers. */
+   si_pm4_set_reg(pm4, R_00B834_COMPUTE_PGM_HI, S_00B834_DATA(sctx->screen->info.address32_hi >> 8));
+   si_pm4_set_reg(pm4, R_00B858_COMPUTE_STATIC_THREAD_MGMT_SE0, compute_cu_en);
+   si_pm4_set_reg(pm4, R_00B85C_COMPUTE_STATIC_THREAD_MGMT_SE1, compute_cu_en);
+
+   if (sctx->gfx_level == GFX6) {
+      /* This register has been moved to R_00CD20_COMPUTE_MAX_WAVE_ID and is now per pipe,
+       * so it should be handled in the kernel if we want to use something other than
+       * the default value.
+       * TODO: This should be: (number of compute units) * 4 * (waves per simd) - 1
+       */
+      si_pm4_set_reg(pm4, R_00B82C_COMPUTE_MAX_WAVE_ID, 0x190 /* Default value */);
+   }
+
+   if (sctx->gfx_level >= GFX7) {
+      si_pm4_set_reg(pm4, R_00B864_COMPUTE_STATIC_THREAD_MGMT_SE2, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B868_COMPUTE_STATIC_THREAD_MGMT_SE3, compute_cu_en);
+
+      /* Disable profiling on compute chips. */
+      if (!sscreen->info.has_graphics) {
+         si_pm4_set_reg(pm4, R_00B82C_COMPUTE_PERFCOUNT_ENABLE, 0);
+         si_pm4_set_reg(pm4, R_00B878_COMPUTE_THREAD_TRACE_ENABLE, 0);
+      }
+   }
+
+   if (sctx->gfx_level >= GFX9 && sctx->gfx_level < GFX11)
+      si_pm4_set_reg(pm4, R_0301EC_CP_COHER_START_DELAY, sctx->gfx_level >= GFX10 ? 0x20 : 0);
+
+   if (!sscreen->info.has_graphics && sscreen->info.family >= CHIP_MI100) {
+      si_pm4_set_reg(pm4, R_00B894_COMPUTE_STATIC_THREAD_MGMT_SE4, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B898_COMPUTE_STATIC_THREAD_MGMT_SE5, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B89C_COMPUTE_STATIC_THREAD_MGMT_SE6, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8A0_COMPUTE_STATIC_THREAD_MGMT_SE7, compute_cu_en);
+   }
+
+   if (sctx->gfx_level >= GFX10) {
+      si_pm4_set_reg(pm4, R_00B890_COMPUTE_USER_ACCUM_0, 0);
+      si_pm4_set_reg(pm4, R_00B894_COMPUTE_USER_ACCUM_1, 0);
+      si_pm4_set_reg(pm4, R_00B898_COMPUTE_USER_ACCUM_2, 0);
+      si_pm4_set_reg(pm4, R_00B89C_COMPUTE_USER_ACCUM_3, 0);
+
+      if (sctx->gfx_level < GFX11)
+         si_pm4_set_reg(pm4, R_00B8A0_COMPUTE_PGM_RSRC3, 0);
+
+      si_pm4_set_reg(pm4, R_00B9F4_COMPUTE_DISPATCH_TUNNEL, 0);
+   }
+
+   if (sctx->gfx_level >= GFX11) {
+      si_pm4_set_reg(pm4, R_00B8AC_COMPUTE_STATIC_THREAD_MGMT_SE4, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8B0_COMPUTE_STATIC_THREAD_MGMT_SE5, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8B4_COMPUTE_STATIC_THREAD_MGMT_SE6, compute_cu_en);
+      si_pm4_set_reg(pm4, R_00B8B8_COMPUTE_STATIC_THREAD_MGMT_SE7, compute_cu_en);
+
+      /* How many threads should go to 1 SE before moving onto the next. Think of GL1 cache hits.
+       * Only these values are valid: 0 (disabled), 64, 128, 256, 512
+       * Recommendation: 64 = RT, 256 = non-RT (run benchmarks to be sure)
+       */
+      si_pm4_set_reg(pm4, R_00B8BC_COMPUTE_DISPATCH_INTERLEAVE, S_00B8BC_INTERLEAVE(256));
+   }
+
+   /* Set the pointer to border colors. MI200 doesn't support border colors. */
+   if (sctx->gfx_level >= GFX7 && sctx->border_color_buffer) {
+      si_pm4_set_reg(pm4, R_030E00_TA_CS_BC_BASE_ADDR, border_color_va >> 8);
+      si_pm4_set_reg(pm4, R_030E04_TA_CS_BC_BASE_ADDR_HI,
+                     S_030E04_ADDRESS(border_color_va >> 40));
+   } else if (sctx->gfx_level == GFX6) {
+      si_pm4_set_reg(pm4, R_00950C_TA_CS_BC_BASE_ADDR, border_color_va >> 8);
+   }
+
+   if (!sctx->has_graphics)
+      goto done;
+
+   /* Graphics registers. */
    /* CLEAR_STATE doesn't restore these correctly. */
    si_pm4_set_reg(pm4, R_028240_PA_SC_GENERIC_SCISSOR_TL, S_028240_WINDOW_OFFSET_DISABLE(1));
    si_pm4_set_reg(pm4, R_028244_PA_SC_GENERIC_SCISSOR_BR,
@@ -5805,11 +5881,6 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
                      S_028C4C_NULL_SQUAD_AA_MASK_ENABLE(1));
 
       si_pm4_set_reg(pm4, R_030968_VGT_INSTANCE_BASE_ID, 0);
-
-      if (sctx->gfx_level < GFX11) {
-         si_pm4_set_reg(pm4, R_0301EC_CP_COHER_START_DELAY,
-                        sctx->gfx_level >= GFX10 ? 0x20 : 0);
-      }
    }
 
    if (sctx->gfx_level >= GFX10) {
@@ -5992,6 +6063,7 @@ void si_init_cs_preamble_state(struct si_context *sctx, bool uses_reg_shadowing)
                      S_03111C_L1_POLICY(1));
    }
 
+done:
    sctx->cs_preamble_state = pm4;
 
    /* Make a copy of the preamble for TMZ. */
-- 
GitLab

