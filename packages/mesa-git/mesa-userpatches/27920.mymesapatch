From 35bb1f919470561cc53b95958d4b1255779aeec5 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 28 Feb 2024 11:59:08 +0000
Subject: [PATCH 1/2] radv,aco: allow VS prologs to increase VGPR usage

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Cc: mesa-stable
---
 .../compiler/aco_instruction_selection.cpp    |  2 +-
 src/amd/vulkan/radv_cmd_buffer.c              | 36 ++++++++-----------
 src/amd/vulkan/radv_shader_args.c             |  4 ---
 3 files changed, 16 insertions(+), 26 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 356d7aadce741..899d40423fb63 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -194,7 +194,7 @@ emit_bpermute(isel_context* ctx, Builder& bld, Temp index, Temp data)
       ctx->options->gfx_level >= GFX10 && ctx->options->gfx_level < GFX11 &&
       ctx->program->wave_size == 64 &&
       (ctx->program->info.has_epilog || ctx->program->info.merged_shader_compiled_separately ||
-       ctx->stage == raytracing_cs);
+       ctx->program->info.vs.has_prolog || ctx->stage == raytracing_cs);
 
    if (ctx->options->gfx_level <= GFX7 || avoid_shared_vgprs) {
       /* GFX6-7: there is no bpermute instruction */
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index afe0edfe7e077..e30661cefbac4 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3938,10 +3938,8 @@ emit_prolog_regs(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    if (chip < GFX10 && G_00B228_SGPRS(prolog->rsrc1) > G_00B228_SGPRS(rsrc1))
       rsrc1 = (rsrc1 & C_00B228_SGPRS) | (prolog->rsrc1 & ~C_00B228_SGPRS);
 
-   /* The main shader must not use less VGPRs than the prolog, otherwise shared vgprs might not
-    * work.
-    */
-   assert(G_00B848_VGPRS(vs_shader->config.rsrc1) >= G_00B848_VGPRS(prolog->rsrc1));
+   if (G_00B848_VGPRS(prolog->rsrc1) > G_00B848_VGPRS(rsrc1))
+      rsrc1 = (rsrc1 & C_00B848_VGPRS) | (prolog->rsrc1 & ~C_00B848_VGPRS);
 
    unsigned pgm_lo_reg = R_00B120_SPI_SHADER_PGM_LO_VS;
    unsigned rsrc1_reg = R_00B128_SPI_SHADER_PGM_RSRC1_VS;
@@ -3964,28 +3962,24 @@ emit_prolog_regs(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
 
    radeon_set_sh_reg(cmd_buffer->cs, pgm_lo_reg, prolog->va >> 8);
 
-   if (chip < GFX10 || vs_shader->info.merged_shader_compiled_separately) {
-      radeon_set_sh_reg(cmd_buffer->cs, rsrc1_reg, rsrc1);
-
-      if (vs_shader->info.merged_shader_compiled_separately) {
-         if (vs_shader->info.next_stage == MESA_SHADER_GEOMETRY) {
-            const struct radv_shader *gs = cmd_buffer->state.shaders[MESA_SHADER_GEOMETRY];
-            unsigned lds_size;
+   radeon_set_sh_reg(cmd_buffer->cs, rsrc1_reg, rsrc1);
 
-            if (gs->info.is_ngg) {
-               lds_size = DIV_ROUND_UP(gs->info.ngg_info.lds_size,
-                                       cmd_buffer->device->physical_device->rad_info.lds_encode_granularity);
-            } else {
-               lds_size = gs->info.gs_ring_info.lds_size;
-            }
+   if (vs_shader->info.merged_shader_compiled_separately) {
+      if (vs_shader->info.next_stage == MESA_SHADER_GEOMETRY) {
+         const struct radv_shader *gs = cmd_buffer->state.shaders[MESA_SHADER_GEOMETRY];
+         unsigned lds_size;
 
-            radeon_set_sh_reg(cmd_buffer->cs, rsrc1_reg + 4, rsrc2 | S_00B22C_LDS_SIZE(lds_size));
+         if (gs->info.is_ngg) {
+            lds_size = DIV_ROUND_UP(gs->info.ngg_info.lds_size,
+                                    cmd_buffer->device->physical_device->rad_info.lds_encode_granularity);
          } else {
-            radeon_set_sh_reg(cmd_buffer->cs, rsrc1_reg + 4, rsrc2);
+            lds_size = gs->info.gs_ring_info.lds_size;
          }
+
+         radeon_set_sh_reg(cmd_buffer->cs, rsrc1_reg + 4, rsrc2 | S_00B22C_LDS_SIZE(lds_size));
+      } else {
+         radeon_set_sh_reg(cmd_buffer->cs, rsrc1_reg + 4, rsrc2);
       }
-   } else {
-      assert(rsrc1 == vs_shader->config.rsrc1);
    }
 
    radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, prolog->bo);
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index babc31fa1ed9d..2a67288592370 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -205,10 +205,6 @@ declare_vs_input_vgprs(enum amd_gfx_level gfx_level, const struct radv_shader_in
          ac_add_arg(&args->ac, AC_ARG_VGPR, 4, AC_ARG_INT, &args->vs_inputs[i]);
          args->ac.args[args->vs_inputs[i].arg_index].pending_vmem = true;
       }
-      /* Ensure the main shader doesn't use less vgprs than the prolog. The prolog requires one
-       * VGPR more than the number of shader arguments in the case of non-trivial divisors on GFX8.
-       */
-      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL);
    }
 }
 
-- 
GitLab


From 5c23dfb01c025b4fcd8cd1688e84a7164578f37d Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 28 Feb 2024 12:23:17 +0000
Subject: [PATCH 2/2] aco: don't reuse misaligned attribute destination VGPRs
 in VS prologs

Since we split misaligned attributes, we could overwrite one of these
VGPRs in the middle of loading the attribute.

For example:
   v_add_u32_e32 v4, vcc, s7, v1
   s_waitcnt lgkmcnt(0)
   buffer_load_dword v4, v4, s[32:35], 0 idxen
   buffer_load_dword v5, v4, s[32:35], 0 idxen offset:4
can overwrite the vertex index in the load of the first component.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Cc: mesa-stable
---
 .../compiler/aco_instruction_selection.cpp    | 45 +++++++++++--------
 1 file changed, 26 insertions(+), 19 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 899d40423fb63..b81b6f1512f08 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12756,6 +12756,15 @@ select_rt_prolog(Program* program, ac_shader_config* config,
    program->config->num_sgprs = get_sgpr_alloc(program, num_sgprs);
 }
 
+PhysReg
+get_next_vgpr(unsigned size, unsigned* num, bool unskipped = true, int offset = 0)
+{
+   unsigned reg = *num + offset;
+   if (unskipped)
+      *num = MAX2(reg + size, *num);
+   return PhysReg(256 + reg);
+}
+
 void
 select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_shader_config* config,
                  const struct aco_compiler_options* options, const struct aco_shader_info* info,
@@ -12797,13 +12806,22 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
    Operand start_instance = get_arg_fixed(args, args->start_instance);
    Operand instance_id = get_arg_fixed(args, args->instance_id);
 
-   PhysReg attributes_start(256 + args->num_vgprs_used);
-   /* choose vgprs that won't be used for anything else until the last attribute load */
-   PhysReg vertex_index(attributes_start.reg() + pinfo->num_attributes * 4 - 1);
-   PhysReg instance_index(attributes_start.reg() + pinfo->num_attributes * 4 - 2);
-   PhysReg start_instance_vgpr(attributes_start.reg() + pinfo->num_attributes * 4 - 3);
-   PhysReg nontrivial_tmp_vgpr0(attributes_start.reg() + pinfo->num_attributes * 4 - 4);
-   PhysReg nontrivial_tmp_vgpr1(attributes_start.reg() + pinfo->num_attributes * 4);
+   bool needs_instance_index =
+      pinfo->instance_rate_inputs &
+      ~(pinfo->zero_divisors | pinfo->nontrivial_divisors); /* divisor is 1 */
+   bool needs_start_instance = pinfo->instance_rate_inputs & pinfo->zero_divisors;
+   bool needs_vertex_index = ~pinfo->instance_rate_inputs & attrib_mask;
+   bool needs_tmp_vgpr = has_nontrivial_divisors && program->gfx_level <= GFX8;
+
+   int vgpr_offset = pinfo->misaligned_mask & (1u << (pinfo->num_attributes - 1)) ? 0 : -4;
+
+   unsigned num_vgprs = args->num_vgprs_used;
+   PhysReg attributes_start = get_next_vgpr(pinfo->num_attributes * 4, &num_vgprs);
+   PhysReg vertex_index = get_next_vgpr(1, &num_vgprs, needs_vertex_index, vgpr_offset);
+   PhysReg instance_index = get_next_vgpr(1, &num_vgprs, needs_instance_index, vgpr_offset);
+   PhysReg start_instance_vgpr = get_next_vgpr(1, &num_vgprs, needs_start_instance, vgpr_offset);
+   PhysReg nontrivial_tmp_vgpr0 = get_next_vgpr(1, &num_vgprs, needs_tmp_vgpr, vgpr_offset);
+   PhysReg nontrivial_tmp_vgpr1 = get_next_vgpr(1, &num_vgprs, needs_tmp_vgpr, vgpr_offset);
 
    bld.sop1(aco_opcode::s_mov_b32, Definition(vertex_buffers, s1),
             get_arg_fixed(args, args->vertex_buffers));
@@ -12815,16 +12833,10 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
                Operand::c32((unsigned)options->address32_hi));
    }
 
-   /* calculate vgpr requirements */
-   unsigned num_vgprs = attributes_start.reg() - 256;
-   num_vgprs += pinfo->num_attributes * 4;
-   if (has_nontrivial_divisors && program->gfx_level <= GFX8)
-      num_vgprs++; /* make space for nontrivial_tmp_vgpr1 */
-   unsigned num_sgprs = 0;
-
    const struct ac_vtx_format_info* vtx_info_table =
       ac_get_vtx_format_info_table(GFX8, CHIP_POLARIS10);
 
+   unsigned num_sgprs = 0;
    for (unsigned loc = 0; loc < pinfo->num_attributes;) {
       unsigned num_descs =
          load_vb_descs(bld, desc, Operand(vertex_buffers, s2), loc, pinfo->num_attributes - loc);
@@ -12864,11 +12876,6 @@ select_vs_prolog(Program* program, const struct aco_vs_prolog_info* pinfo, ac_sh
             }
          }
 
-         bool needs_instance_index =
-            pinfo->instance_rate_inputs &
-            ~(pinfo->zero_divisors | pinfo->nontrivial_divisors); /* divisor is 1 */
-         bool needs_start_instance = pinfo->instance_rate_inputs & pinfo->zero_divisors;
-         bool needs_vertex_index = ~pinfo->instance_rate_inputs & attrib_mask;
          if (needs_vertex_index)
             bld.vadd32(Definition(vertex_index, v1), get_arg_fixed(args, args->base_vertex),
                        get_arg_fixed(args, args->vertex_id), false, Operand(s2), true);
-- 
GitLab

