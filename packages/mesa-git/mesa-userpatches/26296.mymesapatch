From be6ea4aeb5925023d04d8df187ce6a0f558e3135 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Sat, 18 Nov 2023 22:38:20 -0800
Subject: [PATCH 1/4] ac: pass radeon_info to ac_surface_zero_dcc_fields

We will need radeon_info to compute the effective modifier in a
following commit.
---
 src/amd/common/ac_surface.c               | 6 +++---
 src/amd/common/ac_surface.h               | 2 +-
 src/amd/vulkan/radv_image.c               | 2 +-
 src/gallium/drivers/radeonsi/si_texture.c | 2 +-
 4 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 25832d8f9660b..abccb9f98dc89 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -2659,7 +2659,7 @@ int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *inf
 }
 
 /* This is meant to be used for disabling DCC. */
-void ac_surface_zero_dcc_fields(struct radeon_surf *surf)
+void ac_surface_zero_dcc_fields(const struct radeon_info *info, struct radeon_surf *surf)
 {
    if (surf->flags & RADEON_SURF_Z_OR_SBUFFER)
       return;
@@ -2839,7 +2839,7 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
        metadata[0] == 0 ||       /* invalid version number (1 and 2 layouts are compatible) */
        metadata[1] != ac_get_umd_metadata_word1(info)) /* invalid PCI ID */ {
       /* Disable DCC because it might not be enabled. */
-      ac_surface_zero_dcc_fields(surf);
+      ac_surface_zero_dcc_fields(info, surf);
 
       /* Don't report an error if the texture comes from an incompatible driver,
        * but this might not work.
@@ -2906,7 +2906,7 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
       /* Disable DCC. dcc_offset is always set by texture_from_handle
        * and must be cleared here.
        */
-      ac_surface_zero_dcc_fields(surf);
+      ac_surface_zero_dcc_fields(info, surf);
    }
 
    return true;
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index 11808f79bf10f..0c865a4d828a4 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -422,7 +422,7 @@ void *ac_addrlib_get_handle(struct ac_addrlib *addrlib);
 int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *info,
                        const struct ac_surf_config *config, enum radeon_surf_mode mode,
                        struct radeon_surf *surf);
-void ac_surface_zero_dcc_fields(struct radeon_surf *surf);
+void ac_surface_zero_dcc_fields(const struct radeon_info *info, struct radeon_surf *surf);
 unsigned ac_pipe_config_to_num_pipes(unsigned pipe_config);
 
 void ac_surface_apply_bo_metadata(const struct radeon_info *info, struct radeon_surf *surf,
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 5c7a1ad71e83a..dff8790c65690 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -1737,7 +1737,7 @@ radv_image_create_layout(struct radv_device *device, struct radv_image_create_in
 
       if (plane == 0) {
          if (!radv_use_dcc_for_image_late(device, image))
-            ac_surface_zero_dcc_fields(&image->planes[0].surface);
+            ac_surface_zero_dcc_fields(&device->physical_device->rad_info, &image->planes[0].surface);
       }
 
       if (create_info.bo_metadata && !mod_info &&
diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index 084dca54d6af3..878540de502b0 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -406,7 +406,7 @@ static bool si_texture_discard_dcc(struct si_screen *sscreen, struct si_texture
       return false;
 
    /* Disable DCC. */
-   ac_surface_zero_dcc_fields(&tex->surface);
+   ac_surface_zero_dcc_fields(&sscreen->info, &tex->surface);
 
    /* Notify all contexts about the change. */
    p_atomic_inc(&sscreen->dirty_tex_counter);
-- 
GitLab


From cf8d05b3f1b41930adda895d83814641b2bf8b4b Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Sat, 18 Nov 2023 19:50:12 -0800
Subject: [PATCH 2/4] ac: add radeon_surf::has_user_modifier

radeon_surf::has_user_modifier is true if the modifier is selected by
the user rather than addrlib.  It is redundant right now but we will
need this to tell if the modifier is selected by the user or by addrlib.
---
 src/amd/common/ac_surface.c | 2 ++
 src/amd/common/ac_surface.h | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index abccb9f98dc89..aa4848fbb08b3 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -2615,6 +2615,8 @@ int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *inf
    if (r)
       return r;
 
+   surf->has_user_modifier = surf->modifier != DRM_FORMAT_MOD_INVALID;
+
    /* Determine the memory layout of multiple allocations in one buffer. */
    surf->total_size = surf->surf_size;
    surf->alignment_log2 = surf->surf_alignment_log2;
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index 0c865a4d828a4..82d21fa7dfb52 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -347,6 +347,8 @@ struct radeon_surf {
     * select tiling parameters instead.
     */
    uint64_t modifier;
+   /* True if the modifier is selected by user rather than addrlib. */
+   bool has_user_modifier;
    uint64_t flags;
 
    uint64_t surf_size;
-- 
GitLab


From 5b4c044e896f7ae9cad04e2eb9a810ebb2e312fe Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Sat, 18 Nov 2023 21:51:17 -0800
Subject: [PATCH 3/4] ac, radeonsi: check has_user_modifier in some places

We want to set radeon_surf::modifier to the effective modifier selected
by addrlib rather than leaving it at DRM_FORMAT_MOD_INVALID when
has_user_modifier is false in a following commit.  There are a few
places where we care whether the modifier is from the user or from
addrlib.
---
 src/amd/common/ac_surface.c               | 2 +-
 src/gallium/drivers/radeonsi/si_texture.c | 7 ++++---
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index aa4848fbb08b3..7b003e8e15bca 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -2828,7 +2828,7 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
    const uint32_t *desc = &metadata[2];
    uint64_t offset;
 
-   if (surf->modifier != DRM_FORMAT_MOD_INVALID)
+   if (surf->has_user_modifier)
       return true;
 
    if (info->gfx_level >= GFX9)
diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index 878540de502b0..826b9d5798915 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -397,7 +397,8 @@ static bool si_can_disable_dcc(struct si_texture *tex)
           tex->surface.meta_offset &&
           (!tex->buffer.b.is_shared ||
            !(tex->buffer.external_usage & PIPE_HANDLE_USAGE_FRAMEBUFFER_WRITE)) &&
-          !ac_modifier_has_dcc(tex->surface.modifier);
+          (!tex->surface.has_user_modifier ||
+           !ac_modifier_has_dcc(tex->surface.modifier));
 }
 
 static bool si_texture_discard_dcc(struct si_screen *sscreen, struct si_texture *tex)
@@ -595,7 +596,7 @@ static bool si_displayable_dcc_needs_explicit_flush(struct si_texture *tex)
 
    /* With modifiers and > 1 planes any applications will know that they
     * cannot do frontbuffer rendering with the texture. */
-   if (ac_surface_get_nplanes(&tex->surface) > 1)
+   if (tex->surface.has_user_modifier && ac_surface_get_nplanes(&tex->surface) > 1)
       return false;
 
    return tex->surface.is_displayable && tex->surface.meta_offset;
@@ -1649,7 +1650,7 @@ static struct pipe_resource *si_texture_from_winsys_buffer(struct si_screen *ssc
       next_plane = next_plane->next;
    }
 
-   unsigned nplanes = ac_surface_get_nplanes(&tex->surface);
+   unsigned nplanes = tex->surface.has_user_modifier ? ac_surface_get_nplanes(&tex->surface) : 1;
    unsigned plane = 1;
    while (next_plane) {
       struct si_auxiliary_texture *ptex = (struct si_auxiliary_texture *)next_plane;
-- 
GitLab


From 6f33056e921bf13e944b2065808634fab610b5f7 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Sat, 18 Nov 2023 23:49:33 -0800
Subject: [PATCH 4/4] ac: set radeon_surf::modifier to the effective modifier

When has_user_modifier is false, derive the effective modifier from the
tiling parameters selected by addrlib.

This does not affect radv because
VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT requires a valid modifier and
has_user_modifier is already true.

This affects radeonsi in non-trivial ways

 - si_resource_get_param will return the effective memory plane count
   for PIPE_RESOURCE_PARAM_NPLANES
 - si_resource_get_param will return the effective modifier for
   PIPE_RESOURCE_PARAM_MODIFIER
 - si_texture_get_handle will return the effective modifier

As a result, gbm_bo_get_plane_count and gbm_bo_get_modifier start
returning the effective plane counts and modifiers for BOs created with
gbm_bo_create.  This is also the behavior of all other hw gallium
drivers as far as I can tell.

This improves interop between gbm and radv.  radv requires a valid
modifier for dma-buf import.  But a modifier-aware client (e.g., chrome)
might not always allocate gbm bos with gbm_bo_create_with_modifiers.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/10076
---
 src/amd/common/ac_surface.c | 150 +++++++++++++++++++++++++++++++++++-
 src/amd/common/ac_surface.h |   2 +-
 2 files changed, 149 insertions(+), 3 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 7b003e8e15bca..3e57965bb3df7 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -2590,6 +2590,147 @@ static int gfx9_compute_surface(struct ac_addrlib *addrlib, const struct radeon_
    return 0;
 }
 
+static void ac_compute_surface_effective_modifier(const struct radeon_info *info,
+                                                  struct radeon_surf *surf)
+{
+   /* the modifier is user-specified */
+   if (surf->has_user_modifier)
+      return;
+
+   /* only GFX9+ color surfaces have modifier support */
+   if (info->gfx_level < GFX9 || (surf->flags & RADEON_SURF_Z_OR_SBUFFER))
+      goto invalid;
+
+   /* linear is easy */
+   if (surf->is_linear) {
+      surf->modifier = DRM_FORMAT_MOD_LINEAR;
+      return;
+   }
+
+   /* work out the tile version */
+   unsigned tile = surf->u.gfx9.swizzle_mode;
+   unsigned tile_version;
+   bool is_x;
+   switch (tile) {
+   case AMD_FMT_MOD_TILE_GFX9_64K_S:
+      if (info->gfx_level >= GFX11)
+         goto invalid;
+      tile_version = AMD_FMT_MOD_TILE_VER_GFX9;
+      is_x = false;
+      break;
+   case AMD_FMT_MOD_TILE_GFX9_64K_D:
+      tile_version = info->gfx_level >= GFX11 ?
+         AMD_FMT_MOD_TILE_VER_GFX11 : AMD_FMT_MOD_TILE_VER_GFX9;
+      is_x = false;
+      break;
+   case AMD_FMT_MOD_TILE_GFX9_64K_S_X:
+      if (info->gfx_level >= GFX11)
+         goto invalid;
+      tile_version = info->gfx_level >= GFX10 ?
+         AMD_FMT_MOD_TILE_VER_GFX10 : AMD_FMT_MOD_TILE_VER_GFX9;
+      is_x = true;
+      break;
+   case AMD_FMT_MOD_TILE_GFX9_64K_D_X:
+      if (info->gfx_level >= GFX10)
+         goto invalid;
+      tile_version = AMD_FMT_MOD_TILE_VER_GFX9;
+      is_x = true;
+      break;
+   case AMD_FMT_MOD_TILE_GFX9_64K_R_X:
+      switch (info->gfx_level) {
+      case GFX10:
+         tile_version = AMD_FMT_MOD_TILE_VER_GFX10;
+         break;
+      case GFX10_3:
+         tile_version = AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS;
+         break;
+      case GFX11:
+      case GFX11_5:
+         tile_version = AMD_FMT_MOD_TILE_VER_GFX11;
+         break;
+      default:
+         goto invalid;
+      }
+      is_x = true;
+      break;
+   case AMD_FMT_MOD_TILE_GFX11_256K_R_X:
+      if (info->gfx_level < GFX11)
+         goto invalid;
+      tile_version = AMD_FMT_MOD_TILE_VER_GFX11;
+      is_x = true;
+      break;
+   default:
+      goto invalid;
+   }
+
+   uint64_t modifier = AMD_FMT_MOD |
+                       AMD_FMT_MOD_SET(TILE_VERSION, tile_version) |
+                       AMD_FMT_MOD_SET(TILE, tile);
+
+   /* work out DCC */
+   if (surf->meta_offset) {
+      const struct gfx9_surf_meta_flags *dcc = &surf->u.gfx9.color.dcc;
+      const bool dcc_constant_encode = info->gfx_level >= GFX11 ?
+         false : info->has_dcc_constant_encode;
+
+      modifier |= AMD_FMT_MOD_SET(DCC, 1) |
+                  AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, dcc->independent_64B_blocks) |
+                  AMD_FMT_MOD_SET(DCC_INDEPENDENT_128B, dcc->independent_128B_blocks) |
+                  AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, dcc->max_compressed_block_size) |
+                  AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, dcc_constant_encode);
+
+      if (surf->display_dcc_offset || dcc->pipe_aligned) {
+         if (surf->display_dcc_offset)
+            modifier |= AMD_FMT_MOD_SET(DCC_RETILE, 1);
+         else
+            modifier |= AMD_FMT_MOD_SET(DCC_PIPE_ALIGN, 1);
+
+         if (info->gfx_level == GFX9) {
+            const unsigned rb = G_0098F8_NUM_RB_PER_SE(info->gb_addr_config) +
+                                G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config);
+            const unsigned pipe = G_0098F8_NUM_PIPES(info->gb_addr_config);
+
+            modifier |= AMD_FMT_MOD_SET(RB, rb) |
+                        AMD_FMT_MOD_SET(PIPE, pipe);
+         }
+      }
+   }
+
+   /* work out gpu differences */
+   if (is_x) {
+      unsigned pipe_xor_bits = 0;
+      unsigned bank_xor_bits = 0;
+      unsigned packers = 0;
+      switch (info->gfx_level) {
+      case GFX9:
+            pipe_xor_bits = MIN2(G_0098F8_NUM_PIPES(info->gb_addr_config) +
+                                 G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config), 8);
+            bank_xor_bits = MIN2(G_0098F8_NUM_BANKS(info->gb_addr_config), 8 - pipe_xor_bits);
+            break;
+      case GFX10:
+      case GFX10_3:
+      case GFX11:
+      case GFX11_5:
+            pipe_xor_bits = G_0098F8_NUM_PIPES(info->gb_addr_config);
+            if (info->gfx_level >= GFX10_3 && surf->micro_tile_mode == RADEON_MICRO_MODE_RENDER)
+               packers = G_0098F8_NUM_PKRS(info->gb_addr_config);
+            break;
+      default:
+            goto invalid;
+      }
+
+      modifier |= AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
+                  AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits) |
+                  AMD_FMT_MOD_SET(PACKERS, packers);
+   }
+
+   surf->modifier = modifier;
+   return;
+
+invalid:
+   surf->modifier = DRM_FORMAT_MOD_INVALID;
+}
+
 int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *info,
                        const struct ac_surf_config *config, enum radeon_surf_mode mode,
                        struct radeon_surf *surf)
@@ -2615,8 +2756,6 @@ int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *inf
    if (r)
       return r;
 
-   surf->has_user_modifier = surf->modifier != DRM_FORMAT_MOD_INVALID;
-
    /* Determine the memory layout of multiple allocations in one buffer. */
    surf->total_size = surf->surf_size;
    surf->alignment_log2 = surf->surf_alignment_log2;
@@ -2657,6 +2796,9 @@ int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *inf
       surf->alignment_log2 = MAX2(surf->alignment_log2, surf->meta_alignment_log2);
    }
 
+   surf->has_user_modifier = surf->modifier != DRM_FORMAT_MOD_INVALID;
+   ac_compute_surface_effective_modifier(info, surf);
+
    return 0;
 }
 
@@ -2672,6 +2814,8 @@ void ac_surface_zero_dcc_fields(const struct radeon_info *info, struct radeon_su
       surf->total_size = surf->surf_size;
       surf->alignment_log2 = surf->surf_alignment_log2;
    }
+
+   ac_compute_surface_effective_modifier(info, surf);
 }
 
 static unsigned eg_tile_split(unsigned tile_split)
@@ -2904,6 +3048,8 @@ bool ac_surface_apply_umd_metadata(const struct radeon_info *info, struct radeon
          assert(0);
          return false;
       }
+
+      ac_compute_surface_effective_modifier(info, surf);
    } else {
       /* Disable DCC. dcc_offset is always set by texture_from_handle
        * and must be cleared here.
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index 82d21fa7dfb52..5be844a543fd0 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -344,7 +344,7 @@ struct radeon_surf {
    uint8_t alignment_log2;
 
    /* DRM format modifier. Set to DRM_FORMAT_MOD_INVALID to have addrlib
-    * select tiling parameters instead.
+    * select tiling parameters and modifier instead.
     */
    uint64_t modifier;
    /* True if the modifier is selected by user rather than addrlib. */
-- 
GitLab

