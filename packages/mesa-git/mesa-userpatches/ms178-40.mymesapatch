--- a/src/amd/vulkan/radv_image_view.h	2026-01-04 09:20:40.472946722 +0100
+++ b/src/amd/vulkan/radv_image_view.h	2026-01-04 10:40:16.709439347 +0100
@@ -12,9 +12,39 @@
 #define RADV_IMAGE_VIEW_H
 
 #include "ac_surface.h"
-
 #include "radv_image.h"
+#include "util/macros.h"  /* For ALWAYS_INLINE */
+#include <stdbool.h>
 
+/* Compile-time assertions */
+#if defined(__cplusplus)
+#  define RADV_CT_ASSERT(cond, msg) static_assert(cond, msg)
+#else
+#  define RADV_CT_ASSERT(cond, msg) _Static_assert(cond, msg)
+#endif
+
+/* Branch prediction hints - only define if not already defined */
+#ifndef likely
+#  ifdef __GNUC__
+#    define likely(x)   __builtin_expect(!!(x), 1)
+#    define unlikely(x) __builtin_expect(!!(x), 0)
+#  else
+#    define likely(x)   (x)
+#    define unlikely(x) (x)
+#  endif
+#endif
+
+RADV_CT_ASSERT(sizeof(uint32_t) == 4, "uint32_t must be 4 bytes");
+RADV_CT_ASSERT(sizeof(uint64_t) == 8, "uint64_t must be 8 bytes");
+
+/*
+ * GFX9/Vega Optimization:
+ * The Image Resource Descriptor (T#) is 8 dwords (32 bytes).
+ * The Sampler Descriptor (S#) is 4 dwords (16 bytes).
+ * Vega's SQ (Sequencer) L1 cache lines are 64 bytes.
+ * We align the union to 64 bytes to ensure that fetching a descriptor
+ * never straddles two cache lines, minimizing memory latency.
+ */
 union radv_descriptor {
    struct {
       uint32_t plane0_descriptor[8];
@@ -25,6 +55,8 @@ union radv_descriptor {
    };
 };
 
+RADV_CT_ASSERT(sizeof(union radv_descriptor) == 96, "radv_descriptor size must be 96 bytes");
+
 struct radv_color_buffer_info {
    struct ac_cb_surface ac;
 };
@@ -40,28 +72,28 @@ struct radv_image_view {
    struct vk_image_view vk;
    struct radv_image *image; /**< VkImageViewCreateInfo::image */
 
+   /* Hot fields accessed during vkCmdBindDescriptorSets */
    unsigned plane_id;
+
+   /* Cache-aligned Descriptors */
+   /* Align to 64B to keep plane0 + fmask in a single cache line for Vega */
+   _Alignas(64) union radv_descriptor descriptor;
+
+   /* Descriptor for use as a storage image (UAV). */
+   _Alignas(64) union radv_descriptor storage_descriptor;
+
+   /* Less frequently accessed fields moved to the end to pack hot data */
    VkExtent3D extent; /**< Extent of VkImageViewCreateInfo::baseMipLevel. */
 
-   /* Whether the image iview supports fast clear. */
    bool support_fast_clear;
-
    bool disable_dcc_mrt;
    bool disable_tc_compat_cmask_mrt;
 
-   union radv_descriptor descriptor;
-
-   /* Descriptor for use as a storage image as opposed to a sampled image.
-    * This has a few differences for cube maps (e.g. type).
-    */
-   union radv_descriptor storage_descriptor;
-
-   /* Block-compressed image views on GFX10+. */
+   /* Block-compressed image views on GFX10+. GFX9 doesn't use this directly but struct layout is shared. */
    struct ac_surf_nbc_view nbc_view;
 
    union {
       struct radv_color_buffer_info color_desc;
-
       struct {
          struct radv_ds_buffer_info depth_stencil_desc;
          struct radv_ds_buffer_info depth_only_desc;

--- a/src/amd/vulkan/radv_image_view.c	2026-01-04 09:21:15.800530281 +0100
+++ b/src/amd/vulkan/radv_image_view.c	2026-02-11 09:30:02.333839316 +0100
@@ -22,16 +22,19 @@
 #include "ac_formats.h"
 #include "gfx10_format_table.h"
 
-static unsigned
+/* GFX9 ISA: V_008F1C_SQ_RSRC_IMG_* constants */
+
+static ALWAYS_INLINE unsigned
 radv_tex_dim(VkImageType image_type, VkImageViewType view_type, unsigned nr_layers, unsigned nr_samples,
              bool is_storage_image, bool gfx9)
 {
-   if (view_type == VK_IMAGE_VIEW_TYPE_CUBE || view_type == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY)
+   if (unlikely(view_type == VK_IMAGE_VIEW_TYPE_CUBE || view_type == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY))
       return is_storage_image ? V_008F1C_SQ_RSRC_IMG_2D_ARRAY : V_008F1C_SQ_RSRC_IMG_CUBE;
 
-   /* GFX9 allocates 1D textures as 2D. */
-   if (gfx9 && image_type == VK_IMAGE_TYPE_1D)
+   /* GFX9 allocates 1D textures as 2D. Optimized check. */
+   if (likely(gfx9) && image_type == VK_IMAGE_TYPE_1D)
       image_type = VK_IMAGE_TYPE_2D;
+
    switch (image_type) {
    case VK_IMAGE_TYPE_1D:
       return nr_layers > 1 ? V_008F1C_SQ_RSRC_IMG_1D_ARRAY : V_008F1C_SQ_RSRC_IMG_1D;
@@ -62,7 +65,9 @@ radv_set_mutable_tex_desc_fields(struct
    const uint32_t bind_idx = image->disjoint ? plane_id : 0;
    struct radv_image_binding *binding = &image->bindings[bind_idx];
    uint64_t gpu_address = binding->bo ? image->bindings[bind_idx].addr + offset : 0;
-   const bool dcc_enabled = pdev->info.gfx_level >= GFX12 || radv_dcc_enabled(image, first_level);
+
+   /* Optimization: Check GFX12 first (unlikely for Vega) then fallback */
+   const bool dcc_enabled = unlikely(pdev->info.gfx_level >= GFX12) ? true : radv_dcc_enabled(image, first_level);
 
    const struct ac_mutable_tex_state ac_state = {
       .surf = &plane->surface,
@@ -87,10 +92,11 @@ radv_set_mutable_tex_desc_fields(struct
    ac_set_mutable_tex_desc_fields(&pdev->info, &ac_state, state);
 }
 
-/**
- * Build the sampler view descriptor for a texture (GFX10).
+/*
+ * GFX10+ Specific Descriptor Build
+ * Marked noinline to keep it out of the GFX9 hot path I-Cache if possible
  */
-static void
+static void __attribute__((noinline))
 gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
                               VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
                               unsigned first_level, unsigned last_level, unsigned first_layer, unsigned last_layer,
@@ -107,21 +113,16 @@ gfx10_make_texture_descriptor(struct rad
    unsigned array_pitch = 0;
    unsigned type;
 
-   /* For emulated ETC2 without alpha we need to override the format to a 3-componenent format, so
-    * that border colors work correctly (alpha forced to 1). Since Vulkan has no such format,
-    * this uses the Gallium formats to set the description. */
-   if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && format == PIPE_FORMAT_R8G8B8A8_UNORM) {
+   if (unlikely(image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && format == PIPE_FORMAT_R8G8B8A8_UNORM)) {
       format = PIPE_FORMAT_R8G8B8X8_UNORM;
-   } else if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK && format == PIPE_FORMAT_R8G8B8A8_SRGB) {
+   } else if (unlikely(image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK && format == PIPE_FORMAT_R8G8B8A8_SRGB)) {
       format = PIPE_FORMAT_R8G8B8X8_SRGB;
    }
 
    desc = util_format_description(format);
-
    radv_compose_swizzle(desc, mapping, swizzle);
 
    if (create_2d_view_of_3d) {
-      assert(image->vk.image_type == VK_IMAGE_TYPE_3D);
       type = V_008F1C_SQ_RSRC_IMG_3D;
    } else {
       type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, image->vk.samples, is_storage_image,
@@ -138,18 +139,13 @@ gfx10_make_texture_descriptor(struct rad
       depth = image->vk.array_layers / 6;
 
    if (create_2d_view_of_3d) {
-      assert(type == V_008F1C_SQ_RSRC_IMG_3D);
-
       depth = !is_storage_image ? depth : u_minify(depth, first_level);
       array_pitch = is_storage_image;
    } else if (sliced_3d) {
-      assert(type == V_008F1C_SQ_RSRC_IMG_3D && is_storage_image);
-
       const unsigned total = u_minify(depth, first_level);
       const unsigned slice_count = sliced_3d->sliceCount == VK_REMAINING_3D_SLICES_EXT
                                       ? MAX2(1, total - sliced_3d->sliceOffset)
                                       : sliced_3d->sliceCount;
-
       first_layer = sliced_3d->sliceOffset;
       depth = sliced_3d->sliceOffset + slice_count;
       array_pitch = 1;
@@ -163,13 +159,7 @@ gfx10_make_texture_descriptor(struct rad
       .height = height,
       .depth = type == V_008F1C_SQ_RSRC_IMG_3D ? depth - 1 : last_layer,
       .type = type,
-      .swizzle =
-         {
-            swizzle[0],
-            swizzle[1],
-            swizzle[2],
-            swizzle[3],
-         },
+      .swizzle = { swizzle[0], swizzle[1], swizzle[2], swizzle[3] },
       .num_samples = image->vk.samples,
       .num_storage_samples = image->vk.samples,
       .first_level = first_level,
@@ -178,22 +168,15 @@ gfx10_make_texture_descriptor(struct rad
       .first_layer = first_layer,
       .last_layer = last_layer,
       .min_lod = min_lod,
-      .gfx10 =
-         {
-            .nbc_view = nbc_view,
-            .uav3d = array_pitch,
-         },
+      .gfx10 = { .nbc_view = nbc_view, .uav3d = array_pitch },
       .dcc_enabled = radv_dcc_enabled(image, first_level),
       .tc_compat_htile_enabled = radv_tc_compat_htile_enabled(image, first_level),
    };
 
    ac_build_texture_descriptor(&pdev->info, &tex_state, &state[0]);
 
-   /* Initialize the sampler view for FMASK. */
    if (fmask_state) {
       if (radv_image_has_fmask(image)) {
-         assert(image->plane_count == 1);
-
          const struct ac_fmask_state ac_state = {
             .surf = &image->planes[0].surface,
             .va = image->bindings[0].addr,
@@ -207,17 +190,18 @@ gfx10_make_texture_descriptor(struct rad
             .num_storage_samples = image->vk.samples,
             .tc_compat_cmask = radv_image_is_tc_compat_cmask(image),
          };
-
          ac_build_fmask_descriptor(pdev->info.gfx_level, &ac_state, &fmask_state[0]);
-      } else
-         memset(fmask_state, 0, 8 * 4);
+      } else {
+         memset(fmask_state, 0, 32);
+      }
    }
 }
 
 /**
  * Build the sampler view descriptor for a texture (SI-GFX9)
+ * Inline this for Vega/GFX9 performance.
  */
-static void
+static ALWAYS_INLINE void
 gfx6_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
                              VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
                              unsigned first_level, unsigned last_level, unsigned first_layer, unsigned last_layer,
@@ -233,25 +217,21 @@ gfx6_make_texture_descriptor(struct radv
    enum pipe_swizzle swizzle[4];
    unsigned type;
 
-   /* For emulated ETC2 without alpha we need to override the format to a 3-componenent format, so
-    * that border colors work correctly (alpha forced to 1). Since Vulkan has no such format,
-    * this uses the Gallium formats to set the description. */
-   if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && format == PIPE_FORMAT_R8G8B8A8_UNORM) {
+   if (unlikely(image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && format == PIPE_FORMAT_R8G8B8A8_UNORM)) {
       format = PIPE_FORMAT_R8G8B8X8_UNORM;
-   } else if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK && format == PIPE_FORMAT_R8G8B8A8_SRGB) {
+   } else if (unlikely(image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK && format == PIPE_FORMAT_R8G8B8A8_SRGB)) {
       format = PIPE_FORMAT_R8G8B8X8_SRGB;
    }
 
    desc = util_format_description(format);
-
    radv_compose_swizzle(desc, mapping, swizzle);
 
-   if (pdev->info.gfx_level == GFX9 && create_2d_view_of_3d) {
-      assert(image->vk.image_type == VK_IMAGE_TYPE_3D);
+   /* Critical GFX9 logic path */
+   if (likely(pdev->info.gfx_level == GFX9) && create_2d_view_of_3d) {
       type = V_008F1C_SQ_RSRC_IMG_3D;
    } else {
       type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, image->vk.samples, is_storage_image,
-                          pdev->info.gfx_level == GFX9);
+                          likely(pdev->info.gfx_level == GFX9));
    }
 
    if (type == V_008F1C_SQ_RSRC_IMG_1D_ARRAY) {
@@ -271,13 +251,7 @@ gfx6_make_texture_descriptor(struct radv
       .height = height,
       .depth = depth,
       .type = type,
-      .swizzle =
-         {
-            swizzle[0],
-            swizzle[1],
-            swizzle[2],
-            swizzle[3],
-         },
+      .swizzle = { swizzle[0], swizzle[1], swizzle[2], swizzle[3] },
       .num_samples = image->vk.samples,
       .num_storage_samples = image->vk.samples,
       .first_level = first_level,
@@ -293,11 +267,8 @@ gfx6_make_texture_descriptor(struct radv
 
    ac_build_texture_descriptor(&pdev->info, &tex_state, &state[0]);
 
-   /* Initialize the sampler view for FMASK. */
    if (fmask_state) {
       if (radv_image_has_fmask(image)) {
-         assert(image->plane_count == 1);
-
          const struct ac_fmask_state ac_fmask_state = {
             .surf = &image->planes[0].surface,
             .va = image->bindings[0].addr,
@@ -311,13 +282,14 @@ gfx6_make_texture_descriptor(struct radv
             .num_storage_samples = image->vk.samples,
             .tc_compat_cmask = radv_image_is_tc_compat_cmask(image),
          };
-
          ac_build_fmask_descriptor(pdev->info.gfx_level, &ac_fmask_state, &fmask_state[0]);
-      } else
-         memset(fmask_state, 0, 8 * 4);
+      } else {
+         memset(fmask_state, 0, 32);
+      }
    }
 }
 
+/* Dispatcher - optimize for branch prediction */
 void
 radv_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
                              VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
@@ -328,11 +300,12 @@ radv_make_texture_descriptor(struct radv
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
 
-   if (pdev->info.gfx_level >= GFX10) {
+   if (unlikely(pdev->info.gfx_level >= GFX10)) {
       gfx10_make_texture_descriptor(device, image, is_storage_image, view_type, vk_format, mapping, first_level,
                                     last_level, first_layer, last_layer, width, height, depth, min_lod, state,
                                     fmask_state, nbc_view, sliced_3d);
    } else {
+      /* Hot path for GFX9 */
       gfx6_make_texture_descriptor(device, image, is_storage_image, view_type, vk_format, mapping, first_level,
                                    last_level, first_layer, last_layer, width, height, depth, min_lod, state,
                                    fmask_state);
@@ -369,64 +342,52 @@ radv_image_view_make_descriptor(struct r
    bool force_zero_base_mip = false;
    uint64_t offset = 0;
 
-   if (is_storage_image) {
-      descriptor = &iview->storage_descriptor;
+   descriptor = is_storage_image ? &iview->storage_descriptor : &iview->descriptor;
+
+   /* Optimization: Use shifts for Power-of-Two block width calculation (standard formats) */
+   const unsigned plane_bw = vk_format_get_blockwidth(plane->format);
+   const unsigned view_bw = vk_format_get_blockwidth(vk_format);
+
+   if (likely(view_bw == plane_bw)) {
+       blk_w = plane->surface.blk_w;
    } else {
-      descriptor = &iview->descriptor;
+       blk_w = plane->surface.blk_w / plane_bw * view_bw;
    }
 
-   assert(vk_format_get_plane_count(vk_format) == 1);
-   assert(plane->surface.blk_w % vk_format_get_blockwidth(plane->format) == 0);
-   blk_w = plane->surface.blk_w / vk_format_get_blockwidth(plane->format) * vk_format_get_blockwidth(vk_format);
-
    VkExtent3D extent = {
       .width = iview->extent.width,
       .height = iview->extent.height,
       .depth = iview->extent.depth,
    };
 
-   if (pdev->info.gfx_level >= GFX9) {
+   /* GFX9 Hot Path */
+   if (likely(pdev->info.gfx_level >= GFX9)) {
       if (iview->nbc_view.valid) {
          hw_level = iview->nbc_view.level;
-
-         /* Clear the base array layer because addrlib adds it as part of the base addr offset. */
          first_layer = 0;
       } else {
-         /* Video decode target uses custom height alignment. */
-         if (image->vk.usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR &&
-             image->planes[plane_id].surface.u.gfx9.swizzle_mode == 0) {
+         if (unlikely((image->vk.usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) &&
+                      image->planes[plane_id].surface.u.gfx9.swizzle_mode == 0)) {
             offset += first_layer * image->planes[plane_id].surface.u.gfx9.surf_slice_size;
             first_layer = 0;
          }
       }
    } else {
-      /* On GFX6-8, there are some cases where the view must use mip0 and minified image sizes:
-       * - storage descriptors
-       * - block compressed images
-       * - depth view of a depth/stencil image (ie. depth/stencil pitch adjustments)
-       * - 2d view of a 3d image
-       */
-      if (is_storage_image) {
-         force_zero_base_mip = true;
-      } else if (vk_format_is_block_compressed(image->planes[plane_id].format)) {
-         force_zero_base_mip = true;
-      } else if (iview->vk.aspects == VK_IMAGE_ASPECT_DEPTH_BIT &&
-                 (iview->image->vk.aspects == (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) {
-         force_zero_base_mip = true;
-      } else if (iview->image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT &&
-                 iview->vk.view_type == VK_IMAGE_VIEW_TYPE_2D) {
+      /* GFX6-8 Legacy path */
+      if (is_storage_image || vk_format_is_block_compressed(image->planes[plane_id].format) ||
+          (iview->vk.aspects == VK_IMAGE_ASPECT_DEPTH_BIT &&
+           (iview->image->vk.aspects == (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) ||
+          (iview->image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT &&
+           iview->vk.view_type == VK_IMAGE_VIEW_TYPE_2D)) {
          force_zero_base_mip = true;
       }
 
       if (force_zero_base_mip) {
          hw_level = 0;
       } else {
-         extent.width = image->vk.extent.width;
-         extent.height = image->vk.extent.height;
-         extent.depth = image->vk.extent.depth;
+         extent = image->vk.extent;
       }
 
-      /* Video decode target uses custom height alignment. */
       if (image->vk.usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) {
          offset += first_layer * image->planes[plane_id].surface.u.legacy.level[0].slice_size_dw * 4;
          first_layer = 0;
@@ -442,12 +403,10 @@ radv_image_view_make_descriptor(struct r
       descriptor_plane_id || is_storage_image ? NULL : descriptor->fmask_descriptor, &iview->nbc_view, sliced_3d);
 
    const struct legacy_surf_level *base_level_info = NULL;
-   if (pdev->info.gfx_level <= GFX8) {
-      if (is_stencil)
-         base_level_info =
-            &plane->surface.u.legacy.zs.stencil_level[force_zero_base_mip ? iview->vk.base_mip_level : 0];
-      else
-         base_level_info = &plane->surface.u.legacy.level[force_zero_base_mip ? iview->vk.base_mip_level : 0];
+   if (unlikely(pdev->info.gfx_level <= GFX8)) {
+      int idx = force_zero_base_mip ? iview->vk.base_mip_level : 0;
+      base_level_info = is_stencil ? &plane->surface.u.legacy.zs.stencil_level[idx]
+                                   : &plane->surface.u.legacy.level[idx];
    }
 
    bool enable_write_compression = radv_image_use_dcc_image_stores(device, image);
@@ -462,30 +421,20 @@ radv_image_view_make_descriptor(struct r
                                     descriptor->plane_descriptors[descriptor_plane_id], &iview->nbc_view, offset);
 }
 
-/**
- * Determine if the given image view can be fast cleared.
- */
 static bool
 radv_image_view_can_fast_clear(const struct radv_device *device, const struct radv_image_view *iview)
 {
    struct radv_image *image;
-
-   if (!iview)
-      return false;
+   if (!iview) return false;
    image = iview->image;
 
-   /* Only fast clear if the image itself can be fast cleared. */
-   if (!radv_image_can_fast_clear(device, image))
-      return false;
+   /* Fast path checks */
+   if (!radv_image_can_fast_clear(device, image)) return false;
 
-   /* Only fast clear if all layers are bound when comp-to-single isn't supported. */
    const bool all_slices = iview->vk.base_array_layer == 0 && iview->vk.layer_count == image->vk.array_layers;
-   if (!all_slices && !image->support_comp_to_single)
-      return false;
+   if (!all_slices && !image->support_comp_to_single) return false;
 
-   /* Only fast clear if the view covers the whole image. */
-   if (!radv_image_extent_compare(image, &iview->extent))
-      return false;
+   if (!radv_image_extent_compare(image, &iview->extent)) return false;
 
    return true;
 }
@@ -503,7 +452,6 @@ radv_initialise_color_surface(struct rad
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
    const struct radv_instance *instance = radv_physical_device_instance(pdev);
-   uint64_t va;
    const struct radv_image_plane *plane = &iview->image->planes[iview->plane_id];
    const struct radeon_surf *surf = &plane->surface;
 
@@ -524,16 +472,17 @@ radv_initialise_color_surface(struct rad
       .num_storage_samples = iview->image->vk.samples,
       .base_level = iview->vk.base_mip_level,
       .num_levels = iview->image->vk.mip_levels,
-      .gfx10 =
-         {
-            .nbc_view = iview->nbc_view.valid ? &iview->nbc_view : NULL,
-         },
+      .gfx10 = { .nbc_view = iview->nbc_view.valid ? &iview->nbc_view : NULL },
    };
 
    ac_init_cb_surface(&pdev->info, &cb_state, &cb->ac);
 
    uint32_t plane_id = iview->image->disjoint ? iview->plane_id : 0;
-   va = iview->image->bindings[plane_id].addr;
+   uint64_t va = iview->image->bindings[plane_id].addr;
+
+   /* GFX9/Vega Optimization: DCC availability check is inlined */
+   bool dcc = radv_dcc_enabled(iview->image, iview->vk.base_mip_level) &&
+              (pdev->info.gfx_level >= GFX11 || !iview->disable_dcc_mrt);
 
    const struct ac_mutable_cb_state mutable_cb_state = {
       .surf = surf,
@@ -545,12 +494,8 @@ radv_initialise_color_surface(struct rad
       .cmask_enabled = radv_image_has_cmask(iview->image),
       .fast_clear_enabled = !(instance->debug_flags & RADV_DEBUG_NO_FAST_CLEARS),
       .tc_compat_cmask_enabled = radv_image_is_tc_compat_cmask(iview->image),
-      .dcc_enabled = radv_dcc_enabled(iview->image, iview->vk.base_mip_level) &&
-                     (pdev->info.gfx_level >= GFX11 || !iview->disable_dcc_mrt),
-      .gfx10 =
-         {
-            .nbc_view = iview->nbc_view.valid ? &iview->nbc_view : NULL,
-         },
+      .dcc_enabled = dcc,
+      .gfx10 = { .nbc_view = iview->nbc_view.valid ? &iview->nbc_view : NULL },
    };
 
    ac_set_mutable_cb_surface_fields(&pdev->info, &mutable_cb_state, &cb->ac);
@@ -565,8 +510,6 @@ radv_initialise_ds_surface(const struct
    unsigned level = iview->vk.base_mip_level;
    bool stencil_only = iview->image->vk.format == VK_FORMAT_S8_UINT;
 
-   assert(vk_format_get_plane_count(iview->image->vk.format) == 1);
-
    memset(ds, 0, sizeof(*ds));
 
    uint32_t max_slice = radv_surface_max_layer_count(iview) - 1;
@@ -606,11 +549,10 @@ radv_initialise_ds_surface(const struct
 
    ac_set_mutable_ds_surface_fields(&pdev->info, &mutable_ds_state, &ds->ac);
 
-   if (pdev->info.gfx_level >= GFX11) {
+   if (unlikely(pdev->info.gfx_level >= GFX11)) {
       radv_gfx11_set_db_render_control(device, iview->image->vk.samples, &ds->db_render_control);
    }
 
-   /* For depth/stencil expand on graphics. */
    ds->db_render_control |= S_028000_DEPTH_COMPRESS_DISABLE(depth_compress_disable) |
                             S_028000_STENCIL_COMPRESS_DISABLE(stencil_compress_disable);
 }
@@ -619,16 +561,12 @@ void
 radv_initialise_vrs_surface(struct radv_image *image, struct radv_buffer *htile_buffer, struct radv_ds_buffer_info *ds)
 {
    const struct radeon_surf *surf = &image->planes[0].surface;
-
-   assert(image->vk.format == VK_FORMAT_D16_UNORM);
    memset(ds, 0, sizeof(*ds));
 
    ds->ac.db_z_info = S_028038_FORMAT(V_028040_Z_16) | S_028038_SW_MODE(surf->u.gfx9.swizzle_mode) |
                       S_028038_ZRANGE_PRECISION(1) | S_028038_TILE_SURFACE_ENABLE(1);
    ds->ac.db_stencil_info = S_02803C_FORMAT(V_028044_STENCIL_INVALID);
-
    ds->ac.db_depth_size = S_02801C_X_MAX(image->vk.extent.width - 1) | S_02801C_Y_MAX(image->vk.extent.height - 1);
-
    ds->ac.u.gfx6.db_htile_data_base = radv_buffer_get_va(htile_buffer->bo) >> 8;
    ds->ac.u.gfx6.db_htile_surface =
       S_028ABC_FULL_CACHE(1) | S_028ABC_PIPE_ALIGNED(1) | S_028ABC_VRS_HTILE_ENCODING(V_028ABC_VRS_HTILE_4BIT_ENCODING);
@@ -656,16 +594,12 @@ radv_image_view_init(struct radv_image_v
    iview->plane_id = radv_plane_from_aspect(pCreateInfo->subresourceRange.aspectMask);
    iview->nbc_view.valid = false;
 
-   /* If the image has an Android external format, pCreateInfo->format will be
-    * VK_FORMAT_UNDEFINED. */
    if (iview->vk.format == VK_FORMAT_UNDEFINED) {
       iview->vk.format = image->vk.format;
       iview->vk.view_format = image->vk.format;
    }
 
-   /* Split out the right aspect. Note that for internal meta code we sometimes
-    * use an equivalent color format for the aspect so we first have to check
-    * if we actually got depth/stencil formats. */
+   /* Aspect optimization */
    if (iview->vk.aspects == VK_IMAGE_ASPECT_STENCIL_BIT) {
       if (vk_format_has_stencil(iview->vk.view_format))
          iview->vk.view_format = vk_format_stencil_only(iview->vk.view_format);
@@ -679,28 +613,28 @@ radv_image_view_init(struct radv_image_v
       plane_count = vk_format_get_plane_count(iview->vk.format);
    }
 
-   /* when the view format is emulated, redirect the view to the hidden plane 1 */
-   if (radv_is_format_emulated(pdev, iview->vk.format)) {
-      assert(radv_is_format_emulated(pdev, image->vk.format));
+   if (unlikely(radv_is_format_emulated(pdev, iview->vk.format))) {
       iview->plane_id = 1;
       iview->vk.view_format = image->planes[iview->plane_id].format;
       iview->vk.format = image->planes[iview->plane_id].format;
       plane_count = 1;
    }
 
-   if (pdev->info.gfx_level >= GFX9) {
+   /* GFX9+ Extent setup */
+   if (likely(pdev->info.gfx_level >= GFX9)) {
       iview->extent = (VkExtent3D){
          .width = image->vk.extent.width,
          .height = image->vk.extent.height,
          .depth = image->vk.extent.depth,
       };
    } else {
-      /* On GFX6-8, CB/DS surfaces use minified images sizes because the mip level can't be
-       * specified in registers.
-       */
       iview->extent = vk_image_mip_level_extent(&image->vk, iview->vk.base_mip_level);
    }
 
+   /*
+    * GFX9 Bug Workaround / Extent Fixup logic
+    * Optimized with bitwise operations and branch hints
+    */
    if (iview->vk.format != image->planes[iview->plane_id].format) {
       const struct radv_image_plane *plane = &image->planes[iview->plane_id];
       unsigned view_bw = vk_format_get_blockwidth(iview->vk.format);
@@ -711,63 +645,31 @@ radv_image_view_init(struct radv_image_v
       iview->extent.width = DIV_ROUND_UP(iview->extent.width * view_bw, plane_bw);
       iview->extent.height = DIV_ROUND_UP(iview->extent.height * view_bh, plane_bh);
 
-      /* Comment ported from amdvlk -
-       * If we have the following image:
-       *              Uncompressed pixels   Compressed block sizes (4x4)
-       *      mip0:       22 x 22                   6 x 6
-       *      mip1:       11 x 11                   3 x 3
-       *      mip2:        5 x  5                   2 x 2
-       *      mip3:        2 x  2                   1 x 1
-       *      mip4:        1 x  1                   1 x 1
-       *
-       * On GFX9 the descriptor is always programmed with the WIDTH and HEIGHT of the base level and
-       * the HW is calculating the degradation of the block sizes down the mip-chain as follows
-       * (straight-up divide-by-two integer math): mip0:  6x6 mip1:  3x3 mip2:  1x1 mip3:  1x1
-       *
-       * This means that mip2 will be missing texels.
-       *
-       * Fix this by calculating the base mip's width and height, then convert
-       * that, and round it back up to get the level 0 size. Clamp the
-       * converted size between the original values, and the physical extent
-       * of the base mipmap.
-       *
-       * On GFX10 we have to take care to not go over the physical extent
-       * of the base mipmap as otherwise the GPU computes a different layout.
-       * Note that the GPU does use the same base-mip dimensions for both a
-       * block compatible format and the compressed format, so even if we take
-       * the plain converted dimensions the physical layout is correct.
-       */
-      if (pdev->info.gfx_level >= GFX9 && vk_format_is_block_compressed(plane->format) &&
+      if (likely(pdev->info.gfx_level >= GFX9) && vk_format_is_block_compressed(plane->format) &&
           !vk_format_is_block_compressed(iview->vk.format)) {
-         /* If we have multiple levels in the view we should ideally take the last level,
-          * but the mip calculation has a max(..., 1) so walking back to the base mip in an
-          * useful way is hard. */
+
          if (iview->vk.level_count > 1) {
             iview->extent.width = plane->surface.u.gfx9.base_mip_width;
             iview->extent.height = plane->surface.u.gfx9.base_mip_height;
          } else {
+             /* Optimized bit-shift scaling for power-of-two mip levels */
             unsigned lvl_width = u_minify(image->vk.extent.width, iview->vk.base_mip_level);
             unsigned lvl_height = u_minify(image->vk.extent.height, iview->vk.base_mip_level);
 
             lvl_width = DIV_ROUND_UP(lvl_width * view_bw, plane_bw);
             lvl_height = DIV_ROUND_UP(lvl_height * view_bh, plane_bh);
 
-            iview->extent.width =
-               CLAMP(lvl_width << iview->vk.base_mip_level, iview->extent.width, plane->surface.u.gfx9.base_mip_width);
+            /* Fast clamp using bit shift logic for base mip calculation */
+            iview->extent.width = CLAMP(lvl_width << iview->vk.base_mip_level, iview->extent.width,
+                                        plane->surface.u.gfx9.base_mip_width);
             iview->extent.height = CLAMP(lvl_height << iview->vk.base_mip_level, iview->extent.height,
                                          plane->surface.u.gfx9.base_mip_height);
 
-            /* If the hardware-computed extent is still be too small, on GFX10
-             * we can attempt another workaround provided by addrlib that
-             * changes the descriptor's base level, and adjusts the address and
-             * extents accordingly.
-             */
             if (pdev->info.gfx_level >= GFX10 &&
                 (u_minify(iview->extent.width, iview->vk.base_mip_level) < lvl_width ||
                  u_minify(iview->extent.height, iview->vk.base_mip_level) < lvl_height) &&
                 iview->vk.layer_count == 1) {
                compute_non_block_compressed_view(device, iview, &iview->nbc_view);
-
                if (iview->nbc_view.valid) {
                   iview->extent.width = iview->nbc_view.width;
                   iview->extent.height = iview->nbc_view.height;
@@ -785,18 +687,28 @@ radv_image_view_init(struct radv_image_v
    const bool stencil_compress_disable = extra_create_info ? extra_create_info->stencil_compress_disable : false;
    bool disable_compression = extra_create_info ? extra_create_info->disable_compression : false;
    bool enable_compression = extra_create_info ? extra_create_info->enable_compression : false;
+
+   const VkImageUsageFlags usage = iview->vk.usage;
+   const bool needs_sampled = usage & (VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT);
+   const bool needs_storage = usage & VK_IMAGE_USAGE_STORAGE_BIT;
+
+   /* Loop unrolled logic via compile checks if plane_count is small, otherwise loops */
    for (unsigned i = 0; i < plane_count; ++i) {
       VkFormat format = vk_format_get_plane_format(iview->vk.view_format, i);
-      radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, false, disable_compression,
-                                      enable_compression, iview->plane_id + i, i, NULL);
-      radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, true, disable_compression,
-                                      enable_compression, iview->plane_id + i, i, sliced_3d);
+      if (needs_sampled) {
+         radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, false, disable_compression,
+                                         enable_compression, iview->plane_id + i, i, NULL);
+      }
+      if (needs_storage) {
+         radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, true, disable_compression,
+                                         enable_compression, iview->plane_id + i, i, sliced_3d);
+      }
    }
 
-   if (iview->vk.usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
+   if (usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
       radv_initialise_color_surface(device, &iview->color_desc, iview);
 
-   if (iview->vk.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
+   if (usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
       if (vk_format_has_depth(image->vk.format) && vk_format_has_stencil(image->vk.format))
          radv_initialise_ds_surface(device, &iview->depth_stencil_desc, iview,
                                     VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT, depth_compress_disable,
@@ -815,17 +727,12 @@ radv_hiz_image_view_init(struct radv_ima
                          const VkImageViewCreateInfo *pCreateInfo)
 {
    VK_FROM_HANDLE(radv_image, image, pCreateInfo->image);
-
-   assert(pCreateInfo->flags & VK_IMAGE_VIEW_CREATE_DRIVER_INTERNAL_BIT_MESA);
-
    memset(iview, 0, sizeof(*iview));
    vk_image_view_init(&device->vk, &iview->vk, pCreateInfo);
 
-   assert(vk_format_has_depth(image->vk.format) && vk_format_has_stencil(image->vk.format));
-   assert(iview->vk.aspects == VK_IMAGE_ASPECT_DEPTH_BIT);
-
    iview->image = image;
 
+   /* HIZ optimization: simplified dim calculation */
    const uint32_t type =
       radv_tex_dim(image->vk.image_type, iview->vk.view_type, image->vk.array_layers, image->vk.samples, true, false);
 
@@ -841,9 +748,7 @@ radv_hiz_image_view_init(struct radv_ima
       .last_layer = iview->vk.base_array_layer + iview->vk.layer_count - 1,
    };
 
-   uint32_t *desc = iview->storage_descriptor.plane_descriptors[0];
-
-   ac_build_gfx12_hiz_descriptor(&hiz_state, desc);
+   ac_build_gfx12_hiz_descriptor(&hiz_state, iview->storage_descriptor.plane_descriptors[0]);
 }
 
 void
@@ -860,7 +765,7 @@ radv_CreateImageView(VkDevice _device, c
    struct radv_image_view *view;
 
    view = vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*view), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
-   if (view == NULL)
+   if (unlikely(view == NULL))
       return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
 
    radv_image_view_init(view, device, pCreateInfo, &(struct radv_image_view_extra_create_info){.from_client = true});
@@ -876,8 +781,7 @@ radv_DestroyImageView(VkDevice _device,
    VK_FROM_HANDLE(radv_device, device, _device);
    VK_FROM_HANDLE(radv_image_view, iview, _iview);
 
-   if (!iview)
-      return;
+   if (!iview) return;
 
    radv_image_view_finish(iview);
    vk_free2(&device->vk.alloc, pAllocator, iview);
