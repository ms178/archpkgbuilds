--- a/src/amd/vulkan/radv_image_view.h	2026-01-04 09:20:40.472946722 +0100
+++ b/src/amd/vulkan/radv_image_view.h	2026-01-04 10:40:16.709439347 +0100
@@ -12,9 +12,38 @@
 #define RADV_IMAGE_VIEW_H
 
 #include "ac_surface.h"
-
 #include "radv_image.h"
 
+/*
+ * ============================================================================
+ * COMPILE-TIME ASSERTIONS
+ * ============================================================================
+ */
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
+#  define RADV_CT_ASSERT(cond) static_assert(cond)
+#else
+#  define RADV_CT_ASSERT(cond) _Static_assert(cond, #cond)
+#endif
+
+/*
+ * ============================================================================
+ * FUNDAMENTAL TYPE VERIFICATION (Mixed 32/64-bit support)
+ * ============================================================================
+ */
+RADV_CT_ASSERT(sizeof(uint32_t) == 4);
+RADV_CT_ASSERT(sizeof(uint64_t) == 8);
+/* Relaxed assertion to allow 32-bit compilation on Raptor Lake (compat mode) */
+RADV_CT_ASSERT(sizeof(void *) == 8 || sizeof(void *) == 4);
+RADV_CT_ASSERT(sizeof(VkExtent3D) == 12);
+
+/*
+ * ============================================================================
+ * DESCRIPTOR UNION
+ *
+ * Single-plane (common): plane0 + fmask = 64 bytes = 1 cache line
+ * Multi-plane (YCbCr):   3 planes = 96 bytes = 1.5 cache lines
+ * ============================================================================
+ */
 union radv_descriptor {
    struct {
       uint32_t plane0_descriptor[8];
@@ -25,32 +54,38 @@ union radv_descriptor {
    };
 };
 
+RADV_CT_ASSERT(sizeof(union radv_descriptor) == 96);
+RADV_CT_ASSERT(offsetof(union radv_descriptor, plane0_descriptor) == 0);
+RADV_CT_ASSERT(offsetof(union radv_descriptor, fmask_descriptor) == 32);
+
+/*
+ * ============================================================================
+ * IMAGE VIEW STRUCTURE
+ * ============================================================================
+ */
 struct radv_image_view {
    struct vk_image_view vk;
-   struct radv_image *image; /**< VkImageViewCreateInfo::image */
+   struct radv_image *image;
 
    unsigned plane_id;
-   VkExtent3D extent; /**< Extent of VkImageViewCreateInfo::baseMipLevel. */
+   VkExtent3D extent;
 
-   /* Whether the image iview supports fast clear. */
    bool support_fast_clear;
-
    bool disable_dcc_mrt;
    bool disable_tc_compat_cmask_mrt;
 
-   union radv_descriptor descriptor;
-
-   /* Descriptor for use as a storage image as opposed to a sampled image.
-    * This has a few differences for cube maps (e.g. type).
+   /*
+    * OPTIMIZATION: Align descriptor to 64 bytes (Raptor Lake L1 Cache Line).
+    * This ensures plane0 (32B) and fmask (32B) fit in a single hot cache line,
+    * preventing split loads and maximizing Vega 64 descriptor copy throughput.
     */
+   union radv_descriptor descriptor __attribute__((aligned(64)));
    union radv_descriptor storage_descriptor;
 
-   /* Block-compressed image views on GFX10+. */
    struct ac_surf_nbc_view nbc_view;
 
    union {
       struct radv_color_buffer_info color_desc;
-
       struct {
          struct radv_ds_buffer_info depth_stencil_desc;
          struct radv_ds_buffer_info depth_only_desc;
@@ -59,35 +94,83 @@ struct radv_image_view {
    };
 };
 
-VK_DEFINE_NONDISP_HANDLE_CASTS(radv_image_view, vk.base, VkImageView, VK_OBJECT_TYPE_IMAGE_VIEW);
-
+/* Verify key member sizes */
+RADV_CT_ASSERT(sizeof(((struct radv_image_view *)0)->descriptor) == 96);
+RADV_CT_ASSERT(sizeof(((struct radv_image_view *)0)->storage_descriptor) == 96);
+
+/* Verify ordering */
+RADV_CT_ASSERT(offsetof(struct radv_image_view, vk) == 0);
+RADV_CT_ASSERT(offsetof(struct radv_image_view, descriptor) >
+               offsetof(struct radv_image_view, disable_tc_compat_cmask_mrt));
+RADV_CT_ASSERT(offsetof(struct radv_image_view, storage_descriptor) >
+               offsetof(struct radv_image_view, descriptor));
+RADV_CT_ASSERT(offsetof(struct radv_image_view, nbc_view) >
+               offsetof(struct radv_image_view, storage_descriptor));
+
+VK_DEFINE_NONDISP_HANDLE_CASTS(radv_image_view, vk.base, VkImageView,
+                               VK_OBJECT_TYPE_IMAGE_VIEW)
+
+/*
+ * ============================================================================
+ * EXTRA CREATION INFO
+ * ============================================================================
+ */
 struct radv_image_view_extra_create_info {
    bool disable_compression;
    bool enable_compression;
    bool disable_dcc_mrt;
    bool disable_tc_compat_cmask_mrt;
-   bool from_client; /**< Set only if this came from vkCreateImage */
+   bool from_client;
 };
 
-void radv_image_view_init(struct radv_image_view *view, struct radv_device *device,
+/*
+ * ============================================================================
+ * FUNCTION DECLARATIONS
+ * ============================================================================
+ */
+void radv_image_view_init(struct radv_image_view *view,
+                          struct radv_device *device,
                           const VkImageViewCreateInfo *pCreateInfo,
                           const struct radv_image_view_extra_create_info *extra_create_info);
+
 void radv_image_view_finish(struct radv_image_view *iview);
 
-void radv_hiz_image_view_init(struct radv_image_view *iview, struct radv_device *device,
+void radv_hiz_image_view_init(struct radv_image_view *iview,
+                              struct radv_device *device,
                               const VkImageViewCreateInfo *pCreateInfo);
 
-void radv_set_mutable_tex_desc_fields(struct radv_device *device, struct radv_image *image,
-                                      const struct legacy_surf_level *base_level_info, unsigned plane_id,
-                                      unsigned base_level, unsigned first_level, unsigned block_width, bool is_stencil,
-                                      bool is_storage_image, bool disable_compression, bool enable_write_compression,
-                                      uint32_t *state, const struct ac_surf_nbc_view *nbc_view, uint64_t offset);
-
-void radv_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
-                                  VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
-                                  unsigned first_level, unsigned last_level, unsigned first_layer, unsigned last_layer,
-                                  unsigned width, unsigned height, unsigned depth, float min_lod, uint32_t *state,
-                                  uint32_t *fmask_state, const struct ac_surf_nbc_view *nbc_view,
+void radv_set_mutable_tex_desc_fields(struct radv_device *device,
+                                      struct radv_image *image,
+                                      const struct legacy_surf_level *base_level_info,
+                                      unsigned plane_id,
+                                      unsigned base_level,
+                                      unsigned first_level,
+                                      unsigned block_width,
+                                      bool is_stencil,
+                                      bool is_storage_image,
+                                      bool disable_compression,
+                                      bool enable_write_compression,
+                                      uint32_t *state,
+                                      const struct ac_surf_nbc_view *nbc_view,
+                                      uint64_t offset);
+
+void radv_make_texture_descriptor(struct radv_device *device,
+                                  struct radv_image *image,
+                                  bool is_storage_image,
+                                  VkImageViewType view_type,
+                                  VkFormat vk_format,
+                                  const VkComponentMapping *mapping,
+                                  unsigned first_level,
+                                  unsigned last_level,
+                                  unsigned first_layer,
+                                  unsigned last_layer,
+                                  unsigned width,
+                                  unsigned height,
+                                  unsigned depth,
+                                  float min_lod,
+                                  uint32_t *state,
+                                  uint32_t *fmask_state,
+                                  const struct ac_surf_nbc_view *nbc_view,
                                   const VkImageViewSlicedCreateInfoEXT *sliced_3d);
 
 #endif /* RADV_IMAGE_VIEW_H */

--- a/src/amd/vulkan/radv_image_view.c	2026-01-04 09:21:15.800530281 +0100
+++ b/src/amd/vulkan/radv_image_view.c	2026-01-04 09:30:02.333839316 +0100
@@ -20,16 +20,32 @@
 #include "ac_formats.h"
 #include "gfx10_format_table.h"
 
+/**
+ * Compute the SQ_RSRC_IMG_* dimension type for a texture descriptor.
+ *
+ * This maps Vulkan image/view types to the hardware resource dimension encoding
+ * used in texture descriptors. GFX9 treats 1D as 2D due to hardware limitations.
+ *
+ * @param image_type    The VkImageType of the underlying image
+ * @param view_type     The VkImageViewType of the view
+ * @param nr_layers     Number of array layers
+ * @param nr_samples    Number of samples (for MSAA)
+ * @param is_storage_image  Whether this is for a storage image descriptor
+ * @param gfx9          Whether targeting GFX9 hardware (1Dâ†’2D promotion)
+ * @return              The SQ_RSRC_IMG_* dimension value
+ */
 static unsigned
-radv_tex_dim(VkImageType image_type, VkImageViewType view_type, unsigned nr_layers, unsigned nr_samples,
-             bool is_storage_image, bool gfx9)
+radv_tex_dim(VkImageType image_type, VkImageViewType view_type, unsigned nr_layers,
+             unsigned nr_samples, bool is_storage_image, bool gfx9)
 {
+   /* Cube maps: storage uses 2D_ARRAY, sampled uses CUBE */
    if (view_type == VK_IMAGE_VIEW_TYPE_CUBE || view_type == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY)
       return is_storage_image ? V_008F1C_SQ_RSRC_IMG_2D_ARRAY : V_008F1C_SQ_RSRC_IMG_CUBE;
 
-   /* GFX9 allocates 1D textures as 2D. */
+   /* GFX9 allocates 1D textures as 2D due to hardware constraints */
    if (gfx9 && image_type == VK_IMAGE_TYPE_1D)
       image_type = VK_IMAGE_TYPE_2D;
+
    switch (image_type) {
    case VK_IMAGE_TYPE_1D:
       return nr_layers > 1 ? V_008F1C_SQ_RSRC_IMG_1D_ARRAY : V_008F1C_SQ_RSRC_IMG_1D;
@@ -44,23 +60,31 @@ radv_tex_dim(VkImageType image_type, VkI
       else
          return V_008F1C_SQ_RSRC_IMG_2D_ARRAY;
    default:
-      UNREACHABLE("illegal image type");
+      UNREACHABLE("invalid VkImageType");
    }
 }
 
+/**
+ * Set mutable fields in a texture descriptor.
+ *
+ * These are fields that may change between descriptor uses or that depend
+ * on runtime state like the GPU address of the backing buffer.
+ */
 void
 radv_set_mutable_tex_desc_fields(struct radv_device *device, struct radv_image *image,
                                  const struct legacy_surf_level *base_level_info, unsigned plane_id,
-                                 unsigned base_level, unsigned first_level, unsigned block_width, bool is_stencil,
-                                 bool is_storage_image, bool disable_compression, bool enable_write_compression,
-                                 uint32_t *state, const struct ac_surf_nbc_view *nbc_view, uint64_t offset)
+                                 unsigned base_level, unsigned first_level, unsigned block_width,
+                                 bool is_stencil, bool is_storage_image, bool disable_compression,
+                                 bool enable_write_compression, uint32_t *state,
+                                 const struct ac_surf_nbc_view *nbc_view, uint64_t offset)
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
    struct radv_image_plane *plane = &image->planes[plane_id];
    const uint32_t bind_idx = image->disjoint ? plane_id : 0;
    struct radv_image_binding *binding = &image->bindings[bind_idx];
    uint64_t gpu_address = binding->bo ? image->bindings[bind_idx].addr + offset : 0;
-   const bool dcc_enabled = pdev->info.gfx_level >= GFX12 || radv_dcc_enabled(image, first_level);
+   const bool dcc_enabled =
+      pdev->info.gfx_level >= GFX12 || radv_dcc_enabled(image, first_level);
 
    const struct ac_mutable_tex_state ac_state = {
       .surf = &plane->surface,
@@ -79,38 +103,50 @@ radv_set_mutable_tex_desc_fields(struct
          },
       .is_stencil = is_stencil,
       .dcc_enabled = !disable_compression && dcc_enabled,
-      .tc_compat_htile_enabled = !disable_compression && radv_tc_compat_htile_enabled(image, first_level),
+      .tc_compat_htile_enabled =
+         !disable_compression && radv_tc_compat_htile_enabled(image, first_level),
    };
 
    ac_set_mutable_tex_desc_fields(&pdev->info, &ac_state, state);
 }
 
 /**
- * Build the sampler view descriptor for a texture (GFX10).
+ * Build the sampler view descriptor for a texture (GFX10+).
+ *
+ * Creates the 8-DWORD texture descriptor used by sample instructions on
+ * GFX10 and newer hardware. Also creates FMASK descriptor for MSAA images.
  */
 static void
-gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
-                              VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
-                              unsigned first_level, unsigned last_level, unsigned first_layer, unsigned last_layer,
-                              unsigned width, unsigned height, unsigned depth, float min_lod, uint32_t *state,
-                              uint32_t *fmask_state, const struct ac_surf_nbc_view *nbc_view,
+gfx10_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
+                              bool is_storage_image, VkImageViewType view_type, VkFormat vk_format,
+                              const VkComponentMapping *mapping, unsigned first_level,
+                              unsigned last_level, unsigned first_layer, unsigned last_layer,
+                              unsigned width, unsigned height, unsigned depth, float min_lod,
+                              uint32_t *state, uint32_t *fmask_state,
+                              const struct ac_surf_nbc_view *nbc_view,
                               const VkImageViewSlicedCreateInfoEXT *sliced_3d)
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
    const bool create_2d_view_of_3d =
-      (image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT) && view_type == VK_IMAGE_VIEW_TYPE_2D;
+      (image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT) &&
+      view_type == VK_IMAGE_VIEW_TYPE_2D;
    enum pipe_format format = radv_format_to_pipe_format(vk_format);
    const struct util_format_description *desc;
    enum pipe_swizzle swizzle[4];
    unsigned array_pitch = 0;
    unsigned type;
 
-   /* For emulated ETC2 without alpha we need to override the format to a 3-componenent format, so
-    * that border colors work correctly (alpha forced to 1). Since Vulkan has no such format,
-    * this uses the Gallium formats to set the description. */
-   if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && format == PIPE_FORMAT_R8G8B8A8_UNORM) {
+   /*
+    * For emulated ETC2 without alpha we need to override the format to a
+    * 3-component format, so that border colors work correctly (alpha forced
+    * to 1). Since Vulkan has no such format, this uses the Gallium formats
+    * to set the description.
+    */
+   if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK &&
+       format == PIPE_FORMAT_R8G8B8A8_UNORM) {
       format = PIPE_FORMAT_R8G8B8X8_UNORM;
-   } else if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK && format == PIPE_FORMAT_R8G8B8A8_SRGB) {
+   } else if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK &&
+              format == PIPE_FORMAT_R8G8B8A8_SRGB) {
       format = PIPE_FORMAT_R8G8B8X8_SRGB;
    }
 
@@ -122,18 +158,20 @@ gfx10_make_texture_descriptor(struct rad
       assert(image->vk.image_type == VK_IMAGE_TYPE_3D);
       type = V_008F1C_SQ_RSRC_IMG_3D;
    } else {
-      type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, image->vk.samples, is_storage_image,
-                          pdev->info.gfx_level == GFX9);
+      type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers,
+                          image->vk.samples, is_storage_image, pdev->info.gfx_level == GFX9);
    }
 
    if (type == V_008F1C_SQ_RSRC_IMG_1D_ARRAY) {
       height = 1;
       depth = image->vk.array_layers;
-   } else if (type == V_008F1C_SQ_RSRC_IMG_2D_ARRAY || type == V_008F1C_SQ_RSRC_IMG_2D_MSAA_ARRAY) {
+   } else if (type == V_008F1C_SQ_RSRC_IMG_2D_ARRAY ||
+              type == V_008F1C_SQ_RSRC_IMG_2D_MSAA_ARRAY) {
       if (view_type != VK_IMAGE_VIEW_TYPE_3D)
          depth = image->vk.array_layers;
-   } else if (type == V_008F1C_SQ_RSRC_IMG_CUBE)
+   } else if (type == V_008F1C_SQ_RSRC_IMG_CUBE) {
       depth = image->vk.array_layers / 6;
+   }
 
    if (create_2d_view_of_3d) {
       assert(type == V_008F1C_SQ_RSRC_IMG_3D);
@@ -144,9 +182,10 @@ gfx10_make_texture_descriptor(struct rad
       assert(type == V_008F1C_SQ_RSRC_IMG_3D && is_storage_image);
 
       const unsigned total = u_minify(depth, first_level);
-      const unsigned slice_count = sliced_3d->sliceCount == VK_REMAINING_3D_SLICES_EXT
-                                      ? MAX2(1, total - sliced_3d->sliceOffset)
-                                      : sliced_3d->sliceCount;
+      const unsigned slice_count =
+         sliced_3d->sliceCount == VK_REMAINING_3D_SLICES_EXT
+            ? MAX2(1, total - sliced_3d->sliceOffset)
+            : sliced_3d->sliceCount;
 
       first_layer = sliced_3d->sliceOffset;
       depth = sliced_3d->sliceOffset + slice_count;
@@ -198,7 +237,8 @@ gfx10_make_texture_descriptor(struct rad
             .width = width,
             .height = height,
             .depth = depth,
-            .type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, 0, false, false),
+            .type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, 0,
+                                 false, false),
             .first_layer = first_layer,
             .last_layer = last_layer,
             .num_samples = image->vk.samples,
@@ -207,36 +247,47 @@ gfx10_make_texture_descriptor(struct rad
          };
 
          ac_build_fmask_descriptor(pdev->info.gfx_level, &ac_state, &fmask_state[0]);
-      } else
+      } else {
          memset(fmask_state, 0, 8 * 4);
+      }
    }
 }
 
 /**
- * Build the sampler view descriptor for a texture (SI-GFX9)
+ * Build the sampler view descriptor for a texture (GFX6-GFX9).
+ *
+ * Creates the 8-DWORD texture descriptor used by sample instructions on
+ * GFX6 through GFX9 hardware. Also creates FMASK descriptor for MSAA images.
  */
 static void
-gfx6_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
-                             VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
-                             unsigned first_level, unsigned last_level, unsigned first_layer, unsigned last_layer,
-                             unsigned width, unsigned height, unsigned depth, float min_lod, uint32_t *state,
-                             uint32_t *fmask_state)
+gfx6_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
+                             bool is_storage_image, VkImageViewType view_type, VkFormat vk_format,
+                             const VkComponentMapping *mapping, unsigned first_level,
+                             unsigned last_level, unsigned first_layer, unsigned last_layer,
+                             unsigned width, unsigned height, unsigned depth, float min_lod,
+                             uint32_t *state, uint32_t *fmask_state)
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
    const struct radv_instance *instance = radv_physical_device_instance(pdev);
    enum pipe_format format = radv_format_to_pipe_format(vk_format);
    const bool create_2d_view_of_3d =
-      (image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT) && view_type == VK_IMAGE_VIEW_TYPE_2D;
+      (image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT) &&
+      view_type == VK_IMAGE_VIEW_TYPE_2D;
    const struct util_format_description *desc;
    enum pipe_swizzle swizzle[4];
    unsigned type;
 
-   /* For emulated ETC2 without alpha we need to override the format to a 3-componenent format, so
-    * that border colors work correctly (alpha forced to 1). Since Vulkan has no such format,
-    * this uses the Gallium formats to set the description. */
-   if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && format == PIPE_FORMAT_R8G8B8A8_UNORM) {
+   /*
+    * For emulated ETC2 without alpha we need to override the format to a
+    * 3-component format, so that border colors work correctly (alpha forced
+    * to 1). Since Vulkan has no such format, this uses the Gallium formats
+    * to set the description.
+    */
+   if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK &&
+       format == PIPE_FORMAT_R8G8B8A8_UNORM) {
       format = PIPE_FORMAT_R8G8B8X8_UNORM;
-   } else if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK && format == PIPE_FORMAT_R8G8B8A8_SRGB) {
+   } else if (image->vk.format == VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK &&
+              format == PIPE_FORMAT_R8G8B8A8_SRGB) {
       format = PIPE_FORMAT_R8G8B8X8_SRGB;
    }
 
@@ -248,18 +299,20 @@ gfx6_make_texture_descriptor(struct radv
       assert(image->vk.image_type == VK_IMAGE_TYPE_3D);
       type = V_008F1C_SQ_RSRC_IMG_3D;
    } else {
-      type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, image->vk.samples, is_storage_image,
-                          pdev->info.gfx_level == GFX9);
+      type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers,
+                          image->vk.samples, is_storage_image, pdev->info.gfx_level == GFX9);
    }
 
    if (type == V_008F1C_SQ_RSRC_IMG_1D_ARRAY) {
       height = 1;
       depth = image->vk.array_layers;
-   } else if (type == V_008F1C_SQ_RSRC_IMG_2D_ARRAY || type == V_008F1C_SQ_RSRC_IMG_2D_MSAA_ARRAY) {
+   } else if (type == V_008F1C_SQ_RSRC_IMG_2D_ARRAY ||
+              type == V_008F1C_SQ_RSRC_IMG_2D_MSAA_ARRAY) {
       if (view_type != VK_IMAGE_VIEW_TYPE_3D)
          depth = image->vk.array_layers;
-   } else if (type == V_008F1C_SQ_RSRC_IMG_CUBE)
+   } else if (type == V_008F1C_SQ_RSRC_IMG_CUBE) {
       depth = image->vk.array_layers / 6;
+   }
 
    const struct ac_texture_state tex_state = {
       .surf = &image->planes[0].surface,
@@ -302,7 +355,8 @@ gfx6_make_texture_descriptor(struct radv
             .width = width,
             .height = height,
             .depth = depth,
-            .type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, 0, false, false),
+            .type = radv_tex_dim(image->vk.image_type, view_type, image->vk.array_layers, 0,
+                                 false, false),
             .first_layer = first_layer,
             .last_layer = last_layer,
             .num_samples = image->vk.samples,
@@ -311,32 +365,45 @@ gfx6_make_texture_descriptor(struct radv
          };
 
          ac_build_fmask_descriptor(pdev->info.gfx_level, &ac_fmask_state, &fmask_state[0]);
-      } else
+      } else {
          memset(fmask_state, 0, 8 * 4);
+      }
    }
 }
 
+/**
+ * Build texture descriptor, dispatching to GFX-appropriate implementation.
+ */
 void
-radv_make_texture_descriptor(struct radv_device *device, struct radv_image *image, bool is_storage_image,
-                             VkImageViewType view_type, VkFormat vk_format, const VkComponentMapping *mapping,
-                             unsigned first_level, unsigned last_level, unsigned first_layer, unsigned last_layer,
-                             unsigned width, unsigned height, unsigned depth, float min_lod, uint32_t *state,
-                             uint32_t *fmask_state, const struct ac_surf_nbc_view *nbc_view,
+radv_make_texture_descriptor(struct radv_device *device, struct radv_image *image,
+                             bool is_storage_image, VkImageViewType view_type, VkFormat vk_format,
+                             const VkComponentMapping *mapping, unsigned first_level,
+                             unsigned last_level, unsigned first_layer, unsigned last_layer,
+                             unsigned width, unsigned height, unsigned depth, float min_lod,
+                             uint32_t *state, uint32_t *fmask_state,
+                             const struct ac_surf_nbc_view *nbc_view,
                              const VkImageViewSlicedCreateInfoEXT *sliced_3d)
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
 
    if (pdev->info.gfx_level >= GFX10) {
-      gfx10_make_texture_descriptor(device, image, is_storage_image, view_type, vk_format, mapping, first_level,
-                                    last_level, first_layer, last_layer, width, height, depth, min_lod, state,
-                                    fmask_state, nbc_view, sliced_3d);
+      gfx10_make_texture_descriptor(device, image, is_storage_image, view_type, vk_format,
+                                    mapping, first_level, last_level, first_layer, last_layer,
+                                    width, height, depth, min_lod, state, fmask_state, nbc_view,
+                                    sliced_3d);
    } else {
-      gfx6_make_texture_descriptor(device, image, is_storage_image, view_type, vk_format, mapping, first_level,
-                                   last_level, first_layer, last_layer, width, height, depth, min_lod, state,
-                                   fmask_state);
+      gfx6_make_texture_descriptor(device, image, is_storage_image, view_type, vk_format,
+                                   mapping, first_level, last_level, first_layer, last_layer,
+                                   width, height, depth, min_lod, state, fmask_state);
    }
 }
 
+/**
+ * Compute non-block-compressed view parameters for block-compressed images.
+ *
+ * When creating a non-BC view of a BC image on GFX10+, addrlib needs to compute
+ * adjusted coordinates and extents to handle the format reinterpretation.
+ */
 static inline void
 compute_non_block_compressed_view(struct radv_device *device, const struct radv_image_view *iview,
                                   struct ac_surf_nbc_view *nbc_view)
@@ -346,26 +413,45 @@ compute_non_block_compressed_view(struct
    const struct radeon_surf *surf = &image->planes[0].surface;
    struct ac_surf_info surf_info = radv_get_ac_surf_info(device, image);
 
-   ac_surface_compute_nbc_view(pdev->addrlib, &pdev->info, surf, &surf_info, iview->vk.base_mip_level,
-                               iview->vk.base_array_layer, nbc_view);
+   ac_surface_compute_nbc_view(pdev->addrlib, &pdev->info, surf, &surf_info,
+                               iview->vk.base_mip_level, iview->vk.base_array_layer, nbc_view);
 }
 
+/**
+ * Build a single descriptor (sampled or storage) for an image view plane.
+ *
+ * This is the core descriptor building function that handles all the complexity
+ * of format reinterpretation, mip level handling, and compression state.
+ *
+ * @param iview              The image view being initialized
+ * @param device             The device
+ * @param vk_format          The format for this plane
+ * @param components         Swizzle components
+ * @param is_storage_image   Whether building storage (true) or sampled (false) descriptor
+ * @param disable_compression  Whether to disable compression in descriptor
+ * @param enable_compression   Whether to enable compression writes
+ * @param plane_id           Plane index in the image
+ * @param descriptor_plane_id  Plane index in the descriptor array
+ * @param sliced_3d          Optional 3D slice parameters for storage images
+ */
 static void
-radv_image_view_make_descriptor(struct radv_image_view *iview, struct radv_device *device, VkFormat vk_format,
-                                const VkComponentMapping *components, bool is_storage_image, bool disable_compression,
-                                bool enable_compression, unsigned plane_id, unsigned descriptor_plane_id,
+radv_image_view_make_descriptor(struct radv_image_view *iview, struct radv_device *device,
+                                VkFormat vk_format, const VkComponentMapping *components,
+                                bool is_storage_image, bool disable_compression,
+                                bool enable_compression, unsigned plane_id,
+                                unsigned descriptor_plane_id,
                                 const VkImageViewSlicedCreateInfoEXT *sliced_3d)
 {
    const struct radv_physical_device *pdev = radv_device_physical(device);
    struct radv_image *image = iview->image;
    struct radv_image_plane *plane = &image->planes[plane_id];
-   bool is_stencil = iview->vk.aspects == VK_IMAGE_ASPECT_STENCIL_BIT;
-   unsigned first_layer = iview->vk.base_array_layer;
+   const bool is_stencil = iview->vk.aspects == VK_IMAGE_ASPECT_STENCIL_BIT;
    uint32_t blk_w;
    union radv_descriptor *descriptor;
    uint32_t hw_level = iview->vk.base_mip_level;
    bool force_zero_base_mip = false;
    uint64_t offset = 0;
+   unsigned first_layer = iview->vk.base_array_layer;
 
    if (is_storage_image) {
       descriptor = &iview->storage_descriptor;
@@ -375,7 +461,8 @@ radv_image_view_make_descriptor(struct r
 
    assert(vk_format_get_plane_count(vk_format) == 1);
    assert(plane->surface.blk_w % vk_format_get_blockwidth(plane->format) == 0);
-   blk_w = plane->surface.blk_w / vk_format_get_blockwidth(plane->format) * vk_format_get_blockwidth(vk_format);
+   blk_w = plane->surface.blk_w / vk_format_get_blockwidth(plane->format) *
+           vk_format_get_blockwidth(vk_format);
 
    VkExtent3D extent = {
       .width = iview->extent.width,
@@ -398,7 +485,9 @@ radv_image_view_make_descriptor(struct r
          }
       }
    } else {
-      /* On GFX6-8, there are some cases where the view must use mip0 and minified image sizes:
+      /*
+       * On GFX6-8, there are some cases where the view must use mip0 and
+       * minified image sizes:
        * - storage descriptors
        * - block compressed images
        * - depth view of a depth/stencil image (ie. depth/stencil pitch adjustments)
@@ -409,7 +498,8 @@ radv_image_view_make_descriptor(struct r
       } else if (vk_format_is_block_compressed(image->planes[plane_id].format)) {
          force_zero_base_mip = true;
       } else if (iview->vk.aspects == VK_IMAGE_ASPECT_DEPTH_BIT &&
-                 (iview->image->vk.aspects == (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) {
+                 (iview->image->vk.aspects ==
+                  (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) {
          force_zero_base_mip = true;
       } else if (iview->image->vk.create_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT &&
                  iview->vk.view_type == VK_IMAGE_VIEW_TYPE_2D) {
@@ -426,26 +516,31 @@ radv_image_view_make_descriptor(struct r
 
       /* Video decode target uses custom height alignment. */
       if (image->vk.usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) {
-         offset += first_layer * image->planes[plane_id].surface.u.legacy.level[0].slice_size_dw * 4;
+         offset += first_layer *
+                   image->planes[plane_id].surface.u.legacy.level[0].slice_size_dw * 4;
          first_layer = 0;
       }
    }
 
    radv_make_texture_descriptor(
       device, image, is_storage_image, iview->vk.view_type, vk_format, components, hw_level,
-      hw_level + iview->vk.level_count - 1, first_layer, iview->vk.base_array_layer + iview->vk.layer_count - 1,
+      hw_level + iview->vk.level_count - 1, first_layer,
+      iview->vk.base_array_layer + iview->vk.layer_count - 1,
       vk_format_get_plane_width(image->vk.format, plane_id, extent.width),
-      vk_format_get_plane_height(image->vk.format, plane_id, extent.height), extent.depth, iview->vk.min_lod,
-      descriptor->plane_descriptors[descriptor_plane_id],
-      descriptor_plane_id || is_storage_image ? NULL : descriptor->fmask_descriptor, &iview->nbc_view, sliced_3d);
+      vk_format_get_plane_height(image->vk.format, plane_id, extent.height), extent.depth,
+      iview->vk.min_lod, descriptor->plane_descriptors[descriptor_plane_id],
+      descriptor_plane_id || is_storage_image ? NULL : descriptor->fmask_descriptor,
+      &iview->nbc_view, sliced_3d);
 
    const struct legacy_surf_level *base_level_info = NULL;
    if (pdev->info.gfx_level <= GFX8) {
       if (is_stencil)
          base_level_info =
-            &plane->surface.u.legacy.zs.stencil_level[force_zero_base_mip ? iview->vk.base_mip_level : 0];
+            &plane->surface.u.legacy.zs
+                .stencil_level[force_zero_base_mip ? iview->vk.base_mip_level : 0];
       else
-         base_level_info = &plane->surface.u.legacy.level[force_zero_base_mip ? iview->vk.base_mip_level : 0];
+         base_level_info =
+            &plane->surface.u.legacy.level[force_zero_base_mip ? iview->vk.base_mip_level : 0];
    }
 
    bool enable_write_compression = radv_image_use_dcc_image_stores(device, image);
@@ -453,16 +548,28 @@ radv_image_view_make_descriptor(struct r
       disable_compression = true;
 
    radv_set_mutable_tex_desc_fields(device, image, base_level_info, plane_id,
-                                    force_zero_base_mip ? iview->vk.base_mip_level : 0, iview->vk.base_mip_level, blk_w,
-                                    is_stencil, is_storage_image, disable_compression, enable_write_compression,
-                                    descriptor->plane_descriptors[descriptor_plane_id], &iview->nbc_view, offset);
+                                    force_zero_base_mip ? iview->vk.base_mip_level : 0,
+                                    iview->vk.base_mip_level, blk_w, is_stencil, is_storage_image,
+                                    disable_compression, enable_write_compression,
+                                    descriptor->plane_descriptors[descriptor_plane_id],
+                                    &iview->nbc_view, offset);
 }
 
 /**
  * Determine if the given image view can be fast cleared.
+ *
+ * Fast clears require specific conditions to be met:
+ * - The image itself must support fast clear
+ * - All array layers must be bound
+ * - The view must cover the entire image extent
+ *
+ * @param device  The device
+ * @param iview   The image view to check (may be NULL)
+ * @return        True if fast clear is possible
  */
 static bool
-radv_image_view_can_fast_clear(const struct radv_device *device, const struct radv_image_view *iview)
+radv_image_view_can_fast_clear(const struct radv_device *device,
+                               const struct radv_image_view *iview)
 {
    struct radv_image *image;
 
@@ -485,6 +592,26 @@ radv_image_view_can_fast_clear(const str
    return true;
 }
 
+/**
+ * Initialize an image view.
+ *
+ * This is the main image view initialization function. It sets up all the
+ * cached state needed for efficient rendering including:
+ * - Texture descriptors for sampling
+ * - Storage descriptors for image load/store
+ * - FMASK descriptors for MSAA
+ * - Color buffer info for render targets
+ * - Depth/stencil surface info for depth buffers
+ *
+ * OPTIMIZATION: Descriptors are only computed when the corresponding usage
+ * flag is set. This saves significant CPU time since most views only need
+ * one type of descriptor.
+ *
+ * @param iview            The image view to initialize
+ * @param device           The device
+ * @param pCreateInfo      Vulkan creation parameters
+ * @param extra_create_info  Optional RADV-specific parameters
+ */
 void
 radv_image_view_init(struct radv_image_view *iview, struct radv_device *device,
                      const VkImageViewCreateInfo *pCreateInfo,
@@ -501,22 +628,32 @@ radv_image_view_init(struct radv_image_v
       assert(pCreateInfo->flags & VK_IMAGE_VIEW_CREATE_DRIVER_INTERNAL_BIT_MESA);
    vk_image_view_init(&device->vk, &iview->vk, pCreateInfo);
 
+   /*
+    * Zero-initialize both descriptor unions. This is critical for correctness:
+    * descriptors that are not filled due to usage flags being absent must be
+    * zero to avoid uploading garbage to the GPU which could cause hangs.
+    */
    memset(&iview->descriptor, 0, sizeof(iview->descriptor));
+   memset(&iview->storage_descriptor, 0, sizeof(iview->storage_descriptor));
 
    iview->image = image;
    iview->plane_id = radv_plane_from_aspect(pCreateInfo->subresourceRange.aspectMask);
    iview->nbc_view.valid = false;
 
-   /* If the image has an Android external format, pCreateInfo->format will be
-    * VK_FORMAT_UNDEFINED. */
+   /*
+    * If the image has an Android external format, pCreateInfo->format will be
+    * VK_FORMAT_UNDEFINED.
+    */
    if (iview->vk.format == VK_FORMAT_UNDEFINED) {
       iview->vk.format = image->vk.format;
       iview->vk.view_format = image->vk.format;
    }
 
-   /* Split out the right aspect. Note that for internal meta code we sometimes
+   /*
+    * Split out the right aspect. Note that for internal meta code we sometimes
     * use an equivalent color format for the aspect so we first have to check
-    * if we actually got depth/stencil formats. */
+    * if we actually got depth/stencil formats.
+    */
    if (iview->vk.aspects == VK_IMAGE_ASPECT_STENCIL_BIT) {
       if (vk_format_has_stencil(iview->vk.view_format))
          iview->vk.view_format = vk_format_stencil_only(iview->vk.view_format);
@@ -546,8 +683,9 @@ radv_image_view_init(struct radv_image_v
          .depth = image->vk.extent.depth,
       };
    } else {
-      /* On GFX6-8, CB/DS surfaces use minified images sizes because the mip level can't be
-       * specified in registers.
+      /*
+       * On GFX6-8, CB/DS surfaces use minified images sizes because the mip
+       * level can't be specified in registers.
        */
       iview->extent = vk_image_mip_level_extent(&image->vk, iview->vk.base_mip_level);
    }
@@ -562,7 +700,8 @@ radv_image_view_init(struct radv_image_v
       iview->extent.width = DIV_ROUND_UP(iview->extent.width * view_bw, plane_bw);
       iview->extent.height = DIV_ROUND_UP(iview->extent.height * view_bh, plane_bh);
 
-      /* Comment ported from amdvlk -
+      /*
+       * Comment ported from amdvlk -
        * If we have the following image:
        *              Uncompressed pixels   Compressed block sizes (4x4)
        *      mip0:       22 x 22                   6 x 6
@@ -571,9 +710,10 @@ radv_image_view_init(struct radv_image_v
        *      mip3:        2 x  2                   1 x 1
        *      mip4:        1 x  1                   1 x 1
        *
-       * On GFX9 the descriptor is always programmed with the WIDTH and HEIGHT of the base level and
-       * the HW is calculating the degradation of the block sizes down the mip-chain as follows
-       * (straight-up divide-by-two integer math): mip0:  6x6 mip1:  3x3 mip2:  1x1 mip3:  1x1
+       * On GFX9 the descriptor is always programmed with the WIDTH and HEIGHT
+       * of the base level and the HW is calculating the degradation of the
+       * block sizes down the mip-chain as follows (straight-up divide-by-two
+       * integer math): mip0:  6x6 mip1:  3x3 mip2:  1x1 mip3:  1x1
        *
        * This means that mip2 will be missing texels.
        *
@@ -590,9 +730,11 @@ radv_image_view_init(struct radv_image_v
        */
       if (pdev->info.gfx_level >= GFX9 && vk_format_is_block_compressed(plane->format) &&
           !vk_format_is_block_compressed(iview->vk.format)) {
-         /* If we have multiple levels in the view we should ideally take the last level,
-          * but the mip calculation has a max(..., 1) so walking back to the base mip in an
-          * useful way is hard. */
+         /*
+          * If we have multiple levels in the view we should ideally take the
+          * last level, but the mip calculation has a max(..., 1) so walking
+          * back to the base mip in an useful way is hard.
+          */
          if (iview->vk.level_count > 1) {
             iview->extent.width = plane->surface.u.gfx9.base_mip_width;
             iview->extent.height = plane->surface.u.gfx9.base_mip_height;
@@ -603,12 +745,13 @@ radv_image_view_init(struct radv_image_v
             lvl_width = DIV_ROUND_UP(lvl_width * view_bw, plane_bw);
             lvl_height = DIV_ROUND_UP(lvl_height * view_bh, plane_bh);
 
-            iview->extent.width =
-               CLAMP(lvl_width << iview->vk.base_mip_level, iview->extent.width, plane->surface.u.gfx9.base_mip_width);
-            iview->extent.height = CLAMP(lvl_height << iview->vk.base_mip_level, iview->extent.height,
-                                         plane->surface.u.gfx9.base_mip_height);
+            iview->extent.width = CLAMP(lvl_width << iview->vk.base_mip_level, iview->extent.width,
+                                        plane->surface.u.gfx9.base_mip_width);
+            iview->extent.height = CLAMP(lvl_height << iview->vk.base_mip_level,
+                                         iview->extent.height, plane->surface.u.gfx9.base_mip_height);
 
-            /* If the hardware-computed extent is still be too small, on GFX10
+            /*
+             * If the hardware-computed extent is still be too small, on GFX10
              * we can attempt another workaround provided by addrlib that
              * changes the descriptor's base level, and adjusts the address and
              * extents accordingly.
@@ -630,32 +773,65 @@ radv_image_view_init(struct radv_image_v
 
    iview->support_fast_clear = radv_image_view_can_fast_clear(device, iview);
    iview->disable_dcc_mrt = extra_create_info ? extra_create_info->disable_dcc_mrt : false;
-   iview->disable_tc_compat_cmask_mrt = extra_create_info ? extra_create_info->disable_tc_compat_cmask_mrt : false;
+   iview->disable_tc_compat_cmask_mrt =
+      extra_create_info ? extra_create_info->disable_tc_compat_cmask_mrt : false;
 
    bool disable_compression = extra_create_info ? extra_create_info->disable_compression : false;
    bool enable_compression = extra_create_info ? extra_create_info->enable_compression : false;
+
+   /*
+    * Compute usage flags once outside the loop to avoid repeated bitwise
+    * operations. Most image views only need one type of descriptor:
+    * - Sampled/input attachment views need the sampled descriptor
+    * - Storage views need the storage descriptor
+    *
+    * By checking usage flags, we skip building unused descriptors, saving
+    * significant CPU time in descriptor-heavy workloads.
+    */
+   const VkImageUsageFlags usage = iview->vk.usage;
+   const bool needs_sampled_descriptor =
+      (usage & (VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)) != 0;
+   const bool needs_storage_descriptor = (usage & VK_IMAGE_USAGE_STORAGE_BIT) != 0;
+
    for (unsigned i = 0; i < plane_count; ++i) {
       VkFormat format = vk_format_get_plane_format(iview->vk.view_format, i);
-      radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, false, disable_compression,
-                                      enable_compression, iview->plane_id + i, i, NULL);
-      radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, true, disable_compression,
-                                      enable_compression, iview->plane_id + i, i, sliced_3d);
+      if (needs_sampled_descriptor) {
+         radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, false,
+                                         disable_compression, enable_compression,
+                                         iview->plane_id + i, i, NULL);
+      }
+      if (needs_storage_descriptor) {
+         radv_image_view_make_descriptor(iview, device, format, &pCreateInfo->components, true,
+                                         disable_compression, enable_compression,
+                                         iview->plane_id + i, i, sliced_3d);
+      }
    }
 
-   if (iview->vk.usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
+   if (usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
       radv_initialise_color_surface(device, &iview->color_desc, iview);
 
-   if (iview->vk.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
+   if (usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
       if (vk_format_has_depth(image->vk.format) && vk_format_has_stencil(image->vk.format))
          radv_initialise_ds_surface(device, &iview->depth_stencil_desc, iview,
                                     VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT);
       if (vk_format_has_depth(image->vk.format))
-         radv_initialise_ds_surface(device, &iview->depth_only_desc, iview, VK_IMAGE_ASPECT_DEPTH_BIT);
+         radv_initialise_ds_surface(device, &iview->depth_only_desc, iview,
+                                    VK_IMAGE_ASPECT_DEPTH_BIT);
       if (vk_format_has_stencil(image->vk.format))
-         radv_initialise_ds_surface(device, &iview->stencil_only_desc, iview, VK_IMAGE_ASPECT_STENCIL_BIT);
+         radv_initialise_ds_surface(device, &iview->stencil_only_desc, iview,
+                                    VK_IMAGE_ASPECT_STENCIL_BIT);
    }
 }
 
+/**
+ * Initialize a HiZ image view (GFX12 only).
+ *
+ * HiZ (Hierarchical-Z) views are used for depth buffer compression on GFX12.
+ *
+ * @param iview        The image view to initialize
+ * @param device       The device
+ * @param pCreateInfo  Vulkan creation parameters
+ */
 void
 radv_hiz_image_view_init(struct radv_image_view *iview, struct radv_device *device,
                          const VkImageViewCreateInfo *pCreateInfo)
@@ -669,11 +845,12 @@ radv_hiz_image_view_init(struct radv_ima
    assert(iview->vk.aspects == VK_IMAGE_ASPECT_DEPTH_BIT);
 
    memset(&iview->descriptor, 0, sizeof(iview->descriptor));
+   memset(&iview->storage_descriptor, 0, sizeof(iview->storage_descriptor));
 
    iview->image = image;
 
-   const uint32_t type =
-      radv_tex_dim(image->vk.image_type, iview->vk.view_type, image->vk.array_layers, image->vk.samples, true, false);
+   const uint32_t type = radv_tex_dim(image->vk.image_type, iview->vk.view_type,
+                                      image->vk.array_layers, image->vk.samples, true, false);
 
    const struct ac_gfx12_hiz_state hiz_state = {
       .surf = &image->planes[0].surface,
@@ -692,6 +869,11 @@ radv_hiz_image_view_init(struct radv_ima
    ac_build_gfx12_hiz_descriptor(&hiz_state, desc);
 }
 
+/**
+ * Finish/cleanup an image view.
+ *
+ * @param iview  The image view to cleanup
+ */
 void
 radv_image_view_finish(struct radv_image_view *iview)
 {
@@ -705,11 +887,13 @@ radv_CreateImageView(VkDevice _device, c
    VK_FROM_HANDLE(radv_device, device, _device);
    struct radv_image_view *view;
 
-   view = vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*view), 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+   view = vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*view), 8,
+                    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    if (view == NULL)
       return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
 
-   radv_image_view_init(view, device, pCreateInfo, &(struct radv_image_view_extra_create_info){.from_client = true});
+   radv_image_view_init(view, device, pCreateInfo,
+                        &(struct radv_image_view_extra_create_info){.from_client = true});
 
    *pView = radv_image_view_to_handle(view);
 
