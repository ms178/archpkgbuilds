From 179e37e7f9fcb306526e170d1cb98c2d0f30e03d Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 08:59:12 +0300
Subject: [PATCH 01/31] amd: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/amd/common/ac_debug.h       | 2 +-
 src/amd/common/ac_perfcounter.h | 7 ++++---
 src/amd/common/ac_rgp.h         | 2 +-
 src/amd/vpelib/inc/vpe_types.h  | 6 +++---
 4 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/src/amd/common/ac_debug.h b/src/amd/common/ac_debug.h
index 377c10e133eab..13fe2058dc2e2 100644
--- a/src/amd/common/ac_debug.h
+++ b/src/amd/common/ac_debug.h
@@ -88,8 +88,8 @@ struct ac_ib_parser {
    FILE *f;
    uint32_t *ib;
    unsigned num_dw;
-   const int *trace_ids;
    unsigned trace_id_count;
+   const int *trace_ids;
    enum amd_gfx_level gfx_level;
    enum vcn_version vcn_version;
    enum radeon_family family;
diff --git a/src/amd/common/ac_perfcounter.h b/src/amd/common/ac_perfcounter.h
index c198c4403ef28..6bc7b46e268d5 100644
--- a/src/amd/common/ac_perfcounter.h
+++ b/src/amd/common/ac_perfcounter.h
@@ -93,20 +93,21 @@ enum ac_pc_gpu_block {
 };
 
 struct ac_pc_block_base {
-   enum ac_pc_gpu_block gpu_block;
    const char *name;
+   enum ac_pc_gpu_block gpu_block;
    unsigned num_counters;
    unsigned flags;
 
    unsigned select_or;
    unsigned *select0;
-   unsigned counter0_lo;
+   unsigned *select1;
+
    unsigned *counters;
+   unsigned counter0_lo;
 
    /* SPM */
    unsigned num_spm_counters;
    unsigned num_spm_wires;
-   unsigned *select1;
    unsigned spm_block_select;
 };
 
diff --git a/src/amd/common/ac_rgp.h b/src/amd/common/ac_rgp.h
index 3966fa9b3ed75..cac4dca1b786e 100644
--- a/src/amd/common/ac_rgp.h
+++ b/src/amd/common/ac_rgp.h
@@ -133,8 +133,8 @@ struct rgp_queue_info_record {
 };
 
 struct rgp_queue_info {
-   uint32_t record_count;
    struct list_head record;
+   uint32_t record_count;
    simple_mtx_t lock;
 };
 
diff --git a/src/amd/vpelib/inc/vpe_types.h b/src/amd/vpelib/inc/vpe_types.h
index aaf6e006fe762..8736dc806a290 100644
--- a/src/amd/vpelib/inc/vpe_types.h
+++ b/src/amd/vpelib/inc/vpe_types.h
@@ -813,10 +813,10 @@ struct vpe_stream {
     float lower_luma_bound;                                    /**< Lowest range of the luma */
     float upper_luma_bound;                                    /**< Highest range of the luma */
     struct vpe_color_keyer color_keyer; /**< Enable Luma Keying & Set Parameters. */
-    enum vpe_keyer_mode    keyer_mode;  /**< Set Keyer Behavior.
-                                         * Used for both Luma & Color Keying.
-                                         */
     struct vpe_reserved_param reserved_param;     /**< Reserved parameter for input surface */
+    enum vpe_keyer_mode    keyer_mode;  /**< Set Keyer Behavior.
+                                        * Used for both Luma & Color Keying.
+                                        */
 
     /** @brief stream feature flags
      */
-- 
GitLab


From d97d506535744ec56c1405d31b3ad0b1528d4fe3 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 08:59:52 +0300
Subject: [PATCH 02/31] mesa: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/mesa/main/consts_exts.h                   |   8 +-
 src/mesa/main/formats.c                       |   4 +-
 src/mesa/main/glthread.h                      |  34 ++---
 src/mesa/main/glthread_bufferobj.c            |   8 +-
 src/mesa/main/mtypes.h                        | 142 +++++++++---------
 src/mesa/main/shader_types.h                  |   4 +-
 src/mesa/program/program_parser.h             |  11 +-
 src/mesa/state_tracker/st_context.h           |   6 +-
 .../state_tracker/st_nir_lower_alpha_test.c   |   2 +-
 src/mesa/state_tracker/st_nir_lower_fog.c     |   2 +-
 10 files changed, 110 insertions(+), 111 deletions(-)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 526078f9ce376..219b163d89593 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -303,16 +303,16 @@ struct gl_extensions
    GLboolean OES_geometry_shader;
    GLboolean OES_texture_compression_astc;
    GLboolean extension_sentinel;
-   /** The extension string */
-   const GLubyte *String;
-   /** Number of supported extensions */
-   GLuint Count;
    /**
     * The context version which extension helper functions compare against.
     * By default, the value is equal to ctx->Version. This changes to ~0
     * while meta is in progress.
     */
    GLubyte Version;
+   /** Number of supported extensions */
+   GLuint Count;
+   /** The extension string */
+   const GLubyte *String;
 };
 
 /**
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index 07853b92445ae..7294ec0776c98 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -39,11 +39,11 @@ struct mesa_format_info
 {
    mesa_format Name;
 
+   enum mesa_format_layout Layout;
+
    /** text name for debugging */
    const char *StrName;
 
-   enum mesa_format_layout Layout;
-
    /**
     * Base format is one of GL_RED, GL_RG, GL_RGB, GL_RGBA, GL_ALPHA,
     * GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_YCBCR_MESA,
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index 39594b368e746..be7578073f8c2 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -145,9 +145,6 @@ struct glthread_batch
    /** Batch fence for waiting for the execution to finish. */
    struct util_queue_fence fence;
 
-   /** The worker thread will access the context with this. */
-   struct gl_context *ctx;
-
    /**
     * Number of uint64_t elements filled already.
     * This is 0 when it's being filled because glthread::used holds the real
@@ -156,6 +153,9 @@ struct glthread_batch
     */
    unsigned used;
 
+   /** The worker thread will access the context with this. */
+   struct gl_context *ctx;
+
    /** Data contained in the command buffer. */
    uint64_t buffer[MARSHAL_MAX_CMD_BUFFER_SIZE / 8];
 };
@@ -208,10 +208,9 @@ struct glthread_state
    bool inside_begin_end;
    bool thread_sched_enabled;
 
-   /** Display lists. */
-   GLenum16 ListMode; /**< Zero if not inside display list, else list mode. */
-   unsigned ListBase;
-   unsigned ListCallDepth;
+   /** Global mutex update info. */
+   bool LockGlobalMutexes;
+   unsigned GlobalLockUpdateBatchCounter;
 
    /** For L3 cache pinning. */
    unsigned pin_thread_counter;
@@ -233,17 +232,22 @@ struct glthread_state
    unsigned used;
 
    /** Upload buffer. */
+   unsigned upload_offset;
    struct gl_buffer_object *upload_buffer;
    uint8_t *upload_ptr;
-   unsigned upload_offset;
    int upload_buffer_private_refcount;
 
+   /** Display lists. */
+   unsigned ListBase;
+   unsigned ListCallDepth;
+   GLenum16 ListMode; /**< Zero if not inside display list, else list mode. */
+
    /** Primitive restart state. */
    bool PrimitiveRestart;
    bool PrimitiveRestartFixedIndex;
-   bool _PrimitiveRestart;
    GLuint RestartIndex;
    GLuint _RestartIndex[4]; /**< Restart index for index_size = 1,2,4. */
+   bool _PrimitiveRestart;
 
    /** Vertex Array objects tracked by glthread independently of Mesa. */
    struct _mesa_HashTable VAOs;
@@ -275,11 +279,11 @@ struct glthread_state
 
    /** Basic matrix state tracking. */
    int ActiveTexture;
-   GLenum16 MatrixMode;
    gl_matrix_index MatrixIndex;
    struct glthread_attrib_node AttribStack[MAX_ATTRIB_STACK_DEPTH];
-   int AttribStackDepth;
    int MatrixStackDepth[M_NUM_MATRIX_STACKS];
+   int AttribStackDepth;
+   GLenum16 MatrixMode;
 
    /** Enable states. */
    bool Blend;
@@ -294,15 +298,11 @@ struct glthread_state
    GLuint CurrentProgram;
 
    /** The last added call of the given function. */
+   struct gl_pixelstore_attrib Unpack;
+
    struct marshal_cmd_CallList *LastCallList;
    struct marshal_cmd_BindBuffer *LastBindBuffer1;
    struct marshal_cmd_BindBuffer *LastBindBuffer2;
-
-   /** Global mutex update info. */
-   unsigned GlobalLockUpdateBatchCounter;
-   bool LockGlobalMutexes;
-
-   struct gl_pixelstore_attrib Unpack;
 };
 
 void _mesa_glthread_init(struct gl_context *ctx);
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index 7d4b15cb21641..f78b9bee282dc 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -320,13 +320,13 @@ struct marshal_cmd_BufferData
 {
    struct marshal_cmd_base cmd_base;
    uint16_t num_slots;
-   GLuint target_or_name;
-   GLsizeiptr size;
-   GLenum usage;
-   const GLvoid *data_external_mem;
    bool data_null; /* If set, no data follows for "data" */
    bool named;
    bool ext_dsa;
+   GLenum usage;
+   GLuint target_or_name;
+   GLsizeiptr size;
+   const GLvoid *data_external_mem;
    /* Next size bytes are GLubyte data[size] */
 };
 
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 7214818f02e4d..9d2839add9097 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -614,6 +614,11 @@ struct gl_pixel_attrib
    GLenum16 ReadBuffer;		/**< source buffer for glRead/CopyPixels() */
 
    /*--- Begin Pixel Transfer State ---*/
+   /* Pixel Maps */
+   /* Note: actual pixel maps are not part of this attrib group */
+   GLboolean MapColorFlag;
+   GLboolean MapStencilFlag;
+
    /* Fields are in the order in which they're applied... */
 
    /** Scale & Bias (index shift, offset) */
@@ -626,11 +631,6 @@ struct gl_pixel_attrib
    GLint IndexShift, IndexOffset;
    /*@}*/
 
-   /* Pixel Maps */
-   /* Note: actual pixel maps are not part of this attrib group */
-   GLboolean MapColorFlag;
-   GLboolean MapStencilFlag;
-
    /*--- End Pixel Transfer State ---*/
 
    /** glPixelZoom */
@@ -2393,11 +2393,11 @@ struct gl_sync_object
                                * live references (e.g., sync not yet finished)
                                */
    GLenum16 SyncCondition;
-   GLbitfield Flags;          /**< Flags passed to glFenceSync */
    GLuint StatusFlag:1;       /**< Has the sync object been signaled? */
+   GLbitfield Flags;          /**< Flags passed to glFenceSync */
 
-   struct pipe_fence_handle *fence;
    simple_mtx_t mutex; /**< protects "fence" */
+   struct pipe_fence_handle *fence;
 };
 
 
@@ -2597,24 +2597,24 @@ struct gl_renderbuffer_attachment
    GLenum16 Type; /**< \c GL_NONE or \c GL_TEXTURE or \c GL_RENDERBUFFER_EXT */
    GLboolean Complete;
 
-   /**
-    * If \c Type is \c GL_RENDERBUFFER_EXT, this stores a pointer to the
-    * application supplied renderbuffer object.
-    */
-   struct gl_renderbuffer *Renderbuffer;
-
    /**
     * If \c Type is \c GL_TEXTURE, this stores a pointer to the application
     * supplied texture object.
     */
-   struct gl_texture_object *Texture;
+   GLboolean Layered;
    GLuint TextureLevel; /**< Attached mipmap level. */
+   struct gl_texture_object *Texture;
    GLsizei NumSamples;  /**< from FramebufferTexture2DMultisampleEXT */
    GLuint CubeMapFace;  /**< 0 .. 5, for cube map textures. */
    GLuint Zoffset;      /**< Slice for 3D textures,  or layer for both 1D
                          * and 2D array textures */
-   GLboolean Layered;
    GLsizei NumViews;
+
+   /**
+    * If \c Type is \c GL_RENDERBUFFER_EXT, this stores a pointer to the
+    * application supplied renderbuffer object.
+    */
+   struct gl_renderbuffer *Renderbuffer;
 };
 
 
@@ -2636,10 +2636,29 @@ struct gl_framebuffer
    GLuint Name;
    GLint RefCount;
 
-   GLchar *Label;       /**< GL_KHR_debug */
-
    GLboolean DeletePending;
 
+   /** Whether one of Attachment has Type != GL_NONE
+    * NOTE: the values for Width and Height are set to 0 in case of having
+    * no attachments, a backend driver supporting the extension
+    * GL_ARB_framebuffer_no_attachments must check for the flag _HasAttachments
+    * and if GL_FALSE, must then use the values in DefaultGeometry to initialize
+    * its viewport, scissor and so on (in particular _Xmin, _Xmax, _Ymin and
+    * _Ymax do NOT take into account _HasAttachments being false). To get the
+    * geometry of the framebuffer, the  helper functions
+    *   _mesa_geometric_width(),
+    *   _mesa_geometric_height(),
+    *   _mesa_geometric_samples() and
+    *   _mesa_geometric_layers()
+    * are available that check _HasAttachments.
+    */
+   bool _HasAttachments;
+
+   /* GL_MESA_framebuffer_flip_y */
+   bool FlipY;
+
+   GLchar *Label;       /**< GL_KHR_debug */
+
    /**
     * The framebuffer's visual. Immutable if this is a window system buffer.
     * Computed from attachments if user-made FBO.
@@ -2682,24 +2701,23 @@ struct gl_framebuffer
    GLfloat _MRD;	/**< minimum resolvable difference in Z values */
    /*@}*/
 
+   /**
+    * The maximum number of layers in the framebuffer, or 0 if the framebuffer
+    * is not layered.  For cube maps and cube map arrays, each cube face
+    * counts as a layer. As the case for Width, Height a backend driver
+    * supporting GL_ARB_framebuffer_no_attachments must use DefaultGeometry
+    * in the case that _HasAttachments is false
+    */
+   GLuint MaxNumLayers;
+
    /** One of the GL_FRAMEBUFFER_(IN)COMPLETE_* tokens */
    GLenum16 _Status;
 
-   /** Whether one of Attachment has Type != GL_NONE
-    * NOTE: the values for Width and Height are set to 0 in case of having
-    * no attachments, a backend driver supporting the extension
-    * GL_ARB_framebuffer_no_attachments must check for the flag _HasAttachments
-    * and if GL_FALSE, must then use the values in DefaultGeometry to initialize
-    * its viewport, scissor and so on (in particular _Xmin, _Xmax, _Ymin and
-    * _Ymax do NOT take into account _HasAttachments being false). To get the
-    * geometry of the framebuffer, the  helper functions
-    *   _mesa_geometric_width(),
-    *   _mesa_geometric_height(),
-    *   _mesa_geometric_samples() and
-    *   _mesa_geometric_layers()
-    * are available that check _HasAttachments.
+   /* In unextended OpenGL these vars are part of the GL_COLOR_BUFFER
+    * attribute group and GL_PIXEL attribute group, respectively.
     */
-   bool _HasAttachments;
+   GLenum16 ColorReadBuffer;
+   GLenum16 ColorDrawBuffer[MAX_DRAW_BUFFERS];
 
    GLbitfield _IntegerBuffers;  /**< Which color buffer attachments are integer valued */
    GLbitfield _IntegerDrawBuffers;  /**< Which color draw buffers are integer valued */
@@ -2710,44 +2728,26 @@ struct gl_framebuffer
    GLbitfield _FP32Buffers; /**< Which color attachments are FP32 */
    GLbitfield _FP32DrawBuffers; /**< Which color buffers are FP32 */
 
-   /* ARB_color_buffer_float */
-   GLboolean _AllColorBuffersFixedPoint; /* no integer, no float */
-   GLboolean _HasSNormOrFloatColorBuffer;
-
-   /**
-    * The maximum number of layers in the framebuffer, or 0 if the framebuffer
-    * is not layered.  For cube maps and cube map arrays, each cube face
-    * counts as a layer. As the case for Width, Height a backend driver
-    * supporting GL_ARB_framebuffer_no_attachments must use DefaultGeometry
-    * in the case that _HasAttachments is false
-    */
-   GLuint MaxNumLayers;
-
    /** Array of all renderbuffer attachments, indexed by BUFFER_* tokens. */
    struct gl_renderbuffer_attachment Attachment[BUFFER_COUNT];
    struct pipe_resource *resolve; /**< color resolve attachment */
 
-   /* In unextended OpenGL these vars are part of the GL_COLOR_BUFFER
-    * attribute group and GL_PIXEL attribute group, respectively.
-    */
-   GLenum16 ColorDrawBuffer[MAX_DRAW_BUFFERS];
-   GLenum16 ColorReadBuffer;
-
    /* GL_ARB_sample_locations */
    GLfloat *SampleLocationTable; /**< If NULL, no table has been specified */
    GLboolean ProgrammableSampleLocations;
    GLboolean SampleLocationPixelGrid;
 
+   /* ARB_color_buffer_float */
+   GLboolean _AllColorBuffersFixedPoint; /* no integer, no float */
+   GLboolean _HasSNormOrFloatColorBuffer;
+
    /** Computed from ColorDraw/ReadBuffer above */
    GLuint _NumColorDrawBuffers;
-   gl_buffer_index _ColorDrawBufferIndexes[MAX_DRAW_BUFFERS];
    gl_buffer_index _ColorReadBufferIndex;
+   gl_buffer_index _ColorDrawBufferIndexes[MAX_DRAW_BUFFERS];
    struct gl_renderbuffer *_ColorDrawBuffers[MAX_DRAW_BUFFERS];
    struct gl_renderbuffer *_ColorReadBuffer;
 
-   /* GL_MESA_framebuffer_flip_y */
-   bool FlipY;
-
    /** Delete this framebuffer */
    void (*Delete)(struct gl_framebuffer *fb);
 
@@ -3030,8 +3030,8 @@ struct gl_memory_object
 struct gl_semaphore_object
 {
    GLuint Name;            /**< hash table ID/name */
-   struct pipe_fence_handle *fence;
    enum pipe_fd_type type;
+   struct pipe_fence_handle *fence;
    uint64_t timeline_value;
 };
 
@@ -3265,15 +3265,6 @@ struct gl_context
    /** Only accessible while Shared->Mutex is held */
    struct util_dynarray ReleaseResources;
 
-   /** Whether Shared->BufferObjects has already been locked for this context. */
-   bool BufferObjectsLocked;
-   /** Whether Shared->TexMutex has already been locked for this context. */
-   bool TexturesLocked;
-
-   /** \name API function pointer tables */
-   /*@{*/
-   gl_api API;
-
    /**
     * Dispatch tables implementing OpenGL functions. GLThread has no effect
     * on this.
@@ -3297,6 +3288,10 @@ struct gl_context
 
    struct glthread_state GLThread;
 
+   /** \name API function pointer tables */
+   /*@{*/
+   gl_api API;
+
    struct gl_config Visual;
    struct gl_framebuffer *DrawBuffer;	/**< buffer for writing */
    struct gl_framebuffer *ReadBuffer;	/**< buffer for reading */
@@ -3325,6 +3320,11 @@ struct gl_context
     */
    GLbitfield ValidPrimMask;
 
+   /** Whether Shared->BufferObjects has already been locked for this context. */
+   bool BufferObjectsLocked;
+   /** Whether Shared->TexMutex has already been locked for this context. */
+   bool TexturesLocked;
+
    GLenum16 DrawGLError; /**< GL error to return from draw calls */
 
    /**
@@ -3335,11 +3335,6 @@ struct gl_context
    /** DrawID for the next non-multi non-indirect draw. Only set by glthread. */
    GLuint DrawID;
 
-   /**
-    * Whether DrawPixels/CopyPixels/Bitmap are valid to render.
-    */
-   bool DrawPixValid;
-
    /** \name The various 4x4 matrix stacks */
    /*@{*/
    struct gl_matrix_stack ModelviewMatrixStack;
@@ -3358,12 +3353,17 @@ struct gl_context
    GLboolean ExecuteFlag;	/**< Execute GL commands? */
    GLboolean CompileFlag;	/**< Compile GL commands into display list? */
 
+   /**
+    * Whether DrawPixels/CopyPixels/Bitmap are valid to render.
+    */
+   bool DrawPixValid;
+
    /** Extension information */
    struct gl_extensions Extensions;
 
-   /** GL version integer, for example 31 for GL 3.1, or 20 for GLES 2.0. */
-   GLuint Version;
+   /** GL version integer, for example 31 for GL 3.1, or 20 for GLES 2.0. */\
    char *VersionString;
+   GLuint Version;
 
    /** \name State attribute stack (for glPush/PopAttrib) */
    /*@{*/
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index 97ba97ce0c45e..1a8ea3b60a73a 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -251,8 +251,6 @@ struct gl_linked_shader
 {
    mesa_shader_stage Stage;
 
-   struct gl_program *Program;  /**< Post-compile assembly code */
-
    /**
     * \name Sampler tracking
     *
@@ -262,6 +260,8 @@ struct gl_linked_shader
    GLbitfield shadow_samplers;	/**< Samplers used for shadow sampling. */
    /*@}*/
 
+   struct gl_program *Program;  /**< Post-compile assembly code */
+
    /**
     * Number of default uniform block components used by this shader.
     *
diff --git a/src/mesa/program/program_parser.h b/src/mesa/program/program_parser.h
index cb3dd33bdc4db..d24dca0326c7a 100644
--- a/src/mesa/program/program_parser.h
+++ b/src/mesa/program/program_parser.h
@@ -190,6 +190,11 @@ struct asm_parser_state {
    unsigned state_param_enum_env;
    unsigned state_param_enum_local;
 
+   enum {
+      invalid_mode = 0,
+      ARB_vertex,
+      ARB_fragment
+   } mode;
 
    /**
     * Input attributes bound to specific names
@@ -200,12 +205,6 @@ struct asm_parser_state {
     */
    GLbitfield64 InputsBound;
 
-   enum {
-      invalid_mode = 0,
-      ARB_vertex,
-      ARB_fragment
-   } mode;
-
    struct {
       unsigned PositionInvariant:1;
       unsigned Fog:2; /* gl_fog_mode */
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index c06832831b0d5..fb45e8321cf5d 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -62,18 +62,18 @@ struct st_bitmap_cache
 
    /** GL states */
    struct gl_program *fp;
+   GLfloat color[4];
    bool scissor_enabled;
    bool clamp_frag_color;
-   GLfloat color[4];
 
    /** Bitmap's Z position */
+   GLboolean empty;
+
    GLfloat zpos;
 
    struct pipe_resource *texture;
    struct pipe_transfer *trans;
 
-   GLboolean empty;
-
    /** An I8 texture image: */
    uint8_t *buffer;
 };
diff --git a/src/mesa/state_tracker/st_nir_lower_alpha_test.c b/src/mesa/state_tracker/st_nir_lower_alpha_test.c
index 1df994030ea1e..2b42d7590257d 100644
--- a/src/mesa/state_tracker/st_nir_lower_alpha_test.c
+++ b/src/mesa/state_tracker/st_nir_lower_alpha_test.c
@@ -37,10 +37,10 @@
 
 struct alpha_test_state {
    bool alpha_to_one;
+   bool packed_driver_uniform_storage;
    enum compare_func func;
    const gl_state_index16 *alpha_ref_state_tokens;
    struct gl_program_parameter_list *paramList;
-   bool packed_driver_uniform_storage;
 };
 
 static bool
diff --git a/src/mesa/state_tracker/st_nir_lower_fog.c b/src/mesa/state_tracker/st_nir_lower_fog.c
index f400048c6b17f..23f27f709080f 100644
--- a/src/mesa/state_tracker/st_nir_lower_fog.c
+++ b/src/mesa/state_tracker/st_nir_lower_fog.c
@@ -79,8 +79,8 @@ fog_result(nir_builder *b, nir_def *color, enum gl_fog_mode fog_mode,
 
 struct lower_fog_state {
    enum gl_fog_mode fog_mode;
-   struct gl_program_parameter_list *paramList;
    bool packed_driver_uniform_storage;
+   struct gl_program_parameter_list *paramList;
 };
 
 static bool
-- 
GitLab


From 0ac3a6aa3361d9b6e1d31d7249d41e57e61ccbfe Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 09:00:35 +0300
Subject: [PATCH 03/31] util: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/util/disk_cache.h                  |  2 +-
 src/util/disk_cache_os.h               |  9 +++++----
 src/util/format/texcompress_bptc_tmp.h |  4 ++--
 src/util/format/u_format.h             | 14 +++++++-------
 src/util/libdrm.h                      |  4 ++--
 src/util/mesa_cache_db.h               |  2 +-
 src/util/mesa_cache_db_multipart.h     |  2 +-
 src/util/perf/u_trace.c                |  6 +++---
 src/util/ralloc.c                      |  5 ++---
 src/util/u_cpu_detect.h                |  8 ++++----
 src/util/u_queue.h                     |  2 +-
 11 files changed, 29 insertions(+), 29 deletions(-)

diff --git a/src/util/disk_cache.h b/src/util/disk_cache.h
index a69b12665c6e5..d8d61102ac5b0 100644
--- a/src/util/disk_cache.h
+++ b/src/util/disk_cache.h
@@ -73,8 +73,8 @@ struct cache_item_metadata {
    uint32_t type;
 
    /** GLSL cache item metadata */
-   cache_key *keys;   /* sha1 list of shaders that make up the cache item */
    uint32_t num_keys;
+   cache_key *keys;   /* sha1 list of shaders that make up the cache item */
 };
 
 struct disk_cache;
diff --git a/src/util/disk_cache_os.h b/src/util/disk_cache_os.h
index 9c9253adc21d6..9a4d09ea4f625 100644
--- a/src/util/disk_cache_os.h
+++ b/src/util/disk_cache_os.h
@@ -59,7 +59,6 @@ enum disk_cache_type {
 struct disk_cache {
    /* The path to the cache directory. */
    char *path;
-   bool path_init_failed;
 
    /* Thread queue for compressing and writing cache entries to disk */
    struct util_queue cache_queue;
@@ -68,6 +67,11 @@ struct disk_cache {
 
    struct mesa_cache_db_multipart cache_db;
 
+   bool path_init_failed;
+
+   /* Don't compress cached data. This is for testing purposes only. */
+   bool compression_disabled;
+
    enum disk_cache_type type;
 
    /* Seed for rand, which is used to pick a random directory */
@@ -93,9 +97,6 @@ struct disk_cache {
    disk_cache_put_cb blob_put_cb;
    disk_cache_get_cb blob_get_cb;
 
-   /* Don't compress cached data. This is for testing purposes only. */
-   bool compression_disabled;
-
    struct {
       bool enabled;
       unsigned hits;
diff --git a/src/util/format/texcompress_bptc_tmp.h b/src/util/format/texcompress_bptc_tmp.h
index dae6a57de8486..58c47732f3a1d 100644
--- a/src/util/format/texcompress_bptc_tmp.h
+++ b/src/util/format/texcompress_bptc_tmp.h
@@ -42,10 +42,10 @@ struct bptc_unorm_mode {
    int n_partition_bits;
    bool has_rotation_bits;
    bool has_index_selection_bit;
-   int n_color_bits;
-   int n_alpha_bits;
    bool has_endpoint_pbits;
    bool has_shared_pbits;
+   int n_color_bits;
+   int n_alpha_bits;
    int n_index_bits;
    int n_secondary_index_bits;
 };
diff --git a/src/util/format/u_format.h b/src/util/format/u_format.h
index a1bef3192e6e5..347ad53155a4f 100644
--- a/src/util/format/u_format.h
+++ b/src/util/format/u_format.h
@@ -143,21 +143,21 @@ struct util_format_channel_description
 
 struct util_format_description
 {
-   enum pipe_format format;
-
    const char *name;
 
-   /**
-    * Short name, striped of the prefix, lower case.
-    */
-   const char *short_name;
+   enum pipe_format format;
 
    /**
     * Pixel block dimensions.
     */
+   enum util_format_layout layout;
+
    struct util_format_block block;
 
-   enum util_format_layout layout;
+   /**
+    * Short name, striped of the prefix, lower case.
+    */
+   const char *short_name;
 
    /**
     * The number of channels.
diff --git a/src/util/libdrm.h b/src/util/libdrm.h
index d8ef0b55182ef..5f68f158137ef 100644
--- a/src/util/libdrm.h
+++ b/src/util/libdrm.h
@@ -136,10 +136,10 @@ typedef struct _drmVersion {
     int     version_minor;        /**< Minor version */
     int     version_patchlevel;   /**< Patch level */
     int     name_len;             /**< Length of name buffer */
-    char    *name;                /**< Name of driver */
     int     date_len;             /**< Length of date buffer */
-    char    *date;                /**< User-space buffer to hold date */
     int     desc_len;             /**< Length of desc buffer */
+    char    *name;                /**< Name of driver */
+    char    *date;                /**< User-space buffer to hold date */
     char    *desc;                /**< User-space buffer to hold desc */
 } drmVersion, *drmVersionPtr;
 
diff --git a/src/util/mesa_cache_db.h b/src/util/mesa_cache_db.h
index f6097d81271f9..1bed86f5402e4 100644
--- a/src/util/mesa_cache_db.h
+++ b/src/util/mesa_cache_db.h
@@ -34,9 +34,9 @@ struct mesa_cache_db {
    struct mesa_cache_db_file index;
    uint64_t max_cache_size;
    simple_mtx_t flock_mtx;
+   bool alive;
    void *mem_ctx;
    uint64_t uuid;
-   bool alive;
 };
 
 #if DETECT_OS_WINDOWS == 0
diff --git a/src/util/mesa_cache_db_multipart.h b/src/util/mesa_cache_db_multipart.h
index d3cca82c2ab5f..2a192ed46c5f0 100644
--- a/src/util/mesa_cache_db_multipart.h
+++ b/src/util/mesa_cache_db_multipart.h
@@ -13,11 +13,11 @@
 struct mesa_cache_db_multipart {
    struct mesa_cache_db **parts;
    unsigned int num_parts;
+   simple_mtx_t lock;
    volatile unsigned int last_read_part;
    volatile unsigned int last_written_part;
    const char *cache_path;
    uint64_t max_cache_size;
-   simple_mtx_t lock;
 };
 
 bool
diff --git a/src/util/perf/u_trace.c b/src/util/perf/u_trace.c
index f2cad02332815..70793f1ee15a0 100644
--- a/src/util/perf/u_trace.c
+++ b/src/util/perf/u_trace.c
@@ -104,18 +104,18 @@ struct u_trace_chunk {
 
    struct util_queue_fence fence;
 
+   uint32_t frame_nr; /* frame idx from the driver */
    bool has_indirect;
    bool last; /* this chunk is last in batch */
    bool eof;  /* this chunk is last in frame, unless frame_nr is set */
-   uint32_t frame_nr; /* frame idx from the driver */
-
-   void *flush_data; /* assigned by u_trace_flush */
 
    /**
     * Several chunks reference a single flush_data instance thus only
     * one chunk should be designated to free the data.
     */
    bool free_flush_data;
+
+   void *flush_data; /* assigned by u_trace_flush */
 };
 
 struct u_trace_printer {
diff --git a/src/util/ralloc.c b/src/util/ralloc.c
index ba560c8387ae2..e6670502eaf18 100644
--- a/src/util/ralloc.c
+++ b/src/util/ralloc.c
@@ -646,6 +646,8 @@ struct gc_ctx {
 #ifndef NDEBUG
    unsigned canary;
 #endif
+   uint8_t current_gen;
+   void *rubbish;
 
    /* Array of slabs for fixed-size allocations. Each slab tracks allocations
     * of specific sized blocks. User allocations are rounded up to the nearest
@@ -661,9 +663,6 @@ struct gc_ctx {
        */
       struct list_head free_slabs;
    } slabs[NUM_FREELIST_BUCKETS];
-
-   uint8_t current_gen;
-   void *rubbish;
 };
 
 static gc_block_header *
diff --git a/src/util/u_cpu_detect.h b/src/util/u_cpu_detect.h
index ef4c38db2636e..f9ffcb7663e53 100644
--- a/src/util/u_cpu_detect.h
+++ b/src/util/u_cpu_detect.h
@@ -110,18 +110,18 @@ struct util_cpu_caps_t {
 
    uint16_t cpu_to_L3[UTIL_MAX_CPUS];
 
-   /* Affinity masks for each L3 cache. */
-   util_affinity_mask *L3_affinity_mask;
    /**
     * number of "big" CPUs in big.LITTLE configuration
-    * 
+    *
     * a "big" CPU is defined as anything with >= 50% the capacity of the largest CPU,
     * useful for drivers determining how many and what kinds of threads to use
     * example: 1x prime + 3x big + 4x little = 4x "big" cores
-    * 
+    *
     * A value of zero indicates that CPUs are homogeneous.
     */
    int16_t nr_big_cpus;
+   /* Affinity masks for each L3 cache. */
+   util_affinity_mask *L3_affinity_mask;
 };
 
 struct _util_cpu_caps_state_t {
diff --git a/src/util/u_queue.h b/src/util/u_queue.h
index 7cbb89cdec3a6..5077d373fc09d 100644
--- a/src/util/u_queue.h
+++ b/src/util/u_queue.h
@@ -223,8 +223,8 @@ struct util_queue_job {
 /* Put this into your context. */
 struct util_queue {
    char name[14]; /* 13 characters = the thread name without the index */
-   mtx_t lock;
    bool create_threads_on_demand;
+   mtx_t lock;
    cnd_t has_queued_cond;
    cnd_t has_space_cond;
    thrd_t *threads;
-- 
GitLab


From 8576ff770feed658ecfeb910af2f1e886b4ac534 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 09:01:51 +0300
Subject: [PATCH 05/31] gallium: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 .../auxiliary/util/u_threaded_context.h       |  6 +--
 src/gallium/frontends/dri/dri_screen.h        | 37 ++++++++++---------
 .../frontends/dri/loader_dri3_helper.h        |  3 +-
 src/gallium/include/frontend/api.h            |  4 +-
 src/gallium/include/pipe/p_screen.h           | 16 ++++----
 src/gallium/include/pipe/p_state.h            | 24 ++++++------
 6 files changed, 46 insertions(+), 44 deletions(-)

diff --git a/src/gallium/frontends/dri/dri_screen.h b/src/gallium/frontends/dri/dri_screen.h
index acdd624cd21d1..2f5ed522fc72d 100644
--- a/src/gallium/frontends/dri/dri_screen.h
+++ b/src/gallium/frontends/dri/dri_screen.h
@@ -53,11 +53,11 @@ struct dri_screen
    struct pipe_frontend_screen base;
 
    /* dri */
+   void *loaderPrivate;
+
    /* Current screen's number */
    int myNum;
 
-   void *loaderPrivate;
-
    int max_gl_core_version;
    int max_gl_compat_version;
    int max_gl_es1_version;
@@ -83,29 +83,34 @@ struct dri_screen
    driOptionCache optionInfo;
    driOptionCache optionCache;
 
+   bool throttle : 1;
+   bool dmabuf_import : 1;
+   bool has_multibuffer : 1;
+
+   /* drm */
+   bool can_share_buffer : 1;
+   int fd;
+
    unsigned int api_mask;
 
-   bool throttle;
-   bool dmabuf_import;
-   bool has_multibuffer;
+   struct pipe_loader_device *dev;
 
    struct st_config_options options;
 
    /* Which postprocessing filters are enabled. */
    unsigned pp_enabled[PP_FILTERS];
 
-   /* drm */
-   int fd;
-   bool can_share_buffer;
-
-   struct pipe_loader_device *dev;
-
    /* gallium */
-   bool has_reset_status_query;
-   bool has_protected_context;
    enum pipe_texture_target target;
 
-   bool swrast_no_present;
+   bool swrast_no_present : 1;
+
+   bool has_reset_status_query : 1;
+   bool has_protected_context : 1;
+
+   /* kopper */
+   bool has_dmabuf : 1;
+   bool is_sw : 1;
 
    /* DRI exts on this screen. Populated at init time based on device caps. */
    const __DRIextension *screen_extensions[14];
@@ -116,10 +121,6 @@ struct dri_screen
    opencl_dri_event_release_t opencl_dri_event_release;
    opencl_dri_event_wait_t opencl_dri_event_wait;
    opencl_dri_event_get_fence_t opencl_dri_event_get_fence;
-
-   /* kopper */
-   bool has_dmabuf;
-   bool is_sw;
 };
 
 static inline const __DRIkopperLoaderExtension *
diff --git a/src/gallium/frontends/dri/loader_dri3_helper.h b/src/gallium/frontends/dri/loader_dri3_helper.h
index 26f138d1b831a..e9f549e2b24c9 100644
--- a/src/gallium/frontends/dri/loader_dri3_helper.h
+++ b/src/gallium/frontends/dri/loader_dri3_helper.h
@@ -43,7 +43,6 @@ enum loader_dri3_buffer_type {
 
 struct loader_dri3_buffer {
    struct dri_image   *image;
-   uint32_t     pixmap;
 
    /* default case: linear buffer allocated in render gpu vram.
     * p2p case: linear buffer allocated in display gpu vram and imported
@@ -52,6 +51,8 @@ struct loader_dri3_buffer {
     */
    struct dri_image   *linear_buffer;
 
+   uint32_t     pixmap;
+
    /* Synchronization between the client and X server is done using an
     * xshmfence that is mapped into an X server SyncFence. This lets the
     * client check whether the X server is done using a buffer with a simple
diff --git a/src/gallium/include/frontend/api.h b/src/gallium/include/frontend/api.h
index d1af611e53db0..84d08fe4e1d1d 100644
--- a/src/gallium/include/frontend/api.h
+++ b/src/gallium/include/frontend/api.h
@@ -171,11 +171,11 @@ struct st_config_options
    bool disable_glsl_line_continuations;
    bool disable_arb_gpu_shader5;
    bool disable_uniform_array_resize;
+   unsigned force_glsl_version;
    char *alias_shader_extension;
    bool allow_vertex_texture_bias;
    bool force_compat_shaders;
    bool force_glsl_extensions_warn;
-   unsigned force_glsl_version;
    bool allow_extra_pp_tokens;
    bool allow_glsl_extension_directive_midshader;
    bool allow_glsl_120_subset_in_110;
@@ -201,10 +201,10 @@ struct st_config_options
    bool transcode_etc;
    bool transcode_astc;
    bool allow_compressed_fallback;
+   bool allow_multisampled_copyteximage;
    char *force_gl_vendor;
    char *force_gl_renderer;
    char *mesa_extension_override;
-   bool allow_multisampled_copyteximage;
 
    unsigned char config_options_sha1[20];
 };
diff --git a/src/gallium/include/pipe/p_screen.h b/src/gallium/include/pipe/p_screen.h
index 7eb97885f577a..dc3a398c2179d 100644
--- a/src/gallium/include/pipe/p_screen.h
+++ b/src/gallium/include/pipe/p_screen.h
@@ -89,8 +89,15 @@ typedef void (*pipe_driver_thread_func)(void *job, void *gdata, int thread_index
  * context.
  */
 struct pipe_screen {
-   int refcnt;
    void *winsys_priv;
+   int refcnt;
+
+   /**
+    * Atomically incremented by drivers to track the number of contexts.
+    * If it's 0, it can be assumed that contexts are not tracked.
+    * Used by some places to skip locking if num_contexts == 1.
+    */
+   unsigned num_contexts;
 
    const struct pipe_caps caps;
    const struct pipe_shader_caps shader_caps[MESA_SHADER_MESH_STAGES];
@@ -104,13 +111,6 @@ struct pipe_screen {
     */
    int (*get_screen_fd)(struct pipe_screen *);
 
-   /**
-    * Atomically incremented by drivers to track the number of contexts.
-    * If it's 0, it can be assumed that contexts are not tracked.
-    * Used by some places to skip locking if num_contexts == 1.
-    */
-   unsigned num_contexts;
-
    /**
     * For drivers using u_transfer_helper:
     */
diff --git a/src/gallium/include/pipe/p_state.h b/src/gallium/include/pipe/p_state.h
index 733d21ac6db01..32c21059b6f8e 100644
--- a/src/gallium/include/pipe/p_state.h
+++ b/src/gallium/include/pipe/p_state.h
@@ -603,8 +603,8 @@ struct pipe_transfer
    enum pipe_map_flags usage:24;
    unsigned level:8;               /**< texture mipmap level */
    struct pipe_box box;            /**< region of the resource to access */
-   unsigned stride;                /**< row stride in bytes */
    uintptr_t layer_stride;          /**< image/layer stride in bytes */
+   unsigned stride;                /**< row stride in bytes */
 
    /* Offset into a driver-internal staging buffer to make use of unused
     * padding in this structure.
@@ -907,17 +907,17 @@ struct pipe_blit_info
       there mainly to support blitting between different formats
       when one of them has been emulated (e.g. GL_ALPHA emulated
       by GL_RGBA) */
-   bool swizzle_enable; /**< swizzle is only applied if this is set */
    uint8_t swizzle[4];  /**< map to be applied while blitting */
+   bool swizzle_enable; /**< swizzle is only applied if this is set */
+
+   bool render_condition_enable; /**< whether the blit should honor the
+                              current render condition */
+   bool alpha_blend; /* dst.rgb = src.rgb * src.a + dst.rgb * (1 - src.a) */
 
    /* Window rectangles can either be inclusive or exclusive. */
    bool window_rectangle_include;
    unsigned num_window_rectangles;
    struct pipe_scissor_state window_rectangles[PIPE_MAX_WINDOW_RECTANGLES];
-
-   bool render_condition_enable; /**< whether the blit should honor the
-                                 current render condition */
-   bool alpha_blend; /* dst.rgb = src.rgb * src.a + dst.rgb * (1 - src.a) */
 };
 
 /**
@@ -1025,14 +1025,14 @@ struct pipe_tensor {
     * Zero-point used to quantize this tensor, per-tensor quantization.
     */
    int zero_point;
-   /**
-    * Zero-points used to quantize this tensor, per-axis quantization.
-    */
-   int *zero_points;
    /**
     * Whether the tensor contains data in INT8 or UINT8 format.
     */
    bool is_signed;
+   /**
+    * Zero-points used to quantize this tensor, per-axis quantization.
+    */
+   int *zero_points;
 };
 
 /**
@@ -1067,8 +1067,8 @@ struct pipe_ml_operation
    /**
     * Tensor used as input.
     */
-   struct pipe_tensor **input_tensors;
    unsigned input_count;
+   struct pipe_tensor **input_tensors;
 
    /**
     * Tensor used as output.
@@ -1237,8 +1237,8 @@ struct pipe_ml_subgraph
 struct pipe_compute_state
 {
    enum pipe_shader_ir ir_type; /**< IR type contained in prog. */
-   const void *prog; /**< Compute program to be executed. */
    unsigned static_shared_mem; /**< equal to info.shared_size, used for shaders passed as TGSI */
+   const void *prog; /**< Compute program to be executed. */
 };
 
 struct pipe_compute_state_object_info
-- 
GitLab


From 31294e126f09e7b046b0da611fae9e0d8a77fc16 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Wed, 24 Sep 2025 10:53:37 +0300
Subject: [PATCH 06/31] vulkan: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/vulkan/runtime/rmv/vk_rmv_tokens.h        |  8 +-
 src/vulkan/runtime/vk_command_buffer.h        | 32 +++----
 src/vulkan/runtime/vk_device.h                | 30 +++---
 .../runtime/vk_device_generated_commands.h    | 10 +-
 src/vulkan/runtime/vk_graphics_state.h        | 22 ++---
 src/vulkan/runtime/vk_image.h                 |  2 +-
 src/vulkan/runtime/vk_instance.h              | 18 ++--
 src/vulkan/runtime/vk_queue.h                 | 96 +++++++++----------
 src/vulkan/runtime/vk_render_pass.h           | 30 +++---
 src/vulkan/runtime/vk_texcompress_astc.h      |  4 +-
 10 files changed, 126 insertions(+), 126 deletions(-)

diff --git a/src/vulkan/runtime/rmv/vk_rmv_tokens.h b/src/vulkan/runtime/rmv/vk_rmv_tokens.h
index ca40838929d3c..392a3e68562db 100644
--- a/src/vulkan/runtime/rmv/vk_rmv_tokens.h
+++ b/src/vulkan/runtime/rmv/vk_rmv_tokens.h
@@ -163,14 +163,14 @@ struct vk_rmv_image_description {
    uint32_t metadata_alignment_log2;
    uint32_t image_alignment_log2;
 
+   bool presentable;
+
    uint64_t size;
    uint64_t metadata_size;
    uint64_t metadata_header_size;
 
    uint64_t metadata_offset;
    uint64_t metadata_header_offset;
-
-   bool presentable;
 };
 
 struct vk_rmv_event_description {
@@ -202,10 +202,10 @@ struct vk_rmv_heap_description {
 
 struct vk_rmv_pipeline_description {
    bool is_internal;
+   bool is_ngg;
+   VkShaderStageFlags shader_stages;
    uint64_t hash_lo;
    uint64_t hash_hi;
-   VkShaderStageFlags shader_stages;
-   bool is_ngg;
 };
 
 struct vk_rmv_descriptor_pool_description {
diff --git a/src/vulkan/runtime/vk_command_buffer.h b/src/vulkan/runtime/vk_command_buffer.h
index 7d6775258dc80..18a5a466ab7b6 100644
--- a/src/vulkan/runtime/vk_command_buffer.h
+++ b/src/vulkan/runtime/vk_command_buffer.h
@@ -114,19 +114,27 @@ struct vk_command_buffer {
 
    struct vk_command_pool *pool;
 
-   /** VkCommandBufferAllocateInfo::level */
-   VkCommandBufferLevel level;
-
    const struct vk_command_buffer_ops *ops;
 
    struct vk_dynamic_graphics_state dynamic_graphics_state;
 
+   /** VkCommandBufferAllocateInfo::level */
+   VkCommandBufferLevel level;
+
    /** State of the command buffer */
    enum mesa_vk_command_buffer_state state;
 
    /** Command buffer recording error state. */
    VkResult record_result;
 
+   /**
+    * Bitmask of shader stages bound via a vk_pipeline since the last call to
+    * vkBindShadersEXT().
+    *
+    * Used by the common vk_pipeline implementation
+    */
+   VkShaderStageFlags pipeline_shader_stages;
+
    /** Link in vk_command_pool::command_buffers if pool != NULL */
    struct list_head pool_link;
 
@@ -176,30 +184,22 @@ struct vk_command_buffer {
    struct util_dynarray labels;
    bool region_begin;
 
-   struct vk_render_pass *render_pass;
-   uint32_t subpass_idx;
-   struct vk_framebuffer *framebuffer;
-   VkRect2D render_area;
-
    /**
     * True if we are currently inside a CmdPipelineBarrier() is inserted by
     * the runtime's vk_render_pass.c
     */
    bool runtime_rp_barrier;
 
+   uint32_t subpass_idx;
+   struct vk_render_pass *render_pass;
+   struct vk_framebuffer *framebuffer;
+   VkRect2D render_area;
+
    /* This uses the same trick as STACK_ARRAY */
    struct vk_attachment_state *attachments;
    struct vk_attachment_state _attachments[8];
 
    VkRenderPassSampleLocationsBeginInfoEXT *pass_sample_locations;
-
-   /**
-    * Bitmask of shader stages bound via a vk_pipeline since the last call to
-    * vkBindShadersEXT().
-    *
-    * Used by the common vk_pipeline implementation
-    */
-   VkShaderStageFlags pipeline_shader_stages;
 };
 
 VK_DEFINE_HANDLE_CASTS(vk_command_buffer, base, VkCommandBuffer,
diff --git a/src/vulkan/runtime/vk_device.h b/src/vulkan/runtime/vk_device.h
index 8b45d0244d12a..881f8bcf59401 100644
--- a/src/vulkan/runtime/vk_device.h
+++ b/src/vulkan/runtime/vk_device.h
@@ -119,6 +119,16 @@ struct vk_device {
    /** Table of enabled features */
    struct vk_features enabled_features;
 
+   /* For VK_KHR_pipeline_binary */
+   bool disable_internal_cache;
+
+   bool trace_hotkey_trigger;
+   uint32_t current_frame;
+   simple_mtx_t trace_mtx;
+
+   uint32_t memory_report_count;
+   struct vk_device_memory_report *memory_reports;
+
    /** Device-level dispatch table */
    struct vk_device_dispatch_table dispatch_table;
 
@@ -185,13 +195,14 @@ struct vk_device {
     */
    VkResult (*capture_trace)(VkQueue queue);
 
-   uint32_t current_frame;
-   bool trace_hotkey_trigger;
-   simple_mtx_t trace_mtx;
-
    /* For VK_EXT_private_data */
    uint32_t private_data_next_index;
 
+   /** Host time domain used for timestamp calibration */
+   VkTimeDomainKHR calibrate_time_domain;
+   /** Period of VK_TIME_DOMAIN_DEVICE_KHR */
+   uint64_t device_time_domain_period;
+
    struct list_head queues;
 
    struct {
@@ -214,11 +225,6 @@ struct vk_device {
    /* Get the device timestamp in the VK_TIME_DOMAIN_DEVICE_KHR domain */
    VkResult (*get_timestamp)(struct vk_device *device, uint64_t *timestamp);
 
-   /** Host time domain used for timestamp calibration */
-   VkTimeDomainKHR calibrate_time_domain;
-   /** Period of VK_TIME_DOMAIN_DEVICE_KHR */
-   uint64_t device_time_domain_period;
-
    /** Copies the sync payloads from the set of waits to the set of signals
     *
     * This effectively does the same as a vk_queue::driver_submit() with the
@@ -309,12 +315,6 @@ struct vk_device {
    struct hash_table *swapchain_private;
    mtx_t swapchain_name_mtx;
    struct hash_table *swapchain_name;
-
-   /* For VK_KHR_pipeline_binary */
-   bool disable_internal_cache;
-
-   struct vk_device_memory_report *memory_reports;
-   uint32_t memory_report_count;
 };
 
 VK_DEFINE_HANDLE_CASTS(vk_device, base, VkDevice,
diff --git a/src/vulkan/runtime/vk_device_generated_commands.h b/src/vulkan/runtime/vk_device_generated_commands.h
index 58c16e359ab5b..0b0180aa0c08e 100644
--- a/src/vulkan/runtime/vk_device_generated_commands.h
+++ b/src/vulkan/runtime/vk_device_generated_commands.h
@@ -62,6 +62,8 @@ struct vk_indirect_command_layout {
    /* mask of mesa_vk_dgc_types */
    uint32_t dgc_info;
 
+   uint32_t vertex_bindings;
+
    VkPipelineLayout layout;
 
    VkIndirectCommandsLayoutUsageFlagsEXT usage;
@@ -69,18 +71,16 @@ struct vk_indirect_command_layout {
 
    size_t stride;
 
-   uint32_t vertex_bindings;
-
    uint32_t ies_src_offset_B;
    bool is_shaders;
 
    bool delete_layout;
 
    bool index_mode_is_dx;
-   uint32_t index_src_offset_B;
+   bool draw_count;
 
+   uint32_t index_src_offset_B;
    uint32_t draw_src_offset_B;
-   bool draw_count;
 
    uint32_t dispatch_src_offset_B;
 
@@ -88,8 +88,8 @@ struct vk_indirect_command_layout {
 
    struct vk_indirect_command_push_constant_layout si_layout;
 
-   uint32_t n_pc_layouts;
    struct vk_indirect_command_push_constant_layout *pc_layouts;
+   uint32_t n_pc_layouts;
 
    uint32_t n_vb_layouts;
    struct vk_indirect_command_vertex_layout *vb_layouts;
diff --git a/src/vulkan/runtime/vk_graphics_state.h b/src/vulkan/runtime/vk_graphics_state.h
index 759667b64d700..2e6d62c41e713 100644
--- a/src/vulkan/runtime/vk_graphics_state.h
+++ b/src/vulkan/runtime/vk_graphics_state.h
@@ -458,12 +458,12 @@ struct vk_multisample_state {
    /** VkPipelineMultisampleStateCreateInfo::rasterizationSamples */
    VkSampleCountFlagBits rasterization_samples;
 
-   /** VkPipelineMultisampleStateCreateInfo::sampleShadingEnable */
-   bool sample_shading_enable;
-
    /** VkPipelineMultisampleStateCreateInfo::minSampleShading */
    float min_sample_shading;
 
+   /** VkPipelineMultisampleStateCreateInfo::sampleShadingEnable */
+   bool sample_shading_enable;
+
    /** VkPipelineMultisampleStateCreateInfo::pSampleMask */
    uint16_t sample_mask;
 
@@ -984,14 +984,6 @@ struct vk_graphics_pipeline_state {
 
    VkShaderStageFlags shader_stages;
 
-   /** Flags from VkGraphicsPipelineCreateInfo::flags that are considered part
-    * of a stage and need to be merged when linking libraries.
-    *
-    * For drivers which use vk_render_pass, this will also include flags
-    * generated based on subpass self-dependencies and fragment density map.
-    */
-   VkPipelineCreateFlags2KHR pipeline_flags;
-
    /* True if there are feedback loops that do not involve input attachments
     * managed by the driver. This is set to true by the runtime if there
     * are loops indicated by a pipeline flag (which may involve any image
@@ -1001,6 +993,14 @@ struct vk_graphics_pipeline_state {
     */
    bool feedback_loop_not_input_only;
 
+   /** Flags from VkGraphicsPipelineCreateInfo::flags that are considered part
+    * of a stage and need to be merged when linking libraries.
+    *
+    * For drivers which use vk_render_pass, this will also include flags
+    * generated based on subpass self-dependencies and fragment density map.
+    */
+   VkPipelineCreateFlags2KHR pipeline_flags;
+
    /** Vertex input state */
    const struct vk_vertex_input_state *vi;
 
diff --git a/src/vulkan/runtime/vk_image.h b/src/vulkan/runtime/vk_image.h
index 92689e619e299..a4406436fc56d 100644
--- a/src/vulkan/runtime/vk_image.h
+++ b/src/vulkan/runtime/vk_image.h
@@ -266,8 +266,8 @@ struct vk_image_view {
    struct vk_object_base base;
 
    VkImageViewCreateFlags create_flags;
-   struct vk_image *image;
    VkImageViewType view_type;
+   struct vk_image *image;
 
    /** VkImageViewCreateInfo::format or vk_image::format */
    VkFormat format;
diff --git a/src/vulkan/runtime/vk_instance.h b/src/vulkan/runtime/vk_instance.h
index 9cb5fa81e9a36..6d67abf109588 100644
--- a/src/vulkan/runtime/vk_instance.h
+++ b/src/vulkan/runtime/vk_instance.h
@@ -104,6 +104,15 @@ struct vk_instance {
     */
    struct vk_instance_extension_table enabled_extensions;
 
+   /** Enabled tracing modes */
+   bool trace_per_submit;
+   uint32_t trace_frame;
+   char *trace_trigger_file;
+
+   uint64_t trace_mode;
+
+   /** Whether the capture mode is per-submit. */
+
    /** Instance-level dispatch table */
    struct vk_instance_dispatch_table dispatch_table;
 
@@ -171,15 +180,6 @@ struct vk_instance {
       mtx_t mutex;
    } physical_devices;
 
-   /** Enabled tracing modes */
-   uint64_t trace_mode;
-
-   uint32_t trace_frame;
-   char *trace_trigger_file;
-
-   /** Whether the capture mode is per-submit. */
-   bool trace_per_submit;
-
    /** For triggering renderdoc captures from inside the driver. */
    simple_mtx_t renderdoc_mtx;
    RENDERDOC_API_1_0_0 *renderdoc_api;
diff --git a/src/vulkan/runtime/vk_queue.h b/src/vulkan/runtime/vk_queue.h
index 9d0042f0ce653..83905c1e7bee9 100644
--- a/src/vulkan/runtime/vk_queue.h
+++ b/src/vulkan/runtime/vk_queue.h
@@ -57,6 +57,46 @@ struct vk_queue {
    /* Which queue this is within the queue family */
    uint32_t index_in_family;
 
+   /**
+    * VK_EXT_debug_utils
+    *
+    * The next two fields represent debug labels storage.
+    *
+    * VK_EXT_debug_utils spec requires that upon triggering a debug message
+    * with a queue attached to it, all "active" labels will also be provided
+    * to the callback. The spec describes two distinct ways of attaching a
+    * debug label to the queue: opening a label region and inserting a single
+    * label.
+    *
+    * Label region is active between the corresponding `*BeginDebugUtilsLabel`
+    * and `*EndDebugUtilsLabel` calls. The spec doesn't mention any limits on
+    * nestedness of label regions. This implementation assumes that there
+    * aren't any.
+    *
+    * The spec, however, doesn't explain the lifetime of a label submitted by
+    * an `*InsertDebugUtilsLabel` call. The LunarG whitepaper [1] (pp 12-15)
+    * provides a more detailed explanation along with some examples. According
+    * to those, such label remains active until the next `*DebugUtilsLabel`
+    * call. This means that there can be no more than one such label at a
+    * time.
+    *
+    * ``labels`` contains all active labels at this point in order of
+    * submission ``region_begin`` denotes whether the most recent label opens
+    * a new region If ``labels`` is empty ``region_begin`` must be true.
+    *
+    * Anytime we modify labels, we first check for ``region_begin``. If it's
+    * false, it means that the most recent label was submitted by
+    * `*InsertDebugUtilsLabel` and we need to remove it before doing anything
+    * else.
+    *
+    * See the discussion here:
+    * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10318#note_1061317
+    *
+    * [1] https://www.lunarg.com/wp-content/uploads/2018/05/Vulkan-Debug-Utils_05_18_v1.pdf
+    */
+   bool region_begin;
+   struct util_dynarray labels;
+
    /** Driver queue submit hook
     *
     * When using the common implementation of vkQueueSubmit(), this function
@@ -88,14 +128,14 @@ struct vk_queue {
        */
       enum vk_queue_submit_mode mode;
 
+      bool thread_run;
+      thrd_t thread;
+
       mtx_t mutex;
       cnd_t push;
       cnd_t pop;
 
       struct list_head submits;
-
-      bool thread_run;
-      thrd_t thread;
    } submit;
 
    struct {
@@ -106,46 +146,6 @@ struct vk_queue {
       char error_msg[80];
    } _lost;
 
-   /**
-    * VK_EXT_debug_utils
-    *
-    * The next two fields represent debug labels storage.
-    *
-    * VK_EXT_debug_utils spec requires that upon triggering a debug message
-    * with a queue attached to it, all "active" labels will also be provided
-    * to the callback. The spec describes two distinct ways of attaching a
-    * debug label to the queue: opening a label region and inserting a single
-    * label.
-    *
-    * Label region is active between the corresponding `*BeginDebugUtilsLabel`
-    * and `*EndDebugUtilsLabel` calls. The spec doesn't mention any limits on
-    * nestedness of label regions. This implementation assumes that there
-    * aren't any.
-    *
-    * The spec, however, doesn't explain the lifetime of a label submitted by
-    * an `*InsertDebugUtilsLabel` call. The LunarG whitepaper [1] (pp 12-15)
-    * provides a more detailed explanation along with some examples. According
-    * to those, such label remains active until the next `*DebugUtilsLabel`
-    * call. This means that there can be no more than one such label at a
-    * time.
-    *
-    * ``labels`` contains all active labels at this point in order of
-    * submission ``region_begin`` denotes whether the most recent label opens
-    * a new region If ``labels`` is empty ``region_begin`` must be true.
-    *
-    * Anytime we modify labels, we first check for ``region_begin``. If it's
-    * false, it means that the most recent label was submitted by
-    * `*InsertDebugUtilsLabel` and we need to remove it before doing anything
-    * else.
-    *
-    * See the discussion here:
-    * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10318#note_1061317
-    *
-    * [1] https://www.lunarg.com/wp-content/uploads/2018/05/Vulkan-Debug-Utils_05_18_v1.pdf
-    */
-   struct util_dynarray labels;
-   bool region_begin;
-
 #ifdef VK_USE_PLATFORM_ANDROID_KHR
    /** SYNC_FD signal semaphore for vkQueueSignalReleaseImageANDROID
     *
@@ -231,6 +231,11 @@ struct vk_queue_submit {
    VkSparseImageOpaqueMemoryBindInfo *image_opaque_binds;
    VkSparseImageMemoryBindInfo *image_binds;
 
+   struct vk_sync **_wait_temps;
+   struct vk_sync_timeline_point **_wait_points;
+   struct vk_sync_timeline_point **_signal_points;
+   bool _has_binary_permanent_semaphore_wait;
+
    uint32_t perf_pass_index;
 
    /* Used internally; should be ignored by drivers */
@@ -238,11 +243,6 @@ struct vk_queue_submit {
    uint32_t _image_bind_entry_count;
    VkSparseMemoryBind *_bind_entries;
    VkSparseImageMemoryBind *_image_bind_entries;
-
-   bool _has_binary_permanent_semaphore_wait;
-   struct vk_sync **_wait_temps;
-   struct vk_sync_timeline_point **_wait_points;
-   struct vk_sync_timeline_point **_signal_points;
 };
 
 static inline bool
diff --git a/src/vulkan/runtime/vk_render_pass.h b/src/vulkan/runtime/vk_render_pass.h
index d4b477e8d0ef8..3802f5af90feb 100644
--- a/src/vulkan/runtime/vk_render_pass.h
+++ b/src/vulkan/runtime/vk_render_pass.h
@@ -82,21 +82,21 @@ struct vk_subpass {
    /** Count of all attachments referenced by this subpass */
    uint32_t attachment_count;
 
-   /** Array of all attachments referenced by this subpass */
-   struct vk_subpass_attachment *attachments;
-
    /** VkSubpassDescription2::inputAttachmentCount */
    uint32_t input_count;
 
+   /** Array of all attachments referenced by this subpass */
+   struct vk_subpass_attachment *attachments;
+
    /** VkSubpassDescription2::pInputAttachments */
    struct vk_subpass_attachment *input_attachments;
 
-   /** VkSubpassDescription2::colorAttachmentCount */
-   uint32_t color_count;
-
    /** VkSubpassDescription2::pColorAttachments */
    struct vk_subpass_attachment *color_attachments;
 
+   /** VkSubpassDescription2::colorAttachmentCount */
+   uint32_t color_count;
+
    /** VkSubpassDescription2::colorAttachmentCount or zero */
    uint32_t color_resolve_count;
 
@@ -120,6 +120,9 @@ struct vk_subpass {
     */
    uint32_t view_mask;
 
+   /** True if legacy dithering is enabled for this subpass. */
+   bool legacy_dithering_enabled;
+
    /** VkSubpassDescriptionDepthStencilResolve::depthResolveMode */
    VkResolveModeFlagBits depth_resolve_mode;
 
@@ -168,9 +171,6 @@ struct vk_subpass {
 
    /** VkMultisampledRenderToSingleSampledInfoEXT for this subpass */
    VkMultisampledRenderToSingleSampledInfoEXT mrtss;
-
-   /** True if legacy dithering is enabled for this subpass. */
-   bool legacy_dithering_enabled;
 };
 
 /***/
@@ -236,6 +236,9 @@ struct vk_subpass_dependency {
    /** VkSubpassDependency2::dstSubpass */
    uint32_t dst_subpass;
 
+   /** VkSubpassDependency2::viewOffset */
+   int32_t view_offset;
+
    /** VkSubpassDependency2::srcStageMask */
    VkPipelineStageFlags2 src_stage_mask;
 
@@ -247,9 +250,6 @@ struct vk_subpass_dependency {
 
    /** VkSubpassDependency2::dstAccessMask */
    VkAccessFlags2 dst_access_mask;
-
-   /** VkSubpassDependency2::viewOffset */
-   int32_t view_offset;
 };
 
 /***/
@@ -268,12 +268,12 @@ struct vk_render_pass {
    /** VkRenderPassCreateInfo2::attachmentCount */
    uint32_t attachment_count;
 
-   /** VkRenderPassCreateInfo2::pAttachments */
-   struct vk_render_pass_attachment *attachments;
-
    /** VkRenderPassCreateInfo2::subpassCount */
    uint32_t subpass_count;
 
+   /** VkRenderPassCreateInfo2::pAttachments */
+   struct vk_render_pass_attachment *attachments;
+
    /** VkRenderPassCreateInfo2::subpasses */
    struct vk_subpass *subpasses;
 
diff --git a/src/vulkan/runtime/vk_texcompress_astc.h b/src/vulkan/runtime/vk_texcompress_astc.h
index ca57e2cb5d0fd..8da2d8c1f8232 100644
--- a/src/vulkan/runtime/vk_texcompress_astc.h
+++ b/src/vulkan/runtime/vk_texcompress_astc.h
@@ -44,10 +44,10 @@ struct vk_texcompress_astc_state {
    VkBufferView partition_tbl_buf_view[VK_TEXCOMPRESS_ASTC_NUM_PARTITION_TABLES];
 
    simple_mtx_t mutex;
+   uint32_t pipeline_mask;
+   VkPipeline pipeline[VK_TEXCOMPRESS_ASTC_NUM_PARTITION_TABLES];
    VkDescriptorSetLayout ds_layout;
    VkPipelineLayout p_layout;
-   VkPipeline pipeline[VK_TEXCOMPRESS_ASTC_NUM_PARTITION_TABLES];
-   uint32_t pipeline_mask;
    VkShaderModule shader_module;
 };
 
-- 
GitLab


From 6c5fc6de37f434d70708172a54473f3435ad9fe6 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Wed, 24 Sep 2025 10:55:31 +0300
Subject: [PATCH 07/31] glx: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/glx/glxclient.h  | 32 ++++++++++++++++----------------
 src/glx/glxcurrent.c |  2 +-
 2 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index 678c98f380dce..51df40393e6b5 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -266,6 +266,12 @@ struct glx_context
    GLint bufSize;
    /*@} */
 
+   /**
+    * \c GL_TRUE if the context was created with ImportContext, which
+    * means the server-side context was created by another X client.
+    */
+   GLboolean imported;
+
    const struct glx_context_vtable *vtable;
 
     /**
@@ -283,12 +289,6 @@ struct glx_context
 
    struct glx_screen *psc;
 
-    /**
-     * \c GL_TRUE if the context was created with ImportContext, which
-     * means the server-side context was created by another X client.
-     */
-   GLboolean imported;
-
     /**
      * The context tag returned by MakeCurrent when this context is made
      * current. This tag is used to identify the context that a thread has
@@ -561,6 +561,16 @@ struct glx_display
 
    enum glx_driver driver;
 
+   /**
+    * \name Minor Version
+    *
+    * Minor version returned by the server during initialization. The major
+    * version is asserted to be 1 during extension setup.
+    */
+   /*@{ */
+   int minorVersion;
+   /*@} */
+
    /* The extension protocol codes */
    XExtCodes codes;
 
@@ -569,16 +579,6 @@ struct glx_display
      */
    Display *dpy;
 
-    /**
-     * \name Minor Version
-     *
-     * Minor version returned by the server during initialization. The major
-     * version is asserted to be 1 during extension setup.
-     */
-   /*@{ */
-   int minorVersion;
-   /*@} */
-
     /**
      * Configurations of visuals for all screens on this display.
      * Also, per screen data which now includes the server \c GLX_EXTENSION
diff --git a/src/glx/glxcurrent.c b/src/glx/glxcurrent.c
index 1a653c2a929f6..76f3920fa43e7 100644
--- a/src/glx/glxcurrent.c
+++ b/src/glx/glxcurrent.c
@@ -35,7 +35,7 @@ struct glx_context dummyContext = {
    &dummyBuffer[0],
    &dummyBuffer[__GLX_BUFFER_LIMIT_SIZE],
    sizeof(dummyBuffer),
-   &dummyVtable
+   .vtable = &dummyVtable
 };
 
 /*
-- 
GitLab


From 60cf4df4856fc0c6539a5808c0c76a2665ff6a59 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Sat, 27 Sep 2025 01:23:41 +0300
Subject: [PATCH 09/31] mesa[2]: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/mesa/main/consts_exts.h  | 139 ++++++++++++-----------
 src/mesa/main/glspirv.h      |   8 +-
 src/mesa/main/mtypes.h       | 207 ++++++++++++++++++-----------------
 src/mesa/main/shader_types.h |  60 +++++-----
 4 files changed, 208 insertions(+), 206 deletions(-)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 219b163d89593..45273edee517c 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -438,6 +438,8 @@ struct gl_constants
    } ViewportBounds;                         /**< GL_ARB_viewport_array */
    GLuint MaxWindowRectangles;               /**< GL_EXT_window_rectangles */
 
+   GLuint MaxDrawBuffers;    /**< GL_ARB_draw_buffers */
+
    struct gl_program_constants Program[MESA_SHADER_MESH_STAGES];
    GLuint MaxProgramMatrices;
    GLuint MaxProgramMatrixStackDepth;
@@ -464,8 +466,6 @@ struct gl_constants
       GLuint MeshPrimitivesGenerated;
    } QueryCounterBits;
 
-   GLuint MaxDrawBuffers;    /**< GL_ARB_draw_buffers */
-
    GLuint MaxColorAttachments;   /**< GL_EXT_framebuffer_object */
    GLuint MaxRenderbufferSize;   /**< GL_EXT_framebuffer_object */
    GLuint MaxSamples;            /**< GL_ARB_framebuffer_object */
@@ -524,12 +524,6 @@ struct gl_constants
     */
    GLboolean ForceCompatShaders;
 
-   /**
-    * If non-zero, forces GLSL shaders to behave as if they began
-    * with "#version ForceGLSLVersion".
-    */
-   GLuint ForceGLSLVersion;
-
    /**
     * Allow GLSL #extension directives in the middle of shaders.
     */
@@ -540,6 +534,12 @@ struct gl_constants
     */
    GLboolean AllowGLSL120SubsetIn110;
 
+   /**
+    * If non-zero, forces GLSL shaders to behave as if they began
+    * with "#version ForceGLSLVersion".
+    */
+   GLuint ForceGLSLVersion;
+
    /**
     * Allow builtins as part of constant expressions. This was not allowed
     * until GLSL 1.20 this allows it everywhere.
@@ -630,6 +630,9 @@ struct gl_constants
     */
    GLboolean NativeIntegers;
 
+   /** GL_ARB_viewport_array */
+   GLenum16 LayerAndVPIndexProvokingVertex;
+
    /**
     * If the driver supports real 32-bit integers, what integer value should be
     * used for boolean true in uniform uploads?  (Usually 1 or ~0.)
@@ -641,12 +644,6 @@ struct gl_constants
     */
    GLuint64 MaxServerWaitTimeout;
 
-   /** GL_EXT_provoking_vertex */
-   GLboolean QuadsFollowProvokingVertexConvention;
-
-   /** GL_ARB_viewport_array */
-   GLenum16 LayerAndVPIndexProvokingVertex;
-
    /** OpenGL version 3.0 */
    GLbitfield ContextFlags;  /**< Ex: GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT */
 
@@ -676,6 +673,9 @@ struct gl_constants
    /* GL_KHR_robustness */
    GLboolean RobustAccess;
 
+   /** GL_EXT_provoking_vertex */
+   GLboolean QuadsFollowProvokingVertexConvention;
+
    /* GL_ARB_blend_func_extended */
    GLuint MaxDualSourceDrawBuffers;
 
@@ -708,9 +708,6 @@ struct gl_constants
     */
    bool GLSLTessLevelsAsInputs;
 
-   /** GL_ARB_map_buffer_alignment */
-   GLuint MinMapBufferAlignment;
-
    /**
     * Disable varying packing.  This is out of spec, but potentially useful
     * for older platforms that supports a limited number of texture
@@ -722,6 +719,9 @@ struct gl_constants
     */
    GLboolean DisableVaryingPacking;
 
+   /** GL_ARB_map_buffer_alignment */
+   GLuint MinMapBufferAlignment;
+
    /**
     * Disable varying packing if used for transform feedback.  This is needed
     * for some drivers (e.g. Panfrost) where transform feedback requires
@@ -736,11 +736,6 @@ struct gl_constants
     */
    bool DisableUniformArrayResize;
 
-   /**
-    * Alias extension e.g. GL_ATI_shader_texture_lod to GL_ARB_shader_texture_lod.
-    */
-   char *AliasShaderExtension;
-
    /**
     * Allow fs-only bias argument in vertex shaders.
     */
@@ -753,28 +748,10 @@ struct gl_constants
     */
    GLboolean PreferPOTAlignedVaryings;
 
-
-   /**
-    * UBOs and SSBOs can be packed tightly by the OpenGL implementation when
-    * layout is set as shared (the default) or packed. However most Mesa drivers
-    * just use STD140 for these layouts. This flag allows drivers to use STD430
-    * for packed and shared layouts which allows arrays to be packed more
-    * tightly.
-    */
-   bool UseSTD430AsDefaultPacking;
-
    /**
-    * Should meaningful names be generated for compiler temporary variables?
-    *
-    * Generally, it is not useful to have the compiler generate "meaningful"
-    * names for temporary variables that it creates.  This can, however, be a
-    * useful debugging aid.  In Mesa debug builds or release builds when
-    * MESA_GLSL is set at run-time, meaningful names will be generated.
-    * Drivers can also force names to be generated by setting this field.
-    * For example, the i965 driver may set it when INTEL_DEBUG=vs (to dump
-    * vertex shader assembly) is set at run-time.
+    * Alias extension e.g. GL_ATI_shader_texture_lod to GL_ARB_shader_texture_lod.
     */
-   bool GenerateTemporaryNames;
+   char *AliasShaderExtension;
 
    /*
     * Maximum value supported for an index in DrawElements and friends.
@@ -843,11 +820,33 @@ struct gl_constants
    GLfloat MinFragmentInterpolationOffset;
    GLfloat MaxFragmentInterpolationOffset;
 
-   GLboolean FakeSWMSAA;
+   /**
+    * UBOs and SSBOs can be packed tightly by the OpenGL implementation when
+    * layout is set as shared (the default) or packed. However most Mesa drivers
+    * just use STD140 for these layouts. This flag allows drivers to use STD430
+    * for packed and shared layouts which allows arrays to be packed more
+    * tightly.
+    */
+   bool UseSTD430AsDefaultPacking;
+
+   /**
+    * Should meaningful names be generated for compiler temporary variables?
+    *
+    * Generally, it is not useful to have the compiler generate "meaningful"
+    * names for temporary variables that it creates.  This can, however, be a
+    * useful debugging aid.  In Mesa debug builds or release builds when
+    * MESA_GLSL is set at run-time, meaningful names will be generated.
+    * Drivers can also force names to be generated by setting this field.
+    * For example, the i965 driver may set it when INTEL_DEBUG=vs (to dump
+    * vertex shader assembly) is set at run-time.
+    */
+   bool GenerateTemporaryNames;
 
    /** GL_KHR_context_flush_control */
    GLenum16 ContextReleaseBehavior;
 
+   GLboolean FakeSWMSAA;
+
    /** (driconf) Force gl_Position to be considered invariant */
    GLboolean VSPositionAlwaysInvariant;
 
@@ -855,11 +854,11 @@ struct gl_constants
    GLboolean TESPositionAlwaysPrecise;
 
    /** GL_ARB_tessellation_shader */
+   bool PrimitiveRestartForPatches;
    GLuint MaxPatchVertices;
    GLuint MaxTessGenLevel;
    GLuint MaxTessPatchComponents;
    GLuint MaxTessControlTotalOutputComponents;
-   bool PrimitiveRestartForPatches;
 
    /** GL_OES_primitive_bounding_box */
    bool NoPrimitiveBoundingBoxOutput;
@@ -870,15 +869,6 @@ struct gl_constants
    /** Used as an input for sha1 generation in the on-disk shader cache */
    unsigned char *dri_config_options_sha1;
 
-   /** When drivers are OK with mapped buffers during draw and other calls. */
-   bool AllowMappedBuffersDuringExecution;
-
-   /** Override GL_MAP_UNSYNCHRONIZED_BIT */
-   bool ForceMapBufferSynchronized;
-
-   /** Override GL_DEPTH_COMPONENT type from unsigned short to unsigned int */
-   bool ForceDepthComponentTypeInt;
-
    /** GL_ARB_get_program_binary */
    GLuint NumProgramBinaryFormats;
 
@@ -892,6 +882,15 @@ struct gl_constants
    GLfloat ConservativeRasterDilateRange[2];
    GLfloat ConservativeRasterDilateGranularity;
 
+   /** When drivers are OK with mapped buffers during draw and other calls. */
+   bool AllowMappedBuffersDuringExecution;
+
+   /** Override GL_MAP_UNSYNCHRONIZED_BIT */
+   bool ForceMapBufferSynchronized;
+
+   /** Override GL_DEPTH_COMPONENT type from unsigned short to unsigned int */
+   bool ForceDepthComponentTypeInt;
+
    /** Is the drivers uniform storage packed or padded to 16 bytes. */
    bool PackedDriverUniformStorage;
 
@@ -914,13 +913,6 @@ struct gl_constants
     */
    bool UseVAOFastPath;
 
-   /** Whether the driver can support primitive restart with a fixed index.
-    * This is essentially a subset of NV_primitive_restart with enough support
-    * to be able to enable GLES 3.1. Some hardware can support this but not the
-    * full NV extension with arbitrary restart indices.
-    */
-   bool PrimitiveRestartFixedIndex;
-
    /** GL_ARB_spirv_extensions */
    struct spirv_supported_extensions *SpirVExtensions;
 
@@ -930,6 +922,19 @@ struct gl_constants
    /** Buffer size used to upload vertices from glBegin/glEnd. */
    unsigned glBeginEndBufferSize;
 
+   /** GL_ARB_sparse_texture */
+   GLuint MaxSparseTextureSize;
+   GLuint MaxSparse3DTextureSize;
+   GLuint MaxSparseArrayTextureLayers;
+   bool SparseTextureFullArrayCubeMipmaps;
+
+   /** Whether the driver can support primitive restart with a fixed index.
+    * This is essentially a subset of NV_primitive_restart with enough support
+    * to be able to enable GLES 3.1. Some hardware can support this but not the
+    * full NV extension with arbitrary restart indices.
+    */
+   bool PrimitiveRestartFixedIndex;
+
    /** Whether the driver doesn't want x/y/width/height clipped based on src size
     *  when doing a copy texture operation (eg: may want out-of-bounds reads that
     *  produce 0 instead of leaving the texture content undefined).
@@ -943,12 +948,6 @@ struct gl_constants
     */
    bool GLThreadNopCheckFramebufferStatus;
 
-   /** GL_ARB_sparse_texture */
-   GLuint MaxSparseTextureSize;
-   GLuint MaxSparse3DTextureSize;
-   GLuint MaxSparseArrayTextureLayers;
-   bool SparseTextureFullArrayCubeMipmaps;
-
    /** Use hardware accelerated GL_SELECT */
    bool HardwareAcceleratedSelect;
 
@@ -958,14 +957,14 @@ struct gl_constants
    /** Whether pipe_context::draw_vertex_state is supported. */
    bool HasDrawVertexState;
 
-   /* NV_timeline_semaphore */
-   GLuint64 MaxTimelineSemaphoreValueDifference;
-
    /** GL_KHR_shader_subgroup */
+   bool ShaderSubgroupQuadAllStages;
    GLuint ShaderSubgroupSize;
    GLuint ShaderSubgroupSupportedStages;
    GLuint ShaderSubgroupSupportedFeatures;
-   bool ShaderSubgroupQuadAllStages;
+
+   /* NV_timeline_semaphore */
+   GLuint64 MaxTimelineSemaphoreValueDifference;
 };
 
 #endif
diff --git a/src/mesa/main/glspirv.h b/src/mesa/main/glspirv.h
index 734f3b3c34d6f..59b3882e2ee9e 100644
--- a/src/mesa/main/glspirv.h
+++ b/src/mesa/main/glspirv.h
@@ -59,13 +59,13 @@ struct gl_spirv_module {
 struct gl_shader_spirv_data {
    GLint RefCount;
 
-   struct gl_spirv_module *SpirVModule;
-
-   GLchar *SpirVEntryPoint;
-
    GLuint NumSpecializationConstants;
    GLuint *SpecializationConstantsIndex;
    GLuint *SpecializationConstantsValue;
+
+   struct gl_spirv_module *SpirVModule;
+
+   GLchar *SpirVEntryPoint;
 };
 
 void
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 9d2839add9097..4aed0233ae4b4 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -246,6 +246,8 @@ struct gl_colorbuffer_attrib
 
    GLenum16 DrawBuffer[MAX_DRAW_BUFFERS];  /**< Which buffer to draw into */
 
+   GLboolean sRGBEnabled;  /**< Framebuffer sRGB blending/updating requested */
+
    /**
     * \name alpha testing
     */
@@ -280,11 +282,6 @@ struct gl_colorbuffer_attrib
    } Blend[MAX_DRAW_BUFFERS];
    /** Bitfield of color buffers with enabled dual source blending. */
    GLbitfield _BlendUsesDualSrc;
-   /** Are the blend func terms currently different for each buffer/target? */
-   GLboolean _BlendFuncPerBuffer;
-   /** Are the blend equations currently different for each buffer/target? */
-   GLboolean _BlendEquationPerBuffer;
-
    /**
     * Which advanced blending mode is in use (or BLEND_NONE).
     *
@@ -293,6 +290,10 @@ struct gl_colorbuffer_attrib
     * requires all draw buffers to match, so we only need a single value.
     */
    enum gl_advanced_blend_mode _AdvancedBlendMode;
+   /** Are the blend func terms currently different for each buffer/target? */
+   GLboolean _BlendFuncPerBuffer;
+   /** Are the blend equations currently different for each buffer/target? */
+   GLboolean _BlendEquationPerBuffer;
 
    /** Coherency requested via glEnable(GL_BLEND_ADVANCED_COHERENT_KHR)? */
    bool BlendCoherent;
@@ -313,8 +314,6 @@ struct gl_colorbuffer_attrib
    GLboolean _ClampFragmentColor;  /** < with GL_FIXED_ONLY_ARB resolved */
    GLenum16 ClampFragmentColor; /**< GL_TRUE, GL_FALSE or GL_FIXED_ONLY_ARB */
    GLenum16 ClampReadColor;     /**< GL_TRUE, GL_FALSE or GL_FIXED_ONLY_ARB */
-
-   GLboolean sRGBEnabled;  /**< Framebuffer sRGB blending/updating requested */
 };
 
 /**
@@ -360,8 +359,8 @@ struct gl_current_attrib
  */
 struct gl_depthbuffer_attrib
 {
-   GLenum16 Func;		/**< Function for depth buffer compare */
    GLclampd Clear;		/**< Value to clear depth buffer to */
+   GLenum16 Func;		/**< Function for depth buffer compare */
    GLboolean Test;		/**< Depth buffering enabled flag */
    GLboolean Mask;		/**< Depth buffer writable? */
    GLboolean BoundsTest;        /**< GL_EXT_depth_bounds_test */
@@ -660,19 +659,19 @@ struct gl_point_attrib
  */
 struct gl_polygon_attrib
 {
+   GLenum16 CullFaceMode;	/**< Culling mode GL_FRONT or GL_BACK */
    GLenum16 FrontFace;		/**< Either GL_CW or GL_CCW */
    GLenum FrontMode;		/**< Either GL_POINT, GL_LINE or GL_FILL */
    GLenum BackMode;		/**< Either GL_POINT, GL_LINE or GL_FILL */
    GLboolean CullFlag;		/**< Culling on/off flag */
    GLboolean SmoothFlag;	/**< True if GL_POLYGON_SMOOTH is enabled */
    GLboolean StippleFlag;	/**< True if GL_POLYGON_STIPPLE is enabled */
-   GLenum16 CullFaceMode;	/**< Culling mode GL_FRONT or GL_BACK */
-   GLfloat OffsetFactor;	/**< Polygon offset factor, from user */
-   GLfloat OffsetUnits;		/**< Polygon offset units, from user */
-   GLfloat OffsetClamp;		/**< Polygon offset clamp, from user */
    GLboolean OffsetPoint;	/**< Offset in GL_POINT mode */
    GLboolean OffsetLine;	/**< Offset in GL_LINE mode */
    GLboolean OffsetFill;	/**< Offset in GL_FILL mode */
+   GLfloat OffsetFactor;	/**< Polygon offset factor, from user */
+   GLfloat OffsetUnits;		/**< Polygon offset units, from user */
+   GLfloat OffsetClamp;		/**< Polygon offset clamp, from user */
 };
 
 
@@ -755,13 +754,23 @@ struct gl_stencil_attrib
 struct gl_texture_image
 {
    GLint InternalFormat;	/**< Internal format as given by the user */
+   mesa_format TexFormat;         /**< The actual texture memory format */
    GLenum16 _BaseFormat;	/**< Either GL_RGB, GL_RGBA, GL_ALPHA,
                                  *   GL_LUMINANCE, GL_LUMINANCE_ALPHA,
                                  *   GL_INTENSITY, GL_DEPTH_COMPONENT or
                                  *   GL_DEPTH_STENCIL_EXT only. Used for
                                  *   choosing TexEnv arithmetic.
                                  */
-   mesa_format TexFormat;         /**< The actual texture memory format */
+
+   /** GL_ARB_texture_multisample */
+   GLboolean FixedSampleLocations; /**< Same sample locations for all pixels? */
+   GLuint NumSamples;            /**< Sample count, or 0 for non-multisample */
+
+   /* List of transfers, allocated on demand.
+    * transfer[layer] is a mapping for that layer.
+    */
+   unsigned num_transfers;
+   struct st_texture_image_transfer *transfer;
 
    GLuint Border;		/**< 0 or 1 */
    GLuint Width;
@@ -781,21 +790,11 @@ struct gl_texture_image
    unsigned FormatSwizzle;
    unsigned FormatSwizzleGLSL130; //for depth formats
 
-   /** GL_ARB_texture_multisample */
-   GLuint NumSamples;            /**< Sample count, or 0 for non-multisample */
-   GLboolean FixedSampleLocations; /**< Same sample locations for all pixels? */
-
    /* If stImage->pt != NULL, image data is stored here.
     * Else there is no image data.
     */
    struct pipe_resource *pt;
 
-   /* List of transfers, allocated on demand.
-    * transfer[layer] is a mapping for that layer.
-    */
-   struct st_texture_image_transfer *transfer;
-   unsigned num_transfers;
-
    /* For compressed images unsupported by the driver. Keep track of
     * the original data. This is necessary for mapping/unmapping,
     * as well as image copies.
@@ -916,19 +915,21 @@ struct gl_texture_object
 {
    GLint RefCount;             /**< reference count */
    GLuint Name;                /**< the user-visible texture object ID */
-   GLenum16 Target;            /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
    GLchar *Label;              /**< GL_KHR_debug */
+   GLenum16 Target;            /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
+
+   GLboolean _BaseComplete;    /**< Is the base texture level valid? */
+   GLboolean _MipmapComplete;  /**< Is the whole mipmap valid? */
+
+   gl_texture_index TargetIndex; /**< The gl_texture_unit::CurrentTex index.
+                                   Only valid when Target is valid. */
 
    struct gl_sampler_object Sampler;
    struct gl_texture_object_attrib Attrib;  /**< State saved by glPushAttrib */
 
-   gl_texture_index TargetIndex; /**< The gl_texture_unit::CurrentTex index.
-                                      Only valid when Target is valid. */
-   GLbyte _MaxLevel;           /**< actual max mipmap level (q in the spec) */
-   GLfloat _MaxLambda;         /**< = _MaxLevel - BaseLevel (q - p in spec) */
    GLint CropRect[4];          /**< GL_OES_draw_texture */
-   GLboolean _BaseComplete;    /**< Is the base texture level valid? */
-   GLboolean _MipmapComplete;  /**< Is the whole mipmap valid? */
+   GLfloat _MaxLambda;         /**< = _MaxLevel - BaseLevel (q - p in spec) */
+   GLbyte _MaxLevel;           /**< actual max mipmap level (q in the spec) */
    GLboolean _IsIntegerFormat; /**< Does the texture store integer values? */
    GLboolean _RenderToTexture; /**< Any rendering to this texture? */
    GLboolean Immutable;        /**< GL_ARB_texture_storage */
@@ -953,6 +954,10 @@ struct gl_texture_object
    GLenum16 BufferObjectFormat;
    /** Equivalent Mesa format for BufferObjectFormat. */
    mesa_format _BufferObjectFormat;
+
+   /** GL_EXT_texture_storage_compression */
+   GLint CompressionRate; /**< Fixed-rate compression bitrate */
+
    /* TODO: BufferObject->Name should be restored by glPopAttrib(GL_TEXTURE_BIT); */
    struct gl_buffer_object *BufferObject;
 
@@ -967,17 +972,14 @@ struct gl_texture_object
    struct util_dynarray SamplerHandles;
    struct util_dynarray ImageHandles;
 
+   /** GL_EXT_texture_compression_astc_decode_mode */
+   GLenum16 AstcDecodePrecision; /**< ASTC decoding precision */
+
    /** GL_ARB_sparse_texture */
    GLboolean IsSparse;
    GLint VirtualPageSizeIndex;
    GLint NumSparseLevels;
 
-   /** GL_EXT_texture_storage_compression */
-   GLint CompressionRate; /**< Fixed-rate compression bitrate */
-
-   /** GL_EXT_texture_compression_astc_decode_mode */
-   GLenum16 AstcDecodePrecision; /**< ASTC decoding precision */
-
    /* The texture must include at levels [0..lastLevel] once validated:
     */
    GLuint lastLevel;
@@ -988,14 +990,19 @@ struct gl_texture_object
    unsigned int validated_first_level;
    unsigned int validated_last_level;
 
+   /* Protect modifications of the sampler_views array */
+   simple_mtx_t validate_mutex;
+
+   /* If surface_based is true, this format should be used for all sampler
+    * views and surfaces instead of pt->format.
+    */
+   enum pipe_format surface_format;
+
    /* On validation any active images held in main memory or in other
     * textures will be copied to this texture and the old storage freed.
     */
    struct pipe_resource *pt;
 
-   /* Protect modifications of the sampler_views array */
-   simple_mtx_t validate_mutex;
-
    /* Container of sampler views (one per context) attached to this texture
     * object. Created lazily on first binding in context.
     *
@@ -1022,22 +1029,25 @@ struct gl_texture_object
     */
    struct st_sampler_views *sampler_views_old;
 
+   /* If surface_based is true and surface_format is a YUV format, these
+    * settings should be used to convert from YUV to RGB.
+    */
+   enum gl_texture_yuv_color_space yuv_color_space;
+   bool yuv_full_range;
+
    /* True if this texture comes from the window system. Such a texture
     * cannot be reallocated and the format can only be changed with a sampler
     * view or a surface.
     */
    GLboolean surface_based;
 
-   /* If surface_based is true, this format should be used for all sampler
-    * views and surfaces instead of pt->format.
+   /**
+    * Set when the texture images of this texture object might not all be in
+    * the pipe_resource *pt above.
     */
-   enum pipe_format surface_format;
+   bool needs_validation;
 
-   /* If surface_based is true and surface_format is a YUV format, these
-    * settings should be used to convert from YUV to RGB.
-    */
-   enum gl_texture_yuv_color_space yuv_color_space;
-   bool yuv_full_range;
+   GLboolean IsProtected;
 
    /* When non-negative, samplers should use this level instead of the level
     * range specified by the GL state.
@@ -1055,14 +1065,6 @@ struct gl_texture_object
     * describes one non-array texture per field.
     */
    int layer_override;
-
-    /**
-     * Set when the texture images of this texture object might not all be in
-     * the pipe_resource *pt above.
-     */
-    bool needs_validation;
-
-    GLboolean IsProtected;
 };
 
 
@@ -1348,11 +1350,11 @@ typedef GLfloat gl_clip_plane[4];
 struct gl_transform_attrib
 {
    GLenum16 MatrixMode;				/**< Matrix mode */
+   GLboolean Normalize;				/**< Normalize all normals? */
+   GLboolean RescaleNormals;			/**< GL_EXT_rescale_normal */
    gl_clip_plane EyeUserPlane[MAX_CLIP_PLANES];	/**< User clip planes */
    gl_clip_plane _ClipUserPlane[MAX_CLIP_PLANES]; /**< derived */
    GLbitfield ClipPlanesEnabled;                /**< on/off bitmask */
-   GLboolean Normalize;				/**< Normalize all normals? */
-   GLboolean RescaleNormals;			/**< GL_EXT_rescale_normal */
    GLboolean RasterPositionUnclipped;           /**< GL_IBM_rasterpos_clip */
    GLboolean DepthClampNear;			/**< GL_AMD_depth_clamp_separate */
    GLboolean DepthClampFar;			/**< GL_AMD_depth_clamp_separate */
@@ -1596,6 +1598,12 @@ struct gl_vertex_array_object
 
    GLchar *Label;       /**< GL_KHR_debug */
 
+   /** Vertex attribute arrays */
+   struct gl_array_attributes VertexAttrib[VERT_ATTRIB_MAX];
+
+   /** Vertex buffer bindings */
+   struct gl_vertex_buffer_binding BufferBinding[VERT_ATTRIB_MAX];
+
    /**
     * Has this array object been bound?
     */
@@ -1608,12 +1616,6 @@ struct gl_vertex_array_object
     */
    bool SharedAndImmutable;
 
-   /** Vertex attribute arrays */
-   struct gl_array_attributes VertexAttrib[VERT_ATTRIB_MAX];
-
-   /** Vertex buffer bindings */
-   struct gl_vertex_buffer_binding BufferBinding[VERT_ATTRIB_MAX];
-
    /** Mask indicating which vertex arrays have vertex buffer associated. */
    GLbitfield VertexAttribBufferMask;
 
@@ -1669,6 +1671,17 @@ struct gl_array_attrib
    /** Array objects (GL_ARB_vertex_array_object) */
    struct _mesa_HashTable Objects;
 
+   /* GL_ARB_vertex_buffer_object */
+   struct gl_buffer_object *ArrayBufferObj;
+
+   /**
+    * Vertex array object that is used with the currently active draw command.
+    * The _DrawVAO is either set to the currently bound VAO for array type
+    * draws or to internal VAO's set up by the vbo module to execute immediate
+    * mode or display list draws.
+    */
+   struct gl_vertex_array_object *_DrawVAO;
+
    GLint ActiveTexture;		/**< Client Active Texture */
    GLuint LockFirst;            /**< GL_EXT_compiled_vertex_array */
    GLuint LockCount;            /**< GL_EXT_compiled_vertex_array */
@@ -1680,24 +1693,13 @@ struct gl_array_attrib
     * \c PrimitiveRestartFixedIndex is set.
     */
    /*@{*/
-   GLboolean PrimitiveRestart;
    GLboolean PrimitiveRestartFixedIndex;
    GLboolean _PrimitiveRestart[3]; /**< Enable indexed by index_size_shift. */
    GLuint RestartIndex;
    GLuint _RestartIndex[3]; /**< Restart indices indexed by index_size_shift. */
+   GLboolean PrimitiveRestart;
    /*@}*/
 
-   /* GL_ARB_vertex_buffer_object */
-   struct gl_buffer_object *ArrayBufferObj;
-
-   /**
-    * Vertex array object that is used with the currently active draw command.
-    * The _DrawVAO is either set to the currently bound VAO for array type
-    * draws or to internal VAO's set up by the vbo module to execute immediate
-    * mode or display list draws.
-    */
-   struct gl_vertex_array_object *_DrawVAO;
-
    /**
     * Whether per-vertex edge flags are enabled and should be processed by
     * the vertex shader.
@@ -1750,18 +1752,18 @@ struct gl_selection
    GLuint Hits;		/**< number of records in the selection buffer */
    GLuint NameStackDepth; /**< name stack depth */
    GLuint NameStack[MAX_NAME_STACK_DEPTH]; /**< name stack */
-   GLboolean HitFlag;	/**< hit flag */
    GLfloat HitMinZ;	/**< minimum hit depth */
    GLfloat HitMaxZ;	/**< maximum hit depth */
+   GLboolean HitFlag;	/**< hit flag */
+
+   GLboolean ResultUsed;    /**< whether any draw used result buffer */
+   GLuint ResultOffset;     /**< offset into result buffer */
+   struct gl_buffer_object *Result; /**< result buffer */
 
    /* HW GL_SELECT */
    void *SaveBuffer;        /**< array holds multi stack data */
    GLuint SaveBufferTail;   /**< offset to SaveBuffer's tail */
    GLuint SavedStackNum;    /**< number of saved stacks */
-
-   GLboolean ResultUsed;    /**< whether any draw used result buffer */
-   GLuint ResultOffset;     /**< offset into result buffer */
-   struct gl_buffer_object *Result; /**< result buffer */
 };
 
 
@@ -1862,6 +1864,9 @@ struct gl_transform_feedback_object
     */
    unsigned GlesRemainingPrims;
 
+   unsigned num_targets;
+   struct pipe_stream_output_target *targets[PIPE_MAX_SO_BUFFERS];
+
    /**
     * The program active when BeginTransformFeedback() was called.
     * When active and unpaused, this equals ctx->Shader.CurrentProgram[stage],
@@ -1890,9 +1895,6 @@ struct gl_transform_feedback_object
     */
    GLsizeiptr RequestedSize[MAX_FEEDBACK_BUFFERS];
 
-   unsigned num_targets;
-   struct pipe_stream_output_target *targets[PIPE_MAX_SO_BUFFERS];
-
    /* This encapsulates the count that can be used as a source for draw_vbo.
     * It contains stream output targets from the last call of
     * EndTransformFeedback for each stream. */
@@ -2410,6 +2412,21 @@ struct gl_shared_state
    GLint RefCount;			   /**< Reference count */
    bool DisplayListsAffectGLThread;
 
+   /**
+    * Whether at least one image has been imported or exported, excluding
+    * the default framebuffer. If this is false, glFlush can be executed
+    * asynchronously because there is no invisible dependency on external
+    * users.
+    */
+   bool HasExternallySharedImages;
+
+   /* GL_ARB_shading_language_include */
+   /* glCompileShaderInclude expects ShaderIncludes not to change while it is
+    * in progress.
+    */
+   simple_mtx_t ShaderIncludeMutex;
+   struct shader_includes *ShaderIncludes;
+
    struct list_head Contexts;   /**< gl_context objects */
    struct set ReleaseResources; /**< in use by some context */
 
@@ -2479,27 +2496,12 @@ struct gl_shared_state
    struct hash_table_u64 *ImageHandles;
    mtx_t HandlesMutex; /**< For texture/image handles safety */
 
-   /* GL_ARB_shading_language_include */
-   struct shader_includes *ShaderIncludes;
-   /* glCompileShaderInclude expects ShaderIncludes not to change while it is
-    * in progress.
-    */
-   simple_mtx_t ShaderIncludeMutex;
-
    /** EXT_external_objects */
    struct _mesa_HashTable MemoryObjects;
 
    /** EXT_semaphore */
    struct _mesa_HashTable SemaphoreObjects;
 
-   /**
-    * Whether at least one image has been imported or exported, excluding
-    * the default framebuffer. If this is false, glFlush can be executed
-    * asynchronously because there is no invisible dependency on external
-    * users.
-    */
-   bool HasExternallySharedImages;
-
    /* Small display list storage */
    struct {
       union gl_dlist_node *ptr;
@@ -2533,8 +2535,8 @@ struct gl_shared_state
  */
 struct gl_renderbuffer
 {
-   GLuint Name;
    GLchar *Label;         /**< GL_KHR_debug */
+   GLuint Name;
    GLint RefCount;
    GLuint Width, Height;
    GLuint Depth;
@@ -2567,22 +2569,23 @@ struct gl_renderbuffer
    enum pipe_format format_linear;
    enum pipe_format format_srgb;
    struct pipe_surface surface;
-   GLboolean defined;        /**< defined contents? */
 
    struct pipe_transfer *transfer; /**< only used when mapping the resource */
 
    /**
     * Used only when hardware accumulation buffers are not supported.
     */
-   bool software;
    void *data;
+   bool software;
+
+   GLboolean defined;        /**< defined contents? */
 
    bool use_readpix_cache;
 
    /* Inputs from Driver.RenderTexture, don't use directly. */
    bool is_rtt; /**< whether Driver.RenderTexture was called */
-   unsigned rtt_face, rtt_slice;
    bool rtt_layered; /**< whether glFramebufferTexture was called */
+   unsigned rtt_face, rtt_slice;
    unsigned rtt_nr_samples; /**< from FramebufferTexture2DMultisampleEXT */
    unsigned rtt_numviews;
 };
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index 1a8ea3b60a73a..9034d93047ef6 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -345,8 +345,6 @@ struct gl_shader_program_data
    /** Hash for quick search by name. */
    struct hash_table *ProgramResourceHash[NUM_PROGRAM_RESOURCE_TYPES];
 
-   GLboolean Validated;
-
    /** List of all active resources after linking. */
    struct gl_program_resource *ProgramResourceList;
    unsigned NumProgramResourceList;
@@ -357,6 +355,8 @@ struct gl_shader_program_data
    /* Mask of stages this program was linked against */
    unsigned linked_stages;
 
+   GLboolean Validated;
+
    /* Whether the shaders of this program are loaded from SPIR-V binaries
     * (all have the SPIR_V_BINARY_ARB state). This was introduced by the
     * ARB_gl_spirv extension.
@@ -370,10 +370,10 @@ struct gl_shader_program_data
  */
 struct gl_shader_program
 {
-   GLenum16 Type;   /**< Always GL_SHADER_PROGRAM (internal token) */
-   GLuint Name;  /**< aka handle or ID */
    GLchar *Label;   /**< GL_KHR_debug */
+   GLuint Name;  /**< aka handle or ID */
    GLint RefCount;  /**< Reference count */
+   GLenum16 Type;   /**< Always GL_SHADER_PROGRAM (internal token) */
    GLboolean DeletePending;
 
    /**
@@ -392,6 +392,12 @@ struct gl_shader_program
     */
    GLboolean SeparateShader;
 
+   GLboolean SamplersValidated; /**< Samplers validated against texture units? */
+
+   bool IsES;              /**< True if this program uses GLSL ES */
+
+   unsigned GLSL_Version; /**< GLSL version used for linking */
+
    GLuint NumShaders;          /**< number of attached shaders */
    struct gl_shader **Shaders; /**< List of attached the shaders */
 
@@ -453,10 +459,6 @@ struct gl_shader_program
     */
    unsigned NumExplicitUniformLocations;
 
-   GLboolean SamplersValidated; /**< Samplers validated against texture units? */
-
-   bool IsES;              /**< True if this program uses GLSL ES */
-
    /**
     * Per-stage shaders resulting from the first stage of linking.
     *
@@ -465,8 +467,6 @@ struct gl_shader_program
     * \c NULL.
     */
    struct gl_linked_shader *_LinkedShaders[MESA_SHADER_MESH_STAGES];
-
-   unsigned GLSL_Version; /**< GLSL version used for linking */
 };
 
 /**
@@ -485,6 +485,13 @@ struct gl_program
 
    GLboolean _Used;        /**< Ever used for drawing? Used for debugging */
 
+   /** whether to skip VARYING_SLOT_PSIZ in st_translate_stream_output_info() */
+   bool skip_pointsize_xfb;
+
+   st_state_bitset affected_states; /**< ST_NEW_* flags to mark dirty when binding */
+   struct pipe_shader_state state;
+   struct ati_fragment_shader *ati_fs;
+
    struct nir_shader *nir;
    void *base_serialized_nir;
    size_t base_serialized_nir_size;
@@ -493,9 +500,6 @@ struct gl_program
    void *driver_cache_blob;
    size_t driver_cache_blob_size;
 
-   /** whether to skip VARYING_SLOT_PSIZ in st_translate_stream_output_info() */
-   bool skip_pointsize_xfb;
-
    /** A bitfield indicating which vertex shader inputs consume two slots
     *
     * This is used for mapping from single-slot input locations in the GL API
@@ -522,19 +526,15 @@ struct gl_program
    /** Texture units used for samplerExternalOES */
    GLbitfield ExternalSamplersUsed;
 
+   unsigned serialized_nir_size;
+   void *serialized_nir;
+
    /** Named parameters, constants, etc. from program text */
    struct gl_program_parameter_list *Parameters;
 
    /** Map from sampler unit to texture unit (set by glUniform1i()) */
    GLubyte SamplerUnits[MAX_SAMPLERS];
 
-   struct pipe_shader_state state;
-   struct ati_fragment_shader *ati_fs;
-   st_state_bitset affected_states; /**< ST_NEW_* flags to mark dirty when binding */
-
-   void *serialized_nir;
-   unsigned serialized_nir_size;
-
    struct gl_shader_program *shader_program;
 
    struct st_variant *variants;
@@ -550,6 +550,10 @@ struct gl_program
          /** Post-link transform feedback info. */
          struct gl_transform_feedback_info *LinkedTransformFeedback;
 
+         struct gl_uniform_block **UniformBlocks;
+         struct gl_uniform_block **ShaderStorageBlocks;
+         GLuint NumUniformBlocks;
+
          /**
           * Number of types for subroutine uniforms.
           */
@@ -583,10 +587,6 @@ struct gl_program
           */
          enum gl_access_qualifier image_access[MAX_IMAGE_UNIFORMS];
 
-         GLuint NumUniformBlocks;
-         struct gl_uniform_block **UniformBlocks;
-         struct gl_uniform_block **ShaderStorageBlocks;
-
          /**
           * Bitmask of shader storage blocks not declared as read-only.
           */
@@ -795,11 +795,6 @@ struct gl_uniform_storage {
 
    struct gl_opaque_uniform_index opaque[MESA_SHADER_MESH_STAGES];
 
-   /**
-    * Mask of shader stages (1 << MESA_SHADER_xxx) where this uniform is used.
-    */
-   unsigned active_shader_mask;
-
    /**
     * Storage used by the driver for the uniform
     */
@@ -815,6 +810,11 @@ struct gl_uniform_storage {
     */
    union gl_constant_value *storage;
 
+   /**
+    * Mask of shader stages (1 << MESA_SHADER_xxx) where this uniform is used.
+    */
+   unsigned active_shader_mask;
+
    /** Fields for GL_ARB_uniform_buffer_object
     * @{
     */
@@ -959,8 +959,8 @@ struct gl_subroutine_function
  */
 struct gl_program_resource
 {
-   GLenum16 Type; /** Program interface type. */
    const void *Data; /** Pointer to resource associated data structure. */
+   GLenum16 Type; /** Program interface type. */
    uint8_t StageReferences; /** Bitmask of shader stage references. */
 };
 
-- 
GitLab


From 143e3d45eae628edb6a7ce6202fc4227761aac7b Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:07:15 +0300
Subject: [PATCH 10/31] vbo: added sse4.1 for vbo minmax with unsigned byte and
 unsigned short indices

---
 src/mesa/vbo/vbo_minmax_index.c | 24 ++++++++++++++++++------
 1 file changed, 18 insertions(+), 6 deletions(-)

diff --git a/src/mesa/vbo/vbo_minmax_index.c b/src/mesa/vbo/vbo_minmax_index.c
index 5f81d5024cf47..144a7611e043a 100644
--- a/src/mesa/vbo/vbo_minmax_index.c
+++ b/src/mesa/vbo/vbo_minmax_index.c
@@ -276,10 +276,16 @@ vbo_get_minmax_index_mapped(unsigned count, unsigned index_size,
          }
       }
       else {
-         for (unsigned i = 0; i < count; i++) {
-            if (us_indices[i] > max_us) max_us = us_indices[i];
-            if (us_indices[i] < min_us) min_us = us_indices[i];
+#if defined(USE_SSE41)
+         if (util_get_cpu_caps()->has_sse4_1) {
+            _mesa_uint_array_min_max((const GLuint *)us_indices, &min_us, &max_us, count);
          }
+         else
+#endif
+            for (unsigned i = 0; i < count; i++) {
+               if (us_indices[i] > max_us) max_us = us_indices[i];
+               if (us_indices[i] < min_us) min_us = us_indices[i];
+            }
       }
       *min_index = min_us;
       *max_index = max_us;
@@ -298,10 +304,16 @@ vbo_get_minmax_index_mapped(unsigned count, unsigned index_size,
          }
       }
       else {
-         for (unsigned i = 0; i < count; i++) {
-            if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
-            if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
+#if defined(USE_SSE41)
+         if (util_get_cpu_caps()->has_sse4_1) {
+            _mesa_uint_array_min_max((const GLuint *)ub_indices, &min_ub, &max_ub, count);
          }
+         else
+#endif
+            for (unsigned i = 0; i < count; i++) {
+               if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
+               if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
+            }
       }
       *min_index = min_ub;
       *max_index = max_ub;
-- 
GitLab


From abb87973056ce4dc6eb497478d3dad4d0c0a99a4 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:20:56 +0300
Subject: [PATCH 11/31] intel/vulkan/isl: added memcpy SIMD for two functions

Affected functions:
- anv_copy_image_memory
- convert_texture
---
 .../isl/tests/isl_tilememcpy_tiled_unittest.cpp      | 12 ++++++++++--
 src/intel/vulkan/anv_image_host_copy.c               |  6 ++++--
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/src/intel/isl/tests/isl_tilememcpy_tiled_unittest.cpp b/src/intel/isl/tests/isl_tilememcpy_tiled_unittest.cpp
index 24286710e8fd3..28ec81a41277e 100644
--- a/src/intel/isl/tests/isl_tilememcpy_tiled_unittest.cpp
+++ b/src/intel/isl/tests/isl_tilememcpy_tiled_unittest.cpp
@@ -335,13 +335,21 @@ void tileTFixture::convert_texture(uint32_t x1_el, uint32_t x2_el, uint32_t y1_e
                                  (char *)buf_dst,
                                  (const char *)buf_src + linear_offset_B,
                                  tiled_pitch_B, linear_pitch_B,
-                                 0, ops.tiling, ISL_MEMCPY);
+                                 0, ops.tiling,
+#if defined(USE_SSE41)
+                                 util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
+#endif
+                                 ISL_MEMCPY);
    else
       isl_memcpy_tiled_to_linear(x1_el * fmt_bs, x2_el * fmt_bs, y1_el, y2_el,
                                  (char *)buf_dst + linear_offset_B,
                                  (const char *)buf_src,
                                  linear_pitch_B, tiled_pitch_B,
-                                 0, ops.tiling, ISL_MEMCPY);
+                                 0, ops.tiling,
+#if defined(USE_SSE41)
+                                 util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
+#endif
+                                 ISL_MEMCPY);
 
    if (print_results) {
       printf("/************** Printing dest **************/\n");
diff --git a/src/intel/vulkan/anv_image_host_copy.c b/src/intel/vulkan/anv_image_host_copy.c
index 597ea1edba00f..650bbdc835cd0 100644
--- a/src/intel/vulkan/anv_image_host_copy.c
+++ b/src/intel/vulkan/anv_image_host_copy.c
@@ -145,6 +145,9 @@ anv_copy_image_memory(struct anv_device *device,
                                     mem_row_pitch_B,
                                     false,
                                     surf->tiling,
+#if defined(USE_SSE41)
+                                    util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
+#endif
                                     ISL_MEMCPY);
       } else {
          isl_memcpy_tiled_to_linear(x1, x2, y1, y2,
@@ -155,8 +158,7 @@ anv_copy_image_memory(struct anv_device *device,
                                     false,
                                     surf->tiling,
 #if defined(USE_SSE41)
-                                    util_get_cpu_caps()->has_sse4_1 ?
-                                    ISL_MEMCPY_STREAMING_LOAD :
+                                    util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
 #endif
                                     ISL_MEMCPY);
       }
-- 
GitLab


From 4963015c41c7aeeb3be4b473f04cb5ad6bdee0c3 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:24:31 +0300
Subject: [PATCH 12/31] gallium: added memcpy SIMD for three functions

Affected functions:
- crocus_unmap_tiled_memcpy
- iris_unmap_tiled_memcpy
- iris_map_tiled_memcpy
---
 src/gallium/drivers/crocus/crocus_resource.c |  6 +++++-
 src/gallium/drivers/iris/iris_resource.c     | 15 +++++++++++----
 2 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/crocus/crocus_resource.c b/src/gallium/drivers/crocus/crocus_resource.c
index 944792f4d19bb..9d1ababa6708d 100644
--- a/src/gallium/drivers/crocus/crocus_resource.c
+++ b/src/gallium/drivers/crocus/crocus_resource.c
@@ -1422,7 +1422,11 @@ crocus_unmap_tiled_memcpy(struct crocus_transfer *map)
          isl_memcpy_linear_to_tiled(x1, x2, y1, y2, dst, ptr,
                                     surf->row_pitch_B, xfer->stride,
                                     map->has_swizzling,
-                                    surf->tiling, ISL_MEMCPY);
+                                    surf->tiling,
+#if defined(USE_SSE41)
+                                    util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
+#endif
+                                    ISL_MEMCPY);
       }
    }
    os_free_aligned(map->buffer);
diff --git a/src/gallium/drivers/iris/iris_resource.c b/src/gallium/drivers/iris/iris_resource.c
index 78f380a681a63..ae0eb9118cf5a 100644
--- a/src/gallium/drivers/iris/iris_resource.c
+++ b/src/gallium/drivers/iris/iris_resource.c
@@ -2213,7 +2213,11 @@ iris_unmap_tiled_memcpy(struct iris_transfer *map)
 
          isl_memcpy_linear_to_tiled(x1, x2, y1, y2, dst, ptr,
                                     surf->row_pitch_B, xfer->stride,
-                                    has_swizzling, surf->tiling, ISL_MEMCPY);
+                                    has_swizzling, surf->tiling,
+#if defined(USE_SSE41)
+                                    util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
+#endif
+                                    ISL_MEMCPY);
       }
    }
    os_free_aligned(map->buffer);
@@ -2260,8 +2264,7 @@ iris_map_tiled_memcpy(struct iris_transfer *map)
                                     surf->row_pitch_B, has_swizzling,
                                     surf->tiling,
 #if defined(USE_SSE41)
-                                    util_get_cpu_caps()->has_sse4_1 ?
-                                    ISL_MEMCPY_STREAMING_LOAD :
+                                    util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
 #endif
                                     ISL_MEMCPY);
       }
@@ -2635,7 +2638,11 @@ iris_texture_subdata(struct pipe_context *ctx,
       isl_memcpy_linear_to_tiled(x1, x2, y1, y2,
                                  (void *)dst, (void *)src,
                                  surf->row_pitch_B, stride,
-                                 false, surf->tiling, ISL_MEMCPY);
+                                 false, surf->tiling,
+#if defined(USE_SSE41)
+                                 util_get_cpu_caps()->has_sse4_1 ? ISL_MEMCPY_STREAMING_LOAD :
+#endif
+                                 ISL_MEMCPY);
    }
 }
 
-- 
GitLab


From cc8a0397ac41ebb745d99509677619f559022698 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:29:33 +0300
Subject: [PATCH 13/31] vbo: micro-op Clang/GCC using disassembler with -O3
 flag

---
 src/mesa/vbo/vbo_exec.c      | 19 +++++++---------
 src/mesa/vbo/vbo_exec_api.c  | 23 ++++++++-----------
 src/mesa/vbo/vbo_exec_draw.c | 44 +++++++++++++-----------------------
 src/mesa/vbo/vbo_private.h   | 22 +++++++-----------
 src/mesa/vbo/vbo_util.h      | 26 +++++++--------------
 5 files changed, 49 insertions(+), 85 deletions(-)

diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index c669fbd603f04..4a18d97026a8f 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -296,18 +296,15 @@ vbo_copy_vertices(struct gl_context *ctx,
       copy = MIN2(3, count);
       break;
    case GL_PATCHES:
-      if (in_dlist) {
-         /* We don't know the value of GL_PATCH_VERTICES when compiling
-          * a display list.
-          *
-          * Fail an assertion in debug builds and use the value of 3
-          * in release builds, which is more likely than any other value.
-          */
+      /* We don't know the value of GL_PATCH_VERTICES when compiling
+       * a display list.
+       *
+       * Fail an assertion in debug builds and use the value of 3
+       * in release builds, which is more likely than any other value.
+       */
+      if (in_dlist)
          assert(!"patch_vertices is unknown");
-         copy = count % 3;
-      } else {
-         copy = count % ctx->TessCtrlProgram.patch_vertices;
-      }
+      copy = count % (in_dlist ? 3 : ctx->TessCtrlProgram.patch_vertices);
       break;
    case GL_LINE_LOOP:
       if (!in_dlist && begin == 0) {
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index 1cca0e37ec58e..0957dbfc70381 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -198,21 +198,16 @@ vbo_exec_copy_to_current(struct vbo_exec_context *exec)
          if (i == VBO_ATTRIB_COLOR0)
             color0_changed = true;
 
-         if (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT) {
-            ctx->NewState |= _NEW_MATERIAL;
-            ctx->PopAttribState |= GL_LIGHTING_BIT;
-
-            /* The fixed-func vertex program uses this. */
-            if (i == VBO_ATTRIB_MAT_FRONT_SHININESS ||
-                i == VBO_ATTRIB_MAT_BACK_SHININESS)
-               ctx->NewState |= _NEW_FF_VERT_PROGRAM;
-         } else {
-            if (i == VBO_ATTRIB_EDGEFLAG)
-               _mesa_update_edgeflag_state_vao(ctx);
+         if (i == VBO_ATTRIB_EDGEFLAG)
+            _mesa_update_edgeflag_state_vao(ctx);
 
-            ctx->NewState |= _NEW_CURRENT_ATTRIB;
-            ctx->PopAttribState |= GL_CURRENT_BIT;
-         }
+         ctx->NewState |= (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT ? _NEW_MATERIAL : _NEW_CURRENT_ATTRIB);
+         ctx->PopAttribState |= (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT ? GL_LIGHTING_BIT : GL_CURRENT_BIT);
+
+         /* The fixed-func vertex program uses this. */
+         if (i == VBO_ATTRIB_MAT_FRONT_SHININESS ||
+             i == VBO_ATTRIB_MAT_BACK_SHININESS)
+            ctx->NewState |= _NEW_FF_VERT_PROGRAM;
       }
 
       /* Given that we explicitly state size here, there is no need
diff --git a/src/mesa/vbo/vbo_exec_draw.c b/src/mesa/vbo/vbo_exec_draw.c
index 34ef4b705127a..73f7d3b29ddcc 100644
--- a/src/mesa/vbo/vbo_exec_draw.c
+++ b/src/mesa/vbo/vbo_exec_draw.c
@@ -93,25 +93,19 @@ vbo_exec_bind_arrays(struct gl_context *ctx,
    struct vbo_exec_context *exec = &vbo->exec;
 
    GLintptr buffer_offset;
-   if (exec->vtx.bufferobj) {
-      assert(exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Pointer);
-      buffer_offset = exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset +
-                      exec->vtx.buffer_offset;
-   } else {
-      /* Ptr into ordinary app memory */
-      buffer_offset = (GLbyte *)exec->vtx.buffer_map - (GLbyte *)NULL;
-   }
+   assert(exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Pointer);
+   buffer_offset = exec->vtx.bufferobj ?
+      exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset + exec->vtx.buffer_offset :
+      (GLbyte *)exec->vtx.buffer_map - (GLbyte *)NULL; /* Ptr into ordinary app memory */
 
    const gl_vertex_processing_mode mode = ctx->VertexProgram._VPMode;
 
    GLbitfield vao_enabled, vao_filter;
-   if (_mesa_hw_select_enabled(ctx)) {
-      /* HW GL_SELECT has fixed input */
-      vao_enabled = vao_filter = VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET;
-   } else {
-      vao_enabled = _vbo_get_vao_enabled_from_vbo(mode, exec->vtx.enabled);
-      vao_filter = _vbo_get_vao_filter(mode);
-   }
+   /* HW GL_SELECT has fixed input */
+   vao_enabled = _mesa_hw_select_enabled(ctx) ? VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET
+      : _vbo_get_vao_enabled_from_vbo(mode, exec->vtx.enabled);
+   vao_filter = _mesa_hw_select_enabled(ctx) ? VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET
+      : _vbo_get_vao_filter(mode);
 
    /* At first disable arrays no longer needed */
    _mesa_disable_vertex_array_attribs(ctx, vao, ~vao_enabled);
@@ -211,19 +205,13 @@ vbo_exec_vtx_map(struct vbo_exec_context *exec)
    GLenum accessRange = GL_MAP_WRITE_BIT |  /* for MapBufferRange */
                         GL_MAP_UNSYNCHRONIZED_BIT;
 
-   if (ctx->Extensions.ARB_buffer_storage) {
-      /* We sometimes read from the buffer, so map it for read too.
-       * Only the persistent mapping can do that, because the non-persistent
-       * mapping uses flags that are incompatible with GL_MAP_READ_BIT.
-       */
-      accessRange |= GL_MAP_PERSISTENT_BIT |
-                     GL_MAP_COHERENT_BIT |
-                     GL_MAP_READ_BIT;
-   } else {
-      accessRange |= GL_MAP_INVALIDATE_RANGE_BIT |
-                     GL_MAP_FLUSH_EXPLICIT_BIT |
-                     MESA_MAP_NOWAIT_BIT;
-   }
+   /* We sometimes read from the buffer, so map it for read too.
+    * Only the persistent mapping can do that, because the non-persistent
+    * mapping uses flags that are incompatible with GL_MAP_READ_BIT.
+    */
+   accessRange |= ctx->Extensions.ARB_buffer_storage ?
+      GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT | GL_MAP_READ_BIT
+      : GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT | MESA_MAP_NOWAIT_BIT;
 
    if (!exec->vtx.bufferobj)
       return;
diff --git a/src/mesa/vbo/vbo_private.h b/src/mesa/vbo/vbo_private.h
index 054f38c661428..e19056768fa5d 100644
--- a/src/mesa/vbo/vbo_private.h
+++ b/src/mesa/vbo/vbo_private.h
@@ -212,12 +212,9 @@ vbo_copy_vertices(struct gl_context *ctx,
 static inline GLbitfield
 _vbo_get_vao_filter(gl_vertex_processing_mode vertex_processing_mode)
 {
-   if (vertex_processing_mode == VP_MODE_FF) {
-      /* The materials mapped into the generic arrays */
-      return VERT_BIT_FF_ALL | VERT_BIT_MAT_ALL;
-   } else {
-      return VERT_BIT_ALL;
-   }
+   /* The materials mapped into the generic arrays */
+   return (vertex_processing_mode == VP_MODE_FF)
+      ? (VERT_BIT_FF_ALL | VERT_BIT_MAT_ALL) : VERT_BIT_ALL;
 }
 
 
@@ -229,14 +226,11 @@ _vbo_get_vao_filter(gl_vertex_processing_mode vertex_processing_mode)
 static inline GLbitfield
 _vbo_get_vao_enabled_from_vbo(gl_vertex_processing_mode vertex_processing_mode,
                               GLbitfield64 enabled)
-{
-   if (vertex_processing_mode == VP_MODE_FF) {
-      /* The materials mapped into the generic arrays */
-      return (((GLbitfield)enabled) & VERT_BIT_FF_ALL)
-         | (((GLbitfield)(enabled >> VBO_MATERIAL_SHIFT)) & VERT_BIT_MAT_ALL);
-   } else {
-      return enabled;
-   }
+{ /* The materials mapped into the generic arrays */
+   return (vertex_processing_mode == VP_MODE_FF)
+      ? (((GLbitfield)enabled) & VERT_BIT_FF_ALL)
+         | (((GLbitfield)(enabled >> VBO_MATERIAL_SHIFT)) & VERT_BIT_MAT_ALL)
+      : enabled;
 }
 
 
diff --git a/src/mesa/vbo/vbo_util.h b/src/mesa/vbo/vbo_util.h
index 1dd415b2de88a..890da5bdf5a5a 100644
--- a/src/mesa/vbo/vbo_util.h
+++ b/src/mesa/vbo/vbo_util.h
@@ -80,15 +80,10 @@ static inline float conv_i10_to_norm_float(const struct gl_context *ctx, int i10
     * OpenGL 4.2+ and ES 3.0 remedy this and state that equation 2.3 (above)
     * is used in every case.  They remove equation 2.2 completely.
     */
-   if (_mesa_is_gles3(ctx) ||
-       (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) {
-      /* Equation 2.3 above. */
-      float f = ((float) val.x) / 511.0F;
-      return MAX2(f, -1.0f);
-   } else {
-      /* Equation 2.2 above. */
-      return (2.0F * (float)val.x + 1.0F) * (1.0F  / 1023.0F);
-   }
+   return (_mesa_is_gles3(ctx) ||
+           (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) ?
+          MAX2(((float) val.x) / 511.0F, -1.0f) : /* Equation 2.3 above. */
+          (2.0F * (float)val.x + 1.0F) * (1.0F  / 1023.0F); /* Equation 2.2 above. */
 }
 
 static inline float conv_i2_to_norm_float(const struct gl_context *ctx, int i2)
@@ -96,15 +91,10 @@ static inline float conv_i2_to_norm_float(const struct gl_context *ctx, int i2)
    struct attr_bits_2 val;
    val.x = i2;
 
-   if (_mesa_is_gles3(ctx) ||
-       (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) {
-      /* Equation 2.3 above. */
-      float f = (float) val.x;
-      return MAX2(f, -1.0f);
-   } else {
-      /* Equation 2.2 above. */
-      return (2.0F * (float)val.x + 1.0F) * (1.0F / 3.0F);
-   }
+   return (_mesa_is_gles3(ctx) ||
+           (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) ?
+          MAX2((float) val.x, -1.0f) :
+          (2.0F * (float)val.x + 1.0F) * (1.0F / 3.0F);
 }
 
 #define ERROR_IF_NOT_PACKED_TYPE(ctx, type, func) \
-- 
GitLab


From df47570f082ef8b4d84ffd397a283b9fbb838d09 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:31:50 +0300
Subject: [PATCH 14/31] state_tracker: micro-op Clang/GCC using disassembler
 with -O3 flag

---
 src/mesa/state_tracker/st_atifs_to_nir.c  | 53 ++++++++---------------
 src/mesa/state_tracker/st_atom_array.cpp  | 29 ++++---------
 src/mesa/state_tracker/st_atom_constbuf.c |  6 +--
 src/mesa/state_tracker/st_atom_image.c    | 15 +++----
 src/mesa/state_tracker/st_atom_sampler.c  | 12 ++---
 src/mesa/state_tracker/st_atom_shader.c   |  9 +---
 src/mesa/state_tracker/st_cb_eglimage.c   | 26 +++++------
 src/mesa/state_tracker/st_extensions.c    | 15 ++-----
 src/mesa/state_tracker/st_format.c        | 10 ++---
 src/mesa/state_tracker/st_glsl_to_nir.cpp | 39 +++++------------
 src/mesa/state_tracker/st_pbo.c           | 19 +++-----
 src/mesa/state_tracker/st_pbo_compute.c   | 30 ++++---------
 src/mesa/state_tracker/st_program.c       |  9 +---
 src/mesa/state_tracker/st_sampler_view.c  | 21 ++++-----
 14 files changed, 89 insertions(+), 204 deletions(-)

diff --git a/src/mesa/state_tracker/st_atifs_to_nir.c b/src/mesa/state_tracker/st_atifs_to_nir.c
index c534ae008d8a0..4fbcad82465b3 100644
--- a/src/mesa/state_tracker/st_atifs_to_nir.c
+++ b/src/mesa/state_tracker/st_atifs_to_nir.c
@@ -133,33 +133,24 @@ atifs_load_uniform(struct st_translate *t, int index)
 static struct nir_def *
 get_source(struct st_translate *t, GLenum src_type)
 {
-   if (src_type >= GL_REG_0_ATI && src_type <= GL_REG_5_ATI) {
-      if (t->regs_written[t->current_pass][src_type - GL_REG_0_ATI]) {
-         return get_temp(t, src_type - GL_REG_0_ATI);
-      } else {
-         return nir_imm_vec4_float(t->b, 0.0);
-      }
-   } else if (src_type >= GL_CON_0_ATI && src_type <= GL_CON_7_ATI) {
-      int index = src_type - GL_CON_0_ATI;
-      if (t->atifs->LocalConstDef & (1 << index)) {
-         return nir_imm_vec4(t->b,
-                             t->atifs->Constants[index][0],
-                             t->atifs->Constants[index][1],
-                             t->atifs->Constants[index][2],
-                             t->atifs->Constants[index][3]);
-      } else {
-         return atifs_load_uniform(t, index);
-      }
-   } else if (src_type == GL_ZERO) {
+   if (src_type >= GL_REG_0_ATI && src_type <= GL_REG_5_ATI)
+      return t->regs_written[t->current_pass][src_type - GL_REG_0_ATI] ?
+             get_temp(t, src_type - GL_REG_0_ATI) : nir_imm_vec4_float(t->b, 0.0);
+   else if (src_type >= GL_CON_0_ATI && src_type <= GL_CON_7_ATI) {
+      const int index = src_type - GL_CON_0_ATI;
+      return (t->atifs->LocalConstDef & (1 << index)) ?
+             nir_imm_vec4(t->b, t->atifs->Constants[index][0], t->atifs->Constants[index][1],
+                                 t->atifs->Constants[index][2], t->atifs->Constants[index][3]) :
+             atifs_load_uniform(t, index);
+   } else if (src_type == GL_ZERO)
       return nir_imm_vec4_float(t->b, 0.0);
-   } else if (src_type == GL_ONE) {
+   else if (src_type == GL_ONE)
       return nir_imm_vec4_float(t->b, 1.0);
-   } else if (src_type == GL_PRIMARY_COLOR_ARB) {
+   else if (src_type == GL_PRIMARY_COLOR_ARB)
       return load_input(t, VARYING_SLOT_COL0);
-   } else if (src_type == GL_SECONDARY_INTERPOLATOR_ATI) {
+   else if (src_type == GL_SECONDARY_INTERPOLATOR_ATI)
       return load_input(t, VARYING_SLOT_COL1);
-   } else {
-      /* frontend prevents this */
+   else { /* frontend prevents this */
       UNREACHABLE("unknown source");
    }
 }
@@ -322,11 +313,7 @@ compile_setupinst(struct st_translate *t,
       unsigned reg = pass_tex - GL_REG_0_ATI;
 
       /* the frontend already validated that REG is only allowed in second pass */
-      if (t->regs_written[0][reg]) {
-         coord = t->temps[reg];
-      } else {
-         coord = nir_imm_vec4_float(t->b, 0.0f);
-      }
+      coord = t->regs_written[0][reg] ? t->temps[reg] : nir_imm_vec4_float(t->b, 0.0f);
    } else {
       coord = nir_undef(t->b, 4, 32);
    }
@@ -496,13 +483,9 @@ st_nir_lower_atifs_samplers_instr(nir_builder *b, nir_instr *instr, void *data)
 
    unsigned unit;
    int sampler_src_idx = nir_tex_instr_src_index(tex, nir_tex_src_sampler_deref);
-   if (sampler_src_idx >= 0) {
-      nir_deref_instr *deref = nir_src_as_deref(tex->src[sampler_src_idx].src);
-      nir_variable *var = nir_deref_instr_get_variable(deref);
-      unit = var->data.binding;
-   } else {
-      unit = tex->sampler_index;
-   }
+   nir_deref_instr *deref = nir_src_as_deref(tex->src[sampler_src_idx].src);
+   nir_variable *var = nir_deref_instr_get_variable(deref);
+   unit = sampler_src_idx >= 0 ? var->data.binding : tex->sampler_index;
 
    bool is_array;
    tex->sampler_dim =
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index ac48f859347b9..eb5dd648097dd 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -136,14 +136,10 @@ setup_arrays(struct gl_context *ctx,
          const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&mask);
          const struct gl_array_attributes *attrib;
          const struct gl_vertex_buffer_binding *binding;
-
-         if (HAS_IDENTITY_ATTRIB_MAPPING) {
-            attrib = &vao->VertexAttrib[attr];
-            binding = &vao->BufferBinding[attr];
-         } else {
-            attrib = &vao->VertexAttrib[attribute_map[attr]];
-            binding = &vao->BufferBinding[attrib->BufferBindingIndex];
-         }
+         attrib = HAS_IDENTITY_ATTRIB_MAPPING ? &vao->VertexAttrib[attr] :
+                                                &vao->VertexAttrib[attribute_map[attr]];
+         binding = HAS_IDENTITY_ATTRIB_MAPPING ? &vao->BufferBinding[attr] :
+                                                 &vao->BufferBinding[attrib->BufferBindingIndex];
          const unsigned bufidx = (*num_vbuffers)++;
 
          /* Set the vertex buffer. */
@@ -211,19 +207,10 @@ setup_arrays(struct gl_context *ctx,
       const struct gl_vertex_buffer_binding *const binding
          = _mesa_draw_buffer_binding(vao, i);
       const unsigned bufidx = (*num_vbuffers)++;
-
-      if (binding->BufferObj) {
-         /* Set the binding */
-         vbuffer[bufidx].buffer.resource = binding->BufferObj->buffer;
-         vbuffer[bufidx].is_user_buffer = false;
-         vbuffer[bufidx].buffer_offset = _mesa_draw_binding_offset(binding);
-      } else {
-         /* Set the binding */
-         const void *ptr = (const void *)_mesa_draw_binding_offset(binding);
-         vbuffer[bufidx].buffer.user = ptr;
-         vbuffer[bufidx].is_user_buffer = true;
-         vbuffer[bufidx].buffer_offset = 0;
-      }
+      vbuffer[bufidx].buffer.resource = binding->BufferObj ? binding->BufferObj->buffer : NULL;
+      vbuffer[bufidx].is_user_buffer = !binding->BufferObj;
+      vbuffer[bufidx].buffer_offset = binding->BufferObj ? _mesa_draw_binding_offset(binding) : 0;
+      vbuffer[bufidx].buffer.user = binding->BufferObj ? NULL : (const void *)_mesa_draw_binding_offset(binding);
 
       const GLbitfield boundmask = _mesa_draw_bound_attrib_bits(binding);
       GLbitfield attrmask = mask & boundmask;
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 737372e003464..88a4c6be1acd0 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -304,11 +304,7 @@ st_bind_ubos(struct st_context *st, struct gl_program *prog,
       binding =
          &st->ctx->UniformBufferBindings[prog->sh.UniformBlocks[i]->Binding];
 
-      if (binding->BufferObject) {
-         cb.buffer = binding->BufferObject->buffer;
-      } else {
-         cb.buffer = NULL;
-      }
+      cb.buffer = binding->BufferObject ? binding->BufferObject->buffer : NULL;
 
       if (cb.buffer) {
          cb.buffer_offset = binding->Offset;
diff --git a/src/mesa/state_tracker/st_atom_image.c b/src/mesa/state_tracker/st_atom_image.c
index 95f5f89a505de..1493bc8d2b331 100644
--- a/src/mesa/state_tracker/st_atom_image.c
+++ b/src/mesa/state_tracker/st_atom_image.c
@@ -106,15 +106,12 @@ st_convert_image(const struct st_context *st, const struct gl_image_unit *u,
       img->u.tex.level = u->Level + stObj->Attrib.MinLevel;
       img->u.tex.single_layer_view = !u->Layered;
       assert(img->u.tex.level <= img->resource->last_level);
-      if (stObj->pt->target == PIPE_TEXTURE_3D) {
-         if (u->Layered) {
-            img->u.tex.first_layer = 0;
-            img->u.tex.last_layer = u_minify(stObj->pt->depth0, img->u.tex.level) - 1;
-         } else {
-            img->u.tex.first_layer = u->_Layer;
-            img->u.tex.last_layer = u->_Layer;
-            img->u.tex.is_2d_view_of_3d = true;
-         }
+      if (stObj->pt->target == PIPE_TEXTURE_3D) { /* 3D texture */
+         img->u.tex.first_layer = u->Layered ? 0 : u->_Layer;
+         img->u.tex.last_layer = u->Layered
+            ? u_minify(stObj->pt->depth0, img->u.tex.level) - 1
+            : u->_Layer;
+         img->u.tex.is_2d_view_of_3d = !u->Layered;
       } else {
          img->u.tex.first_layer = u->_Layer + stObj->Attrib.MinLayer;
          img->u.tex.last_layer = u->_Layer + stObj->Attrib.MinLayer;
diff --git a/src/mesa/state_tracker/st_atom_sampler.c b/src/mesa/state_tracker/st_atom_sampler.c
index 8b30c72aa83b8..8e1ec5658dd4b 100644
--- a/src/mesa/state_tracker/st_atom_sampler.c
+++ b/src/mesa/state_tracker/st_atom_sampler.c
@@ -245,15 +245,9 @@ update_shader_samplers(struct st_context *st,
       /* Don't update the sampler for TBOs. cso_context will not bind sampler
        * states that are NULL.
        */
-      if (samplers_used & 1 &&
-          (ctx->Texture.Unit[tex_unit]._Current->Target != GL_TEXTURE_BUFFER)) {
-         st_convert_sampler_from_unit(
-            st, sampler, tex_unit,
-            prog->shader_program && prog->shader_program->GLSL_Version >= 130);
-         states[unit] = sampler;
-      } else {
-         states[unit] = NULL;
-      }
+      states[unit] = (samplers_used & 1 && (ctx->Texture.Unit[tex_unit]._Current->Target != GL_TEXTURE_BUFFER)) ?
+         (st_convert_sampler_from_unit(st, sampler, tex_unit,prog->shader_program &&
+            prog->shader_program->GLSL_Version >= 130), sampler) : NULL;
    }
 
    /* For any external samplers with multiplaner YUV, stuff the additional
diff --git a/src/mesa/state_tracker/st_atom_shader.c b/src/mesa/state_tracker/st_atom_shader.c
index 6df450cd6d0c6..b2e3c70814300 100644
--- a/src/mesa/state_tracker/st_atom_shader.c
+++ b/src/mesa/state_tracker/st_atom_shader.c
@@ -60,14 +60,9 @@ static unsigned
 get_texture_index(struct gl_context *ctx, const unsigned unit)
 {
    struct gl_texture_object *texObj = _mesa_get_tex_unit(ctx, unit)->_Current;
-   gl_texture_index index;
 
-   if (texObj) {
-      index = _mesa_tex_target_to_index(ctx, texObj->Target);
-   } else {
-      /* fallback for missing texture */
-      index = TEXTURE_2D_INDEX;
-   }
+   gl_texture_index index = texObj ? _mesa_tex_target_to_index(ctx, texObj->Target)
+                                    : TEXTURE_2D_INDEX; /* fallback for missing texture */
 
    return index;
 }
diff --git a/src/mesa/state_tracker/st_cb_eglimage.c b/src/mesa/state_tracker/st_cb_eglimage.c
index 9feae1f360962..d7c98c246f731 100644
--- a/src/mesa/state_tracker/st_cb_eglimage.c
+++ b/src/mesa/state_tracker/st_cb_eglimage.c
@@ -477,24 +477,18 @@ st_bind_egl_image(struct gl_context *ctx,
          break;
       case PIPE_FORMAT_NV12:
       case PIPE_FORMAT_NV21:
-         if (stimg->texture->format == PIPE_FORMAT_R8_G8B8_420_UNORM ||
-             stimg->texture->format == PIPE_FORMAT_R8_B8G8_420_UNORM) {
-            texFormat = MESA_FORMAT_R8G8B8X8_UNORM;
-            texObj->RequiredTextureImageUnits = 1;
-         } else {
-            texFormat = MESA_FORMAT_R_UNORM8;
-            texObj->RequiredTextureImageUnits = 2;
-         }
+         texFormat = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_420_UNORM ||
+                        stimg->texture->format == PIPE_FORMAT_R8_B8G8_420_UNORM) ?
+                           MESA_FORMAT_R8G8B8X8_UNORM : MESA_FORMAT_R_UNORM8;
+         texObj->RequiredTextureImageUnits = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_420_UNORM ||
+                                             stimg->texture->format == PIPE_FORMAT_R8_B8G8_420_UNORM) ? 1 : 2;
          break;
       case PIPE_FORMAT_NV16:
-         if (stimg->texture->format == PIPE_FORMAT_R8_G8B8_422_UNORM ||
-             stimg->texture->format == PIPE_FORMAT_R8_B8G8_422_UNORM) {
-            texFormat = MESA_FORMAT_R8G8B8X8_UNORM;
-            texObj->RequiredTextureImageUnits = 1;
-         } else {
-            texFormat = MESA_FORMAT_R_UNORM8;
-            texObj->RequiredTextureImageUnits = 2;
-         }
+         texFormat = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_422_UNORM ||
+                        stimg->texture->format == PIPE_FORMAT_R8_B8G8_422_UNORM) ?
+                           MESA_FORMAT_R8G8B8X8_UNORM : MESA_FORMAT_R_UNORM8;
+         texObj->RequiredTextureImageUnits = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_422_UNORM ||
+                                             stimg->texture->format == PIPE_FORMAT_R8_B8G8_422_UNORM) ? 1 : 2;
          break;
       case PIPE_FORMAT_NV61:
       case PIPE_FORMAT_NV24:
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 02f9d4c523cd2..0a5e9e3b2f383 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -1324,11 +1324,7 @@ void st_init_extensions(struct pipe_screen *screen,
       extensions->ARB_texture_rgb10_a2ui = GL_FALSE;
    }
 
-   if (options->glsl_zero_init) {
-      consts->GLSLZeroInit = 1;
-   } else {
-      consts->GLSLZeroInit = screen->caps.glsl_zero_init;
-   }
+   consts->GLSLZeroInit = options->glsl_zero_init ? 1 : screen->caps.glsl_zero_init;
 
    if (extensions->EXT_semaphore) {
       consts->MaxTimelineSemaphoreValueDifference = screen->caps.max_timeline_semaphore_difference;
@@ -1623,13 +1619,8 @@ void st_init_extensions(struct pipe_screen *screen,
 
    consts->MaxViewports = screen->caps.max_viewports;
    if (consts->MaxViewports >= 16) {
-      if (GLSLVersion >= 400) {
-         consts->ViewportBounds.Min = -32768.0;
-         consts->ViewportBounds.Max = 32767.0;
-      } else {
-         consts->ViewportBounds.Min = -16384.0;
-         consts->ViewportBounds.Max = 16383.0;
-      }
+      consts->ViewportBounds.Min = GLSLVersion >= 400 ? -32768.0 : -16384.0;
+      consts->ViewportBounds.Max = GLSLVersion >= 400 ? 32767.0 : 16383.0;
       extensions->ARB_viewport_array = GL_TRUE;
       extensions->ARB_fragment_layer_viewport = GL_TRUE;
       if (extensions->AMD_vertex_shader_layer)
diff --git a/src/mesa/state_tracker/st_format.c b/src/mesa/state_tracker/st_format.c
index 1b2e3fee0ad62..50eac27695ab3 100644
--- a/src/mesa/state_tracker/st_format.c
+++ b/src/mesa/state_tracker/st_format.c
@@ -119,13 +119,9 @@ st_mesa_format_to_pipe_format(const struct st_context *st,
          return mesaFormat;
 
       /* We're emulating all of ASTC via transcoding or decompression */
-      if (_mesa_is_format_srgb(mesaFormat)) {
-         return st->transcode_astc ? PIPE_FORMAT_DXT5_SRGBA :
-                                     PIPE_FORMAT_R8G8B8A8_SRGB;
-      } else {
-         return st->transcode_astc ? PIPE_FORMAT_DXT5_RGBA :
-                                     PIPE_FORMAT_R8G8B8A8_UNORM;
-      }
+      return _mesa_is_format_srgb(mesaFormat) ?
+             (st->transcode_astc ? PIPE_FORMAT_DXT5_SRGBA : PIPE_FORMAT_R8G8B8A8_SRGB) :
+             (st->transcode_astc ? PIPE_FORMAT_DXT5_RGBA : PIPE_FORMAT_R8G8B8A8_UNORM);
    }
 
    if (_mesa_is_format_s3tc(mesaFormat) && !st->has_s3tc) {
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index f46e3378cd3a9..babf9c2d375dd 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -127,25 +127,16 @@ st_nir_assign_uniform_locations(struct st_context *st,
 
       const struct glsl_type *type = glsl_without_array(uniform->type);
       if (!uniform->data.bindless && (glsl_type_is_sampler(type) || glsl_type_is_image(type))) {
-         if (glsl_type_is_sampler(type)) {
-            loc = shaderidx;
-            shaderidx += type_size(uniform->type);
-         } else {
-            loc = imageidx;
-            imageidx += type_size(uniform->type);
-         }
+         loc = glsl_type_is_sampler(type) ? shaderidx : imageidx;
+         (glsl_type_is_sampler(type) ? shaderidx : imageidx) += type_size(uniform->type);
       } else if (uniform->state_slots) {
          if (st->allow_st_finalize_nir_twice && !is_before_variants)
             continue;
 
          const gl_state_index16 *const stateTokens = uniform->state_slots[0].tokens;
 
-         unsigned comps;
-         if (glsl_type_is_struct_or_ifc(type)) {
-            comps = 4;
-         } else {
-            comps = glsl_get_vector_elements(type);
-         }
+         unsigned comps = glsl_type_is_struct_or_ifc(type) ?
+            4 : glsl_get_vector_elements(type);
 
          if (ctx->Const.PackedDriverUniformStorage) {
             loc = _mesa_add_sized_state_reference(prog->Parameters,
@@ -249,12 +240,9 @@ st_glsl_to_nir_post_opts(struct st_context *st, struct gl_program *prog,
       if (slots != NULL) {
          const struct glsl_type *type = glsl_without_array(var->type);
          for (unsigned int i = 0; i < var->num_state_slots; i++) {
-            unsigned comps;
-            if (glsl_type_is_struct_or_ifc(type)) {
-               comps = _mesa_program_state_value_size(slots[i].tokens);
-            } else {
-               comps = glsl_get_vector_elements(type);
-            }
+            unsigned comps = glsl_type_is_struct_or_ifc(type) ?
+                             _mesa_program_state_value_size(slots[i].tokens) :
+                             glsl_get_vector_elements(type);
 
             if (st->ctx->Const.PackedDriverUniformStorage) {
                _mesa_add_sized_state_reference(prog->Parameters,
@@ -687,15 +675,10 @@ st_unpacked_uniforms_type_size(const struct glsl_type *type, bool bindless)
 void
 st_nir_lower_uniforms(struct st_context *st, nir_shader *nir)
 {
-   if (st->ctx->Const.PackedDriverUniformStorage) {
-      NIR_PASS(_, nir, nir_lower_io, nir_var_uniform,
-                 st_packed_uniforms_type_size,
-                 (nir_lower_io_options)0);
-   } else {
-      NIR_PASS(_, nir, nir_lower_io, nir_var_uniform,
-                 st_unpacked_uniforms_type_size,
-                 (nir_lower_io_options)0);
-   }
+   NIR_PASS(_, nir, nir_lower_io, nir_var_uniform,
+            st->ctx->Const.PackedDriverUniformStorage ? st_packed_uniforms_type_size
+                                                   : st_unpacked_uniforms_type_size,
+            (nir_lower_io_options)0);
 
    if (nir->options->lower_uniforms_to_ubo)
       NIR_PASS(_, nir, nir_lower_uniforms_to_ubo,
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index a7f71f78b5310..efde866b38adb 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -118,12 +118,8 @@ st_pbo_addresses_pixelstore(struct st_context *st,
    /* Convert to texels */
    buf_offset = buf_offset / addr->bytes_per_pixel;
 
-   /* Determine image height */
-   if (gl_target == GL_TEXTURE_1D_ARRAY) {
-      addr->image_height = 1;
-   } else {
-      addr->image_height = store->ImageHeight > 0 ? store->ImageHeight : addr->height;
-   }
+   addr->image_height = gl_target == GL_TEXTURE_1D_ARRAY ? 1 :
+                        (store->ImageHeight > 0 ? store->ImageHeight : addr->height);
 
    /* Compute the stride, taking store->Alignment into account */
    {
@@ -487,14 +483,9 @@ create_fs(struct st_context *st, bool download,
             src_layer = nir_iadd(&b, layer, layer_offset);
          }
 
-         if (target == PIPE_TEXTURE_1D_ARRAY) {
-            texcoord = nir_vec2(&b, nir_channel(&b, texcoord, 0),
-                                    src_layer);
-         } else {
-            texcoord = nir_vec3(&b, nir_channel(&b, texcoord, 0),
-                                    nir_channel(&b, texcoord, 1),
-                                    src_layer);
-         }
+         texcoord = target == PIPE_TEXTURE_1D_ARRAY ?
+                    nir_vec2(&b, nir_channel(&b, texcoord, 0), src_layer) :
+                    nir_vec3(&b, nir_channel(&b, texcoord, 0), nir_channel(&b, texcoord, 1), src_layer);
       }
    } else {
       texcoord = pbo_addr;
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 08285d00be16e..9e52efbe4b6c2 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -326,12 +326,8 @@ fill_pbo_data(struct pbo_data *pd, enum pipe_format src_format, enum pipe_format
    if (is_8bit || dst_desc->block.bits == 8)
       swap = false;
 
-   unsigned dst_bit_size = 0;
-   if (weird_packed) {
-      dst_bit_size = dst_desc->block.bits;
-   } else {
-      dst_bit_size = dst_desc->block.bits / dst_desc->nr_channels;
-   }
+   unsigned dst_bit_size = weird_packed ? dst_desc->block.bits :
+                                          dst_desc->block.bits / dst_desc->nr_channels;
    assert(dst_bit_size);
    assert(dst_bit_size <= 64);
 
@@ -1035,14 +1031,11 @@ download_texture_compute(struct st_context *st,
             for (unsigned i = 0; i < 4; i++)
                invswizzle[i] = PIPE_SWIZZLE_Z;
          } else {
-            if (swizzle_clamp & SWIZZLE_CLAMP_BGRA) {
-               if (util_format_get_nr_components(dst_format) == 3)
-                  swizzle = util_format_description(PIPE_FORMAT_B8G8R8_UNORM)->swizzle;
-               else
-                  swizzle = util_format_description(PIPE_FORMAT_B8G8R8A8_UNORM)->swizzle;
-            } else {
-               swizzle = desc->swizzle;
-            }
+            swizzle = (swizzle_clamp & SWIZZLE_CLAMP_BGRA) ?
+                      ((util_format_get_nr_components(dst_format) == 3) ?
+                       util_format_description(PIPE_FORMAT_B8G8R8_UNORM)->swizzle :
+                       util_format_description(PIPE_FORMAT_B8G8R8A8_UNORM)->swizzle) :
+                      desc->swizzle;
             invert_swizzle(invswizzle, swizzle);
          }
          swizzle_clamp &= ~(SWIZZLE_CLAMP_BGRA | SWIZZLE_CLAMP_GREEN | SWIZZLE_CLAMP_BLUE);
@@ -1099,13 +1092,8 @@ download_texture_compute(struct st_context *st,
       /* array textures expect to have array index provided */
       if (view_target != PIPE_TEXTURE_3D && src->array_size) {
          templ.u.tex.first_layer = layer;
-         if (view_target == PIPE_TEXTURE_1D_ARRAY) {
-            templ.u.tex.first_layer += yoffset;
-            templ.u.tex.last_layer = templ.u.tex.first_layer + height - 1;
-         } else {
-            templ.u.tex.first_layer += zoffset;
-            templ.u.tex.last_layer = templ.u.tex.first_layer + depth - 1;
-         }
+         templ.u.tex.first_layer += (view_target == PIPE_TEXTURE_1D_ARRAY) ? yoffset : zoffset;
+         templ.u.tex.last_layer = templ.u.tex.first_layer + ((view_target == PIPE_TEXTURE_1D_ARRAY) ? height : depth) - 1;
       }
 
       sampler_view = pipe->create_sampler_view(pipe, src, &templ);
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 8eed848fccf92..22f3c2f103174 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -706,13 +706,8 @@ lower_ucp(struct st_context *st,
 
       gl_state_index16 clipplane_state[MAX_CLIP_PLANES][STATE_LENGTH] = {{0}};
       for (int i = 0; i < MAX_CLIP_PLANES; ++i) {
-         if (use_eye) {
-            clipplane_state[i][0] = STATE_CLIPPLANE;
-            clipplane_state[i][1] = i;
-         } else {
-            clipplane_state[i][0] = STATE_CLIP_INTERNAL;
-            clipplane_state[i][1] = i;
-         }
+         clipplane_state[i][0] = use_eye ? STATE_CLIPPLANE : STATE_CLIP_INTERNAL;
+         clipplane_state[i][1] = i;
          if (!st->allow_st_finalize_nir_twice)
             _mesa_add_state_reference(params, clipplane_state[i]);
       }
diff --git a/src/mesa/state_tracker/st_sampler_view.c b/src/mesa/state_tracker/st_sampler_view.c
index 8b7ac8352bcec..55a36046ebb40 100644
--- a/src/mesa/state_tracker/st_sampler_view.c
+++ b/src/mesa/state_tracker/st_sampler_view.c
@@ -486,19 +486,14 @@ st_create_texture_sampler_view_from_stobj(struct st_context *st,
    templ.format = format;
    templ.is_tex2d_from_buf = false;
 
-   if (texObj->level_override >= 0) {
-      templ.u.tex.first_level = templ.u.tex.last_level = texObj->level_override;
-   } else {
-      templ.u.tex.first_level = texObj->Attrib.MinLevel +
-                                texObj->Attrib.BaseLevel;
-      templ.u.tex.last_level = last_level(texObj);
-   }
-   if (texObj->layer_override >= 0) {
-      templ.u.tex.first_layer = templ.u.tex.last_layer = texObj->layer_override;
-   } else {
-      templ.u.tex.first_layer = texObj->Attrib.MinLayer;
-      templ.u.tex.last_layer = last_layer(texObj);
-   }
+   templ.u.tex.first_level = texObj->level_override >= 0 ? texObj->level_override
+                           : texObj->Attrib.MinLevel + texObj->Attrib.BaseLevel;
+   templ.u.tex.last_level = texObj->level_override >= 0 ? texObj->level_override
+                           : last_level(texObj);
+   templ.u.tex.first_layer = texObj->layer_override >= 0 ?
+                             texObj->layer_override : texObj->Attrib.MinLayer;
+   templ.u.tex.last_layer = texObj->layer_override >= 0 ?
+                            texObj->layer_override : last_layer(texObj);
    assert(templ.u.tex.first_layer <= templ.u.tex.last_layer);
    assert(templ.u.tex.first_level <= templ.u.tex.last_level);
    templ.target = gl_target_to_pipe(texObj->Target);
-- 
GitLab


From 3b9f7e8e936bc5ec04699e629e84e7051a2ca3b5 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:33:47 +0300
Subject: [PATCH 15/31] vulkan: micro-op Clang/GCC using disassembler with -O3
 flag

---
 src/vulkan/runtime/vk_image.c                 |  8 ++--
 src/vulkan/runtime/vk_meta_blit_resolve.c     | 22 +++------
 src/vulkan/runtime/vk_meta_clear.c            | 13 +++---
 src/vulkan/runtime/vk_meta_copy_fill_update.c | 43 +++++-------------
 src/vulkan/runtime/vk_nir_convert_ycbcr.c     | 25 ++++-------
 src/vulkan/runtime/vk_object.c                |  7 +--
 src/vulkan/runtime/vk_pipeline_cache.c        |  6 +--
 src/vulkan/runtime/vk_queue.c                 | 20 +++------
 src/vulkan/runtime/vk_render_pass.c           | 45 +++++--------------
 src/vulkan/runtime/vk_semaphore.c             | 11 ++---
 src/vulkan/runtime/vk_video.c                 | 26 +++--------
 11 files changed, 66 insertions(+), 160 deletions(-)

diff --git a/src/vulkan/runtime/vk_image.c b/src/vulkan/runtime/vk_image.c
index 7efabe8485a12..59d80a6ff0cd3 100644
--- a/src/vulkan/runtime/vk_image.c
+++ b/src/vulkan/runtime/vk_image.c
@@ -651,11 +651,9 @@ vk_image_view_init(struct vk_device *device,
          unsigned total = image_view->extent.depth;
          image_view->storage.z_slice_offset = sliced_info->sliceOffset;
          assert(image_view->storage.z_slice_offset < total);
-         if (sliced_info->sliceCount == VK_REMAINING_3D_SLICES_EXT) {
-            image_view->storage.z_slice_count = total - image_view->storage.z_slice_offset;
-         } else {
-            image_view->storage.z_slice_count = sliced_info->sliceCount;
-         }
+         image_view->storage.z_slice_count =
+            sliced_info->sliceCount == VK_REMAINING_3D_SLICES_EXT ?
+            total - image_view->storage.z_slice_offset : sliced_info->sliceCount;
       } else if (image_view->view_type != VK_IMAGE_VIEW_TYPE_3D) {
          image_view->storage.z_slice_offset = image_view->base_array_layer;
          image_view->storage.z_slice_count = image_view->layer_count;
diff --git a/src/vulkan/runtime/vk_meta_blit_resolve.c b/src/vulkan/runtime/vk_meta_blit_resolve.c
index a7022bc734816..eb0a8ee5715e4 100644
--- a/src/vulkan/runtime/vk_meta_blit_resolve.c
+++ b/src/vulkan/runtime/vk_meta_blit_resolve.c
@@ -190,14 +190,9 @@ build_tex_resolve(nir_builder *b, nir_deref_instr *t,
 static nir_shader *
 build_blit_shader(const struct vk_meta_blit_key *key)
 {
-   nir_builder build;
-   if (key->resolve_mode || key->stencil_resolve_mode) {
-      build = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT, NULL,
-                                             "vk-meta-resolve");
-   } else {
-      build = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT,
-                                             NULL, "vk-meta-blit");
-   }
+   nir_builder build = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT, NULL,
+                                                      (key->resolve_mode || key->stencil_resolve_mode) ?
+                                                      "vk-meta-resolve" : "vk-meta-blit");
    nir_builder *b = &build;
 
    struct glsl_struct_field push_fields[] = {
@@ -301,14 +296,9 @@ build_blit_shader(const struct vk_meta_blit_key *key)
       texture->data.binding = aspect_to_tex_binding(aspect);
       nir_deref_instr *t = nir_build_deref_var(b, texture);
 
-      nir_def *val;
-      if (resolve_mode == VK_RESOLVE_MODE_NONE) {
-         val = nir_txl(b, src_coord, nir_imm_float(b, 0),
-                       .texture_deref = t, .sampler_deref = s);
-      } else {
-         val = build_tex_resolve(b, t, nir_f2u32(b, src_coord),
-                                 key->src_samples, resolve_mode);
-      }
+      nir_def *val = resolve_mode == VK_RESOLVE_MODE_NONE ?
+                     nir_txl(b, src_coord, nir_imm_float(b, 0), .texture_deref = t, .sampler_deref = s) :
+                     build_tex_resolve(b, t, nir_f2u32(b, src_coord), key->src_samples, resolve_mode);
       val = nir_trim_vector(b, val, out_comps);
 
       if (key->stencil_as_discard) {
diff --git a/src/vulkan/runtime/vk_meta_clear.c b/src/vulkan/runtime/vk_meta_clear.c
index 6f921d0932415..c763880dcb55f 100644
--- a/src/vulkan/runtime/vk_meta_clear.c
+++ b/src/vulkan/runtime/vk_meta_clear.c
@@ -549,14 +549,11 @@ clear_image_level(struct vk_command_buffer *cmd,
 {
    const VkExtent3D level_extent = vk_image_mip_level_extent(image, level);
 
-   uint32_t base_array_layer, layer_count;
-   if (image->image_type == VK_IMAGE_TYPE_3D) {
-      base_array_layer = 0;
-      layer_count = level_extent.depth;
-   } else {
-      base_array_layer = range->baseArrayLayer;
-      layer_count = vk_image_subresource_layer_count(image, range);
-   }
+   const uint32_t base_array_layer =
+      image->image_type == VK_IMAGE_TYPE_3D ? 0 : range->baseArrayLayer;
+   const uint32_t layer_count =
+      image->image_type == VK_IMAGE_TYPE_3D ? level_extent.depth :
+                                              vk_image_subresource_layer_count(image, range);
 
    if (layer_count > 1 && !meta->use_layered_rendering) {
       for (uint32_t a = 0; a < layer_count; a++) {
diff --git a/src/vulkan/runtime/vk_meta_copy_fill_update.c b/src/vulkan/runtime/vk_meta_copy_fill_update.c
index cb836121d0188..5dbcb90fdf897 100644
--- a/src/vulkan/runtime/vk_meta_copy_fill_update.c
+++ b/src/vulkan/runtime/vk_meta_copy_fill_update.c
@@ -1985,17 +1985,9 @@ copy_image_prepare_compute_push_const(
 
    struct vk_meta_copy_image_cs_info info = {0};
 
-   /* We can't necessarily optimize the read+write path, so align things
-    * on the biggest tile size. */
-   if (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE) {
-      info.copy_id_range.start.x = src_offs.x % key->wg_size[0];
-      info.copy_id_range.start.y = src_offs.y % key->wg_size[1];
-      info.copy_id_range.start.z = src_offs.z % key->wg_size[2];
-   } else {
-      info.copy_id_range.start.x = dst_offs.x % key->wg_size[0];
-      info.copy_id_range.start.y = dst_offs.y % key->wg_size[1];
-      info.copy_id_range.start.z = dst_offs.z % key->wg_size[2];
-   }
+   info.copy_id_range.start.x = (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE ? src_offs.x : dst_offs.x) % key->wg_size[0];
+   info.copy_id_range.start.y = (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE ? src_offs.y : dst_offs.y) % key->wg_size[1];
+   info.copy_id_range.start.z = (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE ? src_offs.z : dst_offs.z) % key->wg_size[2];
 
    info.copy_id_range.end.x = info.copy_id_range.start.x + src_extent.width;
    info.copy_id_range.end.y = info.copy_id_range.start.y + src_extent.height;
@@ -2230,18 +2222,14 @@ copy_image_region_compute(struct vk_command_buffer *cmd,
                                dst_props->tile_size.height *
                                dst_props->tile_size.depth;
    enum vk_meta_copy_image_align_policy align_policy;
+   bool align_on_src = src_pix_per_tile >= dst_pix_per_tile;
+
+   key.wg_size[0] = align_on_src ? src_props->tile_size.width : dst_props->tile_size.width;
+   key.wg_size[1] = align_on_src ? src_props->tile_size.height : dst_props->tile_size.height;
+   key.wg_size[2] = align_on_src ? src_props->tile_size.depth : dst_props->tile_size.depth;
+   align_policy = align_on_src ? VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE :
+                                 VK_META_COPY_IMAGE_ALIGN_ON_DST_TILE;
 
-   if (src_pix_per_tile >= dst_pix_per_tile) {
-      key.wg_size[0] = src_props->tile_size.width;
-      key.wg_size[1] = src_props->tile_size.height;
-      key.wg_size[2] = src_props->tile_size.depth;
-      align_policy = VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE;
-   } else {
-      key.wg_size[0] = dst_props->tile_size.width;
-      key.wg_size[1] = dst_props->tile_size.height;
-      key.wg_size[2] = dst_props->tile_size.depth;
-      align_policy = VK_META_COPY_IMAGE_ALIGN_ON_DST_TILE;
-   }
 
    VkPipelineLayout pipeline_layout;
    VkPipeline pipeline;
@@ -2322,16 +2310,9 @@ build_copy_buffer_shader(const struct vk_meta_device *meta,
    b->shader->info.workgroup_size[1] = 1;
    b->shader->info.workgroup_size[2] = 1;
 
-   uint32_t chunk_bit_size, chunk_comp_count;
-
    assert(util_is_power_of_two_nonzero(key->chunk_size));
-   if (key->chunk_size <= 4) {
-      chunk_bit_size = key->chunk_size * 8;
-      chunk_comp_count = 1;
-   } else {
-      chunk_bit_size = 32;
-      chunk_comp_count = key->chunk_size / 4;
-   }
+   uint32_t chunk_bit_size = key->chunk_size <= 4 ? key->chunk_size * 8 : 32;
+   uint32_t chunk_comp_count = key->chunk_size <= 4 ? 1 : key->chunk_size / 4;
 
    assert(chunk_comp_count < NIR_MAX_VEC_COMPONENTS);
 
diff --git a/src/vulkan/runtime/vk_nir_convert_ycbcr.c b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
index cf07dfaff8c43..ac5230e3be6b1 100644
--- a/src/vulkan/runtime/vk_nir_convert_ycbcr.c
+++ b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
@@ -190,15 +190,13 @@ implicit_downsampled_coords(struct ycbcr_state *state,
    int c;
 
    for (c = 0; c < ARRAY_SIZE(conversion->chroma_offsets); c++) {
-      if (format_plane->denominator_scales[c] > 1 &&
-          conversion->chroma_offsets[c] == VK_CHROMA_LOCATION_COSITED_EVEN) {
-         comp[c] = implicit_downsampled_coord(b,
-                                              nir_channel(b, old_coords, c),
-                                              nir_channel(b, image_size, c),
-                                              format_plane->denominator_scales[c]);
-      } else {
-         comp[c] = nir_channel(b, old_coords, c);
-      }
+      comp[c] = (format_plane->denominator_scales[c] > 1 &&
+                 conversion->chroma_offsets[c] == VK_CHROMA_LOCATION_COSITED_EVEN) ?
+                implicit_downsampled_coord(b,
+                                           nir_channel(b, old_coords, c),
+                                           nir_channel(b, image_size, c),
+                                           format_plane->denominator_scales[c]) :
+                nir_channel(b, old_coords, c);
    }
 
    /* Leave other coordinates untouched */
@@ -401,13 +399,8 @@ lower_ycbcr_tex_instr(nir_builder *b, nir_instr *instr, void *_state)
       };
       const VkComponentSwizzle m = conversion->mapping[i];
 
-      if (m == VK_COMPONENT_SWIZZLE_IDENTITY) {
-         swizzled_comp[i] = ycbcr_comp[i];
-         swizzled_bpcs[i] = ycbcr_bpcs[i];
-      } else {
-         swizzled_comp[i] = ycbcr_comp[swizzle_mapping[m]];
-         swizzled_bpcs[i] = ycbcr_bpcs[swizzle_mapping[m]];
-      }
+      swizzled_comp[i] = (m == VK_COMPONENT_SWIZZLE_IDENTITY) ? ycbcr_comp[i] : ycbcr_comp[swizzle_mapping[m]];
+      swizzled_bpcs[i] = (m == VK_COMPONENT_SWIZZLE_IDENTITY) ? ycbcr_bpcs[i] : ycbcr_bpcs[swizzle_mapping[m]];
    }
 
    nir_def *result = nir_vec(b, swizzled_comp, 4);
diff --git a/src/vulkan/runtime/vk_pipeline_cache.c b/src/vulkan/runtime/vk_pipeline_cache.c
index 97f184c1bc700..a3d2c56f8adc0 100644
--- a/src/vulkan/runtime/vk_pipeline_cache.c
+++ b/src/vulkan/runtime/vk_pipeline_cache.c
@@ -731,11 +731,7 @@ vk_common_GetPipelineCacheData(VkDevice _device,
    VK_FROM_HANDLE(vk_pipeline_cache, cache, pipelineCache);
 
    struct blob blob;
-   if (pData) {
-      blob_init_fixed(&blob, pData, *pDataSize);
-   } else {
-      blob_init_fixed(&blob, NULL, SIZE_MAX);
-   }
+   blob_init_fixed(&blob, pData ? pData : NULL, pData ? *pDataSize : SIZE_MAX);
 
    blob_write_bytes(&blob, &cache->header, sizeof(cache->header));
 
diff --git a/src/vulkan/runtime/vk_queue.c b/src/vulkan/runtime/vk_queue.c
index 3d08a6a865d98..73198765f7f47 100644
--- a/src/vulkan/runtime/vk_queue.c
+++ b/src/vulkan/runtime/vk_queue.c
@@ -1207,13 +1207,9 @@ vk_common_QueueSubmit2(VkQueue _queue,
    if (vk_device_is_lost(queue->base.device))
       return VK_ERROR_DEVICE_LOST;
 
-   if (submitCount == 0) {
-      if (fence == NULL) {
-         return VK_SUCCESS;
-      } else {
-         return vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
-      }
-   }
+   if (submitCount == 0)
+      return fence == NULL ? VK_SUCCESS :
+             vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
 
    struct vk_queue_submit *last_submit = NULL;
    for (uint32_t i = 0; i < submitCount; i++) {
@@ -1259,13 +1255,9 @@ vk_common_QueueBindSparse(VkQueue _queue,
    if (vk_device_is_lost(queue->base.device))
       return VK_ERROR_DEVICE_LOST;
 
-   if (bindInfoCount == 0) {
-      if (fence == NULL) {
-         return VK_SUCCESS;
-      } else {
-         return vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
-      }
-   }
+   if (bindInfoCount == 0)
+      return fence == NULL ? VK_SUCCESS :
+             vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
 
    struct vk_queue_submit *last_submit = NULL;
    for (uint32_t i = 0; i < bindInfoCount; i++) {
diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 0e588a19379aa..9007b9441e90e 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1887,19 +1887,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
          color_attachment->loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
       }
 
-      if (!(subpass->view_mask & ~sp_att->last_subpass)) {
-         /* This is the last subpass for every view */
-         color_attachment->storeOp = rp_att->store_op;
-      } else {
-         /* For at least one of our views, this isn't the last subpass
-          *
-          * In the edge case where we have lots of weird overlap between view
-          * masks of different subThis may mean that we get STORE_OP_STORE in
-          * some places where it may have wanted STORE_OP_NONE but that should
-          * be harmless.
-          */
-         color_attachment->storeOp = VK_ATTACHMENT_STORE_OP_STORE;
-      }
+      color_attachment->storeOp = (subpass->view_mask & ~sp_att->last_subpass) ? rp_att->store_op : VK_ATTACHMENT_STORE_OP_STORE;
 
       if (sp_att->resolve != NULL) {
          assert(sp_att->resolve->attachment < pass->attachment_count);
@@ -2009,21 +1997,12 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
          stencil_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
       }
 
-      if (!(subpass->view_mask & ~sp_att->last_subpass)) {
-         /* This is the last subpass for every view */
-         depth_attachment.storeOp = rp_att->store_op;
-         stencil_attachment.storeOp = rp_att->stencil_store_op;
-      } else {
-         /* For at least one of our views, this isn't the last subpass
-          *
-          * In the edge case where we have lots of weird overlap between view
-          * masks of different subThis may mean that we get STORE_OP_STORE in
-          * some places where it may have wanted STORE_OP_NONE but that should
-          * be harmless.
-          */
-         depth_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
-         stencil_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
-      }
+      depth_attachment.storeOp =
+         (subpass->view_mask & ~sp_att->last_subpass) ?
+         VK_ATTACHMENT_STORE_OP_STORE : rp_att->store_op;
+      stencil_attachment.storeOp =
+         (subpass->view_mask & ~sp_att->last_subpass) ?
+         VK_ATTACHMENT_STORE_OP_STORE : rp_att->stencil_store_op;
 
       /* From the Vulkan 1.3.212 spec:
        *
@@ -2545,12 +2524,10 @@ vk_common_CmdBeginRenderPass2(VkCommandBuffer commandBuffer,
    cmd_buffer->render_area = pRenderPassBeginInfo->renderArea;
 
    assert(cmd_buffer->attachments == NULL);
-   if (pass->attachment_count > ARRAY_SIZE(cmd_buffer->_attachments)) {
-      cmd_buffer->attachments = malloc(pass->attachment_count *
-                                       sizeof(*cmd_buffer->attachments));
-   } else {
-      cmd_buffer->attachments = cmd_buffer->_attachments;
-   }
+   cmd_buffer->attachments =
+      pass->attachment_count > ARRAY_SIZE(cmd_buffer->_attachments) ?
+      malloc(pass->attachment_count * sizeof(*cmd_buffer->attachments)) :
+      cmd_buffer->_attachments;
 
    const VkRenderPassAttachmentBeginInfo *attach_begin =
       vk_find_struct_const(pRenderPassBeginInfo,
diff --git a/src/vulkan/runtime/vk_semaphore.c b/src/vulkan/runtime/vk_semaphore.c
index 534eaa76457cc..940038700d172 100644
--- a/src/vulkan/runtime/vk_semaphore.c
+++ b/src/vulkan/runtime/vk_semaphore.c
@@ -96,13 +96,10 @@ get_semaphore_sync_type(struct vk_physical_device *pdevice,
    assert(semaphore_type == VK_SEMAPHORE_TYPE_BINARY ||
           semaphore_type == VK_SEMAPHORE_TYPE_TIMELINE);
 
-   enum vk_sync_features req_features = VK_SYNC_FEATURE_GPU_WAIT;
-   if (semaphore_type == VK_SEMAPHORE_TYPE_TIMELINE) {
-      req_features |= VK_SYNC_FEATURE_TIMELINE |
-                      VK_SYNC_FEATURE_CPU_WAIT;
-   } else {
-      req_features |= VK_SYNC_FEATURE_BINARY;
-   }
+   enum vk_sync_features req_features = VK_SYNC_FEATURE_GPU_WAIT |
+      (semaphore_type == VK_SEMAPHORE_TYPE_TIMELINE ?
+       (VK_SYNC_FEATURE_TIMELINE | VK_SYNC_FEATURE_CPU_WAIT) :
+       VK_SYNC_FEATURE_BINARY);
 
    for (const struct vk_sync_type *const *t =
         pdevice->supported_sync_types; *t; t++) {
diff --git a/src/vulkan/runtime/vk_video.c b/src/vulkan/runtime/vk_video.c
index 942e90a4d17fa..4bcf7821c7eb6 100644
--- a/src/vulkan/runtime/vk_video.c
+++ b/src/vulkan/runtime/vk_video.c
@@ -107,15 +107,11 @@ vk_video_session_init(struct vk_device *device,
          vk_find_struct_const(create_info->pVideoProfile->pNext, VIDEO_ENCODE_USAGE_INFO_KHR);
       const struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR *intra_refresh =
          vk_find_struct_const(create_info->pNext, VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR);
-      if (encode_usage_profile) {
-         vid->enc_usage.video_usage_hints = encode_usage_profile->videoUsageHints;
-         vid->enc_usage.video_content_hints = encode_usage_profile->videoContentHints;
-         vid->enc_usage.tuning_mode = encode_usage_profile->tuningMode;
-      } else {
-         vid->enc_usage.video_usage_hints = VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR;
-         vid->enc_usage.video_content_hints = VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR;
-         vid->enc_usage.tuning_mode = VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR;
-      }
+
+      vid->enc_usage.video_usage_hints = encode_usage_profile ? encode_usage_profile->videoUsageHints : VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR;
+      vid->enc_usage.video_content_hints = encode_usage_profile ? encode_usage_profile->videoContentHints : VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR;
+      vid->enc_usage.tuning_mode = encode_usage_profile ? encode_usage_profile->tuningMode : VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR;
+
       if (intra_refresh)
          vid->intra_refresh_mode = intra_refresh->intraRefreshMode;
    }
@@ -1274,11 +1270,7 @@ h265_pred_weight_table(struct vk_video_h265_slice_params *params,
    }
 
    for (i = 0; i < params->num_ref_idx_l0_active; ++i) {
-      if (chroma_array_type == 0) {
-         params->chroma_weight_l0_flag[i] = 0;
-      } else {
-         params->chroma_weight_l0_flag[i] = vl_rbsp_u(rbsp, 1);
-      }
+      params->chroma_weight_l0_flag[i] = (chroma_array_type == 0) ? 0 : vl_rbsp_u(rbsp, 1);
    }
 
    for (i = 0; i < params->num_ref_idx_l0_active; ++i) {
@@ -1316,11 +1308,7 @@ h265_pred_weight_table(struct vk_video_h265_slice_params *params,
       }
 
       for (i = 0; i < params->num_ref_idx_l1_active; ++i) {
-         if (chroma_array_type == 0) {
-            params->chroma_weight_l1_flag[i] = 0;
-         } else {
-            params->chroma_weight_l1_flag[i] = vl_rbsp_u(rbsp, 1);
-         }
+         params->chroma_weight_l1_flag[i] = (chroma_array_type == 0) ? 0 : vl_rbsp_u(rbsp, 1);
       }
 
       for (i = 0; i < params->num_ref_idx_l1_active; ++i) {
-- 
GitLab


From a80876a750f3ceb105787244ea5ff77e994e7df7 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 15:05:03 +0300
Subject: [PATCH 16/31] vulkan: align generated structures from Python

---
 src/vulkan/util/vk_cmd_queue_gen.py           | 77 +++++++++++++++++-
 .../util/vk_physical_device_properties_gen.py | 78 ++++++++++++++++++-
 2 files changed, 153 insertions(+), 2 deletions(-)

diff --git a/src/vulkan/util/vk_cmd_queue_gen.py b/src/vulkan/util/vk_cmd_queue_gen.py
index b2b75ac5d58b0..170a9c588fa7c 100644
--- a/src/vulkan/util/vk_cmd_queue_gen.py
+++ b/src/vulkan/util/vk_cmd_queue_gen.py
@@ -119,7 +119,7 @@ extern size_t vk_cmd_queue_type_sizes[];
 #ifdef ${c.guard}
 % endif
 struct ${to_struct_name(c.name)} {
-% for p in c.params[1:]:
+% for p in align_structure_fields(c.params[1:]):
    ${to_field_decl(p.decl)};
 % endfor
 };
@@ -443,6 +443,80 @@ def to_field_decl(decl):
     [decl, name] = decl.rsplit(' ', 1)
     return decl + ' ' + to_field_name(name)
 
+def align_structure_fields(params):
+    """
+    Aligns structure fields for x64 architecture.
+    This function reorders fields to minimize padding and ensures proper alignment.
+    """
+    type_sizes = {
+        'char': 1,
+        'int8_t': 1,
+        'uint8_t': 1,
+        'int16_t': 2,
+        'uint16_t': 2,
+        'VkAccessFlags': 4,
+        'VkBlendFactor': 4,
+        'VkBlendOp': 4,
+        'VkBool32': 4,
+        'VkBorderColor': 4,
+        'VkCompareOp': 4,
+        'VkCullModeFlags': 4,
+        'VkDescriptorUpdateTemplateType': 4,
+        'VkFilter': 4,
+        'VkFlags': 4,
+        'VkFormat': 4,
+        'VkImageAspectFlags': 4,
+        'VkImageLayout': 4,
+        'VkImageUsageFlags': 4,
+        'VkLogicOp': 4,
+        'VkMemoryPropertyFlags': 4,
+        'VkPhysicalDeviceType': 4,
+        'VkPipelineBindPoint': 4,
+        'VkPipelineStageFlagBits': 4,
+        'VkPipelineStageFlags': 4,
+        'VkQueryPipelineStatisticFlags': 4,
+        'VkQueueFlags': 4,
+        'VkResult': 4,
+        'VkSampleCountFlags': 4,
+        'VkSamplerMipmapMode': 4,
+        'VkStencilOp': 4,
+        'VkStructureType': 4,
+        'float': 4,
+        'int32_t': 4,
+        'uint32_t': 4,
+        'VkExtent2D': 8,
+        'VkBuffer': 8,
+        'VkBufferUsageFlags': 4,
+        'VkDeviceAddress': 8,
+        'VkDeviceOrHostAddressConstAMDX': 8,
+        'VkDeviceSize': 8,
+        'VkImage': 8,
+        'VkOffset2D': 8,
+        'VkPipeline': 8,
+        'VkPipelineLayout': 8,
+        'VkQueryPool': 8,
+        'double': 8,
+        'int64_t': 8,
+        'uint64_t': 8,
+        'void*': 8,
+    }
+
+
+    def get_param_size(param):
+        # Heuristic to determine size based on type name and pointers
+        if '*' in param.decl or 'const*' in param.decl:
+            return 8  # Pointers are 8 bytes on x64
+        for type_name, size in type_sizes.items():
+            if type_name in param.decl:
+                return size
+        return 4 # Default to 4 bytes for unknown types (e.g., enums, handles)
+
+    sized_params = [(get_param_size(p), p) for p in params]
+    sized_params.sort(key=lambda x: x[0], reverse=True)
+    aligned_params = [p for size, p in sized_params]
+
+    return aligned_params
+
 def to_enum_name(name):
     return "VK_%s" % to_underscore(name).upper()
 
@@ -772,6 +846,7 @@ def main():
         'to_struct_field_name': to_struct_field_name,
         'to_field_name': to_field_name,
         'to_field_decl': to_field_decl,
+        'align_structure_fields': align_structure_fields,
         'to_enum_name': to_enum_name,
         'to_struct_name': to_struct_name,
         'get_params_copy': get_params_copy,
diff --git a/src/vulkan/util/vk_physical_device_properties_gen.py b/src/vulkan/util/vk_physical_device_properties_gen.py
index 5af1c17803154..5a983d167e253 100644
--- a/src/vulkan/util/vk_physical_device_properties_gen.py
+++ b/src/vulkan/util/vk_physical_device_properties_gen.py
@@ -161,7 +161,7 @@ extern "C" {
 #endif
 
 struct vk_properties {
-% for prop in all_properties:
+% for prop in align_structure_fields(all_properties):
    ${prop.decl};
 % endfor
 };
@@ -330,6 +330,81 @@ def get_property_structs(doc, api, beta):
 
     return property_structs.values()
 
+def align_structure_fields(params):
+    """
+    Aligns structure fields for x64 architecture.
+    This function reorders fields to minimize padding and ensures proper alignment.
+    """
+    type_sizes = {
+        'char': 1,
+        'int8_t': 1,
+        'uint8_t': 1,
+        'int16_t': 2,
+        'uint16_t': 2,
+        'VkAccessFlags': 4,
+        'VkBlendFactor': 4,
+        'VkBlendOp': 4,
+        'VkBool32': 4,
+        'VkBorderColor': 4,
+        'VkCompareOp': 4,
+        'VkCullModeFlags': 4,
+        'VkDescriptorUpdateTemplateType': 4,
+        'VkFilter': 4,
+        'VkFlags': 4,
+        'VkFormat': 4,
+        'VkImageAspectFlags': 4,
+        'VkImageLayout': 4,
+        'VkImageUsageFlags': 4,
+        'VkLogicOp': 4,
+        'VkMemoryPropertyFlags': 4,
+        'VkPhysicalDeviceType': 4,
+        'VkPipelineBindPoint': 4,
+        'VkPipelineStageFlagBits': 4,
+        'VkPipelineStageFlags': 4,
+        'VkQueryPipelineStatisticFlags': 4,
+        'VkQueueFlags': 4,
+        'VkResult': 4,
+        'VkSampleCountFlags': 4,
+        'VkSamplerMipmapMode': 4,
+        'VkStencilOp': 4,
+        'VkStructureType': 4,
+        'float': 4,
+        'int32_t': 4,
+        'uint32_t': 4,
+        'VkBufferUsageFlags': 4,
+        'VkExtent2D': 8,
+        'VkBuffer': 8,
+        'VkDeviceAddress': 8,
+        'VkDeviceOrHostAddressConstAMDX': 8,
+        'VkDeviceSize': 8,
+        'VkImage': 8,
+        'VkOffset2D': 8,
+        'VkPipeline': 8,
+        'VkPipelineLayout': 8,
+        'VkQueryPool': 8,
+        'double': 8,
+        'int64_t': 8,
+        'uint64_t': 8,
+        'size_t': 8,
+        'void*': 8,
+    }
+
+
+    def get_param_size(param):
+        # Heuristic to determine size based on type name and pointers
+        if '*' in param.decl or 'const*' in param.decl:
+            return 8  # Pointers are 8 bytes on x64
+        for type_name, size in type_sizes.items():
+            if type_name in param.decl:
+                return size
+        return 4 # Default to 4 bytes for unknown types (e.g., enums, handles)
+
+    sized_params = [(get_param_size(p), p) for p in params]
+    sized_params.sort(key=lambda x: x[0], reverse=True)
+    aligned_params = [p for size, p in sized_params]
+
+    return aligned_params
+
 def get_property_structs_from_xml(xml_files, beta, api="vulkan"):
     diagnostics = []
 
@@ -388,6 +463,7 @@ def main():
         "pdev_properties": pdev_properties,
         "property_structs": property_structs,
         "all_properties": all_properties,
+        "align_structure_fields": align_structure_fields,
         "copy_property": copy_property,
         "SPECIALIZED_PROPERTY_STRUCTS": SPECIALIZED_PROPERTY_STRUCTS,
     }
-- 
GitLab


From 8aa11971504ba9d0346eefcbee66fc3b3820eed2 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 15:09:21 +0300
Subject: [PATCH 17/31] mesa/vulkan: align latest structures for 64-bit

---
 src/mesa/main/consts_exts.h           | 36 +++++++++++++--------------
 src/util/u_queue.h                    |  6 ++---
 src/vulkan/runtime/vk_device_memory.h |  6 ++---
 3 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 45273edee517c..34c8a71eb986b 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -764,12 +764,6 @@ struct gl_constants
     */
    GLuint64 MaxElementIndex;
 
-   /**
-    * Disable interpretation of line continuations (lines ending with a
-    * backslash character ('\') in GLSL source.
-    */
-   GLboolean DisableGLSLLineContinuations;
-
    /** GL_ARB_texture_multisample */
    GLint MaxColorTextureSamples;
    GLint MaxDepthTextureSamples;
@@ -820,6 +814,15 @@ struct gl_constants
    GLfloat MinFragmentInterpolationOffset;
    GLfloat MaxFragmentInterpolationOffset;
 
+   /**
+    * Disable interpretation of line continuations (lines ending with a
+    * backslash character ('\') in GLSL source.
+    */
+   GLboolean DisableGLSLLineContinuations;
+
+   /** GL_OES_primitive_bounding_box */
+   bool NoPrimitiveBoundingBoxOutput;
+
    /**
     * UBOs and SSBOs can be packed tightly by the OpenGL implementation when
     * layout is set as shared (the default) or packed. However most Mesa drivers
@@ -853,6 +856,12 @@ struct gl_constants
    /** (driconf) Force gl_Position to be considered precise */
    GLboolean TESPositionAlwaysPrecise;
 
+   /** When drivers are OK with mapped buffers during draw and other calls. */
+   bool AllowMappedBuffersDuringExecution;
+
+   /** Override GL_MAP_UNSYNCHRONIZED_BIT */
+   bool ForceMapBufferSynchronized;
+
    /** GL_ARB_tessellation_shader */
    bool PrimitiveRestartForPatches;
    GLuint MaxPatchVertices;
@@ -860,12 +869,6 @@ struct gl_constants
    GLuint MaxTessPatchComponents;
    GLuint MaxTessControlTotalOutputComponents;
 
-   /** GL_OES_primitive_bounding_box */
-   bool NoPrimitiveBoundingBoxOutput;
-
-   /** GL_ARB_sparse_buffer */
-   GLuint SparseBufferPageSize;
-
    /** Used as an input for sha1 generation in the on-disk shader cache */
    unsigned char *dri_config_options_sha1;
 
@@ -882,12 +885,6 @@ struct gl_constants
    GLfloat ConservativeRasterDilateRange[2];
    GLfloat ConservativeRasterDilateGranularity;
 
-   /** When drivers are OK with mapped buffers during draw and other calls. */
-   bool AllowMappedBuffersDuringExecution;
-
-   /** Override GL_MAP_UNSYNCHRONIZED_BIT */
-   bool ForceMapBufferSynchronized;
-
    /** Override GL_DEPTH_COMPONENT type from unsigned short to unsigned int */
    bool ForceDepthComponentTypeInt;
 
@@ -963,6 +960,9 @@ struct gl_constants
    GLuint ShaderSubgroupSupportedStages;
    GLuint ShaderSubgroupSupportedFeatures;
 
+   /** GL_ARB_sparse_buffer */
+   GLuint SparseBufferPageSize;
+
    /* NV_timeline_semaphore */
    GLuint64 MaxTimelineSemaphoreValueDifference;
 };
diff --git a/src/util/u_queue.h b/src/util/u_queue.h
index 5077d373fc09d..7448f9d2f190a 100644
--- a/src/util/u_queue.h
+++ b/src/util/u_queue.h
@@ -223,14 +223,14 @@ struct util_queue_job {
 /* Put this into your context. */
 struct util_queue {
    char name[14]; /* 13 characters = the thread name without the index */
-   bool create_threads_on_demand;
+   unsigned short max_threads;
    mtx_t lock;
    cnd_t has_queued_cond;
    cnd_t has_space_cond;
    thrd_t *threads;
-   unsigned flags;
    int num_queued;
-   unsigned max_threads;
+   bool create_threads_on_demand : 1;
+   unsigned flags : 31;
    unsigned num_threads; /* decreasing this number will terminate threads */
    int max_jobs;
    int write_idx, read_idx; /* ring buffer pointers */
diff --git a/src/vulkan/runtime/vk_device_memory.h b/src/vulkan/runtime/vk_device_memory.h
index 6e490172011f5..17f438829826e 100644
--- a/src/vulkan/runtime/vk_device_memory.h
+++ b/src/vulkan/runtime/vk_device_memory.h
@@ -37,12 +37,12 @@ struct vk_device_memory {
    /* VkMemoryAllocateFlagsInfo::flags */
    VkMemoryAllocateFlags alloc_flags;
 
-   /* VkMemoryAllocateInfo::allocationSize */
-   VkDeviceSize size;
-
    /* VkMemoryAllocateInfo::memoryTypeIndex */
    uint32_t memory_type_index;
 
+   /* VkMemoryAllocateInfo::allocationSize */
+   VkDeviceSize size;
+
    /* Import handle type (if any) */
    VkExternalMemoryHandleTypeFlags import_handle_type;
 
-- 
GitLab


From 3f53828652e55a7974a966abed5cff6ad7e49b3a Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:14:00 +0300
Subject: [PATCH 18/31] vulkan: duplicate pow() better move to local variable

---
 src/vulkan/runtime/vk_nir_convert_ycbcr.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/vulkan/runtime/vk_nir_convert_ycbcr.c b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
index ac5230e3be6b1..5e47c113e4b08 100644
--- a/src/vulkan/runtime/vk_nir_convert_ycbcr.c
+++ b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
@@ -39,12 +39,13 @@ y_range(nir_builder *b,
    case VK_SAMPLER_YCBCR_RANGE_ITU_FULL:
       return y_channel;
    case VK_SAMPLER_YCBCR_RANGE_ITU_NARROW:
+      float fpow = pow(2, bpc - 8);
       return nir_fmul_imm(b,
                           nir_fadd_imm(b,
                                        nir_fmul_imm(b, y_channel,
                                                     pow(2, bpc) - 1),
-                                       -16.0f * pow(2, bpc - 8)),
-                          1.0f / (219.0f * pow(2, bpc - 8)));
+                                       -16.0f * fpow),
+                          1.0f / (219.0f * fpow));
 
    default:
       UNREACHABLE("missing Ycbcr range");
@@ -63,12 +64,13 @@ chroma_range(nir_builder *b,
       return nir_fadd(b, chroma_channel,
                       nir_imm_float(b, -pow(2, bpc - 1) / (pow(2, bpc) - 1.0f)));
    case VK_SAMPLER_YCBCR_RANGE_ITU_NARROW:
+      float fpow = pow(2, bpc - 8);
       return nir_fmul_imm(b,
                           nir_fadd_imm(b,
                                        nir_fmul_imm(b, chroma_channel,
                                                     pow(2, bpc) - 1),
-                                       -128.0f * pow(2, bpc - 8)),
-                          1.0f / (224.0f * pow(2, bpc - 8)));
+                                       -128.0f * fpow),
+                          1.0f / (224.0f * fpow));
    default:
       UNREACHABLE("missing Ycbcr range");
       return NULL;
-- 
GitLab


From 3f763657aded946488a9ed3b99c7286b40947de0 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:17:08 +0300
Subject: [PATCH 19/31] amd/intel/gallium/compiler: strict set de/constructors
 as default

Reference: https://stackoverflow.com/questions/59261490/why-is-there-performance-variation-using-default-constructor-instead-of
---
 src/amd/compiler/aco_insert_delay_alu.cpp          | 2 +-
 src/amd/compiler/aco_insert_waitcnt.cpp            | 2 +-
 src/compiler/clc/clc_helpers.cpp                   | 4 ++--
 src/compiler/glsl/ast.h                            | 2 +-
 src/compiler/glsl/glsl_parser_extras.cpp           | 8 ++------
 src/gallium/auxiliary/gallivm/lp_bld_misc.cpp      | 3 +--
 src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp | 5 +----
 src/gallium/drivers/r600/sfn/sfn_callstack.cpp     | 2 +-
 src/intel/compiler/brw_generator.cpp               | 4 +---
 src/intel/compiler/elk/elk_fs_generator.cpp        | 4 +---
 src/intel/compiler/elk/elk_ir.h                    | 2 +-
 src/mesa/main/texcompress_astc.cpp                 | 2 +-
 12 files changed, 14 insertions(+), 26 deletions(-)

diff --git a/src/amd/compiler/aco_insert_delay_alu.cpp b/src/amd/compiler/aco_insert_delay_alu.cpp
index 1b5042839ba68..fd188746ed869 100644
--- a/src/amd/compiler/aco_insert_delay_alu.cpp
+++ b/src/amd/compiler/aco_insert_delay_alu.cpp
@@ -109,7 +109,7 @@ struct delay_ctx {
    Program* program;
    std::map<PhysReg, alu_delay_info> gpr_map;
 
-   delay_ctx() {}
+   delay_ctx() = default;
    delay_ctx(Program* program_) : program(program_) {}
 
    UNUSED void print(FILE* output) const
diff --git a/src/amd/compiler/aco_insert_waitcnt.cpp b/src/amd/compiler/aco_insert_waitcnt.cpp
index 97cf9229255ba..39a342b9b4618 100644
--- a/src/amd/compiler/aco_insert_waitcnt.cpp
+++ b/src/amd/compiler/aco_insert_waitcnt.cpp
@@ -232,7 +232,7 @@ struct wait_ctx {
 
    std::map<PhysReg, wait_entry> gpr_map;
 
-   wait_ctx() {}
+   wait_ctx() = default;
    wait_ctx(Program* program_, const target_info* info_)
        : program(program_), gfx_level(program_->gfx_level), info(info_)
    {}
diff --git a/src/compiler/clc/clc_helpers.cpp b/src/compiler/clc/clc_helpers.cpp
index 7e23effca39c6..61b771b5497a7 100644
--- a/src/compiler/clc/clc_helpers.cpp
+++ b/src/compiler/clc/clc_helpers.cpp
@@ -129,7 +129,7 @@ public:
                                                   addrQualifier(CLC_KERNEL_ARG_ADDRESS_PRIVATE),
                                                   accessQualifier(0),
                                                   typeQualifier(0) { }
-   ~SPIRVKernelArg() { }
+   ~SPIRVKernelArg() = default;
 
    uint32_t id;
    uint32_t typeId;
@@ -144,7 +144,7 @@ class SPIRVKernelInfo {
 public:
    SPIRVKernelInfo(uint32_t fid, const char *nm)
       : funcId(fid), name(nm), vecHint(0), localSize(), localSizeHint() { }
-   ~SPIRVKernelInfo() { }
+   ~SPIRVKernelInfo() = default;
 
    uint32_t funcId;
    std::string name;
diff --git a/src/compiler/glsl/ast.h b/src/compiler/glsl/ast.h
index be639118c2b55..ea194df01bb4f 100644
--- a/src/compiler/glsl/ast.h
+++ b/src/compiler/glsl/ast.h
@@ -1246,7 +1246,7 @@ public:
 
 class ast_demote_statement : public ast_node {
 public:
-   ast_demote_statement(void) {}
+   ast_demote_statement(void) = default;
    virtual void print(void) const;
 
    virtual ir_rvalue *hir(ir_exec_list *instructions,
diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index ce9e4efea3451..9f0803fe2b2a2 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -1776,9 +1776,7 @@ void ast_case_label_list::print(void) const
 }
 
 
-ast_case_label_list::ast_case_label_list(void)
-{
-}
+ast_case_label_list::ast_case_label_list(void) = default;
 
 
 void ast_case_statement::print(void) const
@@ -1805,9 +1803,7 @@ void ast_case_statement_list::print(void) const
 }
 
 
-ast_case_statement_list::ast_case_statement_list(void)
-{
-}
+ast_case_statement_list::ast_case_statement_list(void) = default;
 
 
 void
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
index 29062bbfc1769..3a5b132d93cbd 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
+++ b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
@@ -245,8 +245,7 @@ class ShaderMemoryManager : public DelegatingJITMemoryManager {
          TheMM = MM;
       }
 
-      ~GeneratedCode() {
-      }
+      ~GeneratedCode() = default;
    };
 
    GeneratedCode *code;
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
index d6bec119750f2..8533a410d8aa8 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
@@ -85,10 +85,7 @@ BasicBlock::BasicBlock(Function *fn) : cfg(this), dom(this), func(fn)
    func->add(this, this->id);
 }
 
-BasicBlock::~BasicBlock()
-{
-   // nothing yet
-}
+BasicBlock::~BasicBlock() = default;
 
 BasicBlock *
 BasicBlock::clone(ClonePolicy<Function>& pol) const
diff --git a/src/gallium/drivers/r600/sfn/sfn_callstack.cpp b/src/gallium/drivers/r600/sfn/sfn_callstack.cpp
index 90f5d5e98dac2..abaabf137c818 100644
--- a/src/gallium/drivers/r600/sfn/sfn_callstack.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_callstack.cpp
@@ -13,7 +13,7 @@ CallStack::CallStack(r600_bytecode& bc):
 {
 }
 
-CallStack::~CallStack() {}
+CallStack::~CallStack() = default;
 
 int
 CallStack::push(unsigned type)
diff --git a/src/mesa/main/texcompress_astc.cpp b/src/mesa/main/texcompress_astc.cpp
index 4f8f4f50922bc..a206b38637d08 100644
--- a/src/mesa/main/texcompress_astc.cpp
+++ b/src/mesa/main/texcompress_astc.cpp
@@ -210,7 +210,7 @@ struct uint8x4_t
 {
    uint8_t v[4];
 
-   uint8x4_t() { }
+   uint8x4_t() = default;
 
    uint8x4_t(int a, int b, int c, int d)
    {
-- 
GitLab


From fa12348ffca2ef4d43d19a1cc9508f8f32ef24bf Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:19:18 +0300
Subject: [PATCH 20/31] amd: get value by ptr more faster than .value()

Also above in the code, there is already a pointer retrieval of the same variable.
---
 src/amd/compiler/aco_register_allocation.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index bbb8429032b7a..3396d5359b562 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -1792,7 +1792,7 @@ get_reg_vector(ra_ctx& ctx, const RegisterFile& reg_file, Temp temp, aco_ptr<Ins
          reg->reg_b += our_offset;
          /* make sure to only use byte offset if the instruction supports it */
          if (get_reg_specified(ctx, reg_file, temp.regClass(), instr, *reg, operand)) {
-            ctx.assignments[vec.parts[vec.index].tempId()].set_precolor_affinity(reg.value());
+            ctx.assignments[vec.parts[vec.index].tempId()].set_precolor_affinity(*reg);
             return reg;
          }
       }
-- 
GitLab


From 5a5ea40ae0a1016dd96a918a478ba65beb6bb7e3 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:23:51 +0300
Subject: [PATCH 21/31] intel/glsl: micro-op strstr() to strchr() using
 disassembler with -O3 flag

---
 src/compiler/glsl/glsl_parser_extras.cpp | 2 +-
 src/intel/decoder/intel_batch_decoder.c  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 9f0803fe2b2a2..123f89cf0593a 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -896,7 +896,7 @@ static const char *find_extension_alias(_mesa_glsl_parse_state *state, const cha
    if (exts) {
       for (field = strtok(exts, ","); field != NULL; field = strtok(NULL, ",")) {
          if(strncmp(name, field, strlen(name)) == 0) {
-            field = strstr(field, ":");
+            field = strchr(field, ':');
             if(field) {
                ext_alias = strdup(field + 1);
             }
diff --git a/src/intel/decoder/intel_batch_decoder.c b/src/intel/decoder/intel_batch_decoder.c
index e0b14fa8ea715..87d41d65e1b80 100644
--- a/src/intel/decoder/intel_batch_decoder.c
+++ b/src/intel/decoder/intel_batch_decoder.c
@@ -84,7 +84,7 @@ intel_batch_decode_ctx_init(struct intel_batch_decode_ctx *ctx,
          if (strlen(term) == 0)
             break;
 
-         filters = strstr(term, ",");
+         filters = strchr(term, ',');
 
          char *str = ralloc_strndup(ctx->filters, term,
                                     filters != NULL ?
-- 
GitLab


From 048de65e14ebe261647bdaa0ae988b1ab7ea0082 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:25:55 +0300
Subject: [PATCH 22/31] intel/elk: faster use initialization list than an
 assignment operator

Reference: https://cplusplus.com/forum/beginner/210627/
---
 src/intel/compiler/elk/elk_vec4_visitor.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/intel/compiler/elk/elk_vec4_visitor.cpp b/src/intel/compiler/elk/elk_vec4_visitor.cpp
index 3364b64d767dd..0a24edfa9a7f9 100644
--- a/src/intel/compiler/elk/elk_vec4_visitor.cpp
+++ b/src/intel/compiler/elk/elk_vec4_visitor.cpp
@@ -31,9 +31,9 @@ namespace elk {
 vec4_instruction::vec4_instruction(enum elk_opcode opcode, const dst_reg &dst,
                                    const src_reg &src0, const src_reg &src1,
                                    const src_reg &src2)
+                                      : dst(dst)
 {
    this->opcode = opcode;
-   this->dst = dst;
    this->src[0] = src0;
    this->src[1] = src1;
    this->src[2] = src2;
-- 
GitLab


From 49d8d2cf547a4d15b166bf53187bc4412b1d2535 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:46:28 +0300
Subject: [PATCH 23/31] amd/intel/nouveau/compiler: out-of-loop strlen
 optimization using disasm -O3 flag

---
 src/amd/common/ac_parse_ib.c                          |  3 ++-
 src/amd/vulkan/radv_debug_nir.c                       |  6 ++++--
 src/compiler/glsl/glsl_parser_extras.cpp              |  3 ++-
 src/compiler/nir/nir_precompiled.h                    |  3 ++-
 src/compiler/spirv/vtn_bindgen2.c                     |  3 ++-
 src/gallium/drivers/r600/eg_debug.c                   |  3 ++-
 src/intel/decoder/intel_batch_decoder.c               | 10 ++++++----
 src/intel/vulkan/anv_perf.c                           |  3 ++-
 src/intel/vulkan_hasvk/anv_perf.c                     |  3 ++-
 src/mesa/main/fbobject.c                              |  5 +++--
 src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_pdev.c |  3 ++-
 src/util/u_debug.c                                    |  3 ++-
 12 files changed, 31 insertions(+), 17 deletions(-)

diff --git a/src/amd/common/ac_parse_ib.c b/src/amd/common/ac_parse_ib.c
index e8f46fb89e553..af60e50700d7d 100644
--- a/src/amd/common/ac_parse_ib.c
+++ b/src/amd/common/ac_parse_ib.c
@@ -111,6 +111,7 @@ void ac_dump_reg(FILE *file, enum amd_gfx_level gfx_level, enum radeon_family fa
 
       print_value(file, value, 32);
 
+      size_t reg_name_len = strlen(reg_name);
       for (unsigned f = 0; f < reg->num_fields; f++) {
          const struct si_field *field = sid_fields_table + reg->fields_offset + f;
          const int *values_offsets = sid_strings_offsets + field->values_offset;
@@ -120,7 +121,7 @@ void ac_dump_reg(FILE *file, enum amd_gfx_level gfx_level, enum radeon_family fa
             continue;
 
          /* Indent the field. */
-         print_spaces(file, INDENT_PKT + strlen(reg_name) + 4);
+         print_spaces(file, INDENT_PKT + reg_name_len + 4);
 
          /* Print the field. */
          fprintf(file, "%s = ", sid_strings + field->name_offset);
diff --git a/src/amd/vulkan/radv_debug_nir.c b/src/amd/vulkan/radv_debug_nir.c
index 6018585796a5e..a7afe91e2a03b 100644
--- a/src/amd/vulkan/radv_debug_nir.c
+++ b/src/amd/vulkan/radv_debug_nir.c
@@ -223,7 +223,8 @@ radv_build_printf(nir_builder *b, nir_def *cond, const char *format_string, ...)
    va_start(arg_list, format_string);
 
    uint32_t num_args = 0;
-   for (uint32_t i = 0; i < strlen(format_string); i++)
+   size_t fmt_len = strlen(format_string);
+   for (uint32_t i = 0; i < fmt_len; i++)
       if (format_string[i] == '%')
          num_args++;
 
@@ -261,7 +262,8 @@ radv_dump_printf_data(struct radv_device *device, FILE *out)
       uint32_t invocation_count = printf_header & 0xFFFF;
 
       uint32_t num_args = 0;
-      for (uint32_t i = 0; i < strlen(printf_format->string); i++)
+      size_t fmt_len = strlen(printf_format->string);
+      for (uint32_t i = 0; i < fmt_len; i++)
          if (printf_format->string[i] == '%')
             num_args++;
 
diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 123f89cf0593a..cd1f0e55a3a15 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -894,8 +894,9 @@ static const char *find_extension_alias(_mesa_glsl_parse_state *state, const cha
    /* Copy alias_shader_extension because strtok() is destructive. */
    exts = strdup(state->alias_shader_extension);
    if (exts) {
+      size_t name_len = strlen(name);
       for (field = strtok(exts, ","); field != NULL; field = strtok(NULL, ",")) {
-         if(strncmp(name, field, strlen(name)) == 0) {
+         if(strncmp(name, field, name_len) == 0) {
             field = strchr(field, ':');
             if(field) {
                ext_alias = strdup(field + 1);
diff --git a/src/compiler/nir/nir_precompiled.h b/src/compiler/nir/nir_precompiled.h
index c94d70a1284e7..42844f37ff9ef 100644
--- a/src/compiler/nir/nir_precompiled.h
+++ b/src/compiler/nir/nir_precompiled.h
@@ -269,7 +269,8 @@ nir_precomp_index(const nir_shader *lib, const nir_function *func)
 static inline void
 nir_print_uppercase(FILE *fp, const char *str)
 {
-   for (unsigned i = 0; i < strlen(str); ++i) {
+   size_t len = strlen(str);
+   for (unsigned i = 0; i < len; ++i) {
       fputc(toupper(str[i]), fp);
    }
 }
diff --git a/src/compiler/spirv/vtn_bindgen2.c b/src/compiler/spirv/vtn_bindgen2.c
index 7a1381e8f7531..0c807118613c4 100644
--- a/src/compiler/spirv/vtn_bindgen2.c
+++ b/src/compiler/spirv/vtn_bindgen2.c
@@ -418,7 +418,8 @@ main(int argc, char **argv)
       const char *str = info->strings;
       fprintf(fp_c, "       * ");
 
-      for (unsigned j = 0; j < strlen(str); ++j) {
+      size_t str_len = strlen(str);
+      for (unsigned j = 0; j < str_len; ++j) {
          char c = str[j];
          if (c == '\n')
             fprintf(fp_c, "\\n");
diff --git a/src/gallium/drivers/r600/eg_debug.c b/src/gallium/drivers/r600/eg_debug.c
index dab0432e01a9a..0401289986b83 100644
--- a/src/gallium/drivers/r600/eg_debug.c
+++ b/src/gallium/drivers/r600/eg_debug.c
@@ -77,6 +77,7 @@ static void eg_dump_reg(FILE *file, unsigned offset, uint32_t value,
 				return;
 			}
 
+			size_t reg_name_len = strlen(reg_name);
 			for (f = 0; f < reg->num_fields; f++) {
 				const struct eg_field *field = egd_fields_table + reg->fields_offset + f;
 				const int *values_offsets = egd_strings_offsets + field->values_offset;
@@ -89,7 +90,7 @@ static void eg_dump_reg(FILE *file, unsigned offset, uint32_t value,
 				/* Indent the field. */
 				if (!first_field)
 					print_spaces(file,
-						     INDENT_PKT + strlen(reg_name) + 4);
+						     INDENT_PKT + reg_name_len + 4);
 
 				/* Print the field. */
 				fprintf(file, "%s = ", egd_strings + field->name_offset);
diff --git a/src/intel/decoder/intel_batch_decoder.c b/src/intel/decoder/intel_batch_decoder.c
index 87d41d65e1b80..76ca0b987ad81 100644
--- a/src/intel/decoder/intel_batch_decoder.c
+++ b/src/intel/decoder/intel_batch_decoder.c
@@ -755,10 +755,11 @@ decode_ps_kern(struct intel_batch_decode_ctx *ctx,
 
    struct intel_field_iterator iter;
    intel_field_iterator_init(&iter, inst, p, 0, false);
+   size_t start_ptr_len = strlen("Kernel Start Pointer ");
    while (intel_field_iterator_next(&iter)) {
       if (strncmp(iter.name, "Kernel Start Pointer ",
-                  strlen("Kernel Start Pointer ")) == 0) {
-         int idx = iter.name[strlen("Kernel Start Pointer ")] - '0';
+                  start_ptr_len) == 0) {
+         int idx = iter.name[start_ptr_len] - '0';
          ksp[idx] = strtol(iter.value, NULL, 16);
       } else if (strcmp(iter.name, "8 Pixel Dispatch Enable") == 0) {
          enabled[0] = strcmp(iter.value, "true") == 0;
@@ -808,10 +809,11 @@ decode_ps_kern_xe2(struct intel_batch_decode_ctx *ctx,
 
    struct intel_field_iterator iter;
    intel_field_iterator_init(&iter, inst, p, 0, false);
+   size_t start_ptr_len = strlen("Kernel Start Pointer ");
    while (intel_field_iterator_next(&iter)) {
       if (strncmp(iter.name, "Kernel Start Pointer ",
-                  strlen("Kernel Start Pointer ")) == 0) {
-         int idx = iter.name[strlen("Kernel Start Pointer ")] - '0';
+                  start_ptr_len) == 0) {
+         int idx = iter.name[start_ptr_len] - '0';
          ksp[idx] = strtol(iter.value, NULL, 16);
       } else if (strcmp(iter.name, "Kernel 0 Enable") == 0) {
          enabled[0] = strcmp(iter.value, "true") == 0;
diff --git a/src/intel/vulkan/anv_perf.c b/src/intel/vulkan/anv_perf.c
index a3cee161fb206..23c18939576c6 100644
--- a/src/intel/vulkan/anv_perf.c
+++ b/src/intel/vulkan/anv_perf.c
@@ -376,6 +376,7 @@ VkResult anv_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    for (int c = 0; c < (perf ? perf->n_counters : 0); c++) {
       const struct intel_perf_query_counter *intel_counter = perf->counter_infos[c].counter;
 
+      size_t name_len = strlen(intel_counter->symbol_name);
       vk_outarray_append_typed(VkPerformanceCounterKHR, &out, counter) {
          counter->unit = intel_perf_counter_unit_to_vk_unit[intel_counter->units];
          counter->scope = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;
@@ -383,7 +384,7 @@ VkResult anv_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
 
          unsigned char sha1_result[20];
          _mesa_sha1_compute(intel_counter->symbol_name,
-                            strlen(intel_counter->symbol_name),
+                            name_len,
                             sha1_result);
          memcpy(counter->uuid, sha1_result, sizeof(counter->uuid));
       }
diff --git a/src/intel/vulkan_hasvk/anv_perf.c b/src/intel/vulkan_hasvk/anv_perf.c
index 383d101dba643..568aaef7bbe2a 100644
--- a/src/intel/vulkan_hasvk/anv_perf.c
+++ b/src/intel/vulkan_hasvk/anv_perf.c
@@ -320,6 +320,7 @@ VkResult anv_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    for (int c = 0; c < (perf ? perf->n_counters : 0); c++) {
       const struct intel_perf_query_counter *intel_counter = perf->counter_infos[c].counter;
 
+      size_t name_len = strlen(intel_counter->symbol_name);
       vk_outarray_append_typed(VkPerformanceCounterKHR, &out, counter) {
          counter->unit = intel_perf_counter_unit_to_vk_unit[intel_counter->units];
          counter->scope = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;
@@ -327,7 +328,7 @@ VkResult anv_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
 
          unsigned char sha1_result[20];
          _mesa_sha1_compute(intel_counter->symbol_name,
-                            strlen(intel_counter->symbol_name),
+                            name_len,
                             sha1_result);
          memcpy(counter->uuid, sha1_result, sizeof(counter->uuid));
       }
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index d99345dc4855c..dac180992375f 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -5960,6 +5960,8 @@ sample_locations(struct gl_context *ctx, struct gl_framebuffer *fb,
          fb->SampleLocationTable[i] = 0.5f;
    }
 
+   static const char* msg = "Invalid sample location specified";
+   size_t msg_len = strlen(msg);
    for (i = 0; i < count * 2; i++) {
       /* The ARB_sample_locations spec says:
        *
@@ -5971,11 +5973,10 @@ sample_locations(struct gl_context *ctx, struct gl_framebuffer *fb,
        */
       if (isnan(v[i]) || v[i] < 0.0f || v[i] > 1.0f) {
          static GLuint msg_id = 0;
-         static const char* msg = "Invalid sample location specified";
          _mesa_debug_get_id(&msg_id);
 
          _mesa_log_msg(ctx, MESA_DEBUG_SOURCE_API, MESA_DEBUG_TYPE_UNDEFINED,
-                       msg_id, MESA_DEBUG_SEVERITY_HIGH, strlen(msg), msg);
+                       msg_id, MESA_DEBUG_SEVERITY_HIGH, msg_len, msg);
       }
 
       if (isnan(v[i]))
diff --git a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_pdev.c b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_pdev.c
index 4cd8c7a5a2f28..8155c37284c0a 100644
--- a/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_pdev.c
+++ b/src/nouveau/vulkan/nvkmd/nouveau/nvkmd_nouveau_pdev.c
@@ -46,8 +46,9 @@ nvkmd_nouveau_try_create_pdev(struct _drmDevice *drm_device,
    case DRM_BUS_PLATFORM: {
       const char *compat_prefix = "nvidia,";
       bool found = false;
+      size_t compat_prefix_len = strlen(compat_prefix);
       for (int i = 0; drm_device->deviceinfo.platform->compatible[i] != NULL; i++) {
-         if (strncmp(drm_device->deviceinfo.platform->compatible[0], compat_prefix, strlen(compat_prefix)) == 0) {
+         if (strncmp(drm_device->deviceinfo.platform->compatible[0], compat_prefix, compat_prefix_len) == 0) {
             found = true;
             break;
          }
diff --git a/src/util/u_debug.c b/src/util/u_debug.c
index 96f7ccaaeb0af..a8293e0df84e9 100644
--- a/src/util/u_debug.c
+++ b/src/util/u_debug.c
@@ -427,12 +427,13 @@ parse_debug_string(const char *debug,
          const char *s = debug;
          unsigned n;
 
+         size_t control_len = strlen(control->string);
          for (; n = strcspn(s, ", \n"), *s; s += MAX2(1, n)) {
             if (!n)
                continue;
 
             if (!strncmp("all", s, n) ||
-                (strlen(control->string) == n &&
+                (control_len == n &&
                 !strncmp(control->string, s, n)))
                flag |= control->flag;
          }
-- 
GitLab


From 04e2385def6213b5480f7952117308d6dd727304 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 00:10:10 +0300
Subject: [PATCH 24/31] gallium/utils/mesa: micro-op free() and delete don't
 need to be excess check

Reference:

https://stackoverflow.com/questions/6084218/is-it-good-practice-to-free-a-null-pointer-in-c

https://stackoverflow.com/questions/3821261/null-check-before-deleting-an-object-with-an-overloaded-delete
---
 src/compiler/nir/nir_gather_output_deps.c            |  3 +--
 src/gallium/auxiliary/draw/draw_llvm.c               | 12 ++++--------
 .../draw/draw_pt_fetch_shade_pipeline_llvm.c         |  4 +---
 src/gallium/drivers/llvmpipe/lp_state_cs.c           |  3 +--
 src/gallium/drivers/llvmpipe/lp_state_fs.c           |  9 +++------
 src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp   |  6 ++----
 .../drivers/nouveau/codegen/nv50_ir_graph.cpp        |  6 ++----
 src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp   |  3 +--
 src/gallium/drivers/nouveau/codegen/nv50_ir_ssa.cpp  |  3 +--
 src/gallium/drivers/nouveau/codegen/nv50_ir_util.h   | 10 ++++------
 src/gallium/drivers/r600/r600_shader.c               |  3 +--
 src/gallium/drivers/r600/r600_state_common.c         |  3 +--
 src/gallium/drivers/radeonsi/radeon_vcn_dec.c        |  6 ++----
 src/gallium/drivers/radeonsi/si_sqtt.c               |  3 +--
 src/gallium/drivers/radeonsi/si_vpe.c                | 12 ++++--------
 src/gallium/drivers/svga/svga_resource_texture.c     |  6 ++----
 src/gallium/drivers/svga/svga_state_tgsi_transform.c |  3 +--
 src/gallium/winsys/amdgpu/drm/amdgpu_bo.c            |  3 +--
 src/mesa/program/program_parse.y                     |  4 +---
 src/mesa/vbo/vbo_save.c                              |  3 +--
 src/util/disk_cache_os.c                             |  9 +++------
 src/util/hash_table.c                                |  3 +--
 src/util/u_idalloc.c                                 |  3 +--
 src/util/u_process.c                                 |  4 +---
 src/util/xmlconfig.c                                 |  4 +---
 25 files changed, 42 insertions(+), 86 deletions(-)

diff --git a/src/compiler/nir/nir_gather_output_deps.c b/src/compiler/nir/nir_gather_output_deps.c
index 2fa689b8c7f10..41ab1f4960f70 100644
--- a/src/compiler/nir/nir_gather_output_deps.c
+++ b/src/compiler/nir/nir_gather_output_deps.c
@@ -338,8 +338,7 @@ nir_free_output_dependencies(nir_output_deps *deps)
 {
    for (unsigned i = 0; i < ARRAY_SIZE(deps->output); i++) {
       assert(!!deps->output[i].instr_list == !!deps->output[i].num_instr);
-      if (deps->output[i].instr_list)
-         free(deps->output[i].instr_list);
+      free(deps->output[i].instr_list);
    }
 }
 
diff --git a/src/gallium/auxiliary/draw/draw_llvm.c b/src/gallium/auxiliary/draw/draw_llvm.c
index 2d0053ab0b974..8bf477b1d67de 100644
--- a/src/gallium/auxiliary/draw/draw_llvm.c
+++ b/src/gallium/auxiliary/draw/draw_llvm.c
@@ -2252,8 +2252,7 @@ draw_llvm_destroy_variant(struct draw_llvm_variant *variant)
    variant->shader->variants_cached--;
    list_del(&variant->list_item_global.list);
    llvm->nr_variants--;
-   if(variant->function_name)
-      FREE(variant->function_name);
+   FREE(variant->function_name);
    FREE(variant);
 }
 
@@ -2582,8 +2581,7 @@ draw_gs_llvm_destroy_variant(struct draw_gs_llvm_variant *variant)
    variant->shader->variants_cached--;
    list_del(&variant->list_item_global.list);
    llvm->nr_gs_variants--;
-   if(variant->function_name)
-      FREE(variant->function_name);
+   FREE(variant->function_name);
    FREE(variant);
 }
 
@@ -3257,8 +3255,7 @@ draw_tcs_llvm_destroy_variant(struct draw_tcs_llvm_variant *variant)
    variant->shader->variants_cached--;
    list_del(&variant->list_item_global.list);
    llvm->nr_tcs_variants--;
-   if(variant->function_name)
-      FREE(variant->function_name);
+   FREE(variant->function_name);
    FREE(variant);
 }
 
@@ -3797,8 +3794,7 @@ draw_tes_llvm_destroy_variant(struct draw_tes_llvm_variant *variant)
    variant->shader->variants_cached--;
    list_del(&variant->list_item_global.list);
    llvm->nr_tes_variants--;
-   if(variant->function_name)
-      FREE(variant->function_name);
+   FREE(variant->function_name);
    FREE(variant);
 }
 
diff --git a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline_llvm.c b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline_llvm.c
index 749890aa0a62e..a76a790a85d51 100644
--- a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline_llvm.c
+++ b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_pipeline_llvm.c
@@ -730,9 +730,7 @@ llvm_pipeline_generic(struct draw_pt_middle_end *middle,
        FREE(gs_vert_info[i].verts);
    }
 
-   if (patch_lengths) {
-      FREE(patch_lengths);
-   }
+   FREE(patch_lengths);
 
    if (free_prim_info) {
       FREE(tes_elts_out);
diff --git a/src/gallium/drivers/llvmpipe/lp_state_cs.c b/src/gallium/drivers/llvmpipe/lp_state_cs.c
index 916cf362c2e18..ea00ab9d98873 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_cs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_cs.c
@@ -1069,8 +1069,7 @@ llvmpipe_remove_cs_shader_variant(struct llvmpipe_context *lp,
    lp->nr_cs_variants--;
    lp->nr_cs_instrs -= variant->nr_instrs;
 
-   if(variant->function_name)
-      FREE(variant->function_name);
+   FREE(variant->function_name);
    FREE(variant);
 }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index c3dba775369d9..74cee68f57247 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -4184,12 +4184,9 @@ llvmpipe_destroy_shader_variant(struct llvmpipe_context *lp,
 {
    gallivm_destroy(variant->gallivm);
    lp_fs_reference(lp, &variant->shader, NULL);
-   if (variant->function_name[RAST_EDGE_TEST])
-      FREE(variant->function_name[RAST_EDGE_TEST]);
-   if (variant->function_name[RAST_WHOLE])
-      FREE(variant->function_name[RAST_WHOLE]);
-   if (variant->linear_function_name)
-      FREE(variant->linear_function_name);
+   FREE(variant->function_name[RAST_EDGE_TEST]);
+   FREE(variant->function_name[RAST_WHOLE]);
+   FREE(variant->linear_function_name);
    FREE(variant);
 }
 
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
index 8533a410d8aa8..0de81e4fef900 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
@@ -51,10 +51,8 @@ Function::~Function()
 {
    prog->del(this, id);
 
-   if (domTree)
-      delete domTree;
-   if (bbArray)
-      delete[] bbArray;
+   delete domTree;
+   delete[] bbArray;
 
    // clear value refs and defs
    ins.clear();
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_graph.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_graph.cpp
index 3b0373e8c0eef..4b6eb36be2676 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_graph.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_graph.cpp
@@ -213,8 +213,7 @@ public:
 
    ~DFSIterator()
    {
-      if (nodes)
-         delete[] nodes;
+      delete[] nodes;
    }
 
    void search(Graph::Node *node, const bool preorder, const int sequence)
@@ -271,8 +270,7 @@ public:
 
    ~CFGIterator()
    {
-      if (nodes)
-         delete[] nodes;
+      delete[] nodes;
    }
 
    virtual void *get() const { return nodes[pos]; }
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp
index f0fad0ded4e57..3efceaa357bca 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp
@@ -1131,8 +1131,7 @@ GCRA::GCRA(Function *fn, SpillCodeInserter& spill, MergedDefs& mergedDefs) :
 
 GCRA::~GCRA()
 {
-   if (nodes)
-      delete[] nodes;
+   delete[] nodes;
 }
 
 void
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_ssa.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_ssa.cpp
index 27f8c2be1775a..aace75da807bf 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_ssa.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_ssa.cpp
@@ -409,8 +409,7 @@ RenamePass::RenamePass(Function *fn) : func(fn), prog(fn->getProgram())
 
 RenamePass::~RenamePass()
 {
-   if (stack)
-      delete[] stack;
+   delete[] stack;
 }
 
 LValue *
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_util.h b/src/gallium/drivers/nouveau/codegen/nv50_ir_util.h
index e5a7d90c78d4b..76a5f43c47d76 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_util.h
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_util.h
@@ -249,7 +249,7 @@ public:
    };
 
    Stack() : size(0), limit(0), array(0) { }
-   ~Stack() { if (array) FREE(array); }
+   ~Stack() { FREE(array); }
 
    Stack(const Stack&) = delete;
    Stack& operator=(const Stack&) = delete;
@@ -320,7 +320,7 @@ public:
 
    DynArray() : data(NULL), size(0) { }
 
-   ~DynArray() { if (data) FREE(data); }
+   ~DynArray() { FREE(data); }
 
    DynArray(const DynArray&) = delete;
    DynArray& operator=(const DynArray&) = delete;
@@ -491,8 +491,7 @@ public:
    }
    ~BitSet()
    {
-      if (data)
-         FREE(data);
+      FREE(data);
    }
 
    BitSet(const BitSet&) = delete;
@@ -635,8 +634,7 @@ public:
       unsigned int allocCount = (count + (1 << objStepLog2) - 1) >> objStepLog2;
       for (unsigned int i = 0; i < allocCount && allocArray[i]; ++i)
          FREE(allocArray[i]);
-      if (allocArray)
-         FREE(allocArray);
+      FREE(allocArray);
    }
 
    MemoryPool(const MemoryPool&) = delete;
diff --git a/src/gallium/drivers/r600/r600_shader.c b/src/gallium/drivers/r600/r600_shader.c
index 951e8ca684d07..47e505c596489 100644
--- a/src/gallium/drivers/r600/r600_shader.c
+++ b/src/gallium/drivers/r600/r600_shader.c
@@ -311,8 +311,7 @@ void r600_pipe_shader_destroy(struct pipe_context *ctx UNUSED, struct r600_pipe_
 		r600_bytecode_clear(&shader->shader.bc);
 	r600_release_command_buffer(&shader->command_buffer);
 
-	if (shader->shader.arrays)
-		free(shader->shader.arrays);
+	free(shader->shader.arrays);
 }
 
 struct r600_shader_ctx {
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index 708c777c3e7cd..bc3fd36c423c5 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -1160,8 +1160,7 @@ void r600_delete_shader_selector(struct pipe_context *ctx,
 	}
 	else if (sel->ir_type == PIPE_SHADER_IR_NIR)
 		ralloc_free(sel->nir);
-	if (sel->nir_blob)
-		free(sel->nir_blob);
+	free(sel->nir_blob);
 	free(sel);
 }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_dec.c b/src/gallium/drivers/radeonsi/radeon_vcn_dec.c
index 073c7923bdd1d..9ce246815e0e6 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_dec.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_dec.c
@@ -3188,10 +3188,8 @@ error:
    si_vid_destroy_buffer(&dec->sessionctx);
 
 err:
-   if (dec->jcs)
-      FREE(dec->jcs);
-   if (dec->jctx)
-      FREE(dec->jctx);
+   FREE(dec->jcs);
+   FREE(dec->jctx);
    FREE(dec);
 
    return NULL;
diff --git a/src/gallium/drivers/radeonsi/si_sqtt.c b/src/gallium/drivers/radeonsi/si_sqtt.c
index 818736dbdcac0..996f89f787c31 100644
--- a/src/gallium/drivers/radeonsi/si_sqtt.c
+++ b/src/gallium/drivers/radeonsi/si_sqtt.c
@@ -369,8 +369,7 @@ void si_destroy_sqtt(struct si_context *sctx)
    struct pb_buffer_lean *bo = sctx->sqtt->bo;
    radeon_bo_reference(sctx->screen->ws, &bo, NULL);
 
-   if (sctx->sqtt->trigger_file)
-      free(sctx->sqtt->trigger_file);
+   free(sctx->sqtt->trigger_file);
 
    for (int i = 0; i < ARRAY_SIZE(sctx->sqtt->start_cs); i++) {
       sscreen->ws->cs_destroy(sctx->sqtt->start_cs[i]);
diff --git a/src/gallium/drivers/radeonsi/si_vpe.c b/src/gallium/drivers/radeonsi/si_vpe.c
index 45c58c50c5998..e74bb481e0431 100644
--- a/src/gallium/drivers/radeonsi/si_vpe.c
+++ b/src/gallium/drivers/radeonsi/si_vpe.c
@@ -930,8 +930,7 @@ si_vpe_processor_destroy(struct pipe_video_codec *codec)
       vpe_destroy(&vpeproc->vpe_handle);
 
    if (vpeproc->vpe_build_param) {
-      if (vpeproc->vpe_build_param->streams)
-         FREE(vpeproc->vpe_build_param->streams);
+      FREE(vpeproc->vpe_build_param->streams);
       FREE(vpeproc->vpe_build_param);
    }
 
@@ -945,14 +944,11 @@ si_vpe_processor_destroy(struct pipe_video_codec *codec)
    if (vpeproc->gm_handle)
       tm_destroy(&vpeproc->gm_handle);
    
-   if (vpeproc->lut_data)
-      FREE(vpeproc->lut_data);
+   FREE(vpeproc->lut_data);
 
-   if (vpeproc->geometric_scaling_ratios)
-      FREE(vpeproc->geometric_scaling_ratios);
+   FREE(vpeproc->geometric_scaling_ratios);
 
-   if (vpeproc->lanczos_info)
-      FREE(vpeproc->lanczos_info);
+   FREE(vpeproc->lanczos_info);
 
    if (vpeproc->geometric_buf[0])
       vpeproc->geometric_buf[0]->destroy(vpeproc->geometric_buf[0]);
diff --git a/src/gallium/drivers/svga/svga_resource_texture.c b/src/gallium/drivers/svga/svga_resource_texture.c
index 44775527c9a77..85e9b96ccb9bc 100644
--- a/src/gallium/drivers/svga/svga_resource_texture.c
+++ b/src/gallium/drivers/svga/svga_resource_texture.c
@@ -1113,10 +1113,8 @@ svga_texture_create(struct pipe_screen *screen,
    return &tex->b;
 
 fail:
-   if (tex->dirty)
-      FREE(tex->dirty);
-   if (tex->defined)
-      FREE(tex->defined);
+   FREE(tex->dirty);
+   FREE(tex->defined);
    FREE(tex);
 fail_notex:
    SVGA_STATS_TIME_POP(svgascreen->sws);
diff --git a/src/gallium/drivers/svga/svga_state_tgsi_transform.c b/src/gallium/drivers/svga/svga_state_tgsi_transform.c
index 0497de7a4c54c..5c3737eb9a975 100644
--- a/src/gallium/drivers/svga/svga_state_tgsi_transform.c
+++ b/src/gallium/drivers/svga/svga_state_tgsi_transform.c
@@ -192,8 +192,7 @@ transform_dynamic_indexing(struct svga_context *svga,
    }
    transform_shader->token_key = key;
    bind_shader(svga, info->processor, transform_shader);
-   if (new_tokens)
-      FREE(new_tokens);
+   FREE(new_tokens);
 }
 
 
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
index d5646e9660b57..ce4e9f67659dc 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_bo.c
@@ -1726,8 +1726,7 @@ static struct pb_buffer_lean *amdgpu_bo_from_handle(struct radeon_winsys *rws,
 
 error:
    simple_mtx_unlock(&aws->bo_export_table_lock);
-   if (bo)
-      FREE(bo);
+   FREE(bo);
    if (va_handle)
       ac_drm_va_range_free(va_handle);
    ac_drm_bo_free(aws->dev, result.bo);
diff --git a/src/mesa/program/program_parse.y b/src/mesa/program/program_parse.y
index c227a03e8adb6..5da469855b588 100644
--- a/src/mesa/program/program_parse.y
+++ b/src/mesa/program/program_parse.y
@@ -2530,9 +2530,7 @@ yyerror(YYLTYPE *locp, struct asm_parser_state *state, const char *s)
                                locp->first_line, locp->first_column, s);
    _mesa_set_program_error(state->ctx, locp->position, err_str);
 
-   if (err_str) {
-      free(err_str);
-   }
+   free(err_str);
 }
 
 
diff --git a/src/mesa/vbo/vbo_save.c b/src/mesa/vbo/vbo_save.c
index ec43765c85af7..3632411307b37 100644
--- a/src/mesa/vbo/vbo_save.c
+++ b/src/mesa/vbo/vbo_save.c
@@ -72,8 +72,7 @@ void vbo_save_destroy( struct gl_context *ctx )
       save->vertex_store = NULL;
    }
 
-   if (save->copied.buffer)
-      free(save->copied.buffer);
+   free(save->copied.buffer);
 
    _mesa_reference_buffer_object(ctx, &save->current_bo, NULL);
 }
diff --git a/src/util/disk_cache_os.c b/src/util/disk_cache_os.c
index 5310e342e02e5..41de13d9f10e8 100644
--- a/src/util/disk_cache_os.c
+++ b/src/util/disk_cache_os.c
@@ -624,8 +624,7 @@ parse_and_validate_cache_item(struct disk_cache *cache, void *cache_item,
    return uncompressed_data;
 
  fail:
-   if (uncompressed_data)
-      free(uncompressed_data);
+   free(uncompressed_data);
 
    return NULL;
 }
@@ -664,10 +663,8 @@ disk_cache_load_item(struct disk_cache *cache, char *filename, size_t *size)
    return uncompressed_data;
 
  fail:
-   if (data)
-      free(data);
-   if (filename)
-      free(filename);
+   free(data);
+   free(filename);
    if (fd != -1)
       close(fd);
 
diff --git a/src/util/hash_table.c b/src/util/hash_table.c
index 9cf2e2c37f16c..e6bd3b9e3b7fe 100644
--- a/src/util/hash_table.c
+++ b/src/util/hash_table.c
@@ -936,8 +936,7 @@ _mesa_hash_table_u64_delete_key(struct hash_entry *entry)
 
    struct hash_key_u64 *_key = (struct hash_key_u64 *)entry->key;
 
-   if (_key)
-      FREE(_key);
+   FREE(_key);
 }
 
 void
diff --git a/src/util/u_idalloc.c b/src/util/u_idalloc.c
index 29e3fe07fdd14..d116802822a73 100644
--- a/src/util/u_idalloc.c
+++ b/src/util/u_idalloc.c
@@ -65,8 +65,7 @@ util_idalloc_init(struct util_idalloc *buf, unsigned initial_num_ids)
 void
 util_idalloc_fini(struct util_idalloc *buf)
 {
-   if (buf->data)
-      free(buf->data);
+   free(buf->data);
 }
 
 unsigned
diff --git a/src/util/u_process.c b/src/util/u_process.c
index 404936de50850..6846acd2e0bb3 100644
--- a/src/util/u_process.c
+++ b/src/util/u_process.c
@@ -79,9 +79,7 @@ __getProgramName()
          if (name)
             program_name = strdup(name + 1);
       }
-      if (path) {
-         free(path);
-      }
+      free(path);
       if (!program_name) {
          program_name = strdup(arg+1);
       }
diff --git a/src/util/xmlconfig.c b/src/util/xmlconfig.c
index a2b55d7af563f..f8a398949477b 100644
--- a/src/util/xmlconfig.c
+++ b/src/util/xmlconfig.c
@@ -1284,9 +1284,7 @@ driDestroyOptionInfo(driOptionCache *info)
    if (info->info) {
       uint32_t i, size = 1 << info->tableSize;
       for (i = 0; i < size; ++i) {
-         if (info->info[i].name) {
-            free(info->info[i].name);
-         }
+         free(info->info[i].name);
       }
       free(info->info);
    }
-- 
GitLab


From 41030d92e9cc8f3d9ab4c696d0f9b7c0d577e864 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 00:25:09 +0300
Subject: [PATCH 25/31] intel/amd/gallium: micro-op strlen() extra operation
 faster use hack

---
 src/amd/vulkan/radv_physical_device.c         | 2 +-
 src/compiler/glsl/standalone.cpp              | 4 ++--
 src/compiler/nir/nir_print.c                  | 2 +-
 src/gallium/drivers/i915/i915_fpc_translate.c | 4 ++--
 src/intel/decoder/intel_batch_decoder.c       | 2 +-
 src/intel/decoder/intel_decoder.c             | 2 +-
 src/mesa/main/shaderapi.c                     | 2 +-
 src/util/u_queue.c                            | 2 +-
 8 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_physical_device.c b/src/amd/vulkan/radv_physical_device.c
index ad7cd9a5a27a8..104e866075fdc 100644
--- a/src/amd/vulkan/radv_physical_device.c
+++ b/src/amd/vulkan/radv_physical_device.c
@@ -2315,7 +2315,7 @@ radv_physical_device_try_create(struct radv_instance *instance, drmDevicePtr drm
 
       pdev->gfx12_hiz_wa = RADV_GFX12_HIZ_WA_FULL; /* Default */
 
-      if (strlen(gfx12_hiz_wa_str) > 0) {
+      if (gfx12_hiz_wa_str[0] != '\0') { // optimized variant "strlen(gfx12_hiz_wa_str) > 0"
          if (!strcmp(gfx12_hiz_wa_str, "disabled")) {
             pdev->gfx12_hiz_wa = RADV_GFX12_HIZ_WA_DISABLED;
          } else if (!strcmp(gfx12_hiz_wa_str, "partial")) {
diff --git a/src/compiler/glsl/standalone.cpp b/src/compiler/glsl/standalone.cpp
index c9b31cc170821..abf959bb5d678 100644
--- a/src/compiler/glsl/standalone.cpp
+++ b/src/compiler/glsl/standalone.cpp
@@ -409,7 +409,7 @@ standalone_compile_shader(const struct standalone_options *_options,
 
       compile_shader(ctx, shader);
 
-      if (strlen(shader->InfoLog) > 0) {
+      if (shader->InfoLog[0] != '\0') { // optimized variant "strlen(shader->InfoLog) > 0"
          if (!options->just_log)
             printf("Info log for %s:\n", files[i]);
 
@@ -433,7 +433,7 @@ standalone_compile_shader(const struct standalone_options *_options,
 
       status = (whole_program->data->LinkStatus) ? EXIT_SUCCESS : EXIT_FAILURE;
 
-      if (strlen(whole_program->data->InfoLog) > 0) {
+      if (whole_program->data->InfoLog[0] != '\0') {  // optimized variant "strlen(whole_program->data->InfoLog) > 0"
          printf("\n");
          if (!options->just_log)
             printf("Info log for linking:\n");
diff --git a/src/compiler/nir/nir_print.c b/src/compiler/nir/nir_print.c
index d58392bdceb4e..fa80be987c024 100644
--- a/src/compiler/nir/nir_print.c
+++ b/src/compiler/nir/nir_print.c
@@ -519,7 +519,7 @@ get_name(const void *ctx, const char *identifier, const char *default_name,
       return entry->data;
 
    char *name;
-   if (identifier == NULL || strlen(identifier) == 0) {
+   if (identifier == NULL || identifier[0] == '\0') { // optimized variant "strlen(identifier) == 0"
       name = ralloc_asprintf(state->syms, "%s#%u", default_name, state->index++);
    } else {
       struct set_entry *set_entry = _mesa_set_search(state->syms, identifier);
diff --git a/src/gallium/drivers/i915/i915_fpc_translate.c b/src/gallium/drivers/i915/i915_fpc_translate.c
index b6cfb2a3dfb74..08ddb9fe5c9ed 100644
--- a/src/gallium/drivers/i915/i915_fpc_translate.c
+++ b/src/gallium/drivers/i915/i915_fpc_translate.c
@@ -1013,7 +1013,7 @@ i915_fini_compile(struct i915_context *i915, struct i915_fp_compile *p)
    if (ifs->info.num_instructions == 1)
       i915_program_error(p, "Empty fragment shader");
 
-   if (strlen(p->error) != 0) {
+   if (p->error[0] != '\0') { // optimized variant "strlen(p->error) != 0"
       i915_use_passthrough_shader(ifs);
    } else {
       /* patch in the program length */
@@ -1040,7 +1040,7 @@ i915_fini_compile(struct i915_context *i915, struct i915_fp_compile *p)
       }
    }
 
-   if (strlen(p->error) != 0)
+   if (p->error[0] != '\0') // optimized variant "strlen(p->error) != 0"
       ifs->error = p->error;
    else
       ralloc_free(p->error);
diff --git a/src/intel/decoder/intel_batch_decoder.c b/src/intel/decoder/intel_batch_decoder.c
index 76ca0b987ad81..74eda6bff48e0 100644
--- a/src/intel/decoder/intel_batch_decoder.c
+++ b/src/intel/decoder/intel_batch_decoder.c
@@ -81,7 +81,7 @@ intel_batch_decode_ctx_init(struct intel_batch_decode_ctx *ctx,
          _mesa_hash_table_create(NULL, _mesa_hash_string, _mesa_key_string_equal);
       do {
          const char *term = filters;
-         if (strlen(term) == 0)
+         if (term[0] == '\0') // optimized variant "strlen(term) == 0"
             break;
 
          filters = strchr(term, ',');
diff --git a/src/intel/decoder/intel_decoder.c b/src/intel/decoder/intel_decoder.c
index 523c8fa6d6f71..1e208ac5b8063 100644
--- a/src/intel/decoder/intel_decoder.c
+++ b/src/intel/decoder/intel_decoder.c
@@ -1343,7 +1343,7 @@ iter_decode_field(struct intel_field_iterator *iter)
    }
    }
 
-   if (strlen(iter->group->name) == 0) {
+   if (iter->group->name[0] == '\0') { // optimized variant "strlen(iter->group->name) == 0"
       int length = strlen(iter->name);
       assert(iter->level >= 0);
 
diff --git a/src/mesa/main/shaderapi.c b/src/mesa/main/shaderapi.c
index 6c13c2060cd55..85c563094920d 100644
--- a/src/mesa/main/shaderapi.c
+++ b/src/mesa/main/shaderapi.c
@@ -3367,7 +3367,7 @@ validate_and_tokenise_sh_incl(struct gl_context *ctx,
    list_inithead(&list->list);
 
    while (path_str != NULL) {
-      if (strlen(path_str) == 0) {
+      if (path_str[0] == '\0') { // optimized variant "strlen(path_str) == 0"
          if (error_check) {
             _mesa_error(ctx, GL_INVALID_VALUE,
                         "glNamedStringARB(invalid name %s)", full_path);
diff --git a/src/util/u_queue.c b/src/util/u_queue.c
index 1ccf4af1ad82b..d04116ad346d8 100644
--- a/src/util/u_queue.c
+++ b/src/util/u_queue.c
@@ -258,7 +258,7 @@ util_queue_thread_func(void *input)
    }
 #endif
 
-   if (strlen(queue->name) > 0) {
+   if (queue->name[0] != '\0') { // optimized variant "strlen(queue->name) > 0"
       char name[16];
       snprintf(name, sizeof(name), "%s%i", queue->name, thread_index);
       u_thread_setname(name);
-- 
GitLab


From 268d391347b2711a3c036b6225868f9cba6fa595 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 00:29:39 +0300
Subject: [PATCH 26/31] amd/gallium: micro-op replace post-inc to pre-increment

---
 src/amd/compiler/aco_dead_code_analysis.cpp    | 4 ++--
 src/amd/compiler/aco_insert_waitcnt.cpp        | 2 +-
 src/amd/compiler/aco_reduce_assign.cpp         | 4 ++--
 src/amd/compiler/aco_register_allocation.cpp   | 4 ++--
 src/amd/compiler/aco_util.h                    | 4 ++--
 src/gallium/drivers/r600/sfn/sfn_instr.cpp     | 2 +-
 src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp | 2 +-
 7 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_dead_code_analysis.cpp b/src/amd/compiler/aco_dead_code_analysis.cpp
index 2fdddace4fadb..2da1654aab60d 100644
--- a/src/amd/compiler/aco_dead_code_analysis.cpp
+++ b/src/amd/compiler/aco_dead_code_analysis.cpp
@@ -35,7 +35,7 @@ process_loop_header_phis(std::vector<uint16_t>& uses, Block& block)
 void
 process_block(std::vector<uint16_t>& uses, Block& block)
 {
-   for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); it++) {
+   for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); ++it) {
       aco_ptr<Instruction>& instr = *it;
       if ((block.kind & block_kind_loop_header) && is_phi(instr))
          break;
@@ -61,7 +61,7 @@ dead_code_analysis(Program* program)
          process_loop_header_phis(uses, block);
    }
 
-   for (auto it = program->blocks.rbegin(); it != program->blocks.rend(); it++)
+   for (auto it = program->blocks.rbegin(); it != program->blocks.rend(); ++it)
       process_block(uses, *it);
 
    return uses;
diff --git a/src/amd/compiler/aco_insert_waitcnt.cpp b/src/amd/compiler/aco_insert_waitcnt.cpp
index 39a342b9b4618..9ca8043b3e726 100644
--- a/src/amd/compiler/aco_insert_waitcnt.cpp
+++ b/src/amd/compiler/aco_insert_waitcnt.cpp
@@ -627,7 +627,7 @@ kill(wait_imm& imm, depctr_wait& depctr, Instruction* instr, wait_ctx& ctx,
          if (!it->second.counters)
             it = ctx.gpr_map.erase(it);
          else
-            it++;
+            ++it;
       }
    }
 
diff --git a/src/amd/compiler/aco_reduce_assign.cpp b/src/amd/compiler/aco_reduce_assign.cpp
index 11c0d2022e432..646cd0915ba1a 100644
--- a/src/amd/compiler/aco_reduce_assign.cpp
+++ b/src/amd/compiler/aco_reduce_assign.cpp
@@ -96,7 +96,7 @@ setup_reduce_temp(Program* program)
             if (last_top_level_block_idx == block.index) {
                /* insert right before the current instruction */
                it = block.instructions.insert(it, std::move(create));
-               it++;
+               ++it;
                /* inserted_at is intentionally not updated here, so later blocks
                 * would insert at the end instead of using this one. */
             } else {
@@ -144,7 +144,7 @@ setup_reduce_temp(Program* program)
             create->definitions[0] = Definition(vtmp);
             if (last_top_level_block_idx == block.index) {
                it = block.instructions.insert(it, std::move(create));
-               it++;
+               ++it;
             } else {
                assert(last_top_level_block_idx < block.index);
                std::vector<aco_ptr<Instruction>>& instructions =
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 3396d5359b562..3e6e7ef3c9569 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -3043,7 +3043,7 @@ get_affinities(ra_ctx& ctx)
    aco::unordered_map<uint32_t, uint32_t> temp_to_phi_resources(ctx.memory);
 
    for (auto block_rit = ctx.program->blocks.rbegin(); block_rit != ctx.program->blocks.rend();
-        block_rit++) {
+        ++block_rit) {
       Block& block = *block_rit;
 
       std::vector<aco_ptr<Instruction>>::reverse_iterator rit;
@@ -3195,7 +3195,7 @@ get_affinities(ra_ctx& ctx)
          /* find loop header */
          auto header_rit = block_rit;
          while ((header_rit + 1)->loop_nest_depth > block.loop_nest_depth)
-            header_rit++;
+            ++header_rit;
 
          for (aco_ptr<Instruction>& phi : header_rit->instructions) {
             if (!is_phi(phi))
diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 910feb0ca9c75..bff5ee16cde3b 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -536,10 +536,10 @@ struct IDSet {
          if (block.second == block_t{0})
             continue;
          while (it != words.end() && it->second == block_t{0})
-            it++;
+            ++it;
          if (it == words.end() || block != *it)
             return false;
-         it++;
+         ++it;
       }
 
       return true;
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr.cpp b/src/gallium/drivers/r600/sfn/sfn_instr.cpp
index 1b8da634676c1..e46b2cc0a5649 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr.cpp
@@ -93,7 +93,7 @@ sel_and_szw_from_string(const std::string& str, RegisterVec4::Swizzle& swz, bool
    }
 
    assert(*istr == '.');
-   istr++;
+   ++istr;
 
    int i = 0;
    while (istr != str.end()) {
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
index fade2fb15233a..a01cd8ef7a8f8 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
@@ -1122,7 +1122,7 @@ AluInstr::from_string(istream& is, ValueFactory& value_factory, AluGroup *group,
 
    if (*t == "LDS") {
       is_lds = true;
-      t++;
+      ++t;
    }
 
    string opstr = *t++;
-- 
GitLab


From 5ed472808e05ee860c77a835c6b3492085a04636 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:25:42 +0300
Subject: [PATCH 27/31] vulkan: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

---
 src/vulkan/runtime/vk_graphics_state.h | 30 +++++++++++++-------------
 src/vulkan/runtime/vk_pipeline.c       |  4 ++--
 src/vulkan/runtime/vk_pipeline.h       |  2 +-
 src/vulkan/runtime/vk_shader.h         |  2 +-
 src/vulkan/runtime/vk_video.h          | 12 +++++------
 src/vulkan/util/vk_util.h              | 12 +++++------
 src/vulkan/wsi/wsi_common.c            |  2 +-
 src/vulkan/wsi/wsi_common_display.c    |  2 +-
 src/vulkan/wsi/wsi_common_wayland.c    |  8 +++----
 9 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/src/vulkan/runtime/vk_graphics_state.h b/src/vulkan/runtime/vk_graphics_state.h
index 2e6d62c41e713..71639f165037a 100644
--- a/src/vulkan/runtime/vk_graphics_state.h
+++ b/src/vulkan/runtime/vk_graphics_state.h
@@ -337,6 +337,12 @@ struct vk_rasterization_state {
        */
       bool enable;
 
+      /** VkDepthBiasRepresentationInfoEXT::depthBiasExact
+       *
+       * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
+       */
+      bool exact;
+
       /** VkPipelineRasterizationStateCreateInfo::depthBiasConstantFactor
        *
        * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
@@ -360,12 +366,6 @@ struct vk_rasterization_state {
        * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
        */
       VkDepthBiasRepresentationEXT representation;
-
-      /** VkDepthBiasRepresentationInfoEXT::depthBiasExact
-       *
-       * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
-       */
-      bool exact;
    } depth_bias;
 
    struct {
@@ -385,18 +385,18 @@ struct vk_rasterization_state {
       VkLineRasterizationModeKHR mode;
 
       struct {
-         /** VkPipelineRasterizationLineStateCreateInfoKHR::stippledLineEnable
-          *
-          * MESA_VK_DYNAMIC_RS_LINE_STIPPLE_ENABLE
-          */
-         bool enable;
-
          /** VkPipelineRasterizationLineStateCreateInfoKHR::lineStippleFactor
           *
           * MESA_VK_DYNAMIC_RS_LINE_STIPPLE
           */
          uint32_t factor;
 
+         /** VkPipelineRasterizationLineStateCreateInfoKHR::stippledLineEnable
+          *
+          * MESA_VK_DYNAMIC_RS_LINE_STIPPLE_ENABLE
+          */
+         bool enable;
+
          /** VkPipelineRasterizationLineStateCreateInfoKHR::lineStipplePattern
           *
           * MESA_VK_DYNAMIC_RS_LINE_STIPPLE
@@ -780,6 +780,9 @@ struct vk_render_pass_state {
    /** VkPipelineRenderingCreateInfo::colorAttachmentCount */
    uint8_t color_attachment_count;
 
+   /** VkAttachmentSampleCountInfoAMD::depthStencilAttachmentSamples */
+   uint8_t depth_stencil_attachment_samples;
+
    /** VkPipelineRenderingCreateInfo::pColorAttachmentFormats */
    VkFormat color_attachment_formats[MESA_VK_MAX_COLOR_ATTACHMENTS];
 
@@ -791,9 +794,6 @@ struct vk_render_pass_state {
 
    /** VkAttachmentSampleCountInfoAMD::pColorAttachmentSamples */
    uint8_t color_attachment_samples[MESA_VK_MAX_COLOR_ATTACHMENTS];
-
-   /** VkAttachmentSampleCountInfoAMD::depthStencilAttachmentSamples */
-   uint8_t depth_stencil_attachment_samples;
 };
 
 static inline bool
diff --git a/src/vulkan/runtime/vk_pipeline.c b/src/vulkan/runtime/vk_pipeline.c
index 4e5baf769a2cc..d6e4452995529 100644
--- a/src/vulkan/runtime/vk_pipeline.c
+++ b/src/vulkan/runtime/vk_pipeline.c
@@ -2342,15 +2342,15 @@ struct vk_rt_stage {
 struct vk_rt_shader_group {
    VkRayTracingShaderGroupTypeKHR type;
 
-   struct vk_rt_stage stages[3];
    uint32_t stage_count;
+   struct vk_rt_stage stages[3];
 };
 
 struct vk_rt_pipeline {
    struct vk_pipeline base;
 
-   uint32_t group_count;
    struct vk_rt_shader_group *groups;
+   uint32_t group_count;
 
    uint32_t stage_count;
    struct vk_rt_stage *stages;
diff --git a/src/vulkan/runtime/vk_pipeline.h b/src/vulkan/runtime/vk_pipeline.h
index ef917bdf4428c..73ed884a79770 100644
--- a/src/vulkan/runtime/vk_pipeline.h
+++ b/src/vulkan/runtime/vk_pipeline.h
@@ -154,8 +154,8 @@ struct vk_pipeline {
    const struct vk_pipeline_ops *ops;
 
    VkPipelineBindPoint bind_point;
-   VkPipelineCreateFlags2KHR flags;
    VkShaderStageFlags stages;
+   VkPipelineCreateFlags2KHR flags;
 };
 
 VK_DEFINE_NONDISP_HANDLE_CASTS(vk_pipeline, base, VkPipeline,
diff --git a/src/vulkan/runtime/vk_shader.h b/src/vulkan/runtime/vk_shader.h
index a2caea1c66773..1fc0146d538d3 100644
--- a/src/vulkan/runtime/vk_shader.h
+++ b/src/vulkan/runtime/vk_shader.h
@@ -89,8 +89,8 @@ struct vk_shader_compile_info {
 
    const struct vk_pipeline_robustness_state *robustness;
 
-   uint32_t set_layout_count;
    struct vk_descriptor_set_layout * const *set_layouts;
+   uint32_t set_layout_count;
 
    uint32_t push_constant_range_count;
    const VkPushConstantRange *push_constant_ranges;
diff --git a/src/vulkan/runtime/vk_video.h b/src/vulkan/runtime/vk_video.h
index 8fb270351d994..ea6ec40252e73 100644
--- a/src/vulkan/runtime/vk_video.h
+++ b/src/vulkan/runtime/vk_video.h
@@ -126,8 +126,8 @@ struct vk_video_session_parameters {
          uint32_t max_h264_pps_count;
 
          uint32_t h264_sps_count;
-         struct vk_video_h264_sps *h264_sps;
          uint32_t h264_pps_count;
+         struct vk_video_h264_sps *h264_sps;
          struct vk_video_h264_pps *h264_pps;
       } h264_dec;
 
@@ -137,10 +137,10 @@ struct vk_video_session_parameters {
          uint32_t max_h265_pps_count;
 
          uint32_t h265_vps_count;
-         struct vk_video_h265_vps *h265_vps;
          uint32_t h265_sps_count;
-         struct vk_video_h265_sps *h265_sps;
          uint32_t h265_pps_count;
+         struct vk_video_h265_vps *h265_vps;
+         struct vk_video_h265_sps *h265_sps;
          struct vk_video_h265_pps *h265_pps;
       } h265_dec;
 
@@ -153,8 +153,8 @@ struct vk_video_session_parameters {
          uint32_t max_h264_pps_count;
 
          uint32_t h264_sps_count;
-         struct vk_video_h264_sps *h264_sps;
          uint32_t h264_pps_count;
+         struct vk_video_h264_sps *h264_sps;
          struct vk_video_h264_pps *h264_pps;
          StdVideoH264ProfileIdc profile_idc;
       } h264_enc;
@@ -165,10 +165,10 @@ struct vk_video_session_parameters {
          uint32_t max_h265_pps_count;
 
          uint32_t h265_vps_count;
-         struct vk_video_h265_vps *h265_vps;
          uint32_t h265_sps_count;
-         struct vk_video_h265_sps *h265_sps;
          uint32_t h265_pps_count;
+         struct vk_video_h265_vps *h265_vps;
+         struct vk_video_h265_sps *h265_sps;
          struct vk_video_h265_pps *h265_pps;
       } h265_enc;
 
diff --git a/src/vulkan/util/vk_util.h b/src/vulkan/util/vk_util.h
index aea4c569a1889..835b4a334baf2 100644
--- a/src/vulkan/util/vk_util.h
+++ b/src/vulkan/util/vk_util.h
@@ -152,18 +152,18 @@ struct __vk_outarray {
     */
    uint32_t cap;
 
-   /**
-    * Count of elements successfully written to the array. Every write is
-    * considered successful if data is null.
-    */
-   uint32_t *filled_len;
-
    /**
     * Count of elements that would have been written to the array if its
     * capacity were sufficient. Vulkan functions often return VK_INCOMPLETE
     * when `*filled_len < wanted_len`.
     */
    uint32_t wanted_len;
+
+   /**
+    * Count of elements successfully written to the array. Every write is
+    * considered successful if data is null.
+    */
+   uint32_t *filled_len;
 };
 
 static inline void
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index d88323a91ed73..f3b81062d93c0 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -1380,8 +1380,8 @@ wsi_queue_submit2_unordered(const struct wsi_device *wsi,
 struct wsi_image_signal_info {
    uint64_t present_id;
    uint32_t semaphore_count;
-   VkSemaphoreSubmitInfo semaphore_infos[2];
    uint32_t fence_count;
+   VkSemaphoreSubmitInfo semaphore_infos[2];
    VkFence fences[2];
 };
 
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 48084ac4cebb4..bb79a4450383e 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -444,9 +444,9 @@ struct wsi_display_fence {
    struct wsi_display           *wsi;
    bool                         event_received;
    bool                         destroyed;
+   bool                         device_event; /* fence is used for device events */
    uint32_t                     syncobj; /* syncobj to signal on event */
    uint64_t                     sequence;
-   bool                         device_event; /* fence is used for device events */
 };
 
 struct wsi_display_sync {
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 351b71481107a..8b7dee076b3b0 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -239,18 +239,18 @@ struct wsi_wl_swapchain {
       struct wl_surface *surface;
       bool dispatch_in_progress;
 
+      bool valid_refresh_nsec;
+      bool frame_fallback;
+      unsigned int refresh_nsec;
       uint64_t display_time_error;
       uint64_t display_time_correction;
       uint64_t last_target_time;
       uint64_t displayed_time;
-      bool valid_refresh_nsec;
-      unsigned int refresh_nsec;
-      bool frame_fallback;
    } present_ids;
 
    struct {
-      VkColorSpaceKHR colorspace;
       VkHdrMetadataEXT hdr_metadata;
+      VkColorSpaceKHR colorspace;
       bool has_hdr_metadata;
    } color;
 
-- 
GitLab


From c67d536367f032399e67fe9c1a331f702b237ea6 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:26:17 +0300
Subject: [PATCH 28/31] intel: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

---
 src/intel/blorp/blorp_priv.h                  |  2 +-
 src/intel/common/intel_aux_map.c              |  2 +-
 src/intel/common/intel_measure.h              |  3 ++-
 src/intel/common/mi_builder.h                 |  4 +--
 src/intel/compiler/brw_cfg.h                  |  2 +-
 src/intel/compiler/brw_compiler.h             | 26 +++++++++----------
 .../compiler/brw_nir_lower_cs_intrinsics.c    |  2 +-
 src/intel/compiler/brw_rt.h                   |  6 ++---
 src/intel/compiler/brw_shader.h               |  2 +-
 src/intel/compiler/elk/elk_cfg.h              |  2 +-
 src/intel/compiler/elk/elk_compiler.h         | 12 ++++-----
 .../compiler/elk/elk_fs_combine_constants.cpp |  2 +-
 src/intel/compiler/intel_shader_enums.h       |  6 ++---
 src/intel/decoder/intel_decoder.h             |  4 +--
 src/intel/perf/intel_perf.h                   | 12 ++++-----
 src/intel/vulkan/anv_private.h                | 19 +++++++-------
 src/intel/vulkan/anv_shader.c                 |  2 +-
 src/intel/vulkan/genX_cmd_compute.c           |  8 +++---
 src/intel/vulkan_hasvk/anv_private.h          | 16 ++++++------
 19 files changed, 67 insertions(+), 65 deletions(-)

diff --git a/src/intel/blorp/blorp_priv.h b/src/intel/blorp/blorp_priv.h
index 3c74cfa6bca21..9fcb6a215dcbe 100644
--- a/src/intel/blorp/blorp_priv.h
+++ b/src/intel/blorp/blorp_priv.h
@@ -436,8 +436,8 @@ struct blorp_program {
    const void *kernel;
    uint32_t    kernel_size;
 
-   const void *prog_data;
    uint32_t    prog_data_size;
+   const void *prog_data;
 };
 
 static inline struct blorp_program
diff --git a/src/intel/common/intel_aux_map.c b/src/intel/common/intel_aux_map.c
index 38ae7702a069e..509274a2c2209 100644
--- a/src/intel/common/intel_aux_map.c
+++ b/src/intel/common/intel_aux_map.c
@@ -203,8 +203,8 @@ struct intel_aux_map_context {
    pthread_mutex_t mutex;
    struct intel_aux_level *l3_level;
    struct intel_mapped_pinned_buffer_alloc *buffer_alloc;
-   uint32_t num_buffers;
    struct list_head buffers;
+   uint32_t num_buffers;
    uint32_t tail_offset, tail_remaining;
    uint32_t state_num;
    const struct aux_format_info *format;
diff --git a/src/intel/common/intel_measure.h b/src/intel/common/intel_measure.h
index 5c2a2916f9b34..d9ae97d67fd65 100644
--- a/src/intel/common/intel_measure.h
+++ b/src/intel/common/intel_measure.h
@@ -115,8 +115,9 @@ struct intel_measure_batch;
 
 struct intel_measure_snapshot {
    enum intel_measure_snapshot_type type;
-   unsigned count, event_count;
+   unsigned count;
    const char* event_name;
+   unsigned event_count;
    uint32_t renderpass;
    uint32_t vs, tcs, tes, gs, fs, cs, ms, ts;
    /* for vulkan secondary command buffers */
diff --git a/src/intel/common/mi_builder.h b/src/intel/common/mi_builder.h
index b7c6fd81f484b..5ddecac02f9c4 100644
--- a/src/intel/common/mi_builder.h
+++ b/src/intel/common/mi_builder.h
@@ -109,14 +109,14 @@ enum mi_value_type {
 };
 
 struct mi_value {
-   enum mi_value_type type;
-
    union {
       uint64_t imm;
       __gen_address_type addr;
       uint32_t reg;
    };
 
+   enum mi_value_type type;
+
 #if GFX_VERx10 >= 75
    bool invert;
 #endif
-- 
GitLab


From d97147bead25ac9b96727dea86d8d2fde10bbf98 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:26:49 +0300
Subject: [PATCH 29/31] gallium: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

---
 src/gallium/auxiliary/cso_cache/cso_cache.h           | 2 +-
 src/gallium/auxiliary/draw/draw_context.h             | 2 +-
 src/gallium/auxiliary/draw/draw_mesh_prim.c           | 2 +-
 src/gallium/auxiliary/draw/draw_pt_so_emit.c          | 2 +-
 src/gallium/auxiliary/nir/nir_draw_helpers.c          | 2 +-
 src/gallium/auxiliary/translate/translate_generic.c   | 8 +++++---
 src/gallium/auxiliary/util/u_suballoc.h               | 2 +-
 src/gallium/drivers/crocus/crocus_context.h           | 2 +-
 src/gallium/drivers/crocus/crocus_query.c             | 4 ++--
 src/gallium/drivers/crocus/crocus_resource.h          | 4 ++--
 src/gallium/drivers/crocus/crocus_state.c             | 2 +-
 src/gallium/drivers/i915/i915_debug_private.h         | 2 +-
 src/gallium/drivers/iris/iris_bufmgr.h                | 6 +++---
 src/gallium/drivers/iris/iris_context.h               | 8 ++++----
 src/gallium/drivers/r600/evergreen_state.c            | 2 +-
 src/gallium/drivers/softpipe/sp_quad_depth_test.c     | 2 +-
 src/gallium/drivers/softpipe/sp_tex_sample.h          | 5 +++--
 src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c | 3 +--
 src/gallium/drivers/zink/zink_compiler.c              | 2 +-
 src/gallium/drivers/zink/zink_types.h                 | 4 ++--
 src/gallium/winsys/i915/drm/i915_drm_winsys.h         | 4 ++--
 src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.h   | 2 +-
 22 files changed, 37 insertions(+), 35 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 35408e147b092..26939702da4ac 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -132,8 +132,8 @@ struct cso_rasterizer {
 
 struct cso_sampler {
    struct pipe_sampler_state state;
-   void *data;
    unsigned hash_key;
+   void *data;
 };
 
 struct cso_velems_state {
diff --git a/src/gallium/auxiliary/draw/draw_context.h b/src/gallium/auxiliary/draw/draw_context.h
index 95b4c38d5751c..ba882c87f8dc5 100644
--- a/src/gallium/auxiliary/draw/draw_context.h
+++ b/src/gallium/auxiliary/draw/draw_context.h
@@ -87,8 +87,8 @@ struct draw_prim_info {
 
    enum mesa_prim prim;
    unsigned flags;
-   unsigned *primitive_lengths;
    unsigned primitive_count;
+   unsigned *primitive_lengths;
 };
 
 struct draw_context *draw_create(struct pipe_context *pipe);
diff --git a/src/gallium/auxiliary/draw/draw_mesh_prim.c b/src/gallium/auxiliary/draw/draw_mesh_prim.c
index ac91c27ae4218..2ea45835b070b 100644
--- a/src/gallium/auxiliary/draw/draw_mesh_prim.c
+++ b/src/gallium/auxiliary/draw/draw_mesh_prim.c
@@ -48,8 +48,8 @@ struct draw_mesh_prim
    const struct draw_prim_info *input_prims;
    const struct draw_vertex_info *input_verts;
 
-   unsigned num_prims;
    const char *per_prim;
+   unsigned num_prims;
    uint32_t num_per_prim;
    uint32_t added_prim_size;
    int cull_prim_idx;
diff --git a/src/gallium/auxiliary/draw/draw_pt_so_emit.c b/src/gallium/auxiliary/draw/draw_pt_so_emit.c
index 2e181f2210f8a..e11064a65a858 100644
--- a/src/gallium/auxiliary/draw/draw_pt_so_emit.c
+++ b/src/gallium/auxiliary/draw/draw_pt_so_emit.c
@@ -44,9 +44,9 @@
 struct pt_so_emit {
    struct draw_context *draw;
 
-   unsigned input_vertex_stride;
    const float (*inputs)[4];
    const float *pre_clip_pos;
+   unsigned input_vertex_stride;
    bool has_so;
    bool use_pre_clip_pos;
    int pos_idx;
diff --git a/src/gallium/auxiliary/nir/nir_draw_helpers.c b/src/gallium/auxiliary/nir/nir_draw_helpers.c
index 677b7c35be855..4038890fb8dca 100644
--- a/src/gallium/auxiliary/nir/nir_draw_helpers.c
+++ b/src/gallium/auxiliary/nir/nir_draw_helpers.c
@@ -41,9 +41,9 @@
 typedef struct {
    nir_builder b;
    nir_shader *shader;
-   bool fs_pos_is_sysval;
    nir_variable *stip_tex;
    nir_def *fragcoord;
+   bool fs_pos_is_sysval;
    nir_alu_type bool_type;
 } lower_pstipple;
 
diff --git a/src/gallium/auxiliary/translate/translate_generic.c b/src/gallium/auxiliary/translate/translate_generic.c
index 7caac5a0c902f..7e98f5bf4cbdf 100644
--- a/src/gallium/auxiliary/translate/translate_generic.c
+++ b/src/gallium/auxiliary/translate/translate_generic.c
@@ -48,21 +48,23 @@ struct translate_generic {
    struct translate translate;
 
    struct {
-      enum translate_element_type type;
-
       void (*fetch)(void *restrict dst, const uint8_t *restrict src,
                     unsigned width);
+
+      enum translate_element_type type;
+
       unsigned buffer;
       unsigned input_offset;
       unsigned instance_divisor;
 
       emit_func emit;
-      unsigned output_offset;
 
       const uint8_t *input_ptr;
       unsigned input_stride;
       unsigned max_index;
 
+      unsigned output_offset;
+
       /* this value is set to -1 if this is a normal element with
        * output_format != input_format: in this case, u_format is used
        * to do a full conversion
diff --git a/src/gallium/auxiliary/util/u_suballoc.h b/src/gallium/auxiliary/util/u_suballoc.h
index f2f15e296573c..1af0788ca138c 100644
--- a/src/gallium/auxiliary/util/u_suballoc.h
+++ b/src/gallium/auxiliary/util/u_suballoc.h
@@ -46,8 +46,8 @@ struct u_suballocator {
    unsigned flags;         /* bitmask of PIPE_RESOURCE_FLAG_x */
    bool zero_buffer_memory; /* If the buffer contents should be zeroed. */
 
-   struct pipe_resource *buffer;   /* The buffer we suballocate from. */
    unsigned offset; /* Aligned offset pointing at the first unused byte. */
+   struct pipe_resource *buffer;   /* The buffer we suballocate from. */
 };
 
 void
diff --git a/src/gallium/drivers/crocus/crocus_context.h b/src/gallium/drivers/crocus/crocus_context.h
index ee48acecd193c..7be9449aee6c1 100644
--- a/src/gallium/drivers/crocus/crocus_context.h
+++ b/src/gallium/drivers/crocus/crocus_context.h
@@ -739,8 +739,8 @@ struct crocus_context {
       unsigned vs_size;
       unsigned total_size;
 
-      struct crocus_resource *curbe_res;
       unsigned curbe_offset;
+      struct crocus_resource *curbe_res;
    } curbe;
 
    /**
diff --git a/src/gallium/drivers/crocus/crocus_query.c b/src/gallium/drivers/crocus/crocus_query.c
index ee7f4d3ea458b..568b867ba76fb 100644
--- a/src/gallium/drivers/crocus/crocus_query.c
+++ b/src/gallium/drivers/crocus/crocus_query.c
@@ -83,14 +83,14 @@ struct crocus_query {
 
    bool stalled;
 
+   int batch_idx;
+
    uint64_t result;
 
    struct crocus_state_ref query_state_ref;
    struct crocus_query_snapshots *map;
    struct crocus_syncobj *syncobj;
 
-   int batch_idx;
-
    struct crocus_monitor_object *monitor;
 
    /* Fence for PIPE_QUERY_GPU_FINISHED. */
diff --git a/src/gallium/drivers/crocus/crocus_resource.h b/src/gallium/drivers/crocus/crocus_resource.h
index 75a596d08525e..f10c3a0c0dd9d 100644
--- a/src/gallium/drivers/crocus/crocus_resource.h
+++ b/src/gallium/drivers/crocus/crocus_resource.h
@@ -280,10 +280,10 @@ struct crocus_transfer {
  * Memory Object
  */
 struct crocus_memory_object {
-   struct pipe_memory_object b;
    struct crocus_bo *bo;
-   uint64_t format;
+   struct pipe_memory_object b;
    unsigned stride;
+   uint64_t format;
 };
 
 /**
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 17e40455aced4..00528afe1303f 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -3970,8 +3970,8 @@ struct crocus_stream_output_target {
    /** Has 3DSTATE_SO_BUFFER actually been emitted, zeroing the offsets? */
    bool zeroed;
 
-   struct crocus_resource *offset_res;
    uint32_t offset_offset;
+   struct crocus_resource *offset_res;
 
 #if GFX_VER == 6
    void *prim_map;
diff --git a/src/gallium/drivers/i915/i915_debug_private.h b/src/gallium/drivers/i915/i915_debug_private.h
index a377dc26e79a5..f2029faeca356 100644
--- a/src/gallium/drivers/i915/i915_debug_private.h
+++ b/src/gallium/drivers/i915/i915_debug_private.h
@@ -33,9 +33,9 @@
 
 struct debug_stream {
    unsigned offset; /* current gtt offset */
+   unsigned print_addresses;
    char *ptr;       /* pointer to gtt offset zero */
    char *end;       /* pointer to gtt offset zero */
-   unsigned print_addresses;
 };
 
 void i915_disassemble_program(const unsigned *program, unsigned sz);
diff --git a/src/gallium/drivers/iris/iris_bufmgr.h b/src/gallium/drivers/iris/iris_bufmgr.h
index 1c02028046856..52dd1c654e27e 100644
--- a/src/gallium/drivers/iris/iris_bufmgr.h
+++ b/src/gallium/drivers/iris/iris_bufmgr.h
@@ -669,11 +669,11 @@ struct iris_border_color_pool {
    void *map;
    unsigned insert_point;
 
-   /** Map from border colors to offsets in the buffer. */
-   struct hash_table *ht;
-
    /** Protects insert_point and the hash table. */
    simple_mtx_t lock;
+
+   /** Map from border colors to offsets in the buffer. */
+   struct hash_table *ht;
 };
 
 struct iris_border_color_pool *iris_bufmgr_get_border_color_pool(
diff --git a/src/gallium/drivers/iris/iris_context.h b/src/gallium/drivers/iris/iris_context.h
index 808f2057480ca..6354faccfcd94 100644
--- a/src/gallium/drivers/iris/iris_context.h
+++ b/src/gallium/drivers/iris/iris_context.h
@@ -378,8 +378,8 @@ struct iris_cs_data {
    unsigned prog_offset[3];
    unsigned prog_mask;
 
-   uint8_t generate_local_id;
    enum intel_compute_walk_order walk_order;
+   uint8_t generate_local_id;
 
    bool uses_barrier;
    bool uses_sampler;
@@ -627,6 +627,9 @@ enum {
 struct iris_binding_table {
    uint32_t size_bytes;
 
+   /** Whether the first render target is a null fb surface */
+   uint8_t use_null_rt;
+
    /** Number of surfaces in each group, before compacting. */
    uint32_t sizes[IRIS_SURFACE_GROUP_COUNT];
 
@@ -637,9 +640,6 @@ struct iris_binding_table {
    uint64_t used_mask[IRIS_SURFACE_GROUP_COUNT];
 
    uint64_t samplers_used_mask;
-
-   /** Whether the first render target is a null fb surface */
-   uint8_t use_null_rt;
 };
 
 /**
diff --git a/src/gallium/drivers/r600/evergreen_state.c b/src/gallium/drivers/r600/evergreen_state.c
index 5379bbe7ef848..f7acc1217034b 100644
--- a/src/gallium/drivers/r600/evergreen_state.c
+++ b/src/gallium/drivers/r600/evergreen_state.c
@@ -1060,8 +1060,8 @@ struct r600_tex_color_info {
 	unsigned ntype;
 	unsigned fmask;
 	unsigned fmask_slice;
-	uint64_t offset;
 	bool export_16bpc;
+	uint64_t offset;
 };
 
 static void evergreen_set_color_surface_buffer(struct r600_context *rctx,
diff --git a/src/gallium/drivers/softpipe/sp_quad_depth_test.c b/src/gallium/drivers/softpipe/sp_quad_depth_test.c
index e6ba6fcbf1f30..def944612492c 100644
--- a/src/gallium/drivers/softpipe/sp_quad_depth_test.c
+++ b/src/gallium/drivers/softpipe/sp_quad_depth_test.c
@@ -48,10 +48,10 @@ struct depth_data {
    unsigned qzzzz[TGSI_QUAD_SIZE];  /**< Z values from the quad */
    uint8_t stencilVals[TGSI_QUAD_SIZE];
    bool use_shader_stencil_refs;
+   bool clamp;
    uint8_t shader_stencil_refs[TGSI_QUAD_SIZE];
    struct softpipe_cached_tile *tile;
    float minval, maxval;
-   bool clamp;
 };
 
 
diff --git a/src/gallium/drivers/softpipe/sp_tex_sample.h b/src/gallium/drivers/softpipe/sp_tex_sample.h
index 1226dbf0b85ad..fdee9132bf629 100644
--- a/src/gallium/drivers/softpipe/sp_tex_sample.h
+++ b/src/gallium/drivers/softpipe/sp_tex_sample.h
@@ -117,13 +117,14 @@ struct sp_sampler_view
    bool pot2d;
    bool need_cube_convert;
 
+   /* Value to use for PIPE_SWIZZLE_1 (integer vs float) */
+   float oneval;
+
    /* these are different per shader type */
    struct softpipe_tex_tile_cache *cache;
    compute_lambda_func compute_lambda;
    compute_lambda_from_grad_func compute_lambda_from_grad;
    union pipe_color_union border_color;
-   /* Value to use for PIPE_SWIZZLE_1 (integer vs float) */
-   float oneval;
 };
 
 struct sp_filter_funcs {
diff --git a/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c b/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c
index 3713a51f26e34..e307e26743eb6 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c
+++ b/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c
@@ -1270,9 +1270,8 @@ spirv_builder_emit_ext_inst(struct spirv_builder *b, SpvId result_type,
 struct spirv_type {
    SpvOp op;
    uint32_t args[8];
-   size_t num_args;
-
    SpvId type;
+   size_t num_args;
 };
 
 static uint32_t
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index 5db63cecb9386..6994c99522c1d 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -2536,8 +2536,8 @@ struct io_slot_map {
    uint64_t *patch_slot_track;
    uint64_t *slot_track;
    unsigned char *slot_map;
-   unsigned reserved;
    unsigned char *patch_slot_map;
+   unsigned reserved;
    unsigned patch_reserved;
 };
 
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index 2f51a8a53ee9b..1a6c747437ab1 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -938,13 +938,13 @@ struct zink_compute_pipeline_state {
     * Members after this point are not included in pipeline state hash key */
    uint32_t hash;
    uint32_t final_hash;
-   bool dirty;
    uint32_t local_size[3];
    uint32_t variable_shared_mem;
+   bool dirty;
 
+   bool module_changed;
    uint32_t module_hash;
    VkShaderModule module;
-   bool module_changed;
 
    struct zink_shader_key key;
 
diff --git a/src/gallium/winsys/i915/drm/i915_drm_winsys.h b/src/gallium/winsys/i915/drm/i915_drm_winsys.h
index a7b809c34021a..2e8f088178f0d 100644
--- a/src/gallium/winsys/i915/drm/i915_drm_winsys.h
+++ b/src/gallium/winsys/i915/drm/i915_drm_winsys.h
@@ -47,13 +47,13 @@ void i915_drm_winsys_init_fence_functions(struct i915_drm_winsys *idws);
 
 
 struct i915_drm_buffer {
-   unsigned magic;
-
    drm_intel_bo *bo;
 
    void *ptr;
    unsigned map_count;
 
+   unsigned magic;
+
    bool flinked;
    unsigned flink;
 };
diff --git a/src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.h b/src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.h
index 8ad4060ce39b3..9904828ba7918 100644
--- a/src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.h
+++ b/src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.h
@@ -58,8 +58,8 @@ struct virgl_hw_res {
    uint32_t res_handle;
    int num_cs_references;
 
-   void *ptr;
    int size;
+   void *ptr;
 
    uint32_t format;
    uint32_t stride;
-- 
GitLab


From 5e9fb0ca032f0be4637f4a8a16142ba463f58603 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:27:20 +0300
Subject: [PATCH 30/31] compiler/util: align for 64-bit platforms (fix cache
 misses, compiler use more SIMD)

---
 src/compiler/clc/clc.h                     | 20 +++++++-------
 src/compiler/glsl/gl_nir_link_varyings.h   | 10 +++----
 src/compiler/nir/nir.h                     | 31 +++++++++++-----------
 src/compiler/nir/nir_divergence_analysis.c |  2 +-
 src/compiler/nir/nir_from_ssa.c            |  2 +-
 src/compiler/nir/nir_lower_amul.c          |  4 +--
 src/compiler/nir/nir_lower_tex_shadow.c    |  4 +--
 src/compiler/spirv/vtn_private.h           | 16 +++++------
 src/util/register_allocate_internal.h      | 12 ++++-----
 src/util/u_printf.h                        |  2 +-
 10 files changed, 51 insertions(+), 52 deletions(-)

diff --git a/src/compiler/clc/clc.h b/src/compiler/clc/clc.h
index 95ef4dd759bc8..a464b749497d2 100644
--- a/src/compiler/clc/clc.h
+++ b/src/compiler/clc/clc.h
@@ -79,28 +79,28 @@ struct clc_optional_features {
 
 struct clc_compile_args {
    const struct clc_named_value *headers;
-   unsigned num_headers;
    struct clc_named_value source;
    const char * const *args;
    unsigned num_args;
+   unsigned num_headers;
+
+   unsigned address_bits;
 
    /* SPIRV version to target. */
    enum clc_spirv_version spirv_version;
    struct clc_optional_features features;
    bool use_llvm_spirv_target;
 
-   /* Allowed extensions SPIRV extensions the OpenCL->SPIRV translation can
-    * enable. A pointer to a NULL terminated array of strings, allow any
-    * extension if NULL.
-    */
-   const char * const *allowed_spirv_extensions;
-
    /* Indicate that the input file tries to be compatible with C code. This
     * means that for example the bit-field clang extension is enabled.
     */
    bool c_compatible;
 
-   unsigned address_bits;
+   /* Allowed extensions SPIRV extensions the OpenCL->SPIRV translation can
+    * enable. A pointer to a NULL terminated array of strings, allow any
+    * extension if NULL.
+    */
+   const char * const *allowed_spirv_extensions;
 };
 
 struct clc_validator_options {
@@ -199,8 +199,8 @@ struct clc_parsed_spirv {
    const struct clc_kernel_info *kernels;
    unsigned num_kernels;
 
-   const struct clc_parsed_spec_constant *spec_constants;
    unsigned num_spec_constants;
+   const struct clc_parsed_spec_constant *spec_constants;
 };
 
 struct clc_libclc;
@@ -275,8 +275,8 @@ typedef union {
 
 struct clc_spirv_specialization {
    uint32_t id;
-   clc_spirv_const_value value;
    bool defined_on_module;
+   clc_spirv_const_value value;
 };
 
 struct clc_spirv_specialization_consts {
diff --git a/src/compiler/glsl/gl_nir_link_varyings.h b/src/compiler/glsl/gl_nir_link_varyings.h
index 60e9608ef2a72..5abec0fa4ef11 100644
--- a/src/compiler/glsl/gl_nir_link_varyings.h
+++ b/src/compiler/glsl/gl_nir_link_varyings.h
@@ -125,6 +125,11 @@ struct xfb_decl
     */
    bool is_subscripted;
 
+   /**
+    * Whether this is gl_NextBuffer from ARB_transform_feedback3.
+    */
+   bool next_buffer_separator;
+
    /**
     * If is_subscripted is true, the subscript that was specified in orig_name.
     */
@@ -190,11 +195,6 @@ struct xfb_decl
     */
    unsigned skip_components;
 
-   /**
-    * Whether this is gl_NextBuffer from ARB_transform_feedback3.
-    */
-   bool next_buffer_separator;
-
    /**
     * If find_candidate() has been called, pointer to the tfeedback_candidate
     * data structure that was found.  Otherwise NULL.
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index f1cf5e93e42c9..4da23bc595478 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3015,14 +3015,13 @@ nir_alu_src_as_uint(nir_alu_src src)
 }
 
 typedef struct nir_binding {
-   bool success;
-
    nir_variable *var;
+   bool success;
+   bool read_first_invocation;
    unsigned desc_set;
    unsigned binding;
    unsigned num_indices;
    nir_src indices[4];
-   bool read_first_invocation;
 } nir_binding;
 
 nir_binding nir_chase_binding(nir_src rsrc);
@@ -3743,9 +3742,6 @@ typedef struct nir_function {
    const char *name;
    nir_shader *shader;
 
-   unsigned num_params;
-   nir_parameter *params;
-
    /** The implementation of this function.
     *
     * If the function is only declared and not implemented, this is NULL.
@@ -3755,6 +3751,9 @@ typedef struct nir_function {
     */
    nir_function_impl *impl;
 
+   nir_parameter *params;
+   unsigned num_params;
+
    /* Drivers may optionally stash flags here describing the function call.
     * For example, this might encode the ABI used for the call if a driver
     * supports multiple ABIs.
@@ -3771,11 +3770,6 @@ typedef struct nir_function {
    bool should_inline;
    bool dont_inline; /* from SPIR-V */
 
-   /* Static workgroup size, if this is a kernel function in a library of OpenCL
-    * kernels. Normally, the size in the shader info is used instead.
-    */
-   unsigned workgroup_size[3];
-
    /**
     * Is this function a subroutine type declaration
     * e.g. subroutine void type1(float arg1);
@@ -3787,6 +3781,11 @@ typedef struct nir_function {
     */
    bool is_tmp_globals_wrapper;
 
+   /* Static workgroup size, if this is a kernel function in a library of OpenCL
+    * kernels. Normally, the size in the shader info is used instead.
+    */
+   unsigned workgroup_size[3];
+
    /**
     * Is this function associated to a subroutine type
     * e.g. subroutine (type1, type2) function_name { function_body };
@@ -6508,6 +6507,11 @@ typedef struct nir_opt_preamble_options {
    /* True if load_workgroup_size is supported in the preamble. */
    bool load_workgroup_size_allowed;
 
+   /* Total available size per class for load/store_preamble storage, in units
+    * determined by def_size.
+    */
+   unsigned preamble_storage_size[nir_preamble_num_classes];
+
    /* size/align/class for load/store_preamble.
     *
     * Defs with class "general" will always be allocated as general. Other
@@ -6518,11 +6522,6 @@ typedef struct nir_opt_preamble_options {
    void (*def_size)(nir_def *def, unsigned *size, unsigned *align,
                     nir_preamble_class *class_);
 
-   /* Total available size per class for load/store_preamble storage, in units
-    * determined by def_size.
-    */
-   unsigned preamble_storage_size[nir_preamble_num_classes];
-
    /* Give the cost for an instruction. nir_opt_preamble will prioritize
     * instructions with higher costs. Instructions with cost 0 may still be
     * lifted, but only when required to lift other instructions with non-0
diff --git a/src/compiler/nir/nir_divergence_analysis.c b/src/compiler/nir/nir_divergence_analysis.c
index 00c9047c41103..a527d6d6a5cec 100644
--- a/src/compiler/nir/nir_divergence_analysis.c
+++ b/src/compiler/nir/nir_divergence_analysis.c
@@ -40,9 +40,9 @@
 
 struct divergence_state {
    const mesa_shader_stage stage;
+   nir_divergence_options options;
    nir_shader *shader;
    nir_function_impl *impl;
-   nir_divergence_options options;
    nir_loop *loop;
    bool loop_all_invariant;
 
diff --git a/src/compiler/nir/nir_from_ssa.c b/src/compiler/nir/nir_from_ssa.c
index bb49337085cfe..d03f9dbb9e821 100644
--- a/src/compiler/nir/nir_from_ssa.c
+++ b/src/compiler/nir/nir_from_ssa.c
@@ -36,9 +36,9 @@ struct from_ssa_state {
    nir_builder builder;
    void *dead_ctx;
    struct exec_list dead_instrs;
-   bool phi_webs_only;
    struct hash_table *merge_node_table;
    nir_instr *instr;
+   bool phi_webs_only;
    bool consider_divergence;
    bool progress;
 };
diff --git a/src/compiler/nir/nir_lower_amul.c b/src/compiler/nir/nir_lower_amul.c
index 20138e2d38b2b..d95c35c402e7a 100644
--- a/src/compiler/nir/nir_lower_amul.c
+++ b/src/compiler/nir/nir_lower_amul.c
@@ -64,9 +64,9 @@ typedef struct {
    bool has_large_ubo;
    bool has_large_ssbo;
 
-   unsigned max_slot;
-
    bool progress;
+
+   unsigned max_slot;
 } lower_state;
 
 /* Lower 'amul's in offset src of large variables to 'imul': */
diff --git a/src/compiler/nir/nir_lower_tex_shadow.c b/src/compiler/nir/nir_lower_tex_shadow.c
index 90e00b9682120..5dae74f948d91 100644
--- a/src/compiler/nir/nir_lower_tex_shadow.c
+++ b/src/compiler/nir/nir_lower_tex_shadow.c
@@ -67,9 +67,9 @@ strip_shadow_with_array(const struct glsl_type *type)
 
 typedef struct {
    unsigned n_states;
+   bool is_fixed_point_format;
    enum compare_func *compare_func;
    nir_lower_tex_shadow_swizzle *tex_swizzles;
-   bool is_fixed_point_format;
 } sampler_state;
 
 static nir_def *
@@ -149,7 +149,7 @@ nir_lower_tex_shadow(nir_shader *s,
                      nir_lower_tex_shadow_swizzle *tex_swizzles,
                      bool is_fixed_point_format)
 {
-   sampler_state state = { n_states, compare_func, tex_swizzles, is_fixed_point_format };
+   sampler_state state = { n_states, is_fixed_point_format, compare_func, tex_swizzles };
 
    bool result =
       nir_shader_lower_instructions(s,
diff --git a/src/compiler/spirv/vtn_private.h b/src/compiler/spirv/vtn_private.h
index 5d601f95c8604..f975873e8a60e 100644
--- a/src/compiler/spirv/vtn_private.h
+++ b/src/compiler/spirv/vtn_private.h
@@ -486,6 +486,9 @@ struct vtn_pointer {
    /** The variable mode for the referenced data */
    enum vtn_variable_mode mode;
 
+   /* Access qualifiers */
+   enum gl_access_qualifier access;
+
    /** The pointer type of this pointer */
    struct vtn_type *type;
 
@@ -508,16 +511,13 @@ struct vtn_pointer {
     * in which case desc_index is used instead.
     **/
    nir_deref_instr *deref;
-
-   /* Access qualifiers */
-   enum gl_access_qualifier access;
 };
 
 struct vtn_variable {
-   enum vtn_variable_mode mode;
-
    struct vtn_type *type;
 
+   enum vtn_variable_mode mode;
+
    unsigned descriptor_set;
    unsigned binding;
    bool explicit_binding;
@@ -532,6 +532,9 @@ struct vtn_variable {
     */
    int base_location;
 
+   /* Access qualifiers. */
+   enum gl_access_qualifier access;
+
    /**
     * In some early released versions of GLSLang, it implemented all function
     * calls by making copies of all parameters into temporary variables and
@@ -545,9 +548,6 @@ struct vtn_variable {
     * hack at some point in the future.
     */
    struct vtn_pointer *copy_prop_sampler;
-
-   /* Access qualifiers. */
-   enum gl_access_qualifier access;
 };
 
 const struct glsl_type *
diff --git a/src/util/register_allocate_internal.h b/src/util/register_allocate_internal.h
index e83065140a986..6560d2ec92eb6 100644
--- a/src/util/register_allocate_internal.h
+++ b/src/util/register_allocate_internal.h
@@ -158,6 +158,12 @@ struct ra_graph {
       unsigned int *stack;
       unsigned int stack_count;
 
+      /**
+       * Tracks the start of the set of optimistically-colored registers in the
+       * stack.
+       */
+      unsigned int stack_optimistic_start;
+
       /** Bit-set indicating, for each register, if it's in the stack */
       BITSET_WORD *in_stack;
 
@@ -175,12 +181,6 @@ struct ra_graph {
        * min_q_total[i] != ~0.
        */
       unsigned int *min_q_node;
-
-      /**
-       * Tracks the start of the set of optimistically-colored registers in the
-       * stack.
-       */
-      unsigned int stack_optimistic_start;
    } tmp;
 };
 
diff --git a/src/util/u_printf.h b/src/util/u_printf.h
index e99eed415d5e7..ceac634f6aa93 100644
--- a/src/util/u_printf.h
+++ b/src/util/u_printf.h
@@ -33,8 +33,8 @@ extern "C" {
 
 typedef struct u_printf_info {
    unsigned num_args;
-   unsigned *arg_sizes;
    unsigned string_size;
+   unsigned *arg_sizes;
    char *strings;
 } u_printf_info;
 
-- 
GitLab


From 57508c85cb2a92645089c1ca51f68129952d8ddf Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:27:46 +0300
Subject: [PATCH 31/31] amd: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

---
 src/amd/vpelib/inc/vpe_hw_types.h | 2 +-
 src/amd/vpelib/inc/vpe_types.h    | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/vpelib/inc/vpe_hw_types.h b/src/amd/vpelib/inc/vpe_hw_types.h
index 26fc7cfbffcbe..6b34b25363bc3 100644
--- a/src/amd/vpelib/inc/vpe_hw_types.h
+++ b/src/amd/vpelib/inc/vpe_hw_types.h
@@ -200,9 +200,9 @@ struct vpe_plane_dcc_param {
             bool     independent_64b_blks; /**< DCC independent 64 byte blocks */
             uint8_t  dcc_ind_blk;          /**< DCC independent block size */
 
-            uint32_t meta_pitch_c;         /**< DCC meta surface pitch for chroma plane in bytes */
             bool     independent_64b_blks_c; /**< DCC independent 64 byte blocks for chroma plane */
             uint8_t  dcc_ind_blk_c;          /**< DCC independent block size for chroma plane */
+            uint32_t meta_pitch_c;         /**< DCC meta surface pitch for chroma plane in bytes */
         } src;
 
     };
diff --git a/src/amd/vpelib/inc/vpe_types.h b/src/amd/vpelib/inc/vpe_types.h
index 8736dc806a290..ce11d0351bcd4 100644
--- a/src/amd/vpelib/inc/vpe_types.h
+++ b/src/amd/vpelib/inc/vpe_types.h
@@ -749,11 +749,11 @@ struct vpe_tonemap_params {
     uint16_t                   lut_dim;              /**< Size of one dimension of the 3D-LUT */
     /** @brief 3D LUT settings
      */
+    bool is_dma_lut;   /**< Set to true if the 3D LUT is DMA LUT */
+    bool enable_3dlut; /**< Enable/Disable 3D-LUT */
     union {
         uint16_t *lut_data;                          /**< Accessible to CPU */
     };
-    bool is_dma_lut;   /**< Set to true if the 3D LUT is DMA LUT */
-    bool enable_3dlut; /**< Enable/Disable 3D-LUT */
 };
 
 /** @enum vpe_keyer_mode
@@ -845,8 +845,8 @@ enum predication_polarity {
  *  @brief Predication info
  */
 struct vpe_predication_info {
-    bool                      enable;   /**< Enable predication */
     uint64_t                  gpu_va;   /**< GPU start address of the buffer */
+    bool                      enable;   /**< Enable predication */
     enum predication_polarity polarity; /**< Predication polarity */
 };
 
-- 
GitLab

