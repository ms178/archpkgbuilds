From 179e37e7f9fcb306526e170d1cb98c2d0f30e03d Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 08:59:12 +0300
Subject: [PATCH 01/31] amd: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/amd/common/ac_debug.h       | 2 +-
 src/amd/common/ac_perfcounter.h | 7 ++++---
 src/amd/common/ac_rgp.h         | 2 +-
 src/amd/vpelib/inc/vpe_types.h  | 6 +++---
 4 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/src/amd/common/ac_debug.h b/src/amd/common/ac_debug.h
index 377c10e133eab..13fe2058dc2e2 100644
--- a/src/amd/common/ac_debug.h
+++ b/src/amd/common/ac_debug.h
@@ -88,8 +88,8 @@ struct ac_ib_parser {
    FILE *f;
    uint32_t *ib;
    unsigned num_dw;
-   const int *trace_ids;
    unsigned trace_id_count;
+   const int *trace_ids;
    enum amd_gfx_level gfx_level;
    enum vcn_version vcn_version;
    enum radeon_family family;
diff --git a/src/amd/common/ac_perfcounter.h b/src/amd/common/ac_perfcounter.h
index c198c4403ef28..6bc7b46e268d5 100644
--- a/src/amd/common/ac_perfcounter.h
+++ b/src/amd/common/ac_perfcounter.h
@@ -93,20 +93,21 @@ enum ac_pc_gpu_block {
 };
 
 struct ac_pc_block_base {
-   enum ac_pc_gpu_block gpu_block;
    const char *name;
+   enum ac_pc_gpu_block gpu_block;
    unsigned num_counters;
    unsigned flags;
 
    unsigned select_or;
    unsigned *select0;
-   unsigned counter0_lo;
+   unsigned *select1;
+
    unsigned *counters;
+   unsigned counter0_lo;
 
    /* SPM */
    unsigned num_spm_counters;
    unsigned num_spm_wires;
-   unsigned *select1;
    unsigned spm_block_select;
 };
 
diff --git a/src/amd/common/ac_rgp.h b/src/amd/common/ac_rgp.h
index 3966fa9b3ed75..cac4dca1b786e 100644
--- a/src/amd/common/ac_rgp.h
+++ b/src/amd/common/ac_rgp.h
@@ -133,8 +133,8 @@ struct rgp_queue_info_record {
 };
 
 struct rgp_queue_info {
-   uint32_t record_count;
    struct list_head record;
+   uint32_t record_count;
    simple_mtx_t lock;
 };
 
diff --git a/src/amd/vpelib/inc/vpe_types.h b/src/amd/vpelib/inc/vpe_types.h
index aaf6e006fe762..8736dc806a290 100644
--- a/src/amd/vpelib/inc/vpe_types.h
+++ b/src/amd/vpelib/inc/vpe_types.h
@@ -813,10 +813,10 @@ struct vpe_stream {
     float lower_luma_bound;                                    /**< Lowest range of the luma */
     float upper_luma_bound;                                    /**< Highest range of the luma */
     struct vpe_color_keyer color_keyer; /**< Enable Luma Keying & Set Parameters. */
-    enum vpe_keyer_mode    keyer_mode;  /**< Set Keyer Behavior.
-                                         * Used for both Luma & Color Keying.
-                                         */
     struct vpe_reserved_param reserved_param;     /**< Reserved parameter for input surface */
+    enum vpe_keyer_mode    keyer_mode;  /**< Set Keyer Behavior.
+                                        * Used for both Luma & Color Keying.
+                                        */
 
     /** @brief stream feature flags
      */
-- 
GitLab


From d97d506535744ec56c1405d31b3ad0b1528d4fe3 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 08:59:52 +0300
Subject: [PATCH 02/31] mesa: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/mesa/main/consts_exts.h                   |   8 +-
 src/mesa/main/formats.c                       |   4 +-
 src/mesa/main/glthread.h                      |  34 ++---
 src/mesa/main/glthread_bufferobj.c            |   8 +-
 src/mesa/main/mtypes.h                        | 142 +++++++++---------
 src/mesa/main/shader_types.h                  |   4 +-
 src/mesa/program/program_parser.h             |  11 +-
 src/mesa/state_tracker/st_context.h           |   6 +-
 .../state_tracker/st_nir_lower_alpha_test.c   |   2 +-
 src/mesa/state_tracker/st_nir_lower_fog.c     |   2 +-
 10 files changed, 110 insertions(+), 111 deletions(-)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 526078f9ce376..219b163d89593 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -303,16 +303,16 @@ struct gl_extensions
    GLboolean OES_geometry_shader;
    GLboolean OES_texture_compression_astc;
    GLboolean extension_sentinel;
-   /** The extension string */
-   const GLubyte *String;
-   /** Number of supported extensions */
-   GLuint Count;
    /**
     * The context version which extension helper functions compare against.
     * By default, the value is equal to ctx->Version. This changes to ~0
     * while meta is in progress.
     */
    GLubyte Version;
+   /** Number of supported extensions */
+   GLuint Count;
+   /** The extension string */
+   const GLubyte *String;
 };
 
 /**
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index 07853b92445ae..7294ec0776c98 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -39,11 +39,11 @@ struct mesa_format_info
 {
    mesa_format Name;
 
+   enum mesa_format_layout Layout;
+
    /** text name for debugging */
    const char *StrName;
 
-   enum mesa_format_layout Layout;
-
    /**
     * Base format is one of GL_RED, GL_RG, GL_RGB, GL_RGBA, GL_ALPHA,
     * GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_YCBCR_MESA,
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index 39594b368e746..be7578073f8c2 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -145,9 +145,6 @@ struct glthread_batch
    /** Batch fence for waiting for the execution to finish. */
    struct util_queue_fence fence;
 
-   /** The worker thread will access the context with this. */
-   struct gl_context *ctx;
-
    /**
     * Number of uint64_t elements filled already.
     * This is 0 when it's being filled because glthread::used holds the real
@@ -156,6 +153,9 @@ struct glthread_batch
     */
    unsigned used;
 
+   /** The worker thread will access the context with this. */
+   struct gl_context *ctx;
+
    /** Data contained in the command buffer. */
    uint64_t buffer[MARSHAL_MAX_CMD_BUFFER_SIZE / 8];
 };
@@ -208,10 +208,9 @@ struct glthread_state
    bool inside_begin_end;
    bool thread_sched_enabled;
 
-   /** Display lists. */
-   GLenum16 ListMode; /**< Zero if not inside display list, else list mode. */
-   unsigned ListBase;
-   unsigned ListCallDepth;
+   /** Global mutex update info. */
+   bool LockGlobalMutexes;
+   unsigned GlobalLockUpdateBatchCounter;
 
    /** For L3 cache pinning. */
    unsigned pin_thread_counter;
@@ -233,17 +232,22 @@ struct glthread_state
    unsigned used;
 
    /** Upload buffer. */
+   unsigned upload_offset;
    struct gl_buffer_object *upload_buffer;
    uint8_t *upload_ptr;
-   unsigned upload_offset;
    int upload_buffer_private_refcount;
 
+   /** Display lists. */
+   unsigned ListBase;
+   unsigned ListCallDepth;
+   GLenum16 ListMode; /**< Zero if not inside display list, else list mode. */
+
    /** Primitive restart state. */
    bool PrimitiveRestart;
    bool PrimitiveRestartFixedIndex;
-   bool _PrimitiveRestart;
    GLuint RestartIndex;
    GLuint _RestartIndex[4]; /**< Restart index for index_size = 1,2,4. */
+   bool _PrimitiveRestart;
 
    /** Vertex Array objects tracked by glthread independently of Mesa. */
    struct _mesa_HashTable VAOs;
@@ -275,11 +279,11 @@ struct glthread_state
 
    /** Basic matrix state tracking. */
    int ActiveTexture;
-   GLenum16 MatrixMode;
    gl_matrix_index MatrixIndex;
    struct glthread_attrib_node AttribStack[MAX_ATTRIB_STACK_DEPTH];
-   int AttribStackDepth;
    int MatrixStackDepth[M_NUM_MATRIX_STACKS];
+   int AttribStackDepth;
+   GLenum16 MatrixMode;
 
    /** Enable states. */
    bool Blend;
@@ -294,15 +298,11 @@ struct glthread_state
    GLuint CurrentProgram;
 
    /** The last added call of the given function. */
+   struct gl_pixelstore_attrib Unpack;
+
    struct marshal_cmd_CallList *LastCallList;
    struct marshal_cmd_BindBuffer *LastBindBuffer1;
    struct marshal_cmd_BindBuffer *LastBindBuffer2;
-
-   /** Global mutex update info. */
-   unsigned GlobalLockUpdateBatchCounter;
-   bool LockGlobalMutexes;
-
-   struct gl_pixelstore_attrib Unpack;
 };
 
 void _mesa_glthread_init(struct gl_context *ctx);
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index 7d4b15cb21641..f78b9bee282dc 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -320,13 +320,13 @@ struct marshal_cmd_BufferData
 {
    struct marshal_cmd_base cmd_base;
    uint16_t num_slots;
-   GLuint target_or_name;
-   GLsizeiptr size;
-   GLenum usage;
-   const GLvoid *data_external_mem;
    bool data_null; /* If set, no data follows for "data" */
    bool named;
    bool ext_dsa;
+   GLenum usage;
+   GLuint target_or_name;
+   GLsizeiptr size;
+   const GLvoid *data_external_mem;
    /* Next size bytes are GLubyte data[size] */
 };
 
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 7214818f02e4d..9d2839add9097 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -614,6 +614,11 @@ struct gl_pixel_attrib
    GLenum16 ReadBuffer;		/**< source buffer for glRead/CopyPixels() */
 
    /*--- Begin Pixel Transfer State ---*/
+   /* Pixel Maps */
+   /* Note: actual pixel maps are not part of this attrib group */
+   GLboolean MapColorFlag;
+   GLboolean MapStencilFlag;
+
    /* Fields are in the order in which they're applied... */
 
    /** Scale & Bias (index shift, offset) */
@@ -626,11 +631,6 @@ struct gl_pixel_attrib
    GLint IndexShift, IndexOffset;
    /*@}*/
 
-   /* Pixel Maps */
-   /* Note: actual pixel maps are not part of this attrib group */
-   GLboolean MapColorFlag;
-   GLboolean MapStencilFlag;
-
    /*--- End Pixel Transfer State ---*/
 
    /** glPixelZoom */
@@ -2393,11 +2393,11 @@ struct gl_sync_object
                                * live references (e.g., sync not yet finished)
                                */
    GLenum16 SyncCondition;
-   GLbitfield Flags;          /**< Flags passed to glFenceSync */
    GLuint StatusFlag:1;       /**< Has the sync object been signaled? */
+   GLbitfield Flags;          /**< Flags passed to glFenceSync */
 
-   struct pipe_fence_handle *fence;
    simple_mtx_t mutex; /**< protects "fence" */
+   struct pipe_fence_handle *fence;
 };
 
 
@@ -2597,24 +2597,24 @@ struct gl_renderbuffer_attachment
    GLenum16 Type; /**< \c GL_NONE or \c GL_TEXTURE or \c GL_RENDERBUFFER_EXT */
    GLboolean Complete;
 
-   /**
-    * If \c Type is \c GL_RENDERBUFFER_EXT, this stores a pointer to the
-    * application supplied renderbuffer object.
-    */
-   struct gl_renderbuffer *Renderbuffer;
-
    /**
     * If \c Type is \c GL_TEXTURE, this stores a pointer to the application
     * supplied texture object.
     */
-   struct gl_texture_object *Texture;
+   GLboolean Layered;
    GLuint TextureLevel; /**< Attached mipmap level. */
+   struct gl_texture_object *Texture;
    GLsizei NumSamples;  /**< from FramebufferTexture2DMultisampleEXT */
    GLuint CubeMapFace;  /**< 0 .. 5, for cube map textures. */
    GLuint Zoffset;      /**< Slice for 3D textures,  or layer for both 1D
                          * and 2D array textures */
-   GLboolean Layered;
    GLsizei NumViews;
+
+   /**
+    * If \c Type is \c GL_RENDERBUFFER_EXT, this stores a pointer to the
+    * application supplied renderbuffer object.
+    */
+   struct gl_renderbuffer *Renderbuffer;
 };
 
 
@@ -2636,10 +2636,29 @@ struct gl_framebuffer
    GLuint Name;
    GLint RefCount;
 
-   GLchar *Label;       /**< GL_KHR_debug */
-
    GLboolean DeletePending;
 
+   /** Whether one of Attachment has Type != GL_NONE
+    * NOTE: the values for Width and Height are set to 0 in case of having
+    * no attachments, a backend driver supporting the extension
+    * GL_ARB_framebuffer_no_attachments must check for the flag _HasAttachments
+    * and if GL_FALSE, must then use the values in DefaultGeometry to initialize
+    * its viewport, scissor and so on (in particular _Xmin, _Xmax, _Ymin and
+    * _Ymax do NOT take into account _HasAttachments being false). To get the
+    * geometry of the framebuffer, the  helper functions
+    *   _mesa_geometric_width(),
+    *   _mesa_geometric_height(),
+    *   _mesa_geometric_samples() and
+    *   _mesa_geometric_layers()
+    * are available that check _HasAttachments.
+    */
+   bool _HasAttachments;
+
+   /* GL_MESA_framebuffer_flip_y */
+   bool FlipY;
+
+   GLchar *Label;       /**< GL_KHR_debug */
+
    /**
     * The framebuffer's visual. Immutable if this is a window system buffer.
     * Computed from attachments if user-made FBO.
@@ -2682,24 +2701,23 @@ struct gl_framebuffer
    GLfloat _MRD;	/**< minimum resolvable difference in Z values */
    /*@}*/
 
+   /**
+    * The maximum number of layers in the framebuffer, or 0 if the framebuffer
+    * is not layered.  For cube maps and cube map arrays, each cube face
+    * counts as a layer. As the case for Width, Height a backend driver
+    * supporting GL_ARB_framebuffer_no_attachments must use DefaultGeometry
+    * in the case that _HasAttachments is false
+    */
+   GLuint MaxNumLayers;
+
    /** One of the GL_FRAMEBUFFER_(IN)COMPLETE_* tokens */
    GLenum16 _Status;
 
-   /** Whether one of Attachment has Type != GL_NONE
-    * NOTE: the values for Width and Height are set to 0 in case of having
-    * no attachments, a backend driver supporting the extension
-    * GL_ARB_framebuffer_no_attachments must check for the flag _HasAttachments
-    * and if GL_FALSE, must then use the values in DefaultGeometry to initialize
-    * its viewport, scissor and so on (in particular _Xmin, _Xmax, _Ymin and
-    * _Ymax do NOT take into account _HasAttachments being false). To get the
-    * geometry of the framebuffer, the  helper functions
-    *   _mesa_geometric_width(),
-    *   _mesa_geometric_height(),
-    *   _mesa_geometric_samples() and
-    *   _mesa_geometric_layers()
-    * are available that check _HasAttachments.
+   /* In unextended OpenGL these vars are part of the GL_COLOR_BUFFER
+    * attribute group and GL_PIXEL attribute group, respectively.
     */
-   bool _HasAttachments;
+   GLenum16 ColorReadBuffer;
+   GLenum16 ColorDrawBuffer[MAX_DRAW_BUFFERS];
 
    GLbitfield _IntegerBuffers;  /**< Which color buffer attachments are integer valued */
    GLbitfield _IntegerDrawBuffers;  /**< Which color draw buffers are integer valued */
@@ -2710,44 +2728,26 @@ struct gl_framebuffer
    GLbitfield _FP32Buffers; /**< Which color attachments are FP32 */
    GLbitfield _FP32DrawBuffers; /**< Which color buffers are FP32 */
 
-   /* ARB_color_buffer_float */
-   GLboolean _AllColorBuffersFixedPoint; /* no integer, no float */
-   GLboolean _HasSNormOrFloatColorBuffer;
-
-   /**
-    * The maximum number of layers in the framebuffer, or 0 if the framebuffer
-    * is not layered.  For cube maps and cube map arrays, each cube face
-    * counts as a layer. As the case for Width, Height a backend driver
-    * supporting GL_ARB_framebuffer_no_attachments must use DefaultGeometry
-    * in the case that _HasAttachments is false
-    */
-   GLuint MaxNumLayers;
-
    /** Array of all renderbuffer attachments, indexed by BUFFER_* tokens. */
    struct gl_renderbuffer_attachment Attachment[BUFFER_COUNT];
    struct pipe_resource *resolve; /**< color resolve attachment */
 
-   /* In unextended OpenGL these vars are part of the GL_COLOR_BUFFER
-    * attribute group and GL_PIXEL attribute group, respectively.
-    */
-   GLenum16 ColorDrawBuffer[MAX_DRAW_BUFFERS];
-   GLenum16 ColorReadBuffer;
-
    /* GL_ARB_sample_locations */
    GLfloat *SampleLocationTable; /**< If NULL, no table has been specified */
    GLboolean ProgrammableSampleLocations;
    GLboolean SampleLocationPixelGrid;
 
+   /* ARB_color_buffer_float */
+   GLboolean _AllColorBuffersFixedPoint; /* no integer, no float */
+   GLboolean _HasSNormOrFloatColorBuffer;
+
    /** Computed from ColorDraw/ReadBuffer above */
    GLuint _NumColorDrawBuffers;
-   gl_buffer_index _ColorDrawBufferIndexes[MAX_DRAW_BUFFERS];
    gl_buffer_index _ColorReadBufferIndex;
+   gl_buffer_index _ColorDrawBufferIndexes[MAX_DRAW_BUFFERS];
    struct gl_renderbuffer *_ColorDrawBuffers[MAX_DRAW_BUFFERS];
    struct gl_renderbuffer *_ColorReadBuffer;
 
-   /* GL_MESA_framebuffer_flip_y */
-   bool FlipY;
-
    /** Delete this framebuffer */
    void (*Delete)(struct gl_framebuffer *fb);
 
@@ -3030,8 +3030,8 @@ struct gl_memory_object
 struct gl_semaphore_object
 {
    GLuint Name;            /**< hash table ID/name */
-   struct pipe_fence_handle *fence;
    enum pipe_fd_type type;
+   struct pipe_fence_handle *fence;
    uint64_t timeline_value;
 };
 
@@ -3265,15 +3265,6 @@ struct gl_context
    /** Only accessible while Shared->Mutex is held */
    struct util_dynarray ReleaseResources;
 
-   /** Whether Shared->BufferObjects has already been locked for this context. */
-   bool BufferObjectsLocked;
-   /** Whether Shared->TexMutex has already been locked for this context. */
-   bool TexturesLocked;
-
-   /** \name API function pointer tables */
-   /*@{*/
-   gl_api API;
-
    /**
     * Dispatch tables implementing OpenGL functions. GLThread has no effect
     * on this.
@@ -3297,6 +3288,10 @@ struct gl_context
 
    struct glthread_state GLThread;
 
+   /** \name API function pointer tables */
+   /*@{*/
+   gl_api API;
+
    struct gl_config Visual;
    struct gl_framebuffer *DrawBuffer;	/**< buffer for writing */
    struct gl_framebuffer *ReadBuffer;	/**< buffer for reading */
@@ -3325,6 +3320,11 @@ struct gl_context
     */
    GLbitfield ValidPrimMask;
 
+   /** Whether Shared->BufferObjects has already been locked for this context. */
+   bool BufferObjectsLocked;
+   /** Whether Shared->TexMutex has already been locked for this context. */
+   bool TexturesLocked;
+
    GLenum16 DrawGLError; /**< GL error to return from draw calls */
 
    /**
@@ -3335,11 +3335,6 @@ struct gl_context
    /** DrawID for the next non-multi non-indirect draw. Only set by glthread. */
    GLuint DrawID;
 
-   /**
-    * Whether DrawPixels/CopyPixels/Bitmap are valid to render.
-    */
-   bool DrawPixValid;
-
    /** \name The various 4x4 matrix stacks */
    /*@{*/
    struct gl_matrix_stack ModelviewMatrixStack;
@@ -3358,12 +3353,17 @@ struct gl_context
    GLboolean ExecuteFlag;	/**< Execute GL commands? */
    GLboolean CompileFlag;	/**< Compile GL commands into display list? */
 
+   /**
+    * Whether DrawPixels/CopyPixels/Bitmap are valid to render.
+    */
+   bool DrawPixValid;
+
    /** Extension information */
    struct gl_extensions Extensions;
 
-   /** GL version integer, for example 31 for GL 3.1, or 20 for GLES 2.0. */
-   GLuint Version;
+   /** GL version integer, for example 31 for GL 3.1, or 20 for GLES 2.0. */\
    char *VersionString;
+   GLuint Version;
 
    /** \name State attribute stack (for glPush/PopAttrib) */
    /*@{*/
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index 97ba97ce0c45e..1a8ea3b60a73a 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -251,8 +251,6 @@ struct gl_linked_shader
 {
    mesa_shader_stage Stage;
 
-   struct gl_program *Program;  /**< Post-compile assembly code */
-
    /**
     * \name Sampler tracking
     *
@@ -262,6 +260,8 @@ struct gl_linked_shader
    GLbitfield shadow_samplers;	/**< Samplers used for shadow sampling. */
    /*@}*/
 
+   struct gl_program *Program;  /**< Post-compile assembly code */
+
    /**
     * Number of default uniform block components used by this shader.
     *
diff --git a/src/mesa/program/program_parser.h b/src/mesa/program/program_parser.h
index cb3dd33bdc4db..d24dca0326c7a 100644
--- a/src/mesa/program/program_parser.h
+++ b/src/mesa/program/program_parser.h
@@ -190,6 +190,11 @@ struct asm_parser_state {
    unsigned state_param_enum_env;
    unsigned state_param_enum_local;
 
+   enum {
+      invalid_mode = 0,
+      ARB_vertex,
+      ARB_fragment
+   } mode;
 
    /**
     * Input attributes bound to specific names
@@ -200,12 +205,6 @@ struct asm_parser_state {
     */
    GLbitfield64 InputsBound;
 
-   enum {
-      invalid_mode = 0,
-      ARB_vertex,
-      ARB_fragment
-   } mode;
-
    struct {
       unsigned PositionInvariant:1;
       unsigned Fog:2; /* gl_fog_mode */
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index c06832831b0d5..fb45e8321cf5d 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -62,18 +62,18 @@ struct st_bitmap_cache
 
    /** GL states */
    struct gl_program *fp;
+   GLfloat color[4];
    bool scissor_enabled;
    bool clamp_frag_color;
-   GLfloat color[4];
 
    /** Bitmap's Z position */
+   GLboolean empty;
+
    GLfloat zpos;
 
    struct pipe_resource *texture;
    struct pipe_transfer *trans;
 
-   GLboolean empty;
-
    /** An I8 texture image: */
    uint8_t *buffer;
 };
diff --git a/src/mesa/state_tracker/st_nir_lower_alpha_test.c b/src/mesa/state_tracker/st_nir_lower_alpha_test.c
index 1df994030ea1e..2b42d7590257d 100644
--- a/src/mesa/state_tracker/st_nir_lower_alpha_test.c
+++ b/src/mesa/state_tracker/st_nir_lower_alpha_test.c
@@ -37,10 +37,10 @@
 
 struct alpha_test_state {
    bool alpha_to_one;
+   bool packed_driver_uniform_storage;
    enum compare_func func;
    const gl_state_index16 *alpha_ref_state_tokens;
    struct gl_program_parameter_list *paramList;
-   bool packed_driver_uniform_storage;
 };
 
 static bool
diff --git a/src/mesa/state_tracker/st_nir_lower_fog.c b/src/mesa/state_tracker/st_nir_lower_fog.c
index f400048c6b17f..23f27f709080f 100644
--- a/src/mesa/state_tracker/st_nir_lower_fog.c
+++ b/src/mesa/state_tracker/st_nir_lower_fog.c
@@ -79,8 +79,8 @@ fog_result(nir_builder *b, nir_def *color, enum gl_fog_mode fog_mode,
 
 struct lower_fog_state {
    enum gl_fog_mode fog_mode;
-   struct gl_program_parameter_list *paramList;
    bool packed_driver_uniform_storage;
+   struct gl_program_parameter_list *paramList;
 };
 
 static bool
-- 
GitLab

From 0e7fe1fcb1ecb6c2fffbbbfad39a49910df663f1 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Sat, 20 Sep 2025 09:01:18 +0300
Subject: [PATCH 04/31] egl: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/egl/drivers/dri2/egl_dri2.h | 72 +++++++++++++++++----------------
 src/egl/main/eglarray.h         |  2 +-
 src/egl/main/egldisplay.h       |  6 +--
 src/egl/main/eglglobals.h       |  8 ++--
 src/egl/main/eglsync.h          |  2 +-
 5 files changed, 47 insertions(+), 43 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 15da921421a0f..a1c29b3b67566 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -223,8 +223,32 @@ struct dri2_egl_display {
     * fd_display_gpu will still hold fd for display driver.
     */
    struct dri_screen *dri_screen_display_gpu;
-   bool own_dri_screen;
    const struct dri_config **driver_configs;
+   bool own_dri_screen;
+
+   bool has_compression_modifiers;
+   bool own_device;
+   bool kopper;
+   bool swrast;
+   bool swrast_not_kms;
+
+   bool has_dmabuf_import;
+   bool has_dmabuf_export;
+   bool explicit_modifiers;
+   bool multibuffers_available;
+#ifdef HAVE_X11_PLATFORM
+   bool swap_available;
+   xcb_connection_t *conn;
+   xcb_screen_t *screen;
+#ifdef HAVE_LIBDRM
+   struct loader_screen_resources screen_resources;
+#endif
+
+   int min_swap_interval;
+   int max_swap_interval;
+   int default_swap_interval;
+#endif
+
    /* fd of the GPU used for rendering. */
    int fd_render_gpu;
    /* fd of the GPU used for display. If the same GPU is used for display
@@ -237,14 +261,6 @@ struct dri2_egl_display {
     * dri2_make_current (tracks if there are active contexts/surfaces). */
    int ref_count;
 
-   bool has_compression_modifiers;
-   bool own_device;
-   bool kopper;
-   bool swrast;
-   bool swrast_not_kms;
-   int min_swap_interval;
-   int max_swap_interval;
-   int default_swap_interval;
 #ifdef HAVE_DRM_PLATFORM
    struct gbm_dri_device *gbm_dri;
 #endif
@@ -253,19 +269,6 @@ struct dri2_egl_display {
 
    const __DRIextension **loader_extensions;
 
-   bool has_dmabuf_import;
-   bool has_dmabuf_export;
-   bool explicit_modifiers;
-   bool multibuffers_available;
-#ifdef HAVE_X11_PLATFORM
-   xcb_connection_t *conn;
-   xcb_screen_t *screen;
-   bool swap_available;
-#ifdef HAVE_LIBDRM
-   struct loader_screen_resources screen_resources;
-#endif
-#endif
-
 #ifdef HAVE_WAYLAND_PLATFORM
    struct wl_display *wl_dpy;
    struct wl_display *wl_dpy_wrapper;
@@ -285,16 +288,16 @@ struct dri2_egl_display {
    struct zwp_linux_dmabuf_feedback_v1 *wl_dmabuf_feedback;
    struct dmabuf_feedback_format_table format_table;
    char *device_name;
-   bool is_render_node;
    clockid_t presentation_clock_id;
+   bool is_render_node;
 #endif
 
 #ifdef HAVE_ANDROID_PLATFORM
-   struct u_gralloc *gralloc;
    /* gralloc vendor usage bit for front rendering */
-   uint32_t front_rendering_usage;
    bool has_native_fence_fd;
    bool pure_swrast;
+   uint32_t front_rendering_usage;
+   struct u_gralloc *gralloc;
 #endif
 };
 
@@ -307,7 +310,6 @@ struct dri2_egl_surface {
    _EGLSurface base;
    struct dri_drawable *dri_drawable;
    __DRIbuffer buffers[5];
-   bool have_fake_front;
 
 #ifdef HAVE_X11_PLATFORM
    xcb_drawable_t drawable;
@@ -318,6 +320,10 @@ struct dri2_egl_surface {
    xcb_gcontext_t swapgc;
 #endif
 
+   /* surfaceless and device */
+   enum pipe_format visual;
+   struct dri_image *front;
+
 #ifdef HAVE_WAYLAND_PLATFORM
    struct wl_egl_window *wl_win;
    int dx;
@@ -330,12 +336,14 @@ struct dri2_egl_surface {
    struct zwp_linux_dmabuf_feedback_v1 *wl_dmabuf_feedback;
    struct dmabuf_feedback dmabuf_feedback, pending_dmabuf_feedback;
    struct loader_wayland_presentation wayland_presentation;
-   bool compositor_using_another_device;
    int format;
+   bool compositor_using_another_device;
    bool resized;
    bool received_dmabuf_feedback;
 #endif
 
+   bool have_fake_front;
+
 #ifdef HAVE_DRM_PLATFORM
    struct gbm_dri_surface *gbm_surf;
 #endif
@@ -344,19 +352,19 @@ struct dri2_egl_surface {
    struct {
 #ifdef HAVE_WAYLAND_PLATFORM
       struct loader_wayland_buffer wayland_buffer;
-      bool wl_release;
       struct dri_image *dri_image;
       /* for is_different_gpu case. NULL else */
       struct dri_image *linear_copy;
       /* for swrast */
       void *data;
       int data_size;
+      bool wl_release;
 #endif
+      bool locked;
+      int age;
 #ifdef HAVE_DRM_PLATFORM
       struct gbm_bo *bo;
 #endif
-      bool locked;
-      int age;
    } color_buffers[4], *back, *current;
 #endif
 
@@ -382,10 +390,6 @@ struct dri2_egl_surface {
    uint32_t gralloc_usage;
 #endif
 
-   /* surfaceless and device */
-   struct dri_image *front;
-   enum pipe_format visual;
-
    int out_fence_fd;
    EGLBoolean enable_out_fence;
 
diff --git a/src/egl/main/eglarray.h b/src/egl/main/eglarray.h
index 87b8f0a9b11b5..0e79457b8f0b1 100644
--- a/src/egl/main/eglarray.h
+++ b/src/egl/main/eglarray.h
@@ -40,8 +40,8 @@ struct _egl_array {
    const char *Name;
    EGLint MaxSize;
 
-   void **Elements;
    EGLint Size;
+   void **Elements;
 };
 
 extern _EGLArray *
diff --git a/src/egl/main/egldisplay.h b/src/egl/main/egldisplay.h
index 6178140e7e747..2c74bd8112c55 100644
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -189,13 +189,13 @@ struct _egl_display {
     */
    struct u_rwlock TerminateLock;
 
-   _EGLPlatformType Platform; /**< The type of the platform display */
-   void *PlatformDisplay;     /**< A pointer to the platform display */
-
    _EGLDevice *Device;       /**< Device backing the display */
    const _EGLDriver *Driver; /**< Matched driver of the display */
    EGLBoolean Initialized;   /**< True if the display is initialized */
 
+   _EGLPlatformType Platform; /**< The type of the platform display */
+   void *PlatformDisplay;     /**< A pointer to the platform display */
+
    /* options that affect how the driver initializes the display */
    struct {
       EGLBoolean Zink;           /**< Use kopper only */
diff --git a/src/egl/main/eglsync.h b/src/egl/main/eglsync.h
index d76446cd0b9c5..6e7d08d57f5d8 100644
--- a/src/egl/main/eglsync.h
+++ b/src/egl/main/eglsync.h
@@ -41,8 +41,8 @@ struct _egl_sync {
    EGLenum Type;
    EGLenum SyncStatus;
    EGLenum SyncCondition;
-   EGLAttrib CLEvent;
    EGLint SyncFd;
+   EGLAttrib CLEvent;
 };
 
 extern EGLBoolean
-- 
GitLab

From 31294e126f09e7b046b0da611fae9e0d8a77fc16 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Wed, 24 Sep 2025 10:53:37 +0300
Subject: [PATCH 06/31] vulkan: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/vulkan/runtime/rmv/vk_rmv_tokens.h        |  8 +-
 src/vulkan/runtime/vk_command_buffer.h        | 32 +++----
 src/vulkan/runtime/vk_device.h                | 30 +++---
 .../runtime/vk_device_generated_commands.h    | 10 +-
 src/vulkan/runtime/vk_graphics_state.h        | 22 ++---
 src/vulkan/runtime/vk_image.h                 |  2 +-
 src/vulkan/runtime/vk_instance.h              | 18 ++--
 src/vulkan/runtime/vk_queue.h                 | 96 +++++++++----------
 src/vulkan/runtime/vk_render_pass.h           | 30 +++---
 src/vulkan/runtime/vk_texcompress_astc.h      |  4 +-
 10 files changed, 126 insertions(+), 126 deletions(-)

diff --git a/src/vulkan/runtime/rmv/vk_rmv_tokens.h b/src/vulkan/runtime/rmv/vk_rmv_tokens.h
index ca40838929d3c..392a3e68562db 100644
--- a/src/vulkan/runtime/rmv/vk_rmv_tokens.h
+++ b/src/vulkan/runtime/rmv/vk_rmv_tokens.h
@@ -163,14 +163,14 @@ struct vk_rmv_image_description {
    uint32_t metadata_alignment_log2;
    uint32_t image_alignment_log2;
 
+   bool presentable;
+
    uint64_t size;
    uint64_t metadata_size;
    uint64_t metadata_header_size;
 
    uint64_t metadata_offset;
    uint64_t metadata_header_offset;
-
-   bool presentable;
 };
 
 struct vk_rmv_event_description {
@@ -202,10 +202,10 @@ struct vk_rmv_heap_description {
 
 struct vk_rmv_pipeline_description {
    bool is_internal;
+   bool is_ngg;
+   VkShaderStageFlags shader_stages;
    uint64_t hash_lo;
    uint64_t hash_hi;
-   VkShaderStageFlags shader_stages;
-   bool is_ngg;
 };
 
 struct vk_rmv_descriptor_pool_description {
diff --git a/src/vulkan/runtime/vk_command_buffer.h b/src/vulkan/runtime/vk_command_buffer.h
index 7d6775258dc80..18a5a466ab7b6 100644
--- a/src/vulkan/runtime/vk_command_buffer.h
+++ b/src/vulkan/runtime/vk_command_buffer.h
@@ -114,19 +114,27 @@ struct vk_command_buffer {
 
    struct vk_command_pool *pool;
 
-   /** VkCommandBufferAllocateInfo::level */
-   VkCommandBufferLevel level;
-
    const struct vk_command_buffer_ops *ops;
 
    struct vk_dynamic_graphics_state dynamic_graphics_state;
 
+   /** VkCommandBufferAllocateInfo::level */
+   VkCommandBufferLevel level;
+
    /** State of the command buffer */
    enum mesa_vk_command_buffer_state state;
 
    /** Command buffer recording error state. */
    VkResult record_result;
 
+   /**
+    * Bitmask of shader stages bound via a vk_pipeline since the last call to
+    * vkBindShadersEXT().
+    *
+    * Used by the common vk_pipeline implementation
+    */
+   VkShaderStageFlags pipeline_shader_stages;
+
    /** Link in vk_command_pool::command_buffers if pool != NULL */
    struct list_head pool_link;
 
@@ -176,30 +184,22 @@ struct vk_command_buffer {
    struct util_dynarray labels;
    bool region_begin;
 
-   struct vk_render_pass *render_pass;
-   uint32_t subpass_idx;
-   struct vk_framebuffer *framebuffer;
-   VkRect2D render_area;
-
    /**
     * True if we are currently inside a CmdPipelineBarrier() is inserted by
     * the runtime's vk_render_pass.c
     */
    bool runtime_rp_barrier;
 
+   uint32_t subpass_idx;
+   struct vk_render_pass *render_pass;
+   struct vk_framebuffer *framebuffer;
+   VkRect2D render_area;
+
    /* This uses the same trick as STACK_ARRAY */
    struct vk_attachment_state *attachments;
    struct vk_attachment_state _attachments[8];
 
    VkRenderPassSampleLocationsBeginInfoEXT *pass_sample_locations;
-
-   /**
-    * Bitmask of shader stages bound via a vk_pipeline since the last call to
-    * vkBindShadersEXT().
-    *
-    * Used by the common vk_pipeline implementation
-    */
-   VkShaderStageFlags pipeline_shader_stages;
 };
 
 VK_DEFINE_HANDLE_CASTS(vk_command_buffer, base, VkCommandBuffer,
diff --git a/src/vulkan/runtime/vk_device.h b/src/vulkan/runtime/vk_device.h
index 8b45d0244d12a..881f8bcf59401 100644
--- a/src/vulkan/runtime/vk_device.h
+++ b/src/vulkan/runtime/vk_device.h
@@ -119,6 +119,16 @@ struct vk_device {
    /** Table of enabled features */
    struct vk_features enabled_features;
 
+   /* For VK_KHR_pipeline_binary */
+   bool disable_internal_cache;
+
+   bool trace_hotkey_trigger;
+   uint32_t current_frame;
+   simple_mtx_t trace_mtx;
+
+   uint32_t memory_report_count;
+   struct vk_device_memory_report *memory_reports;
+
    /** Device-level dispatch table */
    struct vk_device_dispatch_table dispatch_table;
 
@@ -185,13 +195,14 @@ struct vk_device {
     */
    VkResult (*capture_trace)(VkQueue queue);
 
-   uint32_t current_frame;
-   bool trace_hotkey_trigger;
-   simple_mtx_t trace_mtx;
-
    /* For VK_EXT_private_data */
    uint32_t private_data_next_index;
 
+   /** Host time domain used for timestamp calibration */
+   VkTimeDomainKHR calibrate_time_domain;
+   /** Period of VK_TIME_DOMAIN_DEVICE_KHR */
+   uint64_t device_time_domain_period;
+
    struct list_head queues;
 
    struct {
@@ -214,11 +225,6 @@ struct vk_device {
    /* Get the device timestamp in the VK_TIME_DOMAIN_DEVICE_KHR domain */
    VkResult (*get_timestamp)(struct vk_device *device, uint64_t *timestamp);
 
-   /** Host time domain used for timestamp calibration */
-   VkTimeDomainKHR calibrate_time_domain;
-   /** Period of VK_TIME_DOMAIN_DEVICE_KHR */
-   uint64_t device_time_domain_period;
-
    /** Copies the sync payloads from the set of waits to the set of signals
     *
     * This effectively does the same as a vk_queue::driver_submit() with the
@@ -309,12 +315,6 @@ struct vk_device {
    struct hash_table *swapchain_private;
    mtx_t swapchain_name_mtx;
    struct hash_table *swapchain_name;
-
-   /* For VK_KHR_pipeline_binary */
-   bool disable_internal_cache;
-
-   struct vk_device_memory_report *memory_reports;
-   uint32_t memory_report_count;
 };
 
 VK_DEFINE_HANDLE_CASTS(vk_device, base, VkDevice,
diff --git a/src/vulkan/runtime/vk_device_generated_commands.h b/src/vulkan/runtime/vk_device_generated_commands.h
index 58c16e359ab5b..0b0180aa0c08e 100644
--- a/src/vulkan/runtime/vk_device_generated_commands.h
+++ b/src/vulkan/runtime/vk_device_generated_commands.h
@@ -62,6 +62,8 @@ struct vk_indirect_command_layout {
    /* mask of mesa_vk_dgc_types */
    uint32_t dgc_info;
 
+   uint32_t vertex_bindings;
+
    VkPipelineLayout layout;
 
    VkIndirectCommandsLayoutUsageFlagsEXT usage;
@@ -69,18 +71,16 @@ struct vk_indirect_command_layout {
 
    size_t stride;
 
-   uint32_t vertex_bindings;
-
    uint32_t ies_src_offset_B;
    bool is_shaders;
 
    bool delete_layout;
 
    bool index_mode_is_dx;
-   uint32_t index_src_offset_B;
+   bool draw_count;
 
+   uint32_t index_src_offset_B;
    uint32_t draw_src_offset_B;
-   bool draw_count;
 
    uint32_t dispatch_src_offset_B;
 
@@ -88,8 +88,8 @@ struct vk_indirect_command_layout {
 
    struct vk_indirect_command_push_constant_layout si_layout;
 
-   uint32_t n_pc_layouts;
    struct vk_indirect_command_push_constant_layout *pc_layouts;
+   uint32_t n_pc_layouts;
 
    uint32_t n_vb_layouts;
    struct vk_indirect_command_vertex_layout *vb_layouts;
diff --git a/src/vulkan/runtime/vk_graphics_state.h b/src/vulkan/runtime/vk_graphics_state.h
index 759667b64d700..2e6d62c41e713 100644
--- a/src/vulkan/runtime/vk_graphics_state.h
+++ b/src/vulkan/runtime/vk_graphics_state.h
@@ -458,12 +458,12 @@ struct vk_multisample_state {
    /** VkPipelineMultisampleStateCreateInfo::rasterizationSamples */
    VkSampleCountFlagBits rasterization_samples;
 
-   /** VkPipelineMultisampleStateCreateInfo::sampleShadingEnable */
-   bool sample_shading_enable;
-
    /** VkPipelineMultisampleStateCreateInfo::minSampleShading */
    float min_sample_shading;
 
+   /** VkPipelineMultisampleStateCreateInfo::sampleShadingEnable */
+   bool sample_shading_enable;
+
    /** VkPipelineMultisampleStateCreateInfo::pSampleMask */
    uint16_t sample_mask;
 
@@ -984,14 +984,6 @@ struct vk_graphics_pipeline_state {
 
    VkShaderStageFlags shader_stages;
 
-   /** Flags from VkGraphicsPipelineCreateInfo::flags that are considered part
-    * of a stage and need to be merged when linking libraries.
-    *
-    * For drivers which use vk_render_pass, this will also include flags
-    * generated based on subpass self-dependencies and fragment density map.
-    */
-   VkPipelineCreateFlags2KHR pipeline_flags;
-
    /* True if there are feedback loops that do not involve input attachments
     * managed by the driver. This is set to true by the runtime if there
     * are loops indicated by a pipeline flag (which may involve any image
@@ -1001,6 +993,14 @@ struct vk_graphics_pipeline_state {
     */
    bool feedback_loop_not_input_only;
 
+   /** Flags from VkGraphicsPipelineCreateInfo::flags that are considered part
+    * of a stage and need to be merged when linking libraries.
+    *
+    * For drivers which use vk_render_pass, this will also include flags
+    * generated based on subpass self-dependencies and fragment density map.
+    */
+   VkPipelineCreateFlags2KHR pipeline_flags;
+
    /** Vertex input state */
    const struct vk_vertex_input_state *vi;
 
diff --git a/src/vulkan/runtime/vk_image.h b/src/vulkan/runtime/vk_image.h
index 92689e619e299..a4406436fc56d 100644
--- a/src/vulkan/runtime/vk_image.h
+++ b/src/vulkan/runtime/vk_image.h
@@ -266,8 +266,8 @@ struct vk_image_view {
    struct vk_object_base base;
 
    VkImageViewCreateFlags create_flags;
-   struct vk_image *image;
    VkImageViewType view_type;
+   struct vk_image *image;
 
    /** VkImageViewCreateInfo::format or vk_image::format */
    VkFormat format;
diff --git a/src/vulkan/runtime/vk_instance.h b/src/vulkan/runtime/vk_instance.h
index 9cb5fa81e9a36..6d67abf109588 100644
--- a/src/vulkan/runtime/vk_instance.h
+++ b/src/vulkan/runtime/vk_instance.h
@@ -104,6 +104,15 @@ struct vk_instance {
     */
    struct vk_instance_extension_table enabled_extensions;
 
+   /** Enabled tracing modes */
+   bool trace_per_submit;
+   uint32_t trace_frame;
+   char *trace_trigger_file;
+
+   uint64_t trace_mode;
+
+   /** Whether the capture mode is per-submit. */
+
    /** Instance-level dispatch table */
    struct vk_instance_dispatch_table dispatch_table;
 
@@ -171,15 +180,6 @@ struct vk_instance {
       mtx_t mutex;
    } physical_devices;
 
-   /** Enabled tracing modes */
-   uint64_t trace_mode;
-
-   uint32_t trace_frame;
-   char *trace_trigger_file;
-
-   /** Whether the capture mode is per-submit. */
-   bool trace_per_submit;
-
    /** For triggering renderdoc captures from inside the driver. */
    simple_mtx_t renderdoc_mtx;
    RENDERDOC_API_1_0_0 *renderdoc_api;
diff --git a/src/vulkan/runtime/vk_queue.h b/src/vulkan/runtime/vk_queue.h
index 9d0042f0ce653..83905c1e7bee9 100644
--- a/src/vulkan/runtime/vk_queue.h
+++ b/src/vulkan/runtime/vk_queue.h
@@ -57,6 +57,46 @@ struct vk_queue {
    /* Which queue this is within the queue family */
    uint32_t index_in_family;
 
+   /**
+    * VK_EXT_debug_utils
+    *
+    * The next two fields represent debug labels storage.
+    *
+    * VK_EXT_debug_utils spec requires that upon triggering a debug message
+    * with a queue attached to it, all "active" labels will also be provided
+    * to the callback. The spec describes two distinct ways of attaching a
+    * debug label to the queue: opening a label region and inserting a single
+    * label.
+    *
+    * Label region is active between the corresponding `*BeginDebugUtilsLabel`
+    * and `*EndDebugUtilsLabel` calls. The spec doesn't mention any limits on
+    * nestedness of label regions. This implementation assumes that there
+    * aren't any.
+    *
+    * The spec, however, doesn't explain the lifetime of a label submitted by
+    * an `*InsertDebugUtilsLabel` call. The LunarG whitepaper [1] (pp 12-15)
+    * provides a more detailed explanation along with some examples. According
+    * to those, such label remains active until the next `*DebugUtilsLabel`
+    * call. This means that there can be no more than one such label at a
+    * time.
+    *
+    * ``labels`` contains all active labels at this point in order of
+    * submission ``region_begin`` denotes whether the most recent label opens
+    * a new region If ``labels`` is empty ``region_begin`` must be true.
+    *
+    * Anytime we modify labels, we first check for ``region_begin``. If it's
+    * false, it means that the most recent label was submitted by
+    * `*InsertDebugUtilsLabel` and we need to remove it before doing anything
+    * else.
+    *
+    * See the discussion here:
+    * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10318#note_1061317
+    *
+    * [1] https://www.lunarg.com/wp-content/uploads/2018/05/Vulkan-Debug-Utils_05_18_v1.pdf
+    */
+   bool region_begin;
+   struct util_dynarray labels;
+
    /** Driver queue submit hook
     *
     * When using the common implementation of vkQueueSubmit(), this function
@@ -88,14 +128,14 @@ struct vk_queue {
        */
       enum vk_queue_submit_mode mode;
 
+      bool thread_run;
+      thrd_t thread;
+
       mtx_t mutex;
       cnd_t push;
       cnd_t pop;
 
       struct list_head submits;
-
-      bool thread_run;
-      thrd_t thread;
    } submit;
 
    struct {
@@ -106,46 +146,6 @@ struct vk_queue {
       char error_msg[80];
    } _lost;
 
-   /**
-    * VK_EXT_debug_utils
-    *
-    * The next two fields represent debug labels storage.
-    *
-    * VK_EXT_debug_utils spec requires that upon triggering a debug message
-    * with a queue attached to it, all "active" labels will also be provided
-    * to the callback. The spec describes two distinct ways of attaching a
-    * debug label to the queue: opening a label region and inserting a single
-    * label.
-    *
-    * Label region is active between the corresponding `*BeginDebugUtilsLabel`
-    * and `*EndDebugUtilsLabel` calls. The spec doesn't mention any limits on
-    * nestedness of label regions. This implementation assumes that there
-    * aren't any.
-    *
-    * The spec, however, doesn't explain the lifetime of a label submitted by
-    * an `*InsertDebugUtilsLabel` call. The LunarG whitepaper [1] (pp 12-15)
-    * provides a more detailed explanation along with some examples. According
-    * to those, such label remains active until the next `*DebugUtilsLabel`
-    * call. This means that there can be no more than one such label at a
-    * time.
-    *
-    * ``labels`` contains all active labels at this point in order of
-    * submission ``region_begin`` denotes whether the most recent label opens
-    * a new region If ``labels`` is empty ``region_begin`` must be true.
-    *
-    * Anytime we modify labels, we first check for ``region_begin``. If it's
-    * false, it means that the most recent label was submitted by
-    * `*InsertDebugUtilsLabel` and we need to remove it before doing anything
-    * else.
-    *
-    * See the discussion here:
-    * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10318#note_1061317
-    *
-    * [1] https://www.lunarg.com/wp-content/uploads/2018/05/Vulkan-Debug-Utils_05_18_v1.pdf
-    */
-   struct util_dynarray labels;
-   bool region_begin;
-
 #ifdef VK_USE_PLATFORM_ANDROID_KHR
    /** SYNC_FD signal semaphore for vkQueueSignalReleaseImageANDROID
     *
@@ -231,6 +231,11 @@ struct vk_queue_submit {
    VkSparseImageOpaqueMemoryBindInfo *image_opaque_binds;
    VkSparseImageMemoryBindInfo *image_binds;
 
+   struct vk_sync **_wait_temps;
+   struct vk_sync_timeline_point **_wait_points;
+   struct vk_sync_timeline_point **_signal_points;
+   bool _has_binary_permanent_semaphore_wait;
+
    uint32_t perf_pass_index;
 
    /* Used internally; should be ignored by drivers */
@@ -238,11 +243,6 @@ struct vk_queue_submit {
    uint32_t _image_bind_entry_count;
    VkSparseMemoryBind *_bind_entries;
    VkSparseImageMemoryBind *_image_bind_entries;
-
-   bool _has_binary_permanent_semaphore_wait;
-   struct vk_sync **_wait_temps;
-   struct vk_sync_timeline_point **_wait_points;
-   struct vk_sync_timeline_point **_signal_points;
 };
 
 static inline bool
diff --git a/src/vulkan/runtime/vk_render_pass.h b/src/vulkan/runtime/vk_render_pass.h
index d4b477e8d0ef8..3802f5af90feb 100644
--- a/src/vulkan/runtime/vk_render_pass.h
+++ b/src/vulkan/runtime/vk_render_pass.h
@@ -82,21 +82,21 @@ struct vk_subpass {
    /** Count of all attachments referenced by this subpass */
    uint32_t attachment_count;
 
-   /** Array of all attachments referenced by this subpass */
-   struct vk_subpass_attachment *attachments;
-
    /** VkSubpassDescription2::inputAttachmentCount */
    uint32_t input_count;
 
+   /** Array of all attachments referenced by this subpass */
+   struct vk_subpass_attachment *attachments;
+
    /** VkSubpassDescription2::pInputAttachments */
    struct vk_subpass_attachment *input_attachments;
 
-   /** VkSubpassDescription2::colorAttachmentCount */
-   uint32_t color_count;
-
    /** VkSubpassDescription2::pColorAttachments */
    struct vk_subpass_attachment *color_attachments;
 
+   /** VkSubpassDescription2::colorAttachmentCount */
+   uint32_t color_count;
+
    /** VkSubpassDescription2::colorAttachmentCount or zero */
    uint32_t color_resolve_count;
 
@@ -120,6 +120,9 @@ struct vk_subpass {
     */
    uint32_t view_mask;
 
+   /** True if legacy dithering is enabled for this subpass. */
+   bool legacy_dithering_enabled;
+
    /** VkSubpassDescriptionDepthStencilResolve::depthResolveMode */
    VkResolveModeFlagBits depth_resolve_mode;
 
@@ -168,9 +171,6 @@ struct vk_subpass {
 
    /** VkMultisampledRenderToSingleSampledInfoEXT for this subpass */
    VkMultisampledRenderToSingleSampledInfoEXT mrtss;
-
-   /** True if legacy dithering is enabled for this subpass. */
-   bool legacy_dithering_enabled;
 };
 
 /***/
@@ -236,6 +236,9 @@ struct vk_subpass_dependency {
    /** VkSubpassDependency2::dstSubpass */
    uint32_t dst_subpass;
 
+   /** VkSubpassDependency2::viewOffset */
+   int32_t view_offset;
+
    /** VkSubpassDependency2::srcStageMask */
    VkPipelineStageFlags2 src_stage_mask;
 
@@ -247,9 +250,6 @@ struct vk_subpass_dependency {
 
    /** VkSubpassDependency2::dstAccessMask */
    VkAccessFlags2 dst_access_mask;
-
-   /** VkSubpassDependency2::viewOffset */
-   int32_t view_offset;
 };
 
 /***/
@@ -268,12 +268,12 @@ struct vk_render_pass {
    /** VkRenderPassCreateInfo2::attachmentCount */
    uint32_t attachment_count;
 
-   /** VkRenderPassCreateInfo2::pAttachments */
-   struct vk_render_pass_attachment *attachments;
-
    /** VkRenderPassCreateInfo2::subpassCount */
    uint32_t subpass_count;
 
+   /** VkRenderPassCreateInfo2::pAttachments */
+   struct vk_render_pass_attachment *attachments;
+
    /** VkRenderPassCreateInfo2::subpasses */
    struct vk_subpass *subpasses;
 
diff --git a/src/vulkan/runtime/vk_texcompress_astc.h b/src/vulkan/runtime/vk_texcompress_astc.h
index ca57e2cb5d0fd..8da2d8c1f8232 100644
--- a/src/vulkan/runtime/vk_texcompress_astc.h
+++ b/src/vulkan/runtime/vk_texcompress_astc.h
@@ -44,10 +44,10 @@ struct vk_texcompress_astc_state {
    VkBufferView partition_tbl_buf_view[VK_TEXCOMPRESS_ASTC_NUM_PARTITION_TABLES];
 
    simple_mtx_t mutex;
+   uint32_t pipeline_mask;
+   VkPipeline pipeline[VK_TEXCOMPRESS_ASTC_NUM_PARTITION_TABLES];
    VkDescriptorSetLayout ds_layout;
    VkPipelineLayout p_layout;
-   VkPipeline pipeline[VK_TEXCOMPRESS_ASTC_NUM_PARTITION_TABLES];
-   uint32_t pipeline_mask;
    VkShaderModule shader_module;
 };
 
-- 
GitLab


From 6c5fc6de37f434d70708172a54473f3435ad9fe6 Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Wed, 24 Sep 2025 10:55:31 +0300
Subject: [PATCH 07/31] glx: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/glx/glxclient.h  | 32 ++++++++++++++++----------------
 src/glx/glxcurrent.c |  2 +-
 2 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index 678c98f380dce..51df40393e6b5 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -266,6 +266,12 @@ struct glx_context
    GLint bufSize;
    /*@} */
 
+   /**
+    * \c GL_TRUE if the context was created with ImportContext, which
+    * means the server-side context was created by another X client.
+    */
+   GLboolean imported;
+
    const struct glx_context_vtable *vtable;
 
     /**
@@ -283,12 +289,6 @@ struct glx_context
 
    struct glx_screen *psc;
 
-    /**
-     * \c GL_TRUE if the context was created with ImportContext, which
-     * means the server-side context was created by another X client.
-     */
-   GLboolean imported;
-
     /**
      * The context tag returned by MakeCurrent when this context is made
      * current. This tag is used to identify the context that a thread has
@@ -561,6 +561,16 @@ struct glx_display
 
    enum glx_driver driver;
 
+   /**
+    * \name Minor Version
+    *
+    * Minor version returned by the server during initialization. The major
+    * version is asserted to be 1 during extension setup.
+    */
+   /*@{ */
+   int minorVersion;
+   /*@} */
+
    /* The extension protocol codes */
    XExtCodes codes;
 
@@ -569,16 +579,6 @@ struct glx_display
      */
    Display *dpy;
 
-    /**
-     * \name Minor Version
-     *
-     * Minor version returned by the server during initialization. The major
-     * version is asserted to be 1 during extension setup.
-     */
-   /*@{ */
-   int minorVersion;
-   /*@} */
-
     /**
      * Configurations of visuals for all screens on this display.
      * Also, per screen data which now includes the server \c GLX_EXTENSION
diff --git a/src/glx/glxcurrent.c b/src/glx/glxcurrent.c
index 1a653c2a929f6..76f3920fa43e7 100644
--- a/src/glx/glxcurrent.c
+++ b/src/glx/glxcurrent.c
@@ -35,7 +35,7 @@ struct glx_context dummyContext = {
    &dummyBuffer[0],
    &dummyBuffer[__GLX_BUFFER_LIMIT_SIZE],
    sizeof(dummyBuffer),
-   &dummyVtable
+   .vtable = &dummyVtable
 };
 
 /*
-- 
GitLab


From f69447ebb0ad506255b37f8c6b4bc8f9ce13323d Mon Sep 17 00:00:00 2001
From: GermanAizek <GermanAizek@yandex.ru>
Date: Wed, 24 Sep 2025 10:58:27 +0300
Subject: [PATCH 08/31] compiler: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/compiler/glsl/glsl_parser_extras.h | 99 +++++++++++++-------------
 src/compiler/nir/nir.h                 |  6 +-
 2 files changed, 53 insertions(+), 52 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 8618e9db62242..f1cf5e93e42c9 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3322,15 +3322,15 @@ typedef struct nir_loop_info {
    /* Estimated cost (in number of instructions) of the loop */
    unsigned instr_cost;
 
-   /* Contains fp64 ops that will be lowered */
-   bool has_soft_fp64;
-
    /* Guessed trip count based on array indexing */
    unsigned guessed_trip_count;
 
    /* Maximum number of times the loop is run (if known) */
    unsigned max_trip_count;
 
+   /* Contains fp64 ops that will be lowered */
+   bool has_soft_fp64;
+
    /* Do we know the exact number of times the loop will be run */
    bool exact_trip_count_known;
 
-- 
GitLab


From 60cf4df4856fc0c6539a5808c0c76a2665ff6a59 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Sat, 27 Sep 2025 01:23:41 +0300
Subject: [PATCH 09/31] mesa[2]: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

References:
    https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-presentation.pdf
    https://hpc.rz.rptu.de/Tutorials/AVX/alignment.shtml
    https://en.wikipedia.org/wiki/Data_structure_alignment
    https://stackoverflow.com/a/20882083
    https://zijishi.xyz/post/optimization-technique/learning-to-use-data-alignment/
---
 src/mesa/main/consts_exts.h  | 139 ++++++++++++-----------
 src/mesa/main/glspirv.h      |   8 +-
 src/mesa/main/mtypes.h       | 207 ++++++++++++++++++-----------------
 src/mesa/main/shader_types.h |  60 +++++-----
 4 files changed, 208 insertions(+), 206 deletions(-)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 219b163d89593..45273edee517c 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -438,6 +438,8 @@ struct gl_constants
    } ViewportBounds;                         /**< GL_ARB_viewport_array */
    GLuint MaxWindowRectangles;               /**< GL_EXT_window_rectangles */
 
+   GLuint MaxDrawBuffers;    /**< GL_ARB_draw_buffers */
+
    struct gl_program_constants Program[MESA_SHADER_MESH_STAGES];
    GLuint MaxProgramMatrices;
    GLuint MaxProgramMatrixStackDepth;
@@ -464,8 +466,6 @@ struct gl_constants
       GLuint MeshPrimitivesGenerated;
    } QueryCounterBits;
 
-   GLuint MaxDrawBuffers;    /**< GL_ARB_draw_buffers */
-
    GLuint MaxColorAttachments;   /**< GL_EXT_framebuffer_object */
    GLuint MaxRenderbufferSize;   /**< GL_EXT_framebuffer_object */
    GLuint MaxSamples;            /**< GL_ARB_framebuffer_object */
@@ -524,12 +524,6 @@ struct gl_constants
     */
    GLboolean ForceCompatShaders;
 
-   /**
-    * If non-zero, forces GLSL shaders to behave as if they began
-    * with "#version ForceGLSLVersion".
-    */
-   GLuint ForceGLSLVersion;
-
    /**
     * Allow GLSL #extension directives in the middle of shaders.
     */
@@ -540,6 +534,12 @@ struct gl_constants
     */
    GLboolean AllowGLSL120SubsetIn110;
 
+   /**
+    * If non-zero, forces GLSL shaders to behave as if they began
+    * with "#version ForceGLSLVersion".
+    */
+   GLuint ForceGLSLVersion;
+
    /**
     * Allow builtins as part of constant expressions. This was not allowed
     * until GLSL 1.20 this allows it everywhere.
@@ -630,6 +630,9 @@ struct gl_constants
     */
    GLboolean NativeIntegers;
 
+   /** GL_ARB_viewport_array */
+   GLenum16 LayerAndVPIndexProvokingVertex;
+
    /**
     * If the driver supports real 32-bit integers, what integer value should be
     * used for boolean true in uniform uploads?  (Usually 1 or ~0.)
@@ -641,12 +644,6 @@ struct gl_constants
     */
    GLuint64 MaxServerWaitTimeout;
 
-   /** GL_EXT_provoking_vertex */
-   GLboolean QuadsFollowProvokingVertexConvention;
-
-   /** GL_ARB_viewport_array */
-   GLenum16 LayerAndVPIndexProvokingVertex;
-
    /** OpenGL version 3.0 */
    GLbitfield ContextFlags;  /**< Ex: GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT */
 
@@ -676,6 +673,9 @@ struct gl_constants
    /* GL_KHR_robustness */
    GLboolean RobustAccess;
 
+   /** GL_EXT_provoking_vertex */
+   GLboolean QuadsFollowProvokingVertexConvention;
+
    /* GL_ARB_blend_func_extended */
    GLuint MaxDualSourceDrawBuffers;
 
@@ -708,9 +708,6 @@ struct gl_constants
     */
    bool GLSLTessLevelsAsInputs;
 
-   /** GL_ARB_map_buffer_alignment */
-   GLuint MinMapBufferAlignment;
-
    /**
     * Disable varying packing.  This is out of spec, but potentially useful
     * for older platforms that supports a limited number of texture
@@ -722,6 +719,9 @@ struct gl_constants
     */
    GLboolean DisableVaryingPacking;
 
+   /** GL_ARB_map_buffer_alignment */
+   GLuint MinMapBufferAlignment;
+
    /**
     * Disable varying packing if used for transform feedback.  This is needed
     * for some drivers (e.g. Panfrost) where transform feedback requires
@@ -736,11 +736,6 @@ struct gl_constants
     */
    bool DisableUniformArrayResize;
 
-   /**
-    * Alias extension e.g. GL_ATI_shader_texture_lod to GL_ARB_shader_texture_lod.
-    */
-   char *AliasShaderExtension;
-
    /**
     * Allow fs-only bias argument in vertex shaders.
     */
@@ -753,28 +748,10 @@ struct gl_constants
     */
    GLboolean PreferPOTAlignedVaryings;
 
-
-   /**
-    * UBOs and SSBOs can be packed tightly by the OpenGL implementation when
-    * layout is set as shared (the default) or packed. However most Mesa drivers
-    * just use STD140 for these layouts. This flag allows drivers to use STD430
-    * for packed and shared layouts which allows arrays to be packed more
-    * tightly.
-    */
-   bool UseSTD430AsDefaultPacking;
-
    /**
-    * Should meaningful names be generated for compiler temporary variables?
-    *
-    * Generally, it is not useful to have the compiler generate "meaningful"
-    * names for temporary variables that it creates.  This can, however, be a
-    * useful debugging aid.  In Mesa debug builds or release builds when
-    * MESA_GLSL is set at run-time, meaningful names will be generated.
-    * Drivers can also force names to be generated by setting this field.
-    * For example, the i965 driver may set it when INTEL_DEBUG=vs (to dump
-    * vertex shader assembly) is set at run-time.
+    * Alias extension e.g. GL_ATI_shader_texture_lod to GL_ARB_shader_texture_lod.
     */
-   bool GenerateTemporaryNames;
+   char *AliasShaderExtension;
 
    /*
     * Maximum value supported for an index in DrawElements and friends.
@@ -843,11 +820,33 @@ struct gl_constants
    GLfloat MinFragmentInterpolationOffset;
    GLfloat MaxFragmentInterpolationOffset;
 
-   GLboolean FakeSWMSAA;
+   /**
+    * UBOs and SSBOs can be packed tightly by the OpenGL implementation when
+    * layout is set as shared (the default) or packed. However most Mesa drivers
+    * just use STD140 for these layouts. This flag allows drivers to use STD430
+    * for packed and shared layouts which allows arrays to be packed more
+    * tightly.
+    */
+   bool UseSTD430AsDefaultPacking;
+
+   /**
+    * Should meaningful names be generated for compiler temporary variables?
+    *
+    * Generally, it is not useful to have the compiler generate "meaningful"
+    * names for temporary variables that it creates.  This can, however, be a
+    * useful debugging aid.  In Mesa debug builds or release builds when
+    * MESA_GLSL is set at run-time, meaningful names will be generated.
+    * Drivers can also force names to be generated by setting this field.
+    * For example, the i965 driver may set it when INTEL_DEBUG=vs (to dump
+    * vertex shader assembly) is set at run-time.
+    */
+   bool GenerateTemporaryNames;
 
    /** GL_KHR_context_flush_control */
    GLenum16 ContextReleaseBehavior;
 
+   GLboolean FakeSWMSAA;
+
    /** (driconf) Force gl_Position to be considered invariant */
    GLboolean VSPositionAlwaysInvariant;
 
@@ -855,11 +854,11 @@ struct gl_constants
    GLboolean TESPositionAlwaysPrecise;
 
    /** GL_ARB_tessellation_shader */
+   bool PrimitiveRestartForPatches;
    GLuint MaxPatchVertices;
    GLuint MaxTessGenLevel;
    GLuint MaxTessPatchComponents;
    GLuint MaxTessControlTotalOutputComponents;
-   bool PrimitiveRestartForPatches;
 
    /** GL_OES_primitive_bounding_box */
    bool NoPrimitiveBoundingBoxOutput;
@@ -870,15 +869,6 @@ struct gl_constants
    /** Used as an input for sha1 generation in the on-disk shader cache */
    unsigned char *dri_config_options_sha1;
 
-   /** When drivers are OK with mapped buffers during draw and other calls. */
-   bool AllowMappedBuffersDuringExecution;
-
-   /** Override GL_MAP_UNSYNCHRONIZED_BIT */
-   bool ForceMapBufferSynchronized;
-
-   /** Override GL_DEPTH_COMPONENT type from unsigned short to unsigned int */
-   bool ForceDepthComponentTypeInt;
-
    /** GL_ARB_get_program_binary */
    GLuint NumProgramBinaryFormats;
 
@@ -892,6 +882,15 @@ struct gl_constants
    GLfloat ConservativeRasterDilateRange[2];
    GLfloat ConservativeRasterDilateGranularity;
 
+   /** When drivers are OK with mapped buffers during draw and other calls. */
+   bool AllowMappedBuffersDuringExecution;
+
+   /** Override GL_MAP_UNSYNCHRONIZED_BIT */
+   bool ForceMapBufferSynchronized;
+
+   /** Override GL_DEPTH_COMPONENT type from unsigned short to unsigned int */
+   bool ForceDepthComponentTypeInt;
+
    /** Is the drivers uniform storage packed or padded to 16 bytes. */
    bool PackedDriverUniformStorage;
 
@@ -914,13 +913,6 @@ struct gl_constants
     */
    bool UseVAOFastPath;
 
-   /** Whether the driver can support primitive restart with a fixed index.
-    * This is essentially a subset of NV_primitive_restart with enough support
-    * to be able to enable GLES 3.1. Some hardware can support this but not the
-    * full NV extension with arbitrary restart indices.
-    */
-   bool PrimitiveRestartFixedIndex;
-
    /** GL_ARB_spirv_extensions */
    struct spirv_supported_extensions *SpirVExtensions;
 
@@ -930,6 +922,19 @@ struct gl_constants
    /** Buffer size used to upload vertices from glBegin/glEnd. */
    unsigned glBeginEndBufferSize;
 
+   /** GL_ARB_sparse_texture */
+   GLuint MaxSparseTextureSize;
+   GLuint MaxSparse3DTextureSize;
+   GLuint MaxSparseArrayTextureLayers;
+   bool SparseTextureFullArrayCubeMipmaps;
+
+   /** Whether the driver can support primitive restart with a fixed index.
+    * This is essentially a subset of NV_primitive_restart with enough support
+    * to be able to enable GLES 3.1. Some hardware can support this but not the
+    * full NV extension with arbitrary restart indices.
+    */
+   bool PrimitiveRestartFixedIndex;
+
    /** Whether the driver doesn't want x/y/width/height clipped based on src size
     *  when doing a copy texture operation (eg: may want out-of-bounds reads that
     *  produce 0 instead of leaving the texture content undefined).
@@ -943,12 +948,6 @@ struct gl_constants
     */
    bool GLThreadNopCheckFramebufferStatus;
 
-   /** GL_ARB_sparse_texture */
-   GLuint MaxSparseTextureSize;
-   GLuint MaxSparse3DTextureSize;
-   GLuint MaxSparseArrayTextureLayers;
-   bool SparseTextureFullArrayCubeMipmaps;
-
    /** Use hardware accelerated GL_SELECT */
    bool HardwareAcceleratedSelect;
 
@@ -958,14 +957,14 @@ struct gl_constants
    /** Whether pipe_context::draw_vertex_state is supported. */
    bool HasDrawVertexState;
 
-   /* NV_timeline_semaphore */
-   GLuint64 MaxTimelineSemaphoreValueDifference;
-
    /** GL_KHR_shader_subgroup */
+   bool ShaderSubgroupQuadAllStages;
    GLuint ShaderSubgroupSize;
    GLuint ShaderSubgroupSupportedStages;
    GLuint ShaderSubgroupSupportedFeatures;
-   bool ShaderSubgroupQuadAllStages;
+
+   /* NV_timeline_semaphore */
+   GLuint64 MaxTimelineSemaphoreValueDifference;
 };
 
 #endif
diff --git a/src/mesa/main/glspirv.h b/src/mesa/main/glspirv.h
index 734f3b3c34d6f..59b3882e2ee9e 100644
--- a/src/mesa/main/glspirv.h
+++ b/src/mesa/main/glspirv.h
@@ -59,13 +59,13 @@ struct gl_spirv_module {
 struct gl_shader_spirv_data {
    GLint RefCount;
 
-   struct gl_spirv_module *SpirVModule;
-
-   GLchar *SpirVEntryPoint;
-
    GLuint NumSpecializationConstants;
    GLuint *SpecializationConstantsIndex;
    GLuint *SpecializationConstantsValue;
+
+   struct gl_spirv_module *SpirVModule;
+
+   GLchar *SpirVEntryPoint;
 };
 
 void
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 9d2839add9097..4aed0233ae4b4 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -246,6 +246,8 @@ struct gl_colorbuffer_attrib
 
    GLenum16 DrawBuffer[MAX_DRAW_BUFFERS];  /**< Which buffer to draw into */
 
+   GLboolean sRGBEnabled;  /**< Framebuffer sRGB blending/updating requested */
+
    /**
     * \name alpha testing
     */
@@ -280,11 +282,6 @@ struct gl_colorbuffer_attrib
    } Blend[MAX_DRAW_BUFFERS];
    /** Bitfield of color buffers with enabled dual source blending. */
    GLbitfield _BlendUsesDualSrc;
-   /** Are the blend func terms currently different for each buffer/target? */
-   GLboolean _BlendFuncPerBuffer;
-   /** Are the blend equations currently different for each buffer/target? */
-   GLboolean _BlendEquationPerBuffer;
-
    /**
     * Which advanced blending mode is in use (or BLEND_NONE).
     *
@@ -293,6 +290,10 @@ struct gl_colorbuffer_attrib
     * requires all draw buffers to match, so we only need a single value.
     */
    enum gl_advanced_blend_mode _AdvancedBlendMode;
+   /** Are the blend func terms currently different for each buffer/target? */
+   GLboolean _BlendFuncPerBuffer;
+   /** Are the blend equations currently different for each buffer/target? */
+   GLboolean _BlendEquationPerBuffer;
 
    /** Coherency requested via glEnable(GL_BLEND_ADVANCED_COHERENT_KHR)? */
    bool BlendCoherent;
@@ -313,8 +314,6 @@ struct gl_colorbuffer_attrib
    GLboolean _ClampFragmentColor;  /** < with GL_FIXED_ONLY_ARB resolved */
    GLenum16 ClampFragmentColor; /**< GL_TRUE, GL_FALSE or GL_FIXED_ONLY_ARB */
    GLenum16 ClampReadColor;     /**< GL_TRUE, GL_FALSE or GL_FIXED_ONLY_ARB */
-
-   GLboolean sRGBEnabled;  /**< Framebuffer sRGB blending/updating requested */
 };
 
 /**
@@ -360,8 +359,8 @@ struct gl_current_attrib
  */
 struct gl_depthbuffer_attrib
 {
-   GLenum16 Func;		/**< Function for depth buffer compare */
    GLclampd Clear;		/**< Value to clear depth buffer to */
+   GLenum16 Func;		/**< Function for depth buffer compare */
    GLboolean Test;		/**< Depth buffering enabled flag */
    GLboolean Mask;		/**< Depth buffer writable? */
    GLboolean BoundsTest;        /**< GL_EXT_depth_bounds_test */
@@ -660,19 +659,19 @@ struct gl_point_attrib
  */
 struct gl_polygon_attrib
 {
+   GLenum16 CullFaceMode;	/**< Culling mode GL_FRONT or GL_BACK */
    GLenum16 FrontFace;		/**< Either GL_CW or GL_CCW */
    GLenum FrontMode;		/**< Either GL_POINT, GL_LINE or GL_FILL */
    GLenum BackMode;		/**< Either GL_POINT, GL_LINE or GL_FILL */
    GLboolean CullFlag;		/**< Culling on/off flag */
    GLboolean SmoothFlag;	/**< True if GL_POLYGON_SMOOTH is enabled */
    GLboolean StippleFlag;	/**< True if GL_POLYGON_STIPPLE is enabled */
-   GLenum16 CullFaceMode;	/**< Culling mode GL_FRONT or GL_BACK */
-   GLfloat OffsetFactor;	/**< Polygon offset factor, from user */
-   GLfloat OffsetUnits;		/**< Polygon offset units, from user */
-   GLfloat OffsetClamp;		/**< Polygon offset clamp, from user */
    GLboolean OffsetPoint;	/**< Offset in GL_POINT mode */
    GLboolean OffsetLine;	/**< Offset in GL_LINE mode */
    GLboolean OffsetFill;	/**< Offset in GL_FILL mode */
+   GLfloat OffsetFactor;	/**< Polygon offset factor, from user */
+   GLfloat OffsetUnits;		/**< Polygon offset units, from user */
+   GLfloat OffsetClamp;		/**< Polygon offset clamp, from user */
 };
 
 
@@ -755,13 +754,23 @@ struct gl_stencil_attrib
 struct gl_texture_image
 {
    GLint InternalFormat;	/**< Internal format as given by the user */
+   mesa_format TexFormat;         /**< The actual texture memory format */
    GLenum16 _BaseFormat;	/**< Either GL_RGB, GL_RGBA, GL_ALPHA,
                                  *   GL_LUMINANCE, GL_LUMINANCE_ALPHA,
                                  *   GL_INTENSITY, GL_DEPTH_COMPONENT or
                                  *   GL_DEPTH_STENCIL_EXT only. Used for
                                  *   choosing TexEnv arithmetic.
                                  */
-   mesa_format TexFormat;         /**< The actual texture memory format */
+
+   /** GL_ARB_texture_multisample */
+   GLboolean FixedSampleLocations; /**< Same sample locations for all pixels? */
+   GLuint NumSamples;            /**< Sample count, or 0 for non-multisample */
+
+   /* List of transfers, allocated on demand.
+    * transfer[layer] is a mapping for that layer.
+    */
+   unsigned num_transfers;
+   struct st_texture_image_transfer *transfer;
 
    GLuint Border;		/**< 0 or 1 */
    GLuint Width;
@@ -781,21 +790,11 @@ struct gl_texture_image
    unsigned FormatSwizzle;
    unsigned FormatSwizzleGLSL130; //for depth formats
 
-   /** GL_ARB_texture_multisample */
-   GLuint NumSamples;            /**< Sample count, or 0 for non-multisample */
-   GLboolean FixedSampleLocations; /**< Same sample locations for all pixels? */
-
    /* If stImage->pt != NULL, image data is stored here.
     * Else there is no image data.
     */
    struct pipe_resource *pt;
 
-   /* List of transfers, allocated on demand.
-    * transfer[layer] is a mapping for that layer.
-    */
-   struct st_texture_image_transfer *transfer;
-   unsigned num_transfers;
-
    /* For compressed images unsupported by the driver. Keep track of
     * the original data. This is necessary for mapping/unmapping,
     * as well as image copies.
@@ -916,19 +915,21 @@ struct gl_texture_object
 {
    GLint RefCount;             /**< reference count */
    GLuint Name;                /**< the user-visible texture object ID */
-   GLenum16 Target;            /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
    GLchar *Label;              /**< GL_KHR_debug */
+   GLenum16 Target;            /**< GL_TEXTURE_1D, GL_TEXTURE_2D, etc. */
+
+   GLboolean _BaseComplete;    /**< Is the base texture level valid? */
+   GLboolean _MipmapComplete;  /**< Is the whole mipmap valid? */
+
+   gl_texture_index TargetIndex; /**< The gl_texture_unit::CurrentTex index.
+                                   Only valid when Target is valid. */
 
    struct gl_sampler_object Sampler;
    struct gl_texture_object_attrib Attrib;  /**< State saved by glPushAttrib */
 
-   gl_texture_index TargetIndex; /**< The gl_texture_unit::CurrentTex index.
-                                      Only valid when Target is valid. */
-   GLbyte _MaxLevel;           /**< actual max mipmap level (q in the spec) */
-   GLfloat _MaxLambda;         /**< = _MaxLevel - BaseLevel (q - p in spec) */
    GLint CropRect[4];          /**< GL_OES_draw_texture */
-   GLboolean _BaseComplete;    /**< Is the base texture level valid? */
-   GLboolean _MipmapComplete;  /**< Is the whole mipmap valid? */
+   GLfloat _MaxLambda;         /**< = _MaxLevel - BaseLevel (q - p in spec) */
+   GLbyte _MaxLevel;           /**< actual max mipmap level (q in the spec) */
    GLboolean _IsIntegerFormat; /**< Does the texture store integer values? */
    GLboolean _RenderToTexture; /**< Any rendering to this texture? */
    GLboolean Immutable;        /**< GL_ARB_texture_storage */
@@ -953,6 +954,10 @@ struct gl_texture_object
    GLenum16 BufferObjectFormat;
    /** Equivalent Mesa format for BufferObjectFormat. */
    mesa_format _BufferObjectFormat;
+
+   /** GL_EXT_texture_storage_compression */
+   GLint CompressionRate; /**< Fixed-rate compression bitrate */
+
    /* TODO: BufferObject->Name should be restored by glPopAttrib(GL_TEXTURE_BIT); */
    struct gl_buffer_object *BufferObject;
 
@@ -967,17 +972,14 @@ struct gl_texture_object
    struct util_dynarray SamplerHandles;
    struct util_dynarray ImageHandles;
 
+   /** GL_EXT_texture_compression_astc_decode_mode */
+   GLenum16 AstcDecodePrecision; /**< ASTC decoding precision */
+
    /** GL_ARB_sparse_texture */
    GLboolean IsSparse;
    GLint VirtualPageSizeIndex;
    GLint NumSparseLevels;
 
-   /** GL_EXT_texture_storage_compression */
-   GLint CompressionRate; /**< Fixed-rate compression bitrate */
-
-   /** GL_EXT_texture_compression_astc_decode_mode */
-   GLenum16 AstcDecodePrecision; /**< ASTC decoding precision */
-
    /* The texture must include at levels [0..lastLevel] once validated:
     */
    GLuint lastLevel;
@@ -988,14 +990,19 @@ struct gl_texture_object
    unsigned int validated_first_level;
    unsigned int validated_last_level;
 
+   /* Protect modifications of the sampler_views array */
+   simple_mtx_t validate_mutex;
+
+   /* If surface_based is true, this format should be used for all sampler
+    * views and surfaces instead of pt->format.
+    */
+   enum pipe_format surface_format;
+
    /* On validation any active images held in main memory or in other
     * textures will be copied to this texture and the old storage freed.
     */
    struct pipe_resource *pt;
 
-   /* Protect modifications of the sampler_views array */
-   simple_mtx_t validate_mutex;
-
    /* Container of sampler views (one per context) attached to this texture
     * object. Created lazily on first binding in context.
     *
@@ -1022,22 +1029,25 @@ struct gl_texture_object
     */
    struct st_sampler_views *sampler_views_old;
 
+   /* If surface_based is true and surface_format is a YUV format, these
+    * settings should be used to convert from YUV to RGB.
+    */
+   enum gl_texture_yuv_color_space yuv_color_space;
+   bool yuv_full_range;
+
    /* True if this texture comes from the window system. Such a texture
     * cannot be reallocated and the format can only be changed with a sampler
     * view or a surface.
     */
    GLboolean surface_based;
 
-   /* If surface_based is true, this format should be used for all sampler
-    * views and surfaces instead of pt->format.
+   /**
+    * Set when the texture images of this texture object might not all be in
+    * the pipe_resource *pt above.
     */
-   enum pipe_format surface_format;
+   bool needs_validation;
 
-   /* If surface_based is true and surface_format is a YUV format, these
-    * settings should be used to convert from YUV to RGB.
-    */
-   enum gl_texture_yuv_color_space yuv_color_space;
-   bool yuv_full_range;
+   GLboolean IsProtected;
 
    /* When non-negative, samplers should use this level instead of the level
     * range specified by the GL state.
@@ -1055,14 +1065,6 @@ struct gl_texture_object
     * describes one non-array texture per field.
     */
    int layer_override;
-
-    /**
-     * Set when the texture images of this texture object might not all be in
-     * the pipe_resource *pt above.
-     */
-    bool needs_validation;
-
-    GLboolean IsProtected;
 };
 
 
@@ -1348,11 +1350,11 @@ typedef GLfloat gl_clip_plane[4];
 struct gl_transform_attrib
 {
    GLenum16 MatrixMode;				/**< Matrix mode */
+   GLboolean Normalize;				/**< Normalize all normals? */
+   GLboolean RescaleNormals;			/**< GL_EXT_rescale_normal */
    gl_clip_plane EyeUserPlane[MAX_CLIP_PLANES];	/**< User clip planes */
    gl_clip_plane _ClipUserPlane[MAX_CLIP_PLANES]; /**< derived */
    GLbitfield ClipPlanesEnabled;                /**< on/off bitmask */
-   GLboolean Normalize;				/**< Normalize all normals? */
-   GLboolean RescaleNormals;			/**< GL_EXT_rescale_normal */
    GLboolean RasterPositionUnclipped;           /**< GL_IBM_rasterpos_clip */
    GLboolean DepthClampNear;			/**< GL_AMD_depth_clamp_separate */
    GLboolean DepthClampFar;			/**< GL_AMD_depth_clamp_separate */
@@ -1596,6 +1598,12 @@ struct gl_vertex_array_object
 
    GLchar *Label;       /**< GL_KHR_debug */
 
+   /** Vertex attribute arrays */
+   struct gl_array_attributes VertexAttrib[VERT_ATTRIB_MAX];
+
+   /** Vertex buffer bindings */
+   struct gl_vertex_buffer_binding BufferBinding[VERT_ATTRIB_MAX];
+
    /**
     * Has this array object been bound?
     */
@@ -1608,12 +1616,6 @@ struct gl_vertex_array_object
     */
    bool SharedAndImmutable;
 
-   /** Vertex attribute arrays */
-   struct gl_array_attributes VertexAttrib[VERT_ATTRIB_MAX];
-
-   /** Vertex buffer bindings */
-   struct gl_vertex_buffer_binding BufferBinding[VERT_ATTRIB_MAX];
-
    /** Mask indicating which vertex arrays have vertex buffer associated. */
    GLbitfield VertexAttribBufferMask;
 
@@ -1669,6 +1671,17 @@ struct gl_array_attrib
    /** Array objects (GL_ARB_vertex_array_object) */
    struct _mesa_HashTable Objects;
 
+   /* GL_ARB_vertex_buffer_object */
+   struct gl_buffer_object *ArrayBufferObj;
+
+   /**
+    * Vertex array object that is used with the currently active draw command.
+    * The _DrawVAO is either set to the currently bound VAO for array type
+    * draws or to internal VAO's set up by the vbo module to execute immediate
+    * mode or display list draws.
+    */
+   struct gl_vertex_array_object *_DrawVAO;
+
    GLint ActiveTexture;		/**< Client Active Texture */
    GLuint LockFirst;            /**< GL_EXT_compiled_vertex_array */
    GLuint LockCount;            /**< GL_EXT_compiled_vertex_array */
@@ -1680,24 +1693,13 @@ struct gl_array_attrib
     * \c PrimitiveRestartFixedIndex is set.
     */
    /*@{*/
-   GLboolean PrimitiveRestart;
    GLboolean PrimitiveRestartFixedIndex;
    GLboolean _PrimitiveRestart[3]; /**< Enable indexed by index_size_shift. */
    GLuint RestartIndex;
    GLuint _RestartIndex[3]; /**< Restart indices indexed by index_size_shift. */
+   GLboolean PrimitiveRestart;
    /*@}*/
 
-   /* GL_ARB_vertex_buffer_object */
-   struct gl_buffer_object *ArrayBufferObj;
-
-   /**
-    * Vertex array object that is used with the currently active draw command.
-    * The _DrawVAO is either set to the currently bound VAO for array type
-    * draws or to internal VAO's set up by the vbo module to execute immediate
-    * mode or display list draws.
-    */
-   struct gl_vertex_array_object *_DrawVAO;
-
    /**
     * Whether per-vertex edge flags are enabled and should be processed by
     * the vertex shader.
@@ -1750,18 +1752,18 @@ struct gl_selection
    GLuint Hits;		/**< number of records in the selection buffer */
    GLuint NameStackDepth; /**< name stack depth */
    GLuint NameStack[MAX_NAME_STACK_DEPTH]; /**< name stack */
-   GLboolean HitFlag;	/**< hit flag */
    GLfloat HitMinZ;	/**< minimum hit depth */
    GLfloat HitMaxZ;	/**< maximum hit depth */
+   GLboolean HitFlag;	/**< hit flag */
+
+   GLboolean ResultUsed;    /**< whether any draw used result buffer */
+   GLuint ResultOffset;     /**< offset into result buffer */
+   struct gl_buffer_object *Result; /**< result buffer */
 
    /* HW GL_SELECT */
    void *SaveBuffer;        /**< array holds multi stack data */
    GLuint SaveBufferTail;   /**< offset to SaveBuffer's tail */
    GLuint SavedStackNum;    /**< number of saved stacks */
-
-   GLboolean ResultUsed;    /**< whether any draw used result buffer */
-   GLuint ResultOffset;     /**< offset into result buffer */
-   struct gl_buffer_object *Result; /**< result buffer */
 };
 
 
@@ -1862,6 +1864,9 @@ struct gl_transform_feedback_object
     */
    unsigned GlesRemainingPrims;
 
+   unsigned num_targets;
+   struct pipe_stream_output_target *targets[PIPE_MAX_SO_BUFFERS];
+
    /**
     * The program active when BeginTransformFeedback() was called.
     * When active and unpaused, this equals ctx->Shader.CurrentProgram[stage],
@@ -1890,9 +1895,6 @@ struct gl_transform_feedback_object
     */
    GLsizeiptr RequestedSize[MAX_FEEDBACK_BUFFERS];
 
-   unsigned num_targets;
-   struct pipe_stream_output_target *targets[PIPE_MAX_SO_BUFFERS];
-
    /* This encapsulates the count that can be used as a source for draw_vbo.
     * It contains stream output targets from the last call of
     * EndTransformFeedback for each stream. */
@@ -2410,6 +2412,21 @@ struct gl_shared_state
    GLint RefCount;			   /**< Reference count */
    bool DisplayListsAffectGLThread;
 
+   /**
+    * Whether at least one image has been imported or exported, excluding
+    * the default framebuffer. If this is false, glFlush can be executed
+    * asynchronously because there is no invisible dependency on external
+    * users.
+    */
+   bool HasExternallySharedImages;
+
+   /* GL_ARB_shading_language_include */
+   /* glCompileShaderInclude expects ShaderIncludes not to change while it is
+    * in progress.
+    */
+   simple_mtx_t ShaderIncludeMutex;
+   struct shader_includes *ShaderIncludes;
+
    struct list_head Contexts;   /**< gl_context objects */
    struct set ReleaseResources; /**< in use by some context */
 
@@ -2479,27 +2496,12 @@ struct gl_shared_state
    struct hash_table_u64 *ImageHandles;
    mtx_t HandlesMutex; /**< For texture/image handles safety */
 
-   /* GL_ARB_shading_language_include */
-   struct shader_includes *ShaderIncludes;
-   /* glCompileShaderInclude expects ShaderIncludes not to change while it is
-    * in progress.
-    */
-   simple_mtx_t ShaderIncludeMutex;
-
    /** EXT_external_objects */
    struct _mesa_HashTable MemoryObjects;
 
    /** EXT_semaphore */
    struct _mesa_HashTable SemaphoreObjects;
 
-   /**
-    * Whether at least one image has been imported or exported, excluding
-    * the default framebuffer. If this is false, glFlush can be executed
-    * asynchronously because there is no invisible dependency on external
-    * users.
-    */
-   bool HasExternallySharedImages;
-
    /* Small display list storage */
    struct {
       union gl_dlist_node *ptr;
@@ -2533,8 +2535,8 @@ struct gl_shared_state
  */
 struct gl_renderbuffer
 {
-   GLuint Name;
    GLchar *Label;         /**< GL_KHR_debug */
+   GLuint Name;
    GLint RefCount;
    GLuint Width, Height;
    GLuint Depth;
@@ -2567,22 +2569,23 @@ struct gl_renderbuffer
    enum pipe_format format_linear;
    enum pipe_format format_srgb;
    struct pipe_surface surface;
-   GLboolean defined;        /**< defined contents? */
 
    struct pipe_transfer *transfer; /**< only used when mapping the resource */
 
    /**
     * Used only when hardware accumulation buffers are not supported.
     */
-   bool software;
    void *data;
+   bool software;
+
+   GLboolean defined;        /**< defined contents? */
 
    bool use_readpix_cache;
 
    /* Inputs from Driver.RenderTexture, don't use directly. */
    bool is_rtt; /**< whether Driver.RenderTexture was called */
-   unsigned rtt_face, rtt_slice;
    bool rtt_layered; /**< whether glFramebufferTexture was called */
+   unsigned rtt_face, rtt_slice;
    unsigned rtt_nr_samples; /**< from FramebufferTexture2DMultisampleEXT */
    unsigned rtt_numviews;
 };
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index 1a8ea3b60a73a..9034d93047ef6 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -345,8 +345,6 @@ struct gl_shader_program_data
    /** Hash for quick search by name. */
    struct hash_table *ProgramResourceHash[NUM_PROGRAM_RESOURCE_TYPES];
 
-   GLboolean Validated;
-
    /** List of all active resources after linking. */
    struct gl_program_resource *ProgramResourceList;
    unsigned NumProgramResourceList;
@@ -357,6 +355,8 @@ struct gl_shader_program_data
    /* Mask of stages this program was linked against */
    unsigned linked_stages;
 
+   GLboolean Validated;
+
    /* Whether the shaders of this program are loaded from SPIR-V binaries
     * (all have the SPIR_V_BINARY_ARB state). This was introduced by the
     * ARB_gl_spirv extension.
@@ -370,10 +370,10 @@ struct gl_shader_program_data
  */
 struct gl_shader_program
 {
-   GLenum16 Type;   /**< Always GL_SHADER_PROGRAM (internal token) */
-   GLuint Name;  /**< aka handle or ID */
    GLchar *Label;   /**< GL_KHR_debug */
+   GLuint Name;  /**< aka handle or ID */
    GLint RefCount;  /**< Reference count */
+   GLenum16 Type;   /**< Always GL_SHADER_PROGRAM (internal token) */
    GLboolean DeletePending;
 
    /**
@@ -392,6 +392,12 @@ struct gl_shader_program
     */
    GLboolean SeparateShader;
 
+   GLboolean SamplersValidated; /**< Samplers validated against texture units? */
+
+   bool IsES;              /**< True if this program uses GLSL ES */
+
+   unsigned GLSL_Version; /**< GLSL version used for linking */
+
    GLuint NumShaders;          /**< number of attached shaders */
    struct gl_shader **Shaders; /**< List of attached the shaders */
 
@@ -453,10 +459,6 @@ struct gl_shader_program
     */
    unsigned NumExplicitUniformLocations;
 
-   GLboolean SamplersValidated; /**< Samplers validated against texture units? */
-
-   bool IsES;              /**< True if this program uses GLSL ES */
-
    /**
     * Per-stage shaders resulting from the first stage of linking.
     *
@@ -465,8 +467,6 @@ struct gl_shader_program
     * \c NULL.
     */
    struct gl_linked_shader *_LinkedShaders[MESA_SHADER_MESH_STAGES];
-
-   unsigned GLSL_Version; /**< GLSL version used for linking */
 };
 
 /**
@@ -485,6 +485,13 @@ struct gl_program
 
    GLboolean _Used;        /**< Ever used for drawing? Used for debugging */
 
+   /** whether to skip VARYING_SLOT_PSIZ in st_translate_stream_output_info() */
+   bool skip_pointsize_xfb;
+
+   st_state_bitset affected_states; /**< ST_NEW_* flags to mark dirty when binding */
+   struct pipe_shader_state state;
+   struct ati_fragment_shader *ati_fs;
+
    struct nir_shader *nir;
    void *base_serialized_nir;
    size_t base_serialized_nir_size;
@@ -493,9 +500,6 @@ struct gl_program
    void *driver_cache_blob;
    size_t driver_cache_blob_size;
 
-   /** whether to skip VARYING_SLOT_PSIZ in st_translate_stream_output_info() */
-   bool skip_pointsize_xfb;
-
    /** A bitfield indicating which vertex shader inputs consume two slots
     *
     * This is used for mapping from single-slot input locations in the GL API
@@ -522,19 +526,15 @@ struct gl_program
    /** Texture units used for samplerExternalOES */
    GLbitfield ExternalSamplersUsed;
 
+   unsigned serialized_nir_size;
+   void *serialized_nir;
+
    /** Named parameters, constants, etc. from program text */
    struct gl_program_parameter_list *Parameters;
 
    /** Map from sampler unit to texture unit (set by glUniform1i()) */
    GLubyte SamplerUnits[MAX_SAMPLERS];
 
-   struct pipe_shader_state state;
-   struct ati_fragment_shader *ati_fs;
-   st_state_bitset affected_states; /**< ST_NEW_* flags to mark dirty when binding */
-
-   void *serialized_nir;
-   unsigned serialized_nir_size;
-
    struct gl_shader_program *shader_program;
 
    struct st_variant *variants;
@@ -550,6 +550,10 @@ struct gl_program
          /** Post-link transform feedback info. */
          struct gl_transform_feedback_info *LinkedTransformFeedback;
 
+         struct gl_uniform_block **UniformBlocks;
+         struct gl_uniform_block **ShaderStorageBlocks;
+         GLuint NumUniformBlocks;
+
          /**
           * Number of types for subroutine uniforms.
           */
@@ -583,10 +587,6 @@ struct gl_program
           */
          enum gl_access_qualifier image_access[MAX_IMAGE_UNIFORMS];
 
-         GLuint NumUniformBlocks;
-         struct gl_uniform_block **UniformBlocks;
-         struct gl_uniform_block **ShaderStorageBlocks;
-
          /**
           * Bitmask of shader storage blocks not declared as read-only.
           */
@@ -795,11 +795,6 @@ struct gl_uniform_storage {
 
    struct gl_opaque_uniform_index opaque[MESA_SHADER_MESH_STAGES];
 
-   /**
-    * Mask of shader stages (1 << MESA_SHADER_xxx) where this uniform is used.
-    */
-   unsigned active_shader_mask;
-
    /**
     * Storage used by the driver for the uniform
     */
@@ -815,6 +810,11 @@ struct gl_uniform_storage {
     */
    union gl_constant_value *storage;
 
+   /**
+    * Mask of shader stages (1 << MESA_SHADER_xxx) where this uniform is used.
+    */
+   unsigned active_shader_mask;
+
    /** Fields for GL_ARB_uniform_buffer_object
     * @{
     */
@@ -959,8 +959,8 @@ struct gl_subroutine_function
  */
 struct gl_program_resource
 {
-   GLenum16 Type; /** Program interface type. */
    const void *Data; /** Pointer to resource associated data structure. */
+   GLenum16 Type; /** Program interface type. */
    uint8_t StageReferences; /** Bitmask of shader stage references. */
 };
 
-- 
GitLab


From 143e3d45eae628edb6a7ce6202fc4227761aac7b Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:07:15 +0300
Subject: [PATCH 10/31] vbo: added sse4.1 for vbo minmax with unsigned byte and
 unsigned short indices

---
 src/mesa/vbo/vbo_minmax_index.c | 24 ++++++++++++++++++------
 1 file changed, 18 insertions(+), 6 deletions(-)

diff --git a/src/mesa/vbo/vbo_minmax_index.c b/src/mesa/vbo/vbo_minmax_index.c
index 5f81d5024cf47..144a7611e043a 100644
--- a/src/mesa/vbo/vbo_minmax_index.c
+++ b/src/mesa/vbo/vbo_minmax_index.c
@@ -276,10 +276,16 @@ vbo_get_minmax_index_mapped(unsigned count, unsigned index_size,
          }
       }
       else {
-         for (unsigned i = 0; i < count; i++) {
-            if (us_indices[i] > max_us) max_us = us_indices[i];
-            if (us_indices[i] < min_us) min_us = us_indices[i];
+#if defined(USE_SSE41)
+         if (util_get_cpu_caps()->has_sse4_1) {
+            _mesa_uint_array_min_max((const GLuint *)us_indices, &min_us, &max_us, count);
          }
+         else
+#endif
+            for (unsigned i = 0; i < count; i++) {
+               if (us_indices[i] > max_us) max_us = us_indices[i];
+               if (us_indices[i] < min_us) min_us = us_indices[i];
+            }
       }
       *min_index = min_us;
       *max_index = max_us;
@@ -298,10 +304,16 @@ vbo_get_minmax_index_mapped(unsigned count, unsigned index_size,
          }
       }
       else {
-         for (unsigned i = 0; i < count; i++) {
-            if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
-            if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
+#if defined(USE_SSE41)
+         if (util_get_cpu_caps()->has_sse4_1) {
+            _mesa_uint_array_min_max((const GLuint *)ub_indices, &min_ub, &max_ub, count);
          }
+         else
+#endif
+            for (unsigned i = 0; i < count; i++) {
+               if (ub_indices[i] > max_ub) max_ub = ub_indices[i];
+               if (ub_indices[i] < min_ub) min_ub = ub_indices[i];
+            }
       }
       *min_index = min_ub;
       *max_index = max_ub;
-- 
GitLab

From cc8a0397ac41ebb745d99509677619f559022698 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:29:33 +0300
Subject: [PATCH 13/31] vbo: micro-op Clang/GCC using disassembler with -O3
 flag

---
 src/mesa/vbo/vbo_exec.c      | 19 +++++++---------
 src/mesa/vbo/vbo_exec_api.c  | 23 ++++++++-----------
 src/mesa/vbo/vbo_exec_draw.c | 44 +++++++++++++-----------------------
 src/mesa/vbo/vbo_private.h   | 22 +++++++-----------
 src/mesa/vbo/vbo_util.h      | 26 +++++++--------------
 5 files changed, 49 insertions(+), 85 deletions(-)

diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index c669fbd603f04..4a18d97026a8f 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -296,18 +296,15 @@ vbo_copy_vertices(struct gl_context *ctx,
       copy = MIN2(3, count);
       break;
    case GL_PATCHES:
-      if (in_dlist) {
-         /* We don't know the value of GL_PATCH_VERTICES when compiling
-          * a display list.
-          *
-          * Fail an assertion in debug builds and use the value of 3
-          * in release builds, which is more likely than any other value.
-          */
+      /* We don't know the value of GL_PATCH_VERTICES when compiling
+       * a display list.
+       *
+       * Fail an assertion in debug builds and use the value of 3
+       * in release builds, which is more likely than any other value.
+       */
+      if (in_dlist)
          assert(!"patch_vertices is unknown");
-         copy = count % 3;
-      } else {
-         copy = count % ctx->TessCtrlProgram.patch_vertices;
-      }
+      copy = count % (in_dlist ? 3 : ctx->TessCtrlProgram.patch_vertices);
       break;
    case GL_LINE_LOOP:
       if (!in_dlist && begin == 0) {
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index 1cca0e37ec58e..0957dbfc70381 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -198,21 +198,16 @@ vbo_exec_copy_to_current(struct vbo_exec_context *exec)
          if (i == VBO_ATTRIB_COLOR0)
             color0_changed = true;
 
-         if (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT) {
-            ctx->NewState |= _NEW_MATERIAL;
-            ctx->PopAttribState |= GL_LIGHTING_BIT;
-
-            /* The fixed-func vertex program uses this. */
-            if (i == VBO_ATTRIB_MAT_FRONT_SHININESS ||
-                i == VBO_ATTRIB_MAT_BACK_SHININESS)
-               ctx->NewState |= _NEW_FF_VERT_PROGRAM;
-         } else {
-            if (i == VBO_ATTRIB_EDGEFLAG)
-               _mesa_update_edgeflag_state_vao(ctx);
+         if (i == VBO_ATTRIB_EDGEFLAG)
+            _mesa_update_edgeflag_state_vao(ctx);
 
-            ctx->NewState |= _NEW_CURRENT_ATTRIB;
-            ctx->PopAttribState |= GL_CURRENT_BIT;
-         }
+         ctx->NewState |= (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT ? _NEW_MATERIAL : _NEW_CURRENT_ATTRIB);
+         ctx->PopAttribState |= (i >= VBO_ATTRIB_MAT_FRONT_AMBIENT ? GL_LIGHTING_BIT : GL_CURRENT_BIT);
+
+         /* The fixed-func vertex program uses this. */
+         if (i == VBO_ATTRIB_MAT_FRONT_SHININESS ||
+             i == VBO_ATTRIB_MAT_BACK_SHININESS)
+            ctx->NewState |= _NEW_FF_VERT_PROGRAM;
       }
 
       /* Given that we explicitly state size here, there is no need
diff --git a/src/mesa/vbo/vbo_exec_draw.c b/src/mesa/vbo/vbo_exec_draw.c
index 34ef4b705127a..73f7d3b29ddcc 100644
--- a/src/mesa/vbo/vbo_exec_draw.c
+++ b/src/mesa/vbo/vbo_exec_draw.c
@@ -93,25 +93,19 @@ vbo_exec_bind_arrays(struct gl_context *ctx,
    struct vbo_exec_context *exec = &vbo->exec;
 
    GLintptr buffer_offset;
-   if (exec->vtx.bufferobj) {
-      assert(exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Pointer);
-      buffer_offset = exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset +
-                      exec->vtx.buffer_offset;
-   } else {
-      /* Ptr into ordinary app memory */
-      buffer_offset = (GLbyte *)exec->vtx.buffer_map - (GLbyte *)NULL;
-   }
+   assert(exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Pointer);
+   buffer_offset = exec->vtx.bufferobj ?
+      exec->vtx.bufferobj->Mappings[MAP_INTERNAL].Offset + exec->vtx.buffer_offset :
+      (GLbyte *)exec->vtx.buffer_map - (GLbyte *)NULL; /* Ptr into ordinary app memory */
 
    const gl_vertex_processing_mode mode = ctx->VertexProgram._VPMode;
 
    GLbitfield vao_enabled, vao_filter;
-   if (_mesa_hw_select_enabled(ctx)) {
-      /* HW GL_SELECT has fixed input */
-      vao_enabled = vao_filter = VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET;
-   } else {
-      vao_enabled = _vbo_get_vao_enabled_from_vbo(mode, exec->vtx.enabled);
-      vao_filter = _vbo_get_vao_filter(mode);
-   }
+   /* HW GL_SELECT has fixed input */
+   vao_enabled = _mesa_hw_select_enabled(ctx) ? VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET
+      : _vbo_get_vao_enabled_from_vbo(mode, exec->vtx.enabled);
+   vao_filter = _mesa_hw_select_enabled(ctx) ? VERT_BIT_POS | VERT_BIT_SELECT_RESULT_OFFSET
+      : _vbo_get_vao_filter(mode);
 
    /* At first disable arrays no longer needed */
    _mesa_disable_vertex_array_attribs(ctx, vao, ~vao_enabled);
@@ -211,19 +205,13 @@ vbo_exec_vtx_map(struct vbo_exec_context *exec)
    GLenum accessRange = GL_MAP_WRITE_BIT |  /* for MapBufferRange */
                         GL_MAP_UNSYNCHRONIZED_BIT;
 
-   if (ctx->Extensions.ARB_buffer_storage) {
-      /* We sometimes read from the buffer, so map it for read too.
-       * Only the persistent mapping can do that, because the non-persistent
-       * mapping uses flags that are incompatible with GL_MAP_READ_BIT.
-       */
-      accessRange |= GL_MAP_PERSISTENT_BIT |
-                     GL_MAP_COHERENT_BIT |
-                     GL_MAP_READ_BIT;
-   } else {
-      accessRange |= GL_MAP_INVALIDATE_RANGE_BIT |
-                     GL_MAP_FLUSH_EXPLICIT_BIT |
-                     MESA_MAP_NOWAIT_BIT;
-   }
+   /* We sometimes read from the buffer, so map it for read too.
+    * Only the persistent mapping can do that, because the non-persistent
+    * mapping uses flags that are incompatible with GL_MAP_READ_BIT.
+    */
+   accessRange |= ctx->Extensions.ARB_buffer_storage ?
+      GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT | GL_MAP_READ_BIT
+      : GL_MAP_INVALIDATE_RANGE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT | MESA_MAP_NOWAIT_BIT;
 
    if (!exec->vtx.bufferobj)
       return;
diff --git a/src/mesa/vbo/vbo_private.h b/src/mesa/vbo/vbo_private.h
index 054f38c661428..e19056768fa5d 100644
--- a/src/mesa/vbo/vbo_private.h
+++ b/src/mesa/vbo/vbo_private.h
@@ -212,12 +212,9 @@ vbo_copy_vertices(struct gl_context *ctx,
 static inline GLbitfield
 _vbo_get_vao_filter(gl_vertex_processing_mode vertex_processing_mode)
 {
-   if (vertex_processing_mode == VP_MODE_FF) {
-      /* The materials mapped into the generic arrays */
-      return VERT_BIT_FF_ALL | VERT_BIT_MAT_ALL;
-   } else {
-      return VERT_BIT_ALL;
-   }
+   /* The materials mapped into the generic arrays */
+   return (vertex_processing_mode == VP_MODE_FF)
+      ? (VERT_BIT_FF_ALL | VERT_BIT_MAT_ALL) : VERT_BIT_ALL;
 }
 
 
@@ -229,14 +226,11 @@ _vbo_get_vao_filter(gl_vertex_processing_mode vertex_processing_mode)
 static inline GLbitfield
 _vbo_get_vao_enabled_from_vbo(gl_vertex_processing_mode vertex_processing_mode,
                               GLbitfield64 enabled)
-{
-   if (vertex_processing_mode == VP_MODE_FF) {
-      /* The materials mapped into the generic arrays */
-      return (((GLbitfield)enabled) & VERT_BIT_FF_ALL)
-         | (((GLbitfield)(enabled >> VBO_MATERIAL_SHIFT)) & VERT_BIT_MAT_ALL);
-   } else {
-      return enabled;
-   }
+{ /* The materials mapped into the generic arrays */
+   return (vertex_processing_mode == VP_MODE_FF)
+      ? (((GLbitfield)enabled) & VERT_BIT_FF_ALL)
+         | (((GLbitfield)(enabled >> VBO_MATERIAL_SHIFT)) & VERT_BIT_MAT_ALL)
+      : enabled;
 }
 
 
diff --git a/src/mesa/vbo/vbo_util.h b/src/mesa/vbo/vbo_util.h
index 1dd415b2de88a..890da5bdf5a5a 100644
--- a/src/mesa/vbo/vbo_util.h
+++ b/src/mesa/vbo/vbo_util.h
@@ -80,15 +80,10 @@ static inline float conv_i10_to_norm_float(const struct gl_context *ctx, int i10
     * OpenGL 4.2+ and ES 3.0 remedy this and state that equation 2.3 (above)
     * is used in every case.  They remove equation 2.2 completely.
     */
-   if (_mesa_is_gles3(ctx) ||
-       (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) {
-      /* Equation 2.3 above. */
-      float f = ((float) val.x) / 511.0F;
-      return MAX2(f, -1.0f);
-   } else {
-      /* Equation 2.2 above. */
-      return (2.0F * (float)val.x + 1.0F) * (1.0F  / 1023.0F);
-   }
+   return (_mesa_is_gles3(ctx) ||
+           (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) ?
+          MAX2(((float) val.x) / 511.0F, -1.0f) : /* Equation 2.3 above. */
+          (2.0F * (float)val.x + 1.0F) * (1.0F  / 1023.0F); /* Equation 2.2 above. */
 }
 
 static inline float conv_i2_to_norm_float(const struct gl_context *ctx, int i2)
@@ -96,15 +91,10 @@ static inline float conv_i2_to_norm_float(const struct gl_context *ctx, int i2)
    struct attr_bits_2 val;
    val.x = i2;
 
-   if (_mesa_is_gles3(ctx) ||
-       (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) {
-      /* Equation 2.3 above. */
-      float f = (float) val.x;
-      return MAX2(f, -1.0f);
-   } else {
-      /* Equation 2.2 above. */
-      return (2.0F * (float)val.x + 1.0F) * (1.0F / 3.0F);
-   }
+   return (_mesa_is_gles3(ctx) ||
+           (_mesa_is_desktop_gl(ctx) && ctx->Version >= 42)) ?
+          MAX2((float) val.x, -1.0f) :
+          (2.0F * (float)val.x + 1.0F) * (1.0F / 3.0F);
 }
 
 #define ERROR_IF_NOT_PACKED_TYPE(ctx, type, func) \
-- 
GitLab


From df47570f082ef8b4d84ffd397a283b9fbb838d09 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:31:50 +0300
Subject: [PATCH 14/31] state_tracker: micro-op Clang/GCC using disassembler
 with -O3 flag

---
 src/mesa/state_tracker/st_atifs_to_nir.c  | 53 ++++++++---------------
 src/mesa/state_tracker/st_atom_array.cpp  | 29 ++++---------
 src/mesa/state_tracker/st_atom_constbuf.c |  6 +--
 src/mesa/state_tracker/st_atom_image.c    | 15 +++----
 src/mesa/state_tracker/st_atom_sampler.c  | 12 ++---
 src/mesa/state_tracker/st_atom_shader.c   |  9 +---
 src/mesa/state_tracker/st_cb_eglimage.c   | 26 +++++------
 src/mesa/state_tracker/st_extensions.c    | 15 ++-----
 src/mesa/state_tracker/st_format.c        | 10 ++---
 src/mesa/state_tracker/st_glsl_to_nir.cpp | 39 +++++------------
 src/mesa/state_tracker/st_pbo.c           | 19 +++-----
 src/mesa/state_tracker/st_pbo_compute.c   | 30 ++++---------
 src/mesa/state_tracker/st_program.c       |  9 +---
 src/mesa/state_tracker/st_sampler_view.c  | 21 ++++-----
 14 files changed, 89 insertions(+), 204 deletions(-)

diff --git a/src/mesa/state_tracker/st_atifs_to_nir.c b/src/mesa/state_tracker/st_atifs_to_nir.c
index c534ae008d8a0..4fbcad82465b3 100644
--- a/src/mesa/state_tracker/st_atifs_to_nir.c
+++ b/src/mesa/state_tracker/st_atifs_to_nir.c
@@ -133,33 +133,24 @@ atifs_load_uniform(struct st_translate *t, int index)
 static struct nir_def *
 get_source(struct st_translate *t, GLenum src_type)
 {
-   if (src_type >= GL_REG_0_ATI && src_type <= GL_REG_5_ATI) {
-      if (t->regs_written[t->current_pass][src_type - GL_REG_0_ATI]) {
-         return get_temp(t, src_type - GL_REG_0_ATI);
-      } else {
-         return nir_imm_vec4_float(t->b, 0.0);
-      }
-   } else if (src_type >= GL_CON_0_ATI && src_type <= GL_CON_7_ATI) {
-      int index = src_type - GL_CON_0_ATI;
-      if (t->atifs->LocalConstDef & (1 << index)) {
-         return nir_imm_vec4(t->b,
-                             t->atifs->Constants[index][0],
-                             t->atifs->Constants[index][1],
-                             t->atifs->Constants[index][2],
-                             t->atifs->Constants[index][3]);
-      } else {
-         return atifs_load_uniform(t, index);
-      }
-   } else if (src_type == GL_ZERO) {
+   if (src_type >= GL_REG_0_ATI && src_type <= GL_REG_5_ATI)
+      return t->regs_written[t->current_pass][src_type - GL_REG_0_ATI] ?
+             get_temp(t, src_type - GL_REG_0_ATI) : nir_imm_vec4_float(t->b, 0.0);
+   else if (src_type >= GL_CON_0_ATI && src_type <= GL_CON_7_ATI) {
+      const int index = src_type - GL_CON_0_ATI;
+      return (t->atifs->LocalConstDef & (1 << index)) ?
+             nir_imm_vec4(t->b, t->atifs->Constants[index][0], t->atifs->Constants[index][1],
+                                 t->atifs->Constants[index][2], t->atifs->Constants[index][3]) :
+             atifs_load_uniform(t, index);
+   } else if (src_type == GL_ZERO)
       return nir_imm_vec4_float(t->b, 0.0);
-   } else if (src_type == GL_ONE) {
+   else if (src_type == GL_ONE)
       return nir_imm_vec4_float(t->b, 1.0);
-   } else if (src_type == GL_PRIMARY_COLOR_ARB) {
+   else if (src_type == GL_PRIMARY_COLOR_ARB)
       return load_input(t, VARYING_SLOT_COL0);
-   } else if (src_type == GL_SECONDARY_INTERPOLATOR_ATI) {
+   else if (src_type == GL_SECONDARY_INTERPOLATOR_ATI)
       return load_input(t, VARYING_SLOT_COL1);
-   } else {
-      /* frontend prevents this */
+   else { /* frontend prevents this */
       UNREACHABLE("unknown source");
    }
 }
@@ -322,11 +313,7 @@ compile_setupinst(struct st_translate *t,
       unsigned reg = pass_tex - GL_REG_0_ATI;
 
       /* the frontend already validated that REG is only allowed in second pass */
-      if (t->regs_written[0][reg]) {
-         coord = t->temps[reg];
-      } else {
-         coord = nir_imm_vec4_float(t->b, 0.0f);
-      }
+      coord = t->regs_written[0][reg] ? t->temps[reg] : nir_imm_vec4_float(t->b, 0.0f);
    } else {
       coord = nir_undef(t->b, 4, 32);
    }
@@ -496,13 +483,9 @@ st_nir_lower_atifs_samplers_instr(nir_builder *b, nir_instr *instr, void *data)
 
    unsigned unit;
    int sampler_src_idx = nir_tex_instr_src_index(tex, nir_tex_src_sampler_deref);
-   if (sampler_src_idx >= 0) {
-      nir_deref_instr *deref = nir_src_as_deref(tex->src[sampler_src_idx].src);
-      nir_variable *var = nir_deref_instr_get_variable(deref);
-      unit = var->data.binding;
-   } else {
-      unit = tex->sampler_index;
-   }
+   nir_deref_instr *deref = nir_src_as_deref(tex->src[sampler_src_idx].src);
+   nir_variable *var = nir_deref_instr_get_variable(deref);
+   unit = sampler_src_idx >= 0 ? var->data.binding : tex->sampler_index;
 
    bool is_array;
    tex->sampler_dim =
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index ac48f859347b9..eb5dd648097dd 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -136,14 +136,10 @@ setup_arrays(struct gl_context *ctx,
          const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&mask);
          const struct gl_array_attributes *attrib;
          const struct gl_vertex_buffer_binding *binding;
-
-         if (HAS_IDENTITY_ATTRIB_MAPPING) {
-            attrib = &vao->VertexAttrib[attr];
-            binding = &vao->BufferBinding[attr];
-         } else {
-            attrib = &vao->VertexAttrib[attribute_map[attr]];
-            binding = &vao->BufferBinding[attrib->BufferBindingIndex];
-         }
+         attrib = HAS_IDENTITY_ATTRIB_MAPPING ? &vao->VertexAttrib[attr] :
+                                                &vao->VertexAttrib[attribute_map[attr]];
+         binding = HAS_IDENTITY_ATTRIB_MAPPING ? &vao->BufferBinding[attr] :
+                                                 &vao->BufferBinding[attrib->BufferBindingIndex];
          const unsigned bufidx = (*num_vbuffers)++;
 
          /* Set the vertex buffer. */
@@ -211,19 +207,10 @@ setup_arrays(struct gl_context *ctx,
       const struct gl_vertex_buffer_binding *const binding
          = _mesa_draw_buffer_binding(vao, i);
       const unsigned bufidx = (*num_vbuffers)++;
-
-      if (binding->BufferObj) {
-         /* Set the binding */
-         vbuffer[bufidx].buffer.resource = binding->BufferObj->buffer;
-         vbuffer[bufidx].is_user_buffer = false;
-         vbuffer[bufidx].buffer_offset = _mesa_draw_binding_offset(binding);
-      } else {
-         /* Set the binding */
-         const void *ptr = (const void *)_mesa_draw_binding_offset(binding);
-         vbuffer[bufidx].buffer.user = ptr;
-         vbuffer[bufidx].is_user_buffer = true;
-         vbuffer[bufidx].buffer_offset = 0;
-      }
+      vbuffer[bufidx].buffer.resource = binding->BufferObj ? binding->BufferObj->buffer : NULL;
+      vbuffer[bufidx].is_user_buffer = !binding->BufferObj;
+      vbuffer[bufidx].buffer_offset = binding->BufferObj ? _mesa_draw_binding_offset(binding) : 0;
+      vbuffer[bufidx].buffer.user = binding->BufferObj ? NULL : (const void *)_mesa_draw_binding_offset(binding);
 
       const GLbitfield boundmask = _mesa_draw_bound_attrib_bits(binding);
       GLbitfield attrmask = mask & boundmask;
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 737372e003464..88a4c6be1acd0 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -304,11 +304,7 @@ st_bind_ubos(struct st_context *st, struct gl_program *prog,
       binding =
          &st->ctx->UniformBufferBindings[prog->sh.UniformBlocks[i]->Binding];
 
-      if (binding->BufferObject) {
-         cb.buffer = binding->BufferObject->buffer;
-      } else {
-         cb.buffer = NULL;
-      }
+      cb.buffer = binding->BufferObject ? binding->BufferObject->buffer : NULL;
 
       if (cb.buffer) {
          cb.buffer_offset = binding->Offset;
diff --git a/src/mesa/state_tracker/st_atom_image.c b/src/mesa/state_tracker/st_atom_image.c
index 95f5f89a505de..1493bc8d2b331 100644
--- a/src/mesa/state_tracker/st_atom_image.c
+++ b/src/mesa/state_tracker/st_atom_image.c
@@ -106,15 +106,12 @@ st_convert_image(const struct st_context *st, const struct gl_image_unit *u,
       img->u.tex.level = u->Level + stObj->Attrib.MinLevel;
       img->u.tex.single_layer_view = !u->Layered;
       assert(img->u.tex.level <= img->resource->last_level);
-      if (stObj->pt->target == PIPE_TEXTURE_3D) {
-         if (u->Layered) {
-            img->u.tex.first_layer = 0;
-            img->u.tex.last_layer = u_minify(stObj->pt->depth0, img->u.tex.level) - 1;
-         } else {
-            img->u.tex.first_layer = u->_Layer;
-            img->u.tex.last_layer = u->_Layer;
-            img->u.tex.is_2d_view_of_3d = true;
-         }
+      if (stObj->pt->target == PIPE_TEXTURE_3D) { /* 3D texture */
+         img->u.tex.first_layer = u->Layered ? 0 : u->_Layer;
+         img->u.tex.last_layer = u->Layered
+            ? u_minify(stObj->pt->depth0, img->u.tex.level) - 1
+            : u->_Layer;
+         img->u.tex.is_2d_view_of_3d = !u->Layered;
       } else {
          img->u.tex.first_layer = u->_Layer + stObj->Attrib.MinLayer;
          img->u.tex.last_layer = u->_Layer + stObj->Attrib.MinLayer;
diff --git a/src/mesa/state_tracker/st_atom_sampler.c b/src/mesa/state_tracker/st_atom_sampler.c
index 8b30c72aa83b8..8e1ec5658dd4b 100644
--- a/src/mesa/state_tracker/st_atom_sampler.c
+++ b/src/mesa/state_tracker/st_atom_sampler.c
@@ -245,15 +245,9 @@ update_shader_samplers(struct st_context *st,
       /* Don't update the sampler for TBOs. cso_context will not bind sampler
        * states that are NULL.
        */
-      if (samplers_used & 1 &&
-          (ctx->Texture.Unit[tex_unit]._Current->Target != GL_TEXTURE_BUFFER)) {
-         st_convert_sampler_from_unit(
-            st, sampler, tex_unit,
-            prog->shader_program && prog->shader_program->GLSL_Version >= 130);
-         states[unit] = sampler;
-      } else {
-         states[unit] = NULL;
-      }
+      states[unit] = (samplers_used & 1 && (ctx->Texture.Unit[tex_unit]._Current->Target != GL_TEXTURE_BUFFER)) ?
+         (st_convert_sampler_from_unit(st, sampler, tex_unit,prog->shader_program &&
+            prog->shader_program->GLSL_Version >= 130), sampler) : NULL;
    }
 
    /* For any external samplers with multiplaner YUV, stuff the additional
diff --git a/src/mesa/state_tracker/st_atom_shader.c b/src/mesa/state_tracker/st_atom_shader.c
index 6df450cd6d0c6..b2e3c70814300 100644
--- a/src/mesa/state_tracker/st_atom_shader.c
+++ b/src/mesa/state_tracker/st_atom_shader.c
@@ -60,14 +60,9 @@ static unsigned
 get_texture_index(struct gl_context *ctx, const unsigned unit)
 {
    struct gl_texture_object *texObj = _mesa_get_tex_unit(ctx, unit)->_Current;
-   gl_texture_index index;
 
-   if (texObj) {
-      index = _mesa_tex_target_to_index(ctx, texObj->Target);
-   } else {
-      /* fallback for missing texture */
-      index = TEXTURE_2D_INDEX;
-   }
+   gl_texture_index index = texObj ? _mesa_tex_target_to_index(ctx, texObj->Target)
+                                    : TEXTURE_2D_INDEX; /* fallback for missing texture */
 
    return index;
 }
diff --git a/src/mesa/state_tracker/st_cb_eglimage.c b/src/mesa/state_tracker/st_cb_eglimage.c
index 9feae1f360962..d7c98c246f731 100644
--- a/src/mesa/state_tracker/st_cb_eglimage.c
+++ b/src/mesa/state_tracker/st_cb_eglimage.c
@@ -477,24 +477,18 @@ st_bind_egl_image(struct gl_context *ctx,
          break;
       case PIPE_FORMAT_NV12:
       case PIPE_FORMAT_NV21:
-         if (stimg->texture->format == PIPE_FORMAT_R8_G8B8_420_UNORM ||
-             stimg->texture->format == PIPE_FORMAT_R8_B8G8_420_UNORM) {
-            texFormat = MESA_FORMAT_R8G8B8X8_UNORM;
-            texObj->RequiredTextureImageUnits = 1;
-         } else {
-            texFormat = MESA_FORMAT_R_UNORM8;
-            texObj->RequiredTextureImageUnits = 2;
-         }
+         texFormat = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_420_UNORM ||
+                        stimg->texture->format == PIPE_FORMAT_R8_B8G8_420_UNORM) ?
+                           MESA_FORMAT_R8G8B8X8_UNORM : MESA_FORMAT_R_UNORM8;
+         texObj->RequiredTextureImageUnits = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_420_UNORM ||
+                                             stimg->texture->format == PIPE_FORMAT_R8_B8G8_420_UNORM) ? 1 : 2;
          break;
       case PIPE_FORMAT_NV16:
-         if (stimg->texture->format == PIPE_FORMAT_R8_G8B8_422_UNORM ||
-             stimg->texture->format == PIPE_FORMAT_R8_B8G8_422_UNORM) {
-            texFormat = MESA_FORMAT_R8G8B8X8_UNORM;
-            texObj->RequiredTextureImageUnits = 1;
-         } else {
-            texFormat = MESA_FORMAT_R_UNORM8;
-            texObj->RequiredTextureImageUnits = 2;
-         }
+         texFormat = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_422_UNORM ||
+                        stimg->texture->format == PIPE_FORMAT_R8_B8G8_422_UNORM) ?
+                           MESA_FORMAT_R8G8B8X8_UNORM : MESA_FORMAT_R_UNORM8;
+         texObj->RequiredTextureImageUnits = (stimg->texture->format == PIPE_FORMAT_R8_G8B8_422_UNORM ||
+                                             stimg->texture->format == PIPE_FORMAT_R8_B8G8_422_UNORM) ? 1 : 2;
          break;
       case PIPE_FORMAT_NV61:
       case PIPE_FORMAT_NV24:
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 02f9d4c523cd2..0a5e9e3b2f383 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -1324,11 +1324,7 @@ void st_init_extensions(struct pipe_screen *screen,
       extensions->ARB_texture_rgb10_a2ui = GL_FALSE;
    }
 
-   if (options->glsl_zero_init) {
-      consts->GLSLZeroInit = 1;
-   } else {
-      consts->GLSLZeroInit = screen->caps.glsl_zero_init;
-   }
+   consts->GLSLZeroInit = options->glsl_zero_init ? 1 : screen->caps.glsl_zero_init;
 
    if (extensions->EXT_semaphore) {
       consts->MaxTimelineSemaphoreValueDifference = screen->caps.max_timeline_semaphore_difference;
@@ -1623,13 +1619,8 @@ void st_init_extensions(struct pipe_screen *screen,
 
    consts->MaxViewports = screen->caps.max_viewports;
    if (consts->MaxViewports >= 16) {
-      if (GLSLVersion >= 400) {
-         consts->ViewportBounds.Min = -32768.0;
-         consts->ViewportBounds.Max = 32767.0;
-      } else {
-         consts->ViewportBounds.Min = -16384.0;
-         consts->ViewportBounds.Max = 16383.0;
-      }
+      consts->ViewportBounds.Min = GLSLVersion >= 400 ? -32768.0 : -16384.0;
+      consts->ViewportBounds.Max = GLSLVersion >= 400 ? 32767.0 : 16383.0;
       extensions->ARB_viewport_array = GL_TRUE;
       extensions->ARB_fragment_layer_viewport = GL_TRUE;
       if (extensions->AMD_vertex_shader_layer)
diff --git a/src/mesa/state_tracker/st_format.c b/src/mesa/state_tracker/st_format.c
index 1b2e3fee0ad62..50eac27695ab3 100644
--- a/src/mesa/state_tracker/st_format.c
+++ b/src/mesa/state_tracker/st_format.c
@@ -119,13 +119,9 @@ st_mesa_format_to_pipe_format(const struct st_context *st,
          return mesaFormat;
 
       /* We're emulating all of ASTC via transcoding or decompression */
-      if (_mesa_is_format_srgb(mesaFormat)) {
-         return st->transcode_astc ? PIPE_FORMAT_DXT5_SRGBA :
-                                     PIPE_FORMAT_R8G8B8A8_SRGB;
-      } else {
-         return st->transcode_astc ? PIPE_FORMAT_DXT5_RGBA :
-                                     PIPE_FORMAT_R8G8B8A8_UNORM;
-      }
+      return _mesa_is_format_srgb(mesaFormat) ?
+             (st->transcode_astc ? PIPE_FORMAT_DXT5_SRGBA : PIPE_FORMAT_R8G8B8A8_SRGB) :
+             (st->transcode_astc ? PIPE_FORMAT_DXT5_RGBA : PIPE_FORMAT_R8G8B8A8_UNORM);
    }
 
    if (_mesa_is_format_s3tc(mesaFormat) && !st->has_s3tc) {
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index f46e3378cd3a9..babf9c2d375dd 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -127,25 +127,16 @@ st_nir_assign_uniform_locations(struct st_context *st,
 
       const struct glsl_type *type = glsl_without_array(uniform->type);
       if (!uniform->data.bindless && (glsl_type_is_sampler(type) || glsl_type_is_image(type))) {
-         if (glsl_type_is_sampler(type)) {
-            loc = shaderidx;
-            shaderidx += type_size(uniform->type);
-         } else {
-            loc = imageidx;
-            imageidx += type_size(uniform->type);
-         }
+         loc = glsl_type_is_sampler(type) ? shaderidx : imageidx;
+         (glsl_type_is_sampler(type) ? shaderidx : imageidx) += type_size(uniform->type);
       } else if (uniform->state_slots) {
          if (st->allow_st_finalize_nir_twice && !is_before_variants)
             continue;
 
          const gl_state_index16 *const stateTokens = uniform->state_slots[0].tokens;
 
-         unsigned comps;
-         if (glsl_type_is_struct_or_ifc(type)) {
-            comps = 4;
-         } else {
-            comps = glsl_get_vector_elements(type);
-         }
+         unsigned comps = glsl_type_is_struct_or_ifc(type) ?
+            4 : glsl_get_vector_elements(type);
 
          if (ctx->Const.PackedDriverUniformStorage) {
             loc = _mesa_add_sized_state_reference(prog->Parameters,
@@ -249,12 +240,9 @@ st_glsl_to_nir_post_opts(struct st_context *st, struct gl_program *prog,
       if (slots != NULL) {
          const struct glsl_type *type = glsl_without_array(var->type);
          for (unsigned int i = 0; i < var->num_state_slots; i++) {
-            unsigned comps;
-            if (glsl_type_is_struct_or_ifc(type)) {
-               comps = _mesa_program_state_value_size(slots[i].tokens);
-            } else {
-               comps = glsl_get_vector_elements(type);
-            }
+            unsigned comps = glsl_type_is_struct_or_ifc(type) ?
+                             _mesa_program_state_value_size(slots[i].tokens) :
+                             glsl_get_vector_elements(type);
 
             if (st->ctx->Const.PackedDriverUniformStorage) {
                _mesa_add_sized_state_reference(prog->Parameters,
@@ -687,15 +675,10 @@ st_unpacked_uniforms_type_size(const struct glsl_type *type, bool bindless)
 void
 st_nir_lower_uniforms(struct st_context *st, nir_shader *nir)
 {
-   if (st->ctx->Const.PackedDriverUniformStorage) {
-      NIR_PASS(_, nir, nir_lower_io, nir_var_uniform,
-                 st_packed_uniforms_type_size,
-                 (nir_lower_io_options)0);
-   } else {
-      NIR_PASS(_, nir, nir_lower_io, nir_var_uniform,
-                 st_unpacked_uniforms_type_size,
-                 (nir_lower_io_options)0);
-   }
+   NIR_PASS(_, nir, nir_lower_io, nir_var_uniform,
+            st->ctx->Const.PackedDriverUniformStorage ? st_packed_uniforms_type_size
+                                                   : st_unpacked_uniforms_type_size,
+            (nir_lower_io_options)0);
 
    if (nir->options->lower_uniforms_to_ubo)
       NIR_PASS(_, nir, nir_lower_uniforms_to_ubo,
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index a7f71f78b5310..efde866b38adb 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -118,12 +118,8 @@ st_pbo_addresses_pixelstore(struct st_context *st,
    /* Convert to texels */
    buf_offset = buf_offset / addr->bytes_per_pixel;
 
-   /* Determine image height */
-   if (gl_target == GL_TEXTURE_1D_ARRAY) {
-      addr->image_height = 1;
-   } else {
-      addr->image_height = store->ImageHeight > 0 ? store->ImageHeight : addr->height;
-   }
+   addr->image_height = gl_target == GL_TEXTURE_1D_ARRAY ? 1 :
+                        (store->ImageHeight > 0 ? store->ImageHeight : addr->height);
 
    /* Compute the stride, taking store->Alignment into account */
    {
@@ -487,14 +483,9 @@ create_fs(struct st_context *st, bool download,
             src_layer = nir_iadd(&b, layer, layer_offset);
          }
 
-         if (target == PIPE_TEXTURE_1D_ARRAY) {
-            texcoord = nir_vec2(&b, nir_channel(&b, texcoord, 0),
-                                    src_layer);
-         } else {
-            texcoord = nir_vec3(&b, nir_channel(&b, texcoord, 0),
-                                    nir_channel(&b, texcoord, 1),
-                                    src_layer);
-         }
+         texcoord = target == PIPE_TEXTURE_1D_ARRAY ?
+                    nir_vec2(&b, nir_channel(&b, texcoord, 0), src_layer) :
+                    nir_vec3(&b, nir_channel(&b, texcoord, 0), nir_channel(&b, texcoord, 1), src_layer);
       }
    } else {
       texcoord = pbo_addr;
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 08285d00be16e..9e52efbe4b6c2 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -326,12 +326,8 @@ fill_pbo_data(struct pbo_data *pd, enum pipe_format src_format, enum pipe_format
    if (is_8bit || dst_desc->block.bits == 8)
       swap = false;
 
-   unsigned dst_bit_size = 0;
-   if (weird_packed) {
-      dst_bit_size = dst_desc->block.bits;
-   } else {
-      dst_bit_size = dst_desc->block.bits / dst_desc->nr_channels;
-   }
+   unsigned dst_bit_size = weird_packed ? dst_desc->block.bits :
+                                          dst_desc->block.bits / dst_desc->nr_channels;
    assert(dst_bit_size);
    assert(dst_bit_size <= 64);
 
@@ -1035,14 +1031,11 @@ download_texture_compute(struct st_context *st,
             for (unsigned i = 0; i < 4; i++)
                invswizzle[i] = PIPE_SWIZZLE_Z;
          } else {
-            if (swizzle_clamp & SWIZZLE_CLAMP_BGRA) {
-               if (util_format_get_nr_components(dst_format) == 3)
-                  swizzle = util_format_description(PIPE_FORMAT_B8G8R8_UNORM)->swizzle;
-               else
-                  swizzle = util_format_description(PIPE_FORMAT_B8G8R8A8_UNORM)->swizzle;
-            } else {
-               swizzle = desc->swizzle;
-            }
+            swizzle = (swizzle_clamp & SWIZZLE_CLAMP_BGRA) ?
+                      ((util_format_get_nr_components(dst_format) == 3) ?
+                       util_format_description(PIPE_FORMAT_B8G8R8_UNORM)->swizzle :
+                       util_format_description(PIPE_FORMAT_B8G8R8A8_UNORM)->swizzle) :
+                      desc->swizzle;
             invert_swizzle(invswizzle, swizzle);
          }
          swizzle_clamp &= ~(SWIZZLE_CLAMP_BGRA | SWIZZLE_CLAMP_GREEN | SWIZZLE_CLAMP_BLUE);
@@ -1099,13 +1092,8 @@ download_texture_compute(struct st_context *st,
       /* array textures expect to have array index provided */
       if (view_target != PIPE_TEXTURE_3D && src->array_size) {
          templ.u.tex.first_layer = layer;
-         if (view_target == PIPE_TEXTURE_1D_ARRAY) {
-            templ.u.tex.first_layer += yoffset;
-            templ.u.tex.last_layer = templ.u.tex.first_layer + height - 1;
-         } else {
-            templ.u.tex.first_layer += zoffset;
-            templ.u.tex.last_layer = templ.u.tex.first_layer + depth - 1;
-         }
+         templ.u.tex.first_layer += (view_target == PIPE_TEXTURE_1D_ARRAY) ? yoffset : zoffset;
+         templ.u.tex.last_layer = templ.u.tex.first_layer + ((view_target == PIPE_TEXTURE_1D_ARRAY) ? height : depth) - 1;
       }
 
       sampler_view = pipe->create_sampler_view(pipe, src, &templ);
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 8eed848fccf92..22f3c2f103174 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -706,13 +706,8 @@ lower_ucp(struct st_context *st,
 
       gl_state_index16 clipplane_state[MAX_CLIP_PLANES][STATE_LENGTH] = {{0}};
       for (int i = 0; i < MAX_CLIP_PLANES; ++i) {
-         if (use_eye) {
-            clipplane_state[i][0] = STATE_CLIPPLANE;
-            clipplane_state[i][1] = i;
-         } else {
-            clipplane_state[i][0] = STATE_CLIP_INTERNAL;
-            clipplane_state[i][1] = i;
-         }
+         clipplane_state[i][0] = use_eye ? STATE_CLIPPLANE : STATE_CLIP_INTERNAL;
+         clipplane_state[i][1] = i;
          if (!st->allow_st_finalize_nir_twice)
             _mesa_add_state_reference(params, clipplane_state[i]);
       }
diff --git a/src/mesa/state_tracker/st_sampler_view.c b/src/mesa/state_tracker/st_sampler_view.c
index 8b7ac8352bcec..55a36046ebb40 100644
--- a/src/mesa/state_tracker/st_sampler_view.c
+++ b/src/mesa/state_tracker/st_sampler_view.c
@@ -486,19 +486,14 @@ st_create_texture_sampler_view_from_stobj(struct st_context *st,
    templ.format = format;
    templ.is_tex2d_from_buf = false;
 
-   if (texObj->level_override >= 0) {
-      templ.u.tex.first_level = templ.u.tex.last_level = texObj->level_override;
-   } else {
-      templ.u.tex.first_level = texObj->Attrib.MinLevel +
-                                texObj->Attrib.BaseLevel;
-      templ.u.tex.last_level = last_level(texObj);
-   }
-   if (texObj->layer_override >= 0) {
-      templ.u.tex.first_layer = templ.u.tex.last_layer = texObj->layer_override;
-   } else {
-      templ.u.tex.first_layer = texObj->Attrib.MinLayer;
-      templ.u.tex.last_layer = last_layer(texObj);
-   }
+   templ.u.tex.first_level = texObj->level_override >= 0 ? texObj->level_override
+                           : texObj->Attrib.MinLevel + texObj->Attrib.BaseLevel;
+   templ.u.tex.last_level = texObj->level_override >= 0 ? texObj->level_override
+                           : last_level(texObj);
+   templ.u.tex.first_layer = texObj->layer_override >= 0 ?
+                             texObj->layer_override : texObj->Attrib.MinLayer;
+   templ.u.tex.last_layer = texObj->layer_override >= 0 ?
+                            texObj->layer_override : last_layer(texObj);
    assert(templ.u.tex.first_layer <= templ.u.tex.last_layer);
    assert(templ.u.tex.first_level <= templ.u.tex.last_level);
    templ.target = gl_target_to_pipe(texObj->Target);
-- 
GitLab


From 3b9f7e8e936bc5ec04699e629e84e7051a2ca3b5 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 29 Sep 2025 10:33:47 +0300
Subject: [PATCH 15/31] vulkan: micro-op Clang/GCC using disassembler with -O3
 flag

---
 src/vulkan/runtime/vk_image.c                 |  8 ++--
 src/vulkan/runtime/vk_meta_blit_resolve.c     | 22 +++------
 src/vulkan/runtime/vk_meta_clear.c            | 13 +++---
 src/vulkan/runtime/vk_meta_copy_fill_update.c | 43 +++++-------------
 src/vulkan/runtime/vk_nir_convert_ycbcr.c     | 25 ++++-------
 src/vulkan/runtime/vk_object.c                |  7 +--
 src/vulkan/runtime/vk_pipeline_cache.c        |  6 +--
 src/vulkan/runtime/vk_queue.c                 | 20 +++------
 src/vulkan/runtime/vk_render_pass.c           | 45 +++++--------------
 src/vulkan/runtime/vk_semaphore.c             | 11 ++---
 src/vulkan/runtime/vk_video.c                 | 26 +++--------
 11 files changed, 66 insertions(+), 160 deletions(-)

diff --git a/src/vulkan/runtime/vk_image.c b/src/vulkan/runtime/vk_image.c
index 7efabe8485a12..59d80a6ff0cd3 100644
--- a/src/vulkan/runtime/vk_image.c
+++ b/src/vulkan/runtime/vk_image.c
@@ -651,11 +651,9 @@ vk_image_view_init(struct vk_device *device,
          unsigned total = image_view->extent.depth;
          image_view->storage.z_slice_offset = sliced_info->sliceOffset;
          assert(image_view->storage.z_slice_offset < total);
-         if (sliced_info->sliceCount == VK_REMAINING_3D_SLICES_EXT) {
-            image_view->storage.z_slice_count = total - image_view->storage.z_slice_offset;
-         } else {
-            image_view->storage.z_slice_count = sliced_info->sliceCount;
-         }
+         image_view->storage.z_slice_count =
+            sliced_info->sliceCount == VK_REMAINING_3D_SLICES_EXT ?
+            total - image_view->storage.z_slice_offset : sliced_info->sliceCount;
       } else if (image_view->view_type != VK_IMAGE_VIEW_TYPE_3D) {
          image_view->storage.z_slice_offset = image_view->base_array_layer;
          image_view->storage.z_slice_count = image_view->layer_count;
diff --git a/src/vulkan/runtime/vk_meta_blit_resolve.c b/src/vulkan/runtime/vk_meta_blit_resolve.c
index a7022bc734816..eb0a8ee5715e4 100644
--- a/src/vulkan/runtime/vk_meta_blit_resolve.c
+++ b/src/vulkan/runtime/vk_meta_blit_resolve.c
@@ -190,14 +190,9 @@ build_tex_resolve(nir_builder *b, nir_deref_instr *t,
 static nir_shader *
 build_blit_shader(const struct vk_meta_blit_key *key)
 {
-   nir_builder build;
-   if (key->resolve_mode || key->stencil_resolve_mode) {
-      build = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT, NULL,
-                                             "vk-meta-resolve");
-   } else {
-      build = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT,
-                                             NULL, "vk-meta-blit");
-   }
+   nir_builder build = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT, NULL,
+                                                      (key->resolve_mode || key->stencil_resolve_mode) ?
+                                                      "vk-meta-resolve" : "vk-meta-blit");
    nir_builder *b = &build;
 
    struct glsl_struct_field push_fields[] = {
@@ -301,14 +296,9 @@ build_blit_shader(const struct vk_meta_blit_key *key)
       texture->data.binding = aspect_to_tex_binding(aspect);
       nir_deref_instr *t = nir_build_deref_var(b, texture);
 
-      nir_def *val;
-      if (resolve_mode == VK_RESOLVE_MODE_NONE) {
-         val = nir_txl(b, src_coord, nir_imm_float(b, 0),
-                       .texture_deref = t, .sampler_deref = s);
-      } else {
-         val = build_tex_resolve(b, t, nir_f2u32(b, src_coord),
-                                 key->src_samples, resolve_mode);
-      }
+      nir_def *val = resolve_mode == VK_RESOLVE_MODE_NONE ?
+                     nir_txl(b, src_coord, nir_imm_float(b, 0), .texture_deref = t, .sampler_deref = s) :
+                     build_tex_resolve(b, t, nir_f2u32(b, src_coord), key->src_samples, resolve_mode);
       val = nir_trim_vector(b, val, out_comps);
 
       if (key->stencil_as_discard) {
diff --git a/src/vulkan/runtime/vk_meta_clear.c b/src/vulkan/runtime/vk_meta_clear.c
index 6f921d0932415..c763880dcb55f 100644
--- a/src/vulkan/runtime/vk_meta_clear.c
+++ b/src/vulkan/runtime/vk_meta_clear.c
@@ -549,14 +549,11 @@ clear_image_level(struct vk_command_buffer *cmd,
 {
    const VkExtent3D level_extent = vk_image_mip_level_extent(image, level);
 
-   uint32_t base_array_layer, layer_count;
-   if (image->image_type == VK_IMAGE_TYPE_3D) {
-      base_array_layer = 0;
-      layer_count = level_extent.depth;
-   } else {
-      base_array_layer = range->baseArrayLayer;
-      layer_count = vk_image_subresource_layer_count(image, range);
-   }
+   const uint32_t base_array_layer =
+      image->image_type == VK_IMAGE_TYPE_3D ? 0 : range->baseArrayLayer;
+   const uint32_t layer_count =
+      image->image_type == VK_IMAGE_TYPE_3D ? level_extent.depth :
+                                              vk_image_subresource_layer_count(image, range);
 
    if (layer_count > 1 && !meta->use_layered_rendering) {
       for (uint32_t a = 0; a < layer_count; a++) {
diff --git a/src/vulkan/runtime/vk_meta_copy_fill_update.c b/src/vulkan/runtime/vk_meta_copy_fill_update.c
index cb836121d0188..5dbcb90fdf897 100644
--- a/src/vulkan/runtime/vk_meta_copy_fill_update.c
+++ b/src/vulkan/runtime/vk_meta_copy_fill_update.c
@@ -1985,17 +1985,9 @@ copy_image_prepare_compute_push_const(
 
    struct vk_meta_copy_image_cs_info info = {0};
 
-   /* We can't necessarily optimize the read+write path, so align things
-    * on the biggest tile size. */
-   if (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE) {
-      info.copy_id_range.start.x = src_offs.x % key->wg_size[0];
-      info.copy_id_range.start.y = src_offs.y % key->wg_size[1];
-      info.copy_id_range.start.z = src_offs.z % key->wg_size[2];
-   } else {
-      info.copy_id_range.start.x = dst_offs.x % key->wg_size[0];
-      info.copy_id_range.start.y = dst_offs.y % key->wg_size[1];
-      info.copy_id_range.start.z = dst_offs.z % key->wg_size[2];
-   }
+   info.copy_id_range.start.x = (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE ? src_offs.x : dst_offs.x) % key->wg_size[0];
+   info.copy_id_range.start.y = (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE ? src_offs.y : dst_offs.y) % key->wg_size[1];
+   info.copy_id_range.start.z = (align_policy == VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE ? src_offs.z : dst_offs.z) % key->wg_size[2];
 
    info.copy_id_range.end.x = info.copy_id_range.start.x + src_extent.width;
    info.copy_id_range.end.y = info.copy_id_range.start.y + src_extent.height;
@@ -2230,18 +2222,14 @@ copy_image_region_compute(struct vk_command_buffer *cmd,
                                dst_props->tile_size.height *
                                dst_props->tile_size.depth;
    enum vk_meta_copy_image_align_policy align_policy;
+   bool align_on_src = src_pix_per_tile >= dst_pix_per_tile;
+
+   key.wg_size[0] = align_on_src ? src_props->tile_size.width : dst_props->tile_size.width;
+   key.wg_size[1] = align_on_src ? src_props->tile_size.height : dst_props->tile_size.height;
+   key.wg_size[2] = align_on_src ? src_props->tile_size.depth : dst_props->tile_size.depth;
+   align_policy = align_on_src ? VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE :
+                                 VK_META_COPY_IMAGE_ALIGN_ON_DST_TILE;
 
-   if (src_pix_per_tile >= dst_pix_per_tile) {
-      key.wg_size[0] = src_props->tile_size.width;
-      key.wg_size[1] = src_props->tile_size.height;
-      key.wg_size[2] = src_props->tile_size.depth;
-      align_policy = VK_META_COPY_IMAGE_ALIGN_ON_SRC_TILE;
-   } else {
-      key.wg_size[0] = dst_props->tile_size.width;
-      key.wg_size[1] = dst_props->tile_size.height;
-      key.wg_size[2] = dst_props->tile_size.depth;
-      align_policy = VK_META_COPY_IMAGE_ALIGN_ON_DST_TILE;
-   }
 
    VkPipelineLayout pipeline_layout;
    VkPipeline pipeline;
@@ -2322,16 +2310,9 @@ build_copy_buffer_shader(const struct vk_meta_device *meta,
    b->shader->info.workgroup_size[1] = 1;
    b->shader->info.workgroup_size[2] = 1;
 
-   uint32_t chunk_bit_size, chunk_comp_count;
-
    assert(util_is_power_of_two_nonzero(key->chunk_size));
-   if (key->chunk_size <= 4) {
-      chunk_bit_size = key->chunk_size * 8;
-      chunk_comp_count = 1;
-   } else {
-      chunk_bit_size = 32;
-      chunk_comp_count = key->chunk_size / 4;
-   }
+   uint32_t chunk_bit_size = key->chunk_size <= 4 ? key->chunk_size * 8 : 32;
+   uint32_t chunk_comp_count = key->chunk_size <= 4 ? 1 : key->chunk_size / 4;
 
    assert(chunk_comp_count < NIR_MAX_VEC_COMPONENTS);
 
diff --git a/src/vulkan/runtime/vk_nir_convert_ycbcr.c b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
index cf07dfaff8c43..ac5230e3be6b1 100644
--- a/src/vulkan/runtime/vk_nir_convert_ycbcr.c
+++ b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
@@ -190,15 +190,13 @@ implicit_downsampled_coords(struct ycbcr_state *state,
    int c;
 
    for (c = 0; c < ARRAY_SIZE(conversion->chroma_offsets); c++) {
-      if (format_plane->denominator_scales[c] > 1 &&
-          conversion->chroma_offsets[c] == VK_CHROMA_LOCATION_COSITED_EVEN) {
-         comp[c] = implicit_downsampled_coord(b,
-                                              nir_channel(b, old_coords, c),
-                                              nir_channel(b, image_size, c),
-                                              format_plane->denominator_scales[c]);
-      } else {
-         comp[c] = nir_channel(b, old_coords, c);
-      }
+      comp[c] = (format_plane->denominator_scales[c] > 1 &&
+                 conversion->chroma_offsets[c] == VK_CHROMA_LOCATION_COSITED_EVEN) ?
+                implicit_downsampled_coord(b,
+                                           nir_channel(b, old_coords, c),
+                                           nir_channel(b, image_size, c),
+                                           format_plane->denominator_scales[c]) :
+                nir_channel(b, old_coords, c);
    }
 
    /* Leave other coordinates untouched */
@@ -401,13 +399,8 @@ lower_ycbcr_tex_instr(nir_builder *b, nir_instr *instr, void *_state)
       };
       const VkComponentSwizzle m = conversion->mapping[i];
 
-      if (m == VK_COMPONENT_SWIZZLE_IDENTITY) {
-         swizzled_comp[i] = ycbcr_comp[i];
-         swizzled_bpcs[i] = ycbcr_bpcs[i];
-      } else {
-         swizzled_comp[i] = ycbcr_comp[swizzle_mapping[m]];
-         swizzled_bpcs[i] = ycbcr_bpcs[swizzle_mapping[m]];
-      }
+      swizzled_comp[i] = (m == VK_COMPONENT_SWIZZLE_IDENTITY) ? ycbcr_comp[i] : ycbcr_comp[swizzle_mapping[m]];
+      swizzled_bpcs[i] = (m == VK_COMPONENT_SWIZZLE_IDENTITY) ? ycbcr_bpcs[i] : ycbcr_bpcs[swizzle_mapping[m]];
    }
 
    nir_def *result = nir_vec(b, swizzled_comp, 4);
diff --git a/src/vulkan/runtime/vk_pipeline_cache.c b/src/vulkan/runtime/vk_pipeline_cache.c
index 97f184c1bc700..a3d2c56f8adc0 100644
--- a/src/vulkan/runtime/vk_pipeline_cache.c
+++ b/src/vulkan/runtime/vk_pipeline_cache.c
@@ -731,11 +731,7 @@ vk_common_GetPipelineCacheData(VkDevice _device,
    VK_FROM_HANDLE(vk_pipeline_cache, cache, pipelineCache);
 
    struct blob blob;
-   if (pData) {
-      blob_init_fixed(&blob, pData, *pDataSize);
-   } else {
-      blob_init_fixed(&blob, NULL, SIZE_MAX);
-   }
+   blob_init_fixed(&blob, pData ? pData : NULL, pData ? *pDataSize : SIZE_MAX);
 
    blob_write_bytes(&blob, &cache->header, sizeof(cache->header));
 
diff --git a/src/vulkan/runtime/vk_queue.c b/src/vulkan/runtime/vk_queue.c
index 3d08a6a865d98..73198765f7f47 100644
--- a/src/vulkan/runtime/vk_queue.c
+++ b/src/vulkan/runtime/vk_queue.c
@@ -1207,13 +1207,9 @@ vk_common_QueueSubmit2(VkQueue _queue,
    if (vk_device_is_lost(queue->base.device))
       return VK_ERROR_DEVICE_LOST;
 
-   if (submitCount == 0) {
-      if (fence == NULL) {
-         return VK_SUCCESS;
-      } else {
-         return vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
-      }
-   }
+   if (submitCount == 0)
+      return fence == NULL ? VK_SUCCESS :
+             vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
 
    struct vk_queue_submit *last_submit = NULL;
    for (uint32_t i = 0; i < submitCount; i++) {
@@ -1259,13 +1255,9 @@ vk_common_QueueBindSparse(VkQueue _queue,
    if (vk_device_is_lost(queue->base.device))
       return VK_ERROR_DEVICE_LOST;
 
-   if (bindInfoCount == 0) {
-      if (fence == NULL) {
-         return VK_SUCCESS;
-      } else {
-         return vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
-      }
-   }
+   if (bindInfoCount == 0)
+      return fence == NULL ? VK_SUCCESS :
+             vk_queue_signal_sync(queue, vk_fence_get_active_sync(fence), 0);
 
    struct vk_queue_submit *last_submit = NULL;
    for (uint32_t i = 0; i < bindInfoCount; i++) {
diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 0e588a19379aa..9007b9441e90e 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1887,19 +1887,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
          color_attachment->loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
       }
 
-      if (!(subpass->view_mask & ~sp_att->last_subpass)) {
-         /* This is the last subpass for every view */
-         color_attachment->storeOp = rp_att->store_op;
-      } else {
-         /* For at least one of our views, this isn't the last subpass
-          *
-          * In the edge case where we have lots of weird overlap between view
-          * masks of different subThis may mean that we get STORE_OP_STORE in
-          * some places where it may have wanted STORE_OP_NONE but that should
-          * be harmless.
-          */
-         color_attachment->storeOp = VK_ATTACHMENT_STORE_OP_STORE;
-      }
+      color_attachment->storeOp = (subpass->view_mask & ~sp_att->last_subpass) ? rp_att->store_op : VK_ATTACHMENT_STORE_OP_STORE;
 
       if (sp_att->resolve != NULL) {
          assert(sp_att->resolve->attachment < pass->attachment_count);
@@ -2009,21 +1997,12 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
          stencil_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
       }
 
-      if (!(subpass->view_mask & ~sp_att->last_subpass)) {
-         /* This is the last subpass for every view */
-         depth_attachment.storeOp = rp_att->store_op;
-         stencil_attachment.storeOp = rp_att->stencil_store_op;
-      } else {
-         /* For at least one of our views, this isn't the last subpass
-          *
-          * In the edge case where we have lots of weird overlap between view
-          * masks of different subThis may mean that we get STORE_OP_STORE in
-          * some places where it may have wanted STORE_OP_NONE but that should
-          * be harmless.
-          */
-         depth_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
-         stencil_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
-      }
+      depth_attachment.storeOp =
+         (subpass->view_mask & ~sp_att->last_subpass) ?
+         VK_ATTACHMENT_STORE_OP_STORE : rp_att->store_op;
+      stencil_attachment.storeOp =
+         (subpass->view_mask & ~sp_att->last_subpass) ?
+         VK_ATTACHMENT_STORE_OP_STORE : rp_att->stencil_store_op;
 
       /* From the Vulkan 1.3.212 spec:
        *
@@ -2545,12 +2524,10 @@ vk_common_CmdBeginRenderPass2(VkCommandBuffer commandBuffer,
    cmd_buffer->render_area = pRenderPassBeginInfo->renderArea;
 
    assert(cmd_buffer->attachments == NULL);
-   if (pass->attachment_count > ARRAY_SIZE(cmd_buffer->_attachments)) {
-      cmd_buffer->attachments = malloc(pass->attachment_count *
-                                       sizeof(*cmd_buffer->attachments));
-   } else {
-      cmd_buffer->attachments = cmd_buffer->_attachments;
-   }
+   cmd_buffer->attachments =
+      pass->attachment_count > ARRAY_SIZE(cmd_buffer->_attachments) ?
+      malloc(pass->attachment_count * sizeof(*cmd_buffer->attachments)) :
+      cmd_buffer->_attachments;
 
    const VkRenderPassAttachmentBeginInfo *attach_begin =
       vk_find_struct_const(pRenderPassBeginInfo,
diff --git a/src/vulkan/runtime/vk_semaphore.c b/src/vulkan/runtime/vk_semaphore.c
index 534eaa76457cc..940038700d172 100644
--- a/src/vulkan/runtime/vk_semaphore.c
+++ b/src/vulkan/runtime/vk_semaphore.c
@@ -96,13 +96,10 @@ get_semaphore_sync_type(struct vk_physical_device *pdevice,
    assert(semaphore_type == VK_SEMAPHORE_TYPE_BINARY ||
           semaphore_type == VK_SEMAPHORE_TYPE_TIMELINE);
 
-   enum vk_sync_features req_features = VK_SYNC_FEATURE_GPU_WAIT;
-   if (semaphore_type == VK_SEMAPHORE_TYPE_TIMELINE) {
-      req_features |= VK_SYNC_FEATURE_TIMELINE |
-                      VK_SYNC_FEATURE_CPU_WAIT;
-   } else {
-      req_features |= VK_SYNC_FEATURE_BINARY;
-   }
+   enum vk_sync_features req_features = VK_SYNC_FEATURE_GPU_WAIT |
+      (semaphore_type == VK_SEMAPHORE_TYPE_TIMELINE ?
+       (VK_SYNC_FEATURE_TIMELINE | VK_SYNC_FEATURE_CPU_WAIT) :
+       VK_SYNC_FEATURE_BINARY);
 
    for (const struct vk_sync_type *const *t =
         pdevice->supported_sync_types; *t; t++) {
diff --git a/src/vulkan/runtime/vk_video.c b/src/vulkan/runtime/vk_video.c
index 942e90a4d17fa..4bcf7821c7eb6 100644
--- a/src/vulkan/runtime/vk_video.c
+++ b/src/vulkan/runtime/vk_video.c
@@ -107,15 +107,11 @@ vk_video_session_init(struct vk_device *device,
          vk_find_struct_const(create_info->pVideoProfile->pNext, VIDEO_ENCODE_USAGE_INFO_KHR);
       const struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR *intra_refresh =
          vk_find_struct_const(create_info->pNext, VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR);
-      if (encode_usage_profile) {
-         vid->enc_usage.video_usage_hints = encode_usage_profile->videoUsageHints;
-         vid->enc_usage.video_content_hints = encode_usage_profile->videoContentHints;
-         vid->enc_usage.tuning_mode = encode_usage_profile->tuningMode;
-      } else {
-         vid->enc_usage.video_usage_hints = VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR;
-         vid->enc_usage.video_content_hints = VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR;
-         vid->enc_usage.tuning_mode = VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR;
-      }
+
+      vid->enc_usage.video_usage_hints = encode_usage_profile ? encode_usage_profile->videoUsageHints : VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR;
+      vid->enc_usage.video_content_hints = encode_usage_profile ? encode_usage_profile->videoContentHints : VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR;
+      vid->enc_usage.tuning_mode = encode_usage_profile ? encode_usage_profile->tuningMode : VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR;
+
       if (intra_refresh)
          vid->intra_refresh_mode = intra_refresh->intraRefreshMode;
    }
@@ -1274,11 +1270,7 @@ h265_pred_weight_table(struct vk_video_h265_slice_params *params,
    }
 
    for (i = 0; i < params->num_ref_idx_l0_active; ++i) {
-      if (chroma_array_type == 0) {
-         params->chroma_weight_l0_flag[i] = 0;
-      } else {
-         params->chroma_weight_l0_flag[i] = vl_rbsp_u(rbsp, 1);
-      }
+      params->chroma_weight_l0_flag[i] = (chroma_array_type == 0) ? 0 : vl_rbsp_u(rbsp, 1);
    }
 
    for (i = 0; i < params->num_ref_idx_l0_active; ++i) {
@@ -1316,11 +1308,7 @@ h265_pred_weight_table(struct vk_video_h265_slice_params *params,
       }
 
       for (i = 0; i < params->num_ref_idx_l1_active; ++i) {
-         if (chroma_array_type == 0) {
-            params->chroma_weight_l1_flag[i] = 0;
-         } else {
-            params->chroma_weight_l1_flag[i] = vl_rbsp_u(rbsp, 1);
-         }
+         params->chroma_weight_l1_flag[i] = (chroma_array_type == 0) ? 0 : vl_rbsp_u(rbsp, 1);
       }
 
       for (i = 0; i < params->num_ref_idx_l1_active; ++i) {
-- 
GitLab


From a80876a750f3ceb105787244ea5ff77e994e7df7 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 15:05:03 +0300
Subject: [PATCH 16/31] vulkan: align generated structures from Python

---
 src/vulkan/util/vk_cmd_queue_gen.py           | 77 +++++++++++++++++-
 .../util/vk_physical_device_properties_gen.py | 78 ++++++++++++++++++-
 2 files changed, 153 insertions(+), 2 deletions(-)

diff --git a/src/vulkan/util/vk_cmd_queue_gen.py b/src/vulkan/util/vk_cmd_queue_gen.py
index b2b75ac5d58b0..170a9c588fa7c 100644
--- a/src/vulkan/util/vk_cmd_queue_gen.py
+++ b/src/vulkan/util/vk_cmd_queue_gen.py
@@ -119,7 +119,7 @@ extern size_t vk_cmd_queue_type_sizes[];
 #ifdef ${c.guard}
 % endif
 struct ${to_struct_name(c.name)} {
-% for p in c.params[1:]:
+% for p in align_structure_fields(c.params[1:]):
    ${to_field_decl(p.decl)};
 % endfor
 };
@@ -443,6 +443,80 @@ def to_field_decl(decl):
     [decl, name] = decl.rsplit(' ', 1)
     return decl + ' ' + to_field_name(name)
 
+def align_structure_fields(params):
+    """
+    Aligns structure fields for x64 architecture.
+    This function reorders fields to minimize padding and ensures proper alignment.
+    """
+    type_sizes = {
+        'char': 1,
+        'int8_t': 1,
+        'uint8_t': 1,
+        'int16_t': 2,
+        'uint16_t': 2,
+        'VkAccessFlags': 4,
+        'VkBlendFactor': 4,
+        'VkBlendOp': 4,
+        'VkBool32': 4,
+        'VkBorderColor': 4,
+        'VkCompareOp': 4,
+        'VkCullModeFlags': 4,
+        'VkDescriptorUpdateTemplateType': 4,
+        'VkFilter': 4,
+        'VkFlags': 4,
+        'VkFormat': 4,
+        'VkImageAspectFlags': 4,
+        'VkImageLayout': 4,
+        'VkImageUsageFlags': 4,
+        'VkLogicOp': 4,
+        'VkMemoryPropertyFlags': 4,
+        'VkPhysicalDeviceType': 4,
+        'VkPipelineBindPoint': 4,
+        'VkPipelineStageFlagBits': 4,
+        'VkPipelineStageFlags': 4,
+        'VkQueryPipelineStatisticFlags': 4,
+        'VkQueueFlags': 4,
+        'VkResult': 4,
+        'VkSampleCountFlags': 4,
+        'VkSamplerMipmapMode': 4,
+        'VkStencilOp': 4,
+        'VkStructureType': 4,
+        'float': 4,
+        'int32_t': 4,
+        'uint32_t': 4,
+        'VkExtent2D': 8,
+        'VkBuffer': 8,
+        'VkBufferUsageFlags': 4,
+        'VkDeviceAddress': 8,
+        'VkDeviceOrHostAddressConstAMDX': 8,
+        'VkDeviceSize': 8,
+        'VkImage': 8,
+        'VkOffset2D': 8,
+        'VkPipeline': 8,
+        'VkPipelineLayout': 8,
+        'VkQueryPool': 8,
+        'double': 8,
+        'int64_t': 8,
+        'uint64_t': 8,
+        'void*': 8,
+    }
+
+
+    def get_param_size(param):
+        # Heuristic to determine size based on type name and pointers
+        if '*' in param.decl or 'const*' in param.decl:
+            return 8  # Pointers are 8 bytes on x64
+        for type_name, size in type_sizes.items():
+            if type_name in param.decl:
+                return size
+        return 4 # Default to 4 bytes for unknown types (e.g., enums, handles)
+
+    sized_params = [(get_param_size(p), p) for p in params]
+    sized_params.sort(key=lambda x: x[0], reverse=True)
+    aligned_params = [p for size, p in sized_params]
+
+    return aligned_params
+
 def to_enum_name(name):
     return "VK_%s" % to_underscore(name).upper()
 
@@ -772,6 +846,7 @@ def main():
         'to_struct_field_name': to_struct_field_name,
         'to_field_name': to_field_name,
         'to_field_decl': to_field_decl,
+        'align_structure_fields': align_structure_fields,
         'to_enum_name': to_enum_name,
         'to_struct_name': to_struct_name,
         'get_params_copy': get_params_copy,
diff --git a/src/vulkan/util/vk_physical_device_properties_gen.py b/src/vulkan/util/vk_physical_device_properties_gen.py
index 5af1c17803154..5a983d167e253 100644
--- a/src/vulkan/util/vk_physical_device_properties_gen.py
+++ b/src/vulkan/util/vk_physical_device_properties_gen.py
@@ -161,7 +161,7 @@ extern "C" {
 #endif
 
 struct vk_properties {
-% for prop in all_properties:
+% for prop in align_structure_fields(all_properties):
    ${prop.decl};
 % endfor
 };
@@ -330,6 +330,81 @@ def get_property_structs(doc, api, beta):
 
     return property_structs.values()
 
+def align_structure_fields(params):
+    """
+    Aligns structure fields for x64 architecture.
+    This function reorders fields to minimize padding and ensures proper alignment.
+    """
+    type_sizes = {
+        'char': 1,
+        'int8_t': 1,
+        'uint8_t': 1,
+        'int16_t': 2,
+        'uint16_t': 2,
+        'VkAccessFlags': 4,
+        'VkBlendFactor': 4,
+        'VkBlendOp': 4,
+        'VkBool32': 4,
+        'VkBorderColor': 4,
+        'VkCompareOp': 4,
+        'VkCullModeFlags': 4,
+        'VkDescriptorUpdateTemplateType': 4,
+        'VkFilter': 4,
+        'VkFlags': 4,
+        'VkFormat': 4,
+        'VkImageAspectFlags': 4,
+        'VkImageLayout': 4,
+        'VkImageUsageFlags': 4,
+        'VkLogicOp': 4,
+        'VkMemoryPropertyFlags': 4,
+        'VkPhysicalDeviceType': 4,
+        'VkPipelineBindPoint': 4,
+        'VkPipelineStageFlagBits': 4,
+        'VkPipelineStageFlags': 4,
+        'VkQueryPipelineStatisticFlags': 4,
+        'VkQueueFlags': 4,
+        'VkResult': 4,
+        'VkSampleCountFlags': 4,
+        'VkSamplerMipmapMode': 4,
+        'VkStencilOp': 4,
+        'VkStructureType': 4,
+        'float': 4,
+        'int32_t': 4,
+        'uint32_t': 4,
+        'VkBufferUsageFlags': 4,
+        'VkExtent2D': 8,
+        'VkBuffer': 8,
+        'VkDeviceAddress': 8,
+        'VkDeviceOrHostAddressConstAMDX': 8,
+        'VkDeviceSize': 8,
+        'VkImage': 8,
+        'VkOffset2D': 8,
+        'VkPipeline': 8,
+        'VkPipelineLayout': 8,
+        'VkQueryPool': 8,
+        'double': 8,
+        'int64_t': 8,
+        'uint64_t': 8,
+        'size_t': 8,
+        'void*': 8,
+    }
+
+
+    def get_param_size(param):
+        # Heuristic to determine size based on type name and pointers
+        if '*' in param.decl or 'const*' in param.decl:
+            return 8  # Pointers are 8 bytes on x64
+        for type_name, size in type_sizes.items():
+            if type_name in param.decl:
+                return size
+        return 4 # Default to 4 bytes for unknown types (e.g., enums, handles)
+
+    sized_params = [(get_param_size(p), p) for p in params]
+    sized_params.sort(key=lambda x: x[0], reverse=True)
+    aligned_params = [p for size, p in sized_params]
+
+    return aligned_params
+
 def get_property_structs_from_xml(xml_files, beta, api="vulkan"):
     diagnostics = []
 
@@ -388,6 +463,7 @@ def main():
         "pdev_properties": pdev_properties,
         "property_structs": property_structs,
         "all_properties": all_properties,
+        "align_structure_fields": align_structure_fields,
         "copy_property": copy_property,
         "SPECIALIZED_PROPERTY_STRUCTS": SPECIALIZED_PROPERTY_STRUCTS,
     }
-- 
GitLab


From 3f53828652e55a7974a966abed5cff6ad7e49b3a Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:14:00 +0300
Subject: [PATCH 18/31] vulkan: duplicate pow() better move to local variable

---
 src/vulkan/runtime/vk_nir_convert_ycbcr.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/vulkan/runtime/vk_nir_convert_ycbcr.c b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
index ac5230e3be6b1..5e47c113e4b08 100644
--- a/src/vulkan/runtime/vk_nir_convert_ycbcr.c
+++ b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
@@ -39,12 +39,13 @@ y_range(nir_builder *b,
    case VK_SAMPLER_YCBCR_RANGE_ITU_FULL:
       return y_channel;
    case VK_SAMPLER_YCBCR_RANGE_ITU_NARROW:
+      float fpow = pow(2, bpc - 8);
       return nir_fmul_imm(b,
                           nir_fadd_imm(b,
                                        nir_fmul_imm(b, y_channel,
                                                     pow(2, bpc) - 1),
-                                       -16.0f * pow(2, bpc - 8)),
-                          1.0f / (219.0f * pow(2, bpc - 8)));
+                                       -16.0f * fpow),
+                          1.0f / (219.0f * fpow));
 
    default:
       UNREACHABLE("missing Ycbcr range");
@@ -63,12 +64,13 @@ chroma_range(nir_builder *b,
       return nir_fadd(b, chroma_channel,
                       nir_imm_float(b, -pow(2, bpc - 1) / (pow(2, bpc) - 1.0f)));
    case VK_SAMPLER_YCBCR_RANGE_ITU_NARROW:
+      float fpow = pow(2, bpc - 8);
       return nir_fmul_imm(b,
                           nir_fadd_imm(b,
                                        nir_fmul_imm(b, chroma_channel,
                                                     pow(2, bpc) - 1),
-                                       -128.0f * pow(2, bpc - 8)),
-                          1.0f / (224.0f * pow(2, bpc - 8)));
+                                       -128.0f * fpow),
+                          1.0f / (224.0f * fpow));
    default:
       UNREACHABLE("missing Ycbcr range");
       return NULL;
-- 
GitLab


From 3f763657aded946488a9ed3b99c7286b40947de0 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:17:08 +0300
Subject: [PATCH 19/31] amd/intel/gallium/compiler: strict set de/constructors
 as default

Reference: https://stackoverflow.com/questions/59261490/why-is-there-performance-variation-using-default-constructor-instead-of
---
 src/amd/compiler/aco_insert_delay_alu.cpp          | 2 +-
 src/amd/compiler/aco_insert_waitcnt.cpp            | 2 +-
 src/compiler/clc/clc_helpers.cpp                   | 4 ++--
 src/compiler/glsl/ast.h                            | 2 +-
 src/compiler/glsl/glsl_parser_extras.cpp           | 8 ++------
 src/gallium/auxiliary/gallivm/lp_bld_misc.cpp      | 3 +--
 src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp | 5 +----
 src/gallium/drivers/r600/sfn/sfn_callstack.cpp     | 2 +-
 src/intel/compiler/brw_generator.cpp               | 4 +---
 src/intel/compiler/elk/elk_fs_generator.cpp        | 4 +---
 src/intel/compiler/elk/elk_ir.h                    | 2 +-
 src/mesa/main/texcompress_astc.cpp                 | 2 +-
 12 files changed, 14 insertions(+), 26 deletions(-)

diff --git a/src/amd/compiler/aco_insert_delay_alu.cpp b/src/amd/compiler/aco_insert_delay_alu.cpp
index 1b5042839ba68..fd188746ed869 100644
--- a/src/amd/compiler/aco_insert_delay_alu.cpp
+++ b/src/amd/compiler/aco_insert_delay_alu.cpp
@@ -109,7 +109,7 @@ struct delay_ctx {
    Program* program;
    std::map<PhysReg, alu_delay_info> gpr_map;
 
-   delay_ctx() {}
+   delay_ctx() = default;
    delay_ctx(Program* program_) : program(program_) {}
 
    UNUSED void print(FILE* output) const
diff --git a/src/amd/compiler/aco_insert_waitcnt.cpp b/src/amd/compiler/aco_insert_waitcnt.cpp
index 97cf9229255ba..39a342b9b4618 100644
--- a/src/amd/compiler/aco_insert_waitcnt.cpp
+++ b/src/amd/compiler/aco_insert_waitcnt.cpp
@@ -232,7 +232,7 @@ struct wait_ctx {
 
    std::map<PhysReg, wait_entry> gpr_map;
 
-   wait_ctx() {}
+   wait_ctx() = default;
    wait_ctx(Program* program_, const target_info* info_)
        : program(program_), gfx_level(program_->gfx_level), info(info_)
    {}
diff --git a/src/compiler/clc/clc_helpers.cpp b/src/compiler/clc/clc_helpers.cpp
index 7e23effca39c6..61b771b5497a7 100644
--- a/src/compiler/clc/clc_helpers.cpp
+++ b/src/compiler/clc/clc_helpers.cpp
@@ -129,7 +129,7 @@ public:
                                                   addrQualifier(CLC_KERNEL_ARG_ADDRESS_PRIVATE),
                                                   accessQualifier(0),
                                                   typeQualifier(0) { }
-   ~SPIRVKernelArg() { }
+   ~SPIRVKernelArg() = default;
 
    uint32_t id;
    uint32_t typeId;
@@ -144,7 +144,7 @@ class SPIRVKernelInfo {
 public:
    SPIRVKernelInfo(uint32_t fid, const char *nm)
       : funcId(fid), name(nm), vecHint(0), localSize(), localSizeHint() { }
-   ~SPIRVKernelInfo() { }
+   ~SPIRVKernelInfo() = default;
 
    uint32_t funcId;
    std::string name;
diff --git a/src/compiler/glsl/ast.h b/src/compiler/glsl/ast.h
index be639118c2b55..ea194df01bb4f 100644
--- a/src/compiler/glsl/ast.h
+++ b/src/compiler/glsl/ast.h
@@ -1246,7 +1246,7 @@ public:
 
 class ast_demote_statement : public ast_node {
 public:
-   ast_demote_statement(void) {}
+   ast_demote_statement(void) = default;
    virtual void print(void) const;
 
    virtual ir_rvalue *hir(ir_exec_list *instructions,
diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index ce9e4efea3451..9f0803fe2b2a2 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -1776,9 +1776,7 @@ void ast_case_label_list::print(void) const
 }
 
 
-ast_case_label_list::ast_case_label_list(void)
-{
-}
+ast_case_label_list::ast_case_label_list(void) = default;
 
 
 void ast_case_statement::print(void) const
@@ -1805,9 +1803,7 @@ void ast_case_statement_list::print(void) const
 }
 
 
-ast_case_statement_list::ast_case_statement_list(void)
-{
-}
+ast_case_statement_list::ast_case_statement_list(void) = default;
 
 
 void
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
index 29062bbfc1769..3a5b132d93cbd 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
+++ b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
@@ -245,8 +245,7 @@ class ShaderMemoryManager : public DelegatingJITMemoryManager {
          TheMM = MM;
       }
 
-      ~GeneratedCode() {
-      }
+      ~GeneratedCode() = default;
    };
 
    GeneratedCode *code;
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
index d6bec119750f2..8533a410d8aa8 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_bb.cpp
@@ -85,10 +85,7 @@ BasicBlock::BasicBlock(Function *fn) : cfg(this), dom(this), func(fn)
    func->add(this, this->id);
 }
 
-BasicBlock::~BasicBlock()
-{
-   // nothing yet
-}
+BasicBlock::~BasicBlock() = default;
 
 BasicBlock *
 BasicBlock::clone(ClonePolicy<Function>& pol) const
diff --git a/src/gallium/drivers/r600/sfn/sfn_callstack.cpp b/src/gallium/drivers/r600/sfn/sfn_callstack.cpp
index 90f5d5e98dac2..abaabf137c818 100644
--- a/src/gallium/drivers/r600/sfn/sfn_callstack.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_callstack.cpp
@@ -13,7 +13,7 @@ CallStack::CallStack(r600_bytecode& bc):
 {
 }
 
-CallStack::~CallStack() {}
+CallStack::~CallStack() = default;
 
 int
 CallStack::push(unsigned type)
diff --git a/src/mesa/main/texcompress_astc.cpp b/src/mesa/main/texcompress_astc.cpp
index 4f8f4f50922bc..a206b38637d08 100644
--- a/src/mesa/main/texcompress_astc.cpp
+++ b/src/mesa/main/texcompress_astc.cpp
@@ -210,7 +210,7 @@ struct uint8x4_t
 {
    uint8_t v[4];
 
-   uint8x4_t() { }
+   uint8x4_t() = default;
 
    uint8x4_t(int a, int b, int c, int d)
    {
-- 
GitLab


From fa12348ffca2ef4d43d19a1cc9508f8f32ef24bf Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Mon, 13 Oct 2025 23:19:18 +0300
Subject: [PATCH 20/31] amd: get value by ptr more faster than .value()

Also above in the code, there is already a pointer retrieval of the same variable.
---
 src/amd/compiler/aco_register_allocation.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index bbb8429032b7a..3396d5359b562 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -1792,7 +1792,7 @@ get_reg_vector(ra_ctx& ctx, const RegisterFile& reg_file, Temp temp, aco_ptr<Ins
          reg->reg_b += our_offset;
          /* make sure to only use byte offset if the instruction supports it */
          if (get_reg_specified(ctx, reg_file, temp.regClass(), instr, *reg, operand)) {
-            ctx.assignments[vec.parts[vec.index].tempId()].set_precolor_affinity(reg.value());
+            ctx.assignments[vec.parts[vec.index].tempId()].set_precolor_affinity(*reg);
             return reg;
          }
       }
-- 
GitLab


From 268d391347b2711a3c036b6225868f9cba6fa595 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 00:29:39 +0300
Subject: [PATCH 26/31] amd/gallium: micro-op replace post-inc to pre-increment

---
 src/amd/compiler/aco_dead_code_analysis.cpp    | 4 ++--
 src/amd/compiler/aco_insert_waitcnt.cpp        | 2 +-
 src/amd/compiler/aco_reduce_assign.cpp         | 4 ++--
 src/amd/compiler/aco_register_allocation.cpp   | 4 ++--
 src/amd/compiler/aco_util.h                    | 4 ++--
 src/gallium/drivers/r600/sfn/sfn_instr.cpp     | 2 +-
 src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp | 2 +-
 7 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_dead_code_analysis.cpp b/src/amd/compiler/aco_dead_code_analysis.cpp
index 2fdddace4fadb..2da1654aab60d 100644
--- a/src/amd/compiler/aco_dead_code_analysis.cpp
+++ b/src/amd/compiler/aco_dead_code_analysis.cpp
@@ -35,7 +35,7 @@ process_loop_header_phis(std::vector<uint16_t>& uses, Block& block)
 void
 process_block(std::vector<uint16_t>& uses, Block& block)
 {
-   for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); it++) {
+   for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); ++it) {
       aco_ptr<Instruction>& instr = *it;
       if ((block.kind & block_kind_loop_header) && is_phi(instr))
          break;
@@ -61,7 +61,7 @@ dead_code_analysis(Program* program)
          process_loop_header_phis(uses, block);
    }
 
-   for (auto it = program->blocks.rbegin(); it != program->blocks.rend(); it++)
+   for (auto it = program->blocks.rbegin(); it != program->blocks.rend(); ++it)
       process_block(uses, *it);
 
    return uses;
diff --git a/src/amd/compiler/aco_insert_waitcnt.cpp b/src/amd/compiler/aco_insert_waitcnt.cpp
index 39a342b9b4618..9ca8043b3e726 100644
--- a/src/amd/compiler/aco_insert_waitcnt.cpp
+++ b/src/amd/compiler/aco_insert_waitcnt.cpp
@@ -627,7 +627,7 @@ kill(wait_imm& imm, depctr_wait& depctr, Instruction* instr, wait_ctx& ctx,
          if (!it->second.counters)
             it = ctx.gpr_map.erase(it);
          else
-            it++;
+            ++it;
       }
    }
 
diff --git a/src/amd/compiler/aco_reduce_assign.cpp b/src/amd/compiler/aco_reduce_assign.cpp
index 11c0d2022e432..646cd0915ba1a 100644
--- a/src/amd/compiler/aco_reduce_assign.cpp
+++ b/src/amd/compiler/aco_reduce_assign.cpp
@@ -96,7 +96,7 @@ setup_reduce_temp(Program* program)
             if (last_top_level_block_idx == block.index) {
                /* insert right before the current instruction */
                it = block.instructions.insert(it, std::move(create));
-               it++;
+               ++it;
                /* inserted_at is intentionally not updated here, so later blocks
                 * would insert at the end instead of using this one. */
             } else {
@@ -144,7 +144,7 @@ setup_reduce_temp(Program* program)
             create->definitions[0] = Definition(vtmp);
             if (last_top_level_block_idx == block.index) {
                it = block.instructions.insert(it, std::move(create));
-               it++;
+               ++it;
             } else {
                assert(last_top_level_block_idx < block.index);
                std::vector<aco_ptr<Instruction>>& instructions =
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 3396d5359b562..3e6e7ef3c9569 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -3043,7 +3043,7 @@ get_affinities(ra_ctx& ctx)
    aco::unordered_map<uint32_t, uint32_t> temp_to_phi_resources(ctx.memory);
 
    for (auto block_rit = ctx.program->blocks.rbegin(); block_rit != ctx.program->blocks.rend();
-        block_rit++) {
+        ++block_rit) {
       Block& block = *block_rit;
 
       std::vector<aco_ptr<Instruction>>::reverse_iterator rit;
@@ -3195,7 +3195,7 @@ get_affinities(ra_ctx& ctx)
          /* find loop header */
          auto header_rit = block_rit;
          while ((header_rit + 1)->loop_nest_depth > block.loop_nest_depth)
-            header_rit++;
+            ++header_rit;
 
          for (aco_ptr<Instruction>& phi : header_rit->instructions) {
             if (!is_phi(phi))
diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 910feb0ca9c75..bff5ee16cde3b 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -536,10 +536,10 @@ struct IDSet {
          if (block.second == block_t{0})
             continue;
          while (it != words.end() && it->second == block_t{0})
-            it++;
+            ++it;
          if (it == words.end() || block != *it)
             return false;
-         it++;
+         ++it;
       }
 
       return true;
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr.cpp b/src/gallium/drivers/r600/sfn/sfn_instr.cpp
index 1b8da634676c1..e46b2cc0a5649 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr.cpp
@@ -93,7 +93,7 @@ sel_and_szw_from_string(const std::string& str, RegisterVec4::Swizzle& swz, bool
    }
 
    assert(*istr == '.');
-   istr++;
+   ++istr;
 
    int i = 0;
    while (istr != str.end()) {
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
index fade2fb15233a..a01cd8ef7a8f8 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
@@ -1122,7 +1122,7 @@ AluInstr::from_string(istream& is, ValueFactory& value_factory, AluGroup *group,
 
    if (*t == "LDS") {
       is_lds = true;
-      t++;
+      ++t;
    }
 
    string opstr = *t++;
-- 
GitLab


From 5ed472808e05ee860c77a835c6b3492085a04636 Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:25:42 +0300
Subject: [PATCH 27/31] vulkan: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

---
 src/vulkan/runtime/vk_graphics_state.h | 30 +++++++++++++-------------
 src/vulkan/runtime/vk_pipeline.c       |  4 ++--
 src/vulkan/runtime/vk_pipeline.h       |  2 +-
 src/vulkan/runtime/vk_shader.h         |  2 +-
 src/vulkan/runtime/vk_video.h          | 12 +++++------
 src/vulkan/util/vk_util.h              | 12 +++++------
 src/vulkan/wsi/wsi_common.c            |  2 +-
 src/vulkan/wsi/wsi_common_display.c    |  2 +-
 src/vulkan/wsi/wsi_common_wayland.c    |  8 +++----
 9 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/src/vulkan/runtime/vk_graphics_state.h b/src/vulkan/runtime/vk_graphics_state.h
index 2e6d62c41e713..71639f165037a 100644
--- a/src/vulkan/runtime/vk_graphics_state.h
+++ b/src/vulkan/runtime/vk_graphics_state.h
@@ -337,6 +337,12 @@ struct vk_rasterization_state {
        */
       bool enable;
 
+      /** VkDepthBiasRepresentationInfoEXT::depthBiasExact
+       *
+       * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
+       */
+      bool exact;
+
       /** VkPipelineRasterizationStateCreateInfo::depthBiasConstantFactor
        *
        * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
@@ -360,12 +366,6 @@ struct vk_rasterization_state {
        * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
        */
       VkDepthBiasRepresentationEXT representation;
-
-      /** VkDepthBiasRepresentationInfoEXT::depthBiasExact
-       *
-       * MESA_VK_DYNAMIC_RS_DEPTH_BIAS_FACTORS
-       */
-      bool exact;
    } depth_bias;
 
    struct {
@@ -385,18 +385,18 @@ struct vk_rasterization_state {
       VkLineRasterizationModeKHR mode;
 
       struct {
-         /** VkPipelineRasterizationLineStateCreateInfoKHR::stippledLineEnable
-          *
-          * MESA_VK_DYNAMIC_RS_LINE_STIPPLE_ENABLE
-          */
-         bool enable;
-
          /** VkPipelineRasterizationLineStateCreateInfoKHR::lineStippleFactor
           *
           * MESA_VK_DYNAMIC_RS_LINE_STIPPLE
           */
          uint32_t factor;
 
+         /** VkPipelineRasterizationLineStateCreateInfoKHR::stippledLineEnable
+          *
+          * MESA_VK_DYNAMIC_RS_LINE_STIPPLE_ENABLE
+          */
+         bool enable;
+
          /** VkPipelineRasterizationLineStateCreateInfoKHR::lineStipplePattern
           *
           * MESA_VK_DYNAMIC_RS_LINE_STIPPLE
@@ -780,6 +780,9 @@ struct vk_render_pass_state {
    /** VkPipelineRenderingCreateInfo::colorAttachmentCount */
    uint8_t color_attachment_count;
 
+   /** VkAttachmentSampleCountInfoAMD::depthStencilAttachmentSamples */
+   uint8_t depth_stencil_attachment_samples;
+
    /** VkPipelineRenderingCreateInfo::pColorAttachmentFormats */
    VkFormat color_attachment_formats[MESA_VK_MAX_COLOR_ATTACHMENTS];
 
@@ -791,9 +794,6 @@ struct vk_render_pass_state {
 
    /** VkAttachmentSampleCountInfoAMD::pColorAttachmentSamples */
    uint8_t color_attachment_samples[MESA_VK_MAX_COLOR_ATTACHMENTS];
-
-   /** VkAttachmentSampleCountInfoAMD::depthStencilAttachmentSamples */
-   uint8_t depth_stencil_attachment_samples;
 };
 
 static inline bool
diff --git a/src/vulkan/runtime/vk_pipeline.c b/src/vulkan/runtime/vk_pipeline.c
index 4e5baf769a2cc..d6e4452995529 100644
--- a/src/vulkan/runtime/vk_pipeline.c
+++ b/src/vulkan/runtime/vk_pipeline.c
@@ -2342,15 +2342,15 @@ struct vk_rt_stage {
 struct vk_rt_shader_group {
    VkRayTracingShaderGroupTypeKHR type;
 
-   struct vk_rt_stage stages[3];
    uint32_t stage_count;
+   struct vk_rt_stage stages[3];
 };
 
 struct vk_rt_pipeline {
    struct vk_pipeline base;
 
-   uint32_t group_count;
    struct vk_rt_shader_group *groups;
+   uint32_t group_count;
 
    uint32_t stage_count;
    struct vk_rt_stage *stages;
diff --git a/src/vulkan/runtime/vk_pipeline.h b/src/vulkan/runtime/vk_pipeline.h
index ef917bdf4428c..73ed884a79770 100644
--- a/src/vulkan/runtime/vk_pipeline.h
+++ b/src/vulkan/runtime/vk_pipeline.h
@@ -154,8 +154,8 @@ struct vk_pipeline {
    const struct vk_pipeline_ops *ops;
 
    VkPipelineBindPoint bind_point;
-   VkPipelineCreateFlags2KHR flags;
    VkShaderStageFlags stages;
+   VkPipelineCreateFlags2KHR flags;
 };
 
 VK_DEFINE_NONDISP_HANDLE_CASTS(vk_pipeline, base, VkPipeline,
diff --git a/src/vulkan/runtime/vk_shader.h b/src/vulkan/runtime/vk_shader.h
index a2caea1c66773..1fc0146d538d3 100644
--- a/src/vulkan/runtime/vk_shader.h
+++ b/src/vulkan/runtime/vk_shader.h
@@ -89,8 +89,8 @@ struct vk_shader_compile_info {
 
    const struct vk_pipeline_robustness_state *robustness;
 
-   uint32_t set_layout_count;
    struct vk_descriptor_set_layout * const *set_layouts;
+   uint32_t set_layout_count;
 
    uint32_t push_constant_range_count;
    const VkPushConstantRange *push_constant_ranges;
diff --git a/src/vulkan/runtime/vk_video.h b/src/vulkan/runtime/vk_video.h
index 8fb270351d994..ea6ec40252e73 100644
--- a/src/vulkan/runtime/vk_video.h
+++ b/src/vulkan/runtime/vk_video.h
@@ -126,8 +126,8 @@ struct vk_video_session_parameters {
          uint32_t max_h264_pps_count;
 
          uint32_t h264_sps_count;
-         struct vk_video_h264_sps *h264_sps;
          uint32_t h264_pps_count;
+         struct vk_video_h264_sps *h264_sps;
          struct vk_video_h264_pps *h264_pps;
       } h264_dec;
 
@@ -137,10 +137,10 @@ struct vk_video_session_parameters {
          uint32_t max_h265_pps_count;
 
          uint32_t h265_vps_count;
-         struct vk_video_h265_vps *h265_vps;
          uint32_t h265_sps_count;
-         struct vk_video_h265_sps *h265_sps;
          uint32_t h265_pps_count;
+         struct vk_video_h265_vps *h265_vps;
+         struct vk_video_h265_sps *h265_sps;
          struct vk_video_h265_pps *h265_pps;
       } h265_dec;
 
@@ -153,8 +153,8 @@ struct vk_video_session_parameters {
          uint32_t max_h264_pps_count;
 
          uint32_t h264_sps_count;
-         struct vk_video_h264_sps *h264_sps;
          uint32_t h264_pps_count;
+         struct vk_video_h264_sps *h264_sps;
          struct vk_video_h264_pps *h264_pps;
          StdVideoH264ProfileIdc profile_idc;
       } h264_enc;
@@ -165,10 +165,10 @@ struct vk_video_session_parameters {
          uint32_t max_h265_pps_count;
 
          uint32_t h265_vps_count;
-         struct vk_video_h265_vps *h265_vps;
          uint32_t h265_sps_count;
-         struct vk_video_h265_sps *h265_sps;
          uint32_t h265_pps_count;
+         struct vk_video_h265_vps *h265_vps;
+         struct vk_video_h265_sps *h265_sps;
          struct vk_video_h265_pps *h265_pps;
       } h265_enc;
 
diff --git a/src/vulkan/util/vk_util.h b/src/vulkan/util/vk_util.h
index aea4c569a1889..835b4a334baf2 100644
--- a/src/vulkan/util/vk_util.h
+++ b/src/vulkan/util/vk_util.h
@@ -152,18 +152,18 @@ struct __vk_outarray {
     */
    uint32_t cap;
 
-   /**
-    * Count of elements successfully written to the array. Every write is
-    * considered successful if data is null.
-    */
-   uint32_t *filled_len;
-
    /**
     * Count of elements that would have been written to the array if its
     * capacity were sufficient. Vulkan functions often return VK_INCOMPLETE
     * when `*filled_len < wanted_len`.
     */
    uint32_t wanted_len;
+
+   /**
+    * Count of elements successfully written to the array. Every write is
+    * considered successful if data is null.
+    */
+   uint32_t *filled_len;
 };
 
 static inline void
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index d88323a91ed73..f3b81062d93c0 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -1380,8 +1380,8 @@ wsi_queue_submit2_unordered(const struct wsi_device *wsi,
 struct wsi_image_signal_info {
    uint64_t present_id;
    uint32_t semaphore_count;
-   VkSemaphoreSubmitInfo semaphore_infos[2];
    uint32_t fence_count;
+   VkSemaphoreSubmitInfo semaphore_infos[2];
    VkFence fences[2];
 };
 
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 48084ac4cebb4..bb79a4450383e 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -444,9 +444,9 @@ struct wsi_display_fence {
    struct wsi_display           *wsi;
    bool                         event_received;
    bool                         destroyed;
+   bool                         device_event; /* fence is used for device events */
    uint32_t                     syncobj; /* syncobj to signal on event */
    uint64_t                     sequence;
-   bool                         device_event; /* fence is used for device events */
 };
 
 struct wsi_display_sync {
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 351b71481107a..8b7dee076b3b0 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -239,18 +239,18 @@ struct wsi_wl_swapchain {
       struct wl_surface *surface;
       bool dispatch_in_progress;
 
+      bool valid_refresh_nsec;
+      bool frame_fallback;
+      unsigned int refresh_nsec;
       uint64_t display_time_error;
       uint64_t display_time_correction;
       uint64_t last_target_time;
       uint64_t displayed_time;
-      bool valid_refresh_nsec;
-      unsigned int refresh_nsec;
-      bool frame_fallback;
    } present_ids;
 
    struct {
-      VkColorSpaceKHR colorspace;
       VkHdrMetadataEXT hdr_metadata;
+      VkColorSpaceKHR colorspace;
       bool has_hdr_metadata;
    } color;
 
-- 
GitLab

From 57508c85cb2a92645089c1ca51f68129952d8ddf Mon Sep 17 00:00:00 2001
From: Herman Semenoff <GermanAizek@yandex.ru>
Date: Tue, 14 Oct 2025 02:27:46 +0300
Subject: [PATCH 31/31] amd: align for 64-bit platforms (fix cache misses,
 compiler use more SIMD)

---
 src/amd/vpelib/inc/vpe_hw_types.h | 2 +-
 src/amd/vpelib/inc/vpe_types.h    | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/vpelib/inc/vpe_hw_types.h b/src/amd/vpelib/inc/vpe_hw_types.h
index 26fc7cfbffcbe..6b34b25363bc3 100644
--- a/src/amd/vpelib/inc/vpe_hw_types.h
+++ b/src/amd/vpelib/inc/vpe_hw_types.h
@@ -200,9 +200,9 @@ struct vpe_plane_dcc_param {
             bool     independent_64b_blks; /**< DCC independent 64 byte blocks */
             uint8_t  dcc_ind_blk;          /**< DCC independent block size */
 
-            uint32_t meta_pitch_c;         /**< DCC meta surface pitch for chroma plane in bytes */
             bool     independent_64b_blks_c; /**< DCC independent 64 byte blocks for chroma plane */
             uint8_t  dcc_ind_blk_c;          /**< DCC independent block size for chroma plane */
+            uint32_t meta_pitch_c;         /**< DCC meta surface pitch for chroma plane in bytes */
         } src;
 
     };
diff --git a/src/amd/vpelib/inc/vpe_types.h b/src/amd/vpelib/inc/vpe_types.h
index 8736dc806a290..ce11d0351bcd4 100644
--- a/src/amd/vpelib/inc/vpe_types.h
+++ b/src/amd/vpelib/inc/vpe_types.h
@@ -749,11 +749,11 @@ struct vpe_tonemap_params {
     uint16_t                   lut_dim;              /**< Size of one dimension of the 3D-LUT */
     /** @brief 3D LUT settings
      */
+    bool is_dma_lut;   /**< Set to true if the 3D LUT is DMA LUT */
+    bool enable_3dlut; /**< Enable/Disable 3D-LUT */
     union {
         uint16_t *lut_data;                          /**< Accessible to CPU */
     };
-    bool is_dma_lut;   /**< Set to true if the 3D LUT is DMA LUT */
-    bool enable_3dlut; /**< Enable/Disable 3D-LUT */
 };
 
 /** @enum vpe_keyer_mode
@@ -845,8 +845,8 @@ enum predication_polarity {
  *  @brief Predication info
  */
 struct vpe_predication_info {
-    bool                      enable;   /**< Enable predication */
     uint64_t                  gpu_va;   /**< GPU start address of the buffer */
+    bool                      enable;   /**< Enable predication */
     enum predication_polarity polarity; /**< Predication polarity */
 };
 
-- 
GitLab

