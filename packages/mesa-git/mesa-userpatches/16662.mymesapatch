From d1106ae82b898716d0ba25988cd8cb64b27f4de0 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 20 May 2022 17:30:00 +0200
Subject: [PATCH 1/5] dri: store internal_format when known
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

For images created from textures or renderbuffer, the internal
format is known so store it.

This will be used in the next commit to replaces guessing it.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/gallium/frontends/dri/dri2.c        | 1 +
 src/gallium/frontends/dri/dri_helpers.c | 2 ++
 src/gallium/frontends/dri/dri_screen.c  | 2 ++
 src/gallium/frontends/dri/dri_screen.h  | 4 ++++
 4 files changed, 9 insertions(+)

diff --git a/src/gallium/frontends/dri/dri2.c b/src/gallium/frontends/dri/dri2.c
index 611ac5cd0c8c..925dc43547df 100644
--- a/src/gallium/frontends/dri/dri2.c
+++ b/src/gallium/frontends/dri/dri2.c
@@ -1442,6 +1442,7 @@ dri2_dup_image(__DRIimage *image, void *loaderPrivate)
    img->level = image->level;
    img->layer = image->layer;
    img->dri_format = image->dri_format;
+   img->internal_format = image->internal_format;
    /* This should be 0 for sub images, but dup is also used for base images. */
    img->dri_components = image->dri_components;
    img->use = image->use;
diff --git a/src/gallium/frontends/dri/dri_helpers.c b/src/gallium/frontends/dri/dri_helpers.c
index b158808c7929..a399d7bf8057 100644
--- a/src/gallium/frontends/dri/dri_helpers.c
+++ b/src/gallium/frontends/dri/dri_helpers.c
@@ -312,6 +312,7 @@ dri2_create_image_from_renderbuffer2(__DRIcontext *context,
    }
 
    img->dri_format = driGLFormatToImageFormat(rb->Format);
+   img->internal_format = rb->InternalFormat;
    img->loader_private = loaderPrivate;
    img->sPriv = context->driScreenPriv;
    img->in_fence_fd = -1;
@@ -416,6 +417,7 @@ dri2_create_from_texture(__DRIcontext *context, int target, unsigned texture,
    img->layer = depth;
    img->in_fence_fd = -1;
    img->dri_format = driGLFormatToImageFormat(obj->Image[face][level]->TexFormat);
+   img->internal_format = obj->Image[face][level]->InternalFormat;
 
    img->loader_private = loaderPrivate;
    img->sPriv = context->driScreenPriv;
diff --git a/src/gallium/frontends/dri/dri_screen.c b/src/gallium/frontends/dri/dri_screen.c
index f331057fdcb2..be405919e6b0 100644
--- a/src/gallium/frontends/dri/dri_screen.c
+++ b/src/gallium/frontends/dri/dri_screen.c
@@ -745,6 +745,8 @@ dri_get_egl_image(struct st_manager *smapi,
        */
       mesa_format mesa_format = driImageFormatToGLFormat(map->dri_format);
       stimg->internalformat = driGLFormatToSizedInternalGLFormat(mesa_format);
+   } else {
+      stimg->internalformat = img->internal_format;
    }
 
    return TRUE;
diff --git a/src/gallium/frontends/dri/dri_screen.h b/src/gallium/frontends/dri/dri_screen.h
index fc7d63699c4b..52c7182d7a44 100644
--- a/src/gallium/frontends/dri/dri_screen.h
+++ b/src/gallium/frontends/dri/dri_screen.h
@@ -117,6 +117,10 @@ struct __DRIimageRec {
    uint32_t dri_format;
    uint32_t dri_fourcc;
    uint32_t dri_components;
+   /* Provided by eglCreateImageKHR if creating from a
+    * texture or a renderbuffer. 0 otherwise.
+    */
+   uint32_t internal_format;
    unsigned use;
    unsigned plane;
 
-- 
GitLab


diff --git a/src/mesa/state_tracker/st_cb_eglimage.c b/src/mesa/state_tracker/st_cb_eglimage.c
index 0768db8cf7ce..c43151baf587 100644
--- a/src/mesa/state_tracker/st_cb_eglimage.c
+++ b/src/mesa/state_tracker/st_cb_eglimage.c
@@ -271,12 +271,16 @@ st_bind_egl_image(struct gl_context *ctx,
    GLenum internalFormat;
    mesa_format texFormat;
 
-   /* map pipe format to base format */
-   if (util_format_get_component_bits(stimg->format,
-                                      UTIL_FORMAT_COLORSPACE_RGB, 3) > 0)
-      internalFormat = GL_RGBA;
-   else
-      internalFormat = GL_RGB;
+   if (stimg->internalformat) {
+      internalFormat = stimg->internalformat;
+   } else {
+      /* map pipe format to base format */
+      if (util_format_get_component_bits(stimg->format,
+                                         UTIL_FORMAT_COLORSPACE_RGB, 3) > 0)
+         internalFormat = GL_RGBA;
+      else
+         internalFormat = GL_RGB;
+   }
 
    /* switch to surface based */
    if (!texObj->surface_based) {
-- 
GitLab


From 2b12c9917706a1b1ffc58330a440ffd748d7a750 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 20 May 2022 17:09:20 +0200
Subject: [PATCH 3/5] nir/lower_tex: fix lower_yu_yv_external
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Indices were mixed, causing "ext_image_dma_buf_import-sample_yuv -fmt=UYVY"
and "ext_image_dma_buf_import-sample_yuv -fmt=YUYV" to fail on radeonsi.

Fixes: 880b00dc599 ("nir/lower_tex: Add support for lowering YUYV formats")
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/compiler/nir/nir_lower_tex.c                          | 2 +-
 src/gallium/drivers/radeonsi/ci/gfx10-navi10-fail.csv     | 2 --
 src/gallium/drivers/radeonsi/ci/gfx10_3-navi21-fail.csv   | 2 --
 src/gallium/drivers/radeonsi/ci/gfx8-polaris11-fail.csv   | 2 --
 src/gallium/drivers/radeonsi/ci/gfx9-raven-fail.csv       | 2 --
 src/gallium/drivers/radeonsi/ci/gfx9-vega20-fail.csv      | 2 --
 src/gallium/drivers/radeonsi/ci/radeonsi-stoney-fails.txt | 2 --
 7 files changed, 1 insertion(+), 13 deletions(-)

diff --git a/src/compiler/nir/nir_lower_tex.c b/src/compiler/nir/nir_lower_tex.c
index bc293cf9bbdf..776f75e8e079 100644
--- a/src/compiler/nir/nir_lower_tex.c
+++ b/src/compiler/nir/nir_lower_tex.c
@@ -517,9 +517,9 @@ lower_yu_yv_external(nir_builder *b, nir_tex_instr *tex,
   nir_ssa_def *yuv = sample_plane(b, tex, 0, options);
 
   convert_yuv_to_rgb(b, tex,
+                     nir_channel(b, yuv, 0),
                      nir_channel(b, yuv, 1),
                      nir_channel(b, yuv, 2),
-                     nir_channel(b, yuv, 0),
                      nir_imm_float(b, 1.0f),
                      options,
                      texture_index);

From 89617825a34a76b59254b20141f12759534fdd88 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 23 May 2022 10:33:25 +0200
Subject: [PATCH 4/5] util/blob: use memcpy in read functions
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Type casting may require specific alignment on some platforms;
since the input data can be provided by the application we can't
require any alignment.

Switch to using memcpy like the write functions do, and drop the
asserts.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/6493
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/util/blob.c | 14 ++------------
 1 file changed, 2 insertions(+), 12 deletions(-)

diff --git a/src/util/blob.c b/src/util/blob.c
index 67f6bb2567ce..b293df9c5dff 100644
--- a/src/util/blob.c
+++ b/src/util/blob.c
@@ -85,7 +85,6 @@ grow_to_fit(struct blob *blob, size_t additional)
 bool
 blob_align(struct blob *blob, size_t alignment)
 {
-   assert(align64((uintptr_t)blob->data, alignment) == (uintptr_t)blob->data);
    const size_t new_size = align64(blob->size, alignment);
 
    if (blob->size < new_size) {
@@ -103,7 +102,6 @@ blob_align(struct blob *blob, size_t alignment)
 void
 blob_reader_align(struct blob_reader *blob, size_t alignment)
 {
-   assert(align64((uintptr_t)blob->data, alignment) == (uintptr_t)blob->data);
    blob->current = blob->data + align64(blob->current - blob->data, alignment);
 }
 
@@ -310,22 +308,14 @@ blob_skip_bytes(struct blob_reader *blob, size_t size)
       blob->current += size;
 }
 
-/* These next three read functions have identical form. If we add any beyond
- * these first three we should probably switch to generating these with a
- * preprocessor macro.
-*/
-
 #define BLOB_READ_TYPE(name, type)         \
 type                                       \
 name(struct blob_reader *blob)             \
 {                                          \
-   type ret;                               \
+   type ret = 0;                           \
    int size = sizeof(ret);                 \
    blob_reader_align(blob, size);          \
-   if (! ensure_can_read(blob, size))      \
-      return 0;                            \
-   ret = *((type*) blob->current);         \
-   blob->current += size;                  \
+   blob_copy_bytes(blob, &ret, size);      \
    return ret;                             \
 }
 
-- 
GitLab


From 681f01c438194e908a6824232531f1e410848cab Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 8 Jun 2022 10:21:46 +0200
Subject: [PATCH 5/5] mesa: skip draws with invalid indices offset
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It's easy to misuse glDrawElements and end up with an
invalid indices offset.
Since this can cause a hang, detect this case and skip
the draw.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/6625
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
---
 src/mesa/main/draw.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 15cef9e675c4..0e2072bb3184 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1772,8 +1772,15 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx, GLenum mode,
       info.index.user = indices;
       draw.start = 0;
    } else {
+      uintptr_t start = (uintptr_t) indices;
+      if (unlikely(index_bo->Size < start)) {
+         _mesa_warning(ctx, "Invalid indices offset 0x%" PRIxPTR
+                            " (indices buffer size is %ld bytes)."
+                            " Draw skipped.", start, index_bo->Size);
+         return;
+      }
       info.index.gl_bo = index_bo;
-      draw.start = (uintptr_t)indices >> index_size_shift;
+      draw.start = start >> index_size_shift;
    }
    draw.index_bias = basevertex;
 
-- 
GitLab

