From 4cbde14fc4547cad537667a64c049ed04e614394 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Mon, 16 May 2022 18:37:17 -0700
Subject: [PATCH 1/4] nir: spirv: Allow 32-bit version of
 nir_intrinsic_is_sparse_texels_resident

This intrinsic returns a Boolean.  Both 1-bit and 32-bit versions must
be allowed.  Otherwise, size mismatches will occur after lowering
1-bit Booleans to 32-bit.

Fixes: 4cbdf9ec4d4 ("nir,spirv: implement SpvOpImageSparseTexelsResident")
Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/16547>
---
 src/compiler/nir/nir_intrinsics.py | 2 +-
 src/compiler/spirv/spirv_to_nir.c  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_intrinsics.py b/src/compiler/nir/nir_intrinsics.py
index 2b8a6c6ab6e3..d481fe22f736 100644
--- a/src/compiler/nir/nir_intrinsics.py
+++ b/src/compiler/nir/nir_intrinsics.py
@@ -319,7 +319,7 @@ intrinsic("deref_mode_is", src_comp=[-1], dest_comp=1,
 intrinsic("addr_mode_is", src_comp=[-1], dest_comp=1,
           indices=[MEMORY_MODES], flags=[CAN_ELIMINATE, CAN_REORDER])
 
-intrinsic("is_sparse_texels_resident", dest_comp=1, src_comp=[1], bit_sizes=[1],
+intrinsic("is_sparse_texels_resident", dest_comp=1, src_comp=[1], bit_sizes=[1,32],
           flags=[CAN_ELIMINATE, CAN_REORDER])
 # result code is resident only if both inputs are resident
 intrinsic("sparse_residency_code_and", dest_comp=1, src_comp=[1, 1], bit_sizes=[32],
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index f9b4eb85530a..b21368d7cec1 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -2702,7 +2702,7 @@ vtn_handle_texture(struct vtn_builder *b, SpvOp opcode,
       return;
    } else if (opcode == SpvOpImageSparseTexelsResident) {
       nir_ssa_def *code = vtn_get_nir_ssa(b, w[3]);
-      vtn_push_nir_ssa(b, w[2], nir_is_sparse_texels_resident(&b->nb, code));
+      vtn_push_nir_ssa(b, w[2], nir_is_sparse_texels_resident(&b->nb, 1, code));
       return;
    }
 
-- 
GitLab


From 67e6b4b96b425cce565c5f2fee90604c125bf057 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 17 May 2022 08:18:26 -0700
Subject: [PATCH 2/4] radeonsi: r600: d3d12: st: Use NIR lowering for tg4
 offset arrays instead of GLSL lowering

I think I got all the drivers that need updating.  This is only
necessary in drivers that support GLSL 4.00 / GL_ARB_gpu_shader5 and
have PIPE_CAP_TEXTURE_GATHER_OFFSETS = 0.

v2: Don't (accidentally) condition tg4 offsets lowering on tex rect
lowering.  Noticed by Qiang.

v3: Add missing bool() cast.

Fixes: 640f9098621 ("glsl: add _texture related sparse texture builtin functions")
Closes: #6365
Tested-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/16547>
---
 src/gallium/drivers/d3d12/d3d12_compiler.cpp |  1 +
 src/gallium/drivers/r600/sfn/sfn_nir.cpp     |  1 +
 src/gallium/drivers/radeonsi/si_shader_nir.c |  1 +
 src/mesa/state_tracker/st_glsl_to_ir.cpp     |  2 --
 src/mesa/state_tracker/st_glsl_to_nir.cpp    | 10 +++++++---
 5 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/d3d12/d3d12_compiler.cpp b/src/gallium/drivers/d3d12/d3d12_compiler.cpp
index b0fbebd2e055..e4262345d941 100644
--- a/src/gallium/drivers/d3d12/d3d12_compiler.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_compiler.cpp
@@ -1159,6 +1159,7 @@ select_shader_variant(struct d3d12_selection_context *sel_ctx, d3d12_shader_sele
       tex_options.saturate_r = key.tex_saturate_r;
       tex_options.saturate_t = key.tex_saturate_t;
       tex_options.lower_invalid_implicit_lod = true;
+      tex_options.lower_tg4_offsets = true;
 
       NIR_PASS_V(new_nir_variant, nir_lower_tex, &tex_options);
    }
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir.cpp b/src/gallium/drivers/r600/sfn/sfn_nir.cpp
index 46c10e40008e..a0e0fae1b9dd 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir.cpp
@@ -837,6 +837,7 @@ int r600_shader_from_nir(struct r600_context *rctx,
    lower_tex_options.lower_txp = ~0u;
    lower_tex_options.lower_txf_offset = true;
    lower_tex_options.lower_invalid_implicit_lod = true;
+   lower_tex_options.lower_tg4_offsets = true;
 
    NIR_PASS_V(sel->nir, nir_lower_tex, &lower_tex_options);
    NIR_PASS_V(sel->nir, r600::r600_nir_lower_txl_txf_array_or_cube);
diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index 612e75b81300..bce1475945cb 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -238,6 +238,7 @@ static void si_lower_nir(struct si_screen *sscreen, struct nir_shader *nir)
       .lower_txp = ~0u,
       .lower_txs_cube_array = true,
       .lower_invalid_implicit_lod = true,
+      .lower_tg4_offsets = true,
    };
    NIR_PASS_V(nir, nir_lower_tex, &lower_tex_options);
 
diff --git a/src/mesa/state_tracker/st_glsl_to_ir.cpp b/src/mesa/state_tracker/st_glsl_to_ir.cpp
index 769226065dcf..032ec7e5819b 100644
--- a/src/mesa/state_tracker/st_glsl_to_ir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_ir.cpp
@@ -94,8 +94,6 @@ link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
          lower_packing_builtins(ir, lower_inst);
       }
 
-      if (!pscreen->get_param(pscreen, PIPE_CAP_TEXTURE_GATHER_OFFSETS))
-         lower_offset_arrays(ir);
       do_mat_op_to_vec(ir);
 
       if (stage == MESA_SHADER_FRAGMENT && pscreen->get_param(pscreen, PIPE_CAP_FBFETCH))
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index c379702d94ae..f046044c4f25 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -1096,10 +1096,14 @@ st_finalize_nir(struct st_context *st, struct gl_program *prog,
    NIR_PASS_V(nir, nir_split_var_copies);
    NIR_PASS_V(nir, nir_lower_var_copies);
 
-   if (st->lower_rect_tex) {
-      struct nir_lower_tex_options opts = { 0 };
+   const bool lower_tg4_offsets =
+      !st->screen->get_param(screen, PIPE_CAP_TEXTURE_GATHER_OFFSETS);
 
-      opts.lower_rect = true;
+   if (st->lower_rect_tex || lower_tg4_offsets) {
+      const struct nir_lower_tex_options opts = {
+         .lower_rect = bool(st->lower_rect_tex),
+         .lower_tg4_offsets = lower_tg4_offsets
+      };
 
       NIR_PASS_V(nir, nir_lower_tex, &opts);
    }
-- 
GitLab


From 12b2df26e905e0dc45baeeb47c304cd0c2c80373 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 17 May 2022 10:29:25 -0700
Subject: [PATCH 3/4] glsl: Remove lower_offset_arrays pass

It is no longer used.

Reviewed-by: Qiang Yu <yuq825@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/16547>
---
 src/compiler/glsl/ir_optimization.h      |  1 -
 src/compiler/glsl/lower_offset_array.cpp | 91 ------------------------
 src/compiler/glsl/meson.build            |  1 -
 3 files changed, 93 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_offset_array.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 7fc8e036431a..1ff1884ea0c8 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -133,7 +133,6 @@ bool lower_vector_insert(exec_list *instructions, bool lower_nonconstant_index);
 bool lower_vector_derefs(gl_linked_shader *shader);
 void lower_named_interface_blocks(void *mem_ctx, gl_linked_shader *shader);
 bool optimize_split_arrays(exec_list *instructions, bool linked);
-bool lower_offset_arrays(exec_list *instructions);
 void optimize_dead_builtin_variables(exec_list *instructions,
                                      enum ir_variable_mode other);
 bool lower_tess_level(gl_linked_shader *shader);
diff --git a/src/compiler/glsl/lower_offset_array.cpp b/src/compiler/glsl/lower_offset_array.cpp
deleted file mode 100644
index 96486c3a7112..000000000000
--- a/src/compiler/glsl/lower_offset_array.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright Â© 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_offset_array.cpp
- *
- * IR lower pass to decompose ir_texture ir_tg4 with an array of offsets
- * into four ir_tg4s with a single ivec2 offset, select the .w component of each,
- * and return those four values packed into a gvec4.
- *
- * \author Chris Forbes <chrisf@ijw.co.nz>
- */
-
-#include "compiler/glsl_types.h"
-#include "ir.h"
-#include "ir_builder.h"
-#include "ir_optimization.h"
-#include "ir_rvalue_visitor.h"
-
-using namespace ir_builder;
-
-class lower_offset_array_visitor : public ir_rvalue_visitor {
-public:
-   lower_offset_array_visitor()
-   {
-      progress = false;
-   }
-
-   void handle_rvalue(ir_rvalue **rv);
-
-   bool progress;
-};
-
-void
-lower_offset_array_visitor::handle_rvalue(ir_rvalue **rv)
-{
-   if (*rv == NULL || (*rv)->ir_type != ir_type_texture)
-      return;
-
-   ir_texture *ir = (ir_texture *) *rv;
-   if (ir->op != ir_tg4 || !ir->offset || !ir->offset->type->is_array())
-      return;
-
-   void *mem_ctx = ralloc_parent(ir);
-
-   ir_variable *var =
-      new (mem_ctx) ir_variable(ir->type, "result", ir_var_temporary);
-   base_ir->insert_before(var);
-
-   for (int i = 0; i < 4; i++) {
-      ir_texture *tex = ir->clone(mem_ctx, NULL);
-      tex->offset = new (mem_ctx) ir_dereference_array(tex->offset,
-            new (mem_ctx) ir_constant(i));
-
-      base_ir->insert_before(assign(var, swizzle_w(tex), 1 << i));
-   }
-
-   *rv = new (mem_ctx) ir_dereference_variable(var);
-
-   progress = true;
-}
-
-bool
-lower_offset_arrays(exec_list *instructions)
-{
-   lower_offset_array_visitor v;
-
-   visit_list_elements(&v, instructions);
-
-   return v.progress;
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 392ff02453d1..13581bb72c77 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -170,7 +170,6 @@ files_libglsl = files(
   'lower_int64.cpp',
   'lower_jumps.cpp',
   'lower_mat_op_to_vec.cpp',
-  'lower_offset_array.cpp',
   'lower_named_interface_blocks.cpp',
   'lower_packing_builtins.cpp',
   'lower_precision.cpp',
-- 
GitLab


From b076299101303b6eb70ab63d8a3a8acb54072268 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 17 May 2022 13:37:10 -0400
Subject: [PATCH 4/4] zink: handle nir_intrinsic_sparse_residency_code_and
 mechanics

without glsl array lowering, this intrinsic can creep in for tg4 ops,
which complicates everything. instead, rewrite these ops as residency+iand,
and then rewrite the existing residency ops to match

v2 (idr): Add missing size parameter to nir_is_sparse_texels_resident
calls.

Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/16547>
---
 src/gallium/drivers/zink/zink_compiler.c | 64 ++++++++++++++++++++++--
 1 file changed, 60 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index 9bb7225bb389..5e20e2d6c080 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -2121,12 +2121,47 @@ scan_nir(struct zink_screen *screen, nir_shader *shader, struct zink_shader *zs)
    }
 }
 
+static bool
+is_residency_code(nir_ssa_def *src)
+{
+   nir_instr *parent = src->parent_instr;
+   while (1) {
+      if (parent->type == nir_instr_type_intrinsic) {
+         nir_intrinsic_instr *intr = nir_instr_as_intrinsic(parent);
+         assert(intr->intrinsic == nir_intrinsic_is_sparse_texels_resident);
+         return false;
+      }
+      if (parent->type == nir_instr_type_tex)
+         return true;
+      assert(parent->type == nir_instr_type_alu);
+      nir_alu_instr *alu = nir_instr_as_alu(parent);
+      parent = alu->src[0].src.ssa->parent_instr;
+   }
+}
+
 static bool
 lower_sparse_instr(nir_builder *b, nir_instr *in, void *data)
 {
    if (in->type != nir_instr_type_intrinsic)
       return false;
    nir_intrinsic_instr *instr = nir_instr_as_intrinsic(in);
+   if (instr->intrinsic == nir_intrinsic_sparse_residency_code_and) {
+      b->cursor = nir_before_instr(&instr->instr);
+      nir_ssa_def *src0;
+      if (is_residency_code(instr->src[0].ssa))
+         src0 = nir_is_sparse_texels_resident(b, 1, instr->src[0].ssa);
+      else
+         src0 = instr->src[0].ssa;
+      nir_ssa_def *src1;
+      if (is_residency_code(instr->src[1].ssa))
+         src1 = nir_is_sparse_texels_resident(b, 1, instr->src[1].ssa);
+      else
+         src1 = instr->src[1].ssa;
+      nir_ssa_def *def = nir_iand(b, src0, src1);
+      nir_ssa_def_rewrite_uses_after(&instr->dest.ssa, def, in);
+      nir_instr_remove(in);
+      return true;
+   }
    if (instr->intrinsic != nir_intrinsic_is_sparse_texels_resident)
       return false;
 
@@ -2136,10 +2171,31 @@ lower_sparse_instr(nir_builder *b, nir_instr *in, void *data)
     */
    b->cursor = nir_before_instr(&instr->instr);
    nir_instr *parent = instr->src[0].ssa->parent_instr;
-   assert(parent->type == nir_instr_type_alu);
-   nir_alu_instr *alu = nir_instr_as_alu(parent);
-   nir_ssa_def_rewrite_uses_after(instr->src[0].ssa, nir_channel(b, alu->src[0].src.ssa, 0), parent);
-   nir_instr_remove(parent);
+   if (is_residency_code(instr->src[0].ssa)) {
+      assert(parent->type == nir_instr_type_alu);
+      nir_alu_instr *alu = nir_instr_as_alu(parent);
+      nir_ssa_def_rewrite_uses_after(instr->src[0].ssa, nir_channel(b, alu->src[0].src.ssa, 0), parent);
+      nir_instr_remove(parent);
+   } else {
+      nir_ssa_def *src;
+      if (parent->type == nir_instr_type_intrinsic) {
+         nir_intrinsic_instr *intr = nir_instr_as_intrinsic(parent);
+         assert(intr->intrinsic == nir_intrinsic_is_sparse_texels_resident);
+         src = intr->src[0].ssa;
+      } else {
+         assert(parent->type == nir_instr_type_alu);
+         nir_alu_instr *alu = nir_instr_as_alu(parent);
+         src = alu->src[0].src.ssa;
+      }
+      if (instr->dest.ssa.bit_size != 32) {
+         if (instr->dest.ssa.bit_size == 1)
+            src = nir_ieq_imm(b, src, 1);
+         else
+            src = nir_u2uN(b, src, instr->dest.ssa.bit_size);
+      }
+      nir_ssa_def_rewrite_uses(&instr->dest.ssa, src);
+      nir_instr_remove(in);
+   }
    return true;
 }
 
-- 
GitLab

