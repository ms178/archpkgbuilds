From 9e15ef60d1c70a0957f21f84b4510b1fa7882cff Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 00:51:19 +0100
Subject: [PATCH 1/5] radv: Reserve space in framebuffer emission.

In the execute secondary scenario nothing else does it for us.

Fixes: 203f60ebf2f ("radv: emit framebuffer state from primary if secondary doesn't inherit it")
---
 src/amd/vulkan/radv_cmd_buffer.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d3838af3e488..57caf86a110f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3280,6 +3280,9 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
                             ? G_028C70_FORMAT_GFX11(V_028C70_COLOR_INVALID)
                             : G_028C70_FORMAT_GFX6(V_028C70_COLOR_INVALID);
 
+   ASSERTED unsigned cdw_max =
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 48 + MAX_RTS * 70);
+
    for (i = 0; i < render->color_att_count; ++i) {
       struct radv_image_view *iview = render->color_att[i].iview;
       if (!iview) {
@@ -3411,6 +3414,8 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
       }
    }
 
+   assert(cmd_buffer->cs->cdw <= cdw_max);
+
    cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_FRAMEBUFFER;
 }
 
-- 
GitLab


From 36daaf7267bcec3b2d7babfcf6fe1744f582be2c Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 01:40:10 +0100
Subject: [PATCH 2/5] radv: Reserve space in various streamout functions.

Fixes: b4eb029062a ("radv: implement VK_EXT_transform_feedback")
---
 src/amd/vulkan/radv_cmd_buffer.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 57caf86a110f..348ec4e64f90 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -10454,6 +10454,8 @@ radv_emit_streamout_enable(struct radv_cmd_buffer *cmd_buffer)
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    uint32_t enabled_stream_buffers_mask = 0;
 
+   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4);
+
    if (pipeline && pipeline->streamout_shader) {
       enabled_stream_buffers_mask = pipeline->streamout_shader->info.so.enabled_stream_buffers_mask;
    }
@@ -10497,6 +10499,8 @@ radv_flush_vgt_streamout(struct radv_cmd_buffer *cmd_buffer)
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    unsigned reg_strmout_cntl;
 
+   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 14);
+
    /* The register is at different places on different ASICs. */
    if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX9) {
       reg_strmout_cntl = R_0300FC_CP_STRMOUT_CNTL;
@@ -10552,6 +10556,8 @@ radv_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstC
       radv_flush_vgt_streamout(cmd_buffer);
    }
 
+   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, MAX_SO_BUFFERS * 10);
+
    u_foreach_bit(i, so->enabled_mask)
    {
       int32_t counter_buffer_idx = i - firstCounterBuffer;
-- 
GitLab


From 7bf415a397b55cd61b8c041768ae96a6a6562a82 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 02:02:36 +0100
Subject: [PATCH 3/5] radv: Reserve space in conditional rendering functions.

Fixes: e45ba51ea45 ("radv: add support for VK_EXT_conditional_rendering")
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 ++
 src/amd/vulkan/si_cmd_buffer.c   | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 348ec4e64f90..fadd7efd93aa 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -10366,6 +10366,8 @@ radv_CmdBeginConditionalRenderingEXT(
 
       pred_va = radv_buffer_get_va(cmd_buffer->upload.upload_bo) + pred_offset;
 
+      radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 8);
+
       radeon_emit(cs, PKT3(PKT3_COPY_DATA, 4, 0));
       radeon_emit(cs, COPY_DATA_SRC_SEL(COPY_DATA_SRC_MEM) | COPY_DATA_DST_SEL(COPY_DATA_DST_MEM) |
                          COPY_DATA_WR_CONFIRM);
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 538a4e1e088b..1a3bcc8f34af 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -1573,6 +1573,8 @@ si_emit_set_predication_state(struct radv_cmd_buffer *cmd_buffer, bool draw_visi
 {
    uint32_t op = 0;
 
+   radeon_check_space(cmd_buffer->device->ws, cmd_buffer->cs, 4);
+
    if (va) {
       assert(pred_op == PREDICATION_OP_BOOL32 || pred_op == PREDICATION_OP_BOOL64);
 
-- 
GitLab


From 86f36a7e41b93dcb95e9291610335129bdf7a08b Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 02:11:51 +0100
Subject: [PATCH 4/5] radv: Reserve space for internal ACE cache flushes.

Fixes: 4c6f83006d4 ("radv: Synchronization for task shaders.")
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index fadd7efd93aa..d5475661bf55 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -638,6 +638,8 @@ radv_ace_internal_cache_flush(struct radv_cmd_buffer *cmd_buffer)
    const uint32_t flush_bits = cmd_buffer->ace_internal.flush_bits;
    enum rgp_flush_bits sqtt_flush_bits = 0;
 
+   radeon_check_space(cmd_buffer->device->ws, ace_cs, 128);
+
    si_cs_emit_cache_flush(ace_cs, cmd_buffer->device->physical_device->rad_info.gfx_level, NULL, 0,
                           true, flush_bits, &sqtt_flush_bits, 0);
 
-- 
GitLab


From 2088d29c06605483444c669d7b0c2f434c2eb02e Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 5 Dec 2022 00:54:14 +0100
Subject: [PATCH 5/5] radv: Add stricter space checks.

The check for max_dw means that none of checks triggered reliably
when we had an issue. Use a stricter reserved dw measure to increase
the probability of catching issues.
---
 src/amd/vulkan/radv_cs.h                      | 24 ++++++++++---------
 src/amd/vulkan/radv_device.c                  |  1 +
 src/amd/vulkan/radv_pipeline.c                |  6 ++---
 src/amd/vulkan/radv_radeon_winsys.h           |  1 +
 src/amd/vulkan/si_cmd_buffer.c                |  4 ++++
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c |  9 +++++++
 6 files changed, 31 insertions(+), 14 deletions(-)

diff --git a/src/amd/vulkan/radv_cs.h b/src/amd/vulkan/radv_cs.h
index ac3d1075783e..860f37341680 100644
--- a/src/amd/vulkan/radv_cs.h
+++ b/src/amd/vulkan/radv_cs.h
@@ -34,8 +34,10 @@
 static inline unsigned
 radeon_check_space(struct radeon_winsys *ws, struct radeon_cmdbuf *cs, unsigned needed)
 {
+   assert(cs->cdw <= cs->reserved_dw);
    if (cs->max_dw - cs->cdw < needed)
       ws->cs_grow(cs, needed);
+   cs->reserved_dw = MAX2(cs->reserved_dw, cs->cdw + needed);
    return cs->cdw + needed;
 }
 
@@ -43,7 +45,7 @@ static inline void
 radeon_set_config_reg_seq(struct radeon_cmdbuf *cs, unsigned reg, unsigned num)
 {
    assert(reg >= SI_CONFIG_REG_OFFSET && reg < SI_CONFIG_REG_END);
-   assert(cs->cdw + 2 + num <= cs->max_dw);
+   assert(cs->cdw + 2 + num <= cs->reserved_dw);
    assert(num);
    radeon_emit(cs, PKT3(PKT3_SET_CONFIG_REG, num, 0));
    radeon_emit(cs, (reg - SI_CONFIG_REG_OFFSET) >> 2);
@@ -60,7 +62,7 @@ static inline void
 radeon_set_context_reg_seq(struct radeon_cmdbuf *cs, unsigned reg, unsigned num)
 {
    assert(reg >= SI_CONTEXT_REG_OFFSET && reg < SI_CONTEXT_REG_END);
-   assert(cs->cdw + 2 + num <= cs->max_dw);
+   assert(cs->cdw + 2 + num <= cs->reserved_dw);
    assert(num);
    radeon_emit(cs, PKT3(PKT3_SET_CONTEXT_REG, num, 0));
    radeon_emit(cs, (reg - SI_CONTEXT_REG_OFFSET) >> 2);
@@ -77,7 +79,7 @@ static inline void
 radeon_set_context_reg_idx(struct radeon_cmdbuf *cs, unsigned reg, unsigned idx, unsigned value)
 {
    assert(reg >= SI_CONTEXT_REG_OFFSET && reg < SI_CONTEXT_REG_END);
-   assert(cs->cdw + 3 <= cs->max_dw);
+   assert(cs->cdw + 3 <= cs->reserved_dw);
    radeon_emit(cs, PKT3(PKT3_SET_CONTEXT_REG, 1, 0));
    radeon_emit(cs, (reg - SI_CONTEXT_REG_OFFSET) >> 2 | (idx << 28));
    radeon_emit(cs, value);
@@ -87,7 +89,7 @@ static inline void
 radeon_set_sh_reg_seq(struct radeon_cmdbuf *cs, unsigned reg, unsigned num)
 {
    assert(reg >= SI_SH_REG_OFFSET && reg < SI_SH_REG_END);
-   assert(cs->cdw + 2 + num <= cs->max_dw);
+   assert(cs->cdw + 2 + num <= cs->reserved_dw);
    assert(num);
    radeon_emit(cs, PKT3(PKT3_SET_SH_REG, num, 0));
    radeon_emit(cs, (reg - SI_SH_REG_OFFSET) >> 2);
@@ -105,7 +107,7 @@ radeon_set_sh_reg_idx(const struct radv_physical_device *pdevice, struct radeon_
                       unsigned reg, unsigned idx, unsigned value)
 {
    assert(reg >= SI_SH_REG_OFFSET && reg < SI_SH_REG_END);
-   assert(cs->cdw + 3 <= cs->max_dw);
+   assert(cs->cdw + 3 <= cs->reserved_dw);
    assert(idx);
 
    unsigned opcode = PKT3_SET_SH_REG_INDEX;
@@ -121,7 +123,7 @@ static inline void
 gfx10_set_sh_reg_idx3(struct radeon_cmdbuf *cs, unsigned reg, unsigned value)
 {
    assert(reg >= SI_SH_REG_OFFSET && reg < SI_SH_REG_END);
-   assert(cs->cdw + 3 <= cs->max_dw);
+   assert(cs->cdw + 3 <= cs->reserved_dw);
 
    radeon_emit(cs, PKT3(PKT3_SET_SH_REG_INDEX, 1, 0));
    radeon_emit(cs, (reg - SI_SH_REG_OFFSET) >> 2 | (3 << 28));
@@ -132,7 +134,7 @@ static inline void
 radeon_set_uconfig_reg_seq(struct radeon_cmdbuf *cs, unsigned reg, unsigned num)
 {
    assert(reg >= CIK_UCONFIG_REG_OFFSET && reg < CIK_UCONFIG_REG_END);
-   assert(cs->cdw + 2 + num <= cs->max_dw);
+   assert(cs->cdw + 2 + num <= cs->reserved_dw);
    assert(num);
    radeon_emit(cs, PKT3(PKT3_SET_UCONFIG_REG, num, 0));
    radeon_emit(cs, (reg - CIK_UCONFIG_REG_OFFSET) >> 2);
@@ -142,7 +144,7 @@ static inline void
 radeon_set_uconfig_reg_seq_perfctr(struct radeon_cmdbuf *cs, unsigned reg, unsigned num)
 {
    assert(reg >= CIK_UCONFIG_REG_OFFSET && reg < CIK_UCONFIG_REG_END);
-   assert(cs->cdw + 2 + num <= cs->max_dw);
+   assert(cs->cdw + 2 + num <= cs->reserved_dw);
    assert(num);
    radeon_emit(cs, PKT3(PKT3_SET_UCONFIG_REG, num, 1));
    radeon_emit(cs, (reg - CIK_UCONFIG_REG_OFFSET) >> 2);
@@ -160,7 +162,7 @@ radeon_set_uconfig_reg_idx(const struct radv_physical_device *pdevice, struct ra
                            unsigned reg, unsigned idx, unsigned value)
 {
    assert(reg >= CIK_UCONFIG_REG_OFFSET && reg < CIK_UCONFIG_REG_END);
-   assert(cs->cdw + 3 <= cs->max_dw);
+   assert(cs->cdw + 3 <= cs->reserved_dw);
    assert(idx);
 
    unsigned opcode = PKT3_SET_UCONFIG_REG_INDEX;
@@ -178,7 +180,7 @@ radeon_set_perfctr_reg(struct radv_cmd_buffer *cmd_buffer, unsigned reg, unsigne
 {
    struct radeon_cmdbuf *cs = cmd_buffer->cs;
    assert(reg >= CIK_UCONFIG_REG_OFFSET && reg < CIK_UCONFIG_REG_END);
-   assert(cs->cdw + 3 <= cs->max_dw);
+   assert(cs->cdw + 3 <= cs->reserved_dw);
 
    /*
     * On GFX10, there is a bug with the ME implementation of its content addressable memory (CAM),
@@ -197,7 +199,7 @@ static inline void
 radeon_set_privileged_config_reg(struct radeon_cmdbuf *cs, unsigned reg, unsigned value)
 {
    assert(reg < CIK_UCONFIG_REG_OFFSET);
-   assert(cs->cdw + 6 <= cs->max_dw);
+   assert(cs->cdw + 6 <= cs->reserved_dw);
 
    radeon_emit(cs, PKT3(PKT3_COPY_DATA, 4, 0));
    radeon_emit(cs, COPY_DATA_SRC_SEL(COPY_DATA_IMM) | COPY_DATA_DST_SEL(COPY_DATA_PERF));
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 53d60ab61e88..183b4a0ab57d 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -4913,6 +4913,7 @@ radv_update_preamble_cs(struct radv_queue_state *queue, struct radv_device *devi
          goto fail;
       }
 
+      radeon_check_space(ws, cs, 256);
       dest_cs[i] = cs;
 
       if (scratch_bo)
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 5f2df7201ef9..06d03bf64abb 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -5285,8 +5285,8 @@ radv_pipeline_emit_pm4(struct radv_graphics_pipeline *pipeline,
    struct radeon_cmdbuf *ctx_cs = &pipeline->base.ctx_cs;
    struct radeon_cmdbuf *cs = &pipeline->base.cs;
 
-   cs->max_dw = 64;
-   ctx_cs->max_dw = 256;
+   cs->reserved_dw = cs->max_dw = 64;
+   ctx_cs->reserved_dw = ctx_cs->max_dw = 256;
    cs->buf = malloc(4 * (cs->max_dw + ctx_cs->max_dw));
    ctx_cs->buf = cs->buf + cs->max_dw;
 
@@ -6022,7 +6022,7 @@ radv_compute_generate_pm4(struct radv_compute_pipeline *pipeline)
    struct radv_shader *shader = pipeline->base.shaders[MESA_SHADER_COMPUTE];
    struct radeon_cmdbuf *cs = &pipeline->base.cs;
 
-   cs->max_dw = pdevice->rad_info.gfx_level >= GFX10 ? 19 : 16;
+   cs->reserved_dw = cs->max_dw = pdevice->rad_info.gfx_level >= GFX10 ? 19 : 16;
    cs->buf = malloc(cs->max_dw * 4);
 
    radv_pipeline_emit_hw_cs(pdevice, cs, shader);
diff --git a/src/amd/vulkan/radv_radeon_winsys.h b/src/amd/vulkan/radv_radeon_winsys.h
index 611188433bda..0aeeedc5a4e0 100644
--- a/src/amd/vulkan/radv_radeon_winsys.h
+++ b/src/amd/vulkan/radv_radeon_winsys.h
@@ -105,6 +105,7 @@ enum radeon_value_id {
 struct radeon_cmdbuf {
    unsigned cdw;    /* Number of used dwords. */
    unsigned max_dw; /* Maximum number of dwords. */
+   unsigned reserved_dw; /* Number of dwords reserved through radeon_check_space() */
    uint32_t *buf;   /* The base pointer of the chunk. */
 };
 
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 1a3bcc8f34af..fe8ae76c320e 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -76,6 +76,8 @@ si_emit_compute(struct radv_device *device, struct radeon_cmdbuf *cs)
 {
    const struct radeon_info *info = &device->physical_device->rad_info;
 
+   radeon_check_space(device->ws, cs, 128);
+
    radeon_set_sh_reg_seq(cs, R_00B810_COMPUTE_START_X, 3);
    radeon_emit(cs, 0);
    radeon_emit(cs, 0);
@@ -200,6 +202,8 @@ si_emit_graphics(struct radv_device *device, struct radeon_cmdbuf *cs)
    bool has_clear_state = physical_device->rad_info.has_clear_state;
    int i;
 
+   radeon_check_space(device->ws, cs, 256);
+
    radeon_emit(cs, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
    radeon_emit(cs, CC0_UPDATE_LOAD_ENABLES(1));
    radeon_emit(cs, CC1_UPDATE_SHADOW_ENABLES(1));
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index d7d6e95d69f5..39c3536b8c1a 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -428,6 +428,8 @@ radv_amdgpu_cs_finalize(struct radeon_cmdbuf *_cs)
    struct radv_amdgpu_cs *cs = radv_amdgpu_cs(_cs);
    enum amd_ip_type ip_type = cs->hw_ip;
 
+   assert(cs->base.cdw <= cs->base.reserved_dw);
+
    if (cs->use_ib) {
       uint32_t ib_pad_dw_mask = MAX2(3, cs->ws->info.ib_pad_dw_mask[ip_type]);
       uint32_t nop_packet = get_nop_packet(cs);
@@ -462,6 +464,7 @@ radv_amdgpu_cs_reset(struct radeon_cmdbuf *_cs)
 {
    struct radv_amdgpu_cs *cs = radv_amdgpu_cs(_cs);
    cs->base.cdw = 0;
+   cs->base.reserved_dw = 0;
    cs->status = VK_SUCCESS;
 
    for (unsigned i = 0; i < cs->num_buffers; ++i) {
@@ -660,6 +663,8 @@ radv_amdgpu_cs_execute_secondary(struct radeon_cmdbuf *_parent, struct radeon_cm
       if (parent->base.cdw + 4 > parent->base.max_dw)
          radv_amdgpu_cs_grow(&parent->base, 4);
 
+      parent->base.reserved_dw = MAX2(parent->base.reserved_dw, parent->base.cdw + 4);
+
       /* Not setting the CHAIN bit will launch an IB2. */
       radeon_emit(&parent->base, PKT3(PKT3_INDIRECT_BUFFER_CIK, 2, 0));
       radeon_emit(&parent->base, child->ib.ib_mc_address);
@@ -675,6 +680,8 @@ radv_amdgpu_cs_execute_secondary(struct radeon_cmdbuf *_parent, struct radeon_cm
             if (parent->base.cdw + ib->cdw > parent->base.max_dw)
                radv_amdgpu_cs_grow(&parent->base, ib->cdw);
 
+            parent->base.reserved_dw = MAX2(parent->base.reserved_dw, parent->base.cdw + ib->cdw);
+
             mapped = ws->base.buffer_map(ib->bo);
             if (!mapped) {
                parent->status = VK_ERROR_OUT_OF_HOST_MEMORY;
@@ -743,6 +750,8 @@ radv_amdgpu_cs_execute_secondary(struct radeon_cmdbuf *_parent, struct radeon_cm
       if (parent->base.cdw + child->base.cdw > parent->base.max_dw)
          radv_amdgpu_cs_grow(&parent->base, child->base.cdw);
 
+      parent->base.reserved_dw = MAX2(parent->base.reserved_dw, parent->base.cdw + child->base.cdw);
+
       memcpy(parent->base.buf + parent->base.cdw, child->base.buf, 4 * child->base.cdw);
       parent->base.cdw += child->base.cdw;
    }
-- 
GitLab

