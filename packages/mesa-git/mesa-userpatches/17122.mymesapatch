From 4f49e53fe5f718f8e1e5ce120f18bd2333055fca Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 11:46:25 +0800
Subject: [PATCH 01/21] mesa/st: Only free pointers in gl_framebuffer when not
 NULL

Also reset the pointer that freed to NULL.
This is a prepare for se gl_framebuffer::Delete instead FREE in st_framebuffer_create

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/framebuffer.c | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/src/mesa/main/framebuffer.c b/src/mesa/main/framebuffer.c
index 18f00820bb99..08318a0b57a7 100644
--- a/src/mesa/main/framebuffer.c
+++ b/src/mesa/main/framebuffer.c
@@ -187,7 +187,10 @@ _mesa_destroy_framebuffer(struct gl_framebuffer *fb)
 {
    if (fb) {
       _mesa_free_framebuffer_data(fb);
-      free(fb->Label);
+      if (fb->Label) {
+         free(fb->Label);
+         fb->Label = NULL;
+      }
       FREE(fb);
    }
 }
@@ -218,8 +221,10 @@ _mesa_free_framebuffer_data(struct gl_framebuffer *fb)
       att->Type = GL_NONE;
    }
 
-   free(fb->SampleLocationTable);
-   fb->SampleLocationTable = NULL;
+   if (fb->SampleLocationTable) {
+      free(fb->SampleLocationTable);
+      fb->SampleLocationTable = NULL;
+   }
 }
 
 
-- 
GitLab


From b928edc4bcaa53eb4a9048a6e2d2d9aed5710f01 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 11:34:14 +0800
Subject: [PATCH 02/21] mesa/st: Use gl_framebuffer::Delete instead FREE in
 st_framebuffer_create

This is a prepare for refactoring _mesa_calloc_framebuffer out

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/state_tracker/st_manager.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index e49ce3ae6f2e..c92a642013fd 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -646,7 +646,7 @@ st_framebuffer_create(struct st_context *st,
    /* add the color buffer */
    idx = stfb->_ColorDrawBufferIndexes[0];
    if (!st_framebuffer_add_renderbuffer(stfb, idx, prefer_srgb)) {
-      FREE(stfb);
+      stfb->Delete(stfb);
       return NULL;
    }
 
-- 
GitLab


From c40e15b3d1d6fa8ea147536a1e8e8b1ef7e83036 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 12:16:51 +0800
Subject: [PATCH 03/21] mesa/st: Refactoring _mesa_calloc_framebuffer out

Introduce _mesa_create_window_framebuffer
This is a prepare for removing usage of _SIMPLE_MTX_INITIALIZER_NP in fbobject.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/context.c             |  2 +-
 src/mesa/main/framebuffer.c         | 69 ++++++++++++++---------------
 src/mesa/main/framebuffer.h         | 10 ++---
 src/mesa/state_tracker/st_manager.c |  8 ++--
 4 files changed, 41 insertions(+), 48 deletions(-)

diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 8a8193c521da..a7e0b77c5e7f 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1538,7 +1538,7 @@ _mesa_make_current( struct gl_context *newCtx,
          }
          if (!newCtx->ReadBuffer || _mesa_is_winsys_fbo(newCtx->ReadBuffer)) {
             _mesa_reference_framebuffer(&newCtx->ReadBuffer, readBuffer);
-            /* In _mesa_initialize_window_framebuffer, for single-buffered
+            /* In _mesa_create_window_framebuffer, for single-buffered
              * visuals, the ColorReadBuffer is set to be GL_FRONT, even with
              * GLES contexts. When calling read_buffer, we verify we are reading
              * from GL_BACK in is_legal_es3_readbuffer_enum.  But the default is
diff --git a/src/mesa/main/framebuffer.c b/src/mesa/main/framebuffer.c
index 08318a0b57a7..46b2b746dd99 100644
--- a/src/mesa/main/framebuffer.c
+++ b/src/mesa/main/framebuffer.c
@@ -80,42 +80,37 @@ compute_depth_max(struct gl_framebuffer *fb)
 }
 
 /**
- * Allocate a new gl_framebuffer object.
- * This is the default function for ctx->Driver.NewFramebuffer().
- * This is for allocating user-created framebuffers, not window-system
- * framebuffers!
+ * Allocate and memset to zeros of a new gl_framebuffer object.
+ * This is also initialize RefCount, Delete and Mutex members
  */
-struct gl_framebuffer *
-_mesa_new_framebuffer(struct gl_context *ctx, GLuint name)
+static struct gl_framebuffer *
+_mesa_calloc_framebuffer(void)
 {
-   struct gl_framebuffer *fb;
-   (void) ctx;
-   assert(name != 0);
-   fb = CALLOC_STRUCT(gl_framebuffer);
+   struct gl_framebuffer *fb = CALLOC_STRUCT(gl_framebuffer);
    if (fb) {
-      _mesa_initialize_user_framebuffer(fb, name);
+      memset(fb, 0, sizeof(struct gl_framebuffer));
+      fb->RefCount = 1;
+      fb->Delete = _mesa_destroy_framebuffer;
+      simple_mtx_init(&fb->Mutex, mtx_plain);
    }
    return fb;
 }
 
 
 /**
- * Initialize a gl_framebuffer object.  Typically used to initialize
+ * Create a gl_framebuffer object. Typically used to create and initialize
  * window system-created framebuffers, not user-created framebuffers.
- * \sa _mesa_initialize_user_framebuffer
+ * \sa _mesa_create_window_framebuffer
  */
-void
-_mesa_initialize_window_framebuffer(struct gl_framebuffer *fb,
-				     const struct gl_config *visual)
+struct gl_framebuffer *
+_mesa_create_window_framebuffer(const struct gl_config *visual)
 {
-   assert(fb);
+   struct gl_framebuffer *fb;
    assert(visual);
-
-   memset(fb, 0, sizeof(struct gl_framebuffer));
-
-   simple_mtx_init(&fb->Mutex, mtx_plain);
-
-   fb->RefCount = 1;
+   fb = _mesa_calloc_framebuffer();
+   if (fb == NULL) {
+      return NULL;
+   }
 
    /* save the visual */
    fb->Visual = *visual;
@@ -136,7 +131,6 @@ _mesa_initialize_window_framebuffer(struct gl_framebuffer *fb,
       fb->_ColorReadBufferIndex = BUFFER_FRONT_LEFT;
    }
 
-   fb->Delete = _mesa_destroy_framebuffer;
    fb->_Status = GL_FRAMEBUFFER_COMPLETE_EXT;
    fb->_AllColorBuffersFixedPoint = !visual->floatMode;
    fb->_HasSNormOrFloatColorBuffer = visual->floatMode;
@@ -148,23 +142,29 @@ _mesa_initialize_window_framebuffer(struct gl_framebuffer *fb,
    fb->SampleLocationPixelGrid = 0;
 
    compute_depth_max(fb);
+   return fb;
 }
 
 
 /**
- * Initialize a user-created gl_framebuffer object.
- * \sa _mesa_initialize_window_framebuffer
+ * Allocate and initialize a user-created gl_framebuffer object.
+ * This is the default function for ctx->Driver.NewFramebuffer().
+ * This is for allocating user-created framebuffers, not window-system
+ * framebuffers!
+ * \sa _mesa_new_framebuffer
  */
-void
-_mesa_initialize_user_framebuffer(struct gl_framebuffer *fb, GLuint name)
+static struct gl_framebuffer *
+_mesa_new_framebuffer(struct gl_context *ctx, GLuint name)
 {
-   assert(fb);
-   assert(name);
-
-   memset(fb, 0, sizeof(struct gl_framebuffer));
+   struct gl_framebuffer *fb;
+   (void) ctx;
+   assert(name != 0);
+   fb = _mesa_calloc_framebuffer();
+   if (fb == NULL) {
+      return NULL;
+   }
 
    fb->Name = name;
-   fb->RefCount = 1;
    fb->_NumColorDrawBuffers = 1;
    fb->ColorDrawBuffer[0] = GL_COLOR_ATTACHMENT0_EXT;
    fb->_ColorDrawBufferIndexes[0] = BUFFER_COLOR0;
@@ -173,8 +173,7 @@ _mesa_initialize_user_framebuffer(struct gl_framebuffer *fb, GLuint name)
    fb->SampleLocationTable = NULL;
    fb->ProgrammableSampleLocations = 0;
    fb->SampleLocationPixelGrid = 0;
-   fb->Delete = _mesa_destroy_framebuffer;
-   simple_mtx_init(&fb->Mutex, mtx_plain);
+   return fb;
 }
 
 
diff --git a/src/mesa/main/framebuffer.h b/src/mesa/main/framebuffer.h
index 8891e4e41647..5ebd6a60d775 100644
--- a/src/mesa/main/framebuffer.h
+++ b/src/mesa/main/framebuffer.h
@@ -33,14 +33,10 @@ struct gl_context;
 struct gl_renderbuffer;
 
 extern struct gl_framebuffer *
-_mesa_new_framebuffer(struct gl_context *ctx, GLuint name);
-
-extern void
-_mesa_initialize_window_framebuffer(struct gl_framebuffer *fb,
-				     const struct gl_config *visual);
+_mesa_create_window_framebuffer(const struct gl_config *visual);
 
-extern void
-_mesa_initialize_user_framebuffer(struct gl_framebuffer *fb, GLuint name);
+extern struct gl_framebuffer *
+_mesa_new_framebuffer(struct gl_context *ctx, GLuint name);
 
 extern void
 _mesa_destroy_framebuffer(struct gl_framebuffer *buffer);
diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index c92a642013fd..f0f91afb00b6 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -591,10 +591,6 @@ st_framebuffer_create(struct st_context *st,
    if (!stfbi)
       return NULL;
 
-   stfb = CALLOC_STRUCT(gl_framebuffer);
-   if (!stfb)
-      return NULL;
-
    st_visual_to_context_mode(stfbi->visual, &mode);
 
    /*
@@ -637,7 +633,9 @@ st_framebuffer_create(struct st_context *st,
       }
    }
 
-   _mesa_initialize_window_framebuffer(stfb, &mode);
+   stfb = _mesa_create_window_framebuffer(&mode);
+   if (!stfb)
+      return NULL;
 
    stfb->iface = stfbi;
    stfb->iface_ID = stfbi->ID;
-- 
GitLab


From 6e4d6fd5327a7fe858912d3a90fe5240aa999b31 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 12:36:33 +0800
Subject: [PATCH 04/21] mesa/framebuffer: Rename function _mesa_new_framebuffer
 to _mesa_create_user_framebuffer

There is also a function named _mesa_create_window_framebuffer, use name of _mesa_create_user_framebuffer
for consistence.
This is a prepare for removing usage of _SIMPLE_MTX_INITIALIZER_NP in fbobject.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/fbobject.c    | 10 +++++-----
 src/mesa/main/framebuffer.c |  6 +++---
 src/mesa/main/framebuffer.h |  2 +-
 3 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 48df6d7c4dea..5da1a4ea9d93 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -176,12 +176,12 @@ _mesa_lookup_framebuffer_dsa(struct gl_context *ctx, GLuint id,
 
    /* Name exists but buffer is not initialized */
    if (fb == &DummyFramebuffer) {
-      fb = _mesa_new_framebuffer(ctx, id);
+      fb = _mesa_create_user_framebuffer(ctx, id);
       _mesa_HashInsert(ctx->Shared->FrameBuffers, id, fb, true);
    }
    /* Name doesn't exist */
    else if (!fb) {
-      fb = _mesa_new_framebuffer(ctx, id);
+      fb = _mesa_create_user_framebuffer(ctx, id);
       if (!fb) {
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
          return NULL;
@@ -3263,7 +3263,7 @@ bind_framebuffer(GLenum target, GLuint framebuffer)
 
       if (!newDrawFb) {
          /* create new framebuffer object */
-         newDrawFb = _mesa_new_framebuffer(ctx, framebuffer);
+         newDrawFb = _mesa_create_user_framebuffer(ctx, framebuffer);
          if (!newDrawFb) {
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindFramebufferEXT");
             return;
@@ -3425,7 +3425,7 @@ create_framebuffers(GLsizei n, GLuint *framebuffers, bool dsa)
 
    for (i = 0; i < n; i++) {
       if (dsa) {
-         fb = _mesa_new_framebuffer(ctx, framebuffers[i]);
+         fb = _mesa_create_user_framebuffer(ctx, framebuffers[i]);
          if (!fb) {
             _mesa_HashUnlockMutex(ctx->Shared->FrameBuffers);
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
@@ -5037,7 +5037,7 @@ lookup_named_framebuffer_ext_dsa(struct gl_context *ctx, GLuint framebuffer, con
       }
       /* Then, make sure it's initialized */
       if (fb == &DummyFramebuffer) {
-         fb = _mesa_new_framebuffer(ctx, framebuffer);
+         fb = _mesa_create_user_framebuffer(ctx, framebuffer);
          _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, fb, true);
       }
    }
diff --git a/src/mesa/main/framebuffer.c b/src/mesa/main/framebuffer.c
index 46b2b746dd99..bd822402b342 100644
--- a/src/mesa/main/framebuffer.c
+++ b/src/mesa/main/framebuffer.c
@@ -151,10 +151,10 @@ _mesa_create_window_framebuffer(const struct gl_config *visual)
  * This is the default function for ctx->Driver.NewFramebuffer().
  * This is for allocating user-created framebuffers, not window-system
  * framebuffers!
- * \sa _mesa_new_framebuffer
+ * \sa _mesa_create_user_framebuffer
  */
-static struct gl_framebuffer *
-_mesa_new_framebuffer(struct gl_context *ctx, GLuint name)
+struct gl_framebuffer *
+_mesa_create_user_framebuffer(struct gl_context *ctx, GLuint name)
 {
    struct gl_framebuffer *fb;
    (void) ctx;
diff --git a/src/mesa/main/framebuffer.h b/src/mesa/main/framebuffer.h
index 5ebd6a60d775..d5f28872f667 100644
--- a/src/mesa/main/framebuffer.h
+++ b/src/mesa/main/framebuffer.h
@@ -36,7 +36,7 @@ extern struct gl_framebuffer *
 _mesa_create_window_framebuffer(const struct gl_config *visual);
 
 extern struct gl_framebuffer *
-_mesa_new_framebuffer(struct gl_context *ctx, GLuint name);
+_mesa_create_user_framebuffer(struct gl_context *ctx, GLuint name);
 
 extern void
 _mesa_destroy_framebuffer(struct gl_framebuffer *buffer);
-- 
GitLab


From d70b145b685046acd33b4a22cf25b6f436d32190 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Fri, 17 Jun 2022 23:21:45 +0800
Subject: [PATCH 05/21] mesa/st: Refactoring _mesa_get_dummy_framebuffer out

Move DummyFramebuffer and IncompleteFramebuffer into function.
This is implemented by introduce enum gl_framebuffer_type
This is a prepare for removing usage of _SIMPLE_MTX_INITIALIZER_NP in fbobject.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/context.c             |  6 +--
 src/mesa/main/fbobject.c            | 62 ++++++++++++++++-------------
 src/mesa/main/framebuffer.c         |  3 +-
 src/mesa/main/mtypes.h              | 16 ++++++++
 src/mesa/state_tracker/st_manager.c |  2 +-
 5 files changed, 56 insertions(+), 33 deletions(-)

diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index a7e0b77c5e7f..a45cd3bd2920 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1321,7 +1321,7 @@ check_compatible(const struct gl_context *ctx,
    const struct gl_config *ctxvis = &ctx->Visual;
    const struct gl_config *bufvis = &buffer->Visual;
 
-   if (buffer == _mesa_get_incomplete_framebuffer())
+   if (buffer != NULL && buffer->Type == GL_FRAMEBUFFER_TYPE_INCOMPLETE)
       return GL_TRUE;
 
 #define check_component(foo)           \
@@ -1387,7 +1387,7 @@ handle_first_current(struct gl_context *ctx)
     * For GLES it is always GL_BACK which has a magic interpretation.
     */
    if (!ctx->HasConfig && _mesa_is_desktop_gl(ctx)) {
-      if (ctx->DrawBuffer != _mesa_get_incomplete_framebuffer()) {
+      if (ctx->DrawBuffer->Type != GL_FRAMEBUFFER_TYPE_INCOMPLETE) {
          GLenum16 buffer;
 
          if (ctx->DrawBuffer->Visual.doubleBufferMode)
@@ -1399,7 +1399,7 @@ handle_first_current(struct gl_context *ctx)
                            NULL /* destMask */);
       }
 
-      if (ctx->ReadBuffer != _mesa_get_incomplete_framebuffer()) {
+      if (ctx->ReadBuffer != NULL && ctx->ReadBuffer->Type != GL_FRAMEBUFFER_TYPE_INCOMPLETE) {
          gl_buffer_index bufferIndex;
          GLenum buffer;
 
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 5da1a4ea9d93..db976873f41b 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -78,32 +78,38 @@ delete_dummy_framebuffer(struct gl_framebuffer *fb)
    /* no op */
 }
 
-
-/*
- * When glGenRender/FramebuffersEXT() is called we insert pointers to
- * these placeholder objects into the hash table.
- * Later, when the object ID is first bound, we replace the placeholder
- * with the real frame/renderbuffer.
- */
-static struct gl_framebuffer DummyFramebuffer = {
-   .Mutex = _SIMPLE_MTX_INITIALIZER_NP,
-   .Delete = delete_dummy_framebuffer,
-};
 static struct gl_renderbuffer DummyRenderbuffer = {
    .Delete = delete_dummy_renderbuffer,
 };
 
-/* We bind this framebuffer when applications pass a NULL
- * drawable/surface in make current. */
-static struct gl_framebuffer IncompleteFramebuffer = {
-   .Mutex = _SIMPLE_MTX_INITIALIZER_NP,
-   .Delete = delete_dummy_framebuffer,
-};
-
+static inline struct gl_framebuffer *
+_mesa_get_dummy_framebuffer(void)
+{
+   /*
+    * When glGenRender/FramebuffersEXT() is called we insert pointers to
+    * these placeholder objects into the hash table.
+    * Later, when the object ID is first bound, we replace the placeholder
+    * with the real frame/renderbuffer.
+    */
+   static struct gl_framebuffer DummyFramebuffer = {
+      .Type = GL_FRAMEBUFFER_TYPE_DUMMY,
+      .Mutex = _SIMPLE_MTX_INITIALIZER_NP,
+      .Delete = delete_dummy_framebuffer,
+   };
+   return &DummyFramebuffer;
+}
 
 struct gl_framebuffer *
 _mesa_get_incomplete_framebuffer(void)
 {
+   /* We bind this framebuffer when applications pass a NULL
+    * drawable/surface in make current.
+    */
+   static struct gl_framebuffer IncompleteFramebuffer = {
+      .Type = GL_FRAMEBUFFER_TYPE_INCOMPLETE,
+      .Mutex = _SIMPLE_MTX_INITIALIZER_NP,
+      .Delete = delete_dummy_framebuffer,
+   };
    return &IncompleteFramebuffer;
 }
 
@@ -175,7 +181,7 @@ _mesa_lookup_framebuffer_dsa(struct gl_context *ctx, GLuint id,
    fb = _mesa_lookup_framebuffer(ctx, id);
 
    /* Name exists but buffer is not initialized */
-   if (fb == &DummyFramebuffer) {
+   if (fb != NULL && fb->Type == GL_FRAMEBUFFER_TYPE_DUMMY) {
       fb = _mesa_create_user_framebuffer(ctx, id);
       _mesa_HashInsert(ctx->Shared->FrameBuffers, id, fb, true);
    }
@@ -203,7 +209,7 @@ _mesa_lookup_framebuffer_err(struct gl_context *ctx, GLuint id,
    struct gl_framebuffer *fb;
 
    fb = _mesa_lookup_framebuffer(ctx, id);
-   if (!fb || fb == &DummyFramebuffer) {
+   if (fb == NULL || fb->Type == GL_FRAMEBUFFER_TYPE_DUMMY) {
       _mesa_error(ctx, GL_INVALID_OPERATION,
                   "%s(non-existent framebuffer %u)", func, id);
       return NULL;
@@ -3168,7 +3174,7 @@ _mesa_IsFramebuffer(GLuint framebuffer)
    ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, GL_FALSE);
    if (framebuffer) {
       struct gl_framebuffer *rb = _mesa_lookup_framebuffer(ctx, framebuffer);
-      if (rb != NULL && rb != &DummyFramebuffer)
+      if (rb != NULL && rb->Type != GL_FRAMEBUFFER_TYPE_DUMMY)
          return GL_TRUE;
    }
    return GL_FALSE;
@@ -3249,7 +3255,7 @@ bind_framebuffer(GLenum target, GLuint framebuffer)
       bool isGenName = false;
       /* Binding a user-created framebuffer object */
       newDrawFb = _mesa_lookup_framebuffer(ctx, framebuffer);
-      if (newDrawFb == &DummyFramebuffer) {
+      if (newDrawFb != NULL && newDrawFb->Type == GL_FRAMEBUFFER_TYPE_DUMMY) {
          /* ID was reserved, but no real framebuffer object made yet */
          newDrawFb = NULL;
          isGenName = true;
@@ -3296,7 +3302,7 @@ _mesa_bind_framebuffers(struct gl_context *ctx,
    const bool bindReadBuf = oldReadFb != newReadFb;
 
    assert(newDrawFb);
-   assert(newDrawFb != &DummyFramebuffer);
+   assert(newDrawFb->Type != GL_FRAMEBUFFER_TYPE_DUMMY);
 
    /*
     * OK, now bind the new Draw/Read framebuffers, if they're changing.
@@ -3368,7 +3374,7 @@ _mesa_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
          struct gl_framebuffer *fb;
          fb = _mesa_lookup_framebuffer(ctx, framebuffers[i]);
          if (fb) {
-            assert(fb == &DummyFramebuffer || fb->Name == framebuffers[i]);
+            assert(fb->Type == GL_FRAMEBUFFER_TYPE_DUMMY || fb->Name == framebuffers[i]);
 
             /* check if deleting currently bound framebuffer object */
             if (fb == ctx->DrawBuffer) {
@@ -3385,7 +3391,7 @@ _mesa_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
             /* remove from hash table immediately, to free the ID */
             _mesa_HashRemove(ctx->Shared->FrameBuffers, framebuffers[i]);
 
-            if (fb != &DummyFramebuffer) {
+            if (fb->Type != GL_FRAMEBUFFER_TYPE_DUMMY) {
                /* But the object will not be freed until it's no longer
                 * bound in any context.
                 */
@@ -3433,7 +3439,7 @@ create_framebuffers(GLsizei n, GLuint *framebuffers, bool dsa)
          }
       }
       else
-         fb = &DummyFramebuffer;
+         fb = _mesa_get_dummy_framebuffer();
 
       _mesa_HashInsertLocked(ctx->Shared->FrameBuffers, framebuffers[i],
                              fb, true);
@@ -3465,7 +3471,7 @@ _mesa_check_framebuffer_status(struct gl_context *ctx,
 
    if (_mesa_is_winsys_fbo(buffer)) {
       /* EGL_KHR_surfaceless_context allows the winsys FBO to be incomplete. */
-      if (buffer != &IncompleteFramebuffer) {
+      if (buffer->Type != GL_FRAMEBUFFER_TYPE_INCOMPLETE) {
          return GL_FRAMEBUFFER_COMPLETE_EXT;
       } else {
          return GL_FRAMEBUFFER_UNDEFINED;
@@ -5036,7 +5042,7 @@ lookup_named_framebuffer_ext_dsa(struct gl_context *ctx, GLuint framebuffer, con
          return NULL;
       }
       /* Then, make sure it's initialized */
-      if (fb == &DummyFramebuffer) {
+      if (fb->Type == GL_FRAMEBUFFER_TYPE_DUMMY) {
          fb = _mesa_create_user_framebuffer(ctx, framebuffer);
          _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, fb, true);
       }
diff --git a/src/mesa/main/framebuffer.c b/src/mesa/main/framebuffer.c
index bd822402b342..039ed5d8e4d4 100644
--- a/src/mesa/main/framebuffer.c
+++ b/src/mesa/main/framebuffer.c
@@ -81,7 +81,7 @@ compute_depth_max(struct gl_framebuffer *fb)
 
 /**
  * Allocate and memset to zeros of a new gl_framebuffer object.
- * This is also initialize RefCount, Delete and Mutex members
+ * This is also initialize Type, RefCount, Delete and Mutex members
  */
 static struct gl_framebuffer *
 _mesa_calloc_framebuffer(void)
@@ -89,6 +89,7 @@ _mesa_calloc_framebuffer(void)
    struct gl_framebuffer *fb = CALLOC_STRUCT(gl_framebuffer);
    if (fb) {
       memset(fb, 0, sizeof(struct gl_framebuffer));
+      fb->Type = GL_FRAMEBUFFER_TYPE_NORMAL;
       fb->RefCount = 1;
       fb->Delete = _mesa_destroy_framebuffer;
       simple_mtx_init(&fb->Mutex, mtx_plain);
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 670a40ee5456..d182ec3bda89 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -2631,6 +2631,21 @@ struct gl_renderbuffer_attachment
    GLboolean Layered;
 };
 
+enum gl_framebuffer_type {
+   /*
+    * When glGenRender/FramebuffersEXT() is called we insert pointers to
+    * these placeholder objects into the hash table.
+    * Later, when the object ID is first bound, we replace the placeholder
+    * with the real frame/renderbuffer.
+    */
+   GL_FRAMEBUFFER_TYPE_DUMMY,
+   /* We bind this framebuffer when applications pass a NULL
+    * drawable/surface in make current.
+    */
+   GL_FRAMEBUFFER_TYPE_INCOMPLETE,
+
+   GL_FRAMEBUFFER_TYPE_NORMAL,
+};
 
 /**
  * A framebuffer is a collection of renderbuffers (color, depth, stencil, etc).
@@ -2640,6 +2655,7 @@ struct gl_renderbuffer_attachment
 struct gl_framebuffer
 {
    simple_mtx_t Mutex;  /**< for thread safety */
+   enum gl_framebuffer_type Type;
    /**
     * If zero, this is a window system framebuffer.  If non-zero, this
     * is a FBO framebuffer; note that for some devices (i.e. those with
diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index f0f91afb00b6..883a9d326fee 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -83,7 +83,7 @@ st_ws_framebuffer(struct gl_framebuffer *fb)
 {
    /* FBO cannot be casted.  See st_new_framebuffer */
    if (fb && _mesa_is_winsys_fbo(fb) &&
-       fb != _mesa_get_incomplete_framebuffer())
+       fb->Type != GL_FRAMEBUFFER_TYPE_INCOMPLETE)
       return fb;
    return NULL;
 }
-- 
GitLab


From 22cba2e8d24982a424579a29740fdb279b4495a1 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Sun, 19 Jun 2022 00:16:06 +0800
Subject: [PATCH 06/21] mesa: Refactoring get_dummy_buffer_object out

By doing this to remove usage of global DummyBufferObject
This is a prepare for removing usage of _SIMPLE_MTX_INITIALIZER_NP in bufferobj.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/bufferobj.c | 44 ++++++++++++++++++++++-----------------
 src/mesa/main/mtypes.h    |  1 +
 2 files changed, 26 insertions(+), 19 deletions(-)

diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 67079f4fd866..119c769f31ad 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -641,16 +641,20 @@ buffer_usage_warning(struct gl_context *ctx, GLuint *id, const char *fmt, ...)
       buffer_usage_warning(CTX, &id, FMT, ##__VA_ARGS__); \
    } while (0)
 
-
-/**
- * Used as a placeholder for buffer objects between glGenBuffers() and
- * glBindBuffer() so that glIsBuffer() can work correctly.
- */
-static struct gl_buffer_object DummyBufferObject = {
-   .MinMaxCacheMutex = _SIMPLE_MTX_INITIALIZER_NP,
-   .RefCount = 1000*1000*1000,  /* never delete */
-};
-
+static inline struct gl_buffer_object *
+get_dummy_buffer_object(void)
+{
+   /**
+    * Used as a placeholder for buffer objects between glGenBuffers() and
+    * glBindBuffer() so that glIsBuffer() can work correctly.
+    */
+   static struct gl_buffer_object DummyBufferObject = {
+      .MinMaxCacheMutex = _SIMPLE_MTX_INITIALIZER_NP,
+      .RefCount = 1000*1000*1000,  /* never delete */
+      .IsDummy = true,
+   };
+   return &DummyBufferObject;
+}
 
 /**
  * Return pointer to address of a buffer object target.
@@ -1308,6 +1312,8 @@ _mesa_bufferobj_alloc(struct gl_context *ctx, GLuint id)
    if (!buf)
       return NULL;
 
+   memset(buf, 0, sizeof(buf[0]));
+   buf->IsDummy = false;
    buf->RefCount = 1;
    buf->Name = id;
    buf->Usage = GL_STATIC_DRAW_ARB;
@@ -1347,7 +1353,7 @@ _mesa_handle_bind_buffer_gen(struct gl_context *ctx,
       return false;
    }
 
-   if (!buf || buf == &DummyBufferObject) {
+   if (!buf || buf->IsDummy) {
       /* If this is a new buffer object id, or one which was generated but
        * never used before, allocate a buffer object now.
        */
@@ -1466,7 +1472,7 @@ _mesa_lookup_bufferobj_err(struct gl_context *ctx, GLuint buffer,
    struct gl_buffer_object *bufObj;
 
    bufObj = _mesa_lookup_bufferobj(ctx, buffer);
-   if (!bufObj || bufObj == &DummyBufferObject) {
+   if (!bufObj || bufObj->IsDummy) {
       _mesa_error(ctx, GL_INVALID_OPERATION,
                   "%s(non-existent buffer object %u)", caller, buffer);
       return NULL;
@@ -1507,7 +1513,7 @@ _mesa_multi_bind_lookup_bufferobj(struct gl_context *ctx,
 
       /* The multi-bind functions don't create the buffer objects
          when they don't exist. */
-      if (bufObj == &DummyBufferObject)
+      if (bufObj != NULL && bufObj->IsDummy)
          bufObj = NULL;
 
       if (!bufObj) {
@@ -1835,7 +1841,7 @@ delete_buffers(struct gl_context *ctx, GLsizei n, const GLuint *ids)
          struct gl_vertex_array_object *vao = ctx->Array.VAO;
          GLuint j;
 
-         assert(bufObj->Name == ids[i] || bufObj == &DummyBufferObject);
+         assert(bufObj->Name == ids[i] || bufObj->IsDummy);
 
          _mesa_buffer_unmap_all_mappings(ctx, bufObj);
 
@@ -2040,7 +2046,7 @@ create_buffers(struct gl_context *ctx, GLsizei n, GLuint *buffers, bool dsa)
          }
       }
       else
-         buf = &DummyBufferObject;
+         buf = get_dummy_buffer_object();
 
       _mesa_HashInsertLocked(ctx->Shared->BufferObjects, buffers[i], buf, true);
    }
@@ -2125,7 +2131,7 @@ _mesa_IsBuffer(GLuint id)
 
    bufObj = _mesa_lookup_bufferobj(ctx, id);
 
-   return bufObj && bufObj != &DummyBufferObject;
+   return bufObj && (!bufObj->IsDummy);
 }
 
 
@@ -5223,7 +5229,7 @@ _mesa_InvalidateBufferSubData(GLuint buffer, GLintptr offset,
     *     name of an existing buffer object."
     */
    bufObj = _mesa_lookup_bufferobj(ctx, buffer);
-   if (!bufObj || bufObj == &DummyBufferObject) {
+   if (!bufObj || bufObj->IsDummy) {
       _mesa_error(ctx, GL_INVALID_VALUE,
                   "glInvalidateBufferSubData(name = %u) invalid object",
                   buffer);
@@ -5282,7 +5288,7 @@ _mesa_InvalidateBufferData(GLuint buffer)
     *     name of an existing buffer object."
     */
    bufObj = _mesa_lookup_bufferobj(ctx, buffer);
-   if (!bufObj || bufObj == &DummyBufferObject) {
+   if (!bufObj || bufObj->IsDummy) {
       _mesa_error(ctx, GL_INVALID_VALUE,
                   "glInvalidateBufferData(name = %u) invalid object",
                   buffer);
@@ -5379,7 +5385,7 @@ _mesa_NamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset,
    struct gl_buffer_object *bufferObj;
 
    bufferObj = _mesa_lookup_bufferobj(ctx, buffer);
-   if (!bufferObj || bufferObj == &DummyBufferObject) {
+   if (!bufferObj || bufferObj->IsDummy) {
       /* Note: the extension spec is not clear about the excpected error value. */
       _mesa_error(ctx, GL_INVALID_VALUE,
                   "glNamedBufferPageCommitmentARB(name = %u) invalid object",
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index d182ec3bda89..42c63b8105d1 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1445,6 +1445,7 @@ struct gl_buffer_object
    struct hash_table *MinMaxCache;
    unsigned MinMaxCacheHitIndices;
    unsigned MinMaxCacheMissIndices;
+   bool IsDummy;
    bool MinMaxCacheDirty;
 
    bool HandleAllocated; /**< GL_ARB_bindless_texture */
-- 
GitLab


From 1db3f780c3c9b3a63bc6f6169b97785aa90ae707 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Sat, 18 Jun 2022 23:55:49 +0800
Subject: [PATCH 07/21] util: Add api util_call_once_with_context to implement
 util_mtx_lock_with_init and util_simple_mtx_lock_with_init

called should be assigned after call of call_once to avoid race

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/util/meson.build   |  2 ++
 src/util/simple_mtx.h  | 10 ++++++++++
 src/util/u_call_once.c | 40 +++++++++++++++++++++++++++++++++++++++
 src/util/u_call_once.h | 43 ++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 95 insertions(+)
 create mode 100644 src/util/u_call_once.c
 create mode 100644 src/util/u_call_once.h

diff --git a/src/util/meson.build b/src/util/meson.build
index 6cb2a5323ad2..4235d1e64e71 100644
--- a/src/util/meson.build
+++ b/src/util/meson.build
@@ -118,6 +118,8 @@ files_mesa_util = files(
   'timespec.h',
   'u_atomic.c',
   'u_atomic.h',
+  'u_call_once.c',
+  'u_call_once.h',
   'u_debug_describe.c',
   'u_debug_describe.h',
   'u_debug_refcnt.c',
diff --git a/src/util/simple_mtx.h b/src/util/simple_mtx.h
index b44ddf5386a7..75f014d3397f 100644
--- a/src/util/simple_mtx.h
+++ b/src/util/simple_mtx.h
@@ -26,6 +26,7 @@
 
 #include "util/futex.h"
 #include "util/macros.h"
+#include "util/u_call_once.h"
 
 #include "c11/threads.h"
 
@@ -182,4 +183,13 @@ simple_mtx_assert_locked(simple_mtx_t *mtx)
 
 #endif
 
+static inline void
+util_simple_mtx_lock_with_init(simple_mtx_t *mtx, struct util_call_once_state_t *once_state)
+{
+   if (!once_state->called) {
+      util_call_once_with_context(once_state, mtx, util_simple_mtx_init_plain);
+   }
+   simple_mtx_lock(mtx);
+}
+
 #endif
diff --git a/src/util/u_call_once.c b/src/util/u_call_once.c
new file mode 100644
index 000000000000..5d01aef1d836
--- /dev/null
+++ b/src/util/u_call_once.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2022 Yonggang Luo
+ * SPDX-License-Identifier: MIT
+ */
+
+#include "u_call_once.h"
+#include "simple_mtx.h"
+
+struct call_once_context
+{
+   void *context;
+   void (*callback)(void *context);
+};
+
+static thread_local struct call_once_context call_once_context;
+
+static void util_call_once_with_context_callback(void)
+{
+   struct call_once_context *once_context = &call_once_context;
+   once_context->callback(once_context->context);
+}
+
+void util_call_once_with_context(struct util_call_once_state_t *once_state, void *context, void (*callback)(void *context))
+{
+   struct call_once_context *once_context = &call_once_context;
+   once_context->context = context;
+   once_context->callback = callback;
+   call_once(&once_state->once, util_call_once_with_context_callback);
+   once_state->called = true;
+}
+
+void util_mtx_init_plain(void *mtx)
+{
+   mtx_init((mtx_t *)mtx, mtx_plain);
+}
+
+void util_simple_mtx_init_plain(void *mtx)
+{
+   simple_mtx_init((simple_mtx_t *)mtx, mtx_plain);
+}
diff --git a/src/util/u_call_once.h b/src/util/u_call_once.h
new file mode 100644
index 000000000000..90a999f6a954
--- /dev/null
+++ b/src/util/u_call_once.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2022 Yonggang Luo
+ * SPDX-License-Identifier: MIT
+ *
+ * Extend C11 call_once to support context parameter
+ */
+
+#ifndef U_CALL_ONCE_H_
+#define U_CALL_ONCE_H_
+
+#include <stdbool.h>
+
+#include "c11/threads.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct util_call_once_state_t {
+   once_flag once;
+   bool called;
+};
+
+void util_call_once_with_context(struct util_call_once_state_t *once_state, void *context, void (*callback)(void *context));
+
+void util_mtx_init_plain(void *mtx);
+
+void util_simple_mtx_init_plain(void *mtx);
+
+static inline void
+util_mtx_lock_with_init(mtx_t *mtx, struct util_call_once_state_t *once_state)
+{
+   if (!once_state->called) {
+      util_call_once_with_context(once_state, mtx, util_mtx_init_plain);
+   }
+   mtx_lock(mtx);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* U_CALL_ONCE_H_ */
-- 
GitLab


From 25fcc60f6a5bfc7d28fbd4b1a82e97f6d6f309a9 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 13:04:27 +0800
Subject: [PATCH 08/21] mesa/st: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 fbobject.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/fbobject.c | 20 ++++++++++++++++++--
 1 file changed, 18 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index db976873f41b..4161eeee2abc 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -93,9 +93,17 @@ _mesa_get_dummy_framebuffer(void)
     */
    static struct gl_framebuffer DummyFramebuffer = {
       .Type = GL_FRAMEBUFFER_TYPE_DUMMY,
-      .Mutex = _SIMPLE_MTX_INITIALIZER_NP,
       .Delete = delete_dummy_framebuffer,
    };
+   static struct util_call_once_state_t DummyFramebufferOnceState = {
+      .once = ONCE_FLAG_INIT,
+      .called = false
+   };
+   if (!DummyFramebufferOnceState.called) {
+      util_call_once_with_context(&DummyFramebufferOnceState,
+                                  &DummyFramebuffer.Mutex,
+                                  util_simple_mtx_init_plain);
+   }
    return &DummyFramebuffer;
 }
 
@@ -107,9 +115,17 @@ _mesa_get_incomplete_framebuffer(void)
     */
    static struct gl_framebuffer IncompleteFramebuffer = {
       .Type = GL_FRAMEBUFFER_TYPE_INCOMPLETE,
-      .Mutex = _SIMPLE_MTX_INITIALIZER_NP,
       .Delete = delete_dummy_framebuffer,
    };
+   struct util_call_once_state_t IncompleteFramebufferOnceState = {
+      .once = ONCE_FLAG_INIT,
+      .called = false
+   };
+   if (!IncompleteFramebufferOnceState.called) {
+      util_call_once_with_context(&IncompleteFramebufferOnceState,
+                                  &IncompleteFramebuffer.Mutex,
+                                  util_simple_mtx_init_plain);
+   }
    return &IncompleteFramebuffer;
 }
 
-- 
GitLab


From de179b68e44c583304cd1a032b39cbc978b0aa1f Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Sun, 19 Jun 2022 00:16:06 +0800
Subject: [PATCH 09/21] mesa: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 bufferobj.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/bufferobj.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 119c769f31ad..b16065f5c5b6 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -649,10 +649,18 @@ get_dummy_buffer_object(void)
     * glBindBuffer() so that glIsBuffer() can work correctly.
     */
    static struct gl_buffer_object DummyBufferObject = {
-      .MinMaxCacheMutex = _SIMPLE_MTX_INITIALIZER_NP,
       .RefCount = 1000*1000*1000,  /* never delete */
       .IsDummy = true,
    };
+   static struct util_call_once_state_t DummyBufferObjectOnceState = {
+      .once = ONCE_FLAG_INIT,
+      .called = false
+   };
+   if (!DummyBufferObjectOnceState.called) {
+      util_call_once_with_context(&DummyBufferObjectOnceState,
+                                  &DummyBufferObject.MinMaxCacheMutex,
+                                  util_simple_mtx_init_plain);
+   }
    return &DummyBufferObject;
 }
 
-- 
GitLab


From 56d1b355fc22605af202f41079b46b6ac30cea04 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Fri, 17 Jun 2022 19:46:42 +0800
Subject: [PATCH 10/21] virtio: Remove usage of _SIMPLE_MTX_INITIALIZER_NP by
 use util_call_once_with_context in vn_cs.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/virtio/vulkan/vn_cs.c | 20 +++++++++-----------
 src/virtio/vulkan/vn_cs.h |  3 +--
 2 files changed, 10 insertions(+), 13 deletions(-)

diff --git a/src/virtio/vulkan/vn_cs.c b/src/virtio/vulkan/vn_cs.c
index 8c242d4cc950..e58874c13040 100644
--- a/src/virtio/vulkan/vn_cs.c
+++ b/src/virtio/vulkan/vn_cs.c
@@ -9,12 +9,14 @@
 #include "vn_renderer.h"
 
 struct vn_cs_renderer_protocol_info _vn_cs_renderer_protocol_info = {
-   .mutex = _SIMPLE_MTX_INITIALIZER_NP,
+   .once_state.once = ONCE_FLAG_INIT,
+   .once_state.called = false
 };
 
 static void
-vn_cs_renderer_protocol_info_init_once(struct vn_instance *instance)
+vn_cs_renderer_protocol_info_init_once(void *context)
 {
+   struct vn_instance *instance = (struct vn_instance *)context;
    const struct vn_renderer_info *renderer_info = &instance->renderer->info;
    /* assume renderer protocol supports all extensions if bit 0 is not set */
    const bool support_all_exts =
@@ -36,16 +38,12 @@ vn_cs_renderer_protocol_info_init_once(struct vn_instance *instance)
 void
 vn_cs_renderer_protocol_info_init(struct vn_instance *instance)
 {
-   simple_mtx_lock(&_vn_cs_renderer_protocol_info.mutex);
-   if (_vn_cs_renderer_protocol_info.init_once) {
-      simple_mtx_unlock(&_vn_cs_renderer_protocol_info.mutex);
-      return;
+   if (!_vn_cs_renderer_protocol_info.once_state.called) {
+      util_call_once_with_context(
+         &_vn_cs_renderer_protocol_info.once_state,
+         instance,
+         vn_cs_renderer_protocol_info_init_once);
    }
-
-   vn_cs_renderer_protocol_info_init_once(instance);
-
-   _vn_cs_renderer_protocol_info.init_once = true;
-   simple_mtx_unlock(&_vn_cs_renderer_protocol_info.mutex);
 }
 
 static void
diff --git a/src/virtio/vulkan/vn_cs.h b/src/virtio/vulkan/vn_cs.h
index a467a6dbf842..3888ef70b48b 100644
--- a/src/virtio/vulkan/vn_cs.h
+++ b/src/virtio/vulkan/vn_cs.h
@@ -84,8 +84,7 @@ struct vn_cs_decoder {
 };
 
 struct vn_cs_renderer_protocol_info {
-   simple_mtx_t mutex;
-   bool init_once;
+   struct util_call_once_state_t once_state;
    uint32_t api_version;
    BITSET_DECLARE(extension_bitset, VN_INFO_EXTENSION_MAX_NUMBER + 1);
 };
-- 
GitLab


From 435d64f8b7c7cbef2d7a5c70b153b56180c882b0 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Fri, 17 Jun 2022 20:18:30 +0800
Subject: [PATCH 11/21] radv: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 radv_amdgpu_winsys.c

simple_mtx_lock(&winsys_creation_mutex)
->
util_simple_mtx_lock_with_init(&winsys_creation_mutex, &winsys_creation_mutex_once_state)

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c
index 409f77aada1f..79e676d888e4 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c
@@ -138,7 +138,11 @@ radv_amdgpu_winsys_get_chip_name(struct radeon_winsys *rws)
    return amdgpu_get_marketing_name(dev);
 }
 
-static simple_mtx_t winsys_creation_mutex = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t winsys_creation_mutex;
+static struct util_call_once_state_t winsys_creation_mutex_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
 static struct hash_table *winsyses = NULL;
 
 static void
@@ -147,7 +151,7 @@ radv_amdgpu_winsys_destroy(struct radeon_winsys *rws)
    struct radv_amdgpu_winsys *ws = (struct radv_amdgpu_winsys *)rws;
    bool destroy = false;
 
-   simple_mtx_lock(&winsys_creation_mutex);
+   util_simple_mtx_lock_with_init(&winsys_creation_mutex, &winsys_creation_mutex_once_state);
    if (!--ws->refcount) {
       _mesa_hash_table_remove_key(winsyses, ws->dev);
 
@@ -204,7 +208,7 @@ radv_amdgpu_winsys_create(int fd, uint64_t debug_flags, uint64_t perftest_flags,
    }
 
    /* We have to keep this lock till insertion. */
-   simple_mtx_lock(&winsys_creation_mutex);
+   util_simple_mtx_lock_with_init(&winsys_creation_mutex, &winsys_creation_mutex_once_state);
    if (!winsyses)
       winsyses = _mesa_pointer_hash_table_create(NULL);
    if (!winsyses) {
-- 
GitLab


From cb5a876f06e3edb10450365d805bad54da17d0f4 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Sun, 19 Jun 2022 03:07:11 +0800
Subject: [PATCH 12/21] drm: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 etnaviv_bo.c

simple_mtx_lock(&etna_drm_table_lock)
->
util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state)

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/etnaviv/drm/etnaviv_bo.c       | 16 ++++++++++------
 src/etnaviv/drm/etnaviv_bo_cache.c |  2 +-
 src/etnaviv/drm/etnaviv_device.c   |  2 +-
 src/etnaviv/drm/etnaviv_priv.h     |  1 +
 4 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/src/etnaviv/drm/etnaviv_bo.c b/src/etnaviv/drm/etnaviv_bo.c
index fc91990cf288..63df1a23aa84 100644
--- a/src/etnaviv/drm/etnaviv_bo.c
+++ b/src/etnaviv/drm/etnaviv_bo.c
@@ -30,7 +30,11 @@
 #include "etnaviv_priv.h"
 #include "etnaviv_drmif.h"
 
-simple_mtx_t etna_drm_table_lock = _SIMPLE_MTX_INITIALIZER_NP;
+simple_mtx_t etna_drm_table_lock;
+struct util_call_once_state_t etna_drm_table_lock_once_state = {
+	.once = ONCE_FLAG_INIT,
+	.called = false
+};
 
 /* set buffer name, and add to table, call w/ etna_drm_table_lock held: */
 static void set_name(struct etna_bo *bo, uint32_t name)
@@ -202,7 +206,7 @@ struct etna_bo *etna_bo_new(struct etna_device *dev, uint32_t size,
 	if (ret)
 		return NULL;
 
-	simple_mtx_lock(&etna_drm_table_lock);
+	util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 	bo = bo_from_handle(dev, size, req.handle, flags);
 	bo->reuse = 1;
 	simple_mtx_unlock(&etna_drm_table_lock);
@@ -249,7 +253,7 @@ struct etna_bo *etna_bo_from_name(struct etna_device *dev,
 		.name = name,
 	};
 
-	simple_mtx_lock(&etna_drm_table_lock);
+	util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 
 	/* check name table first, to see if bo is already open: */
 	bo = lookup_bo(dev->name_table, name);
@@ -292,7 +296,7 @@ struct etna_bo *etna_bo_from_dmabuf(struct etna_device *dev, int fd)
 	 * racing against etna_bo_del, which might invalidate the
 	 * returned handle.
 	 */
-	simple_mtx_lock(&etna_drm_table_lock);
+	util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 
 	ret = drmPrimeFDToHandle(dev->fd, fd, &handle);
 	if (ret) {
@@ -327,7 +331,7 @@ void etna_bo_del(struct etna_bo *bo)
 
 	struct etna_device *dev = bo->dev;
 
-	simple_mtx_lock(&etna_drm_table_lock);
+	util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 
 	/* Must test under table lock to avoid racing with the from_dmabuf/name
 	 * paths, which rely on the BO refcount to be stable over the lookup, so
@@ -359,7 +363,7 @@ int etna_bo_get_name(struct etna_bo *bo, uint32_t *name)
 			return ret;
 		}
 
-		simple_mtx_lock(&etna_drm_table_lock);
+		util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 		set_name(bo, req.name);
 		simple_mtx_unlock(&etna_drm_table_lock);
 		bo->reuse = 0;
diff --git a/src/etnaviv/drm/etnaviv_bo_cache.c b/src/etnaviv/drm/etnaviv_bo_cache.c
index 6828a69f671d..3312bad41ea4 100644
--- a/src/etnaviv/drm/etnaviv_bo_cache.c
+++ b/src/etnaviv/drm/etnaviv_bo_cache.c
@@ -112,7 +112,7 @@ static struct etna_bo *find_in_bucket(struct etna_bo_bucket *bucket, uint32_t fl
 {
 	struct etna_bo *bo = NULL, *tmp;
 
-	simple_mtx_lock(&etna_drm_table_lock);
+	util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 
 	if (list_is_empty(&bucket->list))
 		goto out_unlock;
diff --git a/src/etnaviv/drm/etnaviv_device.c b/src/etnaviv/drm/etnaviv_device.c
index c2b907143388..f980162560dc 100644
--- a/src/etnaviv/drm/etnaviv_device.c
+++ b/src/etnaviv/drm/etnaviv_device.c
@@ -135,7 +135,7 @@ void etna_device_del(struct etna_device *dev)
 	if (!p_atomic_dec_zero(&dev->refcnt))
 		return;
 
-	simple_mtx_lock(&etna_drm_table_lock);
+	util_simple_mtx_lock_with_init(&etna_drm_table_lock, &etna_drm_table_lock_once_state);
 	etna_device_del_impl(dev);
 	simple_mtx_unlock(&etna_drm_table_lock);
 }
diff --git a/src/etnaviv/drm/etnaviv_priv.h b/src/etnaviv/drm/etnaviv_priv.h
index f6be72357cbf..046ef6a4535f 100644
--- a/src/etnaviv/drm/etnaviv_priv.h
+++ b/src/etnaviv/drm/etnaviv_priv.h
@@ -52,6 +52,7 @@
 #include "drm-uapi/etnaviv_drm.h"
 
 extern simple_mtx_t etna_drm_table_lock;
+extern struct util_call_once_state_t etna_drm_table_lock_once_state;
 
 struct etna_bo_bucket {
 	uint32_t size;
-- 
GitLab


From cc368beb82bd5b2e1da99b0caa4dac32c980f49c Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Sat, 18 Jun 2022 02:56:35 +0800
Subject: [PATCH 13/21] drm: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 etnaviv_cmd_stream.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/etnaviv/drm/etnaviv_cmd_stream.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/etnaviv/drm/etnaviv_cmd_stream.c b/src/etnaviv/drm/etnaviv_cmd_stream.c
index 34daa8de4272..c9e506325fce 100644
--- a/src/etnaviv/drm/etnaviv_cmd_stream.c
+++ b/src/etnaviv/drm/etnaviv_cmd_stream.c
@@ -30,7 +30,11 @@
 #include "etnaviv_drmif.h"
 #include "etnaviv_priv.h"
 
-static simple_mtx_t idx_lock = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t idx_lock;
+static struct util_call_once_state_t idx_lock_once_state = {
+	.once = ONCE_FLAG_INIT,
+	.called = false
+};
 
 static void *grow(void *ptr, uint32_t nr, uint32_t *max, uint32_t sz)
 {
@@ -175,7 +179,7 @@ static uint32_t bo2idx(struct etna_cmd_stream *stream, struct etna_bo *bo,
 	struct etna_cmd_stream_priv *priv = etna_cmd_stream_priv(stream);
 	uint32_t idx;
 
-	simple_mtx_lock(&idx_lock);
+	util_simple_mtx_lock_with_init(&idx_lock, &idx_lock_once_state);
 
 	if (bo->current_stream == stream) {
 		idx = bo->idx;
-- 
GitLab


From 98e6a0b65c8d057ad068a515975013e5dbfbe54f Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 14:46:44 +0800
Subject: [PATCH 14/21] mesa: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 version.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/mesa/main/version.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/version.c b/src/mesa/main/version.c
index 74220657b4e2..1673c8cd49af 100644
--- a/src/mesa/main/version.c
+++ b/src/mesa/main/version.c
@@ -36,7 +36,11 @@
 
 #include "state_tracker/st_context.h"
 
-static simple_mtx_t override_lock = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t override_lock;
+static struct util_call_once_state_t override_lock_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
 
 /**
  * Scans 'string' to see if it ends with 'ending'.
@@ -80,7 +84,7 @@ get_gl_override(gl_api api, int *version, bool *fwd_context,
 
    STATIC_ASSERT(ARRAY_SIZE(override) == API_OPENGL_LAST + 1);
 
-   simple_mtx_lock(&override_lock);
+   util_simple_mtx_lock_with_init(&override_lock, &override_lock_once_state);
 
    if (api == API_OPENGLES)
       goto exit;
-- 
GitLab


From 4896cea35dc0c74ba0f3b6afc5e3d2c68d1bd7bc Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 14:49:45 +0800
Subject: [PATCH 15/21] intel: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 intel_nullhw.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/intel/nullhw-layer/intel_nullhw.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/intel/nullhw-layer/intel_nullhw.c b/src/intel/nullhw-layer/intel_nullhw.c
index 329a6fcf505e..7af6102e2d45 100644
--- a/src/intel/nullhw-layer/intel_nullhw.c
+++ b/src/intel/nullhw-layer/intel_nullhw.c
@@ -54,7 +54,11 @@ struct device_data {
 };
 
 static struct hash_table_u64 *vk_object_to_data = NULL;
-static simple_mtx_t vk_object_to_data_mutex = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t vk_object_to_data_mutex;
+static struct util_call_once_state_t vk_object_to_data_mutex_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
 
 static inline void ensure_vk_object_map(void)
 {
@@ -67,7 +71,7 @@ static inline void ensure_vk_object_map(void)
 
 static void *find_object_data(uint64_t obj)
 {
-   simple_mtx_lock(&vk_object_to_data_mutex);
+   util_simple_mtx_lock_with_init(&vk_object_to_data_mutex, &vk_object_to_data_mutex_once_state);
    ensure_vk_object_map();
    void *data = _mesa_hash_table_u64_search(vk_object_to_data, obj);
    simple_mtx_unlock(&vk_object_to_data_mutex);
@@ -76,7 +80,7 @@ static void *find_object_data(uint64_t obj)
 
 static void map_object(uint64_t obj, void *data)
 {
-   simple_mtx_lock(&vk_object_to_data_mutex);
+   util_simple_mtx_lock_with_init(&vk_object_to_data_mutex, &vk_object_to_data_mutex_once_state);
    ensure_vk_object_map();
    _mesa_hash_table_u64_insert(vk_object_to_data, obj, data);
    simple_mtx_unlock(&vk_object_to_data_mutex);
@@ -84,7 +88,7 @@ static void map_object(uint64_t obj, void *data)
 
 static void unmap_object(uint64_t obj)
 {
-   simple_mtx_lock(&vk_object_to_data_mutex);
+   util_simple_mtx_lock_with_init(&vk_object_to_data_mutex, &vk_object_to_data_mutex_once_state);
    _mesa_hash_table_u64_remove(vk_object_to_data, obj);
    simple_mtx_unlock(&vk_object_to_data_mutex);
 }
-- 
GitLab


From cc3847b783c617e32f007c27f44a439599d0f2ef Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 14:54:30 +0800
Subject: [PATCH 16/21] amdgpu: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 amdgpu_winsys.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
index b52e78226e95..02ce3799570a 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
@@ -44,7 +44,11 @@
 #include "sid.h"
 
 static struct hash_table *dev_tab = NULL;
-static simple_mtx_t dev_tab_mutex = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t dev_tab_mutex;
+static struct util_call_once_state_t dev_tab_mutex_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
 
 #if DEBUG
 DEBUG_GET_ONCE_BOOL_OPTION(all_bos, "RADEON_ALL_BOS", false)
@@ -169,7 +173,7 @@ static void amdgpu_winsys_destroy_locked(struct radeon_winsys *rws, bool locked)
     * from the table when the counter drops to 0.
     */
    if (!locked)
-      simple_mtx_lock(&dev_tab_mutex);
+      util_simple_mtx_lock_with_init(&dev_tab_mutex, &dev_tab_mutex_once_state);
 
    destroy = pipe_reference(&ws->reference, NULL);
    if (destroy && dev_tab) {
@@ -381,7 +385,7 @@ amdgpu_winsys_create(int fd, const struct pipe_screen_config *config,
    ws->fd = os_dupfd_cloexec(fd);
 
    /* Look up the winsys from the dev table. */
-   simple_mtx_lock(&dev_tab_mutex);
+   util_simple_mtx_lock_with_init(&dev_tab_mutex, &dev_tab_mutex_once_state);
    if (!dev_tab)
       dev_tab = util_hash_table_create_ptr_keys();
 
-- 
GitLab


From 003684a74d27680080985ee9ae0bf6178c234b9c Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 14:59:47 +0800
Subject: [PATCH 17/21] freedreno: Remove usage of _SIMPLE_MTX_INITIALIZER_NP
 in freedreno_bo.c

Replace:
simple_mtx_lock(&table_lock)
with:
util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state)

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/freedreno/drm/freedreno_bo.c            | 21 +++++++++++++--------
 src/freedreno/drm/freedreno_bo_cache.c      |  5 ++---
 src/freedreno/drm/freedreno_device.c        |  4 ++--
 src/freedreno/drm/freedreno_pipe.c          |  4 ++--
 src/freedreno/drm/freedreno_priv.h          |  1 +
 src/freedreno/drm/freedreno_ringbuffer_sp.c |  2 +-
 src/freedreno/drm/msm/msm_ringbuffer.c      |  2 +-
 7 files changed, 22 insertions(+), 17 deletions(-)

diff --git a/src/freedreno/drm/freedreno_bo.c b/src/freedreno/drm/freedreno_bo.c
index 9b67ef3e74f8..c139a83da05c 100644
--- a/src/freedreno/drm/freedreno_bo.c
+++ b/src/freedreno/drm/freedreno_bo.c
@@ -29,7 +29,12 @@
 #include "freedreno_drmif.h"
 #include "freedreno_priv.h"
 
-simple_mtx_t table_lock = _SIMPLE_MTX_INITIALIZER_NP;
+simple_mtx_t table_lock;
+struct util_call_once_state_t dev_tab_mutex_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
+
 void bo_del(struct fd_bo *bo);
 
 /* set buffer name, and add to table, call w/ table_lock held: */
@@ -113,7 +118,7 @@ bo_new(struct fd_device *dev, uint32_t size, uint32_t flags,
    if (!bo)
       return NULL;
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    /* add ourself into the handle table: */
    _mesa_hash_table_insert(dev->handle_table, &bo->handle, bo);
    simple_mtx_unlock(&table_lock);
@@ -165,7 +170,7 @@ fd_bo_from_handle(struct fd_device *dev, uint32_t handle, uint32_t size)
 {
    struct fd_bo *bo = NULL;
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
 
    bo = lookup_bo(dev->handle_table, handle);
    if (bo)
@@ -188,7 +193,7 @@ fd_bo_from_dmabuf(struct fd_device *dev, int fd)
    uint32_t handle;
    struct fd_bo *bo;
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    ret = drmPrimeFDToHandle(dev->fd, fd, &handle);
    if (ret) {
       simple_mtx_unlock(&table_lock);
@@ -221,7 +226,7 @@ fd_bo_from_name(struct fd_device *dev, uint32_t name)
    };
    struct fd_bo *bo;
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
 
    /* check name table first, to see if bo is already open: */
    bo = lookup_bo(dev->name_table, name);
@@ -305,7 +310,7 @@ fd_bo_del(struct fd_bo *bo)
    if (!p_atomic_dec_zero(&bo->refcnt))
       return;
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    bo_del_or_recycle(bo);
    simple_mtx_unlock(&table_lock);
 }
@@ -399,7 +404,7 @@ fd_bo_get_name(struct fd_bo *bo, uint32_t *name)
          return ret;
       }
 
-      simple_mtx_lock(&table_lock);
+      util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
       set_name(bo, req.name);
       simple_mtx_unlock(&table_lock);
       bo->bo_reuse = NO_CACHE;
@@ -501,7 +506,7 @@ fd_bo_upload(struct fd_bo *bo, void *src, unsigned len)
 int
 fd_bo_cpu_prep(struct fd_bo *bo, struct fd_pipe *pipe, uint32_t op)
 {
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    enum fd_bo_state state = fd_bo_state(bo);
    simple_mtx_unlock(&table_lock);
 
diff --git a/src/freedreno/drm/freedreno_bo_cache.c b/src/freedreno/drm/freedreno_bo_cache.c
index 0a70cb531f4e..d1c58099ff5e 100644
--- a/src/freedreno/drm/freedreno_bo_cache.c
+++ b/src/freedreno/drm/freedreno_bo_cache.c
@@ -28,7 +28,6 @@
 #include "freedreno_priv.h"
 
 void bo_del(struct fd_bo *bo);
-extern simple_mtx_t table_lock;
 
 static void
 add_bucket(struct fd_bo_cache *cache, int size)
@@ -136,7 +135,7 @@ find_in_bucket(struct fd_bo_bucket *bucket, uint32_t flags)
     * NOTE that intel takes ALLOC_FOR_RENDER bo's from the list tail
     * (MRU, since likely to be in GPU cache), rather than head (LRU)..
     */
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    list_for_each_entry (struct fd_bo, entry, &bucket->list, list) {
       if (fd_bo_state(entry) != FD_BO_STATE_IDLE)
          break;
@@ -170,7 +169,7 @@ retry:
          VG_BO_OBTAIN(bo);
          if (bo->funcs->madvise(bo, true) <= 0) {
             /* we've lost the backing pages, delete and try again: */
-            simple_mtx_lock(&table_lock);
+            util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
             bo_del(bo);
             simple_mtx_unlock(&table_lock);
             goto retry;
diff --git a/src/freedreno/drm/freedreno_device.c b/src/freedreno/drm/freedreno_device.c
index 57b33a11e12d..268c044aa2a7 100644
--- a/src/freedreno/drm/freedreno_device.c
+++ b/src/freedreno/drm/freedreno_device.c
@@ -142,7 +142,7 @@ fd_device_ref(struct fd_device *dev)
 void
 fd_device_purge(struct fd_device *dev)
 {
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    fd_bo_cache_cleanup(&dev->bo_cache, 0);
    fd_bo_cache_cleanup(&dev->ring_cache, 0);
    simple_mtx_unlock(&table_lock);
@@ -191,7 +191,7 @@ fd_device_del(struct fd_device *dev)
 {
    if (!p_atomic_dec_zero(&dev->refcnt))
       return;
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    fd_device_del_impl(dev);
    simple_mtx_unlock(&table_lock);
 }
diff --git a/src/freedreno/drm/freedreno_pipe.c b/src/freedreno/drm/freedreno_pipe.c
index 579c98c040be..6386a0229471 100644
--- a/src/freedreno/drm/freedreno_pipe.c
+++ b/src/freedreno/drm/freedreno_pipe.c
@@ -94,7 +94,7 @@ fd_pipe_new(struct fd_device *dev, enum fd_pipe_id id)
 struct fd_pipe *
 fd_pipe_ref(struct fd_pipe *pipe)
 {
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    fd_pipe_ref_locked(pipe);
    simple_mtx_unlock(&table_lock);
    return pipe;
@@ -111,7 +111,7 @@ fd_pipe_ref_locked(struct fd_pipe *pipe)
 void
 fd_pipe_del(struct fd_pipe *pipe)
 {
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    fd_pipe_del_locked(pipe);
    simple_mtx_unlock(&table_lock);
 }
diff --git a/src/freedreno/drm/freedreno_priv.h b/src/freedreno/drm/freedreno_priv.h
index 44d81a351f4c..535a65935b10 100644
--- a/src/freedreno/drm/freedreno_priv.h
+++ b/src/freedreno/drm/freedreno_priv.h
@@ -52,6 +52,7 @@
 #include "freedreno_ringbuffer.h"
 
 extern simple_mtx_t table_lock;
+extern struct util_call_once_state_t dev_tab_mutex_once_state;
 
 /*
  * Stupid/simple growable array implementation:
diff --git a/src/freedreno/drm/freedreno_ringbuffer_sp.c b/src/freedreno/drm/freedreno_ringbuffer_sp.c
index 37d8eeb9b414..2df25a5daf43 100644
--- a/src/freedreno/drm/freedreno_ringbuffer_sp.c
+++ b/src/freedreno/drm/freedreno_ringbuffer_sp.c
@@ -183,7 +183,7 @@ fd_submit_sp_flush_prep(struct fd_submit *submit, int in_fence_fd,
    for (unsigned i = 0; i < primary->u.nr_cmds; i++)
       fd_submit_append_bo(fd_submit, primary->u.cmds[i].ring_bo);
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    for (unsigned i = 0; i < fd_submit->nr_bos; i++) {
       fd_bo_add_fence(fd_submit->bos[i], submit->pipe, submit->fence);
       has_shared |= fd_submit->bos[i]->shared;
diff --git a/src/freedreno/drm/msm/msm_ringbuffer.c b/src/freedreno/drm/msm/msm_ringbuffer.c
index f750e1e5bf45..f9fa4585c818 100644
--- a/src/freedreno/drm/msm/msm_ringbuffer.c
+++ b/src/freedreno/drm/msm/msm_ringbuffer.c
@@ -342,7 +342,7 @@ msm_submit_flush(struct fd_submit *submit, int in_fence_fd,
       }
    }
 
-   simple_mtx_lock(&table_lock);
+   util_simple_mtx_lock_with_init(&table_lock, &dev_tab_mutex_once_state);
    for (unsigned j = 0; j < msm_submit->nr_bos; j++) {
       fd_bo_add_fence(msm_submit->bos[j], submit->pipe, submit->fence);
    }
-- 
GitLab


From a1abdf45d8eb357b420df3d15a2045f95f65c3b2 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 15:02:50 +0800
Subject: [PATCH 18/21] crocus: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 crocus_bufmgr.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/gallium/drivers/crocus/crocus_bufmgr.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/crocus/crocus_bufmgr.c b/src/gallium/drivers/crocus/crocus_bufmgr.c
index 7c4363fe632f..bf790402f5ef 100644
--- a/src/gallium/drivers/crocus/crocus_bufmgr.c
+++ b/src/gallium/drivers/crocus/crocus_bufmgr.c
@@ -164,7 +164,11 @@ struct crocus_bufmgr {
    bool bo_reuse:1;
 };
 
-static simple_mtx_t global_bufmgr_list_mutex = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t global_bufmgr_list_mutex;
+static struct util_call_once_state_t global_bufmgr_list_mutex_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
 static struct list_head global_bufmgr_list = {
    .next = &global_bufmgr_list,
    .prev = &global_bufmgr_list,
@@ -1681,7 +1685,7 @@ crocus_bufmgr_ref(struct crocus_bufmgr *bufmgr)
 void
 crocus_bufmgr_unref(struct crocus_bufmgr *bufmgr)
 {
-   simple_mtx_lock(&global_bufmgr_list_mutex);
+   util_simple_mtx_lock_with_init(&global_bufmgr_list_mutex, &global_bufmgr_list_mutex_once_state);
    if (p_atomic_dec_zero(&bufmgr->refcount)) {
       list_del(&bufmgr->link);
       crocus_bufmgr_destroy(bufmgr);
@@ -1704,7 +1708,7 @@ crocus_bufmgr_get_for_fd(struct intel_device_info *devinfo, int fd, bool bo_reus
 
    struct crocus_bufmgr *bufmgr = NULL;
 
-   simple_mtx_lock(&global_bufmgr_list_mutex);
+   util_simple_mtx_lock_with_init(&global_bufmgr_list_mutex, &global_bufmgr_list_mutex_once_state);
    list_for_each_entry(struct crocus_bufmgr, iter_bufmgr, &global_bufmgr_list, link) {
       struct stat iter_st;
       if (fstat(iter_bufmgr->fd, &iter_st))
-- 
GitLab


From eee52b0bed7adbf88cc0e8c4e8c934b0942e563c Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 15:05:29 +0800
Subject: [PATCH 19/21] iris: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 iris_bufmgr.c

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/gallium/drivers/iris/iris_bufmgr.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/iris/iris_bufmgr.c b/src/gallium/drivers/iris/iris_bufmgr.c
index e0f54fbca459..57f78371bd3c 100644
--- a/src/gallium/drivers/iris/iris_bufmgr.c
+++ b/src/gallium/drivers/iris/iris_bufmgr.c
@@ -246,7 +246,11 @@ struct iris_bufmgr {
    struct iris_border_color_pool border_color_pool;
 };
 
-static simple_mtx_t global_bufmgr_list_mutex = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t global_bufmgr_list_mutex;
+static struct util_call_once_state_t global_bufmgr_list_mutex_once_state = {
+   .once = ONCE_FLAG_INIT,
+   .called = false
+};
 static struct list_head global_bufmgr_list = {
    .next = &global_bufmgr_list,
    .prev = &global_bufmgr_list,
@@ -2509,7 +2513,7 @@ iris_bufmgr_ref(struct iris_bufmgr *bufmgr)
 void
 iris_bufmgr_unref(struct iris_bufmgr *bufmgr)
 {
-   simple_mtx_lock(&global_bufmgr_list_mutex);
+   util_simple_mtx_lock_with_init(&global_bufmgr_list_mutex, &global_bufmgr_list_mutex_once_state);
    if (p_atomic_dec_zero(&bufmgr->refcount)) {
       list_del(&bufmgr->link);
       iris_bufmgr_destroy(bufmgr);
@@ -2539,7 +2543,7 @@ iris_bufmgr_get_for_fd(struct intel_device_info *devinfo, int fd, bool bo_reuse)
 
    struct iris_bufmgr *bufmgr = NULL;
 
-   simple_mtx_lock(&global_bufmgr_list_mutex);
+   util_simple_mtx_lock_with_init(&global_bufmgr_list_mutex, &global_bufmgr_list_mutex_once_state);
    list_for_each_entry(struct iris_bufmgr, iter_bufmgr, &global_bufmgr_list, link) {
       struct stat iter_st;
       if (fstat(iter_bufmgr->fd, &iter_st))
-- 
GitLab


From 5b169c7ddada5f8c146141bd5e9b05ad4df86575 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 15:10:15 +0800
Subject: [PATCH 20/21] vulkan: Remove usage of _SIMPLE_MTX_INITIALIZER_NP in
 overlay.cpp

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/vulkan/overlay-layer/overlay.cpp | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/vulkan/overlay-layer/overlay.cpp b/src/vulkan/overlay-layer/overlay.cpp
index 55d745d10c6e..8442c063e20b 100644
--- a/src/vulkan/overlay-layer/overlay.cpp
+++ b/src/vulkan/overlay-layer/overlay.cpp
@@ -216,7 +216,11 @@ static const VkQueryPipelineStatisticFlags overlay_query_flags =
 #define OVERLAY_QUERY_COUNT (11)
 
 static struct hash_table_u64 *vk_object_to_data = NULL;
-static simple_mtx_t vk_object_to_data_mutex = _SIMPLE_MTX_INITIALIZER_NP;
+static simple_mtx_t vk_object_to_data_mutex;
+static struct util_call_once_state_t vk_object_to_data_mutex_once_state = {
+   ONCE_FLAG_INIT,
+   false
+};
 
 thread_local ImGuiContext* __MesaImGui;
 
@@ -231,7 +235,7 @@ static inline void ensure_vk_object_map(void)
 
 static void *find_object_data(uint64_t obj)
 {
-   simple_mtx_lock(&vk_object_to_data_mutex);
+   util_simple_mtx_lock_with_init(&vk_object_to_data_mutex, &vk_object_to_data_mutex_once_state);
    ensure_vk_object_map();
    void *data = _mesa_hash_table_u64_search(vk_object_to_data, obj);
    simple_mtx_unlock(&vk_object_to_data_mutex);
@@ -240,7 +244,7 @@ static void *find_object_data(uint64_t obj)
 
 static void map_object(uint64_t obj, void *data)
 {
-   simple_mtx_lock(&vk_object_to_data_mutex);
+   util_simple_mtx_lock_with_init(&vk_object_to_data_mutex, &vk_object_to_data_mutex_once_state);
    ensure_vk_object_map();
    _mesa_hash_table_u64_insert(vk_object_to_data, obj, data);
    simple_mtx_unlock(&vk_object_to_data_mutex);
@@ -248,7 +252,7 @@ static void map_object(uint64_t obj, void *data)
 
 static void unmap_object(uint64_t obj)
 {
-   simple_mtx_lock(&vk_object_to_data_mutex);
+   util_simple_mtx_lock_with_init(&vk_object_to_data_mutex, &vk_object_to_data_mutex_once_state);
    _mesa_hash_table_u64_remove(vk_object_to_data, obj);
    simple_mtx_unlock(&vk_object_to_data_mutex);
 }
-- 
GitLab


From 2c6d95976fd2407f8d453fd7105c17d3fdacc496 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Mon, 20 Jun 2022 15:11:37 +0800
Subject: [PATCH 21/21] util: Remove _SIMPLE_MTX_INITIALIZER_NP in simple_mtx.h

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/util/simple_mtx.h | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/util/simple_mtx.h b/src/util/simple_mtx.h
index 75f014d3397f..aa192cb069d4 100644
--- a/src/util/simple_mtx.h
+++ b/src/util/simple_mtx.h
@@ -68,8 +68,6 @@ typedef struct {
    uint32_t val;
 } simple_mtx_t;
 
-#define _SIMPLE_MTX_INITIALIZER_NP { 0 }
-
 #define _SIMPLE_MTX_INVALID_VALUE 0xd0d0d0d0
 
 static inline void
@@ -139,8 +137,6 @@ simple_mtx_assert_locked(simple_mtx_t *mtx)
 
 typedef mtx_t simple_mtx_t;
 
-#define _SIMPLE_MTX_INITIALIZER_NP _MTX_INITIALIZER_NP
-
 static inline void
 simple_mtx_init(simple_mtx_t *mtx, int type)
 {
-- 
GitLab

