From 1f5b93999958710c179e4a5d701b1522d01d8747 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:16:32 -0400
Subject: [PATCH 2/8] radv: add an early out in
 radv_cmd_buffer_flush_dynamic_state()

no point checking all the states if they're known to be unset
---
 src/amd/vulkan/radv_cmd_buffer.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 23f210944a29..6b8beb695f68 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4239,8 +4239,12 @@ radv_emit_msaa_state(struct radv_cmd_buffer *cmd_buffer)
 static void
 radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pipeline_is_dirty)
 {
-   uint64_t states =
+   const uint64_t states =
       cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_ALL;
+
+   if (!states)
+      return;
 
    if (states & (RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_ENABLE |
@@ -4353,8 +4357,6 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
                  RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
                  RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE))
       radv_emit_msaa_state(cmd_buffer);
-
-   cmd_buffer->state.dirty &= ~states;
 }
 
 static void
-- 
GitLab


From 1be6c9281d0aecdbff7e3e5b1c4551c475b0289a Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:38:35 -0400
Subject: [PATCH 3/8] radv: break out radv_flush_constants check

---
 src/amd/vulkan/radv_cmd_buffer.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6b8beb695f68..37f78ffd149f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4522,6 +4522,12 @@ radv_emit_all_inline_push_consts(struct radv_device *device, struct radeon_cmdbu
    }
 }
 
+ALWAYS_INLINE static bool
+radv_must_flush_constants(const struct radv_cmd_buffer *cmd_buffer, const struct radv_pipeline *pipeline, VkShaderStageFlags stages)
+{
+   return (stages & cmd_buffer->push_constant_stages) && (pipeline->push_constant_size || pipeline->dynamic_offset_count);
+}
+
 static void
 radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stages,
                      struct radv_pipeline *pipeline, VkPipelineBindPoint bind_point)
@@ -4538,8 +4544,7 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
    uint32_t internal_stages;
    uint32_t dirty_stages = 0;
 
-   stages &= cmd_buffer->push_constant_stages;
-   if (!stages || (!pipeline->push_constant_size && !pipeline->dynamic_offset_count))
+   if (!radv_must_flush_constants(cmd_buffer, pipeline, stages))
       return;
 
    internal_stages = stages;
-- 
GitLab


From cf084f442d9c090b7d93aaa6e53346f6274b791e Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Mon, 12 Sep 2022 15:41:03 -0400
Subject: [PATCH 4/8] radv: move constant flushing check out to callers

---
 src/amd/vulkan/radv_cmd_buffer.c | 23 +++++++++++++----------
 1 file changed, 13 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 37f78ffd149f..9c45e01e7f64 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4544,9 +4544,6 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
    uint32_t internal_stages;
    uint32_t dirty_stages = 0;
 
-   if (!radv_must_flush_constants(cmd_buffer, pipeline, stages))
-      return;
-
    internal_stages = stages;
    switch (bind_point) {
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
@@ -5008,7 +5005,10 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer)
 
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS;
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
+
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
+
    radv_flush_force_vrs_state(cmd_buffer);
 }
 
@@ -8788,7 +8788,9 @@ radv_before_taskmesh_draw(struct radv_cmd_buffer *cmd_buffer, const struct radv_
    }
 
    radv_flush_descriptors(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
-   radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
+
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages, &pipeline->base, VK_PIPELINE_BIND_POINT_GRAPHICS);
 
    radv_describe_draw(cmd_buffer);
    if (likely(!info->indirect)) {
@@ -9670,11 +9672,12 @@ radv_upload_compute_shader_descriptors(struct radv_cmd_buffer *cmd_buffer,
                                        VkPipelineBindPoint bind_point)
 {
    radv_flush_descriptors(cmd_buffer, VK_SHADER_STAGE_COMPUTE_BIT, &pipeline->base, bind_point);
-   radv_flush_constants(cmd_buffer,
-                        bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
-                           ? RADV_RT_STAGE_BITS
-                           : VK_SHADER_STAGE_COMPUTE_BIT,
-                        &pipeline->base, bind_point);
+   VkShaderStageFlags stages = bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
+                               ? RADV_RT_STAGE_BITS
+                               : VK_SHADER_STAGE_COMPUTE_BIT;
+   if (radv_must_flush_constants(cmd_buffer, &pipeline->base, stages))
+      radv_flush_constants(cmd_buffer, stages,
+                           &pipeline->base, bind_point);
 }
 
 static void
-- 
GitLab


From 825157ecf184fdb17e9e51d91d2d83f95b32a80f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 Jan 2023 01:14:59 +0100
Subject: [PATCH 5/8] radv: Clear some dirty flags in callers instead of emit
 functions.

---
 src/amd/vulkan/radv_cmd_buffer.c | 19 ++++++-------------
 1 file changed, 6 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 9c45e01e7f64..e4985f282204 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1885,8 +1885,6 @@ radv_emit_rbplus_state(struct radv_cmd_buffer *cmd_buffer)
       cmd_buffer->state.last_sx_blend_opt_epsilon = sx_blend_opt_epsilon;
       cmd_buffer->state.last_sx_blend_opt_control = sx_blend_opt_control;
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_RBPLUS;
 }
 
 static void
@@ -2015,8 +2013,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       radv_save_pipeline(cmd_buffer, &pipeline->base);
 
    cmd_buffer->state.emitted_graphics_pipeline = pipeline;
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_PIPELINE;
 }
 
 static enum radv_depth_clamp_mode
@@ -3515,8 +3511,6 @@ radv_emit_framebuffer_state(struct radv_cmd_buffer *cmd_buffer)
                                 S_028424_DISABLE_CONSTANT_ENCODE_REG(disable_constant_encode));
       }
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_FRAMEBUFFER;
 }
 
 static void
@@ -3539,8 +3533,6 @@ radv_emit_guardband_state(struct radv_cmd_buffer *cmd_buffer)
 
    si_write_guardband(cmd_buffer->cs, d->vk.vp.viewport_count, d->vk.vp.viewports, rast_prim,
                       d->vk.rs.polygon_mode, d->vk.rs.line.width);
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_GUARDBAND;
 }
 
 static void
@@ -3568,8 +3560,6 @@ radv_emit_index_buffer(struct radv_cmd_buffer *cmd_buffer, bool indirect)
       radeon_emit(cs, PKT3(PKT3_INDEX_BUFFER_SIZE, 0, 0));
       radeon_emit(cs, state->max_index_count);
    }
-
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_INDEX_BUFFER;
 }
 
 void
@@ -7065,6 +7055,7 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
           */
          radv_emit_fb_mip_change_flush(primary);
          radv_emit_framebuffer_state(primary);
+         primary->state.dirty &= ~RADV_CMD_DIRTY_FRAMEBUFFER;
       }
 
       if (secondary->ace_internal.cs) {
@@ -8565,10 +8556,8 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
       radv_emit_rbplus_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY) {
-      cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_NGG_QUERY;
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY)
       radv_flush_ngg_query_state(cmd_buffer);
-   }
 
    if (cmd_buffer->device->physical_device->use_ngg_culling &&
        cmd_buffer->state.graphics_pipeline->is_ngg)
@@ -8607,6 +8596,10 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       }
    }
 
+   cmd_buffer->state.dirty &=
+      ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
+        RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND | RADV_CMD_DIRTY_INDEX_BUFFER);
+
    if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
       struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
       uint64_t dynamic_states =
-- 
GitLab


From dc22e60e4dd21b4a4873fba319dbf6ce03ae9776 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 Jan 2023 01:17:08 +0100
Subject: [PATCH 6/8] radv: Move pre-computing tess info to
 radv_cmd_buffer_flush_dynamic_state.

---
 src/amd/vulkan/radv_cmd_buffer.c | 53 +++++++++++++++-----------------
 1 file changed, 24 insertions(+), 29 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index e4985f282204..6043c7dceb80 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4236,6 +4236,30 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
    if (!states)
       return;
 
+   /* Pre-compute some tessellation info that depend on the number of patch control points when the
+    * bound pipeline declared this state as dynamic.
+    */
+   if (states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
+      const struct radv_physical_device *pdevice = cmd_buffer->device->physical_device;
+      const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+      const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
+      const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+
+      /* Compute the number of patches and emit the context register. */
+      cmd_buffer->state.tess_num_patches = get_tcs_num_patches(
+         d->vk.ts.patch_control_points, tcs->info.tcs.tcs_vertices_out,
+         tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
+         tcs->info.tcs.num_linked_patch_outputs, pdevice->hs.tess_offchip_block_dw_size,
+         pdevice->rad_info.gfx_level, pdevice->rad_info.family);
+
+      /* Compute the LDS size and emit the shader register. */
+      cmd_buffer->state.tess_lds_size = calculate_tess_lds_size(
+         pdevice->rad_info.gfx_level, d->vk.ts.patch_control_points,
+         tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
+         cmd_buffer->state.tess_num_patches, tcs->info.tcs.num_linked_outputs,
+         tcs->info.tcs.num_linked_patch_outputs);
+   }
+
    if (states & (RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_ENABLE |
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE |
@@ -8616,35 +8640,6 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       }
    }
 
-   /* Pre-compute some tessellation info that depend on the number of patch control points when the
-    * bound pipeline declared this state as dynamic.
-    */
-   if (cmd_buffer->state.graphics_pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS) {
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
-
-      if (dynamic_states & RADV_CMD_DIRTY_DYNAMIC_PATCH_CONTROL_POINTS) {
-         const struct radv_physical_device *pdevice = device->physical_device;
-         const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
-         const struct radv_shader *tcs = pipeline->base.shaders[MESA_SHADER_TESS_CTRL];
-         const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-
-         /* Compute the number of patches and emit the context register. */
-         cmd_buffer->state.tess_num_patches = get_tcs_num_patches(
-            d->vk.ts.patch_control_points, tcs->info.tcs.tcs_vertices_out,
-            tcs->info.tcs.num_linked_inputs, tcs->info.tcs.num_linked_outputs,
-            tcs->info.tcs.num_linked_patch_outputs, pdevice->hs.tess_offchip_block_dw_size,
-            pdevice->rad_info.gfx_level, pdevice->rad_info.family);
-
-         /* Compute the LDS size and emit the shader register. */
-         cmd_buffer->state.tess_lds_size = calculate_tess_lds_size(
-            pdevice->rad_info.gfx_level, d->vk.ts.patch_control_points,
-            tcs->info.tcs.tcs_vertices_out, tcs->info.tcs.num_linked_inputs,
-            cmd_buffer->state.tess_num_patches, tcs->info.tcs.num_linked_outputs,
-            tcs->info.tcs.num_linked_patch_outputs);
-      }
-   }
-
    radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
 
    radv_emit_draw_registers(cmd_buffer, info);
-- 
GitLab


From 7f3af3a3a046592ed20f8305b65715a90ac1d135 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 Jan 2023 01:23:30 +0100
Subject: [PATCH 7/8] radv: Group dirty flag checks in
 radv_emit_all_graphics_state.

Based on the original idea by Mike Blumenkrantz.
Thanks to moving around some additional code in previous commits,
this now has a notable effect on VK draw overhead.
---
 src/amd/vulkan/radv_cmd_buffer.c | 111 ++++++++++++++++---------------
 1 file changed, 59 insertions(+), 52 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6043c7dceb80..141d96d349bc 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -8552,7 +8552,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
                               bool pipeline_is_dirty)
 {
    const struct radv_device *device = cmd_buffer->device;
-   bool late_scissor_emission;
+   bool late_scissor_emission = false;
 
    if (cmd_buffer->state.graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.has_epilog) {
       struct radv_shader_part *ps_epilog = NULL;
@@ -8577,70 +8577,77 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
          radv_emit_ps_epilog_state(cmd_buffer, ps_epilog, pipeline_is_dirty);
    }
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
-      radv_emit_rbplus_state(cmd_buffer);
-
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY)
-      radv_flush_ngg_query_state(cmd_buffer);
-
    if (cmd_buffer->device->physical_device->use_ngg_culling &&
        cmd_buffer->state.graphics_pipeline->is_ngg)
       radv_emit_ngg_culling_state(cmd_buffer, info);
 
-   if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
-                                   RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
-                                   RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE)) ||
-       cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
-      radv_emit_binning_state(cmd_buffer);
+   if (cmd_buffer->state.dirty) {
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
+         radv_emit_rbplus_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
-      radv_emit_graphics_pipeline(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_NGG_QUERY)
+         radv_flush_ngg_query_state(cmd_buffer);
 
-   /* This should be before the cmd_buffer->state.dirty is cleared
-    * (excluding RADV_CMD_DIRTY_PIPELINE) and after
-    * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
-   late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
+      if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
+                                    RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
+                                    RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE)) ||
+         cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
+         radv_emit_binning_state(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
-      radv_emit_framebuffer_state(cmd_buffer);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
+         radv_emit_graphics_pipeline(cmd_buffer);
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
-      radv_emit_guardband_state(cmd_buffer);
-
-   if (info->indexed) {
-      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
-         radv_emit_index_buffer(cmd_buffer, info->indirect);
-   } else {
-      /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
-       * so the state must be re-emitted before the next indexed
-       * draw.
-       */
-      if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
-         cmd_buffer->state.last_index_type = -1;
-      }
-   }
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER)
+         radv_emit_framebuffer_state(cmd_buffer);
 
-   cmd_buffer->state.dirty &=
-      ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
-        RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND | RADV_CMD_DIRTY_INDEX_BUFFER);
+      if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
+         radv_emit_guardband_state(cmd_buffer);
 
-   if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
-      struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-      uint64_t dynamic_states =
-         cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+      if (info->indexed) {
+         if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_INDEX_BUFFER)
+            radv_emit_index_buffer(cmd_buffer, info->indirect);
+      } else {
+         /* On GFX7 and later, non-indexed draws overwrite VGT_INDEX_TYPE,
+         * so the state must be re-emitted before the next indexed
+         * draw.
+         */
+         if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX7) {
+            cmd_buffer->state.last_index_type = -1;
+         }
+      }
 
-      if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
-          d->vk.fsr.fragment_size.width == 1 && d->vk.fsr.fragment_size.height == 1 &&
-          d->vk.fsr.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
-          d->vk.fsr.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
-         /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
-          * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
-          */
-         cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+      /* This should be before the cmd_buffer->state.dirty is cleared
+      * (excluding RADV_CMD_DIRTY_PIPELINE) and after
+      * cmd_buffer->state.context_roll_without_scissor_emitted is set. */
+      late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
+
+      cmd_buffer->state.dirty &=
+         ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
+         RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND | RADV_CMD_DIRTY_INDEX_BUFFER);
+
+      if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
+         struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+         uint64_t dynamic_states =
+            cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
+
+         if ((dynamic_states & RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE) &&
+            d->vk.fsr.fragment_size.width == 1 && d->vk.fsr.fragment_size.height == 1 &&
+            d->vk.fsr.combiner_ops[0] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR &&
+            d->vk.fsr.combiner_ops[1] == VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR) {
+            /* When per-vertex VRS is forced and the dynamic fragment shading rate is a no-op, ignore
+            * it. This is needed for vkd3d-proton because it always declares per-draw VRS as dynamic.
+            */
+            cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_DYNAMIC_FRAGMENT_SHADING_RATE;
+         }
       }
-   }
 
-   radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+      radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
+   } else if (unlikely(cmd_buffer->device->physical_device->rad_info.has_gfx9_scissor_bug)) {
+      /* Check GFX9 late scissor workaround state here too,
+       * because it can be needed even when there aren't any dirty flags.
+       */
+      late_scissor_emission = radv_need_late_scissor_emission(cmd_buffer, info);
+   }
 
    radv_emit_draw_registers(cmd_buffer, info);
 
-- 
GitLab


From 1e92b1698d4c47cd976a7201ce5eb4724c803f04 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 Jan 2023 01:26:10 +0100
Subject: [PATCH 8/8] radv: Mark late scissor emission and force_vrs unlikely
 in radv_emit_all_graphics_states.

---
 src/amd/vulkan/radv_cmd_buffer.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 141d96d349bc..e6d109b5de62 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -8625,7 +8625,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
          ~(RADV_CMD_DIRTY_RBPLUS | RADV_CMD_DIRTY_NGG_QUERY | RADV_CMD_DIRTY_PIPELINE |
          RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_GUARDBAND | RADV_CMD_DIRTY_INDEX_BUFFER);
 
-      if (cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1) {
+      if (unlikely(cmd_buffer->device->force_vrs != RADV_FORCE_VRS_1x1)) {
          struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
          uint64_t dynamic_states =
             cmd_buffer->state.dirty & cmd_buffer->state.emitted_graphics_pipeline->needed_dynamic_state;
@@ -8651,7 +8651,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
 
    radv_emit_draw_registers(cmd_buffer, info);
 
-   if (late_scissor_emission)
+   if (unlikely(late_scissor_emission))
       radv_emit_scissor(cmd_buffer);
 }
 
-- 
GitLab

