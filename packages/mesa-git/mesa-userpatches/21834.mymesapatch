From 53d1c6243baf6af944f2593e94104d7e21b8b7b7 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 10 Mar 2023 14:02:01 +0100
Subject: [PATCH 1/4] radv: fix the error code when the driver fails to create
 a PS epilog

It would have been returned VK_SUCCESS.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 50099d6e0713..0415034d1514 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3631,7 +3631,7 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
                             keep_statistic_info, active_nir_stages, binaries, &gs_copy_binary);
 
    if (!radv_pipeline_create_ps_epilog(pipeline, pipeline_key, lib_flags, noop_fs))
-      return result;
+      return VK_ERROR_OUT_OF_DEVICE_MEMORY;
 
    if (keep_executable_info) {
       for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; ++i) {
-- 
GitLab


From 37888605de02ddc6e7c91cadac955e22a14d1032 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 10 Mar 2023 14:00:48 +0100
Subject: [PATCH 2/4] radv: determine if a graphics pipeline needs a noop FS
 earlier

Also introduce a helper.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 26 ++++++++++++++++++--------
 1 file changed, 18 insertions(+), 8 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 0415034d1514..9ede2dcb2974 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3456,6 +3456,22 @@ radv_skip_graphics_pipeline_compile(const struct radv_graphics_pipeline *pipelin
    return binary_stages == pipeline->active_stages;
 }
 
+static bool
+radv_pipeline_needs_noop_fs(struct radv_graphics_pipeline *pipeline,
+                            VkGraphicsPipelineLibraryFlagBitsEXT lib_flags)
+{
+   if (pipeline->base.type == RADV_PIPELINE_GRAPHICS &&
+       !(radv_pipeline_to_graphics(&pipeline->base)->active_stages & VK_SHADER_STAGE_FRAGMENT_BIT))
+      return true;
+
+   if (pipeline->base.type == RADV_PIPELINE_GRAPHICS_LIB &&
+       (lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
+       !(radv_pipeline_to_graphics_lib(&pipeline->base)->base.active_stages & VK_SHADER_STAGE_FRAGMENT_BIT))
+      return true;
+
+   return false;
+}
+
 static VkResult
 radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
                                const VkGraphicsPipelineCreateInfo *pCreateInfo,
@@ -3465,6 +3481,7 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
                                VkGraphicsPipelineLibraryFlagBitsEXT lib_flags,
                                bool fast_linking_enabled)
 {
+   const bool noop_fs = radv_pipeline_needs_noop_fs(pipeline, lib_flags);
    const char *noop_fs_entrypoint = "noop_fs";
    struct radv_shader_binary *binaries[MESA_VULKAN_SHADER_STAGES] = {NULL};
    struct radv_shader_binary *gs_copy_binary = NULL;
@@ -3480,7 +3497,6 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
       .flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
    };
    bool skip_shaders_cache = false;
-   bool noop_fs = false;
    VkResult result = VK_SUCCESS;
    const bool retain_shaders =
       !!(pCreateInfo->flags & VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT);
@@ -3545,11 +3561,7 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
    if (pCreateInfo->flags & VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT)
       return VK_PIPELINE_COMPILE_REQUIRED;
 
-   if ((pipeline->base.type == RADV_PIPELINE_GRAPHICS &&
-        !(radv_pipeline_to_graphics(&pipeline->base)->active_stages & VK_SHADER_STAGE_FRAGMENT_BIT)) ||
-       (pipeline->base.type == RADV_PIPELINE_GRAPHICS_LIB &&
-        (lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
-        !(radv_pipeline_to_graphics_lib(&pipeline->base)->base.active_stages & VK_SHADER_STAGE_FRAGMENT_BIT))) {
+   if (noop_fs) {
       nir_builder fs_b = radv_meta_init_shader(device, MESA_SHADER_FRAGMENT, "noop_fs");
 
       stages[MESA_SHADER_FRAGMENT] = (struct radv_pipeline_stage) {
@@ -3560,8 +3572,6 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
             .flags = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
          },
       };
-
-      noop_fs = true;
    }
 
    radv_pipeline_get_nir(pipeline, stages, pipeline_key, retain_shaders);
-- 
GitLab


From b1aec12dc7b15ba88301bf24664522b48406389a Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 8 Feb 2023 16:26:50 +0100
Subject: [PATCH 3/4] radv: keep track of the retained NIR shaders sha1 for LTO
 pipelines

Otherwise the per pipeline cache key doesn't consider shaders at all
when they are imported from libs.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 4 ++++
 src/amd/vulkan/radv_private.h  | 1 +
 2 files changed, 5 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 9ede2dcb2974..4c03023d688f 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3084,6 +3084,8 @@ radv_pipeline_get_nir(struct radv_graphics_pipeline *pipeline, struct radv_pipel
       if (retain_shaders) {
          /* Clone the NIR shader because NIR passes after this step will change it. */
          pipeline->retained_shaders[s].nir = nir_shader_clone(NULL, stages[s].nir);
+         memcpy(pipeline->retained_shaders[s].shader_sha1, stages[s].shader_sha1,
+                sizeof(stages[s].shader_sha1));
       }
 
       stages[s].feedback.duration += os_time_get_nano() - stage_start;
@@ -3105,6 +3107,8 @@ radv_pipeline_load_retained_shaders(struct radv_graphics_pipeline *pipeline,
       stages[s].stage = s;
       stages[s].entrypoint =
          nir_shader_get_entrypoint(pipeline->retained_shaders[s].nir)->function->name;
+      memcpy(stages[s].shader_sha1, pipeline->retained_shaders[s].shader_sha1,
+             sizeof(stages[s].shader_sha1));
 
       stages[s].feedback.duration += os_time_get_nano() - stage_start;
       stages[s].feedback.flags |= VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 8269cb078de9..4b523eb7340d 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2228,6 +2228,7 @@ struct radv_graphics_pipeline {
    bool retain_shaders;
    struct {
       nir_shader *nir;
+      unsigned char shader_sha1[20];
    } retained_shaders[MESA_VULKAN_SHADER_STAGES];
 
    /* For relocation of shaders with RGP. */
-- 
GitLab


From 0a9e1b97671bcd8a820cb93172e8b38f0a3ad1ae Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 8 Feb 2023 16:29:11 +0100
Subject: [PATCH 4/4] radv: allow to cache optimized (LTO) pipelines with GPL

This should be working now, except PS epilogs that are still not
added to the cache.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 4c03023d688f..cc5ef1e86acc 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3511,11 +3511,9 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
     * - fast-linking is enabled because it's useless to cache unoptimized pipelines
     * - shaders are captured because it's for debugging purposes
     * - libraries are created with GPL
-    * - optimized (LTO) pipelines are created with GPL
     */
    if (fast_linking_enabled || keep_executable_info ||
-       (pCreateInfo->flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR) ||
-       (lib_flags & ALL_GRAPHICS_LIB_FLAGS) != ALL_GRAPHICS_LIB_FLAGS) {
+       (pCreateInfo->flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR)) {
       skip_shaders_cache = true;
    }
 
@@ -3558,6 +3556,11 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
                                                &found_in_application_cache)) {
       if (found_in_application_cache)
          pipeline_feedback.flags |= VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
+
+      /* TODO: Add PS epilogs to the cache. */
+      if (!radv_pipeline_create_ps_epilog(pipeline, pipeline_key, lib_flags, noop_fs))
+         return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+
       result = VK_SUCCESS;
       goto done;
    }
-- 
GitLab

