From 2b71d527ecd2a9c0215e2728fec6c8347e4f4bde Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 19 Jan 2023 17:06:01 +0100
Subject: [PATCH 1/5] aco/dominance: set immediate dominator for any BB without
 predecessors

---
 src/amd/compiler/aco_dominance.cpp | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_dominance.cpp b/src/amd/compiler/aco_dominance.cpp
index c3dda2be957d..1fc8231dc711 100644
--- a/src/amd/compiler/aco_dominance.cpp
+++ b/src/amd/compiler/aco_dominance.cpp
@@ -41,11 +41,16 @@ namespace aco {
 void
 dominator_tree(Program* program)
 {
-   program->blocks[0].logical_idom = 0;
-   program->blocks[0].linear_idom = 0;
-
-   for (unsigned i = 1; i < program->blocks.size(); i++) {
+   for (unsigned i = 0; i < program->blocks.size(); i++) {
       Block& block = program->blocks[i];
+
+      /* If this block has no predecessor, it dominates itself by definition */
+      if (block.linear_preds.empty()) {
+         block.linear_idom = block.index;
+         block.logical_idom = block.index;
+         continue;
+      }
+
       int new_logical_idom = -1;
       int new_linear_idom = -1;
       for (unsigned pred_idx : block.logical_preds) {
-- 
GitLab


From ad5ba24a68f48196eee63863099c4dc0b844fc03 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 19 Jan 2023 17:14:51 +0100
Subject: [PATCH 2/5] aco/value_numbering: clear hashmap between disconnected
 CFGs

There is no dominance-relationship between two disconnected CFGs,
thus no CSE is possible.
---
 src/amd/compiler/aco_opt_value_numbering.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/amd/compiler/aco_opt_value_numbering.cpp b/src/amd/compiler/aco_opt_value_numbering.cpp
index 4ce05c2572ee..a780fc71811d 100644
--- a/src/amd/compiler/aco_opt_value_numbering.cpp
+++ b/src/amd/compiler/aco_opt_value_numbering.cpp
@@ -489,6 +489,9 @@ value_numbering(Program* program)
          loop_headers.pop_back();
       }
 
+      if (block.logical_idom == (int)block.index)
+         ctx.expr_values.clear();
+
       if (block.logical_idom != -1)
          process_block(ctx, block);
       else
-- 
GitLab


From 1fb37e0aca31c171c862ed4008221fd2f79124dc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 19 Jan 2023 17:20:57 +0100
Subject: [PATCH 3/5] aco/dead_code_analysis: don't add artificial uses to
 p_startpgm

---
 src/amd/compiler/aco_dead_code_analysis.cpp | 5 -----
 src/amd/compiler/aco_ir.h                   | 1 +
 2 files changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_dead_code_analysis.cpp b/src/amd/compiler/aco_dead_code_analysis.cpp
index 4555be589474..e1dbcd536214 100644
--- a/src/amd/compiler/aco_dead_code_analysis.cpp
+++ b/src/amd/compiler/aco_dead_code_analysis.cpp
@@ -91,11 +91,6 @@ dead_code_analysis(Program* program)
       process_block(ctx, program->blocks[next_block]);
    }
 
-   /* add one use to exec to prevent startpgm from being removed */
-   aco_ptr<Instruction>& startpgm = program->blocks[0].instructions[0];
-   assert(startpgm->opcode == aco_opcode::p_startpgm);
-   ctx.uses[startpgm->definitions.back().tempId()]++;
-
    return ctx.uses;
 }
 
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 563004ed58a5..e99922896c3e 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1784,6 +1784,7 @@ inline bool
 is_dead(const std::vector<uint16_t>& uses, const Instruction* instr)
 {
    if (instr->definitions.empty() || instr->isBranch() ||
+       instr->opcode == aco_opcode::p_startpgm ||
        instr->opcode == aco_opcode::p_init_scratch ||
        instr->opcode == aco_opcode::p_dual_src_export_gfx11)
       return false;
-- 
GitLab


From 664a0e81dfd3b1cdb8d8975e964a85cb79a2fce4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 19 Jan 2023 17:36:06 +0100
Subject: [PATCH 4/5] aco/insert_exec_mask: allow for disconnected CFG

---
 src/amd/compiler/aco_insert_exec_mask.cpp | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index 63560cb6d301..a6307ac94039 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -249,7 +249,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
    std::vector<unsigned>& preds = block->linear_preds;
 
    /* start block */
-   if (idx == 0) {
+   if (preds.empty()) {
       aco_ptr<Instruction>& startpgm = block->instructions[0];
       assert(startpgm->opcode == aco_opcode::p_startpgm);
       bld.insert(std::move(startpgm));
@@ -275,10 +275,10 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
          start_exec = Operand::c32_or_c64(-1u, bld.lm == s2);
 
       if (ctx.handle_wqm) {
-         ctx.info[0].exec.emplace_back(start_exec, mask_type_global | mask_type_exact);
+         ctx.info[idx].exec.emplace_back(start_exec, mask_type_global | mask_type_exact);
          /* if this block needs WQM, initialize already */
-         if (ctx.info[0].block_needs & WQM)
-            transition_to_WQM(ctx, bld, 0);
+         if (ctx.info[idx].block_needs & WQM)
+            transition_to_WQM(ctx, bld, idx);
       } else {
          uint8_t mask = mask_type_global;
          if (ctx.program->needs_wqm) {
@@ -288,7 +288,7 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
          } else {
             mask |= mask_type_exact;
          }
-         ctx.info[0].exec.emplace_back(start_exec, mask);
+         ctx.info[idx].exec.emplace_back(start_exec, mask);
       }
 
       return count;
@@ -708,7 +708,7 @@ add_branch_code(exec_ctx& ctx, Block* block)
    unsigned idx = block->index;
    Builder bld(ctx.program, block);
 
-   if (idx == ctx.program->blocks.size() - 1)
+   if (block->linear_succs.empty())
       return;
 
    /* try to disable wqm handling */
@@ -909,8 +909,7 @@ process_block(exec_ctx& ctx, Block* block)
 
    unsigned idx = add_coupling_code(ctx, block, instructions);
 
-   assert(block->index != ctx.program->blocks.size() - 1 ||
-          ctx.info[block->index].exec.size() <= 2);
+   assert(!block->linear_succs.empty() || ctx.info[block->index].exec.size() <= 2);
 
    process_instructions(ctx, block, instructions, idx);
 
-- 
GitLab


From 417bf87928f2ff1ff1a285f28e43e944d94f5ca8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 10 Mar 2023 20:59:36 +0100
Subject: [PATCH 5/5] aco/spill: allow for disconnected CFG

---
 src/amd/compiler/aco_spill.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index f6fac869e55a..ca97f748f5e5 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -486,7 +486,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
    RegisterDemand spilled_registers;
 
    /* first block, nothing was spilled before */
-   if (block_idx == 0)
+   if (block->linear_preds.empty())
       return {0, 0};
 
    /* next use distances at the beginning of the current block */
@@ -1679,7 +1679,7 @@ end_unused_spill_vgprs(spill_ctx& ctx, Block& block, std::vector<Temp>& vgpr_spi
          vgpr_spill_temps[i] = Temp();
       }
    }
-   if (temps.empty())
+   if (temps.empty() || block.linear_preds.empty())
       return;
 
    aco_ptr<Instruction> destr{create_instruction<Pseudo_instruction>(
@@ -1743,7 +1743,7 @@ assign_spill_slots(spill_ctx& ctx, unsigned spills_to_vgpr)
    unsigned last_top_level_block_idx = 0;
    for (Block& block : ctx.program->blocks) {
 
-      if (block.kind & block_kind_top_level && !block.linear_preds.empty()) {
+      if (block.kind & block_kind_top_level) {
          last_top_level_block_idx = block.index;
 
          end_unused_spill_vgprs(ctx, block, vgpr_spill_temps, slots, ctx.spills_entry[block.index]);
-- 
GitLab

