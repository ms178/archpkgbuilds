From 263d3ab850ce2993d678ff7c130987ff227c8c70 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 10:41:20 -0500
Subject: [PATCH 01/33] nir: set nir_io_semantics::num_slots to at least 1 in
 build helpers

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_builder_opcodes_h.py | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_builder_opcodes_h.py b/src/compiler/nir/nir_builder_opcodes_h.py
index f815ab9f80ea9..694ae757d084d 100644
--- a/src/compiler/nir/nir_builder_opcodes_h.py
+++ b/src/compiler/nir/nir_builder_opcodes_h.py
@@ -147,6 +147,10 @@ _nir_build_${name}(nir_builder *build${intrinsic_decl_list(opcode)})
    if (!indices.align_mul)
       indices.align_mul = intrin->def.bit_size / 8u;
    % endif
+   % if IO_SEMANTICS in opcode.indices:
+   if (!indices.io_semantics.num_slots)
+      indices.io_semantics.num_slots = 1;
+   % endif
    % for index in opcode.indices:
    nir_intrinsic_set_${index.name}(intrin, indices.${index.name});
    % endfor
@@ -210,7 +214,7 @@ nir_${prefix}le_imm(nir_builder *build, nir_def *src1, uint64_t src2)
 #endif /* _NIR_BUILDER_OPCODES_ */"""
 
 from nir_opcodes import opcodes, type_size, type_base_type
-from nir_intrinsics import INTR_OPCODES, WRITE_MASK, ALIGN_MUL
+from nir_intrinsics import INTR_OPCODES, WRITE_MASK, ALIGN_MUL, IO_SEMANTICS
 from mako.template import Template
 
 # List of intrinsics that also need a nir_build_ prefixed factory macro.
@@ -238,4 +242,5 @@ print(Template(template).render(opcodes=opcodes,
                                 INTR_OPCODES=INTR_OPCODES,
                                 WRITE_MASK=WRITE_MASK,
                                 ALIGN_MUL=ALIGN_MUL,
+                                IO_SEMANTICS=IO_SEMANTICS,
                                 build_prefixed_intrinsics=build_prefixed_intrinsics))
-- 
GitLab


From 819391ba96b4b6d814aade693eead04520b68440 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 11:09:39 -0500
Subject: [PATCH 02/33] nir: set src_type and dest_type to float implicitly for
 IO build helpers

If you want to set it to int/uint, set .src_type or .dest_type. If you want
to set it to float, you don't need to set the type at all. It's implicitly
set to float.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_builder_opcodes_h.py | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_builder_opcodes_h.py b/src/compiler/nir/nir_builder_opcodes_h.py
index 694ae757d084d..dc32b56779de4 100644
--- a/src/compiler/nir/nir_builder_opcodes_h.py
+++ b/src/compiler/nir/nir_builder_opcodes_h.py
@@ -151,6 +151,14 @@ _nir_build_${name}(nir_builder *build${intrinsic_decl_list(opcode)})
    if (!indices.io_semantics.num_slots)
       indices.io_semantics.num_slots = 1;
    % endif
+   % if IO_SEMANTICS in opcode.indices and DEST_TYPE in opcode.indices and opcode.has_dest:
+   if (!indices.dest_type)
+      indices.dest_type = (nir_alu_type)(nir_type_float | bit_size);
+   % endif
+   % if IO_SEMANTICS in opcode.indices and SRC_TYPE in opcode.indices and opcode.num_srcs > 0:
+   if (!indices.src_type)
+      indices.src_type = (nir_alu_type)(nir_type_float | src0->bit_size);
+   % endif
    % for index in opcode.indices:
    nir_intrinsic_set_${index.name}(intrin, indices.${index.name});
    % endfor
@@ -214,7 +222,7 @@ nir_${prefix}le_imm(nir_builder *build, nir_def *src1, uint64_t src2)
 #endif /* _NIR_BUILDER_OPCODES_ */"""
 
 from nir_opcodes import opcodes, type_size, type_base_type
-from nir_intrinsics import INTR_OPCODES, WRITE_MASK, ALIGN_MUL, IO_SEMANTICS
+from nir_intrinsics import INTR_OPCODES, WRITE_MASK, ALIGN_MUL, IO_SEMANTICS, DEST_TYPE, SRC_TYPE
 from mako.template import Template
 
 # List of intrinsics that also need a nir_build_ prefixed factory macro.
@@ -243,4 +251,6 @@ print(Template(template).render(opcodes=opcodes,
                                 WRITE_MASK=WRITE_MASK,
                                 ALIGN_MUL=ALIGN_MUL,
                                 IO_SEMANTICS=IO_SEMANTICS,
+                                DEST_TYPE=DEST_TYPE,
+                                SRC_TYPE=SRC_TYPE,
                                 build_prefixed_intrinsics=build_prefixed_intrinsics))
-- 
GitLab


From 293ba3c1fafa70012785cdd43e925be564e9edee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 11:26:20 -0500
Subject: [PATCH 03/33] nir: don't set num_slots/src/dest_type/write_mask when
 they're set automatically

to those values

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_lower_clip.c               | 12 ++----------
 src/compiler/nir/nir_lower_io.c                 |  3 +--
 .../nir/nir_lower_passthrough_edgeflags.c       | 17 ++---------------
 src/compiler/nir/nir_lower_point_size_mov.c     |  5 +----
 src/compiler/nir/nir_lower_two_sided_color.c    | 11 ++++-------
 src/gallium/auxiliary/nir/nir_to_tgsi.c         |  6 +-----
 6 files changed, 11 insertions(+), 43 deletions(-)

diff --git a/src/compiler/nir/nir_lower_clip.c b/src/compiler/nir/nir_lower_clip.c
index e105929953dfb..c64f0995454df 100644
--- a/src/compiler/nir/nir_lower_clip.c
+++ b/src/compiler/nir/nir_lower_clip.c
@@ -109,7 +109,6 @@ store_clipdist_output(nir_builder *b, nir_variable *out, int location, int locat
       nir_store_output(b,
                        val[i] ? val[i] : nir_imm_zero(b, 1, 32),
                        nir_imm_int(b, location_offset),
-                       .src_type = nir_type_float32,
                        .write_mask = 0x1,
                        .component = i,
                        .io_semantics = semantics,
@@ -121,11 +120,6 @@ static void
 load_clipdist_input(nir_builder *b, nir_variable *in, int location_offset,
                     nir_def **val, bool use_load_interp)
 {
-   nir_io_semantics semantics = {
-      .location = in->data.location,
-      .num_slots = 1,
-   };
-
    nir_def *load;
    if (use_load_interp) {
       /* TODO: use sample when per-sample shading? */
@@ -134,14 +128,12 @@ load_clipdist_input(nir_builder *b, nir_variable *in, int location_offset,
       load = nir_load_interpolated_input(
          b, 4, 32, barycentric, nir_imm_int(b, location_offset),
          .base = in->data.driver_location,
-         .dest_type = nir_type_float32,
-         .io_semantics = semantics);
+         .io_semantics.location = in->data.location);
 
    } else {
       load = nir_load_input(b, 4, 32, nir_imm_int(b, location_offset),
                             .base = in->data.driver_location,
-                            .dest_type = nir_type_float32,
-                            .io_semantics = semantics);
+                            .io_semantics.location = in->data.location);
    }
 
    val[0] = nir_channel(b, load, 0);
diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index b96de5d5fe142..950b1216c3d2b 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -698,8 +698,7 @@ lower_interpolate_at(nir_intrinsic_instr *intrin, struct lower_io_state *state,
                                   offset,
                                   .base = var->data.driver_location,
                                   .component = component,
-                                  .io_semantics = semantics,
-                                  .dest_type = nir_type_float | intrin->def.bit_size);
+                                  .io_semantics = semantics);
 
    return load;
 }
diff --git a/src/compiler/nir/nir_lower_passthrough_edgeflags.c b/src/compiler/nir/nir_lower_passthrough_edgeflags.c
index 81d3913c30c0c..89c3bd0e6ef99 100644
--- a/src/compiler/nir/nir_lower_passthrough_edgeflags.c
+++ b/src/compiler/nir/nir_lower_passthrough_edgeflags.c
@@ -46,28 +46,15 @@ lower_impl(nir_function_impl *impl)
              util_bitcount64(shader->info.outputs_written));
 
       /* Load an edge flag. */
-      nir_io_semantics load_sem = { 0 };
-      load_sem.location = VERT_ATTRIB_EDGEFLAG;
-      load_sem.num_slots = 1;
-
       nir_def *load =
          nir_load_input(&b, 1, 32, nir_imm_int(&b, 0),
                         .base = shader->num_inputs++,
-                        .component = 0,
-                        .dest_type = nir_type_float32,
-                        .io_semantics = load_sem);
+                        .io_semantics.location = VERT_ATTRIB_EDGEFLAG);
 
       /* Store an edge flag. */
-      nir_io_semantics semantics = { 0 };
-      semantics.location = VARYING_SLOT_EDGE;
-      semantics.num_slots = 1;
-
       nir_store_output(&b, load, nir_imm_int(&b, 0),
                        .base = shader->num_outputs++,
-                       .component = 0,
-                       .io_semantics = semantics,
-                       .src_type = nir_type_float32,
-                       .write_mask = 0x1);
+                       .io_semantics.location = VARYING_SLOT_EDGE);
 
       nir_metadata_preserve(impl, nir_metadata_control_flow);
       return;
diff --git a/src/compiler/nir/nir_lower_point_size_mov.c b/src/compiler/nir/nir_lower_point_size_mov.c
index f199329c41308..fff6679970179 100644
--- a/src/compiler/nir/nir_lower_point_size_mov.c
+++ b/src/compiler/nir/nir_lower_point_size_mov.c
@@ -38,10 +38,7 @@ lower_point_size_mov_after(nir_builder *b, nir_variable *in)
    load = nir_fclamp(b, nir_channel(b, load, 0), nir_channel(b, load, 1), nir_channel(b, load, 2));
    if (b->shader->info.io_lowered) {
       nir_store_output(b, load, nir_imm_int(b, 0),
-                       .io_semantics.location = VARYING_SLOT_PSIZ,
-                       .io_semantics.num_slots = 1,
-                       .src_type = nir_type_float32
-      );
+                       .io_semantics.location = VARYING_SLOT_PSIZ);
    } else {
       nir_variable *out = NULL;
       /* the existing output can't be removed in order to avoid breaking xfb.
diff --git a/src/compiler/nir/nir_lower_two_sided_color.c b/src/compiler/nir/nir_lower_two_sided_color.c
index 4fc752aeee641..63d1ebef5eb43 100644
--- a/src/compiler/nir/nir_lower_two_sided_color.c
+++ b/src/compiler/nir/nir_lower_two_sided_color.c
@@ -62,19 +62,16 @@ static nir_def *
 load_input(nir_builder *b, nir_intrinsic_instr *intr, int location)
 {
    nir_def *load;
-   nir_io_semantics sem = {.location = location, .num_slots = 1};
    int c = nir_intrinsic_component(intr);
    nir_def *zero = nir_imm_int(b, 0);
    if (intr->intrinsic == nir_intrinsic_load_input)
       load = nir_load_input(b, intr->def.num_components, intr->def.bit_size, zero,
-                            .dest_type = nir_type_float32,
-                            .io_semantics = sem,
+                            .io_semantics.location = location,
                             .component = c);
    else
       load = nir_load_interpolated_input(b, intr->def.num_components, intr->def.bit_size,
                                          intr->src[0].ssa, zero,
-                                         .dest_type = nir_type_float32,
-                                         .io_semantics = sem,
+                                         .io_semantics.location = location,
                                          .component = c);
    return load;
 }
@@ -163,9 +160,9 @@ nir_lower_two_sided_color_instr(nir_builder *b, nir_instr *instr, void *data)
       face = nir_load_front_face(b, 1);
    else {
       if (b->shader->info.io_lowered) {
-         nir_io_semantics sem = {.location = VARYING_SLOT_FACE, .num_slots = 1};
          face = nir_load_input(b, 1, 32, nir_imm_int(b, 0), .base = 0,
-                               .dest_type = nir_type_bool32, .io_semantics = sem);
+                               .dest_type = nir_type_bool32,
+                               .io_semantics.location = VARYING_SLOT_FACE);
          face = nir_b2b1(b, face);
       } else {
          nir_variable *var = nir_get_variable_with_location(b->shader, nir_var_shader_in,
diff --git a/src/gallium/auxiliary/nir/nir_to_tgsi.c b/src/gallium/auxiliary/nir/nir_to_tgsi.c
index 2dda6a099a0e7..a672b9e37c401 100644
--- a/src/gallium/auxiliary/nir/nir_to_tgsi.c
+++ b/src/gallium/auxiliary/nir/nir_to_tgsi.c
@@ -3812,13 +3812,9 @@ nir_lower_primid_sysval_to_input_lower(nir_builder *b, nir_instr *instr, void *d
    nir_variable *var = nir_get_variable_with_location(b->shader, nir_var_shader_in,
                                                       VARYING_SLOT_PRIMITIVE_ID, glsl_uint_type());
 
-   nir_io_semantics semantics = {
-      .location = var->data.location,
-       .num_slots = 1
-   };
    return nir_load_input(b, 1, 32, nir_imm_int(b, 0),
                          .base = var->data.driver_location,
-                         .io_semantics = semantics);
+                         .io_semantics.location = var->data.location);
 }
 
 static bool
-- 
GitLab


From 880b8ce749076772e344b16778a4b66072f20f17 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 16:42:08 -0500
Subject: [PATCH 04/33] nir: flip the early exit condition in
 nir_lower_io_temporaries

no change in behavior other than skipping COMPUTE as well.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_lower_io_to_temporaries.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/compiler/nir/nir_lower_io_to_temporaries.c b/src/compiler/nir/nir_lower_io_to_temporaries.c
index bb6d0f3dbf933..8c7b0809bdd29 100644
--- a/src/compiler/nir/nir_lower_io_to_temporaries.c
+++ b/src/compiler/nir/nir_lower_io_to_temporaries.c
@@ -336,9 +336,10 @@ nir_lower_io_to_temporaries(nir_shader *shader, nir_function_impl *entrypoint,
 {
    struct lower_io_state state;
 
-   if (shader->info.stage == MESA_SHADER_TESS_CTRL ||
-       shader->info.stage == MESA_SHADER_TASK ||
-       shader->info.stage == MESA_SHADER_MESH) {
+   if (shader->info.stage != MESA_SHADER_VERTEX &&
+       shader->info.stage != MESA_SHADER_TESS_EVAL &&
+       shader->info.stage != MESA_SHADER_GEOMETRY &&
+       shader->info.stage != MESA_SHADER_FRAGMENT) {
       nir_metadata_preserve(entrypoint, nir_metadata_all);
       return false;
    }
-- 
GitLab


From 2fff80cf5adc151ee4645f11bedddf9ae80d6145 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 16:48:11 -0500
Subject: [PATCH 05/33] nir: remove redundant option linker_ignore_precision

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir.h                      | 5 -----
 src/compiler/nir/nir_linking_helpers.c      | 4 ++--
 src/gallium/drivers/r600/r600_pipe_common.c | 2 +-
 src/microsoft/compiler/nir_to_dxil.c        | 3 +--
 4 files changed, 4 insertions(+), 10 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 9957249f5de4f..16b36d4844c06 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4280,11 +4280,6 @@ typedef struct nir_shader_compiler_options {
 
    bool lower_uniforms_to_ubo;
 
-   /* If the precision is ignored, backends that don't handle
-    * different precisions when passing data between stages and use
-    * vectorized IO can pack more varyings when linking. */
-   bool linker_ignore_precision;
-
    /* Specifies if indirect sampler array access will trigger forced loop
     * unrolling.
     */
diff --git a/src/compiler/nir/nir_linking_helpers.c b/src/compiler/nir/nir_linking_helpers.c
index b9fdea68eca32..8874540b73bc7 100644
--- a/src/compiler/nir/nir_linking_helpers.c
+++ b/src/compiler/nir/nir_linking_helpers.c
@@ -653,7 +653,7 @@ gather_varying_component_info(nir_shader *producer, nir_shader *consumer,
             vc_info->is_32bit = glsl_type_is_32bit(type);
             vc_info->is_patch = in_var->data.patch;
             vc_info->is_per_primitive = in_var->data.per_primitive;
-            vc_info->is_mediump = !producer->options->linker_ignore_precision &&
+            vc_info->is_mediump = !(producer->options->io_options & nir_io_mediump_is_32bit) &&
                                   (in_var->data.precision == GLSL_PRECISION_MEDIUM ||
                                    in_var->data.precision == GLSL_PRECISION_LOW);
             vc_info->is_intra_stage_only = false;
@@ -719,7 +719,7 @@ gather_varying_component_info(nir_shader *producer, nir_shader *consumer,
                vc_info->is_32bit = glsl_type_is_32bit(type);
                vc_info->is_patch = out_var->data.patch;
                vc_info->is_per_primitive = out_var->data.per_primitive;
-               vc_info->is_mediump = !producer->options->linker_ignore_precision &&
+               vc_info->is_mediump = !(producer->options->io_options & nir_io_mediump_is_32bit) &&
                                      (out_var->data.precision == GLSL_PRECISION_MEDIUM ||
                                       out_var->data.precision == GLSL_PRECISION_LOW);
                vc_info->is_intra_stage_only = true;
diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index bce813f38a06f..ddc36be194105 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -1396,13 +1396,13 @@ bool r600_common_screen_init(struct r600_common_screen *rscreen,
 		.lower_ufind_msb = true,
 		.lower_to_scalar = true,
 		.lower_to_scalar_filter = r600_lower_to_scalar_instr_filter,
-		.linker_ignore_precision = true,
 		.lower_fpow = true,
 		.lower_int64_options = ~0,
 		.lower_cs_local_index_to_id = true,
 		.lower_uniforms_to_ubo = true,
 		.lower_image_offset_to_range_base = 1,
 		.vectorize_tess_levels = 1,
+		.io_options = nir_io_mediump_is_32bit,
 	};
 
 	rscreen->nir_options = nir_options;
diff --git a/src/microsoft/compiler/nir_to_dxil.c b/src/microsoft/compiler/nir_to_dxil.c
index d003cd63abbbe..ee0da85327e11 100644
--- a/src/microsoft/compiler/nir_to_dxil.c
+++ b/src/microsoft/compiler/nir_to_dxil.c
@@ -157,12 +157,11 @@ nir_options = {
    .max_unroll_iterations = 32, /* arbitrary */
    .force_indirect_unrolling = (nir_var_shader_in | nir_var_shader_out),
    .lower_device_index_to_zero = true,
-   .linker_ignore_precision = true,
    .support_16bit_alu = true,
    .preserve_mediump = true,
    .discard_is_demote = true,
    .scalarize_ddx = true,
-   .io_options = nir_io_dont_use_pos_for_non_fs_varyings,
+   .io_options = nir_io_dont_use_pos_for_non_fs_varyings | nir_io_mediump_is_32bit,
 };
 
 const nir_shader_compiler_options*
-- 
GitLab


From 91ccbe91d2eb15418807f36a59be3f3b0c131d78 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 13:27:00 -0500
Subject: [PATCH 06/33] nir: use IO intrinsics in nir_lower_bitmap

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_lower_bitmap.c | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/src/compiler/nir/nir_lower_bitmap.c b/src/compiler/nir/nir_lower_bitmap.c
index 3e6a7832d2849..0f65b848786c3 100644
--- a/src/compiler/nir/nir_lower_bitmap.c
+++ b/src/compiler/nir/nir_lower_bitmap.c
@@ -48,8 +48,6 @@
  *
  * If L8_UNORM, options->swizzle_xxxx is true.  Otherwise we can just use
  * the .w comp.
- *
- * Run before nir_lower_io.
  */
 
 static void
@@ -60,8 +58,17 @@ lower_bitmap(nir_shader *shader, nir_builder *b,
    nir_tex_instr *tex;
    nir_def *cond;
 
-   texcoord = nir_load_var(b, nir_get_variable_with_location(shader, nir_var_shader_in,
-                                                             VARYING_SLOT_TEX0, glsl_vec4_type()));
+   if (shader->info.io_lowered) {
+      nir_def *baryc =
+         nir_load_barycentric_pixel(b, 32, .interp_mode = INTERP_MODE_SMOOTH);
+      texcoord = nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
+                                             .io_semantics.location = VARYING_SLOT_TEX0);
+   } else {
+      nir_variable *var =
+         nir_get_variable_with_location(shader, nir_var_shader_in,
+                                        VARYING_SLOT_TEX0, glsl_vec4_type());
+      texcoord = nir_load_var(b, var);
+   }
 
    const struct glsl_type *sampler2D =
       glsl_sampler_type(GLSL_SAMPLER_DIM_2D, false, false, GLSL_TYPE_FLOAT);
-- 
GitLab


From ef443f4a33600e33d5492c3ae07776f632224426 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 13:36:44 -0500
Subject: [PATCH 07/33] nir: use IO intrinsics in nir_lower_drawpixels

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_lower_drawpixels.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/compiler/nir/nir_lower_drawpixels.c b/src/compiler/nir/nir_lower_drawpixels.c
index 3f0874a863487..f9aa247291957 100644
--- a/src/compiler/nir/nir_lower_drawpixels.c
+++ b/src/compiler/nir/nir_lower_drawpixels.c
@@ -40,6 +40,13 @@ typedef struct {
 static nir_def *
 get_texcoord(nir_builder *b, lower_drawpixels_state *state)
 {
+   if (b->shader->info.io_lowered) {
+      nir_def *baryc =
+         nir_load_barycentric_pixel(b, 32, .interp_mode = INTERP_MODE_SMOOTH);
+      return nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
+                                         .io_semantics.location = VARYING_SLOT_TEX0);
+   }
+
    if (state->texcoord == NULL) {
       state->texcoord = nir_get_variable_with_location(state->shader, nir_var_shader_in,
                                                        VARYING_SLOT_TEX0, glsl_vec4_type());
-- 
GitLab


From 3d438bdd3e96599bcbcd2b9ea2e3f192a55b25cc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 09:35:13 -0500
Subject: [PATCH 08/33] mesa: remove unused PROGRAM_SYSTEM_VALUE

ARB_vp/fp don't have system values.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/shader_enums.h       |  5 ++---
 src/mesa/program/prog_parameter.h |  1 -
 src/mesa/program/prog_print.c     |  5 -----
 src/mesa/program/prog_to_nir.c    | 17 -----------------
 4 files changed, 2 insertions(+), 26 deletions(-)

diff --git a/src/compiler/shader_enums.h b/src/compiler/shader_enums.h
index c8af292c0106c..9a3caa31feee4 100644
--- a/src/compiler/shader_enums.h
+++ b/src/compiler/shader_enums.h
@@ -557,9 +557,8 @@ _mesa_varying_slot_in_fs(gl_varying_slot slot)
 /*@}*/
 
 /**
- * If the gl_register_file is PROGRAM_SYSTEM_VALUE, the register index will be
- * one of these values.  If a NIR variable's mode is nir_var_system_value, it
- * will be one of these values.
+ * If a NIR variable's mode is nir_var_system_value, it will be one of these
+ * values.
  */
 typedef enum
 {
diff --git a/src/mesa/program/prog_parameter.h b/src/mesa/program/prog_parameter.h
index 8e275a800bbd3..37c0917ff38d3 100644
--- a/src/mesa/program/prog_parameter.h
+++ b/src/mesa/program/prog_parameter.h
@@ -61,7 +61,6 @@ typedef enum
    PROGRAM_UNIFORM,     /**< gl_program->Parameters[] */
    PROGRAM_WRITE_ONLY,  /**< A dummy, write-only register */
    PROGRAM_ADDRESS,     /**< machine->AddressReg */
-   PROGRAM_SYSTEM_VALUE,/**< InstanceId, PrimitiveID, etc. */
    PROGRAM_UNDEFINED,   /**< Invalid/TBD value */
    PROGRAM_FILE_MAX
 } gl_register_file;
diff --git a/src/mesa/program/prog_print.c b/src/mesa/program/prog_print.c
index 1626ca0f9f2b8..8e5450717bc08 100644
--- a/src/mesa/program/prog_print.c
+++ b/src/mesa/program/prog_print.c
@@ -63,8 +63,6 @@ _mesa_register_file_name(gl_register_file f)
       return "UNIFORM";
    case PROGRAM_ADDRESS:
       return "ADDR";
-   case PROGRAM_SYSTEM_VALUE:
-      return "SYSVAL";
    case PROGRAM_UNDEFINED:
       return "UNDEFINED";
    default:
@@ -394,9 +392,6 @@ reg_string(gl_register_file f, GLint index, gl_prog_print_mode mode,
       case PROGRAM_UNIFORM: /* extension */
          sprintf(str, "uniform[%s%d]", addr, index);
          break;
-      case PROGRAM_SYSTEM_VALUE:
-         sprintf(str, "sysvalue[%s%d]", addr, index);
-         break;
       case PROGRAM_STATE_VAR:
          {
             struct gl_program_parameter *param
diff --git a/src/mesa/program/prog_to_nir.c b/src/mesa/program/prog_to_nir.c
index 513ac6846ace4..68f6d778722d9 100644
--- a/src/mesa/program/prog_to_nir.c
+++ b/src/mesa/program/prog_to_nir.c
@@ -55,7 +55,6 @@ struct ptn_compile {
    nir_variable *parameters;
    nir_variable *input_vars[VARYING_SLOT_MAX];
    nir_variable *output_vars[VARYING_SLOT_MAX];
-   nir_variable *sysval_vars[SYSTEM_VALUE_MAX];
    nir_variable *sampler_vars[32]; /* matches number of bits in TexSrcUnit */
    nir_def **output_regs;
    nir_def **temp_regs;
@@ -94,15 +93,6 @@ ptn_get_src(struct ptn_compile *c, const struct prog_src_register *prog_src)
       src.src = nir_src_for_ssa(nir_load_var(b, var));
       break;
    }
-   case PROGRAM_SYSTEM_VALUE: {
-      assert(!prog_src->RelAddr);
-
-      assert(prog_src->Index >= 0 && prog_src->Index < SYSTEM_VALUE_MAX);
-
-      nir_variable *var = c->sysval_vars[prog_src->Index];
-      src.src = nir_src_for_ssa(nir_load_var(b, var));
-      break;
-   }
    case PROGRAM_STATE_VAR:
    case PROGRAM_CONSTANT: {
       /* We actually want to look at the type in the Parameters list for this,
@@ -798,13 +788,6 @@ setup_registers_and_variables(struct ptn_compile *c)
       c->input_vars[i] = var;
    }
 
-   /* Create system value variables */
-   int i;
-   BITSET_FOREACH_SET(i, c->prog->info.system_values_read, SYSTEM_VALUE_MAX) {
-      c->sysval_vars[i] = nir_create_variable_with_location(b->shader, nir_var_system_value,
-                                                            i, glsl_vec4_type());
-   }
-
    /* Create output registers and variables. */
    int max_outputs = util_last_bit64(c->prog->info.outputs_written);
    c->output_regs = rzalloc_array(c, nir_def *, max_outputs);
-- 
GitLab


From a6692b2012152963d640fa14d1afce21c56ba7d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 09:36:24 -0500
Subject: [PATCH 09/33] mesa: remove unused PROGRAM_WRITE_ONLY

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/program/prog_parameter.h        | 1 -
 src/mesa/program/prog_parameter_layout.c | 6 +++---
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/mesa/program/prog_parameter.h b/src/mesa/program/prog_parameter.h
index 37c0917ff38d3..26e2c3da72c48 100644
--- a/src/mesa/program/prog_parameter.h
+++ b/src/mesa/program/prog_parameter.h
@@ -59,7 +59,6 @@ typedef enum
    PROGRAM_STATE_VAR,   /**< gl_program->Parameters[] */
    PROGRAM_CONSTANT,    /**< gl_program->Parameters[] */
    PROGRAM_UNIFORM,     /**< gl_program->Parameters[] */
-   PROGRAM_WRITE_ONLY,  /**< A dummy, write-only register */
    PROGRAM_ADDRESS,     /**< machine->AddressReg */
    PROGRAM_UNDEFINED,   /**< Invalid/TBD value */
    PROGRAM_FILE_MAX
diff --git a/src/mesa/program/prog_parameter_layout.c b/src/mesa/program/prog_parameter_layout.c
index be97a6a7deb4f..0f49f7e68ad7a 100644
--- a/src/mesa/program/prog_parameter_layout.c
+++ b/src/mesa/program/prog_parameter_layout.c
@@ -197,7 +197,7 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 
          if (inst->SrcReg[i].Base.RelAddr ||
              inst->SrcReg[i].Base.File <= PROGRAM_OUTPUT ||
-             inst->SrcReg[i].Base.File >= PROGRAM_WRITE_ONLY ||
+             inst->SrcReg[i].Base.File >= PROGRAM_ADDRESS ||
              p->Type != PROGRAM_CONSTANT)
             continue;
 
@@ -234,7 +234,7 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 
          if (inst->SrcReg[i].Base.RelAddr ||
              inst->SrcReg[i].Base.File <= PROGRAM_OUTPUT ||
-             inst->SrcReg[i].Base.File >= PROGRAM_WRITE_ONLY ||
+             inst->SrcReg[i].Base.File >= PROGRAM_ADDRESS ||
              p->Type != PROGRAM_STATE_VAR)
             continue;
 
@@ -271,7 +271,7 @@ _mesa_layout_parameters(struct asm_parser_state *state)
 
          if (inst->SrcReg[i].Base.RelAddr ||
              inst->SrcReg[i].Base.File <= PROGRAM_OUTPUT ||
-             inst->SrcReg[i].Base.File >= PROGRAM_WRITE_ONLY ||
+             inst->SrcReg[i].Base.File >= PROGRAM_ADDRESS ||
              p->Type != PROGRAM_STATE_VAR)
             continue;
 
-- 
GitLab


From 2ac581d2f2c68a01ae98dd8778541c106ecbcb36 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 12:00:32 -0500
Subject: [PATCH 10/33] st/mesa: fold st_translate_prog_to_nir into prog_to_nir

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/program/prog_to_nir.c      |  5 +++--
 src/mesa/program/prog_to_nir.h      |  4 ++--
 src/mesa/state_tracker/st_program.c | 22 ++--------------------
 3 files changed, 7 insertions(+), 24 deletions(-)

diff --git a/src/mesa/program/prog_to_nir.c b/src/mesa/program/prog_to_nir.c
index 68f6d778722d9..7c4bd6357b3c9 100644
--- a/src/mesa/program/prog_to_nir.c
+++ b/src/mesa/program/prog_to_nir.c
@@ -835,9 +835,10 @@ setup_registers_and_variables(struct ptn_compile *c)
 }
 
 struct nir_shader *
-prog_to_nir(const struct gl_context *ctx, const struct gl_program *prog,
-            const nir_shader_compiler_options *options)
+prog_to_nir(const struct gl_context *ctx, const struct gl_program *prog)
 {
+   const struct nir_shader_compiler_options *options =
+      st_get_nir_compiler_options(ctx->st, prog->info.stage);
    struct ptn_compile *c;
    struct nir_shader *s;
    gl_shader_stage stage = _mesa_program_enum_to_shader_stage(prog->Target);
diff --git a/src/mesa/program/prog_to_nir.h b/src/mesa/program/prog_to_nir.h
index ad7c8e70c7f59..6e5a8ec2843ce 100644
--- a/src/mesa/program/prog_to_nir.h
+++ b/src/mesa/program/prog_to_nir.h
@@ -30,8 +30,8 @@
 extern "C" {
 #endif
 
-struct nir_shader *prog_to_nir(const struct gl_context *ctx, const struct gl_program *prog,
-                               const nir_shader_compiler_options *options);
+struct nir_shader *prog_to_nir(const struct gl_context *ctx,
+                               const struct gl_program *prog);
 
 enum glsl_sampler_dim _mesa_texture_index_to_sampler_dim(gl_texture_index index,
                                                          bool *is_array);
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 4759dd7dbf475..bf31958209b4c 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -410,22 +410,6 @@ st_prog_to_nir_postprocess(struct st_context *st, nir_shader *nir,
    nir_validate_shader(nir, "after st/glsl finalize_nir");
 }
 
-/**
- * Translate ARB (asm) program to NIR
- */
-static nir_shader *
-st_translate_prog_to_nir(struct st_context *st, struct gl_program *prog,
-                         gl_shader_stage stage)
-{
-   const struct nir_shader_compiler_options *options =
-      st_get_nir_compiler_options(st, prog->info.stage);
-
-   /* Translate to NIR */
-   nir_shader *nir = prog_to_nir(st->ctx, prog, options);
-
-   return nir;
-}
-
 /**
  * Prepare st_vertex_program info.
  *
@@ -616,8 +600,7 @@ st_translate_vertex_program(struct st_context *st,
 
    prog->state.type = PIPE_SHADER_IR_NIR;
    if (prog->arb.Instructions)
-      prog->nir = st_translate_prog_to_nir(st, prog,
-                                           MESA_SHADER_VERTEX);
+      prog->nir = prog_to_nir(st->ctx, prog);
    st_prog_to_nir_postprocess(st, prog->nir, prog);
    prog->info = prog->nir->info;
 
@@ -1021,8 +1004,7 @@ st_translate_fragment_program(struct st_context *st,
 
    prog->state.type = PIPE_SHADER_IR_NIR;
    if (prog->arb.Instructions) {
-      prog->nir = st_translate_prog_to_nir(st, prog,
-                                          MESA_SHADER_FRAGMENT);
+      prog->nir = prog_to_nir(st->ctx, prog);
    } else if (prog->ati_fs) {
       const struct nir_shader_compiler_options *options =
          st_get_nir_compiler_options(st, MESA_SHADER_FRAGMENT);
-- 
GitLab


From 80ee3c4ea4c7b007c21614f978a3ccd80dffe44e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 15:18:56 -0500
Subject: [PATCH 11/33] st/mesa: run DCE before st_unlower_io_to_vars

Some lowering passes can leave dead code behind, but dead IO intrinsics
are still counted as enabled IO, which breaks things.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_program.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index bf31958209b4c..7af6ea92cefa5 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -856,6 +856,10 @@ st_create_common_variant(struct st_context *st,
         key->is_draw_shader)) {
       assert(!state.stream_output.num_outputs || state.ir.nir->xfb_info);
       get_stream_output_info_from_nir(state.ir.nir, &state.stream_output);
+      /* Some lowering passes can leave dead code behind, but dead IO intrinsics
+       * are still counted as enabled IO, which breaks things.
+       */
+      NIR_PASS(_, state.ir.nir, nir_opt_dce);
       NIR_PASS(_, state.ir.nir, st_nir_unlower_io_to_vars);
 
       if (state.ir.nir->info.stage == MESA_SHADER_TESS_CTRL &&
@@ -1235,6 +1239,10 @@ st_create_fp_variant(struct st_context *st,
    /* This should be after all passes that touch IO. */
    if (state.ir.nir->info.io_lowered &&
        !(state.ir.nir->options->io_options & nir_io_has_intrinsics)) {
+      /* Some lowering passes can leave dead code behind, but dead IO intrinsics
+       * are still counted as enabled IO, which breaks things.
+       */
+      NIR_PASS(_, state.ir.nir, nir_opt_dce);
       NIR_PASS(_, state.ir.nir, st_nir_unlower_io_to_vars);
       gl_nir_opts(state.ir.nir);
       finalize = true;
-- 
GitLab


From 70596c3edd07342c1e543bf34258079c34ad8f4c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 10:34:42 -0500
Subject: [PATCH 12/33] st/mesa: use IO intrinsics in st_nir_lower_fog

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_nir_lower_fog.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/src/mesa/state_tracker/st_nir_lower_fog.c b/src/mesa/state_tracker/st_nir_lower_fog.c
index 3aa4ca578fa06..6901d2418f37b 100644
--- a/src/mesa/state_tracker/st_nir_lower_fog.c
+++ b/src/mesa/state_tracker/st_nir_lower_fog.c
@@ -11,10 +11,19 @@ static nir_def *
 fog_result(nir_builder *b, nir_def *color, enum gl_fog_mode fog_mode, struct gl_program_parameter_list *paramList)
 {
    nir_shader *s = b->shader;
-   nir_variable *fogc_var =
-      nir_create_variable_with_location(s, nir_var_shader_in, VARYING_SLOT_FOGC, glsl_float_type());
-   nir_def *fogc = nir_load_var(b, fogc_var);
-   s->info.inputs_read |= VARYING_BIT_FOGC;
+   nir_def *fogc;
+
+   if (b->shader->info.io_lowered) {
+      nir_def *baryc = nir_load_barycentric_pixel(b, 32,
+                                                  .interp_mode = INTERP_MODE_SMOOTH);
+      fogc = nir_load_interpolated_input(b, 1, 32, baryc, nir_imm_int(b, 0),
+                                         .io_semantics.location = VARYING_SLOT_FOGC);
+   } else {
+      nir_variable *fogc_var =
+         nir_create_variable_with_location(s, nir_var_shader_in, VARYING_SLOT_FOGC, glsl_float_type());
+      s->info.inputs_read |= VARYING_BIT_FOGC;
+      fogc = nir_load_var(b, fogc_var);
+   }
 
    static const gl_state_index16 fog_params_tokens[STATE_LENGTH] = {STATE_FOG_PARAMS_OPTIMIZED};
    static const gl_state_index16 fog_color_tokens[STATE_LENGTH] = {STATE_FOG_COLOR};
-- 
GitLab


From ff2ddc1b4286db9cc08488e87926716ba4969473 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 10:48:32 -0500
Subject: [PATCH 13/33] st/mesa: use IO intrinsics in
 st_nir_lower_position_invariant

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 .../st_nir_lower_position_invariant.c         | 28 +++++++++++++++----
 1 file changed, 22 insertions(+), 6 deletions(-)

diff --git a/src/mesa/state_tracker/st_nir_lower_position_invariant.c b/src/mesa/state_tracker/st_nir_lower_position_invariant.c
index 0904e3838f168..c57368db1b8bf 100644
--- a/src/mesa/state_tracker/st_nir_lower_position_invariant.c
+++ b/src/mesa/state_tracker/st_nir_lower_position_invariant.c
@@ -33,9 +33,18 @@ st_nir_lower_position_invariant(struct nir_shader *s, bool aos,
    }
 
    nir_def *result;
-   nir_def *in_pos = nir_load_var(&b, nir_get_variable_with_location(s, nir_var_shader_in,
-                                                                         VERT_ATTRIB_POS, glsl_vec4_type()));
-   s->info.inputs_read |= VERT_BIT_POS;
+   nir_def *in_pos;
+
+   if (s->info.io_lowered) {
+      in_pos = nir_load_input(&b, 4, 32, nir_imm_int(&b, 0),
+                              .io_semantics.location = VERT_ATTRIB_POS);
+   } else {
+      in_pos = nir_load_var(&b, nir_get_variable_with_location(s, nir_var_shader_in,
+                                                               VERT_ATTRIB_POS,
+                                                               glsl_vec4_type()));
+      s->info.inputs_read |= VERT_BIT_POS;
+   }
+
    if (aos) {
       nir_def *chans[4];
       for (int i = 0; i < 4; i++)
@@ -46,9 +55,16 @@ st_nir_lower_position_invariant(struct nir_shader *s, bool aos,
       for (int i = 1; i < 4; i++)
          result = nir_fmad(&b, mvp[i], nir_channel(&b, in_pos, i), result);
    }
-   nir_store_var(&b, nir_get_variable_with_location(s, nir_var_shader_out,
-                                                    VARYING_SLOT_POS, glsl_vec4_type()), result, 0xf);
-   s->info.outputs_written |= VARYING_BIT_POS;
+
+   if (s->info.io_lowered) {
+      nir_store_output(&b, result, nir_imm_int(&b, 0),
+                       .io_semantics.location = VARYING_SLOT_POS);
+   } else {
+      nir_store_var(&b, nir_get_variable_with_location(s, nir_var_shader_out,
+                                                       VARYING_SLOT_POS,
+                                                       glsl_vec4_type()), result, 0xf);
+      s->info.outputs_written |= VARYING_BIT_POS;
+   }
 
    nir_metadata_preserve(b.impl, nir_metadata_control_flow);
 
-- 
GitLab


From def648893a1863fd82da2d43888822b952d9edf4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 07:49:47 -0500
Subject: [PATCH 14/33] mesa: switch fixed-func fragment program to IO
 intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/main/ff_fragment_shader.c  | 43 ++++++++++++-----------------
 src/mesa/state_tracker/st_program.c |  3 ++
 2 files changed, 20 insertions(+), 26 deletions(-)

diff --git a/src/mesa/main/ff_fragment_shader.c b/src/mesa/main/ff_fragment_shader.c
index e34a3ee5bcc2a..1f8a7daea187d 100644
--- a/src/mesa/main/ff_fragment_shader.c
+++ b/src/mesa/main/ff_fragment_shader.c
@@ -387,16 +387,18 @@ load_state_var(struct texenv_fragment_program *p,
 }
 
 static nir_def *
-load_input(struct texenv_fragment_program *p, gl_varying_slot slot,
-           const struct glsl_type *type)
+load_input(struct texenv_fragment_program *p, gl_varying_slot slot)
 {
-   nir_variable *var =
-      nir_get_variable_with_location(p->b->shader,
-                                     nir_var_shader_in,
-                                     slot,
-                                     type);
-   var->data.interpolation = INTERP_MODE_NONE;
-   return nir_load_var(p->b, var);
+   nir_def *baryc = nir_load_barycentric_pixel(p->b, 32);
+
+   if (slot != VARYING_SLOT_COL0 && slot != VARYING_SLOT_COL1) {
+      nir_intrinsic_set_interp_mode(nir_instr_as_intrinsic(baryc->parent_instr),
+                                    INTERP_MODE_SMOOTH);
+   }
+
+   return nir_load_interpolated_input(p->b, 4, 32, baryc,
+                                      nir_imm_int(p->b, 0),
+                                      .io_semantics.location = slot);
 }
 
 static nir_def *
@@ -411,7 +413,7 @@ static nir_def *
 get_gl_Color(struct texenv_fragment_program *p)
 {
    if (p->state->inputs_available & VARYING_BIT_COL0) {
-      return load_input(p, VARYING_SLOT_COL0, glsl_vec4_type());
+      return load_input(p, VARYING_SLOT_COL0);
    } else {
       return get_current_attrib(p, VERT_ATTRIB_COLOR0);
    }
@@ -752,9 +754,7 @@ load_texture(struct texenv_fragment_program *p, GLuint unit)
    if (!(p->state->inputs_available & (VARYING_BIT_TEX0 << unit))) {
       texcoord = get_current_attrib(p, VERT_ATTRIB_TEX0 + unit);
    } else {
-      texcoord = load_input(p,
-         VARYING_SLOT_TEX0 + unit,
-         glsl_vec4_type());
+      texcoord = load_input(p, VARYING_SLOT_TEX0 + unit);
    }
 
    if (!p->state->unit[unit].enabled) {
@@ -906,7 +906,7 @@ emit_instructions(struct texenv_fragment_program *p)
 
       nir_def *secondary;
       if (p->state->inputs_available & VARYING_BIT_COL1)
-         secondary = load_input(p, VARYING_SLOT_COL1, glsl_vec4_type());
+         secondary = load_input(p, VARYING_SLOT_COL1);
       else
          secondary = get_current_attrib(p, VERT_ATTRIB_COLOR1);
 
@@ -915,18 +915,8 @@ emit_instructions(struct texenv_fragment_program *p)
       cf = nir_fadd(p->b, spec_result, secondary);
    }
 
-   const char *name =
-      gl_frag_result_name(FRAG_RESULT_COLOR);
-   nir_variable *var =
-      nir_variable_create(p->b->shader, nir_var_shader_out,
-                          glsl_vec4_type(), name);
-
-   var->data.location = FRAG_RESULT_COLOR;
-   var->data.driver_location = p->b->shader->num_outputs++;
-
-   p->b->shader->info.outputs_written |= BITFIELD64_BIT(FRAG_RESULT_COLOR);
-
-   nir_store_var(p->b, var, cf, 0xf);
+   nir_store_output(p->b, cf, nir_imm_int(p->b, 0),
+                    .io_semantics.location = FRAG_RESULT_COLOR);
 }
 
 /**
@@ -954,6 +944,7 @@ create_new_program(struct state_key *key,
 
    s->info.separate_shader = true;
    s->info.subgroup_size = SUBGROUP_SIZE_UNIFORM;
+   s->info.io_lowered = true;
 
    p.b = &b;
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 7af6ea92cefa5..182cb925014c4 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -395,6 +395,9 @@ st_prog_to_nir_postprocess(struct st_context *st, nir_shader *nir,
    /* Optimise NIR */
    NIR_PASS(_, nir, nir_opt_constant_folding);
    gl_nir_opts(nir);
+
+   /* This must be done after optimizations to assign IO bases. */
+   nir_recompute_io_bases(nir, nir_var_shader_in | nir_var_shader_out);
    st_finalize_nir_before_variants(nir);
 
    if (st->allow_st_finalize_nir_twice) {
-- 
GitLab


From 3f94c3de188a7535f15b27bba939ecc62034b5ed Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 09:04:01 -0500
Subject: [PATCH 15/33] mesa: switch fixed-func vertex program to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/main/ffvertex_prog.c | 45 ++++++++++++++++-------------------
 1 file changed, 20 insertions(+), 25 deletions(-)

diff --git a/src/mesa/main/ffvertex_prog.c b/src/mesa/main/ffvertex_prog.c
index bcd3fb8dc3046..2bb0543b11991 100644
--- a/src/mesa/main/ffvertex_prog.c
+++ b/src/mesa/main/ffvertex_prog.c
@@ -348,22 +348,21 @@ load_state_mat4(struct tnl_program *p, nir_def *out[4],
 }
 
 static nir_def *
-load_input(struct tnl_program *p, gl_vert_attrib attr,
-           const struct glsl_type *type)
+load_input(struct tnl_program *p, gl_vert_attrib attr, unsigned num_components)
 {
    if (p->state->varying_vp_inputs & VERT_BIT(attr)) {
-      nir_variable *var = nir_get_variable_with_location(p->b->shader, nir_var_shader_in,
-                                                         attr, type);
-      p->b->shader->info.inputs_read |= (uint64_t)VERT_BIT(attr);
-      return nir_load_var(p->b, var);
-   } else
-      return load_state_var(p, STATE_CURRENT_ATTRIB, attr, 0, 0, type);
+      return nir_load_input(p->b, num_components, 32, nir_imm_int(p->b, 0),
+                            .io_semantics.location = attr);
+   } else {
+      return load_state_var(p, STATE_CURRENT_ATTRIB, attr, 0, 0,
+                            glsl_vector_type(GLSL_TYPE_FLOAT, num_components));
+   }
 }
 
 static nir_def *
 load_input_vec4(struct tnl_program *p, gl_vert_attrib attr)
 {
-   return load_input(p, attr, glsl_vec4_type());
+   return load_input(p, attr, 4);
 }
 
 static nir_variable *
@@ -377,12 +376,13 @@ register_output(struct tnl_program *p, gl_varying_slot slot,
 }
 
 static void
-store_output_vec4_masked(struct tnl_program *p, gl_varying_slot slot,
-                         nir_def *value, unsigned mask)
+store_output_vec4_masked(struct tnl_program *p, gl_varying_slot slot, nir_def *value,
+                         unsigned writemask)
 {
-   assert(mask <= 0xf);
-   nir_variable *var = register_output(p, slot, glsl_vec4_type());
-   nir_store_var(p->b, var, value, mask);
+   assert(writemask <= 0xf);
+   nir_store_output(p->b, value, nir_imm_int(p->b, 0),
+                    .write_mask = writemask,
+                    .io_semantics.location = slot);
 }
 
 static void
@@ -396,8 +396,7 @@ static void
 store_output_float(struct tnl_program *p, gl_varying_slot slot,
                    nir_def *value)
 {
-   nir_variable *var = register_output(p, slot, glsl_float_type());
-   nir_store_var(p->b, var, value, 0x1);
+   store_output_vec4_masked(p, slot, value, 0x1);
 }
 
 
@@ -499,13 +498,9 @@ get_transformed_normal(struct tnl_program *p)
        !p->state->need_eye_coords &&
        !p->state->normalize &&
        !(p->state->need_eye_coords == p->state->rescale_normals)) {
-      p->transformed_normal =
-         load_input(p, VERT_ATTRIB_NORMAL,
-                    glsl_vector_type(GLSL_TYPE_FLOAT, 3));
+      p->transformed_normal = load_input(p, VERT_ATTRIB_NORMAL, 3);
    } else if (!p->transformed_normal) {
-      nir_def *normal =
-         load_input(p, VERT_ATTRIB_NORMAL,
-                    glsl_vector_type(GLSL_TYPE_FLOAT, 3));
+      nir_def *normal = load_input(p, VERT_ATTRIB_NORMAL, 3);
 
       if (p->state->need_eye_coords) {
          nir_def *mvinv[4];
@@ -1062,7 +1057,7 @@ static void build_fog( struct tnl_program *p )
       fog = nir_fabs(p->b, get_eye_position_z(p));
       break;
    case FDM_FROM_ARRAY:
-      fog = load_input(p, VERT_ATTRIB_FOG, glsl_float_type());
+      fog = load_input(p, VERT_ATTRIB_FOG, 1);
       break;
    default:
       unreachable("Bad fog mode in build_fog()");
@@ -1271,8 +1266,7 @@ static void build_atten_pointsize( struct tnl_program *p )
  */
 static void build_array_pointsize( struct tnl_program *p )
 {
-   nir_def *val = load_input(p, VERT_ATTRIB_POINT_SIZE,
-                                 glsl_float_type());
+   nir_def *val = load_input(p, VERT_ATTRIB_POINT_SIZE, 1);
    store_output_float(p, VARYING_SLOT_PSIZ, val);
 }
 
@@ -1335,6 +1329,7 @@ create_new_program( const struct state_key *key,
    nir_shader *s = b.shader;
 
    s->info.separate_shader = true;
+   s->info.io_lowered = true;
 
    p.b = &b;
 
-- 
GitLab


From 87e3671aeaadb0ca5895eb435fb4685d7d2f9f96 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 09:44:33 -0500
Subject: [PATCH 16/33] mesa: switch ARB_vp/fp to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/program/prog_to_nir.c | 135 ++++++++++++---------------------
 1 file changed, 50 insertions(+), 85 deletions(-)

diff --git a/src/mesa/program/prog_to_nir.c b/src/mesa/program/prog_to_nir.c
index 7c4bd6357b3c9..d5d8393af68e1 100644
--- a/src/mesa/program/prog_to_nir.c
+++ b/src/mesa/program/prog_to_nir.c
@@ -53,8 +53,6 @@ struct ptn_compile {
    bool error;
 
    nir_variable *parameters;
-   nir_variable *input_vars[VARYING_SLOT_MAX];
-   nir_variable *output_vars[VARYING_SLOT_MAX];
    nir_variable *sampler_vars[32]; /* matches number of bits in TexSrcUnit */
    nir_def **output_regs;
    nir_def **temp_regs;
@@ -86,11 +84,47 @@ ptn_get_src(struct ptn_compile *c, const struct prog_src_register *prog_src)
        * attributes; ARB_fragment_program has no relative addressing at all.
        */
       assert(!prog_src->RelAddr);
-
       assert(prog_src->Index >= 0 && prog_src->Index < VARYING_SLOT_MAX);
 
-      nir_variable *var = c->input_vars[prog_src->Index];
-      src.src = nir_src_for_ssa(nir_load_var(b, var));
+      unsigned slot = prog_src->Index;
+      nir_def *input;
+
+      if (c->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
+         if (slot == VARYING_SLOT_POS && c->ctx->Const.GLSLFragCoordIsSysVal) {
+            nir_variable *pos =
+               nir_get_variable_with_location(b->shader, nir_var_system_value,
+                                              SYSTEM_VALUE_FRAG_COORD,
+                                              glsl_vec4_type());
+            src.src = nir_src_for_ssa(nir_load_var(b, pos));
+            break;
+         }
+
+         nir_def *baryc = nir_load_barycentric_pixel(b, 32);
+
+         if (slot != VARYING_SLOT_COL0 && slot != VARYING_SLOT_COL1) {
+            nir_intrinsic_set_interp_mode(nir_instr_as_intrinsic(baryc->parent_instr),
+                                          INTERP_MODE_SMOOTH);
+         }
+
+         input = nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
+                                             .io_semantics.location = slot);
+
+         /* fogcoord is defined as <f, 0.0, 0.0, 1.0>.  Make the actual
+          * input variable a float, and create a local containing the
+          * full vec4 value.
+          */
+         if (slot == VARYING_SLOT_FOGC) {
+            input = nir_vec4(b, nir_channel(b, input, 0),
+                             nir_imm_float(b, 0),
+                             nir_imm_float(b, 0),
+                             nir_imm_float(b, 1));
+         }
+      } else {
+         input = nir_load_input(b, 4, 32, nir_imm_int(b, 0),
+                                .io_semantics.location = slot);
+      }
+
+      src.src = nir_src_for_ssa(input);
       break;
    }
    case PROGRAM_STATE_VAR:
@@ -713,10 +747,10 @@ ptn_add_output_stores(struct ptn_compile *c)
 {
    nir_builder *b = &c->build;
 
-   nir_foreach_shader_out_variable(var, b->shader) {
-      nir_def *src = nir_load_reg(b, c->output_regs[var->data.location]);
+   u_foreach_bit64(slot, b->shader->info.outputs_written) {
+      nir_def *src = nir_load_reg(b, c->output_regs[slot]);
       if (c->prog->Target == GL_FRAGMENT_PROGRAM_ARB &&
-          var->data.location == FRAG_RESULT_DEPTH) {
+          slot == FRAG_RESULT_DEPTH) {
          /* result.depth has this strange convention of being the .z component of
           * a vec4 with undefined .xyw components.  We resolve it to a scalar, to
           * match GLSL's gl_FragDepth and the expectations of most backends.
@@ -724,13 +758,13 @@ ptn_add_output_stores(struct ptn_compile *c)
          src = nir_channel(b, src, 2);
       }
       if (c->prog->Target == GL_VERTEX_PROGRAM_ARB &&
-          (var->data.location == VARYING_SLOT_FOGC ||
-           var->data.location == VARYING_SLOT_PSIZ)) {
+          (slot == VARYING_SLOT_FOGC || slot == VARYING_SLOT_PSIZ)) {
          /* result.{fogcoord,psiz} is a single component value */
          src = nir_channel(b, src, 0);
       }
-      unsigned num_components = glsl_get_vector_elements(var->type);
-      nir_store_var(b, var, src, (1 << num_components) - 1);
+
+      nir_store_output(b, src, nir_imm_int(b, 0),
+                       .io_semantics.location = slot);
    }
 }
 
@@ -738,86 +772,17 @@ static void
 setup_registers_and_variables(struct ptn_compile *c)
 {
    nir_builder *b = &c->build;
-   struct nir_shader *shader = b->shader;
-
-   /* Create input variables. */
-   uint64_t inputs_read = c->prog->info.inputs_read;
-   while (inputs_read) {
-      const int i = u_bit_scan64(&inputs_read);
-
-      if (c->ctx->Const.GLSLFragCoordIsSysVal &&
-          shader->info.stage == MESA_SHADER_FRAGMENT &&
-          i == VARYING_SLOT_POS) {
-         c->input_vars[i] = nir_create_variable_with_location(shader, nir_var_system_value,
-                                                              SYSTEM_VALUE_FRAG_COORD, glsl_vec4_type());
-         continue;
-      }
-
-      nir_variable *var =
-          nir_create_variable_with_location(shader, nir_var_shader_in,
-                                            i, glsl_vec4_type());
-
-      if (c->prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
-         if (i == VARYING_SLOT_FOGC) {
-            /* fogcoord is defined as <f, 0.0, 0.0, 1.0>.  Make the actual
-             * input variable a float, and create a local containing the
-             * full vec4 value.
-             */
-            var->type = glsl_float_type();
-
-            nir_variable *fullvar =
-               nir_local_variable_create(b->impl, glsl_vec4_type(),
-                                         "fogcoord_tmp");
-
-            nir_store_var(b, fullvar,
-                          nir_vec4(b, nir_load_var(b, var),
-                                   nir_imm_float(b, 0.0),
-                                   nir_imm_float(b, 0.0),
-                                   nir_imm_float(b, 1.0)),
-                          WRITEMASK_XYZW);
-
-            /* We inserted the real input into the list so the driver has real
-             * inputs, but we set c->input_vars[i] to the temporary so we use
-             * the splatted value.
-             */
-            c->input_vars[i] = fullvar;
-            continue;
-         }
-      }
 
-      c->input_vars[i] = var;
-   }
-
-   /* Create output registers and variables. */
+   /* Create output registers. */
    int max_outputs = util_last_bit64(c->prog->info.outputs_written);
    c->output_regs = rzalloc_array(c, nir_def *, max_outputs);
 
-   uint64_t outputs_written = c->prog->info.outputs_written;
-   while (outputs_written) {
-      const int i = u_bit_scan64(&outputs_written);
-
+   u_foreach_bit64(i, c->prog->info.outputs_written) {
       /* Since we can't load from outputs in the IR, we make temporaries
        * for the outputs and emit stores to the real outputs at the end of
        * the shader.
        */
-      nir_def *reg = nir_decl_reg(b, 4, 32, 0);
-
-      const struct glsl_type *type;
-      if ((c->prog->Target == GL_FRAGMENT_PROGRAM_ARB && i == FRAG_RESULT_DEPTH) ||
-          (c->prog->Target == GL_VERTEX_PROGRAM_ARB && i == VARYING_SLOT_FOGC) ||
-          (c->prog->Target == GL_VERTEX_PROGRAM_ARB && i == VARYING_SLOT_PSIZ))
-         type = glsl_float_type();
-      else
-         type = glsl_vec4_type();
-
-      nir_variable *var =
-         nir_variable_create(shader, nir_var_shader_out, type,
-                             ralloc_asprintf(shader, "out_%d", i));
-      var->data.location = i;
-      var->data.index = 0;
-
-      c->output_regs[i] = reg;
-      c->output_vars[i] = var;
+      c->output_regs[i] = nir_decl_reg(b, 4, 32, 0);
    }
 
    /* Create temporary registers. */
@@ -887,7 +852,7 @@ prog_to_nir(const struct gl_context *ctx, const struct gl_program *prog)
    s->info.clip_distance_array_size = 0;
    s->info.cull_distance_array_size = 0;
    s->info.separate_shader = true;
-   s->info.io_lowered = false;
+   s->info.io_lowered = true;
    s->info.internal = false;
 
    /* ARB_vp: */
-- 
GitLab


From f8ce2c29039927c1912e7f3e18fadc353f2dbf97 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 12:06:14 -0500
Subject: [PATCH 17/33] st/mesa: switch ATI_fs to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_atifs_to_nir.c | 25 +++++++++++-------------
 1 file changed, 11 insertions(+), 14 deletions(-)

diff --git a/src/mesa/state_tracker/st_atifs_to_nir.c b/src/mesa/state_tracker/st_atifs_to_nir.c
index 7fd2a1402b314..88ffa6d4fc3fb 100644
--- a/src/mesa/state_tracker/st_atifs_to_nir.c
+++ b/src/mesa/state_tracker/st_atifs_to_nir.c
@@ -41,12 +41,9 @@ struct st_translate {
 
    nir_def *temps[MAX_PROGRAM_TEMPS];
 
-   nir_variable *fragcolor;
    nir_variable *constants;
    nir_variable *samplers[MAX_TEXTURE_UNITS];
 
-   nir_def *inputs[VARYING_SLOT_MAX];
-
    unsigned current_pass;
 
    bool regs_written[MAX_NUM_PASSES_ATI][MAX_NUM_FRAGMENT_REGISTERS_ATI];
@@ -113,15 +110,15 @@ apply_swizzle(struct st_translate *t,
 static nir_def *
 load_input(struct st_translate *t, gl_varying_slot slot)
 {
-   if (!t->inputs[slot]) {
-      nir_variable *var = nir_create_variable_with_location(t->b->shader, nir_var_shader_in, slot,
-                                                            glsl_vec4_type());
-      var->data.interpolation = INTERP_MODE_NONE;
+   nir_def *baryc = nir_load_barycentric_pixel(t->b, 32);
 
-      t->inputs[slot] = nir_load_var(t->b, var);
+   if (slot != VARYING_SLOT_COL0 && slot != VARYING_SLOT_COL1) {
+      nir_intrinsic_set_interp_mode(nir_instr_as_intrinsic(baryc->parent_instr),
+                                    INTERP_MODE_SMOOTH);
    }
 
-   return t->inputs[slot];
+   return nir_load_interpolated_input(t->b, 4, 32, baryc, nir_imm_int(t->b, 0),
+                                      .io_semantics.location = slot);
 }
 
 static nir_def *
@@ -447,9 +444,7 @@ st_translate_atifs_program(struct ati_fragment_shader *atifs,
    nir_shader *s = t->b->shader;
    s->info.name = ralloc_asprintf(s, "ATIFS%d", program->Id);
    s->info.internal = false;
-
-   t->fragcolor = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                    FRAG_RESULT_COLOR, glsl_vec4_type());
+   s->info.io_lowered = true;
 
    st_atifs_setup_uniforms(t, program);
 
@@ -466,8 +461,10 @@ st_translate_atifs_program(struct ati_fragment_shader *atifs,
       }
    }
 
-   if (t->regs_written[atifs->NumPasses-1][0])
-      nir_store_var(t->b, t->fragcolor, t->temps[0], 0xf);
+   if (t->regs_written[atifs->NumPasses-1][0]) {
+      nir_store_output(t->b, t->temps[0], nir_imm_int(t->b, 0),
+                       .io_semantics.location = FRAG_RESULT_COLOR);
+   }
 
    return b.shader;
 }
-- 
GitLab


From 6aa56d652b196d3bef556801085db70813ecaa30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 14:09:17 -0500
Subject: [PATCH 18/33] st/mesa: unlower IO for internal shaders if needed

This will be required because all internal shaders will be converted
to IO intrinsics.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_nir_builtins.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index 1a44ae20965ec..a1c91dcc01c61 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -73,6 +73,12 @@ st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
    if (!screen->get_param(screen, PIPE_CAP_NIR_IMAGES_AS_DEREF))
       NIR_PASS(_, nir, gl_nir_lower_images, false);
 
+   if (nir->info.io_lowered &&
+       !(nir->options->io_options & nir_io_has_intrinsics)) {
+      NIR_PASS(_, nir, st_nir_unlower_io_to_vars);
+      gl_nir_opts(nir);
+   }
+
    if (screen->finalize_nir) {
       char *msg = screen->finalize_nir(screen, nir);
       free(msg);
-- 
GitLab


From a51d53ee9f8543feeea38e22e6a80812a28133cd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 12:25:49 -0500
Subject: [PATCH 19/33] st/mesa: switch Z/S DrawPixels shaders to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_cb_drawpixels.c | 79 +++++++++--------------
 src/mesa/state_tracker/st_nir_builtins.c  |  1 +
 2 files changed, 33 insertions(+), 47 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index fd44b5fcae9b5..609cdfd537824 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -105,12 +105,17 @@
 #define USE_DRAWPIXELS_CACHE 1
 
 static nir_def *
-sample_via_nir(nir_builder *b, nir_variable *texcoord,
-               const char *name, int sampler, enum glsl_base_type base_type,
+sample_via_nir(nir_builder *b,  const char *name, int sampler,
                nir_alu_type alu_type)
 {
+   nir_def *baryc = nir_load_barycentric_pixel(b, 32,
+                                               .interp_mode = INTERP_MODE_SMOOTH);
+   nir_def *texcoord =
+      nir_load_interpolated_input(b, 2, 32, baryc, nir_imm_int(b, 0),
+                                  .io_semantics.location = VARYING_SLOT_TEX0);
    const struct glsl_type *sampler2D =
-      glsl_sampler_type(GLSL_SAMPLER_DIM_2D, false, false, base_type);
+      glsl_sampler_type(GLSL_SAMPLER_DIM_2D, false, false,
+                        nir_get_glsl_base_type_for_nir_type(alu_type));
 
    nir_variable *var =
       nir_variable_create(b->shader, nir_var_uniform, sampler2D, name);
@@ -128,10 +133,7 @@ sample_via_nir(nir_builder *b, nir_variable *texcoord,
                                      &deref->def);
    tex->src[1] = nir_tex_src_for_ssa(nir_tex_src_sampler_deref,
                                      &deref->def);
-   tex->src[2] =
-      nir_tex_src_for_ssa(nir_tex_src_coord,
-                          nir_trim_vector(b, nir_load_var(b, texcoord),
-                                             tex->coord_components));
+   tex->src[2] = nir_tex_src_for_ssa(nir_tex_src_coord, texcoord);
 
    nir_def_init(&tex->instr, &tex->def, 4, 32);
    nir_builder_instr_insert(b, &tex->instr);
@@ -150,34 +152,27 @@ make_drawpix_z_stencil_program_nir(struct st_context *st,
                                                   "drawpixels %s%s",
                                                   write_depth ? "Z" : "",
                                                   write_stencil ? "S" : "");
-
-   nir_variable *texcoord =
-      nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                        VARYING_SLOT_TEX0, glsl_vec_type(2));
+   b.shader->info.io_lowered = true;
 
    if (write_depth) {
-      nir_variable *out =
-         nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                           FRAG_RESULT_DEPTH, glsl_float_type());
-      nir_def *depth = sample_via_nir(&b, texcoord, "depth", 0,
-                                          GLSL_TYPE_FLOAT, nir_type_float32);
-      nir_store_var(&b, out, depth, 0x1);
+      nir_def *depth = sample_via_nir(&b, "depth", 0, nir_type_float32);
+      nir_store_output(&b, nir_channel(&b, depth, 0), nir_imm_int(&b, 0),
+                       .io_semantics.location = FRAG_RESULT_DEPTH);
 
       /* Also copy color */
-      nir_copy_var(&b,
-                   nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                     FRAG_RESULT_COLOR, glsl_vec4_type()),
-                   nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                                     VARYING_SLOT_COL0, glsl_vec4_type()));
+      nir_def *baryc = nir_load_barycentric_pixel(&b, 32);
+      nir_def *color = nir_load_interpolated_input(&b, 4, 32, baryc,
+                                                   nir_imm_int(&b, 0),
+                                                   .io_semantics.location = VARYING_SLOT_COL0);
+      nir_store_output(&b, color, nir_imm_int(&b, 0),
+                       .io_semantics.location = FRAG_RESULT_COLOR);
    }
 
    if (write_stencil) {
-      nir_variable *out =
-         nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                           FRAG_RESULT_STENCIL, glsl_uint_type());
-      nir_def *stencil = sample_via_nir(&b, texcoord, "stencil", 1,
-                                            GLSL_TYPE_UINT, nir_type_uint32);
-      nir_store_var(&b, out, stencil, 0x1);
+      nir_def *stencil = sample_via_nir(&b, "stencil", 1, nir_type_uint32);
+      nir_store_output(&b, nir_channel(&b, stencil, 0), nir_imm_int(&b, 0),
+                       .src_type = nir_type_int32,
+                       .io_semantics.location = FRAG_RESULT_STENCIL);
    }
 
    return st_nir_finish_builtin_shader(st, b.shader);
@@ -192,21 +187,11 @@ make_drawpix_zs_to_color_program_nir(struct st_context *st,
 
    nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT, options,
                                                   "copypixels ZStoC");
-
-   nir_variable *texcoord =
-      nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                        VARYING_SLOT_TEX0, glsl_vec_type(2));
+   b.shader->info.io_lowered = true;
 
    /* Sample depth and stencil */
-   nir_def *depth = sample_via_nir(&b, texcoord, "depth", 0,
-                                       GLSL_TYPE_FLOAT, nir_type_float32);
-   nir_def *stencil = sample_via_nir(&b, texcoord, "stencil", 1,
-                                         GLSL_TYPE_UINT, nir_type_uint32);
-
-   /* Create the variable to store the output color */
-   nir_variable *color_out =
-      nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                        FRAG_RESULT_COLOR, glsl_vec_type(4));
+   nir_def *depth = sample_via_nir(&b, "depth", 0, nir_type_float32);
+   nir_def *stencil = sample_via_nir(&b, "stencil", 1, nir_type_uint32);
 
    nir_def *shifted_depth = nir_fmul(&b,nir_f2f64(&b, depth), nir_imm_double(&b,0xffffff));
    nir_def *int_depth = nir_f2u32(&b,shifted_depth);
@@ -225,15 +210,15 @@ make_drawpix_zs_to_color_program_nir(struct st_context *st,
 
    nir_def *unpacked_ds = nir_vec4(&b, ds_comp[0], ds_comp[1], ds_comp[2], ds_comp[3]);
 
-   if (rgba) {
-      nir_store_var(&b, color_out, unpacked_ds, 0xf);
-   }
-   else {
+   if (!rgba) {
+      /* ZS -> BGRA blit */
       unsigned zyxw[4] = { 2, 1, 0, 3 };
-      nir_def *swizzled_ds= nir_swizzle(&b, unpacked_ds, zyxw, 4);
-      nir_store_var(&b, color_out, swizzled_ds, 0xf);
+      unpacked_ds = nir_swizzle(&b, unpacked_ds, zyxw, 4);
    }
 
+   nir_store_output(&b, unpacked_ds, nir_imm_int(&b, 0),
+                    .io_semantics.location = FRAG_RESULT_COLOR);
+
    return st_nir_finish_builtin_shader(st, b.shader);
 }
 
diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index a1c91dcc01c61..7b08cbe4016ad 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -64,6 +64,7 @@ st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
    }
 
    nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
+   nir_recompute_io_bases(nir, nir_var_shader_in | nir_var_shader_out);
 
    st_nir_assign_vs_in_locations(nir);
    st_nir_assign_varying_locations(st, nir);
-- 
GitLab


From 1f5cf10af8d6334eb7c3906c52916356d965d22d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 12:37:37 -0500
Subject: [PATCH 20/33] st/mesa: switch GL_SELECT shader to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_draw_hw_select.c | 19 +++++++------------
 1 file changed, 7 insertions(+), 12 deletions(-)

diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index 7b089483a2912..b64bb930764df 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -89,14 +89,11 @@ get_input_vertices(nir_builder *b, nir_def **v)
 {
    const int num_in_vert = b->shader->info.gs.vertices_in;
 
-   nir_variable *in_pos = nir_variable_create(
-      b->shader, nir_var_shader_in, glsl_array_type(glsl_vec4_type(), num_in_vert, 0),
-      "gl_Position");
-   in_pos->data.location = VARYING_SLOT_POS;
-
    nir_def *is_nan_or_inf = NULL;
    for (int i = 0; i < num_in_vert; i++) {
-      v[i] = nir_load_array_var_imm(b, in_pos, i);
+      v[i] = nir_load_per_vertex_input(b, 4, 32, nir_imm_int(b, i),
+                                       nir_imm_int(b, 0),
+                                       .io_semantics.location = VARYING_SLOT_POS);
       nir_def *r = has_nan_or_inf(b, v[i]);
       is_nan_or_inf = i ? nir_ior(b, is_nan_or_inf, r) : r;
    }
@@ -394,12 +391,9 @@ update_result_buffer(nir_builder *b, nir_def *dmin, nir_def *dmax,
 {
    nir_def *offset;
    if (offset_from_attribute) {
-      nir_variable *in_offset = nir_variable_create(
-         b->shader, nir_var_shader_in,
-         glsl_array_type(glsl_uint_type(), b->shader->info.gs.vertices_in, 0),
-         "result_offset");
-      in_offset->data.location = VARYING_SLOT_VAR0;
-      offset = nir_load_array_var_imm(b, in_offset, 0);
+      offset = nir_load_per_vertex_input(b, 4, 32, nir_imm_int(b, 0),
+                                         nir_imm_int(b, 0),
+                                         .io_semantics.location = VARYING_SLOT_VAR0);
    } else {
       nir_variable *uni_offset = nir_variable_create(
          b->shader, nir_var_uniform, glsl_uint_type(), "result_offset");
@@ -620,6 +614,7 @@ hw_select_create_gs(struct st_context *st, union state_key state)
    nir->info.gs.vertices_out = 1;
    nir->info.gs.invocations = 1;
    nir->info.gs.active_stream_mask = 1;
+   nir->info.io_lowered = true;
 
    if (state.result_offset_from_attribute)
       nir->info.inputs_read |= VARYING_BIT_VAR(0);
-- 
GitLab


From 6f45dfd03354fda738f41656e19c28efc1951508 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 12:47:48 -0500
Subject: [PATCH 21/33] st/mesa: switch st_nir_make_passthrough_shader to IO
 intrinsics

also simplify it to only make VS because it's only used for VS.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_cb_clear.c      |  5 +--
 src/mesa/state_tracker/st_cb_drawpixels.c |  4 +-
 src/mesa/state_tracker/st_cb_drawtex.c    |  6 +--
 src/mesa/state_tracker/st_nir.h           | 14 +++----
 src/mesa/state_tracker/st_nir_builtins.c  | 49 +++++++++++------------
 5 files changed, 34 insertions(+), 44 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_clear.c b/src/mesa/state_tracker/st_cb_clear.c
index 25339aeb63eec..edb0c1d344f0c 100644
--- a/src/mesa/state_tracker/st_cb_clear.c
+++ b/src/mesa/state_tracker/st_cb_clear.c
@@ -135,9 +135,8 @@ make_nir_clear_vertex_shader(struct st_context *st, bool layered)
       VARYING_SLOT_LAYER
    };
 
-   return st_nir_make_passthrough_shader(st, shader_name, MESA_SHADER_VERTEX,
-                                         layered ? 2 : 1, inputs, outputs,
-                                         NULL, (1 << 1));
+   return st_nir_make_passthrough_vs(st, shader_name, layered ? 2 : 1, inputs,
+                                     outputs, (1 << 1));
 }
 
 
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 609cdfd537824..4ce64badfab95 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -302,9 +302,7 @@ st_make_passthrough_vertex_shader(struct st_context *st)
       { VARYING_SLOT_POS,  VARYING_SLOT_COL0,    VARYING_SLOT_TEX0 };
 
    st->passthrough_vs =
-      st_nir_make_passthrough_shader(st, "drawpixels VS",
-                                     MESA_SHADER_VERTEX, 3,
-                                     inputs, outputs, NULL, 0);
+      st_nir_make_passthrough_vs(st, "drawpixels VS", 3, inputs, outputs, 0);
 }
 
 
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index cb5ba13a5c283..5313d3ecc1ad1 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -109,10 +109,8 @@ lookup_shader(struct st_context *st,
    }
 
    CachedShaders[i].handle =
-      st_nir_make_passthrough_shader(st, "st/drawtex VS",
-                                       MESA_SHADER_VERTEX,
-                                       num_attribs, inputs,
-                                       slots, NULL, 0);
+      st_nir_make_passthrough_vs(st, "st/drawtex VS", num_attribs, inputs,
+                                 slots, 0);
 
    NumCachedShaders++;
 
diff --git a/src/mesa/state_tracker/st_nir.h b/src/mesa/state_tracker/st_nir.h
index 70557c5a033a0..f87b9d9e62954 100644
--- a/src/mesa/state_tracker/st_nir.h
+++ b/src/mesa/state_tracker/st_nir.h
@@ -64,14 +64,12 @@ st_nir_finish_builtin_shader(struct st_context *st,
                              struct nir_shader *nir);
 
 void *
-st_nir_make_passthrough_shader(struct st_context *st,
-                               const char *shader_name,
-                               gl_shader_stage stage,
-                               unsigned num_vars,
-                               const unsigned *input_locations,
-                               const gl_varying_slot *output_locations,
-                               unsigned *interpolation_modes,
-                               unsigned sysval_mask);
+st_nir_make_passthrough_vs(struct st_context *st,
+                           const char *shader_name,
+                           unsigned num_vars,
+                           const unsigned *input_locations,
+                           const gl_varying_slot *output_locations,
+                           unsigned sysval_mask);
 
 void *
 st_nir_make_clearcolor_shader(struct st_context *st);
diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index 7b08cbe4016ad..191ebdbe3900b 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -103,44 +103,41 @@ st_nir_finish_builtin_shader(struct st_context *st,
 }
 
 /**
- * Make a simple shader that copies inputs to corresponding outputs.
+ * Make a simple vertex shader that copies inputs to corresponding outputs.
  */
 void *
-st_nir_make_passthrough_shader(struct st_context *st,
-                               const char *shader_name,
-                               gl_shader_stage stage,
-                               unsigned num_vars,
-                               const unsigned *input_locations,
-                               const gl_varying_slot *output_locations,
-                               unsigned *interpolation_modes,
-                               unsigned sysval_mask)
+st_nir_make_passthrough_vs(struct st_context *st,
+                           const char *shader_name,
+                           unsigned num_vars,
+                           const unsigned *input_locations,
+                           const gl_varying_slot *output_locations,
+                           unsigned sysval_mask)
 {
-   const struct glsl_type *vec4 = glsl_vec4_type();
    const nir_shader_compiler_options *options =
-      st_get_nir_compiler_options(st, stage);
+      st_get_nir_compiler_options(st, MESA_SHADER_VERTEX);
 
-   nir_builder b = nir_builder_init_simple_shader(stage, options,
+   nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_VERTEX, options,
                                                   "%s", shader_name);
+   b.shader->info.io_lowered = true;
 
    for (unsigned i = 0; i < num_vars; i++) {
-      nir_variable *in;
+      nir_def *in;
+
       if (sysval_mask & (1 << i)) {
-         in = nir_create_variable_with_location(b.shader, nir_var_system_value,
-                                                input_locations[i],
-                                  glsl_int_type());
+         nir_variable *var =
+            nir_create_variable_with_location(b.shader, nir_var_system_value,
+                                              input_locations[i],
+                                              glsl_int_type());
+         in = nir_load_var(&b, var);
       } else {
-         in = nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                                input_locations[i], vec4);
+         in = nir_load_input(&b, 4, 32, nir_imm_int(&b, 0),
+                             .io_semantics.location = input_locations[i]);
       }
-      if (interpolation_modes)
-         in->data.interpolation = interpolation_modes[i];
-
-      nir_variable *out =
-         nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                           output_locations[i], in->type);
-      out->data.interpolation = in->data.interpolation;
 
-      nir_copy_var(&b, out, in);
+      nir_store_output(&b, in, nir_imm_int(&b, 0),
+                       .src_type = output_locations[i] == VARYING_SLOT_LAYER ?
+                                      nir_type_int32 : nir_type_float32,
+                       .io_semantics.location = output_locations[i]);
    }
 
    return st_nir_finish_builtin_shader(st, b.shader);
-- 
GitLab


From dbf758c2c3f2574d74d05cd0bd7692db38153d0f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 13:05:24 -0500
Subject: [PATCH 22/33] st/mesa: switch st_pbo_create_vs and st_pbo_create_gs
 to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_pbo.c | 71 +++++++++++++++------------------
 1 file changed, 33 insertions(+), 38 deletions(-)

diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index f2cddbeac874c..ece71d62a369f 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -283,36 +283,37 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
 void *
 st_pbo_create_vs(struct st_context *st)
 {
-   const struct glsl_type *vec4 = glsl_vec4_type();
    const nir_shader_compiler_options *options =
       st_get_nir_compiler_options(st, MESA_SHADER_VERTEX);
 
    nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_VERTEX, options,
                                                   "st/pbo VS");
+   b.shader->info.io_lowered = true;
 
-   nir_variable *in_pos = nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                                             VERT_ATTRIB_POS, vec4);
-
-   nir_variable *out_pos = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                             VARYING_SLOT_POS, vec4);
-
-   if (!st->pbo.use_gs)
-      nir_copy_var(&b, out_pos, in_pos);
+   if (!st->pbo.use_gs) {
+      nir_def *pos = nir_load_input(&b, 4, 32, nir_imm_int(&b, 0),
+                                    .io_semantics.location = VERT_ATTRIB_POS);
+      nir_store_output(&b, pos, nir_imm_int(&b, 0),
+                       .io_semantics.location = VARYING_SLOT_POS);
+   }
 
    if (st->pbo.layers) {
-      nir_variable *instance_id = nir_create_variable_with_location(b.shader, nir_var_system_value,
-                                                                    SYSTEM_VALUE_INSTANCE_ID, glsl_int_type());
+      nir_variable *instance_id_var =
+         nir_create_variable_with_location(b.shader, nir_var_system_value,
+                                           SYSTEM_VALUE_INSTANCE_ID, glsl_int_type());
+      nir_def *instance_id = nir_load_var(&b, instance_id_var);
 
       if (st->pbo.use_gs) {
-         nir_store_var(&b, out_pos,
-                       nir_vector_insert_imm(&b, nir_load_var(&b, in_pos),
-                                             nir_i2f32(&b, nir_load_var(&b, instance_id)), 2),
-                       0xf);
+         nir_def *pos = nir_load_input(&b, 4, 32, nir_imm_int(&b, 0),
+                                       .io_semantics.location = VERT_ATTRIB_POS);
+         nir_store_output(&b, nir_vector_insert_imm(&b, pos,
+                                                    nir_i2f32(&b, instance_id), 2),
+                          nir_imm_int(&b, 0),
+                          .io_semantics.location = VARYING_SLOT_POS);
       } else {
-         nir_variable *out_layer = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                                     VARYING_SLOT_LAYER, glsl_int_type());
-         out_layer->data.interpolation = INTERP_MODE_NONE;
-         nir_copy_var(&b, out_layer, instance_id);
+         nir_store_output(&b, instance_id, nir_imm_int(&b, 0),
+                          .src_type = nir_type_int32,
+                          .io_semantics.location = VARYING_SLOT_LAYER);
       }
    }
 
@@ -334,29 +335,23 @@ st_pbo_create_gs(struct st_context *st)
    b.shader->info.gs.vertices_out = 3;
    b.shader->info.gs.invocations = 1;
    b.shader->info.gs.active_stream_mask = 1;
-
-   const struct glsl_type *in_type = glsl_array_type(glsl_vec4_type(), 3, 0);
-   nir_variable *in_pos = nir_variable_create(b.shader, nir_var_shader_in, in_type, "in_pos");
-   in_pos->data.location = VARYING_SLOT_POS;
-   b.shader->info.inputs_read |= VARYING_BIT_POS;
-
-   nir_variable *out_pos = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                             VARYING_SLOT_POS, glsl_vec4_type());
-
-   b.shader->info.outputs_written |= VARYING_BIT_POS;
-
-   nir_variable *out_layer = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                               VARYING_SLOT_LAYER, glsl_int_type());
-   out_layer->data.interpolation = INTERP_MODE_NONE;
-   b.shader->info.outputs_written |= VARYING_BIT_LAYER;
+   b.shader->info.io_lowered = true;
 
    for (int i = 0; i < 3; ++i) {
-      nir_def *pos = nir_load_array_var_imm(&b, in_pos, i);
+      nir_def *pos =
+         nir_load_per_vertex_input(&b, 4, 32, nir_imm_int(&b, i),
+                                   nir_imm_int(&b, 0),
+                                   .io_semantics.location = VARYING_SLOT_POS);
 
-      nir_store_var(&b, out_pos, nir_vector_insert_imm(&b, pos, nir_imm_float(&b, 0.0), 2), 0xf);
-      /* out_layer.x = f2i(in_pos[i].z) */
-      nir_store_var(&b, out_layer, nir_f2i32(&b, nir_channel(&b, pos, 2)), 0x1);
+      nir_store_output(&b, nir_vector_insert_imm(&b, pos, nir_imm_float(&b, 0.0), 2),
+                       nir_imm_int(&b, 0),
+                       .io_semantics.location = VARYING_SLOT_POS);
 
+      /* out_layer.x = f2i(in_pos[i].z) */
+      nir_store_output(&b, nir_f2i32(&b, nir_channel(&b, pos, 2)),
+                       nir_imm_int(&b, 0),
+                       .src_type = nir_type_int32,
+                       .io_semantics.location = VARYING_SLOT_LAYER);
       nir_emit_vertex(&b);
    }
 
-- 
GitLab


From 1ef9c110b1b47d5baf7653523605747cc8d0bc38 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 13:21:48 -0500
Subject: [PATCH 23/33] st/mesa: switch PBO create_fs to IO intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_pbo.c | 41 +++++++++++++++------------------
 1 file changed, 19 insertions(+), 22 deletions(-)

diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index ece71d62a369f..04fd6bbca95e3 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -394,16 +394,14 @@ create_fs(struct st_context *st, bool download,
           enum pipe_format format,
           bool need_layer)
 {
-   struct pipe_screen *screen = st->screen;
    const nir_shader_compiler_options *options =
       st_get_nir_compiler_options(st, MESA_SHADER_FRAGMENT);
-   bool pos_is_sysval =
-      screen->get_param(screen, PIPE_CAP_FS_POSITION_IS_SYSVAL);
 
    nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_FRAGMENT, options,
                                                   download ?
                                                   "st/pbo download FS" :
                                                   "st/pbo upload FS");
+   b.shader->info.io_lowered = true;
 
    nir_def *zero = nir_imm_int(&b, 0);
 
@@ -413,14 +411,18 @@ create_fs(struct st_context *st, bool download,
    b.shader->num_uniforms += 4;
    nir_def *param = nir_load_var(&b, param_var);
 
-   nir_variable *fragcoord;
-   if (pos_is_sysval)
-      fragcoord = nir_create_variable_with_location(b.shader, nir_var_system_value,
-                                                    SYSTEM_VALUE_FRAG_COORD, glsl_vec4_type());
-   else
-      fragcoord = nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                                    VARYING_SLOT_POS, glsl_vec4_type());
-   nir_def *coord = nir_load_var(&b, fragcoord);
+   nir_def *coord;
+   if (st->ctx->Const.GLSLFragCoordIsSysVal) {
+      nir_variable *fragcoord =
+         nir_create_variable_with_location(b.shader, nir_var_system_value,
+                                           SYSTEM_VALUE_FRAG_COORD, glsl_vec4_type());
+      coord = nir_load_var(&b, fragcoord);
+   } else {
+      nir_def *baryc = nir_load_barycentric_pixel(&b, 32, .interp_mode = INTERP_MODE_SMOOTH);
+      coord = nir_load_interpolated_input(&b, 4, 32, baryc,
+                                          nir_imm_int(&b, 0),
+                                          .io_semantics.location = VARYING_SLOT_POS);
+   }
 
    /* When st->pbo.layers == false, it is guaranteed we only have a single
     * layer. But we still need the "layer" variable to add the "array"
@@ -435,12 +437,10 @@ create_fs(struct st_context *st, bool download,
                     target == PIPE_TEXTURE_CUBE_ARRAY) {
       if (need_layer) {
          assert(st->pbo.layers);
-         nir_variable *var = nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                                               VARYING_SLOT_LAYER, glsl_int_type());
-         var->data.interpolation = INTERP_MODE_FLAT;
-         layer = nir_load_var(&b, var);
-      }
-      else {
+         layer = nir_load_input(&b, 1, 32, nir_imm_int(&b, 0),
+                                .dest_type = nir_type_int32,
+                                .io_semantics.location = VARYING_SLOT_LAYER);
+      } else {
          layer = zero;
       }
    }
@@ -562,11 +562,8 @@ create_fs(struct st_context *st, bool download,
                             .src_type = nir_types[conversion],
                             .image_dim = GLSL_SAMPLER_DIM_BUF);
    } else {
-      nir_variable *color =
-         nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                           FRAG_RESULT_COLOR, glsl_vec4_type());
-
-      nir_store_var(&b, color, result, TGSI_WRITEMASK_XYZW);
+      nir_store_output(&b, result, nir_imm_int(&b, 0),
+                       .io_semantics.location = FRAG_RESULT_COLOR);
    }
 
    return st_nir_finish_builtin_shader(st, b.shader);
-- 
GitLab


From afd5a42950eefd1ec8f70c092194e5ba6cd329bf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 13:50:33 -0500
Subject: [PATCH 24/33] st/mesa: switch st_nir_make_clearcolor_shader to IO
 intrinsics

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_nir_builtins.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index 191ebdbe3900b..a3d88c2330d99 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -158,17 +158,15 @@ st_nir_make_clearcolor_shader(struct st_context *st)
    b.shader->info.num_ubos = 1;
    b.shader->num_outputs = 1;
    b.shader->num_uniforms = 1;
+   b.shader->info.io_lowered = true;
 
    /* Read clear color from constant buffer */
    nir_def *clear_color = nir_load_uniform(&b, 4, 32, nir_imm_int(&b,0),
                                                .range = 16,
                                                .dest_type = nir_type_float32);
 
-   nir_variable *color_out = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                                               FRAG_RESULT_COLOR, glsl_vec4_type());
-
-   /* Write out the color */
-   nir_store_var(&b, color_out, clear_color, 0xf);
+   nir_store_output(&b, clear_color, nir_imm_int(&b, 0),
+                    .io_semantics.location = FRAG_RESULT_COLOR);
 
    return st_nir_finish_builtin_shader(st, b.shader);
 }
-- 
GitLab


From 1b17f4f17aae7e5b9aa7a764097f70665e3c31b8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 13:56:29 -0500
Subject: [PATCH 25/33] st/mesa: assert that all incoming shaders use lowered
 IO

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_nir_builtins.c | 2 ++
 src/mesa/state_tracker/st_program.c      | 5 +++++
 2 files changed, 7 insertions(+)

diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index a3d88c2330d99..165de9ebd6c7e 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -74,6 +74,8 @@ st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
    if (!screen->get_param(screen, PIPE_CAP_NIR_IMAGES_AS_DEREF))
       NIR_PASS(_, nir, gl_nir_lower_images, false);
 
+   assert(nir->info.stage == MESA_SHADER_COMPUTE || nir->info.io_lowered);
+
    if (nir->info.io_lowered &&
        !(nir->options->io_options & nir_io_has_intrinsics)) {
       NIR_PASS(_, nir, st_nir_unlower_io_to_vars);
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 182cb925014c4..9f317da1db05c 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -853,6 +853,9 @@ st_create_common_variant(struct st_context *st,
                       key->is_draw_shader);
    }
 
+   assert(state.ir.nir->info.stage == MESA_SHADER_COMPUTE ||
+          state.ir.nir->info.io_lowered);
+
    /* This should be after all passes that touch IO. */
    if (state.ir.nir->info.io_lowered &&
        (!(state.ir.nir->options->io_options & nir_io_has_intrinsics) ||
@@ -1239,6 +1242,8 @@ st_create_fp_variant(struct st_context *st,
       finalize = true;
    }
 
+   assert(state.ir.nir->info.io_lowered);
+
    /* This should be after all passes that touch IO. */
    if (state.ir.nir->info.io_lowered &&
        !(state.ir.nir->options->io_options & nir_io_has_intrinsics)) {
-- 
GitLab


From 11d068053201a22aeeec6cb7eb80887177fbf3c2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 16:29:19 -0500
Subject: [PATCH 26/33] st/mesa: don't use nir_copy_var

so that we don't have to call nir_lower_var_copies.

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_draw_hw_select.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index b64bb930764df..9a4fc9ddcd1a3 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -338,7 +338,7 @@ clip_with_plane(nir_builder *b, nir_variable *vert, nir_variable *num_vert,
    }
    end_for_loop(vert_loop);
 
-   nir_copy_var(b, num_vert, vert_index);
+   nir_store_var(b, num_vert, nir_load_var(b, vert_index), 0x1);
 }
 
 static nir_def *
-- 
GitLab


From 7eea6126c1fb2ec6f16893ddfe7789a3dbdfdb84 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Nov 2024 01:21:04 -0400
Subject: [PATCH 27/33] st/mesa: remove dead/no-op code due to IO being always
 lowered

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_glsl_to_nir.cpp | 227 +---------------------
 src/mesa/state_tracker/st_nir.h           |   4 -
 src/mesa/state_tracker/st_nir_builtins.c  |  14 --
 src/mesa/state_tracker/st_program.c       |  42 +---
 4 files changed, 11 insertions(+), 276 deletions(-)

diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index f2542f6cf4334..cc3acf011c635 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -62,71 +62,6 @@ type_size(const struct glsl_type *type)
    return glsl_count_attribute_slots(type, false);
 }
 
-/* Depending on PIPE_CAP_TGSI_TEXCOORD (st->needs_texcoord_semantic) we
- * may need to fix up varying slots so the glsl->nir path is aligned
- * with the anything->tgsi->nir path.
- */
-static void
-st_nir_fixup_varying_slots(struct st_context *st, nir_shader *shader,
-                           nir_variable_mode mode)
-{
-   if (st->needs_texcoord_semantic)
-      return;
-
-   /* This is called from finalize, but we don't want to do this adjustment twice. */
-   assert(!st->allow_st_finalize_nir_twice);
-
-   nir_foreach_variable_with_modes(var, shader, mode) {
-      if (var->data.location >= VARYING_SLOT_VAR0 && var->data.location < VARYING_SLOT_PATCH0) {
-         var->data.location += 9;
-      } else if (var->data.location == VARYING_SLOT_PNTC) {
-         var->data.location = VARYING_SLOT_VAR8;
-      } else if ((var->data.location >= VARYING_SLOT_TEX0) &&
-               (var->data.location <= VARYING_SLOT_TEX7)) {
-         var->data.location += VARYING_SLOT_VAR0 - VARYING_SLOT_TEX0;
-      }
-   }
-}
-
-/* input location assignment for VS inputs must be handled specially, so
- * that it is aligned w/ st's vbo state.
- * (This isn't the case with, for ex, FS inputs, which only need to agree
- * on varying-slot w/ the VS outputs)
- */
-void
-st_nir_assign_vs_in_locations(struct nir_shader *nir)
-{
-   if (nir->info.stage != MESA_SHADER_VERTEX || nir->info.io_lowered)
-      return;
-
-   nir->num_inputs = util_bitcount64(nir->info.inputs_read);
-
-   bool removed_inputs = false;
-
-   nir_foreach_shader_in_variable_safe(var, nir) {
-      /* NIR already assigns dual-slot inputs to two locations so all we have
-       * to do is compact everything down.
-       */
-      if (nir->info.inputs_read & BITFIELD64_BIT(var->data.location)) {
-         var->data.driver_location =
-            util_bitcount64(nir->info.inputs_read &
-                              BITFIELD64_MASK(var->data.location));
-      } else {
-         /* Convert unused input variables to shader_temp (with no
-          * initialization), to avoid confusing drivers looking through the
-          * inputs array and expecting to find inputs with a driver_location
-          * set.
-          */
-         var->data.mode = nir_var_shader_temp;
-         removed_inputs = true;
-      }
-   }
-
-   /* Re-lower global vars, to deal with any dead VS inputs. */
-   if (removed_inputs)
-      NIR_PASS(_, nir, nir_lower_global_vars_to_local);
-}
-
 static int
 st_nir_lookup_parameter_index(struct gl_program *prog, nir_variable *var)
 {
@@ -405,45 +340,6 @@ st_glsl_to_nir_post_opts(struct st_context *st, struct gl_program *prog,
    return msg;
 }
 
-static void
-st_nir_vectorize_io(nir_shader *producer, nir_shader *consumer)
-{
-   if (consumer)
-      NIR_PASS(_, consumer, nir_lower_io_to_vector, nir_var_shader_in);
-
-   if (!producer)
-      return;
-
-   NIR_PASS(_, producer, nir_lower_io_to_vector, nir_var_shader_out);
-
-   if (producer->info.stage == MESA_SHADER_TESS_CTRL &&
-       producer->options->vectorize_tess_levels)
-      NIR_PASS(_, producer, nir_vectorize_tess_levels);
-
-   NIR_PASS(_, producer, nir_opt_combine_stores, nir_var_shader_out);
-
-   if ((producer)->info.stage != MESA_SHADER_TESS_CTRL) {
-      /* Calling lower_io_to_vector creates output variable writes with
-       * write-masks.  We only support these for TCS outputs, so for other
-       * stages, we need to call nir_lower_io_to_temporaries to get rid of
-       * them.  This, in turn, creates temporary variables and extra
-       * copy_deref intrinsics that we need to clean up.
-       */
-      NIR_PASS(_, producer, nir_lower_io_to_temporaries,
-                 nir_shader_get_entrypoint(producer), true, false);
-      NIR_PASS(_, producer, nir_lower_global_vars_to_local);
-      NIR_PASS(_, producer, nir_split_var_copies);
-      NIR_PASS(_, producer, nir_lower_var_copies);
-   }
-
-   /* Undef scalar store_deref intrinsics are not ignored by nir_lower_io,
-    * so they must be removed before that. These passes remove them.
-    */
-   NIR_PASS(_, producer, nir_lower_vars_to_ssa);
-   NIR_PASS(_, producer, nir_opt_undef);
-   NIR_PASS(_, producer, nir_opt_dce);
-}
-
 extern "C" {
 
 bool
@@ -587,28 +483,18 @@ st_link_glsl_to_nir(struct gl_context *ctx,
       const struct gl_shader_compiler_options *options =
             &ctx->Const.ShaderCompilerOptions[stage];
 
-      if (nir->info.io_lowered) {
-         /* Since IO is lowered, we won't need the IO variables from now on.
-          * nir_build_program_resource_list was the last pass that needed them.
-          */
-         NIR_PASS_V(nir, nir_remove_dead_variables,
-                    nir_var_shader_in | nir_var_shader_out, NULL);
-      }
+      /* Since IO is lowered, we won't need the IO variables from now on.
+       * nir_build_program_resource_list was the last pass that needed them.
+       */
+      NIR_PASS_V(nir, nir_remove_dead_variables,
+                 nir_var_shader_in | nir_var_shader_out, NULL);
 
       /* If there are forms of indirect addressing that the driver
        * cannot handle, perform the lowering pass.
        */
-      if (!(nir->options->support_indirect_inputs & BITFIELD_BIT(stage)) ||
-          !(nir->options->support_indirect_outputs & BITFIELD_BIT(stage)) ||
-          options->EmitNoIndirectTemp || options->EmitNoIndirectUniform) {
+      if (options->EmitNoIndirectTemp || options->EmitNoIndirectUniform) {
          nir_variable_mode mode = (nir_variable_mode)0;
 
-         if (!nir->info.io_lowered) {
-            mode |= !(nir->options->support_indirect_inputs & BITFIELD_BIT(stage)) ?
-               nir_var_shader_in : (nir_variable_mode)0;
-            mode |= !(nir->options->support_indirect_outputs & BITFIELD_BIT(stage)) ?
-               nir_var_shader_out : (nir_variable_mode)0;
-         }
          mode |= options->EmitNoIndirectTemp ?
             nir_var_function_temp : (nir_variable_mode)0;
          mode |= options->EmitNoIndirectUniform ?
@@ -631,50 +517,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
       struct nir_lower_compute_system_values_options cs_options = {};
       NIR_PASS(_, nir, nir_lower_system_values);
       NIR_PASS(_, nir, nir_lower_compute_system_values, &cs_options);
-
-      if (nir->info.io_lowered)
-         continue; /* the rest is for non-lowered IO only */
-
-      /* Remap the locations to slots so those requiring two slots will occupy
-       * two locations. For instance, if we have in the IR code a dvec3 attr0 in
-       * location 0 and vec4 attr1 in location 1, in NIR attr0 will use
-       * locations/slots 0 and 1, and attr1 will use location/slot 2
-       */
-      if (nir->info.stage == MESA_SHADER_VERTEX && !shader_program->data->spirv)
-         nir_remap_dual_slot_attributes(nir, &shader->Program->DualSlotInputs);
-
-      if (i >= 1) {
-         struct gl_program *prev_shader = linked_shader[i - 1]->Program;
-
-         /* We can't use nir_compact_varyings with transform feedback, since
-          * the pipe_stream_output->output_register field is based on the
-          * pre-compacted driver_locations.
-          */
-         if (!(prev_shader->sh.LinkedTransformFeedback &&
-               prev_shader->sh.LinkedTransformFeedback->NumVarying > 0))
-            nir_compact_varyings(prev_shader->nir,
-                                 nir, ctx->API != API_OPENGL_COMPAT);
-
-         if (ctx->Const.ShaderCompilerOptions[shader->Stage].NirOptions->vectorize_io)
-            st_nir_vectorize_io(prev_shader->nir, nir);
-      }
-   }
-
-   /* If the program is a separate shader program check if we need to vectorise
-    * the first and last program interfaces too.
-    */
-   if (shader_program->SeparateShader && num_shaders > 0) {
-      struct gl_linked_shader *first_shader = linked_shader[0];
-      struct gl_linked_shader *last_shader = linked_shader[num_shaders - 1];
-      if (first_shader->Stage != MESA_SHADER_COMPUTE) {
-         if (ctx->Const.ShaderCompilerOptions[first_shader->Stage].NirOptions->vectorize_io &&
-             first_shader->Stage > MESA_SHADER_VERTEX)
-            st_nir_vectorize_io(NULL, first_shader->Program->nir);
-
-         if (ctx->Const.ShaderCompilerOptions[last_shader->Stage].NirOptions->vectorize_io &&
-             last_shader->Stage < MESA_SHADER_FRAGMENT)
-            st_nir_vectorize_io(last_shader->Program->nir, NULL);
-      }
    }
 
    struct shader_info *prev_info = NULL;
@@ -739,18 +581,8 @@ st_link_glsl_to_nir(struct gl_context *ctx,
       prog->info.num_abos = old_info.num_abos;
 
       if (prog->info.stage == MESA_SHADER_VERTEX) {
-         if (prog->nir->info.io_lowered) {
-            prog->info.inputs_read = prog->nir->info.inputs_read;
-            prog->DualSlotInputs = prog->nir->info.dual_slot_inputs;
-         } else {
-            /* NIR expands dual-slot inputs out to two locations.  We need to
-             * compact things back down GL-style single-slot inputs to avoid
-             * confusing the state tracker.
-             */
-            prog->info.inputs_read =
-               nir_get_single_slot_attribs_mask(prog->nir->info.inputs_read,
-                                                prog->DualSlotInputs);
-         }
+         prog->info.inputs_read = prog->nir->info.inputs_read;
+         prog->DualSlotInputs = prog->nir->info.dual_slot_inputs;
 
          /* Initialize st_vertex_program members. */
          st_prepare_vertex_program(prog);
@@ -790,45 +622,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
    return true;
 }
 
-void
-st_nir_assign_varying_locations(struct st_context *st, nir_shader *nir)
-{
-   /* Lowered IO don't have variables, so exit. */
-   if (nir->info.io_lowered)
-      return;
-
-   if (nir->info.stage == MESA_SHADER_VERTEX) {
-      nir_assign_io_var_locations(nir, nir_var_shader_out,
-                                  &nir->num_outputs,
-                                  nir->info.stage);
-      st_nir_fixup_varying_slots(st, nir, nir_var_shader_out);
-   } else if (nir->info.stage == MESA_SHADER_GEOMETRY ||
-              nir->info.stage == MESA_SHADER_TESS_CTRL ||
-              nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      nir_assign_io_var_locations(nir, nir_var_shader_in,
-                                  &nir->num_inputs,
-                                  nir->info.stage);
-      st_nir_fixup_varying_slots(st, nir, nir_var_shader_in);
-
-      nir_assign_io_var_locations(nir, nir_var_shader_out,
-                                  &nir->num_outputs,
-                                  nir->info.stage);
-      st_nir_fixup_varying_slots(st, nir, nir_var_shader_out);
-   } else if (nir->info.stage == MESA_SHADER_FRAGMENT) {
-      nir_assign_io_var_locations(nir, nir_var_shader_in,
-                                  &nir->num_inputs,
-                                  nir->info.stage);
-      st_nir_fixup_varying_slots(st, nir, nir_var_shader_in);
-      nir_assign_io_var_locations(nir, nir_var_shader_out,
-                                  &nir->num_outputs,
-                                  nir->info.stage);
-   } else if (nir->info.stage == MESA_SHADER_COMPUTE) {
-       /* TODO? */
-   } else {
-      unreachable("invalid shader type");
-   }
-}
-
 void
 st_nir_lower_samplers(struct pipe_screen *screen, nir_shader *nir,
                       struct gl_shader_program *shader_program,
@@ -892,9 +685,6 @@ st_finalize_nir(struct st_context *st, struct gl_program *prog,
 
    MESA_TRACE_FUNC();
 
-   NIR_PASS(_, nir, nir_split_var_copies);
-   NIR_PASS(_, nir, nir_lower_var_copies);
-
    const bool lower_tg4_offsets =
       !is_draw_shader && !st->screen->get_param(screen, PIPE_CAP_TEXTURE_GATHER_OFFSETS);
 
@@ -906,7 +696,6 @@ st_finalize_nir(struct st_context *st, struct gl_program *prog,
       NIR_PASS(_, nir, nir_lower_tex, &opts);
    }
 
-   st_nir_assign_varying_locations(st, nir);
    st_nir_assign_uniform_locations(st->ctx, prog, nir);
 
    /* Set num_uniforms in number of attribute slots (vec4s) */
diff --git a/src/mesa/state_tracker/st_nir.h b/src/mesa/state_tracker/st_nir.h
index f87b9d9e62954..794b6c60cfb01 100644
--- a/src/mesa/state_tracker/st_nir.h
+++ b/src/mesa/state_tracker/st_nir.h
@@ -48,10 +48,6 @@ void st_finalize_nir(struct st_context *st, struct gl_program *prog,
                      struct nir_shader *nir, bool is_before_variants,
                      bool is_draw_shader);
 
-void st_nir_assign_vs_in_locations(struct nir_shader *nir);
-void st_nir_assign_varying_locations(struct st_context *st,
-                                     struct nir_shader *nir);
-
 void st_nir_lower_samplers(struct pipe_screen *screen, struct nir_shader *nir,
                            struct gl_shader_program *shader_program,
                            struct gl_program *prog);
diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index 165de9ebd6c7e..84f141097acfb 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -39,9 +39,6 @@ st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
    if (stage == MESA_SHADER_FRAGMENT)
       nir->info.fs.untyped_color_outputs = true;
 
-   NIR_PASS(_, nir, nir_lower_global_vars_to_local);
-   NIR_PASS(_, nir, nir_split_var_copies);
-   NIR_PASS(_, nir, nir_lower_var_copies);
    NIR_PASS(_, nir, nir_lower_system_values);
 
    struct nir_lower_compute_system_values_options cs_options = {
@@ -50,14 +47,6 @@ st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
    };
    NIR_PASS(_, nir, nir_lower_compute_system_values, &cs_options);
 
-   if (nir->options->lower_to_scalar) {
-      nir_variable_mode mask =
-          (stage > MESA_SHADER_VERTEX ? nir_var_shader_in : 0) |
-          (stage < MESA_SHADER_FRAGMENT ? nir_var_shader_out : 0);
-
-      NIR_PASS(_, nir, nir_lower_io_to_scalar_early, mask);
-   }
-
    if (st->lower_rect_tex) {
       const struct nir_lower_tex_options opts = { .lower_rect = true, };
       NIR_PASS(_, nir, nir_lower_tex, &opts);
@@ -66,9 +55,6 @@ st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
    nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
    nir_recompute_io_bases(nir, nir_var_shader_in | nir_var_shader_out);
 
-   st_nir_assign_vs_in_locations(nir);
-   st_nir_assign_varying_locations(st, nir);
-
    st_nir_lower_samplers(screen, nir, NULL, NULL);
    st_nir_lower_uniforms(st, nir);
    if (!screen->get_param(screen, PIPE_CAP_NIR_IMAGES_AS_DEREF))
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 9f317da1db05c..f7ef9fa1a705e 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -349,21 +349,7 @@ st_release_program(struct st_context *st, struct gl_program **p)
 void
 st_finalize_nir_before_variants(struct nir_shader *nir)
 {
-   NIR_PASS(_, nir, nir_split_var_copies);
-   NIR_PASS(_, nir, nir_lower_var_copies);
-   if (nir->options->lower_all_io_to_temps ||
-       nir->options->lower_all_io_to_elements ||
-       nir->info.stage == MESA_SHADER_VERTEX ||
-       nir->info.stage == MESA_SHADER_GEOMETRY) {
-      NIR_PASS(_, nir, nir_lower_io_arrays_to_elements_no_indirects, false);
-   } else if (nir->info.stage == MESA_SHADER_FRAGMENT) {
-      NIR_PASS(_, nir, nir_lower_io_arrays_to_elements_no_indirects, true);
-   }
-
-   /* st_nir_assign_vs_in_locations requires correct shader info. */
    nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
-
-   st_nir_assign_vs_in_locations(nir);
 }
 
 static void
@@ -375,14 +361,6 @@ st_prog_to_nir_postprocess(struct st_context *st, nir_shader *nir,
    NIR_PASS(_, nir, nir_lower_reg_intrinsics_to_ssa);
    nir_validate_shader(nir, "after st/ptn lower_reg_intrinsics_to_ssa");
 
-   /* Lower outputs to temporaries to avoid reading from output variables (which
-    * is permitted by the language but generally not implemented in HW).
-    */
-   NIR_PASS(_, nir, nir_lower_io_to_temporaries,
-               nir_shader_get_entrypoint(nir),
-               true, false);
-   NIR_PASS(_, nir, nir_lower_global_vars_to_local);
-
    NIR_PASS(_, nir, st_nir_lower_wpos_ytransform, prog, screen);
    NIR_PASS(_, nir, nir_lower_system_values);
 
@@ -723,10 +701,6 @@ lower_ucp(struct st_context *st,
          NIR_PASS(_, nir, nir_lower_clip_gs, ucp_enables,
                     can_compact, clipplane_state);
       }
-
-      NIR_PASS(_, nir, nir_lower_io_to_temporaries,
-                 nir_shader_get_entrypoint(nir), true, false);
-      NIR_PASS(_, nir, nir_lower_global_vars_to_local);
    }
 }
 
@@ -1069,10 +1043,6 @@ st_create_fp_variant(struct st_context *st,
    if (fp->ati_fs) {
       if (key->fog) {
          NIR_PASS(_, state.ir.nir, st_nir_lower_fog, key->fog, fp->Parameters);
-         NIR_PASS(_, state.ir.nir, nir_lower_io_to_temporaries,
-            nir_shader_get_entrypoint(state.ir.nir),
-            true, false);
-         nir_lower_global_vars_to_local(state.ir.nir);
       }
 
       NIR_PASS(_, state.ir.nir, st_nir_lower_atifs_samplers, key->texture_index);
@@ -1105,13 +1075,8 @@ st_create_fp_variant(struct st_context *st,
 
    if (key->persample_shading) {
       nir_shader *shader = state.ir.nir;
-      if (shader->info.io_lowered) {
-         nir_shader_intrinsics_pass(shader, force_persample_shading,
-                                    nir_metadata_all, NULL);
-      } else {
-         nir_foreach_shader_in_variable(var, shader)
-            var->data.sample = true;
-      }
+      nir_shader_intrinsics_pass(shader, force_persample_shading,
+                                 nir_metadata_all, NULL);
 
       /* In addition to requiring per-sample interpolation, sample shading
        * changes the behaviour of gl_SampleMaskIn, so we need per-sample shading
@@ -1245,8 +1210,7 @@ st_create_fp_variant(struct st_context *st,
    assert(state.ir.nir->info.io_lowered);
 
    /* This should be after all passes that touch IO. */
-   if (state.ir.nir->info.io_lowered &&
-       !(state.ir.nir->options->io_options & nir_io_has_intrinsics)) {
+   if (!(state.ir.nir->options->io_options & nir_io_has_intrinsics)) {
       /* Some lowering passes can leave dead code behind, but dead IO intrinsics
        * are still counted as enabled IO, which breaks things.
        */
-- 
GitLab


From 4f5e6023ad08a661a59a16ed323f3c728dccccaf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Nov 2024 00:59:15 -0400
Subject: [PATCH 28/33] glsl: remove dead code due to IO being always lowered

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/glsl/gl_nir_linker.c | 65 -------------------------------
 1 file changed, 65 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_linker.c b/src/compiler/glsl/gl_nir_linker.c
index 889d2c947dbc0..35852c7981748 100644
--- a/src/compiler/glsl/gl_nir_linker.c
+++ b/src/compiler/glsl/gl_nir_linker.c
@@ -484,47 +484,6 @@ gl_nir_can_add_pointsize_to_program(const struct gl_constants *consts,
    return num_components + needed_components <= max_components;
 }
 
-static void
-gl_nir_link_opts(nir_shader *producer, nir_shader *consumer)
-{
-   MESA_TRACE_FUNC();
-
-   if (producer->options->lower_to_scalar) {
-      NIR_PASS(_, producer, nir_lower_io_to_scalar_early, nir_var_shader_out);
-      NIR_PASS(_, consumer, nir_lower_io_to_scalar_early, nir_var_shader_in);
-   }
-
-   nir_lower_io_arrays_to_elements(producer, consumer);
-
-   gl_nir_opts(producer);
-   gl_nir_opts(consumer);
-
-   if (nir_link_opt_varyings(producer, consumer))
-      gl_nir_opts(consumer);
-
-   NIR_PASS(_, producer, nir_remove_dead_variables, nir_var_shader_out, NULL);
-   NIR_PASS(_, consumer, nir_remove_dead_variables, nir_var_shader_in, NULL);
-
-   if (nir_remove_unused_varyings(producer, consumer)) {
-      NIR_PASS(_, producer, nir_lower_global_vars_to_local);
-      NIR_PASS(_, consumer, nir_lower_global_vars_to_local);
-
-      gl_nir_opts(producer);
-      gl_nir_opts(consumer);
-
-      /* Optimizations can cause varyings to become unused.
-       * nir_compact_varyings() depends on all dead varyings being removed so
-       * we need to call nir_remove_dead_variables() again here.
-       */
-      NIR_PASS(_, producer, nir_remove_dead_variables, nir_var_shader_out,
-                 NULL);
-      NIR_PASS(_, consumer, nir_remove_dead_variables, nir_var_shader_in,
-                 NULL);
-   }
-
-   nir_link_varying_precision(producer, consumer);
-}
-
 static bool
 can_remove_var(nir_variable *var, UNUSED void *data)
 {
@@ -1644,18 +1603,6 @@ gl_nir_link_spirv(const struct gl_constants *consts,
    gl_nir_link_assign_xfb_resources(consts, prog);
    gl_nir_lower_optimize_varyings(consts, prog, true);
 
-   if (!linked_shader[0]->Program->nir->info.io_lowered) {
-      /* Linking the stages in the opposite order (from fragment to vertex)
-       * ensures that inter-shader outputs written to in an earlier stage
-       * are eliminated if they are (transitively) not used in a later
-       * stage.
-       */
-      for (int i = num_shaders - 2; i >= 0; i--) {
-         gl_nir_link_opts(linked_shader[i]->Program->nir,
-                          linked_shader[i + 1]->Program->nir);
-      }
-   }
-
    for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
       struct gl_linked_shader *shader = prog->_LinkedShaders[i];
       if (shader) {
@@ -4006,18 +3953,6 @@ gl_nir_link_glsl(struct gl_context *ctx, struct gl_shader_program *prog)
    if (prog->data->LinkStatus == LINKING_FAILURE)
       goto done;
 
-   if (!linked_shader[0]->Program->nir->info.io_lowered) {
-      /* Linking the stages in the opposite order (from fragment to vertex)
-       * ensures that inter-shader outputs written to in an earlier stage
-       * are eliminated if they are (transitively) not used in a later
-       * stage.
-       */
-      for (int i = num_linked_shaders - 2; i >= 0; i--) {
-         gl_nir_link_opts(linked_shader[i]->Program->nir,
-                          linked_shader[i + 1]->Program->nir);
-      }
-   }
-
    /* Tidy up any left overs from the linking process for single shaders.
     * For example varying arrays that get packed may have dead elements that
     * can be now be eliminated now that array access has been lowered.
-- 
GitLab


From c9598988d3e590e7734cab9f28e937d717d124a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 16:39:19 -0500
Subject: [PATCH 29/33] glsl: simplify nir_lower_io_to_temporaries logic

no change in behavior

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/glsl/gl_nir_linker.c | 17 +++++------------
 1 file changed, 5 insertions(+), 12 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_linker.c b/src/compiler/glsl/gl_nir_linker.c
index 35852c7981748..a0923e01b9dd2 100644
--- a/src/compiler/glsl/gl_nir_linker.c
+++ b/src/compiler/glsl/gl_nir_linker.c
@@ -1314,18 +1314,11 @@ preprocess_shader(const struct gl_constants *consts,
        (nir->info.outputs_written & (VARYING_BIT_CLIP_DIST0 | VARYING_BIT_CLIP_DIST1)))
       NIR_PASS(_, nir, gl_nir_zero_initialize_clip_distance);
 
-   if (options->lower_all_io_to_temps ||
-       nir->info.stage == MESA_SHADER_VERTEX ||
-       nir->info.stage == MESA_SHADER_GEOMETRY) {
-      NIR_PASS(_, nir, nir_lower_io_to_temporaries,
-                 nir_shader_get_entrypoint(nir),
-                 true, true);
-   } else if (nir->info.stage == MESA_SHADER_TESS_EVAL ||
-              nir->info.stage == MESA_SHADER_FRAGMENT) {
-      NIR_PASS(_, nir, nir_lower_io_to_temporaries,
-                 nir_shader_get_entrypoint(nir),
-                 true, false);
-   }
+   NIR_PASS(_, nir, nir_lower_io_to_temporaries,
+            nir_shader_get_entrypoint(nir), true,
+            options->lower_all_io_to_temps ||
+            nir->info.stage == MESA_SHADER_VERTEX ||
+            nir->info.stage == MESA_SHADER_GEOMETRY);
 
    NIR_PASS(_, nir, nir_lower_global_vars_to_local);
    NIR_PASS(_, nir, nir_split_var_copies);
-- 
GitLab


From 4f1989e63b92b4ee8094c33ec377e830d7b17a81 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Nov 2024 01:21:33 -0400
Subject: [PATCH 30/33] nir: remove dead code due to IO being always lowered in
 st/mesa

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/asahi/compiler/agx_compile.h              |  1 -
 src/compiler/nir/nir.c                        | 44 -------------------
 src/compiler/nir/nir.h                        | 11 +----
 src/freedreno/ir3/ir3_compiler.c              |  1 -
 .../drivers/etnaviv/etnaviv_compiler.c        |  1 -
 src/gallium/drivers/r600/r600_pipe_common.c   |  1 -
 src/intel/compiler/brw_compiler.c             |  1 -
 src/intel/compiler/elk/elk_nir_options.c      |  1 -
 src/microsoft/compiler/nir_to_dxil.c          |  1 -
 src/nouveau/codegen/nv50_ir_from_nir.cpp      |  2 -
 src/panfrost/compiler/bifrost_compile.h       |  1 -
 src/panfrost/midgard/midgard_compile.h        |  1 -
 12 files changed, 1 insertion(+), 65 deletions(-)

diff --git a/src/asahi/compiler/agx_compile.h b/src/asahi/compiler/agx_compile.h
index b2e4e0b9c334b..c2666d3e4a89b 100644
--- a/src/asahi/compiler/agx_compile.h
+++ b/src/asahi/compiler/agx_compile.h
@@ -359,7 +359,6 @@ static const nir_shader_compiler_options agx_nir_options = {
    .has_cs_global_id = true,
    .lower_device_index_to_zero = true,
    .lower_hadd = true,
-   .vectorize_io = true,
    .has_amul = true,
    .has_isub = true,
    .support_16bit_alu = true,
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 208f1185ef8b6..a8a37d0426bd2 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -2596,50 +2596,6 @@ nir_system_value_from_intrinsic(nir_intrinsic_op intrin)
    }
 }
 
-/* OpenGL utility method that remaps the location attributes if they are
- * doubles. Not needed for vulkan due the differences on the input location
- * count for doubles on vulkan vs OpenGL
- *
- * The bitfield returned in dual_slot is one bit for each double input slot in
- * the original OpenGL single-slot input numbering.  The mapping from old
- * locations to new locations is as follows:
- *
- *    new_loc = loc + util_bitcount(dual_slot & BITFIELD64_MASK(loc))
- */
-void
-nir_remap_dual_slot_attributes(nir_shader *shader, uint64_t *dual_slot)
-{
-   assert(shader->info.stage == MESA_SHADER_VERTEX);
-
-   *dual_slot = 0;
-   nir_foreach_shader_in_variable(var, shader) {
-      if (glsl_type_is_dual_slot(glsl_without_array(var->type))) {
-         unsigned slots = glsl_count_attribute_slots(var->type, true);
-         *dual_slot |= BITFIELD64_MASK(slots) << var->data.location;
-      }
-   }
-
-   nir_foreach_shader_in_variable(var, shader) {
-      var->data.location +=
-         util_bitcount64(*dual_slot & BITFIELD64_MASK(var->data.location));
-   }
-}
-
-/* Returns an attribute mask that has been re-compacted using the given
- * dual_slot mask.
- */
-uint64_t
-nir_get_single_slot_attribs_mask(uint64_t attribs, uint64_t dual_slot)
-{
-   while (dual_slot) {
-      unsigned loc = u_bit_scan64(&dual_slot);
-      /* mask of all bits up to and including loc */
-      uint64_t mask = BITFIELD64_MASK(loc + 1);
-      attribs = (attribs & mask) | ((attribs & ~mask) >> 1);
-   }
-   return attribs;
-}
-
 void
 nir_rewrite_image_intrinsic(nir_intrinsic_instr *intrin, nir_def *src,
                             bool bindless)
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 16b36d4844c06..a1cba8c1bc4cc 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3982,8 +3982,8 @@ typedef struct nir_shader_compiler_options {
    bool lower_insert_byte;
    bool lower_insert_word;
 
+   /* TODO: this flag is potentially useless, remove? */
    bool lower_all_io_to_temps;
-   bool lower_all_io_to_elements;
 
    /* Indicates that the driver only has zero-based vertex id */
    bool vertex_id_zero_based;
@@ -4094,11 +4094,6 @@ typedef struct nir_shader_compiler_options {
     */
    bool lower_mul_32x16;
 
-   /**
-    * Should IO be re-vectorized?  Some scalar ISAs still operate on vec4's
-    * for IO purposes and would prefer loads/stores be vectorized.
-    */
-   bool vectorize_io;
    bool vectorize_tess_levels;
    bool lower_to_scalar;
    nir_instr_filter_cb lower_to_scalar_filter;
@@ -7012,10 +7007,6 @@ bool nir_opt_ray_query_ranges(nir_shader *shader);
 
 void nir_sweep(nir_shader *shader);
 
-void nir_remap_dual_slot_attributes(nir_shader *shader,
-                                    uint64_t *dual_slot_inputs);
-uint64_t nir_get_single_slot_attribs_mask(uint64_t attribs, uint64_t dual_slot);
-
 nir_intrinsic_op nir_intrinsic_from_system_value(gl_system_value val);
 gl_system_value nir_system_value_from_intrinsic(nir_intrinsic_op intrin);
 
diff --git a/src/freedreno/ir3/ir3_compiler.c b/src/freedreno/ir3/ir3_compiler.c
index b80ef318d59bf..74b642ca17801 100644
--- a/src/freedreno/ir3/ir3_compiler.c
+++ b/src/freedreno/ir3/ir3_compiler.c
@@ -303,7 +303,6 @@ ir3_compiler_create(struct fd_device *dev, const struct fd_dev_id *dev_id,
    compiler->nir_options.has_iadd3 = dev_info->a6xx.has_sad;
 
    if (compiler->gen >= 6) {
-      compiler->nir_options.vectorize_io = true,
       compiler->nir_options.force_indirect_unrolling = nir_var_all,
       compiler->nir_options.lower_device_index_to_zero = true;
 
diff --git a/src/gallium/drivers/etnaviv/etnaviv_compiler.c b/src/gallium/drivers/etnaviv/etnaviv_compiler.c
index 63d7866e5cf7a..ecdcd32a10cd1 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_compiler.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_compiler.c
@@ -68,7 +68,6 @@ etna_compiler_create(const char *renderer, const struct etna_core_info *info)
       .lower_uniforms_to_ubo = info->halti >= 2,
       .force_indirect_unrolling = nir_var_all,
       .max_unroll_iterations = 32,
-      .vectorize_io = true,
       .lower_pack_32_2x16_split = true,
       .lower_pack_64_2x32_split = true,
       .lower_unpack_32_2x16_split = true,
diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index ddc36be194105..d688ede68b1e7 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -1381,7 +1381,6 @@ bool r600_common_screen_init(struct r600_common_screen *rscreen,
 		 */
 		.max_unroll_iterations = 255,
 		.lower_interpolate_at = true,
-		.vectorize_io = true,
 		.has_umad24 = true,
 		.has_umul24 = true,
 		.has_fmulz = true,
diff --git a/src/intel/compiler/brw_compiler.c b/src/intel/compiler/brw_compiler.c
index 87a32b968a240..f72a556a1b262 100644
--- a/src/intel/compiler/brw_compiler.c
+++ b/src/intel/compiler/brw_compiler.c
@@ -75,7 +75,6 @@ const struct nir_shader_compiler_options brw_scalar_nir_options = {
    .lower_usub_borrow = true,
    .max_unroll_iterations = 32,
    .support_16bit_alu = true,
-   .vectorize_io = true,
    .vectorize_tess_levels = true,
    .vertex_id_zero_based = true,
    .scalarize_ddx = true,
diff --git a/src/intel/compiler/elk/elk_nir_options.c b/src/intel/compiler/elk/elk_nir_options.c
index 458a00ced2bcf..59141d82a18ae 100644
--- a/src/intel/compiler/elk/elk_nir_options.c
+++ b/src/intel/compiler/elk/elk_nir_options.c
@@ -23,7 +23,6 @@
    .lower_bitfield_extract = true,                                            \
    .lower_bitfield_insert = true,                                             \
    .lower_device_index_to_zero = true,                                        \
-   .vectorize_io = true,                                                      \
    .vectorize_tess_levels = true,                                             \
    .scalarize_ddx = true,                                                     \
    .lower_insert_byte = true,                                                 \
diff --git a/src/microsoft/compiler/nir_to_dxil.c b/src/microsoft/compiler/nir_to_dxil.c
index ee0da85327e11..34926f289b2c7 100644
--- a/src/microsoft/compiler/nir_to_dxil.c
+++ b/src/microsoft/compiler/nir_to_dxil.c
@@ -111,7 +111,6 @@ nir_options = {
    .lower_extract_byte = true,
    .lower_insert_word = true,
    .lower_insert_byte = true,
-   .lower_all_io_to_elements = true,
    .lower_hadd = true,
    .lower_uadd_sat = true,
    .lower_usub_sat = true,
diff --git a/src/nouveau/codegen/nv50_ir_from_nir.cpp b/src/nouveau/codegen/nv50_ir_from_nir.cpp
index bd55207223c5a..9c4f85475e012 100644
--- a/src/nouveau/codegen/nv50_ir_from_nir.cpp
+++ b/src/nouveau/codegen/nv50_ir_from_nir.cpp
@@ -3614,7 +3614,6 @@ nvir_nir_shader_compiler_options(int chipset, uint8_t shader_type)
    op.lower_insert_byte = true;
    op.lower_insert_word = true;
    op.lower_all_io_to_temps = false;
-   op.lower_all_io_to_elements = false;
    op.vertex_id_zero_based = false;
    op.lower_base_vertex = false;
    op.lower_helper_invocation = false;
@@ -3627,7 +3626,6 @@ nvir_nir_shader_compiler_options(int chipset, uint8_t shader_type)
    op.lower_uadd_sat = true; // TODO
    op.lower_usub_sat = true; // TODO
    op.lower_iadd_sat = true; // TODO
-   op.vectorize_io = false;
    op.lower_to_scalar = false;
    op.unify_interfaces = false;
    op.lower_mul_2x32_64 = true; // TODO
diff --git a/src/panfrost/compiler/bifrost_compile.h b/src/panfrost/compiler/bifrost_compile.h
index eec69d3ae8ea5..6a6f297c0a361 100644
--- a/src/panfrost/compiler/bifrost_compile.h
+++ b/src/panfrost/compiler/bifrost_compile.h
@@ -84,7 +84,6 @@ void bifrost_compile_shader_nir(nir_shader *nir,
       .lower_usub_borrow = true,                                               \
                                                                                \
       .has_isub = true,                                                        \
-      .vectorize_io = true,                                                    \
       .vectorize_vec2_16bit = true,                                            \
       .fuse_ffma16 = true,                                                     \
       .fuse_ffma32 = true,                                                     \
diff --git a/src/panfrost/midgard/midgard_compile.h b/src/panfrost/midgard/midgard_compile.h
index 6fc2a25b543df..61b20da6876ff 100644
--- a/src/panfrost/midgard/midgard_compile.h
+++ b/src/panfrost/midgard/midgard_compile.h
@@ -96,7 +96,6 @@ static const nir_shader_compiler_options midgard_nir_options = {
    .lower_uniforms_to_ubo = true,
    .has_fsub = true,
    .has_isub = true,
-   .vectorize_io = true,
 
    .vertex_id_zero_based = true,
    .has_cs_global_id = true,
-- 
GitLab


From 690d18500b89103bab71e3c92afd086e53d8bf2a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 17:10:13 -0500
Subject: [PATCH 31/33] st/mesa: inline st_finalize_nir_before_variants

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/mesa/state_tracker/st_glsl_to_nir.cpp | 3 +--
 src/mesa/state_tracker/st_program.c       | 8 +-------
 src/mesa/state_tracker/st_program.h       | 3 ---
 3 files changed, 2 insertions(+), 12 deletions(-)

diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index cc3acf011c635..2b1bad42c00f8 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -316,8 +316,7 @@ st_glsl_to_nir_post_opts(struct st_context *st, struct gl_program *prog,
    }
 
    st_set_prog_affected_state_flags(prog);
-
-   st_finalize_nir_before_variants(nir);
+   nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
 
    char *msg = NULL;
    if (st->allow_st_finalize_nir_twice) {
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index f7ef9fa1a705e..fbb6fd3718790 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -346,12 +346,6 @@ st_release_program(struct st_context *st, struct gl_program **p)
    _mesa_reference_program(st->ctx, p, NULL);
 }
 
-void
-st_finalize_nir_before_variants(struct nir_shader *nir)
-{
-   nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
-}
-
 static void
 st_prog_to_nir_postprocess(struct st_context *st, nir_shader *nir,
                            struct gl_program *prog)
@@ -374,9 +368,9 @@ st_prog_to_nir_postprocess(struct st_context *st, nir_shader *nir,
    NIR_PASS(_, nir, nir_opt_constant_folding);
    gl_nir_opts(nir);
 
+   nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
    /* This must be done after optimizations to assign IO bases. */
    nir_recompute_io_bases(nir, nir_var_shader_in | nir_var_shader_out);
-   st_finalize_nir_before_variants(nir);
 
    if (st->allow_st_finalize_nir_twice) {
       st_serialize_base_nir(prog, nir);
diff --git a/src/mesa/state_tracker/st_program.h b/src/mesa/state_tracker/st_program.h
index b81770afc9ff8..1654e2b1d9b89 100644
--- a/src/mesa/state_tracker/st_program.h
+++ b/src/mesa/state_tracker/st_program.h
@@ -359,9 +359,6 @@ st_release_program(struct st_context *st, struct gl_program **p);
 extern void
 st_destroy_program_variants(struct st_context *st);
 
-extern void
-st_finalize_nir_before_variants(struct nir_shader *nir);
-
 extern void
 st_prepare_vertex_program(struct gl_program *stvp);
 
-- 
GitLab


From e383ae7e0bff1295a5236ca3d05da841716d2086 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 24 Dec 2024 18:08:43 -0500
Subject: [PATCH 32/33] nir: remove handling IO variables from passes used by
 st/mesa

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_lower_alpha_test.c       | 12 +--
 src/compiler/nir/nir_lower_bitmap.c           | 14 +--
 .../nir/nir_lower_clamp_color_outputs.c       | 17 +---
 src/compiler/nir/nir_lower_clip_disable.c     | 91 +-----------------
 src/compiler/nir/nir_lower_drawpixels.c       | 38 ++------
 src/compiler/nir/nir_lower_flatshade.c        | 27 +-----
 .../nir/nir_lower_passthrough_edgeflags.c     | 45 +++------
 src/compiler/nir/nir_lower_pntc_ytransform.c  |  9 +-
 src/compiler/nir/nir_lower_point_size_mov.c   | 30 +-----
 src/compiler/nir/nir_lower_two_sided_color.c  | 94 ++-----------------
 src/compiler/nir/nir_lower_wpos_ytransform.c  |  8 +-
 src/mesa/state_tracker/st_nir_lower_fog.c     | 59 +++---------
 .../st_nir_lower_position_invariant.c         | 26 +----
 13 files changed, 77 insertions(+), 393 deletions(-)

diff --git a/src/compiler/nir/nir_lower_alpha_test.c b/src/compiler/nir/nir_lower_alpha_test.c
index c02dabc921a1a..046c4acc9ece8 100644
--- a/src/compiler/nir/nir_lower_alpha_test.c
+++ b/src/compiler/nir/nir_lower_alpha_test.c
@@ -51,17 +51,8 @@ static bool
 lower(nir_builder *b, nir_intrinsic_instr *intr, void *data)
 {
    struct alpha_test_state *state = data;
-   nir_variable *out = NULL;
 
    switch (intr->intrinsic) {
-   case nir_intrinsic_store_deref:
-      out = nir_intrinsic_get_var(intr, 0);
-      if (out->data.mode != nir_var_shader_out)
-         return false;
-
-      if (!is_color_output(out->data.location))
-         return false;
-      break;
    case nir_intrinsic_store_output:
       if (!is_color_output(nir_intrinsic_io_semantics(intr).location))
          return false;
@@ -75,8 +66,6 @@ lower(nir_builder *b, nir_intrinsic_instr *intr, void *data)
    nir_def *alpha;
    if (state->alpha_to_one)
       alpha = nir_imm_float(b, 1.0);
-   else if (intr->intrinsic == nir_intrinsic_store_deref)
-      alpha = nir_channel(b, intr->src[1].ssa, 3);
    else
       alpha = nir_channel(b, intr->src[0].ssa, 3);
 
@@ -96,6 +85,7 @@ nir_lower_alpha_test(nir_shader *shader, enum compare_func func,
                      bool alpha_to_one,
                      const gl_state_index16 *alpha_ref_state_tokens)
 {
+   assert(shader->info.io_lowered);
    struct alpha_test_state state = {
       .alpha_ref_state_tokens = alpha_ref_state_tokens,
       .alpha_to_one = alpha_to_one,
diff --git a/src/compiler/nir/nir_lower_bitmap.c b/src/compiler/nir/nir_lower_bitmap.c
index 0f65b848786c3..d56a324ec36c6 100644
--- a/src/compiler/nir/nir_lower_bitmap.c
+++ b/src/compiler/nir/nir_lower_bitmap.c
@@ -58,17 +58,10 @@ lower_bitmap(nir_shader *shader, nir_builder *b,
    nir_tex_instr *tex;
    nir_def *cond;
 
-   if (shader->info.io_lowered) {
-      nir_def *baryc =
+   nir_def *baryc =
          nir_load_barycentric_pixel(b, 32, .interp_mode = INTERP_MODE_SMOOTH);
-      texcoord = nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
-                                             .io_semantics.location = VARYING_SLOT_TEX0);
-   } else {
-      nir_variable *var =
-         nir_get_variable_with_location(shader, nir_var_shader_in,
-                                        VARYING_SLOT_TEX0, glsl_vec4_type());
-      texcoord = nir_load_var(b, var);
-   }
+   texcoord = nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
+                                          .io_semantics.location = VARYING_SLOT_TEX0);
 
    const struct glsl_type *sampler2D =
       glsl_sampler_type(GLSL_SAMPLER_DIM_2D, false, false, GLSL_TYPE_FLOAT);
@@ -121,6 +114,7 @@ nir_lower_bitmap(nir_shader *shader,
                  const nir_lower_bitmap_options *options)
 {
    assert(shader->info.stage == MESA_SHADER_FRAGMENT);
+   assert(shader->info.io_lowered);
 
    lower_bitmap_impl(nir_shader_get_entrypoint(shader), options);
    return true;
diff --git a/src/compiler/nir/nir_lower_clamp_color_outputs.c b/src/compiler/nir/nir_lower_clamp_color_outputs.c
index a0a7db9d57b4f..66c81866d2c89 100644
--- a/src/compiler/nir/nir_lower_clamp_color_outputs.c
+++ b/src/compiler/nir/nir_lower_clamp_color_outputs.c
@@ -52,17 +52,9 @@ is_color_output(nir_shader *shader, int location)
 static bool
 lower_intrinsic(nir_builder *b, nir_intrinsic_instr *intr, nir_shader *shader)
 {
-   nir_variable *out = NULL;
-   nir_def *s;
    int loc = -1;
 
    switch (intr->intrinsic) {
-   case nir_intrinsic_store_deref:
-      out = nir_intrinsic_get_var(intr, 0);
-      if (out->data.mode != nir_var_shader_out)
-         return false;
-      loc = out->data.location;
-      break;
    case nir_intrinsic_store_output:
    case nir_intrinsic_store_per_view_output:
       loc = nir_intrinsic_io_semantics(intr).location;
@@ -73,13 +65,13 @@ lower_intrinsic(nir_builder *b, nir_intrinsic_instr *intr, nir_shader *shader)
 
    if (is_color_output(shader, loc)) {
       b->cursor = nir_before_instr(&intr->instr);
-      int src = intr->intrinsic == nir_intrinsic_store_deref ? 1 : 0;
-      s = intr->src[src].ssa;
+      nir_def *s = intr->src[0].ssa;
       s = nir_fsat(b, s);
-      nir_src_rewrite(&intr->src[src], s);
+      nir_src_rewrite(&intr->src[0], s);
+      return true;
    }
 
-   return true;
+   return false;
 }
 
 static bool
@@ -93,6 +85,7 @@ lower_instr(nir_builder *b, nir_instr *instr, void *cb_data)
 bool
 nir_lower_clamp_color_outputs(nir_shader *shader)
 {
+   assert(shader->info.io_lowered);
    return nir_shader_instructions_pass(shader, lower_instr,
                                        nir_metadata_control_flow,
                                        shader);
diff --git a/src/compiler/nir/nir_lower_clip_disable.c b/src/compiler/nir/nir_lower_clip_disable.c
index bf705cc9f0491..c95681cf2db15 100644
--- a/src/compiler/nir/nir_lower_clip_disable.c
+++ b/src/compiler/nir/nir_lower_clip_disable.c
@@ -33,88 +33,6 @@
  * value if the plane is disabled
  */
 
-/* recursively nest if/else blocks until we get to an array index,
- * then overwrite it if that plane isn't enabled
- */
-static void
-recursive_if_chain(nir_builder *b, nir_deref_instr *deref, nir_def *value, unsigned clip_plane_enable, nir_def *index, unsigned start, unsigned end)
-{
-   if (start == end - 1) {
-      /* store the original value again if the clip plane is enabled */
-      if (clip_plane_enable & (1 << start))
-         nir_store_deref(b, deref, value, 1 << start);
-      else
-         nir_store_deref(b, deref, nir_imm_int(b, 0), 1 << start);
-      return;
-   }
-
-   unsigned mid = start + (end - start) / 2;
-   nir_push_if(b, nir_ilt_imm(b, index, mid));
-   recursive_if_chain(b, deref, value, clip_plane_enable, index, start, mid);
-   nir_push_else(b, NULL);
-   recursive_if_chain(b, deref, value, clip_plane_enable, index, mid, end);
-   nir_pop_if(b, NULL);
-}
-
-/* vulkan (and some drivers) provides no concept of enabling clip planes through api,
- * so we rewrite disabled clip planes to a zero value in order to disable them
- */
-static bool
-lower_clip_plane_store(nir_builder *b, nir_intrinsic_instr *instr,
-                       void *cb_data)
-{
-   unsigned clip_plane_enable = *(unsigned *)cb_data;
-   nir_variable *out;
-   unsigned plane;
-
-   if (instr->intrinsic != nir_intrinsic_store_deref)
-      return false;
-
-   nir_deref_instr *deref = nir_src_as_deref(instr->src[0]);
-
-   out = nir_deref_instr_get_variable(deref);
-   if ((out->data.location != VARYING_SLOT_CLIP_DIST0 &&
-        out->data.location != VARYING_SLOT_CLIP_DIST1) ||
-       out->data.mode != nir_var_shader_out)
-      return false;
-
-   b->cursor = nir_after_instr(&instr->instr);
-   if (deref->deref_type == nir_deref_type_var) {
-      int wrmask = nir_intrinsic_write_mask(instr);
-
-      nir_def *components[4];
-      int start = out->data.location == VARYING_SLOT_CLIP_DIST1 ? 4 : 0;
-      /* rewrite components as zeroes for planes that aren't enabled */
-      for (int i = 0; i < 4; i++) {
-         if (wrmask & (1 << i)) {
-            if (!(clip_plane_enable & (1 << (start + i))))
-               components[i] = nir_imm_int(b, 0);
-            else
-               components[i] = nir_channel(b, instr->src[1].ssa, i);
-         } else
-            components[i] = nir_undef(b, 1, 32);
-      }
-      nir_store_deref(b, deref, nir_vec(b, components, instr->num_components), wrmask);
-   } else if (nir_src_is_const(deref->arr.index)) {
-      /* storing using a constant index */
-      plane = nir_src_as_uint(deref->arr.index);
-      /* no need to make changes if the clip plane is enabled */
-      if (clip_plane_enable & (1 << plane))
-         return false;
-
-      assert(nir_intrinsic_write_mask(instr) == 1);
-      nir_store_deref(b, deref, nir_imm_int(b, 0), 1);
-   } else {
-      /* storing using a variable index */
-      nir_def *index = deref->arr.index.ssa;
-      unsigned length = glsl_get_length(nir_deref_instr_parent(deref)->type);
-
-      recursive_if_chain(b, deref, instr->src[1].ssa, clip_plane_enable, index, 0, length);
-   }
-   nir_instr_remove(&instr->instr);
-   return true;
-}
-
 /* vulkan (and some drivers) provides no concept of enabling clip planes through api,
  * so we rewrite disabled clip planes to a zero value in order to disable them
  */
@@ -172,14 +90,15 @@ lower_clip_plane_store_io(nir_builder *b, nir_intrinsic_instr *intr,
 bool
 nir_lower_clip_disable(nir_shader *shader, unsigned clip_plane_enable)
 {
+   assert(shader->info.io_lowered);
+
    /* if all user planes are enabled in API that are written in the array, always ignore;
     * this explicitly covers the 2x vec4 case
     */
    if (clip_plane_enable == u_bit_consecutive(0, shader->info.clip_distance_array_size))
       return false;
 
-   return nir_shader_intrinsics_pass(shader,
-                                     shader->info.io_lowered ? lower_clip_plane_store_io : lower_clip_plane_store,
-                                       nir_metadata_control_flow,
-                                       &clip_plane_enable);
+   return nir_shader_intrinsics_pass(shader, lower_clip_plane_store_io,
+                                     nir_metadata_control_flow,
+                                     &clip_plane_enable);
 }
diff --git a/src/compiler/nir/nir_lower_drawpixels.c b/src/compiler/nir/nir_lower_drawpixels.c
index f9aa247291957..9a7419bdf9f0b 100644
--- a/src/compiler/nir/nir_lower_drawpixels.c
+++ b/src/compiler/nir/nir_lower_drawpixels.c
@@ -27,31 +27,21 @@
 /* Lower glDrawPixels().
  *
  * This is based on the logic in st_get_drawpix_shader() in TGSI compiler.
- *
- * Run before nir_lower_io.
  */
 
 typedef struct {
    const nir_lower_drawpixels_options *options;
    nir_shader *shader;
-   nir_variable *texcoord, *texcoord_const, *scale, *bias, *tex, *pixelmap;
+   nir_variable *texcoord_const, *scale, *bias, *tex, *pixelmap;
 } lower_drawpixels_state;
 
 static nir_def *
 get_texcoord(nir_builder *b, lower_drawpixels_state *state)
 {
-   if (b->shader->info.io_lowered) {
-      nir_def *baryc =
-         nir_load_barycentric_pixel(b, 32, .interp_mode = INTERP_MODE_SMOOTH);
-      return nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
-                                         .io_semantics.location = VARYING_SLOT_TEX0);
-   }
-
-   if (state->texcoord == NULL) {
-      state->texcoord = nir_get_variable_with_location(state->shader, nir_var_shader_in,
-                                                       VARYING_SLOT_TEX0, glsl_vec4_type());
-   }
-   return nir_load_var(b, state->texcoord);
+   nir_def *baryc =
+      nir_load_barycentric_pixel(b, 32, .interp_mode = INTERP_MODE_SMOOTH);
+   return nir_load_interpolated_input(b, 4, 32, baryc, nir_imm_int(b, 0),
+                                      .io_semantics.location = VARYING_SLOT_TEX0);
 }
 
 static nir_def *
@@ -215,22 +205,6 @@ lower_drawpixels_instr(nir_builder *b, nir_instr *instr, void *cb_data)
    nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
 
    switch (intr->intrinsic) {
-   case nir_intrinsic_load_deref: {
-      nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
-      nir_variable *var = nir_deref_instr_get_variable(deref);
-
-      if (var->data.location == VARYING_SLOT_COL0) {
-         /* gl_Color should not have array/struct derefs: */
-         assert(deref->deref_type == nir_deref_type_var);
-         return lower_color(b, state, intr);
-      } else if (var->data.location == VARYING_SLOT_TEX0) {
-         /* gl_TexCoord should not have array/struct derefs: */
-         assert(deref->deref_type == nir_deref_type_var);
-         return lower_texcoord(b, state, intr);
-      }
-      break;
-   }
-
    case nir_intrinsic_load_color0:
       return lower_color(b, state, intr);
 
@@ -253,6 +227,8 @@ bool
 nir_lower_drawpixels(nir_shader *shader,
                      const nir_lower_drawpixels_options *options)
 {
+   assert(shader->info.io_lowered);
+
    lower_drawpixels_state state = {
       .options = options,
       .shader = shader,
diff --git a/src/compiler/nir/nir_lower_flatshade.c b/src/compiler/nir/nir_lower_flatshade.c
index 089f461dc622a..6f3434f1f5e73 100644
--- a/src/compiler/nir/nir_lower_flatshade.c
+++ b/src/compiler/nir/nir_lower_flatshade.c
@@ -33,15 +33,6 @@ check_location(int location)
           location == VARYING_SLOT_BFC1;
 }
 
-static bool
-lower_input(nir_shader *shader, nir_variable *var)
-{
-   if (var->data.interpolation == INTERP_MODE_NONE &&
-       check_location(var->data.location))
-      var->data.interpolation = INTERP_MODE_FLAT;
-   return true;
-}
-
 static bool
 lower_input_io(nir_builder *b, nir_intrinsic_instr *intr, void *data)
 {
@@ -62,21 +53,11 @@ lower_input_io(nir_builder *b, nir_intrinsic_instr *intr, void *data)
    nir_def_replace(&intr->def, load);
    return true;
 }
+
 bool
 nir_lower_flatshade(nir_shader *shader)
 {
-   bool progress = false;
-
-   if (shader->info.io_lowered) {
-      progress = nir_shader_intrinsics_pass(shader, lower_input_io,
-                                            nir_metadata_all, NULL);
-   } else {
-      nir_foreach_shader_in_variable(var, shader) {
-         progress |= lower_input(shader, var);
-      }
-   }
-
-   /* Interpolation doesn't affect any metadata */
-   nir_shader_preserve_all_metadata(shader);
-   return progress;
+   assert(shader->info.io_lowered);
+   return nir_shader_intrinsics_pass(shader, lower_input_io, nir_metadata_all,
+                                     NULL);
 }
diff --git a/src/compiler/nir/nir_lower_passthrough_edgeflags.c b/src/compiler/nir/nir_lower_passthrough_edgeflags.c
index 89c3bd0e6ef99..09347a10fe6ef 100644
--- a/src/compiler/nir/nir_lower_passthrough_edgeflags.c
+++ b/src/compiler/nir/nir_lower_passthrough_edgeflags.c
@@ -28,11 +28,7 @@ static void
 lower_impl(nir_function_impl *impl)
 {
    nir_shader *shader = impl->function->shader;
-   nir_builder b;
-   nir_variable *in, *out;
-   nir_def *def;
-
-   b = nir_builder_at(nir_before_impl(impl));
+   nir_builder b = nir_builder_at(nir_before_impl(impl));
 
    /* The edge flag is the last input in st/mesa.  This code is also called by
     * i965 which calls it before any input locations are assigned.
@@ -40,36 +36,18 @@ lower_impl(nir_function_impl *impl)
    assert(shader->num_inputs == 0 ||
           shader->num_inputs == util_bitcount64(shader->info.inputs_read));
 
-   /* Lowered IO only uses intrinsics. It doesn't use variables. */
-   if (shader->info.io_lowered) {
-      assert(shader->num_outputs ==
-             util_bitcount64(shader->info.outputs_written));
-
-      /* Load an edge flag. */
-      nir_def *load =
-         nir_load_input(&b, 1, 32, nir_imm_int(&b, 0),
-                        .base = shader->num_inputs++,
-                        .io_semantics.location = VERT_ATTRIB_EDGEFLAG);
-
-      /* Store an edge flag. */
-      nir_store_output(&b, load, nir_imm_int(&b, 0),
-                       .base = shader->num_outputs++,
-                       .io_semantics.location = VARYING_SLOT_EDGE);
-
-      nir_metadata_preserve(impl, nir_metadata_control_flow);
-      return;
-   }
-
-   in = nir_create_variable_with_location(b.shader, nir_var_shader_in,
-                                          VERT_ATTRIB_EDGEFLAG, glsl_vec4_type());
-   shader->info.inputs_read |= VERT_BIT_EDGEFLAG;
+   assert(shader->num_outputs ==
+          util_bitcount64(shader->info.outputs_written));
 
-   out = nir_create_variable_with_location(b.shader, nir_var_shader_out,
-                                           VARYING_SLOT_EDGE, glsl_vec4_type());
-   shader->info.outputs_written |= VARYING_BIT_EDGE;
+   /* Load an edge flag. */
+   nir_def *load = nir_load_input(&b, 1, 32, nir_imm_int(&b, 0),
+                                  .base = shader->num_inputs++,
+                                  .io_semantics.location = VERT_ATTRIB_EDGEFLAG);
 
-   def = nir_load_var(&b, in);
-   nir_store_var(&b, out, def, 0xf);
+   /* Store an edge flag. */
+   nir_store_output(&b, load, nir_imm_int(&b, 0),
+                    .base = shader->num_outputs++,
+                    .io_semantics.location = VARYING_SLOT_EDGE);
 
    nir_metadata_preserve(impl, nir_metadata_control_flow);
 }
@@ -78,6 +56,7 @@ bool
 nir_lower_passthrough_edgeflags(nir_shader *shader)
 {
    assert(shader->info.stage == MESA_SHADER_VERTEX);
+   assert(shader->info.io_lowered);
 
    shader->info.vs.needs_edge_flag = true;
 
diff --git a/src/compiler/nir/nir_lower_pntc_ytransform.c b/src/compiler/nir/nir_lower_pntc_ytransform.c
index e3addeb2a4258..7b641531b08bf 100644
--- a/src/compiler/nir/nir_lower_pntc_ytransform.c
+++ b/src/compiler/nir/nir_lower_pntc_ytransform.c
@@ -97,12 +97,9 @@ lower_pntc_ytransform_block(lower_pntc_ytransform_state *state,
             nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
             nir_variable *var = nir_deref_instr_get_variable(deref);
 
-            if ((var->data.mode == nir_var_shader_in &&
-                 var->data.location == VARYING_SLOT_PNTC) ||
-                (var->data.mode == nir_var_system_value &&
-                 var->data.location == SYSTEM_VALUE_POINT_COORD)) {
+            if (var->data.mode == nir_var_system_value &&
+                var->data.location == SYSTEM_VALUE_POINT_COORD)
                lower_load_pointcoord(state, intr);
-            }
          }
 
          if (intr->intrinsic == nir_intrinsic_load_interpolated_input &&
@@ -116,6 +113,8 @@ bool
 nir_lower_pntc_ytransform(nir_shader *shader,
                           const gl_state_index16 pntc_state_tokens[][STATE_LENGTH])
 {
+   assert(shader->info.io_lowered);
+
    if (!shader->options->lower_wpos_pntc)
       return false;
 
diff --git a/src/compiler/nir/nir_lower_point_size_mov.c b/src/compiler/nir/nir_lower_point_size_mov.c
index fff6679970179..952e17a7caa2f 100644
--- a/src/compiler/nir/nir_lower_point_size_mov.c
+++ b/src/compiler/nir/nir_lower_point_size_mov.c
@@ -36,27 +36,8 @@ lower_point_size_mov_after(nir_builder *b, nir_variable *in)
 {
    nir_def *load = nir_load_var(b, in);
    load = nir_fclamp(b, nir_channel(b, load, 0), nir_channel(b, load, 1), nir_channel(b, load, 2));
-   if (b->shader->info.io_lowered) {
-      nir_store_output(b, load, nir_imm_int(b, 0),
-                       .io_semantics.location = VARYING_SLOT_PSIZ);
-   } else {
-      nir_variable *out = NULL;
-      /* the existing output can't be removed in order to avoid breaking xfb.
-       * drivers must check var->data.explicit_location to find the original output
-       * and only emit that one for xfb
-       */
-      nir_foreach_shader_out_variable(var, b->shader) {
-         if (var->data.location == VARYING_SLOT_PSIZ && !var->data.explicit_location) {
-            out = var;
-            break;
-         }
-      }
-      if (!out) {
-         out = nir_create_variable_with_location(b->shader, nir_var_shader_out,
-                                                 VARYING_SLOT_PSIZ, glsl_float_type());
-      }
-      nir_store_var(b, out, load, 0x1);
-   }
+   nir_store_output(b, load, nir_imm_int(b, 0),
+                    .io_semantics.location = VARYING_SLOT_PSIZ);
 }
 
 static bool
@@ -73,11 +54,6 @@ lower_point_size_mov(nir_builder *b, nir_intrinsic_instr *intr, void *data)
          return false;
       break;
    }
-   case nir_intrinsic_store_deref:
-      var = nir_intrinsic_get_var(intr, 0);
-      if (var->data.location != VARYING_SLOT_PSIZ)
-         return false;
-      break;
    default:
       return false;
    }
@@ -94,7 +70,7 @@ nir_lower_point_size_mov(nir_shader *shader,
 {
    assert(shader->info.stage != MESA_SHADER_FRAGMENT &&
           shader->info.stage != MESA_SHADER_COMPUTE);
-
+   assert(shader->info.io_lowered);
 
    bool progress = false;
    nir_metadata preserved = nir_metadata_control_flow;
diff --git a/src/compiler/nir/nir_lower_two_sided_color.c b/src/compiler/nir/nir_lower_two_sided_color.c
index 63d1ebef5eb43..e6c1834c92473 100644
--- a/src/compiler/nir/nir_lower_two_sided_color.c
+++ b/src/compiler/nir/nir_lower_two_sided_color.c
@@ -33,10 +33,6 @@ typedef struct {
    nir_builder b;
    nir_shader *shader;
    bool face_sysval;
-   struct {
-      nir_variable *front; /* COLn */
-      nir_variable *back;  /* BFCn */
-   } colors[MAX_COLORS];
    int colors_count;
 } lower_2side_state;
 
@@ -45,19 +41,6 @@ typedef struct {
  * instruction used to select front or back color based on FACE.
  */
 
-static nir_variable *
-create_input(nir_shader *shader, gl_varying_slot slot,
-             enum glsl_interp_mode interpolation)
-{
-   nir_variable *var = nir_create_variable_with_location(shader, nir_var_shader_in,
-                                                         slot, glsl_vec4_type());
-
-   var->data.index = 0;
-   var->data.interpolation = interpolation;
-
-   return var;
-}
-
 static nir_def *
 load_input(nir_builder *b, nir_intrinsic_instr *intr, int location)
 {
@@ -79,42 +62,8 @@ load_input(nir_builder *b, nir_intrinsic_instr *intr, int location)
 static int
 setup_inputs(lower_2side_state *state)
 {
-   if (state->shader->info.io_lowered) {
-      state->colors_count = util_bitcount64(state->shader->info.inputs_read & (VARYING_BIT_COL0 | VARYING_BIT_COL1));
-      return state->colors_count ? 0 : -1;
-   }
-
-   /* find color inputs: */
-   nir_foreach_shader_in_variable(var, state->shader) {
-      switch (var->data.location) {
-      case VARYING_SLOT_COL0:
-      case VARYING_SLOT_COL1:
-         assert(state->colors_count < ARRAY_SIZE(state->colors));
-         state->colors[state->colors_count].front = var;
-         state->colors_count++;
-         break;
-      }
-   }
-
-   /* if we don't have any color inputs, nothing to do: */
-   if (state->colors_count == 0)
-      return -1;
-
-   /* add required back-face color inputs: */
-   for (int i = 0; i < state->colors_count; i++) {
-      gl_varying_slot slot;
-
-      if (state->colors[i].front->data.location == VARYING_SLOT_COL0)
-         slot = VARYING_SLOT_BFC0;
-      else
-         slot = VARYING_SLOT_BFC1;
-
-      state->colors[i].back = create_input(
-         state->shader, slot,
-         state->colors[i].front->data.interpolation);
-   }
-
-   return 0;
+   state->colors_count = util_bitcount64(state->shader->info.inputs_read & (VARYING_BIT_COL0 | VARYING_BIT_COL1));
+   return state->colors_count ? 0 : -1;
 }
 
 static bool
@@ -132,18 +81,6 @@ nir_lower_two_sided_color_instr(nir_builder *b, nir_instr *instr, void *data)
       if (sem.location != VARYING_SLOT_COL0 && sem.location != VARYING_SLOT_COL1)
          return false;
       idx = sem.location;
-   } else if (intr->intrinsic == nir_intrinsic_load_deref) {
-      nir_variable *var = nir_intrinsic_get_var(intr, 0);
-      if (var->data.mode != nir_var_shader_in)
-         return false;
-
-      for (idx = 0; idx < state->colors_count; idx++) {
-         unsigned loc = state->colors[idx].front->data.location;
-         if (var->data.location == loc)
-            break;
-      }
-      if (idx == state->colors_count)
-         return false;
    } else
       return false;
 
@@ -159,27 +96,14 @@ nir_lower_two_sided_color_instr(nir_builder *b, nir_instr *instr, void *data)
    if (state->face_sysval)
       face = nir_load_front_face(b, 1);
    else {
-      if (b->shader->info.io_lowered) {
-         face = nir_load_input(b, 1, 32, nir_imm_int(b, 0), .base = 0,
-                               .dest_type = nir_type_bool32,
-                               .io_semantics.location = VARYING_SLOT_FACE);
-         face = nir_b2b1(b, face);
-      } else {
-         nir_variable *var = nir_get_variable_with_location(b->shader, nir_var_shader_in,
-                                                            VARYING_SLOT_FACE, glsl_bool_type());
-         var->data.interpolation = INTERP_MODE_FLAT;
-         face = nir_load_var(b, var);
-      }
+      face = nir_load_input(b, 1, 32, nir_imm_int(b, 0), .base = 0,
+                            .dest_type = nir_type_bool32,
+                            .io_semantics.location = VARYING_SLOT_FACE);
+      face = nir_b2b1(b, face);
    }
 
-   nir_def *front, *back;
-   if (intr->intrinsic == nir_intrinsic_load_deref) {
-      front = nir_load_var(b, state->colors[idx].front);
-      back = nir_load_var(b, state->colors[idx].back);
-   } else {
-      front = load_input(b, intr, idx);
-      back = load_input(b, intr, idx == VARYING_SLOT_COL0 ? VARYING_SLOT_BFC0 : VARYING_SLOT_BFC1);
-   }
+   nir_def *front = load_input(b, intr, idx);
+   nir_def *back = load_input(b, intr, idx == VARYING_SLOT_COL0 ? VARYING_SLOT_BFC0 : VARYING_SLOT_BFC1);
    nir_def *color = nir_bcsel(b, face, front, back);
 
    nir_def_rewrite_uses(&intr->def, color);
@@ -190,6 +114,8 @@ nir_lower_two_sided_color_instr(nir_builder *b, nir_instr *instr, void *data)
 bool
 nir_lower_two_sided_color(nir_shader *shader, bool face_sysval)
 {
+   assert(shader->info.io_lowered);
+
    lower_2side_state state = {
       .shader = shader,
       .face_sysval = face_sysval,
diff --git a/src/compiler/nir/nir_lower_wpos_ytransform.c b/src/compiler/nir/nir_lower_wpos_ytransform.c
index 517483f9d560e..be77c6621de61 100644
--- a/src/compiler/nir/nir_lower_wpos_ytransform.c
+++ b/src/compiler/nir/nir_lower_wpos_ytransform.c
@@ -280,10 +280,8 @@ lower_wpos_ytransform_instr(nir_builder *b, nir_intrinsic_instr *intr,
    case nir_intrinsic_load_deref: {
       nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
       nir_variable *var = nir_deref_instr_get_variable(deref);
-      if ((var->data.mode == nir_var_shader_in &&
-           var->data.location == VARYING_SLOT_POS) ||
-          (var->data.mode == nir_var_system_value &&
-           var->data.location == SYSTEM_VALUE_FRAG_COORD)) {
+      if (var->data.mode == nir_var_system_value &&
+          var->data.location == SYSTEM_VALUE_FRAG_COORD) {
          /* gl_FragCoord should not have array/struct derefs: */
          return lower_fragcoord(state, intr);
       } else if (var->data.mode == nir_var_system_value &&
@@ -319,6 +317,8 @@ bool
 nir_lower_wpos_ytransform(nir_shader *shader,
                           const nir_lower_wpos_ytransform_options *options)
 {
+   assert(shader->info.io_lowered);
+
    lower_wpos_ytransform_state state = {
       .options = options,
    };
diff --git a/src/mesa/state_tracker/st_nir_lower_fog.c b/src/mesa/state_tracker/st_nir_lower_fog.c
index 6901d2418f37b..b5c56761e8af0 100644
--- a/src/mesa/state_tracker/st_nir_lower_fog.c
+++ b/src/mesa/state_tracker/st_nir_lower_fog.c
@@ -11,19 +11,10 @@ static nir_def *
 fog_result(nir_builder *b, nir_def *color, enum gl_fog_mode fog_mode, struct gl_program_parameter_list *paramList)
 {
    nir_shader *s = b->shader;
-   nir_def *fogc;
-
-   if (b->shader->info.io_lowered) {
-      nir_def *baryc = nir_load_barycentric_pixel(b, 32,
-                                                  .interp_mode = INTERP_MODE_SMOOTH);
-      fogc = nir_load_interpolated_input(b, 1, 32, baryc, nir_imm_int(b, 0),
-                                         .io_semantics.location = VARYING_SLOT_FOGC);
-   } else {
-      nir_variable *fogc_var =
-         nir_create_variable_with_location(s, nir_var_shader_in, VARYING_SLOT_FOGC, glsl_float_type());
-      s->info.inputs_read |= VARYING_BIT_FOGC;
-      fogc = nir_load_var(b, fogc_var);
-   }
+   nir_def *baryc = nir_load_barycentric_pixel(b, 32,
+                                               .interp_mode = INTERP_MODE_SMOOTH);
+   nir_def *fogc = nir_load_interpolated_input(b, 1, 32, baryc, nir_imm_int(b, 0),
+                                               .io_semantics.location = VARYING_SLOT_FOGC);
 
    static const gl_state_index16 fog_params_tokens[STATE_LENGTH] = {STATE_FOG_PARAMS_OPTIMIZED};
    static const gl_state_index16 fog_color_tokens[STATE_LENGTH] = {STATE_FOG_COLOR};
@@ -120,37 +111,13 @@ st_nir_lower_fog_instr(nir_builder *b, nir_instr *instr, void *_state)
 bool
 st_nir_lower_fog(nir_shader *s, enum gl_fog_mode fog_mode, struct gl_program_parameter_list *paramList)
 {
-   if (s->info.io_lowered) {
-      struct lower_fog_state state = {
-         .fog_mode = fog_mode,
-         .paramList = paramList,
-      };
-      nir_shader_instructions_pass(s, st_nir_lower_fog_instr,
-                                   nir_metadata_control_flow,
-                                   &state);
-   } else {
-      nir_variable *color_var = nir_find_variable_with_location(s, nir_var_shader_out, FRAG_RESULT_COLOR);
-      if (!color_var) {
-         color_var = nir_find_variable_with_location(s, nir_var_shader_out, FRAG_RESULT_DATA0);
-         /* Fog result would be undefined if we had no output color (in ARB_fragment_program) */
-         if (!color_var)
-            return false;
-      }
-
-      nir_function_impl *impl = nir_shader_get_entrypoint(s);
-      nir_builder b = nir_builder_at(nir_after_impl(impl));
-
-      /* Note: while ARB_fragment_program plus ARB_draw_buffers allows an array
-       * of result colors, prog_to_nir generates separate vars per slot so we
-       * don't have to handle that.  Fog only applies to the first color result.
-       */
-      assert(!glsl_type_is_array(color_var->type));
-
-      nir_def *color = nir_load_var(&b, color_var);
-      color = fog_result(&b, color, fog_mode, paramList);
-      nir_store_var(&b, color_var, color, 0x7);
-
-      nir_metadata_preserve(b.impl, nir_metadata_control_flow);   }
-
-   return true;
+   assert(s->info.io_lowered);
+
+   struct lower_fog_state state = {
+      .fog_mode = fog_mode,
+            .paramList = paramList,
+   };
+   return nir_shader_instructions_pass(s, st_nir_lower_fog_instr,
+                                       nir_metadata_control_flow,
+                                       &state);
 }
diff --git a/src/mesa/state_tracker/st_nir_lower_position_invariant.c b/src/mesa/state_tracker/st_nir_lower_position_invariant.c
index c57368db1b8bf..5976dd5432688 100644
--- a/src/mesa/state_tracker/st_nir_lower_position_invariant.c
+++ b/src/mesa/state_tracker/st_nir_lower_position_invariant.c
@@ -20,6 +20,7 @@ bool
 st_nir_lower_position_invariant(struct nir_shader *s, bool aos,
                                 struct gl_program_parameter_list *paramList)
 {
+   assert(s->info.io_lowered);
    nir_function_impl *impl = nir_shader_get_entrypoint(s);
    nir_builder b = nir_builder_at(nir_before_impl(impl));
 
@@ -33,17 +34,8 @@ st_nir_lower_position_invariant(struct nir_shader *s, bool aos,
    }
 
    nir_def *result;
-   nir_def *in_pos;
-
-   if (s->info.io_lowered) {
-      in_pos = nir_load_input(&b, 4, 32, nir_imm_int(&b, 0),
-                              .io_semantics.location = VERT_ATTRIB_POS);
-   } else {
-      in_pos = nir_load_var(&b, nir_get_variable_with_location(s, nir_var_shader_in,
-                                                               VERT_ATTRIB_POS,
-                                                               glsl_vec4_type()));
-      s->info.inputs_read |= VERT_BIT_POS;
-   }
+   nir_def *in_pos = nir_load_input(&b, 4, 32, nir_imm_int(&b, 0),
+                                    .io_semantics.location = VERT_ATTRIB_POS);
 
    if (aos) {
       nir_def *chans[4];
@@ -56,16 +48,8 @@ st_nir_lower_position_invariant(struct nir_shader *s, bool aos,
          result = nir_fmad(&b, mvp[i], nir_channel(&b, in_pos, i), result);
    }
 
-   if (s->info.io_lowered) {
-      nir_store_output(&b, result, nir_imm_int(&b, 0),
-                       .io_semantics.location = VARYING_SLOT_POS);
-   } else {
-      nir_store_var(&b, nir_get_variable_with_location(s, nir_var_shader_out,
-                                                       VARYING_SLOT_POS,
-                                                       glsl_vec4_type()), result, 0xf);
-      s->info.outputs_written |= VARYING_BIT_POS;
-   }
-
+   nir_store_output(&b, result, nir_imm_int(&b, 0),
+                    .io_semantics.location = VARYING_SLOT_POS);
    nir_metadata_preserve(b.impl, nir_metadata_control_flow);
 
    return true;
-- 
GitLab


From ed451943d769f11a8c9b64457ecfb1b89939e34e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 25 Dec 2024 03:51:28 -0500
Subject: [PATCH 33/33] glsl: remove unused code

Reviewed-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/glsl/glsl_symbol_table.cpp | 17 -----
 src/compiler/glsl/glsl_symbol_table.h   |  7 --
 src/compiler/glsl/ir.cpp                | 49 -------------
 src/compiler/glsl/ir.h                  | 50 +------------
 src/compiler/glsl/ir_builder.cpp        | 94 -------------------------
 src/compiler/glsl/ir_builder.h          | 16 -----
 src/compiler/glsl_types.h               | 12 ----
 7 files changed, 2 insertions(+), 243 deletions(-)

diff --git a/src/compiler/glsl/glsl_symbol_table.cpp b/src/compiler/glsl/glsl_symbol_table.cpp
index 1325a27400763..84752b2ecda8e 100644
--- a/src/compiler/glsl/glsl_symbol_table.cpp
+++ b/src/compiler/glsl/glsl_symbol_table.cpp
@@ -232,13 +232,6 @@ const glsl_type *glsl_symbol_table::get_type(const char *name)
    return entry != NULL ? entry->t : NULL;
 }
 
-const glsl_type *glsl_symbol_table::get_interface(const char *name,
-                                                  enum ir_variable_mode mode)
-{
-   symbol_table_entry *entry = get_entry(name);
-   return entry != NULL ? entry->get_interface(mode) : NULL;
-}
-
 ir_function *glsl_symbol_table::get_function(const char *name)
 {
    symbol_table_entry *entry = get_entry(name);
@@ -274,13 +267,3 @@ glsl_symbol_table::disable_variable(const char *name)
       entry->v = NULL;
    }
 }
-
-void
-glsl_symbol_table::replace_variable(const char *name,
-                                    ir_variable *v)
-{
-   symbol_table_entry *entry = get_entry(name);
-   if (entry != NULL) {
-      entry->v = v;
-   }
-}
diff --git a/src/compiler/glsl/glsl_symbol_table.h b/src/compiler/glsl/glsl_symbol_table.h
index 5acd3fe40c116..506ccffa1b31d 100644
--- a/src/compiler/glsl/glsl_symbol_table.h
+++ b/src/compiler/glsl/glsl_symbol_table.h
@@ -82,8 +82,6 @@ struct glsl_symbol_table {
    ir_variable *get_variable(const char *name);
    const glsl_type *get_type(const char *name);
    ir_function *get_function(const char *name);
-   const glsl_type *get_interface(const char *name,
-                                  enum ir_variable_mode mode);
    int get_default_precision_qualifier(const char *type_name);
    /*@}*/
 
@@ -95,11 +93,6 @@ struct glsl_symbol_table {
     */
    void disable_variable(const char *name);
 
-   /**
-    * Replaces the variable in the entry by the new variable.
-    */
-   void replace_variable(const char *name, ir_variable *v);
-
 private:
    symbol_table_entry *get_entry(const char *name);
 
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index 607ead44106c5..da0e3fc2cfb19 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -44,11 +44,6 @@ bool ir_rvalue::is_one() const
    return false;
 }
 
-bool ir_rvalue::is_negative_one() const
-{
-   return false;
-}
-
 /**
  * Modify the swizzle make to move one component to another
  *
@@ -659,16 +654,6 @@ depth_layout_string(ir_depth_layout layout)
    }
 }
 
-ir_expression_operation
-ir_expression::get_operator(const char *str)
-{
-   for (int op = 0; op <= int(ir_last_opcode); op++) {
-      if (strcmp(str, ir_expression_operation_strings[op]) == 0)
-	 return (ir_expression_operation) op;
-   }
-   return (ir_expression_operation) -1;
-}
-
 ir_variable *
 ir_expression::variable_referenced() const
 {
@@ -1633,21 +1618,6 @@ ir_constant::is_one() const
    return is_value(1.0, 1);
 }
 
-bool
-ir_constant::is_negative_one() const
-{
-   return is_value(-1.0, -1);
-}
-
-bool
-ir_constant::is_uint16_constant() const
-{
-   if (!glsl_type_is_integer_32(type))
-      return false;
-
-   return value.u[0] < (1 << 16);
-}
-
 ir_loop::ir_loop()
    : ir_instruction(ir_type_loop)
 {
@@ -1771,18 +1741,6 @@ const char *ir_texture::opcode_string()
    return tex_opcode_strs[op];
 }
 
-ir_texture_opcode
-ir_texture::get_opcode(const char *str)
-{
-   const int count = sizeof(tex_opcode_strs) / sizeof(tex_opcode_strs[0]);
-   for (int op = 0; op < count; op++) {
-      if (strcmp(str, tex_opcode_strs[op]) == 0)
-	 return (ir_texture_opcode) op;
-   }
-   return (ir_texture_opcode) -1;
-}
-
-
 void
 ir_texture::set_sampler(ir_dereference *sampler, const glsl_type *type)
 {
@@ -2095,13 +2053,6 @@ ir_variable::enable_extension_warning(const char *extension)
    this->data.warn_extension_index = 0;
 }
 
-const char *
-ir_variable::get_extension_warning() const
-{
-   return this->data.warn_extension_index == 0
-      ? NULL : warn_extension_table[this->data.warn_extension_index];
-}
-
 ir_function_signature::ir_function_signature(const glsl_type *return_type,
                                              builtin_available_predicate b)
    : ir_instruction(ir_type_function_signature),
diff --git a/src/compiler/glsl/ir.h b/src/compiler/glsl/ir.h
index ed71a57548e2b..79b70db6a7aba 100644
--- a/src/compiler/glsl/ir.h
+++ b/src/compiler/glsl/ir.h
@@ -270,7 +270,7 @@ public:
     * for vector and scalar types that have all elements set to the value
     * zero (or \c false for booleans).
     *
-    * \sa ir_constant::has_value, ir_rvalue::is_one, ir_rvalue::is_negative_one
+    * \sa ir_constant::has_value, ir_rvalue::is_one
     */
    virtual bool is_zero() const;
 
@@ -282,30 +282,10 @@ public:
     * for vector and scalar types that have all elements set to the value
     * one (or \c true for booleans).
     *
-    * \sa ir_constant::has_value, ir_rvalue::is_zero, ir_rvalue::is_negative_one
+    * \sa ir_constant::has_value, ir_rvalue::is_zero
     */
    virtual bool is_one() const;
 
-   /**
-    * Determine if an r-value has the value negative one
-    *
-    * The base implementation of this function always returns \c false.  The
-    * \c ir_constant class over-rides this function to return \c true \b only
-    * for vector and scalar types that have all elements set to the value
-    * negative one.  For boolean types, the result is always \c false.
-    *
-    * \sa ir_constant::has_value, ir_rvalue::is_zero, ir_rvalue::is_one
-    */
-   virtual bool is_negative_one() const;
-
-   /**
-    * Determine if an r-value is an unsigned integer constant which can be
-    * stored in 16 bits.
-    *
-    * \sa ir_constant::is_uint16_constant.
-    */
-   virtual bool is_uint16_constant() const { return false; }
-
    /**
     * Return a generic value of error_type.
     *
@@ -610,13 +590,6 @@ public:
     */
    void enable_extension_warning(const char *extension);
 
-   /**
-    * Get the extension warning string for this variable
-    *
-    * If warnings are not enabled, \c NULL is returned.
-    */
-   const char *get_extension_warning() const;
-
    /**
     * Declared type of the variable
     */
@@ -1601,11 +1574,6 @@ public:
              operation == ir_quadop_vector;
    }
 
-   /**
-    * Do a reverse-lookup to translate the given string into an operator.
-    */
-   static ir_expression_operation get_operator(const char *);
-
    virtual void accept(ir_visitor *v)
    {
       v->visit(this);
@@ -1925,11 +1893,6 @@ public:
    /** Set the sampler and type. */
    void set_sampler(ir_dereference *sampler, const glsl_type *type);
 
-   /**
-    * Do a reverse-lookup to translate a string into an ir_texture_opcode.
-    */
-   static ir_texture_opcode get_opcode(const char *);
-
    enum ir_texture_opcode op;
 
    /** Sampler to use for the texture access. */
@@ -2332,15 +2295,6 @@ public:
    virtual bool is_value(float f, int i) const;
    virtual bool is_zero() const;
    virtual bool is_one() const;
-   virtual bool is_negative_one() const;
-
-   /**
-    * Return true for constants that could be stored as 16-bit unsigned values.
-    *
-    * Note that this will return true even for signed integer ir_constants, as
-    * long as the value is non-negative and fits in 16-bits.
-    */
-   virtual bool is_uint16_constant() const;
 
    /**
     * Value of the constant.
diff --git a/src/compiler/glsl/ir_builder.cpp b/src/compiler/glsl/ir_builder.cpp
index 6894a1224b54a..e4fd703bba64b 100644
--- a/src/compiler/glsl/ir_builder.cpp
+++ b/src/compiler/glsl/ir_builder.cpp
@@ -98,30 +98,6 @@ swizzle_for_size(operand a, unsigned components)
    return new(mem_ctx) ir_swizzle(a.val, s, components);
 }
 
-ir_swizzle *
-swizzle_xxxx(operand a)
-{
-   return swizzle(a, SWIZZLE_XXXX, 4);
-}
-
-ir_swizzle *
-swizzle_yyyy(operand a)
-{
-   return swizzle(a, SWIZZLE_YYYY, 4);
-}
-
-ir_swizzle *
-swizzle_zzzz(operand a)
-{
-   return swizzle(a, SWIZZLE_ZZZZ, 4);
-}
-
-ir_swizzle *
-swizzle_wwww(operand a)
-{
-   return swizzle(a, SWIZZLE_WWWW, 4);
-}
-
 ir_swizzle *
 swizzle_x(operand a)
 {
@@ -146,24 +122,6 @@ swizzle_w(operand a)
    return swizzle(a, SWIZZLE_WWWW, 1);
 }
 
-ir_swizzle *
-swizzle_xy(operand a)
-{
-   return swizzle(a, SWIZZLE_XYZW, 2);
-}
-
-ir_swizzle *
-swizzle_xyz(operand a)
-{
-   return swizzle(a, SWIZZLE_XYZW, 3);
-}
-
-ir_swizzle *
-swizzle_xyzw(operand a)
-{
-   return swizzle(a, SWIZZLE_XYZW, 4);
-}
-
 ir_expression *
 expr(ir_expression_operation op, operand a)
 {
@@ -213,11 +171,6 @@ ir_expression *mul(operand a, operand b)
    return expr(ir_binop_mul, a, b);
 }
 
-ir_expression *imul_high(operand a, operand b)
-{
-   return expr(ir_binop_imul_high, a, b);
-}
-
 ir_expression *div(operand a, operand b)
 {
    return expr(ir_binop_div, a, b);
@@ -243,11 +196,6 @@ ir_expression *round_even(operand a)
    return expr(ir_unop_round_even, a);
 }
 
-ir_expression *fract(operand a)
-{
-   return expr(ir_unop_fract, a);
-}
-
 /* dot for vectors, mul for scalars */
 ir_expression *dot(operand a, operand b)
 {
@@ -301,12 +249,6 @@ exp(operand a)
    return expr(ir_unop_exp, a);
 }
 
-ir_expression *
-rcp(operand a)
-{
-   return expr(ir_unop_rcp, a);
-}
-
 ir_expression *
 rsq(operand a)
 {
@@ -361,12 +303,6 @@ greater(operand a, operand b)
    return expr(ir_binop_less, b, a);
 }
 
-ir_expression*
-lequal(operand a, operand b)
-{
-   return expr(ir_binop_gequal, b, a);
-}
-
 ir_expression*
 gequal(operand a, operand b)
 {
@@ -409,12 +345,6 @@ bit_or(operand a, operand b)
    return expr(ir_binop_bit_or, a, b);
 }
 
-ir_expression*
-bit_xor(operand a, operand b)
-{
-   return expr(ir_binop_bit_xor, a, b);
-}
-
 ir_expression*
 lshift(operand a, operand b)
 {
@@ -487,24 +417,12 @@ bitcast_u2f(operand a)
    return expr(ir_unop_bitcast_u2f, a);
 }
 
-ir_expression*
-i2b(operand a)
-{
-   return expr(ir_unop_i2b, a);
-}
-
 ir_expression*
 b2i(operand a)
 {
    return expr(ir_unop_b2i, a);
 }
 
-ir_expression *
-f2b(operand a)
-{
-   return expr(ir_unop_f2b, a);
-}
-
 ir_expression *
 b2f(operand a)
 {
@@ -565,18 +483,6 @@ f2d(operand a)
    return expr(ir_unop_f2d, a);
 }
 
-ir_expression *
-i2d(operand a)
-{
-   return expr(ir_unop_i2d, a);
-}
-
-ir_expression *
-u2d(operand a)
-{
-   return expr(ir_unop_u2d, a);
-}
-
 ir_expression *
 fma(operand a, operand b, operand c)
 {
diff --git a/src/compiler/glsl/ir_builder.h b/src/compiler/glsl/ir_builder.h
index f46d9257aed42..efb274a2e163a 100644
--- a/src/compiler/glsl/ir_builder.h
+++ b/src/compiler/glsl/ir_builder.h
@@ -125,13 +125,11 @@ ir_expression *expr(ir_expression_operation op, operand a, operand b, operand c)
 ir_expression *add(operand a, operand b);
 ir_expression *sub(operand a, operand b);
 ir_expression *mul(operand a, operand b);
-ir_expression *imul_high(operand a, operand b);
 ir_expression *div(operand a, operand b);
 ir_expression *carry(operand a, operand b);
 ir_expression *borrow(operand a, operand b);
 ir_expression *trunc(operand a);
 ir_expression *round_even(operand a);
-ir_expression *fract(operand a);
 ir_expression *dot(operand a, operand b);
 ir_expression *clamp(operand a, operand b, operand c);
 ir_expression *saturate(operand a);
@@ -140,7 +138,6 @@ ir_expression *neg(operand a);
 ir_expression *sin(operand a);
 ir_expression *cos(operand a);
 ir_expression *exp(operand a);
-ir_expression *rcp(operand a);
 ir_expression *rsq(operand a);
 ir_expression *sqrt(operand a);
 ir_expression *log(operand a);
@@ -151,7 +148,6 @@ ir_expression *equal(operand a, operand b);
 ir_expression *nequal(operand a, operand b);
 ir_expression *less(operand a, operand b);
 ir_expression *greater(operand a, operand b);
-ir_expression *lequal(operand a, operand b);
 ir_expression *gequal(operand a, operand b);
 
 ir_expression *logic_not(operand a);
@@ -161,7 +157,6 @@ ir_expression *logic_or(operand a, operand b);
 ir_expression *bit_not(operand a);
 ir_expression *bit_or(operand a, operand b);
 ir_expression *bit_and(operand a, operand b);
-ir_expression *bit_xor(operand a, operand b);
 ir_expression *lshift(operand a, operand b);
 ir_expression *rshift(operand a, operand b);
 
@@ -176,15 +171,11 @@ ir_expression *bitcast_u2f(operand a);
 ir_expression *i2u(operand a);
 ir_expression *u2i(operand a);
 ir_expression *b2i(operand a);
-ir_expression *i2b(operand a);
-ir_expression *f2b(operand a);
 ir_expression *b2f(operand a);
 
 ir_expression *f2f16(operand a);
 
 ir_expression *f2d(operand a);
-ir_expression *i2d(operand a);
-ir_expression *u2d(operand a);
 
 ir_expression *bitcast_d2i64(operand a);
 ir_expression *bitcast_d2u64(operand a);
@@ -211,17 +202,10 @@ ir_swizzle *swizzle(operand a, int swizzle, int components);
  */
 ir_swizzle *swizzle_for_size(operand a, unsigned components);
 
-ir_swizzle *swizzle_xxxx(operand a);
-ir_swizzle *swizzle_yyyy(operand a);
-ir_swizzle *swizzle_zzzz(operand a);
-ir_swizzle *swizzle_wwww(operand a);
 ir_swizzle *swizzle_x(operand a);
 ir_swizzle *swizzle_y(operand a);
 ir_swizzle *swizzle_z(operand a);
 ir_swizzle *swizzle_w(operand a);
-ir_swizzle *swizzle_xy(operand a);
-ir_swizzle *swizzle_xyz(operand a);
-ir_swizzle *swizzle_xyzw(operand a);
 
 ir_if *if_tree(operand condition,
                ir_instruction *then_branch);
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index ffc664f4ab457..6cbb9a8b37c57 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -535,12 +535,6 @@ glsl_type_is_struct_or_ifc(const glsl_type *t)
    return glsl_type_is_struct(t) || glsl_type_is_interface(t);
 }
 
-static inline bool
-glsl_type_is_packed(const glsl_type *t)
-{
-   return t->packed;
-}
-
 static inline bool
 glsl_type_is_16bit(const glsl_type *t)
 {
@@ -615,12 +609,6 @@ glsl_type_is_float_16_32_64(const glsl_type *t)
    return t->base_type == GLSL_TYPE_FLOAT16 || glsl_type_is_float(t) || glsl_type_is_double(t);
 }
 
-static inline bool
-glsl_type_is_float_32_64(const glsl_type *t)
-{
-   return glsl_type_is_float(t) || glsl_type_is_double(t);
-}
-
 static inline bool
 glsl_type_is_int_16_32_64(const glsl_type *t)
 {
-- 
GitLab

