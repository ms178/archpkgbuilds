From 6dffa0837d3f9a0800da003f97292e9ba60fde9d Mon Sep 17 00:00:00 2001
From: Eric Anholt <eric@anholt.net>
Date: Wed, 18 Oct 2023 08:18:46 +0200
Subject: [PATCH 1/4] glsl: Remove int64 div/mod lowering.

Most drivers that can expose GL4 were claiming the cap anyway (llvmpipe,
softpipe, zink, iris, nvc0, radeonsi, r600, freedreno, d3d12), and just
doing lowering in NIR if nessary.

crocus was only claiming the cap for gen8, but the backend compiler
enables NIR lowering regardless.

svga is the only other GL4 driver that didn't set it, and we can just set
the NIR lowering flag.
---
 docs/gallium/screen.rst                       |    2 -
 src/compiler/glsl/builtin_functions.cpp       |   22 -
 src/compiler/glsl/builtin_int64.h             | 1140 -----------------
 src/compiler/glsl/generate_ir.cpp             |   33 -
 src/compiler/glsl/int64.glsl                  |   99 --
 src/compiler/glsl/ir_optimization.h           |    7 -
 src/compiler/glsl/lower_int64.cpp             |  379 ------
 src/compiler/glsl/meson.build                 |    3 -
 src/compiler/glsl/tests/lower_int64_test.cpp  |  443 -------
 src/compiler/glsl/tests/meson.build           |    1 -
 src/gallium/auxiliary/util/u_screen.c         |    1 -
 src/gallium/drivers/crocus/crocus_screen.c    |    1 -
 src/gallium/drivers/d3d12/d3d12_screen.cpp    |    1 -
 .../drivers/freedreno/freedreno_screen.c      |    1 -
 src/gallium/drivers/iris/iris_screen.c        |    1 -
 src/gallium/drivers/llvmpipe/lp_screen.c      |    1 -
 .../drivers/nouveau/nv30/nv30_screen.c        |    1 -
 .../drivers/nouveau/nvc0/nvc0_screen.c        |    1 -
 src/gallium/drivers/r600/r600_pipe.c          |    5 -
 src/gallium/drivers/radeonsi/si_get.c         |    1 -
 src/gallium/drivers/softpipe/sp_screen.c      |    1 -
 src/gallium/drivers/svga/svga_screen.c        |    2 +-
 src/gallium/drivers/zink/zink_screen.c        |    1 -
 src/gallium/include/pipe/p_defines.h          |    1 -
 src/mesa/state_tracker/st_glsl_to_nir.cpp     |    3 -
 25 files changed, 1 insertion(+), 2150 deletions(-)
 delete mode 100644 src/compiler/glsl/builtin_int64.h
 delete mode 100644 src/compiler/glsl/generate_ir.cpp
 delete mode 100644 src/compiler/glsl/int64.glsl
 delete mode 100644 src/compiler/glsl/lower_int64.cpp
 delete mode 100644 src/compiler/glsl/tests/lower_int64_test.cpp

diff --git a/docs/gallium/screen.rst b/docs/gallium/screen.rst
index 5de2c52deb216..d1105eef8243a 100644
--- a/docs/gallium/screen.rst
+++ b/docs/gallium/screen.rst
@@ -429,8 +429,6 @@ The integer capabilities:
 * ``PIPE_CAP_DOUBLES``: Whether double precision floating-point operations
   are supported.
 * ``PIPE_CAP_INT64``: Whether 64-bit integer operations are supported.
-* ``PIPE_CAP_INT64_DIVMOD``: Whether 64-bit integer division/modulo
-  operations are supported.
 * ``PIPE_CAP_TGSI_TEX_TXF_LZ``: Whether TEX_LZ and TXF_LZ opcodes are
   supported.
 * ``PIPE_CAP_SHADER_CLOCK``: Whether the CLOCK opcode is supported.
diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index a141b8789ed9b..0382ae1c46022 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -827,12 +827,6 @@ vote_or_v460_desktop(const _mesa_glsl_parse_state *state)
    return state->EXT_shader_group_vote_enable || state->ARB_shader_group_vote_enable || v460_desktop(state);
 }
 
-static bool
-integer_functions_supported(const _mesa_glsl_parse_state *state)
-{
-   return state->extensions->MESA_shader_integer_functions;
-}
-
 static bool
 NV_shader_atomic_float_supported(const _mesa_glsl_parse_state *state)
 {
@@ -5193,22 +5187,6 @@ builtin_builder::create_builtins()
 
    add_function("helperInvocationEXT", _helper_invocation(), NULL);
 
-   add_function("__builtin_idiv64",
-                generate_ir::idiv64(mem_ctx, integer_functions_supported),
-                NULL);
-
-   add_function("__builtin_imod64",
-                generate_ir::imod64(mem_ctx, integer_functions_supported),
-                NULL);
-
-   add_function("__builtin_udiv64",
-                generate_ir::udiv64(mem_ctx, integer_functions_supported),
-                NULL);
-
-   add_function("__builtin_umod64",
-                generate_ir::umod64(mem_ctx, integer_functions_supported),
-                NULL);
-
    add_function("countLeadingZeros",
                 _countLeadingZeros(shader_integer_functions2,
                                    glsl_type::uint_type),
diff --git a/src/compiler/glsl/builtin_int64.h b/src/compiler/glsl/builtin_int64.h
deleted file mode 100644
index 40e2c1cfd2ae8..0000000000000
--- a/src/compiler/glsl/builtin_int64.h
+++ /dev/null
@@ -1,1140 +0,0 @@
-ir_function_signature *
-udivmod64(void *mem_ctx, builtin_available_predicate avail)
-{
-   ir_function_signature *const sig =
-      new(mem_ctx) ir_function_signature(glsl_type::uvec4_type, avail);
-   ir_factory body(&sig->body, mem_ctx);
-   sig->is_defined = true;
-
-   exec_list sig_parameters;
-
-   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "n", ir_var_function_in);
-   sig_parameters.push_tail(r000C);
-   ir_variable *const r000D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "d", ir_var_function_in);
-   sig_parameters.push_tail(r000D);
-   ir_variable *const r000E = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-   body.emit(r000E);
-   ir_variable *const r000F = new(mem_ctx) ir_variable(glsl_type::uint64_t_type, "n64", ir_var_auto);
-   body.emit(r000F);
-   ir_variable *const r0010 = new(mem_ctx) ir_variable(glsl_type::int_type, "log2_denom", ir_var_auto);
-   body.emit(r0010);
-   ir_variable *const r0011 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "quot", ir_var_auto);
-   body.emit(r0011);
-   body.emit(assign(r0011, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));
-
-   ir_expression *const r0012 = expr(ir_unop_find_msb, swizzle_y(r000D));
-   body.emit(assign(r0010, add(r0012, body.constant(int(32))), 0x01));
-
-   /* IF CONDITION */
-   ir_expression *const r0014 = equal(swizzle_y(r000D), body.constant(0u));
-   ir_expression *const r0015 = gequal(swizzle_y(r000C), swizzle_x(r000D));
-   ir_expression *const r0016 = logic_and(r0014, r0015);
-   ir_if *f0013 = new(mem_ctx) ir_if(operand(r0016).val);
-   exec_list *const f0013_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f0013->then_instructions;
-
-      ir_variable *const r0017 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-      body.emit(r0017);
-      ir_variable *const r0018 = body.make_temp(glsl_type::int_type, "findMSB_retval");
-      body.emit(assign(r0018, expr(ir_unop_find_msb, swizzle_x(r000D)), 0x01));
-
-      body.emit(assign(r0010, r0018, 0x01));
-
-      body.emit(assign(r0017, body.constant(int(31)), 0x01));
-
-      /* LOOP BEGIN */
-      ir_loop *f0019 = new(mem_ctx) ir_loop();
-      exec_list *const f0019_parent_instructions = body.instructions;
-
-         body.instructions = &f0019->body_instructions;
-
-         /* IF CONDITION */
-         ir_expression *const r001B = less(r0017, body.constant(int(1)));
-         ir_if *f001A = new(mem_ctx) ir_if(operand(r001B).val);
-         exec_list *const f001A_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f001A->then_instructions;
-
-            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-         body.instructions = f001A_parent_instructions;
-         body.emit(f001A);
-
-         /* END IF */
-
-         /* IF CONDITION */
-         ir_expression *const r001D = sub(body.constant(int(31)), r0017);
-         ir_expression *const r001E = lequal(r0018, r001D);
-         ir_expression *const r001F = lshift(swizzle_x(r000D), r0017);
-         ir_expression *const r0020 = lequal(r001F, swizzle_y(r000C));
-         ir_expression *const r0021 = logic_and(r001E, r0020);
-         ir_if *f001C = new(mem_ctx) ir_if(operand(r0021).val);
-         exec_list *const f001C_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f001C->then_instructions;
-
-            ir_expression *const r0022 = lshift(swizzle_x(r000D), r0017);
-            body.emit(assign(r000C, sub(swizzle_y(r000C), r0022), 0x02));
-
-            ir_expression *const r0023 = lshift(body.constant(1u), r0017);
-            body.emit(assign(r0011, bit_or(swizzle_y(r0011), r0023), 0x02));
-
-
-         body.instructions = f001C_parent_instructions;
-         body.emit(f001C);
-
-         /* END IF */
-
-         body.emit(assign(r0017, add(r0017, body.constant(int(-1))), 0x01));
-
-      /* LOOP END */
-
-      body.instructions = f0019_parent_instructions;
-      body.emit(f0019);
-
-      /* IF CONDITION */
-      ir_expression *const r0025 = lequal(swizzle_x(r000D), swizzle_y(r000C));
-      ir_if *f0024 = new(mem_ctx) ir_if(operand(r0025).val);
-      exec_list *const f0024_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0024->then_instructions;
-
-         body.emit(assign(r000C, sub(swizzle_y(r000C), swizzle_x(r000D)), 0x02));
-
-         body.emit(assign(r0011, bit_or(swizzle_y(r0011), body.constant(1u)), 0x02));
-
-
-      body.instructions = f0024_parent_instructions;
-      body.emit(f0024);
-
-      /* END IF */
-
-
-   body.instructions = f0013_parent_instructions;
-   body.emit(f0013);
-
-   /* END IF */
-
-   ir_variable *const r0026 = body.make_temp(glsl_type::uint64_t_type, "packUint2x32_retval");
-   body.emit(assign(r0026, expr(ir_unop_pack_uint_2x32, r000D), 0x01));
-
-   body.emit(assign(r000F, expr(ir_unop_pack_uint_2x32, r000C), 0x01));
-
-   body.emit(assign(r000E, body.constant(int(31)), 0x01));
-
-   /* LOOP BEGIN */
-   ir_loop *f0027 = new(mem_ctx) ir_loop();
-   exec_list *const f0027_parent_instructions = body.instructions;
-
-      body.instructions = &f0027->body_instructions;
-
-      /* IF CONDITION */
-      ir_expression *const r0029 = less(r000E, body.constant(int(1)));
-      ir_if *f0028 = new(mem_ctx) ir_if(operand(r0029).val);
-      exec_list *const f0028_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0028->then_instructions;
-
-         body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-      body.instructions = f0028_parent_instructions;
-      body.emit(f0028);
-
-      /* END IF */
-
-      /* IF CONDITION */
-      ir_expression *const r002B = sub(body.constant(int(63)), r000E);
-      ir_expression *const r002C = lequal(r0010, r002B);
-      ir_expression *const r002D = lshift(r0026, r000E);
-      ir_expression *const r002E = lequal(r002D, r000F);
-      ir_expression *const r002F = logic_and(r002C, r002E);
-      ir_if *f002A = new(mem_ctx) ir_if(operand(r002F).val);
-      exec_list *const f002A_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f002A->then_instructions;
-
-         ir_expression *const r0030 = lshift(r0026, r000E);
-         body.emit(assign(r000F, sub(r000F, r0030), 0x01));
-
-         ir_expression *const r0031 = lshift(body.constant(1u), r000E);
-         body.emit(assign(r0011, bit_or(swizzle_x(r0011), r0031), 0x01));
-
-
-      body.instructions = f002A_parent_instructions;
-      body.emit(f002A);
-
-      /* END IF */
-
-      body.emit(assign(r000E, add(r000E, body.constant(int(-1))), 0x01));
-
-   /* LOOP END */
-
-   body.instructions = f0027_parent_instructions;
-   body.emit(f0027);
-
-   /* IF CONDITION */
-   ir_expression *const r0033 = lequal(r0026, r000F);
-   ir_if *f0032 = new(mem_ctx) ir_if(operand(r0033).val);
-   exec_list *const f0032_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f0032->then_instructions;
-
-      body.emit(assign(r000F, sub(r000F, r0026), 0x01));
-
-      body.emit(assign(r0011, bit_or(swizzle_x(r0011), body.constant(1u)), 0x01));
-
-
-   body.instructions = f0032_parent_instructions;
-   body.emit(f0032);
-
-   /* END IF */
-
-   ir_variable *const r0034 = body.make_temp(glsl_type::uvec4_type, "vec_ctor");
-   body.emit(assign(r0034, r0011, 0x03));
-
-   body.emit(assign(r0034, expr(ir_unop_unpack_uint_2x32, r000F), 0x0c));
-
-   body.emit(ret(r0034));
-
-   sig->replace_parameters(&sig_parameters);
-   return sig;
-}
-ir_function_signature *
-udiv64(void *mem_ctx, builtin_available_predicate avail)
-{
-   ir_function_signature *const sig =
-      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
-   ir_factory body(&sig->body, mem_ctx);
-   sig->is_defined = true;
-
-   exec_list sig_parameters;
-
-   ir_variable *const r0035 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "n", ir_var_function_in);
-   sig_parameters.push_tail(r0035);
-   ir_variable *const r0036 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "d", ir_var_function_in);
-   sig_parameters.push_tail(r0036);
-   ir_variable *const r0037 = body.make_temp(glsl_type::uvec2_type, "n");
-   body.emit(assign(r0037, r0035, 0x03));
-
-   ir_variable *const r0038 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-   body.emit(r0038);
-   ir_variable *const r0039 = new(mem_ctx) ir_variable(glsl_type::uint64_t_type, "n64", ir_var_auto);
-   body.emit(r0039);
-   ir_variable *const r003A = new(mem_ctx) ir_variable(glsl_type::int_type, "log2_denom", ir_var_auto);
-   body.emit(r003A);
-   ir_variable *const r003B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "quot", ir_var_auto);
-   body.emit(r003B);
-   body.emit(assign(r003B, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));
-
-   ir_expression *const r003C = expr(ir_unop_find_msb, swizzle_y(r0036));
-   body.emit(assign(r003A, add(r003C, body.constant(int(32))), 0x01));
-
-   /* IF CONDITION */
-   ir_expression *const r003E = equal(swizzle_y(r0036), body.constant(0u));
-   ir_expression *const r003F = gequal(swizzle_y(r0035), swizzle_x(r0036));
-   ir_expression *const r0040 = logic_and(r003E, r003F);
-   ir_if *f003D = new(mem_ctx) ir_if(operand(r0040).val);
-   exec_list *const f003D_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f003D->then_instructions;
-
-      ir_variable *const r0041 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-      body.emit(r0041);
-      ir_variable *const r0042 = body.make_temp(glsl_type::int_type, "findMSB_retval");
-      body.emit(assign(r0042, expr(ir_unop_find_msb, swizzle_x(r0036)), 0x01));
-
-      body.emit(assign(r003A, r0042, 0x01));
-
-      body.emit(assign(r0041, body.constant(int(31)), 0x01));
-
-      /* LOOP BEGIN */
-      ir_loop *f0043 = new(mem_ctx) ir_loop();
-      exec_list *const f0043_parent_instructions = body.instructions;
-
-         body.instructions = &f0043->body_instructions;
-
-         /* IF CONDITION */
-         ir_expression *const r0045 = less(r0041, body.constant(int(1)));
-         ir_if *f0044 = new(mem_ctx) ir_if(operand(r0045).val);
-         exec_list *const f0044_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f0044->then_instructions;
-
-            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-         body.instructions = f0044_parent_instructions;
-         body.emit(f0044);
-
-         /* END IF */
-
-         /* IF CONDITION */
-         ir_expression *const r0047 = sub(body.constant(int(31)), r0041);
-         ir_expression *const r0048 = lequal(r0042, r0047);
-         ir_expression *const r0049 = lshift(swizzle_x(r0036), r0041);
-         ir_expression *const r004A = lequal(r0049, swizzle_y(r0037));
-         ir_expression *const r004B = logic_and(r0048, r004A);
-         ir_if *f0046 = new(mem_ctx) ir_if(operand(r004B).val);
-         exec_list *const f0046_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f0046->then_instructions;
-
-            ir_expression *const r004C = lshift(swizzle_x(r0036), r0041);
-            body.emit(assign(r0037, sub(swizzle_y(r0037), r004C), 0x02));
-
-            ir_expression *const r004D = lshift(body.constant(1u), r0041);
-            body.emit(assign(r003B, bit_or(swizzle_y(r003B), r004D), 0x02));
-
-
-         body.instructions = f0046_parent_instructions;
-         body.emit(f0046);
-
-         /* END IF */
-
-         body.emit(assign(r0041, add(r0041, body.constant(int(-1))), 0x01));
-
-      /* LOOP END */
-
-      body.instructions = f0043_parent_instructions;
-      body.emit(f0043);
-
-      /* IF CONDITION */
-      ir_expression *const r004F = lequal(swizzle_x(r0036), swizzle_y(r0037));
-      ir_if *f004E = new(mem_ctx) ir_if(operand(r004F).val);
-      exec_list *const f004E_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f004E->then_instructions;
-
-         body.emit(assign(r0037, sub(swizzle_y(r0037), swizzle_x(r0036)), 0x02));
-
-         body.emit(assign(r003B, bit_or(swizzle_y(r003B), body.constant(1u)), 0x02));
-
-
-      body.instructions = f004E_parent_instructions;
-      body.emit(f004E);
-
-      /* END IF */
-
-
-   body.instructions = f003D_parent_instructions;
-   body.emit(f003D);
-
-   /* END IF */
-
-   ir_variable *const r0050 = body.make_temp(glsl_type::uint64_t_type, "packUint2x32_retval");
-   body.emit(assign(r0050, expr(ir_unop_pack_uint_2x32, r0036), 0x01));
-
-   body.emit(assign(r0039, expr(ir_unop_pack_uint_2x32, r0037), 0x01));
-
-   body.emit(assign(r0038, body.constant(int(31)), 0x01));
-
-   /* LOOP BEGIN */
-   ir_loop *f0051 = new(mem_ctx) ir_loop();
-   exec_list *const f0051_parent_instructions = body.instructions;
-
-      body.instructions = &f0051->body_instructions;
-
-      /* IF CONDITION */
-      ir_expression *const r0053 = less(r0038, body.constant(int(1)));
-      ir_if *f0052 = new(mem_ctx) ir_if(operand(r0053).val);
-      exec_list *const f0052_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0052->then_instructions;
-
-         body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-      body.instructions = f0052_parent_instructions;
-      body.emit(f0052);
-
-      /* END IF */
-
-      /* IF CONDITION */
-      ir_expression *const r0055 = sub(body.constant(int(63)), r0038);
-      ir_expression *const r0056 = lequal(r003A, r0055);
-      ir_expression *const r0057 = lshift(r0050, r0038);
-      ir_expression *const r0058 = lequal(r0057, r0039);
-      ir_expression *const r0059 = logic_and(r0056, r0058);
-      ir_if *f0054 = new(mem_ctx) ir_if(operand(r0059).val);
-      exec_list *const f0054_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0054->then_instructions;
-
-         ir_expression *const r005A = lshift(r0050, r0038);
-         body.emit(assign(r0039, sub(r0039, r005A), 0x01));
-
-         ir_expression *const r005B = lshift(body.constant(1u), r0038);
-         body.emit(assign(r003B, bit_or(swizzle_x(r003B), r005B), 0x01));
-
-
-      body.instructions = f0054_parent_instructions;
-      body.emit(f0054);
-
-      /* END IF */
-
-      body.emit(assign(r0038, add(r0038, body.constant(int(-1))), 0x01));
-
-   /* LOOP END */
-
-   body.instructions = f0051_parent_instructions;
-   body.emit(f0051);
-
-   /* IF CONDITION */
-   ir_expression *const r005D = lequal(r0050, r0039);
-   ir_if *f005C = new(mem_ctx) ir_if(operand(r005D).val);
-   exec_list *const f005C_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f005C->then_instructions;
-
-      body.emit(assign(r0039, sub(r0039, r0050), 0x01));
-
-      body.emit(assign(r003B, bit_or(swizzle_x(r003B), body.constant(1u)), 0x01));
-
-
-   body.instructions = f005C_parent_instructions;
-   body.emit(f005C);
-
-   /* END IF */
-
-   body.emit(ret(r003B));
-
-   sig->replace_parameters(&sig_parameters);
-   return sig;
-}
-ir_function_signature *
-idiv64(void *mem_ctx, builtin_available_predicate avail)
-{
-   ir_function_signature *const sig =
-      new(mem_ctx) ir_function_signature(glsl_type::ivec2_type, avail);
-   ir_factory body(&sig->body, mem_ctx);
-   sig->is_defined = true;
-
-   exec_list sig_parameters;
-
-   ir_variable *const r005E = new(mem_ctx) ir_variable(glsl_type::ivec2_type, "_n", ir_var_function_in);
-   sig_parameters.push_tail(r005E);
-   ir_variable *const r005F = new(mem_ctx) ir_variable(glsl_type::ivec2_type, "_d", ir_var_function_in);
-   sig_parameters.push_tail(r005F);
-   ir_variable *const r0060 = new(mem_ctx) ir_variable(glsl_type::bool_type, "negate", ir_var_auto);
-   body.emit(r0060);
-   ir_expression *const r0061 = less(swizzle_y(r005E), body.constant(int(0)));
-   ir_expression *const r0062 = less(swizzle_y(r005F), body.constant(int(0)));
-   body.emit(assign(r0060, nequal(r0061, r0062), 0x01));
-
-   ir_variable *const r0063 = body.make_temp(glsl_type::uvec2_type, "n");
-   ir_expression *const r0064 = expr(ir_unop_pack_int_2x32, r005E);
-   ir_expression *const r0065 = expr(ir_unop_abs, r0064);
-   ir_expression *const r0066 = expr(ir_unop_i642u64, r0065);
-   body.emit(assign(r0063, expr(ir_unop_unpack_uint_2x32, r0066), 0x03));
-
-   ir_variable *const r0067 = body.make_temp(glsl_type::uvec2_type, "d");
-   ir_expression *const r0068 = expr(ir_unop_pack_int_2x32, r005F);
-   ir_expression *const r0069 = expr(ir_unop_abs, r0068);
-   ir_expression *const r006A = expr(ir_unop_i642u64, r0069);
-   body.emit(assign(r0067, expr(ir_unop_unpack_uint_2x32, r006A), 0x03));
-
-   ir_variable *const r006B = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-   body.emit(r006B);
-   ir_variable *const r006C = new(mem_ctx) ir_variable(glsl_type::uint64_t_type, "n64", ir_var_auto);
-   body.emit(r006C);
-   ir_variable *const r006D = new(mem_ctx) ir_variable(glsl_type::int_type, "log2_denom", ir_var_auto);
-   body.emit(r006D);
-   ir_variable *const r006E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "quot", ir_var_auto);
-   body.emit(r006E);
-   body.emit(assign(r006E, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));
-
-   ir_expression *const r006F = expr(ir_unop_find_msb, swizzle_y(r0067));
-   body.emit(assign(r006D, add(r006F, body.constant(int(32))), 0x01));
-
-   /* IF CONDITION */
-   ir_expression *const r0071 = equal(swizzle_y(r0067), body.constant(0u));
-   ir_expression *const r0072 = gequal(swizzle_y(r0063), swizzle_x(r0067));
-   ir_expression *const r0073 = logic_and(r0071, r0072);
-   ir_if *f0070 = new(mem_ctx) ir_if(operand(r0073).val);
-   exec_list *const f0070_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f0070->then_instructions;
-
-      ir_variable *const r0074 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-      body.emit(r0074);
-      ir_variable *const r0075 = body.make_temp(glsl_type::int_type, "findMSB_retval");
-      body.emit(assign(r0075, expr(ir_unop_find_msb, swizzle_x(r0067)), 0x01));
-
-      body.emit(assign(r006D, r0075, 0x01));
-
-      body.emit(assign(r0074, body.constant(int(31)), 0x01));
-
-      /* LOOP BEGIN */
-      ir_loop *f0076 = new(mem_ctx) ir_loop();
-      exec_list *const f0076_parent_instructions = body.instructions;
-
-         body.instructions = &f0076->body_instructions;
-
-         /* IF CONDITION */
-         ir_expression *const r0078 = less(r0074, body.constant(int(1)));
-         ir_if *f0077 = new(mem_ctx) ir_if(operand(r0078).val);
-         exec_list *const f0077_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f0077->then_instructions;
-
-            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-         body.instructions = f0077_parent_instructions;
-         body.emit(f0077);
-
-         /* END IF */
-
-         /* IF CONDITION */
-         ir_expression *const r007A = sub(body.constant(int(31)), r0074);
-         ir_expression *const r007B = lequal(r0075, r007A);
-         ir_expression *const r007C = lshift(swizzle_x(r0067), r0074);
-         ir_expression *const r007D = lequal(r007C, swizzle_y(r0063));
-         ir_expression *const r007E = logic_and(r007B, r007D);
-         ir_if *f0079 = new(mem_ctx) ir_if(operand(r007E).val);
-         exec_list *const f0079_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f0079->then_instructions;
-
-            ir_expression *const r007F = lshift(swizzle_x(r0067), r0074);
-            body.emit(assign(r0063, sub(swizzle_y(r0063), r007F), 0x02));
-
-            ir_expression *const r0080 = lshift(body.constant(1u), r0074);
-            body.emit(assign(r006E, bit_or(swizzle_y(r006E), r0080), 0x02));
-
-
-         body.instructions = f0079_parent_instructions;
-         body.emit(f0079);
-
-         /* END IF */
-
-         body.emit(assign(r0074, add(r0074, body.constant(int(-1))), 0x01));
-
-      /* LOOP END */
-
-      body.instructions = f0076_parent_instructions;
-      body.emit(f0076);
-
-      /* IF CONDITION */
-      ir_expression *const r0082 = lequal(swizzle_x(r0067), swizzle_y(r0063));
-      ir_if *f0081 = new(mem_ctx) ir_if(operand(r0082).val);
-      exec_list *const f0081_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0081->then_instructions;
-
-         body.emit(assign(r0063, sub(swizzle_y(r0063), swizzle_x(r0067)), 0x02));
-
-         body.emit(assign(r006E, bit_or(swizzle_y(r006E), body.constant(1u)), 0x02));
-
-
-      body.instructions = f0081_parent_instructions;
-      body.emit(f0081);
-
-      /* END IF */
-
-
-   body.instructions = f0070_parent_instructions;
-   body.emit(f0070);
-
-   /* END IF */
-
-   ir_variable *const r0083 = body.make_temp(glsl_type::uint64_t_type, "packUint2x32_retval");
-   body.emit(assign(r0083, expr(ir_unop_pack_uint_2x32, r0067), 0x01));
-
-   body.emit(assign(r006C, expr(ir_unop_pack_uint_2x32, r0063), 0x01));
-
-   body.emit(assign(r006B, body.constant(int(31)), 0x01));
-
-   /* LOOP BEGIN */
-   ir_loop *f0084 = new(mem_ctx) ir_loop();
-   exec_list *const f0084_parent_instructions = body.instructions;
-
-      body.instructions = &f0084->body_instructions;
-
-      /* IF CONDITION */
-      ir_expression *const r0086 = less(r006B, body.constant(int(1)));
-      ir_if *f0085 = new(mem_ctx) ir_if(operand(r0086).val);
-      exec_list *const f0085_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0085->then_instructions;
-
-         body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-      body.instructions = f0085_parent_instructions;
-      body.emit(f0085);
-
-      /* END IF */
-
-      /* IF CONDITION */
-      ir_expression *const r0088 = sub(body.constant(int(63)), r006B);
-      ir_expression *const r0089 = lequal(r006D, r0088);
-      ir_expression *const r008A = lshift(r0083, r006B);
-      ir_expression *const r008B = lequal(r008A, r006C);
-      ir_expression *const r008C = logic_and(r0089, r008B);
-      ir_if *f0087 = new(mem_ctx) ir_if(operand(r008C).val);
-      exec_list *const f0087_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f0087->then_instructions;
-
-         ir_expression *const r008D = lshift(r0083, r006B);
-         body.emit(assign(r006C, sub(r006C, r008D), 0x01));
-
-         ir_expression *const r008E = lshift(body.constant(1u), r006B);
-         body.emit(assign(r006E, bit_or(swizzle_x(r006E), r008E), 0x01));
-
-
-      body.instructions = f0087_parent_instructions;
-      body.emit(f0087);
-
-      /* END IF */
-
-      body.emit(assign(r006B, add(r006B, body.constant(int(-1))), 0x01));
-
-   /* LOOP END */
-
-   body.instructions = f0084_parent_instructions;
-   body.emit(f0084);
-
-   /* IF CONDITION */
-   ir_expression *const r0090 = lequal(r0083, r006C);
-   ir_if *f008F = new(mem_ctx) ir_if(operand(r0090).val);
-   exec_list *const f008F_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f008F->then_instructions;
-
-      body.emit(assign(r006C, sub(r006C, r0083), 0x01));
-
-      body.emit(assign(r006E, bit_or(swizzle_x(r006E), body.constant(1u)), 0x01));
-
-
-   body.instructions = f008F_parent_instructions;
-   body.emit(f008F);
-
-   /* END IF */
-
-   ir_variable *const r0091 = body.make_temp(glsl_type::ivec2_type, "conditional_tmp");
-   /* IF CONDITION */
-   ir_if *f0092 = new(mem_ctx) ir_if(operand(r0060).val);
-   exec_list *const f0092_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f0092->then_instructions;
-
-      ir_expression *const r0093 = expr(ir_unop_pack_uint_2x32, r006E);
-      ir_expression *const r0094 = expr(ir_unop_u642i64, r0093);
-      ir_expression *const r0095 = neg(r0094);
-      body.emit(assign(r0091, expr(ir_unop_unpack_int_2x32, r0095), 0x03));
-
-
-      /* ELSE INSTRUCTIONS */
-      body.instructions = &f0092->else_instructions;
-
-      body.emit(assign(r0091, expr(ir_unop_u2i, r006E), 0x03));
-
-
-   body.instructions = f0092_parent_instructions;
-   body.emit(f0092);
-
-   /* END IF */
-
-   body.emit(ret(r0091));
-
-   sig->replace_parameters(&sig_parameters);
-   return sig;
-}
-ir_function_signature *
-umod64(void *mem_ctx, builtin_available_predicate avail)
-{
-   ir_function_signature *const sig =
-      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
-   ir_factory body(&sig->body, mem_ctx);
-   sig->is_defined = true;
-
-   exec_list sig_parameters;
-
-   ir_variable *const r0096 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "n", ir_var_function_in);
-   sig_parameters.push_tail(r0096);
-   ir_variable *const r0097 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "d", ir_var_function_in);
-   sig_parameters.push_tail(r0097);
-   ir_variable *const r0098 = body.make_temp(glsl_type::uvec2_type, "n");
-   body.emit(assign(r0098, r0096, 0x03));
-
-   ir_variable *const r0099 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-   body.emit(r0099);
-   ir_variable *const r009A = new(mem_ctx) ir_variable(glsl_type::uint64_t_type, "n64", ir_var_auto);
-   body.emit(r009A);
-   ir_variable *const r009B = new(mem_ctx) ir_variable(glsl_type::int_type, "log2_denom", ir_var_auto);
-   body.emit(r009B);
-   ir_variable *const r009C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "quot", ir_var_auto);
-   body.emit(r009C);
-   body.emit(assign(r009C, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));
-
-   ir_expression *const r009D = expr(ir_unop_find_msb, swizzle_y(r0097));
-   body.emit(assign(r009B, add(r009D, body.constant(int(32))), 0x01));
-
-   /* IF CONDITION */
-   ir_expression *const r009F = equal(swizzle_y(r0097), body.constant(0u));
-   ir_expression *const r00A0 = gequal(swizzle_y(r0096), swizzle_x(r0097));
-   ir_expression *const r00A1 = logic_and(r009F, r00A0);
-   ir_if *f009E = new(mem_ctx) ir_if(operand(r00A1).val);
-   exec_list *const f009E_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f009E->then_instructions;
-
-      ir_variable *const r00A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-      body.emit(r00A2);
-      ir_variable *const r00A3 = body.make_temp(glsl_type::int_type, "findMSB_retval");
-      body.emit(assign(r00A3, expr(ir_unop_find_msb, swizzle_x(r0097)), 0x01));
-
-      body.emit(assign(r009B, r00A3, 0x01));
-
-      body.emit(assign(r00A2, body.constant(int(31)), 0x01));
-
-      /* LOOP BEGIN */
-      ir_loop *f00A4 = new(mem_ctx) ir_loop();
-      exec_list *const f00A4_parent_instructions = body.instructions;
-
-         body.instructions = &f00A4->body_instructions;
-
-         /* IF CONDITION */
-         ir_expression *const r00A6 = less(r00A2, body.constant(int(1)));
-         ir_if *f00A5 = new(mem_ctx) ir_if(operand(r00A6).val);
-         exec_list *const f00A5_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f00A5->then_instructions;
-
-            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-         body.instructions = f00A5_parent_instructions;
-         body.emit(f00A5);
-
-         /* END IF */
-
-         /* IF CONDITION */
-         ir_expression *const r00A8 = sub(body.constant(int(31)), r00A2);
-         ir_expression *const r00A9 = lequal(r00A3, r00A8);
-         ir_expression *const r00AA = lshift(swizzle_x(r0097), r00A2);
-         ir_expression *const r00AB = lequal(r00AA, swizzle_y(r0098));
-         ir_expression *const r00AC = logic_and(r00A9, r00AB);
-         ir_if *f00A7 = new(mem_ctx) ir_if(operand(r00AC).val);
-         exec_list *const f00A7_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f00A7->then_instructions;
-
-            ir_expression *const r00AD = lshift(swizzle_x(r0097), r00A2);
-            body.emit(assign(r0098, sub(swizzle_y(r0098), r00AD), 0x02));
-
-            ir_expression *const r00AE = lshift(body.constant(1u), r00A2);
-            body.emit(assign(r009C, bit_or(swizzle_y(r009C), r00AE), 0x02));
-
-
-         body.instructions = f00A7_parent_instructions;
-         body.emit(f00A7);
-
-         /* END IF */
-
-         body.emit(assign(r00A2, add(r00A2, body.constant(int(-1))), 0x01));
-
-      /* LOOP END */
-
-      body.instructions = f00A4_parent_instructions;
-      body.emit(f00A4);
-
-      /* IF CONDITION */
-      ir_expression *const r00B0 = lequal(swizzle_x(r0097), swizzle_y(r0098));
-      ir_if *f00AF = new(mem_ctx) ir_if(operand(r00B0).val);
-      exec_list *const f00AF_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f00AF->then_instructions;
-
-         body.emit(assign(r0098, sub(swizzle_y(r0098), swizzle_x(r0097)), 0x02));
-
-         body.emit(assign(r009C, bit_or(swizzle_y(r009C), body.constant(1u)), 0x02));
-
-
-      body.instructions = f00AF_parent_instructions;
-      body.emit(f00AF);
-
-      /* END IF */
-
-
-   body.instructions = f009E_parent_instructions;
-   body.emit(f009E);
-
-   /* END IF */
-
-   ir_variable *const r00B1 = body.make_temp(glsl_type::uint64_t_type, "packUint2x32_retval");
-   body.emit(assign(r00B1, expr(ir_unop_pack_uint_2x32, r0097), 0x01));
-
-   body.emit(assign(r009A, expr(ir_unop_pack_uint_2x32, r0098), 0x01));
-
-   body.emit(assign(r0099, body.constant(int(31)), 0x01));
-
-   /* LOOP BEGIN */
-   ir_loop *f00B2 = new(mem_ctx) ir_loop();
-   exec_list *const f00B2_parent_instructions = body.instructions;
-
-      body.instructions = &f00B2->body_instructions;
-
-      /* IF CONDITION */
-      ir_expression *const r00B4 = less(r0099, body.constant(int(1)));
-      ir_if *f00B3 = new(mem_ctx) ir_if(operand(r00B4).val);
-      exec_list *const f00B3_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f00B3->then_instructions;
-
-         body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-      body.instructions = f00B3_parent_instructions;
-      body.emit(f00B3);
-
-      /* END IF */
-
-      /* IF CONDITION */
-      ir_expression *const r00B6 = sub(body.constant(int(63)), r0099);
-      ir_expression *const r00B7 = lequal(r009B, r00B6);
-      ir_expression *const r00B8 = lshift(r00B1, r0099);
-      ir_expression *const r00B9 = lequal(r00B8, r009A);
-      ir_expression *const r00BA = logic_and(r00B7, r00B9);
-      ir_if *f00B5 = new(mem_ctx) ir_if(operand(r00BA).val);
-      exec_list *const f00B5_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f00B5->then_instructions;
-
-         ir_expression *const r00BB = lshift(r00B1, r0099);
-         body.emit(assign(r009A, sub(r009A, r00BB), 0x01));
-
-         ir_expression *const r00BC = lshift(body.constant(1u), r0099);
-         body.emit(assign(r009C, bit_or(swizzle_x(r009C), r00BC), 0x01));
-
-
-      body.instructions = f00B5_parent_instructions;
-      body.emit(f00B5);
-
-      /* END IF */
-
-      body.emit(assign(r0099, add(r0099, body.constant(int(-1))), 0x01));
-
-   /* LOOP END */
-
-   body.instructions = f00B2_parent_instructions;
-   body.emit(f00B2);
-
-   /* IF CONDITION */
-   ir_expression *const r00BE = lequal(r00B1, r009A);
-   ir_if *f00BD = new(mem_ctx) ir_if(operand(r00BE).val);
-   exec_list *const f00BD_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f00BD->then_instructions;
-
-      body.emit(assign(r009A, sub(r009A, r00B1), 0x01));
-
-      body.emit(assign(r009C, bit_or(swizzle_x(r009C), body.constant(1u)), 0x01));
-
-
-   body.instructions = f00BD_parent_instructions;
-   body.emit(f00BD);
-
-   /* END IF */
-
-   ir_variable *const r00BF = body.make_temp(glsl_type::uvec4_type, "vec_ctor");
-   body.emit(assign(r00BF, r009C, 0x03));
-
-   body.emit(assign(r00BF, expr(ir_unop_unpack_uint_2x32, r009A), 0x0c));
-
-   ir_swizzle *const r00C0 = swizzle(r00BF, MAKE_SWIZZLE4(SWIZZLE_Z, SWIZZLE_W, SWIZZLE_X, SWIZZLE_X), 2);
-   body.emit(ret(r00C0));
-
-   sig->replace_parameters(&sig_parameters);
-   return sig;
-}
-ir_function_signature *
-imod64(void *mem_ctx, builtin_available_predicate avail)
-{
-   ir_function_signature *const sig =
-      new(mem_ctx) ir_function_signature(glsl_type::ivec2_type, avail);
-   ir_factory body(&sig->body, mem_ctx);
-   sig->is_defined = true;
-
-   exec_list sig_parameters;
-
-   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::ivec2_type, "_n", ir_var_function_in);
-   sig_parameters.push_tail(r00C1);
-   ir_variable *const r00C2 = new(mem_ctx) ir_variable(glsl_type::ivec2_type, "_d", ir_var_function_in);
-   sig_parameters.push_tail(r00C2);
-   ir_variable *const r00C3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "negate", ir_var_auto);
-   body.emit(r00C3);
-   ir_expression *const r00C4 = less(swizzle_y(r00C1), body.constant(int(0)));
-   ir_expression *const r00C5 = less(swizzle_y(r00C2), body.constant(int(0)));
-   body.emit(assign(r00C3, nequal(r00C4, r00C5), 0x01));
-
-   ir_variable *const r00C6 = body.make_temp(glsl_type::uvec2_type, "n");
-   ir_expression *const r00C7 = expr(ir_unop_pack_int_2x32, r00C1);
-   ir_expression *const r00C8 = expr(ir_unop_abs, r00C7);
-   ir_expression *const r00C9 = expr(ir_unop_i642u64, r00C8);
-   body.emit(assign(r00C6, expr(ir_unop_unpack_uint_2x32, r00C9), 0x03));
-
-   ir_variable *const r00CA = body.make_temp(glsl_type::uvec2_type, "d");
-   ir_expression *const r00CB = expr(ir_unop_pack_int_2x32, r00C2);
-   ir_expression *const r00CC = expr(ir_unop_abs, r00CB);
-   ir_expression *const r00CD = expr(ir_unop_i642u64, r00CC);
-   body.emit(assign(r00CA, expr(ir_unop_unpack_uint_2x32, r00CD), 0x03));
-
-   ir_variable *const r00CE = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-   body.emit(r00CE);
-   ir_variable *const r00CF = new(mem_ctx) ir_variable(glsl_type::uint64_t_type, "n64", ir_var_auto);
-   body.emit(r00CF);
-   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "log2_denom", ir_var_auto);
-   body.emit(r00D0);
-   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "quot", ir_var_auto);
-   body.emit(r00D1);
-   body.emit(assign(r00D1, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));
-
-   ir_expression *const r00D2 = expr(ir_unop_find_msb, swizzle_y(r00CA));
-   body.emit(assign(r00D0, add(r00D2, body.constant(int(32))), 0x01));
-
-   /* IF CONDITION */
-   ir_expression *const r00D4 = equal(swizzle_y(r00CA), body.constant(0u));
-   ir_expression *const r00D5 = gequal(swizzle_y(r00C6), swizzle_x(r00CA));
-   ir_expression *const r00D6 = logic_and(r00D4, r00D5);
-   ir_if *f00D3 = new(mem_ctx) ir_if(operand(r00D6).val);
-   exec_list *const f00D3_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f00D3->then_instructions;
-
-      ir_variable *const r00D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "i", ir_var_auto);
-      body.emit(r00D7);
-      ir_variable *const r00D8 = body.make_temp(glsl_type::int_type, "findMSB_retval");
-      body.emit(assign(r00D8, expr(ir_unop_find_msb, swizzle_x(r00CA)), 0x01));
-
-      body.emit(assign(r00D0, r00D8, 0x01));
-
-      body.emit(assign(r00D7, body.constant(int(31)), 0x01));
-
-      /* LOOP BEGIN */
-      ir_loop *f00D9 = new(mem_ctx) ir_loop();
-      exec_list *const f00D9_parent_instructions = body.instructions;
-
-         body.instructions = &f00D9->body_instructions;
-
-         /* IF CONDITION */
-         ir_expression *const r00DB = less(r00D7, body.constant(int(1)));
-         ir_if *f00DA = new(mem_ctx) ir_if(operand(r00DB).val);
-         exec_list *const f00DA_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f00DA->then_instructions;
-
-            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-         body.instructions = f00DA_parent_instructions;
-         body.emit(f00DA);
-
-         /* END IF */
-
-         /* IF CONDITION */
-         ir_expression *const r00DD = sub(body.constant(int(31)), r00D7);
-         ir_expression *const r00DE = lequal(r00D8, r00DD);
-         ir_expression *const r00DF = lshift(swizzle_x(r00CA), r00D7);
-         ir_expression *const r00E0 = lequal(r00DF, swizzle_y(r00C6));
-         ir_expression *const r00E1 = logic_and(r00DE, r00E0);
-         ir_if *f00DC = new(mem_ctx) ir_if(operand(r00E1).val);
-         exec_list *const f00DC_parent_instructions = body.instructions;
-
-            /* THEN INSTRUCTIONS */
-            body.instructions = &f00DC->then_instructions;
-
-            ir_expression *const r00E2 = lshift(swizzle_x(r00CA), r00D7);
-            body.emit(assign(r00C6, sub(swizzle_y(r00C6), r00E2), 0x02));
-
-            ir_expression *const r00E3 = lshift(body.constant(1u), r00D7);
-            body.emit(assign(r00D1, bit_or(swizzle_y(r00D1), r00E3), 0x02));
-
-
-         body.instructions = f00DC_parent_instructions;
-         body.emit(f00DC);
-
-         /* END IF */
-
-         body.emit(assign(r00D7, add(r00D7, body.constant(int(-1))), 0x01));
-
-      /* LOOP END */
-
-      body.instructions = f00D9_parent_instructions;
-      body.emit(f00D9);
-
-      /* IF CONDITION */
-      ir_expression *const r00E5 = lequal(swizzle_x(r00CA), swizzle_y(r00C6));
-      ir_if *f00E4 = new(mem_ctx) ir_if(operand(r00E5).val);
-      exec_list *const f00E4_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f00E4->then_instructions;
-
-         body.emit(assign(r00C6, sub(swizzle_y(r00C6), swizzle_x(r00CA)), 0x02));
-
-         body.emit(assign(r00D1, bit_or(swizzle_y(r00D1), body.constant(1u)), 0x02));
-
-
-      body.instructions = f00E4_parent_instructions;
-      body.emit(f00E4);
-
-      /* END IF */
-
-
-   body.instructions = f00D3_parent_instructions;
-   body.emit(f00D3);
-
-   /* END IF */
-
-   ir_variable *const r00E6 = body.make_temp(glsl_type::uint64_t_type, "packUint2x32_retval");
-   body.emit(assign(r00E6, expr(ir_unop_pack_uint_2x32, r00CA), 0x01));
-
-   body.emit(assign(r00CF, expr(ir_unop_pack_uint_2x32, r00C6), 0x01));
-
-   body.emit(assign(r00CE, body.constant(int(31)), 0x01));
-
-   /* LOOP BEGIN */
-   ir_loop *f00E7 = new(mem_ctx) ir_loop();
-   exec_list *const f00E7_parent_instructions = body.instructions;
-
-      body.instructions = &f00E7->body_instructions;
-
-      /* IF CONDITION */
-      ir_expression *const r00E9 = less(r00CE, body.constant(int(1)));
-      ir_if *f00E8 = new(mem_ctx) ir_if(operand(r00E9).val);
-      exec_list *const f00E8_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f00E8->then_instructions;
-
-         body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));
-
-
-      body.instructions = f00E8_parent_instructions;
-      body.emit(f00E8);
-
-      /* END IF */
-
-      /* IF CONDITION */
-      ir_expression *const r00EB = sub(body.constant(int(63)), r00CE);
-      ir_expression *const r00EC = lequal(r00D0, r00EB);
-      ir_expression *const r00ED = lshift(r00E6, r00CE);
-      ir_expression *const r00EE = lequal(r00ED, r00CF);
-      ir_expression *const r00EF = logic_and(r00EC, r00EE);
-      ir_if *f00EA = new(mem_ctx) ir_if(operand(r00EF).val);
-      exec_list *const f00EA_parent_instructions = body.instructions;
-
-         /* THEN INSTRUCTIONS */
-         body.instructions = &f00EA->then_instructions;
-
-         ir_expression *const r00F0 = lshift(r00E6, r00CE);
-         body.emit(assign(r00CF, sub(r00CF, r00F0), 0x01));
-
-         ir_expression *const r00F1 = lshift(body.constant(1u), r00CE);
-         body.emit(assign(r00D1, bit_or(swizzle_x(r00D1), r00F1), 0x01));
-
-
-      body.instructions = f00EA_parent_instructions;
-      body.emit(f00EA);
-
-      /* END IF */
-
-      body.emit(assign(r00CE, add(r00CE, body.constant(int(-1))), 0x01));
-
-   /* LOOP END */
-
-   body.instructions = f00E7_parent_instructions;
-   body.emit(f00E7);
-
-   /* IF CONDITION */
-   ir_expression *const r00F3 = lequal(r00E6, r00CF);
-   ir_if *f00F2 = new(mem_ctx) ir_if(operand(r00F3).val);
-   exec_list *const f00F2_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f00F2->then_instructions;
-
-      body.emit(assign(r00CF, sub(r00CF, r00E6), 0x01));
-
-      body.emit(assign(r00D1, bit_or(swizzle_x(r00D1), body.constant(1u)), 0x01));
-
-
-   body.instructions = f00F2_parent_instructions;
-   body.emit(f00F2);
-
-   /* END IF */
-
-   ir_variable *const r00F4 = body.make_temp(glsl_type::uvec4_type, "vec_ctor");
-   body.emit(assign(r00F4, r00D1, 0x03));
-
-   body.emit(assign(r00F4, expr(ir_unop_unpack_uint_2x32, r00CF), 0x0c));
-
-   ir_variable *const r00F5 = body.make_temp(glsl_type::ivec2_type, "conditional_tmp");
-   /* IF CONDITION */
-   ir_if *f00F6 = new(mem_ctx) ir_if(operand(r00C3).val);
-   exec_list *const f00F6_parent_instructions = body.instructions;
-
-      /* THEN INSTRUCTIONS */
-      body.instructions = &f00F6->then_instructions;
-
-      ir_swizzle *const r00F7 = swizzle(r00F4, MAKE_SWIZZLE4(SWIZZLE_Z, SWIZZLE_W, SWIZZLE_X, SWIZZLE_X), 2);
-      ir_expression *const r00F8 = expr(ir_unop_pack_uint_2x32, r00F7);
-      ir_expression *const r00F9 = expr(ir_unop_u642i64, r00F8);
-      ir_expression *const r00FA = neg(r00F9);
-      body.emit(assign(r00F5, expr(ir_unop_unpack_int_2x32, r00FA), 0x03));
-
-
-      /* ELSE INSTRUCTIONS */
-      body.instructions = &f00F6->else_instructions;
-
-      ir_swizzle *const r00FB = swizzle(r00F4, MAKE_SWIZZLE4(SWIZZLE_Z, SWIZZLE_W, SWIZZLE_X, SWIZZLE_X), 2);
-      body.emit(assign(r00F5, expr(ir_unop_u2i, r00FB), 0x03));
-
-
-   body.instructions = f00F6_parent_instructions;
-   body.emit(f00F6);
-
-   /* END IF */
-
-   body.emit(ret(r00F5));
-
-   sig->replace_parameters(&sig_parameters);
-   return sig;
-}
diff --git a/src/compiler/glsl/generate_ir.cpp b/src/compiler/glsl/generate_ir.cpp
deleted file mode 100644
index 255b0484f2f1a..0000000000000
--- a/src/compiler/glsl/generate_ir.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright © 2016 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-#include "ir_builder.h"
-#include "builtin_functions.h"
-#include "program/prog_instruction.h" /* for SWIZZLE_X, &c. */
-
-using namespace ir_builder;
-
-namespace generate_ir {
-
-#include "builtin_int64.h"
-
-}
diff --git a/src/compiler/glsl/int64.glsl b/src/compiler/glsl/int64.glsl
deleted file mode 100644
index 7b826aecd73e0..0000000000000
--- a/src/compiler/glsl/int64.glsl
+++ /dev/null
@@ -1,99 +0,0 @@
-/* Compile with:
- *
- * glsl_compiler --version 400 --dump-builder int64.glsl > builtin_int64.h
- *
- * Version 4.00+ is required for umulExtended.
- */
-#version 400
-#extension GL_ARB_gpu_shader_int64: require
-#extension GL_ARB_shading_language_420pack: require
-
-uvec4
-udivmod64(uvec2 n, uvec2 d)
-{
-   uvec2 quot = uvec2(0U, 0U);
-   int log2_denom = findMSB(d.y) + 32;
-
-   /* If the upper 32 bits of denom are non-zero, it is impossible for shifts
-    * greater than 32 bits to occur.  If the upper 32 bits of the numerator
-    * are zero, it is impossible for (denom << [63, 32]) <= numer unless
-    * denom == 0.
-    */
-   if (d.y == 0 && n.y >= d.x) {
-      log2_denom = findMSB(d.x);
-
-      /* Since the upper 32 bits of denom are zero, log2_denom <= 31 and we
-       * don't have to compare log2_denom inside the loop as is done in the
-       * general case (below).
-       */
-      for (int i = 31; i >= 1; i--) {
-	 if (log2_denom <= 31 - i && (d.x << i) <= n.y) {
-	    n.y -= d.x << i;
-	    quot.y |= 1U << i;
-	 }
-      }
-
-      /* log2_denom is always <= 31, so manually peel the last loop
-       * iteration.
-       */
-      if (d.x <= n.y) {
-	 n.y -= d.x;
-	 quot.y |= 1U;
-      }
-   }
-
-   uint64_t d64 = packUint2x32(d);
-   uint64_t n64 = packUint2x32(n);
-   for (int i = 31; i >= 1; i--) {
-      if (log2_denom <= 63 - i && (d64 << i) <= n64) {
-	 n64 -= d64 << i;
-	 quot.x |= 1U << i;
-      }
-   }
-
-   /* log2_denom is always <= 63, so manually peel the last loop
-    * iteration.
-    */
-   if (d64 <= n64) {
-      n64 -= d64;
-      quot.x |= 1U;
-   }
-
-   return uvec4(quot, unpackUint2x32(n64));
-}
-
-uvec2
-udiv64(uvec2 n, uvec2 d)
-{
-   return udivmod64(n, d).xy;
-}
-
-ivec2
-idiv64(ivec2 _n, ivec2 _d)
-{
-   const bool negate = (_n.y < 0) != (_d.y < 0);
-   uvec2 n = unpackUint2x32(uint64_t(abs(packInt2x32(_n))));
-   uvec2 d = unpackUint2x32(uint64_t(abs(packInt2x32(_d))));
-
-   uvec2 quot = udivmod64(n, d).xy;
-
-   return negate ? unpackInt2x32(-int64_t(packUint2x32(quot))) : ivec2(quot);
-}
-
-uvec2
-umod64(uvec2 n, uvec2 d)
-{
-   return udivmod64(n, d).zw;
-}
-
-ivec2
-imod64(ivec2 _n, ivec2 _d)
-{
-   const bool negate = (_n.y < 0) != (_d.y < 0);
-   uvec2 n = unpackUint2x32(uint64_t(abs(packInt2x32(_n))));
-   uvec2 d = unpackUint2x32(uint64_t(abs(packInt2x32(_d))));
-
-   uvec2 rem = udivmod64(n, d).zw;
-
-   return negate ? unpackInt2x32(-int64_t(packUint2x32(rem))) : ivec2(rem);
-}
diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index d10a4327f15b1..6e94adc11686e 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -33,10 +33,6 @@
 struct gl_linked_shader;
 struct gl_shader_program;
 
-/* Operations for lower_64bit_integer_instructions() */
-#define DIV64                     (1U << 0)
-#define MOD64                     (1U << 1)
-
 bool do_common_optimization(exec_list *ir, bool linked,
                             const struct gl_shader_compiler_options *options,
                             bool native_integers);
@@ -78,9 +74,6 @@ bool propagate_invariance(exec_list *instructions);
 
 namespace ir_builder { class ir_factory; };
 
-bool lower_64bit_integer_instructions(exec_list *instructions,
-                                      unsigned what_to_lower);
-
 void lower_precision(const struct gl_shader_compiler_options *options,
                      exec_list *instructions);
 
diff --git a/src/compiler/glsl/lower_int64.cpp b/src/compiler/glsl/lower_int64.cpp
deleted file mode 100644
index a4d36735d0726..0000000000000
--- a/src/compiler/glsl/lower_int64.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright © 2016 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_int64.cpp
- *
- * Lower 64-bit operations to 32-bit operations.  Each 64-bit value is lowered
- * to a uvec2.  For each operation that can be lowered, there is a function
- * called __builtin_foo with the same number of parameters that takes uvec2
- * sources and produces uvec2 results.  An operation like
- *
- *     uint64_t(x) / uint64_t(y)
- *
- * becomes
- *
- *     packUint2x32(__builtin_udiv64(unpackUint2x32(x), unpackUint2x32(y)));
- */
-
-#include "main/macros.h"
-#include "compiler/glsl_types.h"
-#include "ir.h"
-#include "ir_rvalue_visitor.h"
-#include "ir_builder.h"
-#include "ir_optimization.h"
-#include "util/hash_table.h"
-#include "builtin_functions.h"
-
-typedef ir_function_signature *(*function_generator)(void *mem_ctx,
-                                                     builtin_available_predicate avail);
-
-using namespace ir_builder;
-
-namespace lower_64bit {
-void expand_source(ir_factory &, ir_rvalue *val, ir_variable **expanded_src);
-
-ir_dereference_variable *compact_destination(ir_factory &,
-                                             const glsl_type *type,
-                                             ir_variable *result[4]);
-
-ir_rvalue *lower_op_to_function_call(ir_instruction *base_ir,
-                                     ir_expression *ir,
-                                     ir_function_signature *callee);
-};
-
-using namespace lower_64bit;
-
-namespace {
-
-class lower_64bit_visitor : public ir_rvalue_visitor {
-public:
-   lower_64bit_visitor(void *mem_ctx, exec_list *instructions, unsigned lower)
-      : progress(false), lower(lower),
-        function_list(), added_functions(&function_list, mem_ctx)
-   {
-      functions = _mesa_hash_table_create(mem_ctx,
-                                          _mesa_hash_string,
-                                          _mesa_key_string_equal);
-
-      foreach_in_list(ir_instruction, node, instructions) {
-         ir_function *const f = node->as_function();
-
-         if (f == NULL || strncmp(f->name, "__builtin_", 10) != 0)
-            continue;
-
-         add_function(f);
-      }
-   }
-
-   ~lower_64bit_visitor()
-   {
-      _mesa_hash_table_destroy(functions, NULL);
-   }
-
-   void handle_rvalue(ir_rvalue **rvalue);
-
-   void add_function(ir_function *f)
-   {
-      _mesa_hash_table_insert(functions, f->name, f);
-   }
-
-   ir_function *find_function(const char *name)
-   {
-      struct hash_entry *const entry =
-         _mesa_hash_table_search(functions, name);
-
-      return entry != NULL ? (ir_function *) entry->data : NULL;
-   }
-
-   bool progress;
-
-private:
-   unsigned lower; /** Bitfield of which operations to lower */
-
-   /** Hashtable containing all of the known functions in the IR */
-   struct hash_table *functions;
-
-public:
-   exec_list function_list;
-
-private:
-   ir_factory added_functions;
-
-   ir_rvalue *handle_op(ir_expression *ir, const char *function_name,
-                        function_generator generator);
-};
-
-} /* anonymous namespace */
-
-/**
- * Determine if a particular type of lowering should occur
- */
-#define lowering(x) (this->lower & x)
-
-bool
-lower_64bit_integer_instructions(exec_list *instructions,
-                                 unsigned what_to_lower)
-{
-   if (instructions->is_empty())
-      return false;
-
-   ir_instruction *first_inst = (ir_instruction *) instructions->get_head_raw();
-   void *const mem_ctx = ralloc_parent(first_inst);
-   lower_64bit_visitor v(mem_ctx, instructions, what_to_lower);
-
-   visit_list_elements(&v, instructions);
-
-   if (v.progress && !v.function_list.is_empty()) {
-      /* Move all of the nodes from function_list to the head if the incoming
-       * instruction list.
-       */
-      exec_node *const after = &instructions->head_sentinel;
-      exec_node *const before = instructions->head_sentinel.next;
-      exec_node *const head = v.function_list.head_sentinel.next;
-      exec_node *const tail = v.function_list.tail_sentinel.prev;
-
-      before->next = head;
-      head->prev = before;
-
-      after->prev = tail;
-      tail->next = after;
-   }
-
-   return v.progress;
-}
-
-
-/**
- * Expand individual 64-bit values to uvec2 values
- *
- * Each operation is in one of a few forms.
- *
- *     vector op vector
- *     vector op scalar
- *     scalar op vector
- *     scalar op scalar
- *
- * In the 'vector op vector' case, the two vectors must have the same size.
- * In a way, the 'scalar op scalar' form is special case of the 'vector op
- * vector' form.
- *
- * This method generates a new set of uvec2 values for each element of a
- * single operand.  If the operand is a scalar, the uvec2 is replicated
- * multiple times.  A value like
- *
- *     u64vec3(a) + u64vec3(b)
- *
- * becomes
- *
- *     u64vec3 tmp0 = u64vec3(a) + u64vec3(b);
- *     uvec2 tmp1 = unpackUint2x32(tmp0.x);
- *     uvec2 tmp2 = unpackUint2x32(tmp0.y);
- *     uvec2 tmp3 = unpackUint2x32(tmp0.z);
- *
- * and the returned operands array contains ir_variable pointers to
- *
- *     { tmp1, tmp2, tmp3, tmp1 }
- */
-void
-lower_64bit::expand_source(ir_factory &body,
-                           ir_rvalue *val,
-                           ir_variable **expanded_src)
-{
-   assert(val->type->is_integer_64());
-
-   ir_variable *const temp = body.make_temp(val->type, "tmp");
-
-   body.emit(assign(temp, val));
-
-   const ir_expression_operation unpack_opcode =
-      val->type->base_type == GLSL_TYPE_UINT64
-      ? ir_unop_unpack_uint_2x32 : ir_unop_unpack_int_2x32;
-
-   const glsl_type *const type =
-      val->type->base_type == GLSL_TYPE_UINT64
-      ? glsl_type::uvec2_type : glsl_type::ivec2_type;
-
-   unsigned i;
-   for (i = 0; i < val->type->vector_elements; i++) {
-      expanded_src[i] = body.make_temp(type, "expanded_64bit_source");
-
-      body.emit(assign(expanded_src[i],
-                       expr(unpack_opcode, swizzle(temp, i, 1))));
-   }
-
-   for (/* empty */; i < 4; i++)
-      expanded_src[i] = expanded_src[0];
-}
-
-/**
- * Convert a series of uvec2 results into a single 64-bit integer vector
- */
-ir_dereference_variable *
-lower_64bit::compact_destination(ir_factory &body,
-                                 const glsl_type *type,
-                                 ir_variable *result[4])
-{
-   const ir_expression_operation pack_opcode =
-      type->base_type == GLSL_TYPE_UINT64
-      ? ir_unop_pack_uint_2x32 : ir_unop_pack_int_2x32;
-
-   ir_variable *const compacted_result =
-      body.make_temp(type, "compacted_64bit_result");
-
-   for (unsigned i = 0; i < type->vector_elements; i++) {
-      body.emit(assign(compacted_result,
-                       expr(pack_opcode, result[i]),
-                       1U << i));
-   }
-
-   void *const mem_ctx = ralloc_parent(compacted_result);
-   return new(mem_ctx) ir_dereference_variable(compacted_result);
-}
-
-ir_rvalue *
-lower_64bit::lower_op_to_function_call(ir_instruction *base_ir,
-                                       ir_expression *ir,
-                                       ir_function_signature *callee)
-{
-   const unsigned num_operands = ir->num_operands;
-   ir_variable *src[4][4];
-   ir_variable *dst[4];
-   void *const mem_ctx = ralloc_parent(ir);
-   exec_list instructions;
-   unsigned source_components = 0;
-   const glsl_type *const result_type =
-      ir->type->base_type == GLSL_TYPE_UINT64
-      ? glsl_type::uvec2_type : glsl_type::ivec2_type;
-
-   ir_factory body(&instructions, mem_ctx);
-
-   for (unsigned i = 0; i < num_operands; i++) {
-      expand_source(body, ir->operands[i], src[i]);
-
-      if (ir->operands[i]->type->vector_elements > source_components)
-         source_components = ir->operands[i]->type->vector_elements;
-   }
-
-   for (unsigned i = 0; i < source_components; i++) {
-      dst[i] = body.make_temp(result_type, "expanded_64bit_result");
-
-      exec_list parameters;
-
-      for (unsigned j = 0; j < num_operands; j++)
-         parameters.push_tail(new(mem_ctx) ir_dereference_variable(src[j][i]));
-
-      ir_dereference_variable *const return_deref =
-         new(mem_ctx) ir_dereference_variable(dst[i]);
-
-      ir_call *const c = new(mem_ctx) ir_call(callee,
-                                              return_deref,
-                                              &parameters);
-
-      body.emit(c);
-   }
-
-   ir_rvalue *const rv = compact_destination(body, ir->type, dst);
-
-   /* Move all of the nodes from instructions between base_ir and the
-    * instruction before it.
-    */
-   exec_node *const after = base_ir;
-   exec_node *const before = after->prev;
-   exec_node *const head = instructions.head_sentinel.next;
-   exec_node *const tail = instructions.tail_sentinel.prev;
-
-   before->next = head;
-   head->prev = before;
-
-   after->prev = tail;
-   tail->next = after;
-
-   return rv;
-}
-
-ir_rvalue *
-lower_64bit_visitor::handle_op(ir_expression *ir,
-                               const char *function_name,
-                               function_generator generator)
-{
-   for (unsigned i = 0; i < ir->num_operands; i++)
-      if (!ir->operands[i]->type->is_integer_64())
-         return ir;
-
-   /* Get a handle to the correct ir_function_signature for the core
-    * operation.
-    */
-   ir_function_signature *callee = NULL;
-   ir_function *f = find_function(function_name);
-
-   if (f != NULL) {
-      callee = (ir_function_signature *) f->signatures.get_head();
-      assert(callee != NULL && callee->ir_type == ir_type_function_signature);
-   } else {
-      f = new(base_ir) ir_function(function_name);
-      callee = generator(base_ir, NULL);
-
-      f->add_signature(callee);
-
-      add_function(f);
-   }
-
-   this->progress = true;
-   return lower_op_to_function_call(this->base_ir, ir, callee);
-}
-
-void
-lower_64bit_visitor::handle_rvalue(ir_rvalue **rvalue)
-{
-   if (*rvalue == NULL || (*rvalue)->ir_type != ir_type_expression)
-      return;
-
-   ir_expression *const ir = (*rvalue)->as_expression();
-   assert(ir != NULL);
-
-   switch (ir->operation) {
-   case ir_binop_div:
-      if (lowering(DIV64)) {
-         if (ir->type->base_type == GLSL_TYPE_UINT64) {
-            *rvalue = handle_op(ir, "__builtin_udiv64", generate_ir::udiv64);
-         } else {
-            *rvalue = handle_op(ir, "__builtin_idiv64", generate_ir::idiv64);
-         }
-      }
-      break;
-
-   case ir_binop_mod:
-      if (lowering(MOD64)) {
-         if (ir->type->base_type == GLSL_TYPE_UINT64) {
-            *rvalue = handle_op(ir, "__builtin_umod64", generate_ir::umod64);
-         } else {
-            *rvalue = handle_op(ir, "__builtin_imod64", generate_ir::imod64);
-         }
-      }
-      break;
-
-   default:
-      break;
-   }
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 9cb51e323dd4d..faded36a0aaa7 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -123,10 +123,8 @@ files_libglsl = files(
   'ast_type.cpp',
   'builtin_functions.cpp',
   'builtin_functions.h',
-  'builtin_int64.h',
   'builtin_types.cpp',
   'builtin_variables.cpp',
-  'generate_ir.cpp',
   'gl_nir_lower_atomics.c',
   'gl_nir_lower_images.c',
   'gl_nir_lower_blend_equation_advanced.c',
@@ -200,7 +198,6 @@ files_libglsl = files(
   'lower_discard_flow.cpp',
   'lower_distance.cpp',
   'lower_instructions.cpp',
-  'lower_int64.cpp',
   'lower_jumps.cpp',
   'lower_mat_op_to_vec.cpp',
   'lower_named_interface_blocks.cpp',
diff --git a/src/compiler/glsl/tests/lower_int64_test.cpp b/src/compiler/glsl/tests/lower_int64_test.cpp
deleted file mode 100644
index 7f70aaeb11878..0000000000000
--- a/src/compiler/glsl/tests/lower_int64_test.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
- * Copyright © 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-#include <gtest/gtest.h>
-#include "util/compiler.h"
-#include "main/macros.h"
-#include "ir.h"
-#include "ir_builder.h"
-
-using namespace ir_builder;
-
-namespace lower_64bit {
-void expand_source(ir_factory &body,
-                   ir_rvalue *val,
-                   ir_variable **expanded_src);
-
-ir_dereference_variable *compact_destination(ir_factory &body,
-                                             const glsl_type *type,
-                                             ir_variable *result[4]);
-
-ir_rvalue *lower_op_to_function_call(ir_instruction *base_ir,
-                                     ir_expression *ir,
-                                     ir_function_signature *callee);
-};
-
-class expand_source : public ::testing::Test {
-public:
-   virtual void SetUp();
-   virtual void TearDown();
-
-   exec_list instructions;
-   ir_factory *body;
-   ir_variable *expanded_src[4];
-   void *mem_ctx;
-};
-
-void
-expand_source::SetUp()
-{
-   glsl_type_singleton_init_or_ref();
-
-   mem_ctx = ralloc_context(NULL);
-
-   memset(expanded_src, 0, sizeof(expanded_src));
-   instructions.make_empty();
-   body = new ir_factory(&instructions, mem_ctx);
-}
-
-void
-expand_source::TearDown()
-{
-   delete body;
-   body = NULL;
-
-   ralloc_free(mem_ctx);
-   mem_ctx = NULL;
-
-   glsl_type_singleton_decref();
-}
-
-static ir_dereference_variable *
-create_variable(void *mem_ctx, const glsl_type *type)
-{
-   ir_variable *var = new(mem_ctx) ir_variable(type,
-                                               "variable",
-                                               ir_var_temporary);
-
-   return new(mem_ctx) ir_dereference_variable(var);
-}
-
-static ir_expression *
-create_expression(void *mem_ctx, const glsl_type *type)
-{
-   return new(mem_ctx) ir_expression(ir_unop_neg,
-                                     create_variable(mem_ctx, type));
-}
-
-static void
-check_expanded_source(const glsl_type *type,
-                      ir_variable *expanded_src[4])
-{
-   const glsl_type *const expanded_type =
-      type->base_type == GLSL_TYPE_UINT64
-      ? glsl_type::uvec2_type :glsl_type::ivec2_type;
-
-   for (int i = 0; i < type->vector_elements; i++) {
-      EXPECT_EQ(expanded_type, expanded_src[i]->type);
-
-      /* All elements that are part of the vector must be unique. */
-      for (int j = i - 1; j >= 0; j--) {
-         EXPECT_NE(expanded_src[i], expanded_src[j])
-            << "    Element " << i << " is the same as element " << j;
-      }
-   }
-
-   /* All elements that are not part of the vector must be the same as element
-    * 0.  This is primarily for scalars (where every element is the same).
-    */
-   for (int i = type->vector_elements; i < 4; i++) {
-      EXPECT_EQ(expanded_src[0], expanded_src[i])
-         << "    Element " << i << " should be the same as element 0";
-   }
-}
-
-static void
-check_instructions(exec_list *instructions,
-                   const glsl_type *type,
-                   const ir_instruction *source)
-{
-   const glsl_type *const expanded_type =
-      type->base_type == GLSL_TYPE_UINT64
-      ? glsl_type::uvec2_type : glsl_type::ivec2_type;
-
-   const ir_expression_operation unpack_opcode =
-      type->base_type == GLSL_TYPE_UINT64
-      ? ir_unop_unpack_uint_2x32 : ir_unop_unpack_int_2x32;
-
-   ir_instruction *ir;
-
-   /* The instruction list should contain IR to represent:
-    *
-    *    type tmp1;
-    *    tmp1 = source;
-    *    uvec2 tmp2;
-    *    tmp2 = unpackUint2x32(tmp1.x);
-    *    uvec2 tmp3;
-    *    tmp3 = unpackUint2x32(tmp1.y);
-    *    uvec2 tmp4;
-    *    tmp4 = unpackUint2x32(tmp1.z);
-    *    uvec2 tmp5;
-    *    tmp5 = unpackUint2x32(tmp1.w);
-    */
-   ASSERT_FALSE(instructions->is_empty());
-   ir = (ir_instruction *) instructions->pop_head();
-   ir_variable *const tmp1 = ir->as_variable();
-   EXPECT_EQ(ir_type_variable, ir->ir_type);
-   EXPECT_EQ(type, tmp1->type) <<
-      "    Got " <<
-      glsl_get_type_name(tmp1->type) <<
-      ", expected " <<
-      glsl_get_type_name(type);
-
-   ASSERT_FALSE(instructions->is_empty());
-   ir = (ir_instruction *) instructions->pop_head();
-   ir_assignment *const assign1 = ir->as_assignment();
-   EXPECT_EQ(ir_type_assignment, ir->ir_type);
-   ASSERT_NE((void *)0, assign1);
-   EXPECT_EQ(tmp1, assign1->lhs->variable_referenced());
-   EXPECT_EQ(source, assign1->rhs);
-
-   for (unsigned i = 0; i < type->vector_elements; i++) {
-      ASSERT_FALSE(instructions->is_empty());
-      ir = (ir_instruction *) instructions->pop_head();
-      ir_variable *const tmp2 = ir->as_variable();
-      EXPECT_EQ(ir_type_variable, ir->ir_type);
-      EXPECT_EQ(expanded_type, tmp2->type);
-
-      ASSERT_FALSE(instructions->is_empty());
-      ir = (ir_instruction *) instructions->pop_head();
-      ir_assignment *const assign2 = ir->as_assignment();
-      EXPECT_EQ(ir_type_assignment, ir->ir_type);
-      ASSERT_NE((void *)0, assign2);
-      EXPECT_EQ(tmp2, assign2->lhs->variable_referenced());
-      ir_expression *unpack = assign2->rhs->as_expression();
-      ASSERT_NE((void *)0, unpack);
-      EXPECT_EQ(unpack_opcode, unpack->operation);
-      EXPECT_EQ(tmp1, unpack->operands[0]->variable_referenced());
-   }
-
-   EXPECT_TRUE(instructions->is_empty());
-}
-
-TEST_F(expand_source, uint64_variable)
-{
-   const glsl_type *const type = glsl_type::uint64_t_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, u64vec2_variable)
-{
-   const glsl_type *const type = glsl_type::u64vec2_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, u64vec3_variable)
-{
-   const glsl_type *const type = glsl_type::u64vec3_type;
-
-   /* Generate an operand that is a scalar variable dereference. */
-   ir_variable *const var = new(mem_ctx) ir_variable(type,
-                                                     "variable",
-                                                     ir_var_temporary);
-
-   ir_dereference_variable *const deref =
-      new(mem_ctx) ir_dereference_variable(var);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, u64vec4_variable)
-{
-   const glsl_type *const type = glsl_type::u64vec4_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, int64_variable)
-{
-   const glsl_type *const type = glsl_type::int64_t_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, i64vec2_variable)
-{
-   const glsl_type *const type = glsl_type::i64vec2_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, i64vec3_variable)
-{
-   const glsl_type *const type = glsl_type::i64vec3_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, i64vec4_variable)
-{
-   const glsl_type *const type = glsl_type::i64vec4_type;
-   ir_dereference_variable *const deref = create_variable(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, deref, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, deref);
-}
-
-TEST_F(expand_source, uint64_expression)
-{
-   const glsl_type *const type = glsl_type::uint64_t_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, u64vec2_expression)
-{
-   const glsl_type *const type = glsl_type::u64vec2_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, u64vec3_expression)
-{
-   const glsl_type *const type = glsl_type::u64vec3_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, u64vec4_expression)
-{
-   const glsl_type *const type = glsl_type::u64vec4_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, int64_expression)
-{
-   const glsl_type *const type = glsl_type::int64_t_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, i64vec2_expression)
-{
-   const glsl_type *const type = glsl_type::i64vec2_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, i64vec3_expression)
-{
-   const glsl_type *const type = glsl_type::i64vec3_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-TEST_F(expand_source, i64vec4_expression)
-{
-   const glsl_type *const type = glsl_type::i64vec4_type;
-   ir_expression *const expr = create_expression(mem_ctx, type);
-
-   lower_64bit::expand_source(*body, expr, expanded_src);
-
-   check_expanded_source(type, expanded_src);
-   check_instructions(&instructions, type, expr);
-}
-
-class compact_destination : public ::testing::Test {
-public:
-   virtual void SetUp();
-   virtual void TearDown();
-
-   exec_list instructions;
-   ir_factory *body;
-   ir_variable *expanded_src[4];
-   void *mem_ctx;
-};
-
-void
-compact_destination::SetUp()
-{
-   mem_ctx = ralloc_context(NULL);
-
-   memset(expanded_src, 0, sizeof(expanded_src));
-   instructions.make_empty();
-   body = new ir_factory(&instructions, mem_ctx);
-}
-
-void
-compact_destination::TearDown()
-{
-   delete body;
-   body = NULL;
-
-   ralloc_free(mem_ctx);
-   mem_ctx = NULL;
-}
-
-TEST_F(compact_destination, uint64)
-{
-   const glsl_type *const type = glsl_type::uint64_t_type;
-
-   for (unsigned i = 0; i < type->vector_elements; i++) {
-      expanded_src[i] = new(mem_ctx) ir_variable(glsl_type::uvec2_type,
-                                                 "result",
-                                                 ir_var_temporary);
-   }
-
-   ir_dereference_variable *deref =
-      lower_64bit::compact_destination(*body,
-                                       type,
-                                       expanded_src);
-
-   ASSERT_EQ(ir_type_dereference_variable, deref->ir_type);
-   EXPECT_EQ(type, deref->var->type) <<
-      "    Got " <<
-      glsl_get_type_name(deref->var->type) <<
-      ", expected " <<
-      glsl_get_type_name(type);
-
-   ir_instruction *ir;
-
-   ASSERT_FALSE(instructions.is_empty());
-   ir = (ir_instruction *) instructions.pop_head();
-   ir_variable *const var = ir->as_variable();
-   ASSERT_NE((void *)0, var);
-   EXPECT_EQ(deref->var, var);
-
-   for (unsigned i = 0; i < type->vector_elements; i++) {
-      ASSERT_FALSE(instructions.is_empty());
-      ir = (ir_instruction *) instructions.pop_head();
-      ir_assignment *const assign = ir->as_assignment();
-      ASSERT_NE((void *)0, assign);
-      EXPECT_EQ(deref->var, assign->lhs->variable_referenced());
-   }
-}
diff --git a/src/compiler/glsl/tests/meson.build b/src/compiler/glsl/tests/meson.build
index 76fe81f00f6c6..5046803698aab 100644
--- a/src/compiler/glsl/tests/meson.build
+++ b/src/compiler/glsl/tests/meson.build
@@ -22,7 +22,6 @@ general_ir_test_files = files(
   'array_refcount_test.cpp',
   'builtin_variable_test.cpp',
   'general_ir_test.cpp',
-  'lower_int64_test.cpp',
   'opt_add_neg_to_sub_test.cpp',
 )
 general_ir_test_files += ir_expression_operation_h
diff --git a/src/gallium/auxiliary/util/u_screen.c b/src/gallium/auxiliary/util/u_screen.c
index 522c0e85789a2..6ce7179c218eb 100644
--- a/src/gallium/auxiliary/util/u_screen.c
+++ b/src/gallium/auxiliary/util/u_screen.c
@@ -334,7 +334,6 @@ u_pipe_screen_get_param_defaults(struct pipe_screen *pscreen,
    case PIPE_CAP_LEGACY_MATH_RULES:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_TGSI_TEX_TXF_LZ:
    case PIPE_CAP_SHADER_CLOCK:
    case PIPE_CAP_POLYGON_MODE_FILL_RECTANGLE:
diff --git a/src/gallium/drivers/crocus/crocus_screen.c b/src/gallium/drivers/crocus/crocus_screen.c
index deca4caf53e4c..464bebfc230be 100644
--- a/src/gallium/drivers/crocus/crocus_screen.c
+++ b/src/gallium/drivers/crocus/crocus_screen.c
@@ -194,7 +194,6 @@ crocus_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_NATIVE_FENCE_FD:
       return true;
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_SHADER_BALLOT:
    case PIPE_CAP_PACKED_UNIFORMS:
       return devinfo->ver == 8;
diff --git a/src/gallium/drivers/d3d12/d3d12_screen.cpp b/src/gallium/drivers/d3d12/d3d12_screen.cpp
index 2279a1e846981..6cdc043627f63 100644
--- a/src/gallium/drivers/d3d12/d3d12_screen.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_screen.cpp
@@ -324,7 +324,6 @@ d3d12_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME:
    case PIPE_CAP_STREAM_OUTPUT_INTERLEAVE_BUFFERS:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_DEVICE_RESET_STATUS_QUERY:
    case PIPE_CAP_ROBUST_BUFFER_ACCESS_BEHAVIOR:
diff --git a/src/gallium/drivers/freedreno/freedreno_screen.c b/src/gallium/drivers/freedreno/freedreno_screen.c
index e101a3f7c5dc0..a2904a5cbb65c 100644
--- a/src/gallium/drivers/freedreno/freedreno_screen.c
+++ b/src/gallium/drivers/freedreno/freedreno_screen.c
@@ -382,7 +382,6 @@ fd_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
       return 64;
 
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_DOUBLES:
       return is_ir3(screen);
 
diff --git a/src/gallium/drivers/iris/iris_screen.c b/src/gallium/drivers/iris/iris_screen.c
index 5c5364d9eca85..accc1250e6dcd 100644
--- a/src/gallium/drivers/iris/iris_screen.c
+++ b/src/gallium/drivers/iris/iris_screen.c
@@ -255,7 +255,6 @@ iris_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_STREAM_OUTPUT_INTERLEAVE_BUFFERS:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_SAMPLER_VIEW_TARGET:
    case PIPE_CAP_ROBUST_BUFFER_ACCESS_BEHAVIOR:
    case PIPE_CAP_DEVICE_RESET_STATUS_QUERY:
diff --git a/src/gallium/drivers/llvmpipe/lp_screen.c b/src/gallium/drivers/llvmpipe/lp_screen.c
index 80e5050f1e7cd..da0dfe5f6f82c 100644
--- a/src/gallium/drivers/llvmpipe/lp_screen.c
+++ b/src/gallium/drivers/llvmpipe/lp_screen.c
@@ -258,7 +258,6 @@ llvmpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_SHADER_ARRAY_COMPONENTS:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_QUERY_SO_OVERFLOW:
    case PIPE_CAP_TGSI_DIV:
       return 1;
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_screen.c b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
index eff6df65c77c7..ee7f132b2053b 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_screen.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
@@ -220,7 +220,6 @@ nv30_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_LEGACY_MATH_RULES:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_TGSI_TEX_TXF_LZ:
    case PIPE_CAP_SHADER_CLOCK:
    case PIPE_CAP_POLYGON_MODE_FILL_RECTANGLE:
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
index b7e603a0e13a2..7057a68b1db5f 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
@@ -330,7 +330,6 @@ nvc0_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
 
    case PIPE_CAP_GL_SPIRV:
    case PIPE_CAP_GL_SPIRV_VARIABLE_POINTERS:
-   case PIPE_CAP_INT64_DIVMOD:
       return 1;
 
    /* nir related caps */
diff --git a/src/gallium/drivers/r600/r600_pipe.c b/src/gallium/drivers/r600/r600_pipe.c
index caea8f509d59b..ab758cca8332c 100644
--- a/src/gallium/drivers/r600/r600_pipe.c
+++ b/src/gallium/drivers/r600/r600_pipe.c
@@ -408,11 +408,6 @@ static int r600_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
 
 	case PIPE_CAP_TWO_SIDED_COLOR:
 		return 0;
-	case PIPE_CAP_INT64_DIVMOD:
-		/* it is actually not supported, but the nir lowering handles this correctly whereas
-		 * the glsl lowering path seems to not initialize the buildins correctly.
-		 */
-		return 1;
 	case PIPE_CAP_CULL_DISTANCE:
 		return 1;
 
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 3d0215fe58545..e794995830e57 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -130,7 +130,6 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_MEMOBJ:
    case PIPE_CAP_LOAD_CONSTBUF:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_SHADER_CLOCK:
    case PIPE_CAP_CAN_BIND_CONST_BUFFER_AS_VERTEX:
    case PIPE_CAP_ALLOW_MAPPED_BUFFERS_DURING_EXECUTION:
diff --git a/src/gallium/drivers/softpipe/sp_screen.c b/src/gallium/drivers/softpipe/sp_screen.c
index 9a78fb8df48f7..351de3f0b25ad 100644
--- a/src/gallium/drivers/softpipe/sp_screen.c
+++ b/src/gallium/drivers/softpipe/sp_screen.c
@@ -206,7 +206,6 @@ softpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_VS_LAYER_VIEWPORT:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_TGSI_DIV:
       return 1;
    case PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT:
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index 06904701aa517..10b82fec18aac 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -740,7 +740,7 @@ vgpu10_get_shader_param(struct pipe_screen *screen,
    .lower_extract_word = true,                                                \
    .lower_insert_byte = true,                                                 \
    .lower_insert_word = true,                                                 \
-   .lower_int64_options = nir_lower_imul_2x32_64,                             \
+   .lower_int64_options = nir_lower_imul_2x32_64 | nir_lower_divmod64,        \
    .lower_fdph = true,                                                        \
    .lower_flrp64 = true,                                                      \
    .lower_ldexp = true,                                                       \
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index d03998f7a0215..3ebfb3e5649f5 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -679,7 +679,6 @@ zink_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
       return screen->info.have_NV_compute_shader_derivatives;
 
    case PIPE_CAP_INT64:
-   case PIPE_CAP_INT64_DIVMOD:
    case PIPE_CAP_DOUBLES:
       return 1;
 
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 0cbbb9d57dc41..38ab5f4a15800 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -809,7 +809,6 @@ enum pipe_cap
    PIPE_CAP_LEGACY_MATH_RULES,
    PIPE_CAP_DOUBLES,
    PIPE_CAP_INT64,
-   PIPE_CAP_INT64_DIVMOD,
    PIPE_CAP_TGSI_TEX_TXF_LZ,
    PIPE_CAP_SHADER_CLOCK,
    PIPE_CAP_POLYGON_MODE_FILL_RECTANGLE,
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index 7c457fd98c417..1d6e4a2e46153 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -515,9 +515,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
          bool have_dround = pscreen->get_shader_param(pscreen, ptarget,
                                                       PIPE_SHADER_CAP_DROUND_SUPPORTED);
 
-         if (!pscreen->get_param(pscreen, PIPE_CAP_INT64_DIVMOD))
-            lower_64bit_integer_instructions(ir, DIV64 | MOD64);
-
          lower_packing_builtins(ir, ctx->Extensions.ARB_shading_language_packing,
                                 ctx->Extensions.ARB_gpu_shader5,
                                 ctx->st->has_half_float_packing);
-- 
GitLab


From c8d08072cb3e4f9c242c0d5a518386531f7033ce Mon Sep 17 00:00:00 2001
From: Eric Anholt <eric@anholt.net>
Date: Wed, 18 Oct 2023 09:47:16 +0200
Subject: [PATCH 2/4] llvmpipe: Set nir_lower_dround_even.

Avoids a regression when disabling GLSL-level lowering of the dround class
of ops, while passing through doubles to llvm for the other rounding ops.
---
 src/gallium/drivers/llvmpipe/lp_screen.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/llvmpipe/lp_screen.c b/src/gallium/drivers/llvmpipe/lp_screen.c
index da0dfe5f6f82c..b518da49e720c 100644
--- a/src/gallium/drivers/llvmpipe/lp_screen.c
+++ b/src/gallium/drivers/llvmpipe/lp_screen.c
@@ -622,6 +622,7 @@ static const struct nir_shader_compiler_options gallivm_nir_options = {
    .lower_mul_2x32_64 = true,
    .lower_ifind_msb = true,
    .lower_int64_options = nir_lower_imul_2x32_64,
+   .lower_doubles_options = nir_lower_dround_even,
    .max_unroll_iterations = 32,
    .use_interpolated_input_intrinsics = true,
    .lower_to_scalar = true,
-- 
GitLab


From 700edad21dbe4090a6c41482e3dc8319088aed63 Mon Sep 17 00:00:00 2001
From: Eric Anholt <eric@anholt.net>
Date: Wed, 18 Oct 2023 09:49:32 +0200
Subject: [PATCH 3/4] nir: Add nir_lower_dsign as 64-bit fsign lowering.

Right now some drivers are doing dsign lowering in GLSL and haven't had to
have a NIR path due to there not being a corresponding vulkan driver.  We
want this in NIR now so that we can retire that batch of GLSL lowering
code.
---
 src/compiler/nir/nir.h                 | 3 ++-
 src/compiler/nir/nir_opt_algebraic.py  | 1 +
 src/gallium/drivers/svga/svga_screen.c | 2 +-
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 5c4c4ada70c3c..db1e26405e96b 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3471,7 +3471,8 @@ typedef enum {
    nir_lower_dmod = (1 << 8),
    nir_lower_dsub = (1 << 9),
    nir_lower_ddiv = (1 << 10),
-   nir_lower_fp64_full_software = (1 << 11),
+   nir_lower_dsign = (1 << 11),
+   nir_lower_fp64_full_software = (1 << 12),
 } nir_lower_doubles_options;
 
 typedef enum {
diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index da422a75e8fbf..eee410364ea5b 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -2217,6 +2217,7 @@ optimizations.extend([
    # Mark the new comparisons precise to prevent them being changed to 'a !=
    # 0' or 'a == 0'.
    (('fsign', a), ('fsub', ('b2f', ('!flt', 0.0, a)), ('b2f', ('!flt', a, 0.0))), 'options->lower_fsign'),
+   (('fsign', 'a@64'), ('fsub', ('b2f', ('!flt', 0.0, a)), ('b2f', ('!flt', a, 0.0))), 'options->lower_doubles_options & nir_lower_dsign'),
 
    # Address/offset calculations:
    # Drivers supporting imul24 should use the nir_lower_amul() pass, this
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index 10b82fec18aac..26e26bc151d7f 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -752,7 +752,7 @@ vgpu10_get_shader_param(struct pipe_screen *screen,
    .use_interpolated_input_intrinsics = true
 
 #define VGPU10_OPTIONS                                                        \
-   .lower_doubles_options = nir_lower_dfloor,                                 \
+   .lower_doubles_options = nir_lower_dfloor | nir_lower_dsign,               \
    .lower_fmod = true,                                                        \
    .lower_fpow = true
 
-- 
GitLab


From 597816464c423867814a6b8749c2b82b324c7b44 Mon Sep 17 00:00:00 2001
From: Eric Anholt <eric@anholt.net>
Date: Wed, 18 Oct 2023 08:30:22 +0200
Subject: [PATCH 4/4] glsl: Retire dround lowering.

We have competent lowering in NIR already available.

Drivers exposing CAP_DOUBLES but not SHADER_CAP_DROUND:
- d3d12 (NIR lowers ~0 if the underlying impl doesn't do floats)
- svga (Now sets the NIR lowering options)
- softpipe (Doesn't do GL4 so you can't use doubles anyway)
- llvmpipe (Lowers dround_even in NIR and passees the rest through
            successfully)
- zink (NIR lowers ~0 if the underlying impl doesn't do floats,
        otherwise passes things through successfully, except needed
        dround_even lowering to avoid lavapipe regression with
        native doubles)
- r600 (sets NIR rounding lowering flags, and lowers all fsign)
---
 docs/gallium/screen.rst                       |   2 -
 src/compiler/glsl/ir_optimization.h           |   1 -
 src/compiler/glsl/lower_instructions.cpp      | 186 +-----------------
 src/compiler/glsl/test_optpass.cpp            |   2 +-
 src/gallium/auxiliary/gallivm/lp_bld_limits.h |   1 -
 src/gallium/auxiliary/tgsi/tgsi_exec.h        |   1 -
 src/gallium/drivers/asahi/agx_pipe.c          |   1 -
 src/gallium/drivers/crocus/crocus_screen.c    |   2 -
 src/gallium/drivers/d3d12/d3d12_screen.cpp    |   3 -
 src/gallium/drivers/etnaviv/etnaviv_screen.c  |   1 -
 .../drivers/freedreno/freedreno_screen.c      |   1 -
 src/gallium/drivers/i915/i915_screen.c        |   1 -
 src/gallium/drivers/iris/iris_screen.c        |   2 -
 .../drivers/nouveau/nv30/nv30_screen.c        |   2 -
 .../drivers/nouveau/nv50/nv50_screen.c        |   1 -
 .../drivers/nouveau/nvc0/nvc0_screen.c        |   2 -
 src/gallium/drivers/panfrost/pan_screen.c     |   1 -
 src/gallium/drivers/r300/r300_screen.c        |   2 -
 src/gallium/drivers/r600/r600_pipe.c          |   2 -
 src/gallium/drivers/radeonsi/si_get.c         |   1 -
 src/gallium/drivers/svga/svga_screen.c        |   9 +-
 src/gallium/drivers/v3d/v3d_screen.c          |   1 -
 src/gallium/drivers/vc4/vc4_screen.c          |   1 -
 src/gallium/drivers/zink/zink_compiler.c      |   2 +-
 src/gallium/drivers/zink/zink_screen.c        |   3 -
 src/gallium/include/pipe/p_defines.h          |   1 -
 src/mesa/state_tracker/st_glsl_to_nir.cpp     |   9 +-
 27 files changed, 5 insertions(+), 236 deletions(-)

diff --git a/docs/gallium/screen.rst b/docs/gallium/screen.rst
index d1105eef8243a..e8efe0ce55472 100644
--- a/docs/gallium/screen.rst
+++ b/docs/gallium/screen.rst
@@ -740,8 +740,6 @@ support different features.
   samplers.
 * ``PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS``: The maximum number of texture
   sampler views. Must not be lower than PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS.
-* ``PIPE_SHADER_CAP_DROUND_SUPPORTED``: Whether double precision rounding
-  is supported. If it is, DTRUNC/DCEIL/DFLR/DROUND opcodes may be used.
 * ``PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE``: Whether the driver doesn't
   ignore tgsi_declaration_range::Last for shader inputs and outputs.
 * ``PIPE_SHADER_CAP_MAX_SHADER_BUFFERS``: Maximum number of memory buffers
diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 6e94adc11686e..56370a7b41258 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -55,7 +55,6 @@ bool do_tree_grafting(exec_list *instructions);
 bool do_vec_index_to_cond_assign(exec_list *instructions);
 void lower_discard_flow(exec_list *instructions);
 bool lower_instructions(exec_list *instructions,
-                        bool have_dround,
                         bool have_gpu_shader5);
 bool lower_clip_cull_distance(struct gl_shader_program *prog,
                               gl_linked_shader *shader);
diff --git a/src/compiler/glsl/lower_instructions.cpp b/src/compiler/glsl/lower_instructions.cpp
index 95339b80a86a9..df7c7435f72d9 100644
--- a/src/compiler/glsl/lower_instructions.cpp
+++ b/src/compiler/glsl/lower_instructions.cpp
@@ -28,13 +28,6 @@
  * must replace them with some other expression tree.  This pass lowers some
  * of the most common cases, allowing the lowering code to be implemented once
  * rather than in each driver backend.
- *
- * Currently supported transformations:
- * - DOPS_TO_DFRAC
- *
- * DOPS_TO_DFRAC:
- * --------------
- * Converts double trunc, ceil, floor, round to fract
  */
 
 #include "program/prog_instruction.h" /* for swizzle */
@@ -47,7 +40,6 @@
 #include <math.h>
 
 /* Operations for lower_instructions() */
-#define DOPS_TO_DFRAC      0x800
 #define FIND_LSB_TO_FLOAT_CAST    0x20000
 #define FIND_MSB_TO_FLOAT_CAST    0x40000
 #define IMUL_HIGH_TO_MUL          0x80000
@@ -70,11 +62,6 @@ private:
 
    void double_dot_to_fma(ir_expression *);
    void double_lrp(ir_expression *);
-   void dceil_to_dfrac(ir_expression *);
-   void dfloor_to_dfrac(ir_expression *);
-   void dround_even_to_dfrac(ir_expression *);
-   void dtrunc_to_dfrac(ir_expression *);
-   void dsign_to_csel(ir_expression *);
    void find_lsb_to_float_cast(ir_expression *ir);
    void find_msb_to_float_cast(ir_expression *ir);
    void imul_high_to_mul(ir_expression *ir);
@@ -95,11 +82,9 @@ private:
 #define lowering(x) (this->lower & x)
 
 bool
-lower_instructions(exec_list *instructions,
-                   bool have_dround, bool have_gpu_shader5)
+lower_instructions(exec_list *instructions,bool have_gpu_shader5)
 {
    unsigned what_to_lower =
-      (have_dround ? 0 : DOPS_TO_DFRAC) |
       /* Assume that if ARB_gpu_shader5 is not supported then all of the
        * extended integer functions need lowering.  It may be necessary to add
        * some caps for individual instructions.
@@ -170,150 +155,6 @@ lower_instructions_visitor::double_lrp(ir_expression *ir)
    this->progress = true;
 }
 
-void
-lower_instructions_visitor::dceil_to_dfrac(ir_expression *ir)
-{
-   /*
-    * frtemp = frac(x);
-    * temp = sub(x, frtemp);
-    * result = temp + ((frtemp != 0.0) ? 1.0 : 0.0);
-    */
-   ir_instruction &i = *base_ir;
-   ir_constant *zero = new(ir) ir_constant(0.0, ir->operands[0]->type->vector_elements);
-   ir_constant *one = new(ir) ir_constant(1.0, ir->operands[0]->type->vector_elements);
-   ir_variable *frtemp = new(ir) ir_variable(ir->operands[0]->type, "frtemp",
-                                             ir_var_temporary);
-
-   i.insert_before(frtemp);
-   i.insert_before(assign(frtemp, fract(ir->operands[0])));
-
-   ir->operation = ir_binop_add;
-   ir->init_num_operands();
-   ir->operands[0] = sub(ir->operands[0]->clone(ir, NULL), frtemp);
-   ir->operands[1] = csel(nequal(frtemp, zero), one, zero->clone(ir, NULL));
-
-   this->progress = true;
-}
-
-void
-lower_instructions_visitor::dfloor_to_dfrac(ir_expression *ir)
-{
-   /*
-    * frtemp = frac(x);
-    * result = sub(x, frtemp);
-    */
-   ir->operation = ir_binop_sub;
-   ir->init_num_operands();
-   ir->operands[1] = fract(ir->operands[0]->clone(ir, NULL));
-
-   this->progress = true;
-}
-void
-lower_instructions_visitor::dround_even_to_dfrac(ir_expression *ir)
-{
-   /*
-    * insane but works
-    * temp = x + 0.5;
-    * frtemp = frac(temp);
-    * t2 = sub(temp, frtemp);
-    * if (frac(x) == 0.5)
-    *     result = frac(t2 * 0.5) == 0 ? t2 : t2 - 1;
-    *  else
-    *     result = t2;
-
-    */
-   ir_instruction &i = *base_ir;
-   ir_variable *frtemp = new(ir) ir_variable(ir->operands[0]->type, "frtemp",
-                                             ir_var_temporary);
-   ir_variable *temp = new(ir) ir_variable(ir->operands[0]->type, "temp",
-                                           ir_var_temporary);
-   ir_variable *t2 = new(ir) ir_variable(ir->operands[0]->type, "t2",
-                                           ir_var_temporary);
-   ir_constant *p5 = new(ir) ir_constant(0.5, ir->operands[0]->type->vector_elements);
-   ir_constant *one = new(ir) ir_constant(1.0, ir->operands[0]->type->vector_elements);
-   ir_constant *zero = new(ir) ir_constant(0.0, ir->operands[0]->type->vector_elements);
-
-   i.insert_before(temp);
-   i.insert_before(assign(temp, add(ir->operands[0], p5)));
-
-   i.insert_before(frtemp);
-   i.insert_before(assign(frtemp, fract(temp)));
-
-   i.insert_before(t2);
-   i.insert_before(assign(t2, sub(temp, frtemp)));
-
-   ir->operation = ir_triop_csel;
-   ir->init_num_operands();
-   ir->operands[0] = equal(fract(ir->operands[0]->clone(ir, NULL)),
-                           p5->clone(ir, NULL));
-   ir->operands[1] = csel(equal(fract(mul(t2, p5->clone(ir, NULL))),
-                                zero),
-                          t2,
-                          sub(t2, one));
-   ir->operands[2] = new(ir) ir_dereference_variable(t2);
-
-   this->progress = true;
-}
-
-void
-lower_instructions_visitor::dtrunc_to_dfrac(ir_expression *ir)
-{
-   /*
-    * frtemp = frac(x);
-    * temp = sub(x, frtemp);
-    * result = x >= 0 ? temp : temp + (frtemp == 0.0) ? 0 : 1;
-    */
-   ir_rvalue *arg = ir->operands[0];
-   ir_instruction &i = *base_ir;
-
-   ir_constant *zero = new(ir) ir_constant(0.0, arg->type->vector_elements);
-   ir_constant *one = new(ir) ir_constant(1.0, arg->type->vector_elements);
-   ir_variable *frtemp = new(ir) ir_variable(arg->type, "frtemp",
-                                             ir_var_temporary);
-   ir_variable *temp = new(ir) ir_variable(ir->operands[0]->type, "temp",
-                                           ir_var_temporary);
-
-   i.insert_before(frtemp);
-   i.insert_before(assign(frtemp, fract(arg)));
-   i.insert_before(temp);
-   i.insert_before(assign(temp, sub(arg->clone(ir, NULL), frtemp)));
-
-   ir->operation = ir_triop_csel;
-   ir->init_num_operands();
-   ir->operands[0] = gequal(arg->clone(ir, NULL), zero);
-   ir->operands[1] = new (ir) ir_dereference_variable(temp);
-   ir->operands[2] = add(temp,
-                         csel(equal(frtemp, zero->clone(ir, NULL)),
-                              zero->clone(ir, NULL),
-                              one));
-
-   this->progress = true;
-}
-
-void
-lower_instructions_visitor::dsign_to_csel(ir_expression *ir)
-{
-   /*
-    * temp = x > 0.0 ? 1.0 : 0.0;
-    * result = x < 0.0 ? -1.0 : temp;
-    */
-   ir_rvalue *arg = ir->operands[0];
-   ir_constant *zero = new(ir) ir_constant(0.0, arg->type->vector_elements);
-   ir_constant *one = new(ir) ir_constant(1.0, arg->type->vector_elements);
-   ir_constant *neg_one = new(ir) ir_constant(-1.0, arg->type->vector_elements);
-
-   ir->operation = ir_triop_csel;
-   ir->init_num_operands();
-   ir->operands[0] = less(arg->clone(ir, NULL),
-                          zero->clone(ir, NULL));
-   ir->operands[1] = neg_one;
-   ir->operands[2] = csel(greater(arg, zero),
-                          one,
-                          zero->clone(ir, NULL));
-
-   this->progress = true;
-}
-
 void
 lower_instructions_visitor::find_lsb_to_float_cast(ir_expression *ir)
 {
@@ -661,31 +502,6 @@ lower_instructions_visitor::visit_leave(ir_expression *ir)
          double_lrp(ir);
       break;
 
-   case ir_unop_trunc:
-      if (lowering(DOPS_TO_DFRAC) && ir->type->is_double())
-         dtrunc_to_dfrac(ir);
-      break;
-
-   case ir_unop_ceil:
-      if (lowering(DOPS_TO_DFRAC) && ir->type->is_double())
-         dceil_to_dfrac(ir);
-      break;
-
-   case ir_unop_floor:
-      if (lowering(DOPS_TO_DFRAC) && ir->type->is_double())
-         dfloor_to_dfrac(ir);
-      break;
-
-   case ir_unop_round_even:
-      if (lowering(DOPS_TO_DFRAC) && ir->type->is_double())
-         dround_even_to_dfrac(ir);
-      break;
-
-   case ir_unop_sign:
-      if (lowering(DOPS_TO_DFRAC) && ir->type->is_double())
-         dsign_to_csel(ir);
-      break;
-
    case ir_unop_find_lsb:
       if (lowering(FIND_LSB_TO_FLOAT_CAST))
          find_lsb_to_float_cast(ir);
diff --git a/src/compiler/glsl/test_optpass.cpp b/src/compiler/glsl/test_optpass.cpp
index d875444587e40..36364c67f723e 100644
--- a/src/compiler/glsl/test_optpass.cpp
+++ b/src/compiler/glsl/test_optpass.cpp
@@ -91,7 +91,7 @@ do_optimization(struct exec_list *ir, const char *optimization,
       return do_vec_index_to_cond_assign(ir);
    } else if (sscanf(optimization, "lower_instructions ( %d ) ",
                      &int_0) == 1) {
-      return lower_instructions(ir, false, false);
+      return lower_instructions(ir, false);
    } else {
       printf("Unrecognized optimization %s\n", optimization);
       exit(EXIT_FAILURE);
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_limits.h b/src/gallium/auxiliary/gallivm/lp_bld_limits.h
index 8deae32a2a7a3..bf93b5c0aeb7f 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_limits.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_limits.h
@@ -147,7 +147,6 @@ gallivm_get_shader_param(enum pipe_shader_cap param)
    case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return 1;
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTER_BUFFERS:
       return 0;
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.h b/src/gallium/auxiliary/tgsi/tgsi_exec.h
index 6213bb8a05aa2..6d3cb47384f58 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.h
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.h
@@ -482,7 +482,6 @@ tgsi_exec_get_shader_param(enum pipe_shader_cap param)
       return 1;
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return 1;
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTER_BUFFERS:
       return 0;
diff --git a/src/gallium/drivers/asahi/agx_pipe.c b/src/gallium/drivers/asahi/agx_pipe.c
index a3795b1b9c14c..01b2faab859c0 100644
--- a/src/gallium/drivers/asahi/agx_pipe.c
+++ b/src/gallium/drivers/asahi/agx_pipe.c
@@ -1871,7 +1871,6 @@ agx_get_shader_param(struct pipe_screen *pscreen, enum pipe_shader_type shader,
       return false;
 
    case PIPE_SHADER_CAP_INT64_ATOMICS:
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return 0;
 
diff --git a/src/gallium/drivers/crocus/crocus_screen.c b/src/gallium/drivers/crocus/crocus_screen.c
index 464bebfc230be..10927b1ea21fe 100644
--- a/src/gallium/drivers/crocus/crocus_screen.c
+++ b/src/gallium/drivers/crocus/crocus_screen.c
@@ -523,8 +523,6 @@ crocus_get_shader_param(struct pipe_screen *pscreen,
       return 0;
    case PIPE_SHADER_CAP_SUPPORTED_IRS:
       return 1 << PIPE_SHADER_IR_NIR;
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-      return 1;
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
    case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
    case PIPE_SHADER_CAP_FP16_DERIVATIVES:
diff --git a/src/gallium/drivers/d3d12/d3d12_screen.cpp b/src/gallium/drivers/d3d12/d3d12_screen.cpp
index 6cdc043627f63..4377361f826ff 100644
--- a/src/gallium/drivers/d3d12/d3d12_screen.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_screen.cpp
@@ -472,9 +472,6 @@ d3d12_get_shader_param(struct pipe_screen *pscreen,
        */
       return PIPE_MAX_SAMPLERS;
 
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-      return 0; /* not implemented */
-
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return 0; /* no idea */
 
diff --git a/src/gallium/drivers/etnaviv/etnaviv_screen.c b/src/gallium/drivers/etnaviv/etnaviv_screen.c
index fc3f63fbdc8a7..8f8e7c8d42836 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_screen.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_screen.c
@@ -419,7 +419,6 @@ etna_screen_get_shader_param(struct pipe_screen *pscreen,
       return shader == PIPE_SHADER_FRAGMENT
                 ? screen->specs.max_ps_uniforms * sizeof(float[4])
                 : screen->specs.max_vs_uniforms * sizeof(float[4]);
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return false;
    case PIPE_SHADER_CAP_SUPPORTED_IRS:
diff --git a/src/gallium/drivers/freedreno/freedreno_screen.c b/src/gallium/drivers/freedreno/freedreno_screen.c
index a2904a5cbb65c..6021e062bd879 100644
--- a/src/gallium/drivers/freedreno/freedreno_screen.c
+++ b/src/gallium/drivers/freedreno/freedreno_screen.c
@@ -737,7 +737,6 @@ fd_screen_get_shader_param(struct pipe_screen *pscreen,
       /* a2xx compiler doesn't handle indirect: */
       return is_ir3(screen) ? 1 : 0;
    case PIPE_SHADER_CAP_SUBROUTINES:
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTER_BUFFERS:
diff --git a/src/gallium/drivers/i915/i915_screen.c b/src/gallium/drivers/i915/i915_screen.c
index c0172359f2800..10b21c323dcff 100644
--- a/src/gallium/drivers/i915/i915_screen.c
+++ b/src/gallium/drivers/i915/i915_screen.c
@@ -381,7 +381,6 @@ i915_get_shader_param(struct pipe_screen *screen, enum pipe_shader_type shader,
       case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
       case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
          return I915_TEX_UNITS;
-      case PIPE_SHADER_CAP_DROUND_SUPPORTED:
       case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
       case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
diff --git a/src/gallium/drivers/iris/iris_screen.c b/src/gallium/drivers/iris/iris_screen.c
index accc1250e6dcd..96621660631fe 100644
--- a/src/gallium/drivers/iris/iris_screen.c
+++ b/src/gallium/drivers/iris/iris_screen.c
@@ -554,8 +554,6 @@ iris_get_shader_param(struct pipe_screen *pscreen,
          irs |= 1 << PIPE_SHADER_IR_NIR_SERIALIZED;
       return irs;
    }
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-      return 1;
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
    case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
       return 0;
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_screen.c b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
index ee7f132b2053b..dfcebf56f9be9 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_screen.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
@@ -359,7 +359,6 @@ nv30_screen_get_shader_param(struct pipe_screen *pscreen,
       case PIPE_SHADER_CAP_FP16_CONST_BUFFERS:
       case PIPE_SHADER_CAP_INT16:
       case PIPE_SHADER_CAP_GLSL_16BIT_CONSTS:
-      case PIPE_SHADER_CAP_DROUND_SUPPORTED:
       case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
       case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
@@ -408,7 +407,6 @@ nv30_screen_get_shader_param(struct pipe_screen *pscreen,
       case PIPE_SHADER_CAP_FP16_CONST_BUFFERS:
       case PIPE_SHADER_CAP_INT16:
       case PIPE_SHADER_CAP_GLSL_16BIT_CONSTS:
-      case PIPE_SHADER_CAP_DROUND_SUPPORTED:
       case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
       case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_screen.c b/src/gallium/drivers/nouveau/nv50/nv50_screen.c
index 5b38bdab9a906..051c31d9785a1 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_screen.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_screen.c
@@ -374,7 +374,6 @@ nv50_screen_get_shader_param(struct pipe_screen *pscreen,
       return shader == PIPE_SHADER_COMPUTE ? NV50_MAX_GLOBALS - 1 : 0;
    case PIPE_SHADER_CAP_SUPPORTED_IRS:
       return 1 << PIPE_SHADER_IR_NIR;
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
    case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTER_BUFFERS:
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
index 7057a68b1db5f..eb21b09558e36 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
@@ -438,8 +438,6 @@ nvc0_screen_get_shader_param(struct pipe_screen *pscreen,
       return 1;
    case PIPE_SHADER_CAP_INTEGERS:
       return 1;
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-      return 1;
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
    case PIPE_SHADER_CAP_INT64_ATOMICS:
    case PIPE_SHADER_CAP_FP16:
diff --git a/src/gallium/drivers/panfrost/pan_screen.c b/src/gallium/drivers/panfrost/pan_screen.c
index 5517c9891cb93..363fc22cdead3 100644
--- a/src/gallium/drivers/panfrost/pan_screen.c
+++ b/src/gallium/drivers/panfrost/pan_screen.c
@@ -459,7 +459,6 @@ panfrost_get_shader_param(struct pipe_screen *screen,
       return false;
 
    case PIPE_SHADER_CAP_INT64_ATOMICS:
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return 0;
 
diff --git a/src/gallium/drivers/r300/r300_screen.c b/src/gallium/drivers/r300/r300_screen.c
index 1500c07f8414e..776a5aca4108e 100644
--- a/src/gallium/drivers/r300/r300_screen.c
+++ b/src/gallium/drivers/r300/r300_screen.c
@@ -311,7 +311,6 @@ static int r300_get_shader_param(struct pipe_screen *pscreen,
         case PIPE_SHADER_CAP_FP16_CONST_BUFFERS:
         case PIPE_SHADER_CAP_INT16:
         case PIPE_SHADER_CAP_GLSL_16BIT_CONSTS:
-        case PIPE_SHADER_CAP_DROUND_SUPPORTED:
         case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
         case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
         case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
@@ -400,7 +399,6 @@ static int r300_get_shader_param(struct pipe_screen *pscreen,
         case PIPE_SHADER_CAP_INT64_ATOMICS:
         case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
         case PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS:
-        case PIPE_SHADER_CAP_DROUND_SUPPORTED:
         case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
         case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
         case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
diff --git a/src/gallium/drivers/r600/r600_pipe.c b/src/gallium/drivers/r600/r600_pipe.c
index ab758cca8332c..cb381c3805d66 100644
--- a/src/gallium/drivers/r600/r600_pipe.c
+++ b/src/gallium/drivers/r600/r600_pipe.c
@@ -615,8 +615,6 @@ static int r600_get_shader_param(struct pipe_screen* pscreen,
 		ir |= 1 << PIPE_SHADER_IR_NIR;
 		return ir;
 	}
-	case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-		return 0;
 	case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
 	case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
 		if (rscreen->b.family >= CHIP_CEDAR &&
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index e794995830e57..c9cdb391b3b3c 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -485,7 +485,6 @@ static int si_get_shader_param(struct pipe_screen *pscreen, enum pipe_shader_typ
    case PIPE_SHADER_CAP_INTEGERS:
    case PIPE_SHADER_CAP_INT64_ATOMICS:
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
    case PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR: /* lowered in finalize_nir */
    case PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR: /* lowered in finalize_nir */
       return 1;
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index 26e26bc151d7f..07dfaf60a8b8d 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -534,7 +534,6 @@ vgpu9_get_shader_param(struct pipe_screen *screen,
          return 16;
       case PIPE_SHADER_CAP_SUPPORTED_IRS:
          return (1 << PIPE_SHADER_IR_TGSI) | (1 << PIPE_SHADER_IR_NIR);
-      case PIPE_SHADER_CAP_DROUND_SUPPORTED:
       case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
       case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
@@ -596,7 +595,6 @@ vgpu9_get_shader_param(struct pipe_screen *screen,
          return 0;
       case PIPE_SHADER_CAP_SUPPORTED_IRS:
          return (1 << PIPE_SHADER_IR_TGSI) | (1 << PIPE_SHADER_IR_NIR);
-      case PIPE_SHADER_CAP_DROUND_SUPPORTED:
       case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       case PIPE_SHADER_CAP_MAX_SHADER_BUFFERS:
       case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
@@ -709,11 +707,6 @@ vgpu10_get_shader_param(struct pipe_screen *screen,
          return (1 << PIPE_SHADER_IR_TGSI) | (1 << PIPE_SHADER_IR_NIR);
       else
          return 0;
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-      /* For the above cases, we rely on the GLSL compiler to translate/lower
-       * the TGIS instruction into other instructions we do support.
-       */
-      return 0;
 
    case PIPE_SHADER_CAP_MAX_SHADER_IMAGES:
       return sws->have_gl43 ? SVGA_MAX_IMAGES : 0;
@@ -752,7 +745,7 @@ vgpu10_get_shader_param(struct pipe_screen *screen,
    .use_interpolated_input_intrinsics = true
 
 #define VGPU10_OPTIONS                                                        \
-   .lower_doubles_options = nir_lower_dfloor | nir_lower_dsign,               \
+   .lower_doubles_options = nir_lower_dfloor | nir_lower_dsign | nir_lower_dceil | nir_lower_dtrunc | nir_lower_dround_even, \
    .lower_fmod = true,                                                        \
    .lower_fpow = true
 
diff --git a/src/gallium/drivers/v3d/v3d_screen.c b/src/gallium/drivers/v3d/v3d_screen.c
index 6eeb86dabf450..08d02c9a73bd8 100644
--- a/src/gallium/drivers/v3d/v3d_screen.c
+++ b/src/gallium/drivers/v3d/v3d_screen.c
@@ -432,7 +432,6 @@ v3d_screen_get_shader_param(struct pipe_screen *pscreen, enum pipe_shader_type s
         case PIPE_SHADER_CAP_FP16_CONST_BUFFERS:
         case PIPE_SHADER_CAP_INT16:
         case PIPE_SHADER_CAP_GLSL_16BIT_CONSTS:
-        case PIPE_SHADER_CAP_DROUND_SUPPORTED:
         case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
         case PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED:
         case PIPE_SHADER_CAP_MAX_HW_ATOMIC_COUNTERS:
diff --git a/src/gallium/drivers/vc4/vc4_screen.c b/src/gallium/drivers/vc4/vc4_screen.c
index c0d4e6406f0f8..6da53d63a65c8 100644
--- a/src/gallium/drivers/vc4/vc4_screen.c
+++ b/src/gallium/drivers/vc4/vc4_screen.c
@@ -293,7 +293,6 @@ vc4_screen_get_shader_param(struct pipe_screen *pscreen,
         case PIPE_SHADER_CAP_FP16_CONST_BUFFERS:
         case PIPE_SHADER_CAP_INT16:
         case PIPE_SHADER_CAP_GLSL_16BIT_CONSTS:
-        case PIPE_SHADER_CAP_DROUND_SUPPORTED:
         case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
                 return 0;
         case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index 9193a938825c2..1be67e5a6fdf2 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -1233,7 +1233,7 @@ zink_screen_init_compiler(struct zink_screen *screen)
       .lower_usub_sat = true,
       .lower_vector_cmp = true,
       .lower_int64_options = 0,
-      .lower_doubles_options = 0,
+      .lower_doubles_options = nir_lower_dround_even,
       .lower_uniforms_to_ubo = true,
       .has_fsub = true,
       .has_isub = true,
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index 3ebfb3e5649f5..ad216c1728cf9 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -1240,9 +1240,6 @@ zink_get_shader_param(struct pipe_screen *pscreen,
                        screen->info.props.limits.maxPerStageDescriptorSampledImages),
                   PIPE_MAX_SAMPLERS);
 
-   case PIPE_SHADER_CAP_DROUND_SUPPORTED:
-      return 0; /* not implemented */
-
    case PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE:
       return 0; /* no idea */
 
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 38ab5f4a15800..cefce408ef0a3 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -1027,7 +1027,6 @@ enum pipe_shader_cap
    PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS,
    PIPE_SHADER_CAP_TGSI_SQRT_SUPPORTED,
    PIPE_SHADER_CAP_MAX_SAMPLER_VIEWS,
-   PIPE_SHADER_CAP_DROUND_SUPPORTED, /* all rounding modes */
    PIPE_SHADER_CAP_TGSI_ANY_INOUT_DECL_RANGE,
    PIPE_SHADER_CAP_MAX_SHADER_BUFFERS,
    PIPE_SHADER_CAP_SUPPORTED_IRS,
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index 1d6e4a2e46153..0255b0cca9044 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -488,7 +488,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
                     struct gl_shader_program *shader_program)
 {
    struct st_context *st = st_context(ctx);
-   struct pipe_screen *pscreen = st->screen;
    struct gl_linked_shader *linked_shader[MESA_SHADER_STAGES];
    unsigned num_shaders = 0;
 
@@ -509,19 +508,13 @@ st_link_glsl_to_nir(struct gl_context *ctx,
 
          struct gl_linked_shader *shader = shader_program->_LinkedShaders[i];
          exec_list *ir = shader->ir;
-         gl_shader_stage stage = shader->Stage;
-
-         enum pipe_shader_type ptarget = pipe_shader_type_from_mesa(stage);
-         bool have_dround = pscreen->get_shader_param(pscreen, ptarget,
-                                                      PIPE_SHADER_CAP_DROUND_SUPPORTED);
 
          lower_packing_builtins(ir, ctx->Extensions.ARB_shading_language_packing,
                                 ctx->Extensions.ARB_gpu_shader5,
                                 ctx->st->has_half_float_packing);
          do_mat_op_to_vec(ir);
 
-         lower_instructions(ir, have_dround,
-                            ctx->Extensions.ARB_gpu_shader5);
+         lower_instructions(ir, ctx->Extensions.ARB_gpu_shader5);
 
          do_vec_index_to_cond_assign(ir);
 
-- 
GitLab

