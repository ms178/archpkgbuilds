From 7da42cfa62bcb9d9d0dcf5bb8f24cc3145590520 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 11 Mar 2022 17:14:38 +0100
Subject: [PATCH 1/2] aco: avoid unnecessary copies in emit_wqm()

No fossil-db changes.
---
 src/amd/compiler/aco_instruction_selection.cpp | 13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 34e82a11b7f4..815426ae3a50 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -169,19 +169,16 @@ emit_mbcnt(isel_context* ctx, Temp dst, Operand mask = Operand(), Operand base =
 Temp
 emit_wqm(Builder& bld, Temp src, Temp dst = Temp(0, s1), bool program_needs_wqm = false)
 {
-   if (!dst.id())
-      dst = bld.tmp(src.regClass());
-
-   assert(src.size() == dst.size());
-
    if (bld.program->stage != fragment_fs) {
       if (!dst.id())
          return src;
-
-      bld.copy(Definition(dst), src);
-      return dst;
+      else
+         return bld.copy(Definition(dst), src);
+   } else if (!dst.id()) {
+      dst = bld.tmp(src.regClass());
    }
 
+   assert(src.size() == dst.size());
    bld.pseudo(aco_opcode::p_wqm, Definition(dst), src);
    bld.program->needs_wqm |= program_needs_wqm;
    return dst;
-- 
GitLab


From dade6b868c9fa5df137d4d710635f490dedf1ce7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Fri, 11 Mar 2022 19:12:50 +0100
Subject: [PATCH 2/2] aco: Avoid live-range splits in Exact mode

Because the data register of atomic VMEM instructions
is shared between src and dst, it might be necessary
to create live-range splits during RA.
Make the live-range splits explicit in WQM mode.

Totals from 7 (0.01% of 134913) affected shaders: (GFX10.3)
Latency: 17209 -> 17210 (+0.01%)
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 30 ++++++++++++++++++++++-
 1 file changed, 29 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index e1dd39299108..78ac3c0f6740 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -476,6 +476,33 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
    return i;
 }
 
+/* Avoid live-range splits in Exact mode:
+ * Because the data register of atomic VMEM instructions
+ * is shared between src and dst, it might be necessary
+ * to create live-range splits during RA.
+ * Make the live-range splits explicit in WQM mode.
+ */
+void
+handle_atomic_data(exec_ctx& ctx, Builder& bld, unsigned block_idx, aco_ptr<Instruction>& instr)
+{
+   /* check if this is an atomic VMEM instruction */
+   int idx = -1;
+   if (!instr->isVMEM() || instr->definitions.empty())
+      return;
+   else if (instr->isMIMG())
+      idx = instr->operands[2].isTemp() ? 2 : -1;
+   else if (instr->operands.size() == 4)
+      idx = 3;
+
+   if (idx != -1) {
+      /* insert explicit copy of atomic data in WQM-mode */
+      transition_to_WQM(ctx, bld, block_idx);
+      Temp data = instr->operands[idx].getTemp();
+      data = bld.copy(bld.def(data.regClass()), data);
+      instr->operands[idx].setTemp(data);
+   }
+}
+
 void
 process_instructions(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>& instructions,
                      unsigned idx)
@@ -511,7 +538,8 @@ process_instructions(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instructio
       if (needs == WQM && state != WQM) {
          transition_to_WQM(ctx, bld, block->index);
          state = WQM;
-      } else if (needs == Exact && state != Exact) {
+      } else if (needs == Exact) {
+         handle_atomic_data(ctx, bld, block->index, instr);
          transition_to_Exact(ctx, bld, block->index);
          state = Exact;
       }
-- 
GitLab

