From d5747753fc5e752ad7fabadf75065fa245377ede Mon Sep 17 00:00:00 2001
From: Antonio Ospite <antonio.ospite@collabora.com>
Date: Thu, 24 Jul 2025 13:40:37 +0200
Subject: [PATCH 1/2] glsl: rename state name to avoid conflicts with future
 changes

A subsequent change is going to add a macro named UNREACHABLE() to
src/util/macros.h which will conflict with the lexer state name
UNREACHABLE in src/compiler/glsl/glcpp/glcpp-lex.l

Use the name NOT_REACHABLE in glcpp-lex.l instead of UNREACHABLE, just
to avoid the name clash with the future macro.
---
 src/compiler/glsl/glcpp/glcpp-lex.l | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/glcpp/glcpp-lex.l b/src/compiler/glsl/glcpp/glcpp-lex.l
index 63b539b4bd37b..0f69715366569 100644
--- a/src/compiler/glsl/glcpp/glcpp-lex.l
+++ b/src/compiler/glsl/glcpp/glcpp-lex.l
@@ -178,7 +178,7 @@ glcpp_lex_update_state_per_token (glcpp_parser_t *parser, int token)
 	 * update the "Internal compiler error" catch-all rule near the end of
 	 * this file. */
 
-%x COMMENT DEFINE DONE HASH NEWLINE_CATCHUP UNREACHABLE
+%x COMMENT DEFINE DONE HASH NEWLINE_CATCHUP NOT_REACHABLE
 
 SPACE		[[:space:]]
 NONSPACE	[^[:space:]]
@@ -602,11 +602,11 @@ PATH			["][]^./ _A-Za-z0-9+*%[(){}|&~=!:;,?-]*["]
 <*>. {
 	glcpp_error(yylloc, yyextra, "Internal compiler error: Unexpected character: %s", yytext);
 
-	/* We don't actually use the UNREACHABLE start condition. We
+	/* We don't actually use the NOT_REACHABLE start condition. We
 	only have this block here so that we can pretend to call some
 	generated functions, (to avoid "defined but not used"
 	warnings. */
-        if (YY_START == UNREACHABLE) {
+        if (YY_START == NOT_REACHABLE) {
 		unput('.');
 		yy_top_state(yyextra);
 	}
-- 
GitLab


From e993ee9b112c455864b51176368ad757ea1c7aaf Mon Sep 17 00:00:00 2001
From: Antonio Ospite <antonio.ospite@collabora.com>
Date: Wed, 23 Jul 2025 09:17:35 +0200
Subject: [PATCH 2/2] build: avoid redefining unreachable() which is standard
 in C23

In the C23 standard unreachable() is now a predefined function-like
macro in <stddef.h>

See https://android.googlesource.com/platform/bionic/+/HEAD/docs/c23.md#is-now-a-predefined-function_like-macro-in

And this causes build errors when building for C23:

-----------------------------------------------------------------------
In file included from ../src/util/log.h:30,
                 from ../src/util/log.c:30:
../src/util/macros.h:123:9: warning: "unreachable" redefined
  123 | #define unreachable(str)    \
      |         ^~~~~~~~~~~
In file included from ../src/util/macros.h:31:
/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h:456:9: note: this is the location of the previous definition
  456 | #define unreachable() (__builtin_unreachable ())
      |         ^~~~~~~~~~~
-----------------------------------------------------------------------

So don't redefine it with the same name when already available, and use
the name UNREACHABLE() for the old definition to also signify it's
a macro.

Using a different name also makes sense because the behavior of the
macro was extending the one of __builtin_unreachable() anyway, and it
also had a different signature than the standard unreachable().

This change improves the chances of building mesa with the C23 standard,
which for instance is the default in recent AOSP versions.

The users of the macro were updated with the following command line:

  git grep -l -P 'unreachable\([^)]*?"' | sort | uniq | \
  while read file; \
    do sed -e 's/unreachable(\([^"]*\)"/UNREACHABLE(\1"/g' -i "$file"; \
  done

Also define unreachable(), without arguments, when it's not available
already, since some parts of the mesa code are also using the variant
with no arguments.
---
 src/amd/common/ac_descriptors.c               |  6 +-
 src/amd/common/ac_gpu_info.c                  |  4 +-
 src/amd/common/ac_parse_ib.c                  |  2 +-
 src/amd/common/ac_pm4.c                       |  2 +-
 src/amd/common/ac_rgp.c                       |  8 +-
 src/amd/common/ac_rtld.c                      |  2 +-
 src/amd/common/ac_shader_util.c               | 36 ++++----
 src/amd/common/ac_shadowed_regs.c             |  4 +-
 src/amd/common/ac_surface.c                   | 24 +++---
 src/amd/common/ac_surface_meta_address_test.c |  4 +-
 src/amd/common/ac_surface_modifier_test.c     |  4 +-
 src/amd/common/amd_family.c                   |  2 +-
 src/amd/common/nir/ac_nir.c                   |  6 +-
 src/amd/common/nir/ac_nir_cull.c              |  2 +-
 .../nir/ac_nir_lower_image_opcodes_cdna.c     |  8 +-
 .../nir/ac_nir_lower_intrinsics_to_args.c     | 10 +--
 src/amd/common/nir/ac_nir_lower_legacy_gs.c   |  2 +-
 src/amd/common/nir/ac_nir_lower_ngg.c         |  4 +-
 src/amd/common/nir/ac_nir_lower_ngg_gs.c      |  2 +-
 src/amd/common/nir/ac_nir_lower_ngg_mesh.c    | 10 +--
 src/amd/common/nir/ac_nir_lower_ps_late.c     |  4 +-
 src/amd/common/nir/ac_nir_lower_resinfo.c     |  4 +-
 .../nir/ac_nir_lower_taskmesh_io_to_mem.c     |  4 +-
 .../common/nir/ac_nir_lower_tess_io_to_mem.c  |  2 +-
 src/amd/common/nir/ac_nir_lower_tex.c         |  2 +-
 .../nir/ac_nir_meta_cs_clear_copy_buffer.c    |  2 +-
 src/amd/compiler/aco_assembler.cpp            | 10 +--
 src/amd/compiler/aco_builder_h.py             |  2 +-
 src/amd/compiler/aco_insert_exec_mask.cpp     |  2 +-
 src/amd/compiler/aco_ir.cpp                   |  2 +-
 src/amd/compiler/aco_ir.h                     |  2 +-
 src/amd/compiler/aco_lower_branches.cpp       |  2 +-
 src/amd/compiler/aco_lower_to_hw_instr.cpp    |  4 +-
 src/amd/compiler/aco_opt_value_numbering.cpp  |  2 +-
 src/amd/compiler/aco_optimizer.cpp            |  6 +-
 src/amd/compiler/aco_optimizer_postRA.cpp     |  2 +-
 src/amd/compiler/aco_print_ir.cpp             |  4 +-
 src/amd/compiler/aco_register_allocation.cpp  |  6 +-
 src/amd/compiler/aco_spill.cpp                |  4 +-
 .../instruction_selection/aco_isel_setup.cpp  |  4 +-
 .../instruction_selection/aco_select_nir.cpp  |  6 +-
 .../aco_select_nir_alu.cpp                    | 10 +--
 .../aco_select_nir_intrinsics.cpp             | 54 ++++++------
 .../aco_select_ps_epilog.cpp                  |  2 +-
 src/amd/llvm/ac_llvm_build.c                  | 42 ++++-----
 src/amd/llvm/ac_llvm_helper.cpp               |  2 +-
 src/amd/llvm/ac_nir_to_llvm.c                 | 12 +--
 src/amd/vulkan/layers/radv_sqtt_layer.c       |  4 +-
 src/amd/vulkan/meta/radv_meta.c               |  2 +-
 src/amd/vulkan/meta/radv_meta.h               |  2 +-
 src/amd/vulkan/meta/radv_meta_astc_decode.c   |  2 +-
 src/amd/vulkan/meta/radv_meta_blit.c          |  6 +-
 src/amd/vulkan/meta/radv_meta_blit2d.c        |  8 +-
 src/amd/vulkan/meta/radv_meta_clear.c         |  2 +-
 src/amd/vulkan/meta/radv_meta_copy.c          |  4 +-
 src/amd/vulkan/meta/radv_meta_fast_clear.c    |  4 +-
 src/amd/vulkan/meta/radv_meta_resolve.c       |  2 +-
 src/amd/vulkan/nir/radv_meta_nir.c            |  8 +-
 src/amd/vulkan/nir/radv_nir_lower_abi.c       |  6 +-
 .../nir/radv_nir_lower_cooperative_matrix.c   |  2 +-
 src/amd/vulkan/nir/radv_nir_lower_io.c        |  2 +-
 .../vulkan/nir/radv_nir_lower_ray_queries.c   |  4 +-
 .../vulkan/nir/radv_nir_opt_tid_function.c    |  2 +-
 src/amd/vulkan/nir/radv_nir_rt_shader.c       |  8 +-
 src/amd/vulkan/radv_acceleration_structure.c  |  4 +-
 src/amd/vulkan/radv_cmd_buffer.c              | 40 ++++-----
 src/amd/vulkan/radv_cs.h                      |  4 +-
 src/amd/vulkan/radv_descriptors.c             |  2 +-
 src/amd/vulkan/radv_descriptors.h             |  2 +-
 src/amd/vulkan/radv_dgc.c                     |  4 +-
 src/amd/vulkan/radv_formats.c                 |  4 +-
 src/amd/vulkan/radv_formats.h                 |  2 +-
 src/amd/vulkan/radv_image.c                   |  4 +-
 src/amd/vulkan/radv_image_view.c              |  2 +-
 src/amd/vulkan/radv_nir_to_llvm.c             |  2 +-
 src/amd/vulkan/radv_perfcounter.c             |  2 +-
 src/amd/vulkan/radv_physical_device.c         |  4 +-
 src/amd/vulkan/radv_pipeline.c                |  6 +-
 src/amd/vulkan/radv_pipeline_binary.c         |  2 +-
 src/amd/vulkan/radv_pipeline_graphics.c       | 10 +--
 src/amd/vulkan/radv_pipeline_graphics.h       |  4 +-
 src/amd/vulkan/radv_pipeline_rt.c             |  4 +-
 src/amd/vulkan/radv_printf.c                  |  2 +-
 src/amd/vulkan/radv_query.c                   | 16 ++--
 src/amd/vulkan/radv_queue.c                   |  4 +-
 src/amd/vulkan/radv_rmv.c                     |  6 +-
 src/amd/vulkan/radv_rra.c                     |  2 +-
 src/amd/vulkan/radv_rra_gfx12.c               |  2 +-
 src/amd/vulkan/radv_sampler.c                 |  4 +-
 src/amd/vulkan/radv_sdma.c                    |  4 +-
 src/amd/vulkan/radv_shader.c                  | 16 ++--
 src/amd/vulkan/radv_shader.h                  |  2 +-
 src/amd/vulkan/radv_shader_args.c             |  2 +-
 src/amd/vulkan/radv_shader_info.c             |  4 +-
 src/amd/vulkan/radv_shader_object.c           |  2 +-
 src/amd/vulkan/radv_sqtt.c                    |  6 +-
 src/amd/vulkan/radv_video.c                   |  6 +-
 src/amd/vulkan/radv_video_enc.c               |  2 +-
 src/amd/vulkan/tests/helpers.cpp              |  2 +-
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c |  6 +-
 .../vulkan/winsys/amdgpu/radv_amdgpu_winsys.c |  2 +-
 src/asahi/compiler/agx_compile.c              | 44 +++++-----
 src/asahi/compiler/agx_compiler.h             |  8 +-
 src/asahi/compiler/agx_ir.c                   |  2 +-
 src/asahi/compiler/agx_nir_lower_address.c    |  2 +-
 src/asahi/compiler/agx_nir_lower_texture.c    |  2 +-
 src/asahi/compiler/agx_opcodes.h.py           |  2 +-
 src/asahi/compiler/agx_optimizer.c            |  2 +-
 src/asahi/compiler/agx_pack.c                 |  4 +-
 src/asahi/compiler/agx_performance.c          |  2 +-
 src/asahi/compiler/agx_print.c                |  4 +-
 src/asahi/compiler/agx_register_allocate.c    |  2 +-
 src/asahi/compiler/agx_spill.c                |  2 +-
 src/asahi/compiler/agx_validate.c             |  4 +-
 src/asahi/compiler/agx_validate_ra.c          |  2 +-
 src/asahi/genxml/agx_pack_header.h            |  2 +-
 src/asahi/layout/layout.c                     |  4 +-
 src/asahi/layout/layout.h                     |  8 +-
 src/asahi/layout/tiling.cc                    |  2 +-
 src/asahi/lib/agx_border.c                    |  4 +-
 src/asahi/lib/agx_helpers.h                   |  8 +-
 src/asahi/lib/agx_nir_lower_gs.c              |  4 +-
 src/asahi/lib/agx_nir_lower_vbo.c             |  2 +-
 src/asahi/lib/agx_nir_prolog_epilog.c         |  2 +-
 src/asahi/lib/agx_tilebuffer.c                |  4 +-
 src/asahi/lib/decode.c                        |  6 +-
 src/asahi/libagx/compression.cl               |  2 +-
 src/asahi/libagx/geometry.h                   |  4 +-
 src/asahi/vulkan/hk_cmd_buffer.h              |  2 +-
 src/asahi/vulkan/hk_cmd_draw.c                | 14 +--
 src/asahi/vulkan/hk_cmd_meta.c                |  6 +-
 src/asahi/vulkan/hk_descriptor_set_layout.c   |  2 +-
 src/asahi/vulkan/hk_device_memory.c           |  2 +-
 src/asahi/vulkan/hk_image.c                   | 14 +--
 src/asahi/vulkan/hk_image_view.c              |  8 +-
 src/asahi/vulkan/hk_nir_lower_descriptors.c   | 10 +--
 src/asahi/vulkan/hk_query_pool.c              |  4 +-
 src/asahi/vulkan/hk_queue.c                   |  4 +-
 src/asahi/vulkan/hk_sampler.c                 |  4 +-
 src/asahi/vulkan/hk_shader.h                  |  2 +-
 src/broadcom/clif/clif_dump.c                 |  2 +-
 src/broadcom/common/v3d_tiling.c              |  6 +-
 src/broadcom/common/v3d_util.c                |  6 +-
 src/broadcom/common/v3d_util.h                |  4 +-
 src/broadcom/compiler/nir_to_vir.c            | 30 +++----
 src/broadcom/compiler/qpu_schedule.c          |  4 +-
 .../compiler/v3d_nir_lower_image_load_store.c |  6 +-
 src/broadcom/compiler/v3d_nir_lower_io.c      |  4 +-
 src/broadcom/compiler/v3d_tex.c               |  8 +-
 src/broadcom/compiler/vir.c                   |  6 +-
 src/broadcom/compiler/vir_opt_dead_code.c     |  2 +-
 src/broadcom/compiler/vir_register_allocate.c |  4 +-
 src/broadcom/qpu/qpu_instr.c                  | 16 ++--
 src/broadcom/qpu/qpu_pack.c                   |  6 +-
 src/broadcom/simulator/v3d_simulator.h        |  2 +-
 src/broadcom/simulator/v3dx_simulator.c       |  2 +-
 src/broadcom/vulkan/v3dv_cmd_buffer.c         |  4 +-
 src/broadcom/vulkan/v3dv_descriptor_set.c     | 10 +--
 src/broadcom/vulkan/v3dv_device.c             |  2 +-
 src/broadcom/vulkan/v3dv_formats.c            |  4 +-
 src/broadcom/vulkan/v3dv_image.c              |  2 +-
 src/broadcom/vulkan/v3dv_meta_clear.c         |  4 +-
 src/broadcom/vulkan/v3dv_meta_copy.c          | 36 ++++----
 src/broadcom/vulkan/v3dv_pipeline.c           | 12 +--
 src/broadcom/vulkan/v3dv_private.h            |  8 +-
 src/broadcom/vulkan/v3dv_query.c              | 10 +--
 src/broadcom/vulkan/v3dv_queue.c              |  2 +-
 src/broadcom/vulkan/v3dv_uniforms.c           |  8 +-
 src/broadcom/vulkan/v3dvx_cmd_buffer.c        |  6 +-
 src/broadcom/vulkan/v3dvx_device.c            |  2 +-
 src/broadcom/vulkan/v3dvx_formats.c           |  2 +-
 src/broadcom/vulkan/v3dvx_pipeline.c          |  4 +-
 src/compiler/clc/clc_helpers.cpp              | 10 +--
 src/compiler/glsl/ast_function.cpp            |  2 +-
 src/compiler/glsl/ast_to_hir.cpp              | 26 +++---
 src/compiler/glsl/builtin_functions.cpp       |  2 +-
 .../glsl/gl_nir_link_uniform_initializers.c   |  2 +-
 .../gl_nir_lower_blend_equation_advanced.c    |  2 +-
 src/compiler/glsl/gl_nir_lower_buffers.c      | 10 +--
 src/compiler/glsl/gl_nir_lower_discard_flow.c |  2 +-
 .../glsl/gl_nir_lower_samplers_as_deref.c     |  4 +-
 src/compiler/glsl/glsl_parser_extras.cpp      |  2 +-
 src/compiler/glsl/glsl_to_nir.cpp             | 48 +++++------
 src/compiler/glsl/ir.cpp                      |  4 +-
 src/compiler/glsl/ir_clone.cpp                |  2 +-
 src/compiler/glsl/ir_constant_expression.cpp  |  2 +-
 src/compiler/glsl/ir_expression_operation.py  | 20 ++---
 src/compiler/glsl/ir_print_visitor.cpp        |  4 +-
 src/compiler/glsl/lower_jumps.cpp             |  2 +-
 src/compiler/glsl/lower_precision.cpp         | 12 +--
 src/compiler/glsl/opt_minmax.cpp              |  2 +-
 src/compiler/glsl_types.c                     | 32 +++----
 src/compiler/glsl_types.h                     | 10 +--
 src/compiler/libcl/libcl.h                    |  2 +-
 src/compiler/nir/nir.c                        | 52 +++++------
 src/compiler/nir/nir.h                        | 10 +--
 src/compiler/nir/nir_builder.c                |  6 +-
 src/compiler/nir/nir_builder.h                | 12 +--
 src/compiler/nir/nir_clone.c                  | 10 +--
 src/compiler/nir/nir_constant_expressions.py  |  4 +-
 src/compiler/nir/nir_control_flow.c           | 10 +--
 src/compiler/nir/nir_conversion_builder.h     | 18 ++--
 src/compiler/nir/nir_deref.c                  | 14 +--
 src/compiler/nir/nir_divergence_analysis.c    | 18 ++--
 src/compiler/nir/nir_format_convert.c         | 16 ++--
 src/compiler/nir/nir_gather_info.c            |  2 +-
 src/compiler/nir/nir_gather_output_deps.c     |  2 +-
 src/compiler/nir/nir_gather_tcs_info.c        |  4 +-
 src/compiler/nir/nir_gather_types.c           |  2 +-
 src/compiler/nir/nir_inline_helpers.h         |  4 +-
 src/compiler/nir/nir_instr_set.c              | 12 +--
 src/compiler/nir/nir_linking_helpers.c        |  2 +-
 src/compiler/nir/nir_loop_analyze.c           |  8 +-
 src/compiler/nir/nir_loop_analyze.h           |  2 +-
 src/compiler/nir/nir_lower_alu_width.c        |  2 +-
 src/compiler/nir/nir_lower_atomics.c          |  6 +-
 src/compiler/nir/nir_lower_bit_size.c         |  4 +-
 src/compiler/nir/nir_lower_blend.c            |  8 +-
 src/compiler/nir/nir_lower_bool_to_bitsize.c  |  2 +-
 .../nir/nir_lower_calls_to_builtins.c         |  2 +-
 src/compiler/nir/nir_lower_cl_images.c        |  2 +-
 .../nir_lower_clip_cull_distance_array_vars.c |  2 +-
 .../nir/nir_lower_const_arrays_to_uniforms.c  |  4 +-
 .../nir/nir_lower_continue_constructs.c       |  2 +-
 src/compiler/nir/nir_lower_discard_if.c       |  2 +-
 src/compiler/nir/nir_lower_double_ops.c       |  4 +-
 src/compiler/nir/nir_lower_explicit_io.c      | 70 +++++++--------
 src/compiler/nir/nir_lower_flrp.c             |  2 +-
 src/compiler/nir/nir_lower_fp16_conv.c        |  4 +-
 src/compiler/nir/nir_lower_frexp.c            |  4 +-
 src/compiler/nir/nir_lower_image.c            |  4 +-
 src/compiler/nir/nir_lower_int64.c            | 10 +--
 src/compiler/nir/nir_lower_io.c               |  6 +-
 .../nir/nir_lower_io_vars_to_temporaries.c    |  2 +-
 src/compiler/nir/nir_lower_locals_to_regs.c   | 10 +--
 src/compiler/nir/nir_lower_mediump.c          | 10 +--
 .../nir/nir_lower_mem_access_bit_sizes.c      |  2 +-
 src/compiler/nir/nir_lower_memcpy.c           |  2 +-
 src/compiler/nir/nir_lower_memory_model.c     |  4 +-
 src/compiler/nir/nir_lower_multiview.c        |  4 +-
 src/compiler/nir/nir_lower_printf.c           |  2 +-
 .../nir/nir_lower_readonly_images_to_tex.c    |  4 +-
 src/compiler/nir/nir_lower_returns.c          |  2 +-
 src/compiler/nir/nir_lower_robust_access.c    |  2 +-
 src/compiler/nir/nir_lower_shader_calls.c     | 14 +--
 src/compiler/nir/nir_lower_subgroups.c        | 16 ++--
 src/compiler/nir/nir_lower_system_values.c    |  4 +-
 src/compiler/nir/nir_lower_task_shader.c      |  2 +-
 .../nir/nir_lower_terminate_to_demote.c       |  2 +-
 src/compiler/nir/nir_lower_tex.c              |  6 +-
 src/compiler/nir/nir_lower_texcoord_replace.c |  2 +-
 src/compiler/nir/nir_lower_vars_to_ssa.c      |  6 +-
 src/compiler/nir/nir_lower_wpos_ytransform.c  |  8 +-
 src/compiler/nir/nir_opcodes_c.py             |  8 +-
 src/compiler/nir/nir_opt_constant_folding.c   |  4 +-
 src/compiler/nir/nir_opt_copy_prop_vars.c     |  4 +-
 src/compiler/nir/nir_opt_dce.c                |  4 +-
 src/compiler/nir/nir_opt_dead_cf.c            |  2 +-
 src/compiler/nir/nir_opt_find_array_copies.c  |  6 +-
 src/compiler/nir/nir_opt_gcm.c                |  6 +-
 src/compiler/nir/nir_opt_idiv_const.c         |  2 +-
 src/compiler/nir/nir_opt_if.c                 |  8 +-
 src/compiler/nir/nir_opt_large_constants.c    |  4 +-
 src/compiler/nir/nir_opt_licm.c               |  2 +-
 .../nir/nir_opt_load_store_vectorize.c        |  4 +-
 src/compiler/nir/nir_opt_loop.c               |  2 +-
 src/compiler/nir/nir_opt_loop_unroll.c        |  2 +-
 .../nir/nir_opt_move_discards_to_top.c        |  2 +-
 src/compiler/nir/nir_opt_offsets.c            |  2 +-
 src/compiler/nir/nir_opt_phi_precision.c      |  2 +-
 src/compiler/nir/nir_opt_phi_to_bool.c        |  2 +-
 src/compiler/nir/nir_opt_preamble.c           |  6 +-
 src/compiler/nir/nir_opt_varyings.c           | 58 ++++++-------
 src/compiler/nir/nir_opt_vectorize.c          |  2 +-
 src/compiler/nir/nir_opt_vectorize_io_vars.c  |  2 +-
 src/compiler/nir/nir_passthrough_gs.c         |  2 +-
 src/compiler/nir/nir_precompiled.h            |  2 +-
 src/compiler/nir/nir_print.c                  | 34 ++++----
 src/compiler/nir/nir_propagate_invariant.c    |  4 +-
 src/compiler/nir/nir_range_analysis.c         |  4 +-
 src/compiler/nir/nir_schedule.c               |  6 +-
 src/compiler/nir/nir_search.c                 | 18 ++--
 src/compiler/nir/nir_serialize.c              | 24 +++---
 .../nir/nir_split_64bit_vec3_and_vec4.c       | 10 +--
 src/compiler/nir/nir_split_vars.c             |  2 +-
 src/compiler/nir/nir_sweep.c                  |  2 +-
 src/compiler/nir/nir_to_lcssa.c               |  2 +-
 src/compiler/nir/nir_use_dominance.c          |  2 +-
 src/compiler/nir/nir_validate.c               |  8 +-
 src/compiler/nir/tests/builder_tests.cpp      |  2 +-
 .../nir/tests/format_convert_tests.cpp        |  6 +-
 .../nir/tests/negative_equal_tests.cpp        |  4 +-
 .../nir/tests/nir_opt_varyings_test.h         |  6 +-
 src/compiler/shader_enums.c                   |  4 +-
 src/compiler/spirv/spirv_info_gen.py          |  2 +-
 src/compiler/spirv/spirv_to_nir.c             | 22 ++---
 src/compiler/spirv/vtn_alu.c                  | 20 ++---
 src/compiler/spirv/vtn_amd.c                  |  8 +-
 src/compiler/spirv/vtn_cmat.c                 |  8 +-
 src/compiler/spirv/vtn_private.h              |  4 +-
 src/compiler/spirv/vtn_structured_cfg.c       | 12 +--
 src/compiler/spirv/vtn_subgroup.c             | 16 ++--
 src/compiler/spirv/vtn_variables.c            |  4 +-
 src/egl/drivers/dri2/egl_dri2.c               |  8 +-
 src/egl/drivers/dri2/platform_wayland.c       |  2 +-
 src/egl/drivers/haiku/egl_haiku.cpp           |  2 +-
 src/egl/drivers/wgl/egl_wgl.c                 |  6 +-
 src/egl/main/eglconfig.c                      |  6 +-
 src/egl/main/eglcontext.c                     |  2 +-
 src/egl/main/eglsurface.c                     |  2 +-
 src/freedreno/afuc/emu-regs.c                 |  4 +-
 src/freedreno/common/freedreno_common.h       |  2 +-
 .../common/freedreno_stompable_regs.h         |  2 +-
 src/freedreno/ds/fd_pps_driver.cc             |  2 +-
 src/freedreno/fdl/fd6_layout.c                |  2 +-
 src/freedreno/fdl/fd6_tiled_memcpy.cc         |  6 +-
 src/freedreno/ir3/ir3.c                       |  6 +-
 src/freedreno/ir3/ir3.h                       |  8 +-
 src/freedreno/ir3/ir3_a4xx.c                  |  4 +-
 src/freedreno/ir3/ir3_a6xx.c                  |  4 +-
 src/freedreno/ir3/ir3_compiler_nir.c          | 20 ++---
 src/freedreno/ir3/ir3_context.c               |  4 +-
 src/freedreno/ir3/ir3_context.h               |  2 +-
 src/freedreno/ir3/ir3_image.c                 |  4 +-
 src/freedreno/ir3/ir3_legalize.c              |  2 +-
 src/freedreno/ir3/ir3_lower_subgroups.c       |  8 +-
 src/freedreno/ir3/ir3_nir.c                   |  2 +-
 src/freedreno/ir3/ir3_nir_lower_tess.c        | 10 +--
 src/freedreno/ir3/ir3_nir_opt_preamble.c      |  2 +-
 src/freedreno/ir3/ir3_ra.c                    |  4 +-
 src/freedreno/ir3/ir3_ra_predicates.c         |  2 +-
 src/freedreno/ir3/ir3_sched.c                 |  2 +-
 src/freedreno/ir3/ir3_shader.h                |  6 +-
 src/freedreno/vulkan/tu_clear_blit.cc         |  6 +-
 src/freedreno/vulkan/tu_cmd_buffer.cc         | 10 +--
 src/freedreno/vulkan/tu_cs.cc                 |  2 +-
 src/freedreno/vulkan/tu_descriptor_set.cc     |  6 +-
 src/freedreno/vulkan/tu_device.cc             |  2 +-
 src/freedreno/vulkan/tu_formats.cc            |  4 +-
 src/freedreno/vulkan/tu_image.cc              |  4 +-
 src/freedreno/vulkan/tu_knl.cc                |  4 +-
 src/freedreno/vulkan/tu_knl_drm_virtio.cc     |  2 +-
 src/freedreno/vulkan/tu_knl_kgsl.cc           | 10 +--
 src/freedreno/vulkan/tu_lrz.cc                |  2 +-
 .../vulkan/tu_nir_lower_ray_query.cc          |  6 +-
 src/freedreno/vulkan/tu_pipeline.cc           | 10 +--
 src/freedreno/vulkan/tu_query_pool.cc         | 10 +--
 src/freedreno/vulkan/tu_sampler.cc            |  2 +-
 src/freedreno/vulkan/tu_shader.cc             | 12 +--
 src/freedreno/vulkan/tu_util.h                |  4 +-
 src/gallium/auxiliary/driver_trace/tr_video.c |  2 +-
 src/gallium/auxiliary/gallivm/lp_bld_arit.c   |  2 +-
 src/gallium/auxiliary/gallivm/lp_bld_format.c |  2 +-
 src/gallium/auxiliary/gallivm/lp_bld_intr.c   |  2 +-
 .../auxiliary/gallivm/lp_bld_nir_soa.c        | 18 ++--
 .../auxiliary/gallivm/lp_bld_sample_soa.c     |  2 +-
 .../auxiliary/gallivm/lp_bld_swizzle.c        |  2 +-
 src/gallium/auxiliary/nir/nir_draw_helpers.c  |  6 +-
 src/gallium/auxiliary/nir/nir_to_tgsi.c       | 38 ++++----
 src/gallium/auxiliary/nir/nir_to_tgsi_info.c  |  6 +-
 src/gallium/auxiliary/nir/pipe_nir.h          |  2 +-
 src/gallium/auxiliary/nir/tgsi_to_nir.c       | 24 +++---
 .../auxiliary/tessellator/tessellator.cpp     |  6 +-
 src/gallium/auxiliary/tgsi/tgsi_exec.c        |  8 +-
 src/gallium/auxiliary/tgsi/tgsi_from_mesa.c   |  4 +-
 src/gallium/auxiliary/tgsi/tgsi_scan.c        |  4 +-
 src/gallium/auxiliary/util/u_inlines.h        |  2 +-
 .../auxiliary/util/u_sample_positions.c       |  2 +-
 .../auxiliary/util/u_threaded_context.c       |  4 +-
 .../auxiliary/util/u_transfer_helper.c        |  4 +-
 src/gallium/auxiliary/util/u_vbuf.c           |  2 +-
 src/gallium/auxiliary/vl/vl_mpeg12_decoder.c  |  2 +-
 src/gallium/drivers/asahi/agx_blit.c          |  2 +-
 .../drivers/asahi/agx_nir_lower_sysvals.c     |  2 +-
 src/gallium/drivers/asahi/agx_query.c         |  2 +-
 src/gallium/drivers/asahi/agx_state.c         | 16 ++--
 src/gallium/drivers/crocus/crocus_blt.c       |  2 +-
 src/gallium/drivers/crocus/crocus_clear.c     |  2 +-
 src/gallium/drivers/crocus/crocus_context.c   |  6 +-
 src/gallium/drivers/crocus/crocus_draw.c      |  2 +-
 .../drivers/crocus/crocus_genx_macros.h       |  2 +-
 src/gallium/drivers/crocus/crocus_monitor.c   |  2 +-
 src/gallium/drivers/crocus/crocus_resolve.c   |  4 +-
 src/gallium/drivers/crocus/crocus_resource.c  |  8 +-
 src/gallium/drivers/crocus/crocus_resource.h  |  2 +-
 src/gallium/drivers/crocus/crocus_screen.c    |  2 +-
 src/gallium/drivers/crocus/crocus_state.c     |  4 +-
 src/gallium/drivers/d3d12/d3d12_compiler.cpp  | 10 +--
 .../d3d12/d3d12_compute_transforms.cpp        |  4 +-
 .../drivers/d3d12/d3d12_context_graphics.cpp  | 30 +++----
 src/gallium/drivers/d3d12/d3d12_draw.cpp      | 12 +--
 src/gallium/drivers/d3d12/d3d12_format.c      |  2 +-
 src/gallium/drivers/d3d12/d3d12_nir_passes.c  |  2 +-
 .../drivers/d3d12/d3d12_pipeline_state.cpp    |  6 +-
 src/gallium/drivers/d3d12/d3d12_query.cpp     |  8 +-
 src/gallium/drivers/d3d12/d3d12_resource.cpp  | 10 +--
 .../drivers/d3d12/d3d12_root_signature.cpp    |  2 +-
 src/gallium/drivers/d3d12/d3d12_screen.cpp    |  2 +-
 src/gallium/drivers/d3d12/d3d12_surface.cpp   |  8 +-
 src/gallium/drivers/d3d12/d3d12_video_dec.cpp | 20 ++---
 .../drivers/d3d12/d3d12_video_dec_h264.cpp    |  2 +-
 .../drivers/d3d12/d3d12_video_dec_hevc.cpp    |  4 +-
 .../drivers/d3d12/d3d12_video_dec_vp9.cpp     |  4 +-
 src/gallium/drivers/d3d12/d3d12_video_enc.cpp | 62 ++++++-------
 .../drivers/d3d12/d3d12_video_enc_av1.cpp     |  8 +-
 .../drivers/d3d12/d3d12_video_enc_h264.cpp    |  8 +-
 .../drivers/d3d12/d3d12_video_enc_hevc.cpp    |  4 +-
 ...2_video_encoder_bitstream_builder_h264.cpp |  2 +-
 ...2_video_encoder_bitstream_builder_hevc.cpp | 16 ++--
 .../d3d12_video_encoder_nalu_writer_hevc.cpp  |  2 +-
 ..._video_encoder_references_manager_h264.cpp |  6 +-
 ..._video_encoder_references_manager_hevc.cpp |  4 +-
 .../drivers/d3d12/d3d12_video_screen.cpp      |  6 +-
 .../drivers/etnaviv/etnaviv_compiler_nir.c    |  4 +-
 src/gallium/drivers/etnaviv/etnaviv_ml.c      |  8 +-
 .../drivers/etnaviv/etnaviv_resource.c        |  4 +-
 src/gallium/drivers/etnaviv/etnaviv_rs.c      |  4 +-
 src/gallium/drivers/etnaviv/etnaviv_shader.c  |  2 +-
 .../drivers/etnaviv/etnaviv_translate.h       |  2 +-
 .../drivers/etnaviv/etnaviv_uniforms.c        |  4 +-
 src/gallium/drivers/freedreno/a2xx/fd2_draw.c |  2 +-
 .../drivers/freedreno/a2xx/fd2_texture.c      |  2 +-
 src/gallium/drivers/freedreno/a3xx/fd3_emit.c |  2 +-
 .../drivers/freedreno/a3xx/fd3_texture.c      |  2 +-
 src/gallium/drivers/freedreno/a4xx/fd4_emit.c |  2 +-
 .../drivers/freedreno/a4xx/fd4_texture.h      |  2 +-
 src/gallium/drivers/freedreno/a5xx/fd5_emit.c |  2 +-
 .../drivers/freedreno/a5xx/fd5_texture.h      |  2 +-
 .../drivers/freedreno/a6xx/fd6_blitter.cc     |  2 +-
 .../drivers/freedreno/a6xx/fd6_const.cc       |  2 +-
 src/gallium/drivers/freedreno/a6xx/fd6_emit.h |  6 +-
 .../drivers/freedreno/a6xx/fd6_program.cc     |  6 +-
 .../drivers/freedreno/a6xx/fd6_texture.cc     |  4 +-
 .../drivers/freedreno/freedreno_fence.c       |  2 +-
 .../drivers/freedreno/freedreno_query.c       |  4 +-
 .../drivers/freedreno/freedreno_resource.c    |  2 +-
 .../drivers/freedreno/freedreno_resource.h    |  2 +-
 .../drivers/freedreno/freedreno_state.c       |  2 +-
 .../drivers/freedreno/freedreno_util.h        |  4 +-
 .../drivers/freedreno/ir3/ir3_descriptor.h    |  2 +-
 src/gallium/drivers/i915/i915_fpc_translate.c |  2 +-
 src/gallium/drivers/iris/iris_batch.c         |  8 +-
 src/gallium/drivers/iris/iris_blorp.c         |  2 +-
 src/gallium/drivers/iris/iris_bufmgr.c        | 16 ++--
 src/gallium/drivers/iris/iris_clear.c         |  2 +-
 src/gallium/drivers/iris/iris_context.c       | 12 +--
 src/gallium/drivers/iris/iris_context.h       |  4 +-
 src/gallium/drivers/iris/iris_disk_cache.c    |  8 +-
 src/gallium/drivers/iris/iris_genx_macros.h   |  2 +-
 src/gallium/drivers/iris/iris_monitor.c       |  2 +-
 src/gallium/drivers/iris/iris_program.c       | 46 +++++-----
 src/gallium/drivers/iris/iris_program_cache.c |  8 +-
 src/gallium/drivers/iris/iris_resolve.c       |  4 +-
 src/gallium/drivers/iris/iris_resource.c      |  4 +-
 src/gallium/drivers/iris/iris_screen.c        |  6 +-
 src/gallium/drivers/iris/iris_state.c         | 18 ++--
 .../drivers/iris/xe/iris_kmd_backend.c        |  2 +-
 .../drivers/lima/genxml/lima_pack_header.h    |  2 +-
 src/gallium/drivers/lima/ir/gp/lower.c        |  2 +-
 src/gallium/drivers/lima/ir/pp/codegen.c      |  2 +-
 src/gallium/drivers/lima/ir/pp/nir.c          |  2 +-
 src/gallium/drivers/llvmpipe/lp_fence.c       |  4 +-
 src/gallium/drivers/llvmpipe/lp_state_fs.c    |  6 +-
 .../drivers/llvmpipe/lp_state_sampler.c       |  4 +-
 .../nouveau/codegen/nv50_ir_emit_gm107.cpp    |  2 +-
 .../nouveau/codegen/nv50_ir_emit_gv100.cpp    |  4 +-
 .../nouveau/codegen/nv50_ir_from_nir.cpp      |  6 +-
 .../codegen/nv50_ir_lowering_gv100.cpp        |  2 +-
 src/gallium/drivers/nouveau/nv50/nv50_tex.c   |  2 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_tex.c   |  4 +-
 src/gallium/drivers/panfrost/pan_blit.c       |  2 +-
 src/gallium/drivers/panfrost/pan_cmdstream.c  | 10 +--
 src/gallium/drivers/panfrost/pan_cmdstream.h  |  2 +-
 src/gallium/drivers/panfrost/pan_context.c    |  2 +-
 src/gallium/drivers/panfrost/pan_fb_preload.c |  8 +-
 src/gallium/drivers/panfrost/pan_helpers.c    |  2 +-
 src/gallium/drivers/panfrost/pan_jm.c         |  4 +-
 .../drivers/panfrost/pan_mod_conv_cso.c       |  2 +-
 src/gallium/drivers/panfrost/pan_resource.h   |  2 +-
 src/gallium/drivers/r300/compiler/nir_to_rc.c | 26 +++---
 src/gallium/drivers/r600/r600_gpu_load.c      |  2 +-
 src/gallium/drivers/r600/r600_query.c         |  8 +-
 src/gallium/drivers/r600/r600_state_common.c  |  4 +-
 .../r600/sfn/sfn_alu_readport_validation.cpp  |  2 +-
 .../drivers/r600/sfn/sfn_assembler.cpp        | 12 +--
 src/gallium/drivers/r600/sfn/sfn_instr.cpp    |  2 +-
 src/gallium/drivers/r600/sfn/sfn_instr.h      |  4 +-
 .../drivers/r600/sfn/sfn_instr_alu.cpp        | 14 +--
 .../drivers/r600/sfn/sfn_instr_alugroup.cpp   |  4 +-
 .../r600/sfn/sfn_instr_controlflow.cpp        |  2 +-
 .../drivers/r600/sfn/sfn_instr_export.cpp     |  2 +-
 .../drivers/r600/sfn/sfn_instr_fetch.cpp      | 22 ++---
 .../drivers/r600/sfn/sfn_instr_lds.cpp        |  4 +-
 .../drivers/r600/sfn/sfn_instr_mem.cpp        |  4 +-
 .../drivers/r600/sfn/sfn_instr_tex.cpp        |  6 +-
 .../r600/sfn/sfn_liverangeevaluator.cpp       |  6 +-
 .../sfn/sfn_nir_legalize_image_load_store.cpp |  2 +-
 .../drivers/r600/sfn/sfn_nir_lower_64bit.cpp  |  8 +-
 .../drivers/r600/sfn/sfn_nir_lower_alu.cpp    |  2 +-
 .../sfn/sfn_nir_lower_fs_out_to_vector.cpp    |  2 +-
 .../r600/sfn/sfn_nir_lower_tess_io.cpp        |  2 +-
 .../drivers/r600/sfn/sfn_scheduler.cpp        |  2 +-
 src/gallium/drivers/r600/sfn/sfn_shader.cpp   |  2 +-
 src/gallium/drivers/r600/sfn/sfn_shader_cs.h  |  4 +-
 .../drivers/r600/sfn/sfn_shader_fs.cpp        |  4 +-
 src/gallium/drivers/r600/sfn/sfn_shader_gs.h  |  2 +-
 .../drivers/r600/sfn/sfn_shader_tess.h        |  8 +-
 .../r600/sfn/sfn_split_address_loads.cpp      |  2 +-
 .../drivers/r600/sfn/sfn_valuefactory.cpp     | 18 ++--
 .../drivers/r600/sfn/sfn_virtualvalues.cpp    | 14 +--
 .../drivers/r600/sfn/sfn_virtualvalues.h      |  4 +-
 src/gallium/drivers/radeonsi/gfx11_query.c    |  2 +-
 src/gallium/drivers/radeonsi/si_blit.c        |  2 +-
 src/gallium/drivers/radeonsi/si_descriptors.c |  4 +-
 src/gallium/drivers/radeonsi/si_fence.c       |  2 +-
 src/gallium/drivers/radeonsi/si_gpu_load.c    |  2 +-
 .../drivers/radeonsi/si_nir_lower_abi.c       |  2 +-
 .../radeonsi/si_nir_lower_ps_color_inputs.c   |  2 +-
 .../drivers/radeonsi/si_nir_lower_resource.c  |  2 +-
 .../drivers/radeonsi/si_nir_lower_vs_inputs.c |  4 +-
 src/gallium/drivers/radeonsi/si_pipe.c        |  2 +-
 src/gallium/drivers/radeonsi/si_query.c       |  8 +-
 src/gallium/drivers/radeonsi/si_shader.c      |  2 +-
 src/gallium/drivers/radeonsi/si_shader_aco.c  |  4 +-
 src/gallium/drivers/radeonsi/si_shader_info.c |  6 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  8 +-
 src/gallium/drivers/radeonsi/si_shader_nir.c  |  2 +-
 src/gallium/drivers/radeonsi/si_sqtt.c        |  2 +-
 src/gallium/drivers/radeonsi/si_state.c       |  8 +-
 .../drivers/radeonsi/si_state_draw.cpp        |  6 +-
 .../drivers/radeonsi/si_state_shaders.cpp     |  8 +-
 .../radeonsi/si_test_image_copy_region.c      |  2 +-
 src/gallium/drivers/rocket/rkt_ml.c           |  4 +-
 .../drivers/softpipe/sp_quad_depth_test.c     |  2 +-
 src/gallium/drivers/softpipe/sp_query.c       |  2 +-
 src/gallium/drivers/v3d/v3d_context.c         |  2 +-
 src/gallium/drivers/v3d/v3d_query_pipe.c      |  6 +-
 src/gallium/drivers/v3d/v3d_uniforms.c        |  6 +-
 src/gallium/drivers/v3d/v3dx_draw.c           |  6 +-
 src/gallium/drivers/v3d/v3dx_emit.c           |  2 +-
 src/gallium/drivers/v3d/v3dx_rcl.c            |  4 +-
 src/gallium/drivers/v3d/v3dx_state.c          |  4 +-
 src/gallium/drivers/v3d/v3dx_tfu.c            |  2 +-
 .../drivers/vc4/vc4_nir_lower_txf_ms.c        |  2 +-
 src/gallium/drivers/vc4/vc4_program.c         |  4 +-
 src/gallium/drivers/vc4/vc4_qir.c             |  2 +-
 src/gallium/drivers/vc4/vc4_qpu_emit.c        |  2 +-
 .../drivers/vc4/vc4_register_allocate.c       |  2 +-
 src/gallium/drivers/vc4/vc4_tiling.h          |  4 +-
 src/gallium/drivers/vc4/vc4_tiling_lt.c       |  8 +-
 src/gallium/drivers/virgl/virgl_screen.h      |  2 +-
 .../drivers/zink/nir_to_spirv/nir_to_spirv.c  | 86 +++++++++----------
 .../drivers/zink/nir_to_spirv/nir_to_spirv.h  |  4 +-
 .../drivers/zink/nir_to_spirv/spirv_builder.c |  2 +-
 src/gallium/drivers/zink/zink_compiler.c      | 34 ++++----
 src/gallium/drivers/zink/zink_context.c       | 20 ++---
 src/gallium/drivers/zink/zink_context.h       |  4 +-
 src/gallium/drivers/zink/zink_descriptors.c   | 10 +--
 src/gallium/drivers/zink/zink_descriptors.h   | 10 +--
 src/gallium/drivers/zink/zink_draw.cpp        |  8 +-
 src/gallium/drivers/zink/zink_format.c        |  2 +-
 src/gallium/drivers/zink/zink_helpers.h       |  2 +-
 src/gallium/drivers/zink/zink_kopper.c        | 14 +--
 .../zink/zink_lower_cubemap_to_array.c        |  2 +-
 src/gallium/drivers/zink/zink_program.c       |  8 +-
 src/gallium/drivers/zink/zink_program.h       |  4 +-
 src/gallium/drivers/zink/zink_query.c         |  6 +-
 src/gallium/drivers/zink/zink_resource.c      | 14 +--
 src/gallium/drivers/zink/zink_screen.c        |  2 +-
 src/gallium/drivers/zink/zink_state.c         | 10 +--
 src/gallium/drivers/zink/zink_surface.c       |  4 +-
 .../drivers/zink/zink_synchronization.cpp     |  2 +-
 src/gallium/frontends/dri/dri2.c              |  4 +-
 src/gallium/frontends/dri/dri_util.c          |  2 +-
 .../frontends/dri/loader_dri3_helper.c        |  2 +-
 .../lavapipe/lvp_acceleration_structure.c     | 10 +--
 src/gallium/frontends/lavapipe/lvp_conv.h     |  2 +-
 .../frontends/lavapipe/lvp_descriptor_set.c   |  8 +-
 src/gallium/frontends/lavapipe/lvp_device.c   |  2 +-
 .../lavapipe/lvp_device_generated_commands.c  |  8 +-
 src/gallium/frontends/lavapipe/lvp_execute.c  | 16 ++--
 src/gallium/frontends/lavapipe/lvp_formats.c  |  4 +-
 src/gallium/frontends/lavapipe/lvp_pipeline.c |  2 +-
 src/gallium/frontends/lavapipe/lvp_private.h  |  2 +-
 .../lavapipe/lvp_ray_tracing_pipeline.c       |  4 +-
 .../lavapipe/nir/lvp_nir_lower_ray_queries.c  |  4 +-
 .../frontends/mediafoundation/encode_h264.cpp |  4 +-
 .../frontends/mediafoundation/encode_hevc.cpp |  4 +-
 .../mediafoundation/mfpipeinterop.cpp         |  8 +-
 .../reference_frames_tracker_h264.cpp         |  4 +-
 .../reference_frames_tracker_hevc.cpp         |  4 +-
 src/gallium/frontends/teflon/tfl_device.c     |  2 +-
 src/gallium/winsys/amdgpu/drm/amdgpu_cs.cpp   |  2 +-
 src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c |  2 +-
 .../winsys/etnaviv/drm/etnaviv_drm_winsys.c   |  2 +-
 src/gallium/winsys/nouveau/drm/nouveau.c      |  2 +-
 src/glx/dri_common.c                          |  4 +-
 .../include/hwdef/rogue_hw_utils.h            |  2 +-
 src/imagination/pco/pco_trans_nir.c           |  8 +-
 src/imagination/rogue/passes/rogue_dce.c      |  2 +-
 src/imagination/rogue/passes/rogue_regalloc.c |  4 +-
 .../passes/rogue_schedule_instr_groups.c      | 32 +++----
 .../rogue/passes/rogue_schedule_uvsw.c        |  4 +-
 .../rogue/passes/rogue_schedule_wdf.c         |  2 +-
 src/imagination/rogue/rogue.c                 | 44 +++++-----
 src/imagination/rogue/rogue.h                 | 24 +++---
 src/imagination/rogue/rogue_build_data.c      |  8 +-
 src/imagination/rogue/rogue_compile.c         | 20 ++---
 src/imagination/rogue/rogue_encode.c          | 58 ++++++-------
 src/imagination/rogue/rogue_print.c           | 12 +--
 src/imagination/vulkan/pds/pvr_pipeline_pds.c |  4 +-
 src/imagination/vulkan/pvr_blit.c             |  4 +-
 src/imagination/vulkan/pvr_cmd_buffer.c       | 34 ++++----
 src/imagination/vulkan/pvr_csb.c              |  4 +-
 src/imagination/vulkan/pvr_csb_enum_helpers.h | 12 +--
 src/imagination/vulkan/pvr_device.c           |  8 +-
 src/imagination/vulkan/pvr_dump_csb.c         |  2 +-
 src/imagination/vulkan/pvr_formats.c          |  6 +-
 src/imagination/vulkan/pvr_hardcode.c         |  4 +-
 src/imagination/vulkan/pvr_image.c            |  2 +-
 src/imagination/vulkan/pvr_job_common.c       |  8 +-
 src/imagination/vulkan/pvr_job_context.c      |  2 +-
 src/imagination/vulkan/pvr_job_render.c       |  4 +-
 src/imagination/vulkan/pvr_job_transfer.c     |  4 +-
 src/imagination/vulkan/pvr_pipeline.c         | 10 +--
 src/imagination/vulkan/pvr_query_compute.c    |  8 +-
 src/imagination/vulkan/pvr_queue.c            |  2 +-
 src/imagination/vulkan/pvr_spm.c              |  4 +-
 src/imagination/vulkan/pvr_tex_state.c        |  4 +-
 src/imagination/vulkan/pvr_uscgen.c           |  6 +-
 src/imagination/vulkan/usc/pvr_uscgen_tq.c    |  8 +-
 .../winsys/powervr/pvr_drm_job_common.h       |  2 +-
 .../winsys/pvrsrvkm/pvr_srv_job_common.h      |  2 +-
 .../winsys/pvrsrvkm/pvr_srv_job_render.c      |  2 +-
 .../vulkan/winsys/pvrsrvkm/pvr_srv_sync.c     |  2 +-
 src/intel/blorp/blorp.c                       |  2 +-
 src/intel/blorp/blorp_blit.c                  | 36 ++++----
 src/intel/blorp/blorp_clear.c                 |  6 +-
 src/intel/blorp/blorp_genX_exec_brw.h         | 18 ++--
 src/intel/blorp/blorp_genX_exec_elk.h         | 18 ++--
 src/intel/blorp/blorp_nir_builder.h           |  2 +-
 src/intel/common/intel_aux_map.c              |  8 +-
 src/intel/common/intel_debug_identifier.c     |  2 +-
 src/intel/common/intel_engine.c               |  4 +-
 src/intel/common/intel_gem.c                  |  8 +-
 src/intel/common/intel_genX_state_brw.h       |  2 +-
 src/intel/common/intel_l3_config.c            |  2 +-
 src/intel/common/intel_sample_positions.h     |  2 +-
 src/intel/common/mi_builder.h                 | 22 ++---
 src/intel/compiler/brw_compile_mesh.cpp       |  4 +-
 src/intel/compiler/brw_compile_tes.cpp        |  2 +-
 src/intel/compiler/brw_compiler.c             |  2 +-
 src/intel/compiler/brw_compiler.h             |  2 +-
 src/intel/compiler/brw_disasm.c               | 10 +--
 src/intel/compiler/brw_eu.c                   |  4 +-
 src/intel/compiler/brw_eu.h                   | 20 ++---
 src/intel/compiler/brw_eu_compact.c           |  8 +-
 src/intel/compiler/brw_eu_emit.c              | 10 +--
 src/intel/compiler/brw_eu_validate.c          |  8 +-
 src/intel/compiler/brw_from_nir.cpp           | 80 ++++++++---------
 src/intel/compiler/brw_generator.cpp          | 10 +--
 src/intel/compiler/brw_inst.cpp               |  8 +-
 src/intel/compiler/brw_lower.cpp              |  2 +-
 .../compiler/brw_lower_logical_sends.cpp      | 12 +--
 src/intel/compiler/brw_lower_pack.cpp         |  2 +-
 src/intel/compiler/brw_lower_regioning.cpp    |  2 +-
 src/intel/compiler/brw_lower_subgroup_ops.cpp |  6 +-
 src/intel/compiler/brw_nir.c                  | 24 +++---
 .../brw_nir_lower_cooperative_matrix.c        |  4 +-
 .../compiler/brw_nir_lower_cs_intrinsics.c    |  2 +-
 .../compiler/brw_nir_lower_fs_barycentrics.c  |  2 +-
 .../compiler/brw_nir_lower_ray_queries.c      |  6 +-
 .../compiler/brw_nir_lower_shader_calls.c     |  2 +-
 .../compiler/brw_nir_lower_storage_image.c    |  4 +-
 .../compiler/brw_nir_lower_texel_address.c    |  2 +-
 src/intel/compiler/brw_opt_algebraic.cpp      | 16 ++--
 .../compiler/brw_opt_cmod_propagation.cpp     |  2 +-
 .../compiler/brw_opt_combine_constants.cpp    | 18 ++--
 src/intel/compiler/brw_print.cpp              |  8 +-
 src/intel/compiler/brw_reg.cpp                | 24 +++---
 src/intel/compiler/brw_reg.h                  | 12 +--
 src/intel/compiler/brw_reg_allocate.cpp       |  2 +-
 .../compiler/brw_schedule_instructions.cpp    | 10 +--
 src/intel/compiler/brw_shader.cpp             | 10 +--
 src/intel/compiler/brw_simd_selection.cpp     |  2 +-
 src/intel/compiler/brw_validate.cpp           |  4 +-
 src/intel/compiler/elk/elk_clip_unfilled.c    |  2 +-
 src/intel/compiler/elk/elk_compile_clip.c     |  2 +-
 src/intel/compiler/elk/elk_compile_ff_gs.c    |  2 +-
 src/intel/compiler/elk/elk_compile_sf.c       |  2 +-
 src/intel/compiler/elk/elk_compiler.c         |  2 +-
 src/intel/compiler/elk/elk_compiler.h         |  2 +-
 src/intel/compiler/elk/elk_disasm.c           |  8 +-
 src/intel/compiler/elk/elk_eu.c               |  6 +-
 src/intel/compiler/elk/elk_eu.h               | 20 ++---
 src/intel/compiler/elk/elk_eu_compact.c       |  2 +-
 src/intel/compiler/elk/elk_eu_emit.c          | 10 +--
 src/intel/compiler/elk/elk_eu_validate.c      |  6 +-
 src/intel/compiler/elk/elk_fs.cpp             | 26 +++---
 src/intel/compiler/elk/elk_fs_builder.h       |  2 +-
 .../compiler/elk/elk_fs_combine_constants.cpp | 18 ++--
 src/intel/compiler/elk/elk_fs_generator.cpp   | 14 +--
 src/intel/compiler/elk/elk_fs_lower_pack.cpp  |  2 +-
 .../compiler/elk/elk_fs_lower_regioning.cpp   |  4 +-
 src/intel/compiler/elk/elk_fs_nir.cpp         | 78 ++++++++---------
 .../compiler/elk/elk_fs_reg_allocate.cpp      |  2 +-
 src/intel/compiler/elk/elk_fs_visitor.cpp     |  6 +-
 .../compiler/elk/elk_gfx6_gs_visitor.cpp      |  2 +-
 src/intel/compiler/elk/elk_ir_fs.h            |  2 +-
 .../compiler/elk/elk_lower_logical_sends.cpp  | 10 +--
 src/intel/compiler/elk/elk_nir.c              | 20 ++---
 .../elk/elk_nir_analyze_boolean_resolves.c    |  2 +-
 .../elk/elk_nir_lower_cs_intrinsics.c         |  2 +-
 .../elk/elk_nir_lower_storage_image.c         |  6 +-
 src/intel/compiler/elk/elk_reg.h              |  8 +-
 src/intel/compiler/elk/elk_reg_type.h         |  8 +-
 .../elk/elk_schedule_instructions.cpp         |  8 +-
 src/intel/compiler/elk/elk_shader.cpp         | 30 +++----
 src/intel/compiler/elk/elk_simd_selection.cpp |  2 +-
 .../compiler/elk/elk_test_eu_compact.cpp      |  2 +-
 .../elk/elk_test_vec4_cmod_propagation.cpp    | 14 +--
 .../elk/elk_test_vec4_copy_propagation.cpp    | 12 +--
 .../elk/elk_test_vec4_dead_code_eliminate.cpp | 12 +--
 .../elk/elk_test_vec4_register_coalesce.cpp   | 12 +--
 src/intel/compiler/elk/elk_vec4.cpp           | 16 ++--
 .../elk/elk_vec4_cmod_propagation.cpp         |  2 +-
 src/intel/compiler/elk/elk_vec4_generator.cpp |  8 +-
 src/intel/compiler/elk/elk_vec4_gs_nir.cpp    |  2 +-
 src/intel/compiler/elk/elk_vec4_nir.cpp       | 50 +++++------
 src/intel/compiler/elk/elk_vec4_tcs.cpp       |  2 +-
 src/intel/compiler/elk/elk_vec4_visitor.cpp   | 10 +--
 src/intel/compiler/intel_gfx_ver_enum.h       |  2 +-
 src/intel/compiler/test_eu_compact.cpp        |  2 +-
 src/intel/compiler/test_eu_validate.cpp       |  6 +-
 src/intel/dev/i915/intel_device_info.c        |  8 +-
 src/intel/dev/intel_device_info.c             |  2 +-
 src/intel/dev/intel_device_info.h             |  2 +-
 .../dev/intel_device_info_serialize_gen_c.py  |  2 +-
 src/intel/dev/intel_hwconfig.c                |  2 +-
 src/intel/executor/executor_macros.c          | 14 +--
 src/intel/executor/executor_main.c            |  2 +-
 src/intel/genxml/gen_bits_header.py           |  2 +-
 src/intel/isl/isl.c                           | 76 ++++++++--------
 src/intel/isl/isl.h                           |  6 +-
 src/intel/isl/isl_aux_info.c                  | 16 ++--
 src/intel/isl/isl_drm.c                       |  4 +-
 src/intel/isl/isl_emit_cpb.c                  |  2 +-
 src/intel/isl/isl_emit_depth_stencil.c        |  2 +-
 src/intel/isl/isl_format.c                    | 10 +--
 src/intel/isl/isl_genX_helpers.h              | 10 +--
 src/intel/isl/isl_priv.h                      |  2 +-
 src/intel/isl/isl_storage_image.c             |  4 +-
 src/intel/isl/isl_surface_state.c             |  8 +-
 src/intel/isl/isl_tiled_memcpy.c              | 34 ++++----
 src/intel/nullhw-layer/intel_nullhw.c         |  4 +-
 src/intel/perf/intel_perf.c                   | 26 +++---
 src/intel/perf/intel_perf.h                   |  2 +-
 src/intel/perf/intel_perf_mdapi.c             |  4 +-
 src/intel/perf/intel_perf_query.c             | 24 +++---
 src/intel/perf/xe/intel_perf.c                |  2 +-
 src/intel/tools/aub_write.c                   |  4 +-
 src/intel/tools/intel_hang_replay.c           |  2 +-
 src/intel/tools/intel_hang_viewer.cpp         |  4 +-
 src/intel/vulkan/anv_batch_chain.c            |  2 +-
 src/intel/vulkan/anv_blorp.c                  | 10 +--
 src/intel/vulkan/anv_bo_sync.c                |  2 +-
 src/intel/vulkan/anv_cmd_buffer.c             |  8 +-
 src/intel/vulkan/anv_descriptor_set.c         | 12 +--
 src/intel/vulkan/anv_device.c                 |  8 +-
 src/intel/vulkan/anv_formats.c                |  4 +-
 src/intel/vulkan/anv_gem.c                    |  8 +-
 src/intel/vulkan/anv_gem_stubs.c              |  4 +-
 src/intel/vulkan/anv_image.c                  | 26 +++---
 src/intel/vulkan/anv_image_view.c             |  2 +-
 .../vulkan/anv_nir_apply_pipeline_layout.c    | 16 ++--
 src/intel/vulkan/anv_perf.c                   |  8 +-
 src/intel/vulkan/anv_physical_device.c        |  6 +-
 src/intel/vulkan/anv_pipeline.c               | 24 +++---
 src/intel/vulkan/anv_private.h                |  4 +-
 src/intel/vulkan/anv_queue.c                  |  6 +-
 src/intel/vulkan/anv_rmv.c                    |  2 +-
 src/intel/vulkan/anv_slab_bo.c                |  4 +-
 src/intel/vulkan/anv_util.c                   |  4 +-
 src/intel/vulkan/anv_video.c                  | 12 +--
 .../vulkan/genX_acceleration_structure.c      |  8 +-
 src/intel/vulkan/genX_blorp_exec.c            |  2 +-
 src/intel/vulkan/genX_cmd_buffer.c            | 28 +++---
 src/intel/vulkan/genX_cmd_compute.c           |  6 +-
 src/intel/vulkan/genX_cmd_draw.c              |  6 +-
 src/intel/vulkan/genX_cmd_video_enc.c         |  2 +-
 src/intel/vulkan/genX_gfx_state.c             | 22 ++---
 src/intel/vulkan/genX_gpu_memcpy.c            |  2 +-
 src/intel/vulkan/genX_init_state.c            |  8 +-
 src/intel/vulkan/genX_internal_kernels.c      |  2 +-
 src/intel/vulkan/genX_pipeline.c              |  8 +-
 src/intel/vulkan/genX_query.c                 | 30 +++----
 src/intel/vulkan/i915/anv_batch_chain.c       |  2 +-
 src/intel/vulkan/i915/anv_device.c            |  2 +-
 src/intel/vulkan/i915/anv_kmd_backend.c       |  2 +-
 src/intel/vulkan/i915/anv_queue.c             |  2 +-
 src/intel/vulkan/xe/anv_device.c              |  2 +-
 src/intel/vulkan/xe/anv_kmd_backend.c         |  2 +-
 src/intel/vulkan/xe/anv_queue.c               |  2 +-
 src/intel/vulkan_hasvk/anv_batch_chain.c      |  4 +-
 src/intel/vulkan_hasvk/anv_blorp.c            | 10 +--
 src/intel/vulkan_hasvk/anv_bo_sync.c          |  2 +-
 src/intel/vulkan_hasvk/anv_cmd_buffer.c       |  8 +-
 src/intel/vulkan_hasvk/anv_descriptor_set.c   |  4 +-
 src/intel/vulkan_hasvk/anv_device.c           |  2 +-
 src/intel/vulkan_hasvk/anv_formats.c          |  4 +-
 src/intel/vulkan_hasvk/anv_gem_stubs.c        | 10 +--
 src/intel/vulkan_hasvk/anv_image.c            | 28 +++---
 .../anv_nir_apply_pipeline_layout.c           | 10 +--
 .../anv_nir_lower_ycbcr_textures.c            |  4 +-
 src/intel/vulkan_hasvk/anv_perf.c             |  6 +-
 src/intel/vulkan_hasvk/anv_pipeline.c         | 14 +--
 src/intel/vulkan_hasvk/anv_private.h          |  2 +-
 src/intel/vulkan_hasvk/genX_cmd_buffer.c      | 10 +--
 src/intel/vulkan_hasvk/genX_gpu_memcpy.c      |  2 +-
 src/intel/vulkan_hasvk/genX_pipeline.c        | 24 +++---
 src/intel/vulkan_hasvk/genX_query.c           | 22 ++---
 src/intel/vulkan_hasvk/genX_state.c           |  6 +-
 src/mesa/main/accum.c                         |  2 +-
 src/mesa/main/bufferobj.c                     |  2 +-
 src/mesa/main/debug_output.c                  |  2 +-
 src/mesa/main/draw.c                          |  2 +-
 src/mesa/main/draw_validate.c                 |  2 +-
 src/mesa/main/fbobject.c                      |  2 +-
 src/mesa/main/ffvertex_prog.c                 |  4 +-
 src/mesa/main/format_utils.c                  |  2 +-
 src/mesa/main/formatquery.c                   |  8 +-
 src/mesa/main/formats.c                       |  4 +-
 src/mesa/main/glformats.c                     |  2 +-
 src/mesa/main/glthread_bufferobj.c            |  8 +-
 src/mesa/main/glthread_draw.c                 | 50 +++++------
 src/mesa/main/glthread_get.c                  |  2 +-
 src/mesa/main/glthread_shaderobj.c            |  4 +-
 src/mesa/main/light.c                         |  2 +-
 src/mesa/main/mipmap.c                        |  2 +-
 src/mesa/main/pack.c                          | 12 +--
 src/mesa/main/performance_monitor.c           |  2 +-
 src/mesa/main/performance_query.c             |  4 +-
 src/mesa/main/pixelstore.c                    |  2 +-
 src/mesa/main/queryobj.c                      |  6 +-
 src/mesa/main/shaderobj.h                     | 12 +--
 src/mesa/main/spirv_extensions.c              |  2 +-
 src/mesa/main/texcompress.c                   |  2 +-
 src/mesa/main/texcompress_astc.cpp            | 14 +--
 src/mesa/main/texcompress_etc.c               |  2 +-
 src/mesa/main/texcompress_rgtc.c              |  2 +-
 src/mesa/main/texcompress_s3tc.c              |  2 +-
 src/mesa/main/texgetimage.c                   |  2 +-
 src/mesa/main/texobj.c                        |  4 +-
 src/mesa/main/texstate.c                      |  6 +-
 src/mesa/main/texstorage.c                    |  2 +-
 src/mesa/main/transformfeedback.c             |  2 +-
 src/mesa/main/uniform_query.cpp               |  2 +-
 src/mesa/program/prog_parameter.c             |  2 +-
 src/mesa/program/prog_statevars.c             |  2 +-
 src/mesa/program/prog_to_nir.c                |  2 +-
 src/mesa/state_tracker/st_atifs_to_nir.c      |  4 +-
 src/mesa/state_tracker/st_atom_array.cpp      |  2 +-
 src/mesa/state_tracker/st_atom_image.c        |  2 +-
 src/mesa/state_tracker/st_cb_drawtex.c        |  2 +-
 src/mesa/state_tracker/st_cb_eglimage.c       |  6 +-
 src/mesa/state_tracker/st_cb_texture.c        |  8 +-
 src/mesa/state_tracker/st_context.c           |  2 +-
 src/mesa/state_tracker/st_draw_hw_select.c    |  2 +-
 src/mesa/state_tracker/st_format.c            |  4 +-
 src/mesa/state_tracker/st_nir_lower_fog.c     |  2 +-
 .../state_tracker/st_nir_unlower_io_to_vars.c |  8 +-
 src/mesa/state_tracker/st_program.c           | 10 +--
 .../state_tracker/st_texcompress_compute.c    |  4 +-
 src/mesa/state_tracker/st_texture.c           |  2 +-
 src/mesa/vbo/vbo_exec.c                       |  2 +-
 src/mesa/vbo/vbo_minmax_index.c               |  2 +-
 src/mesa/vbo/vbo_private.h                    |  6 +-
 src/mesa/vbo/vbo_save_api.c                   |  2 +-
 src/microsoft/clc/clc_compiler.c              | 10 +--
 src/microsoft/clc/clc_nir.c                   |  2 +-
 src/microsoft/compiler/dxil_dump.c            |  2 +-
 src/microsoft/compiler/dxil_enums.c           | 12 +--
 src/microsoft/compiler/dxil_function.c        |  2 +-
 src/microsoft/compiler/dxil_module.c          | 54 ++++++------
 src/microsoft/compiler/dxil_nir.c             | 18 ++--
 .../compiler/dxil_nir_lower_int_cubemaps.c    |  2 +-
 .../compiler/dxil_nir_lower_int_samplers.c    |  4 +-
 .../dxil_nir_lower_vs_vertex_conversion.c     |  2 +-
 src/microsoft/compiler/dxil_signature.c       | 10 +--
 src/microsoft/compiler/nir_to_dxil.c          | 62 ++++++-------
 src/microsoft/vulkan/dzn_cmd_buffer.c         |  8 +-
 src/microsoft/vulkan/dzn_descriptor_set.c     | 14 +--
 src/microsoft/vulkan/dzn_device.c             | 12 +--
 src/microsoft/vulkan/dzn_image.c              | 22 ++---
 src/microsoft/vulkan/dzn_pipeline.c           | 24 +++---
 src/microsoft/vulkan/dzn_private.h            |  8 +-
 src/microsoft/vulkan/dzn_query.c              |  6 +-
 src/microsoft/vulkan/dzn_util.c               |  2 +-
 src/nouveau/compiler/nak_nir.c                | 16 ++--
 src/nouveau/compiler/nak_nir_lower_cf.c       |  8 +-
 src/nouveau/compiler/nak_nir_lower_cmat.c     |  6 +-
 .../compiler/nak_nir_lower_fs_inputs.c        |  6 +-
 .../compiler/nak_nir_lower_image_addrs.c      |  8 +-
 .../nak_nir_lower_kepler_shared_atomics.c     |  2 +-
 .../compiler/nak_nir_lower_non_uniform_ldcx.c |  4 +-
 .../compiler/nak_nir_lower_scan_reduce.c      | 10 +--
 src/nouveau/compiler/nak_nir_lower_tex.c      | 14 +--
 src/nouveau/compiler/nak_nir_lower_vtg_io.c   |  4 +-
 .../compiler/nak_nir_mark_lcssa_invariants.c  |  2 +-
 src/nouveau/mme/mme_builder.h                 | 44 +++++-----
 src/nouveau/mme/mme_fermi_builder.c           | 10 +--
 src/nouveau/mme/mme_fermi_sim.c               |  6 +-
 src/nouveau/mme/mme_sim.c                     |  2 +-
 src/nouveau/mme/mme_tu104.c                   |  4 +-
 src/nouveau/mme/mme_tu104_builder.c           |  8 +-
 src/nouveau/mme/mme_tu104_sim.c               | 10 +--
 src/nouveau/mme/mme_value.h                   |  2 +-
 src/nouveau/vulkan/nvk_cmd_buffer.c           |  8 +-
 src/nouveau/vulkan/nvk_cmd_buffer.h           |  4 +-
 src/nouveau/vulkan/nvk_cmd_clear.c            |  4 +-
 src/nouveau/vulkan/nvk_cmd_copy.c             |  8 +-
 src/nouveau/vulkan/nvk_cmd_draw.c             | 10 +--
 src/nouveau/vulkan/nvk_cmd_indirect.c         | 10 +--
 src/nouveau/vulkan/nvk_cmd_meta.c             |  2 +-
 src/nouveau/vulkan/nvk_descriptor_set.c       |  2 +-
 .../vulkan/nvk_descriptor_set_layout.c        |  2 +-
 src/nouveau/vulkan/nvk_image.c                | 10 +--
 src/nouveau/vulkan/nvk_image.h                |  2 +-
 src/nouveau/vulkan/nvk_image_view.c           |  4 +-
 .../vulkan/nvk_indirect_execution_set.c       | 14 +--
 src/nouveau/vulkan/nvk_mem_arena.c            |  2 +-
 src/nouveau/vulkan/nvk_mme.c                  |  2 +-
 .../vulkan/nvk_nir_lower_descriptors.c        | 22 ++---
 src/nouveau/vulkan/nvk_query_pool.c           |  8 +-
 src/nouveau/vulkan/nvk_sampler.c              |  8 +-
 src/nouveau/vulkan/nvk_shader.c               |  6 +-
 src/panfrost/compiler/bi_builder.h.py         |  2 +-
 src/panfrost/compiler/bi_opt_dual_tex.c       |  2 +-
 src/panfrost/compiler/bi_opt_mod_props.c      |  2 +-
 src/panfrost/compiler/bi_packer.c.py          |  6 +-
 src/panfrost/compiler/bi_printer.c.py         |  8 +-
 src/panfrost/compiler/bi_ra.c                 |  6 +-
 src/panfrost/compiler/bi_spill_ssa.c          |  2 +-
 src/panfrost/compiler/bifrost/bi_pack.c       |  6 +-
 src/panfrost/compiler/bifrost/bi_schedule.c   |  2 +-
 src/panfrost/compiler/bifrost/disassemble.c   |  4 +-
 src/panfrost/compiler/bifrost_compile.c       | 42 ++++-----
 src/panfrost/compiler/bir.c                   |  8 +-
 src/panfrost/compiler/compiler.h              |  8 +-
 src/panfrost/compiler/valhall/va_lower_isel.c |  2 +-
 src/panfrost/compiler/valhall/va_optimize.c   |  2 +-
 src/panfrost/compiler/valhall/va_pack.c       |  4 +-
 src/panfrost/compiler/valhall/va_perf.c       |  2 +-
 src/panfrost/genxml/cs_builder.h              |  6 +-
 src/panfrost/genxml/decode.c                  |  8 +-
 src/panfrost/genxml/decode_common.c           | 10 +--
 src/panfrost/lib/pan_afbc.h                   |  6 +-
 src/panfrost/lib/pan_afrc.h                   |  6 +-
 src/panfrost/lib/pan_blend.c                  | 12 +--
 src/panfrost/lib/pan_desc.c                   |  8 +-
 src/panfrost/lib/pan_desc.h                   |  2 +-
 src/panfrost/lib/pan_encoder.h                |  2 +-
 src/panfrost/lib/pan_format.c                 |  2 +-
 src/panfrost/lib/pan_format.h                 |  2 +-
 src/panfrost/lib/pan_mod.h                    |  2 +-
 src/panfrost/lib/pan_texture.c                | 14 +--
 src/panfrost/libpan/query_pool.cl             |  4 +-
 src/panfrost/midgard/disassemble.c            | 18 ++--
 src/panfrost/midgard/midgard_compile.c        | 34 ++++----
 src/panfrost/midgard/midgard_derivatives.c    |  2 +-
 src/panfrost/midgard/midgard_emit.c           | 10 +--
 src/panfrost/midgard/midgard_quirks.h         |  2 +-
 src/panfrost/midgard/midgard_ra.c             |  6 +-
 src/panfrost/midgard/midgard_schedule.c       |  6 +-
 src/panfrost/midgard/mir.c                    |  4 +-
 src/panfrost/perf/pan_perf.c                  |  4 +-
 src/panfrost/shared/pan_minmax_cache.c        |  2 +-
 src/panfrost/shared/pan_tiling.c              |  2 +-
 src/panfrost/shared/pan_tiling.h              |  2 +-
 src/panfrost/util/pan_collect_varyings.c      |  2 +-
 src/panfrost/util/pan_ir.c                    |  4 +-
 src/panfrost/util/pan_lower_framebuffer.c     | 12 +--
 src/panfrost/vulkan/csf/panvk_cmd_buffer.h    |  2 +-
 src/panfrost/vulkan/csf/panvk_vX_cmd_draw.c   |  6 +-
 src/panfrost/vulkan/csf/panvk_vX_cmd_query.c  |  8 +-
 src/panfrost/vulkan/csf/panvk_vX_gpu_queue.c  |  4 +-
 src/panfrost/vulkan/csf/panvk_vX_instr.c      |  4 +-
 src/panfrost/vulkan/jm/panvk_vX_cmd_draw.c    | 10 +--
 src/panfrost/vulkan/jm/panvk_vX_cmd_query.c   |  4 +-
 src/panfrost/vulkan/jm/panvk_vX_gpu_queue.c   |  4 +-
 src/panfrost/vulkan/panvk_image.c             |  6 +-
 src/panfrost/vulkan/panvk_macros.h            |  4 +-
 src/panfrost/vulkan/panvk_utrace_perfetto.cc  |  2 +-
 src/panfrost/vulkan/panvk_vX_cmd_draw.c       |  2 +-
 src/panfrost/vulkan/panvk_vX_descriptor_set.c |  6 +-
 src/panfrost/vulkan/panvk_vX_device.c         |  4 +-
 src/panfrost/vulkan/panvk_vX_image_view.c     |  4 +-
 .../vulkan/panvk_vX_nir_lower_descriptors.c   | 18 ++--
 src/panfrost/vulkan/panvk_vX_query_pool.c     |  4 +-
 src/panfrost/vulkan/panvk_vX_sampler.c        |  6 +-
 src/panfrost/vulkan/panvk_vX_shader.c         |  4 +-
 src/util/format/texcompress_s3tc_tmp.h        |  2 +-
 src/util/format/u_format_zs.c                 | 12 +--
 src/util/log.c                                |  7 +-
 src/util/macros.h                             | 21 ++++-
 src/util/u_tristate.h                         |  4 +-
 src/util/xmlconfig.c                          |  6 +-
 src/util/xmlconfig.h                          |  2 +-
 src/virtio/vdrm/vdrm_vpipe.c                  |  2 +-
 src/virtio/vulkan/vn_acceleration_structure.c | 10 +--
 src/virtio/vulkan/vn_command_buffer.c         |  4 +-
 src/virtio/vulkan/vn_common.c                 |  2 +-
 src/virtio/vulkan/vn_descriptor_set.c         |  8 +-
 src/virtio/vulkan/vn_image.c                  |  2 +-
 src/virtio/vulkan/vn_physical_device.c        |  4 +-
 src/virtio/vulkan/vn_query_pool.c             |  2 +-
 src/virtio/vulkan/vn_queue.c                  | 14 +--
 src/vulkan/overlay-layer/overlay.cpp          |  4 +-
 src/vulkan/runtime/rmv/vk_rmv_exporter.c      | 14 +--
 src/vulkan/runtime/rmv/vk_rmv_tokens.h        |  2 +-
 .../runtime/vk_acceleration_structure.c       | 18 ++--
 src/vulkan/runtime/vk_blend.c                 |  6 +-
 src/vulkan/runtime/vk_cmd_enqueue.c           |  2 +-
 src/vulkan/runtime/vk_command_buffer.c        |  2 +-
 src/vulkan/runtime/vk_device.c                |  2 +-
 src/vulkan/runtime/vk_device_memory.c         |  4 +-
 src/vulkan/runtime/vk_fence.c                 |  2 +-
 src/vulkan/runtime/vk_format_info_gen.py      |  2 +-
 src/vulkan/runtime/vk_graphics_state.c        |  6 +-
 src/vulkan/runtime/vk_graphics_state.h        |  2 +-
 src/vulkan/runtime/vk_image.c                 | 12 +--
 src/vulkan/runtime/vk_image.h                 |  4 +-
 src/vulkan/runtime/vk_log.c                   |  8 +-
 src/vulkan/runtime/vk_meta_blit_resolve.c     | 12 +--
 src/vulkan/runtime/vk_meta_copy_fill_update.c |  2 +-
 src/vulkan/runtime/vk_meta_object_list.c      |  2 +-
 src/vulkan/runtime/vk_meta_private.h          |  6 +-
 src/vulkan/runtime/vk_nir_convert_ycbcr.c     |  8 +-
 src/vulkan/runtime/vk_queue.c                 | 10 +--
 src/vulkan/runtime/vk_render_pass.c           |  4 +-
 src/vulkan/runtime/vk_sampler.c               |  4 +-
 src/vulkan/runtime/vk_semaphore.c             |  4 +-
 src/vulkan/runtime/vk_shader.c                |  2 +-
 .../runtime/vk_standard_sample_locations.c    |  2 +-
 src/vulkan/runtime/vk_synchronization.c       |  2 +-
 src/vulkan/runtime/vk_texcompress_astc.c      |  2 +-
 src/vulkan/runtime/vk_texcompress_etc2.h      |  2 +-
 src/vulkan/runtime/vk_video.c                 |  4 +-
 src/vulkan/screenshot-layer/screenshot.cpp    |  4 +-
 src/vulkan/util/gen_enum_to_str.py            |  2 +-
 src/vulkan/util/vk_cmd_queue_gen.py           |  2 +-
 src/vulkan/util/vk_dispatch_table_gen.py      |  2 +-
 src/vulkan/util/vk_format.c                   |  6 +-
 src/vulkan/util/vk_util.h                     |  4 +-
 .../vram_report_limit_layer.c                 |  2 +-
 src/vulkan/wsi/wsi_common.c                   |  8 +-
 src/vulkan/wsi/wsi_common_display.c           |  2 +-
 src/vulkan/wsi/wsi_common_wayland.c           |  2 +-
 src/vulkan/wsi/wsi_common_x11.c               |  6 +-
 1059 files changed, 3680 insertions(+), 3664 deletions(-)

diff --git a/src/amd/common/ac_descriptors.c b/src/amd/common/ac_descriptors.c
index 71edb08228256..c824bc84f3f3a 100644
--- a/src/amd/common/ac_descriptors.c
+++ b/src/amd/common/ac_descriptors.c
@@ -138,7 +138,7 @@ ac_build_gfx6_fmask_descriptor(const enum amd_gfx_level gfx_level, const struct
          num_format = V_008F14_IMG_NUM_FORMAT_FMASK_64_16_8;
          break;
       default:
-         unreachable("invalid nr_samples");
+         UNREACHABLE("invalid nr_samples");
       }
    } else {
       switch (FMASK(state->num_samples, state->num_storage_samples)) {
@@ -182,7 +182,7 @@ ac_build_gfx6_fmask_descriptor(const enum amd_gfx_level gfx_level, const struct
          data_format = V_008F14_IMG_DATA_FORMAT_FMASK64_S16_F8;
          break;
       default:
-         unreachable("invalid nr_samples");
+         UNREACHABLE("invalid nr_samples");
       }
       num_format = V_008F14_IMG_NUM_FORMAT_UINT;
    }
@@ -282,7 +282,7 @@ ac_build_gfx10_fmask_descriptor(const enum amd_gfx_level gfx_level, const struct
       format = V_008F0C_GFX10_FORMAT_FMASK64_S16_F8;
       break;
    default:
-      unreachable("invalid nr_samples");
+      UNREACHABLE("invalid nr_samples");
    }
 #undef FMASK
 
diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 7e4e9e00fe9b3..9f956ffb1cb1a 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1740,7 +1740,7 @@ ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info,
       max_hs_out_vram_dwords_enum = V_03093C_X_1K_DWORDS;
       break;
    default:
-      unreachable("invalid TCS workgroup size");
+      UNREACHABLE("invalid TCS workgroup size");
    }
 
    /* Vega10 should limit num_workgroups to 508 (127 per SE)
@@ -2247,7 +2247,7 @@ int ac_get_gs_table_depth(enum amd_gfx_level gfx_level, enum radeon_family famil
    case CHIP_VEGAM:
       return 32;
    default:
-      unreachable("Unknown GPU");
+      UNREACHABLE("Unknown GPU");
    }
 }
 
diff --git a/src/amd/common/ac_parse_ib.c b/src/amd/common/ac_parse_ib.c
index af34386a187f4..d85dfec11ed64 100644
--- a/src/amd/common/ac_parse_ib.c
+++ b/src/amd/common/ac_parse_ib.c
@@ -2152,7 +2152,7 @@ void ac_parse_ib_chunk(struct ac_ib_parser *ib)
    else if (ib->ip_type == AMD_IP_VCN_DEC || ib->ip_type == AMD_IP_VCN_ENC)
       parse_vcn_ib(memf, &tmp_ib);
    else
-      unreachable("unsupported IP type");
+      UNREACHABLE("unsupported IP type");
 
    u_memstream_close(&mem);
 
diff --git a/src/amd/common/ac_pm4.c b/src/amd/common/ac_pm4.c
index cfb7541ebd23f..d4b7faf7691cf 100644
--- a/src/amd/common/ac_pm4.c
+++ b/src/amd/common/ac_pm4.c
@@ -56,7 +56,7 @@ pairs_packed_opcode_to_regular(unsigned opcode)
    case PKT3_SET_SH_REG_PAIRS_PACKED:
       return PKT3_SET_SH_REG;
    default:
-      unreachable("invalid packed opcode");
+      UNREACHABLE("invalid packed opcode");
    }
 }
 
diff --git a/src/amd/common/ac_rgp.c b/src/amd/common/ac_rgp.c
index b8c3af3c2818a..c5783ac0eaf0a 100644
--- a/src/amd/common/ac_rgp.c
+++ b/src/amd/common/ac_rgp.c
@@ -362,7 +362,7 @@ static enum sqtt_gfxip_level ac_gfx_level_to_sqtt_gfxip_level(enum amd_gfx_level
    case GFX12:
       return SQTT_GFXIP_LEVEL_GFXIP_12;
    default:
-      unreachable("Invalid gfx level");
+      UNREACHABLE("Invalid gfx level");
    }
 }
 
@@ -394,7 +394,7 @@ static enum sqtt_memory_type ac_vram_type_to_sqtt_memory_type(uint32_t vram_type
    case AMD_VRAM_TYPE_LPDDR5:
       return SQTT_MEMORY_TYPE_LPDDR5;
    default:
-      unreachable("Invalid vram type");
+      UNREACHABLE("Invalid vram type");
    }
 }
 
@@ -712,7 +712,7 @@ static enum sqtt_version ac_gfx_level_to_sqtt_version(enum amd_gfx_level gfx_lev
    case GFX12:
       return SQTT_VERSION_3_3;
    default:
-      unreachable("Invalid gfx level");
+      UNREACHABLE("Invalid gfx level");
    }
 }
 
@@ -876,7 +876,7 @@ static enum elf_gfxip_level ac_gfx_level_to_elf_gfxip_level(enum amd_gfx_level g
    case GFX12:
       return EF_AMDGPU_MACH_AMDGCN_GFX1200;
    default:
-      unreachable("Invalid gfx level");
+      UNREACHABLE("Invalid gfx level");
    }
 }
 
diff --git a/src/amd/common/ac_rtld.c b/src/amd/common/ac_rtld.c
index df496af261910..f3e7b3acc6b87 100644
--- a/src/amd/common/ac_rtld.c
+++ b/src/amd/common/ac_rtld.c
@@ -469,7 +469,7 @@ static bool apply_relocs(const struct ac_rtld_upload_info *u, unsigned part_idx,
          *(uint64_t *)dst_ptr = util_cpu_to_le64(abs - va);
          break;
       default:
-         unreachable("bad r_type");
+         UNREACHABLE("bad r_type");
       }
    }
 
diff --git a/src/amd/common/ac_shader_util.c b/src/amd/common/ac_shader_util.c
index 173e9ed3672b0..3efaf222ba471 100644
--- a/src/amd/common/ac_shader_util.c
+++ b/src/amd/common/ac_shader_util.c
@@ -116,7 +116,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
    if (gfx_level >= GFX11) {
       switch (dfmt) {
       default:
-         unreachable("bad dfmt");
+         UNREACHABLE("bad dfmt");
       case V_008F0C_BUF_DATA_FORMAT_INVALID:
          return V_008F0C_GFX11_FORMAT_INVALID;
 
@@ -131,7 +131,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_8_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_8_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -149,7 +149,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_8_8_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_8_8_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -167,7 +167,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_8_8_8_8_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_8_8_8_8_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -185,7 +185,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_16_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_16_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -205,7 +205,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_16_16_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_16_16_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -225,7 +225,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_16_16_16_16_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_16_16_16_16_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -237,7 +237,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
       case V_008F0C_BUF_DATA_FORMAT_32:
          switch (nfmt) {
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_32_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -249,7 +249,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
       case V_008F0C_BUF_DATA_FORMAT_32_32:
          switch (nfmt) {
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_32_32_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -261,7 +261,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
       case V_008F0C_BUF_DATA_FORMAT_32_32_32:
          switch (nfmt) {
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_32_32_32_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -273,7 +273,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
       case V_008F0C_BUF_DATA_FORMAT_32_32_32_32:
          switch (nfmt) {
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_32_32_32_32_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -293,7 +293,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          case V_008F0C_BUF_NUM_FORMAT_SSCALED:
             return V_008F0C_GFX11_FORMAT_2_10_10_10_SSCALED;
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_UINT:
             return V_008F0C_GFX11_FORMAT_2_10_10_10_UINT;
          case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -303,7 +303,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
       case V_008F0C_BUF_DATA_FORMAT_10_11_11:
          switch (nfmt) {
          default:
-            unreachable("bad nfmt");
+            UNREACHABLE("bad nfmt");
          case V_008F0C_BUF_NUM_FORMAT_FLOAT:
             return V_008F0C_GFX11_FORMAT_10_11_11_FLOAT;
          }
@@ -312,7 +312,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
       unsigned format;
       switch (dfmt) {
       default:
-         unreachable("bad dfmt");
+         UNREACHABLE("bad dfmt");
       case V_008F0C_BUF_DATA_FORMAT_INVALID:
          format = V_008F0C_GFX10_FORMAT_INVALID;
          break;
@@ -373,7 +373,7 @@ unsigned ac_get_tbuffer_format(enum amd_gfx_level gfx_level, unsigned dfmt, unsi
          format -= 1;
          break;
       default:
-         unreachable("bad nfmt");
+         UNREACHABLE("bad nfmt");
       case V_008F0C_BUF_NUM_FORMAT_UINT:
          break;
       case V_008F0C_BUF_NUM_FORMAT_SINT:
@@ -580,7 +580,7 @@ enum ac_image_dim ac_get_sampler_dim(enum amd_gfx_level gfx_level, enum glsl_sam
    case GLSL_SAMPLER_DIM_SUBPASS_MS:
       return ac_image_2darraymsaa;
    default:
-      unreachable("bad sampler dim");
+      UNREACHABLE("bad sampler dim");
    }
 }
 
@@ -656,7 +656,7 @@ uint16_t ac_get_ps_iter_mask(unsigned ps_iter_samples)
    case 4: return 0x11;
    case 8: return 0x01;
    default:
-      unreachable("invalid sample count");
+      UNREACHABLE("invalid sample count");
    }
 }
 
@@ -885,7 +885,7 @@ unsigned ac_compute_lshs_workgroup_size(enum amd_gfx_level gfx_level, gl_shader_
    else if (stage == MESA_SHADER_TESS_CTRL)
       return hs_workgroup_size;
    else
-      unreachable("invalid LSHS shader stage");
+      UNREACHABLE("invalid LSHS shader stage");
 }
 
 unsigned ac_compute_ngg_workgroup_size(unsigned es_verts, unsigned gs_inst_prims,
diff --git a/src/amd/common/ac_shadowed_regs.c b/src/amd/common/ac_shadowed_regs.c
index 76640bac537ad..7fcd835ec0082 100644
--- a/src/amd/common/ac_shadowed_regs.c
+++ b/src/amd/common/ac_shadowed_regs.c
@@ -2872,7 +2872,7 @@ struct ac_pm4_state *ac_emulate_clear_state(const struct radeon_info *info)
    } else if (info->gfx_level == GFX9) {
       gfx9_emulate_clear_state(pm4);
    } else {
-      unreachable("unimplemented");
+      UNREACHABLE("unimplemented");
    }
 
    ac_pm4_finalize(pm4);
@@ -3066,7 +3066,7 @@ struct ac_pm4_state *ac_create_shadowing_ib_preamble(const struct radeon_info *i
       ac_pm4_cmd_add(pm4, PKT3(PKT3_PFP_SYNC_ME, 0, 0));
       ac_pm4_cmd_add(pm4, 0);
    } else {
-      unreachable("invalid chip");
+      UNREACHABLE("invalid chip");
    }
 
    ac_pm4_cmd_add(pm4, PKT3(PKT3_CONTEXT_CONTROL, 1, 0));
diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 08ea7a507a621..8cfa9b5579b12 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -111,7 +111,7 @@ unsigned ac_pipe_config_to_num_pipes(unsigned pipe_config)
    case V_009910_ADDR_SURF_P16_32x32_16x16:
       return 16;
    default:
-      unreachable("invalid pipe_config");
+      UNREACHABLE("invalid pipe_config");
    }
 }
 
@@ -774,7 +774,7 @@ static unsigned bpe_to_format(const struct radeon_surf *surf)
              */
             return ADDR_FMT_BC3;
          default:
-            unreachable("invalid compressed bpe");
+            UNREACHABLE("invalid compressed bpe");
          }
       } else if (surf->blk_w == 5 && surf->blk_h == 4)
          return ADDR_FMT_ASTC_5x4;
@@ -823,7 +823,7 @@ static unsigned bpe_to_format(const struct radeon_surf *surf)
          assert(!(surf->flags & RADEON_SURF_Z_OR_SBUFFER));
          return ADDR_FMT_32_32_32_32;
       default:
-         unreachable("invalid bpe");
+         UNREACHABLE("invalid bpe");
       }
    }
    return ADDR_FMT_INVALID;
@@ -1944,7 +1944,7 @@ static bool is_dcc_supported_by_CB(const struct radeon_info *info, unsigned sw_m
              sw_mode == ADDR_SW_256KB_Z_X || sw_mode == ADDR_SW_256KB_R_X;
 
    default:
-      unreachable("invalid gfx_level");
+      UNREACHABLE("invalid gfx_level");
    }
 }
 
@@ -2053,7 +2053,7 @@ static bool gfx9_is_dcc_supported_by_DCN(const struct radeon_info *info,
               (surf->u.gfx9.color.dcc.independent_64B_blocks &&
                surf->u.gfx9.color.dcc.max_compressed_block_size == V_028C78_MAX_BLOCK_SIZE_64B));
    default:
-      unreachable("unhandled chip");
+      UNREACHABLE("unhandled chip");
       return false;
    }
 }
@@ -4031,7 +4031,7 @@ static uint32_t ac_surface_get_pitch_align(const struct radeon_info *info,
          block_size_log2 = 18;
          break;
       default:
-         unreachable("unhandled swizzle mode");
+         UNREACHABLE("unhandled swizzle mode");
       }
 
       return 1 << ((block_size_log2 >> 1) - (bpe_log2 >> 1));
@@ -4059,7 +4059,7 @@ static uint32_t ac_surface_get_pitch_align(const struct radeon_info *info,
          block_size_log2 = 18;
          break;
       default:
-         unreachable("unhandled swizzle mode");
+         UNREACHABLE("unhandled swizzle mode");
       }
 
       if (info->gfx_level >= GFX10) {
@@ -4086,7 +4086,7 @@ static uint32_t ac_surface_get_pitch_align(const struct radeon_info *info,
          return 8 * surf->u.legacy.bankw * surf->u.legacy.mtilea *
                 ac_pipe_config_to_num_pipes(surf->u.legacy.pipe_config);
       default:
-         unreachable("unhandled surf mode");
+         UNREACHABLE("unhandled surf mode");
       }
    }
 }
@@ -4192,7 +4192,7 @@ uint64_t ac_surface_get_plane_offset(enum amd_gfx_level gfx_level,
       assert(!layer);
       return surf->meta_offset;
    default:
-      unreachable("Invalid plane index");
+      UNREACHABLE("Invalid plane index");
    }
 }
 
@@ -4213,7 +4213,7 @@ uint64_t ac_surface_get_plane_stride(enum amd_gfx_level gfx_level,
    case 2:
       return surf->u.gfx9.color.dcc_pitch_max + 1;
    default:
-      unreachable("Invalid plane index");
+      UNREACHABLE("Invalid plane index");
    }
 }
 
@@ -4229,7 +4229,7 @@ uint64_t ac_surface_get_plane_size(const struct radeon_surf *surf,
    case 2:
       return surf->meta_size;
    default:
-      unreachable("Invalid plane index");
+      UNREACHABLE("Invalid plane index");
    }
 }
 
@@ -4301,7 +4301,7 @@ ac_surface_addr_from_coord(struct ac_addrlib *addrlib, const struct radeon_info
    else if (info->gfx_level >= GFX9)
       return gfx9_surface_addr_from_coord(addrlib, info, surf, surf_info, level, x, y, layer, is_3d);
    else
-      unreachable("invalid gfx_level");
+      UNREACHABLE("invalid gfx_level");
 }
 
 static void
diff --git a/src/amd/common/ac_surface_meta_address_test.c b/src/amd/common/ac_surface_meta_address_test.c
index d07c44d66fa1d..288bc7de83d24 100644
--- a/src/amd/common/ac_surface_meta_address_test.c
+++ b/src/amd/common/ac_surface_meta_address_test.c
@@ -315,7 +315,7 @@ static void run_dcc_address_test(const char *name, const struct radeon_info *inf
       swizzle_modes[num_swizzle_modes++] = ADDR_SW_256KB_R_X;
       break;
    default:
-      unreachable("unhandled gfx level");
+      UNREACHABLE("unhandled gfx level");
    }
 
    if (full) {
@@ -493,7 +493,7 @@ static void run_htile_address_test(const char *name, const struct radeon_info *i
       swizzle_modes[num_swizzle_modes++] = ADDR_SW_256KB_Z_X;
       break;
    default:
-      unreachable("unhandled gfx level");
+      UNREACHABLE("unhandled gfx level");
    }
 
    /* The test coverage is reduced for Gitlab CI because it timeouts. */
diff --git a/src/amd/common/ac_surface_modifier_test.c b/src/amd/common/ac_surface_modifier_test.c
index e66863be23dc3..4e4e295a5666a 100644
--- a/src/amd/common/ac_surface_modifier_test.c
+++ b/src/amd/common/ac_surface_modifier_test.c
@@ -325,7 +325,7 @@ static void test_modifier(const struct radeon_info *info,
                block_size_bits = 18;
                break;
             default:
-               unreachable("invalid swizzle mode");
+               UNREACHABLE("invalid swizzle mode");
             }
          } else {
             switch (surf.u.gfx9.swizzle_mode) {
@@ -365,7 +365,7 @@ static void test_modifier(const struct radeon_info *info,
                block_size_bits = 18;
                break;
             default:
-               unreachable("invalid swizzle mode");
+               UNREACHABLE("invalid swizzle mode");
             }
          }
 
diff --git a/src/amd/common/amd_family.c b/src/amd/common/amd_family.c
index 79181b686c467..0d73fd90d7a7e 100644
--- a/src/amd/common/amd_family.c
+++ b/src/amd/common/amd_family.c
@@ -64,7 +64,7 @@ const char *ac_get_family_name(enum radeon_family family)
    CASE(GFX1201);
 #undef CASE
    default:
-      unreachable("Unknown GPU family");
+      UNREACHABLE("Unknown GPU family");
    }
 }
 
diff --git a/src/amd/common/nir/ac_nir.c b/src/amd/common/nir/ac_nir.c
index a0bb7e6ccfd34..c68c2c645ff09 100644
--- a/src/amd/common/nir/ac_nir.c
+++ b/src/amd/common/nir/ac_nir.c
@@ -332,7 +332,7 @@ ac_nir_varying_expression_max_cost(nir_shader *producer, nir_shader *consumer)
       return 12;
 
    default:
-      unreachable("unexpected shader stage");
+      UNREACHABLE("unexpected shader stage");
    }
 }
 
@@ -686,7 +686,7 @@ enum gl_access_qualifier ac_nir_get_mem_access_flags(const nir_intrinsic_instr *
          break;
 
       default:
-         unreachable("unexpected store instruction");
+         UNREACHABLE("unexpected store instruction");
       }
    }
 
@@ -762,7 +762,7 @@ summarize_repack(nir_builder *b, nir_def *packed_counts, bool mask_lane_id, unsi
          return nir_msad_4x8(b, nir_unpack_64_2x32_split_y(b, sad_op), nir_imm_int(b, 0), sum);
       }
    } else {
-      unreachable("Unimplemented NGG wave count");
+      UNREACHABLE("Unimplemented NGG wave count");
    }
 }
 
diff --git a/src/amd/common/nir/ac_nir_cull.c b/src/amd/common/nir/ac_nir_cull.c
index 289478a942387..6c58d77e3fad7 100644
--- a/src/amd/common/nir/ac_nir_cull.c
+++ b/src/amd/common/nir/ac_nir_cull.c
@@ -527,7 +527,7 @@ ac_nir_cull_primitive(nir_builder *b,
       return ac_nir_cull_line(b, skip_viewport_state_culling, initially_accepted, pos, &w_info,
                               accept_func, state);
    } else {
-      unreachable("point culling not implemented");
+      UNREACHABLE("point culling not implemented");
    }
 
    return NULL;
diff --git a/src/amd/common/nir/ac_nir_lower_image_opcodes_cdna.c b/src/amd/common/nir/ac_nir_lower_image_opcodes_cdna.c
index 364ed7280bda9..d863a00c15d23 100644
--- a/src/amd/common/nir/ac_nir_lower_image_opcodes_cdna.c
+++ b/src/amd/common/nir/ac_nir_lower_image_opcodes_cdna.c
@@ -39,7 +39,7 @@ static unsigned get_coord_components(enum glsl_sampler_dim dim, bool is_array)
    case GLSL_SAMPLER_DIM_3D:
       return 3;
    default:
-      unreachable("unexpected sampler type");
+      UNREACHABLE("unexpected sampler type");
    }
 }
 
@@ -402,7 +402,7 @@ static bool lower_image_opcodes(nir_builder *b, nir_instr *instr, void *data)
          return true;
 
       default:
-         unreachable("shouldn't get here");
+         UNREACHABLE("shouldn't get here");
       }
    } else if (instr->type == nir_instr_type_tex) {
       nir_tex_instr *tex = nir_instr_as_tex(instr);
@@ -468,7 +468,7 @@ static bool lower_image_opcodes(nir_builder *b, nir_instr *instr, void *data)
             case nir_tex_src_texture_offset:
             case nir_tex_src_sampler_offset:
             case nir_tex_src_plane:
-               unreachable("unsupported texture src");
+               UNREACHABLE("unsupported texture src");
 
             default:;
             }
@@ -493,7 +493,7 @@ static bool lower_image_opcodes(nir_builder *b, nir_instr *instr, void *data)
             return true;
 
          default:
-            unreachable("shouldn't get here");
+            UNREACHABLE("shouldn't get here");
          }
          break;
 
diff --git a/src/amd/common/nir/ac_nir_lower_intrinsics_to_args.c b/src/amd/common/nir/ac_nir_lower_intrinsics_to_args.c
index 873da051d28e2..853613e30d519 100644
--- a/src/amd/common/nir/ac_nir_lower_intrinsics_to_args.c
+++ b/src/amd/common/nir/ac_nir_lower_intrinsics_to_args.c
@@ -91,7 +91,7 @@ load_subgroup_id_lowered(lower_intrinsics_to_args_state *s, nir_builder *b)
          }
          return nir_ushr_imm(b, sgpr_local_invocation_index, util_logbase2(s->wave_size));
       } else {
-         unreachable("unimplemented for LS");
+         UNREACHABLE("unimplemented for LS");
       }
    } else if (s->hw_stage == AC_HW_LEGACY_GEOMETRY_SHADER ||
               s->hw_stage == AC_HW_NEXT_GEN_GEOMETRY_SHADER) {
@@ -281,7 +281,7 @@ lower_intrinsic_to_arg(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
             replacement = ac_nir_load_arg_upper_bound(b, s->args, s->args->gs_invocation_id, 31);
          }
       } else {
-         unreachable("unexpected shader stage");
+         UNREACHABLE("unexpected shader stage");
       }
       break;
    case nir_intrinsic_load_sample_id:
@@ -368,7 +368,7 @@ lower_intrinsic_to_arg(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
       else if (s->args->gs_wave_id.used)
          replacement = ac_nir_load_arg(b, s->args, s->args->gs_wave_id);
       else
-         unreachable("Shader doesn't have GS wave ID.");
+         UNREACHABLE("Shader doesn't have GS wave ID.");
       break;
    case nir_intrinsic_overwrite_vs_arguments_amd:
       s->vertex_id = intrin->src[0].ssa;
@@ -410,7 +410,7 @@ lower_intrinsic_to_arg(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
             }
          }
       } else {
-         unreachable("invalid stage");
+         UNREACHABLE("invalid stage");
       }
       break;
    case nir_intrinsic_load_primitive_id:
@@ -427,7 +427,7 @@ lower_intrinsic_to_arg(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
          else
             replacement = ac_nir_load_arg(b, s->args, s->args->gs_prim_id); /* NGG */
       } else {
-         unreachable("invalid stage");
+         UNREACHABLE("invalid stage");
       }
       break;
    case nir_intrinsic_load_tess_coord: {
diff --git a/src/amd/common/nir/ac_nir_lower_legacy_gs.c b/src/amd/common/nir/ac_nir_lower_legacy_gs.c
index 990d0b1c6beab..73e86458e1dec 100644
--- a/src/amd/common/nir/ac_nir_lower_legacy_gs.c
+++ b/src/amd/common/nir/ac_nir_lower_legacy_gs.c
@@ -176,7 +176,7 @@ ac_nir_lower_legacy_gs(nir_shader *nir, ac_nir_lower_legacy_gs_options *options,
       num_vertices_per_primitive = 3;
       break;
    default:
-      unreachable("Invalid GS output primitive.");
+      UNREACHABLE("Invalid GS output primitive.");
       break;
    }
 
diff --git a/src/amd/common/nir/ac_nir_lower_ngg.c b/src/amd/common/nir/ac_nir_lower_ngg.c
index b60de01231d5a..6f38294806980 100644
--- a/src/amd/common/nir/ac_nir_lower_ngg.c
+++ b/src/amd/common/nir/ac_nir_lower_ngg.c
@@ -1087,7 +1087,7 @@ add_deferred_attribute_culling(nir_builder *b, nir_cf_list *original_extracted_c
          if (s->deferred.uses_tess_primitive_id)
             nir_store_var(b, repacked_variables[2], nir_load_primitive_id(b), 0x1u);
       } else {
-         unreachable("Should be VS or TES.");
+         UNREACHABLE("Should be VS or TES.");
       }
    }
    nir_pop_if(b, if_es_thread);
@@ -1283,7 +1283,7 @@ add_deferred_attribute_culling(nir_builder *b, nir_cf_list *original_extracted_c
 
       nir_overwrite_tes_arguments_amd(b, u, v, prim_id, rel_patch_id);
    } else {
-      unreachable("Should be VS or TES.");
+      UNREACHABLE("Should be VS or TES.");
    }
 }
 
diff --git a/src/amd/common/nir/ac_nir_lower_ngg_gs.c b/src/amd/common/nir/ac_nir_lower_ngg_gs.c
index d2c391a43d503..bc2765cbeac4e 100644
--- a/src/amd/common/nir/ac_nir_lower_ngg_gs.c
+++ b/src/amd/common/nir/ac_nir_lower_ngg_gs.c
@@ -858,7 +858,7 @@ ac_nir_lower_ngg_gs(nir_shader *shader, const ac_nir_lower_ngg_options *options,
    else if (shader->info.gs.output_primitive == MESA_PRIM_TRIANGLE_STRIP)
       state.num_vertices_per_primitive = 3;
    else
-      unreachable("Invalid GS output primitive.");
+      UNREACHABLE("Invalid GS output primitive.");
 
    /* Extract the full control flow. It is going to be wrapped in an if statement. */
    nir_cf_list extracted;
diff --git a/src/amd/common/nir/ac_nir_lower_ngg_mesh.c b/src/amd/common/nir/ac_nir_lower_ngg_mesh.c
index 7ad00be1f822d..54bf7b2971099 100644
--- a/src/amd/common/nir/ac_nir_lower_ngg_mesh.c
+++ b/src/amd/common/nir/ac_nir_lower_ngg_mesh.c
@@ -275,7 +275,7 @@ ms_get_out_layout_part(unsigned location,
       }
    }
 
-   unreachable("Couldn't figure out mesh shader output mode.");
+   UNREACHABLE("Couldn't figure out mesh shader output mode.");
 }
 
 static void
@@ -357,7 +357,7 @@ ms_store_arrayed_output(nir_builder *b,
          nir_store_var(b, s->out_variables[idx], val, 0x1);
       }
    } else {
-      unreachable("Invalid MS output mode for store");
+      UNREACHABLE("Invalid MS output mode for store");
    }
 }
 
@@ -441,7 +441,7 @@ ms_load_arrayed_output(nir_builder *b,
       }
       return nir_vec(b, arr, num_components);
    } else {
-      unreachable("Invalid MS output mode for load");
+      UNREACHABLE("Invalid MS output mode for load");
    }
 }
 
@@ -513,7 +513,7 @@ lower_ms_intrinsic(nir_builder *b, nir_instr *instr, void *state)
    case nir_intrinsic_set_vertex_and_primitive_count:
       return lower_ms_set_vertex_and_primitive_count(b, intrin, s);
    default:
-      unreachable("Not a lowerable mesh shader intrinsic.");
+      UNREACHABLE("Not a lowerable mesh shader intrinsic.");
    }
 }
 
@@ -1310,7 +1310,7 @@ ms_calculate_output_layout(const struct radeon_info *hw_info, unsigned api_share
       else if (l.lds.vtx_attr.mask)
          ms_move_output(&l.lds.vtx_attr, &l.scratch_ring.vtx_attr);
       else
-         unreachable("API shader uses too much shared memory.");
+         UNREACHABLE("API shader uses too much shared memory.");
 
       ms_calculate_arrayed_output_layout(&l, max_vertices, max_primitives);
    }
diff --git a/src/amd/common/nir/ac_nir_lower_ps_late.c b/src/amd/common/nir/ac_nir_lower_ps_late.c
index 19d20f98afec2..7a5b143bc9c28 100644
--- a/src/amd/common/nir/ac_nir_lower_ps_late.c
+++ b/src/amd/common/nir/ac_nir_lower_ps_late.c
@@ -424,7 +424,7 @@ emit_ps_color_export(nir_builder *b, lower_ps_state *s, unsigned output_index, u
          pack_op = nir_op_pack_snorm_2x16;
          break;
       default:
-         unreachable("unsupported color export format");
+         UNREACHABLE("unsupported color export format");
          break;
       }
 
@@ -637,7 +637,7 @@ export_ps_outputs(nir_builder *b, lower_ps_state *s)
       case BITFIELD_RANGE(0, 2):
          break;
       default:
-         unreachable("unexpected number of color outputs for dual source blending");
+         UNREACHABLE("unexpected number of color outputs for dual source blending");
       }
    }
 
diff --git a/src/amd/common/nir/ac_nir_lower_resinfo.c b/src/amd/common/nir/ac_nir_lower_resinfo.c
index 7173514b7aab9..a2b2fa26b3ca0 100644
--- a/src/amd/common/nir/ac_nir_lower_resinfo.c
+++ b/src/amd/common/nir/ac_nir_lower_resinfo.c
@@ -225,7 +225,7 @@ lower_query_size(nir_builder *b, nir_def *desc, nir_src *lod,
       result = nir_vec3(b, width, height, depth);
       break;
    default:
-      unreachable("invalid sampler dim");
+      UNREACHABLE("invalid sampler dim");
    }
 
    return handle_null_desc(b, desc, result);
@@ -352,7 +352,7 @@ static bool lower_resinfo(nir_builder *b, nir_instr *instr, void *data)
             result = query_samples(b, desc, tex->sampler_dim, gfx_level);
             break;
          default:
-            unreachable("shouldn't get here");
+            UNREACHABLE("shouldn't get here");
          }
          break;
 
diff --git a/src/amd/common/nir/ac_nir_lower_taskmesh_io_to_mem.c b/src/amd/common/nir/ac_nir_lower_taskmesh_io_to_mem.c
index b9cde1bf2186c..983e08c87c127 100644
--- a/src/amd/common/nir/ac_nir_lower_taskmesh_io_to_mem.c
+++ b/src/amd/common/nir/ac_nir_lower_taskmesh_io_to_mem.c
@@ -271,7 +271,7 @@ lower_task_intrinsics(nir_builder *b,
       case nir_intrinsic_launch_mesh_workgroups:
          return lower_task_launch_mesh_workgroups(b, intrin, s);
       default:
-         unreachable("unsupported task shader intrinsic");
+         UNREACHABLE("unsupported task shader intrinsic");
    }
 }
 
@@ -338,7 +338,7 @@ lower_mesh_intrinsics(nir_builder *b,
    if (intrin->intrinsic == nir_intrinsic_load_task_payload)
       return lower_taskmesh_payload_load(b, intrin, s);
    else
-      unreachable("unsupported mesh shader intrinsic");
+      UNREACHABLE("unsupported mesh shader intrinsic");
 }
 
 bool
diff --git a/src/amd/common/nir/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/nir/ac_nir_lower_tess_io_to_mem.c
index 19e7ef652aa98..5918cb50c4673 100644
--- a/src/amd/common/nir/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/nir/ac_nir_lower_tess_io_to_mem.c
@@ -804,7 +804,7 @@ lower_hs_output_access(nir_builder *b,
       update_hs_barrier(intrin, st);
       return NIR_LOWER_INSTR_PROGRESS;
    } else {
-      unreachable("intrinsic not supported by lower_hs_output_access");
+      UNREACHABLE("intrinsic not supported by lower_hs_output_access");
    }
 }
 
diff --git a/src/amd/common/nir/ac_nir_lower_tex.c b/src/amd/common/nir/ac_nir_lower_tex.c
index 935710086f067..394ddd1e5ea98 100644
--- a/src/amd/common/nir/ac_nir_lower_tex.c
+++ b/src/amd/common/nir/ac_nir_lower_tex.c
@@ -474,7 +474,7 @@ move_coords_from_divergent_cf(struct move_tex_coords_state *state, nir_function_
          break;
       }
       case nir_cf_node_function:
-         unreachable("Invalid cf type");
+         UNREACHABLE("Invalid cf type");
       }
    }
 
diff --git a/src/amd/common/nir/ac_nir_meta_cs_clear_copy_buffer.c b/src/amd/common/nir/ac_nir_meta_cs_clear_copy_buffer.c
index a7febe22ca6ae..1f41cf9d6709e 100644
--- a/src/amd/common/nir/ac_nir_meta_cs_clear_copy_buffer.c
+++ b/src/amd/common/nir/ac_nir_meta_cs_clear_copy_buffer.c
@@ -419,7 +419,7 @@ ac_prepare_cs_clear_copy_buffer(const struct ac_cs_clear_copy_buffer_options *op
          break;
 
       case GFX12:
-         unreachable("cp_sdma_ge_use_system_memory_scope should be true, so we should never get here");
+         UNREACHABLE("cp_sdma_ge_use_system_memory_scope should be true, so we should never get here");
       }
    }
 
diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 186a1f1546f0b..b7468b477870a 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -405,7 +405,7 @@ emit_vintrp_instruction(asm_context& ctx, std::vector<uint32_t>& out, const Inst
       } else if (ctx.gfx_level >= GFX10) {
          encoding = (0b110101 << 26);
       } else {
-         unreachable("Unknown gfx_level.");
+         UNREACHABLE("Unknown gfx_level.");
       }
 
       unsigned opsel = instr->opcode == aco_opcode::v_interp_p2_hi_f16 ? 0x8 : 0;
@@ -1085,7 +1085,7 @@ emit_vop3_instruction(asm_context& ctx, std::vector<uint32_t>& out, const Instru
    } else if (ctx.gfx_level >= GFX10) {
       encoding = (0b110101 << 26);
    } else {
-      unreachable("Unknown gfx_level.");
+      UNREACHABLE("Unknown gfx_level.");
    }
 
    if (ctx.gfx_level <= GFX7) {
@@ -1136,7 +1136,7 @@ emit_vop3p_instruction(asm_context& ctx, std::vector<uint32_t>& out, const Instr
    } else if (ctx.gfx_level >= GFX10) {
       encoding = (0b110011 << 26);
    } else {
-      unreachable("Unknown gfx_level.");
+      UNREACHABLE("Unknown gfx_level.");
    }
 
    encoding |= opcode << 16;
@@ -1383,7 +1383,7 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
    case Format::PSEUDO:
    case Format::PSEUDO_BARRIER:
       if (instr->opcode != aco_opcode::p_unit_test)
-         unreachable("Pseudo instructions should be lowered before assembly.");
+         UNREACHABLE("Pseudo instructions should be lowered before assembly.");
       break;
    default:
       if (instr->isDPP16()) {
@@ -1399,7 +1399,7 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
       } else if (instr->isSDWA()) {
          emit_sdwa_instruction(ctx, out, instr);
       } else {
-         unreachable("unimplemented instruction format");
+         UNREACHABLE("unimplemented instruction format");
       }
       break;
    }
diff --git a/src/amd/compiler/aco_builder_h.py b/src/amd/compiler/aco_builder_h.py
index 7025add394cea..cab0cf58ea72c 100644
--- a/src/amd/compiler/aco_builder_h.py
+++ b/src/amd/compiler/aco_builder_h.py
@@ -358,7 +358,7 @@ public:
       case s_lshl:
          return aco_opcode::s_lshl_b32;
       default:
-         unreachable("Unsupported wave specific opcode.");
+         UNREACHABLE("Unsupported wave specific opcode.");
       }
    }
 
diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index bea6ee8ab8638..0c1d029e2c3de 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -728,7 +728,7 @@ add_branch_code(exec_ctx& ctx, Block* block)
       bld.branch(aco_opcode::p_cbranch_nz, bld.scc(cond), block->linear_succs[1],
                  block->linear_succs[0]);
    } else {
-      unreachable("unknown/invalid block type");
+      UNREACHABLE("unknown/invalid block type");
    }
 }
 
diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index 19c49610c6022..772e0bc023c53 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -838,7 +838,7 @@ get_reduction_identity(ReduceOp op, unsigned idx)
    case fmax16: return 0xfc00u;                /* negative infinity */
    case fmax32: return 0xff800000u;            /* negative infinity */
    case fmax64: return idx ? 0xfff00000u : 0u; /* negative infinity */
-   default: unreachable("Invalid reduction operation"); break;
+   default: UNREACHABLE("Invalid reduction operation"); break;
    }
    return 0;
 }
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index d577556a562cf..83b3e43ed8c68 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -783,7 +783,7 @@ public:
          case 255:
             return (signext && (data_.i & 0x80000000u) ? 0xffffffff00000000ull : 0ull) | data_.i;
          }
-         unreachable("invalid register for 64-bit constant");
+         UNREACHABLE("invalid register for 64-bit constant");
       } else {
          return data_.i;
       }
diff --git a/src/amd/compiler/aco_lower_branches.cpp b/src/amd/compiler/aco_lower_branches.cpp
index ebd74f0437397..0f5ea750d299c 100644
--- a/src/amd/compiler/aco_lower_branches.cpp
+++ b/src/amd/compiler/aco_lower_branches.cpp
@@ -483,7 +483,7 @@ lower_branch_instruction(branch_ctx& ctx, Block& block)
          bld.sopp(aco_opcode::s_cbranch_scc0, target);
       }
       break;
-   default: unreachable("Unknown Pseudo branch instruction!");
+   default: UNREACHABLE("Unknown Pseudo branch instruction!");
    }
 }
 
diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index 6cfcb5f22df88..df32dd7099b90 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -952,7 +952,7 @@ emit_reduction(lower_context* ctx, aco_opcode op, ReduceOp reduce_op, unsigned c
                      false, identity);
       }
       break;
-   default: unreachable("Invalid reduction mode");
+   default: UNREACHABLE("Invalid reduction mode");
    }
 
    if (op == aco_opcode::p_reduce) {
@@ -1418,7 +1418,7 @@ do_copy(lower_context* ctx, Builder& bld, const copy_operation& copy, bool* pres
       } else if (def.regClass().is_subdword()) {
          bld.vop1_sdwa(aco_opcode::v_mov_b32, def, op);
       } else {
-         unreachable("unsupported copy");
+         UNREACHABLE("unsupported copy");
       }
 
       did_copy = true;
diff --git a/src/amd/compiler/aco_opt_value_numbering.cpp b/src/amd/compiler/aco_opt_value_numbering.cpp
index 45d9847ac00b2..9aed42974cae3 100644
--- a/src/amd/compiler/aco_opt_value_numbering.cpp
+++ b/src/amd/compiler/aco_opt_value_numbering.cpp
@@ -226,7 +226,7 @@ struct InstrPred {
       case Format::EXP:
       case Format::SOPP:
       case Format::PSEUDO_BRANCH:
-      case Format::PSEUDO_BARRIER: unreachable("unsupported instruction format");
+      case Format::PSEUDO_BARRIER: UNREACHABLE("unsupported instruction format");
       default: return true;
       }
    }
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 44e5c3556897d..a3db0a9768459 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3166,7 +3166,7 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract)
    else if (bits_loaded == 16 && load->isSMEM() && !is_s_buffer)
       load->opcode = sign_ext ? aco_opcode::s_load_sshort : aco_opcode::s_load_ushort;
    else
-      unreachable("Forgot to add opcode above.");
+      UNREACHABLE("Forgot to add opcode above.");
 
    if (dst_bitsize <= 16 && ctx.program->gfx_level >= GFX9) {
       switch (load->opcode) {
@@ -4340,7 +4340,7 @@ to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                 pred_instr->definitions[1].physReg() == scc);
          op.setTemp(pred_instr->definitions[1].getTemp());
       } else {
-         unreachable("Invalid operand on uniform bitwise instruction.");
+         UNREACHABLE("Invalid operand on uniform bitwise instruction.");
       }
 
       ctx.uses[op.tempId()]++;
@@ -4792,7 +4792,7 @@ sopc_is_signed(aco_opcode opcode)
       SOPC(ge)
       SOPC(lt)
       SOPC(le)
-   default: unreachable("Not a valid SOPC instruction.");
+   default: UNREACHABLE("Not a valid SOPC instruction.");
    }
 #undef SOPC
 }
diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 03cf4c6e40448..bf184db6ca5a0 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -478,7 +478,7 @@ try_optimize_scc_nocompare(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
             cselect->operands[0] = Operand::c32(0);
             cselect->operands[1] = instr->operands[!scc_op_idx];
          } else {
-            unreachable("invalid op");
+            UNREACHABLE("invalid op");
          }
          scc_op_idx = 2;
          instr.reset(cselect);
diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index 4ff4fad737448..0facdf678e38d 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -876,7 +876,7 @@ print_stage(Stage stage, FILE* output)
       case SWStage::TS: fprintf(output, "TS"); break;
       case SWStage::MS: fprintf(output, "MS"); break;
       case SWStage::RT: fprintf(output, "RT"); break;
-      default: unreachable("invalid SW stage");
+      default: UNREACHABLE("invalid SW stage");
       }
       if (stage.num_sw_stages() > 1)
          fprintf(output, "+");
@@ -893,7 +893,7 @@ print_stage(Stage stage, FILE* output)
    case AC_HW_NEXT_GEN_GEOMETRY_SHADER: fprintf(output, "NEXT_GEN_GEOMETRY_SHADER"); break;
    case AC_HW_PIXEL_SHADER: fprintf(output, "PIXEL_SHADER"); break;
    case AC_HW_COMPUTE_SHADER: fprintf(output, "COMPUTE_SHADER"); break;
-   default: unreachable("invalid HW stage");
+   default: UNREACHABLE("invalid HW stage");
    }
 
    fprintf(output, ")\n");
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index db8e6f1f420f5..dc876f0f26b8b 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -672,7 +672,7 @@ add_subdword_operand(ra_ctx& ctx, aco_ptr<Instruction>& instr, unsigned idx, uns
    else if (instr->opcode == aco_opcode::global_store_short)
       instr->opcode = aco_opcode::global_store_short_d16_hi;
    else
-      unreachable("Something went wrong: Impossible register assignment.");
+      UNREACHABLE("Something went wrong: Impossible register assignment.");
    return;
 }
 
@@ -829,7 +829,7 @@ add_subdword_definition(Program* program, aco_ptr<Instruction>& instr, PhysReg r
    else if (instr->opcode == aco_opcode::ds_read_u16_d16)
       instr->opcode = aco_opcode::ds_read_u16_d16_hi;
    else
-      unreachable("Something went wrong: Impossible register assignment.");
+      UNREACHABLE("Something went wrong: Impossible register assignment.");
 }
 
 void
@@ -3237,7 +3237,7 @@ optimize_encoding_sopk(ra_ctx& ctx, RegisterFile& register_file, aco_ptr<Instruc
    case aco_opcode::s_add_i32: instr->opcode = aco_opcode::s_addk_i32; break;
    case aco_opcode::s_mul_i32: instr->opcode = aco_opcode::s_mulk_i32; break;
    case aco_opcode::s_cselect_b32: instr->opcode = aco_opcode::s_cmovk_i32; break;
-   default: unreachable("illegal instruction");
+   default: UNREACHABLE("illegal instruction");
    }
 }
 
diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index b2f74fee13a5d..8b1584c4ae422 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -1529,7 +1529,7 @@ assign_spill_slots(spill_ctx& ctx, unsigned spills_to_vgpr)
             if (!ctx.is_reloaded[spill_id]) {
                /* never reloaded, so don't spill */
             } else if (!is_assigned[spill_id]) {
-               unreachable("No spill slot assigned for spill id");
+               UNREACHABLE("No spill slot assigned for spill id");
             } else if (ctx.interferences[spill_id].first.type() == RegType::vgpr) {
                spill_vgpr(ctx, block, instructions, *it, slots);
             } else {
@@ -1576,7 +1576,7 @@ assign_spill_slots(spill_ctx& ctx, unsigned spills_to_vgpr)
             assert(ctx.is_reloaded[spill_id]);
 
             if (!is_assigned[spill_id]) {
-               unreachable("No spill slot assigned for spill id");
+               UNREACHABLE("No spill slot assigned for spill id");
             } else if (ctx.interferences[spill_id].first.type() == RegType::vgpr) {
                reload_vgpr(ctx, block, instructions, *it, slots);
             } else {
diff --git a/src/amd/compiler/instruction_selection/aco_isel_setup.cpp b/src/amd/compiler/instruction_selection/aco_isel_setup.cpp
index 6b0e7b2cabb9b..75a33bfca1225 100644
--- a/src/amd/compiler/instruction_selection/aco_isel_setup.cpp
+++ b/src/amd/compiler/instruction_selection/aco_isel_setup.cpp
@@ -143,7 +143,7 @@ sanitize_cf_list(nir_function_impl* impl, struct exec_list* cf_list)
          }
          break;
       }
-      case nir_cf_node_function: unreachable("Invalid cf type");
+      case nir_cf_node_function: UNREACHABLE("Invalid cf type");
       }
    }
 
@@ -726,7 +726,7 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
       case MESA_SHADER_CALLABLE:
       case MESA_SHADER_INTERSECTION:
       case MESA_SHADER_ANY_HIT: sw_stage = SWStage::RT; break;
-      default: unreachable("Shader stage not implemented");
+      default: UNREACHABLE("Shader stage not implemented");
       }
    }
 
diff --git a/src/amd/compiler/instruction_selection/aco_select_nir.cpp b/src/amd/compiler/instruction_selection/aco_select_nir.cpp
index 7586ce5181886..da183ad841c42 100644
--- a/src/amd/compiler/instruction_selection/aco_select_nir.cpp
+++ b/src/amd/compiler/instruction_selection/aco_select_nir.cpp
@@ -442,7 +442,7 @@ visit_tex(isel_context* ctx, nir_tex_instr* instr)
          case 2: op = aco_opcode::buffer_load_format_d16_xy; break;
          case 3: op = aco_opcode::buffer_load_format_d16_xyz; break;
          case 4: op = aco_opcode::buffer_load_format_d16_xyzw; break;
-         default: unreachable("Tex instruction loads more than 4 components.");
+         default: UNREACHABLE("Tex instruction loads more than 4 components.");
          }
       } else {
          switch (util_last_bit(dmask & 0xf)) {
@@ -450,7 +450,7 @@ visit_tex(isel_context* ctx, nir_tex_instr* instr)
          case 2: op = aco_opcode::buffer_load_format_xy; break;
          case 3: op = aco_opcode::buffer_load_format_xyz; break;
          case 4: op = aco_opcode::buffer_load_format_xyzw; break;
-         default: unreachable("Tex instruction loads more than 4 components.");
+         default: UNREACHABLE("Tex instruction loads more than 4 components.");
          }
       }
 
@@ -943,7 +943,7 @@ visit_cf_list(isel_context* ctx, struct exec_list* list)
       case nir_cf_node_block: visit_block(ctx, nir_cf_node_as_block(node)); break;
       case nir_cf_node_if: visit_if(ctx, nir_cf_node_as_if(node)); break;
       case nir_cf_node_loop: visit_loop(ctx, nir_cf_node_as_loop(node)); break;
-      default: unreachable("unimplemented cf list type");
+      default: UNREACHABLE("unimplemented cf list type");
       }
    }
 
diff --git a/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp b/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp
index 29be1f105a475..a6c6d39e8ac1c 100644
--- a/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp
+++ b/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp
@@ -2937,7 +2937,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          Temp one = bld.copy(bld.def(v1), Operand::c32(0x3c00u));
          bld.vop2(aco_opcode::v_cndmask_b32, Definition(dst), Operand::zero(), one, src);
       } else {
-         unreachable("Wrong destination register class for nir_op_b2f16.");
+         UNREACHABLE("Wrong destination register class for nir_op_b2f16.");
       }
       break;
    }
@@ -2952,7 +2952,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          bld.vop2_e64(aco_opcode::v_cndmask_b32, Definition(dst), Operand::zero(),
                       Operand::c32(0x3f800000u), src);
       } else {
-         unreachable("Wrong destination register class for nir_op_b2f32.");
+         UNREACHABLE("Wrong destination register class for nir_op_b2f32.");
       }
       break;
    }
@@ -2970,7 +2970,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             bld.vop2_e64(aco_opcode::v_cndmask_b32, bld.def(v1), Operand::zero(), one, src);
          bld.pseudo(aco_opcode::p_create_vector, Definition(dst), Operand::zero(), upper);
       } else {
-         unreachable("Wrong destination register class for nir_op_b2f64.");
+         UNREACHABLE("Wrong destination register class for nir_op_b2f64.");
       }
       break;
    }
@@ -3024,7 +3024,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          bld.vop2_e64(aco_opcode::v_cndmask_b32, Definition(dst), Operand::zero(), Operand::c32(1u),
                       src);
       } else {
-         unreachable("Invalid register class for b2i32");
+         UNREACHABLE("Invalid register class for b2i32");
       }
       break;
    }
@@ -3471,7 +3471,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
    case nir_op_ubfe:
    case nir_op_ibfe: {
       if (dst.bytes() != 4)
-         unreachable("Unsupported BFE bit size");
+         UNREACHABLE("Unsupported BFE bit size");
 
       if (dst.type() == RegType::sgpr) {
          Temp base = get_alu_src(ctx, instr->src[0]);
diff --git a/src/amd/compiler/instruction_selection/aco_select_nir_intrinsics.cpp b/src/amd/compiler/instruction_selection/aco_select_nir_intrinsics.cpp
index ff0c2a4cb9458..d479f0fd2c454 100644
--- a/src/amd/compiler/instruction_selection/aco_select_nir_intrinsics.cpp
+++ b/src/amd/compiler/instruction_selection/aco_select_nir_intrinsics.cpp
@@ -743,7 +743,7 @@ mubuf_load_format_callback(Builder& bld, const LoadEmitInfo& info, unsigned byte
       case 4: op = aco_opcode::buffer_load_format_d16_xy; break;
       case 6: op = aco_opcode::buffer_load_format_d16_xyz; break;
       case 8: op = aco_opcode::buffer_load_format_d16_xyzw; break;
-      default: unreachable("invalid buffer load format size"); break;
+      default: UNREACHABLE("invalid buffer load format size"); break;
       }
    } else {
       assert(info.component_size == 4);
@@ -752,7 +752,7 @@ mubuf_load_format_callback(Builder& bld, const LoadEmitInfo& info, unsigned byte
       case 8: op = aco_opcode::buffer_load_format_xy; break;
       case 12: op = aco_opcode::buffer_load_format_xyz; break;
       case 16: op = aco_opcode::buffer_load_format_xyzw; break;
-      default: unreachable("invalid buffer load format size"); break;
+      default: UNREACHABLE("invalid buffer load format size"); break;
       }
    }
 
@@ -1289,7 +1289,7 @@ get_buffer_store_op(unsigned bytes)
    case 12: return aco_opcode::buffer_store_dwordx3;
    case 16: return aco_opcode::buffer_store_dwordx4;
    }
-   unreachable("Unexpected store size");
+   UNREACHABLE("Unexpected store size");
    return aco_opcode::num_opcodes;
 }
 
@@ -1366,7 +1366,7 @@ resolve_excess_vmem_const_offset(Builder& bld, Temp& voffset, unsigned const_off
       else if (likely(voffset.regClass() == v1))
          voffset = bld.vadd32(bld.def(v1), Operand(voffset), Operand::c32(excess_const_offset));
       else
-         unreachable("Unsupported register class of voffset");
+         UNREACHABLE("Unsupported register class of voffset");
    }
 
    return const_offset;
@@ -1476,7 +1476,7 @@ visit_store_output(isel_context* ctx, nir_intrinsic_instr* instr)
          abort();
       }
    } else {
-      unreachable("Shader stage not implemented");
+      UNREACHABLE("Shader stage not implemented");
    }
 }
 
@@ -1660,7 +1660,7 @@ visit_load_tcs_per_vertex_input(isel_context* ctx, nir_intrinsic_instr* instr)
    if (load_input_from_temps(ctx, instr, dst))
       return;
 
-   unreachable("LDS-based TCS input should have been lowered in NIR.");
+   UNREACHABLE("LDS-based TCS input should have been lowered in NIR.");
 }
 
 void
@@ -1668,7 +1668,7 @@ visit_load_per_vertex_input(isel_context* ctx, nir_intrinsic_instr* instr)
 {
    switch (ctx->shader->info.stage) {
    case MESA_SHADER_TESS_CTRL: visit_load_tcs_per_vertex_input(ctx, instr); break;
-   default: unreachable("Unimplemented shader stage");
+   default: UNREACHABLE("Unimplemented shader stage");
    }
 }
 
@@ -2052,7 +2052,7 @@ visit_image_load(isel_context* ctx, nir_intrinsic_instr* instr)
          case 2: opcode = aco_opcode::buffer_load_format_xy; break;
          case 3: opcode = aco_opcode::buffer_load_format_xyz; break;
          case 4: opcode = aco_opcode::buffer_load_format_xyzw; break;
-         default: unreachable(">4 channel buffer image load");
+         default: UNREACHABLE(">4 channel buffer image load");
          }
       } else {
          switch (util_bitcount(dmask)) {
@@ -2060,7 +2060,7 @@ visit_image_load(isel_context* ctx, nir_intrinsic_instr* instr)
          case 2: opcode = aco_opcode::buffer_load_format_d16_xy; break;
          case 3: opcode = aco_opcode::buffer_load_format_d16_xyz; break;
          case 4: opcode = aco_opcode::buffer_load_format_d16_xyzw; break;
-         default: unreachable(">4 channel buffer image load");
+         default: UNREACHABLE(">4 channel buffer image load");
          }
       }
       aco_ptr<Instruction> load{create_instruction(opcode, Format::MUBUF, 3 + is_sparse, 1)};
@@ -2195,7 +2195,7 @@ visit_image_store(isel_context* ctx, nir_intrinsic_instr* instr)
          case 0x3: opcode = aco_opcode::buffer_store_format_xy; break;
          case 0x7: opcode = aco_opcode::buffer_store_format_xyz; break;
          case 0xf: opcode = aco_opcode::buffer_store_format_xyzw; break;
-         default: unreachable(">4 channel buffer image store");
+         default: UNREACHABLE(">4 channel buffer image store");
          }
       } else {
          switch (dmask) {
@@ -2203,7 +2203,7 @@ visit_image_store(isel_context* ctx, nir_intrinsic_instr* instr)
          case 0x3: opcode = aco_opcode::buffer_store_format_d16_xy; break;
          case 0x7: opcode = aco_opcode::buffer_store_format_d16_xyz; break;
          case 0xf: opcode = aco_opcode::buffer_store_format_d16_xyzw; break;
-         default: unreachable(">4 channel buffer image store");
+         default: UNREACHABLE(">4 channel buffer image store");
          }
       }
       aco_ptr<Instruction> store{create_instruction(opcode, Format::MUBUF, 4, 0)};
@@ -2323,7 +2323,7 @@ translate_buffer_image_atomic_op(const nir_atomic_op op, aco_opcode* buf_op, aco
       *buf_op64 = aco_opcode::buffer_atomic_fmax_x2;
       *image_op = aco_opcode::image_atomic_fmax;
       break;
-   default: unreachable("unsupported atomic operation");
+   default: UNREACHABLE("unsupported atomic operation");
    }
 }
 
@@ -2611,7 +2611,7 @@ visit_store_global(isel_context* ctx, nir_intrinsic_instr* instr)
          case 16:
             op = global ? aco_opcode::global_store_dwordx4 : aco_opcode::flat_store_dwordx4;
             break;
-         default: unreachable("store_global not implemented for this size.");
+         default: UNREACHABLE("store_global not implemented for this size.");
          }
 
          aco_ptr<Instruction> flat{create_instruction(op, format, 3, 0)};
@@ -2745,7 +2745,7 @@ visit_global_atomic(isel_context* ctx, nir_intrinsic_instr* instr)
          op32 = aco_opcode::num_opcodes;
          op64 = aco_opcode::global_atomic_ordered_add_b64;
          break;
-      default: unreachable("unsupported atomic operation");
+      default: UNREACHABLE("unsupported atomic operation");
       }
 
       aco_opcode op = instr->def.bit_size == 32 ? op32 : op64;
@@ -3020,7 +3020,7 @@ translate_nir_scope(mesa_scope scope)
    case SCOPE_DEVICE: return scope_device;
    case SCOPE_SHADER_CALL: return scope_invocation;
    }
-   unreachable("invalid scope");
+   UNREACHABLE("invalid scope");
 }
 
 void
@@ -3199,7 +3199,7 @@ visit_shared_atomic(isel_context* ctx, nir_intrinsic_instr* instr)
       op64 = aco_opcode::ds_max_f64;
       op64_rtn = aco_opcode::ds_max_rtn_f64;
       break;
-   default: unreachable("Unhandled shared atomic intrinsic");
+   default: UNREACHABLE("Unhandled shared atomic intrinsic");
    }
 
    bool return_previous = !nir_def_is_unused(&instr->def);
@@ -3251,7 +3251,7 @@ visit_shared_append(isel_context* ctx, nir_intrinsic_instr* instr)
    switch (instr->intrinsic) {
    case nir_intrinsic_shared_append_amd: op = aco_opcode::ds_append; break;
    case nir_intrinsic_shared_consume_amd: op = aco_opcode::ds_consume; break;
-   default: unreachable("not shared_append/consume");
+   default: UNREACHABLE("not shared_append/consume");
    }
 
    Temp tmp = bld.tmp(v1);
@@ -3423,7 +3423,7 @@ visit_store_scratch(isel_context* ctx, nir_intrinsic_instr* instr)
          case 8: op = aco_opcode::scratch_store_dwordx2; break;
          case 12: op = aco_opcode::scratch_store_dwordx3; break;
          case 16: op = aco_opcode::scratch_store_dwordx4; break;
-         default: unreachable("Unexpected store size");
+         default: UNREACHABLE("Unexpected store size");
          }
 
          uint32_t const_offset = base_const_offset + offsets[i];
@@ -3483,7 +3483,7 @@ get_reduce_op(nir_op op, unsigned bit_size)
       CASEF(fmul)
       CASEF(fmin)
       CASEF(fmax)
-   default: unreachable("unknown reduction op");
+   default: UNREACHABLE("unknown reduction op");
 #undef CASEI
 #undef CASEF
    }
@@ -3741,7 +3741,7 @@ inclusive_scan_to_exclusive(isel_context* ctx, ReduceOp op, Definition dst, Temp
    case ixor8:
    case ixor16:
    case ixor32: return bld.vop2(aco_opcode::v_xor_b32, dst, scan, src);
-   default: unreachable("Unsupported op");
+   default: UNREACHABLE("Unsupported op");
    }
 }
 
@@ -3862,22 +3862,22 @@ visit_cmat_muladd(isel_context* ctx, nir_intrinsic_instr* instr)
       switch (type_b) {
       case GLSL_TYPE_FLOAT_E4M3FN: opcode = aco_opcode::v_wmma_f32_16x16x16_fp8_fp8; break;
       case GLSL_TYPE_FLOAT_E5M2: opcode = aco_opcode::v_wmma_f32_16x16x16_fp8_bf8; break;
-      default: unreachable("invalid cmat_muladd_amd type");
+      default: UNREACHABLE("invalid cmat_muladd_amd type");
       }
       break;
    case GLSL_TYPE_FLOAT_E5M2:
       switch (type_b) {
       case GLSL_TYPE_FLOAT_E4M3FN: opcode = aco_opcode::v_wmma_f32_16x16x16_bf8_fp8; break;
       case GLSL_TYPE_FLOAT_E5M2: opcode = aco_opcode::v_wmma_f32_16x16x16_bf8_bf8; break;
-      default: unreachable("invalid cmat_muladd_amd type");
+      default: UNREACHABLE("invalid cmat_muladd_amd type");
       }
       break;
    }
-   default: unreachable("invalid cmat_muladd_amd type");
+   default: UNREACHABLE("invalid cmat_muladd_amd type");
    }
 
    if (opcode == aco_opcode::num_opcodes)
-      unreachable("visit_cmat_muladd: invalid bit size combination");
+      UNREACHABLE("visit_cmat_muladd: invalid bit size combination");
 
    Builder bld(ctx->program, ctx->block);
 
@@ -4041,7 +4041,7 @@ ds_bvh_stack_offset1_gfx11(unsigned stack_size)
    case 16: return 0x10;
    case 32: return 0x20;
    case 64: return 0x30;
-   default: unreachable("invalid stack size");
+   default: UNREACHABLE("invalid stack size");
    }
 }
 
@@ -4563,7 +4563,7 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       case nir_intrinsic_reduce: aco_op = aco_opcode::p_reduce; break;
       case nir_intrinsic_inclusive_scan: aco_op = aco_opcode::p_inclusive_scan; break;
       case nir_intrinsic_exclusive_scan: aco_op = aco_opcode::p_exclusive_scan; break;
-      default: unreachable("unknown reduce intrinsic");
+      default: UNREACHABLE("unknown reduce intrinsic");
       }
 
       /* Avoid whole wave shift. */
@@ -5156,7 +5156,7 @@ visit_intrinsic(isel_context* ctx, nir_intrinsic_instr* instr)
       switch (instr->num_components) {
       case 4: emit_ds_bvh_stack_push4_pop1_rtn(ctx, instr, bld); break;
       case 8: emit_ds_bvh_stack_push8_pop1_rtn(ctx, instr, bld); break;
-      default: unreachable("Invalid BVH stack component count!");
+      default: UNREACHABLE("Invalid BVH stack component count!");
       }
       break;
    }
diff --git a/src/amd/compiler/instruction_selection/aco_select_ps_epilog.cpp b/src/amd/compiler/instruction_selection/aco_select_ps_epilog.cpp
index 6a374cc876358..006f2a42eae97 100644
--- a/src/amd/compiler/instruction_selection/aco_select_ps_epilog.cpp
+++ b/src/amd/compiler/instruction_selection/aco_select_ps_epilog.cpp
@@ -51,7 +51,7 @@ emit_clamp_alpha_test(isel_context* ctx, const struct aco_ps_epilog_info* info,
          case COMPARE_FUNC_GREATER: opcode = aco_opcode::v_cmp_nlt_f32; break;
          case COMPARE_FUNC_NOTEQUAL: opcode = aco_opcode::v_cmp_nlg_f32; break;
          case COMPARE_FUNC_GEQUAL: opcode = aco_opcode::v_cmp_nle_f32; break;
-         default: unreachable("invalid alpha func");
+         default: UNREACHABLE("invalid alpha func");
          }
 
          Temp ref = get_arg(ctx, info->alpha_reference);
diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 4ccf1d8820041..e8d45ed5c1565 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -163,7 +163,7 @@ int ac_get_elem_bits(struct ac_llvm_context *ctx, LLVMTypeRef type)
    if (type == ctx->f64)
       return 64;
 
-   unreachable("Unhandled type kind in get_elem_bits");
+   UNREACHABLE("Unhandled type kind in get_elem_bits");
 }
 
 unsigned ac_get_type_size(LLVMTypeRef type)
@@ -207,7 +207,7 @@ static LLVMTypeRef to_integer_type_scalar(struct ac_llvm_context *ctx, LLVMTypeR
    else if (t == ctx->f64 || t == ctx->i64)
       return ctx->i64;
    else
-      unreachable("Unhandled integer size");
+      UNREACHABLE("Unhandled integer size");
 }
 
 LLVMTypeRef ac_to_integer_type(struct ac_llvm_context *ctx, LLVMTypeRef t)
@@ -225,7 +225,7 @@ LLVMTypeRef ac_to_integer_type(struct ac_llvm_context *ctx, LLVMTypeRef t)
       case AC_ADDR_SPACE_LDS:
          return ctx->i32;
       default:
-         unreachable("unhandled address space");
+         UNREACHABLE("unhandled address space");
       }
    }
    return to_integer_type_scalar(ctx, t);
@@ -259,7 +259,7 @@ static LLVMTypeRef to_float_type_scalar(struct ac_llvm_context *ctx, LLVMTypeRef
    else if (t == ctx->i64 || t == ctx->f64)
       return ctx->f64;
    else
-      unreachable("Unhandled float size");
+      UNREACHABLE("Unhandled float size");
 }
 
 LLVMTypeRef ac_to_float_type(struct ac_llvm_context *ctx, LLVMTypeRef t)
@@ -503,7 +503,7 @@ LLVMValueRef ac_build_varying_gather_values(struct ac_llvm_context *ctx, LLVMVal
    if (value_count == 1) {
       return values[component];
    } else if (!value_count)
-      unreachable("value_count is 0");
+      UNREACHABLE("value_count is 0");
 
    for (unsigned i = component; i < value_count + component; i++) {
       LLVMValueRef value = values[i];
@@ -527,7 +527,7 @@ LLVMValueRef ac_build_gather_values_extended(struct ac_llvm_context *ctx, LLVMVa
    if (value_count == 1 && !always_vector) {
       return values[0];
    } else if (!value_count)
-      unreachable("value_count is 0");
+      UNREACHABLE("value_count is 0");
 
    for (i = 0; i < value_count; i++) {
       LLVMValueRef value = values[i * value_stride];
@@ -1384,7 +1384,7 @@ LLVMValueRef ac_build_umsb(struct ac_llvm_context *ctx, LLVMValueRef arg, LLVMTy
       zero = ctx->i8_0;
       break;
    default:
-      unreachable("invalid bitsize");
+      UNREACHABLE("invalid bitsize");
       break;
    }
 
@@ -1531,7 +1531,7 @@ static unsigned ac_num_coords(enum ac_image_dim dim)
    case ac_image_2darraymsaa:
       return 4;
    default:
-      unreachable("ac_num_coords: bad dim");
+      UNREACHABLE("ac_num_coords: bad dim");
    }
 }
 
@@ -1550,7 +1550,7 @@ static unsigned ac_num_derivs(enum ac_image_dim dim)
    case ac_image_2dmsaa:
    case ac_image_2darraymsaa:
    default:
-      unreachable("derivatives not supported");
+      UNREACHABLE("derivatives not supported");
    }
 }
 
@@ -1586,7 +1586,7 @@ static const char *get_atomic_name(enum ac_atomic_op op)
    case ac_atomic_fmax:
       return "fmax";
    }
-   unreachable("bad atomic op");
+   UNREACHABLE("bad atomic op");
 }
 
 LLVMValueRef ac_build_image_opcode(struct ac_llvm_context *ctx, struct ac_image_args *a)
@@ -1764,7 +1764,7 @@ LLVMValueRef ac_build_image_opcode(struct ac_llvm_context *ctx, struct ac_image_
       name = "getresinfo";
       break;
    default:
-      unreachable("invalid image opcode");
+      UNREACHABLE("invalid image opcode");
    }
 
    const char *dimname;
@@ -1794,7 +1794,7 @@ LLVMValueRef ac_build_image_opcode(struct ac_llvm_context *ctx, struct ac_image_
       dimname = "2darraymsaa";
       break;
    default:
-      unreachable("invalid dim");
+      UNREACHABLE("invalid dim");
    }
 
    ac_build_type_name_for_intr(data_type, data_type_str, sizeof(data_type_str));
@@ -2186,7 +2186,7 @@ LLVMValueRef ac_build_bit_count(struct ac_llvm_context *ctx, LLVMValueRef src0)
       result = LLVMBuildZExt(ctx->builder, result, ctx->i32, "");
       break;
    default:
-      unreachable("invalid bitsize");
+      UNREACHABLE("invalid bitsize");
       break;
    }
 
@@ -2214,7 +2214,7 @@ LLVMValueRef ac_build_bitfield_reverse(struct ac_llvm_context *ctx, LLVMValueRef
       result = ac_build_intrinsic(ctx, "llvm.bitreverse.i8", ctx->i8, (LLVMValueRef[]){src0}, 1, 0);
       break;
    default:
-      unreachable("invalid bitsize");
+      UNREACHABLE("invalid bitsize");
       break;
    }
 
@@ -2272,7 +2272,7 @@ LLVMValueRef ac_find_lsb(struct ac_llvm_context *ctx, LLVMTypeRef dst_type, LLVM
       zero = ctx->i8_0;
       break;
    default:
-      unreachable("invalid bitsize");
+      UNREACHABLE("invalid bitsize");
    }
 
    LLVMValueRef params[2] = {
@@ -2900,7 +2900,7 @@ static LLVMValueRef get_reduction_identity(struct ac_llvm_context *ctx, nir_op o
       case nir_op_iand:
          return ctx->i1true;
       default:
-         unreachable("bad reduction intrinsic");
+         UNREACHABLE("bad reduction intrinsic");
       }
    } else if (type_size == 1) {
       switch (op) {
@@ -2923,7 +2923,7 @@ static LLVMValueRef get_reduction_identity(struct ac_llvm_context *ctx, nir_op o
       case nir_op_ixor:
          return ctx->i8_0;
       default:
-         unreachable("bad reduction intrinsic");
+         UNREACHABLE("bad reduction intrinsic");
       }
    } else if (type_size == 2) {
       switch (op) {
@@ -2954,7 +2954,7 @@ static LLVMValueRef get_reduction_identity(struct ac_llvm_context *ctx, nir_op o
       case nir_op_ixor:
          return ctx->i16_0;
       default:
-         unreachable("bad reduction intrinsic");
+         UNREACHABLE("bad reduction intrinsic");
       }
    } else if (type_size == 4) {
       switch (op) {
@@ -2985,7 +2985,7 @@ static LLVMValueRef get_reduction_identity(struct ac_llvm_context *ctx, nir_op o
       case nir_op_ixor:
          return ctx->i32_0;
       default:
-         unreachable("bad reduction intrinsic");
+         UNREACHABLE("bad reduction intrinsic");
       }
    } else { /* type_size == 64bit */
       switch (op) {
@@ -3016,7 +3016,7 @@ static LLVMValueRef get_reduction_identity(struct ac_llvm_context *ctx, nir_op o
       case nir_op_ixor:
          return ctx->i64_0;
       default:
-         unreachable("bad reduction intrinsic");
+         UNREACHABLE("bad reduction intrinsic");
       }
    }
 }
@@ -3062,7 +3062,7 @@ static LLVMValueRef ac_build_alu_op(struct ac_llvm_context *ctx, LLVMValueRef lh
    case nir_op_ixor:
       return LLVMBuildXor(ctx->builder, lhs, rhs, "");
    default:
-      unreachable("bad reduction intrinsic");
+      UNREACHABLE("bad reduction intrinsic");
    }
 }
 
diff --git a/src/amd/llvm/ac_llvm_helper.cpp b/src/amd/llvm/ac_llvm_helper.cpp
index cb59123dacaea..c726f20b166d2 100644
--- a/src/amd/llvm/ac_llvm_helper.cpp
+++ b/src/amd/llvm/ac_llvm_helper.cpp
@@ -415,7 +415,7 @@ LLVMValueRef ac_build_atomic_rmw(struct ac_llvm_context *ctx, LLVMAtomicRMWBinOp
       binop = AtomicRMWInst::FAdd;
       break;
    default:
-      unreachable("invalid LLVMAtomicRMWBinOp");
+      UNREACHABLE("invalid LLVMAtomicRMWBinOp");
       break;
    }
    unsigned SSID = unwrap(ctx->context)->getOrInsertSyncScopeID(sync_scope);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 7df1732062cdd..3ea0475c1b7d9 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -264,7 +264,7 @@ static LLVMValueRef emit_b2f(struct ac_llvm_context *ctx, LLVMValueRef src0, uns
    case 64:
       return LLVMBuildSelect(ctx->builder, src0, ctx->f64_1, ctx->f64_0, "");
    default:
-      unreachable("Unsupported bit size.");
+      UNREACHABLE("Unsupported bit size.");
    }
 }
 
@@ -290,7 +290,7 @@ static LLVMValueRef emit_b2i(struct ac_llvm_context *ctx, LLVMValueRef src0, uns
    case 64:
       return LLVMBuildSelect(ctx->builder, src0, ctx->i64_1, ctx->i64_0, "");
    default:
-      unreachable("Unsupported bit size.");
+      UNREACHABLE("Unsupported bit size.");
    }
 }
 
@@ -1650,7 +1650,7 @@ static void visit_store_ssbo(struct ac_nir_context *ctx, nir_intrinsic_instr *in
             data_type = ctx->ac.f32;
             break;
          default:
-            unreachable("Malformed vector store.");
+            UNREACHABLE("Malformed vector store.");
          }
          data = LLVMBuildBitCast(ctx->ac.builder, data, data_type, "");
 
@@ -1759,7 +1759,7 @@ translate_atomic_op(nir_atomic_op op)
    case nir_atomic_op_imin: return LLVMAtomicRMWBinOpMin;
    case nir_atomic_op_imax: return LLVMAtomicRMWBinOpMax;
    case nir_atomic_op_fadd: return LLVMAtomicRMWBinOpFAdd;
-   default: unreachable("Unexpected atomic");
+   default: UNREACHABLE("Unexpected atomic");
    }
 }
 
@@ -1914,7 +1914,7 @@ static LLVMValueRef get_memory_addr(struct ac_nir_context *ctx, nir_intrinsic_in
       return get_shared_mem_ptr(ctx, intr->src[num_src - 1], nir_intrinsic_base(intr));
    }
    default:
-      unreachable("unexpected store intrinsic");
+      UNREACHABLE("unexpected store intrinsic");
    }
 }
 
@@ -1986,7 +1986,7 @@ static LLVMValueRef visit_global_atomic(struct ac_nir_context *ctx,
          data_type = ctx->ac.f64;
          break;
       default:
-         unreachable("Unsupported float bit size");
+         UNREACHABLE("Unsupported float bit size");
       }
 
       data = LLVMBuildBitCast(ctx->ac.builder, data, data_type, "");
diff --git a/src/amd/vulkan/layers/radv_sqtt_layer.c b/src/amd/vulkan/layers/radv_sqtt_layer.c
index de2cca346b2d6..0d8f7ffbf5956 100644
--- a/src/amd/vulkan/layers/radv_sqtt_layer.c
+++ b/src/amd/vulkan/layers/radv_sqtt_layer.c
@@ -1356,7 +1356,7 @@ radv_get_rgp_shader_stage(struct radv_shader *shader)
    case MESA_SHADER_CALLABLE:
       return RGP_HW_STAGE_CS;
    default:
-      unreachable("invalid mesa shader stage");
+      UNREACHABLE("invalid mesa shader stage");
    }
 }
 
@@ -1463,7 +1463,7 @@ radv_add_rt_record(struct radv_device *device, struct rgp_code_object *code_obje
       snprintf(shader_data->rt_shader_name, sizeof(shader_data->rt_shader_name), "_amdgpu_cs_main");
       break;
    default:
-      unreachable("invalid rt stage");
+      UNREACHABLE("invalid rt stage");
    }
    record->num_shaders_combined = 1;
 
diff --git a/src/amd/vulkan/meta/radv_meta.c b/src/amd/vulkan/meta/radv_meta.c
index d8fb57205bb10..bdb95fc9a2224 100644
--- a/src/amd/vulkan/meta/radv_meta.c
+++ b/src/amd/vulkan/meta/radv_meta.c
@@ -239,7 +239,7 @@ radv_meta_get_view_type(const struct radv_image *image)
    case VK_IMAGE_TYPE_3D:
       return VK_IMAGE_VIEW_TYPE_3D;
    default:
-      unreachable("bad VkImageViewType");
+      UNREACHABLE("bad VkImageViewType");
    }
 }
 
diff --git a/src/amd/vulkan/meta/radv_meta.h b/src/amd/vulkan/meta/radv_meta.h
index 1da266b96f12d..be8005f058746 100644
--- a/src/amd/vulkan/meta/radv_meta.h
+++ b/src/amd/vulkan/meta/radv_meta.h
@@ -149,7 +149,7 @@ radv_meta_get_96bit_channel_format(VkFormat format)
       return VK_FORMAT_R32_SFLOAT;
       break;
    default:
-      unreachable("invalid R32G32B32 format");
+      UNREACHABLE("invalid R32G32B32 format");
    }
 }
 
diff --git a/src/amd/vulkan/meta/radv_meta_astc_decode.c b/src/amd/vulkan/meta/radv_meta_astc_decode.c
index 3e11e767d482f..c58b25a3f27eb 100644
--- a/src/amd/vulkan/meta/radv_meta_astc_decode.c
+++ b/src/amd/vulkan/meta/radv_meta_astc_decode.c
@@ -74,7 +74,7 @@ get_view_type(const struct radv_image *image)
    case VK_IMAGE_TYPE_3D:
       return VK_IMAGE_VIEW_TYPE_3D;
    default:
-      unreachable("bad VkImageViewType");
+      UNREACHABLE("bad VkImageViewType");
    }
 }
 
diff --git a/src/amd/vulkan/meta/radv_meta_blit.c b/src/amd/vulkan/meta/radv_meta_blit.c
index 3d792dafafcda..14ecce41d39cf 100644
--- a/src/amd/vulkan/meta/radv_meta_blit.c
+++ b/src/amd/vulkan/meta/radv_meta_blit.c
@@ -20,7 +20,7 @@ translate_sampler_dim(VkImageType type)
    case VK_IMAGE_TYPE_3D:
       return GLSL_SAMPLER_DIM_3D;
    default:
-      unreachable("Unhandled image type");
+      UNREACHABLE("Unhandled image type");
    }
 }
 
@@ -99,7 +99,7 @@ get_pipeline(struct radv_device *device, const struct radv_image_view *src_iview
       fs = radv_meta_nir_build_blit_copy_fragment_shader_stencil(device, tex_dim);
       break;
    default:
-      unreachable("Unhandled aspect");
+      UNREACHABLE("Unhandled aspect");
    }
 
    VkGraphicsPipelineCreateInfo pipeline_create_info = {
@@ -219,7 +219,7 @@ get_pipeline(struct radv_device *device, const struct radv_image_view *src_iview
       render.stencil_attachment_format = VK_FORMAT_S8_UINT;
       break;
    default:
-      unreachable("Unhandled aspect");
+      UNREACHABLE("Unhandled aspect");
    }
 
    result = vk_meta_create_graphics_pipeline(&device->vk, &device->meta_state.device, &pipeline_create_info, &render,
diff --git a/src/amd/vulkan/meta/radv_meta_blit2d.c b/src/amd/vulkan/meta/radv_meta_blit2d.c
index c7b79a246cbf3..87830ad1202c5 100644
--- a/src/amd/vulkan/meta/radv_meta_blit2d.c
+++ b/src/amd/vulkan/meta/radv_meta_blit2d.c
@@ -229,7 +229,7 @@ radv_meta_blit2d_normal_dst(struct radv_cmd_buffer *cmd_buffer, struct radv_meta
 
          radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
       } else
-         unreachable("Processing blit2d with multiple aspects.");
+         UNREACHABLE("Processing blit2d with multiple aspects.");
 
       float vertex_push_constants[4] = {
          rect->src_x,
@@ -368,7 +368,7 @@ get_color_pipeline(struct radv_device *device, enum blit2d_src_type src_type, Vk
       name = "meta_blit2d_buffer_fs";
       break;
    default:
-      unreachable("unknown blit src type\n");
+      UNREACHABLE("unknown blit src type\n");
       break;
    }
 
@@ -508,7 +508,7 @@ get_depth_only_pipeline(struct radv_device *device, enum blit2d_src_type src_typ
       name = "meta_blit2d_depth_buffer_fs";
       break;
    default:
-      unreachable("unknown blit src type\n");
+      UNREACHABLE("unknown blit src type\n");
       break;
    }
 
@@ -666,7 +666,7 @@ get_stencil_only_pipeline(struct radv_device *device, enum blit2d_src_type src_t
       name = "meta_blit2d_stencil_buffer_fs";
       break;
    default:
-      unreachable("unknown blit src type\n");
+      UNREACHABLE("unknown blit src type\n");
       break;
    }
 
diff --git a/src/amd/vulkan/meta/radv_meta_clear.c b/src/amd/vulkan/meta/radv_meta_clear.c
index 8fef3e9d1f77e..94151c5f4894a 100644
--- a/src/amd/vulkan/meta/radv_meta_clear.c
+++ b/src/amd/vulkan/meta/radv_meta_clear.c
@@ -1025,7 +1025,7 @@ radv_clear_dcc_comp_to_single(struct radv_cmd_buffer *cmd_buffer, struct radv_im
       format = VK_FORMAT_R32G32B32A32_UINT;
       break;
    default:
-      unreachable("Unsupported number of bytes per pixel");
+      UNREACHABLE("Unsupported number of bytes per pixel");
    }
 
    result = get_clear_dcc_comp_to_single_pipeline(device, is_msaa, &pipeline, &layout);
diff --git a/src/amd/vulkan/meta/radv_meta_copy.c b/src/amd/vulkan/meta/radv_meta_copy.c
index 18a4b2e470a86..845400d3835e0 100644
--- a/src/amd/vulkan/meta/radv_meta_copy.c
+++ b/src/amd/vulkan/meta/radv_meta_copy.c
@@ -27,7 +27,7 @@ vk_format_for_size(int bs)
    case 16:
       return VK_FORMAT_R32G32B32A32_UINT;
    default:
-      unreachable("Invalid format block size");
+      UNREACHABLE("Invalid format block size");
    }
 }
 
@@ -440,7 +440,7 @@ radv_get_compat_color_ds_format(VkFormat format)
    case VK_FORMAT_R32_UINT:
       return VK_FORMAT_R32_SFLOAT;
    default:
-      unreachable("invalid color format for color to depth/stencil image copy.");
+      UNREACHABLE("invalid color format for color to depth/stencil image copy.");
    }
 }
 
diff --git a/src/amd/vulkan/meta/radv_meta_fast_clear.c b/src/amd/vulkan/meta/radv_meta_fast_clear.c
index 1214267ec6bf4..cde546a794dfa 100644
--- a/src/amd/vulkan/meta/radv_meta_fast_clear.c
+++ b/src/amd/vulkan/meta/radv_meta_fast_clear.c
@@ -127,7 +127,7 @@ get_pipeline(struct radv_device *device, enum radv_color_op op, VkPipeline *pipe
          pdev->info.gfx_level >= GFX11 ? V_028808_CB_DCC_DECOMPRESS_GFX11 : V_028808_CB_DCC_DECOMPRESS_GFX8;
       break;
    default:
-      unreachable("Invalid color op");
+      UNREACHABLE("Invalid color op");
    }
 
    const VkGraphicsPipelineCreateInfo pipeline_create_info = {
@@ -335,7 +335,7 @@ radv_process_color_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *
       pred_offset = image->dcc_pred_offset;
       break;
    default:
-      unreachable("Invalid color op");
+      UNREACHABLE("Invalid color op");
    }
 
    if (radv_dcc_enabled(image, subresourceRange->baseMipLevel) &&
diff --git a/src/amd/vulkan/meta/radv_meta_resolve.c b/src/amd/vulkan/meta/radv_meta_resolve.c
index 9d1d07a7503f4..51e090da0047f 100644
--- a/src/amd/vulkan/meta/radv_meta_resolve.c
+++ b/src/amd/vulkan/meta/radv_meta_resolve.c
@@ -656,7 +656,7 @@ radv_cmd_buffer_resolve_rendering(struct radv_cmd_buffer *cmd_buffer)
             radv_cmd_buffer_resolve_rendering_fs(cmd_buffer, src_iview, src_layout, dst_iview, dst_layout);
             break;
          default:
-            unreachable("Invalid resolve method");
+            UNREACHABLE("Invalid resolve method");
          }
       }
    }
diff --git a/src/amd/vulkan/nir/radv_meta_nir.c b/src/amd/vulkan/nir/radv_meta_nir.c
index aa9d8549f778b..6a8100ceafd0e 100644
--- a/src/amd/vulkan/nir/radv_meta_nir.c
+++ b/src/amd/vulkan/nir/radv_meta_nir.c
@@ -1276,7 +1276,7 @@ radv_meta_resolve_compute_type_name(enum radv_meta_resolve_compute_type type)
    case RADV_META_RESOLVE_COMPUTE_FLOAT:
       return "float";
    default:
-      unreachable("invalid compute resolve type");
+      UNREACHABLE("invalid compute resolve type");
    }
 }
 
@@ -1341,7 +1341,7 @@ get_resolve_mode_str(VkResolveModeFlagBits resolve_mode)
    case VK_RESOLVE_MODE_MAX_BIT:
       return "max";
    default:
-      unreachable("invalid resolve mode");
+      UNREACHABLE("invalid resolve mode");
    }
 }
 
@@ -1402,7 +1402,7 @@ radv_meta_nir_build_depth_stencil_resolve_compute_shader(struct radv_device *dev
                outval = nir_umax(&b, outval, si);
             break;
          default:
-            unreachable("invalid resolve mode");
+            UNREACHABLE("invalid resolve mode");
          }
       }
 
@@ -1500,7 +1500,7 @@ radv_meta_nir_build_depth_stencil_resolve_fragment_shader(struct radv_device *de
                outval = nir_umax(&b, outval, si);
             break;
          default:
-            unreachable("invalid resolve mode");
+            UNREACHABLE("invalid resolve mode");
          }
       }
 
diff --git a/src/amd/vulkan/nir/radv_nir_lower_abi.c b/src/amd/vulkan/nir/radv_nir_lower_abi.c
index 6de91165ee0e9..6f3e84008912d 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_abi.c
@@ -135,7 +135,7 @@ lower_abi_instr(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
             replacement = nir_iadd_imm_nuw(b, n, 1);
          }
       } else
-         unreachable("invalid tessellation shader stage");
+         UNREACHABLE("invalid tessellation shader stage");
       break;
    case nir_intrinsic_load_pipeline_stat_query_enabled_amd:
       replacement = shader_query_bool_setting(b, radv_shader_query_pipeline_stat, s);
@@ -321,7 +321,7 @@ lower_abi_instr(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
                /* TES won't use this intrinsic, because it can get primitive id directly
                 * instead of using this intrinsic to pass primitive id by LDS.
                 */
-               unreachable("load_provoking_vtx_in_prim_amd is only supported in VS and GS");
+               UNREACHABLE("load_provoking_vtx_in_prim_amd is only supported in VS and GS");
             }
          }
 
@@ -410,7 +410,7 @@ lower_abi_instr(nir_builder *b, nir_intrinsic_instr *intrin, void *state)
             num_vertices = 3;
             break;
          default:
-            unreachable("invalid GS output primitive");
+            UNREACHABLE("invalid GS output primitive");
             break;
          }
          replacement = nir_imm_int(b, num_vertices);
diff --git a/src/amd/vulkan/nir/radv_nir_lower_cooperative_matrix.c b/src/amd/vulkan/nir/radv_nir_lower_cooperative_matrix.c
index 9cdc86418cff9..713b18ecd7a83 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_cooperative_matrix.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_cooperative_matrix.c
@@ -654,7 +654,7 @@ radv_nir_lower_cooperative_matrix(nir_shader *shader, enum amd_gfx_level gfx_lev
                      else if (src_use == GLSL_CMAT_USE_B)
                         src_use = GLSL_CMAT_USE_A;
                      else
-                        unreachable("unsupported transpose");
+                        UNREACHABLE("unsupported transpose");
                   }
                } else {
                   sat = nir_intrinsic_saturate(intr);
diff --git a/src/amd/vulkan/nir/radv_nir_lower_io.c b/src/amd/vulkan/nir/radv_nir_lower_io.c
index 0b454533406b8..516f46fc9491f 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_io.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_io.c
@@ -100,7 +100,7 @@ radv_recompute_fs_input_bases_callback(UNUSED nir_builder *b, nir_intrinsic_inst
       new_base = s->num_always_per_vertex + s->num_potentially_per_primitive +
                  util_bitcount64(s->always_per_primitive & location_mask);
    } else {
-      unreachable("invalid FS input");
+      UNREACHABLE("invalid FS input");
    }
 
    if (new_base != old_base) {
diff --git a/src/amd/vulkan/nir/radv_nir_lower_ray_queries.c b/src/amd/vulkan/nir/radv_nir_lower_ray_queries.c
index f521480c6d998..798643d865ef9 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_ray_queries.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_ray_queries.c
@@ -404,7 +404,7 @@ lower_rq_load(struct radv_device *device, nir_builder *b, nir_intrinsic_instr *i
       return radv_load_vertex_position(device, b, primitive_addr, nir_intrinsic_column(instr));
    }
    default:
-      unreachable("Invalid nir_ray_query_value!");
+      UNREACHABLE("Invalid nir_ray_query_value!");
    }
 
    return NULL;
@@ -671,7 +671,7 @@ radv_nir_lower_ray_queries(struct nir_shader *shader, struct radv_device *device
                lower_rq_terminate(&builder, intrinsic, rq);
                break;
             default:
-               unreachable("Unsupported ray query intrinsic!");
+               UNREACHABLE("Unsupported ray query intrinsic!");
             }
 
             if (new_dest)
diff --git a/src/amd/vulkan/nir/radv_nir_opt_tid_function.c b/src/amd/vulkan/nir/radv_nir_opt_tid_function.c
index 3fad46c3ed71a..29b1d093a4a10 100644
--- a/src/amd/vulkan/nir/radv_nir_opt_tid_function.c
+++ b/src/amd/vulkan/nir/radv_nir_opt_tid_function.c
@@ -238,7 +238,7 @@ constant_fold_scalar(nir_scalar s, unsigned invocation_id, nir_shader *shader, n
       return true;
    }
 
-   unreachable("unhandled scalar type");
+   UNREACHABLE("unhandled scalar type");
    return false;
 }
 
diff --git a/src/amd/vulkan/nir/radv_nir_rt_shader.c b/src/amd/vulkan/nir/radv_nir_rt_shader.c
index e14d8484ea0d9..c9eb714e172e4 100644
--- a/src/amd/vulkan/nir/radv_nir_rt_shader.c
+++ b/src/amd/vulkan/nir/radv_nir_rt_shader.c
@@ -1849,13 +1849,13 @@ lower_rt_instruction_monolithic(nir_builder *b, nir_instr *instr, void *data)
       return true;
    }
    case nir_intrinsic_rt_resume:
-      unreachable("nir_intrinsic_rt_resume");
+      UNREACHABLE("nir_intrinsic_rt_resume");
    case nir_intrinsic_rt_return_amd:
-      unreachable("nir_intrinsic_rt_return_amd");
+      UNREACHABLE("nir_intrinsic_rt_return_amd");
    case nir_intrinsic_execute_closest_hit_amd:
-      unreachable("nir_intrinsic_execute_closest_hit_amd");
+      UNREACHABLE("nir_intrinsic_execute_closest_hit_amd");
    case nir_intrinsic_execute_miss_amd:
-      unreachable("nir_intrinsic_execute_miss_amd");
+      UNREACHABLE("nir_intrinsic_execute_miss_amd");
    default:
       return false;
    }
diff --git a/src/amd/vulkan/radv_acceleration_structure.c b/src/amd/vulkan/radv_acceleration_structure.c
index 7eeeb392d9925..8c40765a2d070 100644
--- a/src/amd/vulkan/radv_acceleration_structure.c
+++ b/src/amd/vulkan/radv_acceleration_structure.c
@@ -96,7 +96,7 @@ radv_get_acceleration_structure_layout(struct radv_device *device,
          bvh_leaf_size = sizeof(struct radv_gfx12_instance_node) + sizeof(struct radv_gfx12_instance_node_user_data);
          break;
       default:
-         unreachable("Unknown VkGeometryTypeKHR");
+         UNREACHABLE("Unknown VkGeometryTypeKHR");
       }
       bvh_node_size_gcd = RADV_GFX12_BVH_NODE_SIZE;
    } else {
@@ -111,7 +111,7 @@ radv_get_acceleration_structure_layout(struct radv_device *device,
          bvh_leaf_size = sizeof(struct radv_bvh_instance_node);
          break;
       default:
-         unreachable("Unknown VkGeometryTypeKHR");
+         UNREACHABLE("Unknown VkGeometryTypeKHR");
       }
       bvh_node_size_gcd = 64;
    }
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d27533db5c8e8..f10b6d2e8e866 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1258,7 +1258,7 @@ radv_emit_sample_locations(struct radv_cmd_buffer *cmd_buffer)
       radeon_emit(sample_locs_pixel[3][1]);
       break;
    default:
-      unreachable("invalid number of samples");
+      UNREACHABLE("invalid number of samples");
    }
 
    if (pdev->info.gfx_level >= GFX12) {
@@ -3012,7 +3012,7 @@ radv_emit_graphics_shaders(struct radv_cmd_buffer *cmd_buffer)
          radv_emit_compute_shader(pdev, cmd_buffer->gang.cs, cmd_buffer->state.shaders[MESA_SHADER_TASK]);
          break;
       default:
-         unreachable("invalid bind stage");
+         UNREACHABLE("invalid bind stage");
       }
    }
 
@@ -3155,7 +3155,7 @@ radv_get_depth_clamp_mode(struct radv_cmd_buffer *cmd_buffer)
       mode = RADV_DEPTH_CLAMP_MODE_USER_DEFINED;
       break;
    default:
-      unreachable("invalid depth clamp mode\n");
+      UNREACHABLE("invalid depth clamp mode\n");
    }
 
    if (!d->vk.rs.depth_clamp_enable) {
@@ -3513,7 +3513,7 @@ radv_get_primitive_reset_index(const struct radv_cmd_buffer *cmd_buffer)
    case V_028A7C_VGT_INDEX_32:
       return 0xffffffffu;
    default:
-      unreachable("invalid index type");
+      UNREACHABLE("invalid index type");
    }
 }
 
@@ -5213,7 +5213,7 @@ radv_emit_tess_domain_origin(struct radv_cmd_buffer *cmd_buffer)
       type = V_028B6C_TESS_ISOLINE;
       break;
    default:
-      unreachable("Invalid tess primitive type");
+      UNREACHABLE("Invalid tess primitive type");
    }
 
    switch (tes->info.tes.spacing) {
@@ -5227,7 +5227,7 @@ radv_emit_tess_domain_origin(struct radv_cmd_buffer *cmd_buffer)
       partitioning = V_028B6C_PART_FRAC_EVEN;
       break;
    default:
-      unreachable("Invalid tess spacing type");
+      UNREACHABLE("Invalid tess spacing type");
    }
 
    if (tes->info.tes.point_mode) {
@@ -5672,7 +5672,7 @@ radv_flush_constants(struct radv_cmd_buffer *cmd_buffer, VkShaderStageFlags stag
       dirty_stages = VK_SHADER_STAGE_COMPUTE_BIT;
       break;
    default:
-      unreachable("Unhandled bind point");
+      UNREACHABLE("Unhandled bind point");
    }
 
    if (internal_stages & VK_SHADER_STAGE_COMPUTE_BIT) {
@@ -7023,7 +7023,7 @@ vk_to_index_type(VkIndexType type)
    case VK_INDEX_TYPE_UINT32:
       return V_028A7C_VGT_INDEX_32;
    default:
-      unreachable("invalid index type");
+      UNREACHABLE("invalid index type");
    }
 }
 
@@ -7039,7 +7039,7 @@ radv_get_vgt_index_size(uint32_t type)
    case V_028A7C_VGT_INDEX_32:
       return 4;
    default:
-      unreachable("invalid index type");
+      UNREACHABLE("invalid index type");
    }
 }
 
@@ -7726,7 +7726,7 @@ radv_bind_shader(struct radv_cmd_buffer *cmd_buffer, struct radv_shader *shader,
       /* no-op */
       break;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 
    cmd_buffer->state.shaders[stage] = shader;
@@ -14498,63 +14498,63 @@ radv_CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount,
                                      const float *pCoverageModulationTable)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
                              const VkViewportSwizzleNV *pViewportSwizzles)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable)
 {
-   unreachable("Not supported by RADV.");
+   UNREACHABLE("Not supported by RADV.");
 }
 
 VKAPI_ATTR void VKAPI_CALL
diff --git a/src/amd/vulkan/radv_cs.h b/src/amd/vulkan/radv_cs.h
index 60f201d366a4a..5e3f2d4b09439 100644
--- a/src/amd/vulkan/radv_cs.h
+++ b/src/amd/vulkan/radv_cs.h
@@ -358,7 +358,7 @@ radv_cp_wait_mem(struct radeon_cmdbuf *cs, const enum radv_queue_family qf, cons
    } else if (qf == RADV_QUEUE_TRANSFER) {
       radv_sdma_emit_wait_mem(cs, op, va, ref, mask);
    } else {
-      unreachable("unsupported queue family");
+      UNREACHABLE("unsupported queue family");
    }
 }
 
@@ -379,7 +379,7 @@ radv_cs_write_data_head(const struct radv_device *device, struct radeon_cmdbuf *
    } else if (qf == RADV_QUEUE_TRANSFER) {
       radv_sdma_emit_write_data_head(cs, va, count);
    } else {
-      unreachable("unsupported queue family");
+      UNREACHABLE("unsupported queue family");
    }
 
    return cdw_end;
diff --git a/src/amd/vulkan/radv_descriptors.c b/src/amd/vulkan/radv_descriptors.c
index e2dbd8ae83b32..15b48d3c000a7 100644
--- a/src/amd/vulkan/radv_descriptors.c
+++ b/src/amd/vulkan/radv_descriptors.c
@@ -187,6 +187,6 @@ radv_GetDescriptorEXT(VkDevice _device, const VkDescriptorGetInfoEXT *pDescripto
       break;
    }
    default:
-      unreachable("invalid descriptor type");
+      UNREACHABLE("invalid descriptor type");
    }
 }
diff --git a/src/amd/vulkan/radv_descriptors.h b/src/amd/vulkan/radv_descriptors.h
index 6162f7b42fee5..f241121ae4df7 100644
--- a/src/amd/vulkan/radv_descriptors.h
+++ b/src/amd/vulkan/radv_descriptors.h
@@ -165,7 +165,7 @@ radv_write_image_descriptor(unsigned *dst, unsigned size, VkDescriptorType descr
       memcpy(dst, descriptor, 64);
       break;
    default:
-      unreachable("Invalid size");
+      UNREACHABLE("Invalid size");
    }
 }
 
diff --git a/src/amd/vulkan/radv_dgc.c b/src/amd/vulkan/radv_dgc.c
index beea7c184ca7e..fe31b7dffd348 100644
--- a/src/amd/vulkan/radv_dgc.c
+++ b/src/amd/vulkan/radv_dgc.c
@@ -3428,7 +3428,7 @@ radv_CreateIndirectExecutionSetEXT(VkDevice _device, const VkIndirectExecutionSe
       break;
    }
    default:
-      unreachable("Invalid IES type");
+      UNREACHABLE("Invalid IES type");
    }
 
    stride = sizeof(struct radv_compute_pipeline_metadata);
@@ -3469,7 +3469,7 @@ radv_CreateIndirectExecutionSetEXT(VkDevice _device, const VkIndirectExecutionSe
       break;
    }
    default:
-      unreachable("Invalid IES type");
+      UNREACHABLE("Invalid IES type");
    }
 
    *pIndirectExecutionSet = radv_indirect_execution_set_to_handle(set);
diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index bd1c7af078a4d..905d3a64bcc56 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -912,7 +912,7 @@ radv_get_image_format_properties(struct radv_physical_device *pdev, const VkPhys
    } else if (tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
       format_feature_flags = radv_get_modifier_flags(pdev, format, mod_info->drmFormatModifier, &format_props);
    } else {
-      unreachable("bad VkImageTiling");
+      UNREACHABLE("bad VkImageTiling");
    }
 
    if (format_feature_flags == 0)
@@ -925,7 +925,7 @@ radv_get_image_format_properties(struct radv_physical_device *pdev, const VkPhys
 
    switch (info->type) {
    default:
-      unreachable("bad vkimage type\n");
+      UNREACHABLE("bad vkimage type\n");
    case VK_IMAGE_TYPE_1D:
       maxExtent.width = 16384;
       maxExtent.height = 1;
diff --git a/src/amd/vulkan/radv_formats.h b/src/amd/vulkan/radv_formats.h
index ee7dbba5a5b36..92321f3e144d6 100644
--- a/src/amd/vulkan/radv_formats.h
+++ b/src/amd/vulkan/radv_formats.h
@@ -66,7 +66,7 @@ radv_swizzle_conv(VkComponentSwizzle component, const unsigned char chan[4], VkC
    case VK_COMPONENT_SWIZZLE_A:
       return (enum pipe_swizzle)chan[vk_swiz - VK_COMPONENT_SWIZZLE_R];
    default:
-      unreachable("Illegal swizzle");
+      UNREACHABLE("Illegal swizzle");
    }
 }
 
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 586ae8e609a61..1ce795d51fb0d 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -655,7 +655,7 @@ radv_get_surface_flags(struct radv_device *device, struct radv_image *image, uns
       flags |= RADEON_SURF_SET(RADEON_SURF_TYPE_3D, TYPE);
       break;
    default:
-      unreachable("unhandled image type");
+      UNREACHABLE("unhandled image type");
    }
 
    /* Required for clearing/initializing a specific layer on GFX8. */
@@ -1389,7 +1389,7 @@ radv_select_modifier(const struct radv_device *dev, VkFormat format,
          }
       }
    }
-   unreachable("App specified an invalid modifier");
+   UNREACHABLE("App specified an invalid modifier");
 }
 
 VkResult
diff --git a/src/amd/vulkan/radv_image_view.c b/src/amd/vulkan/radv_image_view.c
index 9f5a140d21a28..1340407b58237 100644
--- a/src/amd/vulkan/radv_image_view.c
+++ b/src/amd/vulkan/radv_image_view.c
@@ -44,7 +44,7 @@ radv_tex_dim(VkImageType image_type, VkImageViewType view_type, unsigned nr_laye
       else
          return V_008F1C_SQ_RSRC_IMG_2D_ARRAY;
    default:
-      unreachable("illegal image type");
+      UNREACHABLE("illegal image type");
    }
 }
 
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 40f70c7435894..f4110dc4a6d7a 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -83,7 +83,7 @@ get_llvm_calling_convention(LLVMValueRef func, gl_shader_stage stage)
       return AC_LLVM_AMDGPU_CS;
       break;
    default:
-      unreachable("Unhandle shader type");
+      UNREACHABLE("Unhandle shader type");
    }
 }
 
diff --git a/src/amd/vulkan/radv_perfcounter.c b/src/amd/vulkan/radv_perfcounter.c
index 8a795b02db04b..2510e33045944 100644
--- a/src/amd/vulkan/radv_perfcounter.c
+++ b/src/amd/vulkan/radv_perfcounter.c
@@ -838,7 +838,7 @@ radv_pc_get_result(const struct radv_perfcounter_impl *impl, const uint64_t *dat
          result.float64 += radv_pc_sum_reg(impl->regs[2 * i], data) * radv_pc_sum_reg(impl->regs[2 * i + 1], data);
       break;
    default:
-      unreachable("unhandled performance counter operation");
+      UNREACHABLE("unhandled performance counter operation");
    }
    return result;
 }
diff --git a/src/amd/vulkan/radv_physical_device.c b/src/amd/vulkan/radv_physical_device.c
index 66349b863d427..7ff9307fc3876 100644
--- a/src/amd/vulkan/radv_physical_device.c
+++ b/src/amd/vulkan/radv_physical_device.c
@@ -511,7 +511,7 @@ radv_find_memory_index(const struct radv_physical_device *pdev, VkMemoryProperty
          return i;
       }
    }
-   unreachable("invalid memory properties");
+   UNREACHABLE("invalid memory properties");
 }
 
 static void
@@ -1431,7 +1431,7 @@ radv_get_compiler_string(struct radv_physical_device *pdev)
 #if AMD_LLVM_AVAILABLE
    return " (LLVM " MESA_LLVM_VERSION_STRING ")";
 #else
-   unreachable("LLVM is not available");
+   UNREACHABLE("LLVM is not available");
 #endif
 }
 
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 7dc1c107cedb8..8e77fd558369d 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -111,7 +111,7 @@ radv_pipeline_destroy(struct radv_device *device, struct radv_pipeline *pipeline
       radv_destroy_ray_tracing_pipeline(device, radv_pipeline_to_ray_tracing(pipeline));
       break;
    default:
-      unreachable("invalid pipeline type");
+      UNREACHABLE("invalid pipeline type");
    }
 
    radv_rmv_log_resource_destroy(device, (uint64_t)radv_pipeline_to_handle(pipeline));
@@ -174,7 +174,7 @@ radv_pipeline_get_shader_key(const struct radv_device *device, const VkPipelineS
       else if (subgroup_size->requiredSubgroupSize == 64)
          key.subgroup_required_size = RADV_REQUIRED_WAVE64;
       else
-         unreachable("Unsupported required subgroup size.");
+         UNREACHABLE("Unsupported required subgroup size.");
    }
 
    if (stage->flags & VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT) {
@@ -866,7 +866,7 @@ radv_GetPipelineExecutablePropertiesKHR(VkDevice _device, const VkPipelineInfoKH
          description = "Vulkan Callable Shader";
          break;
       default:
-         unreachable("Unsupported shader stage");
+         UNREACHABLE("Unsupported shader stage");
       }
 
       props->subgroupSize = shader->info.wave_size;
diff --git a/src/amd/vulkan/radv_pipeline_binary.c b/src/amd/vulkan/radv_pipeline_binary.c
index fc921883fa3b6..3f94c717f64a1 100644
--- a/src/amd/vulkan/radv_pipeline_binary.c
+++ b/src/amd/vulkan/radv_pipeline_binary.c
@@ -64,7 +64,7 @@ radv_get_pipeline_key(struct radv_device *device, const VkPipelineCreateInfoKHR
       break;
    }
    default:
-      unreachable("unsupported pipeline create info struct");
+      UNREACHABLE("unsupported pipeline create info struct");
    }
 
    return result;
diff --git a/src/amd/vulkan/radv_pipeline_graphics.c b/src/amd/vulkan/radv_pipeline_graphics.c
index b8ce85d640391..9a8c69295a9a5 100644
--- a/src/amd/vulkan/radv_pipeline_graphics.c
+++ b/src/amd/vulkan/radv_pipeline_graphics.c
@@ -380,7 +380,7 @@ radv_dynamic_state_mask(VkDynamicState state)
    case VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT:
       return RADV_DYNAMIC_SCISSOR | RADV_DYNAMIC_SCISSOR_WITH_COUNT;
    default:
-      unreachable("Unhandled dynamic state");
+      UNREACHABLE("Unhandled dynamic state");
    }
 }
 
@@ -568,7 +568,7 @@ shader_stage_to_pipeline_library_flags(VkShaderStageFlagBits stage)
    case VK_SHADER_STAGE_FRAGMENT_BIT:
       return VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT;
    default:
-      unreachable("Invalid shader stage");
+      UNREACHABLE("Invalid shader stage");
    }
 }
 
@@ -1458,7 +1458,7 @@ radv_graphics_shaders_link(const struct radv_device *device, const struct radv_g
          radv_link_fs(&stages[s], gfx_state);
          break;
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
 
       next_stage = &stages[s];
@@ -1485,7 +1485,7 @@ radv_graphics_shaders_fill_linked_vs_io_info(struct radv_shader_stage *vs_stage,
       break;
    }
    default:
-      unreachable("invalid next stage for VS");
+      UNREACHABLE("invalid next stage for VS");
    }
 }
 
@@ -2186,7 +2186,7 @@ radv_get_next_stage(gl_shader_stage stage, VkShaderStageFlagBits active_nir_stag
    case MESA_SHADER_FRAGMENT:
       return MESA_SHADER_NONE;
    default:
-      unreachable("invalid graphics shader stage");
+      UNREACHABLE("invalid graphics shader stage");
    }
 }
 
diff --git a/src/amd/vulkan/radv_pipeline_graphics.h b/src/amd/vulkan/radv_pipeline_graphics.h
index 545be0a0b6cea..bc550884d8f40 100644
--- a/src/amd/vulkan/radv_pipeline_graphics.h
+++ b/src/amd/vulkan/radv_pipeline_graphics.h
@@ -255,7 +255,7 @@ radv_translate_prim(unsigned topology)
    case VK_PRIMITIVE_TOPOLOGY_META_RECT_LIST_MESA:
       return V_008958_DI_PT_RECTLIST;
    default:
-      unreachable("unhandled primitive type");
+      UNREACHABLE("unhandled primitive type");
    }
 }
 
@@ -415,7 +415,7 @@ radv_translate_blend_logic_op(VkLogicOp op)
    case VK_LOGIC_OP_SET:
       return V_028808_ROP3_SET;
    default:
-      unreachable("Unhandled logic op");
+      UNREACHABLE("Unhandled logic op");
    }
 }
 
diff --git a/src/amd/vulkan/radv_pipeline_rt.c b/src/amd/vulkan/radv_pipeline_rt.c
index 54b9e0b94d1e5..acdcea3dff2bb 100644
--- a/src/amd/vulkan/radv_pipeline_rt.c
+++ b/src/amd/vulkan/radv_pipeline_rt.c
@@ -140,7 +140,7 @@ radv_create_group_handles(struct radv_device *device, const VkRayTracingPipeline
          }
          break;
       case VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR:
-         unreachable("VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR");
+         UNREACHABLE("VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR");
       }
 
       if (group_info->pShaderGroupCaptureReplayHandle) {
@@ -817,7 +817,7 @@ compute_rt_stack_size(const VkRayTracingPipelineCreateInfoKHR *pCreateInfo, stru
          any_hit_size = MAX2(any_hit_size, size);
          break;
       default:
-         unreachable("Invalid stage type in RT shader");
+         UNREACHABLE("Invalid stage type in RT shader");
       }
    }
    pipeline->stack_size =
diff --git a/src/amd/vulkan/radv_printf.c b/src/amd/vulkan/radv_printf.c
index a9b892cf33f31..32f24ab8636fb 100644
--- a/src/amd/vulkan/radv_printf.c
+++ b/src/amd/vulkan/radv_printf.c
@@ -329,7 +329,7 @@ radv_dump_printf_data(struct radv_device *device, FILE *out)
                break;
             }
             default:
-               unreachable("Unsupported data type");
+               UNREACHABLE("Unsupported data type");
             }
 
             if (lane != lane_count - 1)
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index f4b4b42deeac6..d322673229c04 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1742,7 +1742,7 @@ get_pipeline(struct radv_device *device, VkQueryType query_type, VkPipeline *pip
       key = RADV_META_OBJECT_KEY_QUERY_MESH_PRIMS_GEN;
       break;
    default:
-      unreachable("invalid query type");
+      UNREACHABLE("invalid query type");
    }
 
    VkPipeline pipeline_from_cache = vk_meta_lookup_pipeline(&device->meta_state.device, &key, sizeof(key));
@@ -1771,7 +1771,7 @@ get_pipeline(struct radv_device *device, VkQueryType query_type, VkPipeline *pip
       cs = build_ms_prim_gen_query_shader(device);
       break;
    default:
-      unreachable("invalid query type");
+      UNREACHABLE("invalid query type");
    }
 
    const VkPipelineShaderStageCreateInfo stage_info = {
@@ -1998,7 +1998,7 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
       pool->stride = 48;
       break;
    default:
-      unreachable("creating unhandled query type");
+      UNREACHABLE("creating unhandled query type");
    }
 
    pool->availability_offset = pool->stride * pCreateInfo->queryCount;
@@ -2425,7 +2425,7 @@ radv_GetQueryPoolResults(VkDevice _device, VkQueryPool queryPool, uint32_t first
          break;
       }
       default:
-         unreachable("trying to get results of unhandled query type");
+         UNREACHABLE("trying to get results of unhandled query type");
       }
 
       if (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT) {
@@ -2519,7 +2519,7 @@ radv_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPoo
       radv_copy_ms_prim_query_result(cmd_buffer, pool, firstQuery, queryCount, dst_va, stride, flags);
       break;
    default:
-      unreachable("trying to get results of unhandled query type");
+      UNREACHABLE("trying to get results of unhandled query type");
    }
 
    radv_resume_conditional_rendering(cmd_buffer);
@@ -2598,7 +2598,7 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
       cmd_buffer->video.feedback_query_va = va;
       break;
    default:
-      unreachable("beginning unhandled query type");
+      UNREACHABLE("beginning unhandled query type");
    }
 }
 
@@ -2632,7 +2632,7 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
       cmd_buffer->video.feedback_query_va = 0;
       break;
    default:
-      unreachable("ending unhandled query type");
+      UNREACHABLE("ending unhandled query type");
    }
 
    cmd_buffer->active_query_flush_bits |=
@@ -2817,7 +2817,7 @@ radv_CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer,
          va += offsetof(struct radv_accel_struct_header, size);
          break;
       default:
-         unreachable("Unhandle accel struct query type.");
+         UNREACHABLE("Unhandle accel struct query type.");
       }
 
       radeon_emit(PKT3(PKT3_COPY_DATA, 4, 0));
diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index ade56c2a36fd2..c2b38f7c431cd 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -41,7 +41,7 @@ radv_get_queue_global_priority(const VkDeviceQueueGlobalPriorityCreateInfo *pObj
    case VK_QUEUE_GLOBAL_PRIORITY_LOW:
       return RADEON_CTX_PRIORITY_LOW;
    default:
-      unreachable("Illegal global priority value");
+      UNREACHABLE("Illegal global priority value");
       return RADEON_CTX_PRIORITY_INVALID;
    }
 }
@@ -2146,6 +2146,6 @@ radv_queue_family_to_ring(const struct radv_physical_device *pdev, enum radv_que
    case RADV_QUEUE_VIDEO_ENC:
       return AMD_IP_VCN_ENC;
    default:
-      unreachable("Unknown queue family");
+      UNREACHABLE("Unknown queue family");
    }
 }
diff --git a/src/amd/vulkan/radv_rmv.c b/src/amd/vulkan/radv_rmv.c
index b8ceb7ee65376..f722e54df9be0 100644
--- a/src/amd/vulkan/radv_rmv.c
+++ b/src/amd/vulkan/radv_rmv.c
@@ -381,7 +381,7 @@ fill_memory_info(const struct radeon_info *gpu_info, struct vk_rmv_memory_info *
       out_info->size = MIN2((uint64_t)gpu_info->gart_size_kb * 1024ULL, ram_size);
    } break;
    default:
-      unreachable("invalid memory index");
+      UNREACHABLE("invalid memory index");
    }
 }
 
@@ -410,7 +410,7 @@ memory_type_from_vram_type(uint32_t vram_type)
    case AMD_VRAM_TYPE_LPDDR5:
       return VK_RMV_MEMORY_TYPE_LPDDR5;
    default:
-      unreachable("Invalid vram type");
+      UNREACHABLE("Invalid vram type");
    }
 }
 
@@ -929,7 +929,7 @@ radv_rmv_log_submit(struct radv_device *device, enum amd_ip_type type)
       vk_rmv_log_misc_token(&device->vk, VK_RMV_MISC_EVENT_TYPE_SUBMIT_COPY);
       break;
    default:
-      unreachable("invalid ip type");
+      UNREACHABLE("invalid ip type");
    }
 }
 
diff --git a/src/amd/vulkan/radv_rra.c b/src/amd/vulkan/radv_rra.c
index e9249fb2d8fe4..682bf881749e0 100644
--- a/src/amd/vulkan/radv_rra.c
+++ b/src/amd/vulkan/radv_rra.c
@@ -153,7 +153,7 @@ amdgpu_vram_type_to_rra(uint32_t type)
    case AMD_VRAM_TYPE_LPDDR5:
       return RRA_MEMORY_TYPE_LPDDR5;
    default:
-      unreachable("invalid vram type");
+      UNREACHABLE("invalid vram type");
    }
 }
 
diff --git a/src/amd/vulkan/radv_rra_gfx12.c b/src/amd/vulkan/radv_rra_gfx12.c
index 0aad6987ea948..771eaa8d23161 100644
--- a/src/amd/vulkan/radv_rra_gfx12.c
+++ b/src/amd/vulkan/radv_rra_gfx12.c
@@ -142,7 +142,7 @@ rra_gather_bvh_info_gfx12(const uint8_t *bvh, uint32_t node_id, struct rra_bvh_i
       dst->leaf_nodes_size += sizeof(struct radv_gfx12_primitive_node);
       break;
    default:
-      unreachable("Invalid node type");
+      UNREACHABLE("Invalid node type");
       break;
    }
 
diff --git a/src/amd/vulkan/radv_sampler.c b/src/amd/vulkan/radv_sampler.c
index 61d62771ea49e..9bcfa479093dc 100644
--- a/src/amd/vulkan/radv_sampler.c
+++ b/src/amd/vulkan/radv_sampler.c
@@ -32,7 +32,7 @@ radv_tex_wrap(VkSamplerAddressMode address_mode)
    case VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE:
       return V_008F30_SQ_TEX_MIRROR_ONCE_LAST_TEXEL;
    default:
-      unreachable("illegal tex wrap mode");
+      UNREACHABLE("illegal tex wrap mode");
       break;
    }
    return 0;
@@ -59,7 +59,7 @@ radv_tex_compare(VkCompareOp op)
    case VK_COMPARE_OP_ALWAYS:
       return V_008F30_SQ_TEX_DEPTH_COMPARE_ALWAYS;
    default:
-      unreachable("illegal compare mode");
+      UNREACHABLE("illegal compare mode");
       break;
    }
    return 0;
diff --git a/src/amd/vulkan/radv_sdma.c b/src/amd/vulkan/radv_sdma.c
index 9ef0b031064e8..a346a3a1ddbde 100644
--- a/src/amd/vulkan/radv_sdma.c
+++ b/src/amd/vulkan/radv_sdma.c
@@ -255,7 +255,7 @@ radv_sdma_get_tiled_info_dword(const struct radv_device *const device, const str
    } else if (ver >= SDMA_4_0) {
       return info | dimension << 9 | surf->u.gfx9.epitch << 16;
    } else {
-      unreachable("unsupported SDMA version");
+      UNREACHABLE("unsupported SDMA version");
    }
 }
 
@@ -273,7 +273,7 @@ radv_sdma_get_tiled_header_dword(const struct radv_device *const device, const s
       const uint32_t mip_id = subresource.mipLevel;
       return (mip_max - 1) << 20 | mip_id << 24;
    } else {
-      unreachable("unsupported SDMA version");
+      UNREACHABLE("unsupported SDMA version");
    }
 }
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 78c008d668c69..3a2843d43dc65 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -781,7 +781,7 @@ radv_lower_ngg(struct radv_device *device, struct radv_shader_stage *ngg_stage,
       else
          assert(nir->info.mesh.primitive_type == MESA_PRIM_TRIANGLES);
    } else {
-      unreachable("NGG needs to be VS, TES or GS.");
+      UNREACHABLE("NGG needs to be VS, TES or GS.");
    }
 
    ac_nir_lower_ngg_options options = {0};
@@ -831,7 +831,7 @@ radv_lower_ngg(struct radv_device *device, struct radv_shader_stage *ngg_stage,
                gfx_state->has_multiview_view_index, info->ms.has_query);
       ngg_stage->info.ms.needs_ms_scratch_ring = scratch_ring;
    } else {
-      unreachable("invalid SW stage passed to radv_lower_ngg");
+      UNREACHABLE("invalid SW stage passed to radv_lower_ngg");
    }
 }
 
@@ -1151,7 +1151,7 @@ radv_free_shader_memory(struct radv_device *device, union radv_shader_arena_bloc
       free_list = NULL;
       break;
    default:
-      unreachable("invalid shader arena type");
+      UNREACHABLE("invalid shader arena type");
    }
 
    /* merge with previous hole */
@@ -1862,7 +1862,7 @@ radv_precompute_registers_pgm(const struct radv_device *device, struct radv_shad
       info->regs.pgm_rsrc3 = R_00B8A0_COMPUTE_PGM_RSRC3;
       break;
    default:
-      unreachable("invalid hw stage");
+      UNREACHABLE("invalid hw stage");
       break;
    }
 }
@@ -2162,7 +2162,7 @@ radv_postprocess_binary_config(struct radv_device *device, struct radv_shader_bi
 
       break;
    default:
-      unreachable("unsupported shader type");
+      UNREACHABLE("unsupported shader type");
       break;
    }
 
@@ -2187,7 +2187,7 @@ radv_postprocess_binary_config(struct radv_device *device, struct radv_shader_bi
       } else if (es_stage == MESA_SHADER_MESH) {
          es_vgpr_comp_cnt = 0;
       } else {
-         unreachable("Unexpected ES shader stage");
+         UNREACHABLE("Unexpected ES shader stage");
       }
 
       if (stage == MESA_SHADER_MESH && pdev->info.mesh_fast_launch_2) {
@@ -2251,7 +2251,7 @@ radv_postprocess_binary_config(struct radv_device *device, struct radv_shader_bi
       } else if (es_stage == MESA_SHADER_TESS_EVAL) {
          es_vgpr_comp_cnt = info->uses_prim_id ? 3 : 2;
       } else {
-         unreachable("invalid shader ES type");
+         UNREACHABLE("invalid shader ES type");
       }
 
       /* If offsets 4, 5 are used, GS_VGPR_COMP_CNT is ignored and
@@ -3696,7 +3696,7 @@ radv_dump_shader_stats(struct radv_device *device, struct radv_pipeline *pipelin
             fprintf(output, "%f", stats[i].value.f64);
             break;
          default:
-            unreachable("Invalid pipeline statistic format");
+            UNREACHABLE("Invalid pipeline statistic format");
          }
          fprintf(output, "\n");
       }
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index d5b399a71ddaa..5c39fe44e5401 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -714,7 +714,7 @@ radv_get_rt_priority(gl_shader_stage stage)
    case MESA_SHADER_CALLABLE:
       return radv_rt_priority_callable;
    default:
-      unreachable("Unimplemented RT shader stage.");
+      UNREACHABLE("Unimplemented RT shader stage.");
    }
 }
 
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index 234b62d012769..17863a7237802 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -872,7 +872,7 @@ declare_shader_args(const struct radv_device *device, const struct radv_graphics
       declare_ps_input_vgprs(info, args);
       break;
    default:
-      unreachable("Shader stage not implemented");
+      UNREACHABLE("Shader stage not implemented");
    }
 }
 
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 29a47c5f1bf51..f9c4983abd6de 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1032,7 +1032,7 @@ radv_get_user_data_0(const struct radv_device *device, struct radv_shader_info *
    case MESA_SHADER_ANY_HIT:
       return R_00B900_COMPUTE_USER_DATA_0;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 }
 
@@ -1622,6 +1622,6 @@ radv_select_hw_stage(const struct radv_shader_info *const info, const enum amd_g
    case MESA_SHADER_CALLABLE:
       return AC_HW_COMPUTE_SHADER;
    default:
-      unreachable("Unsupported HW stage");
+      UNREACHABLE("Unsupported HW stage");
    }
 }
diff --git a/src/amd/vulkan/radv_shader_object.c b/src/amd/vulkan/radv_shader_object.c
index ea82dd8cf48b7..ee7adfdb80b47 100644
--- a/src/amd/vulkan/radv_shader_object.c
+++ b/src/amd/vulkan/radv_shader_object.c
@@ -104,7 +104,7 @@ radv_shader_stage_init(const VkShaderCreateInfoEXT *sinfo, struct radv_shader_st
       else if (subgroup_size->requiredSubgroupSize == 64)
          out_stage->key.subgroup_required_size = RADV_REQUIRED_WAVE64;
       else
-         unreachable("Unsupported required subgroup size.");
+         UNREACHABLE("Unsupported required subgroup size.");
    }
 
    if (sinfo->flags & VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT) {
diff --git a/src/amd/vulkan/radv_sqtt.c b/src/amd/vulkan/radv_sqtt.c
index 4f245a175c957..95455cac15565 100644
--- a/src/amd/vulkan/radv_sqtt.c
+++ b/src/amd/vulkan/radv_sqtt.c
@@ -43,7 +43,7 @@ radv_ip_to_queue_family(enum amd_ip_type t)
    case AMD_IP_SDMA:
       return RADV_QUEUE_TRANSFER;
    default:
-      unreachable("Unknown IP type");
+      UNREACHABLE("Unknown IP type");
    }
 }
 
@@ -544,7 +544,7 @@ radv_begin_sqtt(struct radv_queue *queue)
       radeon_emit(0);
       break;
    default:
-      unreachable("Incorrect queue family");
+      UNREACHABLE("Incorrect queue family");
       break;
    }
 
@@ -621,7 +621,7 @@ radv_end_sqtt(struct radv_queue *queue)
       radeon_emit(0);
       break;
    default:
-      unreachable("Incorrect queue family");
+      UNREACHABLE("Incorrect queue family");
       break;
    }
 
diff --git a/src/amd/vulkan/radv_video.c b/src/amd/vulkan/radv_video.c
index 2a3284a4e6914..9034151d562d9 100644
--- a/src/amd/vulkan/radv_video.c
+++ b/src/amd/vulkan/radv_video.c
@@ -854,7 +854,7 @@ radv_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, cons
       break;
 #endif
    default:
-      unreachable("unsupported operation");
+      UNREACHABLE("unsupported operation");
    }
 
    if (cap && !cap->valid)
@@ -2558,7 +2558,7 @@ rvcn_dec_message_decode(struct radv_cmd_buffer *cmd_buffer, struct radv_video_se
       break;
    }
    default:
-      unreachable("unknown operation");
+      UNREACHABLE("unknown operation");
    }
 
    header->total_size += index_codec->size;
@@ -3311,7 +3311,7 @@ radv_vcn_decode_video(struct radv_cmd_buffer *cmd_buffer, const VkVideoDecodeInf
       size += sizeof(rvcn_dec_message_vp9_t);
       break;
    default:
-      unreachable("unsupported codec.");
+      UNREACHABLE("unsupported codec.");
    }
 
    radv_vid_buffer_upload_alloc(cmd_buffer, FB_BUFFER_SIZE, &fb_offset, &fb_ptr);
diff --git a/src/amd/vulkan/radv_video_enc.c b/src/amd/vulkan/radv_video_enc.c
index a1f5b291be953..c21760af51894 100644
--- a/src/amd/vulkan/radv_video_enc.c
+++ b/src/amd/vulkan/radv_video_enc.c
@@ -2804,7 +2804,7 @@ radv_video_enc_control_video_coding(struct radv_cmd_buffer *cmd_buffer, const Vk
       }
       break;
    default:
-      unreachable("Unsupported\n");
+      UNREACHABLE("Unsupported\n");
    }
 
    if (control_info->flags & VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR) {
diff --git a/src/amd/vulkan/tests/helpers.cpp b/src/amd/vulkan/tests/helpers.cpp
index 6bc27f536e0ff..ec5d8e43e5659 100644
--- a/src/amd/vulkan/tests/helpers.cpp
+++ b/src/amd/vulkan/tests/helpers.cpp
@@ -202,5 +202,5 @@ radv_test::get_pipeline_hash(VkShaderStageFlags stage)
          return stats[i].value.u64;
    }
 
-   unreachable("Driver pipeline hash not found");
+   UNREACHABLE("Driver pipeline hash not found");
 }
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index d0d3073f922af..0fc224b2d7318 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -349,7 +349,7 @@ get_nop_packet(struct radv_amdgpu_cs *cs)
    case AMDGPU_HW_IP_VCN_ENC:
       return 0; /* NOPs are illegal in encode, so don't pad */
    default:
-      unreachable("Unknown IP type");
+      UNREACHABLE("Unknown IP type");
    }
 }
 
@@ -1579,7 +1579,7 @@ radv_to_amdgpu_priority(enum radeon_ctx_priority radv_priority)
    case RADEON_CTX_PRIORITY_LOW:
       return AMDGPU_CTX_PRIORITY_LOW;
    default:
-      unreachable("Invalid context priority");
+      UNREACHABLE("Invalid context priority");
    }
 }
 
@@ -1686,7 +1686,7 @@ radv_to_amdgpu_pstate(enum radeon_ctx_pstate radv_pstate)
    case RADEON_CTX_PSTATE_PEAK:
       return AMDGPU_CTX_STABLE_PSTATE_PEAK;
    default:
-      unreachable("Invalid pstate");
+      UNREACHABLE("Invalid pstate");
    }
 }
 
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c
index 5149d6dea4185..c71db3d0456fb 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_winsys.c
@@ -73,7 +73,7 @@ radv_amdgpu_winsys_query_value(struct radeon_winsys *rws, enum radeon_value_id v
       ac_drm_query_sensor_info(ws->dev, AMDGPU_INFO_SENSOR_GFX_MCLK, 4, &retval);
       return retval;
    default:
-      unreachable("invalid query value");
+      UNREACHABLE("invalid query value");
    }
 
    return 0;
diff --git a/src/asahi/compiler/agx_compile.c b/src/asahi/compiler/agx_compile.c
index b308272880762..09f98c766f3dc 100644
--- a/src/asahi/compiler/agx_compile.c
+++ b/src/asahi/compiler/agx_compile.c
@@ -136,7 +136,7 @@ bitset_for_interp(struct coefficient_info *info, enum glsl_interp_mode mode)
    case INTERP_MODE_SMOOTH:         return info->smooth;
    case INTERP_MODE_NOPERSPECTIVE:  return info->noperspective;
    case INTERP_MODE_FLAT:           return info->flat;
-   default:                         unreachable("invalid interp mode");
+   default:                         UNREACHABLE("invalid interp mode");
    }
    /* clang-format on */
 }
@@ -313,7 +313,7 @@ agx_get_cf(agx_context *ctx, gl_varying_slot slot, unsigned offset)
       }
    }
 
-   unreachable("all coefficient registers preassigned");
+   UNREACHABLE("all coefficient registers preassigned");
 }
 
 /* Builds a 64-bit hash table key for an index */
@@ -476,7 +476,7 @@ agx_block_add_successor(agx_block *block, agx_block *successor)
       return;
    }
 
-   unreachable("Too many successors");
+   UNREACHABLE("Too many successors");
 }
 
 /*
@@ -563,7 +563,7 @@ agx_format_for_pipe(enum pipe_format format)
    CASE(RGB9E5);
 
 #undef CASE
-   unreachable("Invalid format");
+   UNREACHABLE("Invalid format");
 }
 
 static agx_index
@@ -611,7 +611,7 @@ agx_interp_for_bary(nir_intrinsic_instr *bary, agx_index *sample_index)
       return AGX_INTERPOLATION_SAMPLE;
 
    default:
-      unreachable("should have been lowered");
+      UNREACHABLE("should have been lowered");
    }
 }
 
@@ -878,10 +878,10 @@ agx_tex_dim(enum glsl_sampler_dim dim, bool array)
       return array ? AGX_DIM_CUBE_ARRAY : AGX_DIM_CUBE;
 
    case GLSL_SAMPLER_DIM_BUF:
-      unreachable("Buffer textures should have been lowered");
+      UNREACHABLE("Buffer textures should have been lowered");
 
    default:
-      unreachable("Invalid sampler dim\n");
+      UNREACHABLE("Invalid sampler dim\n");
    }
 }
 
@@ -965,7 +965,7 @@ translate_atomic_opcode(nir_atomic_op op)
    case nir_atomic_op_ixor:    return AGX_ATOMIC_OPC_XOR;
    case nir_atomic_op_xchg:    return AGX_ATOMIC_OPC_XCHG;
    case nir_atomic_op_cmpxchg: return AGX_ATOMIC_OPC_CMPXCHG;
-   default: unreachable("unknown atomic opcode");
+   default: UNREACHABLE("unknown atomic opcode");
    }
    /* clang-format on */
 }
@@ -1022,7 +1022,7 @@ format_for_bitsize(unsigned bitsize)
    case 32:
       return AGX_FORMAT_I32;
    default:
-      unreachable("should've been lowered");
+      UNREACHABLE("should've been lowered");
    }
 }
 
@@ -1311,7 +1311,7 @@ translate_simd_op(nir_op op)
       CASE(UMIN, umin)
       CASE(UMAX, umax)
    default:
-      unreachable("unknown simd op");
+      UNREACHABLE("unknown simd op");
    }
 #undef CASE
 }
@@ -1750,12 +1750,12 @@ agx_emit_intrinsic(agx_builder *b, nir_intrinsic_instr *instr)
    case nir_intrinsic_load_barycentric_sample:
    case nir_intrinsic_load_sample_id:
    case nir_intrinsic_load_sample_pos:
-      unreachable("Sample shading should have been lowered");
+      UNREACHABLE("Sample shading should have been lowered");
 
    default:
       fprintf(stderr, "Unhandled intrinsic %s\n",
               nir_intrinsic_infos[instr->intrinsic].name);
-      unreachable("Unhandled intrinsic");
+      UNREACHABLE("Unhandled intrinsic");
    }
 }
 
@@ -2111,7 +2111,7 @@ agx_emit_alu(agx_builder *b, nir_alu_instr *instr)
    case nir_op_u2f16:
    case nir_op_u2f32: {
       if (src_sz == 64)
-         unreachable("64-bit conversions unimplemented");
+         UNREACHABLE("64-bit conversions unimplemented");
 
       enum agx_convert mode = (src_sz == 32)   ? AGX_CONVERT_U32_TO_F
                               : (src_sz == 16) ? AGX_CONVERT_U16_TO_F
@@ -2123,7 +2123,7 @@ agx_emit_alu(agx_builder *b, nir_alu_instr *instr)
    case nir_op_i2f16:
    case nir_op_i2f32: {
       if (src_sz == 64)
-         unreachable("64-bit conversions unimplemented");
+         UNREACHABLE("64-bit conversions unimplemented");
 
       enum agx_convert mode = (src_sz == 32)   ? AGX_CONVERT_S32_TO_F
                               : (src_sz == 16) ? AGX_CONVERT_S16_TO_F
@@ -2155,11 +2155,11 @@ agx_emit_alu(agx_builder *b, nir_alu_instr *instr)
 
    case nir_op_vec8:
    case nir_op_vec16:
-      unreachable("should've been lowered");
+      UNREACHABLE("should've been lowered");
 
    default:
       fprintf(stderr, "Unhandled ALU op %s\n", nir_op_infos[instr->op].name);
-      unreachable("Unhandled ALU instruction");
+      UNREACHABLE("Unhandled ALU instruction");
    }
 }
 
@@ -2192,7 +2192,7 @@ agx_lod_mode_for_nir(nir_texop op, bool biased, bool min_lod, bool lod_is_zero)
       assert(lod_is_zero && "no mipmapping");
       return AGX_LOD_MODE_AUTO_LOD;
    default:
-      unreachable("Unhandled texture op");
+      UNREACHABLE("Unhandled texture op");
    }
 }
 
@@ -2317,7 +2317,7 @@ agx_emit_tex(agx_builder *b, nir_tex_instr *instr)
          break;
 
       default:
-         unreachable("Unexpected texture source");
+         UNREACHABLE("Unexpected texture source");
       }
    }
 
@@ -2551,7 +2551,7 @@ agx_emit_instr(agx_builder *b, struct nir_instr *instr)
       break;
 
    default:
-      unreachable("should've been lowered");
+      UNREACHABLE("should've been lowered");
    }
 }
 
@@ -2766,7 +2766,7 @@ emit_cf_list(agx_context *ctx, struct exec_list *list)
          break;
 
       default:
-         unreachable("Unknown control flow");
+         UNREACHABLE("Unknown control flow");
       }
    }
 
@@ -3769,7 +3769,7 @@ agx_compile_function_nir(nir_shader *nir, nir_function_impl *impl,
                              stderr);
          }
 
-         unreachable("Disassembly error hit.");
+         UNREACHABLE("Disassembly error hit.");
       }
 
       if (selftest) {
@@ -3993,7 +3993,7 @@ agx_compile_shader_nir(nir_shader *nir, struct agx_shader_key *key,
          info->main_offset = offset;
          info->main_size = binary.size - offset;
       } else {
-         unreachable("General functions not yet supported");
+         UNREACHABLE("General functions not yet supported");
       }
    }
 
diff --git a/src/asahi/compiler/agx_compiler.h b/src/asahi/compiler/agx_compiler.h
index f0ad7c76f9d29..bd77be4d84813 100644
--- a/src/asahi/compiler/agx_compiler.h
+++ b/src/asahi/compiler/agx_compiler.h
@@ -55,7 +55,7 @@ agx_size_align_16(enum agx_size size)
       return 4;
    }
 
-   unreachable("Invalid size");
+   UNREACHABLE("Invalid size");
 }
 
 /* Keep synced with hash_index */
@@ -586,7 +586,7 @@ agx_size_for_bits(unsigned bits)
    case 64:
       return AGX_SIZE_64;
    default:
-      unreachable("Invalid bitsize");
+      UNREACHABLE("Invalid bitsize");
    }
 }
 
@@ -770,7 +770,7 @@ agx_predecessor_index(agx_block *succ, agx_block *pred)
       index++;
    }
 
-   unreachable("Invalid predecessor");
+   UNREACHABLE("Invalid predecessor");
 }
 
 static inline agx_block *
@@ -998,7 +998,7 @@ agx_builder_insert(agx_cursor *cursor, agx_instr *I)
       return;
    }
 
-   unreachable("Invalid cursor option");
+   UNREACHABLE("Invalid cursor option");
 }
 
 bool agx_instr_accepts_uniform(enum agx_opcode op, unsigned src_index,
diff --git a/src/asahi/compiler/agx_ir.c b/src/asahi/compiler/agx_ir.c
index 9c2888119c560..3eb14815d6e64 100644
--- a/src/asahi/compiler/agx_ir.c
+++ b/src/asahi/compiler/agx_ir.c
@@ -27,6 +27,6 @@ agx_negate_src_index(agx_instr *I)
    case AGX_OPCODE_IADD:
       return 1;
    default:
-      unreachable("not allowed");
+      UNREACHABLE("not allowed");
    }
 }
diff --git a/src/asahi/compiler/agx_nir_lower_address.c b/src/asahi/compiler/agx_nir_lower_address.c
index c00a078f786dc..915b4d42a6f62 100644
--- a/src/asahi/compiler/agx_nir_lower_address.c
+++ b/src/asahi/compiler/agx_nir_lower_address.c
@@ -27,7 +27,7 @@ format_for_bitsize(unsigned bitsize)
    case 32:
       return PIPE_FORMAT_R32_UINT;
    default:
-      unreachable("should have been lowered");
+      UNREACHABLE("should have been lowered");
    }
 }
 
diff --git a/src/asahi/compiler/agx_nir_lower_texture.c b/src/asahi/compiler/agx_nir_lower_texture.c
index e5807bae8385a..be8d00e2cff54 100644
--- a/src/asahi/compiler/agx_nir_lower_texture.c
+++ b/src/asahi/compiler/agx_nir_lower_texture.c
@@ -602,7 +602,7 @@ lower_images(nir_builder *b, nir_intrinsic_instr *intr, UNUSED void *data)
 
    case nir_intrinsic_image_size:
    case nir_intrinsic_image_texel_address:
-      unreachable("should've been lowered");
+      UNREACHABLE("should've been lowered");
 
    default:
       return false;
diff --git a/src/asahi/compiler/agx_opcodes.h.py b/src/asahi/compiler/agx_opcodes.h.py
index 64da7e9b3e5fa..235c279c2a0c2 100644
--- a/src/asahi/compiler/agx_opcodes.h.py
+++ b/src/asahi/compiler/agx_opcodes.h.py
@@ -44,7 +44,7 @@ agx_${name}_as_str(enum agx_${name} x)
 % for k, v in enums[name].items():
     case AGX_${name.upper()}_${v.replace('.', '_').upper()}: return "${v}";
 % endfor
-    default: unreachable("Nonexhaustive enum");
+    default: UNREACHABLE("Nonexhaustive enum");
     }
 }
 
diff --git a/src/asahi/compiler/agx_optimizer.c b/src/asahi/compiler/agx_optimizer.c
index 2f46c3f6b222c..747d981ad5f96 100644
--- a/src/asahi/compiler/agx_optimizer.c
+++ b/src/asahi/compiler/agx_optimizer.c
@@ -262,7 +262,7 @@ agx_icond_is_unsigned(enum agx_icond cond)
       return false;
    }
 
-   unreachable("invalid condition");
+   UNREACHABLE("invalid condition");
 }
 
 static bool
diff --git a/src/asahi/compiler/agx_pack.c b/src/asahi/compiler/agx_pack.c
index 1241a20a0f92b..cc742e66cce5f 100644
--- a/src/asahi/compiler/agx_pack.c
+++ b/src/asahi/compiler/agx_pack.c
@@ -50,7 +50,7 @@ assert_register_is_aligned(const agx_instr *I, agx_index reg)
       return;
    }
 
-   unreachable("Invalid register size");
+   UNREACHABLE("Invalid register size");
 }
 
 /* Texturing has its own operands */
@@ -169,7 +169,7 @@ agx_pack_pbe_lod(const agx_instr *I, agx_index index, bool *flag)
    else if (index.type == AGX_INDEX_REGISTER)
       *flag = false;
    else
-      unreachable("Invalid PBE LOD type");
+      UNREACHABLE("Invalid PBE LOD type");
 
    return index.value;
 }
diff --git a/src/asahi/compiler/agx_performance.c b/src/asahi/compiler/agx_performance.c
index 65376ddee4c9d..73698b97a30f0 100644
--- a/src/asahi/compiler/agx_performance.c
+++ b/src/asahi/compiler/agx_performance.c
@@ -29,7 +29,7 @@ agx_occupancy_for_register_count(unsigned halfregs)
          return occupancies[i];
    }
 
-   unreachable("Register count must be less than the maximum");
+   UNREACHABLE("Register count must be less than the maximum");
 }
 
 unsigned
diff --git a/src/asahi/compiler/agx_print.c b/src/asahi/compiler/agx_print.c
index 56db05fc221ca..d4bef1bb65e22 100644
--- a/src/asahi/compiler/agx_print.c
+++ b/src/asahi/compiler/agx_print.c
@@ -24,7 +24,7 @@ agx_print_sized(char prefix, unsigned value, enum agx_size size, FILE *fp)
       return;
    }
 
-   unreachable("Invalid size");
+   UNREACHABLE("Invalid size");
 }
 
 static void
@@ -91,7 +91,7 @@ agx_print_index(agx_index index, bool is_float, FILE *fp)
       break;
 
    default:
-      unreachable("Invalid index type");
+      UNREACHABLE("Invalid index type");
    }
 
    if (index.type == AGX_INDEX_NORMAL) {
diff --git a/src/asahi/compiler/agx_register_allocate.c b/src/asahi/compiler/agx_register_allocate.c
index d38a6c12e355f..223a5a01b1d71 100644
--- a/src/asahi/compiler/agx_register_allocate.c
+++ b/src/asahi/compiler/agx_register_allocate.c
@@ -645,7 +645,7 @@ search_ssa_to_reg_out(struct ra_ctx *ctx, struct agx_block *blk,
          return reg;
    }
 
-   unreachable("variable not defined in block");
+   UNREACHABLE("variable not defined in block");
 }
 
 /*
diff --git a/src/asahi/compiler/agx_spill.c b/src/asahi/compiler/agx_spill.c
index 8ceebf11c95e0..2188fc7bbff4e 100644
--- a/src/asahi/compiler/agx_spill.c
+++ b/src/asahi/compiler/agx_spill.c
@@ -296,7 +296,7 @@ remat_to(agx_builder *b, agx_index dst, struct spill_ctx *ctx, unsigned node)
    case AGX_OPCODE_GET_SR:
       return agx_get_sr_to(b, dst, I->sr);
    default:
-      unreachable("invalid remat");
+      UNREACHABLE("invalid remat");
    }
 }
 
diff --git a/src/asahi/compiler/agx_validate.c b/src/asahi/compiler/agx_validate.c
index 7bf697f1a597e..de2e24a149877 100644
--- a/src/asahi/compiler/agx_validate.c
+++ b/src/asahi/compiler/agx_validate.c
@@ -218,7 +218,7 @@ agx_dim_info(enum agx_dim dim)
    case AGX_DIM_2D_MS_ARRAY:
       return (struct dim_info){2, true};
    default:
-      unreachable("invalid dim");
+      UNREACHABLE("invalid dim");
    }
 }
 
@@ -326,7 +326,7 @@ agx_read_registers(const agx_instr *I, unsigned s)
                return (2 * 2 * 3) + min;
             }
 
-            unreachable("Invalid texture dimension");
+            UNREACHABLE("Invalid texture dimension");
          } else if (I->lod_mode == AGX_LOD_MODE_AUTO_LOD_BIAS_MIN) {
             return 2;
          } else {
diff --git a/src/asahi/compiler/agx_validate_ra.c b/src/asahi/compiler/agx_validate_ra.c
index 78445688848c3..c904397c4c358 100644
--- a/src/asahi/compiler/agx_validate_ra.c
+++ b/src/asahi/compiler/agx_validate_ra.c
@@ -295,7 +295,7 @@ agx_validate_ra(agx_context *ctx)
 
    if (!succ) {
       agx_print_shader(ctx, stderr);
-      unreachable("invalid RA");
+      UNREACHABLE("invalid RA");
    }
 
    free(blocks);
diff --git a/src/asahi/genxml/agx_pack_header.h b/src/asahi/genxml/agx_pack_header.h
index eb72655a6ce9b..2f238f291c34c 100644
--- a/src/asahi/genxml/agx_pack_header.h
+++ b/src/asahi/genxml/agx_pack_header.h
@@ -127,7 +127,7 @@ agx_genxml_validate_bounds(const char *name, uint64_t value, uint64_t bound)
       fprintf(stderr, "%s out-of-bounds, got 0x%" PRIx64 ", max %" PRIx64 "\n",
               name, value, bound);
 
-      unreachable("Out-of-bounds pack");
+      UNREACHABLE("Out-of-bounds pack");
    }
 }
 
diff --git a/src/asahi/layout/layout.c b/src/asahi/layout/layout.c
index ec89ab80a9f28..ebf62e64d8c10 100644
--- a/src/asahi/layout/layout.c
+++ b/src/asahi/layout/layout.c
@@ -43,7 +43,7 @@ ail_get_max_tile_size(unsigned blocksize_B)
    case 16: return (struct ail_tile) {  32,  32 };
    case 32: return (struct ail_tile) {  32,  16 };
    case 64: return (struct ail_tile) {  16,  16 };
-   default: unreachable("Invalid blocksize");
+   default: UNREACHABLE("Invalid blocksize");
    }
    /* clang-format on */
 }
@@ -372,7 +372,7 @@ ail_make_miptree(struct ail_layout *layout)
       ail_initialize_twiddled(layout);
       break;
    default:
-      unreachable("Unsupported tiling");
+      UNREACHABLE("Unsupported tiling");
    }
 
    if (layout->compressed) {
diff --git a/src/asahi/layout/layout.h b/src/asahi/layout/layout.h
index 3bcafb09720a4..05d29a6a47df3 100644
--- a/src/asahi/layout/layout.h
+++ b/src/asahi/layout/layout.h
@@ -485,7 +485,7 @@ ail_subtile_uncompressed_mode(enum pipe_format format)
    case  4: return AIL_COMP_UNCOMPRESSED_4;
    case  8:
    case 16: return AIL_COMP_UNCOMPRESSED_8_16;
-   default: unreachable("invalid block size");
+   default: UNREACHABLE("invalid block size");
    }
    /* clang-format on */
 }
@@ -500,7 +500,7 @@ ail_subtile_solid_mode(enum pipe_format format)
    case  4: return AIL_COMP_SOLID_4;
    case  8:
    case 16: return AIL_COMP_SOLID_8_16;
-   default: unreachable("invalid block size");
+   default: UNREACHABLE("invalid block size");
    }
    /* clang-format on */
 }
@@ -566,7 +566,7 @@ ail_drm_modifier_to_tiling(uint64_t modifier)
    case DRM_FORMAT_MOD_APPLE_GPU_TILED_COMPRESSED:
       return AIL_TILING_GPU;
    default:
-      unreachable("Unsupported modifier");
+      UNREACHABLE("Unsupported modifier");
    }
 }
 
@@ -580,7 +580,7 @@ ail_is_drm_modifier_compressed(uint64_t modifier)
    case DRM_FORMAT_MOD_APPLE_GPU_TILED_COMPRESSED:
       return true;
    default:
-      unreachable("Unsupported modifier");
+      UNREACHABLE("Unsupported modifier");
    }
 }
 
diff --git a/src/asahi/layout/tiling.cc b/src/asahi/layout/tiling.cc
index f5572bbd7e3d6..084d72707935b 100644
--- a/src/asahi/layout/tiling.cc
+++ b/src/asahi/layout/tiling.cc
@@ -135,7 +135,7 @@ memcpy_small(void *_tiled, void *_linear, const struct ail_layout *tiled_layout,
                                          linear_pitch_B, sx_px, sy_px,         \
                                          swidth_px, sheight_px);               \
    } else {                                                                    \
-      unreachable("Invalid block size");                                       \
+      UNREACHABLE("Invalid block size");                                       \
    }
 
 void
diff --git a/src/asahi/lib/agx_border.c b/src/asahi/lib/agx_border.c
index fc139b1179c78..1e0dd072e91f5 100644
--- a/src/asahi/lib/agx_border.c
+++ b/src/asahi/lib/agx_border.c
@@ -141,10 +141,10 @@ pack_channel(uint32_t value, enum pipe_format format, unsigned channel)
       return chan.size == 32 ? value : _mesa_float_to_half(uif(value));
 
    case UTIL_FORMAT_TYPE_FIXED:
-      unreachable("no FIXED textures");
+      UNREACHABLE("no FIXED textures");
    }
 
-   unreachable("invalid format type");
+   UNREACHABLE("invalid format type");
 }
 
 void
diff --git a/src/asahi/lib/agx_helpers.h b/src/asahi/lib/agx_helpers.h
index 48e64ba4d2a37..f9aa1220aeb00 100644
--- a/src/asahi/lib/agx_helpers.h
+++ b/src/asahi/lib/agx_helpers.h
@@ -90,7 +90,7 @@ agx_translate_layout(enum ail_tiling tiling)
       return AGX_LAYOUT_LINEAR;
    }
 
-   unreachable("Invalid tiling");
+   UNREACHABLE("Invalid tiling");
 }
 
 static inline enum agx_zls_tiling
@@ -102,7 +102,7 @@ agx_translate_zls_tiling(enum ail_tiling tiling)
    case AIL_TILING_TWIDDLED:
       return AGX_ZLS_TILING_TWIDDLED;
    default:
-      unreachable("Invalid ZLS tiling");
+      UNREACHABLE("Invalid ZLS tiling");
    }
 }
 
@@ -150,7 +150,7 @@ agx_translate_sample_count(unsigned samples)
    case 4:
       return AGX_SAMPLE_COUNT_4;
    default:
-      unreachable("Invalid sample count");
+      UNREACHABLE("Invalid sample count");
    }
 }
 
@@ -167,7 +167,7 @@ agx_translate_depth_layout(enum gl_frag_depth_layout layout)
    case FRAG_DEPTH_LAYOUT_UNCHANGED:
       return AGX_CONSERVATIVE_DEPTH_UNCHANGED;
    default:
-      unreachable("depth layout should have been canonicalized");
+      UNREACHABLE("depth layout should have been canonicalized");
    }
 }
 
diff --git a/src/asahi/lib/agx_nir_lower_gs.c b/src/asahi/lib/agx_nir_lower_gs.c
index 52125aa446b06..6d33206c0adc7 100644
--- a/src/asahi/lib/agx_nir_lower_gs.c
+++ b/src/asahi/lib/agx_nir_lower_gs.c
@@ -272,7 +272,7 @@ vertex_id_for_topology_class(nir_builder *b, nir_def *vert, enum mesa_prim cls)
                                                 flatshade_first);
 
    default:
-      unreachable("invalid topology class");
+      UNREACHABLE("invalid topology class");
    }
 }
 
@@ -693,7 +693,7 @@ agx_nir_create_gs_rast_shader(const nir_shader *gs,
    }
 
    default:
-      unreachable("invalid shape");
+      UNREACHABLE("invalid shape");
    }
 
    u_foreach_bit64(slot, shader->info.outputs_written) {
diff --git a/src/asahi/lib/agx_nir_lower_vbo.c b/src/asahi/lib/agx_nir_lower_vbo.c
index d2699382b375e..561d559e731f1 100644
--- a/src/asahi/lib/agx_nir_lower_vbo.c
+++ b/src/asahi/lib/agx_nir_lower_vbo.c
@@ -106,7 +106,7 @@ apply_swizzle_channel(nir_builder *b, nir_def *vec, unsigned swizzle,
       return is_int ? nir_imm_intN_t(b, 1, vec->bit_size)
                     : nir_imm_floatN_t(b, 1.0, vec->bit_size);
    default:
-      unreachable("Invalid swizzle channel");
+      UNREACHABLE("Invalid swizzle channel");
    }
 }
 
diff --git a/src/asahi/lib/agx_nir_prolog_epilog.c b/src/asahi/lib/agx_nir_prolog_epilog.c
index a5fe0d17045a2..c1c2176eb343a 100644
--- a/src/asahi/lib/agx_nir_prolog_epilog.c
+++ b/src/asahi/lib/agx_nir_prolog_epilog.c
@@ -158,7 +158,7 @@ lower_adjacency(nir_builder *b, nir_intrinsic_instr *intr, void *data)
       /* Sequence (0, 2, 4), (6, 8, 10), ... */
       id = nir_imul_imm(b, id, 2);
    } else {
-      unreachable("unknown");
+      UNREACHABLE("unknown");
    }
 
    id = agx_nir_load_vertex_id(b, id, key->sw_index_size_B);
diff --git a/src/asahi/lib/agx_tilebuffer.c b/src/asahi/lib/agx_tilebuffer.c
index ecb986765a3cd..f4a982ffdfed4 100644
--- a/src/asahi/lib/agx_tilebuffer.c
+++ b/src/asahi/lib/agx_tilebuffer.c
@@ -42,7 +42,7 @@ agx_select_tile_size(unsigned bytes_per_pixel)
          return size;
    }
 
-   unreachable("No supported tile size meets the bytes per pixel requirement");
+   UNREACHABLE("No supported tile size meets the bytes per pixel requirement");
 }
 
 static unsigned
@@ -55,7 +55,7 @@ agx_shared_layout_from_tile_size(struct agx_tile_size t)
    else if (t.width == 16 && t.height == 16)
       return AGX_SHARED_LAYOUT_16X16;
    else
-      unreachable("Invalid tile size");
+      UNREACHABLE("Invalid tile size");
 }
 
 struct agx_tilebuffer_layout
diff --git a/src/asahi/lib/decode.c b/src/asahi/lib/decode.c
index a42330aa2eeb3..9e4c9c082791c 100644
--- a/src/asahi/lib/decode.c
+++ b/src/asahi/lib/decode.c
@@ -84,7 +84,7 @@ _agxdecode_grab_mapped(struct agxdecode_ctx *ctx, uint64_t gpu_va, void **buf,
                        int line, const char *filename)
 {
    if (lib_config.read_gpu_mem)
-      unreachable("you'll have to figure it out.");
+      UNREACHABLE("you'll have to figure it out.");
 
    const struct agx_bo *mem =
       agxdecode_find_mapped_gpu_mem_containing(ctx, gpu_va);
@@ -912,7 +912,7 @@ agxdecode_drm_cmdbuf(struct agxdecode_ctx *ctx,
       } else if (header->cmd_type == DRM_ASAHI_SET_COMPUTE_ATTACHMENTS) {
          agxdecode_drm_attachments("Compute", data, header->size);
       } else {
-         unreachable("Invalid command type");
+         UNREACHABLE("Invalid command type");
       }
 
       offs += header->size;
@@ -1085,7 +1085,7 @@ libagxdecode_init(struct libagxdecode_config *config)
    chip_id_to_params(&lib_params, config->chip_id);
 #else
    /* fopencookie is a glibc extension */
-   unreachable("libagxdecode only available with glibc");
+   UNREACHABLE("libagxdecode only available with glibc");
 #endif
 }
 
diff --git a/src/asahi/libagx/compression.cl b/src/asahi/libagx/compression.cl
index 2050f5a3c6635..4021bd9a9b0b9 100644
--- a/src/asahi/libagx/compression.cl
+++ b/src/asahi/libagx/compression.cl
@@ -150,7 +150,7 @@ stretched_sa_to_px(ushort2 px, uint samples)
    case  4: return (ushort2)(px.x / 2, px.y / 2);
    case  2: return (ushort2)(px.x, px.y / 2);
    case  1: return px;
-   default: unreachable("invalid sample count");
+   default: UNREACHABLE("invalid sample count");
    }
    /* clang-format on */
 }
diff --git a/src/asahi/libagx/geometry.h b/src/asahi/libagx/geometry.h
index a992b2ee39248..547e2367e9fc4 100644
--- a/src/asahi/libagx/geometry.h
+++ b/src/asahi/libagx/geometry.h
@@ -62,7 +62,7 @@ agx_gs_rast_vertices(enum agx_gs_shape shape, unsigned max_indices,
       return max_indices * input_primitives;
    }
 
-   unreachable("invalid shape");
+   UNREACHABLE("invalid shape");
 }
 
 static inline unsigned
@@ -81,7 +81,7 @@ agx_gs_rast_instances(enum agx_gs_shape shape, unsigned max_indices,
       return instance_count;
    }
 
-   unreachable("invalid shape");
+   UNREACHABLE("invalid shape");
 }
 
 static inline bool
diff --git a/src/asahi/vulkan/hk_cmd_buffer.h b/src/asahi/vulkan/hk_cmd_buffer.h
index 2ce66bd002f14..000b833408929 100644
--- a/src/asahi/vulkan/hk_cmd_buffer.h
+++ b/src/asahi/vulkan/hk_cmd_buffer.h
@@ -809,7 +809,7 @@ hk_get_descriptors_state(struct hk_cmd_buffer *cmd,
    case VK_PIPELINE_BIND_POINT_COMPUTE:
       return &cmd->state.cs.descriptors;
    default:
-      unreachable("Unhandled bind point");
+      UNREACHABLE("Unhandled bind point");
    }
 };
 
diff --git a/src/asahi/vulkan/hk_cmd_draw.c b/src/asahi/vulkan/hk_cmd_draw.c
index c216d0d2f5e77..e8aa755756518 100644
--- a/src/asahi/vulkan/hk_cmd_draw.c
+++ b/src/asahi/vulkan/hk_cmd_draw.c
@@ -135,7 +135,7 @@ vk_conv_topology(VkPrimitiveTopology topology)
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
       return MESA_PRIM_PATCHES;
    default:
-      unreachable("invalid");
+      UNREACHABLE("invalid");
    }
 }
 
@@ -1934,7 +1934,7 @@ hk_get_fast_linked(struct hk_device *dev, struct hk_shader *shader, void *key)
    else if (shader->info.stage == MESA_SHADER_FRAGMENT)
       linked = hk_get_fast_linked_locked_fs(dev, shader, key);
    else
-      unreachable("invalid stage");
+      UNREACHABLE("invalid stage");
 
    simple_mtx_unlock(&shader->linked.lock);
    return linked;
@@ -2212,7 +2212,7 @@ translate_hw_primitive_topology(enum mesa_prim prim)
    case MESA_PRIM_TRIANGLE_FAN:
       return AGX_PRIMITIVE_TRIANGLE_FAN;
    default:
-      unreachable("Invalid hardware primitive topology");
+      UNREACHABLE("Invalid hardware primitive topology");
    }
 }
 
@@ -2308,7 +2308,7 @@ hk_default_sample_positions(unsigned nr_samples)
    case 4:
       return 0xeaa26e26;
    default:
-      unreachable("Invalid sample count");
+      UNREACHABLE("Invalid sample count");
    }
 }
 
@@ -3913,7 +3913,7 @@ hk_CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer,
                                VkDeviceSize counterBufferOffset,
                                uint32_t counterOffset, uint32_t vertexStride)
 {
-   unreachable("TODO");
+   UNREACHABLE("TODO");
 }
 
 VKAPI_ATTR void VKAPI_CALL
@@ -4020,11 +4020,11 @@ hk_CmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer,
    const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin)
 {
-   unreachable("stub");
+   UNREACHABLE("stub");
 }
 
 VKAPI_ATTR void VKAPI_CALL
 hk_CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
 {
-   unreachable("stub");
+   UNREACHABLE("stub");
 }
diff --git a/src/asahi/vulkan/hk_cmd_meta.c b/src/asahi/vulkan/hk_cmd_meta.c
index 8ecbce737d2a7..2bed22ef13c2a 100644
--- a/src/asahi/vulkan/hk_cmd_meta.c
+++ b/src/asahi/vulkan/hk_cmd_meta.c
@@ -240,7 +240,7 @@ aspect_format(VkFormat fmt, VkImageAspectFlags aspect)
       case VK_IMAGE_ASPECT_PLANE_2_BIT:
          return ycbcr_info->planes[2].format;
       default:
-         unreachable("invalid ycbcr aspect");
+         UNREACHABLE("invalid ycbcr aspect");
       }
    }
 
@@ -377,7 +377,7 @@ is_format_native(enum pipe_format format)
    case PIPE_FORMAT_B5G5R5A1_UNORM:
       return false;
    default:
-      unreachable("expected canonical");
+      UNREACHABLE("expected canonical");
    }
 }
 
@@ -1319,7 +1319,7 @@ hk_meta_copy_get_image_properties(struct hk_image *img)
          props.depth.component_mask = BITFIELD_BIT(0);
          break;
       default:
-         unreachable("Invalid ZS format");
+         UNREACHABLE("Invalid ZS format");
       }
    }
 
diff --git a/src/asahi/vulkan/hk_descriptor_set_layout.c b/src/asahi/vulkan/hk_descriptor_set_layout.c
index 4cff2a3a756f8..8be2c3ca95d8b 100644
--- a/src/asahi/vulkan/hk_descriptor_set_layout.c
+++ b/src/asahi/vulkan/hk_descriptor_set_layout.c
@@ -83,7 +83,7 @@ hk_descriptor_stride_align_for_type(
       break;
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 
    assert(*stride <= HK_MAX_DESCRIPTOR_SIZE);
diff --git a/src/asahi/vulkan/hk_device_memory.c b/src/asahi/vulkan/hk_device_memory.c
index de50861103dff..a39b5f4a41c60 100644
--- a/src/asahi/vulkan/hk_device_memory.c
+++ b/src/asahi/vulkan/hk_device_memory.c
@@ -109,7 +109,7 @@ hk_remove_ext_bo_locked(struct hk_device *dev, struct agx_bo *bo)
       }
    }
 
-   unreachable("BO not found");
+   UNREACHABLE("BO not found");
 }
 
 static void
diff --git a/src/asahi/vulkan/hk_image.c b/src/asahi/vulkan/hk_image.c
index b6bcb9e61f6d0..afc29b0a82e46 100644
--- a/src/asahi/vulkan/hk_image.c
+++ b/src/asahi/vulkan/hk_image.c
@@ -436,7 +436,7 @@ hk_GetPhysicalDeviceImageFormatProperties2(
       maxArraySize = 1;
       break;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
    if (pImageFormatInfo->tiling == VK_IMAGE_TILING_LINEAR)
       maxArraySize = 1;
@@ -499,7 +499,7 @@ hk_GetPhysicalDeviceImageFormatProperties2(
          tiling_has_explicit_layout = false;
          break;
       default:
-         unreachable("Unsupported VkImageTiling");
+         UNREACHABLE("Unsupported VkImageTiling");
       }
 
       switch (external_info->handleType) {
@@ -721,7 +721,7 @@ hk_map_tiling(struct hk_device *dev, const VkImageCreateInfo *info,
       return ail_drm_modifier_to_tiling(modifier);
 
    default:
-      unreachable("invalid tiling");
+      UNREACHABLE("invalid tiling");
    }
 }
 
@@ -740,7 +740,7 @@ hk_map_compression(struct hk_device *dev, const VkImageCreateInfo *info,
       return ail_is_drm_modifier_compressed(modifier);
 
    default:
-      unreachable("invalid tiling");
+      UNREACHABLE("invalid tiling");
    }
 }
 
@@ -1337,7 +1337,7 @@ hk_image_plane_bind(struct hk_device *dev, struct hk_image_plane *plane,
                              *offset_B,
                              plane->nil.pte_kind);
 #endif
-      unreachable("todo");
+      UNREACHABLE("todo");
    } else {
       plane->addr = mem->bo->va->addr + *offset_B;
       plane->map = agx_bo_map(mem->bo) + *offset_B;
@@ -1631,7 +1631,7 @@ hk_copy_image_to_image_cpu(struct hk_device *device, struct hk_image *src_image,
                    extent.width * src_block_B);
          }
       } else if (!src_tiled) {
-         unreachable("todo");
+         UNREACHABLE("todo");
 #if 0
          fdl6_memcpy_linear_to_tiled(
             dst_offset.x, dst_offset.y, extent.width, extent.height, dst,
@@ -1640,7 +1640,7 @@ hk_copy_image_to_image_cpu(struct hk_device *device, struct hk_image *src_image,
             &device->physical_device->ubwc_config);
 #endif
       } else if (!dst_tiled) {
-         unreachable("todo");
+         UNREACHABLE("todo");
 #if 0
          fdl6_memcpy_tiled_to_linear(
             src_offset.x, src_offset.y, extent.width, extent.height,
diff --git a/src/asahi/vulkan/hk_image_view.c b/src/asahi/vulkan/hk_image_view.c
index 91761bc71dbc8..b5aa20af55b97 100644
--- a/src/asahi/vulkan/hk_image_view.c
+++ b/src/asahi/vulkan/hk_image_view.c
@@ -45,7 +45,7 @@ hk_image_view_type_is_array(VkImageViewType view_type)
       return true;
 
    default:
-      unreachable("Invalid image view type");
+      UNREACHABLE("Invalid image view type");
    }
 }
 
@@ -93,7 +93,7 @@ translate_image_view_type(VkImageViewType view_type, bool msaa, bool layered,
                          : AGX_TEXTURE_DIMENSION_CUBE_ARRAY;
 
    default:
-      unreachable("Invalid image view type");
+      UNREACHABLE("Invalid image view type");
    }
 }
 
@@ -114,7 +114,7 @@ vk_swizzle_to_pipe(VkComponentSwizzle swizzle)
    case VK_COMPONENT_SWIZZLE_ZERO:
       return PIPE_SWIZZLE_0;
    default:
-      unreachable("Invalid component swizzle");
+      UNREACHABLE("Invalid component swizzle");
    }
 }
 
@@ -135,7 +135,7 @@ get_stencil_format(enum pipe_format format)
    case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
       return PIPE_FORMAT_X32_S8X24_UINT;
    default:
-      unreachable("Unsupported depth/stencil format");
+      UNREACHABLE("Unsupported depth/stencil format");
    }
 }
 
diff --git a/src/asahi/vulkan/hk_nir_lower_descriptors.c b/src/asahi/vulkan/hk_nir_lower_descriptors.c
index 5684c3df464bb..25ede0d2c190f 100644
--- a/src/asahi/vulkan/hk_nir_lower_descriptors.c
+++ b/src/asahi/vulkan/hk_nir_lower_descriptors.c
@@ -65,7 +65,7 @@ lower_load_constant(nir_builder *b, nir_intrinsic_instr *load,
                     const struct lower_descriptors_ctx *ctx)
 {
    assert(load->intrinsic == nir_intrinsic_load_constant);
-   unreachable("todo: stick an address in the root descriptor or something");
+   UNREACHABLE("todo: stick an address in the root descriptor or something");
 
    uint32_t base = nir_intrinsic_base(load);
    uint32_t range = nir_intrinsic_range(load);
@@ -385,7 +385,7 @@ translate_pipeline_stat_bit(enum pipe_statistics_query_index pipe)
       return VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT;
    }
 
-   unreachable("invalid statistic");
+   UNREACHABLE("invalid statistic");
 }
 
 static bool
@@ -547,7 +547,7 @@ try_lower_intrin(nir_builder *b, nir_intrinsic_instr *intrin,
       return try_lower_load_vulkan_descriptor(b, intrin, ctx);
 
    case nir_intrinsic_load_workgroup_size:
-      unreachable("Should have been lowered by nir_lower_cs_intrinsics()");
+      UNREACHABLE("Should have been lowered by nir_lower_cs_intrinsics()");
 
    case nir_intrinsic_load_base_workgroup_id:
       return lower_sysval_to_root_table(b, intrin, cs.base_group);
@@ -784,7 +784,7 @@ lower_ssbo_resource_index(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Not an SSBO descriptor");
+      UNREACHABLE("Not an SSBO descriptor");
    }
 
    /* Tuck the stride in the top 8 bits of the binding address */
@@ -866,7 +866,7 @@ lower_load_ssbo_descriptor(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Unknown address mode");
+      UNREACHABLE("Unknown address mode");
    }
 
    nir_def_rewrite_uses(&intrin->def, desc);
diff --git a/src/asahi/vulkan/hk_query_pool.c b/src/asahi/vulkan/hk_query_pool.c
index a867194f1e4f4..a4a7b967045b8 100644
--- a/src/asahi/vulkan/hk_query_pool.c
+++ b/src/asahi/vulkan/hk_query_pool.c
@@ -59,7 +59,7 @@ hk_reports_per_query(struct hk_query_pool *pool)
       // Primitives succeeded and primitives needed
       return 2;
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -494,7 +494,7 @@ hk_cmd_begin_end_query(struct hk_cmd_buffer *cmd, struct hk_query_pool *pool,
    }
 
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    /* We need to set available=1 after the graphics work finishes. */
diff --git a/src/asahi/vulkan/hk_queue.c b/src/asahi/vulkan/hk_queue.c
index d86a3b34a6f55..0e0556f590b0d 100644
--- a/src/asahi/vulkan/hk_queue.c
+++ b/src/asahi/vulkan/hk_queue.c
@@ -235,7 +235,7 @@ asahi_fill_sync(struct drm_asahi_sync *sync, struct vk_sync *vk_sync,
                 uint64_t value)
 {
    if (unlikely(!vk_sync_type_is_drm_syncobj(vk_sync->type))) {
-      unreachable("Unsupported sync type");
+      UNREACHABLE("Unsupported sync type");
       return;
    }
 
@@ -943,7 +943,7 @@ translate_priority(VkQueueGlobalPriorityKHR prio)
       return DRM_ASAHI_PRIORITY_LOW;
 
    default:
-      unreachable("Invalid VkQueueGlobalPriorityKHR");
+      UNREACHABLE("Invalid VkQueueGlobalPriorityKHR");
    }
 }
 
diff --git a/src/asahi/vulkan/hk_sampler.c b/src/asahi/vulkan/hk_sampler.c
index 6c399de9cfdd8..bbd98c097060d 100644
--- a/src/asahi/vulkan/hk_sampler.c
+++ b/src/asahi/vulkan/hk_sampler.c
@@ -73,7 +73,7 @@ translate_mipfilter(VkSamplerMipmapMode mode)
       return AGX_MIP_FILTER_LINEAR;
 
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    }
 }
 
@@ -129,7 +129,7 @@ translate_border_color(VkBorderColor color, bool custom_to_1,
       return AGX_BORDER_COLOUR_OPAQUE_WHITE;
 
    default:
-      unreachable("invalid");
+      UNREACHABLE("invalid");
    }
 }
 
diff --git a/src/asahi/vulkan/hk_shader.h b/src/asahi/vulkan/hk_shader.h
index 6f550677363f4..c3f4917e718b2 100644
--- a/src/asahi/vulkan/hk_shader.h
+++ b/src/asahi/vulkan/hk_shader.h
@@ -338,7 +338,7 @@ hk_buffer_addr_format(VkPipelineRobustnessBufferBehaviorEXT robustness)
    case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT:
       return nir_address_format_64bit_bounded_global;
    default:
-      unreachable("Invalid robust buffer access behavior");
+      UNREACHABLE("Invalid robust buffer access behavior");
    }
 }
 
diff --git a/src/broadcom/clif/clif_dump.c b/src/broadcom/clif/clif_dump.c
index db94edba11369..5e99e0c728672 100644
--- a/src/broadcom/clif/clif_dump.c
+++ b/src/broadcom/clif/clif_dump.c
@@ -115,7 +115,7 @@ clif_dump_packet(struct clif_dump *clif, uint32_t offset, const uint8_t *cl,
         default:
                 break;
         };
-        unreachable("Unknown HW version");
+        UNREACHABLE("Unknown HW version");
 }
 
 static uint32_t
diff --git a/src/broadcom/common/v3d_tiling.c b/src/broadcom/common/v3d_tiling.c
index 6e78591657878..52fdbb6c5803f 100644
--- a/src/broadcom/common/v3d_tiling.c
+++ b/src/broadcom/common/v3d_tiling.c
@@ -46,7 +46,7 @@ v3d_utile_width(int cpp)
         case 16:
                 return 2;
         default:
-                unreachable("unknown cpp");
+                UNREACHABLE("unknown cpp");
         }
 }
 
@@ -64,7 +64,7 @@ v3d_utile_height(int cpp)
         case 16:
                 return 2;
         default:
-                unreachable("unknown cpp");
+                UNREACHABLE("unknown cpp");
         }
 }
 
@@ -447,7 +447,7 @@ v3d_move_tiled_image(void *gpu, uint32_t gpu_stride,
                                         is_load);
                 break;
         default:
-                unreachable("Unsupported tiling format");
+                UNREACHABLE("Unsupported tiling format");
                 break;
         }
 }
diff --git a/src/broadcom/common/v3d_util.c b/src/broadcom/common/v3d_util.c
index 813d4f7f1234c..460a218667ff3 100644
--- a/src/broadcom/common/v3d_util.c
+++ b/src/broadcom/common/v3d_util.c
@@ -211,7 +211,7 @@ v3d_translate_pipe_swizzle(enum pipe_swizzle swizzle)
    case PIPE_SWIZZLE_W:
       return 2 + swizzle;
    default:
-      unreachable("unknown swizzle");
+      UNREACHABLE("unknown swizzle");
    }
 }
 
@@ -238,7 +238,7 @@ v3d_hw_prim_type(enum mesa_prim prim_type)
       return 8 + (prim_type - MESA_PRIM_LINES_ADJACENCY);
 
    default:
-      unreachable("Unsupported primitive type");
+      UNREACHABLE("Unsupported primitive type");
    }
 }
 
@@ -253,7 +253,7 @@ v3d_internal_bpp_words(uint32_t internal_bpp)
         case 2 /* V3D_INTERNAL_BPP_128 */:
                 return 4;
         default:
-                unreachable("Unsupported internal BPP");
+                UNREACHABLE("Unsupported internal BPP");
         }
 }
 
diff --git a/src/broadcom/common/v3d_util.h b/src/broadcom/common/v3d_util.h
index 73dae0d95d70a..b33706cea2971 100644
--- a/src/broadcom/common/v3d_util.h
+++ b/src/broadcom/common/v3d_util.h
@@ -46,7 +46,7 @@
                 v3d_X_thing = &v3d71_##thing;                   \
                 break;                                          \
         default:                                                \
-                unreachable("Unsupported hardware generation"); \
+                UNREACHABLE("Unsupported hardware generation"); \
         }                                                       \
         v3d_X_thing;                                            \
 })
@@ -94,7 +94,7 @@ log2_tile_size(uint32_t size)
         case 64:
                 return 3;
         default:
-                unreachable("Unsupported tile width/height");
+                UNREACHABLE("Unsupported tile width/height");
         }
 }
 
diff --git a/src/broadcom/compiler/nir_to_vir.c b/src/broadcom/compiler/nir_to_vir.c
index de6e76fd2e3d4..2475f858a727a 100644
--- a/src/broadcom/compiler/nir_to_vir.c
+++ b/src/broadcom/compiler/nir_to_vir.c
@@ -98,7 +98,7 @@ v3d_tmu_get_type_from_op(uint32_t tmu_op, bool is_write)
                 return V3D_TMU_OP_TYPE_REGULAR;
 
         default:
-                unreachable("Unknown tmu_op\n");
+                UNREACHABLE("Unknown tmu_op\n");
         }
 }
 static void
@@ -204,7 +204,7 @@ v3d_general_tmu_op_for_atomic(nir_intrinsic_instr *instr)
         case nir_atomic_op_ixor:    return V3D_TMU_OP_WRITE_XOR_READ_NOT;
         case nir_atomic_op_xchg:    return V3D_TMU_OP_WRITE_XCHG_READ_FLUSH;
         case nir_atomic_op_cmpxchg: return V3D_TMU_OP_WRITE_CMPXCHG_READ_FLUSH;
-        default:                    unreachable("unknown atomic op");
+        default:                    UNREACHABLE("unknown atomic op");
         }
 }
 
@@ -234,7 +234,7 @@ v3d_general_tmu_op(nir_intrinsic_instr *instr)
                 return v3d_general_tmu_op_for_atomic(instr);
 
         default:
-                unreachable("unknown intrinsic op");
+                UNREACHABLE("unknown intrinsic op");
         }
 }
 
@@ -681,7 +681,7 @@ ntq_emit_tmu_general(struct v3d_compile *c, nir_intrinsic_instr *instr,
                                         config |= GENERAL_TMU_LOOKUP_TYPE_8BIT_UI;
                                         break;
                                 default:
-                                        unreachable("Unsupported bitsize");
+                                        UNREACHABLE("Unsupported bitsize");
                                 }
                         } else {
                                 assert(type_size == 4);
@@ -944,7 +944,7 @@ ntq_emit_txs(struct v3d_compile *c, nir_tex_instr *instr)
                         break;
 
                 default:
-                        unreachable("Bad sampler type");
+                        UNREACHABLE("Bad sampler type");
                 }
 
                 ntq_store_def(c, &instr->def, i, size);
@@ -1103,7 +1103,7 @@ emit_fragment_varying(struct v3d_compile *c, nir_variable *var,
                 break;
 
         default:
-                unreachable("Bad interp mode");
+                UNREACHABLE("Bad interp mode");
         }
 
         if (input_idx >= 0)
@@ -3809,7 +3809,7 @@ ntq_emit_intrinsic(struct v3d_compile *c, nir_intrinsic_instr *instr)
 
         case nir_intrinsic_emit_vertex:
         case nir_intrinsic_end_primitive:
-                unreachable("Should have been lowered in v3d_nir_lower_io");
+                UNREACHABLE("Should have been lowered in v3d_nir_lower_io");
                 break;
 
         case nir_intrinsic_load_primitive_id: {
@@ -4090,7 +4090,7 @@ ntq_emit_intrinsic(struct v3d_compile *c, nir_intrinsic_instr *instr)
         }
 
         case nir_intrinsic_load_num_subgroups:
-                unreachable("Should have been lowered");
+                UNREACHABLE("Should have been lowered");
                 break;
 
         case nir_intrinsic_load_view_index:
@@ -4421,13 +4421,13 @@ ntq_emit_jump(struct v3d_compile *c, nir_jump_instr *jump)
                 break;
 
         case nir_jump_return:
-                unreachable("All returns should be lowered\n");
+                UNREACHABLE("All returns should be lowered\n");
                 break;
 
         case nir_jump_halt:
         case nir_jump_goto:
         case nir_jump_goto_if:
-                unreachable("not supported\n");
+                UNREACHABLE("not supported\n");
                 break;
         }
 }
@@ -4448,13 +4448,13 @@ ntq_emit_uniform_jump(struct v3d_compile *c, nir_jump_instr *jump)
                 break;
 
         case nir_jump_return:
-                unreachable("All returns should be lowered\n");
+                UNREACHABLE("All returns should be lowered\n");
                 break;
 
         case nir_jump_halt:
         case nir_jump_goto:
         case nir_jump_goto_if:
-                unreachable("not supported\n");
+                UNREACHABLE("not supported\n");
                 break;
         }
 }
@@ -4476,7 +4476,7 @@ ntq_emit_instr(struct v3d_compile *c, nir_instr *instr)
                 break;
 
         case nir_instr_type_undef:
-                unreachable("Should've been lowered by nir_lower_undef_to_zero");
+                UNREACHABLE("Should've been lowered by nir_lower_undef_to_zero");
                 break;
 
         case nir_instr_type_tex:
@@ -4841,7 +4841,7 @@ nir_to_vir(struct v3d_compile *c)
         case MESA_SHADER_COMPUTE:
                 break;
         default:
-                unreachable("unsupported shader stage");
+                UNREACHABLE("unsupported shader stage");
         }
 
         ntq_setup_outputs(c);
@@ -4994,7 +4994,7 @@ v3d_nir_to_vir(struct v3d_compile *c)
         case MESA_SHADER_COMPUTE:
                 break;
         default:
-                unreachable("bad stage");
+                UNREACHABLE("bad stage");
         }
 
         if (V3D_DBG(VIR) ||
diff --git a/src/broadcom/compiler/qpu_schedule.c b/src/broadcom/compiler/qpu_schedule.c
index f52474623ace8..c012f84e565fa 100644
--- a/src/broadcom/compiler/qpu_schedule.c
+++ b/src/broadcom/compiler/qpu_schedule.c
@@ -1106,7 +1106,7 @@ add_op_as_mul_op(enum v3d_qpu_add_op op)
         case V3D_QPU_A_SUB:
                 return V3D_QPU_M_SUB;
         default:
-                unreachable("unexpected add opcode");
+                UNREACHABLE("unexpected add opcode");
         }
 }
 
@@ -1171,7 +1171,7 @@ mul_op_as_add_op(enum v3d_qpu_mul_op op)
         case V3D_QPU_M_FMOV:
                 return V3D_QPU_A_FMOV;
         default:
-                unreachable("unexpected mov opcode");
+                UNREACHABLE("unexpected mov opcode");
         }
 }
 
diff --git a/src/broadcom/compiler/v3d_nir_lower_image_load_store.c b/src/broadcom/compiler/v3d_nir_lower_image_load_store.c
index ea8937fa823fa..5108c2f580007 100644
--- a/src/broadcom/compiler/v3d_nir_lower_image_load_store.c
+++ b/src/broadcom/compiler/v3d_nir_lower_image_load_store.c
@@ -232,7 +232,7 @@ pack_16bit(nir_builder *b, nir_def *color,
                 results[0] = nir_pack_2x32_to_2x16_v3d(b, channels[0], channels[1]);
                 break;
         default:
-                unreachable("Invalid number of components");
+                UNREACHABLE("Invalid number of components");
         }
 
         return nir_vec(b, results, DIV_ROUND_UP(num_components, 2));
@@ -269,7 +269,7 @@ pack_xbit(nir_builder *b, nir_def *color,
                         return pack_16bit(b, color, num_components, conversion);
                 break;
         default:
-                unreachable("unrecognized bits");
+                UNREACHABLE("unrecognized bits");
         }
 }
 
@@ -313,7 +313,7 @@ v3d42_nir_lower_image_store(nir_builder *b, nir_intrinsic_instr *instr)
                         bits = bits_16;
                         break;
                 default:
-                        unreachable("unrecognized bits");
+                        UNREACHABLE("unrecognized bits");
                 }
 
                 bool pack_mask = false;
diff --git a/src/broadcom/compiler/v3d_nir_lower_io.c b/src/broadcom/compiler/v3d_nir_lower_io.c
index 557db360a9ea7..f79e017e10a95 100644
--- a/src/broadcom/compiler/v3d_nir_lower_io.c
+++ b/src/broadcom/compiler/v3d_nir_lower_io.c
@@ -104,7 +104,7 @@ v3d_varying_slot_vpm_offset(struct v3d_compile *c, unsigned location, unsigned c
                 used_outputs = c->gs_key->used_outputs;
                 break;
         default:
-                unreachable("Unsupported shader stage");
+                UNREACHABLE("Unsupported shader stage");
         }
 
         for (int i = 0; i < num_used_outputs; i++) {
@@ -572,7 +572,7 @@ v3d_nir_emit_ff_vpm_outputs(struct v3d_compile *c, nir_builder *b,
                 num_used_outputs = c->gs_key->num_used_outputs;
                 break;
         default:
-                unreachable("Unsupported shader stage");
+                UNREACHABLE("Unsupported shader stage");
         }
 
         for (int i = 0; i < num_used_outputs; i++) {
diff --git a/src/broadcom/compiler/v3d_tex.c b/src/broadcom/compiler/v3d_tex.c
index 94446fe161a3e..e93ded720333a 100644
--- a/src/broadcom/compiler/v3d_tex.c
+++ b/src/broadcom/compiler/v3d_tex.c
@@ -194,7 +194,7 @@ handle_tex_src(struct v3d_compile *c,
         }
 
         default:
-                unreachable("unknown texture source");
+                UNREACHABLE("unknown texture source");
         }
 }
 
@@ -397,7 +397,7 @@ v3d_image_atomic_tmu_op(nir_intrinsic_instr *instr)
         case nir_atomic_op_ixor:    return V3D_TMU_OP_WRITE_XOR_READ_NOT;
         case nir_atomic_op_xchg:    return V3D_TMU_OP_WRITE_XCHG_READ_FLUSH;
         case nir_atomic_op_cmpxchg: return V3D_TMU_OP_WRITE_CMPXCHG_READ_FLUSH;
-        default:                    unreachable("unknown atomic op");
+        default:                    UNREACHABLE("unknown atomic op");
         }
 }
 
@@ -414,7 +414,7 @@ v3d_image_load_store_tmu_op(nir_intrinsic_instr *instr)
                 return v3d_image_atomic_tmu_op(instr);
 
         default:
-                unreachable("unknown image intrinsic");
+                UNREACHABLE("unknown image intrinsic");
         };
 }
 
@@ -461,7 +461,7 @@ vir_image_emit_register_writes(struct v3d_compile *c,
                 break;
         }
         default:
-                unreachable("bad image sampler dim");
+                UNREACHABLE("bad image sampler dim");
         }
 
         /* In order to fetch on a cube map, we need to interpret it as
diff --git a/src/broadcom/compiler/vir.c b/src/broadcom/compiler/vir.c
index 12b185cc0462a..7f677eb2d7e8d 100644
--- a/src/broadcom/compiler/vir.c
+++ b/src/broadcom/compiler/vir.c
@@ -304,7 +304,7 @@ vir_channels_written(struct qinst *inst)
                         return 0xc;
                 }
         }
-        unreachable("Bad pack field");
+        UNREACHABLE("Bad pack field");
 }
 #endif
 
@@ -992,7 +992,7 @@ v3d_set_prog_data(struct v3d_compile *c,
                 v3d_cs_set_prog_data(c, (struct v3d_compute_prog_data *)prog_data);
                 break;
         default:
-                unreachable("unsupported shader stage");
+                UNREACHABLE("unsupported shader stage");
         }
 }
 
@@ -1680,7 +1680,7 @@ v3d_attempt_compile(struct v3d_compile *c)
         case MESA_SHADER_COMPUTE:
                 break;
         default:
-                unreachable("unsupported shader stage");
+                UNREACHABLE("unsupported shader stage");
         }
 
         switch (c->s->info.stage) {
diff --git a/src/broadcom/compiler/vir_opt_dead_code.c b/src/broadcom/compiler/vir_opt_dead_code.c
index 6d05385b1da9c..2d9f029d6ebb7 100644
--- a/src/broadcom/compiler/vir_opt_dead_code.c
+++ b/src/broadcom/compiler/vir_opt_dead_code.c
@@ -134,7 +134,7 @@ check_first_ldunifa(struct v3d_compile *c,
                         return false;
         }
 
-        unreachable("could not find starting unifa for ldunifa sequence");
+        UNREACHABLE("could not find starting unifa for ldunifa sequence");
 }
 
 static bool
diff --git a/src/broadcom/compiler/vir_register_allocate.c b/src/broadcom/compiler/vir_register_allocate.c
index dfb5b9a989a5f..d8166c891e0f9 100644
--- a/src/broadcom/compiler/vir_register_allocate.c
+++ b/src/broadcom/compiler/vir_register_allocate.c
@@ -240,7 +240,7 @@ reconstruct_temp(struct v3d_compile *c, enum v3d_qpu_add_op op)
                 dest = vir_SAMPID(c);
                 break;
         default:
-            unreachable("Unexpected opcode for reconstruction");
+            UNREACHABLE("Unexpected opcode for reconstruction");
         }
 
         return dest;
@@ -1034,7 +1034,7 @@ v3d_ra_select_callback(unsigned int n, BITSET_WORD *regs, void *data)
         if (v3d_ra_select_accum(v3d_ra, regs, &reg))
                 return reg;
 
-        unreachable("RA must pass us at least one possible reg.");
+        UNREACHABLE("RA must pass us at least one possible reg.");
 }
 
 bool
diff --git a/src/broadcom/qpu/qpu_instr.c b/src/broadcom/qpu/qpu_instr.c
index 286616d629bf4..0a21a16909503 100644
--- a/src/broadcom/qpu/qpu_instr.c
+++ b/src/broadcom/qpu/qpu_instr.c
@@ -241,7 +241,7 @@ v3d_qpu_cond_name(enum v3d_qpu_cond cond)
         case V3D_QPU_COND_IFNB:
                 return ".ifnb";
         default:
-                unreachable("bad cond value");
+                UNREACHABLE("bad cond value");
         }
 }
 
@@ -264,7 +264,7 @@ v3d_qpu_branch_cond_name(enum v3d_qpu_branch_cond cond)
         case V3D_QPU_BRANCH_COND_ALLNA:
                 return ".allna";
         default:
-                unreachable("bad branch cond value");
+                UNREACHABLE("bad branch cond value");
         }
 }
 
@@ -279,7 +279,7 @@ v3d_qpu_msfign_name(enum v3d_qpu_msfign msfign)
         case V3D_QPU_MSFIGN_Q:
                 return "q";
         default:
-                unreachable("bad branch cond value");
+                UNREACHABLE("bad branch cond value");
         }
 }
 
@@ -296,7 +296,7 @@ v3d_qpu_pf_name(enum v3d_qpu_pf pf)
         case V3D_QPU_PF_PUSHC:
                 return ".pushc";
         default:
-                unreachable("bad pf value");
+                UNREACHABLE("bad pf value");
         }
 }
 
@@ -331,7 +331,7 @@ v3d_qpu_uf_name(enum v3d_qpu_uf uf)
         case V3D_QPU_UF_NORNC:
                 return ".nornc";
         default:
-                unreachable("bad pf value");
+                UNREACHABLE("bad pf value");
         }
 }
 
@@ -346,7 +346,7 @@ v3d_qpu_pack_name(enum v3d_qpu_output_pack pack)
         case V3D_QPU_PACK_H:
                 return ".h";
         default:
-                unreachable("bad pack value");
+                UNREACHABLE("bad pack value");
         }
 }
 
@@ -377,7 +377,7 @@ v3d_qpu_unpack_name(enum v3d_qpu_input_unpack unpack)
         case V3D71_QPU_UNPACK_MAX0:
                 return ".max0";
         default:
-                unreachable("bad unpack value");
+                UNREACHABLE("bad unpack value");
         }
 }
 
@@ -576,7 +576,7 @@ v3d_qpu_cond_invert(enum v3d_qpu_cond cond)
         case V3D_QPU_COND_IFNB:
                 return V3D_QPU_COND_IFB;
         default:
-                unreachable("Non-invertible cond");
+                UNREACHABLE("Non-invertible cond");
         }
 }
 
diff --git a/src/broadcom/qpu/qpu_pack.c b/src/broadcom/qpu/qpu_pack.c
index 553756a34e5e7..b3c633a03ec3f 100644
--- a/src/broadcom/qpu/qpu_pack.c
+++ b/src/broadcom/qpu/qpu_pack.c
@@ -1282,7 +1282,7 @@ v3d71_qpu_add_unpack(const struct v3d_device_info *devinfo, uint64_t packed_inst
 
         case V3D_QPU_A_VFMIN:
         case V3D_QPU_A_VFMAX:
-                unreachable("pending v3d71 update");
+                UNREACHABLE("pending v3d71 update");
                 if (!v3d_qpu_float16_unpack_unpack(op & 0x7,
                                                    &instr->alu.add.a.unpack)) {
                         return false;
@@ -1479,7 +1479,7 @@ v3d71_qpu_mul_unpack(const struct v3d_device_info *devinfo, uint64_t packed_inst
                 break;
 
         case V3D_QPU_M_VFMUL:
-                unreachable("pending v3d71 update");
+                UNREACHABLE("pending v3d71 update");
                 instr->alu.mul.output_pack = V3D_QPU_PACK_NONE;
 
                 if (!v3d_qpu_float16_unpack_unpack(((op & 0x7) - 4) & 7,
@@ -2224,7 +2224,7 @@ v3d71_qpu_mul_pack(const struct v3d_device_info *devinfo,
         }
 
         case V3D_QPU_M_VFMUL: {
-                unreachable("pending v3d71 update");
+                UNREACHABLE("pending v3d71 update");
                 uint32_t packed;
 
                 if (instr->alu.mul.output_pack != V3D_QPU_PACK_NONE)
diff --git a/src/broadcom/simulator/v3d_simulator.h b/src/broadcom/simulator/v3d_simulator.h
index 03575ae895173..7fe055bc546a0 100644
--- a/src/broadcom/simulator/v3d_simulator.h
+++ b/src/broadcom/simulator/v3d_simulator.h
@@ -66,7 +66,7 @@ uint32_t v3d_simulator_get_mem_free(void);
       v3d_X_sim_thing = &v3d71_simulator_##thing;     \
       break;                                          \
    default:                                           \
-      unreachable("Unsupported hardware generation"); \
+      UNREACHABLE("Unsupported hardware generation"); \
    }                                                  \
    v3d_X_sim_thing;                                   \
 })
diff --git a/src/broadcom/simulator/v3dx_simulator.c b/src/broadcom/simulator/v3dx_simulator.c
index f8630de045d76..73c64e86e4232 100644
--- a/src/broadcom/simulator/v3dx_simulator.c
+++ b/src/broadcom/simulator/v3dx_simulator.c
@@ -432,7 +432,7 @@ v3d_isr_hub(struct v3d_hw *v3d)
                  * the future. In any case, note that for this case we would
                  * only be doing debugging log.
                  */
-                unreachable("TFU Conversion Complete interrupt not handled");
+                UNREACHABLE("TFU Conversion Complete interrupt not handled");
         }
 
         handle_mmu_interruptions(v3d, hub_status);
diff --git a/src/broadcom/vulkan/v3dv_cmd_buffer.c b/src/broadcom/vulkan/v3dv_cmd_buffer.c
index eca7bd3b735c1..7b7350ca5f972 100644
--- a/src/broadcom/vulkan/v3dv_cmd_buffer.c
+++ b/src/broadcom/vulkan/v3dv_cmd_buffer.c
@@ -4000,7 +4000,7 @@ v3dv_cmd_buffer_begin_query(struct v3dv_cmd_buffer *cmd_buffer,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -4138,7 +4138,7 @@ void v3dv_cmd_buffer_end_query(struct v3dv_cmd_buffer *cmd_buffer,
       v3dv_cmd_buffer_end_performance_query(cmd_buffer, pool, query);
       break;
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
diff --git a/src/broadcom/vulkan/v3dv_descriptor_set.c b/src/broadcom/vulkan/v3dv_descriptor_set.c
index 7bbe01ed9cab3..18a009f9d9cf2 100644
--- a/src/broadcom/vulkan/v3dv_descriptor_set.c
+++ b/src/broadcom/vulkan/v3dv_descriptor_set.c
@@ -245,7 +245,7 @@ v3dv_descriptor_map_get_texture_bo(struct v3dv_descriptor_state *descriptor_stat
       return image->planes[map->plane[index]].mem->bo;
    }
    default:
-      unreachable("descriptor type doesn't has a texture bo");
+      UNREACHABLE("descriptor type doesn't has a texture bo");
    }
 }
 
@@ -466,7 +466,7 @@ v3dv_CreateDescriptorPool(VkDevice _device,
       case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
          break;
       default:
-         unreachable("Unimplemented descriptor type");
+         UNREACHABLE("Unimplemented descriptor type");
          break;
       }
 
@@ -752,7 +752,7 @@ v3dv_CreateDescriptorSetLayout(VkDevice _device,
          /* Nothing here, just to keep the descriptor type filtering below */
          break;
       default:
-         unreachable("Unknown descriptor type\n");
+         UNREACHABLE("Unknown descriptor type\n");
          break;
       }
 
@@ -1266,7 +1266,7 @@ v3dv_UpdateDescriptorSets(VkDevice  _device,
             break;
          }
          default:
-            unreachable("unimplemented descriptor type");
+            UNREACHABLE("unimplemented descriptor type");
             break;
          }
          descriptor++;
@@ -1448,7 +1448,7 @@ v3dv_UpdateDescriptorSetWithTemplate(
       }
 
       default:
-         unreachable("Unsupported descriptor type");
+         UNREACHABLE("Unsupported descriptor type");
       }
    }
 }
diff --git a/src/broadcom/vulkan/v3dv_device.c b/src/broadcom/vulkan/v3dv_device.c
index d62130b71f201..2430ef01d8b8f 100644
--- a/src/broadcom/vulkan/v3dv_device.c
+++ b/src/broadcom/vulkan/v3dv_device.c
@@ -1601,7 +1601,7 @@ v3dv_physical_device_device_id(const struct v3dv_physical_device *dev)
    case 71:
       return 0x55701C33; /* Broadcom deviceID for 2712 */
    default:
-      unreachable("Unsupported V3D version");
+      UNREACHABLE("Unsupported V3D version");
    }
 }
 
diff --git a/src/broadcom/vulkan/v3dv_formats.c b/src/broadcom/vulkan/v3dv_formats.c
index 8327598f4e79c..ccaf8f2756643 100644
--- a/src/broadcom/vulkan/v3dv_formats.c
+++ b/src/broadcom/vulkan/v3dv_formats.c
@@ -102,7 +102,7 @@ v3dv_get_compatible_tfu_format(struct v3dv_device *device,
    case 4:  vk_format = VK_FORMAT_R32_SFLOAT;           break;
    case 2:  vk_format = VK_FORMAT_R16_SFLOAT;           break;
    case 1:  vk_format = VK_FORMAT_R8_UNORM;             break;
-   default: unreachable("unsupported format bit-size"); break;
+   default: UNREACHABLE("unsupported format bit-size"); break;
    };
 
    if (out_vk_format)
@@ -541,7 +541,7 @@ get_image_format_properties(
       pImageFormatProperties->maxMipLevels = V3D_MAX_MIP_LEVELS;
       break;
    default:
-      unreachable("bad VkImageType");
+      UNREACHABLE("bad VkImageType");
    }
 
    /* Our hw doesn't support 1D compressed textures. */
diff --git a/src/broadcom/vulkan/v3dv_image.c b/src/broadcom/vulkan/v3dv_image.c
index c98cbbd35204e..26dc311b6a3b6 100644
--- a/src/broadcom/vulkan/v3dv_image.c
+++ b/src/broadcom/vulkan/v3dv_image.c
@@ -690,7 +690,7 @@ v3dv_image_type_to_view_type(VkImageType type)
    case VK_IMAGE_TYPE_2D: return VK_IMAGE_VIEW_TYPE_2D;
    case VK_IMAGE_TYPE_3D: return VK_IMAGE_VIEW_TYPE_3D;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
diff --git a/src/broadcom/vulkan/v3dv_meta_clear.c b/src/broadcom/vulkan/v3dv_meta_clear.c
index c113e110e5bbd..a10a1392274ff 100644
--- a/src/broadcom/vulkan/v3dv_meta_clear.c
+++ b/src/broadcom/vulkan/v3dv_meta_clear.c
@@ -173,7 +173,7 @@ v3dv_CmdClearColorImage(VkCommandBuffer commandBuffer,
    for (uint32_t i = 0; i < rangeCount; i++) {
       if (clear_image_tlb(cmd_buffer, image, &clear_value, &pRanges[i]))
          continue;
-      unreachable("Unsupported color clear.");
+      UNREACHABLE("Unsupported color clear.");
    }
 
    cmd_buffer->state.is_transfer = false;
@@ -199,7 +199,7 @@ v3dv_CmdClearDepthStencilImage(VkCommandBuffer commandBuffer,
    for (uint32_t i = 0; i < rangeCount; i++) {
       if (clear_image_tlb(cmd_buffer, image, &clear_value, &pRanges[i]))
          continue;
-      unreachable("Unsupported depth/stencil clear.");
+      UNREACHABLE("Unsupported depth/stencil clear.");
    }
 
    cmd_buffer->state.is_transfer = false;
diff --git a/src/broadcom/vulkan/v3dv_meta_copy.c b/src/broadcom/vulkan/v3dv_meta_copy.c
index a39024200641d..f986a860f322a 100644
--- a/src/broadcom/vulkan/v3dv_meta_copy.c
+++ b/src/broadcom/vulkan/v3dv_meta_copy.c
@@ -679,7 +679,7 @@ gather_image_to_buffer_info(struct v3dv_cmd_buffer *cmd_buffer,
          buffer_bpp = 1;
          break;
       default:
-         unreachable("unsupported aspect");
+         UNREACHABLE("unsupported aspect");
          return supported;
       };
       break;
@@ -695,7 +695,7 @@ gather_image_to_buffer_info(struct v3dv_cmd_buffer *cmd_buffer,
       src_format = dst_format;
       break;
    default:
-      unreachable("unsupported bit-size");
+      UNREACHABLE("unsupported bit-size");
       return supported;
    };
 
@@ -994,7 +994,7 @@ copy_image_to_buffer_blit(struct v3dv_cmd_buffer *cmd_buffer,
                             &blit_region, VK_FILTER_NEAREST, false);
       if (!handled) {
          /* This is unexpected, we should have a supported blit spec */
-         unreachable("Unable to blit buffer to destination image");
+         UNREACHABLE("Unable to blit buffer to destination image");
          return false;
       }
    }
@@ -1131,7 +1131,7 @@ v3dv_CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
       if (copy_image_to_buffer_texel_buffer(cmd_buffer, buffer, image, region))
          continue;
 
-      unreachable("Unsupported image to buffer copy.");
+      UNREACHABLE("Unsupported image to buffer copy.");
    }
    cmd_buffer->state.is_transfer = false;
 }
@@ -1514,7 +1514,7 @@ copy_image_blit(struct v3dv_cmd_buffer *cmd_buffer,
          format = VK_FORMAT_R16G16B16A16_UINT;
          break;
       default:
-         unreachable("Unsupported compressed format");
+         UNREACHABLE("Unsupported compressed format");
       }
 
       /* Create image views of the src/dst images that we can interpret in
@@ -1654,7 +1654,7 @@ copy_image_linear_texel_buffer(struct v3dv_cmd_buffer *cmd_buffer,
       format = VK_FORMAT_R8_UINT;
       break;
    default:
-      unreachable("unsupported bit-size");
+      UNREACHABLE("unsupported bit-size");
       return false;
    }
 
@@ -1736,7 +1736,7 @@ v3dv_CmdCopyImage2(VkCommandBuffer commandBuffer,
          continue;
       if (copy_image_linear_texel_buffer(cmd_buffer, dst, src, region))
          continue;
-      unreachable("Image copy not supported");
+      UNREACHABLE("Image copy not supported");
    }
 
    cmd_buffer->state.is_transfer = false;
@@ -2320,7 +2320,7 @@ component_swizzle_to_nir_swizzle(VkComponentSwizzle comp, VkComponentSwizzle swz
    case VK_COMPONENT_SWIZZLE_A:
       return 3;
    default:
-      unreachable("Invalid swizzle");
+      UNREACHABLE("Invalid swizzle");
    };
 }
 
@@ -3076,7 +3076,7 @@ copy_buffer_to_image_blit(struct v3dv_cmd_buffer *cmd_buffer,
             /* This is unexpected, we should have setup the upload to be
              * conformant to a TFU or TLB copy.
              */
-            unreachable("Unable to copy buffer to image through TLB");
+            UNREACHABLE("Unable to copy buffer to image through TLB");
             return false;
          }
 
@@ -3130,7 +3130,7 @@ copy_buffer_to_image_blit(struct v3dv_cmd_buffer *cmd_buffer,
                                &blit_region, VK_FILTER_NEAREST, true);
          if (!handled) {
             /* This is unexpected, we should have a supported blit spec */
-            unreachable("Unable to blit buffer to destination image");
+            UNREACHABLE("Unable to blit buffer to destination image");
             return false;
          }
       }
@@ -3245,7 +3245,7 @@ copy_buffer_to_image_shader(struct v3dv_cmd_buffer *cmd_buffer,
          cmask = VK_COLOR_COMPONENT_R_BIT;
          break;
       default:
-         unreachable("unsupported aspect");
+         UNREACHABLE("unsupported aspect");
          return false;
       };
       break;
@@ -3262,7 +3262,7 @@ copy_buffer_to_image_shader(struct v3dv_cmd_buffer *cmd_buffer,
       dst_format = src_format;
       break;
    default:
-      unreachable("unsupported bit-size");
+      UNREACHABLE("unsupported bit-size");
       return false;
    }
 
@@ -3348,7 +3348,7 @@ v3dv_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
          goto handled;
       }
 
-      unreachable("Unsupported buffer to image copy.");
+      UNREACHABLE("Unsupported buffer to image copy.");
 
 handled:
       r += batch_size;
@@ -3844,7 +3844,7 @@ get_channel_mask_for_sampler_dim(enum glsl_sampler_dim sampler_dim)
    case GLSL_SAMPLER_DIM_MS: return 0x3;
    case GLSL_SAMPLER_DIM_3D: return 0x7;
    default:
-      unreachable("invalid sampler dim");
+      UNREACHABLE("invalid sampler dim");
    };
 }
 
@@ -4072,7 +4072,7 @@ get_sampler_dim(VkImageType type, VkSampleCountFlagBits src_samples)
                                                     GLSL_SAMPLER_DIM_MS;
    case VK_IMAGE_TYPE_3D: return GLSL_SAMPLER_DIM_3D;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -4421,7 +4421,7 @@ blit_shader(struct v3dv_cmd_buffer *cmd_buffer,
          dst_format = VK_FORMAT_R8G8B8A8_UINT;
          break;
       default:
-         unreachable("Unsupported depth/stencil format");
+         UNREACHABLE("Unsupported depth/stencil format");
       };
       src_format = dst_format;
    }
@@ -4851,7 +4851,7 @@ v3dv_CmdBlitImage2(VkCommandBuffer commandBuffer,
                       pBlitImageInfo->filter, true)) {
          continue;
       }
-      unreachable("Unsupported blit operation");
+      UNREACHABLE("Unsupported blit operation");
    }
 
    cmd_buffer->state.is_transfer = false;
@@ -4980,7 +4980,7 @@ v3dv_CmdResolveImage2(VkCommandBuffer commandBuffer,
          continue;
       if (resolve_image_blit(cmd_buffer, dst, src, &info->pRegions[i]))
          continue;
-      unreachable("Unsupported multismaple resolve operation");
+      UNREACHABLE("Unsupported multismaple resolve operation");
    }
 
    cmd_buffer->state.is_transfer = false;
diff --git a/src/broadcom/vulkan/v3dv_pipeline.c b/src/broadcom/vulkan/v3dv_pipeline.c
index 28058489f2b00..54ea07cb25f53 100644
--- a/src/broadcom/vulkan/v3dv_pipeline.c
+++ b/src/broadcom/vulkan/v3dv_pipeline.c
@@ -522,7 +522,7 @@ pipeline_get_descriptor_map(struct v3dv_pipeline *pipeline,
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
       return &pipeline->shared_data->maps[broadcom_stage]->ssbo_map;
    default:
-      unreachable("Descriptor type unknown or not having a descriptor map");
+      UNREACHABLE("Descriptor type unknown or not having a descriptor map");
    }
 }
 
@@ -555,7 +555,7 @@ lower_vulkan_resource_index(nir_builder *b,
                                      b->shader->info.stage, false);
 
       if (!const_val)
-         unreachable("non-constant vulkan_resource_index array index");
+         UNREACHABLE("non-constant vulkan_resource_index array index");
 
       /* At compile-time we will need to know if we are processing a UBO load
        * for an inline or a regular UBO so we can handle inline loads like
@@ -582,7 +582,7 @@ lower_vulkan_resource_index(nir_builder *b,
    }
 
    default:
-      unreachable("unsupported descriptor type for vulkan_resource_index");
+      UNREACHABLE("unsupported descriptor type for vulkan_resource_index");
       break;
    }
 
@@ -1019,7 +1019,7 @@ pipeline_populate_v3d_key(struct v3d_key *key,
       key->is_last_geometry_stage = false;
       break;
    default:
-      unreachable("unsupported shader stage");
+      UNREACHABLE("unsupported shader stage");
    }
 
    const VkPipelineRobustnessBufferBehaviorEXT robust_buffer_enabled =
@@ -2253,7 +2253,7 @@ multiview_gs_input_primitive_from_pipeline(struct v3dv_pipeline *pipeline)
       /* Since we don't allow GS with multiview, we can only see non-adjacency
        * primitives.
        */
-      unreachable("Unexpected pipeline primitive type");
+      UNREACHABLE("Unexpected pipeline primitive type");
    }
 }
 
@@ -2274,7 +2274,7 @@ multiview_gs_output_primitive_from_pipeline(struct v3dv_pipeline *pipeline)
       /* Since we don't allow GS with multiview, we can only see non-adjacency
        * primitives.
        */
-      unreachable("Unexpected pipeline primitive type");
+      UNREACHABLE("Unexpected pipeline primitive type");
    }
 }
 
diff --git a/src/broadcom/vulkan/v3dv_private.h b/src/broadcom/vulkan/v3dv_private.h
index e0f0398baabff..053c898f020ee 100644
--- a/src/broadcom/vulkan/v3dv_private.h
+++ b/src/broadcom/vulkan/v3dv_private.h
@@ -375,7 +375,7 @@ gl_shader_stage_to_broadcom(gl_shader_stage stage)
    case MESA_SHADER_COMPUTE:
       return BROADCOM_SHADER_COMPUTE;
    default:
-      unreachable("Unknown gl shader stage");
+      UNREACHABLE("Unknown gl shader stage");
    }
 }
 
@@ -394,7 +394,7 @@ broadcom_shader_stage_to_gl(enum broadcom_shader_stage stage)
    case BROADCOM_SHADER_COMPUTE:
       return MESA_SHADER_COMPUTE;
    default:
-      unreachable("Unknown broadcom shader stage");
+      UNREACHABLE("Unknown broadcom shader stage");
    }
 }
 
@@ -431,7 +431,7 @@ broadcom_binning_shader_stage_for_render_stage(enum broadcom_shader_stage stage)
    case BROADCOM_SHADER_GEOMETRY:
       return BROADCOM_SHADER_GEOMETRY_BIN;
    default:
-      unreachable("Invalid shader stage");
+      UNREACHABLE("Invalid shader stage");
    }
 }
 
@@ -665,7 +665,7 @@ static uint8_t v3dv_plane_from_aspect(VkImageAspectFlags aspect)
    case VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT:
       return 2;
    default:
-      unreachable("invalid image aspect");
+      UNREACHABLE("invalid image aspect");
    }
 }
 
diff --git a/src/broadcom/vulkan/v3dv_query.c b/src/broadcom/vulkan/v3dv_query.c
index 0a311bd1d536c..4f9d44595de8f 100644
--- a/src/broadcom/vulkan/v3dv_query.c
+++ b/src/broadcom/vulkan/v3dv_query.c
@@ -331,7 +331,7 @@ v3dv_CreateQueryPool(VkDevice _device,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    /* Initialize queries in the pool */
@@ -363,7 +363,7 @@ v3dv_CreateQueryPool(VkDevice _device,
          break;
          }
       default:
-         unreachable("Unsupported query type");
+         UNREACHABLE("Unsupported query type");
       }
    }
 
@@ -688,7 +688,7 @@ write_query_result(struct v3dv_device *device,
       return write_performance_query_result(device, pool, query, do_64bit,
                                             data, slot);
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -702,7 +702,7 @@ get_query_result_count(struct v3dv_query_pool *pool)
    case VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR:
       return pool->perfmon.ncounters;
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -1331,7 +1331,7 @@ v3dv_reset_query_pool_cpu(struct v3dv_device *device,
             mesa_loge("Failed to reset sync");
          break;
       default:
-         unreachable("Unsupported query type");
+         UNREACHABLE("Unsupported query type");
       }
    }
 
diff --git a/src/broadcom/vulkan/v3dv_queue.c b/src/broadcom/vulkan/v3dv_queue.c
index 6038d477ca531..36decae6a5faf 100644
--- a/src/broadcom/vulkan/v3dv_queue.c
+++ b/src/broadcom/vulkan/v3dv_queue.c
@@ -1222,7 +1222,7 @@ queue_handle_job(struct v3dv_queue *queue,
    case V3DV_JOB_TYPE_CPU_TIMESTAMP_QUERY:
       return handle_timestamp_query_cpu_job(queue, job, sync_info, signal_syncs);
    default:
-      unreachable("Unhandled job type");
+      UNREACHABLE("Unhandled job type");
    }
 }
 
diff --git a/src/broadcom/vulkan/v3dv_uniforms.c b/src/broadcom/vulkan/v3dv_uniforms.c
index a8d6bfab1bbe6..40adec3419cda 100644
--- a/src/broadcom/vulkan/v3dv_uniforms.c
+++ b/src/broadcom/vulkan/v3dv_uniforms.c
@@ -399,7 +399,7 @@ get_texture_size_from_image_view(struct v3dv_image_view *image_view,
       assert(image_view->vk.image);
       return image_view->vk.image->samples;
    default:
-      unreachable("Bad texture size field");
+      UNREACHABLE("Bad texture size field");
    }
 }
 
@@ -415,7 +415,7 @@ get_texture_size_from_buffer_view(struct v3dv_buffer_view *buffer_view,
       return buffer_view->num_elements;
    /* Only size can be queried for texel buffers  */
    default:
-      unreachable("Bad texture size field for texel buffers");
+      UNREACHABLE("Bad texture size field for texel buffers");
    }
 }
 
@@ -451,7 +451,7 @@ get_texture_size(struct v3dv_cmd_buffer *cmd_buffer,
       return get_texture_size_from_buffer_view(descriptor->buffer_view,
                                                contents, data);
    default:
-      unreachable("Wrong descriptor for getting texture size");
+      UNREACHABLE("Wrong descriptor for getting texture size");
    }
 }
 
@@ -684,7 +684,7 @@ v3dv_write_uniforms_wg_offsets(struct v3dv_cmd_buffer *cmd_buffer,
          break;
 
       default:
-         unreachable("unsupported quniform_contents uniform type\n");
+         UNREACHABLE("unsupported quniform_contents uniform type\n");
       }
    }
 
diff --git a/src/broadcom/vulkan/v3dvx_cmd_buffer.c b/src/broadcom/vulkan/v3dvx_cmd_buffer.c
index 6cde8af89c11e..8816e0f00ea68 100644
--- a/src/broadcom/vulkan/v3dvx_cmd_buffer.c
+++ b/src/broadcom/vulkan/v3dvx_cmd_buffer.c
@@ -864,7 +864,7 @@ v3dX(clamp_for_format_and_type)(uint32_t rt_type,
    case V3D_INTERNAL_TYPE_32F:
       return V3D_RENDER_TARGET_TYPE_CLAMP_32F;
    default:
-      unreachable("Unknown internal render target type");
+      UNREACHABLE("Unknown internal render target type");
    }
 
    return V3D_RENDER_TARGET_TYPE_CLAMP_INVALID;
@@ -2331,7 +2331,7 @@ v3d_gs_output_primitive(enum mesa_prim prim_type)
     case MESA_PRIM_TRIANGLE_STRIP:
         return GEOMETRY_SHADER_TRI_STRIP;
     default:
-        unreachable("Unsupported primitive type");
+        UNREACHABLE("Unsupported primitive type");
     }
 }
 
@@ -2366,7 +2366,7 @@ simd_width_to_gs_pack_mode(uint32_t width)
    case 1:
       return V3D_PACK_MODE_1_WAY;
    default:
-      unreachable("Invalid SIMD width");
+      UNREACHABLE("Invalid SIMD width");
    };
 }
 
diff --git a/src/broadcom/vulkan/v3dvx_device.c b/src/broadcom/vulkan/v3dvx_device.c
index 1df69d0240f30..ba093326ae512 100644
--- a/src/broadcom/vulkan/v3dvx_device.c
+++ b/src/broadcom/vulkan/v3dvx_device.c
@@ -221,7 +221,7 @@ v3dX(pack_sampler_state)(const struct v3dv_device *device,
       border_color_mode = V3D_BORDER_COLOR_FOLLOWS;
       break;
    default:
-      unreachable("Unknown border color");
+      UNREACHABLE("Unknown border color");
       break;
    }
 
diff --git a/src/broadcom/vulkan/v3dvx_formats.c b/src/broadcom/vulkan/v3dvx_formats.c
index 68902b9bc09ee..5c4fc95d9845e 100644
--- a/src/broadcom/vulkan/v3dvx_formats.c
+++ b/src/broadcom/vulkan/v3dvx_formats.c
@@ -517,7 +517,7 @@ v3dX(get_internal_depth_type)(VkFormat format)
    case VK_FORMAT_D24_UNORM_S8_UINT:
       return V3D_INTERNAL_TYPE_DEPTH_24;
    default:
-      unreachable("Invalid depth format");
+      UNREACHABLE("Invalid depth format");
       break;
    }
 }
diff --git a/src/broadcom/vulkan/v3dvx_pipeline.c b/src/broadcom/vulkan/v3dvx_pipeline.c
index 693376bf81529..9aba15b91392a 100644
--- a/src/broadcom/vulkan/v3dvx_pipeline.c
+++ b/src/broadcom/vulkan/v3dvx_pipeline.c
@@ -65,7 +65,7 @@ blend_factor(VkBlendFactor factor, bool dst_alpha_one, bool *needs_constants,
       *needs_dual_src = true;
       return VK_BLEND_FACTOR_ZERO;
    default:
-      unreachable("Unknown blend factor.");
+      UNREACHABLE("Unknown blend factor.");
    }
 }
 
@@ -266,7 +266,7 @@ v3dX(translate_stencil_op)(VkStencilOp op)
    case VK_STENCIL_OP_DECREMENT_AND_WRAP:
       return V3D_STENCIL_OP_DECWRAP;
    default:
-      unreachable("bad stencil op");
+      UNREACHABLE("bad stencil op");
    }
 }
 
diff --git a/src/compiler/clc/clc_helpers.cpp b/src/compiler/clc/clc_helpers.cpp
index 0bfc929b5b915..b61e1048a0ad1 100644
--- a/src/compiler/clc/clc_helpers.cpp
+++ b/src/compiler/clc/clc_helpers.cpp
@@ -534,7 +534,7 @@ public:
             literalType = CLC_SPEC_CONSTANT_HALF;
             break;
          default:
-            unreachable("Unexpected float bit size");
+            UNREACHABLE("Unexpected float bit size");
          }
          break;
       }
@@ -556,7 +556,7 @@ public:
                literalType = CLC_SPEC_CONSTANT_INT64;
                break;
             default:
-               unreachable("Unexpected int bit size");
+               UNREACHABLE("Unexpected int bit size");
             }
          } else {
             switch (sizeInBits) {
@@ -573,13 +573,13 @@ public:
                literalType = CLC_SPEC_CONSTANT_UINT64;
                break;
             default:
-               unreachable("Unexpected uint bit size");
+               UNREACHABLE("Unexpected uint bit size");
             }
          }
          break;
       }
       default:
-         unreachable("Unexpected type opcode");
+         UNREACHABLE("Unexpected type opcode");
       }
    }
 
@@ -605,7 +605,7 @@ public:
                data.type = CLC_SPEC_CONSTANT_BOOL;
                break;
             default:
-               unreachable("Composites and Ops are not directly specializable.");
+               UNREACHABLE("Composites and Ops are not directly specializable.");
             }
          }
       }
diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index 4957a6c91d951..34eb894fc36cd 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -2597,7 +2597,7 @@ ast_function_expression::hir(exec_list *instructions,
       return value;
    }
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 bool
diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index c8eee0f8b1a58..5aa2805d80fac 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -1206,7 +1206,7 @@ do_comparison(void *mem_ctx, int operation, ir_rvalue *op0, ir_rvalue *op1)
       break;
 
    case GLSL_TYPE_COOPERATIVE_MATRIX:
-      unreachable("unsupported base type cooperative matrix");
+      UNREACHABLE("unsupported base type cooperative matrix");
    }
 
    if (cmp == NULL)
@@ -1443,7 +1443,7 @@ ast_expression::do_hir(exec_list *instructions,
 
    switch (this->oper) {
    case ast_aggregate:
-      unreachable("ast_aggregate: Should never get here.");
+      UNREACHABLE("ast_aggregate: Should never get here.");
 
    case ast_assign: {
       this->subexpressions[0]->set_is_lhs(true);
@@ -2060,13 +2060,13 @@ ast_expression::do_hir(exec_list *instructions,
    }
 
    case ast_unsized_array_dim:
-      unreachable("ast_unsized_array_dim: Should never get here.");
+      UNREACHABLE("ast_unsized_array_dim: Should never get here.");
 
    case ast_function_call:
       /* Should *NEVER* get here.  ast_function_call should always be handled
        * by ast_function_expression::hir.
        */
-      unreachable("ast_function_call: handled elsewhere ");
+      UNREACHABLE("ast_function_call: handled elsewhere ");
 
    case ast_identifier: {
       /* ast_identifier can appear several places in a full abstract syntax
@@ -2299,10 +2299,10 @@ ast_expression::has_sequence_subexpression() const
       return false;
 
    case ast_function_call:
-      unreachable("should be handled by ast_function_expression::hir");
+      UNREACHABLE("should be handled by ast_function_expression::hir");
 
    case ast_unsized_array_dim:
-      unreachable("ast_unsized_array_dim: Should never get here.");
+      UNREACHABLE("ast_unsized_array_dim: Should never get here.");
    }
 
    return false;
@@ -2603,7 +2603,7 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[type_idx];
          }
          default:
-            unreachable("Unsupported sampler/image dimensionality");
+            UNREACHABLE("Unsupported sampler/image dimensionality");
          } /* sampler/image float dimensionality */
          break;
       case GLSL_TYPE_INT:
@@ -2658,7 +2658,7 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[offset + type_idx];
          }
          default:
-            unreachable("Unsupported isampler/iimage dimensionality");
+            UNREACHABLE("Unsupported isampler/iimage dimensionality");
          } /* sampler/image int dimensionality */
          break;
       case GLSL_TYPE_UINT:
@@ -2713,17 +2713,17 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[offset + type_idx];
          }
          default:
-            unreachable("Unsupported usampler/uimage dimensionality");
+            UNREACHABLE("Unsupported usampler/uimage dimensionality");
          } /* sampler/image uint dimensionality */
          break;
       default:
-         unreachable("Unsupported sampler/image type");
+         UNREACHABLE("Unsupported sampler/image type");
       } /* sampler/image type */
       break;
    } /* GLSL_TYPE_SAMPLER/GLSL_TYPE_IMAGE */
    break;
    default:
-      unreachable("Unsupported type");
+      UNREACHABLE("Unsupported type");
    } /* base type */
 
    return NULL;
@@ -5194,7 +5194,7 @@ ast_declarator_list::hir(exec_list *instructions,
             this->type->qualifier.image_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
             break;
          default:
-            unreachable("Unknown image format");
+            UNREACHABLE("Unknown image format");
          }
          this->type->qualifier.image_base_type = GLSL_TYPE_FLOAT;
       } else if (strncmp(this->type->specifier->type_name, "uimage", strlen("uimage")) == 0) {
@@ -5215,7 +5215,7 @@ ast_declarator_list::hir(exec_list *instructions,
             this->type->qualifier.image_format = PIPE_FORMAT_R32G32B32A32_UINT;
             break;
          default:
-            unreachable("Unknown image format");
+            UNREACHABLE("Unknown image format");
          }
          this->type->qualifier.image_base_type = GLSL_TYPE_UINT;
       } else if (strncmp(this->type->specifier->type_name, "iimage", strlen("iimage")) == 0) {
diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index dace84669558e..3356140b12cab 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -6862,7 +6862,7 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
          infinities.d[i] = INFINITY;
          break;
       default:
-         unreachable("unknown type");
+         UNREACHABLE("unknown type");
       }
    }
 
diff --git a/src/compiler/glsl/gl_nir_link_uniform_initializers.c b/src/compiler/glsl/gl_nir_link_uniform_initializers.c
index 272f45e6e9c8e..a4784f49ed942 100644
--- a/src/compiler/glsl/gl_nir_link_uniform_initializers.c
+++ b/src/compiler/glsl/gl_nir_link_uniform_initializers.c
@@ -172,7 +172,7 @@ copy_constant_to_storage(union gl_constant_value *storage,
             assert(!"Should not get here.");
             break;
          case GLSL_TYPE_COOPERATIVE_MATRIX:
-            unreachable("unsupported base type cooperative matrix");
+            UNREACHABLE("unsupported base type cooperative matrix");
          }
          i += dmul;
       }
diff --git a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
index baf919e77f6db..ecacc91b5327d 100644
--- a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
+++ b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
@@ -414,7 +414,7 @@ calc_blend_result(nir_builder *b,
          set_lum(b, factor, dst_rgb, src_rgb);
          break;
       case BLEND_NONE:
-         unreachable("not real cases");
+         UNREACHABLE("not real cases");
       }
 
       if (val)
diff --git a/src/compiler/glsl/gl_nir_lower_buffers.c b/src/compiler/glsl/gl_nir_lower_buffers.c
index 5058f9634bbf9..7c62ff6a2d19a 100644
--- a/src/compiler/glsl/gl_nir_lower_buffers.c
+++ b/src/compiler/glsl/gl_nir_lower_buffers.c
@@ -111,9 +111,9 @@ get_block_array_index(nir_builder *b, nir_deref_instr *deref,
     */
 
    if (use_bindings)
-      unreachable("Failed to find the block by binding");
+      UNREACHABLE("Failed to find the block by binding");
    else
-      unreachable("Failed to find the block by name");
+      UNREACHABLE("Failed to find the block by name");
 }
 
 static void
@@ -152,9 +152,9 @@ get_block_index_offset(nir_variable *var,
    }
 
    if (use_bindings)
-      unreachable("Failed to find the block by binding");
+      UNREACHABLE("Failed to find the block by binding");
    else
-      unreachable("Failed to find the block by name");
+      UNREACHABLE("Failed to find the block by name");
 }
 
 static bool
@@ -295,7 +295,7 @@ lower_buffer_interface_derefs_impl(nir_function_impl *impl,
             }
 
             case nir_intrinsic_copy_deref:
-               unreachable("copy_deref should be lowered by now");
+               UNREACHABLE("copy_deref should be lowered by now");
                break;
 
             default:
diff --git a/src/compiler/glsl/gl_nir_lower_discard_flow.c b/src/compiler/glsl/gl_nir_lower_discard_flow.c
index 5e7b93043d4ed..ef88c3269465b 100644
--- a/src/compiler/glsl/gl_nir_lower_discard_flow.c
+++ b/src/compiler/glsl/gl_nir_lower_discard_flow.c
@@ -126,7 +126,7 @@ lower_discard_flow(nir_builder *b, nir_cf_node *cf_node,
       return;
    }
    default:
-      unreachable("unknown cf node type");
+      UNREACHABLE("unknown cf node type");
    }
 }
 
diff --git a/src/compiler/glsl/gl_nir_lower_samplers_as_deref.c b/src/compiler/glsl/gl_nir_lower_samplers_as_deref.c
index 88dffcd971381..74591bfba5833 100644
--- a/src/compiler/glsl/gl_nir_lower_samplers_as_deref.c
+++ b/src/compiler/glsl/gl_nir_lower_samplers_as_deref.c
@@ -112,7 +112,7 @@ remove_struct_derefs_prep(nir_deref_instr **p, char **name,
    }
 
    default:
-      unreachable("Invalid deref type");
+      UNREACHABLE("Invalid deref type");
       break;
    }
 }
@@ -330,7 +330,7 @@ lower_intrinsic(nir_intrinsic_instr *instr,
    }
    if (instr->intrinsic == nir_intrinsic_image_deref_order ||
        instr->intrinsic == nir_intrinsic_image_deref_format)
-      unreachable("how did you even manage this?");
+      UNREACHABLE("how did you even manage this?");
 
    return false;
 }
diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index e7e39150083ec..02f237c402a64 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -659,7 +659,7 @@ mesa_stage_to_gl_stage_bit(unsigned stage)
    case MESA_SHADER_COMPUTE:
       return GL_COMPUTE_SHADER_BIT;
    default:
-      unreachable("glsl parser: invalid shader stage");
+      UNREACHABLE("glsl parser: invalid shader stage");
    }
 }
 
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 6077a6cace200..6764c03d71bcd 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -69,7 +69,7 @@ get_param_mode(ir_variable *param)
    case ir_var_shader_storage:
    case ir_var_temporary:
    default:
-      unreachable("Unsupported function param mode");
+      UNREACHABLE("Unsupported function param mode");
    }
 }
 
@@ -330,7 +330,7 @@ nir_visitor::constant_copy(ir_constant *ir, void *mem_ctx)
                break;
 
             default:
-               unreachable("Cannot get here from the first level switch");
+               UNREACHABLE("Cannot get here from the first level switch");
             }
             ret->elements[c] = col_const;
          }
@@ -352,7 +352,7 @@ nir_visitor::constant_copy(ir_constant *ir, void *mem_ctx)
             break;
 
          default:
-            unreachable("Cannot get here from the first level switch");
+            UNREACHABLE("Cannot get here from the first level switch");
          }
       }
       break;
@@ -393,7 +393,7 @@ nir_visitor::constant_copy(ir_constant *ir, void *mem_ctx)
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    return ret;
@@ -525,7 +525,7 @@ nir_visitor::visit(ir_variable *ir)
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    unsigned mem_access = 0;
@@ -590,7 +590,7 @@ nir_visitor::visit(ir_variable *ir)
       var->data.depth_layout = nir_depth_layout_unchanged;
       break;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    var->data.index = ir->data.index;
@@ -816,7 +816,7 @@ nir_visitor::visit(ir_loop_jump *ir)
       type = nir_jump_continue;
       break;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    nir_jump_instr *instr = nir_jump_instr_create(this->shader, type);
@@ -942,7 +942,7 @@ get_reduction_op(enum ir_intrinsic_id id, const glsl_type *type)
 #undef CONV_OP
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
 #undef IR_CASE
@@ -987,7 +987,7 @@ nir_visitor::visit(ir_call *ir)
          else if (ir->return_deref->type == &glsl_type_builtin_float)
              atomic_op = nir_atomic_op_fmin;
          else
-            unreachable("Invalid type");
+            UNREACHABLE("Invalid type");
          break;
       case ir_intrinsic_generic_atomic_max:
          assert(ir->return_deref);
@@ -1001,7 +1001,7 @@ nir_visitor::visit(ir_call *ir)
          else if (ir->return_deref->type == &glsl_type_builtin_float)
              atomic_op = nir_atomic_op_fmax;
          else
-            unreachable("Invalid type");
+            UNREACHABLE("Invalid type");
          break;
       case ir_intrinsic_generic_atomic_exchange:
          op = nir_intrinsic_deref_atomic;
@@ -1065,7 +1065,7 @@ nir_visitor::visit(ir_call *ir)
          else if (ir->return_deref->type == &glsl_type_builtin_uint)
             atomic_op = nir_atomic_op_umin;
          else
-            unreachable("Invalid type");
+            UNREACHABLE("Invalid type");
          break;
       case ir_intrinsic_image_atomic_max:
          op = nir_intrinsic_image_deref_atomic;
@@ -1074,7 +1074,7 @@ nir_visitor::visit(ir_call *ir)
          else if (ir->return_deref->type == &glsl_type_builtin_uint)
             atomic_op = nir_atomic_op_umax;
          else
-            unreachable("Invalid type");
+            UNREACHABLE("Invalid type");
          break;
       case ir_intrinsic_image_atomic_and:
          op = nir_intrinsic_image_deref_atomic;
@@ -1245,7 +1245,7 @@ nir_visitor::visit(ir_call *ir)
          op = nir_intrinsic_quad_swap_diagonal;
          break;
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
       nir_intrinsic_instr *instr = nir_intrinsic_instr_create(shader, op);
@@ -1531,7 +1531,7 @@ nir_visitor::visit(ir_call *ir)
             modes = nir_var_image;
             break;
          default:
-               unreachable("invalid intrinsic id for memory barrier");
+               UNREACHABLE("invalid intrinsic id for memory barrier");
          }
 
          nir_scoped_memory_barrier(&b, scope, NIR_MEMORY_ACQ_REL,
@@ -1697,7 +1697,7 @@ nir_visitor::visit(ir_call *ir)
          break;
       }
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
       if (ir->return_deref) {
@@ -1887,7 +1887,7 @@ get_instr_def(nir_instr *instr)
          return &tex_instr->def;
 
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 
    return NULL;
@@ -1985,7 +1985,7 @@ nir_visitor::visit(ir_expression *ir)
          op = nir_intrinsic_interp_deref_at_sample;
          break;
       default:
-         unreachable("Invalid interpolation intrinsic");
+         UNREACHABLE("Invalid interpolation intrinsic");
       }
 
       nir_intrinsic_instr *intrin = nir_intrinsic_instr_create(shader, op);
@@ -2245,7 +2245,7 @@ nir_visitor::visit(ir_expression *ir)
          result = nir_ifind_msb(&b, srcs[0]);
          break;
       default:
-         unreachable("Invalid type for findMSB()");
+         UNREACHABLE("Invalid type for findMSB()");
       }
       break;
    case ir_unop_find_lsb:
@@ -2404,7 +2404,7 @@ nir_visitor::visit(ir_expression *ir)
             case 3: result = nir_ball_fequal3(&b, srcs[0], srcs[1]); break;
             case 4: result = nir_ball_fequal4(&b, srcs[0], srcs[1]); break;
             default:
-               unreachable("not reached");
+               UNREACHABLE("not reached");
          }
       } else {
          switch (ir->operands[0]->type->vector_elements) {
@@ -2413,7 +2413,7 @@ nir_visitor::visit(ir_expression *ir)
             case 3: result = nir_ball_iequal3(&b, srcs[0], srcs[1]); break;
             case 4: result = nir_ball_iequal4(&b, srcs[0], srcs[1]); break;
             default:
-               unreachable("not reached");
+               UNREACHABLE("not reached");
          }
       }
       break;
@@ -2425,7 +2425,7 @@ nir_visitor::visit(ir_expression *ir)
             case 3: result = nir_bany_fnequal3(&b, srcs[0], srcs[1]); break;
             case 4: result = nir_bany_fnequal4(&b, srcs[0], srcs[1]); break;
             default:
-               unreachable("not reached");
+               UNREACHABLE("not reached");
          }
       } else {
          switch (ir->operands[0]->type->vector_elements) {
@@ -2434,7 +2434,7 @@ nir_visitor::visit(ir_expression *ir)
             case 3: result = nir_bany_inequal3(&b, srcs[0], srcs[1]); break;
             case 4: result = nir_bany_inequal4(&b, srcs[0], srcs[1]); break;
             default:
-               unreachable("not reached");
+               UNREACHABLE("not reached");
          }
       }
       break;
@@ -2492,7 +2492,7 @@ nir_visitor::visit(ir_expression *ir)
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    /* The bit-size of the NIR SSA value must match the bit-size of the
@@ -2578,7 +2578,7 @@ nir_visitor::visit(ir_texture *ir)
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    if (ir->projector != NULL)
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index f9c779d2cd65d..a5a2fa3e039f0 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -561,7 +561,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
          base = GLSL_TYPE_UINT64;
          break;
       default:
-         unreachable("Invalid base type.");
+         UNREACHABLE("Invalid base type.");
       }
 
       this->type = glsl_simple_type(base, op0->type->vector_elements, 1);
@@ -634,7 +634,7 @@ ir_expression::get_num_operands(ir_expression_operation op)
    if (op <= ir_last_quadop)
       return 4;
 
-   unreachable("Could not calculate number of operands");
+   UNREACHABLE("Could not calculate number of operands");
 }
 
 #include "ir_expression_operation_strings.h"
diff --git a/src/compiler/glsl/ir_clone.cpp b/src/compiler/glsl/ir_clone.cpp
index 665b7b06204cc..2aba20d300009 100644
--- a/src/compiler/glsl/ir_clone.cpp
+++ b/src/compiler/glsl/ir_clone.cpp
@@ -375,7 +375,7 @@ ir_constant::clone(void *mem_ctx, struct hash_table *ht) const
       break;
 
    case GLSL_TYPE_COOPERATIVE_MATRIX:
-      unreachable("unsupported base type cooperative matrix");
+      UNREACHABLE("unsupported base type cooperative matrix");
    }
 
    return NULL;
diff --git a/src/compiler/glsl/ir_constant_expression.cpp b/src/compiler/glsl/ir_constant_expression.cpp
index 25dfe7322b6f5..fb6707022a446 100644
--- a/src/compiler/glsl/ir_constant_expression.cpp
+++ b/src/compiler/glsl/ir_constant_expression.cpp
@@ -1001,7 +1001,7 @@ ir_dereference_array::constant_expression_value(void *mem_ctx,
             break;
 
          default:
-            unreachable("Matrix types are either float or double.");
+            UNREACHABLE("Matrix types are either float or double.");
          }
 
          return new(mem_ctx) ir_constant(column_type, &data);
diff --git a/src/compiler/glsl/ir_expression_operation.py b/src/compiler/glsl/ir_expression_operation.py
index 78804a34b8279..bb055db21a661 100644
--- a/src/compiler/glsl/ir_expression_operation.py
+++ b/src/compiler/glsl/ir_expression_operation.py
@@ -107,7 +107,7 @@ constant_template_common = mako.template.Template("""\
             break;
     % endfor
          default:
-            unreachable("invalid type");
+            UNREACHABLE("invalid type");
          }
       }
       break;""")
@@ -128,7 +128,7 @@ constant_template_vector_scalar = mako.template.Template("""\
             break;
     % endfor
          default:
-            unreachable("invalid type");
+            UNREACHABLE("invalid type");
          }
       }
       break;""")
@@ -163,7 +163,7 @@ constant_template_vector_scalar_mixed = mako.template.Template("""\
                     op[1]->type->base_type == ${last_sig_src_types[1].glsl_type}) {
             data.${last_sig_dst_type.union_field}[c] = ${op.get_c_expression(last_sig_src_types, ("c0", "c1", "c2"))};
          } else {
-            unreachable("invalid types");
+            UNREACHABLE("invalid types");
          }
       }
       break;""")
@@ -186,7 +186,7 @@ constant_template_mul = mako.template.Template("""\
                break;
     % endfor
             default:
-               unreachable("invalid type");
+               UNREACHABLE("invalid type");
             }
          }
       } else {
@@ -244,7 +244,7 @@ constant_template_horizontal = mako.template.Template("""\
          break;
     % endfor
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
       }
       break;""")
 
@@ -261,7 +261,7 @@ constant_template_vector_extract = mako.template.Template("""\
          break;
     % endfor
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
       }
       break;
    }""")
@@ -280,7 +280,7 @@ constant_template_vector_insert = mako.template.Template("""\
          break;
     % endfor
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
       }
       break;
    }""")
@@ -296,7 +296,7 @@ constant_template_vector = mako.template.Template("""\
             break;
     % endfor
          default:
-            unreachable("invalid type");
+            UNREACHABLE("invalid type");
          }
       }
       break;""")
@@ -317,7 +317,7 @@ constant_template_lrp = mako.template.Template("""\
             break;
     % endfor
          default:
-            unreachable("invalid type");
+            UNREACHABLE("invalid type");
          }
       }
       break;
@@ -336,7 +336,7 @@ constant_template_csel = mako.template.Template("""\
             break;
     % endfor
          default:
-            unreachable("invalid type");
+            UNREACHABLE("invalid type");
          }
       }
       break;""")
diff --git a/src/compiler/glsl/ir_print_visitor.cpp b/src/compiler/glsl/ir_print_visitor.cpp
index 90bff8e7be902..718265388fd14 100644
--- a/src/compiler/glsl/ir_print_visitor.cpp
+++ b/src/compiler/glsl/ir_print_visitor.cpp
@@ -403,7 +403,7 @@ void ir_print_visitor::visit(ir_texture *ir)
       ir->lod_info.component->accept(this);
       break;
    case ir_samples_identical:
-      unreachable("ir_samples_identical was already handled");
+      UNREACHABLE("ir_samples_identical was already handled");
    };
    fprintf(f, ")");
 }
@@ -543,7 +543,7 @@ void ir_print_visitor::visit(ir_constant *ir)
                fprintf(f, "%f", ir->value.d[i]);
             break;
 	 default:
-            unreachable("Invalid constant type");
+            UNREACHABLE("Invalid constant type");
 	 }
       }
    }
diff --git a/src/compiler/glsl/lower_jumps.cpp b/src/compiler/glsl/lower_jumps.cpp
index f4e3ac11f1c12..80bc2c0774e4f 100644
--- a/src/compiler/glsl/lower_jumps.cpp
+++ b/src/compiler/glsl/lower_jumps.cpp
@@ -492,7 +492,7 @@ retry: /* we get here if we put code after the if inside a branch */
             break;
 
          if(jump_strengths[lower] == strength_break) {
-            unreachable("no lowering of breaks any more");
+            UNREACHABLE("no lowering of breaks any more");
          } else if(jump_strengths[lower] == strength_continue) {
             /* To lower a continue, we create an execute flag (if the
              * loop doesn't have one already) and replace the continue
diff --git a/src/compiler/glsl/lower_precision.cpp b/src/compiler/glsl/lower_precision.cpp
index c2fbaee5c2cc1..e1be1c8162e47 100644
--- a/src/compiler/glsl/lower_precision.cpp
+++ b/src/compiler/glsl/lower_precision.cpp
@@ -638,7 +638,7 @@ convert_type(bool up, const glsl_type *type)
          new_base_type = GLSL_TYPE_UINT;
          break;
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
          return NULL;
       }
    } else {
@@ -653,7 +653,7 @@ convert_type(bool up, const glsl_type *type)
          new_base_type = GLSL_TYPE_UINT16;
          break;
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
          return NULL;
       }
    }
@@ -689,7 +689,7 @@ convert_precision(bool up, ir_rvalue *ir)
          op = ir_unop_u2u;
          break;
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
          return NULL;
       }
    } else {
@@ -704,7 +704,7 @@ convert_precision(bool up, ir_rvalue *ir)
          op = ir_unop_u2ump;
          break;
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
          return NULL;
       }
    }
@@ -743,7 +743,7 @@ lower_precision_visitor::handle_rvalue(ir_rvalue **rvalue)
             for (unsigned i = 0; i < ARRAY_SIZE(value.u16); i++)
                value.u16[i] = const_ir->value.u[i];
          } else {
-            unreachable("invalid type");
+            UNREACHABLE("invalid type");
          }
 
          const_ir->value = value;
@@ -1006,7 +1006,7 @@ lower_constant(ir_constant *ir)
       for (unsigned i = 0; i < ARRAY_SIZE(value.u16); i++)
          value.u16[i] = ir->value.u[i];
    } else {
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
    }
 
    ir->value = value;
diff --git a/src/compiler/glsl/opt_minmax.cpp b/src/compiler/glsl/opt_minmax.cpp
index 159e3025072cf..0c4d279c20cda 100644
--- a/src/compiler/glsl/opt_minmax.cpp
+++ b/src/compiler/glsl/opt_minmax.cpp
@@ -170,7 +170,7 @@ compare_components(ir_constant *a, ir_constant *b)
             foundequal = true;
          break;
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
    }
 
diff --git a/src/compiler/glsl_types.c b/src/compiler/glsl_types.c
index 84d51c980e883..24f84975b81b9 100644
--- a/src/compiler/glsl_types.c
+++ b/src/compiler/glsl_types.c
@@ -432,7 +432,7 @@ glsl_get_bare_type(const glsl_type *t)
       return t;
    }
 
-   unreachable("Invalid base type");
+   UNREACHABLE("Invalid base type");
 }
 
 const glsl_type *
@@ -564,7 +564,7 @@ glsl_cmat_use_to_string(enum glsl_cmat_use use)
    case GLSL_CMAT_USE_B:           return "B";
    case GLSL_CMAT_USE_ACCUMULATOR: return "ACCUMULATOR";
    default:
-      unreachable("invalid cooperative matrix use");
+      UNREACHABLE("invalid cooperative matrix use");
    }
 };
 
@@ -949,7 +949,7 @@ glsl_sampler_type(enum glsl_sampler_dim dim, bool shadow,
       return &glsl_type_builtin_error;
    }
 
-   unreachable("switch statement above should be complete");
+   UNREACHABLE("switch statement above should be complete");
 }
 
 const glsl_type *
@@ -1080,7 +1080,7 @@ glsl_texture_type(enum glsl_sampler_dim dim, bool array, enum glsl_base_type typ
       return &glsl_type_builtin_error;
    }
 
-   unreachable("switch statement above should be complete");
+   UNREACHABLE("switch statement above should be complete");
 }
 
 const glsl_type *
@@ -1252,7 +1252,7 @@ glsl_image_type(enum glsl_sampler_dim dim, bool array, enum glsl_base_type type)
       return &glsl_type_builtin_error;
    }
 
-   unreachable("switch statement above should be complete");
+   UNREACHABLE("switch statement above should be complete");
 }
 
 struct PACKED array_key {
@@ -2323,7 +2323,7 @@ glsl_get_explicit_std140_type(const glsl_type *t, bool row_major)
       free(fields);
       return type;
    } else {
-      unreachable("Invalid type for UBO or SSBO");
+      UNREACHABLE("Invalid type for UBO or SSBO");
    }
 }
 
@@ -2687,7 +2687,7 @@ glsl_get_explicit_std430_type(const glsl_type *t, bool row_major)
       free(fields);
       return type;
    } else {
-      unreachable("Invalid type for SSBO");
+      UNREACHABLE("Invalid type for SSBO");
    }
 }
 
@@ -2800,7 +2800,7 @@ glsl_get_explicit_type_for_size_align(const glsl_type *t,
                                        t->matrix_columns, stride, false,
                                        *alignment);
    } else {
-      unreachable("Unhandled type.");
+      UNREACHABLE("Unhandled type.");
    }
 }
 
@@ -2863,7 +2863,7 @@ glsl_type_replace_vec3_with_vec4(const glsl_type *t)
       free(fields);
       return type;
    } else {
-      unreachable("Unhandled type.");
+      UNREACHABLE("Unhandled type.");
    }
 }
 
@@ -3005,7 +3005,7 @@ glsl_count_dword_slots(const glsl_type *t, bool is_bindless)
    case GLSL_TYPE_VOID:
    case GLSL_TYPE_ERROR:
    default:
-      unreachable("invalid type in st_glsl_type_dword_size()");
+      UNREACHABLE("invalid type in st_glsl_type_dword_size()");
    }
 
    return 0;
@@ -3426,7 +3426,7 @@ glsl_get_sampler_dim_coordinate_components(enum glsl_sampler_dim dim)
    case GLSL_SAMPLER_DIM_CUBE:
       return 3;
    default:
-      unreachable("Unknown sampler dim");
+      UNREACHABLE("Unknown sampler dim");
    }
 }
 
@@ -3690,7 +3690,7 @@ glsl_replace_vector_type(const glsl_type *t, unsigned components)
    } else if (glsl_type_is_vector_or_scalar(t)) {
       return glsl_vector_type(t->base_type, components);
    } else {
-      unreachable("Unhandled base type glsl_replace_vector_type()");
+      UNREACHABLE("Unhandled base type glsl_replace_vector_type()");
    }
 }
 
@@ -3715,7 +3715,7 @@ glsl_channel_type(const glsl_type *t)
    case GLSL_TYPE_BOOL:
       return glsl_simple_type(t->base_type, 1, 1);
    default:
-      unreachable("Unhandled base type glsl_channel_type()");
+      UNREACHABLE("Unhandled base type glsl_channel_type()");
    }
 }
 
@@ -3798,7 +3798,7 @@ glsl_get_natural_size_align_bytes(const glsl_type *type,
    case GLSL_TYPE_SUBROUTINE:
    case GLSL_TYPE_VOID:
    case GLSL_TYPE_ERROR:
-      unreachable("type does not have a natural size");
+      UNREACHABLE("type does not have a natural size");
    }
 }
 
@@ -3860,7 +3860,7 @@ glsl_get_word_size_align_bytes(const glsl_type *type,
    case GLSL_TYPE_SUBROUTINE:
    case GLSL_TYPE_VOID:
    case GLSL_TYPE_ERROR:
-      unreachable("type does not have a natural size");
+      UNREACHABLE("type does not have a natural size");
    }
 }
 
@@ -3917,7 +3917,7 @@ glsl_get_vec4_size_align_bytes(const glsl_type *type,
    case GLSL_TYPE_SUBROUTINE:
    case GLSL_TYPE_VOID:
    case GLSL_TYPE_ERROR:
-      unreachable("type does not make sense for glsl_get_vec4_size_align_bytes()");
+      UNREACHABLE("type does not make sense for glsl_get_vec4_size_align_bytes()");
    }
 }
 
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 00db23c2a517c..626fc230ab8e1 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -203,7 +203,7 @@ glsl_base_type_get_bit_size(const enum glsl_base_type base_type)
       return 64;
 
    default:
-      unreachable("unknown base type");
+      UNREACHABLE("unknown base type");
    }
 
    return 0;
@@ -986,7 +986,7 @@ glsl_floatN_t_type(unsigned bit_size)
    case 32: return &glsl_type_builtin_float;
    case 64: return &glsl_type_builtin_double;
    default:
-      unreachable("Unsupported bit size");
+      UNREACHABLE("Unsupported bit size");
    }
 }
 
@@ -996,7 +996,7 @@ glsl_bfloatN_t_type(unsigned bit_size)
    switch (bit_size) {
    case 16: return &glsl_type_builtin_bfloat16_t;
    default:
-      unreachable("Unsupported bit size");
+      UNREACHABLE("Unsupported bit size");
    }
 }
 
@@ -1009,7 +1009,7 @@ glsl_intN_t_type(unsigned bit_size)
    case 32: return &glsl_type_builtin_int;
    case 64: return &glsl_type_builtin_int64_t;
    default:
-      unreachable("Unsupported bit size");
+      UNREACHABLE("Unsupported bit size");
    }
 }
 
@@ -1022,7 +1022,7 @@ glsl_uintN_t_type(unsigned bit_size)
    case 32: return &glsl_type_builtin_uint;
    case 64: return &glsl_type_builtin_uint64_t;
    default:
-      unreachable("Unsupported bit size");
+      UNREACHABLE("Unsupported bit size");
    }
 }
 
diff --git a/src/compiler/libcl/libcl.h b/src/compiler/libcl/libcl.h
index cf0d210cb7627..72d4eda579e7d 100644
--- a/src/compiler/libcl/libcl.h
+++ b/src/compiler/libcl/libcl.h
@@ -99,7 +99,7 @@
 /* This is the unreachable macro from macros.h that uses __builtin_unreachable,
  * which is a clang builtin available in OpenCL C.
  */
-#define unreachable(str)                                                       \
+#define UNREACHABLE(str)                                                       \
    do {                                                                        \
       assert(!"" str);                                                         \
       __builtin_unreachable();                                                 \
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 9d6970e79b5ec..c45e50befdd64 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -351,7 +351,7 @@ nir_create_variable_with_location(nir_shader *shader, nir_variable_mode mode, in
       break;
 
    default:
-      unreachable("Unsupported variable mode");
+      UNREACHABLE("Unsupported variable mode");
    }
 
    nir_variable *var = nir_variable_create(shader, mode, type, name);
@@ -370,7 +370,7 @@ nir_create_variable_with_location(nir_shader *shader, nir_variable_mode mode, in
       break;
 
    default:
-      unreachable("Unsupported variable mode");
+      UNREACHABLE("Unsupported variable mode");
    }
 
    return var;
@@ -944,7 +944,7 @@ const_value_float(double d, unsigned bit_size)
    case 32: v.f32 = d;                       break;
    case 64: v.f64 = d;                       break;
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 
@@ -965,7 +965,7 @@ const_value_int(int64_t i, unsigned bit_size)
    case 32: v.i32 = i;     break;
    case 64: v.i64 = i;     break;
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 
@@ -1005,7 +1005,7 @@ nir_alu_binop_identity(nir_op binop, unsigned bit_size)
    case nir_op_ixor:
       return const_value_int(0, bit_size);
    default:
-      unreachable("Invalid reduction operation");
+      UNREACHABLE("Invalid reduction operation");
    }
 }
 
@@ -1059,7 +1059,7 @@ reduce_cursor(nir_cursor cursor)
       return cursor;
 
    default:
-      unreachable("Inavlid cursor option");
+      UNREACHABLE("Inavlid cursor option");
    }
 }
 
@@ -1374,7 +1374,7 @@ nir_instr_def(nir_instr *instr)
       return &nir_instr_as_phi(instr)->def;
 
    case nir_instr_type_parallel_copy:
-      unreachable("Parallel copies are unsupported by this function");
+      UNREACHABLE("Parallel copies are unsupported by this function");
 
    case nir_instr_type_load_const:
       return &nir_instr_as_load_const(instr)->def;
@@ -1387,7 +1387,7 @@ nir_instr_def(nir_instr *instr)
       return NULL;
    }
 
-   unreachable("Invalid instruction type");
+   UNREACHABLE("Invalid instruction type");
 }
 
 bool
@@ -1423,7 +1423,7 @@ nir_const_value_for_float(double f, unsigned bit_size)
    case 16: v.u16 = _mesa_float_to_half(f);  break;
    case 32: v.f32 = f;                       break;
    case 64: v.f64 = f;                       break;
-   default: unreachable("Invalid bit size");
+   default: UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 
@@ -1438,7 +1438,7 @@ nir_const_value_as_float(nir_const_value value, unsigned bit_size)
    case 16: return _mesa_half_to_float(value.u16);
    case 32: return value.f32;
    case 64: return value.f64;
-   default: unreachable("Invalid bit size");
+   default: UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 }
@@ -1840,7 +1840,7 @@ nir_block_cf_tree_next(nir_block *block)
    }
 
    default:
-      unreachable("unknown cf node type");
+      UNREACHABLE("unknown cf node type");
    }
 }
 
@@ -1882,7 +1882,7 @@ nir_block_cf_tree_prev(nir_block *block)
    }
 
    default:
-      unreachable("unknown cf node type");
+      UNREACHABLE("unknown cf node type");
    }
 }
 
@@ -1910,7 +1910,7 @@ nir_cf_node_cf_tree_first(nir_cf_node *node)
    }
 
    default:
-      unreachable("unknown node type");
+      UNREACHABLE("unknown node type");
    }
 }
 
@@ -1941,7 +1941,7 @@ nir_cf_node_cf_tree_last(nir_cf_node *node)
    }
 
    default:
-      unreachable("unknown node type");
+      UNREACHABLE("unknown node type");
    }
 }
 
@@ -2157,7 +2157,7 @@ cursor_next_instr(nir_cursor cursor)
       return cursor_next_instr(cursor);
    }
 
-   unreachable("Inavlid cursor option");
+   UNREACHABLE("Inavlid cursor option");
 }
 
 bool
@@ -2607,7 +2607,7 @@ nir_system_value_from_intrinsic(nir_intrinsic_op intrin)
    case nir_intrinsic_load_sm_id_nv:
       return SYSTEM_VALUE_SM_ID_NV;
    default:
-      unreachable("intrinsic doesn't produce a system value");
+      UNREACHABLE("intrinsic doesn't produce a system value");
    }
 }
 
@@ -2656,7 +2656,7 @@ nir_rewrite_image_intrinsic(nir_intrinsic_instr *intrin, nir_def *src,
       CASE(store_block_agx)
 #undef CASE
    default:
-      unreachable("Unhanded image intrinsic");
+      UNREACHABLE("Unhanded image intrinsic");
    }
 
    if (nir_src_as_deref(intrin->src[0])) {
@@ -2781,7 +2781,7 @@ nir_get_shader_call_payload_src(nir_intrinsic_instr *call)
    case nir_intrinsic_rt_execute_callable:
       return &call->src[1];
    default:
-      unreachable("Not a call intrinsic");
+      UNREACHABLE("Not a call intrinsic");
       return NULL;
    }
 }
@@ -2979,7 +2979,7 @@ nir_get_nir_type_for_glsl_base_type(enum glsl_base_type base_type)
       return nir_type_invalid;
    }
 
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 enum glsl_base_type
@@ -2999,7 +2999,7 @@ nir_get_glsl_base_type_for_nir_type(nir_alu_type base_type)
    case nir_type_float32:  return GLSL_TYPE_FLOAT;
    case nir_type_float16:  return GLSL_TYPE_FLOAT16;
    case nir_type_float64:  return GLSL_TYPE_DOUBLE;
-   default: unreachable("Not a sized nir_alu_type");
+   default: UNREACHABLE("Not a sized nir_alu_type");
    }
    /* clang-format on */
 }
@@ -3016,7 +3016,7 @@ nir_op_vec(unsigned num_components)
    case  5: return nir_op_vec5;
    case  8: return nir_op_vec8;
    case 16: return nir_op_vec16;
-   default: unreachable("bad component count");
+   default: UNREACHABLE("bad component count");
    }
    /* clang-format on */
 }
@@ -3254,7 +3254,7 @@ nir_tex_instr_result_size(const nir_tex_instr *instr)
          ret = 3;
          break;
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
       if (instr->is_array)
          ret++;
@@ -3327,7 +3327,7 @@ nir_tex_instr_is_query(const nir_tex_instr *instr)
    case nir_texop_fragment_fetch_amd:
       return false;
    default:
-      unreachable("Invalid texture opcode");
+      UNREACHABLE("Invalid texture opcode");
    }
 }
 
@@ -3406,10 +3406,10 @@ nir_tex_instr_src_type(const nir_tex_instr *instr, unsigned src)
       return nir_type_uint;
 
    case nir_num_tex_src_types:
-      unreachable("nir_num_tex_src_types is not a valid source type");
+      UNREACHABLE("nir_num_tex_src_types is not a valid source type");
    }
 
-   unreachable("Invalid texture source type");
+   UNREACHABLE("Invalid texture source type");
 }
 
 unsigned
@@ -3704,5 +3704,5 @@ nir_atomic_op_to_alu(nir_atomic_op op)
       return nir_num_opcodes;
    }
 
-   unreachable("Invalid nir_atomic_op");
+   UNREACHABLE("Invalid nir_atomic_op");
 }
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index a30d7ea89d19e..e658c28f95fa1 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -266,7 +266,7 @@ nir_const_value_for_raw_uint(uint64_t x, unsigned bit_size)
    case 32: v.u32 = (uint32_t)x;  break;
    case 64: v.u64 = x;  break;
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 
@@ -317,7 +317,7 @@ nir_const_value_as_int(nir_const_value value, unsigned bit_size)
    case 32: return value.i32;
    case 64: return value.i64;
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 }
@@ -333,7 +333,7 @@ nir_const_value_as_uint(nir_const_value value, unsigned bit_size)
    case 32: return value.u32;
    case 64: return value.u64;
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
    /* clang-format on */
 }
@@ -1274,7 +1274,7 @@ nir_atomic_op_type(nir_atomic_op op)
       return nir_type_uint;
    }
 
-   unreachable("Invalid nir_atomic_op");
+   UNREACHABLE("Invalid nir_atomic_op");
 }
 
 nir_op
@@ -6351,7 +6351,7 @@ nir_deref_count_slots(nir_deref_instr *deref, nir_variable *var)
       case nir_deref_type_var:
          return nir_variable_count_slots(var, deref->type);
       default:
-         unreachable("illegal deref type");
+         UNREACHABLE("illegal deref type");
       }
    }
    return glsl_count_attribute_slots(deref->type, false);
diff --git a/src/compiler/nir/nir_builder.c b/src/compiler/nir/nir_builder.c
index 920d51fa9a426..dda5b796b848a 100644
--- a/src/compiler/nir/nir_builder.c
+++ b/src/compiler/nir/nir_builder.c
@@ -593,7 +593,7 @@ nir_compare_func(nir_builder *b, enum compare_func func,
    case COMPARE_FUNC_LEQUAL:
       return nir_fge(b, src1, src0);
    }
-   unreachable("bad compare func");
+   UNREACHABLE("bad compare func");
 }
 
 nir_def *
@@ -635,7 +635,7 @@ nir_type_convert(nir_builder *b,
             opcode = nir_op_fneu32;
             break;
          default:
-            unreachable("Invalid Boolean size.");
+            UNREACHABLE("Invalid Boolean size.");
          }
       } else {
          assert(src_base == nir_type_int || src_base == nir_type_uint);
@@ -654,7 +654,7 @@ nir_type_convert(nir_builder *b,
             opcode = nir_op_ine32;
             break;
          default:
-            unreachable("Invalid Boolean size.");
+            UNREACHABLE("Invalid Boolean size.");
          }
       }
 
diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index 9dbb03f0bffe5..76efcd9624775 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -748,7 +748,7 @@ nir_fdot(nir_builder *build, nir_def *src0, nir_def *src1)
    case 16:
       return nir_fdot16(build, src0, src1);
    default:
-      unreachable("bad component size");
+      UNREACHABLE("bad component size");
    }
 
    return NULL;
@@ -774,7 +774,7 @@ nir_bfdot(nir_builder *build, nir_def *src0, nir_def *src1)
    case 16:
       return nir_bfdot16(build, src0, src1);
    default:
-      unreachable("bad component size");
+      UNREACHABLE("bad component size");
    }
 
    return NULL;
@@ -799,7 +799,7 @@ nir_ball_iequal(nir_builder *b, nir_def *src0, nir_def *src1)
    case 16:
       return nir_ball_iequal16(b, src0, src1);
    default:
-      unreachable("bad component size");
+      UNREACHABLE("bad component size");
    }
 }
 
@@ -828,7 +828,7 @@ nir_bany_inequal(nir_builder *b, nir_def *src0, nir_def *src1)
    case 16:
       return nir_bany_inequal16(b, src0, src1);
    default:
-      unreachable("bad component size");
+      UNREACHABLE("bad component size");
    }
 }
 
@@ -1823,7 +1823,7 @@ nir_build_deref_follower(nir_builder *b, nir_deref_instr *parent,
 
    switch (leader->deref_type) {
    case nir_deref_type_var:
-      unreachable("A var dereference cannot have a parent");
+      UNREACHABLE("A var dereference cannot have a parent");
       break;
 
    case nir_deref_type_array:
@@ -1868,7 +1868,7 @@ nir_build_deref_follower(nir_builder *b, nir_deref_instr *parent,
    }
 
    default:
-      unreachable("Invalid deref instruction type");
+      UNREACHABLE("Invalid deref instruction type");
    }
    return NULL;
 }
diff --git a/src/compiler/nir/nir_clone.c b/src/compiler/nir/nir_clone.c
index 857ab6c617629..bcf0cafab6b69 100644
--- a/src/compiler/nir/nir_clone.c
+++ b/src/compiler/nir/nir_clone.c
@@ -331,7 +331,7 @@ clone_deref_instr(clone_state *state, const nir_deref_instr *deref)
       break;
 
    default:
-      unreachable("Invalid instruction deref type");
+      UNREACHABLE("Invalid instruction deref type");
    }
 
    return nderef;
@@ -501,15 +501,15 @@ clone_instr(clone_state *state, const nir_instr *instr)
    case nir_instr_type_tex:
       return &clone_tex(state, nir_instr_as_tex(instr))->instr;
    case nir_instr_type_phi:
-      unreachable("Cannot clone phis with clone_instr");
+      UNREACHABLE("Cannot clone phis with clone_instr");
    case nir_instr_type_jump:
       return &clone_jump(state, nir_instr_as_jump(instr))->instr;
    case nir_instr_type_call:
       return &clone_call(state, nir_instr_as_call(instr))->instr;
    case nir_instr_type_parallel_copy:
-      unreachable("Cannot clone parallel copies");
+      UNREACHABLE("Cannot clone parallel copies");
    default:
-      unreachable("bad instr type");
+      UNREACHABLE("bad instr type");
       return NULL;
    }
 }
@@ -623,7 +623,7 @@ clone_cf_list(clone_state *state, struct exec_list *dst,
          clone_loop(state, dst, nir_cf_node_as_loop(cf));
          break;
       default:
-         unreachable("bad cf type");
+         UNREACHABLE("bad cf type");
       }
    }
 }
diff --git a/src/compiler/nir/nir_constant_expressions.py b/src/compiler/nir/nir_constant_expressions.py
index 794f79ec40c02..01b1fb2c8880d 100644
--- a/src/compiler/nir/nir_constant_expressions.py
+++ b/src/compiler/nir/nir_constant_expressions.py
@@ -588,7 +588,7 @@ evaluate_${name}(nir_const_value *_dst_val,
       % endfor
 
       default:
-         unreachable("unknown bit width");
+         UNREACHABLE("unknown bit width");
       }
    % else:
       ${evaluate_op(op, 0, execution_mode)}
@@ -614,7 +614,7 @@ nir_eval_const_opcode(nir_op op, nir_const_value *dest,
       return;
 % endfor
    default:
-      unreachable("shouldn't get here");
+      UNREACHABLE("shouldn't get here");
    }
 }"""
 
diff --git a/src/compiler/nir/nir_control_flow.c b/src/compiler/nir/nir_control_flow.c
index 9e3099e797339..3adce4f5f1223 100644
--- a/src/compiler/nir/nir_control_flow.c
+++ b/src/compiler/nir/nir_control_flow.c
@@ -392,7 +392,7 @@ split_block_cursor(nir_cursor cursor,
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    if (_before)
@@ -527,7 +527,7 @@ nir_handle_add_jump(nir_block *block)
       break;
 
    default:
-      unreachable("Invalid jump type");
+      UNREACHABLE("Invalid jump type");
    }
 }
 
@@ -701,7 +701,7 @@ cleanup_cf_node(nir_cf_node *node, nir_function_impl *impl)
       break;
    }
    default:
-      unreachable("Invalid CF node type");
+      UNREACHABLE("Invalid CF node type");
    }
 }
 
@@ -813,10 +813,10 @@ relink_jump_halt_cf_node(nir_cf_node *node, nir_block *end_block)
    }
 
    case nir_cf_node_function:
-      unreachable("Cannot insert a function in a function");
+      UNREACHABLE("Cannot insert a function in a function");
 
    default:
-      unreachable("Invalid CF node type");
+      UNREACHABLE("Invalid CF node type");
    }
 }
 
diff --git a/src/compiler/nir/nir_conversion_builder.h b/src/compiler/nir/nir_conversion_builder.h
index 680217a5abedc..adf43811825d1 100644
--- a/src/compiler/nir/nir_conversion_builder.h
+++ b/src/compiler/nir/nir_conversion_builder.h
@@ -50,7 +50,7 @@ nir_round_float_to_int(nir_builder *b, nir_def *src,
    case nir_rounding_mode_rtz:
       break;
    }
-   unreachable("unexpected rounding mode");
+   UNREACHABLE("unexpected rounding mode");
 }
 
 static inline nir_def *
@@ -102,7 +102,7 @@ nir_round_float_to_float(nir_builder *b, nir_def *src,
    case nir_rounding_mode_undef:
       break;
    }
-   unreachable("unexpected rounding mode");
+   UNREACHABLE("unexpected rounding mode");
 }
 
 static inline nir_def *
@@ -126,7 +126,7 @@ nir_round_int_to_float(nir_builder *b, nir_def *src,
       mantissa_bits = 52;
       break;
    default:
-      unreachable("Unsupported bit size");
+      UNREACHABLE("Unsupported bit size");
    }
 
    if (src->bit_size < mantissa_bits)
@@ -160,7 +160,7 @@ nir_round_int_to_float(nir_builder *b, nir_def *src,
       case nir_rounding_mode_undef:
          break;
       }
-      unreachable("unexpected rounding mode");
+      UNREACHABLE("unexpected rounding mode");
    } else {
       nir_def *mantissa_bit_size = nir_imm_int(b, mantissa_bits);
       nir_def *msb = nir_imax(b, nir_ufind_msb(b, src), mantissa_bit_size);
@@ -181,7 +181,7 @@ nir_round_int_to_float(nir_builder *b, nir_def *src,
       case nir_rounding_mode_undef:
          break;
       }
-      unreachable("unexpected rounding mode");
+      UNREACHABLE("unexpected rounding mode");
    }
 }
 
@@ -297,7 +297,7 @@ nir_get_clamp_limits(nir_builder *b,
          fhigh = DBL_MAX;
          break;
       default:
-         unreachable("Unhandled bit size");
+         UNREACHABLE("Unhandled bit size");
       }
 
       switch (src_base_type) {
@@ -327,12 +327,12 @@ nir_get_clamp_limits(nir_builder *b,
          *high = nir_imm_floatN_t(b, fhigh, src_bit_size);
          break;
       default:
-         unreachable("Clamping from unknown type");
+         UNREACHABLE("Clamping from unknown type");
       }
       break;
    }
    default:
-      unreachable("clamping to unknown type");
+      UNREACHABLE("clamping to unknown type");
       break;
    }
 }
@@ -376,7 +376,7 @@ nir_clamp_to_type_range(nir_builder *b,
       high_cond = high ? nir_fge(b, src, high) : NULL;
       break;
    default:
-      unreachable("clamping from unknown type");
+      UNREACHABLE("clamping from unknown type");
    }
 
    nir_def *val_low = low, *val_high = high;
diff --git a/src/compiler/nir/nir_deref.c b/src/compiler/nir/nir_deref.c
index 9726e6c7d3cd0..71f7bc6247539 100644
--- a/src/compiler/nir/nir_deref.c
+++ b/src/compiler/nir/nir_deref.c
@@ -237,7 +237,7 @@ nir_deref_instr_has_complex_use(nir_deref_instr *deref,
          default:
             return true;
          }
-         unreachable("Switch default failed");
+         UNREACHABLE("Switch default failed");
       }
 
       default:
@@ -332,7 +332,7 @@ nir_deref_instr_get_const_offset(nir_deref_instr *deref,
          /* A cast doesn't contribute to the offset */
          break;
       default:
-         unreachable("Unsupported deref type");
+         UNREACHABLE("Unsupported deref type");
       }
    }
 
@@ -371,7 +371,7 @@ nir_build_deref_offset(nir_builder *b, nir_deref_instr *deref,
          /* A cast doesn't contribute to the offset */
          break;
       default:
-         unreachable("Unsupported deref type");
+         UNREACHABLE("Unsupported deref type");
       }
    }
 
@@ -475,7 +475,7 @@ nir_fixup_deref_types_instr(UNUSED struct nir_builder *b, nir_instr *instr, UNUS
    } else if (deref->deref_type == nir_deref_type_cast) {
       return false;
    } else {
-      unreachable("Unsupported deref type");
+      UNREACHABLE("Unsupported deref type");
    }
 
    if (deref->type == parent_derived_type)
@@ -606,7 +606,7 @@ compare_deref_paths(nir_deref_path *a_path, nir_deref_path *b_path,
       }
 
       default:
-         unreachable("Invalid deref type");
+         UNREACHABLE("Invalid deref type");
       }
    }
 
@@ -832,7 +832,7 @@ rematerialize_deref_in_block(nir_deref_instr *deref,
       break;
 
    default:
-      unreachable("Invalid deref instruction type");
+      UNREACHABLE("Invalid deref instruction type");
    }
 
    nir_def_init(&new_deref->instr, &new_deref->def,
@@ -931,7 +931,7 @@ nir_deref_instr_fixup_child_types(nir_deref_instr *parent)
       nir_deref_instr *child = nir_instr_as_deref(nir_src_parent_instr(use));
       switch (child->deref_type) {
       case nir_deref_type_var:
-         unreachable("nir_deref_type_var cannot be a child");
+         UNREACHABLE("nir_deref_type_var cannot be a child");
 
       case nir_deref_type_array:
       case nir_deref_type_array_wildcard:
diff --git a/src/compiler/nir/nir_divergence_analysis.c b/src/compiler/nir/nir_divergence_analysis.c
index 88f36250c10b5..1716b8207b87c 100644
--- a/src/compiler/nir/nir_divergence_analysis.c
+++ b/src/compiler/nir/nir_divergence_analysis.c
@@ -433,7 +433,7 @@ visit_intrinsic(nir_intrinsic_instr *instr, struct divergence_state *state)
           */
          break;
       default:
-         unreachable("Invalid stage for load_output");
+         UNREACHABLE("Invalid stage for load_output");
       }
       break;
    case nir_intrinsic_load_per_view_output:
@@ -496,7 +496,7 @@ visit_intrinsic(nir_intrinsic_instr *instr, struct divergence_state *state)
                stage == MESA_SHADER_INTERSECTION)
          is_divergent = true;
       else
-         unreachable("Invalid stage for load_primitive_id");
+         UNREACHABLE("Invalid stage for load_primitive_id");
       break;
    case nir_intrinsic_load_tess_level_inner:
    case nir_intrinsic_load_tess_level_outer:
@@ -505,7 +505,7 @@ visit_intrinsic(nir_intrinsic_instr *instr, struct divergence_state *state)
       else if (stage == MESA_SHADER_TESS_EVAL)
          is_divergent = !(options & nir_divergence_single_patch_per_tes_subgroup);
       else
-         unreachable("Invalid stage for load_primitive_tess_level_*");
+         UNREACHABLE("Invalid stage for load_primitive_tess_level_*");
       break;
 
    case nir_intrinsic_load_workgroup_index:
@@ -966,7 +966,7 @@ visit_intrinsic(nir_intrinsic_instr *instr, struct divergence_state *state)
       break;
 #else
       nir_print_instr(&instr->instr, stderr);
-      unreachable("\nNIR divergence analysis: Unhandled intrinsic.");
+      UNREACHABLE("\nNIR divergence analysis: Unhandled intrinsic.");
 #endif
    }
 
@@ -1131,11 +1131,11 @@ visit_jump(nir_jump_instr *jump, struct divergence_state *state)
       /* This totally kills invocations so it doesn't add divergence */
       break;
    case nir_jump_return:
-      unreachable("NIR divergence analysis: Unsupported return instruction.");
+      UNREACHABLE("NIR divergence analysis: Unsupported return instruction.");
       break;
    case nir_jump_goto:
    case nir_jump_goto_if:
-      unreachable("NIR divergence analysis: Unsupported goto_if instruction.");
+      UNREACHABLE("NIR divergence analysis: Unsupported goto_if instruction.");
       break;
    }
    return false;
@@ -1173,7 +1173,7 @@ instr_is_loop_invariant(nir_instr *instr, struct divergence_state *state)
    case nir_instr_type_phi:
    case nir_instr_type_parallel_copy:
    default:
-      unreachable("NIR divergence analysis: Unsupported instruction type.");
+      UNREACHABLE("NIR divergence analysis: Unsupported instruction type.");
    }
 }
 
@@ -1199,7 +1199,7 @@ update_instr_divergence(nir_instr *instr, struct divergence_state *state)
    case nir_instr_type_phi:
    case nir_instr_type_parallel_copy:
    default:
-      unreachable("NIR divergence analysis: Unsupported instruction type.");
+      UNREACHABLE("NIR divergence analysis: Unsupported instruction type.");
    }
 }
 
@@ -1474,7 +1474,7 @@ visit_cf_list(struct exec_list *list, struct divergence_state *state)
          has_changed |= visit_loop(nir_cf_node_as_loop(node), state);
          break;
       case nir_cf_node_function:
-         unreachable("NIR divergence analysis: Unsupported cf_node type.");
+         UNREACHABLE("NIR divergence analysis: Unsupported cf_node type.");
       }
    }
 
diff --git a/src/compiler/nir/nir_format_convert.c b/src/compiler/nir/nir_format_convert.c
index 0db54aa1a56f0..39856cae458d9 100644
--- a/src/compiler/nir/nir_format_convert.c
+++ b/src/compiler/nir/nir_format_convert.c
@@ -223,7 +223,7 @@ _nir_format_norm_factor(nir_builder *b, const unsigned *bits,
          factor[i].f64 = (1ull << (bits[i] - is_signed)) - 1;
          break;
       default:
-         unreachable("invalid bit size");
+         UNREACHABLE("invalid bit size");
          break;
       }
    }
@@ -603,7 +603,7 @@ nir_format_unpack_rgba(nir_builder *b, nir_def *packed,
          break;
 
       case UTIL_FORMAT_TYPE_FIXED:
-         unreachable("Fixed formats not supported");
+         UNREACHABLE("Fixed formats not supported");
 
       case UTIL_FORMAT_TYPE_FLOAT:
          switch (chan->size) {
@@ -616,12 +616,12 @@ nir_format_unpack_rgba(nir_builder *b, nir_def *packed,
             break;
 
          default:
-            unreachable("Unknown number of float bits");
+            UNREACHABLE("Unknown number of float bits");
          }
          break;
 
       default:
-         unreachable("Unknown format channel type");
+         UNREACHABLE("Unknown format channel type");
       }
    }
 
@@ -651,7 +651,7 @@ nir_format_unpack_rgba(nir_builder *b, nir_def *packed,
          break;
 
       default:
-         unreachable("Unknown swizzle");
+         UNREACHABLE("Unknown swizzle");
       }
    }
    nir_def *rgba = nir_vec(b, swiz_comps, 4);
@@ -750,7 +750,7 @@ nir_format_pack_rgba(nir_builder *b, enum pipe_format format, nir_def *rgba)
          break;
 
       case UTIL_FORMAT_TYPE_FIXED:
-         unreachable("Fixed formats not supported");
+         UNREACHABLE("Fixed formats not supported");
 
       case UTIL_FORMAT_TYPE_FLOAT:
          switch (chan->size) {
@@ -763,12 +763,12 @@ nir_format_pack_rgba(nir_builder *b, enum pipe_format format, nir_def *rgba)
             break;
 
          default:
-            unreachable("Unknown number of float bits");
+            UNREACHABLE("Unknown number of float bits");
          }
          break;
 
       default:
-         unreachable("Unknown format channel type");
+         UNREACHABLE("Unknown format channel type");
       }
    }
    nir_def *encoded = nir_vec(b, comps, desc->nr_channels);
diff --git a/src/compiler/nir/nir_gather_info.c b/src/compiler/nir/nir_gather_info.c
index 76688989b020b..c555a1219d455 100644
--- a/src/compiler/nir/nir_gather_info.c
+++ b/src/compiler/nir/nir_gather_info.c
@@ -93,7 +93,7 @@ get_deref_info(nir_shader *shader, nir_variable *var, nir_deref_instr *deref,
              * to direct deref at a later point.
              */
          } else {
-            unreachable("Unsupported deref type");
+            UNREACHABLE("Unsupported deref type");
          }
       }
    }
diff --git a/src/compiler/nir/nir_gather_output_deps.c b/src/compiler/nir/nir_gather_output_deps.c
index e0df801134bc5..2fa689b8c7f10 100644
--- a/src/compiler/nir/nir_gather_output_deps.c
+++ b/src/compiler/nir/nir_gather_output_deps.c
@@ -207,7 +207,7 @@ nir_gather_output_dependencies(nir_shader *nir, nir_output_deps *deps)
                break;
             }
             default:
-               unreachable("unexpected jump type");
+               UNREACHABLE("unexpected jump type");
             }
             break;
 
diff --git a/src/compiler/nir/nir_gather_tcs_info.c b/src/compiler/nir/nir_gather_tcs_info.c
index ea7816d197fac..dd0098cd39281 100644
--- a/src/compiler/nir/nir_gather_tcs_info.c
+++ b/src/compiler/nir/nir_gather_tcs_info.c
@@ -183,7 +183,7 @@ scan_cf_list_defined_by_all_invocs(struct exec_list *cf_list,
          break;
       }
       default:
-         unreachable("unknown cf node type");
+         UNREACHABLE("unknown cf node type");
       }
    }
 }
@@ -287,7 +287,7 @@ scan_cf_list_for_invoc0(struct exec_list *cf_list,
          break;
       }
       default:
-         unreachable("unknown cf node type");
+         UNREACHABLE("unknown cf node type");
       }
    }
 }
diff --git a/src/compiler/nir/nir_gather_types.c b/src/compiler/nir/nir_gather_types.c
index 69acc23b91a6e..8c55e4008e586 100644
--- a/src/compiler/nir/nir_gather_types.c
+++ b/src/compiler/nir/nir_gather_types.c
@@ -50,7 +50,7 @@ set_type(unsigned idx, nir_alu_type type, BITSET_WORD *float_types,
       break;
 
    default:
-      unreachable("Invalid base nir_alu_type");
+      UNREACHABLE("Invalid base nir_alu_type");
    }
 }
 
diff --git a/src/compiler/nir/nir_inline_helpers.h b/src/compiler/nir/nir_inline_helpers.h
index 0180cb6979dff..4022a78da1ed4 100644
--- a/src/compiler/nir/nir_inline_helpers.h
+++ b/src/compiler/nir/nir_inline_helpers.h
@@ -37,7 +37,7 @@ _nir_foreach_def(nir_instr *instr, nir_foreach_def_cb cb, void *state)
       return true;
 
    default:
-      unreachable("Invalid instruction type");
+      UNREACHABLE("Invalid instruction type");
    }
 }
 
@@ -139,7 +139,7 @@ nir_foreach_src(nir_instr *instr, nir_foreach_src_cb cb, void *state)
       return true;
 
    default:
-      unreachable("Invalid instruction type");
+      UNREACHABLE("Invalid instruction type");
       break;
    }
 
diff --git a/src/compiler/nir/nir_instr_set.c b/src/compiler/nir/nir_instr_set.c
index c0218299850f9..b55ba03b0b3bd 100644
--- a/src/compiler/nir/nir_instr_set.c
+++ b/src/compiler/nir/nir_instr_set.c
@@ -80,7 +80,7 @@ instr_can_rewrite(const nir_instr *instr)
       return false;
    case nir_instr_type_parallel_copy:
    default:
-      unreachable("Invalid instruction type");
+      UNREACHABLE("Invalid instruction type");
    }
 
    return false;
@@ -187,7 +187,7 @@ hash_deref(uint32_t hash, const nir_deref_instr *instr)
       break;
 
    default:
-      unreachable("Invalid instruction deref type");
+      UNREACHABLE("Invalid instruction deref type");
    }
 
    return hash;
@@ -339,7 +339,7 @@ hash_instr(const void *data)
       hash = hash_tex(hash, nir_instr_as_tex(instr));
       break;
    default:
-      unreachable("Invalid instruction type");
+      UNREACHABLE("Invalid instruction type");
    }
 
    return hash;
@@ -643,7 +643,7 @@ nir_instrs_equal(const nir_instr *instr1, const nir_instr *instr2)
          break;
 
       default:
-         unreachable("Invalid instruction deref type");
+         UNREACHABLE("Invalid instruction deref type");
       }
       return true;
    }
@@ -759,10 +759,10 @@ nir_instrs_equal(const nir_instr *instr1, const nir_instr *instr2)
    case nir_instr_type_undef:
    case nir_instr_type_parallel_copy:
    default:
-      unreachable("Invalid instruction type");
+      UNREACHABLE("Invalid instruction type");
    }
 
-   unreachable("All cases in the above switch should return");
+   UNREACHABLE("All cases in the above switch should return");
 }
 
 static bool
diff --git a/src/compiler/nir/nir_linking_helpers.c b/src/compiler/nir/nir_linking_helpers.c
index af6069c98abd2..ddf6c22f6c460 100644
--- a/src/compiler/nir/nir_linking_helpers.c
+++ b/src/compiler/nir/nir_linking_helpers.c
@@ -1227,7 +1227,7 @@ nir_clone_deref_instr(nir_builder *b, nir_variable *var,
    case nir_deref_type_struct:
       return nir_build_deref_struct(b, parent, deref->strct.index);
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
       return NULL;
    }
 }
diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index 6ff87aad34413..33bab84d07220 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -672,7 +672,7 @@ invert_comparison_if_needed(nir_op alu_op, bool invert)
    case nir_op_ine:
       return nir_op_ieq;
    default:
-      unreachable("Unsuported comparison!");
+      UNREACHABLE("Unsuported comparison!");
    }
 }
 
@@ -830,7 +830,7 @@ test_iterations(int32_t iter_int, nir_const_value step,
       add_op = nir_op_iadd;
       break;
    default:
-      unreachable("Unhandled induction variable base type!");
+      UNREACHABLE("Unhandled induction variable base type!");
    }
 
    /* Multiple the iteration count we are testing by the number of times we
@@ -938,7 +938,7 @@ calculate_iterations(nir_scalar basis, nir_scalar limit_basis,
                                      limit_basis, limit, invert_cond,
                                      execution_mode, max_unroll_iterations);
    default:
-      unreachable("Invalid induction variable increment operation.");
+      UNREACHABLE("Invalid induction variable increment operation.");
    }
 
    /* If iter_int is negative the loop is ill-formed or is the conditional is
@@ -1415,7 +1415,7 @@ process_loops(nir_cf_node *cf_node, nir_variable_mode indirect_mask,
       break;
    }
    default:
-      unreachable("unknown cf node type");
+      UNREACHABLE("unknown cf node type");
    }
 
    nir_loop *loop = nir_cf_node_as_loop(cf_node);
diff --git a/src/compiler/nir/nir_loop_analyze.h b/src/compiler/nir/nir_loop_analyze.h
index f8a5986c9120e..8750731d51d35 100644
--- a/src/compiler/nir/nir_loop_analyze.h
+++ b/src/compiler/nir/nir_loop_analyze.h
@@ -67,7 +67,7 @@ contains_other_jump(nir_cf_node *node, nir_instr *expected_jump)
       return false;
 
    default:
-      unreachable("Unhandled cf node type");
+      UNREACHABLE("Unhandled cf node type");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_alu_width.c b/src/compiler/nir/nir_lower_alu_width.c
index 1bca5be4d8059..03857ecedffe1 100644
--- a/src/compiler/nir/nir_lower_alu_width.c
+++ b/src/compiler/nir/nir_lower_alu_width.c
@@ -137,7 +137,7 @@ will_lower_ffma(nir_shader *shader, unsigned bit_size)
    case 64:
       return shader->options->lower_ffma64;
    }
-   unreachable("bad bit size");
+   UNREACHABLE("bad bit size");
 }
 
 static nir_def *
diff --git a/src/compiler/nir/nir_lower_atomics.c b/src/compiler/nir/nir_lower_atomics.c
index 1d42b4e74e229..a5c1d4b7881bd 100644
--- a/src/compiler/nir/nir_lower_atomics.c
+++ b/src/compiler/nir/nir_lower_atomics.c
@@ -66,7 +66,7 @@ build_atomic(nir_builder *b, nir_intrinsic_instr *intr)
                              1, intr->def.bit_size);
       break;
    default:
-      unreachable("unsupported atomic type");
+      UNREACHABLE("unsupported atomic type");
    }
 
    nir_def *data = intr->intrinsic == nir_intrinsic_ssbo_atomic ? intr->src[2].ssa : intr->src[1].ssa;
@@ -103,7 +103,7 @@ build_atomic(nir_builder *b, nir_intrinsic_instr *intr)
                                        .atomic_op = nir_atomic_op_cmpxchg);
          break;
       default:
-         unreachable("unsupported atomic type");
+         UNREACHABLE("unsupported atomic type");
       }
       nir_break_if(b, nir_ieq(b, xchg, before));
       nir_phi_instr_add_src(phi, nir_loop_last_block(loop), xchg);
@@ -147,7 +147,7 @@ lower_atomics(struct nir_builder *b, nir_intrinsic_instr *intr,
       return false;
    case nir_atomic_op_fcmpxchg: /* unimplemented */
    default:
-      unreachable("Invalid nir_atomic_op");
+      UNREACHABLE("Invalid nir_atomic_op");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_bit_size.c b/src/compiler/nir/nir_lower_bit_size.c
index 8a73053ed647e..91214d25c8e24 100644
--- a/src/compiler/nir/nir_lower_bit_size.c
+++ b/src/compiler/nir/nir_lower_bit_size.c
@@ -280,7 +280,7 @@ lower_intrinsic_instr(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Unsupported instruction");
+      UNREACHABLE("Unsupported instruction");
    }
 }
 
@@ -340,7 +340,7 @@ lower_impl(nir_function_impl *impl,
             break;
 
          default:
-            unreachable("Unsupported instruction type");
+            UNREACHABLE("Unsupported instruction type");
          }
          progress = true;
       }
diff --git a/src/compiler/nir/nir_lower_blend.c b/src/compiler/nir/nir_lower_blend.c
index adc5a2d8f798b..10f50d89513e5 100644
--- a/src/compiler/nir/nir_lower_blend.c
+++ b/src/compiler/nir/nir_lower_blend.c
@@ -63,7 +63,7 @@ nir_blend_func(
       return nir_fmax(b, src, dst);
    }
 
-   unreachable("Invalid blend function");
+   UNREACHABLE("Invalid blend function");
 }
 
 /* Does this blend function multiply by a blend factor? */
@@ -128,7 +128,7 @@ nir_blend_factor_value(
       return nir_alpha_saturate(b, src, dst, chan);
    default:
       assert(util_blendfactor_is_inverted(factor_without_invert));
-      unreachable("Unexpected inverted factor");
+      UNREACHABLE("Unexpected inverted factor");
    }
 }
 
@@ -235,7 +235,7 @@ nir_logicop_func(
    case PIPE_LOGICOP_EQUIV:
       return nir_ixor(b, nir_ixor(b, src, dst), bitmask);
    case PIPE_LOGICOP_NOOP:
-      unreachable("optimized out");
+      UNREACHABLE("optimized out");
    case PIPE_LOGICOP_OR_INVERTED:
       return nir_ior(b, nir_ixor(b, src, bitmask), dst);
    case PIPE_LOGICOP_COPY:
@@ -248,7 +248,7 @@ nir_logicop_func(
       return nir_imm_ivec4(b, ~0, ~0, ~0, ~0);
    }
 
-   unreachable("Invalid logciop function");
+   UNREACHABLE("Invalid logciop function");
 }
 
 static nir_def *
diff --git a/src/compiler/nir/nir_lower_bool_to_bitsize.c b/src/compiler/nir/nir_lower_bool_to_bitsize.c
index ab3e3eb8ed110..10de06437e2b7 100644
--- a/src/compiler/nir/nir_lower_bool_to_bitsize.c
+++ b/src/compiler/nir/nir_lower_bool_to_bitsize.c
@@ -53,7 +53,7 @@ get_bool_convert_opcode(uint32_t dst_bit_size)
    case 8:
       return nir_op_i2i8;
    default:
-      unreachable("invalid boolean bit-size");
+      UNREACHABLE("invalid boolean bit-size");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_calls_to_builtins.c b/src/compiler/nir/nir_lower_calls_to_builtins.c
index 1de4fa093f785..a881582abf980 100644
--- a/src/compiler/nir/nir_lower_calls_to_builtins.c
+++ b/src/compiler/nir/nir_lower_calls_to_builtins.c
@@ -136,7 +136,7 @@ lower(nir_builder *b, nir_instr *instr, void *data)
 
    /* We must have matched something! */
    fprintf(stderr, "unknown opcode %s\n", func->name);
-   unreachable("invalid nir opcode/intrinsic");
+   UNREACHABLE("invalid nir opcode/intrinsic");
 }
 
 bool
diff --git a/src/compiler/nir/nir_lower_cl_images.c b/src/compiler/nir/nir_lower_cl_images.c
index 40545670a25ad..6d02ca0c8ec3a 100644
--- a/src/compiler/nir/nir_lower_cl_images.c
+++ b/src/compiler/nir/nir_lower_cl_images.c
@@ -45,7 +45,7 @@ find_identical_inline_sampler(nir_shader *nir,
       exec_list_push_tail(inline_samplers, &var->node);
       return var;
    }
-   unreachable("Should have at least found the input sampler");
+   UNREACHABLE("Should have at least found the input sampler");
 }
 
 static bool
diff --git a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
index 70db280dc0737..80d0b2bb49138 100644
--- a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
+++ b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
@@ -138,7 +138,7 @@ replace_var_declaration(struct lower_distance_state *state, nir_shader *sh,
       old_var = &state->old_distance_in_var;
       new_var = &state->new_distance_in_var;
    } else {
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    *old_var = var;
diff --git a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
index 6d61868a5a308..69d45dd76ebbd 100644
--- a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
+++ b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
@@ -72,7 +72,7 @@ set_const_initialiser(nir_deref_instr **p, nir_constant *top_level_init,
       } else if ((*p)->deref_type == nir_deref_type_struct) {
          ret = ret->elements[(*p)->strct.index];
       } else {
-         unreachable("Unsupported deref type");
+         UNREACHABLE("Unsupported deref type");
       }
    }
 
@@ -395,7 +395,7 @@ nir_lower_const_arrays_to_uniforms(nir_shader *shader,
                new_deref_instr = nir_build_deref_struct(&b, new_deref_instr,
                                                         (*p)->strct.index);
             } else {
-               unreachable("Unsupported deref type");
+               UNREACHABLE("Unsupported deref type");
             }
          }
          nir_deref_path_finish(&path);
diff --git a/src/compiler/nir/nir_lower_continue_constructs.c b/src/compiler/nir/nir_lower_continue_constructs.c
index 5e9032107fc5d..39f334fa84c6f 100644
--- a/src/compiler/nir/nir_lower_continue_constructs.c
+++ b/src/compiler/nir/nir_lower_continue_constructs.c
@@ -124,7 +124,7 @@ visit_cf_list(nir_builder *b, struct exec_list *list, bool *repair_ssa)
          break;
       }
       case nir_cf_node_function:
-         unreachable("Unsupported cf_node type.");
+         UNREACHABLE("Unsupported cf_node type.");
       }
    }
 
diff --git a/src/compiler/nir/nir_lower_discard_if.c b/src/compiler/nir/nir_lower_discard_if.c
index 81e5230abbb19..023a805e4870b 100644
--- a/src/compiler/nir/nir_lower_discard_if.c
+++ b/src/compiler/nir/nir_lower_discard_if.c
@@ -132,7 +132,7 @@ lower_discard_if(nir_builder *b, nir_intrinsic_instr *instr, void *cb_data)
       nir_terminate(b);
       break;
    default:
-      unreachable("bad intrinsic");
+      UNREACHABLE("bad intrinsic");
    }
    nir_pop_if(b, if_stmt);
    nir_instr_remove(&instr->instr);
diff --git a/src/compiler/nir/nir_lower_double_ops.c b/src/compiler/nir/nir_lower_double_ops.c
index 69ceaa71c7aa5..134c1f6671301 100644
--- a/src/compiler/nir/nir_lower_double_ops.c
+++ b/src/compiler/nir/nir_lower_double_ops.c
@@ -853,11 +853,11 @@ lower_doubles_instr(nir_builder *b, nir_instr *instr, void *_data)
       case nir_op_fmax:
          return lower_minmax(b, nir_op_fge, src, src1);
       default:
-         unreachable("unhandled opcode");
+         UNREACHABLE("unhandled opcode");
       }
    }
    default:
-      unreachable("unhandled opcode");
+      UNREACHABLE("unhandled opcode");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_explicit_io.c b/src/compiler/nir/nir_lower_explicit_io.c
index f6ad78532eb65..804e7ce3c1768 100644
--- a/src/compiler/nir/nir_lower_explicit_io.c
+++ b/src/compiler/nir/nir_lower_explicit_io.c
@@ -34,7 +34,7 @@ ssbo_atomic_for_deref(nir_intrinsic_op deref_op)
    case nir_intrinsic_deref_atomic_swap:
       return nir_intrinsic_ssbo_atomic_swap;
    default:
-      unreachable("Invalid SSBO atomic");
+      UNREACHABLE("Invalid SSBO atomic");
    }
 }
 
@@ -56,7 +56,7 @@ global_atomic_for_deref(nir_address_format addr_format,
          return nir_intrinsic_global_atomic_swap_2x32;
 
    default:
-      unreachable("Invalid SSBO atomic");
+      UNREACHABLE("Invalid SSBO atomic");
    }
 }
 
@@ -69,7 +69,7 @@ shared_atomic_for_deref(nir_intrinsic_op deref_op)
    case nir_intrinsic_deref_atomic_swap:
       return nir_intrinsic_shared_atomic_swap;
    default:
-      unreachable("Invalid shared atomic");
+      UNREACHABLE("Invalid shared atomic");
    }
 }
 
@@ -82,7 +82,7 @@ task_payload_atomic_for_deref(nir_intrinsic_op deref_op)
    case nir_intrinsic_deref_atomic_swap:
       return nir_intrinsic_task_payload_atomic_swap;
    default:
-      unreachable("Invalid task payload atomic");
+      UNREACHABLE("Invalid task payload atomic");
    }
 }
 
@@ -158,7 +158,7 @@ build_addr_for_var(nir_builder *b, nir_variable *var,
          break;
 
       default:
-         unreachable("Unsupported variable mode");
+         UNREACHABLE("Unsupported variable mode");
       }
 
       return nir_build_addr_iadd_imm(b, base_addr, addr_format, var->data.mode,
@@ -189,11 +189,11 @@ build_addr_for_var(nir_builder *b, nir_variable *var,
                              var->data.driver_location);
 
       default:
-         unreachable("Unsupported variable mode");
+         UNREACHABLE("Unsupported variable mode");
       }
 
    default:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 }
 
@@ -221,12 +221,12 @@ build_runtime_addr_mode_check(nir_builder *b, nir_def *addr,
                         nir_ieq_imm(b, mode_enum, 0x3));
 
       default:
-         unreachable("Invalid mode check intrinsic");
+         UNREACHABLE("Invalid mode check intrinsic");
       }
    }
 
    default:
-      unreachable("Unsupported address mode");
+      UNREACHABLE("Unsupported address mode");
    }
 }
 
@@ -259,7 +259,7 @@ nir_address_format_bit_size(nir_address_format addr_format)
    case nir_address_format_logical:
       return 32;
    }
-   unreachable("Invalid address format");
+   UNREACHABLE("Invalid address format");
 }
 
 unsigned
@@ -291,7 +291,7 @@ nir_address_format_num_components(nir_address_format addr_format)
    case nir_address_format_logical:
       return 1;
    }
-   unreachable("Invalid address format");
+   UNREACHABLE("Invalid address format");
 }
 
 static nir_def *
@@ -308,7 +308,7 @@ addr_to_index(nir_builder *b, nir_def *addr,
       assert(addr->num_components == 3);
       return nir_trim_vector(b, addr, 2);
    default:
-      unreachable("Invalid address format");
+      UNREACHABLE("Invalid address format");
    }
 }
 
@@ -331,7 +331,7 @@ addr_to_offset(nir_builder *b, nir_def *addr,
    case nir_address_format_62bit_generic:
       return nir_u2u32(b, addr);
    default:
-      unreachable("Invalid address format");
+      UNREACHABLE("Invalid address format");
    }
 }
 
@@ -388,10 +388,10 @@ addr_to_global(nir_builder *b, nir_def *addr,
    case nir_address_format_32bit_offset:
    case nir_address_format_32bit_offset_as_64bit:
    case nir_address_format_logical:
-      unreachable("Cannot get a 64-bit address with this address format");
+      UNREACHABLE("Cannot get a 64-bit address with this address format");
    }
 
-   unreachable("Invalid address format");
+   UNREACHABLE("Invalid address format");
 }
 
 static bool
@@ -682,7 +682,7 @@ build_explicit_io_load(nir_builder *b, nir_intrinsic_instr *intrin,
          }
          break;
       default:
-         unreachable("Unsupported explicit IO variable mode");
+         UNREACHABLE("Unsupported explicit IO variable mode");
       }
       break;
 
@@ -701,12 +701,12 @@ build_explicit_io_load(nir_builder *b, nir_intrinsic_instr *intrin,
          op = nir_intrinsic_load_shared_block_intel;
          break;
       default:
-         unreachable("Unsupported explicit IO variable mode");
+         UNREACHABLE("Unsupported explicit IO variable mode");
       }
       break;
 
    default:
-      unreachable("Invalid intrinsic");
+      UNREACHABLE("Invalid intrinsic");
    }
 
    nir_intrinsic_instr *load = nir_intrinsic_instr_create(b->shader, op);
@@ -900,7 +900,7 @@ build_explicit_io_store(nir_builder *b, nir_intrinsic_instr *intrin,
          }
          break;
       default:
-         unreachable("Unsupported explicit IO variable mode");
+         UNREACHABLE("Unsupported explicit IO variable mode");
       }
       break;
 
@@ -921,12 +921,12 @@ build_explicit_io_store(nir_builder *b, nir_intrinsic_instr *intrin,
          op = nir_intrinsic_store_shared_block_intel;
          break;
       default:
-         unreachable("Unsupported explicit IO variable mode");
+         UNREACHABLE("Unsupported explicit IO variable mode");
       }
       break;
 
    default:
-      unreachable("Invalid intrinsic");
+      UNREACHABLE("Invalid intrinsic");
    }
 
    nir_intrinsic_instr *store = nir_intrinsic_instr_create(b->shader, op);
@@ -1051,7 +1051,7 @@ build_explicit_io_atomic(nir_builder *b, nir_intrinsic_instr *intrin,
       op = task_payload_atomic_for_deref(intrin->intrinsic);
       break;
    default:
-      unreachable("Unsupported explicit IO variable mode");
+      UNREACHABLE("Unsupported explicit IO variable mode");
    }
 
    nir_intrinsic_instr *atomic = nir_intrinsic_instr_create(b->shader, op);
@@ -1135,7 +1135,7 @@ nir_explicit_io_address_from_deref(nir_builder *b, nir_deref_instr *deref,
    }
 
    case nir_deref_type_array_wildcard:
-      unreachable("Wildcards should be lowered by now");
+      UNREACHABLE("Wildcards should be lowered by now");
       break;
 
    case nir_deref_type_struct: {
@@ -1152,7 +1152,7 @@ nir_explicit_io_address_from_deref(nir_builder *b, nir_deref_instr *deref,
       return base_addr;
    }
 
-   unreachable("Invalid NIR deref type");
+   UNREACHABLE("Invalid NIR deref type");
 }
 
 void
@@ -1331,7 +1331,7 @@ nir_get_explicit_deref_align(nir_deref_instr *deref,
 
    switch (deref->deref_type) {
    case nir_deref_type_var:
-      unreachable("Handled above");
+      UNREACHABLE("Handled above");
 
    case nir_deref_type_array:
    case nir_deref_type_array_wildcard:
@@ -1374,7 +1374,7 @@ nir_get_explicit_deref_align(nir_deref_instr *deref,
       return true;
    }
 
-   unreachable("Invalid deref_instr_type");
+   UNREACHABLE("Invalid deref_instr_type");
 }
 
 static void
@@ -1458,7 +1458,7 @@ lower_explicit_io_array_length(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Cannot determine SSBO size");
+      UNREACHABLE("Cannot determine SSBO size");
    }
 
    nir_def *remaining = nir_usub_sat(b, size, offset);
@@ -1709,7 +1709,7 @@ lower_vars_to_explicit(nir_shader *shader,
       offset = 0;
       break;
    default:
-      unreachable("Unsupported mode");
+      UNREACHABLE("Unsupported mode");
    }
    nir_foreach_variable_in_list(var, vars) {
       if (var->data.mode != mode)
@@ -1766,7 +1766,7 @@ lower_vars_to_explicit(nir_shader *shader,
    case nir_var_mem_node_payload_in:
       break;
    default:
-      unreachable("Unsupported mode");
+      UNREACHABLE("Unsupported mode");
    }
 
    return progress;
@@ -2028,10 +2028,10 @@ nir_build_addr_ieq(nir_builder *b, nir_def *addr0, nir_def *addr1,
       return nir_ball_iequal(b, nir_unpack_64_2x32(b, addr0), nir_unpack_64_2x32(b, addr1));
 
    case nir_address_format_logical:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 
-   unreachable("Invalid address format");
+   UNREACHABLE("Invalid address format");
 }
 
 nir_def *
@@ -2075,10 +2075,10 @@ nir_build_addr_isub(nir_builder *b, nir_def *addr0, nir_def *addr1,
       return nir_isub(b, nir_channel(b, addr0, 2), nir_channel(b, addr1, 2));
 
    case nir_address_format_logical:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 
-   unreachable("Invalid address format");
+   UNREACHABLE("Invalid address format");
 }
 
 nir_def *
@@ -2154,7 +2154,7 @@ nir_build_addr_iadd(nir_builder *b, nir_def *addr,
       }
 
    case nir_address_format_logical:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
-   unreachable("Invalid address format");
+   UNREACHABLE("Invalid address format");
 }
diff --git a/src/compiler/nir/nir_lower_flrp.c b/src/compiler/nir/nir_lower_flrp.c
index f40d9045ad2cf..574161299275a 100644
--- a/src/compiler/nir/nir_lower_flrp.c
+++ b/src/compiler/nir/nir_lower_flrp.c
@@ -396,7 +396,7 @@ convert_flrp_instruction(nir_builder *bld,
    else if (bit_size == 64)
       have_ffma = !bld->shader->options->lower_ffma64;
    else
-      unreachable("invalid bit_size");
+      UNREACHABLE("invalid bit_size");
 
    bld->cursor = nir_before_instr(&alu->instr);
 
diff --git a/src/compiler/nir/nir_lower_fp16_conv.c b/src/compiler/nir/nir_lower_fp16_conv.c
index b6990b3da9cd0..e0fabd35b521e 100644
--- a/src/compiler/nir/nir_lower_fp16_conv.c
+++ b/src/compiler/nir/nir_lower_fp16_conv.c
@@ -98,7 +98,7 @@ float_to_half_impl(nir_builder *b, nir_def *src, nir_rounding_mode mode)
          overflowed_fp16 = nir_bcsel(b, nir_i2b(b, sign), nir_imm_int(b, 0x7C00), nir_imm_int(b, 0x7BFF));
          break;
       default:
-         unreachable("Should've been handled already");
+         UNREACHABLE("Should've been handled already");
       }
       nir_push_else(b, NULL);
    }
@@ -316,7 +316,7 @@ lower_fp16_cast_impl(nir_builder *b, nir_instr *instr, void *data)
       /* Otherwise assume the backend can handle f2f16 with undef rounding */
       break;
    default:
-      unreachable("Invalid rounding mode");
+      UNREACHABLE("Invalid rounding mode");
    }
    if (!(options & req_option))
       return progress;
diff --git a/src/compiler/nir/nir_lower_frexp.c b/src/compiler/nir/nir_lower_frexp.c
index 98078f8e3c424..3b547be497138 100644
--- a/src/compiler/nir/nir_lower_frexp.c
+++ b/src/compiler/nir/nir_lower_frexp.c
@@ -76,7 +76,7 @@ lower_frexp_sig(nir_builder *b, nir_def *x)
       exponent_value = nir_imm_int(b, 0x3fe00000u);
       break;
    default:
-      unreachable("Invalid bitsize");
+      UNREACHABLE("Invalid bitsize");
    }
 
    if (x->bit_size == 64) {
@@ -152,7 +152,7 @@ lower_frexp_exp(nir_builder *b, nir_def *x)
       break;
    }
    default:
-      unreachable("Invalid bitsize");
+      UNREACHABLE("Invalid bitsize");
    }
 
    return exponent;
diff --git a/src/compiler/nir/nir_lower_image.c b/src/compiler/nir/nir_lower_image.c
index e8c59f22b454b..3ee0f8bedf848 100644
--- a/src/compiler/nir/nir_lower_image.c
+++ b/src/compiler/nir/nir_lower_image.c
@@ -96,7 +96,7 @@ lower_image_to_fragment_mask_load(nir_builder *b, nir_intrinsic_instr *intrin)
       fmask_op = nir_intrinsic_bindless_image_fragment_mask_load_amd;
       break;
    default:
-      unreachable("bad intrinsic");
+      UNREACHABLE("bad intrinsic");
       break;
    }
 
@@ -145,7 +145,7 @@ lower_image_samples_identical_to_fragment_mask_load(nir_builder *b, nir_intrinsi
       fmask_load->intrinsic = nir_intrinsic_bindless_image_fragment_mask_load_amd;
       break;
    default:
-      unreachable("bad intrinsic");
+      UNREACHABLE("bad intrinsic");
       break;
    }
 
diff --git a/src/compiler/nir/nir_lower_int64.c b/src/compiler/nir/nir_lower_int64.c
index ab21f72fa1635..75aa4af967e68 100644
--- a/src/compiler/nir/nir_lower_int64.c
+++ b/src/compiler/nir/nir_lower_int64.c
@@ -384,7 +384,7 @@ lower_int64_compare(nir_builder *b, nir_op op, nir_def *x, nir_def *y)
       /* Lower as !(x < y) in the hopes of better CSE */
       return nir_inot(b, lower_int64_compare(b, nir_op_ilt, x, y));
    default:
-      unreachable("Invalid comparison");
+      UNREACHABLE("Invalid comparison");
    }
 }
 
@@ -748,7 +748,7 @@ lower_2f(nir_builder *b, nir_def *x, unsigned dest_bit_size,
       significand_bits = 10;
       break;
    default:
-      unreachable("Invalid dest_bit_size");
+      UNREACHABLE("Invalid dest_bit_size");
    }
 
    nir_def *discard =
@@ -1111,7 +1111,7 @@ lower_int64_alu_instr(nir_builder *b, nir_alu_instr *alu)
    case nir_op_f2u64:
       return lower_f2(b, src[0], alu->op == nir_op_f2i64);
    default:
-      unreachable("Invalid ALU opcode to lower");
+      UNREACHABLE("Invalid ALU opcode to lower");
    }
 }
 
@@ -1383,12 +1383,12 @@ lower_int64_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin)
       case nir_op_ixor:
          return split_64bit_subgroup_op(b, intrin);
       default:
-         unreachable("Unsupported subgroup scan/reduce op");
+         UNREACHABLE("Unsupported subgroup scan/reduce op");
       }
       break;
 
    default:
-      unreachable("Unsupported intrinsic");
+      UNREACHABLE("Unsupported intrinsic");
    }
    return NULL;
 }
diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index f3f77c6dbd73d..6f22483a7fd97 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -192,7 +192,7 @@ get_io_offset(nir_builder *b, nir_deref_instr *deref,
          }
          offset = nir_iadd_imm(b, offset, field_offset);
       } else {
-         unreachable("Unsupported deref type");
+         UNREACHABLE("Unsupported deref type");
       }
    }
 
@@ -294,7 +294,7 @@ emit_load(struct lower_io_state *state,
       op = nir_intrinsic_load_uniform;
       break;
    default:
-      unreachable("Unknown variable mode");
+      UNREACHABLE("Unknown variable mode");
    }
 
    nir_intrinsic_instr *load =
@@ -607,7 +607,7 @@ lower_interpolate_at(nir_intrinsic_instr *intrin, struct lower_io_state *state,
       bary_op = nir_intrinsic_load_barycentric_at_offset;
       break;
    default:
-      unreachable("Bogus interpolateAt() intrinsic.");
+      UNREACHABLE("Bogus interpolateAt() intrinsic.");
    }
 
    nir_intrinsic_instr *bary_setup =
diff --git a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
index fd20ea631ed8c..9e5bcd3cf2c9f 100644
--- a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
+++ b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
@@ -184,7 +184,7 @@ emit_interp(nir_builder *b, nir_deref_instr **old_interp_deref,
       case nir_deref_type_array_wildcard:
       case nir_deref_type_ptr_as_array:
       case nir_deref_type_cast:
-         unreachable("bad deref type");
+         UNREACHABLE("bad deref type");
       }
 
       old_interp_deref++;
diff --git a/src/compiler/nir/nir_lower_locals_to_regs.c b/src/compiler/nir/nir_lower_locals_to_regs.c
index cb3b0e39c36c9..f366fd0015d55 100644
--- a/src/compiler/nir/nir_lower_locals_to_regs.c
+++ b/src/compiler/nir/nir_lower_locals_to_regs.c
@@ -65,11 +65,11 @@ hash_deref(const void *void_deref)
          continue;
 
       default:
-         unreachable("Invalid deref type");
+         UNREACHABLE("Invalid deref type");
       }
    }
 
-   unreachable("We should have hit a variable dereference");
+   UNREACHABLE("We should have hit a variable dereference");
 }
 
 static bool
@@ -93,11 +93,11 @@ derefs_equal(const void *void_a, const void *void_b)
          continue;
 
       default:
-         unreachable("Invalid deref type");
+         UNREACHABLE("Invalid deref type");
       }
    }
 
-   unreachable("We should have hit a variable dereference");
+   UNREACHABLE("We should have hit a variable dereference");
 }
 
 static nir_def *
@@ -274,7 +274,7 @@ lower_locals_to_regs_block(nir_block *block,
       }
 
       case nir_intrinsic_copy_deref:
-         unreachable("There should be no copies whatsoever at this point");
+         UNREACHABLE("There should be no copies whatsoever at this point");
          break;
 
       default:
diff --git a/src/compiler/nir/nir_lower_mediump.c b/src/compiler/nir/nir_lower_mediump.c
index 519fc32de5af5..54080465b547e 100644
--- a/src/compiler/nir/nir_lower_mediump.c
+++ b/src/compiler/nir/nir_lower_mediump.c
@@ -241,7 +241,7 @@ nir_lower_mediump_vars_impl(nir_function_impl *impl, nir_variable_mode modes,
                   break;
                default:
                   nir_print_instr(instr, stderr);
-                  unreachable("unsupported deref type");
+                  UNREACHABLE("unsupported deref type");
                }
             }
 
@@ -275,7 +275,7 @@ nir_lower_mediump_vars_impl(nir_function_impl *impl, nir_variable_mode modes,
                   replace = nir_u2u32(&b, &intrin->def);
                   break;
                default:
-                  unreachable("Invalid 16-bit type");
+                  UNREACHABLE("Invalid 16-bit type");
                }
 
                nir_def_rewrite_uses_after(&intrin->def,
@@ -305,7 +305,7 @@ nir_lower_mediump_vars_impl(nir_function_impl *impl, nir_variable_mode modes,
                   replace = nir_i2imp(&b, data);
                   break;
                default:
-                  unreachable("Invalid 16-bit type");
+                  UNREACHABLE("Invalid 16-bit type");
                }
 
                nir_src_rewrite(&intrin->src[1], replace);
@@ -575,7 +575,7 @@ opt_16bit_src(nir_builder *b, nir_instr *instr, nir_src *src, nir_alu_type src_t
                extract = nir_unpack_32_2x16_split_y(b, extract);
                break;
             default:
-               unreachable("unsupported alu op");
+               UNREACHABLE("unsupported alu op");
             }
 
             new_comps[i] = nir_get_scalar(extract, 0);
@@ -704,7 +704,7 @@ opt_16bit_destination(nir_def *ssa, nir_alu_type dest_type, unsigned exec_mode,
          alu->op = nir_op_pack_32_2x16;
          break;
       default:
-         unreachable("unsupported conversion op");
+         UNREACHABLE("unsupported conversion op");
       };
    }
 
diff --git a/src/compiler/nir/nir_lower_mem_access_bit_sizes.c b/src/compiler/nir/nir_lower_mem_access_bit_sizes.c
index e5b2841bb1ac6..51805add503c6 100644
--- a/src/compiler/nir/nir_lower_mem_access_bit_sizes.c
+++ b/src/compiler/nir/nir_lower_mem_access_bit_sizes.c
@@ -442,7 +442,7 @@ lower_mem_store(nir_builder *b, nir_intrinsic_instr *intrin,
             break;
          }
          default:
-            unreachable("Unsupported unaligned store");
+            UNREACHABLE("Unsupported unaligned store");
          }
       } else {
          nir_def *packed = nir_extract_bits(b, &value, 1, chunk_start * 8,
diff --git a/src/compiler/nir/nir_lower_memcpy.c b/src/compiler/nir/nir_lower_memcpy.c
index 6e4cefd8dcd46..541298d062c8a 100644
--- a/src/compiler/nir/nir_lower_memcpy.c
+++ b/src/compiler/nir/nir_lower_memcpy.c
@@ -45,7 +45,7 @@ copy_type_for_byte_size(unsigned size)
    case 16:
       return glsl_vector_type(GLSL_TYPE_UINT, 4);
    default:
-      unreachable("Unsupported size");
+      UNREACHABLE("Unsupported size");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_memory_model.c b/src/compiler/nir/nir_lower_memory_model.c
index aa53766676be8..194215a7a7be9 100644
--- a/src/compiler/nir/nir_lower_memory_model.c
+++ b/src/compiler/nir/nir_lower_memory_model.c
@@ -179,7 +179,7 @@ lower_make_visible(nir_cf_node *cf_node, uint32_t *cur_modes)
       break;
    }
    case nir_cf_node_function:
-      unreachable("Invalid cf type");
+      UNREACHABLE("Invalid cf type");
    }
    return progress;
 }
@@ -219,7 +219,7 @@ lower_make_available(nir_cf_node *cf_node, uint32_t *cur_modes)
       break;
    }
    case nir_cf_node_function:
-      unreachable("Invalid cf type");
+      UNREACHABLE("Invalid cf type");
    }
    return progress;
 }
diff --git a/src/compiler/nir/nir_lower_multiview.c b/src/compiler/nir/nir_lower_multiview.c
index 2f91dd8be63a9..57331fa1a1317 100644
--- a/src/compiler/nir/nir_lower_multiview.c
+++ b/src/compiler/nir/nir_lower_multiview.c
@@ -305,14 +305,14 @@ nir_lower_multiview(nir_shader *shader, nir_lower_multiview_options options)
          case nir_intrinsic_load_deref: {
             nir_variable *var = nir_intrinsic_get_var(intrin, 0);
             if (var && _mesa_hash_table_search(out_derefs, var)) {
-               unreachable("Should have lowered I/O to temporaries "
+               UNREACHABLE("Should have lowered I/O to temporaries "
                            "so no load_deref on output is expected.");
             }
             break;
          }
 
          case nir_intrinsic_copy_deref:
-            unreachable("Should have lowered copy_derefs at this point");
+            UNREACHABLE("Should have lowered copy_derefs at this point");
             break;
 
          default:
diff --git a/src/compiler/nir/nir_lower_printf.c b/src/compiler/nir/nir_lower_printf.c
index d83c56a921c1f..e25805001094b 100644
--- a/src/compiler/nir/nir_lower_printf.c
+++ b/src/compiler/nir/nir_lower_printf.c
@@ -258,7 +258,7 @@ nir_vprintf_fmt(nir_builder *b, unsigned ptr_bit_size, const char *fmt, va_list
          arg_size = 8;
          break;
       default:
-         unreachable("invalid");
+         UNREACHABLE("invalid");
       }
 
       ASSERTED nir_def *def = va_arg(ap, nir_def *);
diff --git a/src/compiler/nir/nir_lower_readonly_images_to_tex.c b/src/compiler/nir/nir_lower_readonly_images_to_tex.c
index e57d9005a4394..e376e1b5b2111 100644
--- a/src/compiler/nir/nir_lower_readonly_images_to_tex.c
+++ b/src/compiler/nir/nir_lower_readonly_images_to_tex.c
@@ -125,7 +125,7 @@ lower_readonly_image_instr_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin
       num_srcs = 1;
       break;
    default:
-      unreachable("Unsupported intrinsic");
+      UNREACHABLE("Unsupported intrinsic");
    }
 
    b->cursor = nir_before_instr(&intrin->instr);
@@ -194,7 +194,7 @@ lower_readonly_image_instr_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin
       break;
 
    default:
-      unreachable("Unsupported intrinsic");
+      UNREACHABLE("Unsupported intrinsic");
    }
 
    nir_builder_instr_insert(b, &tex->instr);
diff --git a/src/compiler/nir/nir_lower_returns.c b/src/compiler/nir/nir_lower_returns.c
index 7f511f7bba98b..d7997a1830d40 100644
--- a/src/compiler/nir/nir_lower_returns.c
+++ b/src/compiler/nir/nir_lower_returns.c
@@ -261,7 +261,7 @@ lower_returns_in_cf_list(struct exec_list *cf_list,
          break;
 
       default:
-         unreachable("Invalid inner CF node type");
+         UNREACHABLE("Invalid inner CF node type");
       }
    }
 
diff --git a/src/compiler/nir/nir_lower_robust_access.c b/src/compiler/nir/nir_lower_robust_access.c
index 3af74d7274de7..73661070d1d6a 100644
--- a/src/compiler/nir/nir_lower_robust_access.c
+++ b/src/compiler/nir/nir_lower_robust_access.c
@@ -207,7 +207,7 @@ lower(nir_builder *b, nir_intrinsic_instr *intr, void *_opts)
       return true;
 
    default:
-      unreachable("driver requested lowering for unsupported intrinsic");
+      UNREACHABLE("driver requested lowering for unsupported intrinsic");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_shader_calls.c b/src/compiler/nir/nir_lower_shader_calls.c
index c958a4f700ee5..75aa7fe663c76 100644
--- a/src/compiler/nir/nir_lower_shader_calls.c
+++ b/src/compiler/nir/nir_lower_shader_calls.c
@@ -679,7 +679,7 @@ spill_ssa_defs_and_lower_shader_calls(nir_shader *shader, uint32_t num_calls,
          }
 
          case nir_intrinsic_report_ray_intersection:
-            unreachable("Any-hit shaders must be inlined");
+            UNREACHABLE("Any-hit shaders must be inlined");
 
          case nir_intrinsic_execute_callable: {
             nir_rt_execute_callable(b, call->src[0].ssa, call->src[1].ssa, .call_idx = call_idx, .stack_size = offset);
@@ -687,7 +687,7 @@ spill_ssa_defs_and_lower_shader_calls(nir_shader *shader, uint32_t num_calls,
          }
 
          default:
-            unreachable("Invalid shader call instruction");
+            UNREACHABLE("Invalid shader call instruction");
          }
 
          nir_rt_resume(b, .call_idx = call_idx, .stack_size = offset);
@@ -816,7 +816,7 @@ find_resume_instr(nir_function_impl *impl, unsigned call_idx)
             return &resume->instr;
       }
    }
-   unreachable("Couldn't find resume instruction");
+   UNREACHABLE("Couldn't find resume instruction");
 }
 
 /* Walk the CF tree and duplicate the contents of every loop, one half runs on
@@ -931,7 +931,7 @@ cursor_is_after_jump(nir_cursor cursor)
       return nir_block_ends_in_jump(cursor.block);
       ;
    }
-   unreachable("Invalid cursor option");
+   UNREACHABLE("Invalid cursor option");
 }
 
 /** Flattens if ladders leading up to a resume
@@ -1112,7 +1112,7 @@ flatten_resume_if_ladder(nir_builder *b,
       }
 
       case nir_cf_node_function:
-         unreachable("Unsupported CF node type");
+         UNREACHABLE("Unsupported CF node type");
       }
    }
    assert(!before_cursor);
@@ -1571,7 +1571,7 @@ nir_opt_trim_stack_values(nir_shader *shader)
                   new_write_mask |= 1 << swiz_map[idx];
                nir_intrinsic_set_write_mask(use_intrin, new_write_mask);
             } else {
-               unreachable("invalid instruction type");
+               UNREACHABLE("invalid instruction type");
             }
          }
 
@@ -1789,7 +1789,7 @@ find_last_dominant_use_block(nir_function_impl *impl, nir_def *value)
 
       return block;
    }
-   unreachable("Cannot find block");
+   UNREACHABLE("Cannot find block");
 }
 
 /* Put the scratch loads in the branches where they're needed. */
diff --git a/src/compiler/nir/nir_lower_subgroups.c b/src/compiler/nir/nir_lower_subgroups.c
index 6bfceee1909bb..944c43a466ea6 100644
--- a/src/compiler/nir/nir_lower_subgroups.c
+++ b/src/compiler/nir/nir_lower_subgroups.c
@@ -382,7 +382,7 @@ lower_to_shuffle(nir_builder *b, nir_intrinsic_instr *intrin,
       break;
    }
    default:
-      unreachable("Invalid intrinsic");
+      UNREACHABLE("Invalid intrinsic");
    }
 
    return nir_shuffle(b, intrin->src[0].ssa, index);
@@ -538,7 +538,7 @@ lower_boolean_shuffle(nir_builder *b, nir_intrinsic_instr *intrin,
       index = nir_as_uniform(b, intrin->src[1].ssa);
       break;
    default:
-      unreachable("not a boolean shuffle");
+      UNREACHABLE("not a boolean shuffle");
    }
 
    if (index) {
@@ -646,7 +646,7 @@ lower_boolean_reduce(nir_builder *b, nir_intrinsic_instr *intrin,
             return nir_i2b(b, nir_iand_imm(b, vec_bit_count(b, nir_ballot(b, options->ballot_components, options->ballot_bit_size, intrin->src[0].ssa)),
                                            1));
          else
-            unreachable("bad boolean reduction op");
+            UNREACHABLE("bad boolean reduction op");
       }
 
       if (cluster_size == 4) {
@@ -682,7 +682,7 @@ lower_boolean_reduce(nir_builder *b, nir_intrinsic_instr *intrin,
       val = nir_ishl_imm(b, val, 1);
       break;
    default:
-      unreachable("bad intrinsic");
+      UNREACHABLE("bad intrinsic");
    }
 
    if (op == nir_op_iand) {
@@ -740,7 +740,7 @@ build_scan_full(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
    }
 
    default:
-      unreachable("Unsupported scan/reduce op");
+      UNREACHABLE("Unsupported scan/reduce op");
    }
 }
 
@@ -806,7 +806,7 @@ build_scan_reduce(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
    }
 
    default:
-      unreachable("Unsupported scan/reduce op");
+      UNREACHABLE("Unsupported scan/reduce op");
    }
 }
 
@@ -1109,7 +1109,7 @@ lower_subgroups_instr(nir_builder *b, nir_instr *instr, void *_options)
          val = nir_inot(b, build_subgroup_ge_mask(b, options));
          break;
       default:
-         unreachable("you seriously can't tell this is unreachable?");
+         UNREACHABLE("you seriously can't tell this is unreachable?");
       }
 
       return uint_to_ballot_type(b, val,
@@ -1194,7 +1194,7 @@ lower_subgroups_instr(nir_builder *b, nir_instr *instr, void *_options)
       case nir_intrinsic_ballot_find_msb:
          return vec_find_msb(b, int_val);
       default:
-         unreachable("you seriously can't tell this is unreachable?");
+         UNREACHABLE("you seriously can't tell this is unreachable?");
       }
    }
 
diff --git a/src/compiler/nir/nir_lower_system_values.c b/src/compiler/nir/nir_lower_system_values.c
index b73135aff46d8..7e2621128e9fa 100644
--- a/src/compiler/nir/nir_lower_system_values.c
+++ b/src/compiler/nir/nir_lower_system_values.c
@@ -142,7 +142,7 @@ lower_system_value_instr(nir_builder *b, nir_instr *instr, void *_state)
          return nir_load_barycentric_coord_at_offset(b, 32, intrin->src[1].ssa,
                                                      .interp_mode = interp_mode);
       default:
-         unreachable("Bogus interpolateAt() intrinsic.");
+         UNREACHABLE("Bogus interpolateAt() intrinsic.");
       }
    }
 
@@ -193,7 +193,7 @@ lower_system_value_instr(nir_builder *b, nir_instr *instr, void *_state)
             break;
 
          default:
-            unreachable("unsupported system value array deref");
+            UNREACHABLE("unsupported system value array deref");
          }
       }
       nir_variable *var = deref->var;
diff --git a/src/compiler/nir/nir_lower_task_shader.c b/src/compiler/nir/nir_lower_task_shader.c
index 3854cf42598a6..0207e207749ea 100644
--- a/src/compiler/nir/nir_lower_task_shader.c
+++ b/src/compiler/nir/nir_lower_task_shader.c
@@ -159,7 +159,7 @@ shared_opcode_for_task_payload(nir_intrinsic_op task_payload_op)
    case nir_intrinsic_store_task_payload:
       return nir_intrinsic_store_shared;
    default:
-      unreachable("Invalid task payload atomic");
+      UNREACHABLE("Invalid task payload atomic");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_terminate_to_demote.c b/src/compiler/nir/nir_lower_terminate_to_demote.c
index 958f6e3383a05..2b57b98cef5e6 100644
--- a/src/compiler/nir/nir_lower_terminate_to_demote.c
+++ b/src/compiler/nir/nir_lower_terminate_to_demote.c
@@ -72,7 +72,7 @@ nir_lower_terminate_cf_list(nir_builder *b, struct exec_list *cf_list)
       }
 
       default:
-         unreachable("Unknown CF node type");
+         UNREACHABLE("Unknown CF node type");
       }
    }
 
diff --git a/src/compiler/nir/nir_lower_tex.c b/src/compiler/nir/nir_lower_tex.c
index 41018e9877ac4..75efa26934c6c 100644
--- a/src/compiler/nir/nir_lower_tex.c
+++ b/src/compiler/nir/nir_lower_tex.c
@@ -144,7 +144,7 @@ project_src(nir_builder *b, nir_tex_instr *tex)
                                  nir_channel(b, unprojected, 1));
             break;
          default:
-            unreachable("bad texture coord count for array");
+            UNREACHABLE("bad texture coord count for array");
             break;
          }
       }
@@ -1204,7 +1204,7 @@ lower_tex_packing(nir_builder *b, nir_tex_instr *tex,
             break;
          }
          default:
-            unreachable("wrong dest_size");
+            UNREACHABLE("wrong dest_size");
          }
          break;
 
@@ -1217,7 +1217,7 @@ lower_tex_packing(nir_builder *b, nir_tex_instr *tex,
          break;
 
       default:
-         unreachable("unknown base type");
+         UNREACHABLE("unknown base type");
       }
       break;
    }
diff --git a/src/compiler/nir/nir_lower_texcoord_replace.c b/src/compiler/nir/nir_lower_texcoord_replace.c
index 7a79cb2a705c4..f7d60e939240c 100644
--- a/src/compiler/nir/nir_lower_texcoord_replace.c
+++ b/src/compiler/nir/nir_lower_texcoord_replace.c
@@ -49,7 +49,7 @@ get_io_index(nir_builder *b, nir_deref_instr *deref)
 
          offset = nir_iadd(b, offset, mul);
       } else
-         unreachable("Unsupported deref type");
+         UNREACHABLE("Unsupported deref type");
    }
 
    nir_deref_path_finish(&path);
diff --git a/src/compiler/nir/nir_lower_vars_to_ssa.c b/src/compiler/nir/nir_lower_vars_to_ssa.c
index a6dbd3b51ce0c..aedd2365a28af 100644
--- a/src/compiler/nir/nir_lower_vars_to_ssa.c
+++ b/src/compiler/nir/nir_lower_vars_to_ssa.c
@@ -213,7 +213,7 @@ get_deref_node_recur(nir_deref_instr *deref,
       return parent->wildcard;
 
    default:
-      unreachable("Invalid deref type");
+      UNREACHABLE("Invalid deref type");
    }
 }
 
@@ -289,7 +289,7 @@ foreach_deref_node_worker(struct deref_node *node, nir_deref_instr **path,
    }
 
    default:
-      unreachable("Unsupported deref type");
+      UNREACHABLE("Unsupported deref type");
    }
 }
 
@@ -367,7 +367,7 @@ path_may_be_aliased_node(struct deref_node *node, nir_deref_instr **path,
    }
 
    default:
-      unreachable("Unsupported deref type");
+      UNREACHABLE("Unsupported deref type");
    }
 }
 
diff --git a/src/compiler/nir/nir_lower_wpos_ytransform.c b/src/compiler/nir/nir_lower_wpos_ytransform.c
index ff33baa27f068..99d49a9358d48 100644
--- a/src/compiler/nir/nir_lower_wpos_ytransform.c
+++ b/src/compiler/nir/nir_lower_wpos_ytransform.c
@@ -165,7 +165,7 @@ lower_fragcoord(lower_wpos_ytransform_state *state, nir_intrinsic_instr *intr)
          /* the driver supports lower-left origin, need to invert Y */
          invert = true;
       } else {
-         unreachable("invalid options");
+         UNREACHABLE("invalid options");
       }
    } else {
       /* Fragment shader wants origin in lower-left */
@@ -175,7 +175,7 @@ lower_fragcoord(lower_wpos_ytransform_state *state, nir_intrinsic_instr *intr)
          /* the driver supports upper-left origin, need to invert Y */
          invert = true;
       } else {
-         unreachable("invalid options");
+         UNREACHABLE("invalid options");
       }
    }
 
@@ -190,7 +190,7 @@ lower_fragcoord(lower_wpos_ytransform_state *state, nir_intrinsic_instr *intr)
          adjY[0] = -0.5f;
          adjY[1] = 0.5f;
       } else {
-         unreachable("invalid options");
+         UNREACHABLE("invalid options");
       }
    } else {
       /* Fragment shader wants pixel center half integer */
@@ -200,7 +200,7 @@ lower_fragcoord(lower_wpos_ytransform_state *state, nir_intrinsic_instr *intr)
          /* the driver supports pixel center integer, need to bias X,Y */
          adjX = adjY[0] = adjY[1] = 0.5f;
       } else {
-         unreachable("invalid options");
+         UNREACHABLE("invalid options");
       }
    }
 
diff --git a/src/compiler/nir/nir_opcodes_c.py b/src/compiler/nir/nir_opcodes_c.py
index a6dd5a3807d93..a477359ae35fb 100644
--- a/src/compiler/nir/nir_opcodes_c.py
+++ b/src/compiler/nir/nir_opcodes_c.py
@@ -87,7 +87,7 @@ nir_type_conversion_op(nir_alu_type src, nir_alu_type dst, nir_rounding_mode rnd
                                                                    dst_bits, rnd_t[1])};
 %                       endfor
                         default:
-                           unreachable("Invalid 16-bit nir rounding mode");
+                           UNREACHABLE("Invalid 16-bit nir rounding mode");
                      }
 %                    else:
                      assert(rnd == nir_rounding_mode_undef);
@@ -95,15 +95,15 @@ nir_type_conversion_op(nir_alu_type src, nir_alu_type dst, nir_rounding_mode rnd
 %                    endif
 %                 endfor
                   default:
-                     unreachable("Invalid nir alu bit size");
+                     UNREACHABLE("Invalid nir alu bit size");
                }
 %           endfor
             default:
-               unreachable("Invalid nir alu base type");
+               UNREACHABLE("Invalid nir alu base type");
          }
 %     endfor
       default:
-         unreachable("Invalid nir alu base type");
+         UNREACHABLE("Invalid nir alu base type");
    }
 }
 
diff --git a/src/compiler/nir/nir_opt_constant_folding.c b/src/compiler/nir/nir_opt_constant_folding.c
index 7c00b1e96d484..00ed641ee8112 100644
--- a/src/compiler/nir/nir_opt_constant_folding.c
+++ b/src/compiler/nir/nir_opt_constant_folding.c
@@ -122,7 +122,7 @@ const_value_for_deref(nir_deref_instr *deref)
       nir_deref_instr *p = path.path[i];
       switch (p->deref_type) {
       case nir_deref_type_var:
-         unreachable("Deref paths can only start with a var deref");
+         UNREACHABLE("Deref paths can only start with a var deref");
 
       case nir_deref_type_array: {
          assert(v == NULL);
@@ -187,7 +187,7 @@ try_fold_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin,
                op = nir_intrinsic_terminate;
                break;
             default:
-               unreachable("invalid intrinsic");
+               UNREACHABLE("invalid intrinsic");
             }
             nir_intrinsic_instr *new_instr =
                nir_intrinsic_instr_create(b->shader, op);
diff --git a/src/compiler/nir/nir_opt_copy_prop_vars.c b/src/compiler/nir/nir_opt_copy_prop_vars.c
index f5117328ea0cf..e85895dbd135b 100644
--- a/src/compiler/nir/nir_opt_copy_prop_vars.c
+++ b/src/compiler/nir/nir_opt_copy_prop_vars.c
@@ -282,7 +282,7 @@ gather_vars_written(struct copy_prop_var_state *state,
    }
 
    default:
-      unreachable("Invalid CF node type");
+      UNREACHABLE("Invalid CF node type");
    }
 
    if (new_written) {
@@ -1483,7 +1483,7 @@ copy_prop_vars_cf_node(struct copy_prop_var_state *state,
    }
 
    default:
-      unreachable("Invalid CF node type");
+      UNREACHABLE("Invalid CF node type");
    }
 }
 
diff --git a/src/compiler/nir/nir_opt_dce.c b/src/compiler/nir/nir_opt_dce.c
index ec47a01658cf6..eb90008cd88fc 100644
--- a/src/compiler/nir/nir_opt_dce.c
+++ b/src/compiler/nir/nir_opt_dce.c
@@ -97,7 +97,7 @@ is_live(BITSET_WORD *defs_live, nir_instr *instr)
       return false;
    }
    default:
-      unreachable("unexpected instr type");
+      UNREACHABLE("unexpected instr type");
    }
 }
 
@@ -211,7 +211,7 @@ dce_cf_list(struct exec_list *cf_list, BITSET_WORD *defs_live,
          break;
       }
       case nir_cf_node_function:
-         unreachable("Invalid cf type");
+         UNREACHABLE("Invalid cf type");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_dead_cf.c b/src/compiler/nir/nir_opt_dead_cf.c
index 6bebda646e11c..c5077ee261a2b 100644
--- a/src/compiler/nir/nir_opt_dead_cf.c
+++ b/src/compiler/nir/nir_opt_dead_cf.c
@@ -373,7 +373,7 @@ dead_cf_list(struct exec_list *list, bool *list_ends_in_jump)
       }
 
       default:
-         unreachable("unknown cf node type");
+         UNREACHABLE("unknown cf node type");
       }
 
       prev = cur;
diff --git a/src/compiler/nir/nir_opt_find_array_copies.c b/src/compiler/nir/nir_opt_find_array_copies.c
index ec541e2ec3969..382bc1f662ef4 100644
--- a/src/compiler/nir/nir_opt_find_array_copies.c
+++ b/src/compiler/nir/nir_opt_find_array_copies.c
@@ -132,7 +132,7 @@ node_for_deref(nir_deref_instr *instr, struct match_node *parent,
       break;
 
    default:
-      unreachable("bad deref type");
+      UNREACHABLE("bad deref type");
    }
 
    assert(idx < parent->num_children);
@@ -251,7 +251,7 @@ _foreach_aliasing(nir_deref_instr **deref, match_cb cb,
       return;
 
    default:
-      unreachable("bad deref type");
+      UNREACHABLE("bad deref type");
    }
 }
 
@@ -382,7 +382,7 @@ try_match_deref(nir_deref_path *base_path, int *path_array_idx,
          continue;
 
       default:
-         unreachable("Invalid deref type in a path");
+         UNREACHABLE("Invalid deref type in a path");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_gcm.c b/src/compiler/nir/nir_opt_gcm.c
index 4e5059104b145..4342f67b328a5 100644
--- a/src/compiler/nir/nir_opt_gcm.c
+++ b/src/compiler/nir/nir_opt_gcm.c
@@ -118,7 +118,7 @@ get_loop_instr_count(struct exec_list *cf_list)
          break;
       }
       default:
-         unreachable("Invalid CF node type");
+         UNREACHABLE("Invalid CF node type");
       }
    }
 
@@ -157,7 +157,7 @@ gcm_build_block_info(struct exec_list *cf_list, struct gcm_state *state,
          break;
       }
       default:
-         unreachable("Invalid CF node type");
+         UNREACHABLE("Invalid CF node type");
       }
    }
 }
@@ -378,7 +378,7 @@ gcm_pin_instructions(nir_function_impl *impl, struct gcm_state *state)
             break;
 
          default:
-            unreachable("Invalid instruction type in GCM");
+            UNREACHABLE("Invalid instruction type in GCM");
          }
 
          if (!(instr->pass_flags & GCM_INSTR_PLACED)) {
diff --git a/src/compiler/nir/nir_opt_idiv_const.c b/src/compiler/nir/nir_opt_idiv_const.c
index 20f1e596d4c0d..ca64563c25efa 100644
--- a/src/compiler/nir/nir_opt_idiv_const.c
+++ b/src/compiler/nir/nir_opt_idiv_const.c
@@ -204,7 +204,7 @@ nir_opt_idiv_const_instr(nir_builder *b, nir_alu_instr *alu, void *user_data)
          q[comp] = build_irem(b, n, d);
          break;
       default:
-         unreachable("Unknown integer division op");
+         UNREACHABLE("Unknown integer division op");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_if.c b/src/compiler/nir/nir_opt_if.c
index 66398c4e3f21d..077a8b226469e 100644
--- a/src/compiler/nir/nir_opt_if.c
+++ b/src/compiler/nir/nir_opt_if.c
@@ -49,7 +49,7 @@ find_continue_block(nir_loop *loop)
          return (nir_block *)pred_entry->key;
    }
 
-   unreachable("Continue block not found!");
+   UNREACHABLE("Continue block not found!");
 }
 
 /**
@@ -1354,7 +1354,7 @@ opt_if_cf_list(nir_builder *b, struct exec_list *cf_list,
       }
 
       case nir_cf_node_function:
-         unreachable("Invalid cf type");
+         UNREACHABLE("Invalid cf type");
       }
    }
 
@@ -1390,7 +1390,7 @@ opt_if_regs_cf_list(struct exec_list *cf_list)
       }
 
       case nir_cf_node_function:
-         unreachable("Invalid cf type");
+         UNREACHABLE("Invalid cf type");
       }
    }
 
@@ -1430,7 +1430,7 @@ opt_if_safe_cf_list(nir_builder *b, struct exec_list *cf_list, nir_opt_if_option
       }
 
       case nir_cf_node_function:
-         unreachable("Invalid cf type");
+         UNREACHABLE("Invalid cf type");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_large_constants.c b/src/compiler/nir/nir_opt_large_constants.c
index fb4346ce50639..e7b288838bb28 100644
--- a/src/compiler/nir/nir_opt_large_constants.c
+++ b/src/compiler/nir/nir_opt_large_constants.c
@@ -65,7 +65,7 @@ read_const_values(nir_const_value *dst, const void *src,
       break;
 
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
 }
 
@@ -106,7 +106,7 @@ write_const_values(void *dst, const nir_const_value *src,
       break;
 
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
 }
 
diff --git a/src/compiler/nir/nir_opt_licm.c b/src/compiler/nir/nir_opt_licm.c
index 905a87dc6d358..0b2c6aefe5669 100644
--- a/src/compiler/nir/nir_opt_licm.c
+++ b/src/compiler/nir/nir_opt_licm.c
@@ -115,7 +115,7 @@ visit_cf_list(struct exec_list *list, nir_block *preheader, nir_block *exit)
          break;
       }
       case nir_cf_node_function:
-         unreachable("NIR LICM: Unsupported cf_node type.");
+         UNREACHABLE("NIR LICM: Unsupported cf_node type.");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_load_store_vectorize.c b/src/compiler/nir/nir_opt_load_store_vectorize.c
index 9838f062de50f..a8c4d4b3d2b9b 100644
--- a/src/compiler/nir/nir_opt_load_store_vectorize.c
+++ b/src/compiler/nir/nir_opt_load_store_vectorize.c
@@ -385,7 +385,7 @@ add_to_entry_key(nir_scalar *offset_defs, uint64_t *offset_defs_mul,
          return 0;
       }
    }
-   unreachable("Unreachable.");
+   UNREACHABLE("Unreachable.");
    return 0;
 }
 
@@ -454,7 +454,7 @@ create_entry_key_from_deref(void *mem_ctx,
          break;
       }
       default:
-         unreachable("Unhandled deref type");
+         UNREACHABLE("Unhandled deref type");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_loop.c b/src/compiler/nir/nir_opt_loop.c
index a054c42c4464d..12532244012eb 100644
--- a/src/compiler/nir/nir_opt_loop.c
+++ b/src/compiler/nir/nir_opt_loop.c
@@ -696,7 +696,7 @@ opt_loop_cf_list(nir_builder *b, struct exec_list *cf_list,
       }
 
       case nir_cf_node_function:
-         unreachable("Invalid cf type");
+         UNREACHABLE("Invalid cf type");
       }
    }
 
diff --git a/src/compiler/nir/nir_opt_loop_unroll.c b/src/compiler/nir/nir_opt_loop_unroll.c
index e93bce54b45a2..77dcf19444734 100644
--- a/src/compiler/nir/nir_opt_loop_unroll.c
+++ b/src/compiler/nir/nir_opt_loop_unroll.c
@@ -1006,7 +1006,7 @@ process_loops(nir_shader *sh, nir_cf_node *cf_node, bool *has_nested_loop_out,
       break;
    }
    default:
-      unreachable("unknown cf node type");
+      UNREACHABLE("unknown cf node type");
    }
 
    const bool unrolled_child_block = progress;
diff --git a/src/compiler/nir/nir_opt_move_discards_to_top.c b/src/compiler/nir/nir_opt_move_discards_to_top.c
index 38ca946f7d1b9..73a8754f5937f 100644
--- a/src/compiler/nir/nir_opt_move_discards_to_top.c
+++ b/src/compiler/nir/nir_opt_move_discards_to_top.c
@@ -290,7 +290,7 @@ opt_move_discards_to_top_impl(nir_function_impl *impl)
          }
 
          case nir_instr_type_parallel_copy:
-            unreachable("Unhanded instruction type");
+            UNREACHABLE("Unhanded instruction type");
          }
       }
    }
diff --git a/src/compiler/nir/nir_opt_offsets.c b/src/compiler/nir/nir_opt_offsets.c
index adaeb73c42fe2..eb8d8767209a2 100644
--- a/src/compiler/nir/nir_opt_offsets.c
+++ b/src/compiler/nir/nir_opt_offsets.c
@@ -236,7 +236,7 @@ process_instr(nir_builder *b, nir_instr *instr, void *s)
       return false;
    }
 
-   unreachable("Can't reach here.");
+   UNREACHABLE("Can't reach here.");
 }
 
 bool
diff --git a/src/compiler/nir/nir_opt_phi_precision.c b/src/compiler/nir/nir_opt_phi_precision.c
index f37adda2c8a03..7b204841c8932 100644
--- a/src/compiler/nir/nir_opt_phi_precision.c
+++ b/src/compiler/nir/nir_opt_phi_precision.c
@@ -289,7 +289,7 @@ can_convert_load_const(nir_load_const_instr *lc, nir_op op)
             return false;
          break;
       default:
-         unreachable("bad type");
+         UNREACHABLE("bad type");
          return false;
       }
    }
diff --git a/src/compiler/nir/nir_opt_phi_to_bool.c b/src/compiler/nir/nir_opt_phi_to_bool.c
index e2673fda9f909..31ae3d2f96718 100644
--- a/src/compiler/nir/nir_opt_phi_to_bool.c
+++ b/src/compiler/nir/nir_opt_phi_to_bool.c
@@ -185,7 +185,7 @@ phi_to_bool(nir_builder *b, nir_phi_instr *phi, void *unused)
    else if (type == bool_type_float)
       res = nir_b2fN(b, res, bit_size);
    else
-      unreachable("invalid bool_type");
+      UNREACHABLE("invalid bool_type");
 
    nir_foreach_use_safe(src, &phi->def) {
       if (nir_src_parent_instr(src) == &phi->instr ||
diff --git a/src/compiler/nir/nir_opt_preamble.c b/src/compiler/nir/nir_opt_preamble.c
index da86130c67544..d620d881cd122 100644
--- a/src/compiler/nir/nir_opt_preamble.c
+++ b/src/compiler/nir/nir_opt_preamble.c
@@ -450,7 +450,7 @@ calculate_can_move_for_cf_list(opt_preamble_ctx *ctx, struct exec_list *list)
       }
 
       default:
-         unreachable("Unexpected CF node type");
+         UNREACHABLE("Unexpected CF node type");
       }
    }
 
@@ -500,7 +500,7 @@ replace_for_block(nir_builder *b, opt_preamble_ctx *ctx,
                assert(else_def == NULL);
                else_def = phi_src->src.ssa;
             } else {
-               unreachable("Invalid predecessor for phi of if");
+               UNREACHABLE("Invalid predecessor for phi of if");
             }
          }
 
@@ -600,7 +600,7 @@ replace_for_cf_list(nir_builder *b, opt_preamble_ctx *ctx,
       }
 
       default:
-         unreachable("Unexpected CF node type");
+         UNREACHABLE("Unexpected CF node type");
       }
    }
 }
diff --git a/src/compiler/nir/nir_opt_varyings.c b/src/compiler/nir/nir_opt_varyings.c
index bf482d22af042..b1dff7251635f 100644
--- a/src/compiler/nir/nir_opt_varyings.c
+++ b/src/compiler/nir/nir_opt_varyings.c
@@ -995,7 +995,7 @@ get_interp_vec4_type(struct linkage_info *linkage, unsigned slot,
    else if (load->def.bit_size == 16)
       base = FS_VEC4_TYPE_INTERP_FP16_PERSP_PIXEL;
    else
-      unreachable("invalid load_interpolated_input type");
+      UNREACHABLE("invalid load_interpolated_input type");
 
    bool linear = nir_intrinsic_interp_mode(baryc) == INTERP_MODE_NOPERSPECTIVE;
 
@@ -1012,7 +1012,7 @@ get_interp_vec4_type(struct linkage_info *linkage, unsigned slot,
    case nir_intrinsic_load_barycentric_sample:
       return base + 2;
    default:
-      unreachable("unexpected barycentric intrinsic");
+      UNREACHABLE("unexpected barycentric intrinsic");
    }
 }
 
@@ -1323,13 +1323,13 @@ gather_inputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_d
             else if (intr->def.bit_size == 16)
                fs_vec4_type = FS_VEC4_TYPE_INTERP_FP16;
             else
-               unreachable("invalid load_interpolated_input type");
+               UNREACHABLE("invalid load_interpolated_input type");
          } else {
             fs_vec4_type = get_interp_vec4_type(linkage, slot, intr);
          }
          break;
       default:
-         unreachable("unexpected input load intrinsic");
+         UNREACHABLE("unexpected input load intrinsic");
       }
 
       linkage->fs_vec4_type[sem.location] = fs_vec4_type;
@@ -1421,7 +1421,7 @@ gather_inputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_d
          break;
 
       case FS_VEC4_TYPE_NONE:
-         unreachable("unexpected fs_vec4_type");
+         UNREACHABLE("unexpected fs_vec4_type");
       }
 
       if (!linkage->has_flexible_interp &&
@@ -1461,7 +1461,7 @@ gather_inputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_d
       else if (intr->def.bit_size == 16)
          BITSET_SET(linkage->flat16_mask, slot);
       else
-         unreachable("invalid load_input type");
+         UNREACHABLE("invalid load_input type");
 
       if (linkage->consumer_stage == MESA_SHADER_TESS_CTRL &&
           intr->intrinsic == nir_intrinsic_load_per_vertex_input) {
@@ -1474,7 +1474,7 @@ gather_inputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_d
             else if (intr->def.bit_size == 16)
                BITSET_SET(linkage->cross_invoc16_mask, slot);
             else
-               unreachable("invalid load_input type");
+               UNREACHABLE("invalid load_input type");
          }
       }
    }
@@ -1565,7 +1565,7 @@ gather_outputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_
             else if (intr->src[0].ssa->bit_size == 16)
                BITSET_SET(linkage->xfb16_only_mask, slot);
             else
-               unreachable("invalid load_input type");
+               UNREACHABLE("invalid load_input type");
          }
       }
    } else {
@@ -1625,7 +1625,7 @@ gather_outputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_
             else if (value.def->bit_size == 16)
                BITSET_SET(linkage->convergent16_mask, slot);
             else
-               unreachable("invalid store_output type");
+               UNREACHABLE("invalid store_output type");
          }
       } else {
          /* There are multiple stores to the same output. If they store
@@ -1641,7 +1641,7 @@ gather_outputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_
             else if (value.def->bit_size == 16)
                BITSET_CLEAR(linkage->convergent16_mask, slot);
             else
-               unreachable("invalid store_output type");
+               UNREACHABLE("invalid store_output type");
          }
       }
 
@@ -1656,7 +1656,7 @@ gather_outputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_
             else if (value.def->bit_size == 16)
                BITSET_SET(linkage->cross_invoc16_mask, slot);
             else
-               unreachable("invalid store_output type");
+               UNREACHABLE("invalid store_output type");
          }
       }
    } else {
@@ -1676,7 +1676,7 @@ gather_outputs(struct nir_builder *builder, nir_intrinsic_instr *intr, void *cb_
       else if (intr->def.bit_size == 16)
          BITSET_SET(linkage->flat16_mask, slot);
       else
-         unreachable("invalid load_input type");
+         UNREACHABLE("invalid load_input type");
    }
    return false;
 }
@@ -1959,7 +1959,7 @@ remove_all_stores(struct linkage_info *linkage, unsigned i,
                else if (iter->instr->src[0].ssa->bit_size == 16)
                   BITSET_SET(linkage->xfb16_only_mask, i);
                else
-                  unreachable("invalid load_input type");
+                  UNREACHABLE("invalid load_input type");
             }
          }
       }
@@ -2187,7 +2187,7 @@ find_per_vertex_load_for_tes_interp(nir_instr *instr)
    }
 
    default:
-      unreachable("unexpected instruction type");
+      UNREACHABLE("unexpected instruction type");
    }
 }
 
@@ -2298,7 +2298,7 @@ clone_ssa_impl(struct linkage_info *linkage, nir_builder *b, nir_def *ssa)
       }
 
       default:
-         unreachable("unexpected intrinsic");
+         UNREACHABLE("unexpected intrinsic");
       }
       break;
    }
@@ -2338,14 +2338,14 @@ clone_ssa_impl(struct linkage_info *linkage, nir_builder *b, nir_def *ssa)
                         ->def;
             break;
          default:
-            unreachable("invalid deref type");
+            UNREACHABLE("invalid deref type");
          }
       }
       break;
    }
 
    default:
-      unreachable("unexpected instruction type");
+      UNREACHABLE("unexpected instruction type");
    }
 
    _mesa_hash_table_insert(linkage->clones_ht, ssa->parent_instr, clone);
@@ -2672,7 +2672,7 @@ get_input_qualifier(struct linkage_info *linkage, unsigned i)
       /* Don't deduplicate outputs that are interpolated at offset/sample. */
       return QUAL_SKIP;
    default:
-      unreachable("unexpected barycentric src");
+      UNREACHABLE("unexpected barycentric src");
    }
 
    switch (nir_intrinsic_interp_mode(baryc)) {
@@ -2686,7 +2686,7 @@ get_input_qualifier(struct linkage_info *linkage, unsigned i)
       qual = is_color ? QUAL_COLOR_LINEAR_PIXEL : QUAL_VAR_LINEAR_PIXEL;
       break;
    default:
-      unreachable("unexpected interp mode");
+      UNREACHABLE("unexpected interp mode");
    }
 
    /* The ordering of the "qual" enum was carefully chosen to make this
@@ -3404,7 +3404,7 @@ gather_used_input_loads(nir_instr *instr,
 
       default:
          printf("%u\n", intr->intrinsic);
-         unreachable("unexpected intrinsic");
+         UNREACHABLE("unexpected intrinsic");
       }
    }
 
@@ -3426,12 +3426,12 @@ gather_used_input_loads(nir_instr *instr,
          return;
 
       default:
-         unreachable("unexpected deref type");
+         UNREACHABLE("unexpected deref type");
       }
    }
 
    default:
-      unreachable("unexpected instr type");
+      UNREACHABLE("unexpected instr type");
    }
 }
 
@@ -3639,7 +3639,7 @@ try_move_postdominator(struct linkage_info *linkage,
          remap = remap_wuv;
          break;
       default:
-         unreachable("invalid TES interpolation mode");
+         UNREACHABLE("invalid TES interpolation mode");
       }
 
       nir_def *tesscoord = slot->consumer.tes_load_tess_coord;
@@ -4012,7 +4012,7 @@ backward_inter_shader_code_motion(struct linkage_info *linkage,
             /* Inter-shader code motion is unimplemented these. */
             continue;
          default:
-            unreachable("unexpected load intrinsic");
+            UNREACHABLE("unexpected load intrinsic");
          }
       }
 
@@ -4117,7 +4117,7 @@ backward_inter_shader_code_motion(struct linkage_info *linkage,
 
                bit_size = intr->def.bit_size;
             } else {
-               unreachable("unexpected instr type");
+               UNREACHABLE("unexpected instr type");
             }
 
             /* Skip unsupported bit sizes and keep searching. */
@@ -4388,7 +4388,7 @@ relocate_slot(struct linkage_info *linkage, struct scalar_slot *slot,
                                                       .interp_mode = INTERP_MODE_NONE);
                   break;
                default:
-                  unreachable("invalid qualifier");
+                  UNREACHABLE("invalid qualifier");
                }
 
                nir_src_rewrite(&intr->src[0], baryc);
@@ -5202,7 +5202,7 @@ default_varying_estimate_instr_cost(nir_instr *instr)
          return 2 * num_dst_dwords;
 
       default:
-         unreachable("unexpected intrinsic");
+         UNREACHABLE("unexpected intrinsic");
       }
 
    case nir_instr_type_deref: {
@@ -5220,12 +5220,12 @@ default_varying_estimate_instr_cost(nir_instr *instr)
          return nir_src_is_const(deref->arr.index) ? 0 : 128;
 
       default:
-         unreachable("unexpected deref type");
+         UNREACHABLE("unexpected deref type");
       }
    }
 
    default:
-      unreachable("unexpected instr type");
+      UNREACHABLE("unexpected instr type");
    }
 }
 
diff --git a/src/compiler/nir/nir_opt_vectorize.c b/src/compiler/nir/nir_opt_vectorize.c
index 39789a7c0f276..edf153b76996c 100644
--- a/src/compiler/nir/nir_opt_vectorize.c
+++ b/src/compiler/nir/nir_opt_vectorize.c
@@ -526,7 +526,7 @@ instr_try_combine(struct set *instr_set, nir_instr *instr1, nir_instr *instr2)
                                    nir_instr_as_phi(instr2));
 
    default:
-      unreachable("Unsupported instruction type");
+      UNREACHABLE("Unsupported instruction type");
    }
 }
 
diff --git a/src/compiler/nir/nir_opt_vectorize_io_vars.c b/src/compiler/nir/nir_opt_vectorize_io_vars.c
index 79acfbeb24cb2..c864912f7f6ae 100644
--- a/src/compiler/nir/nir_opt_vectorize_io_vars.c
+++ b/src/compiler/nir/nir_opt_vectorize_io_vars.c
@@ -356,7 +356,7 @@ build_array_index(nir_builder *b, nir_deref_instr *deref, nir_def *base,
          nir_amul_imm(b, index, glsl_count_attribute_slots(deref->type, vs_in)));
    }
    default:
-      unreachable("Invalid deref instruction type");
+      UNREACHABLE("Invalid deref instruction type");
    }
 }
 
diff --git a/src/compiler/nir/nir_passthrough_gs.c b/src/compiler/nir/nir_passthrough_gs.c
index 52be1b9d8c88c..94c32759cc38d 100644
--- a/src/compiler/nir/nir_passthrough_gs.c
+++ b/src/compiler/nir/nir_passthrough_gs.c
@@ -89,7 +89,7 @@ vertices_for_prim(enum mesa_prim prim)
       return 4;
    case MESA_PRIM_PATCHES:
    default:
-      unreachable("unsupported primitive for gs input");
+      UNREACHABLE("unsupported primitive for gs input");
    }
 }
 
diff --git a/src/compiler/nir/nir_precompiled.h b/src/compiler/nir/nir_precompiled.h
index bd78acde438bf..39d5233318dc5 100644
--- a/src/compiler/nir/nir_precompiled.h
+++ b/src/compiler/nir/nir_precompiled.h
@@ -263,7 +263,7 @@ nir_precomp_index(const nir_shader *lib, const nir_function *func)
       i += nir_precomp_nr_variants(candidate);
    }
 
-   unreachable("function must be in library");
+   UNREACHABLE("function must be in library");
 }
 
 static inline void
diff --git a/src/compiler/nir/nir_print.c b/src/compiler/nir/nir_print.c
index db76a9def1dd7..7d65432c75e77 100644
--- a/src/compiler/nir/nir_print.c
+++ b/src/compiler/nir/nir_print.c
@@ -192,7 +192,7 @@ print_hex_padded_const_value(const nir_const_value *value, unsigned bit_size, FI
       fprintf(fp, "0x%02x", value->u8);
       break;
    default:
-      unreachable("unhandled bit size");
+      UNREACHABLE("unhandled bit size");
    }
 }
 
@@ -213,7 +213,7 @@ print_hex_terse_const_value(const nir_const_value *value, unsigned bit_size, FIL
       fprintf(fp, "0x%x", value->u8);
       break;
    default:
-      unreachable("unhandled bit size");
+      UNREACHABLE("unhandled bit size");
    }
 }
 
@@ -245,7 +245,7 @@ print_int_const_value(const nir_const_value *value, unsigned bit_size, FILE *fp)
       fprintf(fp, "%+d", value->i8);
       break;
    default:
-      unreachable("unhandled bit size");
+      UNREACHABLE("unhandled bit size");
    }
 }
 
@@ -266,7 +266,7 @@ print_uint_const_value(const nir_const_value *value, unsigned bit_size, FILE *fp
       fprintf(fp, "%u", value->u8);
       break;
    default:
-      unreachable("unhandled bit size");
+      UNREACHABLE("unhandled bit size");
    }
 }
 
@@ -309,7 +309,7 @@ print_const_from_load(nir_load_const_instr *instr, print_state *state, nir_alu_t
             break;
 
          default:
-            unreachable("invalid nir alu base type");
+            UNREACHABLE("invalid nir alu base type");
          }
       }
    } else {
@@ -351,7 +351,7 @@ print_const_from_load(nir_load_const_instr *instr, print_state *state, nir_alu_t
             needs_decimal |= v->u8 >= 10;
             break;
          default:
-            unreachable("invalid bit size");
+            UNREACHABLE("invalid bit size");
          }
       }
 
@@ -567,7 +567,7 @@ get_constant_sampler_addressing_mode(enum cl_sampler_addressing_mode mode)
    case SAMPLER_ADDRESSING_MODE_REPEAT_MIRRORED:
       return "repeat_mirrored";
    default:
-      unreachable("Invalid addressing mode");
+      UNREACHABLE("Invalid addressing mode");
    }
 }
 
@@ -580,7 +580,7 @@ get_constant_sampler_filter_mode(enum cl_sampler_filter_mode mode)
    case SAMPLER_FILTER_MODE_LINEAR:
       return "linear";
    default:
-      unreachable("Invalid filter mode");
+      UNREACHABLE("Invalid filter mode");
    }
 }
 
@@ -676,7 +676,7 @@ print_constant(nir_constant *c, const struct glsl_type *type, print_state *state
             break;
 
          default:
-            unreachable("Cannot get here from the first level switch");
+            UNREACHABLE("Cannot get here from the first level switch");
          }
       }
       break;
@@ -724,7 +724,7 @@ print_constant(nir_constant *c, const struct glsl_type *type, print_state *state
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1070,7 +1070,7 @@ print_deref_link(const nir_deref_instr *instr, bool whole_chain, print_state *st
       break;
 
    default:
-      unreachable("Invalid deref instruction type");
+      UNREACHABLE("Invalid deref instruction type");
    }
 }
 
@@ -1099,7 +1099,7 @@ print_deref_instr(nir_deref_instr *instr, print_state *state)
       fprintf(fp, " = deref_ptr_as_array ");
       break;
    default:
-      unreachable("Invalid deref instruction type");
+      UNREACHABLE("Invalid deref instruction type");
    }
 
    /* Only casts naturally return a pointer type */
@@ -1714,7 +1714,7 @@ print_intrinsic_instr(nir_intrinsic_instr *instr, print_state *state)
          else if (cls == nir_preamble_class_sampler)
             fprintf(fp, "class=sampler");
          else
-            unreachable("invalid class");
+            UNREACHABLE("invalid class");
 
          break;
       }
@@ -1869,7 +1869,7 @@ print_tex_instr(nir_tex_instr *instr, print_state *state)
       fprintf(fp, "sample_pos_nv ");
       break;
    default:
-      unreachable("Invalid texture operation");
+      UNREACHABLE("Invalid texture operation");
       break;
    }
 
@@ -1958,7 +1958,7 @@ print_tex_instr(nir_tex_instr *instr, print_state *state)
          break;
 
       default:
-         unreachable("Invalid texture source type");
+         UNREACHABLE("Invalid texture source type");
          break;
       }
    }
@@ -2194,7 +2194,7 @@ print_instr(const nir_instr *instr, print_state *state, unsigned tabs)
       break;
 
    default:
-      unreachable("Invalid instruction type");
+      UNREACHABLE("Invalid instruction type");
       break;
    }
 
@@ -2381,7 +2381,7 @@ print_cf_node(nir_cf_node *node, print_state *state, unsigned int tabs)
       break;
 
    default:
-      unreachable("Invalid CFG node type");
+      UNREACHABLE("Invalid CFG node type");
    }
 }
 
diff --git a/src/compiler/nir/nir_propagate_invariant.c b/src/compiler/nir/nir_propagate_invariant.c
index 8bc479424b888..f29f8832b4366 100644
--- a/src/compiler/nir/nir_propagate_invariant.c
+++ b/src/compiler/nir/nir_propagate_invariant.c
@@ -141,11 +141,11 @@ propagate_invariant_instr(nir_instr *instr, struct set *invariants)
    }
 
    case nir_instr_type_call:
-      unreachable("This pass must be run after function inlining");
+      UNREACHABLE("This pass must be run after function inlining");
 
    case nir_instr_type_parallel_copy:
    default:
-      unreachable("Cannot have this instruction type");
+      UNREACHABLE("Cannot have this instruction type");
    }
 }
 
diff --git a/src/compiler/nir/nir_range_analysis.c b/src/compiler/nir/nir_range_analysis.c
index becbc7681cdd7..ba20b21f87354 100644
--- a/src/compiler/nir/nir_range_analysis.c
+++ b/src/compiler/nir/nir_range_analysis.c
@@ -287,7 +287,7 @@ analyze_constant(const struct nir_alu_instr *instr, unsigned src,
    }
 
    default:
-      unreachable("Invalid alu source type");
+      UNREACHABLE("Invalid alu source type");
    }
 }
 
@@ -521,7 +521,7 @@ get_fp_key(struct analysis_query *q)
       type_encoding = 3;
       break;
    default:
-      unreachable("Invalid base type.");
+      UNREACHABLE("Invalid base type.");
    }
 
    return ptr | type_encoding;
diff --git a/src/compiler/nir/nir_schedule.c b/src/compiler/nir/nir_schedule.c
index b8c815879a193..f0340c949ab07 100644
--- a/src/compiler/nir/nir_schedule.c
+++ b/src/compiler/nir/nir_schedule.c
@@ -477,15 +477,15 @@ nir_schedule_calculate_deps(nir_deps_state *state, nir_schedule_node *n)
       break;
 
    case nir_instr_type_call:
-      unreachable("Calls should have been lowered");
+      UNREACHABLE("Calls should have been lowered");
       break;
 
    case nir_instr_type_parallel_copy:
-      unreachable("Parallel copies should have been lowered");
+      UNREACHABLE("Parallel copies should have been lowered");
       break;
 
    case nir_instr_type_phi:
-      unreachable("nir_schedule() should be called after lowering from SSA");
+      UNREACHABLE("nir_schedule() should be called after lowering from SSA");
       break;
 
    case nir_instr_type_intrinsic:
diff --git a/src/compiler/nir/nir_search.c b/src/compiler/nir/nir_search.c
index 8faed29201e78..163d2796810a2 100644
--- a/src/compiler/nir/nir_search.c
+++ b/src/compiler/nir/nir_search.c
@@ -144,7 +144,7 @@ nir_op_matches_search_op(nir_op nop, uint16_t sop)
       MATCH_FCONV_CASE(b2f)
       MATCH_ICONV_CASE(b2i)
    default:
-      unreachable("Invalid nir_search_op");
+      UNREACHABLE("Invalid nir_search_op");
    }
 
 #undef MATCH_FCONV_CASE
@@ -201,7 +201,7 @@ nir_op_for_search_op(uint16_t sop, unsigned bit_size)
       case 64:                            \
          return nir_op_##op##64;          \
       default:                            \
-         unreachable("Invalid bit size"); \
+         UNREACHABLE("Invalid bit size"); \
       }
 
 #define RET_ICONV_CASE(op)                \
@@ -216,7 +216,7 @@ nir_op_for_search_op(uint16_t sop, unsigned bit_size)
       case 64:                            \
          return nir_op_##op##64;          \
       default:                            \
-         unreachable("Invalid bit size"); \
+         UNREACHABLE("Invalid bit size"); \
       }
 
    switch (sop) {
@@ -230,7 +230,7 @@ nir_op_for_search_op(uint16_t sop, unsigned bit_size)
       RET_FCONV_CASE(b2f)
       RET_ICONV_CASE(b2i)
    default:
-      unreachable("Invalid nir_search_op");
+      UNREACHABLE("Invalid nir_search_op");
    }
 
 #undef RET_FCONV_CASE
@@ -353,12 +353,12 @@ match_value(const nir_algebraic_table *table,
       }
 
       default:
-         unreachable("Invalid alu source type");
+         UNREACHABLE("Invalid alu source type");
       }
    }
 
    default:
-      unreachable("Invalid search value type");
+      UNREACHABLE("Invalid search value type");
    }
 }
 
@@ -539,7 +539,7 @@ construct_value(nir_builder *build,
          break;
 
       default:
-         unreachable("Invalid alu source type");
+         UNREACHABLE("Invalid alu source type");
       }
 
       assert(cval->index ==
@@ -556,7 +556,7 @@ construct_value(nir_builder *build,
    }
 
    default:
-      unreachable("Invalid search value type");
+      UNREACHABLE("Invalid search value type");
    }
 }
 
@@ -580,7 +580,7 @@ dump_value(const nir_algebraic_table *table, const nir_search_value *val)
          fprintf(stderr, "%s", sconst->data.u != 0 ? "True" : "False");
          break;
       default:
-         unreachable("bad const type");
+         UNREACHABLE("bad const type");
       }
       break;
    }
diff --git a/src/compiler/nir/nir_serialize.c b/src/compiler/nir/nir_serialize.c
index 197fdab4e0567..cd5eca5a5cbc5 100644
--- a/src/compiler/nir/nir_serialize.c
+++ b/src/compiler/nir/nir_serialize.c
@@ -173,7 +173,7 @@ decode_num_components_in_3bits(uint8_t value)
    if (value == 6)
       return 16;
 
-   unreachable("invalid num_components encoding");
+   UNREACHABLE("invalid num_components encoding");
    return 0;
 }
 
@@ -953,7 +953,7 @@ write_deref(write_ctx *ctx, const nir_deref_instr *deref)
       break;
 
    default:
-      unreachable("Invalid deref type");
+      UNREACHABLE("Invalid deref type");
    }
 }
 
@@ -1023,7 +1023,7 @@ read_deref(read_ctx *ctx, union packed_instr header)
       break;
 
    default:
-      unreachable("Invalid deref type");
+      UNREACHABLE("Invalid deref type");
    }
 
    if (deref_type == nir_deref_type_var) {
@@ -1213,7 +1213,7 @@ write_load_const(write_ctx *ctx, const nir_load_const_instr *lc)
          header.load_const.packed_value = lc->value[0].b;
          break;
       default:
-         unreachable("invalid bit_size");
+         UNREACHABLE("invalid bit_size");
       }
    }
 
@@ -1264,7 +1264,7 @@ read_load_const(read_ctx *ctx, union packed_instr header)
          lc->value[0].u32 = (uint64_t)header.load_const.packed_value << 13;
          break;
       default:
-         unreachable("invalid bit_size");
+         UNREACHABLE("invalid bit_size");
       }
       break;
 
@@ -1290,7 +1290,7 @@ read_load_const(read_ctx *ctx, union packed_instr header)
          lc->value[0].b = header.load_const.packed_value;
          break;
       default:
-         unreachable("invalid bit_size");
+         UNREACHABLE("invalid bit_size");
       }
       break;
 
@@ -1707,9 +1707,9 @@ write_instr(write_ctx *ctx, const nir_instr *instr)
       write_call(ctx, nir_instr_as_call(instr));
       break;
    case nir_instr_type_parallel_copy:
-      unreachable("Cannot write parallel copies");
+      UNREACHABLE("Cannot write parallel copies");
    default:
-      unreachable("bad instr type");
+      UNREACHABLE("bad instr type");
    }
 }
 
@@ -1761,9 +1761,9 @@ read_instr(read_ctx *ctx, nir_block *block)
       instr = &read_call(ctx)->instr;
       break;
    case nir_instr_type_parallel_copy:
-      unreachable("Cannot read parallel copies");
+      UNREACHABLE("Cannot read parallel copies");
    default:
-      unreachable("bad instr type");
+      UNREACHABLE("bad instr type");
    }
 
    if (unlikely(ctx->nir->has_debug_info)) {
@@ -1883,7 +1883,7 @@ write_cf_node(write_ctx *ctx, nir_cf_node *cf)
       write_loop(ctx, nir_cf_node_as_loop(cf));
       break;
    default:
-      unreachable("bad cf type");
+      UNREACHABLE("bad cf type");
    }
 }
 
@@ -1903,7 +1903,7 @@ read_cf_node(read_ctx *ctx, struct exec_list *list)
       read_loop(ctx, list);
       break;
    default:
-      unreachable("bad cf type");
+      UNREACHABLE("bad cf type");
    }
 }
 
diff --git a/src/compiler/nir/nir_split_64bit_vec3_and_vec4.c b/src/compiler/nir/nir_split_64bit_vec3_and_vec4.c
index 4a5511ce00b58..5b41aaa32fc57 100644
--- a/src/compiler/nir/nir_split_64bit_vec3_and_vec4.c
+++ b/src/compiler/nir/nir_split_64bit_vec3_and_vec4.c
@@ -120,7 +120,7 @@ get_linear_array_offset(nir_builder *b, nir_deref_instr *deref)
          break;
       }
       default:
-         unreachable("Not part of the path");
+         UNREACHABLE("Not part of the path");
       }
    }
    nir_deref_path_finish(&path);
@@ -279,7 +279,7 @@ nir_split_64bit_vec3_and_vec4_impl(nir_builder *b, nir_instr *instr, void *d)
          else if (deref->deref_type == nir_deref_type_array) {
             return split_load_deref(b, intr, get_linear_array_offset(b, deref), split_vars);
          } else
-            unreachable("Only splitting of loads from vars and arrays");
+            UNREACHABLE("Only splitting of loads from vars and arrays");
       }
 
       case nir_intrinsic_store_deref: {
@@ -290,11 +290,11 @@ nir_split_64bit_vec3_and_vec4_impl(nir_builder *b, nir_instr *instr, void *d)
          else if (deref->deref_type == nir_deref_type_array)
             return split_store_deref(b, intr, get_linear_array_offset(b, deref), split_vars);
          else
-            unreachable("Only splitting of stores to vars and arrays");
+            UNREACHABLE("Only splitting of stores to vars and arrays");
       }
 
       default:
-         unreachable("Only splitting load_deref and store_deref");
+         UNREACHABLE("Only splitting load_deref and store_deref");
       }
    }
 
@@ -304,7 +304,7 @@ nir_split_64bit_vec3_and_vec4_impl(nir_builder *b, nir_instr *instr, void *d)
    }
 
    default:
-      unreachable("Only splitting load_deref/store_deref and phi");
+      UNREACHABLE("Only splitting load_deref/store_deref and phi");
    }
 
    return NULL;
diff --git a/src/compiler/nir/nir_split_vars.c b/src/compiler/nir/nir_split_vars.c
index baeffb9bf00b7..812d2c681202a 100644
--- a/src/compiler/nir/nir_split_vars.c
+++ b/src/compiler/nir/nir_split_vars.c
@@ -326,7 +326,7 @@ split_struct_derefs_impl(nir_function_impl *impl,
                break;
 
             default:
-               unreachable("Invalid deref type in path");
+               UNREACHABLE("Invalid deref type in path");
             }
          }
 
diff --git a/src/compiler/nir/nir_sweep.c b/src/compiler/nir/nir_sweep.c
index 2ed2e1fa32b2c..8716ba907682e 100644
--- a/src/compiler/nir/nir_sweep.c
+++ b/src/compiler/nir/nir_sweep.c
@@ -113,7 +113,7 @@ sweep_cf_node(nir_shader *nir, nir_cf_node *cf_node)
       sweep_loop(nir, nir_cf_node_as_loop(cf_node));
       break;
    default:
-      unreachable("Invalid CF node type");
+      UNREACHABLE("Invalid CF node type");
    }
 }
 
diff --git a/src/compiler/nir/nir_to_lcssa.c b/src/compiler/nir/nir_to_lcssa.c
index 9fc9fb629ff31..cd80be5413939 100644
--- a/src/compiler/nir/nir_to_lcssa.c
+++ b/src/compiler/nir/nir_to_lcssa.c
@@ -366,7 +366,7 @@ convert_to_lcssa(nir_cf_node *cf_node, lcssa_state *state)
       return;
    }
    default:
-      unreachable("unknown cf node type");
+      UNREACHABLE("unknown cf node type");
    }
 }
 
diff --git a/src/compiler/nir/nir_use_dominance.c b/src/compiler/nir/nir_use_dominance.c
index 540846f903e85..e0c59e42ec0b2 100644
--- a/src/compiler/nir/nir_use_dominance.c
+++ b/src/compiler/nir/nir_use_dominance.c
@@ -207,7 +207,7 @@ calc_dominance(struct nir_use_dominance_state *state,
       if (!has_use)
          update_imm_dom(state, &state->dom_nodes[0], &new_idom);
    } else {
-      unreachable("TODO: only post-dominance implemented, not dominance");
+      UNREACHABLE("TODO: only post-dominance implemented, not dominance");
    }
 
    if (new_idom && node->imm_dom != new_idom->index) {
diff --git a/src/compiler/nir/nir_validate.c b/src/compiler/nir/nir_validate.c
index 58c5383fbd425..09dd4f8c4a05c 100644
--- a/src/compiler/nir/nir_validate.c
+++ b/src/compiler/nir/nir_validate.c
@@ -409,7 +409,7 @@ validate_deref_instr(nir_deref_instr *instr, validate_state *state)
          break;
 
       default:
-         unreachable("Invalid deref instruction type");
+         UNREACHABLE("Invalid deref instruction type");
       }
    }
 
@@ -1231,7 +1231,7 @@ collect_blocks(struct exec_list *cf_list, validate_state *state)
          break;
 
       default:
-         unreachable("Invalid CF node type");
+         UNREACHABLE("Invalid CF node type");
       }
    }
 }
@@ -1362,7 +1362,7 @@ validate_block(nir_block *block, validate_state *state)
             break;
 
          default:
-            unreachable("unknown control flow node type");
+            UNREACHABLE("unknown control flow node type");
          }
       } else {
          if (next->type == nir_cf_node_if) {
@@ -1487,7 +1487,7 @@ validate_cf_node(nir_cf_node *node, validate_state *state)
       break;
 
    default:
-      unreachable("Invalid CF node type");
+      UNREACHABLE("Invalid CF node type");
    }
 }
 
diff --git a/src/compiler/nir/tests/builder_tests.cpp b/src/compiler/nir/tests/builder_tests.cpp
index 6437bacded356..45ece5bbde3a5 100644
--- a/src/compiler/nir/tests/builder_tests.cpp
+++ b/src/compiler/nir/tests/builder_tests.cpp
@@ -34,7 +34,7 @@ private:
       case 16: return glsl_u16vec_type(def->num_components);
       case 32: return glsl_uvec_type(def->num_components);
       case 64: return glsl_u64vec_type(def->num_components);
-      default: unreachable("Invalid bit size");
+      default: UNREACHABLE("Invalid bit size");
       }
    }
 
diff --git a/src/compiler/nir/tests/format_convert_tests.cpp b/src/compiler/nir/tests/format_convert_tests.cpp
index 028dc40159aef..7e86f7ec92656 100644
--- a/src/compiler/nir/tests/format_convert_tests.cpp
+++ b/src/compiler/nir/tests/format_convert_tests.cpp
@@ -138,7 +138,7 @@ rand_color(util_format_colorspace colorspace,
             return util_format_srgb_8unorm_to_linear_float(rand_uint(8));
 
          default:
-            unreachable("Unknown colorspace");
+            UNREACHABLE("Unknown colorspace");
          }
       } else {
          assert(colorspace == UTIL_FORMAT_COLORSPACE_RGB);
@@ -184,7 +184,7 @@ rand_color(util_format_colorspace colorspace,
       }
 
    default:
-      unreachable("Invalid format type");
+      UNREACHABLE("Invalid format type");
    }
 }
 
@@ -248,7 +248,7 @@ TEST_P(rgba, pack)
             EXPECT_EQ(*(uint32_t *)expected, packed[0].u32);
             break;
          default:
-            unreachable("Unsupported packed data bit size");
+            UNREACHABLE("Unsupported packed data bit size");
          }
       } else {
          assert(packed_ssa->bit_size == 32);
diff --git a/src/compiler/nir/tests/negative_equal_tests.cpp b/src/compiler/nir/tests/negative_equal_tests.cpp
index f135156a62811..5f764a7415125 100644
--- a/src/compiler/nir/tests/negative_equal_tests.cpp
+++ b/src/compiler/nir/tests/negative_equal_tests.cpp
@@ -349,7 +349,7 @@ count_sequence(nir_const_value c[NIR_MAX_VEC_COMPONENTS],
 
    case nir_type_bool:
    default:
-      unreachable("invalid base type");
+      UNREACHABLE("invalid base type");
    }
 }
 
@@ -407,6 +407,6 @@ negate(nir_const_value dst[NIR_MAX_VEC_COMPONENTS],
 
    case nir_type_bool:
    default:
-      unreachable("invalid base type");
+      UNREACHABLE("invalid base type");
    }
 }
diff --git a/src/compiler/nir/tests/nir_opt_varyings_test.h b/src/compiler/nir/tests/nir_opt_varyings_test.h
index 26ee5b67c4393..ec294ec78db4d 100644
--- a/src/compiler/nir/tests/nir_opt_varyings_test.h
+++ b/src/compiler/nir/tests/nir_opt_varyings_test.h
@@ -448,7 +448,7 @@ load_input_interp(nir_builder *b, gl_varying_slot slot, unsigned component,
       baryc = nir_load_barycentric_at_offset(b, 32, nir_imm_ivec2(b, 1, 2));
       break;
    default:
-      unreachable("invalid interp mode");
+      UNREACHABLE("invalid interp mode");
    }
 
    switch (interp) {
@@ -474,7 +474,7 @@ load_input_interp(nir_builder *b, gl_varying_slot slot, unsigned component,
                                     INTERP_MODE_NONE);
       break;
    default:
-      unreachable("invalid interp mode");
+      UNREACHABLE("invalid interp mode");
    }
 
    nir_def *def = nir_load_interpolated_input(b, 1, bit_size, baryc, zero);
@@ -522,7 +522,7 @@ load_interpolated_input_tes(nir_builder *b, gl_varying_slot slot,
       remap = remap_wuv;
       break;
    default:
-      unreachable("unexpected TES interp mode");
+      UNREACHABLE("unexpected TES interp mode");
    }
 
    bool use_ffma = interp == INTERP_TES_TRIANGLE_UVW_FFMA ||
diff --git a/src/compiler/shader_enums.c b/src/compiler/shader_enums.c
index 578c9d166b62f..bac1b92d52a4d 100644
--- a/src/compiler/shader_enums.c
+++ b/src/compiler/shader_enums.c
@@ -82,7 +82,7 @@ _mesa_shader_stage_to_string(unsigned stage)
    case MESA_SHADER_CALLABLE:     return "callable";
    }
 
-   unreachable("Unknown shader stage.");
+   UNREACHABLE("Unknown shader stage.");
 }
 
 /**
@@ -110,7 +110,7 @@ _mesa_shader_stage_to_abbrev(unsigned stage)
    case MESA_SHADER_CALLABLE:     return "RCALL";
    }
 
-   unreachable("Unknown shader stage.");
+   UNREACHABLE("Unknown shader stage.");
 }
 
 const char *
diff --git a/src/compiler/spirv/spirv_info_gen.py b/src/compiler/spirv/spirv_info_gen.py
index 135098c397d03..e664b1f5db5ca 100644
--- a/src/compiler/spirv/spirv_info_gen.py
+++ b/src/compiler/spirv/spirv_info_gen.py
@@ -144,7 +144,7 @@ spirv_capabilities_set(struct spirv_capabilities *caps,
    case SpvCapability${names[0]}: caps->${names[0]} = enabled; break;
     % endfor
    default:
-      unreachable("Unknown capability");
+      UNREACHABLE("Unknown capability");
    }
 }
 % endif
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index 6dc3422874403..baef5b6c20b6d 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -426,7 +426,7 @@ vtn_value_type_to_string(enum vtn_value_type t)
    CASE(image_pointer);
    }
 #undef CASE
-   unreachable("unknown value type");
+   UNREACHABLE("unknown value type");
    return "UNKNOWN";
 }
 
@@ -452,7 +452,7 @@ vtn_base_type_to_string(enum vtn_base_type t)
    CASE(cooperative_matrix);
    }
 #undef CASE
-   unreachable("unknown base type");
+   UNREACHABLE("unknown base type");
    return "UNKNOWN";
 }
 
@@ -1110,7 +1110,7 @@ vtn_handle_decoration(struct vtn_builder *b, SpvOp opcode,
          dec->scope = VTN_DEC_EXECUTION_MODE;
          break;
       default:
-         unreachable("Invalid decoration opcode");
+         UNREACHABLE("Invalid decoration opcode");
       }
       dec->decoration = *(w++);
       dec->num_operands = w_end - w;
@@ -1161,7 +1161,7 @@ vtn_handle_decoration(struct vtn_builder *b, SpvOp opcode,
    }
 
    default:
-      unreachable("Unhandled opcode");
+      UNREACHABLE("Unhandled opcode");
    }
 }
 
@@ -3012,7 +3012,7 @@ vtn_mem_semantics_to_nir_mem_semantics(struct vtn_builder *b,
       break;
 
    default:
-      unreachable("Invalid memory order semantics");
+      UNREACHABLE("Invalid memory order semantics");
    }
 
    if (semantics & SpvMemorySemanticsMakeAvailableMask) {
@@ -3899,7 +3899,7 @@ translate_atomic_op(SpvOp opcode)
    case SpvOpAtomicFMaxEXT:             return nir_atomic_op_fmax;
    case SpvOpAtomicFlagTestAndSet:      return nir_atomic_op_cmpxchg;
    default:
-      unreachable("Invalid atomic");
+      UNREACHABLE("Invalid atomic");
    }
 }
 
@@ -4490,7 +4490,7 @@ vtn_handle_atomics(struct vtn_builder *b, SpvOp opcode,
          break;
 
       default:
-         unreachable("Invalid SPIR-V atomic");
+         UNREACHABLE("Invalid SPIR-V atomic");
 
       }
    } else {
@@ -4914,7 +4914,7 @@ vtn_handle_barrier(struct vtn_builder *b, SpvOp opcode,
          nir_end_primitive(&b->nb, stream);
          break;
       default:
-         unreachable("Invalid opcode");
+         UNREACHABLE("Invalid opcode");
       }
       break;
    }
@@ -4976,7 +4976,7 @@ vtn_handle_barrier(struct vtn_builder *b, SpvOp opcode,
    }
 
    default:
-      unreachable("unknown barrier instruction");
+      UNREACHABLE("unknown barrier instruction");
    }
 }
 
@@ -5324,7 +5324,7 @@ vtn_handle_debug_text(struct vtn_builder *b, SpvOp opcode,
       break;
 
    default:
-      unreachable("Unhandled opcode");
+      UNREACHABLE("Unhandled opcode");
    }
 }
 
@@ -6048,7 +6048,7 @@ vtn_handle_ptr(struct vtn_builder *b, SpvOp opcode,
    }
 
    default:
-      unreachable("Invalid ptr operation");
+      UNREACHABLE("Invalid ptr operation");
    }
 
    vtn_push_nir_ssa(b, w[2], def);
diff --git a/src/compiler/spirv/vtn_alu.c b/src/compiler/spirv/vtn_alu.c
index 1a4d89c9ed8e1..2bfbab789bcee 100644
--- a/src/compiler/spirv/vtn_alu.c
+++ b/src/compiler/spirv/vtn_alu.c
@@ -149,7 +149,7 @@ vtn_mediump_downconvert(struct vtn_builder *b, enum glsl_base_type base_type, ni
    case GLSL_TYPE_BOOL:
       return def;
    default:
-      unreachable("bad relaxed precision input type");
+      UNREACHABLE("bad relaxed precision input type");
    }
 }
 
@@ -252,7 +252,7 @@ vtn_convert_op_src_type(SpvOp opcode)
    case SpvOpSatConvertUToS:
       return nir_type_uint;
    default:
-      unreachable("Unhandled conversion op");
+      UNREACHABLE("Unhandled conversion op");
    }
 }
 
@@ -273,7 +273,7 @@ vtn_convert_op_dst_type(SpvOp opcode)
    case SpvOpSatConvertSToU:
       return nir_type_uint;
    default:
-      unreachable("Unhandled conversion op");
+      UNREACHABLE("Unhandled conversion op");
    }
 }
 
@@ -608,7 +608,7 @@ vtn_mediump_upconvert(struct vtn_builder *b, enum glsl_base_type base_type, nir_
    case GLSL_TYPE_UINT:
       return nir_u2u32(&b->nb, def);
    default:
-      unreachable("bad relaxed precision output type");
+      UNREACHABLE("bad relaxed precision output type");
    }
 }
 
@@ -664,7 +664,7 @@ vtn_handle_deriv(struct vtn_builder *b, SpvOp opcode, nir_def *src)
       return nir_fadd(&b->nb,
                       nir_fabs(&b->nb, nir_ddx_coarse(&b->nb, src)),
                       nir_fabs(&b->nb, nir_ddy_coarse(&b->nb, src)));
-   default: unreachable("Not a derivative opcode");
+   default: UNREACHABLE("Not a derivative opcode");
    }
 }
 
@@ -990,7 +990,7 @@ vtn_handle_alu(struct vtn_builder *b, SpvOp opcode,
       switch (op) {
       case nir_op_fge: op = nir_op_flt; break;
       case nir_op_flt: op = nir_op_fge; break;
-      default: unreachable("Impossible opcode.");
+      default: UNREACHABLE("Impossible opcode.");
       }
 
       dest->def =
@@ -1103,7 +1103,7 @@ vtn_handle_alu(struct vtn_builder *b, SpvOp opcode,
    case SpvOpSDotAccSatKHR:
    case SpvOpUDotAccSatKHR:
    case SpvOpSUDotAccSatKHR:
-      unreachable("Should have called vtn_handle_integer_dot instead.");
+      UNREACHABLE("Should have called vtn_handle_integer_dot instead.");
 
    default: {
       bool swap;
@@ -1289,7 +1289,7 @@ vtn_handle_integer_dot(struct vtn_builder *b, SpvOp opcode,
          break;
 
       default:
-         unreachable("Invalid opcode.");
+         UNREACHABLE("Invalid opcode.");
       }
 
       /* The SPV_KHR_integer_dot_product spec says:
@@ -1367,7 +1367,7 @@ vtn_handle_integer_dot(struct vtn_builder *b, SpvOp opcode,
                dest = nir_udot_2x16_uadd(&b->nb, src[0], src[1], zero);
             break;
          default:
-            unreachable("Invalid opcode.");
+            UNREACHABLE("Invalid opcode.");
          }
       } else {
          switch (opcode) {
@@ -1399,7 +1399,7 @@ vtn_handle_integer_dot(struct vtn_builder *b, SpvOp opcode,
                dest = nir_sudot_4x8_iadd(&b->nb, src[0], src[1], zero);
             break;
          default:
-            unreachable("Invalid opcode.");
+            UNREACHABLE("Invalid opcode.");
          }
       }
 
diff --git a/src/compiler/spirv/vtn_amd.c b/src/compiler/spirv/vtn_amd.c
index 9cc2cb6e8324a..b8f4ef81d72ce 100644
--- a/src/compiler/spirv/vtn_amd.c
+++ b/src/compiler/spirv/vtn_amd.c
@@ -47,7 +47,7 @@ vtn_handle_amd_gcn_shader_instruction(struct vtn_builder *b, SpvOp ext_opcode,
       break;
    }
    default:
-      unreachable("Invalid opcode");
+      UNREACHABLE("Invalid opcode");
    }
 
    vtn_push_nir_ssa(b, w[2], def);
@@ -79,7 +79,7 @@ vtn_handle_amd_shader_ballot_instruction(struct vtn_builder *b, SpvOp ext_opcode
       op = nir_intrinsic_mbcnt_amd;
       break;
    default:
-      unreachable("Invalid opcode");
+      UNREACHABLE("Invalid opcode");
    }
 
    const struct glsl_type *dest_type = vtn_get_type(b, w[1])->type;
@@ -171,7 +171,7 @@ vtn_handle_amd_shader_trinary_minmax_instruction(struct vtn_builder *b, SpvOp ex
                      nir_imax(nb, src[1], src[2]));
       break;
    default:
-      unreachable("unknown opcode\n");
+      UNREACHABLE("unknown opcode\n");
       break;
    }
 
@@ -190,7 +190,7 @@ vtn_handle_amd_shader_explicit_vertex_parameter_instruction(struct vtn_builder *
       op = nir_intrinsic_interp_deref_at_vertex;
       break;
    default:
-      unreachable("unknown opcode");
+      UNREACHABLE("unknown opcode");
    }
 
    nir_intrinsic_instr *intrin = nir_intrinsic_instr_create(b->nb.shader, op);
diff --git a/src/compiler/spirv/vtn_cmat.c b/src/compiler/spirv/vtn_cmat.c
index f0ab5ba95c2cd..bc5ba65c1787c 100644
--- a/src/compiler/spirv/vtn_cmat.c
+++ b/src/compiler/spirv/vtn_cmat.c
@@ -18,7 +18,7 @@ vtn_cooperative_matrix_use_to_glsl(SpvCooperativeMatrixUse use)
    case SpvCooperativeMatrixUseMatrixAccumulatorKHR:
       return GLSL_CMAT_USE_ACCUMULATOR;
    default:
-      unreachable("Unexpected cooperative matrix use");
+      UNREACHABLE("Unexpected cooperative matrix use");
    }
 }
 
@@ -65,7 +65,7 @@ vtn_matrix_layout_to_glsl(SpvCooperativeMatrixLayout layout)
    case SpvCooperativeMatrixLayoutColumnMajorKHR:
       return GLSL_MATRIX_LAYOUT_COLUMN_MAJOR;
    default:
-      unreachable("Unexpected cooperative matrix layout");
+      UNREACHABLE("Unexpected cooperative matrix layout");
    }
 }
 
@@ -200,7 +200,7 @@ vtn_handle_cooperative_instruction(struct vtn_builder *b, SpvOp opcode,
    }
 
    default:
-      unreachable("Unexpected opcode for cooperative matrix instruction");
+      UNREACHABLE("Unexpected opcode for cooperative matrix instruction");
    }
 }
 
@@ -299,7 +299,7 @@ vtn_handle_cooperative_alu(struct vtn_builder *b, struct vtn_value *dest_val,
       }
 
       default:
-         unreachable("invalid cooperative matrix alu instruction");
+         UNREACHABLE("invalid cooperative matrix alu instruction");
       }
 }
 
diff --git a/src/compiler/spirv/vtn_private.h b/src/compiler/spirv/vtn_private.h
index 83daa2ccf44ca..c904965ea5bcc 100644
--- a/src/compiler/spirv/vtn_private.h
+++ b/src/compiler/spirv/vtn_private.h
@@ -830,7 +830,7 @@ vtn_constant_uint(struct vtn_builder *b, uint32_t value_id)
    case 16: return val->constant->values[0].u16;
    case 32: return val->constant->values[0].u32;
    case 64: return val->constant->values[0].u64;
-   default: unreachable("Invalid bit size");
+   default: UNREACHABLE("Invalid bit size");
    }
 }
 
@@ -848,7 +848,7 @@ vtn_constant_int(struct vtn_builder *b, uint32_t value_id)
    case 16: return val->constant->values[0].i16;
    case 32: return val->constant->values[0].i32;
    case 64: return val->constant->values[0].i64;
-   default: unreachable("Invalid bit size");
+   default: UNREACHABLE("Invalid bit size");
    }
 }
 
diff --git a/src/compiler/spirv/vtn_structured_cfg.c b/src/compiler/spirv/vtn_structured_cfg.c
index 6efc984cfc397..97375f4483e83 100644
--- a/src/compiler/spirv/vtn_structured_cfg.c
+++ b/src/compiler/spirv/vtn_structured_cfg.c
@@ -92,7 +92,7 @@ vtn_construct_type_to_string(enum vtn_construct_type t)
    CASE(case);
    }
 #undef CASE
-   unreachable("invalid construct type");
+   UNREACHABLE("invalid construct type");
    return "";
 }
 
@@ -196,7 +196,7 @@ vtn_branch_type_to_string(enum vtn_branch_type t)
    CASE(return);
    }
 #undef CASE
-   unreachable("unknown branch type");
+   UNREACHABLE("unknown branch type");
    return "";
 }
 
@@ -393,7 +393,7 @@ structured_post_order_traversal(struct vtn_builder *b, struct vtn_block *block)
       break;
 
    default:
-      unreachable("invalid branch opcode");
+      UNREACHABLE("invalid branch opcode");
    }
 
    b->func->ordered_blocks[b->func->ordered_blocks_count++] = block;
@@ -749,7 +749,7 @@ create_constructs(struct vtn_builder *b)
          }
 
          default:
-            unreachable("invalid merge opcode");
+            UNREACHABLE("invalid merge opcode");
          }
       }
 
@@ -991,7 +991,7 @@ branch_type_for_terminator(struct vtn_builder *b, struct vtn_block *block)
    case SpvOpUnreachable:
       return vtn_branch_type_return;
    default:
-      unreachable("unexpected terminator operation");
+      UNREACHABLE("unexpected terminator operation");
       return vtn_branch_type_none;
    }
 }
@@ -1652,7 +1652,7 @@ vtn_emit_cf_func_structured(struct vtn_builder *b, struct vtn_function *func,
 
          switch (next->type) {
          case vtn_construct_type_function:
-            unreachable("should've already entered function construct");
+            UNREACHABLE("should've already entered function construct");
             break;
 
          case vtn_construct_type_selection: {
diff --git a/src/compiler/spirv/vtn_subgroup.c b/src/compiler/spirv/vtn_subgroup.c
index fed8e00710e69..e90df1c714e70 100644
--- a/src/compiler/spirv/vtn_subgroup.c
+++ b/src/compiler/spirv/vtn_subgroup.c
@@ -132,7 +132,7 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
             op = nir_intrinsic_ballot_bit_count_exclusive;
             break;
          default:
-            unreachable("Invalid group operation");
+            UNREACHABLE("Invalid group operation");
          }
          src0 = vtn_get_nir_ssa(b, w[5]);
          break;
@@ -145,7 +145,7 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
          src0 = vtn_get_nir_ssa(b, w[4]);
          break;
       default:
-         unreachable("Unhandled opcode");
+         UNREACHABLE("Unhandled opcode");
       }
 
       nir_intrinsic_instr *intrin =
@@ -228,11 +228,11 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
             op = nir_intrinsic_vote_ieq;
             break;
          default:
-            unreachable("Unhandled type");
+            UNREACHABLE("Unhandled type");
          }
          break;
       default:
-         unreachable("Unhandled opcode");
+         UNREACHABLE("Unhandled opcode");
       }
 
       nir_def *src0;
@@ -275,7 +275,7 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
          op = nir_intrinsic_shuffle_down;
          break;
       default:
-         unreachable("Invalid opcode");
+         UNREACHABLE("Invalid opcode");
       }
       vtn_push_ssa_value(b, w[2],
          vtn_build_subgroup_instr(b, op, vtn_ssa_value(b, w[4]),
@@ -499,7 +499,7 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
          reduction_op = nir_op_ixor;
          break;
       default:
-         unreachable("Invalid reduction operation");
+         UNREACHABLE("Invalid reduction operation");
       }
 
       nir_intrinsic_op op;
@@ -520,7 +520,7 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
          cluster_size = vtn_constant_uint(b, w[6]);
          break;
       default:
-         unreachable("Invalid group operation");
+         UNREACHABLE("Invalid group operation");
       }
 
       vtn_push_ssa_value(b, w[2],
@@ -530,6 +530,6 @@ vtn_handle_subgroup(struct vtn_builder *b, SpvOp opcode,
    }
 
    default:
-      unreachable("Invalid SPIR-V opcode");
+      UNREACHABLE("Invalid SPIR-V opcode");
    }
 }
diff --git a/src/compiler/spirv/vtn_variables.c b/src/compiler/spirv/vtn_variables.c
index f2e30c8880f23..b1be13937b69e 100644
--- a/src/compiler/spirv/vtn_variables.c
+++ b/src/compiler/spirv/vtn_variables.c
@@ -1929,7 +1929,7 @@ vtn_mode_to_address_format(struct vtn_builder *b, enum vtn_variable_mode mode)
       return nir_address_format_logical;
    }
 
-   unreachable("Invalid variable mode");
+   UNREACHABLE("Invalid variable mode");
 }
 
 nir_def *
@@ -2318,7 +2318,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
 
    case vtn_variable_mode_phys_ssbo:
    case vtn_variable_mode_generic:
-      unreachable("Should have been caught before");
+      UNREACHABLE("Should have been caught before");
    }
 
    /* Ignore incorrectly generated Undef initializers. */
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 32944890495ff..aa31fff54f92f 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -454,7 +454,7 @@ dri2_add_config(_EGLDisplay *disp, const struct dri_config *dri_config,
 
       _eglLinkConfig(&conf->base);
    } else {
-      unreachable("duplicates should not be possible");
+      UNREACHABLE("duplicates should not be possible");
       return NULL;
    }
 
@@ -877,7 +877,7 @@ dri2_initialize(_EGLDisplay *disp)
       ret = dri2_initialize_android(disp);
       break;
    default:
-      unreachable("Callers ensure we cannot get here.");
+      UNREACHABLE("Callers ensure we cannot get here.");
       return EGL_FALSE;
    }
 
@@ -970,7 +970,7 @@ dri2_display_destroy(_EGLDisplay *disp)
    case _EGL_PLATFORM_DEVICE:
       break;
    default:
-      unreachable("Platform teardown is not properly hooked.");
+      UNREACHABLE("Platform teardown is not properly hooked.");
       break;
    }
 
@@ -1989,7 +1989,7 @@ dri2_create_image_khr_texture(_EGLDisplay *disp, _EGLContext *ctx,
       gl_target = GL_TEXTURE_CUBE_MAP;
       break;
    default:
-      unreachable("Unexpected target in dri2_create_image_khr_texture()");
+      UNREACHABLE("Unexpected target in dri2_create_image_khr_texture()");
       return EGL_NO_IMAGE_KHR;
    }
 
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index e4b4b7140ac6b..f478a89a6d3d9 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2399,7 +2399,7 @@ kopperSetSurfaceCreateInfo(void *_draw, struct kopper_loader_info *out)
    EGL_VK_COMP(12);
 #undef EGL_VK_COMP
    default:
-      unreachable("unknown compression rate");
+      UNREACHABLE("unknown compression rate");
    }
 }
 
diff --git a/src/egl/drivers/haiku/egl_haiku.cpp b/src/egl/drivers/haiku/egl_haiku.cpp
index 37649508f5763..ce7c022276741 100644
--- a/src/egl/drivers/haiku/egl_haiku.cpp
+++ b/src/egl/drivers/haiku/egl_haiku.cpp
@@ -399,7 +399,7 @@ haiku_initialize(_EGLDisplay *disp)
       ret = haiku_initialize_impl(disp, disp->PlatformDisplay);
       break;
    default:
-      unreachable("Callers ensure we cannot get here.");
+      UNREACHABLE("Callers ensure we cannot get here.");
       return EGL_FALSE;
    }
 
diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index a4e3117d2fadf..e2c55bc811cf5 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -159,7 +159,7 @@ wgl_add_config(_EGLDisplay *disp, const struct stw_pixelformat_info *stw_config,
 
       _eglLinkConfig(&conf->base);
    } else {
-      unreachable("duplicates should not be possible");
+      UNREACHABLE("duplicates should not be possible");
       return NULL;
    }
 
@@ -337,7 +337,7 @@ wgl_initialize(_EGLDisplay *disp)
       ret = wgl_initialize_impl(disp, disp->PlatformDisplay);
       break;
    default:
-      unreachable("Callers ensure we cannot get here.");
+      UNREACHABLE("Callers ensure we cannot get here.");
       return EGL_FALSE;
    }
 
@@ -863,7 +863,7 @@ wgl_create_image_khr_texture(_EGLDisplay *disp, _EGLContext *ctx,
       gl_target = GL_TEXTURE_CUBE_MAP;
       break;
    default:
-      unreachable("Unexpected target in wgl_create_image_khr_texture()");
+      UNREACHABLE("Unexpected target in wgl_create_image_khr_texture()");
       return EGL_NO_IMAGE_KHR;
    }
 
diff --git a/src/egl/main/eglconfig.c b/src/egl/main/eglconfig.c
index b7e8bf8efd9c1..2b530904352bb 100644
--- a/src/egl/main/eglconfig.c
+++ b/src/egl/main/eglconfig.c
@@ -323,7 +323,7 @@ _eglValidateConfig(const _EGLConfig *conf, EGLBoolean for_matching)
                valid = EGL_FALSE;
             break;
          default:
-            unreachable("check _eglValidationTable[]");
+            UNREACHABLE("check _eglValidationTable[]");
             break;
          }
          break;
@@ -343,7 +343,7 @@ _eglValidateConfig(const _EGLConfig *conf, EGLBoolean for_matching)
                    EGL_OPENGL_ES3_BIT_KHR | EGL_OPENGL_BIT;
             break;
          default:
-            unreachable("check _eglValidationTable[]");
+            UNREACHABLE("check _eglValidationTable[]");
             mask = 0;
             break;
          }
@@ -466,7 +466,7 @@ _eglMatchConfig(const _EGLConfig *conf, const _EGLConfig *criteria)
          /* ignored here */
          break;
       case ATTRIB_CRITERION_IGNORE:
-         unreachable("already handled above");
+         UNREACHABLE("already handled above");
          break;
       }
 
diff --git a/src/egl/main/eglcontext.c b/src/egl/main/eglcontext.c
index 49b4633b734ce..cbe01771888f9 100644
--- a/src/egl/main/eglcontext.c
+++ b/src/egl/main/eglcontext.c
@@ -734,7 +734,7 @@ _eglQueryContextRenderBuffer(_EGLContext *ctx)
 
    switch (surf->Type) {
    default:
-      unreachable("bad EGLSurface type");
+      UNREACHABLE("bad EGLSurface type");
    case EGL_PIXMAP_BIT:
       /* - If the context is bound to a pixmap surface, then EGL_SINGLE_BUFFER
        *   will be returned.
diff --git a/src/egl/main/eglsurface.c b/src/egl/main/eglsurface.c
index 8ca8f947fc4d6..14dc68619beae 100644
--- a/src/egl/main/eglsurface.c
+++ b/src/egl/main/eglsurface.c
@@ -510,7 +510,7 @@ _eglQuerySurface(_EGLDisplay *disp, _EGLSurface *surface, EGLint attribute,
        */
       switch (surface->Type) {
       default:
-         unreachable("bad EGLSurface type");
+         UNREACHABLE("bad EGLSurface type");
       case EGL_WINDOW_BIT:
          *value = surface->RequestedRenderBuffer;
          break;
diff --git a/src/freedreno/afuc/emu-regs.c b/src/freedreno/afuc/emu-regs.c
index e6a0dd359f831..37e452833f3ef 100644
--- a/src/freedreno/afuc/emu-regs.c
+++ b/src/freedreno/afuc/emu-regs.c
@@ -174,7 +174,7 @@ get_reg_addr(struct emu *emu)
    case DATA_ADDR:    return REG_ADDR;
    case DATA_USRADDR: return REG_USRADDR;
    default:
-      unreachable("bad data_mode");
+      UNREACHABLE("bad data_mode");
       return 0;
    }
 }
@@ -268,7 +268,7 @@ emu_get_fifo_reg(struct emu *emu, unsigned n, bool peek)
          emu_main_prompt(emu);
       } while (true);
    } else {
-      unreachable("not a FIFO reg");
+      UNREACHABLE("not a FIFO reg");
       return 0;
    }
 }
diff --git a/src/freedreno/common/freedreno_common.h b/src/freedreno/common/freedreno_common.h
index 83f9674af6546..12e236d309a4e 100644
--- a/src/freedreno/common/freedreno_common.h
+++ b/src/freedreno/common/freedreno_common.h
@@ -33,7 +33,7 @@
          genX_thing = &thing<A7XX>;                                          \
          break;                                                              \
       default:                                                               \
-         unreachable("Unknown hardware generation");                         \
+         UNREACHABLE("Unknown hardware generation");                         \
       }                                                                      \
       genX_thing;                                                            \
    })
diff --git a/src/freedreno/common/freedreno_stompable_regs.h b/src/freedreno/common/freedreno_stompable_regs.h
index c572416420d30..230a1be322bed 100644
--- a/src/freedreno/common/freedreno_stompable_regs.h
+++ b/src/freedreno/common/freedreno_stompable_regs.h
@@ -77,7 +77,7 @@ fd_reg_stomp_allowed(chip CHIP, uint16_t reg)
       break;
    }
    default: {
-      unreachable("Unknown GPU");
+      UNREACHABLE("Unknown GPU");
    }
    }
 
diff --git a/src/freedreno/ds/fd_pps_driver.cc b/src/freedreno/ds/fd_pps_driver.cc
index e4534179b00d5..945d559eefd92 100644
--- a/src/freedreno/ds/fd_pps_driver.cc
+++ b/src/freedreno/ds/fd_pps_driver.cc
@@ -1736,7 +1736,7 @@ FreedrenoDriver::Countable::resolve() const
          return;
       }
    }
-   unreachable("no such countable!");
+   UNREACHABLE("no such countable!");
 }
 
 uint64_t
diff --git a/src/freedreno/fdl/fd6_layout.c b/src/freedreno/fdl/fd6_layout.c
index d5464ee624a16..d85f86b97cd61 100644
--- a/src/freedreno/fdl/fd6_layout.c
+++ b/src/freedreno/fdl/fd6_layout.c
@@ -69,7 +69,7 @@ fdl6_get_ubwc_blockwidth(const struct fdl_layout *layout,
          *blockwidth = 4;
          *blockheight = 2;
       } else {
-         unreachable("bad nr_samples");
+         UNREACHABLE("bad nr_samples");
       }
       return;
    }
diff --git a/src/freedreno/fdl/fd6_tiled_memcpy.cc b/src/freedreno/fdl/fd6_tiled_memcpy.cc
index 237dc6effbc79..5df257f486755 100644
--- a/src/freedreno/fdl/fd6_tiled_memcpy.cc
+++ b/src/freedreno/fdl/fd6_tiled_memcpy.cc
@@ -272,7 +272,7 @@ get_block_size(unsigned cpp, uint32_t *block_width,
       *block_height = 4;
       break;
    default:
-      unreachable("unknown cpp");
+      UNREACHABLE("unknown cpp");
    }
 }
 
@@ -901,7 +901,7 @@ fdl6_memcpy_linear_to_tiled(uint32_t x_start, uint32_t y_start,
    CASE(16)
 #undef CASE
    default:
-      unreachable("unknown cpp");
+      UNREACHABLE("unknown cpp");
    }
 #endif
 }
@@ -965,7 +965,7 @@ fdl6_memcpy_tiled_to_linear(uint32_t x_start, uint32_t y_start,
    CASE(16)
 #undef CASE
    default:
-      unreachable("unknown cpp");
+      UNREACHABLE("unknown cpp");
    }
 #endif
 }
diff --git a/src/freedreno/ir3/ir3.c b/src/freedreno/ir3/ir3.c
index 82bf82c57bc2f..a07f20b2666ae 100644
--- a/src/freedreno/ir3/ir3.c
+++ b/src/freedreno/ir3/ir3.c
@@ -660,7 +660,7 @@ ir3_find_end(struct ir3 *ir)
             return instr;
       }
    }
-   unreachable("couldn't find end instruction");
+   UNREACHABLE("couldn't find end instruction");
 }
 
 static struct ir3_instruction *
@@ -750,7 +750,7 @@ ir3_find_shpe(struct ir3 *ir)
       }
    }
 
-   unreachable("preamble without shpe");
+   UNREACHABLE("preamble without shpe");
 }
 
 struct ir3_instruction *
@@ -870,7 +870,7 @@ ir3_block_get_pred_index(struct ir3_block *block, struct ir3_block *pred)
       }
    }
 
-   unreachable("ir3_block_get_pred_index() invalid predecessor");
+   UNREACHABLE("ir3_block_get_pred_index() invalid predecessor");
 }
 
 static struct ir3_instruction *
diff --git a/src/freedreno/ir3/ir3.h b/src/freedreno/ir3/ir3.h
index 18dcdd2aea6be..3fe42cb58c090 100644
--- a/src/freedreno/ir3/ir3.h
+++ b/src/freedreno/ir3/ir3.h
@@ -2282,7 +2282,7 @@ soft_sy_delay(struct ir3_instruction *instr, struct ir3 *shader)
          case 2: return 60 / 2;
          case 3: return 77 / 2;
          case 4: return 79 / 2;
-         default: unreachable("bad number of components");
+         default: UNREACHABLE("bad number of components");
          }
       } else {
          switch (components) {
@@ -2290,7 +2290,7 @@ soft_sy_delay(struct ir3_instruction *instr, struct ir3 *shader)
          case 2: return 53;
          case 3: return 62;
          case 4: return 64;
-         default: unreachable("bad number of components");
+         default: UNREACHABLE("bad number of components");
          }
       }
    } else {
@@ -2426,7 +2426,7 @@ ir3_cursor_current_block(struct ir3_cursor cursor)
       return cursor.instr->block;
    }
 
-   unreachable("illegal cursor option");
+   UNREACHABLE("illegal cursor option");
 }
 
 static inline struct ir3_cursor
@@ -3298,7 +3298,7 @@ __regmask_file(regmask_t *regmask, enum ir3_reg_file file)
    case IR3_FILE_NONGPR:
       return regmask->nongpr;
    }
-   unreachable("bad file");
+   UNREACHABLE("bad file");
 }
 
 static inline bool
diff --git a/src/freedreno/ir3/ir3_a4xx.c b/src/freedreno/ir3/ir3_a4xx.c
index 8fa43040ebc5a..2df1e014a796d 100644
--- a/src/freedreno/ir3/ir3_a4xx.c
+++ b/src/freedreno/ir3/ir3_a4xx.c
@@ -135,7 +135,7 @@ emit_atomic(struct ir3_builder *b, nir_atomic_op op, struct ir3_instruction *bo,
    case nir_atomic_op_cmpxchg:
       return ir3_ATOMIC_S_CMPXCHG(b, bo, 0, data, 0, offset, 0, byte_offset, 0);
    default:
-      unreachable("boo");
+      UNREACHABLE("boo");
    }
 }
 
@@ -380,7 +380,7 @@ emit_intrinsic_atomic_image(struct ir3_context *ctx, nir_intrinsic_instr *intr)
 static struct ir3_instruction *
 emit_intrinsic_atomic_global(struct ir3_context *ctx, nir_intrinsic_instr *intr)
 {
-   unreachable("Global atomic are unimplemented on A5xx");
+   UNREACHABLE("Global atomic are unimplemented on A5xx");
 }
 
 const struct ir3_context_funcs ir3_a4xx_funcs = {
diff --git a/src/freedreno/ir3/ir3_a6xx.c b/src/freedreno/ir3/ir3_a6xx.c
index f7158394c29cf..991b175c62879 100644
--- a/src/freedreno/ir3/ir3_a6xx.c
+++ b/src/freedreno/ir3/ir3_a6xx.c
@@ -198,7 +198,7 @@ emit_atomic(struct ir3_builder *b, nir_atomic_op op,
    case nir_atomic_op_cmpxchg:
       return ir3_ATOMIC_B_CMPXCHG(b, ibo, 0, src0, 0, src1, 0);
    default:
-      unreachable("boo");
+      UNREACHABLE("boo");
    }
 }
 
@@ -548,7 +548,7 @@ emit_intrinsic_atomic_global(struct ir3_context *ctx, nir_intrinsic_instr *intr)
       atomic = ir3_ATOMIC_G_CMPXCHG(b, addr, 0, src1, 0);
       break;
    default:
-      unreachable("Unknown global atomic op");
+      UNREACHABLE("Unknown global atomic op");
    }
 
    atomic->cat6.iim_val = 1;
diff --git a/src/freedreno/ir3/ir3_compiler_nir.c b/src/freedreno/ir3/ir3_compiler_nir.c
index 415ee86cd407a..1c57dee7fb82e 100644
--- a/src/freedreno/ir3/ir3_compiler_nir.c
+++ b/src/freedreno/ir3/ir3_compiler_nir.c
@@ -1549,7 +1549,7 @@ emit_intrinsic_atomic_shared(struct ir3_context *ctx, nir_intrinsic_instr *intr)
       atomic = ir3_ATOMIC_CMPXCHG(b, src0, 0, src1, 0);
       break;
    default:
-      unreachable("boo");
+      UNREACHABLE("boo");
    }
 
    atomic->cat6.iim_val = 1;
@@ -2324,7 +2324,7 @@ get_reduce_op(nir_op opc)
    case nir_op_ior:  return REDUCE_OP_OR_B;
    case nir_op_ixor: return REDUCE_OP_XOR_B;
    default:
-      unreachable("unknown NIR reduce op");
+      UNREACHABLE("unknown NIR reduce op");
    }
 }
 
@@ -2359,7 +2359,7 @@ get_reduce_identity(nir_op opc, unsigned size)
    case nir_op_ixor:
       return 0;
    default:
-      unreachable("unknown NIR reduce op");
+      UNREACHABLE("unknown NIR reduce op");
    }
 }
 
@@ -2417,7 +2417,7 @@ emit_intrinsic_reduce(struct ir3_context *ctx, nir_intrinsic_instr *intr)
    case nir_intrinsic_inclusive_scan: dst = inclusive; break;
    case nir_intrinsic_exclusive_scan: dst = exclusive; break;
    default:
-      unreachable("unknown reduce intrinsic");
+      UNREACHABLE("unknown reduce intrinsic");
    }
 
    return create_multidst_mov(&ctx->build, dst);
@@ -2514,7 +2514,7 @@ emit_intrinsic_reduce_clusters(struct ir3_context *ctx,
       break;
    }
    default:
-      unreachable("unknown reduce intrinsic");
+      UNREACHABLE("unknown reduce intrinsic");
    }
 
    return create_multidst_mov(&ctx->build, dst);
@@ -2542,7 +2542,7 @@ shfl_mode(nir_intrinsic_instr *intr)
    case nir_intrinsic_shuffle_xor_uniform_ir3:
       return SHFL_XOR;
    default:
-      unreachable("unsupported shfl");
+      UNREACHABLE("unsupported shfl");
    }
 }
 
@@ -3497,7 +3497,7 @@ get_tex_dest_type(nir_tex_instr *tex)
       return TYPE_U16;
    case nir_type_invalid:
    default:
-      unreachable("bad dest_type");
+      UNREACHABLE("bad dest_type");
    }
 
    return type;
@@ -4159,7 +4159,7 @@ read_phi_src(struct ir3_context *ctx, struct ir3_block *blk,
       }
    }
 
-   unreachable("couldn't find phi node ir3 block");
+   UNREACHABLE("couldn't find phi node ir3 block");
    return NULL;
 }
 
@@ -4452,7 +4452,7 @@ instr_can_be_predicated(nir_instr *instr)
    }
    }
 
-   unreachable("Checked all cases");
+   UNREACHABLE("Checked all cases");
 }
 
 static bool
@@ -5220,7 +5220,7 @@ uses_store_output(struct ir3_shader_variant *so)
    case MESA_SHADER_KERNEL:
       return false;
    default:
-      unreachable("unknown stage");
+      UNREACHABLE("unknown stage");
    }
 }
 
diff --git a/src/freedreno/ir3/ir3_context.c b/src/freedreno/ir3/ir3_context.c
index 23d8d79d79d4f..71ba9c4c24483 100644
--- a/src/freedreno/ir3/ir3_context.c
+++ b/src/freedreno/ir3/ir3_context.c
@@ -344,7 +344,7 @@ ir3_context_error(struct ir3_context *ctx, const char *format, ...)
    nir_log_shader_annotated(ctx->s, errors);
    ralloc_free(errors);
    ctx->error = true;
-   unreachable("");
+   UNREACHABLE("");
 }
 
 static struct ir3_instruction *
@@ -375,7 +375,7 @@ create_addr0(struct ir3_builder *build, struct ir3_instruction *src, int align)
       instr = ir3_SHL_B(build, instr, 0, immed, 0);
       break;
    default:
-      unreachable("bad align");
+      UNREACHABLE("bad align");
       return NULL;
    }
 
diff --git a/src/freedreno/ir3/ir3_context.h b/src/freedreno/ir3/ir3_context.h
index 63851e060e903..e872fa37d1065 100644
--- a/src/freedreno/ir3/ir3_context.h
+++ b/src/freedreno/ir3/ir3_context.h
@@ -250,7 +250,7 @@ utype_for_size(unsigned bit_size)
    case 8:
       return TYPE_U8;
    default:
-      unreachable("bad bitsize");
+      UNREACHABLE("bad bitsize");
       return ~0;
    }
 }
diff --git a/src/freedreno/ir3/ir3_image.c b/src/freedreno/ir3/ir3_image.c
index 616c87260faa9..3ed742c641f0a 100644
--- a/src/freedreno/ir3/ir3_image.c
+++ b/src/freedreno/ir3/ir3_image.c
@@ -125,7 +125,7 @@ ir3_get_type_for_image_intrinsic(const nir_intrinsic_instr *instr)
       break;
 
    default:
-      unreachable("Unhandled NIR image intrinsic");
+      UNREACHABLE("Unhandled NIR image intrinsic");
    }
 
    switch (type) {
@@ -136,7 +136,7 @@ ir3_get_type_for_image_intrinsic(const nir_intrinsic_instr *instr)
    case nir_type_float:
       return bit_size == 16 ? TYPE_F16 : TYPE_F32;
    default:
-      unreachable("bad type");
+      UNREACHABLE("bad type");
    }
 }
 
diff --git a/src/freedreno/ir3/ir3_legalize.c b/src/freedreno/ir3/ir3_legalize.c
index cf8a710af314d..29fb3c023747f 100644
--- a/src/freedreno/ir3/ir3_legalize.c
+++ b/src/freedreno/ir3/ir3_legalize.c
@@ -1215,7 +1215,7 @@ invert_branch(struct ir3_instruction *branch)
       branch->opc = OPC_BRAA;
       break;
    default:
-      unreachable("can't get here");
+      UNREACHABLE("can't get here");
    }
 
    branch->cat0.inv1 = !branch->cat0.inv1;
diff --git a/src/freedreno/ir3/ir3_lower_subgroups.c b/src/freedreno/ir3/ir3_lower_subgroups.c
index 73bd9b9e47e28..e229b9f3d76b7 100644
--- a/src/freedreno/ir3/ir3_lower_subgroups.c
+++ b/src/freedreno/ir3/ir3_lower_subgroups.c
@@ -453,7 +453,7 @@ lower_instr(struct ir3 *ir, struct ir3_block **block, struct ir3_instruction *in
          branch_flags = instr->flags & IR3_INSTR_NEEDS_HELPERS;
          break;
       default:
-         unreachable("bad opcode");
+         UNREACHABLE("bad opcode");
       }
 
       struct ir3_block *then_block =
@@ -497,7 +497,7 @@ lower_instr(struct ir3 *ir, struct ir3_block **block, struct ir3_instruction *in
       }
 
       default:
-         unreachable("bad opcode");
+         UNREACHABLE("bad opcode");
       }
    }
 
@@ -697,7 +697,7 @@ lower_scan_reduce(struct nir_builder *b, nir_instr *instr, void *data)
       return nir_exclusive_scan_clusters_ir3(b, inclusive, exclusive,
                                              .reduction_op = op);
    default:
-      unreachable("filtered intrinsic");
+      UNREACHABLE("filtered intrinsic");
    }
 }
 
@@ -786,7 +786,7 @@ shuffle_to_uniform(nir_builder *b, nir_intrinsic_op op, struct nir_def *val,
    case nir_intrinsic_shuffle_xor:
       return nir_shuffle_xor_uniform_ir3(b, val, id);
    default:
-      unreachable("filtered intrinsic");
+      UNREACHABLE("filtered intrinsic");
    }
 }
 
diff --git a/src/freedreno/ir3/ir3_nir.c b/src/freedreno/ir3/ir3_nir.c
index 6965da2c7b62c..867304f9a6961 100644
--- a/src/freedreno/ir3/ir3_nir.c
+++ b/src/freedreno/ir3/ir3_nir.c
@@ -1646,7 +1646,7 @@ ir3_nir_intrinsic_barycentric_sysval(nir_intrinsic_instr *intr)
          sysval = SYSTEM_VALUE_BARYCENTRIC_PERSP_SAMPLE;
       break;
    default:
-      unreachable("invalid barycentric intrinsic");
+      UNREACHABLE("invalid barycentric intrinsic");
    }
 
    return sysval;
diff --git a/src/freedreno/ir3/ir3_nir_lower_tess.c b/src/freedreno/ir3/ir3_nir_lower_tess.c
index 2f454bb8dc5a6..63ca5fa37930c 100644
--- a/src/freedreno/ir3/ir3_nir_lower_tess.c
+++ b/src/freedreno/ir3/ir3_nir_lower_tess.c
@@ -116,7 +116,7 @@ shader_io_get_unique_index(gl_varying_slot slot)
       return 13 + (slot - VARYING_SLOT_VAR0);
    }
    default:
-      unreachable("illegal slot in get unique index\n");
+      UNREACHABLE("illegal slot in get unique index\n");
    }
 }
 
@@ -144,7 +144,7 @@ build_local_offset(nir_builder *b, struct state *state, nir_def *vertex,
                                  comp * 4);
       break;
    default:
-      unreachable("bad shader stage");
+      UNREACHABLE("bad shader stage");
    }
 
    nir_def *vertex_offset = nir_imul24(b, vertex, vertex_stride);
@@ -437,7 +437,7 @@ build_per_vertex_offset(nir_builder *b, struct state *state,
                                     comp);
          break;
       default:
-         unreachable("bad shader state");
+         UNREACHABLE("bad shader state");
       }
 
       attr_offset = nir_iadd(b, attr_offset,
@@ -478,7 +478,7 @@ tess_level_components(struct state *state, uint32_t *inner, uint32_t *outer)
       *outer = 2;
       break;
    default:
-      unreachable("bad");
+      UNREACHABLE("bad");
    }
 }
 
@@ -508,7 +508,7 @@ build_tessfactor_base(nir_builder *b, gl_varying_slot slot, uint32_t comp,
       offset = 1 + outer_levels;
       break;
    default:
-      unreachable("bad");
+      UNREACHABLE("bad");
    }
 
    return nir_iadd_imm(b, patch_offset, offset + comp);
diff --git a/src/freedreno/ir3/ir3_nir_opt_preamble.c b/src/freedreno/ir3/ir3_nir_opt_preamble.c
index 9798047091230..fc39cb0fd36ba 100644
--- a/src/freedreno/ir3/ir3_nir_opt_preamble.c
+++ b/src/freedreno/ir3/ir3_nir_opt_preamble.c
@@ -476,7 +476,7 @@ _rematerialize_def(nir_builder *b, struct hash_table *remap_ht,
       break;
    }
    default:
-      unreachable("should not get here");
+      UNREACHABLE("should not get here");
    }
 
    nir_instr *instr = nir_instr_clone_deep(b->shader, def->parent_instr,
diff --git a/src/freedreno/ir3/ir3_ra.c b/src/freedreno/ir3/ir3_ra.c
index eddd9eb91ccd8..70f729c06144f 100644
--- a/src/freedreno/ir3/ir3_ra.c
+++ b/src/freedreno/ir3/ir3_ra.c
@@ -1246,7 +1246,7 @@ compress_regs_left(struct ra_ctx *ctx, struct ra_file *file,
           reg_file_size(file, cur_reg)) {
          d("ran out of room for interval %u!\n",
            cur_reg->name);
-         unreachable("reg pressure calculation was wrong!");
+         UNREACHABLE("reg pressure calculation was wrong!");
          return 0;
       }
 
@@ -1941,7 +1941,7 @@ handle_precolored_source(struct ra_ctx *ctx, struct ir3_register *src)
       unsigned eviction_count;
       if (!try_evict_regs(ctx, file, src, physreg, &eviction_count, true,
                           false)) {
-         unreachable("failed to evict for precolored source!");
+         UNREACHABLE("failed to evict for precolored source!");
          return;
       }
    }
diff --git a/src/freedreno/ir3/ir3_ra_predicates.c b/src/freedreno/ir3/ir3_ra_predicates.c
index b7c75be5248fa..e61803f3a1e8f 100644
--- a/src/freedreno/ir3/ir3_ra_predicates.c
+++ b/src/freedreno/ir3/ir3_ra_predicates.c
@@ -99,7 +99,7 @@ alloc_reg_comp(struct ra_predicates_ctx *ctx, struct block_liveness *live)
          return i;
    }
 
-   unreachable("Reg availability should have been checked before");
+   UNREACHABLE("Reg availability should have been checked before");
 }
 
 static struct live_def *
diff --git a/src/freedreno/ir3/ir3_sched.c b/src/freedreno/ir3/ir3_sched.c
index c72b7b0c4bc18..1fb88bf1a935d 100644
--- a/src/freedreno/ir3/ir3_sched.c
+++ b/src/freedreno/ir3/ir3_sched.c
@@ -1287,7 +1287,7 @@ get_array_id(struct ir3_instruction *instr)
       if (src->flags & IR3_REG_ARRAY)
          return src->array.id;
 
-   unreachable("this was unexpected");
+   UNREACHABLE("this was unexpected");
 }
 
 /* does instruction 'prior' need to be scheduled before 'instr'? */
diff --git a/src/freedreno/ir3/ir3_shader.h b/src/freedreno/ir3/ir3_shader.h
index 825ae79b08e06..498d3274b78e2 100644
--- a/src/freedreno/ir3/ir3_shader.h
+++ b/src/freedreno/ir3/ir3_shader.h
@@ -446,7 +446,7 @@ ir3_tess_mode(enum tess_primitive_mode tess_mode)
    case TESS_PRIMITIVE_QUADS:
       return IR3_TESS_QUADS;
    default:
-      unreachable("bad tessmode");
+      UNREACHABLE("bad tessmode");
    }
 }
 
@@ -462,7 +462,7 @@ ir3_tess_factor_stride(unsigned patch_type)
    case IR3_TESS_QUADS:
       return 28;
    default:
-      unreachable("bad tessmode");
+      UNREACHABLE("bad tessmode");
    }
 }
 
@@ -965,7 +965,7 @@ ir3_shader_stage(struct ir3_shader_variant *v)
    case MESA_SHADER_KERNEL:
       return "CL";
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
       return NULL;
    }
 }
diff --git a/src/freedreno/vulkan/tu_clear_blit.cc b/src/freedreno/vulkan/tu_clear_blit.cc
index a0ba36de2f688..4bbd894192b81 100644
--- a/src/freedreno/vulkan/tu_clear_blit.cc
+++ b/src/freedreno/vulkan/tu_clear_blit.cc
@@ -66,7 +66,7 @@ format_to_ifmt(enum pipe_format format)
    case 32:
       return is_int ? R2D_INT32 : R2D_FLOAT32;
     default:
-      unreachable("bad format");
+      UNREACHABLE("bad format");
    }
 }
 
@@ -1754,7 +1754,7 @@ copy_format(VkFormat vk_format, VkImageAspectFlags aspect_mask)
       case 8: return PIPE_FORMAT_R32G32_UINT;
       case 16:return PIPE_FORMAT_R32G32B32A32_UINT;
       default:
-         unreachable("unhandled format size");
+         UNREACHABLE("unhandled format size");
       }
    }
 
@@ -1855,7 +1855,7 @@ pack_blit_event_clear_value(const VkClearValue *val, enum pipe_format format, ui
       PACK_F(a8_unorm);
       break;
    default:
-      unreachable("unexpected channel size");
+      UNREACHABLE("unexpected channel size");
    }
 #undef PACK_F
 }
diff --git a/src/freedreno/vulkan/tu_cmd_buffer.cc b/src/freedreno/vulkan/tu_cmd_buffer.cc
index f0e9cc7b0f9f0..84e3732a3e03a 100644
--- a/src/freedreno/vulkan/tu_cmd_buffer.cc
+++ b/src/freedreno/vulkan/tu_cmd_buffer.cc
@@ -3575,7 +3575,7 @@ tu_CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer,
       index_shift = 0;
       break;
    default:
-      unreachable("invalid VkIndexType");
+      UNREACHABLE("invalid VkIndexType");
    }
 
    if (buf) {
@@ -5261,7 +5261,7 @@ tu_CmdExecuteCommands(VkCommandBuffer commandBuffer,
                   break;
                }
                case SR_AFTER_PRE_CHAIN:
-                  unreachable("resuming render pass is not preceded by suspending one");
+                  UNREACHABLE("resuming render pass is not preceded by suspending one");
                }
 
                tu_reset_render_pass(cmd);
@@ -5286,7 +5286,7 @@ tu_CmdExecuteCommands(VkCommandBuffer commandBuffer,
                   cmd->state.suspend_resume = SR_IN_CHAIN_AFTER_PRE_CHAIN;
                   break;
                default:
-                  unreachable("suspending render pass is followed by a not resuming one");
+                  UNREACHABLE("suspending render pass is followed by a not resuming one");
                }
             }
          }
@@ -5775,7 +5775,7 @@ tu_CmdBeginRendering(VkCommandBuffer commandBuffer,
       case SR_IN_PRE_CHAIN:
       case SR_IN_CHAIN:
       case SR_IN_CHAIN_AFTER_PRE_CHAIN:
-         unreachable("suspending render pass not followed by resuming pass");
+         UNREACHABLE("suspending render pass not followed by resuming pass");
          break;
       }
    }
@@ -8089,7 +8089,7 @@ tu_CmdEndRendering2EXT(VkCommandBuffer commandBuffer,
          cmd_buffer->state.suspend_resume = SR_AFTER_PRE_CHAIN;
          break;
       default:
-         unreachable("suspending render pass not followed by resuming pass");
+         UNREACHABLE("suspending render pass not followed by resuming pass");
       }
    }
 
diff --git a/src/freedreno/vulkan/tu_cs.cc b/src/freedreno/vulkan/tu_cs.cc
index 47de2dc01a6d5..7e700e2c6dec7 100644
--- a/src/freedreno/vulkan/tu_cs.cc
+++ b/src/freedreno/vulkan/tu_cs.cc
@@ -427,7 +427,7 @@ tu_cs_reserve_space(struct tu_cs *cs, uint32_t reserved_size)
 {
    if (tu_cs_get_space(cs) < reserved_size) {
       if (cs->mode == TU_CS_MODE_EXTERNAL) {
-         unreachable("cannot grow external buffer");
+         UNREACHABLE("cannot grow external buffer");
          return VK_ERROR_OUT_OF_HOST_MEMORY;
       }
 
diff --git a/src/freedreno/vulkan/tu_descriptor_set.cc b/src/freedreno/vulkan/tu_descriptor_set.cc
index 01cddafc7a72e..a79c6d950a7e3 100644
--- a/src/freedreno/vulkan/tu_descriptor_set.cc
+++ b/src/freedreno/vulkan/tu_descriptor_set.cc
@@ -1244,7 +1244,7 @@ tu_GetDescriptorEXT(
                              pDescriptorInfo->data.pInputAttachmentImage);
       break;
    default:
-      unreachable("unimplemented descriptor type");
+      UNREACHABLE("unimplemented descriptor type");
       break;
    }
 }
@@ -1370,7 +1370,7 @@ tu_update_descriptor_sets(const struct tu_device *device,
             break;
          }
          default:
-            unreachable("unimplemented descriptor type");
+            UNREACHABLE("unimplemented descriptor type");
             break;
          }
          ptr += binding_layout->size / 4;
@@ -1712,7 +1712,7 @@ tu_update_descriptor_set_with_template(
             break;
          }
          default:
-            unreachable("unimplemented descriptor type");
+            UNREACHABLE("unimplemented descriptor type");
             break;
          }
          src = (char *) src + templ->entry[i].src_stride;
diff --git a/src/freedreno/vulkan/tu_device.cc b/src/freedreno/vulkan/tu_device.cc
index 0316928a20262..55659a562576a 100644
--- a/src/freedreno/vulkan/tu_device.cc
+++ b/src/freedreno/vulkan/tu_device.cc
@@ -1825,7 +1825,7 @@ tu_physical_device_get_global_priority_properties(const struct tu_physical_devic
       props->priorities[2] = VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR;
       break;
    default:
-      unreachable("unexpected priority count");
+      UNREACHABLE("unexpected priority count");
       break;
    }
 }
diff --git a/src/freedreno/vulkan/tu_formats.cc b/src/freedreno/vulkan/tu_formats.cc
index 30592ea26e79d..6bad3dda31820 100644
--- a/src/freedreno/vulkan/tu_formats.cc
+++ b/src/freedreno/vulkan/tu_formats.cc
@@ -442,7 +442,7 @@ tu_get_image_format_properties(
       format_feature_flags = format_props.optimalTilingFeatures;
       break;
    default:
-      unreachable("bad VkPhysicalDeviceImageFormatInfo2");
+      UNREACHABLE("bad VkPhysicalDeviceImageFormatInfo2");
    }
 
    if (format_feature_flags == 0)
@@ -454,7 +454,7 @@ tu_get_image_format_properties(
 
    switch (info->type) {
    default:
-      unreachable("bad vkimage type\n");
+      UNREACHABLE("bad vkimage type\n");
    case VK_IMAGE_TYPE_1D:
       maxExtent.width = 16384;
       maxExtent.height = 1;
diff --git a/src/freedreno/vulkan/tu_image.cc b/src/freedreno/vulkan/tu_image.cc
index 1af7157920ac0..44548feb99360 100644
--- a/src/freedreno/vulkan/tu_image.cc
+++ b/src/freedreno/vulkan/tu_image.cc
@@ -287,7 +287,7 @@ tu_image_view_init(struct tu_device *device,
       args.type = FDL_VIEW_TYPE_3D;
       break;
    default:
-      unreachable("unknown view type");
+      UNREACHABLE("unknown view type");
    }
 
    STATIC_ASSERT((unsigned)VK_CHROMA_LOCATION_COSITED_EVEN == (unsigned)FDL_CHROMA_LOCATION_COSITED_EVEN);
@@ -916,7 +916,7 @@ tu_BindImageMemory2(VkDevice _device,
       if (!mem) {
 #if DETECT_OS_ANDROID
          /* TODO handle VkNativeBufferANDROID */
-         unreachable("VkBindImageMemoryInfo with no memory");
+         UNREACHABLE("VkBindImageMemoryInfo with no memory");
 #else
          const VkBindImageMemorySwapchainInfoKHR *swapchain_info =
             vk_find_struct_const(pBindInfos[i].pNext,
diff --git a/src/freedreno/vulkan/tu_knl.cc b/src/freedreno/vulkan/tu_knl.cc
index 49374a5fb1a6d..96b90aa089241 100644
--- a/src/freedreno/vulkan/tu_knl.cc
+++ b/src/freedreno/vulkan/tu_knl.cc
@@ -147,7 +147,7 @@ tu_sync_cacheline_to_gpu(void const *p __attribute__((unused)))
     * Seems to be illegal to call from userspace.
     */
    //__asm volatile("mcr p15, 0, %0, c7, c10, 1" : : "r" (p) : "memory");
-   unreachable("Cache line clean is unsupported on ARMv7");
+   UNREACHABLE("Cache line clean is unsupported on ARMv7");
 #endif
 }
 
@@ -164,7 +164,7 @@ tu_sync_cacheline_from_gpu(void const *p __attribute__((unused)))
     * Seems to be illegal to call from userspace.
     */
    //__asm volatile("mcr p15, 0, %0, c7, c14, 1" : : "r" (p) : "memory");
-   unreachable("Cache line invalidate is unsupported on ARMv7");
+   UNREACHABLE("Cache line invalidate is unsupported on ARMv7");
 #endif
 }
 
diff --git a/src/freedreno/vulkan/tu_knl_drm_virtio.cc b/src/freedreno/vulkan/tu_knl_drm_virtio.cc
index 67cc88906bf5c..fd810c739d0d5 100644
--- a/src/freedreno/vulkan/tu_knl_drm_virtio.cc
+++ b/src/freedreno/vulkan/tu_knl_drm_virtio.cc
@@ -314,7 +314,7 @@ opt_cap_bool(uint32_t val)
 {
    if (val == VIRTGPU_CAP_BOOL_TRUE)  return true;
    if (val == VIRTGPU_CAP_BOOL_FALSE) return false;
-   unreachable("invalid val");
+   UNREACHABLE("invalid val");
 }
 
 static bool
diff --git a/src/freedreno/vulkan/tu_knl_kgsl.cc b/src/freedreno/vulkan/tu_knl_kgsl.cc
index aab25da7f6470..b902a55a2acad 100644
--- a/src/freedreno/vulkan/tu_knl_kgsl.cc
+++ b/src/freedreno/vulkan/tu_knl_kgsl.cc
@@ -657,7 +657,7 @@ kgsl_syncobj_wait(struct tu_device *device,
    }
 
    default:
-      unreachable("invalid syncobj state");
+      UNREACHABLE("invalid syncobj state");
    }
 }
 
@@ -804,7 +804,7 @@ kgsl_syncobj_export(struct kgsl_syncobj *s, int *pFd)
       return VK_SUCCESS;
 
    default:
-      unreachable("Invalid syncobj state");
+      UNREACHABLE("Invalid syncobj state");
    }
 }
 
@@ -895,7 +895,7 @@ kgsl_syncobj_merge(const struct kgsl_syncobj **syncobjs, uint32_t count)
          break;
 
       default:
-         unreachable("invalid syncobj state");
+         UNREACHABLE("invalid syncobj state");
       }
    }
 
@@ -1235,7 +1235,7 @@ kgsl_queue_submit(struct tu_queue *queue, void *_submit,
       break;
 
    default:
-      unreachable("invalid syncobj state");
+      UNREACHABLE("invalid syncobj state");
    }
 
    struct kgsl_gpu_command req = {
@@ -1354,7 +1354,7 @@ kgsl_device_finish(struct tu_device *dev)
 static int
 kgsl_device_get_gpu_timestamp(struct tu_device *dev, uint64_t *ts)
 {
-   unreachable("");
+   UNREACHABLE("");
    return 0;
 }
 
diff --git a/src/freedreno/vulkan/tu_lrz.cc b/src/freedreno/vulkan/tu_lrz.cc
index 07bd1bdfc24ed..414de6cc7145d 100644
--- a/src/freedreno/vulkan/tu_lrz.cc
+++ b/src/freedreno/vulkan/tu_lrz.cc
@@ -874,7 +874,7 @@ tu6_calculate_lrz_state(struct tu_cmd_buffer *cmd,
       gras_lrz_cntl.dir = LRZ_DIR_LE;
       break;
    default:
-      unreachable("bad VK_COMPARE_OP value or uninitialized");
+      UNREACHABLE("bad VK_COMPARE_OP value or uninitialized");
       break;
    };
 
diff --git a/src/freedreno/vulkan/tu_nir_lower_ray_query.cc b/src/freedreno/vulkan/tu_nir_lower_ray_query.cc
index c4bcbe05e45c6..012bed983432c 100644
--- a/src/freedreno/vulkan/tu_nir_lower_ray_query.cc
+++ b/src/freedreno/vulkan/tu_nir_lower_ray_query.cc
@@ -153,7 +153,7 @@ get_rq_deref(nir_builder *b, struct hash_table *ht, nir_def *def,
 
             out_deref = nir_build_deref_array(b, out_deref, index);
          } else {
-            unreachable("Unsupported deref type");
+            UNREACHABLE("Unsupported deref type");
          }
       }
    }
@@ -511,7 +511,7 @@ lower_rq_load(nir_builder *b, struct hash_table *ht, nir_intrinsic_instr *intr)
    case nir_ray_query_value_world_ray_origin:
       return rq_load(b, rq, world_origin);
    default:
-      unreachable("Invalid nir_ray_query_value!");
+      UNREACHABLE("Invalid nir_ray_query_value!");
    }
 
    return NULL;
@@ -1018,7 +1018,7 @@ tu_nir_lower_ray_queries(nir_shader *shader)
                lower_rq_terminate(&builder, query_ht, intrinsic);
                break;
             default:
-               unreachable("Unsupported ray query intrinsic!");
+               UNREACHABLE("Unsupported ray query intrinsic!");
             }
 
             if (new_dest)
diff --git a/src/freedreno/vulkan/tu_pipeline.cc b/src/freedreno/vulkan/tu_pipeline.cc
index be2eab1c52b79..d486e3f6cb24f 100644
--- a/src/freedreno/vulkan/tu_pipeline.cc
+++ b/src/freedreno/vulkan/tu_pipeline.cc
@@ -104,7 +104,7 @@ tu6_load_state_size(struct tu_pipeline *pipeline,
          case VK_DESCRIPTOR_TYPE_MUTABLE_EXT:
             break;
          default:
-            unreachable("bad descriptor type");
+            UNREACHABLE("bad descriptor type");
          }
          size += count * load_state_size;
       }
@@ -238,7 +238,7 @@ tu6_emit_load_state(struct tu_device *device,
             break;
          }
          default:
-            unreachable("bad descriptor type");
+            UNREACHABLE("bad descriptor type");
          }
       }
    }
@@ -630,7 +630,7 @@ tu6_emit_const(struct tu_cs *cs, uint32_t opcode, enum tu_geom_consts_type type,
          base = const_state->allocs.consts[IR3_CONST_ALLOC_PRIMITIVE_PARAM].offset_vec4;
          break;
       default:
-         unreachable("bad consts type");
+         UNREACHABLE("bad consts type");
       }
 
       int32_t adjusted_size = MIN2(base * 4 + size, constlen * 4) - base * 4;
@@ -658,7 +658,7 @@ tu6_emit_const(struct tu_cs *cs, uint32_t opcode, enum tu_geom_consts_type type,
          base = const_state->primitive_param_ubo.idx;
          break;
       default:
-         unreachable("bad consts type");
+         UNREACHABLE("bad consts type");
       }
       if (base == -1)
          return;
@@ -4248,7 +4248,7 @@ vk_shader_stage_to_pipeline_library_flags(VkShaderStageFlagBits stage)
    case VK_SHADER_STAGE_FRAGMENT_BIT:
       return VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT;
    default:
-      unreachable("Invalid shader stage");
+      UNREACHABLE("Invalid shader stage");
    }
 }
 
diff --git a/src/freedreno/vulkan/tu_query_pool.cc b/src/freedreno/vulkan/tu_query_pool.cc
index d0dfda11972af..4a2b0c1addf34 100644
--- a/src/freedreno/vulkan/tu_query_pool.cc
+++ b/src/freedreno/vulkan/tu_query_pool.cc
@@ -310,7 +310,7 @@ tu_CreateQueryPool(VkDevice _device,
       slot_size = sizeof(struct pipeline_stat_query_slot);
       break;
    default:
-      unreachable("Invalid query type");
+      UNREACHABLE("Invalid query type");
    }
 
    struct tu_query_pool *pool = (struct tu_query_pool *)
@@ -890,7 +890,7 @@ tu_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer,
                                                 queryCount, buffer, dstOffset,
                                                 stride, flags);
    case VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR:
-      unreachable("allowCommandBufferQueryCopies is false");
+      UNREACHABLE("allowCommandBufferQueryCopies is false");
    default:
       assert(!"Invalid query type");
    }
@@ -1386,7 +1386,7 @@ tu_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer,
       emit_begin_stat_query<CHIP>(cmdbuf, pool, query);
       break;
    case VK_QUERY_TYPE_TIMESTAMP:
-      unreachable("Unimplemented query type");
+      UNREACHABLE("Unimplemented query type");
    default:
       assert(!"Invalid query type");
    }
@@ -1976,7 +1976,7 @@ tu_CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer,
       emit_end_stat_query<CHIP>(cmdbuf, pool, query);
       break;
    case VK_QUERY_TYPE_TIMESTAMP:
-      unreachable("Unimplemented query type");
+      UNREACHABLE("Unimplemented query type");
    default:
       assert(!"Invalid query type");
    }
@@ -2099,7 +2099,7 @@ tu_CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer,
          va += offsetof(struct tu_accel_struct_header, size);
          break;
       default:
-         unreachable("Unhandle accel struct query type.");
+         UNREACHABLE("Unhandle accel struct query type.");
       }
 
       tu_cs_emit_pkt7(cs, CP_MEM_TO_MEM, 5);
diff --git a/src/freedreno/vulkan/tu_sampler.cc b/src/freedreno/vulkan/tu_sampler.cc
index fd4f9423e0e97..593b1552a4509 100644
--- a/src/freedreno/vulkan/tu_sampler.cc
+++ b/src/freedreno/vulkan/tu_sampler.cc
@@ -73,7 +73,7 @@ tu_CreateSampler(VkDevice _device,
             fast_border_color = A6XX_BORDER_COLOR_1_1_1_1;
             break;
          default:
-            unreachable("unknown border color");
+            UNREACHABLE("unknown border color");
       }
    }
 
diff --git a/src/freedreno/vulkan/tu_shader.cc b/src/freedreno/vulkan/tu_shader.cc
index 8fa88f98eb9d2..58474366f8a3f 100644
--- a/src/freedreno/vulkan/tu_shader.cc
+++ b/src/freedreno/vulkan/tu_shader.cc
@@ -1438,7 +1438,7 @@ tu6_emit_xs(struct tu_cs *cs,
       ));
       break;
    default:
-      unreachable("bad shader stage");
+      UNREACHABLE("bad shader stage");
    }
 
    tu_cs_emit_pkt4(cs, cfg->reg_sp_xs_instrlen, 1);
@@ -1745,7 +1745,7 @@ tu6_tex_opc_to_prefetch_cmd(opc_t tex_opc)
    case OPC_SAM:
       return TEX_PREFETCH_SAM;
    default:
-      unreachable("Unknown tex opc for prefeth cmd");
+      UNREACHABLE("Unknown tex opc for prefeth cmd");
    }
 }
 
@@ -2149,7 +2149,7 @@ primitive_to_tess(enum mesa_prim primitive) {
    case MESA_PRIM_TRIANGLE_STRIP:
       return TESS_CW_TRIS;
    default:
-      unreachable("");
+      UNREACHABLE("");
    }
 }
 
@@ -2250,7 +2250,7 @@ tu6_emit_variant(struct tu_cs *cs,
       tu6_emit_fs<CHIP>(cs, xs);
       break;
    default:
-      unreachable("unknown shader stage");
+      UNREACHABLE("unknown shader stage");
    }
 }
 
@@ -2848,7 +2848,7 @@ tu_shader_create(struct tu_device *dev,
          break;
       case TESS_SPACING_UNSPECIFIED:
       default:
-         unreachable("invalid tess spacing");
+         UNREACHABLE("invalid tess spacing");
       }
 
       break;
@@ -3002,7 +3002,7 @@ tu6_get_tessmode(const struct nir_shader *shader)
    case TESS_PRIMITIVE_UNSPECIFIED:
       return IR3_TESS_NONE;
    default:
-      unreachable("bad tessmode");
+      UNREACHABLE("bad tessmode");
    }
 }
 
diff --git a/src/freedreno/vulkan/tu_util.h b/src/freedreno/vulkan/tu_util.h
index 5aa900431f66e..48d1b75417c7c 100644
--- a/src/freedreno/vulkan/tu_util.h
+++ b/src/freedreno/vulkan/tu_util.h
@@ -344,7 +344,7 @@ tu6_tex_filter(VkFilter filter, unsigned aniso)
    case VK_FILTER_CUBIC_EXT:
       return A6XX_TEX_CUBIC;
    default:
-      unreachable("illegal texture filter");
+      UNREACHABLE("illegal texture filter");
       break;
    }
 }
@@ -384,7 +384,7 @@ tu6_polygon_mode(VkPolygonMode mode)
    case VK_POLYGON_MODE_FILL:
       return POLYMODE6_TRIANGLES;
    default:
-      unreachable("bad polygon mode");
+      UNREACHABLE("bad polygon mode");
    }
 }
 
diff --git a/src/gallium/auxiliary/driver_trace/tr_video.c b/src/gallium/auxiliary/driver_trace/tr_video.c
index d052c86ca8e1c..74b04a8d6fe5c 100644
--- a/src/gallium/auxiliary/driver_trace/tr_video.c
+++ b/src/gallium/auxiliary/driver_trace/tr_video.c
@@ -98,7 +98,7 @@ unwrap_refrence_frames(struct pipe_picture_desc **picture)
     }
     case PIPE_VIDEO_FORMAT_UNKNOWN:
     default:
-        unreachable("unknown video format");
+        UNREACHABLE("unknown video format");
     }
 }
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_arit.c b/src/gallium/auxiliary/gallivm/lp_bld_arit.c
index d67813069ae89..976307a595ab3 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_arit.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_arit.c
@@ -1844,7 +1844,7 @@ lp_build_round_arch(struct lp_build_context *bld,
          intrinsic_root = "llvm.trunc";
          break;
       default:
-         unreachable("unhandled lp_build_round_mode");
+         UNREACHABLE("unhandled lp_build_round_mode");
       }
 
       lp_format_intrinsic(intrinsic, sizeof intrinsic, intrinsic_root, bld->vec_type);
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_format.c b/src/gallium/auxiliary/gallivm/lp_bld_format.c
index 796277feee702..3f782a34ad000 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_format.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_format.c
@@ -36,7 +36,7 @@ LLVMTypeRef lp_build_format_cache_elem_type(struct gallivm_state *gallivm, enum
    case LP_BUILD_FORMAT_CACHE_MEMBER_TAGS:
       return LLVMInt64TypeInContext(gallivm->context);
    default:
-      unreachable("lp_build_format_cache_elem_type unhandled member type");
+      UNREACHABLE("lp_build_format_cache_elem_type unhandled member type");
    }
 }
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_intr.c b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
index 284f83d7411a0..a98014f54426a 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_intr.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_intr.c
@@ -91,7 +91,7 @@ lp_format_intrinsic(char *name,
       width = 16;
       break;
    default:
-      unreachable("unexpected LLVMTypeKind");
+      UNREACHABLE("unexpected LLVMTypeKind");
    }
 
    if (length) {
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c b/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c
index 01ad922f06a1b..a94b238edbea8 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c
@@ -151,7 +151,7 @@ lp_nir_instr_src_divergent(nir_instr *instr, uint32_t src_index)
    case nir_instr_type_call:
       return true;
    default:
-      unreachable("Unhandled instruction type");
+      UNREACHABLE("Unhandled instruction type");
    }
 }
 
@@ -2880,7 +2880,7 @@ get_src_index(nir_src *src)
       return ((uintptr_t)src - (uintptr_t)&call->params[0]) / sizeof(nir_src);
    }
    default:
-      unreachable("Unhandled instruction type");
+      UNREACHABLE("Unhandled instruction type");
    }
 }
 
@@ -2918,7 +2918,7 @@ get_instr_src_vec(struct lp_build_nir_soa_context *bld, nir_instr *instr, uint32
       break;
    }
    default:
-      unreachable("Unhandled instruction type");
+      UNREACHABLE("Unhandled instruction type");
    }
 
    bool divergent = lp_nir_instr_src_divergent(instr, src_index);
@@ -3320,7 +3320,7 @@ do_alu_action(struct lp_build_nir_soa_context *bld,
       break;
    }
    case nir_op_fisfinite32:
-      unreachable("Should have been lowered in nir_opt_algebraic_late.");
+      UNREACHABLE("Should have been lowered in nir_opt_algebraic_late.");
    case nir_op_flog2:
       result = lp_build_log2_safe(float_bld, src[0]);
       break;
@@ -3773,7 +3773,7 @@ get_deref_offset(struct lp_build_nir_soa_context *bld, nir_deref_instr *instr,
                offset = array_off;
          }
       } else
-         unreachable("Uhandled deref type in get_deref_instr_offset");
+         UNREACHABLE("Uhandled deref type in get_deref_instr_offset");
    }
 
 out:
@@ -4351,7 +4351,7 @@ lp_translate_atomic_op(nir_atomic_op op)
    case nir_atomic_op_fmin: return LLVMAtomicRMWBinOpFMin;
    case nir_atomic_op_fmax: return LLVMAtomicRMWBinOpFMax;
 #endif
-   default:          unreachable("Unexpected atomic");
+   default:          UNREACHABLE("Unexpected atomic");
    }
 }
 
@@ -5558,7 +5558,7 @@ visit_tex(struct lp_build_nir_soa_context *bld, nir_tex_instr *instr)
          vec_type = bld->uint16_bld.vec_type;
          break;
       default:
-         unreachable("unexpected alu type");
+         UNREACHABLE("unexpected alu type");
       }
       for (int i = 0; i < instr->def.num_components; ++i) {
          if (is_float) {
@@ -5599,7 +5599,7 @@ visit_jump(struct lp_build_nir_soa_context *bld,
       continue_stmt(bld);
       break;
    default:
-      unreachable("Unknown jump instr\n");
+      UNREACHABLE("Unknown jump instr\n");
    }
 }
 
@@ -5621,7 +5621,7 @@ visit_deref(struct lp_build_nir_soa_context *bld,
       break;
    }
    default:
-      unreachable("Unhandled deref_instr deref type");
+      UNREACHABLE("Unhandled deref_instr deref type");
    }
 
    assign_ssa_dest(bld, &instr->def, result);
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c b/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
index 979e73dd13feb..ec7a1bcba13d5 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
@@ -2499,7 +2499,7 @@ lp_build_sample_common(struct lp_build_sample_context *bld,
 
    switch (mip_filter) {
    default:
-      unreachable("Bad mip_filter value in lp_build_sample_soa()");
+      UNREACHABLE("Bad mip_filter value in lp_build_sample_soa()");
    case PIPE_TEX_MIPFILTER_NONE:
       /* always use mip level 0 */
       *ilevel0 = first_level;
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_swizzle.c b/src/gallium/auxiliary/gallivm/lp_bld_swizzle.c
index 2d6dfcd38ceaf..aa7bc1e858a43 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_swizzle.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_swizzle.c
@@ -395,7 +395,7 @@ lp_build_swizzle_aos(struct lp_build_context *bld,
             unsigned shuffle;
             switch (swizzles[i]) {
             default:
-               unreachable("Unsupported swizzle");
+               UNREACHABLE("Unsupported swizzle");
             case PIPE_SWIZZLE_X:
             case PIPE_SWIZZLE_Y:
             case PIPE_SWIZZLE_Z:
diff --git a/src/gallium/auxiliary/nir/nir_draw_helpers.c b/src/gallium/auxiliary/nir/nir_draw_helpers.c
index 272102c4645a7..677b7c35be855 100644
--- a/src/gallium/auxiliary/nir/nir_draw_helpers.c
+++ b/src/gallium/auxiliary/nir/nir_draw_helpers.c
@@ -94,7 +94,7 @@ nir_lower_pstipple_block(nir_block *block,
                              nir_imm_floatN_t(b, 0.0, tex->def.bit_size));
       break;
    default:
-      unreachable("Invalid Boolean type.");
+      UNREACHABLE("Invalid Boolean type.");
    }
 
    nir_discard_if(b, condition);
@@ -342,7 +342,7 @@ nir_lower_aapoint_impl(nir_function_impl *impl, lower_aapoint *state,
       comp = nir_slt(b, chan_val_one, dist);
       break;
    default:
-      unreachable("Invalid Boolean type.");
+      UNREACHABLE("Invalid Boolean type.");
    }
 
    nir_discard_if(b, comp);
@@ -398,7 +398,7 @@ nir_lower_aapoint_impl(nir_function_impl *impl, lower_aapoint *state,
       break;
    }
    default:
-      unreachable("Invalid Boolean type.");
+      UNREACHABLE("Invalid Boolean type.");
    }
 
    nir_foreach_block(block, impl) {
diff --git a/src/gallium/auxiliary/nir/nir_to_tgsi.c b/src/gallium/auxiliary/nir/nir_to_tgsi.c
index dc31a256c3bb7..e2bada33a00fb 100644
--- a/src/gallium/auxiliary/nir/nir_to_tgsi.c
+++ b/src/gallium/auxiliary/nir/nir_to_tgsi.c
@@ -828,7 +828,7 @@ ntt_try_store_ssa_in_tgsi_output(struct ntt_compile *c, struct ureg_dst *dst,
    nir_foreach_use_including_if(use, def) {
       return ntt_try_store_in_tgsi_output_with_use(c, dst, use);
    }
-   unreachable("We have one use");
+   UNREACHABLE("We have one use");
 }
 
 static void
@@ -987,7 +987,7 @@ tgsi_texture_type_from_sampler_dim(enum glsl_sampler_dim dim, bool is_array, boo
    case GLSL_SAMPLER_DIM_BUF:
       return TGSI_TEXTURE_BUFFER;
    default:
-      unreachable("unknown sampler dim");
+      UNREACHABLE("unknown sampler dim");
    }
 }
 
@@ -1002,7 +1002,7 @@ tgsi_return_type_from_base_type(enum glsl_base_type type)
    case GLSL_TYPE_FLOAT:
      return TGSI_RETURN_TYPE_FLOAT;
    default:
-      unreachable("unexpected texture type");
+      UNREACHABLE("unexpected texture type");
    }
 }
 
@@ -1704,7 +1704,7 @@ ntt_emit_alu(struct ntt_compile *c, nir_alu_instr *instr)
          break;
 
       case nir_op_fmod:
-         unreachable("should be handled by .lower_fmod = true");
+         UNREACHABLE("should be handled by .lower_fmod = true");
          break;
 
       case nir_op_fpow:
@@ -1780,7 +1780,7 @@ ntt_emit_alu(struct ntt_compile *c, nir_alu_instr *instr)
 
       case nir_op_frexp_sig:
       case nir_op_frexp_exp:
-         unreachable("covered by nir_lower_frexp()");
+         UNREACHABLE("covered by nir_lower_frexp()");
          break;
 
       case nir_op_ldexp:
@@ -1794,11 +1794,11 @@ ntt_emit_alu(struct ntt_compile *c, nir_alu_instr *instr)
       case nir_op_vec4:
       case nir_op_vec3:
       case nir_op_vec2:
-         unreachable("covered by nir_lower_vec_to_movs()");
+         UNREACHABLE("covered by nir_lower_vec_to_movs()");
 
       default:
          fprintf(stderr, "Unknown NIR opcode: %s\n", nir_op_infos[instr->op].name);
-         unreachable("Unknown NIR opcode");
+         UNREACHABLE("Unknown NIR opcode");
       }
    }
 
@@ -1964,7 +1964,7 @@ ntt_translate_atomic_op(nir_atomic_op op)
    case nir_atomic_op_ixor: return TGSI_OPCODE_ATOMXOR;
    case nir_atomic_op_ior:  return TGSI_OPCODE_ATOMOR;
    case nir_atomic_op_xchg: return TGSI_OPCODE_ATOMXCHG;
-   default: unreachable("invalid atomic");
+   default: UNREACHABLE("invalid atomic");
    }
 }
 
@@ -2015,7 +2015,7 @@ ntt_emit_mem(struct ntt_compile *c, nir_intrinsic_instr *instr,
    }
 
    default:
-      unreachable("unknown memory type");
+      UNREACHABLE("unknown memory type");
    }
 
    if (is_store) {
@@ -2088,7 +2088,7 @@ ntt_emit_mem(struct ntt_compile *c, nir_intrinsic_instr *instr,
       opcode = TGSI_OPCODE_RESQ;
       break;
    default:
-      unreachable("unknown memory op");
+      UNREACHABLE("unknown memory op");
    }
 
    unsigned qualifier = 0;
@@ -2206,7 +2206,7 @@ ntt_emit_image_load_store(struct ntt_compile *c, nir_intrinsic_instr *instr)
       op = TGSI_OPCODE_ATOMCAS;
       break;
    default:
-      unreachable("bad op");
+      UNREACHABLE("bad op");
    }
 
    struct ntt_insn *insn = ntt_insn(c, op, opcode_dst, srcs[0], srcs[1], srcs[2], srcs[3]);
@@ -2312,13 +2312,13 @@ ntt_emit_load_input(struct ntt_compile *c, nir_intrinsic_instr *instr)
          break;
 
       default:
-         unreachable("bad barycentric interp intrinsic\n");
+         UNREACHABLE("bad barycentric interp intrinsic\n");
       }
       break;
    }
 
    default:
-      unreachable("bad load input intrinsic\n");
+      UNREACHABLE("bad load input intrinsic\n");
    }
 }
 
@@ -2640,7 +2640,7 @@ ntt_emit_intrinsic(struct ntt_compile *c, nir_intrinsic_instr *instr)
       ntt_emit_mem(c, instr, nir_var_uniform);
       break;
    case nir_intrinsic_atomic_counter_pre_dec:
-      unreachable("Should be lowered by ntt_lower_atomic_pre_dec()");
+      UNREACHABLE("Should be lowered by ntt_lower_atomic_pre_dec()");
       break;
 
    case nir_intrinsic_image_load:
@@ -2808,7 +2808,7 @@ ntt_emit_texture(struct ntt_compile *c, nir_tex_instr *instr)
       tex_opcode = TGSI_OPCODE_TXQS;
       break;
    default:
-      unreachable("unsupported tex op");
+      UNREACHABLE("unsupported tex op");
    }
 
    struct ntt_tex_operand_state s = { .i = 0 };
@@ -2864,7 +2864,7 @@ ntt_emit_texture(struct ntt_compile *c, nir_tex_instr *instr)
       tex_type = TGSI_RETURN_TYPE_UINT;
       break;
    default:
-      unreachable("unknown texture type");
+      UNREACHABLE("unknown texture type");
    }
 
    struct ureg_dst tex_dst;
@@ -3019,7 +3019,7 @@ ntt_emit_block(struct ntt_compile *c, nir_block *block)
          fprintf(stderr, "Emitted ureg insn during: ");
          nir_print_instr(instr, stderr);
          fprintf(stderr, "\n");
-         unreachable("emitted ureg insn");
+         UNREACHABLE("emitted ureg insn");
       }
    }
 
@@ -3053,7 +3053,7 @@ ntt_emit_cf_list(struct ntt_compile *c, struct exec_list *list)
          break;
 
       default:
-         unreachable("unknown CF type");
+         UNREACHABLE("unknown CF type");
       }
    }
 }
@@ -3169,7 +3169,7 @@ ntt_emit_cf_list_ureg(struct ntt_compile *c, struct exec_list *list)
          break;
 
       default:
-         unreachable("unknown CF type");
+         UNREACHABLE("unknown CF type");
       }
    }
 }
diff --git a/src/gallium/auxiliary/nir/nir_to_tgsi_info.c b/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
index dd5bb71c39716..3d5c50a7978c4 100644
--- a/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
+++ b/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
@@ -90,7 +90,7 @@ static void gather_usage_helper(const nir_deref_instr **deref_ptr,
          break;
       }
       default:
-         unreachable("Unhandled deref type in gather_components_used_helper");
+         UNREACHABLE("Unhandled deref type in gather_components_used_helper");
       }
    }
 
@@ -316,7 +316,7 @@ void nir_tgsi_scan_shader(const struct nir_shader *nir,
             info->properties[TGSI_PROPERTY_FS_DEPTH_LAYOUT] = TGSI_FS_DEPTH_LAYOUT_UNCHANGED;
             break;
          default:
-            unreachable("Unknow depth layout");
+            UNREACHABLE("Unknow depth layout");
          }
       }
    }
@@ -485,7 +485,7 @@ void nir_tgsi_scan_shader(const struct nir_shader *nir,
                usagemask |= TGSI_WRITEMASK_W;
                break;
             default:
-               unreachable("error calculating component index");
+               UNREACHABLE("error calculating component index");
             }
          }
 
diff --git a/src/gallium/auxiliary/nir/pipe_nir.h b/src/gallium/auxiliary/nir/pipe_nir.h
index b01d4984a90d2..d31eeb0885ffe 100644
--- a/src/gallium/auxiliary/nir/pipe_nir.h
+++ b/src/gallium/auxiliary/nir/pipe_nir.h
@@ -43,7 +43,7 @@ pipe_shader_from_nir(struct pipe_context *pipe, nir_shader *nir)
    }
 
    default:
-      unreachable("unexpected shader stage");
+      UNREACHABLE("unexpected shader stage");
    }
 }
 
diff --git a/src/gallium/auxiliary/nir/tgsi_to_nir.c b/src/gallium/auxiliary/nir/tgsi_to_nir.c
index a8e2c9b4c78bc..ef05b784e7bfa 100644
--- a/src/gallium/auxiliary/nir/tgsi_to_nir.c
+++ b/src/gallium/auxiliary/nir/tgsi_to_nir.c
@@ -174,7 +174,7 @@ ttn_get_depth_layout(unsigned tgsi_fs_depth_layout)
    case TGSI_FS_DEPTH_LAYOUT_UNCHANGED:
       return FRAG_DEPTH_LAYOUT_UNCHANGED;
    default:
-      unreachable("bad TGSI FS depth layout");
+      UNREACHABLE("bad TGSI FS depth layout");
    }
 }
 
@@ -191,7 +191,7 @@ ttn_translate_interp_mode(unsigned tgsi_interp)
    case TGSI_INTERPOLATE_COLOR:
       return INTERP_MODE_NONE;
    default:
-      unreachable("bad TGSI interpolation mode");
+      UNREACHABLE("bad TGSI interpolation mode");
    }
 }
 
@@ -450,7 +450,7 @@ ttn_emit_declaration(struct ttn_compile *c)
             var->data.location = idx;
             break;
          default:
-            unreachable("bad declaration file");
+            UNREACHABLE("bad declaration file");
             return;
          }
 
@@ -633,7 +633,7 @@ ttn_src_for_file_and_index(struct ttn_compile *c, unsigned file, unsigned index,
          b->shader->info.fs.uses_sample_shading = true;
          break;
       default:
-         unreachable("bad system value");
+         UNREACHABLE("bad system value");
       }
 
       if (load->num_components == 2)
@@ -674,7 +674,7 @@ ttn_src_for_file_and_index(struct ttn_compile *c, unsigned file, unsigned index,
                                                       c->outputs[index]);
          return nir_src_for_ssa(nir_load_deref(&c->build, deref));
       }
-      unreachable("unsupported output read");
+      UNREACHABLE("unsupported output read");
       break;
 
    case TGSI_FILE_CONSTANT: {
@@ -751,7 +751,7 @@ ttn_src_for_file_and_index(struct ttn_compile *c, unsigned file, unsigned index,
    }
 
    default:
-      unreachable("bad src file");
+      UNREACHABLE("bad src file");
    }
 
 
@@ -1082,7 +1082,7 @@ base_type_for_alu_type(nir_alu_type type)
    case nir_type_uint:
       return GLSL_TYPE_UINT;
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
    }
 }
 
@@ -1543,7 +1543,7 @@ ttn_mem(struct ttn_compile *c, nir_def **src)
       addr_src_index = 0;
       break;
    default:
-      unreachable("unexpected memory opcode");
+      UNREACHABLE("unexpected memory opcode");
    }
 
    if (file == TGSI_FILE_BUFFER) {
@@ -1557,7 +1557,7 @@ ttn_mem(struct ttn_compile *c, nir_def **src)
          op = nir_intrinsic_store_ssbo;
          break;
       default:
-         unreachable("unexpected buffer opcode");
+         UNREACHABLE("unexpected buffer opcode");
       }
 
       add_ssbo_var(c, resource_index);
@@ -1588,7 +1588,7 @@ ttn_mem(struct ttn_compile *c, nir_def **src)
          op = nir_intrinsic_image_deref_store;
          break;
       default:
-         unreachable("unexpected file opcode");
+         UNREACHABLE("unexpected file opcode");
       }
 
       instr = nir_intrinsic_instr_create(b->shader, op);
@@ -1634,7 +1634,7 @@ ttn_mem(struct ttn_compile *c, nir_def **src)
 
       instr->num_components = num_components;
    } else {
-      unreachable("unexpected file");
+      UNREACHABLE("unexpected file");
    }
 
 
@@ -2343,7 +2343,7 @@ ttn_compile_init(const void *tgsi_tokens,
          if (value) {
             fprintf(stderr, "tgsi_to_nir: unhandled TGSI property %u = %u\n",
                     i, value);
-            unreachable("unhandled TGSI property");
+            UNREACHABLE("unhandled TGSI property");
          }
       }
    }
diff --git a/src/gallium/auxiliary/tessellator/tessellator.cpp b/src/gallium/auxiliary/tessellator/tessellator.cpp
index 952928b060bcd..88aa10a0031de 100644
--- a/src/gallium/auxiliary/tessellator/tessellator.cpp
+++ b/src/gallium/auxiliary/tessellator/tessellator.cpp
@@ -2230,7 +2230,7 @@ void CHLSLTessellator::QuadHLSLProcessTessFactors( float tessFactor_Ueq0, float
             insideTessFactor[U] = (tessFactor_Veq0 + tessFactor_Veq1 + tessFactor_Ueq0 + tessFactor_Ueq1) / 4;
             break;
         default:
-            unreachable("impossible m_insideTessFactorReduction");
+            UNREACHABLE("impossible m_insideTessFactorReduction");
         }
         // Scale inside tessFactor based on user scale factor.
 
@@ -2297,7 +2297,7 @@ void CHLSLTessellator::QuadHLSLProcessTessFactors( float tessFactor_Ueq0, float
             insideTessFactor[V] = (tessFactor_Ueq0 + tessFactor_Ueq1) / 2;
             break;
         default:
-            unreachable("impossible m_insideTessFactorReduction");
+            UNREACHABLE("impossible m_insideTessFactorReduction");
         }
         // Scale inside tessFactors based on user scale factor.
 
@@ -2470,7 +2470,7 @@ void CHLSLTessellator::TriHLSLProcessTessFactors( float tessFactor_Ueq0, float t
         insideTessFactor = (tessFactor_Ueq0 + tessFactor_Veq0 + tessFactor_Weq0) / 3;
         break;
     default:
-        unreachable("impossible m_insideTessFactorReduction");
+        UNREACHABLE("impossible m_insideTessFactorReduction");
     }
 
     // Scale inside TessFactor based on user scale factor.
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.c b/src/gallium/auxiliary/tgsi/tgsi_exec.c
index 3b5398d6120f2..8962f2f95d9ce 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.c
@@ -1713,7 +1713,7 @@ store_dest_dstret(struct tgsi_exec_machine *mach,
       break;
 
    default:
-      unreachable("Bad destination file");
+      UNREACHABLE("Bad destination file");
    }
 
    return dst;
@@ -3706,7 +3706,7 @@ exec_load_membuf(struct tgsi_exec_machine *mach,
       break;
 
    default:
-      unreachable("unsupported TGSI_OPCODE_LOAD file");
+      UNREACHABLE("unsupported TGSI_OPCODE_LOAD file");
    }
 
    union tgsi_exec_channel offset;
@@ -3839,7 +3839,7 @@ exec_store_membuf(struct tgsi_exec_machine *mach,
       break;
 
    default:
-      unreachable("unsupported TGSI_OPCODE_STORE file");
+      UNREACHABLE("unsupported TGSI_OPCODE_STORE file");
    }
 
    union tgsi_exec_channel offset;
@@ -4030,7 +4030,7 @@ exec_atomop_membuf(struct tgsi_exec_machine *mach,
                result = fui(uif(val) + r0.f[i]);
             break;
          default:
-            unreachable("bad atomic op");
+            UNREACHABLE("bad atomic op");
          }
          memcpy(ptr[i], &result, sizeof(result));
       }
diff --git a/src/gallium/auxiliary/tgsi/tgsi_from_mesa.c b/src/gallium/auxiliary/tgsi/tgsi_from_mesa.c
index 5128cd16c3b19..d0e0ea4463209 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_from_mesa.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_from_mesa.c
@@ -296,7 +296,7 @@ tgsi_get_sysval_semantic(unsigned sysval)
       return TGSI_SEMANTIC_SUBGROUP_LT_MASK;
 
    default:
-      unreachable("Unexpected system value to TGSI");
+      UNREACHABLE("Unexpected system value to TGSI");
    }
 }
 
@@ -313,6 +313,6 @@ tgsi_get_interp_mode(enum glsl_interp_mode mode, bool color)
    case INTERP_MODE_SMOOTH:
       return TGSI_INTERPOLATE_PERSPECTIVE;
    default:
-      unreachable("unknown interpolation mode");
+      UNREACHABLE("unknown interpolation mode");
    }
 }
diff --git a/src/gallium/auxiliary/tgsi/tgsi_scan.c b/src/gallium/auxiliary/tgsi/tgsi_scan.c
index a9aa0fe4b5c3c..b21438de8c51f 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_scan.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_scan.c
@@ -365,7 +365,7 @@ scan_declaration(struct tgsi_shader_info *info,
          break;
 
       case TGSI_FILE_NULL:
-         unreachable("unexpected file");
+         UNREACHABLE("unexpected file");
 
       default:
          break;
@@ -539,7 +539,7 @@ scan_declaration(struct tgsi_shader_info *info,
          break;
 
       case TGSI_FILE_NULL:
-         unreachable("unexpected file");
+         UNREACHABLE("unexpected file");
 
       default:
          break;
diff --git a/src/gallium/auxiliary/util/u_inlines.h b/src/gallium/auxiliary/util/u_inlines.h
index 4bb3dbd362c7e..7f8b437d70e24 100644
--- a/src/gallium/auxiliary/util/u_inlines.h
+++ b/src/gallium/auxiliary/util/u_inlines.h
@@ -919,7 +919,7 @@ util_logicop_reads_dest(enum pipe_logicop op)
    case PIPE_LOGICOP_SET:
       return false;
    }
-   unreachable("bad logicop");
+   UNREACHABLE("bad logicop");
 }
 
 static inline bool
diff --git a/src/gallium/auxiliary/util/u_sample_positions.c b/src/gallium/auxiliary/util/u_sample_positions.c
index a96e8c038ccf9..f186f216a7d89 100644
--- a/src/gallium/auxiliary/util/u_sample_positions.c
+++ b/src/gallium/auxiliary/util/u_sample_positions.c
@@ -68,7 +68,7 @@ u_default_sample_position(unsigned sample_count, unsigned sample_index)
    case  4: return u_default_sample_positions_4x[sample_index];
    case  8: return u_default_sample_positions_8x[sample_index];
    case 16: return u_default_sample_positions_16x[sample_index];
-   default: unreachable("Invalid sample count");
+   default: UNREACHABLE("Invalid sample count");
    }
 }
 
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 44fe0ff18ac48..497ee5d652a2d 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -3433,7 +3433,7 @@ static struct pipe_video_codec *
 tc_create_video_codec(UNUSED struct pipe_context *_pipe,
                       UNUSED const struct pipe_video_codec *templ)
 {
-   unreachable("Threaded context should not be enabled for video APIs");
+   UNREACHABLE("Threaded context should not be enabled for video APIs");
    return NULL;
 }
 
@@ -3441,7 +3441,7 @@ static struct pipe_video_buffer *
 tc_create_video_buffer(UNUSED struct pipe_context *_pipe,
                        UNUSED const struct pipe_video_buffer *templ)
 {
-   unreachable("Threaded context should not be enabled for video APIs");
+   UNREACHABLE("Threaded context should not be enabled for video APIs");
    return NULL;
 }
 
diff --git a/src/gallium/auxiliary/util/u_transfer_helper.c b/src/gallium/auxiliary/util/u_transfer_helper.c
index debf3fba725bb..0455e48b6a7c3 100644
--- a/src/gallium/auxiliary/util/u_transfer_helper.c
+++ b/src/gallium/auxiliary/util/u_transfer_helper.c
@@ -376,7 +376,7 @@ u_transfer_helper_transfer_map(struct pipe_context *pctx,
                                                 width, height);
             break;
          default:
-            unreachable("Unexpected format");
+            UNREACHABLE("Unexpected format");
          }
       }
    } else if (prsc->format == PIPE_FORMAT_Z24X8_UNORM) {
@@ -385,7 +385,7 @@ u_transfer_helper_transfer_map(struct pipe_context *pctx,
                                               trans->ptr, trans->trans->stride,
                                               width, height);
    } else {
-      unreachable("bleh");
+      UNREACHABLE("bleh");
    }
 
    *pptrans = ptrans;
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 8aaf38600ff0c..f023a9f76a0fb 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -1355,7 +1355,7 @@ u_vbuf_get_minmax_index_mapped(const struct pipe_draw_info *info,
       break;
    }
    default:
-      unreachable("bad index size");
+      UNREACHABLE("bad index size");
    }
 }
 
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
index 1a0f1f78b50b0..99e319ddd9463 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
@@ -380,7 +380,7 @@ MotionVectorToPipe(const struct pipe_mpeg12_macroblock *mb, unsigned vector,
          break;
 
       default:
-         unreachable("TODO: Support DUALPRIME and 16x8");
+         UNREACHABLE("TODO: Support DUALPRIME and 16x8");
       }
    } else {
       mv.top.x = mv.top.y = 0;
diff --git a/src/gallium/drivers/asahi/agx_blit.c b/src/gallium/drivers/asahi/agx_blit.c
index e715e0e1ce470..14c524d9d3082 100644
--- a/src/gallium/drivers/asahi/agx_blit.c
+++ b/src/gallium/drivers/asahi/agx_blit.c
@@ -537,7 +537,7 @@ agx_blit(struct pipe_context *pipe, const struct pipe_blit_info *info)
       fprintf(stderr, "\n");
       util_dump_blit_info(stderr, info);
       fprintf(stderr, "\n\n");
-      unreachable("Unsupported blit");
+      UNREACHABLE("Unsupported blit");
    }
 
    /* Handle self-blits */
diff --git a/src/gallium/drivers/asahi/agx_nir_lower_sysvals.c b/src/gallium/drivers/asahi/agx_nir_lower_sysvals.c
index 6d7d1ed7c70d7..ac062ce2acccd 100644
--- a/src/gallium/drivers/asahi/agx_nir_lower_sysvals.c
+++ b/src/gallium/drivers/asahi/agx_nir_lower_sysvals.c
@@ -326,7 +326,7 @@ find_push_range_containing(struct agx_compiled_shader *shader, uint8_t table,
          return range;
    }
 
-   unreachable("no containing range");
+   UNREACHABLE("no containing range");
 }
 
 static unsigned
diff --git a/src/gallium/drivers/asahi/agx_query.c b/src/gallium/drivers/asahi/agx_query.c
index 1c2803cf147da..cf5da24275225 100644
--- a/src/gallium/drivers/asahi/agx_query.c
+++ b/src/gallium/drivers/asahi/agx_query.c
@@ -418,7 +418,7 @@ agx_get_query_result(struct pipe_context *pctx, struct pipe_query *pquery,
       return true;
 
    default:
-      unreachable("Other queries not yet supported");
+      UNREACHABLE("Other queries not yet supported");
    }
 }
 
diff --git a/src/gallium/drivers/asahi/agx_state.c b/src/gallium/drivers/asahi/agx_state.c
index 4f0b46c526375..8b069052a12bd 100644
--- a/src/gallium/drivers/asahi/agx_state.c
+++ b/src/gallium/drivers/asahi/agx_state.c
@@ -365,7 +365,7 @@ agx_translate_polygon_mode(unsigned mode)
    case PIPE_POLYGON_MODE_LINE:
       return AGX_POLYGON_MODE_LINE;
    default:
-      unreachable("Unsupported polygon mode");
+      UNREACHABLE("Unsupported polygon mode");
    }
 }
 
@@ -453,7 +453,7 @@ agx_wrap_from_pipe(enum pipe_tex_wrap in)
    case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
       return AGX_WRAP_MIRRORED_CLAMP_TO_EDGE;
    default:
-      unreachable("Invalid wrap mode");
+      UNREACHABLE("Invalid wrap mode");
    }
 }
 
@@ -469,7 +469,7 @@ agx_mip_filter_from_pipe(enum pipe_tex_mipfilter in)
       return AGX_MIP_FILTER_NONE;
    }
 
-   unreachable("Invalid mip filter");
+   UNREACHABLE("Invalid mip filter");
 }
 
 static const enum agx_compare_func agx_compare_funcs[PIPE_FUNC_ALWAYS + 1] = {
@@ -635,7 +635,7 @@ agx_translate_tex_dim(enum pipe_texture_target dim, unsigned samples)
       return AGX_TEXTURE_DIMENSION_CUBE_ARRAY;
 
    default:
-      unreachable("Unsupported texture dimension");
+      UNREACHABLE("Unsupported texture dimension");
    }
 }
 
@@ -1981,7 +1981,7 @@ agx_create_shader_state(struct pipe_context *pctx,
          }
          break;
       default:
-         unreachable("Unknown shader stage in shader-db precompile");
+         UNREACHABLE("Unknown shader stage in shader-db precompile");
       }
 
       agx_compile_variant(dev, pctx, so, &key);
@@ -3277,7 +3277,7 @@ agx_default_sample_positions(unsigned nr_samples)
    case 4:
       return 0xeaa26e26;
    default:
-      unreachable("Invalid sample count");
+      UNREACHABLE("Invalid sample count");
    }
 }
 
@@ -3742,7 +3742,7 @@ agx_primitive_for_pipe(enum mesa_prim mode)
    case MESA_PRIM_QUAD_STRIP:
       return AGX_PRIMITIVE_QUAD_STRIP;
    default:
-      unreachable("todo: other primitive types");
+      UNREACHABLE("todo: other primitive types");
    }
 }
 
@@ -5471,7 +5471,7 @@ agx_set_global_binding(struct pipe_context *pipe, unsigned first,
       /* we are screwed no matter what */
       if (!util_dynarray_grow(&ctx->global_buffers, *resources,
                               (first + count) - old_size))
-         unreachable("out of memory");
+         UNREACHABLE("out of memory");
 
       for (unsigned i = old_size; i < first + count; i++)
          *util_dynarray_element(&ctx->global_buffers, struct pipe_resource *,
diff --git a/src/gallium/drivers/crocus/crocus_blt.c b/src/gallium/drivers/crocus/crocus_blt.c
index 1a3cf326edc4b..46f4cee0cba25 100644
--- a/src/gallium/drivers/crocus/crocus_blt.c
+++ b/src/gallium/drivers/crocus/crocus_blt.c
@@ -39,7 +39,7 @@ color_depth_for_cpp(int cpp)
    case 2: return COLOR_DEPTH_565;
    case 1: return COLOR_DEPTH_8bit;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
diff --git a/src/gallium/drivers/crocus/crocus_clear.c b/src/gallium/drivers/crocus/crocus_clear.c
index 97931b09baa3a..bf9880eaf0975 100644
--- a/src/gallium/drivers/crocus/crocus_clear.c
+++ b/src/gallium/drivers/crocus/crocus_clear.c
@@ -729,7 +729,7 @@ crocus_clear_texture(struct pipe_context *ctx,
          case 96:  format = ISL_FORMAT_R32G32B32_UINT;    break;
          case 128: format = ISL_FORMAT_R32G32B32A32_UINT; break;
          default:
-            unreachable("Unknown format bpb");
+            UNREACHABLE("Unknown format bpb");
          }
 
          /* No aux surfaces for non-renderable surfaces */
diff --git a/src/gallium/drivers/crocus/crocus_context.c b/src/gallium/drivers/crocus/crocus_context.c
index db084a9bac9e5..6c6acde490bd0 100644
--- a/src/gallium/drivers/crocus/crocus_context.c
+++ b/src/gallium/drivers/crocus/crocus_context.c
@@ -92,7 +92,7 @@ crocus_lost_context_state(struct crocus_batch *batch)
    } else if (batch->name == CROCUS_BATCH_COMPUTE) {
       screen->vtbl.init_compute_context(batch);
    } else {
-      unreachable("unhandled batch reset");
+      UNREACHABLE("unhandled batch reset");
    }
 
    ice->state.dirty = ~0ull;
@@ -175,7 +175,7 @@ crocus_get_sample_position(struct pipe_context *ctx,
    case 4:  INTEL_SAMPLE_POS_4X(u.v._);  break;
    case 8:  INTEL_SAMPLE_POS_8X(u.v._);  break;
    case 16: INTEL_SAMPLE_POS_16X(u.v._); break;
-   default: unreachable("invalid sample count");
+   default: UNREACHABLE("invalid sample count");
    }
 
    out_value[0] = u.a.x[sample_index];
@@ -248,7 +248,7 @@ crocus_destroy_context(struct pipe_context *ctx)
       gfx4_##func(__VA_ARGS__);                         \
       break;                                            \
    default:                                             \
-      unreachable("Unknown hardware generation");       \
+      UNREACHABLE("Unknown hardware generation");       \
    }
 
 /**
diff --git a/src/gallium/drivers/crocus/crocus_draw.c b/src/gallium/drivers/crocus/crocus_draw.c
index 7787d47c7bbfc..a848b1869a892 100644
--- a/src/gallium/drivers/crocus/crocus_draw.c
+++ b/src/gallium/drivers/crocus/crocus_draw.c
@@ -68,7 +68,7 @@ can_cut_index_handle_restart_index(struct crocus_context *ice,
    case 4:
       return draw->restart_index == 0xffffffff;
    default:
-      unreachable("illegal index size\n");
+      UNREACHABLE("illegal index size\n");
    }
 
    return false;
diff --git a/src/gallium/drivers/crocus/crocus_genx_macros.h b/src/gallium/drivers/crocus/crocus_genx_macros.h
index 11f761daa4449..00c5c95d0be7f 100644
--- a/src/gallium/drivers/crocus/crocus_genx_macros.h
+++ b/src/gallium/drivers/crocus/crocus_genx_macros.h
@@ -75,7 +75,7 @@ __gen_combine_address(struct crocus_batch *batch, void *location,
 static inline struct crocus_address
 __gen_get_batch_address(struct crocus_batch *batch, void *location)
 {
-   unreachable("Not supported by crocus");
+   UNREACHABLE("Not supported by crocus");
 }
 
 #define __gen_address_type struct crocus_address
diff --git a/src/gallium/drivers/crocus/crocus_monitor.c b/src/gallium/drivers/crocus/crocus_monitor.c
index e3f668c2cd885..a3b82779c25c9 100644
--- a/src/gallium/drivers/crocus/crocus_monitor.c
+++ b/src/gallium/drivers/crocus/crocus_monitor.c
@@ -330,7 +330,7 @@ crocus_get_monitor_result(struct pipe_context *ctx,
          break;
       }
       default:
-         unreachable("unexpected counter data type");
+         UNREACHABLE("unexpected counter data type");
       }
    }
    return true;
diff --git a/src/gallium/drivers/crocus/crocus_resolve.c b/src/gallium/drivers/crocus/crocus_resolve.c
index 5fce58b5d6e6b..b509fe33935c1 100644
--- a/src/gallium/drivers/crocus/crocus_resolve.c
+++ b/src/gallium/drivers/crocus/crocus_resolve.c
@@ -623,7 +623,7 @@ crocus_hiz_exec(struct crocus_context *ice,
       break;
    case ISL_AUX_OP_PARTIAL_RESOLVE:
    case ISL_AUX_OP_NONE:
-      unreachable("Invalid HiZ op");
+      UNREACHABLE("Invalid HiZ op");
    }
 
    DBG("%s %s to res %p level %d layers %d-%d\n",
@@ -858,7 +858,7 @@ crocus_resource_prepare_access(struct crocus_context *ice,
          } else if (isl_aux_usage_has_hiz(res->aux.usage)) {
             crocus_hiz_exec(ice, batch, res, level, layer, 1, aux_op);
          } else if (res->aux.usage == ISL_AUX_USAGE_STC_CCS) {
-            unreachable("crocus doesn't resolve STC_CCS resources");
+            UNREACHABLE("crocus doesn't resolve STC_CCS resources");
          } else {
             assert(isl_aux_usage_has_ccs(res->aux.usage));
             crocus_resolve_color(ice, batch, res, level, layer, aux_op);
diff --git a/src/gallium/drivers/crocus/crocus_resource.c b/src/gallium/drivers/crocus/crocus_resource.c
index 75bcc8f68d3c1..944792f4d19bb 100644
--- a/src/gallium/drivers/crocus/crocus_resource.c
+++ b/src/gallium/drivers/crocus/crocus_resource.c
@@ -140,7 +140,7 @@ crocus_target_to_isl_surf_dim(enum pipe_texture_target target)
    case PIPE_MAX_TEXTURE_TYPES:
       break;
    }
-   unreachable("invalid texture type");
+   UNREACHABLE("invalid texture type");
 }
 
 static isl_surf_usage_flags_t
@@ -497,7 +497,7 @@ crocus_resource_configure_aux(struct crocus_screen *screen,
       *alloc_flags |= BO_ALLOC_ZEROED;
       break;
    default:
-      unreachable("non-crocus aux");
+      UNREACHABLE("non-crocus aux");
    }
 
    /* Create the aux_state for the auxiliary buffer. */
@@ -799,7 +799,7 @@ crocus_resource_from_handle(struct pipe_screen *pscreen,
                                                whandle->handle);
       break;
    default:
-      unreachable("invalid winsys handle type");
+      UNREACHABLE("invalid winsys handle type");
    }
    if (!res->bo)
       goto fail;
@@ -1894,7 +1894,7 @@ crocus_memobj_create_from_handle(struct pipe_screen *pscreen,
 
       break;
    default:
-      unreachable("invalid winsys handle type");
+      UNREACHABLE("invalid winsys handle type");
    }
 
    if (!bo) {
diff --git a/src/gallium/drivers/crocus/crocus_resource.h b/src/gallium/drivers/crocus/crocus_resource.h
index 40c04f5d7a50a..75a596d08525e 100644
--- a/src/gallium/drivers/crocus/crocus_resource.h
+++ b/src/gallium/drivers/crocus/crocus_resource.h
@@ -73,7 +73,7 @@ crocus_combine_swizzle(enum pipe_swizzle outswz[4],
       case PIPE_SWIZZLE_W: outswz[i] = fswz[3]; break;
       case PIPE_SWIZZLE_1: outswz[i] = PIPE_SWIZZLE_1; break;
       case PIPE_SWIZZLE_0: outswz[i] = PIPE_SWIZZLE_0; break;
-      default: unreachable("invalid swizzle");
+      default: UNREACHABLE("invalid swizzle");
       }
    }
 }
diff --git a/src/gallium/drivers/crocus/crocus_screen.c b/src/gallium/drivers/crocus/crocus_screen.c
index 07409a8e04ae7..b7548cf39f31a 100644
--- a/src/gallium/drivers/crocus/crocus_screen.c
+++ b/src/gallium/drivers/crocus/crocus_screen.c
@@ -83,7 +83,7 @@
       gfx4_##func(__VA_ARGS__);                         \
       break;                                            \
    default:                                             \
-      unreachable("Unknown hardware generation");       \
+      UNREACHABLE("Unknown hardware generation");       \
    }
 
 static const char *
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 4bfb9ab4eab51..45d6370a6abc8 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -499,7 +499,7 @@ crocus_store_register_mem32(struct crocus_batch *batch, uint32_t reg,
       srm.PredicateEnable = predicated;
 #else
       if (predicated)
-         unreachable("unsupported predication");
+         UNREACHABLE("unsupported predication");
 #endif
    }
 }
@@ -5327,7 +5327,7 @@ emit_sol_surface(struct crocus_batch *batch,
       surface_format = ISL_FORMAT_R32G32B32A32_FLOAT;
       break;
    default:
-      unreachable("Invalid vector size for transform feedback output");
+      UNREACHABLE("Invalid vector size for transform feedback output");
    }
 
    UNUSED struct isl_device *isl_dev = &batch->screen->isl_dev;
diff --git a/src/gallium/drivers/d3d12/d3d12_compiler.cpp b/src/gallium/drivers/d3d12/d3d12_compiler.cpp
index 04f3657e70db5..ba6e528492006 100644
--- a/src/gallium/drivers/d3d12/d3d12_compiler.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_compiler.cpp
@@ -420,7 +420,7 @@ get_provoking_vertex(struct d3d12_selection_context *sel_ctx, bool *alternate, c
       mode = (enum mesa_prim)dinfo->mode;
       break;
    default:
-      unreachable("Tesselation shaders are not supported");
+      UNREACHABLE("Tesselation shaders are not supported");
    }
 
    bool flatshade_first = sel_ctx->ctx->gfx_pipeline_state.rast &&
@@ -740,7 +740,7 @@ d3d12_compare_shader_keys(struct d3d12_selection_context* sel_ctx, const d3d12_s
          return false;
       break;
    default:
-      unreachable("invalid stage");
+      UNREACHABLE("invalid stage");
    }
    
    if (expect->n_texture_states != have->n_texture_states)
@@ -862,7 +862,7 @@ d3d12_fill_shader_key(struct d3d12_selection_context *sel_ctx,
    case PIPE_SHADER_COMPUTE:
       memset(key->cs.workgroup_size, 0, sizeof(key->cs.workgroup_size));
       break;
-   default: unreachable("Invalid stage type");
+   default: UNREACHABLE("Invalid stage type");
    }
 
    key->n_texture_states = 0;
@@ -1217,7 +1217,7 @@ get_prev_shader(struct d3d12_context *ctx, pipe_shader_type current)
    case PIPE_SHADER_TESS_CTRL:
       return ctx->gfx_stages[PIPE_SHADER_VERTEX];
    default:
-      unreachable("shader type not supported");
+      UNREACHABLE("shader type not supported");
    }
 }
 
@@ -1242,7 +1242,7 @@ get_next_shader(struct d3d12_context *ctx, pipe_shader_type current)
    case PIPE_SHADER_FRAGMENT:
       return NULL;
    default:
-      unreachable("shader type not supported");
+      UNREACHABLE("shader type not supported");
    }
 }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp b/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp
index 85a285c55af99..8585eb673b176 100644
--- a/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_compute_transforms.cpp
@@ -302,7 +302,7 @@ get_query_resolve(const nir_shader_compiler_options *options, const d3d12_comput
          stride = sizeof(D3D12_QUERY_DATA_PIPELINE_STATISTICS) / sizeof(UINT64);
          break;
       default:
-         unreachable("Unhandled query resolve");
+         UNREACHABLE("Unhandled query resolve");
       }
 
       if (!key->query_resolve.is_resolve_in_place && key->query_resolve.num_subqueries == 1)
@@ -400,7 +400,7 @@ create_compute_transform(const nir_shader_compiler_options *options, const d3d12
    case d3d12_compute_transform_type::query_resolve:
       return get_query_resolve(options, key);
    default:
-      unreachable("Invalid transform");
+      UNREACHABLE("Invalid transform");
    }
 }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
index ebb16e2f13e9e..388ba0379e377 100644
--- a/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context_graphics.cpp
@@ -143,7 +143,7 @@ blend_factor_rgb(enum pipe_blendfactor factor)
    case PIPE_BLENDFACTOR_CONST_ALPHA: return D3D12_BLEND_BLEND_FACTOR; /* Doesn't exist in D3D12 */
    case PIPE_BLENDFACTOR_INV_CONST_ALPHA: return D3D12_BLEND_INV_BLEND_FACTOR; /* Doesn't exist in D3D12 */
    }
-   unreachable("unexpected blend factor");
+   UNREACHABLE("unexpected blend factor");
 }
 
 static D3D12_BLEND
@@ -170,7 +170,7 @@ blend_factor_alpha(enum pipe_blendfactor factor)
    case PIPE_BLENDFACTOR_INV_CONST_COLOR:
    case PIPE_BLENDFACTOR_INV_CONST_ALPHA: return D3D12_BLEND_INV_BLEND_FACTOR;
    }
-   unreachable("unexpected blend factor");
+   UNREACHABLE("unexpected blend factor");
 }
 
 static unsigned
@@ -214,7 +214,7 @@ blend_op(enum pipe_blend_func func)
    case PIPE_BLEND_MIN: return D3D12_BLEND_OP_MIN;
    case PIPE_BLEND_MAX: return D3D12_BLEND_OP_MAX;
    }
-   unreachable("unexpected blend function");
+   UNREACHABLE("unexpected blend function");
 }
 
 static D3D12_COMPARISON_FUNC
@@ -230,7 +230,7 @@ compare_op(enum pipe_compare_func op)
       case PIPE_FUNC_GEQUAL: return D3D12_COMPARISON_FUNC_GREATER_EQUAL;
       case PIPE_FUNC_ALWAYS: return D3D12_COMPARISON_FUNC_ALWAYS;
    }
-   unreachable("unexpected compare");
+   UNREACHABLE("unexpected compare");
 }
 
 static D3D12_LOGIC_OP
@@ -254,7 +254,7 @@ logic_op(enum pipe_logicop func)
    case PIPE_LOGICOP_OR: return D3D12_LOGIC_OP_OR;
    case PIPE_LOGICOP_SET: return D3D12_LOGIC_OP_SET;
    }
-   unreachable("unexpected logicop function");
+   UNREACHABLE("unexpected logicop function");
 }
 
 static UINT8
@@ -369,7 +369,7 @@ stencil_op(enum pipe_stencil_op op)
    case PIPE_STENCIL_OP_DECR_WRAP: return D3D12_STENCIL_OP_DECR;
    case PIPE_STENCIL_OP_INVERT: return D3D12_STENCIL_OP_INVERT;
    }
-   unreachable("unexpected op");
+   UNREACHABLE("unexpected op");
 }
 
 static d3d12_depth_stencil_op_desc_type
@@ -465,7 +465,7 @@ fill_mode(unsigned mode)
       return D3D12_FILL_MODE_SOLID;
 
    default:
-      unreachable("unsupported fill-mode");
+      UNREACHABLE("unsupported fill-mode");
    }
 }
 
@@ -523,7 +523,7 @@ d3d12_create_rasterizer_state(struct pipe_context *pctx,
       break;
 
    default:
-      unreachable("unsupported cull-mode");
+      UNREACHABLE("unsupported cull-mode");
    }
 
    cso->desc.FrontCounterClockwise = rs_state->front_ccw;
@@ -566,7 +566,7 @@ sampler_address_mode(enum pipe_tex_wrap wrap, enum pipe_tex_filter filter)
    case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE: return D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE;
    case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER: return D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE; /* FIXME: Doesn't exist in D3D12 */
    }
-   unreachable("unexpected wrap");
+   UNREACHABLE("unexpected wrap");
 }
 
 static D3D12_FILTER
@@ -637,7 +637,7 @@ d3d12_create_sampler_state(struct pipe_context *pctx,
       desc.MinLOD = 0;
       desc.MaxLOD = 0;
    } else {
-      unreachable("unexpected mip filter");
+      UNREACHABLE("unexpected mip filter");
    }
 
    if (state->compare_mode == PIPE_TEX_COMPARE_R_TO_TEXTURE) {
@@ -645,7 +645,7 @@ d3d12_create_sampler_state(struct pipe_context *pctx,
    } else if (state->compare_mode == PIPE_TEX_COMPARE_NONE) {
       desc.ComparisonFunc = D3D12_COMPARISON_FUNC_ALWAYS;
    } else
-      unreachable("unexpected comparison mode");
+      UNREACHABLE("unexpected comparison mode");
 
    desc.MaxAnisotropy = state->max_anisotropy;
    desc.Filter = get_filter(state);
@@ -768,7 +768,7 @@ view_dimension(enum pipe_texture_target target, unsigned samples)
    case PIPE_TEXTURE_CUBE_ARRAY: return D3D12_SRV_DIMENSION_TEXTURECUBEARRAY;
    case PIPE_TEXTURE_3D: return D3D12_SRV_DIMENSION_TEXTURE3D;
    default:
-      unreachable("unexpected target");
+      UNREACHABLE("unexpected target");
    }
 }
 
@@ -783,7 +783,7 @@ component_mapping(enum pipe_swizzle swizzle)
    case PIPE_SWIZZLE_0: return D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0;
    case PIPE_SWIZZLE_1: return D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1;
    default:
-      unreachable("unexpected swizzle");
+      UNREACHABLE("unexpected swizzle");
    }
 }
 
@@ -904,7 +904,7 @@ d3d12_init_sampler_view_descriptor(struct d3d12_sampler_view *sampler_view)
                                      1 << D3D12_REQ_BUFFER_RESOURCE_TEXEL_COUNT_2_TO_EXP);
       break;
    default:
-      unreachable("Invalid SRV dimension");
+      UNREACHABLE("Invalid SRV dimension");
    }
 
    screen->dev->CreateShaderResourceView(d3d12_res, &desc,
@@ -1688,7 +1688,7 @@ get_shader_image_emulation_format(enum pipe_format resource_format)
    case DXGI_FORMAT_R11G11B10_FLOAT:
       return PIPE_FORMAT_R11G11B10_FLOAT;
    default:
-      unreachable("Unexpected shader image resource format");
+      UNREACHABLE("Unexpected shader image resource format");
    }
 }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_draw.cpp b/src/gallium/drivers/d3d12/d3d12_draw.cpp
index 148dae3c5a7b4..ccde4cb2861a8 100644
--- a/src/gallium/drivers/d3d12/d3d12_draw.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_draw.cpp
@@ -248,7 +248,7 @@ image_view_dimension(enum pipe_texture_target target)
       return D3D12_UAV_DIMENSION_TEXTURE2DARRAY;
    case PIPE_TEXTURE_3D: return D3D12_UAV_DIMENSION_TEXTURE3D;
    default:
-      unreachable("unexpected target");
+      UNREACHABLE("unexpected target");
    }
 }
 
@@ -322,7 +322,7 @@ fill_image_descriptors(struct d3d12_context *ctx,
             break;
          }
          default:
-            unreachable("Unexpected image view dimension");
+            UNREACHABLE("Unexpected image view dimension");
          }
          
          d3d12_transition_flags transition_flags = (d3d12_transition_flags)(D3D12_TRANSITION_FLAG_ACCUMULATE_STATE |
@@ -413,7 +413,7 @@ fill_graphics_state_vars(struct d3d12_context *ctx,
          size += 4;
          break;
       default:
-         unreachable("unknown state variable");
+         UNREACHABLE("unknown state variable");
       }
    }
 
@@ -453,7 +453,7 @@ fill_compute_state_vars(struct d3d12_context *ctx,
          break;
       }
       default:
-         unreachable("unknown state variable");
+         UNREACHABLE("unknown state variable");
       }
    }
 
@@ -663,7 +663,7 @@ topology(enum mesa_prim prim_type, uint8_t patch_vertices)
 
    default:
       debug_printf("mesa_prim: %s\n", u_prim_name(prim_type));
-      unreachable("unexpected enum mesa_prim");
+      UNREACHABLE("unexpected enum mesa_prim");
    }
 }
 
@@ -676,7 +676,7 @@ ib_format(unsigned index_size)
    case 4: return DXGI_FORMAT_R32_UINT;
 
    default:
-      unreachable("unexpected index-buffer size");
+      UNREACHABLE("unexpected index-buffer size");
    }
 }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_format.c b/src/gallium/drivers/d3d12/d3d12_format.c
index 1ed07772efaef..4a2296ba4ac9a 100644
--- a/src/gallium/drivers/d3d12/d3d12_format.c
+++ b/src/gallium/drivers/d3d12/d3d12_format.c
@@ -641,7 +641,7 @@ d3d12_convert_pipe_video_profile_to_dxgi_format(enum pipe_video_profile profile)
          return DXGI_FORMAT_Y210;
       default:
       {
-         unreachable("Unsupported pipe video profile");
+         UNREACHABLE("Unsupported pipe video profile");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_nir_passes.c b/src/gallium/drivers/d3d12/d3d12_nir_passes.c
index f54d833391435..9154f71167639 100644
--- a/src/gallium/drivers/d3d12/d3d12_nir_passes.c
+++ b/src/gallium/drivers/d3d12/d3d12_nir_passes.c
@@ -765,7 +765,7 @@ lower_multisampling_instr(nir_builder *b, nir_instr *instr, void *_data)
    case nir_intrinsic_load_sample_mask_in:
       return nir_b2i32(b, nir_ine_imm(b, &intr->def, 0));
    default:
-      unreachable("Invalid intrinsic");
+      UNREACHABLE("Invalid intrinsic");
    }
 }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_pipeline_state.cpp b/src/gallium/drivers/d3d12/d3d12_pipeline_state.cpp
index 8c33f66f31e3d..be2c5aa0a11f8 100644
--- a/src/gallium/drivers/d3d12/d3d12_pipeline_state.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_pipeline_state.cpp
@@ -191,7 +191,7 @@ depth_bias(struct d3d12_rasterizer_state *state, enum mesa_prim reduced_prim)
       return state->base.offset_point;
 
    default:
-      unreachable("unexpected fill mode");
+      UNREACHABLE("unexpected fill mode");
    }
 }
 
@@ -213,7 +213,7 @@ topology_type(enum mesa_prim reduced_prim)
 
    default:
       debug_printf("mesa_prim: %s\n", u_prim_name(reduced_prim));
-      unreachable("unexpected enum mesa_prim");
+      UNREACHABLE("unexpected enum mesa_prim");
    }
 }
 
@@ -231,7 +231,7 @@ d3d12_rtv_format(struct d3d12_context *ctx, unsigned index)
       case DXGI_FORMAT_B8G8R8X8_UNORM:
          return DXGI_FORMAT_R8G8B8A8_UINT;
       default:
-         unreachable("unsupported logic-op format");
+         UNREACHABLE("unsupported logic-op format");
       }
    }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_query.cpp b/src/gallium/drivers/d3d12/d3d12_query.cpp
index 809258d4ebd90..4682ec63d0458 100644
--- a/src/gallium/drivers/d3d12/d3d12_query.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_query.cpp
@@ -75,7 +75,7 @@ d3d12_query_heap_type(unsigned query_type, unsigned sub_query)
    default:
       debug_printf("unknown query: %s\n",
                    util_str_query_type(query_type, true));
-      unreachable("d3d12: unknown query type");
+      UNREACHABLE("d3d12: unknown query type");
    }
 }
 
@@ -106,7 +106,7 @@ d3d12_query_type(unsigned query_type, unsigned sub_query, unsigned index)
    default:
       debug_printf("unknown query: %s\n",
                    util_str_query_type(query_type, true));
-      unreachable("d3d12: unknown query type");
+      UNREACHABLE("d3d12: unknown query type");
    }
 }
 
@@ -264,7 +264,7 @@ accumulate_subresult_cpu(struct d3d12_context *ctx, struct d3d12_query *q_parent
       default:
          debug_printf("unsupported query type: %s\n",
                       util_str_query_type(q_parent->type, true));
-         unreachable("unexpected query type");
+         UNREACHABLE("unexpected query type");
       }
    }
 
@@ -329,7 +329,7 @@ subquery_should_be_active(struct d3d12_context *ctx, struct d3d12_query *q, unsi
       case 0: return has_xfb;
       case 1: return !has_xfb && has_gs;
       case 2: return !has_xfb && !has_gs;
-      default: unreachable("Invalid subquery for primitives generated");
+      default: UNREACHABLE("Invalid subquery for primitives generated");
       }
       break;
    }
diff --git a/src/gallium/drivers/d3d12/d3d12_resource.cpp b/src/gallium/drivers/d3d12/d3d12_resource.cpp
index 2d72f65558f96..e54c2189f1450 100644
--- a/src/gallium/drivers/d3d12/d3d12_resource.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_resource.cpp
@@ -171,7 +171,7 @@ init_buffer(struct d3d12_screen *screen,
       buf_desc.usage = (pb_usage_flags)(PB_USAGE_GPU_WRITE | PB_USAGE_CPU_READ_WRITE);
       break;
    default:
-      unreachable("Invalid pipe usage");
+      UNREACHABLE("Invalid pipe usage");
    }
 
    /* We can't suballocate buffers that might be bound as a sampler view, *only*
@@ -243,7 +243,7 @@ init_texture(struct d3d12_screen *screen,
       break;
 
    default:
-      unreachable("Invalid texture type");
+      UNREACHABLE("Invalid texture type");
    }
 
    if (templ->bind & PIPE_BIND_SHADER_BUFFER)
@@ -674,7 +674,7 @@ d3d12_resource_from_handle(struct pipe_screen *pscreen,
       res->base.b.depth0 = static_cast<uint16_t>(footprint->Depth);
       break;
    default:
-      unreachable("Invalid dimension");
+      UNREACHABLE("Invalid dimension");
       break;
    }
    res->base.b.nr_samples = static_cast<uint8_t>(incoming_res_desc.SampleDesc.Count);
@@ -1619,7 +1619,7 @@ read_zs_surface(struct d3d12_context *ctx, struct d3d12_resource *res,
                                                     trans->base.b.box.width, trans->base.b.box.height);
       break;
    default:
-      unreachable("Unsupported depth steancil format");
+      UNREACHABLE("Unsupported depth steancil format");
    };
 
    return trans->data;
@@ -1707,7 +1707,7 @@ write_zs_surface(struct pipe_context *pctx, struct d3d12_resource *res,
                                                       trans->base.b.box.height);
       break;
    default:
-      unreachable("Unsupported depth steancil format");
+      UNREACHABLE("Unsupported depth steancil format");
    };
 
    stencil_buffer.unmap();
diff --git a/src/gallium/drivers/d3d12/d3d12_root_signature.cpp b/src/gallium/drivers/d3d12/d3d12_root_signature.cpp
index 1013931a27454..f0feab8f8a7fa 100644
--- a/src/gallium/drivers/d3d12/d3d12_root_signature.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_root_signature.cpp
@@ -54,7 +54,7 @@ get_shader_visibility(enum pipe_shader_type stage)
    case PIPE_SHADER_COMPUTE:
       return D3D12_SHADER_VISIBILITY_ALL;
    default:
-      unreachable("unknown shader stage");
+      UNREACHABLE("unknown shader stage");
    }
 }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_screen.cpp b/src/gallium/drivers/d3d12/d3d12_screen.cpp
index 960a85e128925..c98b44535b23e 100644
--- a/src/gallium/drivers/d3d12/d3d12_screen.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_screen.cpp
@@ -512,7 +512,7 @@ d3d12_is_format_supported(struct pipe_screen *pscreen,
       dim_support = D3D12_FORMAT_SUPPORT1_BUFFER;
       break;
    default:
-      unreachable("Unknown target");
+      UNREACHABLE("Unknown target");
    }
 
    if (bind & PIPE_BIND_DISPLAY_TARGET) {
diff --git a/src/gallium/drivers/d3d12/d3d12_surface.cpp b/src/gallium/drivers/d3d12/d3d12_surface.cpp
index c0a3c742762ea..5e0a83d9d4a41 100644
--- a/src/gallium/drivers/d3d12/d3d12_surface.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_surface.cpp
@@ -50,7 +50,7 @@ view_dsv_dimension(enum pipe_texture_target target, unsigned samples)
                            D3D12_DSV_DIMENSION_TEXTURE2DARRAY;
 
    default:
-      unreachable("unexpected target");
+      UNREACHABLE("unexpected target");
    }
 }
 
@@ -76,7 +76,7 @@ view_rtv_dimension(enum pipe_texture_target target, unsigned samples)
    case PIPE_TEXTURE_3D: return D3D12_RTV_DIMENSION_TEXTURE3D;
 
    default:
-      unreachable("unexpected target");
+      UNREACHABLE("unexpected target");
    }
 }
 
@@ -137,7 +137,7 @@ initialize_dsv(struct pipe_context *pctx,
       break;
 
    default:
-      unreachable("Unhandled DSV dimension");
+      UNREACHABLE("Unhandled DSV dimension");
    }
 
    mtx_lock(&screen->descriptor_pool_mutex);
@@ -216,7 +216,7 @@ initialize_rtv(struct pipe_context *pctx,
       break;
 
    default:
-      unreachable("Unhandled RTV dimension");
+      UNREACHABLE("Unhandled RTV dimension");
    }
 
    mtx_lock(&screen->descriptor_pool_mutex);
diff --git a/src/gallium/drivers/d3d12/d3d12_video_dec.cpp b/src/gallium/drivers/d3d12/d3d12_video_dec.cpp
index c771aacade8bf..10129cd5a5e80 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_dec.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_dec.cpp
@@ -383,7 +383,7 @@ d3d12_video_decoder_store_upper_layer_references(struct d3d12_video_decoder *pD3
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #endif // D3D12_VIDEO_ANY_DECODER_ENABLED
@@ -1115,7 +1115,7 @@ d3d12_video_decoder_prepare_for_decode_frame(struct d3d12_video_decoder *pD3D12D
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #endif // D3D12_VIDEO_ANY_DECODER_ENABLED
@@ -1246,7 +1246,7 @@ d3d12_video_decoder_refresh_dpb_active_references(struct d3d12_video_decoder *pD
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #endif // D3D12_VIDEO_ANY_DECODER_ENABLED
@@ -1288,7 +1288,7 @@ d3d12_video_decoder_get_frame_info(
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #endif // D3D12_VIDEO_ANY_DECODER_ENABLED
@@ -1392,7 +1392,7 @@ d3d12_video_decoder_store_converted_dxva_picparams_from_pipe_input(
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #endif // D3D12_VIDEO_ANY_DECODER_ENABLED
@@ -1442,7 +1442,7 @@ d3d12_video_decoder_prepare_dxva_slices_control(
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #endif // D3D12_VIDEO_ANY_DECODER_ENABLED
@@ -1537,7 +1537,7 @@ d3d12_video_decoder_convert_pipe_video_profile_to_profile_type(enum pipe_video_p
          return d3d12_video_decode_profile_type_vp9;
       default:
       {
-         unreachable("Unsupported pipe video profile");
+         UNREACHABLE("Unsupported pipe video profile");
       } break;
    }
 }
@@ -1587,7 +1587,7 @@ d3d12_video_decoder_resolve_profile(d3d12_video_decode_profile_type profileType,
                return D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN10;
             default:
             {
-               unreachable("Unsupported decode_format");
+               UNREACHABLE("Unsupported decode_format");
             } break;
          }
       } break;
@@ -1607,14 +1607,14 @@ d3d12_video_decoder_resolve_profile(d3d12_video_decode_profile_type profileType,
                return D3D12_VIDEO_DECODE_PROFILE_VP9_10BIT_PROFILE2;
             default:
             {
-               unreachable("Unsupported decode_format");
+               UNREACHABLE("Unsupported decode_format");
             } break;
          }
       } break;
 #endif
       default:
       {
-         unreachable("Unsupported d3d12_video_decode_profile_type");
+         UNREACHABLE("Unsupported d3d12_video_decode_profile_type");
       } break;
    }
 #else
diff --git a/src/gallium/drivers/d3d12/d3d12_video_dec_h264.cpp b/src/gallium/drivers/d3d12/d3d12_video_dec_h264.cpp
index 680ca4e765d60..3ee1024a10d1a 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_dec_h264.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_dec_h264.cpp
@@ -174,7 +174,7 @@ d3d12_video_decoder_prepare_dxva_slices_control_h264(struct d3d12_video_decoder
             break;
          default:
          {
-            unreachable("Unsupported pipe_slice_buffer_placement_type");
+            UNREACHABLE("Unsupported pipe_slice_buffer_placement_type");
          } break;
       }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_video_dec_hevc.cpp b/src/gallium/drivers/d3d12/d3d12_video_dec_hevc.cpp
index 763bedb7dba02..b4809d6133fef 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_dec_hevc.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_dec_hevc.cpp
@@ -130,7 +130,7 @@ d3d12_video_decoder_prepare_dxva_slices_control_hevc(struct d3d12_video_decoder
    
    if(!picture_hevc->slice_parameter.slice_info_present)
    {
-      unreachable("Unsupported - need pipe_h265_picture_desc.slice_parameter.slice_info_present");
+      UNREACHABLE("Unsupported - need pipe_h265_picture_desc.slice_parameter.slice_info_present");
    }
 
    debug_printf("[d3d12_video_decoder_hevc] Upper layer reported %d slices for this frame, parsing them below...\n",
@@ -172,7 +172,7 @@ d3d12_video_decoder_prepare_dxva_slices_control_hevc(struct d3d12_video_decoder
             break;
          default:
          {
-            unreachable("Unsupported pipe_slice_buffer_placement_type");
+            UNREACHABLE("Unsupported pipe_slice_buffer_placement_type");
          } break;
       }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_video_dec_vp9.cpp b/src/gallium/drivers/d3d12/d3d12_video_dec_vp9.cpp
index da1f2a3b998b1..78c2cb83fdc67 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_dec_vp9.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_dec_vp9.cpp
@@ -211,7 +211,7 @@ d3d12_video_decoder_prepare_dxva_slices_control_vp9(struct d3d12_video_decoder *
 {
    if(!picture_vp9->slice_parameter.slice_info_present)
    {
-      unreachable("Unsupported - need pipe_vp9_picture_desc.slice_parameter.slice_info_present");
+      UNREACHABLE("Unsupported - need pipe_vp9_picture_desc.slice_parameter.slice_info_present");
    }
 
    debug_printf("[d3d12_video_decoder_vp9] Upper layer reported %d slices for this frame, parsing them below...\n",
@@ -251,7 +251,7 @@ d3d12_video_decoder_prepare_dxva_slices_control_vp9(struct d3d12_video_decoder *
             break;
          default:
          {
-            unreachable("Unsupported pipe_slice_buffer_placement_type");
+            UNREACHABLE("Unsupported pipe_slice_buffer_placement_type");
          } break;
       }
 
diff --git a/src/gallium/drivers/d3d12/d3d12_video_enc.cpp b/src/gallium/drivers/d3d12/d3d12_video_enc.cpp
index 3ed571ab0fd5d..ef8cc49868999 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_enc.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_enc.cpp
@@ -79,7 +79,7 @@ d3d12_video_encoder_convert_codec_to_d3d12_enc_codec(enum pipe_video_profile pro
       case PIPE_VIDEO_FORMAT_UNKNOWN:
       default:
       {
-         unreachable("Unsupported pipe_video_profile");
+         UNREACHABLE("Unsupported pipe_video_profile");
       } break;
    }
 }
@@ -283,7 +283,7 @@ d3d12_video_encoder_friendly_frame_type_h264(D3D12_VIDEO_ENCODER_FRAME_TYPE_H264
       } break;
       default:
       {
-         unreachable("Unsupported pipe_h2645_enc_picture_type");
+         UNREACHABLE("Unsupported pipe_h2645_enc_picture_type");
       } break;
    }
 }
@@ -308,7 +308,7 @@ d3d12_video_encoder_convert_move_precision(enum pipe_enc_move_info_precision_uni
          } break;
          default:
          {
-            unreachable("Unsupported pipe_enc_move_info");
+            UNREACHABLE("Unsupported pipe_enc_move_info");
             return D3D12_VIDEO_ENCODER_FRAME_INPUT_MOTION_UNIT_PRECISION_FULL_PIXEL;
          } break;
       }
@@ -483,7 +483,7 @@ d3d12_video_encoder_get_two_pass_config_from_picparams(struct pipe_picture_desc*
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 return twopass_frame_config;
@@ -600,7 +600,7 @@ d3d12_video_encoder_update_two_pass_frame_settings(struct d3d12_video_encoder *p
 #endif
             default:
             {
-               unreachable("Unsupported pipe_video_format");
+               UNREACHABLE("Unsupported pipe_video_format");
             } break;
          }
       }
@@ -693,7 +693,7 @@ d3d12_video_encoder_update_picparams_tracking(struct d3d12_video_encoder *pD3D12
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 
@@ -733,7 +733,7 @@ d3d12_video_encoder_uses_direct_dpb(enum pipe_video_format codec)
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1068,7 +1068,7 @@ d3d12_video_encoder_create_reference_picture_manager(struct d3d12_video_encoder
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1117,7 +1117,7 @@ d3d12_video_encoder_get_current_slice_param_settings(struct d3d12_video_encoder
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 
@@ -1154,7 +1154,7 @@ d3d12_video_encoder_get_current_picture_param_settings1(struct d3d12_video_encod
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
    return curPicParamsData;
@@ -1191,7 +1191,7 @@ d3d12_video_encoder_get_current_picture_param_settings(struct d3d12_video_encode
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
    return curPicParamsData;
@@ -1243,7 +1243,7 @@ d3d12_video_encoder_get_current_rate_control_settings(struct d3d12_video_encoder
          } break;
          default:
          {
-            unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
+            UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
          } break;
       }
    }
@@ -1285,7 +1285,7 @@ d3d12_video_encoder_get_current_rate_control_settings(struct d3d12_video_encoder
          } break;
          default:
          {
-            unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
+            UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
          } break;
       }
    }
@@ -1327,7 +1327,7 @@ d3d12_video_encoder_get_current_level_desc(struct d3d12_video_encoder *pD3D12Enc
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1365,7 +1365,7 @@ d3d12_video_encoder_build_pre_encode_codec_headers(struct d3d12_video_encoder *p
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1407,7 +1407,7 @@ d3d12_video_encoder_get_current_gop_desc(struct d3d12_video_encoder *pD3D12Enc)
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1449,7 +1449,7 @@ d3d12_video_encoder_get_current_codec_config_desc(struct d3d12_video_encoder *pD
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1479,7 +1479,7 @@ d3d12_video_encoder_get_current_codec(struct d3d12_video_encoder *pD3D12Enc)
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -1506,7 +1506,7 @@ d3d12_video_encoder_disable_rc_vbv_sizes(struct D3D12EncodeRateControlState & rc
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE for VBV Sizes");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE for VBV Sizes");
       } break;
    }
 }
@@ -1531,7 +1531,7 @@ d3d12_video_encoder_disable_rc_maxframesize(struct D3D12EncodeRateControlState &
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE for VBV Sizes");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE for VBV Sizes");
       } break;
    }
 }
@@ -1558,7 +1558,7 @@ d3d12_video_encoder_is_qualitylevel_in_range(struct D3D12EncodeRateControlState
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
       } break;
    }
 }
@@ -1586,7 +1586,7 @@ d3d12_video_encoder_disable_rc_qualitylevels(struct D3D12EncodeRateControlState
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE");
       } break;
    }
 }
@@ -1619,7 +1619,7 @@ d3d12_video_encoder_disable_rc_minmaxqp(struct D3D12EncodeRateControlState & rcS
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE for VBV Sizes");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE for VBV Sizes");
       } break;
    }
 }
@@ -1942,7 +1942,7 @@ bool d3d12_video_encoder_query_d3d12_driver_caps(struct d3d12_video_encoder *pD3
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 
@@ -2188,7 +2188,7 @@ d3d12_video_encoder_get_current_profile_desc(struct d3d12_video_encoder *pD3D12E
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -2218,7 +2218,7 @@ d3d12_video_encoder_get_current_max_dpb_capacity(struct d3d12_video_encoder *pD3
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -2298,7 +2298,7 @@ d3d12_video_encoder_update_current_encoder_config_state(struct d3d12_video_encod
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 
@@ -2768,7 +2768,7 @@ d3d12_video_encoder_calculate_metadata_resolved_buffer_size(enum pipe_video_form
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
@@ -2817,7 +2817,7 @@ d3d12_video_encoder_calculate_max_slices_count_in_output(
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE");
       } break;
    }
 
@@ -4549,7 +4549,7 @@ d3d12_video_encoder_build_post_encode_codec_bitstream(struct d3d12_video_encoder
       } break;
 #endif
       default:
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
    }
 }
 
@@ -4727,7 +4727,7 @@ d3d12_video_encoder_store_current_picture_references(d3d12_video_encoder *pD3D12
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_enc_av1.cpp b/src/gallium/drivers/d3d12/d3d12_video_enc_av1.cpp
index 73fe53aec5d7f..310d7d87c5d79 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_enc_av1.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_enc_av1.cpp
@@ -412,7 +412,7 @@ d3d12_video_encoder_convert_d3d12_profile_to_spec_profile_av1(D3D12_VIDEO_ENCODE
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_AV1_PROFILE");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_AV1_PROFILE");
       } break;
    }
 }
@@ -427,7 +427,7 @@ d3d12_video_encoder_convert_profile_to_d3d12_enc_profile_av1(enum pipe_video_pro
       } break;
       default:
       {
-         unreachable("Unsupported pipe_video_profile");
+         UNREACHABLE("Unsupported pipe_video_profile");
       } break;
    }
 }
@@ -2114,7 +2114,7 @@ d3d12_video_encoder_looprestorationsize_uint_to_d3d12_av1(uint32_t pixel_size)
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_AV1_PROFILE");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_AV1_PROFILE");
       } break;
    }
 }
@@ -2141,7 +2141,7 @@ d3d12_video_encoder_looprestorationsize_d3d12_to_uint_av1(D3D12_VIDEO_ENCODER_AV
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_AV1_PROFILE");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_AV1_PROFILE");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp b/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp
index e1aae4dacd13b..7247354b660f6 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp
@@ -305,7 +305,7 @@ d3d12_video_encoder_update_current_rate_control_h264(struct d3d12_video_encoder
             } break;
             default:
             {
-               unreachable("Unsupported pipe_h2645_enc_picture_type");
+               UNREACHABLE("Unsupported pipe_h2645_enc_picture_type");
             } break;
          }
 
@@ -651,7 +651,7 @@ d3d12_video_encoder_convert_level_h264(uint32_t h264SpecLevel)
       } break;
       default:
       {
-         unreachable("Unsupported H264 level");
+         UNREACHABLE("Unsupported H264 level");
       } break;
    }
 }
@@ -745,7 +745,7 @@ d3d12_video_encoder_convert_from_d3d12_level_h264(D3D12_VIDEO_ENCODER_LEVELS_H26
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_LEVELS_H264 value");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_LEVELS_H264 value");
       } break;
    }
 }
@@ -1138,7 +1138,7 @@ d3d12_video_encoder_convert_profile_to_d3d12_enc_profile_h264(enum pipe_video_pr
       } break;
       default:
       {
-         unreachable("Unsupported pipe_video_profile");
+         UNREACHABLE("Unsupported pipe_video_profile");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_enc_hevc.cpp b/src/gallium/drivers/d3d12/d3d12_video_enc_hevc.cpp
index 3aa8ae0238a76..9144f147ba8a3 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_enc_hevc.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_enc_hevc.cpp
@@ -304,7 +304,7 @@ d3d12_video_encoder_update_current_rate_control_hevc(struct d3d12_video_encoder
             } break;
             default:
             {
-               unreachable("Unsupported pipe_h2645_enc_picture_type");
+               UNREACHABLE("Unsupported pipe_h2645_enc_picture_type");
             } break;
          }
 
@@ -1495,7 +1495,7 @@ d3d12_video_encoder_convert_profile_to_d3d12_enc_profile_hevc(enum pipe_video_pr
       } break;
       default:
       {
-         unreachable("Unsupported pipe_video_profile");
+         UNREACHABLE("Unsupported pipe_video_profile");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_h264.cpp b/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_h264.cpp
index 2b6b72caa8e7f..d7f57e57d3849 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_h264.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_h264.cpp
@@ -47,7 +47,7 @@ Convert12ToSpecH264Profiles(D3D12_VIDEO_ENCODER_PROFILE_H264 profile12)
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_PROFILE_H264");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_PROFILE_H264");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_hevc.cpp b/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_hevc.cpp
index 4cddd9b287397..ff4f9c059e2b3 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_hevc.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_encoder_bitstream_builder_hevc.cpp
@@ -45,7 +45,7 @@ convert_profile12_to_stdprofile(D3D12_VIDEO_ENCODER_PROFILE_HEVC profile)
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_PROFILE_HEVC value");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_PROFILE_HEVC value");
       } break;
    }
 }
@@ -55,7 +55,7 @@ dxgi_format_to_pix_bits(DXGI_FORMAT fmt)
 {
    switch (fmt) {
       default:
-         unreachable("Unsupported DXGI_FORMAT");
+         UNREACHABLE("Unsupported DXGI_FORMAT");
       case DXGI_FORMAT_AYUV:
       case DXGI_FORMAT_NV12:
       case DXGI_FORMAT_YUY2:
@@ -160,7 +160,7 @@ d3d12_video_encoder_convert_from_d3d12_level_hevc(D3D12_VIDEO_ENCODER_LEVELS_HEV
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_LEVELS_HEVC value");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_LEVELS_HEVC value");
       } break;        
    }
 }
@@ -225,7 +225,7 @@ d3d12_video_encoder_convert_level_hevc(uint32_t hevcSpecLevel)
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_LEVELS_HEVC value");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_LEVELS_HEVC value");
       } break;        
    }
 }
@@ -253,7 +253,7 @@ d3d12_video_encoder_convert_12cusize_to_pixel_size_hevc(const D3D12_VIDEO_ENCODE
         } break;
         default:
         {
-            unreachable(L"Not a supported cu size");
+            UNREACHABLE(L"Not a supported cu size");
             return 0u;
         } break;            
     }
@@ -282,7 +282,7 @@ d3d12_video_encoder_convert_pixel_size_hevc_to_12cusize(const uint32_t& cuSize)
         } break;
         default:
         {
-            unreachable(L"Not a supported cu size");
+            UNREACHABLE(L"Not a supported cu size");
         } break;            
     }
 }
@@ -310,7 +310,7 @@ d3d12_video_encoder_convert_12tusize_to_pixel_size_hevc(const D3D12_VIDEO_ENCODE
         } break;        
         default:
         {
-            unreachable(L"Not a supported TU size");
+            UNREACHABLE(L"Not a supported TU size");
         } break;            
     }
 }
@@ -338,7 +338,7 @@ d3d12_video_encoder_convert_pixel_size_hevc_to_12tusize(const uint32_t& TUSize)
         } break;        
         default:
         {
-            unreachable(L"Not a supported TU size");
+            UNREACHABLE(L"Not a supported TU size");
         } break;            
     }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_encoder_nalu_writer_hevc.cpp b/src/gallium/drivers/d3d12/d3d12_video_encoder_nalu_writer_hevc.cpp
index c91e6d3ba8f7c..2286542046a4f 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_encoder_nalu_writer_hevc.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_encoder_nalu_writer_hevc.cpp
@@ -212,7 +212,7 @@ d3d12_video_nalu_writer_hevc::write_bytes_from_struct(d3d12_video_encoder_bitstr
         } break;
         default:
         {
-            unreachable("Unsupported NALU value");
+            UNREACHABLE("Unsupported NALU value");
         } break;        
     }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_h264.cpp b/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_h264.cpp
index 3be920019df87..d65c1d8d78c89 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_h264.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_h264.cpp
@@ -104,7 +104,7 @@ d3d12_video_encoder_friendly_frame_type_h264(D3D12_VIDEO_ENCODER_FRAME_TYPE_H264
       } break;
       default:
       {
-         unreachable("Unsupported pipe_h2645_enc_picture_type");
+         UNREACHABLE("Unsupported pipe_h2645_enc_picture_type");
       } break;
    }
 }
@@ -284,7 +284,7 @@ d3d12_video_encoder_convert_frame_type_h264(enum pipe_h2645_enc_picture_type pic
       } break;
       default:
       {
-         unreachable("Unsupported pipe_h2645_enc_picture_type");
+         UNREACHABLE("Unsupported pipe_h2645_enc_picture_type");
       } break;
    }
 }
@@ -582,7 +582,7 @@ d3d12_video_encoder_references_manager_h264::print_mmco_lists()
          } break;
          default:
          {
-            unreachable("Unsupported memory_management_control_operation");
+            UNREACHABLE("Unsupported memory_management_control_operation");
          } break;
       }
    }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_hevc.cpp b/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_hevc.cpp
index ed05862915143..0c5853365b25f 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_hevc.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_encoder_references_manager_hevc.cpp
@@ -96,7 +96,7 @@ d3d12_video_encoder_friendly_frame_type_hevc(D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC");
       } break;
    }
 }
@@ -248,7 +248,7 @@ d3d12_video_encoder_convert_frame_type_hevc(enum pipe_h2645_enc_picture_type pic
       } break;
       default:
       {
-         unreachable("Unsupported pipe_h2645_enc_picture_type");
+         UNREACHABLE("Unsupported pipe_h2645_enc_picture_type");
       } break;
    }
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_video_screen.cpp b/src/gallium/drivers/d3d12/d3d12_video_screen.cpp
index 61404defaa2c4..11bbab3d529f1 100644
--- a/src/gallium/drivers/d3d12/d3d12_video_screen.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_video_screen.cpp
@@ -714,7 +714,7 @@ d3d12_video_encode_support_caps(const D3D12_VIDEO_ENCODER_CODEC &argTargetCodec,
       } break;
       default:
       {
-         unreachable("Unsupported D3D12_VIDEO_ENCODER_CODEC");
+         UNREACHABLE("Unsupported D3D12_VIDEO_ENCODER_CODEC");
       } break;
    }
 
@@ -2502,7 +2502,7 @@ d3d12_screen_get_video_param_encode(struct pipe_screen *pscreen,
                   return D3D12_VIDEO_ENC_AV1_MAX_TEMPORAL_LAYERS;
 #endif
                default:
-                  unreachable("Unsupported pipe_video_format");
+                  UNREACHABLE("Unsupported pipe_video_format");
             }
       } break;
       case PIPE_VIDEO_CAP_ENC_SUPPORTS_FEEDBACK_METADATA:
@@ -2883,7 +2883,7 @@ is_d3d12_video_encode_format_supported(struct pipe_screen *screen,
 #endif
       default:
       {
-         unreachable("Unsupported pipe_video_format");
+         UNREACHABLE("Unsupported pipe_video_format");
       } break;
    }
    ComPtr<ID3D12VideoDevice3> spD3D12VideoDevice;
diff --git a/src/gallium/drivers/etnaviv/etnaviv_compiler_nir.c b/src/gallium/drivers/etnaviv/etnaviv_compiler_nir.c
index f7c9d732e6519..b87207270654a 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_compiler_nir.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_compiler_nir.c
@@ -118,7 +118,7 @@ etna_emit_output(struct etna_compile *c, nir_variable *var, struct etna_inst_src
          c->variant->ps_depth_out_reg = src.reg;
          break;
       default:
-         unreachable("Unsupported fs output");
+         UNREACHABLE("Unsupported fs output");
       }
       return;
    }
@@ -1459,7 +1459,7 @@ etna_link_shader(struct etna_shader_link_info *info,
          varying->semantic = VARYING_INTERPOLATION_MODE_FLAT;
          break;
       default:
-         unreachable("unsupported varying interpolation mode");
+         UNREACHABLE("unsupported varying interpolation mode");
       }
 
       /* point/tex coord is an input to the PS without matching VS output,
diff --git a/src/gallium/drivers/etnaviv/etnaviv_ml.c b/src/gallium/drivers/etnaviv/etnaviv_ml.c
index 0cd536281ca3b..a0a7c0b9fd568 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_ml.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_ml.c
@@ -505,7 +505,7 @@ lower_operations(struct etna_ml_subgraph *subgraph,
             break;
          }
          default:
-            unreachable("Unsupported ML operation type");
+            UNREACHABLE("Unsupported ML operation type");
       }
 
       for (int i = 0; i < poperation->output_count; i++) {
@@ -629,7 +629,7 @@ count_tensors(const struct pipe_ml_operation *poperations,
       case PIPE_ML_OPERATION_TYPE_TRANSPOSE:
          break;
       default:
-         unreachable("Unsupported ML operation type");
+         UNREACHABLE("Unsupported ML operation type");
       }
    }
 
@@ -937,7 +937,7 @@ etna_ml_subgraph_invoke(struct pipe_context *pctx, struct pipe_ml_subgraph *psub
                dump_bo(operation->coefficients, "compressed", i, 0, 0, 0);
                break;
             default:
-               unreachable("Unsupported ML operation type");
+               UNREACHABLE("Unsupported ML operation type");
          }
       }
 
@@ -970,7 +970,7 @@ etna_ml_subgraph_invoke(struct pipe_context *pctx, struct pipe_ml_subgraph *psub
             etna_ml_emit_operation_nn(subgraph, operation, i);
             break;
          default:
-            unreachable("Unsupported ML operation type");
+            UNREACHABLE("Unsupported ML operation type");
       }
 
       if (DBG_ENABLED(ETNA_DBG_NPU_NO_BATCHING)) {
diff --git a/src/gallium/drivers/etnaviv/etnaviv_resource.c b/src/gallium/drivers/etnaviv/etnaviv_resource.c
index bc06e0cec9cc2..4d5316d865963 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_resource.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_resource.c
@@ -51,7 +51,7 @@ static enum etna_surface_layout modifier_to_layout(uint64_t modifier)
    case DRM_FORMAT_MOD_LINEAR:
       return ETNA_LAYOUT_LINEAR;
    default:
-      unreachable("unhandled modifier");
+      UNREACHABLE("unhandled modifier");
    }
 }
 
@@ -390,7 +390,7 @@ etna_layout_multiple(const struct etna_screen *screen,
       *halign = TEXTURE_HALIGN_SPLIT_SUPER_TILED;
       break;
    default:
-      unreachable("Unhandled layout");
+      UNREACHABLE("Unhandled layout");
    }
 }
 
diff --git a/src/gallium/drivers/etnaviv/etnaviv_rs.c b/src/gallium/drivers/etnaviv/etnaviv_rs.c
index eba6d46262d96..2d389b4a021cd 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_rs.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_rs.c
@@ -295,7 +295,7 @@ etna_rs_gen_clear_cmd(struct etna_context *ctx,
       format = RS_FORMAT_64BPP_CLEAR;
       break;
    default:
-      unreachable("bpp not supported for clear by RS");
+      UNREACHABLE("bpp not supported for clear by RS");
       break;
    }
 
@@ -602,7 +602,7 @@ etna_compute_tileoffset(const struct pipe_box *box, enum pipe_format format,
       offset = (y & ~0x3f) * stride + blocksize * ((x & ~0x3f) << 6);
       break;
    default:
-      unreachable("invalid resource layout");
+      UNREACHABLE("invalid resource layout");
    }
 
    return offset;
diff --git a/src/gallium/drivers/etnaviv/etnaviv_shader.c b/src/gallium/drivers/etnaviv/etnaviv_shader.c
index 30d90132d65de..2989743b5b46e 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_shader.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_shader.c
@@ -401,7 +401,7 @@ etna_shader_stage(struct etna_shader *shader)
    case MESA_SHADER_FRAGMENT:   return "FRAG";
    case MESA_SHADER_COMPUTE:    return "CL";
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
       return NULL;
    }
 }
diff --git a/src/gallium/drivers/etnaviv/etnaviv_translate.h b/src/gallium/drivers/etnaviv/etnaviv_translate.h
index 6257ede391155..f5f03574c3b12 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_translate.h
+++ b/src/gallium/drivers/etnaviv/etnaviv_translate.h
@@ -535,7 +535,7 @@ translate_texture_compare(enum pipe_compare_func compare_func)
    case PIPE_FUNC_ALWAYS:
       return TEXTURE_COMPARE_FUNC_ALWAYS;
    default:
-      unreachable("Invalid compare func");
+      UNREACHABLE("Invalid compare func");
    }
 }
 
diff --git a/src/gallium/drivers/etnaviv/etnaviv_uniforms.c b/src/gallium/drivers/etnaviv/etnaviv_uniforms.c
index 6c1605f83d193..ff14b733572c5 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_uniforms.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_uniforms.c
@@ -103,7 +103,7 @@ get_texture_size(const struct etna_context *ctx, bool frag,
 
       return u_minify(texture->texture->depth0, texture->u.tex.first_level);
    default:
-      unreachable("Bad texture size field");
+      UNREACHABLE("Bad texture size field");
    }
 }
 
@@ -123,7 +123,7 @@ get_sampler_lod(const struct etna_context *ctx, bool frag,
    case ETNA_UNIFORM_SAMPLER_LOD_BIAS:
       return fui(sampler->lod_bias);
    default:
-      unreachable("Bad sampler lod field");
+      UNREACHABLE("Bad sampler lod field");
    }
 }
 
diff --git a/src/gallium/drivers/freedreno/a2xx/fd2_draw.c b/src/gallium/drivers/freedreno/a2xx/fd2_draw.c
index 7e3b8a7af8e9e..c33b1c88cbcbf 100644
--- a/src/gallium/drivers/freedreno/a2xx/fd2_draw.c
+++ b/src/gallium/drivers/freedreno/a2xx/fd2_draw.c
@@ -595,7 +595,7 @@ fd2_clear(struct fd_context *ctx, enum fd_buffer_mask buffers,
             depth_clear = (uint32_t)(0xffffffff * depth);
             break;
          default:
-            unreachable("invalid depth");
+            UNREACHABLE("invalid depth");
             break;
          }
 
diff --git a/src/gallium/drivers/freedreno/a2xx/fd2_texture.c b/src/gallium/drivers/freedreno/a2xx/fd2_texture.c
index dd3bc74b5e399..b953e394977c8 100644
--- a/src/gallium/drivers/freedreno/a2xx/fd2_texture.c
+++ b/src/gallium/drivers/freedreno/a2xx/fd2_texture.c
@@ -128,7 +128,7 @@ tex_dimension(unsigned target)
 {
    switch (target) {
    default:
-      unreachable("Unsupported target");
+      UNREACHABLE("Unsupported target");
    case PIPE_TEXTURE_1D:
       assert(0); /* TODO */
       return SQ_TEX_DIMENSION_1D;
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
index 0be39065a4ec3..51389c36e803c 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
@@ -384,7 +384,7 @@ fd3_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd3_emit *emit)
             vtxcnt_regid = vp->inputs[i].regid;
             break;
          default:
-            unreachable("invalid system value");
+            UNREACHABLE("invalid system value");
             break;
          }
       } else if (i < vtx->vtx->num_elements) {
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_texture.c b/src/gallium/drivers/freedreno/a3xx/fd3_texture.c
index eb5fad4febda8..d110302f1130c 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_texture.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_texture.c
@@ -110,7 +110,7 @@ tex_type(unsigned target)
 {
    switch (target) {
    default:
-      unreachable("Unsupported target");
+      UNREACHABLE("Unsupported target");
    case PIPE_BUFFER:
    case PIPE_TEXTURE_1D:
    case PIPE_TEXTURE_1D_ARRAY:
diff --git a/src/gallium/drivers/freedreno/a4xx/fd4_emit.c b/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
index 2afc1895fcdaa..2b90349f324e7 100644
--- a/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
+++ b/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
@@ -532,7 +532,7 @@ fd4_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd4_emit *emit)
             vtxcnt_regid = vp->inputs[i].regid;
             break;
          default:
-            unreachable("invalid system value");
+            UNREACHABLE("invalid system value");
             break;
          }
       } else if (i < vtx->vtx->num_elements) {
diff --git a/src/gallium/drivers/freedreno/a4xx/fd4_texture.h b/src/gallium/drivers/freedreno/a4xx/fd4_texture.h
index b982b53ee5012..6d32ff0a1ad19 100644
--- a/src/gallium/drivers/freedreno/a4xx/fd4_texture.h
+++ b/src/gallium/drivers/freedreno/a4xx/fd4_texture.h
@@ -53,7 +53,7 @@ fd4_tex_type(unsigned target)
 {
    switch (target) {
    default:
-      unreachable("Unsupported target");
+      UNREACHABLE("Unsupported target");
    case PIPE_BUFFER:
       return A4XX_TEX_BUFFER;
    case PIPE_TEXTURE_1D:
diff --git a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
index 0fc2456fece87..dfb63348af7c2 100644
--- a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
+++ b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
@@ -238,7 +238,7 @@ setup_border_colors(struct fd_texture_stateobj *tex,
                   clamped = CLAMP(bc->ui[j], 0, 65535);
                break;
             default:
-               unreachable("Unexpected bit size");
+               UNREACHABLE("Unexpected bit size");
             case 32:
                clamped = 0;
                break;
diff --git a/src/gallium/drivers/freedreno/a5xx/fd5_texture.h b/src/gallium/drivers/freedreno/a5xx/fd5_texture.h
index b4ea5b33f15cc..60126baa84a62 100644
--- a/src/gallium/drivers/freedreno/a5xx/fd5_texture.h
+++ b/src/gallium/drivers/freedreno/a5xx/fd5_texture.h
@@ -49,7 +49,7 @@ fd5_tex_type(unsigned target)
 {
    switch (target) {
    default:
-      unreachable("Unsupported target");;
+      UNREACHABLE("Unsupported target");;
    case PIPE_BUFFER:
       return A5XX_TEX_BUFFER;
    case PIPE_TEXTURE_1D:
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_blitter.cc b/src/gallium/drivers/freedreno/a6xx/fd6_blitter.cc
index b8adfdacd1cea..8ee3b773e7fa5 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_blitter.cc
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_blitter.cc
@@ -91,7 +91,7 @@ fd6_ifmt(enum a6xx_format fmt)
       return R2D_FLOAT16;
 
    default:
-      unreachable("bad format");
+      UNREACHABLE("bad format");
       return (enum a6xx_2d_ifmt)0;
    }
 }
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_const.cc b/src/gallium/drivers/freedreno/a6xx/fd6_const.cc
index b4c1559d28f14..c05a4aa21967f 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_const.cc
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_const.cc
@@ -147,7 +147,7 @@ emit_const_ptrs(struct fd_ringbuffer *ring, const struct ir3_shader_variant *v,
                 uint32_t dst_offset, uint32_t num, struct fd_bo **bos,
                 uint32_t *offsets)
 {
-   unreachable("shouldn't be called on a6xx");
+   UNREACHABLE("shouldn't be called on a6xx");
 }
 
 static void
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_emit.h b/src/gallium/drivers/freedreno/a6xx/fd6_emit.h
index d8b9f5b6359c8..49da494c51767 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_emit.h
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_emit.h
@@ -323,7 +323,7 @@ fd6_geom_stage(gl_shader_stage type)
    case MESA_SHADER_KERNEL:
       return false;
    default:
-      unreachable("bad shader type");
+      UNREACHABLE("bad shader type");
    }
 }
 
@@ -351,7 +351,7 @@ fd6_stage2shadersb(gl_shader_stage type)
    case MESA_SHADER_KERNEL:
       return SB6_CS_SHADER;
    default:
-      unreachable("bad shader type");
+      UNREACHABLE("bad shader type");
       return (enum a6xx_state_block)~0;
    }
 }
@@ -368,7 +368,7 @@ fd6_gl2spacing(enum gl_tess_spacing spacing)
       return TESS_FRACTIONAL_EVEN;
    case TESS_SPACING_UNSPECIFIED:
    default:
-      unreachable("spacing must be specified");
+      UNREACHABLE("spacing must be specified");
    }
 }
 
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_program.cc b/src/gallium/drivers/freedreno/a6xx/fd6_program.cc
index 07e1b340cc147..0e6a5580e1edd 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_program.cc
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_program.cc
@@ -181,7 +181,7 @@ fd6_emit_shader(struct fd_context *ctx, struct fd_ringbuffer *ring,
       ));
       break;
    default:
-      unreachable("bad shader stage");
+      UNREACHABLE("bad shader stage");
    }
 
    const struct xs_config<CHIP> *cfg = &xs_configs<CHIP>[type];
@@ -476,7 +476,7 @@ primitive_to_tess(enum mesa_prim primitive)
    case MESA_PRIM_TRIANGLE_STRIP:
       return TESS_CW_TRIS;
    default:
-      unreachable("");
+      UNREACHABLE("");
    }
 }
 
@@ -913,7 +913,7 @@ tex_opc_to_prefetch_cmd(opc_t tex_opc)
    case OPC_SAM:
       return TEX_PREFETCH_SAM;
    default:
-      unreachable("Unknown tex opc for prefeth cmd");
+      UNREACHABLE("Unknown tex opc for prefeth cmd");
    }
 }
 
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_texture.cc b/src/gallium/drivers/freedreno/a6xx/fd6_texture.cc
index 38ea1a497cccb..85908824ade9e 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_texture.cc
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_texture.cc
@@ -163,7 +163,7 @@ setup_border_color(struct fd_screen *screen,
                clamped = CLAMP(bc->ui[j], 0, 65535);
             break;
          default:
-            unreachable("Unexpected bit size");
+            UNREACHABLE("Unexpected bit size");
          case 32:
             clamped = 0;
             break;
@@ -653,7 +653,7 @@ build_texture_state(struct fd_context *ctx, enum pipe_shader_type type,
       tex_count_reg = REG_A6XX_SP_CS_TSIZE;
       break;
    default:
-      unreachable("bad state block");
+      UNREACHABLE("bad state block");
    }
 
    if (tex->num_samplers > 0) {
diff --git a/src/gallium/drivers/freedreno/freedreno_fence.c b/src/gallium/drivers/freedreno/freedreno_fence.c
index 6916212ca4f13..efdc6c9f7f4a6 100644
--- a/src/gallium/drivers/freedreno/freedreno_fence.c
+++ b/src/gallium/drivers/freedreno/freedreno_fence.c
@@ -204,7 +204,7 @@ fd_create_pipe_fence_fd(struct pipe_context *pctx, struct pipe_fence_handle **pf
       break;
    }
    default:
-      unreachable("Unhandled fence type");
+      UNREACHABLE("Unhandled fence type");
    }
 }
 
diff --git a/src/gallium/drivers/freedreno/freedreno_query.c b/src/gallium/drivers/freedreno/freedreno_query.c
index beb248bdd4a5c..f84d08a1e19ec 100644
--- a/src/gallium/drivers/freedreno/freedreno_query.c
+++ b/src/gallium/drivers/freedreno/freedreno_query.c
@@ -199,7 +199,7 @@ query_type(enum fd_perfcntr_type type)
       ENUM(TYPE_AMPS);
       ENUM(TYPE_WATTS);
    default:
-      unreachable("bad type");
+      UNREACHABLE("bad type");
       return 0;
    }
 }
@@ -211,7 +211,7 @@ query_result_type(enum fd_perfcntr_result_type type)
       ENUM(RESULT_TYPE_AVERAGE);
       ENUM(RESULT_TYPE_CUMULATIVE);
    default:
-      unreachable("bad type");
+      UNREACHABLE("bad type");
       return 0;
    }
 }
diff --git a/src/gallium/drivers/freedreno/freedreno_resource.c b/src/gallium/drivers/freedreno/freedreno_resource.c
index d0d78dae0105f..cd34d4fd30272 100644
--- a/src/gallium/drivers/freedreno/freedreno_resource.c
+++ b/src/gallium/drivers/freedreno/freedreno_resource.c
@@ -522,7 +522,7 @@ fd_try_shadow_resource(struct fd_context *ctx, struct fd_resource *rsc,
       case PIPE_TEXTURE_2D:
          /* TODO */
       default:
-         unreachable("TODO");
+         UNREACHABLE("TODO");
       }
    }
 
diff --git a/src/gallium/drivers/freedreno/freedreno_resource.h b/src/gallium/drivers/freedreno/freedreno_resource.h
index cbaf9de6ef8c6..72dc565ced534 100644
--- a/src/gallium/drivers/freedreno/freedreno_resource.h
+++ b/src/gallium/drivers/freedreno/freedreno_resource.h
@@ -464,7 +464,7 @@ fdl_type_from_pipe_target(enum pipe_texture_target target) {
       return FDL_VIEW_TYPE_3D;
    case PIPE_MAX_TEXTURE_TYPES:
    default:
-      unreachable("bad texture type");
+      UNREACHABLE("bad texture type");
    }
 }
 
diff --git a/src/gallium/drivers/freedreno/freedreno_state.c b/src/gallium/drivers/freedreno/freedreno_state.c
index 4ef044366fb4d..8f0a3f8d58709 100644
--- a/src/gallium/drivers/freedreno/freedreno_state.c
+++ b/src/gallium/drivers/freedreno/freedreno_state.c
@@ -731,7 +731,7 @@ fd_set_global_binding(struct pipe_context *pctx, unsigned first, unsigned count,
       /* we are screwed no matter what */
       if (!util_dynarray_grow(&ctx->global_bindings, *prscs,
                               (first + count) - old_size))
-         unreachable("out of memory");
+         UNREACHABLE("out of memory");
 
       for (unsigned i = old_size; i < first + count; i++)
          *util_dynarray_element(&ctx->global_bindings,
diff --git a/src/gallium/drivers/freedreno/freedreno_util.h b/src/gallium/drivers/freedreno/freedreno_util.h
index 51ae73ca126b8..f5a7eb0062e4f 100644
--- a/src/gallium/drivers/freedreno/freedreno_util.h
+++ b/src/gallium/drivers/freedreno/freedreno_util.h
@@ -415,7 +415,7 @@ fd_msaa_samples(unsigned samples)
 {
    switch (samples) {
    default:
-      unreachable("Unsupported samples");
+      UNREACHABLE("Unsupported samples");
    case 0:
    case 1:
       return MSAA_ONE;
@@ -469,7 +469,7 @@ fd4_stage2shadersb(gl_shader_stage type)
    case MESA_SHADER_KERNEL:
       return SB4_CS_SHADER;
    default:
-      unreachable("bad shader type");
+      UNREACHABLE("bad shader type");
       return (enum a4xx_state_block) ~0;
    }
 }
diff --git a/src/gallium/drivers/freedreno/ir3/ir3_descriptor.h b/src/gallium/drivers/freedreno/ir3/ir3_descriptor.h
index 0d6a321df30c0..1186d154edb16 100644
--- a/src/gallium/drivers/freedreno/ir3/ir3_descriptor.h
+++ b/src/gallium/drivers/freedreno/ir3/ir3_descriptor.h
@@ -43,7 +43,7 @@ ir3_shader_descriptor_set(enum pipe_shader_type shader)
    case PIPE_SHADER_COMPUTE:   return 0;
    case MESA_SHADER_KERNEL:    return 0;
    default:
-      unreachable("bad shader stage");
+      UNREACHABLE("bad shader stage");
       return ~0;
    }
 }
diff --git a/src/gallium/drivers/i915/i915_fpc_translate.c b/src/gallium/drivers/i915/i915_fpc_translate.c
index 16f32d32e9ec7..b6cfb2a3dfb74 100644
--- a/src/gallium/drivers/i915/i915_fpc_translate.c
+++ b/src/gallium/drivers/i915/i915_fpc_translate.c
@@ -375,7 +375,7 @@ i915_coord_mask(enum tgsi_opcode opcode, enum tgsi_texture_type tex)
       return coord_mask | TGSI_WRITEMASK_XYZ;
 
    default:
-      unreachable("bad texture target");
+      UNREACHABLE("bad texture target");
    }
 }
 
diff --git a/src/gallium/drivers/iris/iris_batch.c b/src/gallium/drivers/iris/iris_batch.c
index 654c055e91b3a..76e73bd2db1f1 100644
--- a/src/gallium/drivers/iris/iris_batch.c
+++ b/src/gallium/drivers/iris/iris_batch.c
@@ -248,7 +248,7 @@ iris_init_batch(struct iris_context *ice,
                                          stderr, decode_flags, NULL,
                                          decode_get_bo, decode_get_state_size, batch);
 #else
-         unreachable("no elk support");
+         UNREACHABLE("no elk support");
 #endif
       }
       batch->decoder.dynamic_base = IRIS_MEMZONE_DYNAMIC_START;
@@ -281,7 +281,7 @@ iris_init_batches(struct iris_context *ice)
       iris_xe_init_batches(ice);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
    }
 
    iris_foreach_batch(ice, batch)
@@ -540,7 +540,7 @@ iris_batch_free(const struct iris_context *ice, struct iris_batch *batch)
       iris_xe_destroy_batch(batch);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
    }
 
    iris_destroy_batch_measure(batch->measure);
@@ -717,7 +717,7 @@ replace_kernel_ctx(struct iris_batch *batch)
    case INTEL_KMD_TYPE_XE:
       return iris_xe_replace_batch(batch);
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return false;
    }
 }
diff --git a/src/gallium/drivers/iris/iris_blorp.c b/src/gallium/drivers/iris/iris_blorp.c
index 6c6dfdf90ab66..a3b22dfaf33b7 100644
--- a/src/gallium/drivers/iris/iris_blorp.c
+++ b/src/gallium/drivers/iris/iris_blorp.c
@@ -138,7 +138,7 @@ static uint32_t
 blorp_get_dynamic_state(struct blorp_batch *batch,
                         enum blorp_dynamic_state name)
 {
-   unreachable("Not implemented");
+   UNREACHABLE("Not implemented");
 }
 
 static void *
diff --git a/src/gallium/drivers/iris/iris_bufmgr.c b/src/gallium/drivers/iris/iris_bufmgr.c
index 9afe13cf32201..ce4b2c2d72f23 100644
--- a/src/gallium/drivers/iris/iris_bufmgr.c
+++ b/src/gallium/drivers/iris/iris_bufmgr.c
@@ -612,7 +612,7 @@ iris_bo_busy(struct iris_bo *bo)
       busy = iris_bo_busy_syncobj(bo);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       busy = true;
    }
 
@@ -676,7 +676,7 @@ get_slabs(struct iris_bufmgr *bufmgr, uint64_t size)
          return slabs;
    }
 
-   unreachable("should have found a valid slab for this size");
+   UNREACHABLE("should have found a valid slab for this size");
 }
 
 /* Return the power of two size of a slab entry matching the input size. */
@@ -1191,7 +1191,7 @@ alloc_fresh_bo(struct iris_bufmgr *bufmgr, uint64_t bo_size, enum bo_alloc_flags
       case IRIS_HEAP_SYSTEM_MEMORY_UNCACHED:
          /* not valid; discrete cards always enable snooping */
       case IRIS_HEAP_MAX:
-         unreachable("invalid heap for BO");
+         UNREACHABLE("invalid heap for BO");
       }
    } else {
       regions[num_regions++] = bufmgr->sys.region;
@@ -1250,7 +1250,7 @@ heap_to_mmap_mode(struct iris_bufmgr *bufmgr, enum iris_heap heap)
       /* compressed bos are not mmaped */
       return IRIS_MMAP_NONE;
    default:
-      unreachable("invalid heap");
+      UNREACHABLE("invalid heap");
    }
 }
 
@@ -1856,7 +1856,7 @@ iris_bo_wait(struct iris_bo *bo, int64_t timeout_ns)
       ret = iris_bo_wait_syncobj(bo, timeout_ns);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       ret = -1;
    }
 
@@ -1887,7 +1887,7 @@ iris_bufmgr_destroy_global_vm(struct iris_bufmgr *bufmgr)
       iris_xe_destroy_global_vm(bufmgr);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
    }
 }
 
@@ -2385,7 +2385,7 @@ iris_bufmgr_init_global_vm(struct iris_bufmgr *bufmgr)
       /* Xe requires VM */
       return bufmgr->use_global_vm;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return false;
    }
 }
@@ -2763,7 +2763,7 @@ iris_heap_to_pat_entry(const struct intel_device_info *devinfo,
    case IRIS_HEAP_DEVICE_LOCAL_COMPRESSED_SCANOUT:
       return &devinfo->pat.compressed_scanout;
    default:
-      unreachable("invalid heap for platforms using PAT entries");
+      UNREACHABLE("invalid heap for platforms using PAT entries");
    }
 }
 
diff --git a/src/gallium/drivers/iris/iris_clear.c b/src/gallium/drivers/iris/iris_clear.c
index eb028ad307f55..5f9e3d82be928 100644
--- a/src/gallium/drivers/iris/iris_clear.c
+++ b/src/gallium/drivers/iris/iris_clear.c
@@ -826,7 +826,7 @@ iris_clear_texture(struct pipe_context *ctx,
          case 96:  format = ISL_FORMAT_R32G32B32_UINT;    break;
          case 128: format = ISL_FORMAT_R32G32B32A32_UINT; break;
          default:
-            unreachable("Unknown format bpb");
+            UNREACHABLE("Unknown format bpb");
          }
 
          /* No aux surfaces for non-renderable surfaces */
diff --git a/src/gallium/drivers/iris/iris_context.c b/src/gallium/drivers/iris/iris_context.c
index 5c25d5e60e9be..70d90ddc15257 100644
--- a/src/gallium/drivers/iris/iris_context.c
+++ b/src/gallium/drivers/iris/iris_context.c
@@ -73,7 +73,7 @@ iris_lost_context_state(struct iris_batch *batch)
    } else if (batch->name == IRIS_BATCH_BLITTER) {
       /* No state to set up */
    } else {
-      unreachable("unhandled batch reset");
+      UNREACHABLE("unhandled batch reset");
    }
 
    ice->state.dirty = ~0ull;
@@ -159,7 +159,7 @@ iris_get_sample_position(struct pipe_context *ctx,
    case 4:  INTEL_SAMPLE_POS_4X(u.v._);  break;
    case 8:  INTEL_SAMPLE_POS_8X(u.v._);  break;
    case 16: INTEL_SAMPLE_POS_16X(u.v._); break;
-   default: unreachable("invalid sample count");
+   default: UNREACHABLE("invalid sample count");
    }
 
    out_value[0] = u.a.x[sample_index];
@@ -285,13 +285,13 @@ iris_destroy_context(struct pipe_context *ctx)
       gfx8_##func(__VA_ARGS__);                   \
       break;                                      \
    default:                                       \
-      unreachable("Unknown hardware generation"); \
+      UNREACHABLE("Unknown hardware generation"); \
    }
 
 #ifndef INTEL_USE_ELK
-static inline void gfx8_init_state(struct iris_context *ice) { unreachable("no elk support"); }
-static inline void gfx8_init_blorp(struct iris_context *ice) { unreachable("no elk support"); }
-static inline void gfx8_init_query(struct iris_context *ice) { unreachable("no elk support"); }
+static inline void gfx8_init_state(struct iris_context *ice) { UNREACHABLE("no elk support"); }
+static inline void gfx8_init_blorp(struct iris_context *ice) { UNREACHABLE("no elk support"); }
+static inline void gfx8_init_query(struct iris_context *ice) { UNREACHABLE("no elk support"); }
 #endif
 
 /**
diff --git a/src/gallium/drivers/iris/iris_context.h b/src/gallium/drivers/iris/iris_context.h
index 880169dfb9e3f..549e2b5b5b250 100644
--- a/src/gallium/drivers/iris/iris_context.h
+++ b/src/gallium/drivers/iris/iris_context.h
@@ -766,7 +766,7 @@ iris_vue_data(struct iris_compiled_shader *shader)
    case MESA_SHADER_TESS_EVAL: return &shader->tes.base;
    case MESA_SHADER_GEOMETRY:  return &shader->gs.base;
    default:
-      unreachable("invalid shader stage for vue prog data");
+      UNREACHABLE("invalid shader stage for vue prog data");
       return NULL;
    }
 }
@@ -1294,7 +1294,7 @@ iris_blorp_batch_usage(struct iris_batch *batch, bool is_dest)
    case IRIS_BATCH_BLITTER:
       return is_dest ? ISL_SURF_USAGE_BLITTER_DST_BIT : ISL_SURF_USAGE_BLITTER_SRC_BIT;
    default:
-      unreachable("Unhandled batch type");
+      UNREACHABLE("Unhandled batch type");
    }
 }
 
diff --git a/src/gallium/drivers/iris/iris_disk_cache.c b/src/gallium/drivers/iris/iris_disk_cache.c
index 6dcb8a2c216a6..28ce4215d0907 100644
--- a/src/gallium/drivers/iris/iris_disk_cache.c
+++ b/src/gallium/drivers/iris/iris_disk_cache.c
@@ -141,7 +141,7 @@ iris_disk_cache_store(struct disk_cache *cache,
       serializable.base.relocs = NULL;
       blob_write_bytes(&blob, &serializable, prog_data_s);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -161,7 +161,7 @@ iris_disk_cache_store(struct disk_cache *cache,
       blob_write_bytes(&blob, elk->param,
                        elk->nr_params * sizeof(uint32_t));
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
    blob_write_bytes(&blob, &shader->bt, sizeof(shader->bt));
@@ -289,7 +289,7 @@ iris_disk_cache_retrieve(struct iris_screen *screen,
                          elk->nr_params * sizeof(uint32_t));
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -325,7 +325,7 @@ iris_disk_cache_retrieve(struct iris_screen *screen,
 #ifdef INTEL_USE_ELK
       iris_apply_elk_prog_data(shader, elk);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
 
    iris_finalize_program(shader, so_decls, system_values,
diff --git a/src/gallium/drivers/iris/iris_genx_macros.h b/src/gallium/drivers/iris/iris_genx_macros.h
index 877f1baecf95a..892fd7a965dc4 100644
--- a/src/gallium/drivers/iris/iris_genx_macros.h
+++ b/src/gallium/drivers/iris/iris_genx_macros.h
@@ -65,7 +65,7 @@ __gen_combine_address(struct iris_batch *batch, void *location,
 static inline struct iris_address
 __gen_get_batch_address(struct iris_batch *batch, void *location)
 {
-   unreachable("Not supported by iris");
+   UNREACHABLE("Not supported by iris");
 }
 
 #define __gen_address_type struct iris_address
diff --git a/src/gallium/drivers/iris/iris_monitor.c b/src/gallium/drivers/iris/iris_monitor.c
index 5661d6100c840..2d61671f00c89 100644
--- a/src/gallium/drivers/iris/iris_monitor.c
+++ b/src/gallium/drivers/iris/iris_monitor.c
@@ -331,7 +331,7 @@ iris_get_monitor_result(struct pipe_context *ctx,
          break;
       }
       default:
-         unreachable("unexpected counter data type");
+         UNREACHABLE("unexpected counter data type");
       }
    }
    return true;
diff --git a/src/gallium/drivers/iris/iris_program.c b/src/gallium/drivers/iris/iris_program.c
index a3e05775b6a35..03f3c3979b4ff 100644
--- a/src/gallium/drivers/iris/iris_program.c
+++ b/src/gallium/drivers/iris/iris_program.c
@@ -288,7 +288,7 @@ iris_apply_brw_prog_data(struct iris_compiled_shader *shader,
       iris_apply_brw_gs_prog_data(shader, brw_gs_prog_data_const(brw));
       break;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 
    shader->brw_prog_data = brw;
@@ -490,7 +490,7 @@ iris_apply_elk_prog_data(struct iris_compiled_shader *shader,
       iris_apply_elk_gs_prog_data(shader, elk_gs_prog_data_const(elk));
       break;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 
    shader->elk_prog_data = elk;
@@ -819,7 +819,7 @@ iris_uses_image_atomic(const nir_shader *shader)
             switch (intrin->intrinsic) {
             case nir_intrinsic_image_deref_atomic:
             case nir_intrinsic_image_deref_atomic_swap:
-               unreachable("Should have been lowered in "
+               UNREACHABLE("Should have been lowered in "
                            "iris_lower_storage_image_derefs");
 
             case nir_intrinsic_image_atomic:
@@ -935,7 +935,7 @@ setup_vec4_image_sysval(uint32_t *sysvals, uint32_t idx,
    for (unsigned i = n; i < 4; ++i)
       sysvals[i] = ELK_PARAM_BUILTIN_ZERO;
 #else
-   unreachable("no elk support");
+   UNREACHABLE("no elk support");
 #endif
 }
 
@@ -1636,7 +1636,7 @@ iris_debug_recompile_brw(struct iris_screen *screen,
       old_key.cs = iris_to_brw_cs_key(screen, old_iris_key);
       break;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 
    brw_debug_key_recompile(c, dbg, info->stage, &old_key.base, key);
@@ -1688,7 +1688,7 @@ iris_debug_recompile_elk(struct iris_screen *screen,
       old_key.cs = iris_to_elk_cs_key(screen, old_iris_key);
       break;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 
    elk_debug_key_recompile(c, dbg, info->stage, &old_key.base, key);
@@ -1942,7 +1942,7 @@ iris_compile_vs(struct iris_screen *screen,
          iris_apply_elk_prog_data(shader, &elk_prog_data->base.base);
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -2106,7 +2106,7 @@ iris_compile_tcs(struct iris_screen *screen,
          assert(screen->elk);
          nir = elk_nir_create_passthrough_tcs(mem_ctx, screen->elk, &elk_key);
 #else
-         unreachable("no elk support");
+         UNREACHABLE("no elk support");
 #endif
       }
       source_hash = *(uint32_t*)nir->info.source_blake3;
@@ -2168,7 +2168,7 @@ iris_compile_tcs(struct iris_screen *screen,
          iris_apply_elk_prog_data(shader, &elk_prog_data->base.base);
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -2379,7 +2379,7 @@ iris_compile_tes(struct iris_screen *screen,
          iris_apply_elk_prog_data(shader, &elk_prog_data->base.base);
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -2565,7 +2565,7 @@ iris_compile_gs(struct iris_screen *screen,
          iris_apply_elk_prog_data(shader, &elk_prog_data->base.base);
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -2752,7 +2752,7 @@ iris_compile_fs(struct iris_screen *screen,
          iris_apply_elk_prog_data(shader, &elk_prog_data->base);
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -3016,7 +3016,7 @@ iris_compile_cs(struct iris_screen *screen,
 #ifdef INTEL_USE_ELK
       NIR_PASS(_, nir, elk_nir_lower_cs_intrinsics, devinfo, NULL);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
 
    iris_setup_uniforms(devinfo, mem_ctx, nir,
@@ -3077,7 +3077,7 @@ iris_compile_cs(struct iris_screen *screen,
          iris_apply_elk_prog_data(shader, &elk_prog_data->base);
       }
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -3305,7 +3305,7 @@ iris_create_compute_state(struct pipe_context *ctx,
       break;
 
    default:
-      unreachable("Unsupported IR");
+      UNREACHABLE("Unsupported IR");
    }
 
    /* Most of iris doesn't really care about the difference between compute
@@ -3415,7 +3415,7 @@ iris_compile_shader(void *_job, UNUSED void *_gdata, UNUSED int thread_index)
       break;
 
    default:
-      unreachable("Invalid shader stage.");
+      UNREACHABLE("Invalid shader stage.");
    }
 }
 
@@ -3542,7 +3542,7 @@ iris_create_shader_state(struct pipe_context *ctx,
       break;
 
    default:
-      unreachable("Invalid shader stage.");
+      UNREACHABLE("Invalid shader stage.");
    }
 
    if (screen->precompile) {
@@ -3806,7 +3806,7 @@ iris_finalize_nir(struct pipe_screen *_screen, struct nir_shader *nir)
                     .lower_get_size = true,
                  });
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -3902,7 +3902,7 @@ iris_get_cs_dispatch_info(const struct intel_device_info *devinfo,
                                       elk_cs_prog_data(shader->elk_prog_data),
                                       block);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 }
@@ -3920,7 +3920,7 @@ iris_cs_push_const_total_size(const struct iris_compiled_shader *shader,
       return elk_cs_push_const_total_size(elk_cs_prog_data(shader->elk_prog_data),
                                           threads);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 }
@@ -3938,7 +3938,7 @@ iris_fs_barycentric_modes(const struct iris_compiled_shader *shader,
       return elk_wm_prog_data_barycentric_modes(elk_wm_prog_data(shader->elk_prog_data),
                                                 pushed_msaa_flags);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 }
@@ -3959,7 +3959,7 @@ iris_indirect_ubos_use_sampler(struct iris_screen *screen)
       assert(screen->elk);
       return screen->elk->indirect_ubos_use_sampler;
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 }
@@ -4033,7 +4033,7 @@ iris_compiler_init(struct iris_screen *screen)
       screen->elk->shader_perf_log = iris_shader_perf_log;
       screen->elk->supports_shader_constants = true;
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 }
diff --git a/src/gallium/drivers/iris/iris_program_cache.c b/src/gallium/drivers/iris/iris_program_cache.c
index 9d758e128bf83..fd0a07744b97f 100644
--- a/src/gallium/drivers/iris/iris_program_cache.c
+++ b/src/gallium/drivers/iris/iris_program_cache.c
@@ -205,7 +205,7 @@ iris_upload_shader(struct iris_screen *screen,
                               shader->elk_prog_data, reloc_values,
                               ARRAY_SIZE(reloc_values));
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -294,7 +294,7 @@ iris_blorp_upload_shader(struct blorp_batch *blorp_batch, uint32_t stage,
       assert(screen->elk);
       iris_apply_elk_prog_data(shader, prog_data);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -411,7 +411,7 @@ iris_ensure_indirect_generation_shader(struct iris_batch *batch)
       struct elk_nir_compiler_opts opts = {};
       elk_preprocess_nir(screen->elk, nir, &opts);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
@@ -504,7 +504,7 @@ iris_ensure_indirect_generation_shader(struct iris_batch *batch)
       assert(program);
       iris_apply_elk_prog_data(shader, &prog_data->base);
 #else
-      unreachable("no elk support");
+      UNREACHABLE("no elk support");
 #endif
    }
 
diff --git a/src/gallium/drivers/iris/iris_resolve.c b/src/gallium/drivers/iris/iris_resolve.c
index efbcac884ac4b..0ff5eebfe4b71 100644
--- a/src/gallium/drivers/iris/iris_resolve.c
+++ b/src/gallium/drivers/iris/iris_resolve.c
@@ -696,7 +696,7 @@ iris_hiz_exec(struct iris_context *ice,
       break;
    case ISL_AUX_OP_PARTIAL_RESOLVE:
    case ISL_AUX_OP_NONE:
-      unreachable("Invalid HiZ op");
+      UNREACHABLE("Invalid HiZ op");
    }
 
    //DBG("%s %s to mt %p level %d layers %d-%d\n",
@@ -912,7 +912,7 @@ iris_resource_prepare_access(struct iris_context *ice,
          } else if (isl_aux_usage_has_hiz(res->aux.usage)) {
             iris_hiz_exec(ice, batch, res, level, layer, 1, aux_op);
          } else if (res->aux.usage == ISL_AUX_USAGE_STC_CCS) {
-            unreachable("iris doesn't resolve STC_CCS resources");
+            UNREACHABLE("iris doesn't resolve STC_CCS resources");
          } else {
             assert(isl_aux_usage_has_ccs(res->aux.usage));
             iris_resolve_color(ice, batch, res, level, layer, aux_op);
diff --git a/src/gallium/drivers/iris/iris_resource.c b/src/gallium/drivers/iris/iris_resource.c
index 7e56348e4dcaa..78f380a681a63 100644
--- a/src/gallium/drivers/iris/iris_resource.c
+++ b/src/gallium/drivers/iris/iris_resource.c
@@ -756,7 +756,7 @@ target_to_isl_surf_dim(enum pipe_texture_target target)
    case PIPE_MAX_TEXTURE_TYPES:
       break;
    }
-   unreachable("invalid texture type");
+   UNREACHABLE("invalid texture type");
 }
 
 static bool
@@ -1339,7 +1339,7 @@ iris_resource_from_handle(struct pipe_screen *pscreen,
                                              whandle->handle, flags);
       break;
    default:
-      unreachable("invalid winsys handle type");
+      UNREACHABLE("invalid winsys handle type");
    }
    if (!res->bo)
       goto fail;
diff --git a/src/gallium/drivers/iris/iris_screen.c b/src/gallium/drivers/iris/iris_screen.c
index 408cf867e384e..e8a6c3f4eaa9b 100644
--- a/src/gallium/drivers/iris/iris_screen.c
+++ b/src/gallium/drivers/iris/iris_screen.c
@@ -84,12 +84,12 @@
       gfx8_##func(__VA_ARGS__);                   \
       break;                                      \
    default:                                       \
-      unreachable("Unknown hardware generation"); \
+      UNREACHABLE("Unknown hardware generation"); \
    }
 
 #ifndef INTEL_USE_ELK
-static inline void gfx8_init_screen_state(struct iris_screen *screen) { unreachable("no elk support"); }
-static inline void gfx8_init_screen_gen_state(struct iris_screen *screen) { unreachable("no elk support"); }
+static inline void gfx8_init_screen_state(struct iris_screen *screen) { UNREACHABLE("no elk support"); }
+static inline void gfx8_init_screen_gen_state(struct iris_screen *screen) { UNREACHABLE("no elk support"); }
 #endif
 
 static const char *
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index e5905f8296a3b..3962a19c0c37b 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -669,7 +669,7 @@ iris_rewrite_compute_walker_pc(struct iris_batch *batch,
    for (uint32_t i = 0; i < GENX(COMPUTE_WALKER_length); i++)
       walker[i] |= dwords[i];
 #else
-   unreachable("Unsupported");
+   UNREACHABLE("Unsupported");
 #endif
 }
 
@@ -1015,7 +1015,7 @@ upload_pixel_hashing_tables(struct iris_batch *batch)
       else if (ppipes_of[2] == 1 && ppipes_of[1] == 1 && ppipes_of[0] == 1)
          intel_compute_pixel_hash_table_3way(8, 16, 3, 3, 0, p.ThreeWayTableEntry[0]);
       else
-         unreachable("Illegal fusing.");
+         UNREACHABLE("Illegal fusing.");
    }
 
    iris_emit_cmd(batch, GENX(3DSTATE_3D_MODE), p) {
@@ -1234,7 +1234,7 @@ toggle_protected(struct iris_batch *batch)
    else if (batch->name == IRIS_BATCH_COMPUTE)
       ice = container_of(batch, struct iris_context, batches[IRIS_BATCH_COMPUTE]);
    else
-      unreachable("unhandled batch");
+      UNREACHABLE("unhandled batch");
 
    if (!ice->protected)
       return;
@@ -1256,7 +1256,7 @@ toggle_protected(struct iris_batch *batch)
       pc.ProtectedMemoryEnable = true;
    }
 #else
-   unreachable("Not supported");
+   UNREACHABLE("Not supported");
 #endif
 }
 
@@ -2769,7 +2769,7 @@ fmt_swizzle(const struct iris_format_info *fmt, enum pipe_swizzle swz)
    case PIPE_SWIZZLE_W: return fmt->swizzle.a;
    case PIPE_SWIZZLE_1: return ISL_CHANNEL_SELECT_ONE;
    case PIPE_SWIZZLE_0: return ISL_CHANNEL_SELECT_ZERO;
-   default: unreachable("invalid swizzle");
+   default: UNREACHABLE("invalid swizzle");
    }
 }
 
@@ -6266,7 +6266,7 @@ batch_emit_fast_color_dummy_blit(struct iris_batch *batch)
       blt.DestinationTiling = XY_TILE_LINEAR;
    }
 #else
-   unreachable("Not implemented");
+   UNREACHABLE("Not implemented");
 #endif
 }
 
@@ -6354,7 +6354,7 @@ invalidate_aux_map_state_per_engine(struct iris_batch *batch)
       break;
    }
    default:
-      unreachable("Invalid batch for aux map invalidation");
+      UNREACHABLE("Invalid batch for aux map invalidation");
       break;
    }
 
@@ -6424,7 +6424,7 @@ init_aux_map_state(struct iris_batch *batch)
 #endif
       break;
    default:
-      unreachable("Invalid batch for aux map init.");
+      UNREACHABLE("Invalid batch for aux map init.");
    }
 
    if (reg)
@@ -8836,7 +8836,7 @@ iris_upload_indirect_render_state(struct iris_context *ice,
    count *= draw->instance_count ? draw->instance_count : 1;
    trace_intel_end_draw(&batch->trace, count, 0, 0);
 #else
-   unreachable("Unsupported path");
+   UNREACHABLE("Unsupported path");
 #endif /* GFX_VERx10 >= 125 */
 }
 
diff --git a/src/gallium/drivers/iris/xe/iris_kmd_backend.c b/src/gallium/drivers/iris/xe/iris_kmd_backend.c
index b1718af9f166b..f0dca591c66c1 100644
--- a/src/gallium/drivers/iris/xe/iris_kmd_backend.c
+++ b/src/gallium/drivers/iris/xe/iris_kmd_backend.c
@@ -89,7 +89,7 @@ xe_gem_create(struct iris_bufmgr *bufmgr,
       gem_create.cpu_caching = DRM_XE_GEM_CPU_CACHING_WB;
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       gem_create.cpu_caching = DRM_XE_GEM_CPU_CACHING_WC;
    }
 
diff --git a/src/gallium/drivers/lima/genxml/lima_pack_header.h b/src/gallium/drivers/lima/genxml/lima_pack_header.h
index 559769b8806c5..5da27e892bb47 100644
--- a/src/gallium/drivers/lima/genxml/lima_pack_header.h
+++ b/src/gallium/drivers/lima/genxml/lima_pack_header.h
@@ -150,7 +150,7 @@ lima_genxml_validate_bounds(const char *name, uint64_t value, uint64_t bound)
       fprintf(stderr, "%s out-of-bounds, got 0x%" PRIx64 ", max %" PRIx64 "\n",
               name, value, bound);
 
-      unreachable("Out-of-bounds pack");
+      UNREACHABLE("Out-of-bounds pack");
    }
 }
 
diff --git a/src/gallium/drivers/lima/ir/gp/lower.c b/src/gallium/drivers/lima/ir/gp/lower.c
index 890078458e964..6795d67d9d134 100644
--- a/src/gallium/drivers/lima/ir/gp/lower.c
+++ b/src/gallium/drivers/lima/ir/gp/lower.c
@@ -323,7 +323,7 @@ static bool gpir_lower_eq_ne(gpir_block *block, gpir_node *node)
          node_new_op = gpir_op_max; /* or */
          break;
       default:
-         unreachable("bad node op");
+         UNREACHABLE("bad node op");
    }
 
    gpir_alu_node *e = gpir_node_to_alu(node);
diff --git a/src/gallium/drivers/lima/ir/pp/codegen.c b/src/gallium/drivers/lima/ir/pp/codegen.c
index 3d6db737915ba..6c8d40c4f940d 100644
--- a/src/gallium/drivers/lima/ir/pp/codegen.c
+++ b/src/gallium/drivers/lima/ir/pp/codegen.c
@@ -210,7 +210,7 @@ static ppir_codegen_outmod ppir_codegen_get_outmod(ppir_outmod outmod)
       case ppir_outmod_round:
          return ppir_codegen_outmod_round;
       default:
-         unreachable("invalid ppir_outmod");
+         UNREACHABLE("invalid ppir_outmod");
    }
 }
 
diff --git a/src/gallium/drivers/lima/ir/pp/nir.c b/src/gallium/drivers/lima/ir/pp/nir.c
index c7701cd4fcf55..975efec407914 100644
--- a/src/gallium/drivers/lima/ir/pp/nir.c
+++ b/src/gallium/drivers/lima/ir/pp/nir.c
@@ -389,7 +389,7 @@ static bool ppir_emit_intrinsic(ppir_block *block, nir_instr *ni)
          op = ppir_op_load_frontface;
          break;
       default:
-         unreachable("bad intrinsic");
+         UNREACHABLE("bad intrinsic");
          break;
       }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_fence.c b/src/gallium/drivers/llvmpipe/lp_fence.c
index ef4d1b62727f3..37bfc6233b4a4 100644
--- a/src/gallium/drivers/llvmpipe/lp_fence.c
+++ b/src/gallium/drivers/llvmpipe/lp_fence.c
@@ -184,7 +184,7 @@ lp_fence_signalled(struct lp_fence *f)
    }
 #endif
 
-   unreachable("Fence is an unknown type");
+   UNREACHABLE("Fence is an unknown type");
    return false;
 }
 
@@ -248,7 +248,7 @@ lp_fence_timedwait(struct lp_fence *f, uint64_t timeout)
    }
 #endif
 
-   unreachable("Fence is an unknown type");
+   UNREACHABLE("Fence is an unknown type");
    return false;
 }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 654af717b6c55..fe9fcb3aeb005 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -4273,7 +4273,7 @@ llvmpipe_set_constant_buffer(struct pipe_context *pipe,
       llvmpipe->dirty |= LP_NEW_MESH_CONSTANTS;
       break;
    default:
-      unreachable("Illegal shader type");
+      UNREACHABLE("Illegal shader type");
       break;
    }
 }
@@ -4330,7 +4330,7 @@ llvmpipe_set_shader_buffers(struct pipe_context *pipe,
          llvmpipe->dirty |= LP_NEW_FS_SSBOS;
          break;
       default:
-         unreachable("Illegal shader type");
+         UNREACHABLE("Illegal shader type");
          break;
       }
    }
@@ -4381,7 +4381,7 @@ llvmpipe_set_shader_images(struct pipe_context *pipe,
       llvmpipe->dirty |= LP_NEW_MESH_IMAGES;
       break;
    default:
-      unreachable("Illegal shader type");
+      UNREACHABLE("Illegal shader type");
       break;
    }
 
diff --git a/src/gallium/drivers/llvmpipe/lp_state_sampler.c b/src/gallium/drivers/llvmpipe/lp_state_sampler.c
index 78ee298423773..7146d3f73d32e 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_sampler.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_sampler.c
@@ -119,7 +119,7 @@ llvmpipe_bind_sampler_states(struct pipe_context *pipe,
       llvmpipe->dirty |= LP_NEW_MESH_SAMPLER;
       break;
    default:
-      unreachable("Illegal shader type");
+      UNREACHABLE("Illegal shader type");
       break;
    }
 }
@@ -205,7 +205,7 @@ llvmpipe_set_sampler_views(struct pipe_context *pipe,
       llvmpipe->dirty |= LP_NEW_MESH_SAMPLER_VIEW;
       break;
    default:
-      unreachable("Illegal shader type");
+      UNREACHABLE("Illegal shader type");
       break;
    }
 }
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gm107.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gm107.cpp
index c7c08867c5013..6f3c99e68258c 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gm107.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gm107.cpp
@@ -2950,7 +2950,7 @@ CodeEmitterGM107::emitTEXS()
       emitField(0x32, 1, insn->tex.target.isShadow());
       break;
    default:
-      unreachable("unknown op in emitTEXS()");
+      UNREACHABLE("unknown op in emitTEXS()");
       break;
    }
 
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gv100.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gv100.cpp
index 1770b5fa374f1..d3d435a645334 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gv100.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_gv100.cpp
@@ -974,7 +974,7 @@ gv100_interpApply(const FixupEntry *entry, uint32_t *code, const FixupData& data
    case NV50_IR_INTERP_DEFAULT : sample = 0; break;
    case NV50_IR_INTERP_CENTROID: sample = 1; break;
    case NV50_IR_INTERP_OFFSET  : sample = 2; break;
-   default: unreachable("invalid sample mode");
+   default: UNREACHABLE("invalid sample mode");
    }
 
    int interp;
@@ -983,7 +983,7 @@ gv100_interpApply(const FixupEntry *entry, uint32_t *code, const FixupData& data
    case NV50_IR_INTERP_PERSPECTIVE: interp = 0; break;
    case NV50_IR_INTERP_FLAT       : interp = 1; break;
    case NV50_IR_INTERP_SC         : interp = 2; break;
-   default: unreachable("invalid ipa mode");
+   default: UNREACHABLE("invalid ipa mode");
    }
 
    code[loc + 2] &= ~(0xf << 12);
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_from_nir.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_from_nir.cpp
index ae9e1c756e984..e401a526300af 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_from_nir.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_from_nir.cpp
@@ -2014,7 +2014,7 @@ Converter::visit(nir_intrinsic_instr *insn)
          mkOp1(OP_PIXLD, TYPE_U32, newDefs[0], sample)->subOp = NV50_IR_SUBOP_PIXLD_OFFSET;
          mode = NV50_IR_INTERP_OFFSET;
       } else {
-         unreachable("all intrinsics already handled above");
+         UNREACHABLE("all intrinsics already handled above");
       }
 
       loadImm(newDefs[1], mode);
@@ -2369,7 +2369,7 @@ Converter::visit(nir_intrinsic_instr *insn)
          bindless = op == nir_intrinsic_bindless_image_size;
          break;
       default:
-         unreachable("unhandled image opcode");
+         UNREACHABLE("unhandled image opcode");
          break;
       }
 
@@ -2571,7 +2571,7 @@ Converter::convert(nir_load_const_instr *insn, uint8_t idx)
       val = loadImm(getSSA(4), insn->value[idx].u8);
       break;
    default:
-      unreachable("unhandled bit size!\n");
+      UNREACHABLE("unhandled bit size!\n");
    }
    setPosition(bb, true);
    return val;
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gv100.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gv100.cpp
index 6b053d8a318fd..2a390664a2924 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gv100.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gv100.cpp
@@ -132,7 +132,7 @@ GV100LegalizeSSA::handleLOP2(Instruction *i)
    case OP_OR : subOp = src0 | src1; break;
    case OP_XOR: subOp = src0 ^ src1; break;
    default:
-      unreachable("invalid LOP2 opcode");
+      UNREACHABLE("invalid LOP2 opcode");
    }
 
    bld.mkOp3(OP_LOP3_LUT, TYPE_U32, i->getDef(0), i->getSrc(0), i->getSrc(1),
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_tex.c b/src/gallium/drivers/nouveau/nv50/nv50_tex.c
index 7a7eb776f0afa..7ed4d4783d690 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_tex.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_tex.c
@@ -191,7 +191,7 @@ nv50_create_texture_view(struct pipe_context *pipe,
       tic[2] |= G80_TIC_2_TEXTURE_TYPE_ONE_D_BUFFER | G80_TIC_2_LAYOUT_PITCH;
       break;
    default:
-      unreachable("unexpected/invalid texture target");
+      UNREACHABLE("unexpected/invalid texture target");
    }
 
    tic[3] = (flags & NV50_TEXVIEW_FILTER_MSAA8) ? 0x20000000 : 0x00300000;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_tex.c b/src/gallium/drivers/nouveau/nvc0/nvc0_tex.c
index f7c3d5f1b9d3a..c7d990faeebe8 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_tex.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_tex.c
@@ -199,7 +199,7 @@ gm107_create_texture_view(struct pipe_context *pipe,
       tic[4] |= GM107_TIC2_4_TEXTURE_TYPE_CUBE_ARRAY;
       break;
    default:
-      unreachable("unexpected/invalid texture target");
+      UNREACHABLE("unexpected/invalid texture target");
    }
 
    tic[3] |= (flags & NV50_TEXVIEW_FILTER_MSAA8) ?
@@ -407,7 +407,7 @@ gf100_create_texture_view(struct pipe_context *pipe,
       tic[2] |= G80_TIC_2_TEXTURE_TYPE_CUBE_ARRAY;
       break;
    default:
-      unreachable("unexpected/invalid texture target");
+      UNREACHABLE("unexpected/invalid texture target");
    }
 
    tic[3] = (flags & NV50_TEXVIEW_FILTER_MSAA8) ? 0x20000000 : 0x00300000;
diff --git a/src/gallium/drivers/panfrost/pan_blit.c b/src/gallium/drivers/panfrost/pan_blit.c
index abc756a146a6a..ca714c0c0f7ef 100644
--- a/src/gallium/drivers/panfrost/pan_blit.c
+++ b/src/gallium/drivers/panfrost/pan_blit.c
@@ -107,7 +107,7 @@ panfrost_blit(struct pipe_context *pipe, const struct pipe_blit_info *info)
       return;
 
    if (!util_blitter_is_blit_supported(ctx->blitter, info))
-      unreachable("Unsupported blit\n");
+      UNREACHABLE("Unsupported blit\n");
 
    /* Legalize here because it could trigger a recursive blit otherwise */
    struct panfrost_resource *src = pan_resource(info->src.resource);
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 6f43f995c17f3..6e3f7e5fa5261 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -137,7 +137,7 @@ translate_tex_wrap(enum pipe_tex_wrap w, bool using_nearest)
 #endif
 
    default:
-      unreachable("Invalid wrap");
+      UNREACHABLE("Invalid wrap");
    }
 }
 
@@ -168,7 +168,7 @@ pan_pipe_to_mipmode(enum pipe_tex_mipfilter f)
       return MALI_MIPMAP_MODE_NEAREST;
 #endif
    default:
-      unreachable("Invalid");
+      UNREACHABLE("Invalid");
    }
 }
 
@@ -1030,7 +1030,7 @@ panfrost_map_constant_buffer_gpu(struct panfrost_batch *batch,
                                      cb->user_buffer + cb->buffer_offset,
                                      cb->buffer_size, 16);
    } else {
-      unreachable("No constant buffer");
+      UNREACHABLE("No constant buffer");
    }
 }
 
@@ -2016,7 +2016,7 @@ pan_modifier_to_attr_type(uint64_t modifier)
    case DRM_FORMAT_MOD_ARM_16X16_BLOCK_U_INTERLEAVED:
       return MALI_ATTRIBUTE_TYPE_3D_INTERLEAVED;
    default:
-      unreachable("Invalid modifier for attribute record");
+      UNREACHABLE("Invalid modifier for attribute record");
    }
 }
 
@@ -3942,7 +3942,7 @@ pan_pipe_to_stencil_op(enum pipe_stencil_op in)
    case PIPE_STENCIL_OP_INVERT:
       return MALI_STENCIL_OP_INVERT;
    default:
-      unreachable("Invalid stencil op");
+      UNREACHABLE("Invalid stencil op");
    }
 }
 
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.h b/src/gallium/drivers/panfrost/pan_cmdstream.h
index a19e82b7783e2..581d4ff2cad2c 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.h
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.h
@@ -200,7 +200,7 @@ pan_draw_mode(enum mesa_prim mode)
 #undef DEFINE_CASE
 
    default:
-      unreachable("Invalid draw mode");
+      UNREACHABLE("Invalid draw mode");
    }
 }
 
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 813bb1538e7f7..713cc6ddada41 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -913,7 +913,7 @@ panfrost_set_global_binding(struct pipe_context *pctx, unsigned first,
       /* we are screwed no matter what */
       if (!util_dynarray_grow(&ctx->global_buffers, *resources,
                               (first + count) - old_size))
-         unreachable("out of memory");
+         UNREACHABLE("out of memory");
 
       for (unsigned i = old_size; i < first + count; i++)
          *util_dynarray_element(&ctx->global_buffers, struct pipe_resource *,
diff --git a/src/gallium/drivers/panfrost/pan_fb_preload.c b/src/gallium/drivers/panfrost/pan_fb_preload.c
index e5e443894c14b..bbcaa7cf7c0e1 100644
--- a/src/gallium/drivers/panfrost/pan_fb_preload.c
+++ b/src/gallium/drivers/panfrost/pan_fb_preload.c
@@ -59,7 +59,7 @@ nir_type_to_reg_fmt(nir_alu_type in)
    case nir_type_uint32:
       return MALI_REGISTER_FILE_FORMAT_U32;
    default:
-      unreachable("Invalid type");
+      UNREACHABLE("Invalid type");
    }
 }
 #endif
@@ -422,7 +422,7 @@ pan_preload_get_shader(struct pan_fb_preload_cache *cache,
          type_str = "int";
          break;
       default:
-         unreachable("Invalid type\n");
+         UNREACHABLE("Invalid type\n");
       }
 
       switch (key->surfaces[i].dim) {
@@ -439,7 +439,7 @@ pan_preload_get_shader(struct pan_fb_preload_cache *cache,
          dim_str = "3D";
          break;
       default:
-         unreachable("Invalid dim\n");
+         UNREACHABLE("Invalid dim\n");
       }
 
       coord_comps = MAX2(coord_comps, (key->surfaces[i].dim ?: 3) +
@@ -493,7 +493,7 @@ pan_preload_get_shader(struct pan_fb_preload_cache *cache,
          sampler_dim = GLSL_SAMPLER_DIM_CUBE;
          break;
       default:
-         unreachable("Invalid dimension");
+         UNREACHABLE("Invalid dimension");
       }
 
       nir_tex_instr *tex = nir_tex_instr_create(b.shader, ms ? 3 : 1);
diff --git a/src/gallium/drivers/panfrost/pan_helpers.c b/src/gallium/drivers/panfrost/pan_helpers.c
index 6139216b3cfb0..64d2035d34522 100644
--- a/src/gallium/drivers/panfrost/pan_helpers.c
+++ b/src/gallium/drivers/panfrost/pan_helpers.c
@@ -81,7 +81,7 @@ panfrost_analyze_sysvals(struct panfrost_compiled_shader *ss)
          break;
 
       default:
-         unreachable("Invalid sysval");
+         UNREACHABLE("Invalid sysval");
       }
    }
 
diff --git a/src/gallium/drivers/panfrost/pan_jm.c b/src/gallium/drivers/panfrost/pan_jm.c
index af01674d454d2..2c42bf76b98ed 100644
--- a/src/gallium/drivers/panfrost/pan_jm.c
+++ b/src/gallium/drivers/panfrost/pan_jm.c
@@ -970,7 +970,7 @@ GENX(jm_launch_draw)(struct panfrost_batch *batch,
 #elif PAN_ARCH >= 6
       tiler = pan_pool_alloc_desc(&batch->pool.base, INDEXED_VERTEX_JOB);
 #else
-      unreachable("IDVS is unsupported on Midgard");
+      UNREACHABLE("IDVS is unsupported on Midgard");
 #endif
    } else {
       vertex = pan_pool_alloc_desc(&batch->pool.base, COMPUTE_JOB);
@@ -1014,7 +1014,7 @@ GENX(jm_launch_draw_indirect)(struct panfrost_batch *batch,
                               unsigned drawid_offset,
                               const struct pipe_draw_indirect_info *indirect)
 {
-   unreachable("draw indirect not implemented for jm");
+   UNREACHABLE("draw indirect not implemented for jm");
 }
 
 void
diff --git a/src/gallium/drivers/panfrost/pan_mod_conv_cso.c b/src/gallium/drivers/panfrost/pan_mod_conv_cso.c
index 13c336231f35d..901e15a47757f 100644
--- a/src/gallium/drivers/panfrost/pan_mod_conv_cso.c
+++ b/src/gallium/drivers/panfrost/pan_mod_conv_cso.c
@@ -416,7 +416,7 @@ get_mod_convert_shaders(struct panfrost_context *ctx,
    } else if (drm_is_mtk_tiled(key->mod)) {
       COMPILE_SHADER(mtk_tiled, detile, key);
    } else {
-      unreachable("Unsupported conversion");
+      UNREACHABLE("Unsupported conversion");
    }
 
 #undef COMPILE_SHADER
diff --git a/src/gallium/drivers/panfrost/pan_resource.h b/src/gallium/drivers/panfrost/pan_resource.h
index 1521ca2b82bf1..0aa578d20bc28 100644
--- a/src/gallium/drivers/panfrost/pan_resource.h
+++ b/src/gallium/drivers/panfrost/pan_resource.h
@@ -225,7 +225,7 @@ panfrost_translate_texture_dimension(enum pipe_texture_target t)
       return MALI_TEXTURE_DIMENSION_CUBE;
 
    default:
-      unreachable("Unknown target");
+      UNREACHABLE("Unknown target");
    }
 }
 
diff --git a/src/gallium/drivers/r300/compiler/nir_to_rc.c b/src/gallium/drivers/r300/compiler/nir_to_rc.c
index 1a8e6bd22371c..ab2d027185cf0 100644
--- a/src/gallium/drivers/r300/compiler/nir_to_rc.c
+++ b/src/gallium/drivers/r300/compiler/nir_to_rc.c
@@ -370,7 +370,7 @@ ntr_try_store_ssa_in_tgsi_output(struct ntr_compile *c, struct ureg_dst *dst, ni
    nir_foreach_use_including_if (use, def) {
       return ntr_try_store_in_tgsi_output_with_use(c, dst, use);
    }
-   unreachable("We have one use");
+   UNREACHABLE("We have one use");
 }
 
 static void
@@ -500,7 +500,7 @@ tgsi_texture_type_from_sampler_dim(enum glsl_sampler_dim dim, bool is_array)
    case GLSL_SAMPLER_DIM_BUF:
       return TGSI_TEXTURE_BUFFER;
    default:
-      unreachable("unknown sampler dim");
+      UNREACHABLE("unknown sampler dim");
    }
 }
 
@@ -515,7 +515,7 @@ tgsi_return_type_from_base_type(enum glsl_base_type type)
    case GLSL_TYPE_FLOAT:
       return TGSI_RETURN_TYPE_FLOAT;
    default:
-      unreachable("unexpected texture type");
+      UNREACHABLE("unexpected texture type");
    }
 }
 
@@ -923,7 +923,7 @@ ntr_emit_alu(struct ntr_compile *c, nir_alu_instr *instr)
          break;
 
       case nir_op_fmod:
-         unreachable("should be handled by .lower_fmod = true");
+         UNREACHABLE("should be handled by .lower_fmod = true");
          break;
 
       case nir_op_fpow:
@@ -951,11 +951,11 @@ ntr_emit_alu(struct ntr_compile *c, nir_alu_instr *instr)
       case nir_op_vec4:
       case nir_op_vec3:
       case nir_op_vec2:
-         unreachable("covered by nir_lower_vec_to_movs()");
+         UNREACHABLE("covered by nir_lower_vec_to_movs()");
 
       default:
          fprintf(stderr, "Unknown NIR opcode: %s\n", nir_op_infos[instr->op].name);
-         unreachable("Unknown NIR opcode");
+         UNREACHABLE("Unknown NIR opcode");
       }
    }
 
@@ -1106,13 +1106,13 @@ ntr_emit_load_input(struct ntr_compile *c, nir_intrinsic_instr *instr)
          break;
 
       default:
-         unreachable("bad barycentric interp intrinsic\n");
+         UNREACHABLE("bad barycentric interp intrinsic\n");
       }
       break;
    }
 
    default:
-      unreachable("bad load input intrinsic\n");
+      UNREACHABLE("bad load input intrinsic\n");
    }
 }
 
@@ -1382,7 +1382,7 @@ ntr_emit_texture(struct ntr_compile *c, nir_tex_instr *instr)
       tex_opcode = TGSI_OPCODE_TXQS;
       break;
    default:
-      unreachable("unsupported tex op");
+      UNREACHABLE("unsupported tex op");
    }
 
    struct ntr_tex_operand_state s = {.i = 0};
@@ -1438,7 +1438,7 @@ ntr_emit_texture(struct ntr_compile *c, nir_tex_instr *instr)
       tex_type = TGSI_RETURN_TYPE_UINT;
       break;
    default:
-      unreachable("unknown texture type");
+      UNREACHABLE("unknown texture type");
    }
 
    struct ureg_dst tex_dst;
@@ -1592,7 +1592,7 @@ ntr_emit_block(struct ntr_compile *c, nir_block *block)
          fprintf(stderr, "Emitted ureg insn during: ");
          nir_print_instr(instr, stderr);
          fprintf(stderr, "\n");
-         unreachable("emitted ureg insn");
+         UNREACHABLE("emitted ureg insn");
       }
    }
 
@@ -1626,7 +1626,7 @@ ntr_emit_cf_list(struct ntr_compile *c, struct exec_list *list)
          break;
 
       default:
-         unreachable("unknown CF type");
+         UNREACHABLE("unknown CF type");
       }
    }
 }
@@ -1725,7 +1725,7 @@ ntr_emit_cf_list_ureg(struct ntr_compile *c, struct exec_list *list)
          break;
 
       default:
-         unreachable("unknown CF type");
+         UNREACHABLE("unknown CF type");
       }
    }
 }
diff --git a/src/gallium/drivers/r600/r600_gpu_load.c b/src/gallium/drivers/r600/r600_gpu_load.c
index a67b64c39547e..19415abb7799d 100644
--- a/src/gallium/drivers/r600/r600_gpu_load.c
+++ b/src/gallium/drivers/r600/r600_gpu_load.c
@@ -228,7 +228,7 @@ static unsigned busy_index_from_type(struct r600_common_screen *rscreen,
 	case R600_QUERY_GPU_SCRATCH_RAM_BUSY:
 		return BUSY_INDEX(rscreen, scratch_ram);
 	default:
-		unreachable("invalid query type");
+		UNREACHABLE("invalid query type");
 	}
 }
 
diff --git a/src/gallium/drivers/r600/r600_query.c b/src/gallium/drivers/r600/r600_query.c
index 2840665d7cd2d..17f661a11f2af 100644
--- a/src/gallium/drivers/r600/r600_query.c
+++ b/src/gallium/drivers/r600/r600_query.c
@@ -67,7 +67,7 @@ static enum radeon_value_id winsys_id_from_type(unsigned type)
 	case R600_QUERY_CURRENT_GPU_SCLK: return RADEON_CURRENT_SCLK;
 	case R600_QUERY_CURRENT_GPU_MCLK: return RADEON_CURRENT_MCLK;
 	case R600_QUERY_CS_THREAD_BUSY: return RADEON_CS_THREAD_TIME;
-	default: unreachable("query type does not correspond to winsys id");
+	default: UNREACHABLE("query type does not correspond to winsys id");
 	}
 }
 
@@ -215,7 +215,7 @@ static bool r600_query_sw_begin(struct r600_common_context *rctx,
 	case R600_QUERY_GPIN_NUM_SE:
 		break;
 	default:
-		unreachable("r600_query_sw_begin: bad query type");
+		UNREACHABLE("r600_query_sw_begin: bad query type");
 	}
 
 	return true;
@@ -367,7 +367,7 @@ static bool r600_query_sw_end(struct r600_common_context *rctx,
 	case R600_QUERY_GPIN_NUM_SE:
 		break;
 	default:
-		unreachable("r600_query_sw_end: bad query type");
+		UNREACHABLE("r600_query_sw_end: bad query type");
 	}
 
 	return true;
@@ -1134,7 +1134,7 @@ static void r600_get_hw_query_params(struct r600_common_context *rctx,
 		break;
 	}
 	default:
-		unreachable("r600_get_hw_query_params unsupported");
+		UNREACHABLE("r600_get_hw_query_params unsupported");
 	}
 }
 
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index f926b7c13dac6..cf0291ea66fe8 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -885,7 +885,7 @@ r600_shader_precompile_key(const struct pipe_context *ctx,
 		break;
 
 	default:
-		unreachable("bad shader stage");
+		UNREACHABLE("bad shader stage");
 		break;
 	}
 }
@@ -984,7 +984,7 @@ static void *r600_create_shader_state(struct pipe_context *ctx,
 	else if (state->type == PIPE_SHADER_IR_NIR) {
 		sel = r600_create_shader_state_tokens(ctx, state->ir.nir, state->type, pipe_shader_type);
 	} else
-		unreachable("Unknown shader type");
+		UNREACHABLE("Unknown shader type");
 	
 	sel->so = state->stream_output;
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_alu_readport_validation.cpp b/src/gallium/drivers/r600/sfn/sfn_alu_readport_validation.cpp
index 92cff72f58d65..6dbf7526f6256 100644
--- a/src/gallium/drivers/r600/sfn/sfn_alu_readport_validation.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_alu_readport_validation.cpp
@@ -247,7 +247,7 @@ void
 ReserveReadport::visit(const LocalArray& value)
 {
    (void)value;
-   unreachable("a full array is not available here");
+   UNREACHABLE("a full array is not available here");
 }
 
 void
diff --git a/src/gallium/drivers/r600/sfn/sfn_assembler.cpp b/src/gallium/drivers/r600/sfn/sfn_assembler.cpp
index 0a48906ce9340..d22073b180404 100644
--- a/src/gallium/drivers/r600/sfn/sfn_assembler.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_assembler.cpp
@@ -222,7 +222,7 @@ AssamblerVisitor::emit_lds_op(const AluInstr& lds)
       break;
    default:
       std::cerr << "\n R600: error op: " << lds << "\n";
-      unreachable("Unhandled LDS op");
+      UNREACHABLE("Unhandled LDS op");
    }
 
    copy_src(alu.src[0], lds.src(0));
@@ -329,7 +329,7 @@ AssamblerVisitor::emit_alu_op(const AluInstr& ai)
             case 1: kcache_index_mode = bim_zero; break;
             case 2: kcache_index_mode = bim_one; break;
             default:
-               unreachable("Unsupported index mode");
+               UNREACHABLE("Unsupported index mode");
             }
          } else {
             kcache_index_mode = bim_zero;
@@ -955,7 +955,7 @@ AssamblerVisitor::visit(const ControlFlowInstr& instr)
       }
    } break;
    default:
-      unreachable("Unknown CF instruction type");
+      UNREACHABLE("Unknown CF instruction type");
    }
 }
 
@@ -1013,14 +1013,14 @@ void
 AssamblerVisitor::visit(const LDSAtomicInstr& instr)
 {
    (void)instr;
-   unreachable("LDSAtomicInstr must be lowered to ALUInstr");
+   UNREACHABLE("LDSAtomicInstr must be lowered to ALUInstr");
 }
 
 void
 AssamblerVisitor::visit(const LDSReadInstr& instr)
 {
    (void)instr;
-   unreachable("LDSReadInstr must be lowered to ALUInstr");
+   UNREACHABLE("LDSReadInstr must be lowered to ALUInstr");
 }
 
 EBufferIndexMode
@@ -1247,7 +1247,7 @@ void
 EncodeSourceVisitor::visit(const LocalArray& value)
 {
    (void)value;
-   unreachable("An array can't be a source register");
+   UNREACHABLE("An array can't be a source register");
 }
 
 void
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr.cpp b/src/gallium/drivers/r600/sfn/sfn_instr.cpp
index b7a230d9ba150..efacd17119fe8 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr.cpp
@@ -120,7 +120,7 @@ sel_and_szw_from_string(const std::string& str, RegisterVec4::Swizzle& swz, bool
          swz[i] = 7;
          break;
       default:
-         unreachable("Unknown swizzle character");
+         UNREACHABLE("Unknown swizzle character");
       }
       ++istr;
       ++i;
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr.h b/src/gallium/drivers/r600/sfn/sfn_instr.h
index 32e5a05a6ba5f..1590f9b59191a 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr.h
+++ b/src/gallium/drivers/r600/sfn/sfn_instr.h
@@ -121,7 +121,7 @@ public:
    virtual void update_indirect_addr(PRegister old_reg, PRegister addr) {
       (void)old_reg;
       (void)addr;
-      unreachable("Instruction type has no indirect address");
+      UNREACHABLE("Instruction type has no indirect address");
    };
    const InstrList& required_instr() const { return m_required_instr; }
 
@@ -302,7 +302,7 @@ public:
       case 2:
          return bim_one;
       default:
-         unreachable("Invalid resource offset, scheduler must substitute registers");
+         UNREACHABLE("Invalid resource offset, scheduler must substitute registers");
       }
    }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
index e94a5a4434601..56b7287fe0b7e 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_alu.cpp
@@ -335,7 +335,7 @@ public:
    void visit(LocalArray& value) override
    {
       (void)value;
-      unreachable("An array can't be used as address");
+      UNREACHABLE("An array can't be used as address");
    }
    void visit(LocalArrayValue& value) override;
    void visit(UniformValue& value) override;
@@ -734,7 +734,7 @@ public:
    void visit(const LocalArray& value)
    {
       (void)value;
-      unreachable("An array can't be used as address");
+      UNREACHABLE("An array can't be used as address");
    }
    void visit(const LocalArrayValue& value);
    void visit(const UniformValue& value);
@@ -862,7 +862,7 @@ AluInstr::split(ValueFactory& vf)
       if (!group->add_instruction(instr)) {
          std::cerr << "Unable to schedule '" << *instr << "' into\n" << *group << "\n";
 
-         unreachable("Invalid group instruction");
+         UNREACHABLE("Invalid group instruction");
       }
    }
    group->set_blockid(block_id(), index());
@@ -1036,7 +1036,7 @@ AluInstr::from_string(istream& is, ValueFactory& value_factory, AluGroup *group,
 
          if (op_descr.nsrc == -1) {
             std::cerr << "'" << opstr << "'";
-            unreachable("Unknown opcode");
+            UNREACHABLE("Unknown opcode");
             return nullptr;
          }
       } else {
@@ -1055,7 +1055,7 @@ AluInstr::from_string(istream& is, ValueFactory& value_factory, AluGroup *group,
 
          if (op_descr.nsrc == -1) {
             std::cerr << "'" << opstr << "'";
-            unreachable("Unknown opcode");
+            UNREACHABLE("Unknown opcode");
             return nullptr;
          }
       } else {
@@ -1156,7 +1156,7 @@ AluInstr::from_string(istream& is, ValueFactory& value_factory, AluGroup *group,
             bank_swizzle = alu_vec_210;
          else {
             std::cerr << "'" << bs << "': ";
-            unreachable("Unknowe bankswizzle given");
+            UNREACHABLE("Unknowe bankswizzle given");
          }
       } break;
 
@@ -1178,7 +1178,7 @@ AluInstr::from_string(istream& is, ValueFactory& value_factory, AluGroup *group,
             cf = cf_alu_else_after;
          else {
             std::cerr << " '" << cf_str << "' ";
-            unreachable("Unknown tocken in ALU instruction");
+            UNREACHABLE("Unknown tocken in ALU instruction");
          }
       }
       }
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_alugroup.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_alugroup.cpp
index 7e9618cb79b3a..0b0f29c5ff966 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_alugroup.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_alugroup.cpp
@@ -234,7 +234,7 @@ void AluGroup::update_readport_reserver()
          ++bs;
       }
       if (bs == alu_vec_unknown)
-         unreachable("Bank swizzle should have been checked before");
+         UNREACHABLE("Bank swizzle should have been checked before");
    }
 
    if (s_max_slots == 5 && m_slots[4]) {
@@ -248,7 +248,7 @@ void AluGroup::update_readport_reserver()
          ++bs;
       }
       if (bs == sq_alu_scl_unknown)
-         unreachable("Bank swizzle should have been checked before");
+         UNREACHABLE("Bank swizzle should have been checked before");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_controlflow.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_controlflow.cpp
index a98338cb96450..67836341dd017 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_controlflow.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_controlflow.cpp
@@ -66,7 +66,7 @@ ControlFlowInstr::do_print(std::ostream& os) const
       os << "WAIT_ACK";
       break;
    default:
-      unreachable("Unknown CF type");
+      UNREACHABLE("Unknown CF type");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_export.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_export.cpp
index 0deb4a1323316..5753df822ba2f 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_export.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_export.cpp
@@ -133,7 +133,7 @@ ExportInstr::from_string_impl(std::istream& is, ValueFactory& vf)
    else if (typestr == "PIXEL")
       type = ExportInstr::pixel;
    else
-      unreachable("Unknown export type");
+      UNREACHABLE("Unknown export type");
 
    RegisterVec4 value = vf.src_vec4_from_string(value_str);
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_fetch.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_fetch.cpp
index 86fd6bba91e57..98fc94f893ec6 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_fetch.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_fetch.cpp
@@ -58,7 +58,7 @@ FetchInstr::FetchInstr(EVFetchInstr opcode,
       m_opname = "READ_SCRATCH";
       break;
    default:
-      unreachable("Unknown fetch instruction");
+      UNREACHABLE("Unknown fetch instruction");
    }
 
    if (m_src)
@@ -184,7 +184,7 @@ FetchInstr::do_print(std::ostream& os) const
          os << " NO_IDX_OFFSET";
          break;
       default:
-         unreachable("Unknown fetch instruction type");
+         UNREACHABLE("Unknown fetch instruction type");
       }
    }
 
@@ -194,7 +194,7 @@ FetchInstr::do_print(std::ostream& os) const
       if (fmt != s_data_format_map.end())
          os << fmt->second << ",";
       else
-         unreachable("unknown data format");
+         UNREACHABLE("unknown data format");
 
       if (m_tex_flags.test(format_comp_signed))
          os << "S";
@@ -212,7 +212,7 @@ FetchInstr::do_print(std::ostream& os) const
          os << "SCALED";
          break;
       default:
-         unreachable("Unknown number format");
+         UNREACHABLE("Unknown number format");
       }
 
       os << ")";
@@ -360,7 +360,7 @@ FetchInstr::from_string_impl(std::istream& is, EVFetchInstr opcode, ValueFactory
       num_fmt = vtx_nf_scaled;
    else {
       std::cerr << "Number format: '" << num_format_str << "' : ";
-      unreachable("Unknown number format");
+      UNREACHABLE("Unknown number format");
    }
 
    auto fetch = new FetchInstr(opcode,
@@ -407,7 +407,7 @@ FetchInstr::set_param_from_string(const std::string& token)
       set_element_size(int_from_string_with_prefix(token, "ES:"));
    else {
       std::cerr << "Token '" << token << "': ";
-      unreachable("Unknown token in fetch param list");
+      UNREACHABLE("Unknown token in fetch param list");
    }
 }
 
@@ -419,7 +419,7 @@ FetchInstr::set_flag_from_string(const std::string& token)
       set_fetch_flag(flag->second);
    else {
       std::cerr << "Token: " << token << " : ";
-      unreachable("Unknown token in fetch flag list");
+      UNREACHABLE("Unknown token in fetch flag list");
    }
 }
 
@@ -636,18 +636,18 @@ public:
    }
    void visit(LocalArray& value)
    {
-      unreachable("An array can't be a direct source for scratch reads");
+      UNREACHABLE("An array can't be a direct source for scratch reads");
       (void)value;
    }
    void visit(LocalArrayValue& value)
    {
-      unreachable("An array value can't be a direct source for scratch reads");
+      UNREACHABLE("An array value can't be a direct source for scratch reads");
       // TODO: an array element with constant offset could be used here
       (void)value;
    }
    void visit(UniformValue& value)
    {
-      unreachable("A uniform can't be a direct source for scratch reads");
+      UNREACHABLE("A uniform can't be a direct source for scratch reads");
       (void)value;
    }
    void visit(LiteralConstant& value)
@@ -660,7 +660,7 @@ public:
       if (value.sel() == ALU_SRC_1_INT)
          m_lfs->set_array_base(1);
       else if (value.sel() != ALU_SRC_0)
-         unreachable("Scratch array base is an impossible inline constant");
+         UNREACHABLE("Scratch array base is an impossible inline constant");
 
       m_lfs->set_src(new Register(0, 7, pin_none));
    }
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_lds.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_lds.cpp
index d9e9e319fc55b..7a6cee4fd92e5 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_lds.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_lds.cpp
@@ -135,7 +135,7 @@ LDSReadInstr::split(std::vector<AluInstr *>& out_block, AluInstr *last_lds_instr
 bool
 LDSReadInstr::do_ready() const
 {
-   unreachable("This instruction is not handled by the scheduler");
+   UNREACHABLE("This instruction is not handled by the scheduler");
    return false;
 }
 
@@ -383,7 +383,7 @@ LDSAtomicInstr::replace_source(PRegister old_src, PVirtualValue new_src)
 bool
 LDSAtomicInstr::do_ready() const
 {
-   unreachable("This instruction is not handled by the scheduler");
+   UNREACHABLE("This instruction is not handled by the scheduler");
    return false;
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_mem.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_mem.cpp
index 7e558b831110a..6249a051c8e30 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_mem.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_mem.cpp
@@ -462,7 +462,7 @@ get_rat_opcode(const nir_atomic_op opcode)
    case nir_atomic_op_dec_wrap:
       return RatInstr::WRAP_DEC_RTN;
    default:
-      unreachable("Unsupported atomic");
+      UNREACHABLE("Unsupported atomic");
    }
 }
 
@@ -491,7 +491,7 @@ get_rat_opcode_wo(const nir_atomic_op opcode)
    case nir_atomic_op_xchg:
       return RatInstr::XCHG_RTN;
    default:
-      unreachable("Unsupported atomic");
+      UNREACHABLE("Unsupported atomic");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_instr_tex.cpp b/src/gallium/drivers/r600/sfn/sfn_instr_tex.cpp
index 180f34b3c4487..74c662365c194 100644
--- a/src/gallium/drivers/r600/sfn/sfn_instr_tex.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_instr_tex.cpp
@@ -363,7 +363,7 @@ TexInstr::set_tex_param(const std::string& token)
       set_resource_offset(VirtualValue::from_string(token.substr(3))->as_register());
    else {
       std::cerr << "Token '" << token << "': ";
-      unreachable("Unknown token in tex param");
+      UNREACHABLE("Unknown token in tex param");
    }
 }
 
@@ -830,7 +830,7 @@ TexInstr::Inputs::Inputs(const nir_tex_instr& instr, ValueFactory& vf):
       case nir_tex_src_projector:
       case nir_tex_src_min_lod:
       default:
-         unreachable("unsupported texture input type");
+         UNREACHABLE("unsupported texture input type");
       }
    }
 
@@ -867,7 +867,7 @@ TexInstr::Inputs::get_opcode(const nir_tex_instr& instr) -> Opcode
    case nir_texop_texture_samples:
       return TexInstr::get_nsamples;
    default:
-      unreachable("unsupported texture input opcode");
+      UNREACHABLE("unsupported texture input opcode");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_liverangeevaluator.cpp b/src/gallium/drivers/r600/sfn/sfn_liverangeevaluator.cpp
index 5dd6f9c784685..d9a907af403d8 100644
--- a/src/gallium/drivers/r600/sfn/sfn_liverangeevaluator.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_liverangeevaluator.cpp
@@ -365,7 +365,7 @@ LiveRangeInstrVisitor::visit(ControlFlowInstr *instr)
    case ControlFlowInstr::cf_wait_ack:
       break;
    default:
-      unreachable("Flow control unreachanble");
+      UNREACHABLE("Flow control unreachanble");
    }
 }
 
@@ -411,14 +411,14 @@ LiveRangeInstrVisitor::visit(WriteTFInstr *instr)
 void
 LiveRangeInstrVisitor::visit(UNUSED LDSAtomicInstr *instr)
 {
-   unreachable("LDSAtomicInstr must be lowered before scheduling and live "
+   UNREACHABLE("LDSAtomicInstr must be lowered before scheduling and live "
                "range evaluation");
 }
 
 void
 LiveRangeInstrVisitor::visit(UNUSED LDSReadInstr *instr)
 {
-   unreachable("LDSReadInstr must be lowered before scheduling and live "
+   UNREACHABLE("LDSReadInstr must be lowered before scheduling and live "
                "range evaluation");
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_legalize_image_load_store.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_legalize_image_load_store.cpp
index 2f23cee5d7a86..e8ca9667fac2b 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_legalize_image_load_store.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_legalize_image_load_store.cpp
@@ -66,7 +66,7 @@ r600_legalize_image_load_store_impl(nir_builder *b,
          num_components = 3;
          break;
       default:
-         unreachable("Unexpected image size");
+         UNREACHABLE("Unexpected image size");
       }
 
       if (num_components < 3 && nir_intrinsic_image_array(ir))
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp
index df0a74a323401..697808e3c040e 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp
@@ -220,7 +220,7 @@ class LowerSplit64op : public NirLowerInstruction {
             return nir_fadd(b, nir_fmul_imm(b, fhigh, 65536.0 * 65536.0), flow);
          }
          default:
-            unreachable("trying to lower instruction that was not in filter");
+            UNREACHABLE("trying to lower instruction that was not in filter");
          }
       }
       case nir_instr_type_phi: {
@@ -241,7 +241,7 @@ class LowerSplit64op : public NirLowerInstruction {
          return nir_pack_64_2x32_split(b, &phi_lo->def, &phi_hi->def);
       }
       default:
-         unreachable("Trying to lower instruction that was not in filter");
+         UNREACHABLE("Trying to lower instruction that was not in filter");
       }
    }
 };
@@ -349,7 +349,7 @@ LowerSplit64BitVar::split_double_store_deref(nir_intrinsic_instr *intr)
    else if (deref->deref_type == nir_deref_type_array)
       return split_store_deref_array(intr, deref);
    else {
-      unreachable("only splitting of stores to vars and arrays is supported");
+      UNREACHABLE("only splitting of stores to vars and arrays is supported");
    }
 }
 
@@ -362,7 +362,7 @@ LowerSplit64BitVar::split_double_load_deref(nir_intrinsic_instr *intr)
    else if (deref->deref_type == nir_deref_type_array)
       return split_load_deref_array(intr, deref->arr.index);
    else {
-      unreachable("only splitting of loads from vars and arrays is supported");
+      UNREACHABLE("only splitting of loads from vars and arrays is supported");
    }
    m_old_stores.push_back(&intr->instr);
 }
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp
index b1d2049cd24e4..1e30634eb7bef 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp
@@ -50,7 +50,7 @@ Lower2x16::lower(nir_instr *instr)
                                       nir_channel(b, src_vec2, 1));
    }
    default:
-      unreachable("Lower2x16 filter doesn't filter correctly");
+      UNREACHABLE("Lower2x16 filter doesn't filter correctly");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_fs_out_to_vector.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_fs_out_to_vector.cpp
index 80c1c661e01c0..7b04cb08b3735 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_fs_out_to_vector.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_fs_out_to_vector.cpp
@@ -444,7 +444,7 @@ NirLowerFSOutToVector::create_combined_vector(nir_builder *b,
       op = nir_op_vec4;
       break;
    default:
-      unreachable("combined vector must have 2 to 4 components");
+      UNREACHABLE("combined vector must have 2 to 4 components");
    }
    nir_alu_instr *instr = nir_alu_instr_create(b->shader, op);
    instr->exact = b->exact;
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_tess_io.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_tess_io.cpp
index 953c20c812dac..66bf96a2a4264 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_tess_io.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_tess_io.cpp
@@ -142,7 +142,7 @@ load_offset_group(nir_builder *b, int ncomponents)
       return nir_imm_ivec2(b, 16, 20);
    default:
       debug_printf("Got %d components\n", ncomponents);
-      unreachable("Unsupported component count");
+      UNREACHABLE("Unsupported component count");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_scheduler.cpp b/src/gallium/drivers/r600/sfn/sfn_scheduler.cpp
index 483f281f9840f..adbe69c3bdac4 100644
--- a/src/gallium/drivers/r600/sfn/sfn_scheduler.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_scheduler.cpp
@@ -568,7 +568,7 @@ BlockScheduler::schedule_alu(Shader::ShaderBlocks& out_blocks)
                start_new_block(out_blocks, Block::alu);
 
                if (!m_current_block->try_reserve_kcache(*group))
-                  unreachable("Scheduling a group in a new block should always succeed");
+                  UNREACHABLE("Scheduling a group in a new block should always succeed");
                alu_groups_ready.erase(alu_groups_ready.begin());
                sfn_log << SfnLog::schedule << "Schedule ALU group\n";
                success = true;
diff --git a/src/gallium/drivers/r600/sfn/sfn_shader.cpp b/src/gallium/drivers/r600/sfn/sfn_shader.cpp
index 16246d5c9b9bb..194ceef220303 100644
--- a/src/gallium/drivers/r600/sfn/sfn_shader.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_shader.cpp
@@ -979,7 +979,7 @@ lds_op_from_intrinsic(nir_atomic_op op, bool ret)
    case nir_atomic_op_cmpxchg:
       return LDS_CMP_XCHG_RET;
    default:
-      unreachable("Unsupported shared atomic_op opcode");
+      UNREACHABLE("Unsupported shared atomic_op opcode");
    }
 }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_shader_cs.h b/src/gallium/drivers/r600/sfn/sfn_shader_cs.h
index ef04c5ce6b39a..a9454f087ca5a 100644
--- a/src/gallium/drivers/r600/sfn/sfn_shader_cs.h
+++ b/src/gallium/drivers/r600/sfn/sfn_shader_cs.h
@@ -26,11 +26,11 @@ private:
 
    bool load_input(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("compute shaders  have bno inputs");
+      UNREACHABLE("compute shaders  have bno inputs");
    };
    bool store_output(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("compute shaders have no outputs");
+      UNREACHABLE("compute shaders have no outputs");
    };
 
    bool read_prop(std::istream& is) override;
diff --git a/src/gallium/drivers/r600/sfn/sfn_shader_fs.cpp b/src/gallium/drivers/r600/sfn/sfn_shader_fs.cpp
index b04eb7402f0da..2bad1fe25f14a 100644
--- a/src/gallium/drivers/r600/sfn/sfn_shader_fs.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_shader_fs.cpp
@@ -109,7 +109,7 @@ barycentric_ij_index(nir_intrinsic_instr *intr)
       index = 2;
       break;
    default:
-      unreachable("Unknown interpolator intrinsic");
+      UNREACHABLE("Unknown interpolator intrinsic");
    }
 
    switch (nir_intrinsic_interp_mode(intr)) {
@@ -121,7 +121,7 @@ barycentric_ij_index(nir_intrinsic_instr *intr)
    case INTERP_MODE_FLAT:
    case INTERP_MODE_EXPLICIT:
    default:
-      unreachable("unknown/unsupported mode for load_interpolated");
+      UNREACHABLE("unknown/unsupported mode for load_interpolated");
    }
    return 0;
 }
diff --git a/src/gallium/drivers/r600/sfn/sfn_shader_gs.h b/src/gallium/drivers/r600/sfn/sfn_shader_gs.h
index fe3d590c12538..e39f4be649440 100644
--- a/src/gallium/drivers/r600/sfn/sfn_shader_gs.h
+++ b/src/gallium/drivers/r600/sfn/sfn_shader_gs.h
@@ -44,7 +44,7 @@ private:
 
    bool load_input(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("load_input must be lowered in GS");
+      UNREACHABLE("load_input must be lowered in GS");
    };
    bool store_output(nir_intrinsic_instr *instr) override;
    bool emit_vertex(nir_intrinsic_instr *instr, bool cut);
diff --git a/src/gallium/drivers/r600/sfn/sfn_shader_tess.h b/src/gallium/drivers/r600/sfn/sfn_shader_tess.h
index b15366d77e95f..d932bf46c8e7c 100644
--- a/src/gallium/drivers/r600/sfn/sfn_shader_tess.h
+++ b/src/gallium/drivers/r600/sfn/sfn_shader_tess.h
@@ -27,11 +27,11 @@ private:
 
    bool load_input(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("load_input must be lowered in TCS");
+      UNREACHABLE("load_input must be lowered in TCS");
    };
    bool store_output(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("load_output must be lowered in TCS");
+      UNREACHABLE("load_output must be lowered in TCS");
    };
 
    bool read_prop(std::istream& is) override;
@@ -60,11 +60,11 @@ private:
 
    bool load_input(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("load_input must be lowered in TES");
+      UNREACHABLE("load_input must be lowered in TES");
    };
    bool store_output(UNUSED nir_intrinsic_instr *intr) override
    {
-      unreachable("load_output must be lowered in TES");
+      UNREACHABLE("load_output must be lowered in TES");
    };
 
    bool read_prop(std::istream& is) override;
diff --git a/src/gallium/drivers/r600/sfn/sfn_split_address_loads.cpp b/src/gallium/drivers/r600/sfn/sfn_split_address_loads.cpp
index 10ba14eb66bbd..71588b387e9b3 100644
--- a/src/gallium/drivers/r600/sfn/sfn_split_address_loads.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_split_address_loads.cpp
@@ -91,7 +91,7 @@ public:
       for (auto p : r.parents())
          add_dep(p);
    }
-   void visit(const LocalArray& value) override {(void)value; unreachable("Array is not a value");}
+   void visit(const LocalArray& value) override {(void)value; UNREACHABLE("Array is not a value");}
    void visit(const LocalArrayValue& r) override
    {
       auto& a = r.array();
diff --git a/src/gallium/drivers/r600/sfn/sfn_valuefactory.cpp b/src/gallium/drivers/r600/sfn/sfn_valuefactory.cpp
index a718b2099d01e..48be9cd8d86ed 100644
--- a/src/gallium/drivers/r600/sfn/sfn_valuefactory.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_valuefactory.cpp
@@ -422,7 +422,7 @@ ValueFactory::ssa_src(const nir_def& ssa, int chan)
       return iarray->second;
 
    std::cerr << "Didn't find source with key " << key << "\n";
-   unreachable("Source values should always exist");
+   UNREACHABLE("Source values should always exist");
 }
 
 PVirtualValue
@@ -481,7 +481,7 @@ ValueFactory::src_vec4(const nir_src& source, Pin pin, const RegisterVec4::Swizz
 
    int sel = sx ? sx->sel() : (sy ? sy->sel() : (sz ? sz->sel() : sw ? sw->sel() : -1));
    if (sel < 0)
-      unreachable("source vector without valid components");
+      UNREACHABLE("source vector without valid components");
 
    if (!sx)
       sx = new Register(sel, 7, pin);
@@ -532,7 +532,7 @@ chan_from_char(char chan)
    case '_':
       return 7;
    }
-   unreachable("Unknown swizzle char");
+   UNREACHABLE("Unknown swizzle char");
 }
 
 static int
@@ -585,7 +585,7 @@ split_register_string(const string& s,
          size_str.append(1, s[i]);
          break;
       default:
-         unreachable("Malformed Array allocation string");
+         UNREACHABLE("Malformed Array allocation string");
       }
    }
    return true;
@@ -647,7 +647,7 @@ ValueFactory::dest_from_string(const std::string& s)
       pool = vp_ssa;
       break;
    default:
-      unreachable("Unknown value type");
+      UNREACHABLE("Unknown value type");
    }
 
    bool is_ssa = s[0] == 'S';
@@ -719,7 +719,7 @@ ValueFactory::src_from_string(const std::string& s)
 
    default:
       std::cerr << "'" << s << "'";
-      unreachable("Unknown register type");
+      UNREACHABLE("Unknown register type");
    }
 
    assert(strchr("ARS_", s[0]));
@@ -757,7 +757,7 @@ ValueFactory::src_from_string(const std::string& s)
       pool = vp_ssa;
       break;
    default:
-      unreachable("Unknown value type");
+      UNREACHABLE("Unknown value type");
    }
 
    RegisterKey key(sel, chan, pool);
@@ -782,7 +782,7 @@ ValueFactory::src_from_string(const std::string& s)
    } else {
       if (sel != std::numeric_limits<int>::max()) {
          std::cerr << "register " << key << "not found \n";
-         unreachable("Source register should exist");
+         UNREACHABLE("Source register should exist");
       } else {
          auto reg = new Register(sel, chan, p);
          m_registers[key] = reg;
@@ -900,7 +900,7 @@ ValueFactory::array_from_string(const std::string& s)
          size_str.append(1, s[i]);
          break;
       default:
-         unreachable("Malformed Array allocation string");
+         UNREACHABLE("Malformed Array allocation string");
       }
    }
 
diff --git a/src/gallium/drivers/r600/sfn/sfn_virtualvalues.cpp b/src/gallium/drivers/r600/sfn/sfn_virtualvalues.cpp
index 265de415d0044..305f08cdd7014 100644
--- a/src/gallium/drivers/r600/sfn/sfn_virtualvalues.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_virtualvalues.cpp
@@ -125,7 +125,7 @@ VirtualValue::from_string(const std::string& s)
 
    default:
       std::cerr << "'" << s << "'";
-      unreachable("Unknown register type");
+      UNREACHABLE("Unknown register type");
    }
 }
 
@@ -249,7 +249,7 @@ Register::print(std::ostream& os) const
       case AddressRegister::idx0: os << "IDX0"; break;
       case AddressRegister::idx1: os << "IDX1"; break;
       default:
-         unreachable("Wrong address ID");
+         UNREACHABLE("Wrong address ID");
       }
       return;
    }
@@ -308,7 +308,7 @@ Register::from_string(const std::string& s)
          pinstr.append(1, s[i]);
          break;
       default:
-         unreachable("Malformed register string");
+         UNREACHABLE("Malformed register string");
       }
    }
 
@@ -598,7 +598,7 @@ InlineConstant::print(std::ostream& os) const
    } else if (sel() >= ALU_SRC_PARAM_BASE && sel() < ALU_SRC_PARAM_BASE + 32) {
       os << "Param" << sel() - ALU_SRC_PARAM_BASE << "." << chanchar[chan()];
    } else {
-      unreachable("Unknown inline constant");
+      UNREACHABLE("Unknown inline constant");
    }
 }
 
@@ -703,7 +703,7 @@ InlineConstant::param_from_string(const std::string& s)
       chan = 3;
       break;
    default:
-      unreachable("unsupported channel char");
+      UNREACHABLE("unsupported channel char");
    }
 
    return new InlineConstant(ALU_SRC_PARAM_BASE + param, chan);
@@ -829,7 +829,7 @@ UniformValue::from_string(const std::string& s, ValueFactory *factory)
       chan = 3;
       break;
    default:
-      unreachable("Unknown channel when reading uniform");
+      UNREACHABLE("Unknown channel when reading uniform");
    }
    if (bufid)
       return new UniformValue(index + 512, chan, bufid, bank);
@@ -912,7 +912,7 @@ LocalArray::element(size_t offset, PVirtualValue indirect, uint32_t chan)
          void visit(const LocalArray& value)
          {
             (void)value;
-            unreachable("An array can't be used as address");
+            UNREACHABLE("An array can't be used as address");
          }
          void visit(const LocalArrayValue& value) { (void)value; }
          void visit(const UniformValue& value) { (void)value; }
diff --git a/src/gallium/drivers/r600/sfn/sfn_virtualvalues.h b/src/gallium/drivers/r600/sfn/sfn_virtualvalues.h
index f43d3406dc2fa..bff28ae9a57c2 100644
--- a/src/gallium/drivers/r600/sfn/sfn_virtualvalues.h
+++ b/src/gallium/drivers/r600/sfn/sfn_virtualvalues.h
@@ -217,8 +217,8 @@ public:
    }
 
 protected:
-   void do_set_chan(UNUSED int c) { unreachable("Address registers must have chan 0");}
-   void set_sel_internal(UNUSED int sel) {unreachable("Address registers don't support sel override");}
+   void do_set_chan(UNUSED int c) { UNREACHABLE("Address registers must have chan 0");}
+   void set_sel_internal(UNUSED int sel) {UNREACHABLE("Address registers don't support sel override");}
 };
 
 
diff --git a/src/gallium/drivers/radeonsi/gfx11_query.c b/src/gallium/drivers/radeonsi/gfx11_query.c
index 0e9ce841b68da..20558ba875e51 100644
--- a/src/gallium/drivers/radeonsi/gfx11_query.c
+++ b/src/gallium/drivers/radeonsi/gfx11_query.c
@@ -312,7 +312,7 @@ static void gfx11_sh_query_get_result_resource(struct si_context *sctx, struct s
          consts.config = 3;
          break;
       default:
-         unreachable("bad query type");
+         UNREACHABLE("bad query type");
       }
    } else {
       /* Check result availability. */
diff --git a/src/gallium/drivers/radeonsi/si_blit.c b/src/gallium/drivers/radeonsi/si_blit.c
index d84f02acb8097..dd244ca646140 100644
--- a/src/gallium/drivers/radeonsi/si_blit.c
+++ b/src/gallium/drivers/radeonsi/si_blit.c
@@ -1141,7 +1141,7 @@ bool si_msaa_resolve_blit_via_CB(struct pipe_context *ctx, const struct pipe_bli
          break;
 
       default:
-         unreachable("unexpected gfx version");
+         UNREACHABLE("unexpected gfx version");
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index 939c646cc202b..c60aeda7d5c27 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -1422,7 +1422,7 @@ void si_set_ring_buffer(struct si_context *sctx, uint slot, struct pipe_resource
 
       switch (element_size) {
       default:
-         unreachable("Unsupported ring buffer element size");
+         UNREACHABLE("Unsupported ring buffer element size");
       case 0:
       case 2:
          element_size = 0;
@@ -1440,7 +1440,7 @@ void si_set_ring_buffer(struct si_context *sctx, uint slot, struct pipe_resource
 
       switch (index_stride) {
       default:
-         unreachable("Unsupported ring buffer index stride");
+         UNREACHABLE("Unsupported ring buffer index stride");
       case 0:
       case 8:
          index_stride = 0;
diff --git a/src/gallium/drivers/radeonsi/si_fence.c b/src/gallium/drivers/radeonsi/si_fence.c
index ebfb3c6e04a13..16fd0bc84b08b 100644
--- a/src/gallium/drivers/radeonsi/si_fence.c
+++ b/src/gallium/drivers/radeonsi/si_fence.c
@@ -388,7 +388,7 @@ static void si_create_fence_fd(struct pipe_context *ctx, struct pipe_fence_handl
       break;
 
    default:
-      unreachable("bad fence fd type when importing");
+      UNREACHABLE("bad fence fd type when importing");
    }
 
 finish:
diff --git a/src/gallium/drivers/radeonsi/si_gpu_load.c b/src/gallium/drivers/radeonsi/si_gpu_load.c
index 44ca948ad2027..f3004d51ab79b 100644
--- a/src/gallium/drivers/radeonsi/si_gpu_load.c
+++ b/src/gallium/drivers/radeonsi/si_gpu_load.c
@@ -242,7 +242,7 @@ static unsigned busy_index_from_type(struct si_screen *sscreen, unsigned type)
    case SI_QUERY_GPU_SCRATCH_RAM_BUSY:
       return BUSY_INDEX(sscreen, scratch_ram);
    default:
-      unreachable("invalid query type");
+      UNREACHABLE("invalid query type");
    }
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 669925542a2cd..086dfb63307f3 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -287,7 +287,7 @@ static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_s
             replacement = nir_iadd_nuw(b, nir_ishl_imm(b, num_ls_out, 4), extra_dw);
          }
       } else {
-         unreachable("no nir_load_lshs_vertex_stride_amd");
+         UNREACHABLE("no nir_load_lshs_vertex_stride_amd");
       }
       break;
    case nir_intrinsic_load_esgs_vertex_stride_amd:
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_ps_color_inputs.c b/src/gallium/drivers/radeonsi/si_nir_lower_ps_color_inputs.c
index bc6d090c82370..0bb64eb604f0d 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_ps_color_inputs.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_ps_color_inputs.c
@@ -70,7 +70,7 @@ bool si_nir_lower_ps_color_inputs(nir_shader *nir, const union si_shader_key *ke
             op = nir_intrinsic_load_barycentric_sample;
             break;
          default:
-            unreachable("invalid color interpolate location");
+            UNREACHABLE("invalid color interpolate location");
             break;
          }
 
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_resource.c b/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
index d78abe4bee627..735b947076144 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_resource.c
@@ -424,7 +424,7 @@ static nir_def *load_sampler_desc(nir_builder *b, nir_def *list, nir_def *index,
       num_channels = 4;
       break;
    default:
-      unreachable("invalid desc type");
+      UNREACHABLE("invalid desc type");
       break;
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_vs_inputs.c b/src/gallium/drivers/radeonsi/si_nir_lower_vs_inputs.c
index bdfe0be1be140..2154427119896 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_vs_inputs.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_vs_inputs.c
@@ -338,7 +338,7 @@ opencoded_load_format(nir_builder *b, nir_def *rsrc, nir_def *vindex,
          break;
       }
       default:
-         unreachable("invalid fetch format");
+         UNREACHABLE("invalid fetch format");
          break;
       }
    }
@@ -396,7 +396,7 @@ opencoded_load_format(nir_builder *b, nir_def *rsrc, nir_def *vindex,
       }
       break;
    default:
-      unreachable("invalid fetch format");
+      UNREACHABLE("invalid fetch format");
       break;
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index a6f75f74a8016..adb135222dad5 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -725,7 +725,7 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
          si_init_draw_functions_GFX12(sctx);
          break;
       default:
-         unreachable("unhandled gfx level");
+         UNREACHABLE("unhandled gfx level");
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_query.c b/src/gallium/drivers/radeonsi/si_query.c
index 78bc8daa31ab1..8a5ac817f3f5e 100644
--- a/src/gallium/drivers/radeonsi/si_query.c
+++ b/src/gallium/drivers/radeonsi/si_query.c
@@ -95,7 +95,7 @@ static enum radeon_value_id winsys_id_from_type(unsigned type)
    case SI_QUERY_CS_THREAD_BUSY:
       return RADEON_CS_THREAD_TIME;
    default:
-      unreachable("query type does not correspond to winsys id");
+      UNREACHABLE("query type does not correspond to winsys id");
    }
 }
 
@@ -247,7 +247,7 @@ static bool si_query_sw_begin(struct si_context *sctx, struct si_query *squery)
    case SI_QUERY_GPIN_NUM_SE:
       break;
    default:
-      unreachable("si_query_sw_begin: bad query type");
+      UNREACHABLE("si_query_sw_begin: bad query type");
    }
 
    return true;
@@ -404,7 +404,7 @@ static bool si_query_sw_end(struct si_context *sctx, struct si_query *squery)
    case SI_QUERY_GPIN_NUM_SE:
       break;
    default:
-      unreachable("si_query_sw_end: bad query type");
+      UNREACHABLE("si_query_sw_end: bad query type");
    }
 
    return true;
@@ -1339,7 +1339,7 @@ static void si_get_hw_query_result_shader_params(struct si_context *sctx,
       break;
    }
    default:
-      unreachable("si_get_hw_query_params unsupported");
+      UNREACHABLE("si_get_hw_query_params unsupported");
    }
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index c4b21e4c8d49e..0902dec18cca5 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -703,7 +703,7 @@ void si_shader_dump_stats_for_shader_db(struct si_screen *screen, struct si_shad
                shader->selector->stage == MESA_SHADER_TESS_EVAL)
          num_vs_outputs = shader->info.nr_param_exports;
       else
-         unreachable("invalid shader key");
+         UNREACHABLE("invalid shader key");
    } else if (shader->selector->stage == MESA_SHADER_FRAGMENT) {
       num_ps_outputs = util_bitcount(shader->selector->info.colors_written) +
                        (shader->info.writes_z ||
diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 1cccfd7b060f6..3d0a918048203 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -212,7 +212,7 @@ si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code_for_write,
          value = code_for_read[symbols[i].offset] + const_offset;
          break;
       default:
-         unreachable("invalid aco symbol");
+         UNREACHABLE("invalid aco symbol");
          break;
       }
 
@@ -345,7 +345,7 @@ si_aco_build_shader_part(struct si_screen *screen, gl_shader_stage stage, bool p
       else
          return si_aco_build_ps_epilog(&options, result);
    default:
-      unreachable("bad shader part");
+      UNREACHABLE("bad shader part");
    }
 
    return false;
diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index ca1e25de901fe..1ba550bec53fd 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -350,7 +350,7 @@ static void scan_instruction(const struct nir_shader *nir, struct si_shader_info
       case nir_intrinsic_interp_deref_at_centroid:
       case nir_intrinsic_interp_deref_at_sample:
       case nir_intrinsic_interp_deref_at_offset:
-         unreachable("these opcodes should have been lowered");
+         UNREACHABLE("these opcodes should have been lowered");
          break;
       case nir_intrinsic_ordered_add_loop_gfx12_amd:
          info->uses_atomic_ordered_add = true;
@@ -458,7 +458,7 @@ void si_nir_scan_shader(struct si_screen *sscreen, struct nir_shader *nir,
       break;
 
    default:
-      unreachable("unexpected shader stage");
+      UNREACHABLE("unexpected shader stage");
    }
 
    /* Get options from shader profiles. */
@@ -695,6 +695,6 @@ si_select_hw_stage(const gl_shader_stage stage, const union si_shader_key *const
    case MESA_SHADER_KERNEL:
       return AC_HW_COMPUTE_SHADER;
    default:
-      unreachable("Unsupported HW stage");
+      UNREACHABLE("Unsupported HW stage");
    }
 }
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 9a25724eb056b..cb183aaa01849 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -160,7 +160,7 @@ void si_llvm_create_func(struct si_shader_context *ctx, const char *name, LLVMTy
       call_conv = AC_LLVM_AMDGPU_CS;
       break;
    default:
-      unreachable("Unhandle shader type");
+      UNREACHABLE("Unhandle shader type");
    }
 
    /* Setup the function */
@@ -415,7 +415,7 @@ static LLVMValueRef si_llvm_load_sampler_desc(struct ac_shader_abi *abi, LLVMVal
          is_vec4 = true;
          break;
       default:
-         unreachable("invalid desc");
+         UNREACHABLE("invalid desc");
       }
 
       struct ac_llvm_pointer list = {
@@ -713,7 +713,7 @@ bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
       }
       break;
    default:
-      unreachable("bad shader part");
+      UNREACHABLE("bad shader part");
    }
 
    struct si_shader_context ctx;
@@ -733,7 +733,7 @@ bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
       build = prolog ? si_llvm_build_ps_prolog : si_llvm_build_ps_epilog;
       break;
    default:
-      unreachable("bad shader part");
+      UNREACHABLE("bad shader part");
    }
 
    build(&ctx, key);
diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index e25afd8d5f3ee..31a795317f2c9 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -383,7 +383,7 @@ void si_finalize_nir(struct pipe_screen *screen, struct nir_shader *nir)
 
    if (nir->info.io_lowered) {
       nir_foreach_variable_with_modes(var, nir, nir_var_shader_in | nir_var_shader_out) {
-         unreachable("no IO variables should be present with lowered IO");
+         UNREACHABLE("no IO variables should be present with lowered IO");
       }
    } else {
       nir_lower_io_passes(nir, false);
diff --git a/src/gallium/drivers/radeonsi/si_sqtt.c b/src/gallium/drivers/radeonsi/si_sqtt.c
index 3a7fa7955ef70..ebbf1cfec5535 100644
--- a/src/gallium/drivers/radeonsi/si_sqtt.c
+++ b/src/gallium/drivers/radeonsi/si_sqtt.c
@@ -725,7 +725,7 @@ si_sqtt_pipe_to_rgp_shader_stage(union si_shader_key *key, enum pipe_shader_type
       case PIPE_SHADER_COMPUTE:
          return RGP_HW_STAGE_CS;
       default:
-         unreachable("invalid mesa shader stage");
+         UNREACHABLE("invalid mesa shader stage");
    }
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 9bbec335e6289..74394e9ac448d 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -2595,7 +2595,7 @@ static void si_set_framebuffer_state(struct pipe_context *ctx,
     * We could implement the full workaround here, but it's a useless case.
     */
    if ((!state->width || !state->height) && (state->nr_cbufs || state->zsbuf.texture)) {
-      unreachable("the framebuffer shouldn't have zero area");
+      UNREACHABLE("the framebuffer shouldn't have zero area");
       return;
    }
 
@@ -3770,7 +3770,7 @@ static void cdna_emu_make_image_descriptor(struct si_screen *screen, struct si_t
       break;
 
    default:
-      unreachable("invalid texture target");
+      UNREACHABLE("invalid texture target");
    }
 
    unsigned stride = desc->block.bits / 8;
@@ -4535,7 +4535,7 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
             break;
          }
          default:
-            unreachable("bad format type");
+            UNREACHABLE("bad format type");
          }
       } else {
          switch (elements[i].src_format) {
@@ -4543,7 +4543,7 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
             fix_fetch.u.format = AC_FETCH_FORMAT_FLOAT;
             break;
          default:
-            unreachable("bad other format");
+            UNREACHABLE("bad other format");
          }
       }
 
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index bd91e23b239b8..5cd38a40ba34f 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -1805,7 +1805,7 @@ void si_set_vertex_buffer_descriptor(struct si_screen *sscreen, struct si_vertex
       si_set_vb_descriptor<GFX12>(velems, vb, element_index, out);
       break;
    default:
-      unreachable("unhandled gfx level");
+      UNREACHABLE("unhandled gfx level");
    }
 }
 
@@ -2636,7 +2636,7 @@ static void si_invalid_draw_vbo(struct pipe_context *pipe,
                                 const struct pipe_draw_start_count_bias *draws,
                                 unsigned num_draws)
 {
-   unreachable("vertex shader not bound");
+   UNREACHABLE("vertex shader not bound");
 }
 
 static void si_invalid_draw_vertex_state(struct pipe_context *ctx,
@@ -2646,7 +2646,7 @@ static void si_invalid_draw_vertex_state(struct pipe_context *ctx,
                                          const struct pipe_draw_start_count_bias *draws,
                                          unsigned num_draws)
 {
-   unreachable("vertex shader not bound");
+   UNREACHABLE("vertex shader not bound");
 }
 
 extern "C"
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 345ce218ee8eb..a738ebb20f5b7 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -814,7 +814,7 @@ static void si_shader_es(struct si_screen *sscreen, struct si_shader *shader)
       vgpr_comp_cnt = shader->selector->info.uses_primid ? 3 : 2;
       num_user_sgprs = SI_TES_NUM_USER_SGPR;
    } else
-      unreachable("invalid shader selector type");
+      UNREACHABLE("invalid shader selector type");
 
    oc_lds_en = shader->selector->stage == MESA_SHADER_TESS_EVAL ? 1 : 0;
 
@@ -996,7 +996,7 @@ static void si_shader_gs(struct si_screen *sscreen, struct si_shader *shader)
       } else if (es_stage == MESA_SHADER_TESS_EVAL)
          es_vgpr_comp_cnt = shader->key.ge.part.gs.es->info.uses_primid ? 3 : 2;
       else
-         unreachable("invalid shader selector type");
+         UNREACHABLE("invalid shader selector type");
 
       /* If offsets 4, 5 are used, GS_VGPR_COMP_CNT is ignored and
        * VGPR[0:4] are always loaded.
@@ -1342,7 +1342,7 @@ unsigned si_get_num_vertices_per_output_prim(struct si_shader *shader)
    case MESA_PRIM_UNKNOWN:
       return 0;
    default:
-      unreachable("unexpected prim type");
+      UNREACHABLE("unexpected prim type");
    }
 }
 
@@ -1809,7 +1809,7 @@ static void si_shader_vs(struct si_screen *sscreen, struct si_shader *shader,
       vgpr_comp_cnt = enable_prim_id ? 3 : 2;
       num_user_sgprs = SI_TES_NUM_USER_SGPR;
    } else
-      unreachable("invalid shader selector type");
+      UNREACHABLE("invalid shader selector type");
 
    /* VS is required to export at least one param. */
    nparams = MAX2(shader->info.nr_param_exports, 1);
diff --git a/src/gallium/drivers/radeonsi/si_test_image_copy_region.c b/src/gallium/drivers/radeonsi/si_test_image_copy_region.c
index 1d458f9ede896..c375165230c22 100644
--- a/src/gallium/drivers/radeonsi/si_test_image_copy_region.c
+++ b/src/gallium/drivers/radeonsi/si_test_image_copy_region.c
@@ -350,7 +350,7 @@ static void set_random_image_attrs(struct pipe_resource *templ, bool allow_msaa,
       templ->nr_samples = 2 << (rand() % 3);
       break;
    default:
-      unreachable("invalid path");
+      UNREACHABLE("invalid path");
    }
 
    templ->usage = PIPE_USAGE_DEFAULT;
diff --git a/src/gallium/drivers/rocket/rkt_ml.c b/src/gallium/drivers/rocket/rkt_ml.c
index 129f76f7a432f..1f616df116d64 100644
--- a/src/gallium/drivers/rocket/rkt_ml.c
+++ b/src/gallium/drivers/rocket/rkt_ml.c
@@ -243,7 +243,7 @@ count_tensors(const struct pipe_ml_operation *poperations,
          break;
       default:
          DBG("poperation->type %d\n", poperation->type);
-         unreachable("Unsupported ML operation type");
+         UNREACHABLE("Unsupported ML operation type");
       }
    }
 
@@ -352,7 +352,7 @@ rkt_ml_subgraph_create(struct pipe_context *pcontext,
       }
       default:
          DBG("poperation->type %d\n", poperations[i].type);
-         unreachable("Unsupported ML operation type");
+         UNREACHABLE("Unsupported ML operation type");
       }
    }
 
diff --git a/src/gallium/drivers/softpipe/sp_quad_depth_test.c b/src/gallium/drivers/softpipe/sp_quad_depth_test.c
index ea3cdba1617b4..e6ba6fcbf1f30 100644
--- a/src/gallium/drivers/softpipe/sp_quad_depth_test.c
+++ b/src/gallium/drivers/softpipe/sp_quad_depth_test.c
@@ -795,7 +795,7 @@ depth_bounds_test_quads(struct quad_stage *qs,
             imin = ((unsigned) (min * 16777215.0)) & 0xffffff;
             imax = ((unsigned) (max * 16777215.0)) & 0xffffff;
          } else {
-            unreachable("Unknown depth buffer format");
+            UNREACHABLE("Unknown depth buffer format");
          }
 
          for (j = 0; j < TGSI_QUAD_SIZE; j++) {
diff --git a/src/gallium/drivers/softpipe/sp_query.c b/src/gallium/drivers/softpipe/sp_query.c
index 1a2b7d17ae318..983cc0a1af75b 100644
--- a/src/gallium/drivers/softpipe/sp_query.c
+++ b/src/gallium/drivers/softpipe/sp_query.c
@@ -292,7 +292,7 @@ is_result_nonzero(struct pipe_query *q,
    case PIPE_QUERY_TIMESTAMP_DISJOINT:
    case PIPE_QUERY_SO_STATISTICS:
    case PIPE_QUERY_PIPELINE_STATISTICS:
-      unreachable("unpossible");
+      UNREACHABLE("unpossible");
       break;
    case PIPE_QUERY_GPU_FINISHED:
    case PIPE_QUERY_OCCLUSION_PREDICATE:
diff --git a/src/gallium/drivers/v3d/v3d_context.c b/src/gallium/drivers/v3d/v3d_context.c
index 25a29a775b30d..4de9b1abc06bc 100644
--- a/src/gallium/drivers/v3d/v3d_context.c
+++ b/src/gallium/drivers/v3d/v3d_context.c
@@ -252,7 +252,7 @@ v3d_flag_dirty_sampler_state(struct v3d_context *v3d,
                 v3d->dirty |= V3D_DIRTY_COMPTEX;
                 break;
         default:
-                unreachable("Unsupported shader stage");
+                UNREACHABLE("Unsupported shader stage");
         }
 }
 
diff --git a/src/gallium/drivers/v3d/v3d_query_pipe.c b/src/gallium/drivers/v3d/v3d_query_pipe.c
index 1f8f287661cb5..9dac4b80afa9e 100644
--- a/src/gallium/drivers/v3d/v3d_query_pipe.c
+++ b/src/gallium/drivers/v3d/v3d_query_pipe.c
@@ -119,7 +119,7 @@ v3d_begin_query_pipe(struct v3d_context *v3d, struct v3d_query *query)
         case PIPE_QUERY_TIMESTAMP_DISJOINT:
                 break;
         default:
-                unreachable("unsupported query type");
+                UNREACHABLE("unsupported query type");
         }
 
         return true;
@@ -179,7 +179,7 @@ v3d_end_query_pipe(struct v3d_context *v3d, struct v3d_query *query)
         case PIPE_QUERY_TIMESTAMP_DISJOINT:
                 break;
         default:
-                unreachable("unsupported query type");
+                UNREACHABLE("unsupported query type");
         }
 
         return true;
@@ -256,7 +256,7 @@ v3d_get_query_result_pipe(struct v3d_context *v3d, struct v3d_query *query,
                 vresult->timestamp_disjoint.disjoint = false;
            break;
         default:
-                unreachable("unsupported query type");
+                UNREACHABLE("unsupported query type");
         }
 
         return true;
diff --git a/src/gallium/drivers/v3d/v3d_uniforms.c b/src/gallium/drivers/v3d/v3d_uniforms.c
index 91dcdf8c3e0dd..80f9e16f55cc6 100644
--- a/src/gallium/drivers/v3d/v3d_uniforms.c
+++ b/src/gallium/drivers/v3d/v3d_uniforms.c
@@ -83,7 +83,7 @@ get_texture_size(struct v3d_texture_stateobj *texstate,
                 return (texture->u.tex.last_level -
                         texture->u.tex.first_level) + 1;
         default:
-                unreachable("Bad texture size field");
+                UNREACHABLE("Bad texture size field");
         }
 }
 
@@ -120,7 +120,7 @@ get_image_size(struct v3d_shaderimg_stateobj *shaderimg,
                         return image->base.resource->array_size / 6;
                 }
         default:
-                unreachable("Bad texture size field");
+                UNREACHABLE("Bad texture size field");
         }
 }
 
@@ -403,7 +403,7 @@ v3d_write_uniforms(struct v3d_context *v3d, struct v3d_job *job,
                         break;
 
                 default:
-                        unreachable("Unknown QUNIFORM");
+                        UNREACHABLE("Unknown QUNIFORM");
 
                 }
 #if 0
diff --git a/src/gallium/drivers/v3d/v3dx_draw.c b/src/gallium/drivers/v3d/v3dx_draw.c
index d3e073fbd18a9..e87d88c0684c4 100644
--- a/src/gallium/drivers/v3d/v3dx_draw.c
+++ b/src/gallium/drivers/v3d/v3dx_draw.c
@@ -377,7 +377,7 @@ v3d_gs_output_primitive(enum mesa_prim prim_type)
     case MESA_PRIM_TRIANGLE_STRIP:
         return GEOMETRY_SHADER_TRI_STRIP;
     default:
-        unreachable("Unsupported primitive type");
+        UNREACHABLE("Unsupported primitive type");
     }
 }
 
@@ -417,7 +417,7 @@ simd_width_to_gs_pack_mode(uint32_t width)
     case 1:
         return V3D_PACK_MODE_1_WAY;
     default:
-        unreachable("Invalid SIMD width");
+        UNREACHABLE("Invalid SIMD width");
     };
 }
 
@@ -1856,7 +1856,7 @@ v3d_set_global_binding(struct pipe_context *pctx,
         if (old_size < first + count) {
                 /* we are screwed no matter what */
                 if (!util_dynarray_grow(&v3d->global_buffers, *resources, (first + count) - old_size))
-                        unreachable("out of memory");
+                        UNREACHABLE("out of memory");
 
                 for (unsigned i = old_size; i < first + count; i++)
                         *util_dynarray_element(&v3d->global_buffers, struct pipe_resource *, i) = NULL;
diff --git a/src/gallium/drivers/v3d/v3dx_emit.c b/src/gallium/drivers/v3d/v3dx_emit.c
index 473f2a8eaa796..a299abaa82a3c 100644
--- a/src/gallium/drivers/v3d/v3dx_emit.c
+++ b/src/gallium/drivers/v3d/v3dx_emit.c
@@ -74,7 +74,7 @@ v3d_factor(enum pipe_blendfactor factor, bool dst_alpha_one)
                         V3D_BLEND_FACTOR_ZERO :
                         V3D_BLEND_FACTOR_SRC_ALPHA_SATURATE);
         default:
-                unreachable("Bad blend factor");
+                UNREACHABLE("Bad blend factor");
         }
 }
 
diff --git a/src/gallium/drivers/v3d/v3dx_rcl.c b/src/gallium/drivers/v3d/v3dx_rcl.c
index 7fc0c0a1f13d9..27cf729df7fa1 100644
--- a/src/gallium/drivers/v3d/v3dx_rcl.c
+++ b/src/gallium/drivers/v3d/v3dx_rcl.c
@@ -428,11 +428,11 @@ v3dX(clamp_for_format_and_type)(uint32_t rt_type,
         case V3D_INTERNAL_TYPE_32F:
                 return V3D_RENDER_TARGET_TYPE_CLAMP_32F;
         default:
-                unreachable("Unknown internal render target type");
+                UNREACHABLE("Unknown internal render target type");
         }
         return V3D_RENDER_TARGET_TYPE_CLAMP_INVALID;
 #endif
-        unreachable("Wrong V3D_VERSION");
+        UNREACHABLE("Wrong V3D_VERSION");
 }
 
 #if V3D_VERSION >= 71
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index 7f81b62cc005a..979a48a8f72b0 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -172,7 +172,7 @@ translate_stencil_op(enum pipe_stencil_op op)
         case PIPE_STENCIL_OP_DECR_WRAP: return V3D_STENCIL_OP_DECWRAP;
         case PIPE_STENCIL_OP_INVERT:    return V3D_STENCIL_OP_INVERT;
         }
-        unreachable("bad stencil op");
+        UNREACHABLE("bad stencil op");
 }
 
 static void *
@@ -551,7 +551,7 @@ translate_wrap(uint32_t pipe_wrap)
         case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
                 return V3D_WRAP_MODE_MIRROR_ONCE;
         default:
-                unreachable("Unknown wrap mode");
+                UNREACHABLE("Unknown wrap mode");
         }
 }
 
diff --git a/src/gallium/drivers/v3d/v3dx_tfu.c b/src/gallium/drivers/v3d/v3dx_tfu.c
index a00e6f4d106a3..29b29e1dbc390 100644
--- a/src/gallium/drivers/v3d/v3dx_tfu.c
+++ b/src/gallium/drivers/v3d/v3dx_tfu.c
@@ -73,7 +73,7 @@ v3dX(tfu)(struct pipe_context *pctx,
                 case 4:  pformat = PIPE_FORMAT_R32_FLOAT;            break;
                 case 2:  pformat = PIPE_FORMAT_R16_FLOAT;            break;
                 case 1:  pformat = PIPE_FORMAT_R8_UNORM;             break;
-                default: unreachable("unsupported format bit-size"); break;
+                default: UNREACHABLE("unsupported format bit-size"); break;
                 };
         }
 
diff --git a/src/gallium/drivers/vc4/vc4_nir_lower_txf_ms.c b/src/gallium/drivers/vc4/vc4_nir_lower_txf_ms.c
index 41fd1d72a1db8..231480fde8cb6 100644
--- a/src/gallium/drivers/vc4/vc4_nir_lower_txf_ms.c
+++ b/src/gallium/drivers/vc4/vc4_nir_lower_txf_ms.c
@@ -59,7 +59,7 @@ vc4_nir_lower_txf_ms_instr(nir_builder *b, nir_instr *instr, void *data)
                         sample_index = txf_ms->src[i].src.ssa;
                         break;
                 default:
-                        unreachable("Unknown txf_ms src\n");
+                        UNREACHABLE("Unknown txf_ms src\n");
                 }
         }
         assert(coord);
diff --git a/src/gallium/drivers/vc4/vc4_program.c b/src/gallium/drivers/vc4/vc4_program.c
index de9215aca5dce..f61d3a32c251b 100644
--- a/src/gallium/drivers/vc4/vc4_program.c
+++ b/src/gallium/drivers/vc4/vc4_program.c
@@ -433,7 +433,7 @@ ntq_emit_tex(struct vc4_compile *c, nir_tex_instr *instr)
                         compare = ntq_get_src(c, instr->src[i].src, 0);
                         break;
                 default:
-                        unreachable("unknown texture source");
+                        UNREACHABLE("unknown texture source");
                 }
         }
 
@@ -1975,7 +1975,7 @@ ntq_emit_jump(struct vc4_compile *c, nir_jump_instr *jump)
                 jump_block = c->loop_cont_block;
                 break;
         default:
-                unreachable("Unsupported jump type\n");
+                UNREACHABLE("Unsupported jump type\n");
         }
 
         qir_SF(c, c->execute);
diff --git a/src/gallium/drivers/vc4/vc4_qir.c b/src/gallium/drivers/vc4/vc4_qir.c
index d70dedf29e254..5e1af268ce51e 100644
--- a/src/gallium/drivers/vc4/vc4_qir.c
+++ b/src/gallium/drivers/vc4/vc4_qir.c
@@ -340,7 +340,7 @@ qir_channels_written(struct qinst *inst)
                         return 0xc;
                 }
         }
-        unreachable("Bad pack field");
+        UNREACHABLE("Bad pack field");
 }
 
 char *
diff --git a/src/gallium/drivers/vc4/vc4_qpu_emit.c b/src/gallium/drivers/vc4/vc4_qpu_emit.c
index bddc503aaa594..dcc171b935cc2 100644
--- a/src/gallium/drivers/vc4/vc4_qpu_emit.c
+++ b/src/gallium/drivers/vc4/vc4_qpu_emit.c
@@ -359,7 +359,7 @@ vc4_generate_code_block(struct vc4_compile *c,
                         case QFILE_TEX_T:
                         case QFILE_TEX_R:
                         case QFILE_TEX_B:
-                                unreachable("bad qir src file");
+                                UNREACHABLE("bad qir src file");
                         }
                 }
 
diff --git a/src/gallium/drivers/vc4/vc4_register_allocate.c b/src/gallium/drivers/vc4/vc4_register_allocate.c
index a83f97f303086..48168b0ef8eaf 100644
--- a/src/gallium/drivers/vc4/vc4_register_allocate.c
+++ b/src/gallium/drivers/vc4/vc4_register_allocate.c
@@ -238,7 +238,7 @@ vc4_ra_select_callback(unsigned int n, BITSET_WORD *regs, void *data)
                 }
         }
 
-        unreachable("RA must pass us at least one possible reg.");
+        UNREACHABLE("RA must pass us at least one possible reg.");
 }
 
 /**
diff --git a/src/gallium/drivers/vc4/vc4_tiling.h b/src/gallium/drivers/vc4/vc4_tiling.h
index 5afe32939a803..b068f73973638 100644
--- a/src/gallium/drivers/vc4/vc4_tiling.h
+++ b/src/gallium/drivers/vc4/vc4_tiling.h
@@ -42,7 +42,7 @@ vc4_utile_width(int cpp)
         case 8:
                 return 2;
         default:
-                unreachable("unknown cpp");
+                UNREACHABLE("unknown cpp");
         }
 }
 
@@ -58,7 +58,7 @@ vc4_utile_height(int cpp)
         case 8:
                 return 4;
         default:
-                unreachable("unknown cpp");
+                UNREACHABLE("unknown cpp");
         }
 }
 
diff --git a/src/gallium/drivers/vc4/vc4_tiling_lt.c b/src/gallium/drivers/vc4/vc4_tiling_lt.c
index 9dd029729ccf2..4cea5d52aea56 100644
--- a/src/gallium/drivers/vc4/vc4_tiling_lt.c
+++ b/src/gallium/drivers/vc4/vc4_tiling_lt.c
@@ -54,7 +54,7 @@ vc4_utile_stride(int cpp)
         case 8:
                 return 16;
         default:
-                unreachable("bad cpp");
+                UNREACHABLE("bad cpp");
         }
 }
 
@@ -87,7 +87,7 @@ swizzle_lt_x(int x, int cpp)
                 return (((uint32_t)x & 0x1) << (3 - 0) |
                         ((uint32_t)x & ~0x1) << (6 - 1));
         default:
-                unreachable("bad cpp");
+                UNREACHABLE("bad cpp");
         }
 }
 
@@ -115,7 +115,7 @@ swizzle_lt_y(int y, int cpp)
                 /* 2x4 inside of 4x4 */
                 return ((y & 0x3) << 4);
         default:
-                unreachable("bad cpp");
+                UNREACHABLE("bad cpp");
         }
 }
 
@@ -265,7 +265,7 @@ vc4_lt_image_cpp_helper(void *gpu, uint32_t gpu_stride,
                                     to_cpu);
                 break;
         default:
-                unreachable("bad cpp");
+                UNREACHABLE("bad cpp");
         }
 }
 
diff --git a/src/gallium/drivers/virgl/virgl_screen.h b/src/gallium/drivers/virgl/virgl_screen.h
index b84c690242d20..ba0f769ee6073 100644
--- a/src/gallium/drivers/virgl/virgl_screen.h
+++ b/src/gallium/drivers/virgl/virgl_screen.h
@@ -106,7 +106,7 @@ virgl_shader_stage_convert(enum pipe_shader_type type)
    case PIPE_SHADER_COMPUTE:
       return VIRGL_SHADER_COMPUTE;
    default:
-      unreachable("virgl: unknown shader stage.\n");
+      UNREACHABLE("virgl: unknown shader stage.\n");
    }
 }
 
diff --git a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
index 0df38536fb507..027fc35d12d6a 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
+++ b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
@@ -327,7 +327,7 @@ emit_access_decorations(struct ntv_context *ctx, nir_variable *var, SpvId var_id
           /* no equivalent */
           break;
        default:
-          unreachable("unknown access bit");
+          UNREACHABLE("unknown access bit");
        }
     }
     /* The Simple, GLSL, and Vulkan memory models can assume that aliasing is generally
@@ -399,7 +399,7 @@ get_atomic_op(struct ntv_context *ctx, unsigned bit_size, nir_atomic_op op)
       return SpvOpAtomicCompareExchange;
    default:
       debug_printf("%s - ", nir_intrinsic_infos[op].name);
-      unreachable("unhandled atomic op");
+      UNREACHABLE("unhandled atomic op");
    }
    return 0;
 }
@@ -488,7 +488,7 @@ get_alu_type(struct ntv_context *ctx, nir_alu_type type, unsigned num_components
       return get_fvec_type(ctx, bit_size, num_components);
 
    default:
-      unreachable("unsupported nir_alu_type");
+      UNREACHABLE("unsupported nir_alu_type");
    }
 }
 
@@ -512,7 +512,7 @@ get_storage_class(struct nir_variable *var)
    case nir_var_mem_ssbo:
       return SpvStorageClassStorageBuffer;
    default:
-      unreachable("Unsupported nir_variable_mode");
+      UNREACHABLE("Unsupported nir_variable_mode");
    }
    return 0;
 }
@@ -562,7 +562,7 @@ get_glsl_basetype(struct ntv_context *ctx, enum glsl_base_type type)
       return spirv_builder_type_uint(&ctx->builder, 8);
 
    default:
-      unreachable("unknown GLSL type");
+      UNREACHABLE("unknown GLSL type");
    }
 }
 
@@ -634,7 +634,7 @@ get_glsl_type(struct ntv_context *ctx, const struct glsl_type *type, bool implic
             spirv_builder_emit_member_offset(&ctx->builder, ret, i, offset);
       }
    } else
-      unreachable("Unhandled GLSL type");
+      UNREACHABLE("Unhandled GLSL type");
 
    _mesa_hash_table_insert(ctx->glsl_types[implicit_stride], type, (void *)(uintptr_t)ret);
    return ret;
@@ -788,7 +788,7 @@ emit_interpolation(struct ntv_context *ctx, SpvId var_id,
                                     SpvDecorationNoPerspective);
       break;
    default:
-      unreachable("unknown interpolation value");
+      UNREACHABLE("unknown interpolation value");
    }
 }
 
@@ -901,7 +901,7 @@ emit_output(struct ntv_context *ctx, struct nir_variable *var)
       } else {
          switch (var->data.location) {
          case FRAG_RESULT_COLOR:
-            unreachable("gl_FragColor should be lowered by now");
+            UNREACHABLE("gl_FragColor should be lowered by now");
 
          case FRAG_RESULT_DEPTH:
             spirv_builder_emit_builtin(&ctx->builder, var_id, SpvBuiltInFragDepth);
@@ -1681,7 +1681,7 @@ get_alu_src(struct ntv_context *ctx, nir_alu_instr *alu, unsigned src, SpvId *ra
    else {
       switch (nir_alu_type_get_base_type(type)) {
       case nir_type_bool:
-         unreachable("bool should have bit-size 1");
+         UNREACHABLE("bool should have bit-size 1");
 
       case nir_type_int:
          return bitcast_to_ivec(ctx, *raw_value, bit_size, num_components);
@@ -1693,7 +1693,7 @@ get_alu_src(struct ntv_context *ctx, nir_alu_instr *alu, unsigned src, SpvId *ra
          return bitcast_to_fvec(ctx, *raw_value, bit_size, num_components);
 
       default:
-         unreachable("unknown nir_alu_type");
+         UNREACHABLE("unknown nir_alu_type");
       }
    }
 }
@@ -1741,7 +1741,7 @@ emit_alu(struct ntv_context *ctx, nir_alu_instr *alu)
             float_count++;
             break;
          default:
-            unreachable("this shouldn't happen");
+            UNREACHABLE("this shouldn't happen");
          }
       }
       if (uint_count > int_count && uint_count > float_count)
@@ -2016,7 +2016,7 @@ emit_alu(struct ntv_context *ctx, nir_alu_instr *alu)
    case nir_op_sne:
    case nir_op_slt:
    case nir_op_sge:
-      unreachable("should already be lowered away");
+      UNREACHABLE("should already be lowered away");
 
    case nir_op_fneu:
       assert(nir_op_infos[alu->op].num_inputs == 2);
@@ -2161,7 +2161,7 @@ emit_alu(struct ntv_context *ctx, nir_alu_instr *alu)
       fprintf(stderr, "emit_alu: not implemented (%s)\n",
               nir_op_infos[alu->op].name);
 
-      unreachable("unsupported opcode");
+      UNREACHABLE("unsupported opcode");
       return;
    }
    if (alu->exact)
@@ -2206,7 +2206,7 @@ emit_load_const(struct ntv_context *ctx, nir_load_const_instr *load_const)
             break;
          }
          default:
-            unreachable("this shouldn't happen!");
+            UNREACHABLE("this shouldn't happen!");
          }
       }
    }
@@ -2692,7 +2692,7 @@ emit_load_vec_input(struct ntv_context *ctx, nir_intrinsic_instr *intr, SpvId *v
                                intr->def.num_components);
       break;
    default:
-      unreachable("unknown type passed");
+      UNREACHABLE("unknown type passed");
    }
    if (!*var_id)
       *var_id = create_builtin_var(ctx, var_type,
@@ -2732,7 +2732,7 @@ emit_interpolate(struct ntv_context *ctx, nir_intrinsic_instr *intr)
          src1 = emit_bitcast(ctx, get_fvec_type(ctx, 32, 2), src1);
       break;
    default:
-      unreachable("unknown interp op");
+      UNREACHABLE("unknown interp op");
    }
    nir_alu_type ptype;
    SpvId ptr = get_src(ctx, &intr->src[0], &ptype);
@@ -3156,7 +3156,7 @@ emit_vote(struct ntv_context *ctx, nir_intrinsic_instr *intr)
       op = SpvOpGroupNonUniformAllEqual;
       break;
    default:
-      unreachable("unknown vote intrinsic");
+      UNREACHABLE("unknown vote intrinsic");
    }
    spirv_builder_emit_cap(&ctx->builder, SpvCapabilityGroupNonUniformVote);
    nir_alu_type atype;
@@ -3246,7 +3246,7 @@ emit_derivative(struct ntv_context *ctx, nir_intrinsic_instr *intr)
       op = SpvOpDPdyCoarse;
       break;
    default:
-      unreachable("invalid ddx/ddy");
+      UNREACHABLE("invalid ddx/ddy");
    }
 
    if (op != SpvOpDPdx && op != SpvOpDPdy)
@@ -3296,7 +3296,7 @@ emit_subgroup(struct ntv_context *ctx, nir_intrinsic_instr *intr)
    default:
       fprintf(stderr, "emit_subgroup: reduction op not implemented (%s)\n",
               nir_intrinsic_infos[nir_intrinsic_reduction_op(intr)].name);
-      unreachable("unhandled intrinsic");
+      UNREACHABLE("unhandled intrinsic");
    }
 
    SpvGroupOperation groupop;
@@ -3315,7 +3315,7 @@ emit_subgroup(struct ntv_context *ctx, nir_intrinsic_instr *intr)
    default:
       fprintf(stderr, "emit_subgroup: not implemented (%s)\n",
               nir_intrinsic_infos[intr->intrinsic].name);
-      unreachable("unhandled intrinsic");
+      UNREACHABLE("unhandled intrinsic");
    }
    spirv_builder_emit_cap(&ctx->builder, cluster_size ? SpvCapabilityGroupNonUniformClustered : SpvCapabilityGroupNonUniformArithmetic);
 
@@ -3375,7 +3375,7 @@ emit_subgroup_quad(struct ntv_context *ctx, nir_intrinsic_instr *intr)
    default:
       fprintf(stderr, "emit_subgroup_quad: not implemented (%s)\n",
               nir_intrinsic_infos[intr->intrinsic].name);
-      unreachable("unhandled intrinsic");
+      UNREACHABLE("unhandled intrinsic");
    }
    spirv_builder_emit_cap(&ctx->builder, SpvCapabilityGroupNonUniformQuad);
 
@@ -3408,7 +3408,7 @@ emit_shuffle(struct ntv_context *ctx, nir_intrinsic_instr *intr)
    default:
       fprintf(stderr, "emit_shuffle: not implemented (%s)\n",
               nir_intrinsic_infos[intr->intrinsic].name);
-      unreachable("unhandled intrinsic");
+      UNREACHABLE("unhandled intrinsic");
    }
    nir_alu_type atype, unused;
    SpvId src0 = get_src(ctx, &intr->src[0], &atype);
@@ -3725,7 +3725,7 @@ emit_intrinsic(struct ntv_context *ctx, nir_intrinsic_instr *intr)
    default:
       fprintf(stderr, "emit_intrinsic: not implemented (%s)\n",
               nir_intrinsic_infos[intr->intrinsic].name);
-      unreachable("unsupported intrinsic");
+      UNREACHABLE("unsupported intrinsic");
    }
 }
 
@@ -3901,7 +3901,7 @@ get_tex_srcs(struct ntv_context *ctx, nir_tex_instr *tex,
 
       default:
          fprintf(stderr, "texture source: %d\n", tex->src[i].src_type);
-         unreachable("unknown texture source");
+         UNREACHABLE("unknown texture source");
       }
    }
    return var;
@@ -3944,7 +3944,7 @@ get_texop_dest_type(struct ntv_context *ctx, const nir_tex_instr *tex)
       break;
 
    default:
-      unreachable("unexpected nir_alu_type");
+      UNREACHABLE("unexpected nir_alu_type");
    }
 
    return actual_dest_type;
@@ -4188,7 +4188,7 @@ emit_jump(struct ntv_context *ctx, nir_jump_instr *jump)
       break;
 
    default:
-      unreachable("Unsupported jump type\n");
+      UNREACHABLE("Unsupported jump type\n");
    }
 }
 
@@ -4268,7 +4268,7 @@ emit_deref_array(struct ntv_context *ctx, nir_deref_instr *deref)
    }
 
    default:
-      unreachable("Unsupported nir_variable_mode\n");
+      UNREACHABLE("Unsupported nir_variable_mode\n");
    }
 
    nir_alu_type itype;
@@ -4331,7 +4331,7 @@ emit_deref(struct ntv_context *ctx, nir_deref_instr *deref)
       break;
 
    default:
-      unreachable("unexpected deref_type");
+      UNREACHABLE("unexpected deref_type");
    }
 }
 
@@ -4357,16 +4357,16 @@ emit_block(struct ntv_context *ctx, struct nir_block *block)
          emit_tex(ctx, nir_instr_as_tex(instr));
          break;
       case nir_instr_type_phi:
-         unreachable("nir_instr_type_phi not supported");
+         UNREACHABLE("nir_instr_type_phi not supported");
          break;
       case nir_instr_type_jump:
          emit_jump(ctx, nir_instr_as_jump(instr));
          break;
       case nir_instr_type_call:
-         unreachable("nir_instr_type_call not supported");
+         UNREACHABLE("nir_instr_type_call not supported");
          break;
       case nir_instr_type_parallel_copy:
-         unreachable("nir_instr_type_parallel_copy not supported");
+         UNREACHABLE("nir_instr_type_parallel_copy not supported");
          break;
       case nir_instr_type_deref:
          emit_deref(ctx, nir_instr_as_deref(instr));
@@ -4471,7 +4471,7 @@ emit_cf_list(struct ntv_context *ctx, struct exec_list *list)
          break;
 
       case nir_cf_node_function:
-         unreachable("nir_cf_node_function not supported");
+         UNREACHABLE("nir_cf_node_function not supported");
          break;
       }
    }
@@ -4496,7 +4496,7 @@ get_input_prim_type_mode(enum mesa_prim type)
       return SpvExecutionModeQuads;
       break;
    case MESA_PRIM_POLYGON:
-      unreachable("handle polygons in gs");
+      UNREACHABLE("handle polygons in gs");
       break;
    case MESA_PRIM_LINES_ADJACENCY:
    case MESA_PRIM_LINE_STRIP_ADJACENCY:
@@ -4507,7 +4507,7 @@ get_input_prim_type_mode(enum mesa_prim type)
       break;
    default:
       debug_printf("unknown geometry shader input mode %u\n", type);
-      unreachable("error!");
+      UNREACHABLE("error!");
       break;
    }
 
@@ -4521,7 +4521,7 @@ get_output_prim_type_mode(enum mesa_prim type)
       return SpvExecutionModeOutputPoints;
    case MESA_PRIM_LINES:
    case MESA_PRIM_LINE_LOOP:
-      unreachable("MESA_PRIM_LINES/LINE_LOOP passed as gs output");
+      UNREACHABLE("MESA_PRIM_LINES/LINE_LOOP passed as gs output");
       break;
    case MESA_PRIM_LINE_STRIP:
       return SpvExecutionModeOutputLineStrip;
@@ -4534,19 +4534,19 @@ get_output_prim_type_mode(enum mesa_prim type)
    case MESA_PRIM_QUAD_STRIP:
       return SpvExecutionModeQuads;
    case MESA_PRIM_POLYGON:
-      unreachable("handle polygons in gs");
+      UNREACHABLE("handle polygons in gs");
       break;
    case MESA_PRIM_LINES_ADJACENCY:
    case MESA_PRIM_LINE_STRIP_ADJACENCY:
-      unreachable("handle line adjacency in gs");
+      UNREACHABLE("handle line adjacency in gs");
       break;
    case MESA_PRIM_TRIANGLES_ADJACENCY:
    case MESA_PRIM_TRIANGLE_STRIP_ADJACENCY:
-      unreachable("handle triangle adjacency in gs");
+      UNREACHABLE("handle triangle adjacency in gs");
       break;
    default:
       debug_printf("unknown geometry shader output mode %u\n", type);
-      unreachable("error!");
+      UNREACHABLE("error!");
       break;
    }
 
@@ -4567,7 +4567,7 @@ get_depth_layout_mode(enum gl_frag_depth_layout depth_layout)
    case FRAG_DEPTH_LAYOUT_UNCHANGED:
       return SpvExecutionModeDepthUnchanged;
    default:
-      unreachable("unexpected depth layout");
+      UNREACHABLE("unexpected depth layout");
    }
 }
 
@@ -4579,7 +4579,7 @@ get_primitive_mode(enum tess_primitive_mode primitive_mode)
    case TESS_PRIMITIVE_QUADS: return SpvExecutionModeQuads;
    case TESS_PRIMITIVE_ISOLINES: return SpvExecutionModeIsolines;
    default:
-      unreachable("unknown tess prim type!");
+      UNREACHABLE("unknown tess prim type!");
    }
 }
 
@@ -4594,7 +4594,7 @@ get_spacing(enum gl_tess_spacing spacing)
    case TESS_SPACING_FRACTIONAL_EVEN:
       return SpvExecutionModeSpacingFractionalEven;
    default:
-      unreachable("unknown tess spacing!");
+      UNREACHABLE("unknown tess spacing!");
    }
 }
 
@@ -4763,7 +4763,7 @@ nir_to_spirv(struct nir_shader *s, const struct zink_shader_info *sinfo, const s
       exec_model = SpvExecutionModelGLCompute;
       break;
    default:
-      unreachable("invalid stage");
+      UNREACHABLE("invalid stage");
    }
 
    SpvId type_void = spirv_builder_type_void(&ctx.builder);
diff --git a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.h b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.h
index 3992f7a29e9a9..391dd2bf2a394 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.h
+++ b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.h
@@ -74,7 +74,7 @@ zink_sampler_type(const struct glsl_type *type)
    case GLSL_SAMPLER_DIM_BUF:
       return VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
    default:
-      unreachable("unimplemented");
+      UNREACHABLE("unimplemented");
    }
    return 0;
 }
@@ -95,7 +95,7 @@ zink_image_type(const struct glsl_type *type)
    case GLSL_SAMPLER_DIM_BUF:
       return VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
    default:
-      unreachable("unimplemented");
+      UNREACHABLE("unimplemented");
    }
    return 0;
 }
diff --git a/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c b/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c
index e2a49ee18b9df..3713a51f26e34 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c
+++ b/src/gallium/drivers/zink/nir_to_spirv/spirv_builder.c
@@ -1683,7 +1683,7 @@ spirv_builder_const_float(struct spirv_builder *b, int width, double val)
       return emit_constant_64(b, type, u_bitcast_d2u(val));
    }
 
-   unreachable("unhandled float-width");
+   UNREACHABLE("unhandled float-width");
 }
 
 SpvId
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index b9a63abe524dc..d9727749d57be 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -329,9 +329,9 @@ replicate_derefs(nir_builder *b, nir_deref_instr *old, nir_deref_instr *new)
    case nir_deref_type_array_wildcard:
    case nir_deref_type_ptr_as_array:
    case nir_deref_type_cast:
-      unreachable("unexpected deref type");
+      UNREACHABLE("unexpected deref type");
    }
-   unreachable("impossible deref type");
+   UNREACHABLE("impossible deref type");
 }
 
 static bool
@@ -486,7 +486,7 @@ lower_pv_mode_gs_instr(nir_builder *b, nir_instr *instr, void *data)
    case nir_intrinsic_store_deref:
       return lower_pv_mode_gs_store(b, intrin, state);
    case nir_intrinsic_copy_deref:
-      unreachable("should be lowered");
+      UNREACHABLE("should be lowered");
    case nir_intrinsic_emit_vertex_with_counter:
    case nir_intrinsic_emit_vertex:
       return lower_pv_mode_gs_emit_vertex(b, intrin, state);
@@ -904,7 +904,7 @@ lower_line_smooth_gs_instr(nir_builder *b, nir_instr *instr, void *data)
    case nir_intrinsic_store_deref:
       return lower_line_smooth_gs_store(b, intrin, state);
    case nir_intrinsic_copy_deref:
-      unreachable("should be lowered");
+      UNREACHABLE("should be lowered");
    case nir_intrinsic_emit_vertex_with_counter:
    case nir_intrinsic_emit_vertex:
       return lower_line_smooth_gs_emit_vertex(b, intrin, state);
@@ -1052,7 +1052,7 @@ lower_64bit_pack_instr(nir_builder *b, nir_instr *instr, void *data)
       dest = nir_vec2(b, nir_unpack_64_2x32_split_x(b, src), nir_unpack_64_2x32_split_y(b, src));
       break;
    default:
-      unreachable("Impossible opcode");
+      UNREACHABLE("Impossible opcode");
    }
    nir_def_replace(&alu_instr->def, dest);
    return true;
@@ -1259,7 +1259,7 @@ amd_varying_expression_max_cost(nir_shader *producer, nir_shader *consumer)
       return 14;
 
    default:
-      unreachable("unexpected shader stage");
+      UNREACHABLE("unexpected shader stage");
    }
 }
 
@@ -2005,7 +2005,7 @@ update_so_info(struct zink_shader *zs, nir_shader *nir, uint64_t outputs_written
       }
       continue;
 out:
-      unreachable("xfb should be inlined by now!");
+      UNREACHABLE("xfb should be inlined by now!");
    }
 }
 
@@ -2262,7 +2262,7 @@ rewrite_atomic_ssbo_instr(nir_builder *b, nir_instr *instr, struct bo_vars *bo)
    else if (intr->intrinsic == nir_intrinsic_ssbo_atomic_swap)
       op = nir_intrinsic_deref_atomic_swap;
    else
-      unreachable("unknown intrinsic");
+      UNREACHABLE("unknown intrinsic");
    nir_def *offset = intr->src[1].ssa;
    nir_src *src = &intr->src[0];
    nir_variable *var = get_bo_var(b->shader, bo, true, src,
@@ -2520,7 +2520,7 @@ clamp_layer_output(nir_shader *vs, nir_shader *fs, unsigned *next_location)
    case MESA_SHADER_TESS_EVAL:
       break;
    default:
-      unreachable("invalid last vertex stage!");
+      UNREACHABLE("invalid last vertex stage!");
    }
    struct clamp_layer_output_state state = {0};
    state.original = nir_find_variable_with_location(vs, nir_var_shader_out, VARYING_SLOT_LAYER);
@@ -2609,7 +2609,7 @@ assign_producer_var_io(gl_shader_stage stage, nir_variable *var, struct io_slot_
    unsigned slot = var->data.location;
    switch (slot) {
    case -1:
-      unreachable("there should be no UINT32_MAX location variables!");
+      UNREACHABLE("there should be no UINT32_MAX location variables!");
       break;
    case VARYING_SLOT_POS:
    case VARYING_SLOT_PSIZ:
@@ -2986,7 +2986,7 @@ rewrite_64bit_type(nir_shader *nir, const struct glsl_type *type, nir_variable *
       base_type = GLSL_TYPE_FLOAT;
       break;
    default:
-      unreachable("unknown 64-bit vertex attribute format!");
+      UNREACHABLE("unknown 64-bit vertex attribute format!");
    }
    if (glsl_type_is_scalar(type))
       return glsl_vector_type(base_type, 2);
@@ -3312,7 +3312,7 @@ zink_get_next_stage(gl_shader_stage stage)
    case MESA_SHADER_KERNEL:
       return 0;
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 }
 
@@ -3823,7 +3823,7 @@ add_derefs_instr(nir_builder *b, nir_intrinsic_instr *intr, void *data)
                load = nir_interp_deref_at_offset(b, num_components, bit_size, &deref->def, interp_intr->src[0].ssa);
                break;
             default:
-               unreachable("unhandled interp!");
+               UNREACHABLE("unhandled interp!");
             }
          } else {
             load = nir_load_deref(b, deref);
@@ -3855,7 +3855,7 @@ add_derefs_instr(nir_builder *b, nir_intrinsic_instr *intr, void *data)
       nir_instr_remove(&intr->instr);
       return true;
    }
-   unreachable("failed to find variable for explicit io!");
+   UNREACHABLE("failed to find variable for explicit io!");
    return true;
 }
 
@@ -4519,7 +4519,7 @@ static uint32_t
 zink_binding(gl_shader_stage stage, VkDescriptorType type, int index, bool compact_descriptors)
 {
    if (stage == MESA_SHADER_NONE) {
-      unreachable("not supported");
+      UNREACHABLE("not supported");
    } else {
       unsigned base = stage;
       /* clamp compute bindings for better driver efficiency */
@@ -4560,7 +4560,7 @@ zink_binding(gl_shader_stage stage, VkDescriptorType type, int index, bool compa
          return (base * ZINK_MAX_SHADER_IMAGES) + index + (compact_descriptors * (ZINK_GFX_SHADER_COUNT * PIPE_MAX_SAMPLERS));
 
       default:
-         unreachable("unexpected type");
+         UNREACHABLE("unexpected type");
       }
    }
 }
@@ -4594,7 +4594,7 @@ handle_bindless_var(nir_shader *nir, nir_variable *var, const struct glsl_type *
          binding = 3;
          break;
       default:
-         unreachable("unknown");
+         UNREACHABLE("unknown");
    }
    if (!bindless->bindless[binding]) {
       bindless->bindless[binding] = nir_variable_clone(var, nir);
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index 94b3b94b6c78d..6ab1166a94589 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -350,9 +350,9 @@ sampler_mipmap_mode(enum pipe_tex_mipfilter filter)
    case PIPE_TEX_MIPFILTER_NEAREST: return VK_SAMPLER_MIPMAP_MODE_NEAREST;
    case PIPE_TEX_MIPFILTER_LINEAR: return VK_SAMPLER_MIPMAP_MODE_LINEAR;
    case PIPE_TEX_MIPFILTER_NONE:
-      unreachable("PIPE_TEX_MIPFILTER_NONE should be dealt with earlier");
+      UNREACHABLE("PIPE_TEX_MIPFILTER_NONE should be dealt with earlier");
    }
-   unreachable("unexpected filter");
+   UNREACHABLE("unexpected filter");
 }
 
 static VkSamplerAddressMode
@@ -367,7 +367,7 @@ sampler_address_mode(enum pipe_tex_wrap filter)
    case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER: return VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; /* not technically correct, but kinda works */
    default: break;
    }
-   unreachable("unexpected wrap");
+   UNREACHABLE("unexpected wrap");
 }
 
 /* unnormalizedCoordinates only support CLAMP_TO_EDGE or CLAMP_TO_BORDER */
@@ -379,7 +379,7 @@ sampler_address_mode_unnormalized(enum pipe_tex_wrap filter)
    case PIPE_TEX_WRAP_CLAMP_TO_BORDER: return VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
    default: break;
    }
-   unreachable("unexpected wrap");
+   UNREACHABLE("unexpected wrap");
 }
 
 static VkCompareOp
@@ -395,7 +395,7 @@ compare_op(enum pipe_compare_func op)
       case PIPE_FUNC_GEQUAL: return VK_COMPARE_OP_GREATER_OR_EQUAL;
       case PIPE_FUNC_ALWAYS: return VK_COMPARE_OP_ALWAYS;
    }
-   unreachable("unexpected compare");
+   UNREACHABLE("unexpected compare");
 }
 
 static inline bool
@@ -647,7 +647,7 @@ get_imageview_for_binding(struct zink_context *ctx, gl_shader_stage stage, enum
    default:
       break;
    }
-   unreachable("ACK");
+   UNREACHABLE("ACK");
    return VK_NULL_HANDLE;
 }
 
@@ -666,7 +666,7 @@ get_bufferview_for_binding(struct zink_context *ctx, gl_shader_stage stage, enum
    default:
       break;
    }
-   unreachable("ACK");
+   UNREACHABLE("ACK");
    return VK_NULL_HANDLE;
 }
 
@@ -2638,7 +2638,7 @@ zink_set_global_binding(struct pipe_context *pctx,
 
    size_t size = ctx->di.global_bindings.capacity;
    if (!util_dynarray_resize(&ctx->di.global_bindings, struct pipe_resource*, first + count + 8))
-      unreachable("zink: out of memory somehow");
+      UNREACHABLE("zink: out of memory somehow");
    if (size != ctx->di.global_bindings.capacity) {
       uint8_t *data = ctx->di.global_bindings.data;
       memset(data + size, 0, ctx->di.global_bindings.capacity - size);
@@ -3439,7 +3439,7 @@ get_access_flags_for_binding(struct zink_context *ctx, enum zink_descriptor_type
    default:
       break;
    }
-   unreachable("ACK");
+   UNREACHABLE("ACK");
    return 0;
 }
 
@@ -4866,7 +4866,7 @@ zink_resource_copy_region(struct pipe_context *pctx,
        */
          assert(src->aspect == dst->aspect);
       } else
-         unreachable("planar formats not yet handled");
+         UNREACHABLE("planar formats not yet handled");
 
 
       region.srcSubresource.aspectMask = src->aspect;
diff --git a/src/gallium/drivers/zink/zink_context.h b/src/gallium/drivers/zink/zink_context.h
index f23efc904518b..5c664790dcaaf 100644
--- a/src/gallium/drivers/zink/zink_context.h
+++ b/src/gallium/drivers/zink/zink_context.h
@@ -161,7 +161,7 @@ zink_pipeline_flags_from_pipe_stage(gl_shader_stage pstage)
    case MESA_SHADER_COMPUTE:
       return VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
    default:
-      unreachable("unknown shader stage");
+      UNREACHABLE("unknown shader stage");
    }
 }
 
@@ -245,7 +245,7 @@ zink_component_mapping(enum pipe_swizzle swizzle)
    case PIPE_SWIZZLE_0: return VK_COMPONENT_SWIZZLE_ZERO;
    case PIPE_SWIZZLE_1: return VK_COMPONENT_SWIZZLE_ONE;
    default:
-      unreachable("unexpected swizzle");
+      UNREACHABLE("unexpected swizzle");
    }
 }
 
diff --git a/src/gallium/drivers/zink/zink_descriptors.c b/src/gallium/drivers/zink/zink_descriptors.c
index 5b8e096fcbb14..d061ab74e5013 100644
--- a/src/gallium/drivers/zink/zink_descriptors.c
+++ b/src/gallium/drivers/zink/zink_descriptors.c
@@ -369,7 +369,7 @@ init_db_template_entry(struct zink_screen *screen, struct zink_shader *shader, e
        entry->db_size = screen->info.db_props.robustStorageTexelBufferDescriptorSize;
        break;
     default:
-       unreachable("unknown type");
+       UNREACHABLE("unknown type");
     }
     (*entry_idx)++;
 }
@@ -417,7 +417,7 @@ init_template_entry(struct zink_shader *shader, enum zink_descriptor_type type,
        entry->stride = sizeof(VkBufferView);
        break;
     default:
-       unreachable("unknown type");
+       UNREACHABLE("unknown type");
     }
     (*entry_idx)++;
 }
@@ -452,7 +452,7 @@ descriptor_program_num_sizes(VkDescriptorPoolSize *sizes, enum zink_descriptor_t
              !!sizes[ZDS_INDEX_STORAGE_TEXELS].descriptorCount;
    default: break;
    }
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 static uint16_t
@@ -471,7 +471,7 @@ descriptor_program_num_sizes_compact(VkDescriptorPoolSize *sizes, unsigned desc_
    case ZINK_DESCRIPTOR_TYPE_IMAGE:
    default: break;
    }
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 /* create all the descriptor objects for a program:
@@ -942,7 +942,7 @@ check_pool_alloc(struct zink_context *ctx, struct zink_descriptor_pool_multi *mp
          }
       }
       if (!mpool->pool)
-         unreachable("out of descriptor memory!");
+         UNREACHABLE("out of descriptor memory!");
    }
    struct zink_descriptor_pool *pool = mpool->pool;
    /* allocate up to $current * 10, e.g., 10 -> 100;
diff --git a/src/gallium/drivers/zink/zink_descriptors.h b/src/gallium/drivers/zink/zink_descriptors.h
index 8280a05f1947f..ea3982bf014a3 100644
--- a/src/gallium/drivers/zink/zink_descriptors.h
+++ b/src/gallium/drivers/zink/zink_descriptors.h
@@ -59,7 +59,7 @@ zink_vktype_to_size_idx(VkDescriptorType type)
       return ZDS_INDEX_STORAGE_TEXELS;
    default: break;
    }
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 static inline enum zink_descriptor_size_index_compact
@@ -84,7 +84,7 @@ zink_vktype_to_size_idx_comp(VkDescriptorType type)
       return ZDS_INDEX_COMP_STORAGE_TEXELS;
    default: break;
    }
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 static inline enum zink_descriptor_size_index
@@ -101,7 +101,7 @@ zink_descriptor_type_to_size_idx(enum zink_descriptor_type type)
       return ZDS_INDEX_STORAGE_IMAGE;
    default: break;
    }
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 static inline enum zink_descriptor_size_index_compact
@@ -116,7 +116,7 @@ zink_descriptor_type_to_size_idx_comp(enum zink_descriptor_type type)
    case ZINK_DESCRIPTOR_TYPE_IMAGE:
    default: break;
    }
-   unreachable("unknown type");
+   UNREACHABLE("unknown type");
 }
 
 /* bindless descriptor bindings have their own struct indexing */
@@ -129,7 +129,7 @@ zink_descriptor_type_from_bindless_index(unsigned idx)
    case 2: return VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
    case 3: return VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
    default:
-      unreachable("unknown index");
+      UNREACHABLE("unknown index");
    }
 }
 
diff --git a/src/gallium/drivers/zink/zink_draw.cpp b/src/gallium/drivers/zink/zink_draw.cpp
index 21e4509feae99..07c249a1ff3ac 100644
--- a/src/gallium/drivers/zink/zink_draw.cpp
+++ b/src/gallium/drivers/zink/zink_draw.cpp
@@ -320,7 +320,7 @@ zink_rast_prim(const struct zink_context *ctx,
       case PIPE_POLYGON_MODE_LINE:
          return MESA_PRIM_LINES;
       default:
-         unreachable("unexpected polygon mode");
+         UNREACHABLE("unexpected polygon mode");
       }
    }
 
@@ -1170,7 +1170,7 @@ zink_invalid_draw_vbo(struct pipe_context *pipe,
                       const struct pipe_draw_start_count_bias *draws,
                       unsigned num_draws)
 {
-   unreachable("vertex shader not bound");
+   UNREACHABLE("vertex shader not bound");
 }
 
 static void
@@ -1181,13 +1181,13 @@ zink_invalid_draw_vertex_state(struct pipe_context *pipe,
                                const struct pipe_draw_start_count_bias *draws,
                                unsigned num_draws)
 {
-   unreachable("vertex shader not bound");
+   UNREACHABLE("vertex shader not bound");
 }
 
 static void
 zink_invalid_launch_grid(struct pipe_context *pctx, const struct pipe_grid_info *info)
 {
-   unreachable("compute shader not bound");
+   UNREACHABLE("compute shader not bound");
 }
 
 #define STAGE_BASE 0
diff --git a/src/gallium/drivers/zink/zink_format.c b/src/gallium/drivers/zink/zink_format.c
index 49257bcd31668..bf12032f97e11 100644
--- a/src/gallium/drivers/zink/zink_format.c
+++ b/src/gallium/drivers/zink/zink_format.c
@@ -258,7 +258,7 @@ zink_format_clamp_channel_color(const struct util_format_description *desc, unio
 
    switch (desc->channel[channel].type) {
    case UTIL_FORMAT_TYPE_VOID:
-      unreachable("handled above");
+      UNREACHABLE("handled above");
       break;
    case UTIL_FORMAT_TYPE_SIGNED:
       if (desc->channel[channel].normalized)
diff --git a/src/gallium/drivers/zink/zink_helpers.h b/src/gallium/drivers/zink/zink_helpers.h
index 9fea18ac31875..0a67b286b85a4 100644
--- a/src/gallium/drivers/zink/zink_helpers.h
+++ b/src/gallium/drivers/zink/zink_helpers.h
@@ -31,7 +31,7 @@ zink_filter(enum pipe_tex_filter filter)
    case PIPE_TEX_FILTER_NEAREST: return VK_FILTER_NEAREST;
    case PIPE_TEX_FILTER_LINEAR: return VK_FILTER_LINEAR;
    }
-   unreachable("unexpected filter");
+   UNREACHABLE("unexpected filter");
 }
 
 #endif
diff --git a/src/gallium/drivers/zink/zink_kopper.c b/src/gallium/drivers/zink/zink_kopper.c
index f2fee4f0fc611..bf31b073cfadd 100644
--- a/src/gallium/drivers/zink/zink_kopper.c
+++ b/src/gallium/drivers/zink/zink_kopper.c
@@ -71,7 +71,7 @@ init_dt_type(struct kopper_displaytarget *cdt)
       break;
 #endif
    default:
-      unreachable("unsupported!");
+      UNREACHABLE("unsupported!");
    }
 }
 
@@ -110,7 +110,7 @@ kopper_CreateSurface(struct zink_screen *screen, struct kopper_displaytarget *cd
    }
 #endif
    default:
-      unreachable("unsupported!");
+      UNREACHABLE("unsupported!");
    }
    if (error != VK_SUCCESS) {
       return VK_NULL_HANDLE;
@@ -226,7 +226,7 @@ find_dt_entry(struct zink_screen *screen, const struct kopper_displaytarget *cdt
    }
 #endif
    default:
-      unreachable("unsupported!");
+      UNREACHABLE("unsupported!");
    }
    return he;
 }
@@ -328,7 +328,7 @@ kopper_CreateSwapchain(struct zink_screen *screen, struct kopper_displaytarget *
       cswap->scci.imageExtent.height = h;
       break;
    default:
-      unreachable("unknown display platform");
+      UNREACHABLE("unknown display platform");
    }
 
    error = VKSCR(CreateSwapchainKHR)(screen->dev, &cswap->scci, NULL,
@@ -434,7 +434,7 @@ zink_kopper_displaytarget_create(struct zink_screen *screen, unsigned tex_usage,
             _mesa_hash_table_init(&screen->dts, screen, _mesa_hash_pointer, _mesa_key_pointer_equal);
             break;
          default:
-            unreachable("unknown kopper type");
+            UNREACHABLE("unknown kopper type");
          }
       } else {
          he = find_dt_entry(screen, &k);
@@ -504,7 +504,7 @@ zink_kopper_displaytarget_create(struct zink_screen *screen, unsigned tex_usage,
    }
 #endif
    default:
-      unreachable("unsupported!");
+      UNREACHABLE("unsupported!");
    }
    simple_mtx_unlock(&screen->dt_lock);
 
@@ -602,7 +602,7 @@ kopper_acquire(struct zink_screen *screen, struct zink_resource *res, uint64_t t
          }
          if (ret == VK_NOT_READY || ret == VK_TIMEOUT) {
             if (timeout > 1000000)
-               unreachable("kopper_acquire: updated timeout after failure has become unreasonable large");
+               UNREACHABLE("kopper_acquire: updated timeout after failure has become unreasonable large");
             timeout += 4000;
             continue;
          }
diff --git a/src/gallium/drivers/zink/zink_lower_cubemap_to_array.c b/src/gallium/drivers/zink/zink_lower_cubemap_to_array.c
index 4ce1ceb358e38..a63bb0602ed79 100644
--- a/src/gallium/drivers/zink/zink_lower_cubemap_to_array.c
+++ b/src/gallium/drivers/zink/zink_lower_cubemap_to_array.c
@@ -496,7 +496,7 @@ lower_cubemap_to_array_tex(nir_builder *b, nir_tex_instr *tex)
    case nir_texop_txs:
       return lower_cube_txs(b, tex);
    default:
-      unreachable("Unsupported cupe map texture operation");
+      UNREACHABLE("Unsupported cupe map texture operation");
    }
 }
 
diff --git a/src/gallium/drivers/zink/zink_program.c b/src/gallium/drivers/zink/zink_program.c
index 933382734318a..65191c75575f9 100644
--- a/src/gallium/drivers/zink/zink_program.c
+++ b/src/gallium/drivers/zink/zink_program.c
@@ -1423,7 +1423,7 @@ print_pipeline_stats(struct zink_screen *screen, VkPipeline pipeline, struct uti
             fprintf(f, "%g %s", stats[i].value.f64, stats[i].name);
             break;
          default:
-            unreachable("unknown statistic");
+            UNREACHABLE("unknown statistic");
          }
       }
 
@@ -1572,7 +1572,7 @@ zink_program_descriptor_is_buffer(struct zink_context *ctx, gl_shader_stage stag
       break;
    }
    default:
-      unreachable("unknown shader type");
+      UNREACHABLE("unknown shader type");
    }
    if (!zs)
       return false;
@@ -1841,7 +1841,7 @@ gs_output_to_reduced_prim_type(struct shader_info *info)
       return MESA_PRIM_TRIANGLES;
 
    default:
-      unreachable("unexpected output primitive type");
+      UNREACHABLE("unexpected output primitive type");
    }
 }
 
@@ -2166,7 +2166,7 @@ print_exe_stages(VkShaderStageFlags stages)
       return "FS";
    if (stages == VK_SHADER_STAGE_COMPUTE_BIT)
       return "CS";
-   unreachable("unhandled combination of stages!");
+   UNREACHABLE("unhandled combination of stages!");
 }
 
 static void
diff --git a/src/gallium/drivers/zink/zink_program.h b/src/gallium/drivers/zink/zink_program.h
index 638b588db3c8b..6dd523318996b 100644
--- a/src/gallium/drivers/zink/zink_program.h
+++ b/src/gallium/drivers/zink/zink_program.h
@@ -55,7 +55,7 @@ zink_desc_type_from_vktype(VkDescriptorType type)
    case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
       return ZINK_DESCRIPTOR_TYPE_IMAGE;
    default:
-      unreachable("unhandled descriptor type");
+      UNREACHABLE("unhandled descriptor type");
    }
 }
 
@@ -100,7 +100,7 @@ zink_primitive_topology(enum mesa_prim mode)
       return VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY;
 
    default:
-      unreachable("unexpected enum mesa_prim");
+      UNREACHABLE("unexpected enum mesa_prim");
    }
 }
 
diff --git a/src/gallium/drivers/zink/zink_query.c b/src/gallium/drivers/zink/zink_query.c
index 3a6e4a36e0056..c818533b66128 100644
--- a/src/gallium/drivers/zink/zink_query.c
+++ b/src/gallium/drivers/zink/zink_query.c
@@ -280,7 +280,7 @@ get_num_results(struct zink_query *q)
    default:
       debug_printf("unknown query: %s\n",
                    util_str_query_type(q->type, true));
-      unreachable("zink: unknown query type");
+      UNREACHABLE("zink: unknown query type");
    }
 }
 
@@ -328,7 +328,7 @@ convert_query_type(struct zink_screen *screen, enum pipe_query_type query_type,
    default:
       debug_printf("unknown query: %s\n",
                    util_str_query_type(query_type, true));
-      unreachable("zink: unknown query type");
+      UNREACHABLE("zink: unknown query type");
    }
 }
 
@@ -651,7 +651,7 @@ check_query_results(struct zink_query *query, union pipe_query_result *result,
       default:
          debug_printf("unhandled query type: %s\n",
                       util_str_query_type(query->type, true));
-         unreachable("unexpected query type");
+         UNREACHABLE("unexpected query type");
       }
    }
 }
diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index 829a428fe4a46..3c425e1f2a027 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -780,10 +780,10 @@ init_ici(struct zink_screen *screen, VkImageCreateInfo *ici, const struct pipe_r
       break;
 
    case PIPE_BUFFER:
-      unreachable("PIPE_BUFFER should already be handled");
+      UNREACHABLE("PIPE_BUFFER should already be handled");
 
    default:
-      unreachable("Unknown target");
+      UNREACHABLE("Unknown target");
    }
 
    if (screen->info.have_EXT_sample_locations &&
@@ -884,7 +884,7 @@ get_format_feature_flags(VkImageCreateInfo ici, struct zink_screen *screen, cons
          feats &= screen->modifier_props[templ->format].pDrmFormatModifierProperties[i].drmFormatModifierTilingFeatures;
       break;
    default:
-         unreachable("unknown tiling");
+         UNREACHABLE("unknown tiling");
    }
    return feats;
 }
@@ -916,7 +916,7 @@ get_export_flags(struct zink_screen *screen, const struct pipe_resource *templ,
           alloc_info->whandle->type == ZINK_EXTERNAL_MEMORY_HANDLE)
          needs_export |= true;
       else
-         unreachable("unknown handle type");
+         UNREACHABLE("unknown handle type");
    }
    if (needs_export) {
       if (alloc_info->whandle && alloc_info->whandle->type == ZINK_EXTERNAL_MEMORY_HANDLE) {
@@ -1571,7 +1571,7 @@ resource_object_create(struct zink_screen *screen, const struct pipe_resource *t
       FREE(obj);
       return NULL;
    default:
-      unreachable("Invalid create object result code");
+      UNREACHABLE("Invalid create object result code");
    }
 }
 
@@ -1841,7 +1841,7 @@ zink_resource_get_param(struct pipe_screen *pscreen, struct pipe_context *pctx,
          aspect = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
          break;
       default:
-         unreachable("how many planes you got in this thing?");
+         UNREACHABLE("how many planes you got in this thing?");
       }
    } else if (util_format_is_yuv(pres->format)) {
       aspect = VK_IMAGE_ASPECT_PLANE_0_BIT;
@@ -3136,7 +3136,7 @@ resource_object_add_bind(struct zink_context *ctx, struct zink_resource *res, un
    if (res->base.b.bind & bind)
       return true;
    if (res->obj->is_buffer) {
-      unreachable("zink: all buffers should have this bit");
+      UNREACHABLE("zink: all buffers should have this bit");
       return true;
    }
    assert(!res->obj->dt);
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index 2f353b353fc95..e225af577147a 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -1318,7 +1318,7 @@ zink_is_format_supported(struct pipe_screen *pscreen,
          break;
 
       default:
-         unreachable("unknown texture target");
+         UNREACHABLE("unknown texture target");
       }
       u_foreach_bit(b, bind) {
          switch (1<<b) {
diff --git a/src/gallium/drivers/zink/zink_state.c b/src/gallium/drivers/zink/zink_state.c
index 2f048d491457e..6273c4fe1a634 100644
--- a/src/gallium/drivers/zink/zink_state.c
+++ b/src/gallium/drivers/zink/zink_state.c
@@ -280,7 +280,7 @@ blend_factor(enum pipe_blendfactor factor)
    case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
       return VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;
    }
-   unreachable("unexpected blend factor");
+   UNREACHABLE("unexpected blend factor");
 }
 
 
@@ -294,7 +294,7 @@ blend_op(enum pipe_blend_func func)
    case PIPE_BLEND_MIN: return VK_BLEND_OP_MIN;
    case PIPE_BLEND_MAX: return VK_BLEND_OP_MAX;
    }
-   unreachable("unexpected blend function");
+   UNREACHABLE("unexpected blend function");
 }
 
 static VkLogicOp
@@ -318,7 +318,7 @@ logic_op(enum pipe_logicop func)
    case PIPE_LOGICOP_OR: return VK_LOGIC_OP_OR;
    case PIPE_LOGICOP_SET: return VK_LOGIC_OP_SET;
    }
-   unreachable("unexpected logicop function");
+   UNREACHABLE("unexpected logicop function");
 }
 
 /* from iris */
@@ -473,7 +473,7 @@ compare_op(enum pipe_compare_func func)
    case PIPE_FUNC_GEQUAL: return VK_COMPARE_OP_GREATER_OR_EQUAL;
    case PIPE_FUNC_ALWAYS: return VK_COMPARE_OP_ALWAYS;
    }
-   unreachable("unexpected func");
+   UNREACHABLE("unexpected func");
 }
 
 static VkStencilOp
@@ -489,7 +489,7 @@ stencil_op(enum pipe_stencil_op op)
    case PIPE_STENCIL_OP_DECR_WRAP: return VK_STENCIL_OP_DECREMENT_AND_WRAP;
    case PIPE_STENCIL_OP_INVERT: return VK_STENCIL_OP_INVERT;
    }
-   unreachable("unexpected op");
+   UNREACHABLE("unexpected op");
 }
 
 static VkStencilOpState
diff --git a/src/gallium/drivers/zink/zink_surface.c b/src/gallium/drivers/zink/zink_surface.c
index c45d2784db64c..6d12138b67fc1 100644
--- a/src/gallium/drivers/zink/zink_surface.c
+++ b/src/gallium/drivers/zink/zink_surface.c
@@ -60,7 +60,7 @@ vkviewtype_from_pipe(enum pipe_texture_target target, bool need_2D)
       return VK_IMAGE_VIEW_TYPE_3D;
 
    default:
-      unreachable("unsupported target");
+      UNREACHABLE("unsupported target");
    }
 }
 
@@ -189,7 +189,7 @@ componentmapping_to_pipe(VkComponentSwizzle c)
    case VK_COMPONENT_SWIZZLE_A:
       return PIPE_SWIZZLE_W;
    default:
-      unreachable("unknown swizzle");
+      UNREACHABLE("unknown swizzle");
    }
 }
 
diff --git a/src/gallium/drivers/zink/zink_synchronization.cpp b/src/gallium/drivers/zink/zink_synchronization.cpp
index 08da456445e15..6d48159de2917 100644
--- a/src/gallium/drivers/zink/zink_synchronization.cpp
+++ b/src/gallium/drivers/zink/zink_synchronization.cpp
@@ -594,7 +594,7 @@ zink_pipeline_flags_from_stage(VkShaderStageFlagBits stage)
    case VK_SHADER_STAGE_COMPUTE_BIT:
       return VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
    default:
-      unreachable("unknown shader stage bit");
+      UNREACHABLE("unknown shader stage bit");
    }
 }
 
diff --git a/src/gallium/frontends/dri/dri2.c b/src/gallium/frontends/dri/dri2.c
index ac80d819495a2..9e83343359acc 100644
--- a/src/gallium/frontends/dri/dri2.c
+++ b/src/gallium/frontends/dri/dri2.c
@@ -617,7 +617,7 @@ to_dri_compression_rate(uint32_t rate)
    case 11: return __DRI_FIXED_RATE_COMPRESSION_11BPC;
    case 12: return __DRI_FIXED_RATE_COMPRESSION_12BPC;
    default:
-      unreachable("invalid compression fixed-rate value");
+      UNREACHABLE("invalid compression fixed-rate value");
    }
 }
 
@@ -642,7 +642,7 @@ from_dri_compression_rate(enum __DRIFixedRateCompression rate)
    case __DRI_FIXED_RATE_COMPRESSION_11BPC: return 11;
    case __DRI_FIXED_RATE_COMPRESSION_12BPC: return 12;
    default:
-      unreachable("invalid compression fixed-rate value");
+      UNREACHABLE("invalid compression fixed-rate value");
    }
 }
 
diff --git a/src/gallium/frontends/dri/dri_util.c b/src/gallium/frontends/dri/dri_util.c
index 21f17ef9065ca..56bff49d0e5a1 100644
--- a/src/gallium/frontends/dri/dri_util.c
+++ b/src/gallium/frontends/dri/dri_util.c
@@ -139,7 +139,7 @@ driCreateNewScreen3(int scrn, int fd,
       pscreen = dri_swrast_kms_init_screen(screen, driver_name_is_inferred);
       break;
    default:
-      unreachable("unknown dri screen type");
+      UNREACHABLE("unknown dri screen type");
    }
    if (pscreen == NULL) {
       dri_destroy_screen(screen);
diff --git a/src/gallium/frontends/dri/loader_dri3_helper.c b/src/gallium/frontends/dri/loader_dri3_helper.c
index 8b5391e08509b..c5f8000086265 100644
--- a/src/gallium/frontends/dri/loader_dri3_helper.c
+++ b/src/gallium/frontends/dri/loader_dri3_helper.c
@@ -2144,7 +2144,7 @@ dri3_free_buffers(struct dri_drawable *driDrawable,
       n_id = (draw->cur_blit_source == LOADER_DRI3_FRONT_ID) ? 0 : 1;
       break;
    default:
-      unreachable("unhandled buffer_type");
+      UNREACHABLE("unhandled buffer_type");
    }
 
    for (buf_id = first_id; buf_id < first_id + n_id; buf_id++)
diff --git a/src/gallium/frontends/lavapipe/lvp_acceleration_structure.c b/src/gallium/frontends/lavapipe/lvp_acceleration_structure.c
index d8320989109bc..7e08c7ff486e3 100644
--- a/src/gallium/frontends/lavapipe/lvp_acceleration_structure.c
+++ b/src/gallium/frontends/lavapipe/lvp_acceleration_structure.c
@@ -605,7 +605,7 @@ lvp_WriteAccelerationStructuresPropertiesKHR(
    const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType,
    size_t dataSize, void *pData, size_t stride)
 {
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return VK_ERROR_FEATURE_NOT_PRESENT;
 }
 
@@ -615,7 +615,7 @@ lvp_BuildAccelerationStructuresKHR(
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
 {
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return VK_ERROR_FEATURE_NOT_PRESENT;
 }
 
@@ -635,7 +635,7 @@ VKAPI_ATTR VkResult VKAPI_CALL
 lvp_CopyAccelerationStructureKHR(VkDevice _device, VkDeferredOperationKHR deferredOperation,
                                  const VkCopyAccelerationStructureInfoKHR *pInfo)
 {
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return VK_ERROR_FEATURE_NOT_PRESENT;
 }
 
@@ -643,7 +643,7 @@ VKAPI_ATTR VkResult VKAPI_CALL
 lvp_CopyMemoryToAccelerationStructureKHR(VkDevice _device, VkDeferredOperationKHR deferredOperation,
                                          const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
 {
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return VK_ERROR_FEATURE_NOT_PRESENT;
 }
 
@@ -651,7 +651,7 @@ VKAPI_ATTR VkResult VKAPI_CALL
 lvp_CopyAccelerationStructureToMemoryKHR(VkDevice _device, VkDeferredOperationKHR deferredOperation,
                                          const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
 {
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return VK_ERROR_FEATURE_NOT_PRESENT;
 }
 
diff --git a/src/gallium/frontends/lavapipe/lvp_conv.h b/src/gallium/frontends/lavapipe/lvp_conv.h
index 31bd5af7b25f8..8fda41185f99f 100644
--- a/src/gallium/frontends/lavapipe/lvp_conv.h
+++ b/src/gallium/frontends/lavapipe/lvp_conv.h
@@ -129,6 +129,6 @@ static inline enum pipe_swizzle vk_conv_swizzle(VkComponentSwizzle swiz,
    case VK_COMPONENT_SWIZZLE_IDENTITY:
       return identity;
    default:
-      unreachable("Invalid VkComponentSwizzle value");
+      UNREACHABLE("Invalid VkComponentSwizzle value");
    }
 }
diff --git a/src/gallium/frontends/lavapipe/lvp_descriptor_set.c b/src/gallium/frontends/lavapipe/lvp_descriptor_set.c
index 0a2cea4c41027..6089e8d85168c 100644
--- a/src/gallium/frontends/lavapipe/lvp_descriptor_set.c
+++ b/src/gallium/frontends/lavapipe/lvp_descriptor_set.c
@@ -637,7 +637,7 @@ VKAPI_ATTR void VKAPI_CALL lvp_UpdateDescriptorSets(
          break;
 
       default:
-         unreachable("Unsupported descriptor type");
+         UNREACHABLE("Unsupported descriptor type");
          break;
       }
    }
@@ -929,7 +929,7 @@ lvp_descriptor_set_update_with_template(VkDevice _device, VkDescriptorSet descri
          }
 
          default:
-            unreachable("Unsupported descriptor type");
+            UNREACHABLE("Unsupported descriptor type");
             break;
          }
 
@@ -992,7 +992,7 @@ VKAPI_ATTR void VKAPI_CALL lvp_GetDescriptorEXT(
 
    switch (pCreateInfo->type) {
    case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK: {
-      unreachable("this is a spec violation");
+      UNREACHABLE("this is a spec violation");
       break;
    }
    case VK_DESCRIPTOR_TYPE_SAMPLER: {
@@ -1131,7 +1131,7 @@ VKAPI_ATTR void VKAPI_CALL lvp_GetDescriptorEXT(
       break;
    }
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
       break;
    }
 }
diff --git a/src/gallium/frontends/lavapipe/lvp_device.c b/src/gallium/frontends/lavapipe/lvp_device.c
index 8ebc58f511715..d8815c9debb89 100644
--- a/src/gallium/frontends/lavapipe/lvp_device.c
+++ b/src/gallium/frontends/lavapipe/lvp_device.c
@@ -2362,7 +2362,7 @@ lvp_image_bind(struct lvp_device *device,
    if (!mem) {
 #if DETECT_OS_ANDROID
       /* TODO handle VkNativeBufferANDROID */
-      unreachable("VkBindImageMemoryInfo with no memory");
+      UNREACHABLE("VkBindImageMemoryInfo with no memory");
 #else
       const VkBindImageMemorySwapchainInfoKHR *swapchain_info =
          vk_find_struct_const(bind_info->pNext,
diff --git a/src/gallium/frontends/lavapipe/lvp_device_generated_commands.c b/src/gallium/frontends/lavapipe/lvp_device_generated_commands.c
index 0b9a2ed1da192..eed72bc3a3693 100644
--- a/src/gallium/frontends/lavapipe/lvp_device_generated_commands.c
+++ b/src/gallium/frontends/lavapipe/lvp_device_generated_commands.c
@@ -129,7 +129,7 @@ get_token_info_size(VkIndirectCommandsTokenTypeEXT type)
       return 0;
    default: break;
    }
-   unreachable("unknown token type");
+   UNREACHABLE("unknown token type");
 }
 
 VKAPI_ATTR VkResult VKAPI_CALL lvp_CreateIndirectCommandsLayoutEXT(
@@ -240,13 +240,13 @@ lvp_ext_dgc_token_to_cmd_type(const struct lvp_indirect_command_layout_ext *elay
       return VK_CMD_TRACE_RAYS_KHR;
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT:
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT:
-      unreachable("unsupported NV mesh");
+      UNREACHABLE("unsupported NV mesh");
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT:
       return VK_CMD_DRAW_MESH_TASKS_EXT;
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT:
       return VK_CMD_DRAW_MESH_TASKS_INDIRECT_EXT;
    default:
-      unreachable("unknown token type");
+      UNREACHABLE("unknown token type");
    }
    return UINT32_MAX;
 }
@@ -293,7 +293,7 @@ lvp_ext_dgc_token_size(const struct lvp_indirect_command_layout_ext *elayout, co
    case VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT:
       break;
    default:
-      unreachable("unknown type!");
+      UNREACHABLE("unknown type!");
    }
    return size;
 }
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 98498ad266c4d..0d5c780bbed12 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -695,7 +695,7 @@ unbind_graphics_stages(struct rendering_state *state, VkShaderStageFlagBits shad
             state->pctx->bind_ms_state(state->pctx, NULL);
          break;
       default:
-         unreachable("what stage is this?!");
+         UNREACHABLE("what stage is this?!");
       }
       state->shaders[stage] = NULL;
    }
@@ -960,7 +960,7 @@ static void handle_graphics_pipeline(struct lvp_pipeline *pipeline,
             state->velem.velems[a].instance_divisor = d ? d : UINT32_MAX;
             break;
          default:
-            unreachable("Invalid vertex input rate");
+            UNREACHABLE("Invalid vertex input rate");
          }
 
          if (!BITSET_TEST(ps->dynamic, MESA_VK_DYNAMIC_VI_BINDING_STRIDES)) {
@@ -2360,7 +2360,7 @@ find_depth_format(VkFormat format, VkImageAspectFlagBits aspect)
       case VK_FORMAT_D16_UNORM_S8_UINT:
          return PIPE_FORMAT_Z16_UNORM;
       default:
-         unreachable("unsupported format/aspect combo");
+         UNREACHABLE("unsupported format/aspect combo");
       }
    }
    assert(aspect == VK_IMAGE_ASPECT_STENCIL_BIT);
@@ -2371,7 +2371,7 @@ find_depth_format(VkFormat format, VkImageAspectFlagBits aspect)
    case VK_FORMAT_S8_UINT:
       return PIPE_FORMAT_S8_UINT;
    default:
-      unreachable("unsupported format/aspect combo");
+      UNREACHABLE("unsupported format/aspect combo");
    }
 }
 
@@ -4041,7 +4041,7 @@ process_sequence_ext(struct rendering_state *state,
                cmd->u.bind_index_buffer2.index_type = VK_INDEX_TYPE_UINT16;
                break;
             default:
-               unreachable("unknown DXGI index type!");
+               UNREACHABLE("unknown DXGI index type!");
             }
          }
          cmd->u.bind_index_buffer2.size = data->size;
@@ -4150,7 +4150,7 @@ process_sequence_ext(struct rendering_state *state,
          break;
       }
       default:
-         unreachable("unknown token type");
+         UNREACHABLE("unknown token type");
          break;
       }
       size += lvp_ext_dgc_token_size(elayout, token);
@@ -4565,7 +4565,7 @@ handle_write_acceleration_structures_properties(struct vk_cmd_queue_entry *cmd,
          break;
       }
       default:
-         unreachable("Unsupported query type");
+         UNREACHABLE("Unsupported query type");
       }
    }
 }
@@ -5350,7 +5350,7 @@ static void lvp_execute_cmd_buffer(struct list_head *cmds,
          break;
       default:
          fprintf(stderr, "Unsupported command %s\n", vk_cmd_queue_type_names[cmd->type]);
-         unreachable("Unsupported command");
+         UNREACHABLE("Unsupported command");
          break;
       }
       did_flush = false;
diff --git a/src/gallium/frontends/lavapipe/lvp_formats.c b/src/gallium/frontends/lavapipe/lvp_formats.c
index 755563b1b1647..c11b7787c2a6a 100644
--- a/src/gallium/frontends/lavapipe/lvp_formats.c
+++ b/src/gallium/frontends/lavapipe/lvp_formats.c
@@ -313,7 +313,7 @@ static VkResult lvp_get_image_format_properties(struct lvp_physical_device *phys
         goto unsupported;
       format_feature_flags = format_props.optimalTilingFeatures;
    } else {
-      unreachable("bad VkImageTiling");
+      UNREACHABLE("bad VkImageTiling");
    }
 
    if (format_feature_flags == 0)
@@ -323,7 +323,7 @@ static VkResult lvp_get_image_format_properties(struct lvp_physical_device *phys
    uint32_t max_layers = physical_device->pscreen->caps.max_texture_array_layers;
    switch (info->type) {
    default:
-      unreachable("bad vkimage type\n");
+      UNREACHABLE("bad vkimage type\n");
    case VK_IMAGE_TYPE_1D:
       if (util_format_is_compressed(pformat))
          goto unsupported;
diff --git a/src/gallium/frontends/lavapipe/lvp_pipeline.c b/src/gallium/frontends/lavapipe/lvp_pipeline.c
index e0c6cc7328243..f1493e4cb71ab 100644
--- a/src/gallium/frontends/lavapipe/lvp_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_pipeline.c
@@ -604,7 +604,7 @@ lvp_shader_compile_stage(struct lvp_device *device, struct lvp_shader *shader, n
       case MESA_SHADER_MESH:
          return device->queue.ctx->create_ms_state(device->queue.ctx, &shstate);
       default:
-         unreachable("illegal shader");
+         UNREACHABLE("illegal shader");
          break;
       }
    }
diff --git a/src/gallium/frontends/lavapipe/lvp_private.h b/src/gallium/frontends/lavapipe/lvp_private.h
index a3e8a8d39b076..fe125db3c74f8 100644
--- a/src/gallium/frontends/lavapipe/lvp_private.h
+++ b/src/gallium/frontends/lavapipe/lvp_private.h
@@ -463,7 +463,7 @@ lvp_pipeline_type_from_bind_point(VkPipelineBindPoint bind_point)
 #ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX: return LVP_PIPELINE_EXEC_GRAPH;
 #endif
-   default: unreachable("Unsupported VkPipelineBindPoint");
+   default: UNREACHABLE("Unsupported VkPipelineBindPoint");
    }
 }
 
diff --git a/src/gallium/frontends/lavapipe/lvp_ray_tracing_pipeline.c b/src/gallium/frontends/lavapipe/lvp_ray_tracing_pipeline.c
index 6c100d81f64ab..4d7da73f76fe1 100644
--- a/src/gallium/frontends/lavapipe/lvp_ray_tracing_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_ray_tracing_pipeline.c
@@ -54,7 +54,7 @@ lvp_init_ray_tracing_groups(struct lvp_pipeline *pipeline,
          }
          break;
       default:
-         unreachable("Unimplemented VkRayTracingShaderGroupTypeKHR");
+         UNREACHABLE("Unimplemented VkRayTracingShaderGroupTypeKHR");
       }
 
       dst->handle.index = p_atomic_inc_return(&pipeline->device->group_handle_alloc);
@@ -430,7 +430,7 @@ lvp_call_ray_tracing_stage(nir_builder *b, struct lvp_ray_tracing_pipeline_compi
       compiler->callable_size = MAX2(compiler->callable_size, stage->scratch_size);
       break;
    default:
-      unreachable("Invalid ray tracing stage");
+      UNREACHABLE("Invalid ray tracing stage");
       break;
    }
 }
diff --git a/src/gallium/frontends/lavapipe/nir/lvp_nir_lower_ray_queries.c b/src/gallium/frontends/lavapipe/nir/lvp_nir_lower_ray_queries.c
index 3ca66b9c5c408..e0ecb95df4efe 100644
--- a/src/gallium/frontends/lavapipe/nir/lvp_nir_lower_ray_queries.c
+++ b/src/gallium/frontends/lavapipe/nir/lvp_nir_lower_ray_queries.c
@@ -437,7 +437,7 @@ lower_rq_load(nir_builder *b, nir_def *index, nir_intrinsic_instr *instr,
       return lvp_load_vertex_position(
          b, rq_load_var(b, index, intersection->primitive_addr), column);
    default:
-      unreachable("Invalid nir_ray_query_value!");
+      UNREACHABLE("Invalid nir_ray_query_value!");
    }
 
    return NULL;
@@ -635,7 +635,7 @@ lvp_nir_lower_ray_queries(struct nir_shader *shader)
                lower_rq_terminate(&builder, index, intrinsic, vars);
                break;
             default:
-               unreachable("Unsupported ray query intrinsic!");
+               UNREACHABLE("Unsupported ray query intrinsic!");
             }
 
             if (new_dest)
diff --git a/src/gallium/frontends/mediafoundation/encode_h264.cpp b/src/gallium/frontends/mediafoundation/encode_h264.cpp
index 631a0db2dfde0..487b2d2f42b0f 100644
--- a/src/gallium/frontends/mediafoundation/encode_h264.cpp
+++ b/src/gallium/frontends/mediafoundation/encode_h264.cpp
@@ -63,7 +63,7 @@ ComputeCroppingRect( const UINT32 textureWidth,
             break;
          default:
          {
-            unreachable( "Unsupported chroma format idc" );
+            UNREACHABLE( "Unsupported chroma format idc" );
          }
          break;
       }
@@ -1054,7 +1054,7 @@ GetMaxDPBSize( int width, int height, eAVEncH264VLevel level_idc )
          maxDpbMbs = 696320;
          break;
       default:
-         unreachable( "unexpected level_idc" );
+         UNREACHABLE( "unexpected level_idc" );
          break;
    }
    int maxDpbSize = ( maxDpbMbs / numMbs );
diff --git a/src/gallium/frontends/mediafoundation/encode_hevc.cpp b/src/gallium/frontends/mediafoundation/encode_hevc.cpp
index e2a5e3d870bb5..5afcf3d5cacdd 100644
--- a/src/gallium/frontends/mediafoundation/encode_hevc.cpp
+++ b/src/gallium/frontends/mediafoundation/encode_hevc.cpp
@@ -67,7 +67,7 @@ ComputeCroppingRect( const UINT32 textureWidth,
             break;
          default:
          {
-            unreachable( "Unsupported chroma format idc" );
+            UNREACHABLE( "Unsupported chroma format idc" );
          }
          break;
       }
@@ -843,7 +843,7 @@ LevelToLumaPS( eAVEncH265VLevel level_idc )
          maxLumaPs = 35651584;
          break;
       default:
-         unreachable( "unexpected level_idc" );
+         UNREACHABLE( "unexpected level_idc" );
          break;
    }
    return maxLumaPs;
diff --git a/src/gallium/frontends/mediafoundation/mfpipeinterop.cpp b/src/gallium/frontends/mediafoundation/mfpipeinterop.cpp
index d25a64de4fd6e..b17e2ff86aee4 100644
--- a/src/gallium/frontends/mediafoundation/mfpipeinterop.cpp
+++ b/src/gallium/frontends/mediafoundation/mfpipeinterop.cpp
@@ -314,7 +314,7 @@ GetChromaFormatIdc( enum pipe_format pipeFormat )
          return 3;
       default:
       {
-         unreachable( "Unsupported pipe video format" );
+         UNREACHABLE( "Unsupported pipe video format" );
       }
       break;
    }
@@ -349,7 +349,7 @@ ConvertProfileToFormat( enum pipe_video_profile profile )
          return PIPE_FORMAT_Y410;
       default:
       {
-         unreachable( "Unsupported pipe video profile" );
+         UNREACHABLE( "Unsupported pipe video profile" );
       }
       break;
    }
@@ -383,7 +383,7 @@ ConvertProfileToSubtype( enum pipe_video_profile profile )
          return MFVideoFormat_Y410;
       default:
       {
-         unreachable( "Unsupported pipe video profile" );
+         UNREACHABLE( "Unsupported pipe video profile" );
       }
       break;
    }
@@ -434,7 +434,7 @@ ConvertPipeH2645FrameTypeToString( pipe_h2645_enc_picture_type picType )
       break;
       default:
       {
-         unreachable( "Unsupported pipe_h2645_enc_picture_type" );
+         UNREACHABLE( "Unsupported pipe_h2645_enc_picture_type" );
       }
       break;
    }
diff --git a/src/gallium/frontends/mediafoundation/reference_frames_tracker_h264.cpp b/src/gallium/frontends/mediafoundation/reference_frames_tracker_h264.cpp
index 9da59680fc73f..f4111359d8955 100644
--- a/src/gallium/frontends/mediafoundation/reference_frames_tracker_h264.cpp
+++ b/src/gallium/frontends/mediafoundation/reference_frames_tracker_h264.cpp
@@ -270,7 +270,7 @@ reference_frames_tracker_h264::begin_frame( reference_frames_tracker_dpb_async_t
             assert( entryToRemove != m_PrevFramesInfos.end() );
             if( entryToRemove == m_PrevFramesInfos.end() )
             {
-               unreachable( "Unexpected zero STR" );
+               UNREACHABLE( "Unexpected zero STR" );
             }
             ( pAsyncDPBToken )->dpb_buffers_to_release.push_back( entryToRemove->buffer );
             if( m_upTwoPassDPBManager )
@@ -295,7 +295,7 @@ reference_frames_tracker_h264::begin_frame( reference_frames_tracker_dpb_async_t
             assert( entryToRemove != m_PrevFramesInfos.end() );
             if( entryToRemove == m_PrevFramesInfos.end() )
             {
-               unreachable( "Unexpected LTR replacement in Bitmap but not in PrevFramesInfos" );
+               UNREACHABLE( "Unexpected LTR replacement in Bitmap but not in PrevFramesInfos" );
             }
             ( pAsyncDPBToken )->dpb_buffers_to_release.push_back( entryToRemove->buffer );
             if( m_upTwoPassDPBManager )
diff --git a/src/gallium/frontends/mediafoundation/reference_frames_tracker_hevc.cpp b/src/gallium/frontends/mediafoundation/reference_frames_tracker_hevc.cpp
index 4168e9cab5d42..03bc50a81e706 100644
--- a/src/gallium/frontends/mediafoundation/reference_frames_tracker_hevc.cpp
+++ b/src/gallium/frontends/mediafoundation/reference_frames_tracker_hevc.cpp
@@ -221,7 +221,7 @@ reference_frames_tracker_hevc::begin_frame( reference_frames_tracker_dpb_async_t
          assert( entryToRemove != m_PrevFramesInfos.end() );
          if( entryToRemove == m_PrevFramesInfos.end() )
          {
-            unreachable( "Unexpected zero STR" );
+            UNREACHABLE( "Unexpected zero STR" );
          }
          ( pAsyncDPBToken )->dpb_buffers_to_release.push_back( entryToRemove->buffer );
          if( m_upTwoPassDPBManager )
@@ -245,7 +245,7 @@ reference_frames_tracker_hevc::begin_frame( reference_frames_tracker_dpb_async_t
             assert( entryToRemove != m_PrevFramesInfos.end() );
             if( entryToRemove == m_PrevFramesInfos.end() )
             {
-               unreachable( "Unexpected LTR replacement in Bitmap but not in PrevFramesInfos" );
+               UNREACHABLE( "Unexpected LTR replacement in Bitmap but not in PrevFramesInfos" );
             }
             ( pAsyncDPBToken )->dpb_buffers_to_release.push_back( entryToRemove->buffer );
             if( m_upTwoPassDPBManager )
diff --git a/src/gallium/frontends/teflon/tfl_device.c b/src/gallium/frontends/teflon/tfl_device.c
index 2e03beb1123ea..a21f95ba68df7 100644
--- a/src/gallium/frontends/teflon/tfl_device.c
+++ b/src/gallium/frontends/teflon/tfl_device.c
@@ -89,7 +89,7 @@ create_resource(struct pipe_context *context, TfLiteTensor tensor)
       bytes = 8;
       break;
    default:
-      unreachable("Unsupported TF type");
+      UNREACHABLE("Unsupported TF type");
    }
 
    return pipe_buffer_create_with_data(context, 0, PIPE_USAGE_DEFAULT, size * bytes, tensor.data.data);
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.cpp b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.cpp
index 7d5005be04cf0..b88bdcdd9894e 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.cpp
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.cpp
@@ -942,7 +942,7 @@ amdgpu_cs_create(struct radeon_cmdbuf *rcs,
          acs->queue_index = AMDGPU_QUEUE_SDMA;
          break;
       default:
-         unreachable("invalid IP type");
+         UNREACHABLE("invalid IP type");
       }
 
       assert(acs->queue_index < AMDGPU_MAX_QUEUES);
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
index 88e25eddc5203..5a77abd090bc9 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
@@ -324,7 +324,7 @@ radeon_to_amdgpu_pstate(enum radeon_ctx_pstate pstate)
    case RADEON_CTX_PSTATE_PEAK:
       return AMDGPU_CTX_STABLE_PSTATE_PEAK;
    default:
-      unreachable("Invalid pstate");
+      UNREACHABLE("Invalid pstate");
    }
 }
 
diff --git a/src/gallium/winsys/etnaviv/drm/etnaviv_drm_winsys.c b/src/gallium/winsys/etnaviv/drm/etnaviv_drm_winsys.c
index 6c273c06a6252..946113625a85f 100644
--- a/src/gallium/winsys/etnaviv/drm/etnaviv_drm_winsys.c
+++ b/src/gallium/winsys/etnaviv/drm/etnaviv_drm_winsys.c
@@ -71,7 +71,7 @@ screen_create(int gpu_fd, const struct pipe_screen_config *config, struct render
          }
          break;
       default:
-         unreachable("invalid core type");
+         UNREACHABLE("invalid core type");
       }
 
       etna_gpu_del(core);
diff --git a/src/gallium/winsys/nouveau/drm/nouveau.c b/src/gallium/winsys/nouveau/drm/nouveau.c
index 27cbdc10033cc..e0277908fbdb7 100644
--- a/src/gallium/winsys/nouveau/drm/nouveau.c
+++ b/src/gallium/winsys/nouveau/drm/nouveau.c
@@ -425,7 +425,7 @@ nouveau_device_new(struct nouveau_object *parent, struct nouveau_device **pdev)
       nvdev->base.info.type = NV_DEVICE_TYPE_SOC;
       break;
    default:
-      unreachable("unhandled nvidia device type");
+      UNREACHABLE("unhandled nvidia device type");
       break;
    }
 
diff --git a/src/glx/dri_common.c b/src/glx/dri_common.c
index 904ba60df2db4..10542949cbe45 100644
--- a/src/glx/dri_common.c
+++ b/src/glx/dri_common.c
@@ -601,7 +601,7 @@ dri_context_error_to_glx_error(unsigned error)
    else if (error == __DRI_CTX_ERROR_UNKNOWN_FLAG)
       return BadValue;
    else
-      unreachable("Impossible DRI context error");
+      UNREACHABLE("Impossible DRI context error");
 }
 
 struct glx_context *
@@ -959,7 +959,7 @@ dri_screen_init(struct glx_screen *psc, struct glx_display *priv, int screen, in
       type = DRI_SCREEN_SWRAST;
       break;
    default:
-      unreachable("unknown glx driver type");
+      UNREACHABLE("unknown glx driver type");
    }
 
    psc->frontend_screen = driCreateNewScreen3(screen, fd,
diff --git a/src/imagination/include/hwdef/rogue_hw_utils.h b/src/imagination/include/hwdef/rogue_hw_utils.h
index faffa543f679f..52d8b67882eac 100644
--- a/src/imagination/include/hwdef/rogue_hw_utils.h
+++ b/src/imagination/include/hwdef/rogue_hw_utils.h
@@ -124,7 +124,7 @@ static void rogue_get_isp_scale_xy_from_samples(const uint32_t samples,
       *y_scale_out = 4;
       break;
    default:
-      unreachable("Unsupported number of samples");
+      UNREACHABLE("Unsupported number of samples");
    }
 }
 
diff --git a/src/imagination/pco/pco_trans_nir.c b/src/imagination/pco/pco_trans_nir.c
index 11950bda4ad45..71e22b3003dfd 100644
--- a/src/imagination/pco/pco_trans_nir.c
+++ b/src/imagination/pco/pco_trans_nir.c
@@ -528,7 +528,7 @@ static pco_instr *trans_intr(trans_ctx *tctx, nir_intrinsic_instr *intr)
       else if (tctx->stage == MESA_SHADER_FRAGMENT)
          instr = trans_load_input_fs(tctx, intr, dest);
       else
-         unreachable("Unsupported stage for \"nir_intrinsic_load_input\".");
+         UNREACHABLE("Unsupported stage for \"nir_intrinsic_load_input\".");
       break;
 
    case nir_intrinsic_store_output:
@@ -537,7 +537,7 @@ static pco_instr *trans_intr(trans_ctx *tctx, nir_intrinsic_instr *intr)
       else if (tctx->stage == MESA_SHADER_FRAGMENT)
          instr = trans_store_output_fs(tctx, intr, src[0]);
       else
-         unreachable("Unsupported stage for \"nir_intrinsic_store_output\".");
+         UNREACHABLE("Unsupported stage for \"nir_intrinsic_store_output\".");
       break;
 
    case nir_intrinsic_load_ubo:
@@ -1110,7 +1110,7 @@ static pco_if *trans_if(trans_ctx *tctx, nir_if *nif)
 {
    pco_if *pif = pco_if_create(tctx->func);
 
-   unreachable("finishme: trans_if");
+   UNREACHABLE("finishme: trans_if");
 
    return pif;
 }
@@ -1126,7 +1126,7 @@ static pco_loop *trans_loop(trans_ctx *tctx, nir_loop *nloop)
 {
    pco_loop *loop = pco_loop_create(tctx->func);
 
-   unreachable("finishme: trans_loop");
+   UNREACHABLE("finishme: trans_loop");
 
    return loop;
 }
diff --git a/src/imagination/rogue/passes/rogue_dce.c b/src/imagination/rogue/passes/rogue_dce.c
index 7f1e3898e3f76..0eebc6bbb0751 100644
--- a/src/imagination/rogue/passes/rogue_dce.c
+++ b/src/imagination/rogue/passes/rogue_dce.c
@@ -80,7 +80,7 @@ static bool rogue_dce_instrs(rogue_shader *shader)
          break;
 
       default:
-         unreachable("Unsupported instruction type.");
+         UNREACHABLE("Unsupported instruction type.");
          return false;
       }
    }
diff --git a/src/imagination/rogue/passes/rogue_regalloc.c b/src/imagination/rogue/passes/rogue_regalloc.c
index a709c22b9726a..2fd43d8b0697b 100644
--- a/src/imagination/rogue/passes/rogue_regalloc.c
+++ b/src/imagination/rogue/passes/rogue_regalloc.c
@@ -174,7 +174,7 @@ bool rogue_regalloc(rogue_shader *shader)
       else if (regarray->size == 4)
          raclass = ROGUE_REGALLOC_CLASS_TEMP_4;
       else
-         unreachable("Unsupported regarray size.");
+         UNREACHABLE("Unsupported regarray size.");
 
       ra_set_node_class(ra_graph,
                         base_index,
@@ -211,7 +211,7 @@ bool rogue_regalloc(rogue_shader *shader)
 
    /* TODO: Spilling support. */
    if (!ra_allocate(ra_graph))
-      unreachable("Register allocation failed.");
+      UNREACHABLE("Register allocation failed.");
 
    /* Replace SSA regarray registers with allocated physical registers. */
    for (unsigned u = 0; u < num_parent_regarrays; ++u) {
diff --git a/src/imagination/rogue/passes/rogue_schedule_instr_groups.c b/src/imagination/rogue/passes/rogue_schedule_instr_groups.c
index ed432ac3baf23..5b04a2003a893 100644
--- a/src/imagination/rogue/passes/rogue_schedule_instr_groups.c
+++ b/src/imagination/rogue/passes/rogue_schedule_instr_groups.c
@@ -255,7 +255,7 @@ static void rogue_lower_instr_group_io(rogue_instr *instr,
       break;
 
    default:
-      unreachable("Unsupported instruction group type.");
+      UNREACHABLE("Unsupported instruction group type.");
    }
 }
 
@@ -268,14 +268,14 @@ static inline void rogue_instr_group_put(rogue_instr *instr,
 {
    uint64_t supported_phases = rogue_instr_supported_phases(instr);
    if (!supported_phases)
-      unreachable("Can't schedule pseudo-instructions.");
+      UNREACHABLE("Can't schedule pseudo-instructions.");
    else if (!util_is_power_of_two_or_zero64(supported_phases))
-      unreachable("Multi-phase instructions unsupported.");
+      UNREACHABLE("Multi-phase instructions unsupported.");
 
    enum rogue_instr_phase phase =
       rogue_get_supported_phase(supported_phases, group->header.phases);
    if (phase == ROGUE_INSTR_PHASE_INVALID)
-      unreachable("Failed to schedule group instruction.");
+      UNREACHABLE("Failed to schedule group instruction.");
 
    /* Update phases. */
    instr->group = group;
@@ -351,7 +351,7 @@ static unsigned rogue_reg_bank_bits(const rogue_ref *ref)
    else if (rogue_ref_is_regarray(ref))
       reg = ref->regarray->regs[0];
    else
-      unreachable("Non-register reference.");
+      UNREACHABLE("Non-register reference.");
 
    unsigned bits = util_last_bit(rogue_reg_bank_encoding(reg->class));
    return !bits ? 1 : bits;
@@ -366,7 +366,7 @@ static unsigned rogue_reg_index_bits(const rogue_ref *ref)
    else if (rogue_ref_is_regarray(ref))
       reg = ref->regarray->regs[0];
    else
-      unreachable("Non-register reference.");
+      UNREACHABLE("Non-register reference.");
 
    unsigned bits = util_last_bit(reg->index);
    return !bits ? 1 : bits;
@@ -413,7 +413,7 @@ static void rogue_calc_dsts_size(rogue_instr_group *group)
       return;
    }
 
-   unreachable("Unable to encode instruction group dsts.");
+   UNREACHABLE("Unable to encode instruction group dsts.");
 }
 
 static void rogue_calc_iss_size(rogue_instr_group *group)
@@ -466,7 +466,7 @@ static void rogue_calc_srcs_size(rogue_instr_group *group, bool upper_srcs)
             break;
 
          default:
-            unreachable("IS0 set to unsupported value.");
+            UNREACHABLE("IS0 set to unsupported value.");
          }
       }
    }
@@ -509,7 +509,7 @@ static void rogue_calc_srcs_size(rogue_instr_group *group, bool upper_srcs)
       return;
    }
 
-   unreachable("Unable to encode instruction group srcs.");
+   UNREACHABLE("Unable to encode instruction group srcs.");
 }
 
 #define SM(src_mod) ROGUE_ALU_SRC_MOD_##src_mod
@@ -600,7 +600,7 @@ static void rogue_calc_alu_instrs_size(rogue_instr_group *group,
       break;
 
    default:
-      unreachable("Unsupported alu op.");
+      UNREACHABLE("Unsupported alu op.");
    }
 }
 #undef OM
@@ -698,7 +698,7 @@ static void rogue_calc_backend_instrs_size(rogue_instr_group *group,
       break;
 
    default:
-      unreachable("Unsupported backend op.");
+      UNREACHABLE("Unsupported backend op.");
    }
 }
 #undef OM
@@ -726,7 +726,7 @@ static void rogue_calc_ctrl_instrs_size(rogue_instr_group *group,
       break;
 
    default:
-      unreachable("Unsupported ctrl op.");
+      UNREACHABLE("Unsupported ctrl op.");
    }
 }
 
@@ -748,7 +748,7 @@ static void rogue_calc_bitwise_instrs_size(rogue_instr_group *group,
       break;
 
    default:
-      unreachable("Invalid bitwise op.");
+      UNREACHABLE("Invalid bitwise op.");
    }
 }
 
@@ -779,7 +779,7 @@ static void rogue_calc_instrs_size(rogue_instr_group *group)
          break;
 
       default:
-         unreachable("Unsupported instruction type.");
+         UNREACHABLE("Unsupported instruction type.");
       }
 
       group->size.total += group->size.instrs[p];
@@ -865,7 +865,7 @@ bool rogue_schedule_instr_groups(rogue_shader *shader, bool multi_instr_groups)
       return false;
 
    if (multi_instr_groups) {
-      unreachable("Multi instruction groups are unsupported.");
+      UNREACHABLE("Multi instruction groups are unsupported.");
       return false;
    }
 
@@ -895,7 +895,7 @@ bool rogue_schedule_instr_groups(rogue_shader *shader, bool multi_instr_groups)
             break;
 
          default:
-            unreachable("Unsupported instruction type.");
+            UNREACHABLE("Unsupported instruction type.");
          }
 
          if (!grouping) {
diff --git a/src/imagination/rogue/passes/rogue_schedule_uvsw.c b/src/imagination/rogue/passes/rogue_schedule_uvsw.c
index 747791be0f8b0..1782310e8c884 100644
--- a/src/imagination/rogue/passes/rogue_schedule_uvsw.c
+++ b/src/imagination/rogue/passes/rogue_schedule_uvsw.c
@@ -49,7 +49,7 @@ bool rogue_schedule_uvsw(rogue_shader *shader, bool latency_hiding)
 
    /* TODO: Add support for delayed scheduling (latency hiding). */
    if (latency_hiding)
-      unreachable("Latency hiding is unimplemented.");
+      UNREACHABLE("Latency hiding is unimplemented.");
 
    rogue_builder b;
    rogue_builder_init(&b, shader);
@@ -78,7 +78,7 @@ bool rogue_schedule_uvsw(rogue_shader *shader, bool latency_hiding)
       list_last_entry(&final_block->instrs, rogue_instr, link);
 
    if (!rogue_instr_is_nop_end(final_instr))
-      unreachable("UVSW emit/end task need to be the final instruction.");
+      UNREACHABLE("UVSW emit/end task need to be the final instruction.");
 
    b.cursor = rogue_cursor_before_instr(final_instr);
 
diff --git a/src/imagination/rogue/passes/rogue_schedule_wdf.c b/src/imagination/rogue/passes/rogue_schedule_wdf.c
index 88ca59ffbb3d0..da7b1a1088d23 100644
--- a/src/imagination/rogue/passes/rogue_schedule_wdf.c
+++ b/src/imagination/rogue/passes/rogue_schedule_wdf.c
@@ -56,7 +56,7 @@ bool rogue_schedule_wdf(rogue_shader *shader, bool latency_hiding)
 
    /* TODO: Add support for delayed scheduling (latency hiding). */
    if (latency_hiding)
-      unreachable("Latency hiding is unimplemented.");
+      UNREACHABLE("Latency hiding is unimplemented.");
 
    bool progress = false;
 
diff --git a/src/imagination/rogue/rogue.c b/src/imagination/rogue/rogue.c
index 7847f48f403e9..c19b25aabec7f 100644
--- a/src/imagination/rogue/rogue.c
+++ b/src/imagination/rogue/rogue.c
@@ -404,7 +404,7 @@ static rogue_regarray *rogue_find_common_regarray(rogue_regarray *regarray,
    for (unsigned u = 0; u < regarray->size; ++u) {
       if (regarray->regs[u]->regarray) {
          if (common_regarray && regarray->regs[u]->regarray != common_regarray)
-            unreachable("Can't have overlapping regarrays.");
+            UNREACHABLE("Can't have overlapping regarrays.");
          else if (!common_regarray)
             common_regarray = regarray->regs[u]->regarray;
       }
@@ -422,7 +422,7 @@ static rogue_regarray *rogue_find_common_regarray(rogue_regarray *regarray,
        * and also registers *beyond* its parent. */
       if ((min_index > min_common_index && max_index > max_common_index) ||
           (min_index < min_common_index && max_index < max_common_index))
-         unreachable("Can't have overflowing partial regarrays.");
+         UNREACHABLE("Can't have overflowing partial regarrays.");
 
       *is_parent = regarray->size > common_regarray->size;
       const rogue_regarray *parent_regarray = *is_parent ? regarray
@@ -750,7 +750,7 @@ void rogue_link_instr_write(rogue_instr *instr)
          } else if (rogue_ref_is_io(&alu->dst[i].ref)) { /* TODO: check WHICH IO
                                                             IT IS */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -774,7 +774,7 @@ void rogue_link_instr_write(rogue_instr *instr)
                                                                 WHICH IO IT IS
                                                               */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -797,7 +797,7 @@ void rogue_link_instr_write(rogue_instr *instr)
          } else if (rogue_ref_is_io(&ctrl->dst[i].ref)) { /* TODO: check WHICH
                                                              IO IT IS */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -821,7 +821,7 @@ void rogue_link_instr_write(rogue_instr *instr)
                                                                 WHICH IO IT IS
                                                               */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -829,7 +829,7 @@ void rogue_link_instr_write(rogue_instr *instr)
    }
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
    }
 }
 
@@ -864,7 +864,7 @@ void rogue_link_instr_use(rogue_instr *instr)
                                                             IT IS */
          } else if (rogue_ref_is_val(&alu->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -893,7 +893,7 @@ void rogue_link_instr_use(rogue_instr *instr)
                                                               */
          } else if (rogue_ref_is_val(&backend->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -931,7 +931,7 @@ void rogue_link_instr_use(rogue_instr *instr)
                                                              IO IT IS */
          } else if (rogue_ref_is_val(&ctrl->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -960,7 +960,7 @@ void rogue_link_instr_use(rogue_instr *instr)
                                                               */
          } else if (rogue_ref_is_val(&bitwise->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -968,7 +968,7 @@ void rogue_link_instr_use(rogue_instr *instr)
    }
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
    }
 }
 
@@ -996,7 +996,7 @@ void rogue_unlink_instr_write(rogue_instr *instr)
          } else if (rogue_ref_is_io(&alu->dst[i].ref)) { /* TODO: check WHICH IO
                                                             IT IS */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -1018,7 +1018,7 @@ void rogue_unlink_instr_write(rogue_instr *instr)
                                                                 WHICH IO IT IS
                                                               */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -1039,7 +1039,7 @@ void rogue_unlink_instr_write(rogue_instr *instr)
          } else if (rogue_ref_is_io(&ctrl->dst[i].ref)) { /* TODO: check WHICH
                                                              IO IT IS */
          } else {
-            unreachable("Unsupported destination reference type.");
+            UNREACHABLE("Unsupported destination reference type.");
          }
       }
 
@@ -1058,7 +1058,7 @@ void rogue_unlink_instr_write(rogue_instr *instr)
             rogue_regarray_write *write = &bitwise->dst_write[i].regarray;
             rogue_unlink_instr_write_regarray(instr, write);
          } else {
-            unreachable("Invalid destination reference type.");
+            UNREACHABLE("Invalid destination reference type.");
          }
       }
 
@@ -1066,7 +1066,7 @@ void rogue_unlink_instr_write(rogue_instr *instr)
    }
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
    }
 }
 
@@ -1097,7 +1097,7 @@ void rogue_unlink_instr_use(rogue_instr *instr)
                                                             IT IS */
          } else if (rogue_ref_is_val(&alu->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -1124,7 +1124,7 @@ void rogue_unlink_instr_use(rogue_instr *instr)
                                                               */
          } else if (rogue_ref_is_val(&backend->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -1158,7 +1158,7 @@ void rogue_unlink_instr_use(rogue_instr *instr)
                                                              IO IT IS */
          } else if (rogue_ref_is_val(&ctrl->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -1185,7 +1185,7 @@ void rogue_unlink_instr_use(rogue_instr *instr)
                                                               */
          } else if (rogue_ref_is_val(&bitwise->src[i].ref)) {
          } else {
-            unreachable("Unsupported source reference type.");
+            UNREACHABLE("Unsupported source reference type.");
          }
       }
 
@@ -1193,7 +1193,7 @@ void rogue_unlink_instr_use(rogue_instr *instr)
    }
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
    }
 }
 
diff --git a/src/imagination/rogue/rogue.h b/src/imagination/rogue/rogue.h
index 0cdf6e455aecf..5da334ffba2cc 100644
--- a/src/imagination/rogue/rogue.h
+++ b/src/imagination/rogue/rogue.h
@@ -112,7 +112,7 @@ static inline enum reg_bank rogue_reg_bank_encoding(enum rogue_reg_class class)
       return BANK_VTXIN;
 
    default:
-      unreachable("Unsupported register class.");
+      UNREACHABLE("Unsupported register class.");
    }
 }
 
@@ -833,7 +833,7 @@ static inline enum rogue_reg_class rogue_ref_get_reg_class(const rogue_ref *ref)
       return ref->regarray->regs[0]->class;
    else if (rogue_ref_is_reg(ref))
       return ref->reg->class;
-   unreachable("Ref is not a reg/regarray.");
+   UNREACHABLE("Ref is not a reg/regarray.");
 }
 
 static inline unsigned rogue_ref_get_reg_index(const rogue_ref *ref)
@@ -842,14 +842,14 @@ static inline unsigned rogue_ref_get_reg_index(const rogue_ref *ref)
       return ref->regarray->regs[0]->index;
    else if (rogue_ref_is_reg(ref))
       return ref->reg->index;
-   unreachable("Ref is not a reg/regarray.");
+   UNREACHABLE("Ref is not a reg/regarray.");
 }
 
 static inline unsigned rogue_ref_get_regarray_size(const rogue_ref *ref)
 {
    if (rogue_ref_is_regarray(ref))
       return ref->regarray->size;
-   unreachable("Ref is not a regarray.");
+   UNREACHABLE("Ref is not a regarray.");
 }
 
 #define ROGUE_INTERNAL0_OFFSET 36
@@ -1717,7 +1717,7 @@ static inline enum rogue_io rogue_instr_src_io_src(const rogue_instr *instr,
    }
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
       break;
    }
 
@@ -1741,7 +1741,7 @@ rogue_instr_group_io_sel_ref(rogue_instr_group_io_sel *map, enum rogue_io io)
       return &map->dsts[io - ROGUE_IO_W0];
    else if (rogue_io_is_iss(io))
       return &map->iss[io - ROGUE_IO_IS0];
-   unreachable("Unsupported io.");
+   UNREACHABLE("Unsupported io.");
 }
 
 /** Rogue instruction group. */
@@ -2321,7 +2321,7 @@ static inline bool rogue_dst_reg_replace(rogue_reg_write *write,
       break;
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
       return false;
    }
 
@@ -2358,7 +2358,7 @@ static inline bool rogue_src_reg_replace(rogue_reg_use *use, rogue_reg *new_reg)
       break;
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
       return false;
    }
 
@@ -2419,7 +2419,7 @@ static inline bool rogue_dst_regarray_replace(rogue_regarray_write *write,
       break;
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
       return false;
    }
 
@@ -2457,7 +2457,7 @@ static inline bool rogue_src_regarray_replace(rogue_regarray_use *use,
       break;
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
       return false;
    }
 
@@ -2545,7 +2545,7 @@ static inline bool rogue_src_imm_replace(rogue_imm_use *imm_use,
       break;
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
       return false;
    }
 
@@ -2617,7 +2617,7 @@ static inline unsigned rogue_instr_supported_phases(const rogue_instr *instr)
    }
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
    }
 
    return supported_phases;
diff --git a/src/imagination/rogue/rogue_build_data.c b/src/imagination/rogue/rogue_build_data.c
index 6c33358d7ae0d..4f7b1b9f39040 100644
--- a/src/imagination/rogue/rogue_build_data.c
+++ b/src/imagination/rogue/rogue_build_data.c
@@ -99,7 +99,7 @@ static void reserve_iterator(struct rogue_iterator_args *args,
       break;
 
    default:
-      unreachable("Unimplemented interpolation type.");
+      UNREACHABLE("Unimplemented interpolation type.");
    }
 
    /* Number of components in this varying
@@ -304,7 +304,7 @@ static void collect_io_data_vs(struct rogue_common_build_data *common_data,
          unsigned i = (var->data.location - VARYING_SLOT_VAR0) + 1;
          reserve_vs_output(&vs_data->outputs, i, components);
       } else {
-         unreachable("Unsupported vertex output type.");
+         UNREACHABLE("Unsupported vertex output type.");
       }
    }
 
@@ -348,7 +348,7 @@ void rogue_collect_io_data(struct rogue_build_ctx *ctx, nir_shader *nir)
       break;
    }
 
-   unreachable("Unsupported stage.");
+   UNREACHABLE("Unsupported stage.");
 }
 
 /**
@@ -408,7 +408,7 @@ unsigned rogue_output_index_vs(struct rogue_vertex_outputs *outputs,
               (location <= VARYING_SLOT_VAR31)) {
       i = (location - VARYING_SLOT_VAR0) + 1;
    } else {
-      unreachable("Unsupported vertex output type.");
+      UNREACHABLE("Unsupported vertex output type.");
    }
 
    assert(i < outputs->num_output_vars);
diff --git a/src/imagination/rogue/rogue_compile.c b/src/imagination/rogue/rogue_compile.c
index 2502ab1ed13a4..899161cef90f0 100644
--- a/src/imagination/rogue/rogue_compile.c
+++ b/src/imagination/rogue/rogue_compile.c
@@ -102,7 +102,7 @@ static void trans_nir_jump(rogue_builder *b, nir_jump_instr *jump)
       break;
    }
 
-   unreachable("Unimplemented NIR jump instruction type.");
+   UNREACHABLE("Unimplemented NIR jump instruction type.");
 }
 
 static void trans_nir_load_const(rogue_builder *b,
@@ -135,7 +135,7 @@ static void trans_nir_load_const(rogue_builder *b,
    }
 
    default:
-      unreachable("Unimplemented NIR load_const bit size.");
+      UNREACHABLE("Unimplemented NIR load_const bit size.");
    }
 }
 
@@ -247,7 +247,7 @@ static void trans_nir_intrinsic_load_input(rogue_builder *b,
       break;
    }
 
-   unreachable("Unimplemented NIR load_input variant.");
+   UNREACHABLE("Unimplemented NIR load_input variant.");
 }
 
 static void trans_nir_intrinsic_store_output_fs(rogue_builder *b,
@@ -305,7 +305,7 @@ static void trans_nir_intrinsic_store_output(rogue_builder *b,
       break;
    }
 
-   unreachable("Unimplemented NIR store_output variant.");
+   UNREACHABLE("Unimplemented NIR store_output variant.");
 }
 
 static inline gl_shader_stage
@@ -325,7 +325,7 @@ pvr_stage_to_mesa(enum pvr_stage_allocation pvr_stage)
       break;
    }
 
-   unreachable("Unsupported pvr_stage_allocation.");
+   UNREACHABLE("Unsupported pvr_stage_allocation.");
 }
 
 static inline enum pvr_stage_allocation
@@ -345,7 +345,7 @@ mesa_stage_to_pvr(gl_shader_stage mesa_stage)
       break;
    }
 
-   unreachable("Unsupported gl_shader_stage.");
+   UNREACHABLE("Unsupported gl_shader_stage.");
 }
 static bool descriptor_is_dynamic(VkDescriptorType type)
 {
@@ -389,7 +389,7 @@ static void trans_nir_intrinsic(rogue_builder *b, nir_intrinsic_instr *intr)
       break;
    }
 
-   unreachable("Unimplemented NIR intrinsic instruction.");
+   UNREACHABLE("Unimplemented NIR intrinsic instruction.");
 }
 
 static void trans_nir_alu_pack_unorm_4x8(rogue_builder *b, nir_alu_instr *alu)
@@ -480,7 +480,7 @@ static void trans_nir_alu_iadd(rogue_builder *b, nir_alu_instr *alu)
       break;
    }
 
-   unreachable("Unsupported bit size.");
+   UNREACHABLE("Unsupported bit size.");
 }
 
 static void trans_nir_alu(rogue_builder *b, nir_alu_instr *alu)
@@ -506,7 +506,7 @@ static void trans_nir_alu(rogue_builder *b, nir_alu_instr *alu)
       break;
    }
 
-   unreachable("Unimplemented NIR ALU instruction.");
+   UNREACHABLE("Unimplemented NIR ALU instruction.");
 }
 
 PUBLIC
@@ -623,7 +623,7 @@ rogue_shader *rogue_nir_to_rogue(rogue_build_ctx *ctx, const nir_shader *nir)
             break;
 
          default:
-            unreachable("Unimplemented NIR instruction type.");
+            UNREACHABLE("Unimplemented NIR instruction type.");
          }
       }
    }
diff --git a/src/imagination/rogue/rogue_encode.c b/src/imagination/rogue/rogue_encode.c
index b2d0ec14d645f..0cd5f13b43653 100644
--- a/src/imagination/rogue/rogue_encode.c
+++ b/src/imagination/rogue/rogue_encode.c
@@ -64,7 +64,7 @@ static unsigned rogue_calc_da(const rogue_instr_group *group)
       }
 
    } else {
-      unreachable("Unsupported instruction group ALU.");
+      UNREACHABLE("Unsupported instruction group ALU.");
    }
 
    return da;
@@ -95,7 +95,7 @@ static enum oporg rogue_calc_oporg(uint64_t alu_phases)
    else if (P0 && !P1 && !P2 && !PBE)
       return OPORG_P0;
 
-   unreachable("Invalid ALU phase combination.");
+   UNREACHABLE("Invalid ALU phase combination.");
 }
 
 static enum opcnt rogue_calc_opcnt(uint64_t bitwise_phases)
@@ -153,7 +153,7 @@ static void rogue_encode_instr_group_header(rogue_instr_group *group,
       break;
 
    default:
-      unreachable("Unsupported condition code.");
+      UNREACHABLE("Unsupported condition code.");
    }
 
    h.cc = cc.cc;
@@ -196,13 +196,13 @@ static void rogue_encode_instr_group_header(rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported ctrl op.");
+         UNREACHABLE("Unsupported ctrl op.");
       }
 #undef OM
       break;
 
    default:
-      unreachable("Unsupported instruction group ALU.");
+      UNREACHABLE("Unsupported instruction group ALU.");
    }
 
    if (group->header.alu != ROGUE_ALU_CONTROL) {
@@ -242,7 +242,7 @@ static unsigned rogue_alu_movc_ft(const rogue_ref *ref)
       break;
    }
 
-   unreachable("Invalid source.");
+   UNREACHABLE("Invalid source.");
 }
 
 #define SM(src_mod) ROGUE_ALU_SRC_MOD_##src_mod
@@ -330,7 +330,7 @@ static void rogue_encode_alu_instr(const rogue_alu_instr *alu,
       else if (rogue_alu_op_mod_is_set(alu, OM(LE)))
          tstop._ = TSTOP_LE;
       else
-         unreachable("Invalid comparison test.");
+         UNREACHABLE("Invalid comparison test.");
 
       instr_encoding->alu.tst.tstop_2_0 = tstop._2_0;
 
@@ -366,7 +366,7 @@ static void rogue_encode_alu_instr(const rogue_alu_instr *alu,
          else if (rogue_alu_op_mod_is_set(alu, OM(S32)))
             instr_encoding->alu.tst.type = TSTTYPE_S32;
          else
-            unreachable("Invalid comparison type.");
+            UNREACHABLE("Invalid comparison type.");
       }
       break;
    }
@@ -443,7 +443,7 @@ static void rogue_encode_alu_instr(const rogue_alu_instr *alu,
       break;
 
    default:
-      unreachable("Unsupported alu op.");
+      UNREACHABLE("Unsupported alu op.");
    }
 }
 #undef OM
@@ -662,7 +662,7 @@ static void rogue_encode_backend_instr(const rogue_backend_instr *backend,
          break;
 
       default:
-         unreachable("Unsupported number of channels.");
+         UNREACHABLE("Unsupported number of channels.");
       }
 
       switch (backend->op) {
@@ -679,7 +679,7 @@ static void rogue_encode_backend_instr(const rogue_backend_instr *backend,
          break;
 
       default:
-         unreachable("Unsupported sampler op.");
+         UNREACHABLE("Unsupported sampler op.");
       }
 
       if (instr_size > 2) {
@@ -752,7 +752,7 @@ static void rogue_encode_backend_instr(const rogue_backend_instr *backend,
       break;
 
    default:
-      unreachable("Unsupported backend op.");
+      UNREACHABLE("Unsupported backend op.");
    }
 }
 #undef OM
@@ -800,7 +800,7 @@ static void rogue_encode_ctrl_instr(const rogue_ctrl_instr *ctrl,
    }
 
    default:
-      unreachable("Unsupported ctrl op.");
+      UNREACHABLE("Unsupported ctrl op.");
    }
 }
 #undef OM
@@ -835,7 +835,7 @@ static void rogue_encode_bitwise_instr(const rogue_bitwise_instr *bitwise,
    }
 
    default:
-      unreachable("Invalid bitwise op.");
+      UNREACHABLE("Invalid bitwise op.");
    }
 }
 
@@ -878,7 +878,7 @@ static void rogue_encode_instr_group_instrs(rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported instruction type.");
+         UNREACHABLE("Unsupported instruction type.");
       }
 
       util_dynarray_append_mem(binary, group->size.instrs[p], &instr_encoding);
@@ -921,7 +921,7 @@ static void rogue_encode_source_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("IS0 set to unsupported value.");
+         UNREACHABLE("IS0 set to unsupported value.");
       }
    }
 
@@ -977,7 +977,7 @@ static void rogue_encode_source_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported source/bytes combination.");
+         UNREACHABLE("Unsupported source/bytes combination.");
       }
       break;
 
@@ -1018,7 +1018,7 @@ static void rogue_encode_source_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported source/bytes combination.");
+         UNREACHABLE("Unsupported source/bytes combination.");
       }
       break;
 
@@ -1071,12 +1071,12 @@ static void rogue_encode_source_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported source/bytes combination.");
+         UNREACHABLE("Unsupported source/bytes combination.");
       }
       break;
 
    default:
-      unreachable("Unsupported source/bytes combination.");
+      UNREACHABLE("Unsupported source/bytes combination.");
    }
 }
 
@@ -1115,7 +1115,7 @@ static void rogue_encode_dest_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported dest/bytes combination.");
+         UNREACHABLE("Unsupported dest/bytes combination.");
       }
       break;
    }
@@ -1153,12 +1153,12 @@ static void rogue_encode_dest_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported dest/bytes combination.");
+         UNREACHABLE("Unsupported dest/bytes combination.");
       }
    } break;
 
    default:
-      unreachable("Unsupported dest/bytes combination.");
+      UNREACHABLE("Unsupported dest/bytes combination.");
    }
 }
 
@@ -1177,7 +1177,7 @@ static void rogue_encode_iss_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported setting for IS1.");
+         UNREACHABLE("Unsupported setting for IS1.");
       }
 
    if (rogue_ref_is_io(&io_sel->iss[2]))
@@ -1190,7 +1190,7 @@ static void rogue_encode_iss_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported setting for IS2.");
+         UNREACHABLE("Unsupported setting for IS2.");
       }
 
    if (rogue_ref_is_io(&io_sel->iss[3]))
@@ -1209,7 +1209,7 @@ static void rogue_encode_iss_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported setting for IS3.");
+         UNREACHABLE("Unsupported setting for IS3.");
       }
 
    if (rogue_ref_is_io(&io_sel->iss[4]))
@@ -1228,7 +1228,7 @@ static void rogue_encode_iss_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported setting for IS4.");
+         UNREACHABLE("Unsupported setting for IS4.");
       }
 
    if (rogue_ref_is_io(&io_sel->iss[5]))
@@ -1247,7 +1247,7 @@ static void rogue_encode_iss_map(const rogue_instr_group *group,
          break;
 
       default:
-         unreachable("Unsupported setting for IS5.");
+         UNREACHABLE("Unsupported setting for IS5.");
       }
 }
 
@@ -1309,7 +1309,7 @@ void rogue_encode_shader(rogue_build_ctx *ctx,
                          struct util_dynarray *binary)
 {
    if (!shader->is_grouped)
-      unreachable("Can't encode shader with ungrouped instructions.");
+      UNREACHABLE("Can't encode shader with ungrouped instructions.");
 
    util_dynarray_init(binary, ctx);
 
diff --git a/src/imagination/rogue/rogue_print.c b/src/imagination/rogue/rogue_print.c
index 57628008ea56e..eb7bbdf374a4a 100644
--- a/src/imagination/rogue/rogue_print.c
+++ b/src/imagination/rogue/rogue_print.c
@@ -206,7 +206,7 @@ static inline void rogue_print_ref(FILE *fp, const rogue_ref *ref)
       break;
 
    default:
-      unreachable("Unsupported ref type.");
+      UNREACHABLE("Unsupported ref type.");
    }
 }
 
@@ -442,7 +442,7 @@ void rogue_print_instr(FILE *fp, const rogue_instr *instr)
       break;
 
    default:
-      unreachable("Unsupported instruction type.");
+      UNREACHABLE("Unsupported instruction type.");
    }
    RESET(fp);
 
@@ -487,7 +487,7 @@ rogue_print_instr_group_io_sel(FILE *fp, const rogue_instr_group_io_sel *io_sel)
       else if (rogue_ref_is_io(&io_sel->srcs[i]))
          rogue_print_io(fp, io_sel->srcs[i].io);
       else
-         unreachable("Unsupported src map.");
+         UNREACHABLE("Unsupported src map.");
    }
    if (present)
       fputs(" ", fp);
@@ -513,7 +513,7 @@ rogue_print_instr_group_io_sel(FILE *fp, const rogue_instr_group_io_sel *io_sel)
       else if (rogue_ref_is_io(&io_sel->iss[i]))
          rogue_print_io(fp, io_sel->iss[i].io);
       else
-         unreachable("Unsupported iss map.");
+         UNREACHABLE("Unsupported iss map.");
    }
    if (present)
       fputs(" ", fp);
@@ -539,7 +539,7 @@ rogue_print_instr_group_io_sel(FILE *fp, const rogue_instr_group_io_sel *io_sel)
       else if (rogue_ref_is_io(&io_sel->dsts[i]))
          rogue_print_io(fp, io_sel->dsts[i].io);
       else
-         unreachable("Unsupported dst map.");
+         UNREACHABLE("Unsupported dst map.");
    }
    if (present)
       fputs(" ", fp);
@@ -569,7 +569,7 @@ rogue_print_instr_group_header(FILE *fp, const rogue_instr_group *group)
       break;
 
    default:
-      unreachable("Unsupported instruction group ALU.");
+      UNREACHABLE("Unsupported instruction group ALU.");
    }
 
    if (group->header.end)
diff --git a/src/imagination/vulkan/pds/pvr_pipeline_pds.c b/src/imagination/vulkan/pds/pvr_pipeline_pds.c
index 54d414dcc37ef..a1ffd3a0dae44 100644
--- a/src/imagination/vulkan/pds/pvr_pipeline_pds.c
+++ b/src/imagination/vulkan/pds/pvr_pipeline_pds.c
@@ -325,7 +325,7 @@ pvr_find_constant2(uint8_t *const_usage, uint8_t words, const char *const_name)
       }
    }
 
-   unreachable("Unexpected: Space cannot be found for constant");
+   UNREACHABLE("Unexpected: Space cannot be found for constant");
    return ~0;
 }
 
@@ -364,7 +364,7 @@ static uint8_t pvr_get_temps2(struct pvr_temp_usage *temps,
       return i;
    }
 
-   unreachable("Unexpected: Space cannot be found for temps");
+   UNREACHABLE("Unexpected: Space cannot be found for temps");
    return PVR_INVALID_TEMP;
 }
 
diff --git a/src/imagination/vulkan/pvr_blit.c b/src/imagination/vulkan/pvr_blit.c
index e2f6006ab65bb..4811e56d0c77a 100644
--- a/src/imagination/vulkan/pvr_blit.c
+++ b/src/imagination/vulkan/pvr_blit.c
@@ -136,7 +136,7 @@ VkFormat pvr_get_raw_copy_format(VkFormat format)
    case 16:
       return VK_FORMAT_R32G32B32A32_UINT;
    default:
-      unreachable("Unhandled copy block size.");
+      UNREACHABLE("Unhandled copy block size.");
    }
 }
 
@@ -1563,7 +1563,7 @@ static VkResult pvr_clear_color_attachment_static_create_consts_buffer(
          break;
 
       default:
-         unreachable("Unsupported clear attachment const type.");
+         UNREACHABLE("Unsupported clear attachment const type.");
       }
    }
 
diff --git a/src/imagination/vulkan/pvr_cmd_buffer.c b/src/imagination/vulkan/pvr_cmd_buffer.c
index 532220e2e10f3..dc2570fcf328d 100644
--- a/src/imagination/vulkan/pvr_cmd_buffer.c
+++ b/src/imagination/vulkan/pvr_cmd_buffer.c
@@ -125,7 +125,7 @@ static void pvr_cmd_buffer_free_sub_cmd(struct pvr_cmd_buffer *cmd_buffer,
          break;
 
       default:
-         unreachable("Unsupported sub-command type");
+         UNREACHABLE("Unsupported sub-command type");
       }
    }
 
@@ -300,7 +300,7 @@ static void pvr_cmd_buffer_update_barriers(struct pvr_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Unsupported sub-command type");
+      UNREACHABLE("Unsupported sub-command type");
    }
 
    for (uint32_t i = 0; i < ARRAY_SIZE(state->barriers_needed); i++)
@@ -1066,7 +1066,7 @@ pvr_get_render_target(const struct pvr_render_pass *pass,
       break;
 
    default:
-      unreachable("Unsupported sample count");
+      UNREACHABLE("Unsupported sample count");
       break;
    }
 
@@ -1598,7 +1598,7 @@ static VkResult pvr_sub_cmd_gfx_job_init(const struct pvr_device_info *dev_info,
             break;
 
          default:
-            unreachable("Unsupported depth stencil format");
+            UNREACHABLE("Unsupported depth stencil format");
          }
 
          job->ds.memlayout = ds_image->memlayout;
@@ -2190,7 +2190,7 @@ VkResult pvr_cmd_buffer_end_sub_cmd(struct pvr_cmd_buffer *cmd_buffer)
       break;
 
    default:
-      unreachable("Unsupported sub-command type");
+      UNREACHABLE("Unsupported sub-command type");
    }
 
    state->current_sub_cmd = NULL;
@@ -2414,7 +2414,7 @@ VkResult pvr_cmd_buffer_start_sub_cmd(struct pvr_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Unsupported sub-command type");
+      UNREACHABLE("Unsupported sub-command type");
    }
 
    list_addtail(&sub_cmd->link, &cmd_buffer->sub_cmds);
@@ -2443,7 +2443,7 @@ VkResult pvr_cmd_buffer_alloc_mem(struct pvr_cmd_buffer *cmd_buffer,
    else if (heap == cmd_buffer->device->heaps.usc_heap)
       allocator = &cmd_buffer->device->suballoc_usc;
    else
-      unreachable("Unknown heap type");
+      UNREACHABLE("Unknown heap type");
 
    result =
       pvr_bo_suballoc(allocator, size, cache_line_size, false, &suballoc_bo);
@@ -2495,7 +2495,7 @@ void pvr_CmdBindPipeline(VkCommandBuffer commandBuffer,
       break;
 
    default:
-      unreachable("Invalid bind point.");
+      UNREACHABLE("Invalid bind point.");
       break;
    }
 }
@@ -3482,7 +3482,7 @@ pvr_setup_vertex_buffers(struct pvr_cmd_buffer *cmd_buffer,
       }
 
       default:
-         unreachable("Unsupported data section map");
+         UNREACHABLE("Unsupported data section map");
          break;
       }
    }
@@ -3536,7 +3536,7 @@ static VkResult pvr_setup_descriptor_mappings(
       break;
 
    default:
-      unreachable("Unsupported stage.");
+      UNREACHABLE("Unsupported stage.");
       break;
    }
 
@@ -3581,7 +3581,7 @@ static VkResult pvr_setup_descriptor_mappings(
       }
 
       default:
-         unreachable("Unsupported map entry type.");
+         UNREACHABLE("Unsupported map entry type.");
       }
    }
 
@@ -3972,7 +3972,7 @@ static void pvr_cmd_dispatch(
       state->push_constants.dirty_stages &= ~VK_SHADER_STAGE_COMPUTE_BIT;
    }
 
-   unreachable("compute descriptor support");
+   UNREACHABLE("compute descriptor support");
 
    pvr_compute_update_shared(cmd_buffer, sub_cmd);
    pvr_compute_update_kernel(cmd_buffer, sub_cmd, indirect_addr, workgroup_size);
@@ -4892,7 +4892,7 @@ static void pvr_setup_ppp_control(struct pvr_cmd_buffer *const cmd_buffer)
          break;
 
       default:
-         unreachable("Unsupported cull mode!");
+         UNREACHABLE("Unsupported cull mode!");
       }
    }
 
@@ -5720,7 +5720,7 @@ static uint32_t pvr_get_hw_primitive_topology(VkPrimitiveTopology topology)
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
       return ROGUE_VDMCTRL_PRIMITIVE_TOPOLOGY_PATCH_LIST;
    default:
-      unreachable("Undefined primitive topology");
+      UNREACHABLE("Undefined primitive topology");
    }
 }
 
@@ -6364,7 +6364,7 @@ pvr_execute_deferred_cmd_buffer(struct pvr_cmd_buffer *cmd_buffer,
       }
 
       default:
-         unreachable("Invalid deferred control stream command type.");
+         UNREACHABLE("Invalid deferred control stream command type.");
          break;
       }
    }
@@ -6422,7 +6422,7 @@ static VkResult pvr_execute_sub_cmd(struct pvr_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Unsupported sub-command type");
+      UNREACHABLE("Unsupported sub-command type");
    }
 
    return VK_SUCCESS;
@@ -7227,7 +7227,7 @@ void pvr_CmdWriteTimestamp2(VkCommandBuffer commandBuffer,
                             VkQueryPool queryPool,
                             uint32_t query)
 {
-   unreachable("Timestamp queries are not supported.");
+   UNREACHABLE("Timestamp queries are not supported.");
 }
 
 VkResult pvr_EndCommandBuffer(VkCommandBuffer commandBuffer)
diff --git a/src/imagination/vulkan/pvr_csb.c b/src/imagination/vulkan/pvr_csb.c
index c50c2722aa9e9..74c31f78d0b9c 100644
--- a/src/imagination/vulkan/pvr_csb.c
+++ b/src/imagination/vulkan/pvr_csb.c
@@ -201,7 +201,7 @@ pvr_csb_emit_link_unmarked(struct pvr_csb *csb, pvr_dev_addr_t addr, bool ret)
       break;
 
    default:
-      unreachable("Unknown stream type");
+      UNREACHABLE("Unknown stream type");
       break;
    }
 }
@@ -471,7 +471,7 @@ VkResult pvr_csb_emit_terminate(struct pvr_csb *csb)
       break;
 
    default:
-      unreachable("Unknown stream type");
+      UNREACHABLE("Unknown stream type");
       break;
    }
 
diff --git a/src/imagination/vulkan/pvr_csb_enum_helpers.h b/src/imagination/vulkan/pvr_csb_enum_helpers.h
index 893811cfb8b49..482c25d71c7e7 100644
--- a/src/imagination/vulkan/pvr_csb_enum_helpers.h
+++ b/src/imagination/vulkan/pvr_csb_enum_helpers.h
@@ -66,7 +66,7 @@ pvr_cr_isp_aa_mode_type(uint32_t samples)
    case 8:
       return ROGUE_CR_ISP_AA_MODE_TYPE_AA_8X;
    default:
-      unreachable("Unsupported number of samples");
+      UNREACHABLE("Unsupported number of samples");
    }
 }
 
@@ -85,7 +85,7 @@ pvr_zls_format_type_is_packed(enum ROGUE_CR_ZLS_FORMAT_TYPE type)
       return false;
 
    default:
-      unreachable("Invalid ZLS format type");
+      UNREACHABLE("Invalid ZLS format type");
    }
 }
 
@@ -104,7 +104,7 @@ pvr_zls_format_type_is_int(enum ROGUE_CR_ZLS_FORMAT_TYPE type)
       return false;
 
    default:
-      unreachable("Invalid ZLS format type");
+      UNREACHABLE("Invalid ZLS format type");
    }
 }
 
@@ -147,7 +147,7 @@ pvr_pbestate_source_pos(enum pvr_pbe_source_start_pos pos)
       return ROGUE_PBESTATE_SOURCE_POS_START_BIT96;
 
    default:
-      unreachable("Undefined PBE source pos.");
+      UNREACHABLE("Undefined PBE source pos.");
    }
 }
 
@@ -190,7 +190,7 @@ pvr_ta_objtype(VkPrimitiveTopology topology)
       return ROGUE_TA_OBJTYPE_TRIANGLE;
 
    default:
-      unreachable("Invalid topology.");
+      UNREACHABLE("Invalid topology.");
       return 0;
    }
 }
@@ -237,7 +237,7 @@ pvr_vdmctrl_index_size_from_type(VkIndexType type)
    case VK_INDEX_TYPE_UINT8_KHR:
       return ROGUE_VDMCTRL_INDEX_SIZE_B8;
    default:
-      unreachable("Invalid index type");
+      UNREACHABLE("Invalid index type");
    }
 }
 
diff --git a/src/imagination/vulkan/pvr_device.c b/src/imagination/vulkan/pvr_device.c
index 7e80e0d1979cd..36bd2be2783ca 100644
--- a/src/imagination/vulkan/pvr_device.c
+++ b/src/imagination/vulkan/pvr_device.c
@@ -2557,7 +2557,7 @@ VkResult pvr_GetEventStatus(VkDevice _device, VkEvent _event)
       break;
 
    default:
-      unreachable("Event object in unknown state");
+      UNREACHABLE("Event object in unknown state");
    }
 
    return result;
@@ -2666,7 +2666,7 @@ VkResult pvr_gpu_upload(struct pvr_device *device,
    else if (heap == device->heaps.usc_heap)
       allocator = &device->suballoc_usc;
    else
-      unreachable("Unknown heap type");
+      UNREACHABLE("Unknown heap type");
 
    result = pvr_bo_suballoc(allocator, size, alignment, false, &suballoc_bo);
    if (result != VK_SUCCESS)
@@ -3052,7 +3052,7 @@ pvr_sampler_get_hw_filter_from_vk(const struct pvr_device_info *dev_info,
    case VK_FILTER_LINEAR:
       return ROGUE_TEXSTATE_FILTER_LINEAR;
    default:
-      unreachable("Unknown filter type.");
+      UNREACHABLE("Unknown filter type.");
    }
 }
 
@@ -3071,7 +3071,7 @@ pvr_sampler_get_hw_addr_mode_from_vk(VkSamplerAddressMode addr_mode)
    case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER:
       return ROGUE_TEXSTATE_ADDRMODE_CLAMP_TO_BORDER;
    default:
-      unreachable("Invalid sampler address mode.");
+      UNREACHABLE("Invalid sampler address mode.");
    }
 }
 
diff --git a/src/imagination/vulkan/pvr_dump_csb.c b/src/imagination/vulkan/pvr_dump_csb.c
index 3f512fd1acbba..5be9ebbb6920b 100644
--- a/src/imagination/vulkan/pvr_dump_csb.c
+++ b/src/imagination/vulkan/pvr_dump_csb.c
@@ -2358,7 +2358,7 @@ static bool dump_first_buffer(struct pvr_dump_buffer_ctx *const ctx,
       break;
 
    default:
-      unreachable("Unknown stream type");
+      UNREACHABLE("Unknown stream type");
    }
 
    if (!ret)
diff --git a/src/imagination/vulkan/pvr_formats.c b/src/imagination/vulkan/pvr_formats.c
index c64e1f9a8afc2..22a8dabbd7e14 100644
--- a/src/imagination/vulkan/pvr_formats.c
+++ b/src/imagination/vulkan/pvr_formats.c
@@ -453,7 +453,7 @@ uint32_t pvr_get_pbe_accum_format_size_in_bytes(VkFormat vk_format)
       return 4;
 
    default:
-      unreachable("Unknown pbe accum format. Implementation error");
+      UNREACHABLE("Unknown pbe accum format. Implementation error");
    }
 }
 
@@ -577,7 +577,7 @@ void pvr_get_hw_clear_color(
       break;
 
    default:
-      unreachable("Packing not supported for the accum format.");
+      UNREACHABLE("Packing not supported for the accum format.");
       break;
    }
 
@@ -957,7 +957,7 @@ pvr_get_image_format_properties(struct pvr_physical_device *pdevice,
       break;
 
    default:
-      unreachable("Invalid image type.");
+      UNREACHABLE("Invalid image type.");
    }
 
    /* The spec says maxMipLevels may be 1 when tiling is VK_IMAGE_TILING_LINEAR
diff --git a/src/imagination/vulkan/pvr_hardcode.c b/src/imagination/vulkan/pvr_hardcode.c
index ce62124141e9d..987a217ec0164 100644
--- a/src/imagination/vulkan/pvr_hardcode.c
+++ b/src/imagination/vulkan/pvr_hardcode.c
@@ -239,7 +239,7 @@ void pvr_hard_code_graphics_shader(const struct pvr_device_info *const dev_info,
       break;
 
    default:
-      unreachable("Unsupported stage.");
+      UNREACHABLE("Unsupported stage.");
    }
 }
 
@@ -316,7 +316,7 @@ void pvr_hard_code_graphics_get_build_info(
       break;
 
    default:
-      unreachable("Unsupported stage.");
+      UNREACHABLE("Unsupported stage.");
    }
 }
 
diff --git a/src/imagination/vulkan/pvr_image.c b/src/imagination/vulkan/pvr_image.c
index 669c835de3535..422555ee777f2 100644
--- a/src/imagination/vulkan/pvr_image.c
+++ b/src/imagination/vulkan/pvr_image.c
@@ -44,7 +44,7 @@ static void pvr_image_init_memlayout(struct pvr_image *image)
 {
    switch (image->vk.tiling) {
    default:
-      unreachable("bad VkImageTiling");
+      UNREACHABLE("bad VkImageTiling");
    case VK_IMAGE_TILING_OPTIMAL:
       if (image->vk.wsi_legacy_scanout)
          image->memlayout = PVR_MEMLAYOUT_LINEAR;
diff --git a/src/imagination/vulkan/pvr_job_common.c b/src/imagination/vulkan/pvr_job_common.c
index e86fb57dd6596..bc602433ba7af 100644
--- a/src/imagination/vulkan/pvr_job_common.c
+++ b/src/imagination/vulkan/pvr_job_common.c
@@ -198,7 +198,7 @@ void pvr_pbe_pack_state(
          reg.swiz_chan0 = ROGUE_PBESTATE_SWIZ_ONE;
          break;
       default:
-         unreachable("Unknown enum pipe_swizzle");
+         UNREACHABLE("Unknown enum pipe_swizzle");
          break;
       }
       /* g, u or stencil*/
@@ -223,7 +223,7 @@ void pvr_pbe_pack_state(
          reg.swiz_chan1 = ROGUE_PBESTATE_SWIZ_ONE;
          break;
       default:
-         unreachable("Unknown enum pipe_swizzle");
+         UNREACHABLE("Unknown enum pipe_swizzle");
          break;
       }
       /* b or v*/
@@ -248,7 +248,7 @@ void pvr_pbe_pack_state(
          reg.swiz_chan2 = ROGUE_PBESTATE_SWIZ_ONE;
          break;
       default:
-         unreachable("Unknown enum pipe_swizzle");
+         UNREACHABLE("Unknown enum pipe_swizzle");
          break;
       }
       /* a */
@@ -273,7 +273,7 @@ void pvr_pbe_pack_state(
          reg.swiz_chan3 = ROGUE_PBESTATE_SWIZ_ONE;
          break;
       default:
-         unreachable("Unknown enum pipe_swizzle");
+         UNREACHABLE("Unknown enum pipe_swizzle");
          break;
       }
 
diff --git a/src/imagination/vulkan/pvr_job_context.c b/src/imagination/vulkan/pvr_job_context.c
index 74e4ec762fb51..42a46a9b91e6a 100644
--- a/src/imagination/vulkan/pvr_job_context.c
+++ b/src/imagination/vulkan/pvr_job_context.c
@@ -581,7 +581,7 @@ static VkResult pvr_ctx_sr_programs_setup(struct pvr_device *device,
       break;
 
    default:
-      unreachable("Invalid target.");
+      UNREACHABLE("Invalid target.");
       break;
    }
 
diff --git a/src/imagination/vulkan/pvr_job_render.c b/src/imagination/vulkan/pvr_job_render.c
index 8a873ece9d3b8..4fb6f208e086c 100644
--- a/src/imagination/vulkan/pvr_job_render.c
+++ b/src/imagination/vulkan/pvr_job_render.c
@@ -279,7 +279,7 @@ static inline void pvr_get_samples_in_xy(uint32_t samples,
       *y_out = 4;
       break;
    default:
-      unreachable("Unsupported number of samples");
+      UNREACHABLE("Unsupported number of samples");
    }
 }
 
@@ -1313,7 +1313,7 @@ static void pvr_frag_state_stream_init(struct pvr_render_ctx *ctx,
          break;
 
       default:
-         unreachable("Unsupported depth format");
+         UNREACHABLE("Unsupported depth format");
       }
    }
    stream_ptr += pvr_cmd_length(CR_ISP_BGOBJDEPTH);
diff --git a/src/imagination/vulkan/pvr_job_transfer.c b/src/imagination/vulkan/pvr_job_transfer.c
index e93e07fe76dd3..4fc48edde6e94 100644
--- a/src/imagination/vulkan/pvr_job_transfer.c
+++ b/src/imagination/vulkan/pvr_job_transfer.c
@@ -1832,7 +1832,7 @@ pvr_dma_texture_floats(const struct pvr_transfer_cmd *transfer_cmd,
       }
 
       default:
-         unreachable("Unknown COORD_SET_FLOATS.");
+         UNREACHABLE("Unknown COORD_SET_FLOATS.");
          break;
       }
    }
@@ -4340,7 +4340,7 @@ static VkResult pvr_isp_ctrl_stream(const struct pvr_device_info *dev_info,
                      /* Unreachable since we clamped the value earlier so
                       * reaching this is an implementation error.
                       */
-                     unreachable("num_mapping exceeded max_mappings_per_pb");
+                     UNREACHABLE("num_mapping exceeded max_mappings_per_pb");
                      break;
                   }
                }
diff --git a/src/imagination/vulkan/pvr_pipeline.c b/src/imagination/vulkan/pvr_pipeline.c
index b159b96fce280..cf9154b17f54b 100644
--- a/src/imagination/vulkan/pvr_pipeline.c
+++ b/src/imagination/vulkan/pvr_pipeline.c
@@ -464,7 +464,7 @@ static VkResult pvr_pds_vertex_attrib_programs_create_and_upload(
          break;
 
       default:
-         unreachable("Invalid vertex attrib program type.");
+         UNREACHABLE("Invalid vertex attrib program type.");
       }
 
       input.flags |= extra_flags;
@@ -940,7 +940,7 @@ static VkResult pvr_compute_pipeline_compile(
 
    /* FIXME: Compile and upload the shader. */
    /* FIXME: Initialize the shader state and setup build info. */
-   unreachable("finishme: compute support");
+   UNREACHABLE("finishme: compute support");
 
    result = pvr_pds_descriptor_program_create_and_upload(
       device,
@@ -1529,7 +1529,7 @@ static void pvr_graphics_pipeline_setup_fragment_coeff_program(
             break;
 
          default:
-            unreachable("Unimplemented interpolation type.");
+            UNREACHABLE("Unimplemented interpolation type.");
          }
 
          douti_src.size = ROGUE_PDSINST_DOUTI_SIZE_1D + count - 1;
@@ -2404,7 +2404,7 @@ pvr_graphics_pipeline_init(struct pvr_device *device,
          gfx_pipeline->stage_indices[gl_stage] = i;
          break;
       default:
-         unreachable("Unsupported stage.");
+         UNREACHABLE("Unsupported stage.");
       }
    }
 
@@ -2520,6 +2520,6 @@ void pvr_DestroyPipeline(VkDevice _device,
    }
 
    default:
-      unreachable("Unknown pipeline type.");
+      UNREACHABLE("Unknown pipeline type.");
    }
 }
diff --git a/src/imagination/vulkan/pvr_query_compute.c b/src/imagination/vulkan/pvr_query_compute.c
index b08183b2337ab..e1ed8979aa1a2 100644
--- a/src/imagination/vulkan/pvr_query_compute.c
+++ b/src/imagination/vulkan/pvr_query_compute.c
@@ -289,14 +289,14 @@ static VkResult pvr_write_compute_query_pds_data_section(
          }
 
          default:
-            unreachable("Unsupported special buffer type.");
+            UNREACHABLE("Unsupported special buffer type.");
          }
 
          entries += sizeof(*special_buff_entry);
          break;
       }
       default:
-         unreachable("Unsupported data section map");
+         UNREACHABLE("Unsupported data section map");
       }
    }
 
@@ -537,7 +537,7 @@ VkResult pvr_add_query_program(struct pvr_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Invalid query type");
+      UNREACHABLE("Invalid query type");
    }
 
    result = pvr_cmd_buffer_start_sub_cmd(cmd_buffer,
@@ -795,7 +795,7 @@ VkResult pvr_add_query_program(struct pvr_cmd_buffer *cmd_buffer,
    }
 
    default:
-      unreachable("Invalid query type");
+      UNREACHABLE("Invalid query type");
    }
 
 #undef DRIVER_CONST
diff --git a/src/imagination/vulkan/pvr_queue.c b/src/imagination/vulkan/pvr_queue.c
index 5a6960c7a78f2..84408ccde2c55 100644
--- a/src/imagination/vulkan/pvr_queue.c
+++ b/src/imagination/vulkan/pvr_queue.c
@@ -680,7 +680,7 @@ static VkResult pvr_process_event_cmd(struct pvr_device *device,
    case PVR_EVENT_TYPE_BARRIER:
       return pvr_process_event_cmd_barrier(device, queue, &sub_cmd->barrier);
    default:
-      unreachable("Invalid event sub-command type.");
+      UNREACHABLE("Invalid event sub-command type.");
    };
 }
 
diff --git a/src/imagination/vulkan/pvr_spm.c b/src/imagination/vulkan/pvr_spm.c
index 2aa50506269c0..a1e1128b72f94 100644
--- a/src/imagination/vulkan/pvr_spm.c
+++ b/src/imagination/vulkan/pvr_spm.c
@@ -418,7 +418,7 @@ pvr_spm_get_pbe_packmode(uint32_t dword_count)
    case 4:
       return ROGUE_PBESTATE_PACKMODE_U32U32U32U32;
    default:
-      unreachable("Unsupported dword_count");
+      UNREACHABLE("Unsupported dword_count");
    }
 }
 
@@ -779,7 +779,7 @@ static VkFormat pvr_get_format_from_dword_count(uint32_t dword_count)
    case 4:
       return VK_FORMAT_R32G32B32A32_UINT;
    default:
-      unreachable("Invalid dword_count");
+      UNREACHABLE("Invalid dword_count");
    }
 }
 
diff --git a/src/imagination/vulkan/pvr_tex_state.c b/src/imagination/vulkan/pvr_tex_state.c
index 0486e0d6f4b4d..c8326a0d05613 100644
--- a/src/imagination/vulkan/pvr_tex_state.c
+++ b/src/imagination/vulkan/pvr_tex_state.c
@@ -57,7 +57,7 @@ static enum ROGUE_TEXSTATE_SWIZ pvr_get_hw_swizzle(VkComponentSwizzle comp,
       else
          return ROGUE_TEXSTATE_SWIZ_SRC_ZERO;
    default:
-      unreachable("Unknown enum pipe_swizzle");
+      UNREACHABLE("Unknown enum pipe_swizzle");
    };
 }
 
@@ -125,7 +125,7 @@ VkResult pvr_pack_tex_state(struct pvr_device *device,
             return vk_error(device, VK_ERROR_FORMAT_NOT_SUPPORTED);
          }
       } else {
-         unreachable("Unknown memory layout");
+         UNREACHABLE("Unknown memory layout");
       }
 
       /* When sampling from a combined D/S image, the TPU will default to only
diff --git a/src/imagination/vulkan/pvr_uscgen.c b/src/imagination/vulkan/pvr_uscgen.c
index 56651408cbe0f..9c9e85ba84305 100644
--- a/src/imagination/vulkan/pvr_uscgen.c
+++ b/src/imagination/vulkan/pvr_uscgen.c
@@ -48,7 +48,7 @@ static void build_shader(pco_ctx *ctx, nir_shader *nir, pco_binary **binary)
  */
 void pvr_uscgen_nop(pco_ctx *ctx, gl_shader_stage stage, pco_binary **binary)
 {
-   unreachable("finishme: pvr_uscgen_nop");
+   UNREACHABLE("finishme: pvr_uscgen_nop");
 }
 
 /**
@@ -62,7 +62,7 @@ void pvr_uscgen_eot(pco_ctx *ctx,
                     struct pvr_eot_props *props,
                     pco_binary **binary)
 {
-   unreachable("finishme: pvr_uscgen_eot");
+   UNREACHABLE("finishme: pvr_uscgen_eot");
 }
 
 /**
@@ -76,5 +76,5 @@ void pvr_uscgen_tq(pco_ctx *ctx,
                    struct pvr_tq_props *props,
                    pco_binary **binary)
 {
-   unreachable("finishme: pvr_uscgen_tq");
+   UNREACHABLE("finishme: pvr_uscgen_tq");
 }
diff --git a/src/imagination/vulkan/usc/pvr_uscgen_tq.c b/src/imagination/vulkan/usc/pvr_uscgen_tq.c
index d2a0cb69c41e2..971010da6aa88 100644
--- a/src/imagination/vulkan/usc/pvr_uscgen_tq.c
+++ b/src/imagination/vulkan/usc/pvr_uscgen_tq.c
@@ -118,7 +118,7 @@ void pvr_uscgen_tq_frag(const struct pvr_tq_shader_properties *shader_props,
 
       if (!layer_props->msaa) {
       } else {
-         unreachable("Unsupported layer property (MSAA).");
+         UNREACHABLE("Unsupported layer property (MSAA).");
       }
    }
 
@@ -129,7 +129,7 @@ void pvr_uscgen_tq_frag(const struct pvr_tq_shader_properties *shader_props,
       break;
 
    default:
-      unreachable("Unsupported layer property (format).");
+      UNREACHABLE("Unsupported layer property (format).");
    }
 
    /* TODO: Select the texture_regs index appropriately. */
@@ -157,7 +157,7 @@ void pvr_uscgen_tq_frag(const struct pvr_tq_shader_properties *shader_props,
          break;
 
       default:
-         unreachable("Unsupported layer property (format).");
+         UNREACHABLE("Unsupported layer property (format).");
       }
 
       outputs = rogue_ssa_vec_regarray(b.shader, channels, output_idx, 0);
@@ -179,7 +179,7 @@ void pvr_uscgen_tq_frag(const struct pvr_tq_shader_properties *shader_props,
    }
 
    default:
-      unreachable("Unsupported layer property (format).");
+      UNREACHABLE("Unsupported layer property (format).");
    }
 
    assert(channels && outputs);
diff --git a/src/imagination/vulkan/winsys/powervr/pvr_drm_job_common.h b/src/imagination/vulkan/winsys/powervr/pvr_drm_job_common.h
index f490690eb6036..932ef483e5216 100644
--- a/src/imagination/vulkan/winsys/powervr/pvr_drm_job_common.h
+++ b/src/imagination/vulkan/winsys/powervr/pvr_drm_job_common.h
@@ -39,7 +39,7 @@ pvr_drm_from_winsys_priority(enum pvr_winsys_ctx_priority priority)
    case PVR_WINSYS_CTX_PRIORITY_LOW:
       return DRM_PVR_CTX_PRIORITY_LOW;
    default:
-      unreachable("Invalid winsys context priority.");
+      UNREACHABLE("Invalid winsys context priority.");
    }
 }
 
diff --git a/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_common.h b/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_common.h
index 65d0581b7f420..9dcff09ea0e94 100644
--- a/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_common.h
+++ b/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_common.h
@@ -43,7 +43,7 @@ pvr_srv_from_winsys_priority(enum pvr_winsys_ctx_priority priority)
    case PVR_WINSYS_CTX_PRIORITY_LOW:
       return RGX_CONTEXT_PRIORITY_LOW;
    default:
-      unreachable("Invalid winsys context priority.");
+      UNREACHABLE("Invalid winsys context priority.");
    }
 }
 
diff --git a/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_render.c b/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_render.c
index f570e7410a916..e785eb8cdf694 100644
--- a/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_render.c
+++ b/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_job_render.c
@@ -253,7 +253,7 @@ static uint64_t pvr_rogue_get_cr_multisamplectl_val(uint32_t samples,
 
          break;
       default:
-         unreachable("Unsupported number of samples");
+         UNREACHABLE("Unsupported number of samples");
       }
    }
 
diff --git a/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_sync.c b/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_sync.c
index 05f018fc5fb62..637f66c930da2 100644
--- a/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_sync.c
+++ b/src/imagination/vulkan/winsys/pvrsrvkm/pvr_srv_sync.c
@@ -224,7 +224,7 @@ static VkResult pvr_srv_sync_move(struct vk_device *device,
       return VK_SUCCESS;
    }
 
-   unreachable("srv_sync doesn't support move for shared sync objects.");
+   UNREACHABLE("srv_sync doesn't support move for shared sync objects.");
    return VK_ERROR_UNKNOWN;
 }
 
diff --git a/src/intel/blorp/blorp.c b/src/intel/blorp/blorp.c
index 1a12460f31442..b0913a1a3adb9 100644
--- a/src/intel/blorp/blorp.c
+++ b/src/intel/blorp/blorp.c
@@ -275,7 +275,7 @@ blorp_hiz_op(struct blorp_batch *batch, struct blorp_surf *surf,
       break;
    case ISL_AUX_OP_PARTIAL_RESOLVE:
    case ISL_AUX_OP_NONE:
-      unreachable("Invalid HiZ op");
+      UNREACHABLE("Invalid HiZ op");
    }
 
    for (uint32_t a = 0; a < num_layers; a++) {
diff --git a/src/intel/blorp/blorp_blit.c b/src/intel/blorp/blorp_blit.c
index 56a89a8150177..7bd2ec49db2a7 100644
--- a/src/intel/blorp/blorp_blit.c
+++ b/src/intel/blorp/blorp_blit.c
@@ -426,14 +426,14 @@ blorp_nir_encode_msaa(nir_builder *b, nir_def *pos,
          break;
 
       default:
-         unreachable("Invalid number of samples for IMS layout");
+         UNREACHABLE("Invalid number of samples for IMS layout");
       }
 
       return nir_vec2(b, x_out, y_out);
    }
 
    default:
-      unreachable("Invalid MSAA layout");
+      UNREACHABLE("Invalid MSAA layout");
    }
 }
 
@@ -526,14 +526,14 @@ blorp_nir_decode_msaa(nir_builder *b, nir_def *pos,
          break;
 
       default:
-         unreachable("Invalid number of samples for IMS layout");
+         UNREACHABLE("Invalid number of samples for IMS layout");
       }
 
       return nir_vec3(b, x_out, y_out, s_out);
    }
 
    default:
-      unreachable("Invalid MSAA layout");
+      UNREACHABLE("Invalid MSAA layout");
    }
 }
 
@@ -579,7 +579,7 @@ blorp_nir_combine_samples(nir_builder *b, struct blorp_blit_vars *v,
       case nir_type_int:   combine_op = nir_op_imin;  break;
       case nir_type_uint:  combine_op = nir_op_umin;  break;
       case nir_type_float: combine_op = nir_op_fmin;  break;
-      default: unreachable("Invalid dst_type");
+      default: UNREACHABLE("Invalid dst_type");
       }
       break;
 
@@ -588,12 +588,12 @@ blorp_nir_combine_samples(nir_builder *b, struct blorp_blit_vars *v,
       case nir_type_int:   combine_op = nir_op_imax;  break;
       case nir_type_uint:  combine_op = nir_op_umax;  break;
       case nir_type_float: combine_op = nir_op_fmax;  break;
-      default: unreachable("Invalid dst_type");
+      default: UNREACHABLE("Invalid dst_type");
       }
       break;
 
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    }
 
    /* If true, we inserted an if statement that we need to pop at at the end.
@@ -972,7 +972,7 @@ select_color_channel(struct nir_builder *b, nir_def *color,
       case nir_type_float:
          return nir_imm_float(b, 1);
       default:
-         unreachable("Invalid data type");
+         UNREACHABLE("Invalid data type");
       }
    } else {
       assert((unsigned)(chan - ISL_CHANNEL_SELECT_RED) < 4);
@@ -1016,7 +1016,7 @@ convert_color(struct nir_builder *b, nir_def *color,
    } else if (key->dst_format == ISL_FORMAT_R9G9B9E5_SHAREDEXP) {
       value = nir_format_pack_r9g9b9e5(b, color);
    } else {
-      unreachable("Unsupported format conversion");
+      UNREACHABLE("Unsupported format conversion");
    }
 
    nir_def *out_comps[4];
@@ -1407,7 +1407,7 @@ blorp_build_nir_shader(struct blorp_context *blorp,
       break;
 
    default:
-      unreachable("Invalid blorp filter");
+      UNREACHABLE("Invalid blorp filter");
    }
 
    if (!isl_swizzle_is_identity(key->src_swizzle)) {
@@ -1499,7 +1499,7 @@ blorp_build_nir_shader(struct blorp_context *blorp,
       stencil_out->data.location = FRAG_RESULT_STENCIL;
       nir_store_var(&b, stencil_out, nir_channel(&b, color, 0), 0x1);
    } else {
-      unreachable("Invalid destination usage");
+      UNREACHABLE("Invalid destination usage");
    }
 
    if (bounds_if)
@@ -1793,7 +1793,7 @@ get_red_format_for_rgb_format(enum isl_format format)
       case ISL_SINT:
          return ISL_FORMAT_R8_SINT;
       default:
-         unreachable("Invalid 8-bit RGB channel type");
+         UNREACHABLE("Invalid 8-bit RGB channel type");
       }
    case 16:
       switch (fmtl->channels.r.type) {
@@ -1808,7 +1808,7 @@ get_red_format_for_rgb_format(enum isl_format format)
       case ISL_SINT:
          return ISL_FORMAT_R16_SINT;
       default:
-         unreachable("Invalid 8-bit RGB channel type");
+         UNREACHABLE("Invalid 8-bit RGB channel type");
       }
    case 32:
       switch (fmtl->channels.r.type) {
@@ -1819,10 +1819,10 @@ get_red_format_for_rgb_format(enum isl_format format)
       case ISL_SINT:
          return ISL_FORMAT_R32_SINT;
       default:
-         unreachable("Invalid 8-bit RGB channel type");
+         UNREACHABLE("Invalid 8-bit RGB channel type");
       }
    default:
-      unreachable("Invalid number of red channel bits");
+      UNREACHABLE("Invalid number of red channel bits");
    }
 }
 
@@ -2632,7 +2632,7 @@ get_copy_format_for_bpb(const struct isl_device *isl_dev, unsigned bpb)
       case 96: return ISL_FORMAT_R32G32B32_UINT;
       case 128:return ISL_FORMAT_R32G32B32A32_UINT;
       default:
-         unreachable("Unknown format bpb");
+         UNREACHABLE("Unknown format bpb");
       }
    } else {
       switch (bpb) {
@@ -2645,7 +2645,7 @@ get_copy_format_for_bpb(const struct isl_device *isl_dev, unsigned bpb)
       case 96: return ISL_FORMAT_R32G32B32_UINT;
       case 128:return ISL_FORMAT_R32G32B32A32_UINT;
       default:
-         unreachable("Unknown format bpb");
+         UNREACHABLE("Unknown format bpb");
       }
    }
 }
@@ -2756,7 +2756,7 @@ get_ccs_compatible_uint_format(const struct isl_format_layout *fmtl)
       return ISL_FORMAT_R8_UINT;
 
    default:
-      unreachable("Not a compressible format");
+      UNREACHABLE("Not a compressible format");
    }
 }
 
diff --git a/src/intel/blorp/blorp_clear.c b/src/intel/blorp/blorp_clear.c
index 968374bf4d8fa..853a14a265350 100644
--- a/src/intel/blorp/blorp_clear.c
+++ b/src/intel/blorp/blorp_clear.c
@@ -285,7 +285,7 @@ get_fast_clear_rect(const struct isl_device *dev,
             case  32: ccs_format = ISL_FORMAT_GFX12_CCS_32BPP_Y0;  break;
             case  64: ccs_format = ISL_FORMAT_GFX12_CCS_64BPP_Y0;  break;
             case 128: ccs_format = ISL_FORMAT_GFX12_CCS_128BPP_Y0; break;
-            default:  unreachable("Invalid surface bpb for fast clearing");
+            default:  UNREACHABLE("Invalid surface bpb for fast clearing");
             }
          } else {
             assert(aux_surf->usage == ISL_SURF_USAGE_CCS_BIT);
@@ -378,7 +378,7 @@ get_fast_clear_rect(const struct isl_device *dev,
          x_scaledown = dev->info->ver >= 20 ? 8 : 1;
          break;
       default:
-         unreachable("Unexpected MCS format for fast clear");
+         UNREACHABLE("Unexpected MCS format for fast clear");
       }
       y_scaledown = dev->info->ver >= 20 ? 4 : 2;
       x_align = x_scaledown * 2;
@@ -1557,7 +1557,7 @@ blorp_mcs_ambiguate(struct blorp_batch *batch,
    case 8:  renderable_format = ISL_FORMAT_R8_UINT;     break;
    case 32: renderable_format = ISL_FORMAT_R32_UINT;    break;
    case 64: renderable_format = ISL_FORMAT_R32G32_UINT; break;
-   default: unreachable("Unexpected MCS format size for ambiguate");
+   default: UNREACHABLE("Unexpected MCS format size for ambiguate");
    }
 
    /* From Bspec 57340 (r59562):
diff --git a/src/intel/blorp/blorp_genX_exec_brw.h b/src/intel/blorp/blorp_genX_exec_brw.h
index 1239035b3ca02..ecb488cc7b411 100644
--- a/src/intel/blorp/blorp_genX_exec_brw.h
+++ b/src/intel/blorp/blorp_genX_exec_brw.h
@@ -830,7 +830,7 @@ blorp_emit_ps_config(struct blorp_batch *batch,
          ps.RenderTargetFastClearEnable = true;
          break;
       default:
-         unreachable("Invalid fast clear op");
+         UNREACHABLE("Invalid fast clear op");
       }
 
 #if GFX_VERx10 == 120
@@ -1059,7 +1059,7 @@ blorp_emit_depth_stencil_state(struct blorp_batch *batch,
             ds.DepthTestEnable = false;
             break;
          case ISL_AUX_OP_PARTIAL_RESOLVE:
-            unreachable("Invalid HIZ op");
+            UNREACHABLE("Invalid HIZ op");
          }
       }
 
@@ -1560,7 +1560,7 @@ blorp_emit_gfx8_hiz_op(struct blorp_batch *batch,
          break;
       case ISL_AUX_OP_PARTIAL_RESOLVE:
       case ISL_AUX_OP_NONE:
-         unreachable("Invalid HIZ op");
+         UNREACHABLE("Invalid HIZ op");
       }
 
       hzp.NumberofMultisamples = ffs(params->num_samples) - 1;
@@ -1942,7 +1942,7 @@ xy_bcb_tiling(const struct isl_surf *surf)
       return XY_TILE_Y;
 #endif
    default:
-      unreachable("Invalid tiling for XY_BLOCK_COPY_BLT");
+      UNREACHABLE("Invalid tiling for XY_BLOCK_COPY_BLT");
    }
 }
 
@@ -1957,7 +1957,7 @@ xy_color_depth(const struct isl_format_layout *fmtl)
    case  16: return XY_BPP_16_BIT;
    case   8: return XY_BPP_8_BIT;
    default:
-      unreachable("Invalid bpp");
+      UNREACHABLE("Invalid bpp");
    }
 }
 #endif
@@ -1978,7 +1978,7 @@ xy_bcb_surf_dim(const struct isl_surf *surf)
    case ISL_SURF_DIM_3D:
       return XY_SURFTYPE_3D;
    default:
-      unreachable("Invalid dimensionality for XY_BLOCK_COPY_BLT");
+      UNREACHABLE("Invalid dimensionality for XY_BLOCK_COPY_BLT");
    }
 }
 
@@ -2001,7 +2001,7 @@ xy_aux_mode(const struct blorp_surface_info *info)
    case ISL_AUX_USAGE_NONE:
       return XY_NONE;
    default:
-      unreachable("Unsupported aux mode");
+      UNREACHABLE("Unsupported aux mode");
    }
 }
 #endif // GFX_VER < 20
@@ -2012,7 +2012,7 @@ blorp_xy_block_copy_blt(struct blorp_batch *batch,
                         const struct blorp_params *params)
 {
 #if GFX_VER < 12
-   unreachable("Blitter is only supported on Gfx12+");
+   UNREACHABLE("Blitter is only supported on Gfx12+");
 #else
    UNUSED const struct isl_device *isl_dev = batch->blorp->isl_dev;
 
@@ -2172,7 +2172,7 @@ blorp_xy_fast_color_blit(struct blorp_batch *batch,
                          const struct blorp_params *params)
 {
 #if GFX_VER < 12
-   unreachable("Blitter is only supported on Gfx12+");
+   UNREACHABLE("Blitter is only supported on Gfx12+");
 #else
    UNUSED const struct isl_device *isl_dev = batch->blorp->isl_dev;
    const struct isl_surf *dst_surf = &params->dst.surf;
diff --git a/src/intel/blorp/blorp_genX_exec_elk.h b/src/intel/blorp/blorp_genX_exec_elk.h
index b5445e37ce9b1..c2d1b82ef59c4 100644
--- a/src/intel/blorp/blorp_genX_exec_elk.h
+++ b/src/intel/blorp/blorp_genX_exec_elk.h
@@ -405,7 +405,7 @@ blorp_emit_input_varying_data(struct blorp_batch *batch,
                         params->dst.clear_color_addr,
                         clear_color_size);
 #else
-      unreachable("MCS partial resolve is not a thing on SNB and earlier");
+      UNREACHABLE("MCS partial resolve is not a thing on SNB and earlier");
 #endif
    }
 }
@@ -909,7 +909,7 @@ blorp_emit_ps_config(struct blorp_batch *batch,
          ps.RenderTargetFastClearEnable = true;
          break;
       default:
-         unreachable("Invalid fast clear op");
+         UNREACHABLE("Invalid fast clear op");
       }
 
       /* The RENDER_SURFACE_STATE page for TGL says:
@@ -987,7 +987,7 @@ blorp_emit_ps_config(struct blorp_batch *batch,
       case ISL_AUX_OP_NONE:
          break;
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
       if (prog_data) {
@@ -1057,7 +1057,7 @@ blorp_emit_ps_config(struct blorp_batch *batch,
          ps.RenderTargetFastClearEnable = true;
          break;
       default:
-         unreachable("Invalid fast clear op");
+         UNREACHABLE("Invalid fast clear op");
       }
    }
 
@@ -1080,7 +1080,7 @@ blorp_emit_ps_config(struct blorp_batch *batch,
       case ISL_AUX_OP_NONE:
          break;
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
       if (prog_data) {
@@ -1233,7 +1233,7 @@ blorp_emit_depth_stencil_state(struct blorp_batch *batch,
          ds.DepthTestEnable = false;
          break;
       case ISL_AUX_OP_PARTIAL_RESOLVE:
-         unreachable("Invalid HIZ op");
+         UNREACHABLE("Invalid HIZ op");
       }
    }
 
@@ -1520,7 +1520,7 @@ blorp_emit_surface_state(struct blorp_batch *batch,
                            isl_dev->ss.clear_value_size);
       }
 #else
-      unreachable("Fast clears are only supported on gfx7+");
+      UNREACHABLE("Fast clears are only supported on gfx7+");
 #endif
    }
 
@@ -1799,7 +1799,7 @@ blorp_emit_gfx8_hiz_op(struct blorp_batch *batch,
          break;
       case ISL_AUX_OP_PARTIAL_RESOLVE:
       case ISL_AUX_OP_NONE:
-         unreachable("Invalid HIZ op");
+         UNREACHABLE("Invalid HIZ op");
       }
 
       hzp.NumberofMultisamples = ffs(params->num_samples) - 1;
@@ -2053,7 +2053,7 @@ blorp_exec_compute(struct blorp_batch *batch, const struct blorp_params *params)
 
 #else /* GFX_VER >= 7 */
 
-   unreachable("Compute blorp is not supported on SNB and earlier");
+   UNREACHABLE("Compute blorp is not supported on SNB and earlier");
 
 #endif /* GFX_VER >= 7 */
 
diff --git a/src/intel/blorp/blorp_nir_builder.h b/src/intel/blorp/blorp_nir_builder.h
index 863df78283afd..bf5ce426686dd 100644
--- a/src/intel/blorp/blorp_nir_builder.h
+++ b/src/intel/blorp/blorp_nir_builder.h
@@ -99,7 +99,7 @@ blorp_nir_mcs_is_clear_color(nir_builder *b,
                          nir_ieq_imm(b, nir_channel(b, mcs, 1), ~0));
 
    default:
-      unreachable("Invalid sample count");
+      UNREACHABLE("Invalid sample count");
    }
 }
 
diff --git a/src/intel/common/intel_aux_map.c b/src/intel/common/intel_aux_map.c
index 63c062e37de0d..38ae7702a069e 100644
--- a/src/intel/common/intel_aux_map.c
+++ b/src/intel/common/intel_aux_map.c
@@ -446,7 +446,7 @@ get_bpp_encoding(enum isl_format format)
       case ISL_FORMAT_PLANAR_420_10: return 1;
       case ISL_FORMAT_PLANAR_420_16: return 0;
       default:
-         unreachable("Unsupported format!");
+         UNREACHABLE("Unsupported format!");
          return 0;
       }
    } else {
@@ -457,7 +457,7 @@ get_bpp_encoding(enum isl_format format)
       case 64:  return 6;
       case 128: return 7;
       default:
-         unreachable("Unsupported bpp!");
+         UNREACHABLE("Unsupported bpp!");
          return 0;
       }
    }
@@ -539,7 +539,7 @@ get_aux_entry(struct intel_aux_map_context *ctx, uint64_t main_address,
             fprintf(stderr, "AUX-MAP L3[0x%x]: 0x%"PRIx64", map=%p\n",
                     l3_index, l2_level->address, l2_level->entries);
       } else {
-         unreachable("Failed to add L2 Aux-Map Page Table!");
+         UNREACHABLE("Failed to add L2 Aux-Map Page Table!");
       }
       l3_level->entries[l3_index] = (l2_level->address & L3_ENTRY_L2_ADDR_MASK) |
                                     INTEL_AUX_MAP_ENTRY_VALID_BIT;
@@ -557,7 +557,7 @@ get_aux_entry(struct intel_aux_map_context *ctx, uint64_t main_address,
             fprintf(stderr, "AUX-MAP L2[0x%x]: 0x%"PRIx64", map=%p\n",
                     l2_index, l1_level->address, l1_level->entries);
       } else {
-         unreachable("Failed to add L1 Aux-Map Page Table!");
+         UNREACHABLE("Failed to add L1 Aux-Map Page Table!");
       }
       l2_level->entries[l2_index] = (l1_level->address & get_l1_addr_mask(ctx)) |
                                     INTEL_AUX_MAP_ENTRY_VALID_BIT;
diff --git a/src/intel/common/intel_debug_identifier.c b/src/intel/common/intel_debug_identifier.c
index db5a384e6e03b..2757508f75236 100644
--- a/src/intel/common/intel_debug_identifier.c
+++ b/src/intel/common/intel_debug_identifier.c
@@ -77,7 +77,7 @@ intel_debug_write_identifiers(void *_output,
       }
 
       default:
-         unreachable("Missing identifier write");
+         UNREACHABLE("Missing identifier write");
       }
 
       assert(output < output_end);
diff --git a/src/intel/common/intel_engine.c b/src/intel/common/intel_engine.c
index 882d26761a78f..fbff6490780b2 100644
--- a/src/intel/common/intel_engine.c
+++ b/src/intel/common/intel_engine.c
@@ -38,7 +38,7 @@ intel_engine_get_info(int fd, enum intel_kmd_type type)
    case INTEL_KMD_TYPE_XE:
       return xe_engine_get_info(fd);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return NULL;
    }
 }
@@ -85,7 +85,7 @@ is_guc_semaphore_functional(int fd, const struct intel_device_info *info)
    case INTEL_KMD_TYPE_XE:
       return xe_engines_is_guc_semaphore_functional(fd, info);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return false;
    }
 }
diff --git a/src/intel/common/intel_gem.c b/src/intel/common/intel_gem.c
index f2116d4d9712f..c3d06475612a9 100644
--- a/src/intel/common/intel_gem.c
+++ b/src/intel/common/intel_gem.c
@@ -110,7 +110,7 @@ intel_gem_read_render_timestamp(int fd,
    case INTEL_KMD_TYPE_XE:
       return xe_gem_read_render_timestamp(fd, value);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return false;
    }
 }
@@ -136,7 +136,7 @@ intel_gem_read_correlate_cpu_gpu_timestamp(int fd,
                                                      gpu_timestamp,
                                                      cpu_delta);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return false;
    }
 }
@@ -157,7 +157,7 @@ intel_gem_supports_protected_context(int fd, enum intel_kmd_type kmd_type)
    case INTEL_KMD_TYPE_XE:
       return xe_gem_supports_protected_exec_queue(fd);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return false;
    }
 }
@@ -197,7 +197,7 @@ intel_gem_can_render_on_fd(int fd, enum intel_kmd_type kmd_type)
    case INTEL_KMD_TYPE_XE:
       return xe_gem_can_render_on_fd(fd);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return false;
    }
 }
diff --git a/src/intel/common/intel_genX_state_brw.h b/src/intel/common/intel_genX_state_brw.h
index e6d42e3f1af7f..001abeea9f280 100644
--- a/src/intel/common/intel_genX_state_brw.h
+++ b/src/intel/common/intel_genX_state_brw.h
@@ -149,7 +149,7 @@ intel_set_ps_dispatch_state(struct GENX(3DSTATE_PS) *ps,
          ps->Kernel0PolyPackingPolicy = POLY_PACK16_FIXED;
          break;
       default:
-         unreachable("Invalid polygon width");
+         UNREACHABLE("Invalid polygon width");
       }
    } else if (enable_16) {
       ps->Kernel0Enable = true;
diff --git a/src/intel/common/intel_l3_config.c b/src/intel/common/intel_l3_config.c
index 41c6d902c6afa..82af47042e835 100644
--- a/src/intel/common/intel_l3_config.c
+++ b/src/intel/common/intel_l3_config.c
@@ -207,7 +207,7 @@ get_l3_list(const struct intel_device_info *devinfo)
       return &empty_l3_list;
 
    default:
-      unreachable("Not implemented");
+      UNREACHABLE("Not implemented");
    }
 }
 
diff --git a/src/intel/common/intel_sample_positions.h b/src/intel/common/intel_sample_positions.h
index 66ce0d0786bd1..1e872f878ced3 100644
--- a/src/intel/common/intel_sample_positions.h
+++ b/src/intel/common/intel_sample_positions.h
@@ -50,7 +50,7 @@ intel_get_sample_positions(int samples)
    case 4: return intel_sample_positions_4x;
    case 8: return intel_sample_positions_8x;
    case 16: return intel_sample_positions_16x;
-   default: unreachable("Invalid sample count");
+   default: UNREACHABLE("Invalid sample count");
    }
 }
 
diff --git a/src/intel/common/mi_builder.h b/src/intel/common/mi_builder.h
index 822de018f8e1e..b7c6fd81f484b 100644
--- a/src/intel/common/mi_builder.h
+++ b/src/intel/common/mi_builder.h
@@ -486,7 +486,7 @@ mi_value_half(struct mi_value value, bool top_32_bits)
       return value;
    }
 
-   unreachable("Invalid mi_value type");
+   UNREACHABLE("Invalid mi_value type");
 }
 
 static inline void
@@ -507,7 +507,7 @@ _mi_copy_no_unref(struct mi_builder *b,
 
    switch (dst.type) {
    case MI_VALUE_TYPE_IMM:
-      unreachable("Cannot copy to an immediate");
+      UNREACHABLE("Cannot copy to an immediate");
 
    case MI_VALUE_TYPE_MEM64:
    case MI_VALUE_TYPE_REG64:
@@ -567,7 +567,7 @@ _mi_copy_no_unref(struct mi_builder *b,
                               mi_value_half(src, true));
          break;
       default:
-         unreachable("Invalid mi_value type");
+         UNREACHABLE("Invalid mi_value type");
       }
       break;
 
@@ -598,7 +598,7 @@ _mi_copy_no_unref(struct mi_builder *b,
             mi_value_unref(b, tmp);
          }
 #else
-         unreachable("Cannot do mem <-> mem copy on IVB and earlier");
+         UNREACHABLE("Cannot do mem <-> mem copy on IVB and earlier");
 #endif
          break;
 
@@ -615,7 +615,7 @@ _mi_copy_no_unref(struct mi_builder *b,
          break;
 
       default:
-         unreachable("Invalid mi_value type");
+         UNREACHABLE("Invalid mi_value type");
       }
       break;
 
@@ -644,7 +644,7 @@ _mi_copy_no_unref(struct mi_builder *b,
             lrm.MemoryAddress = src.addr;
          }
 #else
-         unreachable("Cannot load do mem -> reg copy on SNB and earlier");
+         UNREACHABLE("Cannot load do mem -> reg copy on SNB and earlier");
 #endif
          break;
 
@@ -666,17 +666,17 @@ _mi_copy_no_unref(struct mi_builder *b,
             }
          }
 #else
-         unreachable("Cannot do reg <-> reg copy on IVB and earlier");
+         UNREACHABLE("Cannot do reg <-> reg copy on IVB and earlier");
 #endif
          break;
 
       default:
-         unreachable("Invalid mi_value type");
+         UNREACHABLE("Invalid mi_value type");
       }
       break;
 
    default:
-      unreachable("Invalid mi_value type");
+      UNREACHABLE("Invalid mi_value type");
    }
 
 
@@ -1373,7 +1373,7 @@ mi_store_relocated_imm(struct mi_builder *b, struct mi_value dst)
    }
 
    default:
-      unreachable("Invalid value type");
+      UNREACHABLE("Invalid value type");
    }
 
    mi_value_unref(b, dst);
@@ -1393,7 +1393,7 @@ mi_relocate_store_imm(struct mi_reloc_imm_token token, uint64_t value)
       *token.ptr[0] = value & 0xffffffff;
       break;
    default:
-      unreachable("Invalid value type");
+      UNREACHABLE("Invalid value type");
    }
 }
 
diff --git a/src/intel/compiler/brw_compile_mesh.cpp b/src/intel/compiler/brw_compile_mesh.cpp
index 1a3d654b5aaa6..ecdf7b06f078c 100644
--- a/src/intel/compiler/brw_compile_mesh.cpp
+++ b/src/intel/compiler/brw_compile_mesh.cpp
@@ -231,7 +231,7 @@ lower_set_vtx_and_prim_to_temp_write(nir_builder *b,
     */
    if (nir_src_is_const(intrin->src[1]) &&
        nir_src_as_uint(intrin->src[1]) > b->shader->info.mesh.max_primitives_out)
-      unreachable("number of primitives bigger than max specified");
+      UNREACHABLE("number of primitives bigger than max specified");
 
    b->cursor = nir_instr_remove(&intrin->instr);
 
@@ -543,7 +543,7 @@ brw_compute_mue_map(const struct brw_compiler *compiler,
       map->per_primitive_indices_stride = 4;
       break;
    default:
-      unreachable("invalid index format");
+      UNREACHABLE("invalid index format");
    }
 
    map->size += map->per_primitive_indices_stride * map->max_primitives;
diff --git a/src/intel/compiler/brw_compile_tes.cpp b/src/intel/compiler/brw_compile_tes.cpp
index 88f29a84a8a73..8c8f0fe113274 100644
--- a/src/intel/compiler/brw_compile_tes.cpp
+++ b/src/intel/compiler/brw_compile_tes.cpp
@@ -129,7 +129,7 @@ brw_compile_tes(const struct brw_compiler *compiler,
       prog_data->domain = INTEL_TESS_DOMAIN_ISOLINE;
       break;
    default:
-      unreachable("invalid domain shader primitive mode");
+      UNREACHABLE("invalid domain shader primitive mode");
    }
 
    if (nir->info.tess.point_mode) {
diff --git a/src/intel/compiler/brw_compiler.c b/src/intel/compiler/brw_compiler.c
index a534f4d5a5cd2..4b5bca04f2132 100644
--- a/src/intel/compiler/brw_compiler.c
+++ b/src/intel/compiler/brw_compiler.c
@@ -354,7 +354,7 @@ brw_write_shader_relocs(const struct brw_isa_info *isa,
                brw_update_reloc_imm(isa, dst, value);
                break;
             default:
-               unreachable("Invalid relocation type");
+               UNREACHABLE("Invalid relocation type");
             }
             break;
          }
diff --git a/src/intel/compiler/brw_compiler.h b/src/intel/compiler/brw_compiler.h
index eec83d7faca20..4bfaaf97f9cb7 100644
--- a/src/intel/compiler/brw_compiler.h
+++ b/src/intel/compiler/brw_compiler.h
@@ -918,7 +918,7 @@ brw_fs_simd_width_for_ksp(unsigned ksp_idx, bool simd8_enabled,
    case 2:
       return (simd16_enabled && (simd32_enabled || simd8_enabled)) ? 16 : 0;
    default:
-      unreachable("Invalid KSP index");
+      UNREACHABLE("Invalid KSP index");
    }
 }
 
diff --git a/src/intel/compiler/brw_disasm.c b/src/intel/compiler/brw_disasm.c
index 50f89099f33e3..beae313e9f313 100644
--- a/src/intel/compiler/brw_disasm.c
+++ b/src/intel/compiler/brw_disasm.c
@@ -969,7 +969,7 @@ hstride_from_align1_3src_dst_hstride(enum brw_align1_3src_dst_horizontal_stride
    case BRW_ALIGN1_3SRC_DST_HORIZONTAL_STRIDE_1: return BRW_HORIZONTAL_STRIDE_1;
    case BRW_ALIGN1_3SRC_DST_HORIZONTAL_STRIDE_2: return BRW_HORIZONTAL_STRIDE_2;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1195,7 +1195,7 @@ vstride_from_align1_3src_vstride(const struct intel_device_info *devinfo,
    case BRW_ALIGN1_3SRC_VERTICAL_STRIDE_4: return BRW_VERTICAL_STRIDE_4;
    case BRW_ALIGN1_3SRC_VERTICAL_STRIDE_8: return BRW_VERTICAL_STRIDE_8;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1208,7 +1208,7 @@ hstride_from_align1_3src_hstride(enum brw_align1_3src_src_horizontal_stride hstr
    case BRW_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_2: return BRW_HORIZONTAL_STRIDE_2;
    case BRW_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_4: return BRW_HORIZONTAL_STRIDE_4;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1221,7 +1221,7 @@ vstride_from_align1_3src_hstride(enum brw_align1_3src_src_horizontal_stride hstr
    case BRW_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_2: return BRW_VERTICAL_STRIDE_2;
    case BRW_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_4: return BRW_VERTICAL_STRIDE_4;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1246,7 +1246,7 @@ implied_width(enum brw_vertical_stride _vert_stride,
       case BRW_VERTICAL_STRIDE_8: return BRW_WIDTH_8;
       case BRW_VERTICAL_STRIDE_0:
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
    } else {
diff --git a/src/intel/compiler/brw_eu.c b/src/intel/compiler/brw_eu.c
index 4f32758f907f5..9cac5dfa1fe9e 100644
--- a/src/intel/compiler/brw_eu.c
+++ b/src/intel/compiler/brw_eu.c
@@ -61,7 +61,7 @@ brw_negate_cmod(enum brw_conditional_mod cmod)
    case BRW_CONDITIONAL_LE:
       return BRW_CONDITIONAL_G;
    default:
-      unreachable("Can't negate this cmod");
+      UNREACHABLE("Can't negate this cmod");
    }
 }
 
@@ -734,6 +734,6 @@ brw_num_sources_from_inst(const struct brw_isa_info *isa,
    case BRW_MATH_FUNCTION_INT_DIV_REMAINDER:
       return 2;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
diff --git a/src/intel/compiler/brw_eu.h b/src/intel/compiler/brw_eu.h
index 0bb8ec67d5e6b..8a8fa445c9dd5 100644
--- a/src/intel/compiler/brw_eu.h
+++ b/src/intel/compiler/brw_eu.h
@@ -606,7 +606,7 @@ brw_mdc_ds(unsigned bit_size)
    case 32:
       return GFX7_BYTE_SCATTERED_DATA_ELEMENT_DWORD;
    default:
-      unreachable("Unsupported bit_size for byte scattered messages");
+      UNREACHABLE("Unsupported bit_size for byte scattered messages");
    }
 }
 
@@ -726,7 +726,7 @@ brw_mdc_a64_ds(unsigned elems)
    case 4:  return 2;
    case 8:  return 3;
    default:
-      unreachable("Unsupported elmeent count for A64 scattered message");
+      UNREACHABLE("Unsupported elmeent count for A64 scattered message");
    }
 }
 
@@ -1060,7 +1060,7 @@ lsc_op_to_legacy_atomic(unsigned _op)
    /* No LSC op maps to BRW_AOP_PREDEC */
    case LSC_OP_ATOMIC_LOAD:
    case LSC_OP_ATOMIC_FSUB:
-      unreachable("no corresponding legacy atomic operation");
+      UNREACHABLE("no corresponding legacy atomic operation");
    case LSC_OP_LOAD:
    case LSC_OP_LOAD_CMASK:
    case LSC_OP_STORE:
@@ -1068,10 +1068,10 @@ lsc_op_to_legacy_atomic(unsigned _op)
    case LSC_OP_FENCE:
    case LSC_OP_LOAD_CMASK_MSRT:
    case LSC_OP_STORE_CMASK_MSRT:
-      unreachable("not an atomic op");
+      UNREACHABLE("not an atomic op");
    }
 
-   unreachable("invalid LSC op");
+   UNREACHABLE("invalid LSC op");
 }
 
 static inline uint32_t
@@ -1090,7 +1090,7 @@ lsc_data_size_bytes(enum lsc_data_size data_size)
    case LSC_DATA_SIZE_D64:
       return 8;
    default:
-      unreachable("Unsupported data payload size.");
+      UNREACHABLE("Unsupported data payload size.");
    }
 }
 
@@ -1102,7 +1102,7 @@ lsc_addr_size_bytes(enum lsc_addr_size addr_size)
    case LSC_ADDR_SIZE_A32: return 4;
    case LSC_ADDR_SIZE_A64: return 8;
    default:
-      unreachable("Unsupported address size.");
+      UNREACHABLE("Unsupported address size.");
    }
 }
 
@@ -1119,7 +1119,7 @@ lsc_vector_length(enum lsc_vect_size vect_size)
    case LSC_VECT_SIZE_V32: return 32;
    case LSC_VECT_SIZE_V64: return 64;
    default:
-      unreachable("Unsupported size of vector");
+      UNREACHABLE("Unsupported size of vector");
    }
 }
 
@@ -1136,7 +1136,7 @@ lsc_vect_size(unsigned vect_size)
    case 32: return LSC_VECT_SIZE_V32;
    case 64: return LSC_VECT_SIZE_V64;
    default:
-      unreachable("Unsupported vector size for dataport");
+      UNREACHABLE("Unsupported vector size for dataport");
    }
 }
 
@@ -1443,7 +1443,7 @@ translate_systolic_depth(unsigned d)
    case 4:  return BRW_SYSTOLIC_DEPTH_4;
    case 8:  return BRW_SYSTOLIC_DEPTH_8;
    case 16: return BRW_SYSTOLIC_DEPTH_16;
-   default: unreachable("Invalid systolic depth.");
+   default: UNREACHABLE("Invalid systolic depth.");
    }
 }
 
diff --git a/src/intel/compiler/brw_eu_compact.c b/src/intel/compiler/brw_eu_compact.c
index 332f2e2b12bed..d60afc4864b94 100644
--- a/src/intel/compiler/brw_eu_compact.c
+++ b/src/intel/compiler/brw_eu_compact.c
@@ -1555,16 +1555,16 @@ uncompact_immediate(const struct intel_device_info *devinfo,
       case BRW_TYPE_UQ:
       case BRW_TYPE_B:
       case BRW_TYPE_UB:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       default:
-         unreachable("invalid type");
+         UNREACHABLE("invalid type");
       }
    } else {
       /* Replicate the 13th bit into the high 19 bits */
       return (int)(compact_imm << 19) >> 19;
    }
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 static bool
@@ -2323,7 +2323,7 @@ compaction_state_init(struct compaction_state *c,
       c->src1_index_table = gfx8_src_index_table;
       break;
    default:
-      unreachable("unknown generation");
+      UNREACHABLE("unknown generation");
    }
 }
 
diff --git a/src/intel/compiler/brw_eu_emit.c b/src/intel/compiler/brw_eu_emit.c
index b301ea5a26311..2480724ed75d1 100644
--- a/src/intel/compiler/brw_eu_emit.c
+++ b/src/intel/compiler/brw_eu_emit.c
@@ -525,7 +525,7 @@ to_3src_align1_vstride(const struct intel_device_info *devinfo,
    case BRW_VERTICAL_STRIDE_16:
       return BRW_ALIGN1_3SRC_VERTICAL_STRIDE_8;
    default:
-      unreachable("invalid vstride");
+      UNREACHABLE("invalid vstride");
    }
 }
 
@@ -538,7 +538,7 @@ to_3src_align1_dst_hstride(enum brw_horizontal_stride hstride)
    case BRW_HORIZONTAL_STRIDE_2:
       return BRW_ALIGN1_3SRC_DST_HORIZONTAL_STRIDE_2;
    default:
-      unreachable("invalid hstride");
+      UNREACHABLE("invalid hstride");
    }
 }
 
@@ -555,7 +555,7 @@ to_3src_align1_hstride(enum brw_horizontal_stride hstride)
    case BRW_HORIZONTAL_STRIDE_4:
       return BRW_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_4;
    default:
-      unreachable("invalid hstride");
+      UNREACHABLE("invalid hstride");
    }
 }
 
@@ -950,7 +950,7 @@ brw_AVG(struct brw_codegen *p, struct brw_reg dest,
    case BRW_TYPE_UD:
       break;
    default:
-      unreachable("Bad type for brw_AVG");
+      UNREACHABLE("Bad type for brw_AVG");
    }
 
    return brw_alu2(p, BRW_OPCODE_AVG, dest, src0, src1);
@@ -1629,7 +1629,7 @@ brw_find_loop_end(struct brw_codegen *p, int start_offset)
 	    return offset;
       }
    }
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 /* After program generation, go back and update the UIP and JIP of
diff --git a/src/intel/compiler/brw_eu_validate.c b/src/intel/compiler/brw_eu_validate.c
index 326b431e9af8d..a3f61da46774f 100644
--- a/src/intel/compiler/brw_eu_validate.c
+++ b/src/intel/compiler/brw_eu_validate.c
@@ -479,7 +479,7 @@ execution_type(const brw_hw_decoded_inst *inst)
        src1_exec_type == BRW_TYPE_DF)
       return BRW_TYPE_DF;
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 /**
@@ -712,7 +712,7 @@ general_restrictions_based_on_operand_types(const struct brw_isa_info *isa,
             ERROR_IF(brw_eu_inst_3src_a16_src2_rep_ctrl(devinfo, inst->raw),
                      "RepCtrl must be zero for 64-bit source 2");
             break;
-         default: unreachable("invalid src");
+         default: UNREACHABLE("invalid src");
          }
       }
    }
@@ -2568,7 +2568,7 @@ DST_STRIDE_3SRC(unsigned hstride)
    case BRW_ALIGN1_3SRC_DST_HORIZONTAL_STRIDE_1: return 1;
    case BRW_ALIGN1_3SRC_DST_HORIZONTAL_STRIDE_2: return 2;
    }
-   unreachable("invalid hstride");
+   UNREACHABLE("invalid hstride");
 }
 
 static unsigned
@@ -2580,7 +2580,7 @@ VSTRIDE_3SRC(unsigned vstride)
    case BRW_ALIGN1_3SRC_VERTICAL_STRIDE_4: return 4;
    case BRW_ALIGN1_3SRC_VERTICAL_STRIDE_8: return 8;
    }
-   unreachable("invalid vstride");
+   UNREACHABLE("invalid vstride");
 }
 
 static inline unsigned
diff --git a/src/intel/compiler/brw_from_nir.cpp b/src/intel/compiler/brw_from_nir.cpp
index 455383ae1065c..774810476fb06 100644
--- a/src/intel/compiler/brw_from_nir.cpp
+++ b/src/intel/compiler/brw_from_nir.cpp
@@ -206,14 +206,14 @@ emit_system_values_block(nir_to_brw_state &ntb, nir_block *block)
       switch (intrin->intrinsic) {
       case nir_intrinsic_load_vertex_id:
       case nir_intrinsic_load_base_vertex:
-         unreachable("should be lowered by nir_lower_system_values().");
+         UNREACHABLE("should be lowered by nir_lower_system_values().");
 
       case nir_intrinsic_load_vertex_id_zero_base:
       case nir_intrinsic_load_is_indexed_draw:
       case nir_intrinsic_load_first_vertex:
       case nir_intrinsic_load_instance_id:
       case nir_intrinsic_load_base_instance:
-         unreachable("should be lowered by brw_nir_lower_vs_inputs().");
+         UNREACHABLE("should be lowered by brw_nir_lower_vs_inputs().");
          break;
 
       case nir_intrinsic_load_draw_id:
@@ -221,7 +221,7 @@ emit_system_values_block(nir_to_brw_state &ntb, nir_block *block)
           * nir_emit_mesh_task_intrinsic().
           */
          if (!gl_shader_stage_is_mesh(s.stage))
-            unreachable("should be lowered by brw_nir_lower_vs_inputs().");
+            UNREACHABLE("should be lowered by brw_nir_lower_vs_inputs().");
          break;
 
       case nir_intrinsic_load_invocation_id:
@@ -258,7 +258,7 @@ emit_system_values_block(nir_to_brw_state &ntb, nir_block *block)
 
       case nir_intrinsic_load_workgroup_id:
          if (gl_shader_stage_is_mesh(s.stage))
-            unreachable("should be lowered by nir_lower_compute_system_values().");
+            UNREACHABLE("should be lowered by nir_lower_compute_system_values().");
          assert(gl_shader_stage_is_compute(s.stage));
          reg = &ntb.system_values[SYSTEM_VALUE_WORKGROUP_ID];
          if (reg->file == BAD_FILE)
@@ -376,7 +376,7 @@ brw_from_nir_emit_cf_list(nir_to_brw_state &ntb, exec_list *list)
          break;
 
       default:
-         unreachable("Invalid CFG node block");
+         UNREACHABLE("Invalid CFG node block");
       }
    }
 }
@@ -714,7 +714,7 @@ brw_rnd_mode_from_nir_op (const nir_op op) {
    case nir_op_f2f16_rtne:
       return BRW_RND_MODE_RTNE;
    default:
-      unreachable("Operation doesn't support rounding mode");
+      UNREACHABLE("Operation doesn't support rounding mode");
    }
 }
 
@@ -1144,7 +1144,7 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
       break;
 
    case nir_op_fsign:
-      unreachable("Should have been lowered by brw_nir_lower_fsign.");
+      UNREACHABLE("Should have been lowered by brw_nir_lower_fsign.");
 
    case nir_op_frcp:
       bld.RCP(result, op[0]);
@@ -1275,10 +1275,10 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
       break;
 
    case nir_op_uadd_carry:
-      unreachable("Should have been lowered by carry_to_arith().");
+      UNREACHABLE("Should have been lowered by carry_to_arith().");
 
    case nir_op_usub_borrow:
-      unreachable("Should have been lowered by borrow_to_arith().");
+      UNREACHABLE("Should have been lowered by borrow_to_arith().");
 
    case nir_op_umod:
    case nir_op_irem:
@@ -1443,7 +1443,7 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
             return;
 
          default:
-            unreachable("impossible opcode");
+            UNREACHABLE("impossible opcode");
          }
       }
       op[0] = resolve_source_modifiers(bld, op[0]);
@@ -1479,10 +1479,10 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
    case nir_op_b32any_inequal3:
    case nir_op_b32any_fnequal4:
    case nir_op_b32any_inequal4:
-      unreachable("Lowered by nir_lower_alu_reductions");
+      UNREACHABLE("Lowered by nir_lower_alu_reductions");
 
    case nir_op_ldexp:
-      unreachable("not reached: should be handled by ldexp_to_arith()");
+      UNREACHABLE("not reached: should be handled by ldexp_to_arith()");
 
    case nir_op_fsqrt:
       bld.SQRT(result, op[0]);
@@ -1531,7 +1531,7 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
    case nir_op_unpack_unorm_4x8:
    case nir_op_unpack_half_2x16:
    case nir_op_pack_half_2x16:
-      unreachable("not reached: should be handled by lower_packing_builtins");
+      UNREACHABLE("not reached: should be handled by lower_packing_builtins");
 
    case nir_op_unpack_half_2x16_split_x:
       bld.MOV(result, subscript(op[0], BRW_TYPE_HF, 0));
@@ -1620,7 +1620,7 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
 
    case nir_op_ubitfield_extract:
    case nir_op_ibitfield_extract:
-      unreachable("should have been lowered");
+      UNREACHABLE("should have been lowered");
    case nir_op_ubfe:
    case nir_op_ibfe:
       assert(instr->def.bit_size < 64);
@@ -1645,7 +1645,7 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
       break;
 
    case nir_op_bitfield_insert:
-      unreachable("not reached: should have been lowered");
+      UNREACHABLE("not reached: should have been lowered");
 
    /* With regards to implicit masking of the shift counts for 8- and 16-bit
     * types, the PRMs are **incorrect**. They falsely state that on Gen9+ only
@@ -1845,7 +1845,7 @@ brw_from_nir_emit_alu(nir_to_brw_state &ntb, nir_alu_instr *instr,
       break;
 
    default:
-      unreachable("unhandled instruction");
+      UNREACHABLE("unhandled instruction");
    }
 }
 
@@ -1892,7 +1892,7 @@ brw_from_nir_emit_load_const(nir_to_brw_state &ntb,
       break;
 
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
 
    bld.VEC(reg, comps, instr->def.num_components);
@@ -2879,7 +2879,7 @@ brw_from_nir_emit_vs_intrinsic(nir_to_brw_state &ntb,
    switch (instr->intrinsic) {
    case nir_intrinsic_load_vertex_id:
    case nir_intrinsic_load_base_vertex:
-      unreachable("should be lowered by nir_lower_system_values()");
+      UNREACHABLE("should be lowered by nir_lower_system_values()");
 
    case nir_intrinsic_load_input: {
       assert(instr->def.bit_size == 32);
@@ -2897,7 +2897,7 @@ brw_from_nir_emit_vs_intrinsic(nir_to_brw_state &ntb,
    case nir_intrinsic_load_draw_id:
    case nir_intrinsic_load_first_vertex:
    case nir_intrinsic_load_is_indexed_draw:
-      unreachable("lowered by brw_nir_lower_vs_inputs");
+      UNREACHABLE("lowered by brw_nir_lower_vs_inputs");
 
    default:
       brw_from_nir_emit_intrinsic(ntb, bld, instr);
@@ -3135,7 +3135,7 @@ brw_from_nir_emit_tcs_intrinsic(nir_to_brw_state &ntb,
       break;
 
    case nir_intrinsic_load_input:
-      unreachable("nir_lower_io should never give us these.");
+      UNREACHABLE("nir_lower_io should never give us these.");
       break;
 
    case nir_intrinsic_load_per_vertex_input: {
@@ -3453,7 +3453,7 @@ brw_from_nir_emit_gs_intrinsic(nir_to_brw_state &ntb,
       break;
 
    case nir_intrinsic_load_input:
-      unreachable("load_input intrinsics are invalid for the GS stage");
+      UNREACHABLE("load_input intrinsics are invalid for the GS stage");
 
    case nir_intrinsic_load_per_vertex_input:
       emit_gs_input_load(ntb, dest, instr->src[0], nir_intrinsic_base(instr),
@@ -3790,7 +3790,7 @@ alloc_frag_output(nir_to_brw_state &ntb, unsigned location)
                              &s.outputs[l - FRAG_RESULT_DATA0], 1);
 
    else
-      unreachable("Invalid location");
+      UNREACHABLE("Invalid location");
 }
 
 static void
@@ -4789,7 +4789,7 @@ brw_from_nir_emit_cs_intrinsic(nir_to_brw_state &ntb,
       /* Should have been lowered by brw_nir_lower_cs_intrinsics() or
        * iris_setup_uniforms() for the variable group size case.
        */
-      unreachable("Should have been lowered");
+      UNREACHABLE("Should have been lowered");
       break;
    }
 
@@ -4919,7 +4919,7 @@ brw_from_nir_emit_cs_intrinsic(nir_to_brw_state &ntb,
          break;
       }
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
       break;
    }
@@ -5008,7 +5008,7 @@ brw_reduce_op_for_nir_reduction_op(nir_op op)
    case nir_op_ior:  return BRW_REDUCE_OP_OR;
    case nir_op_ixor: return BRW_REDUCE_OP_XOR;
    default:
-      unreachable("Invalid reduction operation");
+      UNREACHABLE("Invalid reduction operation");
    }
 }
 
@@ -5833,7 +5833,7 @@ brw_from_nir_emit_task_mesh_intrinsic(nir_to_brw_state &ntb, const brw_builder &
       break;
 
    case nir_intrinsic_load_local_invocation_id:
-      unreachable("local invocation id should have been lowered earlier");
+      UNREACHABLE("local invocation id should have been lowered earlier");
       break;
 
    case nir_intrinsic_load_local_invocation_index:
@@ -6114,7 +6114,7 @@ brw_from_nir_emit_intrinsic(nir_to_brw_state &ntb,
          break;
 
       default:
-         unreachable("invalid intrinsic");
+         UNREACHABLE("invalid intrinsic");
       }
 
       if (opcode == BRW_OPCODE_NOP)
@@ -6605,7 +6605,7 @@ brw_from_nir_emit_intrinsic(nir_to_brw_state &ntb,
    case nir_intrinsic_load_subgroup_gt_mask:
    case nir_intrinsic_load_subgroup_le_mask:
    case nir_intrinsic_load_subgroup_lt_mask:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
 
    case nir_intrinsic_ddx_fine:
       bld.emit(FS_OPCODE_DDX_FINE, retype(dest, BRW_TYPE_F),
@@ -6762,7 +6762,7 @@ brw_from_nir_emit_intrinsic(nir_to_brw_state &ntb,
       case nir_intrinsic_quad_swap_horizontal: dir = BRW_SWAP_HORIZONTAL; break;
       case nir_intrinsic_quad_swap_vertical:   dir = BRW_SWAP_VERTICAL;   break;
       case nir_intrinsic_quad_swap_diagonal:   dir = BRW_SWAP_DIAGONAL;   break;
-      default: unreachable("invalid quad swap");
+      default: UNREACHABLE("invalid quad swap");
       }
 
       bld.emit(SHADER_OPCODE_QUAD_SWAP, retype(dest, value.type),
@@ -6957,7 +6957,7 @@ brw_from_nir_emit_intrinsic(nir_to_brw_state &ntb,
          break;
       }
       default:
-         unreachable("Invalid topology id type");
+         UNREACHABLE("Invalid topology id type");
       }
       break;
    }
@@ -7052,7 +7052,7 @@ brw_from_nir_emit_intrinsic(nir_to_brw_state &ntb,
       assert(instr->intrinsic < nir_num_intrinsics);
       fprintf(stderr, "intrinsic: %s\n", nir_intrinsic_infos[instr->intrinsic].name);
 #endif
-      unreachable("unknown intrinsic");
+      UNREACHABLE("unknown intrinsic");
    }
 }
 
@@ -7065,7 +7065,7 @@ lsc_bits_to_data_size(unsigned bit_size)
    case 4:  return LSC_DATA_SIZE_D32;
    case 8:  return LSC_DATA_SIZE_D64;
    default:
-      unreachable("Unsupported data size.");
+      UNREACHABLE("Unsupported data size.");
    }
 }
 
@@ -7255,7 +7255,7 @@ brw_from_nir_emit_memory_access(nir_to_brw_state &ntb,
       break;
 
    default:
-      unreachable("unknown memory intrinsic");
+      UNREACHABLE("unknown memory intrinsic");
    }
 
    unsigned components = is_store ? instr->src[data_src].ssa->num_components
@@ -7525,7 +7525,7 @@ brw_from_nir_emit_texture(nir_to_brw_state &ntb,
          break;
 
       case nir_tex_src_projector:
-         unreachable("should be lowered");
+         UNREACHABLE("should be lowered");
 
       case nir_tex_src_texture_offset: {
          assert(srcs[TEX_LOGICAL_SRC_SURFACE].file == BAD_FILE);
@@ -7595,7 +7595,7 @@ brw_from_nir_emit_texture(nir_to_brw_state &ntb,
          break;
 
       default:
-         unreachable("unknown texture source");
+         UNREACHABLE("unknown texture source");
       }
    }
 
@@ -7711,7 +7711,7 @@ brw_from_nir_emit_texture(nir_to_brw_state &ntb,
       return;
    }
    default:
-      unreachable("unknown texture opcode");
+      UNREACHABLE("unknown texture opcode");
    }
 
    if (instr->op == nir_texop_tg4) {
@@ -7845,7 +7845,7 @@ brw_from_nir_emit_jump(nir_to_brw_state &ntb, nir_jump_instr *instr)
       break;
    case nir_jump_return:
    default:
-      unreachable("unknown jump");
+      UNREACHABLE("unknown jump");
    }
 }
 
@@ -7865,7 +7865,7 @@ brw_from_nir_emit_instr(nir_to_brw_state &ntb, nir_instr *instr)
       break;
 
    case nir_instr_type_deref:
-      unreachable("All derefs should've been lowered");
+      UNREACHABLE("All derefs should've been lowered");
       break;
 
    case nir_instr_type_intrinsic:
@@ -7904,7 +7904,7 @@ brw_from_nir_emit_instr(nir_to_brw_state &ntb, nir_instr *instr)
          brw_from_nir_emit_mesh_intrinsic(ntb, nir_instr_as_intrinsic(instr));
          break;
       default:
-         unreachable("unsupported shader stage");
+         UNREACHABLE("unsupported shader stage");
       }
       break;
 
@@ -7928,7 +7928,7 @@ brw_from_nir_emit_instr(nir_to_brw_state &ntb, nir_instr *instr)
       break;
 
    default:
-      unreachable("unknown instruction type");
+      UNREACHABLE("unknown instruction type");
    }
 }
 
diff --git a/src/intel/compiler/brw_generator.cpp b/src/intel/compiler/brw_generator.cpp
index 260b7d7de9735..84022d06738fd 100644
--- a/src/intel/compiler/brw_generator.cpp
+++ b/src/intel/compiler/brw_generator.cpp
@@ -61,7 +61,7 @@ brw_math_function(enum opcode op)
    case SHADER_OPCODE_INT_REMAINDER:
       return BRW_MATH_FUNCTION_INT_DIV_REMAINDER;
    default:
-      unreachable("not reached: unknown math function");
+      UNREACHABLE("not reached: unknown math function");
    }
 }
 
@@ -85,7 +85,7 @@ normalize_brw_reg_for_encoding(brw_reg *reg)
    case VGRF:
    case ATTR:
    case UNIFORM:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    return brw_reg;
@@ -1209,7 +1209,7 @@ brw_generator::generate_code(const cfg_t *cfg, int dispatch_width,
       case SHADER_OPCODE_FIND_LIVE_CHANNEL:
       case SHADER_OPCODE_FIND_LAST_LIVE_CHANNEL:
       case SHADER_OPCODE_LOAD_LIVE_CHANNELS:
-         unreachable("Should be lowered by lower_find_live_channel()");
+         UNREACHABLE("Should be lowered by lower_find_live_channel()");
          break;
 
       case FS_OPCODE_LOAD_LIVE_CHANNELS: {
@@ -1337,10 +1337,10 @@ brw_generator::generate_code(const cfg_t *cfg, int dispatch_width,
          break;
 
       default:
-         unreachable("Unsupported opcode");
+         UNREACHABLE("Unsupported opcode");
 
       case SHADER_OPCODE_LOAD_PAYLOAD:
-         unreachable("Should be lowered by lower_load_payload()");
+         UNREACHABLE("Should be lowered by lower_load_payload()");
       }
       prev_inst = inst;
 
diff --git a/src/intel/compiler/brw_inst.cpp b/src/intel/compiler/brw_inst.cpp
index c378f25d847ea..183eec8e2c8f4 100644
--- a/src/intel/compiler/brw_inst.cpp
+++ b/src/intel/compiler/brw_inst.cpp
@@ -49,7 +49,7 @@ brw_inst::init(enum opcode opcode, uint8_t exec_size, const brw_reg &dst,
       break;
    case IMM:
    case UNIFORM:
-      unreachable("Invalid destination register file");
+      UNREACHABLE("Invalid destination register file");
    }
 
    this->writes_accumulator = false;
@@ -509,7 +509,7 @@ brw_inst::components_read(unsigned i) const
          return 1;
 
    case BRW_OPCODE_DPAS:
-      unreachable("Do not use components_read() for DPAS.");
+      UNREACHABLE("Do not use components_read() for DPAS.");
 
    default:
       return 1;
@@ -582,7 +582,7 @@ brw_inst::size_read(const struct intel_device_info *devinfo, int arg) const
           */
          return rcount * sdepth * 4;
       default:
-         unreachable("Invalid source number.");
+         UNREACHABLE("Invalid source number.");
       }
       break;
    }
@@ -633,7 +633,7 @@ namespace {
          case BRW_PREDICATE_ALIGN1_ALL16H:   return 16;
          case BRW_PREDICATE_ALIGN1_ANY32H:   return 32;
          case BRW_PREDICATE_ALIGN1_ALL32H:   return 32;
-         default: unreachable("Unsupported predicate");
+         default: UNREACHABLE("Unsupported predicate");
          }
       }
    }
diff --git a/src/intel/compiler/brw_lower.cpp b/src/intel/compiler/brw_lower.cpp
index bf4a2ab2c2c5f..53900d803f6f4 100644
--- a/src/intel/compiler/brw_lower.cpp
+++ b/src/intel/compiler/brw_lower.cpp
@@ -491,7 +491,7 @@ brw_lower_find_live_channel(brw_shader &s)
          break;
 
       default:
-         unreachable("Impossible.");
+         UNREACHABLE("Impossible.");
       }
 
       inst->remove();
diff --git a/src/intel/compiler/brw_lower_logical_sends.cpp b/src/intel/compiler/brw_lower_logical_sends.cpp
index ab8e4aaa424ed..b1dc907cb3851 100644
--- a/src/intel/compiler/brw_lower_logical_sends.cpp
+++ b/src/intel/compiler/brw_lower_logical_sends.cpp
@@ -661,7 +661,7 @@ sampler_msg_type(const intel_device_info *devinfo,
       assert(!has_min_lod);
       return GFX6_SAMPLER_MESSAGE_SAMPLE_SAMPLEINFO;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1467,7 +1467,7 @@ setup_lsc_surface_descriptors(const brw_builder &bld, brw_inst *inst,
       break;
 
    default:
-      unreachable("Invalid LSC surface address type");
+      UNREACHABLE("Invalid LSC surface address type");
    }
 }
 
@@ -1478,7 +1478,7 @@ lsc_addr_size_for_type(enum brw_reg_type type)
    case 2: return LSC_ADDR_SIZE_A16;
    case 4: return LSC_ADDR_SIZE_A32;
    case 8: return LSC_ADDR_SIZE_A64;
-   default: unreachable("invalid type size");
+   default: UNREACHABLE("invalid type size");
    }
 }
 
@@ -1961,7 +1961,7 @@ lower_hdc_memory_logical_send(const brw_builder &bld, brw_inst *inst)
       }
       break;
    default:
-      unreachable("Unknown surface type");
+      UNREACHABLE("Unknown surface type");
    }
 
    inst->desc = desc;
@@ -2168,7 +2168,7 @@ lower_interpolator_logical_send(const brw_builder &bld, brw_inst *inst,
       break;
 
    default:
-      unreachable("Invalid interpolator instruction");
+      UNREACHABLE("Invalid interpolator instruction");
    }
 
    const bool dynamic_mode =
@@ -2298,7 +2298,7 @@ lower_btd_logical_send(const brw_builder &bld, brw_inst *inst)
       break;
 
    default:
-      unreachable("Invalid BTD message");
+      UNREACHABLE("Invalid BTD message");
    }
 
    /* Stack IDs are always in R1 regardless of whether we're coming from a
diff --git a/src/intel/compiler/brw_lower_pack.cpp b/src/intel/compiler/brw_lower_pack.cpp
index a6801ec39244e..8abb4b3d7b164 100644
--- a/src/intel/compiler/brw_lower_pack.cpp
+++ b/src/intel/compiler/brw_lower_pack.cpp
@@ -69,7 +69,7 @@ brw_lower_pack(brw_shader &s)
          }
          break;
       default:
-         unreachable("skipped above");
+         UNREACHABLE("skipped above");
       }
 
       inst->remove();
diff --git a/src/intel/compiler/brw_lower_regioning.cpp b/src/intel/compiler/brw_lower_regioning.cpp
index 3f2ca520dda19..7a1c3c8dbcefd 100644
--- a/src/intel/compiler/brw_lower_regioning.cpp
+++ b/src/intel/compiler/brw_lower_regioning.cpp
@@ -421,7 +421,7 @@ namespace {
             return 0x3;
 
          default:
-            unreachable("Unknown invalid execution type source mask.");
+            UNREACHABLE("Unknown invalid execution type source mask.");
          }
       } else {
          return 0;
diff --git a/src/intel/compiler/brw_lower_subgroup_ops.cpp b/src/intel/compiler/brw_lower_subgroup_ops.cpp
index 45d0072641367..e827d772a3e06 100644
--- a/src/intel/compiler/brw_lower_subgroup_ops.cpp
+++ b/src/intel/compiler/brw_lower_subgroup_ops.cpp
@@ -32,7 +32,7 @@ brw_get_reduction_info(brw_reduce_op red_op, brw_reg_type type)
    case BRW_REDUCE_OP_MIN: info.cond_mod = BRW_CONDITIONAL_L;  break;
    case BRW_REDUCE_OP_MAX: info.cond_mod = BRW_CONDITIONAL_GE; break;
    default:
-      unreachable("invalid reduce op");
+      UNREACHABLE("invalid reduce op");
    }
 
    switch (red_op) {
@@ -102,7 +102,7 @@ brw_get_reduction_info(brw_reduce_op red_op, brw_reg_type type)
    }
 
    default:
-      unreachable("invalid reduce op");
+      UNREACHABLE("invalid reduce op");
    }
 
    /* For some cases above (e.g. all bits zeros, all bits ones, first bit one)
@@ -177,7 +177,7 @@ brw_emit_scan_step(const brw_builder &bld, enum opcode opcode, brw_conditional_m
       }
 
       default:
-         unreachable("Unsupported 64-bit scan op");
+         UNREACHABLE("Unsupported 64-bit scan op");
       }
    } else {
       set_condmod(mod, bld.emit(opcode, right, left, right));
diff --git a/src/intel/compiler/brw_nir.c b/src/intel/compiler/brw_nir.c
index 6f2a570c0bbf0..7e4335d8df0e7 100644
--- a/src/intel/compiler/brw_nir.c
+++ b/src/intel/compiler/brw_nir.c
@@ -94,7 +94,7 @@ type_size_xvec4(const struct glsl_type *type, bool as_vec4, bool bindless)
    case GLSL_TYPE_VOID:
    case GLSL_TYPE_ERROR:
    case GLSL_TYPE_COOPERATIVE_MATRIX:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    return 0;
@@ -199,7 +199,7 @@ remap_tess_levels(nir_builder *b, nir_intrinsic_instr *intr,
          out_of_bounds = true;
          break;
       default:
-         unreachable("Bogus tessellation domain");
+         UNREACHABLE("Bogus tessellation domain");
       }
    } else if (location == VARYING_SLOT_TESS_LEVEL_OUTER) {
       b->cursor = write ? nir_before_instr(&intr->instr)
@@ -251,7 +251,7 @@ remap_tess_levels(nir_builder *b, nir_intrinsic_instr *intr,
          }
          break;
       default:
-         unreachable("Bogus tessellation domain");
+         UNREACHABLE("Bogus tessellation domain");
       }
    } else {
       return false;
@@ -491,7 +491,7 @@ brw_nir_lower_vs_inputs(nir_shader *nir)
                      nir_intrinsic_set_component(load, 1);
                   break;
                default:
-                  unreachable("Invalid system value intrinsic");
+                  UNREACHABLE("Invalid system value intrinsic");
                }
 
                /* Position the value behind the app's inputs, for base we
@@ -1145,7 +1145,7 @@ lower_bit_size_callback(const nir_instr *instr, UNUSED void *data)
       case nir_op_fcos:
          return 0;
       case nir_op_isign:
-         unreachable("Should have been lowered by nir_opt_algebraic.");
+         UNREACHABLE("Should have been lowered by nir_opt_algebraic.");
       default:
          if (nir_op_infos[alu->op].num_inputs >= 2 &&
              alu->def.bit_size == 8)
@@ -2288,7 +2288,7 @@ get_subgroup_size(const struct shader_info *info, unsigned max_subgroup_size)
       return info->stage == MESA_SHADER_FRAGMENT ? 0 : max_subgroup_size;
 
    case SUBGROUP_SIZE_REQUIRE_4:
-      unreachable("Unsupported subgroup size type");
+      UNREACHABLE("Unsupported subgroup size type");
 
    case SUBGROUP_SIZE_REQUIRE_8:
    case SUBGROUP_SIZE_REQUIRE_16:
@@ -2304,7 +2304,7 @@ get_subgroup_size(const struct shader_info *info, unsigned max_subgroup_size)
       break;
    }
 
-   unreachable("Invalid subgroup size type");
+   UNREACHABLE("Invalid subgroup size type");
 }
 
 unsigned
@@ -2383,7 +2383,7 @@ brw_cmod_for_nir_comparison(nir_op op)
       return BRW_CONDITIONAL_NZ;
 
    default:
-      unreachable("Unsupported NIR comparison op");
+      UNREACHABLE("Unsupported NIR comparison op");
    }
 }
 
@@ -2449,7 +2449,7 @@ lsc_op_for_nir_intrinsic(const nir_intrinsic_instr *intrin)
          src_idx = 1;
          break;
       default:
-         unreachable("Invalid add atomic opcode");
+         UNREACHABLE("Invalid add atomic opcode");
       }
 
       if (nir_src_is_const(intrin->src[src_idx])) {
@@ -2478,7 +2478,7 @@ lsc_op_for_nir_intrinsic(const nir_intrinsic_instr *intrin)
    case nir_atomic_op_fadd: return LSC_OP_ATOMIC_FADD;
 
    default:
-      unreachable("Unsupported NIR atomic intrinsic");
+      UNREACHABLE("Unsupported NIR atomic intrinsic");
    }
 }
 
@@ -2500,7 +2500,7 @@ brw_type_for_base_type(enum glsl_base_type base_type)
    case GLSL_TYPE_INT64:     return BRW_TYPE_Q;
 
    default:
-      unreachable("invalid base type");
+      UNREACHABLE("invalid base type");
    }
 }
 
@@ -2537,7 +2537,7 @@ brw_type_for_nir_type(const struct intel_device_info *devinfo,
    case nir_type_uint8:
       return BRW_TYPE_UB;
    default:
-      unreachable("unknown type");
+      UNREACHABLE("unknown type");
    }
 
    return BRW_TYPE_F;
diff --git a/src/intel/compiler/brw_nir_lower_cooperative_matrix.c b/src/intel/compiler/brw_nir_lower_cooperative_matrix.c
index f37c87cbb288b..45b33d826191a 100644
--- a/src/intel/compiler/brw_nir_lower_cooperative_matrix.c
+++ b/src/intel/compiler/brw_nir_lower_cooperative_matrix.c
@@ -198,7 +198,7 @@ init_slice_info(struct lower_cmat_state *state,
       base_type = GLSL_TYPE_INT;
       break;
    default:
-      unreachable("Invalid cooperative matrix element type.");
+      UNREACHABLE("Invalid cooperative matrix element type.");
    }
 
    unsigned len = elements_per_invocation / packing_factor;
@@ -800,7 +800,7 @@ lower_cmat_instr(nir_builder *b, nir_instr *instr, void *_state)
    }
 
    default:
-      unreachable("invalid cooperative matrix intrinsic");
+      UNREACHABLE("invalid cooperative matrix intrinsic");
    }
 }
 
diff --git a/src/intel/compiler/brw_nir_lower_cs_intrinsics.c b/src/intel/compiler/brw_nir_lower_cs_intrinsics.c
index 2c889318a6c20..4fc1e43050cd2 100644
--- a/src/intel/compiler/brw_nir_lower_cs_intrinsics.c
+++ b/src/intel/compiler/brw_nir_lower_cs_intrinsics.c
@@ -220,7 +220,7 @@ compute_local_index_id(struct lower_intrinsics_state *state, nir_intrinsic_instr
       break;
    }
    default:
-      unreachable("invalid derivative group");
+      UNREACHABLE("invalid derivative group");
    }
 }
 
diff --git a/src/intel/compiler/brw_nir_lower_fs_barycentrics.c b/src/intel/compiler/brw_nir_lower_fs_barycentrics.c
index cb30de35fa289..8e42b9025ba23 100644
--- a/src/intel/compiler/brw_nir_lower_fs_barycentrics.c
+++ b/src/intel/compiler/brw_nir_lower_fs_barycentrics.c
@@ -80,7 +80,7 @@ get_bary_deltas(nir_builder *b, nir_intrinsic_instr *bary, nir_intrinsic_op op,
 
       break;
    default:
-      unreachable("invalid barycentric op");
+      UNREACHABLE("invalid barycentric op");
    }
 
    return deltas;
diff --git a/src/intel/compiler/brw_nir_lower_ray_queries.c b/src/intel/compiler/brw_nir_lower_ray_queries.c
index a45100d59b9d9..bb3a13fc2b510 100644
--- a/src/intel/compiler/brw_nir_lower_ray_queries.c
+++ b/src/intel/compiler/brw_nir_lower_ray_queries.c
@@ -144,7 +144,7 @@ get_ray_query_shadow_addr(nir_builder *b,
 
          base_addr = nir_iadd(b, base_addr, mul);
       } else {
-         unreachable("Unsupported deref type");
+         UNREACHABLE("Unsupported deref type");
       }
    }
 
@@ -498,7 +498,7 @@ lower_ray_query_intrinsic(nir_builder *b,
       }
 
       default:
-         unreachable("Invalid ray query");
+         UNREACHABLE("Invalid ray query");
       }
 
       assert(sysval);
@@ -507,7 +507,7 @@ lower_ray_query_intrinsic(nir_builder *b,
    }
 
    default:
-      unreachable("Invalid intrinsic");
+      UNREACHABLE("Invalid intrinsic");
    }
 }
 
diff --git a/src/intel/compiler/brw_nir_lower_shader_calls.c b/src/intel/compiler/brw_nir_lower_shader_calls.c
index 44a7f53fe9f56..7399f60e16af2 100644
--- a/src/intel/compiler/brw_nir_lower_shader_calls.c
+++ b/src/intel/compiler/brw_nir_lower_shader_calls.c
@@ -114,7 +114,7 @@ brw_nir_lower_shader_returns(nir_shader *shader)
 
       default:
         {
-         unreachable("Invalid callable shader stage");
+         UNREACHABLE("Invalid callable shader stage");
          return false;
         }
       }
diff --git a/src/intel/compiler/brw_nir_lower_storage_image.c b/src/intel/compiler/brw_nir_lower_storage_image.c
index 7ad248f767fbc..0dc53d5494132 100644
--- a/src/intel/compiler/brw_nir_lower_storage_image.c
+++ b/src/intel/compiler/brw_nir_lower_storage_image.c
@@ -135,7 +135,7 @@ convert_color_for_load(nir_builder *b, const struct intel_device_info *devinfo,
       break;
 
    default:
-      unreachable("Invalid image channel type");
+      UNREACHABLE("Invalid image channel type");
    }
 
 expand_vec:
@@ -346,7 +346,7 @@ convert_color_for_store(nir_builder *b, const struct intel_device_info *devinfo,
       break;
 
    default:
-      unreachable("Invalid image channel type");
+      UNREACHABLE("Invalid image channel type");
    }
 
    if (image.bits[0] < 32 &&
diff --git a/src/intel/compiler/brw_nir_lower_texel_address.c b/src/intel/compiler/brw_nir_lower_texel_address.c
index 17ec793399774..9aea3e2f61445 100644
--- a/src/intel/compiler/brw_nir_lower_texel_address.c
+++ b/src/intel/compiler/brw_nir_lower_texel_address.c
@@ -90,7 +90,7 @@ load_image_param(nir_builder *b, nir_def *surface_handle, unsigned index)
       num_components = 1;
       break;
    default:
-      unreachable("Invalid param offset");
+      UNREACHABLE("Invalid param offset");
    }
 
    return nir_image_deref_load_param_intel(b, num_components, bit_size,
diff --git a/src/intel/compiler/brw_opt_algebraic.cpp b/src/intel/compiler/brw_opt_algebraic.cpp
index 00d50ce3c3dbb..f4a50e6e63291 100644
--- a/src/intel/compiler/brw_opt_algebraic.cpp
+++ b/src/intel/compiler/brw_opt_algebraic.cpp
@@ -32,7 +32,7 @@ src_as_uint(const brw_reg &src)
       return src.u64;
 
    default:
-      unreachable("Invalid integer type.");
+      UNREACHABLE("Invalid integer type.");
    }
 }
 
@@ -52,7 +52,7 @@ src_as_float(const brw_reg &src)
       return src.df;
 
    default:
-      unreachable("Invalid float type.");
+      UNREACHABLE("Invalid float type.");
    }
 }
 
@@ -79,7 +79,7 @@ brw_imm_for_type(uint64_t value, enum brw_reg_type type)
       return brw_imm_uq(value);
 
    default:
-      unreachable("Invalid integer type.");
+      UNREACHABLE("Invalid integer type.");
    }
 }
 
@@ -120,11 +120,11 @@ fold_multiplicands_of_MAD(brw_inst *inst)
          break;
 
       case BRW_TYPE_DF:
-         unreachable("float64 should be impossible.");
+         UNREACHABLE("float64 should be impossible.");
          break;
 
       default:
-         unreachable("Invalid float type.");
+         UNREACHABLE("Invalid float type.");
       }
    }
 
@@ -269,7 +269,7 @@ brw_opt_constant_fold_instruction(const intel_device_info *devinfo, brw_inst *in
             break;
          default:
             /* Just in case a future platform re-enables B or UB types. */
-            unreachable("Invalid source size.");
+            UNREACHABLE("Invalid source size.");
          }
 
          result = retype(result, inst->dst.type);
@@ -426,7 +426,7 @@ brw_opt_algebraic(brw_shader &s)
             if (inst->dst.type != inst->src[0].type &&
                 inst->dst.type != BRW_TYPE_DF &&
                 inst->src[0].type != BRW_TYPE_F)
-               unreachable("unimplemented: saturate mixed types");
+               UNREACHABLE("unimplemented: saturate mixed types");
 
             if (brw_reg_saturate_immediate(&inst->src[0])) {
                inst->saturate = false;
@@ -670,7 +670,7 @@ brw_opt_algebraic(brw_shader &s)
                   progress = true;
                   break;
                default:
-                  unreachable("Impossible icsel condition.");
+                  UNREACHABLE("Impossible icsel condition.");
                }
             }
          }
diff --git a/src/intel/compiler/brw_opt_cmod_propagation.cpp b/src/intel/compiler/brw_opt_cmod_propagation.cpp
index ab92166216248..b2b02c0b8f4dd 100644
--- a/src/intel/compiler/brw_opt_cmod_propagation.cpp
+++ b/src/intel/compiler/brw_opt_cmod_propagation.cpp
@@ -65,7 +65,7 @@ src_as_float(const brw_reg &src)
       return src.df;
 
    default:
-      unreachable("Invalid float type.");
+      UNREACHABLE("Invalid float type.");
    }
 }
 
diff --git a/src/intel/compiler/brw_opt_combine_constants.cpp b/src/intel/compiler/brw_opt_combine_constants.cpp
index 67610f4d2a4b8..109e01d1f55e8 100644
--- a/src/intel/compiler/brw_opt_combine_constants.cpp
+++ b/src/intel/compiler/brw_opt_combine_constants.cpp
@@ -246,7 +246,7 @@ negation_exists(nir_const_value v, unsigned bit_size,
          return v.i64 != 0 && v.i64 != INT64_MIN;
 
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 }
 
@@ -286,7 +286,7 @@ negate(nir_const_value v, unsigned bit_size, enum interpreted_type base_type)
       break;
 
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 
    return ret;
@@ -334,7 +334,7 @@ absolute(nir_const_value v, unsigned bit_size, enum interpreted_type base_type)
       break;
 
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 
    return ret;
@@ -410,7 +410,7 @@ value_equal(nir_const_value a, nir_const_value b, unsigned bit_size)
    case 64:
       return a.u64 == b.u64;
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 }
 
@@ -933,7 +933,7 @@ build_imm_reg_for_copy(struct imm *imm)
    case 2:
       return brw_imm_w(imm->w);
    default:
-      unreachable("not implemented");
+      UNREACHABLE("not implemented");
    }
 }
 
@@ -1150,7 +1150,7 @@ add_candidate_immediate(struct table *table, brw_inst *inst, unsigned ip,
    case BRW_TYPE_UB:
    case BRW_TYPE_B:
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    /* It is safe to change the type of the operands of a select instruction
@@ -1212,7 +1212,7 @@ allocate_slots(brw_shader &s,
       }
    }
 
-   unreachable("No free slots found.");
+   UNREACHABLE("No free slots found.");
 }
 
 static void
@@ -1235,7 +1235,7 @@ deallocate_slots(const struct intel_device_info *devinfo,
       }
    }
 
-   unreachable("No such register found.");
+   UNREACHABLE("No such register found.");
 }
 
 static void
@@ -1595,7 +1595,7 @@ brw_opt_combine_constants(brw_shader &s)
                   reg->type = BRW_TYPE_DF;
                   break;
                default:
-                  unreachable("Bad type size");
+                  UNREACHABLE("Bad type size");
                }
             }
          } else if ((link->inst->opcode == BRW_OPCODE_SHL ||
diff --git a/src/intel/compiler/brw_print.cpp b/src/intel/compiler/brw_print.cpp
index 5c876c4497c9d..1875ca3272485 100644
--- a/src/intel/compiler/brw_print.cpp
+++ b/src/intel/compiler/brw_print.cpp
@@ -309,7 +309,7 @@ brw_instruction_name(const struct brw_isa_info *isa, enum opcode op)
       return "flow";
    }
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 /**
@@ -385,7 +385,7 @@ print_memory_logical_source(FILE *file, const brw_inst *inst, unsigned i)
       fprintf(file, " data1: ");
       return false;
    default:
-      unreachable("invalid source");
+      UNREACHABLE("invalid source");
    }
 }
 
@@ -480,7 +480,7 @@ brw_print_instruction(const brw_shader &s, const brw_inst *inst, FILE *file, con
       }
       break;
    case IMM:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    if (inst->dst.offset ||
@@ -648,7 +648,7 @@ brw_print_instruction(const brw_shader &s, const brw_inst *inst, FILE *file, con
          case BRW_SWAP_VERTICAL:   name = "vertical";   break;
          case BRW_SWAP_DIAGONAL:   name = "diagonal";   break;
          default:
-            unreachable("invalid brw_swap_direction");
+            UNREACHABLE("invalid brw_swap_direction");
          }
          fprintf(file, " (%s)", name);
       }
diff --git a/src/intel/compiler/brw_reg.cpp b/src/intel/compiler/brw_reg.cpp
index 23c27a352ab02..4cc9bceaaefc6 100644
--- a/src/intel/compiler/brw_reg.cpp
+++ b/src/intel/compiler/brw_reg.cpp
@@ -46,15 +46,15 @@ brw_reg_saturate_immediate(brw_reg *reg)
       break;
    case BRW_TYPE_UB:
    case BRW_TYPE_B:
-      unreachable("no UB/B immediates");
+      UNREACHABLE("no UB/B immediates");
    case BRW_TYPE_V:
    case BRW_TYPE_UV:
    case BRW_TYPE_VF:
-      unreachable("unimplemented: saturate vector immediate");
+      UNREACHABLE("unimplemented: saturate vector immediate");
    case BRW_TYPE_HF:
-      unreachable("unimplemented: saturate HF immediate");
+      UNREACHABLE("unimplemented: saturate HF immediate");
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
    }
 
    if (size < 8) {
@@ -100,15 +100,15 @@ brw_reg_negate_immediate(brw_reg *reg)
       return true;
    case BRW_TYPE_UB:
    case BRW_TYPE_B:
-      unreachable("no UB/B immediates");
+      UNREACHABLE("no UB/B immediates");
    case BRW_TYPE_UV:
    case BRW_TYPE_V:
-      unreachable("unimplemented: negate UV/V immediate");
+      UNREACHABLE("unimplemented: negate UV/V immediate");
    case BRW_TYPE_HF:
       reg->ud ^= 0x80008000;
       return true;
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
    }
 
    return false;
@@ -140,7 +140,7 @@ brw_reg_abs_immediate(brw_reg *reg)
       return true;
    case BRW_TYPE_UB:
    case BRW_TYPE_B:
-      unreachable("no UB/B immediates");
+      UNREACHABLE("no UB/B immediates");
    case BRW_TYPE_UQ:
    case BRW_TYPE_UD:
    case BRW_TYPE_UW:
@@ -148,14 +148,14 @@ brw_reg_abs_immediate(brw_reg *reg)
       /* Presumably the absolute value modifier on an unsigned source is a
        * nop, but it would be nice to confirm.
        */
-      unreachable("unimplemented: abs unsigned immediate");
+      UNREACHABLE("unimplemented: abs unsigned immediate");
    case BRW_TYPE_V:
-      unreachable("unimplemented: abs V immediate");
+      UNREACHABLE("unimplemented: abs V immediate");
    case BRW_TYPE_HF:
       reg->ud &= ~0x80008000;
       return true;
    default:
-      unreachable("invalid type");
+      UNREACHABLE("invalid type");
    }
 
    return false;
@@ -294,7 +294,7 @@ brw_reg::is_contiguous() const
       return true;
    }
 
-   unreachable("Invalid register file");
+   UNREACHABLE("Invalid register file");
 }
 
 unsigned
diff --git a/src/intel/compiler/brw_reg.h b/src/intel/compiler/brw_reg.h
index 9cf3275b8830e..c7e658b375636 100644
--- a/src/intel/compiler/brw_reg.h
+++ b/src/intel/compiler/brw_reg.h
@@ -256,7 +256,7 @@ phys_file(const struct brw_reg reg)
       return ARF;
 
    default:
-      unreachable("register type should have been lowered");
+      UNREACHABLE("register type should have been lowered");
    }
 }
 
@@ -339,7 +339,7 @@ brw_regs_negative_equal(const struct brw_reg *a, const struct brw_reg *b)
       case BRW_TYPE_UB:
       case BRW_TYPE_B:
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
    } else {
       struct brw_reg tmp = *a;
@@ -384,7 +384,7 @@ brw_int_type(unsigned sz, bool is_signed)
    case 8:
       return (is_signed ? BRW_TYPE_Q : BRW_TYPE_UQ);
    default:
-      unreachable("Not reached.");
+      UNREACHABLE("Not reached.");
    }
 }
 
@@ -557,7 +557,7 @@ brw_vecn_reg(unsigned width, enum brw_reg_file file,
    case 16:
       return brw_vec16_reg(file, nr, subnr);
    default:
-      unreachable("Invalid register width");
+      UNREACHABLE("Invalid register width");
    }
 }
 
@@ -1364,7 +1364,7 @@ horiz_offset(const brw_reg &reg, unsigned delta)
          }
       }
    }
-   unreachable("Invalid register file");
+   UNREACHABLE("Invalid register file");
 }
 
 static inline brw_reg
@@ -1566,7 +1566,7 @@ byte_stride(const brw_reg &reg)
          }
       }
    default:
-      unreachable("Invalid register file");
+      UNREACHABLE("Invalid register file");
    }
 }
 
diff --git a/src/intel/compiler/brw_reg_allocate.cpp b/src/intel/compiler/brw_reg_allocate.cpp
index 650e45f58df49..cc895ca1b7297 100644
--- a/src/intel/compiler/brw_reg_allocate.cpp
+++ b/src/intel/compiler/brw_reg_allocate.cpp
@@ -151,7 +151,7 @@ count_to_loop_end(const bblock_t *block, const brw_ip_ranges &ips)
             return ips.range(block).last();
       }
    }
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 void brw_shader::calculate_payload_ranges(bool allow_spilling,
diff --git a/src/intel/compiler/brw_schedule_instructions.cpp b/src/intel/compiler/brw_schedule_instructions.cpp
index 54523dde13ce6..6be3a9d98174d 100644
--- a/src/intel/compiler/brw_schedule_instructions.cpp
+++ b/src/intel/compiler/brw_schedule_instructions.cpp
@@ -382,7 +382,7 @@ schedule_node::set_latency(const struct brw_isa_info *isa)
             break;
 
          default:
-            unreachable("Unknown render cache message");
+            UNREACHABLE("Unknown render cache message");
          }
          break;
 
@@ -454,7 +454,7 @@ schedule_node::set_latency(const struct brw_isa_info *isa)
             break;
 
          default:
-            unreachable("Unknown data cache message");
+            UNREACHABLE("Unknown data cache message");
          }
          break;
 
@@ -488,7 +488,7 @@ schedule_node::set_latency(const struct brw_isa_info *isa)
             break;
 
          default:
-            unreachable("Unknown data cache message");
+            UNREACHABLE("Unknown data cache message");
          }
          break;
 
@@ -531,7 +531,7 @@ schedule_node::set_latency(const struct brw_isa_info *isa)
             latency = 1400;
             break;
          default:
-            unreachable("unsupported new data port message instruction");
+            UNREACHABLE("unsupported new data port message instruction");
          }
          break;
 
@@ -551,7 +551,7 @@ schedule_node::set_latency(const struct brw_isa_info *isa)
          break;
 
       default:
-         unreachable("Unknown SFID");
+         UNREACHABLE("Unknown SFID");
       }
       break;
 
diff --git a/src/intel/compiler/brw_shader.cpp b/src/intel/compiler/brw_shader.cpp
index ded1cef6157ef..3e729ae90dbba 100644
--- a/src/intel/compiler/brw_shader.cpp
+++ b/src/intel/compiler/brw_shader.cpp
@@ -60,7 +60,7 @@ brw_shader::emit_urb_writes(const brw_reg &gs_vertex_count)
       urb_handle = gs_payload().urb_handles;
       break;
    default:
-      unreachable("invalid stage");
+      UNREACHABLE("invalid stage");
    }
 
    const brw_builder bld = brw_builder(this);
@@ -189,7 +189,7 @@ brw_shader::emit_urb_writes(const brw_reg &gs_vertex_count)
          break;
       }
       case VARYING_SLOT_EDGE:
-         unreachable("unexpected scalar vs output");
+         UNREACHABLE("unexpected scalar vs output");
          break;
 
       default:
@@ -591,7 +591,7 @@ brw_barycentric_mode(const struct brw_wm_prog_key *key,
       bary = INTEL_BARYCENTRIC_PERSPECTIVE_SAMPLE;
       break;
    default:
-      unreachable("invalid intrinsic");
+      UNREACHABLE("invalid intrinsic");
    }
 
    if (mode == INTERP_MODE_NOPERSPECTIVE)
@@ -945,7 +945,7 @@ brw_fb_write_msg_control(const brw_inst *inst,
       else if (inst->group % 16 == 8)
          mctl = BRW_DATAPORT_RENDER_TARGET_WRITE_SIMD8_DUAL_SOURCE_SUBSPAN23;
       else
-         unreachable("Invalid dual-source FB write instruction group");
+         UNREACHABLE("Invalid dual-source FB write instruction group");
    } else {
       assert(inst->group == 0 || (inst->group == 16 && inst->exec_size == 16));
 
@@ -956,7 +956,7 @@ brw_fb_write_msg_control(const brw_inst *inst,
       else if (inst->exec_size == 32)
          mctl = XE2_DATAPORT_RENDER_TARGET_WRITE_SIMD32_SINGLE_SOURCE;
       else
-         unreachable("Invalid FB write execution size");
+         UNREACHABLE("Invalid FB write execution size");
    }
 
    return mctl;
diff --git a/src/intel/compiler/brw_simd_selection.cpp b/src/intel/compiler/brw_simd_selection.cpp
index a613189a9ed52..7498353a51aeb 100644
--- a/src/intel/compiler/brw_simd_selection.cpp
+++ b/src/intel/compiler/brw_simd_selection.cpp
@@ -170,7 +170,7 @@ brw_simd_should_compile(brw_simd_selection_state &state, unsigned simd)
       start = DEBUG_RT_SIMD8;
       break;
    default:
-      unreachable("unknown shader stage in brw_simd_should_compile");
+      UNREACHABLE("unknown shader stage in brw_simd_should_compile");
    }
 
    const bool env_skip[] = {
diff --git a/src/intel/compiler/brw_validate.cpp b/src/intel/compiler/brw_validate.cpp
index 20d48648b1d8e..9183032817e66 100644
--- a/src/intel/compiler/brw_validate.cpp
+++ b/src/intel/compiler/brw_validate.cpp
@@ -193,7 +193,7 @@ validate_memory_logical(const brw_shader &s, const brw_inst *inst)
       fsv_assert(!include_helpers);
       break;
    default:
-      unreachable("invalid opcode");
+      UNREACHABLE("invalid opcode");
    }
 }
 
@@ -210,7 +210,7 @@ brw_shader_phase_to_string(enum brw_shader_phase phase)
    case BRW_SHADER_PHASE_AFTER_REGALLOC:        return "AFTER_REGALLOC";
    case BRW_SHADER_PHASE_INVALID:               break;
    }
-   unreachable("invalid_phase");
+   UNREACHABLE("invalid_phase");
    return NULL;
 }
 
diff --git a/src/intel/compiler/elk/elk_clip_unfilled.c b/src/intel/compiler/elk/elk_clip_unfilled.c
index 0ef1122ccc177..f120af1c8063e 100644
--- a/src/intel/compiler/elk/elk_clip_unfilled.c
+++ b/src/intel/compiler/elk/elk_clip_unfilled.c
@@ -410,7 +410,7 @@ static void emit_primitives( struct elk_clip_compile *c,
       break;
 
    case ELK_CLIP_FILL_MODE_CULL:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_compile_clip.c b/src/intel/compiler/elk/elk_compile_clip.c
index 25db5f0b24e76..187c3363ef7a9 100644
--- a/src/intel/compiler/elk/elk_compile_clip.c
+++ b/src/intel/compiler/elk/elk_compile_clip.c
@@ -78,7 +78,7 @@ elk_compile_clip(const struct elk_compiler *compiler,
       elk_emit_point_clip( &c );
       break;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    elk_compact_instructions(&c.func, 0, NULL);
diff --git a/src/intel/compiler/elk/elk_compile_ff_gs.c b/src/intel/compiler/elk/elk_compile_ff_gs.c
index 6b0d778bff898..9d36e8d86c75c 100644
--- a/src/intel/compiler/elk/elk_compile_ff_gs.c
+++ b/src/intel/compiler/elk/elk_compile_ff_gs.c
@@ -621,7 +621,7 @@ elk_compile_ff_gs_prog(struct elk_compiler *compiler,
          check_edge_flag = true;
          break;
       default:
-         unreachable("Unexpected primitive type in Gen6 SOL program.");
+         UNREACHABLE("Unexpected primitive type in Gen6 SOL program.");
       }
       gfx6_sol_program(&c, key, num_verts, check_edge_flag);
    } else {
diff --git a/src/intel/compiler/elk/elk_compile_sf.c b/src/intel/compiler/elk/elk_compile_sf.c
index a41e2720465d1..e0d0514537920 100644
--- a/src/intel/compiler/elk/elk_compile_sf.c
+++ b/src/intel/compiler/elk/elk_compile_sf.c
@@ -858,7 +858,7 @@ elk_compile_sf(const struct elk_compiler *compiler,
       elk_emit_anyprim_setup( &c );
       break;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    /* FINISHME: SF programs use calculated jumps (i.e., JMPI with a register
diff --git a/src/intel/compiler/elk/elk_compiler.c b/src/intel/compiler/elk/elk_compiler.c
index b3c103e5b710a..7ba10a3b6c16d 100644
--- a/src/intel/compiler/elk/elk_compiler.c
+++ b/src/intel/compiler/elk/elk_compiler.c
@@ -236,7 +236,7 @@ elk_write_shader_relocs(const struct elk_isa_info *isa,
                elk_update_reloc_imm(isa, dst, value);
                break;
             default:
-               unreachable("Invalid relocation type");
+               UNREACHABLE("Invalid relocation type");
             }
             break;
          }
diff --git a/src/intel/compiler/elk/elk_compiler.h b/src/intel/compiler/elk/elk_compiler.h
index 0f8f658b1f769..fbe44a7b0dae9 100644
--- a/src/intel/compiler/elk/elk_compiler.h
+++ b/src/intel/compiler/elk/elk_compiler.h
@@ -940,7 +940,7 @@ elk_fs_simd_width_for_ksp(unsigned ksp_idx, bool simd8_enabled,
    case 2:
       return (simd16_enabled && (simd32_enabled || simd8_enabled)) ? 16 : 0;
    default:
-      unreachable("Invalid KSP index");
+      UNREACHABLE("Invalid KSP index");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_disasm.c b/src/intel/compiler/elk/elk_disasm.c
index df311726adf14..3030b0c4be8ae 100644
--- a/src/intel/compiler/elk/elk_disasm.c
+++ b/src/intel/compiler/elk/elk_disasm.c
@@ -976,7 +976,7 @@ vstride_from_align1_3src_vstride(const struct intel_device_info *devinfo,
    case ELK_ALIGN1_3SRC_VERTICAL_STRIDE_4: return ELK_VERTICAL_STRIDE_4;
    case ELK_ALIGN1_3SRC_VERTICAL_STRIDE_8: return ELK_VERTICAL_STRIDE_8;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -989,7 +989,7 @@ hstride_from_align1_3src_hstride(enum gfx10_align1_3src_src_horizontal_stride hs
    case ELK_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_2: return ELK_HORIZONTAL_STRIDE_2;
    case ELK_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_4: return ELK_HORIZONTAL_STRIDE_4;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1002,7 +1002,7 @@ vstride_from_align1_3src_hstride(enum gfx10_align1_3src_src_horizontal_stride hs
    case ELK_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_2: return ELK_VERTICAL_STRIDE_2;
    case ELK_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_4: return ELK_VERTICAL_STRIDE_4;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1027,7 +1027,7 @@ implied_width(enum elk_vertical_stride _vert_stride,
       case ELK_VERTICAL_STRIDE_8: return ELK_WIDTH_8;
       case ELK_VERTICAL_STRIDE_0:
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
    } else {
diff --git a/src/intel/compiler/elk/elk_eu.c b/src/intel/compiler/elk/elk_eu.c
index 39381f3200fa7..9bbd6d158139b 100644
--- a/src/intel/compiler/elk/elk_eu.c
+++ b/src/intel/compiler/elk/elk_eu.c
@@ -60,7 +60,7 @@ elk_negate_cmod(enum elk_conditional_mod cmod)
    case ELK_CONDITIONAL_LE:
       return ELK_CONDITIONAL_G;
    default:
-      unreachable("Can't negate this cmod");
+      UNREACHABLE("Can't negate this cmod");
    }
 }
 
@@ -198,7 +198,7 @@ elk_set_default_compression_control(struct elk_codegen *p,
       p->current->group = 0;
       break;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    if (p->devinfo->ver <= 6) {
@@ -826,6 +826,6 @@ elk_num_sources_from_inst(const struct elk_isa_info *isa,
    case ELK_MATH_FUNCTION_INT_DIV_REMAINDER:
       return 2;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
diff --git a/src/intel/compiler/elk/elk_eu.h b/src/intel/compiler/elk/elk_eu.h
index 15f868fd9de41..bebb1e1096eda 100644
--- a/src/intel/compiler/elk/elk_eu.h
+++ b/src/intel/compiler/elk/elk_eu.h
@@ -359,7 +359,7 @@ elk_urb_desc(const struct intel_device_info *devinfo,
               SET_BITS(global_offset, 13, 3) |
               SET_BITS(msg_type, 3, 0));
    } else {
-      unreachable("unhandled URB write generation");
+      UNREACHABLE("unhandled URB write generation");
    }
 }
 
@@ -723,7 +723,7 @@ elk_mdc_ds(unsigned bit_size)
    case 32:
       return GFX7_BYTE_SCATTERED_DATA_ELEMENT_DWORD;
    default:
-      unreachable("Unsupported bit_size for byte scattered messages");
+      UNREACHABLE("Unsupported bit_size for byte scattered messages");
    }
 }
 
@@ -858,7 +858,7 @@ elk_mdc_a64_ds(unsigned elems)
    case 4:  return 2;
    case 8:  return 3;
    default:
-      unreachable("Unsupported elmeent count for A64 scattered message");
+      UNREACHABLE("Unsupported elmeent count for A64 scattered message");
    }
 }
 
@@ -1233,16 +1233,16 @@ lsc_op_to_legacy_atomic(unsigned _op)
    /* No LSC op maps to ELK_AOP_PREDEC */
    case LSC_OP_ATOMIC_LOAD:
    case LSC_OP_ATOMIC_FSUB:
-      unreachable("no corresponding legacy atomic operation");
+      UNREACHABLE("no corresponding legacy atomic operation");
    case LSC_OP_LOAD:
    case LSC_OP_LOAD_CMASK:
    case LSC_OP_STORE:
    case LSC_OP_STORE_CMASK:
    case LSC_OP_FENCE:
-      unreachable("not an atomic op");
+      UNREACHABLE("not an atomic op");
    }
 
-   unreachable("invalid LSC op");
+   UNREACHABLE("invalid LSC op");
 }
 
 static inline uint32_t
@@ -1261,7 +1261,7 @@ lsc_data_size_bytes(enum lsc_data_size data_size)
    case LSC_DATA_SIZE_D64:
       return 8;
    default:
-      unreachable("Unsupported data payload size.");
+      UNREACHABLE("Unsupported data payload size.");
    }
 }
 
@@ -1273,7 +1273,7 @@ lsc_addr_size_bytes(enum lsc_addr_size addr_size)
    case LSC_ADDR_SIZE_A32: return 4;
    case LSC_ADDR_SIZE_A64: return 8;
    default:
-      unreachable("Unsupported address size.");
+      UNREACHABLE("Unsupported address size.");
    }
 }
 
@@ -1290,7 +1290,7 @@ lsc_vector_length(enum lsc_vect_size vect_size)
    case LSC_VECT_SIZE_V32: return 32;
    case LSC_VECT_SIZE_V64: return 64;
    default:
-      unreachable("Unsupported size of vector");
+      UNREACHABLE("Unsupported size of vector");
    }
 }
 
@@ -1307,7 +1307,7 @@ lsc_vect_size(unsigned vect_size)
    case 32: return LSC_VECT_SIZE_V32;
    case 64: return LSC_VECT_SIZE_V64;
    default:
-      unreachable("Unsupported vector size for dataport");
+      UNREACHABLE("Unsupported vector size for dataport");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_eu_compact.c b/src/intel/compiler/elk/elk_eu_compact.c
index 522a3f17eb030..0cab10b9f3bc3 100644
--- a/src/intel/compiler/elk/elk_eu_compact.c
+++ b/src/intel/compiler/elk/elk_eu_compact.c
@@ -1913,7 +1913,7 @@ compaction_state_init(struct compaction_state *c,
       c->src1_index_table = g45_src_index_table;
       break;
    default:
-      unreachable("unknown generation");
+      UNREACHABLE("unknown generation");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_eu_emit.c b/src/intel/compiler/elk/elk_eu_emit.c
index 652a539be29c4..76fa1ce8430a8 100644
--- a/src/intel/compiler/elk/elk_eu_emit.c
+++ b/src/intel/compiler/elk/elk_eu_emit.c
@@ -698,7 +698,7 @@ to_3src_align1_vstride(const struct intel_device_info *devinfo,
    case ELK_VERTICAL_STRIDE_16:
       return ELK_ALIGN1_3SRC_VERTICAL_STRIDE_8;
    default:
-      unreachable("invalid vstride");
+      UNREACHABLE("invalid vstride");
    }
 }
 
@@ -716,7 +716,7 @@ to_3src_align1_hstride(enum elk_horizontal_stride hstride)
    case ELK_HORIZONTAL_STRIDE_4:
       return ELK_ALIGN1_3SRC_SRC_HORIZONTAL_STRIDE_4;
    default:
-      unreachable("invalid hstride");
+      UNREACHABLE("invalid hstride");
    }
 }
 
@@ -975,7 +975,7 @@ elk_AVG(struct elk_codegen *p, struct elk_reg dest,
    case ELK_REGISTER_TYPE_UD:
       break;
    default:
-      unreachable("Bad type for elk_AVG");
+      UNREACHABLE("Bad type for elk_AVG");
    }
 
    return elk_alu2(p, ELK_OPCODE_AVG, dest, src0, src1);
@@ -2578,7 +2578,7 @@ elk_find_loop_end(struct elk_codegen *p, int start_offset)
 	    return offset;
       }
    }
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 /* After program generation, go back and update the UIP and JIP of
@@ -2851,7 +2851,7 @@ elk_set_memory_fence_message(struct elk_codegen *p,
       elk_inst_set_dp_msg_type(devinfo, insn, GFX7_DATAPORT_DC_MEMORY_FENCE);
       break;
    default:
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    if (commit_enable)
diff --git a/src/intel/compiler/elk/elk_eu_validate.c b/src/intel/compiler/elk/elk_eu_validate.c
index a4453f2ad6bf3..a3ebe44cd25e1 100644
--- a/src/intel/compiler/elk/elk_eu_validate.c
+++ b/src/intel/compiler/elk/elk_eu_validate.c
@@ -388,7 +388,7 @@ execution_type_for_type(enum elk_reg_type type)
    case ELK_REGISTER_TYPE_UV:
       return ELK_REGISTER_TYPE_W;
    }
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 /**
@@ -452,7 +452,7 @@ execution_type(const struct elk_isa_info *isa, const elk_inst *inst)
        src1_exec_type == ELK_REGISTER_TYPE_DF)
       return ELK_REGISTER_TYPE_DF;
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 /**
@@ -623,7 +623,7 @@ general_restrictions_based_on_operand_types(const struct elk_isa_info *isa,
          switch (s) {
          case 0: src_type = elk_inst_src0_type(devinfo, inst); break;
          case 1: src_type = elk_inst_src1_type(devinfo, inst); break;
-         default: unreachable("invalid src");
+         default: UNREACHABLE("invalid src");
          }
       }
 
diff --git a/src/intel/compiler/elk/elk_fs.cpp b/src/intel/compiler/elk/elk_fs.cpp
index 1ef4342e066ca..703fd63ed7e13 100644
--- a/src/intel/compiler/elk/elk_fs.cpp
+++ b/src/intel/compiler/elk/elk_fs.cpp
@@ -88,7 +88,7 @@ elk_fs_inst::init(enum elk_opcode opcode, uint8_t exec_size, const elk_fs_reg &d
       break;
    case IMM:
    case UNIFORM:
-      unreachable("Invalid destination register file");
+      UNREACHABLE("Invalid destination register file");
    }
 
    this->writes_accumulator = false;
@@ -529,7 +529,7 @@ elk_fs_reg::is_contiguous() const
       return true;
    }
 
-   unreachable("Invalid register file");
+   UNREACHABLE("Invalid register file");
 }
 
 unsigned
@@ -909,7 +909,7 @@ elk_fs_inst::size_read(int arg) const
    case ATTR:
       return components_read(arg) * src[arg].component_size(exec_size);
    case MRF:
-      unreachable("MRF registers are not allowed as sources");
+      UNREACHABLE("MRF registers are not allowed as sources");
    }
    return 0;
 }
@@ -931,7 +931,7 @@ namespace {
       case ELK_PREDICATE_ALIGN1_ALL16H:   return 16;
       case ELK_PREDICATE_ALIGN1_ANY32H:   return 32;
       case ELK_PREDICATE_ALIGN1_ALL32H:   return 32;
-      default: unreachable("Unsupported predicate");
+      default: UNREACHABLE("Unsupported predicate");
       }
    }
 
@@ -1063,7 +1063,7 @@ elk_fs_inst::implied_mrf_writes() const
    case ELK_SHADER_OPCODE_GFX4_SCRATCH_WRITE:
       return mlen;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1149,7 +1149,7 @@ elk_barycentric_mode(nir_intrinsic_instr *intr)
       bary = ELK_BARYCENTRIC_PERSPECTIVE_SAMPLE;
       break;
    default:
-      unreachable("invalid intrinsic");
+      UNREACHABLE("invalid intrinsic");
    }
 
    if (mode == INTERP_MODE_NOPERSPECTIVE)
@@ -2126,7 +2126,7 @@ src_as_uint(const elk_fs_reg &src)
       return src.u64;
 
    default:
-      unreachable("Invalid integer type.");
+      UNREACHABLE("Invalid integer type.");
    }
 }
 
@@ -2153,7 +2153,7 @@ elk_imm_for_type(uint64_t value, enum elk_reg_type type)
       return elk_imm_uq(value);
 
    default:
-      unreachable("Invalid integer type.");
+      UNREACHABLE("Invalid integer type.");
    }
 }
 
@@ -2230,7 +2230,7 @@ elk_fs_visitor::opt_algebraic()
             if (inst->dst.type != inst->src[0].type &&
                 inst->dst.type != ELK_REGISTER_TYPE_DF &&
                 inst->src[0].type != ELK_REGISTER_TYPE_F)
-               unreachable("unimplemented: saturate mixed types");
+               UNREACHABLE("unimplemented: saturate mixed types");
 
             if (elk_saturate_immediate(inst->src[0].type,
                                        &inst->src[0].as_elk_reg())) {
@@ -2487,7 +2487,7 @@ elk_fs_visitor::opt_algebraic()
                break;
             default:
                /* Just in case a future platform re-enables B or UB types. */
-               unreachable("Invalid source size.");
+               UNREACHABLE("Invalid source size.");
             }
 
             inst->opcode = ELK_OPCODE_MOV;
@@ -4172,7 +4172,7 @@ elk_fb_write_msg_control(const elk_fs_inst *inst,
       else if (inst->group % 16 == 8)
          mctl = ELK_DATAPORT_RENDER_TARGET_WRITE_SIMD8_DUAL_SOURCE_SUBSPAN23;
       else
-         unreachable("Invalid dual-source FB write instruction group");
+         UNREACHABLE("Invalid dual-source FB write instruction group");
    } else {
       assert(inst->group == 0 || (inst->group == 16 && inst->exec_size == 16));
 
@@ -4181,7 +4181,7 @@ elk_fb_write_msg_control(const elk_fs_inst *inst,
       else if (inst->exec_size == 8)
          mctl = ELK_DATAPORT_RENDER_TARGET_WRITE_SIMD8_SINGLE_SOURCE_SUBSPAN01;
       else
-         unreachable("Invalid FB write execution size");
+         UNREACHABLE("Invalid FB write execution size");
    }
 
    return mctl;
@@ -5427,7 +5427,7 @@ elk_fs_visitor::dump_instruction_to_file(const elk_backend_instruction *be_inst,
       }
       break;
    case IMM:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    if (inst->dst.offset ||
diff --git a/src/intel/compiler/elk/elk_fs_builder.h b/src/intel/compiler/elk/elk_fs_builder.h
index 67a0f3406d274..2a5f078be7ee2 100644
--- a/src/intel/compiler/elk/elk_fs_builder.h
+++ b/src/intel/compiler/elk/elk_fs_builder.h
@@ -499,7 +499,7 @@ namespace elk {
             }
 
             default:
-               unreachable("Unsupported 64-bit scan op");
+               UNREACHABLE("Unsupported 64-bit scan op");
             }
          } else {
             set_condmod(mod, emit(opcode, right, left, right));
diff --git a/src/intel/compiler/elk/elk_fs_combine_constants.cpp b/src/intel/compiler/elk/elk_fs_combine_constants.cpp
index 82018b85b00a5..f1f8379d28cc6 100644
--- a/src/intel/compiler/elk/elk_fs_combine_constants.cpp
+++ b/src/intel/compiler/elk/elk_fs_combine_constants.cpp
@@ -260,7 +260,7 @@ negation_exists(nir_const_value v, unsigned bit_size,
          return v.i64 != 0 && v.i64 != INT64_MIN;
 
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 }
 
@@ -300,7 +300,7 @@ negate(nir_const_value v, unsigned bit_size, enum interpreted_type base_type)
       break;
 
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 
    return ret;
@@ -348,7 +348,7 @@ absolute(nir_const_value v, unsigned bit_size, enum interpreted_type base_type)
       break;
 
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 
    return ret;
@@ -424,7 +424,7 @@ value_equal(nir_const_value a, nir_const_value b, unsigned bit_size)
    case 64:
       return a.u64 == b.u64;
    default:
-      unreachable("unsupported bit-size should have already been filtered.");
+      UNREACHABLE("unsupported bit-size should have already been filtered.");
    }
 }
 
@@ -984,7 +984,7 @@ build_imm_reg_for_copy(struct imm *imm)
    case 2:
       return elk_imm_w(imm->w);
    default:
-      unreachable("not implemented");
+      UNREACHABLE("not implemented");
    }
 }
 
@@ -1049,7 +1049,7 @@ add_candidate_immediate(struct table *table, elk_fs_inst *inst, unsigned ip,
    case ELK_REGISTER_TYPE_UB:
    case ELK_REGISTER_TYPE_B:
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    /* It is safe to change the type of the operands of a select instruction
@@ -1108,7 +1108,7 @@ allocate_slots(struct register_allocation *regs, unsigned num_regs,
       }
    }
 
-   unreachable("No free slots found.");
+   UNREACHABLE("No free slots found.");
 }
 
 static void
@@ -1130,7 +1130,7 @@ deallocate_slots(struct register_allocation *regs, unsigned num_regs,
       }
    }
 
-   unreachable("No such register found.");
+   UNREACHABLE("No such register found.");
 }
 
 static void
@@ -1590,7 +1590,7 @@ elk_fs_visitor::opt_combine_constants()
                   reg->type = ELK_REGISTER_TYPE_DF;
                   break;
                default:
-                  unreachable("Bad type size");
+                  UNREACHABLE("Bad type size");
                }
             }
          } else if ((link->inst->opcode == ELK_OPCODE_SHL ||
diff --git a/src/intel/compiler/elk/elk_fs_generator.cpp b/src/intel/compiler/elk/elk_fs_generator.cpp
index 371b12f602f73..272650bdc3076 100644
--- a/src/intel/compiler/elk/elk_fs_generator.cpp
+++ b/src/intel/compiler/elk/elk_fs_generator.cpp
@@ -51,7 +51,7 @@ elk_file_from_reg(elk_fs_reg *reg)
    case BAD_FILE:
    case ATTR:
    case UNIFORM:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
    return ELK_ARCHITECTURE_REGISTER_FILE;
 }
@@ -167,7 +167,7 @@ elk_reg_from_fs_reg(const struct intel_device_info *devinfo, elk_fs_inst *inst,
       break;
    case ATTR:
    case UNIFORM:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    /* On HSW+, scalar DF sources can be accessed using the normal <0,1,0>
@@ -944,7 +944,7 @@ elk_fs_generator::generate_tex(elk_fs_inst *inst, struct elk_reg dst,
       simd_mode = ELK_SAMPLER_SIMD_MODE_SIMD16;
       break;
    default:
-      unreachable("Invalid width for texture instruction");
+      UNREACHABLE("Invalid width for texture instruction");
    }
 
    if (devinfo->ver >= 5) {
@@ -995,7 +995,7 @@ elk_fs_generator::generate_tex(elk_fs_inst *inst, struct elk_reg dst,
          msg_type = GFX6_SAMPLER_MESSAGE_SAMPLE_SAMPLEINFO;
          break;
       default:
-	 unreachable("not reached");
+	 UNREACHABLE("not reached");
       }
    } else {
       switch (inst->opcode) {
@@ -1059,7 +1059,7 @@ elk_fs_generator::generate_tex(elk_fs_inst *inst, struct elk_reg dst,
 	 simd_mode = ELK_SAMPLER_SIMD_MODE_SIMD16;
 	 break;
       default:
-	 unreachable("not reached");
+	 UNREACHABLE("not reached");
       }
    }
    assert(msg_type != -1);
@@ -2154,10 +2154,10 @@ elk_fs_generator::generate_code(const elk_cfg_t *cfg, int dispatch_width,
          break;
 
       default:
-         unreachable("Unsupported opcode");
+         UNREACHABLE("Unsupported opcode");
 
       case ELK_SHADER_OPCODE_LOAD_PAYLOAD:
-         unreachable("Should be lowered by lower_load_payload()");
+         UNREACHABLE("Should be lowered by lower_load_payload()");
       }
 
       if (multiple_instructions_emitted)
diff --git a/src/intel/compiler/elk/elk_fs_lower_pack.cpp b/src/intel/compiler/elk/elk_fs_lower_pack.cpp
index 45b87bc3f38ef..480aa89ec582d 100644
--- a/src/intel/compiler/elk/elk_fs_lower_pack.cpp
+++ b/src/intel/compiler/elk/elk_fs_lower_pack.cpp
@@ -78,7 +78,7 @@ elk_fs_visitor::lower_pack()
          }
          break;
       default:
-         unreachable("skipped above");
+         UNREACHABLE("skipped above");
       }
 
       inst->remove(block);
diff --git a/src/intel/compiler/elk/elk_fs_lower_regioning.cpp b/src/intel/compiler/elk/elk_fs_lower_regioning.cpp
index 1a398f29c8b16..2f2bf05689ef2 100644
--- a/src/intel/compiler/elk/elk_fs_lower_regioning.cpp
+++ b/src/intel/compiler/elk/elk_fs_lower_regioning.cpp
@@ -229,7 +229,7 @@ namespace {
             }
          }
       default:
-         unreachable("Invalid register file");
+         UNREACHABLE("Invalid register file");
       }
    }
 
@@ -318,7 +318,7 @@ namespace {
             return 0x3;
 
          default:
-            unreachable("Unknown invalid execution type source mask.");
+            UNREACHABLE("Unknown invalid execution type source mask.");
          }
       } else {
          return 0;
diff --git a/src/intel/compiler/elk/elk_fs_nir.cpp b/src/intel/compiler/elk/elk_fs_nir.cpp
index c800adb0ef0ce..e456cd1778753 100644
--- a/src/intel/compiler/elk/elk_fs_nir.cpp
+++ b/src/intel/compiler/elk/elk_fs_nir.cpp
@@ -192,18 +192,18 @@ emit_system_values_block(nir_to_elk_state &ntb, nir_block *block)
       switch (intrin->intrinsic) {
       case nir_intrinsic_load_vertex_id:
       case nir_intrinsic_load_base_vertex:
-         unreachable("should be lowered by nir_lower_system_values().");
+         UNREACHABLE("should be lowered by nir_lower_system_values().");
 
       case nir_intrinsic_load_vertex_id_zero_base:
       case nir_intrinsic_load_is_indexed_draw:
       case nir_intrinsic_load_first_vertex:
       case nir_intrinsic_load_instance_id:
       case nir_intrinsic_load_base_instance:
-         unreachable("should be lowered by elk_nir_lower_vs_inputs().");
+         UNREACHABLE("should be lowered by elk_nir_lower_vs_inputs().");
          break;
 
       case nir_intrinsic_load_draw_id:
-         unreachable("should be lowered by elk_nir_lower_vs_inputs().");
+         UNREACHABLE("should be lowered by elk_nir_lower_vs_inputs().");
          break;
 
       case nir_intrinsic_load_invocation_id:
@@ -378,7 +378,7 @@ fs_nir_emit_cf_list(nir_to_elk_state &ntb, exec_list *list)
          break;
 
       default:
-         unreachable("Invalid CFG node block");
+         UNREACHABLE("Invalid CFG node block");
       }
    }
 }
@@ -622,7 +622,7 @@ elk_rnd_mode_from_nir_op (const nir_op op) {
    case nir_op_f2f16_rtne:
       return ELK_RND_MODE_RTNE;
    default:
-      unreachable("Operation doesn't support rounding mode");
+      UNREACHABLE("Operation doesn't support rounding mode");
    }
 }
 
@@ -862,7 +862,7 @@ emit_fsign(nir_to_elk_state &ntb, const fs_builder &bld, const nir_alu_instr *in
 
       inst->predicate = ELK_PREDICATE_NORMAL;
    } else {
-      unreachable("Should have been lowered by nir_opt_algebraic.");
+      UNREACHABLE("Should have been lowered by nir_opt_algebraic.");
    }
 }
 
@@ -1299,10 +1299,10 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
       break;
 
    case nir_op_uadd_carry:
-      unreachable("Should have been lowered by carry_to_arith().");
+      UNREACHABLE("Should have been lowered by carry_to_arith().");
 
    case nir_op_usub_borrow:
-      unreachable("Should have been lowered by borrow_to_arith().");
+      UNREACHABLE("Should have been lowered by borrow_to_arith().");
 
    case nir_op_umod:
    case nir_op_irem:
@@ -1457,7 +1457,7 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
                return;
 
             default:
-               unreachable("impossible opcode");
+               UNREACHABLE("impossible opcode");
             }
          }
          op[0] = resolve_source_modifiers(bld, op[0]);
@@ -1498,10 +1498,10 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
    case nir_op_b32any_inequal3:
    case nir_op_b32any_fnequal4:
    case nir_op_b32any_inequal4:
-      unreachable("Lowered by nir_lower_alu_reductions");
+      UNREACHABLE("Lowered by nir_lower_alu_reductions");
 
    case nir_op_ldexp:
-      unreachable("not reached: should be handled by ldexp_to_arith()");
+      UNREACHABLE("not reached: should be handled by ldexp_to_arith()");
 
    case nir_op_fsqrt:
       inst = bld.emit(ELK_SHADER_OPCODE_SQRT, result, op[0]);
@@ -1567,7 +1567,7 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
    case nir_op_unpack_unorm_4x8:
    case nir_op_unpack_half_2x16:
    case nir_op_pack_half_2x16:
-      unreachable("not reached: should be handled by lower_packing_builtins");
+      UNREACHABLE("not reached: should be handled by lower_packing_builtins");
 
    case nir_op_unpack_half_2x16_split_x:
       inst = bld.F16TO32(result, subscript(op[0], ELK_REGISTER_TYPE_HF, 0));
@@ -1655,7 +1655,7 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
 
    case nir_op_ubitfield_extract:
    case nir_op_ibitfield_extract:
-      unreachable("should have been lowered");
+      UNREACHABLE("should have been lowered");
    case nir_op_ubfe:
    case nir_op_ibfe:
       assert(instr->def.bit_size < 64);
@@ -1680,7 +1680,7 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
       break;
 
    case nir_op_bitfield_insert:
-      unreachable("not reached: should have been lowered");
+      UNREACHABLE("not reached: should have been lowered");
 
    /* With regards to implicit masking of the shift counts for 8- and 16-bit
     * types, the PRMs are **incorrect**. They falsely state that on Gen9+ only
@@ -1802,7 +1802,7 @@ fs_nir_emit_alu(nir_to_elk_state &ntb, nir_alu_instr *instr,
    }
 
    default:
-      unreachable("unhandled instruction");
+      UNREACHABLE("unhandled instruction");
    }
 
    /* If we need to do a boolean resolve, replace the result with -(x & 1)
@@ -1859,7 +1859,7 @@ fs_nir_emit_load_const(nir_to_elk_state &ntb,
       break;
 
    default:
-      unreachable("Invalid bit size");
+      UNREACHABLE("Invalid bit size");
    }
 
    ntb.ssa_values[instr->def.index] = reg;
@@ -2526,7 +2526,7 @@ fs_nir_emit_vs_intrinsic(nir_to_elk_state &ntb,
    switch (instr->intrinsic) {
    case nir_intrinsic_load_vertex_id:
    case nir_intrinsic_load_base_vertex:
-      unreachable("should be lowered by nir_lower_system_values()");
+      UNREACHABLE("should be lowered by nir_lower_system_values()");
 
    case nir_intrinsic_load_input: {
       assert(instr->def.bit_size == 32);
@@ -2546,7 +2546,7 @@ fs_nir_emit_vs_intrinsic(nir_to_elk_state &ntb,
    case nir_intrinsic_load_draw_id:
    case nir_intrinsic_load_first_vertex:
    case nir_intrinsic_load_is_indexed_draw:
-      unreachable("lowered by elk_nir_lower_vs_inputs");
+      UNREACHABLE("lowered by elk_nir_lower_vs_inputs");
 
    default:
       fs_nir_emit_intrinsic(ntb, bld, instr);
@@ -2678,7 +2678,7 @@ emit_barrier(nir_to_elk_state &ntb)
    case 8:
       barrier_id_mask = 0x0f000000u; break;
    default:
-      unreachable("barrier is only available on gen >= 7");
+      UNREACHABLE("barrier is only available on gen >= 7");
    }
 
    /* Copy the barrier id from r0.2 to the message payload reg.2 */
@@ -2757,7 +2757,7 @@ fs_nir_emit_tcs_intrinsic(nir_to_elk_state &ntb,
       break;
 
    case nir_intrinsic_load_input:
-      unreachable("nir_lower_io should never give us these.");
+      UNREACHABLE("nir_lower_io should never give us these.");
       break;
 
    case nir_intrinsic_load_per_vertex_input: {
@@ -3084,7 +3084,7 @@ fs_nir_emit_gs_intrinsic(nir_to_elk_state &ntb,
       break;
 
    case nir_intrinsic_load_input:
-      unreachable("load_input intrinsics are invalid for the GS stage");
+      UNREACHABLE("load_input intrinsics are invalid for the GS stage");
 
    case nir_intrinsic_load_per_vertex_input:
       emit_gs_input_load(ntb, dest, instr->src[0], nir_intrinsic_base(instr),
@@ -3285,7 +3285,7 @@ alloc_frag_output(nir_to_elk_state &ntb, unsigned location)
                              &s.outputs[l - FRAG_RESULT_DATA0], 1);
 
    else
-      unreachable("Invalid location");
+      UNREACHABLE("Invalid location");
 }
 
 static void
@@ -3908,7 +3908,7 @@ fs_nir_emit_fs_intrinsic(nir_to_elk_state &ntb,
    }
 
    case nir_intrinsic_load_frag_coord:
-      unreachable("should be lowered by elk_nir_lower_frag_coord");
+      UNREACHABLE("should be lowered by elk_nir_lower_frag_coord");
 
    case nir_intrinsic_load_pixel_coord:
       /* gl_FragCoord.xy: Just load the pixel xy from the payload, or more
@@ -4137,7 +4137,7 @@ fs_nir_emit_cs_intrinsic(nir_to_elk_state &ntb,
       /* Should have been lowered by elk_nir_lower_cs_intrinsics() or
        * crocus/iris_setup_uniforms() for the variable group size case.
        */
-      unreachable("Should have been lowered");
+      UNREACHABLE("Should have been lowered");
       break;
    }
 
@@ -4170,7 +4170,7 @@ elk_nir_reduction_op_identity(const fs_builder &bld,
       else
          return retype(elk_imm_u64(value.u64), type);
    default:
-      unreachable("Invalid type size");
+      UNREACHABLE("Invalid type size");
    }
 }
 
@@ -4192,7 +4192,7 @@ elk_op_for_nir_reduction_op(nir_op op)
    case nir_op_ior:  return ELK_OPCODE_OR;
    case nir_op_ixor: return ELK_OPCODE_XOR;
    default:
-      unreachable("Invalid reduction operation");
+      UNREACHABLE("Invalid reduction operation");
    }
 }
 
@@ -4214,7 +4214,7 @@ elk_cond_mod_for_nir_reduction_op(nir_op op)
    case nir_op_ior:  return ELK_CONDITIONAL_NONE;
    case nir_op_ixor: return ELK_CONDITIONAL_NONE;
    default:
-      unreachable("Invalid reduction operation");
+      UNREACHABLE("Invalid reduction operation");
    }
 }
 
@@ -4814,7 +4814,7 @@ fs_nir_emit_intrinsic(nir_to_elk_state &ntb,
          break;
 
       default:
-         unreachable("invalid intrinsic");
+         UNREACHABLE("invalid intrinsic");
       }
 
       if (opcode == ELK_OPCODE_NOP)
@@ -5618,7 +5618,7 @@ fs_nir_emit_intrinsic(nir_to_elk_state &ntb,
    case nir_intrinsic_load_subgroup_gt_mask:
    case nir_intrinsic_load_subgroup_le_mask:
    case nir_intrinsic_load_subgroup_lt_mask:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
 
    case nir_intrinsic_vote_any: {
       const fs_builder ubld1 = bld.exec_all().group(1, 0);
@@ -6161,7 +6161,7 @@ fs_nir_emit_intrinsic(nir_to_elk_state &ntb,
       assert(instr->intrinsic < nir_num_intrinsics);
       fprintf(stderr, "intrinsic: %s\n", nir_intrinsic_infos[instr->intrinsic].name);
 #endif
-      unreachable("unknown intrinsic");
+      UNREACHABLE("unknown intrinsic");
    }
 }
 
@@ -6264,7 +6264,7 @@ fs_nir_emit_surface_atomic(nir_to_elk_state &ntb, const fs_builder &bld,
                   dest, srcs, SURFACE_LOGICAL_NUM_SRCS);
          break;
       default:
-         unreachable("Unsupported bit size");
+         UNREACHABLE("Unsupported bit size");
    }
 }
 
@@ -6314,7 +6314,7 @@ fs_nir_emit_global_atomic(nir_to_elk_state &ntb, const fs_builder &bld,
                srcs, A64_LOGICAL_NUM_SRCS);
       break;
    default:
-      unreachable("Unsupported bit size");
+      UNREACHABLE("Unsupported bit size");
    }
 }
 
@@ -6423,7 +6423,7 @@ fs_nir_emit_texture(nir_to_elk_state &ntb,
       }
 
       case nir_tex_src_projector:
-         unreachable("should be lowered");
+         UNREACHABLE("should be lowered");
 
       case nir_tex_src_texture_offset: {
          assert(srcs[TEX_LOGICAL_SRC_SURFACE].file == BAD_FILE);
@@ -6488,7 +6488,7 @@ fs_nir_emit_texture(nir_to_elk_state &ntb,
          break;
 
       default:
-         unreachable("unknown texture source");
+         UNREACHABLE("unknown texture source");
       }
    }
 
@@ -6573,7 +6573,7 @@ fs_nir_emit_texture(nir_to_elk_state &ntb,
       return;
    }
    default:
-      unreachable("unknown texture opcode");
+      UNREACHABLE("unknown texture opcode");
    }
 
    if (instr->op == nir_texop_tg4) {
@@ -6662,7 +6662,7 @@ fs_nir_emit_jump(nir_to_elk_state &ntb, nir_jump_instr *instr)
       break;
    case nir_jump_return:
    default:
-      unreachable("unknown jump");
+      UNREACHABLE("unknown jump");
    }
 }
 
@@ -6863,7 +6863,7 @@ fs_nir_emit_instr(nir_to_elk_state &ntb, nir_instr *instr)
       break;
 
    case nir_instr_type_deref:
-      unreachable("All derefs should've been lowered");
+      UNREACHABLE("All derefs should've been lowered");
       break;
 
    case nir_instr_type_intrinsic:
@@ -6887,7 +6887,7 @@ fs_nir_emit_instr(nir_to_elk_state &ntb, nir_instr *instr)
          fs_nir_emit_cs_intrinsic(ntb, nir_instr_as_intrinsic(instr));
          break;
       default:
-         unreachable("unsupported shader stage");
+         UNREACHABLE("unsupported shader stage");
       }
       break;
 
@@ -6911,7 +6911,7 @@ fs_nir_emit_instr(nir_to_elk_state &ntb, nir_instr *instr)
       break;
 
    default:
-      unreachable("unknown instruction type");
+      UNREACHABLE("unknown instruction type");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_fs_reg_allocate.cpp b/src/intel/compiler/elk/elk_fs_reg_allocate.cpp
index f0738b6398d42..4d1cd43d2572a 100644
--- a/src/intel/compiler/elk/elk_fs_reg_allocate.cpp
+++ b/src/intel/compiler/elk/elk_fs_reg_allocate.cpp
@@ -205,7 +205,7 @@ count_to_loop_end(const elk_bblock_t *block)
             return block->end_ip;
       }
    }
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 void elk_fs_visitor::calculate_payload_ranges(unsigned payload_node_count,
diff --git a/src/intel/compiler/elk/elk_fs_visitor.cpp b/src/intel/compiler/elk/elk_fs_visitor.cpp
index c7378d45625d1..95edabc32b786 100644
--- a/src/intel/compiler/elk/elk_fs_visitor.cpp
+++ b/src/intel/compiler/elk/elk_fs_visitor.cpp
@@ -375,7 +375,7 @@ cond_for_alpha_func(enum compare_func func)
    case COMPARE_FUNC_NOTEQUAL:
       return ELK_CONDITIONAL_NEQ;
    default:
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 }
 
@@ -557,7 +557,7 @@ elk_fs_visitor::emit_urb_writes(const elk_fs_reg &gs_vertex_count)
       urb_handle = gs_payload().urb_handles;
       break;
    default:
-      unreachable("invalid stage");
+      UNREACHABLE("invalid stage");
    }
 
    const fs_builder bld = fs_builder(this).at_end();
@@ -680,7 +680,7 @@ elk_fs_visitor::emit_urb_writes(const elk_fs_reg &gs_vertex_count)
       }
       case ELK_VARYING_SLOT_NDC:
       case VARYING_SLOT_EDGE:
-         unreachable("unexpected scalar vs output");
+         UNREACHABLE("unexpected scalar vs output");
          break;
 
       default:
diff --git a/src/intel/compiler/elk/elk_gfx6_gs_visitor.cpp b/src/intel/compiler/elk/elk_gfx6_gs_visitor.cpp
index ba74c2045b8b6..869feb1f015b7 100644
--- a/src/intel/compiler/elk/elk_gfx6_gs_visitor.cpp
+++ b/src/intel/compiler/elk/elk_gfx6_gs_visitor.cpp
@@ -546,7 +546,7 @@ gfx6_gs_visitor::xfb_write()
       num_verts = 3;
       break;
    default:
-      unreachable("Unexpected primitive type in Gfx6 SOL program.");
+      UNREACHABLE("Unexpected primitive type in Gfx6 SOL program.");
    }
 
    this->current_annotation = "gfx6 thread end: svb writes init";
diff --git a/src/intel/compiler/elk/elk_ir_fs.h b/src/intel/compiler/elk/elk_ir_fs.h
index dd71b9e4ea9b1..422610e4d7344 100644
--- a/src/intel/compiler/elk/elk_ir_fs.h
+++ b/src/intel/compiler/elk/elk_ir_fs.h
@@ -132,7 +132,7 @@ horiz_offset(const elk_fs_reg &reg, unsigned delta)
          }
       }
    }
-   unreachable("Invalid register file");
+   UNREACHABLE("Invalid register file");
 }
 
 static inline elk_fs_reg
diff --git a/src/intel/compiler/elk/elk_lower_logical_sends.cpp b/src/intel/compiler/elk/elk_lower_logical_sends.cpp
index 99f267332374c..bd8b8ba739c83 100644
--- a/src/intel/compiler/elk/elk_lower_logical_sends.cpp
+++ b/src/intel/compiler/elk/elk_lower_logical_sends.cpp
@@ -640,7 +640,7 @@ sampler_msg_type(const intel_device_info *devinfo,
       assert(!has_min_lod);
       return GFX6_SAMPLER_MESSAGE_SAMPLE_SAMPLEINFO;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -1311,7 +1311,7 @@ lower_surface_logical_send(const fs_builder &bld, elk_fs_inst *inst)
       break;
 
    default:
-      unreachable("Unsupported surface opcode");
+      UNREACHABLE("Unsupported surface opcode");
    }
 
    uint32_t desc;
@@ -1378,7 +1378,7 @@ lower_surface_logical_send(const fs_builder &bld, elk_fs_inst *inst)
       break;
 
    default:
-      unreachable("Unknown surface logical instruction");
+      UNREACHABLE("Unknown surface logical instruction");
    }
 
    /* Update the original instruction. */
@@ -1503,7 +1503,7 @@ lower_a64_logical_send(const fs_builder &bld, elk_fs_inst *inst)
       break;
 
    default:
-      unreachable("Unknown A64 logical instruction");
+      UNREACHABLE("Unknown A64 logical instruction");
    }
 
    if (bld.shader->stage == MESA_SHADER_FRAGMENT)
@@ -1683,7 +1683,7 @@ lower_interpolator_logical_send(const fs_builder &bld, elk_fs_inst *inst,
       break;
 
    default:
-      unreachable("Invalid interpolator instruction");
+      UNREACHABLE("Invalid interpolator instruction");
    }
 
    const bool dynamic_mode =
diff --git a/src/intel/compiler/elk/elk_nir.c b/src/intel/compiler/elk/elk_nir.c
index 880e49cf9e23f..d6c6405701642 100644
--- a/src/intel/compiler/elk/elk_nir.c
+++ b/src/intel/compiler/elk/elk_nir.c
@@ -88,7 +88,7 @@ remap_tess_levels(nir_builder *b, nir_intrinsic_instr *intr,
          out_of_bounds = true;
          break;
       default:
-         unreachable("Bogus tessellation domain");
+         UNREACHABLE("Bogus tessellation domain");
       }
    } else if (location == VARYING_SLOT_TESS_LEVEL_OUTER) {
       b->cursor = write ? nir_before_instr(&intr->instr)
@@ -140,7 +140,7 @@ remap_tess_levels(nir_builder *b, nir_intrinsic_instr *intr,
          }
          break;
       default:
-         unreachable("Bogus tessellation domain");
+         UNREACHABLE("Bogus tessellation domain");
       }
    } else {
       return false;
@@ -324,7 +324,7 @@ elk_nir_lower_vs_inputs(nir_shader *nir,
                      nir_intrinsic_set_component(load, 1);
                   break;
                default:
-                  unreachable("Invalid system value intrinsic");
+                  UNREACHABLE("Invalid system value intrinsic");
                }
 
                load->num_components = 1;
@@ -861,7 +861,7 @@ lower_bit_size_callback(const nir_instr *instr, UNUSED void *data)
       case nir_op_fcos:
          return 32;
       case nir_op_isign:
-         unreachable("Should have been lowered by nir_opt_algebraic.");
+         UNREACHABLE("Should have been lowered by nir_opt_algebraic.");
       default:
          if (nir_op_infos[alu->op].num_inputs >= 2 &&
              alu->def.bit_size == 8)
@@ -1710,7 +1710,7 @@ get_subgroup_size(const struct shader_info *info, unsigned max_subgroup_size)
       return info->stage == MESA_SHADER_FRAGMENT ? 0 : max_subgroup_size;
 
    case SUBGROUP_SIZE_REQUIRE_4:
-      unreachable("Unsupported subgroup size type");
+      UNREACHABLE("Unsupported subgroup size type");
 
    case SUBGROUP_SIZE_REQUIRE_8:
    case SUBGROUP_SIZE_REQUIRE_16:
@@ -1728,7 +1728,7 @@ get_subgroup_size(const struct shader_info *info, unsigned max_subgroup_size)
       break;
    }
 
-   unreachable("Invalid subgroup size type");
+   UNREACHABLE("Invalid subgroup size type");
 }
 
 unsigned
@@ -1810,7 +1810,7 @@ elk_cmod_for_nir_comparison(nir_op op)
       return ELK_CONDITIONAL_NZ;
 
    default:
-      unreachable("Unsupported NIR comparison op");
+      UNREACHABLE("Unsupported NIR comparison op");
    }
 }
 
@@ -1833,7 +1833,7 @@ elk_lsc_aop_for_nir_intrinsic(const nir_intrinsic_instr *atomic)
          src_idx = 1;
          break;
       default:
-         unreachable("Invalid add atomic opcode");
+         UNREACHABLE("Invalid add atomic opcode");
       }
 
       if (nir_src_is_const(atomic->src[src_idx])) {
@@ -1862,7 +1862,7 @@ elk_lsc_aop_for_nir_intrinsic(const nir_intrinsic_instr *atomic)
    case nir_atomic_op_fadd: return LSC_OP_ATOMIC_FADD;
 
    default:
-      unreachable("Unsupported NIR atomic intrinsic");
+      UNREACHABLE("Unsupported NIR atomic intrinsic");
    }
 }
 
@@ -1899,7 +1899,7 @@ elk_type_for_nir_type(const struct intel_device_info *devinfo,
    case nir_type_uint8:
       return ELK_REGISTER_TYPE_UB;
    default:
-      unreachable("unknown type");
+      UNREACHABLE("unknown type");
    }
 
    return ELK_REGISTER_TYPE_F;
diff --git a/src/intel/compiler/elk/elk_nir_analyze_boolean_resolves.c b/src/intel/compiler/elk/elk_nir_analyze_boolean_resolves.c
index d51fa0f81cd4d..c99162480dc44 100644
--- a/src/intel/compiler/elk/elk_nir_analyze_boolean_resolves.c
+++ b/src/intel/compiler/elk/elk_nir_analyze_boolean_resolves.c
@@ -199,7 +199,7 @@ analyze_boolean_resolves_block(nir_block *block)
             break;
 
          default:
-            unreachable("Invalid boolean flag");
+            UNREACHABLE("Invalid boolean flag");
          }
 
          break;
diff --git a/src/intel/compiler/elk/elk_nir_lower_cs_intrinsics.c b/src/intel/compiler/elk/elk_nir_lower_cs_intrinsics.c
index d60fc507acc7d..e9385101d870e 100644
--- a/src/intel/compiler/elk/elk_nir_lower_cs_intrinsics.c
+++ b/src/intel/compiler/elk/elk_nir_lower_cs_intrinsics.c
@@ -164,7 +164,7 @@ compute_local_index_id(nir_builder *b,
       break;
    }
    default:
-      unreachable("invalid derivative group");
+      UNREACHABLE("invalid derivative group");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_nir_lower_storage_image.c b/src/intel/compiler/elk/elk_nir_lower_storage_image.c
index b945795bd36b2..7b2d447f790b4 100644
--- a/src/intel/compiler/elk/elk_nir_lower_storage_image.c
+++ b/src/intel/compiler/elk/elk_nir_lower_storage_image.c
@@ -49,7 +49,7 @@ _load_image_param(nir_builder *b, nir_deref_instr *deref, unsigned offset)
       load->num_components = 4;
       break;
    default:
-      unreachable("Invalid param offset");
+      UNREACHABLE("Invalid param offset");
    }
    nir_def_init(&load->instr, &load->def, load->num_components, 32);
 
@@ -333,7 +333,7 @@ convert_color_for_load(nir_builder *b, const struct intel_device_info *devinfo,
       break;
 
    default:
-      unreachable("Invalid image channel type");
+      UNREACHABLE("Invalid image channel type");
    }
 
 expand_vec:
@@ -514,7 +514,7 @@ convert_color_for_store(nir_builder *b, const struct intel_device_info *devinfo,
       break;
 
    default:
-      unreachable("Invalid image channel type");
+      UNREACHABLE("Invalid image channel type");
    }
 
    if (image.bits[0] < 32 &&
diff --git a/src/intel/compiler/elk/elk_reg.h b/src/intel/compiler/elk/elk_reg.h
index a1c72ec6170eb..438bd18c73930 100644
--- a/src/intel/compiler/elk/elk_reg.h
+++ b/src/intel/compiler/elk/elk_reg.h
@@ -317,7 +317,7 @@ elk_regs_negative_equal(const struct elk_reg *a, const struct elk_reg *b)
       case ELK_REGISTER_TYPE_B:
       case ELK_REGISTER_TYPE_NF:
       default:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
    } else {
       struct elk_reg tmp = *a;
@@ -360,7 +360,7 @@ type_sz(unsigned type)
    case ELK_REGISTER_TYPE_B:
       return 1;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -397,7 +397,7 @@ elk_int_type(unsigned sz, bool is_signed)
    case 8:
       return (is_signed ? ELK_REGISTER_TYPE_Q : ELK_REGISTER_TYPE_UQ);
    default:
-      unreachable("Not reached.");
+      UNREACHABLE("Not reached.");
    }
 }
 
@@ -564,7 +564,7 @@ elk_vecn_reg(unsigned width, enum elk_reg_file file,
    case 16:
       return elk_vec16_reg(file, nr, subnr);
    default:
-      unreachable("Invalid register width");
+      UNREACHABLE("Invalid register width");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_reg_type.h b/src/intel/compiler/elk/elk_reg_type.h
index 433078a5e0e00..d2e8becfc3427 100644
--- a/src/intel/compiler/elk/elk_reg_type.h
+++ b/src/intel/compiler/elk/elk_reg_type.h
@@ -128,7 +128,7 @@ elk_reg_type_from_bit_size(unsigned bit_size,
       case 64:
          return ELK_REGISTER_TYPE_DF;
       default:
-         unreachable("Invalid bit size");
+         UNREACHABLE("Invalid bit size");
       }
    case ELK_REGISTER_TYPE_B:
    case ELK_REGISTER_TYPE_W:
@@ -144,7 +144,7 @@ elk_reg_type_from_bit_size(unsigned bit_size,
       case 64:
          return ELK_REGISTER_TYPE_Q;
       default:
-         unreachable("Invalid bit size");
+         UNREACHABLE("Invalid bit size");
       }
    case ELK_REGISTER_TYPE_UB:
    case ELK_REGISTER_TYPE_UW:
@@ -160,10 +160,10 @@ elk_reg_type_from_bit_size(unsigned bit_size,
       case 64:
          return ELK_REGISTER_TYPE_UQ;
       default:
-         unreachable("Invalid bit size");
+         UNREACHABLE("Invalid bit size");
       }
    default:
-      unreachable("Unknown type");
+      UNREACHABLE("Unknown type");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_schedule_instructions.cpp b/src/intel/compiler/elk/elk_schedule_instructions.cpp
index e6f19858e4d5e..9575330bfe385 100644
--- a/src/intel/compiler/elk/elk_schedule_instructions.cpp
+++ b/src/intel/compiler/elk/elk_schedule_instructions.cpp
@@ -459,7 +459,7 @@ elk_schedule_node::set_latency_gfx7(const struct elk_isa_info *isa)
             break;
 
          default:
-            unreachable("Unknown render cache message");
+            UNREACHABLE("Unknown render cache message");
          }
          break;
 
@@ -529,7 +529,7 @@ elk_schedule_node::set_latency_gfx7(const struct elk_isa_info *isa)
             break;
 
          default:
-            unreachable("Unknown data cache message");
+            UNREACHABLE("Unknown data cache message");
          }
          break;
 
@@ -559,7 +559,7 @@ elk_schedule_node::set_latency_gfx7(const struct elk_isa_info *isa)
             break;
 
          default:
-            unreachable("Unknown data cache message");
+            UNREACHABLE("Unknown data cache message");
          }
          break;
 
@@ -572,7 +572,7 @@ elk_schedule_node::set_latency_gfx7(const struct elk_isa_info *isa)
          break;
 
       default:
-         unreachable("Unknown SFID");
+         UNREACHABLE("Unknown SFID");
       }
       break;
 
diff --git a/src/intel/compiler/elk/elk_shader.cpp b/src/intel/compiler/elk/elk_shader.cpp
index 63fa8cdf9672b..8e7fc24b46c09 100644
--- a/src/intel/compiler/elk/elk_shader.cpp
+++ b/src/intel/compiler/elk/elk_shader.cpp
@@ -79,7 +79,7 @@ elk_type_for_base_type(const struct glsl_type *type)
    case GLSL_TYPE_BFLOAT16:
    case GLSL_TYPE_FLOAT_E4M3FN:
    case GLSL_TYPE_FLOAT_E5M2:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    return ELK_REGISTER_TYPE_F;
@@ -110,7 +110,7 @@ elk_math_function(enum elk_opcode op)
    case ELK_SHADER_OPCODE_INT_REMAINDER:
       return ELK_MATH_FUNCTION_INT_DIV_REMAINDER;
    default:
-      unreachable("not reached: unknown math function");
+      UNREACHABLE("not reached: unknown math function");
    }
 }
 
@@ -520,7 +520,7 @@ elk_instruction_name(const struct elk_isa_info *isa, enum elk_opcode op)
       return "read_sr_reg";
    }
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 bool
@@ -561,15 +561,15 @@ elk_saturate_immediate(enum elk_reg_type type, struct elk_reg *reg)
       break;
    case ELK_REGISTER_TYPE_UB:
    case ELK_REGISTER_TYPE_B:
-      unreachable("no UB/B immediates");
+      UNREACHABLE("no UB/B immediates");
    case ELK_REGISTER_TYPE_V:
    case ELK_REGISTER_TYPE_UV:
    case ELK_REGISTER_TYPE_VF:
-      unreachable("unimplemented: saturate vector immediate");
+      UNREACHABLE("unimplemented: saturate vector immediate");
    case ELK_REGISTER_TYPE_HF:
-      unreachable("unimplemented: saturate HF immediate");
+      UNREACHABLE("unimplemented: saturate HF immediate");
    case ELK_REGISTER_TYPE_NF:
-      unreachable("no NF immediates");
+      UNREACHABLE("no NF immediates");
    }
 
    if (size < 8) {
@@ -615,15 +615,15 @@ elk_negate_immediate(enum elk_reg_type type, struct elk_reg *reg)
       return true;
    case ELK_REGISTER_TYPE_UB:
    case ELK_REGISTER_TYPE_B:
-      unreachable("no UB/B immediates");
+      UNREACHABLE("no UB/B immediates");
    case ELK_REGISTER_TYPE_UV:
    case ELK_REGISTER_TYPE_V:
-      unreachable("unimplemented: negate UV/V immediate");
+      UNREACHABLE("unimplemented: negate UV/V immediate");
    case ELK_REGISTER_TYPE_HF:
       reg->ud ^= 0x80008000;
       return true;
    case ELK_REGISTER_TYPE_NF:
-      unreachable("no NF immediates");
+      UNREACHABLE("no NF immediates");
    }
 
    return false;
@@ -655,7 +655,7 @@ elk_abs_immediate(enum elk_reg_type type, struct elk_reg *reg)
       return true;
    case ELK_REGISTER_TYPE_UB:
    case ELK_REGISTER_TYPE_B:
-      unreachable("no UB/B immediates");
+      UNREACHABLE("no UB/B immediates");
    case ELK_REGISTER_TYPE_UQ:
    case ELK_REGISTER_TYPE_UD:
    case ELK_REGISTER_TYPE_UW:
@@ -663,14 +663,14 @@ elk_abs_immediate(enum elk_reg_type type, struct elk_reg *reg)
       /* Presumably the absolute value modifier on an unsigned source is a
        * nop, but it would be nice to confirm.
        */
-      unreachable("unimplemented: abs unsigned immediate");
+      UNREACHABLE("unimplemented: abs unsigned immediate");
    case ELK_REGISTER_TYPE_V:
-      unreachable("unimplemented: abs V immediate");
+      UNREACHABLE("unimplemented: abs V immediate");
    case ELK_REGISTER_TYPE_HF:
       reg->ud &= ~0x80008000;
       return true;
    case ELK_REGISTER_TYPE_NF:
-      unreachable("no NF immediates");
+      UNREACHABLE("no NF immediates");
    }
 
    return false;
@@ -1325,7 +1325,7 @@ elk_compile_tes(const struct elk_compiler *compiler,
       prog_data->domain = INTEL_TESS_DOMAIN_ISOLINE;
       break;
    default:
-      unreachable("invalid domain shader primitive mode");
+      UNREACHABLE("invalid domain shader primitive mode");
    }
 
    if (nir->info.tess.point_mode) {
diff --git a/src/intel/compiler/elk/elk_simd_selection.cpp b/src/intel/compiler/elk/elk_simd_selection.cpp
index 04b87c522c295..c479cde51aa0d 100644
--- a/src/intel/compiler/elk/elk_simd_selection.cpp
+++ b/src/intel/compiler/elk/elk_simd_selection.cpp
@@ -132,7 +132,7 @@ elk_simd_should_compile(elk_simd_selection_state &state, unsigned simd)
       start = DEBUG_CS_SIMD8;
       break;
    default:
-      unreachable("unknown shader stage in elk_simd_should_compile");
+      UNREACHABLE("unknown shader stage in elk_simd_should_compile");
    }
 
    const bool env_skip[] = {
diff --git a/src/intel/compiler/elk/elk_test_eu_compact.cpp b/src/intel/compiler/elk/elk_test_eu_compact.cpp
index b186314714403..3fed825ffcac4 100644
--- a/src/intel/compiler/elk/elk_test_eu_compact.cpp
+++ b/src/intel/compiler/elk/elk_test_eu_compact.cpp
@@ -49,7 +49,7 @@ get_compact_params_name(const testing::TestParamInfo<CompactParams> p)
       ss << "Align_16";
       break;
    default:
-      unreachable("invalid align");
+      UNREACHABLE("invalid align");
    }
    return ss.str();
 }
diff --git a/src/intel/compiler/elk/elk_test_vec4_cmod_propagation.cpp b/src/intel/compiler/elk/elk_test_vec4_cmod_propagation.cpp
index c0ab51c1201ec..d4b0bca175e4e 100644
--- a/src/intel/compiler/elk/elk_test_vec4_cmod_propagation.cpp
+++ b/src/intel/compiler/elk/elk_test_vec4_cmod_propagation.cpp
@@ -61,37 +61,37 @@ protected:
    /* Dummy implementation for pure virtual methods */
    virtual dst_reg *make_reg_for_system_value(int /* location */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void setup_payload()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_prolog()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_program_code()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_thread_end()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_urb_write_header(int /* mrf */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual vec4_instruction *emit_urb_write_opcode(bool /* complete */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 };
 
diff --git a/src/intel/compiler/elk/elk_test_vec4_copy_propagation.cpp b/src/intel/compiler/elk/elk_test_vec4_copy_propagation.cpp
index 85bd0db9fab76..fc5e993a892b5 100644
--- a/src/intel/compiler/elk/elk_test_vec4_copy_propagation.cpp
+++ b/src/intel/compiler/elk/elk_test_vec4_copy_propagation.cpp
@@ -56,32 +56,32 @@ public:
 protected:
    virtual dst_reg *make_reg_for_system_value(int /* location */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void setup_payload()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_prolog()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_thread_end()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_urb_write_header(int /* mrf */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual vec4_instruction *emit_urb_write_opcode(bool /* complete */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 };
 
diff --git a/src/intel/compiler/elk/elk_test_vec4_dead_code_eliminate.cpp b/src/intel/compiler/elk/elk_test_vec4_dead_code_eliminate.cpp
index 49df35d588f33..7b6f96070246c 100644
--- a/src/intel/compiler/elk/elk_test_vec4_dead_code_eliminate.cpp
+++ b/src/intel/compiler/elk/elk_test_vec4_dead_code_eliminate.cpp
@@ -56,32 +56,32 @@ public:
 protected:
    virtual dst_reg *make_reg_for_system_value(int /* location */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void setup_payload()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_prolog()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_thread_end()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_urb_write_header(int /* mrf */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual vec4_instruction *emit_urb_write_opcode(bool /* complete */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 };
 
diff --git a/src/intel/compiler/elk/elk_test_vec4_register_coalesce.cpp b/src/intel/compiler/elk/elk_test_vec4_register_coalesce.cpp
index 353c1157c3be3..0f91f9e4195ae 100644
--- a/src/intel/compiler/elk/elk_test_vec4_register_coalesce.cpp
+++ b/src/intel/compiler/elk/elk_test_vec4_register_coalesce.cpp
@@ -59,32 +59,32 @@ public:
 protected:
    virtual dst_reg *make_reg_for_system_value(int /* location */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void setup_payload()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_prolog()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_thread_end()
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual void emit_urb_write_header(int /* mrf */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 
    virtual vec4_instruction *emit_urb_write_opcode(bool /* complete */)
    {
-      unreachable("Not reached");
+      UNREACHABLE("Not reached");
    }
 };
 
diff --git a/src/intel/compiler/elk/elk_vec4.cpp b/src/intel/compiler/elk/elk_vec4.cpp
index eb0c7c98c9e0d..6eec285ec362d 100644
--- a/src/intel/compiler/elk/elk_vec4.cpp
+++ b/src/intel/compiler/elk/elk_vec4.cpp
@@ -387,7 +387,7 @@ vec4_instruction::implied_mrf_writes() const
    case ELK_SHADER_OPCODE_GET_BUFFER_SIZE:
       return header_size;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -648,7 +648,7 @@ vec4_visitor::opt_algebraic()
             if (inst->dst.type != inst->src[0].type &&
                 inst->dst.type != ELK_REGISTER_TYPE_DF &&
                 inst->src[0].type != ELK_REGISTER_TYPE_F)
-               unreachable("unimplemented: saturate mixed types");
+               UNREACHABLE("unimplemented: saturate mixed types");
 
             if (elk_saturate_immediate(inst->src[0].type,
                                        &inst->src[0].as_elk_reg())) {
@@ -701,7 +701,7 @@ vec4_visitor::opt_algebraic()
 	       inst->src[0] = elk_imm_ud(0u);
 	       break;
 	    default:
-	       unreachable("not reached");
+	       UNREACHABLE("not reached");
 	    }
 	    inst->src[1] = src_reg();
 	    progress = true;
@@ -1388,7 +1388,7 @@ vec4_visitor::dump_instruction_to_file(const elk_backend_instruction *be_inst, F
    case IMM:
    case ATTR:
    case UNIFORM:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
    if (inst->dst.offset ||
        (inst->dst.file == VGRF &&
@@ -1480,7 +1480,7 @@ vec4_visitor::dump_instruction_to_file(const elk_backend_instruction *be_inst, F
          fprintf(file, "(null)");
          break;
       case MRF:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
       if (inst->src[i].offset ||
@@ -1785,7 +1785,7 @@ vec4_visitor::convert_to_hw_regs()
 
          case MRF:
          case ATTR:
-            unreachable("not reached");
+            UNREACHABLE("not reached");
          }
 
          apply_logical_swizzle(&reg, inst, i);
@@ -1851,7 +1851,7 @@ vec4_visitor::convert_to_hw_regs()
       case IMM:
       case ATTR:
       case UNIFORM:
-         unreachable("not reached");
+         UNREACHABLE("not reached");
       }
 
       dst = reg;
@@ -2082,7 +2082,7 @@ scalarize_predicate(elk_predicate predicate, unsigned writemask)
    case WRITEMASK_W:
       return ELK_PREDICATE_ALIGN16_REPLICATE_W;
    default:
-      unreachable("invalid writemask");
+      UNREACHABLE("invalid writemask");
    }
 }
 
diff --git a/src/intel/compiler/elk/elk_vec4_cmod_propagation.cpp b/src/intel/compiler/elk/elk_vec4_cmod_propagation.cpp
index d628499cdda0c..488bc451c310d 100644
--- a/src/intel/compiler/elk/elk_vec4_cmod_propagation.cpp
+++ b/src/intel/compiler/elk/elk_vec4_cmod_propagation.cpp
@@ -219,7 +219,7 @@ opt_cmod_propagation_local(elk_bblock_t *block, vec4_visitor *v)
                      src1_chan = ELK_GET_SWZ(scan_inst->src[1].swizzle, 3);
                      break;
                   default:
-                     unreachable("Impossible writemask");
+                     UNREACHABLE("Impossible writemask");
                   }
 
                   scan_inst->src[0].swizzle = ELK_SWIZZLE4(src0_chan,
diff --git a/src/intel/compiler/elk/elk_vec4_generator.cpp b/src/intel/compiler/elk/elk_vec4_generator.cpp
index 03ff460e63742..cde5726f9b8ef 100644
--- a/src/intel/compiler/elk/elk_vec4_generator.cpp
+++ b/src/intel/compiler/elk/elk_vec4_generator.cpp
@@ -172,7 +172,7 @@ generate_tex(struct elk_codegen *p,
          msg_type = GFX6_SAMPLER_MESSAGE_SAMPLE_SAMPLEINFO;
          break;
       default:
-	 unreachable("should not get here: invalid vec4 texture opcode");
+	 UNREACHABLE("should not get here: invalid vec4 texture opcode");
       }
    } else {
       switch (inst->opcode) {
@@ -200,7 +200,7 @@ generate_tex(struct elk_codegen *p,
 	 assert(inst->mlen == 2);
 	 break;
       default:
-	 unreachable("should not get here: invalid vec4 texture opcode");
+	 UNREACHABLE("should not get here: invalid vec4 texture opcode");
       }
    }
 
@@ -1986,7 +1986,7 @@ generate_code(struct elk_codegen *p,
             dst_type = ELK_REGISTER_TYPE_UD;
             break;
          default:
-            unreachable("Not supported conversion");
+            UNREACHABLE("Not supported conversion");
          }
          dst = retype(dst, dst_type);
 
@@ -2198,7 +2198,7 @@ generate_code(struct elk_codegen *p,
          break;
 
       default:
-         unreachable("Unsupported opcode");
+         UNREACHABLE("Unsupported opcode");
       }
 
       if (inst->opcode == ELK_VEC4_OPCODE_PACK_BYTES) {
diff --git a/src/intel/compiler/elk/elk_vec4_gs_nir.cpp b/src/intel/compiler/elk/elk_vec4_gs_nir.cpp
index e9ce534467a8a..b2cad38587b64 100644
--- a/src/intel/compiler/elk/elk_vec4_gs_nir.cpp
+++ b/src/intel/compiler/elk/elk_vec4_gs_nir.cpp
@@ -57,7 +57,7 @@ vec4_gs_visitor::nir_emit_intrinsic(nir_intrinsic_instr *instr)
    }
 
    case nir_intrinsic_load_input:
-      unreachable("nir_lower_io should have produced per_vertex intrinsics");
+      UNREACHABLE("nir_lower_io should have produced per_vertex intrinsics");
 
    case nir_intrinsic_emit_vertex_with_counter:
       this->vertex_count =
diff --git a/src/intel/compiler/elk/elk_vec4_nir.cpp b/src/intel/compiler/elk/elk_vec4_nir.cpp
index d258ec2b5c46e..e34e2b500365c 100644
--- a/src/intel/compiler/elk/elk_vec4_nir.cpp
+++ b/src/intel/compiler/elk/elk_vec4_nir.cpp
@@ -83,7 +83,7 @@ vec4_visitor::nir_emit_cf_list(exec_list *list)
          break;
 
       default:
-         unreachable("Invalid CFG node block");
+         UNREACHABLE("Invalid CFG node block");
       }
    }
 }
@@ -160,7 +160,7 @@ vec4_visitor::nir_emit_instr(nir_instr *instr)
       break;
 
    default:
-      unreachable("VS instruction not yet implemented by NIR->vec4");
+      UNREACHABLE("VS instruction not yet implemented by NIR->vec4");
    }
 }
 
@@ -569,7 +569,7 @@ vec4_visitor::nir_emit_intrinsic(nir_intrinsic_instr *instr)
       break;
 
    case nir_intrinsic_load_vertex_id:
-      unreachable("should be lowered by vertex_id_zero_based");
+      UNREACHABLE("should be lowered by vertex_id_zero_based");
 
    case nir_intrinsic_load_vertex_id_zero_base:
    case nir_intrinsic_load_base_vertex:
@@ -577,7 +577,7 @@ vec4_visitor::nir_emit_intrinsic(nir_intrinsic_instr *instr)
    case nir_intrinsic_load_base_instance:
    case nir_intrinsic_load_draw_id:
    case nir_intrinsic_load_invocation_id:
-      unreachable("should be lowered by elk_nir_lower_vs_inputs()");
+      UNREACHABLE("should be lowered by elk_nir_lower_vs_inputs()");
 
    case nir_intrinsic_load_uniform: {
       /* Offsets are in bytes but they should always be multiples of 4 */
@@ -751,7 +751,7 @@ vec4_visitor::nir_emit_intrinsic(nir_intrinsic_instr *instr)
    }
 
    default:
-      unreachable("Unknown intrinsic");
+      UNREACHABLE("Unknown intrinsic");
    }
 }
 
@@ -857,7 +857,7 @@ vec4_visitor::emit_conversion_from_double(dst_reg dst, src_reg src)
       op = ELK_VEC4_OPCODE_DOUBLE_TO_F32;
       break;
    default:
-      unreachable("Unknown conversion");
+      UNREACHABLE("Unknown conversion");
    }
 
    dst_reg temp = dst_reg(this, glsl_dvec4_type());
@@ -1007,7 +1007,7 @@ try_immediate_source(const nir_alu_instr *instr, src_reg *op,
    }
 
    default:
-      unreachable("Non-32bit type.");
+      UNREACHABLE("Non-32bit type.");
    }
 
    /* If the instruction has more than one source, the instruction format only
@@ -1114,7 +1114,7 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
    case nir_op_vec2:
    case nir_op_vec3:
    case nir_op_vec4:
-      unreachable("not reached: should be handled by lower_vec_to_movs()");
+      UNREACHABLE("not reached: should be handled by lower_vec_to_movs()");
 
    case nir_op_i2f32:
    case nir_op_u2f32:
@@ -1284,7 +1284,7 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
    }
 
    case nir_op_ldexp:
-      unreachable("not reached: should be handled by ldexp_to_arith()");
+      UNREACHABLE("not reached: should be handled by ldexp_to_arith()");
 
    case nir_op_fsqrt:
       inst = emit_math(ELK_SHADER_OPCODE_SQRT, dst, op[0]);
@@ -1487,16 +1487,16 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
    case nir_op_unpack_half_2x16_split_x:
    case nir_op_unpack_half_2x16_split_y:
    case nir_op_pack_half_2x16_split:
-      unreachable("not reached: should not occur in vertex shader");
+      UNREACHABLE("not reached: should not occur in vertex shader");
 
    case nir_op_unpack_snorm_2x16:
    case nir_op_unpack_unorm_2x16:
    case nir_op_pack_snorm_2x16:
    case nir_op_pack_unorm_2x16:
-      unreachable("not reached: should be handled by lower_packing_builtins");
+      UNREACHABLE("not reached: should be handled by lower_packing_builtins");
 
    case nir_op_pack_uvec4_to_uint:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
 
    case nir_op_pack_uvec2_to_uint: {
       dst_reg tmp1 = dst_reg(this, glsl_uint_type());
@@ -1623,7 +1623,7 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
 
    case nir_op_ubitfield_extract:
    case nir_op_ibitfield_extract:
-      unreachable("should have been lowered");
+      UNREACHABLE("should have been lowered");
    case nir_op_ubfe:
    case nir_op_ibfe:
       assert(instr->def.bit_size < 64);
@@ -1649,7 +1649,7 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
       break;
 
    case nir_op_bitfield_insert:
-      unreachable("not reached: should have been lowered");
+      UNREACHABLE("not reached: should have been lowered");
 
    case nir_op_fsign:
        if (type_sz(op[0].type) < 8) {
@@ -1668,7 +1668,7 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
          inst->predicate = ELK_PREDICATE_NORMAL;
          dst.type = ELK_REGISTER_TYPE_F;
       } else {
-          unreachable("Should have been lowered by nir_opt_algebraic.");
+          UNREACHABLE("Should have been lowered by nir_opt_algebraic.");
       }
       break;
 
@@ -1753,17 +1753,17 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
       break;
 
    case nir_op_fdiv:
-      unreachable("not reached: should be lowered by lower_fdiv in the compiler");
+      UNREACHABLE("not reached: should be lowered by lower_fdiv in the compiler");
 
    case nir_op_fmod:
-      unreachable("not reached: should be lowered by lower_fmod in the compiler");
+      UNREACHABLE("not reached: should be lowered by lower_fmod in the compiler");
 
    case nir_op_fsub:
    case nir_op_isub:
-      unreachable("not reached: should be handled by ir_sub_to_add_neg");
+      UNREACHABLE("not reached: should be handled by ir_sub_to_add_neg");
 
    default:
-      unreachable("Unimplemented ALU operation");
+      UNREACHABLE("Unimplemented ALU operation");
    }
 
    /* If we need to do a boolean resolve, replace the result with -(x & 1)
@@ -1796,7 +1796,7 @@ vec4_visitor::nir_emit_jump(nir_jump_instr *instr)
    case nir_jump_return:
       FALLTHROUGH;
    default:
-      unreachable("unknown jump");
+      UNREACHABLE("unknown jump");
    }
 }
 
@@ -1910,13 +1910,13 @@ vec4_visitor::nir_emit_texture(nir_tex_instr *instr)
       }
 
       case nir_tex_src_projector:
-         unreachable("Should be lowered by nir_lower_tex");
+         UNREACHABLE("Should be lowered by nir_lower_tex");
 
       case nir_tex_src_bias:
-         unreachable("LOD bias is not valid for vertex shaders.\n");
+         UNREACHABLE("LOD bias is not valid for vertex shaders.\n");
 
       default:
-         unreachable("unknown texture source");
+         UNREACHABLE("unknown texture source");
       }
    }
 
@@ -1966,9 +1966,9 @@ vec4_visitor::nir_emit_texture(nir_tex_instr *instr)
    }
    case nir_texop_txb:
    case nir_texop_lod:
-      unreachable("Implicit LOD is only valid inside fragment shaders.");
+      UNREACHABLE("Implicit LOD is only valid inside fragment shaders.");
    default:
-      unreachable("Unrecognized tex op");
+      UNREACHABLE("Unrecognized tex op");
    }
 
    vec4_instruction *inst = new(mem_ctx) vec4_instruction(opcode, dest);
diff --git a/src/intel/compiler/elk/elk_vec4_tcs.cpp b/src/intel/compiler/elk/elk_vec4_tcs.cpp
index 1772670f25534..70ce793bda792 100644
--- a/src/intel/compiler/elk/elk_vec4_tcs.cpp
+++ b/src/intel/compiler/elk/elk_vec4_tcs.cpp
@@ -269,7 +269,7 @@ vec4_tcs_visitor::nir_emit_intrinsic(nir_intrinsic_instr *instr)
       break;
    }
    case nir_intrinsic_load_input:
-      unreachable("nir_lower_io should use load_per_vertex_input intrinsics");
+      UNREACHABLE("nir_lower_io should use load_per_vertex_input intrinsics");
       break;
    case nir_intrinsic_load_output:
    case nir_intrinsic_load_per_vertex_output: {
diff --git a/src/intel/compiler/elk/elk_vec4_visitor.cpp b/src/intel/compiler/elk/elk_vec4_visitor.cpp
index e5022cd037a96..3364b64d767dd 100644
--- a/src/intel/compiler/elk/elk_vec4_visitor.cpp
+++ b/src/intel/compiler/elk/elk_vec4_visitor.cpp
@@ -357,7 +357,7 @@ void
 vec4_visitor::emit_pack_half_2x16(dst_reg dst, src_reg src0)
 {
    if (devinfo->ver < 7) {
-      unreachable("ir_unop_pack_half_2x16 should be lowered");
+      UNREACHABLE("ir_unop_pack_half_2x16 should be lowered");
    }
 
    assert(dst.type == ELK_REGISTER_TYPE_UD);
@@ -434,7 +434,7 @@ void
 vec4_visitor::emit_unpack_half_2x16(dst_reg dst, src_reg src0)
 {
    if (devinfo->ver < 7) {
-      unreachable("ir_unop_unpack_half_2x16 should be lowered");
+      UNREACHABLE("ir_unop_unpack_half_2x16 should be lowered");
    }
 
    assert(dst.type == ELK_REGISTER_TYPE_F);
@@ -626,7 +626,7 @@ elk_type_size_xvec4(const struct glsl_type *type, bool as_vec4, bool bindless)
    case GLSL_TYPE_VOID:
    case GLSL_TYPE_ERROR:
    case GLSL_TYPE_COOPERATIVE_MATRIX:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 
    return 0;
@@ -795,13 +795,13 @@ vec4_visitor::emit_uniformize(const src_reg &src)
 void
 vec4_visitor::gs_emit_vertex(int /* stream_id */)
 {
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 void
 vec4_visitor::gs_end_primitive()
 {
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 void
diff --git a/src/intel/compiler/intel_gfx_ver_enum.h b/src/intel/compiler/intel_gfx_ver_enum.h
index 3f86915035763..12042dce00323 100644
--- a/src/intel/compiler/intel_gfx_ver_enum.h
+++ b/src/intel/compiler/intel_gfx_ver_enum.h
@@ -66,6 +66,6 @@ gfx_ver_from_devinfo(const struct intel_device_info *devinfo)
    case 200: return XE2;
    case 300: return XE3;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
diff --git a/src/intel/compiler/test_eu_compact.cpp b/src/intel/compiler/test_eu_compact.cpp
index d828fc5ae07a9..c0c8d7efa9721 100644
--- a/src/intel/compiler/test_eu_compact.cpp
+++ b/src/intel/compiler/test_eu_compact.cpp
@@ -49,7 +49,7 @@ get_compact_params_name(const testing::TestParamInfo<CompactParams> p)
       ss << "Align_16";
       break;
    default:
-      unreachable("invalid align");
+      UNREACHABLE("invalid align");
    }
    return ss.str();
 }
diff --git a/src/intel/compiler/test_eu_validate.cpp b/src/intel/compiler/test_eu_validate.cpp
index 0c8724fcbe6f0..9f96ece650aac 100644
--- a/src/intel/compiler/test_eu_validate.cpp
+++ b/src/intel/compiler/test_eu_validate.cpp
@@ -2859,7 +2859,7 @@ TEST_P(validation_test, gfx11_no_byte_src_1_2)
          brw_eu_inst_set_3src_a1_src1_hstride(&devinfo, last_inst, inst[i].srcs[0].hstride);
          break;
       default:
-         unreachable("invalid opcode");
+         UNREACHABLE("invalid opcode");
       }
 
       brw_eu_inst_set_dst_hstride(&devinfo, last_inst, BRW_HORIZONTAL_STRIDE_1);
@@ -3749,7 +3749,7 @@ TEST_P(validation_test, scalar_register_restrictions)
          break;
       }
       default:
-         unreachable("unexpected opcode in tests");
+         UNREACHABLE("unexpected opcode in tests");
       }
 
       brw_eu_inst_set_exec_size(&devinfo, last_inst, cvt(t.exec_size) - 1);
@@ -3884,7 +3884,7 @@ TEST_P(validation_test, bfloat_restrictions)
          brw_MAD(p, t.dst, t.src0, t.src1, t.src2);
          break;
       default:
-         unreachable("unexpected opcode in tests");
+         UNREACHABLE("unexpected opcode in tests");
       }
 
       if (tests[i].opcode == BRW_OPCODE_MAD) {
diff --git a/src/intel/dev/i915/intel_device_info.c b/src/intel/dev/i915/intel_device_info.c
index 69c0a111458bc..472bafe10176b 100644
--- a/src/intel/dev/i915/intel_device_info.c
+++ b/src/intel/dev/i915/intel_device_info.c
@@ -429,7 +429,7 @@ has_bit6_swizzle(int fd)
    };
 
    if (intel_ioctl(fd, DRM_IOCTL_I915_GEM_CREATE, &gem_create)) {
-      unreachable("Failed to create GEM BO");
+      UNREACHABLE("Failed to create GEM BO");
       return false;
    }
 
@@ -445,7 +445,7 @@ has_bit6_swizzle(int fd)
    };
 
    if (intel_ioctl(fd, DRM_IOCTL_I915_GEM_SET_TILING, &set_tiling)) {
-      unreachable("Failed to set BO tiling");
+      UNREACHABLE("Failed to set BO tiling");
       goto close_and_return;
    }
 
@@ -454,7 +454,7 @@ has_bit6_swizzle(int fd)
    };
 
    if (intel_ioctl(fd, DRM_IOCTL_I915_GEM_GET_TILING, &get_tiling)) {
-      unreachable("Failed to get BO tiling");
+      UNREACHABLE("Failed to get BO tiling");
       goto close_and_return;
    }
 
@@ -479,7 +479,7 @@ has_get_tiling(int fd)
    };
 
    if (intel_ioctl(fd, DRM_IOCTL_I915_GEM_CREATE, &gem_create)) {
-      unreachable("Failed to create GEM BO");
+      UNREACHABLE("Failed to create GEM BO");
       return false;
    }
 
diff --git a/src/intel/dev/intel_device_info.c b/src/intel/dev/intel_device_info.c
index a2d9c1c0a0010..5105697d35c63 100644
--- a/src/intel/dev/intel_device_info.c
+++ b/src/intel/dev/intel_device_info.c
@@ -1938,7 +1938,7 @@ intel_get_device_info_from_fd(int fd, struct intel_device_info *devinfo, int min
       break;
    default:
       ret = false;
-      unreachable("Missing");
+      UNREACHABLE("Missing");
    }
    if (!ret) {
       mesa_logw("Could not get intel_device_info.");
diff --git a/src/intel/dev/intel_device_info.h b/src/intel/dev/intel_device_info.h
index a7284ef9910f8..2ad8a7c20d866 100644
--- a/src/intel/dev/intel_device_info.h
+++ b/src/intel/dev/intel_device_info.h
@@ -153,7 +153,7 @@ intel_device_info_dual_subslice_id_bound(const struct intel_device_info *devinfo
             return s * devinfo->max_subslices_per_slice + ss + 1;
       }
    }
-   unreachable("Invalid topology");
+   UNREACHABLE("Invalid topology");
    return 0;
 }
 
diff --git a/src/intel/dev/intel_device_info_serialize_gen_c.py b/src/intel/dev/intel_device_info_serialize_gen_c.py
index adf8ce1eb603b..5f01bfe98eef2 100755
--- a/src/intel/dev/intel_device_info_serialize_gen_c.py
+++ b/src/intel/dev/intel_device_info_serialize_gen_c.py
@@ -51,7 +51,7 @@ dump_${decl.name}(enum ${decl.name} arg) {
       return json_value_init_string("${value}");
 % endfor
    default:
-      unreachable("invalid ${decl.name} value");
+      UNREACHABLE("invalid ${decl.name} value");
    }
 }
 
diff --git a/src/intel/dev/intel_hwconfig.c b/src/intel/dev/intel_hwconfig.c
index ec4f66dc44603..b140f106b6454 100644
--- a/src/intel/dev/intel_hwconfig.c
+++ b/src/intel/dev/intel_hwconfig.c
@@ -362,7 +362,7 @@ intel_get_hwconfig_table(int fd, struct intel_device_info *devinfo,
    case INTEL_KMD_TYPE_XE:
       return intel_device_info_xe_query_hwconfig(fd, hwconfig_len);
    default:
-      unreachable("unknown kmd type");
+      UNREACHABLE("unknown kmd type");
       return NULL;
    }
 }
diff --git a/src/intel/executor/executor_macros.c b/src/intel/executor/executor_macros.c
index 1928aa2c26732..9e2b5ad93628c 100644
--- a/src/intel/executor/executor_macros.c
+++ b/src/intel/executor/executor_macros.c
@@ -93,7 +93,7 @@ executor_macro_mov(executor_context *ec, char **src, char *line)
          break;
       }
       default:
-         unreachable("invalid gfx version");
+         UNREACHABLE("invalid gfx version");
       }
 
    } else {
@@ -115,7 +115,7 @@ executor_macro_mov(executor_context *ec, char **src, char *line)
       }
 
       default:
-         unreachable("invalid gfx version");
+         UNREACHABLE("invalid gfx version");
       }
    }
 }
@@ -143,7 +143,7 @@ executor_macro_syncnop(executor_context *ec, char **src, char *line)
    }
 
    default:
-      unreachable("invalid gfx version");
+      UNREACHABLE("invalid gfx version");
    }
 }
 
@@ -184,7 +184,7 @@ executor_macro_eot(executor_context *ec, char **src, char *line)
          break;
    }
    default:
-      unreachable("invalid gfx version");
+      UNREACHABLE("invalid gfx version");
    }
 }
 
@@ -220,7 +220,7 @@ executor_macro_id(executor_context *ec, char **src, char *line)
    }
 
    default:
-      unreachable("invalid gfx version");
+      UNREACHABLE("invalid gfx version");
    }
 }
 
@@ -284,7 +284,7 @@ executor_macro_write(executor_context *ec, char **src, char *line)
    }
 
    default:
-      unreachable("invalid gfx version");
+      UNREACHABLE("invalid gfx version");
    }
 }
 
@@ -349,7 +349,7 @@ executor_macro_read(executor_context *ec, char **src, char *line)
    }
 
    default:
-      unreachable("invalid gfx version");
+      UNREACHABLE("invalid gfx version");
    }
 }
 
diff --git a/src/intel/executor/executor_main.c b/src/intel/executor/executor_main.c
index 29354c98e9018..4575e0ca9ccb1 100644
--- a/src/intel/executor/executor_main.c
+++ b/src/intel/executor/executor_main.c
@@ -236,7 +236,7 @@ static struct {
    case 125: gfx125_##func(__VA_ARGS__); break;             \
    case 200: gfx20_ ##func(__VA_ARGS__); break;             \
    case 300: gfx30_ ##func(__VA_ARGS__); break;             \
-   default: unreachable("Unsupported hardware generation"); \
+   default: UNREACHABLE("Unsupported hardware generation"); \
    }
 
 static void
diff --git a/src/intel/genxml/gen_bits_header.py b/src/intel/genxml/gen_bits_header.py
index b2edb1d5c8452..9024cf9a15a4f 100644
--- a/src/intel/genxml/gen_bits_header.py
+++ b/src/intel/genxml/gen_bits_header.py
@@ -96,7 +96,7 @@ ${item.token_name}_${prop}(const struct intel_device_info *devinfo)
    case 45: return ${item.get_prop(prop, 4.5)};
    case 40: return ${item.get_prop(prop, 4)};
    default:
-      unreachable("Invalid hardware generation");
+      UNREACHABLE("Invalid hardware generation");
    }
 }
 %endif
diff --git a/src/intel/isl/isl.c b/src/intel/isl/isl.c
index 4bf2929b1f49c..07a78528f5ab3 100644
--- a/src/intel/isl/isl.c
+++ b/src/intel/isl/isl.c
@@ -434,7 +434,7 @@ isl_device_init(struct isl_device *dev,
    do {
       CHOOSE(ISL_TILING_4);
       CHOOSE(ISL_TILING_Y0);
-      unreachable("Cannot find shader tiling");
+      UNREACHABLE("Cannot find shader tiling");
    } while (0);
 #undef CHOOSE
 }
@@ -1081,7 +1081,7 @@ tiling_max_mip_tail(enum isl_tiling tiling,
       break;
 
    default:
-      unreachable("Invalid tiling");
+      UNREACHABLE("Invalid tiling");
    }
 
    assert(dim != ISL_SURF_DIM_1D);
@@ -1125,7 +1125,7 @@ isl_tiling_supports_dimensions(const struct intel_device_info *devinfo,
       return true;
 
    default:
-      unreachable("invalid dimension");
+      UNREACHABLE("invalid dimension");
    }
 }
 
@@ -1238,7 +1238,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(tile_ysyf_2d_8bpp_swiz, 12);
             break;
          default:
-            unreachable("Unsupported format size");
+            UNREACHABLE("Unsupported format size");
          }
          break;
       case ISL_SURF_DIM_3D:
@@ -1255,11 +1255,11 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(skl_tile_ysyf_3d_16_8bpp_swiz, 12);
             break;
          default:
-            unreachable("Unsupported format size");
+            UNREACHABLE("Unsupported format size");
          }
          break;
       default:
-         unreachable("Invalid dimension");
+         UNREACHABLE("Invalid dimension");
       }
 
       phys_B.w = logical_el.width * bs;
@@ -1315,7 +1315,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(_8bpp_swiz[ffs(samples) - 1], tiling_bits);
             break;
          default:
-            unreachable("Unsupported format size");
+            UNREACHABLE("Unsupported format size");
          }
          break;
       }
@@ -1338,13 +1338,13 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(ICL_OR_SKL(tile_ysyf_3d_16_8bpp_swiz), tiling_bits);
             break;
          default:
-            unreachable("Unsupported format size");
+            UNREACHABLE("Unsupported format size");
          }
 #undef ICL_OR_SKL
          break;
 
       default:
-         unreachable("Invalid dimension");
+         UNREACHABLE("Invalid dimension");
       }
 
       const uint32_t tile_size_B = 1u << tiling_bits;
@@ -1370,7 +1370,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(acm_tile64_3d_8bpp_swiz, 16);
             break;
          default:
-            unreachable("Unsupported format size for 3D");
+            UNREACHABLE("Unsupported format size for 3D");
          }
       } else {
          const uint8_t *_128_64bpp_swiz[5] = {
@@ -1423,7 +1423,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(_8bpp_swiz[sample_idx], 16);
             break;
          default:
-            unreachable("Unsupported format size.");
+            UNREACHABLE("Unsupported format size.");
          }
       }
 
@@ -1447,7 +1447,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             SET_SWIZ(xe2_tile64_3d_16_8bpp_swiz, 16);
             break;
          default:
-            unreachable("Unsupported format size for 3D");
+            UNREACHABLE("Unsupported format size for 3D");
          }
       } else {
          if (samples == 1 || msaa_layout == ISL_MSAA_LAYOUT_INTERLEAVED) {
@@ -1464,7 +1464,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
                SET_SWIZ(xe2_tile64_2d_8bpp_swiz, 16);
                break;
             default:
-               unreachable("Unsupported format size.");
+               UNREACHABLE("Unsupported format size.");
             }
          } else if (samples == 2) {
             switch (format_bpb) {
@@ -1482,7 +1482,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
                SET_SWIZ(xe2_tile64_2d_8bpp_2msaa_swiz, 16);
                break;
             default:
-               unreachable("Unsupported format size.");
+               UNREACHABLE("Unsupported format size.");
             }
          } else if (samples == 4) {
             switch (format_bpb) {
@@ -1497,7 +1497,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             case   8:
                SET_SWIZ(xe2_tile64_2d_8bpp_4msaa_swiz, 16);
                break;
-            default: unreachable("Unsupported format size.");
+            default: UNREACHABLE("Unsupported format size.");
             }
          } else if (samples == 8) {
             switch (format_bpb) {
@@ -1510,7 +1510,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             case   8:
                SET_SWIZ(xe2_tile64_2d_16_8bpp_8msaa_swiz, 16);
                break;
-            default: unreachable("Unsupported format size.");
+            default: UNREACHABLE("Unsupported format size.");
             }
          } else if (samples == 16) {
             switch (format_bpb) {
@@ -1525,7 +1525,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
             case   8:
                SET_SWIZ(xe2_tile64_2d_8bpp_16msaa_swiz, 16);
                break;
-            default: unreachable("Unsupported format size.");
+            default: UNREACHABLE("Unsupported format size.");
             }
          }
       }
@@ -1568,7 +1568,7 @@ isl_tiling_get_info(enum isl_tiling tiling,
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    } /* end switch */
 
 #undef SET_SWIZ
@@ -1893,7 +1893,7 @@ isl_choose_array_pitch_span(const struct isl_device *dev,
       return ISL_ARRAY_PITCH_SPAN_COMPACT;
    }
 
-   unreachable("bad isl_dim_layout");
+   UNREACHABLE("bad isl_dim_layout");
    return ISL_ARRAY_PITCH_SPAN_FULL;
 }
 
@@ -2061,7 +2061,7 @@ isl_surf_choose_dim_layout(const struct isl_device *dev,
       }
    }
 
-   unreachable("bad isl_surf_dim");
+   UNREACHABLE("bad isl_surf_dim");
    return ISL_DIM_LAYOUT_GFX4_2D;
 }
 
@@ -2080,7 +2080,7 @@ isl_calc_phys_level0_extent_sa(const struct isl_device *dev,
    const struct isl_format_layout *fmtl = isl_format_get_layout(info->format);
 
    if (isl_format_is_planar(info->format))
-      unreachable("Planar formats unsupported");
+      UNREACHABLE("Planar formats unsupported");
 
    switch (info->dim) {
    case ISL_SURF_DIM_1D:
@@ -2090,7 +2090,7 @@ isl_calc_phys_level0_extent_sa(const struct isl_device *dev,
 
       switch (dim_layout) {
       case ISL_DIM_LAYOUT_GFX4_3D:
-         unreachable("bad isl_dim_layout");
+         UNREACHABLE("bad isl_dim_layout");
 
       case ISL_DIM_LAYOUT_GFX9_1D:
       case ISL_DIM_LAYOUT_GFX4_2D:
@@ -2170,7 +2170,7 @@ isl_calc_phys_level0_extent_sa(const struct isl_device *dev,
       switch (dim_layout) {
       case ISL_DIM_LAYOUT_GFX9_1D:
       case ISL_DIM_LAYOUT_GFX6_STENCIL_HIZ:
-         unreachable("bad isl_dim_layout");
+         UNREACHABLE("bad isl_dim_layout");
 
       case ISL_DIM_LAYOUT_GFX4_2D:
       case ISL_DIM_LAYOUT_GFX4_3D:
@@ -2218,7 +2218,7 @@ isl_get_miptail_level_offset_el(enum isl_tiling tiling,
          *y_offset_el = skl_std_y_2d_miptail_offset_el[row][col][1];
          break;
       default:
-         unreachable("invalid tiling");
+         UNREACHABLE("invalid tiling");
       }
       *z_offset_el = 0;
       break;
@@ -2250,12 +2250,12 @@ isl_get_miptail_level_offset_el(enum isl_tiling tiling,
          *z_offset_el = skl_std_y_3d_miptail_offset_el[row][col][2];
          break;
       default:
-         unreachable("invalid tiling");
+         UNREACHABLE("invalid tiling");
       }
       break;
 
    case ISL_SURF_DIM_1D:
-      unreachable("invalid dimension");
+      UNREACHABLE("invalid dimension");
    }
 }
 
@@ -2852,7 +2852,7 @@ isl_calc_phys_total_extent_el(const struct isl_device *dev,
       return;
    }
 
-   unreachable("invalid value for dim_layout");
+   UNREACHABLE("invalid value for dim_layout");
 }
 
 static uint32_t
@@ -3532,7 +3532,7 @@ get_2d_array_extent(const struct isl_device *isl_dev,
       }
    }
 
-   unreachable("extent not found for given number of tiles.");
+   UNREACHABLE("extent not found for given number of tiles.");
 }
 
 void
@@ -3707,7 +3707,7 @@ isl_surf_get_mcs_surf(const struct isl_device *dev,
    case 8:  mcs_format = ISL_FORMAT_MCS_8X;  break;
    case 16: mcs_format = ISL_FORMAT_MCS_16X; break;
    default:
-      unreachable("Invalid sample count");
+      UNREACHABLE("Invalid sample count");
    }
 
    return isl_surf_init(dev, mcs_surf,
@@ -3942,24 +3942,24 @@ isl_surf_get_ccs_surf(const struct isl_device *dev,
       case 32:    ccs_format = ISL_FORMAT_GFX9_CCS_32BPP;   break;
       case 64:    ccs_format = ISL_FORMAT_GFX9_CCS_64BPP;   break;
       case 128:   ccs_format = ISL_FORMAT_GFX9_CCS_128BPP;  break;
-      default:    unreachable("Unsupported CCS format");
+      default:    UNREACHABLE("Unsupported CCS format");
       }
    } else if (surf->tiling == ISL_TILING_Y0) {
       switch (isl_format_get_layout(surf->format)->bpb) {
       case 32:    ccs_format = ISL_FORMAT_GFX7_CCS_32BPP_Y;    break;
       case 64:    ccs_format = ISL_FORMAT_GFX7_CCS_64BPP_Y;    break;
       case 128:   ccs_format = ISL_FORMAT_GFX7_CCS_128BPP_Y;   break;
-      default:    unreachable("Unsupported CCS format");
+      default:    UNREACHABLE("Unsupported CCS format");
       }
    } else if (surf->tiling == ISL_TILING_X) {
       switch (isl_format_get_layout(surf->format)->bpb) {
       case 32:    ccs_format = ISL_FORMAT_GFX7_CCS_32BPP_X;    break;
       case 64:    ccs_format = ISL_FORMAT_GFX7_CCS_64BPP_X;    break;
       case 128:   ccs_format = ISL_FORMAT_GFX7_CCS_128BPP_X;   break;
-      default:    unreachable("Unsupported CCS format");
+      default:    UNREACHABLE("Unsupported CCS format");
       }
    } else {
-      unreachable("Invalid tiling format");
+      UNREACHABLE("Invalid tiling format");
    }
 
    return isl_surf_init(dev, ccs_surf,
@@ -4017,7 +4017,7 @@ isl_surf_get_ccs_surf(const struct isl_device *dev,
       isl_gfx30_##func(__VA_ARGS__);               \
       break;                                       \
    default:                                        \
-      unreachable("Unknown hardware generation");  \
+      UNREACHABLE("Unknown hardware generation");  \
    }
 
 /**
@@ -4295,7 +4295,7 @@ isl_surf_get_image_offset_sa(const struct isl_surf *surf,
       break;
 
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -4934,7 +4934,7 @@ isl_surf_get_depth_format(const struct isl_device *dev,
 
    switch (surf->format) {
    default:
-      unreachable("bad isl depth format");
+      UNREACHABLE("bad isl depth format");
    case ISL_FORMAT_R32_FLOAT_X8X24_TYPELESS:
       assert(ISL_GFX_VER(dev) < 7);
       return 0; /* D32_FLOAT_S8X24_UINT */
@@ -5031,7 +5031,7 @@ swizzle_select(enum isl_channel_select chan, struct isl_swizzle swizzle)
    case ISL_CHANNEL_SELECT_ALPHA:
       return swizzle.a;
    default:
-      unreachable("Invalid swizzle component");
+      UNREACHABLE("Invalid swizzle component");
    }
 }
 
@@ -5208,7 +5208,7 @@ isl_format_get_aux_map_encoding(enum isl_format format)
    case ISL_FORMAT_YCRCB_NORMAL: return 0x3;
    case ISL_FORMAT_YCRCB_SWAPY: return 0xB;
    default:
-      unreachable("Unsupported aux-map format!");
+      UNREACHABLE("Unsupported aux-map format!");
       return 0;
    }
 }
diff --git a/src/intel/isl/isl.h b/src/intel/isl/isl.h
index 014dc5f440c6e..7947839562c29 100644
--- a/src/intel/isl/isl.h
+++ b/src/intel/isl/isl.h
@@ -2197,10 +2197,10 @@ isl_format_has_bc_compression(enum isl_format fmt)
    case ISL_TXC_HIZ:
    case ISL_TXC_MCS:
    case ISL_TXC_CCS:
-      unreachable("Should not be called on an aux surface");
+      UNREACHABLE("Should not be called on an aux surface");
    }
 
-   unreachable("bad texture compression mode");
+   UNREACHABLE("bad texture compression mode");
    return false;
 }
 
@@ -3300,7 +3300,7 @@ isl_get_tile_dims(enum isl_tiling tiling, uint32_t cpp,
       *tile_h = 1;
       break;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
diff --git a/src/intel/isl/isl_aux_info.c b/src/intel/isl/isl_aux_info.c
index ef8b9bda3ebc5..437e473a7fc1b 100644
--- a/src/intel/isl/isl_aux_info.c
+++ b/src/intel/isl/isl_aux_info.c
@@ -31,8 +31,8 @@ UNUSED static void static_assert_func(void) {
    STATIC_ASSERT(ISL_AUX_STATE_ASSERT == ((enum isl_aux_state) 0));
 }
 
-#undef unreachable
-#define unreachable(str) return 0
+#undef unreachable_assert
+#define unreachable_assert(str) return 0
 
 #undef assert
 #define assert(cond) do { \
@@ -124,7 +124,7 @@ aux_state_possible(enum isl_aux_state state,
 #endif
    }
 
-   unreachable("Invalid aux state.");
+   UNREACHABLE("Invalid aux state.");
 }
 
 enum isl_aux_state
@@ -201,10 +201,10 @@ isl_aux_get_initial_state(const struct intel_device_info *devinfo,
           */
          return ISL_AUX_STATE_COMPRESSED_NO_CLEAR;
       } else {
-         unreachable("Unsupported gfx version");
+         UNREACHABLE("Unsupported gfx version");
       }
    default:
-      unreachable("Unsupported aux mode");
+      UNREACHABLE("Unsupported aux mode");
    }
 }
 
@@ -246,7 +246,7 @@ isl_aux_prepare_access(enum isl_aux_state initial_state,
 #endif
    }
 
-   unreachable("Invalid aux state.");
+   UNREACHABLE("Invalid aux state.");
 }
 
 enum isl_aux_state
@@ -283,7 +283,7 @@ isl_aux_state_transition_aux_op(enum isl_aux_state initial_state,
 #endif
    }
 
-   unreachable("Invalid aux op.");
+   UNREACHABLE("Invalid aux op.");
 }
 
 enum isl_aux_state
@@ -332,7 +332,7 @@ isl_aux_state_transition_write(enum isl_aux_state initial_state,
 #endif
    }
 
-   unreachable("Invalid aux state.");
+   UNREACHABLE("Invalid aux state.");
 }
 
 bool
diff --git a/src/intel/isl/isl_drm.c b/src/intel/isl/isl_drm.c
index deb7bf9676ae7..a2524f919e4a4 100644
--- a/src/intel/isl/isl_drm.c
+++ b/src/intel/isl/isl_drm.c
@@ -57,7 +57,7 @@ isl_tiling_to_i915_tiling(enum isl_tiling tiling)
       return I915_TILING_NONE;
    }
 
-   unreachable("Invalid ISL tiling");
+   UNREACHABLE("Invalid ISL tiling");
 }
 
 enum isl_tiling
@@ -74,7 +74,7 @@ isl_tiling_from_i915_tiling(uint32_t tiling)
       return ISL_TILING_Y0;
    }
 
-   unreachable("Invalid i915 tiling");
+   UNREACHABLE("Invalid i915 tiling");
 }
 
 /** Sentinel is DRM_FORMAT_MOD_INVALID. */
diff --git a/src/intel/isl/isl_emit_cpb.c b/src/intel/isl/isl_emit_cpb.c
index 2af2064d0660d..fcd92a024a4af 100644
--- a/src/intel/isl/isl_emit_cpb.c
+++ b/src/intel/isl/isl_emit_cpb.c
@@ -121,6 +121,6 @@ isl_genX(emit_cpb_control_s)(const struct isl_device *dev, void *batch,
    uint32_t *dw = batch;
    GENX(3DSTATE_CPSIZE_CONTROL_BUFFER_pack)(NULL, dw, &cpb);
 #else
-   unreachable("Coarse pixel shading not supported");
+   UNREACHABLE("Coarse pixel shading not supported");
 #endif
 }
diff --git a/src/intel/isl/isl_emit_depth_stencil.c b/src/intel/isl/isl_emit_depth_stencil.c
index 6d6620c9bffad..c1344961d1173 100644
--- a/src/intel/isl/isl_emit_depth_stencil.c
+++ b/src/intel/isl/isl_emit_depth_stencil.c
@@ -427,7 +427,7 @@ isl_genX(emit_depth_stencil_hiz_s)(const struct isl_device *dev, void *batch,
          clear.DepthClearValue = info->depth_clear_value * ((1u << 16) - 1);
          break;
       default:
-         unreachable("Invalid depth type");
+         UNREACHABLE("Invalid depth type");
       }
 #endif
 #endif
diff --git a/src/intel/isl/isl_format.c b/src/intel/isl/isl_format.c
index e842ac63aa55a..e6a10820b8294 100644
--- a/src/intel/isl/isl_format.c
+++ b/src/intel/isl/isl_format.c
@@ -1087,7 +1087,7 @@ isl_format_has_color_component(enum isl_format fmt, int component)
    case 3:
       return (fmtl->channels.a.bits + intensity) > 0;
    default:
-      unreachable("Invalid color component: must be 0..3");
+      UNREACHABLE("Invalid color component: must be 0..3");
    }
 }
 
@@ -1111,7 +1111,7 @@ isl_format_get_depth_format(enum isl_format fmt, bool has_stencil)
 {
    switch (fmt) {
    default:
-      unreachable("bad isl depth format");
+      UNREACHABLE("bad isl depth format");
    case ISL_FORMAT_R32_FLOAT_X8X24_TYPELESS:
       assert(has_stencil);
       return 0; /* D32_FLOAT_S8X24_UINT */
@@ -1211,7 +1211,7 @@ isl_format_rgbx_to_rgba(enum isl_format rgbx)
    case ISL_FORMAT_B5G5R5X1_UNORM_SRGB:
       return ISL_FORMAT_B5G5R5A1_UNORM_SRGB;
    default:
-      unreachable("Invalid RGBX format");
+      UNREACHABLE("Invalid RGBX format");
    }
 }
 
@@ -1300,7 +1300,7 @@ pack_channel(const union isl_color_value *value, unsigned i,
       break;
 
    default:
-      unreachable("Invalid channel type");
+      UNREACHABLE("Invalid channel type");
    }
 
    unsigned dword = layout->start_bit / 32;
@@ -1399,7 +1399,7 @@ unpack_channel(union isl_color_value *value,
       break;
 
    default:
-      unreachable("Invalid channel type");
+      UNREACHABLE("Invalid channel type");
    }
 
    for (unsigned i = 0; i < count; i++)
diff --git a/src/intel/isl/isl_genX_helpers.h b/src/intel/isl/isl_genX_helpers.h
index 4788d23cd4870..075a311c047b3 100644
--- a/src/intel/isl/isl_genX_helpers.h
+++ b/src/intel/isl/isl_genX_helpers.h
@@ -53,7 +53,7 @@ isl_encode_halign(uint8_t halign)
    case   4: return HALIGN_4;
    case   8: return HALIGN_8;
 #endif
-   default: unreachable("Invalid halign");
+   default: UNREACHABLE("Invalid halign");
    }
 }
 
@@ -69,7 +69,7 @@ isl_encode_valign(uint8_t valign)
    case   2: return VALIGN_2;
    case   4: return VALIGN_4;
 #endif
-   default: unreachable("Invalid valign");
+   default: UNREACHABLE("Invalid valign");
    }
 }
 
@@ -136,7 +136,7 @@ isl_get_qpitch(const struct isl_surf *surf)
 {
    switch (surf->dim_layout) {
    default:
-      unreachable("Bad isl_surf_dim");
+      UNREACHABLE("Bad isl_surf_dim");
    case ISL_DIM_LAYOUT_GFX4_2D:
       if (GFX_VER >= 9) {
          if (surf->dim == ISL_SURF_DIM_3D && surf->tiling == ISL_TILING_W) {
@@ -327,7 +327,7 @@ isl_get_render_compression_format(enum isl_format format)
    case ISL_FORMAT_R9G9B9E5_SHAREDEXP:
       return CMF_R11_G11_B10;
    default:
-      unreachable("Unsupported render compression format!");
+      UNREACHABLE("Unsupported render compression format!");
       return 0;
    }
 }
@@ -429,7 +429,7 @@ isl_get_render_compression_format(enum isl_format format)
    case ISL_FORMAT_R8_SINT:
       return 0x19;
    default:
-      unreachable("Unsupported render compression format!");
+      UNREACHABLE("Unsupported render compression format!");
       return 0;
    }
 }
diff --git a/src/intel/isl/isl_priv.h b/src/intel/isl/isl_priv.h
index 332900b17f825..a660569d4af3b 100644
--- a/src/intel/isl/isl_priv.h
+++ b/src/intel/isl/isl_priv.h
@@ -82,7 +82,7 @@ typedef void (*isl_emit_cpb_control_s_func)(const struct isl_device *dev, void *
       case 300:                                                         \
          return isl_gfx30_##func;                                       \
       default:                                                          \
-         unreachable("Unknown hardware generation");                    \
+         UNREACHABLE("Unknown hardware generation");                    \
       }                                                                 \
    }
 
diff --git a/src/intel/isl/isl_storage_image.c b/src/intel/isl/isl_storage_image.c
index 492e901cf7b14..3ee523863c73e 100644
--- a/src/intel/isl/isl_storage_image.c
+++ b/src/intel/isl/isl_storage_image.c
@@ -228,7 +228,7 @@ isl_lower_storage_image_format(const struct intel_device_info *devinfo,
       return ISL_FORMAT_R32G32_UINT;
 
    default:
-      unreachable("Unknown image format");
+      UNREACHABLE("Unknown image format");
    }
 }
 
@@ -337,7 +337,7 @@ isl_surf_fill_image_param(const struct isl_device *dev,
       break;
 
    default:
-      unreachable("Unhandled storage image tiling");
+      UNREACHABLE("Unhandled storage image tiling");
    }
 
    /* 3D textures are arranged in 2D in memory with 2^lod slices per row.  The
diff --git a/src/intel/isl/isl_surface_state.c b/src/intel/isl/isl_surface_state.c
index ef42e84718b28..e82d3646b3d51 100644
--- a/src/intel/isl/isl_surface_state.c
+++ b/src/intel/isl/isl_surface_state.c
@@ -123,7 +123,7 @@ get_surftype(enum isl_surf_dim dim, isl_surf_usage_flags_t usage)
 {
    switch (dim) {
    default:
-      unreachable("bad isl_surf_dim");
+      UNREACHABLE("bad isl_surf_dim");
    case ISL_SURF_DIM_1D:
       assert(!(usage & ISL_SURF_USAGE_CUBE_BIT));
       return SURFTYPE_1D;
@@ -445,7 +445,7 @@ isl_genX(surf_fill_state_s)(const struct isl_device *dev, void *state,
       s.RenderTargetViewExtent = info->view->array_len - 1;
       break;
    default:
-      unreachable("bad SurfaceType");
+      UNREACHABLE("bad SurfaceType");
    }
 
 #if GFX_VER >= 7
@@ -749,7 +749,7 @@ isl_genX(surf_fill_state_s)(const struct isl_device *dev, void *state,
          case ISL_FORMAT_R16_UNORM:
             break;
          default:
-            unreachable("Incompatible HiZ Sampling format");
+            UNREACHABLE("Incompatible HiZ Sampling format");
          }
       }
 
@@ -909,7 +909,7 @@ isl_genX(surf_fill_state_s)(const struct isl_device *dev, void *state,
          s.ClearValueAddressEnable = true;
          s.ClearValueAddress = info->clear_address;
 #else
-         unreachable("Only Gfx11 and Gfx12 support indirect clear colors");
+         UNREACHABLE("Only Gfx11 and Gfx12 support indirect clear colors");
 #endif
       }
 
diff --git a/src/intel/isl/isl_tiled_memcpy.c b/src/intel/isl/isl_tiled_memcpy.c
index da1555742522b..5b2f0d684d839 100644
--- a/src/intel/isl/isl_tiled_memcpy.c
+++ b/src/intel/isl/isl_tiled_memcpy.c
@@ -1338,12 +1338,12 @@ choose_copy_function(isl_memcpy_type copy_type)
 #if defined(INLINE_SSE41)
       return _memcpy_streaming_load;
 #else
-      unreachable("ISL_MEMCOPY_STREAMING_LOAD requires sse4.1");
+      UNREACHABLE("ISL_MEMCOPY_STREAMING_LOAD requires sse4.1");
 #endif
    case ISL_MEMCPY_INVALID:
-      unreachable("invalid copy_type");
+      UNREACHABLE("invalid copy_type");
    }
-   unreachable("unhandled copy_type");
+   UNREACHABLE("unhandled copy_type");
    return NULL;
 }
 
@@ -1375,7 +1375,7 @@ linear_to_xtiled_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  dst, src, src_pitch, swizzle_bit,
                                  rgba8_copy, rgba8_copy_aligned_dst);
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    } else {
       if (mem_copy == memcpy)
          return linear_to_xtiled(x0, x1, x2, x3, y0, y1,
@@ -1386,7 +1386,7 @@ linear_to_xtiled_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  dst, src, src_pitch, swizzle_bit,
                                  rgba8_copy, rgba8_copy_aligned_dst);
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 }
 
@@ -1418,7 +1418,7 @@ linear_to_ytiled_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  dst, src, src_pitch, swizzle_bit,
                                  rgba8_copy, rgba8_copy_aligned_dst);
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    } else {
       if (mem_copy == memcpy)
          return linear_to_ytiled(x0, x1, x2, x3, y0, y1,
@@ -1428,7 +1428,7 @@ linear_to_ytiled_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  dst, src, src_pitch, swizzle_bit,
                                  rgba8_copy, rgba8_copy_aligned_dst);
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 }
 
@@ -1461,7 +1461,7 @@ linear_to_tile4_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  dst, src, src_pitch, swizzle_bit,
                                  rgba8_copy, rgba8_copy_aligned_dst);
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    } else {
       if (mem_copy == memcpy)
          return linear_to_tile4(x0, x1, x2, x3, y0, y1,
@@ -1471,7 +1471,7 @@ linear_to_tile4_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  dst, src, src_pitch, swizzle_bit,
                                  rgba8_copy, rgba8_copy_aligned_dst);
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 }
 
@@ -1538,7 +1538,7 @@ xtiled_to_linear_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  memcpy, _memcpy_streaming_load);
 #endif
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    } else {
       if (mem_copy == memcpy)
          return xtiled_to_linear(x0, x1, x2, x3, y0, y1,
@@ -1554,7 +1554,7 @@ xtiled_to_linear_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  memcpy, _memcpy_streaming_load);
 #endif
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 }
 
@@ -1592,7 +1592,7 @@ ytiled_to_linear_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  memcpy, _memcpy_streaming_load);
 #endif
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    } else {
       if (mem_copy == memcpy)
          return ytiled_to_linear(x0, x1, x2, x3, y0, y1,
@@ -1608,7 +1608,7 @@ ytiled_to_linear_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  memcpy, _memcpy_streaming_load);
 #endif
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 }
 
@@ -1647,7 +1647,7 @@ tile4_to_linear_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  memcpy, _memcpy_streaming_load);
 #endif
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    } else {
       if (mem_copy == memcpy)
          return tile4_to_linear(x0, x1, x2, x3, y0, y1,
@@ -1663,7 +1663,7 @@ tile4_to_linear_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                                  memcpy, _memcpy_streaming_load);
 #endif
       else
-         unreachable("not reached");
+         UNREACHABLE("not reached");
    }
 }
 
@@ -1753,7 +1753,7 @@ linear_to_tiled(uint32_t xt1, uint32_t xt2,
        */
       dst_pitch /= 2;
    } else {
-      unreachable("unsupported tiling");
+      UNREACHABLE("unsupported tiling");
    }
 
    /* Round out to tile boundaries. */
@@ -1863,7 +1863,7 @@ tiled_to_linear(uint32_t xt1, uint32_t xt2,
        */
       src_pitch /= 2;
    } else {
-      unreachable("unsupported tiling");
+      UNREACHABLE("unsupported tiling");
    }
 
 #if defined(INLINE_SSE41)
diff --git a/src/intel/nullhw-layer/intel_nullhw.c b/src/intel/nullhw-layer/intel_nullhw.c
index b9e29e5bcb16f..d24abf83406d7 100644
--- a/src/intel/nullhw-layer/intel_nullhw.c
+++ b/src/intel/nullhw-layer/intel_nullhw.c
@@ -181,7 +181,7 @@ static VkLayerDeviceCreateInfo *get_device_chain_info(const VkDeviceCreateInfo *
           ((VkLayerDeviceCreateInfo *) item)->function == func)
          return (VkLayerDeviceCreateInfo *)item;
    }
-   unreachable("device chain info not found");
+   UNREACHABLE("device chain info not found");
    return NULL;
 }
 
@@ -285,7 +285,7 @@ static VkLayerInstanceCreateInfo *get_instance_chain_info(const VkInstanceCreate
           ((VkLayerInstanceCreateInfo *) item)->function == func)
          return (VkLayerInstanceCreateInfo *) item;
    }
-   unreachable("instance chain info not found");
+   UNREACHABLE("instance chain info not found");
    return NULL;
 }
 
diff --git a/src/intel/perf/intel_perf.c b/src/intel/perf/intel_perf.c
index bf18a0954abc6..acfb35d424055 100644
--- a/src/intel/perf/intel_perf.c
+++ b/src/intel/perf/intel_perf.c
@@ -254,7 +254,7 @@ kernel_has_dynamic_config_support(struct intel_perf_config *perf, int fd)
    case INTEL_KMD_TYPE_XE:
       return true;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return false;
    }
 }
@@ -284,7 +284,7 @@ kmd_add_config(struct intel_perf_config *perf, int fd,
    case INTEL_KMD_TYPE_XE:
       return xe_add_config(perf, fd, config, guid);
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return 0;
    }
 }
@@ -383,7 +383,7 @@ init_oa_sys_vars(struct intel_perf_config *perf,
          max_file = "device/tile0/gt0/freq0/max_freq";
          break;
       default:
-         unreachable("missing");
+         UNREACHABLE("missing");
          return false;
       }
 
@@ -716,7 +716,7 @@ oa_metrics_available(struct intel_perf_config *perf, int fd,
       oa_metrics_available = xe_oa_metrics_available(perf, fd, use_register_snapshots);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       break;
    }
 
@@ -780,7 +780,7 @@ intel_perf_load_configuration(struct intel_perf_config *perf_cfg, int fd, const
    case INTEL_KMD_TYPE_I915:
       return i915_perf_load_configurations(perf_cfg, fd, guid);
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return NULL;
    }
 }
@@ -845,7 +845,7 @@ intel_perf_remove_configuration(struct intel_perf_config *perf_cfg, int fd,
       xe_remove_config(perf_cfg, fd, config_id);
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
    }
 }
 
@@ -1239,7 +1239,7 @@ intel_perf_query_result_read_gt_frequency(struct intel_perf_query_result *result
       result->gt_frequency[1] = GET_FIELD(end, GFX9_RPSTAT0_CURR_GT_FREQ) * 50ULL / 3ULL;
       break;
    default:
-      unreachable("unexpected gen");
+      UNREACHABLE("unexpected gen");
    }
 
    /* Put the numbers into Hz. */
@@ -1280,7 +1280,7 @@ query_accumulator_offset(const struct intel_perf_query_info *query,
    case INTEL_PERF_QUERY_FIELD_TYPE_SRM_OA_PEC:
       return query->pec_offset + index;
    default:
-      unreachable("Invalid register type");
+      UNREACHABLE("Invalid register type");
       return 0;
    }
 }
@@ -1568,7 +1568,7 @@ intel_perf_get_oa_format(struct intel_perf_config *perf_cfg)
    case INTEL_KMD_TYPE_XE:
       return xe_perf_get_oa_format(perf_cfg);
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return 0;
    }
 }
@@ -1591,7 +1591,7 @@ intel_perf_stream_open(struct intel_perf_config *perf_config, int drm_fd,
                                  report_format, period_exponent,
                                  hold_preemption, enable, timeline);
    default:
-         unreachable("missing");
+         UNREACHABLE("missing");
          return 0;
    }
 }
@@ -1615,7 +1615,7 @@ intel_perf_stream_read_samples(struct intel_perf_config *perf_config,
    case INTEL_KMD_TYPE_XE:
       return xe_perf_stream_read_samples(perf_config, perf_stream_fd, buffer, buffer_len);
    default:
-         unreachable("missing");
+         UNREACHABLE("missing");
          return -1;
    }
 }
@@ -1630,7 +1630,7 @@ intel_perf_stream_set_state(struct intel_perf_config *perf_config,
    case INTEL_KMD_TYPE_XE:
       return xe_perf_stream_set_state(perf_stream_fd, enable);
    default:
-         unreachable("missing");
+         UNREACHABLE("missing");
          return -1;
    }
 }
@@ -1650,7 +1650,7 @@ intel_perf_stream_set_metrics_id(struct intel_perf_config *perf_config,
                                            exec_queue, metrics_set_id,
                                            timeline);
    default:
-         unreachable("missing");
+         UNREACHABLE("missing");
          return -1;
    }
 }
diff --git a/src/intel/perf/intel_perf.h b/src/intel/perf/intel_perf.h
index 7a9e80906f645..e3c0694c6f981 100644
--- a/src/intel/perf/intel_perf.h
+++ b/src/intel/perf/intel_perf.h
@@ -661,7 +661,7 @@ intel_perf_query_counter_get_size(const struct intel_perf_query_counter *counter
    case INTEL_PERF_COUNTER_DATA_TYPE_DOUBLE:
       return sizeof(double);
    default:
-      unreachable("invalid counter data type");
+      UNREACHABLE("invalid counter data type");
    }
 }
 
diff --git a/src/intel/perf/intel_perf_mdapi.c b/src/intel/perf/intel_perf_mdapi.c
index fe1f79dc73c2b..f733346184310 100644
--- a/src/intel/perf/intel_perf_mdapi.c
+++ b/src/intel/perf/intel_perf_mdapi.c
@@ -129,7 +129,7 @@ intel_perf_query_result_write_mdapi(void *data, uint32_t data_size,
       return sizeof(*mdapi_data);
    }
    default:
-      unreachable("unexpected gen");
+      UNREACHABLE("unexpected gen");
    }
 }
 
@@ -339,7 +339,7 @@ intel_perf_register_mdapi_oa_query(struct intel_perf_config *perf,
       break;
    }
    default:
-      unreachable("Unsupported gen");
+      UNREACHABLE("Unsupported gen");
       break;
    }
 
diff --git a/src/intel/perf/intel_perf_query.c b/src/intel/perf/intel_perf_query.c
index 26aa9e47f045d..effc1d0e66b21 100644
--- a/src/intel/perf/intel_perf_query.c
+++ b/src/intel/perf/intel_perf_query.c
@@ -510,7 +510,7 @@ intel_perf_active_queries(struct intel_perf_context *perf_ctx,
       break;
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 }
@@ -711,7 +711,7 @@ snapshot_query_layout(struct intel_perf_context *perf_ctx,
                                            offset + field->location);
          break;
       default:
-         unreachable("Invalid field type");
+         UNREACHABLE("Invalid field type");
       }
    }
 }
@@ -868,7 +868,7 @@ intel_perf_begin_query(struct intel_perf_context *perf_ctx,
       break;
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 
@@ -916,7 +916,7 @@ intel_perf_end_query(struct intel_perf_context *perf_ctx,
       break;
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 }
@@ -1027,7 +1027,7 @@ read_oa_samples_until(struct intel_perf_context *perf_ctx,
       buf->last_timestamp = last_timestamp;
    }
 
-   unreachable("not reached");
+   UNREACHABLE("not reached");
    return OA_READ_STATUS_ERROR;
 }
 
@@ -1077,7 +1077,7 @@ read_oa_samples_for_query(struct intel_perf_context *perf_ctx,
       return false;
    }
 
-   unreachable("invalid read status");
+   UNREACHABLE("invalid read status");
    return false;
 }
 
@@ -1100,7 +1100,7 @@ intel_perf_wait_query(struct intel_perf_context *perf_ctx,
       break;
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 
@@ -1137,7 +1137,7 @@ intel_perf_is_query_ready(struct intel_perf_context *perf_ctx,
               !perf_cfg->vtbl.bo_busy(query->pipeline_stats.bo));
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 
@@ -1428,7 +1428,7 @@ intel_perf_delete_query(struct intel_perf_context *perf_ctx,
       break;
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 
@@ -1477,7 +1477,7 @@ get_oa_counter_data(struct intel_perf_context *perf_ctx,
             break;
          default:
             /* So far we aren't using uint32, double or bool32... */
-            unreachable("unexpected counter data type");
+            UNREACHABLE("unexpected counter data type");
          }
 
          if (counter->offset + counter_size > written)
@@ -1577,7 +1577,7 @@ intel_perf_get_query_data(struct intel_perf_context *perf_ctx,
       break;
 
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 
@@ -1610,7 +1610,7 @@ intel_perf_dump_query(struct intel_perf_context *ctx,
           obj->pipeline_stats.bo ? "yes" : "no");
       break;
    default:
-      unreachable("Unknown query type");
+      UNREACHABLE("Unknown query type");
       break;
    }
 }
diff --git a/src/intel/perf/xe/intel_perf.c b/src/intel/perf/xe/intel_perf.c
index 3963da684abdc..c3ceb1e10b91f 100644
--- a/src/intel/perf/xe/intel_perf.c
+++ b/src/intel/perf/xe/intel_perf.c
@@ -337,7 +337,7 @@ xe_perf_stream_read_error(int perf_stream_fd, uint8_t *buffer)
    else if (status.oa_status & DRM_XE_OASTATUS_MMIO_TRG_Q_FULL)
       header->type = INTEL_PERF_RECORD_TYPE_MMIO_TRG_Q_FULL;
    else
-      unreachable("missing");
+      UNREACHABLE("missing");
 
    return header->type ? header->size : -1;
 }
diff --git a/src/intel/tools/aub_write.c b/src/intel/tools/aub_write.c
index 2fc225348a1d4..2dcd33ac8385d 100644
--- a/src/intel/tools/aub_write.c
+++ b/src/intel/tools/aub_write.c
@@ -447,7 +447,7 @@ engine_from_engine_class(enum intel_engine_class engine_class)
    case INTEL_ENGINE_CLASS_VIDEO:
       return &engines[engine_class];
    default:
-      unreachable("unknown ring");
+      UNREACHABLE("unknown ring");
    }
 }
 
@@ -499,7 +499,7 @@ write_hwsp(struct aub_file *aub,
    case INTEL_ENGINE_CLASS_COPY:    reg = BCSUNIT0(HWS_PGA); break;
    case INTEL_ENGINE_CLASS_VIDEO:   reg = VCSUNIT0(HWS_PGA); break;
    default:
-      unreachable("unknown ring");
+      UNREACHABLE("unknown ring");
    }
 
    register_write_out(aub, reg, aub->engine_setup[engine_class].hwsp_addr);
diff --git a/src/intel/tools/intel_hang_replay.c b/src/intel/tools/intel_hang_replay.c
index c7bee2861affb..b30977ac4292e 100644
--- a/src/intel/tools/intel_hang_replay.c
+++ b/src/intel/tools/intel_hang_replay.c
@@ -474,7 +474,7 @@ main(int argc, char *argv[])
       }
 
       default:
-         unreachable("Invalid block type");
+         UNREACHABLE("Invalid block type");
       }
    }
 
diff --git a/src/intel/tools/intel_hang_viewer.cpp b/src/intel/tools/intel_hang_viewer.cpp
index 8759b79ede053..5b0f4a5aee324 100644
--- a/src/intel/tools/intel_hang_viewer.cpp
+++ b/src/intel/tools/intel_hang_viewer.cpp
@@ -651,7 +651,7 @@ get_block_size(uint32_t type)
    case INTEL_HANG_DUMP_BLOCK_TYPE_MAP:      return sizeof(struct intel_hang_dump_block_map);
    case INTEL_HANG_DUMP_BLOCK_TYPE_EXEC:     return sizeof(struct intel_hang_dump_block_exec);
    case INTEL_HANG_DUMP_BLOCK_TYPE_HW_IMAGE: return sizeof(struct intel_hang_dump_block_hw_image);
-   default:                                  unreachable("invalid block");
+   default:                                  UNREACHABLE("invalid block");
    }
 }
 
@@ -717,7 +717,7 @@ parse_hang_file(const char *filename)
       }
 
       default:
-         unreachable("Invalid block type");
+         UNREACHABLE("Invalid block type");
       }
    }
 }
diff --git a/src/intel/vulkan/anv_batch_chain.c b/src/intel/vulkan/anv_batch_chain.c
index b05cd4b1f154a..4376491acebdf 100644
--- a/src/intel/vulkan/anv_batch_chain.c
+++ b/src/intel/vulkan/anv_batch_chain.c
@@ -1200,7 +1200,7 @@ anv_cmd_buffer_add_secondary(struct anv_cmd_buffer *primary,
       break;
    }
    default:
-      unreachable("Invalid execution mode");
+      UNREACHABLE("Invalid execution mode");
    }
 
    anv_reloc_list_append(&primary->surface_relocs, &secondary->surface_relocs);
diff --git a/src/intel/vulkan/anv_blorp.c b/src/intel/vulkan/anv_blorp.c
index 9d1df07a00c62..78c110161b4cc 100644
--- a/src/intel/vulkan/anv_blorp.c
+++ b/src/intel/vulkan/anv_blorp.c
@@ -170,7 +170,7 @@ anv_blorp_batch_init(struct anv_cmd_buffer *cmd_buffer,
    } else if (queue_flags & VK_QUEUE_TRANSFER_BIT) {
       flags |= BLORP_BATCH_USE_BLITTER;
    } else {
-      unreachable("unknown queue family");
+      UNREACHABLE("unknown queue family");
    }
 
    /* Can't have both flags at the same time. */
@@ -223,7 +223,7 @@ get_usage_flag_for_cmd_buffer(const struct anv_cmd_buffer *cmd_buffer,
                         ISL_SURF_USAGE_BLITTER_SRC_BIT;
       break;
    default:
-      unreachable("Unhandled engine class");
+      UNREACHABLE("Unhandled engine class");
    }
 
    if (protected)
@@ -1003,7 +1003,7 @@ blit_image(struct anv_cmd_buffer *cmd_buffer,
       blorp_filter = BLORP_FILTER_BILINEAR;
       break;
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    }
 
    assert(anv_image_aspects_compatible(src_res->aspectMask,
@@ -1451,7 +1451,7 @@ exec_ccs_op(struct anv_cmd_buffer *cmd_buffer,
       }
       break;
    default:
-      unreachable("Unsupported CCS operation");
+      UNREACHABLE("Unsupported CCS operation");
    }
 }
 
@@ -1500,7 +1500,7 @@ exec_mcs_op(struct anv_cmd_buffer *cmd_buffer,
       break;
    case ISL_AUX_OP_FULL_RESOLVE:
    default:
-      unreachable("Unsupported MCS operation");
+      UNREACHABLE("Unsupported MCS operation");
    }
 }
 
diff --git a/src/intel/vulkan/anv_bo_sync.c b/src/intel/vulkan/anv_bo_sync.c
index af12c6d61dd84..eb3489f050865 100644
--- a/src/intel/vulkan/anv_bo_sync.c
+++ b/src/intel/vulkan/anv_bo_sync.c
@@ -153,7 +153,7 @@ anv_bo_sync_wait(struct vk_device *vk_device,
             break;
 
          default:
-            unreachable("Invalid BO sync state");
+            UNREACHABLE("Invalid BO sync state");
          }
       }
 
diff --git a/src/intel/vulkan/anv_cmd_buffer.c b/src/intel/vulkan/anv_cmd_buffer.c
index d239ae320080a..89cdfcf3c2052 100644
--- a/src/intel/vulkan/anv_cmd_buffer.c
+++ b/src/intel/vulkan/anv_cmd_buffer.c
@@ -721,7 +721,7 @@ void anv_CmdBindPipeline(
    }
 
    default:
-      unreachable("invalid bind point");
+      UNREACHABLE("invalid bind point");
       break;
    }
 
@@ -754,7 +754,7 @@ anv_cmd_buffer_get_pipeline_layout_state(struct anv_cmd_buffer *cmd_buffer,
       return &cmd_buffer->state.rt.base;
 
    default:
-      unreachable("invalid bind point");
+      UNREACHABLE("invalid bind point");
    }
 }
 
@@ -1188,7 +1188,7 @@ anv_isl_format_for_descriptor_type(const struct anv_device *device,
       return ISL_FORMAT_RAW;
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 }
 
@@ -1370,7 +1370,7 @@ anv_cmd_buffer_get_pipe_state(struct anv_cmd_buffer *cmd_buffer,
       return &cmd_buffer->state.rt.base;
       break;
    default:
-      unreachable("invalid bind point");
+      UNREACHABLE("invalid bind point");
    }
 }
 
diff --git a/src/intel/vulkan/anv_descriptor_set.c b/src/intel/vulkan/anv_descriptor_set.c
index 37b198f206bb8..81855dc4e188e 100644
--- a/src/intel/vulkan/anv_descriptor_set.c
+++ b/src/intel/vulkan/anv_descriptor_set.c
@@ -122,7 +122,7 @@ anv_indirect_descriptor_data_for_type(VkDescriptorType type)
       break;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 
    /* We also need to push SSBO address ranges so that we can use A64
@@ -188,7 +188,7 @@ anv_direct_descriptor_data_for_type(const struct anv_physical_device *device,
       break;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 
    if (layout_type == ANV_PIPELINE_DESCRIPTOR_SET_LAYOUT_TYPE_BUFFER) {
@@ -2159,7 +2159,7 @@ anv_image_view_surface_data_for_plane_layout(struct anv_image_view *image_view,
    if (desc_type == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE)
       return &image_view->planes[plane].storage.state_data;
 
-   unreachable("Invalid descriptor type");
+   UNREACHABLE("Invalid descriptor type");
 }
 
 static const uint32_t *
@@ -2213,7 +2213,7 @@ anv_descriptor_set_write_image_view(struct anv_device *device,
       break;
 
    default:
-      unreachable("invalid descriptor type");
+      UNREACHABLE("invalid descriptor type");
    }
 
    *desc = (struct anv_descriptor) {
@@ -2358,7 +2358,7 @@ anv_buffer_view_surface_data(struct anv_buffer_view *buffer_view,
    if (desc_type == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
       return &buffer_view->storage.state_data;
 
-   unreachable("Invalid descriptor type");
+   UNREACHABLE("Invalid descriptor type");
 }
 
 void
@@ -3114,6 +3114,6 @@ void anv_GetDescriptorEXT(
    }
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 }
diff --git a/src/intel/vulkan/anv_device.c b/src/intel/vulkan/anv_device.c
index 023453a670078..7f97af8bd4922 100644
--- a/src/intel/vulkan/anv_device.c
+++ b/src/intel/vulkan/anv_device.c
@@ -230,7 +230,7 @@ anv_device_setup_context_or_vm(struct anv_device *device,
    case INTEL_KMD_TYPE_XE:
       return anv_xe_device_setup_vm(device);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return VK_ERROR_UNKNOWN;
    }
 }
@@ -247,7 +247,7 @@ anv_device_destroy_context_or_vm(struct anv_device *device)
    case INTEL_KMD_TYPE_XE:
       return anv_xe_device_destroy_vm(device);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return false;
    }
 }
@@ -418,7 +418,7 @@ VkResult anv_CreateDevice(
       device->vk.check_status = anv_xe_device_check_status;
       break;
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
    }
 
    device->vk.command_buffer_ops = &anv_cmd_buffer_ops;
@@ -2048,7 +2048,7 @@ vk_time_domain_to_clockid(VkTimeDomainKHR domain)
    case VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR:
       return CLOCK_MONOTONIC;
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return CLOCK_MONOTONIC;
    }
 }
diff --git a/src/intel/vulkan/anv_formats.c b/src/intel/vulkan/anv_formats.c
index fe72f5be506b0..95c9b0abc3f45 100644
--- a/src/intel/vulkan/anv_formats.c
+++ b/src/intel/vulkan/anv_formats.c
@@ -1592,7 +1592,7 @@ anv_get_image_format_properties(
 
    switch (info->type) {
    default:
-      unreachable("bad VkImageType");
+      UNREACHABLE("bad VkImageType");
    case VK_IMAGE_TYPE_1D:
       maxExtent.width = 16384;
       maxExtent.height = 1;
@@ -1872,7 +1872,7 @@ anv_get_image_format_properties(
 
       switch (info->tiling) {
       default:
-         unreachable("bad VkImageTiling");
+         UNREACHABLE("bad VkImageTiling");
       case VK_IMAGE_TILING_LINEAR:
          /* The app can query the image's memory layout with
           * vkGetImageSubresourceLayout.
diff --git a/src/intel/vulkan/anv_gem.c b/src/intel/vulkan/anv_gem.c
index e721885cb5589..cdffa6b363737 100644
--- a/src/intel/vulkan/anv_gem.c
+++ b/src/intel/vulkan/anv_gem.c
@@ -46,7 +46,7 @@ anv_gem_wait(struct anv_device *device, uint32_t gem_handle, int64_t *timeout_ns
    case INTEL_KMD_TYPE_XE:
       return -1;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return -1;
    }
 }
@@ -61,7 +61,7 @@ anv_gem_get_tiling(struct anv_device *device, uint32_t gem_handle)
    case INTEL_KMD_TYPE_XE:
       return -1;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return -1;
    }
 }
@@ -76,7 +76,7 @@ anv_gem_set_tiling(struct anv_device *device,
    case INTEL_KMD_TYPE_XE:
       return 0;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return -1;
    }
 }
@@ -125,7 +125,7 @@ anv_gem_import_bo_alloc_flags_to_bo_flags(struct anv_device *device,
       *bo_flags = device->kmd_backend->bo_alloc_flags_to_bo_flags(device, alloc_flags);
       return VK_SUCCESS;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       return VK_ERROR_UNKNOWN;
    }
 }
diff --git a/src/intel/vulkan/anv_gem_stubs.c b/src/intel/vulkan/anv_gem_stubs.c
index 5b2c630618c5f..8879a4bbf6837 100644
--- a/src/intel/vulkan/anv_gem_stubs.c
+++ b/src/intel/vulkan/anv_gem_stubs.c
@@ -124,13 +124,13 @@ anv_gem_get_tiling(struct anv_device *device, uint32_t gem_handle)
 int
 anv_gem_handle_to_fd(struct anv_device *device, uint32_t gem_handle)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
 
 uint32_t
 anv_gem_fd_to_handle(struct anv_device *device, int fd)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
 
 VkResult
diff --git a/src/intel/vulkan/anv_image.c b/src/intel/vulkan/anv_image.c
index 14f4b47858fee..97734a521c9b0 100644
--- a/src/intel/vulkan/anv_image.c
+++ b/src/intel/vulkan/anv_image.c
@@ -118,7 +118,7 @@ image_binding_grow(const struct anv_device *device,
    switch (binding) {
    case ANV_IMAGE_MEMORY_BINDING_MAIN:
       /* The caller must not pre-translate BINDING_PLANE_i to BINDING_MAIN. */
-      unreachable("ANV_IMAGE_MEMORY_BINDING_MAIN");
+      UNREACHABLE("ANV_IMAGE_MEMORY_BINDING_MAIN");
    case ANV_IMAGE_MEMORY_BINDING_PLANE_0:
    case ANV_IMAGE_MEMORY_BINDING_PLANE_1:
    case ANV_IMAGE_MEMORY_BINDING_PLANE_2:
@@ -129,7 +129,7 @@ image_binding_grow(const struct anv_device *device,
       assert(offset == ANV_OFFSET_IMPLICIT);
       break;
    case ANV_IMAGE_MEMORY_BINDING_END:
-      unreachable("ANV_IMAGE_MEMORY_BINDING_END");
+      UNREACHABLE("ANV_IMAGE_MEMORY_BINDING_END");
    }
 
    struct anv_image_memory_range *container =
@@ -293,7 +293,7 @@ anv_image_choose_isl_surf_usage(struct anv_physical_device *device,
    case VK_IMAGE_ASPECT_PLANE_2_BIT:
       break;
    default:
-      unreachable("bad VkImageAspect");
+      UNREACHABLE("bad VkImageAspect");
    }
 
    if (vk_usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) {
@@ -334,7 +334,7 @@ choose_isl_tiling_flags(const struct intel_device_info *devinfo,
 
    switch (base_info->tiling) {
    default:
-      unreachable("bad VkImageTiling");
+      UNREACHABLE("bad VkImageTiling");
    case VK_IMAGE_TILING_OPTIMAL:
       flags = ISL_TILING_ANY_MASK;
       break;
@@ -2948,7 +2948,7 @@ anv_get_image_subresource_layout(struct anv_device *device,
          mem_plane = 2;
          break;
       default:
-         unreachable("bad VkImageAspectFlags");
+         UNREACHABLE("bad VkImageAspectFlags");
       }
 
       if (isl_drm_modifier_plane_is_clear_color(image->vk.drm_format_mod,
@@ -3182,7 +3182,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
    switch (layout) {
    /* Invalid layouts */
    case VK_IMAGE_LAYOUT_MAX_ENUM:
-      unreachable("Invalid image layout.");
+      UNREACHABLE("Invalid image layout.");
 
    /* Undefined layouts
     *
@@ -3236,7 +3236,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
       case ISL_AUX_STATE_COMPRESSED_NO_CLEAR:
          return ISL_AUX_STATE_COMPRESSED_NO_CLEAR;
       default:
-         unreachable("unexpected isl_aux_state");
+         UNREACHABLE("unexpected isl_aux_state");
       }
    }
 
@@ -3309,7 +3309,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
          break;
 
       default:
-         unreachable("Unsupported aux usage");
+         UNREACHABLE("Unsupported aux usage");
       }
    }
 
@@ -3361,7 +3361,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
       return ISL_AUX_STATE_COMPRESSED_NO_CLEAR;
 
    default:
-      unreachable("Unsupported aux usage");
+      UNREACHABLE("Unsupported aux usage");
    }
 }
 
@@ -3400,7 +3400,7 @@ anv_layout_to_aux_usage(const struct intel_device_info * const devinfo,
 
    switch (aux_state) {
    case ISL_AUX_STATE_CLEAR:
-      unreachable("We never use this state");
+      UNREACHABLE("We never use this state");
 
    case ISL_AUX_STATE_PARTIAL_CLEAR:
       assert(image->vk.aspects & VK_IMAGE_ASPECT_ANY_COLOR_BIT_ANV);
@@ -3434,7 +3434,7 @@ anv_layout_to_aux_usage(const struct intel_device_info * const devinfo,
       return ISL_AUX_USAGE_NONE;
    }
 
-   unreachable("Invalid isl_aux_state");
+   UNREACHABLE("Invalid isl_aux_state");
 }
 
 /**
@@ -3487,7 +3487,7 @@ anv_layout_to_fast_clear_type(const struct intel_device_info * const devinfo,
 
    switch (aux_state) {
    case ISL_AUX_STATE_CLEAR:
-      unreachable("We never use this state");
+      UNREACHABLE("We never use this state");
 
    case ISL_AUX_STATE_PARTIAL_CLEAR:
    case ISL_AUX_STATE_COMPRESSED_CLEAR:
@@ -3536,7 +3536,7 @@ anv_layout_to_fast_clear_type(const struct intel_device_info * const devinfo,
       return ANV_FAST_CLEAR_NONE;
    }
 
-   unreachable("Invalid isl_aux_state");
+   UNREACHABLE("Invalid isl_aux_state");
 }
 
 bool
diff --git a/src/intel/vulkan/anv_image_view.c b/src/intel/vulkan/anv_image_view.c
index ee51bcb0d7e7f..a3eda58f34932 100644
--- a/src/intel/vulkan/anv_image_view.c
+++ b/src/intel/vulkan/anv_image_view.c
@@ -16,7 +16,7 @@ remap_swizzle(VkComponentSwizzle swizzle,
    case VK_COMPONENT_SWIZZLE_B:     return format_swizzle.b;
    case VK_COMPONENT_SWIZZLE_A:     return format_swizzle.a;
    default:
-      unreachable("Invalid swizzle");
+      UNREACHABLE("Invalid swizzle");
    }
 }
 
diff --git a/src/intel/vulkan/anv_nir_apply_pipeline_layout.c b/src/intel/vulkan/anv_nir_apply_pipeline_layout.c
index d856ad3f81289..6ce5765de3d1e 100644
--- a/src/intel/vulkan/anv_nir_apply_pipeline_layout.c
+++ b/src/intel/vulkan/anv_nir_apply_pipeline_layout.c
@@ -122,7 +122,7 @@ addr_format_for_desc_type(VkDescriptorType desc_type,
       return state->desc_addr_format;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 }
 
@@ -409,7 +409,7 @@ build_load_descriptor_mem(nir_builder *b,
    }
 
    default:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 }
 
@@ -675,7 +675,7 @@ build_res_index(nir_builder *b,
       break;
 
    default:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 
    assert(bind_layout->dynamic_offset_index < MAX_DYNAMIC_BUFFERS);
@@ -829,7 +829,7 @@ build_desc_addr_for_res_index(nir_builder *b,
          return nir_vec2(b, res.set_idx, desc_offset);
 
       default:
-         unreachable("Unhandled address format");
+         UNREACHABLE("Unhandled address format");
       }
    }
 
@@ -839,7 +839,7 @@ build_desc_addr_for_res_index(nir_builder *b,
       return nir_vec2(b, res.set_idx, desc_offset);
 
    default:
-      unreachable("Unhandled address format");
+      UNREACHABLE("Unhandled address format");
    }
 }
 
@@ -890,7 +890,7 @@ build_desc_addr_for_binding(nir_builder *b,
    }
 
    default:
-      unreachable("Unhandled address format");
+      UNREACHABLE("Unhandled address format");
    }
 }
 
@@ -1736,7 +1736,7 @@ lower_image_load_intel_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin,
             1, 32, state);
          break;
       default:
-         unreachable("Invalid surface parameter");
+         UNREACHABLE("Invalid surface parameter");
       }
    } else {
       const struct intel_device_info *devinfo = &state->pdevice->info;
@@ -1801,7 +1801,7 @@ lower_image_load_intel_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin,
          break;
       }
       default:
-         unreachable("Invalid surface parameter");
+         UNREACHABLE("Invalid surface parameter");
       }
    }
 
diff --git a/src/intel/vulkan/anv_perf.c b/src/intel/vulkan/anv_perf.c
index 2dfef2949da5e..a3cee161fb206 100644
--- a/src/intel/vulkan/anv_perf.c
+++ b/src/intel/vulkan/anv_perf.c
@@ -76,7 +76,7 @@ anv_physical_device_init_perf(struct anv_physical_device *device, int fd)
          device->n_perf_query_commands += field->size / 4;
          break;
       default:
-         unreachable("Unhandled register type");
+         UNREACHABLE("Unhandled register type");
       }
    }
    device->n_perf_query_commands *= 2; /* Begin & End */
@@ -122,7 +122,7 @@ anv_device_perf_get_queue_context_or_exec_queue_id(struct anv_queue *queue)
       context_or_exec_queue_id = queue->exec_queue_id;
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       context_or_exec_queue_id = 0;
    }
 
@@ -493,12 +493,12 @@ anv_perf_write_pass_results(struct intel_perf_config *perf,
             break;
          default:
             /* So far we aren't using uint32, double or bool32... */
-            unreachable("unexpected counter data type");
+            UNREACHABLE("unexpected counter data type");
          }
          break;
 
       default:
-         unreachable("invalid query type");
+         UNREACHABLE("invalid query type");
       }
 
       /* The Vulkan extension only has nanoseconds as a unit */
diff --git a/src/intel/vulkan/anv_physical_device.c b/src/intel/vulkan/anv_physical_device.c
index acddc6e1b9012..1bdae78039473 100644
--- a/src/intel/vulkan/anv_physical_device.c
+++ b/src/intel/vulkan/anv_physical_device.c
@@ -2515,7 +2515,7 @@ anv_physical_device_get_parameters(struct anv_physical_device *device)
    case INTEL_KMD_TYPE_XE:
       return anv_xe_physical_device_get_parameters(device);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return VK_ERROR_UNKNOWN;
    }
 }
@@ -3184,7 +3184,7 @@ convert_component_type(enum intel_cooperative_matrix_component_type t)
    case INTEL_CMAT_UINT8:    return VK_COMPONENT_TYPE_UINT8_KHR;
    case INTEL_CMAT_BFLOAT16: return VK_COMPONENT_TYPE_BFLOAT16_KHR;
    }
-   unreachable("invalid cooperative matrix component type in configuration");
+   UNREACHABLE("invalid cooperative matrix component type in configuration");
 }
 
 static VkScopeKHR
@@ -3193,7 +3193,7 @@ convert_scope(enum intel_cmat_scope scope)
    switch (scope) {
    case INTEL_CMAT_SCOPE_SUBGROUP: return VK_SCOPE_SUBGROUP_KHR;
    default:
-      unreachable("invalid cooperative matrix scope in configuration");
+      UNREACHABLE("invalid cooperative matrix scope in configuration");
    }
 }
 
diff --git a/src/intel/vulkan/anv_pipeline.c b/src/intel/vulkan/anv_pipeline.c
index 64378bf68a771..2c265901791d6 100644
--- a/src/intel/vulkan/anv_pipeline.c
+++ b/src/intel/vulkan/anv_pipeline.c
@@ -225,7 +225,7 @@ void anv_DestroyPipeline(
    }
 
    default:
-      unreachable("invalid pipeline type");
+      UNREACHABLE("invalid pipeline type");
    }
 
    anv_pipeline_finish(pipeline, device);
@@ -1685,7 +1685,7 @@ anv_pipeline_add_executable(struct anv_pipeline *pipeline,
                break;
 
             case ANV_DESCRIPTOR_SET_COLOR_ATTACHMENTS:
-               unreachable("Color attachments can't be pushed");
+               UNREACHABLE("Color attachments can't be pushed");
 
             default:
                fprintf(stream, "UBO (set=%d binding=%d start=%dB)",
@@ -1899,7 +1899,7 @@ anv_graphics_pipeline_init_keys(struct anv_graphics_base_pipeline *pipeline,
       }
 
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
 
       stages[s].feedback.duration += os_time_get_nano() - stage_start;
@@ -2374,7 +2374,7 @@ anv_graphics_pipeline_compile(struct anv_graphics_base_pipeline *pipeline,
          anv_pipeline_link_fs(compiler, stage, state->rp);
          break;
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
 
       next_stage = stage;
@@ -2519,7 +2519,7 @@ anv_graphics_pipeline_compile(struct anv_graphics_base_pipeline *pipeline,
                                  &error_str);
          break;
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
       if (stage->code == NULL) {
          if (error_str)
@@ -3762,14 +3762,14 @@ anv_pipeline_compile_ray_tracing(struct anv_ray_tracing_pipeline *pipeline,
          break;
 
       case MESA_SHADER_INTERSECTION:
-         unreachable("These are handled later");
+         UNREACHABLE("These are handled later");
 
       case MESA_SHADER_CALLABLE:
          brw_nir_lower_callable(nir, devinfo);
          break;
 
       default:
-         unreachable("Invalid ray-tracing shader stage");
+         UNREACHABLE("Invalid ray-tracing shader stage");
       }
 
       result = compile_upload_rt_shader(pipeline, cache, nir, &stages[i],
@@ -3839,7 +3839,7 @@ anv_pipeline_compile_ray_tracing(struct anv_ray_tracing_pipeline *pipeline,
       }
 
       default:
-         unreachable("Invalid ray tracing shader group type");
+         UNREACHABLE("Invalid ray tracing shader group type");
       }
    }
 
@@ -4173,7 +4173,7 @@ anv_ray_tracing_pipeline_create(
          break;
 
       default:
-         unreachable("Invalid ray-tracing shader group type");
+         UNREACHABLE("Invalid ray-tracing shader group type");
       }
    }
 
@@ -4384,7 +4384,7 @@ VkResult anv_GetPipelineExecutableStatisticsKHR(
       break;
    }
    default:
-      unreachable("invalid pipeline type");
+      UNREACHABLE("invalid pipeline type");
    }
 
    vk_outarray_append_typed(VkPipelineExecutableStatisticKHR, &out, stat) {
@@ -4623,7 +4623,7 @@ anv_GetRayTracingCaptureReplayShaderGroupHandlesKHR(
     void*                                       pData)
 {
    ANV_FROM_HANDLE(anv_device, device, _device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vk_error(device, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -4661,7 +4661,7 @@ anv_GetRayTracingShaderGroupStackSizeKHR(
       break;
 
    default:
-      unreachable("Invalid VkShaderGroupShader enum");
+      UNREACHABLE("Invalid VkShaderGroupShader enum");
    }
 
    if (bin == NULL)
diff --git a/src/intel/vulkan/anv_private.h b/src/intel/vulkan/anv_private.h
index bdc1dc67a013e..214a8816a2f59 100644
--- a/src/intel/vulkan/anv_private.h
+++ b/src/intel/vulkan/anv_private.h
@@ -2244,7 +2244,7 @@ anv_get_first_render_queue_index(struct anv_physical_device *pdevice)
       }
    }
 
-   unreachable("Graphics capable queue family not found");
+   UNREACHABLE("Graphics capable queue family not found");
 }
 
 static inline struct anv_state
@@ -6773,7 +6773,7 @@ VK_DEFINE_NONDISP_HANDLE_CASTS(anv_video_session_params, vk.base,
       genX_thing = &gfx30_##thing;              \
       break;                                    \
    default:                                     \
-      unreachable("Unknown hardware generation"); \
+      UNREACHABLE("Unknown hardware generation"); \
    }                                            \
    genX_thing;                                  \
 })
diff --git a/src/intel/vulkan/anv_queue.c b/src/intel/vulkan/anv_queue.c
index 2ce93f42fc0c9..42c3b57572b08 100644
--- a/src/intel/vulkan/anv_queue.c
+++ b/src/intel/vulkan/anv_queue.c
@@ -43,7 +43,7 @@ anv_create_engine(struct anv_device *device,
    case INTEL_KMD_TYPE_XE:
       return anv_xe_create_engine(device, queue, pCreateInfo);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return VK_ERROR_UNKNOWN;
    }
 }
@@ -60,7 +60,7 @@ anv_destroy_engine(struct anv_queue *queue)
       anv_xe_destroy_engine(device, queue);
       break;
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
    }
 }
 
@@ -163,7 +163,7 @@ anv_QueueWaitIdle(VkQueue _queue)
    case INTEL_KMD_TYPE_I915:
       return vk_common_QueueWaitIdle(_queue);
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
    }
 
    return VK_SUCCESS;
diff --git a/src/intel/vulkan/anv_rmv.c b/src/intel/vulkan/anv_rmv.c
index 80ccda74affc7..9b9173fd7aa32 100644
--- a/src/intel/vulkan/anv_rmv.c
+++ b/src/intel/vulkan/anv_rmv.c
@@ -72,7 +72,7 @@ fill_memory_info(const struct anv_physical_device *device,
       out_info->size = device->memory.heaps[1].size;
       break;
    default:
-      unreachable("invalid memory index");
+      UNREACHABLE("invalid memory index");
    }
 }
 
diff --git a/src/intel/vulkan/anv_slab_bo.c b/src/intel/vulkan/anv_slab_bo.c
index 1aa631bbc0f78..8ca9a6a15c09a 100644
--- a/src/intel/vulkan/anv_slab_bo.c
+++ b/src/intel/vulkan/anv_slab_bo.c
@@ -102,7 +102,7 @@ get_slabs(struct anv_device *device, uint64_t size)
          return slabs;
    }
 
-   unreachable("should have found a valid slab for this size");
+   UNREACHABLE("should have found a valid slab for this size");
    return NULL;
 }
 
@@ -258,7 +258,7 @@ anv_slab_alloc(void *priv,
       alloc_flags |= ANV_BO_ALLOC_DESCRIPTOR_POOL_FLAGS;
       break;
    default:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
       return NULL;
    }
 
diff --git a/src/intel/vulkan/anv_util.c b/src/intel/vulkan/anv_util.c
index 9c6977e2b06c6..f40725a1c2f01 100644
--- a/src/intel/vulkan/anv_util.c
+++ b/src/intel/vulkan/anv_util.c
@@ -191,7 +191,7 @@ anv_gfx_state_bit_to_str(enum anv_gfx_state_bits state)
       NAME(TCS_INPUT_VERTICES);
       NAME(COARSE_STATE);
       NAME(MESH_PROVOKING_VERTEX);
-   default: unreachable("invalid state");
+   default: UNREACHABLE("invalid state");
    }
 }
 
@@ -262,7 +262,7 @@ create_bvh_dump_file(struct anv_bvh_dump *bvh)
       dump_sub_directory = "BVH_IR_AS";
       break;
    default:
-      unreachable("invalid dump type");
+      UNREACHABLE("invalid dump type");
    }
 
    create_directory(dump_directory, dump_sub_directory);
diff --git a/src/intel/vulkan/anv_video.c b/src/intel/vulkan/anv_video.c
index 74db53397d368..9d4ff8172cc11 100644
--- a/src/intel/vulkan/anv_video.c
+++ b/src/intel/vulkan/anv_video.c
@@ -458,7 +458,7 @@ get_h264_video_mem_size(struct anv_video_session *vid, uint32_t mem_idx)
    case ANV_VID_MEM_H264_MPR_ROW_SCRATCH:
       return width_in_mb * 64 * 2;
    default:
-      unreachable("unknown memory");
+      UNREACHABLE("unknown memory");
    }
 }
 
@@ -510,7 +510,7 @@ get_h265_video_mem_size(struct anv_video_session *vid, uint32_t mem_idx)
       return size;
    }
    default:
-      unreachable("unknown memory");
+      UNREACHABLE("unknown memory");
    }
 
    return size << 6;
@@ -561,7 +561,7 @@ get_vp9_video_mem_size(struct anv_video_session *vid, uint32_t mem_idx)
       size = (width_in_ctb * height_in_ctb * 9);
       break;
    default:
-      unreachable("unknown memory");
+      UNREACHABLE("unknown memory");
    }
 
    return size << 6;
@@ -892,7 +892,7 @@ anv_GetVideoSessionMemoryRequirementsKHR(VkDevice _device,
                                      memory_types);
       break;
    default:
-      unreachable("unknown codec");
+      UNREACHABLE("unknown codec");
    }
 
    return VK_SUCCESS;
@@ -940,7 +940,7 @@ anv_BindVideoSessionMemoryKHR(VkDevice _device,
       }
       break;
    default:
-      unreachable("unknown codec");
+      UNREACHABLE("unknown codec");
    }
    return VK_SUCCESS;
 }
@@ -1078,7 +1078,7 @@ init_all_av1_entry(uint16_t *dst_ptr, int index)
       INIT_TABLE(av1_cdf_intra_coeffs_3);
       break;
    default:
-      unreachable("illegal av1 entry\n");
+      UNREACHABLE("illegal av1 entry\n");
    }
    INIT_TABLE(av1_cdf_intra_part2);
    INIT_TABLE(av1_cdf_inter);
diff --git a/src/intel/vulkan/genX_acceleration_structure.c b/src/intel/vulkan/genX_acceleration_structure.c
index e8bde0991f8b5..f19c040bf65c9 100644
--- a/src/intel/vulkan/genX_acceleration_structure.c
+++ b/src/intel/vulkan/genX_acceleration_structure.c
@@ -78,7 +78,7 @@ begin_debug_marker(VkCommandBuffer commandBuffer,
       break;
    }
    default:
-      unreachable("Invalid build step");
+      UNREACHABLE("Invalid build step");
    }
 }
 
@@ -113,7 +113,7 @@ end_debug_marker(VkCommandBuffer commandBuffer)
       trace_intel_end_as_encode(&cmd_buffer->trace, cmd_buffer->state.rt.num_leaves, cmd_buffer->state.rt.num_ir_nodes);
       break;
    default:
-      unreachable("Invalid build step");
+      UNREACHABLE("Invalid build step");
    }
 }
 
@@ -206,7 +206,7 @@ debug_record_as_to_bvh_dump(struct anv_cmd_buffer *cmd_buffer,
          leaf_total_size = sizeof(struct vk_ir_aabb_node) * leaf_count;
          break;
       default:
-         unreachable("invalid geometry type");
+         UNREACHABLE("invalid geometry type");
       }
 
       add_bvh_dump(cmd_buffer, intermediate_as_addr, internal_node_total_size +
@@ -340,7 +340,7 @@ get_bvh_layout(VkGeometryTypeKHR geometry_type, uint32_t leaf_count,
       offset += leaf_count * ANV_RT_INSTANCE_LEAF_SIZE;
       break;
    default:
-      unreachable("Unknown VkGeometryTypeKHR");
+      UNREACHABLE("Unknown VkGeometryTypeKHR");
    }
 
    layout->size = offset;
diff --git a/src/intel/vulkan/genX_blorp_exec.c b/src/intel/vulkan/genX_blorp_exec.c
index 965a54ed6df31..dbaaf8ecb1195 100644
--- a/src/intel/vulkan/genX_blorp_exec.c
+++ b/src/intel/vulkan/genX_blorp_exec.c
@@ -516,7 +516,7 @@ get_color_aux_op(const struct blorp_params *params)
       return ISL_AUX_OP_NONE;
    }
 
-   unreachable("Invalid value in params->op");
+   UNREACHABLE("Invalid value in params->op");
 }
 
 void
diff --git a/src/intel/vulkan/genX_cmd_buffer.c b/src/intel/vulkan/genX_cmd_buffer.c
index f07ea254641ab..c1b5aa16d0c31 100644
--- a/src/intel/vulkan/genX_cmd_buffer.c
+++ b/src/intel/vulkan/genX_cmd_buffer.c
@@ -216,7 +216,7 @@ fill_state_base_addr(struct anv_cmd_buffer *cmd_buffer,
       sba->BindlessSurfaceStateMOCS = mocs;
       sba->BindlessSurfaceStateBaseAddressModifyEnable = true;
 #else
-      unreachable("Direct descriptor not supported");
+      UNREACHABLE("Direct descriptor not supported");
 #endif
    } else {
       sba->BindlessSurfaceStateBaseAddress =
@@ -2069,7 +2069,7 @@ emit_indirect_descriptor_binding_table_entry(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 
    return surface_state.offset;
@@ -2111,7 +2111,7 @@ emit_direct_descriptor_binding_table_entry(struct anv_cmd_buffer *cmd_buffer,
    }
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 
    return desc_offset;
@@ -2444,7 +2444,7 @@ emit_pipe_control(struct anv_batch *batch,
 {
    if ((batch->engine_class == INTEL_ENGINE_CLASS_COPY) ||
        (batch->engine_class == INTEL_ENGINE_CLASS_VIDEO))
-      unreachable("Trying to emit unsupported PIPE_CONTROL command.");
+      UNREACHABLE("Trying to emit unsupported PIPE_CONTROL command.");
 
    const bool trace_flush =
       (bits & (ANV_PIPE_FLUSH_BITS |
@@ -3155,7 +3155,7 @@ genX(cmd_buffer_set_protected_memory)(struct anv_cmd_buffer *cmd_buffer,
          pc.ProtectedMemoryDisable = true;
    }
 #else
-   unreachable("Protected content not supported");
+   UNREACHABLE("Protected content not supported");
 #endif
 }
 
@@ -4691,7 +4691,7 @@ cmd_buffer_barrier(struct anv_cmd_buffer *cmd_buffer,
    }
 
    default:
-      unreachable("Invalid engine class");
+      UNREACHABLE("Invalid engine class");
    }
 }
 
@@ -6200,7 +6200,7 @@ void genX(CmdSetEvent2)(
    }
 
    default:
-      unreachable("Invalid engine class");
+      UNREACHABLE("Invalid engine class");
    }
 }
 
@@ -6246,7 +6246,7 @@ void genX(CmdResetEvent2)(
    }
 
    default:
-      unreachable("Invalid engine class");
+      UNREACHABLE("Invalid engine class");
    }
 }
 
@@ -6303,7 +6303,7 @@ VkResult genX(CmdSetPerformanceOverrideINTEL)(
       break;
 
    default:
-      unreachable("Invalid override");
+      UNREACHABLE("Invalid override");
    }
 
    return VK_SUCCESS;
@@ -6416,7 +6416,7 @@ void genX(cmd_emit_timestamp)(struct anv_batch *batch,
       break;
 
    default:
-      unreachable("invalid");
+      UNREACHABLE("invalid");
    }
 }
 
@@ -6505,7 +6505,7 @@ genX(batch_emit_fast_color_dummy_blit)(struct anv_batch *batch,
       blt.DestinationTiling = XY_TILE_LINEAR;
    }
 #else
-   unreachable("Not implemented");
+   UNREACHABLE("Not implemented");
 #endif
 }
 
@@ -6587,7 +6587,7 @@ genX(cmd_buffer_begin_companion_rcs_syncpoint)(
 
    return syncpoint;
 #else
-   unreachable("Not implemented");
+   UNREACHABLE("Not implemented");
 #endif
 }
 
@@ -6616,7 +6616,7 @@ genX(cmd_buffer_end_companion_rcs_syncpoint)(struct anv_cmd_buffer *cmd_buffer,
                    &cmd_buffer->companion_rcs_cmd_buffer->batch);
    mi_store(&b, mi_mem32(xcs_wait_addr), mi_imm(0x1));
 #else
-   unreachable("Not implemented");
+   UNREACHABLE("Not implemented");
 #endif
 }
 
@@ -6719,7 +6719,7 @@ genX(write_trtt_entries)(struct anv_async_submit *submit,
                                 ANV_PIPE_CS_STALL_BIT |
                                 ANV_PIPE_TLB_INVALIDATE_BIT);
 #else
-   unreachable("Not implemented");
+   UNREACHABLE("Not implemented");
 #endif
 }
 
diff --git a/src/intel/vulkan/genX_cmd_compute.c b/src/intel/vulkan/genX_cmd_compute.c
index 742390e25ed27..18b3a2478c028 100644
--- a/src/intel/vulkan/genX_cmd_compute.c
+++ b/src/intel/vulkan/genX_cmd_compute.c
@@ -73,7 +73,7 @@ genX(cmd_buffer_ensure_cfe_state)(struct anv_cmd_buffer *cmd_buffer,
       case 512:  cfe.StackIDControl = StackIDs512;  break;
       case 1024: cfe.StackIDControl = StackIDs1024; break;
       case 2048: cfe.StackIDControl = StackIDs2048; break;
-      default:   unreachable("invalid stack_ids value");
+      default:   UNREACHABLE("invalid stack_ids value");
       }
 
 #if INTEL_WA_14021821874_GFX_VER || INTEL_WA_14018813551_GFX_VER
@@ -95,7 +95,7 @@ genX(cmd_buffer_ensure_cfe_state)(struct anv_cmd_buffer *cmd_buffer,
 
    comp_state->scratch_size = total_scratch;
 #else
-   unreachable("Invalid call");
+   UNREACHABLE("Invalid call");
 #endif
 }
 
@@ -933,7 +933,7 @@ genX(cmd_buffer_ray_query_globals)(struct anv_cmd_buffer *cmd_buffer)
 
    return anv_cmd_buffer_temporary_state_address(cmd_buffer, state);
 #else
-   unreachable("Not supported");
+   UNREACHABLE("Not supported");
 #endif
 }
 
diff --git a/src/intel/vulkan/genX_cmd_draw.c b/src/intel/vulkan/genX_cmd_draw.c
index 5145da9105fae..98efdeb3500ea 100644
--- a/src/intel/vulkan/genX_cmd_draw.c
+++ b/src/intel/vulkan/genX_cmd_draw.c
@@ -1834,10 +1834,10 @@ static inline uint32_t xi_argument_format_for_vk_cmd(enum vk_cmd_type cmd)
       case VK_CMD_DRAW_MESH_TASKS_INDIRECT_COUNT_EXT:
          return XI_MESH_3D;
       default:
-         unreachable("unhandled cmd type");
+         UNREACHABLE("unhandled cmd type");
    }
 #else
-   unreachable("unsupported GFX VER");
+   UNREACHABLE("unsupported GFX VER");
 #endif
 }
 
@@ -1864,7 +1864,7 @@ cmd_buffer_set_indirect_stride(struct anv_cmd_buffer *cmd_buffer,
       data_stride = sizeof(VkDrawMeshTasksIndirectCommandEXT);
       break;
    default:
-      unreachable("unhandled cmd type");
+      UNREACHABLE("unhandled cmd type");
    }
 
    bool aligned = stride == data_stride;
diff --git a/src/intel/vulkan/genX_cmd_video_enc.c b/src/intel/vulkan/genX_cmd_video_enc.c
index ab71ae9ddbc4c..86050c8ff1d8f 100644
--- a/src/intel/vulkan/genX_cmd_video_enc.c
+++ b/src/intel/vulkan/genX_cmd_video_enc.c
@@ -2435,7 +2435,7 @@ handle_inline_query_end(struct anv_cmd_buffer *cmd_buffer,
    } else if (pool->codec & VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR) {
       reg_addr = HCP_BITSTREAM_BYTECOUNT_FRAME_REG;
    } else {
-      unreachable("Invalid codec operation");
+      UNREACHABLE("Invalid codec operation");
    }
 
    mi_store(&b, mi_mem64(anv_address_add(query_addr, 8)), mi_reg32(reg_addr));
diff --git a/src/intel/vulkan/genX_gfx_state.c b/src/intel/vulkan/genX_gfx_state.c
index c9fa96c645bf0..5c61b96ebab46 100644
--- a/src/intel/vulkan/genX_gfx_state.c
+++ b/src/intel/vulkan/genX_gfx_state.c
@@ -150,7 +150,7 @@ static uint32_t vk_to_intel_index_type(VkIndexType type)
    case VK_INDEX_TYPE_UINT32:
       return INDEX_DWORD;
    default:
-      unreachable("invalid index type");
+      UNREACHABLE("invalid index type");
    }
 }
 
@@ -253,7 +253,7 @@ get_cps_size(uint32_t size)
    case 4:
       return CPSIZE_4;
    default:
-      unreachable("Invalid size");
+      UNREACHABLE("Invalid size");
    }
 }
 
@@ -450,7 +450,7 @@ anv_raster_polygon_mode(const struct anv_graphics_pipeline *pipeline,
       case MESA_PRIM_TRIANGLES:
          return polygon_mode;
       default:
-         unreachable("invalid primitive type for mesh");
+         UNREACHABLE("invalid primitive type for mesh");
       }
    } else if (anv_pipeline_has_stage(pipeline, MESA_SHADER_GEOMETRY)) {
       switch (get_gs_prog_data(pipeline)->output_topology) {
@@ -471,7 +471,7 @@ anv_raster_polygon_mode(const struct anv_graphics_pipeline *pipeline,
       case _3DPRIM_POLYGON:
          return polygon_mode;
       }
-      unreachable("Unsupported GS output topology");
+      UNREACHABLE("Unsupported GS output topology");
    } else if (anv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_EVAL)) {
       switch (get_tes_prog_data(pipeline)->output_topology) {
       case INTEL_TESS_OUTPUT_TOPOLOGY_POINT:
@@ -484,7 +484,7 @@ anv_raster_polygon_mode(const struct anv_graphics_pipeline *pipeline,
       case INTEL_TESS_OUTPUT_TOPOLOGY_TRI_CCW:
          return polygon_mode;
       }
-      unreachable("Unsupported TCS output topology");
+      UNREACHABLE("Unsupported TCS output topology");
    } else {
       switch (primitive_topology) {
       case VK_PRIMITIVE_TOPOLOGY_POINT_LIST:
@@ -504,7 +504,7 @@ anv_raster_polygon_mode(const struct anv_graphics_pipeline *pipeline,
          return polygon_mode;
 
       default:
-         unreachable("Unsupported primitive topology");
+         UNREACHABLE("Unsupported primitive topology");
       }
    }
 }
@@ -568,7 +568,7 @@ anv_rasterization_mode(VkPolygonMode raster_mode,
          break;
 
       default:
-         unreachable("Unsupported line rasterization mode");
+         UNREACHABLE("Unsupported line rasterization mode");
       }
    } else {
       *api_mode = DX101;
@@ -749,7 +749,7 @@ calculate_tile_dimensions(const struct anv_device *device,
       SET(bit, cmd.TriangleFanProvokingVertexSelect,       2);         \
       break;                                                           \
    default:                                                            \
-      unreachable("Invalid provoking vertex mode");                    \
+      UNREACHABLE("Invalid provoking vertex mode");                    \
    }                                                                   \
 
 #define SETUP_PROVOKING_VERTEX_FSB(bit, cmd, mode)                  \
@@ -767,7 +767,7 @@ calculate_tile_dimensions(const struct anv_device *device,
       SET(bit, cmd.TriangleStripOddProvokingVertexSelect,  1);      \
       break;                                                        \
    default:                                                         \
-      unreachable("Invalid provoking vertex mode");                 \
+      UNREACHABLE("Invalid provoking vertex mode");                 \
    }                                                                \
 
 ALWAYS_INLINE static void
@@ -1034,7 +1034,7 @@ update_provoking_vertex(struct anv_gfx_dynamic_state *hw_state,
       break;
 
    default:
-      unreachable("Invalid provoking vertex mode");
+      UNREACHABLE("Invalid provoking vertex mode");
    }
 }
 
@@ -1894,7 +1894,7 @@ compute_mesh_provoking_vertex(const struct brw_mesh_prog_data *mesh_prog_data,
    case MESA_PRIM_QUAD_STRIP:
       return dyn->rs.provoking_vertex == VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT ? 3 : 0;
    default:
-      unreachable("invalid mesh primitive type");
+      UNREACHABLE("invalid mesh primitive type");
    }
 }
 #endif
diff --git a/src/intel/vulkan/genX_gpu_memcpy.c b/src/intel/vulkan/genX_gpu_memcpy.c
index 7848df273c7b4..0ab1d32213277 100644
--- a/src/intel/vulkan/genX_gpu_memcpy.c
+++ b/src/intel/vulkan/genX_gpu_memcpy.c
@@ -164,7 +164,7 @@ emit_so_memcpy(struct anv_memcpy_state *state,
    case 8:  format = ISL_FORMAT_R32G32_UINT;       break;
    case 16: format = ISL_FORMAT_R32G32B32A32_UINT; break;
    default:
-      unreachable("Invalid size");
+      UNREACHABLE("Invalid size");
    }
 
    uint32_t *dw;
diff --git a/src/intel/vulkan/genX_init_state.c b/src/intel/vulkan/genX_init_state.c
index 6075568991be5..534f5c7931335 100644
--- a/src/intel/vulkan/genX_init_state.c
+++ b/src/intel/vulkan/genX_init_state.c
@@ -106,7 +106,7 @@ genX(emit_slice_hashing_state)(struct anv_device *device,
       else if (ppipes_of[2] == 1 && ppipes_of[1] == 1 && ppipes_of[0] == 1)
          intel_compute_pixel_hash_table_3way(8, 16, 3, 3, 0, p.ThreeWayTableEntry[0]);
       else
-         unreachable("Illegal fusing.");
+         UNREACHABLE("Illegal fusing.");
    }
 
    anv_batch_emit(batch, GENX(3DSTATE_3D_MODE), p) {
@@ -1067,7 +1067,7 @@ genX(emit_l3_config)(struct anv_batch *batch,
 #if GFX_VER >= 12
          l3cr.L3FullWayAllocationEnable = true;
 #else
-         unreachable("Invalid L3$ config");
+         UNREACHABLE("Invalid L3$ config");
 #endif
       } else {
 #if GFX_VER < 11
@@ -1159,7 +1159,7 @@ genX(emit_sample_pattern)(struct anv_batch *batch,
             }
             break;
          default:
-            unreachable("Invalid sample count");
+            UNREACHABLE("Invalid sample count");
          }
       }
    }
@@ -1170,7 +1170,7 @@ vk_to_intel_tex_filter(VkFilter filter, bool anisotropyEnable)
 {
    switch (filter) {
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    case VK_FILTER_NEAREST:
       return anisotropyEnable ?
 #if GFX_VER >= 30
diff --git a/src/intel/vulkan/genX_internal_kernels.c b/src/intel/vulkan/genX_internal_kernels.c
index 5727b993cc172..e1de861a245b0 100644
--- a/src/intel/vulkan/genX_internal_kernels.c
+++ b/src/intel/vulkan/genX_internal_kernels.c
@@ -98,7 +98,7 @@ genX(call_internal_shader)(nir_builder *b, enum anv_internal_kernel_name shader_
       return sizeof(struct anv_memcpy_params);
 
    default:
-      unreachable("Invalid shader name");
+      UNREACHABLE("Invalid shader name");
       break;
    }
 }
diff --git a/src/intel/vulkan/genX_pipeline.c b/src/intel/vulkan/genX_pipeline.c
index 8d60778071bcf..93a87c4239afe 100644
--- a/src/intel/vulkan/genX_pipeline.c
+++ b/src/intel/vulkan/genX_pipeline.c
@@ -124,7 +124,7 @@ vertex_element_comp_control(enum isl_format format, unsigned comp)
    case 1: bits = isl_format_layouts[format].channels.g.bits; break;
    case 2: bits = isl_format_layouts[format].channels.b.bits; break;
    case 3: bits = isl_format_layouts[format].channels.a.bits; break;
-   default: unreachable("Invalid component");
+   default: UNREACHABLE("Invalid component");
    }
 
    /*
@@ -1868,7 +1868,7 @@ emit_mesh_state(struct anv_graphics_pipeline *pipeline)
       index_format = INDEX_U888X;
       break;
    default:
-      unreachable("invalid index format");
+      UNREACHABLE("invalid index format");
    }
 
    anv_pipeline_emit(pipeline, final.mesh_shader,
@@ -2234,7 +2234,7 @@ genX(ray_tracing_pipeline_emit)(struct anv_ray_tracing_pipeline *pipeline)
       }
 
       default:
-         unreachable("Invalid shader group type");
+         UNREACHABLE("Invalid shader group type");
       }
    }
 }
@@ -2244,7 +2244,7 @@ genX(ray_tracing_pipeline_emit)(struct anv_ray_tracing_pipeline *pipeline)
 void
 genX(ray_tracing_pipeline_emit)(struct anv_ray_tracing_pipeline *pipeline)
 {
-   unreachable("Ray tracing not supported");
+   UNREACHABLE("Ray tracing not supported");
 }
 
 #endif /* GFX_VERx10 >= 125 */
diff --git a/src/intel/vulkan/genX_query.c b/src/intel/vulkan/genX_query.c
index 4d9a1f9f77e6a..11fd3c5d3b340 100644
--- a/src/intel/vulkan/genX_query.c
+++ b/src/intel/vulkan/genX_query.c
@@ -119,7 +119,7 @@ emit_query_eop_availability(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Invalid engine class");
+      UNREACHABLE("Invalid engine class");
    }
 }
 
@@ -253,7 +253,7 @@ VkResult genX(CreateQueryPool)(
       uint64s_per_slot = 1 + 1; /* availability + length of written bitstream data */
       break;
    default:
-      unreachable("Invalid query type");
+      UNREACHABLE("Invalid query type");
    }
 
    if (!vk_multialloc_zalloc2(&ma, &device->vk.alloc, pAllocator,
@@ -748,7 +748,7 @@ VkResult genX(GetQueryPoolResults)(
       }
 
       default:
-         unreachable("invalid pool type");
+         UNREACHABLE("invalid pool type");
       }
 
       if (!write_results)
@@ -847,7 +847,7 @@ emit_zero_queries(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -967,7 +967,7 @@ void genX(CmdResetQueryPool)(
          emit_query_mi_flush_availability(cmd_buffer, anv_query_address(pool, firstQuery + i), false);
       break;
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    trace_intel_end_query_clear_cs(&cmd_buffer->trace, queryCount);
@@ -1076,7 +1076,7 @@ emit_perf_intel_query(struct anv_cmd_buffer *cmd_buffer,
       }
 
       default:
-         unreachable("Invalid query field");
+         UNREACHABLE("Invalid query field");
          break;
       }
    }
@@ -1284,7 +1284,7 @@ void genX(CmdBeginQueryIndexedEXT)(
             break;
 
          default:
-            unreachable("Invalid query field");
+            UNREACHABLE("Invalid query field");
             break;
          }
       }
@@ -1307,7 +1307,7 @@ void genX(CmdBeginQueryIndexedEXT)(
       emit_query_mi_availability(&b, query_addr, false);
       break;
    default:
-      unreachable("");
+      UNREACHABLE("");
    }
 }
 
@@ -1471,7 +1471,7 @@ void genX(CmdEndQueryIndexedEXT)(
             break;
 
          default:
-            unreachable("Invalid query field");
+            UNREACHABLE("Invalid query field");
             break;
          }
       }
@@ -1523,7 +1523,7 @@ void genX(CmdEndQueryIndexedEXT)(
       } else if (pool->codec & VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR) {
          reg_addr = HCP_BITSTREAM_BYTECOUNT_FRAME_REG;
       } else {
-         unreachable("Invalid codec operation");
+         UNREACHABLE("Invalid codec operation");
       }
 
       mi_store(&b, mi_mem64(anv_address_add(query_addr, 8)), mi_reg32(reg_addr));
@@ -1531,7 +1531,7 @@ void genX(CmdEndQueryIndexedEXT)(
       break;
    }
    default:
-      unreachable("");
+      UNREACHABLE("");
    }
 
    /* When multiview is active the spec requires that N consecutive query
@@ -1809,11 +1809,11 @@ copy_query_results_with_cs(struct anv_cmd_buffer *cmd_buffer,
 #endif
 
       case VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR:
-         unreachable("Copy KHR performance query results not implemented");
+         UNREACHABLE("Copy KHR performance query results not implemented");
          break;
 
       default:
-         unreachable("unhandled query type");
+         UNREACHABLE("unhandled query type");
       }
 
       if (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT) {
@@ -1982,7 +1982,7 @@ copy_query_results_with_shader(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("unhandled query type");
+      UNREACHABLE("unhandled query type");
    }
 
    *params = (struct anv_query_copy_params) {
@@ -2113,7 +2113,7 @@ genX(CmdWriteAccelerationStructuresPropertiesKHR)(
          query_addr = anv_address_add(query_addr, 8);
          break;
       default:
-         unreachable("unhandled query type");
+         UNREACHABLE("unhandled query type");
       }
 
       mi_store(&b, mi_mem64(query_addr), mi_mem64(anv_address_from_u64(va)));
diff --git a/src/intel/vulkan/i915/anv_batch_chain.c b/src/intel/vulkan/i915/anv_batch_chain.c
index 20436760f3b47..6a5a207c4b2c5 100644
--- a/src/intel/vulkan/i915/anv_batch_chain.c
+++ b/src/intel/vulkan/i915/anv_batch_chain.c
@@ -266,7 +266,7 @@ anv_execbuf_add_sync(struct anv_device *device,
                                      value);
    }
 
-   unreachable("Invalid sync type");
+   UNREACHABLE("Invalid sync type");
 }
 
 static VkResult
diff --git a/src/intel/vulkan/i915/anv_device.c b/src/intel/vulkan/i915/anv_device.c
index d6fd25009c24a..4421497e8e12b 100644
--- a/src/intel/vulkan/i915/anv_device.c
+++ b/src/intel/vulkan/i915/anv_device.c
@@ -42,7 +42,7 @@ vk_priority_to_i915(VkQueueGlobalPriorityKHR priority)
    case VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR:
       return INTEL_CONTEXT_REALTIME_PRIORITY;
    default:
-      unreachable("Invalid priority");
+      UNREACHABLE("Invalid priority");
    }
 }
 
diff --git a/src/intel/vulkan/i915/anv_kmd_backend.c b/src/intel/vulkan/i915/anv_kmd_backend.c
index 843abf278d527..ce62d072c7bda 100644
--- a/src/intel/vulkan/i915/anv_kmd_backend.c
+++ b/src/intel/vulkan/i915/anv_kmd_backend.c
@@ -226,7 +226,7 @@ mmap_calc_flags(struct anv_device *device, struct anv_bo *bo)
       flags = I915_MMAP_WC;
       break;
    case INTEL_DEVICE_INFO_MMAP_MODE_UC:
-      unreachable("Missing");
+      UNREACHABLE("Missing");
    default:
       /* no flags == WB */
       flags = 0;
diff --git a/src/intel/vulkan/i915/anv_queue.c b/src/intel/vulkan/i915/anv_queue.c
index f67f88e8d3681..7dae8f509a48a 100644
--- a/src/intel/vulkan/i915/anv_queue.c
+++ b/src/intel/vulkan/i915/anv_queue.c
@@ -54,7 +54,7 @@ anv_i915_create_engine(struct anv_device *device,
          queue->exec_flags = I915_EXEC_BSD | I915_EXEC_BSD_RING1;
          break;
       default:
-         unreachable("Unsupported legacy engine");
+         UNREACHABLE("Unsupported legacy engine");
       }
    } else if (device->physical->has_vm_control) {
       assert(pCreateInfo->queueFamilyIndex < physical->queue.family_count);
diff --git a/src/intel/vulkan/xe/anv_device.c b/src/intel/vulkan/xe/anv_device.c
index 3b67ab2feabc4..62c339405c42f 100644
--- a/src/intel/vulkan/xe/anv_device.c
+++ b/src/intel/vulkan/xe/anv_device.c
@@ -73,7 +73,7 @@ drm_sched_priority_to_vk_priority(enum drm_sched_priority drm_sched_priority)
    case DRM_SCHED_PRIORITY_HIGH:
       return VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR;
    default:
-      unreachable("Invalid drm_sched_priority");
+      UNREACHABLE("Invalid drm_sched_priority");
       return VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR;
    }
 }
diff --git a/src/intel/vulkan/xe/anv_kmd_backend.c b/src/intel/vulkan/xe/anv_kmd_backend.c
index 5ed0aded4e46c..bba284f16e0a9 100644
--- a/src/intel/vulkan/xe/anv_kmd_backend.c
+++ b/src/intel/vulkan/xe/anv_kmd_backend.c
@@ -88,7 +88,7 @@ xe_gem_create(struct anv_device *device,
       gem_create.cpu_caching = DRM_XE_GEM_CPU_CACHING_WB;
       break;
    default:
-      unreachable("missing");
+      UNREACHABLE("missing");
       gem_create.cpu_caching = DRM_XE_GEM_CPU_CACHING_WC;
    }
 
diff --git a/src/intel/vulkan/xe/anv_queue.c b/src/intel/vulkan/xe/anv_queue.c
index 4be1347609d76..e540e7b7a409b 100644
--- a/src/intel/vulkan/xe/anv_queue.c
+++ b/src/intel/vulkan/xe/anv_queue.c
@@ -45,7 +45,7 @@ anv_vk_priority_to_drm_sched_priority(VkQueueGlobalPriorityKHR vk_priority)
    case VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR:
       return DRM_SCHED_PRIORITY_HIGH;
    default:
-      unreachable("Invalid priority");
+      UNREACHABLE("Invalid priority");
       return DRM_SCHED_PRIORITY_MIN;
    }
 }
diff --git a/src/intel/vulkan_hasvk/anv_batch_chain.c b/src/intel/vulkan_hasvk/anv_batch_chain.c
index 03d96c16f60ae..b8487707dabae 100644
--- a/src/intel/vulkan_hasvk/anv_batch_chain.c
+++ b/src/intel/vulkan_hasvk/anv_batch_chain.c
@@ -1166,7 +1166,7 @@ anv_cmd_buffer_add_secondary(struct anv_cmd_buffer *primary,
       break;
    }
    default:
-      unreachable("Invalid execution mode");
+      UNREACHABLE("Invalid execution mode");
    }
 
    anv_reloc_list_append(&primary->surface_relocs, &primary->vk.pool->alloc,
@@ -1660,7 +1660,7 @@ anv_execbuf_add_sync(struct anv_device *device,
                                      value);
    }
 
-   unreachable("Invalid sync type");
+   UNREACHABLE("Invalid sync type");
 }
 
 static VkResult
diff --git a/src/intel/vulkan_hasvk/anv_blorp.c b/src/intel/vulkan_hasvk/anv_blorp.c
index 0554521e671e7..46d2559538465 100644
--- a/src/intel/vulkan_hasvk/anv_blorp.c
+++ b/src/intel/vulkan_hasvk/anv_blorp.c
@@ -104,7 +104,7 @@ anv_device_init_blorp(struct anv_device *device)
       device->blorp.exec = gfx8_blorp_exec;
       break;
    default:
-      unreachable("Unknown hardware generation");
+      UNREACHABLE("Unknown hardware generation");
    }
 }
 
@@ -437,7 +437,7 @@ isl_format_for_size(unsigned size_B)
    case 12: return ISL_FORMAT_R32G32B32_UINT;
    case 16: return ISL_FORMAT_R32G32B32A32_UINT;
    default:
-      unreachable("Unknown format size");
+      UNREACHABLE("Unknown format size");
    }
 }
 
@@ -647,7 +647,7 @@ blit_image(struct anv_cmd_buffer *cmd_buffer,
       blorp_filter = BLORP_FILTER_BILINEAR;
       break;
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    }
 
    assert(anv_image_aspects_compatible(src_res->aspectMask,
@@ -1884,7 +1884,7 @@ anv_image_mcs_op(struct anv_cmd_buffer *cmd_buffer,
    case ISL_AUX_OP_FULL_RESOLVE:
    case ISL_AUX_OP_AMBIGUATE:
    default:
-      unreachable("Unsupported MCS operation");
+      UNREACHABLE("Unsupported MCS operation");
    }
 
    anv_add_pending_pipe_bits(cmd_buffer,
@@ -1982,7 +1982,7 @@ anv_image_ccs_op(struct anv_cmd_buffer *cmd_buffer,
       }
       break;
    default:
-      unreachable("Unsupported CCS operation");
+      UNREACHABLE("Unsupported CCS operation");
    }
 
    anv_add_pending_pipe_bits(cmd_buffer,
diff --git a/src/intel/vulkan_hasvk/anv_bo_sync.c b/src/intel/vulkan_hasvk/anv_bo_sync.c
index 149ae2c2ba2d3..5f02c6c588694 100644
--- a/src/intel/vulkan_hasvk/anv_bo_sync.c
+++ b/src/intel/vulkan_hasvk/anv_bo_sync.c
@@ -150,7 +150,7 @@ anv_bo_sync_wait(struct vk_device *vk_device,
             break;
 
          default:
-            unreachable("Invalid BO sync state");
+            UNREACHABLE("Invalid BO sync state");
          }
       }
 
diff --git a/src/intel/vulkan_hasvk/anv_cmd_buffer.c b/src/intel/vulkan_hasvk/anv_cmd_buffer.c
index 52e944f92a9c9..6b7198f6af8b6 100644
--- a/src/intel/vulkan_hasvk/anv_cmd_buffer.c
+++ b/src/intel/vulkan_hasvk/anv_cmd_buffer.c
@@ -319,7 +319,7 @@ void anv_CmdBindPipeline(
    }
 
    default:
-      unreachable("invalid bind point");
+      UNREACHABLE("invalid bind point");
       break;
    }
 }
@@ -362,7 +362,7 @@ anv_cmd_buffer_bind_descriptor_set(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("invalid bind point");
+      UNREACHABLE("invalid bind point");
    }
 
    VkShaderStageFlags dirty_stages = 0;
@@ -517,7 +517,7 @@ anv_isl_format_for_descriptor_type(const struct anv_device *device,
       return ISL_FORMAT_RAW;
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 }
 
@@ -664,7 +664,7 @@ anv_cmd_buffer_push_descriptor_set(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("invalid bind point");
+      UNREACHABLE("invalid bind point");
    }
 
    struct anv_push_descriptor_set **push_set =
diff --git a/src/intel/vulkan_hasvk/anv_descriptor_set.c b/src/intel/vulkan_hasvk/anv_descriptor_set.c
index 2746a99f46ae5..77ce1bc190530 100644
--- a/src/intel/vulkan_hasvk/anv_descriptor_set.c
+++ b/src/intel/vulkan_hasvk/anv_descriptor_set.c
@@ -87,7 +87,7 @@ anv_descriptor_data_for_type(const struct anv_physical_device *device,
       break;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 
    /* On gfx8 and above when we have softpin enabled, we also need to push
@@ -1384,7 +1384,7 @@ anv_descriptor_set_write_image_view(struct anv_device *device,
       break;
 
    default:
-      unreachable("invalid descriptor type");
+      UNREACHABLE("invalid descriptor type");
    }
 
    *desc = (struct anv_descriptor) {
diff --git a/src/intel/vulkan_hasvk/anv_device.c b/src/intel/vulkan_hasvk/anv_device.c
index 81f08e50e5d79..1437e30dabacc 100644
--- a/src/intel/vulkan_hasvk/anv_device.c
+++ b/src/intel/vulkan_hasvk/anv_device.c
@@ -2013,7 +2013,7 @@ vk_priority_to_gen(int priority)
    case VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR:
       return INTEL_CONTEXT_REALTIME_PRIORITY;
    default:
-      unreachable("Invalid priority");
+      UNREACHABLE("Invalid priority");
    }
 }
 
diff --git a/src/intel/vulkan_hasvk/anv_formats.c b/src/intel/vulkan_hasvk/anv_formats.c
index 2f3e8fadcbc74..160ee95b378cc 100644
--- a/src/intel/vulkan_hasvk/anv_formats.c
+++ b/src/intel/vulkan_hasvk/anv_formats.c
@@ -1011,7 +1011,7 @@ anv_get_image_format_properties(
 
    switch (info->type) {
    default:
-      unreachable("bad VkImageType");
+      UNREACHABLE("bad VkImageType");
    case VK_IMAGE_TYPE_1D:
       maxExtent.width = 16384;
       maxExtent.height = 1;
@@ -1418,7 +1418,7 @@ VkResult anv_GetPhysicalDeviceImageFormatProperties2(
 
       switch (base_info->tiling) {
       default:
-         unreachable("bad VkImageTiling");
+         UNREACHABLE("bad VkImageTiling");
       case VK_IMAGE_TILING_LINEAR:
          /* The app can query the image's memory layout with
           * vkGetImageSubresourceLayout.
diff --git a/src/intel/vulkan_hasvk/anv_gem_stubs.c b/src/intel/vulkan_hasvk/anv_gem_stubs.c
index 2b20323a38881..6a193fdfefb2a 100644
--- a/src/intel/vulkan_hasvk/anv_gem_stubs.c
+++ b/src/intel/vulkan_hasvk/anv_gem_stubs.c
@@ -113,30 +113,30 @@ anv_gem_set_caching(struct anv_device *device, uint32_t gem_handle,
 int
 anv_gem_set_context_param(int fd, uint32_t context, uint32_t param, uint64_t value)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
 
 bool
 anv_gem_has_context_priority(int fd, int priority)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
 
 int
 anv_gem_context_get_reset_stats(int fd, int context,
                                 uint32_t *active, uint32_t *pending)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
 
 int
 anv_gem_handle_to_fd(struct anv_device *device, uint32_t gem_handle)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
 
 uint32_t
 anv_gem_fd_to_handle(struct anv_device *device, int fd)
 {
-   unreachable("Unused");
+   UNREACHABLE("Unused");
 }
diff --git a/src/intel/vulkan_hasvk/anv_image.c b/src/intel/vulkan_hasvk/anv_image.c
index e2acb1f860e42..35535bf384116 100644
--- a/src/intel/vulkan_hasvk/anv_image.c
+++ b/src/intel/vulkan_hasvk/anv_image.c
@@ -108,7 +108,7 @@ image_binding_grow(const struct anv_device *device,
    switch (binding) {
    case ANV_IMAGE_MEMORY_BINDING_MAIN:
       /* The caller must not pre-translate BINDING_PLANE_i to BINDING_MAIN. */
-      unreachable("ANV_IMAGE_MEMORY_BINDING_MAIN");
+      UNREACHABLE("ANV_IMAGE_MEMORY_BINDING_MAIN");
    case ANV_IMAGE_MEMORY_BINDING_PLANE_0:
    case ANV_IMAGE_MEMORY_BINDING_PLANE_1:
    case ANV_IMAGE_MEMORY_BINDING_PLANE_2:
@@ -119,7 +119,7 @@ image_binding_grow(const struct anv_device *device,
       assert(offset == ANV_OFFSET_IMPLICIT);
       break;
    case ANV_IMAGE_MEMORY_BINDING_END:
-      unreachable("ANV_IMAGE_MEMORY_BINDING_END");
+      UNREACHABLE("ANV_IMAGE_MEMORY_BINDING_END");
    }
 
    struct anv_image_memory_range *container =
@@ -239,7 +239,7 @@ choose_isl_surf_usage(VkImageCreateFlags vk_create_flags,
    case VK_IMAGE_ASPECT_PLANE_2_BIT:
       break;
    default:
-      unreachable("bad VkImageAspect");
+      UNREACHABLE("bad VkImageAspect");
    }
 
    if (vk_usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) {
@@ -272,7 +272,7 @@ choose_isl_tiling_flags(const struct intel_device_info *devinfo,
 
    switch (base_info->tiling) {
    default:
-      unreachable("bad VkImageTiling");
+      UNREACHABLE("bad VkImageTiling");
    case VK_IMAGE_TILING_OPTIMAL:
       flags = ISL_TILING_ANY_MASK;
       break;
@@ -1759,7 +1759,7 @@ anv_get_image_subresource_layout(const struct anv_image *image,
          mem_plane = 2;
          break;
       default:
-         unreachable("bad VkImageAspectFlags");
+         UNREACHABLE("bad VkImageAspectFlags");
       }
 
       if (mem_plane == 1 && isl_drm_modifier_has_aux(image->vk.drm_format_mod)) {
@@ -1899,7 +1899,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
    switch (layout) {
    /* Invalid layouts */
    case VK_IMAGE_LAYOUT_MAX_ENUM:
-      unreachable("Invalid image layout.");
+      UNREACHABLE("Invalid image layout.");
 
    /* Undefined layouts
     *
@@ -1936,7 +1936,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
       case ISL_AUX_STATE_COMPRESSED_NO_CLEAR:
          return ISL_AUX_STATE_COMPRESSED_NO_CLEAR;
       default:
-         unreachable("unexpected isl_aux_state");
+         UNREACHABLE("unexpected isl_aux_state");
       }
    }
 
@@ -1990,7 +1990,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
          break;
 
       default:
-         unreachable("Unsupported aux usage");
+         UNREACHABLE("Unsupported aux usage");
       }
    }
 
@@ -2014,7 +2014,7 @@ anv_layout_to_aux_state(const struct intel_device_info * const devinfo,
       }
 
    default:
-      unreachable("Unsupported aux usage");
+      UNREACHABLE("Unsupported aux usage");
    }
 }
 
@@ -2052,7 +2052,7 @@ anv_layout_to_aux_usage(const struct intel_device_info * const devinfo,
 
    switch (aux_state) {
    case ISL_AUX_STATE_CLEAR:
-      unreachable("We never use this state");
+      UNREACHABLE("We never use this state");
 
    case ISL_AUX_STATE_PARTIAL_CLEAR:
       assert(image->vk.aspects & VK_IMAGE_ASPECT_ANY_COLOR_BIT_ANV);
@@ -2086,7 +2086,7 @@ anv_layout_to_aux_usage(const struct intel_device_info * const devinfo,
       return ISL_AUX_USAGE_NONE;
    }
 
-   unreachable("Invalid isl_aux_state");
+   UNREACHABLE("Invalid isl_aux_state");
 }
 
 /**
@@ -2125,7 +2125,7 @@ anv_layout_to_fast_clear_type(const struct intel_device_info * const devinfo,
 
    switch (aux_state) {
    case ISL_AUX_STATE_CLEAR:
-      unreachable("We never use this state");
+      UNREACHABLE("We never use this state");
 
    case ISL_AUX_STATE_PARTIAL_CLEAR:
    case ISL_AUX_STATE_COMPRESSED_CLEAR:
@@ -2159,7 +2159,7 @@ anv_layout_to_fast_clear_type(const struct intel_device_info * const devinfo,
       return ANV_FAST_CLEAR_NONE;
    }
 
-   unreachable("Invalid isl_aux_state");
+   UNREACHABLE("Invalid isl_aux_state");
 }
 
 
@@ -2181,7 +2181,7 @@ remap_swizzle(VkComponentSwizzle swizzle,
    case VK_COMPONENT_SWIZZLE_B:     return format_swizzle.b;
    case VK_COMPONENT_SWIZZLE_A:     return format_swizzle.a;
    default:
-      unreachable("Invalid swizzle");
+      UNREACHABLE("Invalid swizzle");
    }
 }
 
diff --git a/src/intel/vulkan_hasvk/anv_nir_apply_pipeline_layout.c b/src/intel/vulkan_hasvk/anv_nir_apply_pipeline_layout.c
index 8e3f30a4984ac..f99a3bd9d9bb9 100644
--- a/src/intel/vulkan_hasvk/anv_nir_apply_pipeline_layout.c
+++ b/src/intel/vulkan_hasvk/anv_nir_apply_pipeline_layout.c
@@ -75,7 +75,7 @@ addr_format_for_desc_type(VkDescriptorType desc_type,
       return nir_address_format_32bit_index_offset;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 }
 
@@ -318,7 +318,7 @@ build_res_index(nir_builder *b, uint32_t set, uint32_t binding,
    }
 
    default:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 }
 
@@ -372,7 +372,7 @@ build_res_reindex(nir_builder *b, nir_def *orig, nir_def *delta,
                          nir_channel(b, orig, 1));
 
    default:
-      unreachable("Unhandled address format");
+      UNREACHABLE("Unhandled address format");
    }
 }
 
@@ -417,7 +417,7 @@ build_desc_addr(nir_builder *b,
       return index;
 
    default:
-      unreachable("Unhandled address format");
+      UNREACHABLE("Unhandled address format");
    }
 }
 
@@ -832,7 +832,7 @@ lower_get_ssbo_size(nir_builder *b, nir_intrinsic_instr *intrin,
       break;
 
    default:
-      unreachable("Unsupported address format");
+      UNREACHABLE("Unsupported address format");
    }
 
    return true;
diff --git a/src/intel/vulkan_hasvk/anv_nir_lower_ycbcr_textures.c b/src/intel/vulkan_hasvk/anv_nir_lower_ycbcr_textures.c
index e9809b0e490a3..e5b8f3813adbb 100644
--- a/src/intel/vulkan_hasvk/anv_nir_lower_ycbcr_textures.c
+++ b/src/intel/vulkan_hasvk/anv_nir_lower_ycbcr_textures.c
@@ -171,7 +171,7 @@ channel_to_component(enum isl_channel_select channel)
    case ISL_CHANNEL_SELECT_ALPHA:
       return 3;
    default:
-      unreachable("invalid channel");
+      UNREACHABLE("invalid channel");
       return 0;
    }
 }
@@ -189,7 +189,7 @@ swizzle_channel(struct isl_swizzle swizzle, unsigned channel)
    case 3:
       return swizzle.a;
    default:
-      unreachable("invalid channel");
+      UNREACHABLE("invalid channel");
       return 0;
    }
 }
diff --git a/src/intel/vulkan_hasvk/anv_perf.c b/src/intel/vulkan_hasvk/anv_perf.c
index b792c36b0a66d..383d101dba643 100644
--- a/src/intel/vulkan_hasvk/anv_perf.c
+++ b/src/intel/vulkan_hasvk/anv_perf.c
@@ -83,7 +83,7 @@ anv_physical_device_init_perf(struct anv_physical_device *device, int fd)
          device->n_perf_query_commands += field->size / 4;
          break;
       default:
-         unreachable("Unhandled register type");
+         UNREACHABLE("Unhandled register type");
       }
    }
    device->n_perf_query_commands *= 2; /* Begin & End */
@@ -434,12 +434,12 @@ anv_perf_write_pass_results(struct intel_perf_config *perf,
             break;
          default:
             /* So far we aren't using uint32, double or bool32... */
-            unreachable("unexpected counter data type");
+            UNREACHABLE("unexpected counter data type");
          }
          break;
 
       default:
-         unreachable("invalid query type");
+         UNREACHABLE("invalid query type");
       }
 
       /* The Vulkan extension only has nanoseconds as a unit */
diff --git a/src/intel/vulkan_hasvk/anv_pipeline.c b/src/intel/vulkan_hasvk/anv_pipeline.c
index 911fa8922ce9c..c94ed3c15b72c 100644
--- a/src/intel/vulkan_hasvk/anv_pipeline.c
+++ b/src/intel/vulkan_hasvk/anv_pipeline.c
@@ -194,7 +194,7 @@ void anv_DestroyPipeline(
    }
 
    default:
-      unreachable("invalid pipeline type");
+      UNREACHABLE("invalid pipeline type");
    }
 
    anv_pipeline_finish(pipeline, device, pAllocator);
@@ -948,7 +948,7 @@ anv_pipeline_add_executable(struct anv_pipeline *pipeline,
                break;
 
             case ANV_DESCRIPTOR_SET_NUM_WORK_GROUPS:
-               unreachable("gl_NumWorkgroups is never pushed");
+               UNREACHABLE("gl_NumWorkgroups is never pushed");
 
             case ANV_DESCRIPTOR_SET_SHADER_CONSTANTS:
                fprintf(stream, "Inline shader constant data (start=%dB)",
@@ -956,7 +956,7 @@ anv_pipeline_add_executable(struct anv_pipeline *pipeline,
                break;
 
             case ANV_DESCRIPTOR_SET_COLOR_ATTACHMENTS:
-               unreachable("Color attachments can't be pushed");
+               UNREACHABLE("Color attachments can't be pushed");
 
             default:
                fprintf(stream, "UBO (set=%d binding=%d start=%dB)",
@@ -1081,7 +1081,7 @@ anv_graphics_pipeline_init_keys(struct anv_graphics_pipeline *pipeline,
          break;
       }
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
 
       stages[s].feedback.duration += os_time_get_nano() - stage_start;
@@ -1292,7 +1292,7 @@ anv_graphics_pipeline_compile(struct anv_graphics_pipeline *pipeline,
          anv_pipeline_link_fs(compiler, &stages[s], state->rp);
          break;
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
 
       next_stage = &stages[s];
@@ -1358,7 +1358,7 @@ anv_graphics_pipeline_compile(struct anv_graphics_pipeline *pipeline,
                                  &stages[s], prev_stage);
          break;
       default:
-         unreachable("Invalid graphics shader stage");
+         UNREACHABLE("Invalid graphics shader stage");
       }
       if (stages[s].code == NULL) {
          ralloc_free(stage_ctx);
@@ -1971,7 +1971,7 @@ VkResult anv_GetPipelineExecutableStatisticsKHR(
       break;
    }
    default:
-      unreachable("invalid pipeline type");
+      UNREACHABLE("invalid pipeline type");
    }
 
    vk_outarray_append_typed(VkPipelineExecutableStatisticKHR, &out, stat) {
diff --git a/src/intel/vulkan_hasvk/anv_private.h b/src/intel/vulkan_hasvk/anv_private.h
index 54f29d3932517..d8a7b437036c8 100644
--- a/src/intel/vulkan_hasvk/anv_private.h
+++ b/src/intel/vulkan_hasvk/anv_private.h
@@ -3852,7 +3852,7 @@ VK_DEFINE_NONDISP_HANDLE_CASTS(anv_performance_configuration_intel, base,
       genX_thing = &gfx8_##thing;               \
       break;                                    \
    default:                                     \
-      unreachable("Unknown hardware generation"); \
+      UNREACHABLE("Unknown hardware generation"); \
    }                                            \
    genX_thing;                                  \
 })
diff --git a/src/intel/vulkan_hasvk/genX_cmd_buffer.c b/src/intel/vulkan_hasvk/genX_cmd_buffer.c
index 41499a4a78224..079e598d04c52 100644
--- a/src/intel/vulkan_hasvk/genX_cmd_buffer.c
+++ b/src/intel/vulkan_hasvk/genX_cmd_buffer.c
@@ -740,7 +740,7 @@ anv_cmd_predicated_mcs_resolve(struct anv_cmd_buffer *cmd_buffer,
    anv_image_mcs_op(cmd_buffer, image, format, swizzle, aspect,
                     array_layer, 1, resolve_op, NULL, true);
 #else
-   unreachable("MCS resolves are unsupported on Ivybridge and Bay Trail");
+   UNREACHABLE("MCS resolves are unsupported on Ivybridge and Bay Trail");
 #endif
 }
 
@@ -2397,7 +2397,7 @@ emit_binding_table(struct anv_cmd_buffer *cmd_buffer,
             break;
 
          default:
-            unreachable("Invalid descriptor type");
+            UNREACHABLE("Invalid descriptor type");
          }
          assert(surface_state.map);
          bt_map[s] = surface_state.offset + state_offset;
@@ -5907,7 +5907,7 @@ static uint32_t vk_to_intel_index_type(VkIndexType type)
    case VK_INDEX_TYPE_UINT32:
       return INDEX_DWORD;
    default:
-      unreachable("invalid index type");
+      UNREACHABLE("invalid index type");
    }
 }
 
@@ -5958,7 +5958,7 @@ VkResult genX(CmdSetPerformanceOverrideINTEL)(
       break;
 
    default:
-      unreachable("Invalid override");
+      UNREACHABLE("Invalid override");
    }
 
    return VK_SUCCESS;
@@ -6005,7 +6005,7 @@ void genX(cmd_emit_timestamp)(struct anv_batch *batch,
       break;
 
    default:
-      unreachable("invalid");
+      UNREACHABLE("invalid");
    }
 }
 
diff --git a/src/intel/vulkan_hasvk/genX_gpu_memcpy.c b/src/intel/vulkan_hasvk/genX_gpu_memcpy.c
index d892ccef995ca..78d23806e5b28 100644
--- a/src/intel/vulkan_hasvk/genX_gpu_memcpy.c
+++ b/src/intel/vulkan_hasvk/genX_gpu_memcpy.c
@@ -116,7 +116,7 @@ emit_so_memcpy(struct anv_batch *batch, struct anv_device *device,
    case 8:  format = ISL_FORMAT_R32G32_UINT;       break;
    case 16: format = ISL_FORMAT_R32G32B32A32_UINT; break;
    default:
-      unreachable("Invalid size");
+      UNREACHABLE("Invalid size");
    }
 
    uint32_t *dw;
diff --git a/src/intel/vulkan_hasvk/genX_pipeline.c b/src/intel/vulkan_hasvk/genX_pipeline.c
index de47a5cb89687..f7bb06b20bf0d 100644
--- a/src/intel/vulkan_hasvk/genX_pipeline.c
+++ b/src/intel/vulkan_hasvk/genX_pipeline.c
@@ -46,7 +46,7 @@ vertex_element_comp_control(enum isl_format format, unsigned comp)
    case 1: bits = isl_format_layouts[format].channels.g.bits; break;
    case 2: bits = isl_format_layouts[format].channels.b.bits; break;
    case 3: bits = isl_format_layouts[format].channels.a.bits; break;
-   default: unreachable("Invalid component");
+   default: UNREACHABLE("Invalid component");
    }
 
    /*
@@ -474,7 +474,7 @@ genX(raster_polygon_mode)(struct anv_graphics_pipeline *pipeline,
       case _3DPRIM_POLYGON:
          return pipeline->polygon_mode;
       }
-      unreachable("Unsupported GS output topology");
+      UNREACHABLE("Unsupported GS output topology");
    } else if (anv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_EVAL)) {
       switch (get_tes_prog_data(pipeline)->output_topology) {
       case INTEL_TESS_OUTPUT_TOPOLOGY_POINT:
@@ -487,7 +487,7 @@ genX(raster_polygon_mode)(struct anv_graphics_pipeline *pipeline,
       case INTEL_TESS_OUTPUT_TOPOLOGY_TRI_CCW:
          return pipeline->polygon_mode;
       }
-      unreachable("Unsupported TCS output topology");
+      UNREACHABLE("Unsupported TCS output topology");
    } else {
       switch (primitive_topology) {
       case VK_PRIMITIVE_TOPOLOGY_POINT_LIST:
@@ -507,7 +507,7 @@ genX(raster_polygon_mode)(struct anv_graphics_pipeline *pipeline,
          return pipeline->polygon_mode;
 
       default:
-         unreachable("Unsupported primitive topology");
+         UNREACHABLE("Unsupported primitive topology");
       }
    }
 }
@@ -527,14 +527,14 @@ genX(ms_rasterization_mode)(struct anv_graphics_pipeline *pipeline,
          return MSRASTMODE_OFF_PIXEL;
 
       default:
-         unreachable("Unsupported line rasterization mode");
+         UNREACHABLE("Unsupported line rasterization mode");
       }
    } else {
       return pipeline->rasterization_samples > 1 ?
          MSRASTMODE_ON_PATTERN : MSRASTMODE_OFF_PIXEL;
    }
 #else
-   unreachable("Only on gen7");
+   UNREACHABLE("Only on gen7");
 #endif
 }
 
@@ -594,14 +594,14 @@ genX(rasterization_mode)(VkPolygonMode raster_mode,
          break;
 
       default:
-         unreachable("Unsupported line rasterization mode");
+         UNREACHABLE("Unsupported line rasterization mode");
       }
    } else {
       *api_mode = DX100;
       *msaa_rasterization_enable = true;
    }
 #else
-   unreachable("Invalid call");
+   UNREACHABLE("Invalid call");
 #endif
 }
 
@@ -636,7 +636,7 @@ emit_rs_state(struct anv_graphics_pipeline *pipeline,
       break;
 
    default:
-      unreachable("Invalid provoking vertex mode");
+      UNREACHABLE("Invalid provoking vertex mode");
    }
 
 #if GFX_VERx10 == 75
@@ -1047,7 +1047,7 @@ emit_3dstate_clip(struct anv_graphics_pipeline *pipeline,
       break;
 
    default:
-      unreachable("Invalid provoking vertex mode");
+      UNREACHABLE("Invalid provoking vertex mode");
    }
 
    clip.MinimumPointWidth = 0.125;
@@ -1244,7 +1244,7 @@ emit_3dstate_streamout(struct anv_graphics_pipeline *pipeline,
          break;
 
       default:
-         unreachable("Invalid provoking vertex mode");
+         UNREACHABLE("Invalid provoking vertex mode");
       }
 
       so.RenderStreamSelect = rs->rasterization_stream;
@@ -1519,7 +1519,7 @@ emit_3dstate_gs(struct anv_graphics_pipeline *pipeline,
          break;
 
       default:
-         unreachable("Invalid provoking vertex mode");
+         UNREACHABLE("Invalid provoking vertex mode");
       }
 
 #if GFX_VER >= 8
diff --git a/src/intel/vulkan_hasvk/genX_query.c b/src/intel/vulkan_hasvk/genX_query.c
index cb4869436380f..1728b150cec13 100644
--- a/src/intel/vulkan_hasvk/genX_query.c
+++ b/src/intel/vulkan_hasvk/genX_query.c
@@ -164,7 +164,7 @@ VkResult genX(CreateQueryPool)(
       uint64s_per_slot = 1 + 2;
       break;
    default:
-      unreachable("Invalid query type");
+      UNREACHABLE("Invalid query type");
    }
 
    if (!vk_object_multialloc(&device->vk, &ma, pAllocator,
@@ -592,7 +592,7 @@ VkResult genX(GetQueryPoolResults)(
       }
 
       default:
-         unreachable("invalid pool type");
+         UNREACHABLE("invalid pool type");
       }
 
       if (!write_results)
@@ -714,7 +714,7 @@ emit_zero_queries(struct anv_cmd_buffer *cmd_buffer,
       break;
 
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -791,7 +791,7 @@ void genX(CmdResetQueryPool)(
    }
 
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -895,7 +895,7 @@ emit_perf_intel_query(struct anv_cmd_buffer *cmd_buffer,
       }
 
       default:
-         unreachable("Invalid query field");
+         UNREACHABLE("Invalid query field");
          break;
       }
    }
@@ -1072,7 +1072,7 @@ void genX(CmdBeginQueryIndexedEXT)(
             break;
 
          default:
-            unreachable("Invalid query field");
+            UNREACHABLE("Invalid query field");
             break;
          }
       }
@@ -1090,7 +1090,7 @@ void genX(CmdBeginQueryIndexedEXT)(
    }
 
    default:
-      unreachable("");
+      UNREACHABLE("");
    }
 }
 
@@ -1224,7 +1224,7 @@ void genX(CmdEndQueryIndexedEXT)(
             break;
 
          default:
-            unreachable("Invalid query field");
+            UNREACHABLE("Invalid query field");
             break;
          }
       }
@@ -1258,7 +1258,7 @@ void genX(CmdEndQueryIndexedEXT)(
    }
 
    default:
-      unreachable("");
+      UNREACHABLE("");
    }
 
    /* When multiview is active the spec requires that N consecutive query
@@ -1498,12 +1498,12 @@ void genX(CmdCopyQueryPoolResults)(
 
 #if GFX_VER >= 8
       case VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR:
-         unreachable("Copy KHR performance query results not implemented");
+         UNREACHABLE("Copy KHR performance query results not implemented");
          break;
 #endif
 
       default:
-         unreachable("unhandled query type");
+         UNREACHABLE("unhandled query type");
       }
 
       if (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT) {
diff --git a/src/intel/vulkan_hasvk/genX_state.c b/src/intel/vulkan_hasvk/genX_state.c
index 6f1e1fa3a265f..337fa12a9e325 100644
--- a/src/intel/vulkan_hasvk/genX_state.c
+++ b/src/intel/vulkan_hasvk/genX_state.c
@@ -148,7 +148,7 @@ genX(emit_l3_config)(struct anv_batch *batch,
 
    anv_batch_write_reg(batch, L3_ALLOCATION_REG, l3cr) {
       if (cfg == NULL) {
-         unreachable("Invalid L3$ config");
+         UNREACHABLE("Invalid L3$ config");
       } else {
          l3cr.SLMEnable = cfg->n[INTEL_L3P_SLM];
          assert(cfg->n[INTEL_L3P_IS] == 0);
@@ -334,7 +334,7 @@ genX(emit_sample_pattern)(struct anv_batch *batch,
             }
             break;
          default:
-            unreachable("Invalid sample count");
+            UNREACHABLE("Invalid sample count");
          }
       }
    }
@@ -346,7 +346,7 @@ vk_to_intel_tex_filter(VkFilter filter, bool anisotropyEnable)
 {
    switch (filter) {
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    case VK_FILTER_NEAREST:
       return anisotropyEnable ? MAPFILTER_ANISOTROPIC : MAPFILTER_NEAREST;
    case VK_FILTER_LINEAR:
diff --git a/src/mesa/main/accum.c b/src/mesa/main/accum.c
index 0a449d6ab6e86..bc2a48dfda477 100644
--- a/src/mesa/main/accum.c
+++ b/src/mesa/main/accum.c
@@ -436,7 +436,7 @@ accum(struct gl_context *ctx, GLenum op, GLfloat value)
       accum_return(ctx, value, xpos, ypos, width, height);
       break;
    default:
-      unreachable("invalid mode in _mesa_Accum()");
+      UNREACHABLE("invalid mode in _mesa_Accum()");
       break;
    }
 }
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index c8280e8de6d1d..7569e24936201 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -4906,7 +4906,7 @@ bind_buffer_range(GLenum target, GLuint index, GLuint buffer, GLintptr offset,
          bind_buffer_range_atomic_buffer(ctx, index, bufObj, offset, size);
          return;
       default:
-         unreachable("invalid BindBufferRange target with KHR_no_error");
+         UNREACHABLE("invalid BindBufferRange target with KHR_no_error");
       }
    } else {
       if (buffer != 0) {
diff --git a/src/mesa/main/debug_output.c b/src/mesa/main/debug_output.c
index cf61355d035d8..2fa6980e54c13 100644
--- a/src/mesa/main/debug_output.c
+++ b/src/mesa/main/debug_output.c
@@ -734,7 +734,7 @@ _debug_message(void *data,
       severity = MESA_DEBUG_SEVERITY_NOTIFICATION;
       break;
    default:
-      unreachable("invalid debug type");
+      UNREACHABLE("invalid debug type");
    }
    _mesa_gl_vdebugf(ctx, id, source, type, severity, fmt, args);
 }
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 485ae07ecb0a6..045b80c312a31 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1041,7 +1041,7 @@ check_draw_elements_data(struct gl_context *ctx, GLsizei count,
          j = ((const GLuint *) elements)[i];
          break;
       default:
-         unreachable("Unexpected index buffer type");
+         UNREACHABLE("Unexpected index buffer type");
       }
 
       /* check element j of each enabled array */
diff --git a/src/mesa/main/draw_validate.c b/src/mesa/main/draw_validate.c
index 9ac709858b069..a52bf1801bd08 100644
--- a/src/mesa/main/draw_validate.c
+++ b/src/mesa/main/draw_validate.c
@@ -261,7 +261,7 @@ _mesa_update_valid_to_render_state(struct gl_context *ctx)
       break;
 
    default:
-      unreachable("Invalid API value in _mesa_update_valid_to_render_state");
+      UNREACHABLE("Invalid API value in _mesa_update_valid_to_render_state");
    }
 
    /* From the GL_NV_fill_rectangle spec:
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index a9fab8c081895..6c78dd69039f9 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -368,7 +368,7 @@ get_fb0_attachment(struct gl_context *ctx, struct gl_framebuffer *fb,
       case GL_STENCIL:
          return &fb->Attachment[BUFFER_STENCIL];
       default:
-         unreachable("invalid attachment");
+         UNREACHABLE("invalid attachment");
       }
    }
 
diff --git a/src/mesa/main/ffvertex_prog.c b/src/mesa/main/ffvertex_prog.c
index abd33a0e0f742..d9fb01f37578f 100644
--- a/src/mesa/main/ffvertex_prog.c
+++ b/src/mesa/main/ffvertex_prog.c
@@ -531,7 +531,7 @@ static GLuint material_attrib( GLuint side, GLuint property )
    case STATE_SHININESS:
       return MAT_ATTRIB_FRONT_SHININESS + side;
    default:
-      unreachable("invalid value");
+      UNREACHABLE("invalid value");
    }
 }
 
@@ -1063,7 +1063,7 @@ static void build_fog( struct tnl_program *p )
       fog = load_input(p, VERT_ATTRIB_FOG, 1);
       break;
    default:
-      unreachable("Bad fog mode in build_fog()");
+      UNREACHABLE("Bad fog mode in build_fog()");
    }
 
    store_output_float(p, VARYING_SLOT_FOGC, fog);
diff --git a/src/mesa/main/format_utils.c b/src/mesa/main/format_utils.c
index 625d8d8589743..ac6f8a624be64 100644
--- a/src/mesa/main/format_utils.c
+++ b/src/mesa/main/format_utils.c
@@ -186,7 +186,7 @@ _mesa_compute_rgba2base2rgba_component_mapping(GLenum baseFormat, uint8_t *map)
          return needRebase;
       }
    default:
-      unreachable("Unexpected base format");
+      UNREACHABLE("Unexpected base format");
    }
 }
 
diff --git a/src/mesa/main/formatquery.c b/src/mesa/main/formatquery.c
index 51d02fd9b38ce..ca57571e798e6 100644
--- a/src/mesa/main/formatquery.c
+++ b/src/mesa/main/formatquery.c
@@ -430,7 +430,7 @@ _set_default_response(GLenum pname, GLint buffer[16])
       break;
 
    default:
-      unreachable("invalid 'pname'");
+      UNREACHABLE("invalid 'pname'");
    }
 }
 
@@ -494,7 +494,7 @@ _is_target_supported(struct gl_context *ctx, GLenum target)
       break;
 
    default:
-      unreachable("invalid target");
+      UNREACHABLE("invalid target");
    }
 
    return true;
@@ -584,7 +584,7 @@ _is_resource_supported(struct gl_context *ctx, GLenum target,
 
       break;
    default:
-      unreachable("bad target");
+      UNREACHABLE("bad target");
    }
 
    return true;
@@ -1674,7 +1674,7 @@ _mesa_GetInternalformativ(GLenum target, GLenum internalformat, GLenum pname,
       break;
 
    default:
-      unreachable("bad param");
+      UNREACHABLE("bad param");
    }
 
  end:
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index ba20232f2a7cb..07853b92445ae 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -307,7 +307,7 @@ get_base_format_for_array_format(mesa_array_format format)
       break;
    }
 
-   unreachable("Unsupported format");
+   UNREACHABLE("Unsupported format");
 }
 
 /**
@@ -427,7 +427,7 @@ _mesa_array_format_flip_channels(mesa_array_format format)
       return format;
    }
 
-   unreachable("Invalid array format");
+   UNREACHABLE("Invalid array format");
 }
 
 static uint32_t
diff --git a/src/mesa/main/glformats.c b/src/mesa/main/glformats.c
index 7c476bfd22049..70147fc7646f7 100644
--- a/src/mesa/main/glformats.c
+++ b/src/mesa/main/glformats.c
@@ -4122,7 +4122,7 @@ _mesa_format_from_format_and_type(GLenum format, GLenum type)
     * matches the GL format/type provided. We may need to add a new Mesa
     * format in that case.
     */
-   unreachable("Unsupported format");
+   UNREACHABLE("Unsupported format");
 }
 
 uint32_t
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index cb5a0eef55281..c25ee8e67387f 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -354,7 +354,7 @@ uint32_t
 _mesa_unmarshal_NamedBufferData(struct gl_context *ctx,
                                 const struct marshal_cmd_NamedBufferData *restrict cmd)
 {
-   unreachable("never used - all BufferData variants use DISPATCH_CMD_BufferData");
+   UNREACHABLE("never used - all BufferData variants use DISPATCH_CMD_BufferData");
    return 0;
 }
 
@@ -362,7 +362,7 @@ uint32_t
 _mesa_unmarshal_NamedBufferDataEXT(struct gl_context *ctx,
                                    const struct marshal_cmd_NamedBufferDataEXT *restrict cmd)
 {
-   unreachable("never used - all BufferData variants use DISPATCH_CMD_BufferData");
+   UNREACHABLE("never used - all BufferData variants use DISPATCH_CMD_BufferData");
    return 0;
 }
 
@@ -472,7 +472,7 @@ uint32_t
 _mesa_unmarshal_NamedBufferSubData(struct gl_context *ctx,
                                    const struct marshal_cmd_NamedBufferSubData *restrict cmd)
 {
-   unreachable("never used - all BufferSubData variants use DISPATCH_CMD_BufferSubData");
+   UNREACHABLE("never used - all BufferSubData variants use DISPATCH_CMD_BufferSubData");
    return 0;
 }
 
@@ -480,7 +480,7 @@ uint32_t
 _mesa_unmarshal_NamedBufferSubDataEXT(struct gl_context *ctx,
                                       const struct marshal_cmd_NamedBufferSubDataEXT *restrict cmd)
 {
-   unreachable("never used - all BufferSubData variants use DISPATCH_CMD_BufferSubData");
+   UNREACHABLE("never used - all BufferSubData variants use DISPATCH_CMD_BufferSubData");
    return 0;
 }
 
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 95d7a6b3c9fda..1ae5ac8a9ca38 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -1868,7 +1868,7 @@ uint32_t
 _mesa_unmarshal_DrawArrays(struct gl_context *ctx,
                            const struct marshal_cmd_DrawArrays *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1876,7 +1876,7 @@ uint32_t
 _mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
                                                 const struct marshal_cmd_DrawArraysInstancedBaseInstance *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1884,7 +1884,7 @@ uint32_t
 _mesa_unmarshal_MultiDrawArrays(struct gl_context *ctx,
                                 const struct marshal_cmd_MultiDrawArrays *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1892,7 +1892,7 @@ uint32_t
 _mesa_unmarshal_DrawRangeElements(struct gl_context *ctx,
                                   const struct marshal_cmd_DrawRangeElements *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1900,7 +1900,7 @@ uint32_t
 _mesa_unmarshal_DrawRangeElementsBaseVertex(struct gl_context *ctx,
                                             const struct marshal_cmd_DrawRangeElementsBaseVertex *cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1908,7 +1908,7 @@ uint32_t
 _mesa_unmarshal_DrawElementsInstanced(struct gl_context *ctx,
                                       const struct marshal_cmd_DrawElementsInstanced *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1916,7 +1916,7 @@ uint32_t
 _mesa_unmarshal_DrawElementsBaseVertex(struct gl_context *ctx,
                                        const struct marshal_cmd_DrawElementsBaseVertex *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1924,7 +1924,7 @@ uint32_t
 _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *ctx,
                                                             const struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1932,7 +1932,7 @@ uint32_t
 _mesa_unmarshal_MultiDrawElements(struct gl_context *ctx,
                                   const struct marshal_cmd_MultiDrawElements *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1940,7 +1940,7 @@ uint32_t
 _mesa_unmarshal_MultiDrawElementsBaseVertex(struct gl_context *ctx,
                                             const struct marshal_cmd_MultiDrawElementsBaseVertex *restrict cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1948,7 +1948,7 @@ uint32_t
 _mesa_unmarshal_MultiModeDrawArraysIBM(struct gl_context *ctx,
                                        const struct marshal_cmd_MultiModeDrawArraysIBM *cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
@@ -1956,32 +1956,32 @@ uint32_t
 _mesa_unmarshal_MultiModeDrawElementsIBM(struct gl_context *ctx,
                                          const struct marshal_cmd_MultiModeDrawElementsIBM *cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
    return 0;
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawArraysUserBuf(void)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElementsUserBuf(const GLvoid *cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElementsUserBufPacked(const GLvoid *cmd)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_marshal_MultiDrawArraysUserBuf(void)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
@@ -1991,19 +1991,19 @@ _mesa_marshal_MultiDrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
                                        GLsizei primcount,
                                        const GLint *basevertex)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawArraysInstancedBaseInstanceDrawID(void)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY _mesa_marshal_DrawElementsPacked(GLenum mode, GLenum type,
                                                  GLushort count, GLushort indices)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
@@ -2012,31 +2012,31 @@ _mesa_marshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(GLenum mode, GLs
                                                                 GLsizei instance_count, GLint basevertex,
                                                                 GLuint baseinstance, GLuint drawid)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_DrawArraysUserBuf(void)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_MultiDrawArraysUserBuf(void)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
 _mesa_DrawArraysInstancedBaseInstanceDrawID(void)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY _mesa_DrawElementsPacked(GLenum mode, GLenum type,
                                          GLushort count, GLushort indices)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 void GLAPIENTRY
@@ -2045,7 +2045,7 @@ _mesa_DrawElementsInstancedBaseVertexBaseInstanceDrawID(GLenum mode, GLsizei cou
                                                         GLsizei instance_count, GLint basevertex,
                                                         GLuint baseinstance, GLuint drawid)
 {
-   unreachable("should never end up here");
+   UNREACHABLE("should never end up here");
 }
 
 uint32_t
diff --git a/src/mesa/main/glthread_get.c b/src/mesa/main/glthread_get.c
index fc14e3f4e14a7..e11e0100eb463 100644
--- a/src/mesa/main/glthread_get.c
+++ b/src/mesa/main/glthread_get.c
@@ -28,7 +28,7 @@ uint32_t
 _mesa_unmarshal_GetIntegerv(struct gl_context *ctx,
                             const struct marshal_cmd_GetIntegerv *restrict cmd)
 {
-   unreachable("never executed");
+   UNREACHABLE("never executed");
    return 0;
 }
 
diff --git a/src/mesa/main/glthread_shaderobj.c b/src/mesa/main/glthread_shaderobj.c
index d994958d7d0c1..45c1a5ca7ff44 100644
--- a/src/mesa/main/glthread_shaderobj.c
+++ b/src/mesa/main/glthread_shaderobj.c
@@ -39,7 +39,7 @@ uint32_t
 _mesa_unmarshal_GetActiveUniform(struct gl_context *ctx,
                                  const struct marshal_cmd_GetActiveUniform *restrict cmd)
 {
-   unreachable("never executed");
+   UNREACHABLE("never executed");
    return 0;
 }
 
@@ -83,7 +83,7 @@ uint32_t
 _mesa_unmarshal_GetUniformLocation(struct gl_context *ctx,
                                    const struct marshal_cmd_GetUniformLocation *restrict cmd)
 {
-   unreachable("never executed");
+   UNREACHABLE("never executed");
    return 0;
 }
 
diff --git a/src/mesa/main/light.c b/src/mesa/main/light.c
index b1543f58f1552..dbc9f2d1fa776 100644
--- a/src/mesa/main/light.c
+++ b/src/mesa/main/light.c
@@ -245,7 +245,7 @@ do_light(struct gl_context *ctx, GLuint lnum, GLenum pname, const GLfloat *param
       break;
    }
    default:
-      unreachable("Unexpected pname in do_light()");
+      UNREACHABLE("Unexpected pname in do_light()");
    }
 }
 
diff --git a/src/mesa/main/mipmap.c b/src/mesa/main/mipmap.c
index 3553003841927..e98da79498b8f 100644
--- a/src/mesa/main/mipmap.c
+++ b/src/mesa/main/mipmap.c
@@ -629,7 +629,7 @@ _mesa_generate_mipmap_level(GLenum target,
       /* no mipmaps, do nothing */
       break;
    default:
-      unreachable("bad tex target in _mesa_generate_mipmaps");
+      UNREACHABLE("bad tex target in _mesa_generate_mipmaps");
    }
 }
 
diff --git a/src/mesa/main/pack.c b/src/mesa/main/pack.c
index b1cf949530f8e..179af484af24c 100644
--- a/src/mesa/main/pack.c
+++ b/src/mesa/main/pack.c
@@ -462,7 +462,7 @@ extract_uint_indexes(GLuint n, GLuint indexes[],
          break;
 
       default:
-         unreachable("bad srcType in extract_uint_indexes");
+         UNREACHABLE("bad srcType in extract_uint_indexes");
    }
 }
 
@@ -586,7 +586,7 @@ _mesa_unpack_stencil_span( struct gl_context *ctx, GLuint n,
             }
             break;
          default:
-            unreachable("bad dstType in _mesa_unpack_stencil_span");
+            UNREACHABLE("bad dstType in _mesa_unpack_stencil_span");
       }
 
       free(indexes);
@@ -733,7 +733,7 @@ _mesa_pack_stencil_span( struct gl_context *ctx, GLuint n,
       }
       break;
    default:
-      unreachable("bad type in _mesa_pack_index_span");
+      UNREACHABLE("bad type in _mesa_pack_index_span");
    }
 
    free(stencil);
@@ -1124,7 +1124,7 @@ _mesa_pack_depth_span( struct gl_context *ctx, GLuint n, GLvoid *dest,
       }
       break;
    default:
-      unreachable("bad type in _mesa_pack_depth_span()");
+      UNREACHABLE("bad type in _mesa_pack_depth_span()");
    }
 
    free(depthCopy);
@@ -1720,7 +1720,7 @@ _mesa_unpack_uint_24_8_depth_stencil_row(mesa_format format, uint32_t n,
       unpack_uint_24_8_depth_stencil_Z32_S8X24(src, dst, n);
       break;
    default:
-      unreachable("bad format %s in _mesa_unpack_uint_24_8_depth_stencil_row");
+      UNREACHABLE("bad format %s in _mesa_unpack_uint_24_8_depth_stencil_row");
    }
 }
 
@@ -1794,6 +1794,6 @@ _mesa_unpack_float_32_uint_24_8_depth_stencil_row(mesa_format format, uint32_t n
       unpack_float_32_uint_24_8_Z32_FLOAT_S8X24_UINT(src, dst, n);
       break;
    default:
-      unreachable("bad format %s in _mesa_unpack_uint_24_8_depth_stencil_row");
+      UNREACHABLE("bad format %s in _mesa_unpack_uint_24_8_depth_stencil_row");
    }
 }
diff --git a/src/mesa/main/performance_monitor.c b/src/mesa/main/performance_monitor.c
index c184a8bd16525..efe524ea85bd4 100644
--- a/src/mesa/main/performance_monitor.c
+++ b/src/mesa/main/performance_monitor.c
@@ -419,7 +419,7 @@ init_groups(struct gl_context *ctx)
                c->Type = GL_PERCENTAGE_AMD;
                break;
             default:
-               unreachable("Invalid driver query type!");
+               UNREACHABLE("Invalid driver query type!");
          }
 
          c->query_type = info.query_type;
diff --git a/src/mesa/main/performance_query.c b/src/mesa/main/performance_query.c
index a5e2ef25f0294..9a579c49f3df6 100644
--- a/src/mesa/main/performance_query.c
+++ b/src/mesa/main/performance_query.c
@@ -319,7 +319,7 @@ pipe_counter_type_enum_to_gl_type(enum pipe_perf_counter_type type)
    case PIPE_PERF_COUNTER_TYPE_RAW: return GL_PERFQUERY_COUNTER_RAW_INTEL;
    case PIPE_PERF_COUNTER_TYPE_TIMESTAMP: return GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL;
    default:
-      unreachable("Unknown counter type");
+      UNREACHABLE("Unknown counter type");
    }
 }
 
@@ -333,7 +333,7 @@ pipe_counter_data_type_to_gl_type(enum pipe_perf_counter_data_type type)
    case PIPE_PERF_COUNTER_DATA_TYPE_FLOAT: return GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL;
    case PIPE_PERF_COUNTER_DATA_TYPE_DOUBLE: return GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL;
    default:
-      unreachable("Unknown counter data type");
+      UNREACHABLE("Unknown counter data type");
    }
 }
 
diff --git a/src/mesa/main/pixelstore.c b/src/mesa/main/pixelstore.c
index 016181f624f27..f46f924328eb1 100644
--- a/src/mesa/main/pixelstore.c
+++ b/src/mesa/main/pixelstore.c
@@ -215,7 +215,7 @@ pixel_storei(GLenum pname, GLint param, bool no_error)
          if (!no_error)
             goto invalid_enum_error;
          else
-            unreachable("invalid pixel store enum");
+            UNREACHABLE("invalid pixel store enum");
    }
 
    return;
diff --git a/src/mesa/main/queryobj.c b/src/mesa/main/queryobj.c
index 9bb805d8eb1ad..0a29ff88f08c3 100644
--- a/src/mesa/main/queryobj.c
+++ b/src/mesa/main/queryobj.c
@@ -333,7 +333,7 @@ get_query_result(struct pipe_context *pipe,
          q->Result = data.pipeline_statistics.c_primitives;
          break;
       default:
-         unreachable("invalid pipeline statistics counter");
+         UNREACHABLE("invalid pipeline statistics counter");
       }
       break;
    case PIPE_QUERY_OCCLUSION_PREDICATE:
@@ -448,7 +448,7 @@ store_query_result(struct gl_context *ctx, struct gl_query_object *q,
       result_type = PIPE_QUERY_TYPE_U64;
       break;
    default:
-      unreachable("Unexpected result type");
+      UNREACHABLE("Unexpected result type");
    }
 
    if (pname == GL_QUERY_RESULT_AVAILABLE) {
@@ -1215,7 +1215,7 @@ invalid_enum:
       break;
    }
    default:
-      unreachable("unexpected ptype");
+      UNREACHABLE("unexpected ptype");
    }
 }
 
diff --git a/src/mesa/main/shaderobj.h b/src/mesa/main/shaderobj.h
index 5315eaffd4184..7209b29122cc7 100644
--- a/src/mesa/main/shaderobj.h
+++ b/src/mesa/main/shaderobj.h
@@ -138,7 +138,7 @@ _mesa_shader_enum_to_shader_stage(GLenum v)
    case GL_COMPUTE_SHADER:
       return MESA_SHADER_COMPUTE;
    default:
-      unreachable("bad value in _mesa_shader_enum_to_shader_stage()");
+      UNREACHABLE("bad value in _mesa_shader_enum_to_shader_stage()");
    }
 }
 
@@ -161,7 +161,7 @@ _mesa_shader_stage_to_subroutine_prefix(gl_shader_stage stage)
   case MESA_SHADER_TESS_EVAL:
     return "__subu_e";
   default:
-    unreachable("bad value in _mesa_shader_stage_to_subroutine_prefix()");
+    UNREACHABLE("bad value in _mesa_shader_stage_to_subroutine_prefix()");
   }
 }
 
@@ -182,7 +182,7 @@ _mesa_shader_stage_from_subroutine_uniform(GLenum subuniform)
    case GL_TESS_EVALUATION_SUBROUTINE_UNIFORM:
       return MESA_SHADER_TESS_EVAL;
    }
-   unreachable("not reached");
+   UNREACHABLE("not reached");
 }
 
 static inline gl_shader_stage
@@ -202,7 +202,7 @@ _mesa_shader_stage_from_subroutine(GLenum subroutine)
    case GL_TESS_EVALUATION_SUBROUTINE:
       return MESA_SHADER_TESS_EVAL;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -223,7 +223,7 @@ _mesa_shader_stage_to_subroutine(gl_shader_stage stage)
    case MESA_SHADER_TESS_EVAL:
       return GL_TESS_EVALUATION_SUBROUTINE;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
@@ -244,7 +244,7 @@ _mesa_shader_stage_to_subroutine_uniform(gl_shader_stage stage)
    case MESA_SHADER_TESS_EVAL:
       return GL_TESS_EVALUATION_SUBROUTINE_UNIFORM;
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
diff --git a/src/mesa/main/spirv_extensions.c b/src/mesa/main/spirv_extensions.c
index a3470a61cbf83..78c361c0b0ab5 100644
--- a/src/mesa/main/spirv_extensions.c
+++ b/src/mesa/main/spirv_extensions.c
@@ -74,7 +74,7 @@ _mesa_spirv_extensions_to_string(enum SpvExtension ext)
    STR(SPV_KHR_variable_pointers);
    STR(SPV_AMD_gcn_shader);
    case SPV_EXTENSIONS_COUNT:
-      unreachable("Unknown SPIR-V extension");
+      UNREACHABLE("Unknown SPIR-V extension");
    }
 #undef STR
 
diff --git a/src/mesa/main/texcompress.c b/src/mesa/main/texcompress.c
index 1a25a508a4aaf..f06b92739040d 100644
--- a/src/mesa/main/texcompress.c
+++ b/src/mesa/main/texcompress.c
@@ -505,7 +505,7 @@ _mesa_astc_ldrhdr_glenum_to_format(const struct gl_context *ctx, GLenum format)
 #undef CASE
 
    default:
-      unreachable("unexpected format");
+      UNREACHABLE("unexpected format");
    }
 }
 
diff --git a/src/mesa/main/texcompress_astc.cpp b/src/mesa/main/texcompress_astc.cpp
index e628c4c81bff7..4f8f4f50922bc 100644
--- a/src/mesa/main/texcompress_astc.cpp
+++ b/src/mesa/main/texcompress_astc.cpp
@@ -909,7 +909,7 @@ void Block::decode_cem(InputBitVector in)
             cems[2] = ((cem_base_class + c2) << 2) | m2;
             cems[3] = ((cem_base_class + c3) << 2) | m3;
          } else {
-            unreachable("");
+            UNREACHABLE("");
          }
       }
 
@@ -1194,7 +1194,7 @@ void Block::unquantise_weights()
                D = v >> 3;
                break;
             default:
-               unreachable("");
+               UNREACHABLE("");
             }
             uint16_t T = D * C + B;
             T = T ^ A;
@@ -1224,7 +1224,7 @@ void Block::unquantise_weights()
                D = v >> 2;
                break;
             default:
-               unreachable("");
+               UNREACHABLE("");
             }
             uint16_t T = D * C + B;
             T = T ^ A;
@@ -1244,7 +1244,7 @@ void Block::unquantise_weights()
          case 3: w = v | (v << 3); break;
          case 4: w = (v >> 2) | (v << 2); break;
          case 5: w = (v >> 4) | (v << 1); break;
-         default: unreachable("");
+         default: UNREACHABLE("");
          }
          assert(w < 64);
          if (w > 32)
@@ -1368,7 +1368,7 @@ void Block::unquantise_colour_endpoints()
             D = v >> 6;
             break;
          default:
-            unreachable("");
+            UNREACHABLE("");
          }
          uint16_t T = D * C + B;
          T = T ^ A;
@@ -1409,7 +1409,7 @@ void Block::unquantise_colour_endpoints()
             D = v >> 5;
             break;
          default:
-            unreachable("");
+            UNREACHABLE("");
          }
          uint16_t T = D * C + B;
          T = T ^ A;
@@ -1426,7 +1426,7 @@ void Block::unquantise_colour_endpoints()
          case 6: v = (v << 2) | (v >> 4); break;
          case 7: v = (v << 1) | (v >> 6); break;
          case 8: break;
-         default: unreachable("");
+         default: UNREACHABLE("");
          }
          colour_endpoints[i] = v;
       }
diff --git a/src/mesa/main/texcompress_etc.c b/src/mesa/main/texcompress_etc.c
index 607686ef6dd84..95d5822ed379b 100644
--- a/src/mesa/main/texcompress_etc.c
+++ b/src/mesa/main/texcompress_etc.c
@@ -549,7 +549,7 @@ etc2_rgb8_fetch_texel(const struct etc2_block *block,
          dst[3] = 255;
    }
    else
-      unreachable("unhandled block mode");
+      UNREACHABLE("unhandled block mode");
 }
 
 static void
diff --git a/src/mesa/main/texcompress_rgtc.c b/src/mesa/main/texcompress_rgtc.c
index 94c802170fd86..0b280377bb8c7 100644
--- a/src/mesa/main/texcompress_rgtc.c
+++ b/src/mesa/main/texcompress_rgtc.c
@@ -496,6 +496,6 @@ _mesa_unpack_rgtc(uint8_t *dst_row,
       break;
 
    default:
-      unreachable("unexpected format");
+      UNREACHABLE("unexpected format");
    }
 }
diff --git a/src/mesa/main/texcompress_s3tc.c b/src/mesa/main/texcompress_s3tc.c
index 585fa8b9062a9..add08aaae7c67 100644
--- a/src/mesa/main/texcompress_s3tc.c
+++ b/src/mesa/main/texcompress_s3tc.c
@@ -426,6 +426,6 @@ _mesa_unpack_s3tc(uint8_t *dst_row,
       break;
 
    default:
-      unreachable("unexpected format");
+      UNREACHABLE("unexpected format");
    }
 }
diff --git a/src/mesa/main/texgetimage.c b/src/mesa/main/texgetimage.c
index 6d0db242cff5a..f9e223e8e66d3 100644
--- a/src/mesa/main/texgetimage.c
+++ b/src/mesa/main/texgetimage.c
@@ -162,7 +162,7 @@ get_tex_depth_stencil(struct gl_context *ctx, GLuint dimensions,
                                                                  src, dest);
                break;
             default:
-               unreachable("bad type in get_tex_depth_stencil()");
+               UNREACHABLE("bad type in get_tex_depth_stencil()");
             }
             if (ctx->Pack.SwapBytes) {
                _mesa_swap4((GLuint *) dest, width);
diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index 927ff199e046a..813aee59f7b27 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -86,7 +86,7 @@ valid_filter_for_float(const struct gl_context *ctx,
    case GL_NEAREST_MIPMAP_NEAREST:
       break;
    default:
-      unreachable("Invalid mag filter");
+      UNREACHABLE("Invalid mag filter");
    }
 
    switch (obj->Sampler.Attrib.MinFilter) {
@@ -104,7 +104,7 @@ valid_filter_for_float(const struct gl_context *ctx,
    case GL_NEAREST_MIPMAP_NEAREST:
       break;
    default:
-      unreachable("Invalid min filter");
+      UNREACHABLE("Invalid min filter");
    }
 
    return true;
diff --git a/src/mesa/main/texstate.c b/src/mesa/main/texstate.c
index f2c0e5e5acbe4..c4c6e7e32bbc9 100644
--- a/src/mesa/main/texstate.c
+++ b/src/mesa/main/texstate.c
@@ -445,7 +445,7 @@ tex_combine_translate_mode(GLenum envMode, GLenum mode)
    case GL_MODULATE_SIGNED_ADD_ATI: return TEXENV_MODE_MODULATE_SIGNED_ADD_ATI;
    case GL_MODULATE_SUBTRACT_ATI: return TEXENV_MODE_MODULATE_SUBTRACT_ATI;
    default:
-      unreachable("Invalid TexEnv Combine mode");
+      UNREACHABLE("Invalid TexEnv Combine mode");
    }
 }
 
@@ -469,7 +469,7 @@ tex_combine_translate_source(GLenum src)
    case GL_ZERO: return TEXENV_SRC_ZERO;
    case GL_ONE: return TEXENV_SRC_ONE;
    default:
-      unreachable("Invalid TexEnv Combine argument source");
+      UNREACHABLE("Invalid TexEnv Combine argument source");
    }
 }
 
@@ -483,7 +483,7 @@ tex_combine_translate_operand(GLenum operand)
    case GL_SRC_ALPHA: return TEXENV_OPR_ALPHA;
    case GL_ONE_MINUS_SRC_ALPHA: return TEXENV_OPR_ONE_MINUS_ALPHA;
    default:
-      unreachable("Invalid TexEnv Combine argument source");
+      UNREACHABLE("Invalid TexEnv Combine argument source");
    }
 }
 
diff --git a/src/mesa/main/texstorage.c b/src/mesa/main/texstorage.c
index f0c1801320e53..334ab1a96cd6d 100644
--- a/src/mesa/main/texstorage.c
+++ b/src/mesa/main/texstorage.c
@@ -118,7 +118,7 @@ _mesa_is_legal_tex_storage_target(const struct gl_context *ctx,
          return false;
       }
    default:
-      unreachable("impossible dimensions");
+      UNREACHABLE("impossible dimensions");
    }
 }
 
diff --git a/src/mesa/main/transformfeedback.c b/src/mesa/main/transformfeedback.c
index bc1c25f9e8a9d..4fe75792c7c21 100644
--- a/src/mesa/main/transformfeedback.c
+++ b/src/mesa/main/transformfeedback.c
@@ -373,7 +373,7 @@ begin_transform_feedback(struct gl_context *ctx, GLenum mode, bool no_error)
          return;
       } else {
          /* Stop compiler warnings */
-         unreachable("Error in API use when using KHR_no_error");
+         UNREACHABLE("Error in API use when using KHR_no_error");
       }
    }
 
diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index 296d023c9d1e7..5a24e2484afd1 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -611,7 +611,7 @@ _mesa_get_uniform(struct gl_context *ctx, GLuint program, GLint location,
                   break;
                }
                default:
-                  unreachable("invalid uniform type");
+                  UNREACHABLE("invalid uniform type");
                }
                break;
 
diff --git a/src/mesa/program/prog_parameter.c b/src/mesa/program/prog_parameter.c
index 53ddf35cad0e2..acfd9211a1106 100644
--- a/src/mesa/program/prog_parameter.c
+++ b/src/mesa/program/prog_parameter.c
@@ -353,7 +353,7 @@ _mesa_add_parameter(struct gl_program_parameter_list *paramList,
       paramList->LastStateVarIndex =
          MAX2(paramList->LastStateVarIndex, oldNum);
    } else {
-      unreachable("invalid parameter type");
+      UNREACHABLE("invalid parameter type");
    }
 
    assert(paramList->NumParameters <= paramList->Size);
diff --git a/src/mesa/program/prog_statevars.c b/src/mesa/program/prog_statevars.c
index cd6cafe6d4923..375c50c0bebd8 100644
--- a/src/mesa/program/prog_statevars.c
+++ b/src/mesa/program/prog_statevars.c
@@ -1638,7 +1638,7 @@ _mesa_optimize_state_parameters(struct gl_constants *consts,
                attrib_incr = 1;
                break;
             default:
-               unreachable("unexpected state-var");
+               UNREACHABLE("unexpected state-var");
             }
 
             /* Find all attributes for one light. */
diff --git a/src/mesa/program/prog_to_nir.c b/src/mesa/program/prog_to_nir.c
index 264090d5d3cf1..a80934b128c07 100644
--- a/src/mesa/program/prog_to_nir.c
+++ b/src/mesa/program/prog_to_nir.c
@@ -374,7 +374,7 @@ _mesa_texture_index_to_sampler_dim(gl_texture_index index, bool *is_array)
    case NUM_TEXTURE_TARGETS:
       break;
    }
-   unreachable("unknown texture target");
+   UNREACHABLE("unknown texture target");
 }
 
 static nir_def *
diff --git a/src/mesa/state_tracker/st_atifs_to_nir.c b/src/mesa/state_tracker/st_atifs_to_nir.c
index b08de70e6acd2..c8c9f94a059a4 100644
--- a/src/mesa/state_tracker/st_atifs_to_nir.c
+++ b/src/mesa/state_tracker/st_atifs_to_nir.c
@@ -160,7 +160,7 @@ get_source(struct st_translate *t, GLenum src_type)
       return load_input(t, VARYING_SLOT_COL1);
    } else {
       /* frontend prevents this */
-      unreachable("unknown source");
+      UNREACHABLE("unknown source");
    }
 }
 
@@ -262,7 +262,7 @@ emit_arith_inst(struct st_translate *t,
       return nir_channel_vec4(t->b, nir_fdot4(t->b,src[0], src[1]), 0);
 
    default:
-      unreachable("Unknown ATI_fs opcode");
+      UNREACHABLE("Unknown ATI_fs opcode");
    }
 }
 
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index c10342ae57ab1..462df8c2ae304 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -646,7 +646,7 @@ st_update_array_impl(struct st_context *st)
 void
 st_update_array(struct st_context *st)
 {
-   unreachable("st_init_update_array not called");
+   UNREACHABLE("st_init_update_array not called");
 }
 
 void
diff --git a/src/mesa/state_tracker/st_atom_image.c b/src/mesa/state_tracker/st_atom_image.c
index 3f1f9fb4ed8e5..e415b3d76b8b6 100644
--- a/src/mesa/state_tracker/st_atom_image.c
+++ b/src/mesa/state_tracker/st_atom_image.c
@@ -65,7 +65,7 @@ st_convert_image(const struct st_context *st, const struct gl_image_unit *u,
       img->access = PIPE_IMAGE_ACCESS_READ_WRITE;
       break;
    default:
-      unreachable("bad gl_image_unit::Access");
+      UNREACHABLE("bad gl_image_unit::Access");
    }
 
    img->shader_access = 0;
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index 5313d3ecc1ad1..3e5760f17bb29 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -67,7 +67,7 @@ slot_to_vert_attrib(gl_varying_slot slot)
    case VARYING_SLOT_TEX0:
       return VERT_ATTRIB_GENERIC0;
    default:
-      unreachable("unhandled slot");
+      UNREACHABLE("unhandled slot");
    }
 }
 
diff --git a/src/mesa/state_tracker/st_cb_eglimage.c b/src/mesa/state_tracker/st_cb_eglimage.c
index 9f52810742e06..95516b5fb05a6 100644
--- a/src/mesa/state_tracker/st_cb_eglimage.c
+++ b/src/mesa/state_tracker/st_cb_eglimage.c
@@ -498,7 +498,7 @@ st_bind_egl_image(struct gl_context *ctx,
             texFormat = MESA_FORMAT_R10G10B10X2_UNORM;
             texObj->RequiredTextureImageUnits = 1;
          } else {
-            unreachable("NV15 emulation requires R10_G10B10_420_UNORM support");
+            UNREACHABLE("NV15 emulation requires R10_G10B10_420_UNORM support");
          }
          break;
       case PIPE_FORMAT_NV20:
@@ -506,7 +506,7 @@ st_bind_egl_image(struct gl_context *ctx,
             texFormat = MESA_FORMAT_R10G10B10X2_UNORM;
             texObj->RequiredTextureImageUnits = 1;
          } else {
-            unreachable("NV20 emulation requires R10_G10B10_422_UNORM support");
+            UNREACHABLE("NV20 emulation requires R10_G10B10_422_UNORM support");
          }
          break;
       case PIPE_FORMAT_P010:
@@ -586,7 +586,7 @@ st_bind_egl_image(struct gl_context *ctx,
          texObj->RequiredTextureImageUnits = 1;
          break;
       default:
-         unreachable("unexpected emulated format");
+         UNREACHABLE("unexpected emulated format");
          break;
       }
    } else {
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 44d280f4b8c9f..59e9bdab9f17b 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -156,7 +156,7 @@ st_from_pipe_compression_rate(uint32_t rate)
    case 11: return GL_SURFACE_COMPRESSION_FIXED_RATE_11BPC_EXT;
    case 12: return GL_SURFACE_COMPRESSION_FIXED_RATE_12BPC_EXT;
    default:
-      unreachable("Unexpected value in st_from_pipe_compression_rate");
+      UNREACHABLE("Unexpected value in st_from_pipe_compression_rate");
    }
 }
 
@@ -181,7 +181,7 @@ st_gl_compression_rate_to_pipe(GLint rate)
    case GL_SURFACE_COMPRESSION_FIXED_RATE_11BPC_EXT: return 11;
    case GL_SURFACE_COMPRESSION_FIXED_RATE_12BPC_EXT: return 12;
    default:
-      unreachable("Unexpected value in st_gl_compression_rate_to_pipe()");
+      UNREACHABLE("Unexpected value in st_gl_compression_rate_to_pipe()");
    }
 }
 
@@ -799,7 +799,7 @@ st_UnmapTextureImage(struct gl_context *ctx,
                                         transfer->box.height,
                                         texImage->TexFormat);
             } else {
-               unreachable("unexpected format for a compressed format fallback");
+               UNREACHABLE("unexpected format for a compressed format fallback");
             }
 
             /* Compress it to the target format. */
@@ -855,7 +855,7 @@ st_UnmapTextureImage(struct gl_context *ctx,
                                  transfer->box.width, transfer->box.height,
                                  texImage->TexFormat);
             } else {
-               unreachable("unexpected format for a compressed format fallback");
+               UNREACHABLE("unexpected format for a compressed format fallback");
             }
          }
 
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 7c37f76d32d55..215d08d3753e0 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -307,7 +307,7 @@ free_zombie_shaders(struct st_context *st)
          st->pipe->delete_compute_state(st->pipe, entry->shader);
          break;
       default:
-         unreachable("invalid shader type in free_zombie_shaders()");
+         UNREACHABLE("invalid shader type in free_zombie_shaders()");
       }
       free(entry);
    }
diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index cd37f23329240..de40454a68cc5 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -644,7 +644,7 @@ hw_select_create_gs(struct st_context *st, union state_key state)
       build_planar_primitive_nir_shader(&b, state, packed);
       break;
    default:
-      unreachable("unexpected primitive");
+      UNREACHABLE("unexpected primitive");
    }
 
    nir_lower_returns(nir);
diff --git a/src/mesa/state_tracker/st_format.c b/src/mesa/state_tracker/st_format.c
index ee7f6efdce6ce..1b2e3fee0ad62 100644
--- a/src/mesa/state_tracker/st_format.c
+++ b/src/mesa/state_tracker/st_format.c
@@ -105,7 +105,7 @@ st_mesa_format_to_pipe_format(const struct st_context *st,
          return st->transcode_etc ? PIPE_FORMAT_DXT1_SRGBA :
                 has_bgra_srgb ? PIPE_FORMAT_B8G8R8A8_SRGB : PIPE_FORMAT_R8G8B8A8_SRGB;
       default:
-         unreachable("Unknown ETC2 format");
+         UNREACHABLE("Unknown ETC2 format");
       }
    }
 
@@ -153,7 +153,7 @@ st_mesa_format_to_pipe_format(const struct st_context *st,
       case MESA_FORMAT_LA_LATC2_SNORM:
          return PIPE_FORMAT_L8A8_SNORM;
       default:
-         unreachable("Unknown RGTC format");
+         UNREACHABLE("Unknown RGTC format");
       }
    }
 
diff --git a/src/mesa/state_tracker/st_nir_lower_fog.c b/src/mesa/state_tracker/st_nir_lower_fog.c
index b5c56761e8af0..93602513d288e 100644
--- a/src/mesa/state_tracker/st_nir_lower_fog.c
+++ b/src/mesa/state_tracker/st_nir_lower_fog.c
@@ -62,7 +62,7 @@ fog_result(nir_builder *b, nir_def *color, enum gl_fog_mode fog_mode, struct gl_
       f = nir_fexp2(b, nir_fneg(b, f));
       break;
    default:
-      unreachable("unsupported fog mode");
+      UNREACHABLE("unsupported fog mode");
    }
    f = nir_fsat(b, f);
 
diff --git a/src/mesa/state_tracker/st_nir_unlower_io_to_vars.c b/src/mesa/state_tracker/st_nir_unlower_io_to_vars.c
index 853fe1153d0ff..b49105e8d233f 100644
--- a/src/mesa/state_tracker/st_nir_unlower_io_to_vars.c
+++ b/src/mesa/state_tracker/st_nir_unlower_io_to_vars.c
@@ -306,7 +306,7 @@ create_vars(nir_builder *b, nir_intrinsic_instr *intr, void *opaque)
                                           sizeof(float));
                break;
             default:
-               unreachable("unexpected varying slot");
+               UNREACHABLE("unexpected varying slot");
             }
          } else {
             switch (desc.sem.location) {
@@ -359,7 +359,7 @@ create_vars(nir_builder *b, nir_intrinsic_instr *intr, void *opaque)
          else if (nir->info.stage == MESA_SHADER_GEOMETRY && !desc.is_output)
             num_vertices = mesa_vertices_per_prim(nir->info.gs.input_primitive);
          else
-            unreachable("unexpected shader stage for per-vertex IO");
+            UNREACHABLE("unexpected shader stage for per-vertex IO");
 
          var_type = glsl_array_type(var_type, num_vertices, 0);
       }
@@ -511,7 +511,7 @@ create_vars(nir_builder *b, nir_intrinsic_instr *intr, void *opaque)
          var->data.sample = true;
          break;
       default:
-         unreachable("unexpected barycentric intrinsic");
+         UNREACHABLE("unexpected barycentric intrinsic");
       }
 
       if (var->index == VAR_INDEX_INTERP_AT_PIXEL) {
@@ -692,7 +692,7 @@ st_nir_unlower_io_to_vars(nir_shader *nir)
             nir_io_mix_convergent_flat_with_interpolated));
 
    nir_foreach_variable_with_modes(var, nir, nir_var_shader_in | nir_var_shader_out) {
-      unreachable("the shader should have no IO variables");
+      UNREACHABLE("the shader should have no IO variables");
    }
 
    /* Some drivers can't handle holes in driver locations (bases), so
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index a52c725ae7076..1117e0abc9497 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -208,7 +208,7 @@ st_set_prog_affected_state_flags(struct gl_program *prog)
       break;
 
    default:
-      unreachable("unhandled shader stage");
+      UNREACHABLE("unhandled shader stage");
    }
 }
 
@@ -249,7 +249,7 @@ delete_variant(struct st_context *st, struct st_variant *v, unsigned stage)
             st->pipe->delete_compute_state(st->pipe, v->driver_shader);
             break;
          default:
-            unreachable("bad shader type in delete_basic_variant");
+            UNREACHABLE("bad shader type in delete_basic_variant");
          }
       } else {
          /* We can't delete a shader with a context different from the one
@@ -294,7 +294,7 @@ st_unbind_program(struct st_context *st, struct gl_program *p)
       ctx->NewDriverState |= ST_NEW_CS_STATE;
       break;
    default:
-      unreachable("invalid shader type");
+      UNREACHABLE("invalid shader type");
    }
 }
 
@@ -535,7 +535,7 @@ st_create_nir_shader(struct st_context *st, struct pipe_shader_state *state)
       break;
    }
    default:
-      unreachable("unsupported shader stage");
+      UNREACHABLE("unsupported shader stage");
       return NULL;
    }
 
@@ -1459,7 +1459,7 @@ st_precompile_shader_variant(struct st_context *st,
    }
 
    default:
-      unreachable("invalid shader stage");
+      UNREACHABLE("invalid shader stage");
    }
 }
 
diff --git a/src/mesa/state_tracker/st_texcompress_compute.c b/src/mesa/state_tracker/st_texcompress_compute.c
index 11a0d8b9e06a0..3f4fafc5d4576 100644
--- a/src/mesa/state_tracker/st_texcompress_compute.c
+++ b/src/mesa/state_tracker/st_texcompress_compute.c
@@ -188,11 +188,11 @@ bind_compute_state(struct st_context *st,
    }
 
    if (prog->affected_states & ST_NEW_CS_UBOS) {
-      unreachable("Uniform buffer objects not handled");
+      UNREACHABLE("Uniform buffer objects not handled");
    }
 
    if (prog->affected_states & ST_NEW_CS_ATOMICS) {
-      unreachable("Atomic buffer objects not handled");
+      UNREACHABLE("Atomic buffer objects not handled");
    }
 
    if (prog->affected_states & ST_NEW_CS_SSBOS) {
diff --git a/src/mesa/state_tracker/st_texture.c b/src/mesa/state_tracker/st_texture.c
index 73fc15817dbac..83150056ee08f 100644
--- a/src/mesa/state_tracker/st_texture.c
+++ b/src/mesa/state_tracker/st_texture.c
@@ -188,7 +188,7 @@ st_gl_texture_dims_to_pipe_dims(GLenum texture,
       *layersOut = util_align_npot(depthIn, 6);
       break;
    default:
-      unreachable("Unexpected texture in st_gl_texture_dims_to_pipe_dims()");
+      UNREACHABLE("Unexpected texture in st_gl_texture_dims_to_pipe_dims()");
    case GL_TEXTURE_3D:
    case GL_PROXY_TEXTURE_3D:
       *widthOut = widthIn;
diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index 1fd23fdb3846b..c669fbd603f04 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -350,7 +350,7 @@ vbo_copy_vertices(struct gl_context *ctx,
    case GL_TRIANGLE_STRIP_ADJACENCY:
       /* TODO: Splitting tri strips with adjacency is too complicated. */
    default:
-      unreachable("Unexpected primitive type");
+      UNREACHABLE("Unexpected primitive type");
       return 0;
    }
 
diff --git a/src/mesa/vbo/vbo_minmax_index.c b/src/mesa/vbo/vbo_minmax_index.c
index 19df7807a769d..5f81d5024cf47 100644
--- a/src/mesa/vbo/vbo_minmax_index.c
+++ b/src/mesa/vbo/vbo_minmax_index.c
@@ -308,7 +308,7 @@ vbo_get_minmax_index_mapped(unsigned count, unsigned index_size,
       break;
    }
    default:
-      unreachable("not reached");
+      UNREACHABLE("not reached");
    }
 }
 
diff --git a/src/mesa/vbo/vbo_private.h b/src/mesa/vbo/vbo_private.h
index cd79c590de2f5..90b6f65a37e6e 100644
--- a/src/mesa/vbo/vbo_private.h
+++ b/src/mesa/vbo/vbo_private.h
@@ -102,7 +102,7 @@ vbo_attrtype_to_integer_flag(GLenum format)
    case GL_UNSIGNED_INT64_ARB:
       return GL_TRUE;
    default:
-      unreachable("Bad vertex attribute type");
+      UNREACHABLE("Bad vertex attribute type");
       return GL_FALSE;
    }
 }
@@ -119,7 +119,7 @@ vbo_attrtype_to_double_flag(GLenum format)
    case GL_DOUBLE:
       return GL_TRUE;
    default:
-      unreachable("Bad vertex attribute type");
+      UNREACHABLE("Bad vertex attribute type");
       return GL_FALSE;
    }
 }
@@ -159,7 +159,7 @@ vbo_get_default_vals_as_union(GLenum format)
    case GL_UNSIGNED_INT64_ARB:
       return (fi_type *)default_uint64;
    default:
-      unreachable("Bad vertex format");
+      UNREACHABLE("Bad vertex format");
       return NULL;
    }
 }
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index 525bd199bda8f..748404b2f11a2 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -1108,7 +1108,7 @@ copy_from_current(struct gl_context *ctx)
          save->attrptr[i][0] = save->current[i][0];
          break;
       case 0:
-         unreachable("Unexpected vertex attribute size");
+         UNREACHABLE("Unexpected vertex attribute size");
       }
    }
 }
diff --git a/src/microsoft/clc/clc_compiler.c b/src/microsoft/clc/clc_compiler.c
index 1aac05c56141b..62f03237c5246 100644
--- a/src/microsoft/clc/clc_compiler.c
+++ b/src/microsoft/clc/clc_compiler.c
@@ -172,7 +172,7 @@ clc_lower_input_image_deref(nir_builder *b, struct clc_image_lower_context *cont
                case nir_type_float: type = FLOAT4; break;
                case nir_type_int: type = INT4; break;
                case nir_type_uint: type = UINT4; break;
-               default: unreachable("Unsupported image type for load.");
+               default: UNREACHABLE("Unsupported image type for load.");
                }
 
                int image_binding = image_bindings[type];
@@ -243,7 +243,7 @@ clc_lower_input_image_deref(nir_builder *b, struct clc_image_lower_context *cont
             }
 
             default:
-               unreachable("Unsupported image intrinsic");
+               UNREACHABLE("Unsupported image intrinsic");
             }
          } else if (nir_src_parent_instr(src)->type == nir_instr_type_tex) {
             assert(in_var->data.access & ACCESS_NON_WRITEABLE);
@@ -253,7 +253,7 @@ clc_lower_input_image_deref(nir_builder *b, struct clc_image_lower_context *cont
             case nir_type_float: type = FLOAT4; break;
             case nir_type_int: type = INT4; break;
             case nir_type_uint: type = UINT4; break;
-            default: unreachable("Unsupported image format for sample.");
+            default: UNREACHABLE("Unsupported image format for sample.");
             }
 
             int image_binding = image_bindings[type];
@@ -567,7 +567,7 @@ copy_const_initializer(const nir_constant *constant, const struct glsl_type *typ
             *((uint8_t *)data) = constant->values[i].u8;
             break;
          default:
-            unreachable("Invalid base type");
+            UNREACHABLE("Invalid base type");
          }
 
          data += glsl_get_bit_size(type) / 8;
@@ -1202,7 +1202,7 @@ clc_spirv_to_dxil(struct clc_libclc *lib,
             metadata->consts[metadata->num_consts].uav_id = var->data.binding;
             metadata->num_consts++;
          } else
-            unreachable("unexpected constant initializer");
+            UNREACHABLE("unexpected constant initializer");
       }
    }
 
diff --git a/src/microsoft/clc/clc_nir.c b/src/microsoft/clc/clc_nir.c
index 6ac0fcf70a79d..1aba48e57fb2c 100644
--- a/src/microsoft/clc/clc_nir.c
+++ b/src/microsoft/clc/clc_nir.c
@@ -118,7 +118,7 @@ lower_load_kernel_input(nir_builder *b, nir_instr *instr, void *state)
       base_type = GLSL_TYPE_UINT8;
       break;
    default:
-      unreachable("invalid bit size");
+      UNREACHABLE("invalid bit size");
    }
 
    const struct glsl_type *type =
diff --git a/src/microsoft/compiler/dxil_dump.c b/src/microsoft/compiler/dxil_dump.c
index 73bff2fac074d..9b0db94607b76 100644
--- a/src/microsoft/compiler/dxil_dump.c
+++ b/src/microsoft/compiler/dxil_dump.c
@@ -399,7 +399,7 @@ dump_constants(struct dxil_dumper *d, struct list_head *list)
             _mesa_string_buffer_append(d->buf, "}\n");
             break;
          default:
-            unreachable("Unsupported const type");
+            UNREACHABLE("Unsupported const type");
          }
       } else
          _mesa_string_buffer_append(d->buf, " undef\n");
diff --git a/src/microsoft/compiler/dxil_enums.c b/src/microsoft/compiler/dxil_enums.c
index a8321b35b7e31..9530220b8744d 100644
--- a/src/microsoft/compiler/dxil_enums.c
+++ b/src/microsoft/compiler/dxil_enums.c
@@ -64,7 +64,7 @@ enum dxil_component_type dxil_get_comp_type_from_prog_sig_type(enum dxil_prog_si
    case DXIL_PROG_SIG_COMP_TYPE_FLOAT16: return DXIL_COMP_TYPE_F16;
    default:
       debug_printf("unexpected signature type\n");
-      unreachable("unexpected signature type");
+      UNREACHABLE("unexpected signature type");
    }
 }
 
@@ -90,7 +90,7 @@ enum dxil_component_type dxil_get_comp_type(const struct glsl_type *type)
 
    default:
       debug_printf("type: %s\n", glsl_get_type_name(type));
-      unreachable("unexpected glsl type");
+      UNREACHABLE("unexpected glsl type");
    }
 }
 
@@ -122,7 +122,7 @@ enum dxil_resource_kind dxil_sampler_dim_to_resource_kind(enum glsl_sampler_dim
          return DXIL_RESOURCE_KIND_TEXTURE2DMS_ARRAY;
 
       default:
-         unreachable("unexpected sampler type");
+         UNREACHABLE("unexpected sampler type");
    }
 }
 
@@ -138,7 +138,7 @@ enum dxil_resource_kind dxil_get_resource_kind(const struct glsl_type *type)
       return dxil_sampler_dim_to_resource_kind(glsl_get_sampler_dim(type), is_array);
 
    debug_printf("type: %s\n", glsl_get_type_name(type));
-   unreachable("unexpected glsl type");
+   UNREACHABLE("unexpected glsl type");
 }
 
 enum dxil_input_primitive dxil_get_input_primitive(enum mesa_prim primitive)
@@ -155,7 +155,7 @@ enum dxil_input_primitive dxil_get_input_primitive(enum mesa_prim primitive)
    case MESA_PRIM_TRIANGLES_ADJACENCY:
       return DXIL_INPUT_PRIMITIVE_TRIANGLES_ADJENCY;
    default:
-      unreachable("unhandled primitive topology");
+      UNREACHABLE("unhandled primitive topology");
    }
 }
 
@@ -171,7 +171,7 @@ enum dxil_primitive_topology dxil_get_primitive_topology(enum mesa_prim topology
    case MESA_PRIM_TRIANGLE_STRIP:
       return DXIL_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    default:
-      unreachable("unhandled primitive topology");
+      UNREACHABLE("unhandled primitive topology");
    }
 }
 
diff --git a/src/microsoft/compiler/dxil_function.c b/src/microsoft/compiler/dxil_function.c
index 483e85be61f41..6b47272463e91 100644
--- a/src/microsoft/compiler/dxil_function.c
+++ b/src/microsoft/compiler/dxil_function.c
@@ -161,7 +161,7 @@ allocate_function_from_predefined(struct dxil_module *mod,
                                 predefined_funcs[i].attr);
       }
    }
-   unreachable("Invalid function name");
+   UNREACHABLE("Invalid function name");
 }
 
 const struct dxil_func *
diff --git a/src/microsoft/compiler/dxil_module.c b/src/microsoft/compiler/dxil_module.c
index 7be3cdf391829..ec24970230e1b 100644
--- a/src/microsoft/compiler/dxil_module.c
+++ b/src/microsoft/compiler/dxil_module.c
@@ -206,7 +206,7 @@ encode_char6(char ch)
    case '.': return 62;
    case '_': return 63;
    default:
-      unreachable("invalid char6-character");
+      UNREACHABLE("invalid char6-character");
    }
 }
 
@@ -311,7 +311,7 @@ emit_record_abbrev(struct dxil_buffer *b,
             break;
 
          default:
-            unreachable("unexpected operand type");
+            UNREACHABLE("unexpected operand type");
          }
          return true; /* we're done */
 
@@ -322,10 +322,10 @@ emit_record_abbrev(struct dxil_buffer *b,
          break;
 
       case DXIL_OP_BLOB:
-         unreachable("HALP, unplement!");
+         UNREACHABLE("HALP, unplement!");
 
       default:
-         unreachable("unexpected operand type");
+         UNREACHABLE("unexpected operand type");
       }
    }
 
@@ -424,7 +424,7 @@ dxil_type_to_nir_type(const struct dxil_type *type)
    case TYPE_FLOAT:
       return nir_type_float;
    default:
-      unreachable("Unexpected type in dxil_type_to_nir_type");
+      UNREACHABLE("Unexpected type in dxil_type_to_nir_type");
    }
 }
 
@@ -523,7 +523,7 @@ dxil_module_get_int_type(struct dxil_module *m, unsigned bit_size)
    case 32: return get_int32_type(m);
    case 64: return get_int64_type(m);
    default:
-      unreachable("unsupported bit-width");
+      UNREACHABLE("unsupported bit-width");
    }
 }
 
@@ -559,7 +559,7 @@ dxil_module_get_float_type(struct dxil_module *m, unsigned bit_size)
    case 32: return get_float32_type(m);
    case 64: return get_float64_type(m);
    default:
-      unreachable("unsupported bit-width");
+      UNREACHABLE("unsupported bit-width");
    }
    return get_float32_type(m);
 }
@@ -684,7 +684,7 @@ dxil_get_overload_type(struct dxil_module *mod, enum overload_type overload)
    case DXIL_F32: return get_float32_type(mod);
    case DXIL_F64: return get_float64_type(mod);
    default:
-      unreachable("unexpected overload type");
+      UNREACHABLE("unexpected overload type");
    }
 }
 
@@ -727,7 +727,7 @@ dxil_module_get_cbuf_ret_type(struct dxil_module *mod, enum overload_type overlo
       additional = ".8";
       break;
    default:
-      unreachable("unexpected overload type");
+      UNREACHABLE("unexpected overload type");
    }
    snprintf(name, sizeof(name), "dx.types.CBufRet.%s%s", dxil_overload_suffix(overload), additional);
 
@@ -759,7 +759,7 @@ dxil_module_get_type_from_comp_type(struct dxil_module *m, enum dxil_component_t
 
    case DXIL_COMP_TYPE_F16:
    default:
-      unreachable("unexpected component type");
+      UNREACHABLE("unexpected component type");
    }
 }
 
@@ -774,7 +774,7 @@ get_res_comp_type_name(enum dxil_component_type comp_type)
    case DXIL_COMP_TYPE_I64: return "int64";
    case DXIL_COMP_TYPE_U64: return "uint64";
    default:
-      unreachable("unexpected resource component type");
+      UNREACHABLE("unexpected resource component type");
    }
 }
 
@@ -793,7 +793,7 @@ get_res_dimension_type_name(enum dxil_resource_kind kind)
    case DXIL_RESOURCE_KIND_TEXTURECUBE: return "TextureCube";
    case DXIL_RESOURCE_KIND_TEXTURECUBE_ARRAY: return "TextureCubeArray";
    default:
-      unreachable("unexpected resource kind");
+      UNREACHABLE("unexpected resource kind");
    }
 }
 
@@ -852,7 +852,7 @@ dxil_module_get_res_type(struct dxil_module *m, enum dxil_resource_kind kind,
    }
 
    default:
-      unreachable("resource type not supported");
+      UNREACHABLE("resource type not supported");
    }
 }
 
@@ -876,7 +876,7 @@ dxil_module_get_resret_type(struct dxil_module *m, enum overload_type overload)
    case DXIL_F32: name = "dx.types.ResRet.f32"; break;
    case DXIL_F64: name = "dx.types.ResRet.f64"; break;
    default:
-      unreachable("unexpected overload type");
+      UNREACHABLE("unexpected overload type");
    }
 
    return dxil_module_get_struct_type(m, name, resret, 5);
@@ -1363,7 +1363,7 @@ emit_attrib_group(struct dxil_module *m, int id, uint32_t slot,
          break;
 
       default:
-         unreachable("unsupported attrib type");
+         UNREACHABLE("unsupported attrib type");
       }
    }
 
@@ -1423,7 +1423,7 @@ emit_float_type(struct dxil_module *m, unsigned bit_size)
    case 32: return emit_record(m, TYPE_CODE_FLOAT, NULL, 0);
    case 64: return emit_record(m, TYPE_CODE_DOUBLE, NULL, 0);
    default:
-      unreachable("unexpected bit_size for float type");
+      UNREACHABLE("unexpected bit_size for float type");
    }
 }
 
@@ -1569,7 +1569,7 @@ emit_type(struct dxil_module *m, struct dxil_type *type)
       return emit_vector_type(m, type);
 
    default:
-      unreachable("unexpected type->type");
+      UNREACHABLE("unexpected type->type");
    }
 }
 
@@ -1711,7 +1711,7 @@ dxil_module_get_int_const(struct dxil_module *m, intmax_t value,
       return dxil_module_get_int64_const(m, value);
 
    default:
-      unreachable("unsupported bit-width");
+      UNREACHABLE("unsupported bit-width");
    }
 }
 
@@ -2015,13 +2015,13 @@ fill_res_props_dwords(uint32_t dwords[2],
       dwords[0] = get_sampler_res_props_dword(get_int_from_mdnode(mdnode, 6) == DXIL_SAMPLER_KIND_COMPARISON);
       break;
    default:
-      unreachable("Unexpected resource class");
+      UNREACHABLE("Unexpected resource class");
    }
 
    switch (kind) {
    case DXIL_RESOURCE_KIND_STRUCTURED_BUFFER:
    case DXIL_RESOURCE_KIND_INVALID:
-      unreachable("Unimplemented");
+      UNREACHABLE("Unimplemented");
    case DXIL_RESOURCE_KIND_RAW_BUFFER:
    case DXIL_RESOURCE_KIND_SAMPLER:
       dwords[1] = 0;
@@ -2075,7 +2075,7 @@ comp_type_from_alu_type(nir_alu_type type)
    case nir_type_int: return DXIL_COMP_TYPE_I32;
    case nir_type_uint: return DXIL_COMP_TYPE_U32;
    case nir_type_float: return DXIL_COMP_TYPE_F32;
-   default: unreachable("Unexpected component type");
+   default: UNREACHABLE("Unexpected component type");
    }
 }
 
@@ -2332,7 +2332,7 @@ static bool attrs_equal(const struct dxil_attrib *a, const struct dxil_attrib *b
       return (a->key.str == b->key.str || !strcmp(a->key.str, b->key.str)) &&
          (a->value.str == b->value.str || !strcmp(a->value.str, b->value.str));
    default:
-      unreachable("Invalid attr type");
+      UNREACHABLE("Invalid attr type");
    }
 }
 
@@ -2690,7 +2690,7 @@ emit_consts(struct dxil_module *m)
                return false;
             break;
          default:
-            unreachable("unexpected float_bits");
+            UNREACHABLE("unexpected float_bits");
          }
          break;
 
@@ -2707,7 +2707,7 @@ emit_consts(struct dxil_module *m)
          break;
 
       default:
-         unreachable("unsupported constant type");
+         UNREACHABLE("unsupported constant type");
       }
    }
 
@@ -3049,7 +3049,7 @@ emit_mdnode(struct dxil_module *m, struct dxil_mdnode *n)
       return emit_metadata_node(m, n->node.subnodes, n->node.num_subnodes);
 
    default:
-      unreachable("unexpected n->type");
+      UNREACHABLE("unexpected n->type");
    }
 }
 
@@ -3411,7 +3411,7 @@ get_deref_type(const struct dxil_type *type)
    switch (type->type) {
    case TYPE_POINTER: return type->ptr_target_type;
    case TYPE_ARRAY: return type->array_or_vector_def.elem_type;
-   default: unreachable("unexpected type");
+   default: UNREACHABLE("unexpected type");
    }
 }
 
@@ -3880,7 +3880,7 @@ emit_instr(struct dxil_module *m, struct dxil_func_def *func, struct dxil_instr
       return emit_cmpxchg(m, instr);
 
    default:
-      unreachable("unexpected instruction type");
+      UNREACHABLE("unexpected instruction type");
    }
 }
 
diff --git a/src/microsoft/compiler/dxil_nir.c b/src/microsoft/compiler/dxil_nir.c
index 27cffc88bf934..4b1bd8034d25a 100644
--- a/src/microsoft/compiler/dxil_nir.c
+++ b/src/microsoft/compiler/dxil_nir.c
@@ -516,7 +516,7 @@ lower_var_bit_size_types(nir_variable *var, unsigned min_bit_size, unsigned max_
                var->constant_initializer->elements[i]->values[0].i16 = var->constant_initializer->elements[i]->values[0].i8;
             break;
          case GLSL_TYPE_UINT8: base_type = GLSL_TYPE_UINT16; break;
-         default: unreachable("Unexpected base type");
+         default: UNREACHABLE("Unexpected base type");
          }
          break;
       case 32:
@@ -543,10 +543,10 @@ lower_var_bit_size_types(nir_variable *var, unsigned min_bit_size, unsigned max_
             break;
          case GLSL_TYPE_UINT8: base_type = GLSL_TYPE_UINT; break;
          case GLSL_TYPE_UINT16: base_type = GLSL_TYPE_UINT; break;
-         default: unreachable("Unexpected base type");
+         default: UNREACHABLE("Unexpected base type");
          }
          break;
-      default: unreachable("Unexpected min bit size");
+      default: UNREACHABLE("Unexpected min bit size");
       }
       var->type = glsl_type_wrap_in_arrays(glsl_scalar_type(base_type), var->type);
       return true;
@@ -2016,7 +2016,7 @@ get_cast_type(unsigned bit_size)
    case 8:
       return glsl_int8_t_type();
    }
-   unreachable("Invalid bit_size");
+   UNREACHABLE("Invalid bit_size");
 }
 
 static nir_def *
@@ -2420,7 +2420,7 @@ propagate_input_to_output_dependencies(struct dxil_module *mod, nir_intrinsic_in
             }
             break;
          default:
-            unreachable("Don't expect any other jumps");
+            UNREACHABLE("Don't expect any other jumps");
          }
          break;
       }
@@ -2511,7 +2511,7 @@ get_format_for_var(unsigned num_comps, enum glsl_base_type sampled_type)
       case 2: return PIPE_FORMAT_R32G32_SINT;
       case 3: return PIPE_FORMAT_R32G32B32_SINT;
       case 4: return PIPE_FORMAT_R32G32B32A32_SINT;
-      default: unreachable("Invalid num_comps");
+      default: UNREACHABLE("Invalid num_comps");
       }
    case GLSL_TYPE_UINT:
    case GLSL_TYPE_UINT64:
@@ -2521,7 +2521,7 @@ get_format_for_var(unsigned num_comps, enum glsl_base_type sampled_type)
       case 2: return PIPE_FORMAT_R32G32_UINT;
       case 3: return PIPE_FORMAT_R32G32B32_UINT;
       case 4: return PIPE_FORMAT_R32G32B32A32_UINT;
-      default: unreachable("Invalid num_comps");
+      default: UNREACHABLE("Invalid num_comps");
       }
    case GLSL_TYPE_FLOAT:
    case GLSL_TYPE_FLOAT16:
@@ -2531,9 +2531,9 @@ get_format_for_var(unsigned num_comps, enum glsl_base_type sampled_type)
       case 2: return PIPE_FORMAT_R32G32_FLOAT;
       case 3: return PIPE_FORMAT_R32G32B32_FLOAT;
       case 4: return PIPE_FORMAT_R32G32B32A32_FLOAT;
-      default: unreachable("Invalid num_comps");
+      default: UNREACHABLE("Invalid num_comps");
       }
-   default: unreachable("Invalid sampler return type");
+   default: UNREACHABLE("Invalid sampler return type");
    }
 }
 
diff --git a/src/microsoft/compiler/dxil_nir_lower_int_cubemaps.c b/src/microsoft/compiler/dxil_nir_lower_int_cubemaps.c
index 3e0cbc09ced33..3809d994a996d 100644
--- a/src/microsoft/compiler/dxil_nir_lower_int_cubemaps.c
+++ b/src/microsoft/compiler/dxil_nir_lower_int_cubemaps.c
@@ -497,7 +497,7 @@ lower_int_cubemap_to_array_tex(nir_builder *b, nir_tex_instr *tex)
    case nir_texop_txs:
       return lower_cube_txs(b, tex);
    default:
-      unreachable("Unsupported cupe map texture operation");
+      UNREACHABLE("Unsupported cupe map texture operation");
    }
 }
 
diff --git a/src/microsoft/compiler/dxil_nir_lower_int_samplers.c b/src/microsoft/compiler/dxil_nir_lower_int_samplers.c
index c5b6b40231b29..9198ce4122e33 100644
--- a/src/microsoft/compiler/dxil_nir_lower_int_samplers.c
+++ b/src/microsoft/compiler/dxil_nir_lower_int_samplers.c
@@ -254,7 +254,7 @@ load_bordercolor(nir_builder *b, nir_tex_instr *tex, const dxil_wrap_sampler_sta
          const_value[i] = nir_const_value_for_uint(border_color[swizzle[i]], 32);
          break;
       default:
-         unreachable("Unexpected swizzle value");
+         UNREACHABLE("Unexpected swizzle value");
       }
    }
 
@@ -491,7 +491,7 @@ lower_sample_to_txf_for_integer_tex_impl(nir_builder *b, nir_instr *instr,
                                     array_index);
             break;
          default:
-            unreachable("unsupported number of non-array coordinates");
+            UNREACHABLE("unsupported number of non-array coordinates");
          }
       }
    }
diff --git a/src/microsoft/compiler/dxil_nir_lower_vs_vertex_conversion.c b/src/microsoft/compiler/dxil_nir_lower_vs_vertex_conversion.c
index 40c81f80a8ab1..37f3ff25a709b 100644
--- a/src/microsoft/compiler/dxil_nir_lower_vs_vertex_conversion.c
+++ b/src/microsoft/compiler/dxil_nir_lower_vs_vertex_conversion.c
@@ -140,7 +140,7 @@ lower_vs_vertex_conversion_impl(nir_builder *b, nir_instr *instr, void *options)
          return nir_i2f32(b, &intr->def);
 
       default:
-         unreachable("Unsupported emulated vertex format");
+         UNREACHABLE("Unsupported emulated vertex format");
       }
    }
 }
diff --git a/src/microsoft/compiler/dxil_signature.c b/src/microsoft/compiler/dxil_signature.c
index 35b2e0844b02f..134ec635c1f8b 100644
--- a/src/microsoft/compiler/dxil_signature.c
+++ b/src/microsoft/compiler/dxil_signature.c
@@ -211,7 +211,7 @@ get_semantic_sv_name(nir_variable *var, struct semantic_info *info, gl_shader_st
       info->kind = DXIL_SEM_SAMPLE_INDEX;
       break;
    default:
-      unreachable("unsupported system value");
+      UNREACHABLE("unsupported system value");
    }
    strncpy(info->name, var->name, ARRAY_SIZE(info->name) - 1);
 }
@@ -372,14 +372,14 @@ prog_semantic_from_kind(enum dxil_semantic_kind kind, unsigned num_vals, unsigne
          DXIL_PROG_SEM_FINAL_LINE_DENSITY_TESSFACTOR :
          DXIL_PROG_SEM_FINAL_LINE_DETAIL_TESSFACTOR;
       default:
-         unreachable("Invalid row count for tess factor");
+         UNREACHABLE("Invalid row count for tess factor");
       }
    case DXIL_SEM_INSIDE_TESS_FACTOR:
       switch (num_vals) {
       case 2: return DXIL_PROG_SEM_FINAL_QUAD_INSIDE_EDGE_TESSFACTOR;
       case 1: return DXIL_PROG_SEM_FINAL_TRI_INSIDE_EDGE_TESSFACTOR;
       default:
-         unreachable("Invalid row count for inner tess factor");
+         UNREACHABLE("Invalid row count for inner tess factor");
       }
    default:
        return DXIL_PROG_SEM_UNDEFINED;
@@ -715,7 +715,7 @@ patch_sysvalue_name(nir_variable *var)
          return var->data.location_frac == 0 ?
             "LINEDET" : "LINEDEN";
       default:
-         unreachable("Unexpected outer tess factor array size");
+         UNREACHABLE("Unexpected outer tess factor array size");
       }
       break;
    case VARYING_SLOT_TESS_LEVEL_INNER:
@@ -725,7 +725,7 @@ patch_sysvalue_name(nir_variable *var)
       case 1:
          return "TRIINT";
       default:
-         unreachable("Unexpected inner tess factory array size");
+         UNREACHABLE("Unexpected inner tess factory array size");
       }
       break;
    default:
diff --git a/src/microsoft/compiler/nir_to_dxil.c b/src/microsoft/compiler/nir_to_dxil.c
index 5a10a33525681..b78e97d81cf14 100644
--- a/src/microsoft/compiler/nir_to_dxil.c
+++ b/src/microsoft/compiler/nir_to_dxil.c
@@ -74,7 +74,7 @@ static void
 default_logger_func(void *priv, const char *msg)
 {
    fprintf(stderr, "%s", msg);
-   unreachable("Unhandled error");
+   UNREACHABLE("Unhandled error");
 }
 
 static const struct dxil_logger default_logger = { .priv = NULL, .log = default_logger_func };
@@ -230,7 +230,7 @@ get_shader_kind_str(enum dxil_shader_kind kind)
    case DXIL_COMPUTE_SHADER:
       return "cs";
    default:
-      unreachable("invalid shader kind");
+      UNREACHABLE("invalid shader kind");
    }
 }
 
@@ -422,7 +422,7 @@ nir_atomic_to_dxil_atomic(nir_atomic_op op)
    case nir_atomic_op_umin: return DXIL_ATOMIC_UMIN;
    case nir_atomic_op_umax: return DXIL_ATOMIC_UMAX;
    case nir_atomic_op_xchg: return DXIL_ATOMIC_EXCHANGE;
-   default: unreachable("Unsupported atomic op");
+   default: UNREACHABLE("Unsupported atomic op");
    }
 }
 
@@ -439,7 +439,7 @@ nir_atomic_to_dxil_rmw(nir_atomic_op op)
    case nir_atomic_op_umin: return DXIL_RMWOP_UMIN;
    case nir_atomic_op_umax: return DXIL_RMWOP_UMAX;
    case nir_atomic_op_xchg: return DXIL_RMWOP_XCHG;
-   default: unreachable("Unsupported atomic op");
+   default: UNREACHABLE("Unsupported atomic op");
    }
 }
 
@@ -487,7 +487,7 @@ emit_srv_metadata(struct dxil_module *m, const struct dxil_type *elem_type,
    } else if (res_kind == DXIL_RESOURCE_KIND_RAW_BUFFER)
       fields[8] = NULL;
    else
-      unreachable("Structured buffers not supported yet");
+      UNREACHABLE("Structured buffers not supported yet");
 
    return dxil_get_metadata_node(m, fields, ARRAY_SIZE(fields));
 }
@@ -516,7 +516,7 @@ emit_uav_metadata(struct dxil_module *m, const struct dxil_type *struct_type,
    } else if (res_kind == DXIL_RESOURCE_KIND_RAW_BUFFER)
       fields[10] = NULL;
    else
-      unreachable("Structured buffers not supported yet");
+      UNREACHABLE("Structured buffers not supported yet");
 
    return dxil_get_metadata_node(m, fields, ARRAY_SIZE(fields));
 }
@@ -1073,7 +1073,7 @@ emit_annotate_handle_from_metadata(struct ntd_context *ctx,
       mdnodes = &ctx->sampler_metadata_nodes;
       break;
    default:
-      unreachable("Invalid resource class");
+      UNREACHABLE("Invalid resource class");
    }
 
    const struct dxil_mdnode *mdnode = *util_dynarray_element(mdnodes, const struct dxil_mdnode *, resource_range_id);
@@ -1279,7 +1279,7 @@ emit_createhandle_call_dynamic(struct ntd_context *ctx,
       }
    }
 
-   unreachable("Resource access for undeclared range");
+   UNREACHABLE("Resource access for undeclared range");
 }
 
 static bool
@@ -1413,7 +1413,7 @@ get_value_for_const(struct dxil_module *mod, nir_const_value *c, const struct dx
       mod->feats.doubles = true;
       return dxil_module_get_double_const(mod, c->f64);
    }
-   unreachable("Invalid type");
+   UNREACHABLE("Invalid type");
 }
 
 static const struct dxil_type *
@@ -1655,7 +1655,7 @@ emit_static_indexing_handles(struct ntd_context *ctx)
          handle_array = ctx->image_handles;
          break;
       default:
-         unreachable("Unexpected resource type");
+         UNREACHABLE("Unexpected resource type");
       }
 
       if (last_res_class != res_class)
@@ -1722,7 +1722,7 @@ get_tessellator_domain(enum tess_primitive_mode primitive_mode)
    case TESS_PRIMITIVE_TRIANGLES: return DXIL_TESSELLATOR_DOMAIN_TRI;
    case TESS_PRIMITIVE_ISOLINES: return DXIL_TESSELLATOR_DOMAIN_ISOLINE;
    default:
-      unreachable("Invalid tessellator primitive mode");
+      UNREACHABLE("Invalid tessellator primitive mode");
    }
 }
 
@@ -2253,7 +2253,7 @@ get_src(struct ntd_context *ctx, nir_src *src, unsigned chan,
       return value;
 
    default:
-      unreachable("unexpected nir_alu_type");
+      UNREACHABLE("unexpected nir_alu_type");
    }
 }
 
@@ -2407,7 +2407,7 @@ get_cast_op(nir_alu_instr *alu)
       return DXIL_CAST_UITOFP;
 
    default:
-      unreachable("unexpected cast op");
+      UNREACHABLE("unexpected cast op");
    }
 }
 
@@ -2427,7 +2427,7 @@ get_cast_dest_type(struct ntd_context *ctx, nir_alu_instr *alu)
       return dxil_module_get_float_type(&ctx->mod, dst_bits);
 
    default:
-      unreachable("unknown nir_alu_type");
+      UNREACHABLE("unknown nir_alu_type");
    }
 }
 
@@ -2498,7 +2498,7 @@ get_overload(nir_alu_type alu_type, unsigned bit_size)
       case 32: return DXIL_I32;
       case 64: return DXIL_I64;
       default:
-         unreachable("unexpected bit_size");
+         UNREACHABLE("unexpected bit_size");
       }
    case nir_type_float:
       switch (bit_size) {
@@ -2506,12 +2506,12 @@ get_overload(nir_alu_type alu_type, unsigned bit_size)
       case 32: return DXIL_F32;
       case 64: return DXIL_F64;
       default:
-         unreachable("unexpected bit_size");
+         UNREACHABLE("unexpected bit_size");
       }
    case nir_type_invalid:
       return DXIL_NONE;
    default:
-      unreachable("unexpected output type");
+      UNREACHABLE("unexpected output type");
    }
 }
 
@@ -2986,7 +2986,7 @@ emit_alu(struct ntd_context *ctx, nir_alu_instr *alu)
       case 64:
          one = dxil_module_get_double_const(&ctx->mod, 1.0);
          break;
-      default: unreachable("Invalid float size");
+      default: UNREACHABLE("Invalid float size");
       }
       return emit_binop(ctx, alu, DXIL_BINOP_SDIV, one, src[0]);
    }
@@ -3845,7 +3845,7 @@ emit_load_interpolated_input(struct ntd_context *ctx, nir_intrinsic_instr *intr)
       num_args = 4;
       break;
    default:
-      unreachable("Unsupported interpolation barycentric intrinsic");
+      UNREACHABLE("Unsupported interpolation barycentric intrinsic");
    }
    uint8_t io_index = ctx->mod.input_mappings[nir_intrinsic_base(intr)];
    args[0] = dxil_module_get_int32_const(&ctx->mod, opcode_val);
@@ -3905,7 +3905,7 @@ deref_to_gep(struct ntd_context *ctx, nir_deref_instr *deref)
    case nir_var_mem_constant: var_array = ctx->consts; break;
    case nir_var_mem_shared: var_array = ctx->sharedvars; break;
    case nir_var_function_temp: var_array = ctx->scratchvars; break;
-   default: unreachable("Invalid deref mode");
+   default: UNREACHABLE("Invalid deref mode");
    }
    gep_indices[0] = var_array[var->data.driver_location];
 
@@ -4489,7 +4489,7 @@ emit_load_vulkan_descriptor(struct ntd_context *ctx, nir_intrinsic_instr *intr)
       resource_kind = DXIL_RESOURCE_KIND_RAW_BUFFER;
       break;
    default:
-      unreachable("unknown descriptor type");
+      UNREACHABLE("unknown descriptor type");
       return false;
    }
 
@@ -4707,7 +4707,7 @@ get_reduce_bit_op(nir_op op)
    case nir_op_ixor: return DXIL_WAVE_BIT_OP_XOR;
    case nir_op_iand: return DXIL_WAVE_BIT_OP_AND;
    default:
-      unreachable("Invalid bit op");
+      UNREACHABLE("Invalid bit op");
    }
 }
 
@@ -4751,7 +4751,7 @@ get_reduce_op(nir_op op)
    case nir_op_fmin:
       return DXIL_WAVE_OP_MIN;
    default:
-      unreachable("Unexpected reduction op");
+      UNREACHABLE("Unexpected reduction op");
    }
 }
 
@@ -4832,7 +4832,7 @@ emit_intrinsic(struct ntd_context *ctx, nir_intrinsic_instr *intr)
          return emit_load_unary_external_function(ctx, intr, "dx.op.gsInstanceID",
                                                   DXIL_INTR_GS_INSTANCE_ID, nir_type_int);
       default:
-         unreachable("Unexpected shader kind for invocation ID");
+         UNREACHABLE("Unexpected shader kind for invocation ID");
       }
    case nir_intrinsic_load_view_index:
       ctx->mod.feats.view_id = true;
@@ -5025,7 +5025,7 @@ emit_deref(struct ntd_context* ctx, nir_deref_instr* instr)
          store_def(ctx, &instr->def, 0, dxil_module_get_int_const(&ctx->mod, instr->strct.index, 32));
          return true;
       default:
-         unreachable("Other deref types not supported");
+         UNREACHABLE("Other deref types not supported");
       }
    }
 
@@ -5114,7 +5114,7 @@ emit_jump(struct ntd_context *ctx, nir_jump_instr *instr)
       return emit_branch(ctx, instr->instr.block->successors[0]->index);
 
    default:
-      unreachable("Unsupported jump type\n");
+      UNREACHABLE("Unsupported jump type\n");
    }
 }
 
@@ -5599,11 +5599,11 @@ emit_tex(struct ntd_context *ctx, nir_tex_instr *instr)
          break;
 
       case nir_tex_src_projector:
-         unreachable("Texture projector should have been lowered");
+         UNREACHABLE("Texture projector should have been lowered");
 
       default:
          fprintf(stderr, "texture source: %d\n", instr->src[i].src_type);
-         unreachable("unknown texture source");
+         UNREACHABLE("unknown texture source");
       }
    }
 
@@ -5705,7 +5705,7 @@ emit_tex(struct ntd_context *ctx, nir_tex_instr *instr)
 
    default:
       fprintf(stderr, "texture op: %d\n", instr->op);
-      unreachable("unknown texture op");
+      UNREACHABLE("unknown texture op");
    }
 
    if (!sample)
@@ -5866,7 +5866,7 @@ emit_cf_list(struct ntd_context *ctx, struct exec_list *list)
          break;
 
       default:
-         unreachable("unsupported cf-list node");
+         UNREACHABLE("unsupported cf-list node");
          break;
       }
    }
@@ -6198,7 +6198,7 @@ get_dxil_shader_kind(struct nir_shader *s)
    case MESA_SHADER_COMPUTE:
       return DXIL_COMPUTE_SHADER;
    default:
-      unreachable("unknown shader stage in nir_to_dxil");
+      UNREACHABLE("unknown shader stage in nir_to_dxil");
       return DXIL_COMPUTE_SHADER;
    }
 }
diff --git a/src/microsoft/vulkan/dzn_cmd_buffer.c b/src/microsoft/vulkan/dzn_cmd_buffer.c
index 9ac0382cb5242..2a895b73891bf 100644
--- a/src/microsoft/vulkan/dzn_cmd_buffer.c
+++ b/src/microsoft/vulkan/dzn_cmd_buffer.c
@@ -1748,7 +1748,7 @@ heap_type_for_bucket(enum dzn_internal_buf_bucket bucket)
    switch (bucket) {
    case DZN_INTERNAL_BUF_UPLOAD: return D3D12_HEAP_TYPE_UPLOAD;
    case DZN_INTERNAL_BUF_DEFAULT: return D3D12_HEAP_TYPE_DEFAULT;
-   default: unreachable("Invalid value");
+   default: UNREACHABLE("Invalid value");
    }
 }
 
@@ -2721,7 +2721,7 @@ dzn_cmd_buffer_blit_prepare_src_view(struct dzn_cmd_buffer *cmdbuf,
       iview_info.viewType = VK_IMAGE_VIEW_TYPE_3D;
       break;
    default:
-      unreachable("Invalid type");
+      UNREACHABLE("Invalid type");
    }
 
    struct dzn_image_view iview;
@@ -3075,7 +3075,7 @@ get_blit_resolve_mode(VkResolveModeFlagBits mode)
    case VK_RESOLVE_MODE_MIN_BIT: return dzn_blit_resolve_min;
    case VK_RESOLVE_MODE_MAX_BIT: return dzn_blit_resolve_max;
    case VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: return dzn_blit_resolve_sample_zero;
-   default: unreachable("Unexpected resolve mode");
+   default: UNREACHABLE("Unexpected resolve mode");
    }
 }
 
@@ -5506,7 +5506,7 @@ dzn_CmdBindIndexBuffer(VkCommandBuffer commandBuffer,
       cmdbuf->state.ib.view.Format = DXGI_FORMAT_R32_UINT;
       cmdbuf->state.pipeline_variant.ib_strip_cut = D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF;
       break;
-   default: unreachable("Invalid index type");
+   default: UNREACHABLE("Invalid index type");
    }
 
    cmdbuf->state.dirty |= DZN_CMD_DIRTY_IB;
diff --git a/src/microsoft/vulkan/dzn_descriptor_set.c b/src/microsoft/vulkan/dzn_descriptor_set.c
index ec162956dd34d..368a3d66703d2 100644
--- a/src/microsoft/vulkan/dzn_descriptor_set.c
+++ b/src/microsoft/vulkan/dzn_descriptor_set.c
@@ -80,7 +80,7 @@ desc_type_to_range_type(VkDescriptorType in, bool writeable)
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
       return writeable ? D3D12_DESCRIPTOR_RANGE_TYPE_UAV : D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    default:
-      unreachable("Unsupported desc type");
+      UNREACHABLE("Unsupported desc type");
    }
 }
 
@@ -1120,7 +1120,7 @@ dzn_bindless_descriptor_set_write_image_view_desc(volatile struct dxil_spirv_bin
       map[desc_offset].texture_idx = iview->srv_bindless_slot;
       break;
    default:
-      unreachable("Unexpected descriptor type");
+      UNREACHABLE("Unexpected descriptor type");
    }
 }
 
@@ -1138,7 +1138,7 @@ dzn_bindless_descriptor_set_write_buffer_view_desc(volatile struct dxil_spirv_bi
       map[desc_offset].texture_idx = bview->uav_bindless_slot;
       break;
    default:
-      unreachable("Unexpected descriptor type");
+      UNREACHABLE("Unexpected descriptor type");
    }
 }
 
@@ -1277,7 +1277,7 @@ dzn_buffer_get_bindless_buffer_descriptor(struct dzn_device *device,
       slot = bdesc->buffer->uav_bindless_slot;
       break;
    default:
-      unreachable("Unexpected descriptor type");
+      UNREACHABLE("Unexpected descriptor type");
    }
 
    struct dzn_buffer_desc local_desc;
@@ -1794,7 +1794,7 @@ dzn_descriptor_pool_create(struct dzn_device *device,
          case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
             break;
          default:
-            unreachable("Unsupported desc type");
+            UNREACHABLE("Unsupported desc type");
          }
       }
    }
@@ -2231,7 +2231,7 @@ dzn_descriptor_set_write(struct dzn_device *device,
       break;
 
    default:
-      unreachable("invalid descriptor type");
+      UNREACHABLE("invalid descriptor type");
       break;
    }
 
@@ -2613,7 +2613,7 @@ dzn_UpdateDescriptorSetWithTemplate(VkDevice _device,
          break;
 
       default:
-         unreachable("invalid descriptor type");
+         UNREACHABLE("invalid descriptor type");
       }
    }
 }
diff --git a/src/microsoft/vulkan/dzn_device.c b/src/microsoft/vulkan/dzn_device.c
index 97fd13bed10d6..95092260dd5fd 100644
--- a/src/microsoft/vulkan/dzn_device.c
+++ b/src/microsoft/vulkan/dzn_device.c
@@ -1187,7 +1187,7 @@ dzn_get_most_capable_format_for_casting(VkFormat format, VkImageCreateFlags crea
    case 8: return DXGI_FORMAT_R32G32_FLOAT;
    case 12: return DXGI_FORMAT_R32G32B32_FLOAT;
    case 16: return DXGI_FORMAT_R32G32B32A32_FLOAT;
-   default: unreachable("Unsupported format bit size");;
+   default: UNREACHABLE("Unsupported format bit size");;
    }
 }
 
@@ -1555,7 +1555,7 @@ dzn_physical_device_get_image_format_properties(struct dzn_physical_device *pdev
       properties->imageFormatProperties.maxExtent.depth = max_extent;
       break;
    default:
-      unreachable("bad VkImageType");
+      UNREACHABLE("bad VkImageType");
    }
 
    /* From the Vulkan 1.0 spec, section 34.1.1. Supported Sample Counts:
@@ -3476,7 +3476,7 @@ dzn_sampler_translate_addr_mode(VkSamplerAddressMode in)
    case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: return D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
    case VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: return D3D12_TEXTURE_ADDRESS_MODE_BORDER;
    case VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: return D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE;
-   default: unreachable("Invalid address mode");
+   default: UNREACHABLE("Invalid address mode");
    }
 }
 
@@ -3584,7 +3584,7 @@ dzn_sampler_create(struct dzn_device *device,
          sampler->desc.Flags = D3D12_SAMPLER_FLAG_UINT_BORDER_COLOR;
          break;
       default:
-         unreachable("Unsupported border color");
+         UNREACHABLE("Unsupported border color");
       }
    }
 
@@ -3685,7 +3685,7 @@ dzn_CreateSamplerYcbcrConversion(VkDevice device,
                                  const VkAllocationCallbacks *pAllocator,
                                  VkSamplerYcbcrConversion *pYcbcrConversion)
 {
-   unreachable("Ycbcr sampler conversion is not supported");
+   UNREACHABLE("Ycbcr sampler conversion is not supported");
    return VK_SUCCESS;
 }
 
@@ -3694,7 +3694,7 @@ dzn_DestroySamplerYcbcrConversion(VkDevice device,
                                   VkSamplerYcbcrConversion YcbcrConversion,
                                   const VkAllocationCallbacks *pAllocator)
 {
-   unreachable("Ycbcr sampler conversion is not supported");
+   UNREACHABLE("Ycbcr sampler conversion is not supported");
 }
 
 VKAPI_ATTR VkDeviceAddress VKAPI_CALL
diff --git a/src/microsoft/vulkan/dzn_image.c b/src/microsoft/vulkan/dzn_image.c
index e20849e6bb93b..d05fc54f88656 100644
--- a/src/microsoft/vulkan/dzn_image.c
+++ b/src/microsoft/vulkan/dzn_image.c
@@ -486,7 +486,7 @@ dzn_image_get_dsv_desc(const struct dzn_image *image,
       }
       break;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 
    switch (dsv_desc.ViewDimension) {
@@ -513,7 +513,7 @@ dzn_image_get_dsv_desc(const struct dzn_image *image,
       dsv_desc.Texture2DMSArray.ArraySize = layer_count;
       break;
    default:
-      unreachable("Invalid view dimension");
+      UNREACHABLE("Invalid view dimension");
    }
 
    return dsv_desc;
@@ -556,7 +556,7 @@ dzn_image_get_rtv_desc(const struct dzn_image *image,
    case VK_IMAGE_TYPE_3D:
       rtv_desc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE3D;
       break;
-   default: unreachable("Invalid image type\n");
+   default: UNREACHABLE("Invalid image type\n");
    }
 
    switch (rtv_desc.ViewDimension) {
@@ -601,7 +601,7 @@ dzn_image_get_rtv_desc(const struct dzn_image *image,
          range->layerCount == VK_REMAINING_ARRAY_LAYERS ? -1 : layer_count;
       break;
    default:
-      unreachable("Invalid ViewDimension");
+      UNREACHABLE("Invalid ViewDimension");
    }
 
    return rtv_desc;
@@ -663,7 +663,7 @@ dzn_image_layout_to_state(const struct dzn_image *image,
       return D3D12_RESOURCE_STATE_COMMON;
 
    default:
-      unreachable("not implemented");
+      UNREACHABLE("not implemented");
    }
 }
 
@@ -983,7 +983,7 @@ translate_swizzle(VkComponentSwizzle in, uint32_t comp)
       return D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2;
    case VK_COMPONENT_SWIZZLE_A:
       return D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3;
-   default: unreachable("Invalid swizzle");
+   default: UNREACHABLE("Invalid swizzle");
    }
 }
 
@@ -1136,7 +1136,7 @@ dzn_image_view_prepare_srv_desc(struct dzn_image_view *iview)
       iview->srv_desc.Texture3D.ResourceMinLODClamp = 0.0f;
       break;
 
-   default: unreachable("Invalid view type");
+   default: UNREACHABLE("Invalid view type");
    }
 }
 
@@ -1192,7 +1192,7 @@ dzn_image_view_prepare_uav_desc(struct dzn_image_view *iview)
       iview->uav_desc.Texture3D.FirstWSlice = 0;
       iview->uav_desc.Texture3D.WSize = iview->vk.extent.depth;
       break;
-   default: unreachable("Invalid type");
+   default: UNREACHABLE("Invalid type");
    }
 }
 
@@ -1264,7 +1264,7 @@ dzn_image_view_prepare_rtv_desc(struct dzn_image_view *iview)
       iview->rtv_desc.Texture3D.WSize = iview->vk.extent.depth;
       break;
 
-   default: unreachable("Invalid view type");
+   default: UNREACHABLE("Invalid view type");
    }
 }
 
@@ -1318,7 +1318,7 @@ dzn_image_view_prepare_dsv_desc(struct dzn_image_view *iview)
       }
       break;
 
-   default: unreachable("Invalid view type");
+   default: UNREACHABLE("Invalid view type");
    }
 }
 
@@ -1358,7 +1358,7 @@ dzn_image_view_init(struct dzn_device *device,
 
    switch (image->vk.image_type) {
    default:
-      unreachable("bad VkImageType");
+      UNREACHABLE("bad VkImageType");
    case VK_IMAGE_TYPE_1D:
    case VK_IMAGE_TYPE_2D:
       assert(range->baseArrayLayer + dzn_get_layer_count(image, range) - 1 <= image->vk.array_layers);
diff --git a/src/microsoft/vulkan/dzn_pipeline.c b/src/microsoft/vulkan/dzn_pipeline.c
index 79d4b7d5058ce..e18fcd77e168f 100644
--- a/src/microsoft/vulkan/dzn_pipeline.c
+++ b/src/microsoft/vulkan/dzn_pipeline.c
@@ -197,7 +197,7 @@ to_dxil_shader_stage(VkShaderStageFlagBits in)
    case VK_SHADER_STAGE_GEOMETRY_BIT: return DXIL_SPIRV_SHADER_GEOMETRY;
    case VK_SHADER_STAGE_FRAGMENT_BIT: return DXIL_SPIRV_SHADER_FRAGMENT;
    case VK_SHADER_STAGE_COMPUTE_BIT: return DXIL_SPIRV_SHADER_COMPUTE;
-   default: unreachable("Unsupported stage");
+   default: UNREACHABLE("Unsupported stage");
    }
 }
 
@@ -336,7 +336,7 @@ adjust_to_bindless_cb(struct dxil_spirv_binding_remapping *inout, void *context)
       inout->binding = new_binding;
       break;
    default:
-      unreachable("Invalid binding type");
+      UNREACHABLE("Invalid binding type");
    }
 }
 
@@ -513,7 +513,7 @@ dzn_pipeline_get_gfx_shader_slot(D3D12_PIPELINE_STATE_STREAM_DESC *stream,
       d3d12_gfx_pipeline_state_stream_new_desc(stream, PS, D3D12_SHADER_BYTECODE, desc);
       return desc;
    }
-   default: unreachable("Unsupported stage");
+   default: UNREACHABLE("Unsupported stage");
    }
 }
 
@@ -1217,7 +1217,7 @@ to_prim_topology_type(VkPrimitiveTopology in)
       return D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
       return D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH;
-   default: unreachable("Invalid primitive topology");
+   default: UNREACHABLE("Invalid primitive topology");
    }
 }
 
@@ -1240,7 +1240,7 @@ to_prim_topology(VkPrimitiveTopology in, unsigned patch_control_points, bool sup
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
       assert(patch_control_points);
       return (D3D12_PRIMITIVE_TOPOLOGY)(D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST + patch_control_points - 1);
-   default: unreachable("Invalid primitive topology");
+   default: UNREACHABLE("Invalid primitive topology");
    }
 }
 
@@ -1293,7 +1293,7 @@ translate_polygon_mode(VkPolygonMode in)
    case VK_POLYGON_MODE_POINT:
       /* This is handled elsewhere */
       return D3D12_FILL_MODE_SOLID;
-   default: unreachable("Unsupported polygon mode");
+   default: UNREACHABLE("Unsupported polygon mode");
    }
 }
 
@@ -1306,7 +1306,7 @@ translate_cull_mode(VkCullModeFlags in)
    case VK_CULL_MODE_BACK_BIT: return D3D12_CULL_MODE_BACK;
    /* Front+back face culling is equivalent to 'rasterization disabled' */
    case VK_CULL_MODE_FRONT_AND_BACK: return D3D12_CULL_MODE_NONE;
-   default: unreachable("Unsupported cull mode");
+   default: UNREACHABLE("Unsupported cull mode");
    }
 }
 
@@ -1437,7 +1437,7 @@ translate_stencil_op(VkStencilOp in)
    case VK_STENCIL_OP_INCREMENT_AND_WRAP: return D3D12_STENCIL_OP_INCR;
    case VK_STENCIL_OP_DECREMENT_AND_WRAP: return D3D12_STENCIL_OP_DECR;
    case VK_STENCIL_OP_INVERT: return D3D12_STENCIL_OP_INVERT;
-   default: unreachable("Invalid stencil op");
+   default: UNREACHABLE("Invalid stencil op");
    }
 }
 
@@ -1650,7 +1650,7 @@ translate_blend_factor(VkBlendFactor in, bool is_alpha, bool support_alpha_blend
    case VK_BLEND_FACTOR_SRC1_ALPHA: return D3D12_BLEND_SRC1_ALPHA;
    case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: return D3D12_BLEND_INV_SRC1_ALPHA;
    case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE: return D3D12_BLEND_SRC_ALPHA_SAT;
-   default: unreachable("Invalid blend factor");
+   default: UNREACHABLE("Invalid blend factor");
    }
 }
 
@@ -1663,7 +1663,7 @@ translate_blend_op(VkBlendOp in)
    case VK_BLEND_OP_REVERSE_SUBTRACT: return D3D12_BLEND_OP_REV_SUBTRACT;
    case VK_BLEND_OP_MIN: return D3D12_BLEND_OP_MIN;
    case VK_BLEND_OP_MAX: return D3D12_BLEND_OP_MAX;
-   default: unreachable("Invalid blend op");
+   default: UNREACHABLE("Invalid blend op");
    }
 }
 
@@ -1687,7 +1687,7 @@ translate_logic_op(VkLogicOp in)
    case VK_LOGIC_OP_OR_INVERTED: return D3D12_LOGIC_OP_OR_INVERTED;
    case VK_LOGIC_OP_NAND: return D3D12_LOGIC_OP_NAND;
    case VK_LOGIC_OP_SET: return D3D12_LOGIC_OP_SET;
-   default: unreachable("Invalid logic op");
+   default: UNREACHABLE("Invalid logic op");
    }
 }
 
@@ -1946,7 +1946,7 @@ dzn_graphics_pipeline_create(struct dzn_device *device,
          case VK_DYNAMIC_STATE_LINE_WIDTH:
             /* Nothing to do since we just support lineWidth = 1. */
             break;
-         default: unreachable("Unsupported dynamic state");
+         default: UNREACHABLE("Unsupported dynamic state");
          }
       }
    }
diff --git a/src/microsoft/vulkan/dzn_private.h b/src/microsoft/vulkan/dzn_private.h
index 06f4b236a7482..27d7a3ab9f8ef 100644
--- a/src/microsoft/vulkan/dzn_private.h
+++ b/src/microsoft/vulkan/dzn_private.h
@@ -66,7 +66,7 @@
 #include "spirv_to_dxil.h"
 #include "dzn_abi_helper.h"
 
-#define dzn_stub() unreachable("Unsupported feature")
+#define dzn_stub() UNREACHABLE("Unsupported feature")
 
 #if defined(VK_USE_PLATFORM_WIN32_KHR) || \
     defined(VK_USE_PLATFORM_WAYLAND_KHR) || \
@@ -102,7 +102,7 @@ dzn_index_type_from_size(uint8_t index_size)
    case 0: return DZN_NO_INDEX;
    case 2: return DZN_INDEX_2B;
    case 4: return DZN_INDEX_4B;
-   default: unreachable("Invalid index size");
+   default: UNREACHABLE("Invalid index size");
    }
 }
 
@@ -115,7 +115,7 @@ dzn_index_type_from_dxgi_format(DXGI_FORMAT format, bool prim_restart)
       return prim_restart ? DZN_INDEX_2B_WITH_PRIM_RESTART : DZN_INDEX_2B;
    case DXGI_FORMAT_R32_UINT:
       return prim_restart ? DZN_INDEX_4B_WITH_PRIM_RESTART : DZN_INDEX_4B;
-   default: unreachable("Invalid index format");
+   default: UNREACHABLE("Invalid index format");
    }
 }
 
@@ -131,7 +131,7 @@ dzn_index_size(enum dzn_index_type type)
    case DZN_INDEX_4B_WITH_PRIM_RESTART:
    case DZN_INDEX_4B:
       return 4;
-   default: unreachable("Invalid index type");
+   default: UNREACHABLE("Invalid index type");
    }
 }
 
diff --git a/src/microsoft/vulkan/dzn_query.c b/src/microsoft/vulkan/dzn_query.c
index be49e54f83e3e..da885c863037b 100644
--- a/src/microsoft/vulkan/dzn_query.c
+++ b/src/microsoft/vulkan/dzn_query.c
@@ -37,7 +37,7 @@ dzn_query_pool_get_heap_type(VkQueryType in)
    case VK_QUERY_TYPE_OCCLUSION: return D3D12_QUERY_HEAP_TYPE_OCCLUSION;
    case VK_QUERY_TYPE_PIPELINE_STATISTICS: return D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS;
    case VK_QUERY_TYPE_TIMESTAMP: return D3D12_QUERY_HEAP_TYPE_TIMESTAMP;
-   default: unreachable("Unsupported query type");
+   default: UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -51,7 +51,7 @@ dzn_query_pool_get_query_type(const struct dzn_query_pool *qpool,
              D3D12_QUERY_TYPE_OCCLUSION : D3D12_QUERY_TYPE_BINARY_OCCLUSION;
    case D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS: return D3D12_QUERY_TYPE_PIPELINE_STATISTICS;
    case D3D12_QUERY_HEAP_TYPE_TIMESTAMP: return D3D12_QUERY_TYPE_TIMESTAMP;
-   default: unreachable("Unsupported query type");
+   default: UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -129,7 +129,7 @@ dzn_query_pool_create(struct dzn_device *device,
       qpool->pipeline_statistics = info->pipelineStatistics;
       qpool->query_size = sizeof(D3D12_QUERY_DATA_PIPELINE_STATISTICS);
       break;
-   default: unreachable("Unsupported query type");
+   default: UNREACHABLE("Unsupported query type");
    }
 
    D3D12_HEAP_PROPERTIES hprops =
diff --git a/src/microsoft/vulkan/dzn_util.c b/src/microsoft/vulkan/dzn_util.c
index 550106a6a1f06..8d9c437aa87ea 100644
--- a/src/microsoft/vulkan/dzn_util.c
+++ b/src/microsoft/vulkan/dzn_util.c
@@ -266,7 +266,7 @@ dzn_translate_compare_op(VkCompareOp in)
    case VK_COMPARE_OP_NOT_EQUAL: return D3D12_COMPARISON_FUNC_NOT_EQUAL;
    case VK_COMPARE_OP_GREATER_OR_EQUAL: return D3D12_COMPARISON_FUNC_GREATER_EQUAL;
    case VK_COMPARE_OP_ALWAYS: return D3D12_COMPARISON_FUNC_ALWAYS;
-   default: unreachable("Invalid compare op");
+   default: UNREACHABLE("Invalid compare op");
    }
 }
 
diff --git a/src/nouveau/compiler/nak_nir.c b/src/nouveau/compiler/nak_nir.c
index 1a3ae4d5c7085..fc03534600a05 100644
--- a/src/nouveau/compiler/nak_nir.c
+++ b/src/nouveau/compiler/nak_nir.c
@@ -55,7 +55,7 @@ nak_nir_workgroup_has_one_subgroup(const nir_shader *nir)
    case MESA_SHADER_TESS_EVAL:
    case MESA_SHADER_GEOMETRY:
    case MESA_SHADER_FRAGMENT:
-      unreachable("Shader stage does not have workgroups");
+      UNREACHABLE("Shader stage does not have workgroups");
       break;
 
    case MESA_SHADER_TESS_CTRL:
@@ -78,7 +78,7 @@ nak_nir_workgroup_has_one_subgroup(const nir_shader *nir)
    }
 
    default:
-      unreachable("Unknown shader stage");
+      UNREACHABLE("Unknown shader stage");
    }
 }
 
@@ -395,7 +395,7 @@ nak_varying_attr_addr(const struct nak_compiler *nak, gl_varying_slot slot)
       case VARYING_SLOT_PRIMITIVE_SHADING_RATE:
          return nak->sm >= 86 ? NAK_ATTR_VPRS_TABLE_INDEX
                               : NAK_ATTR_VIEWPORT_INDEX;
-      default: unreachable("Invalid varying slot");
+      default: UNREACHABLE("Invalid varying slot");
       }
    }
 }
@@ -409,10 +409,10 @@ nak_fs_out_addr(gl_frag_result slot, uint32_t blend_idx)
       return NAK_FS_OUT_DEPTH;
 
    case FRAG_RESULT_STENCIL:
-      unreachable("EXT_shader_stencil_export not supported");
+      UNREACHABLE("EXT_shader_stencil_export not supported");
 
    case FRAG_RESULT_COLOR:
-      unreachable("Vulkan alway uses explicit locations");
+      UNREACHABLE("Vulkan alway uses explicit locations");
 
    case FRAG_RESULT_SAMPLE_MASK:
       assert(blend_idx == 0);
@@ -436,7 +436,7 @@ nak_sysval_attr_addr(const struct nak_compiler *nak, gl_system_value sysval)
    case SYSTEM_VALUE_VERTEX_ID:     return NAK_ATTR_VERTEX_ID;
    case SYSTEM_VALUE_FRONT_FACE:    return NAK_ATTR_FRONT_FACE;
    case SYSTEM_VALUE_LAYER_ID:      return NAK_ATTR_RT_ARRAY_INDEX;
-   default: unreachable("Invalid system value");
+   default: UNREACHABLE("Invalid system value");
    }
 }
 
@@ -455,7 +455,7 @@ nak_sysval_sysval_idx(gl_system_value sysval)
    case SYSTEM_VALUE_SUBGROUP_LE_MASK:       return NAK_SV_LANEMASK_LE;
    case SYSTEM_VALUE_SUBGROUP_GT_MASK:       return NAK_SV_LANEMASK_GT;
    case SYSTEM_VALUE_SUBGROUP_GE_MASK:       return NAK_SV_LANEMASK_GE;
-   default: unreachable("Invalid system value");
+   default: UNREACHABLE("Invalid system value");
    }
 }
 
@@ -1089,7 +1089,7 @@ nak_postprocess_nir(nir_shader *nir,
       break;
 
    default:
-      unreachable("Unsupported shader stage");
+      UNREACHABLE("Unsupported shader stage");
    }
 
    OPT(nir, nir_lower_doubles, NULL, nak->nir_options.lower_doubles_options);
diff --git a/src/nouveau/compiler/nak_nir_lower_cf.c b/src/nouveau/compiler/nak_nir_lower_cf.c
index d1e20cf52ea6e..dc40a76d92218 100644
--- a/src/nouveau/compiler/nak_nir_lower_cf.c
+++ b/src/nouveau/compiler/nak_nir_lower_cf.c
@@ -107,7 +107,7 @@ jump_target_scope_type(nir_jump_type jump_type)
    case nir_jump_break:    return SCOPE_TYPE_LOOP_BREAK;
    case nir_jump_continue: return SCOPE_TYPE_LOOP_CONT;
    default:
-      unreachable("Unknown jump type");
+      UNREACHABLE("Unknown jump type");
    }
 }
 
@@ -223,10 +223,10 @@ parent_scope_will_sync(nir_cf_node *node, struct scope *parent_scope)
       return false;
 
    case SCOPE_TYPE_LOOP_BREAK:
-      unreachable("Loops must have a continue scope");
+      UNREACHABLE("Loops must have a continue scope");
 
    default:
-      unreachable("Unknown scope type");
+      UNREACHABLE("Unknown scope type");
    }
 }
 
@@ -373,7 +373,7 @@ lower_cf_list(nir_builder *b, nir_def *esc_reg, struct scope *parent_scope,
       }
 
       default:
-         unreachable("Unknown CF node type");
+         UNREACHABLE("Unknown CF node type");
       }
    }
 }
diff --git a/src/nouveau/compiler/nak_nir_lower_cmat.c b/src/nouveau/compiler/nak_nir_lower_cmat.c
index 3da5802e05783..c705a42781e34 100644
--- a/src/nouveau/compiler/nak_nir_lower_cmat.c
+++ b/src/nouveau/compiler/nak_nir_lower_cmat.c
@@ -60,7 +60,7 @@ get_nak_cmat_type_for_muladd(struct glsl_cmat_description a_desc,
        k == 16 && glsl_base_type_is_float(c_desc.element_type))
       return NAK_CMAT_TYPE_M16N16K16_FLOAT_SW;
 
-   unreachable("Unable to determine matrix muladd layout!");
+   UNREACHABLE("Unable to determine matrix muladd layout!");
 }
 
 enum nak_matrix_type_layout {
@@ -328,7 +328,7 @@ get_hw_nak_cmat_type(enum nak_cmat_type cmat_type, uint8_t sm)
    case NAK_CMAT_TYPE_M16N16K16_FLOAT_SW:
       return NAK_CMAT_TYPE_M16N8K16_FLOAT;
    default:
-      unreachable("Unknown Matrix muladd type.");
+      UNREACHABLE("Unknown Matrix muladd type.");
    }
 }
 
@@ -557,7 +557,7 @@ lower_cmat_convert(nir_builder *b, nir_intrinsic_instr *intr, nir_def *cmat,
             nir_channel(b, efgh, 3)
          );
       } else {
-         unreachable("unsupported component counts for Matrix layout conversion");
+         UNREACHABLE("unsupported component counts for Matrix layout conversion");
       }
    }
 
diff --git a/src/nouveau/compiler/nak_nir_lower_fs_inputs.c b/src/nouveau/compiler/nak_nir_lower_fs_inputs.c
index 67d35354e9202..e49e270bb9e15 100644
--- a/src/nouveau/compiler/nak_nir_lower_fs_inputs.c
+++ b/src/nouveau/compiler/nak_nir_lower_fs_inputs.c
@@ -91,7 +91,7 @@ interp_fs_input(nir_builder *b, unsigned num_components, uint32_t addr,
       }
       return nir_vec(b, comps, num_components);
    } else {
-      unreachable("Unsupported shader model");
+      UNREACHABLE("Unsupported shader model");
    }
 }
 
@@ -263,7 +263,7 @@ lower_fs_input_intrin(nir_builder *b, nir_intrinsic_instr *intrin, void *data)
          interp_loc = NAK_INTERP_LOC_DEFAULT;
          break;
       default:
-         unreachable("Unknown intrinsic");
+         UNREACHABLE("Unknown intrinsic");
       }
 
       nir_def *inv_w = NULL;
@@ -307,7 +307,7 @@ lower_fs_input_intrin(nir_builder *b, nir_intrinsic_instr *intrin, void *data)
          break;
 
       default:
-         unreachable("Unsupported barycentric");
+         UNREACHABLE("Unsupported barycentric");
       }
 
       nir_def *inv_w = NULL;
diff --git a/src/nouveau/compiler/nak_nir_lower_image_addrs.c b/src/nouveau/compiler/nak_nir_lower_image_addrs.c
index 684d82891b648..6c2504bc95b0e 100644
--- a/src/nouveau/compiler/nak_nir_lower_image_addrs.c
+++ b/src/nouveau/compiler/nak_nir_lower_image_addrs.c
@@ -27,7 +27,7 @@ format_for_bits(unsigned bits)
    case 32:  return PIPE_FORMAT_R32_UINT;
    case 64:  return PIPE_FORMAT_R32G32_UINT;
    case 128: return PIPE_FORMAT_R32G32B32A32_UINT;
-   default: unreachable("Unknown number of image format bits");
+   default: UNREACHABLE("Unknown number of image format bits");
    }
 }
 
@@ -46,7 +46,7 @@ sampler_dim_len(enum glsl_sampler_dim dim)
    case GLSL_SAMPLER_DIM_3D:
       return 3;
    default:
-      unreachable("Unhandled sampler dim");
+      UNREACHABLE("Unhandled sampler dim");
       return 1;// Never reached
    }
 }
@@ -100,7 +100,7 @@ load_su_info_clamp(nir_builder *b, nir_deref_instr *deref,
    case 0: return load_su_info(b, deref, clamp_x);
    case 1: return load_su_info(b, deref, clamp_y);
    case 2: return load_su_info(b, deref, clamp_z);
-   default: unreachable("Invalid image dimension");
+   default: UNREACHABLE("Invalid image dimension");
    }
 }
 
@@ -502,7 +502,7 @@ lower_image_access(nir_builder *b, nir_intrinsic_instr *intrin)
       break;
    }
    default:
-      unreachable("Unknown image intrinsic");
+      UNREACHABLE("Unknown image intrinsic");
    }
 }
 
diff --git a/src/nouveau/compiler/nak_nir_lower_kepler_shared_atomics.c b/src/nouveau/compiler/nak_nir_lower_kepler_shared_atomics.c
index b2114a80963f2..f00e989571f14 100644
--- a/src/nouveau/compiler/nak_nir_lower_kepler_shared_atomics.c
+++ b/src/nouveau/compiler/nak_nir_lower_kepler_shared_atomics.c
@@ -67,7 +67,7 @@ lower_atomic_in_lock(nir_builder *b, nir_intrinsic_instr *intr, nir_def *loaded)
    }
    case nir_atomic_op_fcmpxchg: /* TODO: shared atomic floats */
    default:
-      unreachable("Invalid intrinsic");
+      UNREACHABLE("Invalid intrinsic");
    }
 
    return to_store;
diff --git a/src/nouveau/compiler/nak_nir_lower_non_uniform_ldcx.c b/src/nouveau/compiler/nak_nir_lower_non_uniform_ldcx.c
index 3a9f7848ace13..62fdeecd11156 100644
--- a/src/nouveau/compiler/nak_nir_lower_non_uniform_ldcx.c
+++ b/src/nouveau/compiler/nak_nir_lower_non_uniform_ldcx.c
@@ -184,7 +184,7 @@ hoist_def(nir_def *def, nir_block *target)
       break;
 
    default:
-      unreachable("Cannot hoist instruction");
+      UNREACHABLE("Cannot hoist instruction");
    }
 
    nir_instr_remove(instr);
@@ -480,7 +480,7 @@ lower_cf_list(nir_builder *b, struct exec_list *cf_list,
       }
 
       default:
-         unreachable("Unknown CF node type");
+         UNREACHABLE("Unknown CF node type");
       }
    }
 
diff --git a/src/nouveau/compiler/nak_nir_lower_scan_reduce.c b/src/nouveau/compiler/nak_nir_lower_scan_reduce.c
index ddd0a9d7b8183..700392030b3f0 100644
--- a/src/nouveau/compiler/nak_nir_lower_scan_reduce.c
+++ b/src/nouveau/compiler/nak_nir_lower_scan_reduce.c
@@ -39,7 +39,7 @@ build_scan_bool(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
          /* The generic path is fine */
          break;
       default:
-         unreachable("Unsupported boolean reduction op");
+         UNREACHABLE("Unsupported boolean reduction op");
       }
    }
 
@@ -54,7 +54,7 @@ build_scan_bool(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
    case nir_intrinsic_reduce:
       break;
    default:
-      unreachable("Unsupported scan/reduce op");
+      UNREACHABLE("Unsupported scan/reduce op");
    }
 
    data = nir_ballot(b, 1, 32, data);
@@ -69,7 +69,7 @@ build_scan_bool(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
       return nir_ine_imm(b, nir_iand_imm(b, count, 1), 0);
    }
    default:
-      unreachable("Unsupported boolean reduction op");
+      UNREACHABLE("Unsupported boolean reduction op");
    }
 }
 
@@ -122,7 +122,7 @@ build_scan_full(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
    }
 
    default:
-      unreachable("Unsupported scan/reduce op");
+      UNREACHABLE("Unsupported scan/reduce op");
    }
 }
 
@@ -186,7 +186,7 @@ build_scan_reduce(nir_builder *b, nir_intrinsic_op op, nir_op red_op,
    }
 
    default:
-      unreachable("Unsupported scan/reduce op");
+      UNREACHABLE("Unsupported scan/reduce op");
    }
 }
 
diff --git a/src/nouveau/compiler/nak_nir_lower_tex.c b/src/nouveau/compiler/nak_nir_lower_tex.c
index 24973d04387db..d7bce06fc746e 100644
--- a/src/nouveau/compiler/nak_nir_lower_tex.c
+++ b/src/nouveau/compiler/nak_nir_lower_tex.c
@@ -146,7 +146,7 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       case nir_tex_src_ddx:            ddx =       tex->src[i].src.ssa; break;
       case nir_tex_src_ddy:            ddy =       tex->src[i].src.ssa; break;
       default:
-         unreachable("Unsupported texture source");
+         UNREACHABLE("Unsupported texture source");
       }
       /* Remove sources as we walk them.  We'll add them back later */
       nir_instr_clear_src(&tex->instr, &tex->src[i].src);
@@ -221,7 +221,7 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
          lod_mode = NAK_NIR_LOD_MODE_BIAS_CLAMP;
          break;
       default:
-         unreachable("Invalid min_lod");
+         UNREACHABLE("Invalid min_lod");
       }
       min_lod = nir_f2u32(b, nir_fmax(b, nir_fmul_imm(b, min_lod, 256),
                                          nir_imm_float(b, 16)));
@@ -375,7 +375,7 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
                                nir_vec(b, src + 4, 4));
       }
    } else {
-      unreachable("Unsupported shader model");
+      UNREACHABLE("Unsupported shader model");
    }
 
    tex->sampler_dim = remap_sampler_dim(tex->sampler_dim);
@@ -482,7 +482,7 @@ lower_txq(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       case nir_tex_src_sampler_handle: break; /* Ignored */
       case nir_tex_src_lod:            lod = tex->src[i].src.ssa; break;
       default:
-         unreachable("Unsupported texture source");
+         UNREACHABLE("Unsupported texture source");
       }
    }
 
@@ -499,7 +499,7 @@ lower_txq(nir_builder *b, nir_tex_instr *tex, const struct nak_compiler *nak)
       res = build_txq_samples(b, tex_h, tex->can_speculate, nak);
       break;
    default:
-      unreachable("Invalid texture query op");
+      UNREACHABLE("Invalid texture query op");
    }
 
    nir_def_replace(&tex->def, res);
@@ -786,7 +786,7 @@ lower_image_txq(nir_builder *b, nir_intrinsic_instr *intrin,
       res = build_txq_samples(b, img_h, can_speculate, nak);
       break;
    default:
-      unreachable("Invalid image query op");
+      UNREACHABLE("Invalid image query op");
    }
 
    nir_def_replace(&intrin->def, res);
@@ -817,7 +817,7 @@ lower_tex_instr(nir_builder *b, nir_instr *instr, void *_data)
       case nir_texop_texture_samples:
          return lower_txq(b, tex, nak);
       default:
-         unreachable("Unsupported texture instruction");
+         UNREACHABLE("Unsupported texture instruction");
       }
    }
    case nir_instr_type_intrinsic: {
diff --git a/src/nouveau/compiler/nak_nir_lower_vtg_io.c b/src/nouveau/compiler/nak_nir_lower_vtg_io.c
index 6ccd78260edcd..d176687620650 100644
--- a/src/nouveau/compiler/nak_nir_lower_vtg_io.c
+++ b/src/nouveau/compiler/nak_nir_lower_vtg_io.c
@@ -109,7 +109,7 @@ lower_vtg_io_intrin(nir_builder *b,
       break;
 
    default:
-      unreachable("Unknown NIR I/O intrinsic");
+      UNREACHABLE("Unknown NIR I/O intrinsic");
    }
 
    bool is_patch;
@@ -128,7 +128,7 @@ lower_vtg_io_intrin(nir_builder *b,
       break;
 
    default:
-      unreachable("Unknown shader stage");
+      UNREACHABLE("Unknown shader stage");
    }
 
    nir_component_mask_t mask;
diff --git a/src/nouveau/compiler/nak_nir_mark_lcssa_invariants.c b/src/nouveau/compiler/nak_nir_mark_lcssa_invariants.c
index c2edc4e62b1a0..41192fc258b75 100644
--- a/src/nouveau/compiler/nak_nir_mark_lcssa_invariants.c
+++ b/src/nouveau/compiler/nak_nir_mark_lcssa_invariants.c
@@ -91,7 +91,7 @@ lower_cf_list(nir_builder *b, struct exec_list *cf_list)
       }
 
       default:
-         unreachable("Unknown CF node type");
+         UNREACHABLE("Unknown CF node type");
       }
    }
 
diff --git a/src/nouveau/mme/mme_builder.h b/src/nouveau/mme/mme_builder.h
index b3915931c960b..8e4bd15a711ba 100644
--- a/src/nouveau/mme/mme_builder.h
+++ b/src/nouveau/mme/mme_builder.h
@@ -90,7 +90,7 @@ mme_builder_init(struct mme_builder *b, const struct nv_device_info *dev)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_builder_init(b);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline uint32_t *
@@ -101,7 +101,7 @@ mme_builder_finish(struct mme_builder *b, size_t *size_out)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       return mme_fermi_builder_finish(&b->fermi, size_out);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline void
@@ -112,7 +112,7 @@ mme_builder_dump(struct mme_builder *b, FILE *fp)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_builder_dump(b, fp);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline struct mme_value
@@ -160,7 +160,7 @@ mme_alu_to(struct mme_builder *b,
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_alu_to(b, dst, op, x, y);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline struct mme_value
@@ -196,7 +196,7 @@ mme_alu64_to(struct mme_builder *b,
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_alu64_to(b, dst, op_lo, op_hi, x, y);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline struct mme_value64
@@ -323,7 +323,7 @@ mme_mul_32x32_32_free_srcs(struct mme_builder *b,
       mme_fermi_umul_32x32_32_to_free_srcs(b, dst, x, y);
       return dst;
    } else {
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
    }
 }
 
@@ -382,7 +382,7 @@ mme_umul_32x32_64_free_srcs(struct mme_builder *b,
       mme_fermi_umul_32x64_64_to_free_srcs(b, dst, x, mme_value64(y, y_hi));
       return dst;
    } else {
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
    }
 }
 
@@ -405,7 +405,7 @@ mme_umul_32x64_64_free_srcs(struct mme_builder *b,
       mme_fermi_umul_32x64_64_to_free_srcs(b, dst, x, y);
       return dst;
    } else {
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
    }
 }
 
@@ -440,7 +440,7 @@ mme_bfe_to(struct mme_builder *b, struct mme_value dst,
    } else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI) {
       mme_fermi_bfe_to(b, dst, x, pos, bits);
    } else {
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
    }
 }
 
@@ -463,7 +463,7 @@ mme_merge_to(struct mme_builder *b, struct mme_value dst,
   else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_merge_to(b, dst, x, y, dst_pos, bits, src_pos);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline struct mme_value
@@ -491,7 +491,7 @@ mme_state_arr_to(struct mme_builder *b, struct mme_value dst,
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_state_arr_to(b, dst, state, index);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline void
@@ -534,7 +534,7 @@ mme_load_to(struct mme_builder *b, struct mme_value dst)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_load_to(b, dst);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline struct mme_value
@@ -553,7 +553,7 @@ mme_load(struct mme_builder *b)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       return mme_fermi_load(b);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline struct mme_value64
@@ -573,7 +573,7 @@ mme_mthd_arr(struct mme_builder *b, uint16_t mthd,
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_mthd_arr(b, mthd, index);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline void
@@ -591,7 +591,7 @@ mme_emit(struct mme_builder *b,
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_emit(b, data);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline void
@@ -623,7 +623,7 @@ mme_start_loop(struct mme_builder *b, struct mme_value count)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_start_loop(b, count);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 static inline void
@@ -634,7 +634,7 @@ mme_end_loop(struct mme_builder *b)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_end_loop(b);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 #define mme_loop(b, count) \
@@ -651,7 +651,7 @@ mme_start_if_##op(struct mme_builder *b,                          \
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)               \
       mme_fermi_start_if(b, MME_CMP_OP_##OP, if_true, x, y);      \
    else                                                           \
-      unreachable("Unsupported GPU class");                       \
+      UNREACHABLE("Unsupported GPU class");                       \
 }
 
 MME_DEF_START_IF(ilt,   LT,  true)
@@ -675,7 +675,7 @@ mme_end_if(struct mme_builder *b)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_end_if(b);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 #define mme_if(b, cmp, x, y) \
@@ -690,7 +690,7 @@ mme_start_while(struct mme_builder *b)
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)
       mme_fermi_start_while(b);
    else
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
 }
 
 #define MME_DEF_END_WHILE(op, OP, if_true)                        \
@@ -703,7 +703,7 @@ mme_end_while_##op(struct mme_builder *b,                         \
    else if (b->devinfo->cls_eng3d >= MME_CLS_FERMI)               \
       mme_fermi_end_while(b, MME_CMP_OP_##OP, if_true, x, y);     \
    else                                                           \
-      unreachable("Unsupported GPU class");                       \
+      UNREACHABLE("Unsupported GPU class");                       \
 }
 
 MME_DEF_END_WHILE(ilt,   LT,  true)
@@ -729,7 +729,7 @@ mme_exit_if_##op(struct mme_builder *b,                           \
    if (b->devinfo->cls_eng3d >= MME_CLS_TURING)                   \
       mme_tu104_exit_if(b, MME_CMP_OP_##OP, if_true, x, y);       \
    else                                                           \
-      unreachable("Unsupported GPU class");                       \
+      UNREACHABLE("Unsupported GPU class");                       \
 }
 
 MME_DEF_EXIT(ilt,   LT,  true)
diff --git a/src/nouveau/mme/mme_fermi_builder.c b/src/nouveau/mme/mme_fermi_builder.c
index 75df0ca42219a..2888e2afeb50f 100644
--- a/src/nouveau/mme/mme_fermi_builder.c
+++ b/src/nouveau/mme/mme_fermi_builder.c
@@ -27,7 +27,7 @@ mme_fermi_is_zero_or_reg(struct mme_value x)
    case MME_VALUE_TYPE_ZERO:  return true;
    case MME_VALUE_TYPE_IMM:   return x.imm == 0;
    case MME_VALUE_TYPE_REG:   return true;
-   default: unreachable("Invalid MME value type");
+   default: UNREACHABLE("Invalid MME value type");
    }
 }
 
@@ -38,7 +38,7 @@ mme_fermi_is_zero_or_imm(struct mme_value x)
    case MME_VALUE_TYPE_ZERO:  return true;
    case MME_VALUE_TYPE_IMM:   return true;
    case MME_VALUE_TYPE_REG:   return false;
-   default: unreachable("Invalid MME value type");
+   default: UNREACHABLE("Invalid MME value type");
    }
 }
 
@@ -56,7 +56,7 @@ mme_value_alu_reg(struct mme_value val)
    case MME_VALUE_TYPE_IMM:
       return MME_FERMI_REG_ZERO;
    }
-   unreachable("Invalid value type");
+   UNREACHABLE("Invalid value type");
 }
 
 static inline uint32_t
@@ -72,7 +72,7 @@ mme_value_alu_imm(struct mme_value val)
    case MME_VALUE_TYPE_REG:
       return 0;
    }
-   unreachable("Invalid value type");
+   UNREACHABLE("Invalid value type");
 }
 
 static inline void
@@ -715,7 +715,7 @@ mme_to_fermi_alu_op(enum mme_alu_op op)
    ALU_CASE(XOR)
 #undef ALU_CASE
    default:
-      unreachable("Unsupported MME ALU op");
+      UNREACHABLE("Unsupported MME ALU op");
    }
 }
 
diff --git a/src/nouveau/mme/mme_fermi_sim.c b/src/nouveau/mme/mme_fermi_sim.c
index 93738edb3273e..2f63c3e3e0230 100644
--- a/src/nouveau/mme/mme_fermi_sim.c
+++ b/src/nouveau/mme/mme_fermi_sim.c
@@ -113,7 +113,7 @@ static uint32_t eval_op(struct mme_fermi_sim *sim, const struct mme_fermi_inst *
                res = ~(x & y);
                break;
             default:
-               unreachable("Unhandled ALU op");
+               UNREACHABLE("Unhandled ALU op");
          }
 
          return res;
@@ -130,7 +130,7 @@ static uint32_t eval_op(struct mme_fermi_sim *sim, const struct mme_fermi_inst *
          return load_state(sim, (x + load_imm(inst)) * 4);
       // TODO: reverse MME_FERMI_OP_UNK6
       default:
-         unreachable("Unhandled op");
+         UNREACHABLE("Unhandled op");
    }
 }
 
@@ -202,7 +202,7 @@ eval_inst(struct mme_fermi_sim *sim, const struct mme_fermi_inst *inst)
             emit_mthd(sim, (scratch >> 12) & 0x3f);
             break;
          default:
-            unreachable("Unhandled ASSIGN op");
+            UNREACHABLE("Unhandled ASSIGN op");
       }
    }
 }
diff --git a/src/nouveau/mme/mme_sim.c b/src/nouveau/mme/mme_sim.c
index 0dded7004e90c..0c2f64c69009e 100644
--- a/src/nouveau/mme/mme_sim.c
+++ b/src/nouveau/mme/mme_sim.c
@@ -35,6 +35,6 @@ mme_sim_core(const struct nv_device_info *devinfo,
       mme_fermi_sim_core(inst_count, insts, state_ops, state_handler);
       free(insts);
    } else {
-      unreachable("Unsupported GPU class");
+      UNREACHABLE("Unsupported GPU class");
    }
 }
diff --git a/src/nouveau/mme/mme_tu104.c b/src/nouveau/mme/mme_tu104.c
index 1bc0f94510273..965c7842b84c6 100644
--- a/src/nouveau/mme/mme_tu104.c
+++ b/src/nouveau/mme/mme_tu104.c
@@ -216,7 +216,7 @@ mme_tu104_print_alu_src(FILE *fp, const struct mme_tu104_inst *inst,
          fprintf(fp, " $load1");
          break;
       default:
-         unreachable("Invalid ALU source register");
+         UNREACHABLE("Invalid ALU source register");
       }
    }
 }
@@ -487,7 +487,7 @@ mme_tu104_print_out_src(FILE *fp, const struct mme_tu104_inst *inst,
       fprintf(fp, "0x%x", ((uint32_t)inst->imm[0] << 16) | inst->imm[1]);
       break;
    default:
-      unreachable("Invalid output source");
+      UNREACHABLE("Invalid output source");
    }
 };
 
diff --git a/src/nouveau/mme/mme_tu104_builder.c b/src/nouveau/mme/mme_tu104_builder.c
index e4e6d05197a62..99e4f8cc5bf1d 100644
--- a/src/nouveau/mme/mme_tu104_builder.c
+++ b/src/nouveau/mme/mme_tu104_builder.c
@@ -226,7 +226,7 @@ mme_value_alu_reg(struct mme_value val)
       assert(val.reg <= 23);
       return MME_TU104_REG_R0 + val.reg;
    }
-   unreachable("Invalid value type");
+   UNREACHABLE("Invalid value type");
 }
 
 static void
@@ -329,7 +329,7 @@ mme_to_tu104_alu_op(enum mme_alu_op op)
    ALU_CASE(DWRITE)
 #undef ALU_CASE
    default:
-      unreachable("Unsupported MME ALU op");
+      UNREACHABLE("Unsupported MME ALU op");
    }
 }
 
@@ -364,7 +364,7 @@ mme_tu104_alu_to(struct mme_builder *b,
          break;
 
       default:
-         unreachable("Unknown MME value type");
+         UNREACHABLE("Unknown MME value type");
       }
 
       mme_and_to(b, dst, x, not_y);
@@ -650,7 +650,7 @@ mme_cmp_to_tu104_branch_op(enum mme_cmp_op op)
    CMP_CASE(EQ)
 #undef CMP_CASE
    default:
-      unreachable("Unsupported MME CMP op");
+      UNREACHABLE("Unsupported MME CMP op");
    }
 }
 
diff --git a/src/nouveau/mme/mme_tu104_sim.c b/src/nouveau/mme/mme_tu104_sim.c
index b6092b5455786..f087192e953fb 100644
--- a/src/nouveau/mme/mme_tu104_sim.c
+++ b/src/nouveau/mme/mme_tu104_sim.c
@@ -122,7 +122,7 @@ load_reg(struct mme_tu104_sim *sim,
    case MME_TU104_REG_LOAD1:
       return sim->load[1];
    default:
-      unreachable("Unhandled register type");
+      UNREACHABLE("Unhandled register type");
    }
 }
 
@@ -156,7 +156,7 @@ store_reg(struct mme_tu104_sim *sim,
    } else if (reg <= MME_TU104_REG_ZERO) {
       /* Do nothing */
    } else {
-      unreachable("Unhandled register type");
+      UNREACHABLE("Unhandled register type");
    }
 }
 
@@ -180,7 +180,7 @@ eval_cond(enum mme_tu104_alu_op op, uint32_t x, uint32_t y)
    case MME_TU104_ALU_OP_SEQ:
       return x == y;
    default:
-      unreachable("Not a comparison op");
+      UNREACHABLE("Not a comparison op");
    }
 }
 
@@ -336,7 +336,7 @@ eval_alu(struct mme_tu104_sim *sim,
       break;
    }
    default:
-      unreachable("Unhandled ALU op");
+      UNREACHABLE("Unhandled ALU op");
    }
 
    sim->alu_res[alu_idx] = res;
@@ -368,7 +368,7 @@ load_out(struct mme_tu104_sim *sim,
    case MME_TU104_OUT_OP_IMM32:
       return ((uint32_t)inst->imm[0] << 16) | inst->imm[1];
    default:
-      unreachable("Unhandled output op");
+      UNREACHABLE("Unhandled output op");
    }
 }
 
diff --git a/src/nouveau/mme/mme_value.h b/src/nouveau/mme/mme_value.h
index 1a434b96dba42..0f9c533b16c1e 100644
--- a/src/nouveau/mme/mme_value.h
+++ b/src/nouveau/mme/mme_value.h
@@ -62,7 +62,7 @@ mme_is_zero(struct mme_value x)
    case MME_VALUE_TYPE_ZERO:  return true;
    case MME_VALUE_TYPE_IMM:   return x.imm == 0;
    case MME_VALUE_TYPE_REG:   return false;
-   default: unreachable("Invalid MME value type");
+   default: UNREACHABLE("Invalid MME value type");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.c b/src/nouveau/vulkan/nvk_cmd_buffer.c
index fd54628c94d62..e6bd690aed852 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.c
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.c
@@ -724,7 +724,7 @@ nvk_cmd_dirty_cbufs_for_descriptors(struct nvk_cmd_buffer *cmd,
             break;
 
          default:
-            unreachable("Invalid cbuf type");
+            UNREACHABLE("Invalid cbuf type");
          }
       }
    }
@@ -1099,7 +1099,7 @@ nvk_cmd_buffer_get_cbuf_addr(struct nvk_cmd_buffer *cmd,
       return true;
 
    case NVK_CBUF_TYPE_ROOT_DESC:
-      unreachable("The caller should handle root descriptors");
+      UNREACHABLE("The caller should handle root descriptors");
       return false;
 
    case NVK_CBUF_TYPE_SHADER_DATA:
@@ -1140,7 +1140,7 @@ nvk_cmd_buffer_get_cbuf_addr(struct nvk_cmd_buffer *cmd,
    }
 
    default:
-      unreachable("Invalid cbuf type");
+      UNREACHABLE("Invalid cbuf type");
    }
 }
 
@@ -1161,7 +1161,7 @@ nvk_cmd_buffer_get_cbuf_descriptor_addr(struct nvk_cmd_buffer *cmd,
    }
 
    default:
-      unreachable("Unknown descriptor set type");
+      UNREACHABLE("Unknown descriptor set type");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_cmd_buffer.h b/src/nouveau/vulkan/nvk_cmd_buffer.h
index 894a44ccd9574..71c06ad0efad0 100644
--- a/src/nouveau/vulkan/nvk_cmd_buffer.h
+++ b/src/nouveau/vulkan/nvk_cmd_buffer.h
@@ -314,7 +314,7 @@ nvk_get_descriptors_state(struct nvk_cmd_buffer *cmd,
    case VK_PIPELINE_BIND_POINT_COMPUTE:
       return &cmd->state.cs.descriptors;
    default:
-      unreachable("Unhandled bind point");
+      UNREACHABLE("Unhandled bind point");
    }
 }
 
@@ -329,7 +329,7 @@ nvk_get_descriptor_state_for_stages(struct nvk_cmd_buffer *cmd,
       assert(!(stages & ~NVK_SHADER_STAGE_GRAPHICS_BITS));
       return &cmd->state.gfx.descriptors;
    } else {
-      unreachable("Unknown shader stage");
+      UNREACHABLE("Unknown shader stage");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_cmd_clear.c b/src/nouveau/vulkan/nvk_cmd_clear.c
index 3e8630594c8be..908cd450eb06e 100644
--- a/src/nouveau/vulkan/nvk_cmd_clear.c
+++ b/src/nouveau/vulkan/nvk_cmd_clear.c
@@ -200,7 +200,7 @@ render_view_type(VkImageType image_type, unsigned layer_count)
    case VK_IMAGE_TYPE_3D:
       return VK_IMAGE_VIEW_TYPE_3D;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -305,7 +305,7 @@ vk_packed_int_format_for_size(unsigned size_B)
    case 4:  return VK_FORMAT_R32_UINT;
    case 8:  return VK_FORMAT_R32G32_UINT;
    case 16: return VK_FORMAT_R32G32B32A32_UINT;
-   default: unreachable("Invalid image format size");
+   default: UNREACHABLE("Invalid image format size");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_cmd_copy.c b/src/nouveau/vulkan/nvk_cmd_copy.c
index e8c6b492b72bd..4316f994072ae 100644
--- a/src/nouveau/vulkan/nvk_cmd_copy.c
+++ b/src/nouveau/vulkan/nvk_cmd_copy.c
@@ -180,7 +180,7 @@ nil_to_nvcab5_gob_type(enum nil_gob_type gob_type)
    case NIL_GOB_TYPE_BLACKWELL16_BIT:  return NVCAB5_GOB_KIND(16);
    case NIL_GOB_TYPE_BLACKWELL_Z24:    return NVCAB5_GOB_KIND(24);
    default:
-      unreachable("Invalid GOB type on Blackwell+");
+      UNREACHABLE("Invalid GOB type on Blackwell+");
    }
 #undef NVCAB5_GOB_KIND
 }
@@ -497,7 +497,7 @@ nvk_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
          break;
       case PIPE_FORMAT_Z16_UNORM_S8_UINT:
       case PIPE_FORMAT_S8_UINT_Z24_UNORM:
-         unreachable("Unsupported packed depth/stencil format");
+         UNREACHABLE("Unsupported packed depth/stencil format");
          break;
       default:
          copy.remap = nouveau_copy_remap_format(format.p_format);
@@ -611,7 +611,7 @@ nvk_CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
          break;
       case PIPE_FORMAT_Z16_UNORM_S8_UINT:
       case PIPE_FORMAT_S8_UINT_Z24_UNORM:
-         unreachable("Unsupported packed depth/stencil format");
+         UNREACHABLE("Unsupported packed depth/stencil format");
          break;
       default:
          copy.remap = nouveau_copy_remap_format(format.p_format);
@@ -809,7 +809,7 @@ nvk_CmdCopyImage2(VkCommandBuffer commandBuffer,
             break;
          case PIPE_FORMAT_Z16_UNORM_S8_UINT:
          case PIPE_FORMAT_S8_UINT_Z24_UNORM:
-            unreachable("Unsupported packed depth/stencil format");
+            UNREACHABLE("Unsupported packed depth/stencil format");
             break;
          default:
             copy.remap = nouveau_copy_remap_format(src_format.p_format);
diff --git a/src/nouveau/vulkan/nvk_cmd_draw.c b/src/nouveau/vulkan/nvk_cmd_draw.c
index eb7e3b7e33fe9..c1d12a4e2792a 100644
--- a/src/nouveau/vulkan/nvk_cmd_draw.c
+++ b/src/nouveau/vulkan/nvk_cmd_draw.c
@@ -907,7 +907,7 @@ nvk_cmd_set_sample_layout(struct nvk_cmd_buffer *cmd,
       break;
 
    default:
-      unreachable("Unknown sample layout");
+      UNREACHABLE("Unknown sample layout");
    }
 
    P_1INC(p, NV9097, CALL_MME_MACRO(NVK_MME_SET_ANTI_ALIAS));
@@ -1885,7 +1885,7 @@ vk_to_nv9097_primitive_topology(VkPrimitiveTopology prim)
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
       return NV9097_BEGIN_OP_PATCH;
    default:
-      unreachable("Invalid primitive topology");
+      UNREACHABLE("Invalid primitive topology");
    }
 }
 
@@ -2337,7 +2337,7 @@ nvk_flush_rs_state(struct nvk_cmd_buffer *cmd)
          break;
       case VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT:
       default:
-         unreachable("Unsupported depth bias representation");
+         UNREACHABLE("Unsupported depth bias representation");
       }
       /* TODO: The blob multiplies by 2 for some reason. We don't. */
       P_IMMD(p, NV9097, SET_DEPTH_BIAS, fui(dyn->rs.depth_bias.constant_factor));
@@ -2370,7 +2370,7 @@ nvk_flush_rs_state(struct nvk_cmd_buffer *cmd)
          break;
 
       default:
-         unreachable("Invalid line rasterization mode");
+         UNREACHABLE("Invalid line rasterization mode");
       }
    }
 
@@ -2522,7 +2522,7 @@ nvk_combine_fs_log2_rates(VkFragmentShadingRateCombinerOpKHR op,
       };
 
    default:
-      unreachable("Invalid FSR combiner op");
+      UNREACHABLE("Invalid FSR combiner op");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_cmd_indirect.c b/src/nouveau/vulkan/nvk_cmd_indirect.c
index de29b566270f6..6a22b21535b33 100644
--- a/src/nouveau/vulkan/nvk_cmd_indirect.c
+++ b/src/nouveau/vulkan/nvk_cmd_indirect.c
@@ -415,7 +415,7 @@ build_process_cs_cmd_seq(nir_builder *b, struct nvk_nir_push *p,
       }
 
       default:
-         unreachable("Unsupported indirect token type");
+         UNREACHABLE("Unsupported indirect token type");
       }
    }
 }
@@ -479,7 +479,7 @@ build_gfx_set_exec(nir_builder *b, struct nvk_nir_push *p, nir_def *token_addr,
    }
 
    default:
-      unreachable("Unknown indirect execution set type");
+      UNREACHABLE("Unknown indirect execution set type");
    }
 }
 
@@ -681,7 +681,7 @@ build_process_gfx_cmd_seq(nir_builder *b, struct nvk_nir_push *p,
          break;
 
       default:
-         unreachable("Unsupported indirect token type");
+         UNREACHABLE("Unsupported indirect token type");
       }
    }
 }
@@ -786,7 +786,7 @@ build_process_shader(struct nvk_device *dev,
          build_process_gfx_cmd_seq(b, &push, in_seq_addr, seq_idx,
                                    &in, pdev, info);
       } else {
-         unreachable("Unknown shader stage");
+         UNREACHABLE("Unknown shader stage");
       }
    }
    nir_pop_if(b, NULL);
@@ -799,7 +799,7 @@ build_process_shader(struct nvk_device *dev,
    } else if (info->shaderStages & NVK_SHADER_STAGE_GRAPHICS_BITS) {
       nvk_nir_pad_NOP(b, &push, NV9097);
    } else {
-      unreachable("Unknown shader stage");
+      UNREACHABLE("Unknown shader stage");
    }
 
    /* Replace the out stride with the actual size of a command stream */
diff --git a/src/nouveau/vulkan/nvk_cmd_meta.c b/src/nouveau/vulkan/nvk_cmd_meta.c
index f834c627c099a..e1329a3446f08 100644
--- a/src/nouveau/vulkan/nvk_cmd_meta.c
+++ b/src/nouveau/vulkan/nvk_cmd_meta.c
@@ -154,7 +154,7 @@ nvk_meta_end(struct nvk_cmd_buffer *cmd,
       break;
 
    default:
-      unreachable("Unknown descriptor set type");
+      UNREACHABLE("Unknown descriptor set type");
    }
    nvk_cmd_dirty_cbufs_for_descriptors(cmd, ~0, 0, 1);
 
diff --git a/src/nouveau/vulkan/nvk_descriptor_set.c b/src/nouveau/vulkan/nvk_descriptor_set.c
index 10f49183201a7..d2c4f14742680 100644
--- a/src/nouveau/vulkan/nvk_descriptor_set.c
+++ b/src/nouveau/vulkan/nvk_descriptor_set.c
@@ -1101,6 +1101,6 @@ nvk_GetDescriptorEXT(VkDevice _device,
       break;
 
    default:
-      unreachable("Unknown descriptor type");
+      UNREACHABLE("Unknown descriptor type");
    }
 }
diff --git a/src/nouveau/vulkan/nvk_descriptor_set_layout.c b/src/nouveau/vulkan/nvk_descriptor_set_layout.c
index 1a85e1e5273d5..575b246e6ca09 100644
--- a/src/nouveau/vulkan/nvk_descriptor_set_layout.c
+++ b/src/nouveau/vulkan/nvk_descriptor_set_layout.c
@@ -122,7 +122,7 @@ nvk_descriptor_stride_align_for_type(const struct nvk_physical_device *pdev,
       break;
 
    default:
-      unreachable("Invalid descriptor type");
+      UNREACHABLE("Invalid descriptor type");
    }
 
    assert(*stride <= NVK_MAX_DESCRIPTOR_SIZE);
diff --git a/src/nouveau/vulkan/nvk_image.c b/src/nouveau/vulkan/nvk_image.c
index 73bc9594c4476..529be64787669 100644
--- a/src/nouveau/vulkan/nvk_image.c
+++ b/src/nouveau/vulkan/nvk_image.c
@@ -266,7 +266,7 @@ nvk_get_drm_format_modifier_properties_list(const struct nvk_physical_device *pd
    }
 
    default:
-      unreachable("Invalid structure type");
+      UNREACHABLE("Invalid structure type");
    }
 }
 
@@ -315,7 +315,7 @@ nvk_image_max_dimension(const struct nv_device_info *info,
    case VK_IMAGE_TYPE_3D:
       return 0x4000;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -477,7 +477,7 @@ nvk_GetPhysicalDeviceImageFormatProperties2(
       maxArraySize = 1;
       break;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
    if (pImageFormatInfo->tiling == VK_IMAGE_TILING_LINEAR)
       maxArraySize = 1;
@@ -540,7 +540,7 @@ nvk_GetPhysicalDeviceImageFormatProperties2(
          tiling_has_explicit_layout = false;
          break;
       default:
-         unreachable("Unsupported VkImageTiling");
+         UNREACHABLE("Unsupported VkImageTiling");
       }
 
       switch (external_info->handleType) {
@@ -673,7 +673,7 @@ vk_image_type_to_nil_dim(VkImageType type)
    case VK_IMAGE_TYPE_2D:  return NIL_IMAGE_DIM_2D;
    case VK_IMAGE_TYPE_3D:  return NIL_IMAGE_DIM_3D;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_image.h b/src/nouveau/vulkan/nvk_image.h
index 6d7cdc2760a6b..1f576e66e290f 100644
--- a/src/nouveau/vulkan/nvk_image.h
+++ b/src/nouveau/vulkan/nvk_image.h
@@ -142,7 +142,7 @@ nvk_image_aspects_to_plane(const struct nvk_image *image,
       switch(aspectMask) {
       case VK_IMAGE_ASPECT_DEPTH_BIT: return 0;
       case VK_IMAGE_ASPECT_STENCIL_BIT: return 1;
-      default: unreachable("Not a depth/stencil aspect");
+      default: UNREACHABLE("Not a depth/stencil aspect");
       }
    }
 
diff --git a/src/nouveau/vulkan/nvk_image_view.c b/src/nouveau/vulkan/nvk_image_view.c
index 7e2b0034206c5..b409a8a77d522 100644
--- a/src/nouveau/vulkan/nvk_image_view.c
+++ b/src/nouveau/vulkan/nvk_image_view.c
@@ -26,7 +26,7 @@ vk_image_view_type_to_nil_view_type(VkImageViewType view_type)
    case VK_IMAGE_VIEW_TYPE_2D_ARRAY:   return NIL_VIEW_TYPE_2D_ARRAY;
    case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: return NIL_VIEW_TYPE_CUBE_ARRAY;
    default:
-      unreachable("Invalid image view type");
+      UNREACHABLE("Invalid image view type");
    }
 }
 
@@ -41,7 +41,7 @@ vk_swizzle_to_pipe(VkComponentSwizzle swizzle)
    case VK_COMPONENT_SWIZZLE_ONE:   return PIPE_SWIZZLE_1;
    case VK_COMPONENT_SWIZZLE_ZERO:  return PIPE_SWIZZLE_0;
    default:
-      unreachable("Invalid component swizzle");
+      UNREACHABLE("Invalid component swizzle");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_indirect_execution_set.c b/src/nouveau/vulkan/nvk_indirect_execution_set.c
index a176107930a0d..1712bdacb4359 100644
--- a/src/nouveau/vulkan/nvk_indirect_execution_set.c
+++ b/src/nouveau/vulkan/nvk_indirect_execution_set.c
@@ -51,7 +51,7 @@ nvk_ies_cs_qmd_init(const struct nvk_physical_device *pdev,
          break;
 
       default:
-         unreachable("Unsupported cbuf type");
+         UNREACHABLE("Unsupported cbuf type");
       }
    }
 
@@ -206,7 +206,7 @@ nvk_ies_set_pipeline(struct nvk_device *dev,
    }
 
    default:
-      unreachable("Invalid indirect execution set type");
+      UNREACHABLE("Invalid indirect execution set type");
    }
 }
 
@@ -227,7 +227,7 @@ nvk_ies_set_shader(struct nvk_device *dev,
    }
 
    default:
-      unreachable("Invalid indirect execution set type");
+      UNREACHABLE("Invalid indirect execution set type");
    }
 }
 
@@ -262,7 +262,7 @@ nvk_CreateIndirectExecutionSetEXT(VkDevice _device,
          ies->type = NVK_IES_TYPE_GFX_PIPELINE;
          ies->stride_B = nvk_ies_stride_gfx_pipeline(pdev, pipeline->stages);
       } else {
-         unreachable("Unknown shader stage");
+         UNREACHABLE("Unknown shader stage");
       }
       break;
    }
@@ -287,13 +287,13 @@ nvk_CreateIndirectExecutionSetEXT(VkDevice _device,
          ies->type = NVK_IES_TYPE_GFX_SHADER;
          ies->stride_B = nvk_ies_stride_gfx_shader(pdev, stages);
       } else {
-         unreachable("Unknown shader stage");
+         UNREACHABLE("Unknown shader stage");
       }
       break;
    }
 
    default:
-      unreachable("Unknown indirect execution set info type");
+      UNREACHABLE("Unknown indirect execution set info type");
    }
 
    size_t size = ies->count * (size_t)ies->stride_B;
@@ -325,7 +325,7 @@ nvk_CreateIndirectExecutionSetEXT(VkDevice _device,
    }
 
    default:
-      unreachable("Unknown indirect execution set info type");
+      UNREACHABLE("Unknown indirect execution set info type");
    }
 
    *pIndirectExecutionSet = nvk_indirect_execution_set_to_handle(ies);
diff --git a/src/nouveau/vulkan/nvk_mem_arena.c b/src/nouveau/vulkan/nvk_mem_arena.c
index 0b0fd4b2cf441..d7b17a5500ed5 100644
--- a/src/nouveau/vulkan/nvk_mem_arena.c
+++ b/src/nouveau/vulkan/nvk_mem_arena.c
@@ -138,7 +138,7 @@ nvk_mem_arena_find_mem_by_addr(const struct nvk_mem_arena *arena, uint64_t addr)
             return mem_idx;
       }
 
-      unreachable("Not an arena address");
+      UNREACHABLE("Not an arena address");
    }
 }
 
diff --git a/src/nouveau/vulkan/nvk_mme.c b/src/nouveau/vulkan/nvk_mme.c
index 94ca3a9d2663d..7d1b05ac1082e 100644
--- a/src/nouveau/vulkan/nvk_mme.c
+++ b/src/nouveau/vulkan/nvk_mme.c
@@ -87,7 +87,7 @@ nvk_mme_test_state_state(void *_ts, uint16_t addr)
    assert(ts->test->init != NULL && "Read uninitialized state");
    for (uint32_t i = 0;; i++) {
       if (ts->test->init[i].mthd == 0)
-         unreachable("Read uninitialized state");
+         UNREACHABLE("Read uninitialized state");
 
       if (ts->test->init[i].mthd == addr)
          return ts->test->init[i].data;
diff --git a/src/nouveau/vulkan/nvk_nir_lower_descriptors.c b/src/nouveau/vulkan/nvk_nir_lower_descriptors.c
index 41cb767191f2b..1d3a1ea541778 100644
--- a/src/nouveau/vulkan/nvk_nir_lower_descriptors.c
+++ b/src/nouveau/vulkan/nvk_nir_lower_descriptors.c
@@ -232,7 +232,7 @@ ubo_deref_to_cbuf(nir_deref_instr *deref,
 
       switch (deref->deref_type) {
       case nir_deref_type_var:
-         unreachable("Buffers don't use variables in Vulkan");
+         UNREACHABLE("Buffers don't use variables in Vulkan");
 
       case nir_deref_type_array:
       case nir_deref_type_array_wildcard: {
@@ -251,7 +251,7 @@ ubo_deref_to_cbuf(nir_deref_instr *deref,
           * anyway, even with variable pointers.
           */
          offset_valid = false;
-         unreachable("Variable pointers aren't allowed on UBOs");
+         UNREACHABLE("Variable pointers aren't allowed on UBOs");
          break;
 
       case nir_deref_type_struct: {
@@ -261,7 +261,7 @@ ubo_deref_to_cbuf(nir_deref_instr *deref,
       }
 
       default:
-         unreachable("Unknown deref type");
+         UNREACHABLE("Unknown deref type");
       }
 
       deref = parent;
@@ -388,7 +388,7 @@ record_cbuf_uses_instr(UNUSED nir_builder *b, nir_instr *instr, void *_ctx)
       default:
          return false;
       }
-      unreachable("All cases return false");
+      UNREACHABLE("All cases return false");
    }
 
    case nir_instr_type_tex:
@@ -1013,7 +1013,7 @@ lower_edb_buffer_image_intrin(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Unknown image intrinsic");
+      UNREACHABLE("Unknown image intrinsic");
    }
 }
 
@@ -1105,7 +1105,7 @@ try_lower_intrin(nir_builder *b, nir_intrinsic_instr *intrin,
       return try_lower_load_vulkan_descriptor(b, intrin, ctx);
 
    case nir_intrinsic_load_workgroup_size:
-      unreachable("Should have been lowered by nir_lower_cs_intrinsics()");
+      UNREACHABLE("Should have been lowered by nir_lower_cs_intrinsics()");
 
    case nir_intrinsic_load_num_workgroups:
       return lower_sysval_to_root_table(b, intrin, cs.group_count, ctx);
@@ -1212,7 +1212,7 @@ lower_edb_buffer_tex_instr(nir_builder *b, nir_tex_instr *tex,
    }
 
    default:
-      unreachable("Invalid buffer texture op");
+      UNREACHABLE("Invalid buffer texture op");
    }
 }
 
@@ -1346,7 +1346,7 @@ lower_ssbo_resource_index(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Not an SSBO descriptor");
+      UNREACHABLE("Not an SSBO descriptor");
    }
 
    /* Tuck the stride in the top 8 bits of the binding address */
@@ -1369,7 +1369,7 @@ lower_ssbo_resource_index(nir_builder *b, nir_intrinsic_instr *intrin,
       break;
 
    default:
-      unreachable("Unknown address mode");
+      UNREACHABLE("Unknown address mode");
    }
 
    nir_def_rewrite_uses(&intrin->def, addr);
@@ -1397,7 +1397,7 @@ lower_ssbo_resource_reindex(nir_builder *b, nir_intrinsic_instr *intrin,
       break;
 
    default:
-      unreachable("Unknown address mode");
+      UNREACHABLE("Unknown address mode");
    }
 
    nir_def *stride = nir_ushr_imm(b, addr_high32, 24);
@@ -1437,7 +1437,7 @@ lower_load_ssbo_descriptor(nir_builder *b, nir_intrinsic_instr *intrin,
    }
 
    default:
-      unreachable("Unknown address mode");
+      UNREACHABLE("Unknown address mode");
    }
 
    /* Mask off the binding stride */
diff --git a/src/nouveau/vulkan/nvk_query_pool.c b/src/nouveau/vulkan/nvk_query_pool.c
index 097da69c989f2..028a6f10d081d 100644
--- a/src/nouveau/vulkan/nvk_query_pool.c
+++ b/src/nouveau/vulkan/nvk_query_pool.c
@@ -66,7 +66,7 @@ nvk_CreateQueryPool(VkDevice device,
       reports_per_query = 4;
       break;
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
    pool->query_stride = reports_per_query * sizeof(struct nvk_query_report);
 
@@ -172,7 +172,7 @@ emit_zero_queries(struct nvk_cmd_buffer *cmd, struct nvk_query_pool *pool,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -481,7 +481,7 @@ nvk_cmd_begin_end_query(struct nvk_cmd_buffer *cmd,
       break;
 
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    if (end) {
@@ -662,7 +662,7 @@ nvk_GetQueryPoolResults(VkDevice device,
             cpu_write_query_result(dst, 0, flags, src->timestamp);
          break;
       default:
-         unreachable("Unsupported query type");
+         UNREACHABLE("Unsupported query type");
       }
 
       if (!write_results)
diff --git a/src/nouveau/vulkan/nvk_sampler.c b/src/nouveau/vulkan/nvk_sampler.c
index ea90ad4e3fefc..d07a1a24666db 100644
--- a/src/nouveau/vulkan/nvk_sampler.c
+++ b/src/nouveau/vulkan/nvk_sampler.c
@@ -180,7 +180,7 @@ nvk_sampler_get_header(const struct nvk_physical_device *pdev,
       SAMP_SET_E(samp, NV9097, 1, MAG_FILTER, MAG_LINEAR);
       break;
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    }
 
    switch (state->min_filter) {
@@ -194,7 +194,7 @@ nvk_sampler_get_header(const struct nvk_physical_device *pdev,
          SAMP_SET_E(samp, NV9097, 1, MIN_FILTER, MIN_LINEAR);
       break;
    default:
-      unreachable("Invalid filter");
+      UNREACHABLE("Invalid filter");
    }
 
    switch (state->mipmap_mode) {
@@ -205,7 +205,7 @@ nvk_sampler_get_header(const struct nvk_physical_device *pdev,
       SAMP_SET_E(samp, NV9097, 1, MIP_FILTER, MIP_LINEAR);
       break;
    default:
-      unreachable("Invalid mipmap mode");
+      UNREACHABLE("Invalid mipmap mode");
    }
 
    assert(pdev->info.cls_eng3d >= KEPLER_A);
@@ -227,7 +227,7 @@ nvk_sampler_get_header(const struct nvk_physical_device *pdev,
          SAMP_SET_E(samp, NVB197, 1, REDUCTION_FILTER, RED_MAXIMUM);
          break;
       default:
-         unreachable("Invalid reduction mode");
+         UNREACHABLE("Invalid reduction mode");
       }
    }
 
diff --git a/src/nouveau/vulkan/nvk_shader.c b/src/nouveau/vulkan/nvk_shader.c
index 0afbf394991a9..27d7e197beb57 100644
--- a/src/nouveau/vulkan/nvk_shader.c
+++ b/src/nouveau/vulkan/nvk_shader.c
@@ -85,7 +85,7 @@ nvk_ubo_addr_format(const struct nvk_physical_device *pdev,
       case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT:
          return nir_address_format_64bit_bounded_global;
       default:
-         unreachable("Invalid robust buffer access behavior");
+         UNREACHABLE("Invalid robust buffer access behavior");
       }
    }
 }
@@ -105,7 +105,7 @@ nvk_ssbo_addr_format(const struct nvk_physical_device *pdev,
       case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT:
          return nir_address_format_64bit_bounded_global;
       default:
-         unreachable("Invalid robust buffer access behavior");
+         UNREACHABLE("Invalid robust buffer access behavior");
       }
    }
 }
@@ -250,7 +250,7 @@ lower_load_intrinsic(nir_builder *b, nir_intrinsic_instr *load,
                            .align_mul = align_mul,
                            .align_offset = align_offset);
       } else {
-         unreachable("Invalid UBO index");
+         UNREACHABLE("Invalid UBO index");
       }
       nir_def_rewrite_uses(&load->def, val);
       return true;
diff --git a/src/panfrost/compiler/bi_builder.h.py b/src/panfrost/compiler/bi_builder.h.py
index 08e382d9a8298..d4ae3eeb63b62 100644
--- a/src/panfrost/compiler/bi_builder.h.py
+++ b/src/panfrost/compiler/bi_builder.h.py
@@ -177,7 +177,7 @@ bi_${ret} bi_${common_op.replace('.', '_').lower()}${suffix if ops[opcode]['dest
         return (bi_${variant.replace('.', '_').lower()}${to_suffix(ops[opcode])}(${arguments(ops[opcode], temp_dest = temp)}))${"->dest[0]" if temp else ""};
 % endfor
     else
-        unreachable("Invalid parameters for ${common_op}");
+        UNREACHABLE("Invalid parameters for ${common_op}");
 }
 
 %endif
diff --git a/src/panfrost/compiler/bi_opt_dual_tex.c b/src/panfrost/compiler/bi_opt_dual_tex.c
index 44f4dddffba65..e3274d0cbee30 100644
--- a/src/panfrost/compiler/bi_opt_dual_tex.c
+++ b/src/panfrost/compiler/bi_opt_dual_tex.c
@@ -65,7 +65,7 @@ bi_format_for_texs_2d(enum bi_opcode op)
    case BI_OPCODE_TEXS_2D_F16:
       return BIFROST_TEXTURE_FORMAT_F16;
    default:
-      unreachable("Invalid TEXS_2D instruction");
+      UNREACHABLE("Invalid TEXS_2D instruction");
    }
 }
 
diff --git a/src/panfrost/compiler/bi_opt_mod_props.c b/src/panfrost/compiler/bi_opt_mod_props.c
index 236e2d9a8df8c..687a46fdc7d9f 100644
--- a/src/panfrost/compiler/bi_opt_mod_props.c
+++ b/src/panfrost/compiler/bi_opt_mod_props.c
@@ -294,7 +294,7 @@ bi_sized_mux_op(unsigned size)
    case 32:
       return BI_OPCODE_MUX_I32;
    default:
-      unreachable("invalid size");
+      UNREACHABLE("invalid size");
    }
 }
 
diff --git a/src/panfrost/compiler/bi_packer.c.py b/src/panfrost/compiler/bi_packer.c.py
index c50606398099c..5fb3d2d886fcc 100644
--- a/src/panfrost/compiler/bi_packer.c.py
+++ b/src/panfrost/compiler/bi_packer.c.py
@@ -178,7 +178,7 @@ def pack_derived(pos, exprs, imm_map, body, pack_exprs):
             first = False
 
     assert (not first)
-    body.append('else unreachable("No pattern match at pos {}");'.format(pos))
+    body.append('else UNREACHABLE("No pattern match at pos {}");'.format(pos))
     body.append('')
 
     assert(pos is not None)
@@ -207,7 +207,7 @@ ${"\\n".join(["    " + x for x in s_body + ["return {};".format( " | ".join(pack
 ${"\\n".join(["        " + x for x in s_body + ["return {};".format(" | ".join(pack_exprs))]])}
 % endfor
     } else {
-        unreachable("No matching state found in ${name}");
+        UNREACHABLE("No matching state found in ${name}");
     }
 % endif
 }
@@ -337,7 +337,7 @@ bi_pack_${'fma' if unit == '*' else 'add'}(bi_instr *I,
 #ifndef NDEBUG
         bi_print_instr(I, stderr);
 #endif
-        unreachable("Cannot pack instruction as ${unit}");
+        UNREACHABLE("Cannot pack instruction as ${unit}");
     }
 }
 """)
diff --git a/src/panfrost/compiler/bi_printer.c.py b/src/panfrost/compiler/bi_printer.c.py
index 833805d2276c6..623b3bef692d1 100644
--- a/src/panfrost/compiler/bi_printer.c.py
+++ b/src/panfrost/compiler/bi_printer.c.py
@@ -52,7 +52,7 @@ bi_swizzle_as_str(enum bi_swizzle swz)
         case BI_SWIZZLE_B1123: return ".b1123";
         }
 
-        unreachable("Invalid swizzle");
+        UNREACHABLE("Invalid swizzle");
 }
 
 static const char *
@@ -108,7 +108,7 @@ bi_print_index(FILE *fp, bi_index index)
     else if (index.type == BI_INDEX_NORMAL)
         fprintf(fp, "%u", index.value);
     else
-        unreachable("Invalid index");
+        UNREACHABLE("Invalid index");
 
     if (index.offset)
         fprintf(fp, "[%u]", index.offset);
@@ -138,7 +138,7 @@ bi_${mod}_as_str(enum bi_${mod} ${mod})
 % endfor
     }
 
-    unreachable("Invalid ${mod}");
+    UNREACHABLE("Invalid ${mod}");
 };
 % endif
 % endfor
@@ -224,7 +224,7 @@ bi_print_instr(const bi_instr *I, FILE *fp)
         break;
 % endfor
     default:
-        unreachable("Invalid opcode");
+        UNREACHABLE("Invalid opcode");
     }
 
     if (I->branch_target)
diff --git a/src/panfrost/compiler/bi_ra.c b/src/panfrost/compiler/bi_ra.c
index 0f0cd61f3f7c0..0e879ec06cf24 100644
--- a/src/panfrost/compiler/bi_ra.c
+++ b/src/panfrost/compiler/bi_ra.c
@@ -1106,7 +1106,7 @@ bi_register_allocate(bi_context *ctx)
       if (register_demand > regs_to_use) {
          /* spill registers if we can */
          if (ctx->inputs->is_blend)
-            unreachable("Blend shaders may not spill");
+            UNREACHABLE("Blend shaders may not spill");
 
          spill_count = bi_spill_ssa(ctx, regs_to_use, spill_count);
          /* By default, we use packed TLS addressing on Valhall.
@@ -1153,10 +1153,10 @@ bi_register_allocate(bi_context *ctx)
          l = NULL;
 
          if (spill_node == -1)
-            unreachable("Failed to choose spill node\n");
+            UNREACHABLE("Failed to choose spill node\n");
 
          if (ctx->inputs->is_blend)
-            unreachable("Blend shaders may not spill");
+            UNREACHABLE("Blend shaders may not spill");
 
          /* By default, we use packed TLS addressing on Valhall.
           * We cannot cross 16 byte boundaries with packed TLS
diff --git a/src/panfrost/compiler/bi_spill_ssa.c b/src/panfrost/compiler/bi_spill_ssa.c
index 80fa45eb21990..99424c5decbd3 100644
--- a/src/panfrost/compiler/bi_spill_ssa.c
+++ b/src/panfrost/compiler/bi_spill_ssa.c
@@ -333,7 +333,7 @@ remat_to(bi_builder *b, bi_index dst, struct spill_ctx *ctx, unsigned node)
       assert(dst.type == BI_INDEX_NORMAL);
       return bi_mov_i32_to(b, dst, I->src[0]);
    default:
-      unreachable("invalid remat");
+      UNREACHABLE("invalid remat");
    }
 }
 
diff --git a/src/panfrost/compiler/bifrost/bi_pack.c b/src/panfrost/compiler/bifrost/bi_pack.c
index 948560bd6571b..d42c55e87064a 100644
--- a/src/panfrost/compiler/bifrost/bi_pack.c
+++ b/src/panfrost/compiler/bifrost/bi_pack.c
@@ -100,7 +100,7 @@ bi_assign_slot_read(bi_registers *regs, bi_index src)
    }
 
    bi_print_slots(regs, stderr);
-   unreachable("Failed to find a free slot for src");
+   UNREACHABLE("Failed to find a free slot for src");
 }
 
 static bi_registers
@@ -180,7 +180,7 @@ bi_pack_register_mode(bi_registers r)
    }
 
    bi_print_slots(&r, stderr);
-   unreachable("Invalid slot assignment");
+   UNREACHABLE("Invalid slot assignment");
 }
 
 static uint64_t
@@ -296,7 +296,7 @@ bi_get_src_slot(bi_registers *regs, unsigned reg)
    else if (regs->slot[2] == reg && regs->slot23.slot2 == BIFROST_OP_READ)
       return BIFROST_SRC_PORT2;
    else
-      unreachable("Tried to access register with no port");
+      UNREACHABLE("Tried to access register with no port");
 }
 
 static inline enum bifrost_packed_src
diff --git a/src/panfrost/compiler/bifrost/bi_schedule.c b/src/panfrost/compiler/bifrost/bi_schedule.c
index 851cfef069985..794339ed0856a 100644
--- a/src/panfrost/compiler/bifrost/bi_schedule.c
+++ b/src/panfrost/compiler/bifrost/bi_schedule.c
@@ -2068,7 +2068,7 @@ bi_schedule_block(bi_context *ctx, bi_block *block)
    }
 
    if (incomplete)
-      unreachable("The above instructions failed to schedule.");
+      UNREACHABLE("The above instructions failed to schedule.");
 #endif
 
    bi_free_worklist(st);
diff --git a/src/panfrost/compiler/bifrost/disassemble.c b/src/panfrost/compiler/bifrost/disassemble.c
index 56eca97c18cc3..83b2c0b471ab4 100644
--- a/src/panfrost/compiler/bifrost/disassemble.c
+++ b/src/panfrost/compiler/bifrost/disassemble.c
@@ -282,7 +282,7 @@ dump_pc_imm(FILE *fp, uint64_t imm, unsigned branch_offset,
       offs = sx32[high32];
       break;
    default:
-      unreachable("Invalid PC modifier");
+      UNREACHABLE("Invalid PC modifier");
    }
 
    assert((offs & 15) == 0);
@@ -560,7 +560,7 @@ dump_clause(FILE *fp, const uint32_t *words, unsigned *size, unsigned offset,
                done = stop;
                break;
             default:
-               unreachable("[INSTR_INVALID_ENC] Invalid tag bits");
+               UNREACHABLE("[INSTR_INVALID_ENC] Invalid tag bits");
             }
             break;
          case 0x2:
diff --git a/src/panfrost/compiler/bifrost_compile.c b/src/panfrost/compiler/bifrost_compile.c
index 873be4127dedc..ecdc978cfdca0 100644
--- a/src/panfrost/compiler/bifrost_compile.c
+++ b/src/panfrost/compiler/bifrost_compile.c
@@ -134,7 +134,7 @@ bi_emit_jump(bi_builder *b, nir_jump_instr *instr)
       branch->branch_target = b->shader->continue_block;
       break;
    default:
-      unreachable("Unhandled jump type");
+      UNREACHABLE("Unhandled jump type");
    }
 
    bi_block_add_successor(b->shader->current_block, branch->branch_target);
@@ -408,7 +408,7 @@ bi_reg_fmt_for_nir(nir_alu_type T)
    case nir_type_uint32:
       return BI_REGISTER_FORMAT_U32;
    default:
-      unreachable("Invalid type for register format");
+      UNREACHABLE("Invalid type for register format");
    }
 }
 
@@ -1599,7 +1599,7 @@ bi_atom_opc_for_nir(nir_atomic_op op)
    case nir_atomic_op_ixor: return BI_ATOM_OPC_AXOR;
    case nir_atomic_op_xchg: return BI_ATOM_OPC_AXCHG;
    case nir_atomic_op_cmpxchg: return BI_ATOM_OPC_AXCHG;
-   default: unreachable("Unexpected computational atomic");
+   default: UNREACHABLE("Unexpected computational atomic");
    }
    /* clang-format on */
 }
@@ -2038,7 +2038,7 @@ bi_subgroup_from_cluster_size(unsigned cluster_size)
    case 4: return BI_SUBGROUP_SUBGROUP4;
    case 8: return BI_SUBGROUP_SUBGROUP8;
    case 16: return BI_SUBGROUP_SUBGROUP16;
-   default: unreachable("Unsupported cluster size");
+   default: UNREACHABLE("Unsupported cluster size");
    }
 }
 
@@ -2072,7 +2072,7 @@ bi_emit_intrinsic(bi_builder *b, nir_intrinsic_instr *instr)
       else if (stage == MESA_SHADER_VERTEX)
          bi_emit_load_attr(b, instr);
       else
-         unreachable("Unsupported shader stage");
+         UNREACHABLE("Unsupported shader stage");
       break;
 
    case nir_intrinsic_store_output:
@@ -2082,7 +2082,7 @@ bi_emit_intrinsic(bi_builder *b, nir_intrinsic_instr *instr)
       else if (stage == MESA_SHADER_VERTEX)
          bi_emit_store_vary(b, instr);
       else
-         unreachable("Unsupported shader stage");
+         UNREACHABLE("Unsupported shader stage");
       break;
 
    case nir_intrinsic_store_combined_output_pan:
@@ -2145,7 +2145,7 @@ bi_emit_intrinsic(bi_builder *b, nir_intrinsic_instr *instr)
          break;
 
       default:
-         unreachable("Unsupported barrier scope");
+         UNREACHABLE("Unsupported barrier scope");
       }
 
       break;
@@ -2537,7 +2537,7 @@ bi_nir_round(nir_op op)
    case nir_op_ffloor:
       return BI_ROUND_RTN;
    default:
-      unreachable("invalid nir round op");
+      UNREACHABLE("invalid nir round op");
    }
 }
 
@@ -2778,7 +2778,7 @@ bi_translate_cmpf(nir_op op)
       return BI_CMPF_GE;
 
    default:
-      unreachable("invalid comparison");
+      UNREACHABLE("invalid comparison");
    }
 }
 
@@ -3667,7 +3667,7 @@ bi_emit_alu(bi_builder *b, nir_alu_instr *instr)
 
    default:
       fprintf(stderr, "Unhandled ALU op %s\n", nir_op_infos[instr->op].name);
-      unreachable("Unknown ALU op");
+      UNREACHABLE("Unknown ALU op");
    }
 }
 
@@ -3696,7 +3696,7 @@ bifrost_tex_format(enum glsl_sampler_dim dim)
       return 0;
 
    default:
-      unreachable("Unknown sampler dim type\n");
+      UNREACHABLE("Unknown sampler dim type\n");
    }
 }
 
@@ -3723,7 +3723,7 @@ valhall_tex_dimension(enum glsl_sampler_dim dim)
       return BI_DIMENSION_CUBE;
 
    default:
-      unreachable("Unknown sampler dim type");
+      UNREACHABLE("Unknown sampler dim type");
    }
 }
 
@@ -3744,7 +3744,7 @@ bi_texture_format(nir_alu_type T, enum bi_clamp clamp)
    case nir_type_int32:
       return BIFROST_TEXTURE_FORMAT_S32;
    default:
-      unreachable("Invalid type for texturing");
+      UNREACHABLE("Invalid type for texturing");
    }
 }
 
@@ -4007,9 +4007,9 @@ bi_tex_op(nir_texop op)
    case nir_texop_query_levels:
    case nir_texop_texture_samples:
    case nir_texop_samples_identical:
-      unreachable("should've been lowered");
+      UNREACHABLE("should've been lowered");
    default:
-      unreachable("unsupported tex op");
+      UNREACHABLE("unsupported tex op");
    }
 }
 
@@ -4058,7 +4058,7 @@ bi_emit_texc(bi_builder *b, nir_tex_instr *instr)
    case BIFROST_TEX_OP_GRDESC:
       break;
    default:
-      unreachable("texture op unsupported");
+      UNREACHABLE("texture op unsupported");
    }
 
    /* 32-bit indices to be allocated as consecutive staging registers */
@@ -4161,7 +4161,7 @@ bi_emit_texc(bi_builder *b, nir_tex_instr *instr)
          break;
 
       default:
-         unreachable("Unhandled src type in texc emit");
+         UNREACHABLE("Unhandled src type in texc emit");
       }
    }
 
@@ -4445,7 +4445,7 @@ bi_emit_tex_valhall(bi_builder *b, nir_tex_instr *instr)
          break;
 
       default:
-         unreachable("Unhandled src type in tex emit");
+         UNREACHABLE("Unhandled src type in tex emit");
       }
    }
 
@@ -4599,7 +4599,7 @@ bi_emit_tex_valhall(bi_builder *b, nir_tex_instr *instr)
                        explicit_offset, !narrow_indices, mask, sr_count);
       break;
    default:
-      unreachable("Unhandled Valhall texture op");
+      UNREACHABLE("Unhandled Valhall texture op");
    }
 
    /* The hardware will write only what we read, and it will into
@@ -4804,7 +4804,7 @@ bi_emit_instr(bi_builder *b, struct nir_instr *instr)
       break;
 
    default:
-      unreachable("should've been lowered");
+      UNREACHABLE("should've been lowered");
    }
 }
 
@@ -4942,7 +4942,7 @@ emit_cf_list(bi_context *ctx, struct exec_list *list)
          break;
 
       default:
-         unreachable("Unknown control flow");
+         UNREACHABLE("Unknown control flow");
       }
    }
 
diff --git a/src/panfrost/compiler/bir.c b/src/panfrost/compiler/bir.c
index 00b03955b0844..11e711d79de16 100644
--- a/src/panfrost/compiler/bir.c
+++ b/src/panfrost/compiler/bir.c
@@ -59,7 +59,7 @@ bi_is_regfmt_16(enum bi_register_format fmt)
    case BI_REGISTER_FORMAT_AUTO:
       return false;
    default:
-      unreachable("Invalid register format");
+      UNREACHABLE("Invalid register format");
    }
 }
 
@@ -81,7 +81,7 @@ bi_count_staging_registers(const bi_instr *ins)
       return ins->sr_count;
    }
 
-   unreachable("Invalid sr_count");
+   UNREACHABLE("Invalid sr_count");
 }
 
 unsigned
@@ -234,7 +234,7 @@ bi_side_effects(const bi_instr *I)
       return (I->op != BI_OPCODE_LD_TILE);
    }
 
-   unreachable("Invalid message type");
+   UNREACHABLE("Invalid message type");
 }
 
 /* Branch reconvergence is required when the execution mask may change
@@ -288,7 +288,7 @@ bi_csel_for_mux(bool must_sign, bool b32, enum bi_mux mux)
    case BI_MUX_FP_ZERO:
       return b32 ? BI_OPCODE_CSEL_F32 : BI_OPCODE_CSEL_V2F16;
    default:
-      unreachable("No CSEL for MUX.bit");
+      UNREACHABLE("No CSEL for MUX.bit");
    }
 }
 
diff --git a/src/panfrost/compiler/compiler.h b/src/panfrost/compiler/compiler.h
index 739772d13eb5a..02fe0b4440c94 100644
--- a/src/panfrost/compiler/compiler.h
+++ b/src/panfrost/compiler/compiler.h
@@ -161,7 +161,7 @@ bi_apply_swizzle(uint32_t value, enum bi_swizzle swz)
 #undef H
 #undef B
 
-   unreachable("Invalid swizzle");
+   UNREACHABLE("Invalid swizzle");
 }
 
 enum bi_index_type {
@@ -913,7 +913,7 @@ bi_block_add_successor(bi_block *block, bi_block *successor)
       return;
    }
 
-   unreachable("Too many successors");
+   UNREACHABLE("Too many successors");
 }
 
 /* Subset of pan_shader_info needed per-variant, in order to support IDVS */
@@ -1245,7 +1245,7 @@ bi_predecessor_index(bi_block *succ, bi_block *pred)
       index++;
    }
 
-   unreachable("Invalid predecessor");
+   UNREACHABLE("Invalid predecessor");
 }
 
 static inline bi_instr *
@@ -1599,7 +1599,7 @@ bi_builder_insert(bi_cursor *cursor, bi_instr *I)
       return;
    }
 
-   unreachable("Invalid cursor option");
+   UNREACHABLE("Invalid cursor option");
 }
 
 bi_instr *bi_csel_from_mux(bi_builder *b, const bi_instr *I, bool must_sign);
diff --git a/src/panfrost/compiler/valhall/va_lower_isel.c b/src/panfrost/compiler/valhall/va_lower_isel.c
index 2c441348e209d..7e79d9f75f4fb 100644
--- a/src/panfrost/compiler/valhall/va_lower_isel.c
+++ b/src/panfrost/compiler/valhall/va_lower_isel.c
@@ -63,7 +63,7 @@ va_compose_mkvec_swz_v4i8(bi_index *b, enum bi_swizzle swz)
       B(1, 1, 2, 3);
 
    default:
-      unreachable("Invalid swizzle");
+      UNREACHABLE("Invalid swizzle");
       break;
    }
 
diff --git a/src/panfrost/compiler/valhall/va_optimize.c b/src/panfrost/compiler/valhall/va_optimize.c
index 2f845f4430035..4ed4cebf65af6 100644
--- a/src/panfrost/compiler/valhall/va_optimize.c
+++ b/src/panfrost/compiler/valhall/va_optimize.c
@@ -117,7 +117,7 @@ va_fuse_add_imm(bi_instr *I)
       else if (I->op == BI_OPCODE_FADD_IMM_V2F16)
          I->index ^= (1u << 31) | (1u << 15);
       else
-         unreachable("unexpected .neg");
+         UNREACHABLE("unexpected .neg");
    }
 
    I->src[0] = I->src[1 - s];
diff --git a/src/panfrost/compiler/valhall/va_pack.c b/src/panfrost/compiler/valhall/va_pack.c
index b177403dfe7c7..bc4e2a62f8fbe 100644
--- a/src/panfrost/compiler/valhall/va_pack.c
+++ b/src/panfrost/compiler/valhall/va_pack.c
@@ -49,7 +49,7 @@ NORETURN static void PRINTFLIKE(2, 3)
    bi_print_instr(I, stderr);
    fprintf(stderr, "\n");
 
-   unreachable("Invalid instruction");
+   UNREACHABLE("Invalid instruction");
 }
 
 /*
@@ -435,7 +435,7 @@ va_pack_rhadd(const bi_instr *I)
    case BI_ROUND_RTP:
       return BITFIELD_BIT(30); /* rhadd */
    default:
-      unreachable("Invalid round for HADD");
+      UNREACHABLE("Invalid round for HADD");
    }
 }
 
diff --git a/src/panfrost/compiler/valhall/va_perf.c b/src/panfrost/compiler/valhall/va_perf.c
index 29a1424162feb..efa7c7b4a1dd5 100644
--- a/src/panfrost/compiler/valhall/va_perf.c
+++ b/src/panfrost/compiler/valhall/va_perf.c
@@ -73,5 +73,5 @@ va_count_instr_stats(bi_instr *I, struct va_stats *stats)
       return;
    }
 
-   unreachable("Invalid unit");
+   UNREACHABLE("Invalid unit");
 }
diff --git a/src/panfrost/genxml/cs_builder.h b/src/panfrost/genxml/cs_builder.h
index 04733f12eefaa..968a900a673ba 100644
--- a/src/panfrost/genxml/cs_builder.h
+++ b/src/panfrost/genxml/cs_builder.h
@@ -1100,9 +1100,9 @@ cs_invert_cond(enum mali_cs_condition cond)
    case MALI_CS_CONDITION_GEQUAL:
       return MALI_CS_CONDITION_LESS;
    case MALI_CS_CONDITION_ALWAYS:
-      unreachable("cannot invert ALWAYS");
+      UNREACHABLE("cannot invert ALWAYS");
    default:
-      unreachable("invalid cond");
+      UNREACHABLE("invalid cond");
    }
 }
 
@@ -1146,7 +1146,7 @@ cs_branch_label_cond64(struct cs_builder *b, struct cs_label *label,
       cs_branch_label_cond32(b, label, MALI_CS_CONDITION_EQUAL, val_hi);
       break;
    default:
-      unreachable("unsupported 64bit condition");
+      UNREACHABLE("unsupported 64bit condition");
    }
 
    cs_set_label(b, &false_label);
diff --git a/src/panfrost/genxml/decode.c b/src/panfrost/genxml/decode.c
index c59896330ccb8..fbfaa056baf75 100644
--- a/src/panfrost/genxml/decode.c
+++ b/src/panfrost/genxml/decode.c
@@ -91,7 +91,7 @@ pandecode_rt(struct pandecode_context *ctx, unsigned index, uint64_t gpu_va)
                     "AFRC YUV Color Render Target %d:\n", index);
       break;
    default:
-      unreachable("Invalid writeback mode");
+      UNREACHABLE("Invalid writeback mode");
    }
 #endif
 
@@ -180,7 +180,7 @@ pandecode_zs_crc_ext(struct pandecode_context *ctx, uint64_t gpu_va)
       break;
 
    default:
-      unreachable("Invalid block format");
+      UNREACHABLE("Invalid block format");
    }
 
    switch (zs_crc.s.block_format) {
@@ -201,7 +201,7 @@ pandecode_zs_crc_ext(struct pandecode_context *ctx, uint64_t gpu_va)
 #endif
 
    default:
-      unreachable("Invalid block format");
+      UNREACHABLE("Invalid block format");
    }
 
    pandecode_log(ctx, "\n");
@@ -465,7 +465,7 @@ pandecode_tex_plane(struct pandecode_context *ctx, uint64_t u, unsigned idx)
       break;
 #endif
    default:
-      unreachable("Unknown plane type");
+      UNREACHABLE("Unknown plane type");
    }
 }
 #endif
diff --git a/src/panfrost/genxml/decode_common.c b/src/panfrost/genxml/decode_common.c
index 67b2ca87ea843..3c150c1da7724 100644
--- a/src/panfrost/genxml/decode_common.c
+++ b/src/panfrost/genxml/decode_common.c
@@ -382,7 +382,7 @@ pandecode_abort_on_fault(struct pandecode_context *ctx, uint64_t jc_gpu_va,
       pandecode_abort_on_fault_v9(ctx, jc_gpu_va);
       break;
    default:
-      unreachable("Unsupported architecture");
+      UNREACHABLE("Unsupported architecture");
    }
 
    simple_mtx_unlock(&ctx->lock);
@@ -410,7 +410,7 @@ pandecode_jc(struct pandecode_context *ctx, uint64_t jc_gpu_va, unsigned gpu_id)
       pandecode_jc_v9(ctx, jc_gpu_va, gpu_id);
       break;
    default:
-      unreachable("Unsupported architecture");
+      UNREACHABLE("Unsupported architecture");
    }
 
    simple_mtx_unlock(&ctx->lock);
@@ -433,7 +433,7 @@ pandecode_interpret_cs(struct pandecode_context *ctx, uint64_t queue_gpu_va,
       pandecode_interpret_cs_v13(ctx, queue_gpu_va, size, gpu_id, regs);
       break;
    default:
-      unreachable("Unsupported architecture");
+      UNREACHABLE("Unsupported architecture");
    }
 
    simple_mtx_unlock(&ctx->lock);
@@ -456,7 +456,7 @@ pandecode_cs_binary(struct pandecode_context *ctx, uint64_t bin_gpu_va,
       pandecode_cs_binary_v13(ctx, bin_gpu_va, size, gpu_id);
       break;
    default:
-      unreachable("Unsupported architecture");
+      UNREACHABLE("Unsupported architecture");
    }
 
    simple_mtx_unlock(&ctx->lock);
@@ -479,7 +479,7 @@ pandecode_cs_trace(struct pandecode_context *ctx, uint64_t trace_gpu_va,
       pandecode_cs_trace_v13(ctx, trace_gpu_va, size, gpu_id);
       break;
    default:
-      unreachable("Unsupported architecture");
+      UNREACHABLE("Unsupported architecture");
    }
 
    simple_mtx_unlock(&ctx->lock);
diff --git a/src/panfrost/lib/pan_afbc.h b/src/panfrost/lib/pan_afbc.h
index 188177d29fd44..4051bfee8352d 100644
--- a/src/panfrost/lib/pan_afbc.h
+++ b/src/panfrost/lib/pan_afbc.h
@@ -288,7 +288,7 @@ pan_afbc_header_subblock_size(struct pan_afbc_headerblock header,
    case 13: return  (header.u64[1] >> 46)  & mask; break;
    case 14: return  (header.u64[1] >> 52)  & mask; break;
    case 15: return  (header.u64[1] >> 58)  & mask; break;
-   default: unreachable("invalid index"); return 0;
+   default: UNREACHABLE("invalid index"); return 0;
    }
 }
 
@@ -694,10 +694,10 @@ pan_afbc_compression_mode(enum pipe_format format, unsigned plane_idx)
    case PAN_AFBC_MODE_YUV422_1C10:
       return MALI_AFBC_COMPRESSION_MODE_YUV422_1C10;
    case PAN_AFBC_MODE_INVALID:
-      unreachable("Invalid AFBC format");
+      UNREACHABLE("Invalid AFBC format");
    }
 
-   unreachable("all AFBC formats handled");
+   UNREACHABLE("all AFBC formats handled");
 }
 #endif
 
diff --git a/src/panfrost/lib/pan_afrc.h b/src/panfrost/lib/pan_afrc.h
index 3e74f912f32fd..df2b648c3f442 100644
--- a/src/panfrost/lib/pan_afrc.h
+++ b/src/panfrost/lib/pan_afrc.h
@@ -265,7 +265,7 @@ pan_afrc_block_size_from_modifier(uint64_t modifier)
    case AFRC_FORMAT_MOD_CU_SIZE_32:
       return 32;
    default:
-      unreachable("invalid coding unit size flag in modifier");
+      UNREACHABLE("invalid coding unit size flag in modifier");
    };
 }
 
@@ -313,7 +313,7 @@ pan_afrc_buffer_alignment_from_modifier(uint64_t modifier)
    case AFRC_FORMAT_MOD_CU_SIZE_32:
       return 2048;
    default:
-      unreachable("invalid coding unit size flag in modifier");
+      UNREACHABLE("invalid coding unit size flag in modifier");
    };
 }
 
@@ -419,7 +419,7 @@ pan_afrc_block_size(uint64_t modifier, unsigned index)
    case AFRC_FORMAT_MOD_CU_SIZE_32:
       return MALI_AFRC_BLOCK_SIZE_32;
    default:
-      unreachable("invalid code unit size");
+      UNREACHABLE("invalid code unit size");
    }
 }
 #endif
diff --git a/src/panfrost/lib/pan_blend.c b/src/panfrost/lib/pan_blend.c
index a6ce2d4cf5469..8d948ab950665 100644
--- a/src/panfrost/lib/pan_blend.c
+++ b/src/panfrost/lib/pan_blend.c
@@ -170,7 +170,7 @@ to_c_factor(enum pipe_blendfactor factor)
       return MALI_BLEND_OPERAND_C_CONSTANT;
 
    default:
-      unreachable("Unsupported blend factor");
+      UNREACHABLE("Unsupported blend factor");
    }
 }
 
@@ -242,7 +242,7 @@ to_mali_function(enum pipe_blend_func blend_func,
          function->b = MALI_BLEND_OPERAND_B_SRC_MINUS_DEST;
          break;
       default:
-         unreachable("Invalid blend function");
+         UNREACHABLE("Invalid blend function");
       }
    } else if (is_2srcdest(blend_func, src_factor, dest_factor, is_alpha)) {
       /* src*dest + dest*src = 2*src*dest = 0 + dest*(2*src) */
@@ -271,7 +271,7 @@ to_mali_function(enum pipe_blend_func blend_func,
          function->negate_a = true;
          break;
       default:
-         unreachable("Invalid blend function\n");
+         UNREACHABLE("Invalid blend function\n");
       }
    }
 }
@@ -485,7 +485,7 @@ pan_blend_type_from_nir(nir_alu_type nir_type)
    case nir_type_uint16:
       return MALI_REGISTER_FILE_FORMAT_U16;
    default:
-      unreachable("Unsupported blend shader type for NIR alu type");
+      UNREACHABLE("Unsupported blend shader type for NIR alu type");
       return 0;
    }
 }
@@ -529,7 +529,7 @@ logicop_str(enum pipe_logicop logicop)
    case PIPE_LOGICOP_SET:
       return "set";
    default:
-      unreachable("Invalid logicop\n");
+      UNREACHABLE("Invalid logicop\n");
    }
 }
 
@@ -748,7 +748,7 @@ GENX(pan_blend_get_internal_desc)(enum pipe_format fmt, unsigned rt,
             MALI_REGISTER_FILE_FORMAT_U32;
          break;
       default:
-         unreachable("Invalid format");
+         UNREACHABLE("Invalid format");
       }
 
       cfg.fixed_function.conversion.memory_format =
diff --git a/src/panfrost/lib/pan_desc.c b/src/panfrost/lib/pan_desc.c
index 73126ed413ed1..8ed2f0fc3beaf 100644
--- a/src/panfrost/lib/pan_desc.c
+++ b/src/panfrost/lib/pan_desc.c
@@ -147,7 +147,7 @@ translate_zs_format(enum pipe_format in)
       return MALI_ZS_FORMAT_D32_S8X24;
 #endif
    default:
-      unreachable("Unsupported depth/stencil format.");
+      UNREACHABLE("Unsupported depth/stencil format.");
    }
 }
 
@@ -172,7 +172,7 @@ translate_s_format(enum pipe_format in)
 #endif
 
    default:
-      unreachable("Unsupported stencil format.");
+      UNREACHABLE("Unsupported stencil format.");
    }
 }
 
@@ -586,7 +586,7 @@ pan_mfbd_raw_format(unsigned bits)
    case 1024: return MALI_COLOR_FORMAT_RAW1024;
    case 1536: return MALI_COLOR_FORMAT_RAW1536;
    case 2048: return MALI_COLOR_FORMAT_RAW2048;
-   default: unreachable("invalid raw bpp");
+   default: UNREACHABLE("invalid raw bpp");
    }
    /* clang-format on */
 }
@@ -1219,7 +1219,7 @@ pan_sfbd_raw_format(unsigned bits)
    case   64: return MALI_COLOR_FORMAT_2_32B_CHANNELS;
    case   96: return MALI_COLOR_FORMAT_3_32B_CHANNELS;
    case  128: return MALI_COLOR_FORMAT_4_32B_CHANNELS;
-   default: unreachable("invalid raw bpp");
+   default: UNREACHABLE("invalid raw bpp");
    }
    /* clang-format on */
 }
diff --git a/src/panfrost/lib/pan_desc.h b/src/panfrost/lib/pan_desc.h
index 52cb7c2c9ccc5..75b62d62b0346 100644
--- a/src/panfrost/lib/pan_desc.h
+++ b/src/panfrost/lib/pan_desc.h
@@ -253,7 +253,7 @@ pan_sample_pattern(unsigned samples)
       return MALI_SAMPLE_PATTERN_D3D_16X_GRID;
 #endif
    default:
-      unreachable("Unsupported sample count");
+      UNREACHABLE("Unsupported sample count");
    }
 }
 
diff --git a/src/panfrost/lib/pan_encoder.h b/src/panfrost/lib/pan_encoder.h
index 5d0b66e638338..fc1d9c822b0c0 100644
--- a/src/panfrost/lib/pan_encoder.h
+++ b/src/panfrost/lib/pan_encoder.h
@@ -274,7 +274,7 @@ pan_get_z_internal_format(enum pipe_format fmt)
    case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
       return MALI_Z_INTERNAL_FORMAT_D32;
    default:
-      unreachable("Unsupported depth/stencil format.");
+      UNREACHABLE("Unsupported depth/stencil format.");
    }
 }
 #endif
diff --git a/src/panfrost/lib/pan_format.c b/src/panfrost/lib/pan_format.c
index 1de9d84fa9f4a..b6bd4d703b903 100644
--- a/src/panfrost/lib/pan_format.c
+++ b/src/panfrost/lib/pan_format.c
@@ -657,7 +657,7 @@ GENX(pan_decompose_swizzle)(enum mali_rgb_component_order order)
       CASE(0001, 0001, X, Y, Z, W);
       CASE(0000, 0000, X, Y, Z, W);
    default:
-      unreachable("Invalid case for texturing");
+      UNREACHABLE("Invalid case for texturing");
    }
 
 #undef CASE
diff --git a/src/panfrost/lib/pan_format.h b/src/panfrost/lib/pan_format.h
index 63612e81f8bd2..bce015c919100 100644
--- a/src/panfrost/lib/pan_format.h
+++ b/src/panfrost/lib/pan_format.h
@@ -238,7 +238,7 @@ pan_get_default_swizzle(unsigned components)
    case 4:
       return PAN_V6_SWIZZLE(R, G, B, A);
    default:
-      unreachable("Invalid number of components");
+      UNREACHABLE("Invalid number of components");
    }
 }
 
diff --git a/src/panfrost/lib/pan_mod.h b/src/panfrost/lib/pan_mod.h
index 3146895d2b568..c64ec1b0b0459 100644
--- a/src/panfrost/lib/pan_mod.h
+++ b/src/panfrost/lib/pan_mod.h
@@ -78,7 +78,7 @@ pan_mod_get_handler(unsigned arch, uint64_t modifier)
    case 13:
       return pan_mod_get_handler_v13(modifier);
    default:
-      unreachable("Unsupported arch");
+      UNREACHABLE("Unsupported arch");
    }
 }
 #endif
diff --git a/src/panfrost/lib/pan_texture.c b/src/panfrost/lib/pan_texture.c
index 09fa432128b2e..cf4a2ea383134 100644
--- a/src/panfrost/lib/pan_texture.c
+++ b/src/panfrost/lib/pan_texture.c
@@ -60,7 +60,7 @@ pan_astc_dim_2d(unsigned dim)
    case 12:
       return MALI_ASTC_2D_DIMENSION_12;
    default:
-      unreachable("Invalid ASTC dimension");
+      UNREACHABLE("Invalid ASTC dimension");
    }
 }
 
@@ -77,7 +77,7 @@ pan_astc_dim_3d(unsigned dim)
    case 6:
       return MALI_ASTC_3D_DIMENSION_6;
    default:
-      unreachable("Invalid ASTC dimension");
+      UNREACHABLE("Invalid ASTC dimension");
    }
 }
 #endif
@@ -283,7 +283,7 @@ pan_clump_format(enum pipe_format format)
       case PIPE_FORMAT_R10_G10B10_422_UNORM:
          return MALI_CLUMP_FORMAT_Y10_UV10_422;
       default:
-         unreachable("unhandled clump format");
+         UNREACHABLE("unhandled clump format");
       }
    }
 
@@ -306,7 +306,7 @@ pan_clump_format(enum pipe_format format)
    case 16:
       return MALI_CLUMP_FORMAT_RAW128;
    default:
-      unreachable("Invalid bpp");
+      UNREACHABLE("Invalid bpp");
    }
 }
 
@@ -323,7 +323,7 @@ translate_superblock_size(uint64_t modifier)
    case AFBC_FORMAT_MOD_BLOCK_SIZE_64x4:
       return MALI_AFBC_SUPERBLOCK_SIZE_64X4;
    default:
-      unreachable("Invalid superblock size");
+      UNREACHABLE("Invalid superblock size");
    }
 }
 
@@ -705,7 +705,7 @@ emit_afbc_chroma_2p_plane(const struct pan_image_view *iview,
                           unsigned mip_level, unsigned layer_or_z_slice,
                           void *payload)
 {
-   unreachable("AFBC chroma 2p plane not supported");
+   UNREACHABLE("AFBC chroma 2p plane not supported");
 }
 
 #if PAN_ARCH >= 10
@@ -1147,7 +1147,7 @@ pan_modifier_to_layout(uint64_t modifier)
    else if (modifier == DRM_FORMAT_MOD_LINEAR)
       return MALI_TEXTURE_LAYOUT_LINEAR;
    else
-      unreachable("Invalid modifer");
+      UNREACHABLE("Invalid modifer");
 }
 #endif
 
diff --git a/src/panfrost/libpan/query_pool.cl b/src/panfrost/libpan/query_pool.cl
index 180e422bb0fa0..8075f1cbf1d12 100644
--- a/src/panfrost/libpan/query_pool.cl
+++ b/src/panfrost/libpan/query_pool.cl
@@ -43,7 +43,7 @@ compute_timestamp_query_result(global uint64_t *report_addr,
       break;
    }
    default:
-      unreachable("Invalid timestamp op");
+      UNREACHABLE("Invalid timestamp op");
       break;
    }
 
@@ -131,7 +131,7 @@ panlib_copy_query_result(uint64_t pool_addr, global uint32_t *available_addr,
          write_occlusion_query_result(dst, 0, flags, report_addr, report_count);
          break;
       default:
-         unreachable("Unsupported query type");
+         UNREACHABLE("Unsupported query type");
          break;
       }
    }
diff --git a/src/panfrost/midgard/disassemble.c b/src/panfrost/midgard/disassemble.c
index ebe3a54bcab52..45315e38b2b1e 100644
--- a/src/panfrost/midgard/disassemble.c
+++ b/src/panfrost/midgard/disassemble.c
@@ -165,7 +165,7 @@ validate_expand_mode(midgard_src_expand_mode expand_mode,
       break;
 
    default:
-      unreachable("Invalid expand mode");
+      UNREACHABLE("Invalid expand mode");
       break;
    }
 }
@@ -250,7 +250,7 @@ print_ldst_read_reg(FILE *fp, unsigned reg)
       fprintf(fp, "0");
       break;
    default:
-      unreachable("Invalid load/store register read");
+      UNREACHABLE("Invalid load/store register read");
    }
 }
 
@@ -274,7 +274,7 @@ print_tex_reg(FILE *fp, unsigned reg, bool is_write)
       fprintf(fp, "%s%d", str, select);
       break;
    default:
-      unreachable("Invalid texture register");
+      UNREACHABLE("Invalid texture register");
    }
 }
 
@@ -353,7 +353,7 @@ bits_for_mode(midgard_reg_mode mode)
    case midgard_reg_mode_64:
       return 64;
    default:
-      unreachable("Invalid reg mode");
+      UNREACHABLE("Invalid reg mode");
       return 0;
    }
 }
@@ -485,7 +485,7 @@ print_vec_swizzle(FILE *fp, unsigned swizzle, midgard_src_expand_mode expand,
       break;
 
    default:
-      unreachable("Invalid expand mode");
+      UNREACHABLE("Invalid expand mode");
       break;
    }
 
@@ -563,7 +563,7 @@ print_vector_constants(FILE *fp, unsigned src_binary,
             c += !upper * 4;
             break;
          default:
-            unreachable("invalid expand mode");
+            UNREACHABLE("invalid expand mode");
             break;
          }
       } else if (bits == 32 && !expands) {
@@ -590,7 +590,7 @@ print_vector_constants(FILE *fp, unsigned src_binary,
             c += !upper * 8;
             break;
          default:
-            unreachable("invalid expand mode");
+            UNREACHABLE("invalid expand mode");
             break;
          }
 
@@ -1280,7 +1280,7 @@ print_varying_parameters(FILE *fp, midgard_load_store_word *word)
       fprintf(fp, ".perspectivew");
       break;
    default:
-      unreachable("invalid varying modifier");
+      UNREACHABLE("invalid varying modifier");
       break;
    }
 }
@@ -1527,7 +1527,7 @@ print_texture_format(FILE *fp, int format)
       DEFINE_CASE(0, "cube");
 
    default:
-      unreachable("Bad format");
+      UNREACHABLE("Bad format");
    }
 }
 
diff --git a/src/panfrost/midgard/midgard_compile.c b/src/panfrost/midgard/midgard_compile.c
index 11ac910c0d3b0..21a3fb62348cb 100644
--- a/src/panfrost/midgard/midgard_compile.c
+++ b/src/panfrost/midgard/midgard_compile.c
@@ -176,7 +176,7 @@ M_LOAD(lea_image, nir_type_uint64);
       case nir_type_int32:                                                     \
          return m_##op##_image_32i(val, address);                              \
       default:                                                                 \
-         unreachable("Invalid image type");                                    \
+         UNREACHABLE("Invalid image type");                                    \
       }                                                                        \
    }
 
@@ -592,7 +592,7 @@ emit_load_const(compiler_context *ctx, nir_load_const_instr *instr)
       RAW_CONST_COPY(8);
       break;
    default:
-      unreachable("Invalid bit_size for load_const instruction\n");
+      UNREACHABLE("Invalid bit_size for load_const instruction\n");
    }
 
    /* Shifted for SSA, +1 for off-by-one */
@@ -1105,7 +1105,7 @@ emit_ubo_read(compiler_context *ctx, nir_instr *instr, unsigned dest,
    else if (bitsize <= 128)
       ins = m_ld_ubo_128(dest, 0);
    else
-      unreachable("Invalid UBO read size");
+      UNREACHABLE("Invalid UBO read size");
 
    ins.constants.u32[0] = offset;
 
@@ -1163,7 +1163,7 @@ emit_global(compiler_context *ctx, nir_instr *instr, bool is_read,
          ins = m_ld_128(srcdest, 0);
          break;
       default:
-         unreachable("Invalid global read size");
+         UNREACHABLE("Invalid global read size");
       }
 
       mir_set_intr_mask(instr, &ins, is_read);
@@ -1211,7 +1211,7 @@ emit_global(compiler_context *ctx, nir_instr *instr, bool is_read,
       else if (bitsize <= 128)
          ins = m_st_128(srcdest, 0);
       else
-         unreachable("Invalid global store size");
+         UNREACHABLE("Invalid global store size");
 
       mir_set_intr_mask(instr, &ins, is_read);
    }
@@ -1245,7 +1245,7 @@ translate_atomic_op(nir_atomic_op op)
    case nir_atomic_op_umax:    return midgard_op_atomic_umax;
    case nir_atomic_op_umin:    return midgard_op_atomic_umin;
    case nir_atomic_op_ixor:    return midgard_op_atomic_xor;
-   default: unreachable("Unexpected atomic");
+   default: UNREACHABLE("Unexpected atomic");
    }
    /* clang-format on */
 }
@@ -1364,7 +1364,7 @@ emit_varying_read(compiler_context *ctx, unsigned dest, unsigned offset,
          ins.op = midgard_op_ld_vary_16;
          break;
       default:
-         unreachable("Attempted to load unknown type");
+         UNREACHABLE("Attempted to load unknown type");
          break;
       }
    } else if (flat) {
@@ -1462,7 +1462,7 @@ emit_attr_read(compiler_context *ctx, unsigned dest, unsigned offset,
       ins.op = midgard_op_ld_attr_32;
       break;
    default:
-      unreachable("Attempted to load unknown type");
+      UNREACHABLE("Attempted to load unknown type");
       break;
    }
 
@@ -1480,7 +1480,7 @@ compute_builtin_arg(nir_intrinsic_op op)
    case nir_intrinsic_load_global_invocation_id:
       return REGISTER_LDST_GLOBAL_THREAD_ID;
    default:
-      unreachable("Invalid compute paramater loaded");
+      UNREACHABLE("Invalid compute paramater loaded");
    }
 }
 
@@ -1559,7 +1559,7 @@ vertex_builtin_arg(nir_intrinsic_op op)
    case nir_intrinsic_load_instance_id:
       return PAN_INSTANCE_ID;
    default:
-      unreachable("Invalid vertex builtin");
+      UNREACHABLE("Invalid vertex builtin");
    }
 }
 
@@ -1613,7 +1613,7 @@ output_load_rt_addr(compiler_context *ctx, nir_intrinsic_instr *instr)
    if (loc == FRAG_RESULT_STENCIL)
       return 0x1E;
 
-   unreachable("Invalid RT to load from");
+   UNREACHABLE("Invalid RT to load from");
 }
 
 static void
@@ -1743,7 +1743,7 @@ emit_intrinsic(compiler_context *ctx, nir_intrinsic_instr *instr)
       } else if (ctx->stage == MESA_SHADER_VERTEX) {
          emit_attr_read(ctx, reg, offset, nr_comp, t);
       } else {
-         unreachable("Unknown load");
+         UNREACHABLE("Unknown load");
       }
 
       break;
@@ -1928,7 +1928,7 @@ emit_intrinsic(compiler_context *ctx, nir_intrinsic_instr *instr)
 
          emit_mir_instruction(ctx, &st);
       } else {
-         unreachable("Unknown store");
+         UNREACHABLE("Unknown store");
       }
 
       break;
@@ -2043,7 +2043,7 @@ midgard_tex_format(enum glsl_sampler_dim dim)
       return 0;
 
    default:
-      unreachable("Unknown sampler dim type");
+      UNREACHABLE("Unknown sampler dim type");
    }
 }
 
@@ -2366,7 +2366,7 @@ emit_jump(compiler_context *ctx, nir_jump_instr *instr)
    }
 
    default:
-      unreachable("Unhandled jump");
+      UNREACHABLE("Unhandled jump");
    }
 }
 
@@ -2399,7 +2399,7 @@ emit_instr(compiler_context *ctx, struct nir_instr *instr)
       break;
 
    default:
-      unreachable("Unhandled instruction type");
+      UNREACHABLE("Unhandled instruction type");
    }
 }
 
@@ -2532,7 +2532,7 @@ reg_mode_for_bitsize(unsigned bitsize)
    case 64:
       return midgard_reg_mode_64;
    default:
-      unreachable("invalid bit size");
+      UNREACHABLE("invalid bit size");
    }
 }
 
diff --git a/src/panfrost/midgard/midgard_derivatives.c b/src/panfrost/midgard/midgard_derivatives.c
index d72a368756be9..0a63fe79681fe 100644
--- a/src/panfrost/midgard/midgard_derivatives.c
+++ b/src/panfrost/midgard/midgard_derivatives.c
@@ -65,7 +65,7 @@ mir_derivative_mode(nir_intrinsic_op op)
       return TEXTURE_DFDY;
 
    default:
-      unreachable("Invalid derivative op");
+      UNREACHABLE("Invalid derivative op");
    }
 }
 
diff --git a/src/panfrost/midgard/midgard_emit.c b/src/panfrost/midgard/midgard_emit.c
index 1dd0671115efd..cdf40d7227a98 100644
--- a/src/panfrost/midgard/midgard_emit.c
+++ b/src/panfrost/midgard/midgard_emit.c
@@ -261,7 +261,7 @@ mir_pack_swizzle(unsigned mask, unsigned *swizzle, unsigned sz,
 
          *expand_mode = hi ? midgard_src_expand_high : midgard_src_expand_low;
       } else if (sz < 32) {
-         unreachable("Cannot encode 8/16 swizzle in 64-bit");
+         UNREACHABLE("Cannot encode 8/16 swizzle in 64-bit");
       }
    } else {
       /* For 32-bit, swizzle packing is stupid-simple. For 16-bit,
@@ -312,7 +312,7 @@ mir_pack_swizzle(unsigned mask, unsigned *swizzle, unsigned sz,
          *expand_mode =
             upper ? midgard_src_expand_high : midgard_src_expand_low;
       } else if (reg_mode == midgard_reg_mode_8) {
-         unreachable("Unhandled reg mode");
+         UNREACHABLE("Unhandled reg mode");
       }
    }
 
@@ -491,7 +491,7 @@ midgard_pack_common_store_mask(midgard_instruction *ins)
       }
       return packed;
    default:
-      unreachable("unexpected ldst opcode");
+      UNREACHABLE("unexpected ldst opcode");
    }
 }
 
@@ -918,7 +918,7 @@ midgard_sampler_type(nir_alu_type t)
    case nir_type_uint:
       return MALI_SAMPLER_UNSIGNED;
    default:
-      unreachable("Unknown sampler type");
+      UNREACHABLE("Unknown sampler type");
    }
 }
 
@@ -1040,6 +1040,6 @@ emit_binary_bundle(compiler_context *ctx, midgard_block *block,
    }
 
    default:
-      unreachable("Unknown midgard instruction type\n");
+      UNREACHABLE("Unknown midgard instruction type\n");
    }
 }
diff --git a/src/panfrost/midgard/midgard_quirks.h b/src/panfrost/midgard/midgard_quirks.h
index ae0acea3f8c4f..f1c5eb660a982 100644
--- a/src/panfrost/midgard/midgard_quirks.h
+++ b/src/panfrost/midgard/midgard_quirks.h
@@ -99,7 +99,7 @@ midgard_get_quirks(unsigned gpu_id)
       return 0;
 
    default:
-      unreachable("Invalid Midgard GPU ID");
+      UNREACHABLE("Invalid Midgard GPU ID");
    }
 }
 
diff --git a/src/panfrost/midgard/midgard_ra.c b/src/panfrost/midgard/midgard_ra.c
index f73d43c548e47..c0d3908d6733d 100644
--- a/src/panfrost/midgard/midgard_ra.c
+++ b/src/panfrost/midgard/midgard_ra.c
@@ -404,7 +404,7 @@ check_read_class(unsigned *classes, unsigned tag, unsigned node)
    case REG_CLASS_WORK:
       return IS_ALU(tag);
    default:
-      unreachable("Invalid class");
+      UNREACHABLE("Invalid class");
    }
 }
 
@@ -424,7 +424,7 @@ check_write_class(unsigned *classes, unsigned tag, unsigned node)
    case REG_CLASS_WORK:
       return IS_ALU(tag) || (tag == TAG_LOAD_STORE_4);
    default:
-      unreachable("Invalid class");
+      UNREACHABLE("Invalid class");
    }
 }
 
@@ -1232,7 +1232,7 @@ mir_spill_register(compiler_context *ctx, unsigned spill_node,
                    unsigned spill_class, unsigned *spill_count)
 {
    if (spill_class == REG_CLASS_WORK && ctx->inputs->is_blend)
-      unreachable("Blend shader spilling is currently unimplemented");
+      UNREACHABLE("Blend shader spilling is currently unimplemented");
 
    unsigned spill_index = ctx->temp_count;
 
diff --git a/src/panfrost/midgard/midgard_schedule.c b/src/panfrost/midgard/midgard_schedule.c
index 79947f11505ba..6209a4e963341 100644
--- a/src/panfrost/midgard/midgard_schedule.c
+++ b/src/panfrost/midgard/midgard_schedule.c
@@ -1172,7 +1172,7 @@ mir_schedule_zs_write(compiler_context *ctx,
       }
    }
 
-   unreachable("Could not schedule Z/S move to any unit");
+   UNREACHABLE("Could not schedule Z/S move to any unit");
 }
 
 static midgard_bundle
@@ -1211,7 +1211,7 @@ mir_schedule_alu(compiler_context *ctx, midgard_instruction **instructions,
       else if (cond->unit == UNIT_SMUL)
          smul = cond;
       else
-         unreachable("Bad condition");
+         UNREACHABLE("Bad condition");
    }
 
    /* If we have a render target reference, schedule a move for it. Since
@@ -1312,7 +1312,7 @@ mir_schedule_alu(compiler_context *ctx, midgard_instruction **instructions,
       else if (cond->unit == UNIT_SADD)
          sadd = cond;
       else
-         unreachable("Bad condition");
+         UNREACHABLE("Bad condition");
    }
 
    /* Stage 2, let's schedule sadd before vmul for writeout */
diff --git a/src/panfrost/midgard/mir.c b/src/panfrost/midgard/mir.c
index 6255fc7314261..97581015e6e24 100644
--- a/src/panfrost/midgard/mir.c
+++ b/src/panfrost/midgard/mir.c
@@ -48,7 +48,7 @@ mir_block_add_successor(midgard_block *block, midgard_block *successor)
       return;
    }
 
-   unreachable("Too many successors");
+   UNREACHABLE("Too many successors");
 }
 
 void
@@ -416,7 +416,7 @@ mir_bundle_idx_for_ins(const midgard_instruction *tag, midgard_block *block)
    }
 
    mir_print_instruction(tag);
-   unreachable("Instruction not scheduled in block");
+   UNREACHABLE("Instruction not scheduled in block");
 }
 
 midgard_instruction *
diff --git a/src/panfrost/perf/pan_perf.c b/src/panfrost/perf/pan_perf.c
index 1fc994669acff..0f2363b658dcb 100644
--- a/src/panfrost/perf/pan_perf.c
+++ b/src/panfrost/perf/pan_perf.c
@@ -88,12 +88,12 @@ pan_perf_init(struct pan_perf *perf, int fd)
    const struct pan_model *model =
       pan_get_model(props.gpu_id, props.gpu_variant);
    if (model == NULL)
-      unreachable("Invalid GPU ID");
+      UNREACHABLE("Invalid GPU ID");
 
    perf->cfg = pan_lookup_counters(model->performance_counters);
 
    if (perf->cfg == NULL)
-      unreachable("Performance counters missing!");
+      UNREACHABLE("Performance counters missing!");
 
    // Generally counter blocks are laid out in the following order:
    // Job manager, tiler, one or more L2 caches, and one or more shader cores.
diff --git a/src/panfrost/shared/pan_minmax_cache.c b/src/panfrost/shared/pan_minmax_cache.c
index a6f98203d8c8f..4f3af6bc2bb5d 100644
--- a/src/panfrost/shared/pan_minmax_cache.c
+++ b/src/panfrost/shared/pan_minmax_cache.c
@@ -75,7 +75,7 @@ pan_calc_cache_key(struct pan_minmax_cache *cache, unsigned index_size,
       index_size = 2;
       break;
    default:
-      unreachable("unknown index size");
+      UNREACHABLE("unknown index size");
    }
    count = count | (index_size << 30);
    ht_key = ((uint64_t)count << 32) | start;
diff --git a/src/panfrost/shared/pan_tiling.c b/src/panfrost/shared/pan_tiling.c
index 49f03dba4a020..5214ec691a163 100644
--- a/src/panfrost/shared/pan_tiling.c
+++ b/src/panfrost/shared/pan_tiling.c
@@ -121,7 +121,7 @@ pan_get_interleave_zs(enum pipe_format format, bool depth, bool stencil)
       } else if (!depth && stencil) {
          return PAN_INTERLEAVE_STENCIL;
       } else if (!depth && !stencil) {
-         unreachable("at least one aspect must be specified");
+         UNREACHABLE("at least one aspect must be specified");
       }
    }
    return PAN_INTERLEAVE_NONE;
diff --git a/src/panfrost/shared/pan_tiling.h b/src/panfrost/shared/pan_tiling.h
index 32589e803770b..9e7bf0cc239e3 100644
--- a/src/panfrost/shared/pan_tiling.h
+++ b/src/panfrost/shared/pan_tiling.h
@@ -130,7 +130,7 @@ void *assume_pixel_aligned(void *ptr, const unsigned pixel_size)
     else if (pixel_size == 16)
         return __builtin_assume_aligned(ptr, 16);
     else
-        unreachable("unexpected pixel size");
+        UNREACHABLE("unexpected pixel size");
 }
 
 static inline
diff --git a/src/panfrost/util/pan_collect_varyings.c b/src/panfrost/util/pan_collect_varyings.c
index e76f953959b50..0c546b0c392e8 100644
--- a/src/panfrost/util/pan_collect_varyings.c
+++ b/src/panfrost/util/pan_collect_varyings.c
@@ -59,7 +59,7 @@ varying_format(nir_alu_type t, unsigned ncomps)
          return conv[i].formats[ncomps - 1];
    }
 
-   unreachable("Invalid type");
+   UNREACHABLE("Invalid type");
 }
 
 struct slot_info {
diff --git a/src/panfrost/util/pan_ir.c b/src/panfrost/util/pan_ir.c
index 3f012e6ede56e..a19d7adf137f7 100644
--- a/src/panfrost/util/pan_ir.c
+++ b/src/panfrost/util/pan_ir.c
@@ -64,7 +64,7 @@ pan_to_bytemask(unsigned bytes, unsigned mask)
    }
 
    default:
-      unreachable("Invalid register mode");
+      UNREACHABLE("Invalid register mode");
    }
 }
 
@@ -80,5 +80,5 @@ pan_lookup_pushed_ubo(struct pan_ubo_push *push, unsigned ubo, unsigned offs)
          return i;
    }
 
-   unreachable("UBO not pushed");
+   UNREACHABLE("UBO not pushed");
 }
diff --git a/src/panfrost/util/pan_lower_framebuffer.c b/src/panfrost/util/pan_lower_framebuffer.c
index 1fb44d233fc0e..016fe22e4be3d 100644
--- a/src/panfrost/util/pan_lower_framebuffer.c
+++ b/src/panfrost/util/pan_lower_framebuffer.c
@@ -62,7 +62,7 @@ pan_unpacked_type_for_format(const struct util_format_description *desc)
    int c = util_format_get_first_non_void_channel(desc->format);
 
    if (c == -1)
-      unreachable("Void format not renderable");
+      UNREACHABLE("Void format not renderable");
 
    bool large = (desc->channel[c].size > 16);
    bool large_norm = (desc->channel[c].size > 8);
@@ -80,7 +80,7 @@ pan_unpacked_type_for_format(const struct util_format_description *desc)
    case UTIL_FORMAT_TYPE_FLOAT:
       return large ? nir_type_float32 : nir_type_float16;
    default:
-      unreachable("Format not renderable");
+      UNREACHABLE("Format not renderable");
    }
 }
 
@@ -371,7 +371,7 @@ pan_unpack_pure(nir_builder *b, nir_def *packed, unsigned size, unsigned nr)
    case 8:
       return pan_unpack_pure_8(b, packed, nr);
    default:
-      unreachable("Unrenderable size");
+      UNREACHABLE("Unrenderable size");
    }
 }
 
@@ -418,7 +418,7 @@ pan_unpack(nir_builder *b, const struct util_format_description *desc,
    }
 
    mesa_loge("%s\n", desc->name);
-   unreachable("Unknown format");
+   UNREACHABLE("Unknown format");
 }
 
 static nir_def *pan_pack(nir_builder *b,
@@ -455,7 +455,7 @@ static nir_def *pan_pack(nir_builder *b,
       case 8:
          return pan_pack_pure_8(b, raw, desc->nr_channels);
       default:
-         unreachable("Unrenderable size");
+         UNREACHABLE("Unrenderable size");
       }
    }
 
@@ -489,7 +489,7 @@ static nir_def *pan_pack(nir_builder *b,
    }
 
    mesa_loge("%s\n", desc->name);
-   unreachable("Unknown format");
+   UNREACHABLE("Unknown format");
 }
 
 static void
diff --git a/src/panfrost/vulkan/csf/panvk_cmd_buffer.h b/src/panfrost/vulkan/csf/panvk_cmd_buffer.h
index fe98a2a656087..92ae12757622f 100644
--- a/src/panfrost/vulkan/csf/panvk_cmd_buffer.h
+++ b/src/panfrost/vulkan/csf/panvk_cmd_buffer.h
@@ -542,7 +542,7 @@ panvk_get_subqueue_stages(enum panvk_subqueue_id subqueue)
       return VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT |
              VK_PIPELINE_STAGE_2_COPY_BIT;
    default:
-      unreachable("Invalid subqueue id");
+      UNREACHABLE("Invalid subqueue id");
    }
 }
 
diff --git a/src/panfrost/vulkan/csf/panvk_vX_cmd_draw.c b/src/panfrost/vulkan/csf/panvk_vX_cmd_draw.c
index 8fec396795df5..47562790b4e0b 100644
--- a/src/panfrost/vulkan/csf/panvk_vX_cmd_draw.c
+++ b/src/panfrost/vulkan/csf/panvk_vX_cmd_draw.c
@@ -544,7 +544,7 @@ translate_stencil_op(VkStencilOp in)
    case VK_STENCIL_OP_INVERT:
       return MALI_STENCIL_OP_INVERT;
    default:
-      unreachable("Invalid stencil op");
+      UNREACHABLE("Invalid stencil op");
    }
 }
 
@@ -576,7 +576,7 @@ translate_prim_topology(VkPrimitiveTopology in)
    case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY:
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
    default:
-      unreachable("Invalid primitive type");
+      UNREACHABLE("Invalid primitive type");
    }
 }
 
@@ -1589,7 +1589,7 @@ get_first_provoking_vertex(struct panvk_cmd_buffer *cmdbuf)
       case U_TRISTATE_UNSET:
          return true;
       default:
-         unreachable("Invalid u_tristate");
+         UNREACHABLE("Invalid u_tristate");
    }
 }
 
diff --git a/src/panfrost/vulkan/csf/panvk_vX_cmd_query.c b/src/panfrost/vulkan/csf/panvk_vX_cmd_query.c
index 00d1c1c9638a9..8f50d230c15ac 100644
--- a/src/panfrost/vulkan/csf/panvk_vX_cmd_query.c
+++ b/src/panfrost/vulkan/csf/panvk_vX_cmd_query.c
@@ -634,7 +634,7 @@ panvk_per_arch(CmdResetQueryPool)(VkCommandBuffer commandBuffer,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -656,7 +656,7 @@ panvk_per_arch(CmdBeginQueryIndexedEXT)(VkCommandBuffer commandBuffer,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -677,7 +677,7 @@ panvk_per_arch(CmdEndQueryIndexedEXT)(VkCommandBuffer commandBuffer,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
 
@@ -718,6 +718,6 @@ panvk_per_arch(CmdCopyQueryPoolResults)(
    }
 #endif
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 }
diff --git a/src/panfrost/vulkan/csf/panvk_vX_gpu_queue.c b/src/panfrost/vulkan/csf/panvk_vX_gpu_queue.c
index 4160c33b128e1..59bd066db40fe 100644
--- a/src/panfrost/vulkan/csf/panvk_vX_gpu_queue.c
+++ b/src/panfrost/vulkan/csf/panvk_vX_gpu_queue.c
@@ -464,7 +464,7 @@ init_subqueue(struct panvk_gpu_queue *queue, enum panvk_subqueue_id subqueue)
       cs_req_res(&b, CS_COMPUTE_RES);
       break;
    default:
-      unreachable("Unknown subqueue");
+      UNREACHABLE("Unknown subqueue");
       break;
    }
 
@@ -1213,7 +1213,7 @@ get_panthor_group_priority(const VkDeviceQueueCreateInfo *create_info)
    case VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR:
       return PANTHOR_GROUP_PRIORITY_REALTIME;
    default:
-      unreachable("Invalid global priority");
+      UNREACHABLE("Invalid global priority");
    }
 }
 
diff --git a/src/panfrost/vulkan/csf/panvk_vX_instr.c b/src/panfrost/vulkan/csf/panvk_vX_instr.c
index 6df6e7b433eee..dfc530575254b 100644
--- a/src/panfrost/vulkan/csf/panvk_vX_instr.c
+++ b/src/panfrost/vulkan/csf/panvk_vX_instr.c
@@ -98,7 +98,7 @@ panvk_per_arch(panvk_instr_begin_work)(enum panvk_subqueue_id id,
       trace_begin_sync_wait(&cmdbuf->utrace.uts[id], &cs_info);
       break;
    default:
-      unreachable("unsupported panvk_instr_work_type");
+      UNREACHABLE("unsupported panvk_instr_work_type");
    }
 }
 
@@ -145,6 +145,6 @@ panvk_per_arch(panvk_instr_end_work_async)(
       trace_end_sync_wait(&cmdbuf->utrace.uts[id], &cs_info);
       break;
    default:
-      unreachable("unsupported panvk_instr_work_type");
+      UNREACHABLE("unsupported panvk_instr_work_type");
    }
 }
diff --git a/src/panfrost/vulkan/jm/panvk_vX_cmd_draw.c b/src/panfrost/vulkan/jm/panvk_vX_cmd_draw.c
index 35c5c0813896d..74f6e8c18b4ea 100644
--- a/src/panfrost/vulkan/jm/panvk_vX_cmd_draw.c
+++ b/src/panfrost/vulkan/jm/panvk_vX_cmd_draw.c
@@ -173,7 +173,7 @@ translate_stencil_op(VkStencilOp in)
    case VK_STENCIL_OP_INVERT:
       return MALI_STENCIL_OP_INVERT;
    default:
-      unreachable("Invalid stencil op");
+      UNREACHABLE("Invalid stencil op");
    }
 }
 
@@ -821,7 +821,7 @@ translate_prim_topology(VkPrimitiveTopology in)
    case VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY:
    case VK_PRIMITIVE_TOPOLOGY_PATCH_LIST:
    default:
-      unreachable("Invalid primitive type");
+      UNREACHABLE("Invalid primitive type");
    }
 }
 
@@ -875,7 +875,7 @@ panvk_emit_tiler_primitive(struct panvk_cmd_buffer *cmdbuf,
             cfg.index_type = MALI_INDEX_TYPE_UINT8;
             break;
          default:
-            unreachable("Invalid index size");
+            UNREACHABLE("Invalid index size");
          }
       } else {
          cfg.index_count = draw->info.vertex.count;
@@ -925,7 +925,7 @@ primitive_vertex_count(enum mali_draw_mode in)
    case MALI_DRAW_MODE_TRIANGLE_FAN:
       return 3;
    default:
-      unreachable("Invalid draw mode");
+      UNREACHABLE("Invalid draw mode");
    }
 }
 
@@ -1528,7 +1528,7 @@ panvk_index_minmax_search(struct panvk_cmd_buffer *cmdbuf, uint32_t start,
       MINMAX_SEARCH_CASE(8)
 #undef MINMAX_SEARCH_CASE
    default:
-      unreachable("Invalid index size");
+      UNREACHABLE("Invalid index size");
    }
 }
 
diff --git a/src/panfrost/vulkan/jm/panvk_vX_cmd_query.c b/src/panfrost/vulkan/jm/panvk_vX_cmd_query.c
index 62850d5d0fedd..1406bf63e90a0 100644
--- a/src/panfrost/vulkan/jm/panvk_vX_cmd_query.c
+++ b/src/panfrost/vulkan/jm/panvk_vX_cmd_query.c
@@ -164,7 +164,7 @@ panvk_per_arch(CmdBeginQueryIndexedEXT)(VkCommandBuffer commandBuffer,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    close_batch(cmd, had_batch);
@@ -199,7 +199,7 @@ panvk_per_arch(CmdEndQueryIndexedEXT)(VkCommandBuffer commandBuffer,
       break;
    }
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    uint64_t available_addr = panvk_query_available_dev_addr(pool, query);
diff --git a/src/panfrost/vulkan/jm/panvk_vX_gpu_queue.c b/src/panfrost/vulkan/jm/panvk_vX_gpu_queue.c
index a7756f290f336..ff3fc4e670129 100644
--- a/src/panfrost/vulkan/jm/panvk_vX_gpu_queue.c
+++ b/src/panfrost/vulkan/jm/panvk_vX_gpu_queue.c
@@ -173,7 +173,7 @@ panvk_add_wait_event_syncobjs(struct panvk_batch *batch, uint32_t *in_fences,
          in_fences[(*nr_in_fences)++] = op->event->syncobj;
          break;
       default:
-         unreachable("bad panvk_cmd_event_op type\n");
+         UNREACHABLE("bad panvk_cmd_event_op type\n");
       }
    }
 }
@@ -206,7 +206,7 @@ panvk_signal_event_syncobjs(struct panvk_gpu_queue *queue,
          /* Nothing left to do */
          break;
       default:
-         unreachable("bad panvk_cmd_event_op type\n");
+         UNREACHABLE("bad panvk_cmd_event_op type\n");
       }
    }
 }
diff --git a/src/panfrost/vulkan/panvk_image.c b/src/panfrost/vulkan/panvk_image.c
index edc921c366763..46dbb0348c3e8 100644
--- a/src/panfrost/vulkan/panvk_image.c
+++ b/src/panfrost/vulkan/panvk_image.c
@@ -237,7 +237,7 @@ panvk_image_type_to_mali_tex_dim(VkImageType type)
    case VK_IMAGE_TYPE_3D:
       return MALI_TEXTURE_DIMENSION_3D;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -568,7 +568,7 @@ get_image_subresource_layout(const struct panvk_image *image,
                memcpy_size->size = slice_layout->size_B / 4;
                break;
             default:
-               unreachable("invalid aspect");
+               UNREACHABLE("invalid aspect");
          }
       } else {
          memcpy_size->size = slice_layout->size_B;
@@ -685,7 +685,7 @@ panvk_image_bind(struct panvk_device *dev,
    if (!mem) {
 #if DETECT_OS_ANDROID
       /* TODO handle VkNativeBufferANDROID when we support ANB */
-      unreachable("VkBindImageMemoryInfo with no memory");
+      UNREACHABLE("VkBindImageMemoryInfo with no memory");
 #else
       const VkBindImageMemorySwapchainInfoKHR *swapchain_info =
          vk_find_struct_const(bind_info->pNext,
diff --git a/src/panfrost/vulkan/panvk_macros.h b/src/panfrost/vulkan/panvk_macros.h
index 927f49756bb75..940d00522bb57 100644
--- a/src/panfrost/vulkan/panvk_macros.h
+++ b/src/panfrost/vulkan/panvk_macros.h
@@ -62,7 +62,7 @@ panvk_catch_indirect_alloc_failure(VkResult error)
          panvk_arch_name(name, v13)(__VA_ARGS__);                              \
          break;                                                                \
       default:                                                                 \
-         unreachable("Unsupported architecture");                              \
+         UNREACHABLE("Unsupported architecture");                              \
       }                                                                        \
    } while (0)
 
@@ -85,7 +85,7 @@ panvk_catch_indirect_alloc_failure(VkResult error)
          ret = panvk_arch_name(name, v13)(__VA_ARGS__);                        \
          break;                                                                \
       default:                                                                 \
-         unreachable("Unsupported architecture");                              \
+         UNREACHABLE("Unsupported architecture");                              \
       }                                                                        \
    } while (0)
 
diff --git a/src/panfrost/vulkan/panvk_utrace_perfetto.cc b/src/panfrost/vulkan/panvk_utrace_perfetto.cc
index ba175d7a31375..ab069d203ae37 100644
--- a/src/panfrost/vulkan/panvk_utrace_perfetto.cc
+++ b/src/panfrost/vulkan/panvk_utrace_perfetto.cc
@@ -46,7 +46,7 @@ get_stage_name(enum panvk_utrace_perfetto_stage stage)
       CASE(SYNC_WAIT);
 #undef CASE
    default:
-      unreachable("bad stage");
+      UNREACHABLE("bad stage");
    }
 }
 
diff --git a/src/panfrost/vulkan/panvk_vX_cmd_draw.c b/src/panfrost/vulkan/panvk_vX_cmd_draw.c
index 86bceb607c141..c64e13d715843 100644
--- a/src/panfrost/vulkan/panvk_vX_cmd_draw.c
+++ b/src/panfrost/vulkan/panvk_vX_cmd_draw.c
@@ -44,7 +44,7 @@ att_set_clear_preload(const VkRenderingAttachmentInfo *att, bool *clear, bool *p
       *preload |= att->storeOp == VK_ATTACHMENT_STORE_OP_NONE;
       break;
    default:
-      unreachable("Unsupported loadOp");
+      UNREACHABLE("Unsupported loadOp");
    }
 }
 
diff --git a/src/panfrost/vulkan/panvk_vX_descriptor_set.c b/src/panfrost/vulkan/panvk_vX_descriptor_set.c
index e6ab1084ff873..81a598576ad1a 100644
--- a/src/panfrost/vulkan/panvk_vX_descriptor_set.c
+++ b/src/panfrost/vulkan/panvk_vX_descriptor_set.c
@@ -697,7 +697,7 @@ panvk_per_arch(descriptor_set_write)(struct panvk_descriptor_set *set,
       break;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
    return VK_SUCCESS;
 }
@@ -766,7 +766,7 @@ panvk_descriptor_set_copy(const VkCopyDescriptorSet *copy)
    }
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 
    return VK_SUCCESS;
@@ -872,7 +872,7 @@ panvk_per_arch(descriptor_set_write_template)(
          break;
 
       default:
-         unreachable("Unsupported descriptor type");
+         UNREACHABLE("Unsupported descriptor type");
       }
    }
 }
diff --git a/src/panfrost/vulkan/panvk_vX_device.c b/src/panfrost/vulkan/panvk_vX_device.c
index 2483cfae715fa..e18c20a41dc97 100644
--- a/src/panfrost/vulkan/panvk_vX_device.c
+++ b/src/panfrost/vulkan/panvk_vX_device.c
@@ -196,7 +196,7 @@ global_priority_to_group_allow_priority_flag(
    case VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR:
       return PAN_KMOD_GROUP_ALLOW_PRIORITY_REALTIME;
    default:
-      unreachable("Invalid global priority");
+      UNREACHABLE("Invalid global priority");
    }
 }
 
@@ -281,7 +281,7 @@ panvk_queue_destroy(struct vk_queue *queue)
       panvk_per_arch(destroy_gpu_queue)(queue);
       break;
    default:
-      unreachable("Unknown queue family");
+      UNREACHABLE("Unknown queue family");
    }
 }
 
diff --git a/src/panfrost/vulkan/panvk_vX_image_view.c b/src/panfrost/vulkan/panvk_vX_image_view.c
index 9e479a8034dfa..c56495541e85d 100644
--- a/src/panfrost/vulkan/panvk_vX_image_view.c
+++ b/src/panfrost/vulkan/panvk_vX_image_view.c
@@ -39,7 +39,7 @@ panvk_view_type_to_mali_tex_dim(VkImageViewType type)
    case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY:
       return MALI_TEXTURE_DIMENSION_CUBE;
    default:
-      unreachable("Invalid view type");
+      UNREACHABLE("Invalid view type");
    }
 }
 
@@ -68,7 +68,7 @@ panvk_convert_swizzle(const VkComponentMapping *in, unsigned char *out)
          out[i] = PIPE_SWIZZLE_W;
          break;
       default:
-         unreachable("Invalid swizzle");
+         UNREACHABLE("Invalid swizzle");
       }
    }
 }
diff --git a/src/panfrost/vulkan/panvk_vX_nir_lower_descriptors.c b/src/panfrost/vulkan/panvk_vX_nir_lower_descriptors.c
index 2c7cc5f99d075..c26279a5a9525 100644
--- a/src/panfrost/vulkan/panvk_vX_nir_lower_descriptors.c
+++ b/src/panfrost/vulkan/panvk_vX_nir_lower_descriptors.c
@@ -91,7 +91,7 @@ addr_format_for_desc_type(VkDescriptorType desc_type,
       return ctx->ssbo_addr_format;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 }
 
@@ -233,7 +233,7 @@ addr_format_for_type(VkDescriptorType type, const struct lower_desc_ctx *ctx)
       return ctx->ssbo_addr_format;
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
       return ~0;
    }
 }
@@ -327,7 +327,7 @@ build_res_index(nir_builder *b, uint32_t set, uint32_t binding,
 #endif
 
    default:
-      unreachable("Unsupported descriptor type");
+      UNREACHABLE("Unsupported descriptor type");
    }
 }
 
@@ -362,7 +362,7 @@ build_res_reindex(nir_builder *b, nir_def *orig, nir_def *delta,
 #endif
 
    default:
-      unreachable("Unhandled address format");
+      UNREACHABLE("Unhandled address format");
    }
 }
 
@@ -436,7 +436,7 @@ build_buffer_addr_for_res_index(nir_builder *b, nir_def *res_index,
 #endif
 
    default:
-      unreachable("Unhandled address format");
+      UNREACHABLE("Unhandled address format");
    }
 }
 
@@ -468,7 +468,7 @@ lower_res_intrinsic(nir_builder *b, nir_intrinsic_instr *intrin,
       break;
 
    default:
-      unreachable("Unhandled resource intrinsic");
+      UNREACHABLE("Unhandled resource intrinsic");
    }
 
    assert(intrin->def.bit_size == res->bit_size);
@@ -772,7 +772,7 @@ lower_tex(nir_builder *b, nir_tex_instr *tex, const struct lower_desc_ctx *ctx)
          res = load_tex_samples(b, deref, dim, ctx);
          break;
       default:
-         unreachable("Unsupported texture query op");
+         UNREACHABLE("Unsupported texture query op");
       }
 
       nir_def_replace(&tex->def, res);
@@ -1116,7 +1116,7 @@ lower_img_intrinsic(nir_builder *b, nir_intrinsic_instr *intr,
          res = load_img_samples(b, deref, dim, ctx);
          break;
       default:
-         unreachable("Unsupported image query op");
+         UNREACHABLE("Unsupported image query op");
       }
 
       nir_def_replace(&intr->def, res);
@@ -1300,7 +1300,7 @@ create_copy_table(nir_shader *nir, struct lower_desc_ctx *ctx)
       dummy_sampler_idx = 0;
       break;
    default:
-      unreachable("unexpected stage");
+      UNREACHABLE("unexpected stage");
    }
    desc_info->dummy_sampler_handle = pan_res_handle(0, dummy_sampler_idx);
 
diff --git a/src/panfrost/vulkan/panvk_vX_query_pool.c b/src/panfrost/vulkan/panvk_vX_query_pool.c
index 81bbfa8fc4930..acde2f7928f2b 100644
--- a/src/panfrost/vulkan/panvk_vX_query_pool.c
+++ b/src/panfrost/vulkan/panvk_vX_query_pool.c
@@ -57,7 +57,7 @@ panvk_per_arch(CreateQueryPool)(VkDevice _device,
    }
 #endif
    default:
-      unreachable("Unsupported query type");
+      UNREACHABLE("Unsupported query type");
    }
 
    pool->reports_per_query = reports_per_query;
@@ -260,7 +260,7 @@ panvk_per_arch(GetQueryPoolResults)(VkDevice _device, VkQueryPool queryPool,
       }
 #endif
       default:
-         unreachable("Unsupported query type");
+         UNREACHABLE("Unsupported query type");
       }
 
       if (!write_results)
diff --git a/src/panfrost/vulkan/panvk_vX_sampler.c b/src/panfrost/vulkan/panvk_vX_sampler.c
index 5143b10769b1a..fdcefa9fb8cf4 100644
--- a/src/panfrost/vulkan/panvk_vX_sampler.c
+++ b/src/panfrost/vulkan/panvk_vX_sampler.c
@@ -26,7 +26,7 @@ panvk_translate_sampler_mipmap_mode(VkSamplerMipmapMode mode)
    case VK_SAMPLER_MIPMAP_MODE_LINEAR:
       return MALI_MIPMAP_MODE_TRILINEAR;
    default:
-      unreachable("Invalid mipmap mode");
+      UNREACHABLE("Invalid mipmap mode");
    }
 }
 
@@ -45,7 +45,7 @@ panvk_translate_sampler_address_mode(VkSamplerAddressMode mode)
    case VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE:
       return MALI_WRAP_MODE_MIRRORED_CLAMP_TO_EDGE;
    default:
-      unreachable("Invalid wrap");
+      UNREACHABLE("Invalid wrap");
    }
 }
 
@@ -70,7 +70,7 @@ panvk_translate_reduction_mode(VkSamplerReductionMode reduction_mode)
    case VK_SAMPLER_REDUCTION_MODE_MAX:
       return MALI_REDUCTION_MODE_MAXIMUM;
    default:
-      unreachable("Invalid reduction mode");
+      UNREACHABLE("Invalid reduction mode");
    }
 }
 #endif
diff --git a/src/panfrost/vulkan/panvk_vX_shader.c b/src/panfrost/vulkan/panvk_vX_shader.c
index d32a422a58f52..8dc721be7f441 100644
--- a/src/panfrost/vulkan/panvk_vX_shader.c
+++ b/src/panfrost/vulkan/panvk_vX_shader.c
@@ -342,7 +342,7 @@ panvk_buffer_ubo_addr_format(VkPipelineRobustnessBufferBehaviorEXT robustness)
       return PAN_ARCH < 9 ? nir_address_format_32bit_index_offset
                            : nir_address_format_vec2_index_32bit_offset;
    default:
-      unreachable("Invalid robust buffer access behavior");
+      UNREACHABLE("Invalid robust buffer access behavior");
    }
 }
 
@@ -358,7 +358,7 @@ panvk_buffer_ssbo_addr_format(VkPipelineRobustnessBufferBehaviorEXT robustness)
       return PAN_ARCH < 9 ? nir_address_format_64bit_bounded_global
                            : nir_address_format_vec2_index_32bit_offset;
    default:
-      unreachable("Invalid robust buffer access behavior");
+      UNREACHABLE("Invalid robust buffer access behavior");
    }
 }
 
diff --git a/src/util/format/texcompress_s3tc_tmp.h b/src/util/format/texcompress_s3tc_tmp.h
index eb4ab460323f6..c6f4936e48071 100644
--- a/src/util/format/texcompress_s3tc_tmp.h
+++ b/src/util/format/texcompress_s3tc_tmp.h
@@ -1028,7 +1028,7 @@ tx_compress_dxtn(GLint srccomps, GLint width, GLint height,
                        dest, dstRowStride);
       break;
    default:
-      unreachable("unknown DXTn format");
+      UNREACHABLE("unknown DXTn format");
    }
 }
 
diff --git a/src/util/format/u_format_zs.c b/src/util/format/u_format_zs.c
index cc4e8026e4a04..4fe54c5925469 100644
--- a/src/util/format/u_format_zs.c
+++ b/src/util/format/u_format_zs.c
@@ -330,7 +330,7 @@ util_format_z16_unorm_s8_uint_unpack_z_float(float *restrict dst_row, unsigned d
                                              const uint8_t *restrict src_row, unsigned src_stride,
                                              unsigned width, unsigned height)
 {
-   unreachable("z16_s8 packing/unpacking is not implemented.");
+   UNREACHABLE("z16_s8 packing/unpacking is not implemented.");
 }
 
 void
@@ -338,7 +338,7 @@ util_format_z16_unorm_s8_uint_pack_z_float(uint8_t *restrict dst_row, unsigned d
                                            const float *restrict src_row, unsigned src_stride,
                                            unsigned width, unsigned height)
 {
-   unreachable("z16_s8 packing/unpacking is not implemented.");
+   UNREACHABLE("z16_s8 packing/unpacking is not implemented.");
 }
 
 void
@@ -346,7 +346,7 @@ util_format_z16_unorm_s8_uint_unpack_z_32unorm(uint32_t *restrict dst_row, unsig
                                                const uint8_t *restrict src_row, unsigned src_stride,
                                                unsigned width, unsigned height)
 {
-   unreachable("z16_s8 packing/unpacking is not implemented.");
+   UNREACHABLE("z16_s8 packing/unpacking is not implemented.");
 }
 
 void
@@ -354,7 +354,7 @@ util_format_z16_unorm_s8_uint_pack_z_32unorm(uint8_t *restrict dst_row, unsigned
                                              const uint32_t *restrict src_row, unsigned src_stride,
                                              unsigned width, unsigned height)
 {
-   unreachable("z16_s8 packing/unpacking is not implemented.");
+   UNREACHABLE("z16_s8 packing/unpacking is not implemented.");
 }
 
 void
@@ -362,7 +362,7 @@ util_format_z16_unorm_s8_uint_unpack_s_8uint(uint8_t *restrict dst_row, unsigned
                                              const uint8_t *restrict src_row, unsigned src_stride,
                                              unsigned width, unsigned height)
 {
-   unreachable("z16_s8 packing/unpacking is not implemented.");
+   UNREACHABLE("z16_s8 packing/unpacking is not implemented.");
 }
 
 void
@@ -370,7 +370,7 @@ util_format_z16_unorm_s8_uint_pack_s_8uint(uint8_t *restrict dst_row, unsigned d
                                            const uint8_t *restrict src_row, unsigned src_stride,
                                            unsigned width, unsigned height)
 {
-   unreachable("z16_s8 packing/unpacking is not implemented.");
+   UNREACHABLE("z16_s8 packing/unpacking is not implemented.");
 }
 
 void
diff --git a/src/util/log.c b/src/util/log.c
index ecd84447f3421..549941c4b3056 100644
--- a/src/util/log.c
+++ b/src/util/log.c
@@ -30,6 +30,7 @@
 #include "util/log.h"
 #include "util/ralloc.h"
 #include "util/u_debug.h"
+#include "util/macros.h"
 
 #if DETECT_OS_POSIX
 #include <syslog.h>
@@ -157,7 +158,7 @@ level_to_str(enum mesa_log_level l)
    case MESA_LOG_DEBUG: return "debug";
    }
 
-   unreachable("bad mesa_log_level");
+   UNREACHABLE("bad mesa_log_level");
 }
 
 enum logger_vasnprintf_affix {
@@ -272,7 +273,7 @@ level_to_syslog(enum mesa_log_level l)
    case MESA_LOG_DEBUG: return LOG_DEBUG;
    }
 
-   unreachable("bad mesa_log_level");
+   UNREACHABLE("bad mesa_log_level");
 }
 
 static void
@@ -305,7 +306,7 @@ level_to_android(enum mesa_log_level l)
    case MESA_LOG_DEBUG: return ANDROID_LOG_DEBUG;
    }
 
-   unreachable("bad mesa_log_level");
+   UNREACHABLE("bad mesa_log_level");
 }
 
 static void
diff --git a/src/util/macros.h b/src/util/macros.h
index c05c4f95ac53d..bda039162cfab 100644
--- a/src/util/macros.h
+++ b/src/util/macros.h
@@ -118,22 +118,37 @@
 /**
  * Unreachable macro. Useful for suppressing "control reaches end of non-void
  * function" warnings.
+ *
+ * It will also assert, extending the behavior of __builtin_unreachable.
  */
 #if defined(HAVE___BUILTIN_UNREACHABLE) || __has_builtin(__builtin_unreachable)
-#define unreachable(str)    \
+#define UNREACHABLE(str)    \
 do {                        \
    assert(!"" str);         \
    __builtin_unreachable(); \
 } while (0)
 #elif defined (_MSC_VER)
-#define unreachable(str)    \
+#define UNREACHABLE(str)    \
 do {                        \
    assert(!"" str);         \
    __assume(0);             \
 } while (0)
 #else
-#define unreachable(str) assert(!"" str)
+#define UNREACHABLE(str) assert(!"" str)
+#endif
+
+/*
+ * Also define unreachable() when not available already.
+ */
+#if !defined(unreachable)
+#if defined(HAVE___BUILTIN_UNREACHABLE) || __has_builtin(__builtin_unreachable)
+#define unreachable() __builtin_unreachable()
+#elif defined (_MSC_VER)
+#define unreachable() __assume(0)
+#else
+#define unreachable() assert(!"")
 #endif
+#endif // !defined(unreachable)
 
 /**
  * Assume macro. Useful for expressing our assumptions to the compiler,
diff --git a/src/util/u_tristate.h b/src/util/u_tristate.h
index cc40bb715fe12..ebdff5fa154f3 100644
--- a/src/util/u_tristate.h
+++ b/src/util/u_tristate.h
@@ -50,7 +50,7 @@ u_tristate_set(enum u_tristate *state, bool value)
       return (value == true);
 
    default:
-      unreachable("Invalid tristate value");
+      UNREACHABLE("Invalid tristate value");
    }
 }
 
@@ -66,7 +66,7 @@ u_tristate_invert(enum u_tristate tri)
    case U_TRISTATE_NO: return U_TRISTATE_YES;
    }
 
-   unreachable("invalid tristate");
+   UNREACHABLE("invalid tristate");
 }
 
 #endif
diff --git a/src/util/xmlconfig.c b/src/util/xmlconfig.c
index feb1d8b3ad1a2..a2b55d7af563f 100644
--- a/src/util/xmlconfig.c
+++ b/src/util/xmlconfig.c
@@ -269,7 +269,7 @@ parseValue(driOptionValue *v, driOptionType type, const char *string)
       v->_string = strndup(string, STRING_CONF_MAXLEN);
       return true;
    case DRI_SECTION:
-      unreachable("shouldn't be parsing values in section declarations");
+      UNREACHABLE("shouldn't be parsing values in section declarations");
    }
 
    if (tail == string)
@@ -414,7 +414,7 @@ driParseOptionInfo(driOptionCache *info,
          break;
 
       case DRI_SECTION:
-         unreachable("handled above");
+         UNREACHABLE("handled above");
       }
 
       /* Built-in default values should always be valid. */
@@ -521,7 +521,7 @@ driGetOptionsXml(const driOptionDescription *configOptions, unsigned numOptions)
          break;
 
       case DRI_SECTION:
-         unreachable("handled above");
+         UNREACHABLE("handled above");
          break;
       }
       ralloc_asprintf_append(&str, "\"");
diff --git a/src/util/xmlconfig.h b/src/util/xmlconfig.h
index 8fd998a1d3fbd..f64b212952a9a 100644
--- a/src/util/xmlconfig.h
+++ b/src/util/xmlconfig.h
@@ -207,7 +207,7 @@ driComputeOptionsSha1(const driOptionCache *cache, unsigned char *sha1)
                                       cache->values[i]._string);
          break;
       default:
-         unreachable("unsupported dri config type!");
+         UNREACHABLE("unsupported dri config type!");
       }
 
       if (!ret) {
diff --git a/src/virtio/vdrm/vdrm_vpipe.c b/src/virtio/vdrm/vdrm_vpipe.c
index de95c4c0adfbf..629d43bcd9a4c 100644
--- a/src/virtio/vdrm/vdrm_vpipe.c
+++ b/src/virtio/vdrm/vdrm_vpipe.c
@@ -375,7 +375,7 @@ static uint32_t
 vpipe_dmabuf_to_handle(struct vdrm_device *vdev, int fd)
 {
    mesa_loge("%s: unimplemented", __func__);
-   unreachable("unimplemented");
+   UNREACHABLE("unimplemented");
    return 0;
 }
 
diff --git a/src/virtio/vulkan/vn_acceleration_structure.c b/src/virtio/vulkan/vn_acceleration_structure.c
index 1992e94808dad..6339c28254124 100644
--- a/src/virtio/vulkan/vn_acceleration_structure.c
+++ b/src/virtio/vulkan/vn_acceleration_structure.c
@@ -108,7 +108,7 @@ vn_BuildAccelerationStructuresKHR(
    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
 {
    struct vn_device *dev = vn_device_from_handle(device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vn_error(dev->instance, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -119,7 +119,7 @@ vn_CopyAccelerationStructureKHR(
    const VkCopyAccelerationStructureInfoKHR *pInfo)
 {
    struct vn_device *dev = vn_device_from_handle(device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vn_error(dev->instance, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -130,7 +130,7 @@ vn_CopyAccelerationStructureToMemoryKHR(
    const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
 {
    struct vn_device *dev = vn_device_from_handle(device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vn_error(dev->instance, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -141,7 +141,7 @@ vn_CopyMemoryToAccelerationStructureKHR(
    const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
 {
    struct vn_device *dev = vn_device_from_handle(device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vn_error(dev->instance, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -156,6 +156,6 @@ vn_WriteAccelerationStructuresPropertiesKHR(
    size_t stride)
 {
    struct vn_device *dev = vn_device_from_handle(device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vn_error(dev->instance, VK_ERROR_FEATURE_NOT_PRESENT);
 }
diff --git a/src/virtio/vulkan/vn_command_buffer.c b/src/virtio/vulkan/vn_command_buffer.c
index 84c3c1b60a9b8..d0135cb8e9063 100644
--- a/src/virtio/vulkan/vn_command_buffer.c
+++ b/src/virtio/vulkan/vn_command_buffer.c
@@ -112,7 +112,7 @@ vn_cmd_get_cached_storage(struct vn_command_buffer *cmd,
       barriers_size = barrier_count * sizeof(VkImageMemoryBarrier2);
       break;
    default:
-      unreachable("invalid barrier_type");
+      UNREACHABLE("invalid barrier_type");
    }
 
    size_t total_size =
@@ -2389,7 +2389,7 @@ vn_CmdPushDescriptorSetWithTemplate2(VkCommandBuffer commandBuffer,
       stage_flags = VK_SHADER_STAGE_RAYGEN_BIT_KHR;
       break;
    default:
-      unreachable("bad pipeline bind point in the template");
+      UNREACHABLE("bad pipeline bind point in the template");
       break;
    }
    const VkPushDescriptorSetInfo info = {
diff --git a/src/virtio/vulkan/vn_common.c b/src/virtio/vulkan/vn_common.c
index 2d389a8dc197d..f8f9a1fc9cfe0 100644
--- a/src/virtio/vulkan/vn_common.c
+++ b/src/virtio/vulkan/vn_common.c
@@ -233,7 +233,7 @@ vn_relax_get_profile(enum vn_relax_reason reason)
       };
    }
 
-   unreachable("unhandled vn_relax_reason");
+   UNREACHABLE("unhandled vn_relax_reason");
 }
 
 struct vn_relax_state
diff --git a/src/virtio/vulkan/vn_descriptor_set.c b/src/virtio/vulkan/vn_descriptor_set.c
index a23eb27206611..82cff787b1032 100644
--- a/src/virtio/vulkan/vn_descriptor_set.c
+++ b/src/virtio/vulkan/vn_descriptor_set.c
@@ -84,7 +84,7 @@ vn_descriptor_type(VkDescriptorType type)
       break;
    }
 
-   unreachable("bad VkDescriptorType");
+   UNREACHABLE("bad VkDescriptorType");
 }
 
 /* descriptor set layout commands */
@@ -447,7 +447,7 @@ vn_get_mutable_state(const struct vn_descriptor_pool *pool,
       if (BITSET_EQUAL(shared_types, binding->mutable_descriptor_types))
          return mutable_state;
    }
-   unreachable("bad mutable descriptor binding");
+   UNREACHABLE("bad mutable descriptor binding");
 }
 
 static inline void
@@ -953,7 +953,7 @@ vn_descriptor_update_template_init(
       case VK_DESCRIPTOR_TYPE_MUTABLE_EXT:
          break;
       default:
-         unreachable("unhandled descriptor type");
+         UNREACHABLE("unhandled descriptor type");
          break;
       }
    }
@@ -1120,7 +1120,7 @@ vn_descriptor_set_fill_update_with_template(
       case VK_DESCRIPTOR_TYPE_MUTABLE_EXT:
          break;
       default:
-         unreachable("unhandled descriptor type");
+         UNREACHABLE("unhandled descriptor type");
          break;
       }
       update->writes[i] = (VkWriteDescriptorSet){
diff --git a/src/virtio/vulkan/vn_image.c b/src/virtio/vulkan/vn_image.c
index f49e4a5e05352..e8c7d4c1a98da 100644
--- a/src/virtio/vulkan/vn_image.c
+++ b/src/virtio/vulkan/vn_image.c
@@ -882,7 +882,7 @@ vn_image_get_aspect(struct vn_image *img, VkImageAspectFlags aspect)
    default:
       break;
    }
-   unreachable("unexpected aspect");
+   UNREACHABLE("unexpected aspect");
 }
 
 void
diff --git a/src/virtio/vulkan/vn_physical_device.c b/src/virtio/vulkan/vn_physical_device.c
index c7e3685cfd2fc..d1075e61b4ec2 100644
--- a/src/virtio/vulkan/vn_physical_device.c
+++ b/src/virtio/vulkan/vn_physical_device.c
@@ -2508,7 +2508,7 @@ vn_image_init_format_from_cache(
                break;
             }
             default:
-               unreachable("unexpected format props pNext");
+               UNREACHABLE("unexpected format props pNext");
             }
          }
       }
@@ -2592,7 +2592,7 @@ vn_image_store_format_in_cache(
             break;
          }
          default:
-            unreachable("unexpected format props pNext");
+            UNREACHABLE("unexpected format props pNext");
          }
       }
    }
diff --git a/src/virtio/vulkan/vn_query_pool.c b/src/virtio/vulkan/vn_query_pool.c
index b27c8bbb67168..f00071b6e8ef9 100644
--- a/src/virtio/vulkan/vn_query_pool.c
+++ b/src/virtio/vulkan/vn_query_pool.c
@@ -108,7 +108,7 @@ vn_CreateQueryPool(VkDevice device,
       pool->result_array_size = 1;
       break;
    default:
-      unreachable("bad query type");
+      UNREACHABLE("bad query type");
       break;
    }
 
diff --git a/src/virtio/vulkan/vn_queue.c b/src/virtio/vulkan/vn_queue.c
index c609ad506dfa1..3140cc186d6a9 100644
--- a/src/virtio/vulkan/vn_queue.c
+++ b/src/virtio/vulkan/vn_queue.c
@@ -102,7 +102,7 @@ vn_get_wait_semaphore_count(struct vn_queue_submission *submit,
    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
       return submit->sparse_batches[batch_index].waitSemaphoreCount;
    default:
-      unreachable("unexpected batch type");
+      UNREACHABLE("unexpected batch type");
    }
 }
 
@@ -118,7 +118,7 @@ vn_get_signal_semaphore_count(struct vn_queue_submission *submit,
    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
       return submit->sparse_batches[batch_index].signalSemaphoreCount;
    default:
-      unreachable("unexpected batch type");
+      UNREACHABLE("unexpected batch type");
    }
 }
 
@@ -139,7 +139,7 @@ vn_get_wait_semaphore(struct vn_queue_submission *submit,
       return submit->sparse_batches[batch_index]
          .pWaitSemaphores[semaphore_index];
    default:
-      unreachable("unexpected batch type");
+      UNREACHABLE("unexpected batch type");
    }
 }
 
@@ -160,7 +160,7 @@ vn_get_signal_semaphore(struct vn_queue_submission *submit,
       return submit->sparse_batches[batch_index]
          .pSignalSemaphores[semaphore_index];
    default:
-      unreachable("unexpected batch type");
+      UNREACHABLE("unexpected batch type");
    }
 }
 
@@ -255,7 +255,7 @@ vn_get_signal_semaphore_counter(struct vn_queue_submission *submit,
          .pSignalSemaphoreInfos[sem_index]
          .value;
    default:
-      unreachable("unexpected batch type");
+      UNREACHABLE("unexpected batch type");
    }
 }
 
@@ -739,7 +739,7 @@ vn_queue_submission_add_semaphore_feedback(struct vn_queue_submission *submit,
       }
    }
 
-   unreachable("bad feedback sem");
+   UNREACHABLE("bad feedback sem");
 }
 
 static void
@@ -1638,7 +1638,7 @@ vn_GetFenceStatus(VkDevice device, VkFence _fence)
          result = errno == ETIME ? VK_NOT_READY : VK_ERROR_DEVICE_LOST;
       break;
    default:
-      unreachable("unexpected fence payload type");
+      UNREACHABLE("unexpected fence payload type");
       break;
    }
 
diff --git a/src/vulkan/overlay-layer/overlay.cpp b/src/vulkan/overlay-layer/overlay.cpp
index 8693739a1998f..313851c33b824 100644
--- a/src/vulkan/overlay-layer/overlay.cpp
+++ b/src/vulkan/overlay-layer/overlay.cpp
@@ -278,7 +278,7 @@ static VkLayerInstanceCreateInfo *get_instance_chain_info(const VkInstanceCreate
           ((VkLayerInstanceCreateInfo *) item)->function == func)
          return (VkLayerInstanceCreateInfo *) item;
    }
-   unreachable("instance chain info not found");
+   UNREACHABLE("instance chain info not found");
    return NULL;
 }
 
@@ -290,7 +290,7 @@ static VkLayerDeviceCreateInfo *get_device_chain_info(const VkDeviceCreateInfo *
           ((VkLayerDeviceCreateInfo *) item)->function == func)
          return (VkLayerDeviceCreateInfo *)item;
    }
-   unreachable("device chain info not found");
+   UNREACHABLE("device chain info not found");
    return NULL;
 }
 
diff --git a/src/vulkan/runtime/rmv/vk_rmv_exporter.c b/src/vulkan/runtime/rmv/vk_rmv_exporter.c
index 9277b0a90f9c6..32bca4a66970e 100644
--- a/src/vulkan/runtime/rmv/vk_rmv_exporter.c
+++ b/src/vulkan/runtime/rmv/vk_rmv_exporter.c
@@ -887,7 +887,7 @@ token_type_to_rmt(enum vk_rmv_token_type type)
    case VK_RMV_TOKEN_TYPE_RESOURCE_DESTROY:
       return RMT_TOKEN_TYPE_RESOURCE_DESTROY;
    default:
-      unreachable("invalid token type");
+      UNREACHABLE("invalid token type");
    }
 }
 
@@ -1003,7 +1003,7 @@ rmt_file_domain_to_heap_type(enum vk_rmv_kernel_memory_domain domain, bool has_c
    case VK_RMV_KERNEL_MEMORY_DOMAIN_VRAM:
       return has_cpu_access ? RMT_HEAP_TYPE_LOCAL : RMT_HEAP_TYPE_INVISIBLE;
    default:
-      unreachable("invalid domain");
+      UNREACHABLE("invalid domain");
    }
 }
 
@@ -1078,7 +1078,7 @@ rmt_size_to_page_size(uint32_t size)
    case 2097152:
       return RMT_PAGE_SIZE_2_MB;
    default:
-      unreachable("invalid page size");
+      UNREACHABLE("invalid page size");
    }
 }
 
@@ -1190,7 +1190,7 @@ rmt_dump_image_resource(struct vk_rmv_image_description *description, FILE *outp
       tiling = RMT_TILING_OPTIMAL;
       break;
    default:
-      unreachable("invalid image tiling");
+      UNREACHABLE("invalid image tiling");
    }
 
    uint32_t create_flags = 0;
@@ -1273,7 +1273,7 @@ rmt_dump_query_pool_resource(struct vk_rmv_query_pool_description *description,
       pool_type = RMT_QUERY_POOL_TYPE_STREAMOUT;
       break;
    default:
-      unreachable("invalid query pool type");
+      UNREACHABLE("invalid query pool type");
       break;
    }
 
@@ -1446,7 +1446,7 @@ rmt_dump_resource_create(struct vk_rmv_resource_create_token *token, FILE *outpu
       rmt_dump_misc_internal_resource(&token->misc_internal, output);
       break;
    default:
-      unreachable("invalid resource type");
+      UNREACHABLE("invalid resource type");
    }
 }
 
@@ -1686,7 +1686,7 @@ rmt_dump_data(struct vk_memory_trace_data *data, FILE *output)
          rmt_dump_cpu_map(&token->data.cpu_map, output);
          break;
       default:
-         unreachable("invalid token type");
+         UNREACHABLE("invalid token type");
       }
 
       current_timestamp = token->timestamp;
diff --git a/src/vulkan/runtime/rmv/vk_rmv_tokens.h b/src/vulkan/runtime/rmv/vk_rmv_tokens.h
index e16998b118496..ca40838929d3c 100644
--- a/src/vulkan/runtime/rmv/vk_rmv_tokens.h
+++ b/src/vulkan/runtime/rmv/vk_rmv_tokens.h
@@ -297,7 +297,7 @@ vk_rmv_token_size_from_type(enum vk_rmv_token_type type)
    case VK_RMV_TOKEN_TYPE_RESOURCE_DESTROY:
       return sizeof(struct vk_rmv_resource_destroy_token);
    default:
-      unreachable("invalid token type");
+      UNREACHABLE("invalid token type");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_acceleration_structure.c b/src/vulkan/runtime/vk_acceleration_structure.c
index b0e9e5cb97ced..b4b0960304fd7 100644
--- a/src/vulkan/runtime/vk_acceleration_structure.c
+++ b/src/vulkan/runtime/vk_acceleration_structure.c
@@ -164,7 +164,7 @@ vk_acceleration_structure_build_state_init(struct vk_acceleration_structure_buil
       ir_leaf_size = sizeof(struct vk_ir_instance_node);
       break;
    default:
-      unreachable("Unknown VkGeometryTypeKHR");
+      UNREACHABLE("Unknown VkGeometryTypeKHR");
    }
 
    uint32_t offset = 0;
@@ -426,7 +426,7 @@ vk_fill_geometry_data(VkAccelerationStructureTypeKHR type, uint32_t first_id, ui
          data.stride = sizeof(VkAccelerationStructureInstanceKHR);
       break;
    default:
-      unreachable("Unknown geometryType");
+      UNREACHABLE("Unknown geometryType");
    }
 
    return data;
@@ -1071,7 +1071,7 @@ vk_cmd_build_acceleration_structures(VkCommandBuffer commandBuffer,
          /* For updates, the leaf node pass never runs, so set leaf_node_count here. */
          bvh_states[i].vk.leaf_node_count = leaf_node_count;
       } else {
-         unreachable("Unknown internal_build_type");
+         UNREACHABLE("Unknown internal_build_type");
       }
 
       if (bvh_states[i].vk.config.internal_type != VK_INTERNAL_BUILD_TYPE_UPDATE) {
@@ -1307,7 +1307,7 @@ vk_common_CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffe
                                                     const uint32_t *pIndirectStrides,
                                                     const uint32_t *const *ppMaxPrimitiveCounts)
 {
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
 }
 
 VKAPI_ATTR VkResult VKAPI_CALL
@@ -1319,7 +1319,7 @@ vk_common_WriteAccelerationStructuresPropertiesKHR(VkDevice _device, uint32_t ac
                                                    size_t stride)
 {
    VK_FROM_HANDLE(vk_device, device, _device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vk_error(device, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -1331,7 +1331,7 @@ vk_common_BuildAccelerationStructuresKHR(VkDevice _device,
                                          const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
 {
    VK_FROM_HANDLE(vk_device, device, _device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vk_error(device, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -1341,7 +1341,7 @@ vk_common_CopyAccelerationStructureKHR(VkDevice _device,
                                        const VkCopyAccelerationStructureInfoKHR *pInfo)
 {
    VK_FROM_HANDLE(vk_device, device, _device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vk_error(device, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -1351,7 +1351,7 @@ vk_common_CopyMemoryToAccelerationStructureKHR(VkDevice _device,
                                                const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
 {
    VK_FROM_HANDLE(vk_device, device, _device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vk_error(device, VK_ERROR_FEATURE_NOT_PRESENT);
 }
 
@@ -1361,6 +1361,6 @@ vk_common_CopyAccelerationStructureToMemoryKHR(VkDevice _device,
                                                const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
 {
    VK_FROM_HANDLE(vk_device, device, _device);
-   unreachable("Unimplemented");
+   UNREACHABLE("Unimplemented");
    return vk_error(device, VK_ERROR_FEATURE_NOT_PRESENT);
 }
diff --git a/src/vulkan/runtime/vk_blend.c b/src/vulkan/runtime/vk_blend.c
index 8268f6ce89bc1..dd70142a8c7f1 100644
--- a/src/vulkan/runtime/vk_blend.c
+++ b/src/vulkan/runtime/vk_blend.c
@@ -44,7 +44,7 @@ vk_logic_op_to_pipe(VkLogicOp in)
    case VK_LOGIC_OP_SET:
       return PIPE_LOGICOP_SET;
    default:
-      unreachable("Invalid logicop");
+      UNREACHABLE("Invalid logicop");
    }
 }
 
@@ -63,7 +63,7 @@ vk_blend_op_to_pipe(VkBlendOp in)
    case VK_BLEND_OP_MAX:
       return PIPE_BLEND_MAX;
    default:
-      unreachable("Invalid blend op");
+      UNREACHABLE("Invalid blend op");
    }
 }
 
@@ -110,6 +110,6 @@ vk_blend_factor_to_pipe(VkBlendFactor vk_factor)
    case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
       return PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE;
    default:
-      unreachable("Invalid blend factor");
+      UNREACHABLE("Invalid blend factor");
    }
 }
diff --git a/src/vulkan/runtime/vk_cmd_enqueue.c b/src/vulkan/runtime/vk_cmd_enqueue.c
index f2ccab68844ab..9a57d01fe784c 100644
--- a/src/vulkan/runtime/vk_cmd_enqueue.c
+++ b/src/vulkan/runtime/vk_cmd_enqueue.c
@@ -35,7 +35,7 @@ vk_descriptor_type_update_size(VkDescriptorType type)
 {
    switch (type) {
    case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
-      unreachable("handled in caller");
+      UNREACHABLE("handled in caller");
 
    case VK_DESCRIPTOR_TYPE_SAMPLER:
    case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
diff --git a/src/vulkan/runtime/vk_command_buffer.c b/src/vulkan/runtime/vk_command_buffer.c
index 12735e20dd345..da532d224b4f2 100644
--- a/src/vulkan/runtime/vk_command_buffer.c
+++ b/src/vulkan/runtime/vk_command_buffer.c
@@ -221,7 +221,7 @@ vk_shader_stages_from_bind_point(VkPipelineBindPoint pipelineBindPoint)
              VK_SHADER_STAGE_INTERSECTION_BIT_KHR |
              VK_SHADER_STAGE_CALLABLE_BIT_KHR;
    default:
-      unreachable("unknown bind point!");
+      UNREACHABLE("unknown bind point!");
    }
    return 0;
 }
diff --git a/src/vulkan/runtime/vk_device.c b/src/vulkan/runtime/vk_device.c
index 8e99c47baa282..9c7e3b0b5bb12 100644
--- a/src/vulkan/runtime/vk_device.c
+++ b/src/vulkan/runtime/vk_device.c
@@ -215,7 +215,7 @@ vk_device_init(struct vk_device *device,
       break;
 
    default:
-      unreachable("Invalid timeline mode");
+      UNREACHABLE("Invalid timeline mode");
    }
 
 #if DETECT_OS_ANDROID
diff --git a/src/vulkan/runtime/vk_device_memory.c b/src/vulkan/runtime/vk_device_memory.c
index e0a742e198e01..32db3b24a6a28 100644
--- a/src/vulkan/runtime/vk_device_memory.c
+++ b/src/vulkan/runtime/vk_device_memory.c
@@ -79,7 +79,7 @@ vk_device_memory_create(struct vk_device *device,
          mem->ahardware_buffer = ahb_info->buffer;
          break;
 #else
-         unreachable("AHardwareBuffer import requires Android >= 26");
+         UNREACHABLE("AHardwareBuffer import requires Android >= 26");
 #endif /* DETECT_OS_ANDROID && ANDROID_API_LEVEL >= 26 */
       }
 
@@ -122,7 +122,7 @@ vk_device_memory_create(struct vk_device *device,
          }
          break;
 #else
-         unreachable("Win32 platform support disabled");
+         UNREACHABLE("Win32 platform support disabled");
 #endif
       }
 
diff --git a/src/vulkan/runtime/vk_fence.c b/src/vulkan/runtime/vk_fence.c
index 77cb5a3a47f53..8e43ea09e10e0 100644
--- a/src/vulkan/runtime/vk_fence.c
+++ b/src/vulkan/runtime/vk_fence.c
@@ -473,7 +473,7 @@ vk_common_GetFenceFdKHR(VkDevice _device,
       break;
 
    default:
-      unreachable("Invalid fence export handle type");
+      UNREACHABLE("Invalid fence export handle type");
    }
 
    /* From the Vulkan 1.2.194 spec:
diff --git a/src/vulkan/runtime/vk_format_info_gen.py b/src/vulkan/runtime/vk_format_info_gen.py
index 29cb4ebe65f8c..30c132a9505c5 100644
--- a/src/vulkan/runtime/vk_format_info_gen.py
+++ b/src/vulkan/runtime/vk_format_info_gen.py
@@ -104,7 +104,7 @@ vk_format_get_info(VkFormat format)
       return &ext${id}_format_infos[offset];
 % endfor
    default:
-      unreachable("Invalid extension");
+      UNREACHABLE("Invalid extension");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_graphics_state.c b/src/vulkan/runtime/vk_graphics_state.c
index cee7d74f09d4d..ae2c3ec51b491 100644
--- a/src/vulkan/runtime/vk_graphics_state.c
+++ b/src/vulkan/runtime/vk_graphics_state.c
@@ -296,7 +296,7 @@ vk_get_dynamic_graphics_states(BITSET_WORD *dynamic,
       CASE( ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT, ATTACHMENT_FEEDBACK_LOOP_ENABLE)
       CASE( DEPTH_CLAMP_RANGE_EXT,        VP_DEPTH_CLAMP_RANGE)
       default:
-         unreachable("Unsupported dynamic graphics state");
+         UNREACHABLE("Unsupported dynamic graphics state");
       }
    }
 
@@ -3077,7 +3077,7 @@ vk_common_CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer,
                                       uint32_t attachmentCount,
                                       const VkColorBlendAdvancedEXT* pColorBlendAdvanced)
 {
-   unreachable("VK_EXT_blend_operation_advanced unsupported");
+   UNREACHABLE("VK_EXT_blend_operation_advanced unsupported");
 }
 
 void
@@ -3374,7 +3374,7 @@ vk_dynamic_graphic_state_to_str(enum mesa_vk_dynamic_graphics_state state)
       NAME(CB_BLEND_CONSTANTS);
       NAME(ATTACHMENT_FEEDBACK_LOOP_ENABLE);
       NAME(COLOR_ATTACHMENT_MAP);
-   default: unreachable("Invalid state");
+   default: UNREACHABLE("Invalid state");
    }
 
 #undef NAME
diff --git a/src/vulkan/runtime/vk_graphics_state.h b/src/vulkan/runtime/vk_graphics_state.h
index 820dfac12cead..759667b64d700 100644
--- a/src/vulkan/runtime/vk_graphics_state.h
+++ b/src/vulkan/runtime/vk_graphics_state.h
@@ -414,7 +414,7 @@ vk_rasterization_state_depth_clip_enable(const struct vk_rasterization_state *rs
    case VK_MESA_DEPTH_CLIP_ENABLE_TRUE:      return true;
    case VK_MESA_DEPTH_CLIP_ENABLE_NOT_CLAMP: return !rs->depth_clamp_enable;
    }
-   unreachable("Invalid depth clip enable");
+   UNREACHABLE("Invalid depth clip enable");
 }
 
 /***/
diff --git a/src/vulkan/runtime/vk_image.c b/src/vulkan/runtime/vk_image.c
index edc84d6ede9b3..90c5b948c634e 100644
--- a/src/vulkan/runtime/vk_image.c
+++ b/src/vulkan/runtime/vk_image.c
@@ -455,7 +455,7 @@ vk_image_view_init(struct vk_device *device,
          assert(image->create_flags & VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT);
          break;
       default:
-         unreachable("Invalid image view type");
+         UNREACHABLE("Invalid image view type");
       }
    }
 
@@ -619,7 +619,7 @@ vk_image_view_init(struct vk_device *device,
           <= image->mip_levels);
    switch (image->image_type) {
    default:
-      unreachable("bad VkImageType");
+      UNREACHABLE("bad VkImageType");
    case VK_IMAGE_TYPE_1D:
    case VK_IMAGE_TYPE_2D:
       assert(image_view->base_array_layer + image_view->layer_count
@@ -739,10 +739,10 @@ vk_image_layout_is_read_only(VkImageLayout layout,
    case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR:
    case VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR:
    case VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM:
-      unreachable("Invalid image layout.");
+      UNREACHABLE("Invalid image layout.");
    }
 
-   unreachable("Invalid image layout.");
+   UNREACHABLE("Invalid image layout.");
 }
 
 bool
@@ -1133,8 +1133,8 @@ vk_image_layout_to_usage_flags(VkImageLayout layout,
       return VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM;
 
    case VK_IMAGE_LAYOUT_MAX_ENUM:
-      unreachable("Invalid image layout.");
+      UNREACHABLE("Invalid image layout.");
    }
 
-   unreachable("Invalid image layout.");
+   UNREACHABLE("Invalid image layout.");
 }
diff --git a/src/vulkan/runtime/vk_image.h b/src/vulkan/runtime/vk_image.h
index 9c7dbdd8a7ac9..f9869f19532fb 100644
--- a/src/vulkan/runtime/vk_image.h
+++ b/src/vulkan/runtime/vk_image.h
@@ -170,7 +170,7 @@ vk_image_sanitize_extent(const struct vk_image *image,
    case VK_IMAGE_TYPE_3D:
       return imageExtent;
    default:
-      unreachable("invalid image type");
+      UNREACHABLE("invalid image type");
    }
 }
 
@@ -189,7 +189,7 @@ vk_image_sanitize_offset(const struct vk_image *image,
    case VK_IMAGE_TYPE_3D:
       return imageOffset;
    default:
-      unreachable("invalid image type");
+      UNREACHABLE("invalid image type");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_log.c b/src/vulkan/runtime/vk_log.c
index 915a18db4c759..9ed8cff342280 100644
--- a/src/vulkan/runtime/vk_log.c
+++ b/src/vulkan/runtime/vk_log.c
@@ -46,7 +46,7 @@ vk_object_to_physical_device(struct vk_object_base *obj)
 {
    switch (obj->type) {
    case VK_OBJECT_TYPE_INSTANCE:
-      unreachable("Unsupported object type");
+      UNREACHABLE("Unsupported object type");
    case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
       return container_of(obj, struct vk_physical_device, base);
    case VK_OBJECT_TYPE_SURFACE_KHR:
@@ -54,7 +54,7 @@ vk_object_to_physical_device(struct vk_object_base *obj)
    case VK_OBJECT_TYPE_DISPLAY_MODE_KHR:
    case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
    case VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT:
-      unreachable("Unsupported object type");
+      UNREACHABLE("Unsupported object type");
    default:
       return vk_object_to_device(obj)->physical;
    }
@@ -145,7 +145,7 @@ __vk_log_impl(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
       mesa_loge("%s: %s", message_idname, message);
       break;
    default:
-      unreachable("Invalid debug message severity");
+      UNREACHABLE("Invalid debug message severity");
       break;
    }
 
@@ -250,7 +250,7 @@ __vk_log_impl(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
          flags |= VK_DEBUG_REPORT_ERROR_BIT_EXT;
          break;
       default:
-         unreachable("Invalid debug message severity");
+         UNREACHABLE("Invalid debug message severity");
          break;
       }
 
diff --git a/src/vulkan/runtime/vk_meta_blit_resolve.c b/src/vulkan/runtime/vk_meta_blit_resolve.c
index 155e4d8834d55..3757ef23d9909 100644
--- a/src/vulkan/runtime/vk_meta_blit_resolve.c
+++ b/src/vulkan/runtime/vk_meta_blit_resolve.c
@@ -52,7 +52,7 @@ vk_image_sampler_dim(const struct vk_image *image)
       else
          return GLSL_SAMPLER_DIM_2D;
    case VK_IMAGE_TYPE_3D: return GLSL_SAMPLER_DIM_3D;
-   default: unreachable("Invalid image type");
+   default: UNREACHABLE("Invalid image type");
    }
 }
 
@@ -70,7 +70,7 @@ aspect_to_tex_binding(VkImageAspectFlagBits aspect)
    case VK_IMAGE_ASPECT_COLOR_BIT: return BLIT_DESC_BINDING_COLOR;
    case VK_IMAGE_ASPECT_DEPTH_BIT: return BLIT_DESC_BINDING_DEPTH;
    case VK_IMAGE_ASPECT_STENCIL_BIT: return BLIT_DESC_BINDING_STENCIL;
-   default: unreachable("Unsupported aspect");
+   default: UNREACHABLE("Unsupported aspect");
    }
 }
 
@@ -156,7 +156,7 @@ build_tex_resolve(nir_builder *b, nir_deref_instr *t,
             accum = nir_fmin(b, accum, val);
             break;
          default:
-            unreachable("Invalid sample result type");
+            UNREACHABLE("Invalid sample result type");
          }
          break;
 
@@ -172,12 +172,12 @@ build_tex_resolve(nir_builder *b, nir_deref_instr *t,
             accum = nir_fmax(b, accum, val);
             break;
          default:
-            unreachable("Invalid sample result type");
+            UNREACHABLE("Invalid sample result type");
          }
          break;
 
       default:
-         unreachable("Unsupported resolve mode");
+         UNREACHABLE("Unsupported resolve mode");
       }
    }
 
@@ -289,7 +289,7 @@ build_blit_shader(const struct vk_meta_blit_key *key)
          out_comps = 1;
          break;
       default:
-         unreachable("Unsupported aspect");
+         UNREACHABLE("Unsupported aspect");
       }
 
       const bool is_array = key->dim != GLSL_SAMPLER_DIM_3D;
diff --git a/src/vulkan/runtime/vk_meta_copy_fill_update.c b/src/vulkan/runtime/vk_meta_copy_fill_update.c
index d299d0282b943..cb836121d0188 100644
--- a/src/vulkan/runtime/vk_meta_copy_fill_update.c
+++ b/src/vulkan/runtime/vk_meta_copy_fill_update.c
@@ -1337,7 +1337,7 @@ img_copy_view_info(VkImageViewType view_type, VkImageAspectFlags aspects,
          view.plane.format = img_props->plane[2].view_format;
          break;
       default:
-         unreachable("invalid ycbcr aspect");
+         UNREACHABLE("invalid ycbcr aspect");
       }
 
       assert(format_is_supported(view.color.format));
diff --git a/src/vulkan/runtime/vk_meta_object_list.c b/src/vulkan/runtime/vk_meta_object_list.c
index 37c383d44219b..d47063f3de22f 100644
--- a/src/vulkan/runtime/vk_meta_object_list.c
+++ b/src/vulkan/runtime/vk_meta_object_list.c
@@ -39,7 +39,7 @@ vk_meta_destroy_object(struct vk_device *device, struct vk_object_base *obj)
       disp->DestroyShaderEXT(_device, (VkShaderEXT)(uintptr_t)obj, NULL);
       break;
    default:
-      unreachable("Unsupported object type");
+      UNREACHABLE("Unsupported object type");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_meta_private.h b/src/vulkan/runtime/vk_meta_private.h
index f13561226ab27..fd14b370b7112 100644
--- a/src/vulkan/runtime/vk_meta_private.h
+++ b/src/vulkan/runtime/vk_meta_private.h
@@ -65,7 +65,7 @@ vk_image_sampled_view_type(const struct vk_image *image)
    case VK_IMAGE_TYPE_1D: return VK_IMAGE_VIEW_TYPE_1D_ARRAY;
    case VK_IMAGE_TYPE_2D: return VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    case VK_IMAGE_TYPE_3D: return VK_IMAGE_VIEW_TYPE_3D;
-   default: unreachable("Invalid image type");
+   default: UNREACHABLE("Invalid image type");
    }
 }
 
@@ -81,7 +81,7 @@ vk_image_render_view_type(const struct vk_image *image, uint32_t layer_count)
       return layer_count == 1 ? VK_IMAGE_VIEW_TYPE_2D :
                                 VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -98,7 +98,7 @@ vk_image_storage_view_type(const struct vk_image *image)
    case VK_IMAGE_TYPE_3D:
       return VK_IMAGE_VIEW_TYPE_3D;
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_nir_convert_ycbcr.c b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
index 7c762fe6284e3..cf07dfaff8c43 100644
--- a/src/vulkan/runtime/vk_nir_convert_ycbcr.c
+++ b/src/vulkan/runtime/vk_nir_convert_ycbcr.c
@@ -47,7 +47,7 @@ y_range(nir_builder *b,
                           1.0f / (219.0f * pow(2, bpc - 8)));
 
    default:
-      unreachable("missing Ycbcr range");
+      UNREACHABLE("missing Ycbcr range");
       return NULL;
    }
 }
@@ -70,7 +70,7 @@ chroma_range(nir_builder *b,
                                        -128.0f * pow(2, bpc - 8)),
                           1.0f / (224.0f * pow(2, bpc - 8)));
    default:
-      unreachable("missing Ycbcr range");
+      UNREACHABLE("missing Ycbcr range");
       return NULL;
    }
 }
@@ -111,7 +111,7 @@ ycbcr_model_to_rgb_matrix(VkSamplerYcbcrModelConversion model)
       return &bt2020;
    }
    default:
-      unreachable("missing Ycbcr model");
+      UNREACHABLE("missing Ycbcr model");
       return NULL;
    }
 }
@@ -271,7 +271,7 @@ swizzle_to_component(VkComponentSwizzle swizzle)
    case VK_COMPONENT_SWIZZLE_A:
       return 3;
    default:
-      unreachable("invalid channel");
+      UNREACHABLE("invalid channel");
       return 0;
    }
 }
diff --git a/src/vulkan/runtime/vk_queue.c b/src/vulkan/runtime/vk_queue.c
index 89a046a40083b..26c0d9de31ac1 100644
--- a/src/vulkan/runtime/vk_queue.c
+++ b/src/vulkan/runtime/vk_queue.c
@@ -1208,9 +1208,9 @@ vk_queue_submit(struct vk_queue *queue,
       return VK_SUCCESS;
 
    case VK_QUEUE_SUBMIT_MODE_THREADED_ON_DEMAND:
-      unreachable("Invalid vk_queue::submit.mode");
+      UNREACHABLE("Invalid vk_queue::submit.mode");
    }
-   unreachable("Invalid submit mode");
+   UNREACHABLE("Invalid submit mode");
 
 fail:
    vk_queue_submit_destroy(queue, submit);
@@ -1339,9 +1339,9 @@ vk_queue_signal_sync(struct vk_queue *queue,
       return VK_SUCCESS;
 
    case VK_QUEUE_SUBMIT_MODE_THREADED_ON_DEMAND:
-      unreachable("Invalid vk_queue::submit.mode");
+      UNREACHABLE("Invalid vk_queue::submit.mode");
    }
-   unreachable("Invalid timeline mode");
+   UNREACHABLE("Invalid timeline mode");
 }
 
 void
@@ -1559,7 +1559,7 @@ get_cpu_wait_type(struct vk_physical_device *pdevice)
          return *t;
    }
 
-   unreachable("You must have a non-timeline CPU wait sync type");
+   UNREACHABLE("You must have a non-timeline CPU wait sync type");
 }
 
 VKAPI_ATTR VkResult VKAPI_CALL
diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index bccb8822a803e..0cc3a1884a806 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -405,7 +405,7 @@ vk_subpass_attachment_init(struct vk_subpass_attachment *att,
       break;
 
    default:
-      unreachable("Invalid subpass attachment usage");
+      UNREACHABLE("Invalid subpass attachment usage");
    }
 }
 
@@ -1535,7 +1535,7 @@ vk_command_buffer_get_attachment_layout(const struct vk_command_buffer *cmd_buff
          return a;
       }
    }
-   unreachable("Image not found in attachments");
+   UNREACHABLE("Image not found in attachments");
 }
 
 void
diff --git a/src/vulkan/runtime/vk_sampler.c b/src/vulkan/runtime/vk_sampler.c
index 7ef0fd97245fa..d90130649eac2 100644
--- a/src/vulkan/runtime/vk_sampler.c
+++ b/src/vulkan/runtime/vk_sampler.c
@@ -45,7 +45,7 @@ vk_border_color_value(VkBorderColor color)
    case VK_BORDER_COLOR_INT_OPAQUE_WHITE:
       return (VkClearColorValue) { .int32 = { 1, 1, 1, 1 } };
    default:
-      unreachable("Invalid or custom border color enum");
+      UNREACHABLE("Invalid or custom border color enum");
    }
 }
 
@@ -64,7 +64,7 @@ vk_border_color_is_int(VkBorderColor color)
    case VK_BORDER_COLOR_INT_CUSTOM_EXT:
       return true;
    default:
-      unreachable("Invalid border color enum");
+      UNREACHABLE("Invalid border color enum");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_semaphore.c b/src/vulkan/runtime/vk_semaphore.c
index 7044ed9aea27d..534eaa76457cc 100644
--- a/src/vulkan/runtime/vk_semaphore.c
+++ b/src/vulkan/runtime/vk_semaphore.c
@@ -517,7 +517,7 @@ vk_common_GetSemaphoreWin32HandleKHR(VkDevice _device,
       break;
 
    default:
-      unreachable("Invalid semaphore export handle type");
+      UNREACHABLE("Invalid semaphore export handle type");
    }
 
    /* From the Vulkan 1.2.194 spec:
@@ -705,7 +705,7 @@ vk_common_GetSemaphoreFdKHR(VkDevice _device,
       break;
 
    default:
-      unreachable("Invalid semaphore export handle type");
+      UNREACHABLE("Invalid semaphore export handle type");
    }
 
    /* From the Vulkan 1.2.194 spec:
diff --git a/src/vulkan/runtime/vk_shader.c b/src/vulkan/runtime/vk_shader.c
index 0594be4d41a45..af0860483e417 100644
--- a/src/vulkan/runtime/vk_shader.c
+++ b/src/vulkan/runtime/vk_shader.c
@@ -518,7 +518,7 @@ vk_common_CreateShadersEXT(VkDevice _device,
       }
 
       default:
-         unreachable("Unknown shader code type");
+         UNREACHABLE("Unknown shader code type");
       }
 
       if (first_fail_or_success == VK_SUCCESS)
diff --git a/src/vulkan/runtime/vk_standard_sample_locations.c b/src/vulkan/runtime/vk_standard_sample_locations.c
index de3fa4993012e..72111485e8b83 100644
--- a/src/vulkan/runtime/vk_standard_sample_locations.c
+++ b/src/vulkan/runtime/vk_standard_sample_locations.c
@@ -151,6 +151,6 @@ vk_standard_sample_locations_state(VkSampleCountFlagBits sample_count)
    case 4:  return &sample_locations_state_4x;
    case 8:  return &sample_locations_state_8x;
    case 16: return &sample_locations_state_16x;
-   default: unreachable("Sample count has no standard locations");
+   default: UNREACHABLE("Sample count has no standard locations");
    }
 }
diff --git a/src/vulkan/runtime/vk_synchronization.c b/src/vulkan/runtime/vk_synchronization.c
index d02fb19bbe87c..4aaa805cfa693 100644
--- a/src/vulkan/runtime/vk_synchronization.c
+++ b/src/vulkan/runtime/vk_synchronization.c
@@ -358,7 +358,7 @@ vk_common_GetQueueCheckpointDataNV(
     uint32_t*                                   pCheckpointDataCount,
     VkCheckpointDataNV*                         pCheckpointData)
 {
-   unreachable("Entrypoint not implemented");
+   UNREACHABLE("Entrypoint not implemented");
 }
 
 VKAPI_ATTR VkResult VKAPI_CALL
diff --git a/src/vulkan/runtime/vk_texcompress_astc.c b/src/vulkan/runtime/vk_texcompress_astc.c
index 2996af4d40410..69d409137b769 100644
--- a/src/vulkan/runtime/vk_texcompress_astc.c
+++ b/src/vulkan/runtime/vk_texcompress_astc.c
@@ -172,7 +172,7 @@ get_partition_table_index(VkFormat format)
    case VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
       return 13;
    default:
-      unreachable("bad astc format\n");
+      UNREACHABLE("bad astc format\n");
       return 0;
    }
 }
diff --git a/src/vulkan/runtime/vk_texcompress_etc2.h b/src/vulkan/runtime/vk_texcompress_etc2.h
index f8e6269ebec73..0742df8db609c 100644
--- a/src/vulkan/runtime/vk_texcompress_etc2.h
+++ b/src/vulkan/runtime/vk_texcompress_etc2.h
@@ -76,7 +76,7 @@ vk_texcompress_etc2_image_view_type(VkImageType image_type)
    case VK_IMAGE_TYPE_3D:
       return VK_IMAGE_VIEW_TYPE_3D;
    default:
-      unreachable("bad image type");
+      UNREACHABLE("bad image type");
    }
 }
 
diff --git a/src/vulkan/runtime/vk_video.c b/src/vulkan/runtime/vk_video.c
index 679d1dbdc1348..813959dc3e1d1 100644
--- a/src/vulkan/runtime/vk_video.c
+++ b/src/vulkan/runtime/vk_video.c
@@ -581,7 +581,7 @@ vk_video_session_parameters_init(struct vk_device *device,
       break;
    }
    default:
-      unreachable("Unsupported video codec operation");
+      UNREACHABLE("Unsupported video codec operation");
       break;
    }
    return VK_SUCCESS;
@@ -802,7 +802,7 @@ vk_video_session_parameters_update(struct vk_video_session_parameters *params,
       return update_h265_enc_session_parameters(params, h265_add);
    }
    default:
-      unreachable("Unknown codec\n");
+      UNREACHABLE("Unknown codec\n");
    }
    return result;
 }
diff --git a/src/vulkan/screenshot-layer/screenshot.cpp b/src/vulkan/screenshot-layer/screenshot.cpp
index 71c2bb1bd0f02..c6f9becb0f768 100644
--- a/src/vulkan/screenshot-layer/screenshot.cpp
+++ b/src/vulkan/screenshot-layer/screenshot.cpp
@@ -231,7 +231,7 @@ static VkLayerInstanceCreateInfo *get_instance_chain_info(const VkInstanceCreate
           ((VkLayerInstanceCreateInfo *) item)->function == func)
          return (VkLayerInstanceCreateInfo *) item;
    }
-   unreachable("instance chain info not found");
+   UNREACHABLE("instance chain info not found");
    return NULL;
 }
 
@@ -243,7 +243,7 @@ static VkLayerDeviceCreateInfo *get_device_chain_info(const VkDeviceCreateInfo *
           ((VkLayerDeviceCreateInfo *) item)->function == func)
          return (VkLayerDeviceCreateInfo *)item;
    }
-   unreachable("device chain info not found");
+   UNREACHABLE("device chain info not found");
    return NULL;
 }
 
diff --git a/src/vulkan/util/gen_enum_to_str.py b/src/vulkan/util/gen_enum_to_str.py
index 07893e2925eaa..21cb1790c2def 100644
--- a/src/vulkan/util/gen_enum_to_str.py
+++ b/src/vulkan/util/gen_enum_to_str.py
@@ -127,7 +127,7 @@ C_TEMPLATE = Template(textwrap.dedent(u"""\
         case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: return sizeof(VkLayerInstanceCreateInfo);
         case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: return sizeof(VkLayerDeviceCreateInfo);
         default:
-            unreachable("Undefined struct type.");
+            UNREACHABLE("Undefined struct type.");
         }
     }
 
diff --git a/src/vulkan/util/vk_cmd_queue_gen.py b/src/vulkan/util/vk_cmd_queue_gen.py
index e80790b669be6..718f536acda7f 100644
--- a/src/vulkan/util/vk_cmd_queue_gen.py
+++ b/src/vulkan/util/vk_cmd_queue_gen.py
@@ -374,7 +374,7 @@ vk_cmd_queue_execute(struct vk_cmd_queue *queue,
 #endif // ${c.guard}
 % endif
 % endfor
-      default: unreachable("Unsupported command");
+      default: UNREACHABLE("Unsupported command");
       }
    }
 }
diff --git a/src/vulkan/util/vk_dispatch_table_gen.py b/src/vulkan/util/vk_dispatch_table_gen.py
index 7a3b459b37155..c2776d2608353 100644
--- a/src/vulkan/util/vk_dispatch_table_gen.py
+++ b/src/vulkan/util/vk_dispatch_table_gen.py
@@ -570,7 +570,7 @@ vk_device_entrypoint_is_enabled(int index, uint32_t core_version,
 #ifdef _MSC_VER
 VKAPI_ATTR void VKAPI_CALL vk_entrypoint_stub(void)
 {
-   unreachable("Entrypoint not implemented");
+   UNREACHABLE("Entrypoint not implemented");
 }
 
 static const void *get_function_target(const void *func)
diff --git a/src/vulkan/util/vk_format.c b/src/vulkan/util/vk_format.c
index 943d2e8ee3cdc..9c9171198f7ea 100644
--- a/src/vulkan/util/vk_format.c
+++ b/src/vulkan/util/vk_format.c
@@ -661,7 +661,7 @@ vk_format_get_aspect_format(VkFormat format, const VkImageAspectFlags aspect)
    case VK_IMAGE_ASPECT_PLANE_2_BIT:
       return vk_format_get_plane_format(format, 2);
    default:
-      unreachable("Cannot translate format aspect");
+      UNREACHABLE("Cannot translate format aspect");
    }
 }
 
@@ -694,7 +694,7 @@ vk_component_mapping_to_pipe_swizzle(VkComponentMapping mapping,
          out_swizzle[i] = PIPE_SWIZZLE_1;
          break;
       default:
-         unreachable("unknown swizzle");
+         UNREACHABLE("unknown swizzle");
       }
    }
 }
@@ -894,7 +894,7 @@ swizzled_color_component(const VkClearColorValue *color,
    case VK_COMPONENT_SWIZZLE_G:        return color->uint32[1];
    case VK_COMPONENT_SWIZZLE_B:        return color->uint32[2];
    case VK_COMPONENT_SWIZZLE_A:        return color->uint32[3];
-   default: unreachable("Invalid component swizzle");
+   default: UNREACHABLE("Invalid component swizzle");
    }
 }
 
diff --git a/src/vulkan/util/vk_util.h b/src/vulkan/util/vk_util.h
index c9caae1b162c5..b3cab1e5c70d1 100644
--- a/src/vulkan/util/vk_util.h
+++ b/src/vulkan/util/vk_util.h
@@ -373,7 +373,7 @@ vk_index_type_to_bytes(VkIndexType type)
    case VK_INDEX_TYPE_UINT8_KHR: return 1;
    case VK_INDEX_TYPE_UINT16:    return 2;
    case VK_INDEX_TYPE_UINT32:    return 4;
-   default:                      unreachable("Invalid index type");
+   default:                      UNREACHABLE("Invalid index type");
    }
 }
 
@@ -384,7 +384,7 @@ vk_index_to_restart(VkIndexType type)
    case VK_INDEX_TYPE_UINT8_KHR: return 0xff;
    case VK_INDEX_TYPE_UINT16:    return 0xffff;
    case VK_INDEX_TYPE_UINT32:    return 0xffffffff;
-   default:                      unreachable("unexpected index type");
+   default:                      UNREACHABLE("unexpected index type");
    }
 }
 
diff --git a/src/vulkan/vram-report-limit-layer/vram_report_limit_layer.c b/src/vulkan/vram-report-limit-layer/vram_report_limit_layer.c
index 20df59e7f5a3c..313997367ac8f 100644
--- a/src/vulkan/vram-report-limit-layer/vram_report_limit_layer.c
+++ b/src/vulkan/vram-report-limit-layer/vram_report_limit_layer.c
@@ -312,7 +312,7 @@ get_instance_chain_info(const VkInstanceCreateInfo *pCreateInfo)
           ((VkLayerInstanceCreateInfo *)item)->function == VK_LAYER_LINK_INFO)
          return (VkLayerInstanceCreateInfo *)item;
    }
-   unreachable("instance chain info not found");
+   UNREACHABLE("instance chain info not found");
    return NULL;
 }
 
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index f78e4baa22a86..934e7e4cc2c6a 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -392,7 +392,7 @@ get_blit_type(const struct wsi_device *wsi,
    }
 #endif
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -424,7 +424,7 @@ configure_image(const struct wsi_swapchain *chain,
    }
 #endif
    default:
-      unreachable("Invalid image type");
+      UNREACHABLE("Invalid image type");
    }
 }
 
@@ -1760,7 +1760,7 @@ wsi_select_memory_type(const struct wsi_device *wsi,
       return wsi_select_memory_type(wsi, req_props, deny_props, type_bits);
    }
 
-   unreachable("No memory type found");
+   UNREACHABLE("No memory type found");
 }
 
 uint32_t
@@ -2149,7 +2149,7 @@ wsi_finish_create_blit_context(const struct wsi_swapchain *chain,
          wsi_cmd_blit_image_to_image(cmd_buffer, wsi, info, image);
          break;
       default:
-         unreachable("Invalid wsi_swapchain_blit_type");
+         UNREACHABLE("Invalid wsi_swapchain_blit_type");
       }
 
       result = wsi->EndCommandBuffer(cmd_buffer);
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 4952e81079623..db64b930d02f8 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -179,7 +179,7 @@ find_properties(struct wsi_display_connector *connector, int fd, uint32_t type)
       prop_count = ARRAY_SIZE(connector->plane_property);
       break;
    default:
-      unreachable("unexpected drm object type");
+      UNREACHABLE("unexpected drm object type");
    }
 
    props = drmModeObjectGetProperties(fd, obj_id, type);
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index dd15d03846b0a..74f436e6b9fd9 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -3278,7 +3278,7 @@ wsi_wl_image_init(struct wsi_wl_swapchain *chain,
    }
 
    default:
-      unreachable("Invalid buffer type");
+      UNREACHABLE("Invalid buffer type");
    }
 
    if (!image->wayland_buffer.buffer)
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 7e3db6d631709..5c4dcb0b96e7d 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1734,7 +1734,7 @@ x11_present_to_x11(struct x11_swapchain *chain, uint32_t image_index,
 #ifdef HAVE_X11_DRM
       result = x11_present_to_x11_dri3(chain, image_index, target_msc, present_mode);
 #else
-      unreachable("X11 missing DRI3 support!");
+      UNREACHABLE("X11 missing DRI3 support!");
 #endif
 
    if (result < 0)
@@ -2252,7 +2252,7 @@ fail_image:
    wsi_destroy_image(&chain->base, &image->base);
 
 #else
-   unreachable("SHM support not compiled in");
+   UNREACHABLE("SHM support not compiled in");
 #endif
    return VK_ERROR_INITIALIZATION_FAILED;
 }
@@ -2709,7 +2709,7 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
       }
       image_params = &drm_image_params.base;
 #else
-      unreachable("X11 DRM support missing!");
+      UNREACHABLE("X11 DRM support missing!");
 #endif
    }
 
-- 
GitLab

