From 762716bcdd2ac44af6ef0ae302354bd856e2637c Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 00:49:23 +0200
Subject: [PATCH 1/5] util: Add timespec_sub_saturated to avoid negative time
 for deadlines

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/util/timespec.h | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/util/timespec.h b/src/util/timespec.h
index 378ebbba9e54..2022ab56dce5 100644
--- a/src/util/timespec.h
+++ b/src/util/timespec.h
@@ -79,6 +79,24 @@ timespec_sub(struct timespec *r,
    }
 }
 
+/**
+ * Saturated subtract timespecs
+ *
+ * \param r[out] result: max(a - b, 0)
+ * \param a[in] operand
+ * \param b[in] operand
+ */
+static inline void
+timespec_sub_saturated(struct timespec *r,
+                       const struct timespec *a, const struct timespec *b)
+{
+   timespec_sub(r, a, b);
+   if (r->tv_sec < 0) {
+      r->tv_sec = 0;
+      r->tv_nsec = 0;
+   }
+}
+
 #define TIME_T_MAX \
    ((time_t)(((time_t)-1) > 0 ? u_uintN_max(sizeof(time_t) * 8) : \
                                 u_intN_max(sizeof(time_t) * 8)))
-- 
GitLab


From 7759c6f3cf675a858a8187dfee046807e46e3e0d Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 00:59:52 +0200
Subject: [PATCH 2/5] vulkan/wsi/wayland: Add fallback
 wl_display_dispatch_queue_timeout

This is almost a 1:1 copy of the same function in libwayland. If the version
with the symbol propagates far enough the fallback can be removed again.

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 meson.build                         |  6 +++
 src/vulkan/wsi/wsi_common_wayland.c | 83 +++++++++++++++++++++++++++++
 2 files changed, 89 insertions(+)

diff --git a/meson.build b/meson.build
index 492142f05705..1c13a9b14db2 100644
--- a/meson.build
+++ b/meson.build
@@ -2054,6 +2054,12 @@ if with_platform_wayland
     'linux-dmabuf', 'linux-dmabuf-unstable-v1.xml'
   )
   pre_args += '-DWL_HIDE_DEPRECATED'
+  if cc.has_function(
+      'wl_display_dispatch_queue_timeout',
+      prefix : '#include <wayland-client.h>',
+      dependencies: dep_wayland_client)
+    pre_args += ['-DHAVE_WL_DISPATCH_QUEUE_TIMEOUT']
+  endif
 endif
 
 dep_x11 = null_dep
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 7faeb43083c5..768b10d80abe 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -954,6 +954,89 @@ wsi_wl_swapchain_get_wsi_image(struct wsi_swapchain *wsi_chain,
    return &chain->images[image_index].base;
 }
 
+#ifndef HAVE_WL_DISPATCH_QUEUE_TIMEOUT
+static int
+wl_display_poll(struct wl_display *display,
+                short int events,
+                struct timespec *timeout)
+{
+   int ret;
+   struct pollfd pfd[1];
+
+   pfd[0].fd = wl_display_get_fd(display);
+   pfd[0].events = events;
+   do {
+      ret = ppoll(pfd, 1, timeout, NULL);
+   } while (ret == -1 && errno == EINTR);
+
+   if (ret == 0)
+      return -2;
+
+   return ret;
+}
+
+static int
+wl_display_dispatch_queue_timeout(struct wl_display *display,
+                                  struct wl_event_queue *queue,
+                                  struct timespec *timeout)
+{
+   int ret;
+   struct timespec now;
+   struct timespec target_time = {0};
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&target_time, &now, timeout);
+   }
+
+   if (wl_display_prepare_read_queue(display, queue) == -1)
+      return wl_display_dispatch_queue_pending(display, queue);
+
+   while (true) {
+      ret = wl_display_flush(display);
+
+      if (ret != -1 || errno != EAGAIN)
+         break;
+
+      ret = wl_display_poll(display, POLLOUT, timeout);
+
+      if (timeout) {
+         clock_gettime(CLOCK_MONOTONIC, &now);
+         timespec_sub_saturated(timeout, &target_time, &now);
+      }
+
+      if (ret < 0) {
+         wl_display_cancel_read(display);
+         return ret;
+      }
+   }
+
+   /* Don't stop if flushing hits an EPIPE; continue so we can read any
+    * protocol error that may have triggered it. */
+   if (ret < 0 && errno != EPIPE) {
+      wl_display_cancel_read(display);
+      return -1;
+   }
+
+   ret = wl_display_poll(display, POLLIN, timeout);
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_sub_saturated(timeout, &target_time, &now);
+   }
+
+   if (ret < 0) {
+      wl_display_cancel_read(display);
+      return ret;
+   }
+
+   if (wl_display_read_events(display) == -1)
+      return -1;
+
+   return wl_display_dispatch_queue_pending(display, queue);
+}
+#endif
+
 static VkResult
 wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
                                     const VkAcquireNextImageInfoKHR *info,
-- 
GitLab


From 063c0008463aeb959f6b3466003a3219579bc563 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 01:04:21 +0200
Subject: [PATCH 3/5] vulkan/wsi/wayland: Use dispatch_queue_timeout in
 acquire_next_image

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/vulkan/wsi/wsi_common_wayland.c | 64 ++++++-----------------------
 1 file changed, 13 insertions(+), 51 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 768b10d80abe..4781c0146b05 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -1043,22 +1043,15 @@ wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
                                     uint32_t *image_index)
 {
    struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
-   struct timespec start_time, end_time;
-   struct timespec rel_timeout;
-   int wl_fd = wl_display_get_fd(chain->display->wl_display);
+   struct timespec ts;
+   struct timespec *timeout = NULL;
 
-   timespec_from_nsec(&rel_timeout, info->timeout);
-
-   clock_gettime(CLOCK_MONOTONIC, &start_time);
-   timespec_add(&end_time, &rel_timeout, &start_time);
+   if (info->timeout > -1) {
+      timespec_from_nsec(&ts, info->timeout);
+      timeout = &ts;
+   }
 
    while (1) {
-      /* Try to dispatch potential events. */
-      int ret = wl_display_dispatch_queue_pending(chain->display->wl_display,
-                                                  chain->display->queue);
-      if (ret < 0)
-         return VK_ERROR_OUT_OF_DATE_KHR;
-
       /* Try to find a free image. */
       for (uint32_t i = 0; i < chain->base.image_count; i++) {
          if (!chain->images[i].busy) {
@@ -1069,46 +1062,15 @@ wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
          }
       }
 
-      /* Check for timeout. */
-      struct timespec current_time;
-      clock_gettime(CLOCK_MONOTONIC, &current_time);
-      if (timespec_after(&current_time, &end_time))
-         return VK_NOT_READY;
-
-      /* Try to read events from the server. */
-      ret = wl_display_prepare_read_queue(chain->display->wl_display,
-                                          chain->display->queue);
-      if (ret < 0) {
-         /* Another thread might have read events for our queue already. Go
-          * back to dispatch them.
-          */
-         if (errno == EAGAIN)
-            continue;
+      /* Try to dispatch potential events. */
+      int ret = wl_display_dispatch_queue_timeout(chain->display->wl_display,
+                                                  chain->display->queue,
+                                                  timeout);
+      if (ret == -1)
          return VK_ERROR_OUT_OF_DATE_KHR;
-      }
 
-      struct pollfd pollfd = {
-         .fd = wl_fd,
-         .events = POLLIN
-      };
-      timespec_sub(&rel_timeout, &end_time, &current_time);
-      ret = ppoll(&pollfd, 1, &rel_timeout, NULL);
-      if (ret <= 0) {
-         int lerrno = errno;
-         wl_display_cancel_read(chain->display->wl_display);
-         if (ret < 0) {
-            /* If ppoll() was interrupted, try again. */
-            if (lerrno == EINTR || lerrno == EAGAIN)
-               continue;
-            return VK_ERROR_OUT_OF_DATE_KHR;
-         }
-         assert(ret == 0);
-         continue;
-      }
-
-      ret = wl_display_read_events(chain->display->wl_display);
-      if (ret < 0)
-         return VK_ERROR_OUT_OF_DATE_KHR;
+      if (ret == -2)
+         return VK_NOT_READY;
    }
 }
 
-- 
GitLab


From 1191001ef41c6025c3e75c3bde55ee90e84ee1b3 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 01:53:39 +0200
Subject: [PATCH 4/5] vulkan/wsi/wayland: Guarantee 1Hz progress for FIFO
 present mode

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/vulkan/wsi/wsi_common_wayland.c | 48 +++++++++++++++++++++++++----
 1 file changed, 42 insertions(+), 6 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 4781c0146b05..c6bfc18f4b03 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -940,6 +940,9 @@ struct wsi_wl_swapchain {
 
    VkPresentModeKHR                             present_mode;
    bool                                         fifo_ready;
+   struct timespec                              lowest_tick_rate;
+   struct timespec                              last_frame_callback;
+   struct timespec                              last_queue_present;
 
    struct wsi_wl_image                          images[0];
 };
@@ -1078,9 +1081,21 @@ static void
 frame_handle_done(void *data, struct wl_callback *callback, uint32_t serial)
 {
    struct wsi_wl_swapchain *chain = data;
+   struct timespec deadline;
+   struct timespec now;
 
    chain->frame = NULL;
-   chain->fifo_ready = true;
+
+   clock_gettime(CLOCK_MONOTONIC, &now);
+   timespec_add(&deadline,
+                &chain->last_frame_callback,
+                &chain->lowest_tick_rate);
+
+   if (!timespec_after(&now, &deadline))
+      chain->fifo_ready = true;
+
+   chain->last_frame_callback.tv_sec = now.tv_sec;
+   chain->last_frame_callback.tv_nsec = now.tv_nsec;
 
    wl_callback_destroy(callback);
 }
@@ -1102,11 +1117,24 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
              image->base.row_pitches[0] * chain->extent.height);
    }
    if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR) {
+      struct timespec deadline;
+      struct timespec now;
+      struct timespec timeout;
+
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&deadline,
+                   &chain->last_queue_present,
+                   &chain->lowest_tick_rate);
+      timespec_sub_saturated(&timeout, &deadline, &now);
+
       while (!chain->fifo_ready) {
-         int ret = wl_display_dispatch_queue(chain->display->wl_display,
-                                             chain->display->queue);
-         if (ret < 0)
+         int ret = wl_display_dispatch_queue_timeout(chain->display->wl_display,
+                                                     chain->display->queue,
+                                                     &timeout);
+         if (ret == -1)
             return VK_ERROR_OUT_OF_DATE_KHR;
+         if (ret == -2)
+            break;
       }
    }
 
@@ -1127,11 +1155,15 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
    }
 
    if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR) {
-      chain->frame = wl_surface_frame(chain->surface);
-      wl_callback_add_listener(chain->frame, &frame_listener, chain);
+      if (chain->frame == NULL) {
+         chain->frame = wl_surface_frame(chain->surface);
+         wl_callback_add_listener(chain->frame, &frame_listener, chain);
+      }
       chain->fifo_ready = false;
    }
 
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
+
    chain->images[image_index].busy = true;
    wl_surface_commit(chain->surface);
    wl_display_flush(chain->display->wl_display);
@@ -1390,6 +1422,10 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    }
 
    chain->fifo_ready = true;
+   chain->lowest_tick_rate.tv_sec = 1;
+   chain->lowest_tick_rate.tv_nsec = 0;
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_frame_callback);
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
 
    switch (chain->buffer_type) {
    case WSI_WL_BUFFER_NATIVE:
-- 
GitLab


From c2d52b4bf0eaf1a6d1a2ba30189b7666b8a6edd4 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sat, 3 Sep 2022 18:46:24 +0200
Subject: [PATCH 5/5] vulkan/wsi/wayland: Make the minimum FIFO frequency
 configurable

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/amd/vulkan/radv_device.c        |  1 +
 src/util/driconf.h                  |  4 ++++
 src/vulkan/wsi/wsi_common.c         |  2 +-
 src/vulkan/wsi/wsi_common_private.h |  3 ++-
 src/vulkan/wsi/wsi_common_wayland.c | 17 ++++++++++++++---
 5 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 0c73819ede70..44d6ce818689 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1042,6 +1042,7 @@ static const driOptionDescription radv_dri_options[] = {
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(true)
+      DRI_CONF_VK_WAYLAND_MIN_FIFO_FREQUENCY(1)
       DRI_CONF_RADV_REPORT_LLVM9_VERSION_STRING(false)
       DRI_CONF_RADV_ENABLE_MRT_OUTPUT_NAN_FIXUP(false)
       DRI_CONF_RADV_DISABLE_SHRINK_IMAGE_STORE(false)
diff --git a/src/util/driconf.h b/src/util/driconf.h
index db095fdcd131..647f220b9be8 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -376,6 +376,10 @@
    DRI_CONF_OPT_B(vk_xwayland_wait_ready, def, \
                   "Wait for fences before submitting buffers to Xwayland")
 
+#define DRI_CONF_VK_WAYLAND_MIN_FIFO_FREQUENCY(def) \
+   DRI_CONF_OPT_I(vk_wayland_min_fifo_frequency, def, 1, 1000, \
+                  "Limit the blocking of QueuePresent with present mode FIFO to no more than 1/frequency seconds")
+
 #define DRI_CONF_MESA_GLTHREAD(def) \
    DRI_CONF_OPT_B(mesa_glthread, def, \
                   "Enable offloading GL driver work to a separate thread")
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 5cafaf3dd861..7db95f09513e 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -171,7 +171,7 @@ wsi_device_init(struct wsi_device *wsi,
 #endif
 
 #ifdef VK_USE_PLATFORM_WAYLAND_KHR
-   result = wsi_wl_init_wsi(wsi, alloc, pdevice);
+   result = wsi_wl_init_wsi(wsi, alloc, pdevice, dri_options);
    if (result != VK_SUCCESS)
       goto fail;
 #endif
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 6315e6c7d844..09f96ac0f99c 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -276,7 +276,8 @@ void wsi_x11_finish_wsi(struct wsi_device *wsi_device,
                         const VkAllocationCallbacks *alloc);
 VkResult wsi_wl_init_wsi(struct wsi_device *wsi_device,
                          const VkAllocationCallbacks *alloc,
-                         VkPhysicalDevice physical_device);
+                         VkPhysicalDevice physical_device,
+                         const struct driOptionCache *dri_options);
 void wsi_wl_finish_wsi(struct wsi_device *wsi_device,
                        const VkAllocationCallbacks *alloc);
 VkResult wsi_win32_init_wsi(struct wsi_device *wsi_device,
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index c6bfc18f4b03..0335394872fc 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -47,6 +47,7 @@
 #include <util/timespec.h>
 #include <util/u_vector.h>
 #include <util/anon_file.h>
+#include <util/xmlconfig.h>
 
 struct wsi_wayland;
 
@@ -81,6 +82,7 @@ struct wsi_wayland {
    struct wsi_interface                     base;
 
    struct wsi_device *wsi;
+   int min_fifo_frequency;
 
    const VkAllocationCallbacks *alloc;
    VkPhysicalDevice physical_device;
@@ -1422,8 +1424,8 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    }
 
    chain->fifo_ready = true;
-   chain->lowest_tick_rate.tv_sec = 1;
-   chain->lowest_tick_rate.tv_nsec = 0;
+   timespec_from_nsec(&chain->lowest_tick_rate,
+                      (uint64_t)NSEC_PER_SEC / wsi->min_fifo_frequency);
    clock_gettime(CLOCK_MONOTONIC, &chain->last_frame_callback);
    clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
 
@@ -1477,7 +1479,8 @@ fail:
 VkResult
 wsi_wl_init_wsi(struct wsi_device *wsi_device,
                 const VkAllocationCallbacks *alloc,
-                VkPhysicalDevice physical_device)
+                VkPhysicalDevice physical_device,
+                const struct driOptionCache *dri_options)
 {
    struct wsi_wayland *wsi;
    VkResult result;
@@ -1492,6 +1495,14 @@ wsi_wl_init_wsi(struct wsi_device *wsi_device,
    wsi->physical_device = physical_device;
    wsi->alloc = alloc;
    wsi->wsi = wsi_device;
+   wsi->min_fifo_frequency = 1;
+
+   if (dri_options) {
+      if (driCheckOption(dri_options, "vk_wayland_min_fifo_frequency", DRI_INT)) {
+         wsi->min_fifo_frequency =
+            driQueryOptioni(dri_options, "vk_wayland_min_fifo_frequency");
+      }
+   }
 
    wsi->base.get_support = wsi_wl_surface_get_support;
    wsi->base.get_capabilities2 = wsi_wl_surface_get_capabilities2;
-- 
GitLab

