From 2d8345d4f720b2deb90fe2d5ae9848246fcc54f8 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 00:49:23 +0200
Subject: [PATCH 1/7] util: Add timespec_sub_saturated to avoid negative time
 for deadlines

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/util/timespec.h | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/util/timespec.h b/src/util/timespec.h
index 378ebbba9e54..2022ab56dce5 100644
--- a/src/util/timespec.h
+++ b/src/util/timespec.h
@@ -79,6 +79,24 @@ timespec_sub(struct timespec *r,
    }
 }
 
+/**
+ * Saturated subtract timespecs
+ *
+ * \param r[out] result: max(a - b, 0)
+ * \param a[in] operand
+ * \param b[in] operand
+ */
+static inline void
+timespec_sub_saturated(struct timespec *r,
+                       const struct timespec *a, const struct timespec *b)
+{
+   timespec_sub(r, a, b);
+   if (r->tv_sec < 0) {
+      r->tv_sec = 0;
+      r->tv_nsec = 0;
+   }
+}
+
 #define TIME_T_MAX \
    ((time_t)(((time_t)-1) > 0 ? u_uintN_max(sizeof(time_t) * 8) : \
                                 u_intN_max(sizeof(time_t) * 8)))
-- 
GitLab


From 8fd875b5a2327962b4c86c93060afc4cd9e6b1af Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 00:59:52 +0200
Subject: [PATCH 2/7] loader/wayland: Add fallback
 wl_display_dispatch_queue_timeout

This is almost a 1:1 copy of the same function in libwayland. If the version
with the symbol propagates far enough the fallback can be removed again.

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 meson.build                         |   6 ++
 src/loader/loader_wayland_helper.c  | 125 ++++++++++++++++++++++++++++
 src/loader/loader_wayland_helper.h  |  36 ++++++++
 src/loader/meson.build              |  15 ++++
 src/meson.build                     |   6 +-
 src/vulkan/wsi/meson.build          |   1 +
 src/vulkan/wsi/wsi_common_wayland.c |   2 +
 7 files changed, 188 insertions(+), 3 deletions(-)
 create mode 100644 src/loader/loader_wayland_helper.c
 create mode 100644 src/loader/loader_wayland_helper.h

diff --git a/meson.build b/meson.build
index 2f329d0d110b..e374a5f29eb0 100644
--- a/meson.build
+++ b/meson.build
@@ -1903,6 +1903,12 @@ if with_platform_wayland
     'linux-dmabuf', 'linux-dmabuf-unstable-v1.xml'
   )
   pre_args += '-DWL_HIDE_DEPRECATED'
+  if cc.has_function(
+      'wl_display_dispatch_queue_timeout',
+      prefix : '#include <wayland-client.h>',
+      dependencies: dep_wayland_client)
+    pre_args += ['-DHAVE_WL_DISPATCH_QUEUE_TIMEOUT']
+  endif
 endif
 
 dep_x11 = null_dep
diff --git a/src/loader/loader_wayland_helper.c b/src/loader/loader_wayland_helper.c
new file mode 100644
index 000000000000..213ea850b703
--- /dev/null
+++ b/src/loader/loader_wayland_helper.c
@@ -0,0 +1,125 @@
+/*
+ * Copyright © 2022 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <poll.h>
+#include <errno.h>
+
+#include "loader_wayland_helper.h"
+
+#ifndef HAVE_WL_DISPATCH_QUEUE_TIMEOUT
+static int
+wl_display_poll(struct wl_display *display,
+                short int events,
+                const struct timespec *timeout)
+{
+   int ret;
+   struct pollfd pfd[1];
+   struct timespec now;
+   struct timespec deadline = {0};
+   struct timespec result;
+   struct timespec *remaining_timeout = NULL;
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&deadline, &now, timeout);
+   }
+
+   pfd[0].fd = wl_display_get_fd(display);
+   pfd[0].events = events;
+   do {
+      if (timeout) {
+         clock_gettime(CLOCK_MONOTONIC, &now);
+         timespec_sub_saturated(&result, &deadline, &now);
+         remaining_timeout = &result;
+      }
+      ret = ppoll(pfd, 1, remaining_timeout, NULL);
+   } while (ret == -1 && errno == EINTR);
+
+   if (ret == 0)
+      return -2;
+
+   return ret;
+}
+
+int
+wl_display_dispatch_queue_timeout(struct wl_display *display,
+                                  struct wl_event_queue *queue,
+                                  const struct timespec *timeout)
+{
+   int ret;
+   struct timespec now;
+   struct timespec deadline = {0};
+   struct timespec result;
+   struct timespec *remaining_timeout = NULL;
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&deadline, &now, timeout);
+   }
+
+   if (wl_display_prepare_read_queue(display, queue) == -1)
+      return wl_display_dispatch_queue_pending(display, queue);
+
+   while (true) {
+      ret = wl_display_flush(display);
+
+      if (ret != -1 || errno != EAGAIN)
+         break;
+
+      if (timeout) {
+         clock_gettime(CLOCK_MONOTONIC, &now);
+         timespec_sub_saturated(&result, &deadline, &now);
+         remaining_timeout = &result;
+      }
+      ret = wl_display_poll(display, POLLOUT, remaining_timeout);
+
+      if (ret < 0) {
+         wl_display_cancel_read(display);
+         return ret;
+      }
+   }
+
+   /* Don't stop if flushing hits an EPIPE; continue so we can read any
+    * protocol error that may have triggered it. */
+   if (ret < 0 && errno != EPIPE) {
+      wl_display_cancel_read(display);
+      return -1;
+   }
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_sub_saturated(&result, &deadline, &now);
+      remaining_timeout = &result;
+   }
+   ret = wl_display_poll(display, POLLIN, remaining_timeout);
+
+   if (ret < 0) {
+      wl_display_cancel_read(display);
+      return ret;
+   }
+
+   if (wl_display_read_events(display) == -1)
+      return -1;
+
+   return wl_display_dispatch_queue_pending(display, queue);
+}
+#endif
diff --git a/src/loader/loader_wayland_helper.h b/src/loader/loader_wayland_helper.h
new file mode 100644
index 000000000000..ecd01e6d45a0
--- /dev/null
+++ b/src/loader/loader_wayland_helper.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright © 2022 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef LOADER_WAYLAND_HELPER_HEADER_H
+#define LOADER_WAYLAND_HELPER_HEADER_H
+
+#ifndef HAVE_WL_DISPATCH_QUEUE_TIMEOUT
+
+#include <wayland-client.h>
+#include <util/timespec.h>
+int
+wl_display_dispatch_queue_timeout(struct wl_display *display,
+                                  struct wl_event_queue *queue,
+                                  const struct timespec *deadline);
+#endif
+
+#endif
diff --git a/src/loader/meson.build b/src/loader/meson.build
index b03b229cd851..46887a372a65 100644
--- a/src/loader/meson.build
+++ b/src/loader/meson.build
@@ -36,6 +36,21 @@ else
   libloader_dri3_helper = []
 endif
 
+if with_platform_wayland
+  libloader_wayland_helper = static_library(
+    'loader_wayland_helper',
+    'loader_wayland_helper.c',
+    gnu_symbol_visibility : 'hidden',
+    include_directories : [inc_include, inc_src],
+    dependencies : [
+      dep_wayland_client,
+    ],
+    build_by_default : false,
+  )
+else
+  libloader_wayland_helper = []
+endif
+
 loader_c_args = [
   '-DUSE_DRICONF',
   '-DDEFAULT_DRIVER_DIR="@0@"'.format(dri_search_path),
diff --git a/src/meson.build b/src/meson.build
index ebfcf94858fe..d5faa86bc5cd 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -60,6 +60,9 @@ endif
 subdir('android_stub')
 subdir('c11/impl')
 subdir('util')
+if with_gallium or with_gbm
+  subdir('loader')
+endif
 if with_gallium
   subdir('mapi')
 endif
@@ -109,9 +112,6 @@ endif
 if with_gallium_asahi or with_tools.contains('asahi')
   subdir('asahi')
 endif
-if with_gallium or with_gbm
-  subdir('loader')
-endif
 if with_gbm
   subdir('gbm')
 else
diff --git a/src/vulkan/wsi/meson.build b/src/vulkan/wsi/meson.build
index 0a9ac8ef5721..453dbe180169 100644
--- a/src/vulkan/wsi/meson.build
+++ b/src/vulkan/wsi/meson.build
@@ -67,6 +67,7 @@ libvulkan_wsi = static_library(
     vulkan_wsi_deps, dep_libdrm, dep_libudev, idep_vulkan_util_headers,
     idep_vulkan_runtime_headers, idep_xmlconfig, idep_mesautil, platform_deps
   ],
+  link_with: libloader_wayland_helper,
   gnu_symbol_visibility : 'hidden',
   build_by_default : false,
 )
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 154d1278c7a2..37d00f83b4ea 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -51,6 +51,8 @@
 #include <util/u_dynarray.h>
 #include <util/anon_file.h>
 
+#include <loader/loader_wayland_helper.h>
+
 #ifdef MAJOR_IN_MKDEV
 #include <sys/mkdev.h>
 #endif
-- 
GitLab


From 0c1f2562a71bbaa7e158547157c191aa2dcb56d0 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 01:04:21 +0200
Subject: [PATCH 3/7] vulkan/wsi/wayland: Use dispatch_queue_timeout in
 acquire_next_image

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/vulkan/wsi/wsi_common_wayland.c | 73 +++++++++--------------------
 1 file changed, 22 insertions(+), 51 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 37d00f83b4ea..1ba1bafc6e95 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -1569,22 +1569,18 @@ wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
 {
    struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
    struct wsi_wl_surface *wsi_wl_surface = chain->wsi_wl_surface;
-   struct timespec start_time, end_time;
-   struct timespec rel_timeout;
-   int wl_fd = wl_display_get_fd(wsi_wl_surface->display->wl_display);
-
-   timespec_from_nsec(&rel_timeout, info->timeout);
-
-   clock_gettime(CLOCK_MONOTONIC, &start_time);
-   timespec_add(&end_time, &rel_timeout, &start_time);
+   struct timespec now;
+   struct timespec timeout;
+   struct timespec deadline = { 0 };
+   struct timespec *remaining_timeout = NULL;
+
+   if (info->timeout > -1) {
+      timespec_from_nsec(&timeout, info->timeout);
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&deadline, &now, &timeout);
+   }
 
    while (1) {
-      /* Try to dispatch potential events. */
-      int ret = wl_display_dispatch_queue_pending(wsi_wl_surface->display->wl_display,
-                                                  wsi_wl_surface->display->queue);
-      if (ret < 0)
-         return VK_ERROR_OUT_OF_DATE_KHR;
-
       /* Try to find a free image. */
       for (uint32_t i = 0; i < chain->base.image_count; i++) {
          if (!chain->images[i].busy) {
@@ -1595,46 +1591,21 @@ wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
          }
       }
 
-      /* Check for timeout. */
-      struct timespec current_time;
-      clock_gettime(CLOCK_MONOTONIC, &current_time);
-      if (timespec_after(&current_time, &end_time))
-         return (info->timeout ? VK_TIMEOUT : VK_NOT_READY);
-
-      /* Try to read events from the server. */
-      ret = wl_display_prepare_read_queue(wsi_wl_surface->display->wl_display,
-                                          wsi_wl_surface->display->queue);
-      if (ret < 0) {
-         /* Another thread might have read events for our queue already. Go
-          * back to dispatch them.
-          */
-         if (errno == EAGAIN)
-            continue;
-         return VK_ERROR_OUT_OF_DATE_KHR;
-      }
-
-      struct pollfd pollfd = {
-         .fd = wl_fd,
-         .events = POLLIN
-      };
-      timespec_sub(&rel_timeout, &end_time, &current_time);
-      ret = ppoll(&pollfd, 1, &rel_timeout, NULL);
-      if (ret <= 0) {
-         int lerrno = errno;
-         wl_display_cancel_read(wsi_wl_surface->display->wl_display);
-         if (ret < 0) {
-            /* If ppoll() was interrupted, try again. */
-            if (lerrno == EINTR || lerrno == EAGAIN)
-               continue;
-            return VK_ERROR_OUT_OF_DATE_KHR;
-         }
-         assert(ret == 0);
-         continue;
+      if (info->timeout > -1) {
+         clock_gettime(CLOCK_MONOTONIC, &now);
+         timespec_sub_saturated(&timeout, &deadline, &now);
+         remaining_timeout = &timeout;
       }
 
-      ret = wl_display_read_events(wsi_wl_surface->display->wl_display);
-      if (ret < 0)
+      /* Try to dispatch potential events. */
+      int ret = wl_display_dispatch_queue_timeout(wsi_wl_surface->display->wl_display,
+                                                  wsi_wl_surface->display->queue,
+                                                  remaining_timeout);
+      if (ret == -1)
          return VK_ERROR_OUT_OF_DATE_KHR;
+
+      if (ret == -2)
+         return VK_NOT_READY;
    }
 }
 
-- 
GitLab


From b80b17bbbc7affc81fba7c65769a65b814726dc1 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 01:53:39 +0200
Subject: [PATCH 4/7] vulkan/wsi/wayland: Guarantee 1Hz progress for FIFO
 present mode

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/vulkan/wsi/wsi_common_wayland.c | 48 +++++++++++++++++++++++++----
 1 file changed, 42 insertions(+), 6 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 1ba1bafc6e95..367355d54e92 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -170,6 +170,10 @@ struct wsi_wl_swapchain {
    VkPresentModeKHR present_mode;
    bool fifo_ready;
 
+   struct timespec lowest_tick_rate;
+   struct timespec last_frame_callback;
+   struct timespec last_queue_present;
+
    struct wsi_wl_image images[0];
 };
 VK_DEFINE_NONDISP_HANDLE_CASTS(wsi_wl_swapchain, base.base, VkSwapchainKHR,
@@ -1613,9 +1617,21 @@ static void
 frame_handle_done(void *data, struct wl_callback *callback, uint32_t serial)
 {
    struct wsi_wl_swapchain *chain = data;
+   struct timespec deadline;
+   struct timespec now;
 
    chain->frame = NULL;
-   chain->fifo_ready = true;
+
+   clock_gettime(CLOCK_MONOTONIC, &now);
+   timespec_add(&deadline,
+                &chain->last_frame_callback,
+                &chain->lowest_tick_rate);
+
+   if (!timespec_after(&now, &deadline))
+      chain->fifo_ready = true;
+
+   chain->last_frame_callback.tv_sec = now.tv_sec;
+   chain->last_frame_callback.tv_nsec = now.tv_nsec;
 
    wl_callback_destroy(callback);
 }
@@ -1632,6 +1648,9 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
 {
    struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
    struct wsi_wl_surface *wsi_wl_surface = chain->wsi_wl_surface;
+   struct timespec deadline;
+   struct timespec now;
+   struct timespec remaining_timeout;
 
    if (chain->buffer_type == WSI_WL_BUFFER_SHM_MEMCPY) {
       struct wsi_wl_image *image = &chain->images[image_index];
@@ -1639,13 +1658,22 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
              image->base.row_pitches[0] * chain->extent.height);
    }
 
+   timespec_add(&deadline,
+                &chain->last_queue_present,
+                &chain->lowest_tick_rate);
+
    /* For EXT_swapchain_maintenance1. We might have transitioned from FIFO to MAILBOX.
     * In this case we need to let the FIFO request complete, before presenting MAILBOX. */
    while (!chain->fifo_ready) {
-      int ret = wl_display_dispatch_queue(wsi_wl_surface->display->wl_display,
-                                          wsi_wl_surface->display->queue);
-      if (ret < 0)
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_sub_saturated(&remaining_timeout, &deadline, &now);
+      int ret = wl_display_dispatch_queue_timeout(wsi_wl_surface->display->wl_display,
+                                                  wsi_wl_surface->display->queue,
+                                                  &remaining_timeout);
+      if (ret == -1)
          return VK_ERROR_OUT_OF_DATE_KHR;
+      if (ret == -2)
+         break;
    }
 
    assert(image_index < chain->base.image_count);
@@ -1665,14 +1693,18 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
    }
 
    if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR) {
-      chain->frame = wl_surface_frame(wsi_wl_surface->surface);
-      wl_callback_add_listener(chain->frame, &frame_listener, chain);
+      if (chain->frame == NULL) {
+         chain->frame = wl_surface_frame(wsi_wl_surface->surface);
+         wl_callback_add_listener(chain->frame, &frame_listener, chain);
+      }
       chain->fifo_ready = false;
    } else {
       /* If we present MAILBOX, any subsequent presentation in FIFO can replace this image. */
       chain->fifo_ready = true;
    }
 
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
+
    chain->images[image_index].busy = true;
    wl_surface_commit(wsi_wl_surface->surface);
    wl_display_flush(wsi_wl_surface->display->wl_display);
@@ -1961,6 +1993,10 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->num_drm_modifiers = num_drm_modifiers;
    chain->drm_modifiers = drm_modifiers;
    chain->fifo_ready = true;
+   chain->lowest_tick_rate.tv_sec = 1;
+   chain->lowest_tick_rate.tv_nsec = 0;
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_frame_callback);
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
 
    for (uint32_t i = 0; i < chain->base.image_count; i++) {
       result = wsi_wl_image_init(chain, &chain->images[i],
-- 
GitLab


From df28d4218dd9f7538dd7896e8aa9dd821cf0ed7d Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sat, 3 Sep 2022 18:46:24 +0200
Subject: [PATCH 5/7] vulkan/wsi/wayland: Make the minimum FIFO frequency
 configurable

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/amd/vulkan/radv_instance.c      |  1 +
 src/util/driconf.h                  |  4 ++++
 src/vulkan/wsi/wsi_common.c         |  2 +-
 src/vulkan/wsi/wsi_common_private.h |  3 ++-
 src/vulkan/wsi/wsi_common_wayland.c | 19 ++++++++++++++++---
 5 files changed, 24 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_instance.c b/src/amd/vulkan/radv_instance.c
index 14aa0c983ca0..397098d126e0 100644
--- a/src/amd/vulkan/radv_instance.c
+++ b/src/amd/vulkan/radv_instance.c
@@ -114,6 +114,7 @@ radv_get_perftest_option_name(int id)
 static const driOptionDescription radv_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
+      DRI_CONF_WAYLAND_MIN_SYNC_FREQUENCY(1)
       DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
diff --git a/src/util/driconf.h b/src/util/driconf.h
index c5de0c1ad589..ec00fc924e8d 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -376,6 +376,10 @@
    DRI_CONF_OPT_B(block_on_depleted_buffers, def, \
                   "Block clients using buffer backpressure until new buffer is available to reduce latency")
 
+#define DRI_CONF_WAYLAND_MIN_SYNC_FREQUENCY(def) \
+   DRI_CONF_OPT_I(wayland_min_sync_frequency, def, 1, 1000, \
+                  "Limit the blocking of vkQueuePresent/eglSwapBuffers to no more than 1/frequency (in Hz)")
+
 #define DRI_CONF_VK_WSI_FORCE_BGRA8_UNORM_FIRST(def) \
    DRI_CONF_OPT_B(vk_wsi_force_bgra8_unorm_first, def, \
                   "Force vkGetPhysicalDeviceSurfaceFormatsKHR to return VK_FORMAT_B8G8R8A8_UNORM as the first format")
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index b03a35901888..3035c62a64dd 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -190,7 +190,7 @@ wsi_device_init(struct wsi_device *wsi,
 #endif
 
 #ifdef VK_USE_PLATFORM_WAYLAND_KHR
-   result = wsi_wl_init_wsi(wsi, alloc, pdevice);
+   result = wsi_wl_init_wsi(wsi, alloc, pdevice, dri_options);
    if (result != VK_SUCCESS)
       goto fail;
 #endif
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index fd4d8482288f..1f08765316cc 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -360,7 +360,8 @@ void wsi_x11_finish_wsi(struct wsi_device *wsi_device,
                         const VkAllocationCallbacks *alloc);
 VkResult wsi_wl_init_wsi(struct wsi_device *wsi_device,
                          const VkAllocationCallbacks *alloc,
-                         VkPhysicalDevice physical_device);
+                         VkPhysicalDevice physical_device,
+                         const struct driOptionCache *dri_options);
 void wsi_wl_finish_wsi(struct wsi_device *wsi_device,
                        const VkAllocationCallbacks *alloc);
 VkResult wsi_win32_init_wsi(struct wsi_device *wsi_device,
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 367355d54e92..c84be4d03b95 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -50,6 +50,7 @@
 #include <util/u_vector.h>
 #include <util/u_dynarray.h>
 #include <util/anon_file.h>
+#include <util/xmlconfig.h>
 
 #include <loader/loader_wayland_helper.h>
 
@@ -118,6 +119,7 @@ struct wsi_wayland {
    struct wsi_interface base;
 
    struct wsi_device *wsi;
+   int min_sync_frequency;
 
    const VkAllocationCallbacks *alloc;
    VkPhysicalDevice physical_device;
@@ -1881,6 +1883,8 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
 {
    struct wsi_wl_surface *wsi_wl_surface =
       wl_container_of((VkIcdSurfaceWayland *)icd_surface, wsi_wl_surface, base);
+   struct wsi_wayland *wsi =
+      (struct wsi_wayland *)wsi_device->wsi[VK_ICD_WSI_PLATFORM_WAYLAND];
    struct wsi_wl_swapchain *chain;
    VkResult result;
 
@@ -1993,8 +1997,8 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->num_drm_modifiers = num_drm_modifiers;
    chain->drm_modifiers = drm_modifiers;
    chain->fifo_ready = true;
-   chain->lowest_tick_rate.tv_sec = 1;
-   chain->lowest_tick_rate.tv_nsec = 0;
+   timespec_from_nsec(&chain->lowest_tick_rate,
+                      (uint64_t)NSEC_PER_SEC / wsi->min_sync_frequency);
    clock_gettime(CLOCK_MONOTONIC, &chain->last_frame_callback);
    clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
 
@@ -2024,7 +2028,8 @@ fail:
 VkResult
 wsi_wl_init_wsi(struct wsi_device *wsi_device,
                 const VkAllocationCallbacks *alloc,
-                VkPhysicalDevice physical_device)
+                VkPhysicalDevice physical_device,
+                const struct driOptionCache *dri_options)
 {
    struct wsi_wayland *wsi;
    VkResult result;
@@ -2039,6 +2044,14 @@ wsi_wl_init_wsi(struct wsi_device *wsi_device,
    wsi->physical_device = physical_device;
    wsi->alloc = alloc;
    wsi->wsi = wsi_device;
+   wsi->min_sync_frequency = 1;
+
+   if (dri_options) {
+      if (driCheckOption(dri_options, "wayland_min_sync_frequency", DRI_INT)) {
+         wsi->min_sync_frequency =
+            driQueryOptioni(dri_options, "wayland_min_sync_frequency");
+      }
+   }
 
    wsi->base.get_support = wsi_wl_surface_get_support;
    wsi->base.get_capabilities2 = wsi_wl_surface_get_capabilities2;
-- 
GitLab


From 0c0c75453f4008bd04269c833fa15b8e251aa131 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sun, 11 Sep 2022 19:15:37 +0200
Subject: [PATCH 6/7] egl/wayland: Guarantee 1Hz progress for SwapInterval > 0

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/egl/drivers/dri2/egl_dri2.h         |  4 +++
 src/egl/drivers/dri2/platform_wayland.c | 47 ++++++++++++++++++++++---
 src/egl/meson.build                     |  2 +-
 3 files changed, 48 insertions(+), 5 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index a803a0f229d4..dd3816e54da9 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -349,6 +349,10 @@ struct dri2_egl_surface
    struct wl_display *wl_dpy_wrapper;
    struct wl_drm *wl_drm_wrapper;
    struct wl_callback *throttle_callback;
+   bool throttle_ready;
+   struct timespec last_throttle_callback;
+   struct timespec last_swap_buffers;
+   struct timespec lowest_tick_rate;
    struct zwp_linux_dmabuf_feedback_v1 *wl_dmabuf_feedback;
    struct dmabuf_feedback dmabuf_feedback, pending_dmabuf_feedback;
    bool compositor_using_another_device;
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index fe152294a85c..81a0ca8d27ca 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -43,11 +43,13 @@
 
 #include "egl_dri2.h"
 #include "loader_dri_helper.h"
+#include "loader_wayland_helper.h"
 #include "loader.h"
 #include "util/u_vector.h"
 #include "util/anon_file.h"
 #include "eglglobals.h"
 #include "kopper_interface.h"
+#include "util/timespec.h"
 
 #include <wayland-egl-backend.h>
 #include <wayland-client.h>
@@ -751,6 +753,12 @@ dri2_wl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    dri2_surf->base.SwapInterval = dri2_dpy->default_swap_interval;
 
+   dri2_surf->throttle_ready = true;
+   timespec_from_nsec(&dri2_surf->lowest_tick_rate,
+                      (uint64_t)NSEC_PER_SEC / 1);
+   clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_throttle_callback);
+   clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_swap_buffers);
+
    return &dri2_surf->base;
 
  cleanup_dmabuf_feedback:
@@ -1385,8 +1393,22 @@ wayland_throttle_callback(void *data,
                           uint32_t time)
 {
    struct dri2_egl_surface *dri2_surf = data;
+   struct timespec deadline;
+   struct timespec now;
 
    dri2_surf->throttle_callback = NULL;
+
+   clock_gettime(CLOCK_MONOTONIC, &now);
+   timespec_add(&deadline,
+                &dri2_surf->last_throttle_callback,
+                &dri2_surf->lowest_tick_rate);
+
+   if (!timespec_after(&now, &deadline))
+      dri2_surf->throttle_ready = true;
+
+   dri2_surf->last_throttle_callback.tv_sec = now.tv_sec;
+   dri2_surf->last_throttle_callback.tv_nsec = now.tv_nsec;
+
    wl_callback_destroy(callback);
 }
 
@@ -1584,6 +1606,9 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
+   struct timespec deadline;
+   struct timespec now;
+   struct timespec remaining_timeout;
 
    if (!dri2_surf->wl_win)
       return _eglError(EGL_BAD_NATIVE_WINDOW, "dri2_swap_buffers");
@@ -1601,10 +1626,23 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
    dri2_flush_drawable_for_swapbuffers(disp, draw);
    dri2_dpy->flush->invalidate(dri2_surf->dri_drawable);
 
-   while (dri2_surf->throttle_callback != NULL)
-      if (wl_display_dispatch_queue(dri2_dpy->wl_dpy,
-                                    dri2_surf->wl_queue) == -1)
+   timespec_add(&deadline,
+                &dri2_surf->last_swap_buffers,
+                &dri2_surf->lowest_tick_rate);
+
+   while (!dri2_surf->throttle_ready) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_sub_saturated(&remaining_timeout, &deadline, &now);
+      int ret = wl_display_dispatch_queue_timeout(dri2_dpy->wl_dpy,
+                                                  dri2_surf->wl_queue,
+                                                  &remaining_timeout);
+      if (ret == -1)
          return -1;
+      if (ret == -2)
+         break;
+   }
+
+   clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_swap_buffers);
 
    for (int i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++)
       if (dri2_surf->color_buffers[i].age > 0)
@@ -1615,13 +1653,14 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
    if (update_buffers_if_needed(dri2_surf) < 0)
       return _eglError(EGL_BAD_ALLOC, "dri2_swap_buffers");
 
-   if (draw->SwapInterval > 0) {
+   if (draw->SwapInterval > 0 && dri2_surf->throttle_callback == NULL) {
       dri2_surf->throttle_callback =
          wl_surface_frame(dri2_surf->wl_surface_wrapper);
       wl_callback_add_listener(dri2_surf->throttle_callback,
                                &throttle_listener, dri2_surf);
    }
 
+   dri2_surf->throttle_ready = false;
    dri2_surf->back->age = 1;
    dri2_surf->current = dri2_surf->back;
    dri2_surf->back = NULL;
diff --git a/src/egl/meson.build b/src/egl/meson.build
index 708c1206b97b..581389b2536c 100644
--- a/src/egl/meson.build
+++ b/src/egl/meson.build
@@ -123,7 +123,7 @@ if with_dri2
   endif
   if with_platform_wayland
     deps_for_egl += [dep_wayland_client, dep_wayland_server, dep_wayland_egl_headers]
-    link_for_egl += libwayland_drm
+    link_for_egl += [libwayland_drm, libloader_wayland_helper]
     files_egl += files('drivers/dri2/platform_wayland.c')
     files_egl += [
       linux_dmabuf_unstable_v1_protocol_c,
-- 
GitLab


From 2ae30237602ec07c63e245bc07aff3dccddb0267 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sun, 11 Sep 2022 21:51:16 +0200
Subject: [PATCH 7/7] egl/wayland: Make the minimum SwapBuffer frequency
 configurable

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/egl/drivers/dri2/egl_dri2.h         | 1 +
 src/egl/drivers/dri2/platform_wayland.c | 8 +++++++-
 src/gallium/frontends/dri/dri_util.c    | 1 +
 3 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index dd3816e54da9..9cc8b8c561ae 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -307,6 +307,7 @@ struct dri2_egl_display
    bool authenticated;
    uint32_t capabilities;
    char *device_name;
+   int min_sync_frequency;
 #endif
 
 #ifdef HAVE_ANDROID_PLATFORM
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 81a0ca8d27ca..5f1a71497c2f 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -755,7 +755,7 @@ dri2_wl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    dri2_surf->throttle_ready = true;
    timespec_from_nsec(&dri2_surf->lowest_tick_rate,
-                      (uint64_t)NSEC_PER_SEC / 1);
+                      (uint64_t)NSEC_PER_SEC / dri2_dpy->min_sync_frequency);
    clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_throttle_callback);
    clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_swap_buffers);
 
@@ -2330,6 +2330,12 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    dri2_wl_setup_swap_interval(disp);
 
+   dri2_dpy->min_sync_frequency = 1;
+   if (dri2_dpy->config)
+      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen_render_gpu,
+                                     "wayland_min_sync_frequency",
+                                     &dri2_dpy->min_sync_frequency);
+
    if (dri2_dpy->wl_drm) {
       /* To use Prime, we must have _DRI_IMAGE v7 at least. createImageFromFds
        * support indicates that Prime export/import is supported by the driver.
diff --git a/src/gallium/frontends/dri/dri_util.c b/src/gallium/frontends/dri/dri_util.c
index 026fa5f85606..eb9e60140ae0 100644
--- a/src/gallium/frontends/dri/dri_util.c
+++ b/src/gallium/frontends/dri/dri_util.c
@@ -63,6 +63,7 @@ driOptionDescription __dri2ConfigOptions[] = {
       DRI_CONF_SECTION_PERFORMANCE
          DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_1)
          DRI_CONF_BLOCK_ON_DEPLETED_BUFFERS(false)
+         DRI_CONF_WAYLAND_MIN_SYNC_FREQUENCY(1)
       DRI_CONF_SECTION_END
 };
 
-- 
GitLab

