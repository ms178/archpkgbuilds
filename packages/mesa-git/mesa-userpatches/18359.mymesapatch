From ae6bd23640fad609db1b0aefb002a20a03036d10 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 00:49:23 +0200
Subject: [PATCH 1/8] util: Add timespec_sub_saturated to avoid negative time
 for deadlines

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/util/timespec.h | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/util/timespec.h b/src/util/timespec.h
index 378ebbba9e54..2022ab56dce5 100644
--- a/src/util/timespec.h
+++ b/src/util/timespec.h
@@ -79,6 +79,24 @@ timespec_sub(struct timespec *r,
    }
 }
 
+/**
+ * Saturated subtract timespecs
+ *
+ * \param r[out] result: max(a - b, 0)
+ * \param a[in] operand
+ * \param b[in] operand
+ */
+static inline void
+timespec_sub_saturated(struct timespec *r,
+                       const struct timespec *a, const struct timespec *b)
+{
+   timespec_sub(r, a, b);
+   if (r->tv_sec < 0) {
+      r->tv_sec = 0;
+      r->tv_nsec = 0;
+   }
+}
+
 #define TIME_T_MAX \
    ((time_t)(((time_t)-1) > 0 ? u_uintN_max(sizeof(time_t) * 8) : \
                                 u_intN_max(sizeof(time_t) * 8)))
-- 
GitLab


From 690113fffad2bf5cef7cdb52b7679a69861babd8 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 00:59:52 +0200
Subject: [PATCH 2/8] vulkan/wsi/wayland: Add fallback
 wl_display_dispatch_queue_timeout

This is almost a 1:1 copy of the same function in libwayland. If the version
with the symbol propagates far enough the fallback can be removed again.

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 meson.build                         |  6 +++
 src/vulkan/wsi/wsi_common_wayland.c | 83 +++++++++++++++++++++++++++++
 2 files changed, 89 insertions(+)

diff --git a/meson.build b/meson.build
index 6250de545fd1..2450a51f99c4 100644
--- a/meson.build
+++ b/meson.build
@@ -2071,6 +2071,12 @@ if with_platform_wayland
     'linux-dmabuf', 'linux-dmabuf-unstable-v1.xml'
   )
   pre_args += '-DWL_HIDE_DEPRECATED'
+  if cc.has_function(
+      'wl_display_dispatch_queue_timeout',
+      prefix : '#include <wayland-client.h>',
+      dependencies: dep_wayland_client)
+    pre_args += ['-DHAVE_WL_DISPATCH_QUEUE_TIMEOUT']
+  endif
 endif
 
 dep_x11 = null_dep
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 7faeb43083c5..768b10d80abe 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -954,6 +954,89 @@ wsi_wl_swapchain_get_wsi_image(struct wsi_swapchain *wsi_chain,
    return &chain->images[image_index].base;
 }
 
+#ifndef HAVE_WL_DISPATCH_QUEUE_TIMEOUT
+static int
+wl_display_poll(struct wl_display *display,
+                short int events,
+                struct timespec *timeout)
+{
+   int ret;
+   struct pollfd pfd[1];
+
+   pfd[0].fd = wl_display_get_fd(display);
+   pfd[0].events = events;
+   do {
+      ret = ppoll(pfd, 1, timeout, NULL);
+   } while (ret == -1 && errno == EINTR);
+
+   if (ret == 0)
+      return -2;
+
+   return ret;
+}
+
+static int
+wl_display_dispatch_queue_timeout(struct wl_display *display,
+                                  struct wl_event_queue *queue,
+                                  struct timespec *timeout)
+{
+   int ret;
+   struct timespec now;
+   struct timespec target_time = {0};
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&target_time, &now, timeout);
+   }
+
+   if (wl_display_prepare_read_queue(display, queue) == -1)
+      return wl_display_dispatch_queue_pending(display, queue);
+
+   while (true) {
+      ret = wl_display_flush(display);
+
+      if (ret != -1 || errno != EAGAIN)
+         break;
+
+      ret = wl_display_poll(display, POLLOUT, timeout);
+
+      if (timeout) {
+         clock_gettime(CLOCK_MONOTONIC, &now);
+         timespec_sub_saturated(timeout, &target_time, &now);
+      }
+
+      if (ret < 0) {
+         wl_display_cancel_read(display);
+         return ret;
+      }
+   }
+
+   /* Don't stop if flushing hits an EPIPE; continue so we can read any
+    * protocol error that may have triggered it. */
+   if (ret < 0 && errno != EPIPE) {
+      wl_display_cancel_read(display);
+      return -1;
+   }
+
+   ret = wl_display_poll(display, POLLIN, timeout);
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_sub_saturated(timeout, &target_time, &now);
+   }
+
+   if (ret < 0) {
+      wl_display_cancel_read(display);
+      return ret;
+   }
+
+   if (wl_display_read_events(display) == -1)
+      return -1;
+
+   return wl_display_dispatch_queue_pending(display, queue);
+}
+#endif
+
 static VkResult
 wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
                                     const VkAcquireNextImageInfoKHR *info,
-- 
GitLab


From 0f0827c11e35af8c63776fa380a50ab62130bbe6 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 01:04:21 +0200
Subject: [PATCH 3/8] vulkan/wsi/wayland: Use dispatch_queue_timeout in
 acquire_next_image

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/vulkan/wsi/wsi_common_wayland.c | 64 ++++++-----------------------
 1 file changed, 13 insertions(+), 51 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 768b10d80abe..4781c0146b05 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -1043,22 +1043,15 @@ wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
                                     uint32_t *image_index)
 {
    struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
-   struct timespec start_time, end_time;
-   struct timespec rel_timeout;
-   int wl_fd = wl_display_get_fd(chain->display->wl_display);
+   struct timespec ts;
+   struct timespec *timeout = NULL;
 
-   timespec_from_nsec(&rel_timeout, info->timeout);
-
-   clock_gettime(CLOCK_MONOTONIC, &start_time);
-   timespec_add(&end_time, &rel_timeout, &start_time);
+   if (info->timeout > -1) {
+      timespec_from_nsec(&ts, info->timeout);
+      timeout = &ts;
+   }
 
    while (1) {
-      /* Try to dispatch potential events. */
-      int ret = wl_display_dispatch_queue_pending(chain->display->wl_display,
-                                                  chain->display->queue);
-      if (ret < 0)
-         return VK_ERROR_OUT_OF_DATE_KHR;
-
       /* Try to find a free image. */
       for (uint32_t i = 0; i < chain->base.image_count; i++) {
          if (!chain->images[i].busy) {
@@ -1069,46 +1062,15 @@ wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
          }
       }
 
-      /* Check for timeout. */
-      struct timespec current_time;
-      clock_gettime(CLOCK_MONOTONIC, &current_time);
-      if (timespec_after(&current_time, &end_time))
-         return VK_NOT_READY;
-
-      /* Try to read events from the server. */
-      ret = wl_display_prepare_read_queue(chain->display->wl_display,
-                                          chain->display->queue);
-      if (ret < 0) {
-         /* Another thread might have read events for our queue already. Go
-          * back to dispatch them.
-          */
-         if (errno == EAGAIN)
-            continue;
+      /* Try to dispatch potential events. */
+      int ret = wl_display_dispatch_queue_timeout(chain->display->wl_display,
+                                                  chain->display->queue,
+                                                  timeout);
+      if (ret == -1)
          return VK_ERROR_OUT_OF_DATE_KHR;
-      }
 
-      struct pollfd pollfd = {
-         .fd = wl_fd,
-         .events = POLLIN
-      };
-      timespec_sub(&rel_timeout, &end_time, &current_time);
-      ret = ppoll(&pollfd, 1, &rel_timeout, NULL);
-      if (ret <= 0) {
-         int lerrno = errno;
-         wl_display_cancel_read(chain->display->wl_display);
-         if (ret < 0) {
-            /* If ppoll() was interrupted, try again. */
-            if (lerrno == EINTR || lerrno == EAGAIN)
-               continue;
-            return VK_ERROR_OUT_OF_DATE_KHR;
-         }
-         assert(ret == 0);
-         continue;
-      }
-
-      ret = wl_display_read_events(chain->display->wl_display);
-      if (ret < 0)
-         return VK_ERROR_OUT_OF_DATE_KHR;
+      if (ret == -2)
+         return VK_NOT_READY;
    }
 }
 
-- 
GitLab


From cba360bab3accd4c4b1fbeb1bae33fbd3f64668f Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 1 Sep 2022 01:53:39 +0200
Subject: [PATCH 4/8] vulkan/wsi/wayland: Guarantee 1Hz progress for FIFO
 present mode

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/vulkan/wsi/wsi_common_wayland.c | 48 +++++++++++++++++++++++++----
 1 file changed, 42 insertions(+), 6 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 4781c0146b05..c6bfc18f4b03 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -940,6 +940,9 @@ struct wsi_wl_swapchain {
 
    VkPresentModeKHR                             present_mode;
    bool                                         fifo_ready;
+   struct timespec                              lowest_tick_rate;
+   struct timespec                              last_frame_callback;
+   struct timespec                              last_queue_present;
 
    struct wsi_wl_image                          images[0];
 };
@@ -1078,9 +1081,21 @@ static void
 frame_handle_done(void *data, struct wl_callback *callback, uint32_t serial)
 {
    struct wsi_wl_swapchain *chain = data;
+   struct timespec deadline;
+   struct timespec now;
 
    chain->frame = NULL;
-   chain->fifo_ready = true;
+
+   clock_gettime(CLOCK_MONOTONIC, &now);
+   timespec_add(&deadline,
+                &chain->last_frame_callback,
+                &chain->lowest_tick_rate);
+
+   if (!timespec_after(&now, &deadline))
+      chain->fifo_ready = true;
+
+   chain->last_frame_callback.tv_sec = now.tv_sec;
+   chain->last_frame_callback.tv_nsec = now.tv_nsec;
 
    wl_callback_destroy(callback);
 }
@@ -1102,11 +1117,24 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
              image->base.row_pitches[0] * chain->extent.height);
    }
    if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR) {
+      struct timespec deadline;
+      struct timespec now;
+      struct timespec timeout;
+
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&deadline,
+                   &chain->last_queue_present,
+                   &chain->lowest_tick_rate);
+      timespec_sub_saturated(&timeout, &deadline, &now);
+
       while (!chain->fifo_ready) {
-         int ret = wl_display_dispatch_queue(chain->display->wl_display,
-                                             chain->display->queue);
-         if (ret < 0)
+         int ret = wl_display_dispatch_queue_timeout(chain->display->wl_display,
+                                                     chain->display->queue,
+                                                     &timeout);
+         if (ret == -1)
             return VK_ERROR_OUT_OF_DATE_KHR;
+         if (ret == -2)
+            break;
       }
    }
 
@@ -1127,11 +1155,15 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
    }
 
    if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR) {
-      chain->frame = wl_surface_frame(chain->surface);
-      wl_callback_add_listener(chain->frame, &frame_listener, chain);
+      if (chain->frame == NULL) {
+         chain->frame = wl_surface_frame(chain->surface);
+         wl_callback_add_listener(chain->frame, &frame_listener, chain);
+      }
       chain->fifo_ready = false;
    }
 
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
+
    chain->images[image_index].busy = true;
    wl_surface_commit(chain->surface);
    wl_display_flush(chain->display->wl_display);
@@ -1390,6 +1422,10 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    }
 
    chain->fifo_ready = true;
+   chain->lowest_tick_rate.tv_sec = 1;
+   chain->lowest_tick_rate.tv_nsec = 0;
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_frame_callback);
+   clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
 
    switch (chain->buffer_type) {
    case WSI_WL_BUFFER_NATIVE:
-- 
GitLab


From bc5fb4cf4bd68281d79173c7635d1ae2e7613729 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sat, 3 Sep 2022 18:46:24 +0200
Subject: [PATCH 5/8] vulkan/wsi/wayland: Make the minimum FIFO frequency
 configurable

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/amd/vulkan/radv_device.c        |  1 +
 src/util/driconf.h                  |  4 ++++
 src/vulkan/wsi/wsi_common.c         |  2 +-
 src/vulkan/wsi/wsi_common_private.h |  3 ++-
 src/vulkan/wsi/wsi_common_wayland.c | 17 ++++++++++++++---
 5 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index c2b14c8082d3..26e5cfe6db91 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1042,6 +1042,7 @@ radv_get_perftest_option_name(int id)
 static const driOptionDescription radv_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_ADAPTIVE_SYNC(true)
+      DRI_CONF_WAYLAND_MIN_SYNC_FREQUENCY(1)
       DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
diff --git a/src/util/driconf.h b/src/util/driconf.h
index db095fdcd131..39e69d92a950 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -356,6 +356,10 @@
    DRI_CONF_OPT_B(adaptive_sync,def, \
                   "Adapt the monitor sync to the application performance (when possible)")
 
+#define DRI_CONF_WAYLAND_MIN_SYNC_FREQUENCY(def) \
+   DRI_CONF_OPT_I(wayland_min_sync_frequency, def, 1, 1000, \
+                  "Limit the blocking of vkQueuePresent/eglSwapBuffers to no more than 1/frequency (in Hz)")
+
 #define DRI_CONF_VK_WSI_FORCE_BGRA8_UNORM_FIRST(def) \
    DRI_CONF_OPT_B(vk_wsi_force_bgra8_unorm_first, def, \
                   "Force vkGetPhysicalDeviceSurfaceFormatsKHR to return VK_FORMAT_B8G8R8A8_UNORM as the first format")
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 1afee9917181..147a716e5e82 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -173,7 +173,7 @@ wsi_device_init(struct wsi_device *wsi,
 #endif
 
 #ifdef VK_USE_PLATFORM_WAYLAND_KHR
-   result = wsi_wl_init_wsi(wsi, alloc, pdevice);
+   result = wsi_wl_init_wsi(wsi, alloc, pdevice, dri_options);
    if (result != VK_SUCCESS)
       goto fail;
 #endif
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 04950982274c..4d97a97caa4a 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -277,7 +277,8 @@ void wsi_x11_finish_wsi(struct wsi_device *wsi_device,
                         const VkAllocationCallbacks *alloc);
 VkResult wsi_wl_init_wsi(struct wsi_device *wsi_device,
                          const VkAllocationCallbacks *alloc,
-                         VkPhysicalDevice physical_device);
+                         VkPhysicalDevice physical_device,
+                         const struct driOptionCache *dri_options);
 void wsi_wl_finish_wsi(struct wsi_device *wsi_device,
                        const VkAllocationCallbacks *alloc);
 VkResult wsi_win32_init_wsi(struct wsi_device *wsi_device,
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index c6bfc18f4b03..f67a70f5bd40 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -47,6 +47,7 @@
 #include <util/timespec.h>
 #include <util/u_vector.h>
 #include <util/anon_file.h>
+#include <util/xmlconfig.h>
 
 struct wsi_wayland;
 
@@ -81,6 +82,7 @@ struct wsi_wayland {
    struct wsi_interface                     base;
 
    struct wsi_device *wsi;
+   int min_sync_frequency;
 
    const VkAllocationCallbacks *alloc;
    VkPhysicalDevice physical_device;
@@ -1422,8 +1424,8 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    }
 
    chain->fifo_ready = true;
-   chain->lowest_tick_rate.tv_sec = 1;
-   chain->lowest_tick_rate.tv_nsec = 0;
+   timespec_from_nsec(&chain->lowest_tick_rate,
+                      (uint64_t)NSEC_PER_SEC / wsi->min_sync_frequency);
    clock_gettime(CLOCK_MONOTONIC, &chain->last_frame_callback);
    clock_gettime(CLOCK_MONOTONIC, &chain->last_queue_present);
 
@@ -1477,7 +1479,8 @@ fail:
 VkResult
 wsi_wl_init_wsi(struct wsi_device *wsi_device,
                 const VkAllocationCallbacks *alloc,
-                VkPhysicalDevice physical_device)
+                VkPhysicalDevice physical_device,
+                const struct driOptionCache *dri_options)
 {
    struct wsi_wayland *wsi;
    VkResult result;
@@ -1492,6 +1495,14 @@ wsi_wl_init_wsi(struct wsi_device *wsi_device,
    wsi->physical_device = physical_device;
    wsi->alloc = alloc;
    wsi->wsi = wsi_device;
+   wsi->min_sync_frequency = 1;
+
+   if (dri_options) {
+      if (driCheckOption(dri_options, "wayland_min_sync_frequency", DRI_INT)) {
+         wsi->min_sync_frequency =
+            driQueryOptioni(dri_options, "wayland_min_sync_frequency");
+      }
+   }
 
    wsi->base.get_support = wsi_wl_surface_get_support;
    wsi->base.get_capabilities2 = wsi_wl_surface_get_capabilities2;
-- 
GitLab


From 13e588c481dffe0f6875680180c87bb0bf1afedd Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sun, 11 Sep 2022 19:26:40 +0200
Subject: [PATCH 6/8] egl/wayland: Add fallback
 wl_display_dispatch_queue_timeout

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/egl/drivers/dri2/platform_wayland.c | 84 +++++++++++++++++++++++++
 1 file changed, 84 insertions(+)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index d536bdb0f9bf..386192a6a85c 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -38,6 +38,7 @@
 #include <xf86drm.h>
 #include "drm-uapi/drm_fourcc.h"
 #include <sys/mman.h>
+#include <poll.h>
 
 #include "egl_dri2.h"
 #include "loader_dri_helper.h"
@@ -1503,6 +1504,89 @@ try_damage_buffer(struct dri2_egl_surface *dri2_surf,
    return EGL_TRUE;
 }
 
+#ifndef HAVE_WL_DISPATCH_QUEUE_TIMEOUT
+static int
+wl_display_poll(struct wl_display *display,
+                short int events,
+                struct timespec *timeout)
+{
+   int ret;
+   struct pollfd pfd[1];
+
+   pfd[0].fd = wl_display_get_fd(display);
+   pfd[0].events = events;
+   do {
+      ret = ppoll(pfd, 1, timeout, NULL);
+   } while (ret == -1 && errno == EINTR);
+
+   if (ret == 0)
+      return -2;
+
+   return ret;
+}
+
+static int
+wl_display_dispatch_queue_timeout(struct wl_display *display,
+                                  struct wl_event_queue *queue,
+                                  struct timespec *timeout)
+{
+   int ret;
+   struct timespec now;
+   struct timespec target_time = {0};
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_add(&target_time, &now, timeout);
+   }
+
+   if (wl_display_prepare_read_queue(display, queue) == -1)
+      return wl_display_dispatch_queue_pending(display, queue);
+
+   while (true) {
+      ret = wl_display_flush(display);
+
+      if (ret != -1 || errno != EAGAIN)
+         break;
+
+      ret = wl_display_poll(display, POLLOUT, timeout);
+
+      if (timeout) {
+         clock_gettime(CLOCK_MONOTONIC, &now);
+         timespec_sub_saturated(timeout, &target_time, &now);
+      }
+
+      if (ret < 0) {
+         wl_display_cancel_read(display);
+         return ret;
+      }
+   }
+
+   /* Don't stop if flushing hits an EPIPE; continue so we can read any
+    * protocol error that may have triggered it. */
+   if (ret < 0 && errno != EPIPE) {
+      wl_display_cancel_read(display);
+      return -1;
+   }
+
+   ret = wl_display_poll(display, POLLIN, timeout);
+
+   if (timeout) {
+      clock_gettime(CLOCK_MONOTONIC, &now);
+      timespec_sub_saturated(timeout, &target_time, &now);
+   }
+
+   if (ret < 0) {
+      wl_display_cancel_read(display);
+      return ret;
+   }
+
+   if (wl_display_read_events(display) == -1)
+      return -1;
+
+   return wl_display_dispatch_queue_pending(display, queue);
+}
+#endif
+
 /**
  * Called via eglSwapBuffers(), drv->SwapBuffers().
  */
-- 
GitLab


From 0a2e4579daadd30a846478a9984a1170fc425877 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sun, 11 Sep 2022 19:15:37 +0200
Subject: [PATCH 7/8] egl/wayland: Guarantee 1Hz progress for SwapInterval > 0

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/egl/drivers/dri2/egl_dri2.h         |  4 +++
 src/egl/drivers/dri2/platform_wayland.c | 46 ++++++++++++++++++++++---
 2 files changed, 46 insertions(+), 4 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 2e283cba0e76..8a076c5c9fd5 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -336,6 +336,10 @@ struct dri2_egl_surface
    struct wl_display *wl_dpy_wrapper;
    struct wl_drm *wl_drm_wrapper;
    struct wl_callback *throttle_callback;
+   bool throttle_ready;
+   struct timespec last_throttle_callback;
+   struct timespec last_swap_buffers;
+   struct timespec lowest_tick_rate;
    struct zwp_linux_dmabuf_feedback_v1 *wl_dmabuf_feedback;
    struct dmabuf_feedback dmabuf_feedback, pending_dmabuf_feedback;
    bool compositor_using_another_device;
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 386192a6a85c..faef6682900d 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -47,6 +47,7 @@
 #include "util/anon_file.h"
 #include "eglglobals.h"
 #include "kopper_interface.h"
+#include "util/timespec.h"
 
 #include <wayland-egl-backend.h>
 #include <wayland-client.h>
@@ -750,6 +751,12 @@ dri2_wl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    dri2_surf->base.SwapInterval = dri2_dpy->default_swap_interval;
 
+   dri2_surf->throttle_ready = true;
+   timespec_from_nsec(&dri2_surf->lowest_tick_rate,
+                      (uint64_t)NSEC_PER_SEC / 1);
+   clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_throttle_callback);
+   clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_swap_buffers);
+
    return &dri2_surf->base;
 
  cleanup_dmabuf_feedback:
@@ -1316,8 +1323,22 @@ wayland_throttle_callback(void *data,
                           uint32_t time)
 {
    struct dri2_egl_surface *dri2_surf = data;
+   struct timespec deadline;
+   struct timespec now;
 
    dri2_surf->throttle_callback = NULL;
+
+   clock_gettime(CLOCK_MONOTONIC, &now);
+   timespec_add(&deadline,
+                &dri2_surf->last_throttle_callback,
+                &dri2_surf->lowest_tick_rate);
+
+   if (!timespec_after(&now, &deadline))
+      dri2_surf->throttle_ready = true;
+
+   dri2_surf->last_throttle_callback.tv_sec = now.tv_sec;
+   dri2_surf->last_throttle_callback.tv_nsec = now.tv_nsec;
+
    wl_callback_destroy(callback);
 }
 
@@ -1598,14 +1619,30 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
+   struct timespec deadline;
+   struct timespec now;
+   struct timespec timeout;
 
    if (!dri2_surf->wl_win)
       return _eglError(EGL_BAD_NATIVE_WINDOW, "dri2_swap_buffers");
 
-   while (dri2_surf->throttle_callback != NULL)
-      if (wl_display_dispatch_queue(dri2_dpy->wl_dpy,
-                                    dri2_surf->wl_queue) == -1)
+   clock_gettime(CLOCK_MONOTONIC, &now);
+   timespec_add(&deadline,
+                &dri2_surf->last_swap_buffers,
+                &dri2_surf->lowest_tick_rate);
+   timespec_sub_saturated(&timeout, &deadline, &now);
+
+   while (!dri2_surf->throttle_ready) {
+      int ret = wl_display_dispatch_queue_timeout(dri2_dpy->wl_dpy,
+                                                  dri2_surf->wl_queue,
+                                                  &timeout);
+      if (ret == -1)
          return -1;
+      if (ret == -2)
+         break;
+   }
+
+   clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_swap_buffers);
 
    for (int i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++)
       if (dri2_surf->color_buffers[i].age > 0)
@@ -1616,13 +1653,14 @@ dri2_wl_swap_buffers_with_damage(_EGLDisplay *disp,
    if (update_buffers_if_needed(dri2_surf) < 0)
       return _eglError(EGL_BAD_ALLOC, "dri2_swap_buffers");
 
-   if (draw->SwapInterval > 0) {
+   if (draw->SwapInterval > 0 && dri2_surf->throttle_callback == NULL) {
       dri2_surf->throttle_callback =
          wl_surface_frame(dri2_surf->wl_surface_wrapper);
       wl_callback_add_listener(dri2_surf->throttle_callback,
                                &throttle_listener, dri2_surf);
    }
 
+   dri2_surf->throttle_ready = false;
    dri2_surf->back->age = 1;
    dri2_surf->current = dri2_surf->back;
    dri2_surf->back = NULL;
-- 
GitLab


From 0816217bcad875a9005924f6d4b245e9689570dd Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Sun, 11 Sep 2022 21:51:16 +0200
Subject: [PATCH 8/8] egl/wayland: Make the minimum SwapBuffer frequency
 configurable

Signed-off-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/egl/drivers/dri2/egl_dri2.h         | 1 +
 src/egl/drivers/dri2/platform_wayland.c | 8 +++++++-
 src/gallium/frontends/dri/dri_util.c    | 1 +
 3 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 8a076c5c9fd5..fcee8d652932 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -293,6 +293,7 @@ struct dri2_egl_display
    bool authenticated;
    uint32_t capabilities;
    char *device_name;
+   int min_sync_frequency;
 #endif
 
 #ifdef HAVE_ANDROID_PLATFORM
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index faef6682900d..bc7ee8deb46e 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -753,7 +753,7 @@ dri2_wl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    dri2_surf->throttle_ready = true;
    timespec_from_nsec(&dri2_surf->lowest_tick_rate,
-                      (uint64_t)NSEC_PER_SEC / 1);
+                      (uint64_t)NSEC_PER_SEC / dri2_dpy->min_sync_frequency);
    clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_throttle_callback);
    clock_gettime(CLOCK_MONOTONIC, &dri2_surf->last_swap_buffers);
 
@@ -2332,6 +2332,12 @@ dri2_initialize_wayland_drm(_EGLDisplay *disp)
 
    dri2_wl_setup_swap_interval(disp);
 
+   dri2_dpy->min_sync_frequency = 1;
+   if (dri2_dpy->config)
+      dri2_dpy->config->configQueryi(dri2_dpy->dri_screen,
+                                     "wayland_min_sync_frequency",
+                                     &dri2_dpy->min_sync_frequency);
+
    if (dri2_dpy->wl_drm) {
       /* To use Prime, we must have _DRI_IMAGE v7 at least. createImageFromFds
        * support indicates that Prime export/import is supported by the driver.

