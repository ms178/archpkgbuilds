From 8bac92479562013cf81a9937d2722897a2d06bfe Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 13 Mar 2023 19:23:25 +0100
Subject: [PATCH 1/5] aco/opcodes: move v_cndmask_b32 back to the VOP2 list

---
 src/amd/compiler/aco_opcodes.py | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index 79e0033afab6..b81f93db996c 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -711,6 +711,7 @@ for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) in SMEM:
 # TODO: misses some GFX6_7 opcodes which were shifted to VOP3 in GFX8
 VOP2 = {
   # GFX6, GFX7, GFX8, GFX9, GFX10,GFX11,name, input modifiers, output modifiers
+   (0x00, 0x00, 0x00, 0x00, 0x01, 0x01, "v_cndmask_b32", True, False),
    (0x01, 0x01,   -1,   -1,   -1,   -1, "v_readlane_b32", False, False),
    (0x02, 0x02,   -1,   -1,   -1,   -1, "v_writelane_b32", False, False),
    (0x03, 0x03, 0x01, 0x01, 0x03, 0x03, "v_add_f32", True, True),
@@ -790,11 +791,6 @@ VOP2 = {
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, in_mod, out_mod) in VOP2:
    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP2, InstrClass.Valu32, in_mod, out_mod)
 
-if True:
-    # v_cndmask_b32 can use input modifiers but not output modifiers
-    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x00, 0x00, 0x00, 0x00, 0x01, 0x01, "v_cndmask_b32")
-    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP2, InstrClass.Valu32, True, False)
-
 
 # VOP1 instructions: instructions with 1 input and 1 output
 VOP1 = {
-- 
GitLab


From e56482f61d2577722acf26b432747671ccd13912 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 13 Mar 2023 20:05:26 +0100
Subject: [PATCH 2/5] aco: remove v_cvt_pkrtz_f16_f32_e64 when it's actually
 VOP2

More consistent with how we handle all the opcodes which were moved to VOP3.
---
 src/amd/compiler/aco_opcodes.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index b81f93db996c..7ea8e5c02ad1 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -1151,7 +1151,7 @@ VOP3 = {
    (0x11e, 0x11e, 0x293, 0x293, 0x363, 0x31d, "v_bfm_b32", False, False),
    (0x12d, 0x12d, 0x294, 0x294, 0x368, 0x321, "v_cvt_pknorm_i16_f32", True, False),
    (0x12e, 0x12e, 0x295, 0x295, 0x369, 0x322, "v_cvt_pknorm_u16_f32", True, False),
-   (0x12f, 0x12f, 0x296, 0x296, 0x12f, 0x12f, "v_cvt_pkrtz_f16_f32_e64", True, False), # GFX6_7_10_11 is VOP2 with opcode 0x02f
+   (   -1,    -1, 0x296, 0x296,    -1,    -1, "v_cvt_pkrtz_f16_f32_e64", True, False),
    (0x130, 0x130, 0x297, 0x297, 0x36a, 0x323, "v_cvt_pk_u16_u32", False, False),
    (0x131, 0x131, 0x298, 0x298, 0x36b, 0x324, "v_cvt_pk_i16_i32", False, False),
    (   -1,    -1,    -1, 0x299, 0x312, 0x312, "v_cvt_pknorm_i16_f16", True, False), #v_cvt_pk_norm_i16_f32 in GFX11
-- 
GitLab


From 4bc3d894bd636e8ce270775a65cbef8bad2f9e7f Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 13 Mar 2023 19:46:58 +0100
Subject: [PATCH 3/5] aco: add an opcode array for gfx8

There are a lot of new instructions on vega, and this allows us to remove
16bit legacy instruction.
---
 src/amd/compiler/aco_assembler.cpp  |   2 +
 src/amd/compiler/aco_ir.h           |   1 +
 src/amd/compiler/aco_opcodes.py     | 140 ++++++++++++++--------------
 src/amd/compiler/aco_opcodes_cpp.py |   5 +
 4 files changed, 79 insertions(+), 69 deletions(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index e6e3de055bd2..b2f320cace5d 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -53,6 +53,8 @@ struct asm_context {
    {
       if (gfx_level <= GFX7)
          opcode = &instr_info.opcode_gfx7[0];
+      else if (gfx_level <= GFX8)
+         opcode = &instr_info.opcode_gfx8[0];
       else if (gfx_level <= GFX9)
          opcode = &instr_info.opcode_gfx9[0];
       else if (gfx_level <= GFX10_3)
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index db2158e4ae82..f1d8398abd13 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2300,6 +2300,7 @@ uint16_t get_addr_vgpr_from_waves(Program* program, uint16_t max_waves);
 
 typedef struct {
    const int16_t opcode_gfx7[static_cast<int>(aco_opcode::num_opcodes)];
+   const int16_t opcode_gfx8[static_cast<int>(aco_opcode::num_opcodes)];
    const int16_t opcode_gfx9[static_cast<int>(aco_opcode::num_opcodes)];
    const int16_t opcode_gfx10[static_cast<int>(aco_opcode::num_opcodes)];
    const int16_t opcode_gfx11[static_cast<int>(aco_opcode::num_opcodes)];
diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index 7ea8e5c02ad1..b09144853090 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -199,7 +199,7 @@ class Opcode(object):
    """Class that represents all the information we have about the opcode
    NOTE: this must be kept in sync with aco_op_info
    """
-   def __init__(self, name, opcode_gfx7, opcode_gfx9, opcode_gfx10, opcode_gfx11, format, input_mod, output_mod, is_atomic, cls):
+   def __init__(self, name, opcode_gfx7, opcode_gfx8, opcode_gfx9, opcode_gfx10, opcode_gfx11, format, input_mod, output_mod, is_atomic, cls):
       """Parameters:
 
       - name is the name of the opcode (prepend nir_op_ for the enum name)
@@ -212,6 +212,7 @@ class Opcode(object):
       """
       assert isinstance(name, str)
       assert isinstance(opcode_gfx7, int)
+      assert isinstance(opcode_gfx8, int)
       assert isinstance(opcode_gfx9, int)
       assert isinstance(opcode_gfx10, int)
       assert isinstance(opcode_gfx11, int)
@@ -221,6 +222,7 @@ class Opcode(object):
 
       self.name = name
       self.opcode_gfx7 = opcode_gfx7
+      self.opcode_gfx8 = opcode_gfx8
       self.opcode_gfx9 = opcode_gfx9
       self.opcode_gfx10 = opcode_gfx10
       self.opcode_gfx11 = opcode_gfx11
@@ -260,9 +262,9 @@ class Opcode(object):
 # global dictionary of opcodes
 opcodes = {}
 
-def opcode(name, opcode_gfx7 = -1, opcode_gfx9 = -1, opcode_gfx10 = -1, opcode_gfx11 = -1, format = Format.PSEUDO, cls = InstrClass.Other, input_mod = False, output_mod = False, is_atomic = False):
+def opcode(name, opcode_gfx7 = -1, opcode_gfx8=-1, opcode_gfx9 = -1, opcode_gfx10 = -1, opcode_gfx11 = -1, format = Format.PSEUDO, cls = InstrClass.Other, input_mod = False, output_mod = False, is_atomic = False):
    assert name not in opcodes
-   opcodes[name] = Opcode(name, opcode_gfx7, opcode_gfx9, opcode_gfx10, opcode_gfx11, format, input_mod, output_mod, is_atomic, cls)
+   opcodes[name] = Opcode(name, opcode_gfx7, opcode_gfx8, opcode_gfx9, opcode_gfx10, opcode_gfx11, format, input_mod, output_mod, is_atomic, cls)
 
 def default_class(opcodes, cls):
    for op in opcodes:
@@ -271,7 +273,7 @@ def default_class(opcodes, cls):
       else:
          yield op + (cls,)
 
-opcode("exp", 0, 0, 0, 0, format = Format.EXP, cls = InstrClass.Export)
+opcode("exp", 0, 0, 0, 0, 0, Format.EXP, InstrClass.Export)
 opcode("p_parallelcopy")
 opcode("p_startpgm")
 opcode("p_phi")
@@ -416,7 +418,7 @@ SOP2 = {
    (  -1,   -1,   -1,   -1,   -1,   -1, "p_constaddr_addlo"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, cls) in default_class(SOP2, InstrClass.Salu):
-    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.SOP2, cls)
+    opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.SOP2, cls)
 
 
 # SOPK instructions: 0 input (+ imm), 1 output + optional scc
@@ -452,7 +454,7 @@ SOPK = {
    (  -1,   -1,   -1,   -1, 0x1c, 0x17, "s_subvector_loop_end", InstrClass.Branch),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, cls) in default_class(SOPK, InstrClass.Salu):
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.SOPK, cls)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.SOPK, cls)
 
 
 # SOP1 instructions: 1 input, 1 output (+optional SCC)
@@ -532,7 +534,7 @@ SOP1 = {
    (  -1,   -1,   -1,   -1,   -1,   -1, "p_constaddr_getpc"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, cls) in default_class(SOP1, InstrClass.Salu):
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.SOP1, cls)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.SOP1, cls)
 
 
 # SOPC instructions: 2 inputs and 0 outputs (+SCC)
@@ -560,7 +562,7 @@ SOPC = {
    (  -1,   -1, 0x13, 0x13, 0x13, 0x11, "s_cmp_lg_u64"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) in SOPC:
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.SOPC, InstrClass.Salu)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.SOPC, InstrClass.Salu)
 
 
 # SOPP instructions: 0 inputs (+optional scc/vcc), 0 outputs
@@ -609,7 +611,7 @@ SOPP = {
    (  -1,   -1,   -1,   -1,   -1, 0x0b, "s_wait_event"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, cls) in default_class(SOPP, InstrClass.Salu):
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.SOPP, cls)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.SOPP, cls)
 
 
 # SMEM instructions: sbase input (2 sgpr), potentially 2 offset inputs, 1 sdata input/output
@@ -704,7 +706,7 @@ SMEM = {
    (  -1,   -1,   -1, 0xac, 0xac,   -1, "s_atomic_dec_x2"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) in SMEM:
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.SMEM, InstrClass.SMem, is_atomic = "atomic" in name)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.SMEM, InstrClass.SMem, is_atomic = "atomic" in name)
 
 
 # VOP2 instructions: 2 inputs, 1 output (+ optional vcc)
@@ -789,7 +791,7 @@ VOP2 = {
    (  -1,   -1,   -1, 0x37, 0x02, 0x02, "v_dot2c_f32_f16", False, False), #v_dot2acc_f32_f16 in GFX11
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, in_mod, out_mod) in VOP2:
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP2, InstrClass.Valu32, in_mod, out_mod)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOP2, InstrClass.Valu32, in_mod, out_mod)
 
 
 # VOP1 instructions: instructions with 1 input and 1 output
@@ -894,7 +896,7 @@ VOP1 = {
    (  -1,   -1,   -1,   -1,   -1, 0x1c, "v_mov_b16", True, False),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, in_mod, out_mod, cls) in default_class(VOP1, InstrClass.Valu32):
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP1, cls, in_mod, out_mod)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOP1, cls, in_mod, out_mod)
 
 
 # VOPC instructions:
@@ -908,29 +910,29 @@ VOPC_CLASS = {
    (0xb8, 0xb8, 0x13, 0x13, 0xb8, 0xff, "v_cmpx_class_f64", InstrClass.ValuDouble),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, cls) in default_class(VOPC_CLASS, InstrClass.Valu32):
-    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, cls, True, False)
+    opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, cls, True, False)
 
 COMPF = ["f", "lt", "eq", "le", "gt", "lg", "ge", "o", "u", "nge", "nlg", "ngt", "nle", "neq", "nlt", "tru"]
 
 for i in range(8):
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0x20+i, 0x20+i, 0xc8+i, 0x00+i, "v_cmp_"+COMPF[i]+"_f16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0x30+i, 0x30+i, 0xd8+i, 0x80+i, "v_cmpx_"+COMPF[i]+"_f16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0x28+i, 0x28+i, 0xe8+i, 0x08+i, "v_cmp_"+COMPF[i+8]+"_f16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0x38+i, 0x38+i, 0xf8+i, 0x88+i, "v_cmpx_"+COMPF[i+8]+"_f16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
 
 for i in range(16):
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x00+i, 0x00+i, 0x40+i, 0x40+i, 0x00+i, 0x10+i, "v_cmp_"+COMPF[i]+"_f32")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x10+i, 0x10+i, 0x50+i, 0x50+i, 0x10+i, 0x90+i, "v_cmpx_"+COMPF[i]+"_f32")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32, True, False)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x20+i, 0x20+i, 0x60+i, 0x60+i, 0x20+i, 0x20+i, "v_cmp_"+COMPF[i]+"_f64")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.ValuDouble, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.ValuDouble, True, False)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x30+i, 0x30+i, 0x70+i, 0x70+i, 0x30+i, 0xa0+i, "v_cmpx_"+COMPF[i]+"_f64")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.ValuDouble, True, False)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.ValuDouble, True, False)
    # GFX_6_7
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x40+i, 0x40+i, -1, -1, -1, -1, "v_cmps_"+COMPF[i]+"_f32")
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x50+i, 0x50+i, -1, -1, -1, -1, "v_cmpsx_"+COMPF[i]+"_f32")
@@ -942,41 +944,41 @@ COMPI = ["f", "lt", "eq", "le", "gt", "lg", "ge", "tru"]
 # GFX_8_9
 for i in [0,7]: # only 0 and 7
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xa0+i, 0xa0+i, -1, -1, "v_cmp_"+COMPI[i]+"_i16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xb0+i, 0xb0+i, -1, -1, "v_cmpx_"+COMPI[i]+"_i16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xa8+i, 0xa8+i, -1, -1, "v_cmp_"+COMPI[i]+"_u16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xb8+i, 0xb8+i, -1, -1, "v_cmpx_"+COMPI[i]+"_u16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
 
 for i in range(1, 7): # [1..6]
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xa0+i, 0xa0+i, 0x88+i, 0x30+i, "v_cmp_"+COMPI[i]+"_i16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xb0+i, 0xb0+i, 0x98+i, 0xb0+i, "v_cmpx_"+COMPI[i]+"_i16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xa8+i, 0xa8+i, 0xa8+i, 0x38+i, "v_cmp_"+COMPI[i]+"_u16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, 0xb8+i, 0xb8+i, 0xb8+i, 0xb8+i, "v_cmpx_"+COMPI[i]+"_u16")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
 
 for i in range(8):
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x80+i, 0x80+i, 0xc0+i, 0xc0+i, 0x80+i, 0x40+i, "v_cmp_"+COMPI[i]+"_i32")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0x90+i, 0x90+i, 0xd0+i, 0xd0+i, 0x90+i, 0xc0+i, "v_cmpx_"+COMPI[i]+"_i32")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0xa0+i, 0xa0+i, 0xe0+i, 0xe0+i, 0xa0+i, 0x50+i, "v_cmp_"+COMPI[i]+"_i64")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0xb0+i, 0xb0+i, 0xf0+i, 0xf0+i, 0xb0+i, 0xd0+i, "v_cmpx_"+COMPI[i]+"_i64")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0xc0+i, 0xc0+i, 0xc8+i, 0xc8+i, 0xc0+i, 0x48+i, "v_cmp_"+COMPI[i]+"_u32")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0xd0+i, 0xd0+i, 0xd8+i, 0xd8+i, 0xd0+i, 0xc8+i, "v_cmpx_"+COMPI[i]+"_u32")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu32)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0xe0+i, 0xe0+i, 0xe8+i, 0xe8+i, 0xe0+i, 0x58+i, "v_cmp_"+COMPI[i]+"_u64")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
    (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (0xf0+i, 0xf0+i, 0xf8+i, 0xf8+i, 0xf0+i, 0xd8+i, "v_cmpx_"+COMPI[i]+"_u64")
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOPC, InstrClass.Valu64)
 
 
 # VOPP instructions: packed 16bit instructions - 1 or 2 inputs and 1 output
@@ -1008,16 +1010,16 @@ VOPP = {
 # note that these are only supported on gfx9+ so we'll need to distinguish between gfx8 and gfx9 here
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, -1, code, code, code, name)
 for (code, name, modifiers) in VOPP:
-   opcode(name, -1, code, code, code, Format.VOP3P, InstrClass.Valu32, modifiers, modifiers)
-opcode("v_dot2_i32_i16", -1, 0x26, 0x14, -1, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot2_u32_u16", -1, 0x27, 0x15, -1, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot4_i32_iu8", -1, -1, -1, 0x16, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot4_i32_i8", -1, 0x28, 0x16, -1, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot4_u32_u8", -1, 0x29, 0x17, 0x17, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot8_i32_iu4", -1, -1, -1, 0x18, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot8_u32_u4", -1, 0x2b, 0x19, 0x19, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot2_f32_f16", -1, 0x23, 0x13, 0x13, Format.VOP3P, InstrClass.Valu32)
-opcode("v_dot2_f32_bf16", -1, -1, -1, 0x1a, Format.VOP3P, InstrClass.Valu32)
+   opcode(name, -1, -1, code, code, code, Format.VOP3P, InstrClass.Valu32, modifiers, modifiers)
+opcode("v_dot2_i32_i16", -1, -1, 0x26, 0x14, -1, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot2_u32_u16", -1, -1, 0x27, 0x15, -1, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot4_i32_iu8", -1, -1, -1, -1, 0x16, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot4_i32_i8", -1, -1, 0x28, 0x16, -1, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot4_u32_u8", -1, -1, 0x29, 0x17, 0x17, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot8_i32_iu4", -1, -1, -1, -1, 0x18, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot8_u32_u4", -1, -1, 0x2b, 0x19, 0x19, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot2_f32_f16", -1, -1, 0x23, 0x13, 0x13, Format.VOP3P, InstrClass.Valu32)
+opcode("v_dot2_f32_bf16", -1, -1, -1, -1, 0x1a, Format.VOP3P, InstrClass.Valu32)
 
 
 # VINTRP (GFX6 - GFX10.3) instructions:
@@ -1028,7 +1030,7 @@ VINTRP = {
 }
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (code, code, code, code, code, code, name)
 for (code, name) in VINTRP:
-   opcode(name, code, code, code, -1, Format.VINTRP, InstrClass.Valu32)
+   opcode(name, code, code, code, code, -1, Format.VINTRP, InstrClass.Valu32)
 
 
 # VINTERP (GFX11+) instructions:
@@ -1041,7 +1043,7 @@ VINTERP = {
    (0x05, "v_interp_p2_rtz_f16_f32_inreg"),
 }
 for (code, name) in VINTERP:
-   opcode(name, -1, -1, -1, code, Format.VINTERP_INREG, InstrClass.Valu32)
+   opcode(name, -1, -1, -1, -1, code, Format.VINTERP_INREG, InstrClass.Valu32)
 
 
 # VOP3 instructions: 3 inputs, 1 output
@@ -1196,7 +1198,7 @@ VOP3 = {
    (   -1,    -1,    -1,    -1,    -1, 0x25d, "v_cndmask_b16", True, False),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, in_mod, out_mod, cls) in default_class(VOP3, InstrClass.Valu32):
-   opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP3, cls, in_mod, out_mod)
+   opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.VOP3, cls, in_mod, out_mod)
 
 
 # DS instructions: 3 inputs (1 addr, 2 data), 1 output
@@ -1360,7 +1362,7 @@ DS = {
    (  -1,   -1,   -1,   -1,   -1, 0x7b, "ds_sub_gs_reg_rtn"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) in DS:
-    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.DS, InstrClass.DS)
+    opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.DS, InstrClass.DS)
 
 
 # LDSDIR instructions:
@@ -1369,7 +1371,7 @@ LDSDIR = {
    (0x01, "lds_direct_load"),
 }
 for (code, name) in LDSDIR:
-    opcode(name, -1, -1, -1, code, Format.LDSDIR, InstrClass.DS)
+    opcode(name, -1, -1, -1, -1, code, Format.LDSDIR, InstrClass.DS)
 
 # MUBUF instructions:
 MUBUF = {
@@ -1462,7 +1464,7 @@ MUBUF = {
    (  -1,   -1,   -1,   -1,   -1, 0x56, "buffer_atomic_add_f32"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) in MUBUF:
-    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.MUBUF, InstrClass.VMem, is_atomic = "atomic" in name)
+    opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.MUBUF, InstrClass.VMem, is_atomic = "atomic" in name)
 
 MTBUF = {
    (0x00, 0x00, 0x00, 0x00, 0x00, 0x00, "tbuffer_load_format_x"),
@@ -1483,7 +1485,7 @@ MTBUF = {
    (  -1,   -1, 0x0f, 0x0f, 0x0f, 0x0f, "tbuffer_store_format_d16_xyzw"),
 }
 for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) in MTBUF:
-    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.MTBUF, InstrClass.VMem)
+    opcode(name, gfx7, gfx8, gfx9, gfx10, gfx11, Format.MTBUF, InstrClass.VMem)
 
 
 IMAGE = {
@@ -1502,9 +1504,9 @@ IMAGE = {
 }
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (code, code, code, code, code, name)
 for (code, gfx11, name) in IMAGE:
-   opcode(name, code, code, code, gfx11, Format.MIMG, InstrClass.VMem)
+   opcode(name, code, code, code, code, gfx11, Format.MIMG, InstrClass.VMem)
 
-opcode("image_msaa_load", -1, -1, 0x80, 0x18, Format.MIMG, InstrClass.VMem) #GFX10.3+
+opcode("image_msaa_load", -1, -1, -1, 0x80, 0x18, Format.MIMG, InstrClass.VMem) #GFX10.3+
 
 IMAGE_ATOMIC = {
    (0x0f, 0x0f, 0x10, 0x0a, "image_atomic_swap"),
@@ -1528,7 +1530,7 @@ IMAGE_ATOMIC = {
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (gfx6, gfx7, gfx89, gfx89, ???, gfx11, name)
 # gfx7 and gfx10 opcodes are the same here
 for (gfx6, gfx7, gfx89, gfx11, name) in IMAGE_ATOMIC:
-   opcode(name, gfx7, gfx89, gfx7, gfx11, Format.MIMG, InstrClass.VMem, is_atomic = True)
+   opcode(name, gfx7, gfx89, gfx89, gfx7, gfx11, Format.MIMG, InstrClass.VMem, is_atomic = True)
 
 IMAGE_SAMPLE = {
    (0x20, 0x1b, "image_sample"),
@@ -1574,7 +1576,7 @@ IMAGE_SAMPLE = {
 }
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (code, code, code, code, code, gfx11, name)
 for (code, gfx11, name) in IMAGE_SAMPLE:
-   opcode(name, code, code, code, gfx11, Format.MIMG, InstrClass.VMem)
+   opcode(name, code, code, code, code, gfx11, Format.MIMG, InstrClass.VMem)
 
 IMAGE_SAMPLE_G16 = {
    (0xa2, 0x39, "image_sample_d_g16"),
@@ -1589,7 +1591,7 @@ IMAGE_SAMPLE_G16 = {
 
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (-1, -1, -1, -1, code, gfx11, name)
 for (code, gfx11, name) in IMAGE_SAMPLE_G16:
-   opcode(name, -1, -1, code, gfx11, Format.MIMG, InstrClass.VMem)
+   opcode(name, -1, -1, -1, code, gfx11, Format.MIMG, InstrClass.VMem)
 
 IMAGE_GATHER4 = {
    (0x40, 0x2f, "image_gather4"),
@@ -1622,10 +1624,10 @@ IMAGE_GATHER4 = {
 }
 # (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name) = (code, code, code, code, code, gfx11, name)
 for (code, gfx11, name) in IMAGE_GATHER4:
-   opcode(name, code, code, code, gfx11, Format.MIMG, InstrClass.VMem)
+   opcode(name, code, code, code, code, gfx11, Format.MIMG, InstrClass.VMem)
 
-opcode("image_bvh_intersect_ray", -1, -1, 0xe6, 0x19, Format.MIMG, InstrClass.VMem)
-opcode("image_bvh64_intersect_ray", -1, -1, 0xe7, 0x1a, Format.MIMG, InstrClass.VMem)
+opcode("image_bvh_intersect_ray", -1, -1, -1, 0xe6, 0x19, Format.MIMG, InstrClass.VMem)
+opcode("image_bvh64_intersect_ray", -1, -1, -1, 0xe7, 0x1a, Format.MIMG, InstrClass.VMem)
 
 FLAT = {
    #GFX7, GFX89,GFX10,GFX11
@@ -1686,10 +1688,10 @@ FLAT = {
    (  -1,   -1,   -1, 0x56, "flat_atomic_add_f32"),
 }
 for (gfx7, gfx8, gfx10, gfx11, name) in FLAT:
-    opcode(name, gfx7, gfx8, gfx10, gfx11, Format.FLAT, InstrClass.VMem, is_atomic = "atomic" in name) #TODO: also LDS?
+    opcode(name, gfx7, gfx8, gfx8, gfx10, gfx11, Format.FLAT, InstrClass.VMem, is_atomic = "atomic" in name) #TODO: also LDS?
 
 GLOBAL = {
-   #GFX89,GFX10,GFX11
+   #GFX9,GFX10,GFX11
    (0x10, 0x08, 0x10, "global_load_ubyte"),
    (0x11, 0x09, 0x11, "global_load_sbyte"),
    (0x12, 0x0a, 0x12, "global_load_ushort"),
@@ -1749,11 +1751,11 @@ GLOBAL = {
    (  -1, 0x34, 0x37, "global_atomic_csub"), #GFX10.3+. seems glc must be set
    (  -1,   -1, 0x56, "global_atomic_add_f32"),
 }
-for (gfx8, gfx10, gfx11, name) in GLOBAL:
-    opcode(name, -1, gfx8, gfx10, gfx11, Format.GLOBAL, InstrClass.VMem, is_atomic = "atomic" in name)
+for (gfx9, gfx10, gfx11, name) in GLOBAL:
+    opcode(name, -1, -1, gfx9, gfx10, gfx11, Format.GLOBAL, InstrClass.VMem, is_atomic = "atomic" in name)
 
 SCRATCH = {
-   #GFX89,GFX10,GFX11
+   #GFX9,GFX10,GFX11
    (0x10, 0x08, 0x10, "scratch_load_ubyte"),
    (0x11, 0x09, 0x11, "scratch_load_sbyte"),
    (0x12, 0x0a, 0x12, "scratch_load_ushort"),
@@ -1777,8 +1779,8 @@ SCRATCH = {
    (0x24, 0x24, 0x20, "scratch_load_short_d16"),
    (0x25, 0x25, 0x23, "scratch_load_short_d16_hi"),
 }
-for (gfx8, gfx10, gfx11, name) in SCRATCH:
-    opcode(name, -1, gfx8, gfx10, gfx11, Format.SCRATCH, InstrClass.VMem)
+for (gfx9, gfx10, gfx11, name) in SCRATCH:
+    opcode(name, -1, -1, gfx9, gfx10, gfx11, Format.SCRATCH, InstrClass.VMem)
 
 # check for duplicate opcode numbers
 for ver in ['gfx9', 'gfx10', 'gfx11']:
diff --git a/src/amd/compiler/aco_opcodes_cpp.py b/src/amd/compiler/aco_opcodes_cpp.py
index a0e5e9f407b0..6696273c9ca7 100644
--- a/src/amd/compiler/aco_opcodes_cpp.py
+++ b/src/amd/compiler/aco_opcodes_cpp.py
@@ -42,6 +42,11 @@ extern const aco::Info instr_info = {
       ${opcodes[name].opcode_gfx7},
       % endfor
    },
+   {
+      % for name in opcode_names:
+      ${opcodes[name].opcode_gfx8},
+      % endfor
+   },
    {
       % for name in opcode_names:
       ${opcodes[name].opcode_gfx9},
-- 
GitLab


From e84198eb603960411d4c92ff69f51482b14565e8 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 19 Mar 2023 14:04:59 +0100
Subject: [PATCH 4/5] aco: remove gfx8 legacy 16bit special cases

Legacy 16bt instructions zero the msbs, but on gfx8 that is the only option.
We can use legacy encoding for the non legacy opcodes on gfx8, instr_is_16bit
and can_use_opsel already handle the difference.

Keep the legacy opcodes in aco_opcodes.py as documentation.
---
 .../compiler/aco_instruction_selection.cpp    | 11 +++------
 src/amd/compiler/aco_opcodes.py               | 24 +++++++++----------
 src/amd/compiler/aco_optimizer.cpp            | 19 ++++-----------
 src/amd/compiler/aco_register_allocation.cpp  |  5 ++--
 4 files changed, 21 insertions(+), 38 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 2e09da8b00a0..3c374ad04230 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5376,18 +5376,13 @@ emit_interp_instr(isel_context* ctx, unsigned idx, unsigned component, Temp src,
                        bld.m0(prim_mask), idx, component);
          interp_p1 = bld.vintrp(aco_opcode::v_interp_p1lv_f16, bld.def(v2b), coord1,
                                 bld.m0(prim_mask), interp_p1, idx, component);
-         bld.vintrp(aco_opcode::v_interp_p2_legacy_f16, Definition(dst), coord2, bld.m0(prim_mask),
+         bld.vintrp(aco_opcode::v_interp_p2_f16, Definition(dst), coord2, bld.m0(prim_mask),
                     interp_p1, idx, component);
       } else {
-         aco_opcode interp_p2_op = aco_opcode::v_interp_p2_f16;
-
-         if (ctx->options->gfx_level == GFX8)
-            interp_p2_op = aco_opcode::v_interp_p2_legacy_f16;
-
          Builder::Result interp_p1 = bld.vintrp(aco_opcode::v_interp_p1ll_f16, bld.def(v1), coord1,
                                                 bld.m0(prim_mask), idx, component);
-         bld.vintrp(interp_p2_op, Definition(dst), coord2, bld.m0(prim_mask), interp_p1, idx,
-                    component);
+         bld.vintrp(aco_opcode::v_interp_p2_f16, Definition(dst), coord2, bld.m0(prim_mask),
+                    interp_p1, idx, component);
       }
    } else {
       Builder::Result interp_p1 = bld.vintrp(aco_opcode::v_interp_p1_f32, bld.def(v1), coord1,
diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index b09144853090..d1a99d7d7399 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -1107,12 +1107,7 @@ VOP3 = {
    (   -1, 0x175, 0x1e7, 0x1e7, 0x175, 0x23d, "v_mqsad_u32_u8", False, False),
    (   -1, 0x176, 0x1e8, 0x1e8, 0x176, 0x2fe, "v_mad_u64_u32", False, False, InstrClass.Valu64),
    (   -1, 0x177, 0x1e9, 0x1e9, 0x177, 0x2ff, "v_mad_i64_i32", False, False, InstrClass.Valu64),
-   (   -1,    -1, 0x1ea, 0x1ea,    -1,    -1, "v_mad_legacy_f16", True, True),
-   (   -1,    -1, 0x1eb, 0x1eb,    -1,    -1, "v_mad_legacy_u16", False, False),
-   (   -1,    -1, 0x1ec, 0x1ec,    -1,    -1, "v_mad_legacy_i16", False, False),
    (   -1,    -1, 0x1ed, 0x1ed, 0x344, 0x244, "v_perm_b32", False, False),
-   (   -1,    -1, 0x1ee, 0x1ee,    -1,    -1, "v_fma_legacy_f16", True, True, InstrClass.ValuFma),
-   (   -1,    -1, 0x1ef, 0x1ef,    -1,    -1, "v_div_fixup_legacy_f16", True, True),
    (0x12c, 0x12c, 0x1f0, 0x1f0,    -1,    -1, "v_cvt_pkaccum_u8_f32", True, False),
    (   -1,    -1,    -1, 0x1f1, 0x373, 0x259, "v_mad_u32_u16", False, False),
    (   -1,    -1,    -1, 0x1f2, 0x375, 0x25a, "v_mad_i32_i16", False, False),
@@ -1132,15 +1127,20 @@ VOP3 = {
    (   -1,    -1,    -1, 0x200, 0x36f, 0x256, "v_lshl_or_b32", False, False),
    (   -1,    -1,    -1, 0x201, 0x371, 0x257, "v_and_or_b32", False, False),
    (   -1,    -1,    -1, 0x202, 0x372, 0x258, "v_or3_b32", False, False),
-   (   -1,    -1,    -1, 0x203,    -1,    -1, "v_mad_f16", True, True),
-   (   -1,    -1,    -1, 0x204, 0x340, 0x241, "v_mad_u16", False, False),
-   (   -1,    -1,    -1, 0x205, 0x35e, 0x253, "v_mad_i16", False, False),
-   (   -1,    -1,    -1, 0x206, 0x34b, 0x248, "v_fma_f16", True, True),
-   (   -1,    -1,    -1, 0x207, 0x35f, 0x254, "v_div_fixup_f16", True, True),
+   (   -1,    -1, 0x1ea, 0x203,    -1,    -1, "v_mad_f16", True, True),
+   (   -1,    -1, 0x1eb, 0x204, 0x340, 0x241, "v_mad_u16", False, False),
+   (   -1,    -1, 0x1ec, 0x205, 0x35e, 0x253, "v_mad_i16", False, False),
+   (   -1,    -1, 0x1ee, 0x206, 0x34b, 0x248, "v_fma_f16", True, True),
+   (   -1,    -1, 0x1ef, 0x207, 0x35f, 0x254, "v_div_fixup_f16", True, True),
    (   -1,    -1, 0x274, 0x274, 0x342,    -1, "v_interp_p1ll_f16", True, True),
    (   -1,    -1, 0x275, 0x275, 0x343,    -1, "v_interp_p1lv_f16", True, True),
-   (   -1,    -1, 0x276, 0x276,    -1,    -1, "v_interp_p2_legacy_f16", True, True),
-   (   -1,    -1,    -1, 0x277, 0x35a,    -1, "v_interp_p2_f16", True, True),
+   (   -1,    -1, 0x276, 0x277, 0x35a,    -1, "v_interp_p2_f16", True, True),
+   (   -1,    -1, 0x276, 0x276,    -1,    -1, "v_interp_p2_legacy_f16", True, True), # On GFX9 legacy 16bit opcodes zero the
+   (   -1,    -1, 0x1ea, 0x1ea,    -1,    -1, "v_mad_legacy_f16", True, True),       # msbs while non legacy preserve them.
+   (   -1,    -1, 0x1eb, 0x1eb,    -1,    -1, "v_mad_legacy_u16", False, False),     # GFX8 only has legacy 16bit, so we use
+   (   -1,    -1, 0x1ec, 0x1ec,    -1,    -1, "v_mad_legacy_i16", False, False),     # the same encoding for both opcodes.
+   (   -1,    -1, 0x1ee, 0x1ee,    -1,    -1, "v_fma_legacy_f16", True, True, InstrClass.ValuFma),
+   (   -1,    -1, 0x1ef, 0x1ef,    -1,    -1, "v_div_fixup_legacy_f16", True, True),
    (0x12b, 0x12b, 0x288, 0x288, 0x362, 0x31c, "v_ldexp_f32", False, True),
    (   -1,    -1, 0x289, 0x289, 0x360, 0x360, "v_readlane_b32_e64", False, False),
    (   -1,    -1, 0x28a, 0x28a, 0x361, 0x361, "v_writelane_b32_e64", False, False),
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 4c4cb5faaebb..a548a97601d0 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4335,10 +4335,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                assert(emit_fma == (ctx.program->gfx_level >= GFX10_3));
                mad_op = emit_fma ? aco_opcode::v_fma_legacy_f32 : aco_opcode::v_mad_legacy_f32;
             } else if (mad16) {
-               mad_op = emit_fma ? (ctx.program->gfx_level == GFX8 ? aco_opcode::v_fma_legacy_f16
-                                                                   : aco_opcode::v_fma_f16)
-                                 : (ctx.program->gfx_level == GFX8 ? aco_opcode::v_mad_legacy_f16
-                                                                   : aco_opcode::v_mad_f16);
+               mad_op = emit_fma ? aco_opcode::v_fma_f16 : aco_opcode::v_mad_f16;
             } else if (mad64) {
                mad_op = aco_opcode::v_fma_f64;
             }
@@ -4408,10 +4405,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
       combine_not_xor(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_add_u16) {
-      combine_three_valu_op(
-         ctx, instr, aco_opcode::v_mul_lo_u16,
-         ctx.program->gfx_level == GFX8 ? aco_opcode::v_mad_legacy_u16 : aco_opcode::v_mad_u16,
-         "120", 1 | 2);
+      combine_three_valu_op(ctx, instr, aco_opcode::v_mul_lo_u16, aco_opcode::v_mad_u16, "120",
+                            1 | 2);
    } else if (instr->opcode == aco_opcode::v_add_u16_e64) {
       combine_three_valu_op(ctx, instr, aco_opcode::v_mul_lo_u16_e64, aco_opcode::v_mad_u16, "120",
                             1 | 2);
@@ -4646,11 +4641,6 @@ select_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          if ((instr->opcode == aco_opcode::v_fma_f32 || instr->opcode == aco_opcode::v_fma_f16) &&
              ctx.program->gfx_level < GFX10)
             return;
-         /* There are no v_fmaak_legacy_f16/v_fmamk_legacy_f16 and on chips where VOP3 can take
-          * literals (GFX10+), these instructions don't exist.
-          */
-         if (instr->opcode == aco_opcode::v_fma_legacy_f16)
-            return;
 
          uint32_t literal_mask = 0;
          uint32_t fp16_mask = 0;
@@ -5097,8 +5087,7 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          aco_opcode new_op = madak ? aco_opcode::v_madak_f32 : aco_opcode::v_madmk_f32;
          if (instr->opcode == aco_opcode::v_fma_f32)
             new_op = madak ? aco_opcode::v_fmaak_f32 : aco_opcode::v_fmamk_f32;
-         else if (instr->opcode == aco_opcode::v_mad_f16 ||
-                  instr->opcode == aco_opcode::v_mad_legacy_f16)
+         else if (instr->opcode == aco_opcode::v_mad_f16)
             new_op = madak ? aco_opcode::v_madak_f16 : aco_opcode::v_madmk_f16;
          else if (instr->opcode == aco_opcode::v_fma_f16)
             new_op = madak ? aco_opcode::v_fmaak_f16 : aco_opcode::v_fmamk_f16;
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index ca9b87024199..4eb19cb76fbd 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2600,7 +2600,7 @@ optimize_encoding_vop2(Program* program, ra_ctx& ctx, RegisterFile& register_fil
    /* try to optimize v_mad_f32 -> v_mac_f32 */
    if ((instr->opcode != aco_opcode::v_mad_f32 &&
         (instr->opcode != aco_opcode::v_fma_f32 || program->gfx_level < GFX10) &&
-        instr->opcode != aco_opcode::v_mad_f16 && instr->opcode != aco_opcode::v_mad_legacy_f16 &&
+        instr->opcode != aco_opcode::v_mad_f16 &&
         (instr->opcode != aco_opcode::v_fma_f16 || program->gfx_level < GFX10) &&
         (instr->opcode != aco_opcode::v_pk_fma_f16 || program->gfx_level < GFX10) &&
         (instr->opcode != aco_opcode::v_mad_legacy_f32 || !program->dev.has_mac_legacy32) &&
@@ -2630,8 +2630,7 @@ optimize_encoding_vop2(Program* program, ra_ctx& ctx, RegisterFile& register_fil
    switch (instr->opcode) {
    case aco_opcode::v_mad_f32: instr->opcode = aco_opcode::v_mac_f32; break;
    case aco_opcode::v_fma_f32: instr->opcode = aco_opcode::v_fmac_f32; break;
-   case aco_opcode::v_mad_f16:
-   case aco_opcode::v_mad_legacy_f16: instr->opcode = aco_opcode::v_mac_f16; break;
+   case aco_opcode::v_mad_f16: instr->opcode = aco_opcode::v_mac_f16; break;
    case aco_opcode::v_fma_f16: instr->opcode = aco_opcode::v_fmac_f16; break;
    case aco_opcode::v_pk_fma_f16: instr->opcode = aco_opcode::v_pk_fmac_f16; break;
    case aco_opcode::v_dot4_i32_i8: instr->opcode = aco_opcode::v_dot4c_i32_i8; break;
-- 
GitLab


From 18c7a702c4d22c9ae656021587c167885bc0b5bb Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 22 Apr 2023 13:40:58 +0200
Subject: [PATCH 5/5] aco/opcodes: delete wrong comment copy pasted from NIR

---
 src/amd/compiler/aco_opcodes.py | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index d1a99d7d7399..5da77b79fe24 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -200,16 +200,6 @@ class Opcode(object):
    NOTE: this must be kept in sync with aco_op_info
    """
    def __init__(self, name, opcode_gfx7, opcode_gfx8, opcode_gfx9, opcode_gfx10, opcode_gfx11, format, input_mod, output_mod, is_atomic, cls):
-      """Parameters:
-
-      - name is the name of the opcode (prepend nir_op_ for the enum name)
-      - all types are strings that get nir_type_ prepended to them
-      - input_types is a list of types
-      - algebraic_properties is a space-separated string, where nir_op_is_ is
-        prepended before each entry
-      - const_expr is an expression or series of statements that computes the
-        constant value of the opcode given the constant values of its inputs.
-      """
       assert isinstance(name, str)
       assert isinstance(opcode_gfx7, int)
       assert isinstance(opcode_gfx8, int)
-- 
GitLab

