From d019225d453799a2a6973e44bd9848884f580216 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 6 Feb 2023 13:54:04 +0100
Subject: [PATCH 1/5] radv: cleanup graphics pipeline library flags uses

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 33 +++++++++++++++------------------
 1 file changed, 15 insertions(+), 18 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 75d3aef68c43..49f59c76f0ff 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -5010,6 +5010,7 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
                             const VkGraphicsPipelineCreateInfo *pCreateInfo,
                             const struct radv_graphics_pipeline_create_info *extra)
 {
+   VkGraphicsPipelineLibraryFlagBitsEXT lib_flags = ALL_GRAPHICS_LIB_FLAGS;
    bool fast_linking_enabled = radv_is_fast_linking_enabled(pCreateInfo);
    struct radv_pipeline_layout pipeline_layout;
    struct vk_graphics_pipeline_state state = {0};
@@ -5019,7 +5020,6 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
 
    const VkPipelineLibraryCreateInfoKHR *libs_info =
       vk_find_struct_const(pCreateInfo->pNext, PIPELINE_LIBRARY_CREATE_INFO_KHR);
-   VkGraphicsPipelineLibraryFlagBitsEXT imported_flags = 0;
 
    radv_pipeline_layout_init(device, &pipeline_layout, false);
 
@@ -5043,13 +5043,13 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
          radv_graphics_pipeline_import_lib(pipeline, &state, &pipeline_layout, gfx_pipeline_lib,
                                            link_optimize);
 
-         imported_flags |= gfx_pipeline_lib->lib_flags;
+         lib_flags &= ~gfx_pipeline_lib->lib_flags;
       }
    }
 
    /* Import graphics pipeline info that was not included in the libraries. */
    result = radv_pipeline_import_graphics_info(pipeline, &state, &pipeline_layout, pCreateInfo,
-                                               (~imported_flags) & ALL_GRAPHICS_LIB_FLAGS);
+                                               lib_flags);
    if (result != VK_SUCCESS) {
       radv_pipeline_layout_finish(device, &pipeline_layout);
       return result;
@@ -5059,14 +5059,12 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
       radv_pipeline_layout_hash(&pipeline_layout);
 
 
-   if (!radv_skip_graphics_pipeline_compile(pipeline, (~imported_flags) & ALL_GRAPHICS_LIB_FLAGS,
-                                            fast_linking_enabled)) {
+   if (!radv_skip_graphics_pipeline_compile(pipeline, lib_flags, fast_linking_enabled)) {
       struct radv_pipeline_key key = radv_generate_graphics_pipeline_key(
-         pipeline, pCreateInfo, &state, (~imported_flags) & ALL_GRAPHICS_LIB_FLAGS);
+         pipeline, pCreateInfo, &state, lib_flags);
 
       result = radv_graphics_pipeline_compile(pipeline, pCreateInfo, &pipeline_layout, device, cache,
-                                              &key, (~imported_flags) & ALL_GRAPHICS_LIB_FLAGS,
-                                              fast_linking_enabled);
+                                              &key, lib_flags, fast_linking_enabled);
       if (result != VK_SUCCESS) {
          radv_pipeline_layout_finish(device, &pipeline_layout);
          return result;
@@ -5211,11 +5209,10 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
 
    const VkGraphicsPipelineLibraryCreateInfoEXT *lib_info =
       vk_find_struct_const(pCreateInfo->pNext, GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT);
-   const VkGraphicsPipelineLibraryFlagBitsEXT lib_flags = lib_info ? lib_info->flags : 0;
+   VkGraphicsPipelineLibraryFlagBitsEXT lib_flags = lib_info ? lib_info->flags : 0;
    const VkPipelineLibraryCreateInfoKHR *libs_info =
       vk_find_struct_const(pCreateInfo->pNext, PIPELINE_LIBRARY_CREATE_INFO_KHR);
    bool fast_linking_enabled = radv_is_fast_linking_enabled(pCreateInfo);
-   VkGraphicsPipelineLibraryFlagBitsEXT imported_flags = lib_flags;
 
    struct vk_graphics_pipeline_state *state = &pipeline->graphics_state;
    struct radv_pipeline_layout *pipeline_layout = &pipeline->layout;
@@ -5242,12 +5239,12 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
 
          pipeline->lib_flags |= gfx_pipeline_lib->lib_flags;
 
-         imported_flags &= ~gfx_pipeline_lib->lib_flags;
+         lib_flags &= ~gfx_pipeline_lib->lib_flags;
       }
    }
 
    result = radv_pipeline_import_graphics_info(&pipeline->base, state, pipeline_layout, pCreateInfo,
-                                               imported_flags);
+                                               lib_flags);
    if (result != VK_SUCCESS)
       return result;
 
@@ -5257,8 +5254,8 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
    /* Compile a PS epilog if the fragment shader output interface is present without the main
     * fragment shader.
     */
-   if ((imported_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT) &&
-       !(imported_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
+   if ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT) &&
+       !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
        !radv_pipeline_needs_dynamic_ps_epilog(&pipeline->base)) {
       struct radv_ps_epilog_key key = radv_pipeline_generate_ps_epilog_key(&pipeline->base, state, true);
 
@@ -5268,17 +5265,17 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
    }
 
    if (pipeline->base.active_stages != 0 ||
-       (imported_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT)) {
+       (lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT)) {
       struct radv_pipeline_key key =
-         radv_generate_graphics_pipeline_key(&pipeline->base, pCreateInfo, state, imported_flags);
+         radv_generate_graphics_pipeline_key(&pipeline->base, pCreateInfo, state, lib_flags);
 
       result = radv_graphics_pipeline_compile(&pipeline->base, pCreateInfo, pipeline_layout, device,
-                                              cache, &key, imported_flags, fast_linking_enabled);
+                                              cache, &key, lib_flags, fast_linking_enabled);
       if (result != VK_SUCCESS)
          return result;
 
       /* Force add the fragment shader stage when a noop FS has been compiled. */
-      if ((imported_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
+      if ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
           !(pipeline->base.active_stages & VK_SHADER_STAGE_FRAGMENT_BIT)) {
          assert(pipeline->base.base.shaders[MESA_SHADER_FRAGMENT]);
          pipeline->base.active_stages |= VK_SHADER_STAGE_FRAGMENT_BIT;
-- 
GitLab


From 0befd3acad26724f035e05d9fe638080cf822320 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 6 Feb 2023 16:02:45 +0100
Subject: [PATCH 2/5] radv: simplify determining when the fragment shader needs
 an epilog

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 49f59c76f0ff..737232212cb2 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2412,15 +2412,15 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
    if (radv_pipeline_needs_dynamic_ps_epilog(pipeline))
       key.ps.dynamic_ps_epilog = true;
 
+   /* The fragment shader needs an epilog when:
+    * - it's compiled without the fragment output interface with GPL
+    * - it's compiled on-demand because some dynamic states are enabled
+    */
    key.ps.has_epilog =
-      (!!(pipeline->active_stages & VK_SHADER_STAGE_FRAGMENT_BIT) && !!pipeline->ps_epilog) ||
-      key.ps.dynamic_ps_epilog;
-
-   /* Compile the main FS only when the fragment shader output interface is missing. */
-   if ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
-       !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT)) {
-      key.ps.has_epilog = true;
-   }
+      (pipeline->active_stages & VK_SHADER_STAGE_FRAGMENT_BIT) &&
+      (((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
+       !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT)) ||
+       key.ps.dynamic_ps_epilog);
 
    key.dynamic_patch_control_points =
       !!(pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS);
-- 
GitLab


From 74faabab1198f8c8991791c4c6a090683cdd548e Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 6 Feb 2023 16:25:15 +0100
Subject: [PATCH 3/5] radv: regroup PS epilog info when generating the graphics
 pipeline key

No logical change.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 737232212cb2..0287e45e786c 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2372,8 +2372,6 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
       }
    }
 
-   key.ps.epilog = radv_pipeline_generate_ps_epilog_key(pipeline, state, pipeline->ps_epilog);
-
    if (device->physical_device->rad_info.gfx_level >= GFX11 && state->ms) {
       key.ps.alpha_to_coverage_via_mrtz = state->ms->alpha_to_coverage_enable;
    }
@@ -2422,6 +2420,8 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
        !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT)) ||
        key.ps.dynamic_ps_epilog);
 
+   key.ps.epilog = radv_pipeline_generate_ps_epilog_key(pipeline, state, pipeline->ps_epilog);
+
    key.dynamic_patch_control_points =
       !!(pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS);
 
-- 
GitLab


From 9ac5f6b3db5b21bea77ceaa9af09b36319064833 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 6 Feb 2023 16:29:05 +0100
Subject: [PATCH 4/5] radv: fix disabling MRT compaction for on-demand PS
 epilogs

Some dynamic states require to compile PS epilogs on-demand. In this
case, MRT compaction should be disabled because we don't know the CB
state when compiling the fragment shader.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 0287e45e786c..21cfc450a91e 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2420,7 +2420,7 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
        !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT)) ||
        key.ps.dynamic_ps_epilog);
 
-   key.ps.epilog = radv_pipeline_generate_ps_epilog_key(pipeline, state, pipeline->ps_epilog);
+   key.ps.epilog = radv_pipeline_generate_ps_epilog_key(pipeline, state, key.ps.has_epilog);
 
    key.dynamic_patch_control_points =
       !!(pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS);
-- 
GitLab


From af4bf6bf628452fb6cfec3002a5ed13cfa2f216f Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 6 Feb 2023 14:46:40 +0100
Subject: [PATCH 5/5] radv: simplify creating a FS epilog from a library

It's now compiled in radv_graphics_pipeline_compile().

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 75 +++++++++++++++++-----------------
 1 file changed, 38 insertions(+), 37 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 21cfc450a91e..580771138ea7 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2420,7 +2420,14 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
        !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT)) ||
        key.ps.dynamic_ps_epilog);
 
-   key.ps.epilog = radv_pipeline_generate_ps_epilog_key(pipeline, state, key.ps.has_epilog);
+   /* Disable MRT compaction when it's not possible to know both the written color outputs and the
+    * color blend attachments.
+    */
+   bool disable_mrt_compaction = key.ps.has_epilog ||
+      ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT) &&
+       !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT));
+
+   key.ps.epilog = radv_pipeline_generate_ps_epilog_key(pipeline, state, disable_mrt_compaction);
 
    key.dynamic_patch_control_points =
       !!(pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS);
@@ -3399,16 +3406,29 @@ radv_postprocess_nir(struct radv_pipeline *pipeline,
 
 static bool
 radv_pipeline_create_ps_epilog(struct radv_graphics_pipeline *pipeline,
-                               const struct radv_pipeline_key *pipeline_key)
+                               const struct radv_pipeline_key *pipeline_key,
+                               VkGraphicsPipelineLibraryFlagBitsEXT lib_flags,
+                               bool noop_fs)
 {
    struct radv_device *device = pipeline->base.device;
+   bool needs_ps_epilog = false;
 
    /* Do not compile a PS epilog as part of the pipeline when it needs to be dynamic. */
    if (pipeline_key->ps.dynamic_ps_epilog)
       return true;
 
-   if (pipeline->base.shaders[MESA_SHADER_FRAGMENT] &&
-       pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.has_epilog && !pipeline->ps_epilog) {
+   if (pipeline->base.type == RADV_PIPELINE_GRAPHICS) {
+      needs_ps_epilog = !noop_fs && pipeline->base.shaders[MESA_SHADER_FRAGMENT] &&
+                        pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.has_epilog &&
+                        !pipeline->ps_epilog;
+   } else {
+      assert(pipeline->base.type == RADV_PIPELINE_GRAPHICS_LIB);
+      needs_ps_epilog =
+         (lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT) &&
+         !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT);
+   }
+
+   if (needs_ps_epilog) {
       pipeline->ps_epilog = radv_create_ps_epilog(device, &pipeline_key->ps.epilog);
       if (!pipeline->ps_epilog)
          return false;
@@ -3657,6 +3677,9 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
    radv_pipeline_nir_to_asm(pipeline, stages, pipeline_key, pipeline_layout, keep_executable_info,
                             keep_statistic_info, binaries, &gs_copy_binary);
 
+   if (!radv_pipeline_create_ps_epilog(pipeline, pipeline_key, lib_flags, noop_fs))
+      return result;
+
    if (keep_executable_info) {
       for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; ++i) {
          struct radv_shader *shader = pipeline->base.shaders[i];
@@ -3679,12 +3702,6 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
          /* Discard the PS epilog when the pipeline doesn't use a FS because it makes no sense. */
          radv_shader_part_unref(device, graphics_pipeline->ps_epilog);
          graphics_pipeline->ps_epilog = NULL;
-      } else {
-         /* When the main FS is compiled inside a library, we need to compile a PS epilog if it
-          * hasn't been already imported.
-          */
-         if (!radv_pipeline_create_ps_epilog(graphics_pipeline, pipeline_key))
-            return result;
       }
    }
 
@@ -5251,35 +5268,19 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
    if (!fast_linking_enabled)
       radv_pipeline_layout_hash(pipeline_layout);
 
-   /* Compile a PS epilog if the fragment shader output interface is present without the main
-    * fragment shader.
-    */
-   if ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT) &&
-       !(lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
-       !radv_pipeline_needs_dynamic_ps_epilog(&pipeline->base)) {
-      struct radv_ps_epilog_key key = radv_pipeline_generate_ps_epilog_key(&pipeline->base, state, true);
-
-      pipeline->base.ps_epilog = radv_create_ps_epilog(device, &key);
-      if (!pipeline->base.ps_epilog)
-         return VK_ERROR_OUT_OF_HOST_MEMORY;
-   }
-
-   if (pipeline->base.active_stages != 0 ||
-       (lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT)) {
-      struct radv_pipeline_key key =
-         radv_generate_graphics_pipeline_key(&pipeline->base, pCreateInfo, state, lib_flags);
+   struct radv_pipeline_key key =
+      radv_generate_graphics_pipeline_key(&pipeline->base, pCreateInfo, state, lib_flags);
 
-      result = radv_graphics_pipeline_compile(&pipeline->base, pCreateInfo, pipeline_layout, device,
-                                              cache, &key, lib_flags, fast_linking_enabled);
-      if (result != VK_SUCCESS)
-         return result;
+   result = radv_graphics_pipeline_compile(&pipeline->base, pCreateInfo, pipeline_layout, device,
+                                           cache, &key, lib_flags, fast_linking_enabled);
+   if (result != VK_SUCCESS)
+      return result;
 
-      /* Force add the fragment shader stage when a noop FS has been compiled. */
-      if ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
-          !(pipeline->base.active_stages & VK_SHADER_STAGE_FRAGMENT_BIT)) {
-         assert(pipeline->base.base.shaders[MESA_SHADER_FRAGMENT]);
-         pipeline->base.active_stages |= VK_SHADER_STAGE_FRAGMENT_BIT;
-      }
+   /* Force add the fragment shader stage when a noop FS has been compiled. */
+   if ((lib_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT) &&
+       !(pipeline->base.active_stages & VK_SHADER_STAGE_FRAGMENT_BIT)) {
+      assert(pipeline->base.base.shaders[MESA_SHADER_FRAGMENT]);
+      pipeline->base.active_stages |= VK_SHADER_STAGE_FRAGMENT_BIT;
    }
 
    return VK_SUCCESS;
-- 
GitLab

