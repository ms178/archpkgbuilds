From f3edfeb41c3be4e55b3cc2e13a9f9045f6da142f Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Wed, 4 Oct 2023 16:51:05 +0200
Subject: [PATCH 1/4] frontends/va: Parse H264 SPS for max_num_reorder_frames

Reviewed-by: Ruijing Dong <ruijing.dong@amd.com>
---
 src/gallium/frontends/va/picture_h264_enc.c | 48 +++++++++++++++++++++
 src/gallium/include/pipe/p_video_state.h    |  1 +
 2 files changed, 49 insertions(+)

diff --git a/src/gallium/frontends/va/picture_h264_enc.c b/src/gallium/frontends/va/picture_h264_enc.c
index 48403b17e7832..87b427b0ec534 100644
--- a/src/gallium/frontends/va/picture_h264_enc.c
+++ b/src/gallium/frontends/va/picture_h264_enc.c
@@ -325,9 +325,28 @@ vlVaHandleVAEncMiscParameterTypeFrameRateH264(vlVaContext *context, VAEncMiscPar
    return VA_STATUS_SUCCESS;
 }
 
+static void parseEncHrdParamsH264(struct vl_rbsp *rbsp)
+{
+   unsigned i, cpb_cnt_minus1;
+
+   cpb_cnt_minus1 = vl_rbsp_ue(rbsp);
+   vl_rbsp_u(rbsp, 4); /* bit_rate_scale */
+   vl_rbsp_u(rbsp, 4); /* cpb_size_scale */
+   for (i = 0; i <= cpb_cnt_minus1; ++i) {
+      vl_rbsp_ue(rbsp); /* bit_rate_value_minus1[i] */
+      vl_rbsp_ue(rbsp); /* cpb_size_value_minus1[i] */
+      vl_rbsp_u(rbsp, 1); /* cbr_flag[i] */
+   }
+   vl_rbsp_u(rbsp, 5); /* initial_cpb_removal_delay_length_minus1 */
+   vl_rbsp_u(rbsp, 5); /* cpb_removal_delay_length_minus1 */
+   vl_rbsp_u(rbsp, 5); /* dpb_output_delay_length_minus1 */
+   vl_rbsp_u(rbsp, 5); /* time_offset_length */
+}
+
 static void parseEncSpsParamsH264(vlVaContext *context, struct vl_rbsp *rbsp)
 {
    unsigned i, profile_idc, num_ref_frames_in_pic_order_cnt_cycle;
+   unsigned nal_hrd_parameters_present_flag, vcl_hrd_parameters_present_flag;
 
    profile_idc = vl_rbsp_u(rbsp, 8);
 
@@ -412,6 +431,35 @@ static void parseEncSpsParamsH264(vlVaContext *context, struct vl_rbsp *rbsp)
          context->desc.h264enc.seq.chroma_sample_loc_type_top_field = vl_rbsp_ue(rbsp);
          context->desc.h264enc.seq.chroma_sample_loc_type_bottom_field = vl_rbsp_ue(rbsp);
       }
+
+      if (vl_rbsp_u(rbsp, 1)) { /* timing_info_present_flag */
+         vl_rbsp_u(rbsp, 32); /* num_units_in_tick */
+         vl_rbsp_u(rbsp, 32); /* time_scale */
+         vl_rbsp_u(rbsp, 1); /* fixed_frame_rate_flag */
+      }
+
+      nal_hrd_parameters_present_flag = vl_rbsp_u(rbsp, 1);
+      if (nal_hrd_parameters_present_flag)
+         parseEncHrdParamsH264(rbsp);
+
+      vcl_hrd_parameters_present_flag = vl_rbsp_u(rbsp, 1);
+      if (vcl_hrd_parameters_present_flag)
+         parseEncHrdParamsH264(rbsp);
+
+      if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag)
+         vl_rbsp_u(rbsp, 1); /* low_delay_hrd_flag */
+
+      vl_rbsp_u(rbsp, 1); /* pic_struct_present_flag */
+
+      if (vl_rbsp_u(rbsp, 1)) { /* bitstream_restriction_flag */
+         vl_rbsp_u(rbsp, 1); /* motion_vectors_over_pic_boundaries_flag */
+         vl_rbsp_ue(rbsp); /* max_bytes_per_pic_denom */
+         vl_rbsp_ue(rbsp); /* max_bits_per_mb_denom */
+         vl_rbsp_ue(rbsp); /* log2_max_mv_length_horizontal */
+         vl_rbsp_ue(rbsp); /* log2_max_mv_length_vertical */
+         context->desc.h264enc.seq.max_num_reorder_frames = vl_rbsp_ue(rbsp);
+         vl_rbsp_ue(rbsp); /* max_dec_frame_buffering */
+      }
    }
 }
 
diff --git a/src/gallium/include/pipe/p_video_state.h b/src/gallium/include/pipe/p_video_state.h
index c3fe4371256a8..9cb34c55aa03a 100644
--- a/src/gallium/include/pipe/p_video_state.h
+++ b/src/gallium/include/pipe/p_video_state.h
@@ -528,6 +528,7 @@ struct pipe_h264_enc_seq_param
    uint32_t matrix_coefficients;
    uint32_t chroma_sample_loc_type_top_field;
    uint32_t chroma_sample_loc_type_bottom_field;
+   uint32_t max_num_reorder_frames;
 };
 
 struct pipe_h264_enc_picture_desc
-- 
GitLab


From e471a8375ff1a6fac4b4ef6dfebabc85a91cd90d Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Thu, 5 Oct 2023 16:41:33 +0200
Subject: [PATCH 2/4] util/vl: Fix vl_rbsp parser with bitstreams without
 emulation bytes

This is used for parsing VA packed headers and those can be without
emulation prevention bytes.
Add emulation_bytes argument to vl_rbsp_init and skip all emulation
bytes handling when set.

Reviewed-by: Ruijing Dong <ruijing.dong@amd.com>
---
 .../frontends/omx/bellagio/vid_dec_h265.c     |  6 +++---
 .../frontends/omx/vid_dec_h264_common.c       |  6 +++---
 src/gallium/frontends/va/picture_h264_enc.c   |  2 +-
 src/gallium/frontends/va/picture_hevc_enc.c   |  2 +-
 src/util/vl_rbsp.h                            | 19 ++++++++++++++-----
 src/vulkan/runtime/vk_video.c                 |  2 +-
 6 files changed, 23 insertions(+), 14 deletions(-)

diff --git a/src/gallium/frontends/omx/bellagio/vid_dec_h265.c b/src/gallium/frontends/omx/bellagio/vid_dec_h265.c
index 68ee619b54690..322c1aaafa2b8 100644
--- a/src/gallium/frontends/omx/bellagio/vid_dec_h265.c
+++ b/src/gallium/frontends/omx/bellagio/vid_dec_h265.c
@@ -958,13 +958,13 @@ static void vid_dec_h265_Decode(vid_dec_PrivateType *priv,
    if (nal_unit_type == NAL_UNIT_TYPE_SPS) {
       struct vl_rbsp rbsp;
 
-      vl_rbsp_init(&rbsp, vlc, ~0);
+      vl_rbsp_init(&rbsp, vlc, ~0, /* emulation_bytes */ true);
       seq_parameter_set(priv, &rbsp);
 
    } else if (nal_unit_type == NAL_UNIT_TYPE_PPS) {
       struct vl_rbsp rbsp;
 
-      vl_rbsp_init(&rbsp, vlc, ~0);
+      vl_rbsp_init(&rbsp, vlc, ~0, /* emulation_bytes */ true);
       picture_parameter_set(priv, &rbsp);
 
    } else if (is_slice_picture(nal_unit_type)) {
@@ -986,7 +986,7 @@ static void vid_dec_h265_Decode(vid_dec_PrivateType *priv,
       priv->bytes_left = (vl_vlc_bits_left(vlc) - bits) / 8;
       priv->slice = vlc->data;
 
-      vl_rbsp_init(&rbsp, vlc, 128);
+      vl_rbsp_init(&rbsp, vlc, 128, /* emulation_bytes */ true);
       slice_header(priv, &rbsp, nal_unit_type);
 
       vid_dec_h265_BeginFrame(priv);
diff --git a/src/gallium/frontends/omx/vid_dec_h264_common.c b/src/gallium/frontends/omx/vid_dec_h264_common.c
index 1412ef560b555..fcf5c99d644d6 100644
--- a/src/gallium/frontends/omx/vid_dec_h264_common.c
+++ b/src/gallium/frontends/omx/vid_dec_h264_common.c
@@ -1002,7 +1002,7 @@ void vid_dec_h264_Decode(vid_dec_PrivateType *priv, struct vl_vlc *vlc, unsigned
 
    if (nal_unit_type == 7) {
       struct vl_rbsp rbsp;
-      vl_rbsp_init(&rbsp, vlc, ~0);
+      vl_rbsp_init(&rbsp, vlc, ~0, /* emulation_bytes */ true);
       seq_parameter_set(priv, &rbsp);
 #if ENABLE_ST_OMX_TIZONIA
       update_port_parameters(priv);
@@ -1010,7 +1010,7 @@ void vid_dec_h264_Decode(vid_dec_PrivateType *priv, struct vl_vlc *vlc, unsigned
 
    } else if (nal_unit_type == 8) {
       struct vl_rbsp rbsp;
-      vl_rbsp_init(&rbsp, vlc, ~0);
+      vl_rbsp_init(&rbsp, vlc, ~0, /* emulation_bytes */ true);
       picture_parameter_set(priv, &rbsp);
 
    } else if (nal_unit_type == 1 || nal_unit_type == 5) {
@@ -1032,7 +1032,7 @@ void vid_dec_h264_Decode(vid_dec_PrivateType *priv, struct vl_vlc *vlc, unsigned
       priv->bytes_left = (vl_vlc_bits_left(vlc) - bits) / 8;
       priv->slice = vlc->data;
 
-      vl_rbsp_init(&rbsp, vlc, 128);
+      vl_rbsp_init(&rbsp, vlc, 128, /* emulation_bytes */ true);
       slice_header(priv, &rbsp, nal_ref_idc, nal_unit_type);
 
       vid_dec_h264_BeginFrame(priv);
diff --git a/src/gallium/frontends/va/picture_h264_enc.c b/src/gallium/frontends/va/picture_h264_enc.c
index 87b427b0ec534..c12ee99a36973 100644
--- a/src/gallium/frontends/va/picture_h264_enc.c
+++ b/src/gallium/frontends/va/picture_h264_enc.c
@@ -486,7 +486,7 @@ vlVaHandleVAEncPackedHeaderDataBufferTypeH264(vlVaContext *context, vlVaBuffer *
       unsigned nal_unit_type = vl_vlc_get_uimsbf(&vlc, 5);
 
       struct vl_rbsp rbsp;
-      vl_rbsp_init(&rbsp, &vlc, ~0);
+      vl_rbsp_init(&rbsp, &vlc, ~0, true);
 
       switch(nal_unit_type) {
       case H264_NAL_SPS:
diff --git a/src/gallium/frontends/va/picture_hevc_enc.c b/src/gallium/frontends/va/picture_hevc_enc.c
index ae9a74715a784..860404c925bd1 100644
--- a/src/gallium/frontends/va/picture_hevc_enc.c
+++ b/src/gallium/frontends/va/picture_hevc_enc.c
@@ -465,7 +465,7 @@ vlVaHandleVAEncPackedHeaderDataBufferTypeHEVC(vlVaContext *context, vlVaBuffer *
       vl_vlc_eatbits(&vlc, 3);
 
       struct vl_rbsp rbsp;
-      vl_rbsp_init(&rbsp, &vlc, ~0);
+      vl_rbsp_init(&rbsp, &vlc, ~0, true);
 
       switch(nal_unit_type) {
       case HEVC_NAL_SPS:
diff --git a/src/util/vl_rbsp.h b/src/util/vl_rbsp.h
index c2d9b2b5c33a8..0842b0f14908b 100644
--- a/src/util/vl_rbsp.h
+++ b/src/util/vl_rbsp.h
@@ -44,12 +44,14 @@ struct vl_rbsp {
    struct vl_vlc nal;
    unsigned escaped;
    unsigned removed;
+   bool emulation_bytes;
 };
 
 /**
  * Initialize the RBSP object
  */
-static inline void vl_rbsp_init(struct vl_rbsp *rbsp, struct vl_vlc *nal, unsigned num_bits)
+static inline void vl_rbsp_init(struct vl_rbsp *rbsp, struct vl_vlc *nal, unsigned num_bits,
+                                bool emulation_bytes)
 {
    unsigned valid, bits_left = vl_vlc_bits_left(nal);
    int i;
@@ -57,6 +59,13 @@ static inline void vl_rbsp_init(struct vl_rbsp *rbsp, struct vl_vlc *nal, unsign
    /* copy the position */
    rbsp->nal = *nal;
 
+   rbsp->escaped = 0;
+   rbsp->removed = 0;
+   rbsp->emulation_bytes = emulation_bytes;
+
+   if (!rbsp->emulation_bytes)
+      return;
+
    /* search for the end of the NAL unit */
    while (vl_vlc_search_byte(nal, num_bits, 0x00)) {
       if (vl_vlc_peekbits(nal, 24) == 0x000001 ||
@@ -79,7 +88,6 @@ static inline void vl_rbsp_init(struct vl_rbsp *rbsp, struct vl_vlc *nal, unsign
    valid = vl_vlc_valid_bits(&rbsp->nal);
 
    rbsp->escaped = (valid >= 16) ? 16 : ((valid >= 8) ? 8 : 0);
-   rbsp->removed = 0;
 }
 
 /**
@@ -96,13 +104,14 @@ static inline void vl_rbsp_fillbits(struct vl_rbsp *rbsp)
 
    vl_vlc_fillbits(&rbsp->nal);
 
+   /* nothing to do if no emulation prevention bytes in bitstream */
+   if (!rbsp->emulation_bytes)
+      return;
+
    /* abort if we have less than 24 bits left in this nal */
    if (vl_vlc_bits_left(&rbsp->nal) < 24)
       return;
 
-   /* check that we have enough bits left from the last fillbits */
-   assert(valid >= rbsp->escaped);
-
    /* handle the already escaped bits */
    valid -= rbsp->escaped;
 
diff --git a/src/vulkan/runtime/vk_video.c b/src/vulkan/runtime/vk_video.c
index 0e90f18ae905f..16a684bfcd54c 100644
--- a/src/vulkan/runtime/vk_video.c
+++ b/src/vulkan/runtime/vk_video.c
@@ -723,7 +723,7 @@ vk_video_parse_h265_slice_header(const struct VkVideoDecodeInfoKHR *frame_info,
    vl_vlc_get_uimsbf(&vlc, 3); /* nuh_temporal_id_plus1 */
 
    struct vl_rbsp rbsp;
-   vl_rbsp_init(&rbsp, &vlc, 128);
+   vl_rbsp_init(&rbsp, &vlc, 128, /* emulation_bytes */ true);
 
    memset(params, 0, sizeof(*params));
 
-- 
GitLab


From 954b17db33a37a80a4331c63e4544050e38157ae Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Thu, 5 Oct 2023 16:47:21 +0200
Subject: [PATCH 3/4] frontends/va: Fix parsing packed headers without
 emulation bytes

Don't try to handle emulation bytes and only parse first NAL unit
if the packed header has no emulation bytes.

This fixes parsing packed headers from gstreamer.

Reviewed-by: Ruijing Dong <ruijing.dong@amd.com>
---
 src/gallium/frontends/va/picture.c          | 2 ++
 src/gallium/frontends/va/picture_h264_enc.c | 5 ++++-
 src/gallium/frontends/va/picture_hevc_enc.c | 5 ++++-
 src/gallium/frontends/va/va_private.h       | 1 +
 4 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/src/gallium/frontends/va/picture.c b/src/gallium/frontends/va/picture.c
index 6bd799e606c85..330ff8dde471b 100644
--- a/src/gallium/frontends/va/picture.c
+++ b/src/gallium/frontends/va/picture.c
@@ -737,6 +737,8 @@ handleVAEncPackedHeaderParameterBufferType(vlVaContext *context, vlVaBuffer *buf
    VAStatus status = VA_STATUS_SUCCESS;
    VAEncPackedHeaderParameterBuffer *param = buf->data;
 
+   context->packed_header_emulation_bytes = param->has_emulation_bytes;
+
    switch (u_reduce_video_profile(context->templat.profile)) {
    case PIPE_VIDEO_FORMAT_MPEG4_AVC:
       if (param->type == VAEncPackedHeaderSequence)
diff --git a/src/gallium/frontends/va/picture_h264_enc.c b/src/gallium/frontends/va/picture_h264_enc.c
index c12ee99a36973..56c600613dc21 100644
--- a/src/gallium/frontends/va/picture_h264_enc.c
+++ b/src/gallium/frontends/va/picture_h264_enc.c
@@ -486,7 +486,7 @@ vlVaHandleVAEncPackedHeaderDataBufferTypeH264(vlVaContext *context, vlVaBuffer *
       unsigned nal_unit_type = vl_vlc_get_uimsbf(&vlc, 5);
 
       struct vl_rbsp rbsp;
-      vl_rbsp_init(&rbsp, &vlc, ~0, true);
+      vl_rbsp_init(&rbsp, &vlc, ~0, context->packed_header_emulation_bytes);
 
       switch(nal_unit_type) {
       case H264_NAL_SPS:
@@ -496,6 +496,9 @@ vlVaHandleVAEncPackedHeaderDataBufferTypeH264(vlVaContext *context, vlVaBuffer *
       default:
          break;
       }
+
+      if (!context->packed_header_emulation_bytes)
+         break;
    }
 
    return VA_STATUS_SUCCESS;
diff --git a/src/gallium/frontends/va/picture_hevc_enc.c b/src/gallium/frontends/va/picture_hevc_enc.c
index 860404c925bd1..b0aa1b946b035 100644
--- a/src/gallium/frontends/va/picture_hevc_enc.c
+++ b/src/gallium/frontends/va/picture_hevc_enc.c
@@ -465,7 +465,7 @@ vlVaHandleVAEncPackedHeaderDataBufferTypeHEVC(vlVaContext *context, vlVaBuffer *
       vl_vlc_eatbits(&vlc, 3);
 
       struct vl_rbsp rbsp;
-      vl_rbsp_init(&rbsp, &vlc, ~0, true);
+      vl_rbsp_init(&rbsp, &vlc, ~0, context->packed_header_emulation_bytes);
 
       switch(nal_unit_type) {
       case HEVC_NAL_SPS:
@@ -476,6 +476,9 @@ vlVaHandleVAEncPackedHeaderDataBufferTypeHEVC(vlVaContext *context, vlVaBuffer *
       default:
          break;
       }
+
+      if (!context->packed_header_emulation_bytes)
+         break;
    }
 
    return VA_STATUS_SUCCESS;
diff --git a/src/gallium/frontends/va/va_private.h b/src/gallium/frontends/va/va_private.h
index ad2dc4da20336..7239a0715c694 100644
--- a/src/gallium/frontends/va/va_private.h
+++ b/src/gallium/frontends/va/va_private.h
@@ -372,6 +372,7 @@ typedef struct {
    bool needs_begin_frame;
    void *blit_cs;
    int packed_header_type;
+   bool packed_header_emulation_bytes;
    struct set *surfaces;
 } vlVaContext;
 
-- 
GitLab


From 1dbca88003e3d2768738a2aebd93b72b8dbc2ac9 Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Wed, 4 Oct 2023 16:55:47 +0200
Subject: [PATCH 4/4] radeonsi/vcn: Add encode support for H264 B-frames

Tested with ffmpeg and gstreamer vah264enc.

References to B-frames (b_depth/b-pyramid) not supported.

Reviewed-by: Ruijing Dong <ruijing.dong@amd.com>
---
 src/amd/common/ac_vcn_enc.h                   |   2 +
 src/gallium/drivers/radeonsi/radeon_vcn_enc.c |  16 +-
 .../drivers/radeonsi/radeon_vcn_enc_1_2.c     |  29 +-
 .../drivers/radeonsi/radeon_vcn_enc_3_0.c     | 299 +++++++++++++++++-
 .../drivers/radeonsi/radeon_vcn_enc_4_0.c     |   6 +-
 src/gallium/drivers/radeonsi/si_get.c         |   9 +
 6 files changed, 347 insertions(+), 14 deletions(-)

diff --git a/src/amd/common/ac_vcn_enc.h b/src/amd/common/ac_vcn_enc.h
index 382143cb9922e..aefc7de04163c 100644
--- a/src/amd/common/ac_vcn_enc.h
+++ b/src/amd/common/ac_vcn_enc.h
@@ -371,6 +371,7 @@ typedef struct rvcn_enc_h264_encode_params_s {
    rvcn_enc_h264_reference_picture_info_t picture_info_l0_reference_picture1;
    uint32_t l1_reference_picture0_index;
    rvcn_enc_h264_reference_picture_info_t picture_info_l1_reference_picture0;
+   uint32_t is_reference;
 } rvcn_enc_h264_encode_params_t;
 
 typedef struct rvcn_enc_h264_deblocking_filter_s {
@@ -560,6 +561,7 @@ typedef struct rvcn_enc_vui_info_s
    uint32_t matrix_coefficients;
    uint32_t chroma_sample_loc_type_top_field;
    uint32_t chroma_sample_loc_type_bottom_field;
+   uint32_t max_num_reorder_frames;
 }rvcn_enc_vui_info;
 
 typedef struct rvcn_enc_input_format_s
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
index 2510a3346bbb7..0f4b5efcca42c 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
@@ -101,6 +101,7 @@ static void radeon_vcn_enc_h264_get_spec_misc_param(struct radeon_encoder *enc,
       pic->pic_ctrl.deblocking_filter_control_present_flag;
    enc->enc_pic.spec_misc.redundant_pic_cnt_present_flag =
       pic->pic_ctrl.redundant_pic_cnt_present_flag;
+   enc->enc_pic.spec_misc.b_picture_enabled = !!pic->seq.max_num_reorder_frames;
 }
 
 static void radeon_vcn_enc_h264_get_rc_param(struct radeon_encoder *enc,
@@ -189,6 +190,7 @@ static void radeon_vcn_enc_h264_get_vui_param(struct radeon_encoder *enc,
       pic->seq.chroma_sample_loc_type_top_field;
    enc->enc_pic.vui_info.chroma_sample_loc_type_bottom_field =
       pic->seq.chroma_sample_loc_type_bottom_field;
+   enc->enc_pic.vui_info.max_num_reorder_frames = pic->seq.max_num_reorder_frames;
 }
 
 /* only checking the first slice to get num of mbs in slice to
@@ -775,9 +777,9 @@ static int setup_dpb(struct radeon_encoder *enc)
       full_size = align(full_size, 4);
 
       enc_pic->ctx_buf.two_pass_search_center_map_offset = offset;
-      if (is_h264)
+      if (is_h264 && !enc_pic->spec_misc.b_picture_enabled)
          offset += align((pre_size * 4 + full_size) * sizeof(uint32_t), enc->alignment);
-      else
+      else if (!is_h264)
          offset += align((pre_size * 52 + full_size) * sizeof(uint32_t), enc->alignment);
    } else
       enc_pic->ctx_buf.two_pass_search_center_map_offset = 0;
@@ -814,10 +816,16 @@ static int setup_dpb(struct radeon_encoder *enc)
    }
 
    enc_pic->ctx_buf.num_reconstructed_pictures = num_reconstructed_pictures;
-   enc_pic->ctx_buf.colloc_buffer_offset = 0;
-   enc->dpb_size = offset;
    enc->max_ltr_idx = 0;
 
+   if (enc_pic->spec_misc.b_picture_enabled) {
+      enc_pic->ctx_buf.colloc_buffer_offset = offset;
+      offset += (align((aligned_width / 16), 64) / 2) * (aligned_height / 16);
+   } else
+      enc_pic->ctx_buf.colloc_buffer_offset = 0;
+
+   enc->dpb_size = offset;
+
    return offset;
 }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
index b74ecc9e812b5..aef49593e865a 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
@@ -1476,6 +1476,27 @@ static void manage_dpb_before_encode(struct radeon_encoder *enc)
    assert(current_pic_idx >= 0);
 
    int ref0_idx = find_ref_idx(enc, enc->enc_pic.ref_idx_l0, enc->enc_pic.ref_idx_l0_is_ltr);
+   /* B-frames only supported on VCN >= 3.0 */
+   int ref1_idx = find_ref_idx(enc, enc->enc_pic.ref_idx_l1, enc->enc_pic.ref_idx_l1_is_ltr);
+
+   assert(enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_P ||
+          ref0_idx != -1);
+   assert(enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_B ||
+          (ref0_idx != -1 && ref1_idx != -1));
+
+   /* In case we didn't find the reference in dpb, we have to pick
+    * some valid index to prevent GPU hang. */
+   if ((enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_P ||
+        enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) &&
+       ref0_idx == -1) {
+      RVID_ERR("Failed to find ref0 (%u).\n", enc->enc_pic.ref_idx_l0);
+      ref0_idx = (current_pic_idx + 1) % (enc->base.max_references + 1);
+   }
+
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B && ref1_idx == -1) {
+      RVID_ERR("Failed to find ref1 (%u).\n", enc->enc_pic.ref_idx_l1);
+      ref1_idx = (current_pic_idx + 2) % (enc->base.max_references + 1);
+   }
 
    if (!enc->enc_pic.not_referenced)
       enc->dpb_info[current_pic_idx].in_use = true;
@@ -1488,11 +1509,15 @@ static void manage_dpb_before_encode(struct radeon_encoder *enc)
       enc->dpb_info[current_pic_idx].is_ltr = false;
    }
 
-   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR)
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) {
       enc->enc_pic.enc_params.reference_picture_index = 0xFFFFFFFF;
-   else
+      enc->enc_pic.h264_enc_params.l1_reference_picture0_index = 0xFFFFFFFF;
+   } else {
       enc->enc_pic.enc_params.reference_picture_index = ref0_idx;
+      enc->enc_pic.h264_enc_params.l1_reference_picture0_index = ref1_idx;
+   }
    enc->enc_pic.enc_params.reconstructed_picture_index = current_pic_idx;
+   enc->enc_pic.h264_enc_params.is_reference = !enc->enc_pic.not_referenced;
 }
 
 void radeon_enc_1_2_init(struct radeon_encoder *enc)
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c
index 294202e2d4a97..1c193d0a264f7 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_3_0.c
@@ -17,7 +17,7 @@
 #include "radeon_vcn_enc.h"
 
 #define RENCODE_FW_INTERFACE_MAJOR_VERSION   1
-#define RENCODE_FW_INTERFACE_MINOR_VERSION   0
+#define RENCODE_FW_INTERFACE_MINOR_VERSION   20
 
 static void radeon_enc_spec_misc(struct radeon_encoder *enc)
 {
@@ -25,7 +25,6 @@ static void radeon_enc_spec_misc(struct radeon_encoder *enc)
    enc->enc_pic.spec_misc.half_pel_enabled = 1;
    enc->enc_pic.spec_misc.quarter_pel_enabled = 1;
    enc->enc_pic.spec_misc.level_idc = enc->base.level;
-   enc->enc_pic.spec_misc.b_picture_enabled = 0;
    enc->enc_pic.spec_misc.weighted_bipred_idc = 0;
 
    RADEON_ENC_BEGIN(enc->cmd.spec_misc_h264);
@@ -65,7 +64,6 @@ static void radeon_enc_encode_params_h264(struct radeon_encoder *enc)
    enc->enc_pic.h264_enc_params.input_pic_order_cnt = 0;
    enc->enc_pic.h264_enc_params.interlaced_mode = RENCODE_H264_INTERLACING_MODE_PROGRESSIVE;
    enc->enc_pic.h264_enc_params.l0_reference_picture1_index = 0xFFFFFFFF;
-   enc->enc_pic.h264_enc_params.l1_reference_picture0_index= 0xFFFFFFFF;
 
    RADEON_ENC_BEGIN(enc->cmd.enc_params_h264);
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.input_picture_structure);
@@ -85,6 +83,298 @@ static void radeon_enc_encode_params_h264(struct radeon_encoder *enc)
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.picture_info_l1_reference_picture0.is_long_term);
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.picture_info_l1_reference_picture0.picture_structure);
    RADEON_ENC_CS(enc->enc_pic.h264_enc_params.picture_info_l1_reference_picture0.pic_order_cnt);
+   RADEON_ENC_CS(enc->enc_pic.h264_enc_params.is_reference);
+   RADEON_ENC_END();
+}
+
+static void radeon_enc_quality_params(struct radeon_encoder *enc)
+{
+   enc->enc_pic.quality_params.vbaq_mode = enc->enc_pic.quality_modes.vbaq_mode;
+   enc->enc_pic.quality_params.scene_change_sensitivity = 0;
+   enc->enc_pic.quality_params.scene_change_min_idr_interval = 0;
+   enc->enc_pic.quality_params.two_pass_search_center_map_mode =
+      (enc->enc_pic.quality_modes.pre_encode_mode &&
+       !enc->enc_pic.spec_misc.b_picture_enabled) ? 1 : 0;
+   enc->enc_pic.quality_params.vbaq_strength = 0;
+
+   RADEON_ENC_BEGIN(enc->cmd.quality_params);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.vbaq_mode);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.scene_change_sensitivity);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.scene_change_min_idr_interval);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.two_pass_search_center_map_mode);
+   RADEON_ENC_CS(enc->enc_pic.quality_params.vbaq_strength);
+   RADEON_ENC_END();
+}
+
+static void radeon_enc_nalu_sps(struct radeon_encoder *enc)
+{
+   struct radeon_enc_pic *pic = &enc->enc_pic;
+   RADEON_ENC_BEGIN(enc->cmd.nalu);
+   RADEON_ENC_CS(RENCODE_DIRECT_OUTPUT_NALU_TYPE_SPS);
+   uint32_t *size_in_bytes = &enc->cs.current.buf[enc->cs.current.cdw++];
+   radeon_enc_reset(enc);
+   radeon_enc_set_emulation_prevention(enc, false);
+   radeon_enc_code_fixed_bits(enc, 0x00000001, 32);
+   radeon_enc_code_fixed_bits(enc, 0x67, 8);
+   radeon_enc_byte_align(enc);
+   radeon_enc_set_emulation_prevention(enc, true);
+   radeon_enc_code_fixed_bits(enc, pic->spec_misc.profile_idc, 8);
+   radeon_enc_code_fixed_bits(enc, 0x0, 8); /* constraint_set_flags */
+   radeon_enc_code_fixed_bits(enc, pic->spec_misc.level_idc, 8);
+   radeon_enc_code_ue(enc, 0x0);
+
+   if (pic->spec_misc.profile_idc == 100 || pic->spec_misc.profile_idc == 110 ||
+       pic->spec_misc.profile_idc == 122 || pic->spec_misc.profile_idc == 244 ||
+       pic->spec_misc.profile_idc == 44  || pic->spec_misc.profile_idc == 83 ||
+       pic->spec_misc.profile_idc == 86  || pic->spec_misc.profile_idc == 118 ||
+       pic->spec_misc.profile_idc == 128 || pic->spec_misc.profile_idc == 138) {
+      radeon_enc_code_ue(enc, 0x1);
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_fixed_bits(enc, 0x0, 2);
+   }
+
+   radeon_enc_code_ue(enc, 1);
+   radeon_enc_code_ue(enc, pic->pic_order_cnt_type);
+
+   if (pic->pic_order_cnt_type == 0)
+      radeon_enc_code_ue(enc, 1);
+
+   radeon_enc_code_ue(enc, enc->base.max_references);
+   radeon_enc_code_fixed_bits(enc, pic->layer_ctrl.max_num_temporal_layers > 1 ? 0x1 : 0x0,
+                              1);
+   radeon_enc_code_ue(enc, (pic->session_init.aligned_picture_width / 16 - 1));
+   radeon_enc_code_ue(enc, (pic->session_init.aligned_picture_height / 16 - 1));
+   bool progressive_only = true;
+   radeon_enc_code_fixed_bits(enc, progressive_only ? 0x1 : 0x0, 1);
+
+   if (!progressive_only)
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+
+   radeon_enc_code_fixed_bits(enc, 0x1, 1);
+
+   if ((pic->crop_left != 0) || (pic->crop_right  != 0) ||
+       (pic->crop_top  != 0) || (pic->crop_bottom != 0)) {
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);
+      radeon_enc_code_ue(enc, pic->crop_left);
+      radeon_enc_code_ue(enc, pic->crop_right);
+      radeon_enc_code_ue(enc, pic->crop_top);
+      radeon_enc_code_ue(enc, pic->crop_bottom);
+   } else
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+
+   /* VUI present flag */
+   radeon_enc_code_fixed_bits(enc, pic->vui_info.vui_parameters_present_flag, 1);
+   if (pic->vui_info.vui_parameters_present_flag) {
+      /* aspect ratio present flag */
+      radeon_enc_code_fixed_bits(enc, (pic->vui_info.flags.aspect_ratio_info_present_flag), 1);
+      if (pic->vui_info.flags.aspect_ratio_info_present_flag) {
+         radeon_enc_code_fixed_bits(enc, (pic->vui_info.aspect_ratio_idc), 8);
+         if (pic->vui_info.aspect_ratio_idc == PIPE_H2645_EXTENDED_SAR) {
+            radeon_enc_code_fixed_bits(enc, (pic->vui_info.sar_width), 16);
+            radeon_enc_code_fixed_bits(enc, (pic->vui_info.sar_height), 16);
+         }
+      }
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* overscan info present flag */
+      /* video signal type present flag  */
+      radeon_enc_code_fixed_bits(enc, pic->vui_info.flags.video_signal_type_present_flag, 1);
+      if (pic->vui_info.flags.video_signal_type_present_flag) {
+         radeon_enc_code_fixed_bits(enc, pic->vui_info.video_format, 3);
+         radeon_enc_code_fixed_bits(enc, pic->vui_info.video_full_range_flag, 1);
+         radeon_enc_code_fixed_bits(enc, pic->vui_info.flags.colour_description_present_flag, 1);
+         if (pic->vui_info.flags.colour_description_present_flag) {
+            radeon_enc_code_fixed_bits(enc, pic->vui_info.colour_primaries, 8);
+            radeon_enc_code_fixed_bits(enc, pic->vui_info.transfer_characteristics, 8);
+            radeon_enc_code_fixed_bits(enc, pic->vui_info.matrix_coefficients, 8);
+         }
+      }
+      /* chroma loc info present flag */
+      radeon_enc_code_fixed_bits(enc, pic->vui_info.flags.chroma_loc_info_present_flag, 1);
+      if (pic->vui_info.flags.chroma_loc_info_present_flag) {
+         radeon_enc_code_ue(enc, pic->vui_info.chroma_sample_loc_type_top_field);
+         radeon_enc_code_ue(enc, pic->vui_info.chroma_sample_loc_type_bottom_field);
+      }
+      /* timing info present flag */
+      radeon_enc_code_fixed_bits(enc, (pic->vui_info.flags.timing_info_present_flag), 1);
+      if (pic->vui_info.flags.timing_info_present_flag) {
+         radeon_enc_code_fixed_bits(enc, (pic->vui_info.num_units_in_tick), 32);
+         radeon_enc_code_fixed_bits(enc, (pic->vui_info.time_scale), 32);
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+      }
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* nal hrd parameters present flag */
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* vcl hrd parameters present flag */
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);  /* pic_struct_present flag */
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);  /* bitstream_restriction_flag */
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);  /* motion_vectors_over_pic_boundaries_flag */
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_ue(enc, 0x0);
+      radeon_enc_code_ue(enc, 16);
+      radeon_enc_code_ue(enc, 16);
+      radeon_enc_code_ue(enc, pic->vui_info.max_num_reorder_frames);
+      radeon_enc_code_ue(enc, enc->base.max_references); /* max_dec_frame_buffering */
+   }
+   radeon_enc_code_fixed_bits(enc, 0x1, 1);
+
+   radeon_enc_byte_align(enc);
+   radeon_enc_flush_headers(enc);
+   *size_in_bytes = (enc->bits_output + 7) / 8;
+   RADEON_ENC_END();
+}
+
+static void radeon_enc_slice_header(struct radeon_encoder *enc)
+{
+   uint32_t instruction[RENCODE_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS] = {0};
+   uint32_t num_bits[RENCODE_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS] = {0};
+   unsigned int inst_index = 0;
+   unsigned int cdw_start = 0;
+   unsigned int cdw_filled = 0;
+   unsigned int bits_copied = 0;
+   RADEON_ENC_BEGIN(enc->cmd.slice_header);
+   radeon_enc_reset(enc);
+   radeon_enc_set_emulation_prevention(enc, false);
+
+   cdw_start = enc->cs.current.cdw;
+   if (enc->enc_pic.is_idr)
+      radeon_enc_code_fixed_bits(enc, 0x65, 8);
+   else if (enc->enc_pic.not_referenced)
+      radeon_enc_code_fixed_bits(enc, 0x01, 8);
+   else
+      radeon_enc_code_fixed_bits(enc, 0x41, 8);
+
+   radeon_enc_flush_headers(enc);
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
+   num_bits[inst_index] = enc->bits_output - bits_copied;
+   bits_copied = enc->bits_output;
+   inst_index++;
+
+   instruction[inst_index] = RENCODE_H264_HEADER_INSTRUCTION_FIRST_MB;
+   inst_index++;
+
+   switch (enc->enc_pic.picture_type) {
+   case PIPE_H2645_ENC_PICTURE_TYPE_I:
+   case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
+      radeon_enc_code_fixed_bits(enc, 0x08, 7);
+      break;
+   case PIPE_H2645_ENC_PICTURE_TYPE_P:
+   case PIPE_H2645_ENC_PICTURE_TYPE_SKIP:
+      radeon_enc_code_fixed_bits(enc, 0x06, 5);
+      break;
+   case PIPE_H2645_ENC_PICTURE_TYPE_B:
+      radeon_enc_code_fixed_bits(enc, 0x07, 5);
+      break;
+   default:
+      radeon_enc_code_fixed_bits(enc, 0x08, 7);
+   }
+
+   radeon_enc_code_ue(enc, 0x0);
+   radeon_enc_code_fixed_bits(enc, enc->enc_pic.frame_num % 32, 5);
+
+   if (enc->enc_pic.h264_enc_params.input_picture_structure !=
+       RENCODE_H264_PICTURE_STRUCTURE_FRAME) {
+      radeon_enc_code_fixed_bits(enc, 0x1, 1);
+      radeon_enc_code_fixed_bits(enc,
+                                 enc->enc_pic.h264_enc_params.input_picture_structure ==
+                                       RENCODE_H264_PICTURE_STRUCTURE_BOTTOM_FIELD
+                                    ? 1
+                                    : 0,
+                                 1);
+   }
+
+   if (enc->enc_pic.is_idr)
+      radeon_enc_code_ue(enc, enc->enc_pic.is_even_frame);
+
+   enc->enc_pic.is_even_frame = !enc->enc_pic.is_even_frame;
+
+   if (enc->enc_pic.pic_order_cnt_type == 0)
+      radeon_enc_code_fixed_bits(enc, enc->enc_pic.pic_order_cnt % 32, 5);
+
+   if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B)
+      radeon_enc_code_fixed_bits(enc, 0x1, 1); /* direct_spatial_mv_pred_flag */
+
+   /* ref_pic_list_modification() */
+   if (enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_IDR) {
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+
+      /* long-term reference */
+      if (enc->enc_pic.ref_idx_l0_is_ltr) {
+         radeon_enc_code_fixed_bits(enc, 0x1, 1);            /* ref_pic_list_modification_flag_l0 */
+         radeon_enc_code_ue(enc, 0x2);                       /* modification_of_pic_nums_idc */
+         radeon_enc_code_ue(enc, enc->enc_pic.ref_idx_l0);   /* long_term_pic_num */
+         radeon_enc_code_ue(enc, 0x3);
+      }
+
+      /* short-term reference */
+      else if (enc->enc_pic.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_B) {
+         radeon_enc_code_fixed_bits(enc, 0x0, 1); /* ref_pic_list_modification_flag_l0 */
+         radeon_enc_code_fixed_bits(enc, 0x0, 1); /* ref_pic_list_modification_flag_l1 */
+      }
+      /* list_mod_diff_pic_minus1 != 0 */
+      else if (enc->enc_pic.frame_num - enc->enc_pic.ref_idx_l0 > 1) {
+         radeon_enc_code_fixed_bits(enc, 0x1, 1);  /* ref_pic_list_modification_flag_l0 */
+         radeon_enc_code_ue(enc, 0x0);             /* modification_of_pic_nums_idc */
+         /* abs_diff_pic_num_minus1 */
+         radeon_enc_code_ue(enc, (enc->enc_pic.frame_num - enc->enc_pic.ref_idx_l0 - 1));
+         radeon_enc_code_ue(enc, 0x3);
+      } else
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+   }
+
+   if (enc->enc_pic.is_idr) {
+      radeon_enc_code_fixed_bits(enc, 0x0, 1);
+      if (enc->enc_pic.is_ltr)
+         radeon_enc_code_fixed_bits(enc, 0x1, 1); /* long_term_reference_flag */
+      else
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+   } else if (!enc->enc_pic.not_referenced) {
+      if (enc->enc_pic.is_ltr) {
+         radeon_enc_code_fixed_bits(enc, 0x1, 1);
+         radeon_enc_code_ue(enc, 0x4); /* memory_management_control_operation */
+         radeon_enc_code_ue(enc, enc->max_ltr_idx + 1); /* max_long_term_frame_idx_plus1 */
+         radeon_enc_code_ue(enc, 0x6); /*memory_management_control_operation */
+         radeon_enc_code_ue(enc, enc->enc_pic.ltr_idx); /* long_term_frame_idx */
+         radeon_enc_code_ue(enc, 0x0); /*memory_management_control_operation end*/
+      } else
+         radeon_enc_code_fixed_bits(enc, 0x0, 1);
+   }
+
+   if ((enc->enc_pic.picture_type != PIPE_H2645_ENC_PICTURE_TYPE_IDR) &&
+       (enc->enc_pic.spec_misc.cabac_enable))
+      radeon_enc_code_ue(enc, enc->enc_pic.spec_misc.cabac_init_idc);
+
+   radeon_enc_flush_headers(enc);
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
+   num_bits[inst_index] = enc->bits_output - bits_copied;
+   bits_copied = enc->bits_output;
+   inst_index++;
+
+   instruction[inst_index] = RENCODE_H264_HEADER_INSTRUCTION_SLICE_QP_DELTA;
+   inst_index++;
+
+   if (enc->enc_pic.spec_misc.deblocking_filter_control_present_flag) {
+      radeon_enc_code_ue(enc, enc->enc_pic.h264_deblock.disable_deblocking_filter_idc);
+      if (!enc->enc_pic.h264_deblock.disable_deblocking_filter_idc) {
+         radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.alpha_c0_offset_div2);
+         radeon_enc_code_se(enc, enc->enc_pic.h264_deblock.beta_offset_div2);
+      }
+   }
+
+   radeon_enc_flush_headers(enc);
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_COPY;
+   num_bits[inst_index] = enc->bits_output - bits_copied;
+   bits_copied = enc->bits_output;
+   inst_index++;
+
+   instruction[inst_index] = RENCODE_HEADER_INSTRUCTION_END;
+
+   cdw_filled = enc->cs.current.cdw - cdw_start;
+   for (int i = 0; i < RENCODE_SLICE_HEADER_TEMPLATE_MAX_TEMPLATE_SIZE_IN_DWORDS - cdw_filled; i++)
+      RADEON_ENC_CS(0x00000000);
+
+   for (int j = 0; j < RENCODE_SLICE_HEADER_TEMPLATE_MAX_NUM_INSTRUCTIONS; j++) {
+      RADEON_ENC_CS(instruction[j]);
+      RADEON_ENC_CS(num_bits[j]);
+   }
+
    RADEON_ENC_END();
 }
 
@@ -233,10 +523,13 @@ void radeon_enc_3_0_init(struct radeon_encoder *enc)
 
    enc->session_init = radeon_enc_session_init;
    enc->ctx = radeon_enc_ctx;
+   enc->quality_params = radeon_enc_quality_params;
 
    if (u_reduce_video_profile(enc->base.profile) == PIPE_VIDEO_FORMAT_MPEG4_AVC) {
       enc->spec_misc = radeon_enc_spec_misc;
       enc->encode_params_codec_spec = radeon_enc_encode_params_h264;
+      enc->nalu_sps = radeon_enc_nalu_sps;
+      enc->slice_header = radeon_enc_slice_header;
    }
 
    if (u_reduce_video_profile(enc->base.profile) == PIPE_VIDEO_FORMAT_HEVC) {
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
index 99b0edc04aec9..8638bc45268b0 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_4_0.c
@@ -16,7 +16,7 @@
 #include "radeon_vcn_enc.h"
 
 #define RENCODE_FW_INTERFACE_MAJOR_VERSION   1
-#define RENCODE_FW_INTERFACE_MINOR_VERSION   0
+#define RENCODE_FW_INTERFACE_MINOR_VERSION   11
 
 #define RENCODE_IB_PARAM_CDF_DEFAULT_TABLE_BUFFER  0x00000019
 #define RENCODE_IB_PARAM_ENCODE_STATISTICS         0x0000001a
@@ -936,10 +936,6 @@ static void radeon_enc_ctx(struct radeon_encoder *enc)
                                            == PIPE_VIDEO_FORMAT_AV1;
    enc->enc_pic.ctx_buf.swizzle_mode = radeon_enc_ref_swizzle_mode(enc);
    enc->enc_pic.ctx_buf.two_pass_search_center_map_offset = 0;
-   if (is_av1)
-      enc->enc_pic.ctx_buf.colloc_buffer_offset = 0;
-   else
-      enc->enc_pic.ctx_buf.colloc_buffer_offset = enc->dpb_size;
 
    RADEON_ENC_BEGIN(enc->cmd.ctx);
    RADEON_ENC_READWRITE(enc->dpb->res->buf, enc->dpb->res->domains, 0);
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 8de9124c0c1fb..bfbed3950651d 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -752,6 +752,15 @@ static int si_get_video_param(struct pipe_screen *screen, enum pipe_video_profil
       case PIPE_VIDEO_CAP_EFC_SUPPORTED:
          return ((sscreen->info.family >= CHIP_RENOIR) &&
                  !(sscreen->debug_flags & DBG(NO_EFC)));
+
+      case PIPE_VIDEO_CAP_ENC_MAX_REFERENCES_PER_FRAME:
+         if (sscreen->info.vcn_ip_version >= VCN_3_0_0) {
+            int refPicList0 = 1;
+            int refPicList1 = codec == PIPE_VIDEO_FORMAT_MPEG4_AVC ? 1 : 0;
+            return refPicList0 | (refPicList1 << 16);
+         } else
+            return 1;
+
       default:
          return 0;
       }
-- 
GitLab

