From 235b3500a5a181b630d4d0363b15b98bbdb8c317 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 24 Jul 2022 19:35:28 -0400
Subject: [PATCH 1/4] Revert "mesa: implement a display list / glBitmap texture
 atlas"

This reverts commit b26ddda12fe7dbb6a4e6af3b47c1e837cc7ebb03 and
commit 06d3b0a006f35dc232d512d09f45a6cb4f13cfdf.

Reviewed-by: Brian Paul <brianp@vmware.com>
---
 src/mesa/main/dd.h                    |   1 -
 src/mesa/main/dlist.c                 | 392 --------------------------
 src/mesa/main/dlist.h                 |  38 ---
 src/mesa/main/mtypes.h                |   1 -
 src/mesa/main/shared.c                |  18 --
 src/mesa/state_tracker/st_cb_bitmap.c | 148 +---------
 src/mesa/state_tracker/st_cb_bitmap.h |   5 +-
 src/mesa/state_tracker/st_context.h   |   1 -
 8 files changed, 4 insertions(+), 600 deletions(-)

diff --git a/src/mesa/main/dd.h b/src/mesa/main/dd.h
index 0615942212a2..a9c714f08764 100644
--- a/src/mesa/main/dd.h
+++ b/src/mesa/main/dd.h
@@ -44,7 +44,6 @@
 #undef MemoryBarrier
 #endif
 
-struct gl_bitmap_atlas;
 struct gl_buffer_object;
 struct gl_context;
 struct gl_display_list;
diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index 64070b68d0d1..c4cddad47761 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -55,8 +55,6 @@
 #include "state_tracker/st_cb_texture.h"
 #include "state_tracker/st_cb_bitmap.h"
 
-#define USE_BITMAP_ATLAS 1
-
 static bool
 _mesa_glthread_should_execute_list(struct gl_context *ctx,
                                    struct gl_display_list *dlist);
@@ -802,271 +800,6 @@ Node *get_list_head(struct gl_context *ctx, struct gl_display_list *dlist)
 }
 
 
-/**
- * Does the given display list only contain a single glBitmap call?
- */
-static bool
-is_bitmap_list(struct gl_context *ctx, struct gl_display_list *dlist)
-{
-   Node *n = get_list_head(ctx, dlist);
-   if (n[0].opcode == OPCODE_BITMAP) {
-      n += n[0].InstSize;
-      if (n[0].opcode == OPCODE_END_OF_LIST)
-         return true;
-   }
-   return false;
-}
-
-
-/**
- * Is the given display list an empty list?
- */
-static bool
-is_empty_list(struct gl_context *ctx, struct gl_display_list *dlist)
-{
-   Node *n = get_list_head(ctx, dlist);
-   return n[0].opcode == OPCODE_END_OF_LIST;
-}
-
-
-/**
- * Delete/free a gl_bitmap_atlas.  Called during context tear-down.
- */
-void
-_mesa_delete_bitmap_atlas(struct gl_context *ctx, struct gl_bitmap_atlas *atlas)
-{
-   if (atlas->texObj) {
-      _mesa_delete_texture_object(ctx, atlas->texObj);
-   }
-   free(atlas->glyphs);
-   free(atlas);
-}
-
-
-/**
- * Lookup a gl_bitmap_atlas by listBase ID.
- */
-static struct gl_bitmap_atlas *
-lookup_bitmap_atlas(struct gl_context *ctx, GLuint listBase)
-{
-   struct gl_bitmap_atlas *atlas;
-
-   assert(listBase > 0);
-   atlas = _mesa_HashLookup(ctx->Shared->BitmapAtlas, listBase);
-   return atlas;
-}
-
-
-/**
- * Create new bitmap atlas and insert into hash table.
- */
-static struct gl_bitmap_atlas *
-alloc_bitmap_atlas(struct gl_context *ctx, GLuint listBase, bool isGenName)
-{
-   struct gl_bitmap_atlas *atlas;
-
-   assert(listBase > 0);
-   assert(_mesa_HashLookup(ctx->Shared->BitmapAtlas, listBase) == NULL);
-
-   atlas = calloc(1, sizeof(*atlas));
-   if (atlas) {
-      _mesa_HashInsert(ctx->Shared->BitmapAtlas, listBase, atlas, isGenName);
-      atlas->Id = listBase;
-   }
-
-   return atlas;
-}
-
-
-/**
- * Try to build a bitmap atlas.  This involves examining a sequence of
- * display lists which contain glBitmap commands and putting the bitmap
- * images into a texture map (the atlas).
- * If we succeed, gl_bitmap_atlas::complete will be set to true.
- * If we fail, gl_bitmap_atlas::incomplete will be set to true.
- */
-static void
-build_bitmap_atlas(struct gl_context *ctx, struct gl_bitmap_atlas *atlas,
-                   GLuint listBase)
-{
-   unsigned i, row_height = 0, xpos = 0, ypos = 0;
-   GLubyte *map;
-   GLint map_stride;
-
-   assert(atlas);
-   assert(!atlas->complete);
-   assert(atlas->numBitmaps > 0);
-
-   /* We use a rectangle texture (non-normalized coords) for the atlas */
-   assert(ctx->Extensions.NV_texture_rectangle);
-   assert(ctx->Const.MaxTextureRectSize >= 1024);
-
-   atlas->texWidth = 1024;
-   atlas->texHeight = 0;  /* determined below */
-
-   atlas->glyphs = malloc(atlas->numBitmaps * sizeof(atlas->glyphs[0]));
-   if (!atlas->glyphs) {
-      /* give up */
-      atlas->incomplete = true;
-      return;
-   }
-
-   /* Loop over the display lists.  They should all contain a single glBitmap
-    * call.  If not, bail out.  Also, compute the position and sizes of each
-    * bitmap in the atlas to determine the texture atlas size.
-    */
-   for (i = 0; i < atlas->numBitmaps; i++) {
-      struct gl_display_list *list = _mesa_lookup_list(ctx, listBase + i, true);
-      const Node *n;
-      struct gl_bitmap_glyph *g = &atlas->glyphs[i];
-      unsigned bitmap_width, bitmap_height;
-      float bitmap_xmove, bitmap_ymove, bitmap_xorig, bitmap_yorig;
-
-      if (!list || is_empty_list(ctx, list)) {
-         /* stop here */
-         atlas->numBitmaps = i;
-         break;
-      }
-
-      if (!is_bitmap_list(ctx, list)) {
-         /* This list does not contain exactly one glBitmap command. Give up. */
-         atlas->incomplete = true;
-         return;
-      }
-
-      /* get bitmap info from the display list command */
-      n = get_list_head(ctx, list);
-      assert(n[0].opcode == OPCODE_BITMAP);
-      bitmap_width = n[1].i;
-      bitmap_height = n[2].i;
-      bitmap_xorig = n[3].f;
-      bitmap_yorig = n[4].f;
-      bitmap_xmove = n[5].f;
-      bitmap_ymove = n[6].f;
-
-      if (xpos + bitmap_width > atlas->texWidth) {
-         /* advance to the next row of the texture */
-         xpos = 0;
-         ypos += row_height;
-         row_height = 0;
-      }
-
-      /* save the bitmap's position in the atlas */
-      g->x = xpos;
-      g->y = ypos;
-      g->w = bitmap_width;
-      g->h = bitmap_height;
-      g->xorig = bitmap_xorig;
-      g->yorig = bitmap_yorig;
-      g->xmove = bitmap_xmove;
-      g->ymove = bitmap_ymove;
-
-      xpos += bitmap_width;
-
-      /* keep track of tallest bitmap in the row */
-      row_height = MAX2(row_height, bitmap_height);
-   }
-
-   /* Now we know the texture height */
-   atlas->texHeight = ypos + row_height;
-
-   if (atlas->texHeight == 0) {
-      /* no glyphs found, give up */
-      goto fail;
-   }
-   else if (atlas->texHeight > ctx->Const.MaxTextureRectSize) {
-      /* too large, give up */
-      goto fail;
-   }
-
-   /* Create atlas texture (texture ID is irrelevant) */
-   atlas->texObj = _mesa_new_texture_object(ctx, 999, GL_TEXTURE_RECTANGLE);
-   if (!atlas->texObj) {
-      goto out_of_memory;
-   }
-
-   atlas->texObj->Sampler.Attrib.MinFilter = GL_NEAREST;
-   atlas->texObj->Sampler.Attrib.MagFilter = GL_NEAREST;
-   atlas->texObj->Sampler.Attrib.state.min_img_filter = PIPE_TEX_FILTER_NEAREST;
-   atlas->texObj->Sampler.Attrib.state.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
-   atlas->texObj->Sampler.Attrib.state.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
-   atlas->texObj->Attrib.MaxLevel = 0;
-   atlas->texObj->Immutable = GL_TRUE;
-
-   atlas->texImage = _mesa_get_tex_image(ctx, atlas->texObj,
-                                         GL_TEXTURE_RECTANGLE, 0);
-   if (!atlas->texImage) {
-      goto out_of_memory;
-   }
-
-   if (ctx->Const.BitmapUsesRed)
-      _mesa_init_teximage_fields(ctx, atlas->texImage,
-                                 atlas->texWidth, atlas->texHeight, 1, 0,
-                                 GL_RED, MESA_FORMAT_R_UNORM8);
-   else
-      _mesa_init_teximage_fields(ctx, atlas->texImage,
-                                 atlas->texWidth, atlas->texHeight, 1, 0,
-                                 GL_ALPHA, MESA_FORMAT_A_UNORM8);
-
-   /* alloc image storage */
-   if (!st_AllocTextureImageBuffer(ctx, atlas->texImage)) {
-      goto out_of_memory;
-   }
-
-   /* map teximage, load with bitmap glyphs */
-   st_MapTextureImage(ctx, atlas->texImage, 0,
-                      0, 0, atlas->texWidth, atlas->texHeight,
-                      GL_MAP_WRITE_BIT, &map, &map_stride);
-   if (!map) {
-      goto out_of_memory;
-   }
-
-   /* Background/clear pixels are 0xff, foreground/set pixels are 0x0 */
-   memset(map, 0xff, map_stride * atlas->texHeight);
-
-   for (i = 0; i < atlas->numBitmaps; i++) {
-      struct gl_display_list *list = _mesa_lookup_list(ctx, listBase + i, true);
-      const Node *n = get_list_head(ctx, list);
-
-      assert(n[0].opcode == OPCODE_BITMAP ||
-             n[0].opcode == OPCODE_END_OF_LIST);
-
-      if (n[0].opcode == OPCODE_BITMAP) {
-         unsigned bitmap_width = n[1].i;
-         unsigned bitmap_height = n[2].i;
-         unsigned xpos = atlas->glyphs[i].x;
-         unsigned ypos = atlas->glyphs[i].y;
-         const void *bitmap_image = get_pointer(&n[7]);
-
-         assert(atlas->glyphs[i].w == bitmap_width);
-         assert(atlas->glyphs[i].h == bitmap_height);
-
-         /* put the bitmap image into the texture image */
-         _mesa_expand_bitmap(bitmap_width, bitmap_height,
-                             &ctx->DefaultPacking, bitmap_image,
-                             map + map_stride * ypos + xpos, /* dest addr */
-                             map_stride, 0x0);
-      }
-   }
-
-   st_UnmapTextureImage(ctx, atlas->texImage, 0);
-
-   atlas->complete = true;
-
-   return;
-
-out_of_memory:
-   _mesa_error(ctx, GL_OUT_OF_MEMORY, "Display list bitmap atlas");
-fail:
-   if (atlas->texObj) {
-      _mesa_delete_texture_object(ctx, atlas->texObj);
-   }
-   free(atlas->glyphs);
-   atlas->glyphs = NULL;
-   atlas->incomplete = true;
-}
-
-
 /**
  * Allocate a gl_display_list object with an initial block of storage.
  * \param count  how many display list nodes/tokens to allocate
@@ -1354,31 +1087,6 @@ _mesa_delete_list(struct gl_context *ctx, struct gl_display_list *dlist)
 }
 
 
-/**
- * Called by _mesa_HashWalk() to check if a display list which is being
- * deleted belongs to a bitmap texture atlas.
- */
-static void
-check_atlas_for_deleted_list(void *data, void *userData)
-{
-   struct gl_bitmap_atlas *atlas = (struct gl_bitmap_atlas *) data;
-   GLuint list_id = *((GLuint *) userData);  /* the list being deleted */
-   const GLuint atlas_id = atlas->Id;
-
-   /* See if the list_id falls in the range contained in this texture atlas */
-   if (atlas->complete &&
-       list_id >= atlas_id &&
-       list_id < atlas_id + atlas->numBitmaps) {
-      /* Mark the atlas as incomplete so it doesn't get used.  But don't
-       * delete it yet since we don't want to try to recreate it in the next
-       * glCallLists.
-       */
-      atlas->complete = false;
-      atlas->incomplete = true;
-   }
-}
-
-
 /**
  * Destroy a display list and remove from hash table.
  * \param list - display list number
@@ -1395,16 +1103,6 @@ destroy_list(struct gl_context *ctx, GLuint list)
    if (!dlist)
       return;
 
-   if (is_bitmap_list(ctx, dlist)) {
-      /* If we're destroying a simple glBitmap display list, there's a
-       * chance that we're destroying a bitmap image that's in a texture
-       * atlas.  Examine all atlases to see if that's the case.  There's
-       * usually few (if any) atlases so this isn't expensive.
-       */
-      _mesa_HashWalk(ctx->Shared->BitmapAtlas,
-                     check_atlas_for_deleted_list, &list);
-   }
-
    _mesa_delete_list(ctx, dlist);
    _mesa_HashRemoveLocked(ctx->Shared->DisplayList, list);
 }
@@ -13388,17 +13086,6 @@ _mesa_DeleteLists(GLuint list, GLsizei range)
       return;
    }
 
-   if (range > 1) {
-      /* We may be deleting a set of bitmap lists.  See if there's a
-       * bitmap atlas to free.
-       */
-      struct gl_bitmap_atlas *atlas = lookup_bitmap_atlas(ctx, list);
-      if (atlas) {
-         _mesa_delete_bitmap_atlas(ctx, atlas);
-         _mesa_HashRemove(ctx->Shared->BitmapAtlas, list);
-      }
-   }
-
    _mesa_HashLockMutex(ctx->Shared->DisplayList);
    for (i = list; i < list + range; i++) {
       destroy_list(ctx, i);
@@ -13442,23 +13129,6 @@ _mesa_GenLists(GLsizei range)
       }
    }
 
-   if (USE_BITMAP_ATLAS &&
-       range > 16) {
-      /* "range > 16" is a rough heuristic to guess when glGenLists might be
-       * used to allocate display lists for glXUseXFont or wglUseFontBitmaps.
-       * Create the empty atlas now.
-       */
-      struct gl_bitmap_atlas *atlas = lookup_bitmap_atlas(ctx, base);
-      if (!atlas) {
-         atlas = alloc_bitmap_atlas(ctx, base, true);
-      }
-      if (atlas) {
-         /* Atlas _should_ be new/empty now, but clobbering is OK */
-         assert(atlas->numBitmaps == 0);
-         atlas->numBitmaps = range;
-      }
-   }
-
    _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
 
    return base;
@@ -13774,64 +13444,6 @@ _mesa_CallList(GLuint list)
 }
 
 
-/**
- * Try to execute a glCallLists() command where the display lists contain
- * glBitmap commands with a texture atlas.
- * \return true for success, false otherwise
- */
-static bool
-render_bitmap_atlas(struct gl_context *ctx, GLsizei n, GLenum type,
-                    const void *lists)
-{
-   struct gl_bitmap_atlas *atlas;
-   int i;
-
-   if (!USE_BITMAP_ATLAS ||
-       !ctx->Current.RasterPosValid ||
-       ctx->List.ListBase == 0 ||
-       type != GL_UNSIGNED_BYTE) {
-      /* unsupported */
-      return false;
-   }
-
-   atlas = lookup_bitmap_atlas(ctx, ctx->List.ListBase);
-
-   if (!atlas) {
-      /* Even if glGenLists wasn't called, we can still try to create
-       * the atlas now.
-       */
-      atlas = alloc_bitmap_atlas(ctx, ctx->List.ListBase, false);
-   }
-
-   if (atlas && !atlas->complete && !atlas->incomplete) {
-      /* Try to build the bitmap atlas now.
-       * If the atlas was created in glGenLists, we'll have recorded the
-       * number of lists (bitmaps).  Otherwise, take a guess at 256.
-       */
-      if (atlas->numBitmaps == 0)
-         atlas->numBitmaps = 256;
-      build_bitmap_atlas(ctx, atlas, ctx->List.ListBase);
-   }
-
-   if (!atlas || !atlas->complete) {
-      return false;
-   }
-
-   /* check that all display list IDs are in the atlas */
-   for (i = 0; i < n; i++) {
-      const GLubyte *ids = (const GLubyte *) lists;
-
-      if (ids[i] >= atlas->numBitmaps) {
-         return false;
-      }
-   }
-
-   st_DrawAtlasBitmaps(ctx, atlas, n, (const GLubyte *) lists);
-
-   return true;
-}
-
-
 /**
  * Execute glCallLists:  call multiple display lists.
  */
@@ -13857,10 +13469,6 @@ _mesa_CallLists(GLsizei n, GLenum type, const GLvoid * lists)
       return;
    }
 
-   if (render_bitmap_atlas(ctx, n, type, lists)) {
-      return;
-   }
-
    /* Save the CompileFlag status, turn it off, execute the display lists,
     * and restore the CompileFlag. This is needed for GL_COMPILE_AND_EXECUTE
     * because the call is already recorded and we just need to execute it.
diff --git a/src/mesa/main/dlist.h b/src/mesa/main/dlist.h
index ac9f8048c1c4..98de831030fb 100644
--- a/src/mesa/main/dlist.h
+++ b/src/mesa/main/dlist.h
@@ -69,44 +69,6 @@ union gl_dlist_node
    GLsizei si;
 };
 
-/**
- * Describes the location and size of a glBitmap image in a texture atlas.
- */
-struct gl_bitmap_glyph
-{
-   unsigned short x, y, w, h;  /**< position and size in the texture */
-   float xorig, yorig;         /**< bitmap origin */
-   float xmove, ymove;         /**< rasterpos move */
-};
-
-
-/**
- * Describes a set of glBitmap display lists which live in a texture atlas.
- * The idea is when we see a code sequence of glListBase(b), glCallLists(n)
- * we're probably drawing bitmap font glyphs.  We try to put all the bitmap
- * glyphs into one texture map then render the glCallLists as a textured
- * quadstrip.
- */
-struct gl_bitmap_atlas
-{
-   GLint Id;
-   bool complete;     /**< Is the atlas ready to use? */
-   bool incomplete;   /**< Did we fail to construct this atlas? */
-
-   unsigned numBitmaps;
-   unsigned texWidth, texHeight;
-   struct gl_texture_object *texObj;
-   struct gl_texture_image *texImage;
-
-   unsigned glyphHeight;
-
-   struct gl_bitmap_glyph *glyphs;
-};
-
-void
-_mesa_delete_bitmap_atlas(struct gl_context *ctx,
-                          struct gl_bitmap_atlas *atlas);
-
 struct gl_display_list *
 _mesa_lookup_list(struct gl_context *ctx, GLuint list, bool locked);
 
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 1c725f010081..6d5ca9a44112 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -2433,7 +2433,6 @@ struct gl_shared_state
    bool DisplayListsAffectGLThread;
 
    struct _mesa_HashTable *DisplayList;	   /**< Display lists hash table */
-   struct _mesa_HashTable *BitmapAtlas;    /**< For optimized glBitmap text */
    struct _mesa_HashTable *TexObjects;	   /**< Texture objects hash table */
 
    /** Default texture objects (shared by all texture units) */
diff --git a/src/mesa/main/shared.c b/src/mesa/main/shared.c
index 2085b280e00f..b62c01c1ee17 100644
--- a/src/mesa/main/shared.c
+++ b/src/mesa/main/shared.c
@@ -72,7 +72,6 @@ _mesa_alloc_shared_state(struct gl_context *ctx)
    simple_mtx_init(&shared->Mutex, mtx_plain);
 
    shared->DisplayList = _mesa_NewHashTable();
-   shared->BitmapAtlas = _mesa_NewHashTable();
    shared->TexObjects = _mesa_NewHashTable();
    shared->Programs = _mesa_NewHashTable();
 
@@ -158,18 +157,6 @@ delete_displaylist_cb(void *data, void *userData)
 }
 
 
-/**
- * Callback for deleting a bitmap atlas.  Called by _mesa_HashDeleteAll().
- */
-static void
-delete_bitmap_atlas_cb(void *data, void *userData)
-{
-   struct gl_bitmap_atlas *atlas = (struct gl_bitmap_atlas *) data;
-   struct gl_context *ctx = (struct gl_context *) userData;
-   _mesa_delete_bitmap_atlas(ctx, atlas);
-}
-
-
 /**
  * Callback for deleting a texture object.  Called by _mesa_HashDeleteAll().
  */
@@ -362,11 +349,6 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
       util_idalloc_fini(&shared->small_dlist_store.free_idx);
    }
 
-   if (shared->BitmapAtlas) {
-      _mesa_HashDeleteAll(shared->BitmapAtlas, delete_bitmap_atlas_cb, ctx);
-      _mesa_DeleteHashTable(shared->BitmapAtlas);
-   }
-
    if (shared->ShaderObjects) {
       _mesa_HashWalk(shared->ShaderObjects, free_shader_program_data_cb, ctx);
       _mesa_HashDeleteAll(shared->ShaderObjects, delete_shader_cb, ctx);
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index e2f944765ed8..48c28eab00c6 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -34,7 +34,6 @@
 
 #include "main/image.h"
 #include "main/bufferobj.h"
-#include "main/dlist.h"
 #include "main/framebuffer.h"
 #include "main/macros.h"
 #include "main/pbo.h"
@@ -56,7 +55,6 @@
 #include "pipe/p_defines.h"
 #include "pipe/p_shader_tokens.h"
 #include "util/u_inlines.h"
-#include "util/u_upload_mgr.h"
 #include "program/prog_instruction.h"
 #include "cso_cache/cso_context.h"
 
@@ -167,8 +165,7 @@ make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
 static void
 setup_render_state(struct gl_context *ctx,
                    struct pipe_sampler_view *sv,
-                   const GLfloat *color,
-                   bool atlas)
+                   const GLfloat *color)
 {
    struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st->pipe;
@@ -232,10 +229,7 @@ setup_render_state(struct gl_context *ctx,
       for (i = 0; i < st->state.num_frag_samplers; i++) {
          samplers[i] = &st->state.frag_samplers[i];
       }
-      if (atlas)
-         samplers[fpv->bitmap_sampler] = &st->bitmap.atlas_sampler;
-      else
-         samplers[fpv->bitmap_sampler] = &st->bitmap.sampler;
+      samplers[fpv->bitmap_sampler] = &st->bitmap.sampler;
       cso_set_samplers(cso, PIPE_SHADER_FRAGMENT, num,
                        (const struct pipe_sampler_state **) samplers);
    }
@@ -321,7 +315,7 @@ draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
       assert(height <= (GLsizei) maxSize);
    }
 
-   setup_render_state(ctx, sv, color, false);
+   setup_render_state(ctx, sv, color);
 
    /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
    z = z * 2.0f - 1.0f;
@@ -563,9 +557,6 @@ init_bitmap_state(struct st_context *st)
    st->bitmap.sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
    st->bitmap.sampler.normalized_coords = st->internal_target == PIPE_TEXTURE_2D;
 
-   st->bitmap.atlas_sampler = st->bitmap.sampler;
-   st->bitmap.atlas_sampler.normalized_coords = 0;
-
    /* init baseline rasterizer state once */
    memset(&st->bitmap.rasterizer, 0, sizeof(st->bitmap.rasterizer));
    st->bitmap.rasterizer.half_pixel_center = 1;
@@ -642,139 +633,6 @@ st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
    }
 }
 
-void
-st_DrawAtlasBitmaps(struct gl_context *ctx,
-                    const struct gl_bitmap_atlas *atlas,
-                    GLuint count, const GLubyte *ids)
-{
-   struct st_context *st = st_context(ctx);
-   struct pipe_context *pipe = st->pipe;
-   struct gl_texture_object *stObj = atlas->texObj;
-   struct pipe_sampler_view *sv;
-   /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
-   const float z = ctx->Current.RasterPos[2] * 2.0f - 1.0f;
-   const float *color = ctx->Current.RasterColor;
-   const float clip_x_scale = 2.0f / st->state.fb_width;
-   const float clip_y_scale = 2.0f / st->state.fb_height;
-   const unsigned num_verts = count * 4;
-   const unsigned num_vert_bytes = num_verts * sizeof(struct st_util_vertex);
-   struct st_util_vertex *verts;
-   struct pipe_vertex_buffer vb = {0};
-   unsigned i;
-
-   if (!st->bitmap.tex_format) {
-      init_bitmap_state(st);
-   }
-
-   st_flush_bitmap_cache(st);
-
-   st_validate_state(st, ST_PIPELINE_META);
-   st_invalidate_readpix_cache(st);
-
-   sv = st_create_texture_sampler_view(pipe, stObj->pt);
-   if (!sv) {
-      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCallLists(bitmap text)");
-      return;
-   }
-
-   setup_render_state(ctx, sv, color, true);
-
-   vb.stride = sizeof(struct st_util_vertex);
-
-   u_upload_alloc(pipe->stream_uploader, 0, num_vert_bytes, 4,
-                  &vb.buffer_offset, &vb.buffer.resource, (void **) &verts);
-
-   if (unlikely(!verts)) {
-      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCallLists(bitmap text)");
-      goto out;
-   }
-
-   /* build quads vertex data */
-   for (i = 0; i < count; i++) {
-      const GLfloat epsilon = 0.0001F;
-      const struct gl_bitmap_glyph *g = &atlas->glyphs[ids[i]];
-      const float xmove = g->xmove, ymove = g->ymove;
-      const float xorig = g->xorig, yorig = g->yorig;
-      const float s0 = g->x, t0 = g->y;
-      const float s1 = s0 + g->w, t1 = t0 + g->h;
-      const float x0 = util_ifloor(ctx->Current.RasterPos[0] - xorig + epsilon);
-      const float y0 = util_ifloor(ctx->Current.RasterPos[1] - yorig + epsilon);
-      const float x1 = x0 + g->w, y1 = y0 + g->h;
-      const float clip_x0 = x0 * clip_x_scale - 1.0f;
-      const float clip_y0 = y0 * clip_y_scale - 1.0f;
-      const float clip_x1 = x1 * clip_x_scale - 1.0f;
-      const float clip_y1 = y1 * clip_y_scale - 1.0f;
-
-      /* lower-left corner */
-      verts->x = clip_x0;
-      verts->y = clip_y0;
-      verts->z = z;
-      verts->r = color[0];
-      verts->g = color[1];
-      verts->b = color[2];
-      verts->a = color[3];
-      verts->s = s0;
-      verts->t = t0;
-      verts++;
-
-      /* lower-right corner */
-      verts->x = clip_x1;
-      verts->y = clip_y0;
-      verts->z = z;
-      verts->r = color[0];
-      verts->g = color[1];
-      verts->b = color[2];
-      verts->a = color[3];
-      verts->s = s1;
-      verts->t = t0;
-      verts++;
-
-      /* upper-right corner */
-      verts->x = clip_x1;
-      verts->y = clip_y1;
-      verts->z = z;
-      verts->r = color[0];
-      verts->g = color[1];
-      verts->b = color[2];
-      verts->a = color[3];
-      verts->s = s1;
-      verts->t = t1;
-      verts++;
-
-      /* upper-left corner */
-      verts->x = clip_x0;
-      verts->y = clip_y1;
-      verts->z = z;
-      verts->r = color[0];
-      verts->g = color[1];
-      verts->b = color[2];
-      verts->a = color[3];
-      verts->s = s0;
-      verts->t = t1;
-      verts++;
-
-      /* Update the raster position */
-      ctx->Current.RasterPos[0] += xmove;
-      ctx->Current.RasterPos[1] += ymove;
-      ctx->PopAttribState |= GL_CURRENT_BIT;
-   }
-
-   u_upload_unmap(pipe->stream_uploader);
-
-   cso_set_vertex_buffers(st->cso_context, 0, 1, 0, false, &vb);
-   st->last_num_vbuffers = MAX2(st->last_num_vbuffers, 1);
-
-   cso_draw_arrays(st->cso_context, PIPE_PRIM_QUADS, 0, num_verts);
-
-out:
-   restore_render_state(ctx);
-
-   pipe_resource_reference(&vb.buffer.resource, NULL);
-
-   /* We uploaded modified constants, need to invalidate them. */
-   st->dirty |= ST_NEW_FS_CONSTANTS;
-}
-
 /** Per-context tear-down */
 void
 st_destroy_bitmap(struct st_context *st)
diff --git a/src/mesa/state_tracker/st_cb_bitmap.h b/src/mesa/state_tracker/st_cb_bitmap.h
index 0cc453031d54..8a75886d8069 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.h
+++ b/src/mesa/state_tracker/st_cb_bitmap.h
@@ -36,7 +36,6 @@ struct dd_function_table;
 struct st_context;
 struct gl_program;
 struct st_program;
-struct gl_bitmap_atlas;
 struct gl_context;
 struct gl_pixelstore_attrib;
 
@@ -49,7 +48,5 @@ st_flush_bitmap_cache(struct st_context *st);
 void st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
                GLsizei width, GLsizei height,
                const struct gl_pixelstore_attrib *unpack, const GLubyte *bitmap);
-void st_DrawAtlasBitmaps(struct gl_context *ctx,
-                         const struct gl_bitmap_atlas *atlas,
-                         GLuint count, const GLubyte *ids);
+
 #endif /* ST_CB_BITMAP_H */
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 005d18988cea..cf3445d8e7cd 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -280,7 +280,6 @@ struct st_context
    struct {
       struct pipe_rasterizer_state rasterizer;
       struct pipe_sampler_state sampler;
-      struct pipe_sampler_state atlas_sampler;
       enum pipe_format tex_format;
       struct st_bitmap_cache cache;
    } bitmap;
-- 
GitLab


From dfcdd04727fd40cb4dfec5f1f499566b8161d9ce Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 24 Jul 2022 20:47:26 -0400
Subject: [PATCH 2/4] mesa: create glBitmap textures while creating display
 lists

This makes glCallList just a textured draw, which is blazingly fast.

Reviewed-by: Brian Paul <brianp@vmware.com>
---
 src/mesa/main/dlist.c                 | 56 +++++++++++++++++----------
 src/mesa/main/draw.h                  |  5 +++
 src/mesa/main/drawpix.c               | 24 ++++++++----
 src/mesa/state_tracker/st_cb_bitmap.c | 55 ++++++++++++++++----------
 src/mesa/state_tracker/st_cb_bitmap.h |  8 +++-
 5 files changed, 98 insertions(+), 50 deletions(-)

diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index c4cddad47761..594e9c551a9b 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -52,8 +52,10 @@
 #include "util/u_memory.h"
 #include "api_exec_decl.h"
 
+#include "state_tracker/st_context.h"
 #include "state_tracker/st_cb_texture.h"
 #include "state_tracker/st_cb_bitmap.h"
+#include "state_tracker/st_sampler_view.h"
 
 static bool
 _mesa_glthread_should_execute_list(struct gl_context *ctx,
@@ -860,9 +862,11 @@ _mesa_delete_list(struct gl_context *ctx, struct gl_display_list *dlist)
          case OPCODE_DRAW_PIXELS:
             free(get_pointer(&n[5]));
             break;
-         case OPCODE_BITMAP:
-            free(get_pointer(&n[7]));
+         case OPCODE_BITMAP: {
+            struct pipe_resource *tex = get_pointer(&n[7]);
+            pipe_resource_reference(&tex, NULL);
             break;
+         }
          case OPCODE_POLYGON_STIPPLE:
             free(get_pointer(&n[1]));
             break;
@@ -1336,21 +1340,32 @@ save_Bitmap(GLsizei width, GLsizei height,
    GET_CURRENT_CONTEXT(ctx);
    Node *n;
    ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
+   struct pipe_resource *tex =
+      st_make_bitmap_texture(ctx, width, height, &ctx->Unpack, pixels);
+
+   if (!tex) {
+      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glNewList -> glBitmap");
+      return;
+   }
+
    n = alloc_instruction(ctx, OPCODE_BITMAP, 6 + POINTER_DWORDS);
-   if (n) {
-      n[1].i = (GLint) width;
-      n[2].i = (GLint) height;
-      n[3].f = xorig;
-      n[4].f = yorig;
-      n[5].f = xmove;
-      n[6].f = ymove;
-      save_pointer(&n[7],
-                   unpack_image(ctx, 2, width, height, 1, GL_COLOR_INDEX,
-                                GL_BITMAP, pixels, &ctx->Unpack));
+   if (!n) {
+      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glNewList -> glBitmap (3)");
+      pipe_resource_reference(&tex, NULL);
+      return;
    }
+
+   n[1].i = (GLint) width;
+   n[2].i = (GLint) height;
+   n[3].f = xorig;
+   n[4].f = yorig;
+   n[5].f = xmove;
+   n[6].f = ymove;
+   save_pointer(&n[7], tex);
+
    if (ctx->ExecuteFlag) {
-      CALL_Bitmap(ctx->Exec, (width, height,
-                              xorig, yorig, xmove, ymove, pixels));
+      ASSERT_OUTSIDE_BEGIN_END(ctx);
+      _mesa_bitmap(ctx, width, height, xorig, yorig, xmove, ymove, NULL, tex);
    }
 }
 
@@ -10853,13 +10868,12 @@ execute_list(struct gl_context *ctx, GLuint list)
             CALL_BindTexture(ctx->Exec, (n[1].e, n[2].ui));
             break;
          case OPCODE_BITMAP:
-            {
-               const struct gl_pixelstore_attrib save = ctx->Unpack;
-               ctx->Unpack = ctx->DefaultPacking;
-               CALL_Bitmap(ctx->Exec, ((GLsizei) n[1].i, (GLsizei) n[2].i,
-                                       n[3].f, n[4].f, n[5].f, n[6].f,
-                                       get_pointer(&n[7])));
-               ctx->Unpack = save;      /* restore */
+            if (_mesa_inside_begin_end(ctx)) {
+               _mesa_error(ctx, GL_INVALID_OPERATION,
+                           "glCallList -> glBitmap inside Begin/End");
+            } else {
+               _mesa_bitmap(ctx, n[1].i, n[2].i, n[3].f, n[4].f, n[5].f,
+                            n[6].f, NULL, get_pointer(&n[7]));
             }
             break;
          case OPCODE_BLEND_COLOR:
diff --git a/src/mesa/main/draw.h b/src/mesa/main/draw.h
index 7a59964118cf..aa65745dc3ac 100644
--- a/src/mesa/main/draw.h
+++ b/src/mesa/main/draw.h
@@ -101,6 +101,11 @@ _mesa_draw_gallium_multimode_fallback(struct gl_context *ctx,
                                      const unsigned char *mode,
                                      unsigned num_draws);
 
+void
+_mesa_bitmap(struct gl_context *ctx, GLsizei width, GLsizei height,
+             GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove,
+             const GLubyte *bitmap, struct pipe_resource *tex);
+
 #ifdef __cplusplus
 } // extern "C"
 #endif
diff --git a/src/mesa/main/drawpix.c b/src/mesa/main/drawpix.c
index 15c60f205fdd..627330dd2c88 100644
--- a/src/mesa/main/drawpix.c
+++ b/src/mesa/main/drawpix.c
@@ -316,13 +316,11 @@ end:
 }
 
 
-void GLAPIENTRY
-_mesa_Bitmap( GLsizei width, GLsizei height,
-              GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove,
-              const GLubyte *bitmap )
+void
+_mesa_bitmap(struct gl_context *ctx, GLsizei width, GLsizei height,
+             GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove,
+             const GLubyte *bitmap, struct pipe_resource *tex)
 {
-   GET_CURRENT_CONTEXT(ctx);
-
    FLUSH_VERTICES(ctx, 0, 0);
 
    if (width < 0 || height < 0) {
@@ -354,7 +352,7 @@ _mesa_Bitmap( GLsizei width, GLsizei height,
          GLint x = util_ifloor(ctx->Current.RasterPos[0] + epsilon - xorig);
          GLint y = util_ifloor(ctx->Current.RasterPos[1] + epsilon - yorig);
 
-         if (ctx->Unpack.BufferObj) {
+         if (!tex && ctx->Unpack.BufferObj) {
             /* unpack from PBO */
             if (!_mesa_validate_pbo_access(2, &ctx->Unpack, width, height,
                                            1, GL_COLOR_INDEX, GL_BITMAP,
@@ -371,7 +369,7 @@ _mesa_Bitmap( GLsizei width, GLsizei height,
             }
          }
 
-         st_Bitmap( ctx, x, y, width, height, &ctx->Unpack, bitmap );
+         st_Bitmap(ctx, x, y, width, height, &ctx->Unpack, bitmap, tex);
       }
    }
    else if (ctx->RenderMode == GL_FEEDBACK) {
@@ -396,3 +394,13 @@ _mesa_Bitmap( GLsizei width, GLsizei height,
       _mesa_flush(ctx);
    }
 }
+
+void GLAPIENTRY
+_mesa_Bitmap(GLsizei width, GLsizei height,
+             GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove,
+             const GLubyte *bitmap)
+{
+   GET_CURRENT_CONTEXT(ctx);
+
+   _mesa_bitmap(ctx, width, height, xorig, yorig, xmove, ymove, bitmap, NULL);
+}
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index 48c28eab00c6..8cc8b8f8feb4 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -88,6 +88,8 @@ static GLboolean UseBitmapCache = GL_TRUE;
 /** Epsilon for Z comparisons */
 #define Z_EPSILON 1e-06
 
+static void
+init_bitmap_state(struct st_context *st);
 
 /**
  * Copy user-provide bitmap bits into texture buffer, expanding
@@ -114,10 +116,10 @@ unpack_bitmap(struct st_context *st,
 /**
  * Create a texture which represents a bitmap image.
  */
-static struct pipe_resource *
-make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
-                    const struct gl_pixelstore_attrib *unpack,
-                    const GLubyte *bitmap)
+struct pipe_resource *
+st_make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
+                       const struct gl_pixelstore_attrib *unpack,
+                       const GLubyte *bitmap)
 {
    struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st->pipe;
@@ -125,6 +127,9 @@ make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
    ubyte *dest;
    struct pipe_resource *pt;
 
+   if (!st->bitmap.tex_format)
+      init_bitmap_state(st);
+
    /* PBO source... */
    bitmap = _mesa_map_pbo_source(ctx, unpack, bitmap);
    if (!bitmap) {
@@ -283,12 +288,13 @@ restore_render_state(struct gl_context *ctx)
 
 /**
  * Render a glBitmap by drawing a textured quad
+ *
+ * take_ownership means the callee will be resposible for unreferencing sv.
  */
 static void
 draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
                  GLsizei width, GLsizei height,
-                 struct pipe_sampler_view *sv,
-                 const GLfloat *color)
+                 struct pipe_sampler_view *sv, const GLfloat *color)
 {
    struct st_context *st = st_context(ctx);
    const float fb_width = (float) st->state.fb_width;
@@ -589,15 +595,17 @@ init_bitmap_state(struct st_context *st)
 void
 st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
           GLsizei width, GLsizei height,
-          const struct gl_pixelstore_attrib *unpack, const GLubyte *bitmap)
+          const struct gl_pixelstore_attrib *unpack, const GLubyte *bitmap,
+          struct pipe_resource *tex)
 {
    struct st_context *st = st_context(ctx);
-   struct pipe_resource *pt;
 
    assert(width > 0);
    assert(height > 0);
 
    st_invalidate_readpix_cache(st);
+   if (tex)
+      st_flush_bitmap_cache(st);
 
    if (!st->bitmap.tex_format) {
       init_bitmap_state(st);
@@ -613,23 +621,30 @@ st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
       st_validate_state(st, ST_PIPELINE_META);
    }
 
-   if (UseBitmapCache && accum_bitmap(ctx, x, y, width, height, unpack, bitmap))
-      return;
+   struct pipe_sampler_view *view = NULL;
 
-   pt = make_bitmap_texture(ctx, width, height, unpack, bitmap);
-   if (pt) {
-      struct pipe_sampler_view *sv =
-         st_create_texture_sampler_view(st->pipe, pt);
+   if (!tex) {
+      if (UseBitmapCache && accum_bitmap(ctx, x, y, width, height, unpack, bitmap))
+         return;
 
-      assert(pt->target == PIPE_TEXTURE_2D || pt->target == PIPE_TEXTURE_RECT);
+      struct pipe_resource *pt =
+         st_make_bitmap_texture(ctx, width, height, unpack, bitmap);
+      if (!pt)
+         return;
 
-      if (sv) {
-         draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
-                          width, height, sv, ctx->Current.RasterColor);
-      }
+      assert(pt->target == PIPE_TEXTURE_2D || pt->target == PIPE_TEXTURE_RECT);
 
-      /* release/free the texture */
+      view = st_create_texture_sampler_view(st->pipe, pt);
+      /* unreference the texture because it's referenced by sv */
       pipe_resource_reference(&pt, NULL);
+   } else {
+      /* tex comes from a display list. */
+      view = st_create_texture_sampler_view(st->pipe, tex);
+   }
+
+   if (view) {
+      draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
+                       width, height, view, ctx->Current.RasterColor);
    }
 }
 
diff --git a/src/mesa/state_tracker/st_cb_bitmap.h b/src/mesa/state_tracker/st_cb_bitmap.h
index 8a75886d8069..936d49d7a74a 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.h
+++ b/src/mesa/state_tracker/st_cb_bitmap.h
@@ -45,8 +45,14 @@ st_destroy_bitmap(struct st_context *st);
 extern void
 st_flush_bitmap_cache(struct st_context *st);
 
+struct pipe_resource *
+st_make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
+                       const struct gl_pixelstore_attrib *unpack,
+                       const GLubyte *bitmap);
+
 void st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
                GLsizei width, GLsizei height,
-               const struct gl_pixelstore_attrib *unpack, const GLubyte *bitmap);
+               const struct gl_pixelstore_attrib *unpack, const GLubyte *bitmap,
+               struct pipe_resource *tex);
 
 #endif /* ST_CB_BITMAP_H */
-- 
GitLab


From 448100034181dc048d6e3956b8dc0ea2120d72b8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 24 Jul 2022 20:36:00 -0400
Subject: [PATCH 3/4] st/mesa: fix potential use-after-free in draw_bitmap_quad

This is super unlikely to be freed before use, but let's fix it anyway.

setup_render_state calls set_sampler_views(take_ownership=true), which
means it takes ownership of the sampler view reference and is free to
unreference it, so we can't use sv after setup_render_state.

Fixes: feda6e9c5d101 - st/mesa: set take_ownership = true in set_sampler_views

Reviewed-by: Brian Paul <brianp@vmware.com>
Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/state_tracker/st_cb_bitmap.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index 8cc8b8f8feb4..c02e468e8125 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -321,17 +321,17 @@ draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
       assert(height <= (GLsizei) maxSize);
    }
 
-   setup_render_state(ctx, sv, color);
-
-   /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
-   z = z * 2.0f - 1.0f;
-
    if (sv->texture->target == PIPE_TEXTURE_RECT) {
       /* use non-normalized texcoords */
       sRight = (float) width;
       tBot = (float) height;
    }
 
+   setup_render_state(ctx, sv, color);
+
+   /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
+   z = z * 2.0f - 1.0f;
+
    if (!st_draw_quad(st, clip_x0, clip_y0, clip_x1, clip_y1, z,
                      sLeft, tBot, sRight, tTop, color, 0)) {
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBitmap");
-- 
GitLab


From fd25959d0ca5df86fda751f0e3f3c564e6134b13 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 24 Aug 2022 10:59:31 -0400
Subject: [PATCH 4/4] ci: update pass/fail results for spec@!opengl
 1.0@gl-1.0-dlist-bitmap

This is mostly positive.
---
 src/broadcom/ci/broadcom-rpi3-fails.txt           | 1 -
 src/broadcom/ci/broadcom-rpi4-fails.txt           | 1 -
 src/gallium/drivers/d3d12/ci/d3d12-quick_gl.txt   | 1 -
 src/gallium/drivers/lima/ci/lima-fails.txt        | 1 +
 src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt | 1 -
 5 files changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/broadcom/ci/broadcom-rpi3-fails.txt b/src/broadcom/ci/broadcom-rpi3-fails.txt
index 0a8edaeb1908..d2d56d6d5efe 100644
--- a/src/broadcom/ci/broadcom-rpi3-fails.txt
+++ b/src/broadcom/ci/broadcom-rpi3-fails.txt
@@ -124,7 +124,6 @@ shaders@glsl-bug-110796,Fail
 shaders@glsl-max-vertex-attrib,Fail
 shaders@glsl-predication-on-large-array,Fail
 spec@!opengl 1.0@gl-1.0-bitmap-heart-dance,Fail
-spec@!opengl 1.0@gl-1.0-dlist-bitmap,Crash
 spec@!opengl 1.0@gl-1.0-drawbuffer-modes,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag-const,Fail
diff --git a/src/broadcom/ci/broadcom-rpi4-fails.txt b/src/broadcom/ci/broadcom-rpi4-fails.txt
index fa3d432cbde4..4a14b26b91a5 100644
--- a/src/broadcom/ci/broadcom-rpi4-fails.txt
+++ b/src/broadcom/ci/broadcom-rpi4-fails.txt
@@ -16,7 +16,6 @@ glx@glx_ext_import_context@make current- single process,Fail
 glx@glx_ext_import_context@query context info,Fail
 shaders@glsl-bug-110796,Fail
 spec@!opengl 1.0@gl-1.0-bitmap-heart-dance,Fail
-spec@!opengl 1.0@gl-1.0-dlist-bitmap,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag-const,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag-quads,Fail
diff --git a/src/gallium/drivers/d3d12/ci/d3d12-quick_gl.txt b/src/gallium/drivers/d3d12/ci/d3d12-quick_gl.txt
index 80b8a143c836..622a5a0f98da 100644
--- a/src/gallium/drivers/d3d12/ci/d3d12-quick_gl.txt
+++ b/src/gallium/drivers/d3d12/ci/d3d12-quick_gl.txt
@@ -51,7 +51,6 @@ shaders/useshaderprogram-bad-type: skip
 shaders/useshaderprogram-flushverts-1: skip
 spec/!opengl 1.0/gl-1.0-beginend-coverage/glflush: fail
 spec/!opengl 1.0/gl-1.0-blend-func: fail
-spec/!opengl 1.0/gl-1.0-dlist-bitmap: fail
 spec/!opengl 1.0/gl-1.0-long-line-loop: fail
 spec/!opengl 1.0/gl-1.0-no-op-paths: fail
 spec/!opengl 1.0/gl-1.0-simple-readbuffer: fail
diff --git a/src/gallium/drivers/lima/ci/lima-fails.txt b/src/gallium/drivers/lima/ci/lima-fails.txt
index de8ae03d26e7..9121599b7e6e 100644
--- a/src/gallium/drivers/lima/ci/lima-fails.txt
+++ b/src/gallium/drivers/lima/ci/lima-fails.txt
@@ -544,6 +544,7 @@ spec@khr_texture_compression_astc@basic-gles,Fail
 spec@khr_texture_compression_astc@miptree-gles srgb,Fail
 spec@khr_texture_compression_astc@miptree-gles srgb-fp,Fail
 spec@oes_point_sprite@arb_point_sprite-checkerboard_gles1,Fail
+spec@!opengl 1.0@gl-1.0-dlist-bitmap,Fail
 spec@!opengl 1.0@gl-1.0-dlist-materials,Fail
 spec@!opengl 1.0@gl-1.0-dlist-shademodel,Fail
 spec@!opengl 1.0@gl-1.0-drawbuffer-modes,Fail
diff --git a/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt b/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt
index d1029abf29d9..33387e6fd2cd 100644
--- a/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt
+++ b/src/gallium/drivers/virgl/ci/virpipe-gl-fails.txt
@@ -122,7 +122,6 @@ shaders@point-vertex-id gl_vertexid,Fail
 shaders@point-vertex-id gl_vertexid divisor,Fail
 shaders@point-vertex-id gl_vertexid gl_instanceid,Fail
 shaders@point-vertex-id gl_vertexid gl_instanceid divisor,Fail
-spec@!opengl 1.0@gl-1.0-dlist-bitmap,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag,Fail
 spec@!opengl 1.0@gl-1.0-edgeflag-quads,Fail
 spec@!opengl 1.0@gl-1.0-swapbuffers-behavior,Fail
-- 
GitLab

