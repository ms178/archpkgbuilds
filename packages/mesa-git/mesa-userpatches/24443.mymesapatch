From 8d124716a3fceb05d9b530fc210a49fe88ed8351 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 7 Jul 2023 15:50:13 +0800
Subject: [PATCH 01/21] aco: add p_end_with_regs pseudo instruction

Used by radeonsi shader parts to pass args from one part to another.
It has variable number of operands to reserve fixed registers with
wanted value.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 3 ++-
 src/amd/compiler/aco_opcodes.py           | 4 ++++
 src/amd/compiler/aco_scheduler.cpp        | 3 ++-
 src/amd/compiler/aco_validate.cpp         | 1 +
 4 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index 859a3cd04d1f2..1a04dd1582f97 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -103,7 +103,8 @@ needs_exact(aco_ptr<Instruction>& instr)
        * epilog without considering the exec mask.
        */
       return instr->isEXP() || instr->opcode == aco_opcode::p_jump_to_epilog ||
-             instr->opcode == aco_opcode::p_dual_src_export_gfx11;
+             instr->opcode == aco_opcode::p_dual_src_export_gfx11 ||
+             instr->opcode == aco_opcode::p_end_with_regs;
    }
 }
 
diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index 04b2645b61aa4..c6766934aa430 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -375,6 +375,10 @@ opcode("p_interp_gfx11")
 # performs dual source MRTs swizzling and emits exports on GFX11
 opcode("p_dual_src_export_gfx11")
 
+# Let shader end with specific registers set to wanted value, used by multi part
+# shader to pass arguments to next part.
+opcode("p_end_with_regs")
+
 # SOP2 instructions: 2 scalar inputs, 1 scalar output (+optional scc)
 SOP2 = {
   # GFX6, GFX7, GFX8, GFX9, GFX10,GFX11,name
diff --git a/src/amd/compiler/aco_scheduler.cpp b/src/amd/compiler/aco_scheduler.cpp
index d0cd09db36259..592e42c54c42c 100644
--- a/src/amd/compiler/aco_scheduler.cpp
+++ b/src/amd/compiler/aco_scheduler.cpp
@@ -611,7 +611,8 @@ perform_hazard_query(hazard_query* query, Instruction* instr, bool upwards)
        instr->opcode == aco_opcode::p_init_scratch ||
        instr->opcode == aco_opcode::p_jump_to_epilog ||
        instr->opcode == aco_opcode::s_sendmsg_rtn_b32 ||
-       instr->opcode == aco_opcode::s_sendmsg_rtn_b64)
+       instr->opcode == aco_opcode::s_sendmsg_rtn_b64 ||
+       instr->opcode == aco_opcode::p_end_with_regs)
       return hazard_fail_unreorderable;
 
    memory_event_set instr_set;
diff --git a/src/amd/compiler/aco_validate.cpp b/src/amd/compiler/aco_validate.cpp
index 506ff8039a681..781a25538af9b 100644
--- a/src/amd/compiler/aco_validate.cpp
+++ b/src/amd/compiler/aco_validate.cpp
@@ -266,6 +266,7 @@ validate_ir(Program* program)
                                    instr->opcode == aco_opcode::p_create_vector ||
                                    instr->opcode == aco_opcode::p_jump_to_epilog ||
                                    instr->opcode == aco_opcode::p_dual_src_export_gfx11 ||
+                                   instr->opcode == aco_opcode::p_end_with_regs ||
                                    (instr->opcode == aco_opcode::p_interp_gfx11 && i == 0) ||
                                    (instr->opcode == aco_opcode::p_bpermute_gfx11w64 && i == 0) ||
                                    (flat && i == 1) || (instr->isMIMG() && (i == 1 || i == 2)) ||
-- 
GitLab


From e0b663093e67a3060ff2dd6aedae9ceeddd2feae Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 2 Aug 2023 17:12:09 +0800
Subject: [PATCH 02/21] aco: move jump to epilog out of ic_merged_wave_info

TCS may be wrapped with if/else when merged shader. Jump
to epilog or end with regs should not be inside it.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 2a392b59edd4b..2b0178432ec92 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11294,6 +11294,11 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
    nir_function_impl* func = nir_shader_get_entrypoint(nir);
    visit_cf_list(&ctx, &func->body);
 
+   if (endif_merged_wave_info) {
+      begin_divergent_if_else(&ctx, ic_merged_wave_info);
+      end_divergent_if(&ctx, ic_merged_wave_info);
+   }
+
    if (ctx.program->info.has_epilog) {
       if (ctx.stage == fragment_fs) {
          create_fs_jump_to_epilog(&ctx);
@@ -11307,11 +11312,6 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
       }
    }
 
-   if (endif_merged_wave_info) {
-      begin_divergent_if_else(&ctx, ic_merged_wave_info);
-      end_divergent_if(&ctx, ic_merged_wave_info);
-   }
-
    cleanup_context(&ctx);
 }
 
-- 
GitLab


From baa8742f38ba1cd84153756777655ee5f79b74ca Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 20 Jul 2023 10:16:29 +0800
Subject: [PATCH 03/21] aco: add tcs end regs for epilog usage

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 91 +++++++++++++++++--
 src/amd/compiler/aco_shader_info.h            |  8 ++
 2 files changed, 89 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 2b0178432ec92..6bb5e77a49ee2 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10854,12 +10854,89 @@ create_fs_jump_to_epilog(isel_context* ctx)
    ctx->block->instructions.emplace_back(std::move(jump));
 }
 
+PhysReg
+get_arg_reg(const struct ac_shader_args* args, struct ac_arg arg)
+{
+   assert(arg.used);
+   enum ac_arg_regfile file = args->args[arg.arg_index].file;
+   unsigned reg = args->args[arg.arg_index].offset;
+   return PhysReg(file == AC_ARG_SGPR ? reg : reg + 256);
+}
+
+static Operand
+get_arg_for_end(isel_context* ctx, struct ac_arg arg)
+{
+   return Operand(get_arg(ctx, arg), get_arg_reg(ctx->args, arg));
+}
+
 static void
 create_tcs_jump_to_epilog(isel_context* ctx)
 {
    /* TODO */
 }
 
+static void
+create_tcs_end_for_epilog(isel_context* ctx)
+{
+   std::vector<Operand> regs;
+
+   regs.emplace_back(get_arg_for_end(ctx, ctx->program->info.tcs.tcs_offchip_layout));
+   regs.emplace_back(get_arg_for_end(ctx, ctx->program->info.tcs.tes_offchip_addr));
+   regs.emplace_back(get_arg_for_end(ctx, ctx->args->tess_offchip_offset));
+   regs.emplace_back(get_arg_for_end(ctx, ctx->args->tcs_factor_offset));
+
+   Builder bld(ctx->program, ctx->block);
+
+   /* Leave a hole corresponding to the two input VGPRs. This ensures that
+    * the invocation_id output does not alias the tcs_rel_ids input,
+    * which saves a V_MOV on gfx9.
+    */
+   unsigned vgpr = 256 + ctx->args->num_vgprs_used;
+
+   Temp rel_patch_id =
+      bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), get_arg(ctx, ctx->args->tcs_rel_ids),
+               Operand::c32(0u), Operand::c32(8u));
+   regs.emplace_back(Operand(rel_patch_id, PhysReg{vgpr++}));
+
+   Temp invocation_id =
+      bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), get_arg(ctx, ctx->args->tcs_rel_ids),
+               Operand::c32(8u), Operand::c32(5u));
+   regs.emplace_back(Operand(invocation_id, PhysReg{vgpr++}));
+
+   if (ctx->program->info.tcs.pass_tessfactors_by_reg) {
+      vgpr++; /* skip the tess factor LDS offset */
+
+      unsigned slot = VARYING_SLOT_TESS_LEVEL_OUTER;
+      u_foreach_bit (i, ctx->outputs.mask[slot]) {
+         regs.emplace_back(Operand(ctx->outputs.temps[slot * 4 + i], PhysReg{vgpr + i}));
+      }
+      vgpr += 4;
+
+      slot = VARYING_SLOT_TESS_LEVEL_INNER;
+      u_foreach_bit (i, ctx->outputs.mask[slot]) {
+         regs.emplace_back(Operand(ctx->outputs.temps[slot * 4 + i], PhysReg{vgpr + i}));
+      }
+   } else {
+      Temp patch0_patch_data_offset =
+         bld.sop2(aco_opcode::s_bfe_u32, bld.def(s1), bld.def(s1, scc),
+                  get_arg(ctx, ctx->program->info.tcs.vs_state_bits), Operand::c32(0xe000a));
+
+      Temp tf_lds_offset =
+         bld.v_mul24_imm(bld.def(v1), rel_patch_id, ctx->program->info.tcs.patch_stride);
+      tf_lds_offset = bld.nuw().vadd32(bld.def(v1), tf_lds_offset, patch0_patch_data_offset);
+
+      regs.emplace_back(Operand(tf_lds_offset, PhysReg{vgpr}));
+   }
+
+   aco_ptr<Pseudo_instruction> end{create_instruction<Pseudo_instruction>(
+      aco_opcode::p_end_with_regs, Format::PSEUDO, regs.size(), 0)};
+
+   for (unsigned i = 0; i < regs.size(); i++)
+      end->operands[i] = regs[i];
+
+   ctx->block->instructions.emplace_back(std::move(end));
+}
+
 Pseudo_instruction*
 add_startpgm(struct isel_context* ctx)
 {
@@ -11308,7 +11385,10 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
          ctx.block->kind |= block_kind_export_end;
       } else {
          assert(ctx.stage == tess_control_hs);
-         create_tcs_jump_to_epilog(&ctx);
+         if (ctx.options->is_opengl)
+            create_tcs_end_for_epilog(&ctx);
+         else
+            create_tcs_jump_to_epilog(&ctx);
       }
    }
 
@@ -11450,15 +11530,6 @@ select_trap_handler_shader(Program* program, struct nir_shader* shader, ac_shade
    cleanup_cfg(program);
 }
 
-PhysReg
-get_arg_reg(const struct ac_shader_args* args, struct ac_arg arg)
-{
-   assert(arg.used);
-   enum ac_arg_regfile file = args->args[arg.arg_index].file;
-   unsigned reg = args->args[arg.arg_index].offset;
-   return PhysReg(file == AC_ARG_SGPR ? reg : reg + 256);
-}
-
 Operand
 get_arg_fixed(const struct ac_shader_args* args, struct ac_arg arg)
 {
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 339194d54b20a..43982a9d1bf1d 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -96,7 +96,15 @@ struct aco_shader_info {
       bool has_prolog;
    } vs;
    struct {
+      /* Vulkan only */
       uint32_t num_lds_blocks;
+
+      /* OpenGL only */
+      bool pass_tessfactors_by_reg;
+      unsigned patch_stride;
+      struct ac_arg tcs_offchip_layout;
+      struct ac_arg tes_offchip_addr;
+      struct ac_arg vs_state_bits;
    } tcs;
    struct {
       struct ac_arg epilog_pc;
-- 
GitLab


From 84b26b1a4789f78bf50da6e24496d4203aba4705 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 20 Jul 2023 11:41:00 +0800
Subject: [PATCH 04/21] aco: allow tcs with epilog to keep nir store output
 instruction

Used to same tess factor outputs.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 6bb5e77a49ee2..86c50429747d2 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5258,9 +5258,13 @@ visit_store_output(isel_context* ctx, nir_intrinsic_instr* instr)
    bool ls_need_output = ctx->stage == vertex_tess_control_hs &&
                          ctx->shader->info.stage == MESA_SHADER_VERTEX && ctx->tcs_in_out_eq;
 
+   bool tcs_need_output = ctx->shader->info.stage == MESA_SHADER_TESS_CTRL &&
+                          ctx->program->info.has_epilog &&
+                          ctx->program->info.tcs.pass_tessfactors_by_reg;
+
    bool ps_need_output = ctx->stage == fragment_fs;
 
-   if (ls_need_output || ps_need_output) {
+   if (ls_need_output || tcs_need_output || ps_need_output) {
       bool stored_to_temps = store_output_to_temps(ctx, instr);
       if (!stored_to_temps) {
          isel_err(instr->src[1].ssa->parent_instr, "Unimplemented output offset instruction");
-- 
GitLab


From 843835dd394dbe14ca124e235d7afd9114237163 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 25 Mar 2023 09:31:03 +0800
Subject: [PATCH 05/21] aco: add tcs epilog generation for radeonsi

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 221 +++++++++++++++++-
 src/amd/compiler/aco_shader_info.h            |  11 +
 2 files changed, 229 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 86c50429747d2..28d989aba35bf 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11445,6 +11445,63 @@ select_program_merged(isel_context& ctx, const unsigned shader_count, nir_shader
    }
 }
 
+Temp
+get_tess_ring_descriptor(isel_context* ctx, const struct aco_tcs_epilog_info* einfo,
+                         bool is_tcs_factor_ring)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   Temp addr = get_arg(ctx, einfo->tcs_out_lds_layout);
+   /* TCS only receives high 13 bits of the address. */
+   addr = bld.sop2(aco_opcode::s_and_b32, bld.def(s1), bld.def(s1, scc), addr,
+                   Operand::c32(0xfff80000));
+
+   if (is_tcs_factor_ring) {
+      addr = bld.sop2(aco_opcode::s_add_u32, bld.def(s1), bld.def(s1, scc), addr,
+                      Operand::c32(einfo->tess_offchip_ring_size));
+   }
+
+   uint32_t rsrc3 = S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) | S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
+                    S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) | S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W);
+
+   if (ctx->options->gfx_level >= GFX11) {
+      rsrc3 |= S_008F0C_FORMAT(V_008F0C_GFX11_FORMAT_32_FLOAT) |
+               S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW);
+   } else if (ctx->options->gfx_level >= GFX10) {
+      rsrc3 |= S_008F0C_FORMAT(V_008F0C_GFX10_FORMAT_32_FLOAT) |
+               S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW) | S_008F0C_RESOURCE_LEVEL(1);
+   } else {
+      rsrc3 |= S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) |
+               S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);
+   }
+
+   return bld.pseudo(aco_opcode::p_create_vector, bld.def(s4), addr,
+                     Operand::c32(ctx->options->address32_hi), Operand::c32(0xffffffff),
+                     Operand::c32(rsrc3));
+}
+
+void
+store_tess_factor_to_tess_ring(isel_context* ctx, Temp tess_ring_desc, Temp factors[],
+                               unsigned factor_comps, Temp sbase, Temp voffset, Temp num_patches,
+                               unsigned patch_offset)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   Temp soffset = sbase;
+   if (patch_offset) {
+      Temp offset =
+         bld.sop2(aco_opcode::s_mul_i32, bld.def(s1), num_patches, Operand::c32(patch_offset));
+      soffset = bld.sop2(aco_opcode::s_add_u32, bld.def(s1), bld.def(s1, scc), soffset, offset);
+   }
+
+   Temp data = factor_comps == 1
+                  ? factors[0]
+                  : create_vec_from_array(ctx, factors, factor_comps, RegType::vgpr, 4);
+
+   emit_single_mubuf_store(ctx, tess_ring_desc, voffset, soffset, Temp(), data, 0,
+                           memory_sync_info(storage_vmem_output), true, false, false);
+}
+
 } /* end namespace */
 
 void
@@ -12103,7 +12160,7 @@ select_tcs_epilog(Program* program, void* pinfo, ac_shader_config* config,
                   const struct aco_compiler_options* options, const struct aco_shader_info* info,
                   const struct ac_shader_args* args)
 {
-   UNUSED const struct aco_tcs_epilog_info* einfo = (const struct aco_tcs_epilog_info*)pinfo;
+   const struct aco_tcs_epilog_info* einfo = (const struct aco_tcs_epilog_info*)pinfo;
    isel_context ctx =
       setup_isel_context(program, 0, NULL, config, options, info, args, false, true);
 
@@ -12114,12 +12171,170 @@ select_tcs_epilog(Program* program, void* pinfo, ac_shader_config* config,
 
    Builder bld(ctx.program, ctx.block);
 
-   /* TODO */
+   /* Add a barrier before loading tess factors from LDS. */
+   if (!einfo->pass_tessfactors_by_reg) {
+      wait_imm lgkm_imm;
+      lgkm_imm.lgkm = 0;
+      bld.sopp(aco_opcode::s_waitcnt, -1, lgkm_imm.pack(program->gfx_level));
+
+      if (!einfo->tcs_out_patch_fits_subgroup)
+         bld.sopp(aco_opcode::s_barrier, -1u, 0u);
+   }
+
+   Temp invocation_id = get_arg(&ctx, einfo->invocation_id);
+
+   Temp cond = bld.vopc(aco_opcode::v_cmp_eq_u32, bld.def(bld.lm), Operand::zero(), invocation_id);
+
+   if_context ic_invoc_0;
+   begin_divergent_if_then(&ctx, &ic_invoc_0, cond);
+
+   int outer_comps, inner_comps;
+   switch (einfo->primitive_mode) {
+   case TESS_PRIMITIVE_ISOLINES:
+      outer_comps = 2;
+      inner_comps = 0;
+      break;
+   case TESS_PRIMITIVE_TRIANGLES:
+      outer_comps = 3;
+      inner_comps = 1;
+      break;
+   case TESS_PRIMITIVE_QUADS:
+      outer_comps = 4;
+      inner_comps = 2;
+      break;
+   default: unreachable("invalid primitive mode"); return;
+   }
+
+   bld.reset(ctx.block);
+
+   unsigned tess_lvl_out_loc =
+      ac_shader_io_get_unique_index_patch(VARYING_SLOT_TESS_LEVEL_OUTER) * 16;
+   unsigned tess_lvl_in_loc =
+      ac_shader_io_get_unique_index_patch(VARYING_SLOT_TESS_LEVEL_INNER) * 16;
+
+   Temp outer[4];
+   Temp inner[2];
+   if (einfo->pass_tessfactors_by_reg) {
+      for (int i = 0; i < outer_comps; i++)
+         outer[i] = get_arg(&ctx, einfo->tess_lvl_out[i]);
+
+      for (int i = 0; i < inner_comps; i++)
+         inner[i] = get_arg(&ctx, einfo->tess_lvl_in[i]);
+   } else {
+      Temp addr = get_arg(&ctx, einfo->tcs_out_current_patch_data_offset);
+      addr = bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(2), addr);
+
+      Temp data = program->allocateTmp(RegClass(RegType::vgpr, outer_comps));
+      load_lds(&ctx, 4, outer_comps, data, addr, tess_lvl_out_loc, 16);
+      for (int i = 0; i < outer_comps; i++)
+         outer[i] = emit_extract_vector(&ctx, data, i, v1);
+
+      if (inner_comps) {
+         data = program->allocateTmp(RegClass(RegType::vgpr, inner_comps));
+         load_lds(&ctx, 4, inner_comps, data, addr, tess_lvl_in_loc, 16);
+         for (int i = 0; i < inner_comps; i++)
+            inner[i] = emit_extract_vector(&ctx, data, i, v1);
+      }
+   }
+
+   Temp tess_factor_ring_desc = get_tess_ring_descriptor(&ctx, einfo, true);
+   Temp tess_factor_ring_base = get_arg(&ctx, args->tcs_factor_offset);
+   Temp rel_patch_id = get_arg(&ctx, einfo->rel_patch_id);
+   unsigned tess_factor_ring_const_offset = 0;
+
+   if (program->gfx_level <= GFX8) {
+      /* Store the dynamic HS control word. */
+      cond = bld.vopc(aco_opcode::v_cmp_eq_u32, bld.def(bld.lm), Operand::zero(), rel_patch_id);
+
+      if_context ic_patch_0;
+      begin_divergent_if_then(&ctx, &ic_patch_0, cond);
+
+      bld.reset(ctx.block);
+
+      Temp data = bld.copy(bld.def(v1), Operand::c32(0x80000000u));
+
+      emit_single_mubuf_store(&ctx, tess_factor_ring_desc, Temp(0, v1), tess_factor_ring_base,
+                              Temp(), data, 0, memory_sync_info(), true, false, false);
+
+      tess_factor_ring_const_offset += 4;
+
+      begin_divergent_if_else(&ctx, &ic_patch_0);
+      end_divergent_if(&ctx, &ic_patch_0);
+   }
+
+   bld.reset(ctx.block);
+
+   Temp tess_factor_ring_offset =
+      bld.v_mul_imm(bld.def(v1), rel_patch_id, (inner_comps + outer_comps) * 4, false);
+
+   switch (einfo->primitive_mode) {
+   case TESS_PRIMITIVE_ISOLINES: {
+      /* For isolines, the hardware expects tess factors in the reverse order. */
+      Temp data = bld.pseudo(aco_opcode::p_create_vector, bld.def(v2), outer[1], outer[0]);
+      emit_single_mubuf_store(&ctx, tess_factor_ring_desc, tess_factor_ring_offset,
+                              tess_factor_ring_base, Temp(), data, tess_factor_ring_const_offset,
+                              memory_sync_info(), true, false, false);
+      break;
+   }
+   case TESS_PRIMITIVE_TRIANGLES: {
+      Temp data = bld.pseudo(aco_opcode::p_create_vector, bld.def(v4), outer[0], outer[1], outer[2],
+                             inner[0]);
+      emit_single_mubuf_store(&ctx, tess_factor_ring_desc, tess_factor_ring_offset,
+                              tess_factor_ring_base, Temp(), data, tess_factor_ring_const_offset,
+                              memory_sync_info(), true, false, false);
+      break;
+   }
+   case TESS_PRIMITIVE_QUADS: {
+      Temp data = bld.pseudo(aco_opcode::p_create_vector, bld.def(v4), outer[0], outer[1], outer[2],
+                             outer[3]);
+      emit_single_mubuf_store(&ctx, tess_factor_ring_desc, tess_factor_ring_offset,
+                              tess_factor_ring_base, Temp(), data, tess_factor_ring_const_offset,
+                              memory_sync_info(), true, false, false);
+
+      data = bld.pseudo(aco_opcode::p_create_vector, bld.def(v2), inner[0], inner[1]);
+      emit_single_mubuf_store(
+         &ctx, tess_factor_ring_desc, tess_factor_ring_offset, tess_factor_ring_base, Temp(), data,
+         tess_factor_ring_const_offset + 16, memory_sync_info(), true, false, false);
+      break;
+   }
+   default: unreachable("invalid primitive mode"); break;
+   }
+
+   if (einfo->tes_reads_tessfactors) {
+      Temp layout = get_arg(&ctx, einfo->tcs_offchip_layout);
+      Temp num_patches =
+         bld.sop2(aco_opcode::s_and_b32, bld.def(s1), bld.def(s1, scc), layout, Operand::c32(0x3f));
+      num_patches = bld.sop2(aco_opcode::s_add_u32, bld.def(s1), bld.def(s1, scc), num_patches,
+                             Operand::c32(1));
+
+      Temp patch_base =
+         bld.sop2(aco_opcode::s_lshr_b32, bld.def(s1), bld.def(s1, scc), layout, Operand::c32(16));
+
+      Temp tess_ring_desc = get_tess_ring_descriptor(&ctx, einfo, false);
+      Temp tess_ring_base = get_arg(&ctx, args->tess_offchip_offset);
+
+      Temp sbase =
+         bld.sop2(aco_opcode::s_add_u32, bld.def(s1), bld.def(s1, scc), tess_ring_base, patch_base);
+
+      Temp voffset =
+         bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(4), rel_patch_id);
+
+      store_tess_factor_to_tess_ring(&ctx, tess_ring_desc, outer, outer_comps, sbase, voffset,
+                                     num_patches, tess_lvl_out_loc);
+
+      if (inner_comps) {
+         store_tess_factor_to_tess_ring(&ctx, tess_ring_desc, inner, inner_comps, sbase, voffset,
+                                        num_patches, tess_lvl_in_loc);
+      }
+   }
+
+   begin_divergent_if_else(&ctx, &ic_invoc_0);
+   end_divergent_if(&ctx, &ic_invoc_0);
 
    program->config->float_mode = program->blocks[0].fp_mode.val;
 
    append_logical_end(ctx.block);
-   ctx.block->kind |= block_kind_export_end;
+
    bld.reset(ctx.block);
    bld.sopp(aco_opcode::s_endpgm);
 
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 43982a9d1bf1d..0a98bda4b3f28 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -78,8 +78,19 @@ struct aco_ps_epilog_info {
 };
 
 struct aco_tcs_epilog_info {
+   bool pass_tessfactors_by_reg;
+   bool tcs_out_patch_fits_subgroup;
    enum tess_primitive_mode primitive_mode;
+   unsigned tess_offchip_ring_size;
    bool tes_reads_tessfactors;
+
+   struct ac_arg invocation_id;
+   struct ac_arg rel_patch_id;
+   struct ac_arg tcs_out_current_patch_data_offset;
+   struct ac_arg tess_lvl_in[2];
+   struct ac_arg tess_lvl_out[4];
+   struct ac_arg tcs_out_lds_layout;
+   struct ac_arg tcs_offchip_layout;
 };
 
 struct aco_shader_info {
-- 
GitLab


From b9675f46229fb7823d8e6c6eeef4adb7f14c11d2 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 25 Jul 2023 14:00:17 +0800
Subject: [PATCH 06/21] aco: don't emit s_endpgm for tcs with epilog

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp             |  6 ++++--
 src/amd/compiler/aco_instruction_selection.cpp |  7 +++++--
 src/amd/compiler/aco_interface.cpp             | 12 ++++++++----
 src/amd/compiler/aco_ir.h                      |  2 +-
 src/amd/compiler/tests/helpers.cpp             |  2 +-
 5 files changed, 19 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 52b6528ac8476..7e6aa4eea4836 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -1279,7 +1279,8 @@ align_block(asm_context& ctx, std::vector<uint32_t>& code, Block& block)
 }
 
 unsigned
-emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct aco_symbol>* symbols)
+emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct aco_symbol>* symbols,
+             bool append_endpgm)
 {
    asm_context ctx(program, symbols);
 
@@ -1298,7 +1299,8 @@ emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct a
    unsigned exec_size = code.size() * sizeof(uint32_t);
 
    /* Add end-of-code markers for the UMR disassembler. */
-   code.resize(code.size() + 5, 0xbf9f0000u);
+   if (append_endpgm)
+      code.resize(code.size() + 5, 0xbf9f0000u);
 
    fix_constaddrs(ctx, code);
 
diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 28d989aba35bf..9408c8dd4793b 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11525,8 +11525,11 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
 
    append_logical_end(ctx.block);
    ctx.block->kind |= block_kind_uniform;
-   Builder bld(ctx.program, ctx.block);
-   bld.sopp(aco_opcode::s_endpgm);
+
+   if (!ctx.program->info.has_epilog) {
+      Builder bld(ctx.program, ctx.block);
+      bld.sopp(aco_opcode::s_endpgm);
+   }
 
    cleanup_cfg(program);
 }
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index fccad69a5c03d..3b5148b6be459 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -236,7 +236,11 @@ aco_compile_shader(const struct aco_compiler_options* options, const struct aco_
    /* assembly */
    std::vector<uint32_t> code;
    std::vector<struct aco_symbol> symbols;
-   unsigned exec_size = aco::emit_program(program.get(), code, &symbols);
+   /* OpenGL combine multi shader parts into one continous code block,
+    * so only last part need the s_endpgm instruction.
+    */
+   bool append_endpgm = !(options->is_opengl && info->has_epilog);
+   unsigned exec_size = aco::emit_program(program.get(), code, &symbols, append_endpgm);
 
    if (program->collect_statistics)
       aco::collect_postasm_stats(program.get(), code);
@@ -284,7 +288,7 @@ aco_compile_rt_prolog(const struct aco_compiler_options* options,
    /* assembly */
    std::vector<uint32_t> code;
    code.reserve(align(program->blocks[0].instructions.size() * 2, 16));
-   unsigned exec_size = aco::emit_program(program.get(), code, NULL);
+   unsigned exec_size = aco::emit_program(program.get(), code);
 
    bool get_disasm = options->dump_shader || options->record_ir;
 
@@ -322,7 +326,7 @@ aco_compile_vs_prolog(const struct aco_compiler_options* options,
    /* assembly */
    std::vector<uint32_t> code;
    code.reserve(align(program->blocks[0].instructions.size() * 2, 16));
-   unsigned exec_size = aco::emit_program(program.get(), code, NULL);
+   unsigned exec_size = aco::emit_program(program.get(), code);
 
    bool get_disasm = options->dump_shader || options->record_ir;
 
@@ -365,7 +369,7 @@ aco_compile_shader_part(const struct aco_compiler_options* options,
 
    /* assembly */
    std::vector<uint32_t> code;
-   unsigned exec_size = aco::emit_program(program.get(), code, NULL);
+   unsigned exec_size = aco::emit_program(program.get(), code);
 
    bool get_disasm = options->dump_shader || options->record_ir;
 
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index b1f0280437efa..58f6b046859e0 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2259,7 +2259,7 @@ bool dealloc_vgprs(Program* program);
 void insert_NOPs(Program* program);
 void form_hard_clauses(Program* program);
 unsigned emit_program(Program* program, std::vector<uint32_t>& code,
-                      std::vector<struct aco_symbol>* symbols);
+                      std::vector<struct aco_symbol>* symbols = NULL, bool append_endpgm = true);
 /**
  * Returns true if print_asm can disassemble the given program for the current build/runtime
  * configuration
diff --git a/src/amd/compiler/tests/helpers.cpp b/src/amd/compiler/tests/helpers.cpp
index caa8b51eeeb19..407b1d7eb8108 100644
--- a/src/amd/compiler/tests/helpers.cpp
+++ b/src/amd/compiler/tests/helpers.cpp
@@ -269,7 +269,7 @@ finish_assembler_test()
 {
    finish_program(program.get());
    std::vector<uint32_t> binary;
-   unsigned exec_size = emit_program(program.get(), binary, NULL);
+   unsigned exec_size = emit_program(program.get(), binary);
 
    /* we could use CLRX for disassembly but that would require it to be
     * installed */
-- 
GitLab


From 2e1a423dc184b8e2c6c8c482f99507bd31079ac0 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 25 Jul 2023 11:19:47 +0800
Subject: [PATCH 07/21] aco: skip scratch init when no scratch arg provide

epilog does not use scratch so has no scratch arg.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 38 ++++++++++---------
 1 file changed, 21 insertions(+), 17 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 9408c8dd4793b..591dfca2b3423 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10988,26 +10988,30 @@ add_startpgm(struct isel_context* ctx)
       }
    }
 
-   if (ctx->program->gfx_level < GFX9) {
-      /* Stash these in the program so that they can be accessed later when
-       * handling spilling.
-       */
-      if (ctx->args->ring_offsets.used)
-         ctx->program->private_segment_buffer = get_arg(ctx, ctx->args->ring_offsets);
+   /* epilog has no scratch */
+   if (ctx->args->scratch_offset.used) {
+      if (ctx->program->gfx_level < GFX9) {
+         /* Stash these in the program so that they can be accessed later when
+          * handling spilling.
+          */
+         if (ctx->args->ring_offsets.used)
+            ctx->program->private_segment_buffer = get_arg(ctx, ctx->args->ring_offsets);
 
-      ctx->program->scratch_offset = get_arg(ctx, ctx->args->scratch_offset);
-   } else if (ctx->program->gfx_level <= GFX10_3 && ctx->program->stage != raytracing_cs) {
-      /* Manually initialize scratch. For RT stages scratch initialization is done in the prolog. */
-      Operand scratch_offset = Operand(get_arg(ctx, ctx->args->scratch_offset));
-      scratch_offset.setLateKill(true);
+         ctx->program->scratch_offset = get_arg(ctx, ctx->args->scratch_offset);
+      } else if (ctx->program->gfx_level <= GFX10_3 && ctx->program->stage != raytracing_cs) {
+         /* Manually initialize scratch. For RT stages scratch initialization is done in the prolog.
+          */
+         Operand scratch_offset = Operand(get_arg(ctx, ctx->args->scratch_offset));
+         scratch_offset.setLateKill(true);
 
-      Operand scratch_addr = ctx->args->ring_offsets.used
-                                ? Operand(get_arg(ctx, ctx->args->ring_offsets))
-                                : Operand(s2);
+         Operand scratch_addr = ctx->args->ring_offsets.used
+                                   ? Operand(get_arg(ctx, ctx->args->ring_offsets))
+                                   : Operand(s2);
 
-      Builder bld(ctx->program, ctx->block);
-      bld.pseudo(aco_opcode::p_init_scratch, bld.def(s2), bld.def(s1, scc), scratch_addr,
-                 scratch_offset);
+         Builder bld(ctx->program, ctx->block);
+         bld.pseudo(aco_opcode::p_init_scratch, bld.def(s2), bld.def(s1, scc), scratch_addr,
+                    scratch_offset);
+      }
    }
 
    return startpgm;
-- 
GitLab


From 6c6dd0a20e662ee3cd0403141d1ba4b038b7c2ff Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 20 Jul 2023 17:50:36 +0800
Subject: [PATCH 08/21] aco,radeonsi: save const addr to symbol

For radeonsi to relocation const data when combine multiple
shader parts to a single one. So the final shader binary will
begin with exec code of all parts then const data.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp           | 7 +++++++
 src/amd/compiler/aco_shader_info.h           | 1 +
 src/gallium/drivers/radeonsi/si_shader_aco.c | 2 ++
 3 files changed, 10 insertions(+)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 7e6aa4eea4836..c27e084645c79 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -1209,6 +1209,13 @@ fix_constaddrs(asm_context& ctx, std::vector<uint32_t>& out)
    for (auto& constaddr : ctx.constaddrs) {
       constaddr_info& info = constaddr.second;
       out[info.add_literal] += (out.size() - info.getpc_end) * 4u;
+
+      if (ctx.symbols) {
+         struct aco_symbol sym;
+         sym.id = aco_symbol_const_data_addr;
+         sym.offset = info.add_literal;
+         ctx.symbols->push_back(sym);
+      }
    }
    for (auto& addr : ctx.resumeaddrs) {
       constaddr_info& info = addr.second;
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 0a98bda4b3f28..952f980a0af6c 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -177,6 +177,7 @@ enum aco_symbol_id {
    aco_symbol_scratch_addr_hi,
    aco_symbol_lds_ngg_scratch_base,
    aco_symbol_lds_ngg_gs_out_vertex_base,
+   aco_symbol_const_data_addr,
 };
 
 struct aco_symbol {
diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index fc063bf133f92..c6ae491fe3085 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -208,6 +208,8 @@ si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code, uint64_t scratc
          assert(sel->stage == MESA_SHADER_GEOMETRY && key->ge.as_ngg);
          value = shader->gs_info.esgs_ring_size * 4;
          break;
+      case aco_symbol_const_data_addr:
+         continue;
       default:
          unreachable("invalid aco symbol");
          break;
-- 
GitLab


From 89e029f844285f1a55f8b977eeede841a3c4f43a Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 2 Aug 2023 16:08:09 +0800
Subject: [PATCH 09/21] ac/nir/tess: move tess factor output out of control
 flow

For radeonsi aco compile which can't handle outputs without
nir_lower_io_to_temporaries().

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 73 +++++++++++++++-----
 1 file changed, 55 insertions(+), 18 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index eb796533f5cd5..62b70a47e219a 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -147,12 +147,13 @@ typedef struct {
     */
    bool tcs_no_inputs_in_lds;
 
-   /* Whether to emit TCS tess factor write. */
-   bool tcs_emit_tess_factor_write;
-
    /* Save TCS tess factor for tess factor writer. */
    nir_variable *tcs_tess_level_outer;
    nir_variable *tcs_tess_level_inner;
+   unsigned tcs_tess_level_outer_base;
+   unsigned tcs_tess_level_outer_mask;
+   unsigned tcs_tess_level_inner_base;
+   unsigned tcs_tess_level_inner_mask;
 } lower_tess_io_state;
 
 static bool
@@ -415,6 +416,7 @@ lower_hs_output_store(nir_builder *b,
 
    nir_io_semantics semantics = nir_intrinsic_io_semantics(intrin);
    nir_ssa_def *store_val = intrin->src[0].ssa;
+   unsigned base = nir_intrinsic_base(intrin);
    unsigned component = nir_intrinsic_component(intrin);
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
    bool is_tess_factor = semantics.location == VARYING_SLOT_TESS_LEVEL_INNER ||
@@ -454,24 +456,24 @@ lower_hs_output_store(nir_builder *b,
       nir_store_shared(b, store_val, lds_off, .write_mask = write_mask);
    }
 
-   nir_ssa_def *ret = NIR_LOWER_INSTR_PROGRESS_REPLACE;
-
+   /* Save tess factor to be used by tess factor writer or reconstruct
+    * store output instruction later.
+    */
    if (is_tess_factor && st->tcs_pass_tessfactors_by_reg) {
-      if (st->tcs_emit_tess_factor_write) {
-         nir_variable *var = semantics.location == VARYING_SLOT_TESS_LEVEL_INNER ?
-            st->tcs_tess_level_inner : st->tcs_tess_level_outer;
-
-         /* Save to temp variable for read by tess factor writer. */
-         ac_nir_store_var_components(b, var, store_val, component, write_mask);
+      if (semantics.location == VARYING_SLOT_TESS_LEVEL_INNER) {
+         st->tcs_tess_level_inner_base = base;
+         st->tcs_tess_level_inner_mask |= write_mask << component;
+         ac_nir_store_var_components(b, st->tcs_tess_level_inner, store_val,
+                                     component, write_mask);
       } else {
-         /* Keep tess factor nir_store_output instruction if it's going to be passed
-          * by reg instead of LDS and we use a compiler backend TCS epilog.
-          */
-         ret = NIR_LOWER_INSTR_PROGRESS;
+         st->tcs_tess_level_outer_base = base;
+         st->tcs_tess_level_outer_mask |= write_mask << component;
+         ac_nir_store_var_components(b, st->tcs_tess_level_outer, store_val,
+                                     component, write_mask);
       }
    }
 
-   return ret;
+   return NIR_LOWER_INSTR_PROGRESS_REPLACE;
 }
 
 static nir_ssa_def *
@@ -775,6 +777,31 @@ ac_nir_lower_hs_inputs_to_mem(nir_shader *shader,
                                  &state);
 }
 
+static void
+reconstruct_tess_factor_outputs(nir_shader *shader, lower_tess_io_state *st)
+{
+   nir_function_impl *impl = nir_shader_get_entrypoint(shader);
+   nir_builder builder = nir_builder_create(impl);
+   nir_builder *b = &builder;
+   b->cursor = nir_after_cf_list(&impl->body);
+
+   if (st->tcs_tess_level_outer_mask) {
+      nir_ssa_def *val = nir_load_var(b, st->tcs_tess_level_outer);
+      nir_store_output(b, val, nir_imm_int(b, 0),
+                       .base = st->tcs_tess_level_outer_base,
+                       .write_mask = st->tcs_tess_level_outer_mask,
+                       .io_semantics.location = VARYING_SLOT_TESS_LEVEL_OUTER);
+   }
+
+   if (st->tcs_tess_level_inner_mask) {
+      nir_ssa_def *val = nir_load_var(b, st->tcs_tess_level_inner);
+      nir_store_output(b, val, nir_imm_int(b, 0),
+                       .base = st->tcs_tess_level_inner_base,
+                       .write_mask = st->tcs_tess_level_inner_mask,
+                       .io_semantics.location = VARYING_SLOT_TESS_LEVEL_INNER);
+   }
+}
+
 void
 ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
@@ -801,7 +828,6 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tcs_out_patch_fits_subgroup = wave_size % shader->info.tess.tcs_vertices_out == 0,
       .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
       .tcs_no_inputs_in_lds = no_inputs_in_lds,
-      .tcs_emit_tess_factor_write = emit_tess_factor_write,
       .tcs_tess_lvl_in_loc = -1,
       .tcs_tess_lvl_out_loc = -1,
       .map_io = map,
@@ -820,8 +846,19 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                  lower_hs_output_access,
                                  &state);
 
-   if (emit_tess_factor_write)
+   if (emit_tess_factor_write) {
       hs_emit_write_tess_factors(shader, &state);
+   } else if (pass_tessfactors_by_reg) {
+      /* Reconstruct tess factor nir_store_output instruction if it's going to be passed
+       * by reg instead of LDS and we use a compiler backend TCS epilog.
+       *
+       * TCS does not call nir_lower_io_to_temporaries(). It's not a problem when LLVM
+       * because LLVM support variable. But ACO does not support variable, so we do similar
+       * thing as nir_lower_io_to_temporaries() to move store output instruction out of
+       * control flow.
+       */
+      reconstruct_tess_factor_outputs(shader, &state);
+   }
 }
 
 void
-- 
GitLab


From cbd7e0d9ee9b4f6dbf3f06e69b6414ea464f0275 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 10 Aug 2023 15:19:46 +0800
Subject: [PATCH 10/21] aco: use semantic location as io temp index

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 16 +++++++++++++---
 1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 591dfca2b3423..5612d031ce9fa 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5187,7 +5187,6 @@ store_output_to_temps(isel_context* ctx, nir_intrinsic_instr* instr)
 {
    unsigned write_mask = nir_intrinsic_write_mask(instr);
    unsigned component = nir_intrinsic_component(instr);
-   unsigned idx = nir_intrinsic_base(instr) * 4u + component;
    nir_src offset = *nir_get_io_offset_src(instr);
 
    if (!nir_src_is_const(offset) || nir_src_as_uint(offset))
@@ -5200,6 +5199,15 @@ store_output_to_temps(isel_context* ctx, nir_intrinsic_instr* instr)
 
    RegClass rc = instr->src[0].ssa->bit_size == 16 ? v2b : v1;
 
+   /* Use semantic location as index. radv already uses it as intrinsic base
+    * but radeonsi does not. We need to make LS output and TCS input index
+    * match each other, so need to use semantic location explicitly. Also for
+    * TCS epilog to index tess factor temps using semantic location directly.
+    */
+   nir_io_semantics sem = nir_intrinsic_io_semantics(instr);
+   unsigned base = sem.location + sem.dual_source_blend_index;
+   unsigned idx = base * 4u + component;
+
    for (unsigned i = 0; i < 8; ++i) {
       if (write_mask & (1 << i)) {
          ctx->outputs.mask[idx / 4u] |= 1 << (idx % 4u);
@@ -5209,7 +5217,7 @@ store_output_to_temps(isel_context* ctx, nir_intrinsic_instr* instr)
    }
 
    if (ctx->stage == fragment_fs && ctx->program->info.has_epilog) {
-      unsigned index = nir_intrinsic_base(instr) - FRAG_RESULT_DATA0;
+      unsigned index = base - FRAG_RESULT_DATA0;
 
       if (nir_intrinsic_src_type(instr) == nir_type_float16) {
          ctx->output_color_types |= ACO_TYPE_FLOAT16 << (index * 2);
@@ -5243,7 +5251,9 @@ load_input_from_temps(isel_context* ctx, nir_intrinsic_instr* instr, Temp dst)
    if (!can_use_temps)
       return false;
 
-   unsigned idx = nir_intrinsic_base(instr) * 4u + nir_intrinsic_component(instr) +
+   nir_io_semantics sem = nir_intrinsic_io_semantics(instr);
+
+   unsigned idx = sem.location * 4u + nir_intrinsic_component(instr) +
                   4 * nir_src_as_uint(*off_src);
    Temp* src = &ctx->inputs.temps[idx];
    create_vec_from_array(ctx, src, dst.size(), dst.regClass().type(), 4u, 0, dst);
-- 
GitLab


From f26d7ec92b59a0d7375f4a7f7da08b4fed193177 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 20 Jul 2023 21:15:57 +0800
Subject: [PATCH 11/21] radeonsi: add exec_size to shader binary

Used by aco binary to split exec code and const data when combine
multi part shader binary.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.h          | 1 +
 src/gallium/drivers/radeonsi/si_shader_aco.c      | 1 +
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 4 +++-
 3 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index e52ee99a72c22..1e3ede70a928f 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -842,6 +842,7 @@ struct si_shader_binary {
    /* Depends on binary type, either ELF or raw buffer. */
    const char *code_buffer;
    size_t code_size;
+   uint32_t exec_size;
 
    char *uploaded_code;
    size_t uploaded_code_size;
diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index c6ae491fe3085..4e1f371e7fa09 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -110,6 +110,7 @@ si_aco_build_shader_binary(void **data, const struct ac_shader_config *config,
    shader->binary.type = SI_SHADER_BINARY_RAW;
    shader->binary.code_buffer = buffer;
    shader->binary.code_size = code_size;
+   shader->binary.exec_size = exec_size;
 
    if (disasm_size) {
       memcpy(buffer + code_size, disasm_str, disasm_size);
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 78ab64bfdf3d4..9bad382b995ee 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -253,7 +253,7 @@ static uint32_t *si_get_shader_binary(struct si_shader *shader)
    unsigned size = sizeof(struct si_shader_blob_head) +
                    align(sizeof(shader->config), 4) +
                    align(sizeof(shader->info), 4) +
-                   4 + align(shader->binary.code_size, 4) +
+                   4 + 4 + align(shader->binary.code_size, 4) +
                    4 + shader->binary.num_symbols * 8 +
                    4 + align(llvm_ir_size, 4);
    uint32_t *buffer = (uint32_t*)CALLOC(1, size);
@@ -269,6 +269,7 @@ static uint32_t *si_get_shader_binary(struct si_shader *shader)
 
    ptr = write_data(ptr, &shader->config, sizeof(shader->config));
    ptr = write_data(ptr, &shader->info, sizeof(shader->info));
+   ptr = write_data(ptr, &shader->binary.exec_size, 4);
    ptr = write_chunk(ptr, shader->binary.code_buffer, shader->binary.code_size);
    ptr = write_chunk(ptr, shader->binary.symbols, shader->binary.num_symbols * 8);
    ptr = write_chunk(ptr, shader->binary.llvm_ir_string, llvm_ir_size);
@@ -295,6 +296,7 @@ static bool si_load_shader_binary(struct si_shader *shader, void *binary)
    shader->binary.type = (enum si_shader_binary_type)head->type;
    ptr = read_data(ptr, &shader->config, sizeof(shader->config));
    ptr = read_data(ptr, &shader->info, sizeof(shader->info));
+   ptr = read_data(ptr, &shader->binary.exec_size, 4);
    ptr = read_chunk(ptr, (void **)&shader->binary.code_buffer, &code_size);
    shader->binary.code_size = code_size;
    ptr = read_chunk(ptr, (void **)&shader->binary.symbols, &chunk_size);
-- 
GitLab


From 05568828fb0d0d1bdd0ee8c9e5d3ce4e2ec47355 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 20 Jul 2023 16:53:55 +0800
Subject: [PATCH 12/21] radeonsi: support upload multi part shader binary

Need to split shader binary into exec and data part, then combine
exec and data of all shader parts separately. So const data symbols
in code need to be relocated.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 69 +++++++++++++++++--
 src/gallium/drivers/radeonsi/si_shader_aco.c  | 10 ++-
 .../drivers/radeonsi/si_shader_internal.h     |  4 +-
 3 files changed, 73 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index f284b5011fef8..9f32066dcbc8b 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -830,6 +830,24 @@ bool si_shader_binary_open(struct si_screen *screen, struct si_shader *shader,
    return ok;
 }
 
+static unsigned get_shader_binaries(struct si_shader *shader, struct si_shader_binary *bin[4])
+{
+   unsigned num_bin = 0;
+
+   if (shader->prolog)
+      bin[num_bin++] = &shader->prolog->binary;
+
+   if (shader->previous_stage)
+      bin[num_bin++] = &shader->previous_stage->binary;
+
+   bin[num_bin++] = &shader->binary;
+
+   if (shader->epilog)
+      bin[num_bin++] = &shader->epilog->binary;
+
+   return num_bin;
+}
+
 static unsigned si_get_shader_binary_size(struct si_screen *screen, struct si_shader *shader)
 {
    if (shader->binary.type == SI_SHADER_BINARY_ELF) {
@@ -839,8 +857,15 @@ static unsigned si_get_shader_binary_size(struct si_screen *screen, struct si_sh
       ac_rtld_close(&rtld);
       return size;
    } else {
-      assert(shader->binary.type == SI_SHADER_BINARY_RAW);
-      return shader->binary.code_size;
+      struct si_shader_binary *bin[4];
+      unsigned num_bin = get_shader_binaries(shader, bin);
+
+      unsigned size = 0;
+      for (unsigned i = 0; i < num_bin; i++) {
+         assert(bin[i]->type == SI_SHADER_BINARY_RAW);
+         size += bin[i]->exec_size;
+      }
+      return size;
    }
 }
 
@@ -942,8 +967,17 @@ static void calculate_needed_lds_size(struct si_screen *sscreen, struct si_shade
 static bool upload_binary_raw(struct si_screen *sscreen, struct si_shader *shader,
                               uint64_t scratch_va)
 {
-   unsigned rx_size =
-      ac_align_shader_binary_for_prefetch(&sscreen->info, shader->binary.code_size);
+   struct si_shader_binary *bin[4];
+   unsigned num_bin = get_shader_binaries(shader, bin);
+
+   unsigned code_size = 0, exec_size = 0;
+   for (unsigned i = 0; i < num_bin; i++) {
+      assert(bin[i]->type == SI_SHADER_BINARY_RAW);
+      code_size += bin[i]->code_size;
+      exec_size += bin[i]->exec_size;
+   }
+
+   unsigned rx_size = ac_align_shader_binary_for_prefetch(&sscreen->info, code_size);
 
    si_resource_reference(&shader->bo, NULL);
    shader->bo =
@@ -965,9 +999,32 @@ static bool upload_binary_raw(struct si_screen *sscreen, struct si_shader *shade
    if (!rx_ptr)
       return false;
 
-   memcpy(rx_ptr, shader->binary.code_buffer, shader->binary.code_size);
+   unsigned exec_offset = 0, data_offset = exec_size;
+   for (unsigned i = 0; i < num_bin; i++) {
+      memcpy(rx_ptr + exec_offset, bin[i]->code_buffer, bin[i]->exec_size);
+
+      if (bin[i]->num_symbols) {
+         /* Offset needed to add to const data symbol because of inserting other
+          * shader part between exec code and const data.
+          */
+         unsigned const_offset = data_offset - exec_offset - bin[i]->exec_size;
+
+         /* Prolog and epilog have no symbols. */
+         struct si_shader *sh = bin[i] == &shader->binary ? shader : shader->previous_stage;
+         assert(sh && bin[i] == &sh->binary);
 
-   si_aco_resolve_symbols(shader, rx_ptr, scratch_va);
+         si_aco_resolve_symbols(sh, rx_ptr + exec_offset, (const uint32_t *)bin[i]->code_buffer,
+                                scratch_va, const_offset);
+      }
+
+      exec_offset += bin[i]->exec_size;
+
+      unsigned data_size = bin[i]->code_size - bin[i]->exec_size;
+      if (data_size) {
+         memcpy(rx_ptr + data_offset, bin[i]->code_buffer + bin[i]->exec_size, data_size);
+         data_offset += data_size;
+      }
+   }
 
    sscreen->ws->buffer_unmap(sscreen->ws, shader->bo->buf);
    shader->gpu_address = shader->bo->gpu_address;
diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 4e1f371e7fa09..62b300968f064 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -177,7 +177,8 @@ si_aco_compile_shader(struct si_shader *shader,
 }
 
 void
-si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code, uint64_t scratch_va)
+si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code_for_write,
+                       const uint32_t *code_for_read, uint64_t scratch_va, uint32_t const_offset)
 {
    const struct aco_symbol *symbols = (struct aco_symbol *)shader->binary.symbols;
    const struct si_shader_selector *sel = shader->selector;
@@ -210,12 +211,15 @@ si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code, uint64_t scratc
          value = shader->gs_info.esgs_ring_size * 4;
          break;
       case aco_symbol_const_data_addr:
-         continue;
+         if (!const_offset)
+            continue;
+         value = code_for_read[symbols[i].offset] + const_offset;
+         break;
       default:
          unreachable("invalid aco symbol");
          break;
       }
 
-      code[symbols[i].offset] = value;
+      code_for_write[symbols[i].offset] = value;
    }
 }
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 0f2af78ba6658..19a8486b721da 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -215,6 +215,8 @@ bool si_aco_compile_shader(struct si_shader *shader,
                            struct si_shader_args *args,
                            struct nir_shader *nir,
                            struct util_debug_callback *debug);
-void si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code, uint64_t scratch_va);
+void si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code_for_write,
+                            const uint32_t *code_for_read, uint64_t scratch_va,
+                            uint32_t const_offset);
 
 #endif
-- 
GitLab


From dd5bb39d361d51a268f955f9b6f9884b1ecdca1d Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 22 Jul 2023 15:43:54 +0800
Subject: [PATCH 13/21] radeonsi: share si_get_tcs_out_patch_stride with aco

Move it out of llvm to be shared with aco.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      |  9 +++++++++
 .../drivers/radeonsi/si_shader_internal.h     |  1 +
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 20 ++-----------------
 3 files changed, 12 insertions(+), 18 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 9f32066dcbc8b..1826722bd0874 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -3524,3 +3524,12 @@ nir_shader *si_get_prev_stage_nir_shader(struct si_shader *shader,
 
    return nir;
 }
+
+unsigned si_get_tcs_out_patch_stride(const struct si_shader_info *info)
+{
+   unsigned tcs_out_vertices = info->base.tess.tcs_vertices_out;
+   unsigned vertex_stride = util_last_bit64(info->outputs_written) * 4;
+   unsigned num_patch_outputs = util_last_bit64(info->patch_outputs_written);
+
+   return tcs_out_vertices * vertex_stride + num_patch_outputs * 4;
+}
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 19a8486b721da..37d3e3f59d30b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -135,6 +135,7 @@ nir_shader *si_get_prev_stage_nir_shader(struct si_shader *shader,
                                          struct si_shader *prev_shader,
                                          struct si_shader_args *args,
                                          bool *free_nir);
+unsigned si_get_tcs_out_patch_stride(const struct si_shader_info *info);
 
 /* gfx10_shader_ngg.c */
 unsigned gfx10_ngg_get_vertices_per_prim(struct si_shader *shader);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index a215dc96f32dc..00a341f2a9483 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -46,23 +46,6 @@ LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx)
  * All three shaders VS(LS), TCS, TES share the same LDS space.
  */
 
-static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *ctx)
-{
-   assert(ctx->stage == MESA_SHADER_TESS_CTRL);
-
-   return util_last_bit64(ctx->shader->selector->info.outputs_written) * 4;
-}
-
-static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
-{
-   const struct si_shader_info *info = &ctx->shader->selector->info;
-   unsigned tcs_out_vertices = info->base.tess.tcs_vertices_out;
-   unsigned vertex_dw_stride = get_tcs_out_vertex_dw_stride_constant(ctx);
-   unsigned num_patch_outputs = util_last_bit64(ctx->shader->selector->info.patch_outputs_written);
-   unsigned patch_dw_stride = tcs_out_vertices * vertex_dw_stride + num_patch_outputs * 4;
-   return LLVMConstInt(ctx->ac.i32, patch_dw_stride, 0);
-}
-
 static LLVMValueRef get_tcs_out_patch0_patch_data_offset(struct si_shader_context *ctx)
 {
    return si_unpack_param(ctx, ctx->args->vs_state_bits, 10, 14);
@@ -71,7 +54,8 @@ static LLVMValueRef get_tcs_out_patch0_patch_data_offset(struct si_shader_contex
 static LLVMValueRef get_tcs_out_current_patch_data_offset(struct si_shader_context *ctx)
 {
    LLVMValueRef patch0_patch_data_offset = get_tcs_out_patch0_patch_data_offset(ctx);
-   LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
+   unsigned patch_dw_stride = si_get_tcs_out_patch_stride(&ctx->shader->selector->info);
+   LLVMValueRef patch_stride = LLVMConstInt(ctx->ac.i32, patch_dw_stride, 0);
    LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_patch_data_offset);
-- 
GitLab


From 5c1737ef7943045312b9f0f1c337337ed750b51c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 22 Jul 2023 15:58:07 +0800
Subject: [PATCH 14/21] radeonsi: fill part mode tcs aco shader info

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 62b300968f064..b90307c99e267 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -59,7 +59,8 @@ si_fill_aco_options(struct si_shader *shader, struct aco_compiler_options *optio
 }
 
 static void
-si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info)
+si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info,
+                        struct si_shader_args *args)
 {
    const struct si_shader_selector *sel = shader->selector;
    const union si_shader_key *key = &shader->key;
@@ -84,6 +85,12 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info)
    case MESA_SHADER_TESS_CTRL:
       info->vs.tcs_in_out_eq = key->ge.opt.same_patch_vertices;
       info->vs.tcs_temp_only_input_mask = sel->info.tcs_vgpr_only_inputs;
+      info->has_epilog = !shader->is_monolithic;
+      info->tcs.pass_tessfactors_by_reg = sel->info.tessfactors_are_def_in_all_invocs;
+      info->tcs.patch_stride = si_get_tcs_out_patch_stride(&sel->info);
+      info->tcs.tcs_offchip_layout = args->tcs_offchip_layout;
+      info->tcs.tes_offchip_addr = args->tes_offchip_addr;
+      info->tcs.vs_state_bits = args->vs_state_bits;
       break;
    case MESA_SHADER_FRAGMENT:
       info->ps.num_interp = si_get_ps_num_interp(shader);
@@ -144,7 +151,7 @@ si_aco_compile_shader(struct si_shader *shader,
    si_fill_aco_options(shader, &options, debug);
 
    struct aco_shader_info info = {0};
-   si_fill_aco_shader_info(shader, &info);
+   si_fill_aco_shader_info(shader, &info, args);
 
    nir_shader *shaders[2];
    unsigned num_shaders = 0;
-- 
GitLab


From 256b9756e71029431fe233e4447dff21eb27f89c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 22 Jul 2023 22:34:54 +0800
Subject: [PATCH 15/21] radeonsi: extract si_llvm_build_shader_part

Prepare for aco code path.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 78 ++---------------
 .../drivers/radeonsi/si_shader_internal.h     |  4 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 85 +++++++++++++++++++
 3 files changed, 98 insertions(+), 69 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 1826722bd0874..5a8fa29cf6606 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2858,15 +2858,12 @@ out:
  * \param prolog   whether the part being requested is a prolog
  * \param tm       LLVM target machine
  * \param debug    debug callback
- * \param build    the callback responsible for building the main function
  * \return         non-NULL on success
  */
 static struct si_shader_part *
 si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
                    gl_shader_stage stage, bool prolog, union si_shader_part_key *key,
                    struct ac_llvm_compiler *compiler, struct util_debug_callback *debug,
-                   void (*build)(struct si_shader_context *, union si_shader_part_key *,
-                                 bool non_monolithic),
                    const char *name)
 {
    struct si_shader_part *result;
@@ -2885,73 +2882,16 @@ si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
    result = CALLOC_STRUCT(si_shader_part);
    result->key = *key;
 
-   struct si_shader_selector sel = {};
-   sel.screen = sscreen;
+   bool ok = si_llvm_build_shader_part(sscreen, stage, prolog, compiler, debug, name, result);
 
-   struct si_shader shader = {};
-   shader.selector = &sel;
-   bool wave32 = false;
-   bool exports_color_null = false;
-   bool exports_mrtz = false;
-
-   switch (stage) {
-   case MESA_SHADER_VERTEX:
-      shader.key.ge.as_ls = key->vs_prolog.as_ls;
-      shader.key.ge.as_es = key->vs_prolog.as_es;
-      shader.key.ge.as_ngg = key->vs_prolog.as_ngg;
-      wave32 = key->vs_prolog.wave32;
-      break;
-   case MESA_SHADER_TESS_CTRL:
-      assert(!prolog);
-      shader.key.ge.part.tcs.epilog = key->tcs_epilog.states;
-      wave32 = key->tcs_epilog.wave32;
-      break;
-   case MESA_SHADER_FRAGMENT:
-      if (prolog) {
-         shader.key.ps.part.prolog = key->ps_prolog.states;
-         wave32 = key->ps_prolog.wave32;
-         exports_color_null = key->ps_prolog.states.poly_stipple;
-      } else {
-         shader.key.ps.part.epilog = key->ps_epilog.states;
-         wave32 = key->ps_epilog.wave32;
-         exports_color_null = key->ps_epilog.colors_written;
-         exports_mrtz = key->ps_epilog.writes_z || key->ps_epilog.writes_stencil ||
-                        key->ps_epilog.writes_samplemask;
-         if (!exports_mrtz && !exports_color_null)
-            exports_color_null = key->ps_epilog.uses_discard || sscreen->info.gfx_level < GFX10;
-      }
-      break;
-   default:
-      unreachable("bad shader part");
-   }
-
-   struct si_shader_context ctx;
-   si_llvm_context_init(&ctx, sscreen, compiler, wave32 ? 32 : 64, exports_color_null, exports_mrtz,
-                        AC_FLOAT_MODE_DEFAULT_OPENGL);
-
-   ctx.shader = &shader;
-   ctx.stage = stage;
-
-   struct si_shader_args args;
-   ctx.args = &args;
-
-   build(&ctx, key, true);
-
-   /* Compile. */
-   si_llvm_optimize_module(&ctx);
-
-   if (!si_compile_llvm(sscreen, &result->binary, &result->config, compiler, &ctx.ac, debug,
-                        ctx.stage, name, false)) {
+   if (ok) {
+      result->next = *list;
+      *list = result;
+   } else {
       FREE(result);
       result = NULL;
-      goto out;
    }
 
-   result->next = *list;
-   *list = result;
-
-out:
-   si_llvm_dispose(&ctx);
    simple_mtx_unlock(&sscreen->shader_parts_mutex);
    return result;
 }
@@ -2972,7 +2912,7 @@ static bool si_get_vs_prolog(struct si_screen *sscreen, struct ac_llvm_compiler
 
    shader->prolog =
       si_get_shader_part(sscreen, &sscreen->vs_prologs, MESA_SHADER_VERTEX, true, &prolog_key,
-                         compiler, debug, si_llvm_build_vs_prolog, "Vertex Shader Prolog");
+                         compiler, debug, "Vertex Shader Prolog");
    return shader->prolog != NULL;
 }
 
@@ -3017,7 +2957,7 @@ static bool si_shader_select_tcs_parts(struct si_screen *sscreen, struct ac_llvm
    si_get_tcs_epilog_key(shader, &epilog_key);
 
    shader->epilog = si_get_shader_part(sscreen, &sscreen->tcs_epilogs, MESA_SHADER_TESS_CTRL, false,
-                                       &epilog_key, compiler, debug, si_llvm_build_tcs_epilog,
+                                       &epilog_key, compiler, debug,
                                        "Tessellation Control Shader Epilog");
    return shader->epilog != NULL;
 }
@@ -3209,7 +3149,7 @@ static bool si_shader_select_ps_parts(struct si_screen *sscreen, struct ac_llvm_
    if (si_need_ps_prolog(&prolog_key)) {
       shader->prolog =
          si_get_shader_part(sscreen, &sscreen->ps_prologs, MESA_SHADER_FRAGMENT, true, &prolog_key,
-                            compiler, debug, si_llvm_build_ps_prolog, "Fragment Shader Prolog");
+                            compiler, debug, "Fragment Shader Prolog");
       if (!shader->prolog)
          return false;
    }
@@ -3219,7 +3159,7 @@ static bool si_shader_select_ps_parts(struct si_screen *sscreen, struct ac_llvm_
 
    shader->epilog =
       si_get_shader_part(sscreen, &sscreen->ps_epilogs, MESA_SHADER_FRAGMENT, false, &epilog_key,
-                         compiler, debug, si_llvm_build_ps_epilog, "Fragment Shader Epilog");
+                         compiler, debug, "Fragment Shader Epilog");
    if (!shader->epilog)
       return false;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 37d3e3f59d30b..225168fa4ba6c 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -185,6 +185,10 @@ LLVMValueRef si_unpack_param(struct si_shader_context *ctx, struct ac_arg param,
 bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
                             struct si_shader *shader, struct si_shader_args *args,
                             struct util_debug_callback *debug, struct nir_shader *nir);
+bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
+                               bool prolog, struct ac_llvm_compiler *compiler,
+                               struct util_debug_callback *debug, const char *name,
+                               struct si_shader_part *result);
 
 /* si_shader_llvm_gs.c */
 LLVMValueRef si_is_es_thread(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 75b42923650f4..98506879f3321 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -898,3 +898,88 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
    si_llvm_dispose(&ctx);
    return true;
 }
+
+bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
+                               bool prolog, struct ac_llvm_compiler *compiler,
+                               struct util_debug_callback *debug, const char *name,
+                               struct si_shader_part *result)
+{
+   union si_shader_part_key *key = &result->key;
+
+   struct si_shader_selector sel = {};
+   sel.screen = sscreen;
+
+   struct si_shader shader = {};
+   shader.selector = &sel;
+   bool wave32 = false;
+   bool exports_color_null = false;
+   bool exports_mrtz = false;
+
+   switch (stage) {
+   case MESA_SHADER_VERTEX:
+      shader.key.ge.as_ls = key->vs_prolog.as_ls;
+      shader.key.ge.as_es = key->vs_prolog.as_es;
+      shader.key.ge.as_ngg = key->vs_prolog.as_ngg;
+      wave32 = key->vs_prolog.wave32;
+      break;
+   case MESA_SHADER_TESS_CTRL:
+      assert(!prolog);
+      shader.key.ge.part.tcs.epilog = key->tcs_epilog.states;
+      wave32 = key->tcs_epilog.wave32;
+      break;
+   case MESA_SHADER_FRAGMENT:
+      if (prolog) {
+         shader.key.ps.part.prolog = key->ps_prolog.states;
+         wave32 = key->ps_prolog.wave32;
+         exports_color_null = key->ps_prolog.states.poly_stipple;
+      } else {
+         shader.key.ps.part.epilog = key->ps_epilog.states;
+         wave32 = key->ps_epilog.wave32;
+         exports_color_null = key->ps_epilog.colors_written;
+         exports_mrtz = key->ps_epilog.writes_z || key->ps_epilog.writes_stencil ||
+                        key->ps_epilog.writes_samplemask;
+         if (!exports_mrtz && !exports_color_null)
+            exports_color_null = key->ps_epilog.uses_discard || sscreen->info.gfx_level < GFX10;
+      }
+      break;
+   default:
+      unreachable("bad shader part");
+   }
+
+   struct si_shader_context ctx;
+   si_llvm_context_init(&ctx, sscreen, compiler, wave32 ? 32 : 64, exports_color_null, exports_mrtz,
+                        AC_FLOAT_MODE_DEFAULT_OPENGL);
+
+   ctx.shader = &shader;
+   ctx.stage = stage;
+
+   struct si_shader_args args;
+   ctx.args = &args;
+
+   void (*build)(struct si_shader_context *, union si_shader_part_key *, bool);
+
+   switch (stage) {
+   case MESA_SHADER_VERTEX:
+      build = si_llvm_build_vs_prolog;
+      break;
+   case MESA_SHADER_TESS_CTRL:
+      build = si_llvm_build_tcs_epilog;
+      break;
+   case MESA_SHADER_FRAGMENT:
+      build = prolog ? si_llvm_build_ps_prolog : si_llvm_build_ps_epilog;
+      break;
+   default:
+      unreachable("bad shader part");
+   }
+
+   build(&ctx, key, true);
+
+   /* Compile. */
+   si_llvm_optimize_module(&ctx);
+
+   bool ret = si_compile_llvm(sscreen, &result->binary, &result->config, compiler,
+                              &ctx.ac, debug, ctx.stage, name, false);
+
+   si_llvm_dispose(&ctx);
+   return ret;
+}
-- 
GitLab


From 90f256f01d082cfd598406ede79e84e3cc3e023d Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 22 Jul 2023 22:40:52 +0800
Subject: [PATCH 16/21] radeonsi: remove separate_prolog arg from prolog/epilog
 build

It's always true.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_internal.h  | 12 ++++--------
 src/gallium/drivers/radeonsi/si_shader_llvm.c      |  4 ++--
 src/gallium/drivers/radeonsi/si_shader_llvm_ps.c   | 12 +++++-------
 src/gallium/drivers/radeonsi/si_shader_llvm_tess.c |  3 +--
 src/gallium/drivers/radeonsi/si_shader_llvm_vs.c   |  3 +--
 5 files changed, 13 insertions(+), 21 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 225168fa4ba6c..8d12895ab50b4 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -199,21 +199,17 @@ void si_llvm_gs_build_end(struct si_shader_context *ctx);
 /* si_shader_llvm_tess.c */
 LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx);
 void si_llvm_ls_build_end(struct si_shader_context *ctx);
-void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                              bool separate_epilog);
+void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_tcs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx);
 
 /* si_shader_llvm_ps.c */
-void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                             bool separate_prolog);
-void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                             bool separate_epilog);
+void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
+void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_ps_build_end(struct si_shader_context *ctx);
 
 /* si_shader_llvm_vs.c */
-void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                             bool separate_prolog);
+void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
 
 /* si_shader_aco.c */
 bool si_aco_compile_shader(struct si_shader *shader,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 98506879f3321..7e496a816057b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -956,7 +956,7 @@ bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
    struct si_shader_args args;
    ctx.args = &args;
 
-   void (*build)(struct si_shader_context *, union si_shader_part_key *, bool);
+   void (*build)(struct si_shader_context *, union si_shader_part_key *);
 
    switch (stage) {
    case MESA_SHADER_VERTEX:
@@ -972,7 +972,7 @@ bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
       unreachable("bad shader part");
    }
 
-   build(&ctx, key, true);
+   build(&ctx, key);
 
    /* Compile. */
    si_llvm_optimize_module(&ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index 6bbe7c248dfc0..2874d17159374 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -466,8 +466,7 @@ static void si_llvm_emit_polygon_stipple(struct si_shader_context *ctx,
  * overridden by other states. (e.g. per-sample interpolation)
  * Interpolated colors are stored after the preloaded VGPRs.
  */
-void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                             bool separate_prolog)
+void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key)
 {
    LLVMValueRef ret, func;
    int num_returns, i, num_color_channels;
@@ -591,13 +590,13 @@ void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part
 
       /* Read LINEAR_SAMPLE. */
       for (i = 0; i < 2; i++)
-         linear_sample[i] = LLVMGetParam(func, base + (separate_prolog ? 6 : 9) + i);
+         linear_sample[i] = LLVMGetParam(func, base + 6 + i);
       /* Overwrite LINEAR_CENTER. */
       for (i = 0; i < 2; i++)
-         ret = LLVMBuildInsertValue(ctx->ac.builder, ret, linear_sample[i], base + (separate_prolog ? 8 : 11) + i, "");
+         ret = LLVMBuildInsertValue(ctx->ac.builder, ret, linear_sample[i], base + 8 + i, "");
       /* Overwrite LINEAR_CENTROID. */
       for (i = 0; i < 2; i++)
-         ret = LLVMBuildInsertValue(ctx->ac.builder, ret, linear_sample[i], base + (separate_prolog ? 10 : 13) + i, "");
+         ret = LLVMBuildInsertValue(ctx->ac.builder, ret, linear_sample[i], base + 10 + i, "");
    }
 
    /* Force center interpolation. */
@@ -715,8 +714,7 @@ void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part
  * Build the pixel shader epilog function. This handles everything that must be
  * emulated for pixel shader exports. (alpha-test, format conversions, etc)
  */
-void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                             UNUSED bool separate_epilog)
+void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key)
 {
    int i;
    struct si_ps_exports exp = {};
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 00a341f2a9483..d86a8b6cb3208 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -530,8 +530,7 @@ void si_llvm_ls_build_end(struct si_shader_context *ctx)
  * Compile the TCS epilog function. This writes tessellation factors to memory
  * based on the output primitive type of the tessellator (determined by TES).
  */
-void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                              UNUSED bool separate_epilog)
+void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key)
 {
    memset(ctx->args, 0, sizeof(*ctx->args));
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index b1783b50ab053..c2786028ff77c 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -73,8 +73,7 @@ static LLVMValueRef get_vertex_index(struct si_shader_context *ctx,
  *   (InstanceID + StartInstance),
  *   (InstanceID / 2 + StartInstance)
  */
-void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key,
-                             UNUSED bool separate_prolog)
+void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key)
 {
    LLVMTypeRef *returns;
    LLVMValueRef ret, func;
-- 
GitLab


From a75fcd28ea89a79acda912549427fdca476407d9 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 24 Jul 2023 14:56:48 +0800
Subject: [PATCH 17/21] radeonsi: add si_get_tcs_epilog_args

For shared with aco tcs epilog creation.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 53 +++++++++++++++++++
 .../drivers/radeonsi/si_shader_internal.h     |  6 +++
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 50 ++---------------
 3 files changed, 64 insertions(+), 45 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 5a8fa29cf6606..34119cdc70266 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -3473,3 +3473,56 @@ unsigned si_get_tcs_out_patch_stride(const struct si_shader_info *info)
 
    return tcs_out_vertices * vertex_stride + num_patch_outputs * 4;
 }
+
+void si_get_tcs_epilog_args(enum amd_gfx_level gfx_level,
+                            struct si_shader_args *args,
+                            struct ac_arg *rel_patch_id,
+                            struct ac_arg *invocation_id,
+                            struct ac_arg *tf_lds_offset,
+                            struct ac_arg tess_factors[6])
+{
+   memset(args, 0, sizeof(*args));
+
+   if (gfx_level >= GFX9) {
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tess_offchip_offset);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL); /* wave info */
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tcs_factor_offset);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tcs_offchip_layout);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tes_offchip_addr);
+   } else {
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tcs_offchip_layout);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->tes_offchip_addr);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tess_offchip_offset);
+      ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tcs_factor_offset);
+   }
+
+   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* VGPR gap */
+   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* VGPR gap */
+   /* patch index within the wave (REL_PATCH_ID) */
+   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, rel_patch_id);
+   /* invocation ID within the patch */
+   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, invocation_id);
+   /* LDS offset where tess factors should be loaded from */
+   ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, tf_lds_offset);
+
+   for (unsigned i = 0; i < 6; i++)
+      ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &tess_factors[i]);
+}
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 8d12895ab50b4..081a13b976c23 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -136,6 +136,12 @@ nir_shader *si_get_prev_stage_nir_shader(struct si_shader *shader,
                                          struct si_shader_args *args,
                                          bool *free_nir);
 unsigned si_get_tcs_out_patch_stride(const struct si_shader_info *info);
+void si_get_tcs_epilog_args(enum amd_gfx_level gfx_level,
+                            struct si_shader_args *args,
+                            struct ac_arg *rel_patch_id,
+                            struct ac_arg *invocation_id,
+                            struct ac_arg *tf_lds_offset,
+                            struct ac_arg tess_factors[6]);
 
 /* gfx10_shader_ngg.c */
 unsigned gfx10_ngg_get_vertices_per_prim(struct si_shader *shader);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index d86a8b6cb3208..1af9b750cc2af 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -532,52 +532,12 @@ void si_llvm_ls_build_end(struct si_shader_context *ctx)
  */
 void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key)
 {
-   memset(ctx->args, 0, sizeof(*ctx->args));
-
-   if (ctx->screen->info.gfx_level >= GFX9) {
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->ac.tess_offchip_offset);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL); /* wave info */
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->ac.tcs_factor_offset);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->tcs_offchip_layout);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->tes_offchip_addr);
-   } else {
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->tcs_offchip_layout);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->tes_offchip_addr);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, NULL);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->ac.tess_offchip_offset);
-      ac_add_arg(&ctx->args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &ctx->args->ac.tcs_factor_offset);
-   }
-
-   ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* VGPR gap */
-   ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, NULL); /* VGPR gap */
-   struct ac_arg rel_patch_id; /* patch index within the wave (REL_PATCH_ID) */
-   ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &rel_patch_id);
-   struct ac_arg invocation_id; /* invocation ID within the patch */
-   ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &invocation_id);
-   struct ac_arg
-      tcs_out_current_patch_data_offset; /* LDS offset where tess factors should be loaded from */
-   ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &tcs_out_current_patch_data_offset);
-
+   struct ac_arg rel_patch_id;
+   struct ac_arg invocation_id;
+   struct ac_arg tcs_out_current_patch_data_offset;
    struct ac_arg tess_factors[6];
-   for (unsigned i = 0; i < 6; i++)
-      ac_add_arg(&ctx->args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &tess_factors[i]);
+   si_get_tcs_epilog_args(ctx->screen->info.gfx_level, ctx->args, &rel_patch_id, &invocation_id,
+                          &tcs_out_current_patch_data_offset, tess_factors);
 
    /* Create the function. */
    si_llvm_create_func(ctx, "tcs_epilog", NULL, 0, ctx->screen->info.gfx_level >= GFX7 ? 128 : 0);
-- 
GitLab


From 726a9addd8a055f2262f4e203fb21d6aa546a8ea Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 24 Jul 2023 20:36:12 +0800
Subject: [PATCH 18/21] radeonsi: change si_fill_aco_options args

Prepare to be shared with prolog/epilog generation which
does not have si_shader param.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 25 ++++++++++----------
 1 file changed, 12 insertions(+), 13 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index b90307c99e267..6573b6c3347c4 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -37,22 +37,21 @@ si_aco_compiler_debug(void *private_data, enum aco_compiler_debug_level level,
 }
 
 static void
-si_fill_aco_options(struct si_shader *shader, struct aco_compiler_options *options,
+si_fill_aco_options(struct si_screen *screen, gl_shader_stage stage,
+                    struct aco_compiler_options *options,
                     struct util_debug_callback *debug)
 {
-   const struct si_shader_selector *sel = shader->selector;
-
    options->dump_shader =
-      si_can_dump_shader(sel->screen, sel->stage, SI_DUMP_ACO_IR) ||
-      si_can_dump_shader(sel->screen, sel->stage, SI_DUMP_ASM);
-   options->dump_preoptir = si_can_dump_shader(sel->screen, sel->stage, SI_DUMP_INIT_ACO_IR);
-   options->record_ir = sel->screen->record_llvm_ir;
+      si_can_dump_shader(screen, stage, SI_DUMP_ACO_IR) ||
+      si_can_dump_shader(screen, stage, SI_DUMP_ASM);
+   options->dump_preoptir = si_can_dump_shader(screen, stage, SI_DUMP_INIT_ACO_IR);
+   options->record_ir = screen->record_llvm_ir;
    options->is_opengl = true;
 
    options->load_grid_size_from_user_sgpr = true;
-   options->family = sel->screen->info.family;
-   options->gfx_level = sel->screen->info.gfx_level;
-   options->address32_hi = sel->screen->info.address32_hi;
+   options->family = screen->info.family;
+   options->gfx_level = screen->info.gfx_level;
+   options->address32_hi = screen->info.address32_hi;
 
    options->debug.func = si_aco_compiler_debug;
    options->debug.private_data = debug;
@@ -147,8 +146,10 @@ si_aco_compile_shader(struct si_shader *shader,
                       struct nir_shader *nir,
                       struct util_debug_callback *debug)
 {
+   const struct si_shader_selector *sel = shader->selector;
+
    struct aco_compiler_options options = {0};
-   si_fill_aco_options(shader, &options, debug);
+   si_fill_aco_options(sel->screen, sel->stage, &options, debug);
 
    struct aco_shader_info info = {0};
    si_fill_aco_shader_info(shader, &info, args);
@@ -160,8 +161,6 @@ si_aco_compile_shader(struct si_shader *shader,
    struct si_shader prev_shader = {};
    struct si_shader_args prev_args;
 
-   const struct si_shader_selector *sel = shader->selector;
-
    /* For merged shader stage. */
    if (shader->is_monolithic && sel->screen->info.gfx_level >= GFX9 &&
        (sel->stage == MESA_SHADER_TESS_CTRL || sel->stage == MESA_SHADER_GEOMETRY)) {
-- 
GitLab


From 81f82c66cc16c8ea65eb7dd7b90786fc230b4fd7 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 24 Jul 2023 21:14:19 +0800
Subject: [PATCH 19/21] radeonsi: add si_aco_build_shader_part

Now it only has tcs epilog build, will add more prolog/epilog to it.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c  | 85 +++++++++++++++++++
 .../drivers/radeonsi/si_shader_internal.h     |  3 +
 2 files changed, 88 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 6573b6c3347c4..1de9337d39abf 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -229,3 +229,88 @@ si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code_for_write,
       code_for_write[symbols[i].offset] = value;
    }
 }
+
+static void
+si_aco_build_shader_part_binary(void** priv_ptr, uint32_t num_sgprs, uint32_t num_vgprs,
+                                const uint32_t* code, uint32_t code_dw_size,
+                                const char* disasm_str, uint32_t disasm_size)
+{
+   struct si_shader_part *result = (struct si_shader_part *)priv_ptr;
+   unsigned code_size = code_dw_size * 4;
+
+   char *buffer = MALLOC(code_size + disasm_size);
+   memcpy(buffer, code, code_size);
+
+   result->binary.type = SI_SHADER_BINARY_RAW;
+   result->binary.code_buffer = buffer;
+   result->binary.code_size = code_size;
+   result->binary.exec_size = code_size;
+
+   if (disasm_size) {
+      memcpy(buffer + code_size, disasm_str, disasm_size);
+      result->binary.disasm_string = buffer + code_size;
+      result->binary.disasm_size = disasm_size;
+   }
+
+   result->config.num_sgprs = num_sgprs;
+   result->config.num_vgprs = num_vgprs;
+}
+
+static bool
+si_aco_build_tcs_epilog(struct si_screen *screen,
+                        struct aco_compiler_options *options,
+                        struct si_shader_part *result)
+{
+   const union si_shader_part_key *key = &result->key;
+
+   struct si_shader_args args;
+   struct ac_arg rel_patch_id;
+   struct ac_arg invocation_id;
+   struct ac_arg tcs_out_current_patch_data_offset;
+   struct ac_arg tess_factors[6];
+   si_get_tcs_epilog_args(screen->info.gfx_level, &args, &rel_patch_id, &invocation_id,
+                          &tcs_out_current_patch_data_offset, tess_factors);
+
+   struct aco_tcs_epilog_info einfo = {
+      .pass_tessfactors_by_reg = key->tcs_epilog.states.invoc0_tess_factors_are_def,
+      .tcs_out_patch_fits_subgroup = key->tcs_epilog.noop_s_barrier,
+      .primitive_mode = key->tcs_epilog.states.prim_mode,
+      .tess_offchip_ring_size = screen->hs.tess_offchip_ring_size,
+      .tes_reads_tessfactors = key->tcs_epilog.states.tes_reads_tess_factors,
+
+      .rel_patch_id = rel_patch_id,
+      .invocation_id = invocation_id,
+      .tcs_out_current_patch_data_offset = tcs_out_current_patch_data_offset,
+      .tcs_out_lds_layout = args.tes_offchip_addr,
+      .tcs_offchip_layout = args.tcs_offchip_layout,
+   };
+   memcpy(einfo.tess_lvl_out, tess_factors, sizeof(einfo.tess_lvl_out));
+   memcpy(einfo.tess_lvl_in, tess_factors + 4, sizeof(einfo.tess_lvl_in));
+
+   struct aco_shader_info info = {0};
+   info.hw_stage = AC_HW_HULL_SHADER;
+   info.workgroup_size = info.wave_size = key->tcs_epilog.wave32 ? 32 : 64,
+
+   aco_compile_tcs_epilog(options, &info, &einfo, &args.ac,
+                          si_aco_build_shader_part_binary, (void **)result);
+   return true;
+}
+
+bool
+si_aco_build_shader_part(struct si_screen *screen, gl_shader_stage stage, bool prolog,
+                         struct util_debug_callback *debug, const char *name,
+                         struct si_shader_part *result)
+{
+   struct aco_compiler_options options = {0};
+   si_fill_aco_options(screen, stage, &options, debug);
+
+   switch (stage) {
+   case MESA_SHADER_TESS_CTRL:
+      return si_aco_build_tcs_epilog(screen, &options, result);
+      break;
+   default:
+      unreachable("bad shader part");
+   }
+
+   return false;
+}
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 081a13b976c23..3a6b224eeda01 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -225,5 +225,8 @@ bool si_aco_compile_shader(struct si_shader *shader,
 void si_aco_resolve_symbols(struct si_shader *shader, uint32_t *code_for_write,
                             const uint32_t *code_for_read, uint64_t scratch_va,
                             uint32_t const_offset);
+bool si_aco_build_shader_part(struct si_screen *screen, gl_shader_stage stage, bool prolog,
+                              struct util_debug_callback *debug, const char *name,
+                              struct si_shader_part *result);
 
 #endif
-- 
GitLab


From 3f4264a933b191eec591b3455022be2c57c39580 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 25 Jul 2023 09:15:11 +0800
Subject: [PATCH 20/21] radeonsi: part mode standalone tcs support aco compile

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 34119cdc70266..e31033ecaefbb 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2382,9 +2382,9 @@ static void si_determine_use_aco(struct si_shader *shader)
 
    switch (sel->stage) {
    case MESA_SHADER_VERTEX:
-   case MESA_SHADER_TESS_CTRL:
       shader->use_aco = shader->is_monolithic;
       break;
+   case MESA_SHADER_TESS_CTRL:
    case MESA_SHADER_TESS_EVAL:
    case MESA_SHADER_GEOMETRY:
       shader->use_aco =
@@ -2882,7 +2882,13 @@ si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
    result = CALLOC_STRUCT(si_shader_part);
    result->key = *key;
 
-   bool ok = si_llvm_build_shader_part(sscreen, stage, prolog, compiler, debug, name, result);
+   bool use_aco =
+      (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics &&
+      stage == MESA_SHADER_TESS_CTRL && sscreen->info.gfx_level <= GFX8;
+
+   bool ok = use_aco ?
+      si_aco_build_shader_part(sscreen, stage, prolog, debug, name, result) :
+      si_llvm_build_shader_part(sscreen, stage, prolog, compiler, debug, name, result);
 
    if (ok) {
       result->next = *list;
-- 
GitLab


From 9016c123574e9b565d65a111788ca207f687f153 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 2 Aug 2023 16:17:00 +0800
Subject: [PATCH 21/21] radeonsi: remove unused arg of
 get_tcs_tes_buffer_address

Sigend-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 41 ++++---------------
 1 file changed, 8 insertions(+), 33 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 1af9b750cc2af..8a6a11bd0ea46 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -61,20 +61,6 @@ static LLVMValueRef get_tcs_out_current_patch_data_offset(struct si_shader_conte
    return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_patch_data_offset);
 }
 
-static LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx)
-{
-   unsigned tcs_out_vertices =
-      ctx->shader->selector ? ctx->shader->selector->info.base.tess.tcs_vertices_out
-                            : 0;
-
-   /* If !tcs_out_vertices, it's the TCS epilog. */
-   if (ctx->stage == MESA_SHADER_TESS_CTRL && tcs_out_vertices)
-      return LLVMConstInt(ctx->ac.i32, tcs_out_vertices, 0);
-
-   return LLVMBuildAdd(ctx->ac.builder,
-                       si_unpack_param(ctx, ctx->args->tcs_offchip_layout, 6, 5), ctx->ac.i32_1, "");
-}
-
 /* The offchip buffer layout for TCS->TES is
  *
  * - attribute 0 of patch 0 vertex 0
@@ -94,35 +80,24 @@ static LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx)
  * Note that every attribute has 4 components.
  */
 static LLVMValueRef get_tcs_tes_buffer_address(struct si_shader_context *ctx,
-                                               LLVMValueRef rel_patch_id, LLVMValueRef vertex_index,
+                                               LLVMValueRef rel_patch_id,
                                                LLVMValueRef param_index)
 {
-   LLVMValueRef base_addr, vertices_per_patch, num_patches, total_vertices;
+   LLVMValueRef base_addr, num_patches;
    LLVMValueRef param_stride, constant16;
 
-   vertices_per_patch = si_get_num_tcs_out_vertices(ctx);
    num_patches = si_unpack_param(ctx, ctx->args->tcs_offchip_layout, 0, 6);
    num_patches = LLVMBuildAdd(ctx->ac.builder, num_patches, ctx->ac.i32_1, "");
-   total_vertices = LLVMBuildMul(ctx->ac.builder, vertices_per_patch, num_patches, "");
 
    constant16 = LLVMConstInt(ctx->ac.i32, 16, 0);
-   if (vertex_index) {
-      base_addr = ac_build_imad(&ctx->ac, rel_patch_id, vertices_per_patch, vertex_index);
-      param_stride = total_vertices;
-   } else {
-      base_addr = rel_patch_id;
-      param_stride = num_patches;
-   }
+   base_addr = rel_patch_id;
+   param_stride = num_patches;
 
    base_addr = ac_build_imad(&ctx->ac, param_index, param_stride, base_addr);
    base_addr = LLVMBuildMul(ctx->ac.builder, base_addr, constant16, "");
 
-   if (!vertex_index) {
-      LLVMValueRef patch_data_offset = si_unpack_param(ctx, ctx->args->tcs_offchip_layout, 16, 16);
-
-      base_addr = LLVMBuildAdd(ctx->ac.builder, base_addr, patch_data_offset, "");
-   }
-   return base_addr;
+   LLVMValueRef patch_data_offset = si_unpack_param(ctx, ctx->args->tcs_offchip_layout, 16, 16);
+   return LLVMBuildAdd(ctx->ac.builder, base_addr, patch_data_offset, "");
 }
 
 /**
@@ -353,7 +328,7 @@ static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader
       base = ac_get_arg(&ctx->ac, ctx->args->ac.tess_offchip_offset);
 
       param_outer = ac_shader_io_get_unique_index_patch(VARYING_SLOT_TESS_LEVEL_OUTER);
-      tf_outer_offset = get_tcs_tes_buffer_address(ctx, rel_patch_id, NULL,
+      tf_outer_offset = get_tcs_tes_buffer_address(ctx, rel_patch_id,
                                                    LLVMConstInt(ctx->ac.i32, param_outer, 0));
 
       outer_vec = ac_build_gather_values(&ctx->ac, outer, outer_comps);
@@ -362,7 +337,7 @@ static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader
                                   base, ACCESS_COHERENT);
       if (inner_comps) {
          param_inner = ac_shader_io_get_unique_index_patch(VARYING_SLOT_TESS_LEVEL_INNER);
-         tf_inner_offset = get_tcs_tes_buffer_address(ctx, rel_patch_id, NULL,
+         tf_inner_offset = get_tcs_tes_buffer_address(ctx, rel_patch_id,
                                                       LLVMConstInt(ctx->ac.i32, param_inner, 0));
 
          inner_vec = ac_build_gather_values(&ctx->ac, inner, inner_comps);
-- 
GitLab

