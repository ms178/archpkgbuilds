From 91d2ab2d08b7382802663295a759485e4add835a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Wed, 8 May 2024 18:08:44 +0200
Subject: [PATCH 1/3] wsi: Call drmSyncobjQuery only once for all images

Reduces system call overhead.
---
 src/vulkan/wsi/wsi_common_drm.c | 77 +++++++++++++++++++++------------
 1 file changed, 50 insertions(+), 27 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index 474e59f88bd93..ebb4530876696 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -854,40 +854,62 @@ static const uint32_t wsi_explicit_sync_free_levels[] = {
    (WSI_ES_STATE_RELEASE_MATERIALIZED),
 };
 
-static uint32_t
-wsi_drm_image_explicit_sync_state(struct vk_device *device, struct wsi_image *image)
+static void
+wsi_drm_images_explicit_sync_state(struct vk_device *device, int count, uint32_t *indices,
+                                   struct wsi_image **images, uint32_t *flags)
 {
-   if (image->explicit_sync[WSI_ES_RELEASE].timeline == 0) {
-      /* This image has never been used in a timeline.
-       * It must be free.
-       */
-      return WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED;
+   struct wsi_image *image;
+   int i;
+
+   memset(flags, 0, count * sizeof(flags[0]));
+
+   for (i = 0; i < count; i++) {
+      if (images[indices[i]]->explicit_sync[WSI_ES_RELEASE].timeline == 0) {
+         /* This image has never been used in a timeline.
+          * It must be free.
+          */
+         flags[i] = WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED;
+         return;
+      }
    }
 
-   uint64_t points[WSI_ES_COUNT] = { 0 };
-   uint32_t handles[WSI_ES_COUNT] = {
-      image->explicit_sync[WSI_ES_ACQUIRE].handle,
-      image->explicit_sync[WSI_ES_RELEASE].handle
-   };
-   int ret = drmSyncobjQuery(device->drm_fd, handles, points, WSI_ES_COUNT);
-   if (ret)
-      return 0;
+   STACK_ARRAY(uint64_t, points, count * WSI_ES_COUNT);
+   STACK_ARRAY(uint32_t, handles, count * WSI_ES_COUNT);
 
-   uint32_t flags = 0;
-   if (points[WSI_ES_ACQUIRE] >= image->explicit_sync[WSI_ES_ACQUIRE].timeline) {
-      flags |= WSI_ES_STATE_ACQUIRE_SIGNALLED;
+   for (i = 0; i < count; i++) {
+      points[i * WSI_ES_COUNT + WSI_ES_ACQUIRE] = 0;
+      points[i * WSI_ES_COUNT + WSI_ES_RELEASE] = 0;
+
+      image = images[indices[i]];
+      handles[i * WSI_ES_COUNT + WSI_ES_ACQUIRE] = image->explicit_sync[WSI_ES_ACQUIRE].handle;
+      handles[i * WSI_ES_COUNT + WSI_ES_RELEASE] = image->explicit_sync[WSI_ES_RELEASE].handle;
    }
 
-   if (points[WSI_ES_RELEASE] >= image->explicit_sync[WSI_ES_RELEASE].timeline) {
-      flags |= WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED;
-   } else {
-      uint32_t first_signalled;
-      ret = drmSyncobjTimelineWait(device->drm_fd, &handles[WSI_ES_RELEASE], &image->explicit_sync[WSI_ES_RELEASE].timeline, 1, 0, DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE, &first_signalled);
-      if (ret == 0)
-         flags |= WSI_ES_STATE_RELEASE_MATERIALIZED;
+   int ret = drmSyncobjQuery(device->drm_fd, handles, points, count * WSI_ES_COUNT);
+   if (ret)
+      goto done;
+
+   for (i = 0; i < count; i++) {
+      image = images[indices[i]];
+
+      if (points[i * WSI_ES_COUNT + WSI_ES_ACQUIRE] >= image->explicit_sync[WSI_ES_ACQUIRE].timeline)
+         flags[i] |= WSI_ES_STATE_ACQUIRE_SIGNALLED;
+
+      if (points[i * WSI_ES_COUNT + WSI_ES_RELEASE] >= image->explicit_sync[WSI_ES_RELEASE].timeline) {
+         flags[i] |= WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED;
+      } else {
+         uint32_t first_signalled;
+         ret = drmSyncobjTimelineWait(device->drm_fd, &handles[i * WSI_ES_COUNT + WSI_ES_RELEASE],
+                                      &image->explicit_sync[WSI_ES_RELEASE].timeline, 1, 0,
+                                      DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE, &first_signalled);
+         if (ret == 0)
+            flags[i] |= WSI_ES_STATE_RELEASE_MATERIALIZED;
+      }
    }
 
-   return flags;
+done:
+   STACK_ARRAY_FINISH(handles);
+   STACK_ARRAY_FINISH(points);
 }
 
 static uint64_t
@@ -928,7 +950,6 @@ wsi_drm_wait_for_explicit_sync_release(struct wsi_swapchain *chain,
       if (images[i]->acquired)
          continue;
 
-      flags[unacquired_image_count] = wsi_drm_image_explicit_sync_state(device, images[i]);
       handles[unacquired_image_count] = images[i]->explicit_sync[WSI_ES_RELEASE].handle;
       points[unacquired_image_count] = images[i]->explicit_sync[WSI_ES_RELEASE].timeline;
       indices[unacquired_image_count] = i;
@@ -941,6 +962,8 @@ wsi_drm_wait_for_explicit_sync_release(struct wsi_swapchain *chain,
       goto done;
    }
 
+   wsi_drm_images_explicit_sync_state(device, unacquired_image_count, indices, images, flags);
+
    /* Find the most optimal image using the free levels above. */
    for (uint32_t free_level_idx = 0; free_level_idx < ARRAY_SIZE(wsi_explicit_sync_free_levels); free_level_idx++) {
       uint32_t free_level = wsi_explicit_sync_free_levels[free_level_idx];
-- 
GitLab


From 2e00953b80b4b0903f24edf3cf3c7aa15fec61bb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Fri, 10 May 2024 17:26:06 +0200
Subject: [PATCH 2/3] wsi: Swap middle entries of wsi_explicit_sync_free_levels
 array

The next commit will effectively swap the order as well as a side
effect. Doing this explicitly first will make it easier to keep apart
the effects of this and the rest of the next commit.
---
 src/vulkan/wsi/wsi_common_drm.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index ebb4530876696..d6bd7f18fa3d3 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -843,14 +843,14 @@ enum wsi_explicit_sync_state_flags
 
 /* Levels of "freeness"
  * 0 -> Acquire Signalled + Release Signalled
- * 1 -> Acquire Signalled + Release Materialized
- * 2 -> Release Signalled
+ * 1 -> Release Signalled
+ * 2 -> Acquire Signalled + Release Materialized
  * 3 -> Release Materialized
  */
 static const uint32_t wsi_explicit_sync_free_levels[] = {
    (WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED),
-   (WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED),
    (WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_RELEASE_SIGNALLED),
+   (WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED),
    (WSI_ES_STATE_RELEASE_MATERIALIZED),
 };
 
-- 
GitLab


From 653262f5b004fe78b58b8ba60d417d2d25803e34 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Wed, 8 May 2024 17:24:55 +0200
Subject: [PATCH 3/3] wsi: Drop WSI_ES_STATE_RELEASE_MATERIALIZED

The separate drmSyncobjTimelineWait calls can incur significant
overhead, for relatively little benefit over the fallback call in
wsi_drm_wait_for_explicit_sync_release.
---
 src/vulkan/wsi/wsi_common_drm.c | 24 ++++++------------------
 1 file changed, 6 insertions(+), 18 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index d6bd7f18fa3d3..89e37368d8d0c 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -836,22 +836,17 @@ wsi_drm_configure_image(const struct wsi_swapchain *chain,
 
 enum wsi_explicit_sync_state_flags
 {
-   WSI_ES_STATE_RELEASE_MATERIALIZED = (1u << 0),
-   WSI_ES_STATE_RELEASE_SIGNALLED    = (1u << 1),
-   WSI_ES_STATE_ACQUIRE_SIGNALLED    = (1u << 2),
+   WSI_ES_STATE_RELEASE_SIGNALLED    = (1u << 0),
+   WSI_ES_STATE_ACQUIRE_SIGNALLED    = (1u << 1),
 };
 
 /* Levels of "freeness"
  * 0 -> Acquire Signalled + Release Signalled
  * 1 -> Release Signalled
- * 2 -> Acquire Signalled + Release Materialized
- * 3 -> Release Materialized
  */
 static const uint32_t wsi_explicit_sync_free_levels[] = {
-   (WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED),
-   (WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_RELEASE_SIGNALLED),
-   (WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED),
-   (WSI_ES_STATE_RELEASE_MATERIALIZED),
+   WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_ACQUIRE_SIGNALLED,
+   WSI_ES_STATE_RELEASE_SIGNALLED,
 };
 
 static void
@@ -868,7 +863,7 @@ wsi_drm_images_explicit_sync_state(struct vk_device *device, int count, uint32_t
          /* This image has never been used in a timeline.
           * It must be free.
           */
-         flags[i] = WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED | WSI_ES_STATE_ACQUIRE_SIGNALLED;
+         flags[i] = WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_ACQUIRE_SIGNALLED;
          return;
       }
    }
@@ -896,14 +891,7 @@ wsi_drm_images_explicit_sync_state(struct vk_device *device, int count, uint32_t
          flags[i] |= WSI_ES_STATE_ACQUIRE_SIGNALLED;
 
       if (points[i * WSI_ES_COUNT + WSI_ES_RELEASE] >= image->explicit_sync[WSI_ES_RELEASE].timeline) {
-         flags[i] |= WSI_ES_STATE_RELEASE_SIGNALLED | WSI_ES_STATE_RELEASE_MATERIALIZED;
-      } else {
-         uint32_t first_signalled;
-         ret = drmSyncobjTimelineWait(device->drm_fd, &handles[i * WSI_ES_COUNT + WSI_ES_RELEASE],
-                                      &image->explicit_sync[WSI_ES_RELEASE].timeline, 1, 0,
-                                      DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE, &first_signalled);
-         if (ret == 0)
-            flags[i] |= WSI_ES_STATE_RELEASE_MATERIALIZED;
+         flags[i] |= WSI_ES_STATE_RELEASE_SIGNALLED;
       }
    }
 
-- 
GitLab

