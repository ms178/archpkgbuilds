From e0010bb6316ffbe0e0d02407f7baa87b4bd18d81 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 14 Jun 2024 13:05:34 +0300
Subject: [PATCH 1/3] egl/wayland: Pass dri2_wl_formats to create_dri_image

Make the dri2_wl_formats struct available in create_dri_image, in
preparation for upcoming changes.
---
 src/egl/drivers/dri2/platform_wayland.c | 28 +++++++++++--------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 160eb5e72cd18..8f48e97a0a56d 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -967,13 +967,22 @@ static void
 create_dri_image(struct dri2_egl_surface *dri2_surf,
                  enum pipe_format pipe_format, uint32_t use_flags,
                  uint64_t *surf_modifiers, int surf_modifiers_count,
-                 struct u_vector *modifiers_set)
+                 struct dri2_wl_formats *formats)
 {
    struct dri2_egl_display *dri2_dpy =
       dri2_egl_display(dri2_surf->base.Resource.Display);
+   int visual_idx = dri2_wl_visual_idx_from_fourcc(dri2_surf->format);
    struct u_vector modifiers_subset;
    uint64_t *modifiers;
    unsigned int num_modifiers;
+   struct u_vector *modifiers_set;
+
+   assert(visual_idx != -1);
+
+   if (!BITSET_TEST(formats->formats_bitmap, visual_idx))
+      return;
+
+   modifiers_set = &formats->modifiers[visual_idx];
 
    if (surf_modifiers_count > 0) {
       if (!intersect_modifiers(&modifiers_subset, modifiers_set, surf_modifiers,
@@ -1013,16 +1022,12 @@ create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
                                       uint64_t *surf_modifiers,
                                       int surf_modifiers_count)
 {
-   int visual_idx;
    uint32_t flags;
 
    /* We don't have valid dma-buf feedback, so return */
    if (dri2_surf->dmabuf_feedback.main_device == 0)
       return;
 
-   visual_idx = dri2_wl_visual_idx_from_fourcc(dri2_surf->format);
-   assert(visual_idx != -1);
-
    /* Iterates through the dma-buf feedback to pick a new set of modifiers. The
     * tranches are sent in descending order of preference by the compositor, so
     * the first set that we can pick is the best one. For now we still can't
@@ -1035,17 +1040,12 @@ create_dri_image_from_dmabuf_feedback(struct dri2_egl_surface *dri2_surf,
     * incompatible with the main device. */
    util_dynarray_foreach (&dri2_surf->dmabuf_feedback.tranches,
                           struct dmabuf_feedback_tranche, tranche) {
-      /* Ignore tranches that do not contain dri2_surf->format */
-      if (!BITSET_TEST(tranche->formats.formats_bitmap, visual_idx))
-         continue;
-
       flags = use_flags;
       if (tranche->flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT)
          flags |= __DRI_IMAGE_USE_SCANOUT;
 
       create_dri_image(dri2_surf, pipe_format, flags, surf_modifiers,
-                       surf_modifiers_count,
-                       &tranche->formats.modifiers[visual_idx]);
+                       surf_modifiers_count, &tranche->formats);
 
       if (dri2_surf->back->dri_image)
          return;
@@ -1060,12 +1060,8 @@ create_dri_image_from_formats(struct dri2_egl_surface *dri2_surf,
 {
    struct dri2_egl_display *dri2_dpy =
       dri2_egl_display(dri2_surf->base.Resource.Display);
-   int visual_idx;
-
-   visual_idx = dri2_wl_visual_idx_from_fourcc(dri2_surf->format);
    create_dri_image(dri2_surf, pipe_format, use_flags, surf_modifiers,
-                    surf_modifiers_count,
-                    &dri2_dpy->formats.modifiers[visual_idx]);
+                    surf_modifiers_count, &dri2_dpy->formats);
 }
 
 static int
-- 
GitLab


From 2d317db978603d9889ff047a78921c0a8d72cbab Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 14 Jun 2024 14:58:33 +0300
Subject: [PATCH 2/3] egl/wayland: Fail EGL surface creation if opaque format
 is unsupported

When using the EGL_EXT_present_opaque extension we create wayland
buffers with the opaque variant of the surface format, while the
underlying image is created with the normal surface format. However,
there is no guarantee that the compositor supports that opaque format,
or that we can use that format with all the modifiers of the surface
format.

Since this is completely out of the control of the application, and the
compositor will disconnect the client with an error if the format is not
supported, this commit:

1. Fails EGL surface creation if it determines that the opaque format
   cannot be used, either because it's not present at all, or because
   it shares no modifier with the non-opaque format.
2. When creating the DRI image ensures that we use a modifier that's
   also supported by the opaque format.
---
 src/egl/drivers/dri2/platform_wayland.c | 80 ++++++++++++++++++++++---
 1 file changed, 71 insertions(+), 9 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 8f48e97a0a56d..2a6ed0714c48d 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -622,6 +622,29 @@ static const struct zwp_linux_dmabuf_feedback_v1_listener
       .done = surface_dmabuf_feedback_done,
 };
 
+static bool
+dri2_wl_modifiers_have_common(struct u_vector *modifiers1,
+                              struct u_vector *modifiers2)
+{
+   uint64_t *mod1, *mod2;
+
+   /* If both modifier vectors are empty, assume there is a compatible
+    * implicit modifier. */
+   if (u_vector_length(modifiers1) == 0 && u_vector_length(modifiers2) == 0)
+       return true;
+
+   u_vector_foreach(mod1, modifiers1)
+   {
+      u_vector_foreach(mod2, modifiers2)
+      {
+         if (*mod1 == *mod2)
+            return true;
+      }
+   }
+
+   return false;
+}
+
 /**
  * Called via eglCreateWindowSurface(), drv->CreateWindowSurface().
  */
@@ -680,6 +703,20 @@ dri2_wl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
       dri2_surf->format = dri2_wl_shm_format_from_visual_idx(visual_idx);
    }
 
+   if (dri2_surf->base.PresentOpaque) {
+      uint32_t opaque_fourcc =
+         dri2_wl_visuals[visual_idx].opaque_wl_drm_format;
+      int opaque_visual_idx = dri2_wl_visual_idx_from_fourcc(opaque_fourcc);
+
+      if (!server_supports_format(&dri2_dpy->formats, opaque_visual_idx) ||
+          !dri2_wl_modifiers_have_common(
+               &dri2_dpy->formats.modifiers[visual_idx],
+               &dri2_dpy->formats.modifiers[opaque_visual_idx])) {
+         _eglError(EGL_BAD_MATCH, "Unsupported opaque format");
+         goto cleanup_surf;
+      }
+   }
+
    dri2_surf->wl_queue = wl_display_create_queue_with_name(dri2_dpy->wl_dpy,
                                                            "mesa egl surface queue");
    if (!dri2_surf->wl_queue) {
@@ -973,26 +1010,47 @@ create_dri_image(struct dri2_egl_surface *dri2_surf,
       dri2_egl_display(dri2_surf->base.Resource.Display);
    int visual_idx = dri2_wl_visual_idx_from_fourcc(dri2_surf->format);
    struct u_vector modifiers_subset;
+   struct u_vector modifiers_subset_opaque;
    uint64_t *modifiers;
    unsigned int num_modifiers;
-   struct u_vector *modifiers_set;
+   struct u_vector *modifiers_present;
 
    assert(visual_idx != -1);
 
-   if (!BITSET_TEST(formats->formats_bitmap, visual_idx))
-      return;
+   if (dri2_surf->base.PresentOpaque) {
+      uint32_t opaque_fourcc =
+            dri2_wl_visuals[visual_idx].opaque_wl_drm_format;
+      int opaque_visual_idx = dri2_wl_visual_idx_from_fourcc(opaque_fourcc);
+      struct u_vector *modifiers_dpy = &dri2_dpy->formats.modifiers[visual_idx];
+      /* Surface creation would have failed if we didn't support the matching
+       * opaque format. */
+      assert(opaque_visual_idx != -1);
 
-   modifiers_set = &formats->modifiers[visual_idx];
+      if (!BITSET_TEST(formats->formats_bitmap, opaque_visual_idx))
+         return;
 
-   if (surf_modifiers_count > 0) {
-      if (!intersect_modifiers(&modifiers_subset, modifiers_set, surf_modifiers,
-                               surf_modifiers_count))
+      if (!intersect_modifiers(&modifiers_subset_opaque,
+                               &formats->modifiers[opaque_visual_idx],
+                               u_vector_tail(modifiers_dpy),
+                               u_vector_length(modifiers_dpy)))
+         return;
+
+      modifiers_present = &modifiers_subset_opaque;
+   } else {
+      if (!BITSET_TEST(formats->formats_bitmap, visual_idx))
          return;
+      modifiers_present = &formats->modifiers[visual_idx];
+   }
+
+   if (surf_modifiers_count > 0) {
+      if (!intersect_modifiers(&modifiers_subset, modifiers_present,
+                               surf_modifiers, surf_modifiers_count))
+         goto cleanup_present;
       modifiers = u_vector_tail(&modifiers_subset);
       num_modifiers = u_vector_length(&modifiers_subset);
    } else {
-      modifiers = u_vector_tail(modifiers_set);
-      num_modifiers = u_vector_length(modifiers_set);
+      modifiers = u_vector_tail(modifiers_present);
+      num_modifiers = u_vector_length(modifiers_present);
    }
 
    /* For the purposes of this function, an INVALID modifier on
@@ -1013,6 +1071,10 @@ create_dri_image(struct dri2_egl_surface *dri2_surf,
       u_vector_finish(&modifiers_subset);
       update_surface(dri2_surf, dri2_surf->back->dri_image);
    }
+
+cleanup_present:
+   if (modifiers_present == &modifiers_subset_opaque)
+      u_vector_finish(&modifiers_subset_opaque);
 }
 
 static void
-- 
GitLab


From 1bdd3ab897ba63b4942c51207ad3768740ada031 Mon Sep 17 00:00:00 2001
From: msizanoen <msizanoen@qtmlabs.xyz>
Date: Tue, 4 Jun 2024 22:32:41 +0700
Subject: [PATCH 3/3] egl/wayland: Fix direct scanout with
 EGL_EXT_present_opaque

We select the feedback tranche according to the image format but not the
actual format that we will use for presentation. This breaks direct
scanout in cases where the application selected a visual with an alpha
channel but using EGL_EXT_present_opaque which previously worked as
expected.

Fix this by selecting the feedback tranche according to the actual
presentation format.

Fixes: 9ea9a963aa1 ("egl/wayland: Fix EGL_EXT_present_opaque")
---
 src/egl/drivers/dri2/platform_wayland.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 2a6ed0714c48d..6822cdec759a2 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -530,11 +530,18 @@ surface_dmabuf_feedback_tranche_formats(
 {
    struct dri2_egl_surface *dri2_surf = data;
    struct dmabuf_feedback *feedback = &dri2_surf->pending_dmabuf_feedback;
+   uint32_t present_format = dri2_surf->format;
    uint64_t *modifier_ptr, modifier;
    uint32_t format;
    uint16_t *index;
    int visual_idx;
 
+   if (dri2_surf->base.PresentOpaque) {
+      visual_idx = dri2_wl_visual_idx_from_fourcc(present_format);
+      if (visual_idx != -1)
+         present_format = dri2_wl_visuals[visual_idx].opaque_wl_drm_format;
+   }
+
    /* Compositor may advertise or not a format table. If it does, we use it.
     * Otherwise, we steal the most recent advertised format table. If we don't
     * have a most recent advertised format table, compositor did something
@@ -564,7 +571,7 @@ surface_dmabuf_feedback_tranche_formats(
 
       /* Skip formats that are not the one the surface is already using. We
        * can't switch to another format. */
-      if (format != dri2_surf->format)
+      if (format != present_format)
          continue;
 
       /* We are sure that the format is supported because of the check above. */
-- 
GitLab

