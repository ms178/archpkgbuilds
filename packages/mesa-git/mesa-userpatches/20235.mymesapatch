From 6bf2d77febe41b0247a8efbbf428314d4c7072b0 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 8 Dec 2022 17:07:52 +0100
Subject: [PATCH 1/9] wsi/common: Add common implementation of
 vkReleaseSwapchainImagesEXT.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common.c         | 23 +++++++++++++++++++++++
 src/vulkan/wsi/wsi_common_private.h |  3 +++
 2 files changed, 26 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index f010972be1cb..14847acc1bad 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -986,6 +986,29 @@ wsi_DestroySwapchainKHR(VkDevice _device,
    swapchain->destroy(swapchain, alloc);
 }
 
+VKAPI_ATTR VkResult VKAPI_CALL
+wsi_ReleaseSwapchainImagesEXT(VkDevice _device,
+                              const VkReleaseSwapchainImagesInfoEXT *pReleaseInfo)
+{
+   VK_FROM_HANDLE(wsi_swapchain, swapchain, pReleaseInfo->swapchain);
+   VkResult result = swapchain->release_images(swapchain,
+                                               pReleaseInfo->imageIndexCount,
+                                               pReleaseInfo->pImageIndices);
+
+   if (result != VK_SUCCESS)
+      return result;
+
+   if (swapchain->wsi->set_memory_ownership) {
+      for (uint32_t i = 0; i < pReleaseInfo->imageIndexCount; i++) {
+         uint32_t image_index = pReleaseInfo->pImageIndices[i];
+         VkDeviceMemory mem = swapchain->get_wsi_image(swapchain, image_index)->memory;
+         swapchain->wsi->set_memory_ownership(swapchain->device, mem, false);
+      }
+   }
+
+   return VK_SUCCESS;
+}
+
 VkResult
 wsi_common_get_images(VkSwapchainKHR _swapchain,
                       uint32_t *pSwapchainImageCount,
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 308fb57a5f51..148d6db99e13 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -188,6 +188,9 @@ struct wsi_swapchain {
    VkResult (*wait_for_present)(struct wsi_swapchain *swap_chain,
                                 uint64_t present_id,
                                 uint64_t timeout);
+   VkResult (*release_images)(struct wsi_swapchain *swap_chain,
+                              uint32_t count,
+                              const uint32_t *indices);
 };
 
 bool
-- 
GitLab


From 2fc4a738b2da2ffd35ec524d9a7c28141181d13b Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 8 Dec 2022 17:08:21 +0100
Subject: [PATCH 2/9] wsi/x11: Implement EXT_swapchain_maintenance1.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common_x11.c | 84 ++++++++++++++++++++++++++++++++-
 1 file changed, 82 insertions(+), 2 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 6de51942301f..2bc2020d5305 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -658,9 +658,15 @@ x11_get_min_image_count(const struct wsi_device *wsi_device, bool is_xwayland)
    return is_xwayland ? 4 : 3;
 }
 
+static unsigned
+x11_get_min_image_count_for_present_mode(struct wsi_device *wsi_device,
+                                         struct wsi_x11_connection *wsi_conn,
+                                         VkPresentModeKHR present_mode);
+
 static VkResult
 x11_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
                              struct wsi_device *wsi_device,
+                             const VkSurfacePresentModeEXT *present_mode,
                              VkSurfaceCapabilitiesKHR *caps)
 {
    xcb_connection_t *conn = x11_surface_get_connection(icd_surface);
@@ -703,7 +709,12 @@ x11_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
                                       VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    }
 
-   caps->minImageCount = x11_get_min_image_count(wsi_device, wsi_conn->is_xwayland);
+   if (present_mode) {
+      caps->minImageCount = x11_get_min_image_count_for_present_mode(wsi_device, wsi_conn, present_mode->presentMode);
+   } else {
+      caps->minImageCount = x11_get_min_image_count(wsi_device, wsi_conn->is_xwayland);
+   }
+
    /* There is no real maximum */
    caps->maxImageCount = 0;
 
@@ -729,8 +740,10 @@ x11_surface_get_capabilities2(VkIcdSurfaceBase *icd_surface,
 {
    assert(caps->sType == VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR);
 
+   const VkSurfacePresentModeEXT *present_mode = vk_find_struct_const(info_next, SURFACE_PRESENT_MODE_EXT);
+
    VkResult result =
-      x11_surface_get_capabilities(icd_surface, wsi_device,
+      x11_surface_get_capabilities(icd_surface, wsi_device, present_mode,
                                    &caps->surfaceCapabilities);
 
    if (result != VK_SUCCESS)
@@ -744,6 +757,33 @@ x11_surface_get_capabilities2(VkIcdSurfaceBase *icd_surface,
          break;
       }
 
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
+         /* Unsupported. */
+         VkSurfacePresentScalingCapabilitiesEXT *scaling = (void *)ext;
+         scaling->supportedPresentScaling = 0;
+         scaling->supportedPresentGravityX = 0;
+         scaling->supportedPresentGravityY = 0;
+         scaling->minScaledImageExtent = caps->surfaceCapabilities.minImageExtent;
+         scaling->maxScaledImageExtent = caps->surfaceCapabilities.maxImageExtent;
+         break;
+      }
+
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
+         /* To be able to toggle between FIFO and non-FIFO, we would need a rewrite to always use FIFO thread
+          * mechanism. For now, only return the input, making this effectively unsupported. */
+         assert(present_mode);
+         VkSurfacePresentModeCompatibilityEXT *compat = (void *)ext;
+         if (compat->pPresentModes) {
+            if (compat->presentModeCount) {
+               compat->pPresentModes[0] = present_mode->presentMode;
+               compat->presentModeCount = 1;
+            }
+         } else {
+            compat->presentModeCount = 1;
+         }
+         break;
+      }
+
       default:
          /* Ignored */
          break;
@@ -1645,6 +1685,34 @@ x11_present_to_x11(struct x11_swapchain *chain, uint32_t image_index,
    return result;
 }
 
+static VkResult
+x11_release_images(struct wsi_swapchain *wsi_chain,
+                   uint32_t count, const uint32_t *indices)
+{
+   struct x11_swapchain *chain = (struct x11_swapchain *)wsi_chain;
+   if (chain->status == VK_ERROR_SURFACE_LOST_KHR)
+      return chain->status;
+
+   for (uint32_t i = 0; i < count; i++) {
+      uint32_t index = indices[i];
+      assert(index < chain->base.image_count);
+
+      if (chain->has_acquire_queue) {
+         wsi_queue_push(&chain->acquire_queue, index);
+      } else {
+         assert(chain->images[index].busy);
+         chain->images[index].busy = false;
+      }
+   }
+
+   if (!chain->has_acquire_queue) {
+      assert(chain->present_poll_acquire_count >= count);
+      chain->present_poll_acquire_count -= count;
+   }
+
+   return VK_SUCCESS;
+}
+
 /**
  * Acquire a ready-to-use image from the swapchain.
  *
@@ -2441,6 +2509,17 @@ static VkResult x11_wait_for_present(struct wsi_swapchain *wsi_chain,
    return result;
 }
 
+static unsigned
+x11_get_min_image_count_for_present_mode(struct wsi_device *wsi_device,
+                                         struct wsi_x11_connection *wsi_conn,
+                                         VkPresentModeKHR present_mode)
+{
+   if (x11_needs_wait_for_fences(wsi_device, wsi_conn, present_mode))
+      return 5;
+   else
+      return x11_get_min_image_count(wsi_device, wsi_conn->is_xwayland);
+}
+
 /**
  * Create the swapchain.
  *
@@ -2569,6 +2648,7 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->base.acquire_next_image = x11_acquire_next_image;
    chain->base.queue_present = x11_queue_present;
    chain->base.wait_for_present = x11_wait_for_present;
+   chain->base.release_images = x11_release_images;
    chain->base.present_mode = present_mode;
    chain->base.image_count = num_images;
    chain->conn = conn;
-- 
GitLab


From 49e63dbd14f8b82828ffb6143ecd8e0398502da5 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 30 Nov 2022 12:07:58 +0100
Subject: [PATCH 3/9] wsi/common: Implement swapchain present fence.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common.c | 17 ++++++++++++-----
 1 file changed, 12 insertions(+), 5 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 14847acc1bad..e76da94239ac 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -1185,9 +1185,10 @@ wsi_AcquireNextImage2KHR(VkDevice _device,
 }
 
 static VkResult wsi_signal_present_id_timeline(struct wsi_swapchain *swapchain,
-                                               VkQueue queue, uint64_t present_id)
+                                               VkQueue queue, uint64_t present_id,
+                                               VkFence present_fence)
 {
-   assert(swapchain->present_id_timeline);
+   assert(swapchain->present_id_timeline || present_fence);
 
    const VkTimelineSemaphoreSubmitInfo timeline_info = {
       .sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
@@ -1202,7 +1203,8 @@ static VkResult wsi_signal_present_id_timeline(struct wsi_swapchain *swapchain,
       .pSignalSemaphores = &swapchain->present_id_timeline,
    };
 
-   return swapchain->wsi->QueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE);
+   uint32_t submit_count = present_id ? 1 : 0;
+   return swapchain->wsi->QueueSubmit(queue, submit_count, &submit_info, present_fence);
 }
 
 VkResult
@@ -1223,6 +1225,8 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       vk_find_struct_const(pPresentInfo->pNext, PRESENT_REGIONS_KHR);
    const VkPresentIdKHR *present_ids =
       vk_find_struct_const(pPresentInfo->pNext, PRESENT_ID_KHR);
+   const VkSwapchainPresentFenceInfoEXT *present_fence_info =
+      vk_find_struct_const(pPresentInfo->pNext, SWAPCHAIN_PRESENT_FENCE_INFO_EXT);
 
    for (uint32_t i = 0; i < pPresentInfo->swapchainCount; i++) {
       VK_FROM_HANDLE(wsi_swapchain, swapchain, pPresentInfo->pSwapchains[i]);
@@ -1374,9 +1378,12 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       uint64_t present_id = 0;
       if (present_ids && present_ids->pPresentIds)
          present_id = present_ids->pPresentIds[i];
+      VkFence present_fence = VK_NULL_HANDLE;
+      if (present_fence_info && present_fence_info->pFences)
+         present_fence = present_fence_info->pFences[i];
 
-      if (present_id) {
-         result = wsi_signal_present_id_timeline(swapchain, queue, present_id);
+      if (present_id || present_fence) {
+         result = wsi_signal_present_id_timeline(swapchain, queue, present_id, present_fence);
          if (result != VK_SUCCESS)
             goto fail_present;
       }
-- 
GitLab


From 9f15d55a6cd854ff78464ce0e6abe94e8757cb32 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 30 Nov 2022 12:21:22 +0100
Subject: [PATCH 4/9] wsi/common: Add comment about
 DEFERRED_ALLOCATION_BIT_EXT.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index e76da94239ac..d266ebc12a55 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -913,6 +913,10 @@ wsi_CreateSwapchainKHR(VkDevice _device,
    else
      alloc = &device->alloc;
 
+   /* Ignore DEFERRED_MEMORY_ALLOCATION_BIT. Would require deep plumbing to be able to take advantage of it.
+    * bool deferred_allocation = pCreateInfo->flags & VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT;
+    */
+
    VkResult result = iface->create_swapchain(surface, _device, wsi_device,
                                              pCreateInfo, alloc,
                                              &swapchain);
-- 
GitLab


From f7ad06fe4b6a249d79bd619e2fd54ee729104784 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 30 Nov 2022 17:17:39 +0100
Subject: [PATCH 5/9] wsi/common: Add function to modify present mode.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common.c         | 6 ++++++
 src/vulkan/wsi/wsi_common_private.h | 2 ++
 2 files changed, 8 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index d266ebc12a55..a1922993681a 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -1231,12 +1231,18 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       vk_find_struct_const(pPresentInfo->pNext, PRESENT_ID_KHR);
    const VkSwapchainPresentFenceInfoEXT *present_fence_info =
       vk_find_struct_const(pPresentInfo->pNext, SWAPCHAIN_PRESENT_FENCE_INFO_EXT);
+   const VkSwapchainPresentModeInfoEXT *present_mode_info =
+      vk_find_struct_const(pPresentInfo->pNext, SWAPCHAIN_PRESENT_MODE_INFO_EXT);
 
    for (uint32_t i = 0; i < pPresentInfo->swapchainCount; i++) {
       VK_FROM_HANDLE(wsi_swapchain, swapchain, pPresentInfo->pSwapchains[i]);
       uint32_t image_index = pPresentInfo->pImageIndices[i];
       VkResult result;
 
+      /* Update the present mode for this present and any subsequent present. */
+      if (present_mode_info && present_mode_info->pPresentModes && swapchain->set_present_mode)
+         swapchain->set_present_mode(swapchain, present_mode_info->pPresentModes[i]);
+
       if (swapchain->fences[image_index] == VK_NULL_HANDLE) {
          const VkFenceCreateInfo fence_info = {
             .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 148d6db99e13..b31961a931ab 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -191,6 +191,8 @@ struct wsi_swapchain {
    VkResult (*release_images)(struct wsi_swapchain *swap_chain,
                               uint32_t count,
                               const uint32_t *indices);
+   void (*set_present_mode)(struct wsi_swapchain *swap_chain,
+                            VkPresentModeKHR mode);
 };
 
 bool
-- 
GitLab


From edf3c7a4e1956df93232c34773a82a7ddd6a9b36 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 30 Nov 2022 17:18:00 +0100
Subject: [PATCH 6/9] wsi/wayland: Implement EXT_swapchain_maintenance1.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common_wayland.c | 131 ++++++++++++++++++++++++----
 1 file changed, 116 insertions(+), 15 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 928ec2165057..ec9407c06d7e 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -963,18 +963,56 @@ static const VkPresentModeKHR present_modes[] = {
    VK_PRESENT_MODE_FIFO_KHR,
 };
 
+static uint32_t
+wsi_wl_surface_get_min_image_count(const VkSurfacePresentModeEXT *present_mode)
+{
+   if (present_mode && (present_mode->presentMode == VK_PRESENT_MODE_FIFO_KHR ||
+                        present_mode->presentMode == VK_PRESENT_MODE_FIFO_RELAXED_KHR)) {
+      /* If we receive a FIFO present mode, only 2 images is required for forward progress.
+       * Performance with 2 images will be questionable, but we only allow it for applications
+       * using the new API, so we don't risk breaking any existing apps this way.
+       * Other ICDs expose 2 images here already. */
+       return 2;
+   } else {
+      /* For true mailbox mode, we need at least 4 images:
+       *  1) One to scan out from
+       *  2) One to have queued for scan-out
+       *  3) One to be currently held by the Wayland compositor
+       *  4) One to render to
+       */
+      return 4;
+   }
+}
+
+static uint32_t
+wsi_wl_surface_get_min_image_count_for_mode_group(const VkSwapchainPresentModesCreateInfoEXT *modes)
+{
+   /* If we don't provide the PresentModeCreateInfo struct, we must be backwards compatible,
+    * and assume that minImageCount is the default one, i.e. 4, which supports both FIFO and MAILBOX. */
+   if (!modes) {
+      return wsi_wl_surface_get_min_image_count(NULL);
+   }
+
+   uint32_t max_required = 0;
+   for (uint32_t i = 0; i < modes->presentModeCount; i++) {
+      const VkSurfacePresentModeEXT mode = {
+         VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT,
+         NULL,
+         modes->pPresentModes[i]
+      };
+      max_required = MAX2(max_required, wsi_wl_surface_get_min_image_count(&mode));
+   }
+
+   return max_required;
+}
+
 static VkResult
 wsi_wl_surface_get_capabilities(VkIcdSurfaceBase *surface,
                                 struct wsi_device *wsi_device,
+                                const VkSurfacePresentModeEXT *present_mode,
                                 VkSurfaceCapabilitiesKHR* caps)
 {
-   /* For true mailbox mode, we need at least 4 images:
-    *  1) One to scan out from
-    *  2) One to have queued for scan-out
-    *  3) One to be currently held by the Wayland compositor
-    *  4) One to render to
-    */
-   caps->minImageCount = 4;
+   caps->minImageCount = wsi_wl_surface_get_min_image_count(present_mode);
    /* There is no real maximum */
    caps->maxImageCount = 0;
 
@@ -1012,8 +1050,10 @@ wsi_wl_surface_get_capabilities2(VkIcdSurfaceBase *surface,
 {
    assert(caps->sType == VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR);
 
+   const VkSurfacePresentModeEXT *present_mode = vk_find_struct_const(info_next, SURFACE_PRESENT_MODE_EXT);
+
    VkResult result =
-      wsi_wl_surface_get_capabilities(surface, wsi_device,
+      wsi_wl_surface_get_capabilities(surface, wsi_device, present_mode,
                                       &caps->surfaceCapabilities);
 
    vk_foreach_struct(ext, caps->pNext) {
@@ -1024,6 +1064,40 @@ wsi_wl_surface_get_capabilities2(VkIcdSurfaceBase *surface,
          break;
       }
 
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
+         /* Unsupported. */
+         VkSurfacePresentScalingCapabilitiesEXT *scaling = (void *)ext;
+         scaling->supportedPresentScaling = 0;
+         scaling->supportedPresentGravityX = 0;
+         scaling->supportedPresentGravityY = 0;
+         scaling->minScaledImageExtent = caps->surfaceCapabilities.minImageExtent;
+         scaling->maxScaledImageExtent = caps->surfaceCapabilities.maxImageExtent;
+         break;
+      }
+
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
+         /* Can easily toggle between FIFO and MAILBOX on Wayland. */
+         assert(present_mode);
+         VkSurfacePresentModeCompatibilityEXT *compat = (void *)ext;
+         if (compat->pPresentModes) {
+            VK_OUTARRAY_MAKE_TYPED(VkPresentModeKHR, modes, compat->pPresentModes, &compat->presentModeCount);
+            /* Must always return queried present mode even when truncating. */
+            vk_outarray_append_typed(VkPresentModeKHR, &modes, mode) {
+               *mode = present_mode->presentMode;
+            }
+            for (unsigned i = 0; i < ARRAY_SIZE(present_modes); i++) {
+               if (present_modes[i] != present_mode->presentMode) {
+                  vk_outarray_append_typed(VkPresentModeKHR, &modes, mode) {
+                     *mode = present_modes[i];
+                  }
+               }
+            }
+         } else {
+            compat->presentModeCount = ARRAY_SIZE(present_modes);
+         }
+         break;
+      }
+
       default:
          /* Ignored */
          break;
@@ -1460,6 +1534,27 @@ wsi_wl_swapchain_get_wsi_image(struct wsi_swapchain *wsi_chain,
    return &chain->images[image_index].base;
 }
 
+static VkResult
+wsi_wl_swapchain_release_images(struct wsi_swapchain *wsi_chain,
+                                uint32_t count, const uint32_t *indices)
+{
+   struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
+   for (uint32_t i = 0; i < count; i++) {
+      uint32_t index = indices[i];
+      assert(chain->images[index].busy);
+      chain->images[index].busy = false;
+   }
+   return VK_SUCCESS;
+}
+
+static void
+wsi_wl_swapchain_set_present_mode(struct wsi_swapchain *wsi_chain,
+                                  VkPresentModeKHR mode)
+{
+   struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
+   chain->base.present_mode = mode;
+}
+
 static VkResult
 wsi_wl_swapchain_acquire_next_image(struct wsi_swapchain *wsi_chain,
                                     const VkAcquireNextImageInfoKHR *info,
@@ -1565,13 +1660,14 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
       memcpy(image->shm_ptr, image->base.cpu_map,
              image->base.row_pitches[0] * chain->extent.height);
    }
-   if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR) {
-      while (!chain->fifo_ready) {
-         int ret = wl_display_dispatch_queue(wsi_wl_surface->display->wl_display,
-                                             wsi_wl_surface->display->queue);
-         if (ret < 0)
-            return VK_ERROR_OUT_OF_DATE_KHR;
-      }
+
+   /* For EXT_swapchain_maintenance1. We might have transitioned from FIFO to MAILBOX.
+    * In this case we need to let the FIFO request complete, before presenting MAILBOX. */
+   while (!chain->fifo_ready) {
+      int ret = wl_display_dispatch_queue(wsi_wl_surface->display->wl_display,
+                                          wsi_wl_surface->display->queue);
+      if (ret < 0)
+         return VK_ERROR_OUT_OF_DATE_KHR;
    }
 
    assert(image_index < chain->base.image_count);
@@ -1594,6 +1690,9 @@ wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
       chain->frame = wl_surface_frame(wsi_wl_surface->surface);
       wl_callback_add_listener(chain->frame, &frame_listener, chain);
       chain->fifo_ready = false;
+   } else {
+      /* If we present MAILBOX, any subsequent presentation in FIFO can replace this image. */
+      chain->fifo_ready = true;
    }
 
    chain->images[image_index].busy = true;
@@ -1871,6 +1970,8 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->base.get_wsi_image = wsi_wl_swapchain_get_wsi_image;
    chain->base.acquire_next_image = wsi_wl_swapchain_acquire_next_image;
    chain->base.queue_present = wsi_wl_swapchain_queue_present;
+   chain->base.release_images = wsi_wl_swapchain_release_images;
+   chain->base.set_present_mode = wsi_wl_swapchain_set_present_mode;
    chain->base.present_mode = wsi_swapchain_get_present_mode(wsi_device, pCreateInfo);
    chain->base.image_count = num_images;
    chain->extent = pCreateInfo->imageExtent;
-- 
GitLab


From 81e0a9355bb307745126a87359192574378fb189 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Thu, 8 Dec 2022 16:48:12 +0100
Subject: [PATCH 7/9] wsi/display: Implement EXT_swapchain_maintenance1.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common_display.c | 61 +++++++++++++++++++++++++++++
 1 file changed, 61 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 83b0b38d434b..6a27ae0d0a63 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -955,6 +955,8 @@ wsi_display_surface_get_capabilities2(VkIcdSurfaceBase *icd_surface,
 
    struct wsi_surface_supported_counters *counters =
       vk_find_struct( caps->pNext, WSI_SURFACE_SUPPORTED_COUNTERS_MESA);
+   const VkSurfacePresentModeEXT *present_mode =
+      vk_find_struct_const(info_next, SURFACE_PRESENT_MODE_EXT);
 
    if (counters) {
       result = wsi_display_surface_get_surface_counters(
@@ -962,6 +964,46 @@ wsi_display_surface_get_capabilities2(VkIcdSurfaceBase *icd_surface,
          &counters->supported_surface_counters);
    }
 
+   vk_foreach_struct(ext, caps->pNext) {
+      switch (ext->sType) {
+      case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: {
+         VkSurfaceProtectedCapabilitiesKHR *protected = (void *)ext;
+         protected->supportsProtected = VK_FALSE;
+         break;
+      }
+
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
+         /* Unsupported. */
+         VkSurfacePresentScalingCapabilitiesEXT *scaling = (void *)ext;
+         scaling->supportedPresentScaling = 0;
+         scaling->supportedPresentGravityX = 0;
+         scaling->supportedPresentGravityY = 0;
+         scaling->minScaledImageExtent = caps->surfaceCapabilities.minImageExtent;
+         scaling->maxScaledImageExtent = caps->surfaceCapabilities.maxImageExtent;
+         break;
+      }
+
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
+         /* We only support FIFO. */
+         assert(present_mode);
+         VkSurfacePresentModeCompatibilityEXT *compat = (void *)ext;
+         if (compat->pPresentModes) {
+            if (compat->presentModeCount) {
+               compat->pPresentModes[0] = present_mode->presentMode;
+               compat->presentModeCount = 1;
+            }
+         } else {
+            compat->presentModeCount = 1;
+         }
+         break;
+      }
+
+      default:
+         /* Ignored */
+         break;
+      }
+   }
+
    return result;
 }
 
@@ -1398,6 +1440,24 @@ wsi_device_wait_for_event(struct wsi_display *wsi,
    return cond_timedwait_ns(&wsi->hotplug_cond, &wsi->wait_mutex, timeout_ns);
 }
 
+static VkResult
+wsi_display_release_images(struct wsi_swapchain *drv_chain,
+                           uint32_t count, const uint32_t *indices)
+{
+   struct wsi_display_swapchain *chain = (struct wsi_display_swapchain *)drv_chain;
+   if (chain->status == VK_ERROR_SURFACE_LOST_KHR)
+      return chain->status;
+
+   for (uint32_t i = 0; i < count; i++) {
+      uint32_t index = indices[i];
+      assert(index < chain->base.image_count);
+      assert(chain->images[index].state == WSI_IMAGE_DRAWING);
+      chain->images[index].state = WSI_IMAGE_IDLE;
+   }
+
+   return VK_SUCCESS;
+}
+
 static VkResult
 wsi_display_acquire_next_image(struct wsi_swapchain *drv_chain,
                                const VkAcquireNextImageInfoKHR *info,
@@ -2088,6 +2148,7 @@ wsi_display_surface_create_swapchain(
    chain->base.destroy = wsi_display_swapchain_destroy;
    chain->base.get_wsi_image = wsi_display_get_wsi_image;
    chain->base.acquire_next_image = wsi_display_acquire_next_image;
+   chain->base.release_images = wsi_display_release_images;
    chain->base.queue_present = wsi_display_queue_present;
    chain->base.wait_for_present = wsi_display_wait_for_present;
    chain->base.present_mode = wsi_swapchain_get_present_mode(wsi_device, create_info);
-- 
GitLab


From fb51b940daa403fd698004e0c5867a60c23d4419 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 11 Jan 2023 11:49:49 +0100
Subject: [PATCH 8/9] wsi/win32: Implement VK_EXT_swapchain_maintenance1.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Jesse Natalie <jenatalie@microsoft.com>
---
 src/vulkan/wsi/wsi_common_win32.cpp | 50 +++++++++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common_win32.cpp b/src/vulkan/wsi/wsi_common_win32.cpp
index aac403640a65..6a2b124ecd7d 100644
--- a/src/vulkan/wsi/wsi_common_win32.cpp
+++ b/src/vulkan/wsi/wsi_common_win32.cpp
@@ -228,6 +228,8 @@ wsi_win32_surface_get_capabilities2(VkIcdSurfaceBase *surface,
 {
    assert(caps->sType == VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR);
 
+   const VkSurfacePresentModeEXT *present_mode = vk_find_struct_const(info_next, SURFACE_PRESENT_MODE_EXT);
+
    VkResult result =
       wsi_win32_surface_get_capabilities(surface, wsi_device,
                                       &caps->surfaceCapabilities);
@@ -240,6 +242,32 @@ wsi_win32_surface_get_capabilities2(VkIcdSurfaceBase *surface,
          break;
       }
 
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {
+         /* Unsupported. */
+         VkSurfacePresentScalingCapabilitiesEXT *scaling = (void *)ext;
+         scaling->supportedPresentScaling = 0;
+         scaling->supportedPresentGravityX = 0;
+         scaling->supportedPresentGravityY = 0;
+         scaling->minScaledImageExtent = caps->surfaceCapabilities.minImageExtent;
+         scaling->maxScaledImageExtent = caps->surfaceCapabilities.maxImageExtent;
+         break;
+      }
+
+      case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
+         /* Unsupported, just report the input present mode. */
+         assert(present_mode);
+         VkSurfacePresentModeCompatibilityEXT *compat = (void *)ext;
+         if (compat->pPresentModes) {
+            if (compat->presentModeCount) {
+               compat->pPresentModes[0] = present_mode->presentMode;
+               compat->presentModeCount = 1;
+            }
+         } else {
+            compat->presentModeCount = 1;
+         }
+         break;
+      }
+
       default:
          /* Ignored */
          break;
@@ -570,6 +598,27 @@ wsi_win32_get_wsi_image(struct wsi_swapchain *drv_chain,
    return &chain->images[image_index].base;
 }
 
+static VkResult
+wsi_win32_release_images(struct wsi_swapchain *drv_chain,
+                         uint32_t count, const uint32_t *indices)
+{
+   struct wsi_win32_swapchain *chain =
+      (struct wsi_win32_swapchain *)drv_chain;
+
+   if (chain->status == VK_ERROR_SURFACE_LOST_KHR)
+      return chain->status;
+
+   for (uint32_t i = 0; i < count; i++) {
+      uint32_t index = indices[i];
+      assert(index < chain->base.image_count);
+      assert(chain->images[index].state == WSI_IMAGE_DRAWING);
+      chain->images[index].state = WSI_IMAGE_IDLE;
+   }
+
+   return VK_SUCCESS;
+}
+
+
 static VkResult
 wsi_win32_acquire_next_image(struct wsi_swapchain *drv_chain,
                              const VkAcquireNextImageInfoKHR *info,
@@ -788,6 +837,7 @@ wsi_win32_surface_create_swapchain(
    chain->base.destroy = wsi_win32_swapchain_destroy;
    chain->base.get_wsi_image = wsi_win32_get_wsi_image;
    chain->base.acquire_next_image = wsi_win32_acquire_next_image;
+   chain->base.release_images = wsi_win32_release_images;
    chain->base.queue_present = wsi_win32_queue_present;
    chain->base.present_mode = wsi_swapchain_get_present_mode(wsi_device, create_info);
    chain->extent = create_info->imageExtent;
-- 
GitLab


From 29a7e9c2394734b55f61378c9badf3a3be46a8d4 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 30 Nov 2022 12:08:56 +0100
Subject: [PATCH 9/9] radv: Expose VK_EXT_swapchain_maintenance1.

Passes dEQP-VK.wsi.*.maintenance1.*.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/amd/vulkan/radv_device.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index c433d5068c04..b99b676d8374 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -471,6 +471,7 @@ static const struct vk_instance_extension_table radv_instance_extensions_support
    .KHR_get_surface_capabilities2 = true,
    .KHR_surface = true,
    .KHR_surface_protected_capabilities = true,
+   .EXT_surface_maintenance1 = true,
    .EXT_swapchain_colorspace = true,
 #endif
 #ifdef VK_USE_PLATFORM_WAYLAND_KHR
@@ -655,6 +656,9 @@ radv_physical_device_get_supported_extensions(const struct radv_physical_device
       .EXT_shader_subgroup_vote = true,
       .EXT_shader_viewport_index_layer = true,
       .EXT_subgroup_size_control = true,
+#ifdef RADV_USE_WSI_PLATFORM
+      .EXT_swapchain_maintenance1 = true,
+#endif
       .EXT_texel_buffer_alignment = true,
       .EXT_transform_feedback = true,
       .EXT_vertex_attribute_divisor = true,
@@ -2008,6 +2012,14 @@ radv_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
          features->shaderEarlyAndLateFragmentTests = true;
          break;
       }
+#ifdef RADV_USE_WSI_PLATFORM
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {
+         VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *features =
+               (VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *)ext;
+         features->swapchainMaintenance1 = true;
+         break;
+      }
+#endif
       default:
          break;
       }
-- 
GitLab

