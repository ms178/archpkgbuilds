From aade34b93313dabc9d2d9dff118dd3b870a69f9d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 6 Feb 2024 03:10:58 -0500
Subject: [PATCH 1/4] mesa: enable GL names reuse for _mesa_HashTable, remove
 the alternative

The code that generates IDs from the max used ID is removed.
In practice, we don't need that to be fast because IDs aren't allocated
often.

The reason is that this is a prerequisite for replacing hash_table with
util_sparse_array for faster lookups.

This matches the behavior of closed source drivers and driconf workarounds
are no longer needed.

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 .../auxiliary/pipe-loader/driinfo_gallium.h   |  1 -
 src/gallium/auxiliary/util/u_driconf.c        |  1 -
 src/gallium/include/frontend/api.h            |  1 -
 src/mesa/main/consts_exts.h                   |  5 -
 src/mesa/main/hash.c                          | 91 +++----------------
 src/mesa/main/hash.h                          | 10 +-
 src/mesa/state_tracker/st_context.c           | 18 ----
 src/mesa/state_tracker/st_extensions.c        |  2 -
 src/util/00-mesa-defaults.conf                |  9 --
 src/util/driconf.h                            |  3 -
 10 files changed, 15 insertions(+), 126 deletions(-)

diff --git a/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h b/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h
index f764916b6303a..6975859f466e6 100644
--- a/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h
+++ b/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h
@@ -41,7 +41,6 @@ DRI_CONF_SECTION_DEBUG
    DRI_CONF_GLTHREAD_NOP_CHECK_FRAMEBUFFER_STATUS(false)
    DRI_CONF_FORCE_COMPAT_PROFILE(false)
    DRI_CONF_FORCE_COMPAT_SHADERS(false)
-   DRI_CONF_FORCE_GL_NAMES_REUSE(false)
    DRI_CONF_FORCE_GL_MAP_BUFFER_SYNCHRONIZED(false)
    DRI_CONF_TRANSCODE_ETC(false)
    DRI_CONF_TRANSCODE_ASTC(false)
diff --git a/src/gallium/auxiliary/util/u_driconf.c b/src/gallium/auxiliary/util/u_driconf.c
index 165de18b131c3..497b8ac98de2f 100644
--- a/src/gallium/auxiliary/util/u_driconf.c
+++ b/src/gallium/auxiliary/util/u_driconf.c
@@ -67,7 +67,6 @@ u_driconf_fill_st_options(struct st_config_options *options,
    query_bool_option(glthread_nop_check_framebuffer_status);
    query_bool_option(ignore_map_unsynchronized);
    query_bool_option(ignore_discard_framebuffer);
-   query_bool_option(force_gl_names_reuse);
    query_bool_option(force_gl_map_buffer_synchronized);
    query_bool_option(transcode_etc);
    query_bool_option(transcode_astc);
diff --git a/src/gallium/include/frontend/api.h b/src/gallium/include/frontend/api.h
index 712cbe9e47e97..abf5d59c9c2eb 100644
--- a/src/gallium/include/frontend/api.h
+++ b/src/gallium/include/frontend/api.h
@@ -196,7 +196,6 @@ struct st_config_options
    bool ignore_map_unsynchronized;
    bool ignore_discard_framebuffer;
    bool force_integer_tex_nearest;
-   bool force_gl_names_reuse;
    bool force_gl_map_buffer_synchronized;
    bool transcode_etc;
    bool transcode_astc;
diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 6cc973a717582..142afb04c0cea 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -675,11 +675,6 @@ struct gl_constants
     */
    GLchar GLSLZeroInit;
 
-   /**
-    * Force GL names reuse. Needed by SPECviewperf13.
-    */
-   GLboolean ForceGLNamesReuse;
-
    /**
     * Treat integer textures using GL_LINEAR filters as GL_NEAREST.
     */
diff --git a/src/mesa/main/hash.c b/src/mesa/main/hash.c
index 53ba52cfdedd1..51c54b63fb52e 100644
--- a/src/mesa/main/hash.c
+++ b/src/mesa/main/hash.c
@@ -40,7 +40,6 @@
 #include "hash.h"
 #include "util/hash_table.h"
 #include "util/u_memory.h"
-#include "util/u_idalloc.h"
 
 /**
  * Magic GLuint object name that gets stored outside of the struct hash_table.
@@ -120,8 +119,11 @@ _mesa_NewHashTable(void)
 
       _mesa_hash_table_set_deleted_key(table->ht, uint_key(DELETED_KEY_VALUE));
       simple_mtx_init(&table->Mutex, mtx_plain);
-   }
-   else {
+
+      util_idalloc_init(&table->id_alloc, 8);
+      /* Mark ID = 0 as used, so that we don't return it. */
+      util_idalloc_reserve(&table->id_alloc, 0);
+   } else {
       _mesa_error_no_memory(__func__);
    }
 
@@ -157,32 +159,11 @@ _mesa_DeleteHashTable(struct _mesa_HashTable *table,
    }
 
    _mesa_hash_table_destroy(table->ht, NULL);
-   if (table->id_alloc) {
-      util_idalloc_fini(table->id_alloc);
-      free(table->id_alloc);
-   }
-
+   util_idalloc_fini(&table->id_alloc);
    simple_mtx_destroy(&table->Mutex);
    FREE(table);
 }
 
-static void init_name_reuse(struct _mesa_HashTable *table)
-{
-   assert(_mesa_hash_table_num_entries(table->ht) == 0);
-   table->id_alloc = MALLOC_STRUCT(util_idalloc);
-   util_idalloc_init(table->id_alloc, 8);
-   ASSERTED GLuint reserve0 = util_idalloc_alloc(table->id_alloc);
-   assert (reserve0 == 0);
-}
-
-void
-_mesa_HashEnableNameReuse(struct _mesa_HashTable *table)
-{
-   _mesa_HashLockMutex(table);
-   init_name_reuse(table);
-   _mesa_HashUnlockMutex(table);
-}
-
 /**
  * Lookup an entry in the hash table without locking the mutex.
  *
@@ -252,9 +233,6 @@ _mesa_HashInsertLocked(struct _mesa_HashTable *table, GLuint key, void *data,
 
    assert(key);
 
-   if (key > table->MaxKey)
-      table->MaxKey = key;
-
    if (key == DELETED_KEY_VALUE) {
       table->deleted_key_data = data;
    } else {
@@ -266,8 +244,8 @@ _mesa_HashInsertLocked(struct _mesa_HashTable *table, GLuint key, void *data,
       }
    }
 
-   if (!isGenName && table->id_alloc)
-      util_idalloc_reserve(table->id_alloc, key);
+   if (!isGenName)
+      util_idalloc_reserve(&table->id_alloc, key);
 }
 
 /**
@@ -313,8 +291,7 @@ _mesa_HashRemoveLocked(struct _mesa_HashTable *table, GLuint key)
       _mesa_hash_table_remove(table->ht, entry);
    }
 
-   if (table->id_alloc)
-      util_idalloc_free(table->id_alloc, key);
+   util_idalloc_free(&table->id_alloc, key);
 }
 
 void
@@ -362,61 +339,19 @@ _mesa_HashWalk(struct _mesa_HashTable *table,
  * \param table the hash table.
  * \param numKeys number of keys needed.
  * 
- * \return Starting key of free block or 0 if failure.
- *
- * If there are enough free keys between the maximum key existing in the table
- * (_mesa_HashTable::MaxKey) and the maximum key possible, then simply return
- * the adjacent key. Otherwise do a full search for a free key block in the
- * allowable key range.
+ * \return Starting key of a free block
  */
 GLuint
 _mesa_HashFindFreeKeyBlock(struct _mesa_HashTable *table, GLuint numKeys)
 {
-   const GLuint maxKey = ~((GLuint) 0) - 1;
-   if (table->id_alloc) {
-      return util_idalloc_alloc_range(table->id_alloc, numKeys);
-   } else if (maxKey - numKeys > table->MaxKey) {
-      /* the quick solution */
-      return table->MaxKey + 1;
-   }
-   else {
-      /* the slow solution */
-      GLuint freeCount = 0;
-      GLuint freeStart = 1;
-      GLuint key;
-      for (key = 1; key != maxKey; key++) {
-	 if (_mesa_HashLookupLocked(table, key)) {
-	    /* darn, this key is already in use */
-	    freeCount = 0;
-	    freeStart = key+1;
-	 }
-	 else {
-	    /* this key not in use, check if we've found enough */
-	    freeCount++;
-	    if (freeCount == numKeys) {
-	       return freeStart;
-	    }
-	 }
-      }
-      /* cannot allocate a block of numKeys consecutive keys */
-      return 0;
-   }
+   return util_idalloc_alloc_range(&table->id_alloc, numKeys);
 }
 
 bool
 _mesa_HashFindFreeKeys(struct _mesa_HashTable *table, GLuint* keys, GLuint numKeys)
 {
-   if (!table->id_alloc) {
-      GLuint first = _mesa_HashFindFreeKeyBlock(table, numKeys);
-      for (int i = 0; i < numKeys; i++) {
-         keys[i] = first + i;
-      }
-      return first != 0;
-   }
-
-   for (int i = 0; i < numKeys; i++) {
-      keys[i] = util_idalloc_alloc(table->id_alloc);
-   }
+   for (int i = 0; i < numKeys; i++)
+      keys[i] = util_idalloc_alloc(&table->id_alloc);
 
    return true;
 }
diff --git a/src/mesa/main/hash.h b/src/mesa/main/hash.h
index 72842a5ec13d8..f1897153d377a 100644
--- a/src/mesa/main/hash.h
+++ b/src/mesa/main/hash.h
@@ -36,18 +36,15 @@
 
 #include "c11/threads.h"
 #include "util/simple_mtx.h"
-
-struct util_idalloc;
+#include "util/u_idalloc.h"
 
 /**
  * The hash table data structure.
  */
 struct _mesa_HashTable {
    struct hash_table *ht;
-   GLuint MaxKey;                        /**< highest key inserted so far */
    simple_mtx_t Mutex;                   /**< mutual exclusion lock */
-   /* Used when name reuse is enabled */
-   struct util_idalloc *id_alloc;
+   struct util_idalloc id_alloc;
 
    /** Value that would be in the table for DELETED_KEY_VALUE. */
    void *deleted_key_data;
@@ -98,9 +95,6 @@ bool
 _mesa_HashFindFreeKeys(struct _mesa_HashTable *table, GLuint* keys,
                        GLuint numKeys);
 
-void
-_mesa_HashEnableNameReuse(struct _mesa_HashTable *table);
-
 /* Inline functions. */
 
 /**
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 086d3b1585a3f..937026bf74372 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -728,24 +728,6 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
 
    st->bitmap.cache.empty = true;
 
-   if (ctx->Const.ForceGLNamesReuse && ctx->Shared->RefCount == 1) {
-      _mesa_HashEnableNameReuse(ctx->Shared->TexObjects);
-      _mesa_HashEnableNameReuse(ctx->Shared->ShaderObjects);
-      _mesa_HashEnableNameReuse(ctx->Shared->BufferObjects);
-      _mesa_HashEnableNameReuse(ctx->Shared->SamplerObjects);
-      _mesa_HashEnableNameReuse(ctx->Shared->FrameBuffers);
-      _mesa_HashEnableNameReuse(ctx->Shared->RenderBuffers);
-      _mesa_HashEnableNameReuse(ctx->Shared->MemoryObjects);
-      _mesa_HashEnableNameReuse(ctx->Shared->SemaphoreObjects);
-   }
-   /* SPECviewperf13/sw-04 crashes since a56849ddda6 if Mesa is build with
-    * -O3 on gcc 7.5, which doesn't happen with ForceGLNamesReuse, which is
-    * the default setting for SPECviewperf because it simulates glGen behavior
-    * of closed source drivers.
-    */
-   if (ctx->Const.ForceGLNamesReuse)
-      _mesa_HashEnableNameReuse(ctx->Query.QueryObjects);
-
    _mesa_override_extensions(ctx);
    _mesa_compute_version(ctx);
 
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 91d593dfc9004..945c8c3623f1d 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -1282,8 +1282,6 @@ void st_init_extensions(struct pipe_screen *screen,
       consts->GLSLZeroInit = screen->get_param(screen, PIPE_CAP_GLSL_ZERO_INIT);
    }
 
-   consts->ForceGLNamesReuse = options->force_gl_names_reuse;
-
    consts->ForceIntegerTexNearest = options->force_integer_tex_nearest;
 
    consts->VendorOverride = options->force_gl_vendor;
diff --git a/src/util/00-mesa-defaults.conf b/src/util/00-mesa-defaults.conf
index 22358549b9253..047b4c81f0f35 100644
--- a/src/util/00-mesa-defaults.conf
+++ b/src/util/00-mesa-defaults.conf
@@ -383,7 +383,6 @@ TODO: document the other workarounds.
             <option name="vblank_mode" value="0" />
             <option name="allow_glsl_extension_directive_midshader" value="true" />
             <option name="allow_glsl_120_subset_in_110" value="true" />
-            <option name="force_gl_names_reuse" value="true" />
             <!-- This makes it use GL_NVX_gpu_memory_info to query memory info
                  instead of non-existent GLX_AMD_gpu_association. Yes, it checks
                  the vendor string, not the extension list. -->
@@ -876,14 +875,6 @@ TODO: document the other workarounds.
             <option name="glsl_correct_derivatives_after_discard" value="true" />
         </application>
 
-        <!-- Workaround for STAR WARS: Knights of the Old Republic relying on
-             non-specified OpenGL behavior (expecting texture names to be
-             small enough to fit in the static array).
-          -->
-        <application name="SWKOTOR (wine)" executable="swkotor.exe">
-            <option name="force_gl_names_reuse" value="true"/>
-        </application>
-
         <application name="Assault Android Cactus (32-bit)" executable="cactus_demo.x86">
             <option name="vs_position_always_precise" value="true" />
         </application>
diff --git a/src/util/driconf.h b/src/util/driconf.h
index 6a7331f3f9ef7..a86ad764a30b8 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -269,9 +269,6 @@
    DRI_CONF_OPT_I(override_vram_size, -1, -1, 2147483647, \
                   "Override the VRAM size advertised to the application in MiB (-1 = default)")
 
-#define DRI_CONF_FORCE_GL_NAMES_REUSE(def) \
-   DRI_CONF_OPT_B(force_gl_names_reuse, def, "Force GL names reuse")
-
 #define DRI_CONF_FORCE_GL_MAP_BUFFER_SYNCHRONIZED(def) \
    DRI_CONF_OPT_B(force_gl_map_buffer_synchronized, def, "Override GL_MAP_UNSYNCHRONIZED_BIT.")
 
-- 
GitLab


From 6c4046f3026fe5c7f70bc6b3df27d22e07cfc715 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 6 Feb 2024 03:45:15 -0500
Subject: [PATCH 2/4] mesa: replace _mesa_HashTable::ht with util_sparse_array
 for faster lookups

This reduces the overhead of _mesa_HashLookupLocked by 19% according to
sysprof, which could be inaccurate.

While this commit inlines _mesa_HashLookupLocked for a better gain,
the testing was done without inlining to make it fair.

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 src/mesa/main/hash.c | 159 +++----------------------------------------
 src/mesa/main/hash.h |  67 ++++++++++++------
 src/util/u_idalloc.h |   8 +++
 3 files changed, 62 insertions(+), 172 deletions(-)

diff --git a/src/mesa/main/hash.c b/src/mesa/main/hash.c
index 51c54b63fb52e..71f1f7dd2fce0 100644
--- a/src/mesa/main/hash.c
+++ b/src/mesa/main/hash.c
@@ -41,63 +41,6 @@
 #include "util/hash_table.h"
 #include "util/u_memory.h"
 
-/**
- * Magic GLuint object name that gets stored outside of the struct hash_table.
- *
- * The hash table needs a particular pointer to be the marker for a key that
- * was deleted from the table, along with NULL for the "never allocated in the
- * table" marker.  Legacy GL allows any GLuint to be used as a GL object name,
- * and we use a 1:1 mapping from GLuints to key pointers, so we need to be
- * able to track a GLuint that happens to match the deleted key outside of
- * struct hash_table.  We tell the hash table to use "1" as the deleted key
- * value, so that we test the deleted-key-in-the-table path as best we can.
- */
-#define DELETED_KEY_VALUE 1
-
-/** @{
- * Mapping from our use of GLuint as both the key and the hash value to the
- * hash_table.h API
- *
- * There exist many integer hash functions, designed to avoid collisions when
- * the integers are spread across key space with some patterns.  In GL, the
- * pattern (in the case of glGen*()ed object IDs) is that the keys are unique
- * contiguous integers starting from 1.  Because of that, we just use the key
- * as the hash value, to minimize the cost of the hash function.  If objects
- * are never deleted, we will never see a collision in the table, because the
- * table resizes itself when it approaches full, and thus key % table_size ==
- * key.
- *
- * The case where we could have collisions for genned objects would be
- * something like: glGenBuffers(&a, 100); glDeleteBuffers(&a + 50, 50);
- * glGenBuffers(&b, 100), because objects 1-50 and 101-200 are allocated at
- * the end of that sequence, instead of 1-150.  So far it doesn't appear to be
- * a problem.
- */
-static inline bool
-uint_key_compare(const void *a, const void *b)
-{
-   return a == b;
-}
-
-static inline uint32_t
-uint_hash(GLuint id)
-{
-   return id;
-}
-
-static inline uint32_t
-uint_key_hash(const void *key)
-{
-   return uint_hash((uintptr_t)key);
-}
-
-static inline void *
-uint_key(GLuint id)
-{
-   return (void *)(uintptr_t) id;
-}
-/** @} */
-
 /**
  * Create a new hash table.
  * 
@@ -109,15 +52,7 @@ _mesa_NewHashTable(void)
    struct _mesa_HashTable *table = CALLOC_STRUCT(_mesa_HashTable);
 
    if (table) {
-      table->ht = _mesa_hash_table_create(NULL, uint_key_hash,
-                                          uint_key_compare);
-      if (table->ht == NULL) {
-         free(table);
-         _mesa_error_no_memory(__func__);
-         return NULL;
-      }
-
-      _mesa_hash_table_set_deleted_key(table->ht, uint_key(DELETED_KEY_VALUE));
+      util_sparse_array_init(&table->array, sizeof(void*), 1024);
       simple_mtx_init(&table->Mutex, mtx_plain);
 
       util_idalloc_init(&table->id_alloc, 8);
@@ -150,68 +85,18 @@ _mesa_DeleteHashTable(struct _mesa_HashTable *table,
                       void *userData)
 {
    if (free_callback) {
-      hash_table_foreach(table->ht, entry) {
-         free_callback(entry->data, userData);
-      }
-      if (table->deleted_key_data) {
-         free_callback(table->deleted_key_data, userData);
+      util_idalloc_foreach_no_zero_safe(&table->id_alloc, id) {
+         free_callback(*(void**)util_sparse_array_get(&table->array, id),
+                       userData);
       }
    }
 
-   _mesa_hash_table_destroy(table->ht, NULL);
    util_idalloc_fini(&table->id_alloc);
+   util_sparse_array_finish(&table->array);
    simple_mtx_destroy(&table->Mutex);
    FREE(table);
 }
 
-/**
- * Lookup an entry in the hash table without locking the mutex.
- *
- * The hash table mutex must be locked manually by calling
- * _mesa_HashLockMutex() before calling this function.
- *
- * \param table the hash table.
- * \param key the key.
- *
- * \return pointer to user's data or NULL if key not in table
- */
-void *
-_mesa_HashLookupLocked(struct _mesa_HashTable *table, GLuint key)
-{
-   const struct hash_entry *entry;
-
-   assert(key);
-
-   if (key == DELETED_KEY_VALUE)
-      return table->deleted_key_data;
-
-   entry = _mesa_hash_table_search_pre_hashed(table->ht,
-                                              uint_hash(key),
-                                              uint_key(key));
-   if (!entry)
-      return NULL;
-
-   return entry->data;
-}
-
-/**
- * Lookup an entry in the hash table.
- * 
- * \param table the hash table.
- * \param key the key.
- * 
- * \return pointer to user's data or NULL if key not in table
- */
-void *
-_mesa_HashLookup(struct _mesa_HashTable *table, GLuint key)
-{
-   void *res;
-   _mesa_HashLockMutex(table);
-   res = _mesa_HashLookupLocked(table, key);
-   _mesa_HashUnlockMutex(table);
-   return res;
-}
-
 /**
  * Insert a key/pointer pair into the hash table without locking the mutex.
  * If an entry with this key already exists we'll replace the existing entry.
@@ -228,21 +113,8 @@ void
 _mesa_HashInsertLocked(struct _mesa_HashTable *table, GLuint key, void *data,
                        GLboolean isGenName)
 {
-   uint32_t hash = uint_hash(key);
-   struct hash_entry *entry;
-
    assert(key);
-
-   if (key == DELETED_KEY_VALUE) {
-      table->deleted_key_data = data;
-   } else {
-      entry = _mesa_hash_table_search_pre_hashed(table->ht, hash, uint_key(key));
-      if (entry) {
-         entry->data = data;
-      } else {
-         _mesa_hash_table_insert_pre_hashed(table->ht, hash, uint_key(key), data);
-      }
-   }
+   *(void**)util_sparse_array_get(&table->array, key) = data;
 
    if (!isGenName)
       util_idalloc_reserve(&table->id_alloc, key);
@@ -278,19 +150,8 @@ _mesa_HashInsert(struct _mesa_HashTable *table, GLuint key, void *data,
 void
 _mesa_HashRemoveLocked(struct _mesa_HashTable *table, GLuint key)
 {
-   struct hash_entry *entry;
-
    assert(key);
-
-   if (key == DELETED_KEY_VALUE) {
-      table->deleted_key_data = NULL;
-   } else {
-      entry = _mesa_hash_table_search_pre_hashed(table->ht,
-                                                 uint_hash(key),
-                                                 uint_key(key));
-      _mesa_hash_table_remove(table->ht, entry);
-   }
-
+   *(void**)util_sparse_array_get(&table->array, key) = NULL;
    util_idalloc_free(&table->id_alloc, key);
 }
 
@@ -316,11 +177,9 @@ _mesa_HashWalkLocked(struct _mesa_HashTable *table,
 {
    assert(callback);
 
-   hash_table_foreach(table->ht, entry) {
-      callback(entry->data, userData);
+   util_idalloc_foreach_no_zero_safe(&table->id_alloc, id) {
+      callback(*(void**)util_sparse_array_get(&table->array, id), userData);
    }
-   if (table->deleted_key_data)
-      callback(table->deleted_key_data, userData);
 }
 
 void
diff --git a/src/mesa/main/hash.h b/src/mesa/main/hash.h
index f1897153d377a..f866c7e14eec5 100644
--- a/src/mesa/main/hash.h
+++ b/src/mesa/main/hash.h
@@ -36,18 +36,18 @@
 
 #include "c11/threads.h"
 #include "util/simple_mtx.h"
+#include "util/sparse_array.h"
 #include "util/u_idalloc.h"
 
 /**
- * The hash table data structure.
+ * The not-really-hash-table data structure. It pretends to be a hash table,
+ * but it uses util_idalloc to keep track of GL object IDs and
+ * util_sparse_array for storing entries. Lookups only access the array.
  */
 struct _mesa_HashTable {
-   struct hash_table *ht;
-   simple_mtx_t Mutex;                   /**< mutual exclusion lock */
+   struct util_sparse_array array;
    struct util_idalloc id_alloc;
-
-   /** Value that would be in the table for DELETED_KEY_VALUE. */
-   void *deleted_key_data;
+   simple_mtx_t Mutex;
 };
 
 struct _mesa_HashTable *
@@ -58,9 +58,6 @@ _mesa_DeleteHashTable(struct _mesa_HashTable *table,
                       void (*free_callback)(void *data, void *userData),
                       void *userData);
 
-void *
-_mesa_HashLookup(struct _mesa_HashTable *table, GLuint key);
-
 void
 _mesa_HashInsert(struct _mesa_HashTable *table, GLuint key, void *data,
                  GLboolean isGenName);
@@ -68,9 +65,6 @@ _mesa_HashInsert(struct _mesa_HashTable *table, GLuint key, void *data,
 void
 _mesa_HashRemove(struct _mesa_HashTable *table, GLuint key);
 
-void *
-_mesa_HashLookupLocked(struct _mesa_HashTable *table, GLuint key);
-
 void
 _mesa_HashInsertLocked(struct _mesa_HashTable *table,
                        GLuint key, void *data, GLboolean isGenName);
@@ -123,16 +117,6 @@ _mesa_HashUnlockMutex(struct _mesa_HashTable *table)
    simple_mtx_unlock(&table->Mutex);
 }
 
-static inline struct gl_buffer_object *
-_mesa_HashLookupMaybeLocked(struct _mesa_HashTable *table, GLuint key,
-                            bool locked)
-{
-   if (locked)
-      return _mesa_HashLookupLocked(table, key);
-   else
-      return _mesa_HashLookup(table, key);
-}
-
 static inline void
 _mesa_HashLockMaybeLocked(struct _mesa_HashTable *table, bool locked)
 {
@@ -147,4 +131,43 @@ _mesa_HashUnlockMaybeLocked(struct _mesa_HashTable *table, bool locked)
       _mesa_HashUnlockMutex(table);
 }
 
+/**
+ * Lookup an entry in the hash table without locking the mutex.
+ *
+ * The hash table mutex must be locked manually by calling
+ * _mesa_HashLockMutex() before calling this function.
+ *
+ * \return pointer to user's data or NULL if key not in table
+ */
+static inline void *
+_mesa_HashLookupLocked(struct _mesa_HashTable *table, GLuint key)
+{
+   assert(key);
+   return *(void**)util_sparse_array_get(&table->array, key);
+}
+
+/**
+ * Lookup an entry in the hash table.
+ *
+ * \return pointer to user's data or NULL if key not in table
+ */
+static inline void *
+_mesa_HashLookup(struct _mesa_HashTable *table, GLuint key)
+{
+   _mesa_HashLockMutex(table);
+   void *res = _mesa_HashLookupLocked(table, key);
+   _mesa_HashUnlockMutex(table);
+   return res;
+}
+
+static inline struct gl_buffer_object *
+_mesa_HashLookupMaybeLocked(struct _mesa_HashTable *table, GLuint key,
+                            bool locked)
+{
+   if (locked)
+      return _mesa_HashLookupLocked(table, key);
+   else
+      return _mesa_HashLookup(table, key);
+}
+
 #endif
diff --git a/src/util/u_idalloc.h b/src/util/u_idalloc.h
index cedc1e303867d..834f5db180b08 100644
--- a/src/util/u_idalloc.h
+++ b/src/util/u_idalloc.h
@@ -81,6 +81,14 @@ util_idalloc_exists(struct util_idalloc *buf, unsigned id)
       while (mask) \
          if ((id = i * 32 + u_bit_scan(&mask)), true)
 
+/* This allows freeing IDs while iterating. */
+#define util_idalloc_foreach_no_zero_safe(buf, id) \
+   for (uint32_t i = 0, bit, id, count = (buf)->num_elements, \
+         mask = count ? (buf)->data[0] & ~0x1 : 0; \
+        i < count; mask = ++i < count ? (buf)->data[i] : 0) \
+      while (mask) \
+         if ((bit = u_bit_scan(&mask), id = i * 32 + bit), \
+             (buf)->data[i] & BITFIELD_BIT(bit))
 
 /* Thread-safe variant. */
 struct util_idalloc_mt {
-- 
GitLab


From 28117821ce566aa393cb534c66d82f7db3e51c6e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 6 Feb 2024 04:36:10 -0500
Subject: [PATCH 3/4] mesa: declare _mesa_HashTable inside structures instead
 of as a pointer

This removes the pointer indirection every time we access the hash table.

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 src/mesa/main/arbprogram.c          | 14 +++---
 src/mesa/main/arrayobj.c            | 10 ++--
 src/mesa/main/atifragshader.c       | 20 ++++----
 src/mesa/main/bufferobj.c           | 50 +++++++++----------
 src/mesa/main/debug.c               |  4 +-
 src/mesa/main/dlist.c               | 34 ++++++-------
 src/mesa/main/externalobjects.c     | 36 +++++++-------
 src/mesa/main/externalobjects.h     |  8 ++--
 src/mesa/main/fbobject.c            | 54 ++++++++++-----------
 src/mesa/main/glthread.c            | 15 ++----
 src/mesa/main/glthread.h            |  4 +-
 src/mesa/main/glthread_varray.c     |  8 ++--
 src/mesa/main/hash.c                | 29 ++++-------
 src/mesa/main/hash.h                |  8 ++--
 src/mesa/main/mtypes.h              | 35 +++++++-------
 src/mesa/main/performance_monitor.c | 12 ++---
 src/mesa/main/performance_query.c   | 12 ++---
 src/mesa/main/pipelineobj.c         | 12 ++---
 src/mesa/main/queryobj.c            | 14 +++---
 src/mesa/main/queryobj.h            |  2 +-
 src/mesa/main/samplerobj.c          | 24 +++++-----
 src/mesa/main/shaderapi.c           | 30 ++++++------
 src/mesa/main/shaderimage.c         |  4 +-
 src/mesa/main/shaderobj.c           | 18 +++----
 src/mesa/main/shared.c              | 74 +++++++++++------------------
 src/mesa/main/teximage.c            |  4 +-
 src/mesa/main/texobj.c              | 24 +++++-----
 src/mesa/main/transformfeedback.c   | 14 +++---
 src/mesa/main/varray.c              |  8 ++--
 src/mesa/program/program.c          |  2 +-
 src/mesa/state_tracker/st_context.c |  4 +-
 src/mesa/state_tracker/st_program.c |  4 +-
 32 files changed, 276 insertions(+), 315 deletions(-)

diff --git a/src/mesa/main/arbprogram.c b/src/mesa/main/arbprogram.c
index 3911e55217c3d..9938123c8f14d 100644
--- a/src/mesa/main/arbprogram.c
+++ b/src/mesa/main/arbprogram.c
@@ -87,7 +87,7 @@ lookup_or_create_program(GLuint id, GLenum target, const char* caller)
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
             return NULL;
          }
-         _mesa_HashInsert(ctx->Shared->Programs, id, newProg, isGenName);
+         _mesa_HashInsert(&ctx->Shared->Programs, id, newProg, isGenName);
       }
       else if (newProg->Target != target) {
          _mesa_error(ctx, GL_INVALID_OPERATION,
@@ -181,7 +181,7 @@ _mesa_DeleteProgramsARB(GLsizei n, const GLuint *ids)
       if (ids[i] != 0) {
          struct gl_program *prog = _mesa_lookup_program(ctx, ids[i]);
          if (prog == &_mesa_DummyProgram) {
-            _mesa_HashRemove(ctx->Shared->Programs, ids[i]);
+            _mesa_HashRemove(&ctx->Shared->Programs, ids[i]);
          }
          else if (prog) {
             /* Unbind program if necessary */
@@ -205,7 +205,7 @@ _mesa_DeleteProgramsARB(GLsizei n, const GLuint *ids)
                return;
             }
             /* The ID is immediately available for re-use now */
-            _mesa_HashRemove(ctx->Shared->Programs, ids[i]);
+            _mesa_HashRemove(&ctx->Shared->Programs, ids[i]);
             _mesa_reference_program(ctx, &prog, NULL);
          }
       }
@@ -232,17 +232,17 @@ _mesa_GenProgramsARB(GLsizei n, GLuint *ids)
    if (!ids)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->Programs);
+   _mesa_HashLockMutex(&ctx->Shared->Programs);
 
-   _mesa_HashFindFreeKeys(ctx->Shared->Programs, ids, n);
+   _mesa_HashFindFreeKeys(&ctx->Shared->Programs, ids, n);
 
    /* Insert pointer to dummy program as placeholder */
    for (i = 0; i < (GLuint) n; i++) {
-      _mesa_HashInsertLocked(ctx->Shared->Programs, ids[i],
+      _mesa_HashInsertLocked(&ctx->Shared->Programs, ids[i],
                              &_mesa_DummyProgram, true);
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->Programs);
+   _mesa_HashUnlockMutex(&ctx->Shared->Programs);
 }
 
 
diff --git a/src/mesa/main/arrayobj.c b/src/mesa/main/arrayobj.c
index cb623024b8d45..dbb156fc9c103 100644
--- a/src/mesa/main/arrayobj.c
+++ b/src/mesa/main/arrayobj.c
@@ -218,7 +218,7 @@ _mesa_lookup_vao(struct gl_context *ctx, GLuint id)
          vao = ctx->Array.LastLookedUpVAO;
       } else {
          vao = (struct gl_vertex_array_object *)
-            _mesa_HashLookupLocked(ctx->Array.Objects, id);
+            _mesa_HashLookupLocked(&ctx->Array.Objects, id);
 
          _mesa_reference_vao(ctx, &ctx->Array.LastLookedUpVAO, vao);
       }
@@ -267,7 +267,7 @@ _mesa_lookup_vao_err(struct gl_context *ctx, GLuint id,
          vao = ctx->Array.LastLookedUpVAO;
       } else {
          vao = (struct gl_vertex_array_object *)
-            _mesa_HashLookupLocked(ctx->Array.Objects, id);
+            _mesa_HashLookupLocked(&ctx->Array.Objects, id);
 
          /* The ARB_direct_state_access specification says:
           *
@@ -978,7 +978,7 @@ delete_vertex_arrays(struct gl_context *ctx, GLsizei n, const GLuint *ids)
             _mesa_BindVertexArray_no_error(0);
 
          /* The ID is immediately freed for re-use */
-         _mesa_HashRemoveLocked(ctx->Array.Objects, obj->Name);
+         _mesa_HashRemoveLocked(&ctx->Array.Objects, obj->Name);
 
          if (ctx->Array.LastLookedUpVAO == obj)
             _mesa_reference_vao(ctx, &ctx->Array.LastLookedUpVAO, NULL);
@@ -1033,7 +1033,7 @@ gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays,
    if (!arrays)
       return;
 
-   _mesa_HashFindFreeKeys(ctx->Array.Objects, arrays, n);
+   _mesa_HashFindFreeKeys(&ctx->Array.Objects, arrays, n);
 
    /* For the sake of simplicity we create the array objects in both
     * the Gen* and Create* cases.  The only difference is the value of
@@ -1048,7 +1048,7 @@ gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays,
          return;
       }
       obj->EverBound = create;
-      _mesa_HashInsertLocked(ctx->Array.Objects, obj->Name, obj, true);
+      _mesa_HashInsertLocked(&ctx->Array.Objects, obj->Name, obj, true);
    }
 }
 
diff --git a/src/mesa/main/atifragshader.c b/src/mesa/main/atifragshader.c
index d2c8387ef9f4f..fc8aaa490d0f1 100644
--- a/src/mesa/main/atifragshader.c
+++ b/src/mesa/main/atifragshader.c
@@ -216,14 +216,14 @@ _mesa_GenFragmentShadersATI(GLuint range)
       return 0;
    }
 
-   _mesa_HashLockMutex(ctx->Shared->ATIShaders);
+   _mesa_HashLockMutex(&ctx->Shared->ATIShaders);
 
-   first = _mesa_HashFindFreeKeyBlock(ctx->Shared->ATIShaders, range);
+   first = _mesa_HashFindFreeKeyBlock(&ctx->Shared->ATIShaders, range);
    for (i = 0; i < range; i++) {
-      _mesa_HashInsertLocked(ctx->Shared->ATIShaders, first + i, &DummyShader, true);
+      _mesa_HashInsertLocked(&ctx->Shared->ATIShaders, first + i, &DummyShader, true);
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->ATIShaders);
+   _mesa_HashUnlockMutex(&ctx->Shared->ATIShaders);
 
    return first;
 }
@@ -250,7 +250,7 @@ _mesa_BindFragmentShaderATI(GLuint id)
    if (curProg->Id != 0) {
       curProg->RefCount--;
       if (curProg->RefCount <= 0) {
-	 _mesa_HashRemove(ctx->Shared->ATIShaders, id);
+	 _mesa_HashRemove(&ctx->Shared->ATIShaders, id);
       }
    }
 
@@ -261,7 +261,7 @@ _mesa_BindFragmentShaderATI(GLuint id)
    else {
       bool isGenName;
       newProg = (struct ati_fragment_shader *)
-         _mesa_HashLookup(ctx->Shared->ATIShaders, id);
+         _mesa_HashLookup(&ctx->Shared->ATIShaders, id);
       isGenName = newProg != NULL;
       if (!newProg || newProg == &DummyShader) {
 	 /* allocate a new program now */
@@ -270,7 +270,7 @@ _mesa_BindFragmentShaderATI(GLuint id)
 	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindFragmentShaderATI");
 	    return;
 	 }
-	 _mesa_HashInsert(ctx->Shared->ATIShaders, id, newProg, isGenName);
+	 _mesa_HashInsert(&ctx->Shared->ATIShaders, id, newProg, isGenName);
       }
 
    }
@@ -295,9 +295,9 @@ _mesa_DeleteFragmentShaderATI(GLuint id)
 
    if (id != 0) {
       struct ati_fragment_shader *prog = (struct ati_fragment_shader *)
-	 _mesa_HashLookup(ctx->Shared->ATIShaders, id);
+	 _mesa_HashLookup(&ctx->Shared->ATIShaders, id);
       if (prog == &DummyShader) {
-	 _mesa_HashRemove(ctx->Shared->ATIShaders, id);
+	 _mesa_HashRemove(&ctx->Shared->ATIShaders, id);
       }
       else if (prog) {
 	 if (ctx->ATIFragmentShader.Current &&
@@ -308,7 +308,7 @@ _mesa_DeleteFragmentShaderATI(GLuint id)
       }
 
       /* The ID is immediately available for re-use now */
-      _mesa_HashRemove(ctx->Shared->ATIShaders, id);
+      _mesa_HashRemove(&ctx->Shared->ATIShaders, id);
       if (prog) {
 	 prog->RefCount--;
 	 if (prog->RefCount <= 0) {
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index a955df9e2b0d7..85ae7fc476539 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -1233,11 +1233,11 @@ _mesa_free_buffer_objects( struct gl_context *ctx )
 				    NULL);
    }
 
-   _mesa_HashLockMutex(ctx->Shared->BufferObjects);
+   _mesa_HashLockMutex(&ctx->Shared->BufferObjects);
    unreference_zombie_buffers_for_ctx(ctx);
-   _mesa_HashWalkLocked(ctx->Shared->BufferObjects,
+   _mesa_HashWalkLocked(&ctx->Shared->BufferObjects,
                         detach_unrefcounted_buffer_from_ctx, ctx);
-   _mesa_HashUnlockMutex(ctx->Shared->BufferObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->BufferObjects);
 }
 
 struct gl_buffer_object *
@@ -1295,9 +1295,9 @@ handle_bind_buffer_gen(struct gl_context *ctx,
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
          return false;
       }
-      _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+      _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                                 ctx->BufferObjectsLocked);
-      _mesa_HashInsertLocked(ctx->Shared->BufferObjects, buffer,
+      _mesa_HashInsertLocked(&ctx->Shared->BufferObjects, buffer,
                              *buf_handle, buf != NULL);
       /* If one context only creates buffers and another context only deletes
        * buffers, buffers don't get released because it only produces zombie
@@ -1306,7 +1306,7 @@ handle_bind_buffer_gen(struct gl_context *ctx,
        * buffers.
        */
       unreference_zombie_buffers_for_ctx(ctx);
-      _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+      _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                   ctx->BufferObjectsLocked);
    }
 
@@ -1391,7 +1391,7 @@ _mesa_lookup_bufferobj(struct gl_context *ctx, GLuint buffer)
       return NULL;
    else
       return (struct gl_buffer_object *)
-         _mesa_HashLookupMaybeLocked(ctx->Shared->BufferObjects, buffer,
+         _mesa_HashLookupMaybeLocked(&ctx->Shared->BufferObjects, buffer,
                                      ctx->BufferObjectsLocked);
 }
 
@@ -1403,7 +1403,7 @@ _mesa_lookup_bufferobj_locked(struct gl_context *ctx, GLuint buffer)
       return NULL;
    else
       return (struct gl_buffer_object *)
-         _mesa_HashLookupLocked(ctx->Shared->BufferObjects, buffer);
+         _mesa_HashLookupLocked(&ctx->Shared->BufferObjects, buffer);
 }
 
 /**
@@ -1442,7 +1442,7 @@ _mesa_lookup_bufferobj_err(struct gl_context *ctx, GLuint buffer,
  *
  * This function assumes that the caller has already locked the
  * hash table mutex by calling
- * _mesa_HashLockMutex(ctx->Shared->BufferObjects).
+ * _mesa_HashLockMutex(&ctx->Shared->BufferObjects).
  */
 struct gl_buffer_object *
 _mesa_multi_bind_lookup_bufferobj(struct gl_context *ctx,
@@ -1763,7 +1763,7 @@ delete_buffers(struct gl_context *ctx, GLsizei n, const GLuint *ids)
 {
    FLUSH_VERTICES(ctx, 0, 0);
 
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
    unreference_zombie_buffers_for_ctx(ctx);
 
@@ -1880,7 +1880,7 @@ delete_buffers(struct gl_context *ctx, GLsizei n, const GLuint *ids)
          }
 
          /* The ID is immediately freed for re-use */
-         _mesa_HashRemoveLocked(ctx->Shared->BufferObjects, ids[i]);
+         _mesa_HashRemoveLocked(&ctx->Shared->BufferObjects, ids[i]);
          /* Make sure we do not run into the classic ABA problem on bind.
           * We don't want to allow re-binding a buffer object that's been
           * "deleted" by glDeleteBuffers().
@@ -1909,7 +1909,7 @@ delete_buffers(struct gl_context *ctx, GLsizei n, const GLuint *ids)
       }
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
@@ -1952,7 +1952,7 @@ create_buffers(struct gl_context *ctx, GLsizei n, GLuint *buffers, bool dsa)
    /*
     * This must be atomic (generation and allocation of buffer object IDs)
     */
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
    /* If one context only creates buffers and another context only deletes
     * buffers, buffers don't get released because it only produces zombie
@@ -1962,7 +1962,7 @@ create_buffers(struct gl_context *ctx, GLsizei n, GLuint *buffers, bool dsa)
     */
    unreference_zombie_buffers_for_ctx(ctx);
 
-   _mesa_HashFindFreeKeys(ctx->Shared->BufferObjects, buffers, n);
+   _mesa_HashFindFreeKeys(&ctx->Shared->BufferObjects, buffers, n);
 
    /* Insert the ID and pointer into the hash table. If non-DSA, insert a
     * DummyBufferObject.  Otherwise, create a new buffer object and insert
@@ -1973,7 +1973,7 @@ create_buffers(struct gl_context *ctx, GLsizei n, GLuint *buffers, bool dsa)
          buf = new_gl_buffer_object(ctx, buffers[i]);
          if (!buf) {
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCreateBuffers");
-            _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+            _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                         ctx->BufferObjectsLocked);
             return;
          }
@@ -1981,10 +1981,10 @@ create_buffers(struct gl_context *ctx, GLsizei n, GLuint *buffers, bool dsa)
       else
          buf = &DummyBufferObject;
 
-      _mesa_HashInsertLocked(ctx->Shared->BufferObjects, buffers[i], buf, true);
+      _mesa_HashInsertLocked(&ctx->Shared->BufferObjects, buffers[i], buf, true);
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
@@ -4373,7 +4373,7 @@ bind_uniform_buffers(struct gl_context *ctx, GLuint first, GLsizei count,
     *       parameters are valid and no other error occurs."
     */
 
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
 
    for (int i = 0; i < count; i++) {
@@ -4425,7 +4425,7 @@ bind_uniform_buffers(struct gl_context *ctx, GLuint first, GLsizei count,
                                USAGE_UNIFORM_BUFFER);
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
@@ -4476,7 +4476,7 @@ bind_shader_storage_buffers(struct gl_context *ctx, GLuint first,
     *       parameters are valid and no other error occurs."
     */
 
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
 
    for (int i = 0; i < count; i++) {
@@ -4528,7 +4528,7 @@ bind_shader_storage_buffers(struct gl_context *ctx, GLuint first,
                                USAGE_SHADER_STORAGE_BUFFER);
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
@@ -4643,7 +4643,7 @@ bind_xfb_buffers(struct gl_context *ctx,
     *       parameters are valid and no other error occurs."
     */
 
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
 
    for (int i = 0; i < count; i++) {
@@ -4711,7 +4711,7 @@ bind_xfb_buffers(struct gl_context *ctx,
                                            offset, size);
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
@@ -4804,7 +4804,7 @@ bind_atomic_buffers(struct gl_context *ctx,
     *       parameters are valid and no other error occurs."
     */
 
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
 
    for (int i = 0; i < count; i++) {
@@ -4853,7 +4853,7 @@ bind_atomic_buffers(struct gl_context *ctx,
                                USAGE_ATOMIC_COUNTER_BUFFER);
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
diff --git a/src/mesa/main/debug.c b/src/mesa/main/debug.c
index 43a68d130e1a3..e81bcd7b6a9c8 100644
--- a/src/mesa/main/debug.c
+++ b/src/mesa/main/debug.c
@@ -412,7 +412,7 @@ _mesa_dump_textures(GLuint writeImages)
 {
    GET_CURRENT_CONTEXT(ctx);
    WriteImages = writeImages;
-   _mesa_HashWalk(ctx->Shared->TexObjects, dump_texture_cb, ctx);
+   _mesa_HashWalk(&ctx->Shared->TexObjects, dump_texture_cb, ctx);
 }
 
 
@@ -445,7 +445,7 @@ _mesa_dump_renderbuffers(GLboolean writeImages)
 {
    GET_CURRENT_CONTEXT(ctx);
    WriteImages = writeImages;
-   _mesa_HashWalk(ctx->Shared->RenderBuffers, dump_renderbuffer_cb, ctx);
+   _mesa_HashWalk(&ctx->Shared->RenderBuffers, dump_renderbuffer_cb, ctx);
 }
 
 
diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index b0184a24e20e0..d50a657d66f05 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -829,7 +829,7 @@ struct gl_display_list *
 _mesa_lookup_list(struct gl_context *ctx, GLuint list, bool locked)
 {
    return (struct gl_display_list *)
-      _mesa_HashLookupMaybeLocked(ctx->Shared->DisplayList, list, locked);
+      _mesa_HashLookupMaybeLocked(&ctx->Shared->DisplayList, list, locked);
 }
 
 
@@ -1113,7 +1113,7 @@ destroy_list(struct gl_context *ctx, GLuint list)
       return;
 
    _mesa_delete_list(ctx, dlist);
-   _mesa_HashRemoveLocked(ctx->Shared->DisplayList, list);
+   _mesa_HashRemoveLocked(&ctx->Shared->DisplayList, list);
 }
 
 
@@ -10928,9 +10928,9 @@ execute_list(struct gl_context *ctx, GLuint list)
          case OPCODE_CALL_LISTS:
             if (ctx->ListState.CallDepth < MAX_LIST_NESTING) {
                ctx->ListState.CallDepth++;
-               _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
+               _mesa_HashUnlockMutex(&ctx->Shared->DisplayList);
                CALL_CallLists(ctx->Dispatch.Exec, (n[1].i, n[2].e, get_pointer(&n[3])));
-               _mesa_HashLockMutex(ctx->Shared->DisplayList);
+               _mesa_HashLockMutex(&ctx->Shared->DisplayList);
                ctx->ListState.CallDepth--;
             }
             break;
@@ -13108,11 +13108,11 @@ _mesa_DeleteLists(GLuint list, GLsizei range)
       return;
    }
 
-   _mesa_HashLockMutex(ctx->Shared->DisplayList);
+   _mesa_HashLockMutex(&ctx->Shared->DisplayList);
    for (i = list; i < list + range; i++) {
       destroy_list(ctx, i);
    }
-   _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
+   _mesa_HashUnlockMutex(&ctx->Shared->DisplayList);
 }
 
 
@@ -13139,19 +13139,19 @@ _mesa_GenLists(GLsizei range)
    /*
     * Make this an atomic operation
     */
-   _mesa_HashLockMutex(ctx->Shared->DisplayList);
+   _mesa_HashLockMutex(&ctx->Shared->DisplayList);
 
-   base = _mesa_HashFindFreeKeyBlock(ctx->Shared->DisplayList, range);
+   base = _mesa_HashFindFreeKeyBlock(&ctx->Shared->DisplayList, range);
    if (base) {
       /* reserve the list IDs by with empty/dummy lists */
       GLint i;
       for (i = 0; i < range; i++) {
-         _mesa_HashInsertLocked(ctx->Shared->DisplayList, base + i,
+         _mesa_HashInsertLocked(&ctx->Shared->DisplayList, base + i,
                                 make_list(base + i, 1), true);
       }
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
+   _mesa_HashUnlockMutex(&ctx->Shared->DisplayList);
 
    return base;
 }
@@ -13347,7 +13347,7 @@ _mesa_EndList(void)
 
    (void) alloc_instruction(ctx, OPCODE_END_OF_LIST, 0);
 
-   _mesa_HashLockMutex(ctx->Shared->DisplayList);
+   _mesa_HashLockMutex(&ctx->Shared->DisplayList);
 
    if (ctx->ListState.Current.UseLoopback)
       replace_op_vertex_list_recursively(ctx, ctx->ListState.CurrentList);
@@ -13399,14 +13399,14 @@ _mesa_EndList(void)
    destroy_list(ctx, ctx->ListState.CurrentList->Name);
 
    /* Install the new list */
-   _mesa_HashInsertLocked(ctx->Shared->DisplayList,
+   _mesa_HashInsertLocked(&ctx->Shared->DisplayList,
                           ctx->ListState.CurrentList->Name,
                           ctx->ListState.CurrentList, false);
 
    if (MESA_VERBOSE & VERBOSE_DISPLAY_LIST)
       mesa_print_display_list(ctx->ListState.CurrentList->Name);
 
-   _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
+   _mesa_HashUnlockMutex(&ctx->Shared->DisplayList);
 
    ctx->ListState.CurrentList = NULL;
    ctx->ListState.CurrentBlock = NULL;
@@ -13450,9 +13450,9 @@ _mesa_CallList(GLuint list)
       ctx->CompileFlag = GL_FALSE;
    }
 
-   _mesa_HashLockMutex(ctx->Shared->DisplayList);
+   _mesa_HashLockMutex(&ctx->Shared->DisplayList);
    execute_list(ctx, list);
-   _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
+   _mesa_HashUnlockMutex(&ctx->Shared->DisplayList);
    ctx->CompileFlag = save_compile_flag;
 
    /* also restore API function pointers to point to "save" versions */
@@ -13507,7 +13507,7 @@ _mesa_CallLists(GLsizei n, GLenum type, const GLvoid * lists)
 
    GLuint base = ctx->List.ListBase;
 
-   _mesa_HashLockMutex(ctx->Shared->DisplayList);
+   _mesa_HashLockMutex(&ctx->Shared->DisplayList);
 
    /* A loop inside a switch is faster than a switch inside a loop. */
    switch (type) {
@@ -13575,7 +13575,7 @@ _mesa_CallLists(GLsizei n, GLenum type, const GLvoid * lists)
       break;
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->DisplayList);
+   _mesa_HashUnlockMutex(&ctx->Shared->DisplayList);
    ctx->CompileFlag = save_compile_flag;
 
    /* also restore API function pointers to point to "save" versions */
diff --git a/src/mesa/main/externalobjects.c b/src/mesa/main/externalobjects.c
index 5dac6d558b57a..0748f42ed8f67 100644
--- a/src/mesa/main/externalobjects.c
+++ b/src/mesa/main/externalobjects.c
@@ -148,20 +148,20 @@ _mesa_DeleteMemoryObjectsEXT(GLsizei n, const GLuint *memoryObjects)
    if (!memoryObjects)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->MemoryObjects);
+   _mesa_HashLockMutex(&ctx->Shared->MemoryObjects);
    for (GLint i = 0; i < n; i++) {
       if (memoryObjects[i] > 0) {
          struct gl_memory_object *delObj
             = _mesa_lookup_memory_object_locked(ctx, memoryObjects[i]);
 
          if (delObj) {
-            _mesa_HashRemoveLocked(ctx->Shared->MemoryObjects,
+            _mesa_HashRemoveLocked(&ctx->Shared->MemoryObjects,
                                    memoryObjects[i]);
             _mesa_delete_memory_object(ctx, delObj);
          }
       }
    }
-   _mesa_HashUnlockMutex(ctx->Shared->MemoryObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->MemoryObjects);
 }
 
 GLboolean GLAPIENTRY
@@ -204,8 +204,8 @@ _mesa_CreateMemoryObjectsEXT(GLsizei n, GLuint *memoryObjects)
    if (!memoryObjects)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->MemoryObjects);
-   if (_mesa_HashFindFreeKeys(ctx->Shared->MemoryObjects, memoryObjects, n)) {
+   _mesa_HashLockMutex(&ctx->Shared->MemoryObjects);
+   if (_mesa_HashFindFreeKeys(&ctx->Shared->MemoryObjects, memoryObjects, n)) {
       for (GLsizei i = 0; i < n; i++) {
          struct gl_memory_object *memObj;
 
@@ -213,18 +213,18 @@ _mesa_CreateMemoryObjectsEXT(GLsizei n, GLuint *memoryObjects)
          memObj = memoryobj_alloc(ctx, memoryObjects[i]);
          if (!memObj) {
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s()", func);
-            _mesa_HashUnlockMutex(ctx->Shared->MemoryObjects);
+            _mesa_HashUnlockMutex(&ctx->Shared->MemoryObjects);
             return;
          }
 
          /* insert into hash table */
-         _mesa_HashInsertLocked(ctx->Shared->MemoryObjects,
+         _mesa_HashInsertLocked(&ctx->Shared->MemoryObjects,
                                 memoryObjects[i],
                                 memObj, true);
       }
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->MemoryObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->MemoryObjects);
 }
 
 void GLAPIENTRY
@@ -784,15 +784,15 @@ _mesa_GenSemaphoresEXT(GLsizei n, GLuint *semaphores)
    if (!semaphores)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->SemaphoreObjects);
-   if (_mesa_HashFindFreeKeys(ctx->Shared->SemaphoreObjects, semaphores, n)) {
+   _mesa_HashLockMutex(&ctx->Shared->SemaphoreObjects);
+   if (_mesa_HashFindFreeKeys(&ctx->Shared->SemaphoreObjects, semaphores, n)) {
       for (GLsizei i = 0; i < n; i++) {
-         _mesa_HashInsertLocked(ctx->Shared->SemaphoreObjects,
+         _mesa_HashInsertLocked(&ctx->Shared->SemaphoreObjects,
                                 semaphores[i], &DummySemaphoreObject, true);
       }
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->SemaphoreObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->SemaphoreObjects);
 }
 
 void GLAPIENTRY
@@ -819,20 +819,20 @@ _mesa_DeleteSemaphoresEXT(GLsizei n, const GLuint *semaphores)
    if (!semaphores)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->SemaphoreObjects);
+   _mesa_HashLockMutex(&ctx->Shared->SemaphoreObjects);
    for (GLint i = 0; i < n; i++) {
       if (semaphores[i] > 0) {
          struct gl_semaphore_object *delObj
             = _mesa_lookup_semaphore_object_locked(ctx, semaphores[i]);
 
          if (delObj) {
-            _mesa_HashRemoveLocked(ctx->Shared->SemaphoreObjects,
+            _mesa_HashRemoveLocked(&ctx->Shared->SemaphoreObjects,
                                    semaphores[i]);
             _mesa_delete_semaphore_object(ctx, delObj);
          }
       }
    }
-   _mesa_HashUnlockMutex(ctx->Shared->SemaphoreObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->SemaphoreObjects);
 }
 
 GLboolean GLAPIENTRY
@@ -1163,7 +1163,7 @@ _mesa_ImportSemaphoreFdEXT(GLuint semaphore,
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
          return;
       }
-      _mesa_HashInsert(ctx->Shared->SemaphoreObjects, semaphore, semObj, true);
+      _mesa_HashInsert(&ctx->Shared->SemaphoreObjects, semaphore, semObj, true);
    }
 
    import_semaphoreobj_fd(ctx, semObj, fd);
@@ -1205,7 +1205,7 @@ _mesa_ImportSemaphoreWin32HandleEXT(GLuint semaphore,
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
          return;
       }
-      _mesa_HashInsert(ctx->Shared->SemaphoreObjects, semaphore, semObj, true);
+      _mesa_HashInsert(&ctx->Shared->SemaphoreObjects, semaphore, semObj, true);
    }
 
    enum pipe_fd_type type = handleType == GL_HANDLE_TYPE_D3D12_FENCE_EXT ?
@@ -1249,7 +1249,7 @@ _mesa_ImportSemaphoreWin32NameEXT(GLuint semaphore,
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
          return;
       }
-      _mesa_HashInsert(ctx->Shared->SemaphoreObjects, semaphore, semObj, true);
+      _mesa_HashInsert(&ctx->Shared->SemaphoreObjects, semaphore, semObj, true);
    }
 
    enum pipe_fd_type type = handleType == GL_HANDLE_TYPE_D3D12_FENCE_EXT ?
diff --git a/src/mesa/main/externalobjects.h b/src/mesa/main/externalobjects.h
index 853451499c318..642c42dc97b55 100644
--- a/src/mesa/main/externalobjects.h
+++ b/src/mesa/main/externalobjects.h
@@ -44,7 +44,7 @@ _mesa_lookup_memory_object(struct gl_context *ctx, GLuint memory)
       return NULL;
 
    return (struct gl_memory_object *)
-      _mesa_HashLookup(ctx->Shared->MemoryObjects, memory);
+      _mesa_HashLookup(&ctx->Shared->MemoryObjects, memory);
 }
 
 static inline struct gl_memory_object *
@@ -54,7 +54,7 @@ _mesa_lookup_memory_object_locked(struct gl_context *ctx, GLuint memory)
       return NULL;
 
    return (struct gl_memory_object *)
-      _mesa_HashLookupLocked(ctx->Shared->MemoryObjects, memory);
+      _mesa_HashLookupLocked(&ctx->Shared->MemoryObjects, memory);
 }
 
 static inline struct gl_semaphore_object *
@@ -64,7 +64,7 @@ _mesa_lookup_semaphore_object(struct gl_context *ctx, GLuint semaphore)
       return NULL;
 
    return (struct gl_semaphore_object *)
-      _mesa_HashLookup(ctx->Shared->SemaphoreObjects, semaphore);
+      _mesa_HashLookup(&ctx->Shared->SemaphoreObjects, semaphore);
 }
 
 static inline struct gl_semaphore_object *
@@ -74,7 +74,7 @@ _mesa_lookup_semaphore_object_locked(struct gl_context *ctx, GLuint semaphore)
       return NULL;
 
    return (struct gl_semaphore_object *)
-      _mesa_HashLookupLocked(ctx->Shared->SemaphoreObjects, semaphore);
+      _mesa_HashLookupLocked(&ctx->Shared->SemaphoreObjects, semaphore);
 }
 
 extern void
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 9f409ac202933..e1aba9c5317f2 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -120,7 +120,7 @@ _mesa_lookup_renderbuffer(struct gl_context *ctx, GLuint id)
       return NULL;
 
    rb = (struct gl_renderbuffer *)
-      _mesa_HashLookup(ctx->Shared->RenderBuffers, id);
+      _mesa_HashLookup(&ctx->Shared->RenderBuffers, id);
    return rb;
 }
 
@@ -158,7 +158,7 @@ _mesa_lookup_framebuffer(struct gl_context *ctx, GLuint id)
       return NULL;
 
    fb = (struct gl_framebuffer *)
-      _mesa_HashLookup(ctx->Shared->FrameBuffers, id);
+      _mesa_HashLookup(&ctx->Shared->FrameBuffers, id);
 
    return fb;
 }
@@ -178,7 +178,7 @@ _mesa_lookup_framebuffer_dsa(struct gl_context *ctx, GLuint id,
    /* Name exists but buffer is not initialized */
    if (fb == &DummyFramebuffer) {
       fb = _mesa_new_framebuffer(ctx, id);
-      _mesa_HashInsert(ctx->Shared->FrameBuffers, id, fb, true);
+      _mesa_HashInsert(&ctx->Shared->FrameBuffers, id, fb, true);
    }
    /* Name doesn't exist */
    else if (!fb) {
@@ -187,7 +187,7 @@ _mesa_lookup_framebuffer_dsa(struct gl_context *ctx, GLuint id,
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
          return NULL;
       }
-      _mesa_HashInsert(ctx->Shared->FrameBuffers, id, fb, false);
+      _mesa_HashInsert(&ctx->Shared->FrameBuffers, id, fb, false);
    }
    return fb;
 }
@@ -1748,7 +1748,7 @@ allocate_renderbuffer_locked(struct gl_context *ctx, GLuint renderbuffer,
       return NULL;
    }
    assert(newRb->AllocStorage);
-   _mesa_HashInsertLocked(ctx->Shared->RenderBuffers, renderbuffer,
+   _mesa_HashInsertLocked(&ctx->Shared->RenderBuffers, renderbuffer,
                           newRb, isGenName);
 
    return newRb;
@@ -1786,10 +1786,10 @@ bind_renderbuffer(GLenum target, GLuint renderbuffer)
       }
 
       if (!newRb) {
-         _mesa_HashLockMutex(ctx->Shared->RenderBuffers);
+         _mesa_HashLockMutex(&ctx->Shared->RenderBuffers);
          newRb = allocate_renderbuffer_locked(ctx, renderbuffer,
                                               isGenName, "glBindRenderbufferEXT");
-         _mesa_HashUnlockMutex(ctx->Shared->RenderBuffers);
+         _mesa_HashUnlockMutex(&ctx->Shared->RenderBuffers);
       }
    }
    else {
@@ -2229,7 +2229,7 @@ _mesa_DeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
              * But the object will not be freed until it's no longer
              * referenced anywhere else.
              */
-            _mesa_HashRemove(ctx->Shared->RenderBuffers, renderbuffers[i]);
+            _mesa_HashRemove(&ctx->Shared->RenderBuffers, renderbuffers[i]);
 
             if (rb != &DummyRenderbuffer) {
                /* no longer referenced by hash table */
@@ -2250,21 +2250,21 @@ create_render_buffers(struct gl_context *ctx, GLsizei n, GLuint *renderbuffers,
    if (!renderbuffers)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->RenderBuffers);
+   _mesa_HashLockMutex(&ctx->Shared->RenderBuffers);
 
-   _mesa_HashFindFreeKeys(ctx->Shared->RenderBuffers, renderbuffers, n);
+   _mesa_HashFindFreeKeys(&ctx->Shared->RenderBuffers, renderbuffers, n);
 
    for (i = 0; i < n; i++) {
       if (dsa) {
          allocate_renderbuffer_locked(ctx, renderbuffers[i], true, func);
       } else {
          /* insert a dummy renderbuffer into the hash table */
-         _mesa_HashInsertLocked(ctx->Shared->RenderBuffers, renderbuffers[i],
+         _mesa_HashInsertLocked(&ctx->Shared->RenderBuffers, renderbuffers[i],
                                 &DummyRenderbuffer, true);
       }
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->RenderBuffers);
+   _mesa_HashUnlockMutex(&ctx->Shared->RenderBuffers);
 }
 
 
@@ -2752,7 +2752,7 @@ _mesa_renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
 
    /* Invalidate the framebuffers the renderbuffer is attached in. */
    if (rb->AttachedAnytime) {
-      _mesa_HashWalk(ctx->Shared->FrameBuffers, invalidate_rb, rb);
+      _mesa_HashWalk(&ctx->Shared->FrameBuffers, invalidate_rb, rb);
    }
 }
 
@@ -3012,10 +3012,10 @@ _mesa_NamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat,
    GET_CURRENT_CONTEXT(ctx);
    struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, renderbuffer);
    if (!rb || rb == &DummyRenderbuffer) {
-      _mesa_HashLockMutex(ctx->Shared->RenderBuffers);
+      _mesa_HashLockMutex(&ctx->Shared->RenderBuffers);
       rb = allocate_renderbuffer_locked(ctx, renderbuffer, rb != NULL,
                                         "glNamedRenderbufferStorageEXT");
-      _mesa_HashUnlockMutex(ctx->Shared->RenderBuffers);
+      _mesa_HashUnlockMutex(&ctx->Shared->RenderBuffers);
    }
    renderbuffer_storage(ctx, rb, internalformat, width, height, NO_SAMPLES,
                         0, "glNamedRenderbufferStorageEXT");
@@ -3041,10 +3041,10 @@ _mesa_NamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei sample
    GET_CURRENT_CONTEXT(ctx);
    struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, renderbuffer);
    if (!rb || rb == &DummyRenderbuffer) {
-      _mesa_HashLockMutex(ctx->Shared->RenderBuffers);
+      _mesa_HashLockMutex(&ctx->Shared->RenderBuffers);
       rb = allocate_renderbuffer_locked(ctx, renderbuffer, rb != NULL,
                                         "glNamedRenderbufferStorageMultisampleEXT");
-      _mesa_HashUnlockMutex(ctx->Shared->RenderBuffers);
+      _mesa_HashUnlockMutex(&ctx->Shared->RenderBuffers);
    }
    renderbuffer_storage(ctx, rb, internalformat, width, height,
                         samples, samples,
@@ -3159,10 +3159,10 @@ _mesa_GetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname,
 
    struct gl_renderbuffer *rb = _mesa_lookup_renderbuffer(ctx, renderbuffer);
    if (!rb || rb == &DummyRenderbuffer) {
-      _mesa_HashLockMutex(ctx->Shared->RenderBuffers);
+      _mesa_HashLockMutex(&ctx->Shared->RenderBuffers);
       rb = allocate_renderbuffer_locked(ctx, renderbuffer, rb != NULL,
                                         "glGetNamedRenderbufferParameterivEXT");
-      _mesa_HashUnlockMutex(ctx->Shared->RenderBuffers);
+      _mesa_HashUnlockMutex(&ctx->Shared->RenderBuffers);
    }
 
    get_render_buffer_parameteriv(ctx, rb, pname, params,
@@ -3277,7 +3277,7 @@ bind_framebuffer(GLenum target, GLuint framebuffer)
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindFramebufferEXT");
             return;
          }
-         _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, newDrawFb, isGenName);
+         _mesa_HashInsert(&ctx->Shared->FrameBuffers, framebuffer, newDrawFb, isGenName);
       }
       newReadFb = newDrawFb;
    }
@@ -3394,7 +3394,7 @@ _mesa_DeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
             }
 
             /* remove from hash table immediately, to free the ID */
-            _mesa_HashRemove(ctx->Shared->FrameBuffers, framebuffers[i]);
+            _mesa_HashRemove(&ctx->Shared->FrameBuffers, framebuffers[i]);
 
             if (fb != &DummyFramebuffer) {
                /* But the object will not be freed until it's no longer
@@ -3430,15 +3430,15 @@ create_framebuffers(GLsizei n, GLuint *framebuffers, bool dsa)
    if (!framebuffers)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->FrameBuffers);
+   _mesa_HashLockMutex(&ctx->Shared->FrameBuffers);
 
-   _mesa_HashFindFreeKeys(ctx->Shared->FrameBuffers, framebuffers, n);
+   _mesa_HashFindFreeKeys(&ctx->Shared->FrameBuffers, framebuffers, n);
 
    for (i = 0; i < n; i++) {
       if (dsa) {
          fb = _mesa_new_framebuffer(ctx, framebuffers[i]);
          if (!fb) {
-            _mesa_HashUnlockMutex(ctx->Shared->FrameBuffers);
+            _mesa_HashUnlockMutex(&ctx->Shared->FrameBuffers);
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
             return;
          }
@@ -3446,11 +3446,11 @@ create_framebuffers(GLsizei n, GLuint *framebuffers, bool dsa)
       else
          fb = &DummyFramebuffer;
 
-      _mesa_HashInsertLocked(ctx->Shared->FrameBuffers, framebuffers[i],
+      _mesa_HashInsertLocked(&ctx->Shared->FrameBuffers, framebuffers[i],
                              fb, true);
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->FrameBuffers);
+   _mesa_HashUnlockMutex(&ctx->Shared->FrameBuffers);
 }
 
 
@@ -5050,7 +5050,7 @@ lookup_named_framebuffer_ext_dsa(struct gl_context *ctx, GLuint framebuffer, con
       /* Then, make sure it's initialized */
       if (fb == &DummyFramebuffer) {
          fb = _mesa_new_framebuffer(ctx, framebuffer);
-         _mesa_HashInsert(ctx->Shared->FrameBuffers, framebuffer, fb, true);
+         _mesa_HashInsert(&ctx->Shared->FrameBuffers, framebuffer, fb, true);
       }
    }
    else
diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 82792706409f9..18c600cf80e1b 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -127,7 +127,7 @@ glthread_unmarshal_batch(void *job, void *gdata, int thread_index)
     */
    bool lock_mutexes = ctx->GLThread.LockGlobalMutexes;
    if (lock_mutexes) {
-      _mesa_HashLockMutex(shared->BufferObjects);
+      _mesa_HashLockMutex(&shared->BufferObjects);
       ctx->BufferObjectsLocked = true;
       simple_mtx_lock(&shared->TexMutex);
       ctx->TexturesLocked = true;
@@ -144,7 +144,7 @@ glthread_unmarshal_batch(void *job, void *gdata, int thread_index)
       ctx->TexturesLocked = false;
       simple_mtx_unlock(&shared->TexMutex);
       ctx->BufferObjectsLocked = false;
-      _mesa_HashUnlockMutex(shared->BufferObjects);
+      _mesa_HashUnlockMutex(&shared->BufferObjects);
    }
 
    assert(pos == used);
@@ -222,18 +222,13 @@ _mesa_glthread_init(struct gl_context *ctx)
       return;
    }
 
-   glthread->VAOs = _mesa_NewHashTable();
-   if (!glthread->VAOs) {
-      util_queue_destroy(&glthread->queue);
-      return;
-   }
-
+   _mesa_InitHashTable(&glthread->VAOs);
    _mesa_glthread_reset_vao(&glthread->DefaultVAO);
    glthread->CurrentVAO = &glthread->DefaultVAO;
 
    ctx->MarshalExec = _mesa_alloc_dispatch_table(true);
    if (!ctx->MarshalExec) {
-      _mesa_DeleteHashTable(glthread->VAOs, NULL, NULL);
+      _mesa_DeinitHashTable(&glthread->VAOs, NULL, NULL);
       util_queue_destroy(&glthread->queue);
       return;
    }
@@ -289,7 +284,7 @@ _mesa_glthread_destroy(struct gl_context *ctx)
       for (unsigned i = 0; i < MARSHAL_MAX_BATCHES; i++)
          util_queue_fence_destroy(&glthread->batches[i].fence);
 
-      _mesa_DeleteHashTable(glthread->VAOs, free_vao, NULL);
+      _mesa_DeinitHashTable(&glthread->VAOs, free_vao, NULL);
       _mesa_glthread_release_upload_buffer(ctx);
    }
 }
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index bc47403364812..b2ba3133230ba 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -56,6 +56,7 @@
 #include "util/u_queue.h"
 #include "compiler/shader_enums.h"
 #include "main/config.h"
+#include "main/hash.h"
 #include "util/glheader.h"
 
 #ifdef __cplusplus
@@ -64,7 +65,6 @@ extern "C" {
 
 struct gl_context;
 struct gl_buffer_object;
-struct _mesa_HashTable;
 struct _glapi_table;
 
 /* Used by both glthread and gl_context. */
@@ -230,7 +230,7 @@ struct glthread_state
    GLuint _RestartIndex[4]; /**< Restart index for index_size = 1,2,4. */
 
    /** Vertex Array objects tracked by glthread independently of Mesa. */
-   struct _mesa_HashTable *VAOs;
+   struct _mesa_HashTable VAOs;
    struct glthread_vao *CurrentVAO;
    struct glthread_vao *LastLookedUpVAO;
    struct glthread_vao DefaultVAO;
diff --git a/src/mesa/main/glthread_varray.c b/src/mesa/main/glthread_varray.c
index 98b3027869eb2..8a5af53726694 100644
--- a/src/mesa/main/glthread_varray.c
+++ b/src/mesa/main/glthread_varray.c
@@ -102,7 +102,7 @@ lookup_vao(struct gl_context *ctx, GLuint id)
        glthread->LastLookedUpVAO->Name == id) {
       vao = glthread->LastLookedUpVAO;
    } else {
-      vao = _mesa_HashLookupLocked(glthread->VAOs, id);
+      vao = _mesa_HashLookupLocked(&glthread->VAOs, id);
       if (!vao)
          return NULL;
 
@@ -156,7 +156,7 @@ _mesa_glthread_DeleteVertexArrays(struct gl_context *ctx,
          glthread->LastLookedUpVAO = NULL;
 
       /* The ID is immediately freed for re-use */
-      _mesa_HashRemoveLocked(glthread->VAOs, vao->Name);
+      _mesa_HashRemoveLocked(&glthread->VAOs, vao->Name);
       free(vao);
    }
 }
@@ -181,7 +181,7 @@ _mesa_glthread_GenVertexArrays(struct gl_context *ctx,
 
       vao->Name = id;
       _mesa_glthread_reset_vao(vao);
-      _mesa_HashInsertLocked(glthread->VAOs, id, vao, true);
+      _mesa_HashInsertLocked(&glthread->VAOs, id, vao, true);
    }
 }
 
@@ -770,6 +770,6 @@ _mesa_glthread_unbind_uploaded_vbos(struct gl_context *ctx)
    assert(ctx->API != API_OPENGL_CORE);
 
    /* Iterate over all VAOs. */
-   _mesa_HashWalk(ctx->Array.Objects, unbind_uploaded_vbos, ctx);
+   _mesa_HashWalk(&ctx->Array.Objects, unbind_uploaded_vbos, ctx);
    unbind_uploaded_vbos(ctx->Array.DefaultVAO, ctx);
 }
diff --git a/src/mesa/main/hash.c b/src/mesa/main/hash.c
index 71f1f7dd2fce0..53ddfa13e8000 100644
--- a/src/mesa/main/hash.c
+++ b/src/mesa/main/hash.c
@@ -42,27 +42,17 @@
 #include "util/u_memory.h"
 
 /**
- * Create a new hash table.
- * 
- * \return pointer to a new, empty hash table.
+ * Initialize a hash table.
  */
-struct _mesa_HashTable *
-_mesa_NewHashTable(void)
+void
+_mesa_InitHashTable(struct _mesa_HashTable *table)
 {
-   struct _mesa_HashTable *table = CALLOC_STRUCT(_mesa_HashTable);
-
-   if (table) {
-      util_sparse_array_init(&table->array, sizeof(void*), 1024);
-      simple_mtx_init(&table->Mutex, mtx_plain);
-
-      util_idalloc_init(&table->id_alloc, 8);
-      /* Mark ID = 0 as used, so that we don't return it. */
-      util_idalloc_reserve(&table->id_alloc, 0);
-   } else {
-      _mesa_error_no_memory(__func__);
-   }
+   util_sparse_array_init(&table->array, sizeof(void*), 1024);
+   simple_mtx_init(&table->Mutex, mtx_plain);
 
-   return table;
+   util_idalloc_init(&table->id_alloc, 8);
+   /* Mark ID = 0 as used, so that we don't return it. */
+   util_idalloc_reserve(&table->id_alloc, 0);
 }
 
 /**
@@ -80,7 +70,7 @@ _mesa_NewHashTable(void)
  *                  (this is typically a struct gl_context pointer)
  */
 void
-_mesa_DeleteHashTable(struct _mesa_HashTable *table,
+_mesa_DeinitHashTable(struct _mesa_HashTable *table,
                       void (*free_callback)(void *data, void *userData),
                       void *userData)
 {
@@ -94,7 +84,6 @@ _mesa_DeleteHashTable(struct _mesa_HashTable *table,
    util_idalloc_fini(&table->id_alloc);
    util_sparse_array_finish(&table->array);
    simple_mtx_destroy(&table->Mutex);
-   FREE(table);
 }
 
 /**
diff --git a/src/mesa/main/hash.h b/src/mesa/main/hash.h
index f866c7e14eec5..7bfee0bf2c7f3 100644
--- a/src/mesa/main/hash.h
+++ b/src/mesa/main/hash.h
@@ -50,11 +50,11 @@ struct _mesa_HashTable {
    simple_mtx_t Mutex;
 };
 
-struct _mesa_HashTable *
-_mesa_NewHashTable(void);
+void
+_mesa_InitHashTable(struct _mesa_HashTable *table);
 
 void
-_mesa_DeleteHashTable(struct _mesa_HashTable *table,
+_mesa_DeinitHashTable(struct _mesa_HashTable *table,
                       void (*free_callback)(void *data, void *userData),
                       void *userData);
 
@@ -160,7 +160,7 @@ _mesa_HashLookup(struct _mesa_HashTable *table, GLuint key)
    return res;
 }
 
-static inline struct gl_buffer_object *
+static inline void *
 _mesa_HashLookupMaybeLocked(struct _mesa_HashTable *table, GLuint key,
                             bool locked)
 {
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 2a1d3547dac47..15ca47ff6b46a 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -74,7 +74,6 @@ extern "C" {
  * \name Some forward type declarations
  */
 /*@{*/
-struct _mesa_HashTable;
 struct gl_attrib_node;
 struct gl_list_extensions;
 struct gl_meta_state;
@@ -1711,7 +1710,7 @@ struct gl_array_attrib
    struct gl_vertex_array_object DefaultVAOState;
 
    /** Array objects (GL_ARB_vertex_array_object) */
-   struct _mesa_HashTable *Objects;
+   struct _mesa_HashTable Objects;
 
    GLint ActiveTexture;		/**< Client Active Texture */
    GLuint LockFirst;            /**< GL_EXT_compiled_vertex_array */
@@ -1944,7 +1943,7 @@ struct gl_transform_feedback_state
    struct gl_buffer_object *CurrentBuffer;
 
    /** The table of all transform feedback objects */
-   struct _mesa_HashTable *Objects;
+   struct _mesa_HashTable Objects;
 
    /** The current xform-fb object (GL_TRANSFORM_FEEDBACK_BINDING) */
    struct gl_transform_feedback_object *CurrentObject;
@@ -2076,7 +2075,7 @@ struct gl_perf_monitor_state
    GLuint NumGroups;
 
    /** The table of all performance monitors. */
-   struct _mesa_HashTable *Monitors;
+   struct _mesa_HashTable Monitors;
 };
 
 
@@ -2085,7 +2084,7 @@ struct gl_perf_monitor_state
  */
 struct gl_perf_query_state
 {
-   struct _mesa_HashTable *Objects; /**< The table of all performance query objects */
+   struct _mesa_HashTable Objects; /**< The table of all performance query objects */
 };
 
 
@@ -2331,7 +2330,7 @@ struct gl_pipeline_shader_state
    struct gl_pipeline_object *Default;
 
    /** Pipeline objects */
-   struct _mesa_HashTable *Objects;
+   struct _mesa_HashTable Objects;
 };
 
 /**
@@ -2362,7 +2361,7 @@ struct gl_query_object
  */
 struct gl_query_state
 {
-   struct _mesa_HashTable *QueryObjects;
+   struct _mesa_HashTable QueryObjects;
    struct gl_query_object *CurrentOcclusionObject; /* GL_ARB_occlusion_query */
    struct gl_query_object *CurrentTimerObject;     /* GL_EXT_timer_query */
 
@@ -2414,8 +2413,8 @@ struct gl_shared_state
    GLint RefCount;			   /**< Reference count */
    bool DisplayListsAffectGLThread;
 
-   struct _mesa_HashTable *DisplayList;	   /**< Display lists hash table */
-   struct _mesa_HashTable *TexObjects;	   /**< Texture objects hash table */
+   struct _mesa_HashTable DisplayList;	   /**< Display lists hash table */
+   struct _mesa_HashTable TexObjects;	   /**< Texture objects hash table */
 
    /** Default texture objects (shared by all texture units) */
    struct gl_texture_object *DefaultTex[NUM_TEXTURE_TARGETS];
@@ -2438,16 +2437,16 @@ struct gl_shared_state
     * \name Vertex/geometry/fragment programs
     */
    /*@{*/
-   struct _mesa_HashTable *Programs; /**< All vertex/fragment programs */
+   struct _mesa_HashTable Programs; /**< All vertex/fragment programs */
    struct gl_program *DefaultVertexProgram;
    struct gl_program *DefaultFragmentProgram;
    /*@}*/
 
    /* GL_ATI_fragment_shader */
-   struct _mesa_HashTable *ATIShaders;
+   struct _mesa_HashTable ATIShaders;
    struct ati_fragment_shader *DefaultFragmentShader;
 
-   struct _mesa_HashTable *BufferObjects;
+   struct _mesa_HashTable BufferObjects;
 
    /* Buffer objects released by a different context than the one that
     * created them. Since the creating context holds one global buffer
@@ -2463,17 +2462,17 @@ struct gl_shared_state
    struct set *ZombieBufferObjects;
 
    /** Table of both gl_shader and gl_shader_program objects */
-   struct _mesa_HashTable *ShaderObjects;
+   struct _mesa_HashTable ShaderObjects;
 
    /* GL_EXT_framebuffer_object */
-   struct _mesa_HashTable *RenderBuffers;
-   struct _mesa_HashTable *FrameBuffers;
+   struct _mesa_HashTable RenderBuffers;
+   struct _mesa_HashTable FrameBuffers;
 
    /* GL_ARB_sync */
    struct set *SyncObjects;
 
    /** GL_ARB_sampler_objects */
-   struct _mesa_HashTable *SamplerObjects;
+   struct _mesa_HashTable SamplerObjects;
 
    /* GL_ARB_bindless_texture */
    struct hash_table_u64 *TextureHandles;
@@ -2488,10 +2487,10 @@ struct gl_shared_state
    simple_mtx_t ShaderIncludeMutex;
 
    /** EXT_external_objects */
-   struct _mesa_HashTable *MemoryObjects;
+   struct _mesa_HashTable MemoryObjects;
 
    /** EXT_semaphore */
-   struct _mesa_HashTable *SemaphoreObjects;
+   struct _mesa_HashTable SemaphoreObjects;
 
    /**
     * Whether at least one image has been imported or exported, excluding
diff --git a/src/mesa/main/performance_monitor.c b/src/mesa/main/performance_monitor.c
index 4999f8e4fa0f0..116385e808de2 100644
--- a/src/mesa/main/performance_monitor.c
+++ b/src/mesa/main/performance_monitor.c
@@ -57,7 +57,7 @@
 void
 _mesa_init_performance_monitors(struct gl_context *ctx)
 {
-   ctx->PerfMonitor.Monitors = _mesa_NewHashTable();
+   _mesa_InitHashTable(&ctx->PerfMonitor.Monitors);
    ctx->PerfMonitor.NumGroups = 0;
    ctx->PerfMonitor.Groups = NULL;
 }
@@ -496,7 +496,7 @@ free_performance_monitor(void *data, void *user)
 void
 _mesa_free_performance_monitors(struct gl_context *ctx)
 {
-   _mesa_DeleteHashTable(ctx->PerfMonitor.Monitors, free_performance_monitor,
+   _mesa_DeinitHashTable(&ctx->PerfMonitor.Monitors, free_performance_monitor,
                          ctx);
 }
 
@@ -504,7 +504,7 @@ static inline struct gl_perf_monitor_object *
 lookup_monitor(struct gl_context *ctx, GLuint id)
 {
    return (struct gl_perf_monitor_object *)
-      _mesa_HashLookup(ctx->PerfMonitor.Monitors, id);
+      _mesa_HashLookup(&ctx->PerfMonitor.Monitors, id);
 }
 
 static inline const struct gl_perf_monitor_group *
@@ -734,7 +734,7 @@ _mesa_GenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
    if (monitors == NULL)
       return;
 
-   if (_mesa_HashFindFreeKeys(ctx->PerfMonitor.Monitors, monitors, n)) {
+   if (_mesa_HashFindFreeKeys(&ctx->PerfMonitor.Monitors, monitors, n)) {
       GLsizei i;
       for (i = 0; i < n; i++) {
          struct gl_perf_monitor_object *m =
@@ -743,7 +743,7 @@ _mesa_GenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenPerfMonitorsAMD");
             return;
          }
-         _mesa_HashInsert(ctx->PerfMonitor.Monitors, monitors[i], m, true);
+         _mesa_HashInsert(&ctx->PerfMonitor.Monitors, monitors[i], m, true);
       }
    } else {
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenPerfMonitorsAMD");
@@ -778,7 +778,7 @@ _mesa_DeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
             m->Ended = false;
          }
 
-         _mesa_HashRemove(ctx->PerfMonitor.Monitors, monitors[i]);
+         _mesa_HashRemove(&ctx->PerfMonitor.Monitors, monitors[i]);
          ralloc_free(m->ActiveGroups);
          ralloc_free(m->ActiveCounters);
          delete_perf_monitor(ctx, m);
diff --git a/src/mesa/main/performance_query.c b/src/mesa/main/performance_query.c
index 364b0c9025a71..359d17eeb2042 100644
--- a/src/mesa/main/performance_query.c
+++ b/src/mesa/main/performance_query.c
@@ -44,7 +44,7 @@
 void
 _mesa_init_performance_queries(struct gl_context *ctx)
 {
-   ctx->PerfQuery.Objects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&ctx->PerfQuery.Objects);
 }
 
 static void
@@ -65,13 +65,13 @@ free_performance_query(void *data, void *user)
 void
 _mesa_free_performance_queries(struct gl_context *ctx)
 {
-   _mesa_DeleteHashTable(ctx->PerfQuery.Objects, free_performance_query, ctx);
+   _mesa_DeinitHashTable(&ctx->PerfQuery.Objects, free_performance_query, ctx);
 }
 
 static inline struct gl_perf_query_object *
 lookup_object(struct gl_context *ctx, GLuint id)
 {
-   return _mesa_HashLookup(ctx->PerfQuery.Objects, id);
+   return _mesa_HashLookup(&ctx->PerfQuery.Objects, id);
 }
 
 static GLuint
@@ -488,7 +488,7 @@ _mesa_CreatePerfQueryINTEL(GLuint queryId, GLuint *queryHandle)
       return;
    }
 
-   id = _mesa_HashFindFreeKeyBlock(ctx->PerfQuery.Objects, 1);
+   id = _mesa_HashFindFreeKeyBlock(&ctx->PerfQuery.Objects, 1);
    if (!id) {
       /* The GL_INTEL_performance_query spec says:
        *
@@ -512,7 +512,7 @@ _mesa_CreatePerfQueryINTEL(GLuint queryId, GLuint *queryHandle)
    obj->Active = false;
    obj->Ready = false;
 
-   _mesa_HashInsert(ctx->PerfQuery.Objects, id, obj, true);
+   _mesa_HashInsert(&ctx->PerfQuery.Objects, id, obj, true);
    *queryHandle = id;
 }
 
@@ -547,7 +547,7 @@ _mesa_DeletePerfQueryINTEL(GLuint queryHandle)
       obj->Ready = true;
    }
 
-   _mesa_HashRemove(ctx->PerfQuery.Objects, queryHandle);
+   _mesa_HashRemove(&ctx->PerfQuery.Objects, queryHandle);
    ctx->pipe->delete_intel_perf_query(ctx->pipe, (struct pipe_query *)obj);
 }
 
diff --git a/src/mesa/main/pipelineobj.c b/src/mesa/main/pipelineobj.c
index 1f7e14ada9a60..04441efdc748e 100644
--- a/src/mesa/main/pipelineobj.c
+++ b/src/mesa/main/pipelineobj.c
@@ -94,7 +94,7 @@ _mesa_new_pipeline_object(struct gl_context *ctx, GLuint name)
 void
 _mesa_init_pipeline(struct gl_context *ctx)
 {
-   ctx->Pipeline.Objects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&ctx->Pipeline.Objects);
 
    ctx->Pipeline.Current = NULL;
 
@@ -123,7 +123,7 @@ void
 _mesa_free_pipeline_data(struct gl_context *ctx)
 {
    _mesa_reference_pipeline_object(ctx, &ctx->_Shader, NULL);
-   _mesa_DeleteHashTable(ctx->Pipeline.Objects, delete_pipelineobj_cb, ctx);
+   _mesa_DeinitHashTable(&ctx->Pipeline.Objects, delete_pipelineobj_cb, ctx);
    _mesa_delete_pipeline_object(ctx, ctx->Pipeline.Default);
 }
 
@@ -142,7 +142,7 @@ _mesa_lookup_pipeline_object(struct gl_context *ctx, GLuint id)
       return NULL;
    else
       return (struct gl_pipeline_object *)
-         _mesa_HashLookupLocked(ctx->Pipeline.Objects, id);
+         _mesa_HashLookupLocked(&ctx->Pipeline.Objects, id);
 }
 
 /**
@@ -152,7 +152,7 @@ static void
 save_pipeline_object(struct gl_context *ctx, struct gl_pipeline_object *obj)
 {
    if (obj->Name > 0) {
-      _mesa_HashInsertLocked(ctx->Pipeline.Objects, obj->Name, obj, true);
+      _mesa_HashInsertLocked(&ctx->Pipeline.Objects, obj->Name, obj, true);
    }
 }
 
@@ -164,7 +164,7 @@ static void
 remove_pipeline_object(struct gl_context *ctx, struct gl_pipeline_object *obj)
 {
    if (obj->Name > 0) {
-      _mesa_HashRemoveLocked(ctx->Pipeline.Objects, obj->Name);
+      _mesa_HashRemoveLocked(&ctx->Pipeline.Objects, obj->Name);
    }
 }
 
@@ -606,7 +606,7 @@ create_program_pipelines(struct gl_context *ctx, GLsizei n, GLuint *pipelines,
    if (!pipelines)
       return;
 
-   _mesa_HashFindFreeKeys(ctx->Pipeline.Objects, pipelines, n);
+   _mesa_HashFindFreeKeys(&ctx->Pipeline.Objects, pipelines, n);
 
    for (i = 0; i < n; i++) {
       struct gl_pipeline_object *obj;
diff --git a/src/mesa/main/queryobj.c b/src/mesa/main/queryobj.c
index 834d87de94d1b..f1407b0a068bb 100644
--- a/src/mesa/main/queryobj.c
+++ b/src/mesa/main/queryobj.c
@@ -585,7 +585,7 @@ create_queries(struct gl_context *ctx, GLenum target, GLsizei n, GLuint *ids,
       return;
    }
 
-   if (_mesa_HashFindFreeKeys(ctx->Query.QueryObjects, ids, n)) {
+   if (_mesa_HashFindFreeKeys(&ctx->Query.QueryObjects, ids, n)) {
       GLsizei i;
       for (i = 0; i < n; i++) {
          struct gl_query_object *q
@@ -598,7 +598,7 @@ create_queries(struct gl_context *ctx, GLenum target, GLsizei n, GLuint *ids,
             q->Target = target;
             q->EverBound = GL_TRUE;
          }
-         _mesa_HashInsertLocked(ctx->Query.QueryObjects, ids[i], q, true);
+         _mesa_HashInsertLocked(&ctx->Query.QueryObjects, ids[i], q, true);
       }
    }
 }
@@ -665,7 +665,7 @@ _mesa_DeleteQueries(GLsizei n, const GLuint *ids)
                q->Active = GL_FALSE;
                end_query(ctx, q);
             }
-            _mesa_HashRemoveLocked(ctx->Query.QueryObjects, ids[i]);
+            _mesa_HashRemoveLocked(&ctx->Query.QueryObjects, ids[i]);
             delete_query(ctx, q);
          }
       }
@@ -768,7 +768,7 @@ _mesa_BeginQueryIndexed(GLenum target, GLuint index, GLuint id)
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBeginQuery{Indexed}");
             return;
          }
-         _mesa_HashInsertLocked(ctx->Query.QueryObjects, id, q, false);
+         _mesa_HashInsertLocked(&ctx->Query.QueryObjects, id, q, false);
       }
    }
    else {
@@ -910,7 +910,7 @@ _mesa_QueryCounter(GLuint id, GLenum target)
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "glQueryCounter");
          return;
       }
-      _mesa_HashInsertLocked(ctx->Query.QueryObjects, id, q, false);
+      _mesa_HashInsertLocked(&ctx->Query.QueryObjects, id, q, false);
    }
    else {
       if (q->Target && q->Target != GL_TIMESTAMP) {
@@ -1342,7 +1342,7 @@ _mesa_init_queryobj(struct gl_context *ctx)
 {
    struct pipe_screen *screen = ctx->pipe->screen;
 
-   ctx->Query.QueryObjects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&ctx->Query.QueryObjects);
    ctx->Query.CurrentOcclusionObject = NULL;
 
    if (screen->get_param(screen, PIPE_CAP_OCCLUSION_QUERY))
@@ -1402,5 +1402,5 @@ delete_queryobj_cb(void *data, void *userData)
 void
 _mesa_free_queryobj_data(struct gl_context *ctx)
 {
-   _mesa_DeleteHashTable(ctx->Query.QueryObjects, delete_queryobj_cb, ctx);
+   _mesa_DeinitHashTable(&ctx->Query.QueryObjects, delete_queryobj_cb, ctx);
 }
diff --git a/src/mesa/main/queryobj.h b/src/mesa/main/queryobj.h
index 63432cc477b80..f343d00879afa 100644
--- a/src/mesa/main/queryobj.h
+++ b/src/mesa/main/queryobj.h
@@ -35,7 +35,7 @@ static inline struct gl_query_object *
 _mesa_lookup_query_object(struct gl_context *ctx, GLuint id)
 {
    return (struct gl_query_object *)
-      _mesa_HashLookupLocked(ctx->Query.QueryObjects, id);
+      _mesa_HashLookupLocked(&ctx->Query.QueryObjects, id);
 }
 
 extern void
diff --git a/src/mesa/main/samplerobj.c b/src/mesa/main/samplerobj.c
index 1018854689dea..d0436409cb94e 100644
--- a/src/mesa/main/samplerobj.c
+++ b/src/mesa/main/samplerobj.c
@@ -60,14 +60,14 @@ _mesa_lookup_samplerobj(struct gl_context *ctx, GLuint name)
       return NULL;
    else
       return (struct gl_sampler_object *)
-         _mesa_HashLookup(ctx->Shared->SamplerObjects, name);
+         _mesa_HashLookup(&ctx->Shared->SamplerObjects, name);
 }
 
 static inline struct gl_sampler_object *
 lookup_samplerobj_locked(struct gl_context *ctx, GLuint name)
 {
    return (struct gl_sampler_object *)
-         _mesa_HashLookupLocked(ctx->Shared->SamplerObjects, name);
+         _mesa_HashLookupLocked(&ctx->Shared->SamplerObjects, name);
 }
 
 static void
@@ -176,9 +176,9 @@ create_samplers(struct gl_context *ctx, GLsizei count, GLuint *samplers,
    if (!samplers)
       return;
 
-   _mesa_HashLockMutex(ctx->Shared->SamplerObjects);
+   _mesa_HashLockMutex(&ctx->Shared->SamplerObjects);
 
-   _mesa_HashFindFreeKeys(ctx->Shared->SamplerObjects, samplers, count);
+   _mesa_HashFindFreeKeys(&ctx->Shared->SamplerObjects, samplers, count);
 
    /* Insert the ID and pointer to new sampler object into hash table */
    for (i = 0; i < count; i++) {
@@ -186,16 +186,16 @@ create_samplers(struct gl_context *ctx, GLsizei count, GLuint *samplers,
 
       sampObj = _mesa_new_sampler_object(ctx, samplers[i]);
       if (!sampObj) {
-         _mesa_HashUnlockMutex(ctx->Shared->SamplerObjects);
+         _mesa_HashUnlockMutex(&ctx->Shared->SamplerObjects);
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
          return;
       }
 
-      _mesa_HashInsertLocked(ctx->Shared->SamplerObjects, samplers[i],
+      _mesa_HashInsertLocked(&ctx->Shared->SamplerObjects, samplers[i],
                              sampObj, true);
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->SamplerObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->SamplerObjects);
 }
 
 static void
@@ -248,7 +248,7 @@ delete_samplers(struct gl_context *ctx, GLsizei count, const GLuint *samplers)
 {
    FLUSH_VERTICES(ctx, 0, 0);
 
-   _mesa_HashLockMutex(ctx->Shared->SamplerObjects);
+   _mesa_HashLockMutex(&ctx->Shared->SamplerObjects);
 
    for (GLsizei i = 0; i < count; i++) {
       if (samplers[i]) {
@@ -266,14 +266,14 @@ delete_samplers(struct gl_context *ctx, GLsizei count, const GLuint *samplers)
             }
 
             /* The ID is immediately freed for re-use */
-            _mesa_HashRemoveLocked(ctx->Shared->SamplerObjects, samplers[i]);
+            _mesa_HashRemoveLocked(&ctx->Shared->SamplerObjects, samplers[i]);
             /* But the object exists until its reference count goes to zero */
             _mesa_reference_sampler_object(ctx, &sampObj, NULL);
          }
       }
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->SamplerObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->SamplerObjects);
 }
 
 
@@ -393,7 +393,7 @@ bind_samplers(struct gl_context *ctx, GLuint first, GLsizei count,
        *       their parameters are valid and no other error occurs."
        */
 
-      _mesa_HashLockMutex(ctx->Shared->SamplerObjects);
+      _mesa_HashLockMutex(&ctx->Shared->SamplerObjects);
 
       for (i = 0; i < count; i++) {
          const GLuint unit = first + i;
@@ -434,7 +434,7 @@ bind_samplers(struct gl_context *ctx, GLuint first, GLsizei count,
          }
       }
 
-      _mesa_HashUnlockMutex(ctx->Shared->SamplerObjects);
+      _mesa_HashUnlockMutex(&ctx->Shared->SamplerObjects);
    } else {
       /* Unbind all samplers in the range <first> through <first>+<count>-1 */
       for (i = 0; i < count; i++) {
diff --git a/src/mesa/main/shaderapi.c b/src/mesa/main/shaderapi.c
index faf41935cb76d..d88063a60a050 100644
--- a/src/mesa/main/shaderapi.c
+++ b/src/mesa/main/shaderapi.c
@@ -412,12 +412,12 @@ create_shader(struct gl_context *ctx, GLenum type)
    struct gl_shader *sh;
    GLuint name;
 
-   _mesa_HashLockMutex(ctx->Shared->ShaderObjects);
-   name = _mesa_HashFindFreeKeyBlock(ctx->Shared->ShaderObjects, 1);
+   _mesa_HashLockMutex(&ctx->Shared->ShaderObjects);
+   name = _mesa_HashFindFreeKeyBlock(&ctx->Shared->ShaderObjects, 1);
    sh = _mesa_new_shader(name, _mesa_shader_enum_to_shader_stage(type));
    sh->Type = type;
-   _mesa_HashInsertLocked(ctx->Shared->ShaderObjects, name, sh, true);
-   _mesa_HashUnlockMutex(ctx->Shared->ShaderObjects);
+   _mesa_HashInsertLocked(&ctx->Shared->ShaderObjects, name, sh, true);
+   _mesa_HashUnlockMutex(&ctx->Shared->ShaderObjects);
 
    return name;
 }
@@ -442,17 +442,17 @@ create_shader_program(struct gl_context *ctx)
    GLuint name;
    struct gl_shader_program *shProg;
 
-   _mesa_HashLockMutex(ctx->Shared->ShaderObjects);
+   _mesa_HashLockMutex(&ctx->Shared->ShaderObjects);
 
-   name = _mesa_HashFindFreeKeyBlock(ctx->Shared->ShaderObjects, 1);
+   name = _mesa_HashFindFreeKeyBlock(&ctx->Shared->ShaderObjects, 1);
 
    shProg = _mesa_new_shader_program(name);
 
-   _mesa_HashInsertLocked(ctx->Shared->ShaderObjects, name, shProg, true);
+   _mesa_HashInsertLocked(&ctx->Shared->ShaderObjects, name, shProg, true);
 
    assert(shProg->RefCount == 1);
 
-   _mesa_HashUnlockMutex(ctx->Shared->ShaderObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->ShaderObjects);
 
    return name;
 }
@@ -1356,14 +1356,12 @@ link_program(struct gl_context *ctx, struct gl_shader_program *shProg,
          _mesa_use_program(ctx, stage, shProg, prog, ctx->_Shader);
       }
 
-      if (ctx->Pipeline.Objects) {
-         struct update_programs_in_pipeline_params params = {
-            .ctx = ctx,
-            .shProg = shProg
-         };
-         _mesa_HashWalk(ctx->Pipeline.Objects, update_programs_in_pipeline,
-                        &params);
-      }
+      struct update_programs_in_pipeline_params params = {
+         .ctx = ctx,
+         .shProg = shProg
+      };
+      _mesa_HashWalk(&ctx->Pipeline.Objects, update_programs_in_pipeline,
+                     &params);
    }
 
 #ifndef CUSTOM_SHADER_REPLACEMENT
diff --git a/src/mesa/main/shaderimage.c b/src/mesa/main/shaderimage.c
index df0a999dd294c..64dd8e5376c7f 100644
--- a/src/mesa/main/shaderimage.c
+++ b/src/mesa/main/shaderimage.c
@@ -711,7 +711,7 @@ bind_image_textures(struct gl_context *ctx, GLuint first, GLuint count,
     *       their parameters are valid and no other error occurs."
     */
 
-   _mesa_HashLockMutex(ctx->Shared->TexObjects);
+   _mesa_HashLockMutex(&ctx->Shared->TexObjects);
 
    for (i = 0; i < count; i++) {
       struct gl_image_unit *u = &ctx->ImageUnits[first + i];
@@ -788,7 +788,7 @@ bind_image_textures(struct gl_context *ctx, GLuint first, GLuint count,
       }
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->TexObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->TexObjects);
 }
 
 void GLAPIENTRY
diff --git a/src/mesa/main/shaderobj.c b/src/mesa/main/shaderobj.c
index 12bc5d6c034ac..dce54d7be8a7e 100644
--- a/src/mesa/main/shaderobj.c
+++ b/src/mesa/main/shaderobj.c
@@ -73,9 +73,9 @@ _reference_shader(struct gl_context *ctx, struct gl_shader **ptr,
       if (p_atomic_dec_zero(&old->RefCount)) {
          if (old->Name != 0) {
             if (skip_locking)
-               _mesa_HashRemoveLocked(ctx->Shared->ShaderObjects, old->Name);
+               _mesa_HashRemoveLocked(&ctx->Shared->ShaderObjects, old->Name);
             else
-               _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
+               _mesa_HashRemove(&ctx->Shared->ShaderObjects, old->Name);
          }
          _mesa_delete_shader(ctx, old);
       }
@@ -159,7 +159,7 @@ _mesa_lookup_shader(struct gl_context *ctx, GLuint name)
 {
    if (name) {
       struct gl_shader *sh = (struct gl_shader *)
-         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
+         _mesa_HashLookup(&ctx->Shared->ShaderObjects, name);
       /* Note that both gl_shader and gl_shader_program objects are kept
        * in the same hash table.  Check the object's type to be sure it's
        * what we're expecting.
@@ -185,7 +185,7 @@ _mesa_lookup_shader_err(struct gl_context *ctx, GLuint name, const char *caller)
    }
    else {
       struct gl_shader *sh = (struct gl_shader *)
-         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
+         _mesa_HashLookup(&ctx->Shared->ShaderObjects, name);
       if (!sh) {
          _mesa_error(ctx, GL_INVALID_VALUE, "%s", caller);
          return NULL;
@@ -258,11 +258,11 @@ _mesa_reference_shader_program_(struct gl_context *ctx,
       assert(old->RefCount > 0);
 
       if (p_atomic_dec_zero(&old->RefCount)) {
-         _mesa_HashLockMutex(ctx->Shared->ShaderObjects);
+         _mesa_HashLockMutex(&ctx->Shared->ShaderObjects);
          if (old->Name != 0)
-	         _mesa_HashRemoveLocked(ctx->Shared->ShaderObjects, old->Name);
+	         _mesa_HashRemoveLocked(&ctx->Shared->ShaderObjects, old->Name);
          _mesa_delete_shader_program(ctx, old);
-         _mesa_HashUnlockMutex(ctx->Shared->ShaderObjects);
+         _mesa_HashUnlockMutex(&ctx->Shared->ShaderObjects);
       }
 
       *ptr = NULL;
@@ -432,7 +432,7 @@ _mesa_lookup_shader_program(struct gl_context *ctx, GLuint name)
    struct gl_shader_program *shProg;
    if (name) {
       shProg = (struct gl_shader_program *)
-         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
+         _mesa_HashLookup(&ctx->Shared->ShaderObjects, name);
       /* Note that both gl_shader and gl_shader_program objects are kept
        * in the same hash table.  Check the object's type to be sure it's
        * what we're expecting.
@@ -459,7 +459,7 @@ _mesa_lookup_shader_program_err_glthread(struct gl_context *ctx, GLuint name,
    }
    else {
       struct gl_shader_program *shProg = (struct gl_shader_program *)
-         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
+         _mesa_HashLookup(&ctx->Shared->ShaderObjects, name);
       if (!shProg) {
          _mesa_error_glthread_safe(ctx, GL_INVALID_VALUE, glthread,
                                    "%s", caller);
diff --git a/src/mesa/main/shared.c b/src/mesa/main/shared.c
index 721746b2a7597..41e05ed56b949 100644
--- a/src/mesa/main/shared.c
+++ b/src/mesa/main/shared.c
@@ -71,26 +71,26 @@ _mesa_alloc_shared_state(struct gl_context *ctx)
 
    simple_mtx_init(&shared->Mutex, mtx_plain);
 
-   shared->DisplayList = _mesa_NewHashTable();
-   shared->TexObjects = _mesa_NewHashTable();
-   shared->Programs = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->DisplayList);
+   _mesa_InitHashTable(&shared->TexObjects);
+   _mesa_InitHashTable(&shared->Programs);
 
    shared->DefaultVertexProgram =
       ctx->Driver.NewProgram(ctx, MESA_SHADER_VERTEX, 0, true);
    shared->DefaultFragmentProgram =
       ctx->Driver.NewProgram(ctx, MESA_SHADER_FRAGMENT, 0, true);
 
-   shared->ATIShaders = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->ATIShaders);
    shared->DefaultFragmentShader = _mesa_new_ati_fragment_shader(ctx, 0);
 
-   shared->ShaderObjects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->ShaderObjects);
 
-   shared->BufferObjects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->BufferObjects);
    shared->ZombieBufferObjects = _mesa_set_create(NULL, _mesa_hash_pointer,
                                                   _mesa_key_pointer_equal);
 
    /* GL_ARB_sampler_objects */
-   shared->SamplerObjects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->SamplerObjects);
 
    /* GL_ARB_bindless_texture */
    _mesa_init_shared_handles(shared);
@@ -132,14 +132,14 @@ _mesa_alloc_shared_state(struct gl_context *ctx)
    simple_mtx_init(&shared->TexMutex, mtx_plain);
    shared->TextureStateStamp = 0;
 
-   shared->FrameBuffers = _mesa_NewHashTable();
-   shared->RenderBuffers = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->FrameBuffers);
+   _mesa_InitHashTable(&shared->RenderBuffers);
 
    shared->SyncObjects = _mesa_set_create(NULL, _mesa_hash_pointer,
                                           _mesa_key_pointer_equal);
 
-   shared->MemoryObjects = _mesa_NewHashTable();
-   shared->SemaphoreObjects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&shared->MemoryObjects);
+   _mesa_InitHashTable(&shared->SemaphoreObjects);
 
    shared->GLThread.NoLockDuration = ONE_SECOND_IN_NS;
 
@@ -346,19 +346,13 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
    /*
     * Free display lists
     */
-   if (shared->DisplayList) {
-      _mesa_DeleteHashTable(shared->DisplayList, delete_displaylist_cb, ctx);
-      free(shared->small_dlist_store.ptr);
-      util_idalloc_fini(&shared->small_dlist_store.free_idx);
-   }
-
-   if (shared->ShaderObjects) {
-      _mesa_HashWalk(shared->ShaderObjects, free_shader_program_data_cb, ctx);
-      _mesa_DeleteHashTable(shared->ShaderObjects, delete_shader_cb, ctx);
-   }
+   _mesa_DeinitHashTable(&shared->DisplayList, delete_displaylist_cb, ctx);
+   free(shared->small_dlist_store.ptr);
+   util_idalloc_fini(&shared->small_dlist_store.free_idx);
 
-   if (shared->Programs)
-      _mesa_DeleteHashTable(shared->Programs, delete_program_cb, ctx);
+   _mesa_HashWalk(&shared->ShaderObjects, free_shader_program_data_cb, ctx);
+   _mesa_DeinitHashTable(&shared->ShaderObjects, delete_shader_cb, ctx);
+   _mesa_DeinitHashTable(&shared->Programs, delete_program_cb, ctx);
 
    if (shared->DefaultVertexProgram)
       _mesa_reference_program(ctx, &shared->DefaultVertexProgram, NULL);
@@ -369,11 +363,8 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
    if (shared->DefaultFragmentShader)
       _mesa_delete_ati_fragment_shader(ctx, shared->DefaultFragmentShader);
 
-   if (shared->ATIShaders)
-      _mesa_DeleteHashTable(shared->ATIShaders, delete_fragshader_cb, ctx);
-
-   if (shared->BufferObjects)
-      _mesa_DeleteHashTable(shared->BufferObjects, delete_bufferobj_cb, ctx);
+   _mesa_DeinitHashTable(&shared->ATIShaders, delete_fragshader_cb, ctx);
+   _mesa_DeinitHashTable(&shared->BufferObjects, delete_bufferobj_cb, ctx);
 
    if (shared->ZombieBufferObjects) {
       set_foreach(shared->ZombieBufferObjects, entry) {
@@ -382,11 +373,8 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
       _mesa_set_destroy(shared->ZombieBufferObjects, NULL);
    }
 
-   if (shared->FrameBuffers)
-      _mesa_DeleteHashTable(shared->FrameBuffers, delete_framebuffer_cb, ctx);
-
-   if (shared->RenderBuffers)
-      _mesa_DeleteHashTable(shared->RenderBuffers, delete_renderbuffer_cb, ctx);
+   _mesa_DeinitHashTable(&shared->FrameBuffers, delete_framebuffer_cb, ctx);
+   _mesa_DeinitHashTable(&shared->RenderBuffers, delete_renderbuffer_cb, ctx);
 
    if (shared->SyncObjects) {
       set_foreach(shared->SyncObjects, entry) {
@@ -396,10 +384,8 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
       _mesa_set_destroy(shared->SyncObjects, NULL);
    }
 
-   if (shared->SamplerObjects) {
-      _mesa_DeleteHashTable(shared->SamplerObjects, delete_sampler_object_cb,
+   _mesa_DeinitHashTable(&shared->SamplerObjects, delete_sampler_object_cb,
                             ctx);
-   }
 
    /*
     * Free texture objects (after FBOs since some textures might have
@@ -412,8 +398,7 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
    }
 
    /* all other textures */
-   if (shared->TexObjects)
-      _mesa_DeleteHashTable(shared->TexObjects, delete_texture_cb, ctx);
+   _mesa_DeinitHashTable(&shared->TexObjects, delete_texture_cb, ctx);
 
    _mesa_free_shared_handles(shared);
 
@@ -421,15 +406,10 @@ free_shared_state(struct gl_context *ctx, struct gl_shared_state *shared)
    _mesa_destroy_shader_includes(shared);
    simple_mtx_destroy(&shared->ShaderIncludeMutex);
 
-   if (shared->MemoryObjects) {
-      _mesa_DeleteHashTable(shared->MemoryObjects, delete_memory_object_cb,
-                            ctx);
-   }
-
-   if (shared->SemaphoreObjects) {
-      _mesa_DeleteHashTable(shared->SemaphoreObjects,
-                            delete_semaphore_object_cb, ctx);
-   }
+   _mesa_DeinitHashTable(&shared->MemoryObjects, delete_memory_object_cb,
+                         ctx);
+   _mesa_DeinitHashTable(&shared->SemaphoreObjects,
+                         delete_semaphore_object_cb, ctx);
 
    simple_mtx_destroy(&shared->Mutex);
    simple_mtx_destroy(&shared->TexMutex);
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index 6909d32c411ad..cf69c3ec666d5 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -2881,7 +2881,7 @@ _mesa_update_fbo_texture(struct gl_context *ctx,
       info.texObj = texObj;
       info.level = level;
       info.face = face;
-      _mesa_HashWalk(ctx->Shared->FrameBuffers, check_rtt_cb, &info);
+      _mesa_HashWalk(&ctx->Shared->FrameBuffers, check_rtt_cb, &info);
    }
 }
 
@@ -3081,7 +3081,7 @@ lookup_texture_ext_dsa(struct gl_context *ctx, GLenum target, GLuint texture,
          }
 
          /* insert into hash table */
-         _mesa_HashInsert(ctx->Shared->TexObjects, texObj->Name, texObj, isGenName);
+         _mesa_HashInsert(&ctx->Shared->TexObjects, texObj->Name, texObj, isGenName);
       }
 
       if (texObj->Target != boundTarget) {
diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index 5c960c730bfee..19d07d460b090 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -117,7 +117,7 @@ struct gl_texture_object *
 _mesa_lookup_texture(struct gl_context *ctx, GLuint id)
 {
    return (struct gl_texture_object *)
-      _mesa_HashLookup(ctx->Shared->TexObjects, id);
+      _mesa_HashLookup(&ctx->Shared->TexObjects, id);
 }
 
 /**
@@ -143,7 +143,7 @@ struct gl_texture_object *
 _mesa_lookup_texture_locked(struct gl_context *ctx, GLuint id)
 {
    return (struct gl_texture_object *)
-      _mesa_HashLookupLocked(ctx->Shared->TexObjects, id);
+      _mesa_HashLookupLocked(&ctx->Shared->TexObjects, id);
 }
 
 /**
@@ -1182,7 +1182,7 @@ _mesa_total_texture_memory(struct gl_context *ctx)
 {
    GLuint tgt, total = 0;
 
-   _mesa_HashWalk(ctx->Shared->TexObjects, count_tex_size, &total);
+   _mesa_HashWalk(&ctx->Shared->TexObjects, count_tex_size, &total);
 
    /* plus, the default texture objects */
    for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
@@ -1280,25 +1280,25 @@ create_textures(struct gl_context *ctx, GLenum target,
    /*
     * This must be atomic (generation and allocation of texture IDs)
     */
-   _mesa_HashLockMutex(ctx->Shared->TexObjects);
+   _mesa_HashLockMutex(&ctx->Shared->TexObjects);
 
-   _mesa_HashFindFreeKeys(ctx->Shared->TexObjects, textures, n);
+   _mesa_HashFindFreeKeys(&ctx->Shared->TexObjects, textures, n);
 
    /* Allocate new, empty texture objects */
    for (i = 0; i < n; i++) {
       struct gl_texture_object *texObj;
       texObj = _mesa_new_texture_object(ctx, textures[i], target);
       if (!texObj) {
-         _mesa_HashUnlockMutex(ctx->Shared->TexObjects);
+         _mesa_HashUnlockMutex(&ctx->Shared->TexObjects);
          _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
          return;
       }
 
       /* insert into hash table */
-      _mesa_HashInsertLocked(ctx->Shared->TexObjects, texObj->Name, texObj, true);
+      _mesa_HashInsertLocked(&ctx->Shared->TexObjects, texObj->Name, texObj, true);
    }
 
-   _mesa_HashUnlockMutex(ctx->Shared->TexObjects);
+   _mesa_HashUnlockMutex(&ctx->Shared->TexObjects);
 }
 
 
@@ -1566,7 +1566,7 @@ delete_textures(struct gl_context *ctx, GLsizei n, const GLuint *textures)
             /* The texture _name_ is now free for re-use.
              * Remove it from the hash table now.
              */
-            _mesa_HashRemove(ctx->Shared->TexObjects, delObj->Name);
+            _mesa_HashRemove(&ctx->Shared->TexObjects, delObj->Name);
 
             st_texture_release_all_sampler_views(st_context(ctx), delObj);
 
@@ -1792,7 +1792,7 @@ _mesa_lookup_or_create_texture(struct gl_context *ctx, GLenum target,
          }
 
          /* and insert it into hash table */
-         _mesa_HashInsert(ctx->Shared->TexObjects, texName, newTexObj, false);
+         _mesa_HashInsert(&ctx->Shared->TexObjects, texName, newTexObj, false);
       }
    }
 
@@ -1975,7 +1975,7 @@ bind_textures(struct gl_context *ctx, GLuint first, GLsizei count,
        *       their parameters are valid and no other error occurs."
        */
 
-      _mesa_HashLockMutex(ctx->Shared->TexObjects);
+      _mesa_HashLockMutex(&ctx->Shared->TexObjects);
 
       for (i = 0; i < count; i++) {
          if (textures[i] != 0) {
@@ -2007,7 +2007,7 @@ bind_textures(struct gl_context *ctx, GLuint first, GLsizei count,
          }
       }
 
-      _mesa_HashUnlockMutex(ctx->Shared->TexObjects);
+      _mesa_HashUnlockMutex(&ctx->Shared->TexObjects);
    } else {
       /* Unbind all textures in the range <first> through <first>+<count>-1 */
       for (i = 0; i < count; i++)
diff --git a/src/mesa/main/transformfeedback.c b/src/mesa/main/transformfeedback.c
index dbc065f553e10..3e4aa2d865f47 100644
--- a/src/mesa/main/transformfeedback.c
+++ b/src/mesa/main/transformfeedback.c
@@ -79,7 +79,7 @@ _mesa_transform_feedback_is_using_program(struct gl_context *ctx,
    callback_data.found = false;
    callback_data.prog = shProg->last_vert_prog;
 
-   _mesa_HashWalkLocked(ctx->TransformFeedback.Objects,
+   _mesa_HashWalkLocked(&ctx->TransformFeedback.Objects,
                         active_xfb_object_references_program, &callback_data);
 
    /* Also check DefaultObject, as it's not in the Objects hash table. */
@@ -182,7 +182,7 @@ _mesa_init_transform_feedback(struct gl_context *ctx)
 
    assert(ctx->TransformFeedback.DefaultObject->RefCount == 2);
 
-   ctx->TransformFeedback.Objects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&ctx->TransformFeedback.Objects);
 
    _mesa_reference_buffer_object(ctx,
                                  &ctx->TransformFeedback.CurrentBuffer, NULL);
@@ -216,7 +216,7 @@ _mesa_free_transform_feedback(struct gl_context *ctx)
                                  NULL);
 
    /* Delete all feedback objects */
-   _mesa_DeleteHashTable(ctx->TransformFeedback.Objects, delete_cb, ctx);
+   _mesa_DeinitHashTable(&ctx->TransformFeedback.Objects, delete_cb, ctx);
 
    /* Delete the default feedback object */
    delete_transform_feedback(ctx,
@@ -1045,7 +1045,7 @@ _mesa_lookup_transform_feedback_object(struct gl_context *ctx, GLuint name)
    }
    else
       return (struct gl_transform_feedback_object *)
-         _mesa_HashLookupLocked(ctx->TransformFeedback.Objects, name);
+         _mesa_HashLookupLocked(&ctx->TransformFeedback.Objects, name);
 }
 
 static void
@@ -1067,7 +1067,7 @@ create_transform_feedbacks(struct gl_context *ctx, GLsizei n, GLuint *ids,
    if (!ids)
       return;
 
-   if (_mesa_HashFindFreeKeys(ctx->TransformFeedback.Objects, ids, n)) {
+   if (_mesa_HashFindFreeKeys(&ctx->TransformFeedback.Objects, ids, n)) {
       GLsizei i;
       for (i = 0; i < n; i++) {
          struct gl_transform_feedback_object *obj
@@ -1076,7 +1076,7 @@ create_transform_feedbacks(struct gl_context *ctx, GLsizei n, GLuint *ids,
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", func);
             return;
          }
-         _mesa_HashInsertLocked(ctx->TransformFeedback.Objects, ids[i],
+         _mesa_HashInsertLocked(&ctx->TransformFeedback.Objects, ids[i],
                                 obj, true);
          if (dsa) {
             /* this is normally done at bind time in the non-dsa case */
@@ -1225,7 +1225,7 @@ _mesa_DeleteTransformFeedbacks(GLsizei n, const GLuint *names)
                            names[i]);
                return;
             }
-            _mesa_HashRemoveLocked(ctx->TransformFeedback.Objects, names[i]);
+            _mesa_HashRemoveLocked(&ctx->TransformFeedback.Objects, names[i]);
             /* unref, but object may not be deleted until later */
             if (obj == ctx->TransformFeedback.CurrentObject) {
                reference_transform_feedback_object(
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index 1340e909f60df..25229537ee518 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -3416,7 +3416,7 @@ vertex_array_vertex_buffers(struct gl_context *ctx,
     *       their parameters are valid and no other error occurs."
     */
 
-   _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashLockMaybeLocked(&ctx->Shared->BufferObjects,
                              ctx->BufferObjectsLocked);
 
    for (i = 0; i < count; i++) {
@@ -3474,7 +3474,7 @@ vertex_array_vertex_buffers(struct gl_context *ctx,
                                vbo, offsets[i], strides[i], false, false);
    }
 
-   _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
+   _mesa_HashUnlockMaybeLocked(&ctx->Shared->BufferObjects,
                                ctx->BufferObjectsLocked);
 }
 
@@ -4167,7 +4167,7 @@ _mesa_init_varray(struct gl_context *ctx)
    _mesa_set_draw_vao(ctx, ctx->Array.VAO);
    ctx->Array.ActiveTexture = 0;   /* GL_ARB_multitexture */
 
-   ctx->Array.Objects = _mesa_NewHashTable();
+   _mesa_InitHashTable(&ctx->Array.Objects);
 }
 
 
@@ -4189,7 +4189,7 @@ delete_arrayobj_cb(void *data, void *userData)
 void
 _mesa_free_varray_data(struct gl_context *ctx)
 {
-   _mesa_DeleteHashTable(ctx->Array.Objects, delete_arrayobj_cb, ctx);
+   _mesa_DeinitHashTable(&ctx->Array.Objects, delete_arrayobj_cb, ctx);
 }
 
 void GLAPIENTRY
diff --git a/src/mesa/program/program.c b/src/mesa/program/program.c
index 52ea0a0bb8569..5c0951251f052 100644
--- a/src/mesa/program/program.c
+++ b/src/mesa/program/program.c
@@ -288,7 +288,7 @@ struct gl_program *
 _mesa_lookup_program(struct gl_context *ctx, GLuint id)
 {
    if (id)
-      return (struct gl_program *) _mesa_HashLookup(ctx->Shared->Programs, id);
+      return (struct gl_program *) _mesa_HashLookup(&ctx->Shared->Programs, id);
    else
       return NULL;
 }
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 937026bf74372..d76992cffbd7a 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -919,7 +919,7 @@ st_destroy_context(struct st_context *st)
    /* This must be called first so that glthread has a chance to finish */
    _mesa_glthread_destroy(ctx);
 
-   _mesa_HashWalk(ctx->Shared->TexObjects, destroy_tex_sampler_cb, st);
+   _mesa_HashWalk(&ctx->Shared->TexObjects, destroy_tex_sampler_cb, st);
 
    /* For the fallback textures, free any sampler views belonging to this
     * context.
@@ -952,7 +952,7 @@ st_destroy_context(struct st_context *st)
       _mesa_reference_framebuffer(&stfb, NULL);
    }
 
-   _mesa_HashWalk(ctx->Shared->FrameBuffers, destroy_framebuffer_attachment_sampler_cb, st);
+   _mesa_HashWalk(&ctx->Shared->FrameBuffers, destroy_framebuffer_attachment_sampler_cb, st);
 
    pipe_sampler_view_reference(&st->pixel_xfer.pixelmap_sampler_view, NULL);
    pipe_resource_reference(&st->pixel_xfer.pixelmap_texture, NULL);
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 1f36e51572f4d..1497283f470dd 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -1221,11 +1221,11 @@ st_destroy_program_variants(struct st_context *st)
       return;
 
    /* ARB vert/frag program */
-   _mesa_HashWalk(st->ctx->Shared->Programs,
+   _mesa_HashWalk(&st->ctx->Shared->Programs,
                   destroy_program_variants_cb, st);
 
    /* GLSL vert/frag/geom shaders */
-   _mesa_HashWalk(st->ctx->Shared->ShaderObjects,
+   _mesa_HashWalk(&st->ctx->Shared->ShaderObjects,
                   destroy_shader_program_variants_cb, st);
 }
 
-- 
GitLab


From c574d80c6e240eb7e623fd7b96b348bfc2d2be6a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 18 May 2021 05:54:20 -0400
Subject: [PATCH 4/4] util/idalloc: optimize foreach by tracking the greatest
 non-zero element

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 src/util/u_idalloc.c | 19 ++++++++++++++++---
 src/util/u_idalloc.h | 11 ++++++-----
 2 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/src/util/u_idalloc.c b/src/util/u_idalloc.c
index 4abe478a9c8eb..2149e09e86b73 100644
--- a/src/util/u_idalloc.c
+++ b/src/util/u_idalloc.c
@@ -74,6 +74,7 @@ util_idalloc_alloc(struct util_idalloc *buf)
       unsigned bit = ffs(~buf->data[i]) - 1;
       buf->data[i] |= 1u << bit;
       buf->lowest_free_idx = i;
+      buf->num_set_elements = MAX2(buf->num_set_elements, i + 1);
       return i * 32 + bit;
    }
 
@@ -82,6 +83,7 @@ util_idalloc_alloc(struct util_idalloc *buf)
 
    buf->lowest_free_idx = num_elements;
    buf->data[num_elements] |= 1;
+   buf->num_set_elements = MAX2(buf->num_set_elements, num_elements + 1);
    return num_elements * 32;
 }
 
@@ -134,6 +136,8 @@ ret:
    if (buf->lowest_free_idx == base)
       buf->lowest_free_idx = base + num / 32;
 
+   buf->num_set_elements = MAX2(buf->num_set_elements, base + num_alloc);
+
    /* Validate this algorithm. */
    for (unsigned i = 0; i < num; i++)
       assert(util_idalloc_exists(buf, base * 32 + i));
@@ -151,14 +155,23 @@ util_idalloc_free(struct util_idalloc *buf, unsigned id)
 
    buf->lowest_free_idx = MIN2(idx, buf->lowest_free_idx);
    buf->data[idx] &= ~(1 << (id % 32));
+
+   /* Decrease num_used to the last used element + 1. */
+   if (buf->num_set_elements == idx + 1) {
+      while (buf->num_set_elements > 0 && !buf->data[buf->num_set_elements - 1])
+         buf->num_set_elements--;
+   }
 }
 
 void
 util_idalloc_reserve(struct util_idalloc *buf, unsigned id)
 {
-   if (id / 32 >= buf->num_elements)
-      util_idalloc_resize(buf, (id / 32 + 1) * 2);
-   buf->data[id / 32] |= 1u << (id % 32);
+   unsigned idx = id / 32;
+
+   if (idx >= buf->num_elements)
+      util_idalloc_resize(buf, (idx + 1) * 2);
+   buf->data[idx] |= 1u << (id % 32);
+   buf->num_set_elements = MAX2(buf->num_set_elements, idx + 1);
 }
 
 void
diff --git a/src/util/u_idalloc.h b/src/util/u_idalloc.h
index 834f5db180b08..73123545bd69f 100644
--- a/src/util/u_idalloc.h
+++ b/src/util/u_idalloc.h
@@ -45,7 +45,8 @@ extern "C" {
 struct util_idalloc
 {
    uint32_t *data;
-   unsigned num_elements;    /* number of allocated elements of "data" */
+   unsigned num_elements;     /* number of allocated elements of "data" */
+   unsigned num_set_elements; /* the last non-zero element of "data" + 1 */
    unsigned lowest_free_idx;
 };
 
@@ -70,20 +71,20 @@ util_idalloc_reserve(struct util_idalloc *buf, unsigned id);
 static inline bool
 util_idalloc_exists(struct util_idalloc *buf, unsigned id)
 {
-   return id / 32 < buf->num_elements &&
+   return id / 32 < buf->num_set_elements &&
           buf->data[id / 32] & BITFIELD_BIT(id % 32);
 }
 
 #define util_idalloc_foreach(buf, id) \
-   for (uint32_t i = 0, mask = (buf)->num_elements ? (buf)->data[0] : 0, id, \
-                 count = (buf)->num_elements; \
+   for (uint32_t i = 0, mask = (buf)->num_set_elements ? (buf)->data[0] : 0, id, \
+                 count = (buf)->num_used; \
         i < count; mask = ++i < count ? (buf)->data[i] : 0) \
       while (mask) \
          if ((id = i * 32 + u_bit_scan(&mask)), true)
 
 /* This allows freeing IDs while iterating. */
 #define util_idalloc_foreach_no_zero_safe(buf, id) \
-   for (uint32_t i = 0, bit, id, count = (buf)->num_elements, \
+   for (uint32_t i = 0, bit, id, count = (buf)->num_set_elements, \
          mask = count ? (buf)->data[0] & ~0x1 : 0; \
         i < count; mask = ++i < count ? (buf)->data[i] : 0) \
       while (mask) \
-- 
GitLab

