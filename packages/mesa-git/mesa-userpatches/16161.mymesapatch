From cc098dd36c6ad22ef646ba946335d139268540b8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 14 Nov 2022 16:17:25 +0100
Subject: [PATCH 1/7] aco: fix reset_block_regs() in postRA-optimizer

Accidentally, we picked the index of the predecessors instead of the predecessors.

Totals from 8496 (6.30% of 134913) affected shaders: (GFX10.3)
CodeSize: 64070724 -> 64022516 (-0.08%); split: -0.08%, +0.00%
Instrs: 11932750 -> 11920698 (-0.10%); split: -0.10%, +0.00%
Latency: 144040266 -> 144017062 (-0.02%); split: -0.02%, +0.00%
InvThroughput: 29327735 -> 29326421 (-0.00%); split: -0.00%, +0.00%

Fixes: 75967a4814be7988afc20e59bac4b48bafacab00 ('aco/optimizer_postRA: Speed up reset_block() with predecessors.')
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 8ced375dd63c..59c0d12548d1 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -89,13 +89,14 @@ struct pr_opt_ctx {
 
       /* Mark overwritten if it doesn't match with other predecessors. */
       const unsigned until_reg = min_reg + num_regs;
-      for (unsigned pred = 1; pred < num_preds; ++pred) {
-         for (unsigned i = min_reg; i < until_reg; ++i) {
-            Idx& idx = instr_idx_by_regs[block_index][i];
+      for (unsigned i = 1; i < num_preds; ++i) {
+         unsigned pred = preds[i];
+         for (unsigned reg = min_reg; reg < until_reg; ++reg) {
+            Idx& idx = instr_idx_by_regs[block_index][reg];
             if (idx == overwritten_untrackable)
                continue;
 
-            if (idx != instr_idx_by_regs[pred][i])
+            if (idx != instr_idx_by_regs[pred][reg])
                idx = overwritten_untrackable;
          }
       }
-- 
GitLab


From 5244015826faede2e574437c2fbc808dabb38178 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 14 Nov 2022 18:04:23 +0100
Subject: [PATCH 2/7] aco/optimizer_postRA: Initialize loop header with
 preheader information

This works because of SSA and should be safer than just setting 'not_written_yet'.

Totals from 1673 (1.24% of 134913) affected shaders: (GFX10.3)
CodeSize: 14301984 -> 14294440 (-0.05%)
Instrs: 2731138 -> 2729252 (-0.07%)
Latency: 17763181 -> 17762582 (-0.00%); split: -0.00%, +0.00%
InvThroughput: 2969629 -> 2969559 (-0.00%)
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 59c0d12548d1..7a598ed65549 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -107,9 +107,17 @@ struct pr_opt_ctx {
       current_block = block;
       current_instr_idx = 0;
 
-      if ((block->kind & block_kind_loop_header) || block->linear_preds.empty()) {
+      if (block->linear_preds.empty()) {
          std::fill(instr_idx_by_regs[block->index].begin(), instr_idx_by_regs[block->index].end(),
                    not_written_yet);
+      } else if (block->kind & block_kind_loop_header) {
+         /* Initialize with content from loop preheader */
+         memcpy(&instr_idx_by_regs[block->index][0], &instr_idx_by_regs[block->index - 1][0],
+                max_reg_cnt * sizeof(Idx));
+
+         /* Assume exec writes on back-edges */
+         instr_idx_by_regs[block->index][126] = overwritten_untrackable;
+         instr_idx_by_regs[block->index][127] = overwritten_untrackable;
       } else {
          reset_block_regs(block->linear_preds, block->index, 0, max_sgpr_cnt);
          reset_block_regs(block->linear_preds, block->index, 251, 3);
-- 
GitLab


From fe5d16fee0a33ad71803bbdb7375c01d0b570823 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 3 Nov 2022 18:30:28 +0100
Subject: [PATCH 3/7] aco/optimizer_postRA: Distinguish
 overwritten_untrackable_prev_block.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This allows is_overwritten_since to return false when the last
writer instruction of a register can't be tracked but we know it wasn't
written in the current block.

Fossil DB stats on Rembrandt:

Totals from 9155 (6.79% of 134906) affected shaders:
CodeSize: 68859796 -> 68805784 (-0.08%)
Instrs: 12892462 -> 12878959 (-0.10%)
Latency: 129374853 -> 129343129 (-0.02%); split: -0.02%, +0.00%
InvThroughput: 24766667 -> 24764928 (-0.01%); split: -0.01%, +0.00%

Signed-off-by: Timur Krist√≥f <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 7a598ed65549..cfcb1f01eb18 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -62,6 +62,12 @@ Idx const_or_undef{UINT32_MAX, 2};
  */
 Idx overwritten_untrackable{UINT32_MAX, 3};
 
+/**
+ * Indicates that a register range was overwritten in a previous block
+ * but we can't track the instruction that wrote it.
+ */
+Idx overwritten_untrackable_prev_block{UINT32_MAX, 4};
+
 struct pr_opt_ctx {
    using Idx_array = std::array<Idx, max_reg_cnt>;
 
@@ -93,11 +99,8 @@ struct pr_opt_ctx {
          unsigned pred = preds[i];
          for (unsigned reg = min_reg; reg < until_reg; ++reg) {
             Idx& idx = instr_idx_by_regs[block_index][reg];
-            if (idx == overwritten_untrackable)
-               continue;
-
-            if (idx != instr_idx_by_regs[pred][reg])
-               idx = overwritten_untrackable;
+            if (idx == overwritten_untrackable || idx != instr_idx_by_regs[pred][reg])
+               idx = overwritten_untrackable_prev_block;
          }
       }
    }
@@ -209,8 +212,10 @@ is_overwritten_since(pr_opt_ctx& ctx, PhysReg reg, RegClass rc, const Idx& since
 
    for (unsigned r = begin_reg; r < end_reg; ++r) {
       Idx& i = ctx.instr_idx_by_regs[current_block_idx][r];
-      if (i == overwritten_untrackable)
+      if (i == overwritten_untrackable || (i == overwritten_untrackable_prev_block && since_idx.block != ctx.current_block->index))
          return true;
+      else if (i == overwritten_untrackable_prev_block)
+         continue;
       else if (i == not_written_yet)
          continue;
 
-- 
GitLab


From b3354013397952f4fdd53d7f75eb604a0be11dd5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 14 Nov 2022 17:29:36 +0100
Subject: [PATCH 4/7] [SQUASH] distinguish untrackable and subdword instead

With the bugfix from the previous patch, there is no difference between
untrackable and untrackable_prev except for subdword writes.

The only affected values are exec writes which are not SSA.
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 31 +++++++++--------------
 1 file changed, 12 insertions(+), 19 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index cfcb1f01eb18..af720fcf5114 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -48,25 +48,17 @@ struct Idx {
    uint32_t instr;
 };
 
-/** Indicates that a register range was not yet written in the shader. */
+/** Indicates that a register was not yet written in the shader. */
 Idx not_written_yet{UINT32_MAX, 0};
 
 /** Indicates that an operand is constant or undefined, not written by any instruction. */
 Idx const_or_undef{UINT32_MAX, 2};
 
-/**
- * Indicates that a register range was overwritten but we can't track the instruction that wrote it.
- * Possible reasons for this:
- * - Some registers in the range were overwritten by different instructions.
- * - The register was used as a subdword definition which we don't support here.
- */
+/** Indicates that a register was overwritten by different instructions in previous blocks. */
 Idx overwritten_untrackable{UINT32_MAX, 3};
 
-/**
- * Indicates that a register range was overwritten in a previous block
- * but we can't track the instruction that wrote it.
- */
-Idx overwritten_untrackable_prev_block{UINT32_MAX, 4};
+/** Indicates that a register was written by subdword operations. */
+Idx overwritten_subdword{UINT32_MAX, 4};
 
 struct pr_opt_ctx {
    using Idx_array = std::array<Idx, max_reg_cnt>;
@@ -99,8 +91,11 @@ struct pr_opt_ctx {
          unsigned pred = preds[i];
          for (unsigned reg = min_reg; reg < until_reg; ++reg) {
             Idx& idx = instr_idx_by_regs[block_index][reg];
-            if (idx == overwritten_untrackable || idx != instr_idx_by_regs[pred][reg])
-               idx = overwritten_untrackable_prev_block;
+            if (idx == overwritten_untrackable)
+               continue;
+
+            if (idx != instr_idx_by_regs[pred][reg])
+               idx = overwritten_untrackable;
          }
       }
    }
@@ -155,7 +150,7 @@ save_reg_writes(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
       Idx idx{ctx.current_block->index, ctx.current_instr_idx};
 
       if (def.regClass().is_subdword())
-         idx = overwritten_untrackable;
+         idx = overwritten_subdword;
 
       assert((r + dw_size) <= max_reg_cnt);
       assert(def.size() == dw_size || def.regClass().is_subdword());
@@ -212,11 +207,9 @@ is_overwritten_since(pr_opt_ctx& ctx, PhysReg reg, RegClass rc, const Idx& since
 
    for (unsigned r = begin_reg; r < end_reg; ++r) {
       Idx& i = ctx.instr_idx_by_regs[current_block_idx][r];
-      if (i == overwritten_untrackable || (i == overwritten_untrackable_prev_block && since_idx.block != ctx.current_block->index))
+      if (i == overwritten_untrackable && current_block_idx > since_idx.block)
          return true;
-      else if (i == overwritten_untrackable_prev_block)
-         continue;
-      else if (i == not_written_yet)
+      else if (i == overwritten_untrackable || i == not_written_yet)
          continue;
 
       assert(i.found());
-- 
GitLab


From 879238d57c3fdd4d3c5dbea5f913a74b12f835ef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Tue, 26 Apr 2022 11:09:47 +0200
Subject: [PATCH 5/7] aco: Try to reassign split vector registers post-RA.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Eliminate unnecessary copies when the operand registers of a
p_split_vector instruction are not clobbered between the p_split_vector
and the user of its definitions.

This happens when p_split_vector doesn't kill its operand and its
definitions have a shorter lifespan that the operand. It affects every
NGG culling shader among other things.

This optimization exists because it's too difficult to solve it
in RA, and should be removed after we solved this in RA.

v2 by Daniel Sch√ºrmann:
- Rearrange and simplify conditions for the new optimization
- Fix a few bugs

Fossil DB stats on Rembrandt:

Totals from 64882 (48.09% of 134906) affected shaders:
CodeSize: 175598372 -> 175340604 (-0.15%)
Instrs: 33311018 -> 33246604 (-0.19%)
Latency: 183179887 -> 183177316 (-0.00%); split: -0.00%, +0.00%
InvThroughput: 28475720 -> 28475518 (-0.00%); split: -0.00%, +0.00%
Copies: 2814902 -> 2750493 (-2.29%)

Signed-off-by: Timur Krist√≥f <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 83 +++++++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index af720fcf5114..4c62ca399a2e 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -543,6 +543,87 @@ try_combine_dpp(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
+void
+try_reassign_split_vector(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   /* We are looking for the following pattern:
+    *
+    * sA, sB = p_split_vector s[X:Y]
+    * ... X and Y not overwritten here ...
+    * use sA or sB <--- current instruction
+    *
+    * If possible, we propagate the registers from the p_split_vector
+    * operand into the current instruction and the above is optimized into:
+    *
+    * use sX or sY
+    *
+    * Thereby, we might violate register assignment rules.
+    * This optimization exists because it's too difficult to solve it
+    * in RA, and should be removed after we solved this in RA.
+    */
+
+   if (!instr->isVALU() && !instr->isSALU())
+      return;
+
+   for (unsigned i = 0; i < instr->operands.size(); i++) {
+      /* Find the instruction that writes the current operand. */
+      const Operand& op = instr->operands[i];
+      Idx op_instr_idx = last_writer_idx(ctx, op);
+      if (!op_instr_idx.found())
+         continue;
+
+      /* Check if the operand is written by p_split_vector. */
+      Instruction* split_vec = ctx.get(op_instr_idx);
+      if (split_vec->opcode != aco_opcode::p_split_vector)
+         continue;
+
+      Operand& split_op = split_vec->operands[0];
+
+      /* Don't do anything if the p_split_vector operand is not a temporary
+       * or is killed by the p_split_vector.
+       * In this case the definitions likely already reuse the same registers as the operand.
+       */
+      if (!split_op.isTemp() || split_op.isKill())
+         continue;
+
+      /* Only propagate operands of the same type */
+      if (split_op.getTemp().type() != op.getTemp().type())
+         continue;
+
+      /* Check if the p_split_vector operand's registers are overwritten. */
+      if (is_overwritten_since(ctx, split_op, op_instr_idx))
+         continue;
+
+      PhysReg reg = split_op.physReg();
+      for (Definition& def : split_vec->definitions) {
+         if (def.getTemp() != op.getTemp()) {
+            reg = reg.advance(def.bytes());
+            continue;
+         }
+
+         /* Don't propagate misaligned SGPRs.
+          * Note: No ALU instruction can take a variable larger than 64bit.
+          */
+         if (op.regClass() == s2 && reg.reg() % 2 != 0)
+            break;
+
+         /* If there is only one use (left), recolor the split_vector definition */
+         if (ctx.uses[op.tempId()] == 1)
+            def.setFixed(reg);
+         else
+            ctx.uses[op.tempId()]--;
+
+         /* Use the p_split_vector operand register directly.
+          *
+          * Note: this might violate register assignment rules to some extend
+          *       in case the definition does not get recolored, eventually.
+          */
+         instr->operands[i].setFixed(reg);
+         break;
+      }
+   }
+}
+
 void
 process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -559,6 +640,8 @@ process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
    try_combine_dpp(ctx, instr);
 
+   try_reassign_split_vector(ctx, instr);
+
    if (instr)
       save_reg_writes(ctx, instr);
 
-- 
GitLab


From ab30e9ad0ffe8d6c1bee56080f4054f6c3e9eeae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 15 Nov 2022 18:08:43 +0100
Subject: [PATCH 6/7] [SQUASH] only consider unconstraint / encoded operands

---
 src/amd/compiler/aco_optimizer_postRA.cpp | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 4c62ca399a2e..af8b89213f38 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -543,6 +543,22 @@ try_combine_dpp(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
+unsigned
+num_encoded_alu_operands(const aco_ptr<Instruction>& instr)
+{
+   switch (instr->format) {
+   case Format::SOPK: return 0;
+   case Format::SOP1:
+   case Format::SOPP:
+   case Format::VOP1: return 1;
+   case Format::VOP2:
+   case Format::VOPC:
+   case Format::SOP2:
+   case Format::SOPC: return 2;
+   default: return instr->operands.size();
+   }
+}
+
 void
 try_reassign_split_vector(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -565,7 +581,7 @@ try_reassign_split_vector(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (!instr->isVALU() && !instr->isSALU())
       return;
 
-   for (unsigned i = 0; i < instr->operands.size(); i++) {
+   for (unsigned i = 0; i < num_encoded_alu_operands(instr); i++) {
       /* Find the instruction that writes the current operand. */
       const Operand& op = instr->operands[i];
       Idx op_instr_idx = last_writer_idx(ctx, op);
-- 
GitLab


From bb05f1366a35b3d89b1f8aa7014493f417c50823 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 2 Nov 2022 13:35:57 +0100
Subject: [PATCH 7/7] aco: Reassign dead definitions of p_split_vector to
 associated register
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Any unused split_vector definition can always use the same register
as the operand. This avoids creating unnecessary copies.

Fossil DB stats on Rembrandt:

Totals from 3908 (2.90% of 134906) affected shaders:
CodeSize: 18369496 -> 18292740 (-0.42%)
Instrs: 3396306 -> 3377129 (-0.56%)
Latency: 42354546 -> 42344161 (-0.02%); split: -0.03%, +0.00%
InvThroughput: 6572594 -> 6572152 (-0.01%); split: -0.01%, +0.00%
SClause: 129444 -> 129386 (-0.04%)
Copies: 230104 -> 210909 (-8.34%)

Reviewed-by: Timur Krist√≥f <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index af8b89213f38..a412227ecce1 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -562,6 +562,25 @@ num_encoded_alu_operands(const aco_ptr<Instruction>& instr)
 void
 try_reassign_split_vector(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
+   /* Any unused split_vector definition can always use the same register
+    * as the operand. This avoids creating unnecessary copies.
+    */
+   if (instr->opcode == aco_opcode::p_split_vector) {
+      Operand& op = instr->operands[0];
+      if (!op.isTemp() || op.isKill())
+         return;
+
+      PhysReg reg = op.physReg();
+      for (Definition& def : instr->definitions) {
+         if (def.getTemp().type() == op.getTemp().type() && def.isKill())
+            def.setFixed(reg);
+
+         reg = reg.advance(def.bytes());
+      }
+
+      return;
+   }
+
    /* We are looking for the following pattern:
     *
     * sA, sB = p_split_vector s[X:Y]
-- 
GitLab

