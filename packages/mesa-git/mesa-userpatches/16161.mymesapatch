From 689d4ed04385f4b916b7ac4709998925ac52dda4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 14 Nov 2022 16:17:25 +0100
Subject: [PATCH 1/5] aco: fix reset_block_regs() in postRA-optimizer

Accidentally, we picked the index of the predecessors instead of the predecessors.

Totals from 8496 (6.30% of 134913) affected shaders: (GFX10.3)
CodeSize: 64070724 -> 64022516 (-0.08%); split: -0.08%, +0.00%
Instrs: 11932750 -> 11920698 (-0.10%); split: -0.10%, +0.00%
Latency: 144040266 -> 144017062 (-0.02%); split: -0.02%, +0.00%
InvThroughput: 29327735 -> 29326421 (-0.00%); split: -0.00%, +0.00%

Fixes: 75967a4814be7988afc20e59bac4b48bafacab00 ('aco/optimizer_postRA: Speed up reset_block() with predecessors.')
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 8ced375dd63c..59c0d12548d1 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -89,13 +89,14 @@ struct pr_opt_ctx {
 
       /* Mark overwritten if it doesn't match with other predecessors. */
       const unsigned until_reg = min_reg + num_regs;
-      for (unsigned pred = 1; pred < num_preds; ++pred) {
-         for (unsigned i = min_reg; i < until_reg; ++i) {
-            Idx& idx = instr_idx_by_regs[block_index][i];
+      for (unsigned i = 1; i < num_preds; ++i) {
+         unsigned pred = preds[i];
+         for (unsigned reg = min_reg; reg < until_reg; ++reg) {
+            Idx& idx = instr_idx_by_regs[block_index][reg];
             if (idx == overwritten_untrackable)
                continue;
 
-            if (idx != instr_idx_by_regs[pred][i])
+            if (idx != instr_idx_by_regs[pred][reg])
                idx = overwritten_untrackable;
          }
       }
-- 
GitLab


From 3531ba652516029d3d989ae2566ee7b519fee44e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 14 Nov 2022 18:04:23 +0100
Subject: [PATCH 2/5] aco/optimizer_postRA: Initialize loop header with
 preheader information

This works because of SSA and should be safer than just setting 'not_written_yet'.

Totals from 1673 (1.24% of 134913) affected shaders: (GFX10.3)
CodeSize: 14301984 -> 14294440 (-0.05%)
Instrs: 2731138 -> 2729252 (-0.07%)
Latency: 17763181 -> 17762582 (-0.00%); split: -0.00%, +0.00%
InvThroughput: 2969629 -> 2969559 (-0.00%)
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 59c0d12548d1..7a598ed65549 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -107,9 +107,17 @@ struct pr_opt_ctx {
       current_block = block;
       current_instr_idx = 0;
 
-      if ((block->kind & block_kind_loop_header) || block->linear_preds.empty()) {
+      if (block->linear_preds.empty()) {
          std::fill(instr_idx_by_regs[block->index].begin(), instr_idx_by_regs[block->index].end(),
                    not_written_yet);
+      } else if (block->kind & block_kind_loop_header) {
+         /* Initialize with content from loop preheader */
+         memcpy(&instr_idx_by_regs[block->index][0], &instr_idx_by_regs[block->index - 1][0],
+                max_reg_cnt * sizeof(Idx));
+
+         /* Assume exec writes on back-edges */
+         instr_idx_by_regs[block->index][126] = overwritten_untrackable;
+         instr_idx_by_regs[block->index][127] = overwritten_untrackable;
       } else {
          reset_block_regs(block->linear_preds, block->index, 0, max_sgpr_cnt);
          reset_block_regs(block->linear_preds, block->index, 251, 3);
-- 
GitLab


From d237d7f35f5aefa5c5154e89d6dd1f93b697b41b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 3 Nov 2022 18:30:28 +0100
Subject: [PATCH 3/5] aco/optimizer_postRA: Distinguish overwritten untrackable
 and subdword.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This allows is_overwritten_since to return false when the last
writer instruction of a register can't be tracked but we know it wasn't
written in the current block.

Fossil DB stats on Rembrandt:

Totals from 9155 (6.79% of 134906) affected shaders:
CodeSize: 68859796 -> 68805784 (-0.08%)
Instrs: 12892462 -> 12878959 (-0.10%)
Latency: 129374853 -> 129343129 (-0.02%); split: -0.02%, +0.00%
InvThroughput: 24766667 -> 24764928 (-0.01%); split: -0.01%, +0.00%

Signed-off-by: Timur Krist처f <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 18 ++++++++----------
 1 file changed, 8 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 7a598ed65549..af720fcf5114 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -48,20 +48,18 @@ struct Idx {
    uint32_t instr;
 };
 
-/** Indicates that a register range was not yet written in the shader. */
+/** Indicates that a register was not yet written in the shader. */
 Idx not_written_yet{UINT32_MAX, 0};
 
 /** Indicates that an operand is constant or undefined, not written by any instruction. */
 Idx const_or_undef{UINT32_MAX, 2};
 
-/**
- * Indicates that a register range was overwritten but we can't track the instruction that wrote it.
- * Possible reasons for this:
- * - Some registers in the range were overwritten by different instructions.
- * - The register was used as a subdword definition which we don't support here.
- */
+/** Indicates that a register was overwritten by different instructions in previous blocks. */
 Idx overwritten_untrackable{UINT32_MAX, 3};
 
+/** Indicates that a register was written by subdword operations. */
+Idx overwritten_subdword{UINT32_MAX, 4};
+
 struct pr_opt_ctx {
    using Idx_array = std::array<Idx, max_reg_cnt>;
 
@@ -152,7 +150,7 @@ save_reg_writes(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
       Idx idx{ctx.current_block->index, ctx.current_instr_idx};
 
       if (def.regClass().is_subdword())
-         idx = overwritten_untrackable;
+         idx = overwritten_subdword;
 
       assert((r + dw_size) <= max_reg_cnt);
       assert(def.size() == dw_size || def.regClass().is_subdword());
@@ -209,9 +207,9 @@ is_overwritten_since(pr_opt_ctx& ctx, PhysReg reg, RegClass rc, const Idx& since
 
    for (unsigned r = begin_reg; r < end_reg; ++r) {
       Idx& i = ctx.instr_idx_by_regs[current_block_idx][r];
-      if (i == overwritten_untrackable)
+      if (i == overwritten_untrackable && current_block_idx > since_idx.block)
          return true;
-      else if (i == not_written_yet)
+      else if (i == overwritten_untrackable || i == not_written_yet)
          continue;
 
       assert(i.found());
-- 
GitLab


From 6823bf8264938c2ffde6e38aa8a10e2938c561f9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Tue, 26 Apr 2022 11:09:47 +0200
Subject: [PATCH 4/5] aco: Try to reassign split vector registers post-RA.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Eliminate unnecessary copies when the operand registers of a
p_split_vector instruction are not clobbered between the p_split_vector
and the user of its definitions.

This happens when p_split_vector doesn't kill its operand and its
definitions have a shorter lifespan that the operand. It affects every
NGG culling shader among other things.

This optimization exists because it's too difficult to solve it
in RA, and should be removed after we solved this in RA.

v2 by Daniel Sch체rmann:
- Rearrange and simplify conditions for the new optimization
- Fix a few bugs

v3 by Daniel Sch체rmann:
- Check number of encoded ALU operands

Fossil DB stats on Rembrandt:

Totals from 64882 (48.09% of 134906) affected shaders:
CodeSize: 175598372 -> 175340604 (-0.15%)
Instrs: 33311018 -> 33246604 (-0.19%)
Latency: 183179887 -> 183177316 (-0.00%); split: -0.00%, +0.00%
InvThroughput: 28475720 -> 28475518 (-0.00%); split: -0.00%, +0.00%
Copies: 2814902 -> 2750493 (-2.29%)

Signed-off-by: Timur Krist처f <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 110 ++++++++++++++++++++++
 1 file changed, 110 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index af720fcf5114..476ef3d20030 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -543,6 +543,114 @@ try_combine_dpp(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
+unsigned
+num_encoded_alu_operands(const aco_ptr<Instruction>& instr)
+{
+   if (instr->isSALU()) {
+      if (instr->isSOP2())
+         return 2;
+      else if (instr->isSOP1())
+         return 1;
+
+      return 0;
+   }
+
+   if (instr->isVALU()) {
+      if (instr->isVOP1())
+         return 1;
+      else if (instr->isVOPC() || instr->isVOP2())
+         return 2;
+      else if (instr->opcode == aco_opcode::v_writelane_b32_e64 ||
+               instr->opcode == aco_opcode::v_writelane_b32)
+         return 2; /* potentially VOP3, but reads VDST as SRC2 */
+      else if (instr->isVOP3() || instr->isVOP3P())
+         return instr->operands.size();
+   }
+
+   return 0;
+}
+
+void
+try_reassign_split_vector(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   /* We are looking for the following pattern:
+    *
+    * sA, sB = p_split_vector s[X:Y]
+    * ... X and Y not overwritten here ...
+    * use sA or sB <--- current instruction
+    *
+    * If possible, we propagate the registers from the p_split_vector
+    * operand into the current instruction and the above is optimized into:
+    *
+    * use sX or sY
+    *
+    * Thereby, we might violate register assignment rules.
+    * This optimization exists because it's too difficult to solve it
+    * in RA, and should be removed after we solved this in RA.
+    */
+
+   if (!instr->isVALU() && !instr->isSALU())
+      return;
+
+   for (unsigned i = 0; i < num_encoded_alu_operands(instr); i++) {
+      /* Find the instruction that writes the current operand. */
+      const Operand& op = instr->operands[i];
+      Idx op_instr_idx = last_writer_idx(ctx, op);
+      if (!op_instr_idx.found())
+         continue;
+
+      /* Check if the operand is written by p_split_vector. */
+      Instruction* split_vec = ctx.get(op_instr_idx);
+      if (split_vec->opcode != aco_opcode::p_split_vector)
+         continue;
+
+      Operand& split_op = split_vec->operands[0];
+
+      /* Don't do anything if the p_split_vector operand is not a temporary
+       * or is killed by the p_split_vector.
+       * In this case the definitions likely already reuse the same registers as the operand.
+       */
+      if (!split_op.isTemp() || split_op.isKill())
+         continue;
+
+      /* Only propagate operands of the same type */
+      if (split_op.getTemp().type() != op.getTemp().type())
+         continue;
+
+      /* Check if the p_split_vector operand's registers are overwritten. */
+      if (is_overwritten_since(ctx, split_op, op_instr_idx))
+         continue;
+
+      PhysReg reg = split_op.physReg();
+      for (Definition& def : split_vec->definitions) {
+         if (def.getTemp() != op.getTemp()) {
+            reg = reg.advance(def.bytes());
+            continue;
+         }
+
+         /* Don't propagate misaligned SGPRs.
+          * Note: No ALU instruction can take a variable larger than 64bit.
+          */
+         if (op.regClass() == s2 && reg.reg() % 2 != 0)
+            break;
+
+         /* If there is only one use (left), recolor the split_vector definition */
+         if (ctx.uses[op.tempId()] == 1)
+            def.setFixed(reg);
+         else
+            ctx.uses[op.tempId()]--;
+
+         /* Use the p_split_vector operand register directly.
+          *
+          * Note: this might violate register assignment rules to some extend
+          *       in case the definition does not get recolored, eventually.
+          */
+         instr->operands[i].setFixed(reg);
+         break;
+      }
+   }
+}
+
 void
 process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -559,6 +667,8 @@ process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
    try_combine_dpp(ctx, instr);
 
+   try_reassign_split_vector(ctx, instr);
+
    if (instr)
       save_reg_writes(ctx, instr);
 
-- 
GitLab


From cffc17349e6503c66abacbc0177e99a85e250bce Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 2 Nov 2022 13:35:57 +0100
Subject: [PATCH 5/5] aco: Reassign dead definitions of p_split_vector to
 associated register
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Any unused split_vector definition can always use the same register
as the operand. This avoids creating unnecessary copies.

Fossil DB stats on Rembrandt:

Totals from 3908 (2.90% of 134906) affected shaders:
CodeSize: 18369496 -> 18292740 (-0.42%)
Instrs: 3396306 -> 3377129 (-0.56%)
Latency: 42354546 -> 42344161 (-0.02%); split: -0.03%, +0.00%
InvThroughput: 6572594 -> 6572152 (-0.01%); split: -0.01%, +0.00%
SClause: 129444 -> 129386 (-0.04%)
Copies: 230104 -> 210909 (-8.34%)

Reviewed-by: Timur Krist처f <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 476ef3d20030..91fc663927c7 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -573,6 +573,25 @@ num_encoded_alu_operands(const aco_ptr<Instruction>& instr)
 void
 try_reassign_split_vector(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
+   /* Any unused split_vector definition can always use the same register
+    * as the operand. This avoids creating unnecessary copies.
+    */
+   if (instr->opcode == aco_opcode::p_split_vector) {
+      Operand& op = instr->operands[0];
+      if (!op.isTemp() || op.isKill())
+         return;
+
+      PhysReg reg = op.physReg();
+      for (Definition& def : instr->definitions) {
+         if (def.getTemp().type() == op.getTemp().type() && def.isKill())
+            def.setFixed(reg);
+
+         reg = reg.advance(def.bytes());
+      }
+
+      return;
+   }
+
    /* We are looking for the following pattern:
     *
     * sA, sB = p_split_vector s[X:Y]
-- 
GitLab

