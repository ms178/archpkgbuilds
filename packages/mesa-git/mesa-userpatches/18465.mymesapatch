From 4cc12f4c5ff35e7d28a2296277562af14c95c9c7 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 2 Sep 2022 16:58:12 +0100
Subject: [PATCH 1/4] radv: shrink zero-initialization in
 vkCmdSetVertexInputEXT

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c              | 19 ++++++++++++++++++-
 .../vulkan/radv_device_generated_commands.c   |  9 +++++++++
 2 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 3819dffdcea4..45c3d880b749 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3563,6 +3563,16 @@ radv_write_vertex_descriptors(const struct radv_cmd_buffer *cmd_buffer,
       unsigned i = u_bit_scan(&mask);
       uint32_t *desc = &((uint32_t *)vb_ptr)[desc_index++ * 4];
       uint32_t offset, rsrc_word3;
+
+      if (vs_state && !(vs_state->attribute_mask & BITFIELD_BIT(i))) {
+         /* No vertex attribute description given: assume that the shader doesn't use this
+          * location (vb_desc_usage_mask can be larger than attribute usage) and just use a null
+          * descriptor.
+          */
+         memset(desc, 0, 4 * 4);
+         continue;
+      }
+
       unsigned binding =
          vs_state ? cmd_buffer->state.dynamic_vs_input.bindings[i]
                   : (pipeline->use_per_attribute_vb_descs ? pipeline->attrib_bindings[i] : i);
@@ -5815,7 +5825,14 @@ radv_CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingD
    cmd_buffer->state.vbo_misaligned_mask = 0;
    cmd_buffer->state.vbo_misaligned_mask_invalid = 0;
 
-   memset(state, 0, sizeof(*state));
+   state->attribute_mask = 0;
+   state->instance_rate_inputs = 0;
+   state->nontrivial_divisors = 0;
+   state->zero_divisors = 0;
+   state->post_shuffle = 0;
+   state->alpha_adjust_lo = 0;
+   state->alpha_adjust_hi = 0;
+   state->nontrivial_formats = 0;
    state->bindings_match_attrib = true;
 
    enum amd_gfx_level chip = cmd_buffer->device->physical_device->rad_info.gfx_level;
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 1a4dc0a64ead..21ecb37c9063 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1215,6 +1215,15 @@ radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer,
       unsigned idx = 0;
       while (mask) {
          unsigned i = u_bit_scan(&mask);
+
+         if (vs_state && !(vs_state->attribute_mask & BITFIELD_BIT(i))) {
+            /* No vertex attribute description given: assume that the shader doesn't use this
+             * location (vb_desc_usage_mask can be larger than attribute usage).
+             */
+            ++idx;
+            continue;
+         }
+
          unsigned binding =
             vs_state ? cmd_buffer->state.dynamic_vs_input.bindings[i]
                      : (graphics_pipeline->use_per_attribute_vb_descs ? graphics_pipeline->attrib_bindings[i] : i);
-- 
GitLab


From d9df8b108b618ed3652e60bf47882d136eef6b90 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 7 Sep 2022 15:55:56 +0100
Subject: [PATCH 2/4] radv: disable EXT_vertex_input_dynamic_state when using
 DGC

This simplifies the DGC path and removes some untested code. The only user
of the partial DGC implementation (vkd3d-proton) doesn't use
EXT_vertex_input_dynamic_state.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/vulkan/radv_device.c                  | 15 ++++--
 .../vulkan/radv_device_generated_commands.c   | 51 +++----------------
 2 files changed, 18 insertions(+), 48 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 2f316666a100..cc78639f20b8 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -386,6 +386,14 @@ radv_taskmesh_enabled(const struct radv_physical_device *pdevice)
           pdevice->rad_info.has_scheduled_fence_dependency;
 }
 
+static bool
+radv_NV_device_generated_commands_enabled(const struct radv_physical_device *device)
+{
+   return device->rad_info.gfx_level >= GFX7 &&
+          !(device->instance->debug_flags & RADV_DEBUG_NO_IBS) &&
+          driQueryOptionb(&device->instance->dri_options, "radv_dgc");
+}
+
 #if defined(VK_USE_PLATFORM_WAYLAND_KHR) || defined(VK_USE_PLATFORM_XCB_KHR) ||                    \
    defined(VK_USE_PLATFORM_XLIB_KHR) || defined(VK_USE_PLATFORM_DISPLAY_KHR)
 #define RADV_USE_WSI_PLATFORM
@@ -586,7 +594,8 @@ radv_physical_device_get_supported_extensions(const struct radv_physical_device
       .EXT_texel_buffer_alignment = true,
       .EXT_transform_feedback = device->rad_info.gfx_level < GFX11,
       .EXT_vertex_attribute_divisor = true,
-      .EXT_vertex_input_dynamic_state = !device->use_llvm,
+      .EXT_vertex_input_dynamic_state = !device->use_llvm &&
+                                        !radv_NV_device_generated_commands_enabled(device),
       .EXT_ycbcr_image_arrays = true,
       .AMD_buffer_marker = true,
       .AMD_device_coherent_memory = true,
@@ -614,9 +623,7 @@ radv_physical_device_get_supported_extensions(const struct radv_physical_device
       .GOOGLE_user_type = true,
       .INTEL_shader_integer_functions2 = true,
       .NV_compute_shader_derivatives = true,
-      .NV_device_generated_commands = device->rad_info.gfx_level >= GFX7 &&
-                                      !(device->instance->debug_flags & RADV_DEBUG_NO_IBS) &&
-                                      driQueryOptionb(&device->instance->dri_options, "radv_dgc"),
+      .NV_device_generated_commands = radv_NV_device_generated_commands_enabled(device),
       .NV_mesh_shader =
          radv_taskmesh_enabled(device) && device->instance->perftest_flags & RADV_PERFTEST_NV_MS,
       /* Undocumented extension purely for vkd3d-proton. This check is to prevent anyone else from
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 21ecb37c9063..4ec10518e3b6 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -147,7 +147,6 @@ struct radv_dgc_params {
    /* bind index buffer info. Valid if base_index_size == 0 && draw_indexed */
    uint16_t index_buffer_offset;
 
-   /* Top bit is DGC_DYNAMIC_VERTEX_INPUT */
    uint8_t vbo_cnt;
 
    uint8_t const_copy;
@@ -181,10 +180,6 @@ enum {
    DGC_DYNAMIC_STRIDE = 1u << 15,
 };
 
-enum {
-   DGC_DYNAMIC_VERTEX_INPUT = 1u << 7,
-};
-
 enum {
    DGC_DESC_STREAM,
    DGC_DESC_PREPARE,
@@ -381,7 +376,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
                     0x1);
 
       nir_ssa_def *vbo_bind_mask = load_param32(&b, vbo_bind_mask);
-      nir_ssa_def *vbo_cnt = nir_iand_imm(&b, load_param8(&b, vbo_cnt), 0x7F);
+      nir_ssa_def *vbo_cnt = load_param8(&b, vbo_cnt);
       nir_push_if(&b, nir_ine_imm(&b, vbo_bind_mask, 0));
       {
          nir_variable *vbo_idx =
@@ -425,9 +420,6 @@ build_dgc_prepare_shader(struct radv_device *dev)
                nir_ssa_def *size = nir_channel(&b, stream_data, 2);
                nir_ssa_def *stride = nir_channel(&b, stream_data, 3);
 
-               nir_ssa_def *vs_state_offset = nir_ubfe(&b, nir_channel(&b, vbo_over_data, 0), nir_imm_int(&b, 16), nir_imm_int(&b, 15));
-               va = nir_iadd(&b, va, nir_u2u64(&b, vs_state_offset));
-
                nir_ssa_def *dyn_stride = nir_test_mask(&b, nir_channel(&b, vbo_over_data, 0), DGC_DYNAMIC_STRIDE);
                nir_ssa_def *old_stride =
                   nir_ubfe(&b, nir_channel(&b, nir_load_var(&b, vbo_data), 1), nir_imm_int(&b, 16),
@@ -530,23 +522,9 @@ build_dgc_prepare_shader(struct radv_device *dev)
             nir_push_if(&b,
                         nir_ior(&b, nir_ieq_imm(&b, num_records, 0), nir_ieq_imm(&b, buf_va, 0)));
             {
-               nir_ssa_def *use_dynamic_vertex_input =
-                  nir_test_mask(&b, load_param8(&b, vbo_cnt), DGC_DYNAMIC_VERTEX_INPUT);
-
-               nir_push_if(&b, use_dynamic_vertex_input);
-               {
-                  nir_ssa_def *new_vbo_data[4] = {
-                     nir_imm_int(&b, 0), nir_imm_int(&b, S_008F04_STRIDE(16)), nir_imm_int(&b, 0),
-                     nir_channel(&b, nir_load_var(&b, vbo_data), 3)};
-                  nir_store_var(&b, vbo_data, nir_vec(&b, new_vbo_data, 4), 0xf);
-               }
-               nir_push_else(&b, NULL);
-               {
-                  nir_ssa_def *new_vbo_data[4] = {nir_imm_int(&b, 0), nir_imm_int(&b, 0),
-                                                  nir_imm_int(&b, 0), nir_imm_int(&b, 0)};
-                  nir_store_var(&b, vbo_data, nir_vec(&b, new_vbo_data, 4), 0xf);
-               }
-               nir_pop_if(&b, NULL);
+               nir_ssa_def *new_vbo_data[4] = {nir_imm_int(&b, 0), nir_imm_int(&b, 0),
+                                               nir_imm_int(&b, 0), nir_imm_int(&b, 0)};
+               nir_store_var(&b, vbo_data, nir_vec(&b, new_vbo_data, 4), 0xf);
             }
             nir_pop_if(&b, NULL);
 
@@ -1208,36 +1186,21 @@ radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer,
 
       uint32_t *vbo_info = (uint32_t *)((char *)upload_data + graphics_pipeline->vb_desc_alloc_size);
 
-      struct radv_shader *vs_shader = radv_get_shader(&graphics_pipeline->base, MESA_SHADER_VERTEX);
-      const struct radv_vs_input_state *vs_state =
-         vs_shader->info.vs.dynamic_inputs ? &cmd_buffer->state.dynamic_vs_input : NULL;
       uint32_t mask = graphics_pipeline->vb_desc_usage_mask;
       unsigned idx = 0;
       while (mask) {
          unsigned i = u_bit_scan(&mask);
-
-         if (vs_state && !(vs_state->attribute_mask & BITFIELD_BIT(i))) {
-            /* No vertex attribute description given: assume that the shader doesn't use this
-             * location (vb_desc_usage_mask can be larger than attribute usage).
-             */
-            ++idx;
-            continue;
-         }
-
          unsigned binding =
-            vs_state ? cmd_buffer->state.dynamic_vs_input.bindings[i]
-                     : (graphics_pipeline->use_per_attribute_vb_descs ? graphics_pipeline->attrib_bindings[i] : i);
-         uint32_t attrib_end =
-            vs_state ? vs_state->offsets[i] + vs_state->format_sizes[i] : graphics_pipeline->attrib_ends[i];
+            graphics_pipeline->use_per_attribute_vb_descs ? graphics_pipeline->attrib_bindings[i] : i;
+         uint32_t attrib_end = graphics_pipeline->attrib_ends[i];
 
          params.vbo_bind_mask |= ((layout->bind_vbo_mask >> binding) & 1u) << idx;
          vbo_info[2 * idx] = ((graphics_pipeline->use_per_attribute_vb_descs ? 1u : 0u) << 31) |
-                             (vs_state ? vs_state->offsets[i] << 16 : 0) |
                              layout->vbo_offsets[binding];
          vbo_info[2 * idx + 1] = graphics_pipeline->attrib_index_offset[i] | (attrib_end << 16);
          ++idx;
       }
-      params.vbo_cnt = idx | (vs_state ? DGC_DYNAMIC_VERTEX_INPUT : 0);
+      params.vbo_cnt = idx;
       upload_data = (char *)upload_data + vb_size;
    }
 
-- 
GitLab


From 006afcfeab10e4861318d4c253ac3de5f1a0736c Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 7 Sep 2022 15:58:59 +0100
Subject: [PATCH 3/4] radv: use nir_ubfe_imm

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../vulkan/radv_device_generated_commands.c   | 22 +++++++++----------
 1 file changed, 10 insertions(+), 12 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 4ec10518e3b6..b28b7c23d7c2 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -208,18 +208,18 @@ dgc_emit(nir_builder *b, struct dgc_cmdbuf *cs, nir_ssa_def *value)
                           .base = offsetof(struct radv_dgc_params, field), .range = 4)
 
 #define load_param16(b, field)                                                                     \
-   nir_ubfe(                                                                                       \
+   nir_ubfe_imm(                                                                                   \
       (b),                                                                                         \
       nir_load_push_constant((b), 1, 32, nir_imm_int((b), 0),                                      \
                              .base = (offsetof(struct radv_dgc_params, field) & ~3), .range = 4),  \
-      nir_imm_int((b), (offsetof(struct radv_dgc_params, field) & 2) * 8), nir_imm_int((b), 16))
+      (offsetof(struct radv_dgc_params, field) & 2) * 8, 16)
 
 #define load_param8(b, field)                                                                      \
-   nir_ubfe(                                                                                       \
+   nir_ubfe_imm(                                                                                   \
       (b),                                                                                         \
       nir_load_push_constant((b), 1, 32, nir_imm_int((b), 0),                                      \
                              .base = (offsetof(struct radv_dgc_params, field) & ~3), .range = 4),  \
-      nir_imm_int((b), (offsetof(struct radv_dgc_params, field) & 3) * 8), nir_imm_int((b), 8))
+      (offsetof(struct radv_dgc_params, field) & 3) * 8, 8)
 
 #define load_param64(b, field)                                                                     \
    nir_pack_64_2x32((b), nir_load_push_constant((b), 2, 32, nir_imm_int((b), 0),                   \
@@ -422,8 +422,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
 
                nir_ssa_def *dyn_stride = nir_test_mask(&b, nir_channel(&b, vbo_over_data, 0), DGC_DYNAMIC_STRIDE);
                nir_ssa_def *old_stride =
-                  nir_ubfe(&b, nir_channel(&b, nir_load_var(&b, vbo_data), 1), nir_imm_int(&b, 16),
-                           nir_imm_int(&b, 14));
+                  nir_ubfe_imm(&b, nir_channel(&b, nir_load_var(&b, vbo_data), 1), 16, 14);
                stride = nir_bcsel(&b, dyn_stride, stride, old_stride);
 
                nir_ssa_def *use_per_attribute_vb_descs =
@@ -434,11 +433,10 @@ build_dgc_prepare_shader(struct radv_device *dev)
 
                nir_push_if(&b, use_per_attribute_vb_descs);
                {
-                  nir_ssa_def *attrib_end = nir_ubfe(&b, nir_channel(&b, vbo_over_data, 1),
-                                                     nir_imm_int(&b, 16), nir_imm_int(&b, 16));
+                  nir_ssa_def *attrib_end = nir_ubfe_imm(&b, nir_channel(&b, vbo_over_data, 1), 16,
+                                                         16);
                   nir_ssa_def *attrib_index_offset =
-                     nir_ubfe(&b, nir_channel(&b, vbo_over_data, 1), nir_imm_int(&b, 0),
-                              nir_imm_int(&b, 16));
+                     nir_ubfe_imm(&b, nir_channel(&b, vbo_over_data, 1), 0, 16);
 
                   nir_push_if(&b, nir_ult(&b, nir_load_var(&b, num_records), attrib_end));
                   {
@@ -621,8 +619,8 @@ build_dgc_prepare_shader(struct radv_device *dev)
             nir_pop_if(&b, NULL);
 
             nir_ssa_def *reg_info = nir_load_ssbo(&b, 3, 32, param_buf, nir_iadd(&b, param_offset, nir_imul_imm(&b, cur_shader_idx, 12)), .align_mul = 4);
-            nir_ssa_def *upload_sgpr = nir_ubfe(&b, nir_channel(&b, reg_info, 0), nir_imm_int(&b, 0), nir_imm_int(&b, 16));
-            nir_ssa_def *inline_sgpr = nir_ubfe(&b, nir_channel(&b, reg_info, 0), nir_imm_int(&b, 16), nir_imm_int(&b, 16));
+            nir_ssa_def *upload_sgpr = nir_ubfe_imm(&b, nir_channel(&b, reg_info, 0), 0, 16);
+            nir_ssa_def *inline_sgpr = nir_ubfe_imm(&b, nir_channel(&b, reg_info, 0), 16, 16);
             nir_ssa_def *inline_mask = nir_pack_64_2x32(&b, nir_channels(&b, reg_info, 0x6));
 
             nir_push_if(&b, nir_ine_imm(&b, upload_sgpr, 0));
-- 
GitLab


From d546284ce7340265b62ca547ac0363761a27aa46 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 7 Sep 2022 16:04:33 +0100
Subject: [PATCH 4/4] radv: remove unnecessary .align_mul=4

The builders can pick a default using the component size.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../vulkan/radv_device_generated_commands.c   | 37 +++++++++----------
 1 file changed, 17 insertions(+), 20 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index b28b7c23d7c2..e8fea2294cc2 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -349,7 +349,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
    nir_push_if(&b, nir_ieq_imm(&b, sequence_count, UINT32_MAX));
    {
       nir_ssa_def *count_buf = radv_meta_load_descriptor(&b, 0, DGC_DESC_COUNT);
-      nir_ssa_def *cnt = nir_load_ssbo(&b, 1, 32, count_buf, nir_imm_int(&b, 0), .align_mul = 4);
+      nir_ssa_def *cnt = nir_load_ssbo(&b, 1, 32, count_buf, nir_imm_int(&b, 0));
       nir_store_var(&b, count_var, cnt, 0x1);
    }
    nir_pop_if(&b, NULL);
@@ -397,7 +397,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
 
             nir_ssa_def *param_buf = radv_meta_load_descriptor(&b, 0, DGC_DESC_PARAMS);
             nir_store_var(&b, vbo_data,
-                          nir_load_ssbo(&b, 4, 32, param_buf, vbo_offset, .align_mul = 4), 0xf);
+                          nir_load_ssbo(&b, 4, 32, param_buf, vbo_offset), 0xf);
 
             nir_ssa_def *vbo_override =
                nir_ine_imm(&b,
@@ -410,11 +410,11 @@ build_dgc_prepare_shader(struct radv_device *dev)
                   nir_iadd(&b, nir_imul_imm(&b, vbo_cnt, 16),
                            nir_imul_imm(&b, nir_load_var(&b, vbo_idx), 8));
                nir_ssa_def *vbo_over_data =
-                  nir_load_ssbo(&b, 2, 32, param_buf, vbo_offset_offset, .align_mul = 4);
+                  nir_load_ssbo(&b, 2, 32, param_buf, vbo_offset_offset);
                nir_ssa_def *stream_offset = nir_iadd(
                   &b, stream_base, nir_iand_imm(&b, nir_channel(&b, vbo_over_data, 0), 0x7FFF));
                nir_ssa_def *stream_data =
-                  nir_load_ssbo(&b, 4, 32, stream_buf, stream_offset, .align_mul = 4);
+                  nir_load_ssbo(&b, 4, 32, stream_buf, stream_offset);
 
                nir_ssa_def *va = nir_pack_64_2x32(&b, nir_channels(&b, stream_data, 0x3));
                nir_ssa_def *size = nir_channel(&b, stream_data, 2);
@@ -580,8 +580,8 @@ build_dgc_prepare_shader(struct radv_device *dev)
             {
                nir_ssa_def *stream_offset = nir_load_ssbo(
                   &b, 1, 32, param_buf,
-                  nir_iadd(&b, param_offset_offset, nir_ishl_imm(&b, cur_idx, 2)), .align_mul = 4);
-               nir_ssa_def *new_data = nir_load_ssbo(&b, 1, 32, stream_buf, nir_iadd(&b, stream_base, stream_offset), .align_mul = 4);
+                  nir_iadd(&b, param_offset_offset, nir_ishl_imm(&b, cur_idx, 2)));
+               nir_ssa_def *new_data = nir_load_ssbo(&b, 1, 32, stream_buf, nir_iadd(&b, stream_base, stream_offset));
                nir_store_var(&b, data, new_data, 0x1);
             }
             nir_push_else(&b, NULL);
@@ -589,8 +589,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
                nir_store_var(
                   &b, data,
                   nir_load_ssbo(&b, 1, 32, param_buf,
-                                nir_iadd(&b, param_const_offset, nir_ishl_imm(&b, cur_idx, 2)),
-                                .align_mul = 4),
+                                nir_iadd(&b, param_const_offset, nir_ishl_imm(&b, cur_idx, 2))),
                   0x1);
             }
             nir_pop_if(&b, NULL);
@@ -618,7 +617,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
             }
             nir_pop_if(&b, NULL);
 
-            nir_ssa_def *reg_info = nir_load_ssbo(&b, 3, 32, param_buf, nir_iadd(&b, param_offset, nir_imul_imm(&b, cur_shader_idx, 12)), .align_mul = 4);
+            nir_ssa_def *reg_info = nir_load_ssbo(&b, 3, 32, param_buf, nir_iadd(&b, param_offset, nir_imul_imm(&b, cur_shader_idx, 12)));
             nir_ssa_def *upload_sgpr = nir_ubfe_imm(&b, nir_channel(&b, reg_info, 0), 0, 16);
             nir_ssa_def *inline_sgpr = nir_ubfe_imm(&b, nir_channel(&b, reg_info, 0), 16, 16);
             nir_ssa_def *inline_mask = nir_pack_64_2x32(&b, nir_channels(&b, reg_info, 0x6));
@@ -676,9 +675,8 @@ build_dgc_prepare_shader(struct radv_device *dev)
                   {
                      nir_ssa_def *stream_offset = nir_load_ssbo(
                         &b, 1, 32, param_buf,
-                        nir_iadd(&b, param_offset_offset, nir_ishl_imm(&b, cur_idx, 2)),
-                        .align_mul = 4);
-                     nir_ssa_def *new_data = nir_load_ssbo(&b, 1, 32, stream_buf, nir_iadd(&b, stream_base, stream_offset), .align_mul = 4);
+                        nir_iadd(&b, param_offset_offset, nir_ishl_imm(&b, cur_idx, 2)));
+                     nir_ssa_def *new_data = nir_load_ssbo(&b, 1, 32, stream_buf, nir_iadd(&b, stream_base, stream_offset));
                      nir_store_var(&b, data, new_data, 0x1);
                   }
                   nir_push_else(&b, NULL);
@@ -686,8 +684,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
                      nir_store_var(&b, data,
                                    nir_load_ssbo(&b, 1, 32, param_buf,
                                                  nir_iadd(&b, param_const_offset,
-                                                          nir_ishl_imm(&b, cur_idx, 2)),
-                                                 .align_mul = 4),
+                                                          nir_ishl_imm(&b, cur_idx, 2))),
                                    0x1);
                   }
                   nir_pop_if(&b, NULL);
@@ -708,7 +705,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
       nir_push_if(&b, nir_ieq_imm(&b, load_param16(&b, emit_state), 1));
       {
          nir_ssa_def *stream_offset = nir_iadd(&b, load_param16(&b, state_offset), stream_base);
-         nir_ssa_def *state = nir_load_ssbo(&b, 1, 32, stream_buf, stream_offset, .align_mul = 4);
+         nir_ssa_def *state = nir_load_ssbo(&b, 1, 32, stream_buf, stream_offset);
          state = nir_iand_imm(&b, state, 1);
 
          nir_ssa_def *reg =
@@ -741,7 +738,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
 
             nir_ssa_def *param_buf = radv_meta_load_descriptor(&b, 0, DGC_DESC_PARAMS);
             nir_ssa_def *param_offset = nir_iadd(&b, scissor_offset, nir_imul_imm(&b, cur_idx, 4));
-            nir_ssa_def *value = nir_load_ssbo(&b, 1, 32, param_buf, param_offset, .align_mul = 4);
+            nir_ssa_def *value = nir_load_ssbo(&b, 1, 32, param_buf, param_offset);
 
             dgc_emit(&b, &cmd_buf, value);
 
@@ -758,7 +755,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
             nir_iadd(&b, load_param16(&b, draw_params_offset), stream_base);
 
          nir_ssa_def *draw_data0 =
-            nir_load_ssbo(&b, 4, 32, stream_buf, stream_offset, .align_mul = 4);
+            nir_load_ssbo(&b, 4, 32, stream_buf, stream_offset);
          nir_ssa_def *vertex_count = nir_channel(&b, draw_data0, 0);
          nir_ssa_def *instance_count = nir_channel(&b, draw_data0, 1);
          nir_ssa_def *vertex_offset = nir_channel(&b, draw_data0, 2);
@@ -787,7 +784,7 @@ build_dgc_prepare_shader(struct radv_device *dev)
             nir_ssa_def *index_stream_offset =
                nir_iadd(&b, load_param16(&b, index_buffer_offset), stream_base);
             nir_ssa_def *data =
-               nir_load_ssbo(&b, 4, 32, stream_buf, index_stream_offset, .align_mul = 4);
+               nir_load_ssbo(&b, 4, 32, stream_buf, index_stream_offset);
 
             nir_ssa_def *vk_index_type = nir_channel(&b, data, 3);
             nir_ssa_def *index_type = nir_bcsel(
@@ -845,9 +842,9 @@ build_dgc_prepare_shader(struct radv_device *dev)
          max_index_count = nir_bcsel(&b, bind_index_buffer, nir_load_var(&b, max_index_count_var),
                                      max_index_count);
          nir_ssa_def *draw_data0 =
-            nir_load_ssbo(&b, 4, 32, stream_buf, stream_offset, .align_mul = 4);
+            nir_load_ssbo(&b, 4, 32, stream_buf, stream_offset);
          nir_ssa_def *draw_data1 = nir_load_ssbo(
-            &b, 1, 32, stream_buf, nir_iadd_imm(&b, stream_offset, 16), .align_mul = 4);
+            &b, 1, 32, stream_buf, nir_iadd_imm(&b, stream_offset, 16));
          nir_ssa_def *index_count = nir_channel(&b, draw_data0, 0);
          nir_ssa_def *instance_count = nir_channel(&b, draw_data0, 1);
          nir_ssa_def *first_index = nir_channel(&b, draw_data0, 2);
-- 
GitLab

