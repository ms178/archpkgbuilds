From c8121d196c3cda801d52a43542d1e1500cb1192e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Feb 2024 21:06:30 -0500
Subject: [PATCH 01/12] amd/registers: add correct gfx11.x enums for
 BINNING_MODE

---
 src/amd/registers/gfx11.json              |  4 ++--
 src/amd/registers/gfx115.json             |  3 +--
 src/amd/registers/parse_kernel_headers.py | 25 ++++++++++++++++++++++-
 3 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/src/amd/registers/gfx11.json b/src/amd/registers/gfx11.json
index 5f8fc95d02908..23d5d82d00799 100644
--- a/src/amd/registers/gfx11.json
+++ b/src/amd/registers/gfx11.json
@@ -20,8 +20,8 @@
    "entries": [
     {"name": "BINNING_ALLOWED", "value": 0},
     {"name": "FORCE_BINNING_ON", "value": 1},
-    {"name": "DISABLE_BINNING_USE_NEW_SC", "value": 2},
-    {"name": "DISABLE_BINNING_USE_LEGACY_SC", "value": 3}
+    {"name": "BINNING_ONE_PRIM_PER_BATCH", "value": 2},
+    {"name": "BINNING_DISABLED", "value": 3}
    ]
   },
   "BlendOp": {
diff --git a/src/amd/registers/gfx115.json b/src/amd/registers/gfx115.json
index 03f320a7fa6eb..20e0f2c64f2a7 100644
--- a/src/amd/registers/gfx115.json
+++ b/src/amd/registers/gfx115.json
@@ -20,8 +20,7 @@
    "entries": [
     {"name": "BINNING_ALLOWED", "value": 0},
     {"name": "FORCE_BINNING_ON", "value": 1},
-    {"name": "DISABLE_BINNING_USE_NEW_SC", "value": 2},
-    {"name": "DISABLE_BINNING_USE_LEGACY_SC", "value": 3}
+    {"name": "BINNING_DISABLED", "value": 3}
    ]
   },
   "BlendOp": {
diff --git a/src/amd/registers/parse_kernel_headers.py b/src/amd/registers/parse_kernel_headers.py
index 79e0f00fd0f40..2da746c858998 100644
--- a/src/amd/registers/parse_kernel_headers.py
+++ b/src/amd/registers/parse_kernel_headers.py
@@ -444,6 +444,23 @@ VRSHtileEncoding = {
  ]
 }
 
+BinningModeGfx11 = {
+ "entries": [
+  {"name": "BINNING_ALLOWED", "value": 0},
+  {"name": "FORCE_BINNING_ON", "value": 1},
+  {"name": "BINNING_ONE_PRIM_PER_BATCH", "value": 2},
+  {"name": "BINNING_DISABLED", "value": 3}
+ ]
+}
+
+BinningModeGfx115Plus = {
+ "entries": [
+  {"name": "BINNING_ALLOWED", "value": 0},
+  {"name": "FORCE_BINNING_ON", "value": 1},
+  {"name": "BINNING_DISABLED", "value": 3}
+ ]
+}
+
 missing_enums_all = {
   'FLOAT_MODE': {
     "entries": [
@@ -669,6 +686,11 @@ missing_enums_gfx11plus = {
   },
 }
 
+missing_enums_gfx115plus = {
+  **missing_enums_gfx11plus,
+  "BinningMode": BinningModeGfx115Plus,
+}
+
 enums_missing = {
   'gfx6': {
     **missing_enums_all,
@@ -704,9 +726,10 @@ enums_missing = {
   },
   'gfx11': {
     **missing_enums_gfx11plus,
+    "BinningMode": BinningModeGfx11,
   },
   'gfx115': {
-    **missing_enums_gfx11plus,
+    **missing_enums_gfx115plus,
   },
 }
 
-- 
GitLab


From ee0f06e2218bfde5a2c05cbfe7a74fce7d21ab8b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Feb 2024 21:08:51 -0500
Subject: [PATCH 02/12] radeonsi: disable binning correctly on gfx11.5

---
 src/gallium/drivers/radeonsi/si_state_binning.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_binning.c b/src/gallium/drivers/radeonsi/si_state_binning.c
index 39a97ebd0ce02..984586eb8647a 100644
--- a/src/gallium/drivers/radeonsi/si_state_binning.c
+++ b/src/gallium/drivers/radeonsi/si_state_binning.c
@@ -393,6 +393,9 @@ static void si_emit_dpbb_disable(struct si_context *sctx)
    if (sctx->gfx_level >= GFX10) {
       struct uvec2 bin_size = {};
       struct uvec2 bin_size_extend = {};
+      unsigned binning_disabled =
+         sctx->gfx_level >= GFX11_5 ? V_028C44_BINNING_DISABLED
+                                    : V_028C44_DISABLE_BINNING_USE_NEW_SC;
 
       bin_size.x = 128;
       bin_size.y = sctx->framebuffer.min_bytes_per_pixel <= 4 ? 128 : 64;
@@ -404,7 +407,7 @@ static void si_emit_dpbb_disable(struct si_context *sctx)
 
       radeon_opt_set_context_reg(sctx, R_028C44_PA_SC_BINNER_CNTL_0,
                                  SI_TRACKED_PA_SC_BINNER_CNTL_0,
-                                 S_028C44_BINNING_MODE(V_028C44_DISABLE_BINNING_USE_NEW_SC) |
+                                 S_028C44_BINNING_MODE(binning_disabled) |
                                  S_028C44_BIN_SIZE_X(bin_size.x == 16) |
                                  S_028C44_BIN_SIZE_Y(bin_size.y == 16) |
                                  S_028C44_BIN_SIZE_X_EXTEND(bin_size_extend.x) |
-- 
GitLab


From 9d99aafec7d18702855b03dc717b94cccdfe27f7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 27 Feb 2024 17:48:22 -0500
Subject: [PATCH 03/12] radeonsi/gfx11: fix programming of
 PA_SC_BINNER_CNTL_1.MAX_ALLOC_COUNT

---
 src/gallium/drivers/radeonsi/si_state.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index f7fb8ffbe92f1..464fcf6b716b2 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -6416,8 +6416,10 @@ static void gfx10_init_gfx_preamble_state(struct si_context *sctx)
                      S_028B50_DONUT_SPLIT_GFX9(24) |
                      S_028B50_TRAP_SPLIT(6));
 
+   /* GFX11+ shouldn't subtract 1 from pbb_max_alloc_count.  */
+   unsigned gfx10_one = sctx->gfx_level < GFX11;
    si_pm4_set_reg(pm4, R_028C48_PA_SC_BINNER_CNTL_1,
-                  S_028C48_MAX_ALLOC_COUNT(sscreen->info.pbb_max_alloc_count - 1) |
+                  S_028C48_MAX_ALLOC_COUNT(sscreen->info.pbb_max_alloc_count - gfx10_one) |
                   S_028C48_MAX_PRIM_PER_BATCH(1023));
 
    if (sctx->gfx_level >= GFX11_5)
-- 
GitLab


From 45b2f3ccbafc414829cd2e6f915d9de299f3751d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 27 Feb 2024 19:47:46 -0500
Subject: [PATCH 04/12] radeonsi/gfx10.3: add a GPU hang workaround for legacy
 tess+GS

---
 src/gallium/drivers/radeonsi/si_state.h           | 2 +-
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 9 +++++++++
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index 3f7c8c64e4fa0..ae4e9b584aab0 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -342,7 +342,7 @@ enum si_tracked_reg
 
    /* The slots below can be reused by other generations. */
    SI_TRACKED_VGT_ESGS_RING_ITEMSIZE,        /* GFX6-8 (GFX9+ can reuse this slot) */
-   SI_TRACKED_VGT_REUSE_OFF,                 /* GFX6-8 (GFX9+ can reuse this slot) */
+   SI_TRACKED_VGT_REUSE_OFF,                 /* GFX6-8,10.3 */
    SI_TRACKED_IA_MULTI_VGT_PARAM,            /* GFX6-8 (GFX9+ can reuse this slot) */
 
    SI_TRACKED_VGT_GS_MAX_PRIMS_PER_SUBGROUP, /* GFX9 - the slots above can be reused */
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index bd5c3e0bae025..a011186d2e461 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -4350,6 +4350,15 @@ static void si_emit_vgt_pipeline_state(struct si_context *sctx, unsigned index)
    radeon_begin(cs);
    radeon_opt_set_context_reg(sctx, R_028B54_VGT_SHADER_STAGES_EN, SI_TRACKED_VGT_SHADER_STAGES_EN,
                               sctx->vgt_shader_stages_en);
+   if (sctx->gfx_level == GFX10_3) {
+      /* Legacy Tess+GS should disable reuse to prevent hangs on GFX10.3. */
+      bool has_legacy_tess_gs = G_028B54_HS_EN(sctx->vgt_shader_stages_en) &&
+                                G_028B54_GS_EN(sctx->vgt_shader_stages_en) &&
+                                !G_028B54_PRIMGEN_EN(sctx->vgt_shader_stages_en); /* !NGG */
+
+      radeon_opt_set_context_reg(sctx, R_028AB4_VGT_REUSE_OFF, SI_TRACKED_VGT_REUSE_OFF,
+                                 S_028AB4_REUSE_OFF(has_legacy_tess_gs));
+   }
    radeon_end_update_context_roll(sctx);
 
    if (sctx->gfx_level >= GFX10) {
-- 
GitLab


From a319b8a9fa7cc640debe7b10cca6e461d741b10e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 27 Feb 2024 17:07:30 -0500
Subject: [PATCH 05/12] radeonsi: allocate only one set of tessellation rings
 per device

Move them to si_screen. The "has_tessellation" context flag indicates that
the screen has valid tess rings, so that we don't have to lock the mutex
to check whether the rings are valid.
---
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  7 +-
 src/gallium/drivers/radeonsi/si_pipe.c        |  6 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |  7 +-
 .../drivers/radeonsi/si_state_draw.cpp        |  4 +-
 .../drivers/radeonsi/si_state_shaders.cpp     | 91 +++++++++++--------
 5 files changed, 68 insertions(+), 47 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index 40276919c983a..ea493836ce8f5 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -92,7 +92,7 @@ void si_flush_gfx_cs(struct si_context *ctx, unsigned flags, struct pipe_fence_h
    /* If we use s_sendmsg to set tess factors to all 0 or all 1 instead of writing to the tess
     * factor buffer, we need this at the end of command buffers:
     */
-   if ((ctx->gfx_level == GFX11 || ctx->gfx_level == GFX11_5) && ctx->tess_rings) {
+   if ((ctx->gfx_level == GFX11 || ctx->gfx_level == GFX11_5) && ctx->has_tessellation) {
       radeon_begin(cs);
       radeon_emit(PKT3(PKT3_EVENT_WRITE, 0, 0));
       radeon_emit(EVENT_TYPE(V_028A90_SQ_NON_EVENT) | EVENT_INDEX(0));
@@ -447,9 +447,10 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
       return;
    }
 
-   if (ctx->tess_rings) {
+   if (ctx->has_tessellation) {
       radeon_add_to_buffer_list(ctx, &ctx->gfx_cs,
-                                unlikely(is_secure) ? si_resource(ctx->tess_rings_tmz) : si_resource(ctx->tess_rings),
+                                unlikely(is_secure) ? si_resource(ctx->screen->tess_rings_tmz)
+                                                    : si_resource(ctx->screen->tess_rings),
                                 RADEON_USAGE_READWRITE | RADEON_PRIO_SHADER_RINGS);
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 3433385cf5464..78be8186fbd7e 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -223,8 +223,6 @@ static void si_destroy_context(struct pipe_context *context)
 
    pipe_resource_reference(&sctx->esgs_ring, NULL);
    pipe_resource_reference(&sctx->gsvs_ring, NULL);
-   pipe_resource_reference(&sctx->tess_rings, NULL);
-   pipe_resource_reference(&sctx->tess_rings_tmz, NULL);
    pipe_resource_reference(&sctx->null_const_buf.buffer, NULL);
    pipe_resource_reference(&sctx->sample_pos_buffer, NULL);
    si_resource_reference(&sctx->border_color_buffer, NULL);
@@ -974,6 +972,8 @@ static void si_destroy_screen(struct pipe_screen *pscreen)
    }
 
    si_resource_reference(&sscreen->attribute_ring, NULL);
+   pipe_resource_reference(&sscreen->tess_rings, NULL);
+   pipe_resource_reference(&sscreen->tess_rings_tmz, NULL);
 
    util_queue_destroy(&sscreen->shader_compiler_queue);
    util_queue_destroy(&sscreen->shader_compiler_queue_opt_variants);
@@ -1031,6 +1031,7 @@ static void si_destroy_screen(struct pipe_screen *pscreen)
 
    simple_mtx_destroy(&sscreen->gpu_load_mutex);
    simple_mtx_destroy(&sscreen->gds_mutex);
+   simple_mtx_destroy(&sscreen->tess_ring_lock);
 
    radeon_bo_reference(sscreen->ws, &sscreen->gds_oa, NULL);
 
@@ -1277,6 +1278,7 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
    (void)simple_mtx_init(&sscreen->async_compute_context_lock, mtx_plain);
    (void)simple_mtx_init(&sscreen->gpu_load_mutex, mtx_plain);
    (void)simple_mtx_init(&sscreen->gds_mutex, mtx_plain);
+   (void)simple_mtx_init(&sscreen->tess_ring_lock, mtx_plain);
 
    si_init_gs_info(sscreen);
    if (!si_init_shader_cache(sscreen)) {
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 8a94fe97a81ec..384f6de691ee1 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -712,6 +712,10 @@ struct si_screen {
 
    struct si_resource *attribute_ring;
 
+   simple_mtx_t tess_ring_lock;
+   struct pipe_resource *tess_rings;
+   struct pipe_resource *tess_rings_tmz;
+
    /* NGG streamout. */
    simple_mtx_t gds_mutex;
    struct pb_buffer_lean *gds_oa;
@@ -1129,6 +1133,7 @@ struct si_context {
    bool vs_uses_base_instance;
    bool vs_uses_draw_id;
    uint8_t patch_vertices;
+   bool has_tessellation; /* whether si_screen::tess_rings* are valid */
 
    /* shader descriptors */
    struct si_descriptors descriptors[SI_NUM_DESCS];
@@ -1147,8 +1152,6 @@ struct si_context {
    struct pipe_constant_buffer null_const_buf; /* used for set_constant_buffer(NULL) on GFX7 */
    struct pipe_resource *esgs_ring;
    struct pipe_resource *gsvs_ring;
-   struct pipe_resource *tess_rings;
-   struct pipe_resource *tess_rings_tmz;
    union pipe_color_union *border_color_table; /* in CPU memory, any endian */
    struct si_resource *border_color_buffer;
    union pipe_color_union *border_color_map; /* in VRAM (slow access), little endian */
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 95b6201c2167b..6660f7c6c1125 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -52,9 +52,9 @@ static bool si_update_shaders(struct si_context *sctx)
 
    /* Update TCS and TES. */
    if (HAS_TESS) {
-      if (!sctx->tess_rings) {
+      if (!sctx->has_tessellation) {
          si_init_tess_factor_ring(sctx);
-         if (!sctx->tess_rings)
+         if (!sctx->has_tessellation)
             return false;
       }
 
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index a011186d2e461..9708a7b09260a 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -4239,42 +4239,55 @@ bool si_update_spi_tmpring_size(struct si_context *sctx, unsigned bytes)
 
 void si_init_tess_factor_ring(struct si_context *sctx)
 {
-   assert(!sctx->tess_rings);
+   struct si_screen *sscreen = sctx->screen;
+   assert(!sctx->has_tessellation);
 
-   /* The address must be aligned to 2^19, because the shader only
-    * receives the high 13 bits. Align it to 2MB to match the GPU page size.
-    */
-   sctx->tess_rings = pipe_aligned_buffer_create(sctx->b.screen,
-                                                 PIPE_RESOURCE_FLAG_UNMAPPABLE |
-                                                 SI_RESOURCE_FLAG_32BIT |
-                                                 SI_RESOURCE_FLAG_DRIVER_INTERNAL |
-                                                 SI_RESOURCE_FLAG_DISCARDABLE,
-                                                 PIPE_USAGE_DEFAULT,
-                                                 sctx->screen->hs.tess_offchip_ring_size +
-                                                 sctx->screen->hs.tess_factor_ring_size,
-                                                 2 * 1024 * 1024);
-   if (!sctx->tess_rings)
+   if (sctx->has_tessellation)
       return;
 
-   if (sctx->screen->info.has_tmz_support) {
-      sctx->tess_rings_tmz = pipe_aligned_buffer_create(sctx->b.screen,
-                                                        PIPE_RESOURCE_FLAG_UNMAPPABLE |
-                                                        PIPE_RESOURCE_FLAG_ENCRYPTED |
-                                                        SI_RESOURCE_FLAG_32BIT |
-                                                        SI_RESOURCE_FLAG_DRIVER_INTERNAL |
-                                                        SI_RESOURCE_FLAG_DISCARDABLE,
-                                                        PIPE_USAGE_DEFAULT,
-                                                        sctx->screen->hs.tess_offchip_ring_size +
-                                                        sctx->screen->hs.tess_factor_ring_size,
-                                                        2 * 1024 * 1024);
+   simple_mtx_lock(&sscreen->tess_ring_lock);
+
+   if (!sscreen->tess_rings) {
+      /* The address must be aligned to 2^19, because the shader only
+       * receives the high 13 bits. Align it to 2MB to match the GPU page size.
+       */
+      sscreen->tess_rings = pipe_aligned_buffer_create(sctx->b.screen,
+                                                       PIPE_RESOURCE_FLAG_UNMAPPABLE |
+                                                       SI_RESOURCE_FLAG_32BIT |
+                                                       SI_RESOURCE_FLAG_DRIVER_INTERNAL |
+                                                       SI_RESOURCE_FLAG_DISCARDABLE,
+                                                       PIPE_USAGE_DEFAULT,
+                                                       sscreen->hs.tess_offchip_ring_size +
+                                                       sscreen->hs.tess_factor_ring_size,
+                                                       2 * 1024 * 1024);
+      if (!sscreen->tess_rings) {
+         simple_mtx_unlock(&sscreen->tess_ring_lock);
+         return;
+      }
+
+      if (sscreen->info.has_tmz_support) {
+         sscreen->tess_rings_tmz = pipe_aligned_buffer_create(sctx->b.screen,
+                                                              PIPE_RESOURCE_FLAG_UNMAPPABLE |
+                                                              PIPE_RESOURCE_FLAG_ENCRYPTED |
+                                                              SI_RESOURCE_FLAG_32BIT |
+                                                              SI_RESOURCE_FLAG_DRIVER_INTERNAL |
+                                                              SI_RESOURCE_FLAG_DISCARDABLE,
+                                                              PIPE_USAGE_DEFAULT,
+                                                              sscreen->hs.tess_offchip_ring_size +
+                                                              sscreen->hs.tess_factor_ring_size,
+                                                              2 * 1024 * 1024);
+      }
    }
 
-   uint64_t factor_va =
-      si_resource(sctx->tess_rings)->gpu_address + sctx->screen->hs.tess_offchip_ring_size;
+   simple_mtx_unlock(&sscreen->tess_ring_lock);
+   sctx->has_tessellation = true;
+
+   uint64_t factor_va = si_resource(sscreen->tess_rings)->gpu_address +
+                        sscreen->hs.tess_offchip_ring_size;
 
-   unsigned tf_ring_size_field = sctx->screen->hs.tess_factor_ring_size / 4;
+   unsigned tf_ring_size_field = sscreen->hs.tess_factor_ring_size / 4;
    if (sctx->gfx_level >= GFX11)
-      tf_ring_size_field /= sctx->screen->info.max_se;
+      tf_ring_size_field /= sscreen->info.max_se;
 
    assert((tf_ring_size_field & C_030938_SIZE) == 0);
 
@@ -4285,7 +4298,7 @@ void si_init_tess_factor_ring(struct si_context *sctx)
 
       assert(sctx->gfx_level >= GFX7);
 
-      radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, si_resource(sctx->tess_rings),
+      radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, si_resource(sscreen->tess_rings),
                                 RADEON_USAGE_READWRITE | RADEON_PRIO_SHADER_RINGS);
       si_emit_vgt_flush(cs);
 
@@ -4302,7 +4315,7 @@ void si_init_tess_factor_ring(struct si_context *sctx)
                                 S_030944_BASE_HI(factor_va >> 40));
       }
       radeon_set_uconfig_reg(R_03093C_VGT_HS_OFFCHIP_PARAM,
-                             sctx->screen->hs.hs_offchip_param);
+                             sscreen->hs.hs_offchip_param);
       radeon_end();
       return;
    }
@@ -4311,18 +4324,18 @@ void si_init_tess_factor_ring(struct si_context *sctx)
    /* Add these registers to cs_preamble_state. */
    for (unsigned tmz = 0; tmz <= 1; tmz++) {
       struct si_pm4_state *pm4 = tmz ? sctx->cs_preamble_state_tmz : sctx->cs_preamble_state;
-      struct pipe_resource *tf_ring = tmz ? sctx->tess_rings_tmz : sctx->tess_rings;
+      struct pipe_resource *tf_ring = tmz ? sscreen->tess_rings_tmz : sscreen->tess_rings;
 
       if (!tf_ring)
          continue; /* TMZ not supported */
 
-      uint64_t va = si_resource(tf_ring)->gpu_address + sctx->screen->hs.tess_offchip_ring_size;
+      uint64_t va = si_resource(tf_ring)->gpu_address + sscreen->hs.tess_offchip_ring_size;
 
       si_cs_preamble_add_vgt_flush(sctx, tmz);
 
       if (sctx->gfx_level >= GFX7) {
          si_pm4_set_reg(pm4, R_030938_VGT_TF_RING_SIZE, S_030938_SIZE(tf_ring_size_field));
-         si_pm4_set_reg(pm4, R_03093C_VGT_HS_OFFCHIP_PARAM, sctx->screen->hs.hs_offchip_param);
+         si_pm4_set_reg(pm4, R_03093C_VGT_HS_OFFCHIP_PARAM, sscreen->hs.hs_offchip_param);
          si_pm4_set_reg(pm4, R_030940_VGT_TF_MEMORY_BASE, va >> 8);
          if (sctx->gfx_level >= GFX10)
             si_pm4_set_reg(pm4, R_030984_VGT_TF_MEMORY_BASE_HI, S_030984_BASE_HI(va >> 40));
@@ -4331,7 +4344,7 @@ void si_init_tess_factor_ring(struct si_context *sctx)
       } else {
          si_pm4_set_reg(pm4, R_008988_VGT_TF_RING_SIZE, S_008988_SIZE(tf_ring_size_field));
          si_pm4_set_reg(pm4, R_0089B8_VGT_TF_MEMORY_BASE, factor_va >> 8);
-         si_pm4_set_reg(pm4, R_0089B0_VGT_HS_OFFCHIP_PARAM, sctx->screen->hs.hs_offchip_param);
+         si_pm4_set_reg(pm4, R_0089B0_VGT_HS_OFFCHIP_PARAM, sscreen->hs.hs_offchip_param);
       }
       si_pm4_finalize(pm4);
    }
@@ -4481,7 +4494,7 @@ static void si_set_patch_vertices(struct pipe_context *ctx, uint8_t patch_vertic
          /* Update the io layout now if possible,
           * otherwise make sure it's done by si_update_shaders.
           */
-         if (sctx->tess_rings)
+         if (sctx->has_tessellation)
             si_update_tess_io_layout_state(sctx);
          else
             sctx->do_update_shaders = true;
@@ -4654,8 +4667,10 @@ void si_update_tess_io_layout_state(struct si_context *sctx)
    assert(num_patches <= 64);
    assert(((pervertex_output_patch_size * num_patches) & ~0xffff) == 0);
 
-   uint64_t ring_va = (unlikely(sctx->ws->cs_is_secure(&sctx->gfx_cs)) ?
-      si_resource(sctx->tess_rings_tmz) : si_resource(sctx->tess_rings))->gpu_address;
+   uint64_t ring_va =
+      sctx->ws->cs_is_secure(&sctx->gfx_cs) ?
+          si_resource(sctx->screen->tess_rings_tmz)->gpu_address :
+          si_resource(sctx->screen->tess_rings)->gpu_address;
    assert((ring_va & u_bit_consecutive(0, 19)) == 0);
 
    sctx->tes_offchip_ring_va_sgpr = ring_va;
-- 
GitLab


From bbc6e115fdd4cc5a5cc0382ed44d8d011ebd71ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 27 Feb 2024 16:18:13 -0500
Subject: [PATCH 06/12] radeonsi/gfx11: program the attribute ring right before
 draws

This way, we only wait for idle right before draw packets,
so that all preceding SET packets can be processed in parallel
with draws from the previous IB.

Add a new state atom that is emitted last. It only contains code for gfx11,
but some code for older chips will be added by the next commit.
---
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  1 +
 src/gallium/drivers/radeonsi/si_state.c       | 40 ----------------
 src/gallium/drivers/radeonsi/si_state.h       |  1 +
 .../drivers/radeonsi/si_state_shaders.cpp     | 47 +++++++++++++++++++
 4 files changed, 49 insertions(+), 40 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index ea493836ce8f5..f4e93d8b4ecdf 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -411,6 +411,7 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
       ctx->flags |= SI_CONTEXT_VGT_FLUSH;
 
    si_mark_atom_dirty(ctx, &ctx->atoms.s.cache_flush);
+   si_mark_atom_dirty(ctx, &ctx->atoms.s.spi_ge_ring_state);
 
    if (ctx->screen->attribute_ring) {
       radeon_add_to_buffer_list(ctx, &ctx->gfx_cs, ctx->screen->attribute_ring,
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 464fcf6b716b2..7f0a4c500d782 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -6467,46 +6467,6 @@ static void gfx10_init_gfx_preamble_state(struct si_context *sctx)
                           PIXEL_PIPE_STATE_CNTL_STRIDE(2) |
                           PIXEL_PIPE_STATE_CNTL_INSTANCE_EN_LO(rb_mask));
       si_pm4_cmd_add(pm4, PIXEL_PIPE_STATE_CNTL_INSTANCE_EN_HI(rb_mask));
-
-      /* We must wait for idle using an EOP event before changing the attribute ring registers.
-       * Use the bottom-of-pipe EOP event, but increment the PWS counter instead of writing memory.
-       */
-      si_pm4_cmd_add(pm4, PKT3(PKT3_RELEASE_MEM, 6, 0));
-      si_pm4_cmd_add(pm4, S_490_EVENT_TYPE(V_028A90_BOTTOM_OF_PIPE_TS) |
-                          S_490_EVENT_INDEX(5) |
-                          S_490_PWS_ENABLE(1));
-      si_pm4_cmd_add(pm4, 0); /* DST_SEL, INT_SEL, DATA_SEL */
-      si_pm4_cmd_add(pm4, 0); /* ADDRESS_LO */
-      si_pm4_cmd_add(pm4, 0); /* ADDRESS_HI */
-      si_pm4_cmd_add(pm4, 0); /* DATA_LO */
-      si_pm4_cmd_add(pm4, 0); /* DATA_HI */
-      si_pm4_cmd_add(pm4, 0); /* INT_CTXID */
-
-      /* Wait for the PWS counter. */
-      si_pm4_cmd_add(pm4, PKT3(PKT3_ACQUIRE_MEM, 6, 0));
-      si_pm4_cmd_add(pm4, S_580_PWS_STAGE_SEL(V_580_CP_ME) |
-                          S_580_PWS_COUNTER_SEL(V_580_TS_SELECT) |
-                          S_580_PWS_ENA2(1) |
-                          S_580_PWS_COUNT(0));
-      si_pm4_cmd_add(pm4, 0xffffffff); /* GCR_SIZE */
-      si_pm4_cmd_add(pm4, 0x01ffffff); /* GCR_SIZE_HI */
-      si_pm4_cmd_add(pm4, 0); /* GCR_BASE_LO */
-      si_pm4_cmd_add(pm4, 0); /* GCR_BASE_HI */
-      si_pm4_cmd_add(pm4, S_585_PWS_ENA(1));
-      si_pm4_cmd_add(pm4, 0); /* GCR_CNTL */
-
-      si_pm4_set_reg(pm4, R_031110_SPI_GS_THROTTLE_CNTL1, 0x12355123);
-      si_pm4_set_reg(pm4, R_031114_SPI_GS_THROTTLE_CNTL2, 0x1544D);
-
-      assert((sscreen->attribute_ring->gpu_address >> 32) == sscreen->info.address32_hi);
-
-      /* The PS will read inputs from this address. */
-      si_pm4_set_reg(pm4, R_031118_SPI_ATTRIBUTE_RING_BASE,
-                     sscreen->attribute_ring->gpu_address >> 16);
-      si_pm4_set_reg(pm4, R_03111C_SPI_ATTRIBUTE_RING_SIZE,
-                     S_03111C_MEM_SIZE((sscreen->info.attribute_ring_size_per_se >> 16) - 1) |
-                     S_03111C_BIG_PAGE(sscreen->info.discardable_allows_big_page) |
-                     S_03111C_L1_POLICY(1));
    }
 
 done:
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index ae4e9b584aab0..c9e923d665d3a 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -237,6 +237,7 @@ union si_state_atoms {
       struct si_atom cache_flush;
       struct si_atom streamout_begin; /* this must be done after cache_flush */
       struct si_atom render_cond; /* this must be after cache_flush */
+      struct si_atom spi_ge_ring_state; /* this must be last because it waits for idle. */
    } s;
    struct si_atom array[sizeof(struct si_atoms_s) / sizeof(struct si_atom)];
 };
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 9708a7b09260a..099bad05b05d2 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -4870,11 +4870,58 @@ static void si_emit_spi_map(struct si_context *sctx, unsigned index)
    radeon_end_update_context_roll(sctx);
 }
 
+static void si_emit_spi_ge_ring_state(struct si_context *sctx, unsigned index)
+{
+   struct si_screen *sscreen = sctx->screen;
+
+   if (sctx->gfx_level >= GFX11) {
+      radeon_begin(&sctx->gfx_cs);
+      /* We must wait for idle using an EOP event before changing the attribute ring registers.
+       * Use the bottom-of-pipe EOP event, but increment the PWS counter instead of writing memory.
+       */
+      radeon_emit(PKT3(PKT3_RELEASE_MEM, 6, 0));
+      radeon_emit(S_490_EVENT_TYPE(V_028A90_BOTTOM_OF_PIPE_TS) |
+                  S_490_EVENT_INDEX(5) |
+                  S_490_PWS_ENABLE(1));
+      radeon_emit(0); /* DST_SEL, INT_SEL, DATA_SEL */
+      radeon_emit(0); /* ADDRESS_LO */
+      radeon_emit(0); /* ADDRESS_HI */
+      radeon_emit(0); /* DATA_LO */
+      radeon_emit(0); /* DATA_HI */
+      radeon_emit(0); /* INT_CTXID */
+
+      /* Wait for the PWS counter. */
+      radeon_emit(PKT3(PKT3_ACQUIRE_MEM, 6, 0));
+      radeon_emit(S_580_PWS_STAGE_SEL(V_580_CP_ME) |
+                  S_580_PWS_COUNTER_SEL(V_580_TS_SELECT) |
+                  S_580_PWS_ENA2(1) |
+                  S_580_PWS_COUNT(0));
+      radeon_emit(0xffffffff); /* GCR_SIZE */
+      radeon_emit(0x01ffffff); /* GCR_SIZE_HI */
+      radeon_emit(0); /* GCR_BASE_LO */
+      radeon_emit(0); /* GCR_BASE_HI */
+      radeon_emit(S_585_PWS_ENA(1));
+      radeon_emit(0); /* GCR_CNTL */
+
+      assert((sscreen->attribute_ring->gpu_address >> 32) == sscreen->info.address32_hi);
+
+      radeon_set_uconfig_reg_seq(R_031110_SPI_GS_THROTTLE_CNTL1, 4);
+      radeon_emit(0x12355123);      /* SPI_GS_THROTTLE_CNTL1 */
+      radeon_emit(0x1544D);         /* SPI_GS_THROTTLE_CNTL2 */
+      radeon_emit(sscreen->attribute_ring->gpu_address >> 16); /* SPI_ATTRIBUTE_RING_BASE */
+      radeon_emit(S_03111C_MEM_SIZE((sscreen->info.attribute_ring_size_per_se >> 16) - 1) |
+                  S_03111C_BIG_PAGE(sscreen->info.discardable_allows_big_page) |
+                  S_03111C_L1_POLICY(1)); /* SPI_ATTRIBUTE_RING_SIZE */
+      radeon_end();
+   }
+}
+
 void si_init_shader_functions(struct si_context *sctx)
 {
    sctx->atoms.s.vgt_pipeline_state.emit = si_emit_vgt_pipeline_state;
    sctx->atoms.s.scratch_state.emit = si_emit_scratch_state;
    sctx->atoms.s.tess_io_layout.emit = si_emit_tess_io_layout_state;
+   sctx->atoms.s.spi_ge_ring_state.emit = si_emit_spi_ge_ring_state;
 
    sctx->b.create_vs_state = si_create_shader;
    sctx->b.create_tcs_state = si_create_shader;
-- 
GitLab


From 81db138e055e7ac48d246fd3e623f4ac7b259924 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 27 Feb 2024 17:23:39 -0500
Subject: [PATCH 07/12] radeonsi: program tessellation rings right before draws

so that we only wait for idle right before draw packets and all preceding
SET packets can be processed in parallel with draws from the previous IB.

This way we also don't need to update the preamble and flush the context
just to emit the preamble. It's a normal state now.

Use the new state atom that is emitted last.
---
 .../drivers/radeonsi/si_state_shaders.cpp     | 114 +++++++-----------
 1 file changed, 42 insertions(+), 72 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 099bad05b05d2..1577ef1dfb3f5 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -4282,78 +4282,7 @@ void si_init_tess_factor_ring(struct si_context *sctx)
    simple_mtx_unlock(&sscreen->tess_ring_lock);
    sctx->has_tessellation = true;
 
-   uint64_t factor_va = si_resource(sscreen->tess_rings)->gpu_address +
-                        sscreen->hs.tess_offchip_ring_size;
-
-   unsigned tf_ring_size_field = sscreen->hs.tess_factor_ring_size / 4;
-   if (sctx->gfx_level >= GFX11)
-      tf_ring_size_field /= sscreen->info.max_se;
-
-   assert((tf_ring_size_field & C_030938_SIZE) == 0);
-
-   if (sctx->shadowing.registers) {
-      /* These registers will be shadowed, so set them only once. */
-      /* TODO: tmz + shadowed_regs support */
-      struct radeon_cmdbuf *cs = &sctx->gfx_cs;
-
-      assert(sctx->gfx_level >= GFX7);
-
-      radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, si_resource(sscreen->tess_rings),
-                                RADEON_USAGE_READWRITE | RADEON_PRIO_SHADER_RINGS);
-      si_emit_vgt_flush(cs);
-
-      /* Set tessellation registers. */
-      radeon_begin(cs);
-      radeon_set_uconfig_reg(R_030938_VGT_TF_RING_SIZE,
-                             S_030938_SIZE(tf_ring_size_field));
-      radeon_set_uconfig_reg(R_030940_VGT_TF_MEMORY_BASE, factor_va >> 8);
-      if (sctx->gfx_level >= GFX10) {
-         radeon_set_uconfig_reg(R_030984_VGT_TF_MEMORY_BASE_HI,
-                                S_030984_BASE_HI(factor_va >> 40));
-      } else if (sctx->gfx_level == GFX9) {
-         radeon_set_uconfig_reg(R_030944_VGT_TF_MEMORY_BASE_HI,
-                                S_030944_BASE_HI(factor_va >> 40));
-      }
-      radeon_set_uconfig_reg(R_03093C_VGT_HS_OFFCHIP_PARAM,
-                             sscreen->hs.hs_offchip_param);
-      radeon_end();
-      return;
-   }
-
-   /* The codepath without register shadowing is below. */
-   /* Add these registers to cs_preamble_state. */
-   for (unsigned tmz = 0; tmz <= 1; tmz++) {
-      struct si_pm4_state *pm4 = tmz ? sctx->cs_preamble_state_tmz : sctx->cs_preamble_state;
-      struct pipe_resource *tf_ring = tmz ? sscreen->tess_rings_tmz : sscreen->tess_rings;
-
-      if (!tf_ring)
-         continue; /* TMZ not supported */
-
-      uint64_t va = si_resource(tf_ring)->gpu_address + sscreen->hs.tess_offchip_ring_size;
-
-      si_cs_preamble_add_vgt_flush(sctx, tmz);
-
-      if (sctx->gfx_level >= GFX7) {
-         si_pm4_set_reg(pm4, R_030938_VGT_TF_RING_SIZE, S_030938_SIZE(tf_ring_size_field));
-         si_pm4_set_reg(pm4, R_03093C_VGT_HS_OFFCHIP_PARAM, sscreen->hs.hs_offchip_param);
-         si_pm4_set_reg(pm4, R_030940_VGT_TF_MEMORY_BASE, va >> 8);
-         if (sctx->gfx_level >= GFX10)
-            si_pm4_set_reg(pm4, R_030984_VGT_TF_MEMORY_BASE_HI, S_030984_BASE_HI(va >> 40));
-         else if (sctx->gfx_level == GFX9)
-            si_pm4_set_reg(pm4, R_030944_VGT_TF_MEMORY_BASE_HI, S_030944_BASE_HI(va >> 40));
-      } else {
-         si_pm4_set_reg(pm4, R_008988_VGT_TF_RING_SIZE, S_008988_SIZE(tf_ring_size_field));
-         si_pm4_set_reg(pm4, R_0089B8_VGT_TF_MEMORY_BASE, factor_va >> 8);
-         si_pm4_set_reg(pm4, R_0089B0_VGT_HS_OFFCHIP_PARAM, sscreen->hs.hs_offchip_param);
-      }
-      si_pm4_finalize(pm4);
-   }
-
-   /* Flush the context to re-emit the cs_preamble state.
-    * This is done only once in a lifetime of a context.
-    */
-   sctx->initial_gfx_cs_size = 0; /* force flush */
-   si_flush_gfx_cs(sctx, RADEON_FLUSH_ASYNC_START_NEXT_GFX_IB_NOW, NULL);
+   si_mark_atom_dirty(sctx, &sctx->atoms.s.spi_ge_ring_state);
 }
 
 static void si_emit_vgt_pipeline_state(struct si_context *sctx, unsigned index)
@@ -4874,6 +4803,47 @@ static void si_emit_spi_ge_ring_state(struct si_context *sctx, unsigned index)
 {
    struct si_screen *sscreen = sctx->screen;
 
+   if (sctx->has_tessellation) {
+      struct pipe_resource *tf_ring =
+         sctx->ws->cs_is_secure(&sctx->gfx_cs) ? sscreen->tess_rings_tmz : sscreen->tess_rings;
+      uint64_t factor_va = si_resource(tf_ring)->gpu_address +
+                           sscreen->hs.tess_offchip_ring_size;
+
+      unsigned tf_ring_size_field = sscreen->hs.tess_factor_ring_size / 4;
+      if (sctx->gfx_level >= GFX11)
+         tf_ring_size_field /= sscreen->info.max_se;
+
+      assert((tf_ring_size_field & C_030938_SIZE) == 0);
+
+      radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, si_resource(tf_ring),
+                                RADEON_USAGE_READWRITE | RADEON_PRIO_SHADER_RINGS);
+
+      radeon_begin(&sctx->gfx_cs);
+      /* Required before writing tessellation config registers. */
+      radeon_emit(PKT3(PKT3_EVENT_WRITE, 0, 0));
+      radeon_emit(EVENT_TYPE(V_028A90_VS_PARTIAL_FLUSH) | EVENT_INDEX(4));
+
+      radeon_emit(PKT3(PKT3_EVENT_WRITE, 0, 0));
+      radeon_emit(EVENT_TYPE(V_028A90_VGT_FLUSH) | EVENT_INDEX(0));
+
+      if (sctx->gfx_level >= GFX7) {
+         radeon_set_uconfig_reg_seq(R_030938_VGT_TF_RING_SIZE, 3);
+         radeon_emit(S_030938_SIZE(tf_ring_size_field)); /* R_030938_VGT_TF_RING_SIZE */
+         radeon_emit(sscreen->hs.hs_offchip_param);      /* R_03093C_VGT_HS_OFFCHIP_PARAM */
+         radeon_emit(factor_va >> 8);                           /* R_030940_VGT_TF_MEMORY_BASE */
+
+         if (sctx->gfx_level >= GFX10)
+            radeon_set_uconfig_reg(R_030984_VGT_TF_MEMORY_BASE_HI, S_030984_BASE_HI(factor_va >> 40));
+         else if (sctx->gfx_level == GFX9)
+            radeon_set_uconfig_reg(R_030944_VGT_TF_MEMORY_BASE_HI, S_030944_BASE_HI(factor_va >> 40));
+      } else {
+         radeon_set_uconfig_reg(R_008988_VGT_TF_RING_SIZE, S_008988_SIZE(tf_ring_size_field));
+         radeon_set_uconfig_reg(R_0089B8_VGT_TF_MEMORY_BASE, factor_va >> 8);
+         radeon_set_uconfig_reg(R_0089B0_VGT_HS_OFFCHIP_PARAM, sscreen->hs.hs_offchip_param);
+      }
+      radeon_end();
+   }
+
    if (sctx->gfx_level >= GFX11) {
       radeon_begin(&sctx->gfx_cs);
       /* We must wait for idle using an EOP event before changing the attribute ring registers.
-- 
GitLab


From 5b5f39895aacd38105bfc782fd47471f81acee81 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 29 Feb 2024 11:40:25 -0500
Subject: [PATCH 08/12] radeonsi/gfx11: program SAMPLE_MASK_TRACKER_WATERMARK
 optimally for APUs

---
 src/gallium/drivers/radeonsi/si_state.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 7f0a4c500d782..da85ab9755cd6 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -93,8 +93,9 @@ static void si_emit_cb_render_state(struct si_context *sctx, unsigned index)
          blend->dcc_msaa_corruption_4bit & cb_target_mask && sctx->framebuffer.nr_samples >= 2;
 
       if (sctx->gfx_level >= GFX11) {
-         cb_dcc_control = S_028424_SAMPLE_MASK_TRACKER_DISABLE(oc_disable) |
-                          S_028424_SAMPLE_MASK_TRACKER_WATERMARK(0);
+         cb_dcc_control =
+            S_028424_SAMPLE_MASK_TRACKER_DISABLE(oc_disable) |
+            S_028424_SAMPLE_MASK_TRACKER_WATERMARK(sctx->screen->info.has_dedicated_vram ? 0 : 15);
       } else {
          cb_dcc_control =
             S_028424_OVERWRITE_COMBINER_MRT_SHARING_DISABLE(sctx->gfx_level <= GFX9) |
-- 
GitLab


From 99b1645dc029b17cb5a243b052c96e6feede2e34 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 29 Feb 2024 15:03:58 -0500
Subject: [PATCH 09/12] ac: use the gfx11 shadowed register tables for gfx11.5

---
 src/amd/common/ac_shadowed_regs.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/common/ac_shadowed_regs.c b/src/amd/common/ac_shadowed_regs.c
index 46f12842df14b..cacc46a4ca225 100644
--- a/src/amd/common/ac_shadowed_regs.c
+++ b/src/amd/common/ac_shadowed_regs.c
@@ -732,7 +732,7 @@ void ac_get_reg_ranges(enum amd_gfx_level gfx_level, enum radeon_family family,
 
    switch (type) {
    case SI_REG_RANGE_UCONFIG:
-      if (gfx_level == GFX11)
+      if (gfx_level == GFX11 || gfx_level == GFX11_5)
          RETURN(Gfx11UserConfigShadowRange);
       else if (gfx_level == GFX10_3)
          RETURN(Gfx103UserConfigShadowRange);
@@ -742,7 +742,7 @@ void ac_get_reg_ranges(enum amd_gfx_level gfx_level, enum radeon_family family,
          RETURN(Gfx9UserConfigShadowRange);
       break;
    case SI_REG_RANGE_CONTEXT:
-      if (gfx_level == GFX11)
+      if (gfx_level == GFX11 || gfx_level == GFX11_5)
          RETURN(Gfx11ContextShadowRange);
       else if (gfx_level == GFX10_3)
          RETURN(Gfx103ContextShadowRange);
@@ -752,7 +752,7 @@ void ac_get_reg_ranges(enum amd_gfx_level gfx_level, enum radeon_family family,
          RETURN(Gfx9ContextShadowRange);
       break;
    case SI_REG_RANGE_SH:
-      if (gfx_level == GFX11)
+      if (gfx_level == GFX11 || gfx_level == GFX11_5)
          RETURN(Gfx11ShShadowRange);
       else if (gfx_level == GFX10_3 || gfx_level == GFX10)
          RETURN(Gfx10ShShadowRange);
@@ -762,7 +762,7 @@ void ac_get_reg_ranges(enum amd_gfx_level gfx_level, enum radeon_family family,
          RETURN(Gfx9ShShadowRange);
       break;
    case SI_REG_RANGE_CS_SH:
-      if (gfx_level == GFX11)
+      if (gfx_level == GFX11 || gfx_level == GFX11_5)
          RETURN(Gfx11CsShShadowRange);
       else if (gfx_level == GFX10_3 || gfx_level == GFX10)
          RETURN(Gfx10CsShShadowRange);
@@ -3498,7 +3498,7 @@ void ac_emulate_clear_state(const struct radeon_info *info, struct radeon_cmdbuf
    unsigned reg_offset = R_02835C_PA_SC_TILE_STEERING_OVERRIDE;
    uint32_t reg_value = info->pa_sc_tile_steering_override;
 
-   if (info->gfx_level >= GFX11) {
+   if (info->gfx_level == GFX11 || info->gfx_level == GFX11_5) {
       gfx11_emulate_clear_state(cs, 1, &reg_offset, &reg_value, set_context_reg_seq_array);
    } else if (info->gfx_level == GFX10_3) {
       gfx103_emulate_clear_state(cs, 1, &reg_offset, &reg_value, set_context_reg_seq_array);
-- 
GitLab


From 69bef7fa75c9b08cf38b02282bdfa369b5080b9a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 29 Feb 2024 19:50:46 -0500
Subject: [PATCH 10/12] radeonsi/gfx11: add missing DCC_RD_POLICY setting

---
 src/gallium/drivers/radeonsi/si_state.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index da85ab9755cd6..30b0cb0ea1368 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -6364,6 +6364,7 @@ static void gfx10_init_gfx_preamble_state(struct si_context *sctx)
                   (sctx->gfx_level >= GFX11 ?
                       S_028410_DCC_WR_POLICY_GFX11(meta_write_policy) |
                       S_028410_COLOR_WR_POLICY_GFX11(V_028410_CACHE_STREAM) |
+                      S_028410_DCC_RD_POLICY(meta_read_policy) |
                       S_028410_COLOR_RD_POLICY(V_028410_CACHE_NOA_GFX11)
                     :
                       S_028410_CMASK_WR_POLICY(meta_write_policy) |
@@ -6373,7 +6374,7 @@ static void gfx10_init_gfx_preamble_state(struct si_context *sctx)
                       S_028410_CMASK_RD_POLICY(meta_read_policy) |
                       S_028410_FMASK_RD_POLICY(V_028410_CACHE_NOA_GFX10) |
                       S_028410_COLOR_RD_POLICY(V_028410_CACHE_NOA_GFX10)) |
-                  S_028410_DCC_RD_POLICY(meta_read_policy));
+                      S_028410_DCC_RD_POLICY(meta_read_policy));
    si_pm4_set_reg(pm4, R_028708_SPI_SHADER_IDX_FORMAT,
                   S_028708_IDX0_EXPORT_FORMAT(V_028708_SPI_SHADER_1COMP));
 
-- 
GitLab


From 5987ccdcfbdc80245e85640eed05334c8adba14f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 29 Feb 2024 20:10:02 -0500
Subject: [PATCH 11/12] radeonsi: add radeonsi_cache_rb_gl2 option enabling GL2
 caching for CB and DB

for perf testing
---
 .../drivers/radeonsi/si_debug_options.h       |  1 +
 src/gallium/drivers/radeonsi/si_state.c       | 60 ++++++++++++-------
 2 files changed, 39 insertions(+), 22 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_debug_options.h b/src/gallium/drivers/radeonsi/si_debug_options.h
index 270904361cf55..8ba03d8179b74 100644
--- a/src/gallium/drivers/radeonsi/si_debug_options.h
+++ b/src/gallium/drivers/radeonsi/si_debug_options.h
@@ -21,6 +21,7 @@ OPT_BOOL(force_use_fma32, false, "Force use fma32 instruction for GPU family new
 OPT_BOOL(dcc_msaa, false, "Enable DCC for MSAA")
 OPT_BOOL(zerovram, false, "Zero all VRAM allocations")
 OPT_BOOL(clear_lds, false, "Clear LDS at the end of shaders. Might decrease performance.")
+OPT_BOOL(cache_rb_gl2, false, "Enable GL2 caching for CB and DB.")
 
 #undef OPT_BOOL
 #undef OPT_INT
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 30b0cb0ea1368..70926b35f6757 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -6219,16 +6219,32 @@ static void gfx10_init_gfx_preamble_state(struct si_context *sctx)
       sctx->border_color_buffer ? sctx->border_color_buffer->gpu_address : 0;
    uint32_t compute_cu_en = S_00B858_SH0_CU_EN(sscreen->info.spi_cu_en) |
                             S_00B858_SH1_CU_EN(sscreen->info.spi_cu_en);
-   unsigned meta_write_policy, meta_read_policy;
-   unsigned no_alloc = sctx->gfx_level >= GFX11 ? V_02807C_CACHE_NOA_GFX11:
-                                                  V_02807C_CACHE_NOA_GFX10;
-   /* Enable CMASK/HTILE/DCC caching in L2 for small chips. */
-   if (sscreen->info.max_render_backends <= 4) {
-      meta_write_policy = V_02807C_CACHE_LRU_WR; /* cache writes */
-      meta_read_policy = V_02807C_CACHE_LRU_RD;  /* cache reads */
+   unsigned meta_write_policy, meta_read_policy, color_write_policy, color_read_policy;
+   unsigned zs_write_policy, zs_read_policy;
+   unsigned cache_no_alloc = sctx->gfx_level >= GFX11 ? V_02807C_CACHE_NOA_GFX11:
+                                                        V_02807C_CACHE_NOA_GFX10;
+
+   if (sscreen->options.cache_rb_gl2) {
+      color_write_policy = V_028410_CACHE_LRU_WR;
+      color_read_policy = V_028410_CACHE_LRU_RD;
+      zs_write_policy = V_02807C_CACHE_LRU_WR;
+      zs_read_policy = V_02807C_CACHE_LRU_RD;
+      meta_write_policy = V_02807C_CACHE_LRU_WR;
+      meta_read_policy = V_02807C_CACHE_LRU_RD;
    } else {
-      meta_write_policy = V_02807C_CACHE_STREAM; /* write combine */
-      meta_read_policy = no_alloc; /* don't cache reads that miss */
+      color_write_policy = V_028410_CACHE_STREAM;
+      color_read_policy = cache_no_alloc;
+      zs_write_policy = V_02807C_CACHE_STREAM;
+      zs_read_policy = cache_no_alloc;
+
+      /* Enable CMASK/HTILE/DCC caching in L2 for small chips. */
+      if (sscreen->info.max_render_backends <= 4) {
+         meta_write_policy = V_02807C_CACHE_LRU_WR; /* cache writes */
+         meta_read_policy = V_02807C_CACHE_LRU_RD;  /* cache reads */
+      } else {
+         meta_write_policy = V_02807C_CACHE_STREAM; /* write combine */
+         meta_read_policy = cache_no_alloc; /* don't cache reads that miss */
+      }
    }
 
    /* We need more space because the preamble is large. */
@@ -6350,30 +6366,30 @@ static void gfx10_init_gfx_preamble_state(struct si_context *sctx)
       si_pm4_set_reg(pm4, R_028038_DB_DFSM_CONTROL, S_028038_PUNCHOUT_MODE(V_028038_FORCE_OFF));
    }
    si_pm4_set_reg(pm4, R_02807C_DB_RMI_L2_CACHE_CONTROL,
-                  S_02807C_Z_WR_POLICY(V_02807C_CACHE_STREAM) |
-                  S_02807C_S_WR_POLICY(V_02807C_CACHE_STREAM) |
+                  S_02807C_Z_WR_POLICY(zs_write_policy) |
+                  S_02807C_S_WR_POLICY(zs_write_policy) |
                   S_02807C_HTILE_WR_POLICY(meta_write_policy) |
-                  S_02807C_ZPCPSD_WR_POLICY(V_02807C_CACHE_STREAM) |
-                  S_02807C_Z_RD_POLICY(no_alloc) |
-                  S_02807C_S_RD_POLICY(no_alloc) |
+                  S_02807C_ZPCPSD_WR_POLICY(V_02807C_CACHE_STREAM) | /* occlusion query writes */
+                  S_02807C_Z_RD_POLICY(zs_read_policy) |
+                  S_02807C_S_RD_POLICY(zs_read_policy) |
                   S_02807C_HTILE_RD_POLICY(meta_read_policy));
    si_pm4_set_reg(pm4, R_028080_TA_BC_BASE_ADDR, border_color_va >> 8);
    si_pm4_set_reg(pm4, R_028084_TA_BC_BASE_ADDR_HI, S_028084_ADDRESS(border_color_va >> 40));
 
    si_pm4_set_reg(pm4, R_028410_CB_RMI_GL2_CACHE_CONTROL,
                   (sctx->gfx_level >= GFX11 ?
+                      S_028410_COLOR_WR_POLICY_GFX11(color_write_policy) |
+                      S_028410_COLOR_RD_POLICY(color_read_policy) |
                       S_028410_DCC_WR_POLICY_GFX11(meta_write_policy) |
-                      S_028410_COLOR_WR_POLICY_GFX11(V_028410_CACHE_STREAM) |
-                      S_028410_DCC_RD_POLICY(meta_read_policy) |
-                      S_028410_COLOR_RD_POLICY(V_028410_CACHE_NOA_GFX11)
+                      S_028410_DCC_RD_POLICY(meta_read_policy)
                     :
+                      S_028410_COLOR_WR_POLICY_GFX10(color_write_policy) |
+                      S_028410_COLOR_RD_POLICY(color_read_policy)) |
+                      S_028410_FMASK_WR_POLICY(color_write_policy) |
+                      S_028410_FMASK_RD_POLICY(color_read_policy) |
                       S_028410_CMASK_WR_POLICY(meta_write_policy) |
-                      S_028410_FMASK_WR_POLICY(V_028410_CACHE_STREAM) |
-                      S_028410_DCC_WR_POLICY_GFX10(meta_write_policy) |
-                      S_028410_COLOR_WR_POLICY_GFX10(V_028410_CACHE_STREAM) |
                       S_028410_CMASK_RD_POLICY(meta_read_policy) |
-                      S_028410_FMASK_RD_POLICY(V_028410_CACHE_NOA_GFX10) |
-                      S_028410_COLOR_RD_POLICY(V_028410_CACHE_NOA_GFX10)) |
+                      S_028410_DCC_WR_POLICY_GFX10(meta_write_policy) |
                       S_028410_DCC_RD_POLICY(meta_read_policy));
    si_pm4_set_reg(pm4, R_028708_SPI_SHADER_IDX_FORMAT,
                   S_028708_IDX0_EXPORT_FORMAT(V_028708_SPI_SHADER_1COMP));
-- 
GitLab


From 175ab09036ae5de493777622c17e30661ce51e9e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 23 Jan 2024 20:16:51 +0800
Subject: [PATCH 12/12] radeonsi: split RADEON_USAGE_NEEDS_IMPLICIT_SYNC into
 CB and DB flags

it will be required in the future

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_compute.c  | 10 ++++++----
 src/gallium/drivers/radeonsi/si_gfx_cs.c   |  1 +
 src/gallium/drivers/radeonsi/si_pipe.h     |  2 ++
 src/gallium/drivers/radeonsi/si_state.c    |  8 ++++----
 src/gallium/include/winsys/radeon_winsys.h |  9 +++++----
 5 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index e7964601a84cc..cdbeea64cf50c 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -897,7 +897,7 @@ static void si_emit_dispatch_packets(struct si_context *sctx, const struct pipe_
    radeon_end();
 }
 
-static bool si_check_needs_implicit_sync(struct si_context *sctx)
+static bool si_check_needs_implicit_sync(struct si_context *sctx, bool is_db)
 {
    /* If the compute shader is going to read from a texture/image written by a
     * previous draw, we must wait for its completion before continuing.
@@ -921,7 +921,8 @@ static bool si_check_needs_implicit_sync(struct si_context *sctx)
 
       struct si_resource *res = si_resource(sview->base.texture);
       if (sctx->ws->cs_is_buffer_referenced(&sctx->gfx_cs, res->buf,
-                                            RADEON_USAGE_NEEDS_IMPLICIT_SYNC))
+                                            is_db ? RADEON_USAGE_DB_NEEDS_IMPLICIT_SYNC :
+                                            RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC))
          return true;
    }
 
@@ -934,7 +935,8 @@ static bool si_check_needs_implicit_sync(struct si_context *sctx)
 
       struct si_resource *res = si_resource(sview->resource);
       if (sctx->ws->cs_is_buffer_referenced(&sctx->gfx_cs, res->buf,
-                                            RADEON_USAGE_NEEDS_IMPLICIT_SYNC))
+                                            is_db ? RADEON_USAGE_DB_NEEDS_IMPLICIT_SYNC :
+                                            RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC))
          return true;
    }
    return false;
@@ -965,7 +967,7 @@ static void si_launch_grid(struct pipe_context *ctx, const struct pipe_grid_info
          si_update_fb_dirtiness_after_rendering(sctx);
          sctx->last_num_draw_calls = sctx->num_draw_calls;
 
-         if (sctx->force_cb_shader_coherent || si_check_needs_implicit_sync(sctx))
+         if (sctx->force_cb_shader_coherent || si_check_needs_implicit_sync(sctx, false))
             si_make_CB_shader_coherent(sctx, 0,
                                        sctx->framebuffer.CB_has_shader_readable_metadata,
                                        sctx->framebuffer.all_DCC_pipe_aligned);
diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index f4e93d8b4ecdf..0ea069b2dca25 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -585,6 +585,7 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
     * si_make_CB_shader_coherent.
     */
    ctx->force_cb_shader_coherent = true;
+   ctx->force_db_shader_coherent = true;
 }
 
 void si_trace_emit(struct si_context *sctx)
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 384f6de691ee1..c1a74c79a51a1 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -1353,6 +1353,7 @@ struct si_context {
    unsigned num_active_shader_queries;
 
    bool force_cb_shader_coherent;
+   bool force_db_shader_coherent;
 
    struct si_tracked_regs tracked_regs;
 
@@ -1918,6 +1919,7 @@ static inline void si_make_DB_shader_coherent(struct si_context *sctx, unsigned
                                               bool include_stencil, bool shaders_read_metadata)
 {
    sctx->flags |= SI_CONTEXT_FLUSH_AND_INV_DB | SI_CONTEXT_INV_VCACHE;
+   sctx->force_db_shader_coherent = false;
 
    if (sctx->gfx_level >= GFX10) {
       if (sctx->screen->info.tcc_rb_non_coherent)
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 70926b35f6757..b44123c17151a 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -3341,12 +3341,12 @@ static void si_emit_framebuffer_state(struct si_context *sctx, unsigned index)
 
       tex = (struct si_texture *)cb->base.texture;
       radeon_add_to_buffer_list(
-         sctx, &sctx->gfx_cs, &tex->buffer, RADEON_USAGE_READWRITE | RADEON_USAGE_NEEDS_IMPLICIT_SYNC |
+         sctx, &sctx->gfx_cs, &tex->buffer, RADEON_USAGE_READWRITE | RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC |
          (tex->buffer.b.b.nr_samples > 1 ? RADEON_PRIO_COLOR_BUFFER_MSAA : RADEON_PRIO_COLOR_BUFFER));
 
       if (tex->cmask_buffer && tex->cmask_buffer != &tex->buffer) {
          radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, tex->cmask_buffer,
-                                   RADEON_USAGE_READWRITE | RADEON_USAGE_NEEDS_IMPLICIT_SYNC |
+                                   RADEON_USAGE_READWRITE | RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC |
                                    RADEON_PRIO_SEPARATE_META);
       }
 
@@ -3799,12 +3799,12 @@ static void gfx11_dgpu_emit_framebuffer_state(struct si_context *sctx, unsigned
 
       tex = (struct si_texture *)cb->base.texture;
       radeon_add_to_buffer_list(
-         sctx, &sctx->gfx_cs, &tex->buffer, RADEON_USAGE_READWRITE | RADEON_USAGE_NEEDS_IMPLICIT_SYNC |
+         sctx, &sctx->gfx_cs, &tex->buffer, RADEON_USAGE_READWRITE | RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC |
          (tex->buffer.b.b.nr_samples > 1 ? RADEON_PRIO_COLOR_BUFFER_MSAA : RADEON_PRIO_COLOR_BUFFER));
 
       if (tex->cmask_buffer && tex->cmask_buffer != &tex->buffer) {
          radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, tex->cmask_buffer,
-                                   RADEON_USAGE_READWRITE | RADEON_USAGE_NEEDS_IMPLICIT_SYNC |
+                                   RADEON_USAGE_READWRITE | RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC |
                                    RADEON_PRIO_SEPARATE_META);
       }
 
diff --git a/src/gallium/include/winsys/radeon_winsys.h b/src/gallium/include/winsys/radeon_winsys.h
index 30554e1ebcb72..6f7faef41ae5f 100644
--- a/src/gallium/include/winsys/radeon_winsys.h
+++ b/src/gallium/include/winsys/radeon_winsys.h
@@ -189,19 +189,20 @@ enum radeon_ctx_pstate
 #define RADEON_ALL_PRIORITIES (RADEON_USAGE_READ - 1)
 
 /* Upper bits of priorities are used by usage flags. */
-#define RADEON_USAGE_READ (1 << 28)
-#define RADEON_USAGE_WRITE (1 << 29)
+#define RADEON_USAGE_READ (1 << 27)
+#define RADEON_USAGE_WRITE (1 << 28)
 #define RADEON_USAGE_READWRITE (RADEON_USAGE_READ | RADEON_USAGE_WRITE)
 
 /* The winsys ensures that the CS submission will be scheduled after
  * previously flushed CSs referencing this BO in a conflicting way.
  */
-#define RADEON_USAGE_SYNCHRONIZED (1 << 30)
+#define RADEON_USAGE_SYNCHRONIZED (1 << 29)
 
 /* When used, an implicit sync is done to make sure a compute shader
  * will read the written values from a previous draw.
  */
-#define RADEON_USAGE_NEEDS_IMPLICIT_SYNC (1u << 31)
+#define RADEON_USAGE_CB_NEEDS_IMPLICIT_SYNC (1u << 30)
+#define RADEON_USAGE_DB_NEEDS_IMPLICIT_SYNC (1u << 31)
 
 struct winsys_handle;
 struct radeon_winsys_ctx;
-- 
GitLab

