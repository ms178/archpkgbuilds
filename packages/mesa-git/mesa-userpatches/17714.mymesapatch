From a74e98e526e379123a4510727d04c6f33ed11301 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 22 Jul 2022 09:33:21 -0400
Subject: [PATCH] util/blitter: respect PIPE_TEXTURE_RECT

if this isn't supported, don't use rect-related sampling and instead
use 2D since the driver will always convert to 2D
---
 src/gallium/auxiliary/util/u_blitter.c        | 30 +++++++++++++------
 .../drivers/zink/ci/zink-lvp-fails.txt        |  1 -
 2 files changed, 21 insertions(+), 10 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 051668091718..693c7f38c8c5 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -273,15 +273,19 @@ struct blitter_context *util_blitter_create(struct pipe_context *pipe)
    sampler_state.wrap_r = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
    sampler_state.normalized_coords = 1;
    ctx->sampler_state = pipe->create_sampler_state(pipe, &sampler_state);
-   sampler_state.normalized_coords = 0;
-   ctx->sampler_state_rect = pipe->create_sampler_state(pipe, &sampler_state);
+   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_TEXRECT)) {
+      sampler_state.normalized_coords = 0;
+      ctx->sampler_state_rect = pipe->create_sampler_state(pipe, &sampler_state);
+   }
 
    sampler_state.min_img_filter = PIPE_TEX_FILTER_LINEAR;
    sampler_state.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
    sampler_state.normalized_coords = 1;
    ctx->sampler_state_linear = pipe->create_sampler_state(pipe, &sampler_state);
-   sampler_state.normalized_coords = 0;
-   ctx->sampler_state_rect_linear = pipe->create_sampler_state(pipe, &sampler_state);
+   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_TEXRECT)) {
+      sampler_state.normalized_coords = 0;
+      ctx->sampler_state_rect_linear = pipe->create_sampler_state(pipe, &sampler_state);
+   }
 
    /* rasterizer state */
    memset(&rs_state, 0, sizeof(rs_state));
@@ -581,8 +585,10 @@ void util_blitter_destroy(struct blitter_context *blitter)
       if (ctx->fs_stencil_blit_fallback[i])
          ctx->delete_fs_state(pipe, ctx->fs_stencil_blit_fallback[i]);
 
-   pipe->delete_sampler_state(pipe, ctx->sampler_state_rect_linear);
-   pipe->delete_sampler_state(pipe, ctx->sampler_state_rect);
+   if (ctx->sampler_state_rect_linear)
+      pipe->delete_sampler_state(pipe, ctx->sampler_state_rect_linear);
+   if (ctx->sampler_state_rect)
+      pipe->delete_sampler_state(pipe, ctx->sampler_state_rect);
    pipe->delete_sampler_state(pipe, ctx->sampler_state_linear);
    pipe->delete_sampler_state(pipe, ctx->sampler_state);
    FREE(ctx);
@@ -1258,13 +1264,14 @@ void util_blitter_cache_all_shaders(struct blitter_context *blitter)
    struct pipe_context *pipe = blitter->pipe;
    struct pipe_screen *screen = pipe->screen;
    unsigned samples, j, f, target, max_samples, use_txf;
-   bool has_arraytex, has_cubearraytex;
+   bool has_arraytex, has_cubearraytex, have_texrect;
 
    max_samples = ctx->has_texture_multisample ? 2 : 1;
    has_arraytex = screen->get_param(screen,
                                     PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS) != 0;
    has_cubearraytex = screen->get_param(screen,
                                     PIPE_CAP_CUBE_MAP_ARRAY) != 0;
+   have_texrect = screen->get_param(screen, PIPE_CAP_TEXRECT) != 0;
 
    /* It only matters if i <= 1 or > 1. */
    for (samples = 1; samples <= max_samples; samples++) {
@@ -1278,6 +1285,9 @@ void util_blitter_cache_all_shaders(struct blitter_context *blitter)
             if (!has_cubearraytex &&
                 (target == PIPE_TEXTURE_CUBE_ARRAY))
                continue;
+            if (!have_texrect &&
+                (target == PIPE_TEXTURE_RECT))
+               continue;
 
             if (samples > 1 &&
                 (target != PIPE_TEXTURE_2D &&
@@ -2142,13 +2152,15 @@ void util_blitter_blit_generic(struct blitter_context *blitter,
 
    /* Set the linear filter only for scaled color non-MSAA blits. */
    if (filter == PIPE_TEX_FILTER_LINEAR) {
-      if (src_target == PIPE_TEXTURE_RECT) {
+      /* !PIPE_CAP_TEXRECT won't have this sampler */
+      if (src_target == PIPE_TEXTURE_RECT && ctx->sampler_state_rect_linear) {
          sampler_state = ctx->sampler_state_rect_linear;
       } else {
          sampler_state = ctx->sampler_state_linear;
       }
    } else {
-      if (src_target == PIPE_TEXTURE_RECT) {
+      /* !PIPE_CAP_TEXRECT won't have this sampler */
+      if (src_target == PIPE_TEXTURE_RECT && ctx->sampler_state_rect) {
          sampler_state = ctx->sampler_state_rect;
       } else {
          sampler_state = ctx->sampler_state;
diff --git a/src/gallium/drivers/zink/ci/zink-lvp-fails.txt b/src/gallium/drivers/zink/ci/zink-lvp-fails.txt
index ce0d742d3b1c..3f227b4a0e02 100644
--- a/src/gallium/drivers/zink/ci/zink-lvp-fails.txt
+++ b/src/gallium/drivers/zink/ci/zink-lvp-fails.txt
@@ -103,7 +103,6 @@ spec@arb_tessellation_shader@execution@variable-indexing@tes-both-input-array-ve
 spec@arb_tessellation_shader@execution@variable-indexing@tes-both-input-array-vec4-index-rd,Crash
 
 # #6322
-spec@arb_framebuffer_object@fbo-attachments-blit-scaled-linear,Fail
 spec@arb_framebuffer_object@fbo-blit-scaled-linear,Fail
 
 
-- 
GitLab

