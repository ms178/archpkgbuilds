From f8bcf52ba0c0f38a2a83eeba3170be5092f8b7ac Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 26 Oct 2023 20:41:08 -0400
Subject: [PATCH] mesa: plumb errors through to texture allocation

the spec allows this and tests like spec@arb_texture_multisample@arb_texture_multisample-dsa-texelfetch
expect it

cc: mesa-stable
---
 src/mesa/main/teximage.c               |  4 +--
 src/mesa/main/texstorage.c             | 45 ++++++++++++++------------
 src/mesa/state_tracker/st_cb_texture.c | 16 +++++----
 src/mesa/state_tracker/st_cb_texture.h |  6 ++--
 4 files changed, 41 insertions(+), 30 deletions(-)

diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index 412fce4d8c74f..c77259e877e01 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -7095,14 +7095,14 @@ texture_image_multisample(struct gl_context *ctx, GLuint dims,
             if (!st_SetTextureStorageForMemoryObject(ctx, texObj,
                                                      memObj, 1, width,
                                                      height, depth,
-                                                     offset)) {
+                                                     offset, func)) {
 
                _mesa_init_teximage_fields(ctx, texImage, 0, 0, 0, 0,
                                           internalformat, texFormat);
             }
          } else {
             if (!st_AllocTextureStorage(ctx, texObj, 1,
-                                        width, height, depth)) {
+                                        width, height, depth, func)) {
                /* tidy up the texture image state. strictly speaking,
                 * we're allowed to just leave this in whatever state we
                 * like, but being tidy is good.
diff --git a/src/mesa/main/texstorage.c b/src/mesa/main/texstorage.c
index b1f8de70c4187..53428c34d2d85 100644
--- a/src/mesa/main/texstorage.c
+++ b/src/mesa/main/texstorage.c
@@ -439,7 +439,7 @@ texture_storage(struct gl_context *ctx, GLuint dims,
                 struct gl_memory_object *memObj, GLenum target,
                 GLsizei levels, GLenum internalformat, GLsizei width,
                 GLsizei height, GLsizei depth, GLuint64 offset, bool dsa,
-                bool no_error)
+                bool no_error, const char *func)
 {
    GLboolean sizeOK = GL_TRUE, dimensionsOK = GL_TRUE;
    mesa_format texFormat;
@@ -517,7 +517,7 @@ texture_storage(struct gl_context *ctx, GLuint dims,
          if (!st_SetTextureStorageForMemoryObject(ctx, texObj, memObj,
                                                   levels,
                                                   width, height, depth,
-                                                  offset)) {
+                                                  offset, func)) {
 
             clear_texture_fields(ctx, texObj);
             return;
@@ -525,7 +525,7 @@ texture_storage(struct gl_context *ctx, GLuint dims,
       }
       else {
          if (!st_AllocTextureStorage(ctx, texObj, levels,
-                                     width, height, depth)) {
+                                     width, height, depth, func)) {
             /* Reset the texture images' info to zeros.
              * Strictly speaking, we probably don't have to do this since
              * generating GL_OUT_OF_MEMORY can leave things in an undefined
@@ -550,10 +550,10 @@ texture_storage_error(struct gl_context *ctx, GLuint dims,
                       struct gl_texture_object *texObj,
                       GLenum target, GLsizei levels,
                       GLenum internalformat, GLsizei width,
-                      GLsizei height, GLsizei depth, bool dsa)
+                      GLsizei height, GLsizei depth, bool dsa, const char *func)
 {
    texture_storage(ctx, dims, texObj, NULL, target, levels, internalformat,
-                   width, height, depth, dsa, 0, false);
+                   width, height, depth, dsa, 0, false, func);
 }
 
 
@@ -562,10 +562,10 @@ texture_storage_no_error(struct gl_context *ctx, GLuint dims,
                          struct gl_texture_object *texObj,
                          GLenum target, GLsizei levels,
                          GLenum internalformat, GLsizei width,
-                         GLsizei height, GLsizei depth, bool dsa)
+                         GLsizei height, GLsizei depth, bool dsa, const char *func)
 {
    texture_storage(ctx, dims, texObj, NULL, target, levels, internalformat,
-                   width, height, depth, dsa, 0, true);
+                   width, height, depth, dsa, 0, true, func);
 }
 
 
@@ -609,20 +609,20 @@ texstorage_error(GLuint dims, GLenum target, GLsizei levels,
       return;
 
    texture_storage_error(ctx, dims, texObj, target, levels,
-                         internalformat, width, height, depth, false);
+                         internalformat, width, height, depth, false, caller);
 }
 
 
 static void
 texstorage_no_error(GLuint dims, GLenum target, GLsizei levels,
                     GLenum internalformat, GLsizei width, GLsizei height,
-                    GLsizei depth)
+                    GLsizei depth, const char *caller)
 {
    GET_CURRENT_CONTEXT(ctx);
 
    struct gl_texture_object *texObj = _mesa_get_current_tex_object(ctx, target);
    texture_storage_no_error(ctx, dims, texObj, target, levels,
-                            internalformat, width, height, depth, false);
+                            internalformat, width, height, depth, false, caller);
 }
 
 
@@ -666,20 +666,20 @@ texturestorage_error(GLuint dims, GLuint texture, GLsizei levels,
    }
 
    texture_storage_error(ctx, dims, texObj, texObj->Target,
-                         levels, internalformat, width, height, depth, true);
+                         levels, internalformat, width, height, depth, true, caller);
 }
 
 
 static void
 texturestorage_no_error(GLuint dims, GLuint texture, GLsizei levels,
                         GLenum internalformat, GLsizei width, GLsizei height,
-                        GLsizei depth)
+                        GLsizei depth, const char *caller)
 {
    GET_CURRENT_CONTEXT(ctx);
 
    struct gl_texture_object *texObj = _mesa_lookup_texture(ctx, texture);
    texture_storage_no_error(ctx, dims, texObj, texObj->Target,
-                            levels, internalformat, width, height, depth, true);
+                            levels, internalformat, width, height, depth, true, caller);
 }
 
 
@@ -687,7 +687,8 @@ void GLAPIENTRY
 _mesa_TexStorage1D_no_error(GLenum target, GLsizei levels,
                             GLenum internalformat, GLsizei width)
 {
-   texstorage_no_error(1, target, levels, internalformat, width, 1, 1);
+   texstorage_no_error(1, target, levels, internalformat, width, 1, 1,
+                       "glTexStorage1D");
 }
 
 
@@ -705,7 +706,8 @@ _mesa_TexStorage2D_no_error(GLenum target, GLsizei levels,
                             GLenum internalformat, GLsizei width,
                             GLsizei height)
 {
-   texstorage_no_error(2, target, levels, internalformat, width, height, 1);
+   texstorage_no_error(2, target, levels, internalformat, width, height, 1,
+                       "glTexStorage2D");
 }
 
 
@@ -723,7 +725,8 @@ _mesa_TexStorage3D_no_error(GLenum target, GLsizei levels,
                             GLenum internalformat, GLsizei width,
                             GLsizei height, GLsizei depth)
 {
-   texstorage_no_error(3, target, levels, internalformat, width, height, depth);
+   texstorage_no_error(3, target, levels, internalformat, width, height, depth,
+                       "glTexStorage3D");
 }
 
 
@@ -740,7 +743,8 @@ void GLAPIENTRY
 _mesa_TextureStorage1D_no_error(GLuint texture, GLsizei levels,
                                 GLenum internalformat, GLsizei width)
 {
-   texturestorage_no_error(1, texture, levels, internalformat, width, 1, 1);
+   texturestorage_no_error(1, texture, levels, internalformat, width, 1, 1,
+                           "glTextureStorage1D");
 }
 
 
@@ -758,7 +762,8 @@ _mesa_TextureStorage2D_no_error(GLuint texture, GLsizei levels,
                                 GLenum internalformat,
                                 GLsizei width, GLsizei height)
 {
-   texturestorage_no_error(2, texture, levels, internalformat, width, height, 1);
+   texturestorage_no_error(2, texture, levels, internalformat, width, height, 1,
+                           "glTextureStorage2D");
 }
 
 
@@ -778,7 +783,7 @@ _mesa_TextureStorage3D_no_error(GLuint texture, GLsizei levels,
                                 GLsizei height, GLsizei depth)
 {
    texturestorage_no_error(3, texture, levels, internalformat, width, height,
-                           depth);
+                           depth, "glTextureStorage3D");
 }
 
 
@@ -854,5 +859,5 @@ _mesa_texture_storage_memory(struct gl_context *ctx, GLuint dims,
    assert(memObj);
 
    texture_storage(ctx, dims, texObj, memObj, target, levels, internalformat,
-                   width, height, depth, offset, dsa, false);
+                   width, height, depth, offset, dsa, false, "");
 }
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 3b75d01230140..abc5fef2b5e61 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -3373,7 +3373,7 @@ st_texture_storage(struct gl_context *ctx,
                    GLsizei levels, GLsizei width,
                    GLsizei height, GLsizei depth,
                    struct gl_memory_object *memObj,
-                   GLuint64 offset)
+                   GLuint64 offset, const char *func)
 {
    const GLuint numFaces = _mesa_num_tex_faces(texObj->Target);
    struct gl_texture_image *texImage = texObj->Image[0][0];
@@ -3423,6 +3423,7 @@ st_texture_storage(struct gl_context *ctx,
       }
 
       if (!found) {
+         _mesa_error(st->ctx, GL_INVALID_OPERATION, "%s(format/samplecount not supported)", func);
          return GL_FALSE;
       }
    }
@@ -3459,8 +3460,10 @@ st_texture_storage(struct gl_context *ctx,
                                     texObj->IsSparse);
    }
 
-   if (!texObj->pt)
+   if (!texObj->pt) {
+      _mesa_error(st->ctx, GL_OUT_OF_MEMORY, "%s", func);
       return GL_FALSE;
+   }
 
    /* Set image resource pointers */
    for (level = 0; level < levels; level++) {
@@ -3493,11 +3496,12 @@ GLboolean
 st_AllocTextureStorage(struct gl_context *ctx,
                        struct gl_texture_object *texObj,
                        GLsizei levels, GLsizei width,
-                       GLsizei height, GLsizei depth)
+                       GLsizei height, GLsizei depth,
+                       const char *func)
 {
    return st_texture_storage(ctx, texObj, levels,
                              width, height, depth,
-                             NULL, 0);
+                             NULL, 0, func);
 }
 
 
@@ -3715,11 +3719,11 @@ st_SetTextureStorageForMemoryObject(struct gl_context *ctx,
                                     struct gl_memory_object *memObj,
                                     GLsizei levels, GLsizei width,
                                     GLsizei height, GLsizei depth,
-                                    GLuint64 offset)
+                                    GLuint64 offset, const char *func)
 {
    return st_texture_storage(ctx, texObj, levels,
                              width, height, depth,
-                             memObj, offset);
+                             memObj, offset, func);
 }
 
 GLboolean
diff --git a/src/mesa/state_tracker/st_cb_texture.h b/src/mesa/state_tracker/st_cb_texture.h
index cc496d2d2f418..6131954d988cb 100644
--- a/src/mesa/state_tracker/st_cb_texture.h
+++ b/src/mesa/state_tracker/st_cb_texture.h
@@ -98,7 +98,8 @@ void st_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
 GLboolean st_AllocTextureStorage(struct gl_context *ctx,
                                  struct gl_texture_object *texObj,
                                  GLsizei levels, GLsizei width,
-                                 GLsizei height, GLsizei depth);
+                                 GLsizei height, GLsizei depth,
+                                 const char *func);
 GLboolean st_TestProxyTexImage(struct gl_context *ctx, GLenum target,
                                GLuint numLevels, GLint level,
                                mesa_format format, GLuint numSamples,
@@ -116,7 +117,8 @@ GLboolean st_SetTextureStorageForMemoryObject(struct gl_context *ctx,
                                               struct gl_memory_object *memObj,
                                               GLsizei levels, GLsizei width,
                                               GLsizei height, GLsizei depth,
-                                              GLuint64 offset);
+                                              GLuint64 offset,
+                                              const char *func);
 
 GLboolean st_GetSparseTextureVirtualPageSize(struct gl_context *ctx,
                                              GLenum target, mesa_format format,
-- 
GitLab

