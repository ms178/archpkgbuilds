From 144a6d48a673b6a398693dc5d9d5f7c084512224 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 1 Jul 2022 14:13:25 +0100
Subject: [PATCH 1/4] nir: rename fsin_r600/fcos_r600 to fsin_amd/fcos_amd

GCN has better range, but constant folding is the same.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_opcodes.py                         | 6 +++---
 src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp | 8 ++++----
 src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp      | 4 ++--
 3 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/compiler/nir/nir_opcodes.py b/src/compiler/nir/nir_opcodes.py
index a08adc695c6b..8bb1685f71a9 100644
--- a/src/compiler/nir/nir_opcodes.py
+++ b/src/compiler/nir/nir_opcodes.py
@@ -1261,11 +1261,11 @@ unop_horiz("cube_r600", 4, tfloat32, 3, tfloat32, """
    }
 """)
 
-# r600 specific sin and cos
+# r600/gcn specific sin and cos
 # these trigeometric functions need some lowering because the supported
 # input values are expected to be normalized by dividing by (2 * pi)
-unop("fsin_r600", tfloat32, "sinf(6.2831853 * src0)")
-unop("fcos_r600", tfloat32, "cosf(6.2831853 * src0)")
+unop("fsin_amd", tfloat32, "sinf(6.2831853 * src0)")
+unop("fcos_amd", tfloat32, "cosf(6.2831853 * src0)")
 
 # AGX specific sin with input expressed in quadrants. Used in the lowering for
 # fsin/fcos. This corresponds to a sequence of 3 ALU ops in the backend (where
diff --git a/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp b/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp
index 306822552baa..e9e8421dbae5 100644
--- a/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp
@@ -53,12 +53,12 @@ bool EmitAluInstruction::do_emit(nir_instr* ir)
 
    if (get_chip_class() == CAYMAN) {
       switch (instr.op) {
-      case nir_op_fcos_r600: return emit_alu_cm_trig(instr, op1_cos);
+      case nir_op_fcos_amd: return emit_alu_cm_trig(instr, op1_cos);
       case nir_op_fexp2: return emit_alu_cm_trig(instr, op1_exp_ieee);
       case nir_op_flog2: return emit_alu_cm_trig(instr, op1_log_clamped);
       case nir_op_frcp: return emit_alu_cm_trig(instr, op1_recip_ieee);
       case nir_op_frsq: return emit_alu_cm_trig(instr, op1_recipsqrt_ieee1);
-      case nir_op_fsin_r600: return emit_alu_cm_trig(instr, op1_sin);
+      case nir_op_fsin_amd: return emit_alu_cm_trig(instr, op1_sin);
       case nir_op_fsqrt: return emit_alu_cm_trig(instr, op1_sqrt_ieee);
          default:
             ;
@@ -110,7 +110,7 @@ bool EmitAluInstruction::do_emit(nir_instr* ir)
    case nir_op_fabs: return emit_alu_op1(instr, op1_mov, {1 << alu_src0_abs});
    case nir_op_fadd: return emit_alu_op2(instr, op2_add);
    case nir_op_fceil: return emit_alu_op1(instr, op1_ceil);
-   case nir_op_fcos_r600: return emit_alu_trans_op1(instr, op1_cos);
+   case nir_op_fcos_amd: return emit_alu_trans_op1(instr, op1_cos);
    case nir_op_fcsel: return emit_alu_op3(instr, op3_cnde, {0, 2, 1});
    case nir_op_fcsel_ge: return emit_alu_op3(instr, op3_cndge, {0, 1, 2});
    case nir_op_fcsel_gt: return emit_alu_op3(instr, op3_cndgt, {0, 1, 2});
@@ -154,7 +154,7 @@ bool EmitAluInstruction::do_emit(nir_instr* ir)
    case nir_op_fround_even: return emit_alu_op1(instr, op1_rndne);
    case nir_op_frsq: return emit_alu_trans_op1(instr, op1_recipsqrt_ieee1);
    case nir_op_fsat: return emit_alu_op1(instr, op1_mov, {1 << alu_dst_clamp});
-   case nir_op_fsin_r600: return emit_alu_trans_op1(instr, op1_sin);
+   case nir_op_fsin_amd: return emit_alu_trans_op1(instr, op1_sin);
    case nir_op_fsqrt: return emit_alu_trans_op1(instr, op1_sqrt_ieee);
    case nir_op_fsub: return emit_alu_op2(instr, op2_add, op2_opt_neg_src1);
    case nir_op_ftrunc: return emit_alu_op1(instr, op1_trunc);
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp
index 561c7468f91b..e5311f9a87c8 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_alu.cpp
@@ -83,9 +83,9 @@ nir_ssa_def *LowerSinCos::lower(nir_instr *instr)
                               nir_imm_float(b, -0.5));
 
    if (alu->op == nir_op_fsin)
-      return nir_fsin_r600(b, normalized);
+      return nir_fsin_amd(b, normalized);
    else
-      return nir_fcos_r600(b, normalized);
+      return nir_fcos_amd(b, normalized);
 }
 
 
-- 
GitLab


From f823f1867a46f5f3cef233a04a5880286f9bafe6 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 3 May 2021 10:55:39 +0100
Subject: [PATCH 2/4] nir/algebraic: optimize bcsel(c, fsin/cos_amd(a),
 fsin/cos_amd(b))

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_opt_algebraic.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 73ee5d419d64..9ab8542b0ff5 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -2426,7 +2426,7 @@ for op in ['fpow']:
         (('bcsel', a, (op, b, c), (op + '(is_used_once)', d, c)), (op, ('bcsel', a, b, d), c)),
     ]
 
-for op in ['frcp', 'frsq', 'fsqrt', 'fexp2', 'flog2', 'fsign', 'fsin', 'fcos', 'fneg', 'fabs', 'fsign']:
+for op in ['frcp', 'frsq', 'fsqrt', 'fexp2', 'flog2', 'fsign', 'fsin', 'fcos', 'fsin_amd', 'fcos_amd', 'fneg', 'fabs', 'fsign']:
     optimizations += [
         (('bcsel', c, (op + '(is_used_once)', a), (op + '(is_used_once)', b)), (op, ('bcsel', c, a, b))),
     ]
-- 
GitLab


From af1bee3cf471aaaffbb936355076577f2e3430e7 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 13 May 2021 15:31:56 +0100
Subject: [PATCH 3/4] nir: allow 16-bit fsin_r600/fcos_r600

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
---
 src/compiler/nir/nir_opcodes.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_opcodes.py b/src/compiler/nir/nir_opcodes.py
index 8bb1685f71a9..97025d92857d 100644
--- a/src/compiler/nir/nir_opcodes.py
+++ b/src/compiler/nir/nir_opcodes.py
@@ -1264,8 +1264,8 @@ unop_horiz("cube_r600", 4, tfloat32, 3, tfloat32, """
 # r600/gcn specific sin and cos
 # these trigeometric functions need some lowering because the supported
 # input values are expected to be normalized by dividing by (2 * pi)
-unop("fsin_amd", tfloat32, "sinf(6.2831853 * src0)")
-unop("fcos_amd", tfloat32, "cosf(6.2831853 * src0)")
+unop("fsin_amd", tfloat, "sinf(6.2831853 * src0)")
+unop("fcos_amd", tfloat, "cosf(6.2831853 * src0)")
 
 # AGX specific sin with input expressed in quadrants. Used in the lowering for
 # fsin/fcos. This corresponds to a sequence of 3 ALU ops in the backend (where
-- 
GitLab


From 02d3053afc08e17960b1add899d124b64be7380b Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 3 May 2021 11:10:06 +0100
Subject: [PATCH 4/4] radv,aco,ac/llvm: use nir_op_f{sin,cos}_r600

This lets NIR optimize the multiplication, particularly sin/cos(a * #b).

fossil-db (Sienna Cichlid):
Totals from 12306 (7.58% of 162293) affected shaders:
MaxWaves: 224814 -> 224834 (+0.01%)
Instrs: 17365273 -> 17338758 (-0.15%); split: -0.16%, +0.00%
CodeSize: 93478488 -> 93354912 (-0.13%); split: -0.14%, +0.01%
VGPRs: 752080 -> 752072 (-0.00%); split: -0.00%, +0.00%
SpillSGPRs: 8440 -> 8410 (-0.36%)
Latency: 200402154 -> 200279405 (-0.06%); split: -0.06%, +0.00%
InvThroughput: 37588077 -> 37545545 (-0.11%); split: -0.11%, +0.00%
VClause: 293863 -> 293874 (+0.00%); split: -0.03%, +0.03%
SClause: 619539 -> 619064 (-0.08%); split: -0.09%, +0.01%
Copies: 1151591 -> 1151641 (+0.00%); split: -0.04%, +0.05%
Branches: 506434 -> 506437 (+0.00%); split: -0.00%, +0.00%
PreSGPRs: 877609 -> 877517 (-0.01%); split: -0.01%, +0.00%
PreVGPRs: 711938 -> 711940 (+0.00%); split: -0.00%, +0.00%

fossil-db (LLVM, Sienna Cichlid):
Totals from 4377 (3.59% of 121873) affected shaders:
SGPRs: 358960 -> 359176 (+0.06%); split: -0.18%, +0.25%
VGPRs: 319832 -> 319720 (-0.04%); split: -0.18%, +0.15%
SpillSGPRs: 46983 -> 47007 (+0.05%); split: -0.99%, +1.04%
CodeSize: 30872812 -> 30764512 (-0.35%); split: -0.39%, +0.04%
MaxWaves: 73814 -> 73904 (+0.12%); split: +0.25%, -0.13%

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 22 +++++++++----------
 .../aco_instruction_selection_setup.cpp       |  4 ++--
 src/amd/llvm/ac_nir_to_llvm.c                 | 10 +++++++++
 src/amd/vulkan/radv_shader.c                  | 17 ++++++++++++++
 4 files changed, 39 insertions(+), 14 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 34e82a11b7f4..0baf6a1cdbb4 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -2750,27 +2750,25 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
       }
       break;
    }
-   case nir_op_fsin:
-   case nir_op_fcos: {
+   case nir_op_fsin_amd:
+   case nir_op_fcos_amd: {
       Temp src = as_vgpr(ctx, get_alu_src(ctx, instr->src[0]));
       aco_ptr<Instruction> norm;
       if (dst.regClass() == v2b) {
-         Temp half_pi = bld.copy(bld.def(s1), Operand::c32(0x3118u));
-         Temp tmp = bld.vop2(aco_opcode::v_mul_f16, bld.def(v2b), half_pi, src);
+         if (ctx->options->gfx_level < GFX9)
+            src = bld.vop1(aco_opcode::v_fract_f16, bld.def(v2b), src);
+
          aco_opcode opcode =
-            instr->op == nir_op_fsin ? aco_opcode::v_sin_f16 : aco_opcode::v_cos_f16;
-         bld.vop1(opcode, Definition(dst), tmp);
+            instr->op == nir_op_fsin_amd ? aco_opcode::v_sin_f16 : aco_opcode::v_cos_f16;
+         bld.vop1(opcode, Definition(dst), src);
       } else if (dst.regClass() == v1) {
-         Temp half_pi = bld.copy(bld.def(s1), Operand::c32(0x3e22f983u));
-         Temp tmp = bld.vop2(aco_opcode::v_mul_f32, bld.def(v1), half_pi, src);
-
          /* before GFX9, v_sin_f32 and v_cos_f32 had a valid input domain of [-256, +256] */
          if (ctx->options->gfx_level < GFX9)
-            tmp = bld.vop1(aco_opcode::v_fract_f32, bld.def(v1), tmp);
+            src = bld.vop1(aco_opcode::v_fract_f32, bld.def(v1), src);
 
          aco_opcode opcode =
-            instr->op == nir_op_fsin ? aco_opcode::v_sin_f32 : aco_opcode::v_cos_f32;
-         bld.vop1(opcode, Definition(dst), tmp);
+            instr->op == nir_op_fsin_amd ? aco_opcode::v_sin_f32 : aco_opcode::v_cos_f32;
+         bld.vop1(opcode, Definition(dst), src);
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 99ebec2031e2..719c5b8b9785 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -501,8 +501,8 @@ init_context(isel_context* ctx, nir_shader* shader)
                case nir_op_fceil:
                case nir_op_ftrunc:
                case nir_op_fround_even:
-               case nir_op_fsin:
-               case nir_op_fcos:
+               case nir_op_fsin_amd:
+               case nir_op_fcos_amd:
                case nir_op_f2f16:
                case nir_op_f2f16_rtz:
                case nir_op_f2f16_rtne:
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index fb09193443b4..53f6242ae336 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -854,6 +854,16 @@ static void visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
       result =
          emit_intrin_1f_param(&ctx->ac, "llvm.cos", ac_to_float_type(&ctx->ac, def_type), src[0]);
       break;
+   case nir_op_fsin_amd:
+   case nir_op_fcos_amd:
+      /* before GFX9, v_sin_f32 and v_cos_f32 had a valid input domain of [-256, +256] */
+      if (ctx->ac.gfx_level < GFX9)
+         src[0] = emit_intrin_1f_param_scalar(&ctx->ac, "llvm.amdgcn.fract",
+                                              ac_to_float_type(&ctx->ac, def_type), src[0]);
+      result =
+         emit_intrin_1f_param(&ctx->ac, instr->op == nir_op_fsin_amd ? "llvm.amdgcn.sin" : "llvm.amdgcn.cos",
+                              ac_to_float_type(&ctx->ac, def_type), src[0]);
+      break;
    case nir_op_fsqrt:
       result =
          emit_intrin_1f_param(&ctx->ac, "llvm.sqrt", ac_to_float_type(&ctx->ac, def_type), src[0]);
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 453f954fa7df..b4f1a8d748f9 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -633,6 +633,21 @@ radv_lower_ms_workgroup_id(nir_shader *nir)
    return progress;
 }
 
+static bool
+is_sincos(const nir_instr *instr, const void *_)
+{
+   return instr->type == nir_instr_type_alu &&
+          (nir_instr_as_alu(instr)->op == nir_op_fsin || nir_instr_as_alu(instr)->op == nir_op_fcos);
+}
+
+static nir_ssa_def *
+lower_sincos(struct nir_builder *b, nir_instr *instr, void *_)
+{
+   nir_alu_instr *sincos = nir_instr_as_alu(instr);
+   nir_ssa_def *src = nir_fmul_imm(b, nir_ssa_for_alu_src(b, sincos, 0), 0.15915493667125702);
+   return sincos->op == nir_op_fsin ? nir_fsin_amd(b, src) : nir_fcos_amd(b, src);
+}
+
 nir_shader *
 radv_shader_spirv_to_nir(struct radv_device *device, const struct radv_pipeline_stage *stage,
                          const struct radv_pipeline_key *key)
@@ -843,6 +858,8 @@ radv_shader_spirv_to_nir(struct radv_device *device, const struct radv_pipeline_
       }
 
       NIR_PASS(_, nir, nir_lower_doubles, NULL, lower_doubles);
+
+      NIR_PASS(_, nir, nir_shader_lower_instructions, &is_sincos, &lower_sincos, NULL);
    }
 
    NIR_PASS(_, nir, nir_lower_system_values);
-- 
GitLab

