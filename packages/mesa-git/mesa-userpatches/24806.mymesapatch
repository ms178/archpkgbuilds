From 289615059a3151ad218b0c1ae687e9604aaa6f3f Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Mon, 21 Aug 2023 14:49:29 +0900
Subject: [PATCH 3/3] radv/amdgpu: Use rwlock to protect access to virtual BOs.

Vulkan provides no external synchronization guarantees on sparse memory
objects. Use a per-BO rwlock to prevent reading data mid-update.
---
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c | 20 +++++++++++++------
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h |  2 ++
 src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c |  2 ++
 3 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
index 8c26c9fbcf123..5cc92bd65df9a 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.c
@@ -121,6 +121,8 @@ radv_amdgpu_winsys_bo_virtual_bind(struct radeon_winsys *_ws, struct radeon_wins
    assert(parent->is_virtual);
    assert(!bo || !bo->is_virtual);
 
+   u_rwlock_wrlock(&parent->lock);
+
    /* When the BO is NULL, AMDGPU will reset the PTE VA range to the initial state. Otherwise, it
     * will first unmap all existing VA that overlap the requested range and then map.
     */
@@ -133,7 +135,8 @@ radv_amdgpu_winsys_bo_virtual_bind(struct radeon_winsys *_ws, struct radeon_wins
 
    if (r) {
       fprintf(stderr, "radv/amdgpu: Failed to replace a PRT VA region (%d).\n", r);
-      return VK_ERROR_OUT_OF_DEVICE_MEMORY;
+      result = VK_ERROR_OUT_OF_DEVICE_MEMORY;
+      goto out;
    }
 
    /* Do not add the BO to the virtual BO list if it's already in the global list to avoid dangling
@@ -157,8 +160,10 @@ radv_amdgpu_winsys_bo_virtual_bind(struct radeon_winsys *_ws, struct radeon_wins
       uint32_t range_capacity = parent->range_capacity + 2;
       struct radv_amdgpu_map_range *ranges =
          realloc(parent->ranges, range_capacity * sizeof(struct radv_amdgpu_map_range));
-      if (!ranges)
-         return VK_ERROR_OUT_OF_HOST_MEMORY;
+      if (!ranges) {
+         result = VK_ERROR_OUT_OF_HOST_MEMORY;
+         goto out;
+      }
       parent->ranges = ranges;
       parent->range_capacity = range_capacity;
    }
@@ -243,10 +248,10 @@ radv_amdgpu_winsys_bo_virtual_bind(struct radeon_winsys *_ws, struct radeon_wins
    parent->range_count += range_count_delta;
 
    result = radv_amdgpu_winsys_rebuild_bo_list(parent);
-   if (result != VK_SUCCESS)
-      return result;
 
-   return VK_SUCCESS;
+out:
+   u_rwlock_wrunlock(&parent->lock);
+   return result;
 }
 
 struct radv_amdgpu_winsys_bo_log {
@@ -337,6 +342,7 @@ radv_amdgpu_winsys_bo_destroy(struct radeon_winsys *_ws, struct radeon_winsys_bo
 
       free(bo->bos);
       free(bo->ranges);
+      u_rwlock_destroy(&bo->lock);
    } else {
       if (ws->debug_all_bos)
          radv_amdgpu_global_bo_list_del(ws, bo);
@@ -410,6 +416,8 @@ radv_amdgpu_winsys_bo_create(struct radeon_winsys *_ws, uint64_t size, unsigned
          goto error_ranges_alloc;
       }
 
+      u_rwlock_init(&bo->lock);
+
       bo->ranges = ranges;
       bo->range_count = 1;
       bo->range_capacity = 1;
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h
index ffe4e27077e23..f108d8ba35963 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_bo.h
@@ -53,6 +53,8 @@ struct radv_amdgpu_winsys_bo {
       };
       /* virtual bo */
       struct {
+         struct u_rwlock lock;
+
          struct radv_amdgpu_map_range *ranges;
          uint32_t range_count;
          uint32_t range_capacity;
diff --git a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
index 6e17a9ba10903..756e6a11a1584 100644
--- a/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
+++ b/src/amd/vulkan/winsys/amdgpu/radv_amdgpu_cs.c
@@ -824,6 +824,7 @@ radv_amdgpu_add_cs_to_bo_list(struct radv_amdgpu_cs *cs, struct drm_amdgpu_bo_li
    }
    for (unsigned j = 0; j < cs->num_virtual_buffers; ++j) {
       struct radv_amdgpu_winsys_bo *virtual_bo = radv_amdgpu_winsys_bo(cs->virtual_buffers[j]);
+      u_rwlock_rdlock(&virtual_bo->lock);
       for (unsigned k = 0; k < virtual_bo->bo_count; ++k) {
          struct radv_amdgpu_winsys_bo *bo = virtual_bo->bos[k];
          bool found = false;
@@ -839,6 +840,7 @@ radv_amdgpu_add_cs_to_bo_list(struct radv_amdgpu_cs *cs, struct drm_amdgpu_bo_li
             ++num_handles;
          }
       }
+      u_rwlock_rdunlock(&virtual_bo->lock);
    }
 
    return num_handles;
-- 
GitLab

