From f95b8d428ba1156d5ccbd6b794cc94a2029a6cb8 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 10:34:20 -0400
Subject: [PATCH 01/14] radv: outdent some vs prolog code

no functional changes
---
 src/amd/vulkan/radv_cmd_buffer.c | 39 ++++++++++++++++----------------
 1 file changed, 19 insertions(+), 20 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 449bf68f388e..a19ce94ccb26 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3814,30 +3814,29 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    struct hash_entry *prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
    u_rwlock_rdunlock(&device->vs_prologs_lock);
 
-   if (!prolog_entry) {
-      u_rwlock_wrlock(&device->vs_prologs_lock);
-      prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
-      if (prolog_entry) {
-         u_rwlock_wrunlock(&device->vs_prologs_lock);
-         return prolog_entry->data;
-      }
-
-      prolog = radv_create_vs_prolog(device, &key);
-      uint32_t *key2 = malloc(key_size * 4);
-      if (!prolog || !key2) {
-         radv_shader_part_unref(device, prolog);
-         free(key2);
-         u_rwlock_wrunlock(&device->vs_prologs_lock);
-         return NULL;
-      }
-      memcpy(key2, key_words, key_size * 4);
-      _mesa_hash_table_insert_pre_hashed(device->vs_prologs, hash, key2, prolog);
+   if (prolog_entry)
+      return prolog_entry->data;
 
+   u_rwlock_wrlock(&device->vs_prologs_lock);
+   prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
+   if (prolog_entry) {
       u_rwlock_wrunlock(&device->vs_prologs_lock);
-      return prolog;
+      return prolog_entry->data;
+   }
+
+   prolog = radv_create_vs_prolog(device, &key);
+   uint32_t *key2 = malloc(key_size * 4);
+   if (!prolog || !key2) {
+      radv_shader_part_unref(device, prolog);
+      free(key2);
+      u_rwlock_wrunlock(&device->vs_prologs_lock);
+      return NULL;
    }
+   memcpy(key2, key_words, key_size * 4);
+   _mesa_hash_table_insert_pre_hashed(device->vs_prologs, hash, key2, prolog);
 
-   return prolog_entry->data;
+   u_rwlock_wrunlock(&device->vs_prologs_lock);
+   return prolog;
 }
 
 static void
-- 
GitLab


From 4fa9021508eaa18e06eb03871f4667ac8f2175fc Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 10:45:51 -0400
Subject: [PATCH 02/14] radv: add a vs_prologs table to cmdbufs

the device hash table is under lock, which is extremely painful in
cpu-intensive scenarios. by adding the used prologs to cmdbufs, the lock
is bypassed and perf increases
---
 src/amd/vulkan/radv_cmd_buffer.c | 22 +++++++++++++++++++---
 src/amd/vulkan/radv_private.h    |  2 ++
 2 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index a19ce94ccb26..7c73886b07ba 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -328,6 +328,7 @@ radv_destroy_cmd_buffer(struct vk_command_buffer *vk_cmd_buffer)
          vk_descriptor_set_layout_unref(&cmd_buffer->device->vk, &set->layout->vk);
       vk_object_base_finish(&set->base);
    }
+   ralloc_free(cmd_buffer->vs_prologs.table);
 
    vk_object_base_finish(&cmd_buffer->meta_push_descriptors.base);
 
@@ -366,7 +367,11 @@ radv_create_cmd_buffer(struct vk_command_pool *pool, struct vk_command_buffer **
       return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
    }
 
-   vk_object_base_init(&device->vk, &cmd_buffer->meta_push_descriptors.base, VK_OBJECT_TYPE_DESCRIPTOR_SET);
+   if (device->vs_prologs)
+      _mesa_hash_table_init(&cmd_buffer->vs_prologs, NULL, &radv_hash_vs_prolog, &radv_cmp_vs_prolog);
+
+   vk_object_base_init(&device->vk, &cmd_buffer->meta_push_descriptors.base,
+                       VK_OBJECT_TYPE_DESCRIPTOR_SET);
 
    for (unsigned i = 0; i < MAX_BIND_POINTS; i++)
       vk_object_base_init(&device->vk, &cmd_buffer->descriptors[i].push_set.set.base, VK_OBJECT_TYPE_DESCRIPTOR_SET);
@@ -3810,17 +3815,27 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
        radv_cmp_vs_prolog(key_words, cmd_buffer->state.emitted_vs_prolog_key))
       return cmd_buffer->state.emitted_vs_prolog;
 
+   struct hash_entry *prolog_entry = NULL;
+   if (cmd_buffer->vs_prologs.entries) {
+      prolog_entry = _mesa_hash_table_search_pre_hashed(&cmd_buffer->vs_prologs, hash, key_words);
+      if (prolog_entry)
+         return prolog_entry->data;
+   }
+
    u_rwlock_rdlock(&device->vs_prologs_lock);
-   struct hash_entry *prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
+   prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
    u_rwlock_rdunlock(&device->vs_prologs_lock);
 
-   if (prolog_entry)
+   if (prolog_entry) {
+      _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key, prolog_entry->data);
       return prolog_entry->data;
+   }
 
    u_rwlock_wrlock(&device->vs_prologs_lock);
    prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
    if (prolog_entry) {
       u_rwlock_wrunlock(&device->vs_prologs_lock);
+      _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key, prolog_entry->data);
       return prolog_entry->data;
    }
 
@@ -3834,6 +3849,7 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    }
    memcpy(key2, key_words, key_size * 4);
    _mesa_hash_table_insert_pre_hashed(device->vs_prologs, hash, key2, prolog);
+   _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, hash, key2, prolog);
 
    u_rwlock_wrunlock(&device->vs_prologs_lock);
    return prolog;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index a20629dde738..6dcd271a14ba 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1858,6 +1858,8 @@ struct radv_cmd_buffer {
    uint64_t shader_upload_seq;
 
    uint32_t sqtt_cb_id;
+
+   struct hash_table vs_prologs;
 };
 
 static inline bool
-- 
GitLab


From 33b7af01d32588f42eb0573c398873350ff2b67d Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 10:56:05 -0400
Subject: [PATCH 03/14] radv: explicitly multiply by sizeof(uint32_t) for vs
 prologs

this is a little more clear
---
 src/amd/vulkan/radv_cmd_buffer.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 7c73886b07ba..925aa31e22cf 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3840,14 +3840,14 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    }
 
    prolog = radv_create_vs_prolog(device, &key);
-   uint32_t *key2 = malloc(key_size * 4);
+   uint32_t *key2 = malloc(key_size * sizeof(uint32_t));
    if (!prolog || !key2) {
       radv_shader_part_unref(device, prolog);
       free(key2);
       u_rwlock_wrunlock(&device->vs_prologs_lock);
       return NULL;
    }
-   memcpy(key2, key_words, key_size * 4);
+   memcpy(key2, key_words, key_size * sizeof(uint32_t));
    _mesa_hash_table_insert_pre_hashed(device->vs_prologs, hash, key2, prolog);
    _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, hash, key2, prolog);
 
-- 
GitLab


From 1c5ea3a45ea28d3c43cc44e6c4f52eaf98d7d5ba Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 11:38:30 -0400
Subject: [PATCH 04/14] radv: move/rename vs_prolog_key_header to header file

no functional changes
---
 src/amd/vulkan/radv_cmd_buffer.c | 29 ++++-------------------------
 src/amd/vulkan/radv_shader.h     | 21 +++++++++++++++++++++
 2 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 925aa31e22cf..d57de76e8c47 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3637,32 +3637,11 @@ radv_instance_rate_prolog_index(unsigned num_attributes, uint32_t instance_rate_
    return start_index + offset_from_start_index + first;
 }
 
-union vs_prolog_key_header {
-   struct {
-      uint32_t key_size : 8;
-      uint32_t num_attributes : 6;
-      uint32_t as_ls : 1;
-      uint32_t is_ngg : 1;
-      uint32_t wave32 : 1;
-      uint32_t next_stage : 3;
-      uint32_t instance_rate_inputs : 1;
-      uint32_t alpha_adjust_lo : 1;
-      uint32_t alpha_adjust_hi : 1;
-      uint32_t misaligned_mask : 1;
-      uint32_t post_shuffle : 1;
-      uint32_t nontrivial_divisors : 1;
-      uint32_t zero_divisors : 1;
-      /* We need this to ensure the padding is zero. It's useful even if it's unused. */
-      uint32_t padding0 : 5;
-   };
-   uint32_t v;
-};
-
 uint32_t
 radv_hash_vs_prolog(const void *key_)
 {
    const uint32_t *key = key_;
-   union vs_prolog_key_header header;
+   union radv_vs_prolog_key_header header;
    header.v = key[0];
    return _mesa_hash_data(key, header.key_size);
 }
@@ -3675,7 +3654,7 @@ radv_cmp_vs_prolog(const void *a_, const void *b_)
    if (a[0] != b[0])
       return false;
 
-   union vs_prolog_key_header header;
+   union radv_vs_prolog_key_header header;
    header.v = a[0];
    return memcmp(a, b, header.key_size) == 0;
 }
@@ -3683,7 +3662,7 @@ radv_cmp_vs_prolog(const void *a_, const void *b_)
 static struct radv_shader_part *
 lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *vs_shader, uint32_t *nontrivial_divisors)
 {
-   STATIC_ASSERT(sizeof(union vs_prolog_key_header) == 4);
+   STATIC_ASSERT(sizeof(union radv_vs_prolog_key_header) == 4);
    assert(vs_shader->info.vs.dynamic_inputs);
 
    const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
@@ -3760,7 +3739,7 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    key.wave32 = vs_shader->info.wave_size == 32;
    key.next_stage = ffs(cmd_buffer->state.active_stages) - 1;
 
-   union vs_prolog_key_header header;
+   union radv_vs_prolog_key_header header;
    header.v = 0;
    header.num_attributes = num_attributes;
    header.as_ls = key.as_ls;
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index a93dc6faa181..0253bbd1ec28 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -461,6 +461,27 @@ struct radv_vs_prolog_key {
    gl_shader_stage next_stage;
 };
 
+union radv_vs_prolog_key_header {
+   struct {
+      uint32_t key_size : 8;
+      uint32_t num_attributes : 6;
+      uint32_t as_ls : 1;
+      uint32_t is_ngg : 1;
+      uint32_t wave32 : 1;
+      uint32_t next_stage : 3;
+      uint32_t instance_rate_inputs : 1;
+      uint32_t alpha_adjust_lo : 1;
+      uint32_t alpha_adjust_hi : 1;
+      uint32_t misaligned_mask : 1;
+      uint32_t post_shuffle : 1;
+      uint32_t nontrivial_divisors : 1;
+      uint32_t zero_divisors : 1;
+      /* We need this to ensure the padding is zero. It's useful even if it's unused. */
+      uint32_t padding0 : 5;
+   };
+   uint32_t v;
+};
+
 enum radv_shader_binary_type { RADV_BINARY_TYPE_LEGACY, RADV_BINARY_TYPE_RTLD };
 
 struct radv_shader_binary {
-- 
GitLab


From 7de49879d00b6f4ec403469e1a7edd4018bfa50c Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 11:38:57 -0400
Subject: [PATCH 05/14] radv: inline vs prologs onto the prolog key and use a
 set to store

this stores the prolog at the end of the prolog key words, enabling a
set to be used instead of a hash table

should be no functional changes
---
 src/amd/vulkan/radv_cmd_buffer.c | 29 ++++++++++++++++-------------
 src/amd/vulkan/radv_device.c     | 10 ++++++----
 src/amd/vulkan/radv_private.h    |  4 ++--
 3 files changed, 24 insertions(+), 19 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d57de76e8c47..4ef030dbe587 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -368,7 +368,7 @@ radv_create_cmd_buffer(struct vk_command_pool *pool, struct vk_command_buffer **
    }
 
    if (device->vs_prologs)
-      _mesa_hash_table_init(&cmd_buffer->vs_prologs, NULL, &radv_hash_vs_prolog, &radv_cmp_vs_prolog);
+      _mesa_set_init(&cmd_buffer->vs_prologs, NULL, radv_hash_vs_prolog, radv_cmp_vs_prolog);
 
    vk_object_base_init(&device->vk, &cmd_buffer->meta_push_descriptors.base,
                        VK_OBJECT_TYPE_DESCRIPTOR_SET);
@@ -3794,32 +3794,32 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
        radv_cmp_vs_prolog(key_words, cmd_buffer->state.emitted_vs_prolog_key))
       return cmd_buffer->state.emitted_vs_prolog;
 
-   struct hash_entry *prolog_entry = NULL;
+   struct set_entry *prolog_entry = NULL;
    if (cmd_buffer->vs_prologs.entries) {
-      prolog_entry = _mesa_hash_table_search_pre_hashed(&cmd_buffer->vs_prologs, hash, key_words);
+      prolog_entry = _mesa_set_search_pre_hashed(&cmd_buffer->vs_prologs, hash, key_words);
       if (prolog_entry)
-         return prolog_entry->data;
+         return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
    }
 
    u_rwlock_rdlock(&device->vs_prologs_lock);
-   prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
+   prolog_entry = _mesa_set_search_pre_hashed(device->vs_prologs, hash, key_words);
    u_rwlock_rdunlock(&device->vs_prologs_lock);
 
    if (prolog_entry) {
-      _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key, prolog_entry->data);
-      return prolog_entry->data;
+      _mesa_set_add_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key);
+      return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
    }
 
    u_rwlock_wrlock(&device->vs_prologs_lock);
-   prolog_entry = _mesa_hash_table_search_pre_hashed(device->vs_prologs, hash, key_words);
+   prolog_entry = _mesa_set_search_pre_hashed(device->vs_prologs, hash, key_words);
    if (prolog_entry) {
       u_rwlock_wrunlock(&device->vs_prologs_lock);
-      _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key, prolog_entry->data);
-      return prolog_entry->data;
+      _mesa_set_add_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key);
+      return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
    }
 
    prolog = radv_create_vs_prolog(device, &key);
-   uint32_t *key2 = malloc(key_size * sizeof(uint32_t));
+   uint32_t *key2 = malloc(key_size * sizeof(uint32_t) + sizeof(void*));
    if (!prolog || !key2) {
       radv_shader_part_unref(device, prolog);
       free(key2);
@@ -3827,8 +3827,11 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
       return NULL;
    }
    memcpy(key2, key_words, key_size * sizeof(uint32_t));
-   _mesa_hash_table_insert_pre_hashed(device->vs_prologs, hash, key2, prolog);
-   _mesa_hash_table_insert_pre_hashed(&cmd_buffer->vs_prologs, hash, key2, prolog);
+   void **ptr = (void**)(key2 + key_size);
+   *ptr = prolog;
+
+   _mesa_set_add_pre_hashed(device->vs_prologs, hash, key2);
+   _mesa_set_add_pre_hashed(&cmd_buffer->vs_prologs, hash, key2);
 
    u_rwlock_wrunlock(&device->vs_prologs_lock);
    return prolog;
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index d1f0053ebf2d..9393c2288051 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -158,7 +158,7 @@ static VkResult
 radv_device_init_vs_prologs(struct radv_device *device)
 {
    u_rwlock_init(&device->vs_prologs_lock);
-   device->vs_prologs = _mesa_hash_table_create(NULL, &radv_hash_vs_prolog, &radv_cmp_vs_prolog);
+   device->vs_prologs = _mesa_set_create(NULL, &radv_hash_vs_prolog, &radv_cmp_vs_prolog);
    if (!device->vs_prologs)
       return vk_error(device->physical_device->instance, VK_ERROR_OUT_OF_HOST_MEMORY);
 
@@ -223,11 +223,13 @@ static void
 radv_device_finish_vs_prologs(struct radv_device *device)
 {
    if (device->vs_prologs) {
-      hash_table_foreach (device->vs_prologs, entry) {
+      set_foreach(device->vs_prologs, entry) {
+         const union radv_vs_prolog_key_header *header = entry->key;
+         struct radv_shader_part *prolog = *(void**)(((uint32_t*)entry->key) + (header->key_size / sizeof(uint32_t)));
          free((void *)entry->key);
-         radv_shader_part_unref(device, entry->data);
+         radv_shader_part_unref(device, prolog);
       }
-      _mesa_hash_table_destroy(device->vs_prologs, NULL);
+      _mesa_set_destroy(device->vs_prologs, NULL);
    }
 
    for (unsigned i = 0; i < ARRAY_SIZE(device->simple_vs_prologs); i++) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 6dcd271a14ba..6583ed8188f0 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1075,7 +1075,7 @@ struct radv_device {
    } vrs;
 
    struct u_rwlock vs_prologs_lock;
-   struct hash_table *vs_prologs;
+   struct set *vs_prologs;
 
    /* Prime blit sdma queue */
    struct radv_queue *private_sdma_queue;
@@ -1859,7 +1859,7 @@ struct radv_cmd_buffer {
 
    uint32_t sqtt_cb_id;
 
-   struct hash_table vs_prologs;
+   struct set vs_prologs;
 };
 
 static inline bool
-- 
GitLab


From 99d7bda6ec3640c714346ea59f1074b9b2d1e6ec Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 11:43:24 -0400
Subject: [PATCH 06/14] radv: use search_or_add for vs prolog management

this reduces both lookups and locking to improve perf
---
 src/amd/vulkan/radv_cmd_buffer.c | 31 +++++++++++--------------------
 1 file changed, 11 insertions(+), 20 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 4ef030dbe587..f3ed84af560e 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3794,27 +3794,18 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
        radv_cmp_vs_prolog(key_words, cmd_buffer->state.emitted_vs_prolog_key))
       return cmd_buffer->state.emitted_vs_prolog;
 
-   struct set_entry *prolog_entry = NULL;
-   if (cmd_buffer->vs_prologs.entries) {
-      prolog_entry = _mesa_set_search_pre_hashed(&cmd_buffer->vs_prologs, hash, key_words);
-      if (prolog_entry)
-         return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
-   }
-
-   u_rwlock_rdlock(&device->vs_prologs_lock);
-   prolog_entry = _mesa_set_search_pre_hashed(device->vs_prologs, hash, key_words);
-   u_rwlock_rdunlock(&device->vs_prologs_lock);
-
-   if (prolog_entry) {
-      _mesa_set_add_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key);
-      return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
-   }
+   bool found = false;
+   bool cfound = false;
+   struct set_entry *cmdbuf_prolog_entry = _mesa_set_search_or_add_pre_hashed(&cmd_buffer->vs_prologs, hash, key_words, &cfound);
+   if (cfound)
+      return *(void**)(((uint32_t*)cmdbuf_prolog_entry->key) + key_size);
 
    u_rwlock_wrlock(&device->vs_prologs_lock);
-   prolog_entry = _mesa_set_search_pre_hashed(device->vs_prologs, hash, key_words);
-   if (prolog_entry) {
+   struct set_entry *prolog_entry = _mesa_set_search_or_add_pre_hashed(device->vs_prologs, hash, key_words, &found);
+
+   if (found) {
       u_rwlock_wrunlock(&device->vs_prologs_lock);
-      _mesa_set_add_pre_hashed(&cmd_buffer->vs_prologs, prolog_entry->hash, prolog_entry->key);
+      cmdbuf_prolog_entry->key = prolog_entry->key;
       return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
    }
 
@@ -3830,8 +3821,8 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    void **ptr = (void**)(key2 + key_size);
    *ptr = prolog;
 
-   _mesa_set_add_pre_hashed(device->vs_prologs, hash, key2);
-   _mesa_set_add_pre_hashed(&cmd_buffer->vs_prologs, hash, key2);
+   prolog_entry->key = key2;
+   cmdbuf_prolog_entry->key = key2;
 
    u_rwlock_wrunlock(&device->vs_prologs_lock);
    return prolog;
-- 
GitLab


From f5b3e9dba35262190db9dda3f7e8851df77c6dff Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 11:48:22 -0400
Subject: [PATCH 07/14] radv: outdent epilog lookup code

no functional changes
---
 src/amd/vulkan/radv_cmd_buffer.c | 39 ++++++++++++++++----------------
 1 file changed, 19 insertions(+), 20 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index f3ed84af560e..679e6ee4fe21 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4212,30 +4212,29 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    struct hash_entry *epilog_entry = _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
    u_rwlock_rdunlock(&device->ps_epilogs_lock);
 
-   if (!epilog_entry) {
-      u_rwlock_wrlock(&device->ps_epilogs_lock);
-      epilog_entry = _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
-      if (epilog_entry) {
-         u_rwlock_wrunlock(&device->ps_epilogs_lock);
-         return epilog_entry->data;
-      }
-
-      epilog = radv_create_ps_epilog(device, &key, NULL);
-      struct radv_ps_epilog_key *key2 = malloc(sizeof(*key2));
-      if (!epilog || !key2) {
-         radv_shader_part_unref(device, epilog);
-         free(key2);
-         u_rwlock_wrunlock(&device->ps_epilogs_lock);
-         return NULL;
-      }
-      memcpy(key2, &key, sizeof(*key2));
-      _mesa_hash_table_insert_pre_hashed(device->ps_epilogs, hash, key2, epilog);
+   if (epilog_entry)
+      return epilog_entry->data;
 
+   u_rwlock_wrlock(&device->ps_epilogs_lock);
+   epilog_entry = _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
+   if (epilog_entry) {
       u_rwlock_wrunlock(&device->ps_epilogs_lock);
-      return epilog;
+      return epilog_entry->data;
+   }
+
+   epilog = radv_create_ps_epilog(device, &key, NULL);
+   struct radv_ps_epilog_key *key2 = malloc(sizeof(*key2));
+   if (!epilog || !key2) {
+      radv_shader_part_unref(device, epilog);
+      free(key2);
+      u_rwlock_wrunlock(&device->ps_epilogs_lock);
+      return NULL;
    }
+   memcpy(key2, &key, sizeof(*key2));
+   _mesa_hash_table_insert_pre_hashed(device->ps_epilogs, hash, key2, epilog);
 
-   return epilog_entry->data;
+   u_rwlock_wrunlock(&device->ps_epilogs_lock);
+   return epilog;
 }
 
 static void
-- 
GitLab


From 20fa9d3860c2a7f1bc79b1bd131172471e714fb1 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 11:52:23 -0400
Subject: [PATCH 08/14] radv: inline ps epilog onto the key and use a set

this mimics prolog changes and will allow further optimizations
---
 src/amd/vulkan/radv_cmd_buffer.c | 15 ++++++++-------
 src/amd/vulkan/radv_device.c     | 11 ++++++-----
 src/amd/vulkan/radv_private.h    |  2 +-
 src/amd/vulkan/radv_shader.h     |  5 +++++
 4 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 679e6ee4fe21..1b0e594e26d3 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4209,29 +4209,30 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    uint32_t hash = radv_hash_ps_epilog(&key);
 
    u_rwlock_rdlock(&device->ps_epilogs_lock);
-   struct hash_entry *epilog_entry = _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
+   struct set_entry *epilog_entry = _mesa_set_search_pre_hashed(device->ps_epilogs, hash, &key);
    u_rwlock_rdunlock(&device->ps_epilogs_lock);
 
    if (epilog_entry)
-      return epilog_entry->data;
+      return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
 
    u_rwlock_wrlock(&device->ps_epilogs_lock);
-   epilog_entry = _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
+   epilog_entry = _mesa_set_search_pre_hashed(device->ps_epilogs, hash, &key);
    if (epilog_entry) {
       u_rwlock_wrunlock(&device->ps_epilogs_lock);
-      return epilog_entry->data;
+      return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
    }
 
    epilog = radv_create_ps_epilog(device, &key, NULL);
-   struct radv_ps_epilog_key *key2 = malloc(sizeof(*key2));
+   struct radv_ps_epilog *key2 = malloc(sizeof(*key2));
    if (!epilog || !key2) {
       radv_shader_part_unref(device, epilog);
       free(key2);
       u_rwlock_wrunlock(&device->ps_epilogs_lock);
       return NULL;
    }
-   memcpy(key2, &key, sizeof(*key2));
-   _mesa_hash_table_insert_pre_hashed(device->ps_epilogs, hash, key2, epilog);
+   memcpy(&key2->key, &key, sizeof(key));
+   key2->epilog = epilog;
+   _mesa_set_add_pre_hashed(device->ps_epilogs, hash, key2);
 
    u_rwlock_wrunlock(&device->ps_epilogs_lock);
    return epilog;
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 9393c2288051..22d2f32e3037 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -252,7 +252,7 @@ radv_device_init_ps_epilogs(struct radv_device *device)
 {
    u_rwlock_init(&device->ps_epilogs_lock);
 
-   device->ps_epilogs = _mesa_hash_table_create(NULL, &radv_hash_ps_epilog, &radv_cmp_ps_epilog);
+   device->ps_epilogs = _mesa_set_create(NULL, &radv_hash_ps_epilog, &radv_cmp_ps_epilog);
    if (!device->ps_epilogs)
       return vk_error(device->physical_device->instance, VK_ERROR_OUT_OF_HOST_MEMORY);
 
@@ -263,11 +263,12 @@ static void
 radv_device_finish_ps_epilogs(struct radv_device *device)
 {
    if (device->ps_epilogs) {
-      hash_table_foreach (device->ps_epilogs, entry) {
-         free((void *)entry->key);
-         radv_shader_part_unref(device, entry->data);
+      set_foreach(device->ps_epilogs, entry) {
+         struct radv_ps_epilog *epilog = (void*)entry->key;
+         radv_shader_part_unref(device, epilog->epilog);
+         free(epilog);
       }
-      _mesa_hash_table_destroy(device->ps_epilogs, NULL);
+      _mesa_set_destroy(device->ps_epilogs, NULL);
    }
 }
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 6583ed8188f0..0d92df3cca2d 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1085,7 +1085,7 @@ struct radv_device {
 
    /* PS epilogs */
    struct u_rwlock ps_epilogs_lock;
-   struct hash_table *ps_epilogs;
+   struct set *ps_epilogs;
 
    simple_mtx_t trace_mtx;
 
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 0253bbd1ec28..e027ce88050a 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -60,6 +60,11 @@ struct radv_ps_epilog_key {
    bool mrt0_is_dual_src;
 };
 
+struct radv_ps_epilog {
+   struct radv_ps_epilog_key key;
+   struct radv_shader_part *epilog;
+};
+
 struct radv_pipeline_key {
    uint32_t lib_flags : 4; /* VkGraphicsPipelineLibraryFlagBitsEXT */
 
-- 
GitLab


From 89de5acae934619e1e3b1cbcebc2ef475cbee4a5 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 11:57:01 -0400
Subject: [PATCH 09/14] radv: use search_or_add for epilog management

this reduces the number of lookups and locks, which improves perf
---
 src/amd/vulkan/radv_cmd_buffer.c | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 1b0e594e26d3..82a033308793 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4208,16 +4208,11 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    struct radv_ps_epilog_key key = radv_generate_ps_epilog_key(device, &state, true);
    uint32_t hash = radv_hash_ps_epilog(&key);
 
-   u_rwlock_rdlock(&device->ps_epilogs_lock);
-   struct set_entry *epilog_entry = _mesa_set_search_pre_hashed(device->ps_epilogs, hash, &key);
-   u_rwlock_rdunlock(&device->ps_epilogs_lock);
-
-   if (epilog_entry)
-      return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
-
+   bool found = false;
    u_rwlock_wrlock(&device->ps_epilogs_lock);
-   epilog_entry = _mesa_set_search_pre_hashed(device->ps_epilogs, hash, &key);
-   if (epilog_entry) {
+   struct set_entry *epilog_entry = _mesa_set_search_or_add_pre_hashed(device->ps_epilogs, hash, &key, &found);
+
+   if (found) {
       u_rwlock_wrunlock(&device->ps_epilogs_lock);
       return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
    }
@@ -4232,7 +4227,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    }
    memcpy(&key2->key, &key, sizeof(key));
    key2->epilog = epilog;
-   _mesa_set_add_pre_hashed(device->ps_epilogs, hash, key2);
+   epilog_entry->key = key2;
 
    u_rwlock_wrunlock(&device->ps_epilogs_lock);
    return epilog;
-- 
GitLab


From 7788f84d8a92fa645bc1621fbff1f4058d5d6b7e Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 10:45:51 -0400
Subject: [PATCH 10/14] radv: add a ps_epilogs table to cmdbufs

the device hash table is under lock, which is extremely painful in
cpu-intensive scenarios. by adding the used epilogs to cmdbufs, the lock
is bypassed and perf increases
---
 src/amd/vulkan/radv_cmd_buffer.c | 10 ++++++++++
 src/amd/vulkan/radv_private.h    |  1 +
 2 files changed, 11 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 82a033308793..85b526d06b2c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -329,6 +329,7 @@ radv_destroy_cmd_buffer(struct vk_command_buffer *vk_cmd_buffer)
       vk_object_base_finish(&set->base);
    }
    ralloc_free(cmd_buffer->vs_prologs.table);
+   ralloc_free(cmd_buffer->ps_epilogs.table);
 
    vk_object_base_finish(&cmd_buffer->meta_push_descriptors.base);
 
@@ -369,6 +370,8 @@ radv_create_cmd_buffer(struct vk_command_pool *pool, struct vk_command_buffer **
 
    if (device->vs_prologs)
       _mesa_set_init(&cmd_buffer->vs_prologs, NULL, radv_hash_vs_prolog, radv_cmp_vs_prolog);
+   if (device->ps_epilogs)
+      _mesa_set_init(&cmd_buffer->ps_epilogs, NULL, radv_hash_ps_epilog, radv_cmp_ps_epilog);
 
    vk_object_base_init(&device->vk, &cmd_buffer->meta_push_descriptors.base,
                        VK_OBJECT_TYPE_DESCRIPTOR_SET);
@@ -4208,12 +4211,18 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    struct radv_ps_epilog_key key = radv_generate_ps_epilog_key(device, &state, true);
    uint32_t hash = radv_hash_ps_epilog(&key);
 
+   bool cfound = false;
+   struct set_entry *cmd_epilog_entry = _mesa_set_search_or_add_pre_hashed(&cmd_buffer->ps_epilogs, hash, &key, &cfound);
+   if (cfound)
+      return ((struct radv_ps_epilog*)cmd_epilog_entry->key)->epilog;
+
    bool found = false;
    u_rwlock_wrlock(&device->ps_epilogs_lock);
    struct set_entry *epilog_entry = _mesa_set_search_or_add_pre_hashed(device->ps_epilogs, hash, &key, &found);
 
    if (found) {
       u_rwlock_wrunlock(&device->ps_epilogs_lock);
+      cmd_epilog_entry->key = epilog_entry->key;
       return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
    }
 
@@ -4228,6 +4237,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    memcpy(&key2->key, &key, sizeof(key));
    key2->epilog = epilog;
    epilog_entry->key = key2;
+   cmd_epilog_entry->key = key2;
 
    u_rwlock_wrunlock(&device->ps_epilogs_lock);
    return epilog;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 0d92df3cca2d..bd43fa34dbd1 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1860,6 +1860,7 @@ struct radv_cmd_buffer {
    uint32_t sqtt_cb_id;
 
    struct set vs_prologs;
+   struct set ps_epilogs;
 };
 
 static inline bool
-- 
GitLab


From 6c6c5ef01f961a22dcc9ebfd68c7b8c65c39f84d Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 12:07:59 -0400
Subject: [PATCH 11/14] radv: use a union for better sizing of epilog keys

this is a little less hacky
---
 src/amd/vulkan/radv_pipeline_graphics.c |  4 +---
 src/amd/vulkan/radv_shader.h            | 21 +++++++++++++--------
 2 files changed, 14 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline_graphics.c b/src/amd/vulkan/radv_pipeline_graphics.c
index bcf0dbe78ce2..e8c95c5e214c 100644
--- a/src/amd/vulkan/radv_pipeline_graphics.c
+++ b/src/amd/vulkan/radv_pipeline_graphics.c
@@ -1688,9 +1688,7 @@ radv_generate_ps_epilog_key(const struct radv_device *device, const struct radv_
                             bool disable_mrt_compaction)
 {
    unsigned col_format = 0, is_int8 = 0, is_int10 = 0, is_float32 = 0;
-   struct radv_ps_epilog_key key;
-
-   memset(&key, 0, sizeof(key));
+   struct radv_ps_epilog_key key = {.val = 0};
 
    for (unsigned i = 0; i < state->color_attachment_count; ++i) {
       unsigned cf;
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index e027ce88050a..e581267ae553 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -50,14 +50,19 @@ struct radv_vs_input_state;
 struct radv_shader_args;
 
 struct radv_ps_epilog_key {
-   uint32_t spi_shader_col_format;
-
-   /* Bitmasks, each bit represents one of the 8 MRTs. */
-   uint8_t color_is_int8;
-   uint8_t color_is_int10;
-   uint8_t enable_mrt_output_nan_fixup;
-
-   bool mrt0_is_dual_src;
+   union {
+      struct {
+         uint32_t spi_shader_col_format;
+
+         /* Bitmasks, each bit represents one of the 8 MRTs. */
+         uint8_t color_is_int8;
+         uint8_t color_is_int10;
+         uint8_t enable_mrt_output_nan_fixup;
+
+         bool mrt0_is_dual_src;
+      };
+      uint64_t val;
+   };
 };
 
 struct radv_ps_epilog {
-- 
GitLab


From 2c7067e0a99e80f6a9676ce3c9ad74bde267b495 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 12:23:43 -0400
Subject: [PATCH 12/14] radv: fix last vs prolog reuse mechanism

AFAICS this was never initialized, so the shortcut was never used
---
 src/amd/vulkan/radv_cmd_buffer.c | 13 +++++++++++--
 src/amd/vulkan/radv_private.h    |  2 +-
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 85b526d06b2c..72b4a2862bb2 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3725,8 +3725,11 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
          prolog = device->instance_rate_vs_prologs[index];
       }
    }
-   if (prolog)
+   if (prolog) {
+      cmd_buffer->state.emitted_vs_prolog_key_hash = 0;
+      cmd_buffer->state.emitted_vs_prolog_key = NULL;
       return prolog;
+   }
 
    /* if we couldn't use a pre-compiled prolog, find one in the cache or create one */
    uint32_t key_words[17];
@@ -3797,17 +3800,22 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
        radv_cmp_vs_prolog(key_words, cmd_buffer->state.emitted_vs_prolog_key))
       return cmd_buffer->state.emitted_vs_prolog;
 
+   cmd_buffer->state.emitted_vs_prolog_key_hash = hash;
+
    bool found = false;
    bool cfound = false;
    struct set_entry *cmdbuf_prolog_entry = _mesa_set_search_or_add_pre_hashed(&cmd_buffer->vs_prologs, hash, key_words, &cfound);
-   if (cfound)
+   if (cfound) {
+      cmd_buffer->state.emitted_vs_prolog_key = cmdbuf_prolog_entry->key;
       return *(void**)(((uint32_t*)cmdbuf_prolog_entry->key) + key_size);
+   }
 
    u_rwlock_wrlock(&device->vs_prologs_lock);
    struct set_entry *prolog_entry = _mesa_set_search_or_add_pre_hashed(device->vs_prologs, hash, key_words, &found);
 
    if (found) {
       u_rwlock_wrunlock(&device->vs_prologs_lock);
+      cmd_buffer->state.emitted_vs_prolog_key = prolog_entry->key;
       cmdbuf_prolog_entry->key = prolog_entry->key;
       return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
    }
@@ -3826,6 +3834,7 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
 
    prolog_entry->key = key2;
    cmdbuf_prolog_entry->key = key2;
+   cmd_buffer->state.emitted_vs_prolog_key = prolog_entry->key;
 
    u_rwlock_wrunlock(&device->vs_prologs_lock);
    return prolog;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index bd43fa34dbd1..64f78aea2388 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1707,7 +1707,7 @@ struct radv_cmd_state {
    uint32_t rt_stack_size;
 
    struct radv_shader_part *emitted_vs_prolog;
-   uint32_t *emitted_vs_prolog_key;
+   const uint32_t *emitted_vs_prolog_key;
    uint32_t emitted_vs_prolog_key_hash;
    uint32_t vbo_misaligned_mask;
    uint32_t vbo_misaligned_mask_invalid;
-- 
GitLab


From 1f3bbd3475bee742e191e2c734659944a3225973 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 8 Jun 2023 12:26:02 -0400
Subject: [PATCH 13/14] radv: add a last ps epilog reuse mechanism

this shortcuts hash lookups when reusing the same epilog, same as
vs prologs
---
 src/amd/vulkan/radv_cmd_buffer.c | 13 ++++++++++++-
 src/amd/vulkan/radv_private.h    |  2 ++
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 72b4a2862bb2..55ab75ef8d3a 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4220,10 +4220,19 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    struct radv_ps_epilog_key key = radv_generate_ps_epilog_key(device, &state, true);
    uint32_t hash = radv_hash_ps_epilog(&key);
 
+   if (cmd_buffer->state.emitted_ps_epilog &&
+       cmd_buffer->state.emitted_ps_epilog_key_hash == hash &&
+       radv_cmp_ps_epilog(&key, cmd_buffer->state.emitted_ps_epilog_key))
+      return cmd_buffer->state.emitted_ps_epilog;
+
+   cmd_buffer->state.emitted_ps_epilog_key_hash = hash;
+
    bool cfound = false;
    struct set_entry *cmd_epilog_entry = _mesa_set_search_or_add_pre_hashed(&cmd_buffer->ps_epilogs, hash, &key, &cfound);
-   if (cfound)
+   if (cfound) {
+      cmd_buffer->state.emitted_ps_epilog_key = cmd_epilog_entry->key;
       return ((struct radv_ps_epilog*)cmd_epilog_entry->key)->epilog;
+   }
 
    bool found = false;
    u_rwlock_wrlock(&device->ps_epilogs_lock);
@@ -4231,6 +4240,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
 
    if (found) {
       u_rwlock_wrunlock(&device->ps_epilogs_lock);
+      cmd_buffer->state.emitted_ps_epilog_key = epilog_entry->key;
       cmd_epilog_entry->key = epilog_entry->key;
       return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
    }
@@ -4247,6 +4257,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    key2->epilog = epilog;
    epilog_entry->key = key2;
    cmd_epilog_entry->key = key2;
+   cmd_buffer->state.emitted_ps_epilog_key = epilog_entry->key;
 
    u_rwlock_wrunlock(&device->ps_epilogs_lock);
    return epilog;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 64f78aea2388..d146b67164e3 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1713,6 +1713,8 @@ struct radv_cmd_state {
    uint32_t vbo_misaligned_mask_invalid;
    uint32_t vbo_bound_mask;
 
+   const struct radv_ps_epilog_key *emitted_ps_epilog_key;
+   uint32_t emitted_ps_epilog_key_hash;
    struct radv_shader_part *emitted_ps_epilog;
 
    /* Per-vertex VRS state. */
-- 
GitLab


From aaca0902fa82cbeebe62af6fd4430cd4bd5595b9 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 28 Jun 2023 11:02:17 -0400
Subject: [PATCH 14/14] radv: replace wrlocks with simple_mtx for
 prologs/epilogs

wrlocks are no longer necessary now that there is only one point of
lock/unlock
---
 src/amd/vulkan/radv_cmd_buffer.c | 16 ++++++++--------
 src/amd/vulkan/radv_device.c     |  6 ++++--
 src/amd/vulkan/radv_private.h    |  4 ++--
 3 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 55ab75ef8d3a..c8605844816b 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -3810,11 +3810,11 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
       return *(void**)(((uint32_t*)cmdbuf_prolog_entry->key) + key_size);
    }
 
-   u_rwlock_wrlock(&device->vs_prologs_lock);
+   simple_mtx_lock(&device->vs_prologs_lock);
    struct set_entry *prolog_entry = _mesa_set_search_or_add_pre_hashed(device->vs_prologs, hash, key_words, &found);
 
    if (found) {
-      u_rwlock_wrunlock(&device->vs_prologs_lock);
+      simple_mtx_unlock(&device->vs_prologs_lock);
       cmd_buffer->state.emitted_vs_prolog_key = prolog_entry->key;
       cmdbuf_prolog_entry->key = prolog_entry->key;
       return *(void**)(((uint32_t*)prolog_entry->key) + key_size);
@@ -3825,7 +3825,7 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    if (!prolog || !key2) {
       radv_shader_part_unref(device, prolog);
       free(key2);
-      u_rwlock_wrunlock(&device->vs_prologs_lock);
+      simple_mtx_unlock(&device->vs_prologs_lock);
       return NULL;
    }
    memcpy(key2, key_words, key_size * sizeof(uint32_t));
@@ -3836,7 +3836,7 @@ lookup_vs_prolog(struct radv_cmd_buffer *cmd_buffer, const struct radv_shader *v
    cmdbuf_prolog_entry->key = key2;
    cmd_buffer->state.emitted_vs_prolog_key = prolog_entry->key;
 
-   u_rwlock_wrunlock(&device->vs_prologs_lock);
+   simple_mtx_unlock(&device->vs_prologs_lock);
    return prolog;
 }
 
@@ -4235,11 +4235,11 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    }
 
    bool found = false;
-   u_rwlock_wrlock(&device->ps_epilogs_lock);
+   simple_mtx_lock(&device->ps_epilogs_lock);
    struct set_entry *epilog_entry = _mesa_set_search_or_add_pre_hashed(device->ps_epilogs, hash, &key, &found);
 
    if (found) {
-      u_rwlock_wrunlock(&device->ps_epilogs_lock);
+      simple_mtx_unlock(&device->ps_epilogs_lock);
       cmd_buffer->state.emitted_ps_epilog_key = epilog_entry->key;
       cmd_epilog_entry->key = epilog_entry->key;
       return ((struct radv_ps_epilog*)epilog_entry->key)->epilog;
@@ -4250,7 +4250,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    if (!epilog || !key2) {
       radv_shader_part_unref(device, epilog);
       free(key2);
-      u_rwlock_wrunlock(&device->ps_epilogs_lock);
+      simple_mtx_unlock(&device->ps_epilogs_lock);
       return NULL;
    }
    memcpy(&key2->key, &key, sizeof(key));
@@ -4259,7 +4259,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    cmd_epilog_entry->key = key2;
    cmd_buffer->state.emitted_ps_epilog_key = epilog_entry->key;
 
-   u_rwlock_wrunlock(&device->ps_epilogs_lock);
+   simple_mtx_unlock(&device->ps_epilogs_lock);
    return epilog;
 }
 
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 22d2f32e3037..ab98cc9bf2f8 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -157,7 +157,7 @@ radv_device_finish_border_color(struct radv_device *device)
 static VkResult
 radv_device_init_vs_prologs(struct radv_device *device)
 {
-   u_rwlock_init(&device->vs_prologs_lock);
+   simple_mtx_init(&device->vs_prologs_lock, mtx_plain);
    device->vs_prologs = _mesa_set_create(NULL, &radv_hash_vs_prolog, &radv_cmp_vs_prolog);
    if (!device->vs_prologs)
       return vk_error(device->physical_device->instance, VK_ERROR_OUT_OF_HOST_MEMORY);
@@ -245,12 +245,13 @@ radv_device_finish_vs_prologs(struct radv_device *device)
 
       radv_shader_part_unref(device, device->instance_rate_vs_prologs[i]);
    }
+   simple_mtx_destroy(&device->vs_prologs_lock);
 }
 
 static VkResult
 radv_device_init_ps_epilogs(struct radv_device *device)
 {
-   u_rwlock_init(&device->ps_epilogs_lock);
+   simple_mtx_init(&device->ps_epilogs_lock, mtx_plain);
 
    device->ps_epilogs = _mesa_set_create(NULL, &radv_hash_ps_epilog, &radv_cmp_ps_epilog);
    if (!device->ps_epilogs)
@@ -270,6 +271,7 @@ radv_device_finish_ps_epilogs(struct radv_device *device)
       }
       _mesa_set_destroy(device->ps_epilogs, NULL);
    }
+   simple_mtx_destroy(&device->ps_epilogs_lock);
 }
 
 VkResult
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index d146b67164e3..27337cec9ab2 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1074,7 +1074,7 @@ struct radv_device {
       struct radv_device_memory *mem;
    } vrs;
 
-   struct u_rwlock vs_prologs_lock;
+   simple_mtx_t vs_prologs_lock;
    struct set *vs_prologs;
 
    /* Prime blit sdma queue */
@@ -1084,7 +1084,7 @@ struct radv_device {
    struct radv_shader_part *instance_rate_vs_prologs[816];
 
    /* PS epilogs */
-   struct u_rwlock ps_epilogs_lock;
+   simple_mtx_t ps_epilogs_lock;
    struct set *ps_epilogs;
 
    simple_mtx_t trace_mtx;
-- 
GitLab

