From 25fcca79592082a6d90a05f9202d35441a48a970 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Tue, 11 Jun 2024 11:15:01 -0400
Subject: [PATCH] mesa/st: fix zombie shader handling for non-current programs

for drivers that don't support PIPE_CAP_SHAREABLE_SHADERS,
the zombie shader mechanism is used, storing shaders to delete after
the next flush

the zombie mechanism also calls bind_*_state(pipe, NULL) during deletion,
however, which breaks drivers in the following scenario:

* create_all_shaders(pipe_A)
* bind_vs(pipe_A, vs_A)
* bind_fs(pipe_A, fs_A)
* draw(pipe_A)
* makeCurrent(pipe_B)
* delete_vs(pipe_B, vs_B)
  * vs_B must only be deleted on pipe_A
  * zombie_shader_add(pipe_A, vs_B)
* makeCurrent(pipe_A)
  * free_zombie_shaders(pipe_A)
    * bind_vs(pipe_A, NULL)
    * delete_vs(pipe_A, vs_B)
* draw(pipe_A)
* boom

the problem being that bind_vs(pipe_A, NULL) was called when deleting
vs_B, but it was actually vs_A which was bound

to solve this, pass through whether the program was active on its context
before queuing zombie deletion, and only unbind the shader(s) if this
condition is true

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/11122

cc: mesa-stable
---
 src/mesa/state_tracker/st_context.c | 22 +++++++++++++++-------
 src/mesa/state_tracker/st_context.h |  4 +++-
 src/mesa/state_tracker/st_program.c |  8 ++++----
 3 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index bc4e435da2708..d31363f0d2ca5 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -211,7 +211,8 @@ st_save_zombie_sampler_view(struct st_context *st,
 void
 st_save_zombie_shader(struct st_context *st,
                       enum pipe_shader_type type,
-                      struct pipe_shader_state *shader)
+                      void *shader,
+                      bool prog_is_active)
 {
    struct st_zombie_shader_node *entry;
 
@@ -224,6 +225,7 @@ st_save_zombie_shader(struct st_context *st,
 
    entry->shader = shader;
    entry->type = type;
+   entry->prog_is_active = prog_is_active;
 
    /* We need a mutex since this function may be called from one thread
     * while free_zombie_shaders() is called from another.
@@ -284,27 +286,33 @@ free_zombie_shaders(struct st_context *st)
 
       switch (entry->type) {
       case PIPE_SHADER_VERTEX:
-         st->pipe->bind_vs_state(st->pipe, NULL);
+         if (entry->prog_is_active)
+            st->pipe->bind_vs_state(st->pipe, NULL);
          st->pipe->delete_vs_state(st->pipe, entry->shader);
          break;
       case PIPE_SHADER_FRAGMENT:
-         st->pipe->bind_fs_state(st->pipe, NULL);
+         if (entry->prog_is_active)
+            st->pipe->bind_fs_state(st->pipe, NULL);
          st->pipe->delete_fs_state(st->pipe, entry->shader);
          break;
       case PIPE_SHADER_GEOMETRY:
-         st->pipe->bind_gs_state(st->pipe, NULL);
+         if (entry->prog_is_active)
+            st->pipe->bind_gs_state(st->pipe, NULL);
          st->pipe->delete_gs_state(st->pipe, entry->shader);
          break;
       case PIPE_SHADER_TESS_CTRL:
-         st->pipe->bind_tcs_state(st->pipe, NULL);
+         if (entry->prog_is_active)
+            st->pipe->bind_tcs_state(st->pipe, NULL);
          st->pipe->delete_tcs_state(st->pipe, entry->shader);
          break;
       case PIPE_SHADER_TESS_EVAL:
-         st->pipe->bind_tes_state(st->pipe, NULL);
+         if (entry->prog_is_active)
+            st->pipe->bind_tes_state(st->pipe, NULL);
          st->pipe->delete_tes_state(st->pipe, entry->shader);
          break;
       case PIPE_SHADER_COMPUTE:
-         st->pipe->bind_compute_state(st->pipe, NULL);
+         if (entry->prog_is_active)
+            st->pipe->bind_compute_state(st->pipe, NULL);
          st->pipe->delete_compute_state(st->pipe, entry->shader);
          break;
       default:
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index b7ea01d36cb66..926df0763ffba 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -117,6 +117,7 @@ struct st_zombie_shader_node
 {
    void *shader;
    enum pipe_shader_type type;
+   bool prog_is_active;
    struct list_head node;
 };
 
@@ -477,7 +478,8 @@ st_save_zombie_sampler_view(struct st_context *st,
 extern void
 st_save_zombie_shader(struct st_context *st,
                       enum pipe_shader_type type,
-                      struct pipe_shader_state *shader);
+                      void *shader,
+                      bool prog_is_active);
 
 
 void
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index f71708a1e9b36..3cb9843c85a25 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -215,7 +215,7 @@ st_set_prog_affected_state_flags(struct gl_program *prog)
  * the linked list.
  */
 static void
-delete_variant(struct st_context *st, struct st_variant *v, GLenum target)
+delete_variant(struct st_context *st, struct st_variant *v, GLenum target, bool prog_is_active)
 {
    if (v->driver_shader) {
       if (target == GL_VERTEX_PROGRAM_ARB &&
@@ -255,7 +255,7 @@ delete_variant(struct st_context *st, struct st_variant *v, GLenum target)
          enum pipe_shader_type type =
             pipe_shader_type_from_mesa(_mesa_program_enum_to_shader_stage(target));
 
-         st_save_zombie_shader(v->st, type, v->driver_shader);
+         st_save_zombie_shader(v->st, type, v->driver_shader, prog_is_active);
       }
    }
 
@@ -314,7 +314,7 @@ st_release_variants(struct st_context *st, struct gl_program *p)
 
    for (v = p->variants; v; ) {
       struct st_variant *next = v->next;
-      delete_variant(st, v, p->Target);
+      delete_variant(st, v, p->Target, p->shader_program == st->ctx->Shader.ActiveProgram);
       v = next;
    }
 
@@ -1213,7 +1213,7 @@ destroy_program_variants(struct st_context *st, struct gl_program *p)
          /* unlink from list */
          *prevPtr = next;
          /* destroy this variant */
-         delete_variant(st, v, p->Target);
+         delete_variant(st, v, p->Target, p->shader_program == st->ctx->Shader.ActiveProgram);
       }
       else {
          prevPtr = &v->next;
-- 
GitLab

