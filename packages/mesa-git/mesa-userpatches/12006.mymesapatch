From 05d7736c080c04756783eefb55e4746da7dce752 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 21 Jul 2021 18:05:12 -0400
Subject: [PATCH 1/5] glx/dri: Use X/GLX error codes for our
 create_context_attribs

This has no functional change because everyone calling this is
discarding the error code, because we're relying on the server to
generate the right thing for us. But we create the direct context first
and the server isn't going to enforce everything we want it to
(supported GL versions for example). Convert out from DRI error codes to
X/GLX error codes so we can fail the right way on the client side. We're
still throwing the error away in all of the callers but that'll change
shortly.
---
 src/glx/dri2_glx.c     |  6 +++--
 src/glx/dri3_glx.c     |  6 +++--
 src/glx/dri_common.c   | 56 ++++++++++++++++++++++++++++--------------
 src/glx/dri_common.h   |  3 +++
 src/glx/drisw_glx.c    |  5 +++-
 src/glx/glxclient.h    |  6 +++++
 src/glx/indirect_glx.c |  5 ++++
 7 files changed, 64 insertions(+), 23 deletions(-)

diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index c000139a74fc..45d8c26f3158 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -188,7 +188,7 @@ dri2_create_context_attribs(struct glx_screen *base,
        *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
        */
       if (!!shareList->noError != !!dca.no_error) {
-         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         *error = BadMatch;
          return NULL;
       }
 
@@ -198,7 +198,7 @@ dri2_create_context_attribs(struct glx_screen *base,
 
    pcp = calloc(1, sizeof *pcp);
    if (pcp == NULL) {
-      *error = __DRI_CTX_ERROR_NO_MEMORY;
+      *error = BadAlloc;
       goto error_exit;
    }
 
@@ -250,6 +250,8 @@ dri2_create_context_attribs(struct glx_screen *base,
 					  error,
 					  pcp);
 
+   *error = dri_context_error_to_glx_error(*error);
+
    if (pcp->driContext == NULL)
       goto error_exit;
 
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index ecfcdee1816c..60b77a1b8b63 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -266,7 +266,7 @@ dri3_create_context_attribs(struct glx_screen *base,
        *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
        */
       if (!!shareList->noError != !!dca.no_error) {
-         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         *error = BadMatch;
          return NULL;
       }
 
@@ -276,7 +276,7 @@ dri3_create_context_attribs(struct glx_screen *base,
 
    pcp = calloc(1, sizeof *pcp);
    if (pcp == NULL) {
-      *error = __DRI_CTX_ERROR_NO_MEMORY;
+      *error = BadAlloc;
       goto error_exit;
    }
 
@@ -326,6 +326,8 @@ dri3_create_context_attribs(struct glx_screen *base,
                                                   error,
                                                   pcp);
 
+   *error = dri_context_error_to_glx_error(*error);
+
    if (pcp->driContext == NULL)
       goto error_exit;
 
diff --git a/src/glx/dri_common.c b/src/glx/dri_common.c
index 16f1613013ea..32dd00b97755 100644
--- a/src/glx/dri_common.c
+++ b/src/glx/dri_common.c
@@ -527,13 +527,6 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
    dca->api = __DRI_API_OPENGL;
    dca->no_error = 0;
 
-   if (num_attribs == 0)
-      return __DRI_CTX_ERROR_SUCCESS;
-
-   /* This is actually an internal error, but what the heck. */
-   if (attribs == NULL)
-      return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
-
    for (i = 0; i < num_attribs; i++) {
       switch (attribs[i * 2]) {
       case GLX_CONTEXT_MAJOR_VERSION_ARB:
@@ -563,7 +556,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
             dca->reset = __DRI_CTX_RESET_LOSE_CONTEXT;
             break;
          default:
-            return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+            return BadValue;
          }
          break;
       case GLX_CONTEXT_RELEASE_BEHAVIOR_ARB:
@@ -575,7 +568,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
             dca->release = __DRI_CTX_RELEASE_BEHAVIOR_FLUSH;
             break;
          default:
-            return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+            return BadValue;
          }
          break;
       case GLX_SCREEN:
@@ -585,7 +578,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
       default:
 	 /* If an unknown attribute is received, fail.
 	  */
-	 return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+	 return BadValue;
       }
    }
 
@@ -612,11 +605,11 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
       else if (dca->major_ver == 1 && dca->minor_ver < 2)
          dca->api = __DRI_API_GLES;
       else {
-         return __DRI_CTX_ERROR_BAD_API;
+         return BadValue;
       }
       break;
    default:
-      return __DRI_CTX_ERROR_BAD_API;
+      return GLXBadProfileARB;
    }
 
    /* Unknown flag value */
@@ -624,7 +617,7 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                       __DRI_CTX_FLAG_FORWARD_COMPATIBLE |
                       __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS |
                       __DRI_CTX_FLAG_RESET_ISOLATION))
-      return __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      return BadValue;
 
    /* There are no forward-compatible contexts before OpenGL 3.0.  The
     * GLX_ARB_create_context spec says:
@@ -633,17 +626,23 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
     *     3.0 and later."
     */
    if (dca->major_ver < 3 && (dca->flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)
-      return __DRI_CTX_ERROR_BAD_FLAG;
+      return BadMatch;
 
+   /* It also says:
+    *
+    *    "OpenGL contexts supporting version 3.0 or later of the API do not
+    *    support color index rendering, even if a color index <config> is
+    *    available."
+    */
    if (dca->major_ver >= 3 && dca->render_type == GLX_COLOR_INDEX_TYPE)
-      return __DRI_CTX_ERROR_BAD_FLAG;
+      return BadMatch;
 
    /* The KHR_no_error specs say:
     *
     *    Requires OpenGL ES 2.0 or OpenGL 2.0.
     */
    if (dca->no_error && dca->major_ver < 2)
-      return __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      return BadMatch;
 
    /* The GLX_ARB_create_context_no_error specs say:
     *
@@ -653,9 +652,30 @@ dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
     */
    if (dca->no_error && ((dca->flags & __DRI_CTX_FLAG_DEBUG) ||
                          (dca->flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)))
-      return __DRI_CTX_ERROR_BAD_FLAG;
+      return BadMatch;
 
-   return __DRI_CTX_ERROR_SUCCESS;
+   return Success;
+}
+
+unsigned
+dri_context_error_to_glx_error(unsigned error)
+{
+   if (error == __DRI_CTX_ERROR_SUCCESS)
+      return Success;
+   if (error == __DRI_CTX_ERROR_NO_MEMORY)
+      return BadAlloc;
+   else if (error == __DRI_CTX_ERROR_BAD_API)
+      return BadMatch;
+   else if (error == __DRI_CTX_ERROR_BAD_VERSION)
+      return GLXBadFBConfig;
+   else if (error == __DRI_CTX_ERROR_BAD_FLAG)
+      return BadMatch;
+   else if (error == __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE)
+      return BadValue;
+   else if (error == __DRI_CTX_ERROR_UNKNOWN_FLAG)
+      return BadValue;
+   else
+      unreachable("Impossible DRI context error");
 }
 
 struct glx_context *
diff --git a/src/glx/dri_common.h b/src/glx/dri_common.h
index 000282032936..d762308a4fb3 100644
--- a/src/glx/dri_common.h
+++ b/src/glx/dri_common.h
@@ -77,6 +77,9 @@ struct dri_ctx_attribs {
    int no_error;
 };
 
+extern unsigned
+dri_context_error_to_glx_error(unsigned error);
+
 extern int
 dri_convert_glx_attribs(unsigned num_attribs, const uint32_t *attribs,
                         struct dri_ctx_attribs *dca);
diff --git a/src/glx/drisw_glx.c b/src/glx/drisw_glx.c
index 5849486c393a..b16fbeb1fa7e 100644
--- a/src/glx/drisw_glx.c
+++ b/src/glx/drisw_glx.c
@@ -594,7 +594,7 @@ drisw_create_context_attribs(struct glx_screen *base,
        *    GLX_CONTEXT_OPENGL_NO_ERROR_ARB for the context being created.
        */
       if (!!shareList->noError != !!dca.no_error) {
-         *error = __DRI_CTX_ERROR_BAD_FLAG;
+         *error = BadMatch;
          return NULL;
       }
 
@@ -646,6 +646,9 @@ drisw_create_context_attribs(struct glx_screen *base,
 					    ctx_attribs,
 					    error,
 					    pcp);
+
+   *error = dri_context_error_to_glx_error(*error);
+
    if (pcp->driContext == NULL) {
       free(pcp);
       return NULL;
diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index 179b4ddff4de..774610160547 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -480,6 +480,12 @@ struct glx_screen_vtable {
 					 struct glx_context *shareList,
 					 int renderType);
 
+   /* The error outparameter here abuses the fact that the only possible
+    * errors are are GLXBadContext (0), GLXBadFBConfig (9), GLXBadProfileARB
+    * (13), BadValue (2), BadMatch (8), and BadAlloc (11). Since those don't
+    * collide we just use them directly rather than try to offset or use
+    * a sign convention.
+    */
    struct glx_context *(*create_context_attribs)(struct glx_screen *psc,
 						 struct glx_config *config,
 						 struct glx_context *shareList,
diff --git a/src/glx/indirect_glx.c b/src/glx/indirect_glx.c
index 7b0cf3b71642..0317aa8cb2da 100644
--- a/src/glx/indirect_glx.c
+++ b/src/glx/indirect_glx.c
@@ -290,6 +290,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
 
    opcode = __glXSetupForCommand(psc->dpy);
    if (!opcode) {
+      *error = BadImplementation;
       return NULL;
    }
 
@@ -312,6 +313,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
    if (mask != GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB ||
        major != 1 ||
        minor > 4) {
+      *error = GLXBadFBConfig;
       return NULL;
    }
 
@@ -322,6 +324,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
    /* Allocate our context record */
    gc = calloc(1, sizeof *gc);
    if (!gc) {
+      *error = BadAlloc;
       /* Out of memory */
       return NULL;
    }
@@ -334,6 +337,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
 
    if (state == NULL) {
       /* Out of memory */
+      *error = BadAlloc;
       free(gc);
       return NULL;
    }
@@ -350,6 +354,7 @@ indirect_create_context_attribs(struct glx_screen *psc,
    bufSize = (XMaxRequestSize(psc->dpy) * 4) - sz_xGLXRenderReq;
    gc->buf = malloc(bufSize);
    if (!gc->buf) {
+      *error = BadAlloc;
       free(gc->client_state_private);
       free(gc);
       return NULL;
-- 
GitLab


From 8c8842d9275ed9ff3bbe44f421efe904edc0ab3c Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 22 Jul 2021 16:28:31 -0400
Subject: [PATCH 2/5] glx/dri: Validate more of the context version in
 validate_context_version

There's two kinds of "bad version" you might encounter here, either the
combination does not name a defined version (like 1.7) or it names
something the driver can't do (like asking r300 to do 4.0), and you have
to distinguish to generate BadMatch vs GLXBadFBConfig correctly.

While we're at it just return the status directly rather than
bool+outparam.
---
 src/gallium/frontends/dri/dri_util.c | 66 ++++++++++++++++------------
 1 file changed, 38 insertions(+), 28 deletions(-)

diff --git a/src/gallium/frontends/dri/dri_util.c b/src/gallium/frontends/dri/dri_util.c
index 4a6c201387ec..f0cf166724e4 100644
--- a/src/gallium/frontends/dri/dri_util.c
+++ b/src/gallium/frontends/dri/dri_util.c
@@ -397,43 +397,53 @@ driIndexConfigAttrib(const __DRIconfig *config, int index,
     return GL_FALSE;
 }
 
-static bool
+static unsigned
 validate_context_version(__DRIscreen *screen,
                          int mesa_api,
                          unsigned major_version,
-                         unsigned minor_version,
-                         unsigned *dri_ctx_error)
+                         unsigned minor_version)
 {
    unsigned req_version = 10 * major_version + minor_version;
    unsigned max_version = 0;
 
-   switch (mesa_api) {
-   case API_OPENGL_COMPAT:
+   if (major_version == 0 || major_version > 4)
+      return __DRI_CTX_ERROR_BAD_API;
+
+   if (mesa_api == API_OPENGL_COMPAT) {
+      if ((major_version == 4 && minor_version > 6) ||
+          (major_version == 3 && minor_version > 3) ||
+          (major_version == 2 && minor_version > 1) ||
+          (major_version == 1 && minor_version > 5))
+         return __DRI_CTX_ERROR_BAD_API;
       max_version = screen->max_gl_compat_version;
-      break;
-   case API_OPENGL_CORE:
-      max_version = screen->max_gl_core_version;
-      break;
-   case API_OPENGLES:
+   } else if (mesa_api == API_OPENGLES) {
+      if (major_version > 1 || minor_version > 1)
+         return __DRI_CTX_ERROR_BAD_API;
       max_version = screen->max_gl_es1_version;
-      break;
-   case API_OPENGLES2:
+   } else if (mesa_api == API_OPENGLES2) {
+      if ((major_version >  3) ||
+          (major_version == 3 && minor_version > 2) ||
+          (major_version == 2 && minor_version > 0) ||
+          (major_version <  2))
+         return __DRI_CTX_ERROR_BAD_API;
       max_version = screen->max_gl_es2_version;
-      break;
-   default:
-      max_version = 0;
-      break;
+   } else if (mesa_api == API_OPENGL_CORE) {
+      if ((major_version == 4 && minor_version > 6) ||
+          (major_version == 3 && minor_version > 3) ||
+          (major_version < 3))
+         return __DRI_CTX_ERROR_BAD_API;
+      max_version = screen->max_gl_core_version;
+   } else {
+      return __DRI_CTX_ERROR_BAD_API;
    }
 
-   if (max_version == 0) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
-      return false;
-   } else if (req_version > max_version) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
-      return false;
-   }
+   if (max_version == 0)
+      return __DRI_CTX_ERROR_BAD_API;
+
+   if (req_version > max_version)
+      return __DRI_CTX_ERROR_BAD_VERSION;
 
-   return true;
+   return __DRI_CTX_ERROR_SUCCESS;
 }
 
 /*****************************************************************/
@@ -613,10 +623,10 @@ driCreateContextAttribs(__DRIscreen *screen, int api,
 	return NULL;
     }
 
-    if (!validate_context_version(screen, mesa_api,
-                                  ctx_config.major_version,
-                                  ctx_config.minor_version,
-                                  error))
+    *error = validate_context_version(screen, mesa_api,
+                                      ctx_config.major_version,
+                                      ctx_config.minor_version);
+    if (*error != __DRI_CTX_ERROR_SUCCESS)
        return NULL;
 
     context = calloc(1, sizeof *context);
-- 
GitLab


From f6eb3d48034beffe45036c548a4d76032aff9c56 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 23 Jul 2021 18:14:33 -0400
Subject: [PATCH 3/5] glx/dri: Fix error generation for invalid GLX_RENDER_TYPE

This needs to throw BadValue.
---
 src/glx/dri2_glx.c  | 6 ++++--
 src/glx/dri3_glx.c  | 6 ++++--
 src/glx/drisw_glx.c | 3 ++-
 3 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index 45d8c26f3158..bb9a04e9df27 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -173,8 +173,10 @@ dri2_create_context_attribs(struct glx_screen *base,
       goto error_exit;
 
    /* Check the renderType value */
-   if (!validate_renderType_against_config(config_base, dca.render_type))
-       goto error_exit;
+   if (!validate_renderType_against_config(config_base, dca.render_type)) {
+      *error = BadValue;
+      goto error_exit;
+   }
 
    if (shareList) {
       /* We can't share with an indirect context */
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index 60b77a1b8b63..96d66f8e9d84 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -251,8 +251,10 @@ dri3_create_context_attribs(struct glx_screen *base,
       goto error_exit;
 
    /* Check the renderType value */
-   if (!validate_renderType_against_config(config_base, dca.render_type))
-       goto error_exit;
+   if (!validate_renderType_against_config(config_base, dca.render_type)) {
+      *error = BadValue;
+      goto error_exit;
+   }
 
    if (shareList) {
       /* We can't share with an indirect context */
diff --git a/src/glx/drisw_glx.c b/src/glx/drisw_glx.c
index b16fbeb1fa7e..815ffa50b67f 100644
--- a/src/glx/drisw_glx.c
+++ b/src/glx/drisw_glx.c
@@ -579,7 +579,8 @@ drisw_create_context_attribs(struct glx_screen *base,
 
    /* Check the renderType value */
    if (!validate_renderType_against_config(config_base, dca.render_type)) {
-       return NULL;
+      *error = BadValue;
+      return NULL;
    }
 
    if (shareList) {
-- 
GitLab


From e46e04433101a4d80e59b2ecd7396034bf45925b Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 23 Jul 2021 16:13:45 -0400
Subject: [PATCH 4/5] glx: disable the indirect fallback in
 CreateContextAttribs

If your app cares enough to use CreateContextAttribs it's probably not
going to be happy with the pre-GL-1.5 indirect experience.
---
 src/glx/create_context.c | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/glx/create_context.c b/src/glx/create_context.c
index c44d579c9545..f31d466a7324 100644
--- a/src/glx/create_context.c
+++ b/src/glx/create_context.c
@@ -109,16 +109,15 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
       gc = psc->vtable->create_context_attribs(psc, cfg, share, num_attribs,
 					       (const uint32_t *) attrib_list,
 					       &dummy_err);
-   }
-
-   if (gc == NULL) {
+   } 
 #ifdef GLX_USE_APPLEGL
+   else if (gc == NULL) {
       gc = applegl_create_context(psc, cfg, share, 0);
-#else
-      gc = indirect_create_context_attribs(psc, cfg, share, num_attribs,
-              (const uint32_t *) attrib_list,
-              &dummy_err);
 #endif
+   else if (!direct) {
+      gc = indirect_create_context_attribs(psc, cfg, share, num_attribs,
+                                           (const uint32_t *) attrib_list,
+                                           &dummy_err);
    }
 
    xid = xcb_generate_id(c);
-- 
GitLab


From 88d8a5893f77a29909964e465a4b765bf156fcee Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 21 Jul 2021 12:02:35 -0400
Subject: [PATCH 5/5] glx: Fix error handling yet again in CreateContextAttribs

Unlike the legacy CreateContext path, we would try to send the
GLXCreateContextAttribs request regardless of whether we'd successfully
created the client context state. And there's not a lot on the server
side to go wrong besides BadAlloc, so if the request succeeded but
the client side didn't we'd need to destroy the server context and
synthesize an X error. Since that itself involves more X protocol it's
tricky to get the request number right in the error, and tests and apps
can notice when you get it wrong.

Since we have now fixed client-side validation to generate the right
errors at the right times, this patch does something simpler, we match
CreateContext and fail early if the client-side setup fails. Now there's
no question of what request number to use, because we haven't sent any
protocol, the error is for the request as if it'd been sent.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/4763
---
 src/glx/create_context.c | 43 +++++++++++++++++++---------------------
 1 file changed, 20 insertions(+), 23 deletions(-)

diff --git a/src/glx/create_context.c b/src/glx/create_context.c
index f31d466a7324..008974a659b4 100644
--- a/src/glx/create_context.c
+++ b/src/glx/create_context.c
@@ -54,7 +54,7 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
    struct glx_screen *psc;
    xcb_generic_error_t *err;
    xcb_void_cookie_t cookie;
-   unsigned dummy_err = 0;
+   unsigned error = BadImplementation;
    uint32_t xid, share_xid;
    int screen = -1;
 
@@ -100,24 +100,30 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
       direct = true;
    }
 
-
+#ifdef GLX_USE_APPLEGL
+   gc = applegl_create_context(psc, cfg, share, 0);
+#else
    if (direct && psc->vtable->create_context_attribs) {
-      /* GLX drops the error returned by the driver.  The expectation is that
-       * an error will also be returned by the server.  The server's error
-       * will be delivered to the application.
-       */
       gc = psc->vtable->create_context_attribs(psc, cfg, share, num_attribs,
 					       (const uint32_t *) attrib_list,
-					       &dummy_err);
-   } 
-#ifdef GLX_USE_APPLEGL
-   else if (gc == NULL) {
-      gc = applegl_create_context(psc, cfg, share, 0);
-#endif
-   else if (!direct) {
+					       &error);
+   } else if (!direct) {
       gc = indirect_create_context_attribs(psc, cfg, share, num_attribs,
                                            (const uint32_t *) attrib_list,
-                                           &dummy_err);
+                                           &error);
+   }
+#endif
+
+   if (gc == NULL) {
+      /* -1 isn't a legal XID, which is sort of the point, we've failed
+       * before we even got to XID allocation.
+       */
+      if (error == GLXBadContext || error == GLXBadFBConfig ||
+          error == GLXBadProfileARB)
+         __glXSendError(dpy, error, -1, 0, False);
+      else
+         __glXSendError(dpy, error, -1, 0, True);
+      return NULL;
    }
 
    xid = xcb_generate_id(c);
@@ -149,15 +155,6 @@ glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
 
       __glXSendErrorForXcb(dpy, err);
       free(err);
-   } else if (!gc) {
-      /* the server thought the context description was okay, but we failed
-       * somehow on the client side. clean up the server resource and panic.
-       */
-      xcb_glx_destroy_context(c, xid);
-      /* increment dpy->request in order to give a unique serial number to the
-       * error */
-      XNoOp(dpy);
-      __glXSendError(dpy, GLXBadFBConfig, xid, 0, False);
    } else {
       gc->xid = xid;
       gc->share_xid = share_xid;
-- 
GitLab

