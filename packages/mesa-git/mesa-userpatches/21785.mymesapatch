From bac63f5df6ded93b8e5d9d06e4ce5d29ec11509d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 8 Mar 2023 12:02:56 +0100
Subject: [PATCH] aco: add more s_bitcmp patterns

Foz-DB Navi21:
Totals from 14 (0.01% of 134913) affected shaders:
CodeSize: 149472 -> 149324 (-0.10%)
Instrs: 27795 -> 27758 (-0.13%)
Latency: 862134 -> 862125 (-0.00%)
InvThroughput: 140032 -> 140031 (-0.00%)
PreSGPRs: 776 -> 772 (-0.52%)
---
 src/amd/compiler/aco_optimizer.cpp | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index d67fe93e65ed..03e4dfb4213d 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2053,6 +2053,11 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       ctx.info[instr->definitions[0].tempId()].set_bitwise(instr.get());
       break;
    case aco_opcode::s_lshl_b32:
+   case aco_opcode::s_lshl_b64:
+   case aco_opcode::s_lshr_b32:
+   case aco_opcode::s_lshr_b64:
+   case aco_opcode::s_ashr_i32:
+   case aco_opcode::s_ashr_i64:
    case aco_opcode::v_or_b32:
    case aco_opcode::v_lshlrev_b32:
    case aco_opcode::v_bcnt_u32_b32:
@@ -3077,7 +3082,11 @@ use_absdiff:
    return true;
 }
 
-/* s_cmp_{lg,eq}(s_and(a, s_lshl(1, b)), 0) -> s_bitcmp[10](a, b)*/
+/* s_cmp_{lg,eq}(s_and(a, s_lshl(1, b)), 0) -> s_bitcmp[10](a, b)
+ * s_cmp_{lg,eq}(s_and(a, s_lshl(1, b)), s_lshl(1, b)) -> s_bitcmp[10](a, b)
+ * s_cmp_{lg,eq}(s_and(a, #b(pot), 0) -> s_bitcmp[10](a, first_bit(b))
+ * s_cmp_{lg,eq}(s_and(1, s_lshr(a, b)), 0) -> s_bitcmp[10](a, b)
+ */
 bool
 combine_s_bitcmp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -3095,6 +3104,8 @@ combine_s_bitcmp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
    aco_opcode s_and = b64 ? aco_opcode::s_and_b64 : aco_opcode::s_and_b32;
    aco_opcode s_lshl = b64 ? aco_opcode::s_lshl_b64 : aco_opcode::s_lshl_b32;
+   aco_opcode s_lshr = b64 ? aco_opcode::s_lshr_b64 : aco_opcode::s_lshr_b32;
+   aco_opcode s_ashr = b64 ? aco_opcode::s_ashr_i64 : aco_opcode::s_ashr_i32;
 
    for (unsigned cmp_idx = 0; cmp_idx < 2; cmp_idx++) {
       Instruction* and_instr = follow_operand(ctx, instr->operands[cmp_idx], false);
@@ -3141,6 +3152,13 @@ combine_s_bitcmp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             decrease_op_uses_if_dead(ctx, lshl_instr);
          } else {
             instr->operands[1] = Operand::c32(ffsll(constant) - 1);
+            Instruction* shr_instr = follow_operand(ctx, instr->operands[0]);
+            if (shr_instr && (shr_instr->opcode == s_ashr || shr_instr->opcode == s_lshr) &&
+                instr->operands[1].constantEquals(0)) {
+               instr->operands[0] = copy_operand(ctx, shr_instr->operands[0]);
+               instr->operands[1] = copy_operand(ctx, shr_instr->operands[1]);
+               decrease_uses(ctx, shr_instr);
+            }
          }
          return true;
       }
-- 
GitLab

