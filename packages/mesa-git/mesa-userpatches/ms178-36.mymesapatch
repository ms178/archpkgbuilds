--- a/src/mesa/main/format_utils.c	2025-11-21 21:54:51.036519633 +0100
+++ b/src/mesa/main/format_utils.c	2025-11-21 22:07:59.910140506 +0100
@@ -23,6 +23,8 @@
  */
 
 #include <stdlib.h>
+#include <string.h>
+#include <immintrin.h>
 
 #include "errors.h"
 #include "format_utils.h"
@@ -30,6 +32,7 @@
 #include "format_pack.h"
 #include "format_unpack.h"
 
+/* Standard array format definitions */
 const mesa_array_format RGBA32_FLOAT =
    MESA_ARRAY_FORMAT(MESA_ARRAY_FORMAT_BASE_FORMAT_RGBA_VARIANTS,
                      4, 1, 1, 1, 4, 0, 1, 2, 3);
@@ -50,15 +53,107 @@ const mesa_array_format RGBA32_INT =
    MESA_ARRAY_FORMAT(MESA_ARRAY_FORMAT_BASE_FORMAT_RGBA_VARIANTS,
                      4, 1, 0, 0, 4, 0, 1, 2, 3);
 
+/* ----------------------------------------------------------------------
+ * AVX2 Optimized Kernels
+ * ---------------------------------------------------------------------- */
+
+#if defined(__AVX2__)
+
+/*
+ * 16-bit Rotation Kernel
+ * Handles A1B5G5R5 <-> B5G5R5A1 conversion via bit rotation.
+ * direction 0: Rotate Left 1 (A1... -> ...A1)
+ * direction 1: Rotate Right 1 (...A1 -> A1...)
+ */
+static inline void
+convert_16bit_rotate_avx2(uint16_t *restrict dst, const uint16_t *restrict src, size_t n, int direction)
+{
+   size_t i = 0;
+
+   /* Main Loop: Process 16 pixels (32 bytes) per iteration */
+   if (n >= 16) {
+      for (; i <= n - 16; i += 16) {
+         __m256i in = _mm256_loadu_si256((const __m256i *)(src + i));
+         __m256i r, l;
+
+         if (direction == 0) {
+            /* Rotate Left 1 */
+            l = _mm256_slli_epi16(in, 1);
+            r = _mm256_srli_epi16(in, 15);
+         } else {
+            /* Rotate Right 1 */
+            l = _mm256_slli_epi16(in, 15);
+            r = _mm256_srli_epi16(in, 1);
+         }
+         _mm256_storeu_si256((__m256i *)(dst + i), _mm256_or_si256(l, r));
+      }
+   }
+
+   /* Scalar Tail */
+   for (; i < n; i++) {
+      uint16_t val = src[i];
+      if (direction == 0)
+         dst[i] = (val << 1) | (val >> 15);
+      else
+         dst[i] = (val >> 1) | (val << 15);
+   }
+}
+
+/*
+ * Optimized BGRA Swizzle
+ * Converts RGBA to BGRA (swaps bytes 0 and 2) using vpshufb.
+ */
+static inline void
+convert_ubyte_rgba_to_bgra_avx2(size_t width, size_t height,
+                                const uint8_t *restrict src, size_t src_stride,
+                                uint8_t *restrict dst, size_t dst_stride)
+{
+   /* vpshufb mask: Swap indices 0 and 2 within every 4-byte block */
+   /* 2, 1, 0, 3 | 6, 5, 4, 7 | ... */
+   const __m256i mask = _mm256_setr_epi8(
+      2, 1, 0, 3, 6, 5, 4, 7, 10, 9, 8, 11, 14, 13, 12, 15,
+      2, 1, 0, 3, 6, 5, 4, 7, 10, 9, 8, 11, 14, 13, 12, 15
+   );
+
+   size_t row, i;
+   for (row = 0; row < height; row++) {
+      const uint8_t *s = src;
+      uint8_t *d = dst;
+
+      /* Process 8 pixels (32 bytes) at a time */
+      for (i = 0; i <= width - 8; i += 8) {
+         __m256i v = _mm256_loadu_si256((const __m256i *)(s + i * 4));
+         v = _mm256_shuffle_epi8(v, mask);
+         _mm256_storeu_si256((__m256i *)(d + i * 4), v);
+      }
+
+      /* Scalar Tail */
+      for (; i < width; i++) {
+         uint32_t pixel;
+         memcpy(&pixel, s + i * 4, 4);
+         /* (AABBGGRR) -> (AARRGGBB) */
+         pixel = (pixel & 0xff00ff00) |
+                 ((pixel & 0x00ff0000) >> 16) |
+                 ((pixel & 0x000000ff) << 16);
+         memcpy(d + i * 4, &pixel, 4);
+      }
+
+      src += src_stride;
+      dst += dst_stride;
+   }
+}
+
+#endif /* __AVX2__ */
+
+/* ----------------------------------------------------------------------
+ * Swizzle Logic
+ * ---------------------------------------------------------------------- */
+
 static void
 invert_swizzle(uint8_t dst[4], const uint8_t src[4])
 {
    int i, j;
-
-   dst[0] = MESA_FORMAT_SWIZZLE_NONE;
-   dst[1] = MESA_FORMAT_SWIZZLE_NONE;
-   dst[2] = MESA_FORMAT_SWIZZLE_NONE;
-   dst[3] = MESA_FORMAT_SWIZZLE_NONE;
+   dst[0] = dst[1] = dst[2] = dst[3] = MESA_FORMAT_SWIZZLE_NONE;
 
    for (i = 0; i < 4; ++i)
       for (j = 0; j < 4; ++j)
@@ -66,25 +161,12 @@ invert_swizzle(uint8_t dst[4], const uin
             dst[i] = j;
 }
 
-/* Takes a src to RGBA swizzle and applies a rebase swizzle to it. This
- * is used when we need to rebase a format to match a different
- * base internal format.
- *
- * The rebase swizzle can be NULL, which means that no rebase is necessary,
- * in which case the src to RGBA swizzle is copied to the output without
- * changes.
- *
- * The resulting rebased swizzle and well as the input swizzles are
- * all 4-element swizzles, but the rebase swizzle can be NULL if no rebase
- * is necessary.
- */
 static void
 compute_rebased_rgba_component_mapping(uint8_t *src2rgba,
                                        uint8_t *rebase_swizzle,
                                        uint8_t *rebased_src2rgba)
 {
    int i;
-
    if (rebase_swizzle) {
       for (i = 0; i < 4; i++) {
          if (rebase_swizzle[i] > MESA_FORMAT_SWIZZLE_W)
@@ -93,68 +175,40 @@ compute_rebased_rgba_component_mapping(u
             rebased_src2rgba[i] = src2rgba[rebase_swizzle[i]];
       }
    } else {
-      /* No rebase needed, so src2rgba is all that we need */
       memcpy(rebased_src2rgba, src2rgba, 4 * sizeof(uint8_t));
    }
 }
 
-/* Computes the final swizzle transform to apply from src to dst in a
- * conversion that might involve a rebase swizzle.
- *
- * This is used to compute the swizzle transform to apply in conversions
- * between array formats where we have a src2rgba swizzle, a rgba2dst swizzle
- * and possibly, a rebase swizzle.
- *
- * The final swizzle transform to apply (src2dst) when a rebase swizzle is
- * involved is: src -> rgba -> base -> rgba -> dst
- */
 static void
 compute_src2dst_component_mapping(uint8_t *src2rgba, uint8_t *rgba2dst,
                                   uint8_t *rebase_swizzle, uint8_t *src2dst)
 {
    int i;
-
    if (!rebase_swizzle) {
       for (i = 0; i < 4; i++) {
-         if (rgba2dst[i] > MESA_FORMAT_SWIZZLE_W) {
+         if (rgba2dst[i] > MESA_FORMAT_SWIZZLE_W)
             src2dst[i] = rgba2dst[i];
-         } else {
+         else
             src2dst[i] = src2rgba[rgba2dst[i]];
-         }
       }
    } else {
       for (i = 0; i < 4; i++) {
-         if (rgba2dst[i] > MESA_FORMAT_SWIZZLE_W) {
+         if (rgba2dst[i] > MESA_FORMAT_SWIZZLE_W)
             src2dst[i] = rgba2dst[i];
-         } else if (rebase_swizzle[rgba2dst[i]] > MESA_FORMAT_SWIZZLE_W) {
+         else if (rebase_swizzle[rgba2dst[i]] > MESA_FORMAT_SWIZZLE_W)
             src2dst[i] = rebase_swizzle[rgba2dst[i]];
-         } else {
+         else
             src2dst[i] = src2rgba[rebase_swizzle[rgba2dst[i]]];
-         }
       }
    }
 }
 
-/**
- * This function is used by clients of _mesa_format_convert to obtain
- * the rebase swizzle to use in a format conversion based on the base
- * format involved.
- *
- * \param baseFormat  the base internal format involved in the conversion.
- * \param map  the rebase swizzle to consider
- *
- * This function computes 'map' as rgba -> baseformat -> rgba and returns true
- * if the resulting swizzle transform is not the identity transform (thus, a
- * rebase is needed). If the function returns false then a rebase swizzle
- * is not necessary and the value of 'map' is undefined. In this situation
- * clients of _mesa_format_convert should pass NULL in the 'rebase_swizzle'
- * parameter.
- */
 bool
 _mesa_compute_rgba2base2rgba_component_mapping(GLenum baseFormat, uint8_t *map)
 {
    uint8_t rgba2base[6], base2rgba[6];
    int i;
+   bool needRebase = false;
 
    switch (baseFormat) {
    case GL_ALPHA:
@@ -170,62 +224,52 @@ _mesa_compute_rgba2base2rgba_component_m
    case GL_LUMINANCE:
    case GL_INTENSITY:
    case GL_LUMINANCE_ALPHA:
-      {
-         bool needRebase = false;
-         _mesa_compute_component_mapping(GL_RGBA, baseFormat, rgba2base);
-         _mesa_compute_component_mapping(baseFormat, GL_RGBA, base2rgba);
-         for (i = 0; i < 4; i++) {
-            if (base2rgba[i] > MESA_FORMAT_SWIZZLE_W) {
-               map[i] = base2rgba[i];
-            } else {
-               map[i] = rgba2base[base2rgba[i]];
-            }
-            if (map[i] != i)
-               needRebase = true;
-         }
-         return needRebase;
+      _mesa_compute_component_mapping(GL_RGBA, baseFormat, rgba2base);
+      _mesa_compute_component_mapping(baseFormat, GL_RGBA, base2rgba);
+      for (i = 0; i < 4; i++) {
+         if (base2rgba[i] > MESA_FORMAT_SWIZZLE_W)
+            map[i] = base2rgba[i];
+         else
+            map[i] = rgba2base[base2rgba[i]];
+         if (map[i] != i)
+            needRebase = true;
       }
+      return needRebase;
    default:
       UNREACHABLE("Unexpected base format");
    }
 }
 
-
-/**
- * Special case conversion function to swap r/b channels from the source
- * image to the dest image.
- */
 static void
 convert_ubyte_rgba_to_bgra(size_t width, size_t height,
                            const uint8_t *src, size_t src_stride,
                            uint8_t *dst, size_t dst_stride)
 {
+#if defined(__AVX2__)
+   convert_ubyte_rgba_to_bgra_avx2(width, height, src, src_stride, dst, dst_stride);
+#else
+   /* Fallback for non-AVX2 */
    int row;
-
+   /* Check 64-bit alignment for SWAR optimization */
    if (sizeof(void *) == 8 &&
-       src_stride % 8 == 0 &&
-       dst_stride % 8 == 0 &&
-       (GLsizeiptr) src % 8 == 0 &&
-       (GLsizeiptr) dst % 8 == 0) {
-      /* use 64-bit word to swizzle two 32-bit pixels.  We need 8-byte
-       * alignment for src/dst addresses and strides.
-       */
+       src_stride % 8 == 0 && dst_stride % 8 == 0 &&
+       (GLsizeiptr) src % 8 == 0 && (GLsizeiptr) dst % 8 == 0) {
       for (row = 0; row < height; row++) {
          const GLuint64 *s = (const GLuint64 *) src;
          GLuint64 *d = (GLuint64 *) dst;
          int i;
          for (i = 0; i < width/2; i++) {
+            /* Swap R and B in two pixels at once */
             d[i] = ( (s[i] & 0xff00ff00ff00ff00) |
                     ((s[i] &       0xff000000ff) << 16) |
                     ((s[i] &   0xff000000ff0000) >> 16));
          }
          if (width & 1) {
-            /* handle the case of odd widths */
-            const GLuint s = ((const GLuint *) src)[width - 1];
-            GLuint *d = (GLuint *) dst + width - 1;
-            *d = ( (s & 0xff00ff00) |
-                  ((s &       0xff) << 16) |
-                  ((s &   0xff0000) >> 16));
+            const GLuint s32 = ((const GLuint *) src)[width - 1];
+            GLuint *d32 = (GLuint *) dst + width - 1;
+            *d32 = ( (s32 & 0xff00ff00) |
+                    ((s32 &       0xff) << 16) |
+                    ((s32 &   0xff0000) >> 16));
          }
          src += src_stride;
          dst += dst_stride;
@@ -244,36 +288,524 @@ convert_ubyte_rgba_to_bgra(size_t width,
          dst += dst_stride;
       }
    }
+#endif
 }
 
+/* ----------------------------------------------------------------------
+ * Generic Swizzle JIT-like Optimization
+ * ---------------------------------------------------------------------- */
+
+static bool
+swizzle_convert_try_memcpy(void *restrict dst,
+                           enum mesa_array_format_datatype dst_type,
+                           int num_dst_channels,
+                           const void *restrict src,
+                           enum mesa_array_format_datatype src_type,
+                           int num_src_channels,
+                           const uint8_t swizzle[4], bool normalized, int count)
+{
+   if (src_type != dst_type) return false;
+   if (num_src_channels != num_dst_channels) return false;
+
+   /* Verify identity swizzle */
+   for (int i = 0; i < num_dst_channels; ++i)
+      if (swizzle[i] != i && swizzle[i] != MESA_FORMAT_SWIZZLE_NONE)
+         return false;
+
+   memcpy(dst, src, count * num_src_channels * _mesa_array_format_datatype_get_size(src_type));
+   return true;
+}
+
+static bool
+swizzle_convert_try_avx2(void *restrict dst, enum mesa_array_format_datatype dst_type,
+                         int num_dst_channels,
+                         const void *restrict src, enum mesa_array_format_datatype src_type,
+                         int num_src_channels,
+                         const uint8_t swizzle[4], bool normalized, int count)
+{
+#if defined(__AVX2__)
+   if (src_type != dst_type) return false;
+   /* Only optimize 4-channel to 4-channel swizzles (most common) */
+   if (num_src_channels != 4 || num_dst_channels != 4) return false;
+
+   if (src_type == MESA_ARRAY_FORMAT_TYPE_UBYTE) {
+      uint8_t shuf[32];
+      uint8_t one_mask_arr[32];
+      uint8_t one_val = normalized ? 255 : 1;
+
+      /* Build shuffle mask */
+      for (int k = 0; k < 16; k++) {
+         int chan = k % 4;
+         uint8_t s = swizzle[chan];
+         if (s <= 3) {
+            shuf[k] = (uint8_t)((k / 4) * 4 + s);
+            one_mask_arr[k] = 0;
+         } else if (s == MESA_FORMAT_SWIZZLE_ZERO) {
+            shuf[k] = 0x80; /* Disable byte in vpshufb */
+            one_mask_arr[k] = 0;
+         } else if (s == MESA_FORMAT_SWIZZLE_ONE) {
+            shuf[k] = 0x80;
+            one_mask_arr[k] = one_val;
+         } else {
+            return false; /* Unknown swizzle enum */
+         }
+      }
+      /* Replicate mask for high lane */
+      memcpy(shuf + 16, shuf, 16);
+      memcpy(one_mask_arr + 16, one_mask_arr, 16);
+
+      __m256i vshuf = _mm256_loadu_si256((const __m256i *)shuf);
+      __m256i vone  = _mm256_loadu_si256((const __m256i *)one_mask_arr);
+      const uint8_t *s_ptr = (const uint8_t *)src;
+      uint8_t *d_ptr = (uint8_t *)dst;
+      int i;
+
+      /* Process 8 pixels (32 bytes) */
+      for (i = 0; i <= count - 8; i += 8) {
+         __m256i v = _mm256_loadu_si256((const __m256i *)(s_ptr + i * 4));
+         v = _mm256_shuffle_epi8(v, vshuf);
+         v = _mm256_or_si256(v, vone);
+         _mm256_storeu_si256((__m256i *)(d_ptr + i * 4), v);
+      }
+
+      /* Finish tail scalarly */
+      for (; i < count; i++) {
+         for (int c = 0; c < 4; c++) {
+            uint8_t val;
+            if (swizzle[c] <= 3) val = s_ptr[i*4 + swizzle[c]];
+            else if (swizzle[c] == MESA_FORMAT_SWIZZLE_ZERO) val = 0;
+            else val = one_val;
+            d_ptr[i*4 + c] = val;
+         }
+      }
+      return true;
+   }
+
+   if (src_type == MESA_ARRAY_FORMAT_TYPE_FLOAT) {
+      int perm[8];
+      float ones[8];
+      int blend_mask[8];
+
+      /* Build permutation mask */
+      for(int k=0; k<8; k++) {
+         int c = k % 4;
+         if (swizzle[c] <= 3) {
+            perm[k] = swizzle[c];
+            ones[k] = 0.0f;
+            blend_mask[k] = 0;
+         } else {
+            perm[k] = 0; /* Safe dummy */
+            ones[k] = (swizzle[c] == MESA_FORMAT_SWIZZLE_ONE) ? 1.0f : 0.0f;
+            blend_mask[k] = 0x80000000; /* High bit set for blend */
+         }
+      }
+
+      __m256i vperm = _mm256_loadu_si256((const __m256i *)perm);
+      __m256 vone = _mm256_loadu_ps(ones);
+      __m256 vblend = _mm256_castsi256_ps(_mm256_loadu_si256((const __m256i *)blend_mask));
+      const float *s_ptr = (const float *)src;
+      float *d_ptr = (float *)dst;
+      int i;
+
+      /* Process 2 pixels (8 floats) */
+      for (i = 0; i <= count - 2; i += 2) {
+         __m256 v = _mm256_loadu_ps(s_ptr + i * 4);
+         __m256 p = _mm256_permutevar_ps(v, vperm);
+
+         /* Blend constants if needed */
+         if (_mm256_movemask_ps(vblend))
+            p = _mm256_blendv_ps(p, vone, vblend);
+
+         _mm256_storeu_ps(d_ptr + i * 4, p);
+      }
+
+      /* Finish tail */
+      for (; i < count; i++) {
+         for (int c = 0; c < 4; c++) {
+            float val;
+            if (swizzle[c] <= 3) val = s_ptr[i*4 + swizzle[c]];
+            else if (swizzle[c] == MESA_FORMAT_SWIZZLE_ZERO) val = 0.0f;
+            else val = 1.0f;
+            d_ptr[i*4 + c] = val;
+         }
+      }
+      return true;
+   }
+#endif
+   return false;
+}
+
+/* ----------------------------------------------------------------------
+ * Scalar Loop Macros (Manually Unrolled)
+ * ---------------------------------------------------------------------- */
+
+#define SWIZZLE_CONVERT_LOOP(DST_TYPE, DST_CHANS, SRC_TYPE, SRC_CHANS, CONV) \
+   do {                                           \
+      int s, j;                                   \
+      /* Unroll 4x for pipelining */              \
+      for (s = 0; s < count - 3; s += 4) {        \
+         for (int u = 0; u < 4; u++) {            \
+             for (j = 0; j < SRC_CHANS; ++j) {    \
+                SRC_TYPE src = typed_src[j];      \
+                tmp[j] = CONV;                    \
+             }                                    \
+             typed_dst[0] = tmp[swizzle_x];       \
+             if (DST_CHANS > 1) typed_dst[1] = tmp[swizzle_y]; \
+             if (DST_CHANS > 2) typed_dst[2] = tmp[swizzle_z]; \
+             if (DST_CHANS > 3) typed_dst[3] = tmp[swizzle_w]; \
+             typed_src += SRC_CHANS;              \
+             typed_dst += DST_CHANS;              \
+         }                                        \
+      }                                           \
+      /* Tail Loop */                             \
+      for (; s < count; ++s) {                    \
+         for (j = 0; j < SRC_CHANS; ++j) {        \
+            SRC_TYPE src = typed_src[j];          \
+            tmp[j] = CONV;                        \
+         }                                        \
+         typed_dst[0] = tmp[swizzle_x];           \
+         if (DST_CHANS > 1) typed_dst[1] = tmp[swizzle_y]; \
+         if (DST_CHANS > 2) typed_dst[2] = tmp[swizzle_z]; \
+         if (DST_CHANS > 3) typed_dst[3] = tmp[swizzle_w]; \
+         typed_src += SRC_CHANS;                  \
+         typed_dst += DST_CHANS;                  \
+      }                                           \
+   } while (0)
+
+#define SWIZZLE_CONVERT(DST_TYPE, SRC_TYPE, CONV)                 \
+   do {                                                           \
+      const uint8_t swizzle_x = swizzle[0];                       \
+      const uint8_t swizzle_y = swizzle[1];                       \
+      const uint8_t swizzle_z = swizzle[2];                       \
+      const uint8_t swizzle_w = swizzle[3];                       \
+      const SRC_TYPE *typed_src = void_src;                       \
+      DST_TYPE *typed_dst = void_dst;                             \
+      DST_TYPE tmp[7];                                            \
+      tmp[4] = 0;                                                 \
+      tmp[5] = one;                                               \
+      switch (num_dst_channels) {                                 \
+      case 1:                                                     \
+         switch (num_src_channels) {                              \
+         case 1: SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 1, CONV); break; \
+         case 2: SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 2, CONV); break; \
+         case 3: SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 3, CONV); break; \
+         case 4: SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 4, CONV); break; \
+         } break;                                                 \
+      case 2:                                                     \
+         switch (num_src_channels) {                              \
+         case 1: SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 1, CONV); break; \
+         case 2: SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 2, CONV); break; \
+         case 3: SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 3, CONV); break; \
+         case 4: SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 4, CONV); break; \
+         } break;                                                 \
+      case 3:                                                     \
+         switch (num_src_channels) {                              \
+         case 1: SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 1, CONV); break; \
+         case 2: SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 2, CONV); break; \
+         case 3: SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 3, CONV); break; \
+         case 4: SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 4, CONV); break; \
+         } break;                                                 \
+      case 4:                                                     \
+         switch (num_src_channels) {                              \
+         case 1: SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 1, CONV); break; \
+         case 2: SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 2, CONV); break; \
+         case 3: SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 3, CONV); break; \
+         case 4: SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 4, CONV); break; \
+         } break;                                                 \
+      }                                                           \
+   } while (0)
+
+static void
+convert_float(void *void_dst, int num_dst_channels,
+              const void *void_src, GLenum src_type, int num_src_channels,
+              const uint8_t swizzle[4], bool normalized, int count)
+{
+   const float one = 1.0f;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT: SWIZZLE_CONVERT(float, float, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF: SWIZZLE_CONVERT(float, uint16_t, _mesa_half_to_float(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(float, uint8_t, _mesa_unorm_to_float(src, 8));
+      else SWIZZLE_CONVERT(float, uint8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(float, int8_t, _mesa_snorm_to_float(src, 8));
+      else SWIZZLE_CONVERT(float, int8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(float, uint16_t, _mesa_unorm_to_float(src, 16));
+      else SWIZZLE_CONVERT(float, uint16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(float, int16_t, _mesa_snorm_to_float(src, 16));
+      else SWIZZLE_CONVERT(float, int16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(float, uint32_t, _mesa_unorm_to_float(src, 32));
+      else SWIZZLE_CONVERT(float, uint32_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(float, int32_t, _mesa_snorm_to_float(src, 32));
+      else SWIZZLE_CONVERT(float, int32_t, src); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_half_float(void *void_dst, int num_dst_channels,
+                   const void *void_src, GLenum src_type, int num_src_channels,
+                   const uint8_t swizzle[4], bool normalized, int count)
+{
+   const uint16_t one = _mesa_float_to_half(1.0f);
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT: SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_half(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF: SWIZZLE_CONVERT(uint16_t, uint16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint8_t, _mesa_unorm_to_half(src, 8));
+      else SWIZZLE_CONVERT(uint16_t, uint8_t, _mesa_float_to_half(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_snorm_to_half(src, 8));
+      else SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_float_to_half(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_unorm_to_half(src, 16));
+      else SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_float_to_half(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_snorm_to_half(src, 16));
+      else SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_float_to_half(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_unorm_to_half(src, 32));
+      else SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_float_to_half(src)); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_snorm_to_half(src, 32));
+      else SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_float_to_half(src)); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_ubyte(void *void_dst, int num_dst_channels,
+              const void *void_src, GLenum src_type, int num_src_channels,
+              const uint8_t swizzle[4], bool normalized, int count)
+{
+   const uint8_t one = normalized ? UINT8_MAX : 1;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_unorm(src, 8));
+      else SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_unsigned(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_unorm(src, 8));
+      else SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_unsigned(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE: SWIZZLE_CONVERT(uint8_t, uint8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, int8_t, _mesa_snorm_to_unorm(src, 8, 8));
+      else SWIZZLE_CONVERT(uint8_t, int8_t, _mesa_unsigned_to_unsigned(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_unorm_to_unorm(src, 16, 8));
+      else SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_unsigned_to_unsigned(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, int16_t, _mesa_snorm_to_unorm(src, 16, 8));
+      else SWIZZLE_CONVERT(uint8_t, int16_t, _mesa_unsigned_to_unsigned(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, uint32_t, _mesa_unorm_to_unorm(src, 32, 8));
+      else SWIZZLE_CONVERT(uint8_t, uint32_t, _mesa_unsigned_to_unsigned(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, int32_t, _mesa_snorm_to_unorm(src, 32, 8));
+      else SWIZZLE_CONVERT(uint8_t, int32_t, _mesa_signed_to_unsigned(src, 8)); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_byte(void *void_dst, int num_dst_channels,
+             const void *void_src, GLenum src_type, int num_src_channels,
+             const uint8_t swizzle[4], bool normalized, int count)
+{
+   const int8_t one = normalized ? INT8_MAX : 1;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_snorm(src, 8));
+      else SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_signed(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:
+      if (normalized) SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_snorm(src, 8));
+      else SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_signed(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(int8_t, uint8_t, _mesa_unorm_to_snorm(src, 8, 8));
+      else SWIZZLE_CONVERT(int8_t, uint8_t, _mesa_unsigned_to_signed(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE: SWIZZLE_CONVERT(int8_t, int8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(int8_t, uint16_t, _mesa_unorm_to_snorm(src, 16, 8));
+      else SWIZZLE_CONVERT(int8_t, uint16_t, _mesa_unsigned_to_signed(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(int8_t, int16_t, _mesa_snorm_to_snorm(src, 16, 8));
+      else SWIZZLE_CONVERT(int8_t, int16_t, _mesa_signed_to_signed(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(int8_t, uint32_t, _mesa_unorm_to_snorm(src, 32, 8));
+      else SWIZZLE_CONVERT(int8_t, uint32_t, _mesa_unsigned_to_signed(src, 8)); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(int8_t, int32_t, _mesa_snorm_to_snorm(src, 32, 8));
+      else SWIZZLE_CONVERT(int8_t, int32_t, _mesa_signed_to_signed(src, 8)); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_ushort(void *void_dst, int num_dst_channels,
+               const void *void_src, GLenum src_type, int num_src_channels,
+               const uint8_t swizzle[4], bool normalized, int count)
+{
+   const uint16_t one = normalized ? UINT16_MAX : 1;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_unorm(src, 16));
+      else SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_unsigned(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_unorm(src, 16));
+      else SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_unsigned(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint8_t, _mesa_unorm_to_unorm(src, 8, 16));
+      else SWIZZLE_CONVERT(uint16_t, uint8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_snorm_to_unorm(src, 8, 16));
+      else SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_signed_to_unsigned(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT: SWIZZLE_CONVERT(uint16_t, uint16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_snorm_to_unorm(src, 16, 16));
+      else SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_signed_to_unsigned(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_unorm_to_unorm(src, 32, 16));
+      else SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_unsigned_to_unsigned(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_snorm_to_unorm(src, 32, 16));
+      else SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_signed_to_unsigned(src, 16)); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_short(void *void_dst, int num_dst_channels,
+              const void *void_src, GLenum src_type, int num_src_channels,
+              const uint8_t swizzle[4], bool normalized, int count)
+{
+   const int16_t one = normalized ? INT16_MAX : 1;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_snorm(src, 16));
+      else SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_signed(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:
+      if (normalized) SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_snorm(src, 16));
+      else SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_signed(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(int16_t, uint8_t, _mesa_unorm_to_snorm(src, 8, 16));
+      else SWIZZLE_CONVERT(int16_t, uint8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(int16_t, int8_t, _mesa_snorm_to_snorm(src, 8, 16));
+      else SWIZZLE_CONVERT(int16_t, int8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(int16_t, uint16_t, _mesa_unorm_to_snorm(src, 16, 16));
+      else SWIZZLE_CONVERT(int16_t, uint16_t, _mesa_unsigned_to_signed(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT: SWIZZLE_CONVERT(int16_t, int16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(int16_t, uint32_t, _mesa_unorm_to_snorm(src, 32, 16));
+      else SWIZZLE_CONVERT(int16_t, uint32_t, _mesa_unsigned_to_signed(src, 16)); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(int16_t, int32_t, _mesa_snorm_to_snorm(src, 32, 16));
+      else SWIZZLE_CONVERT(int16_t, int32_t, _mesa_signed_to_signed(src, 16)); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_uint(void *void_dst, int num_dst_channels,
+             const void *void_src, GLenum src_type, int num_src_channels,
+             const uint8_t swizzle[4], bool normalized, int count)
+{
+   const uint32_t one = normalized ? UINT32_MAX : 1;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_unorm(src, 32));
+      else SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_unsigned(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_unorm(src, 32));
+      else SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_unsigned(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, uint8_t, _mesa_unorm_to_unorm(src, 8, 32));
+      else SWIZZLE_CONVERT(uint32_t, uint8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, int8_t, _mesa_snorm_to_unorm(src, 8, 32));
+      else SWIZZLE_CONVERT(uint32_t, int8_t, _mesa_signed_to_unsigned(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_unorm_to_unorm(src, 16, 32));
+      else SWIZZLE_CONVERT(uint32_t, uint16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, int16_t, _mesa_snorm_to_unorm(src, 16, 32));
+      else SWIZZLE_CONVERT(uint32_t, int16_t, _mesa_signed_to_unsigned(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT: SWIZZLE_CONVERT(uint32_t, uint32_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, int32_t, _mesa_snorm_to_unorm(src, 32, 32));
+      else SWIZZLE_CONVERT(uint32_t, int32_t, _mesa_signed_to_unsigned(src, 32)); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+static void
+convert_int(void *void_dst, int num_dst_channels,
+            const void *void_src, GLenum src_type, int num_src_channels,
+            const uint8_t swizzle[4], bool normalized, int count)
+{
+   const int32_t one = normalized ? INT32_MAX : 1;
+   switch (src_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_snorm(src, 32));
+      else SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_signed(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:
+      if (normalized) SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_snorm(src, 32));
+      else SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_signed(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
+      if (normalized) SWIZZLE_CONVERT(int32_t, uint8_t, _mesa_unorm_to_snorm(src, 8, 32));
+      else SWIZZLE_CONVERT(int32_t, uint8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:
+      if (normalized) SWIZZLE_CONVERT(int32_t, int8_t, _mesa_snorm_to_snorm(src, 8, 32));
+      else SWIZZLE_CONVERT(int32_t, int8_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT:
+      if (normalized) SWIZZLE_CONVERT(int32_t, uint16_t, _mesa_unorm_to_snorm(src, 16, 32));
+      else SWIZZLE_CONVERT(int32_t, uint16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:
+      if (normalized) SWIZZLE_CONVERT(int32_t, int16_t, _mesa_snorm_to_snorm(src, 16, 32));
+      else SWIZZLE_CONVERT(int32_t, int16_t, src); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:
+      if (normalized) SWIZZLE_CONVERT(int32_t, uint32_t, _mesa_unorm_to_snorm(src, 32, 32));
+      else SWIZZLE_CONVERT(int32_t, uint32_t, _mesa_unsigned_to_signed(src, 32)); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT: SWIZZLE_CONVERT(int32_t, int32_t, src); break;
+   default: assert(!"Invalid channel type combination");
+   }
+}
+
+void
+_mesa_swizzle_and_convert(void *void_dst, enum mesa_array_format_datatype dst_type, int num_dst_channels,
+                          const void *void_src, enum mesa_array_format_datatype src_type, int num_src_channels,
+                          const uint8_t swizzle[4], bool normalized, int count)
+{
+   /* 1. Try Direct Memcpy (Identical format/swizzle) */
+   if (swizzle_convert_try_memcpy(void_dst, dst_type, num_dst_channels,
+                                  void_src, src_type, num_src_channels,
+                                  swizzle, normalized, count))
+      return;
+
+   /* 2. Try AVX2 Swizzle (Supported formats) */
+   if (swizzle_convert_try_avx2(void_dst, dst_type, num_dst_channels,
+                                void_src, src_type, num_src_channels,
+                                swizzle, normalized, count))
+      return;
+
+   /* 3. Scalar Fallback */
+   switch (dst_type) {
+   case MESA_ARRAY_FORMAT_TYPE_FLOAT:  convert_float(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_HALF:   convert_half_float(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_UBYTE:  convert_ubyte(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_BYTE:   convert_byte(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_USHORT: convert_ushort(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_SHORT:  convert_short(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_UINT:   convert_uint(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   case MESA_ARRAY_FORMAT_TYPE_INT:    convert_int(void_dst, num_dst_channels, void_src, src_type, num_src_channels, swizzle, normalized, count); break;
+   default: assert(!"Invalid channel type");
+   }
+}
 
-/**
- * This can be used to convert between most color formats.
- *
- * Limitations:
- * - This function doesn't handle GL_COLOR_INDEX or YCBCR formats.
- * - This function doesn't handle byte-swapping or transferOps, these should
- *   be handled by the caller.
- *
- * \param void_dst  The address where converted color data will be stored.
- *                  The caller must ensure that the buffer is large enough
- *                  to hold the converted pixel data.
- * \param dst_format  The destination color format. It can be a mesa_format
- *                    or a mesa_array_format represented as an uint32_t.
- * \param dst_stride  The stride of the destination format in bytes.
- * \param void_src  The address of the source color data to convert.
- * \param src_format  The source color format. It can be a mesa_format
- *                    or a mesa_array_format represented as an uint32_t.
- * \param src_stride  The stride of the source format in bytes.
- * \param width  The width, in pixels, of the source image to convert.
- * \param height  The height, in pixels, of the source image to convert.
- * \param rebase_swizzle  A swizzle transform to apply during the conversion,
- *                        typically used to match a different internal base
- *                        format involved. NULL if no rebase transform is needed
- *                        (i.e. the internal base format and the base format of
- *                        the dst or the src -depending on whether we are doing
- *                        an upload or a download respectively- are the same).
- */
 void
 _mesa_format_convert(void *void_dst, uint32_t dst_format, size_t dst_stride,
                      void *void_src, uint32_t src_format, size_t src_stride,
@@ -288,9 +820,12 @@ _mesa_format_convert(void *void_dst, uin
    enum mesa_array_format_datatype src_type = 0, dst_type = 0, common_type;
    bool normalized, dst_integer, src_integer, is_signed;
    int src_num_channels = 0, dst_num_channels = 0;
-   uint8_t (*tmp_ubyte)[4];
-   float (*tmp_float)[4];
-   uint32_t (*tmp_uint)[4];
+
+   /* Row buffers for tiled processing */
+   uint8_t (*tmp_ubyte)[4] = NULL;
+   float (*tmp_float)[4] = NULL;
+   uint32_t (*tmp_uint)[4] = NULL;
+
    int bits;
    size_t row;
 
@@ -312,23 +847,23 @@ _mesa_format_convert(void *void_dst, uin
       dst_array_format = _mesa_format_to_array_format(dst_format);
    }
 
-   /* First we see if we can implement the conversion with a direct pack
-    * or unpack.
-    *
-    * In this case we want to be careful when we need to apply a swizzle to
-    * match an internal base format, since in these cases a simple pack/unpack
-    * to the dst format from the src format may not match the requirements
-    * of the internal base format. For now we decide to be safe and
-    * avoid this path in these scenarios but in the future we may want to
-    * enable it for specific combinations that are known to work.
-    */
+   /* --------------------------------------------------------------
+    * Fast Paths
+    * -------------------------------------------------------------- */
    if (!rebase_swizzle) {
-      /* Do a direct memcpy where possible */
+      /* Direct Memcpy */
       if ((dst_format_is_mesa_array_format &&
            src_format_is_mesa_array_format &&
            src_array_format == dst_array_format) ||
           src_format == dst_format) {
          int format_size = _mesa_get_format_bytes(src_format);
+
+         /* Check for potential contiguous block copy */
+         if (src_stride == width * format_size && dst_stride == width * format_size) {
+             memcpy(dst, src, height * src_stride);
+             return;
+         }
+
          for (row = 0; row < height; row++) {
             memcpy(dst, src, width * format_size);
             src += src_stride;
@@ -337,12 +872,30 @@ _mesa_format_convert(void *void_dst, uin
          return;
       }
 
-      /* Handle the cases where we can directly unpack */
+#if defined(__AVX2__)
+      /* 16-bit Swaps: A1B5G5R5 <-> B5G5R5A1 (Rotate Left/Right 1) */
+      if (src_format == MESA_FORMAT_A1B5G5R5_UNORM && dst_format == MESA_FORMAT_B5G5R5A1_UNORM) {
+         for (row = 0; row < height; row++) {
+            convert_16bit_rotate_avx2((uint16_t *)dst, (const uint16_t *)src, width, 0); /* Left */
+            src += src_stride;
+            dst += dst_stride;
+         }
+         return;
+      }
+      if (src_format == MESA_FORMAT_B5G5R5A1_UNORM && dst_format == MESA_FORMAT_A1B5G5R5_UNORM) {
+         for (row = 0; row < height; row++) {
+            convert_16bit_rotate_avx2((uint16_t *)dst, (const uint16_t *)src, width, 1); /* Right */
+            src += src_stride;
+            dst += dst_stride;
+         }
+         return;
+      }
+#endif
+
       if (!src_format_is_mesa_array_format) {
          if (dst_array_format == RGBA32_FLOAT) {
             for (row = 0; row < height; ++row) {
-               _mesa_unpack_rgba_row(src_format, width,
-                                     src, (float (*)[4])dst);
+               _mesa_unpack_rgba_row(src_format, width, src, (float (*)[4])dst);
                src += src_stride;
                dst += dst_stride;
             }
@@ -350,25 +903,20 @@ _mesa_format_convert(void *void_dst, uin
          } else if (dst_array_format == RGBA8_UBYTE) {
             assert(!_mesa_is_format_integer_color(src_format));
             for (row = 0; row < height; ++row) {
-               _mesa_unpack_ubyte_rgba_row(src_format, width,
-                                           src, (uint8_t (*)[4])dst);
+               _mesa_unpack_ubyte_rgba_row(src_format, width, src, (uint8_t (*)[4])dst);
                src += src_stride;
                dst += dst_stride;
             }
             return;
 #if UTIL_ARCH_LITTLE_ENDIAN
-         } else if (dst_array_format == BGRA8_UBYTE &&
-                    src_format == MESA_FORMAT_R8G8B8A8_UNORM) {
-             convert_ubyte_rgba_to_bgra(width, height, src, src_stride,
-                                        dst, dst_stride);
+         } else if (dst_array_format == BGRA8_UBYTE && src_format == MESA_FORMAT_R8G8B8A8_UNORM) {
+             convert_ubyte_rgba_to_bgra(width, height, src, src_stride, dst, dst_stride);
              return;
 #endif
-         } else if (dst_array_format == RGBA32_UINT &&
-                    _mesa_is_format_unsigned(src_format)) {
+         } else if (dst_array_format == RGBA32_UINT && _mesa_is_format_unsigned(src_format)) {
             assert(_mesa_is_format_integer_color(src_format));
             for (row = 0; row < height; ++row) {
-               _mesa_unpack_uint_rgba_row(src_format, width,
-                                          src, (uint32_t (*)[4])dst);
+               _mesa_unpack_uint_rgba_row(src_format, width, src, (uint32_t (*)[4])dst);
                src += src_stride;
                dst += dst_stride;
             }
@@ -376,25 +924,20 @@ _mesa_format_convert(void *void_dst, uin
          }
       }
 
-      /* Handle the cases where we can directly pack */
       if (!dst_format_is_mesa_array_format) {
          if (src_array_format == RGBA32_FLOAT) {
             for (row = 0; row < height; ++row) {
-               _mesa_pack_float_rgba_row(dst_format, width,
-                                         (const float (*)[4])src, dst);
+               _mesa_pack_float_rgba_row(dst_format, width, (const float (*)[4])src, dst);
                src += src_stride;
                dst += dst_stride;
             }
             return;
          } else if (src_array_format == RGBA8_UBYTE) {
             assert(!_mesa_is_format_integer_color(dst_format));
-
 #if UTIL_ARCH_LITTLE_ENDIAN
             if (dst_format == MESA_FORMAT_B8G8R8A8_UNORM) {
-               convert_ubyte_rgba_to_bgra(width, height, src, src_stride,
-                                          dst, dst_stride);
-            }
-            else
+               convert_ubyte_rgba_to_bgra(width, height, src, src_stride, dst, dst_stride);
+            } else
 #endif
             {
                for (row = 0; row < height; ++row) {
@@ -404,12 +947,10 @@ _mesa_format_convert(void *void_dst, uin
                }
             }
             return;
-         } else if (src_array_format == RGBA32_UINT &&
-                    _mesa_is_format_unsigned(dst_format)) {
+         } else if (src_array_format == RGBA32_UINT && _mesa_is_format_unsigned(dst_format)) {
             assert(_mesa_is_format_integer_color(dst_format));
             for (row = 0; row < height; ++row) {
-               _mesa_pack_uint_rgba_row(dst_format, width,
-                                        (const uint32_t (*)[4])src, dst);
+               _mesa_pack_uint_rgba_row(dst_format, width, (const uint32_t (*)[4])src, dst);
                src += src_stride;
                dst += dst_stride;
             }
@@ -418,26 +959,22 @@ _mesa_format_convert(void *void_dst, uin
       }
    }
 
-   /* Handle conversions between array formats */
+   /* --------------------------------------------------------------
+    * General Path: Row-Based Tiled Processing
+    * -------------------------------------------------------------- */
    normalized = false;
    if (src_array_format) {
       src_type = _mesa_array_format_get_datatype(src_array_format);
-
       src_num_channels = _mesa_array_format_get_num_channels(src_array_format);
-
       _mesa_array_format_get_swizzle(src_array_format, src2rgba);
-
       normalized = _mesa_array_format_is_normalized(src_array_format);
    }
 
    if (dst_array_format) {
       dst_type = _mesa_array_format_get_datatype(dst_array_format);
-
       dst_num_channels = _mesa_array_format_get_num_channels(dst_array_format);
-
       _mesa_array_format_get_swizzle(dst_array_format, dst2rgba);
       invert_swizzle(rgba2dst, dst2rgba);
-
       normalized |= _mesa_array_format_is_normalized(dst_array_format);
    }
 
@@ -445,8 +982,7 @@ _mesa_format_convert(void *void_dst, uin
       assert(_mesa_array_format_is_normalized(src_array_format) ==
              _mesa_array_format_is_normalized(dst_array_format));
 
-      compute_src2dst_component_mapping(src2rgba, rgba2dst, rebase_swizzle,
-                                        src2dst);
+      compute_src2dst_component_mapping(src2rgba, rgba2dst, rebase_swizzle, src2dst);
 
       for (row = 0; row < height; ++row) {
          _mesa_swizzle_and_convert(dst, dst_type, dst_num_channels,
@@ -458,15 +994,11 @@ _mesa_format_convert(void *void_dst, uin
       return;
    }
 
-   /* At this point, we're fresh out of fast-paths and we need to convert
-    * to float, uint32, or, if we're lucky, uint8.
-    */
    dst_integer = false;
    src_integer = false;
 
    if (src_array_format) {
-      if (!_mesa_array_format_is_float(src_array_format) &&
-          !_mesa_array_format_is_normalized(src_array_format))
+      if (!_mesa_array_format_is_float(src_array_format) && !_mesa_array_format_is_normalized(src_array_format))
          src_integer = true;
    } else {
       switch (_mesa_get_format_datatype(src_format)) {
@@ -477,986 +1009,124 @@ _mesa_format_convert(void *void_dst, uin
       }
    }
 
-   /* If the destination format is signed but the source is unsigned, then we
-    * don't loose any data by converting to a signed intermediate format above
-    * and beyond the precision that we loose in the conversion itself. If the
-    * destination is unsigned then, by using an unsigned intermediate format,
-    * we make the conversion function that converts from the source to the
-    * intermediate format take care of truncating at zero. The exception here
-    * is if the intermediate format is float, in which case the first
-    * conversion will leave it signed and the second conversion will truncate
-    * at zero.
-    */
    is_signed = false;
    if (dst_array_format) {
-      if (!_mesa_array_format_is_float(dst_array_format) &&
-          !_mesa_array_format_is_normalized(dst_array_format))
+      if (!_mesa_array_format_is_float(dst_array_format) && !_mesa_array_format_is_normalized(dst_array_format))
          dst_integer = true;
       is_signed = _mesa_array_format_is_signed(dst_array_format);
       bits = 8 * _mesa_array_format_get_type_size(dst_array_format);
    } else {
       switch (_mesa_get_format_datatype(dst_format)) {
-      case GL_UNSIGNED_NORMALIZED:
-         is_signed = false;
-         break;
-      case GL_SIGNED_NORMALIZED:
-         is_signed = true;
-         break;
-      case GL_FLOAT:
-         is_signed = true;
-         break;
-      case GL_UNSIGNED_INT:
-         is_signed = false;
-         dst_integer = true;
-         break;
-      case GL_INT:
-         is_signed = true;
-         dst_integer = true;
-         break;
+      case GL_UNSIGNED_NORMALIZED: is_signed = false; break;
+      case GL_SIGNED_NORMALIZED: is_signed = true; break;
+      case GL_FLOAT: is_signed = true; break;
+      case GL_UNSIGNED_INT: is_signed = false; dst_integer = true; break;
+      case GL_INT: is_signed = true; dst_integer = true; break;
       }
       bits = _mesa_get_format_max_bits(dst_format);
    }
 
    assert(src_integer == dst_integer);
 
+   /* --------------------------------------------------------------
+    * Allocation & Loop (Tiled)
+    * -------------------------------------------------------------- */
    if (src_integer && dst_integer) {
-      tmp_uint = malloc(width * height * sizeof(*tmp_uint));
+      common_type = is_signed ? MESA_ARRAY_FORMAT_TYPE_INT : MESA_ARRAY_FORMAT_TYPE_UINT;
+      tmp_uint = malloc(width * sizeof(*tmp_uint));
+      if (!tmp_uint) return;
 
-      /* The [un]packing functions for unsigned datatypes treat the 32-bit
-       * integer array as signed for signed formats and as unsigned for
-       * unsigned formats. This is a bit of a problem if we ever convert from
-       * a signed to an unsigned format because the unsigned packing function
-       * doesn't know that the input is signed and will treat it as unsigned
-       * and not do the trunctation. The thing that saves us here is that all
-       * of the packed formats are unsigned, so we can just always use
-       * _mesa_swizzle_and_convert for signed formats, which is aware of the
-       * truncation problem.
-       */
-      common_type = is_signed ? MESA_ARRAY_FORMAT_TYPE_INT :
-                                MESA_ARRAY_FORMAT_TYPE_UINT;
       if (src_array_format) {
-         compute_rebased_rgba_component_mapping(src2rgba, rebase_swizzle,
-                                                rebased_src2rgba);
-         for (row = 0; row < height; ++row) {
-            _mesa_swizzle_and_convert(tmp_uint + row * width, common_type, 4,
+         compute_rebased_rgba_component_mapping(src2rgba, rebase_swizzle, rebased_src2rgba);
+      }
+
+      for (row = 0; row < height; ++row) {
+         if (src_array_format) {
+            _mesa_swizzle_and_convert(tmp_uint, common_type, 4,
                                       src, src_type, src_num_channels,
                                       rebased_src2rgba, normalized, width);
-            src += src_stride;
-         }
-      } else {
-         for (row = 0; row < height; ++row) {
-            _mesa_unpack_uint_rgba_row(src_format, width,
-                                       src, tmp_uint + row * width);
+         } else {
+            _mesa_unpack_uint_rgba_row(src_format, width, src, tmp_uint);
             if (rebase_swizzle)
-               _mesa_swizzle_and_convert(tmp_uint + row * width, common_type, 4,
-                                         tmp_uint + row * width, common_type, 4,
+               _mesa_swizzle_and_convert(tmp_uint, common_type, 4,
+                                         tmp_uint, common_type, 4,
                                          rebase_swizzle, false, width);
-            src += src_stride;
          }
-      }
 
-      /* At this point, we have already done the truncation if the source is
-       * signed but the destination is unsigned, so no need to force the
-       * _mesa_swizzle_and_convert path.
-       */
-      if (dst_format_is_mesa_array_format) {
-         for (row = 0; row < height; ++row) {
+         if (dst_format_is_mesa_array_format) {
             _mesa_swizzle_and_convert(dst, dst_type, dst_num_channels,
-                                      tmp_uint + row * width, common_type, 4,
+                                      tmp_uint, common_type, 4,
                                       rgba2dst, normalized, width);
-            dst += dst_stride;
-         }
-      } else {
-         for (row = 0; row < height; ++row) {
-            _mesa_pack_uint_rgba_row(dst_format, width,
-                                     (const uint32_t (*)[4])tmp_uint + row * width, dst);
-            dst += dst_stride;
+         } else {
+            _mesa_pack_uint_rgba_row(dst_format, width, (const uint32_t (*)[4])tmp_uint, dst);
          }
+         src += src_stride;
+         dst += dst_stride;
       }
-
       free(tmp_uint);
    } else if (is_signed || bits > 8) {
-      tmp_float = malloc(width * height * sizeof(*tmp_float));
+      tmp_float = malloc(width * sizeof(*tmp_float));
+      if (!tmp_float) return;
 
       if (src_format_is_mesa_array_format) {
-         compute_rebased_rgba_component_mapping(src2rgba, rebase_swizzle,
-                                                rebased_src2rgba);
-         for (row = 0; row < height; ++row) {
-            _mesa_swizzle_and_convert(tmp_float + row * width,
-                                      MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
+         compute_rebased_rgba_component_mapping(src2rgba, rebase_swizzle, rebased_src2rgba);
+      }
+
+      for (row = 0; row < height; ++row) {
+         if (src_format_is_mesa_array_format) {
+            _mesa_swizzle_and_convert(tmp_float, MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
                                       src, src_type, src_num_channels,
                                       rebased_src2rgba, normalized, width);
-            src += src_stride;
-         }
-      } else {
-         for (row = 0; row < height; ++row) {
-            _mesa_unpack_rgba_row(src_format, width,
-                                  src, tmp_float + row * width);
+         } else {
+            _mesa_unpack_rgba_row(src_format, width, src, tmp_float);
             if (rebase_swizzle)
-               _mesa_swizzle_and_convert(tmp_float + row * width,
-                                         MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
-                                         tmp_float + row * width,
-                                         MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
+               _mesa_swizzle_and_convert(tmp_float, MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
+                                         tmp_float, MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
                                          rebase_swizzle, normalized, width);
-            src += src_stride;
          }
-      }
 
-      if (dst_format_is_mesa_array_format) {
-         for (row = 0; row < height; ++row) {
+         if (dst_format_is_mesa_array_format) {
             _mesa_swizzle_and_convert(dst, dst_type, dst_num_channels,
-                                      tmp_float + row * width,
-                                      MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
+                                      tmp_float, MESA_ARRAY_FORMAT_TYPE_FLOAT, 4,
                                       rgba2dst, normalized, width);
-            dst += dst_stride;
-         }
-      } else {
-         for (row = 0; row < height; ++row) {
-            _mesa_pack_float_rgba_row(dst_format, width,
-                                      (const float (*)[4])tmp_float + row * width, dst);
-            dst += dst_stride;
+         } else {
+            _mesa_pack_float_rgba_row(dst_format, width, (const float (*)[4])tmp_float, dst);
          }
+         src += src_stride;
+         dst += dst_stride;
       }
-
       free(tmp_float);
    } else {
-      tmp_ubyte = malloc(width * height * sizeof(*tmp_ubyte));
+      tmp_ubyte = malloc(width * sizeof(*tmp_ubyte));
+      if (!tmp_ubyte) return;
 
       if (src_format_is_mesa_array_format) {
-         compute_rebased_rgba_component_mapping(src2rgba, rebase_swizzle,
-                                                rebased_src2rgba);
-         for (row = 0; row < height; ++row) {
-            _mesa_swizzle_and_convert(tmp_ubyte + row * width,
-                                      MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
+         compute_rebased_rgba_component_mapping(src2rgba, rebase_swizzle, rebased_src2rgba);
+      }
+
+      for (row = 0; row < height; ++row) {
+         if (src_format_is_mesa_array_format) {
+            _mesa_swizzle_and_convert(tmp_ubyte, MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
                                       src, src_type, src_num_channels,
                                       rebased_src2rgba, normalized, width);
-            src += src_stride;
-         }
-      } else {
-         for (row = 0; row < height; ++row) {
-            _mesa_unpack_ubyte_rgba_row(src_format, width,
-                                        src, tmp_ubyte + row * width);
+         } else {
+            _mesa_unpack_ubyte_rgba_row(src_format, width, src, tmp_ubyte);
             if (rebase_swizzle)
-               _mesa_swizzle_and_convert(tmp_ubyte + row * width,
-                                         MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
-                                         tmp_ubyte + row * width,
-                                         MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
+               _mesa_swizzle_and_convert(tmp_ubyte, MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
+                                         tmp_ubyte, MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
                                          rebase_swizzle, normalized, width);
-            src += src_stride;
          }
-      }
 
-      if (dst_format_is_mesa_array_format) {
-         for (row = 0; row < height; ++row) {
+         if (dst_format_is_mesa_array_format) {
             _mesa_swizzle_and_convert(dst, dst_type, dst_num_channels,
-                                      tmp_ubyte + row * width,
-                                      MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
+                                      tmp_ubyte, MESA_ARRAY_FORMAT_TYPE_UBYTE, 4,
                                       rgba2dst, normalized, width);
-            dst += dst_stride;
-         }
-      } else {
-         for (row = 0; row < height; ++row) {
-            _mesa_pack_ubyte_rgba_row(dst_format, width,
-                                      (const uint8_t *)(tmp_ubyte + row * width), dst);
-            dst += dst_stride;
+         } else {
+            _mesa_pack_ubyte_rgba_row(dst_format, width, (const uint8_t *)tmp_ubyte, dst);
          }
+         src += src_stride;
+         dst += dst_stride;
       }
-
       free(tmp_ubyte);
    }
 }
-
-/**
- * Attempts to perform the given swizzle-and-convert operation with memcpy
- *
- * This function determines if the given swizzle-and-convert operation can
- * be done with a simple memcpy and, if so, does the memcpy.  If not, it
- * returns false and we fall back to the standard version below.
- *
- * The arguments are exactly the same as for _mesa_swizzle_and_convert
- *
- * \return  true if it successfully performed the swizzle-and-convert
- *          operation with memcpy, false otherwise
- */
-static bool
-swizzle_convert_try_memcpy(void *dst,
-                           enum mesa_array_format_datatype dst_type,
-                           int num_dst_channels,
-                           const void *src,
-                           enum mesa_array_format_datatype src_type,
-                           int num_src_channels,
-                           const uint8_t swizzle[4], bool normalized, int count)
-{
-   int i;
-
-   if (src_type != dst_type)
-      return false;
-   if (num_src_channels != num_dst_channels)
-      return false;
-
-   for (i = 0; i < num_dst_channels; ++i)
-      if (swizzle[i] != i && swizzle[i] != MESA_FORMAT_SWIZZLE_NONE)
-         return false;
-
-   memcpy(dst, src, count * num_src_channels *
-          _mesa_array_format_datatype_get_size(src_type));
-
-   return true;
-}
-
-/**
- * Represents a single instance of the standard swizzle-and-convert loop
- *
- * Any swizzle-and-convert operation simply loops through the pixels and
- * performs the transformation operation one pixel at a time.  This macro
- * embodies one instance of the conversion loop.  This way we can do all
- * control flow outside of the loop and allow the compiler to unroll
- * everything inside the loop.
- *
- * Note: This loop is carefully crafted for performance.  Be careful when
- * changing it and run some benchmarks to ensure no performance regressions
- * if you do.
- *
- * \param   DST_TYPE    the C datatype of the destination
- * \param   DST_CHANS   the number of destination channels
- * \param   SRC_TYPE    the C datatype of the source
- * \param   SRC_CHANS   the number of source channels
- * \param   CONV        an expression for converting from the source data,
- *                      storred in the variable "src", to the destination
- *                      format
- */
-#define SWIZZLE_CONVERT_LOOP(DST_TYPE, DST_CHANS, SRC_TYPE, SRC_CHANS, CONV) \
-   do {                                           \
-      int s, j;                                   \
-      for (s = 0; s < count; ++s) {               \
-         for (j = 0; j < SRC_CHANS; ++j) {        \
-            SRC_TYPE src = typed_src[j];          \
-            tmp[j] = CONV;                        \
-         }                                        \
-                                                  \
-         typed_dst[0] = tmp[swizzle_x];           \
-         if (DST_CHANS > 1) {                     \
-            typed_dst[1] = tmp[swizzle_y];        \
-            if (DST_CHANS > 2) {                  \
-               typed_dst[2] = tmp[swizzle_z];     \
-               if (DST_CHANS > 3) {               \
-                  typed_dst[3] = tmp[swizzle_w];  \
-               }                                  \
-            }                                     \
-         }                                        \
-         typed_src += SRC_CHANS;                  \
-         typed_dst += DST_CHANS;                  \
-      }                                           \
-   } while (0)
-
-/**
- * Represents a single swizzle-and-convert operation
- *
- * This macro represents everything done in a single swizzle-and-convert
- * operation.  The actual work is done by the SWIZZLE_CONVERT_LOOP macro.
- * This macro acts as a wrapper that uses a nested switch to ensure that
- * all looping parameters get unrolled.
- *
- * This macro makes assumptions about variables etc. in the calling
- * function.  Changes to _mesa_swizzle_and_convert may require changes to
- * this macro.
- *
- * \param   DST_TYPE    the C datatype of the destination
- * \param   SRC_TYPE    the C datatype of the source
- * \param   CONV        an expression for converting from the source data,
- *                      storred in the variable "src", to the destination
- *                      format
- */
-#define SWIZZLE_CONVERT(DST_TYPE, SRC_TYPE, CONV)                 \
-   do {                                                           \
-      const uint8_t swizzle_x = swizzle[0];                       \
-      const uint8_t swizzle_y = swizzle[1];                       \
-      const uint8_t swizzle_z = swizzle[2];                       \
-      const uint8_t swizzle_w = swizzle[3];                       \
-      const SRC_TYPE *typed_src = void_src;                       \
-      DST_TYPE *typed_dst = void_dst;                             \
-      DST_TYPE tmp[7];                                            \
-      tmp[4] = 0;                                                 \
-      tmp[5] = one;                                               \
-      switch (num_dst_channels) {                                 \
-      case 1:                                                     \
-         switch (num_src_channels) {                              \
-         case 1:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 1, CONV); \
-            break;                                                \
-         case 2:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 2, CONV); \
-            break;                                                \
-         case 3:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 3, CONV); \
-            break;                                                \
-         case 4:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 1, SRC_TYPE, 4, CONV); \
-            break;                                                \
-         }                                                        \
-         break;                                                   \
-      case 2:                                                     \
-         switch (num_src_channels) {                              \
-         case 1:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 1, CONV); \
-            break;                                                \
-         case 2:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 2, CONV); \
-            break;                                                \
-         case 3:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 3, CONV); \
-            break;                                                \
-         case 4:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 2, SRC_TYPE, 4, CONV); \
-            break;                                                \
-         }                                                        \
-         break;                                                   \
-      case 3:                                                     \
-         switch (num_src_channels) {                              \
-         case 1:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 1, CONV); \
-            break;                                                \
-         case 2:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 2, CONV); \
-            break;                                                \
-         case 3:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 3, CONV); \
-            break;                                                \
-         case 4:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 3, SRC_TYPE, 4, CONV); \
-            break;                                                \
-         }                                                        \
-         break;                                                   \
-      case 4:                                                     \
-         switch (num_src_channels) {                              \
-         case 1:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 1, CONV); \
-            break;                                                \
-         case 2:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 2, CONV); \
-            break;                                                \
-         case 3:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 3, CONV); \
-            break;                                                \
-         case 4:                                                  \
-            SWIZZLE_CONVERT_LOOP(DST_TYPE, 4, SRC_TYPE, 4, CONV); \
-            break;                                                \
-         }                                                        \
-         break;                                                   \
-      }                                                           \
-   } while (0)
-
-
-static void
-convert_float(void *void_dst, int num_dst_channels,
-              const void *void_src, GLenum src_type, int num_src_channels,
-              const uint8_t swizzle[4], bool normalized, int count)
-{
-   const float one = 1.0f;
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      SWIZZLE_CONVERT(float, float, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      SWIZZLE_CONVERT(float, uint16_t, _mesa_half_to_float(src));
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(float, uint8_t, _mesa_unorm_to_float(src, 8));
-      } else {
-         SWIZZLE_CONVERT(float, uint8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(float, int8_t, _mesa_snorm_to_float(src, 8));
-      } else {
-         SWIZZLE_CONVERT(float, int8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(float, uint16_t, _mesa_unorm_to_float(src, 16));
-      } else {
-         SWIZZLE_CONVERT(float, uint16_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(float, int16_t, _mesa_snorm_to_float(src, 16));
-      } else {
-         SWIZZLE_CONVERT(float, int16_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(float, uint32_t, _mesa_unorm_to_float(src, 32));
-      } else {
-         SWIZZLE_CONVERT(float, uint32_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(float, int32_t, _mesa_snorm_to_float(src, 32));
-      } else {
-         SWIZZLE_CONVERT(float, int32_t, src);
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-
-static void
-convert_half_float(void *void_dst, int num_dst_channels,
-                   const void *void_src, GLenum src_type, int num_src_channels,
-                   const uint8_t swizzle[4], bool normalized, int count)
-{
-   const uint16_t one = _mesa_float_to_half(1.0f);
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_half(src));
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      SWIZZLE_CONVERT(uint16_t, uint16_t, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint8_t, _mesa_unorm_to_half(src, 8));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint8_t, _mesa_float_to_half(src));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_snorm_to_half(src, 8));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_float_to_half(src));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_unorm_to_half(src, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_float_to_half(src));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_snorm_to_half(src, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_float_to_half(src));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_unorm_to_half(src, 32));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_float_to_half(src));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_snorm_to_half(src, 32));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_float_to_half(src));
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-static void
-convert_ubyte(void *void_dst, int num_dst_channels,
-              const void *void_src, GLenum src_type, int num_src_channels,
-              const uint8_t swizzle[4], bool normalized, int count)
-{
-   const uint8_t one = normalized ? UINT8_MAX : 1;
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_unorm(src, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_unsigned(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_unorm(src, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_unsigned(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      SWIZZLE_CONVERT(uint8_t, uint8_t, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, int8_t, _mesa_snorm_to_unorm(src, 8, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, int8_t, _mesa_signed_to_unsigned(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_unorm_to_unorm(src, 16, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_unsigned_to_unsigned(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, int16_t, _mesa_snorm_to_unorm(src, 16, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, int16_t, _mesa_signed_to_unsigned(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, uint32_t, _mesa_unorm_to_unorm(src, 32, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, uint32_t, _mesa_unsigned_to_unsigned(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, int32_t, _mesa_snorm_to_unorm(src, 32, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, int32_t, _mesa_signed_to_unsigned(src, 8));
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-
-static void
-convert_byte(void *void_dst, int num_dst_channels,
-             const void *void_src, GLenum src_type, int num_src_channels,
-             const uint8_t swizzle[4], bool normalized, int count)
-{
-   const int8_t one = normalized ? INT8_MAX : 1;
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_snorm(src, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, float, _mesa_float_to_signed(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_snorm(src, 8));
-      } else {
-         SWIZZLE_CONVERT(uint8_t, uint16_t, _mesa_half_to_signed(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(int8_t, uint8_t, _mesa_unorm_to_snorm(src, 8, 8));
-      } else {
-         SWIZZLE_CONVERT(int8_t, uint8_t, _mesa_unsigned_to_signed(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      SWIZZLE_CONVERT(int8_t, int8_t, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int8_t, uint16_t, _mesa_unorm_to_snorm(src, 16, 8));
-      } else {
-         SWIZZLE_CONVERT(int8_t, uint16_t, _mesa_unsigned_to_signed(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int8_t, int16_t, _mesa_snorm_to_snorm(src, 16, 8));
-      } else {
-         SWIZZLE_CONVERT(int8_t, int16_t, _mesa_signed_to_signed(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int8_t, uint32_t, _mesa_unorm_to_snorm(src, 32, 8));
-      } else {
-         SWIZZLE_CONVERT(int8_t, uint32_t, _mesa_unsigned_to_signed(src, 8));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int8_t, int32_t, _mesa_snorm_to_snorm(src, 32, 8));
-      } else {
-         SWIZZLE_CONVERT(int8_t, int32_t, _mesa_signed_to_signed(src, 8));
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-
-static void
-convert_ushort(void *void_dst, int num_dst_channels,
-               const void *void_src, GLenum src_type, int num_src_channels,
-               const uint8_t swizzle[4], bool normalized, int count)
-{
-   const uint16_t one = normalized ? UINT16_MAX : 1;
-   
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_unorm(src, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_unsigned(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_unorm(src, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_unsigned(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint8_t, _mesa_unorm_to_unorm(src, 8, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_snorm_to_unorm(src, 8, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, int8_t, _mesa_signed_to_unsigned(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      SWIZZLE_CONVERT(uint16_t, uint16_t, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_snorm_to_unorm(src, 16, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, int16_t, _mesa_signed_to_unsigned(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_unorm_to_unorm(src, 32, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint32_t, _mesa_unsigned_to_unsigned(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_snorm_to_unorm(src, 32, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, int32_t, _mesa_signed_to_unsigned(src, 16));
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-
-static void
-convert_short(void *void_dst, int num_dst_channels,
-              const void *void_src, GLenum src_type, int num_src_channels,
-              const uint8_t swizzle[4], bool normalized, int count)
-{
-   const int16_t one = normalized ? INT16_MAX : 1;
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_snorm(src, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, float, _mesa_float_to_signed(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_snorm(src, 16));
-      } else {
-         SWIZZLE_CONVERT(uint16_t, uint16_t, _mesa_half_to_signed(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(int16_t, uint8_t, _mesa_unorm_to_snorm(src, 8, 16));
-      } else {
-         SWIZZLE_CONVERT(int16_t, uint8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(int16_t, int8_t, _mesa_snorm_to_snorm(src, 8, 16));
-      } else {
-         SWIZZLE_CONVERT(int16_t, int8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int16_t, uint16_t, _mesa_unorm_to_snorm(src, 16, 16));
-      } else {
-         SWIZZLE_CONVERT(int16_t, uint16_t, _mesa_unsigned_to_signed(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      SWIZZLE_CONVERT(int16_t, int16_t, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int16_t, uint32_t, _mesa_unorm_to_snorm(src, 32, 16));
-      } else {
-         SWIZZLE_CONVERT(int16_t, uint32_t, _mesa_unsigned_to_signed(src, 16));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int16_t, int32_t, _mesa_snorm_to_snorm(src, 32, 16));
-      } else {
-         SWIZZLE_CONVERT(int16_t, int32_t, _mesa_signed_to_signed(src, 16));
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-static void
-convert_uint(void *void_dst, int num_dst_channels,
-             const void *void_src, GLenum src_type, int num_src_channels,
-             const uint8_t swizzle[4], bool normalized, int count)
-{
-   const uint32_t one = normalized ? UINT32_MAX : 1;
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_unorm(src, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_unsigned(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_unorm(src, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_unsigned(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, uint8_t, _mesa_unorm_to_unorm(src, 8, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, uint8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, int8_t, _mesa_snorm_to_unorm(src, 8, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, int8_t, _mesa_signed_to_unsigned(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_unorm_to_unorm(src, 16, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, uint16_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, int16_t, _mesa_snorm_to_unorm(src, 16, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, int16_t, _mesa_signed_to_unsigned(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      SWIZZLE_CONVERT(uint32_t, uint32_t, src);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, int32_t, _mesa_snorm_to_unorm(src, 32, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, int32_t, _mesa_signed_to_unsigned(src, 32));
-      }
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-
-static void
-convert_int(void *void_dst, int num_dst_channels,
-            const void *void_src, GLenum src_type, int num_src_channels,
-            const uint8_t swizzle[4], bool normalized, int count)
-{
-   const int32_t one = normalized ? INT32_MAX : 1;
-
-   switch (src_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_snorm(src, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, float, _mesa_float_to_signed(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      if (normalized) {
-         SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_snorm(src, 32));
-      } else {
-         SWIZZLE_CONVERT(uint32_t, uint16_t, _mesa_half_to_signed(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(int32_t, uint8_t, _mesa_unorm_to_snorm(src, 8, 32));
-      } else {
-         SWIZZLE_CONVERT(int32_t, uint8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      if (normalized) {
-         SWIZZLE_CONVERT(int32_t, int8_t, _mesa_snorm_to_snorm(src, 8, 32));
-      } else {
-         SWIZZLE_CONVERT(int32_t, int8_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int32_t, uint16_t, _mesa_unorm_to_snorm(src, 16, 32));
-      } else {
-         SWIZZLE_CONVERT(int32_t, uint16_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int32_t, int16_t, _mesa_snorm_to_snorm(src, 16, 32));
-      } else {
-         SWIZZLE_CONVERT(int32_t, int16_t, src);
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      if (normalized) {
-         SWIZZLE_CONVERT(int32_t, uint32_t, _mesa_unorm_to_snorm(src, 32, 32));
-      } else {
-         SWIZZLE_CONVERT(int32_t, uint32_t, _mesa_unsigned_to_signed(src, 32));
-      }
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      SWIZZLE_CONVERT(int32_t, int32_t, src);
-      break;
-   default:
-      assert(!"Invalid channel type combination");
-   }
-}
-
-
-/**
- * Convert between array-based color formats.
- *
- * Most format conversion operations required by GL can be performed by
- * converting one channel at a time, shuffling the channels around, and
- * optionally filling missing channels with zeros and ones.  This function
- * does just that in a general, yet efficient, way.
- *
- * The swizzle parameter is an array of 4 numbers (see
- * _mesa_get_format_swizzle) that describes where each channel in the
- * destination should come from in the source.  If swizzle[i] < 4 then it
- * means that dst[i] = CONVERT(src[swizzle[i]]).  If swizzle[i] is
- * MESA_FORMAT_SWIZZLE_ZERO or MESA_FORMAT_SWIZZLE_ONE, the corresponding
- * dst[i] will be filled with the appropreate representation of zero or one
- * respectively.
- *
- * Under most circumstances, the source and destination images must be
- * different as no care is taken not to clobber one with the other.
- * However, if they have the same number of bits per pixel, it is safe to
- * do an in-place conversion.
- *
- * \param[out] dst               pointer to where the converted data should
- *                               be stored
- *
- * \param[in]  dst_type          the destination GL type of the converted
- *                               data (GL_BYTE, etc.)
- *
- * \param[in]  num_dst_channels  the number of channels in the converted
- *                               data
- *
- * \param[in]  src               pointer to the source data
- *
- * \param[in]  src_type          the GL type of the source data (GL_BYTE,
- *                               etc.)
- *
- * \param[in]  num_src_channels  the number of channels in the source data
- *                               (the number of channels total, not just
- *                               the number used)
- *
- * \param[in]  swizzle           describes how to get the destination data
- *                               from the source data.
- *
- * \param[in]  normalized        for integer types, this indicates whether
- *                               the data should be considered as integers
- *                               or as normalized integers;
- *
- * \param[in]  count             the number of pixels to convert
- */
-void
-_mesa_swizzle_and_convert(void *void_dst, enum mesa_array_format_datatype dst_type, int num_dst_channels,
-                          const void *void_src, enum mesa_array_format_datatype src_type, int num_src_channels,
-                          const uint8_t swizzle[4], bool normalized, int count)
-{
-   if (swizzle_convert_try_memcpy(void_dst, dst_type, num_dst_channels,
-                                  void_src, src_type, num_src_channels,
-                                  swizzle, normalized, count))
-      return;
-
-   switch (dst_type) {
-   case MESA_ARRAY_FORMAT_TYPE_FLOAT:
-      convert_float(void_dst, num_dst_channels, void_src, src_type,
-                    num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_HALF:
-      convert_half_float(void_dst, num_dst_channels, void_src, src_type,
-                    num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UBYTE:
-      convert_ubyte(void_dst, num_dst_channels, void_src, src_type,
-                    num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_BYTE:
-      convert_byte(void_dst, num_dst_channels, void_src, src_type,
-                   num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_USHORT:
-      convert_ushort(void_dst, num_dst_channels, void_src, src_type,
-                     num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_SHORT:
-      convert_short(void_dst, num_dst_channels, void_src, src_type,
-                    num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_UINT:
-      convert_uint(void_dst, num_dst_channels, void_src, src_type,
-                   num_src_channels, swizzle, normalized, count);
-      break;
-   case MESA_ARRAY_FORMAT_TYPE_INT:
-      convert_int(void_dst, num_dst_channels, void_src, src_type,
-                  num_src_channels, swizzle, normalized, count);
-      break;
-   default:
-      assert(!"Invalid channel type");
-   }
-}
