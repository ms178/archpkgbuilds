From cf6be48cd26dfe6cdcd52e704010bb76c33aedc3 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 4 May 2024 10:53:46 +0200
Subject: [PATCH 1/4] vulkan: Handle group stages in
 vk_.*_access2_for_pipeline_stage_flags2

Avoids calling vk_expand_.*_stage_flags2.
---
 .../util/vk_synchronization_helpers_gen.py    | 27 +++++++++++++++----
 1 file changed, 22 insertions(+), 5 deletions(-)

diff --git a/src/vulkan/util/vk_synchronization_helpers_gen.py b/src/vulkan/util/vk_synchronization_helpers_gen.py
index bc256752ba2a2..eb3fc6228ed5b 100644
--- a/src/vulkan/util/vk_synchronization_helpers_gen.py
+++ b/src/vulkan/util/vk_synchronization_helpers_gen.py
@@ -168,7 +168,7 @@ def access_is_read(name):
         print(name)
         assert False, "Invalid access bit name"
 
-def get_stages_access(xml, read, guards):
+def get_stages_access(xml, read, guards, all_commands_stages, group_stages):
     stages_access = {}
     for access in xml.findall('./sync/syncaccess'):
         access_name = access.attrib['name']
@@ -182,6 +182,20 @@ def get_stages_access(xml, read, guards):
         support = access.find('./syncsupport')
         if support is not None:
             stages = support.attrib['stage'].split(',')
+
+            for stage in stages:
+                if (guard, stage) in all_commands_stages:
+                    stages.append('VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT')
+                    stages.append('VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT' if read else 'VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT')
+                    break
+
+            for (group, equiv) in group_stages.items():
+                for stage in stages:
+                    if stage in equiv:
+                        stages.append(group)
+                        break
+
+
             stages.sort()
             key = (guard, tuple(stages))
             if key in stages_access:
@@ -201,11 +215,14 @@ def main():
     xml = et.parse(args.xml);
 
     guards = get_guards(xml, 'vulkan')
+    all_commands_stages = get_all_commands_stages(xml, guards)
+    group_stages = get_group_stages(xml)
+
     environment = {
-        'all_commands_stages': get_all_commands_stages(xml, guards),
-        'group_stages': get_group_stages(xml),
-        'stages_read_access': get_stages_access(xml, True, guards),
-        'stages_write_access': get_stages_access(xml, False, guards),
+        'all_commands_stages': all_commands_stages,
+        'group_stages': group_stages,
+        'stages_read_access': get_stages_access(xml, True, guards, all_commands_stages, group_stages),
+        'stages_write_access': get_stages_access(xml, False, guards, all_commands_stages, group_stages),
     }
 
     try:
-- 
GitLab


From edbdbad5e5e9f851013cc4ff700e7d84f651b276 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Thu, 23 May 2024 11:42:08 +0200
Subject: [PATCH 2/4] vulkan: Add vk_expand_(dst|src)_access_flags2

Those helpers do not filter out dead access bits to keep synchronization
conservative.
---
 src/vulkan/runtime/vk_synchronization.c | 30 ++++++++++++++++++++-----
 src/vulkan/runtime/vk_synchronization.h |  8 +++++++
 2 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/src/vulkan/runtime/vk_synchronization.c b/src/vulkan/runtime/vk_synchronization.c
index 701474164e456..a9aadc85b1d4f 100644
--- a/src/vulkan/runtime/vk_synchronization.c
+++ b/src/vulkan/runtime/vk_synchronization.c
@@ -32,7 +32,7 @@
 #include "../wsi/wsi_common.h"
 
 VkAccessFlags2
-vk_filter_src_access_flags2(VkPipelineStageFlags2 stages,
+vk_expand_src_access_flags2(VkPipelineStageFlags2 stages,
                             VkAccessFlags2 access)
 {
    const VkPipelineStageFlags2 all_write_access =
@@ -44,12 +44,11 @@ vk_filter_src_access_flags2(VkPipelineStageFlags2 stages,
    if (access & VK_ACCESS_2_SHADER_WRITE_BIT)
       access |= VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT;
 
-   /* We only care about write access in src flags */
-   return access & all_write_access;
+   return access;
 }
 
 VkAccessFlags2
-vk_filter_dst_access_flags2(VkPipelineStageFlags2 stages,
+vk_expand_dst_access_flags2(VkPipelineStageFlags2 stages,
                             VkAccessFlags2 access)
 {
    const VkPipelineStageFlags2 all_read_access =
@@ -63,8 +62,29 @@ vk_filter_dst_access_flags2(VkPipelineStageFlags2 stages,
                 VK_ACCESS_2_SHADER_STORAGE_READ_BIT |
                 VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR;
 
+   return access;
+}
+
+VkAccessFlags2
+vk_filter_src_access_flags2(VkPipelineStageFlags2 stages,
+                            VkAccessFlags2 access)
+{
+   const VkPipelineStageFlags2 all_write_access =
+      vk_write_access2_for_pipeline_stage_flags2(stages);
+
+   /* We only care about write access in src flags */
+   return vk_expand_src_access_flags2(stages, access) & all_write_access;
+}
+
+VkAccessFlags2
+vk_filter_dst_access_flags2(VkPipelineStageFlags2 stages,
+                            VkAccessFlags2 access)
+{
+   const VkPipelineStageFlags2 all_read_access =
+      vk_read_access2_for_pipeline_stage_flags2(stages);
+
    /* We only care about read access in dst flags */
-   return access & all_read_access;
+   return vk_expand_dst_access_flags2(stages, access) & all_read_access;
 }
 
 VKAPI_ATTR void VKAPI_CALL
diff --git a/src/vulkan/runtime/vk_synchronization.h b/src/vulkan/runtime/vk_synchronization.h
index 5c3fd1f4992f3..0ffbc2d3b202d 100644
--- a/src/vulkan/runtime/vk_synchronization.h
+++ b/src/vulkan/runtime/vk_synchronization.h
@@ -94,6 +94,14 @@ vk_read_access2_for_pipeline_stage_flags2(VkPipelineStageFlags2 stages);
 VkAccessFlags2
 vk_write_access2_for_pipeline_stage_flags2(VkPipelineStageFlags2 stages);
 
+VkAccessFlags2
+vk_expand_src_access_flags2(VkPipelineStageFlags2 stages,
+                            VkAccessFlags2 access);
+
+VkAccessFlags2
+vk_expand_dst_access_flags2(VkPipelineStageFlags2 stages,
+                            VkAccessFlags2 access);
+
 VkAccessFlags2
 vk_filter_src_access_flags2(VkPipelineStageFlags2 stages,
                             VkAccessFlags2 access);
-- 
GitLab


From a17fd47870d8689de8b415af5e20c602bc1067e7 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Fri, 3 May 2024 20:07:11 +0200
Subject: [PATCH 3/4] radv: Use vk_expand_(src|dst)_access_flags2

Simplifies access flags handling since the driver doesn't have to worry
about VK_ACCESS_2_MEMORY_READ_BIT and friends.
---
 src/amd/vulkan/meta/radv_meta_buffer.c        |  5 +-
 src/amd/vulkan/meta/radv_meta_clear.c         | 14 ++--
 src/amd/vulkan/meta/radv_meta_copy.c          |  8 +-
 .../vulkan/meta/radv_meta_copy_vrs_htile.c    |  9 ++-
 src/amd/vulkan/meta/radv_meta_dcc_retile.c    |  5 +-
 src/amd/vulkan/meta/radv_meta_decompress.c    |  5 +-
 src/amd/vulkan/meta/radv_meta_fast_clear.c    | 14 ++--
 src/amd/vulkan/meta/radv_meta_fmask_expand.c  |  5 +-
 src/amd/vulkan/meta/radv_meta_resolve.c       |  7 +-
 src/amd/vulkan/meta/radv_meta_resolve_cs.c    | 14 ++--
 src/amd/vulkan/meta/radv_meta_resolve_fs.c    |  9 ++-
 src/amd/vulkan/radv_acceleration_structure.c  | 13 ++--
 src/amd/vulkan/radv_cmd_buffer.c              | 78 +++++++++++--------
 src/amd/vulkan/radv_cmd_buffer.h              |  8 +-
 14 files changed, 111 insertions(+), 83 deletions(-)

diff --git a/src/amd/vulkan/meta/radv_meta_buffer.c b/src/amd/vulkan/meta/radv_meta_buffer.c
index 25473ff1026bb..65c0b4502ecf8 100644
--- a/src/amd/vulkan/meta/radv_meta_buffer.c
+++ b/src/amd/vulkan/meta/radv_meta_buffer.c
@@ -247,8 +247,9 @@ radv_fill_buffer(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
    } else if (use_compute) {
       fill_buffer_shader(cmd_buffer, va, size, value);
 
-      flush_bits = RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
-                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+      flush_bits =
+         RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
+         radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, image);
    } else if (size)
       radv_cp_dma_clear_buffer(cmd_buffer, va, size, value);
 
diff --git a/src/amd/vulkan/meta/radv_meta_clear.c b/src/amd/vulkan/meta/radv_meta_clear.c
index 6ea0c59ae6eb1..c597fc05ea170 100644
--- a/src/amd/vulkan/meta/radv_meta_clear.c
+++ b/src/amd/vulkan/meta/radv_meta_clear.c
@@ -623,7 +623,8 @@ clear_htile_mask(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
 
    radv_meta_restore(&saved_state, cmd_buffer);
 
-   return RADV_CMD_FLAG_CS_PARTIAL_FLUSH | radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+   return RADV_CMD_FLAG_CS_PARTIAL_FLUSH | radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,
+                                                                 VK_ACCESS_2_SHADER_WRITE_BIT, image);
 }
 
 static uint32_t
@@ -761,8 +762,8 @@ radv_fast_clear_depth(struct radv_cmd_buffer *cmd_buffer, const struct radv_imag
 
    if (pre_flush) {
       enum radv_cmd_flush_bits bits =
-         radv_src_access_flush(cmd_buffer, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, iview->image) |
-         radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, iview->image);
+         radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, iview->image) |
+         radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, iview->image);
       cmd_buffer->state.flush_bits |= bits & ~*pre_flush;
       *pre_flush |= cmd_buffer->state.flush_bits;
    }
@@ -1318,7 +1319,8 @@ radv_clear_dcc_comp_to_single(struct radv_cmd_buffer *cmd_buffer, struct radv_im
 
    radv_meta_restore(&saved_state, cmd_buffer);
 
-   return RADV_CMD_FLAG_CS_PARTIAL_FLUSH | radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+   return RADV_CMD_FLAG_CS_PARTIAL_FLUSH | radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,
+                                                                 VK_ACCESS_2_SHADER_WRITE_BIT, image);
 }
 
 uint32_t
@@ -1695,8 +1697,8 @@ radv_fast_clear_color(struct radv_cmd_buffer *cmd_buffer, const struct radv_imag
    };
 
    if (pre_flush) {
-      enum radv_cmd_flush_bits bits =
-         radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, iview->image);
+      enum radv_cmd_flush_bits bits = radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,
+                                                            VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, iview->image);
       cmd_buffer->state.flush_bits |= bits & ~*pre_flush;
       *pre_flush |= cmd_buffer->state.flush_bits;
    }
diff --git a/src/amd/vulkan/meta/radv_meta_copy.c b/src/amd/vulkan/meta/radv_meta_copy.c
index fddc53e0aaa17..957e45c5c6efc 100644
--- a/src/amd/vulkan/meta/radv_meta_copy.c
+++ b/src/amd/vulkan/meta/radv_meta_copy.c
@@ -233,8 +233,8 @@ radv_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToIm
 
    if (radv_is_format_emulated(pdev, dst_image->vk.format)) {
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_PS_PARTIAL_FLUSH |
-                                      radv_src_access_flush(cmd_buffer, VK_ACCESS_TRANSFER_WRITE_BIT, dst_image) |
-                                      radv_dst_access_flush(cmd_buffer, VK_ACCESS_TRANSFER_READ_BIT, dst_image);
+                                      radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_TRANSFER_WRITE_BIT, dst_image) |
+                                      radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_TRANSFER_READ_BIT, dst_image);
 
       const enum util_format_layout format_layout = vk_format_description(dst_image->vk.format)->layout;
       for (unsigned r = 0; r < pCopyBufferToImageInfo->regionCount; r++) {
@@ -611,8 +611,8 @@ radv_CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyI
 
    if (radv_is_format_emulated(pdev, dst_image->vk.format)) {
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_PS_PARTIAL_FLUSH |
-                                      radv_src_access_flush(cmd_buffer, VK_ACCESS_TRANSFER_WRITE_BIT, dst_image) |
-                                      radv_dst_access_flush(cmd_buffer, VK_ACCESS_TRANSFER_READ_BIT, dst_image);
+                                      radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_TRANSFER_WRITE_BIT, dst_image) |
+                                      radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_TRANSFER_READ_BIT, dst_image);
 
       const enum util_format_layout format_layout = vk_format_description(dst_image->vk.format)->layout;
       for (unsigned r = 0; r < pCopyImageInfo->regionCount; r++) {
diff --git a/src/amd/vulkan/meta/radv_meta_copy_vrs_htile.c b/src/amd/vulkan/meta/radv_meta_copy_vrs_htile.c
index 93ddbc878262d..f5dfa3badcaee 100644
--- a/src/amd/vulkan/meta/radv_meta_copy_vrs_htile.c
+++ b/src/amd/vulkan/meta/radv_meta_copy_vrs_htile.c
@@ -190,8 +190,8 @@ radv_copy_vrs_htile(struct radv_cmd_buffer *cmd_buffer, struct radv_image_view *
    }
 
    cmd_buffer->state.flush_bits |=
-      radv_src_access_flush(cmd_buffer, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, NULL) |
-      radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, NULL);
+      radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, NULL) |
+      radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, NULL);
 
    radv_meta_save(&saved_state, cmd_buffer,
                   RADV_META_SAVE_COMPUTE_PIPELINE | RADV_META_SAVE_CONSTANTS | RADV_META_SAVE_DESCRIPTORS);
@@ -242,6 +242,7 @@ radv_copy_vrs_htile(struct radv_cmd_buffer *cmd_buffer, struct radv_image_view *
 
    radv_meta_restore(&saved_state, cmd_buffer);
 
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
-                                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, NULL);
+   cmd_buffer->state.flush_bits |=
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, NULL);
 }
diff --git a/src/amd/vulkan/meta/radv_meta_dcc_retile.c b/src/amd/vulkan/meta/radv_meta_dcc_retile.c
index 107a983e55624..67db998bad7dc 100644
--- a/src/amd/vulkan/meta/radv_meta_dcc_retile.c
+++ b/src/amd/vulkan/meta/radv_meta_dcc_retile.c
@@ -162,7 +162,7 @@ radv_retile_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image)
 
    struct radv_cmd_state *state = &cmd_buffer->state;
 
-   state->flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, image);
+   state->flush_bits |= radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, image);
 
    unsigned swizzle_mode = image->planes[0].surface.u.gfx9.swizzle_mode;
 
@@ -250,5 +250,6 @@ radv_retile_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image)
    radv_meta_restore(&saved_state, cmd_buffer);
 
    state->flush_bits |=
-      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, image);
 }
diff --git a/src/amd/vulkan/meta/radv_meta_decompress.c b/src/amd/vulkan/meta/radv_meta_decompress.c
index a5b226e6442c2..12407da73ec84 100644
--- a/src/amd/vulkan/meta/radv_meta_decompress.c
+++ b/src/amd/vulkan/meta/radv_meta_decompress.c
@@ -575,8 +575,9 @@ radv_expand_depth_stencil_compute(struct radv_cmd_buffer *cmd_buffer, struct rad
 
    radv_meta_restore(&saved_state, cmd_buffer);
 
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
-                                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+   cmd_buffer->state.flush_bits |=
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, image);
 
    /* Initialize the HTILE metadata as "fully expanded". */
    uint32_t htile_value = radv_get_htile_initial_value(device, image);
diff --git a/src/amd/vulkan/meta/radv_meta_fast_clear.c b/src/amd/vulkan/meta/radv_meta_fast_clear.c
index b83e230af558c..dfd5341df033b 100644
--- a/src/amd/vulkan/meta/radv_meta_fast_clear.c
+++ b/src/amd/vulkan/meta/radv_meta_fast_clear.c
@@ -483,12 +483,14 @@ radv_process_color_image_layer(struct radv_cmd_buffer *cmd_buffer, struct radv_i
    radv_CmdBeginRendering(radv_cmd_buffer_to_handle(cmd_buffer), &rendering_info);
 
    if (flush_cb)
-      cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, image);
+      cmd_buffer->state.flush_bits |=
+         radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, image);
 
    radv_CmdDraw(radv_cmd_buffer_to_handle(cmd_buffer), 3, 1, 0, 0);
 
    if (flush_cb)
-      cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, image);
+      cmd_buffer->state.flush_bits |=
+         radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, image);
 
    radv_CmdEndRendering(radv_cmd_buffer_to_handle(cmd_buffer));
 
@@ -670,7 +672,8 @@ radv_decompress_dcc_compute(struct radv_cmd_buffer *cmd_buffer, struct radv_imag
    struct radv_image_view load_iview = {0};
    struct radv_image_view store_iview = {0};
 
-   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+   cmd_buffer->state.flush_bits |=
+      radv_dst_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, image);
 
    if (!device->meta_state.fast_clear_flush.cmask_eliminate_pipeline) {
       VkResult ret = radv_device_init_meta_fast_clear_flush_state_internal(device);
@@ -765,8 +768,9 @@ radv_decompress_dcc_compute(struct radv_cmd_buffer *cmd_buffer, struct radv_imag
 
    radv_meta_restore(&saved_state, cmd_buffer);
 
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
-                                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+   cmd_buffer->state.flush_bits |=
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, image);
 
    /* Initialize the DCC metadata as "fully expanded". */
    cmd_buffer->state.flush_bits |= radv_init_dcc(cmd_buffer, image, subresourceRange, 0xffffffff);
diff --git a/src/amd/vulkan/meta/radv_meta_fmask_expand.c b/src/amd/vulkan/meta/radv_meta_fmask_expand.c
index dea93422bcffb..83f11e82c5c5a 100644
--- a/src/amd/vulkan/meta/radv_meta_fmask_expand.c
+++ b/src/amd/vulkan/meta/radv_meta_fmask_expand.c
@@ -74,7 +74,7 @@ radv_expand_fmask_image_inplace(struct radv_cmd_buffer *cmd_buffer, struct radv_
 
    radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_COMPUTE, pipeline);
 
-   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, image);
+   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, image);
 
    radv_image_view_init(&iview, device,
                         &(VkImageViewCreateInfo){
@@ -125,7 +125,8 @@ radv_expand_fmask_image_inplace(struct radv_cmd_buffer *cmd_buffer, struct radv_
    radv_meta_restore(&saved_state, cmd_buffer);
 
    cmd_buffer->state.flush_bits |=
-      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, image);
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, image);
 
    /* Re-initialize FMASK in fully expanded mode. */
    cmd_buffer->state.flush_bits |= radv_init_fmask(cmd_buffer, image, subresourceRange);
diff --git a/src/amd/vulkan/meta/radv_meta_resolve.c b/src/amd/vulkan/meta/radv_meta_resolve.c
index 2a36f64f8b174..5c5fc4edeeae6 100644
--- a/src/amd/vulkan/meta/radv_meta_resolve.c
+++ b/src/amd/vulkan/meta/radv_meta_resolve.c
@@ -217,13 +217,14 @@ emit_resolve(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *src_im
    unsigned fs_key = radv_format_meta_fs_key(device, vk_format);
 
    cmd_buffer->state.flush_bits |=
-      radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, src_image) |
-      radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, src_image);
+      radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, src_image) |
+      radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, src_image);
 
    radv_CmdBindPipeline(cmd_buffer_h, VK_PIPELINE_BIND_POINT_GRAPHICS, device->meta_state.resolve.pipeline[fs_key]);
 
    radv_CmdDraw(cmd_buffer_h, 3, 1, 0, 0);
-   cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, dst_image);
+   cmd_buffer->state.flush_bits |=
+      radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, dst_image);
 }
 
 enum radv_resolve_method {
diff --git a/src/amd/vulkan/meta/radv_meta_resolve_cs.c b/src/amd/vulkan/meta/radv_meta_resolve_cs.c
index c46e7ab2c97d6..47885d1966c1e 100644
--- a/src/amd/vulkan/meta/radv_meta_resolve_cs.c
+++ b/src/amd/vulkan/meta/radv_meta_resolve_cs.c
@@ -676,8 +676,9 @@ radv_cmd_buffer_resolve_rendering_cs(struct radv_cmd_buffer *cmd_buffer, struct
    radv_meta_resolve_compute_image(cmd_buffer, src_iview->image, src_iview->vk.format, src_layout, dst_iview->image,
                                    dst_iview->vk.format, dst_layout, region);
 
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
-                                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, NULL);
+   cmd_buffer->state.flush_bits |=
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, NULL);
 }
 
 void
@@ -697,8 +698,8 @@ radv_depth_stencil_resolve_rendering_cs(struct radv_cmd_buffer *cmd_buffer, VkIm
     * we have to make the attachment shader-readable.
     */
    cmd_buffer->state.flush_bits |=
-      radv_src_access_flush(cmd_buffer, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, NULL) |
-      radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, NULL);
+      radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, NULL) |
+      radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, NULL);
 
    struct radv_image_view *src_iview = render->ds_att.iview;
    VkImageLayout src_layout =
@@ -761,8 +762,9 @@ radv_depth_stencil_resolve_rendering_cs(struct radv_cmd_buffer *cmd_buffer, VkIm
                               &(VkExtent3D){resolve_area.extent.width, resolve_area.extent.height, layer_count},
                               aspects, resolve_mode);
 
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
-                                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, NULL);
+   cmd_buffer->state.flush_bits |=
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, NULL);
 
    uint32_t queue_mask = radv_image_queue_family_mask(dst_image, cmd_buffer->qf, cmd_buffer->qf);
 
diff --git a/src/amd/vulkan/meta/radv_meta_resolve_fs.c b/src/amd/vulkan/meta/radv_meta_resolve_fs.c
index 4f506ca9f2afc..7438c6d151006 100644
--- a/src/amd/vulkan/meta/radv_meta_resolve_fs.c
+++ b/src/amd/vulkan/meta/radv_meta_resolve_fs.c
@@ -590,8 +590,9 @@ emit_resolve(struct radv_cmd_buffer *cmd_buffer, struct radv_image_view *src_ivi
                                  });
 
    cmd_buffer->state.flush_bits |=
-      radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, src_iview->image) |
-      radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, dst_iview->image);
+      radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, src_iview->image) |
+      radv_dst_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,
+                            VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, dst_iview->image);
 
    unsigned push_constants[2] = {
       src_offset->x - dst_offset->x,
@@ -605,8 +606,8 @@ emit_resolve(struct radv_cmd_buffer *cmd_buffer, struct radv_image_view *src_ivi
    radv_CmdBindPipeline(cmd_buffer_h, VK_PIPELINE_BIND_POINT_GRAPHICS, *pipeline);
 
    radv_CmdDraw(cmd_buffer_h, 3, 1, 0, 0);
-   cmd_buffer->state.flush_bits |=
-      radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, dst_iview->image);
+   cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,
+                                                         VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, dst_iview->image);
 }
 
 static void
diff --git a/src/amd/vulkan/radv_acceleration_structure.c b/src/amd/vulkan/radv_acceleration_structure.c
index e50c1659c570c..4e91df816489e 100644
--- a/src/amd/vulkan/radv_acceleration_structure.c
+++ b/src/amd/vulkan/radv_acceleration_structure.c
@@ -1352,9 +1352,10 @@ radv_CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t i
       return;
    }
 
-   enum radv_cmd_flush_bits flush_bits = RADV_CMD_FLAG_CS_PARTIAL_FLUSH |
-                                         radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, NULL) |
-                                         radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, NULL);
+   enum radv_cmd_flush_bits flush_bits =
+      RADV_CMD_FLAG_CS_PARTIAL_FLUSH |
+      radv_src_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_WRITE_BIT, NULL) |
+      radv_dst_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT, VK_ACCESS_2_SHADER_READ_BIT, NULL);
 
    radv_meta_save(&saved_state, cmd_buffer,
                   RADV_META_SAVE_COMPUTE_PIPELINE | RADV_META_SAVE_DESCRIPTORS | RADV_META_SAVE_CONSTANTS);
@@ -1511,7 +1512,8 @@ radv_CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopy
                               device->meta_state.accel_struct_build.copy_p_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0,
                               sizeof(consts), &consts);
 
-   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, NULL);
+   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,
+                                                         VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, NULL);
 
    radv_indirect_dispatch(
       cmd_buffer, src_buffer->bo,
@@ -1616,7 +1618,8 @@ radv_CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer,
                               device->meta_state.accel_struct_build.copy_p_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0,
                               sizeof(consts), &consts);
 
-   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, NULL);
+   cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,
+                                                         VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, NULL);
 
    radv_indirect_dispatch(
       cmd_buffer, src_buffer->bo,
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index aa1ebff0e9d68..558915ce9773b 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -28,6 +28,7 @@
 #include "vk_format.h"
 #include "vk_framebuffer.h"
 #include "vk_render_pass.h"
+#include "vk_synchronization.h"
 #include "vk_util.h"
 
 #include "ac_debug.h"
@@ -3930,10 +3931,10 @@ radv_emit_fb_color_state(struct radv_cmd_buffer *cmd_buffer, int index, struct r
       radeon_set_context_reg(cmd_buffer->cs, R_028EC0_CB_COLOR0_INFO + index * 4, cb->ac.cb_color_info);
    } else if (pdev->info.gfx_level >= GFX11) {
       radeon_set_context_reg_seq(cmd_buffer->cs, R_028C6C_CB_COLOR0_VIEW + index * 0x3c, 4);
-      radeon_emit(cmd_buffer->cs, cb->ac.cb_color_view);    /* CB_COLOR0_VIEW */
-      radeon_emit(cmd_buffer->cs, cb->ac.cb_color_info);    /* CB_COLOR0_INFO */
-      radeon_emit(cmd_buffer->cs, cb->ac.cb_color_attrib);  /* CB_COLOR0_ATTRIB */
-      radeon_emit(cmd_buffer->cs, cb_fdcc_control);     /* CB_COLOR0_FDCC_CONTROL */
+      radeon_emit(cmd_buffer->cs, cb->ac.cb_color_view);   /* CB_COLOR0_VIEW */
+      radeon_emit(cmd_buffer->cs, cb->ac.cb_color_info);   /* CB_COLOR0_INFO */
+      radeon_emit(cmd_buffer->cs, cb->ac.cb_color_attrib); /* CB_COLOR0_ATTRIB */
+      radeon_emit(cmd_buffer->cs, cb_fdcc_control);        /* CB_COLOR0_FDCC_CONTROL */
 
       radeon_set_context_reg(cmd_buffer->cs, R_028C60_CB_COLOR0_BASE + index * 0x3c, cb->ac.cb_color_base);
       radeon_set_context_reg(cmd_buffer->cs, R_028E40_CB_COLOR0_BASE_EXT + index * 4,
@@ -4182,16 +4183,16 @@ radv_emit_fb_ds_state(struct radv_cmd_buffer *cmd_buffer, struct radv_ds_buffer_
       radeon_emit(cmd_buffer->cs, ds->ac.db_depth_size);
 
       radeon_set_context_reg_seq(cmd_buffer->cs, R_028038_DB_Z_INFO, 10);
-      radeon_emit(cmd_buffer->cs, db_z_info);                                         /* DB_Z_INFO */
-      radeon_emit(cmd_buffer->cs, ds->ac.db_stencil_info);                            /* DB_STENCIL_INFO */
-      radeon_emit(cmd_buffer->cs, ds->ac.db_depth_base);                              /* DB_Z_READ_BASE */
-      radeon_emit(cmd_buffer->cs, S_028044_BASE_HI(ds->ac.db_depth_base >> 32));      /* DB_Z_READ_BASE_HI */
-      radeon_emit(cmd_buffer->cs, ds->ac.db_stencil_base);                            /* DB_STENCIL_READ_BASE */
-      radeon_emit(cmd_buffer->cs, S_02804C_BASE_HI(ds->ac.db_stencil_base >> 32));    /* DB_STENCIL_READ_BASE_HI */
-      radeon_emit(cmd_buffer->cs, ds->ac.db_depth_base);                              /* DB_Z_WRITE_BASE */
-      radeon_emit(cmd_buffer->cs, S_028054_BASE_HI(ds->ac.db_depth_base >> 32));      /* DB_Z_WRITE_BASE_HI */
-      radeon_emit(cmd_buffer->cs, ds->ac.db_stencil_base);                            /* DB_STENCIL_WRITE_BASE */
-      radeon_emit(cmd_buffer->cs, S_02805C_BASE_HI(ds->ac.db_stencil_base >> 32));    /* DB_STENCIL_WRITE_BASE_HI */
+      radeon_emit(cmd_buffer->cs, db_z_info);                                      /* DB_Z_INFO */
+      radeon_emit(cmd_buffer->cs, ds->ac.db_stencil_info);                         /* DB_STENCIL_INFO */
+      radeon_emit(cmd_buffer->cs, ds->ac.db_depth_base);                           /* DB_Z_READ_BASE */
+      radeon_emit(cmd_buffer->cs, S_028044_BASE_HI(ds->ac.db_depth_base >> 32));   /* DB_Z_READ_BASE_HI */
+      radeon_emit(cmd_buffer->cs, ds->ac.db_stencil_base);                         /* DB_STENCIL_READ_BASE */
+      radeon_emit(cmd_buffer->cs, S_02804C_BASE_HI(ds->ac.db_stencil_base >> 32)); /* DB_STENCIL_READ_BASE_HI */
+      radeon_emit(cmd_buffer->cs, ds->ac.db_depth_base);                           /* DB_Z_WRITE_BASE */
+      radeon_emit(cmd_buffer->cs, S_028054_BASE_HI(ds->ac.db_depth_base >> 32));   /* DB_Z_WRITE_BASE_HI */
+      radeon_emit(cmd_buffer->cs, ds->ac.db_stencil_base);                         /* DB_STENCIL_WRITE_BASE */
+      radeon_emit(cmd_buffer->cs, S_02805C_BASE_HI(ds->ac.db_stencil_base >> 32)); /* DB_STENCIL_WRITE_BASE_HI */
 
       radeon_set_context_reg_seq(cmd_buffer->cs, R_028068_DB_Z_INFO2, 2);
       radeon_emit(cmd_buffer->cs, ds->ac.u.gfx6.db_z_info2);
@@ -7001,8 +7002,11 @@ can_skip_buffer_l2_flushes(struct radv_device *device)
  */
 
 enum radv_cmd_flush_bits
-radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 src_flags, const struct radv_image *image)
+radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2 src_stages, VkAccessFlags2 src_flags,
+                      const struct radv_image *image)
 {
+   src_flags = vk_expand_src_access_flags2(src_stages, src_flags);
+
    bool has_CB_meta = true, has_DB_meta = true;
    bool image_is_coherent = image ? image->l2_coherent : false;
    enum radv_cmd_flush_bits flush_bits = 0;
@@ -7079,7 +7083,8 @@ radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 src_fla
 }
 
 enum radv_cmd_flush_bits
-radv_dst_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 dst_flags, const struct radv_image *image)
+radv_dst_access_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2 dst_stages, VkAccessFlags2 dst_flags,
+                      const struct radv_image *image)
 {
    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
    const struct radv_physical_device *pdev = radv_device_physical(device);
@@ -7089,6 +7094,8 @@ radv_dst_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 dst_fla
    bool image_is_coherent = image ? image->l2_coherent : false;
    bool flush_L2_metadata = false;
 
+   dst_flags = vk_expand_dst_access_flags2(dst_stages, dst_flags);
+
    if (image) {
       if (!(image->vk.usage & VK_IMAGE_USAGE_STORAGE_BIT)) {
          flush_CB = false;
@@ -7216,11 +7223,12 @@ radv_emit_resolve_barrier(struct radv_cmd_buffer *cmd_buffer, const struct radv_
       if (!iview)
          continue;
 
-      cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, barrier->src_access_mask, iview->image);
+      cmd_buffer->state.flush_bits |=
+         radv_src_access_flush(cmd_buffer, barrier->src_stage_mask, barrier->src_access_mask, iview->image);
    }
    if (render->ds_att.iview) {
-      cmd_buffer->state.flush_bits |=
-         radv_src_access_flush(cmd_buffer, barrier->src_access_mask, render->ds_att.iview->image);
+      cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, barrier->src_stage_mask,
+                                                            barrier->src_access_mask, render->ds_att.iview->image);
    }
 
    radv_stage_flush(cmd_buffer, barrier->src_stage_mask);
@@ -7230,11 +7238,12 @@ radv_emit_resolve_barrier(struct radv_cmd_buffer *cmd_buffer, const struct radv_
       if (!iview)
          continue;
 
-      cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dst_access_mask, iview->image);
+      cmd_buffer->state.flush_bits |=
+         radv_dst_access_flush(cmd_buffer, barrier->src_stage_mask, barrier->dst_access_mask, iview->image);
    }
    if (render->ds_att.iview) {
-      cmd_buffer->state.flush_bits |=
-         radv_dst_access_flush(cmd_buffer, barrier->dst_access_mask, render->ds_att.iview->image);
+      cmd_buffer->state.flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dst_stage_mask,
+                                                            barrier->dst_access_mask, render->ds_att.iview->image);
    }
 
    radv_gang_barrier(cmd_buffer, barrier->src_stage_mask, barrier->dst_stage_mask);
@@ -7818,7 +7827,8 @@ radv_EndCommandBuffer(VkCommandBuffer commandBuffer)
        */
       if (cmd_buffer->state.rb_noncoherent_dirty && !can_skip_buffer_l2_flushes(device))
          cmd_buffer->state.flush_bits |= radv_src_access_flush(
-            cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, NULL);
+            cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
+            NULL);
 
       /* Since NGG streamout uses GDS, we need to make GDS idle when
        * we leave the IB, otherwise another process might overwrite
@@ -12145,8 +12155,8 @@ radv_trace_trace_rays(struct radv_cmd_buffer *cmd_buffer, const VkTraceRaysIndir
    util_dynarray_append(&cmd_buffer->ray_history, struct radv_rra_ray_history_data *, data);
 
    cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_INV_SCACHE | RADV_CMD_FLAG_CS_PARTIAL_FLUSH |
-                                   radv_src_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_WRITE_BIT, NULL) |
-                                   radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, NULL);
+                                   radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_WRITE_BIT, NULL) |
+                                   radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, NULL);
 
    radv_update_buffer_cp(cmd_buffer,
                          device->rra_trace.ray_history_addr + offsetof(struct radv_ray_history_header, dispatch_index),
@@ -12392,14 +12402,14 @@ radv_initialize_htile(struct radv_cmd_buffer *cmd_buffer, struct radv_image *ima
 
    /* Transitioning from LAYOUT_UNDEFINED layout not everyone is consistent
     * in considering previous rendering work for WAW hazards. */
-   state->flush_bits |= radv_src_access_flush(cmd_buffer, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, image);
+   state->flush_bits |= radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, image);
 
    if (image->planes[0].surface.has_stencil &&
        !(range->aspectMask == (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) {
       /* Flush caches before performing a separate aspect initialization because it's a
        * read-modify-write operation.
        */
-      state->flush_bits |= radv_dst_access_flush(cmd_buffer, VK_ACCESS_2_SHADER_READ_BIT, image);
+      state->flush_bits |= radv_dst_access_flush(cmd_buffer, -1, VK_ACCESS_2_SHADER_READ_BIT, image);
    }
 
    state->flush_bits |= radv_clear_htile(cmd_buffer, image, range, htile_value);
@@ -12524,7 +12534,7 @@ radv_init_color_image_metadata(struct radv_cmd_buffer *cmd_buffer, struct radv_i
    /* Transitioning from LAYOUT_UNDEFINED layout not everyone is
     * consistent in considering previous rendering work for WAW hazards.
     */
-   cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, image);
+   cmd_buffer->state.flush_bits |= radv_src_access_flush(cmd_buffer, -1, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, image);
 
    if (radv_image_has_cmask(image)) {
       static const uint32_t cmask_clear_values[4] = {0xffffffff, 0xdddddddd, 0xeeeeeeee, 0xffffffff};
@@ -12777,17 +12787,17 @@ radv_barrier(struct radv_cmd_buffer *cmd_buffer, uint32_t dep_count, const VkDep
       for (uint32_t i = 0; i < dep_info->memoryBarrierCount; i++) {
          const VkMemoryBarrier2 *barrier = &dep_info->pMemoryBarriers[i];
          src_stage_mask |= barrier->srcStageMask;
-         src_flush_bits |= radv_src_access_flush(cmd_buffer, barrier->srcAccessMask, NULL);
+         src_flush_bits |= radv_src_access_flush(cmd_buffer, barrier->srcStageMask, barrier->srcAccessMask, NULL);
          dst_stage_mask |= barrier->dstStageMask;
-         dst_flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dstAccessMask, NULL);
+         dst_flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dstStageMask, barrier->dstAccessMask, NULL);
       }
 
       for (uint32_t i = 0; i < dep_info->bufferMemoryBarrierCount; i++) {
          const VkBufferMemoryBarrier2 *barrier = &dep_info->pBufferMemoryBarriers[i];
          src_stage_mask |= barrier->srcStageMask;
-         src_flush_bits |= radv_src_access_flush(cmd_buffer, barrier->srcAccessMask, NULL);
+         src_flush_bits |= radv_src_access_flush(cmd_buffer, barrier->srcStageMask, barrier->srcAccessMask, NULL);
          dst_stage_mask |= barrier->dstStageMask;
-         dst_flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dstAccessMask, NULL);
+         dst_flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dstStageMask, barrier->dstAccessMask, NULL);
       }
 
       for (uint32_t i = 0; i < dep_info->imageMemoryBarrierCount; i++) {
@@ -12795,9 +12805,9 @@ radv_barrier(struct radv_cmd_buffer *cmd_buffer, uint32_t dep_count, const VkDep
          VK_FROM_HANDLE(radv_image, image, barrier->image);
 
          src_stage_mask |= barrier->srcStageMask;
-         src_flush_bits |= radv_src_access_flush(cmd_buffer, barrier->srcAccessMask, image);
+         src_flush_bits |= radv_src_access_flush(cmd_buffer, barrier->srcStageMask, barrier->srcAccessMask, image);
          dst_stage_mask |= barrier->dstStageMask;
-         dst_flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dstAccessMask, image);
+         dst_flush_bits |= radv_dst_access_flush(cmd_buffer, barrier->dstStageMask, barrier->dstAccessMask, image);
       }
    }
 
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index 0f6ee494ad48b..c736fe138b2c8 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -704,11 +704,11 @@ void radv_write_vertex_descriptors(const struct radv_cmd_buffer *cmd_buffer,
                                    const struct radv_graphics_pipeline *pipeline, bool full_null_descriptors,
                                    void *vb_ptr);
 
-enum radv_cmd_flush_bits radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 src_flags,
-                                               const struct radv_image *image);
+enum radv_cmd_flush_bits radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2 src_stages,
+                                               VkAccessFlags2 src_flags, const struct radv_image *image);
 
-enum radv_cmd_flush_bits radv_dst_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 dst_flags,
-                                               const struct radv_image *image);
+enum radv_cmd_flush_bits radv_dst_access_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2 dst_stages,
+                                               VkAccessFlags2 dst_flags, const struct radv_image *image);
 
 struct radv_resolve_barrier {
    VkPipelineStageFlags2 src_stage_mask;
-- 
GitLab


From a319cb929b9c269e619e5a6f37ee1d0defbab6af Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Sat, 4 May 2024 15:39:01 +0200
Subject: [PATCH 4/4] radv: Refactor radv_(dst|src)_access_flush

Removes a bit of dead code (WRITE cases in radv_dst_access_flush) and
shares ray tracing access paths with shader storage paths since they
should be identical.
---
 src/amd/vulkan/radv_cmd_buffer.c | 246 +++++++++++++------------------
 1 file changed, 100 insertions(+), 146 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 558915ce9773b..ffea986ed0661 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7018,67 +7018,54 @@ radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2
          has_DB_meta = false;
    }
 
-   u_foreach_bit64 (b, src_flags) {
-      switch ((VkAccessFlags2)BITFIELD64_BIT(b)) {
-      case VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV:
-         flush_bits |= RADV_CMD_FLAG_INV_L2;
-         break;
-      case VK_ACCESS_2_SHADER_WRITE_BIT:
-      case VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT:
-         /* since the STORAGE bit isn't set we know that this is a meta operation.
-          * on the dst flush side we skip CB/DB flushes without the STORAGE bit, so
-          * set it here. */
-         if (image && !(image->vk.usage & VK_IMAGE_USAGE_STORAGE_BIT)) {
-            if (vk_format_is_depth_or_stencil(image->vk.format)) {
-               flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
-            } else {
-               flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
-            }
+   if (src_flags & VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV)
+      flush_bits |= RADV_CMD_FLAG_INV_L2;
+
+   if (src_flags & (VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT | VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR)) {
+      /* since the STORAGE bit isn't set we know that this is a meta operation.
+       * on the dst flush side we skip CB/DB flushes without the STORAGE bit, so
+       * set it here. */
+      if (image && !(image->vk.usage & VK_IMAGE_USAGE_STORAGE_BIT)) {
+         if (vk_format_is_depth_or_stencil(image->vk.format)) {
+            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
+         } else {
+            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
          }
+      }
 
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_INV_L2;
-         break;
-      case VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR:
-      case VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT:
-      case VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT:
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_WB_L2;
-         break;
-      case VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT:
-         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
-         if (has_CB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-         break;
-      case VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT:
-         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
-         if (has_DB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
-         break;
-      case VK_ACCESS_2_TRANSFER_WRITE_BIT:
-         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_DB;
+      if (!image_is_coherent)
+         flush_bits |= RADV_CMD_FLAG_INV_L2;
+   }
 
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_INV_L2;
-         if (has_CB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-         if (has_DB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
-         break;
-      case VK_ACCESS_2_MEMORY_WRITE_BIT:
-         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_DB;
+   if (src_flags &
+       (VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT | VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT)) {
+      if (!image_is_coherent)
+         flush_bits |= RADV_CMD_FLAG_WB_L2;
+   }
 
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_INV_L2;
-         if (has_CB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-         if (has_DB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
-         break;
-      default:
-         break;
-      }
+   if (src_flags & VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT) {
+      flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
+      if (has_CB_meta)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
    }
+
+   if (src_flags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT) {
+      flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
+      if (has_DB_meta)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
+   }
+
+   if (src_flags & VK_ACCESS_2_TRANSFER_WRITE_BIT) {
+      flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB | RADV_CMD_FLAG_FLUSH_AND_INV_DB;
+
+      if (!image_is_coherent)
+         flush_bits |= RADV_CMD_FLAG_INV_L2;
+      if (has_CB_meta)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
+      if (has_DB_meta)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
+   }
+
    return flush_bits;
 }
 
@@ -7114,102 +7101,69 @@ radv_dst_access_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2
     * in the L2 cache in CB/DB mode then they are already usable from all the other L2 clients. */
    image_is_coherent |= can_skip_buffer_l2_flushes(device) && !cmd_buffer->state.rb_noncoherent_dirty;
 
-   u_foreach_bit64 (b, dst_flags) {
-      switch ((VkAccessFlags2)BITFIELD64_BIT(b)) {
-      case VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT:
-         /* SMEM loads are used to read compute dispatch size in shaders */
-         if (!device->load_grid_size_from_user_sgpr)
-            flush_bits |= RADV_CMD_FLAG_INV_SCACHE;
-
-         /* Ensure the DGC meta shader can read the commands. */
-         if (radv_uses_device_generated_commands(device)) {
-            flush_bits |= RADV_CMD_FLAG_INV_SCACHE | RADV_CMD_FLAG_INV_VCACHE;
+   if (dst_flags & VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT) {
+      /* SMEM loads are used to read compute dispatch size in shaders */
+      if (!device->load_grid_size_from_user_sgpr)
+         flush_bits |= RADV_CMD_FLAG_INV_SCACHE;
 
-            if (pdev->info.gfx_level < GFX9)
-               flush_bits |= RADV_CMD_FLAG_INV_L2;
-         }
+      /* Ensure the DGC meta shader can read the commands. */
+      if (radv_uses_device_generated_commands(device)) {
+         flush_bits |= RADV_CMD_FLAG_INV_SCACHE | RADV_CMD_FLAG_INV_VCACHE;
 
-         break;
-      case VK_ACCESS_2_INDEX_READ_BIT:
-      case VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT:
-         break;
-      case VK_ACCESS_2_UNIFORM_READ_BIT:
-         flush_bits |= RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_SCACHE;
-         break;
-      case VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT:
-      case VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT:
-      case VK_ACCESS_2_TRANSFER_READ_BIT:
-      case VK_ACCESS_2_TRANSFER_WRITE_BIT:
-         flush_bits |= RADV_CMD_FLAG_INV_VCACHE;
-
-         if (flush_L2_metadata)
-            flush_bits |= RADV_CMD_FLAG_INV_L2_METADATA;
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_INV_L2;
-         break;
-      case VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT:
-         flush_bits |= RADV_CMD_FLAG_INV_SCACHE;
-         break;
-      case VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR:
-      case VK_ACCESS_2_SHADER_READ_BIT:
-      case VK_ACCESS_2_SHADER_STORAGE_READ_BIT:
-         /* Unlike LLVM, ACO uses SMEM for SSBOs and we have to
-          * invalidate the scalar cache. */
-         if (!pdev->use_llvm && !image)
-            flush_bits |= RADV_CMD_FLAG_INV_SCACHE;
-         FALLTHROUGH;
-      case VK_ACCESS_2_SHADER_SAMPLED_READ_BIT:
-         flush_bits |= RADV_CMD_FLAG_INV_VCACHE;
-         if (flush_L2_metadata)
-            flush_bits |= RADV_CMD_FLAG_INV_L2_METADATA;
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_INV_L2;
-         break;
-      case VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV:
-      case VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR:
-         flush_bits |= RADV_CMD_FLAG_INV_VCACHE;
          if (pdev->info.gfx_level < GFX9)
             flush_bits |= RADV_CMD_FLAG_INV_L2;
-         break;
-      case VK_ACCESS_2_SHADER_WRITE_BIT:
-      case VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT:
-      case VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR:
-         break;
-      case VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT:
-      case VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT:
-         if (flush_CB)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
-         if (has_CB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-         break;
-      case VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT:
-      case VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT:
-         if (flush_DB)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
-         if (has_DB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
-         break;
-      case VK_ACCESS_2_MEMORY_READ_BIT:
-         if (flush_L2_metadata)
-            flush_bits |= RADV_CMD_FLAG_INV_L2_METADATA;
-         FALLTHROUGH;
-      case VK_ACCESS_2_MEMORY_WRITE_BIT:
-         flush_bits |= RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_SCACHE;
-         if (!image_is_coherent)
-            flush_bits |= RADV_CMD_FLAG_INV_L2;
-         if (flush_CB)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
-         if (has_CB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META;
-         if (flush_DB)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
-         if (has_DB_meta)
-            flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META;
-         break;
-      default:
-         break;
       }
    }
+
+   if (dst_flags & VK_ACCESS_2_UNIFORM_READ_BIT)
+      flush_bits |= RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_SCACHE;
+
+   if (dst_flags & (VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT | VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
+                    VK_ACCESS_2_TRANSFER_READ_BIT)) {
+      flush_bits |= RADV_CMD_FLAG_INV_VCACHE;
+
+      if (flush_L2_metadata)
+         flush_bits |= RADV_CMD_FLAG_INV_L2_METADATA;
+      if (!image_is_coherent)
+         flush_bits |= RADV_CMD_FLAG_INV_L2;
+   }
+
+   if (dst_flags & VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT)
+      flush_bits |= RADV_CMD_FLAG_INV_SCACHE;
+
+   if (dst_flags & (VK_ACCESS_2_SHADER_STORAGE_READ_BIT | VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR |
+                    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR | VK_ACCESS_2_SHADER_SAMPLED_READ_BIT)) {
+      flush_bits |= RADV_CMD_FLAG_INV_VCACHE;
+      /* Unlike LLVM, ACO uses SMEM for SSBOs and we have to
+       * invalidate the scalar cache. */
+      if (!pdev->use_llvm && !image)
+         flush_bits |= RADV_CMD_FLAG_INV_SCACHE;
+      if (flush_L2_metadata)
+         flush_bits |= RADV_CMD_FLAG_INV_L2_METADATA;
+      if (!image_is_coherent)
+         flush_bits |= RADV_CMD_FLAG_INV_L2;
+   }
+
+   if (dst_flags & VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV) {
+      flush_bits |= RADV_CMD_FLAG_INV_VCACHE;
+      if (pdev->info.gfx_level < GFX9)
+         flush_bits |= RADV_CMD_FLAG_INV_L2;
+   }
+
+   if (dst_flags & VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT) {
+      if (flush_CB)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB;
+      if (has_CB_meta)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_CB_META | RADV_CMD_FLAG_INV_L2_METADATA;
+   }
+
+   if (dst_flags & VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT) {
+      if (flush_DB)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB;
+      if (has_DB_meta)
+         flush_bits |= RADV_CMD_FLAG_FLUSH_AND_INV_DB_META | RADV_CMD_FLAG_INV_L2_METADATA;
+   }
+
    return flush_bits;
 }
 
-- 
GitLab

