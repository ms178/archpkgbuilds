From 2782c513db1c47c85cd6db3d5259fb432d4fb367 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 11 Oct 2023 14:41:49 +0200
Subject: [PATCH 1/2] radv: only initialize DB_{z,stencil}_{read/write}_BASE
 when needed

Otherwise, the hw seems confused if for example, only the depth aspect
of a depth/stencil image is copied, although the depth format is
INVALID. This prevents regressions in the next commit.

This matches PAL.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 4fdfa2f258266..b28e5c8a7ff9a 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1827,6 +1827,7 @@ radv_initialise_ds_surface_va(const struct radv_device *device, struct radv_ds_b
    uint64_t va, s_offs, z_offs;
    const struct radv_image_plane *plane = &iview->image->planes[0];
    const struct radeon_surf *surf = &plane->surface;
+   unsigned format, stencil_format;
 
    assert(vk_format_get_plane_count(iview->image->vk.format) == 1);
 
@@ -1845,8 +1846,14 @@ radv_initialise_ds_surface_va(const struct radv_device *device, struct radv_ds_b
       ds->db_htile_data_base = va >> 8;
    }
 
-   ds->db_z_read_base = ds->db_z_write_base = z_offs >> 8;
-   ds->db_stencil_read_base = ds->db_stencil_write_base = s_offs >> 8;
+   format = radv_translate_dbformat(iview->image->vk.format);
+   stencil_format = surf->has_stencil ? V_028044_STENCIL_8 : V_028044_STENCIL_INVALID;
+
+   if (format != V_028040_Z_INVALID)
+      ds->db_z_read_base = ds->db_z_write_base = z_offs >> 8;
+
+   if (stencil_format != V_028044_STENCIL_INVALID)
+      ds->db_stencil_read_base = ds->db_stencil_write_base = s_offs >> 8;
 }
 
 void
-- 
GitLab


From b8811ba8edbd03567d2e4b8abd784fbd4cd12f9d Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 22 Sep 2023 16:25:26 +0200
Subject: [PATCH 2/2] radv: fix binding partial depth/stencil views with
 dynamic rendering

With dynamic rendering, it's allowed to begin rendering with depth or
stencil only but still with a depth/stencil format. The test below
checks that unbound part of ds isn't modified, if depth is bound and
stencil not and vice versa.

This moves the ds surface initialization back to begin rendering
because otherwise it would be too messy.

This fixes a recent CTS
dEQP-VK.dynamic_rendering.primary_cmd_buff.basic.partial_binding_depth_stencil,
except on GFX9 due to the mentioned hw bug which is hard to workaround.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 22 +++++++++--
 src/amd/vulkan/radv_device.c     | 68 ++++++++++++--------------------
 src/amd/vulkan/radv_image.c      |  4 +-
 src/amd/vulkan/radv_private.h    |  9 +----
 4 files changed, 47 insertions(+), 56 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 471aa6a717307..6cd5cb11e2de8 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7735,10 +7735,24 @@ radv_CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRe
       }
 
       assert(d_iview == NULL || s_iview == NULL || d_iview == s_iview);
-      ds_att.iview = d_iview ? d_iview : s_iview, ds_att.format = ds_att.iview->vk.format;
-      if (!ds_att.iview->ds.db_z_read_base && !ds_att.iview->ds.db_stencil_read_base)
-         radv_initialise_ds_surface_va(cmd_buffer->device, &ds_att.iview->ds, ds_att.iview);
-      ds_att.ds = ds_att.iview->ds;
+      ds_att.iview = d_iview ? d_iview : s_iview;
+
+      if (d_iview && s_iview) {
+         ds_att.format = ds_att.iview->vk.format;
+      } else if (d_iview) {
+         ds_att.format = vk_format_depth_only(ds_att.iview->vk.format);
+      } else {
+         ds_att.format = vk_format_stencil_only(ds_att.iview->vk.format);
+
+         /* FIXME: GFX9 seems to be affected by a hw bug where compression for a depth/stencil image
+          * should be disabled for a stencil-only view (see waDisableSCompressOnly in PAL).
+          */
+         if (cmd_buffer->device->physical_device->rad_info.gfx_level == GFX9) {
+            ds_att.format = ds_att.iview->vk.format;
+         }
+      }
+
+      radv_initialise_ds_surface(cmd_buffer->device, &ds_att.ds, ds_att.iview, ds_att.format);
 
       assert(d_res_iview == NULL || s_res_iview == NULL || d_res_iview == s_res_iview);
       ds_att.resolve_iview = d_res_iview ? d_res_iview : s_res_iview;
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index b28e5c8a7ff9a..33f34a53a6267 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1819,59 +1819,24 @@ radv_initialise_vrs_surface(struct radv_image *image, struct radv_buffer *htile_
       S_028ABC_FULL_CACHE(1) | S_028ABC_PIPE_ALIGNED(1) | S_028ABC_VRS_HTILE_ENCODING(V_028ABC_VRS_HTILE_4BIT_ENCODING);
 }
 
-void
-radv_initialise_ds_surface_va(const struct radv_device *device, struct radv_ds_buffer_info *ds,
-                              struct radv_image_view *iview)
-{
-   unsigned level = iview->vk.base_mip_level;
-   uint64_t va, s_offs, z_offs;
-   const struct radv_image_plane *plane = &iview->image->planes[0];
-   const struct radeon_surf *surf = &plane->surface;
-   unsigned format, stencil_format;
-
-   assert(vk_format_get_plane_count(iview->image->vk.format) == 1);
-
-   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
-   s_offs = z_offs = va;
-
-   if (device->physical_device->rad_info.gfx_level >= GFX9) {
-      assert(surf->u.gfx9.surf_offset == 0);
-      s_offs += surf->u.gfx9.zs.stencil_offset;
-   } else {
-      z_offs += (uint64_t)surf->u.legacy.level[level].offset_256B * 256;
-      s_offs += (uint64_t)surf->u.legacy.zs.stencil_level[level].offset_256B * 256;
-   }
-   if (radv_htile_enabled(iview->image, level)) {
-      va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset + surf->meta_offset;
-      ds->db_htile_data_base = va >> 8;
-   }
-
-   format = radv_translate_dbformat(iview->image->vk.format);
-   stencil_format = surf->has_stencil ? V_028044_STENCIL_8 : V_028044_STENCIL_INVALID;
-
-   if (format != V_028040_Z_INVALID)
-      ds->db_z_read_base = ds->db_z_write_base = z_offs >> 8;
-
-   if (stencil_format != V_028044_STENCIL_INVALID)
-      ds->db_stencil_read_base = ds->db_stencil_write_base = s_offs >> 8;
-}
-
 void
 radv_initialise_ds_surface(const struct radv_device *device, struct radv_ds_buffer_info *ds,
-                           struct radv_image_view *iview)
+                           struct radv_image_view *iview, VkFormat ds_format)
 {
    unsigned level = iview->vk.base_mip_level;
    unsigned format, stencil_format;
-   bool stencil_only = iview->image->vk.format == VK_FORMAT_S8_UINT;
+   bool stencil_only = ds_format == VK_FORMAT_S8_UINT;
    const struct radv_image_plane *plane = &iview->image->planes[0];
    const struct radeon_surf *surf = &plane->surface;
+   uint64_t va, s_offs, z_offs;
 
-   assert(vk_format_get_plane_count(iview->image->vk.format) == 1);
+   assert(vk_format_get_plane_count(ds_format) == 1);
 
    memset(ds, 0, sizeof(*ds));
 
-   format = radv_translate_dbformat(iview->image->vk.format);
-   stencil_format = surf->has_stencil ? V_028044_STENCIL_8 : V_028044_STENCIL_INVALID;
+   format = radv_translate_dbformat(ds_format);
+   stencil_format =
+      vk_format_has_stencil(ds_format) && surf->has_stencil ? V_028044_STENCIL_8 : V_028044_STENCIL_INVALID;
 
    uint32_t max_slice = radv_surface_max_layer_count(iview) - 1;
    ds->db_depth_view = S_028008_SLICE_START(iview->vk.base_array_layer) | S_028008_SLICE_MAX(max_slice);
@@ -1887,6 +1852,9 @@ radv_initialise_ds_surface(const struct radv_device *device, struct radv_ds_buff
    ds->db_render_override2 = S_028010_DECOMPRESS_Z_ON_FLUSH(iview->image->vk.samples >= 4) |
                              S_028010_CENTROID_COMPUTATION_MODE(device->physical_device->rad_info.gfx_level >= GFX10_3);
 
+   va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset;
+   s_offs = z_offs = va;
+
    if (device->physical_device->rad_info.gfx_level >= GFX9) {
       assert(surf->u.gfx9.surf_offset == 0);
 
@@ -1945,6 +1913,8 @@ radv_initialise_ds_surface(const struct radv_device *device, struct radv_ds_buff
       if (device->physical_device->rad_info.gfx_level >= GFX11) {
          radv_gfx11_set_db_render_control(device, iview->image->vk.samples, &ds->db_render_control);
       }
+
+      s_offs += surf->u.gfx9.zs.stencil_offset;
    } else {
       const struct legacy_surf_level *level_info = &surf->u.legacy.level[level];
 
@@ -2007,7 +1977,21 @@ radv_initialise_ds_surface(const struct radv_device *device, struct radv_ds_buff
             ds->db_z_info |= S_028040_DECOMPRESS_ON_N_ZPLANES(max_zplanes);
          }
       }
+
+      z_offs += (uint64_t)surf->u.legacy.level[level].offset_256B * 256;
+      s_offs += (uint64_t)surf->u.legacy.zs.stencil_level[level].offset_256B * 256;
+   }
+
+   if (radv_htile_enabled(iview->image, level)) {
+      va = radv_buffer_get_va(iview->image->bindings[0].bo) + iview->image->bindings[0].offset + surf->meta_offset;
+      ds->db_htile_data_base = va >> 8;
    }
+
+   if (format != V_028040_Z_INVALID)
+      ds->db_z_read_base = ds->db_z_write_base = z_offs >> 8;
+
+   if (stencil_format != V_028044_STENCIL_INVALID)
+      ds->db_stencil_read_base = ds->db_stencil_write_base = s_offs >> 8;
 }
 
 void
diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 5a45d09e32076..b5551d5c9d2dc 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -2272,9 +2272,7 @@ radv_image_view_init(struct radv_image_view *iview, struct radv_device *device,
                                       &iview->nbc_view, sliced_3d);
    }
 
-   if (iview->vk.aspects & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)) {
-      radv_initialise_ds_surface(device, &iview->ds, iview);
-   } else {
+   if (!(iview->vk.aspects & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) {
       bool blendable = false;
       if (radv_is_colorbuffer_format_supported(device->physical_device, iview->vk.format, &blendable))
          radv_initialise_color_surface(device, &iview->cb, iview);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index c06078275f828..6a4cbcc2f162a 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1517,10 +1517,8 @@ void radv_initialise_color_surface_va(struct radv_device *device, struct radv_co
                                       struct radv_image_view *iview);
 void radv_initialise_color_surface(struct radv_device *device, struct radv_color_buffer_info *cb,
                                    struct radv_image_view *iview);
-void radv_initialise_ds_surface_va(const struct radv_device *device, struct radv_ds_buffer_info *ds,
-                                   struct radv_image_view *iview);
 void radv_initialise_ds_surface(const struct radv_device *device, struct radv_ds_buffer_info *ds,
-                                struct radv_image_view *iview);
+                                struct radv_image_view *iview, VkFormat ds_format);
 void radv_initialise_vrs_surface(struct radv_image *image, struct radv_buffer *htile_buffer,
                                  struct radv_ds_buffer_info *ds);
 
@@ -2908,10 +2906,7 @@ struct radv_image_view {
    /* Block-compressed image views on GFX10+. */
    struct ac_surf_nbc_view nbc_view;
 
-   union {
-      struct radv_color_buffer_info cb;
-      struct radv_ds_buffer_info ds;
-   };
+   struct radv_color_buffer_info cb;
 };
 
 struct radv_image_create_info {
-- 
GitLab

