From 0d9bcf5841cced4f7f60638e32d043fcaa828c90 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 1 Sep 2023 16:44:07 +0800
Subject: [PATCH 01/21] aco: do not fix_exports when separately compiled ngg vs
 or es

For radeonsi not abort when this case, as it does not jump at
last.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp             | 14 ++++++--------
 src/amd/compiler/aco_instruction_selection.cpp |  1 -
 2 files changed, 6 insertions(+), 9 deletions(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index f552618acc7f..49508e961379 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -1008,13 +1008,6 @@ fix_exports(asm_context& ctx, std::vector<uint32_t>& out, Program* program)
             }
          } else if ((*it)->definitions.size() && (*it)->definitions[0].physReg() == exec) {
             break;
-         } else if ((*it)->opcode == aco_opcode::s_setpc_b64) {
-            /* Do not abort for VS/TES as NGG if they are non-monolithic shaders
-             * because a jump would be emitted.
-             */
-            exported |= (program->stage.sw == SWStage::VS || program->stage.sw == SWStage::TES) &&
-                        program->stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER &&
-                        program->info.merged_shader_compiled_separately;
          }
          ++it;
       }
@@ -1293,8 +1286,13 @@ emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct a
 {
    asm_context ctx(program, symbols);
 
+   bool is_separately_compiled_ngg_vs_or_es =
+      (program->stage.sw == SWStage::VS || program->stage.sw == SWStage::TES) &&
+      program->stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER &&
+      program->info.merged_shader_compiled_separately;
+
    /* Prolog has no exports. */
-   if (!program->is_prolog && !program->info.has_epilog &&
+   if (!program->is_prolog && !program->info.has_epilog && !is_separately_compiled_ngg_vs_or_es &&
        (program->stage.hw == AC_HW_VERTEX_SHADER || program->stage.hw == AC_HW_PIXEL_SHADER ||
         program->stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER))
       fix_exports(ctx, code, program);
diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 22fc17f71c33..632326a5b6e9 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11774,7 +11774,6 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
        (ctx.stage.sw == SWStage::VS || ctx.stage.sw == SWStage::TES)) {
       assert(program->gfx_level >= GFX9);
       create_merged_jump_to_epilog(&ctx);
-      ctx.block->kind |= block_kind_export_end;
    }
 
    cleanup_context(&ctx);
-- 
GitLab


From d81e09ec37dd23019f7f5e63996f822ce2fb4872 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 29 Aug 2023 19:29:02 +0800
Subject: [PATCH 02/21] aco: stop emit s_endpgm for first stage of merged
 shader

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 632326a5b6e9..626f13abd7d0 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12211,6 +12211,8 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
    if (ctx.stage == raytracing_cs)
       return select_program_rt(ctx, shader_count, shaders, args);
 
+   bool is_first_stage_of_merged_shader = false;
+
    if (shader_count >= 2) {
       select_program_merged(ctx, shader_count, shaders);
    } else {
@@ -12222,6 +12224,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
          assert(ctx.program->gfx_level >= GFX9);
          if (ctx.stage.sw == SWStage::VS || ctx.stage.sw == SWStage::TES) {
             check_merged_wave_info = endif_merged_wave_info = true;
+            is_first_stage_of_merged_shader = true;
          } else {
             const bool ngg_gs =
                ctx.stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER && ctx.stage.sw == SWStage::GS;
@@ -12240,7 +12243,7 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
    append_logical_end(ctx.block);
    ctx.block->kind |= block_kind_uniform;
 
-   if (!ctx.program->info.has_epilog ||
+   if ((!ctx.program->info.has_epilog && !is_first_stage_of_merged_shader) ||
        (shaders[shader_count - 1]->info.stage == MESA_SHADER_TESS_CTRL &&
         options->gfx_level >= GFX9)) {
       Builder bld(ctx.program, ctx.block);
-- 
GitLab


From fda8f2b2a7ff9959286d82835cdc6d471294e984 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 30 Aug 2023 10:03:11 +0800
Subject: [PATCH 03/21] aco: stop manually init exec for vs with prolog

It's done by vs prolog already.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_insert_exec_mask.cpp | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index d20bc29b120d..4eb931206b89 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -193,13 +193,14 @@ add_coupling_code(exec_ctx& ctx, Block* block, std::vector<aco_ptr<Instruction>>
       Operand start_exec(bld.lm);
 
       /* exec seems to need to be manually initialized with combined shaders */
-      if (ctx.program->stage.num_sw_stages() > 1 ||
-          ctx.program->stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER ||
-          (ctx.program->stage.sw == SWStage::VS &&
-           (ctx.program->stage.hw == AC_HW_HULL_SHADER ||
-            ctx.program->stage.hw == AC_HW_LEGACY_GEOMETRY_SHADER)) ||
-          (ctx.program->stage.sw == SWStage::TES &&
-           ctx.program->stage.hw == AC_HW_LEGACY_GEOMETRY_SHADER)) {
+      if (!ctx.program->info.vs.has_prolog &&
+          (ctx.program->stage.num_sw_stages() > 1 ||
+           ctx.program->stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER ||
+           (ctx.program->stage.sw == SWStage::VS &&
+            (ctx.program->stage.hw == AC_HW_HULL_SHADER ||
+             ctx.program->stage.hw == AC_HW_LEGACY_GEOMETRY_SHADER)) ||
+           (ctx.program->stage.sw == SWStage::TES &&
+            ctx.program->stage.hw == AC_HW_LEGACY_GEOMETRY_SHADER))) {
          start_exec = Operand::c32_or_c64(-1u, bld.lm == s2);
          bld.copy(Definition(exec, bld.lm), start_exec);
       }
-- 
GitLab


From 2e67e76dddc0b99443f2739886873a440c01ad44 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 29 Aug 2023 14:21:08 +0800
Subject: [PATCH 04/21] aco: add create_end_for_merged_shader

For radeonsi merged shader LS/ES part to pass args to next
stage.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 29 ++++++++++++++++++-
 1 file changed, 28 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 626f13abd7d0..585b62f2e8b3 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11692,6 +11692,30 @@ create_merged_jump_to_epilog(isel_context* ctx)
    ctx->block->instructions.emplace_back(std::move(jump));
 }
 
+static void
+create_end_for_merged_shader(isel_context* ctx)
+{
+   std::vector<Operand> regs;
+
+   unsigned max_args;
+   if (ctx->stage.sw == SWStage::VS) {
+      assert(ctx->args->vertex_id.used);
+      max_args = ctx->args->vertex_id.arg_index;
+   } else {
+      assert(ctx->stage.sw == SWStage::TES);
+      assert(ctx->args->tes_u.used);
+      max_args = ctx->args->tes_u.arg_index;
+   }
+
+   struct ac_arg arg;
+   arg.used = true;
+
+   for (arg.arg_index = 0; arg.arg_index < max_args; arg.arg_index++)
+      regs.emplace_back(get_arg_for_end(ctx, arg));
+
+   build_end_with_regs(ctx, regs);
+}
+
 void
 select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, const bool need_barrier,
               if_context* ic_merged_wave_info, const bool check_merged_wave_info,
@@ -11773,7 +11797,10 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
    if (ctx.program->info.merged_shader_compiled_separately &&
        (ctx.stage.sw == SWStage::VS || ctx.stage.sw == SWStage::TES)) {
       assert(program->gfx_level >= GFX9);
-      create_merged_jump_to_epilog(&ctx);
+      if (ctx.options->is_opengl)
+         create_end_for_merged_shader(&ctx);
+      else
+         create_merged_jump_to_epilog(&ctx);
    }
 
    cleanup_context(&ctx);
-- 
GitLab


From 4a7d6b76813728d8439dbea2067e4386cfecc094 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 10 Sep 2023 16:46:14 +0800
Subject: [PATCH 05/21] aco: extend max operands in a instruction to 128

We get more than 64 operands in p_end_with_regs when radeonsi.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_register_allocation.cpp | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index 1acd899e6c56..9251f56ddb15 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -24,6 +24,7 @@
 
 #include "aco_ir.h"
 
+#include "util/bitset.h"
 #include "util/enum_operators.h"
 
 #include <algorithm>
@@ -1971,11 +1972,12 @@ handle_fixed_operands(ra_ctx& ctx, RegisterFile& register_file,
                       std::vector<std::pair<Operand, Definition>>& parallelcopy,
                       aco_ptr<Instruction>& instr)
 {
-   assert(instr->operands.size() <= 64);
+   assert(instr->operands.size() <= 128);
 
    RegisterFile tmp_file(register_file);
 
-   uint64_t mask = 0;
+   BITSET_DECLARE(mask, 128) = {0};
+
    for (unsigned i = 0; i < instr->operands.size(); i++) {
       Operand& op = instr->operands[i];
 
@@ -1990,8 +1992,9 @@ handle_fixed_operands(ra_ctx& ctx, RegisterFile& register_file,
          continue;
       }
 
+      unsigned j;
       bool found = false;
-      u_foreach_bit64 (j, mask) {
+      BITSET_FOREACH_SET (j, mask, i) {
          if (instr->operands[j].tempId() == op.tempId() &&
              instr->operands[j].physReg() == op.physReg()) {
             found = true;
@@ -2004,18 +2007,19 @@ handle_fixed_operands(ra_ctx& ctx, RegisterFile& register_file,
       /* clear from register_file so fixed operands are not collected be collect_vars() */
       tmp_file.clear(src, op.regClass()); // TODO: try to avoid moving block vars to src
 
-      mask |= (uint64_t)1 << i;
+      BITSET_SET(mask, i);
 
       Operand pc_op(instr->operands[i].getTemp(), src);
       Definition pc_def = Definition(op.physReg(), pc_op.regClass());
       parallelcopy.emplace_back(pc_op, pc_def);
    }
 
-   if (!mask)
+   if (BITSET_IS_EMPTY(mask))
       return;
 
+   unsigned i;
    std::vector<unsigned> blocking_vars;
-   u_foreach_bit64 (i, mask) {
+   BITSET_FOREACH_SET (i, mask, instr->operands.size()) {
       Operand& op = instr->operands[i];
       PhysRegInterval target{op.physReg(), op.size()};
       std::vector<unsigned> blocking_vars2 = collect_vars(ctx, tmp_file, target);
-- 
GitLab

From 29560a88561cf790146bf75ee3cc39c9aceee10f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 29 Aug 2023 15:41:38 +0800
Subject: [PATCH 07/21] radeonsi: add vs prolog args needed by aco ls vgpr fix

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 65cd51325fa7..aaca2c4c1ea2 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -3647,8 +3647,15 @@ void si_get_vs_prolog_args(enum amd_gfx_level gfx_level,
    args->ac.vertex_id = input_vgprs[vertex_id_vgpr];
    args->ac.instance_id = input_vgprs[instance_id_vgpr];
 
-   if (key->vs_prolog.as_ls && gfx_level < GFX11)
-      args->ac.vs_rel_patch_id = input_vgprs[first_vs_vgpr + 1];
+   if (key->vs_prolog.as_ls) {
+      if (gfx_level < GFX11)
+         args->ac.vs_rel_patch_id = input_vgprs[first_vs_vgpr + 1];
+
+      if (gfx_level >= GFX9) {
+         args->ac.tcs_patch_id = input_vgprs[0];
+         args->ac.tcs_rel_ids = input_vgprs[1];
+      }
+   }
 
    unsigned user_sgpr_base = key->vs_prolog.num_merged_next_stage_vgprs ? 8 : 0;
    args->internal_bindings = input_sgprs[user_sgpr_base + SI_SGPR_INTERNAL_BINDINGS];
-- 
GitLab


From b2e769678025999c62435d6189d980a8dee033d4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 1 Sep 2023 16:52:18 +0800
Subject: [PATCH 08/21] radeonsi: fill aco shader info for part mode merged
 shader

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_aco.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 179191e09050..4dee0284fbc7 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -73,6 +73,9 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info,
    if (!info->workgroup_size)
       info->workgroup_size = info->wave_size;
 
+   info->merged_shader_compiled_separately = !shader->is_gs_copy_shader &&
+      si_is_multi_part_shader(shader) && !shader->is_monolithic;
+
    info->image_2d_view_of_3d = gfx_level == GFX9;
    info->hw_stage = si_select_hw_stage(stage, key, gfx_level);
 
-- 
GitLab


From dc4cae8d987f9d443f593f19666baebeed6effee Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 29 Aug 2023 14:28:50 +0800
Subject: [PATCH 09/21] radeonsi: enable aco compilation for merged shader
 parts

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 30 +-----------------------
 1 file changed, 1 insertion(+), 29 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index aaca2c4c1ea2..5d6e746455ed 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2443,22 +2443,7 @@ static void si_determine_use_aco(struct si_shader *shader)
    if (!sel->screen->info.has_graphics)
       return;
 
-   switch (sel->stage) {
-   case MESA_SHADER_VERTEX:
-   case MESA_SHADER_TESS_CTRL:
-   case MESA_SHADER_TESS_EVAL:
-   case MESA_SHADER_GEOMETRY:
-      shader->use_aco =
-         !si_is_multi_part_shader(shader) || shader->is_monolithic ||
-         shader->is_gs_copy_shader;
-      break;
-   case MESA_SHADER_FRAGMENT:
-   case MESA_SHADER_COMPUTE:
-      shader->use_aco = true;
-      break;
-   default:
-      break;
-   }
+   shader->use_aco = true;
 }
 
 /* Generate code for the hardware VS shader stage to go with a geometry shader */
@@ -2961,19 +2946,6 @@ si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
    result->key = *key;
 
    bool use_aco = (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics;
-   if (use_aco) {
-      switch (stage) {
-      case MESA_SHADER_VERTEX:
-         use_aco = sscreen->info.gfx_level <= GFX8 ||
-            !(key->vs_prolog.as_ls || key->vs_prolog.as_es);
-         break;
-      case MESA_SHADER_TESS_CTRL:
-         use_aco = sscreen->info.gfx_level <= GFX8;
-         break;
-      default:
-         break;
-      }
-   }
 
    bool ok = use_aco ?
       si_aco_build_shader_part(sscreen, stage, prolog, debug, name, result) :
-- 
GitLab


From 36fdfec3ad1827f5798db0f2fdebc9281e0f3d47 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 30 Aug 2023 10:53:55 +0800
Subject: [PATCH 10/21] radeonsi: move use_aco to si_screen

It's not per shader any more.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../drivers/radeonsi/si_nir_lower_abi.c       |  4 +-
 src/gallium/drivers/radeonsi/si_pipe.c        |  3 +
 src/gallium/drivers/radeonsi/si_pipe.h        |  1 +
 src/gallium/drivers/radeonsi/si_shader.c      | 55 ++++++-------------
 src/gallium/drivers/radeonsi/si_shader.h      |  3 -
 5 files changed, 23 insertions(+), 43 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 9d15e17faa98..e8457bb405ea 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -680,7 +680,7 @@ static bool lower_intrinsic(nir_builder *b, nir_instr *instr, struct lower_abi_s
       break;
    case nir_intrinsic_load_tess_rel_patch_id_amd:
       /* LLVM need to replace patch id arg, so have to be done in LLVM backend. */
-      if (!shader->use_aco)
+      if (!sel->screen->use_aco)
          return false;
 
       if (stage == MESA_SHADER_TESS_CTRL) {
@@ -740,7 +740,7 @@ static bool lower_tex(nir_builder *b, nir_instr *instr, struct lower_abi_state *
     */
 
    /* LLVM keep non-uniform sampler as index, so can't do this in NIR. */
-   if (tex->is_shadow && gfx_level >= GFX8 && gfx_level <= GFX9 && s->shader->use_aco) {
+   if (tex->is_shadow && gfx_level >= GFX8 && gfx_level <= GFX9 && sel->screen->use_aco) {
       int samp_index = nir_tex_instr_src_index(tex, nir_tex_src_sampler_handle);
       int comp_index = nir_tex_instr_src_index(tex, nir_tex_src_comparator);
       assert(samp_index >= 0 && comp_index >= 0);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 5c67a9ae005c..eeb8851473cb 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1184,6 +1184,9 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
                                             sscreen->info.has_dedicated_vram;
    }
 
+   /* ACO does not support compute cards yet. */
+   sscreen->use_aco = (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics;
+
    if (sscreen->debug_flags & DBG(NO_GFX))
       sscreen->info.has_graphics = false;
 
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index af042af269ad..b8ab0f05d45f 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -579,6 +579,7 @@ struct si_screen {
    bool use_ngg_culling;
    bool allow_dcc_msaa_clear_to_reg_for_bpp[5]; /* indexed by log2(Bpp) */
    bool always_allow_dcc_stores;
+   bool use_aco;
 
    struct {
 #define OPT_BOOL(name, dflt, description) bool name : 1;
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 5d6e746455ed..3c5e8b7954c5 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -389,7 +389,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       }
 
       /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
-      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+      if (sel->screen->use_aco && sel->screen->info.gfx_level < GFX11)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
 
       /* VGPRs */
@@ -407,7 +407,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tcs_factor_offset);
 
       /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
-      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+      if (sel->screen->use_aco && sel->screen->info.gfx_level < GFX11)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
 
       /* VGPRs */
@@ -473,7 +473,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
                ac_add_return(&args->ac, AC_ARG_VGPR);
 
             /* VS outputs passed via VGPRs to TCS. */
-            if (shader->key.ge.opt.same_patch_vertices && !shader->use_aco) {
+            if (shader->key.ge.opt.same_patch_vertices && !sel->screen->use_aco) {
                unsigned num_outputs = util_last_bit64(shader->selector->info.outputs_written);
                for (i = 0; i < num_outputs * 4; i++)
                   ac_add_return(&args->ac, AC_ARG_VGPR);
@@ -481,7 +481,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
          }
       } else {
          /* TCS inputs are passed via VGPRs from VS. */
-         if (shader->key.ge.opt.same_patch_vertices && !shader->use_aco) {
+         if (shader->key.ge.opt.same_patch_vertices && !sel->screen->use_aco) {
             unsigned num_inputs = util_last_bit64(shader->previous_stage_sel->info.outputs_written);
             for (i = 0; i < num_inputs * 4; i++)
                ac_add_arg(&args->ac, AC_ARG_VGPR, 1, AC_ARG_FLOAT, NULL);
@@ -604,7 +604,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       }
 
       /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
-      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+      if (sel->screen->use_aco && sel->screen->info.gfx_level < GFX11)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
 
       /* VGPRs */
@@ -618,7 +618,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.gs_wave_id);
 
       /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
-      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+      if (sel->screen->use_aco && sel->screen->info.gfx_level < GFX11)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
 
       /* VGPRs */
@@ -671,7 +671,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
       si_add_arg_checked(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.pos_fixed_pt,
                          SI_PARAM_POS_FIXED_PT);
 
-      if (shader->use_aco) {
+      if (sel->screen->use_aco) {
          ac_compact_ps_vgpr_args(&args->ac, shader->config.spi_ps_input_addr);
 
          /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
@@ -747,7 +747,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.tg_size);
 
       /* GFX11 set FLAT_SCRATCH directly instead of using this arg. */
-      if (shader->use_aco && sel->screen->info.gfx_level < GFX11)
+      if (sel->screen->use_aco && sel->screen->info.gfx_level < GFX11)
          ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
 
       /* Hardware VGPRs. */
@@ -2264,7 +2264,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader,
       NIR_PASS(progress, nir, ac_nir_lower_image_opcodes);
 
    /* LLVM does not work well with this, so is handled in llvm backend waterfall. */
-   if (shader->use_aco && sel->info.has_non_uniform_tex_access) {
+   if (sel->screen->use_aco && sel->info.has_non_uniform_tex_access) {
       nir_lower_non_uniform_access_options options = {
          .types = nir_lower_non_uniform_texture_access,
       };
@@ -2348,7 +2348,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader,
       ac_nir_lower_ps_options options = {
          .gfx_level = sel->screen->info.gfx_level,
          .family = sel->screen->info.family,
-         .use_aco = shader->use_aco,
+         .use_aco = sel->screen->use_aco,
          .uses_discard = si_shader_uses_discard(shader),
          .alpha_to_coverage_via_mrtz = key->ps.part.epilog.alpha_to_coverage_via_mrtz,
          .dual_src_blend_swizzle = key->ps.part.epilog.dual_src_blend_swizzle,
@@ -2407,7 +2407,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader,
    /* aco only accept scalar const, must be done after si_nir_late_opts()
     * which may generate vec const.
     */
-   if (shader->use_aco)
+   if (sel->screen->use_aco)
       NIR_PASS_V(nir, nir_lower_load_const_to_scalar);
 
    /* This helps LLVM form VMEM clauses and thus get more GPU cache hits.
@@ -2432,20 +2432,6 @@ void si_update_shader_binary_info(struct si_shader *shader, nir_shader *nir)
    shader->info.uses_vmem_sampler_or_bvh |= info.uses_vmem_sampler_or_bvh;
 }
 
-static void si_determine_use_aco(struct si_shader *shader)
-{
-   const struct si_shader_selector *sel = shader->selector;
-
-   if (!(sel->screen->debug_flags & DBG(USE_ACO)))
-      return;
-
-   /* ACO does not support compute cards yet. */
-   if (!sel->screen->info.has_graphics)
-      return;
-
-   shader->use_aco = true;
-}
-
 /* Generate code for the hardware VS shader stage to go with a geometry shader */
 static struct si_shader *
 si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
@@ -2506,8 +2492,6 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
                                    sscreen->options.vrs2x2,
                                    output_info);
 
-   si_determine_use_aco(shader);
-
    struct si_shader_args args;
    si_init_shader_args(shader, &args);
 
@@ -2517,7 +2501,7 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
    si_nir_opts(gs_selector->screen, nir, false);
 
    /* aco only accept scalar const */
-   if (shader->use_aco)
+   if (sscreen->use_aco)
       NIR_PASS_V(nir, nir_lower_load_const_to_scalar);
 
    if (si_can_dump_shader(sscreen, MESA_SHADER_GEOMETRY, SI_DUMP_NIR)) {
@@ -2525,7 +2509,7 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
       nir_print_shader(nir, stderr);
    }
 
-   bool ok = shader->use_aco ?
+   bool ok = sscreen->use_aco ?
       si_aco_compile_shader(shader, &args, nir, debug) :
       si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir);
 
@@ -2715,10 +2699,8 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
    bool ret = true;
    struct si_shader_selector *sel = shader->selector;
 
-   si_determine_use_aco(shader);
-
    /* ACO need spi_ps_input in advance to init args and used in compiler. */
-   if (sel->stage == MESA_SHADER_FRAGMENT && shader->use_aco)
+   if (sel->stage == MESA_SHADER_FRAGMENT && sscreen->use_aco)
       si_set_spi_ps_input_config(shader);
 
    /* We need this info only when legacy GS. */
@@ -2782,7 +2764,7 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
                                                   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP64))
       float_mode &= ~V_00B028_FP_16_64_DENORMS;
 
-   ret = shader->use_aco ?
+   ret = sscreen->use_aco ?
       si_aco_compile_shader(shader, &args, nir, debug) :
       si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir);
    if (!ret)
@@ -2873,7 +2855,7 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
    if (sel->screen->info.gfx_level < GFX11 &&
        (sel->screen->info.family < CHIP_GFX940 || sel->screen->info.has_graphics) &&
        !si_is_merged_shader(shader)) {
-      if (shader->use_aco) {
+      if (sscreen->use_aco) {
          /* When aco scratch_offset arg is added explicitly at the beginning.
           * After compile if no scratch used, reduce the input sgpr count.
           */
@@ -2945,9 +2927,7 @@ si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
    result = CALLOC_STRUCT(si_shader_part);
    result->key = *key;
 
-   bool use_aco = (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics;
-
-   bool ok = use_aco ?
+   bool ok = sscreen->use_aco ?
       si_aco_build_shader_part(sscreen, stage, prolog, debug, name, result) :
       si_llvm_build_shader_part(sscreen, stage, prolog, compiler, debug, name, result);
 
@@ -3514,7 +3494,6 @@ nir_shader *si_get_prev_stage_nir_shader(struct si_shader *shader,
     */
    prev_shader->key.ge.opt.kill_outputs = 0;
    prev_shader->is_monolithic = true;
-   prev_shader->use_aco = shader->use_aco;
 
    si_init_shader_args(prev_shader, args);
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index e6b82e2fff1f..a4bfbc264449 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -886,9 +886,6 @@ struct si_shader {
    bool is_gs_copy_shader;
    uint8_t wave_size;
 
-   /* Use ACO for compilation. */
-   bool use_aco;
-
    /* The following data is all that's needed for binary shaders. */
    struct si_shader_binary binary;
    struct ac_shader_config config;
-- 
GitLab


From a37b50984389c4843954c1400b4ac211d5aa7623 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 14:11:31 +0800
Subject: [PATCH 11/21] radeonsi: stop llvm context init when use aco

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_compute.c     |  4 +++-
 src/gallium/drivers/radeonsi/si_pipe.c        | 22 +++++++++++--------
 .../drivers/radeonsi/si_state_shaders.cpp     | 12 +++++++---
 3 files changed, 25 insertions(+), 13 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index 642acb79cc9e..3e28c74fb323 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -99,10 +99,12 @@ static void si_create_compute_state_async(void *job, void *gdata, int thread_ind
    assert(thread_index < ARRAY_SIZE(sscreen->compiler));
    compiler = &sscreen->compiler[thread_index];
 
-   if (!*compiler) {
+#ifdef LLVM_AVAILABLE
+   if (!sscreen->use_aco && !*compiler) {
       *compiler = CALLOC_STRUCT(ac_llvm_compiler);
       si_init_compiler(sscreen, *compiler);
    }
+#endif
 
    assert(program->ir_type == PIPE_SHADER_IR_NIR);
    si_nir_scan_shader(sscreen, sel->nir, &sel->info);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index eeb8851473cb..2ad4164aa1f7 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1198,16 +1198,20 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
       return NULL;
    }
 
-   /* Initialize just one compiler instance to check for errors. The other compiler instances are
-    * initialized on demand.
-    */
-   sscreen->compiler[0] = CALLOC_STRUCT(ac_llvm_compiler);
-   if (!si_init_compiler(sscreen, sscreen->compiler[0])) {
-      /* The callee prints the error message. */
-      FREE(sscreen->nir_options);
-      FREE(sscreen);
-      return NULL;
+#ifdef LLVM_AVAILABLE
+   if (!sscreen->use_aco) {
+      /* Initialize just one compiler instance to check for errors. The other compiler instances are
+       * initialized on demand.
+       */
+      sscreen->compiler[0] = CALLOC_STRUCT(ac_llvm_compiler);
+      if (!si_init_compiler(sscreen, sscreen->compiler[0])) {
+         /* The callee prints the error message. */
+         FREE(sscreen->nir_options);
+         FREE(sscreen);
+         return NULL;
+      }
    }
+#endif
 
    util_idalloc_mt_init_tc(&sscreen->buffer_ids);
 
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index c6d0010e6c21..cb46337e8cfe 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -2482,10 +2482,12 @@ static void si_build_shader_variant(struct si_shader *shader, int thread_index,
       compiler = &shader->compiler_ctx_state.compiler;
    }
 
-   if (!*compiler) {
+#ifdef LLVM_AVAILABLE
+   if (!sscreen->use_aco && !*compiler) {
       *compiler = CALLOC_STRUCT(ac_llvm_compiler);
       si_init_compiler(sscreen, *compiler);
    }
+#endif
 
    if (unlikely(!si_create_shader_variant(sscreen, *compiler, shader, debug))) {
       PRINT_ERR("Failed to build shader variant (type=%u)\n", sel->stage);
@@ -2700,10 +2702,12 @@ current_not_ready:
 
    util_queue_fence_init(&shader->ready);
 
-   if (!sctx->compiler) {
+#ifdef LLVM_AVAILABLE
+   if (!sscreen->use_aco && !sctx->compiler) {
       sctx->compiler = CALLOC_STRUCT(ac_llvm_compiler);
       si_init_compiler(sctx->screen, sctx->compiler);
    }
+#endif
 
    shader->selector = sel;
    *((SHADER_KEY_TYPE*)&shader->key) = *key;
@@ -2912,10 +2916,12 @@ static void si_init_shader_selector_async(void *job, void *gdata, int thread_ind
    assert(thread_index < (int)ARRAY_SIZE(sscreen->compiler));
    compiler = &sscreen->compiler[thread_index];
 
-   if (!*compiler) {
+#ifdef LLVM_AVAILABLE
+   if (!sscreen->use_aco && !*compiler) {
       *compiler = CALLOC_STRUCT(ac_llvm_compiler);
       si_init_compiler(sscreen, *compiler);
    }
+#endif
 
    /* Serialize NIR to save memory. Monolithic shader variants
     * have to deserialize NIR before compilation.
-- 
GitLab


From 2d98320c3fb40b33bf6ec862954ab1acf6ee6adb Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 14:56:21 +0800
Subject: [PATCH 12/21] radeonsi: move llvm header to si_shader_llvm.h

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/meson.build      |   1 +
 .../drivers/radeonsi/si_shader_internal.h     | 103 ++---------------
 src/gallium/drivers/radeonsi/si_shader_llvm.h | 108 ++++++++++++++++++
 3 files changed, 118 insertions(+), 94 deletions(-)
 create mode 100644 src/gallium/drivers/radeonsi/si_shader_llvm.h

diff --git a/src/gallium/drivers/radeonsi/meson.build b/src/gallium/drivers/radeonsi/meson.build
index ec0b8bf377e6..454564ec88a1 100644
--- a/src/gallium/drivers/radeonsi/meson.build
+++ b/src/gallium/drivers/radeonsi/meson.build
@@ -55,6 +55,7 @@ files_libradeonsi = files(
   'si_shader_info.c',
   'si_shader_internal.h',
   'si_shader_llvm.c',
+  'si_shader_llvm.h',
   'si_shader_llvm_gs.c',
   'si_shader_llvm_ps.c',
   'si_shader_llvm_tess.c',
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 9b85375d913a..bdb36ae3b9ce 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -8,10 +8,14 @@
 #define SI_SHADER_PRIVATE_H
 
 #include "ac_hw_stage.h"
-#include "ac_shader_abi.h"
-#include "ac_llvm_build.h"
+#include "ac_shader_args.h"
+#include "ac_shader_util.h"
 #include "si_shader.h"
 
+#ifdef LLVM_AVAILABLE
+#include "si_shader_llvm.h"
+#endif
+
 #define SI_SPI_PS_INPUT_ADDR_FOR_PROLOG (       \
    S_0286D0_PERSP_SAMPLE_ENA(1) |               \
    S_0286D0_PERSP_CENTER_ENA(1) |               \
@@ -78,49 +82,15 @@ struct si_shader_args {
    struct ac_arg cs_image[3];
 };
 
-struct si_shader_context {
-   struct ac_llvm_context ac;
-   struct si_shader *shader;
-   struct si_screen *screen;
-
-   gl_shader_stage stage;
-
-   /* For clamping the non-constant index in resource indexing: */
-   unsigned num_const_buffers;
-   unsigned num_shader_buffers;
-   unsigned num_images;
-   unsigned num_samplers;
-
-   struct si_shader_args *args;
-   struct ac_shader_abi abi;
-
-   LLVMBasicBlockRef merged_wrap_if_entry_block;
-   int merged_wrap_if_label;
-
-   struct ac_llvm_pointer main_fn;
-   LLVMTypeRef return_type;
-
-   struct ac_llvm_compiler *compiler;
-
-   /* Preloaded descriptors. */
-   LLVMValueRef instance_divisor_constbuf;
-
-   LLVMValueRef gs_ngg_emit;
-   struct ac_llvm_pointer gs_ngg_scratch;
-   LLVMValueRef return_value;
-};
-
-static inline struct si_shader_context *si_shader_context_from_abi(struct ac_shader_abi *abi)
-{
-   return container_of(abi, struct si_shader_context, abi);
-}
-
 struct ac_nir_gs_output_info;
 typedef struct ac_nir_gs_output_info ac_nir_gs_output_info;
 
 struct nir_builder;
 typedef struct nir_builder nir_builder;
 
+struct nir_shader;
+typedef struct nir_shader nir_shader;
+
 /* si_shader.c */
 bool si_is_multi_part_shader(struct si_shader *shader);
 bool si_is_merged_shader(struct si_shader *shader);
@@ -183,61 +153,6 @@ bool si_nir_lower_resource(nir_shader *nir, struct si_shader *shader,
 bool si_nir_lower_vs_inputs(nir_shader *nir, struct si_shader *shader,
                             struct si_shader_args *args);
 
-/* si_shader_llvm.c */
-bool si_compile_llvm(struct si_screen *sscreen, struct si_shader_binary *binary,
-                     struct ac_shader_config *conf, struct ac_llvm_compiler *compiler,
-                     struct ac_llvm_context *ac, struct util_debug_callback *debug,
-                     gl_shader_stage stage, const char *name, bool less_optimized);
-void si_llvm_context_init(struct si_shader_context *ctx, struct si_screen *sscreen,
-                          struct ac_llvm_compiler *compiler, unsigned wave_size,
-                          bool exports_color_null, bool exports_mrtz,
-                          enum ac_float_mode float_mode);
-void si_llvm_create_func(struct si_shader_context *ctx, const char *name, LLVMTypeRef *return_types,
-                         unsigned num_return_elems, unsigned max_workgroup_size);
-void si_llvm_create_main_func(struct si_shader_context *ctx);
-void si_llvm_optimize_module(struct si_shader_context *ctx);
-void si_llvm_dispose(struct si_shader_context *ctx);
-LLVMValueRef si_buffer_load_const(struct si_shader_context *ctx, LLVMValueRef resource,
-                                  LLVMValueRef offset);
-void si_llvm_build_ret(struct si_shader_context *ctx, LLVMValueRef ret);
-LLVMValueRef si_insert_input_ret(struct si_shader_context *ctx, LLVMValueRef ret,
-                                 struct ac_arg param, unsigned return_index);
-LLVMValueRef si_insert_input_ret_float(struct si_shader_context *ctx, LLVMValueRef ret,
-                                       struct ac_arg param, unsigned return_index);
-LLVMValueRef si_insert_input_ptr(struct si_shader_context *ctx, LLVMValueRef ret,
-                                 struct ac_arg param, unsigned return_index);
-LLVMValueRef si_prolog_get_internal_binding_slot(struct si_shader_context *ctx, unsigned slot);
-LLVMValueRef si_unpack_param(struct si_shader_context *ctx, struct ac_arg param, unsigned rshift,
-                             unsigned bitwidth);
-bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
-                            struct si_shader *shader, struct si_shader_args *args,
-                            struct util_debug_callback *debug, struct nir_shader *nir);
-bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
-                               bool prolog, struct ac_llvm_compiler *compiler,
-                               struct util_debug_callback *debug, const char *name,
-                               struct si_shader_part *result);
-
-/* si_shader_llvm_gs.c */
-LLVMValueRef si_is_es_thread(struct si_shader_context *ctx);
-LLVMValueRef si_is_gs_thread(struct si_shader_context *ctx);
-void si_llvm_es_build_end(struct si_shader_context *ctx);
-void si_llvm_gs_build_end(struct si_shader_context *ctx);
-
-/* si_shader_llvm_tess.c */
-LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx);
-void si_llvm_ls_build_end(struct si_shader_context *ctx);
-void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
-void si_llvm_tcs_build_end(struct si_shader_context *ctx);
-void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx);
-
-/* si_shader_llvm_ps.c */
-void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
-void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
-void si_llvm_ps_build_end(struct si_shader_context *ctx);
-
-/* si_shader_llvm_vs.c */
-void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
-
 /* si_shader_aco.c */
 bool si_aco_compile_shader(struct si_shader *shader,
                            struct si_shader_args *args,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.h b/src/gallium/drivers/radeonsi/si_shader_llvm.h
new file mode 100644
index 000000000000..75d5d10a655f
--- /dev/null
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#ifndef SI_SHADER_LLVM_H
+#define SI_SHADER_LLVM_H
+
+#include "ac_shader_abi.h"
+#include "ac_llvm_build.h"
+#include "si_shader.h"
+
+struct si_shader_args;
+
+struct si_shader_context {
+   struct ac_llvm_context ac;
+   struct si_shader *shader;
+   struct si_screen *screen;
+
+   gl_shader_stage stage;
+
+   /* For clamping the non-constant index in resource indexing: */
+   unsigned num_const_buffers;
+   unsigned num_shader_buffers;
+   unsigned num_images;
+   unsigned num_samplers;
+
+   struct si_shader_args *args;
+   struct ac_shader_abi abi;
+
+   LLVMBasicBlockRef merged_wrap_if_entry_block;
+   int merged_wrap_if_label;
+
+   struct ac_llvm_pointer main_fn;
+   LLVMTypeRef return_type;
+
+   struct ac_llvm_compiler *compiler;
+
+   /* Preloaded descriptors. */
+   LLVMValueRef instance_divisor_constbuf;
+
+   LLVMValueRef gs_ngg_emit;
+   struct ac_llvm_pointer gs_ngg_scratch;
+   LLVMValueRef return_value;
+};
+
+static inline struct si_shader_context *si_shader_context_from_abi(struct ac_shader_abi *abi)
+{
+   return container_of(abi, struct si_shader_context, abi);
+}
+
+/* si_shader_llvm.c */
+bool si_compile_llvm(struct si_screen *sscreen, struct si_shader_binary *binary,
+                     struct ac_shader_config *conf, struct ac_llvm_compiler *compiler,
+                     struct ac_llvm_context *ac, struct util_debug_callback *debug,
+                     gl_shader_stage stage, const char *name, bool less_optimized);
+void si_llvm_context_init(struct si_shader_context *ctx, struct si_screen *sscreen,
+                          struct ac_llvm_compiler *compiler, unsigned wave_size,
+                          bool exports_color_null, bool exports_mrtz,
+                          enum ac_float_mode float_mode);
+void si_llvm_create_func(struct si_shader_context *ctx, const char *name, LLVMTypeRef *return_types,
+                         unsigned num_return_elems, unsigned max_workgroup_size);
+void si_llvm_create_main_func(struct si_shader_context *ctx);
+void si_llvm_optimize_module(struct si_shader_context *ctx);
+void si_llvm_dispose(struct si_shader_context *ctx);
+LLVMValueRef si_buffer_load_const(struct si_shader_context *ctx, LLVMValueRef resource,
+                                  LLVMValueRef offset);
+void si_llvm_build_ret(struct si_shader_context *ctx, LLVMValueRef ret);
+LLVMValueRef si_insert_input_ret(struct si_shader_context *ctx, LLVMValueRef ret,
+                                 struct ac_arg param, unsigned return_index);
+LLVMValueRef si_insert_input_ret_float(struct si_shader_context *ctx, LLVMValueRef ret,
+                                       struct ac_arg param, unsigned return_index);
+LLVMValueRef si_insert_input_ptr(struct si_shader_context *ctx, LLVMValueRef ret,
+                                 struct ac_arg param, unsigned return_index);
+LLVMValueRef si_prolog_get_internal_binding_slot(struct si_shader_context *ctx, unsigned slot);
+LLVMValueRef si_unpack_param(struct si_shader_context *ctx, struct ac_arg param, unsigned rshift,
+                             unsigned bitwidth);
+bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
+                            struct si_shader *shader, struct si_shader_args *args,
+                            struct util_debug_callback *debug, struct nir_shader *nir);
+bool si_llvm_build_shader_part(struct si_screen *sscreen, gl_shader_stage stage,
+                               bool prolog, struct ac_llvm_compiler *compiler,
+                               struct util_debug_callback *debug, const char *name,
+                               struct si_shader_part *result);
+
+/* si_shader_llvm_gs.c */
+LLVMValueRef si_is_es_thread(struct si_shader_context *ctx);
+LLVMValueRef si_is_gs_thread(struct si_shader_context *ctx);
+void si_llvm_es_build_end(struct si_shader_context *ctx);
+void si_llvm_gs_build_end(struct si_shader_context *ctx);
+
+/* si_shader_llvm_tess.c */
+LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx);
+void si_llvm_ls_build_end(struct si_shader_context *ctx);
+void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
+void si_llvm_tcs_build_end(struct si_shader_context *ctx);
+void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx);
+
+/* si_shader_llvm_ps.c */
+void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
+void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
+void si_llvm_ps_build_end(struct si_shader_context *ctx);
+
+/* si_shader_llvm_vs.c */
+void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part_key *key);
+
+#endif
-- 
GitLab


From 2b40107bc5df7587ad1c027c14e247eba7c024a3 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 15:04:01 +0800
Subject: [PATCH 13/21] radeonsi: selectively build si llvm compiler
 init/destroy

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_pipe.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 2ad4164aa1f7..413fc3175650 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -131,6 +131,7 @@ static const struct debug_named_value test_options[] = {
 
 bool si_init_compiler(struct si_screen *sscreen, struct ac_llvm_compiler *compiler)
 {
+#ifdef LLVM_AVAILABLE
    /* Only create the less-optimizing version of the compiler on APUs
     * predating Ryzen (Raven). */
    bool create_low_opt_compiler =
@@ -146,6 +147,7 @@ bool si_init_compiler(struct si_screen *sscreen, struct ac_llvm_compiler *compil
    compiler->passes = ac_create_llvm_passes(compiler->tm);
    if (compiler->low_opt_tm)
       compiler->low_opt_passes = ac_create_llvm_passes(compiler->low_opt_tm);
+#endif
 
    return true;
 }
@@ -167,7 +169,9 @@ void si_init_aux_async_compute_ctx(struct si_screen *sscreen)
 
 static void si_destroy_compiler(struct ac_llvm_compiler *compiler)
 {
+#ifdef LLVM_AVAILABLE
    ac_destroy_llvm_compiler(compiler);
+#endif
 }
 
 
-- 
GitLab


From 2fd0663c03b7c54a125c5d0fd1c3d2424c437484 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 15:14:19 +0800
Subject: [PATCH 14/21] radeonsi: selectively build llvm compile

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c | 26 ++++++++++++++++--------
 1 file changed, 17 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 3c5e8b7954c5..41ce23569983 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2509,9 +2509,12 @@ si_nir_generate_gs_copy_shader(struct si_screen *sscreen,
       nir_print_shader(nir, stderr);
    }
 
-   bool ok = sscreen->use_aco ?
-      si_aco_compile_shader(shader, &args, nir, debug) :
-      si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir);
+   bool ok =
+#ifdef LLVM_AVAILABLE
+      !sscreen->use_aco ? si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir) :
+#endif
+      si_aco_compile_shader(shader, &args, nir, debug);
+
 
    if (ok) {
       assert(!shader->config.scratch_bytes_per_wave);
@@ -2764,9 +2767,12 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
                                                   FLOAT_CONTROLS_DENORM_FLUSH_TO_ZERO_FP64))
       float_mode &= ~V_00B028_FP_16_64_DENORMS;
 
-   ret = sscreen->use_aco ?
-      si_aco_compile_shader(shader, &args, nir, debug) :
-      si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir);
+   ret =
+#ifdef LLVM_AVAILABLE
+      !sscreen->use_aco ? si_llvm_compile_shader(sscreen, compiler, shader, &args, debug, nir) :
+#endif
+      si_aco_compile_shader(shader, &args, nir, debug);
+
    if (!ret)
       goto out;
 
@@ -2927,9 +2933,11 @@ si_get_shader_part(struct si_screen *sscreen, struct si_shader_part **list,
    result = CALLOC_STRUCT(si_shader_part);
    result->key = *key;
 
-   bool ok = sscreen->use_aco ?
-      si_aco_build_shader_part(sscreen, stage, prolog, debug, name, result) :
-      si_llvm_build_shader_part(sscreen, stage, prolog, compiler, debug, name, result);
+   bool ok =
+#ifdef LLVM_AVAILABLE
+      !sscreen->use_aco ? si_llvm_build_shader_part(sscreen, stage, prolog, compiler, debug, name, result) :
+#endif
+      si_aco_build_shader_part(sscreen, stage, prolog, debug, name, result);
 
    if (ok) {
       result->next = *list;
-- 
GitLab


From a9a3b1235c9941d70f4eba7d3c59559aa2667701 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 15:44:00 +0800
Subject: [PATCH 15/21] radeonsi: set use_aco when no llvm available

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_pipe.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 413fc3175650..d2c509301d84 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1188,8 +1188,18 @@ static struct pipe_screen *radeonsi_screen_create_impl(struct radeon_winsys *ws,
                                             sscreen->info.has_dedicated_vram;
    }
 
-   /* ACO does not support compute cards yet. */
-   sscreen->use_aco = (sscreen->debug_flags & DBG(USE_ACO)) && sscreen->info.has_graphics;
+#ifdef LLVM_AVAILABLE
+   sscreen->use_aco = (sscreen->debug_flags & DBG(USE_ACO));
+#else
+   sscreen->use_aco = true;
+#endif
+
+   if (sscreen->use_aco && !sscreen->info.has_graphics) {
+      fprintf(stderr, "radeonsi: ACO does not support compute cards yet\n");
+      FREE(sscreen->nir_options);
+      FREE(sscreen);
+      return NULL;
+   }
 
    if (sscreen->debug_flags & DBG(NO_GFX))
       sscreen->info.has_graphics = false;
-- 
GitLab


From 48a39033ec197c8c9f43091f892def8bf8d71e19 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 16:22:02 +0800
Subject: [PATCH 16/21] radeonsi: include ac_llvm_util.h when llvm available

Remove unused include.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_get.c             | 1 -
 src/gallium/drivers/radeonsi/si_state_shaders.cpp | 3 +++
 src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c     | 1 -
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 8de9124c0c1f..c20b31eebe93 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -9,7 +9,6 @@
 #include "radeon_vce.h"
 #include "radeon_video.h"
 #include "si_pipe.h"
-#include "ac_llvm_util.h"
 #include "util/u_cpu_detect.h"
 #include "util/u_screen.h"
 #include "util/u_video.h"
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index cb46337e8cfe..bf3107b25c2a 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -4,7 +4,10 @@
  * SPDX-License-Identifier: MIT
  */
 
+#ifdef LLVM_AVAILABLE
 #include "ac_llvm_util.h"
+#endif
+
 #include "ac_nir.h"
 #include "ac_shader_util.h"
 #include "compiler/nir/nir_serialize.h"
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
index 83bcf94309fc..699c1e852652 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_winsys.c
@@ -20,7 +20,6 @@
 #include <stdio.h>
 #include <sys/stat.h>
 #include <fcntl.h>
-#include "ac_llvm_util.h"
 #include "sid.h"
 
 static struct hash_table *dev_tab = NULL;
-- 
GitLab


From 83dfdab2a47f7d83445e128e50a6c823b62a1cd2 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 18:30:24 +0800
Subject: [PATCH 17/21] radeonsi: disk cache remove llvm dependancy when use
 aco

This re-enable disk cache when use aco.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_pipe.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index d2c509301d84..14a4e8e46d09 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1103,7 +1103,7 @@ static void si_test_gds_memory_management(struct si_context *sctx, unsigned allo
 static void si_disk_cache_create(struct si_screen *sscreen)
 {
    /* Don't use the cache if shader dumping is enabled. */
-   if (sscreen->debug_flags & (DBG_ALL_SHADERS | DBG(USE_ACO)))
+   if (sscreen->debug_flags & DBG_ALL_SHADERS)
       return;
 
    struct mesa_sha1 ctx;
@@ -1112,9 +1112,14 @@ static void si_disk_cache_create(struct si_screen *sscreen)
 
    _mesa_sha1_init(&ctx);
 
-   if (!disk_cache_get_function_identifier(si_disk_cache_create, &ctx) ||
+   if (!disk_cache_get_function_identifier(si_disk_cache_create, &ctx))
+      return;
+
+#ifdef LLVM_AVAILABLE
+   if (!sscreen->use_aco &&
        !disk_cache_get_function_identifier(LLVMInitializeAMDGPUTargetInfo, &ctx))
       return;
+#endif
 
    _mesa_sha1_final(&ctx, sha1);
    mesa_bytes_to_hex(cache_id, sha1, 20);
-- 
GitLab


From fe1b9cf507560b5fd996caf5b10bb28b29bc4f81 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 12 Sep 2023 10:25:57 +0800
Subject: [PATCH 18/21] radeonsi: does not call llvm init when no llvm
 available

It's still needed when aco asm print.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_pipe.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 14a4e8e46d09..759049460836 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -1529,6 +1529,7 @@ struct pipe_screen *radeonsi_screen_create(int fd, const struct pipe_screen_conf
    if (!version)
      return NULL;
 
+#ifdef LLVM_AVAILABLE
    /* LLVM must be initialized before util_queue because both u_queue and LLVM call atexit,
     * and LLVM must call it first because its atexit handler executes C++ destructors,
     * which must be done after our compiler threads using LLVM in u_queue are finished
@@ -1536,6 +1537,7 @@ struct pipe_screen *radeonsi_screen_create(int fd, const struct pipe_screen_conf
     * LLVM must be initialized first, followed by u_queue.
     */
    ac_init_llvm_once();
+#endif
 
    driParseConfigFiles(config->options, config->options_info, 0, "radeonsi",
                        NULL, NULL, NULL, 0, NULL, 0);
-- 
GitLab


From edf8366f834b6790537067e8f2b7aa95d6e33b74 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 5 Sep 2023 20:49:10 +0800
Subject: [PATCH 19/21] radeonsi: change compiler name for aco

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_get.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index c20b31eebe93..6685e629660f 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -1210,8 +1210,14 @@ static void si_init_renderer_string(struct si_screen *sscreen)
    if (uname(&uname_data) == 0)
       snprintf(kernel_version, sizeof(kernel_version), ", %s", uname_data.release);
 
+   const char *compiler_name =
+#ifdef LLVM_AVAILABLE
+      !sscreen->use_aco ? "LLVM " MESA_LLVM_VERSION_STRING :
+#endif
+      "ACO";
+
    snprintf(sscreen->renderer_string, sizeof(sscreen->renderer_string),
-            "%s (%sLLVM " MESA_LLVM_VERSION_STRING ", DRM %i.%i%s)", first_name, second_name,
+            "%s (%s%s, DRM %i.%i%s)", first_name, second_name, compiler_name,
             sscreen->info.drm_major, sscreen->info.drm_minor, kernel_version);
 }
 
-- 
GitLab


From 1cfd5b16c37bb17d9f44b3192fae9ca3712b829a Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 15:55:54 +0800
Subject: [PATCH 20/21] radeonsi: selectively build llvm files

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/meson.build | 31 ++++++++++++++++--------
 1 file changed, 21 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/meson.build b/src/gallium/drivers/radeonsi/meson.build
index 454564ec88a1..fdb70b33ba7d 100644
--- a/src/gallium/drivers/radeonsi/meson.build
+++ b/src/gallium/drivers/radeonsi/meson.build
@@ -54,12 +54,6 @@ files_libradeonsi = files(
   'si_shader_aco.c',
   'si_shader_info.c',
   'si_shader_internal.h',
-  'si_shader_llvm.c',
-  'si_shader_llvm.h',
-  'si_shader_llvm_gs.c',
-  'si_shader_llvm_ps.c',
-  'si_shader_llvm_tess.c',
-  'si_shader_llvm_vs.c',
   'si_shader_nir.c',
   'si_shaderlib_nir.c',
   'si_shaderlib_tgsi.c',
@@ -103,8 +97,25 @@ files_libradeonsi = files(
 )
 
 radeonsi_include_dirs = [inc_src, inc_include, inc_gallium, inc_gallium_aux, inc_amd_common,
-                         inc_amd_common_llvm, inc_gallium_drivers]
-radeonsi_deps = [dep_llvm, dep_clock, dep_libdrm_radeon, idep_nir_headers, idep_amdgfxregs_h, idep_mesautil, idep_aco]
+                         inc_gallium_drivers]
+radeonsi_deps = [dep_clock, dep_libdrm_radeon, idep_nir_headers, idep_amdgfxregs_h, idep_mesautil, idep_aco]
+
+amd_common_libs = [libamd_common]
+
+if with_llvm
+  files_libradeonsi += files(
+    'si_shader_llvm.c',
+    'si_shader_llvm.h',
+    'si_shader_llvm_gs.c',
+    'si_shader_llvm_ps.c',
+    'si_shader_llvm_tess.c',
+    'si_shader_llvm_vs.c',
+  )
+
+  radeonsi_include_dirs += [inc_amd_common_llvm]
+  radeonsi_deps += [dep_llvm]
+  amd_common_libs += [libamd_common_llvm]
+endif
 
 radeonsi_gfx_libs = []
 foreach ver : ['6', '7', '8', '9', '10', '103', '11']
@@ -128,8 +139,8 @@ libradeonsi = static_library(
 
 driver_radeonsi = declare_dependency(
   compile_args : '-DGALLIUM_RADEONSI',
-  link_with : radeonsi_gfx_libs + [
-    libradeonsi, libradeonwinsys, libamdgpuwinsys, libamd_common, libamd_common_llvm, libgalliumvl
+  link_with : radeonsi_gfx_libs + amd_common_libs + [
+    libradeonsi, libradeonwinsys, libamdgpuwinsys, libgalliumvl
   ],
   dependencies : idep_nir,
 )
-- 
GitLab


From 9a530f511900e42a835b2afd62021427ba255967 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 4 Sep 2023 15:59:33 +0800
Subject: [PATCH 21/21] meson: be able to build radeonsi without llvm

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 meson.build | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/meson.build b/meson.build
index 6f3cc93fbcf6..bdbf621b8477 100644
--- a/meson.build
+++ b/meson.build
@@ -1755,8 +1755,8 @@ if with_llvm
   endif
 elif with_amd_vk and with_aco_tests
   error('ACO tests require LLVM, but LLVM is disabled.')
-elif with_gallium_radeonsi or with_swrast_vk
-  error('The following drivers require LLVM: RadeonSI, Lavapipe. One of these is enabled, but LLVM is disabled.')
+elif with_swrast_vk
+  error('The following drivers require LLVM: Lavapipe. One of these is enabled, but LLVM is disabled.')
 elif with_gallium_opencl
   error('The OpenCL "Clover" state tracker requires LLVM, but LLVM is disabled.')
 elif with_clc
-- 
GitLab

