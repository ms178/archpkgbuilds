From e2fca8f8fc764dcfb17d460c90aff5535cb787c2 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 11 Aug 2022 09:32:29 -0700
Subject: [PATCH 1/6] egl/wgl: Make ref_count atomic

Looks like wgl doesn't have much display state to protect.  But it's
ref_count should be atomic before we start removing locking from eglapi
to protect against MakeCurrent being called in parallel on multiple
threads.

Signed-off-by: Rob Clark <robdclark@chromium.org>
---
 src/egl/drivers/wgl/egl_wgl.c | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 7ec1fcf79b7c..0d8b627e94be 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -318,7 +318,7 @@ wgl_initialize(_EGLDisplay *disp)
     * to free it up correctly.
     */
    if (wgl_dpy) {
-      wgl_dpy->ref_count++;
+      p_atomic_inc(&wgl_dpy->ref_count);
       return EGL_TRUE;
    }
 
@@ -338,7 +338,7 @@ wgl_initialize(_EGLDisplay *disp)
       return EGL_FALSE;
 
    wgl_dpy = wgl_egl_display(disp);
-   wgl_dpy->ref_count++;
+   p_atomic_inc(&wgl_dpy->ref_count);
 
    return EGL_TRUE;
 }
@@ -357,9 +357,7 @@ wgl_display_release(_EGLDisplay *disp)
    wgl_dpy = wgl_egl_display(disp);
 
    assert(wgl_dpy->ref_count > 0);
-   wgl_dpy->ref_count--;
-
-   if (wgl_dpy->ref_count > 0)
+   if (!p_atomic_dec_zero(&wgl_dpy->ref_count))
       return;
 
    _eglCleanupDisplay(disp);
@@ -643,7 +641,7 @@ wgl_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
           * EGLDisplay is terminated and then initialized again while a
           * context is still bound. See wgl_intitialize() for a more in depth
           * explanation. */
-         wgl_dpy->ref_count++;
+         p_atomic_inc(&wgl_dpy->ref_count);
       }
    }
 
-- 
GitLab


From 5300bc9d7e42e94d42473f780c10d15d56b78491 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 11 Aug 2022 13:02:29 -0700
Subject: [PATCH 2/6] egl/dri2: Make ref_count atomic

In particular, MakeCurrent can be called on multiple threads in
parallel.

Signed-off-by: Rob Clark <robdclark@chromium.org>
Reviewed-by: Eric Engestrom <eric@igalia.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 5d4aeec2d957..d0f6d590eee2 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1162,7 +1162,7 @@ dri2_initialize(_EGLDisplay *disp)
     * to free it up correctly.
     */
    if (dri2_dpy) {
-      dri2_dpy->ref_count++;
+      p_atomic_inc(&dri2_dpy->ref_count);
       return EGL_TRUE;
    }
 
@@ -1197,7 +1197,7 @@ dri2_initialize(_EGLDisplay *disp)
       return EGL_FALSE;
 
    dri2_dpy = dri2_egl_display(disp);
-   dri2_dpy->ref_count++;
+   p_atomic_inc(&dri2_dpy->ref_count);
 
    return EGL_TRUE;
 }
@@ -1216,9 +1216,8 @@ dri2_display_release(_EGLDisplay *disp)
    dri2_dpy = dri2_egl_display(disp);
 
    assert(dri2_dpy->ref_count > 0);
-   dri2_dpy->ref_count--;
 
-   if (dri2_dpy->ref_count > 0)
+   if (!p_atomic_dec_zero(&dri2_dpy->ref_count))
       return;
 
    _eglCleanupDisplay(disp);
@@ -1878,7 +1877,7 @@ dri2_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
           * EGLDisplay is terminated and then initialized again while a
           * context is still bound. See dri2_intitialize() for a more in depth
           * explanation. */
-         dri2_dpy->ref_count++;
+         p_atomic_inc(&dri2_dpy->ref_count);
       }
    }
 
-- 
GitLab


From aa283aa32c238636ca3ccf362bf12c5ae96e60c8 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Sat, 13 Aug 2022 10:41:46 -0700
Subject: [PATCH 3/6] egl/dri2: Add display lock

In preperation of relaxing eglapi to not hold a lock across driver
calls, but instead only for protecting it's own state, add our own
lock to protect code paths that need locking or have not been audited
yet.  The blocking calls (ClientWaitSyncKHR) or critical path and/or
blocking (MakeCurrent, SwapBuffers*) are lockless, as they have already
been audited for thread safety.

Signed-off-by: Rob Clark <robdclark@chromium.org>
Acked-by: Eric Engestrom <eric@igalia.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 242 ++++++++++++++++++++++----------
 src/egl/drivers/dri2/egl_dri2.h |  20 +++
 2 files changed, 191 insertions(+), 71 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index d0f6d590eee2..ce25cf8a9d3d 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -873,13 +873,19 @@ dri2_query_driver_name(_EGLDisplay *disp)
 static char *
 dri2_query_driver_config(_EGLDisplay *disp)
 {
-    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+    struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
     const __DRIconfigOptionsExtension *ext = dri2_dpy->configOptions;
+    char *ret;
+
+    if (ext->base.version >= 2) {
+        ret = ext->getXml(dri2_dpy->driver_name);
+    } else {
+       ret = strdup(ext->xml);
+    }
 
-    if (ext->base.version >= 2)
-        return ext->getXml(dri2_dpy->driver_name);
+    mtx_unlock(&dri2_dpy->lock);
 
-    return strdup(ext->xml);
+    return ret;
 }
 
 
@@ -1199,6 +1205,8 @@ dri2_initialize(_EGLDisplay *disp)
    dri2_dpy = dri2_egl_display(disp);
    p_atomic_inc(&dri2_dpy->ref_count);
 
+   mtx_init(&dri2_dpy->lock, mtx_plain);
+
    return EGL_TRUE;
 }
 
@@ -1483,7 +1491,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
                     _EGLContext *share_list, const EGLint *attrib_list)
 {
    struct dri2_egl_context *dri2_ctx;
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx_shared = dri2_egl_context(share_list);
    __DRIcontext *shared =
       dri2_ctx_shared ? dri2_ctx_shared->dri_context : NULL;
@@ -1496,7 +1504,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
 
    dri2_ctx = malloc(sizeof *dri2_ctx);
    if (!dri2_ctx) {
-      _eglError(EGL_BAD_ALLOC, "eglCreateContext");
+      dri2_egl_error_unlock(dri2_dpy, EGL_BAD_ALLOC, "eglCreateContext");
       return NULL;
    }
 
@@ -1639,9 +1647,12 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
    if (!dri2_ctx->dri_context)
       goto cleanup;
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return &dri2_ctx->base;
 
  cleanup:
+   mtx_unlock(&dri2_dpy->lock);
    free(dri2_ctx);
    return NULL;
 }
@@ -1707,11 +1718,12 @@ static EGLBoolean
 dri2_destroy_surface(_EGLDisplay *disp, _EGLSurface *surf)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   EGLBoolean ret = EGL_TRUE;
 
-   if (!_eglPutSurface(surf))
-      return EGL_TRUE;
+   if (_eglPutSurface(surf))
+      ret = dri2_dpy->vtbl->destroy_surface(disp, surf);
 
-   return dri2_dpy->vtbl->destroy_surface(disp, surf);
+   return ret;
 }
 
 static void
@@ -1928,39 +1940,57 @@ static _EGLSurface*
 dri2_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            void *native_window, const EGLint *attrib_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   return dri2_dpy->vtbl->create_window_surface(disp, conf, native_window,
-                                                attrib_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLSurface *ret =
+         dri2_dpy->vtbl->create_window_surface(disp, conf, native_window,
+                                               attrib_list);
+   mtx_unlock(&dri2_dpy->lock);
+   return ret;
 }
 
 static _EGLSurface*
 dri2_create_pixmap_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            void *native_pixmap, const EGLint *attrib_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->create_pixmap_surface)
-      return NULL;
-   return dri2_dpy->vtbl->create_pixmap_surface(disp, conf, native_pixmap,
-                                                attrib_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLSurface *ret = NULL;
+
+   if (dri2_dpy->vtbl->create_pixmap_surface)
+      ret = dri2_dpy->vtbl->create_pixmap_surface(disp, conf, native_pixmap,
+                                                  attrib_list);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static _EGLSurface*
 dri2_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
                             const EGLint *attrib_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->create_pbuffer_surface)
-      return NULL;
-   return dri2_dpy->vtbl->create_pbuffer_surface(disp, conf, attrib_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLSurface *ret = NULL;
+
+   if (dri2_dpy->vtbl->create_pbuffer_surface)
+      ret = dri2_dpy->vtbl->create_pbuffer_surface(disp, conf, attrib_list);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static EGLBoolean
 dri2_swap_interval(_EGLDisplay *disp, _EGLSurface *surf, EGLint interval)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->swap_interval)
-      return EGL_TRUE;
-   return dri2_dpy->vtbl->swap_interval(disp, surf, interval);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   EGLBoolean ret = EGL_TRUE;
+
+   if (dri2_dpy->vtbl->swap_interval)
+      ret = dri2_dpy->vtbl->swap_interval(disp, surf, interval);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 /**
@@ -2074,13 +2104,16 @@ static EGLBoolean
 dri2_set_damage_region(_EGLDisplay *disp, _EGLSurface *surf,
                        EGLint *rects, EGLint n_rects)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    __DRIdrawable *drawable = dri2_dpy->vtbl->get_dri_drawable(surf);
 
-   if (!dri2_dpy->buffer_damage || !dri2_dpy->buffer_damage->set_damage_region)
+   if (!dri2_dpy->buffer_damage || !dri2_dpy->buffer_damage->set_damage_region) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    dri2_dpy->buffer_damage->set_damage_region(drawable, n_rects, rects);
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_TRUE;
 }
 
@@ -2088,19 +2121,26 @@ static EGLBoolean
 dri2_post_sub_buffer(_EGLDisplay *disp, _EGLSurface *surf,
                      EGLint x, EGLint y, EGLint width, EGLint height)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->post_sub_buffer)
-      return EGL_FALSE;
-   return dri2_dpy->vtbl->post_sub_buffer(disp, surf, x, y, width, height);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   EGLBoolean ret = EGL_FALSE;
+
+   if (dri2_dpy->vtbl->post_sub_buffer)
+      ret = dri2_dpy->vtbl->post_sub_buffer(disp, surf, x, y, width, height);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static EGLBoolean
 dri2_copy_buffers(_EGLDisplay *disp, _EGLSurface *surf, void *native_pixmap_target)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    if (!dri2_dpy->vtbl->copy_buffers)
-      return _eglError(EGL_BAD_NATIVE_PIXMAP, "no support for native pixmaps");
-   return dri2_dpy->vtbl->copy_buffers(disp, surf, native_pixmap_target);
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_NATIVE_PIXMAP, "no support for native pixmaps");
+   EGLBoolean ret = dri2_dpy->vtbl->copy_buffers(disp, surf, native_pixmap_target);
+   mtx_unlock(&dri2_dpy->lock);
+   return ret;
 }
 
 static EGLint
@@ -2141,7 +2181,7 @@ dri2_wait_native(EGLint engine)
 static EGLBoolean
 dri2_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx;
    _EGLContext *ctx;
    GLint format, target;
@@ -2150,8 +2190,10 @@ dri2_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
    ctx = _eglGetCurrentContext();
    dri2_ctx = dri2_egl_context(ctx);
 
-   if (!_eglBindTexImage(disp, surf, buffer))
+   if (!_eglBindTexImage(disp, surf, buffer)) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    switch (surf->TextureFormat) {
    case EGL_TEXTURE_RGB:
@@ -2178,13 +2220,15 @@ dri2_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
                                        target, format,
                                        dri_drawable);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
 static EGLBoolean
 dri2_release_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx;
    _EGLContext *ctx;
    GLint  target;
@@ -2193,8 +2237,10 @@ dri2_release_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
    ctx = _eglGetCurrentContext();
    dri2_ctx = dri2_egl_context(ctx);
 
-   if (!_eglReleaseTexImage(disp, surf, buffer))
+   if (!_eglReleaseTexImage(disp, surf, buffer)) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    switch (surf->TextureTarget) {
    case EGL_TEXTURE_2D:
@@ -2210,6 +2256,8 @@ dri2_release_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
                                              target, dri_drawable);
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -2217,9 +2265,11 @@ static _EGLImage*
 dri2_create_image(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
                   EGLClientBuffer buffer, const EGLint *attr_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   return dri2_dpy->vtbl->create_image(disp, ctx, target, buffer,
-                                       attr_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLImage *ret = dri2_dpy->vtbl->create_image(disp, ctx, target, buffer,
+                                                 attr_list);
+   mtx_unlock(&dri2_dpy->lock);
+   return ret;
 }
 
 _EGLImage *
@@ -2379,9 +2429,14 @@ dri2_get_sync_values_chromium(_EGLDisplay *disp, _EGLSurface *surf,
                               EGLuint64KHR *sbc)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->get_sync_values)
-      return EGL_FALSE;
-   return dri2_dpy->vtbl->get_sync_values(disp, surf, ust, msc, sbc);
+   EGLBoolean ret = EGL_FALSE;
+
+   if (dri2_dpy->vtbl->get_sync_values)
+      ret = dri2_dpy->vtbl->get_sync_values(disp, surf, ust, msc, sbc);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static EGLBoolean
@@ -2497,18 +2552,31 @@ dri2_query_surface(_EGLDisplay *disp, _EGLSurface *surf,
                    EGLint attribute, EGLint *value)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->query_surface)
-      return _eglQuerySurface(disp, surf, attribute, value);
-   return dri2_dpy->vtbl->query_surface(disp, surf, attribute, value);
+   EGLBoolean ret;
+
+   if (!dri2_dpy->vtbl->query_surface) {
+      ret = _eglQuerySurface(disp, surf, attribute, value);
+   } else {
+      ret = dri2_dpy->vtbl->query_surface(disp, surf, attribute, value);
+   }
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static struct wl_buffer*
 dri2_create_wayland_buffer_from_image(_EGLDisplay *disp, _EGLImage *img)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->create_wayland_buffer_from_image)
-      return NULL;
-   return dri2_dpy->vtbl->create_wayland_buffer_from_image(disp, img);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   struct wl_buffer *ret = NULL;
+
+   if (dri2_dpy->vtbl->create_wayland_buffer_from_image)
+      ret = dri2_dpy->vtbl->create_wayland_buffer_from_image(disp, img);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 #ifdef HAVE_LIBDRM
@@ -2783,9 +2851,11 @@ static EGLBoolean
 dri2_query_dma_buf_formats(_EGLDisplay *disp, EGLint max,
                            EGLint *formats, EGLint *count)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (max < 0 || (max > 0 && formats == NULL))
-      return _eglError(EGL_BAD_PARAMETER, "invalid value for max count of formats");
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   if (max < 0 || (max > 0 && formats == NULL)) {
+      _eglError(EGL_BAD_PARAMETER, "invalid value for max count of formats");
+      goto fail;
+   }
 
    if (dri2_dpy->image->base.version < 15 ||
        dri2_dpy->image->queryDmaBufFormats == NULL)
@@ -2807,9 +2877,12 @@ dri2_query_dma_buf_formats(_EGLDisplay *disp, EGLint max,
       }
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 
 fail:
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_FALSE;
 }
 
@@ -2818,26 +2891,30 @@ dri2_query_dma_buf_modifiers(_EGLDisplay *disp, EGLint format,
                              EGLint max, EGLuint64KHR *modifiers,
                              EGLBoolean *external_only, EGLint *count)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
 
    if (dri2_num_fourcc_format_planes(format) == 0)
-      return _eglError(EGL_BAD_PARAMETER, "invalid fourcc format");
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid fourcc format");
 
    if (max < 0)
-      return _eglError(EGL_BAD_PARAMETER, "invalid value for max count of formats");
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid value for max count of formats");
 
    if (max > 0 && modifiers == NULL)
-      return _eglError(EGL_BAD_PARAMETER, "invalid modifiers array");
+      dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid modifiers array");
 
    if (dri2_dpy->image->base.version < 15 ||
-       dri2_dpy->image->queryDmaBufModifiers == NULL)
+       dri2_dpy->image->queryDmaBufModifiers == NULL) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    if (dri2_dpy->image->queryDmaBufModifiers(dri2_dpy->dri_screen, format,
                                              max, modifiers,
                                              (unsigned int *) external_only,
                                              count) == false)
-      return _eglError(EGL_BAD_PARAMETER, "invalid format");
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid format");
+
+   mtx_unlock(&dri2_dpy->lock);
 
    return EGL_TRUE;
 }
@@ -2966,7 +3043,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
 static _EGLImage *
 dri2_create_drm_image_mesa(_EGLDisplay *disp, const EGLint *attr_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img;
    _EGLImageAttribs attrs;
    unsigned int dri_use, valid_mask;
@@ -3029,9 +3106,12 @@ dri2_create_drm_image_mesa(_EGLDisplay *disp, const EGLint *attr_list)
       goto fail;
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return &dri2_img->base;
 
 fail:
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_NO_IMAGE_KHR;
 }
 
@@ -3039,7 +3119,7 @@ static EGLBoolean
 dri2_export_drm_image_mesa(_EGLDisplay *disp, _EGLImage *img,
                           EGLint *name, EGLint *handle, EGLint *stride)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
 
    if (name && !dri2_dpy->image->queryImage(dri2_img->dri_image,
@@ -3054,6 +3134,8 @@ dri2_export_drm_image_mesa(_EGLDisplay *disp, _EGLImage *img,
       dri2_dpy->image->queryImage(dri2_img->dri_image,
                                   __DRI_IMAGE_ATTRIB_STRIDE, stride);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3084,12 +3166,14 @@ dri2_export_dma_buf_image_query_mesa(_EGLDisplay *disp, _EGLImage *img,
                                      EGLint *fourcc, EGLint *nplanes,
                                      EGLuint64KHR *modifiers)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
    int num_planes;
 
-   if (!dri2_can_export_dma_buf_image(disp, img))
+   if (!dri2_can_export_dma_buf_image(disp, img)) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    dri2_dpy->image->queryImage(dri2_img->dri_image,
                                __DRI_IMAGE_ATTRIB_NUM_PLANES, &num_planes);
@@ -3118,6 +3202,8 @@ dri2_export_dma_buf_image_query_mesa(_EGLDisplay *disp, _EGLImage *img,
         modifiers[i] = modifier;
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3125,7 +3211,7 @@ static EGLBoolean
 dri2_export_dma_buf_image_mesa(_EGLDisplay *disp, _EGLImage *img,
                                int *fds, EGLint *strides, EGLint *offsets)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
    EGLint nplanes;
 
@@ -3162,6 +3248,8 @@ dri2_export_dma_buf_image_mesa(_EGLDisplay *disp, _EGLImage *img,
          offsets[0] = 0;
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3202,12 +3290,14 @@ dri2_create_image_khr(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
 static EGLBoolean
 dri2_destroy_image_khr(_EGLDisplay *disp, _EGLImage *image)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(image);
 
    dri2_dpy->image->destroyImage(dri2_img->dri_image);
    free(dri2_img);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3269,7 +3359,7 @@ dri2_wl_release_buffer(void *user_data, struct wl_drm_buffer *buffer)
 static EGLBoolean
 dri2_bind_wayland_display_wl(_EGLDisplay *disp, struct wl_display *wl_dpy)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    const struct wayland_drm_callbacks wl_drm_callbacks = {
       .authenticate = (int(*)(void *, uint32_t)) dri2_dpy->vtbl->authenticate,
       .reference_buffer = dri2_wl_reference_buffer,
@@ -3311,9 +3401,11 @@ dri2_bind_wayland_display_wl(_EGLDisplay *disp, struct wl_display *wl_dpy)
       dri2_dpy->gbm_dri->wl_drm = dri2_dpy->wl_server_drm;
 #endif
 
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_TRUE;
 
 fail:
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_FALSE;
 }
 
@@ -3394,7 +3486,7 @@ static _EGLSync *
 dri2_create_sync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
 {
    _EGLContext *ctx = _eglGetCurrentContext();
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
    struct dri2_egl_sync *dri2_sync;
    EGLint ret;
@@ -3480,17 +3572,20 @@ dri2_create_sync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
    }
 
    p_atomic_set(&dri2_sync->refcount, 1);
+   mtx_unlock(&dri2_dpy->lock);
+
    return &dri2_sync->base;
 
 fail:
    free(dri2_sync);
+   mtx_unlock(&dri2_dpy->lock);
    return NULL;
 }
 
 static EGLBoolean
 dri2_destroy_sync(_EGLDisplay *disp, _EGLSync *sync)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_sync *dri2_sync = dri2_egl_sync(sync);
    EGLint ret = EGL_TRUE;
    EGLint err;
@@ -3513,13 +3608,15 @@ dri2_destroy_sync(_EGLDisplay *disp, _EGLSync *sync)
 
    dri2_egl_unref_sync(dri2_dpy, dri2_sync);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return ret;
 }
 
 static EGLint
 dri2_dup_native_fence_fd(_EGLDisplay *disp, _EGLSync *sync)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_sync *dri2_sync = dri2_egl_sync(sync);
 
    assert(sync->Type == EGL_SYNC_NATIVE_FENCE_ANDROID);
@@ -3532,6 +3629,8 @@ dri2_dup_native_fence_fd(_EGLDisplay *disp, _EGLSync *sync)
                                                    dri2_sync->fence);
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    if (sync->SyncFd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
       /* if native fence fd still not created, return an error: */
       _eglError(EGL_BAD_PARAMETER, "eglDupNativeFenceFDANDROID");
@@ -3548,10 +3647,11 @@ dri2_set_blob_cache_funcs(_EGLDisplay *disp,
                           EGLSetBlobFuncANDROID set,
                           EGLGetBlobFuncANDROID get)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen,
                                    disp->BlobCacheSet,
                                    disp->BlobCacheGet);
+   mtx_unlock(&dri2_dpy->lock);
 }
 
 static EGLint
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index a3d848e0a281..2e283cba0e76 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -217,6 +217,8 @@ struct dri2_egl_display
 {
    const struct dri2_egl_display_vtbl *vtbl;
 
+   mtx_t lock;
+
    int dri2_major;
    int dri2_minor;
    __DRIscreen *dri_screen;
@@ -427,6 +429,24 @@ _EGL_DRIVER_STANDARD_TYPECASTS(dri2_egl)
 _EGL_DRIVER_TYPECAST(dri2_egl_image, _EGLImage, obj)
 _EGL_DRIVER_TYPECAST(dri2_egl_sync, _EGLSync, obj)
 
+static inline struct dri2_egl_display *
+dri2_egl_display_lock(_EGLDisplay *disp)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+
+   if (dri2_dpy)
+      mtx_lock(&dri2_dpy->lock);
+
+   return dri2_dpy;
+}
+
+static inline EGLBoolean
+dri2_egl_error_unlock(struct dri2_egl_display *dri2_dpy, EGLint err, const char *msg)
+{
+   mtx_unlock(&dri2_dpy->lock);
+   return _eglError(err, msg);
+}
+
 extern const __DRIimageLookupExtension image_lookup_extension;
 extern const __DRIuseInvalidateExtension use_invalidate;
 extern const __DRIbackgroundCallableExtension background_callable_extension;
-- 
GitLab


From e32570e91a240fab1accbf9c19faeb9e6ccfc0b2 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 18 Aug 2022 10:59:50 -0700
Subject: [PATCH 4/6] egl: Make RefCount atomic

Once we relax the locking, we will be doing _eglPutFoo() outside of the
big display lock.

Signed-off-by: Rob Clark <robdclark@chromium.org>
---
 src/egl/main/egldisplay.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index db90b2b2dc78..ddbcbf0061dd 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -442,8 +442,7 @@ void
 _eglGetResource(_EGLResource *res)
 {
    assert(res && res->RefCount > 0);
-   /* hopefully a resource is always manipulated with its display locked */
-   res->RefCount++;
+   p_atomic_inc(&res->RefCount);
 }
 
 
@@ -454,8 +453,7 @@ EGLBoolean
 _eglPutResource(_EGLResource *res)
 {
    assert(res && res->RefCount > 0);
-   res->RefCount--;
-   return (!res->RefCount);
+   return p_atomic_dec_zero(&res->RefCount);
 }
 
 
-- 
GitLab


From 104447c2ac0388811302340a771ad1666534cb15 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Mon, 29 Aug 2022 10:28:11 -0700
Subject: [PATCH 5/6] egl: Introduce rwlock to protect eglTerminate()

eglTerminate() must be serialized against all other EGL calls.  But in
most cases, other EGL calls do not need to be serialized against each
other.  Which fits rather well with a rwlock.

One would be tempted to simply replace the existing BDL with a rwlock,
but several portability and debuggability limitations of the rwlock
implementation prevent that, as described in the TerminateLock comment
block.

Signed-off-by: Rob Clark <robdclark@chromium.org>
---
 src/egl/drivers/dri2/egl_dri2.c |  4 ++--
 src/egl/drivers/wgl/egl_wgl.c   |  4 ++--
 src/egl/main/eglapi.c           | 22 +++++++++++-------
 src/egl/main/egldisplay.c       |  1 +
 src/egl/main/egldisplay.h       | 40 +++++++++++++++++++++++++++++++++
 5 files changed, 59 insertions(+), 12 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index ce25cf8a9d3d..7614ff5a798d 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -656,9 +656,9 @@ dri2_validate_egl_image(void *image, void *data)
    _EGLDisplay *disp = data;
    _EGLImage *img;
 
-   simple_mtx_lock(&disp->Mutex);
+   egl_lock(disp);
    img = _eglLookupImage(image, disp);
-   simple_mtx_unlock(&disp->Mutex);
+   egl_unlock(disp);
 
    if (img == NULL) {
       _eglError(EGL_BAD_PARAMETER, "dri2_validate_egl_image");
diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 0d8b627e94be..cf9453ad7a14 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -215,9 +215,9 @@ wgl_validate_egl_image(struct st_manager *smapi, void *image)
    _EGLDisplay *disp = wgl_dpy->parent;
    _EGLImage *img;
 
-   simple_mtx_lock(&disp->Mutex);
+   egl_lock(disp);
    img = _eglLookupImage(image, disp);
-   simple_mtx_unlock(&disp->Mutex);
+   egl_lock(disp);
 
    if (img == NULL) {
       _eglError(EGL_BAD_PARAMETER, "wgl_validate_egl_image");
diff --git a/src/egl/main/eglapi.c b/src/egl/main/eglapi.c
index 13f055355e8e..595841b5f27b 100644
--- a/src/egl/main/eglapi.c
+++ b/src/egl/main/eglapi.c
@@ -250,7 +250,7 @@ _eglLockDisplay(EGLDisplay dpy)
 {
    _EGLDisplay *disp = _eglLookupDisplay(dpy);
    if (disp)
-      simple_mtx_lock(&disp->Mutex);
+      egl_lock(disp);
    return disp;
 }
 
@@ -261,7 +261,7 @@ _eglLockDisplay(EGLDisplay dpy)
 static inline void
 _eglUnlockDisplay(_EGLDisplay *disp)
 {
-   simple_mtx_unlock(&disp->Mutex);
+   egl_unlock(disp);
 }
 
 static void
@@ -689,13 +689,16 @@ eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
 EGLBoolean EGLAPIENTRY
 eglTerminate(EGLDisplay dpy)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
 
    _EGL_FUNC_START(disp, EGL_OBJECT_DISPLAY_KHR, NULL);
 
    if (!disp)
       RETURN_EGL_ERROR(NULL, EGL_BAD_DISPLAY, EGL_FALSE);
 
+   u_rwlock_wrlock(&disp->TerminateLock);
+   simple_mtx_lock(&disp->Mutex);
+
    if (disp->Initialized) {
       disp->Driver->Terminate(disp);
       /* do not reset disp->Driver */
@@ -707,7 +710,10 @@ eglTerminate(EGLDisplay dpy)
       disp->BlobCacheGet = NULL;
    }
 
-   RETURN_EGL_SUCCESS(disp, EGL_TRUE);
+   simple_mtx_unlock(&disp->Mutex);
+   u_rwlock_wrunlock(&disp->TerminateLock);
+
+   RETURN_EGL_SUCCESS(NULL, EGL_TRUE);
 }
 
 
@@ -1523,7 +1529,7 @@ _eglWaitClientCommon(void)
       RETURN_EGL_SUCCESS(NULL, EGL_TRUE);
 
    disp = ctx->Resource.Display;
-   simple_mtx_lock(&disp->Mutex);
+   egl_lock(disp);
 
    /* let bad current context imply bad current surface */
    if (_eglGetContextHandle(ctx) == EGL_NO_CONTEXT ||
@@ -1566,7 +1572,7 @@ eglWaitNative(EGLint engine)
    _EGL_FUNC_START(NULL, EGL_OBJECT_THREAD_KHR, NULL);
 
    disp = ctx->Resource.Display;
-   simple_mtx_lock(&disp->Mutex);
+   egl_lock(disp);
 
    /* let bad current context imply bad current surface */
    if (_eglGetContextHandle(ctx) == EGL_NO_CONTEXT ||
@@ -1725,9 +1731,9 @@ eglReleaseThread(void)
    if (ctx) {
       _EGLDisplay *disp = ctx->Resource.Display;
 
-      simple_mtx_lock(&disp->Mutex);
+      egl_lock(disp);
       (void) disp->Driver->MakeCurrent(disp, NULL, NULL, NULL);
-      simple_mtx_unlock(&disp->Mutex);
+      egl_unlock(disp);
    }
 
    _eglDestroyCurrentThread();
diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index ddbcbf0061dd..9d49ec55dadb 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -279,6 +279,7 @@ _eglFindDisplay(_EGLPlatformType plat, void *plat_dpy,
       goto out;
 
    simple_mtx_init(&disp->Mutex, mtx_plain);
+   u_rwlock_init(&disp->TerminateLock);
    disp->Platform = plat;
    disp->PlatformDisplay = plat_dpy;
    num_attribs = _eglNumAttribs(attrib_list);
diff --git a/src/egl/main/egldisplay.h b/src/egl/main/egldisplay.h
index cf7cfb1a82bd..2b9609b20e93 100644
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -32,6 +32,7 @@
 #define EGLDISPLAY_INCLUDED
 
 #include "util/simple_mtx.h"
+#include "util/rwlock.h"
 
 #include "egltypedefs.h"
 #include "egldefines.h"
@@ -159,8 +160,34 @@ struct _egl_display
    /* used to link displays */
    _EGLDisplay *Next;
 
+   /**
+    * The big-display-lock (BDL) which protects our internal state.  EGL
+    * drivers should use their own locking, as needed, to protect their
+    * own state, rather than relying on this.
+    */
    simple_mtx_t Mutex;
 
+   /**
+    * The spec appears to allow eglTerminate() to race with more or less
+    * any other egl call.  To allow for this, while relaxing the BDL to
+    * allow other egl calls to happen in parallel, a rwlock is used.  All
+    * points where the BDL lock is acquired also acquire TerminateLock
+    * for reading, while eglTerminate() itself acquires the TerminateLock
+    * for writing.
+    *
+    * Note, we could conceivable just replace the BDL with as single
+    * rwlock.  But there are a couple shortcomings of u_rwlock:
+    *
+    *   1) The WIN32 implementation does not allow promoting a read-
+    *      lock to write-lock, nor recursive locking, whereas the
+    *      pthread based implementation does.  Because of this, it
+    *      would be difficult to keep the eglapi layer portable if
+    *      we depended on any less-than-trivial rwlock usage.
+    *
+    *   2) We'd lose simple_mtx_assert_locked().
+    */
+   struct u_rwlock TerminateLock;
+
    _EGLPlatformType Platform; /**< The type of the platform display */
    void *PlatformDisplay;     /**< A pointer to the platform display */
 
@@ -198,6 +225,19 @@ struct _egl_display
    EGLGetBlobFuncANDROID BlobCacheGet;
 };
 
+static inline void
+egl_lock(_EGLDisplay *disp)
+{
+   u_rwlock_rdlock(&disp->TerminateLock);
+   simple_mtx_lock(&disp->Mutex);
+}
+
+static inline void
+egl_unlock(_EGLDisplay *disp)
+{
+   simple_mtx_unlock(&disp->Mutex);
+   u_rwlock_rdunlock(&disp->TerminateLock);
+}
 
 extern _EGLPlatformType
 _eglGetNativePlatform(void *nativeDisplay);
-- 
GitLab


From 41740e82f8caf2181256ec2e70ee6d0c82dcfbc9 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 11 Aug 2022 10:52:59 -0700
Subject: [PATCH 6/6] egl: Relax locking

Now that we have the rwlock TerminateLock protecting us against
eglTerminate() yanking the rug from under us, drop the BDL across
calls to driver (or at least the main ones that can potentially
block).

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/7039
Signed-off-by: Rob Clark <robdclark@chromium.org>
Acked-by: Eric Engestrom <eric@igalia.com>
---
 src/egl/drivers/dri2/platform_android.c |   8 -
 src/egl/main/eglapi.c                   | 202 +++++++++++++++++-------
 2 files changed, 145 insertions(+), 65 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index ffd75ced0a3f..af7b3291f8b2 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -540,12 +540,6 @@ droid_window_enqueue_buffer(_EGLDisplay *disp, struct dri2_egl_surface *dri2_sur
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   /* To avoid blocking other EGL calls, release the display mutex before
-    * we enter droid_window_enqueue_buffer() and re-acquire the mutex upon
-    * return.
-    */
-   simple_mtx_unlock(&disp->Mutex);
-
    /* Queue the buffer with stored out fence fd. The ANativeWindow or buffer
     * consumer may choose to wait for the fence to signal before accessing
     * it. If fence fd value is -1, buffer can be accessed by consumer
@@ -563,8 +557,6 @@ droid_window_enqueue_buffer(_EGLDisplay *disp, struct dri2_egl_surface *dri2_sur
    dri2_surf->buffer = NULL;
    dri2_surf->back = NULL;
 
-   simple_mtx_lock(&disp->Mutex);
-
    if (dri2_surf->dri_image_back) {
       dri2_dpy->image->destroyImage(dri2_surf->dri_image_back);
       dri2_surf->dri_image_back = NULL;
diff --git a/src/egl/main/eglapi.c b/src/egl/main/eglapi.c
index 595841b5f27b..34998edbfce8 100644
--- a/src/egl/main/eglapi.c
+++ b/src/egl/main/eglapi.c
@@ -165,6 +165,36 @@
 #define _EGL_CHECK_SYNC(disp, s, ret) \
    _EGL_CHECK_OBJECT(disp, Sync, s, ret)
 
+static _EGLResource **
+_egl_relax_begin(_EGLDisplay *disp, _EGLResource **rs, unsigned rs_count)
+{
+   for (unsigned i = 0; i < rs_count; i++)
+      if (rs[i])
+         _eglGetResource(rs[i]);
+   simple_mtx_unlock(&disp->Mutex);
+   return rs;
+}
+
+static _EGLResource **
+_egl_relax_end(_EGLDisplay *disp, _EGLResource **rs, unsigned rs_count)
+{
+   simple_mtx_lock(&disp->Mutex);
+   for (unsigned i = 0; i < rs_count; i++)
+      if (rs[i])
+         _eglPutResource(rs[i]);
+   return NULL;
+}
+
+/**
+ * Helper to relax (drop) the EGL BDL over it's body, optionally holding
+ * a reference to a list of _EGLResource's until the lock is re-aquired,
+ * protecting the resources from destruction while the BDL is dropped.
+ */
+#define egl_relax(disp, ...) \
+   for (_EGLResource *__rs[] = {__VA_ARGS__}, \
+         **__rsp = _egl_relax_begin(disp, __rs, ARRAY_SIZE(__rs)); \
+         __rsp; \
+         __rsp = _egl_relax_end(disp, __rs, ARRAY_SIZE(__rs)))
 
 extern const _EGLDriver _eglDriver;
 
@@ -860,7 +890,7 @@ eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read,
    _EGLContext *context = _eglLookupContext(ctx, disp);
    _EGLSurface *draw_surf = _eglLookupSurface(draw, disp);
    _EGLSurface *read_surf = _eglLookupSurface(read, disp);
-   EGLBoolean ret;
+   EGLBoolean ret = EGL_FALSE;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_CONTEXT_KHR, context);
 
@@ -910,7 +940,9 @@ eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read,
        draw_surf && !draw_surf->ProtectedContent)
       RETURN_EGL_ERROR(disp, EGL_BAD_ACCESS, EGL_FALSE);
 
-   ret = disp->Driver->MakeCurrent(disp, draw_surf, read_surf, context);
+   egl_relax (disp, &draw_surf->Resource, &read_surf->Resource, &context->Resource) {
+      ret = disp->Driver->MakeCurrent(disp, draw_surf, read_surf, context);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -999,7 +1031,9 @@ _eglCreateWindowSurfaceCommon(_EGLDisplay *disp, EGLConfig config,
    if (_eglNativeSurfaceAlreadyUsed(disp, native_window))
       RETURN_EGL_ERROR(disp, EGL_BAD_ALLOC, EGL_NO_SURFACE);
 
-   surf = disp->Driver->CreateWindowSurface(disp, conf, native_window, attrib_list);
+   egl_relax (disp) {
+      surf = disp->Driver->CreateWindowSurface(disp, conf, native_window, attrib_list);
+   }
    ret = (surf) ? _eglLinkSurface(surf) : EGL_NO_SURFACE;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1142,7 +1176,9 @@ _eglCreatePixmapSurfaceCommon(_EGLDisplay *disp, EGLConfig config,
    if (_eglNativeSurfaceAlreadyUsed(disp, native_pixmap))
       RETURN_EGL_ERROR(disp, EGL_BAD_ALLOC, EGL_NO_SURFACE);
 
-   surf = disp->Driver->CreatePixmapSurface(disp, conf, native_pixmap, attrib_list);
+   egl_relax (disp) {
+      surf = disp->Driver->CreatePixmapSurface(disp, conf, native_pixmap, attrib_list);
+   }
    ret = (surf) ? _eglLinkSurface(surf) : EGL_NO_SURFACE;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1213,7 +1249,9 @@ eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config,
    if ((conf->SurfaceType & EGL_PBUFFER_BIT) == 0)
       RETURN_EGL_ERROR(disp, EGL_BAD_MATCH, EGL_NO_SURFACE);
 
-   surf = disp->Driver->CreatePbufferSurface(disp, conf, attrib_list);
+   egl_relax (disp) {
+      surf = disp->Driver->CreatePbufferSurface(disp, conf, attrib_list);
+   }
    ret = (surf) ? _eglLinkSurface(surf) : EGL_NO_SURFACE;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1230,7 +1268,9 @@ eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
    _eglUnlinkSurface(surf);
-   ret = disp->Driver->DestroySurface(disp, surf);
+   egl_relax (disp) {
+      ret = disp->Driver->DestroySurface(disp, surf);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1280,7 +1320,10 @@ eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
-   ret = disp->Driver->BindTexImage(disp, surf, buffer);
+
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->BindTexImage(disp, surf, buffer);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1295,7 +1338,10 @@ eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
-   ret = disp->Driver->ReleaseTexImage(disp, surf, buffer);
+
+   egl_relax (disp) {
+      ret = disp->Driver->ReleaseTexImage(disp, surf, buffer);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1307,7 +1353,7 @@ eglSwapInterval(EGLDisplay dpy, EGLint interval)
    _EGLDisplay *disp = _eglLockDisplay(dpy);
    _EGLContext *ctx = _eglGetCurrentContext();
    _EGLSurface *surf = ctx ? ctx->DrawSurface : NULL;
-   EGLBoolean ret;
+   EGLBoolean ret = EGL_FALSE;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_DISPLAY(disp, EGL_FALSE);
@@ -1326,10 +1372,13 @@ eglSwapInterval(EGLDisplay dpy, EGLint interval)
                     surf->Config->MinSwapInterval,
                     surf->Config->MaxSwapInterval);
 
-   if (surf->SwapInterval != interval && disp->Driver->SwapInterval)
-      ret = disp->Driver->SwapInterval(disp, surf, interval);
-   else
+   if (surf->SwapInterval != interval && disp->Driver->SwapInterval) {
+      egl_relax (disp, &surf->Resource) {
+         ret = disp->Driver->SwapInterval(disp, surf, interval);
+      }
+   } else {
       ret = EGL_TRUE;
+   }
 
    if (ret)
       surf->SwapInterval = interval;
@@ -1344,7 +1393,7 @@ eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
    _EGLContext *ctx = _eglGetCurrentContext();
    _EGLDisplay *disp = _eglLockDisplay(dpy);
    _EGLSurface *surf = _eglLookupSurface(surface, disp);
-   EGLBoolean ret;
+   EGLBoolean ret = EGL_FALSE;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
@@ -1368,7 +1417,9 @@ eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
    if (surf->Lost)
       RETURN_EGL_ERROR(disp, EGL_BAD_NATIVE_WINDOW, EGL_FALSE);
 
-   ret = disp->Driver->SwapBuffers(disp, surf);
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->SwapBuffers(disp, surf);
+   }
 
    /* EGL_KHR_partial_update
     * Frame boundary successfully reached,
@@ -1388,7 +1439,7 @@ _eglSwapBuffersWithDamageCommon(_EGLDisplay *disp, _EGLSurface *surf,
                                 const EGLint *rects, EGLint n_rects)
 {
    _EGLContext *ctx = _eglGetCurrentContext();
-   EGLBoolean ret;
+   EGLBoolean ret = EGL_FALSE;
 
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
 
@@ -1403,7 +1454,9 @@ _eglSwapBuffersWithDamageCommon(_EGLDisplay *disp, _EGLSurface *surf,
    if ((n_rects > 0 && rects == NULL) || n_rects < 0)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->SwapBuffersWithDamageEXT(disp, surf, rects, n_rects);
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->SwapBuffersWithDamageEXT(disp, surf, rects, n_rects);
+   }
 
    /* EGL_KHR_partial_update
     * Frame boundary successfully reached,
@@ -1512,7 +1565,10 @@ eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
    if (surf->ProtectedContent)
       RETURN_EGL_ERROR(disp, EGL_BAD_ACCESS, EGL_FALSE);
-   ret = disp->Driver->CopyBuffers(disp, surf, native_pixmap_ptr);
+
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->CopyBuffers(disp, surf, native_pixmap_ptr);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1538,7 +1594,10 @@ _eglWaitClientCommon(void)
 
    /* a valid current context implies an initialized current display */
    assert(disp->Initialized);
-   ret = disp->Driver->WaitClient(disp, ctx);
+
+   egl_relax (disp, &ctx->Resource) {
+      ret = disp->Driver->WaitClient(disp, ctx);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1581,7 +1640,10 @@ eglWaitNative(EGLint engine)
 
    /* a valid current context implies an initialized current display */
    assert(disp->Initialized);
-   ret = disp->Driver->WaitNative(engine);
+
+   egl_relax (disp) {
+      ret = disp->Driver->WaitNative(engine);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1731,9 +1793,9 @@ eglReleaseThread(void)
    if (ctx) {
       _EGLDisplay *disp = ctx->Resource.Display;
 
-      egl_lock(disp);
+      u_rwlock_rdlock(&disp->TerminateLock);
       (void) disp->Driver->MakeCurrent(disp, NULL, NULL, NULL);
-      egl_unlock(disp);
+      u_rwlock_rdunlock(&disp->TerminateLock);
    }
 
    _eglDestroyCurrentThread();
@@ -1761,7 +1823,10 @@ _eglCreateImageCommon(_EGLDisplay *disp, EGLContext ctx, EGLenum target,
    if (ctx != EGL_NO_CONTEXT && target == EGL_LINUX_DMA_BUF_EXT)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);
 
-   img = disp->Driver->CreateImageKHR(disp, context, target, buffer, attr_list);
+   egl_relax (disp, &context->Resource) {
+      img = disp->Driver->CreateImageKHR(disp, context, target, buffer, attr_list);
+   }
+
    ret = (img) ? _eglLinkImage(img) : EGL_NO_IMAGE_KHR;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1889,7 +1954,10 @@ _eglCreateSync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list,
       RETURN_EGL_ERROR(disp, invalid_type_error, EGL_NO_SYNC_KHR);
    }
 
-   sync = disp->Driver->CreateSyncKHR(disp, type, attrib_list);
+   egl_relax (disp) {
+      sync = disp->Driver->CreateSyncKHR(disp, type, attrib_list);
+   }
+
    ret = (sync) ? _eglLinkSync(sync) : EGL_NO_SYNC_KHR;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1956,7 +2024,10 @@ _eglDestroySync(_EGLDisplay *disp, _EGLSync *s)
           disp->Extensions.ANDROID_native_fence_sync);
 
    _eglUnlinkSync(s);
-   ret = disp->Driver->DestroySyncKHR(disp, s);
+
+   egl_relax (disp) {
+      ret = disp->Driver->DestroySyncKHR(disp, s);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -1994,24 +2065,11 @@ _eglClientWaitSyncCommon(_EGLDisplay *disp, _EGLSync *s,
    if (s->SyncStatus == EGL_SIGNALED_KHR)
       RETURN_EGL_EVAL(disp, EGL_CONDITION_SATISFIED_KHR);
 
-   /* if sync type is EGL_SYNC_REUSABLE_KHR, dpy should be
-    * unlocked here to allow other threads also to be able to
-    * go into waiting state.
-    */
-
-   if (s->Type == EGL_SYNC_REUSABLE_KHR)
-      _eglUnlockDisplay(disp);
-
-   ret = disp->Driver->ClientWaitSyncKHR(disp, s, flags, timeout);
+   egl_relax (disp, &s->Resource) {
+      ret = disp->Driver->ClientWaitSyncKHR(disp, s, flags, timeout);
+   }
 
-   /*
-    * 'disp' is already unlocked for reusable sync type,
-    * so passing 'NULL' to bypass unlocking display.
-    */
-   if (s->Type == EGL_SYNC_REUSABLE_KHR)
-      RETURN_EGL_EVAL(NULL, ret);
-   else
-      RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(disp, ret);
 }
 
 EGLint EGLAPIENTRY
@@ -2051,7 +2109,9 @@ _eglWaitSyncCommon(_EGLDisplay *disp, _EGLSync *s, EGLint flags)
    if (flags != 0)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->WaitSyncKHR(disp, s);
+   egl_relax (disp, &s->Resource) {
+      ret = disp->Driver->WaitSyncKHR(disp, s);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2091,7 +2151,10 @@ eglSignalSyncKHR(EGLDisplay dpy, EGLSync sync, EGLenum mode)
 
    _EGL_CHECK_SYNC(disp, s, EGL_FALSE);
    assert(disp->Extensions.KHR_reusable_sync);
-   ret = disp->Driver->SignalSyncKHR(disp, s, mode);
+
+   egl_relax (disp, &s->Resource) {
+      ret = disp->Driver->SignalSyncKHR(disp, s, mode);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2171,7 +2234,10 @@ eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSync sync)
 
    _EGL_CHECK_SYNC(disp, s, EGL_NO_NATIVE_FENCE_FD_ANDROID);
    assert(disp->Extensions.ANDROID_native_fence_sync);
-   ret = disp->Driver->DupNativeFenceFDANDROID(disp, s);
+
+   egl_relax (disp, &s->Resource) {
+      ret = disp->Driver->DupNativeFenceFDANDROID(disp, s);
+   }
 
    RETURN_EGL_SUCCESS(disp, ret);
 }
@@ -2183,7 +2249,7 @@ eglSwapBuffersRegionNOK(EGLDisplay dpy, EGLSurface surface,
    _EGLContext *ctx = _eglGetCurrentContext();
    _EGLDisplay *disp = _eglLockDisplay(dpy);
    _EGLSurface *surf = _eglLookupSurface(surface, disp);
-   EGLBoolean ret;
+   EGLBoolean ret = EGL_FALSE;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
 
@@ -2197,7 +2263,9 @@ eglSwapBuffersRegionNOK(EGLDisplay dpy, EGLSurface surface,
        surf != ctx->DrawSurface)
       RETURN_EGL_ERROR(disp, EGL_BAD_SURFACE, EGL_FALSE);
 
-   ret = disp->Driver->SwapBuffersRegionNOK(disp, surf, numRects, rects);
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->SwapBuffersRegionNOK(disp, surf, numRects, rects);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2238,7 +2306,9 @@ eglExportDRMImageMESA(EGLDisplay dpy, EGLImage image,
    if (!img)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->ExportDRMImageMESA(disp, img, name, handle, stride);
+   egl_relax (disp, &img->Resource) {
+      ret = disp->Driver->ExportDRMImageMESA(disp, img, name, handle, stride);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2260,7 +2330,9 @@ eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
    if (!display)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->BindWaylandDisplayWL(disp, display);
+   egl_relax (disp) {
+      ret = disp->Driver->BindWaylandDisplayWL(disp, display);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2279,7 +2351,9 @@ eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
    if (!display)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->UnbindWaylandDisplayWL(disp, display);
+   egl_relax (disp) {
+      ret = disp->Driver->UnbindWaylandDisplayWL(disp, display);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2299,7 +2373,9 @@ eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *buffer,
    if (!buffer)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->QueryWaylandBufferWL(disp, buffer, attribute, value);
+   egl_relax (disp) {
+      ret = disp->Driver->QueryWaylandBufferWL(disp, buffer, attribute, value);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2343,7 +2419,9 @@ eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface,
    if (!disp->Extensions.NV_post_sub_buffer)
       RETURN_EGL_EVAL(disp, EGL_FALSE);
 
-   ret = disp->Driver->PostSubBufferNV(disp, surf, x, y, width, height);
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->PostSubBufferNV(disp, surf, x, y, width, height);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2366,7 +2444,9 @@ eglGetSyncValuesCHROMIUM(EGLDisplay dpy, EGLSurface surface,
    if (!ust || !msc || !sbc)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->GetSyncValuesCHROMIUM(disp, surf, ust, msc, sbc);
+   egl_relax (disp, &surf->Resource) {
+      ret = disp->Driver->GetSyncValuesCHROMIUM(disp, surf, ust, msc, sbc);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2410,7 +2490,9 @@ eglExportDMABUFImageQueryMESA(EGLDisplay dpy, EGLImage image,
    if (!img)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->ExportDMABUFImageQueryMESA(disp, img, fourcc, nplanes, modifiers);
+   egl_relax (disp, &img->Resource) {
+      ret = disp->Driver->ExportDMABUFImageQueryMESA(disp, img, fourcc, nplanes, modifiers);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2431,7 +2513,9 @@ eglExportDMABUFImageMESA(EGLDisplay dpy, EGLImage image,
    if (!img)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
-   ret = disp->Driver->ExportDMABUFImageMESA(disp, img, fds, strides, offsets);
+   egl_relax (disp, &img->Resource) {
+      ret = disp->Driver->ExportDMABUFImageMESA(disp, img, fds, strides, offsets);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2590,7 +2674,9 @@ eglQueryDmaBufFormatsEXT(EGLDisplay dpy, EGLint max_formats,
 
    _EGL_CHECK_DISPLAY(disp, EGL_FALSE);
 
-   ret = disp->Driver->QueryDmaBufFormatsEXT(disp, max_formats, formats, num_formats);
+   egl_relax (disp) {
+      ret = disp->Driver->QueryDmaBufFormatsEXT(disp, max_formats, formats, num_formats);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
@@ -2607,8 +2693,10 @@ eglQueryDmaBufModifiersEXT(EGLDisplay dpy, EGLint format, EGLint max_modifiers,
 
    _EGL_CHECK_DISPLAY(disp, EGL_FALSE);
 
-   ret = disp->Driver->QueryDmaBufModifiersEXT(disp, format, max_modifiers, modifiers,
-                                      external_only, num_modifiers);
+   egl_relax (disp) {
+      ret = disp->Driver->QueryDmaBufModifiersEXT(disp, format, max_modifiers, modifiers,
+                                                  external_only, num_modifiers);
+   }
 
    RETURN_EGL_EVAL(disp, ret);
 }
-- 
GitLab

