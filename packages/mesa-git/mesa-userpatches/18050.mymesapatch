From c76c6f6563fcf3b97da1a5fb3e79e1fa7d8c616f Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 11 Aug 2022 09:32:29 -0700
Subject: [PATCH 1/5] egl/wgl: Make ref_count atomic

Looks like wgl doesn't have much display state to protect.  But it's
ref_count should be atomic before we start removing locking from eglapi
to protect against MakeCurrent being called in parallel on multiple
threads.

Signed-off-by: Rob Clark <robdclark@chromium.org>
---
 src/egl/drivers/wgl/egl_wgl.c | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 7ec1fcf79b7c..0d8b627e94be 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -318,7 +318,7 @@ wgl_initialize(_EGLDisplay *disp)
     * to free it up correctly.
     */
    if (wgl_dpy) {
-      wgl_dpy->ref_count++;
+      p_atomic_inc(&wgl_dpy->ref_count);
       return EGL_TRUE;
    }
 
@@ -338,7 +338,7 @@ wgl_initialize(_EGLDisplay *disp)
       return EGL_FALSE;
 
    wgl_dpy = wgl_egl_display(disp);
-   wgl_dpy->ref_count++;
+   p_atomic_inc(&wgl_dpy->ref_count);
 
    return EGL_TRUE;
 }
@@ -357,9 +357,7 @@ wgl_display_release(_EGLDisplay *disp)
    wgl_dpy = wgl_egl_display(disp);
 
    assert(wgl_dpy->ref_count > 0);
-   wgl_dpy->ref_count--;
-
-   if (wgl_dpy->ref_count > 0)
+   if (!p_atomic_dec_zero(&wgl_dpy->ref_count))
       return;
 
    _eglCleanupDisplay(disp);
@@ -643,7 +641,7 @@ wgl_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
           * EGLDisplay is terminated and then initialized again while a
           * context is still bound. See wgl_intitialize() for a more in depth
           * explanation. */
-         wgl_dpy->ref_count++;
+         p_atomic_inc(&wgl_dpy->ref_count);
       }
    }
 
-- 
GitLab


From 9193234e48107b53ed0551d32ce0fc93ad9781bd Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 11 Aug 2022 13:02:29 -0700
Subject: [PATCH 2/5] egl/dri2: Make ref_count atomic

In particular, MakeCurrent can be called on multiple threads in
parallel.

Signed-off-by: Rob Clark <robdclark@chromium.org>
Reviewed-by: Eric Engestrom <eric@igalia.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 5d4aeec2d957..d0f6d590eee2 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1162,7 +1162,7 @@ dri2_initialize(_EGLDisplay *disp)
     * to free it up correctly.
     */
    if (dri2_dpy) {
-      dri2_dpy->ref_count++;
+      p_atomic_inc(&dri2_dpy->ref_count);
       return EGL_TRUE;
    }
 
@@ -1197,7 +1197,7 @@ dri2_initialize(_EGLDisplay *disp)
       return EGL_FALSE;
 
    dri2_dpy = dri2_egl_display(disp);
-   dri2_dpy->ref_count++;
+   p_atomic_inc(&dri2_dpy->ref_count);
 
    return EGL_TRUE;
 }
@@ -1216,9 +1216,8 @@ dri2_display_release(_EGLDisplay *disp)
    dri2_dpy = dri2_egl_display(disp);
 
    assert(dri2_dpy->ref_count > 0);
-   dri2_dpy->ref_count--;
 
-   if (dri2_dpy->ref_count > 0)
+   if (!p_atomic_dec_zero(&dri2_dpy->ref_count))
       return;
 
    _eglCleanupDisplay(disp);
@@ -1878,7 +1877,7 @@ dri2_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
           * EGLDisplay is terminated and then initialized again while a
           * context is still bound. See dri2_intitialize() for a more in depth
           * explanation. */
-         dri2_dpy->ref_count++;
+         p_atomic_inc(&dri2_dpy->ref_count);
       }
    }
 
-- 
GitLab


From 4211ce8c342d03043c6ecb41b270ac4e54726bfb Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Sat, 13 Aug 2022 10:41:46 -0700
Subject: [PATCH 3/5] egl/dri2: Add display lock

In preperation of relaxing eglapi to not hold a lock across driver
calls, but instead only for protecting it's own state, add our own
lock to protect code paths that need locking or have not been audited
yet.  The blocking calls (ClientWaitSyncKHR) or critical path and/or
blocking (MakeCurrent, SwapBuffers*) are lockless, as they have already
been audited for thread safety.

Signed-off-by: Rob Clark <robdclark@chromium.org>
Acked-by: Eric Engestrom <eric@igalia.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 242 ++++++++++++++++++++++----------
 src/egl/drivers/dri2/egl_dri2.h |  20 +++
 2 files changed, 191 insertions(+), 71 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index d0f6d590eee2..ce25cf8a9d3d 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -873,13 +873,19 @@ dri2_query_driver_name(_EGLDisplay *disp)
 static char *
 dri2_query_driver_config(_EGLDisplay *disp)
 {
-    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+    struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
     const __DRIconfigOptionsExtension *ext = dri2_dpy->configOptions;
+    char *ret;
+
+    if (ext->base.version >= 2) {
+        ret = ext->getXml(dri2_dpy->driver_name);
+    } else {
+       ret = strdup(ext->xml);
+    }
 
-    if (ext->base.version >= 2)
-        return ext->getXml(dri2_dpy->driver_name);
+    mtx_unlock(&dri2_dpy->lock);
 
-    return strdup(ext->xml);
+    return ret;
 }
 
 
@@ -1199,6 +1205,8 @@ dri2_initialize(_EGLDisplay *disp)
    dri2_dpy = dri2_egl_display(disp);
    p_atomic_inc(&dri2_dpy->ref_count);
 
+   mtx_init(&dri2_dpy->lock, mtx_plain);
+
    return EGL_TRUE;
 }
 
@@ -1483,7 +1491,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
                     _EGLContext *share_list, const EGLint *attrib_list)
 {
    struct dri2_egl_context *dri2_ctx;
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx_shared = dri2_egl_context(share_list);
    __DRIcontext *shared =
       dri2_ctx_shared ? dri2_ctx_shared->dri_context : NULL;
@@ -1496,7 +1504,7 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
 
    dri2_ctx = malloc(sizeof *dri2_ctx);
    if (!dri2_ctx) {
-      _eglError(EGL_BAD_ALLOC, "eglCreateContext");
+      dri2_egl_error_unlock(dri2_dpy, EGL_BAD_ALLOC, "eglCreateContext");
       return NULL;
    }
 
@@ -1639,9 +1647,12 @@ dri2_create_context(_EGLDisplay *disp, _EGLConfig *conf,
    if (!dri2_ctx->dri_context)
       goto cleanup;
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return &dri2_ctx->base;
 
  cleanup:
+   mtx_unlock(&dri2_dpy->lock);
    free(dri2_ctx);
    return NULL;
 }
@@ -1707,11 +1718,12 @@ static EGLBoolean
 dri2_destroy_surface(_EGLDisplay *disp, _EGLSurface *surf)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   EGLBoolean ret = EGL_TRUE;
 
-   if (!_eglPutSurface(surf))
-      return EGL_TRUE;
+   if (_eglPutSurface(surf))
+      ret = dri2_dpy->vtbl->destroy_surface(disp, surf);
 
-   return dri2_dpy->vtbl->destroy_surface(disp, surf);
+   return ret;
 }
 
 static void
@@ -1928,39 +1940,57 @@ static _EGLSurface*
 dri2_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            void *native_window, const EGLint *attrib_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   return dri2_dpy->vtbl->create_window_surface(disp, conf, native_window,
-                                                attrib_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLSurface *ret =
+         dri2_dpy->vtbl->create_window_surface(disp, conf, native_window,
+                                               attrib_list);
+   mtx_unlock(&dri2_dpy->lock);
+   return ret;
 }
 
 static _EGLSurface*
 dri2_create_pixmap_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            void *native_pixmap, const EGLint *attrib_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->create_pixmap_surface)
-      return NULL;
-   return dri2_dpy->vtbl->create_pixmap_surface(disp, conf, native_pixmap,
-                                                attrib_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLSurface *ret = NULL;
+
+   if (dri2_dpy->vtbl->create_pixmap_surface)
+      ret = dri2_dpy->vtbl->create_pixmap_surface(disp, conf, native_pixmap,
+                                                  attrib_list);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static _EGLSurface*
 dri2_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
                             const EGLint *attrib_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->create_pbuffer_surface)
-      return NULL;
-   return dri2_dpy->vtbl->create_pbuffer_surface(disp, conf, attrib_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLSurface *ret = NULL;
+
+   if (dri2_dpy->vtbl->create_pbuffer_surface)
+      ret = dri2_dpy->vtbl->create_pbuffer_surface(disp, conf, attrib_list);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static EGLBoolean
 dri2_swap_interval(_EGLDisplay *disp, _EGLSurface *surf, EGLint interval)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->swap_interval)
-      return EGL_TRUE;
-   return dri2_dpy->vtbl->swap_interval(disp, surf, interval);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   EGLBoolean ret = EGL_TRUE;
+
+   if (dri2_dpy->vtbl->swap_interval)
+      ret = dri2_dpy->vtbl->swap_interval(disp, surf, interval);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 /**
@@ -2074,13 +2104,16 @@ static EGLBoolean
 dri2_set_damage_region(_EGLDisplay *disp, _EGLSurface *surf,
                        EGLint *rects, EGLint n_rects)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    __DRIdrawable *drawable = dri2_dpy->vtbl->get_dri_drawable(surf);
 
-   if (!dri2_dpy->buffer_damage || !dri2_dpy->buffer_damage->set_damage_region)
+   if (!dri2_dpy->buffer_damage || !dri2_dpy->buffer_damage->set_damage_region) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    dri2_dpy->buffer_damage->set_damage_region(drawable, n_rects, rects);
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_TRUE;
 }
 
@@ -2088,19 +2121,26 @@ static EGLBoolean
 dri2_post_sub_buffer(_EGLDisplay *disp, _EGLSurface *surf,
                      EGLint x, EGLint y, EGLint width, EGLint height)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->post_sub_buffer)
-      return EGL_FALSE;
-   return dri2_dpy->vtbl->post_sub_buffer(disp, surf, x, y, width, height);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   EGLBoolean ret = EGL_FALSE;
+
+   if (dri2_dpy->vtbl->post_sub_buffer)
+      ret = dri2_dpy->vtbl->post_sub_buffer(disp, surf, x, y, width, height);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static EGLBoolean
 dri2_copy_buffers(_EGLDisplay *disp, _EGLSurface *surf, void *native_pixmap_target)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    if (!dri2_dpy->vtbl->copy_buffers)
-      return _eglError(EGL_BAD_NATIVE_PIXMAP, "no support for native pixmaps");
-   return dri2_dpy->vtbl->copy_buffers(disp, surf, native_pixmap_target);
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_NATIVE_PIXMAP, "no support for native pixmaps");
+   EGLBoolean ret = dri2_dpy->vtbl->copy_buffers(disp, surf, native_pixmap_target);
+   mtx_unlock(&dri2_dpy->lock);
+   return ret;
 }
 
 static EGLint
@@ -2141,7 +2181,7 @@ dri2_wait_native(EGLint engine)
 static EGLBoolean
 dri2_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx;
    _EGLContext *ctx;
    GLint format, target;
@@ -2150,8 +2190,10 @@ dri2_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
    ctx = _eglGetCurrentContext();
    dri2_ctx = dri2_egl_context(ctx);
 
-   if (!_eglBindTexImage(disp, surf, buffer))
+   if (!_eglBindTexImage(disp, surf, buffer)) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    switch (surf->TextureFormat) {
    case EGL_TEXTURE_RGB:
@@ -2178,13 +2220,15 @@ dri2_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
                                        target, format,
                                        dri_drawable);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
 static EGLBoolean
 dri2_release_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx;
    _EGLContext *ctx;
    GLint  target;
@@ -2193,8 +2237,10 @@ dri2_release_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
    ctx = _eglGetCurrentContext();
    dri2_ctx = dri2_egl_context(ctx);
 
-   if (!_eglReleaseTexImage(disp, surf, buffer))
+   if (!_eglReleaseTexImage(disp, surf, buffer)) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    switch (surf->TextureTarget) {
    case EGL_TEXTURE_2D:
@@ -2210,6 +2256,8 @@ dri2_release_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
                                              target, dri_drawable);
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -2217,9 +2265,11 @@ static _EGLImage*
 dri2_create_image(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
                   EGLClientBuffer buffer, const EGLint *attr_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   return dri2_dpy->vtbl->create_image(disp, ctx, target, buffer,
-                                       attr_list);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   _EGLImage *ret = dri2_dpy->vtbl->create_image(disp, ctx, target, buffer,
+                                                 attr_list);
+   mtx_unlock(&dri2_dpy->lock);
+   return ret;
 }
 
 _EGLImage *
@@ -2379,9 +2429,14 @@ dri2_get_sync_values_chromium(_EGLDisplay *disp, _EGLSurface *surf,
                               EGLuint64KHR *sbc)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->get_sync_values)
-      return EGL_FALSE;
-   return dri2_dpy->vtbl->get_sync_values(disp, surf, ust, msc, sbc);
+   EGLBoolean ret = EGL_FALSE;
+
+   if (dri2_dpy->vtbl->get_sync_values)
+      ret = dri2_dpy->vtbl->get_sync_values(disp, surf, ust, msc, sbc);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static EGLBoolean
@@ -2497,18 +2552,31 @@ dri2_query_surface(_EGLDisplay *disp, _EGLSurface *surf,
                    EGLint attribute, EGLint *value)
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->query_surface)
-      return _eglQuerySurface(disp, surf, attribute, value);
-   return dri2_dpy->vtbl->query_surface(disp, surf, attribute, value);
+   EGLBoolean ret;
+
+   if (!dri2_dpy->vtbl->query_surface) {
+      ret = _eglQuerySurface(disp, surf, attribute, value);
+   } else {
+      ret = dri2_dpy->vtbl->query_surface(disp, surf, attribute, value);
+   }
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 static struct wl_buffer*
 dri2_create_wayland_buffer_from_image(_EGLDisplay *disp, _EGLImage *img)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (!dri2_dpy->vtbl->create_wayland_buffer_from_image)
-      return NULL;
-   return dri2_dpy->vtbl->create_wayland_buffer_from_image(disp, img);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   struct wl_buffer *ret = NULL;
+
+   if (dri2_dpy->vtbl->create_wayland_buffer_from_image)
+      ret = dri2_dpy->vtbl->create_wayland_buffer_from_image(disp, img);
+
+   mtx_unlock(&dri2_dpy->lock);
+
+   return ret;
 }
 
 #ifdef HAVE_LIBDRM
@@ -2783,9 +2851,11 @@ static EGLBoolean
 dri2_query_dma_buf_formats(_EGLDisplay *disp, EGLint max,
                            EGLint *formats, EGLint *count)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   if (max < 0 || (max > 0 && formats == NULL))
-      return _eglError(EGL_BAD_PARAMETER, "invalid value for max count of formats");
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
+   if (max < 0 || (max > 0 && formats == NULL)) {
+      _eglError(EGL_BAD_PARAMETER, "invalid value for max count of formats");
+      goto fail;
+   }
 
    if (dri2_dpy->image->base.version < 15 ||
        dri2_dpy->image->queryDmaBufFormats == NULL)
@@ -2807,9 +2877,12 @@ dri2_query_dma_buf_formats(_EGLDisplay *disp, EGLint max,
       }
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 
 fail:
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_FALSE;
 }
 
@@ -2818,26 +2891,30 @@ dri2_query_dma_buf_modifiers(_EGLDisplay *disp, EGLint format,
                              EGLint max, EGLuint64KHR *modifiers,
                              EGLBoolean *external_only, EGLint *count)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
 
    if (dri2_num_fourcc_format_planes(format) == 0)
-      return _eglError(EGL_BAD_PARAMETER, "invalid fourcc format");
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid fourcc format");
 
    if (max < 0)
-      return _eglError(EGL_BAD_PARAMETER, "invalid value for max count of formats");
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid value for max count of formats");
 
    if (max > 0 && modifiers == NULL)
-      return _eglError(EGL_BAD_PARAMETER, "invalid modifiers array");
+      dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid modifiers array");
 
    if (dri2_dpy->image->base.version < 15 ||
-       dri2_dpy->image->queryDmaBufModifiers == NULL)
+       dri2_dpy->image->queryDmaBufModifiers == NULL) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    if (dri2_dpy->image->queryDmaBufModifiers(dri2_dpy->dri_screen, format,
                                              max, modifiers,
                                              (unsigned int *) external_only,
                                              count) == false)
-      return _eglError(EGL_BAD_PARAMETER, "invalid format");
+      return dri2_egl_error_unlock(dri2_dpy, EGL_BAD_PARAMETER, "invalid format");
+
+   mtx_unlock(&dri2_dpy->lock);
 
    return EGL_TRUE;
 }
@@ -2966,7 +3043,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
 static _EGLImage *
 dri2_create_drm_image_mesa(_EGLDisplay *disp, const EGLint *attr_list)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img;
    _EGLImageAttribs attrs;
    unsigned int dri_use, valid_mask;
@@ -3029,9 +3106,12 @@ dri2_create_drm_image_mesa(_EGLDisplay *disp, const EGLint *attr_list)
       goto fail;
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return &dri2_img->base;
 
 fail:
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_NO_IMAGE_KHR;
 }
 
@@ -3039,7 +3119,7 @@ static EGLBoolean
 dri2_export_drm_image_mesa(_EGLDisplay *disp, _EGLImage *img,
                           EGLint *name, EGLint *handle, EGLint *stride)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
 
    if (name && !dri2_dpy->image->queryImage(dri2_img->dri_image,
@@ -3054,6 +3134,8 @@ dri2_export_drm_image_mesa(_EGLDisplay *disp, _EGLImage *img,
       dri2_dpy->image->queryImage(dri2_img->dri_image,
                                   __DRI_IMAGE_ATTRIB_STRIDE, stride);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3084,12 +3166,14 @@ dri2_export_dma_buf_image_query_mesa(_EGLDisplay *disp, _EGLImage *img,
                                      EGLint *fourcc, EGLint *nplanes,
                                      EGLuint64KHR *modifiers)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
    int num_planes;
 
-   if (!dri2_can_export_dma_buf_image(disp, img))
+   if (!dri2_can_export_dma_buf_image(disp, img)) {
+      mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
+   }
 
    dri2_dpy->image->queryImage(dri2_img->dri_image,
                                __DRI_IMAGE_ATTRIB_NUM_PLANES, &num_planes);
@@ -3118,6 +3202,8 @@ dri2_export_dma_buf_image_query_mesa(_EGLDisplay *disp, _EGLImage *img,
         modifiers[i] = modifier;
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3125,7 +3211,7 @@ static EGLBoolean
 dri2_export_dma_buf_image_mesa(_EGLDisplay *disp, _EGLImage *img,
                                int *fds, EGLint *strides, EGLint *offsets)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
    EGLint nplanes;
 
@@ -3162,6 +3248,8 @@ dri2_export_dma_buf_image_mesa(_EGLDisplay *disp, _EGLImage *img,
          offsets[0] = 0;
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3202,12 +3290,14 @@ dri2_create_image_khr(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
 static EGLBoolean
 dri2_destroy_image_khr(_EGLDisplay *disp, _EGLImage *image)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(image);
 
    dri2_dpy->image->destroyImage(dri2_img->dri_image);
    free(dri2_img);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return EGL_TRUE;
 }
 
@@ -3269,7 +3359,7 @@ dri2_wl_release_buffer(void *user_data, struct wl_drm_buffer *buffer)
 static EGLBoolean
 dri2_bind_wayland_display_wl(_EGLDisplay *disp, struct wl_display *wl_dpy)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    const struct wayland_drm_callbacks wl_drm_callbacks = {
       .authenticate = (int(*)(void *, uint32_t)) dri2_dpy->vtbl->authenticate,
       .reference_buffer = dri2_wl_reference_buffer,
@@ -3311,9 +3401,11 @@ dri2_bind_wayland_display_wl(_EGLDisplay *disp, struct wl_display *wl_dpy)
       dri2_dpy->gbm_dri->wl_drm = dri2_dpy->wl_server_drm;
 #endif
 
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_TRUE;
 
 fail:
+   mtx_unlock(&dri2_dpy->lock);
    return EGL_FALSE;
 }
 
@@ -3394,7 +3486,7 @@ static _EGLSync *
 dri2_create_sync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
 {
    _EGLContext *ctx = _eglGetCurrentContext();
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_context *dri2_ctx = dri2_egl_context(ctx);
    struct dri2_egl_sync *dri2_sync;
    EGLint ret;
@@ -3480,17 +3572,20 @@ dri2_create_sync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
    }
 
    p_atomic_set(&dri2_sync->refcount, 1);
+   mtx_unlock(&dri2_dpy->lock);
+
    return &dri2_sync->base;
 
 fail:
    free(dri2_sync);
+   mtx_unlock(&dri2_dpy->lock);
    return NULL;
 }
 
 static EGLBoolean
 dri2_destroy_sync(_EGLDisplay *disp, _EGLSync *sync)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_sync *dri2_sync = dri2_egl_sync(sync);
    EGLint ret = EGL_TRUE;
    EGLint err;
@@ -3513,13 +3608,15 @@ dri2_destroy_sync(_EGLDisplay *disp, _EGLSync *sync)
 
    dri2_egl_unref_sync(dri2_dpy, dri2_sync);
 
+   mtx_unlock(&dri2_dpy->lock);
+
    return ret;
 }
 
 static EGLint
 dri2_dup_native_fence_fd(_EGLDisplay *disp, _EGLSync *sync)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_sync *dri2_sync = dri2_egl_sync(sync);
 
    assert(sync->Type == EGL_SYNC_NATIVE_FENCE_ANDROID);
@@ -3532,6 +3629,8 @@ dri2_dup_native_fence_fd(_EGLDisplay *disp, _EGLSync *sync)
                                                    dri2_sync->fence);
    }
 
+   mtx_unlock(&dri2_dpy->lock);
+
    if (sync->SyncFd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
       /* if native fence fd still not created, return an error: */
       _eglError(EGL_BAD_PARAMETER, "eglDupNativeFenceFDANDROID");
@@ -3548,10 +3647,11 @@ dri2_set_blob_cache_funcs(_EGLDisplay *disp,
                           EGLSetBlobFuncANDROID set,
                           EGLGetBlobFuncANDROID get)
 {
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    dri2_dpy->blob->set_cache_funcs(dri2_dpy->dri_screen,
                                    disp->BlobCacheSet,
                                    disp->BlobCacheGet);
+   mtx_unlock(&dri2_dpy->lock);
 }
 
 static EGLint
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index a3d848e0a281..2e283cba0e76 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -217,6 +217,8 @@ struct dri2_egl_display
 {
    const struct dri2_egl_display_vtbl *vtbl;
 
+   mtx_t lock;
+
    int dri2_major;
    int dri2_minor;
    __DRIscreen *dri_screen;
@@ -427,6 +429,24 @@ _EGL_DRIVER_STANDARD_TYPECASTS(dri2_egl)
 _EGL_DRIVER_TYPECAST(dri2_egl_image, _EGLImage, obj)
 _EGL_DRIVER_TYPECAST(dri2_egl_sync, _EGLSync, obj)
 
+static inline struct dri2_egl_display *
+dri2_egl_display_lock(_EGLDisplay *disp)
+{
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
+
+   if (dri2_dpy)
+      mtx_lock(&dri2_dpy->lock);
+
+   return dri2_dpy;
+}
+
+static inline EGLBoolean
+dri2_egl_error_unlock(struct dri2_egl_display *dri2_dpy, EGLint err, const char *msg)
+{
+   mtx_unlock(&dri2_dpy->lock);
+   return _eglError(err, msg);
+}
+
 extern const __DRIimageLookupExtension image_lookup_extension;
 extern const __DRIuseInvalidateExtension use_invalidate;
 extern const __DRIbackgroundCallableExtension background_callable_extension;
-- 
GitLab


From 315e875d4f2de343f28ea94943557ed884c02330 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 18 Aug 2022 10:59:50 -0700
Subject: [PATCH 4/5] egl: Make RefCount atomic

Once we relax the locking, we will be doing _eglPutFoo() outside of the
big display lock.

Signed-off-by: Rob Clark <robdclark@chromium.org>
---
 src/egl/main/egldisplay.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index db90b2b2dc78..ddbcbf0061dd 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -442,8 +442,7 @@ void
 _eglGetResource(_EGLResource *res)
 {
    assert(res && res->RefCount > 0);
-   /* hopefully a resource is always manipulated with its display locked */
-   res->RefCount++;
+   p_atomic_inc(&res->RefCount);
 }
 
 
@@ -454,8 +453,7 @@ EGLBoolean
 _eglPutResource(_EGLResource *res)
 {
    assert(res && res->RefCount > 0);
-   res->RefCount--;
-   return (!res->RefCount);
+   return p_atomic_dec_zero(&res->RefCount);
 }
 
 
-- 
GitLab


From 632f5c63e99664f46d025a32d6fa116caaa06ff6 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Thu, 11 Aug 2022 10:52:59 -0700
Subject: [PATCH 5/5] egl: Relax locking

Don't look the display in cases where we don't need it, or drop the lock
before calling down to driver in cases where we do need the lock to
lookup objects.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/7039
Signed-off-by: Rob Clark <robdclark@chromium.org>
Acked-by: Eric Engestrom <eric@igalia.com>
---
 src/egl/drivers/dri2/platform_android.c |   8 --
 src/egl/main/eglapi.c                   | 150 ++++++++++++++++--------
 2 files changed, 99 insertions(+), 59 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index ffd75ced0a3f..af7b3291f8b2 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -540,12 +540,6 @@ droid_window_enqueue_buffer(_EGLDisplay *disp, struct dri2_egl_surface *dri2_sur
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
-   /* To avoid blocking other EGL calls, release the display mutex before
-    * we enter droid_window_enqueue_buffer() and re-acquire the mutex upon
-    * return.
-    */
-   simple_mtx_unlock(&disp->Mutex);
-
    /* Queue the buffer with stored out fence fd. The ANativeWindow or buffer
     * consumer may choose to wait for the fence to signal before accessing
     * it. If fence fd value is -1, buffer can be accessed by consumer
@@ -563,8 +557,6 @@ droid_window_enqueue_buffer(_EGLDisplay *disp, struct dri2_egl_surface *dri2_sur
    dri2_surf->buffer = NULL;
    dri2_surf->back = NULL;
 
-   simple_mtx_lock(&disp->Mutex);
-
    if (dri2_surf->dri_image_back) {
       dri2_dpy->image->destroyImage(dri2_surf->dri_image_back);
       dri2_surf->dri_image_back = NULL;
diff --git a/src/egl/main/eglapi.c b/src/egl/main/eglapi.c
index 95a5e76adf18..44d85fdb68dd 100644
--- a/src/egl/main/eglapi.c
+++ b/src/egl/main/eglapi.c
@@ -901,8 +901,25 @@ eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read,
        draw_surf && !draw_surf->ProtectedContent)
       RETURN_EGL_ERROR(disp, EGL_BAD_ACCESS, EGL_FALSE);
 
+   /* Temporarily hold an extra reference to the ctx and surfs, before we
+    * drop the disp mutex.  If successful, the egl driver's MakeCurrent
+    * will have grabbed it's own references, so this these references can
+    * be dropped once MakeCurrent returns.
+    */
+   _eglGetSurface(draw_surf);
+   _eglGetSurface(read_surf);
+   _eglGetContext(ctx);
+
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->MakeCurrent(disp, draw_surf, read_surf, context);
 
+   simple_mtx_lock(&disp->Mutex);
+
+   _eglPutContext(ctx);
+   _eglPutSurface(read_surf);
+   _eglPutSurface(draw_surf);
+
    RETURN_EGL_EVAL(disp, ret);
 }
 
@@ -990,7 +1007,9 @@ _eglCreateWindowSurfaceCommon(_EGLDisplay *disp, EGLConfig config,
    if (_eglNativeSurfaceAlreadyUsed(disp, native_window))
       RETURN_EGL_ERROR(disp, EGL_BAD_ALLOC, EGL_NO_SURFACE);
 
+   simple_mtx_unlock(&disp->Mutex);
    surf = disp->Driver->CreateWindowSurface(disp, conf, native_window, attrib_list);
+   simple_mtx_lock(&disp->Mutex);
    ret = (surf) ? _eglLinkSurface(surf) : EGL_NO_SURFACE;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1133,7 +1152,9 @@ _eglCreatePixmapSurfaceCommon(_EGLDisplay *disp, EGLConfig config,
    if (_eglNativeSurfaceAlreadyUsed(disp, native_pixmap))
       RETURN_EGL_ERROR(disp, EGL_BAD_ALLOC, EGL_NO_SURFACE);
 
+   simple_mtx_unlock(&disp->Mutex);
    surf = disp->Driver->CreatePixmapSurface(disp, conf, native_pixmap, attrib_list);
+   simple_mtx_lock(&disp->Mutex);
    ret = (surf) ? _eglLinkSurface(surf) : EGL_NO_SURFACE;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1193,7 +1214,7 @@ EGLSurface EGLAPIENTRY
 eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config,
                         const EGLint *attrib_list)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    _EGLConfig *conf = _eglLookupConfig(config, disp);
    _EGLSurface *surf;
    EGLSurface ret;
@@ -1205,6 +1226,7 @@ eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config,
       RETURN_EGL_ERROR(disp, EGL_BAD_MATCH, EGL_NO_SURFACE);
 
    surf = disp->Driver->CreatePbufferSurface(disp, conf, attrib_list);
+   simple_mtx_lock(&disp->Mutex);
    ret = (surf) ? _eglLinkSurface(surf) : EGL_NO_SURFACE;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1221,9 +1243,10 @@ eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
    _eglUnlinkSurface(surf);
+   _eglUnlockDisplay(disp);
    ret = disp->Driver->DestroySurface(disp, surf);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 EGLBoolean EGLAPIENTRY
@@ -1271,9 +1294,10 @@ eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
+   _eglUnlockDisplay(disp);
    ret = disp->Driver->BindTexImage(disp, surf, buffer);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -1286,16 +1310,17 @@ eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
 
    _EGL_FUNC_START(disp, EGL_OBJECT_SURFACE_KHR, surf);
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
+   _eglUnlockDisplay(disp);
    ret = disp->Driver->ReleaseTexImage(disp, surf, buffer);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
 EGLBoolean EGLAPIENTRY
 eglSwapInterval(EGLDisplay dpy, EGLint interval)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    _EGLContext *ctx = _eglGetCurrentContext();
    _EGLSurface *surf = ctx ? ctx->DrawSurface : NULL;
    EGLBoolean ret;
@@ -1325,7 +1350,7 @@ eglSwapInterval(EGLDisplay dpy, EGLint interval)
    if (ret)
       surf->SwapInterval = interval;
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -1359,6 +1384,8 @@ eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
    if (surf->Lost)
       RETURN_EGL_ERROR(disp, EGL_BAD_NATIVE_WINDOW, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->SwapBuffers(disp, surf);
 
    /* EGL_KHR_partial_update
@@ -1370,7 +1397,7 @@ eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
       surf->BufferAgeRead = EGL_FALSE;
    }
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -1394,6 +1421,8 @@ _eglSwapBuffersWithDamageCommon(_EGLDisplay *disp, _EGLSurface *surf,
    if ((n_rects > 0 && rects == NULL) || n_rects < 0)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->SwapBuffersWithDamageEXT(disp, surf, rects, n_rects);
 
    /* EGL_KHR_partial_update
@@ -1405,7 +1434,7 @@ _eglSwapBuffersWithDamageCommon(_EGLDisplay *disp, _EGLSurface *surf,
       surf->BufferAgeRead = EGL_FALSE;
    }
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
@@ -1503,9 +1532,12 @@ eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
    _EGL_CHECK_SURFACE(disp, surf, EGL_FALSE);
    if (surf->ProtectedContent)
       RETURN_EGL_ERROR(disp, EGL_BAD_ACCESS, EGL_FALSE);
+
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->CopyBuffers(disp, surf, native_pixmap_ptr);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -1520,7 +1552,6 @@ _eglWaitClientCommon(void)
       RETURN_EGL_SUCCESS(NULL, EGL_TRUE);
 
    disp = ctx->Resource.Display;
-   simple_mtx_lock(&disp->Mutex);
 
    /* let bad current context imply bad current surface */
    if (_eglGetContextHandle(ctx) == EGL_NO_CONTEXT ||
@@ -1531,7 +1562,7 @@ _eglWaitClientCommon(void)
    assert(disp->Initialized);
    ret = disp->Driver->WaitClient(disp, ctx);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 EGLBoolean EGLAPIENTRY
@@ -1563,18 +1594,17 @@ eglWaitNative(EGLint engine)
    _EGL_FUNC_START(NULL, EGL_OBJECT_THREAD_KHR, NULL);
 
    disp = ctx->Resource.Display;
-   simple_mtx_lock(&disp->Mutex);
 
    /* let bad current context imply bad current surface */
    if (_eglGetContextHandle(ctx) == EGL_NO_CONTEXT ||
        _eglGetSurfaceHandle(ctx->DrawSurface) == EGL_NO_SURFACE)
-      RETURN_EGL_ERROR(disp, EGL_BAD_CURRENT_SURFACE, EGL_FALSE);
+      RETURN_EGL_ERROR(NULL, EGL_BAD_CURRENT_SURFACE, EGL_FALSE);
 
    /* a valid current context implies an initialized current display */
    assert(disp->Initialized);
    ret = disp->Driver->WaitNative(engine);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -1722,9 +1752,7 @@ eglReleaseThread(void)
    if (ctx) {
       _EGLDisplay *disp = ctx->Resource.Display;
 
-      simple_mtx_lock(&disp->Mutex);
       (void) disp->Driver->MakeCurrent(disp, NULL, NULL, NULL);
-      simple_mtx_unlock(&disp->Mutex);
    }
 
    _eglDestroyCurrentThread();
@@ -1752,7 +1780,9 @@ _eglCreateImageCommon(_EGLDisplay *disp, EGLContext ctx, EGLenum target,
    if (ctx != EGL_NO_CONTEXT && target == EGL_LINUX_DMA_BUF_EXT)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);
 
+   simple_mtx_unlock(&disp->Mutex);
    img = disp->Driver->CreateImageKHR(disp, context, target, buffer, attr_list);
+   simple_mtx_lock(&disp->Mutex);
    ret = (img) ? _eglLinkImage(img) : EGL_NO_IMAGE_KHR;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1883,7 +1913,9 @@ _eglCreateSync(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list,
       RETURN_EGL_ERROR(disp, invalid_type_error, EGL_NO_SYNC_KHR);
    }
 
+   simple_mtx_unlock(&disp->Mutex);
    sync = disp->Driver->CreateSyncKHR(disp, type, attrib_list);
+   simple_mtx_lock(&disp->Mutex);
    ret = (sync) ? _eglLinkSync(sync) : EGL_NO_SYNC_KHR;
 
    RETURN_EGL_EVAL(disp, ret);
@@ -1950,9 +1982,10 @@ _eglDestroySync(_EGLDisplay *disp, _EGLSync *s)
           disp->Extensions.ANDROID_native_fence_sync);
 
    _eglUnlinkSync(s);
+   _eglUnlockDisplay(disp);
    ret = disp->Driver->DestroySyncKHR(disp, s);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 EGLBoolean EGLAPIENTRY
@@ -1988,24 +2021,13 @@ _eglClientWaitSyncCommon(_EGLDisplay *disp, _EGLSync *s,
    if (s->SyncStatus == EGL_SIGNALED_KHR)
       RETURN_EGL_EVAL(disp, EGL_CONDITION_SATISFIED_KHR);
 
-   /* if sync type is EGL_SYNC_REUSABLE_KHR, dpy should be
-    * unlocked here to allow other threads also to be able to
-    * go into waiting state.
-    */
-
-   if (s->Type == EGL_SYNC_REUSABLE_KHR)
-      _eglUnlockDisplay(disp);
+   _eglGetSync(s);
+   _eglUnlockDisplay(disp);
 
    ret = disp->Driver->ClientWaitSyncKHR(disp, s, flags, timeout);
+   _eglPutSync(s);
 
-   /*
-    * 'disp' is already unlocked for reusable sync type,
-    * so passing 'NULL' to bypass unlocking display.
-    */
-   if (s->Type == EGL_SYNC_REUSABLE_KHR)
-      RETURN_EGL_EVAL(NULL, ret);
-   else
-      RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 EGLint EGLAPIENTRY
@@ -2048,9 +2070,13 @@ _eglWaitSyncCommon(_EGLDisplay *disp, _EGLSync *s, EGLint flags)
    if (flags != 0)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
+   _eglGetSync(s);
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->WaitSyncKHR(disp, s);
+   _eglPutSync(s);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLint EGLAPIENTRY
@@ -2088,9 +2114,14 @@ eglSignalSyncKHR(EGLDisplay dpy, EGLSync sync, EGLenum mode)
 
    _EGL_CHECK_SYNC(disp, s, EGL_FALSE);
    assert(disp->Extensions.KHR_reusable_sync);
+
+   _eglGetSync(s);
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->SignalSyncKHR(disp, s, mode);
+   _eglPutSync(s);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -2168,9 +2199,14 @@ eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSync sync)
 
    _EGL_CHECK_SYNC(disp, s, EGL_NO_NATIVE_FENCE_FD_ANDROID);
    assert(disp->Extensions.ANDROID_native_fence_sync);
+
+   _eglGetSync(s);
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->DupNativeFenceFDANDROID(disp, s);
+   _eglPutSync(s);
 
-   RETURN_EGL_SUCCESS(disp, ret);
+   RETURN_EGL_SUCCESS(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
@@ -2194,9 +2230,11 @@ eglSwapBuffersRegionNOK(EGLDisplay dpy, EGLSurface surface,
        surf != ctx->DrawSurface)
       RETURN_EGL_ERROR(disp, EGL_BAD_SURFACE, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->SwapBuffersRegionNOK(disp, surf, numRects, rects);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -2235,9 +2273,11 @@ eglExportDRMImageMESA(EGLDisplay dpy, EGLImage image,
    if (!img)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->ExportDRMImageMESA(disp, img, name, handle, stride);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -2246,7 +2286,7 @@ struct wl_display;
 static EGLBoolean EGLAPIENTRY
 eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    EGLBoolean ret;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_DISPLAY_KHR, NULL);
@@ -2259,13 +2299,13 @@ eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
 
    ret = disp->Driver->BindWaylandDisplayWL(disp, display);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
 eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    EGLBoolean ret;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_DISPLAY_KHR, NULL);
@@ -2278,14 +2318,14 @@ eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
 
    ret = disp->Driver->UnbindWaylandDisplayWL(disp, display);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
 eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *buffer,
                         EGLint attribute, EGLint *value)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    EGLBoolean ret;
 
    _EGL_FUNC_START(disp, EGL_OBJECT_DISPLAY_KHR, NULL);
@@ -2298,7 +2338,7 @@ eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *buffer,
 
    ret = disp->Driver->QueryWaylandBufferWL(disp, buffer, attribute, value);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 
@@ -2340,9 +2380,11 @@ eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface,
    if (!disp->Extensions.NV_post_sub_buffer)
       RETURN_EGL_EVAL(disp, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->PostSubBufferNV(disp, surf, x, y, width, height);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
@@ -2363,9 +2405,11 @@ eglGetSyncValuesCHROMIUM(EGLDisplay dpy, EGLSurface surface,
    if (!ust || !msc || !sbc)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->GetSyncValuesCHROMIUM(disp, surf, ust, msc, sbc);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
@@ -2407,9 +2451,11 @@ eglExportDMABUFImageQueryMESA(EGLDisplay dpy, EGLImage image,
    if (!img)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->ExportDMABUFImageQueryMESA(disp, img, fourcc, nplanes, modifiers);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
@@ -2428,9 +2474,11 @@ eglExportDMABUFImageMESA(EGLDisplay dpy, EGLImage image,
    if (!img)
       RETURN_EGL_ERROR(disp, EGL_BAD_PARAMETER, EGL_FALSE);
 
+   _eglUnlockDisplay(disp);
+
    ret = disp->Driver->ExportDMABUFImageMESA(disp, img, fds, strides, offsets);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLint EGLAPIENTRY
@@ -2580,7 +2628,7 @@ static EGLBoolean EGLAPIENTRY
 eglQueryDmaBufFormatsEXT(EGLDisplay dpy, EGLint max_formats,
                          EGLint *formats, EGLint *num_formats)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    EGLBoolean ret;
 
    _EGL_FUNC_START(NULL, EGL_NONE, NULL);
@@ -2589,7 +2637,7 @@ eglQueryDmaBufFormatsEXT(EGLDisplay dpy, EGLint max_formats,
 
    ret = disp->Driver->QueryDmaBufFormatsEXT(disp, max_formats, formats, num_formats);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static EGLBoolean EGLAPIENTRY
@@ -2597,7 +2645,7 @@ eglQueryDmaBufModifiersEXT(EGLDisplay dpy, EGLint format, EGLint max_modifiers,
                            EGLuint64KHR *modifiers, EGLBoolean *external_only,
                            EGLint *num_modifiers)
 {
-   _EGLDisplay *disp = _eglLockDisplay(dpy);
+   _EGLDisplay *disp = _eglLookupDisplay(dpy);
    EGLBoolean ret;
 
    _EGL_FUNC_START(NULL, EGL_NONE, NULL);
@@ -2607,7 +2655,7 @@ eglQueryDmaBufModifiersEXT(EGLDisplay dpy, EGLint format, EGLint max_modifiers,
    ret = disp->Driver->QueryDmaBufModifiersEXT(disp, format, max_modifiers, modifiers,
                                       external_only, num_modifiers);
 
-   RETURN_EGL_EVAL(disp, ret);
+   RETURN_EGL_EVAL(NULL, ret);
 }
 
 static void EGLAPIENTRY
-- 
GitLab

