From 98ad01c0f0beea61518bb72af16f42fc915133ed Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 22 May 2023 14:15:58 +0100
Subject: [PATCH 1/5] aco: add VOPD format

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp        | 29 +++++++++++
 src/amd/compiler/aco_builder_h.py         |  1 +
 src/amd/compiler/aco_ir.h                 | 21 +++++++-
 src/amd/compiler/aco_opcodes.py           | 26 ++++++++++
 src/amd/compiler/aco_print_ir.cpp         |  5 ++
 src/amd/compiler/tests/test_assembler.cpp | 59 +++++++++++++++++++++++
 6 files changed, 140 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 49508e9613795..1500984a12131 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -468,6 +468,35 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
       out.push_back(encoding);
       break;
    }
+   case Format::VOPD: {
+      VOPD_instruction& vopd = instr->vopd();
+      uint32_t encoding = (0b110010 << 26);
+      encoding |= reg(ctx, instr->operands[0]);
+      if (instr->opcode != aco_opcode::v_dual_mov_b32)
+         encoding |= reg(ctx, instr->operands[1], 8) << 9;
+      encoding |= (uint32_t)ctx.opcode[(int)vopd.opy] << 17;
+      encoding |= opcode << 22;
+      out.push_back(encoding);
+
+      unsigned opy_start = instr->opcode == aco_opcode::v_dual_mov_b32 ? 1 : 2;
+      switch (instr->opcode) {
+      case aco_opcode::v_dual_fmac_f32:
+      case aco_opcode::v_dual_fmaak_f32:
+      case aco_opcode::v_dual_fmamk_f32:
+      case aco_opcode::v_dual_cndmask_b32:
+      case aco_opcode::v_dual_dot2acc_f32_f16:
+      case aco_opcode::v_dual_dot2acc_f32_bf16: opy_start = 3; break;
+      default: break;
+      }
+
+      encoding = reg(ctx, instr->operands[opy_start]);
+      if (vopd.opy != aco_opcode::v_dual_mov_b32)
+         encoding |= reg(ctx, instr->operands[opy_start + 1], 8) << 9;
+      encoding |= (reg(ctx, instr->definitions[1], 8) >> 1) << 17;
+      encoding |= reg(ctx, instr->definitions[0], 8) << 24;
+      out.push_back(encoding);
+      break;
+   }
    case Format::DS: {
       DS_instruction& ds = instr->ds();
       uint32_t encoding = (0b110110 << 26);
diff --git a/src/amd/compiler/aco_builder_h.py b/src/amd/compiler/aco_builder_h.py
index 4d56d06758514..f07827b6ace9e 100644
--- a/src/amd/compiler/aco_builder_h.py
+++ b/src/amd/compiler/aco_builder_h.py
@@ -571,6 +571,7 @@ formats = [("pseudo", [Format.PSEUDO], 'Pseudo_instruction', list(itertools.prod
            ("vopc_sdwa", [Format.VOPC, Format.SDWA], 'SDWA_instruction', itertools.product([1, 2], [2])),
            ("vop3", [Format.VOP3], 'VALU_instruction', [(1, 3), (1, 2), (1, 1), (2, 2)]),
            ("vop3p", [Format.VOP3P], 'VALU_instruction', [(1, 2), (1, 3)]),
+           ("vopd", [Format.VOPD], 'VOPD_instruction', [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6)]),
            ("vinterp_inreg", [Format.VINTERP_INREG], 'VINTERP_inreg_instruction', [(1, 3)]),
            ("vintrp", [Format.VINTRP], 'VINTRP_instruction', [(1, 2), (1, 3)]),
            ("vop1_dpp", [Format.VOP1, Format.DPP16], 'DPP16_instruction', [(1, 1)]),
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index cd4ceb221ce8c..107961fa524cf 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -957,6 +957,7 @@ struct Pseudo_reduction_instruction;
 struct VALU_instruction;
 struct VINTERP_inreg_instruction;
 struct VINTRP_instruction;
+struct VOPD_instruction;
 struct DPP16_instruction;
 struct DPP8_instruction;
 struct SDWA_instruction;
@@ -1210,6 +1211,17 @@ struct Instruction {
       return *(VINTERP_inreg_instruction*)this;
    }
    constexpr bool isVINTERP_INREG() const noexcept { return format == Format::VINTERP_INREG; }
+   VOPD_instruction& vopd() noexcept
+   {
+      assert(isVOPD());
+      return *(VOPD_instruction*)this;
+   }
+   const VOPD_instruction& vopd() const noexcept
+   {
+      assert(isVOPD());
+      return *(VOPD_instruction*)this;
+   }
+   constexpr bool isVOPD() const noexcept { return format == Format::VOPD; }
    constexpr bool isVOP1() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP1; }
    constexpr bool isVOP2() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP2; }
    constexpr bool isVOPC() const noexcept { return (uint16_t)format & (uint16_t)Format::VOPC; }
@@ -1278,7 +1290,8 @@ struct Instruction {
    }
    constexpr bool isVALU() const noexcept
    {
-      return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P() || isVINTERP_INREG();
+      return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P() || isVINTERP_INREG() ||
+             isVOPD();
    }
 
    constexpr bool isSALU() const noexcept
@@ -1368,6 +1381,12 @@ struct VINTERP_inreg_instruction : public VALU_instruction {
 static_assert(sizeof(VINTERP_inreg_instruction) == sizeof(VALU_instruction) + 4,
               "Unexpected padding");
 
+struct VOPD_instruction : public VALU_instruction {
+   aco_opcode opy;
+   uint16_t padding;
+};
+static_assert(sizeof(VOPD_instruction) == sizeof(VALU_instruction) + 4, "Unexpected padding");
+
 /**
  * Data Parallel Primitives Format:
  * This format can be used for VOP1, VOP2 or VOPC instructions.
diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index 1cf23b5e061b7..4a512113c3f49 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -89,6 +89,7 @@ class Format(IntEnum):
    VINTRP = auto()
    # Vector ALU Formats
    VINTERP_INREG = auto()
+   VOPD = auto()
    VOP1 = 1 << 7
    VOP2 = 1 << 8
    VOPC = 1 << 9
@@ -186,6 +187,8 @@ class Format(IntEnum):
       elif self == Format.VOP3P:
          return [('uint8_t', 'opsel_lo', None),
                  ('uint8_t', 'opsel_hi', None)]
+      elif self == Format.VOPD:
+         return [('aco_opcode', 'opy', None)]
       elif self == Format.VINTERP_INREG:
          return [('unsigned', 'wait_exp', 7),
                  ('uint8_t', 'opsel', 0)]
@@ -1272,6 +1275,29 @@ for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, in_mod, out_mod, defs, ops, cls
    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP3, cls, in_mod, out_mod, definitions = defs, operands = ops)
 
 
+VOPD = {
+   (0x00, "v_dual_fmac_f32"),
+   (0x01, "v_dual_fmaak_f32"),
+   (0x02, "v_dual_fmamk_f32"),
+   (0x03, "v_dual_mul_f32"),
+   (0x04, "v_dual_add_f32"),
+   (0x05, "v_dual_sub_f32"),
+   (0x06, "v_dual_subrev_f32"),
+   (0x07, "v_dual_mul_dx9_zero_f32"),
+   (0x08, "v_dual_mov_b32"),
+   (0x09, "v_dual_cndmask_b32"),
+   (0x0a, "v_dual_max_f32"),
+   (0x0b, "v_dual_min_f32"),
+   (0x0c, "v_dual_dot2acc_f32_f16"),
+   (0x0d, "v_dual_dot2acc_f32_bf16"),
+   (0x10, "v_dual_add_nc_u32"),
+   (0x11, "v_dual_lshlrev_b32"),
+   (0x12, "v_dual_and_b32"),
+}
+for gfx11, name in VOPD:
+   opcode(name, -1, -1, -1, gfx11, format = Format.VOPD, cls = InstrClass.Valu32)
+
+
 # DS instructions: 3 inputs (1 addr, 2 data), 1 output
 DS = {
    (0x00, 0x00, 0x00, 0x00, 0x00, 0x00, "ds_add_u32"),
diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index 3fc32223a41b4..335d9036f5bd3 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -443,6 +443,11 @@ print_instr_format_specific(enum amd_gfx_level gfx_level, const Instruction* ins
       fprintf(output, " attr%d.%c", vintrp.attribute, "xyzw"[vintrp.component]);
       break;
    }
+   case Format::VOPD: {
+      const VOPD_instruction& vopd = instr->vopd();
+      fprintf(output, " %s", instr_info.name[(int)vopd.opy]);
+      break;
+   }
    case Format::DS: {
       const DS_instruction& ds = instr->ds();
       if (ds.offset0)
diff --git a/src/amd/compiler/tests/test_assembler.cpp b/src/amd/compiler/tests/test_assembler.cpp
index a7106e98686a4..8c92e669a6493 100644
--- a/src/amd/compiler/tests/test_assembler.cpp
+++ b/src/amd/compiler/tests/test_assembler.cpp
@@ -1055,3 +1055,62 @@ BEGIN_TEST(assembler.vop3_dpp)
 
    finish_assembler_test();
 END_TEST
+
+BEGIN_TEST(assembler.vopd)
+   if (!setup_cs(NULL, GFX11))
+      return;
+
+   Definition dst_v0 = bld.def(v1);
+   dst_v0.setFixed(PhysReg(256));
+
+   Definition dst_v1 = bld.def(v1);
+   dst_v1.setFixed(PhysReg(256 + 1));
+
+   Operand op_v0(bld.tmp(v1));
+   op_v0.setFixed(PhysReg(256 + 0));
+
+   Operand op_v1(bld.tmp(v1));
+   op_v1.setFixed(PhysReg(256 + 1));
+
+   Operand op_v2(bld.tmp(v1));
+   op_v2.setFixed(PhysReg(256 + 2));
+
+   Operand op_v3(bld.tmp(v1));
+   op_v3.setFixed(PhysReg(256 + 3));
+
+   Operand op_s0(bld.tmp(s1));
+   op_s0.setFixed(PhysReg(0));
+
+   Operand op_vcc(bld.tmp(s1));
+   op_vcc.setFixed(vcc);
+
+   //>> BB0:
+   //! v_dual_mov_b32 v0, v0 :: v_dual_mov_b32 v1, v1 ; ca100100 00000101
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, op_v0, op_v1, aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mov_b32 v0, 0x60 :: v_dual_mov_b32 v1, s0 ; ca1000ff 00000000 00000060
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, Operand::c32(96), op_s0,
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mov_b32 v0, s0 :: v_dual_mov_b32 v1, 0x60 ; ca100000 000000ff 00000060
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, op_s0, Operand::c32(96),
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mul_f32 v0, v0, v1 :: v_dual_mov_b32 v1, v2 ; c8d00300 00000102
+   bld.vopd(aco_opcode::v_dual_mul_f32, dst_v0, dst_v1, op_v0, op_v1, op_v2,
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_fmac_f32 v0, v1, v2 :: v_dual_mov_b32 v1, v3 ; c8100501 00000103
+   bld.vopd(aco_opcode::v_dual_fmac_f32, dst_v0, dst_v1, op_v1, op_v2, op_v0, op_v3,
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mov_b32 v0, v0 :: v_dual_and_b32 v1, v1, v2 ; ca240100 00000501
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, op_v0, op_v1, op_v2,
+            aco_opcode::v_dual_and_b32);
+
+   //! v_dual_cndmask_b32 v0, v0, v1 :: v_dual_cndmask_b32 v1, v2, v3 ; ca520300 00000702
+   bld.vopd(aco_opcode::v_dual_cndmask_b32, dst_v0, dst_v1, op_v0, op_v1, op_vcc, op_v2, op_v3,
+            op_vcc, aco_opcode::v_dual_cndmask_b32);
+
+   finish_assembler_test();
+END_TEST
-- 
GitLab


From 3511bd2607ddaf1d1eafd7062f5818c8d6798bb0 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 24 May 2023 18:43:13 +0100
Subject: [PATCH 2/5] aco: add VOPD statistic

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_interface.cpp | 1 +
 src/amd/compiler/aco_shader_info.h | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index b405fbd82cbe5..9c4280480468a 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -59,6 +59,7 @@ static const std::array<aco_compiler_statistic_info, aco_num_statistics> statist
    ret[aco_statistic_salu] = aco_compiler_statistic_info{"SALU", "Number of SALU instructions"};
    ret[aco_statistic_vmem] = aco_compiler_statistic_info{"VMEM", "Number of VMEM instructions"};
    ret[aco_statistic_smem] = aco_compiler_statistic_info{"SMEM", "Number of SMEM instructions"};
+   ret[aco_statistic_vopd] = aco_compiler_statistic_info{"VOPD", "Number of VOPD instructions"};
    return ret;
 }();
 
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index e6ff2c8a5f7d4..bfe8071dee2d3 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -228,6 +228,7 @@ enum aco_statistic {
    aco_statistic_salu,
    aco_statistic_vmem,
    aco_statistic_smem,
+   aco_statistic_vopd,
    aco_num_statistics
 };
 
-- 
GitLab


From b89c3cfa8ff4e48cb35ab577bde32a578e889105 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 12 Jan 2024 19:27:48 +0000
Subject: [PATCH 3/5] aco: refactor schedule_ilp main loop

Besides switching to "ctx.active_mask" as the condition, this is basically
the same.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_scheduler_ilp.cpp | 54 +++++++++++++++-----------
 1 file changed, 32 insertions(+), 22 deletions(-)

diff --git a/src/amd/compiler/aco_scheduler_ilp.cpp b/src/amd/compiler/aco_scheduler_ilp.cpp
index 007386cef7b6f..4bcd1d80e8cf9 100644
--- a/src/amd/compiler/aco_scheduler_ilp.cpp
+++ b/src/amd/compiler/aco_scheduler_ilp.cpp
@@ -377,6 +377,36 @@ select_instruction(const SchedILPContext& ctx)
    return idx;
 }
 
+template <typename It>
+void
+do_schedule(SchedILPContext& ctx, It& insert_it, It& remove_it, It instructions_begin,
+            It instructions_end)
+{
+   for (unsigned i = 0; i < num_nodes; i++) {
+      if (remove_it == instructions_end)
+         break;
+
+      add_entry(ctx, (remove_it++)->get(), i);
+   }
+
+   while (ctx.active_mask) {
+      unsigned next_idx = select_instruction(ctx);
+      Instruction* next_instr = ctx.nodes[next_idx].instr;
+
+      (insert_it++)->reset(next_instr);
+
+      remove_entry(ctx, next_instr, next_idx);
+      ctx.nodes[next_idx].instr = NULL;
+
+      if (remove_it != instructions_end) {
+         add_entry(ctx, (remove_it++)->get(), next_idx);
+      } else if (ctx.last_non_reorderable != UINT8_MAX) {
+         ctx.nodes[ctx.last_non_reorderable].potential_clause = false;
+         ctx.last_non_reorderable = UINT8_MAX;
+      }
+   }
+}
+
 } // namespace
 
 void
@@ -386,29 +416,9 @@ schedule_ilp(Program* program)
 
    for (Block& block : program->blocks) {
       auto it = block.instructions.begin();
-      for (unsigned i = 0; i < num_nodes; i++) {
-         if (it == block.instructions.end())
-            break;
-
-         add_entry(ctx, (it++)->get(), i);
-      }
-
       auto insert_it = block.instructions.begin();
-      while (insert_it != block.instructions.end()) {
-         unsigned next_idx = select_instruction(ctx);
-         Instruction* next_instr = ctx.nodes[next_idx].instr;
-         remove_entry(ctx, next_instr, next_idx);
-         (insert_it++)->reset(next_instr);
-         ctx.nodes[next_idx].instr = NULL;
-
-         if (it != block.instructions.end()) {
-            add_entry(ctx, (it++)->get(), next_idx);
-         } else if (ctx.last_non_reorderable != UINT8_MAX) {
-            ctx.nodes[ctx.last_non_reorderable].potential_clause = false;
-            ctx.last_non_reorderable = UINT8_MAX;
-         }
-      }
-      assert(it == block.instructions.end());
+      do_schedule(ctx, insert_it, it, block.instructions.begin(), block.instructions.end());
+      block.instructions.resize(insert_it - block.instructions.begin());
    }
 }
 
-- 
GitLab


From a799ef230b37f1bb32c10e1707e24b20f8554b3f Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 17 Jan 2024 20:47:27 +0000
Subject: [PATCH 4/5] aco: implement VOPD scheduler

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_ir.h              |   1 +
 src/amd/compiler/aco_scheduler_ilp.cpp | 288 ++++++++++++++++++++++++-
 2 files changed, 283 insertions(+), 6 deletions(-)

diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 107961fa524cf..7c74d2fc73ee4 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2228,6 +2228,7 @@ void ssa_elimination(Program* program);
 void lower_to_hw_instr(Program* program);
 void schedule_program(Program* program, live& live_vars);
 void schedule_ilp(Program* program);
+void schedule_vopd(Program* program);
 void spill(Program* program, live& live_vars);
 void insert_wait_states(Program* program);
 bool dealloc_vgprs(Program* program);
diff --git a/src/amd/compiler/aco_scheduler_ilp.cpp b/src/amd/compiler/aco_scheduler_ilp.cpp
index 4bcd1d80e8cf9..7aba074e92883 100644
--- a/src/amd/compiler/aco_scheduler_ilp.cpp
+++ b/src/amd/compiler/aco_scheduler_ilp.cpp
@@ -27,6 +27,23 @@ constexpr unsigned num_nodes = 16;
 using mask_t = uint16_t;
 static_assert(std::numeric_limits<mask_t>::digits >= num_nodes);
 
+struct VOPDInfo {
+   VOPDInfo() : restriction_mask(0), op(aco_opcode::num_opcodes), has_literal(false), literal(0) {}
+   union {
+      struct {
+         uint16_t is_opy_only : 1;
+         uint16_t is_dst_odd : 1;
+         uint16_t is_dst_even : 1;
+         uint16_t src_banks : 10; /* 0-3: src0, 4-7: src1, 8-9: src2 */
+         uint16_t padding : 3;
+      };
+      uint16_t restriction_mask;
+   };
+   aco_opcode op : 15;
+   bool has_literal : 1;
+   uint32_t literal;
+};
+
 struct InstrInfo {
    Instruction* instr;
    int32_t priority;
@@ -46,12 +63,21 @@ struct RegisterInfo {
 
 struct SchedILPContext {
    Program* program;
+   bool is_vopd = false;
    InstrInfo nodes[num_nodes];
    RegisterInfo regs[512];
    mask_t non_reorder_mask = 0; /* bitmask of instruction nodes which should not be reordered. */
    mask_t active_mask = 0;      /* bitmask of valid instruction nodes. */
    uint8_t next_non_reorderable = UINT8_MAX; /* index of next node which should not be reordered. */
    uint8_t last_non_reorderable = UINT8_MAX; /* index of last node which should not be reordered. */
+
+   /* VOPD scheduler: */
+   VOPDInfo vopd[num_nodes];
+   VOPDInfo prev_vopd_info;
+   InstrInfo prev_info;
+
+   mask_t vopd_odd_mask = 0;
+   mask_t vopd_even_mask = 0;
 };
 
 /**
@@ -98,6 +124,118 @@ can_reorder(const Instruction* const instr)
    return true;
 }
 
+VOPDInfo
+get_vopd_info(const Instruction* instr)
+{
+   if (instr->format != Format::VOP1 && instr->format != Format::VOP2)
+      return VOPDInfo();
+
+   VOPDInfo info;
+   switch (instr->opcode) {
+   case aco_opcode::v_fmac_f32: info.op = aco_opcode::v_dual_fmac_f32; break;
+   case aco_opcode::v_fmaak_f32: info.op = aco_opcode::v_dual_fmaak_f32; break;
+   case aco_opcode::v_fmamk_f32: info.op = aco_opcode::v_dual_fmamk_f32; break;
+   case aco_opcode::v_mul_f32: info.op = aco_opcode::v_dual_mul_f32; break;
+   case aco_opcode::v_add_f32: info.op = aco_opcode::v_dual_add_f32; break;
+   case aco_opcode::v_sub_f32: info.op = aco_opcode::v_dual_sub_f32; break;
+   case aco_opcode::v_subrev_f32: info.op = aco_opcode::v_dual_subrev_f32; break;
+   case aco_opcode::v_mul_legacy_f32: info.op = aco_opcode::v_dual_mul_dx9_zero_f32; break;
+   case aco_opcode::v_mov_b32: info.op = aco_opcode::v_dual_mov_b32; break;
+   case aco_opcode::v_cndmask_b32: info.op = aco_opcode::v_dual_cndmask_b32; break;
+   case aco_opcode::v_max_f32: info.op = aco_opcode::v_dual_max_f32; break;
+   case aco_opcode::v_min_f32: info.op = aco_opcode::v_dual_min_f32; break;
+   case aco_opcode::v_dot2c_f32_f16: info.op = aco_opcode::v_dual_dot2acc_f32_f16; break;
+   case aco_opcode::v_add_u32:
+      info.op = aco_opcode::v_dual_add_nc_u32;
+      info.is_opy_only = true;
+      break;
+   case aco_opcode::v_lshlrev_b32:
+      info.op = aco_opcode::v_dual_lshlrev_b32;
+      info.is_opy_only = true;
+      break;
+   case aco_opcode::v_and_b32:
+      info.op = aco_opcode::v_dual_and_b32;
+      info.is_opy_only = true;
+      break;
+   default: return VOPDInfo();
+   }
+
+   /* Each instruction may use at most one SGPR. */
+   if (instr->opcode == aco_opcode::v_cndmask_b32 && instr->operands[0].isOfType(RegType::sgpr) &&
+       instr->operands[0].physReg() != vcc)
+      return VOPDInfo();
+
+   info.is_dst_odd = instr->definitions[0].physReg().reg() & 0x1;
+   info.is_dst_even = !(instr->definitions[0].physReg().reg() & 0x1);
+
+   static const unsigned bank_mask[3] = {0x3, 0x3, 0x1};
+   bool has_sgpr = false;
+   for (unsigned i = 0; i < instr->operands.size(); i++) {
+      unsigned port = (instr->opcode == aco_opcode::v_fmamk_f32 && i == 1) ? 2 : i;
+      if (instr->operands[i].isOfType(RegType::vgpr))
+         info.src_banks |= 1 << (port * 4 + (instr->operands[i].physReg().reg() & bank_mask[port]));
+
+      /* Check all operands because of fmaak/fmamk. */
+      if (instr->operands[i].isLiteral()) {
+         assert(!info.has_literal || info.literal == instr->operands[i].constantValue());
+         info.has_literal = true;
+         info.literal = instr->operands[i].constantValue();
+      }
+
+      /* Check all operands because of cndmask. */
+      has_sgpr |= !instr->operands[i].isConstant() && instr->operands[i].isOfType(RegType::sgpr);
+   }
+
+   /* An instruction can't use both a literal and an SGPR. */
+   if (has_sgpr && info.has_literal)
+      return VOPDInfo();
+
+   return info;
+}
+
+bool
+regs_intersect(PhysReg a_reg, unsigned a_size, PhysReg b_reg, unsigned b_size)
+{
+   return a_reg > b_reg ? (a_reg - b_reg < b_size) : (b_reg - a_reg < a_size);
+}
+
+bool
+can_use_vopd(const SchedILPContext& ctx, unsigned idx)
+{
+   VOPDInfo cur_vopd = ctx.vopd[idx];
+   Instruction* first = ctx.nodes[idx].instr;
+   Instruction* second = ctx.prev_info.instr;
+
+   if (!second)
+      return false;
+
+   if (ctx.prev_vopd_info.op == aco_opcode::num_opcodes || cur_vopd.op == aco_opcode::num_opcodes)
+      return false;
+
+   if (ctx.prev_vopd_info.restriction_mask & cur_vopd.restriction_mask)
+      return false;
+
+   /* Both can use a literal, but it must be the same literal. */
+   if (ctx.prev_vopd_info.has_literal && cur_vopd.has_literal &&
+       ctx.prev_vopd_info.literal != cur_vopd.literal)
+      return false;
+
+   /* Check for WaW dependency. */
+   if (regs_intersect(first->definitions[0].physReg(), first->definitions[0].size(),
+                      second->definitions[0].physReg(), second->definitions[0].size()))
+      return false;
+
+   /* Check for RaW dependency. */
+   for (Operand op : second->operands) {
+      if (regs_intersect(first->definitions[0].physReg(), first->definitions[0].size(),
+                         op.physReg(), op.size()))
+         return false;
+   }
+
+   /* WaR dependencies are not a concern. */
+   return true;
+}
+
 unsigned
 get_latency(const Instruction* const instr)
 {
@@ -138,6 +276,16 @@ add_entry(SchedILPContext& ctx, Instruction* const instr, const uint32_t idx)
    bool reorder = can_reorder(instr);
    ctx.active_mask |= mask;
 
+   if (ctx.is_vopd) {
+      VOPDInfo vopd = get_vopd_info(entry.instr);
+
+      ctx.vopd[idx] = vopd;
+      ctx.vopd_odd_mask &= ~BITFIELD_BIT(idx);
+      ctx.vopd_odd_mask |= ctx.vopd[idx].is_dst_odd ? BITFIELD_BIT(idx) : 0;
+      ctx.vopd_even_mask &= ~BITFIELD_BIT(idx);
+      ctx.vopd_even_mask |= ctx.vopd[idx].is_dst_even ? BITFIELD_BIT(idx) : 0;
+   }
+
    for (const Operand& op : instr->operands) {
       assert(op.isFixed());
       unsigned reg = op.physReg();
@@ -206,8 +354,10 @@ add_entry(SchedILPContext& ctx, Instruction* const instr, const uint32_t idx)
          reg_info.has_direct_dependency = 1;
          reg_info.direct_dependency = idx;
 
-         /* Add latency information for the next register read. */
-         reg_info.latency = get_latency(instr);
+         if (!ctx.is_vopd) {
+            /* Add latency information for the next register read. */
+            reg_info.latency = get_latency(instr);
+         }
       }
    }
 
@@ -225,7 +375,7 @@ add_entry(SchedILPContext& ctx, Instruction* const instr, const uint32_t idx)
 
       /* Just don't reorder these at all. */
       if (!is_memory_instr(instr) || instr->definitions.empty() ||
-          get_sync_info(instr).semantics & semantic_volatile) {
+          get_sync_info(instr).semantics & semantic_volatile || ctx.is_vopd) {
          /* Add all previous instructions as dependencies. */
          entry.dependency_mask = ctx.active_mask;
       }
@@ -343,7 +493,7 @@ collect_clause_dependencies(const SchedILPContext& ctx, const uint8_t next, mask
  * Returns the index of the next instruction to be selected.
  */
 unsigned
-select_instruction(const SchedILPContext& ctx)
+select_instruction_ilp(const SchedILPContext& ctx)
 {
    mask_t mask = ctx.active_mask;
 
@@ -377,6 +527,104 @@ select_instruction(const SchedILPContext& ctx)
    return idx;
 }
 
+bool
+compare_nodes_vopd(const SchedILPContext& ctx, int num_vopd_odd_minus_even, bool* use_vopd,
+                   unsigned current, unsigned candidate)
+{
+   if (can_use_vopd(ctx, candidate)) {
+      /* If we can form a VOPD instruction, always prefer to do so. */
+      if (!*use_vopd) {
+         *use_vopd = true;
+         return true;
+      }
+   } else {
+      if (*use_vopd)
+         return false;
+
+      VOPDInfo current_vopd = ctx.vopd[current];
+      VOPDInfo candidate_vopd = ctx.vopd[candidate];
+
+      /* Delay scheduling VOPD-capable instructions in case an opportunity appears later. */
+      bool current_vopd_capable = current_vopd.op != aco_opcode::num_opcodes;
+      bool candidate_vopd_capable = candidate_vopd.op != aco_opcode::num_opcodes;
+      if (current_vopd_capable != candidate_vopd_capable)
+         return !candidate_vopd_capable;
+
+      /* If we have to select from VOPD-capable instructions, prefer maintaining a balance of
+       * odd/even instructions, in case selecting this instruction fails to make a pair.
+       */
+      if (current_vopd_capable && num_vopd_odd_minus_even != 0) {
+         assert(candidate_vopd_capable);
+         bool prefer_vopd_dst_odd = num_vopd_odd_minus_even > 0;
+         if (current_vopd.is_dst_odd != candidate_vopd.is_dst_odd)
+            return prefer_vopd_dst_odd ? candidate_vopd.is_dst_odd : !candidate_vopd.is_dst_odd;
+      }
+   }
+
+   return ctx.nodes[candidate].priority > ctx.nodes[current].priority;
+}
+
+unsigned
+select_instruction_vopd(const SchedILPContext& ctx, bool* use_vopd)
+{
+   mask_t mask = ctx.active_mask;
+
+   if (ctx.next_non_reorderable != UINT8_MAX)
+      mask = ctx.nodes[ctx.next_non_reorderable].dependency_mask;
+
+   if (mask == 0)
+      return ctx.next_non_reorderable;
+
+   int num_vopd_odd_minus_even =
+      (int)util_bitcount(ctx.vopd_odd_mask & mask) - (int)util_bitcount(ctx.vopd_even_mask & mask);
+
+   unsigned cur = -1u;
+   *use_vopd = false;
+   u_foreach_bit (i, mask) {
+      const InstrInfo& candidate = ctx.nodes[i];
+
+      /* Check if the candidate has pending dependencies. */
+      if (candidate.dependency_mask)
+         continue;
+
+      if (cur == -1u) {
+         cur = i;
+         *use_vopd = can_use_vopd(ctx, i);
+      } else if (compare_nodes_vopd(ctx, num_vopd_odd_minus_even, use_vopd, cur, i)) {
+         cur = i;
+      }
+   }
+
+   assert(cur != -1u);
+   return cur;
+}
+
+Instruction*
+create_vopd_instruction(const SchedILPContext& ctx, unsigned idx)
+{
+   Instruction* x = ctx.prev_info.instr;
+   Instruction* y = ctx.nodes[idx].instr;
+   aco_opcode opx = ctx.prev_vopd_info.op;
+   aco_opcode opy = ctx.vopd[idx].op;
+   if (ctx.prev_vopd_info.is_opy_only) {
+      std::swap(x, y);
+      std::swap(opx, opy);
+   }
+
+   VOPD_instruction* instr = create_instruction<VOPD_instruction>(
+      opx, Format::VOPD, x->operands.size() + y->operands.size(), 2);
+   instr->opy = opy;
+   instr->definitions[0] = x->definitions[0];
+   instr->definitions[1] = y->definitions[0];
+   std::copy(x->operands.begin(), x->operands.end(), instr->operands.begin());
+   std::copy(y->operands.begin(), y->operands.end(),
+             std::next(instr->operands.begin(), x->operands.size()));
+
+   ctx.program->statistics[aco_statistic_vopd]++;
+
+   return instr;
+}
+
 template <typename It>
 void
 do_schedule(SchedILPContext& ctx, It& insert_it, It& remove_it, It instructions_begin,
@@ -389,11 +637,22 @@ do_schedule(SchedILPContext& ctx, It& insert_it, It& remove_it, It instructions_
       add_entry(ctx, (remove_it++)->get(), i);
    }
 
+   ctx.prev_info.instr = NULL;
+
    while (ctx.active_mask) {
-      unsigned next_idx = select_instruction(ctx);
+      bool use_vopd = false;
+      unsigned next_idx =
+         ctx.is_vopd ? select_instruction_vopd(ctx, &use_vopd) : select_instruction_ilp(ctx);
       Instruction* next_instr = ctx.nodes[next_idx].instr;
 
-      (insert_it++)->reset(next_instr);
+      if (use_vopd) {
+         std::prev(insert_it)->reset(create_vopd_instruction(ctx, next_idx));
+         ctx.prev_info.instr = NULL;
+      } else {
+         (insert_it++)->reset(next_instr);
+         ctx.prev_info = ctx.nodes[next_idx];
+         ctx.prev_vopd_info = ctx.vopd[next_idx];
+      }
 
       remove_entry(ctx, next_instr, next_idx);
       ctx.nodes[next_idx].instr = NULL;
@@ -422,4 +681,21 @@ schedule_ilp(Program* program)
    }
 }
 
+void
+schedule_vopd(Program* program)
+{
+   if (program->gfx_level < GFX11 || program->wave_size != 32)
+      return;
+
+   SchedILPContext ctx = {program};
+   ctx.is_vopd = true;
+
+   for (Block& block : program->blocks) {
+      auto it = block.instructions.rbegin();
+      auto insert_it = block.instructions.rbegin();
+      do_schedule(ctx, insert_it, it, block.instructions.rbegin(), block.instructions.rend());
+      block.instructions.erase(block.instructions.begin(), insert_it.base());
+   }
+}
+
 } // namespace aco
-- 
GitLab


From 2b0b395733771044fe24305a323f255456205fc6 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 18 Jan 2024 11:54:53 +0000
Subject: [PATCH 5/5] aco: enable VOPD scheduler

fossil-db (navi31, wave32):
Totals from 75237 (94.95% of 79242) affected shaders:
Instrs: 40383337 -> 36522907 (-9.56%); split: -9.56%, +0.00%
CodeSize: 209282312 -> 209883000 (+0.29%); split: -0.18%, +0.46%
Latency: 256898944 -> 257834204 (+0.36%); split: -0.23%, +0.60%
InvThroughput: 59105835 -> 52725948 (-10.79%); split: -10.90%, +0.11%
VClause: 759487 -> 758151 (-0.18%); split: -0.18%, +0.01%
SClause: 1264895 -> 1263230 (-0.13%); split: -0.14%, +0.01%
VALU: 22886416 -> 18837085 (-17.69%)
VOPD: 0 -> 4049331 (+inf%)

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Reviewed-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_interface.cpp | 3 +++
 src/amd/compiler/aco_ir.cpp        | 3 ++-
 src/amd/compiler/aco_ir.h          | 1 +
 3 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 9c4280480468a..f6bc400b444eb 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -200,6 +200,9 @@ aco_postprocess_shader(const struct aco_compiler_options* options,
    aco::lower_to_hw_instr(program.get());
    validate(program.get());
 
+   if (!options->optimisations_disabled && !(aco::debug_flags & aco::DEBUG_NO_SCHED_VOPD))
+      aco::schedule_vopd(program.get());
+
    /* Schedule hardware instructions for ILP */
    if (!options->optimisations_disabled && !(aco::debug_flags & aco::DEBUG_NO_SCHED_ILP))
       aco::schedule_ilp(program.get());
diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index ea49a10da5c7c..1a54f7de2e491 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -45,8 +45,9 @@ static const struct debug_control aco_debug_options[] = {
    {"force-waitdeps", DEBUG_FORCE_WAITDEPS},
    {"novn", DEBUG_NO_VN},
    {"noopt", DEBUG_NO_OPT},
-   {"nosched", DEBUG_NO_SCHED | DEBUG_NO_SCHED_ILP},
+   {"nosched", DEBUG_NO_SCHED | DEBUG_NO_SCHED_ILP | DEBUG_NO_SCHED_VOPD},
    {"nosched-ilp", DEBUG_NO_SCHED_ILP},
+   {"nosched-vopd", DEBUG_NO_SCHED_VOPD},
    {"perfinfo", DEBUG_PERF_INFO},
    {"liveinfo", DEBUG_LIVE_INFO},
    {NULL, 0}};
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 7c74d2fc73ee4..3863cf11b7205 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -58,6 +58,7 @@ enum {
    DEBUG_FORCE_WAITDEPS = 0x200,
    DEBUG_NO_VALIDATE_IR = 0x400,
    DEBUG_NO_SCHED_ILP = 0x800,
+   DEBUG_NO_SCHED_VOPD = 0x1000,
 };
 
 enum storage_class : uint8_t {
-- 
GitLab

