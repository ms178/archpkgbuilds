From 6be56c86ab91615be1949516c2efbcbc89712c17 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Thu, 1 Jun 2023 13:03:39 +0100
Subject: [PATCH 1/6] aco: insert s_barrier during waitcnt pass

So that this is done after the post-RA scheduler.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_insert_waitcnt.cpp    | 23 ++++++++++++++++++++--
 src/amd/compiler/aco_lower_to_hw_instr.cpp | 12 -----------
 2 files changed, 21 insertions(+), 14 deletions(-)

diff --git a/src/amd/compiler/aco_insert_waitcnt.cpp b/src/amd/compiler/aco_insert_waitcnt.cpp
index 0209f44c377a0..82aa7539a3d58 100644
--- a/src/amd/compiler/aco_insert_waitcnt.cpp
+++ b/src/amd/compiler/aco_insert_waitcnt.cpp
@@ -1040,6 +1040,22 @@ emit_delay_alu(wait_ctx& ctx, std::vector<aco_ptr<Instruction>>& instructions,
    delay = alu_delay_info();
 }
 
+void
+emit_barrier(Program *program, std::vector<aco_ptr<Instruction>>& instructions,
+             aco_ptr<Instruction>& instr)
+{
+   /* Anything larger than a workgroup isn't possible. Anything smaller requires no instructions and
+    * this pseudo instruction would only be included to control optimizations.
+    */
+   if (instr->barrier().exec_scope == scope_workgroup &&
+       program->workgroup_size > program->wave_size) {
+      SOPP_instruction* inst =
+         create_instruction<SOPP_instruction>(aco_opcode::s_barrier, Format::SOPP, 0, 0);
+      inst->block = -1;
+      instructions.emplace_back(inst);
+   }
+}
+
 void
 handle_block(Program* program, Block& block, wait_ctx& ctx)
 {
@@ -1059,7 +1075,7 @@ handle_block(Program* program, Block& block, wait_ctx& ctx)
          gen_alu(instr.get(), ctx);
       gen(instr.get(), ctx);
 
-      if (instr->format != Format::PSEUDO_BARRIER && !is_wait && !is_delay_alu) {
+      if (!is_wait && !is_delay_alu) {
          if (instr->isVINTERP_INREG() && queued_imm.exp != wait_imm::unset_counter) {
             instr->vinterp_inreg().wait_exp = MIN2(instr->vinterp_inreg().wait_exp, queued_imm.exp);
             queued_imm.exp = wait_imm::unset_counter;
@@ -1074,7 +1090,10 @@ handle_block(Program* program, Block& block, wait_ctx& ctx)
             instr->opcode == aco_opcode::ds_ordered_count &&
             !((instr->ds().offset1 | (instr->ds().offset0 >> 8)) & 0x1);
 
-         new_instructions.emplace_back(std::move(instr));
+         if (instr->opcode == aco_opcode::p_barrier)
+            emit_barrier(program, new_instructions, instr);
+         else
+            new_instructions.emplace_back(std::move(instr));
          perform_barrier(ctx, queued_imm, sync_info, semantic_acquire);
 
          if (is_ordered_count_acquire)
diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index dedb84e568c60..5df84e7428d34 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -3013,18 +3013,6 @@ lower_to_hw_instr(Program* program)
                            reduce.operands[2].physReg(),    // vtmp
                            reduce.definitions[2].physReg(), // sitmp
                            reduce.operands[0], reduce.definitions[0]);
-         } else if (instr->isBarrier()) {
-            Pseudo_barrier_instruction& barrier = instr->barrier();
-
-            /* Anything larger than a workgroup isn't possible. Anything
-             * smaller requires no instructions and this pseudo instruction
-             * would only be included to control optimizations. */
-            bool emit_s_barrier = barrier.exec_scope == scope_workgroup &&
-                                  program->workgroup_size > program->wave_size;
-
-            bld.insert(std::move(instr));
-            if (emit_s_barrier)
-               bld.sopp(aco_opcode::s_barrier);
          } else if (instr->opcode == aco_opcode::p_cvt_f16_f32_rtne) {
             float_mode new_mode = block->fp_mode;
             new_mode.round16_64 = fp_round_ne;
-- 
GitLab


From f569894fb56a4aa50df08696bd0349d48c674941 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Mon, 22 May 2023 14:15:58 +0100
Subject: [PATCH 2/6] aco: add VOPD format

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp        | 29 +++++++++++
 src/amd/compiler/aco_builder_h.py         |  1 +
 src/amd/compiler/aco_ir.h                 | 21 +++++++-
 src/amd/compiler/aco_opcodes.py           | 26 ++++++++++
 src/amd/compiler/aco_print_ir.cpp         |  5 ++
 src/amd/compiler/tests/test_assembler.cpp | 59 +++++++++++++++++++++++
 6 files changed, 140 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 49508e9613795..1500984a12131 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -468,6 +468,35 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
       out.push_back(encoding);
       break;
    }
+   case Format::VOPD: {
+      VOPD_instruction& vopd = instr->vopd();
+      uint32_t encoding = (0b110010 << 26);
+      encoding |= reg(ctx, instr->operands[0]);
+      if (instr->opcode != aco_opcode::v_dual_mov_b32)
+         encoding |= reg(ctx, instr->operands[1], 8) << 9;
+      encoding |= (uint32_t)ctx.opcode[(int)vopd.opy] << 17;
+      encoding |= opcode << 22;
+      out.push_back(encoding);
+
+      unsigned opy_start = instr->opcode == aco_opcode::v_dual_mov_b32 ? 1 : 2;
+      switch (instr->opcode) {
+      case aco_opcode::v_dual_fmac_f32:
+      case aco_opcode::v_dual_fmaak_f32:
+      case aco_opcode::v_dual_fmamk_f32:
+      case aco_opcode::v_dual_cndmask_b32:
+      case aco_opcode::v_dual_dot2acc_f32_f16:
+      case aco_opcode::v_dual_dot2acc_f32_bf16: opy_start = 3; break;
+      default: break;
+      }
+
+      encoding = reg(ctx, instr->operands[opy_start]);
+      if (vopd.opy != aco_opcode::v_dual_mov_b32)
+         encoding |= reg(ctx, instr->operands[opy_start + 1], 8) << 9;
+      encoding |= (reg(ctx, instr->definitions[1], 8) >> 1) << 17;
+      encoding |= reg(ctx, instr->definitions[0], 8) << 24;
+      out.push_back(encoding);
+      break;
+   }
    case Format::DS: {
       DS_instruction& ds = instr->ds();
       uint32_t encoding = (0b110110 << 26);
diff --git a/src/amd/compiler/aco_builder_h.py b/src/amd/compiler/aco_builder_h.py
index 4d56d06758514..f07827b6ace9e 100644
--- a/src/amd/compiler/aco_builder_h.py
+++ b/src/amd/compiler/aco_builder_h.py
@@ -571,6 +571,7 @@ formats = [("pseudo", [Format.PSEUDO], 'Pseudo_instruction', list(itertools.prod
            ("vopc_sdwa", [Format.VOPC, Format.SDWA], 'SDWA_instruction', itertools.product([1, 2], [2])),
            ("vop3", [Format.VOP3], 'VALU_instruction', [(1, 3), (1, 2), (1, 1), (2, 2)]),
            ("vop3p", [Format.VOP3P], 'VALU_instruction', [(1, 2), (1, 3)]),
+           ("vopd", [Format.VOPD], 'VOPD_instruction', [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6)]),
            ("vinterp_inreg", [Format.VINTERP_INREG], 'VINTERP_inreg_instruction', [(1, 3)]),
            ("vintrp", [Format.VINTRP], 'VINTRP_instruction', [(1, 2), (1, 3)]),
            ("vop1_dpp", [Format.VOP1, Format.DPP16], 'DPP16_instruction', [(1, 1)]),
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 2fc50c2d11976..e3cea4615b89b 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -958,6 +958,7 @@ struct Pseudo_reduction_instruction;
 struct VALU_instruction;
 struct VINTERP_inreg_instruction;
 struct VINTRP_instruction;
+struct VOPD_instruction;
 struct DPP16_instruction;
 struct DPP8_instruction;
 struct SDWA_instruction;
@@ -1211,6 +1212,17 @@ struct Instruction {
       return *(VINTERP_inreg_instruction*)this;
    }
    constexpr bool isVINTERP_INREG() const noexcept { return format == Format::VINTERP_INREG; }
+   VOPD_instruction& vopd() noexcept
+   {
+      assert(isVOPD());
+      return *(VOPD_instruction*)this;
+   }
+   const VOPD_instruction& vopd() const noexcept
+   {
+      assert(isVOPD());
+      return *(VOPD_instruction*)this;
+   }
+   constexpr bool isVOPD() const noexcept { return format == Format::VOPD; }
    constexpr bool isVOP1() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP1; }
    constexpr bool isVOP2() const noexcept { return (uint16_t)format & (uint16_t)Format::VOP2; }
    constexpr bool isVOPC() const noexcept { return (uint16_t)format & (uint16_t)Format::VOPC; }
@@ -1279,7 +1291,8 @@ struct Instruction {
    }
    constexpr bool isVALU() const noexcept
    {
-      return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P() || isVINTERP_INREG();
+      return isVOP1() || isVOP2() || isVOPC() || isVOP3() || isVOP3P() || isVINTERP_INREG() ||
+             isVOPD();
    }
 
    constexpr bool isSALU() const noexcept
@@ -1368,6 +1381,12 @@ struct VINTERP_inreg_instruction : public VALU_instruction {
 static_assert(sizeof(VINTERP_inreg_instruction) == sizeof(VALU_instruction) + 4,
               "Unexpected padding");
 
+struct VOPD_instruction : public VALU_instruction {
+   aco_opcode opy;
+   uint16_t padding;
+};
+static_assert(sizeof(VOPD_instruction) == sizeof(VALU_instruction) + 4, "Unexpected padding");
+
 /**
  * Data Parallel Primitives Format:
  * This format can be used for VOP1, VOP2 or VOPC instructions.
diff --git a/src/amd/compiler/aco_opcodes.py b/src/amd/compiler/aco_opcodes.py
index 1cf23b5e061b7..585586d9a517a 100644
--- a/src/amd/compiler/aco_opcodes.py
+++ b/src/amd/compiler/aco_opcodes.py
@@ -88,6 +88,7 @@ class Format(IntEnum):
    # Vector Parameter Interpolation Formats
    VINTRP = auto()
    # Vector ALU Formats
+   VOPD = auto()
    VINTERP_INREG = auto()
    VOP1 = 1 << 7
    VOP2 = 1 << 8
@@ -186,6 +187,8 @@ class Format(IntEnum):
       elif self == Format.VOP3P:
          return [('uint8_t', 'opsel_lo', None),
                  ('uint8_t', 'opsel_hi', None)]
+      elif self == Format.VOPD:
+         return [('aco_opcode', 'opy', None)]
       elif self == Format.VINTERP_INREG:
          return [('unsigned', 'wait_exp', 7),
                  ('uint8_t', 'opsel', 0)]
@@ -1272,6 +1275,29 @@ for (gfx6, gfx7, gfx8, gfx9, gfx10, gfx11, name, in_mod, out_mod, defs, ops, cls
    opcode(name, gfx7, gfx9, gfx10, gfx11, Format.VOP3, cls, in_mod, out_mod, definitions = defs, operands = ops)
 
 
+VOPD = {
+   (0x00, "v_dual_fmac_f32"),
+   (0x01, "v_dual_fmaak_f32"),
+   (0x02, "v_dual_fmamk_f32"),
+   (0x03, "v_dual_mul_f32"),
+   (0x04, "v_dual_add_f32"),
+   (0x05, "v_dual_sub_f32"),
+   (0x06, "v_dual_subrev_f32"),
+   (0x07, "v_dual_mul_dx9_zero_f32"),
+   (0x08, "v_dual_mov_b32"),
+   (0x09, "v_dual_cndmask_b32"),
+   (0x0a, "v_dual_max_f32"),
+   (0x0b, "v_dual_min_f32"),
+   (0x0c, "v_dual_dot2acc_f32_f16"),
+   (0x0d, "v_dual_dot2acc_f32_bf16"),
+   (0x10, "v_dual_add_nc_u32"),
+   (0x11, "v_dual_lshlrev_b32"),
+   (0x12, "v_dual_and_b32"),
+}
+for gfx11, name in VOPD:
+   opcode(name, -1, -1, -1, gfx11, format = Format.VOPD, cls = InstrClass.Valu32)
+
+
 # DS instructions: 3 inputs (1 addr, 2 data), 1 output
 DS = {
    (0x00, 0x00, 0x00, 0x00, 0x00, 0x00, "ds_add_u32"),
diff --git a/src/amd/compiler/aco_print_ir.cpp b/src/amd/compiler/aco_print_ir.cpp
index 3fc32223a41b4..335d9036f5bd3 100644
--- a/src/amd/compiler/aco_print_ir.cpp
+++ b/src/amd/compiler/aco_print_ir.cpp
@@ -443,6 +443,11 @@ print_instr_format_specific(enum amd_gfx_level gfx_level, const Instruction* ins
       fprintf(output, " attr%d.%c", vintrp.attribute, "xyzw"[vintrp.component]);
       break;
    }
+   case Format::VOPD: {
+      const VOPD_instruction& vopd = instr->vopd();
+      fprintf(output, " %s", instr_info.name[(int)vopd.opy]);
+      break;
+   }
    case Format::DS: {
       const DS_instruction& ds = instr->ds();
       if (ds.offset0)
diff --git a/src/amd/compiler/tests/test_assembler.cpp b/src/amd/compiler/tests/test_assembler.cpp
index a7106e98686a4..8c92e669a6493 100644
--- a/src/amd/compiler/tests/test_assembler.cpp
+++ b/src/amd/compiler/tests/test_assembler.cpp
@@ -1055,3 +1055,62 @@ BEGIN_TEST(assembler.vop3_dpp)
 
    finish_assembler_test();
 END_TEST
+
+BEGIN_TEST(assembler.vopd)
+   if (!setup_cs(NULL, GFX11))
+      return;
+
+   Definition dst_v0 = bld.def(v1);
+   dst_v0.setFixed(PhysReg(256));
+
+   Definition dst_v1 = bld.def(v1);
+   dst_v1.setFixed(PhysReg(256 + 1));
+
+   Operand op_v0(bld.tmp(v1));
+   op_v0.setFixed(PhysReg(256 + 0));
+
+   Operand op_v1(bld.tmp(v1));
+   op_v1.setFixed(PhysReg(256 + 1));
+
+   Operand op_v2(bld.tmp(v1));
+   op_v2.setFixed(PhysReg(256 + 2));
+
+   Operand op_v3(bld.tmp(v1));
+   op_v3.setFixed(PhysReg(256 + 3));
+
+   Operand op_s0(bld.tmp(s1));
+   op_s0.setFixed(PhysReg(0));
+
+   Operand op_vcc(bld.tmp(s1));
+   op_vcc.setFixed(vcc);
+
+   //>> BB0:
+   //! v_dual_mov_b32 v0, v0 :: v_dual_mov_b32 v1, v1 ; ca100100 00000101
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, op_v0, op_v1, aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mov_b32 v0, 0x60 :: v_dual_mov_b32 v1, s0 ; ca1000ff 00000000 00000060
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, Operand::c32(96), op_s0,
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mov_b32 v0, s0 :: v_dual_mov_b32 v1, 0x60 ; ca100000 000000ff 00000060
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, op_s0, Operand::c32(96),
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mul_f32 v0, v0, v1 :: v_dual_mov_b32 v1, v2 ; c8d00300 00000102
+   bld.vopd(aco_opcode::v_dual_mul_f32, dst_v0, dst_v1, op_v0, op_v1, op_v2,
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_fmac_f32 v0, v1, v2 :: v_dual_mov_b32 v1, v3 ; c8100501 00000103
+   bld.vopd(aco_opcode::v_dual_fmac_f32, dst_v0, dst_v1, op_v1, op_v2, op_v0, op_v3,
+            aco_opcode::v_dual_mov_b32);
+
+   //! v_dual_mov_b32 v0, v0 :: v_dual_and_b32 v1, v1, v2 ; ca240100 00000501
+   bld.vopd(aco_opcode::v_dual_mov_b32, dst_v0, dst_v1, op_v0, op_v1, op_v2,
+            aco_opcode::v_dual_and_b32);
+
+   //! v_dual_cndmask_b32 v0, v0, v1 :: v_dual_cndmask_b32 v1, v2, v3 ; ca520300 00000702
+   bld.vopd(aco_opcode::v_dual_cndmask_b32, dst_v0, dst_v1, op_v0, op_v1, op_vcc, op_v2, op_v3,
+            op_vcc, aco_opcode::v_dual_cndmask_b32);
+
+   finish_assembler_test();
+END_TEST
-- 
GitLab


From ade0cf3fedbc41a3ecdfc4def3c4b66bcdbdc805 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 24 May 2023 18:43:13 +0100
Subject: [PATCH 3/6] aco: add VOPD statistic

---
 src/amd/compiler/aco_interface.cpp | 1 +
 src/amd/compiler/aco_shader_info.h | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 6ae3405b3e1f5..cd016231db409 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -59,6 +59,7 @@ static const std::array<aco_compiler_statistic_info, aco_num_statistics> statist
    ret[aco_statistic_salu] = aco_compiler_statistic_info{"SALU", "Number of SALU instructions"};
    ret[aco_statistic_vmem] = aco_compiler_statistic_info{"VMEM", "Number of VMEM instructions"};
    ret[aco_statistic_smem] = aco_compiler_statistic_info{"SMEM", "Number of SMEM instructions"};
+   ret[aco_statistic_vopd] = aco_compiler_statistic_info{"VOPD", "Number of VOPD instructions"};
    return ret;
 }();
 
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 847bda0275106..43cf7c994e89f 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -229,6 +229,7 @@ enum aco_statistic {
    aco_statistic_salu,
    aco_statistic_vmem,
    aco_statistic_smem,
+   aco_statistic_vopd,
    aco_num_statistics
 };
 
-- 
GitLab


From 13b127b261c0790a570d6e64d4c5e4fc80b2b20b Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 14 Jun 2023 18:46:28 +0100
Subject: [PATCH 4/6] aco/util: add small_vec

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_util.h | 147 ++++++++++++++++++++++++++++++++++++
 1 file changed, 147 insertions(+)

diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 9659f5a98f623..7fdab9d6f068d 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -1031,6 +1031,153 @@ using bitfield_array64 = bitfield_array<T, offset, size, uint64_t>;
 
 using bitarray8 = bitfield_array<uint8_t, 0, 8, uint8_t>;
 
+/*
+ * Resizable array optimized for small lengths. If it's smaller than Size, the elements will be
+ * inlined into the object.
+ */
+template <typename T, uint32_t Size> class small_vec {
+public:
+   static_assert(std::is_trivially_copyable<T>::value);
+   static_assert(std::is_trivially_destructible<T>::value);
+
+   using value_type = T;
+   using pointer = value_type*;
+   using const_pointer = const value_type*;
+   using reference = value_type&;
+   using const_reference = const value_type&;
+   using iterator = pointer;
+   using const_iterator = const_pointer;
+   using reverse_iterator = std::reverse_iterator<iterator>;
+   using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+   using size_type = uint16_t;
+   using difference_type = std::ptrdiff_t;
+
+   constexpr small_vec() = default;
+   constexpr small_vec(const small_vec&) = delete;
+
+   ~small_vec()
+   {
+      if (capacity > Size)
+         free(data);
+   }
+
+   constexpr small_vec& operator=(const small_vec&) = delete;
+
+   constexpr iterator begin() noexcept { return capacity > Size ? data : inline_data; }
+
+   constexpr const_iterator begin() const noexcept { return capacity > Size ? data : inline_data; }
+
+   constexpr iterator end() noexcept { return std::next(begin(), length); }
+
+   constexpr const_iterator end() const noexcept { return std::next(begin(), length); }
+
+   constexpr const_iterator cbegin() const noexcept { return begin(); }
+
+   constexpr const_iterator cend() const noexcept { return std::next(begin(), length); }
+
+   constexpr reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
+
+   constexpr const_reverse_iterator rbegin() const noexcept
+   {
+      return const_reverse_iterator(end());
+   }
+
+   constexpr reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
+
+   constexpr const_reverse_iterator rend() const noexcept
+   {
+      return const_reverse_iterator(begin());
+   }
+
+   constexpr const_reverse_iterator crbegin() const noexcept
+   {
+      return const_reverse_iterator(cend());
+   }
+
+   constexpr const_reverse_iterator crend() const noexcept
+   {
+      return const_reverse_iterator(cbegin());
+   }
+
+   constexpr reference operator[](const size_type index) noexcept
+   {
+      assert(length > index);
+      return *(std::next(begin(), index));
+   }
+
+   constexpr const_reference operator[](const size_type index) const noexcept
+   {
+      assert(length > index);
+      return *(std::next(begin(), index));
+   }
+
+   constexpr reference back() noexcept
+   {
+      assert(length > 0);
+      return *(std::next(begin(), length - 1));
+   }
+
+   constexpr const_reference back() const noexcept
+   {
+      assert(length > 0);
+      return *(std::next(begin(), length - 1));
+   }
+
+   constexpr reference front() noexcept
+   {
+      assert(length > 0);
+      return *begin();
+   }
+
+   constexpr const_reference front() const noexcept
+   {
+      assert(length > 0);
+      return *cbegin();
+   }
+
+   constexpr bool empty() const noexcept { return length == 0; }
+
+   constexpr size_type size() const noexcept { return length; }
+
+   constexpr void pop_back() noexcept
+   {
+      assert(length > 0);
+      --length;
+   }
+
+   template <typename... Args> constexpr void emplace_back(Args... args) noexcept
+   {
+      if (length == capacity) {
+         if (capacity > Size) {
+            capacity *= 2;
+            data = (T*)realloc(data, sizeof(T) * capacity);
+         } else {
+            capacity *= 2;
+            T* ptr = (T*)malloc(sizeof(T) * capacity);
+            memcpy(ptr, inline_data, sizeof(T) * length);
+            data = ptr;
+         }
+      }
+      *std::next(begin(), length++) = T(args...);
+   }
+
+   constexpr void clear() noexcept
+   {
+      if (capacity > Size)
+         free(data);
+      length = 0;
+      capacity = 0;
+   }
+
+private:
+   uint32_t length = 0;
+   uint32_t capacity = Size;
+   union {
+      T* data = NULL;
+      T inline_data[Size];
+   };
+};
+
 } // namespace aco
 
 #endif // ACO_UTIL_H
-- 
GitLab
