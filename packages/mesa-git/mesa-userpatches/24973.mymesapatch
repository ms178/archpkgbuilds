From 985f165ba6c49a5d54648c74aad0bb3967d7b3ee Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 8 Aug 2023 13:14:19 +0800
Subject: [PATCH 01/16] ac,radeonsi: move ps arg pos_fixed_pt to ac_shader_args

It's a HW init reg, not driver spec user sgpr. radv just
doesn't use it. Move it to amd common for aco ps prolog
usage.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_shader_args.h                   | 1 +
 src/gallium/drivers/radeonsi/si_nir_lower_abi.c   | 4 ++--
 src/gallium/drivers/radeonsi/si_shader.c          | 6 +++---
 src/gallium/drivers/radeonsi/si_shader_internal.h | 1 -
 4 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/amd/common/ac_shader_args.h b/src/amd/common/ac_shader_args.h
index 3c4ae916dfcb8..1b2b6b30deade 100644
--- a/src/amd/common/ac_shader_args.h
+++ b/src/amd/common/ac_shader_args.h
@@ -142,6 +142,7 @@ struct ac_shader_args {
    struct ac_arg linear_sample;
    struct ac_arg linear_center;
    struct ac_arg linear_centroid;
+   struct ac_arg pos_fixed_pt;
 
    /* CS */
    struct ac_arg local_invocation_ids;
diff --git a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
index 233f1c4fedbfe..d492793549150 100644
--- a/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
+++ b/src/gallium/drivers/radeonsi/si_nir_lower_abi.c
@@ -108,10 +108,10 @@ fetch_framebuffer(nir_builder *b, struct si_shader_args *args,
    unsigned chan = 0;
    nir_def *vec[4] = {undef, undef, undef, undef};
 
-   vec[chan++] = ac_nir_unpack_arg(b, &args->ac, args->pos_fixed_pt, 0, 16);
+   vec[chan++] = ac_nir_unpack_arg(b, &args->ac, args->ac.pos_fixed_pt, 0, 16);
 
    if (!key->ps.mono.fbfetch_is_1D)
-      vec[chan++] = ac_nir_unpack_arg(b, &args->ac, args->pos_fixed_pt, 16, 16);
+      vec[chan++] = ac_nir_unpack_arg(b, &args->ac, args->ac.pos_fixed_pt, 16, 16);
 
    /* Get the current render target layer index. */
    if (key->ps.mono.fbfetch_layered)
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index dabf8d94ba4ed..69fa35f7279fc 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -667,7 +667,7 @@ void si_init_shader_args(struct si_shader *shader, struct si_shader_args *args)
                          SI_PARAM_ANCILLARY);
       si_add_arg_checked(&args->ac, AC_ARG_VGPR, 1, AC_ARG_FLOAT, &args->ac.sample_coverage,
                          SI_PARAM_SAMPLE_COVERAGE);
-      si_add_arg_checked(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->pos_fixed_pt,
+      si_add_arg_checked(&args->ac, AC_ARG_VGPR, 1, AC_ARG_INT, &args->ac.pos_fixed_pt,
                          SI_PARAM_POS_FIXED_PT);
 
       if (shader->use_aco) {
@@ -2090,8 +2090,8 @@ static void si_nir_emit_polygon_stipple(nir_shader *nir, struct si_shader_args *
     * Since the stipple pattern is 32x32 and it repeats, just get 5 bits
     * per coordinate to get the repeating effect.
     */
-   nir_def *pos_x = ac_nir_unpack_arg(b, &args->ac, args->pos_fixed_pt, 0, 5);
-   nir_def *pos_y = ac_nir_unpack_arg(b, &args->ac, args->pos_fixed_pt, 16, 5);
+   nir_def *pos_x = ac_nir_unpack_arg(b, &args->ac, args->ac.pos_fixed_pt, 0, 5);
+   nir_def *pos_y = ac_nir_unpack_arg(b, &args->ac, args->ac.pos_fixed_pt, 16, 5);
 
    nir_def *zero = nir_imm_int(b, 0);
    /* The stipple pattern is 32x32, each row has 32 bits. */
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 95d8c3dfbe792..d4d201092c553 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -57,7 +57,6 @@ struct si_shader_args {
    /* API TCS & TES */
    struct ac_arg tes_offchip_addr;
    /* PS */
-   struct ac_arg pos_fixed_pt;
    struct ac_arg alpha_reference;
    struct ac_arg color_start;
    /* CS */
-- 
GitLab


From 214f5b7360d43c966c5e049f1254fd1d5a6ffe31 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 15 Sep 2023 16:42:25 +0800
Subject: [PATCH 02/16] aco: do not eliminate final exec write when
 p_end_with_regs block

p_end_with_regs just partially end the program, next part need
exec mask to be set correctly. For example p_end_wqm will generate
a exec restore from WQM mode after p_end_with_regs.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    |  2 ++
 src/amd/compiler/aco_ir.h                     |  1 +
 src/amd/compiler/aco_ssa_elimination.cpp      | 36 ++++++++++---------
 3 files changed, 23 insertions(+), 16 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 8dda7eb837759..d70964d9b140d 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10969,6 +10969,8 @@ build_end_with_regs(isel_context* ctx, std::vector<Operand>& regs)
       end->operands[i] = regs[i];
 
    ctx->block->instructions.emplace_back(std::move(end));
+
+   ctx->block->kind |= block_kind_end_with_regs;
 }
 
 static void
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index b8f6bc3d2e717..17fbb5ab6b567 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1887,6 +1887,7 @@ enum block_kind {
    block_kind_uses_discard = 1 << 12,
    block_kind_resume = 1 << 13,
    block_kind_export_end = 1 << 14,
+   block_kind_end_with_regs = 1 << 15,
 };
 
 struct RegisterDemand {
diff --git a/src/amd/compiler/aco_ssa_elimination.cpp b/src/amd/compiler/aco_ssa_elimination.cpp
index 80644140b8bd4..9a309c7f3e05d 100644
--- a/src/amd/compiler/aco_ssa_elimination.cpp
+++ b/src/amd/compiler/aco_ssa_elimination.cpp
@@ -547,24 +547,28 @@ eliminate_useless_exec_writes_in_block(ssa_elimination_ctx& ctx, Block& block)
 {
    /* Check if any successor needs the outgoing exec mask from the current block. */
 
-   bool copy_to_exec = false;
-   bool copy_from_exec = false;
-
-   for (const auto& successor_phi_info : ctx.linear_phi_info[block.index]) {
-      copy_to_exec |= successor_phi_info.def.physReg() == exec;
-      copy_from_exec |= successor_phi_info.op.physReg() == exec;
-   }
-
    bool exec_write_used;
-   if (copy_from_exec)
+   if (block.kind & block_kind_end_with_regs) {
       exec_write_used = true;
-   else if (copy_to_exec)
-      exec_write_used = false;
-   else
-      /* blocks_incoming_exec_used is initialized to true, so this is correct even for loops. */
-      exec_write_used =
-         std::any_of(block.linear_succs.begin(), block.linear_succs.end(),
-                     [&ctx](int succ_idx) { return ctx.blocks_incoming_exec_used[succ_idx]; });
+   } else {
+      bool copy_to_exec = false;
+      bool copy_from_exec = false;
+
+      for (const auto& successor_phi_info : ctx.linear_phi_info[block.index]) {
+         copy_to_exec |= successor_phi_info.def.physReg() == exec;
+         copy_from_exec |= successor_phi_info.op.physReg() == exec;
+      }
+
+      if (copy_from_exec)
+         exec_write_used = true;
+      else if (copy_to_exec)
+         exec_write_used = false;
+      else
+         /* blocks_incoming_exec_used is initialized to true, so this is correct even for loops. */
+         exec_write_used =
+            std::any_of(block.linear_succs.begin(), block.linear_succs.end(),
+                        [&ctx](int succ_idx) { return ctx.blocks_incoming_exec_used[succ_idx]; });
+   }
 
    /* Collect information about the branching sequence. */
 
-- 
GitLab


From 7eb59644a663b0f64fc3ffd8659cdf863da5004d Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 25 Aug 2023 14:25:20 +0800
Subject: [PATCH 03/16] aco: add build_ps_end_with_regs for ps shader parts

Used by ps prolog and main part to end shader with. ps needs to
handle wqm:
1. main part may compute with args from prolog in wqm mode, so
   prolog need to compute these args in wqm mode too.
2. prolog and main part need to end with exact exec, so next
   shader part which inherit previous shader part's exec won't
   do valid job for helper threads

1 need p_end_with_regs to operate in wqm mode and itself can't
be exact, otherwise some move instruction added by it won't be
in wqm mode so helper threads' compute result is not passed to
next shader part as args.

2 is done by p_end_wqm added by finish_program automatically
after p_end_with_regs.

Piglit tests can trigger the problem:

1. gl-2.1-polygon-stipple-fs
  a. ps prolog call discard_if
  b. ps main pass wqm exec to epilog
  c. ps epilog export color for discarded pixel

2. fs-fwidth-color.shader_test
  a. ps prolog need to pass args computed in wqm mode
  b. set p_end_with_regs to exact will end wqm mode before
     the move instructions, so helper threads's result is not
     passed to next shader part

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_insert_exec_mask.cpp      |  3 +--
 src/amd/compiler/aco_instruction_selection.cpp | 11 +++++++++++
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_insert_exec_mask.cpp b/src/amd/compiler/aco_insert_exec_mask.cpp
index 6053874308a60..d20bc29b120db 100644
--- a/src/amd/compiler/aco_insert_exec_mask.cpp
+++ b/src/amd/compiler/aco_insert_exec_mask.cpp
@@ -89,8 +89,7 @@ needs_exact(aco_ptr<Instruction>& instr)
        * epilog without considering the exec mask.
        */
       return instr->isEXP() || instr->opcode == aco_opcode::p_jump_to_epilog ||
-             instr->opcode == aco_opcode::p_dual_src_export_gfx11 ||
-             instr->opcode == aco_opcode::p_end_with_regs;
+             instr->opcode == aco_opcode::p_dual_src_export_gfx11;
    }
 }
 
diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index d70964d9b140d..be5e29d9f34bf 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10973,6 +10973,17 @@ build_end_with_regs(isel_context* ctx, std::vector<Operand>& regs)
    ctx->block->kind |= block_kind_end_with_regs;
 }
 
+static void
+build_ps_end_with_regs(isel_context* ctx, std::vector<Operand>& regs, bool needs_wqm)
+{
+   build_end_with_regs(ctx, regs);
+
+   if (needs_wqm)
+      set_wqm(ctx, true);
+
+   ctx->program->needs_exact = true;
+}
+
 static void
 create_tcs_jump_to_epilog(isel_context* ctx)
 {
-- 
GitLab


From 7de625e8d62745a29f9ae882ae12fb71f9377c42 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 9 Aug 2023 15:07:39 +0800
Subject: [PATCH 04/16] aco: add ps prolog generation for radeonsi

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 271 +++++++++++++++++-
 src/amd/compiler/aco_interface.cpp            |  10 +
 src/amd/compiler/aco_interface.h              |   6 +
 src/amd/compiler/aco_ir.h                     |   4 +
 src/amd/compiler/aco_shader_info.h            |  22 ++
 5 files changed, 304 insertions(+), 9 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index be5e29d9f34bf..686926a03f994 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -1102,6 +1102,22 @@ emit_boolean_logic(isel_context* ctx, nir_alu_instr* instr, Builder::WaveSpecifi
    bld.sop2(op, Definition(dst), bld.def(s1, scc), src0, src1);
 }
 
+void
+select_vec2(isel_context* ctx, Temp dst, Temp cond, Temp then, Temp els)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   Temp then_lo = bld.tmp(v1), then_hi = bld.tmp(v1);
+   bld.pseudo(aco_opcode::p_split_vector, Definition(then_lo), Definition(then_hi), then);
+   Temp else_lo = bld.tmp(v1), else_hi = bld.tmp(v1);
+   bld.pseudo(aco_opcode::p_split_vector, Definition(else_lo), Definition(else_hi), els);
+
+   Temp dst0 = bld.vop2(aco_opcode::v_cndmask_b32, bld.def(v1), else_lo, then_lo, cond);
+   Temp dst1 = bld.vop2(aco_opcode::v_cndmask_b32, bld.def(v1), else_hi, then_hi, cond);
+
+   bld.pseudo(aco_opcode::p_create_vector, Definition(dst), dst0, dst1);
+}
+
 void
 emit_bcsel(isel_context* ctx, nir_alu_instr* instr, Temp dst)
 {
@@ -1120,15 +1136,7 @@ emit_bcsel(isel_context* ctx, nir_alu_instr* instr, Temp dst)
 
          bld.vop2(aco_opcode::v_cndmask_b32, Definition(dst), els, then, cond);
       } else if (dst.size() == 2) {
-         Temp then_lo = bld.tmp(v1), then_hi = bld.tmp(v1);
-         bld.pseudo(aco_opcode::p_split_vector, Definition(then_lo), Definition(then_hi), then);
-         Temp else_lo = bld.tmp(v1), else_hi = bld.tmp(v1);
-         bld.pseudo(aco_opcode::p_split_vector, Definition(else_lo), Definition(else_hi), els);
-
-         Temp dst0 = bld.vop2(aco_opcode::v_cndmask_b32, bld.def(v1), else_lo, then_lo, cond);
-         Temp dst1 = bld.vop2(aco_opcode::v_cndmask_b32, bld.def(v1), else_hi, then_hi, cond);
-
-         bld.pseudo(aco_opcode::p_create_vector, Definition(dst), dst0, dst1);
+         select_vec2(ctx, dst, cond, then, els);
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
@@ -11806,6 +11814,216 @@ get_gl_vs_prolog_vertex_index(isel_context* ctx, const struct aco_gl_vs_prolog_i
    return index;
 }
 
+void
+emit_polygon_stipple(isel_context* ctx, const struct aco_ps_prolog_info* finfo)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   /* Use the fixed-point gl_FragCoord input.
+    * Since the stipple pattern is 32x32 and it repeats, just get 5 bits
+    * per coordinate to get the repeating effect.
+    */
+   Temp pos_fixed_pt = get_arg(ctx, ctx->args->pos_fixed_pt);
+   Temp addr0 = bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), pos_fixed_pt, Operand::c32(0u),
+                         Operand::c32(5u));
+   Temp addr1 = bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), pos_fixed_pt, Operand::c32(16u),
+                         Operand::c32(5u));
+
+   /* Load the buffer descriptor. */
+   Temp list = get_arg(ctx, finfo->internal_bindings);
+   list = convert_pointer_to_64_bit(ctx, list);
+   Temp desc = bld.smem(aco_opcode::s_load_dwordx4, bld.def(s4), list,
+                        Operand::c32(finfo->poly_stipple_buf_offset));
+
+   /* The stipple pattern is 32x32, each row has 32 bits. */
+   Temp offset = bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(2), addr1);
+   Temp row = bld.mubuf(aco_opcode::buffer_load_dword, bld.def(v1), desc, offset, Operand::c32(0u),
+                        0, true);
+   Temp bit = bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), row, addr0, Operand::c32(1u));
+   Temp cond = bld.vopc(aco_opcode::v_cmp_eq_u32, bld.def(bld.lm), Operand::zero(), bit);
+   bld.pseudo(aco_opcode::p_demote_to_helper, cond);
+
+   ctx->block->kind |= block_kind_uses_discard;
+   ctx->program->needs_exact = true;
+}
+
+void
+overwrite_interp_args(isel_context* ctx, const struct aco_ps_prolog_info* finfo)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   if (finfo->bc_optimize_for_persp || finfo->bc_optimize_for_linear) {
+      /* The shader should do: if (PRIM_MASK[31]) CENTROID = CENTER;
+       * The hw doesn't compute CENTROID if the whole wave only
+       * contains fully-covered quads.
+       */
+      Temp bc_optimize = get_arg(ctx, ctx->args->prim_mask);
+
+      /* enabled when bit 31 is set */
+      Temp cond =
+         bld.sopc(aco_opcode::s_cmp_lt_i32, bld.def(s1, scc), bc_optimize, Operand::zero());
+
+      /* scale 1bit scc to wave size bits used by v_cndmask */
+      if (ctx->program->info.wave_size == 64) {
+         cond = bld.sop2(aco_opcode::s_cselect_b64, bld.def(s2), Operand::c64(-1),
+                         Operand::zero(), cond);
+      } else {
+         assert(ctx->program->info.wave_size == 32);
+         cond = bld.sop2(aco_opcode::s_cselect_b32, bld.def(s1), Operand::c32(-1),
+                         Operand::zero(), cond);
+      }
+
+      if (finfo->bc_optimize_for_persp) {
+         Temp center = get_arg(ctx, ctx->args->persp_center);
+         Temp centroid = get_arg(ctx, ctx->args->persp_centroid);
+
+         Temp dst = bld.tmp(v2);
+         select_vec2(ctx, dst, cond, center, centroid);
+         ctx->arg_temps[ctx->args->persp_centroid.arg_index] = dst;
+      }
+
+      if (finfo->bc_optimize_for_linear) {
+         Temp center = get_arg(ctx, ctx->args->linear_center);
+         Temp centroid = get_arg(ctx, ctx->args->linear_centroid);
+
+         Temp dst = bld.tmp(v2);
+         select_vec2(ctx, dst, cond, center, centroid);
+         ctx->arg_temps[ctx->args->linear_centroid.arg_index] = dst;
+      }
+   }
+
+   if (finfo->force_persp_sample_interp) {
+      Temp persp_sample = get_arg(ctx, ctx->args->persp_sample);
+      ctx->arg_temps[ctx->args->persp_center.arg_index] = persp_sample;
+      ctx->arg_temps[ctx->args->persp_centroid.arg_index] = persp_sample;
+   }
+
+   if (finfo->force_linear_sample_interp) {
+      Temp linear_sample = get_arg(ctx, ctx->args->linear_sample);
+      ctx->arg_temps[ctx->args->linear_center.arg_index] = linear_sample;
+      ctx->arg_temps[ctx->args->linear_centroid.arg_index] = linear_sample;
+   }
+
+   if (finfo->force_persp_center_interp) {
+      Temp persp_center = get_arg(ctx, ctx->args->persp_center);
+      ctx->arg_temps[ctx->args->persp_sample.arg_index] = persp_center;
+      ctx->arg_temps[ctx->args->persp_centroid.arg_index] = persp_center;
+   }
+
+   if (finfo->force_linear_center_interp) {
+      Temp linear_center = get_arg(ctx, ctx->args->linear_center);
+      ctx->arg_temps[ctx->args->linear_sample.arg_index] = linear_center;
+      ctx->arg_temps[ctx->args->linear_centroid.arg_index] = linear_center;
+   }
+}
+
+void
+overwrite_samplemask_arg(isel_context* ctx, const struct aco_ps_prolog_info* finfo)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   /* Section 15.2.2 (Shader Inputs) of the OpenGL 4.5 (Core Profile) spec
+    * says:
+    *
+    *    "When per-sample shading is active due to the use of a fragment
+    *     input qualified by sample or due to the use of the gl_SampleID
+    *     or gl_SamplePosition variables, only the bit for the current
+    *     sample is set in gl_SampleMaskIn. When state specifies multiple
+    *     fragment shader invocations for a given fragment, the sample
+    *     mask for any single fragment shader invocation may specify a
+    *     subset of the covered samples for the fragment. In this case,
+    *     the bit corresponding to each covered sample will be set in
+    *     exactly one fragment shader invocation."
+    *
+    * The samplemask loaded by hardware is always the coverage of the
+    * entire pixel/fragment, so mask bits out based on the sample ID.
+    */
+   if (finfo->samplemask_log_ps_iter) {
+      Temp ancillary = get_arg(ctx, ctx->args->ancillary);
+      Temp sampleid = bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), ancillary, Operand::c32(8u),
+                               Operand::c32(4u));
+      Temp samplemask = get_arg(ctx, ctx->args->sample_coverage);
+
+      uint32_t ps_iter_mask = ac_get_ps_iter_mask(1 << finfo->samplemask_log_ps_iter);
+      Temp iter_mask = bld.copy(bld.def(v1), Operand::c32(ps_iter_mask));
+
+      Temp mask = bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), sampleid, iter_mask);
+      samplemask = bld.vop2(aco_opcode::v_and_b32, bld.def(v1), samplemask, mask);
+
+      ctx->arg_temps[ctx->args->sample_coverage.arg_index] = samplemask;
+   }
+}
+
+Temp
+get_interp_color(isel_context* ctx, int interp_vgpr, unsigned attr_index, unsigned comp)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   Temp dst = bld.tmp(v1);
+
+   Temp prim_mask = get_arg(ctx, ctx->args->prim_mask);
+
+   if (interp_vgpr != -1) {
+      /* interp args are all 2 vgprs */
+      int arg_index = ctx->args->persp_sample.arg_index + interp_vgpr / 2;
+      Temp interp_ij = ctx->arg_temps[arg_index];
+
+      emit_interp_instr(ctx, attr_index, comp, interp_ij, dst, prim_mask);
+   } else {
+      emit_interp_mov_instr(ctx, attr_index, comp, 0, dst, prim_mask);
+   }
+
+   return dst;
+}
+
+void
+interpolate_color_args(isel_context* ctx, const struct aco_ps_prolog_info* finfo,
+                       std::vector<Operand>& regs)
+{
+   if (!finfo->colors_read)
+      return;
+
+   Builder bld(ctx->program, ctx->block);
+
+   unsigned vgpr = 256 + ctx->args->num_vgprs_used;
+
+   if (finfo->color_two_side) {
+      Temp face = get_arg(ctx, ctx->args->front_face);
+      Temp is_face_positive =
+         bld.vopc(aco_opcode::v_cmp_lg_u32, bld.def(bld.lm), Operand::zero(), face);
+
+      u_foreach_bit (i, finfo->colors_read) {
+         unsigned color_index = i / 4;
+         unsigned front_index = finfo->color_attr_index[color_index];
+         int interp_vgpr = finfo->color_interp_vgpr_index[color_index];
+
+         /* If BCOLOR0 is used, BCOLOR1 is at offset "num_inputs + 1",
+          * otherwise it's at offset "num_inputs".
+          */
+         unsigned back_index = finfo->num_interp_inputs;
+         if (color_index == 1 && finfo->colors_read & 0xf)
+            back_index++;
+
+         Temp front = get_interp_color(ctx, interp_vgpr, front_index, i % 4);
+         Temp back = get_interp_color(ctx, interp_vgpr, back_index, i % 4);
+
+         Temp color =
+            bld.vop2(aco_opcode::v_cndmask_b32, bld.def(v1), back, front, is_face_positive);
+
+         regs.emplace_back(Operand(color, PhysReg{vgpr++}));
+      }
+   } else {
+      u_foreach_bit (i, finfo->colors_read) {
+         unsigned color_index = i / 4;
+         unsigned attr_index = finfo->color_attr_index[color_index];
+         int interp_vgpr = finfo->color_interp_vgpr_index[color_index];
+         Temp color = get_interp_color(ctx, interp_vgpr, attr_index, i % 4);
+
+         regs.emplace_back(Operand(color, PhysReg{vgpr++}));
+      }
+   }
+}
+
 } /* end namespace */
 
 void
@@ -12727,4 +12945,39 @@ select_gl_vs_prolog(Program* program, void* pinfo, ac_shader_config* config,
    finish_program(&ctx);
 }
 
+void
+select_ps_prolog(Program* program, void* pinfo, ac_shader_config* config,
+                 const struct aco_compiler_options* options, const struct aco_shader_info* info,
+                 const struct ac_shader_args* args)
+{
+   const struct aco_ps_prolog_info* finfo = (const struct aco_ps_prolog_info*)pinfo;
+   isel_context ctx =
+      setup_isel_context(program, 0, NULL, config, options, info, args, SWStage::FS);
+
+   ctx.block->fp_mode = program->next_fp_mode;
+
+   add_startpgm(&ctx);
+   append_logical_start(ctx.block);
+
+   if (finfo->poly_stipple)
+      emit_polygon_stipple(&ctx, finfo);
+
+   overwrite_interp_args(&ctx, finfo);
+
+   overwrite_samplemask_arg(&ctx, finfo);
+
+   std::vector<Operand> regs;
+   passthrough_all_args(&ctx, regs);
+
+   interpolate_color_args(&ctx, finfo, regs);
+
+   build_ps_end_with_regs(&ctx, regs, finfo->needs_wqm);
+
+   program->config->float_mode = program->blocks[0].fp_mode.val;
+
+   append_logical_end(ctx.block);
+
+   finish_program(&ctx);
+}
+
 } // namespace aco
diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 08274ea2bc31e..4edef6d3ba62a 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -415,3 +415,13 @@ aco_compile_gl_vs_prolog(const struct aco_compiler_options* options,
    aco_compile_shader_part(options, info, args, aco::select_gl_vs_prolog, (void*)pinfo,
                            build_prolog, binary, true);
 }
+
+void
+aco_compile_ps_prolog(const struct aco_compiler_options* options,
+                      const struct aco_shader_info* info, const struct aco_ps_prolog_info* pinfo,
+                      const struct ac_shader_args* args, aco_shader_part_callback* build_prolog,
+                      void** binary)
+{
+   aco_compile_shader_part(options, info, args, aco::select_ps_prolog, (void*)pinfo, build_prolog,
+                           binary, true);
+}
diff --git a/src/amd/compiler/aco_interface.h b/src/amd/compiler/aco_interface.h
index e08b6b6a2e5c5..8f35e18b5b060 100644
--- a/src/amd/compiler/aco_interface.h
+++ b/src/amd/compiler/aco_interface.h
@@ -89,6 +89,12 @@ void aco_compile_gl_vs_prolog(const struct aco_compiler_options* options,
                               const struct ac_shader_args* args,
                               aco_shader_part_callback* build_prolog, void** binary);
 
+void aco_compile_ps_prolog(const struct aco_compiler_options* options,
+                           const struct aco_shader_info* info,
+                           const struct aco_ps_prolog_info* pinfo,
+                           const struct ac_shader_args* args,
+                           aco_shader_part_callback* build_prolog, void** binary);
+
 uint64_t aco_get_codegen_flags();
 
 #ifdef __cplusplus
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 17fbb5ab6b567..82a9763439689 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2244,6 +2244,10 @@ void select_gl_vs_prolog(Program* program, void* pinfo, ac_shader_config* config
                          const struct aco_compiler_options* options,
                          const struct aco_shader_info* info, const struct ac_shader_args* args);
 
+void select_ps_prolog(Program* program, void* pinfo, ac_shader_config* config,
+                      const struct aco_compiler_options* options,
+                      const struct aco_shader_info* info, const struct ac_shader_args* args);
+
 void lower_phis(Program* program);
 void calc_min_waves(Program* program);
 void update_vgpr_sgpr_demand(Program* program, const RegisterDemand new_demand);
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index c739100c1c6f9..1b491023dd3a7 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -104,6 +104,28 @@ struct aco_gl_vs_prolog_info {
    struct ac_arg internal_bindings;
 };
 
+struct aco_ps_prolog_info {
+   bool poly_stipple;
+   unsigned poly_stipple_buf_offset;
+
+   bool bc_optimize_for_persp;
+   bool bc_optimize_for_linear;
+   bool force_persp_sample_interp;
+   bool force_linear_sample_interp;
+   bool force_persp_center_interp;
+   bool force_linear_center_interp;
+
+   unsigned samplemask_log_ps_iter;
+   unsigned num_interp_inputs;
+   unsigned colors_read;
+   int color_interp_vgpr_index[2];
+   int color_attr_index[2];
+   bool color_two_side;
+   bool needs_wqm;
+
+   struct ac_arg internal_bindings;
+};
+
 struct aco_shader_info {
    enum ac_hw_stage hw_stage;
    uint8_t wave_size;
-- 
GitLab


From 8f3fde2e4f1fcfbd5525029bbcb1d9451dc45a14 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 11 Aug 2023 09:57:42 +0800
Subject: [PATCH 05/16] aco: handle ps outputs from radeonsi

radeonsi will keep outputs <FRAG_RESULT_DATA0.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 686926a03f994..719f5923e7d73 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5204,7 +5204,20 @@ store_output_to_temps(isel_context* ctx, nir_intrinsic_instr* instr)
     * TCS epilog to index tess factor temps using semantic location directly.
     */
    nir_io_semantics sem = nir_intrinsic_io_semantics(instr);
-   unsigned base = sem.location + sem.dual_source_blend_index;
+   unsigned base = sem.location;
+   if (ctx->stage == fragment_fs) {
+      /* color result is a legacy slot which won't appear with data result
+       * at the same time. Here we just use the data slot for it to simplify
+       * code handling for both of them.
+       */
+      if (base == FRAG_RESULT_COLOR)
+         base = FRAG_RESULT_DATA0;
+
+      /* Sencond output of dual source blend just use data1 slot for simplicity,
+       * because dual source blend does not support multi render target.
+       */
+      base += sem.dual_source_blend_index;
+   }
    unsigned idx = base * 4u + component;
 
    for (unsigned i = 0; i < 8; ++i) {
@@ -5215,7 +5228,7 @@ store_output_to_temps(isel_context* ctx, nir_intrinsic_instr* instr)
       idx++;
    }
 
-   if (ctx->stage == fragment_fs && ctx->program->info.has_epilog) {
+   if (ctx->stage == fragment_fs && ctx->program->info.has_epilog && base >= FRAG_RESULT_DATA0) {
       unsigned index = base - FRAG_RESULT_DATA0;
 
       if (nir_intrinsic_src_type(instr) == nir_type_float16) {
-- 
GitLab


From f4e8f4936b0e97a34af025e26ca6a91b8e86d316 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 11 Aug 2023 16:58:36 +0800
Subject: [PATCH 06/16] aco: add create_fs_end_for_epilog for radeonsi

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 57 ++++++++++++++++++-
 src/amd/compiler/aco_shader_info.h            |  7 ++-
 2 files changed, 62 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 719f5923e7d73..14d89e68c74e6 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11116,6 +11116,58 @@ create_tcs_end_for_epilog(isel_context* ctx)
    build_end_with_regs(ctx, regs);
 }
 
+static void
+create_fs_end_for_epilog(isel_context* ctx)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   std::vector<Operand> regs;
+
+   regs.emplace_back(get_arg_for_end(ctx, ctx->program->info.ps.alpha_reference));
+
+   unsigned vgpr = 256;
+
+   for (unsigned slot = FRAG_RESULT_DATA0; slot <= FRAG_RESULT_DATA7; slot++) {
+      unsigned index = slot - FRAG_RESULT_DATA0;
+      unsigned type = (ctx->output_color_types >> (index * 2)) & 0x3;
+      unsigned write_mask = ctx->outputs.mask[slot];
+
+      if (!write_mask)
+         continue;
+
+      if (type == ACO_TYPE_ANY32) {
+         u_foreach_bit (i, write_mask) {
+            regs.emplace_back(Operand(ctx->outputs.temps[slot * 4 + i], PhysReg{vgpr + i}));
+         }
+      } else {
+         for (unsigned i = 0; i < 2; i++) {
+            unsigned mask = (write_mask >> (i * 2)) & 0x3;
+            if (!mask)
+               continue;
+
+            unsigned chan = slot * 4 + i * 2;
+            Operand lo = mask & 0x1 ? Operand(ctx->outputs.temps[chan]) : Operand(v2b);
+            Operand hi = mask & 0x2 ? Operand(ctx->outputs.temps[chan + 1]) : Operand(v2b);
+
+            Temp dst = bld.pseudo(aco_opcode::p_create_vector, bld.def(v1), lo, hi);
+            regs.emplace_back(Operand(dst, PhysReg{vgpr + i}));
+         }
+      }
+      vgpr += 4;
+   }
+
+   if (ctx->outputs.mask[FRAG_RESULT_DEPTH])
+      regs.emplace_back(Operand(ctx->outputs.temps[FRAG_RESULT_DEPTH * 4], PhysReg{vgpr++}));
+
+   if (ctx->outputs.mask[FRAG_RESULT_STENCIL])
+      regs.emplace_back(Operand(ctx->outputs.temps[FRAG_RESULT_STENCIL * 4], PhysReg{vgpr++}));
+
+   if (ctx->outputs.mask[FRAG_RESULT_SAMPLE_MASK])
+      regs.emplace_back(Operand(ctx->outputs.temps[FRAG_RESULT_SAMPLE_MASK * 4], PhysReg{vgpr++}));
+
+   build_ps_end_with_regs(ctx, regs, false);
+}
+
 Pseudo_instruction*
 add_startpgm(struct isel_context* ctx)
 {
@@ -11638,7 +11690,10 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
 
    if (ctx.program->info.has_epilog) {
       if (ctx.stage == fragment_fs) {
-         create_fs_jump_to_epilog(&ctx);
+         if (ctx.options->is_opengl)
+            create_fs_end_for_epilog(&ctx);
+         else
+            create_fs_jump_to_epilog(&ctx);
 
          /* FS epilogs always have at least one color/null export. */
          ctx.program->has_color_exports = true;
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 1b491023dd3a7..d2b6335f040f2 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -158,9 +158,14 @@ struct aco_shader_info {
       struct ac_arg vs_state_bits;
    } tcs;
    struct {
-      struct ac_arg epilog_pc;
       uint32_t num_interp;
       unsigned spi_ps_input;
+
+      /* Vulkan only */
+      struct ac_arg epilog_pc;
+
+      /* OpenGL only */
+      struct ac_arg alpha_reference;
    } ps;
    struct {
       uint8_t subgroup_size;
-- 
GitLab


From 48ce2aa55bcce5a4e464f1d24cefd911a659dbe6 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 14 Aug 2023 09:43:18 +0800
Subject: [PATCH 07/16] aco,radv: remove unused ps epilog info fields

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_shader_info.h    | 1 -
 src/amd/vulkan/radv_aco_shader_info.h | 1 -
 2 files changed, 2 deletions(-)

diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index d2b6335f040f2..5fecb0fa0fd85 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -66,7 +66,6 @@ struct aco_vs_prolog_info {
 
 struct aco_ps_epilog_info {
    struct ac_arg inputs[8];
-   struct ac_arg pc;
 
    uint32_t spi_shader_col_format;
 
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index a9fbf3943f98f..04035720a5f3b 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -118,7 +118,6 @@ radv_aco_convert_ps_epilog_key(struct aco_ps_epilog_info *aco_info, const struct
    ASSIGN_FIELD(mrt0_is_dual_src);
 
    memcpy(aco_info->inputs, radv_args->ps_epilog_inputs, sizeof(aco_info->inputs));
-   aco_info->pc = radv_args->ps_epilog_pc;
 }
 
 static inline void
-- 
GitLab


From 358718cf20050fc030e72d4df36c003ff5755a87 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 14 Aug 2023 17:05:32 +0800
Subject: [PATCH 08/16] aco,radv: rename ps epilog info inputs to colors

Will add other mrtz args for radeonsi.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 10 +++++-----
 src/amd/compiler/aco_shader_info.h             |  2 +-
 src/amd/vulkan/radv_aco_shader_info.h          |  2 +-
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 14d89e68c74e6..6a71179f1b54f 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -12715,10 +12715,10 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
    Builder bld(ctx.program, ctx.block);
 
    /* Export all color render targets */
-   struct aco_export_mrt mrts[8];
+   struct aco_export_mrt mrts[MAX_DRAW_BUFFERS];
    uint8_t exported_mrts = 0;
 
-   for (unsigned i = 0; i < 8; i++) {
+   for (unsigned i = 0; i < MAX_DRAW_BUFFERS; i++) {
       unsigned col_format = (einfo->spi_shader_col_format >> (i * 4)) & 0xf;
 
       if (col_format == V_028714_SPI_SHADER_ZERO)
@@ -12733,10 +12733,10 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
       out.is_int10 = (einfo->color_is_int10 >> i) & 1;
       out.enable_mrt_output_nan_fixup = (options->enable_mrt_output_nan_fixup >> i) & 1;
 
-      Temp inputs = get_arg(&ctx, einfo->inputs[i]);
-      emit_split_vector(&ctx, inputs, 4);
+      Temp colors = get_arg(&ctx, einfo->colors[i]);
+      emit_split_vector(&ctx, colors, 4);
       for (unsigned c = 0; c < 4; ++c) {
-         out.values[c] = Operand(emit_extract_vector(&ctx, inputs, c, v1));
+         out.values[c] = Operand(emit_extract_vector(&ctx, colors, c, v1));
       }
 
       if (export_fs_mrt_color(&ctx, &out, &mrts[i])) {
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 5fecb0fa0fd85..281c7182f7f73 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -65,7 +65,7 @@ struct aco_vs_prolog_info {
 };
 
 struct aco_ps_epilog_info {
-   struct ac_arg inputs[8];
+   struct ac_arg colors[MAX_DRAW_BUFFERS];
 
    uint32_t spi_shader_col_format;
 
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 04035720a5f3b..4ae15e2c5f849 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -117,7 +117,7 @@ radv_aco_convert_ps_epilog_key(struct aco_ps_epilog_info *aco_info, const struct
    ASSIGN_FIELD(color_is_int10);
    ASSIGN_FIELD(mrt0_is_dual_src);
 
-   memcpy(aco_info->inputs, radv_args->ps_epilog_inputs, sizeof(aco_info->inputs));
+   memcpy(aco_info->colors, radv_args->ps_epilog_inputs, sizeof(aco_info->colors));
 }
 
 static inline void
-- 
GitLab


From b9da47fe25711df76d918d968b237357377a2e0b Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 15 Aug 2023 17:27:48 +0800
Subject: [PATCH 09/16] aco: simplify export_fs_mrt_color

It's now used by ps epilog only.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 133 +++++++-----------
 1 file changed, 48 insertions(+), 85 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 6a71179f1b54f..5414ac16fbe10 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10628,18 +10628,6 @@ visit_cf_list(isel_context* ctx, struct exec_list* list)
    return false;
 }
 
-struct mrt_color_export {
-   int slot;
-   unsigned write_mask;
-   Operand values[4];
-   uint8_t col_format;
-
-   /* Fields below are only used for PS epilogs. */
-   bool is_int8;
-   bool is_int10;
-   bool enable_mrt_output_nan_fixup;
-};
-
 static void
 export_mrt(isel_context* ctx, const struct aco_export_mrt* mrt)
 {
@@ -10652,32 +10640,36 @@ export_mrt(isel_context* ctx, const struct aco_export_mrt* mrt)
 }
 
 static bool
-export_fs_mrt_color(isel_context* ctx, const struct mrt_color_export* out,
-                    struct aco_export_mrt* mrt)
+export_fs_mrt_color(isel_context* ctx, const struct aco_ps_epilog_info* info, Temp colors[4],
+                    unsigned slot, struct aco_export_mrt* mrt)
 {
+   unsigned col_format = (info->spi_shader_col_format >> (slot * 4)) & 0xf;
+
+   if (col_format == V_028714_SPI_SHADER_ZERO)
+      return false;
+
    Builder bld(ctx->program, ctx->block);
    Operand values[4];
 
    for (unsigned i = 0; i < 4; ++i) {
-      values[i] = out->values[i];
+      values[i] = Operand(colors[i]);
    }
 
-   unsigned target;
+   unsigned target = V_008DFC_SQ_EXP_MRT + slot;
    unsigned enabled_channels = 0;
    aco_opcode compr_op = aco_opcode::num_opcodes;
    bool compr = false;
-   bool is_16bit = values[0].regClass() == v2b;
-
-   target = V_008DFC_SQ_EXP_MRT + out->slot;
+   bool is_16bit = colors[0].regClass() == v2b;
+   bool is_int8 = (info->color_is_int8 >> slot) & 1;
+   bool is_int10 = (info->color_is_int10 >> slot) & 1;
+   bool enable_mrt_output_nan_fixup = (ctx->options->enable_mrt_output_nan_fixup >> slot) & 1;
 
    /* Replace NaN by zero (only 32-bit) to fix game bugs if requested. */
-   if (out->enable_mrt_output_nan_fixup && !is_16bit &&
-       (out->col_format == V_028714_SPI_SHADER_32_R ||
-        out->col_format == V_028714_SPI_SHADER_32_GR ||
-        out->col_format == V_028714_SPI_SHADER_32_AR ||
-        out->col_format == V_028714_SPI_SHADER_32_ABGR ||
-        out->col_format == V_028714_SPI_SHADER_FP16_ABGR)) {
-      u_foreach_bit (i, out->write_mask) {
+   if (enable_mrt_output_nan_fixup && !is_16bit &&
+       (col_format == V_028714_SPI_SHADER_32_R || col_format == V_028714_SPI_SHADER_32_GR ||
+        col_format == V_028714_SPI_SHADER_32_AR || col_format == V_028714_SPI_SHADER_32_ABGR ||
+        col_format == V_028714_SPI_SHADER_FP16_ABGR)) {
+      for (unsigned i = 0; i < 4; i++) {
          Temp is_not_nan =
             bld.vopc(aco_opcode::v_cmp_eq_f32, bld.def(bld.lm), values[i], values[i]);
          values[i] = bld.vop2(aco_opcode::v_cndmask_b32, bld.def(v1), Operand::zero(), values[i],
@@ -10685,7 +10677,7 @@ export_fs_mrt_color(isel_context* ctx, const struct mrt_color_export* out,
       }
    }
 
-   switch (out->col_format) {
+   switch (col_format) {
    case V_028714_SPI_SHADER_32_R: enabled_channels = 1; break;
 
    case V_028714_SPI_SHADER_32_GR: enabled_channels = 0x3; break;
@@ -10703,31 +10695,20 @@ export_fs_mrt_color(isel_context* ctx, const struct mrt_color_export* out,
 
    case V_028714_SPI_SHADER_FP16_ABGR:
       for (int i = 0; i < 2; i++) {
-         bool enabled = (out->write_mask >> (i * 2)) & 0x3;
-         if (enabled) {
-            enabled_channels |= 0x3 << (i * 2);
-            if (is_16bit) {
-               values[i] =
-                  bld.pseudo(aco_opcode::p_create_vector, bld.def(v1),
-                             values[i * 2].isUndefined() ? Operand(v2b) : values[i * 2],
-                             values[i * 2 + 1].isUndefined() ? Operand(v2b) : values[i * 2 + 1]);
-            } else if (ctx->options->gfx_level == GFX8 || ctx->options->gfx_level == GFX9) {
-               values[i] =
-                  bld.vop3(aco_opcode::v_cvt_pkrtz_f16_f32_e64, bld.def(v1),
-                           values[i * 2].isUndefined() ? Operand::zero() : values[i * 2],
-                           values[i * 2 + 1].isUndefined() ? Operand::zero() : values[i * 2 + 1]);
-            } else {
-               values[i] =
-                  bld.vop2(aco_opcode::v_cvt_pkrtz_f16_f32, bld.def(v1),
-                           values[i * 2].isUndefined() ? values[i * 2 + 1] : values[i * 2],
-                           values[i * 2 + 1].isUndefined() ? values[i * 2] : values[i * 2 + 1]);
-            }
+         if (is_16bit) {
+            values[i] = bld.pseudo(aco_opcode::p_create_vector, bld.def(v1), values[i * 2],
+                                   values[i * 2 + 1]);
+         } else if (ctx->options->gfx_level == GFX8 || ctx->options->gfx_level == GFX9) {
+            values[i] = bld.vop3(aco_opcode::v_cvt_pkrtz_f16_f32_e64, bld.def(v1), values[i * 2],
+                                 values[i * 2 + 1]);
          } else {
-            values[i] = Operand(v1);
+            values[i] = bld.vop2(aco_opcode::v_cvt_pkrtz_f16_f32, bld.def(v1), values[i * 2],
+                                 values[i * 2 + 1]);
          }
       }
       values[2] = Operand(v1);
       values[3] = Operand(v1);
+      enabled_channels = 0xf;
       compr = true;
       break;
 
@@ -10749,17 +10730,17 @@ export_fs_mrt_color(isel_context* ctx, const struct mrt_color_export* out,
 
    case V_028714_SPI_SHADER_UINT16_ABGR:
       compr_op = aco_opcode::v_cvt_pk_u16_u32;
-      if (out->is_int8 || out->is_int10) {
+      if (is_int8 || is_int10) {
          /* clamp */
-         uint32_t max_rgb = out->is_int8 ? 255 : out->is_int10 ? 1023 : 0;
+         uint32_t max_rgb = is_int8 ? 255 : is_int10 ? 1023 : 0;
 
-         u_foreach_bit (i, out->write_mask) {
-            uint32_t max = i == 3 && out->is_int10 ? 3 : max_rgb;
+         for (unsigned i = 0; i < 4; i++) {
+            uint32_t max = i == 3 && is_int10 ? 3 : max_rgb;
 
             values[i] = bld.vop2(aco_opcode::v_min_u32, bld.def(v1), Operand::c32(max), values[i]);
          }
       } else if (is_16bit) {
-         u_foreach_bit (i, out->write_mask) {
+         for (unsigned i = 0; i < 4; i++) {
             Temp tmp = convert_int(ctx, bld, values[i].getTemp(), 16, 32, false);
             values[i] = Operand(tmp);
          }
@@ -10768,20 +10749,20 @@ export_fs_mrt_color(isel_context* ctx, const struct mrt_color_export* out,
 
    case V_028714_SPI_SHADER_SINT16_ABGR:
       compr_op = aco_opcode::v_cvt_pk_i16_i32;
-      if (out->is_int8 || out->is_int10) {
+      if (is_int8 || is_int10) {
          /* clamp */
-         uint32_t max_rgb = out->is_int8 ? 127 : out->is_int10 ? 511 : 0;
-         uint32_t min_rgb = out->is_int8 ? -128 : out->is_int10 ? -512 : 0;
+         uint32_t max_rgb = is_int8 ? 127 : is_int10 ? 511 : 0;
+         uint32_t min_rgb = is_int8 ? -128 : is_int10 ? -512 : 0;
 
-         u_foreach_bit (i, out->write_mask) {
-            uint32_t max = i == 3 && out->is_int10 ? 1 : max_rgb;
-            uint32_t min = i == 3 && out->is_int10 ? -2u : min_rgb;
+         for (unsigned i = 0; i < 4; i++) {
+            uint32_t max = i == 3 && is_int10 ? 1 : max_rgb;
+            uint32_t min = i == 3 && is_int10 ? -2u : min_rgb;
 
             values[i] = bld.vop2(aco_opcode::v_min_i32, bld.def(v1), Operand::c32(max), values[i]);
             values[i] = bld.vop2(aco_opcode::v_max_i32, bld.def(v1), Operand::c32(min), values[i]);
          }
       } else if (is_16bit) {
-         u_foreach_bit (i, out->write_mask) {
+         for (unsigned i = 0; i < 4; i++) {
             Temp tmp = convert_int(ctx, bld, values[i].getTemp(), 16, 32, true);
             values[i] = Operand(tmp);
          }
@@ -10795,20 +10776,11 @@ export_fs_mrt_color(isel_context* ctx, const struct mrt_color_export* out,
    }
 
    if (compr_op != aco_opcode::num_opcodes) {
-      for (int i = 0; i < 2; i++) {
-         /* check if at least one of the values to be compressed is enabled */
-         bool enabled = (out->write_mask >> (i * 2)) & 0x3;
-         if (enabled) {
-            enabled_channels |= 0x3 << (i * 2);
-            values[i] = bld.vop3(
-               compr_op, bld.def(v1), values[i * 2].isUndefined() ? Operand::zero() : values[i * 2],
-               values[i * 2 + 1].isUndefined() ? Operand::zero() : values[i * 2 + 1]);
-         } else {
-            values[i] = Operand(v1);
-         }
-      }
+      values[0] = bld.vop3(compr_op, bld.def(v1), values[0], values[1]);
+      values[1] = bld.vop3(compr_op, bld.def(v1), values[2], values[3]);
       values[2] = Operand(v1);
       values[3] = Operand(v1);
+      enabled_channels = 0xf;
       compr = true;
    } else if (!compr) {
       for (int i = 0; i < 4; i++)
@@ -12719,27 +12691,18 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
    uint8_t exported_mrts = 0;
 
    for (unsigned i = 0; i < MAX_DRAW_BUFFERS; i++) {
-      unsigned col_format = (einfo->spi_shader_col_format >> (i * 4)) & 0xf;
-
-      if (col_format == V_028714_SPI_SHADER_ZERO)
+      if (!einfo->colors[i].used)
          continue;
 
-      struct mrt_color_export out;
-
-      out.slot = i;
-      out.write_mask = 0xf;
-      out.col_format = col_format;
-      out.is_int8 = (einfo->color_is_int8 >> i) & 1;
-      out.is_int10 = (einfo->color_is_int10 >> i) & 1;
-      out.enable_mrt_output_nan_fixup = (options->enable_mrt_output_nan_fixup >> i) & 1;
-
       Temp colors = get_arg(&ctx, einfo->colors[i]);
       emit_split_vector(&ctx, colors, 4);
+
+      Temp comps[4];
       for (unsigned c = 0; c < 4; ++c) {
-         out.values[c] = Operand(emit_extract_vector(&ctx, colors, c, v1));
+         comps[c] = emit_extract_vector(&ctx, colors, c, v1);
       }
 
-      if (export_fs_mrt_color(&ctx, &out, &mrts[i])) {
+      if (export_fs_mrt_color(&ctx, einfo, comps, i, &mrts[i])) {
          exported_mrts |= 1 << i;
       }
    }
-- 
GitLab


From 5363a354ce582e70755fb9852eccbc091e1c51d7 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 17 Aug 2023 10:13:26 +0800
Subject: [PATCH 10/16] aco,radv: add radeonsi spec ps epilog code

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 180 ++++++++++++++++--
 src/amd/compiler/aco_shader_info.h            |  13 ++
 src/amd/vulkan/radv_aco_shader_info.h         |   2 +
 src/amd/vulkan/radv_shader.c                  |   2 +-
 4 files changed, 185 insertions(+), 12 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 5414ac16fbe10..ef9944a18c446 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10804,6 +10804,68 @@ export_fs_mrt_color(isel_context* ctx, const struct aco_ps_epilog_info* info, Te
    return true;
 }
 
+static void
+export_fs_mrtz(isel_context* ctx, Temp depth, Temp stencil, Temp samplemask, Temp alpha)
+{
+   Builder bld(ctx->program, ctx->block);
+   unsigned enabled_channels = 0;
+   bool compr = false;
+   Operand values[4];
+
+   for (unsigned i = 0; i < 4; ++i) {
+      values[i] = Operand(v1);
+   }
+
+   /* Both stencil and sample mask only need 16-bits. */
+   if (!depth.id() && !alpha.id() && (stencil.id() || samplemask.id())) {
+      compr = ctx->program->gfx_level < GFX11; /* COMPR flag */
+
+      if (stencil.id()) {
+         /* Stencil should be in X[23:16]. */
+         values[0] = bld.vop2(aco_opcode::v_lshlrev_b32, bld.def(v1), Operand::c32(16u), stencil);
+         enabled_channels |= ctx->program->gfx_level >= GFX11 ? 0x1 : 0x3;
+      }
+
+      if (samplemask.id()) {
+         /* SampleMask should be in Y[15:0]. */
+         values[1] = Operand(samplemask);
+         enabled_channels |= ctx->program->gfx_level >= GFX11 ? 0x2 : 0xc;
+      }
+   } else {
+      if (depth.id()) {
+         values[0] = Operand(depth);
+         enabled_channels |= 0x1;
+      }
+
+      if (stencil.id()) {
+         values[1] = Operand(stencil);
+         enabled_channels |= 0x2;
+      }
+
+      if (samplemask.id()) {
+         values[2] = Operand(samplemask);
+         enabled_channels |= 0x4;
+      }
+
+      if (alpha.id()) {
+         assert(ctx->program->gfx_level >= GFX11);
+         values[3] = Operand(alpha);
+         enabled_channels |= 0x8;
+      }
+   }
+
+   /* GFX6 (except OLAND and HAINAN) has a bug that it only looks at the X
+    * writemask component.
+    */
+   if (ctx->options->gfx_level == GFX6 && ctx->options->family != CHIP_OLAND &&
+       ctx->options->family != CHIP_HAINAN) {
+      enabled_channels |= 0x1;
+   }
+
+   bld.exp(aco_opcode::exp, values[0], values[1], values[2], values[3], enabled_channels,
+           V_008DFC_SQ_EXP_MRTZ, compr);
+}
+
 static void
 create_fs_null_export(isel_context* ctx)
 {
@@ -12064,6 +12126,75 @@ interpolate_color_args(isel_context* ctx, const struct aco_ps_prolog_info* finfo
    }
 }
 
+void
+emit_clamp_alpha_test(isel_context *ctx, const struct aco_ps_epilog_info *info,
+                      Temp colors[4], unsigned color_index)
+{
+   Builder bld(ctx->program, ctx->block);
+
+   if (info->clamp_color) {
+      for (unsigned i = 0; i < 4; i++) {
+         if (colors[i].regClass() == v2b) {
+            colors[i] = bld.vop3(aco_opcode::v_med3_f16, bld.def(v2b), Operand::c16(0u),
+                                 Operand::c16(0x3c00), colors[i]);
+         } else {
+            assert(colors[i].regClass() == v1);
+            colors[i] = bld.vop3(aco_opcode::v_med3_f32, bld.def(v1), Operand::zero(),
+                                 Operand::c32(0x3f800000u), colors[i]);
+         }
+      }
+   }
+
+   if (info->alpha_to_one) {
+      if (colors[3].regClass() == v2b)
+         colors[3] = bld.copy(bld.def(v2b), Operand::c16(0x3c00));
+      else
+         colors[3] = bld.copy(bld.def(v1), Operand::c32(0x3f800000u));
+   }
+
+   if (color_index == 0 && info->alpha_func != COMPARE_FUNC_ALWAYS) {
+      Operand cond = Operand::c32(-1u);
+      if (info->alpha_func != COMPARE_FUNC_NEVER) {
+         aco_opcode opcode = aco_opcode::num_opcodes;
+
+         switch (info->alpha_func) {
+         case COMPARE_FUNC_LESS:
+            opcode = aco_opcode::v_cmp_ngt_f32;
+            break;
+         case COMPARE_FUNC_EQUAL:
+            opcode = aco_opcode::v_cmp_neq_f32;
+            break;
+         case COMPARE_FUNC_LEQUAL:
+            opcode = aco_opcode::v_cmp_nge_f32;
+            break;
+         case COMPARE_FUNC_GREATER:
+            opcode = aco_opcode::v_cmp_nlt_f32;
+            break;
+         case COMPARE_FUNC_NOTEQUAL:
+            opcode = aco_opcode::v_cmp_nlg_f32;
+            break;
+         case COMPARE_FUNC_GEQUAL:
+            opcode = aco_opcode::v_cmp_nle_f32;
+            break;
+         default:
+            unreachable("invalid alpha func");
+         }
+
+         Temp ref = get_arg(ctx, info->alpha_reference);
+
+         Temp alpha = colors[3].regClass() == v2b ?
+            bld.vop1(aco_opcode::v_cvt_f32_f16, bld.def(v1), colors[3]) : colors[3];
+
+         /* true if not pass */
+         cond = bld.vopc(opcode, bld.def(bld.lm), ref, alpha);
+      }
+
+      bld.pseudo(aco_opcode::p_discard_if, cond);
+      ctx->block->kind |= block_kind_uses_discard;
+      ctx->program->needs_exact = true;
+   }
+}
+
 } /* end namespace */
 
 void
@@ -12686,24 +12817,51 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
 
    Builder bld(ctx.program, ctx.block);
 
-   /* Export all color render targets */
-   struct aco_export_mrt mrts[MAX_DRAW_BUFFERS];
-   uint8_t exported_mrts = 0;
-
+   Temp colors[MAX_DRAW_BUFFERS][4];
    for (unsigned i = 0; i < MAX_DRAW_BUFFERS; i++) {
       if (!einfo->colors[i].used)
          continue;
 
-      Temp colors = get_arg(&ctx, einfo->colors[i]);
-      emit_split_vector(&ctx, colors, 4);
+      Temp color = get_arg(&ctx, einfo->colors[i]);
+      unsigned col_types = (einfo->color_types >> (i * 2)) & 0x3;
 
-      Temp comps[4];
+      emit_split_vector(&ctx, color, col_types == ACO_TYPE_ANY32 ? 4 : 8);
       for (unsigned c = 0; c < 4; ++c) {
-         comps[c] = emit_extract_vector(&ctx, colors, c, v1);
+         colors[i][c] =
+            emit_extract_vector(&ctx, color, c, col_types == ACO_TYPE_ANY32 ? v1 : v2b);
       }
 
-      if (export_fs_mrt_color(&ctx, einfo, comps, i, &mrts[i])) {
-         exported_mrts |= 1 << i;
+      emit_clamp_alpha_test(&ctx, einfo, colors[i], i);
+   }
+
+   bool has_mrtz_depth = einfo->depth.used;
+   bool has_mrtz_stencil = einfo->stencil.used;
+   bool has_mrtz_samplemask = einfo->samplemask.used;
+   bool has_mrtz_alpha = einfo->alpha_to_coverage_via_mrtz && einfo->colors[0].used;
+   bool has_mrtz_export =
+      has_mrtz_depth || has_mrtz_stencil || has_mrtz_samplemask || has_mrtz_alpha;
+   if (has_mrtz_export) {
+      Temp depth = has_mrtz_depth ? get_arg(&ctx, einfo->depth) : Temp();
+      Temp stencil = has_mrtz_stencil ? get_arg(&ctx, einfo->stencil) : Temp();
+      Temp samplemask = has_mrtz_samplemask ? get_arg(&ctx, einfo->samplemask) : Temp();
+      Temp alpha = has_mrtz_alpha ? colors[0][3] : Temp();
+
+      export_fs_mrtz(&ctx, depth, stencil, samplemask, alpha);
+   }
+
+   /* Export all color render targets */
+   struct aco_export_mrt mrts[MAX_DRAW_BUFFERS];
+   uint8_t exported_mrts = 0;
+
+   if (einfo->broadcast_last_cbuf) {
+      for (unsigned i = 0; i <= einfo->broadcast_last_cbuf; i++) {
+         if (export_fs_mrt_color(&ctx, einfo, colors[0], i, &mrts[i]))
+            exported_mrts |= 1 << i;
+      }
+   } else {
+      for (unsigned i = 0; i < MAX_DRAW_BUFFERS; i++) {
+         if (export_fs_mrt_color(&ctx, einfo, colors[i], i, &mrts[i]))
+            exported_mrts |= 1 << i;
       }
    }
 
@@ -12717,7 +12875,7 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
             export_mrt(&ctx, &mrts[i]);
          }
       }
-   } else {
+   } else if (!has_mrtz_export && !einfo->skip_null_export) {
       create_fs_null_export(&ctx);
    }
 
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index 281c7182f7f73..dce49f7169e7a 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -74,6 +74,19 @@ struct aco_ps_epilog_info {
    uint8_t color_is_int10;
 
    bool mrt0_is_dual_src;
+
+   /* OpenGL only */
+   uint16_t color_types;
+   bool clamp_color;
+   bool alpha_to_one;
+   bool alpha_to_coverage_via_mrtz;
+   bool skip_null_export;
+   unsigned broadcast_last_cbuf;
+   enum compare_func alpha_func;
+   struct ac_arg alpha_reference;
+   struct ac_arg depth;
+   struct ac_arg stencil;
+   struct ac_arg samplemask;
 };
 
 struct aco_tcs_epilog_info {
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index 4ae15e2c5f849..f53c433f76971 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -118,6 +118,8 @@ radv_aco_convert_ps_epilog_key(struct aco_ps_epilog_info *aco_info, const struct
    ASSIGN_FIELD(mrt0_is_dual_src);
 
    memcpy(aco_info->colors, radv_args->ps_epilog_inputs, sizeof(aco_info->colors));
+
+   aco_info->alpha_func = COMPARE_FUNC_ALWAYS;
 }
 
 static inline void
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 5148295dddc08..ae83df9bb6935 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2596,7 +2596,7 @@ radv_create_ps_epilog(struct radv_device *device, const struct radv_ps_epilog_ke
 
    struct radv_shader_part_binary *binary = NULL;
    struct aco_shader_info ac_info;
-   struct aco_ps_epilog_info ac_epilog_info;
+   struct aco_ps_epilog_info ac_epilog_info = {0};
    struct aco_compiler_options ac_opts;
    radv_aco_convert_shader_info(&ac_info, &info, &args, &options.key, options.info->gfx_level);
    radv_aco_convert_opts(&ac_opts, &options, &args);
-- 
GitLab


From ecd743e11b97f5103f673975dc6608b7e60e7969 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 25 Aug 2023 16:39:19 +0800
Subject: [PATCH 11/16] aco: compact ps expilog color export for radeonsi

radeonsi need to compact color export for ps epilog while radv does not.
radv will fill empty color slot, so won't affected by this change.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../compiler/aco_instruction_selection.cpp    | 25 +++++++++----------
 1 file changed, 12 insertions(+), 13 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index ef9944a18c446..04ab1033a3558 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10655,7 +10655,6 @@ export_fs_mrt_color(isel_context* ctx, const struct aco_ps_epilog_info* info, Te
       values[i] = Operand(colors[i]);
    }
 
-   unsigned target = V_008DFC_SQ_EXP_MRT + slot;
    unsigned enabled_channels = 0;
    aco_opcode compr_op = aco_opcode::num_opcodes;
    bool compr = false;
@@ -10797,7 +10796,7 @@ export_fs_mrt_color(isel_context* ctx, const struct aco_ps_epilog_info* info, Te
 
    for (unsigned i = 0; i < 4; i++)
       mrt->out[i] = values[i];
-   mrt->target = target;
+   mrt->target = V_008DFC_SQ_EXP_MRT;
    mrt->enabled_channels = enabled_channels;
    mrt->compr = compr;
 
@@ -12851,29 +12850,29 @@ select_ps_epilog(Program* program, void* pinfo, ac_shader_config* config,
 
    /* Export all color render targets */
    struct aco_export_mrt mrts[MAX_DRAW_BUFFERS];
-   uint8_t exported_mrts = 0;
+   unsigned mrt_num = 0;
 
    if (einfo->broadcast_last_cbuf) {
       for (unsigned i = 0; i <= einfo->broadcast_last_cbuf; i++) {
-         if (export_fs_mrt_color(&ctx, einfo, colors[0], i, &mrts[i]))
-            exported_mrts |= 1 << i;
+         struct aco_export_mrt* mrt = &mrts[mrt_num];
+         if (export_fs_mrt_color(&ctx, einfo, colors[0], i, mrt))
+            mrt->target += mrt_num++;
       }
    } else {
       for (unsigned i = 0; i < MAX_DRAW_BUFFERS; i++) {
-         if (export_fs_mrt_color(&ctx, einfo, colors[i], i, &mrts[i]))
-            exported_mrts |= 1 << i;
+         struct aco_export_mrt* mrt = &mrts[mrt_num];
+         if (export_fs_mrt_color(&ctx, einfo, colors[i], i, mrt))
+            mrt->target += mrt_num++;
       }
    }
 
-   if (exported_mrts) {
+   if (mrt_num) {
       if (ctx.options->gfx_level >= GFX11 && einfo->mrt0_is_dual_src) {
-         struct aco_export_mrt* mrt0 = (exported_mrts & BITFIELD_BIT(0)) ? &mrts[0] : NULL;
-         struct aco_export_mrt* mrt1 = (exported_mrts & BITFIELD_BIT(1)) ? &mrts[1] : NULL;
-         create_fs_dual_src_export_gfx11(&ctx, mrt0, mrt1);
+         assert(mrt_num == 2);
+         create_fs_dual_src_export_gfx11(&ctx, &mrts[0], &mrts[1]);
       } else {
-         u_foreach_bit (i, exported_mrts) {
+         for (unsigned i = 0; i < mrt_num; i++)
             export_mrt(&ctx, &mrts[i]);
-         }
       }
    } else if (!has_mrtz_export && !einfo->skip_null_export) {
       create_fs_null_export(&ctx);
-- 
GitLab


From bd93663e1af2ceb9405c146efe4a4d5b72e57373 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 19 Aug 2023 11:20:00 +0800
Subject: [PATCH 12/16] aco,radv,radeonsi: pass spi ps input ena and addr

radeonsi may pass different ena and addr when part mode shader.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection_setup.cpp | 4 ++--
 src/amd/compiler/aco_shader_info.h                   | 3 ++-
 src/amd/vulkan/radv_aco_shader_info.h                | 3 ++-
 src/gallium/drivers/radeonsi/si_shader_aco.c         | 3 ++-
 4 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 27b318451d791..d444b89f63d95 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -625,8 +625,8 @@ init_context(isel_context* ctx, nir_shader* shader)
       }
    }
 
-   ctx->program->config->spi_ps_input_ena = ctx->program->info.ps.spi_ps_input;
-   ctx->program->config->spi_ps_input_addr = ctx->program->info.ps.spi_ps_input;
+   ctx->program->config->spi_ps_input_ena = ctx->program->info.ps.spi_ps_input_ena;
+   ctx->program->config->spi_ps_input_addr = ctx->program->info.ps.spi_ps_input_addr;
 
    ctx->cf_info.nir_to_aco = std::move(nir_to_aco);
 
diff --git a/src/amd/compiler/aco_shader_info.h b/src/amd/compiler/aco_shader_info.h
index dce49f7169e7a..a9559f9d783bd 100644
--- a/src/amd/compiler/aco_shader_info.h
+++ b/src/amd/compiler/aco_shader_info.h
@@ -171,7 +171,8 @@ struct aco_shader_info {
    } tcs;
    struct {
       uint32_t num_interp;
-      unsigned spi_ps_input;
+      unsigned spi_ps_input_ena;
+      unsigned spi_ps_input_addr;
 
       /* Vulkan only */
       struct ac_arg epilog_pc;
diff --git a/src/amd/vulkan/radv_aco_shader_info.h b/src/amd/vulkan/radv_aco_shader_info.h
index f53c433f76971..ec235a7279bf8 100644
--- a/src/amd/vulkan/radv_aco_shader_info.h
+++ b/src/amd/vulkan/radv_aco_shader_info.h
@@ -58,9 +58,10 @@ radv_aco_convert_shader_info(struct aco_shader_info *aco_info, const struct radv
    ASSIGN_FIELD(tcs.num_linked_patch_outputs);
    ASSIGN_FIELD(tcs.tcs_vertices_out);
    ASSIGN_FIELD(ps.num_interp);
-   ASSIGN_FIELD(ps.spi_ps_input);
    ASSIGN_FIELD(cs.subgroup_size);
    ASSIGN_FIELD(cs.uses_full_subgroups);
+   aco_info->ps.spi_ps_input_ena = radv->ps.spi_ps_input;
+   aco_info->ps.spi_ps_input_addr = radv->ps.spi_ps_input;
    aco_info->gfx9_gs_ring_lds_size = radv->gs_ring_info.lds_size;
    aco_info->is_trap_handler_shader = radv->type == RADV_SHADER_TYPE_TRAP_HANDLER;
    aco_info->image_2d_view_of_3d = radv_key->image_2d_view_of_3d;
diff --git a/src/gallium/drivers/radeonsi/si_shader_aco.c b/src/gallium/drivers/radeonsi/si_shader_aco.c
index 526bf19c3a27b..8d925bc669406 100644
--- a/src/gallium/drivers/radeonsi/si_shader_aco.c
+++ b/src/gallium/drivers/radeonsi/si_shader_aco.c
@@ -104,7 +104,8 @@ si_fill_aco_shader_info(struct si_shader *shader, struct aco_shader_info *info,
       break;
    case MESA_SHADER_FRAGMENT:
       info->ps.num_interp = si_get_ps_num_interp(shader);
-      info->ps.spi_ps_input = shader->config.spi_ps_input_ena;
+      info->ps.spi_ps_input_ena = shader->config.spi_ps_input_ena;
+      info->ps.spi_ps_input_addr = shader->config.spi_ps_input_addr;
       break;
    default:
       break;
-- 
GitLab


From 8451103bfe85240e5341a9b8e7d7ae159c9c4254 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 19 Aug 2023 15:36:00 +0800
Subject: [PATCH 13/16] aco: wait memory ops done for p_end_with_regs args

Next part don't know whether args are load from memory
ops, need to wait it's done here.

Signe-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp         | 3 +++
 src/amd/compiler/aco_lower_to_hw_instr.cpp | 7 +++++++
 2 files changed, 10 insertions(+)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 47e379bb761c5..584a8ed5a7a45 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -165,6 +165,9 @@ emit_instruction(asm_context& ctx, std::vector<uint32_t>& out, Instruction* inst
       instr->opcode = aco_opcode::s_mov_b32;
       /* in case it's an inline constant, make it a literal */
       instr->operands[0] = Operand::literal32(0);
+   } else if (instr->opcode == aco_opcode::p_end_with_regs) {
+      /* do nothing, it gets here for insert waitcnt pass */
+      return;
    }
 
    /* Promote VOP12C to VOP3 if necessary. */
diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index ba49e3817b6ea..e268da5624b97 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -2873,6 +2873,13 @@ lower_to_hw_instr(Program* program)
                        V_008DFC_SQ_EXP_MRT + 22, false);
                break;
             }
+            case aco_opcode::p_end_with_regs: {
+               /* Keep for insert waitcnt pass to wait mem ops done before pass args to
+                * next part.
+                */
+               ctx.instructions.emplace_back(std::move(instr));
+               break;
+            }
             default: break;
             }
          } else if (instr->isBranch()) {
-- 
GitLab


From 0dcf70404b8c0d4908621104717f58644a0f83bf Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 17 Aug 2023 15:17:20 +0800
Subject: [PATCH 14/16] aco: do not fix_exports when program has epilog

PS with epilog does not need to fix_exports. And radeonsi use
p_end_with_regs so does not have jump instruction at last.

radeonsi may also have exec restore instruction, so may break
before reach to p_end_with_regs.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_assembler.cpp             | 13 +++----------
 src/amd/compiler/aco_instruction_selection.cpp |  1 -
 2 files changed, 3 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 584a8ed5a7a45..0efadf13c7b5f 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -1006,21 +1006,14 @@ fix_exports(asm_context& ctx, std::vector<uint32_t>& out, Program* program)
                   break;
                }
             } else {
-               if (!program->info.has_epilog) {
-                  exp.done = true;
-                  exp.valid_mask = true;
-               }
+               exp.done = true;
+               exp.valid_mask = true;
                exported = true;
                break;
             }
          } else if ((*it)->definitions.size() && (*it)->definitions[0].physReg() == exec) {
             break;
          } else if ((*it)->opcode == aco_opcode::s_setpc_b64) {
-            /* Do not abort if the main FS has an epilog because it only
-             * exports MRTZ (if present) and the epilog exports colors.
-             */
-            exported |= program->stage.hw == AC_HW_PIXEL_SHADER && program->info.has_epilog;
-
             /* Do not abort for VS/TES as NGG if they are non-monolithic shaders
              * because a jump would be emitted.
              */
@@ -1302,7 +1295,7 @@ emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct a
    asm_context ctx(program, symbols);
 
    /* Prolog has no exports. */
-   if (!program->is_prolog &&
+   if (!program->is_prolog && !program->info.has_epilog &&
        (program->stage.hw == AC_HW_VERTEX_SHADER || program->stage.hw == AC_HW_PIXEL_SHADER ||
         program->stage.hw == AC_HW_NEXT_GEN_GEOMETRY_SHADER))
       fix_exports(ctx, code, program);
diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 04ab1033a3558..1428cd20a5e1f 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -11730,7 +11730,6 @@ select_shader(isel_context& ctx, nir_shader* nir, const bool need_startpgm, cons
 
          /* FS epilogs always have at least one color/null export. */
          ctx.program->has_color_exports = true;
-         ctx.block->kind |= block_kind_export_end;
       } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
          assert(ctx.stage == tess_control_hs || ctx.stage == vertex_tess_control_hs);
          if (ctx.options->is_opengl)
-- 
GitLab


From 5801afaef61ae7f46201b7bd37e98c76f0c103d2 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 21 Aug 2023 10:44:45 +0800
Subject: [PATCH 15/16] aco: fix assertion fail when program contains empty
 block

radeonsi may generate empty main shader or an empty exit block
for p_end_with_regs to jump to.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_print_asm.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_print_asm.cpp b/src/amd/compiler/aco_print_asm.cpp
index 226d56785cd88..9fd1a8422c401 100644
--- a/src/amd/compiler/aco_print_asm.cpp
+++ b/src/amd/compiler/aco_print_asm.cpp
@@ -347,7 +347,7 @@ print_asm_llvm(Program* program, std::vector<uint32_t>& binary, unsigned exec_si
    unsigned prev_size = 0;
    unsigned prev_pos = 0;
    unsigned repeat_count = 0;
-   while (pos < exec_size) {
+   while (pos <= exec_size) {
       bool new_block =
          next_block < program->blocks.size() && pos == program->blocks[next_block].offset;
       if (pos + prev_size <= exec_size && prev_pos != pos && !new_block &&
@@ -363,6 +363,10 @@ print_asm_llvm(Program* program, std::vector<uint32_t>& binary, unsigned exec_si
 
       print_block_markers(output, program, referenced_blocks, &next_block, pos);
 
+      /* For empty last block, only print block marker. */
+      if (pos == exec_size)
+         break;
+
       char outline[1024];
       std::pair<bool, size_t> res = disasm_instr(program->gfx_level, disasm, binary.data(),
                                                  exec_size, pos, outline, sizeof(outline));
-- 
GitLab


From affcc31a14f9bb8bd61cec24887b1ea514312b1a Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Thu, 24 Aug 2023 10:11:40 +0800
Subject: [PATCH 16/16] aco: create exit block for p_end_with_regs to branch to

To handle ps discard in radeonsi part mode shader.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_lower_to_hw_instr.cpp | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index e268da5624b97..6e0cd574e9b22 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -2303,6 +2303,8 @@ lower_to_hw_instr(Program* program)
    Block* discard_exit_block = NULL;
    Block* discard_pops_done_and_exit_block = NULL;
 
+   int end_with_regs_block_index = -1;
+
    bool should_dealloc_vgprs = dealloc_vgprs(program);
 
    for (int block_idx = program->blocks.size() - 1; block_idx >= 0; block_idx--) {
@@ -2878,6 +2880,8 @@ lower_to_hw_instr(Program* program)
                 * next part.
                 */
                ctx.instructions.emplace_back(std::move(instr));
+
+               end_with_regs_block_index = block->index;
                break;
             }
             default: break;
@@ -3058,6 +3062,20 @@ lower_to_hw_instr(Program* program)
 
       block->instructions = std::move(ctx.instructions);
    }
+
+   /* If block with p_end_with_regs is not the last block (i.e. p_exit_early_if may append exit
+    * block at last), create an exit block for it to branch to.
+    */
+   int last_block_index = program->blocks.size() - 1;
+   if (end_with_regs_block_index >= 0 && end_with_regs_block_index != last_block_index) {
+      Block* exit_block = program->create_and_insert_block();
+      Block* end_with_regs_block = &program->blocks[end_with_regs_block_index];
+      exit_block->linear_preds.push_back(end_with_regs_block->index);
+      end_with_regs_block->linear_succs.push_back(exit_block->index);
+
+      Builder bld(program, end_with_regs_block);
+      bld.sopp(aco_opcode::s_branch, exit_block->index);
+   }
 }
 
 } // namespace aco
-- 
GitLab

