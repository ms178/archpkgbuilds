--- a/src/util/blake3/blake3_avx2_x86-64_unix.S	2025-06-22 09:48:29.513316482 +0200
+++ b/src/util/blake3/blake3_avx2_x86-64_unix.S	2025-06-22 10:17:54.155516793 +0200


--- a/src/util/blake3/blake3_avx2.c	2025-06-22 09:48:29.513316482 +0200
+++ b/src/util/blake3/blake3_avx2.c	2025-06-22 10:07:36.353637101 +0200
@@ -4,17 +4,19 @@
 
 #define DEGREE 8
 
+/* Unaligned 32-byte load. */
 INLINE __m256i loadu(const uint8_t src[32]) {
   return _mm256_loadu_si256((const __m256i *)src);
 }
 
-INLINE void storeu(__m256i src, uint8_t dest[16]) {
+/* Unaligned 32-byte store. Signature corrected to 32 bytes. */
+INLINE void storeu(__m256i src, uint8_t dest[32]) {
   _mm256_storeu_si256((__m256i *)dest, src);
 }
 
 INLINE __m256i addv(__m256i a, __m256i b) { return _mm256_add_epi32(a, b); }
 
-// Note that clang-format doesn't like the name "xor" for some reason.
+/* Note that clang-format doesn't like the name "xor" for some reason. */
 INLINE __m256i xorv(__m256i a, __m256i b) { return _mm256_xor_si256(a, b); }
 
 INLINE __m256i set1(uint32_t x) { return _mm256_set1_epi32((int32_t)x); }
@@ -39,7 +41,9 @@ INLINE __m256i rot7(__m256i x) {
   return _mm256_or_si256(_mm256_srli_epi32(x, 7), _mm256_slli_epi32(x, 32 - 7));
 }
 
-INLINE void round_fn(__m256i v[16], __m256i m[16], size_t r) {
+/* Round function: upstream-tuned schedule retained to avoid register spills.
+   m is read-only; mark as const to aid compiler. */
+INLINE void round_fn(__m256i v[16], const __m256i m[16], size_t r) {
   v[0] = addv(v[0], m[(size_t)MSG_SCHEDULE[r][0]]);
   v[1] = addv(v[1], m[(size_t)MSG_SCHEDULE[r][2]]);
   v[2] = addv(v[2], m[(size_t)MSG_SCHEDULE[r][4]]);
@@ -220,8 +224,9 @@ INLINE void load_counters(uint64_t count
   const __m256i add0 = _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0);
   const __m256i add1 = _mm256_and_si256(mask, add0);
   __m256i l = _mm256_add_epi32(_mm256_set1_epi32((int32_t)counter), add1);
-  __m256i carry = _mm256_cmpgt_epi32(_mm256_xor_si256(add1, _mm256_set1_epi32(0x80000000)), 
-                                     _mm256_xor_si256(   l, _mm256_set1_epi32(0x80000000)));
+  __m256i carry = _mm256_cmpgt_epi32(
+      _mm256_xor_si256(add1, _mm256_set1_epi32(0x80000000)),
+      _mm256_xor_si256(l, _mm256_set1_epi32(0x80000000)));
   __m256i h = _mm256_sub_epi32(_mm256_set1_epi32((int32_t)(counter >> 32)), carry);
   *out_lo = l;
   *out_hi = h;
@@ -239,22 +244,34 @@ void blake3_hash8_avx2(const uint8_t *co
   __m256i counter_low_vec, counter_high_vec;
   load_counters(counter, increment_counter, &counter_low_vec,
                 &counter_high_vec);
-  uint8_t block_flags = flags | flags_start;
+
+  /* Hoist invariant broadcasts */
+  const __m256i block_len_vec = set1(BLAKE3_BLOCK_LEN);
+  const __m256i iv0 = set1(IV[0]);
+  const __m256i iv1 = set1(IV[1]);
+  const __m256i iv2 = set1(IV[2]);
+  const __m256i iv3 = set1(IV[3]);
+  const __m256i flags_first      = set1((uint32_t)(flags | flags_start));
+  const __m256i flags_mid        = set1((uint32_t)(flags));
+  const __m256i flags_last       = set1((uint32_t)(flags | flags_end));
+  const __m256i flags_first_last = set1((uint32_t)(flags | flags_start | flags_end));
 
   for (size_t block = 0; block < blocks; block++) {
-    if (block + 1 == blocks) {
-      block_flags |= flags_end;
-    }
-    __m256i block_len_vec = set1(BLAKE3_BLOCK_LEN);
-    __m256i block_flags_vec = set1(block_flags);
+    const bool is_first = (block == 0);
+    const bool is_last  = (block + 1 == blocks);
+
+    const __m256i block_flags_vec =
+        is_first ? (is_last ? flags_first_last : flags_first)
+                 : (is_last ? flags_last : flags_mid);
+
     __m256i msg_vecs[16];
     transpose_msg_vecs(inputs, block * BLAKE3_BLOCK_LEN, msg_vecs);
 
     __m256i v[16] = {
-        h_vecs[0],       h_vecs[1],        h_vecs[2],     h_vecs[3],
-        h_vecs[4],       h_vecs[5],        h_vecs[6],     h_vecs[7],
-        set1(IV[0]),     set1(IV[1]),      set1(IV[2]),   set1(IV[3]),
-        counter_low_vec, counter_high_vec, block_len_vec, block_flags_vec,
+        h_vecs[0],       h_vecs[1],        h_vecs[2],       h_vecs[3],
+        h_vecs[4],       h_vecs[5],        h_vecs[6],       h_vecs[7],
+        iv0,             iv1,              iv2,             iv3,
+        counter_low_vec, counter_high_vec, block_len_vec,   block_flags_vec,
     };
     round_fn(v, msg_vecs, 0);
     round_fn(v, msg_vecs, 1);
@@ -271,19 +288,31 @@ void blake3_hash8_avx2(const uint8_t *co
     h_vecs[5] = xorv(v[5], v[13]);
     h_vecs[6] = xorv(v[6], v[14]);
     h_vecs[7] = xorv(v[7], v[15]);
-
-    block_flags = flags;
   }
 
   transpose_vecs(h_vecs);
-  storeu(h_vecs[0], &out[0 * sizeof(__m256i)]);
-  storeu(h_vecs[1], &out[1 * sizeof(__m256i)]);
-  storeu(h_vecs[2], &out[2 * sizeof(__m256i)]);
-  storeu(h_vecs[3], &out[3 * sizeof(__m256i)]);
-  storeu(h_vecs[4], &out[4 * sizeof(__m256i)]);
-  storeu(h_vecs[5], &out[5 * sizeof(__m256i)]);
-  storeu(h_vecs[6], &out[6 * sizeof(__m256i)]);
-  storeu(h_vecs[7], &out[7 * sizeof(__m256i)]);
+
+  /* Aligned store fast-path; otherwise fall back to unaligned stores. */
+  const uintptr_t out_addr = (uintptr_t)out;
+  if ((out_addr & 31u) == 0u) {
+    _mm256_store_si256((__m256i *)&out[0 * sizeof(__m256i)], h_vecs[0]);
+    _mm256_store_si256((__m256i *)&out[1 * sizeof(__m256i)], h_vecs[1]);
+    _mm256_store_si256((__m256i *)&out[2 * sizeof(__m256i)], h_vecs[2]);
+    _mm256_store_si256((__m256i *)&out[3 * sizeof(__m256i)], h_vecs[3]);
+    _mm256_store_si256((__m256i *)&out[4 * sizeof(__m256i)], h_vecs[4]);
+    _mm256_store_si256((__m256i *)&out[5 * sizeof(__m256i)], h_vecs[5]);
+    _mm256_store_si256((__m256i *)&out[6 * sizeof(__m256i)], h_vecs[6]);
+    _mm256_store_si256((__m256i *)&out[7 * sizeof(__m256i)], h_vecs[7]);
+  } else {
+    storeu(h_vecs[0], &out[0 * sizeof(__m256i)]);
+    storeu(h_vecs[1], &out[1 * sizeof(__m256i)]);
+    storeu(h_vecs[2], &out[2 * sizeof(__m256i)]);
+    storeu(h_vecs[3], &out[3 * sizeof(__m256i)]);
+    storeu(h_vecs[4], &out[4 * sizeof(__m256i)]);
+    storeu(h_vecs[5], &out[5 * sizeof(__m256i)]);
+    storeu(h_vecs[6], &out[6 * sizeof(__m256i)]);
+    storeu(h_vecs[7], &out[7 * sizeof(__m256i)]);
+  }
 }
 
 #if !defined(BLAKE3_NO_SSE41)
