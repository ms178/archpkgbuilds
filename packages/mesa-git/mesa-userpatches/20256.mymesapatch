From 28fb5a4d00c6ca5c1b5d14b11386fabc1fb9081c Mon Sep 17 00:00:00 2001
From: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Date: Mon, 24 Oct 2022 13:13:29 +0300
Subject: [PATCH 1/5] util/mesa-db: Don't account header size

In order to ease writing mesa-db eviction unit tests, stop accounting
mesa-db cache file header size during checking whether cache file reached
the size limit. This change ensures that older unit tests will keep working
whenever cache header version/size will change.

Signed-off-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
---
 src/util/mesa_cache_db.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/src/util/mesa_cache_db.c b/src/util/mesa_cache_db.c
index 1619ad239f86..2da025b40c51 100644
--- a/src/util/mesa_cache_db.c
+++ b/src/util/mesa_cache_db.c
@@ -723,6 +723,19 @@ fail:
    return NULL;
 }
 
+static bool
+mesa_cache_db_has_space_locked(struct mesa_cache_db *db, size_t blob_size)
+{
+   return ftell(db->cache.file) + blob_file_size(blob_size) -
+          sizeof(struct mesa_db_file_header) <= db->max_cache_size;
+}
+
+static size_t
+mesa_cache_db_eviction_size(struct mesa_cache_db *db)
+{
+   return db->max_cache_size / 2 - sizeof(struct mesa_db_file_header);
+}
+
 bool
 mesa_cache_db_entry_write(struct mesa_cache_db *db,
                           const uint8_t *cache_key_160bit,
@@ -745,8 +758,8 @@ mesa_cache_db_entry_write(struct mesa_cache_db *db,
    if (!mesa_db_seek_end(db->cache.file))
       goto fail_fatal;
 
-   if (ftell(db->cache.file) + blob_file_size(blob_size) > db->max_cache_size) {
-      if (!mesa_db_compact(db, MAX2(blob_size, db->max_cache_size / 2)))
+   if (!mesa_cache_db_has_space_locked(db, blob_size)) {
+      if (!mesa_db_compact(db, MAX2(blob_size, mesa_cache_db_eviction_size(db))))
          goto fail_fatal;
    } else {
       if (!mesa_db_update_index(db))
-- 
GitLab


From 0fc94c8b58826d27a6e8b2e037a9fc8549b34c05 Mon Sep 17 00:00:00 2001
From: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Date: Mon, 24 Oct 2022 19:41:59 +0300
Subject: [PATCH 2/5] util/mesa-db: Support removal of cache entries

Add support for removal of cache entries to mesa-db cache. This allows
to have a more predictable unit tests by removing dummy entries that
are added to cache when test-cache is created by unit-testing framework.

Signed-off-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
---
 src/util/disk_cache.c    |  5 ++++
 src/util/mesa_cache_db.c | 57 +++++++++++++++++++++++++++++++++++++---
 src/util/mesa_cache_db.h | 11 ++++++++
 3 files changed, 69 insertions(+), 4 deletions(-)

diff --git a/src/util/disk_cache.c b/src/util/disk_cache.c
index f2c0fc0e8d56..9f5e953b784a 100644
--- a/src/util/disk_cache.c
+++ b/src/util/disk_cache.c
@@ -289,6 +289,11 @@ disk_cache_wait_for_idle(struct disk_cache *cache)
 void
 disk_cache_remove(struct disk_cache *cache, const cache_key key)
 {
+   if (cache->use_cache_db) {
+      mesa_cache_db_entry_remove(&cache->cache_db, key);
+      return;
+   }
+
    char *filename = disk_cache_get_cache_filename(cache, key);
    if (filename == NULL) {
       return;
diff --git a/src/util/mesa_cache_db.c b/src/util/mesa_cache_db.c
index 2da025b40c51..64b360a1c660 100644
--- a/src/util/mesa_cache_db.c
+++ b/src/util/mesa_cache_db.c
@@ -434,7 +434,8 @@ static uint32_t blob_file_size(uint32_t blob_size)
 }
 
 static bool
-mesa_db_compact(struct mesa_cache_db *db, int64_t blob_size)
+mesa_db_compact(struct mesa_cache_db *db, int64_t blob_size,
+                struct mesa_index_db_hash_entry *remove_entry)
 {
    uint32_t num_entries, buffer_size = sizeof(struct mesa_index_db_file_entry);
    struct mesa_db_file_header cache_header, index_header;
@@ -446,7 +447,7 @@ mesa_db_compact(struct mesa_cache_db *db, int64_t blob_size)
    unsigned int i = 0;
 
    /* reload index to sync the last access times */
-   if (!mesa_db_reload(db))
+   if (!remove_entry && !mesa_db_reload(db))
       return false;
 
    num_entries = _mesa_hash_table_num_entries(db->index_db->table);
@@ -469,7 +470,7 @@ mesa_db_compact(struct mesa_cache_db *db, int64_t blob_size)
 
    hash_table_foreach(db->index_db->table, entry) {
       entries[i] = entry->data;
-      entries[i]->evicted = false;
+      entries[i]->evicted = (entries[i] == remove_entry);
       buffer_size = MAX2(buffer_size, blob_file_size(entries[i]->size));
       i++;
    }
@@ -759,7 +760,8 @@ mesa_cache_db_entry_write(struct mesa_cache_db *db,
       goto fail_fatal;
 
    if (!mesa_cache_db_has_space_locked(db, blob_size)) {
-      if (!mesa_db_compact(db, MAX2(blob_size, mesa_cache_db_eviction_size(db))))
+      if (!mesa_db_compact(db, MAX2(blob_size, mesa_cache_db_eviction_size(db)),
+                           NULL))
          goto fail_fatal;
    } else {
       if (!mesa_db_update_index(db))
@@ -821,4 +823,51 @@ fail:
    return false;
 }
 
+bool
+mesa_cache_db_entry_remove(struct mesa_cache_db *db,
+                           const uint8_t *cache_key_160bit)
+{
+   uint64_t hash = to_mesa_cache_db_hash(cache_key_160bit);
+   struct mesa_cache_db_file_entry cache_entry;
+   struct mesa_index_db_hash_entry *hash_entry;
+
+   if (!mesa_db_lock(db))
+      return NULL;
+
+   if (!db->alive)
+      goto fail;
+
+   if (mesa_db_uuid_changed(db) && !mesa_db_reload(db))
+      goto fail_fatal;
+
+   if (!mesa_db_update_index(db))
+      goto fail_fatal;
+
+   hash_entry = _mesa_hash_table_u64_search(db->index_db, hash);
+   if (!hash_entry)
+      goto fail;
+
+   if (!mesa_db_seek(db->cache.file, hash_entry->cache_db_file_offset) ||
+       !mesa_db_read(db->cache.file, &cache_entry) ||
+       !mesa_db_cache_entry_valid(&cache_entry))
+      goto fail_fatal;
+
+   if (memcmp(cache_entry.key, cache_key_160bit, sizeof(cache_entry.key)))
+      goto fail;
+
+   if (!mesa_db_compact(db, 0, hash_entry))
+      goto fail_fatal;
+
+   mesa_db_unlock(db);
+
+   return true;
+
+fail_fatal:
+   mesa_db_zap(db);
+fail:
+   mesa_db_unlock(db);
+
+   return false;
+}
+
 #endif /* DETECT_OS_WINDOWS */
diff --git a/src/util/mesa_cache_db.h b/src/util/mesa_cache_db.h
index 1be102f7ceb8..16b774268428 100644
--- a/src/util/mesa_cache_db.h
+++ b/src/util/mesa_cache_db.h
@@ -62,6 +62,10 @@ bool
 mesa_cache_db_entry_write(struct mesa_cache_db *db,
                           const uint8_t *cache_key_160bit,
                           const void *blob, size_t blob_size);
+
+bool
+mesa_cache_db_entry_remove(struct mesa_cache_db *db,
+                           const uint8_t *cache_key_160bit);
 #else
 static inline bool
 mesa_cache_db_open(struct mesa_cache_db *db, const char *cache_path)
@@ -101,6 +105,13 @@ mesa_cache_db_entry_write(struct mesa_cache_db *db,
 {
    return false;
 }
+
+bool
+mesa_cache_db_entry_remove(struct mesa_cache_db *db,
+                           const uint8_t *cache_key_160bit)
+{
+   return false;
+}
 #endif /* DETECT_OS_WINDOWS */
 
 #ifdef __cplusplus
-- 
GitLab


From f1cf5c3e292cd7cb619d3a25d3352a38310b4190 Mon Sep 17 00:00:00 2001
From: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Date: Mon, 24 Oct 2022 19:47:03 +0300
Subject: [PATCH 3/5] util/cache_test: Remove dummy cache entry added by
 cache_exists()

The cache_exists() function adds a dummy cache entry that may affect cache
eviction testing results. Remove this entry.

Signed-off-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
---
 src/util/tests/cache_test.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/util/tests/cache_test.cpp b/src/util/tests/cache_test.cpp
index f0164b4fc720..7043f7dc2055 100644
--- a/src/util/tests/cache_test.cpp
+++ b/src/util/tests/cache_test.cpp
@@ -121,6 +121,7 @@ cache_exists(struct disk_cache *cache)
    disk_cache_put(cache, key, data, sizeof(data), NULL);
    disk_cache_wait_for_idle(cache);
    void *result = disk_cache_get(cache, key, NULL);
+   disk_cache_remove(cache, key);
 
    free(result);
    return result != NULL;
-- 
GitLab


From f8c0bcff65207454a1e67446ff06a82e847b051d Mon Sep 17 00:00:00 2001
From: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Date: Mon, 24 Oct 2022 13:24:16 +0300
Subject: [PATCH 4/5] util/mesa-db: Introduce multipart mesa-db cache

Whenever a single file mesa-db cache hits max size limit, a half of cache
is evicted and the cache file is defragmented. The downside of this eviction
strategy is that it causes high disk IO usage during eviction if mesa-db
cache file size is large.

In order to mitigate this downside, we will split mesa-db into multiple
part such that only one part will be evicted at a time. Each part will be
an individual single file mesa-db cache, like a DB shard. The new multipart
mesa-db cache will merge the parts into a single virtual cache.

This patch introduces two new environment variables:

1. MESA_DISK_CACHE_DATABASE_NUM_PARTS:
Controls number of mesa-db cache file parts. By default 50 parts will be
created. The old pre-multipart mesa-db cache files will be auto-removed
if they exist, i.e. Mesa will switch to the new DB version automatically.

2. MESA_DISK_CACHE_DATABASE_EVICTION_SCORE_2X_PERIOD:
Controls the eviction score doubling time period. The evicted DB part
selection is based on cache entries size weighted by 'last_access_time' of
the entries. By default the cache eviction score is doubled for each month
of cache entry age, i.e. for two equally sized entries where one entry is
older by one month than the other, the older entry will have x2 eviction
score than the other entry. Database part with a highest total eviction
score is selected for eviction.

This patch brings x40 performance improvement of cache eviction time using
multipart cache vs a single file cache due to a smaller eviction portions
and more optimized eviction algorithm.

Signed-off-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
---
 docs/envvars.rst                   |  11 ++
 src/util/mesa_cache_db.c           | 126 +++++++++++++++++++++++
 src/util/mesa_cache_db.h           |  27 +++++
 src/util/mesa_cache_db_multipart.c | 159 +++++++++++++++++++++++++++++
 src/util/mesa_cache_db_multipart.h |  44 ++++++++
 src/util/meson.build               |   2 +
 src/util/tests/cache_test.cpp      | 102 ++++++++++++++++++
 7 files changed, 471 insertions(+)
 create mode 100644 src/util/mesa_cache_db_multipart.c
 create mode 100644 src/util/mesa_cache_db_multipart.h

diff --git a/docs/envvars.rst b/docs/envvars.rst
index f2b246a15ccf..0a5750096757 100644
--- a/docs/envvars.rst
+++ b/docs/envvars.rst
@@ -201,6 +201,17 @@ Core Mesa environment variables
    variable is set), or else within ``.cache/mesa_shader_cache`` within
    the user's home directory.
 
+.. envvar:: MESA_DISK_CACHE_DATABASE_NUM_PARTS
+
+   specifies number of mesa-db cache parts, default is 50.
+
+.. envvar:: MESA_DISK_CACHE_DATABASE_EVICTION_SCORE_2X_PERIOD
+
+   Mesa-DB cache eviction algorithm calculates weighted score for the
+   cache items. The weight is doubled based on the last access time of
+   cache entry. By default period of weight doubling is set to one month.
+   Period value is given in seconds.
+
 .. envvar:: MESA_SHADER_CACHE_SHOW_STATS
 
    if set to ``true``, keeps hit/miss statistics for the shader cache.
diff --git a/src/util/mesa_cache_db.c b/src/util/mesa_cache_db.c
index 64b360a1c660..7cd0ca4e4363 100644
--- a/src/util/mesa_cache_db.c
+++ b/src/util/mesa_cache_db.c
@@ -25,6 +25,7 @@
 #include "mesa_cache_db.h"
 #include "os_time.h"
 #include "ralloc.h"
+#include "u_debug.h"
 #include "u_qsort.h"
 
 #define MESA_CACHE_DB_VERSION          1
@@ -398,6 +399,19 @@ mesa_db_close_file(struct mesa_cache_db_file *db_file)
    free(db_file->path);
 }
 
+static bool
+mesa_db_remove_file(struct mesa_cache_db_file *db_file,
+                  const char *cache_path,
+                  const char *filename)
+{
+   if (asprintf(&db_file->path, "%s/%s", cache_path, filename) == -1)
+      return false;
+
+   unlink(db_file->path);
+
+   return true;
+}
+
 static int
 entry_sort_lru(const void *_a, const void *_b, void *arg)
 {
@@ -625,6 +639,22 @@ close_cache:
    return false;
 }
 
+bool
+mesa_db_wipe_path(const char *cache_path)
+{
+   struct mesa_cache_db db = {0};
+   bool success = true;
+
+   if (!mesa_db_remove_file(&db.cache, cache_path, "mesa_cache.db") ||
+       !mesa_db_remove_file(&db.index, cache_path, "mesa_cache.idx"))
+      success = false;
+
+   free(db.cache.path);
+   free(db.index.path);
+
+   return success;
+}
+
 void
 mesa_cache_db_close(struct mesa_cache_db *db)
 {
@@ -870,4 +900,100 @@ fail:
    return false;
 }
 
+bool
+mesa_cache_db_has_space(struct mesa_cache_db *db, size_t blob_size)
+{
+   bool has_space;
+
+   if (!mesa_db_lock(db))
+      return false;
+
+   if (!mesa_db_seek_end(db->cache.file))
+      goto fail_fatal;
+
+   has_space = mesa_cache_db_has_space_locked(db, blob_size);
+
+   mesa_db_unlock(db);
+
+   return has_space;
+
+fail_fatal:
+   mesa_db_zap(db);
+   mesa_db_unlock(db);
+
+   return false;
+}
+
+static uint64_t
+mesa_cache_db_eviction_2x_score_period(void)
+{
+   const uint64_t nsec_per_sec = 1000000000ull;
+   static uint64_t period = 0;
+
+   if (period)
+      return period;
+
+   period = debug_get_num_option("MESA_DISK_CACHE_DATABASE_EVICTION_SCORE_2X_PERIOD",
+                                 30 * 24 * 60 * 60) * nsec_per_sec;
+
+   return period;
+}
+
+double
+mesa_cache_db_eviction_score(struct mesa_cache_db *db)
+{
+   int64_t eviction_size = mesa_cache_db_eviction_size(db);
+   struct mesa_index_db_hash_entry **entries;
+   unsigned num_entries, i = 0;
+   double eviction_score = 0;
+
+   if (!mesa_db_lock(db))
+      return 0;
+
+   if (!db->alive)
+      goto fail;
+
+   if (!mesa_db_reload(db))
+      goto fail_fatal;
+
+   num_entries = _mesa_hash_table_num_entries(db->index_db->table);
+   entries = calloc(num_entries, sizeof(*entries));
+   if (!entries)
+      goto fail;
+
+   hash_table_foreach(db->index_db->table, entry)
+      entries[i++] = entry->data;
+
+   util_qsort_r(entries, num_entries, sizeof(*entries),
+                entry_sort_lru, db);
+
+   for (i = 0; eviction_size > 0 && i < num_entries; i++) {
+      uint64_t entry_age = os_time_get_nano() - entries[i]->last_access_time;
+      unsigned entry_size = blob_file_size(entries[i]->size);
+
+      /* Eviction score is a sum of weighted cache entry sizes,
+       * where weight doubles for each month of entry's age.
+       */
+      uint64_t period = mesa_cache_db_eviction_2x_score_period();
+      double entry_scale = 1 + (double)entry_age / period;
+      double entry_score = entry_size * entry_scale;
+
+      eviction_score += entry_score;
+      eviction_size -= entry_size;
+   }
+
+   free(entries);
+
+   mesa_db_unlock(db);
+
+   return eviction_score;
+
+fail_fatal:
+   mesa_db_zap(db);
+fail:
+   mesa_db_unlock(db);
+
+   return 0;
+}
+
 #endif /* DETECT_OS_WINDOWS */
diff --git a/src/util/mesa_cache_db.h b/src/util/mesa_cache_db.h
index 16b774268428..d88f67ddd4da 100644
--- a/src/util/mesa_cache_db.h
+++ b/src/util/mesa_cache_db.h
@@ -66,6 +66,15 @@ mesa_cache_db_entry_write(struct mesa_cache_db *db,
 bool
 mesa_cache_db_entry_remove(struct mesa_cache_db *db,
                            const uint8_t *cache_key_160bit);
+
+bool
+mesa_db_wipe_path(const char *cache_path);
+
+bool
+mesa_cache_db_has_space(struct mesa_cache_db *db, size_t blob_size);
+
+double
+mesa_cache_db_eviction_score(struct mesa_cache_db *db);
 #else
 static inline bool
 mesa_cache_db_open(struct mesa_cache_db *db, const char *cache_path)
@@ -112,6 +121,24 @@ mesa_cache_db_entry_remove(struct mesa_cache_db *db,
 {
    return false;
 }
+
+static inline bool
+mesa_db_wipe_path(const char *cache_path)
+{
+   return false;
+}
+
+static inline bool
+mesa_cache_db_has_space(struct mesa_cache_db *db, size_t blob_size)
+{
+   return false;
+}
+
+static inline double
+mesa_cache_db_eviction_score(struct mesa_cache_db *db)
+{
+   return 0;
+}
 #endif /* DETECT_OS_WINDOWS */
 
 #ifdef __cplusplus
diff --git a/src/util/mesa_cache_db_multipart.c b/src/util/mesa_cache_db_multipart.c
new file mode 100644
index 000000000000..989cc2c0bf0f
--- /dev/null
+++ b/src/util/mesa_cache_db_multipart.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright © 2022 Collabora, Ltd.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#include <sys/stat.h>
+
+#include "detect_os.h"
+#include "string.h"
+#include "mesa_cache_db_multipart.h"
+#include "u_debug.h"
+
+bool
+mesa_cache_db_multipart_open(struct mesa_cache_db_multipart *db,
+                             const char *cache_path)
+{
+   char *part_path = NULL;
+   unsigned int i;
+
+   if (DETECT_OS_WINDOWS)
+      return false;
+
+   db->num_parts = debug_get_num_option("MESA_DISK_CACHE_DATABASE_NUM_PARTS", 50);
+
+   db->parts = calloc(db->num_parts, sizeof(*db->parts));
+   if (!db->parts)
+      return false;
+
+   for (i = 0; i < db->num_parts; i++) {
+      bool db_opened = false;
+
+      if (asprintf(&part_path, "%s/part%u", cache_path, i) == -1)
+         goto close_db;
+
+      if (mkdir(part_path, 0755) == -1 && errno != EEXIST)
+         goto free_path;
+
+      /* DB opening may fail only in a case of a severe problem,
+       * like IO error.
+       */
+      db_opened = mesa_cache_db_open(&db->parts[i], part_path);
+      if (!db_opened)
+         goto free_path;
+
+      free(part_path);
+   }
+
+   /* remove old pre multi-part cache */
+   mesa_db_wipe_path(cache_path);
+
+   return true;
+
+free_path:
+   free(part_path);
+close_db:
+   while (i--)
+      mesa_cache_db_close(&db->parts[i]);
+
+   free(db->parts);
+
+   return false;
+}
+
+void
+mesa_cache_db_multipart_close(struct mesa_cache_db_multipart *db)
+{
+   while (db->num_parts--)
+      mesa_cache_db_close(&db->parts[db->num_parts]);
+
+   free(db->parts);
+}
+
+void
+mesa_cache_db_multipart_set_size_limit(struct mesa_cache_db_multipart *db,
+                                       uint64_t max_cache_size)
+{
+   for (unsigned int i = 0; i < db->num_parts; i++)
+      mesa_cache_db_set_size_limit(&db->parts[i],
+                                   max_cache_size / db->num_parts);
+}
+
+void *
+mesa_cache_db_multipart_read_entry(struct mesa_cache_db_multipart *db,
+                                   const uint8_t *cache_key_160bit,
+                                   size_t *size)
+{
+   unsigned last_read_part = db->last_read_part;
+
+   for (unsigned int i = 0; i < db->num_parts; i++) {
+      unsigned int part = (last_read_part + i) % db->num_parts;
+
+      void *cache_item = mesa_cache_db_read_entry(&db->parts[part],
+                                                  cache_key_160bit, size);
+      if (cache_item) {
+         /* Likely that the next entry lookup will hit the same DB part. */
+         db->last_read_part = part;
+         return cache_item;
+      }
+   }
+
+   return NULL;
+}
+
+static unsigned
+mesa_cache_db_multipart_select_victim_part(struct mesa_cache_db_multipart *db)
+{
+   double best_score = 0, score;
+   unsigned victim = 0;
+
+   for (unsigned int i = 0; i < db->num_parts; i++) {
+      score = mesa_cache_db_eviction_score(&db->parts[i]);
+      if (score > best_score) {
+         best_score = score;
+         victim = i;
+      }
+   }
+
+   return victim;
+}
+
+bool
+mesa_cache_db_multipart_entry_write(struct mesa_cache_db_multipart *db,
+                                    const uint8_t *cache_key_160bit,
+                                    const void *blob, size_t blob_size)
+{
+   unsigned last_written_part = db->last_written_part;
+   int wpart = -1;
+
+   for (unsigned int i = 0; i < db->num_parts; i++) {
+      unsigned int part = (last_written_part + i) % db->num_parts;
+
+      /* Note that each DB part has own locking. */
+      if (mesa_cache_db_has_space(&db->parts[part], blob_size)) {
+         wpart = part;
+         break;
+      }
+   }
+
+   /* All DB parts are full. Writing to a full DB part will auto-trigger
+    * eviction of LRU cache entries from the part. Select DB part that
+    * contains majority of LRU cache entries.
+    */
+   if (wpart < 0)
+      wpart = mesa_cache_db_multipart_select_victim_part(db);
+
+   db->last_written_part = wpart;
+
+   return mesa_cache_db_entry_write(&db->parts[wpart], cache_key_160bit,
+                                    blob, blob_size);
+}
+
+void
+mesa_cache_db_multipart_entry_remove(struct mesa_cache_db_multipart *db,
+                                     const uint8_t *cache_key_160bit)
+{
+   for (unsigned int i = 0; i < db->num_parts; i++)
+      mesa_cache_db_entry_remove(&db->parts[i], cache_key_160bit);
+}
diff --git a/src/util/mesa_cache_db_multipart.h b/src/util/mesa_cache_db_multipart.h
new file mode 100644
index 000000000000..7a1aef5dcb30
--- /dev/null
+++ b/src/util/mesa_cache_db_multipart.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright © 2022 Collabora, Ltd.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#ifndef MESA_CACHE_DB_MULTIPART_H
+#define MESA_CACHE_DB_MULTIPART_H
+
+#include "mesa_cache_db.h"
+
+struct mesa_cache_db_multipart {
+   struct mesa_cache_db *parts;
+   unsigned int num_parts;
+   volatile unsigned int last_read_part;
+   volatile unsigned int last_written_part;
+};
+
+bool
+mesa_cache_db_multipart_open(struct mesa_cache_db_multipart *db,
+                             const char *cache_path);
+
+void
+mesa_cache_db_multipart_close(struct mesa_cache_db_multipart *db);
+
+void
+mesa_cache_db_multipart_set_size_limit(struct mesa_cache_db_multipart *db,
+                                       uint64_t max_cache_size);
+
+void *
+mesa_cache_db_multipart_read_entry(struct mesa_cache_db_multipart *db,
+                                   const uint8_t *cache_key_160bit,
+                                   size_t *size);
+
+bool
+mesa_cache_db_multipart_entry_write(struct mesa_cache_db_multipart *db,
+                                    const uint8_t *cache_key_160bit,
+                                    const void *blob, size_t blob_size);
+
+void
+mesa_cache_db_multipart_entry_remove(struct mesa_cache_db_multipart *db,
+                                     const uint8_t *cache_key_160bit);
+
+#endif /* MESA_CACHE_DB_MULTIPART_H */
diff --git a/src/util/meson.build b/src/util/meson.build
index 6a5881b3d9a3..59f09eacf288 100644
--- a/src/util/meson.build
+++ b/src/util/meson.build
@@ -168,6 +168,8 @@ files_mesa_util = files(
   'indices/u_primconvert.h',
   'mesa_cache_db.c',
   'mesa_cache_db.h',
+  'mesa_cache_db_multipart.c',
+  'mesa_cache_db_multipart.h',
 )
 
 files_drirc = files('00-mesa-defaults.conf')
diff --git a/src/util/tests/cache_test.cpp b/src/util/tests/cache_test.cpp
index 7043f7dc2055..2e42458791ce 100644
--- a/src/util/tests/cache_test.cpp
+++ b/src/util/tests/cache_test.cpp
@@ -744,6 +744,7 @@ TEST_F(Cache, Database)
 #ifndef ENABLE_SHADER_CACHE
    GTEST_SKIP() << "ENABLE_SHADER_CACHE not defined.";
 #else
+   setenv("MESA_DISK_CACHE_DATABASE_NUM_PARTS", "1", 1);
    setenv("MESA_DISK_CACHE_DATABASE", "true", 1);
 
    test_disk_cache_create(mem_ctx, CACHE_DIR_NAME_DB, driver_id);
@@ -774,3 +775,104 @@ TEST_F(Cache, Database)
    EXPECT_EQ(err, 0) << "Removing " CACHE_TEST_TMP " again";
 #endif
 }
+
+static void
+test_multipart_eviction(const char *driver_id)
+{
+   const unsigned int entry_size = 512;
+   uint8_t blobs[7][entry_size];
+   cache_key keys[7];
+   unsigned int i;
+   char *result;
+   size_t size;
+
+   setenv("MESA_SHADER_CACHE_MAX_SIZE", "3K", 1);
+   setenv("MESA_DISK_CACHE_DATABASE_EVICTION_SCORE_2X_PERIOD", "1", 1);
+
+   struct disk_cache *cache = disk_cache_create("test", driver_id, 0);
+
+   unsigned int entry_file_size = entry_size;
+   entry_file_size -= sizeof(struct cache_entry_file_data);
+   entry_file_size -= mesa_cache_db_file_entry_size();
+   entry_file_size -= cache->driver_keys_blob_size;
+   entry_file_size -= 4 + 8; /* cache_item_metadata size + room for alignment */
+
+   /*
+    * 1. Allocate 3KB cache in 3 parts, each part is 1KB
+    * 2. Fill up cache with six 512K entries
+    * 3. Touch entries of the first part, which will bump last_access_time
+    *    of the first two cache entries
+    * 4. Insert seventh 512K entry that will cause eviction of the second part
+    * 5. Check that second entry of the second part gone due to eviction and
+    *    others present
+    */
+
+   /* Fill up cache with six 512K entries. */
+   for (i = 0; i < 6; i++) {
+      memset(blobs[i], i, entry_file_size);
+
+      disk_cache_compute_key(cache,  blobs[i], entry_file_size, keys[i]);
+      disk_cache_put(cache, keys[i], blobs[i], entry_file_size, NULL);
+      disk_cache_wait_for_idle(cache);
+
+      result = (char *) disk_cache_get(cache, keys[i], &size);
+      EXPECT_NE(result, nullptr) << "disk_cache_get with existent item (pointer)";
+      EXPECT_EQ(size, entry_file_size) << "disk_cache_get with existent item (size)";
+      free(result);
+
+      /* Ensure that cache entries will have distinct last_access_time
+       * during testing.
+       */
+      if (i % 2 == 0)
+         usleep(100000);
+   }
+
+   /* Touch entries of the first part. Second part becomes outdated */
+   for (i = 0; i < 2; i++) {
+      result = (char *) disk_cache_get(cache, keys[i], &size);
+      EXPECT_NE(result, nullptr) << "disk_cache_get with existent item (pointer)";
+      EXPECT_EQ(size, entry_file_size) << "disk_cache_get with existent item (size)";
+      free(result);
+   }
+
+   /* Insert seventh entry. */
+   memset(blobs[6], 6, entry_file_size);
+   disk_cache_compute_key(cache,  blobs[6], entry_file_size, keys[6]);
+   disk_cache_put(cache, keys[6], blobs[6], entry_file_size, NULL);
+   disk_cache_wait_for_idle(cache);
+
+   /* Check whether third entry of the second part gone and others present. */
+   for (i = 0; i < ARRAY_SIZE(blobs); i++) {
+      result = (char *) disk_cache_get(cache, keys[i], &size);
+      if (i == 2) {
+         EXPECT_EQ(result, nullptr) << "disk_cache_get with non-existent item (pointer)";
+      } else {
+         EXPECT_NE(result, nullptr) << "disk_cache_get with existent item (pointer)";
+         EXPECT_EQ(size, entry_file_size) << "disk_cache_get with existent item (size)";
+      }
+      free(result);
+   }
+
+   disk_cache_destroy(cache);
+}
+
+TEST_F(Cache, DatabaseMultipartEviction)
+{
+   const char *driver_id = "make_check_uncompressed";
+
+#ifndef ENABLE_SHADER_CACHE
+   GTEST_SKIP() << "ENABLE_SHADER_CACHE not defined.";
+#else
+   setenv("MESA_DISK_CACHE_DATABASE_NUM_PARTS", "3", 1);
+   setenv("MESA_DISK_CACHE_DATABASE", "true", 1);
+
+   test_disk_cache_create(mem_ctx, CACHE_DIR_NAME_DB, driver_id);
+
+   test_multipart_eviction(driver_id);
+
+   setenv("MESA_DISK_CACHE_DATABASE", "false", 1);
+
+   int err = rmrf_local(CACHE_TEST_TMP);
+   EXPECT_EQ(err, 0) << "Removing " CACHE_TEST_TMP " again";
+#endif
+}
-- 
GitLab


From 75dcc67cbbadcd0f4b7c63cc1a57f93d35227144 Mon Sep 17 00:00:00 2001
From: Dmitry Osipenko <dmitry.osipenko@collabora.com>
Date: Mon, 24 Oct 2022 20:46:21 +0300
Subject: [PATCH 5/5] util/disk_cache: Switch to multipart mesa-db cache

Replace single file mesa-db cache with multipart mesa-db cache.
Each part of the multipart cache essentially is a single file
mesa-db cache, aka database shard. Multipart cache brings much
more optimized cache eviction times in comparison to a single file
cache.

Signed-off-by: Dmitry Osipenko <dmitry.osipenko@collabora.com>
---
 src/util/disk_cache.c    |  6 +++---
 src/util/disk_cache_os.c | 11 ++++++-----
 src/util/disk_cache_os.h |  3 ++-
 3 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/src/util/disk_cache.c b/src/util/disk_cache.c
index 9f5e953b784a..55f8b5b5f22e 100644
--- a/src/util/disk_cache.c
+++ b/src/util/disk_cache.c
@@ -187,7 +187,7 @@ disk_cache_create(const char *gpu_name, const char *driver_id,
    cache->max_size = max_size;
 
    if (cache->use_cache_db)
-      mesa_cache_db_set_size_limit(&cache->cache_db, cache->max_size);
+      mesa_cache_db_multipart_set_size_limit(&cache->cache_db, cache->max_size);
 
    /* 4 threads were chosen below because just about all modern CPUs currently
     * available that run Mesa have *at least* 4 cores. For these CPUs allowing
@@ -272,7 +272,7 @@ disk_cache_destroy(struct disk_cache *cache)
          foz_destroy(&cache->foz_db);
 
       if (cache->use_cache_db)
-         mesa_cache_db_close(&cache->cache_db);
+         mesa_cache_db_multipart_close(&cache->cache_db);
 
       disk_cache_destroy_mmap(cache);
    }
@@ -290,7 +290,7 @@ void
 disk_cache_remove(struct disk_cache *cache, const cache_key key)
 {
    if (cache->use_cache_db) {
-      mesa_cache_db_entry_remove(&cache->cache_db, key);
+      mesa_cache_db_multipart_entry_remove(&cache->cache_db, key);
       return;
    }
 
diff --git a/src/util/disk_cache_os.c b/src/util/disk_cache_os.c
index 6ef0e0dd463f..719aa6fc1935 100644
--- a/src/util/disk_cache_os.c
+++ b/src/util/disk_cache_os.c
@@ -1053,8 +1053,8 @@ disk_cache_db_load_item(struct disk_cache *cache, const cache_key key,
                         size_t *size)
 {
    size_t cache_tem_size = 0;
-   void *cache_item = mesa_cache_db_read_entry(&cache->cache_db, key,
-                                               &cache_tem_size);
+   void *cache_item = mesa_cache_db_multipart_read_entry(&cache->cache_db,
+                                                         key, &cache_tem_size);
    if (!cache_item)
       return NULL;
 
@@ -1074,8 +1074,9 @@ disk_cache_db_write_item_to_disk(struct disk_cache_put_job *dc_job)
    if (!create_cache_item_header_and_blob(dc_job, &cache_blob))
       return false;
 
-   bool r = mesa_cache_db_entry_write(&dc_job->cache->cache_db, dc_job->key,
-                                      cache_blob.data, cache_blob.size);
+   bool r = mesa_cache_db_multipart_entry_write(&dc_job->cache->cache_db,
+                                                dc_job->key, cache_blob.data,
+                                                cache_blob.size);
 
    blob_finish(&cache_blob);
    return r;
@@ -1084,7 +1085,7 @@ disk_cache_db_write_item_to_disk(struct disk_cache_put_job *dc_job)
 bool
 disk_cache_db_load_cache_index(void *mem_ctx, struct disk_cache *cache)
 {
-   return mesa_cache_db_open(&cache->cache_db, cache->path);
+   return mesa_cache_db_multipart_open(&cache->cache_db, cache->path);
 }
 #endif
 
diff --git a/src/util/disk_cache_os.h b/src/util/disk_cache_os.h
index 5a34a59961ff..5567ccdc3c1e 100644
--- a/src/util/disk_cache_os.h
+++ b/src/util/disk_cache_os.h
@@ -34,6 +34,7 @@
 
 #include "util/fossilize_db.h"
 #include "util/mesa_cache_db.h"
+#include "util/mesa_cache_db_multipart.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -58,7 +59,7 @@ struct disk_cache {
 
    struct foz_db foz_db;
 
-   struct mesa_cache_db cache_db;
+   struct mesa_cache_db_multipart cache_db;
 
    bool use_cache_db;
 
-- 
GitLab

