From 84ecffd9b4f8fca9259357b311c752875f0a2cbd Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 17 Mar 2023 14:42:19 +0100
Subject: [PATCH 1/3] amd: update amdgpu_drm.h

---
 include/drm-uapi/amdgpu_drm.h | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/include/drm-uapi/amdgpu_drm.h b/include/drm-uapi/amdgpu_drm.h
index b6eb90df5d05..35fdd7921ee3 100644
--- a/include/drm-uapi/amdgpu_drm.h
+++ b/include/drm-uapi/amdgpu_drm.h
@@ -592,6 +592,7 @@ struct drm_amdgpu_gem_va {
 #define AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES	0x07
 #define AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_WAIT    0x08
 #define AMDGPU_CHUNK_ID_SYNCOBJ_TIMELINE_SIGNAL  0x09
+#define AMDGPU_CHUNK_ID_SHADOW		0x0a
 
 struct drm_amdgpu_cs_chunk {
 	__u32		chunk_id;
@@ -599,6 +600,12 @@ struct drm_amdgpu_cs_chunk {
 	__u64		chunk_data;
 };
 
+struct drm_amdgpu_cs_chunk_cp_gfx_shadow {
+	__u64 shadow_va;
+	__u64 csa_va;
+	__u64 gds_va;
+};
+
 struct drm_amdgpu_cs_in {
 	/** Rendering context id */
 	__u32		ctx_id;
@@ -882,6 +889,8 @@ struct drm_amdgpu_cs_chunk_data {
 #define AMDGPU_INFO_MMR_SH_INDEX_SHIFT	8
 #define AMDGPU_INFO_MMR_SH_INDEX_MASK	0xff
 
+#define AMDGPU_INFO_CP_GFX_SHADOW_SIZE	0x22
+
 struct drm_amdgpu_query_fw {
 	/** AMDGPU_INFO_FW_* */
 	__u32 fw_type;
@@ -1193,6 +1202,15 @@ struct drm_amdgpu_info_video_caps {
 	struct drm_amdgpu_info_video_codec_info codec_info[AMDGPU_INFO_VIDEO_CAPS_CODEC_IDX_COUNT];
 };
 
+struct drm_amdgpu_info_cp_gfx_shadow_size {
+    __u32 shadow_size;
+    __u32 shadow_alignment;
+    __u32 csa_size;
+    __u32 csa_alignment;
+    __u32 gds_size;
+    __u32 gds_alignment;
+};
+
 /*
  * Supported GPU families
  */
-- 
GitLab


From a8214895c0ea22680ce37eccc275becea4e35b8d Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 17 Mar 2023 14:43:47 +0100
Subject: [PATCH 2/3] amd: use AMDGPU_INFO_CP_GFX_SHADOW_SIZE

The kernel will return ENOTSUP if this feature isn't
supported for the GPU.
---
 src/amd/common/ac_gpu_info.c |  8 ++++++++
 src/amd/common/ac_gpu_info.h | 10 ++++++++++
 2 files changed, 18 insertions(+)

diff --git a/src/amd/common/ac_gpu_info.c b/src/amd/common/ac_gpu_info.c
index 408748821b86..2ce1d43d6526 100644
--- a/src/amd/common/ac_gpu_info.c
+++ b/src/amd/common/ac_gpu_info.c
@@ -1458,6 +1458,14 @@ bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info)
       info->attribute_ring_size_per_se = 64 * 1024;
    }
 
+   if (info->gfx_level >= GFX11) {
+      assert(sizeof(struct drm_amdgpu_info_cp_gfx_shadow_size) == sizeof(info->fw_based_mcbp));
+      r = amdgpu_query_info(dev, AMDGPU_INFO_CP_GFX_SHADOW_SIZE,
+                            sizeof(info->fw_based_mcbp),
+                            &info->fw_based_mcbp);
+      info->has_fw_based_mcbp = r == 0 && info->fw_based_mcbp.shadow_size > 0;
+   }
+
    set_custom_cu_en_mask(info);
 
    const char *ib_filename = debug_get_option("AMD_PARSE_IB", NULL);
diff --git a/src/amd/common/ac_gpu_info.h b/src/amd/common/ac_gpu_info.h
index b21a3a3baff6..a64592d2e855 100644
--- a/src/amd/common/ac_gpu_info.h
+++ b/src/amd/common/ac_gpu_info.h
@@ -271,6 +271,16 @@ struct radeon_info {
    /* AMD_CU_MASK environment variable or ~0. */
    bool spi_cu_en_has_effect;
    uint32_t spi_cu_en;
+
+   struct {
+      uint32_t shadow_size;
+      uint32_t shadow_alignment;
+      uint32_t csa_size;
+      uint32_t csa_alignment;
+      uint32_t gds_size;
+      uint32_t gds_alignment;
+   } fw_based_mcbp;
+   bool has_fw_based_mcbp;
 };
 
 bool ac_query_gpu_info(int fd, void *dev_p, struct radeon_info *info);
-- 
GitLab


From b4e88a3dfc55c036b0948c06ac12a26d3a764d4c Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 17 Mar 2023 14:44:42 +0100
Subject: [PATCH 3/3] radeonsi: implement fw based mcbp

Some chips support firmware based mcbp. If supported this means
radeonsi needs to allocate 3 buffers and pass them to the firmware.

From there, the firmware will handle mcbp and register shadowing
on its own so we don't need to insert LOAD packet in the preamble.
---
 src/amd/common/ac_shadowed_regs.c             |  6 ++-
 .../drivers/radeonsi/si_cp_reg_shadowing.c    | 50 ++++++++++++++++---
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  7 +++
 src/gallium/drivers/radeonsi/si_pipe.h        |  2 +
 src/gallium/include/winsys/radeon_winsys.h    |  7 +++
 src/gallium/winsys/amdgpu/drm/amdgpu_cs.c     | 22 +++++++-
 src/gallium/winsys/amdgpu/drm/amdgpu_cs.h     |  2 +
 7 files changed, 85 insertions(+), 11 deletions(-)

diff --git a/src/amd/common/ac_shadowed_regs.c b/src/amd/common/ac_shadowed_regs.c
index 1bc9d86e00db..05827e4c5a26 100644
--- a/src/amd/common/ac_shadowed_regs.c
+++ b/src/amd/common/ac_shadowed_regs.c
@@ -4288,6 +4288,8 @@ void ac_create_shadowing_ib_preamble(const struct radeon_info *info,
                CC1_SHADOW_GFX_SH_REGS(1) |
                CC1_SHADOW_GLOBAL_UCONFIG(1));
 
-   for (unsigned i = 0; i < SI_NUM_SHADOWED_REG_RANGES; i++)
-      ac_build_load_reg(info, pm4_cmd_add, pm4_cmdbuf, i, gpu_address);
+   if (!info->has_fw_based_mcbp) {
+      for (unsigned i = 0; i < SI_NUM_SHADOWED_REG_RANGES; i++)
+         ac_build_load_reg(info, pm4_cmd_add, pm4_cmdbuf, i, gpu_address);
+   }
 }
diff --git a/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c b/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
index ecdbc5ec71cc..2cb3dc015c89 100644
--- a/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
+++ b/src/gallium/drivers/radeonsi/si_cp_reg_shadowing.c
@@ -41,14 +41,42 @@ void si_init_cp_reg_shadowing(struct si_context *sctx)
    if (sctx->has_graphics &&
        (sctx->screen->info.mid_command_buffer_preemption_enabled ||
         sctx->screen->debug_flags & DBG(SHADOW_REGS))) {
-      sctx->shadowed_regs =
-            si_aligned_buffer_create(sctx->b.screen,
-                                     PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
-                                     PIPE_USAGE_DEFAULT,
-                                     SI_SHADOWED_REG_BUFFER_SIZE,
-                                     4096);
-      if (!sctx->shadowed_regs)
-         fprintf(stderr, "radeonsi: cannot create a shadowed_regs buffer\n");
+      if (sctx->screen->info.has_fw_based_mcbp) {
+         sctx->shadowed_regs =
+               si_aligned_buffer_create(sctx->b.screen,
+                                        PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
+                                        PIPE_USAGE_DEFAULT,
+                                        sctx->screen->info.fw_based_mcbp.shadow_size,
+                                        sctx->screen->info.fw_based_mcbp.shadow_alignment);
+         sctx->mcbp_csa =
+               si_aligned_buffer_create(sctx->b.screen,
+                                        PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
+                                        PIPE_USAGE_DEFAULT,
+                                        sctx->screen->info.fw_based_mcbp.csa_size,
+                                        sctx->screen->info.fw_based_mcbp.csa_alignment);
+         sctx->mcbp_gds =
+               si_aligned_buffer_create(sctx->b.screen,
+                                        PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
+                                        PIPE_USAGE_DEFAULT,
+                                        sctx->screen->info.fw_based_mcbp.gds_size,
+                                        sctx->screen->info.fw_based_mcbp.gds_alignment);
+         if (!sctx->shadowed_regs || !sctx->mcbp_csa || !sctx->mcbp_gds)
+            fprintf(stderr, "radeonsi: cannot create register shadowing buffer(s)\n");
+         else
+            sctx->ws->cs_set_mcbp_reg_shadowing_va(&sctx->gfx_cs,
+                                                   sctx->ws->buffer_get_virtual_address(sctx->shadowed_regs->buf),
+                                                   sctx->ws->buffer_get_virtual_address(sctx->mcbp_csa->buf),
+                                                   sctx->ws->buffer_get_virtual_address(sctx->mcbp_gds->buf));
+      } else {
+         sctx->shadowed_regs =
+               si_aligned_buffer_create(sctx->b.screen,
+                                        PIPE_RESOURCE_FLAG_UNMAPPABLE | SI_RESOURCE_FLAG_DRIVER_INTERNAL,
+                                        PIPE_USAGE_DEFAULT,
+                                        SI_SHADOWED_REG_BUFFER_SIZE,
+                                        4096);
+         if (!sctx->shadowed_regs)
+            fprintf(stderr, "radeonsi: cannot create a shadowed_regs buffer\n");
+      }
    }
 
    si_init_cs_preamble_state(sctx, sctx->shadowed_regs != NULL);
@@ -77,6 +105,12 @@ void si_init_cp_reg_shadowing(struct si_context *sctx)
       /* Initialize shadowed registers as follows. */
       radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, sctx->shadowed_regs,
                                 RADEON_USAGE_READWRITE | RADEON_PRIO_DESCRIPTORS);
+      if (sctx->mcbp_csa)
+         radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, sctx->mcbp_csa,
+                                   RADEON_USAGE_READWRITE | RADEON_PRIO_DESCRIPTORS);
+      if (sctx->mcbp_gds)
+         radeon_add_to_buffer_list(sctx, &sctx->gfx_cs, sctx->mcbp_gds,
+                                   RADEON_USAGE_READWRITE | RADEON_PRIO_DESCRIPTORS);
       si_pm4_emit(sctx, shadowing_preamble);
       ac_emulate_clear_state(&sctx->screen->info, &sctx->gfx_cs, si_set_context_reg_array);
       si_pm4_emit(sctx, sctx->cs_preamble_state);
diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index e6e94ce64d09..54ed44ad3834 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -420,6 +420,13 @@ void si_begin_new_gfx_cs(struct si_context *ctx, bool first_cs)
    if (ctx->shadowed_regs) {
       radeon_add_to_buffer_list(ctx, &ctx->gfx_cs, ctx->shadowed_regs,
                                 RADEON_USAGE_READWRITE | RADEON_PRIO_DESCRIPTORS);
+
+      if (ctx->mcbp_csa)
+         radeon_add_to_buffer_list(ctx, &ctx->gfx_cs, ctx->mcbp_csa,
+                                   RADEON_USAGE_READWRITE | RADEON_PRIO_DESCRIPTORS);
+      if (ctx->mcbp_gds)
+         radeon_add_to_buffer_list(ctx, &ctx->gfx_cs, ctx->mcbp_gds,
+                                   RADEON_USAGE_READWRITE | RADEON_PRIO_DESCRIPTORS);
    }
 
    si_add_all_descriptors_to_bo_list(ctx);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index cfa380480b94..52616355a6ff 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -961,6 +961,8 @@ struct si_context {
    void *query_result_shader;
    void *sh_query_result_shader;
    struct si_resource *shadowed_regs;
+   struct si_resource *mcbp_csa; /* only used if info->has_fw_based_mcbp is true */
+   struct si_resource *mcbp_gds; /* only used if info->has_fw_based_mcbp is true */
 
    void (*emit_cache_flush)(struct si_context *ctx, struct radeon_cmdbuf *cs);
 
diff --git a/src/gallium/include/winsys/radeon_winsys.h b/src/gallium/include/winsys/radeon_winsys.h
index c1d7f6dfd433..9788bc920d59 100644
--- a/src/gallium/include/winsys/radeon_winsys.h
+++ b/src/gallium/include/winsys/radeon_winsys.h
@@ -746,6 +746,13 @@ struct radeon_winsys {
     * Stable pstate
     */
    bool (*cs_set_pstate)(struct radeon_cmdbuf *cs, enum radeon_ctx_pstate state);
+
+   /**
+    * Pass the VAs to the buffers where various information is saved by the FW  during mcbp.
+    */
+   void (*cs_set_mcbp_reg_shadowing_va)(struct radeon_cmdbuf *cs, uint64_t regs_va,
+                                                                  uint64_t csa_va,
+                                                                  uint64_t gds_va);
 };
 
 static inline bool radeon_emitted(struct radeon_cmdbuf *cs, unsigned num_dw)
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
index 7ac0118d7ada..4cbb480cef8c 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
@@ -1490,7 +1490,7 @@ static void amdgpu_cs_submit_ib(void *job, void *gdata, int thread_index)
    if (acs->ip_type == AMD_IP_GFX)
       ws->gfx_bo_list_counter += cs->num_real_buffers;
 
-   struct drm_amdgpu_cs_chunk chunks[7];
+   struct drm_amdgpu_cs_chunk chunks[8];
    unsigned num_chunks = 0;
 
    /* BO list */
@@ -1565,6 +1565,13 @@ static void amdgpu_cs_submit_ib(void *job, void *gdata, int thread_index)
       num_chunks++;
    }
 
+   if (ws->info.has_fw_based_mcbp) {
+      chunks[num_chunks].chunk_id = AMDGPU_CHUNK_ID_SHADOW;
+      chunks[num_chunks].length_dw = sizeof(struct drm_amdgpu_cs_chunk_cp_gfx_shadow) / 4;
+      chunks[num_chunks].chunk_data = (uintptr_t)&acs->mcbp_fw_shadow_chunk;
+      num_chunks++;
+   }
+
    /* Fence */
    if (has_user_fence) {
       chunks[num_chunks].chunk_id = AMDGPU_CHUNK_ID_FENCE;
@@ -1855,6 +1862,16 @@ static bool amdgpu_bo_is_referenced(struct radeon_cmdbuf *rcs,
    return amdgpu_bo_is_referenced_by_cs_with_usage(cs, bo, usage);
 }
 
+static void amdgpu_cs_set_mcbp_reg_shadowing_va(struct radeon_cmdbuf *rcs,uint64_t regs_va,
+                                                                   uint64_t csa_va,
+                                                                   uint64_t gds_va)
+{
+   struct amdgpu_cs *cs = amdgpu_cs(rcs);
+   cs->mcbp_fw_shadow_chunk.shadow_va = regs_va;
+   cs->mcbp_fw_shadow_chunk.csa_va = csa_va;
+   cs->mcbp_fw_shadow_chunk.gds_va = gds_va;
+}
+
 void amdgpu_cs_init_functions(struct amdgpu_screen_winsys *ws)
 {
    ws->base.ctx_create = amdgpu_ctx_create;
@@ -1880,4 +1897,7 @@ void amdgpu_cs_init_functions(struct amdgpu_screen_winsys *ws)
    ws->base.fence_import_sync_file = amdgpu_fence_import_sync_file;
    ws->base.fence_export_sync_file = amdgpu_fence_export_sync_file;
    ws->base.export_signalled_sync_file = amdgpu_export_signalled_sync_file;
+
+   if (ws->aws->info.has_fw_based_mcbp)
+      ws->base.cs_set_mcbp_reg_shadowing_va = amdgpu_cs_set_mcbp_reg_shadowing_va;
 }
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.h b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.h
index 13b8bf73d4f7..5038463db406 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.h
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.h
@@ -161,6 +161,8 @@ struct amdgpu_cs {
    struct util_queue_fence flush_completed;
    struct pipe_fence_handle *next_fence;
    struct pb_buffer *preamble_ib_bo;
+
+   struct drm_amdgpu_cs_chunk_cp_gfx_shadow mcbp_fw_shadow_chunk;
 };
 
 struct amdgpu_fence {
-- 
GitLab

