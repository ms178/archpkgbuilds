From fe99f9c98943d67019da4d783a73d72472113201 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 12 Apr 2023 15:50:57 +0100
Subject: [PATCH 1/2] aco: add get_op_fixed_to_def() helper

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_ir.h                    |  2 +
 src/amd/compiler/aco_register_allocation.cpp | 52 ++++++++++----------
 2 files changed, 28 insertions(+), 26 deletions(-)

diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index a282dc5c7623..9352c1e239f9 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2279,6 +2279,8 @@ void _aco_err(Program* program, const char* file, unsigned line, const char* fmt
 #define aco_perfwarn(program, ...) _aco_perfwarn(program, __FILE__, __LINE__, __VA_ARGS__)
 #define aco_err(program, ...)      _aco_err(program, __FILE__, __LINE__, __VA_ARGS__)
 
+int get_op_fixed_to_def(Instruction* instr);
+
 /* utilities for dealing with register demand */
 RegisterDemand get_live_changes(aco_ptr<Instruction>& instr);
 RegisterDemand get_temp_registers(aco_ptr<Instruction>& instr);
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index ed05b3454aed..c12343f843d4 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2709,6 +2709,29 @@ optimize_encoding(Program* program, ra_ctx& ctx, RegisterFile& register_file,
 
 } /* end namespace */
 
+int
+get_op_fixed_to_def(Instruction* instr)
+{
+   if (instr->opcode == aco_opcode::v_interp_p2_f32 || instr->opcode == aco_opcode::v_mac_f32 ||
+       instr->opcode == aco_opcode::v_fmac_f32 || instr->opcode == aco_opcode::v_mac_f16 ||
+       instr->opcode == aco_opcode::v_fmac_f16 || instr->opcode == aco_opcode::v_mac_legacy_f32 ||
+       instr->opcode == aco_opcode::v_fmac_legacy_f32 ||
+       instr->opcode == aco_opcode::v_pk_fmac_f16 || instr->opcode == aco_opcode::v_writelane_b32 ||
+       instr->opcode == aco_opcode::v_writelane_b32_e64 ||
+       instr->opcode == aco_opcode::v_dot4c_i32_i8) {
+      return 2;
+   } else if (instr->opcode == aco_opcode::s_addk_i32 || instr->opcode == aco_opcode::s_mulk_i32 ||
+              instr->opcode == aco_opcode::s_cmovk_i32) {
+      return 0;
+   } else if (instr->isMUBUF() && instr->definitions.size() == 1 && instr->operands.size() == 4) {
+      return 3;
+   } else if (instr->isMIMG() && instr->definitions.size() == 1 &&
+              !instr->operands[2].isUndefined()) {
+      return 2;
+   }
+   return -1;
+}
+
 void
 register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra_test_policy policy)
 {
@@ -2852,32 +2875,9 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
           * We can't read from the old location because it's corrupted, and we can't write the new
           * location because that's used by a live-through operand.
           */
-         if (instr->opcode == aco_opcode::v_interp_p2_f32 ||
-             instr->opcode == aco_opcode::v_mac_f32 || instr->opcode == aco_opcode::v_fmac_f32 ||
-             instr->opcode == aco_opcode::v_mac_f16 || instr->opcode == aco_opcode::v_fmac_f16 ||
-             instr->opcode == aco_opcode::v_mac_legacy_f32 ||
-             instr->opcode == aco_opcode::v_fmac_legacy_f32 ||
-             instr->opcode == aco_opcode::v_pk_fmac_f16 ||
-             instr->opcode == aco_opcode::v_writelane_b32 ||
-             instr->opcode == aco_opcode::v_writelane_b32_e64 ||
-             instr->opcode == aco_opcode::v_dot4c_i32_i8) {
-            assert(instr->definitions[0].bytes() == instr->operands[2].bytes() ||
-                   instr->operands[2].regClass() == v1);
-            instr->definitions[0].setFixed(instr->operands[2].physReg());
-         } else if (instr->opcode == aco_opcode::s_addk_i32 ||
-                    instr->opcode == aco_opcode::s_mulk_i32 ||
-                    instr->opcode == aco_opcode::s_cmovk_i32) {
-            assert(instr->definitions[0].bytes() == instr->operands[0].bytes());
-            instr->definitions[0].setFixed(instr->operands[0].physReg());
-         } else if (instr->isMUBUF() && instr->definitions.size() == 1 &&
-                    instr->operands.size() == 4) {
-            assert(instr->definitions[0].bytes() == instr->operands[3].bytes());
-            instr->definitions[0].setFixed(instr->operands[3].physReg());
-         } else if (instr->isMIMG() && instr->definitions.size() == 1 &&
-                    !instr->operands[2].isUndefined()) {
-            assert(instr->definitions[0].bytes() == instr->operands[2].bytes());
-            instr->definitions[0].setFixed(instr->operands[2].physReg());
-         }
+         int op_fixed_to_def = get_op_fixed_to_def(instr.get());
+         if (op_fixed_to_def != -1)
+            instr->definitions[0].setFixed(instr->operands[op_fixed_to_def].physReg());
 
          /* handle fixed definitions first */
          for (unsigned i = 0; i < instr->definitions.size(); ++i) {
-- 
GitLab


From 5481be33d0423b6362fd41d851288fafc4e75354 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 12 Apr 2023 16:00:10 +0100
Subject: [PATCH 2/2] aco: consider how definitions fixed to operands can
 change register demand

Usually the register demand before an instruction would be considered part
of the previous instruction, since it's not greater than the register
demand for that previous instruction. Except, it can be greater in the
case of an definition fixed to a non-killed operand: the RA needs to
reserve space between the two instructions for the definition (containing
a copy of the operand).

fossil-db (navi21):
Totals from 5 (0.00% of 135636) affected shaders:
PreVGPRs: 35 -> 40 (+14.29%)

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/8807
---
 src/amd/compiler/aco_live_var_analysis.cpp | 30 ++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index bedc829a9019..493eaa3f1fca 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -50,6 +50,23 @@ get_live_changes(aco_ptr<Instruction>& instr)
    return changes;
 }
 
+void
+handle_def_fixed_to_op(RegisterDemand* demand, RegisterDemand demand_before, Instruction* instr,
+                       int op_idx)
+{
+   /* Usually the register demand before an instruction would be considered part of the previous
+    * instruction, since it's not greater than the register demand for that previous instruction.
+    * Except, it can be greater in the case of an definition fixed to a non-killed operand: the RA
+    * needs to reserve space between the two instructions for the definition (containing a copy of
+    * the operand).
+    */
+   if (instr->definitions[0].bytes() > instr->operands[op_idx].bytes())
+      demand_before += instr->definitions[0].getTemp();
+   else
+      demand_before += instr->operands[op_idx].getTemp();
+   demand->update(demand_before);
+}
+
 RegisterDemand
 get_temp_registers(aco_ptr<Instruction>& instr)
 {
@@ -67,6 +84,13 @@ get_temp_registers(aco_ptr<Instruction>& instr)
          temp_registers += op.getTemp();
    }
 
+   int op_idx = get_op_fixed_to_def(instr.get());
+   if (op_idx != -1 && !instr->operands[op_idx].isKill()) {
+      RegisterDemand before_instr;
+      before_instr -= get_live_changes(instr);
+      handle_def_fixed_to_op(&temp_registers, before_instr, instr.get(), op_idx);
+   }
+
    return temp_registers;
 }
 
@@ -183,6 +207,12 @@ process_live_temps_per_block(Program* program, live& lives, Block* block, unsign
          }
       }
 
+      int op_idx = get_op_fixed_to_def(insn);
+      if (op_idx != -1 && !insn->operands[op_idx].isKill()) {
+         RegisterDemand before_instr = new_demand;
+         handle_def_fixed_to_op(&register_demand[idx], before_instr, insn, op_idx);
+      }
+
       block_register_demand.update(register_demand[idx]);
    }
 
-- 
GitLab

