From 9d65ca1866d0e3a2784adc9268aea45fea0b3c45 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 16 Nov 2022 02:43:23 -0500
Subject: [PATCH 01/12] st/mesa: only call st_manager_validate_framebuffers at
 FBO change or SwapBuffers

Hopefully this doesn't break anything.

There are a lot of places that invalidate drawables, but no place attempted
to call the context directly like this. A few places don't even have
the context.

Explanation:

The DRI frontend uses a global atomic counter per drawable that is
incremented when that drawable changed buffers.
st_manager_validate_framebuffers checks for that atomic counter and
updates the framebuffer state if there is any change. This was called at
every state update, so likely before almost every draw (!!!).

This commit changes that. Everything is the same except that the change
of buffers will not be noticed until the beginning of the next frame or
when the framebuffer state update is triggered by something else.

The effect is that we don't waste time calling
st_manager_validate_framebuffers a million times per frame.
---
 src/gallium/frontends/dri/dri_drawable.c             |  2 ++
 src/gallium/frontends/dri/drisw.c                    |  3 +++
 src/gallium/frontends/glx/xlib/xm_api.c              |  3 +++
 src/gallium/frontends/wgl/stw_st.c                   |  3 +++
 src/gallium/include/frontend/api.h                   |  1 +
 .../targets/haiku-softpipe/GalliumContext.cpp        |  3 +++
 src/mesa/state_tracker/st_atom.c                     |  5 -----
 src/mesa/state_tracker/st_atom_framebuffer.c         |  4 ++++
 src/mesa/state_tracker/st_manager.c                  | 12 ++----------
 9 files changed, 21 insertions(+), 15 deletions(-)

diff --git a/src/gallium/frontends/dri/dri_drawable.c b/src/gallium/frontends/dri/dri_drawable.c
index 83ac52569983..9f312220e972 100644
--- a/src/gallium/frontends/dri/dri_drawable.c
+++ b/src/gallium/frontends/dri/dri_drawable.c
@@ -558,6 +558,8 @@ dri_flush(__DRIcontext *cPriv,
        */
       p_atomic_inc(&drawable->base.stamp);
    }
+
+   st->invalidate_state(st, ST_INVALIDATE_FB_STATE);
 }
 
 /**
diff --git a/src/gallium/frontends/dri/drisw.c b/src/gallium/frontends/dri/drisw.c
index b5c0b7a8ae2e..c885d86b1bb5 100644
--- a/src/gallium/frontends/dri/drisw.c
+++ b/src/gallium/frontends/dri/drisw.c
@@ -274,6 +274,9 @@ drisw_swap_buffers(__DRIdrawable *dPriv)
                                         fence, PIPE_TIMEOUT_INFINITE);
       screen->base.screen->fence_reference(screen->base.screen, &fence, NULL);
       drisw_copy_to_front(ctx->st->pipe, dPriv, ptex);
+
+      /* TODO: remove this if the framebuffer state doesn't change. */
+      ctx->st->invalidate_state(ctx->st, ST_INVALIDATE_FB_STATE);
    }
 }
 
diff --git a/src/gallium/frontends/glx/xlib/xm_api.c b/src/gallium/frontends/glx/xlib/xm_api.c
index 62a774adfa57..a9086511a6f4 100644
--- a/src/gallium/frontends/glx/xlib/xm_api.c
+++ b/src/gallium/frontends/glx/xlib/xm_api.c
@@ -1344,6 +1344,9 @@ void XMesaSwapBuffers( XMesaBuffer b )
    }
 
    xmesa_swap_st_framebuffer(b->stfb);
+
+   /* TODO: remove this if the framebuffer state doesn't change. */
+   xmctx->st->invalidate_state(xmctx->st, ST_INVALIDATE_FB_STATE);
 }
 
 
diff --git a/src/gallium/frontends/wgl/stw_st.c b/src/gallium/frontends/wgl/stw_st.c
index e7862e4b2608..2831c3961cad 100644
--- a/src/gallium/frontends/wgl/stw_st.c
+++ b/src/gallium/frontends/wgl/stw_st.c
@@ -410,6 +410,9 @@ stw_st_flush(struct st_context_iface *stctx,
    if (flags & ST_FLUSH_WAIT)
       pfence = &fence;
    stctx->flush(stctx, flags, pfence, notify_before_flush_cb, &args);
+
+   /* TODO: remove this if the framebuffer state doesn't change. */
+   stctx->invalidate_state(stctx, ST_INVALIDATE_FB_STATE);
 }
 
 /**
diff --git a/src/gallium/include/frontend/api.h b/src/gallium/include/frontend/api.h
index f113b72104a2..76406869e1b4 100644
--- a/src/gallium/include/frontend/api.h
+++ b/src/gallium/include/frontend/api.h
@@ -136,6 +136,7 @@ enum st_attachment_type {
 #define ST_INVALIDATE_FS_CONSTBUF0        (1 << 1)
 #define ST_INVALIDATE_VS_CONSTBUF0        (1 << 2)
 #define ST_INVALIDATE_VERTEX_BUFFERS      (1 << 3)
+#define ST_INVALIDATE_FB_STATE            (1 << 4)
 
 /**
  * Value to st_manager->get_param function.
diff --git a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
index db0ef9e221e8..ca50e097c014 100644
--- a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
+++ b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
@@ -349,6 +349,9 @@ GalliumContext::SwapBuffers(context_id contextID)
 		p_atomic_inc(&buffer->stfbi->stamp);
 	}
 
+        /* TODO: remove this if the framebuffer state doesn't change. */
+        context->st->invalidate_state(context->st, ST_INVALIDATE_FB_STATE);
+
 	Unlock();
 	return B_OK;
 }
diff --git a/src/mesa/state_tracker/st_atom.c b/src/mesa/state_tracker/st_atom.c
index 095474c9f919..0bb8e11e8aac 100644
--- a/src/mesa/state_tracker/st_atom.c
+++ b/src/mesa/state_tracker/st_atom.c
@@ -219,8 +219,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
          st->gfx_shaders_may_be_dirty = false;
       }
 
-      st_manager_validate_framebuffers(st);
-
       if (pipeline == ST_PIPELINE_RENDER)
          pipeline_mask = ST_PIPELINE_RENDER_STATE_MASK;
       else
@@ -228,7 +226,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       break;
 
    case ST_PIPELINE_CLEAR:
-      st_manager_validate_framebuffers(st);
       pipeline_mask = ST_PIPELINE_CLEAR_STATE_MASK;
       break;
 
@@ -238,12 +235,10 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
          st->gfx_shaders_may_be_dirty = false;
       }
 
-      st_manager_validate_framebuffers(st);
       pipeline_mask = ST_PIPELINE_META_STATE_MASK;
       break;
 
    case ST_PIPELINE_UPDATE_FRAMEBUFFER:
-      st_manager_validate_framebuffers(st);
       pipeline_mask = ST_PIPELINE_UPDATE_FB_STATE_MASK;
       break;
 
diff --git a/src/mesa/state_tracker/st_atom_framebuffer.c b/src/mesa/state_tracker/st_atom_framebuffer.c
index 88ca3201b992..15507e25e3c4 100644
--- a/src/mesa/state_tracker/st_atom_framebuffer.c
+++ b/src/mesa/state_tracker/st_atom_framebuffer.c
@@ -36,6 +36,7 @@
 #include "st_context.h"
 #include "st_atom.h"
 #include "st_cb_bitmap.h"
+#include "st_manager.h"
 #include "st_texture.h"
 #include "st_util.h"
 #include "pipe/p_context.h"
@@ -115,6 +116,9 @@ st_update_framebuffer_state( struct st_context *st )
    struct gl_renderbuffer *rb;
    GLuint i;
 
+   /* Window framebuffer changes are received here. */
+   st_manager_validate_framebuffers(st);
+
    st_flush_bitmap_cache(st);
    st_invalidate_readpix_cache(st);
 
diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index 0e8644f2b8d0..19f593263634 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -820,16 +820,6 @@ st_context_flush(struct st_context_iface *stctxi, unsigned flags,
 
    if (flags & ST_FLUSH_FRONT)
       st_manager_flush_frontbuffer(st);
-
-   /* DRI3 changes the framebuffer after SwapBuffers, but we need to invoke
-    * st_manager_validate_framebuffers to notice that.
-    *
-    * Set gfx_shaders_may_be_dirty to invoke st_validate_state in the next
-    * draw call, which will invoke st_manager_validate_framebuffers, but it
-    * won't dirty states if there is no change.
-    */
-   if (flags & ST_FLUSH_END_OF_FRAME)
-      st->gfx_shaders_may_be_dirty = true;
 }
 
 static bool
@@ -985,6 +975,8 @@ st_context_invalidate_state(struct st_context_iface *stctxi,
       st->ctx->Array.NewVertexElements = true;
       st->dirty |= ST_NEW_VERTEX_ARRAYS;
    }
+   if (flags & ST_INVALIDATE_FB_STATE)
+      st->dirty |= ST_NEW_FB_STATE;
 }
 
 
-- 
GitLab


From 5b34cb7c31a621d7c3c1be0ad705b1b628ff3939 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 06:42:07 -0500
Subject: [PATCH 02/12] st/mesa: move check_program_state code into
 _mesa_update_state

_mesa_update_state() receives the _NEW_PROGRAM flag, so we can handle
any shader changes there.

There may be some overhead reduction because gfx_shaders_may_be_dirty
is removed.
---
 src/mesa/main/compute.c                 |   3 +-
 src/mesa/main/mtypes.h                  |   1 -
 src/mesa/main/state.c                   |  99 +++++++++++++++++++-
 src/mesa/state_tracker/st_atom.c        | 117 +-----------------------
 src/mesa/state_tracker/st_atom.h        |   4 +-
 src/mesa/state_tracker/st_cb_bitmap.c   |   3 +-
 src/mesa/state_tracker/st_cb_feedback.c |   2 +-
 src/mesa/state_tracker/st_context.c     |   2 -
 src/mesa/state_tracker/st_context.h     |   6 --
 src/mesa/state_tracker/st_draw.c        |   3 +-
 src/mesa/state_tracker/st_program.c     |   2 +-
 11 files changed, 104 insertions(+), 138 deletions(-)

diff --git a/src/mesa/main/compute.c b/src/mesa/main/compute.c
index 8e585fdf39ac..1705ec6805f5 100644
--- a/src/mesa/main/compute.c
+++ b/src/mesa/main/compute.c
@@ -296,8 +296,7 @@ prepare_compute(struct gl_context *ctx)
       _mesa_update_state(ctx);
 
    if ((st->dirty | ctx->NewDriverState) & st->active_states &
-       ST_PIPELINE_COMPUTE_STATE_MASK ||
-       st->compute_shader_may_be_dirty)
+       ST_PIPELINE_COMPUTE_STATE_MASK)
       st_validate_state(st, ST_PIPELINE_COMPUTE);
 
 }
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 6bd289476ab0..80033bd0fa68 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3581,7 +3581,6 @@ struct gl_context
 
    GLuint TextureStateTimestamp; /**< detect changes to shared state */
 
-   GLboolean LastVertexStageDirty; /**< the last vertex stage has changed */
    GLboolean PointSizeIsSet; /**< the glPointSize value in the shader is set */
 
    /** \name For debugging/development only */
diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 6cbc3dee364b..6f6245859aad 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -56,6 +56,7 @@
 #include "blend.h"
 
 #include "state_tracker/st_context.h"
+#include "state_tracker/st_util.h"
 
 void
 _mesa_update_allow_draw_out_of_order(struct gl_context *ctx)
@@ -292,16 +293,108 @@ update_program(struct gl_context *ctx)
    }
 
    bool vp_changed = ctx->VertexProgram._Current != prevVP;
+   bool tcp_changed = ctx->TessCtrlProgram._Current != prevTCP;
    bool tep_changed = ctx->TessEvalProgram._Current != prevTEP;
    bool gp_changed = ctx->GeometryProgram._Current != prevGP;
+   bool fp_changed = ctx->FragmentProgram._Current != prevFP;
+   bool cp_changed = ctx->ComputeProgram._Current != prevCP;
+
+   /* Set NewDriverState depending on which shaders have changed. */
+   uint64_t dirty = 0;
+
+   /* Flag states used by both new and old shaders to rebind shader resources
+    * (because shaders pack them and reorder them) and to unbind shader
+    * resources properly when transitioning to shaders that don't use them.
+    */
+   if (vp_changed) {
+      ctx->Array.NewVertexElements = true;
+      if (prevVP)
+         dirty |= prevVP->affected_states;
+      if (ctx->VertexProgram._Current)
+         dirty |= ST_NEW_VERTEX_PROGRAM(ctx, ctx->VertexProgram._Current);
+   }
+
+   if (tcp_changed) {
+      if (prevTCP)
+         dirty |= prevTCP->affected_states;
+      if (ctx->TessCtrlProgram._Current)
+         dirty |= ctx->TessCtrlProgram._Current->affected_states;
+   }
+
+   if (tep_changed) {
+      if (prevTEP)
+         dirty |= prevTEP->affected_states;
+      if (ctx->TessEvalProgram._Current)
+         dirty |= ctx->TessEvalProgram._Current->affected_states;
+   }
+
+   if (gp_changed) {
+      if (prevGP)
+         dirty |= prevGP->affected_states;
+      if (ctx->GeometryProgram._Current)
+         dirty |= ctx->GeometryProgram._Current->affected_states;
+   }
+
+   if (fp_changed) {
+      if (prevFP)
+         dirty |= prevFP->affected_states;
+      if (ctx->FragmentProgram._Current)
+         dirty |= ctx->FragmentProgram._Current->affected_states;
+   }
+
+   if (cp_changed) {
+      if (prevCP)
+         dirty |= prevCP->affected_states;
+      if (ctx->ComputeProgram._Current)
+         dirty |= ctx->ComputeProgram._Current->affected_states;
+   }
+
+   struct gl_program *last_vertex_stage;
+   bool last_vertex_stage_dirty;
+
    if (ctx->GeometryProgram._Current) {
-      ctx->LastVertexStageDirty |= gp_changed;
+      last_vertex_stage = ctx->GeometryProgram._Current;
+      last_vertex_stage_dirty = gp_changed;
    } else if (ctx->TessEvalProgram._Current) {
-      ctx->LastVertexStageDirty |= gp_changed | tep_changed;
+      last_vertex_stage = ctx->TessEvalProgram._Current;
+      last_vertex_stage_dirty = gp_changed | tep_changed;
    } else {
-      ctx->LastVertexStageDirty |= gp_changed | tep_changed | vp_changed;
+      last_vertex_stage = ctx->VertexProgram._Current;
+      last_vertex_stage_dirty = gp_changed | tep_changed | vp_changed;
    }
 
+   /* Find out the number of viewports. This determines how many scissors
+    * and viewport states we need to update.
+    */
+   struct st_context *st = ctx->st;
+   unsigned num_viewports = 1;
+
+   if (last_vertex_stage &&
+       last_vertex_stage->info.outputs_written & (
+             VARYING_BIT_VIEWPORT | VARYING_BIT_VIEWPORT_MASK))
+      num_viewports = ctx->Const.MaxViewports;
+
+   if (st->state.num_viewports != num_viewports) {
+      st->state.num_viewports = num_viewports;
+      dirty |= ST_NEW_VIEWPORT;
+
+      if (ctx->Scissor.EnableFlags & u_bit_consecutive(0, num_viewports))
+         dirty |= ST_NEW_SCISSOR;
+   }
+
+   if (st->lower_point_size && last_vertex_stage_dirty &&
+       !ctx->VertexProgram.PointSizeEnabled && !ctx->PointSizeIsSet) {
+      if (ctx->GeometryProgram._Current) {
+         st->dirty |= ST_NEW_GS_CONSTANTS;
+      } else if (ctx->TessEvalProgram._Current) {
+         st->dirty |= ST_NEW_TES_CONSTANTS;
+      } else {
+         st->dirty |= ST_NEW_VS_CONSTANTS;
+      }
+   }
+
+   ctx->NewDriverState |= dirty;
+
    /* Let the driver know what's happening:
     */
    if (ctx->FragmentProgram._Current != prevFP ||
diff --git a/src/mesa/state_tracker/st_atom.c b/src/mesa/state_tracker/st_atom.c
index 0bb8e11e8aac..f2ceb59c4a11 100644
--- a/src/mesa/state_tracker/st_atom.c
+++ b/src/mesa/state_tracker/st_atom.c
@@ -65,104 +65,11 @@ void st_init_atoms( struct st_context *st )
    call_once(&flag, init_atoms_once);
 }
 
-
 void st_destroy_atoms( struct st_context *st )
 {
    /* no-op */
 }
 
-
-/* Too complex to figure out, just check every time:
- */
-static void check_program_state( struct st_context *st )
-{
-   struct gl_context *ctx = st->ctx;
-   struct gl_program *old_vp = st->vp;
-   struct gl_program *old_tcp = st->tcp;
-   struct gl_program *old_tep = st->tep;
-   struct gl_program *old_gp = st->gp;
-   struct gl_program *old_fp = st->fp;
-
-   struct gl_program *new_vp = ctx->VertexProgram._Current;
-   struct gl_program *new_tcp = ctx->TessCtrlProgram._Current;
-   struct gl_program *new_tep = ctx->TessEvalProgram._Current;
-   struct gl_program *new_gp = ctx->GeometryProgram._Current;
-   struct gl_program *new_fp = ctx->FragmentProgram._Current;
-   uint64_t dirty = 0;
-   unsigned num_viewports = 1;
-
-   /* Flag states used by both new and old shaders to unbind shader resources
-    * properly when transitioning to shaders that don't use them.
-    */
-   if (unlikely(new_vp != old_vp)) {
-      ctx->Array.NewVertexElements = true;
-      if (old_vp)
-         dirty |= old_vp->affected_states;
-      if (new_vp)
-         dirty |= ST_NEW_VERTEX_PROGRAM(st, new_vp);
-   }
-
-   if (unlikely(new_tcp != old_tcp)) {
-      if (old_tcp)
-         dirty |= old_tcp->affected_states;
-      if (new_tcp)
-         dirty |= new_tcp->affected_states;
-   }
-
-   if (unlikely(new_tep != old_tep)) {
-      if (old_tep)
-         dirty |= old_tep->affected_states;
-      if (new_tep)
-         dirty |= new_tep->affected_states;
-   }
-
-   if (unlikely(new_gp != old_gp)) {
-      if (old_gp)
-         dirty |= old_gp->affected_states;
-      if (new_gp)
-         dirty |= new_gp->affected_states;
-   }
-
-   if (unlikely(new_fp != old_fp)) {
-      if (old_fp)
-         dirty |= old_fp->affected_states;
-      if (new_fp)
-         dirty |= new_fp->affected_states;
-   }
-
-   /* Find out the number of viewports. This determines how many scissors
-    * and viewport states we need to update.
-    */
-   struct gl_program *last_prim_shader = new_gp ? new_gp :
-                                         new_tep ? new_tep : new_vp;
-   if (last_prim_shader &&
-       last_prim_shader->info.outputs_written & (
-             VARYING_BIT_VIEWPORT | VARYING_BIT_VIEWPORT_MASK))
-      num_viewports = ctx->Const.MaxViewports;
-
-   if (st->state.num_viewports != num_viewports) {
-      st->state.num_viewports = num_viewports;
-      dirty |= ST_NEW_VIEWPORT;
-
-      if (ctx->Scissor.EnableFlags & u_bit_consecutive(0, num_viewports))
-         dirty |= ST_NEW_SCISSOR;
-   }
-
-   if (st->lower_point_size && st->ctx->LastVertexStageDirty &&
-       !st->ctx->VertexProgram.PointSizeEnabled && !st->ctx->PointSizeIsSet) {
-      if (new_gp) {
-         st->dirty |= ST_NEW_GS_CONSTANTS;
-      } else if (new_tep) {
-         st->dirty |= ST_NEW_TES_CONSTANTS;
-      } else {
-         st->dirty |= ST_NEW_VS_CONSTANTS;
-      }
-   }
-   st->ctx->LastVertexStageDirty = false;
-
-   st->dirty |= dirty;
-}
-
 void st_update_edgeflags(struct st_context *st, bool per_vertex_edgeflags)
 {
    bool edgeflags_enabled = st->ctx->Polygon.FrontMode != GL_FILL ||
@@ -174,7 +81,7 @@ void st_update_edgeflags(struct st_context *st, bool per_vertex_edgeflags)
 
       struct gl_program *vp = st->ctx->VertexProgram._Current;
       if (vp)
-         st->dirty |= ST_NEW_VERTEX_PROGRAM(st, vp);
+         st->dirty |= ST_NEW_VERTEX_PROGRAM(st->ctx, vp);
    }
 
    bool edgeflag_culls_prims = edgeflags_enabled && !vertdata_edgeflags &&
@@ -214,11 +121,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       if (st->ctx->API == API_OPENGL_COMPAT)
          check_attrib_edgeflag(st);
 
-      if (st->gfx_shaders_may_be_dirty) {
-         check_program_state(st);
-         st->gfx_shaders_may_be_dirty = false;
-      }
-
       if (pipeline == ST_PIPELINE_RENDER)
          pipeline_mask = ST_PIPELINE_RENDER_STATE_MASK;
       else
@@ -230,11 +132,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       break;
 
    case ST_PIPELINE_META:
-      if (st->gfx_shaders_may_be_dirty) {
-         check_program_state(st);
-         st->gfx_shaders_may_be_dirty = false;
-      }
-
       pipeline_mask = ST_PIPELINE_META_STATE_MASK;
       break;
 
@@ -243,18 +140,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       break;
 
    case ST_PIPELINE_COMPUTE: {
-      struct gl_program *old_cp = st->cp;
-      struct gl_program *new_cp = ctx->ComputeProgram._Current;
-
-      if (new_cp != old_cp) {
-         if (old_cp)
-            st->dirty |= old_cp->affected_states;
-         assert(new_cp);
-         st->dirty |= new_cp->affected_states;
-      }
-
-      st->compute_shader_may_be_dirty = false;
-
       /*
        * We add the ST_NEW_FB_STATE bit here as well, because glBindFramebuffer
        * acts as a barrier that breaks feedback loops between the framebuffer
diff --git a/src/mesa/state_tracker/st_atom.h b/src/mesa/state_tracker/st_atom.h
index e616c0d8c4b4..62d13955fb8d 100644
--- a/src/mesa/state_tracker/st_atom.h
+++ b/src/mesa/state_tracker/st_atom.h
@@ -120,8 +120,8 @@ enum {
                                  ST_NEW_SAMPLE_STATE | \
                                  ST_NEW_SAMPLE_SHADING)
 
-#define ST_NEW_VERTEX_PROGRAM(st, p) ((p)->affected_states | \
-                                      (st_user_clip_planes_enabled(st->ctx) ? \
+#define ST_NEW_VERTEX_PROGRAM(ctx, p) ((p)->affected_states | \
+                                      (st_user_clip_planes_enabled(ctx) ? \
                                        ST_NEW_CLIP_STATE : 0))
 
 #define ST_NEW_CONSTANTS        (ST_NEW_VS_CONSTANTS | \
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index bfe8de4fd0c0..7b2433ec5a78 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -618,8 +618,7 @@ st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
     * explicitly uploaded in the draw_bitmap_quad() function.
     */
    if ((st->dirty | ctx->NewDriverState) & st->active_states &
-       ~ST_NEW_CONSTANTS & ST_PIPELINE_RENDER_STATE_MASK ||
-       st->gfx_shaders_may_be_dirty) {
+       ~ST_NEW_CONSTANTS & ST_PIPELINE_RENDER_STATE_MASK) {
       st_validate_state(st, ST_PIPELINE_META);
    }
 
diff --git a/src/mesa/state_tracker/st_cb_feedback.c b/src/mesa/state_tracker/st_cb_feedback.c
index e5ae1296266e..ec62a0a077be 100644
--- a/src/mesa/state_tracker/st_cb_feedback.c
+++ b/src/mesa/state_tracker/st_cb_feedback.c
@@ -313,7 +313,7 @@ st_RenderMode(struct gl_context *ctx, GLenum newMode )
       ctx->Driver.DrawGalliumMultiMode = st_feedback_draw_vbo_multi_mode;
       /* need to generate/use a vertex program that emits pos/color/tex */
       if (vp)
-         st->dirty |= ST_NEW_VERTEX_PROGRAM(st, vp);
+         st->dirty |= ST_NEW_VERTEX_PROGRAM(ctx, vp);
    }
 
    /* Restore geometry shader states when leaving GL_SELECT mode. */
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 71fffcc4bffd..41aa4e880bb9 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -185,8 +185,6 @@ st_invalidate_state(struct gl_context *ctx)
 
    /* Which shaders are dirty will be determined manually. */
    if (new_state & _NEW_PROGRAM) {
-      st->gfx_shaders_may_be_dirty = true;
-      st->compute_shader_may_be_dirty = true;
       /* This will mask out unused shader resources. */
       st->active_states = st_get_active_states(ctx);
    }
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 7ff3baa0e6da..a3e0f980cadf 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -247,12 +247,6 @@ struct st_context
    /** This masks out unused shader resources. Only valid in draw calls. */
    uint64_t active_states;
 
-   /* If true, further analysis of states is required to know if something
-    * has changed. Used mainly for shaders.
-    */
-   bool gfx_shaders_may_be_dirty;
-   bool compute_shader_may_be_dirty;
-
    GLboolean vertdata_edgeflags;
    GLboolean edgeflag_culls_prims;
 
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 18c27c7f4595..4bff75bbdf55 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -86,8 +86,7 @@ prepare_draw(struct st_context *st, struct gl_context *ctx, uint64_t state_mask,
    st_invalidate_readpix_cache(st);
 
    /* Validate state. */
-   if ((st->dirty | ctx->NewDriverState) & st->active_states & state_mask ||
-       st->gfx_shaders_may_be_dirty) {
+   if ((st->dirty | ctx->NewDriverState) & st->active_states & state_mask) {
       st_validate_state(st, pipeline);
    }
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index ff784a448035..d041d60addd7 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -1314,7 +1314,7 @@ st_finalize_program(struct st_context *st, struct gl_program *prog)
    if (st->current_program[prog->info.stage] == prog) {
       if (prog->info.stage == MESA_SHADER_VERTEX) {
          st->ctx->Array.NewVertexElements = true;
-         st->dirty |= ST_NEW_VERTEX_PROGRAM(st, prog);
+         st->dirty |= ST_NEW_VERTEX_PROGRAM(st->ctx, prog);
       } else {
          st->dirty |= prog->affected_states;
       }
-- 
GitLab


From d183b8b7418be829548db37027ec44f3b75408f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 06:53:48 -0500
Subject: [PATCH 03/12] st/mesa: update st_context::active_states in
 _mesa_update_state

just a code movement to a better place
---
 src/mesa/main/state.c               | 38 ++++++++++++++++++++++++-----
 src/mesa/state_tracker/st_context.c | 35 --------------------------
 2 files changed, 32 insertions(+), 41 deletions(-)

diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 6f6245859aad..bf1a02013c32 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -150,6 +150,33 @@ _mesa_update_allow_draw_out_of_order(struct gl_context *ctx)
       FLUSH_VERTICES(ctx, 0, 0);
 }
 
+static uint64_t
+st_get_active_states(struct gl_context *ctx)
+{
+   struct gl_program *vp = ctx->VertexProgram._Current;
+   struct gl_program *tcp = ctx->TessCtrlProgram._Current;
+   struct gl_program *tep = ctx->TessEvalProgram._Current;
+   struct gl_program *gp = ctx->GeometryProgram._Current;
+   struct gl_program *fp = ctx->FragmentProgram._Current;
+   struct gl_program *cp = ctx->ComputeProgram._Current;
+   uint64_t active_shader_states = 0;
+
+   if (vp)
+      active_shader_states |= vp->affected_states;
+   if (tcp)
+      active_shader_states |= tcp->affected_states;
+   if (tep)
+      active_shader_states |= tep->affected_states;
+   if (gp)
+      active_shader_states |= gp->affected_states;
+   if (fp)
+      active_shader_states |= fp->affected_states;
+   if (cp)
+      active_shader_states |= cp->affected_states;
+
+   /* Mark non-shader-resource shader states as "always active". */
+   return active_shader_states | ~ST_ALL_SHADER_RESOURCES;
+}
 
 /**
  * Update the ctx->*Program._Current pointers to point to the
@@ -397,13 +424,12 @@ update_program(struct gl_context *ctx)
 
    /* Let the driver know what's happening:
     */
-   if (ctx->FragmentProgram._Current != prevFP ||
-       ctx->VertexProgram._Current != prevVP ||
-       ctx->GeometryProgram._Current != prevGP ||
-       ctx->TessEvalProgram._Current != prevTEP ||
-       ctx->TessCtrlProgram._Current != prevTCP ||
-       ctx->ComputeProgram._Current != prevCP)
+   if (vp_changed || tcp_changed || tep_changed || gp_changed ||
+       fp_changed || cp_changed) {
+      /* This will mask out unused shader resources. */
+      st->active_states = st_get_active_states(ctx);
       return _NEW_PROGRAM;
+   }
 
    return 0;
 }
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 41aa4e880bb9..e6df83ccf555 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -71,35 +71,6 @@
 
 DEBUG_GET_ONCE_BOOL_OPTION(mesa_mvp_dp4, "MESA_MVP_DP4", FALSE)
 
-static uint64_t
-st_get_active_states(struct gl_context *ctx)
-{
-   struct gl_program *vp = ctx->VertexProgram._Current;
-   struct gl_program *tcp = ctx->TessCtrlProgram._Current;
-   struct gl_program *tep = ctx->TessEvalProgram._Current;
-   struct gl_program *gp = ctx->GeometryProgram._Current;
-   struct gl_program *fp = ctx->FragmentProgram._Current;
-   struct gl_program *cp = ctx->ComputeProgram._Current;
-   uint64_t active_shader_states = 0;
-
-   if (vp)
-      active_shader_states |= vp->affected_states;
-   if (tcp)
-      active_shader_states |= tcp->affected_states;
-   if (tep)
-      active_shader_states |= tep->affected_states;
-   if (gp)
-      active_shader_states |= gp->affected_states;
-   if (fp)
-      active_shader_states |= fp->affected_states;
-   if (cp)
-      active_shader_states |= cp->affected_states;
-
-   /* Mark non-shader-resource shader states as "always active". */
-   return active_shader_states | ~ST_ALL_SHADER_RESOURCES;
-}
-
-
 void
 st_invalidate_buffers(struct st_context *st)
 {
@@ -183,12 +154,6 @@ st_invalidate_state(struct gl_context *ctx)
          st->dirty |= ST_NEW_VS_STATE | ST_NEW_VS_CONSTANTS;
    }
 
-   /* Which shaders are dirty will be determined manually. */
-   if (new_state & _NEW_PROGRAM) {
-      /* This will mask out unused shader resources. */
-      st->active_states = st_get_active_states(ctx);
-   }
-
    if (new_state & _NEW_TEXTURE_OBJECT) {
       st->dirty |= st->active_states &
                    (ST_NEW_SAMPLER_VIEWS |
-- 
GitLab


From cf11318d119d56b421a86a7bc9198b43f152c807 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:07:46 -0500
Subject: [PATCH 04/12] mesa: flag ST_NEW_FS_CONSTANTS instead of _NEW_PROGRAM
 for ATI_fs constants

We only need to update the constant buffer.
---
 src/mesa/main/atifragshader.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/mesa/main/atifragshader.c b/src/mesa/main/atifragshader.c
index f8fd16a35044..6baa6a4a5565 100644
--- a/src/mesa/main/atifragshader.c
+++ b/src/mesa/main/atifragshader.c
@@ -827,7 +827,8 @@ _mesa_SetFragmentShaderConstantATI(GLuint dst, const GLfloat * value)
       curProg->LocalConstDef |= 1 << dstindex;
    }
    else {
-      FLUSH_VERTICES(ctx, _NEW_PROGRAM, 0);
+      FLUSH_VERTICES(ctx, 0, 0);
+      ctx->NewDriverState |= ST_NEW_FS_CONSTANTS;
       COPY_4V(ctx->ATIFragmentShader.GlobalConstants[dstindex], value);
    }
 }
-- 
GitLab


From f1ee78267ed2df07515cf81929a6d78e4d8fbb35 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:20:20 -0500
Subject: [PATCH 05/12] mesa: set fewer dirty flags for PointSizeEnabled state
 changes

---
 src/mesa/main/enable.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index 5aab14268bf2..ed8016bcf8c5 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -128,7 +128,9 @@ client_state(struct gl_context *ctx, struct gl_vertex_array_object* vao,
 
       case GL_POINT_SIZE_ARRAY_OES:
          if (ctx->VertexProgram.PointSizeEnabled != state) {
-            FLUSH_VERTICES(ctx, _NEW_PROGRAM, 0);
+            FLUSH_VERTICES(ctx, ctx->st->lower_point_size ? _NEW_PROGRAM : 0,
+                           0);
+            ctx->NewDriverState |= ST_NEW_RASTERIZER;
             ctx->VertexProgram.PointSizeEnabled = state;
          }
          vao_state(ctx, vao, VERT_ATTRIB_POINT_SIZE, state);
@@ -1091,7 +1093,9 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             goto invalid_enum_error;
          if (ctx->VertexProgram.PointSizeEnabled == state)
             return;
-         FLUSH_VERTICES(ctx, _NEW_PROGRAM, GL_ENABLE_BIT);
+         FLUSH_VERTICES(ctx, ctx->st->lower_point_size ? _NEW_PROGRAM : 0,
+                        GL_ENABLE_BIT);
+         ctx->NewDriverState |= ST_NEW_RASTERIZER;
          ctx->VertexProgram.PointSizeEnabled = state;
          break;
       case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
-- 
GitLab


From dfcce95b31d1645105b9b8f06712af105114f0ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:31:03 -0500
Subject: [PATCH 06/12] mesa: set fewer flags for VertexProgram.TwoSideEnabled
 changes

---
 src/mesa/main/enable.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index ed8016bcf8c5..5696aa16a6ed 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -1103,7 +1103,14 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             goto invalid_enum_error;
          if (ctx->VertexProgram.TwoSideEnabled == state)
             return;
-         FLUSH_VERTICES(ctx, _NEW_PROGRAM, GL_ENABLE_BIT);
+         FLUSH_VERTICES(ctx, 0, GL_ENABLE_BIT);
+         if (ctx->st->lower_two_sided_color) {
+            /* TODO: this could be smaller, but most drivers don't get here */
+            ctx->NewDriverState |= ST_NEW_VS_STATE |
+                                   ST_NEW_TES_STATE |
+                                   ST_NEW_GS_STATE;
+         }
+         ctx->NewDriverState |= ST_NEW_RASTERIZER;
          ctx->VertexProgram.TwoSideEnabled = state;
          break;
 
-- 
GitLab


From 353f463713f35aa9de51da8407c8d6deccfa62cf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:35:00 -0500
Subject: [PATCH 07/12] mesa: don't flag _NEW_PROGRAM for "texture_unit ->
 sampler" mapping changes

st/mesa just reorders sampler views, so we only need to rebind those.
---
 src/mesa/main/uniform_query.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index 6135c80586ac..70bf6816fca4 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -1551,7 +1551,7 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
                 */
                if (sampler->unit != value || !sampler->bound) {
                   if (!flushed) {
-                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT | _NEW_PROGRAM, 0);
+                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT, 0);
                      flushed = true;
                   }
                   sampler->unit = value;
@@ -1562,7 +1562,7 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
             } else {
                if (sh->Program->SamplerUnits[unit] != value) {
                   if (!flushed) {
-                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT | _NEW_PROGRAM, 0);
+                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT, 0);
                      flushed = true;
                   }
                   sh->Program->SamplerUnits[unit] = value;
-- 
GitLab


From af7bb46190f5025a290ae69e23277f65bfdc151f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:38:40 -0500
Subject: [PATCH 08/12] mesa: remove unused composite _NEW_* flags

---
 src/mesa/main/mtypes.h | 31 -------------------------------
 1 file changed, 31 deletions(-)

diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 80033bd0fa68..8d2f978de709 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -2852,37 +2852,6 @@ struct gl_matrix_stack
 /*@}*/
 
 
-/**
- * Composite state flags, deprecated and inefficient, do not use.
- */
-/*@{*/
-#define _NEW_LIGHT     (_NEW_LIGHT_CONSTANTS |  /* state parameters */ \
-                        _NEW_LIGHT_STATE |      /* rasterizer state */ \
-                        _NEW_MATERIAL |         /* light materials */ \
-                        _NEW_FF_VERT_PROGRAM | \
-                        _NEW_FF_FRAG_PROGRAM)
-
-#define _NEW_TEXTURE   (_NEW_TEXTURE_OBJECT | _NEW_TEXTURE_STATE | \
-                        _NEW_FF_VERT_PROGRAM | _NEW_FF_FRAG_PROGRAM)
-
-#define _MESA_NEW_NEED_EYE_COORDS         (_NEW_FF_VERT_PROGRAM | \
-                                           _NEW_FF_FRAG_PROGRAM | \
-                                           _NEW_LIGHT_CONSTANTS | \
-                                           _NEW_TEXTURE_STATE |	\
-                                           _NEW_POINT |		\
-                                           _NEW_PROGRAM |	\
-                                           _NEW_MODELVIEW)
-
-#define _MESA_NEW_SEPARATE_SPECULAR        (_NEW_LIGHT | \
-                                            _NEW_FOG | \
-                                            _NEW_PROGRAM)
-
-
-/*@}*/
-
-
-
-
 /* This has to be included here. */
 #include "dd.h"
 
-- 
GitLab


From 73ddb1aa1362204b538b41b6ca55ebd7a6155bfe Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:49:33 -0500
Subject: [PATCH 09/12] mesa: flag ST_NEW_RASTERIZER for
 needs_texcoord_semantic if changing FS

This will be required with the next change, which will remove
the rasterizer state dependency on _NEW_PROGRAM.
---
 src/mesa/main/state.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index bf1a02013c32..3c7ba6422ff8 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -367,6 +367,9 @@ update_program(struct gl_context *ctx)
          dirty |= prevFP->affected_states;
       if (ctx->FragmentProgram._Current)
          dirty |= ctx->FragmentProgram._Current->affected_states;
+
+      if (!ctx->st->needs_texcoord_semantic)
+         dirty |= ST_NEW_RASTERIZER;
    }
 
    if (cp_changed) {
-- 
GitLab


From d4e425c1a90bdb3b9825075aac6659a5cef6b9d9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:52:11 -0500
Subject: [PATCH 10/12] st/mesa: don't flag ST_NEW_RASTERIZER for _NEW_PROGRAM

This should have no effect thanks to previous commits.
---
 src/mesa/state_tracker/st_context.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index e6df83ccf555..9869758625d4 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -108,9 +108,6 @@ st_invalidate_state(struct gl_context *ctx)
       /* These set a subset of flags set by _NEW_BUFFERS, so we only have to
        * check them when _NEW_BUFFERS isn't set.
        */
-      if (new_state & _NEW_PROGRAM)
-         st->dirty |= ST_NEW_RASTERIZER;
-
       if (new_state & _NEW_FOG)
          st->dirty |= ST_NEW_FS_STATE;
    }
-- 
GitLab


From d3a24137e774242e6ddcc5041f90a4a7673596fe Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 10:20:17 -0500
Subject: [PATCH 11/12] st/mesa: fix the glBitmap cache wrt FS, scissor, and
 clamp color changes

We need to track those states in the cache and flush the cache
if the next glBitmap call uses different states.
---
 src/mesa/main/enable.c                |  4 ---
 src/mesa/main/scissor.c               |  3 --
 src/mesa/state_tracker/st_cb_bitmap.c | 42 ++++++++++++++++++++-------
 src/mesa/state_tracker/st_context.h   |  4 +++
 4 files changed, 35 insertions(+), 18 deletions(-)

diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index 5696aa16a6ed..22ca9a30f220 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -868,8 +868,6 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             GLbitfield newEnabled =
                state * ((1 << ctx->Const.MaxViewports) - 1);
             if (newEnabled != ctx->Scissor.EnableFlags) {
-               st_flush_bitmap_cache(st_context(ctx));
-
                FLUSH_VERTICES(ctx, 0,
                               GL_SCISSOR_BIT | GL_ENABLE_BIT);
                ctx->NewDriverState |= ST_NEW_SCISSOR | ST_NEW_RASTERIZER;
@@ -1404,8 +1402,6 @@ _mesa_set_enablei(struct gl_context *ctx, GLenum cap,
          return;
       }
       if (((ctx->Scissor.EnableFlags >> index) & 1) != state) {
-         st_flush_bitmap_cache(st_context(ctx));
-
          FLUSH_VERTICES(ctx, 0,
                         GL_SCISSOR_BIT | GL_ENABLE_BIT);
          ctx->NewDriverState |= ST_NEW_SCISSOR | ST_NEW_RASTERIZER;
diff --git a/src/mesa/main/scissor.c b/src/mesa/main/scissor.c
index c4bff669c6cd..a3bf2ae15ce1 100644
--- a/src/mesa/main/scissor.c
+++ b/src/mesa/main/scissor.c
@@ -51,9 +51,6 @@ set_scissor_no_notify(struct gl_context *ctx, unsigned idx,
        height == ctx->Scissor.ScissorArray[idx].Height)
       return;
 
-   if (ctx->Scissor.EnableFlags)
-      st_flush_bitmap_cache(st_context(ctx));
-
    FLUSH_VERTICES(ctx, 0, GL_SCISSOR_BIT);
    ctx->NewDriverState |= ST_NEW_SCISSOR;
 
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index 7b2433ec5a78..86cd6cc728a0 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -170,7 +170,8 @@ st_make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
 static void
 setup_render_state(struct gl_context *ctx,
                    struct pipe_sampler_view *sv,
-                   const GLfloat *color)
+                   const GLfloat *color, struct gl_program *fp,
+                   bool scissor_enabled, bool clamp_frag_color)
 {
    struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st->pipe;
@@ -182,10 +183,10 @@ setup_render_state(struct gl_context *ctx,
    key.st = st->has_shareable_shaders ? NULL : st;
    key.bitmap = GL_TRUE;
    key.clamp_color = st->clamp_frag_color_in_shader &&
-                     ctx->Color._ClampFragmentColor;
+                     clamp_frag_color;
    key.lower_alpha_func = COMPARE_FUNC_ALWAYS;
 
-   fpv = st_get_fp_variant(st, st->fp, &key);
+   fpv = st_get_fp_variant(st, fp, &key);
 
    /* As an optimization, Mesa's fragment programs will sometimes get the
     * primary color from a statevar/constant rather than a varying variable.
@@ -198,7 +199,7 @@ setup_render_state(struct gl_context *ctx,
       GLfloat colorSave[4];
       COPY_4V(colorSave, ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
       COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], color);
-      st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, fp, MESA_SHADER_FRAGMENT);
       COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], colorSave);
    }
 
@@ -211,7 +212,7 @@ setup_render_state(struct gl_context *ctx,
 
 
    /* rasterizer state: just scissor */
-   st->bitmap.rasterizer.scissor = ctx->Scissor.EnableFlags & 1;
+   st->bitmap.rasterizer.scissor = scissor_enabled;
    cso_set_rasterizer(cso, &st->bitmap.rasterizer);
 
    /* fragment shader state: TEX lookup program */
@@ -243,8 +244,7 @@ setup_render_state(struct gl_context *ctx,
    {
       struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
       unsigned num_views =
-         st_get_sampler_views(st, PIPE_SHADER_FRAGMENT,
-                              ctx->FragmentProgram._Current, sampler_views);
+         st_get_sampler_views(st, PIPE_SHADER_FRAGMENT, fp, sampler_views);
 
       num_views = MAX2(fpv->bitmap_sampler + 1, num_views);
       sampler_views[fpv->bitmap_sampler] = sv;
@@ -294,7 +294,9 @@ restore_render_state(struct gl_context *ctx)
 static void
 draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
                  GLsizei width, GLsizei height,
-                 struct pipe_sampler_view *sv, const GLfloat *color)
+                 struct pipe_sampler_view *sv, const GLfloat *color,
+                 struct gl_program *fp, bool scissor_enabled,
+                 bool clamp_frag_color)
 {
    struct st_context *st = st_context(ctx);
    const float fb_width = (float) st->state.fb_width;
@@ -327,7 +329,7 @@ draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
       tBot = (float) height;
    }
 
-   setup_render_state(ctx, sv, color);
+   setup_render_state(ctx, sv, color, fp, scissor_enabled, clamp_frag_color);
 
    /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
    z = z * 2.0f - 1.0f;
@@ -357,6 +359,8 @@ reset_cache(struct st_context *st)
    cache->ymin = 1000000;
    cache->ymax = -1000000;
 
+   _mesa_reference_program(st->ctx, &cache->fp, NULL);
+
    assert(!cache->texture);
 
    /* allocate a new texture */
@@ -453,7 +457,10 @@ st_flush_bitmap_cache(struct st_context *st)
                           cache->zpos,
                           BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                           sv,
-                          cache->color);
+                          cache->color,
+                          cache->fp,
+                          cache->scissor_enabled,
+                          cache->clamp_frag_color);
       }
 
       /* release/free the texture */
@@ -483,12 +490,18 @@ accum_bitmap(struct gl_context *ctx,
        height > BITMAP_CACHE_HEIGHT)
       return GL_FALSE; /* too big to cache */
 
+   bool scissor_enabled = ctx->Scissor.EnableFlags & 0x1;
+   bool clamp_frag_color = ctx->Color._ClampFragmentColor;
+
    if (!cache->empty) {
       px = x - cache->xpos;  /* pos in buffer */
       py = y - cache->ypos;
       if (px < 0 || px + width > BITMAP_CACHE_WIDTH ||
           py < 0 || py + height > BITMAP_CACHE_HEIGHT ||
           !TEST_EQ_4V(ctx->Current.RasterColor, cache->color) ||
+          ctx->FragmentProgram._Current != cache->fp ||
+          scissor_enabled != cache->scissor_enabled ||
+          clamp_frag_color != cache->clamp_frag_color ||
           ((fabsf(z - cache->zpos) > Z_EPSILON))) {
          /* This bitmap would extend beyond cache bounds, or the bitmap
           * color is changing
@@ -507,6 +520,9 @@ accum_bitmap(struct gl_context *ctx,
       cache->zpos = z;
       cache->empty = GL_FALSE;
       COPY_4FV(cache->color, ctx->Current.RasterColor);
+      _mesa_reference_program(ctx, &cache->fp, ctx->FragmentProgram._Current);
+      cache->scissor_enabled = scissor_enabled;
+      cache->clamp_frag_color = clamp_frag_color;
    }
 
    assert(px != -999);
@@ -645,7 +661,10 @@ st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
 
    if (view) {
       draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
-                       width, height, view, ctx->Current.RasterColor);
+                       width, height, view, ctx->Current.RasterColor,
+                       ctx->FragmentProgram._Current,
+                       ctx->Scissor.EnableFlags & 0x1,
+                       ctx->Color._ClampFragmentColor);
    }
 }
 
@@ -660,4 +679,5 @@ st_destroy_bitmap(struct st_context *st)
       pipe_texture_unmap(pipe, cache->trans);
    }
    pipe_resource_reference(&st->bitmap.cache.texture, NULL);
+   _mesa_reference_program(st->ctx, &st->bitmap.cache.fp, NULL);
 }
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index a3e0f980cadf..17dfb1f46d7f 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -62,6 +62,10 @@ struct st_bitmap_cache
    /** Bounds of region used in window coords */
    GLint xmin, ymin, xmax, ymax;
 
+   /** GL states */
+   struct gl_program *fp;
+   bool scissor_enabled;
+   bool clamp_frag_color;
    GLfloat color[4];
 
    /** Bitmap's Z position */
-- 
GitLab


From 3ebbaa0712061c28219b6c5111a540f510d1a9fc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 08:08:30 -0500
Subject: [PATCH 12/12] st/mesa: remove redundant
 st_context::vp,tcp,tep,gp,fp,cp

Use ctx->XXProgram._Current instead of the st_context variables.

Also, the st_release_program calls were redundant. The same code is
invoked when mesa/main unreferences shaders.
---
 src/mesa/state_tracker/st_atom_array.cpp   |  3 ++-
 src/mesa/state_tracker/st_atom_constbuf.c  | 22 ++++++++++------
 src/mesa/state_tracker/st_atom_msaa.c      |  7 +++--
 src/mesa/state_tracker/st_atom_shader.c    | 17 ++++--------
 src/mesa/state_tracker/st_cb_drawpixels.c  |  8 +++---
 src/mesa/state_tracker/st_cb_feedback.c    |  3 ++-
 src/mesa/state_tracker/st_cb_rasterpos.c   |  3 ++-
 src/mesa/state_tracker/st_context.c        |  7 -----
 src/mesa/state_tracker/st_context.h        | 12 ---------
 src/mesa/state_tracker/st_draw_feedback.c  |  8 +++---
 src/mesa/state_tracker/st_draw_hw_select.c |  6 +++--
 src/mesa/state_tracker/st_program.c        | 30 ++++++++++++----------
 src/mesa/state_tracker/st_program.h        |  3 ---
 13 files changed, 56 insertions(+), 73 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 4ed0d488068c..ab00e4a3fc95 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -303,7 +303,8 @@ st_update_array_templ(struct st_context *st)
 
    /* vertex program validation must be done before this */
    /* _NEW_PROGRAM, ST_NEW_VS_STATE */
-   const struct gl_vertex_program *vp = (struct gl_vertex_program *)st->vp;
+   const struct gl_vertex_program *vp =
+      (struct gl_vertex_program *)ctx->VertexProgram._Current;
    const struct st_common_variant *vp_variant = st->vp_variant;
 
    struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 9f337d4f9570..50937acbebae 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -85,8 +85,8 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
           shader_type == PIPE_SHADER_COMPUTE);
 
    /* update the ATI constants before rendering */
-   if (shader_type == PIPE_SHADER_FRAGMENT && st->fp->ati_fs) {
-      struct ati_fragment_shader *ati_fs = st->fp->ati_fs;
+   if (shader_type == PIPE_SHADER_FRAGMENT && prog->ati_fs) {
+      struct ati_fragment_shader *ati_fs = prog->ati_fs;
       unsigned c;
 
       for (c = 0; c < MAX_NUM_FRAGMENT_CONSTANTS_ATI; c++) {
@@ -213,7 +213,8 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
 void
 st_update_vs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->vp, MESA_SHADER_VERTEX);
+   st_upload_constants(st, st->ctx->VertexProgram._Current,
+                       MESA_SHADER_VERTEX);
 }
 
 /**
@@ -222,7 +223,8 @@ st_update_vs_constants(struct st_context *st)
 void
 st_update_fs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+   st_upload_constants(st, st->ctx->FragmentProgram._Current,
+                       MESA_SHADER_FRAGMENT);
 }
 
 
@@ -231,7 +233,8 @@ st_update_fs_constants(struct st_context *st)
 void
 st_update_gs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->gp, MESA_SHADER_GEOMETRY);
+   st_upload_constants(st, st->ctx->GeometryProgram._Current,
+                       MESA_SHADER_GEOMETRY);
 }
 
 /* Tessellation control shader:
@@ -239,7 +242,8 @@ st_update_gs_constants(struct st_context *st)
 void
 st_update_tcs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->tcp, MESA_SHADER_TESS_CTRL);
+   st_upload_constants(st, st->ctx->TessCtrlProgram._Current,
+                       MESA_SHADER_TESS_CTRL);
 }
 
 /* Tessellation evaluation shader:
@@ -247,7 +251,8 @@ st_update_tcs_constants(struct st_context *st)
 void
 st_update_tes_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->tep, MESA_SHADER_TESS_EVAL);
+   st_upload_constants(st, st->ctx->TessEvalProgram._Current,
+                       MESA_SHADER_TESS_EVAL);
 }
 
 /* Compute shader:
@@ -255,7 +260,8 @@ st_update_tes_constants(struct st_context *st)
 void
 st_update_cs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->cp, MESA_SHADER_COMPUTE);
+   st_upload_constants(st, st->ctx->ComputeProgram._Current,
+                       MESA_SHADER_COMPUTE);
 }
 
 static void
diff --git a/src/mesa/state_tracker/st_atom_msaa.c b/src/mesa/state_tracker/st_atom_msaa.c
index 8ee71cdcc980..9e16ebda383d 100644
--- a/src/mesa/state_tracker/st_atom_msaa.c
+++ b/src/mesa/state_tracker/st_atom_msaa.c
@@ -144,12 +144,11 @@ st_update_sample_state(struct st_context *st)
 void
 st_update_sample_shading(struct st_context *st)
 {
-   if (!st->fp)
-      return;
+   struct gl_program *fp = st->ctx->FragmentProgram._Current;
 
-   if (!st->ctx->Extensions.ARB_sample_shading)
+   if (!fp || !st->ctx->Extensions.ARB_sample_shading)
       return;
 
    cso_set_min_samples(st->cso_context,
-                       _mesa_get_min_invocations_per_fragment(st->ctx, st->fp));
+                       _mesa_get_min_invocations_per_fragment(st->ctx, fp));
 }
diff --git a/src/mesa/state_tracker/st_atom_shader.c b/src/mesa/state_tracker/st_atom_shader.c
index 96f4e1c04a6d..cac6a4d387f7 100644
--- a/src/mesa/state_tracker/st_atom_shader.c
+++ b/src/mesa/state_tracker/st_atom_shader.c
@@ -172,8 +172,6 @@ st_update_fp( struct st_context *st )
       simple_mtx_unlock(&st->ctx->Shared->Mutex);
    }
 
-   _mesa_reference_program(st->ctx, &st->fp, fp);
-
    cso_set_fragment_shader_handle(st->cso_context, shader);
 }
 
@@ -237,8 +235,6 @@ st_update_vp( struct st_context *st )
       simple_mtx_unlock(&st->ctx->Shared->Mutex);
    }
 
-   _mesa_reference_program(st->ctx, &st->vp, vp);
-
    cso_set_vertex_shader_handle(st->cso_context,
                                 st->vp_variant->base.driver_shader);
 }
@@ -246,15 +242,12 @@ st_update_vp( struct st_context *st )
 
 static void *
 st_update_common_program(struct st_context *st, struct gl_program *prog,
-                         unsigned pipe_shader, struct gl_program **dst)
+                         unsigned pipe_shader)
 {
    if (!prog) {
-      _mesa_reference_program(st->ctx, dst, NULL);
       return NULL;
    }
 
-   _mesa_reference_program(st->ctx, dst, prog);
-
    if (st->shader_has_one_variant[prog->info.stage])
       return prog->variants->driver_shader;
 
@@ -299,7 +292,7 @@ st_update_gp(struct st_context *st)
 {
    void *shader = st_update_common_program(st,
                                            st->ctx->GeometryProgram._Current,
-                                           PIPE_SHADER_GEOMETRY, &st->gp);
+                                           PIPE_SHADER_GEOMETRY);
    cso_set_geometry_shader_handle(st->cso_context, shader);
 }
 
@@ -309,7 +302,7 @@ st_update_tcp(struct st_context *st)
 {
    void *shader = st_update_common_program(st,
                                            st->ctx->TessCtrlProgram._Current,
-                                           PIPE_SHADER_TESS_CTRL, &st->tcp);
+                                           PIPE_SHADER_TESS_CTRL);
    cso_set_tessctrl_shader_handle(st->cso_context, shader);
 }
 
@@ -319,7 +312,7 @@ st_update_tep(struct st_context *st)
 {
    void *shader = st_update_common_program(st,
                                            st->ctx->TessEvalProgram._Current,
-                                           PIPE_SHADER_TESS_EVAL, &st->tep);
+                                           PIPE_SHADER_TESS_EVAL);
    cso_set_tesseval_shader_handle(st->cso_context, shader);
 }
 
@@ -329,6 +322,6 @@ st_update_cp(struct st_context *st)
 {
    void *shader = st_update_common_program(st,
                                            st->ctx->ComputeProgram._Current,
-                                           PIPE_SHADER_COMPUTE, &st->cp);
+                                           PIPE_SHADER_COMPUTE);
    cso_set_compute_shader_handle(st->cso_context, shader);
 }
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 7b21f2ccbbb0..e54930c823d3 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -1149,7 +1149,7 @@ get_color_fp_variant(struct st_context *st)
                      ctx->Color._ClampFragmentColor;
    key.lower_alpha_func = COMPARE_FUNC_ALWAYS;
 
-   fpv = st_get_fp_variant(st, st->fp, &key);
+   fpv = st_get_fp_variant(st, ctx->FragmentProgram._Current, &key);
 
    return fpv;
 }
@@ -1179,7 +1179,7 @@ get_color_index_fp_variant(struct st_context *st)
                      ctx->Color._ClampFragmentColor;
    key.lower_alpha_func = COMPARE_FUNC_ALWAYS;
 
-   fpv = st_get_fp_variant(st, st->fp, &key);
+   fpv = st_get_fp_variant(st, ctx->FragmentProgram._Current, &key);
 
    return fpv;
 }
@@ -1353,7 +1353,7 @@ st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
       /* compiling a new fragment shader variant added new state constants
        * into the constant buffer, we need to update them
        */
-      st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT);
    }
 
    {
@@ -1738,7 +1738,7 @@ st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
       /* compiling a new fragment shader variant added new state constants
        * into the constant buffer, we need to update them
        */
-      st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT);
    } else if (type == GL_DEPTH) {
       rbRead = ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
       driver_fp = get_drawpix_z_stencil_program(st, GL_TRUE, GL_FALSE);
diff --git a/src/mesa/state_tracker/st_cb_feedback.c b/src/mesa/state_tracker/st_cb_feedback.c
index ec62a0a077be..607753e4c58f 100644
--- a/src/mesa/state_tracker/st_cb_feedback.c
+++ b/src/mesa/state_tracker/st_cb_feedback.c
@@ -87,7 +87,8 @@ feedback_vertex(struct gl_context *ctx, const struct draw_context *draw,
                 const struct vertex_header *v)
 {
    const struct st_context *st = st_context(ctx);
-   struct gl_vertex_program *stvp = (struct gl_vertex_program *)st->vp;
+   struct gl_vertex_program *stvp =
+      (struct gl_vertex_program *)ctx->VertexProgram._Current;
    GLfloat win[4];
    const GLfloat *color, *texcoord;
    ubyte slot;
diff --git a/src/mesa/state_tracker/st_cb_rasterpos.c b/src/mesa/state_tracker/st_cb_rasterpos.c
index 044b60d7cbb0..1c958a818be2 100644
--- a/src/mesa/state_tracker/st_cb_rasterpos.c
+++ b/src/mesa/state_tracker/st_cb_rasterpos.c
@@ -143,7 +143,8 @@ rastpos_point(struct draw_stage *stage, struct prim_header *prim)
    struct gl_context *ctx = rs->ctx;
    struct st_context *st = st_context(ctx);
    const GLfloat height = (GLfloat) ctx->DrawBuffer->Height;
-   struct gl_vertex_program *stvp = (struct gl_vertex_program *)st->vp;
+   struct gl_vertex_program *stvp =
+      (struct gl_vertex_program *)ctx->VertexProgram._Current;
    const ubyte *outputMapping = stvp->result_to_output;
    const GLfloat *pos;
    GLuint i;
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 9869758625d4..7c98dee09900 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -929,13 +929,6 @@ st_destroy_context(struct st_context *st)
    simple_mtx_destroy(&st->zombie_sampler_views.mutex);
    simple_mtx_destroy(&st->zombie_shaders.mutex);
 
-   st_release_program(st, &st->fp);
-   st_release_program(st, &st->gp);
-   st_release_program(st, &st->vp);
-   st_release_program(st, &st->tcp);
-   st_release_program(st, &st->tep);
-   st_release_program(st, &st->cp);
-
    if (st->hw_select_shaders) {
       hash_table_foreach(st->hw_select_shaders, entry)
          st->pipe->delete_gs_state(st->pipe, entry->data);
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 17dfb1f46d7f..34389169c5a3 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -260,18 +260,6 @@ struct st_context
     */
    unsigned active_queries;
 
-   union {
-      struct {
-         struct gl_program *vp;    /**< Currently bound vertex program */
-         struct gl_program *tcp; /**< Currently bound tess control program */
-         struct gl_program *tep; /**< Currently bound tess eval program */
-         struct gl_program *gp;  /**< Currently bound geometry program */
-         struct gl_program *fp;  /**< Currently bound fragment program */
-         struct gl_program *cp;   /**< Currently bound compute program */
-      };
-      struct gl_program *current_program[MESA_SHADER_STAGES];
-   };
-
    struct st_common_variant *vp_variant;
 
    struct {
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index ebadabf9503c..af0202ed8b96 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -101,7 +101,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st->pipe;
    struct draw_context *draw = st_get_draw_context(st);
-   const struct gl_vertex_program *vp;
+   struct gl_vertex_program *vp;
    struct st_common_variant *vp_variant;
    struct pipe_vertex_buffer vbuffers[PIPE_MAX_SHADER_INPUTS];
    unsigned num_vbuffers = 0;
@@ -130,8 +130,8 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    memcpy(&key, &st->vp_variant->key, sizeof(key));
    key.is_draw_shader = true;
 
-   vp = (struct gl_vertex_program *)st->vp;
-   vp_variant = st_get_common_variant(st, st->vp, &key);
+   vp = (struct gl_vertex_program *)ctx->VertexProgram._Current;
+   vp_variant = st_get_common_variant(st, &vp->Base, &key);
 
    /*
     * Set up the draw module's state.
@@ -186,7 +186,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    }
 
    /* set constant buffer 0 */
-   struct gl_program_parameter_list *params = st->vp->Parameters;
+   struct gl_program_parameter_list *params = vp->Base.Parameters;
 
    /* Update the constants which come from fixed-function state, such as
     * transformation matrices, fog factors, etc.
diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index 38da7c5ca401..e802d2bbfb04 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -659,7 +659,9 @@ bool
 st_draw_hw_select_prepare_common(struct gl_context *ctx)
 {
    struct st_context *st = st_context(ctx);
-   if (st->gp || st->tcp || st->tep) {
+   if (ctx->GeometryProgram._Current ||
+       ctx->TessCtrlProgram._Current ||
+       ctx->TessEvalProgram._Current) {
       fprintf(stderr, "HW GL_SELECT does not support user geometry/tessellation shader\n");
       return false;
    }
@@ -736,7 +738,7 @@ make_state_key(struct gl_context *ctx, int mode)
    }
 
    /* TODO: support gl_ClipDistance/gl_CullDistance, but it costs more regs */
-   struct gl_program *vp = ctx->st->vp;
+   struct gl_program *vp = ctx->VertexProgram._Current;
    if (vp->info.clip_distance_array_size || vp->info.cull_distance_array_size) {
       fprintf(stderr, "HW GL_SELECT does not support gl_ClipDistance/gl_CullDistance\n");
       return (union state_key){0};
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index d041d60addd7..8f4b649bd191 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -337,19 +337,6 @@ st_release_variants(struct st_context *st, struct gl_program *p)
     */
 }
 
-/**
- * Free all basic program variants and unref program.
- */
-void
-st_release_program(struct st_context *st, struct gl_program **p)
-{
-   if (!*p)
-      return;
-
-   destroy_program_variants(st, *p);
-   _mesa_reference_program(st->ctx, p, NULL);
-}
-
 void
 st_finalize_nir_before_variants(struct nir_shader *nir)
 {
@@ -1311,7 +1298,22 @@ st_serialize_nir(struct gl_program *prog)
 void
 st_finalize_program(struct st_context *st, struct gl_program *prog)
 {
-   if (st->current_program[prog->info.stage] == prog) {
+   bool is_bound = false;
+
+   if (prog->info.stage == MESA_SHADER_VERTEX)
+      is_bound = prog == st->ctx->VertexProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_TESS_CTRL)
+      is_bound = prog == st->ctx->TessCtrlProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_TESS_EVAL)
+      is_bound = prog == st->ctx->TessEvalProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_GEOMETRY)
+      is_bound = prog == st->ctx->GeometryProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_FRAGMENT)
+      is_bound = prog == st->ctx->FragmentProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_COMPUTE)
+      is_bound = prog == st->ctx->ComputeProgram._Current;
+
+   if (is_bound) {
       if (prog->info.stage == MESA_SHADER_VERTEX) {
          st->ctx->Array.NewVertexElements = true;
          st->dirty |= ST_NEW_VERTEX_PROGRAM(st->ctx, prog);
diff --git a/src/mesa/state_tracker/st_program.h b/src/mesa/state_tracker/st_program.h
index 3265e02e019e..89d0b8c0e21a 100644
--- a/src/mesa/state_tracker/st_program.h
+++ b/src/mesa/state_tracker/st_program.h
@@ -301,9 +301,6 @@ st_get_common_variant(struct st_context *st,
 extern void
 st_release_variants(struct st_context *st, struct gl_program *p);
 
-extern void
-st_release_program(struct st_context *st, struct gl_program **p);
-
 extern void
 st_destroy_program_variants(struct st_context *st);
 
-- 
GitLab

