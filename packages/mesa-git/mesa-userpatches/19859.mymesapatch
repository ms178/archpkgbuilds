From ea4f94a7c9c57a1eb8ec607910eb2d18594401c4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 25 Nov 2022 13:08:48 -0500
Subject: [PATCH 01/13] mesa: clean up hairy code in state.c: update_program

No change in behavior.

Replace:

if (shader)
   bind(shader);
else
   bind(NULL);

With:

bind(shader);
---
 src/mesa/main/state.c | 53 ++++++++-----------------------------------
 1 file changed, 10 insertions(+), 43 deletions(-)

diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 6cbc3dee364b..13d62d0ca53c 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -207,23 +207,20 @@ update_program(struct gl_context *ctx)
       _mesa_reference_program(ctx, &ctx->FragmentProgram._Current, fsProg);
       _mesa_reference_program(ctx, &ctx->FragmentProgram._TexEnvProgram,
                               NULL);
-   }
-   else if (_mesa_arb_fragment_program_enabled(ctx)) {
+   } else if (_mesa_arb_fragment_program_enabled(ctx)) {
       /* Use user-defined fragment program */
       _mesa_reference_program(ctx, &ctx->FragmentProgram._Current,
                               ctx->FragmentProgram.Current);
       _mesa_reference_program(ctx, &ctx->FragmentProgram._TexEnvProgram,
 			      NULL);
-   }
-   else if (_mesa_ati_fragment_shader_enabled(ctx) &&
+   } else if (_mesa_ati_fragment_shader_enabled(ctx) &&
             ctx->ATIFragmentShader.Current->Program) {
        /* Use the enabled ATI fragment shader's associated program */
       _mesa_reference_program(ctx, &ctx->FragmentProgram._Current,
                               ctx->ATIFragmentShader.Current->Program);
       _mesa_reference_program(ctx, &ctx->FragmentProgram._TexEnvProgram,
                               NULL);
-   }
-   else {
+   } else {
       /* Use fragment program generated from fixed-function state */
       struct gl_shader_program *f = _mesa_get_fixed_func_fragment_program(ctx);
 
@@ -233,32 +230,6 @@ update_program(struct gl_context *ctx)
 			      f->_LinkedShaders[MESA_SHADER_FRAGMENT]->Program);
    }
 
-   if (gsProg) {
-      /* Use GLSL geometry shader */
-      _mesa_reference_program(ctx, &ctx->GeometryProgram._Current, gsProg);
-   } else {
-      /* No geometry program */
-      _mesa_reference_program(ctx, &ctx->GeometryProgram._Current, NULL);
-   }
-
-   if (tesProg) {
-      /* Use GLSL tessellation evaluation shader */
-      _mesa_reference_program(ctx, &ctx->TessEvalProgram._Current, tesProg);
-   }
-   else {
-      /* No tessellation evaluation program */
-      _mesa_reference_program(ctx, &ctx->TessEvalProgram._Current, NULL);
-   }
-
-   if (tcsProg) {
-      /* Use GLSL tessellation control shader */
-      _mesa_reference_program(ctx, &ctx->TessCtrlProgram._Current, tcsProg);
-   }
-   else {
-      /* No tessellation control program */
-      _mesa_reference_program(ctx, &ctx->TessCtrlProgram._Current, NULL);
-   }
-
    /* Examine vertex program after fragment program as
     * _mesa_get_fixed_func_vertex_program() needs to know active
     * fragprog inputs.
@@ -267,14 +238,12 @@ update_program(struct gl_context *ctx)
       /* Use GLSL vertex shader */
       assert(VP_MODE_SHADER == ctx->VertexProgram._VPMode);
       _mesa_reference_program(ctx, &ctx->VertexProgram._Current, vsProg);
-   }
-   else if (_mesa_arb_vertex_program_enabled(ctx)) {
+   } else if (_mesa_arb_vertex_program_enabled(ctx)) {
       /* Use user-defined vertex program */
       assert(VP_MODE_SHADER == ctx->VertexProgram._VPMode);
       _mesa_reference_program(ctx, &ctx->VertexProgram._Current,
                               ctx->VertexProgram.Current);
-   }
-   else {
+   } else {
       /* Use vertex program generated from fixed-function state */
       assert(VP_MODE_FF == ctx->VertexProgram._VPMode);
       _mesa_reference_program(ctx, &ctx->VertexProgram._Current,
@@ -283,13 +252,11 @@ update_program(struct gl_context *ctx)
                               ctx->VertexProgram._Current);
    }
 
-   if (csProg) {
-      /* Use GLSL compute shader */
-      _mesa_reference_program(ctx, &ctx->ComputeProgram._Current, csProg);
-   } else {
-      /* no compute program */
-      _mesa_reference_program(ctx, &ctx->ComputeProgram._Current, NULL);
-   }
+   /* Bind or unbind these shaders. (NULL = unbind) */
+   _mesa_reference_program(ctx, &ctx->GeometryProgram._Current, gsProg);
+   _mesa_reference_program(ctx, &ctx->TessEvalProgram._Current, tesProg);
+   _mesa_reference_program(ctx, &ctx->TessCtrlProgram._Current, tcsProg);
+   _mesa_reference_program(ctx, &ctx->ComputeProgram._Current, csProg);
 
    bool vp_changed = ctx->VertexProgram._Current != prevVP;
    bool tep_changed = ctx->TessEvalProgram._Current != prevTEP;
-- 
GitLab


From 981f4463d4dc611b21e1c3488969fef1f1472dc2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 26 Nov 2022 12:22:26 -0500
Subject: [PATCH 02/13] st/mesa: always unbind constant buffer 0 when unbinding
 a shader

softpipe loads from an unbound and destroyed constant buffer for some reason
---
 src/mesa/state_tracker/st_atom.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_atom.h b/src/mesa/state_tracker/st_atom.h
index e616c0d8c4b4..938a1cf88b76 100644
--- a/src/mesa/state_tracker/st_atom.h
+++ b/src/mesa/state_tracker/st_atom.h
@@ -168,7 +168,6 @@ enum {
 
 #define ST_ALL_SHADER_RESOURCES (ST_NEW_SAMPLER_VIEWS | \
                                  ST_NEW_SAMPLERS | \
-                                 ST_NEW_CONSTANTS | \
                                  ST_NEW_UNIFORM_BUFFER | \
                                  ST_NEW_ATOMIC_BUFFER | \
                                  ST_NEW_STORAGE_BUFFER | \
-- 
GitLab


From 8798dfec8462d0b9a4bd758f13b710fc6bbd7548 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 06:42:07 -0500
Subject: [PATCH 03/13] st/mesa: move check_program_state code into
 _mesa_update_state

_mesa_update_state() receives the _NEW_PROGRAM flag, so we can handle
any shader changes there.

There may be some overhead reduction because gfx_shaders_may_be_dirty
is removed.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/compute.c                 |   3 +-
 src/mesa/main/mtypes.h                  |   1 -
 src/mesa/main/state.c                   | 108 ++++++++++++++++++++--
 src/mesa/state_tracker/st_atom.c        | 117 +-----------------------
 src/mesa/state_tracker/st_atom.h        |   4 +-
 src/mesa/state_tracker/st_cb_bitmap.c   |   3 +-
 src/mesa/state_tracker/st_cb_feedback.c |   2 +-
 src/mesa/state_tracker/st_context.c     |   2 -
 src/mesa/state_tracker/st_context.h     |   6 --
 src/mesa/state_tracker/st_draw.c        |   3 +-
 src/mesa/state_tracker/st_program.c     |   2 +-
 11 files changed, 106 insertions(+), 145 deletions(-)

diff --git a/src/mesa/main/compute.c b/src/mesa/main/compute.c
index 8e585fdf39ac..1705ec6805f5 100644
--- a/src/mesa/main/compute.c
+++ b/src/mesa/main/compute.c
@@ -296,8 +296,7 @@ prepare_compute(struct gl_context *ctx)
       _mesa_update_state(ctx);
 
    if ((st->dirty | ctx->NewDriverState) & st->active_states &
-       ST_PIPELINE_COMPUTE_STATE_MASK ||
-       st->compute_shader_may_be_dirty)
+       ST_PIPELINE_COMPUTE_STATE_MASK)
       st_validate_state(st, ST_PIPELINE_COMPUTE);
 
 }
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 6bd289476ab0..80033bd0fa68 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3581,7 +3581,6 @@ struct gl_context
 
    GLuint TextureStateTimestamp; /**< detect changes to shared state */
 
-   GLboolean LastVertexStageDirty; /**< the last vertex stage has changed */
    GLboolean PointSizeIsSet; /**< the glPointSize value in the shader is set */
 
    /** \name For debugging/development only */
diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 13d62d0ca53c..daf5688fe4a5 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -56,6 +56,7 @@
 #include "blend.h"
 
 #include "state_tracker/st_context.h"
+#include "state_tracker/st_util.h"
 
 void
 _mesa_update_allow_draw_out_of_order(struct gl_context *ctx)
@@ -184,6 +185,12 @@ update_program(struct gl_context *ctx)
    const struct gl_program *prevTCP = ctx->TessCtrlProgram._Current;
    const struct gl_program *prevTEP = ctx->TessEvalProgram._Current;
    const struct gl_program *prevCP = ctx->ComputeProgram._Current;
+   uint64_t prev_vp_affected_states = prevVP ? prevVP->affected_states : 0;
+   uint64_t prev_tcp_affected_states = prevTCP ? prevTCP->affected_states : 0;
+   uint64_t prev_tep_affected_states = prevTEP ? prevTEP->affected_states : 0;
+   uint64_t prev_gp_affected_states = prevGP ? prevGP->affected_states : 0;
+   uint64_t prev_fp_affected_states = prevFP ? prevFP->affected_states : 0;
+   uint64_t prev_cp_affected_states = prevCP ? prevCP->affected_states : 0;
 
    /*
     * Set the ctx->VertexProgram._Current and ctx->FragmentProgram._Current
@@ -259,24 +266,105 @@ update_program(struct gl_context *ctx)
    _mesa_reference_program(ctx, &ctx->ComputeProgram._Current, csProg);
 
    bool vp_changed = ctx->VertexProgram._Current != prevVP;
+   bool tcp_changed = ctx->TessCtrlProgram._Current != prevTCP;
    bool tep_changed = ctx->TessEvalProgram._Current != prevTEP;
    bool gp_changed = ctx->GeometryProgram._Current != prevGP;
+   bool fp_changed = ctx->FragmentProgram._Current != prevFP;
+   bool cp_changed = ctx->ComputeProgram._Current != prevCP;
+
+   /* Set NewDriverState depending on which shaders have changed. */
+   uint64_t dirty = 0;
+
+   /* Flag states used by both new and old shaders to rebind shader resources
+    * (because shaders pack them and reorder them) and to unbind shader
+    * resources properly when transitioning to shaders that don't use them.
+    */
+   if (vp_changed) {
+      ctx->Array.NewVertexElements = true;
+      dirty |= prev_vp_affected_states;
+      if (ctx->VertexProgram._Current)
+         dirty |= ST_NEW_VERTEX_PROGRAM(ctx, ctx->VertexProgram._Current);
+   }
+
+   if (tcp_changed) {
+      dirty |= prev_tcp_affected_states;
+      if (ctx->TessCtrlProgram._Current)
+         dirty |= ctx->TessCtrlProgram._Current->affected_states;
+   }
+
+   if (tep_changed) {
+      dirty |= prev_tep_affected_states;
+      if (ctx->TessEvalProgram._Current)
+         dirty |= ctx->TessEvalProgram._Current->affected_states;
+   }
+
+   if (gp_changed) {
+      dirty |= prev_gp_affected_states;
+      if (ctx->GeometryProgram._Current)
+         dirty |= ctx->GeometryProgram._Current->affected_states;
+   }
+
+   if (fp_changed) {
+      dirty |= prev_fp_affected_states;
+      if (ctx->FragmentProgram._Current)
+         dirty |= ctx->FragmentProgram._Current->affected_states;
+   }
+
+   if (cp_changed) {
+      dirty |= prev_cp_affected_states;
+      if (ctx->ComputeProgram._Current)
+         dirty |= ctx->ComputeProgram._Current->affected_states;
+   }
+
+   struct gl_program *last_vertex_stage;
+   bool last_vertex_stage_dirty;
+
    if (ctx->GeometryProgram._Current) {
-      ctx->LastVertexStageDirty |= gp_changed;
+      last_vertex_stage = ctx->GeometryProgram._Current;
+      last_vertex_stage_dirty = gp_changed;
    } else if (ctx->TessEvalProgram._Current) {
-      ctx->LastVertexStageDirty |= gp_changed | tep_changed;
+      last_vertex_stage = ctx->TessEvalProgram._Current;
+      last_vertex_stage_dirty = gp_changed | tep_changed;
    } else {
-      ctx->LastVertexStageDirty |= gp_changed | tep_changed | vp_changed;
+      last_vertex_stage = ctx->VertexProgram._Current;
+      last_vertex_stage_dirty = gp_changed | tep_changed | vp_changed;
    }
 
-   /* Let the driver know what's happening:
+   /* Find out the number of viewports. This determines how many scissors
+    * and viewport states we need to update.
     */
-   if (ctx->FragmentProgram._Current != prevFP ||
-       ctx->VertexProgram._Current != prevVP ||
-       ctx->GeometryProgram._Current != prevGP ||
-       ctx->TessEvalProgram._Current != prevTEP ||
-       ctx->TessCtrlProgram._Current != prevTCP ||
-       ctx->ComputeProgram._Current != prevCP)
+   struct st_context *st = ctx->st;
+   unsigned num_viewports = 1;
+
+   if (last_vertex_stage &&
+       last_vertex_stage->info.outputs_written & (
+             VARYING_BIT_VIEWPORT | VARYING_BIT_VIEWPORT_MASK))
+      num_viewports = ctx->Const.MaxViewports;
+
+   if (st->state.num_viewports != num_viewports) {
+      st->state.num_viewports = num_viewports;
+      dirty |= ST_NEW_VIEWPORT;
+
+      if (ctx->Scissor.EnableFlags & u_bit_consecutive(0, num_viewports))
+         dirty |= ST_NEW_SCISSOR;
+   }
+
+   if (st->lower_point_size && last_vertex_stage_dirty &&
+       !ctx->VertexProgram.PointSizeEnabled && !ctx->PointSizeIsSet) {
+      if (ctx->GeometryProgram._Current) {
+         st->dirty |= ST_NEW_GS_CONSTANTS;
+      } else if (ctx->TessEvalProgram._Current) {
+         st->dirty |= ST_NEW_TES_CONSTANTS;
+      } else {
+         st->dirty |= ST_NEW_VS_CONSTANTS;
+      }
+   }
+
+   ctx->NewDriverState |= dirty;
+
+   /* Let the driver know what's happening: */
+   if (fp_changed || vp_changed || gp_changed || tep_changed ||
+       tcp_changed || cp_changed)
       return _NEW_PROGRAM;
 
    return 0;
diff --git a/src/mesa/state_tracker/st_atom.c b/src/mesa/state_tracker/st_atom.c
index 0bb8e11e8aac..f2ceb59c4a11 100644
--- a/src/mesa/state_tracker/st_atom.c
+++ b/src/mesa/state_tracker/st_atom.c
@@ -65,104 +65,11 @@ void st_init_atoms( struct st_context *st )
    call_once(&flag, init_atoms_once);
 }
 
-
 void st_destroy_atoms( struct st_context *st )
 {
    /* no-op */
 }
 
-
-/* Too complex to figure out, just check every time:
- */
-static void check_program_state( struct st_context *st )
-{
-   struct gl_context *ctx = st->ctx;
-   struct gl_program *old_vp = st->vp;
-   struct gl_program *old_tcp = st->tcp;
-   struct gl_program *old_tep = st->tep;
-   struct gl_program *old_gp = st->gp;
-   struct gl_program *old_fp = st->fp;
-
-   struct gl_program *new_vp = ctx->VertexProgram._Current;
-   struct gl_program *new_tcp = ctx->TessCtrlProgram._Current;
-   struct gl_program *new_tep = ctx->TessEvalProgram._Current;
-   struct gl_program *new_gp = ctx->GeometryProgram._Current;
-   struct gl_program *new_fp = ctx->FragmentProgram._Current;
-   uint64_t dirty = 0;
-   unsigned num_viewports = 1;
-
-   /* Flag states used by both new and old shaders to unbind shader resources
-    * properly when transitioning to shaders that don't use them.
-    */
-   if (unlikely(new_vp != old_vp)) {
-      ctx->Array.NewVertexElements = true;
-      if (old_vp)
-         dirty |= old_vp->affected_states;
-      if (new_vp)
-         dirty |= ST_NEW_VERTEX_PROGRAM(st, new_vp);
-   }
-
-   if (unlikely(new_tcp != old_tcp)) {
-      if (old_tcp)
-         dirty |= old_tcp->affected_states;
-      if (new_tcp)
-         dirty |= new_tcp->affected_states;
-   }
-
-   if (unlikely(new_tep != old_tep)) {
-      if (old_tep)
-         dirty |= old_tep->affected_states;
-      if (new_tep)
-         dirty |= new_tep->affected_states;
-   }
-
-   if (unlikely(new_gp != old_gp)) {
-      if (old_gp)
-         dirty |= old_gp->affected_states;
-      if (new_gp)
-         dirty |= new_gp->affected_states;
-   }
-
-   if (unlikely(new_fp != old_fp)) {
-      if (old_fp)
-         dirty |= old_fp->affected_states;
-      if (new_fp)
-         dirty |= new_fp->affected_states;
-   }
-
-   /* Find out the number of viewports. This determines how many scissors
-    * and viewport states we need to update.
-    */
-   struct gl_program *last_prim_shader = new_gp ? new_gp :
-                                         new_tep ? new_tep : new_vp;
-   if (last_prim_shader &&
-       last_prim_shader->info.outputs_written & (
-             VARYING_BIT_VIEWPORT | VARYING_BIT_VIEWPORT_MASK))
-      num_viewports = ctx->Const.MaxViewports;
-
-   if (st->state.num_viewports != num_viewports) {
-      st->state.num_viewports = num_viewports;
-      dirty |= ST_NEW_VIEWPORT;
-
-      if (ctx->Scissor.EnableFlags & u_bit_consecutive(0, num_viewports))
-         dirty |= ST_NEW_SCISSOR;
-   }
-
-   if (st->lower_point_size && st->ctx->LastVertexStageDirty &&
-       !st->ctx->VertexProgram.PointSizeEnabled && !st->ctx->PointSizeIsSet) {
-      if (new_gp) {
-         st->dirty |= ST_NEW_GS_CONSTANTS;
-      } else if (new_tep) {
-         st->dirty |= ST_NEW_TES_CONSTANTS;
-      } else {
-         st->dirty |= ST_NEW_VS_CONSTANTS;
-      }
-   }
-   st->ctx->LastVertexStageDirty = false;
-
-   st->dirty |= dirty;
-}
-
 void st_update_edgeflags(struct st_context *st, bool per_vertex_edgeflags)
 {
    bool edgeflags_enabled = st->ctx->Polygon.FrontMode != GL_FILL ||
@@ -174,7 +81,7 @@ void st_update_edgeflags(struct st_context *st, bool per_vertex_edgeflags)
 
       struct gl_program *vp = st->ctx->VertexProgram._Current;
       if (vp)
-         st->dirty |= ST_NEW_VERTEX_PROGRAM(st, vp);
+         st->dirty |= ST_NEW_VERTEX_PROGRAM(st->ctx, vp);
    }
 
    bool edgeflag_culls_prims = edgeflags_enabled && !vertdata_edgeflags &&
@@ -214,11 +121,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       if (st->ctx->API == API_OPENGL_COMPAT)
          check_attrib_edgeflag(st);
 
-      if (st->gfx_shaders_may_be_dirty) {
-         check_program_state(st);
-         st->gfx_shaders_may_be_dirty = false;
-      }
-
       if (pipeline == ST_PIPELINE_RENDER)
          pipeline_mask = ST_PIPELINE_RENDER_STATE_MASK;
       else
@@ -230,11 +132,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       break;
 
    case ST_PIPELINE_META:
-      if (st->gfx_shaders_may_be_dirty) {
-         check_program_state(st);
-         st->gfx_shaders_may_be_dirty = false;
-      }
-
       pipeline_mask = ST_PIPELINE_META_STATE_MASK;
       break;
 
@@ -243,18 +140,6 @@ void st_validate_state( struct st_context *st, enum st_pipeline pipeline )
       break;
 
    case ST_PIPELINE_COMPUTE: {
-      struct gl_program *old_cp = st->cp;
-      struct gl_program *new_cp = ctx->ComputeProgram._Current;
-
-      if (new_cp != old_cp) {
-         if (old_cp)
-            st->dirty |= old_cp->affected_states;
-         assert(new_cp);
-         st->dirty |= new_cp->affected_states;
-      }
-
-      st->compute_shader_may_be_dirty = false;
-
       /*
        * We add the ST_NEW_FB_STATE bit here as well, because glBindFramebuffer
        * acts as a barrier that breaks feedback loops between the framebuffer
diff --git a/src/mesa/state_tracker/st_atom.h b/src/mesa/state_tracker/st_atom.h
index 938a1cf88b76..010f2e5f4e6e 100644
--- a/src/mesa/state_tracker/st_atom.h
+++ b/src/mesa/state_tracker/st_atom.h
@@ -120,8 +120,8 @@ enum {
                                  ST_NEW_SAMPLE_STATE | \
                                  ST_NEW_SAMPLE_SHADING)
 
-#define ST_NEW_VERTEX_PROGRAM(st, p) ((p)->affected_states | \
-                                      (st_user_clip_planes_enabled(st->ctx) ? \
+#define ST_NEW_VERTEX_PROGRAM(ctx, p) ((p)->affected_states | \
+                                      (st_user_clip_planes_enabled(ctx) ? \
                                        ST_NEW_CLIP_STATE : 0))
 
 #define ST_NEW_CONSTANTS        (ST_NEW_VS_CONSTANTS | \
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index bfe8de4fd0c0..7b2433ec5a78 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -618,8 +618,7 @@ st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
     * explicitly uploaded in the draw_bitmap_quad() function.
     */
    if ((st->dirty | ctx->NewDriverState) & st->active_states &
-       ~ST_NEW_CONSTANTS & ST_PIPELINE_RENDER_STATE_MASK ||
-       st->gfx_shaders_may_be_dirty) {
+       ~ST_NEW_CONSTANTS & ST_PIPELINE_RENDER_STATE_MASK) {
       st_validate_state(st, ST_PIPELINE_META);
    }
 
diff --git a/src/mesa/state_tracker/st_cb_feedback.c b/src/mesa/state_tracker/st_cb_feedback.c
index e5ae1296266e..ec62a0a077be 100644
--- a/src/mesa/state_tracker/st_cb_feedback.c
+++ b/src/mesa/state_tracker/st_cb_feedback.c
@@ -313,7 +313,7 @@ st_RenderMode(struct gl_context *ctx, GLenum newMode )
       ctx->Driver.DrawGalliumMultiMode = st_feedback_draw_vbo_multi_mode;
       /* need to generate/use a vertex program that emits pos/color/tex */
       if (vp)
-         st->dirty |= ST_NEW_VERTEX_PROGRAM(st, vp);
+         st->dirty |= ST_NEW_VERTEX_PROGRAM(ctx, vp);
    }
 
    /* Restore geometry shader states when leaving GL_SELECT mode. */
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index d711bd1750cf..f46eee4f3200 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -185,8 +185,6 @@ st_invalidate_state(struct gl_context *ctx)
 
    /* Which shaders are dirty will be determined manually. */
    if (new_state & _NEW_PROGRAM) {
-      st->gfx_shaders_may_be_dirty = true;
-      st->compute_shader_may_be_dirty = true;
       /* This will mask out unused shader resources. */
       st->active_states = st_get_active_states(ctx);
    }
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 7f5c5dc65b9f..cc952951a89b 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -249,12 +249,6 @@ struct st_context
    /** This masks out unused shader resources. Only valid in draw calls. */
    uint64_t active_states;
 
-   /* If true, further analysis of states is required to know if something
-    * has changed. Used mainly for shaders.
-    */
-   bool gfx_shaders_may_be_dirty;
-   bool compute_shader_may_be_dirty;
-
    GLboolean vertdata_edgeflags;
    GLboolean edgeflag_culls_prims;
 
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 18c27c7f4595..4bff75bbdf55 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -86,8 +86,7 @@ prepare_draw(struct st_context *st, struct gl_context *ctx, uint64_t state_mask,
    st_invalidate_readpix_cache(st);
 
    /* Validate state. */
-   if ((st->dirty | ctx->NewDriverState) & st->active_states & state_mask ||
-       st->gfx_shaders_may_be_dirty) {
+   if ((st->dirty | ctx->NewDriverState) & st->active_states & state_mask) {
       st_validate_state(st, pipeline);
    }
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index ff784a448035..d041d60addd7 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -1314,7 +1314,7 @@ st_finalize_program(struct st_context *st, struct gl_program *prog)
    if (st->current_program[prog->info.stage] == prog) {
       if (prog->info.stage == MESA_SHADER_VERTEX) {
          st->ctx->Array.NewVertexElements = true;
-         st->dirty |= ST_NEW_VERTEX_PROGRAM(st, prog);
+         st->dirty |= ST_NEW_VERTEX_PROGRAM(st->ctx, prog);
       } else {
          st->dirty |= prog->affected_states;
       }
-- 
GitLab


From f3366ae6dba0a1a938677b47531e8944da2f3928 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 06:53:48 -0500
Subject: [PATCH 04/13] st/mesa: update st_context::active_states in
 _mesa_update_state

just a code movement to a better place

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/state.c               | 32 ++++++++++++++++++++++++-
 src/mesa/main/state.h               |  3 +++
 src/mesa/state_tracker/st_context.c | 36 +----------------------------
 3 files changed, 35 insertions(+), 36 deletions(-)

diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index daf5688fe4a5..5cba82cacdd5 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -150,6 +150,33 @@ _mesa_update_allow_draw_out_of_order(struct gl_context *ctx)
       FLUSH_VERTICES(ctx, 0, 0);
 }
 
+uint64_t
+_mesa_get_active_states(struct gl_context *ctx)
+{
+   struct gl_program *vp = ctx->VertexProgram._Current;
+   struct gl_program *tcp = ctx->TessCtrlProgram._Current;
+   struct gl_program *tep = ctx->TessEvalProgram._Current;
+   struct gl_program *gp = ctx->GeometryProgram._Current;
+   struct gl_program *fp = ctx->FragmentProgram._Current;
+   struct gl_program *cp = ctx->ComputeProgram._Current;
+   uint64_t active_shader_states = 0;
+
+   if (vp)
+      active_shader_states |= vp->affected_states;
+   if (tcp)
+      active_shader_states |= tcp->affected_states;
+   if (tep)
+      active_shader_states |= tep->affected_states;
+   if (gp)
+      active_shader_states |= gp->affected_states;
+   if (fp)
+      active_shader_states |= fp->affected_states;
+   if (cp)
+      active_shader_states |= cp->affected_states;
+
+   /* Mark non-shader-resource shader states as "always active". */
+   return active_shader_states | ~ST_ALL_SHADER_RESOURCES;
+}
 
 /**
  * Update the ctx->*Program._Current pointers to point to the
@@ -364,8 +391,11 @@ update_program(struct gl_context *ctx)
 
    /* Let the driver know what's happening: */
    if (fp_changed || vp_changed || gp_changed || tep_changed ||
-       tcp_changed || cp_changed)
+       tcp_changed || cp_changed) {
+      /* This will mask out unused shader resources. */
+      st->active_states = _mesa_get_active_states(ctx);
       return _NEW_PROGRAM;
+   }
 
    return 0;
 }
diff --git a/src/mesa/main/state.h b/src/mesa/main/state.h
index 411cbcc3adcb..c7cb6f26e8fb 100644
--- a/src/mesa/main/state.h
+++ b/src/mesa/main/state.h
@@ -31,6 +31,9 @@
 extern void
 _mesa_update_allow_draw_out_of_order(struct gl_context *ctx);
 
+extern uint64_t
+_mesa_get_active_states(struct gl_context *ctx);
+
 extern void
 _mesa_update_state(struct gl_context *ctx);
 
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index f46eee4f3200..c3b18c39e4e8 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -71,35 +71,6 @@
 
 DEBUG_GET_ONCE_BOOL_OPTION(mesa_mvp_dp4, "MESA_MVP_DP4", FALSE)
 
-static uint64_t
-st_get_active_states(struct gl_context *ctx)
-{
-   struct gl_program *vp = ctx->VertexProgram._Current;
-   struct gl_program *tcp = ctx->TessCtrlProgram._Current;
-   struct gl_program *tep = ctx->TessEvalProgram._Current;
-   struct gl_program *gp = ctx->GeometryProgram._Current;
-   struct gl_program *fp = ctx->FragmentProgram._Current;
-   struct gl_program *cp = ctx->ComputeProgram._Current;
-   uint64_t active_shader_states = 0;
-
-   if (vp)
-      active_shader_states |= vp->affected_states;
-   if (tcp)
-      active_shader_states |= tcp->affected_states;
-   if (tep)
-      active_shader_states |= tep->affected_states;
-   if (gp)
-      active_shader_states |= gp->affected_states;
-   if (fp)
-      active_shader_states |= fp->affected_states;
-   if (cp)
-      active_shader_states |= cp->affected_states;
-
-   /* Mark non-shader-resource shader states as "always active". */
-   return active_shader_states | ~ST_ALL_SHADER_RESOURCES;
-}
-
-
 void
 st_invalidate_buffers(struct st_context *st)
 {
@@ -183,12 +154,6 @@ st_invalidate_state(struct gl_context *ctx)
          st->dirty |= ST_NEW_VS_STATE | ST_NEW_VS_CONSTANTS;
    }
 
-   /* Which shaders are dirty will be determined manually. */
-   if (new_state & _NEW_PROGRAM) {
-      /* This will mask out unused shader resources. */
-      st->active_states = st_get_active_states(ctx);
-   }
-
    if (new_state & _NEW_TEXTURE_OBJECT) {
       st->dirty |= st->active_states &
                    (ST_NEW_SAMPLER_VIEWS |
@@ -803,6 +768,7 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
    ctx->Const.DriverSupportedPrimMask = screen->get_param(screen, PIPE_CAP_SUPPORTED_PRIM_MODES) |
                                         /* patches is always supported */
                                         BITFIELD_BIT(PIPE_PRIM_PATCHES);
+   st->active_states = _mesa_get_active_states(ctx);
 
    return st;
 }
-- 
GitLab


From ffdf27adf3bec68eaa7631691f2708b433fbaef8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:07:46 -0500
Subject: [PATCH 05/13] mesa: flag ST_NEW_FS_CONSTANTS instead of _NEW_PROGRAM
 for ATI_fs constants

We only need to update the constant buffer.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/atifragshader.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/mesa/main/atifragshader.c b/src/mesa/main/atifragshader.c
index f8fd16a35044..6baa6a4a5565 100644
--- a/src/mesa/main/atifragshader.c
+++ b/src/mesa/main/atifragshader.c
@@ -827,7 +827,8 @@ _mesa_SetFragmentShaderConstantATI(GLuint dst, const GLfloat * value)
       curProg->LocalConstDef |= 1 << dstindex;
    }
    else {
-      FLUSH_VERTICES(ctx, _NEW_PROGRAM, 0);
+      FLUSH_VERTICES(ctx, 0, 0);
+      ctx->NewDriverState |= ST_NEW_FS_CONSTANTS;
       COPY_4V(ctx->ATIFragmentShader.GlobalConstants[dstindex], value);
    }
 }
-- 
GitLab


From 4be1cfdbd6e92d35fd1a445b941cbead9a37cccb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:20:20 -0500
Subject: [PATCH 06/13] mesa: set fewer dirty flags for PointSizeEnabled state
 changes

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/enable.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index 5aab14268bf2..ed8016bcf8c5 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -128,7 +128,9 @@ client_state(struct gl_context *ctx, struct gl_vertex_array_object* vao,
 
       case GL_POINT_SIZE_ARRAY_OES:
          if (ctx->VertexProgram.PointSizeEnabled != state) {
-            FLUSH_VERTICES(ctx, _NEW_PROGRAM, 0);
+            FLUSH_VERTICES(ctx, ctx->st->lower_point_size ? _NEW_PROGRAM : 0,
+                           0);
+            ctx->NewDriverState |= ST_NEW_RASTERIZER;
             ctx->VertexProgram.PointSizeEnabled = state;
          }
          vao_state(ctx, vao, VERT_ATTRIB_POINT_SIZE, state);
@@ -1091,7 +1093,9 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             goto invalid_enum_error;
          if (ctx->VertexProgram.PointSizeEnabled == state)
             return;
-         FLUSH_VERTICES(ctx, _NEW_PROGRAM, GL_ENABLE_BIT);
+         FLUSH_VERTICES(ctx, ctx->st->lower_point_size ? _NEW_PROGRAM : 0,
+                        GL_ENABLE_BIT);
+         ctx->NewDriverState |= ST_NEW_RASTERIZER;
          ctx->VertexProgram.PointSizeEnabled = state;
          break;
       case GL_VERTEX_PROGRAM_TWO_SIDE_ARB:
-- 
GitLab


From 7b52d5a316ec3ce6fbb05605edf77864a4887570 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:31:03 -0500
Subject: [PATCH 07/13] mesa: set fewer flags for VertexProgram.TwoSideEnabled
 changes

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/enable.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index ed8016bcf8c5..5696aa16a6ed 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -1103,7 +1103,14 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             goto invalid_enum_error;
          if (ctx->VertexProgram.TwoSideEnabled == state)
             return;
-         FLUSH_VERTICES(ctx, _NEW_PROGRAM, GL_ENABLE_BIT);
+         FLUSH_VERTICES(ctx, 0, GL_ENABLE_BIT);
+         if (ctx->st->lower_two_sided_color) {
+            /* TODO: this could be smaller, but most drivers don't get here */
+            ctx->NewDriverState |= ST_NEW_VS_STATE |
+                                   ST_NEW_TES_STATE |
+                                   ST_NEW_GS_STATE;
+         }
+         ctx->NewDriverState |= ST_NEW_RASTERIZER;
          ctx->VertexProgram.TwoSideEnabled = state;
          break;
 
-- 
GitLab


From aa6cd84b70e09776e28d5210a1b3dfe43d018af6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:35:00 -0500
Subject: [PATCH 08/13] mesa: don't flag _NEW_PROGRAM for "texture_unit ->
 sampler" mapping changes

st/mesa just reorders sampler views, so we only need to rebind those.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/uniform_query.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index 6135c80586ac..70bf6816fca4 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -1551,7 +1551,7 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
                 */
                if (sampler->unit != value || !sampler->bound) {
                   if (!flushed) {
-                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT | _NEW_PROGRAM, 0);
+                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT, 0);
                      flushed = true;
                   }
                   sampler->unit = value;
@@ -1562,7 +1562,7 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
             } else {
                if (sh->Program->SamplerUnits[unit] != value) {
                   if (!flushed) {
-                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT | _NEW_PROGRAM, 0);
+                     FLUSH_VERTICES(ctx, _NEW_TEXTURE_OBJECT, 0);
                      flushed = true;
                   }
                   sh->Program->SamplerUnits[unit] = value;
-- 
GitLab


From 2eb793eea7798d05a4331236d969e46df87c302e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:38:40 -0500
Subject: [PATCH 09/13] mesa: remove unused composite _NEW_* flags

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/mtypes.h | 31 -------------------------------
 1 file changed, 31 deletions(-)

diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 80033bd0fa68..8d2f978de709 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -2852,37 +2852,6 @@ struct gl_matrix_stack
 /*@}*/
 
 
-/**
- * Composite state flags, deprecated and inefficient, do not use.
- */
-/*@{*/
-#define _NEW_LIGHT     (_NEW_LIGHT_CONSTANTS |  /* state parameters */ \
-                        _NEW_LIGHT_STATE |      /* rasterizer state */ \
-                        _NEW_MATERIAL |         /* light materials */ \
-                        _NEW_FF_VERT_PROGRAM | \
-                        _NEW_FF_FRAG_PROGRAM)
-
-#define _NEW_TEXTURE   (_NEW_TEXTURE_OBJECT | _NEW_TEXTURE_STATE | \
-                        _NEW_FF_VERT_PROGRAM | _NEW_FF_FRAG_PROGRAM)
-
-#define _MESA_NEW_NEED_EYE_COORDS         (_NEW_FF_VERT_PROGRAM | \
-                                           _NEW_FF_FRAG_PROGRAM | \
-                                           _NEW_LIGHT_CONSTANTS | \
-                                           _NEW_TEXTURE_STATE |	\
-                                           _NEW_POINT |		\
-                                           _NEW_PROGRAM |	\
-                                           _NEW_MODELVIEW)
-
-#define _MESA_NEW_SEPARATE_SPECULAR        (_NEW_LIGHT | \
-                                            _NEW_FOG | \
-                                            _NEW_PROGRAM)
-
-
-/*@}*/
-
-
-
-
 /* This has to be included here. */
 #include "dd.h"
 
-- 
GitLab


From 30d9aaea90f63cb2ee418eaa6a4b3fc05aa85858 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:49:33 -0500
Subject: [PATCH 10/13] mesa: flag ST_NEW_RASTERIZER for
 !needs_texcoord_semantic if changing FS

This will be required with the next change, which will remove
the rasterizer state dependency on _NEW_PROGRAM.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/state.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 5cba82cacdd5..9e56bfc28420 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -335,6 +335,9 @@ update_program(struct gl_context *ctx)
       dirty |= prev_fp_affected_states;
       if (ctx->FragmentProgram._Current)
          dirty |= ctx->FragmentProgram._Current->affected_states;
+
+      if (!ctx->st->needs_texcoord_semantic)
+         dirty |= ST_NEW_RASTERIZER;
    }
 
    if (cp_changed) {
-- 
GitLab


From 14c9cfc266ef06aa94ffd4d784ed1e938f7778be Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 07:52:11 -0500
Subject: [PATCH 11/13] st/mesa: don't flag ST_NEW_RASTERIZER for _NEW_PROGRAM

This should have no effect thanks to previous commits.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/state_tracker/st_context.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index c3b18c39e4e8..02e234090800 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -108,9 +108,6 @@ st_invalidate_state(struct gl_context *ctx)
       /* These set a subset of flags set by _NEW_BUFFERS, so we only have to
        * check them when _NEW_BUFFERS isn't set.
        */
-      if (new_state & _NEW_PROGRAM)
-         st->dirty |= ST_NEW_RASTERIZER;
-
       if (new_state & _NEW_FOG)
          st->dirty |= ST_NEW_FS_STATE;
    }
-- 
GitLab


From fffc680a77b7de97ef4586fa9ec4b2a8504c472e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 10:20:17 -0500
Subject: [PATCH 12/13] st/mesa: fix the glBitmap cache wrt FS, scissor, and
 clamp color changes

We need to track those states in the cache and flush the cache
if the next glBitmap call uses different states.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/enable.c                |  4 ---
 src/mesa/main/scissor.c               |  3 --
 src/mesa/state_tracker/st_cb_bitmap.c | 42 ++++++++++++++++++++-------
 src/mesa/state_tracker/st_context.h   |  4 +++
 4 files changed, 35 insertions(+), 18 deletions(-)

diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index 5696aa16a6ed..22ca9a30f220 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -868,8 +868,6 @@ _mesa_set_enable(struct gl_context *ctx, GLenum cap, GLboolean state)
             GLbitfield newEnabled =
                state * ((1 << ctx->Const.MaxViewports) - 1);
             if (newEnabled != ctx->Scissor.EnableFlags) {
-               st_flush_bitmap_cache(st_context(ctx));
-
                FLUSH_VERTICES(ctx, 0,
                               GL_SCISSOR_BIT | GL_ENABLE_BIT);
                ctx->NewDriverState |= ST_NEW_SCISSOR | ST_NEW_RASTERIZER;
@@ -1404,8 +1402,6 @@ _mesa_set_enablei(struct gl_context *ctx, GLenum cap,
          return;
       }
       if (((ctx->Scissor.EnableFlags >> index) & 1) != state) {
-         st_flush_bitmap_cache(st_context(ctx));
-
          FLUSH_VERTICES(ctx, 0,
                         GL_SCISSOR_BIT | GL_ENABLE_BIT);
          ctx->NewDriverState |= ST_NEW_SCISSOR | ST_NEW_RASTERIZER;
diff --git a/src/mesa/main/scissor.c b/src/mesa/main/scissor.c
index c4bff669c6cd..a3bf2ae15ce1 100644
--- a/src/mesa/main/scissor.c
+++ b/src/mesa/main/scissor.c
@@ -51,9 +51,6 @@ set_scissor_no_notify(struct gl_context *ctx, unsigned idx,
        height == ctx->Scissor.ScissorArray[idx].Height)
       return;
 
-   if (ctx->Scissor.EnableFlags)
-      st_flush_bitmap_cache(st_context(ctx));
-
    FLUSH_VERTICES(ctx, 0, GL_SCISSOR_BIT);
    ctx->NewDriverState |= ST_NEW_SCISSOR;
 
diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index 7b2433ec5a78..86cd6cc728a0 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -170,7 +170,8 @@ st_make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
 static void
 setup_render_state(struct gl_context *ctx,
                    struct pipe_sampler_view *sv,
-                   const GLfloat *color)
+                   const GLfloat *color, struct gl_program *fp,
+                   bool scissor_enabled, bool clamp_frag_color)
 {
    struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st->pipe;
@@ -182,10 +183,10 @@ setup_render_state(struct gl_context *ctx,
    key.st = st->has_shareable_shaders ? NULL : st;
    key.bitmap = GL_TRUE;
    key.clamp_color = st->clamp_frag_color_in_shader &&
-                     ctx->Color._ClampFragmentColor;
+                     clamp_frag_color;
    key.lower_alpha_func = COMPARE_FUNC_ALWAYS;
 
-   fpv = st_get_fp_variant(st, st->fp, &key);
+   fpv = st_get_fp_variant(st, fp, &key);
 
    /* As an optimization, Mesa's fragment programs will sometimes get the
     * primary color from a statevar/constant rather than a varying variable.
@@ -198,7 +199,7 @@ setup_render_state(struct gl_context *ctx,
       GLfloat colorSave[4];
       COPY_4V(colorSave, ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
       COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], color);
-      st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, fp, MESA_SHADER_FRAGMENT);
       COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], colorSave);
    }
 
@@ -211,7 +212,7 @@ setup_render_state(struct gl_context *ctx,
 
 
    /* rasterizer state: just scissor */
-   st->bitmap.rasterizer.scissor = ctx->Scissor.EnableFlags & 1;
+   st->bitmap.rasterizer.scissor = scissor_enabled;
    cso_set_rasterizer(cso, &st->bitmap.rasterizer);
 
    /* fragment shader state: TEX lookup program */
@@ -243,8 +244,7 @@ setup_render_state(struct gl_context *ctx,
    {
       struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
       unsigned num_views =
-         st_get_sampler_views(st, PIPE_SHADER_FRAGMENT,
-                              ctx->FragmentProgram._Current, sampler_views);
+         st_get_sampler_views(st, PIPE_SHADER_FRAGMENT, fp, sampler_views);
 
       num_views = MAX2(fpv->bitmap_sampler + 1, num_views);
       sampler_views[fpv->bitmap_sampler] = sv;
@@ -294,7 +294,9 @@ restore_render_state(struct gl_context *ctx)
 static void
 draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
                  GLsizei width, GLsizei height,
-                 struct pipe_sampler_view *sv, const GLfloat *color)
+                 struct pipe_sampler_view *sv, const GLfloat *color,
+                 struct gl_program *fp, bool scissor_enabled,
+                 bool clamp_frag_color)
 {
    struct st_context *st = st_context(ctx);
    const float fb_width = (float) st->state.fb_width;
@@ -327,7 +329,7 @@ draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
       tBot = (float) height;
    }
 
-   setup_render_state(ctx, sv, color);
+   setup_render_state(ctx, sv, color, fp, scissor_enabled, clamp_frag_color);
 
    /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
    z = z * 2.0f - 1.0f;
@@ -357,6 +359,8 @@ reset_cache(struct st_context *st)
    cache->ymin = 1000000;
    cache->ymax = -1000000;
 
+   _mesa_reference_program(st->ctx, &cache->fp, NULL);
+
    assert(!cache->texture);
 
    /* allocate a new texture */
@@ -453,7 +457,10 @@ st_flush_bitmap_cache(struct st_context *st)
                           cache->zpos,
                           BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                           sv,
-                          cache->color);
+                          cache->color,
+                          cache->fp,
+                          cache->scissor_enabled,
+                          cache->clamp_frag_color);
       }
 
       /* release/free the texture */
@@ -483,12 +490,18 @@ accum_bitmap(struct gl_context *ctx,
        height > BITMAP_CACHE_HEIGHT)
       return GL_FALSE; /* too big to cache */
 
+   bool scissor_enabled = ctx->Scissor.EnableFlags & 0x1;
+   bool clamp_frag_color = ctx->Color._ClampFragmentColor;
+
    if (!cache->empty) {
       px = x - cache->xpos;  /* pos in buffer */
       py = y - cache->ypos;
       if (px < 0 || px + width > BITMAP_CACHE_WIDTH ||
           py < 0 || py + height > BITMAP_CACHE_HEIGHT ||
           !TEST_EQ_4V(ctx->Current.RasterColor, cache->color) ||
+          ctx->FragmentProgram._Current != cache->fp ||
+          scissor_enabled != cache->scissor_enabled ||
+          clamp_frag_color != cache->clamp_frag_color ||
           ((fabsf(z - cache->zpos) > Z_EPSILON))) {
          /* This bitmap would extend beyond cache bounds, or the bitmap
           * color is changing
@@ -507,6 +520,9 @@ accum_bitmap(struct gl_context *ctx,
       cache->zpos = z;
       cache->empty = GL_FALSE;
       COPY_4FV(cache->color, ctx->Current.RasterColor);
+      _mesa_reference_program(ctx, &cache->fp, ctx->FragmentProgram._Current);
+      cache->scissor_enabled = scissor_enabled;
+      cache->clamp_frag_color = clamp_frag_color;
    }
 
    assert(px != -999);
@@ -645,7 +661,10 @@ st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
 
    if (view) {
       draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
-                       width, height, view, ctx->Current.RasterColor);
+                       width, height, view, ctx->Current.RasterColor,
+                       ctx->FragmentProgram._Current,
+                       ctx->Scissor.EnableFlags & 0x1,
+                       ctx->Color._ClampFragmentColor);
    }
 }
 
@@ -660,4 +679,5 @@ st_destroy_bitmap(struct st_context *st)
       pipe_texture_unmap(pipe, cache->trans);
    }
    pipe_resource_reference(&st->bitmap.cache.texture, NULL);
+   _mesa_reference_program(st->ctx, &st->bitmap.cache.fp, NULL);
 }
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index cc952951a89b..2a70cd0182d5 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -62,6 +62,10 @@ struct st_bitmap_cache
    /** Bounds of region used in window coords */
    GLint xmin, ymin, xmax, ymax;
 
+   /** GL states */
+   struct gl_program *fp;
+   bool scissor_enabled;
+   bool clamp_frag_color;
    GLfloat color[4];
 
    /** Bitmap's Z position */
-- 
GitLab


From 8207b364723622c3a8f76e50e420226142cbe444 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 18 Nov 2022 08:08:30 -0500
Subject: [PATCH 13/13] st/mesa: stop using redundant
 st_context::vp,tcp,tep,gp,fp,cp

Use ctx->XXProgram._Current instead of the st_context variables.

v2: split from a bigger commit

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/state_tracker/st_atom_array.cpp   |  3 ++-
 src/mesa/state_tracker/st_atom_constbuf.c  | 22 ++++++++++++++--------
 src/mesa/state_tracker/st_atom_msaa.c      |  7 +++----
 src/mesa/state_tracker/st_cb_drawpixels.c  |  8 ++++----
 src/mesa/state_tracker/st_cb_feedback.c    |  4 ++--
 src/mesa/state_tracker/st_cb_rasterpos.c   |  4 ++--
 src/mesa/state_tracker/st_draw_feedback.c  |  8 ++++----
 src/mesa/state_tracker/st_draw_hw_select.c |  6 ++++--
 src/mesa/state_tracker/st_program.c        | 17 ++++++++++++++++-
 9 files changed, 51 insertions(+), 28 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 4ed0d488068c..ab00e4a3fc95 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -303,7 +303,8 @@ st_update_array_templ(struct st_context *st)
 
    /* vertex program validation must be done before this */
    /* _NEW_PROGRAM, ST_NEW_VS_STATE */
-   const struct gl_vertex_program *vp = (struct gl_vertex_program *)st->vp;
+   const struct gl_vertex_program *vp =
+      (struct gl_vertex_program *)ctx->VertexProgram._Current;
    const struct st_common_variant *vp_variant = st->vp_variant;
 
    struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 9f337d4f9570..50937acbebae 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -85,8 +85,8 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
           shader_type == PIPE_SHADER_COMPUTE);
 
    /* update the ATI constants before rendering */
-   if (shader_type == PIPE_SHADER_FRAGMENT && st->fp->ati_fs) {
-      struct ati_fragment_shader *ati_fs = st->fp->ati_fs;
+   if (shader_type == PIPE_SHADER_FRAGMENT && prog->ati_fs) {
+      struct ati_fragment_shader *ati_fs = prog->ati_fs;
       unsigned c;
 
       for (c = 0; c < MAX_NUM_FRAGMENT_CONSTANTS_ATI; c++) {
@@ -213,7 +213,8 @@ st_upload_constants(struct st_context *st, struct gl_program *prog, gl_shader_st
 void
 st_update_vs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->vp, MESA_SHADER_VERTEX);
+   st_upload_constants(st, st->ctx->VertexProgram._Current,
+                       MESA_SHADER_VERTEX);
 }
 
 /**
@@ -222,7 +223,8 @@ st_update_vs_constants(struct st_context *st)
 void
 st_update_fs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+   st_upload_constants(st, st->ctx->FragmentProgram._Current,
+                       MESA_SHADER_FRAGMENT);
 }
 
 
@@ -231,7 +233,8 @@ st_update_fs_constants(struct st_context *st)
 void
 st_update_gs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->gp, MESA_SHADER_GEOMETRY);
+   st_upload_constants(st, st->ctx->GeometryProgram._Current,
+                       MESA_SHADER_GEOMETRY);
 }
 
 /* Tessellation control shader:
@@ -239,7 +242,8 @@ st_update_gs_constants(struct st_context *st)
 void
 st_update_tcs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->tcp, MESA_SHADER_TESS_CTRL);
+   st_upload_constants(st, st->ctx->TessCtrlProgram._Current,
+                       MESA_SHADER_TESS_CTRL);
 }
 
 /* Tessellation evaluation shader:
@@ -247,7 +251,8 @@ st_update_tcs_constants(struct st_context *st)
 void
 st_update_tes_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->tep, MESA_SHADER_TESS_EVAL);
+   st_upload_constants(st, st->ctx->TessEvalProgram._Current,
+                       MESA_SHADER_TESS_EVAL);
 }
 
 /* Compute shader:
@@ -255,7 +260,8 @@ st_update_tes_constants(struct st_context *st)
 void
 st_update_cs_constants(struct st_context *st)
 {
-   st_upload_constants(st, st->cp, MESA_SHADER_COMPUTE);
+   st_upload_constants(st, st->ctx->ComputeProgram._Current,
+                       MESA_SHADER_COMPUTE);
 }
 
 static void
diff --git a/src/mesa/state_tracker/st_atom_msaa.c b/src/mesa/state_tracker/st_atom_msaa.c
index 8ee71cdcc980..9e16ebda383d 100644
--- a/src/mesa/state_tracker/st_atom_msaa.c
+++ b/src/mesa/state_tracker/st_atom_msaa.c
@@ -144,12 +144,11 @@ st_update_sample_state(struct st_context *st)
 void
 st_update_sample_shading(struct st_context *st)
 {
-   if (!st->fp)
-      return;
+   struct gl_program *fp = st->ctx->FragmentProgram._Current;
 
-   if (!st->ctx->Extensions.ARB_sample_shading)
+   if (!fp || !st->ctx->Extensions.ARB_sample_shading)
       return;
 
    cso_set_min_samples(st->cso_context,
-                       _mesa_get_min_invocations_per_fragment(st->ctx, st->fp));
+                       _mesa_get_min_invocations_per_fragment(st->ctx, fp));
 }
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 7b21f2ccbbb0..e54930c823d3 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -1149,7 +1149,7 @@ get_color_fp_variant(struct st_context *st)
                      ctx->Color._ClampFragmentColor;
    key.lower_alpha_func = COMPARE_FUNC_ALWAYS;
 
-   fpv = st_get_fp_variant(st, st->fp, &key);
+   fpv = st_get_fp_variant(st, ctx->FragmentProgram._Current, &key);
 
    return fpv;
 }
@@ -1179,7 +1179,7 @@ get_color_index_fp_variant(struct st_context *st)
                      ctx->Color._ClampFragmentColor;
    key.lower_alpha_func = COMPARE_FUNC_ALWAYS;
 
-   fpv = st_get_fp_variant(st, st->fp, &key);
+   fpv = st_get_fp_variant(st, ctx->FragmentProgram._Current, &key);
 
    return fpv;
 }
@@ -1353,7 +1353,7 @@ st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
       /* compiling a new fragment shader variant added new state constants
        * into the constant buffer, we need to update them
        */
-      st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT);
    }
 
    {
@@ -1738,7 +1738,7 @@ st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
       /* compiling a new fragment shader variant added new state constants
        * into the constant buffer, we need to update them
        */
-      st_upload_constants(st, st->fp, MESA_SHADER_FRAGMENT);
+      st_upload_constants(st, ctx->FragmentProgram._Current, MESA_SHADER_FRAGMENT);
    } else if (type == GL_DEPTH) {
       rbRead = ctx->ReadBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
       driver_fp = get_drawpix_z_stencil_program(st, GL_TRUE, GL_FALSE);
diff --git a/src/mesa/state_tracker/st_cb_feedback.c b/src/mesa/state_tracker/st_cb_feedback.c
index ec62a0a077be..a070c4c3d5b1 100644
--- a/src/mesa/state_tracker/st_cb_feedback.c
+++ b/src/mesa/state_tracker/st_cb_feedback.c
@@ -86,8 +86,8 @@ static void
 feedback_vertex(struct gl_context *ctx, const struct draw_context *draw,
                 const struct vertex_header *v)
 {
-   const struct st_context *st = st_context(ctx);
-   struct gl_vertex_program *stvp = (struct gl_vertex_program *)st->vp;
+   struct gl_vertex_program *stvp =
+      (struct gl_vertex_program *)ctx->VertexProgram._Current;
    GLfloat win[4];
    const GLfloat *color, *texcoord;
    ubyte slot;
diff --git a/src/mesa/state_tracker/st_cb_rasterpos.c b/src/mesa/state_tracker/st_cb_rasterpos.c
index 044b60d7cbb0..6f381386a601 100644
--- a/src/mesa/state_tracker/st_cb_rasterpos.c
+++ b/src/mesa/state_tracker/st_cb_rasterpos.c
@@ -141,9 +141,9 @@ rastpos_point(struct draw_stage *stage, struct prim_header *prim)
 {
    struct rastpos_stage *rs = rastpos_stage(stage);
    struct gl_context *ctx = rs->ctx;
-   struct st_context *st = st_context(ctx);
    const GLfloat height = (GLfloat) ctx->DrawBuffer->Height;
-   struct gl_vertex_program *stvp = (struct gl_vertex_program *)st->vp;
+   struct gl_vertex_program *stvp =
+      (struct gl_vertex_program *)ctx->VertexProgram._Current;
    const ubyte *outputMapping = stvp->result_to_output;
    const GLfloat *pos;
    GLuint i;
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index ebadabf9503c..af0202ed8b96 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -101,7 +101,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st->pipe;
    struct draw_context *draw = st_get_draw_context(st);
-   const struct gl_vertex_program *vp;
+   struct gl_vertex_program *vp;
    struct st_common_variant *vp_variant;
    struct pipe_vertex_buffer vbuffers[PIPE_MAX_SHADER_INPUTS];
    unsigned num_vbuffers = 0;
@@ -130,8 +130,8 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    memcpy(&key, &st->vp_variant->key, sizeof(key));
    key.is_draw_shader = true;
 
-   vp = (struct gl_vertex_program *)st->vp;
-   vp_variant = st_get_common_variant(st, st->vp, &key);
+   vp = (struct gl_vertex_program *)ctx->VertexProgram._Current;
+   vp_variant = st_get_common_variant(st, &vp->Base, &key);
 
    /*
     * Set up the draw module's state.
@@ -186,7 +186,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    }
 
    /* set constant buffer 0 */
-   struct gl_program_parameter_list *params = st->vp->Parameters;
+   struct gl_program_parameter_list *params = vp->Base.Parameters;
 
    /* Update the constants which come from fixed-function state, such as
     * transformation matrices, fog factors, etc.
diff --git a/src/mesa/state_tracker/st_draw_hw_select.c b/src/mesa/state_tracker/st_draw_hw_select.c
index 38da7c5ca401..e802d2bbfb04 100644
--- a/src/mesa/state_tracker/st_draw_hw_select.c
+++ b/src/mesa/state_tracker/st_draw_hw_select.c
@@ -659,7 +659,9 @@ bool
 st_draw_hw_select_prepare_common(struct gl_context *ctx)
 {
    struct st_context *st = st_context(ctx);
-   if (st->gp || st->tcp || st->tep) {
+   if (ctx->GeometryProgram._Current ||
+       ctx->TessCtrlProgram._Current ||
+       ctx->TessEvalProgram._Current) {
       fprintf(stderr, "HW GL_SELECT does not support user geometry/tessellation shader\n");
       return false;
    }
@@ -736,7 +738,7 @@ make_state_key(struct gl_context *ctx, int mode)
    }
 
    /* TODO: support gl_ClipDistance/gl_CullDistance, but it costs more regs */
-   struct gl_program *vp = ctx->st->vp;
+   struct gl_program *vp = ctx->VertexProgram._Current;
    if (vp->info.clip_distance_array_size || vp->info.cull_distance_array_size) {
       fprintf(stderr, "HW GL_SELECT does not support gl_ClipDistance/gl_CullDistance\n");
       return (union state_key){0};
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index d041d60addd7..de1cc4efebc2 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -1311,7 +1311,22 @@ st_serialize_nir(struct gl_program *prog)
 void
 st_finalize_program(struct st_context *st, struct gl_program *prog)
 {
-   if (st->current_program[prog->info.stage] == prog) {
+   bool is_bound = false;
+
+   if (prog->info.stage == MESA_SHADER_VERTEX)
+      is_bound = prog == st->ctx->VertexProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_TESS_CTRL)
+      is_bound = prog == st->ctx->TessCtrlProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_TESS_EVAL)
+      is_bound = prog == st->ctx->TessEvalProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_GEOMETRY)
+      is_bound = prog == st->ctx->GeometryProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_FRAGMENT)
+      is_bound = prog == st->ctx->FragmentProgram._Current;
+   else if (prog->info.stage == MESA_SHADER_COMPUTE)
+      is_bound = prog == st->ctx->ComputeProgram._Current;
+
+   if (is_bound) {
       if (prog->info.stage == MESA_SHADER_VERTEX) {
          st->ctx->Array.NewVertexElements = true;
          st->dirty |= ST_NEW_VERTEX_PROGRAM(st->ctx, prog);
-- 
GitLab

