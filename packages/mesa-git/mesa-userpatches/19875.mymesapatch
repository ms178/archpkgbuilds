From 8c4573781c5a4e5bf60810794bd2f71f242c3204 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Fri, 4 Nov 2022 21:03:08 +0800
Subject: [PATCH 1/6] loader: fixes -Werror,-Wdeprecated-non-prototype for
 clang-15 in pipe-loader

There are multiple error messages, show one of them:
../../src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c:219:54: error: passing arguments to a function without a prototype is deprecated in
all versions of C and is not supported in C2x [-Werror,-Wdeprecated-non-prototype]
         sdev->ws = sdev->dd->winsys[i].create_winsys(drisw_lf);
                                                     ^

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c | 8 ++++----
 src/gallium/include/frontend/sw_driver.h           | 8 +++++++-
 src/gallium/targets/pipe-loader/pipe_swrast.c      | 6 +++---
 3 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c b/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c
index 12bc79305573..758d7cb33f91 100644
--- a/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c
+++ b/src/gallium/auxiliary/pipe-loader/pipe_loader_sw.c
@@ -216,7 +216,7 @@ pipe_loader_sw_probe_dri(struct pipe_loader_device **devs, const struct drisw_lo
 
    for (i = 0; sdev->dd->winsys[i].name; i++) {
       if (strcmp(sdev->dd->winsys[i].name, "dri") == 0) {
-         sdev->ws = sdev->dd->winsys[i].create_winsys(drisw_lf);
+         sdev->ws = sdev->dd->winsys[i].create_winsys_dri(drisw_lf);
          break;
       }
    }
@@ -246,7 +246,7 @@ pipe_loader_vk_probe_dri(struct pipe_loader_device **devs, const struct drisw_lo
 
    for (i = 0; sdev->dd->winsys[i].name; i++) {
       if (strcmp(sdev->dd->winsys[i].name, "dri") == 0) {
-         sdev->ws = sdev->dd->winsys[i].create_winsys(drisw_lf);
+         sdev->ws = sdev->dd->winsys[i].create_winsys_dri(drisw_lf);
          break;
       }
    }
@@ -282,7 +282,7 @@ pipe_loader_sw_probe_kms(struct pipe_loader_device **devs, int fd)
 
    for (i = 0; sdev->dd->winsys[i].name; i++) {
       if (strcmp(sdev->dd->winsys[i].name, "kms_dri") == 0) {
-         sdev->ws = sdev->dd->winsys[i].create_winsys(sdev->fd);
+         sdev->ws = sdev->dd->winsys[i].create_winsys_kms_dri(sdev->fd);
          break;
       }
    }
@@ -360,7 +360,7 @@ pipe_loader_sw_probe_wrapped(struct pipe_loader_device **dev,
 
    for (i = 0; sdev->dd->winsys[i].name; i++) {
       if (strcmp(sdev->dd->winsys[i].name, "wrapped") == 0) {
-         sdev->ws = sdev->dd->winsys[i].create_winsys(screen);
+         sdev->ws = sdev->dd->winsys[i].create_winsys_wrapped(screen);
          break;
       }
    }
diff --git a/src/gallium/include/frontend/sw_driver.h b/src/gallium/include/frontend/sw_driver.h
index d2cb33845f2b..6223ff9f0eff 100644
--- a/src/gallium/include/frontend/sw_driver.h
+++ b/src/gallium/include/frontend/sw_driver.h
@@ -6,13 +6,19 @@
 
 struct pipe_screen;
 struct sw_winsys;
+struct drisw_loader_funcs;
 
 struct sw_driver_descriptor
 {
    struct pipe_screen *(*create_screen)(struct sw_winsys *ws, const struct pipe_screen_config *config, bool sw_vk);
    struct {
        const char * const name;
-       struct sw_winsys *(*create_winsys)();
+       union {
+         struct sw_winsys *(*create_winsys)();
+         struct sw_winsys *(*create_winsys_wrapped)(struct pipe_screen *screen);
+         struct sw_winsys *(*create_winsys_dri)(const struct drisw_loader_funcs *lf);
+         struct sw_winsys *(*create_winsys_kms_dri)(int fd);
+       };
    } winsys[];
 };
 
diff --git a/src/gallium/targets/pipe-loader/pipe_swrast.c b/src/gallium/targets/pipe-loader/pipe_swrast.c
index bb353b1913ab..583dc3ad705d 100644
--- a/src/gallium/targets/pipe-loader/pipe_swrast.c
+++ b/src/gallium/targets/pipe-loader/pipe_swrast.c
@@ -29,13 +29,13 @@ const struct sw_driver_descriptor swrast_driver_descriptor = {
 #ifdef HAVE_DRI
       {
          .name = "dri",
-         .create_winsys = dri_create_sw_winsys,
+         .create_winsys_dri = dri_create_sw_winsys,
       },
 #endif
 #ifdef HAVE_DRISW_KMS
       {
          .name = "kms_dri",
-         .create_winsys = kms_dri_create_winsys,
+         .create_winsys_kms_dri = kms_dri_create_winsys,
       },
 #endif
       {
@@ -44,7 +44,7 @@ const struct sw_driver_descriptor swrast_driver_descriptor = {
       },
       {
          .name = "wrapped",
-         .create_winsys = wrapper_sw_winsys_wrap_pipe_screen,
+         .create_winsys_wrapped = wrapper_sw_winsys_wrap_pipe_screen,
       },
       { 0 },
    }
-- 
GitLab


From 86e23e0a64b4162efb3f80b038610b3d5da09933 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Fri, 4 Nov 2022 19:31:47 +0800
Subject: [PATCH 2/6] panvk: Fixes -Werror,-Wunused-but-set-variable for
 clang-15 in panvk_descriptor_set.c

../../src/panfrost/vulkan/panvk_descriptor_set.c:67:13: error: variable 'dynoffset_idx' set but not used [-Werror,-Wunused-but-set-variable]
   unsigned dynoffset_idx = 0, img_idx = 0;
            ^

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/panfrost/vulkan/panvk_descriptor_set.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/panfrost/vulkan/panvk_descriptor_set.c b/src/panfrost/vulkan/panvk_descriptor_set.c
index bb9c5e7dbab3..a67eaf8bbd41 100644
--- a/src/panfrost/vulkan/panvk_descriptor_set.c
+++ b/src/panfrost/vulkan/panvk_descriptor_set.c
@@ -64,7 +64,8 @@ panvk_GetDescriptorSetLayoutSupport(VkDevice _device,
    }
 
    unsigned sampler_idx = 0, tex_idx = 0, ubo_idx = 0;
-   unsigned dynoffset_idx = 0, img_idx = 0;
+   unsigned img_idx = 0;
+   UNUSED unsigned dynoffset_idx = 0;
 
    for (unsigned i = 0; i < pCreateInfo->bindingCount; i++) {
       const VkDescriptorSetLayoutBinding *binding = &bindings[i];
-- 
GitLab


From 3ced102af6edb8d733f2f5e4bd311e0fe2eda8f6 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Wed, 23 Nov 2022 00:34:35 +0800
Subject: [PATCH 3/6] glsl: Fixes ident issue in glsl_parser.yy and update
 editorconfig for it

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 .editorconfig                    |  2 +-
 src/compiler/glsl/glsl_parser.yy | 10 +++++-----
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/.editorconfig b/.editorconfig
index 6f7d47e90b39..3c6b234f1826 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -8,7 +8,7 @@ charset = utf-8
 insert_final_newline = true
 tab_width = 8
 
-[*.{c,h,cpp,hpp,cc,hh,y}]
+[*.{c,h,cpp,hpp,cc,hh,y,yy}]
 indent_style = space
 indent_size = 3
 max_line_length = 78
diff --git a/src/compiler/glsl/glsl_parser.yy b/src/compiler/glsl/glsl_parser.yy
index f887cdb247bf..428ff53cd318 100644
--- a/src/compiler/glsl/glsl_parser.yy
+++ b/src/compiler/glsl/glsl_parser.yy
@@ -1438,10 +1438,10 @@ layout_qualifier_id:
                                 "valid in fragment shaders");
             }
 
-	    if (state->INTEL_conservative_rasterization_enable) {
-	       $$.flags.q.inner_coverage = 1;
-	    } else {
-	       _mesa_glsl_error(& @1, state,
+            if (state->INTEL_conservative_rasterization_enable) {
+               $$.flags.q.inner_coverage = 1;
+            } else {
+               _mesa_glsl_error(& @1, state,
                                 "inner_coverage layout qualifier present, "
                                 "but the INTEL_conservative_rasterization extension "
                                 "is not enabled.");
@@ -1456,7 +1456,7 @@ layout_qualifier_id:
             }
 
             if (state->ARB_post_depth_coverage_enable ||
-		state->INTEL_conservative_rasterization_enable) {
+                state->INTEL_conservative_rasterization_enable) {
                $$.flags.q.post_depth_coverage = 1;
             } else {
                _mesa_glsl_error(& @1, state,
-- 
GitLab


From 8cc91cc9f548b5c5a2350f5f7eb367bd03f7a275 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Wed, 23 Nov 2022 00:37:28 +0800
Subject: [PATCH 4/6] glsl: replace tab with 3 space in glcpp-parse.y

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/compiler/glsl/glcpp/glcpp-parse.y | 1120 ++++++++++++-------------
 1 file changed, 560 insertions(+), 560 deletions(-)

diff --git a/src/compiler/glsl/glcpp/glcpp-parse.y b/src/compiler/glsl/glcpp/glcpp-parse.y
index ab0fd6076c41..dba582fa1c8e 100644
--- a/src/compiler/glsl/glcpp/glcpp-parse.y
+++ b/src/compiler/glsl/glcpp/glcpp-parse.y
@@ -218,87 +218,87 @@ add_builtin_define(glcpp_parser_t *parser, const char *name, int value);
 %%
 
 input:
-	/* empty */
-|	input line
+   /* empty */
+|   input line
 ;
 
 line:
-	control_line
-|	SPACE control_line
-|	text_line {
-		_glcpp_parser_print_expanded_token_list (parser, $1);
-		_mesa_string_buffer_append_char(parser->output, '\n');
-	}
-|	expanded_line
+   control_line
+|   SPACE control_line
+|   text_line {
+      _glcpp_parser_print_expanded_token_list (parser, $1);
+      _mesa_string_buffer_append_char(parser->output, '\n');
+   }
+|   expanded_line
 ;
 
 expanded_line:
-	IF_EXPANDED expression NEWLINE {
-		if (parser->is_gles && $2.undefined_macro)
-			glcpp_error(& @1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
-		_glcpp_parser_skip_stack_push_if (parser, & @1, $2.value);
-	}
-|	ELIF_EXPANDED expression NEWLINE {
-		if (parser->is_gles && $2.undefined_macro)
-			glcpp_error(& @1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
-		_glcpp_parser_skip_stack_change_if (parser, & @1, "elif", $2.value);
-	}
-|	LINE_EXPANDED integer_constant NEWLINE {
-		parser->has_new_line_number = 1;
-		parser->new_line_number = $2;
-		_mesa_string_buffer_printf(parser->output, "#line %" PRIiMAX "\n", $2);
-	}
-|	LINE_EXPANDED integer_constant integer_constant NEWLINE {
-		parser->has_new_line_number = 1;
-		parser->new_line_number = $2;
-		parser->has_new_source_number = 1;
-		parser->new_source_number = $3;
-		_mesa_string_buffer_printf(parser->output,
-					   "#line %" PRIiMAX " %" PRIiMAX "\n",
-					    $2, $3);
-	}
-|	LINE_EXPANDED integer_constant PATH NEWLINE {
-		parser->has_new_line_number = 1;
-		parser->new_line_number = $2;
-		_mesa_string_buffer_printf(parser->output,
-					   "#line %" PRIiMAX " %s\n",
-					    $2, $3);
-	}
+   IF_EXPANDED expression NEWLINE {
+      if (parser->is_gles && $2.undefined_macro)
+         glcpp_error(& @1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
+      _glcpp_parser_skip_stack_push_if (parser, & @1, $2.value);
+   }
+|   ELIF_EXPANDED expression NEWLINE {
+      if (parser->is_gles && $2.undefined_macro)
+         glcpp_error(& @1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
+      _glcpp_parser_skip_stack_change_if (parser, & @1, "elif", $2.value);
+   }
+|   LINE_EXPANDED integer_constant NEWLINE {
+      parser->has_new_line_number = 1;
+      parser->new_line_number = $2;
+      _mesa_string_buffer_printf(parser->output, "#line %" PRIiMAX "\n", $2);
+   }
+|   LINE_EXPANDED integer_constant integer_constant NEWLINE {
+      parser->has_new_line_number = 1;
+      parser->new_line_number = $2;
+      parser->has_new_source_number = 1;
+      parser->new_source_number = $3;
+      _mesa_string_buffer_printf(parser->output,
+                  "#line %" PRIiMAX " %" PRIiMAX "\n",
+                   $2, $3);
+   }
+|   LINE_EXPANDED integer_constant PATH NEWLINE {
+      parser->has_new_line_number = 1;
+      parser->new_line_number = $2;
+      _mesa_string_buffer_printf(parser->output,
+                  "#line %" PRIiMAX " %s\n",
+                   $2, $3);
+   }
 ;
 
 define:
-	OBJ_IDENTIFIER replacement_list NEWLINE {
-		_define_object_macro (parser, & @1, $1, $2);
-	}
-|	FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
-		_define_function_macro (parser, & @1, $1, NULL, $4);
-	}
-|	FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
-		_define_function_macro (parser, & @1, $1, $3, $5);
-	}
+   OBJ_IDENTIFIER replacement_list NEWLINE {
+      _define_object_macro (parser, & @1, $1, $2);
+   }
+|   FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
+      _define_function_macro (parser, & @1, $1, NULL, $4);
+   }
+|   FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
+      _define_function_macro (parser, & @1, $1, $3, $5);
+   }
 ;
 
 control_line:
-	control_line_success {
-		_mesa_string_buffer_append_char(parser->output, '\n');
-	}
-|	control_line_error
-|	HASH_TOKEN LINE pp_tokens NEWLINE {
-
-		if (parser->skip_stack == NULL ||
-		    parser->skip_stack->type == SKIP_NO_SKIP)
-		{
-			_glcpp_parser_expand_and_lex_from (parser,
-							   LINE_EXPANDED, $3,
-							   EXPANSION_MODE_IGNORE_DEFINED);
-		}
-	}
+   control_line_success {
+      _mesa_string_buffer_append_char(parser->output, '\n');
+   }
+|   control_line_error
+|   HASH_TOKEN LINE pp_tokens NEWLINE {
+
+      if (parser->skip_stack == NULL ||
+          parser->skip_stack->type == SKIP_NO_SKIP)
+      {
+         _glcpp_parser_expand_and_lex_from (parser,
+                        LINE_EXPANDED, $3,
+                        EXPANSION_MODE_IGNORE_DEFINED);
+      }
+   }
 ;
 
 control_line_success:
-	HASH_TOKEN DEFINE_TOKEN define
-|	HASH_TOKEN UNDEF IDENTIFIER NEWLINE {
-		struct hash_entry *entry;
+   HASH_TOKEN DEFINE_TOKEN define
+|   HASH_TOKEN UNDEF IDENTIFIER NEWLINE {
+      struct hash_entry *entry;
 
                 /* Section 3.4 (Preprocessor) of the GLSL ES 3.00 spec says:
                  *
@@ -322,549 +322,549 @@ control_line_success:
                  *
                  * The code below implements the same checks as GLSLang.
                  */
-		if (strncmp("GL_", $3, 3) == 0)
-			glcpp_error(& @1, parser, "Built-in (pre-defined)"
-				    " names beginning with GL_ cannot be undefined.");
-		else if (strstr($3, "__") != NULL) {
-			if (parser->is_gles
-			    && parser->version >= 300
-			    && (strcmp("__LINE__", $3) == 0
-				|| strcmp("__FILE__", $3) == 0
-				|| strcmp("__VERSION__", $3) == 0)) {
-				glcpp_error(& @1, parser, "Built-in (pre-defined)"
-					    " names cannot be undefined.");
-			} else if (parser->is_gles && parser->version <= 300) {
-				glcpp_error(& @1, parser,
-					    " names containing consecutive underscores"
-					    " are reserved.");
-			} else {
-				glcpp_warning(& @1, parser,
-					      " names containing consecutive underscores"
-					      " are reserved.");
-			}
-		}
-
-		entry = _mesa_hash_table_search (parser->defines, $3);
-		if (entry) {
-			_mesa_hash_table_remove (parser->defines, entry);
-		}
-	}
-|	HASH_TOKEN INCLUDE NEWLINE {
-		size_t include_cursor = _mesa_get_shader_include_cursor(parser->gl_ctx->Shared);
-
-		/* Remove leading and trailing "" or <> */
-		char *start = strchr($2, '"');
-		if (!start) {
-			_mesa_set_shader_include_cursor(parser->gl_ctx->Shared, 0);
-			start = strchr($2, '<');
-		}
-		char *path = strndup(start + 1, strlen(start + 1) - 1);
-
-		const char *shader =
-			_mesa_lookup_shader_include(parser->gl_ctx, path, false);
-		free(path);
-
-		if (!shader)
-			glcpp_error(&@1, parser, "%s not found", $2);
-		else {
-			/* Create a temporary parser with the same settings */
-			glcpp_parser_t *tmp_parser =
-				glcpp_parser_create(parser->gl_ctx, parser->extensions, parser->state);
-			tmp_parser->version_set = true;
-			tmp_parser->version = parser->version;
-
-			/* Set the shader source and run the lexer */
-			glcpp_lex_set_source_string(tmp_parser, shader);
-
-			/* Copy any existing define macros to the temporary
-			 * shade include parser.
-			 */
-			struct define_include di;
-			di.parser = tmp_parser;
-			di.loc = &@1;
-
-			hash_table_call_foreach(parser->defines,
-						glcpp_parser_copy_defines,
-						&di);
-
-			/* Print out '#include' to the glsl parser. We do this
-			 * so that it can do the error checking require to
-			 * make sure the ARB_shading_language_include
-			 * extension is enabled.
-			 */
-			_mesa_string_buffer_printf(parser->output, "#include\n");
-
-			/* Parse the include string before adding to the
-			 * preprocessor output.
-			 */
-			glcpp_parser_parse(tmp_parser);
-			_mesa_string_buffer_printf(parser->info_log, "%s",
-						   tmp_parser->info_log->buf);
-			_mesa_string_buffer_printf(parser->output, "%s",
-						   tmp_parser->output->buf);
-
-			/* Copy any new define macros to the parent parser
-			 * and steal the memory of our temp parser so we don't
-			 * free these new defines before they are no longer
-			 * needed.
-			 */
-			di.parser = parser;
-			di.loc = &@1;
-			ralloc_steal(parser, tmp_parser);
-
-			hash_table_call_foreach(tmp_parser->defines,
-						glcpp_parser_copy_defines,
-						&di);
-
-			/* Destroy tmp parser memory we no longer need */
-			glcpp_lex_destroy(tmp_parser->scanner);
-			_mesa_hash_table_destroy(tmp_parser->defines, NULL);
-		}
-
-		_mesa_set_shader_include_cursor(parser->gl_ctx->Shared, include_cursor);
-	}
-|	HASH_TOKEN IF pp_tokens NEWLINE {
-		/* Be careful to only evaluate the 'if' expression if
-		 * we are not skipping. When we are skipping, we
-		 * simply push a new 0-valued 'if' onto the skip
-		 * stack.
-		 *
-		 * This avoids generating diagnostics for invalid
-		 * expressions that are being skipped. */
-		if (parser->skip_stack == NULL ||
-		    parser->skip_stack->type == SKIP_NO_SKIP)
-		{
-			_glcpp_parser_expand_and_lex_from (parser,
-							   IF_EXPANDED, $3,
-							   EXPANSION_MODE_EVALUATE_DEFINED);
-		}	
-		else
-		{
-			_glcpp_parser_skip_stack_push_if (parser, & @1, 0);
-			parser->skip_stack->type = SKIP_TO_ENDIF;
-		}
-	}
-|	HASH_TOKEN IF NEWLINE {
-		/* #if without an expression is only an error if we
-		 *  are not skipping */
-		if (parser->skip_stack == NULL ||
-		    parser->skip_stack->type == SKIP_NO_SKIP)
-		{
-			glcpp_error(& @1, parser, "#if with no expression");
-		}	
-		_glcpp_parser_skip_stack_push_if (parser, & @1, 0);
-	}
-|	HASH_TOKEN IFDEF IDENTIFIER junk NEWLINE {
-		struct hash_entry *entry =
-				_mesa_hash_table_search(parser->defines, $3);
-		macro_t *macro = entry ? entry->data : NULL;
-		_glcpp_parser_skip_stack_push_if (parser, & @1, macro != NULL);
-	}
-|	HASH_TOKEN IFNDEF IDENTIFIER junk NEWLINE {
-		struct hash_entry *entry =
-				_mesa_hash_table_search(parser->defines, $3);
-		macro_t *macro = entry ? entry->data : NULL;
-		_glcpp_parser_skip_stack_push_if (parser, & @3, macro == NULL);
-	}
-|	HASH_TOKEN ELIF pp_tokens NEWLINE {
-		/* Be careful to only evaluate the 'elif' expression
-		 * if we are not skipping. When we are skipping, we
-		 * simply change to a 0-valued 'elif' on the skip
-		 * stack.
-		 *
-		 * This avoids generating diagnostics for invalid
-		 * expressions that are being skipped. */
-		if (parser->skip_stack &&
-		    parser->skip_stack->type == SKIP_TO_ELSE)
-		{
-			_glcpp_parser_expand_and_lex_from (parser,
-							   ELIF_EXPANDED, $3,
-							   EXPANSION_MODE_EVALUATE_DEFINED);
-		}
-		else if (parser->skip_stack &&
-		    parser->skip_stack->has_else)
-		{
-			glcpp_error(& @1, parser, "#elif after #else");
-		}
-		else
-		{
-			_glcpp_parser_skip_stack_change_if (parser, & @1,
-							    "elif", 0);
-		}
-	}
-|	HASH_TOKEN ELIF NEWLINE {
-		/* #elif without an expression is an error unless we
-		 * are skipping. */
-		if (parser->skip_stack &&
-		    parser->skip_stack->type == SKIP_TO_ELSE)
-		{
-			glcpp_error(& @1, parser, "#elif with no expression");
-		}
-		else if (parser->skip_stack &&
-		    parser->skip_stack->has_else)
-		{
-			glcpp_error(& @1, parser, "#elif after #else");
-		}
-		else
-		{
-			_glcpp_parser_skip_stack_change_if (parser, & @1,
-							    "elif", 0);
-			glcpp_warning(& @1, parser, "ignoring illegal #elif without expression");
-		}
-	}
-|	HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
-		if (parser->skip_stack &&
-		    parser->skip_stack->has_else)
-		{
-			glcpp_error(& @1, parser, "multiple #else");
-		}
-		else
-		{
-			_glcpp_parser_skip_stack_change_if (parser, & @1, "else", 1);
-			if (parser->skip_stack)
-				parser->skip_stack->has_else = true;
-		}
-	}
-|	HASH_TOKEN ENDIF {
-		_glcpp_parser_skip_stack_pop (parser, & @1);
-	} NEWLINE
-|	HASH_TOKEN VERSION_TOKEN version_constant NEWLINE {
-		if (parser->version_set) {
-			glcpp_error(& @1, parser, "#version must appear on the first line");
-		}
-		_glcpp_parser_handle_version_declaration(parser, $3, NULL, true);
-	}
-|	HASH_TOKEN VERSION_TOKEN version_constant IDENTIFIER NEWLINE {
-		if (parser->version_set) {
-			glcpp_error(& @1, parser, "#version must appear on the first line");
-		}
-		_glcpp_parser_handle_version_declaration(parser, $3, $4, true);
-	}
-|	HASH_TOKEN NEWLINE {
-		glcpp_parser_resolve_implicit_version(parser);
-	}
-|	HASH_TOKEN PRAGMA NEWLINE {
-		_mesa_string_buffer_printf(parser->output, "#%s", $2);
-	}
+      if (strncmp("GL_", $3, 3) == 0)
+         glcpp_error(& @1, parser, "Built-in (pre-defined)"
+                " names beginning with GL_ cannot be undefined.");
+      else if (strstr($3, "__") != NULL) {
+         if (parser->is_gles
+             && parser->version >= 300
+             && (strcmp("__LINE__", $3) == 0
+            || strcmp("__FILE__", $3) == 0
+            || strcmp("__VERSION__", $3) == 0)) {
+            glcpp_error(& @1, parser, "Built-in (pre-defined)"
+                   " names cannot be undefined.");
+         } else if (parser->is_gles && parser->version <= 300) {
+            glcpp_error(& @1, parser,
+                   " names containing consecutive underscores"
+                   " are reserved.");
+         } else {
+            glcpp_warning(& @1, parser,
+                     " names containing consecutive underscores"
+                     " are reserved.");
+         }
+      }
+
+      entry = _mesa_hash_table_search (parser->defines, $3);
+      if (entry) {
+         _mesa_hash_table_remove (parser->defines, entry);
+      }
+   }
+|   HASH_TOKEN INCLUDE NEWLINE {
+      size_t include_cursor = _mesa_get_shader_include_cursor(parser->gl_ctx->Shared);
+
+      /* Remove leading and trailing "" or <> */
+      char *start = strchr($2, '"');
+      if (!start) {
+         _mesa_set_shader_include_cursor(parser->gl_ctx->Shared, 0);
+         start = strchr($2, '<');
+      }
+      char *path = strndup(start + 1, strlen(start + 1) - 1);
+
+      const char *shader =
+         _mesa_lookup_shader_include(parser->gl_ctx, path, false);
+      free(path);
+
+      if (!shader)
+         glcpp_error(&@1, parser, "%s not found", $2);
+      else {
+         /* Create a temporary parser with the same settings */
+         glcpp_parser_t *tmp_parser =
+            glcpp_parser_create(parser->gl_ctx, parser->extensions, parser->state);
+         tmp_parser->version_set = true;
+         tmp_parser->version = parser->version;
+
+         /* Set the shader source and run the lexer */
+         glcpp_lex_set_source_string(tmp_parser, shader);
+
+         /* Copy any existing define macros to the temporary
+          * shade include parser.
+          */
+         struct define_include di;
+         di.parser = tmp_parser;
+         di.loc = &@1;
+
+         hash_table_call_foreach(parser->defines,
+                  glcpp_parser_copy_defines,
+                  &di);
+
+         /* Print out '#include' to the glsl parser. We do this
+          * so that it can do the error checking require to
+          * make sure the ARB_shading_language_include
+          * extension is enabled.
+          */
+         _mesa_string_buffer_printf(parser->output, "#include\n");
+
+         /* Parse the include string before adding to the
+          * preprocessor output.
+          */
+         glcpp_parser_parse(tmp_parser);
+         _mesa_string_buffer_printf(parser->info_log, "%s",
+                     tmp_parser->info_log->buf);
+         _mesa_string_buffer_printf(parser->output, "%s",
+                     tmp_parser->output->buf);
+
+         /* Copy any new define macros to the parent parser
+          * and steal the memory of our temp parser so we don't
+          * free these new defines before they are no longer
+          * needed.
+          */
+         di.parser = parser;
+         di.loc = &@1;
+         ralloc_steal(parser, tmp_parser);
+
+         hash_table_call_foreach(tmp_parser->defines,
+                  glcpp_parser_copy_defines,
+                  &di);
+
+         /* Destroy tmp parser memory we no longer need */
+         glcpp_lex_destroy(tmp_parser->scanner);
+         _mesa_hash_table_destroy(tmp_parser->defines, NULL);
+      }
+
+      _mesa_set_shader_include_cursor(parser->gl_ctx->Shared, include_cursor);
+   }
+|   HASH_TOKEN IF pp_tokens NEWLINE {
+      /* Be careful to only evaluate the 'if' expression if
+       * we are not skipping. When we are skipping, we
+       * simply push a new 0-valued 'if' onto the skip
+       * stack.
+       *
+       * This avoids generating diagnostics for invalid
+       * expressions that are being skipped. */
+      if (parser->skip_stack == NULL ||
+          parser->skip_stack->type == SKIP_NO_SKIP)
+      {
+         _glcpp_parser_expand_and_lex_from (parser,
+                        IF_EXPANDED, $3,
+                        EXPANSION_MODE_EVALUATE_DEFINED);
+      }   
+      else
+      {
+         _glcpp_parser_skip_stack_push_if (parser, & @1, 0);
+         parser->skip_stack->type = SKIP_TO_ENDIF;
+      }
+   }
+|   HASH_TOKEN IF NEWLINE {
+      /* #if without an expression is only an error if we
+       *  are not skipping */
+      if (parser->skip_stack == NULL ||
+          parser->skip_stack->type == SKIP_NO_SKIP)
+      {
+         glcpp_error(& @1, parser, "#if with no expression");
+      }   
+      _glcpp_parser_skip_stack_push_if (parser, & @1, 0);
+   }
+|   HASH_TOKEN IFDEF IDENTIFIER junk NEWLINE {
+      struct hash_entry *entry =
+            _mesa_hash_table_search(parser->defines, $3);
+      macro_t *macro = entry ? entry->data : NULL;
+      _glcpp_parser_skip_stack_push_if (parser, & @1, macro != NULL);
+   }
+|   HASH_TOKEN IFNDEF IDENTIFIER junk NEWLINE {
+      struct hash_entry *entry =
+            _mesa_hash_table_search(parser->defines, $3);
+      macro_t *macro = entry ? entry->data : NULL;
+      _glcpp_parser_skip_stack_push_if (parser, & @3, macro == NULL);
+   }
+|   HASH_TOKEN ELIF pp_tokens NEWLINE {
+      /* Be careful to only evaluate the 'elif' expression
+       * if we are not skipping. When we are skipping, we
+       * simply change to a 0-valued 'elif' on the skip
+       * stack.
+       *
+       * This avoids generating diagnostics for invalid
+       * expressions that are being skipped. */
+      if (parser->skip_stack &&
+          parser->skip_stack->type == SKIP_TO_ELSE)
+      {
+         _glcpp_parser_expand_and_lex_from (parser,
+                        ELIF_EXPANDED, $3,
+                        EXPANSION_MODE_EVALUATE_DEFINED);
+      }
+      else if (parser->skip_stack &&
+          parser->skip_stack->has_else)
+      {
+         glcpp_error(& @1, parser, "#elif after #else");
+      }
+      else
+      {
+         _glcpp_parser_skip_stack_change_if (parser, & @1,
+                         "elif", 0);
+      }
+   }
+|   HASH_TOKEN ELIF NEWLINE {
+      /* #elif without an expression is an error unless we
+       * are skipping. */
+      if (parser->skip_stack &&
+          parser->skip_stack->type == SKIP_TO_ELSE)
+      {
+         glcpp_error(& @1, parser, "#elif with no expression");
+      }
+      else if (parser->skip_stack &&
+          parser->skip_stack->has_else)
+      {
+         glcpp_error(& @1, parser, "#elif after #else");
+      }
+      else
+      {
+         _glcpp_parser_skip_stack_change_if (parser, & @1,
+                         "elif", 0);
+         glcpp_warning(& @1, parser, "ignoring illegal #elif without expression");
+      }
+   }
+|   HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
+      if (parser->skip_stack &&
+          parser->skip_stack->has_else)
+      {
+         glcpp_error(& @1, parser, "multiple #else");
+      }
+      else
+      {
+         _glcpp_parser_skip_stack_change_if (parser, & @1, "else", 1);
+         if (parser->skip_stack)
+            parser->skip_stack->has_else = true;
+      }
+   }
+|   HASH_TOKEN ENDIF {
+      _glcpp_parser_skip_stack_pop (parser, & @1);
+   } NEWLINE
+|   HASH_TOKEN VERSION_TOKEN version_constant NEWLINE {
+      if (parser->version_set) {
+         glcpp_error(& @1, parser, "#version must appear on the first line");
+      }
+      _glcpp_parser_handle_version_declaration(parser, $3, NULL, true);
+   }
+|   HASH_TOKEN VERSION_TOKEN version_constant IDENTIFIER NEWLINE {
+      if (parser->version_set) {
+         glcpp_error(& @1, parser, "#version must appear on the first line");
+      }
+      _glcpp_parser_handle_version_declaration(parser, $3, $4, true);
+   }
+|   HASH_TOKEN NEWLINE {
+      glcpp_parser_resolve_implicit_version(parser);
+   }
+|   HASH_TOKEN PRAGMA NEWLINE {
+      _mesa_string_buffer_printf(parser->output, "#%s", $2);
+   }
 ;
 
 control_line_error:
-	HASH_TOKEN ERROR_TOKEN NEWLINE {
-		glcpp_error(& @1, parser, "#%s", $2);
-	}
-|	HASH_TOKEN DEFINE_TOKEN NEWLINE {
-		glcpp_error (& @1, parser, "#define without macro name");
-	}
-|	HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
-		glcpp_error (& @1, parser, "Illegal non-directive after #");
-	}
+   HASH_TOKEN ERROR_TOKEN NEWLINE {
+      glcpp_error(& @1, parser, "#%s", $2);
+   }
+|   HASH_TOKEN DEFINE_TOKEN NEWLINE {
+      glcpp_error (& @1, parser, "#define without macro name");
+   }
+|   HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
+      glcpp_error (& @1, parser, "Illegal non-directive after #");
+   }
 ;
 
 integer_constant:
-	INTEGER_STRING {
-		/* let strtoll detect the base */
-		$$ = strtoll ($1, NULL, 0);
-	}
-|	INTEGER {
-		$$ = $1;
-	}
+   INTEGER_STRING {
+      /* let strtoll detect the base */
+      $$ = strtoll ($1, NULL, 0);
+   }
+|   INTEGER {
+      $$ = $1;
+   }
 
 version_constant:
-	INTEGER_STRING {
-	   /* Both octal and hexadecimal constants begin with 0. */
-	   if ($1[0] == '0' && $1[1] != '\0') {
-		glcpp_error(&@1, parser, "invalid #version \"%s\" (not a decimal constant)", $1);
-		$$ = 0;
-	   } else {
-		$$ = strtoll($1, NULL, 10);
-	   }
-	}
+   INTEGER_STRING {
+      /* Both octal and hexadecimal constants begin with 0. */
+      if ($1[0] == '0' && $1[1] != '\0') {
+      glcpp_error(&@1, parser, "invalid #version \"%s\" (not a decimal constant)", $1);
+      $$ = 0;
+      } else {
+      $$ = strtoll($1, NULL, 10);
+      }
+   }
 
 expression:
-	integer_constant {
-		$$.value = $1;
-		$$.undefined_macro = NULL;
-	}
-|	IDENTIFIER {
-		$$.value = 0;
-		if (parser->is_gles)
-			$$.undefined_macro = linear_strdup(parser->linalloc, $1);
-		else
-			$$.undefined_macro = NULL;
-	}
-|	expression OR expression {
-		$$.value = $1.value || $3.value;
-
-		/* Short-circuit: Only flag undefined from right side
-		 * if left side evaluates to false.
-		 */
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+   integer_constant {
+      $$.value = $1;
+      $$.undefined_macro = NULL;
+   }
+|   IDENTIFIER {
+      $$.value = 0;
+      if (parser->is_gles)
+         $$.undefined_macro = linear_strdup(parser->linalloc, $1);
+      else
+         $$.undefined_macro = NULL;
+   }
+|   expression OR expression {
+      $$.value = $1.value || $3.value;
+
+      /* Short-circuit: Only flag undefined from right side
+       * if left side evaluates to false.
+       */
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else if (! $1.value)
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression AND expression {
-		$$.value = $1.value && $3.value;
-
-		/* Short-circuit: Only flag undefined from right-side
-		 * if left side evaluates to true.
-		 */
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression AND expression {
+      $$.value = $1.value && $3.value;
+
+      /* Short-circuit: Only flag undefined from right-side
+       * if left side evaluates to true.
+       */
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else if ($1.value)
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '|' expression {
-		$$.value = $1.value | $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '|' expression {
+      $$.value = $1.value | $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '^' expression {
-		$$.value = $1.value ^ $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '^' expression {
+      $$.value = $1.value ^ $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '&' expression {
-		$$.value = $1.value & $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '&' expression {
+      $$.value = $1.value & $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression NOT_EQUAL expression {
-		$$.value = $1.value != $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression NOT_EQUAL expression {
+      $$.value = $1.value != $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression EQUAL expression {
-		$$.value = $1.value == $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression EQUAL expression {
+      $$.value = $1.value == $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression GREATER_OR_EQUAL expression {
-		$$.value = $1.value >= $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression GREATER_OR_EQUAL expression {
+      $$.value = $1.value >= $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression LESS_OR_EQUAL expression {
-		$$.value = $1.value <= $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression LESS_OR_EQUAL expression {
+      $$.value = $1.value <= $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '>' expression {
-		$$.value = $1.value > $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '>' expression {
+      $$.value = $1.value > $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '<' expression {
-		$$.value = $1.value < $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '<' expression {
+      $$.value = $1.value < $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression RIGHT_SHIFT expression {
-		$$.value = $1.value >> $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression RIGHT_SHIFT expression {
+      $$.value = $1.value >> $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression LEFT_SHIFT expression {
-		$$.value = $1.value << $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression LEFT_SHIFT expression {
+      $$.value = $1.value << $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '-' expression {
-		$$.value = $1.value - $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '-' expression {
+      $$.value = $1.value - $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '+' expression {
-		$$.value = $1.value + $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '+' expression {
+      $$.value = $1.value + $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '%' expression {
-		if ($3.value == 0) {
-			yyerror (& @1, parser,
-				 "zero modulus in preprocessor directive");
-		} else {
-			$$.value = $1.value % $3.value;
-		}
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '%' expression {
+      if ($3.value == 0) {
+         yyerror (& @1, parser,
+             "zero modulus in preprocessor directive");
+      } else {
+         $$.value = $1.value % $3.value;
+      }
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '/' expression {
-		if ($3.value == 0) {
-			yyerror (& @1, parser,
-				 "division by 0 in preprocessor directive");
-		} else {
-			$$.value = $1.value / $3.value;
-		}
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '/' expression {
+      if ($3.value == 0) {
+         yyerror (& @1, parser,
+             "division by 0 in preprocessor directive");
+      } else {
+         $$.value = $1.value / $3.value;
+      }
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	expression '*' expression {
-		$$.value = $1.value * $3.value;
-		if ($1.undefined_macro)
-			$$.undefined_macro = $1.undefined_macro;
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   expression '*' expression {
+      $$.value = $1.value * $3.value;
+      if ($1.undefined_macro)
+         $$.undefined_macro = $1.undefined_macro;
                 else
-			$$.undefined_macro = $3.undefined_macro;
-	}
-|	'!' expression %prec UNARY {
-		$$.value = ! $2.value;
-		$$.undefined_macro = $2.undefined_macro;
-	}
-|	'~' expression %prec UNARY {
-		$$.value = ~ $2.value;
-		$$.undefined_macro = $2.undefined_macro;
-	}
-|	'-' expression %prec UNARY {
-		$$.value = - $2.value;
-		$$.undefined_macro = $2.undefined_macro;
-	}
-|	'+' expression %prec UNARY {
-		$$.value = + $2.value;
-		$$.undefined_macro = $2.undefined_macro;
-	}
-|	'(' expression ')' {
-		$$ = $2;
-	}
+         $$.undefined_macro = $3.undefined_macro;
+   }
+|   '!' expression %prec UNARY {
+      $$.value = ! $2.value;
+      $$.undefined_macro = $2.undefined_macro;
+   }
+|   '~' expression %prec UNARY {
+      $$.value = ~ $2.value;
+      $$.undefined_macro = $2.undefined_macro;
+   }
+|   '-' expression %prec UNARY {
+      $$.value = - $2.value;
+      $$.undefined_macro = $2.undefined_macro;
+   }
+|   '+' expression %prec UNARY {
+      $$.value = + $2.value;
+      $$.undefined_macro = $2.undefined_macro;
+   }
+|   '(' expression ')' {
+      $$ = $2;
+   }
 ;
 
 identifier_list:
-	IDENTIFIER {
-		$$ = _string_list_create (parser);
-		_string_list_append_item (parser, $$, $1);
-	}
-|	identifier_list ',' IDENTIFIER {
-		$$ = $1;	
-		_string_list_append_item (parser, $$, $3);
-	}
+   IDENTIFIER {
+      $$ = _string_list_create (parser);
+      _string_list_append_item (parser, $$, $1);
+   }
+|   identifier_list ',' IDENTIFIER {
+      $$ = $1;   
+      _string_list_append_item (parser, $$, $3);
+   }
 ;
 
 text_line:
-	NEWLINE { $$ = NULL; }
-|	pp_tokens NEWLINE
+   NEWLINE { $$ = NULL; }
+|   pp_tokens NEWLINE
 ;
 
 replacement_list:
-	/* empty */ { $$ = NULL; }
-|	pp_tokens
+   /* empty */ { $$ = NULL; }
+|   pp_tokens
 ;
 
 junk:
-	/* empty */
-|	pp_tokens {
-		if (parser->gl_ctx->Const.AllowExtraPPTokens)
-			glcpp_warning(&@1, parser, "extra tokens at end of directive");
-		else
-			glcpp_error(&@1, parser, "extra tokens at end of directive");
-	}
+   /* empty */
+|   pp_tokens {
+      if (parser->gl_ctx->Const.AllowExtraPPTokens)
+         glcpp_warning(&@1, parser, "extra tokens at end of directive");
+      else
+         glcpp_error(&@1, parser, "extra tokens at end of directive");
+   }
 ;
 
 pp_tokens:
-	preprocessing_token {
-		parser->space_tokens = 1;
-		$$ = _token_list_create (parser);
-		_token_list_append (parser, $$, $1);
-	}
-|	pp_tokens preprocessing_token {
-		$$ = $1;
-		_token_list_append (parser, $$, $2);
-	}
+   preprocessing_token {
+      parser->space_tokens = 1;
+      $$ = _token_list_create (parser);
+      _token_list_append (parser, $$, $1);
+   }
+|   pp_tokens preprocessing_token {
+      $$ = $1;
+      _token_list_append (parser, $$, $2);
+   }
 ;
 
 preprocessing_token:
-	IDENTIFIER {
-		$$ = _token_create_str (parser, IDENTIFIER, $1);
-		$$->location = yylloc;
-	}
-|	INTEGER_STRING {
-		$$ = _token_create_str (parser, INTEGER_STRING, $1);
-		$$->location = yylloc;
-	}
-|	PATH {
-		$$ = _token_create_str (parser, PATH, $1);
-		$$->location = yylloc;
-	}
-|	operator {
-		$$ = _token_create_ival (parser, $1, $1);
-		$$->location = yylloc;
-	}
-|	DEFINED {
-		$$ = _token_create_ival (parser, DEFINED, DEFINED);
-		$$->location = yylloc;
-	}
-|	OTHER {
-		$$ = _token_create_str (parser, OTHER, $1);
-		$$->location = yylloc;
-	}
-|	SPACE {
-		$$ = _token_create_ival (parser, SPACE, SPACE);
-		$$->location = yylloc;
-	}
+   IDENTIFIER {
+      $$ = _token_create_str (parser, IDENTIFIER, $1);
+      $$->location = yylloc;
+   }
+|   INTEGER_STRING {
+      $$ = _token_create_str (parser, INTEGER_STRING, $1);
+      $$->location = yylloc;
+   }
+|   PATH {
+      $$ = _token_create_str (parser, PATH, $1);
+      $$->location = yylloc;
+   }
+|   operator {
+      $$ = _token_create_ival (parser, $1, $1);
+      $$->location = yylloc;
+   }
+|   DEFINED {
+      $$ = _token_create_ival (parser, DEFINED, DEFINED);
+      $$->location = yylloc;
+   }
+|   OTHER {
+      $$ = _token_create_str (parser, OTHER, $1);
+      $$->location = yylloc;
+   }
+|   SPACE {
+      $$ = _token_create_ival (parser, SPACE, SPACE);
+      $$->location = yylloc;
+   }
 ;
 
 operator:
-	'['			{ $$ = '['; }
-|	']'			{ $$ = ']'; }
-|	'('			{ $$ = '('; }
-|	')'			{ $$ = ')'; }
-|	'{'			{ $$ = '{'; }
-|	'}'			{ $$ = '}'; }
-|	'.'			{ $$ = '.'; }
-|	'&'			{ $$ = '&'; }
-|	'*'			{ $$ = '*'; }
-|	'+'			{ $$ = '+'; }
-|	'-'			{ $$ = '-'; }
-|	'~'			{ $$ = '~'; }
-|	'!'			{ $$ = '!'; }
-|	'/'			{ $$ = '/'; }
-|	'%'			{ $$ = '%'; }
-|	LEFT_SHIFT		{ $$ = LEFT_SHIFT; }
-|	RIGHT_SHIFT		{ $$ = RIGHT_SHIFT; }
-|	'<'			{ $$ = '<'; }
-|	'>'			{ $$ = '>'; }
-|	LESS_OR_EQUAL		{ $$ = LESS_OR_EQUAL; }
-|	GREATER_OR_EQUAL	{ $$ = GREATER_OR_EQUAL; }
-|	EQUAL			{ $$ = EQUAL; }
-|	NOT_EQUAL		{ $$ = NOT_EQUAL; }
-|	'^'			{ $$ = '^'; }
-|	'|'			{ $$ = '|'; }
-|	AND			{ $$ = AND; }
-|	OR			{ $$ = OR; }
-|	';'			{ $$ = ';'; }
-|	','			{ $$ = ','; }
-|	'='			{ $$ = '='; }
-|	PASTE			{ $$ = PASTE; }
-|	PLUS_PLUS		{ $$ = PLUS_PLUS; }
-|	MINUS_MINUS		{ $$ = MINUS_MINUS; }
+   '['         { $$ = '['; }
+|   ']'         { $$ = ']'; }
+|   '('         { $$ = '('; }
+|   ')'         { $$ = ')'; }
+|   '{'         { $$ = '{'; }
+|   '}'         { $$ = '}'; }
+|   '.'         { $$ = '.'; }
+|   '&'         { $$ = '&'; }
+|   '*'         { $$ = '*'; }
+|   '+'         { $$ = '+'; }
+|   '-'         { $$ = '-'; }
+|   '~'         { $$ = '~'; }
+|   '!'         { $$ = '!'; }
+|   '/'         { $$ = '/'; }
+|   '%'         { $$ = '%'; }
+|   LEFT_SHIFT      { $$ = LEFT_SHIFT; }
+|   RIGHT_SHIFT      { $$ = RIGHT_SHIFT; }
+|   '<'         { $$ = '<'; }
+|   '>'         { $$ = '>'; }
+|   LESS_OR_EQUAL      { $$ = LESS_OR_EQUAL; }
+|   GREATER_OR_EQUAL   { $$ = GREATER_OR_EQUAL; }
+|   EQUAL         { $$ = EQUAL; }
+|   NOT_EQUAL      { $$ = NOT_EQUAL; }
+|   '^'         { $$ = '^'; }
+|   '|'         { $$ = '|'; }
+|   AND         { $$ = AND; }
+|   OR         { $$ = OR; }
+|   ';'         { $$ = ';'; }
+|   ','         { $$ = ','; }
+|   '='         { $$ = '='; }
+|   PASTE         { $$ = PASTE; }
+|   PLUS_PLUS      { $$ = PLUS_PLUS; }
+|   MINUS_MINUS      { $$ = MINUS_MINUS; }
 ;
 
 %%
-- 
GitLab


From 4c02cb59caa834b70407b63c0a6baad1a7ceba0d Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Wed, 23 Nov 2022 00:47:53 +0800
Subject: [PATCH 5/6] glsl: Fixes indent issue after replace tab with 3 space
 by tools in glcpp-parse.y

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/compiler/glsl/glcpp/glcpp-parse.y | 244 +++++++++++++-------------
 1 file changed, 122 insertions(+), 122 deletions(-)

diff --git a/src/compiler/glsl/glcpp/glcpp-parse.y b/src/compiler/glsl/glcpp/glcpp-parse.y
index dba582fa1c8e..93445e6dc967 100644
--- a/src/compiler/glsl/glcpp/glcpp-parse.y
+++ b/src/compiler/glsl/glcpp/glcpp-parse.y
@@ -219,17 +219,17 @@ add_builtin_define(glcpp_parser_t *parser, const char *name, int value);
 
 input:
    /* empty */
-|   input line
+|  input line
 ;
 
 line:
    control_line
-|   SPACE control_line
-|   text_line {
+|  SPACE control_line
+|  text_line {
       _glcpp_parser_print_expanded_token_list (parser, $1);
       _mesa_string_buffer_append_char(parser->output, '\n');
    }
-|   expanded_line
+|  expanded_line
 ;
 
 expanded_line:
@@ -238,17 +238,17 @@ expanded_line:
          glcpp_error(& @1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
       _glcpp_parser_skip_stack_push_if (parser, & @1, $2.value);
    }
-|   ELIF_EXPANDED expression NEWLINE {
+|  ELIF_EXPANDED expression NEWLINE {
       if (parser->is_gles && $2.undefined_macro)
          glcpp_error(& @1, parser, "undefined macro %s in expression (illegal in GLES)", $2.undefined_macro);
       _glcpp_parser_skip_stack_change_if (parser, & @1, "elif", $2.value);
    }
-|   LINE_EXPANDED integer_constant NEWLINE {
+|  LINE_EXPANDED integer_constant NEWLINE {
       parser->has_new_line_number = 1;
       parser->new_line_number = $2;
       _mesa_string_buffer_printf(parser->output, "#line %" PRIiMAX "\n", $2);
    }
-|   LINE_EXPANDED integer_constant integer_constant NEWLINE {
+|  LINE_EXPANDED integer_constant integer_constant NEWLINE {
       parser->has_new_line_number = 1;
       parser->new_line_number = $2;
       parser->has_new_source_number = 1;
@@ -257,7 +257,7 @@ expanded_line:
                   "#line %" PRIiMAX " %" PRIiMAX "\n",
                    $2, $3);
    }
-|   LINE_EXPANDED integer_constant PATH NEWLINE {
+|  LINE_EXPANDED integer_constant PATH NEWLINE {
       parser->has_new_line_number = 1;
       parser->new_line_number = $2;
       _mesa_string_buffer_printf(parser->output,
@@ -270,10 +270,10 @@ define:
    OBJ_IDENTIFIER replacement_list NEWLINE {
       _define_object_macro (parser, & @1, $1, $2);
    }
-|   FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
+|  FUNC_IDENTIFIER '(' ')' replacement_list NEWLINE {
       _define_function_macro (parser, & @1, $1, NULL, $4);
    }
-|   FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
+|  FUNC_IDENTIFIER '(' identifier_list ')' replacement_list NEWLINE {
       _define_function_macro (parser, & @1, $1, $3, $5);
    }
 ;
@@ -282,8 +282,8 @@ control_line:
    control_line_success {
       _mesa_string_buffer_append_char(parser->output, '\n');
    }
-|   control_line_error
-|   HASH_TOKEN LINE pp_tokens NEWLINE {
+|  control_line_error
+|  HASH_TOKEN LINE pp_tokens NEWLINE {
 
       if (parser->skip_stack == NULL ||
           parser->skip_stack->type == SKIP_NO_SKIP)
@@ -297,31 +297,31 @@ control_line:
 
 control_line_success:
    HASH_TOKEN DEFINE_TOKEN define
-|   HASH_TOKEN UNDEF IDENTIFIER NEWLINE {
+|  HASH_TOKEN UNDEF IDENTIFIER NEWLINE {
       struct hash_entry *entry;
 
-                /* Section 3.4 (Preprocessor) of the GLSL ES 3.00 spec says:
-                 *
-                 *    It is an error to undefine or to redefine a built-in
-                 *    (pre-defined) macro name.
-                 *
-                 * The GLSL ES 1.00 spec does not contain this text, but
-                 * dEQP's preprocess test in GLES2 checks for it.
-                 *
-                 * Section 3.3 (Preprocessor) revision 7, of the GLSL 4.50
-                 * spec says:
-                 *
-                 *    By convention, all macro names containing two consecutive
-                 *    underscores ( __ ) are reserved for use by underlying
-                 *    software layers. Defining or undefining such a name
-                 *    in a shader does not itself result in an error, but may
-                 *    result in unintended behaviors that stem from having
-                 *    multiple definitions of the same name. All macro names
-                 *    prefixed with "GL_" (...) are also reseved, and defining
-                 *    such a name results in a compile-time error.
-                 *
-                 * The code below implements the same checks as GLSLang.
-                 */
+      /* Section 3.4 (Preprocessor) of the GLSL ES 3.00 spec says:
+       *
+       *    It is an error to undefine or to redefine a built-in
+       *    (pre-defined) macro name.
+       *
+       * The GLSL ES 1.00 spec does not contain this text, but
+       * dEQP's preprocess test in GLES2 checks for it.
+       *
+       * Section 3.3 (Preprocessor) revision 7, of the GLSL 4.50
+       * spec says:
+       *
+       *    By convention, all macro names containing two consecutive
+       *    underscores ( __ ) are reserved for use by underlying
+       *    software layers. Defining or undefining such a name
+       *    in a shader does not itself result in an error, but may
+       *    result in unintended behaviors that stem from having
+       *    multiple definitions of the same name. All macro names
+       *    prefixed with "GL_" (...) are also reseved, and defining
+       *    such a name results in a compile-time error.
+       *
+       * The code below implements the same checks as GLSLang.
+       */
       if (strncmp("GL_", $3, 3) == 0)
          glcpp_error(& @1, parser, "Built-in (pre-defined)"
                 " names beginning with GL_ cannot be undefined.");
@@ -349,7 +349,7 @@ control_line_success:
          _mesa_hash_table_remove (parser->defines, entry);
       }
    }
-|   HASH_TOKEN INCLUDE NEWLINE {
+|  HASH_TOKEN INCLUDE NEWLINE {
       size_t include_cursor = _mesa_get_shader_include_cursor(parser->gl_ctx->Shared);
 
       /* Remove leading and trailing "" or <> */
@@ -423,7 +423,7 @@ control_line_success:
 
       _mesa_set_shader_include_cursor(parser->gl_ctx->Shared, include_cursor);
    }
-|   HASH_TOKEN IF pp_tokens NEWLINE {
+|  HASH_TOKEN IF pp_tokens NEWLINE {
       /* Be careful to only evaluate the 'if' expression if
        * we are not skipping. When we are skipping, we
        * simply push a new 0-valued 'if' onto the skip
@@ -437,36 +437,36 @@ control_line_success:
          _glcpp_parser_expand_and_lex_from (parser,
                         IF_EXPANDED, $3,
                         EXPANSION_MODE_EVALUATE_DEFINED);
-      }   
+      }
       else
       {
          _glcpp_parser_skip_stack_push_if (parser, & @1, 0);
          parser->skip_stack->type = SKIP_TO_ENDIF;
       }
    }
-|   HASH_TOKEN IF NEWLINE {
+|  HASH_TOKEN IF NEWLINE {
       /* #if without an expression is only an error if we
        *  are not skipping */
       if (parser->skip_stack == NULL ||
           parser->skip_stack->type == SKIP_NO_SKIP)
       {
          glcpp_error(& @1, parser, "#if with no expression");
-      }   
+      }
       _glcpp_parser_skip_stack_push_if (parser, & @1, 0);
    }
-|   HASH_TOKEN IFDEF IDENTIFIER junk NEWLINE {
+|  HASH_TOKEN IFDEF IDENTIFIER junk NEWLINE {
       struct hash_entry *entry =
             _mesa_hash_table_search(parser->defines, $3);
       macro_t *macro = entry ? entry->data : NULL;
       _glcpp_parser_skip_stack_push_if (parser, & @1, macro != NULL);
    }
-|   HASH_TOKEN IFNDEF IDENTIFIER junk NEWLINE {
+|  HASH_TOKEN IFNDEF IDENTIFIER junk NEWLINE {
       struct hash_entry *entry =
             _mesa_hash_table_search(parser->defines, $3);
       macro_t *macro = entry ? entry->data : NULL;
       _glcpp_parser_skip_stack_push_if (parser, & @3, macro == NULL);
    }
-|   HASH_TOKEN ELIF pp_tokens NEWLINE {
+|  HASH_TOKEN ELIF pp_tokens NEWLINE {
       /* Be careful to only evaluate the 'elif' expression
        * if we are not skipping. When we are skipping, we
        * simply change to a 0-valued 'elif' on the skip
@@ -492,7 +492,7 @@ control_line_success:
                          "elif", 0);
       }
    }
-|   HASH_TOKEN ELIF NEWLINE {
+|  HASH_TOKEN ELIF NEWLINE {
       /* #elif without an expression is an error unless we
        * are skipping. */
       if (parser->skip_stack &&
@@ -512,7 +512,7 @@ control_line_success:
          glcpp_warning(& @1, parser, "ignoring illegal #elif without expression");
       }
    }
-|   HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
+|  HASH_TOKEN ELSE { parser->lexing_directive = 1; } NEWLINE {
       if (parser->skip_stack &&
           parser->skip_stack->has_else)
       {
@@ -525,25 +525,25 @@ control_line_success:
             parser->skip_stack->has_else = true;
       }
    }
-|   HASH_TOKEN ENDIF {
+|  HASH_TOKEN ENDIF {
       _glcpp_parser_skip_stack_pop (parser, & @1);
    } NEWLINE
-|   HASH_TOKEN VERSION_TOKEN version_constant NEWLINE {
+|  HASH_TOKEN VERSION_TOKEN version_constant NEWLINE {
       if (parser->version_set) {
          glcpp_error(& @1, parser, "#version must appear on the first line");
       }
       _glcpp_parser_handle_version_declaration(parser, $3, NULL, true);
    }
-|   HASH_TOKEN VERSION_TOKEN version_constant IDENTIFIER NEWLINE {
+|  HASH_TOKEN VERSION_TOKEN version_constant IDENTIFIER NEWLINE {
       if (parser->version_set) {
          glcpp_error(& @1, parser, "#version must appear on the first line");
       }
       _glcpp_parser_handle_version_declaration(parser, $3, $4, true);
    }
-|   HASH_TOKEN NEWLINE {
+|  HASH_TOKEN NEWLINE {
       glcpp_parser_resolve_implicit_version(parser);
    }
-|   HASH_TOKEN PRAGMA NEWLINE {
+|  HASH_TOKEN PRAGMA NEWLINE {
       _mesa_string_buffer_printf(parser->output, "#%s", $2);
    }
 ;
@@ -552,10 +552,10 @@ control_line_error:
    HASH_TOKEN ERROR_TOKEN NEWLINE {
       glcpp_error(& @1, parser, "#%s", $2);
    }
-|   HASH_TOKEN DEFINE_TOKEN NEWLINE {
+|  HASH_TOKEN DEFINE_TOKEN NEWLINE {
       glcpp_error (& @1, parser, "#define without macro name");
    }
-|   HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
+|  HASH_TOKEN GARBAGE pp_tokens NEWLINE  {
       glcpp_error (& @1, parser, "Illegal non-directive after #");
    }
 ;
@@ -565,7 +565,7 @@ integer_constant:
       /* let strtoll detect the base */
       $$ = strtoll ($1, NULL, 0);
    }
-|   INTEGER {
+|  INTEGER {
       $$ = $1;
    }
 
@@ -585,14 +585,14 @@ expression:
       $$.value = $1;
       $$.undefined_macro = NULL;
    }
-|   IDENTIFIER {
+|  IDENTIFIER {
       $$.value = 0;
       if (parser->is_gles)
          $$.undefined_macro = linear_strdup(parser->linalloc, $1);
       else
          $$.undefined_macro = NULL;
    }
-|   expression OR expression {
+|  expression OR expression {
       $$.value = $1.value || $3.value;
 
       /* Short-circuit: Only flag undefined from right side
@@ -603,7 +603,7 @@ expression:
                 else if (! $1.value)
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression AND expression {
+|  expression AND expression {
       $$.value = $1.value && $3.value;
 
       /* Short-circuit: Only flag undefined from right-side
@@ -614,98 +614,98 @@ expression:
                 else if ($1.value)
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '|' expression {
+|  expression '|' expression {
       $$.value = $1.value | $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '^' expression {
+|  expression '^' expression {
       $$.value = $1.value ^ $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '&' expression {
+|  expression '&' expression {
       $$.value = $1.value & $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression NOT_EQUAL expression {
+|  expression NOT_EQUAL expression {
       $$.value = $1.value != $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression EQUAL expression {
+|  expression EQUAL expression {
       $$.value = $1.value == $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression GREATER_OR_EQUAL expression {
+|  expression GREATER_OR_EQUAL expression {
       $$.value = $1.value >= $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression LESS_OR_EQUAL expression {
+|  expression LESS_OR_EQUAL expression {
       $$.value = $1.value <= $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '>' expression {
+|  expression '>' expression {
       $$.value = $1.value > $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '<' expression {
+|  expression '<' expression {
       $$.value = $1.value < $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression RIGHT_SHIFT expression {
+|  expression RIGHT_SHIFT expression {
       $$.value = $1.value >> $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression LEFT_SHIFT expression {
+|  expression LEFT_SHIFT expression {
       $$.value = $1.value << $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '-' expression {
+|  expression '-' expression {
       $$.value = $1.value - $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '+' expression {
+|  expression '+' expression {
       $$.value = $1.value + $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '%' expression {
+|  expression '%' expression {
       if ($3.value == 0) {
          yyerror (& @1, parser,
              "zero modulus in preprocessor directive");
@@ -717,7 +717,7 @@ expression:
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '/' expression {
+|  expression '/' expression {
       if ($3.value == 0) {
          yyerror (& @1, parser,
              "division by 0 in preprocessor directive");
@@ -729,30 +729,30 @@ expression:
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   expression '*' expression {
+|  expression '*' expression {
       $$.value = $1.value * $3.value;
       if ($1.undefined_macro)
          $$.undefined_macro = $1.undefined_macro;
                 else
          $$.undefined_macro = $3.undefined_macro;
    }
-|   '!' expression %prec UNARY {
+|  '!' expression %prec UNARY {
       $$.value = ! $2.value;
       $$.undefined_macro = $2.undefined_macro;
    }
-|   '~' expression %prec UNARY {
+|  '~' expression %prec UNARY {
       $$.value = ~ $2.value;
       $$.undefined_macro = $2.undefined_macro;
    }
-|   '-' expression %prec UNARY {
+|  '-' expression %prec UNARY {
       $$.value = - $2.value;
       $$.undefined_macro = $2.undefined_macro;
    }
-|   '+' expression %prec UNARY {
+|  '+' expression %prec UNARY {
       $$.value = + $2.value;
       $$.undefined_macro = $2.undefined_macro;
    }
-|   '(' expression ')' {
+|  '(' expression ')' {
       $$ = $2;
    }
 ;
@@ -762,25 +762,25 @@ identifier_list:
       $$ = _string_list_create (parser);
       _string_list_append_item (parser, $$, $1);
    }
-|   identifier_list ',' IDENTIFIER {
-      $$ = $1;   
+|  identifier_list ',' IDENTIFIER {
+      $$ = $1;
       _string_list_append_item (parser, $$, $3);
    }
 ;
 
 text_line:
    NEWLINE { $$ = NULL; }
-|   pp_tokens NEWLINE
+|  pp_tokens NEWLINE
 ;
 
 replacement_list:
    /* empty */ { $$ = NULL; }
-|   pp_tokens
+|  pp_tokens
 ;
 
 junk:
    /* empty */
-|   pp_tokens {
+|  pp_tokens {
       if (parser->gl_ctx->Const.AllowExtraPPTokens)
          glcpp_warning(&@1, parser, "extra tokens at end of directive");
       else
@@ -794,7 +794,7 @@ pp_tokens:
       $$ = _token_list_create (parser);
       _token_list_append (parser, $$, $1);
    }
-|   pp_tokens preprocessing_token {
+|  pp_tokens preprocessing_token {
       $$ = $1;
       _token_list_append (parser, $$, $2);
    }
@@ -805,66 +805,66 @@ preprocessing_token:
       $$ = _token_create_str (parser, IDENTIFIER, $1);
       $$->location = yylloc;
    }
-|   INTEGER_STRING {
+|  INTEGER_STRING {
       $$ = _token_create_str (parser, INTEGER_STRING, $1);
       $$->location = yylloc;
    }
-|   PATH {
+|  PATH {
       $$ = _token_create_str (parser, PATH, $1);
       $$->location = yylloc;
    }
-|   operator {
+|  operator {
       $$ = _token_create_ival (parser, $1, $1);
       $$->location = yylloc;
    }
-|   DEFINED {
+|  DEFINED {
       $$ = _token_create_ival (parser, DEFINED, DEFINED);
       $$->location = yylloc;
    }
-|   OTHER {
+|  OTHER {
       $$ = _token_create_str (parser, OTHER, $1);
       $$->location = yylloc;
    }
-|   SPACE {
+|  SPACE {
       $$ = _token_create_ival (parser, SPACE, SPACE);
       $$->location = yylloc;
    }
 ;
 
 operator:
-   '['         { $$ = '['; }
-|   ']'         { $$ = ']'; }
-|   '('         { $$ = '('; }
-|   ')'         { $$ = ')'; }
-|   '{'         { $$ = '{'; }
-|   '}'         { $$ = '}'; }
-|   '.'         { $$ = '.'; }
-|   '&'         { $$ = '&'; }
-|   '*'         { $$ = '*'; }
-|   '+'         { $$ = '+'; }
-|   '-'         { $$ = '-'; }
-|   '~'         { $$ = '~'; }
-|   '!'         { $$ = '!'; }
-|   '/'         { $$ = '/'; }
-|   '%'         { $$ = '%'; }
-|   LEFT_SHIFT      { $$ = LEFT_SHIFT; }
-|   RIGHT_SHIFT      { $$ = RIGHT_SHIFT; }
-|   '<'         { $$ = '<'; }
-|   '>'         { $$ = '>'; }
-|   LESS_OR_EQUAL      { $$ = LESS_OR_EQUAL; }
-|   GREATER_OR_EQUAL   { $$ = GREATER_OR_EQUAL; }
-|   EQUAL         { $$ = EQUAL; }
-|   NOT_EQUAL      { $$ = NOT_EQUAL; }
-|   '^'         { $$ = '^'; }
-|   '|'         { $$ = '|'; }
-|   AND         { $$ = AND; }
-|   OR         { $$ = OR; }
-|   ';'         { $$ = ';'; }
-|   ','         { $$ = ','; }
-|   '='         { $$ = '='; }
-|   PASTE         { $$ = PASTE; }
-|   PLUS_PLUS      { $$ = PLUS_PLUS; }
-|   MINUS_MINUS      { $$ = MINUS_MINUS; }
+   '['               { $$ = '['; }
+|  ']'               { $$ = ']'; }
+|  '('               { $$ = '('; }
+|  ')'               { $$ = ')'; }
+|  '{'               { $$ = '{'; }
+|  '}'               { $$ = '}'; }
+|  '.'               { $$ = '.'; }
+|  '&'               { $$ = '&'; }
+|  '*'               { $$ = '*'; }
+|  '+'               { $$ = '+'; }
+|  '-'               { $$ = '-'; }
+|  '~'               { $$ = '~'; }
+|  '!'               { $$ = '!'; }
+|  '/'               { $$ = '/'; }
+|  '%'               { $$ = '%'; }
+|  LEFT_SHIFT        { $$ = LEFT_SHIFT; }
+|  RIGHT_SHIFT       { $$ = RIGHT_SHIFT; }
+|  '<'               { $$ = '<'; }
+|  '>'               { $$ = '>'; }
+|  LESS_OR_EQUAL     { $$ = LESS_OR_EQUAL; }
+|  GREATER_OR_EQUAL  { $$ = GREATER_OR_EQUAL; }
+|  EQUAL             { $$ = EQUAL; }
+|  NOT_EQUAL         { $$ = NOT_EQUAL; }
+|  '^'               { $$ = '^'; }
+|  '|'               { $$ = '|'; }
+|  AND               { $$ = AND; }
+|  OR                { $$ = OR; }
+|  ';'               { $$ = ';'; }
+|  ','               { $$ = ','; }
+|  '='               { $$ = '='; }
+|  PASTE             { $$ = PASTE; }
+|  PLUS_PLUS         { $$ = PLUS_PLUS; }
+|  MINUS_MINUS       { $$ = MINUS_MINUS; }
 ;
 
 %%
-- 
GitLab


From 8d8c502177b4bfedb4b71c931df919a7b2c94aa8 Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Fri, 4 Nov 2022 20:48:02 +0800
Subject: [PATCH 6/6] glsl: fixes -Werror,-Wunused-but-set-variable for
 clang-15 in glcpp-parse.y and glsl_parser.yy

error messages:
src/compiler/glsl/glcpp/glcpp-parse.c:1691:9: error: variable 'glcpp_parser_nerrs' set but not used [-Werror,-Wunused-but-set-variable]
    int yynerrs = 0;
        ^

src/compiler/glsl/glsl_parser.cpp:2370:9: error: variable '_mesa_glsl_nerrs' set but not used [-Werror,-Wunused-but-set-variable]
    int yynerrs = 0;
        ^

Signed-off-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/compiler/glsl/glcpp/glcpp-parse.y | 2 ++
 src/compiler/glsl/glsl_parser.yy      | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/src/compiler/glsl/glcpp/glcpp-parse.y b/src/compiler/glsl/glcpp/glcpp-parse.y
index 93445e6dc967..7456c8ab8720 100644
--- a/src/compiler/glsl/glcpp/glcpp-parse.y
+++ b/src/compiler/glsl/glcpp/glcpp-parse.y
@@ -785,6 +785,8 @@ junk:
          glcpp_warning(&@1, parser, "extra tokens at end of directive");
       else
          glcpp_error(&@1, parser, "extra tokens at end of directive");
+
+      (void)yynerrs;
    }
 ;
 
diff --git a/src/compiler/glsl/glsl_parser.yy b/src/compiler/glsl/glsl_parser.yy
index 428ff53cd318..574895b005ae 100644
--- a/src/compiler/glsl/glsl_parser.yy
+++ b/src/compiler/glsl/glsl_parser.yy
@@ -3105,5 +3105,7 @@ layout_defaults:
       if (!state->out_qualifier->push_to_global(& @1, state)) {
          YYERROR;
       }
+
+      (void)yynerrs;
    }
    ;
-- 
GitLab

