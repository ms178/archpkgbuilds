From d4d843ee6ab57180afb3efc65e6129ceca9329ea Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 26 Jan 2023 12:33:40 -0500
Subject: [PATCH 1/4] radv: delete radv_graphics_pipeline_compile() asserts

validation should catch these by now
---
 src/amd/vulkan/radv_pipeline.c | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 50099d6e0713..633940c191fd 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3512,19 +3512,6 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
 
    radv_pipeline_load_retained_shaders(pipeline, stages);
 
-   ASSERTED bool primitive_shading =
-      stages[MESA_SHADER_VERTEX].entrypoint || stages[MESA_SHADER_TESS_CTRL].entrypoint ||
-      stages[MESA_SHADER_TESS_EVAL].entrypoint || stages[MESA_SHADER_GEOMETRY].entrypoint;
-   ASSERTED bool mesh_shading =
-      stages[MESA_SHADER_MESH].entrypoint;
-
-   /* Primitive and mesh shading must not be mixed in the same pipeline. */
-   assert(!primitive_shading || !mesh_shading);
-   /* Mesh shaders are mandatory in mesh shading pipelines. */
-   assert(mesh_shading == !!stages[MESA_SHADER_MESH].entrypoint);
-   /* Mesh shaders always need NGG. */
-   assert(!mesh_shading || pipeline_key->use_ngg);
-
    if (!fast_linking_enabled) {
       radv_hash_shaders(hash, stages, MESA_VULKAN_SHADER_STAGES, pipeline_layout, pipeline_key,
                         radv_get_hash_flags(device, keep_statistic_info));
-- 
GitLab


From a0245d89c98b22724f77791d84c5360a8a746c4c Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 9 Mar 2023 15:04:29 +0100
Subject: [PATCH 2/4] radv: zero-initialize radv_shader_args right before
 declaring them

This should allow us to remove a big memset when compiling a
graphics pipeline. This is mostly for imported NIR stages which
don't go through radv_pipeline_stage_init().

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 24 ++++++++----------------
 src/amd/vulkan/radv_pipeline_rt.c |  5 ++---
 src/amd/vulkan/radv_shader.c      |  9 ++++-----
 src/amd/vulkan/radv_shader_args.c | 30 ++++++++++++++++++++++++------
 src/amd/vulkan/radv_shader_args.h |  5 +++--
 5 files changed, 41 insertions(+), 32 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 633940c191fd..0ba226787214 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2558,15 +2558,8 @@ radv_declare_pipeline_args(struct radv_device *device, struct radv_pipeline_stag
 {
    enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
 
-   radv_foreach_stage(i, active_nir_stages) {
-      stages[i].args.is_gs_copy_shader = false;
-      stages[i].args.explicit_scratch_args = !radv_use_llvm_for_stage(device, i);
-      stages[i].args.remap_spi_ps_input = !radv_use_llvm_for_stage(device, i);
-      stages[i].args.load_grid_size_from_user_sgpr = device->load_grid_size_from_user_sgpr;
-   }
-
    if (gfx_level >= GFX9 && stages[MESA_SHADER_TESS_CTRL].nir) {
-      radv_declare_shader_args(gfx_level, pipeline_key, &stages[MESA_SHADER_TESS_CTRL].info,
+      radv_declare_shader_args(device, pipeline_key, &stages[MESA_SHADER_TESS_CTRL].info,
                                MESA_SHADER_TESS_CTRL, true, MESA_SHADER_VERTEX,
                                &stages[MESA_SHADER_TESS_CTRL].args);
       stages[MESA_SHADER_TESS_CTRL].info.user_sgprs_locs = stages[MESA_SHADER_TESS_CTRL].args.user_sgprs_locs;
@@ -2584,7 +2577,7 @@ radv_declare_pipeline_args(struct radv_device *device, struct radv_pipeline_stag
    if (gfx_level >= GFX9 && stages[MESA_SHADER_GEOMETRY].nir) {
       gl_shader_stage pre_stage =
          stages[MESA_SHADER_TESS_EVAL].nir ? MESA_SHADER_TESS_EVAL : MESA_SHADER_VERTEX;
-      radv_declare_shader_args(gfx_level, pipeline_key, &stages[MESA_SHADER_GEOMETRY].info,
+      radv_declare_shader_args(device, pipeline_key, &stages[MESA_SHADER_GEOMETRY].info,
                                MESA_SHADER_GEOMETRY, true, pre_stage,
                                &stages[MESA_SHADER_GEOMETRY].args);
       stages[MESA_SHADER_GEOMETRY].info.user_sgprs_locs = stages[MESA_SHADER_GEOMETRY].args.user_sgprs_locs;
@@ -2599,8 +2592,8 @@ radv_declare_pipeline_args(struct radv_device *device, struct radv_pipeline_stag
    }
 
    u_foreach_bit(i, active_nir_stages) {
-      radv_declare_shader_args(gfx_level, pipeline_key, &stages[i].info, i, false,
-                               MESA_SHADER_VERTEX, &stages[i].args);
+      radv_declare_shader_args(device, pipeline_key, &stages[i].info, i, false, MESA_SHADER_VERTEX,
+                               &stages[i].args);
       stages[i].info.user_sgprs_locs = stages[i].args.user_sgprs_locs;
       stages[i].info.inline_push_constant_mask = stages[i].args.ac.inline_push_const_mask;
    }
@@ -2984,11 +2977,11 @@ radv_pipeline_create_gs_copy_shader(struct radv_pipeline *pipeline,
    info.outinfo = gs_info->outinfo;
    info.force_vrs_per_vertex = gs_info->force_vrs_per_vertex;
 
-   struct radv_shader_args gs_copy_args = {0};
+   struct radv_shader_args gs_copy_args;
    gs_copy_args.is_gs_copy_shader = true;
    gs_copy_args.explicit_scratch_args = !radv_use_llvm_for_stage(device, MESA_SHADER_VERTEX);
-   radv_declare_shader_args(device->physical_device->rad_info.gfx_level, pipeline_key, &info,
-                            MESA_SHADER_VERTEX, false, MESA_SHADER_VERTEX, &gs_copy_args);
+   radv_declare_shader_args(device, pipeline_key, &info, MESA_SHADER_VERTEX, false,
+                            MESA_SHADER_VERTEX, &gs_copy_args);
    info.user_sgprs_locs = gs_copy_args.user_sgprs_locs;
    info.inline_push_constant_mask = gs_copy_args.ac.inline_push_const_mask;
 
@@ -5440,8 +5433,7 @@ radv_compute_pipeline_compile(struct radv_compute_pipeline *pipeline,
    cs_stage.args.explicit_scratch_args = !radv_use_llvm_for_stage(device, MESA_SHADER_COMPUTE);
    cs_stage.args.load_grid_size_from_user_sgpr = device->load_grid_size_from_user_sgpr;
 
-   radv_declare_shader_args(device->physical_device->rad_info.gfx_level, pipeline_key,
-                            &cs_stage.info, MESA_SHADER_COMPUTE, false,
+   radv_declare_shader_args(device, pipeline_key, &cs_stage.info, MESA_SHADER_COMPUTE, false,
                             MESA_SHADER_VERTEX, &cs_stage.args);
 
    cs_stage.info.user_sgprs_locs = cs_stage.args.user_sgprs_locs;
diff --git a/src/amd/vulkan/radv_pipeline_rt.c b/src/amd/vulkan/radv_pipeline_rt.c
index 1193e1faa10d..af39b6d0c90e 100644
--- a/src/amd/vulkan/radv_pipeline_rt.c
+++ b/src/amd/vulkan/radv_pipeline_rt.c
@@ -271,9 +271,8 @@ radv_rt_pipeline_compile(struct radv_pipeline *pipeline,
    rt_stage.args.explicit_scratch_args = !radv_use_llvm_for_stage(device, rt_stage.stage);
    rt_stage.args.load_grid_size_from_user_sgpr = device->load_grid_size_from_user_sgpr;
 
-   radv_declare_shader_args(device->physical_device->rad_info.gfx_level, pipeline_key,
-                            &rt_stage.info, rt_stage.stage, false, MESA_SHADER_NONE,
-                            &rt_stage.args);
+   radv_declare_shader_args(device, pipeline_key, &rt_stage.info, rt_stage.stage, false,
+                            MESA_SHADER_NONE, &rt_stage.args);
 
    rt_stage.info.user_sgprs_locs = rt_stage.args.user_sgprs_locs;
    rt_stage.info.inline_push_constant_mask = rt_stage.args.ac.inline_push_const_mask;
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 4436bf29e13f..41dc6d5ecbb5 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2460,11 +2460,10 @@ radv_create_trap_handler_shader(struct radv_device *device)
 
    info.wave_size = 64;
 
-   struct radv_shader_args args = {0};
+   struct radv_shader_args args;
    args.explicit_scratch_args = true;
    args.is_trap_handler_shader = true;
-   radv_declare_shader_args(device->physical_device->rad_info.gfx_level, &key, &info, stage, false,
-                            MESA_SHADER_VERTEX, &args);
+   radv_declare_shader_args(device, &key, &info, stage, false, MESA_SHADER_VERTEX, &args);
 
    shader =
       shader_compile(device, &b.shader, 1, stage, &info, &args, &key, true, false, false, &binary);
@@ -2527,7 +2526,7 @@ radv_create_vs_prolog(struct radv_device *device, const struct radv_vs_prolog_ke
    struct radv_pipeline_key pipeline_key = {0};
 
    args.explicit_scratch_args = true;
-   radv_declare_shader_args(options.gfx_level, &pipeline_key, &info, key->next_stage,
+   radv_declare_shader_args(device, &pipeline_key, &info, key->next_stage,
                             key->next_stage != MESA_SHADER_VERTEX, MESA_SHADER_VERTEX, &args);
 
    info.user_sgprs_locs = args.user_sgprs_locs;
@@ -2596,7 +2595,7 @@ radv_create_ps_epilog(struct radv_device *device, const struct radv_ps_epilog_ke
    info.wave_size = device->physical_device->ps_wave_size;
    info.workgroup_size = 64;
 
-   radv_declare_ps_epilog_args(device->physical_device->rad_info.gfx_level, key, &args);
+   radv_declare_ps_epilog_args(device, key, &args);
 
 #ifdef LLVM_AVAILABLE
    if (options.dump_shader || options.record_ir)
diff --git a/src/amd/vulkan/radv_shader_args.c b/src/amd/vulkan/radv_shader_args.c
index 494f39189adf..428bb47bcc84 100644
--- a/src/amd/vulkan/radv_shader_args.c
+++ b/src/amd/vulkan/radv_shader_args.c
@@ -557,12 +557,29 @@ set_ms_input_locs(struct radv_shader_args *args, uint8_t *user_sgpr_idx)
       set_loc_shader(args, AC_UD_TASK_RING_ENTRY, user_sgpr_idx, 1);
 }
 
+static void
+radv_init_shader_args(const struct radv_device *device, gl_shader_stage stage,
+                      struct radv_shader_args *args)
+{
+   memset(args, 0, sizeof(*args));
+
+   args->explicit_scratch_args = !radv_use_llvm_for_stage(device, stage);
+   args->remap_spi_ps_input = !radv_use_llvm_for_stage(device, stage);
+   args->load_grid_size_from_user_sgpr = device->load_grid_size_from_user_sgpr;
+
+   for (int i = 0; i < MAX_SETS; i++)
+      args->user_sgprs_locs.descriptor_sets[i].sgpr_idx = -1;
+   for (int i = 0; i < AC_UD_MAX_UD; i++)
+      args->user_sgprs_locs.shader_data[i].sgpr_idx = -1;
+}
+
 void
-radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipeline_key *key,
+radv_declare_shader_args(const struct radv_device *device, const struct radv_pipeline_key *key,
                          const struct radv_shader_info *info, gl_shader_stage stage,
                          bool has_previous_stage, gl_shader_stage previous_stage,
                          struct radv_shader_args *args)
 {
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
    struct user_sgpr_info user_sgpr_info;
    bool needs_view_index = info->uses_view_index;
    bool has_ngg_query = info->has_ngg_prim_query || info->has_ngg_xfb_query ||
@@ -577,10 +594,7 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
       has_previous_stage = true;
    }
 
-   for (int i = 0; i < MAX_SETS; i++)
-      args->user_sgprs_locs.descriptor_sets[i].sgpr_idx = -1;
-   for (int i = 0; i < AC_UD_MAX_UD; i++)
-      args->user_sgprs_locs.shader_data[i].sgpr_idx = -1;
+   radv_init_shader_args(device, stage, args);
 
    allocate_user_sgprs(gfx_level, info, args, stage, has_previous_stage, previous_stage,
                        needs_view_index, has_ngg_query, has_ngg_provoking_vtx, key, &user_sgpr_info);
@@ -970,9 +984,13 @@ radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipelin
 }
 
 void
-radv_declare_ps_epilog_args(enum amd_gfx_level gfx_level, const struct radv_ps_epilog_key *key,
+radv_declare_ps_epilog_args(const struct radv_device *device, const struct radv_ps_epilog_key *key,
                             struct radv_shader_args *args)
 {
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+
+   radv_init_shader_args(device, MESA_SHADER_FRAGMENT, args);
+
    ac_add_arg(&args->ac, AC_ARG_SGPR, 2, AC_ARG_CONST_DESC_PTR, &args->ac.ring_offsets);
    if (gfx_level < GFX11)
       ac_add_arg(&args->ac, AC_ARG_SGPR, 1, AC_ARG_INT, &args->ac.scratch_offset);
diff --git a/src/amd/vulkan/radv_shader_args.h b/src/amd/vulkan/radv_shader_args.h
index 18076cd545d7..29831a6558f1 100644
--- a/src/amd/vulkan/radv_shader_args.h
+++ b/src/amd/vulkan/radv_shader_args.h
@@ -93,12 +93,13 @@ radv_shader_args_from_ac(struct ac_shader_args *args)
 struct radv_pipeline_key;
 struct radv_shader_info;
 
-void radv_declare_shader_args(enum amd_gfx_level gfx_level, const struct radv_pipeline_key *key,
+void radv_declare_shader_args(const struct radv_device *device, const struct radv_pipeline_key *key,
                               const struct radv_shader_info *info, gl_shader_stage stage,
                               bool has_previous_stage, gl_shader_stage previous_stage,
                               struct radv_shader_args *args);
 
-void radv_declare_ps_epilog_args(enum amd_gfx_level gfx_level, const struct radv_ps_epilog_key *key,
+void radv_declare_ps_epilog_args(const struct radv_device *device,
+                                 const struct radv_ps_epilog_key *key,
                                  struct radv_shader_args *args);
 
 #endif
-- 
GitLab


From bd9c7bccd9a465288420920cd3108c7da9592ead Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 9 Mar 2023 17:28:28 +0100
Subject: [PATCH 3/4] radv: zero-initialize radv_shader_info earlier for
 graphics pipeline

This should allow us to remove a big memset when compiling a
graphics pipeline. This is mostly for imported NIR stages which
don't go through radv_pipeline_stage_init().

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 5 ++++-
 src/amd/vulkan/radv_shader_info.c | 2 ++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 0ba226787214..64431f591ef5 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2541,7 +2541,6 @@ radv_fill_shader_info(struct radv_graphics_pipeline *pipeline,
    bool consider_force_vrs = radv_consider_force_vrs(pipeline, noop_fs, stages);
 
    radv_foreach_stage(i, active_nir_stages) {
-      radv_nir_shader_info_init(&stages[i].info);
       radv_nir_shader_info_pass(device, stages[i].nir, pipeline_layout, pipeline_key,
                                 pipeline->base.type,
                                 i == pipeline->last_vgt_api_stage && consider_force_vrs,
@@ -3554,6 +3553,10 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
 
    bool optimize_conservatively = pipeline_key->optimisations_disabled;
 
+   radv_foreach_stage(i, active_nir_stages) {
+      radv_nir_shader_info_init(&stages[i].info);
+   }
+
    /* Determine if shaders uses NGG before linking because it's needed for some NIR pass. */
    radv_fill_shader_info_ngg(pipeline, pipeline_key, stages);
 
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index d34eb9a5fe53..4d4d20f0d953 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -690,6 +690,8 @@ gather_shader_info_task(const nir_shader *nir, struct radv_shader_info *info)
 void
 radv_nir_shader_info_init(struct radv_shader_info *info)
 {
+   memset(info, 0, sizeof(*info));
+
    /* Assume that shaders can inline all push constants by default. */
    info->can_inline_all_push_constants = true;
 }
-- 
GitLab


From 2496571c3e0fcf16eab11e6bce1cbd77c12da50c Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 26 Jan 2023 12:55:02 -0500
Subject: [PATCH 4/4] radv: avoid a huge memset in
 radv_graphics_pipeline_compile()

this has a noticeable impact on pipeline creation
---
 src/amd/vulkan/radv_pipeline.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 64431f591ef5..069696e1e10e 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3465,7 +3465,7 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
       radv_pipeline_capture_shaders(pipeline->base.device, pCreateInfo->flags);
    bool keep_statistic_info =
       radv_pipeline_capture_shader_stats(pipeline->base.device, pCreateInfo->flags);
-   struct radv_pipeline_stage stages[MESA_VULKAN_SHADER_STAGES] = {0};
+   struct radv_pipeline_stage stages[MESA_VULKAN_SHADER_STAGES];
    const VkPipelineCreationFeedbackCreateInfo *creation_feedback =
       vk_find_struct_const(pCreateInfo->pNext, PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
    VkPipelineCreationFeedback pipeline_feedback = {
@@ -3491,6 +3491,12 @@ radv_graphics_pipeline_compile(struct radv_graphics_pipeline *pipeline,
       skip_shaders_cache = true;
    }
 
+   for (unsigned i = 0; i < MESA_VULKAN_SHADER_STAGES; i++) {
+      stages[i].entrypoint = NULL;
+      stages[i].nir = NULL;
+      stages[i].spirv.size = 0;
+   }
+
    for (uint32_t i = 0; i < pCreateInfo->stageCount; i++) {
       const VkPipelineShaderStageCreateInfo *sinfo = &pCreateInfo->pStages[i];
       gl_shader_stage stage = vk_to_mesa_shader_stage(sinfo->stage);
-- 
GitLab

