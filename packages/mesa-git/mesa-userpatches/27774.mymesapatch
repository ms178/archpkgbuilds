From 88642a08381d39a9b976b4ad9969c23d055fd6d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 20 Feb 2024 12:45:56 +0100
Subject: [PATCH 02/11] aco/spill: refactor SSA repairing

---
 src/amd/compiler/aco_spill.cpp | 73 +++++++++++-----------------------
 1 file changed, 24 insertions(+), 49 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 8da3d49202bfc..e06223c3983ed 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -1350,64 +1350,39 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
 
    /* add coupling code to all loop header predecessors */
    add_coupling_code(ctx, loop_header, loop_header->index);
-
-   /* propagate new renames through loop: i.e. repair the SSA */
    renames.swap(ctx.renames[loop_header->index]);
-   for (std::pair<Temp, Temp> rename : renames) {
-      for (unsigned idx = loop_header->index; idx <= block_idx; idx++) {
-         Block& current = ctx.program->blocks[idx];
-         std::vector<aco_ptr<Instruction>>::iterator instr_it = current.instructions.begin();
-
-         /* first rename phis */
-         while (instr_it != current.instructions.end()) {
-            aco_ptr<Instruction>& phi = *instr_it;
-            if (phi->opcode != aco_opcode::p_phi && phi->opcode != aco_opcode::p_linear_phi)
-               break;
-            /* no need to rename the loop header phis once again. this happened in
-             * add_coupling_code() */
-            if (idx == loop_header->index) {
-               instr_it++;
-               continue;
-            }
 
-            for (Operand& op : phi->operands) {
-               if (!op.isTemp())
-                  continue;
-               if (op.getTemp() == rename.first)
-                  op.setTemp(rename.second);
-            }
-            instr_it++;
-         }
+   /* remove loop header info from stack */
+   ctx.loop_header.pop();
+   if (renames.empty())
+      return;
 
-         /* variable is not live at beginning of this block */
-         if (ctx.next_use_distances_start[idx].count(rename.first) == 0)
+   /* Add the new renames to each block */
+   for (std::pair<Temp, Temp> rename : renames) {
+      /* If there is already a rename, don't overwrite it. */
+      for (unsigned idx = loop_header->index; idx <= block_idx; idx++)
+         ctx.renames[idx].insert(rename);
+   }
+
+   /* propagate new renames through loop: i.e. repair the SSA */
+   for (unsigned idx = loop_header->index; idx <= block_idx; idx++) {
+      Block& current = ctx.program->blocks[idx];
+      /* rename all uses in this block */
+      for (aco_ptr<Instruction>& instr : current.instructions) {
+         /* no need to rename the loop header phis once again. */
+         if (idx == loop_header->index && is_phi(instr))
             continue;
 
-         /* if the variable is live at the block's exit, add rename */
-         if (ctx.next_use_distances_end[idx].count(rename.first) != 0)
-            ctx.renames[idx].insert(rename);
+         for (Operand& op : instr->operands) {
+            if (!op.isTemp())
+               continue;
 
-         /* rename all uses in this block */
-         bool renamed = false;
-         while (!renamed && instr_it != current.instructions.end()) {
-            aco_ptr<Instruction>& instr = *instr_it;
-            for (Operand& op : instr->operands) {
-               if (!op.isTemp())
-                  continue;
-               if (op.getTemp() == rename.first) {
-                  op.setTemp(rename.second);
-                  /* we can stop with this block as soon as the variable is spilled */
-                  if (instr->opcode == aco_opcode::p_spill)
-                     renamed = true;
-               }
-            }
-            instr_it++;
+            auto rename = renames.find(op.getTemp());
+            if (rename != renames.end())
+               op.setTemp(rename->second);
          }
       }
    }
-
-   /* remove loop header info from stack */
-   ctx.loop_header.pop();
 }
 
 Temp
-- 
GitLab


From 2e4945bf1d2cf56c3821cc7a36b11c86da284cd7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 20 Feb 2024 10:19:33 +0100
Subject: [PATCH 03/11] aco/spill: keep live-out variables spilled at branch
 blocks

There is no reason to reload early. Leave scheduling to the scheduler.

Totals from 98 (0.12% of 79242) affected shaders: (GFX11)
Instrs: 841944 -> 841995 (+0.01%); split: -0.02%, +0.03%
CodeSize: 4354332 -> 4354544 (+0.00%); split: -0.02%, +0.02%
SpillSGPRs: 2557 -> 2554 (-0.12%)
Latency: 5772080 -> 5772209 (+0.00%); split: -0.00%, +0.01%
InvThroughput: 1694834 -> 1694873 (+0.00%); split: -0.00%, +0.00%
SClause: 16036 -> 16042 (+0.04%); split: -0.07%, +0.11%
Copies: 85117 -> 85125 (+0.01%); split: -0.18%, +0.19%
Branches: 25222 -> 25219 (-0.01%); split: -0.02%, +0.00%
---
 src/amd/compiler/aco_spill.cpp | 148 ++++++---------------------------
 1 file changed, 26 insertions(+), 122 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index e06223c3983ed..d1847c803f620 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -606,53 +606,29 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
 
    /* branch block */
    if (block->linear_preds.size() == 1 && !(block->kind & block_kind_loop_exit)) {
-      /* keep variables spilled if they are alive and not used in the current block */
+      /* keep variables spilled */
       unsigned pred_idx = block->linear_preds[0];
       for (std::pair<Temp, uint32_t> pair : ctx.spills_exit[pred_idx]) {
-         if (pair.first.type() != RegType::sgpr) {
+         if (pair.first.type() != RegType::sgpr)
             continue;
-         }
-         auto next_use_distance_it = next_use_distances.find(pair.first);
-         if (next_use_distance_it != next_use_distances.end() &&
-             next_use_distance_it->second.first != block_idx) {
-            ctx.spills_entry[block_idx].insert(pair);
-            spilled_registers.sgpr += pair.first.size();
-         }
-      }
-      if (block->logical_preds.size() == 1) {
-         pred_idx = block->logical_preds[0];
-         for (std::pair<Temp, uint32_t> pair : ctx.spills_exit[pred_idx]) {
-            if (pair.first.type() != RegType::vgpr) {
-               continue;
-            }
-            auto next_use_distance_it = next_use_distances.find(pair.first);
-            if (next_use_distance_it != next_use_distances.end() &&
-                next_use_distance_it->second.first != block_idx) {
-               ctx.spills_entry[block_idx].insert(pair);
-               spilled_registers.vgpr += pair.first.size();
-            }
-         }
-      }
 
-      /* if register demand is still too high, we just keep all spilled live vars
-       * and process the block */
-      if (block->register_demand.sgpr - spilled_registers.sgpr > ctx.target_pressure.sgpr) {
-         pred_idx = block->linear_preds[0];
-         for (std::pair<Temp, uint32_t> pair : ctx.spills_exit[pred_idx]) {
-            if (pair.first.type() == RegType::sgpr && next_use_distances.count(pair.first) &&
-                ctx.spills_entry[block_idx].insert(pair).second) {
-               spilled_registers.sgpr += pair.first.size();
-            }
+         if (next_use_distances.count(pair.first)) {
+            spilled_registers += pair.first;
+            ctx.spills_entry[block_idx].emplace(pair);
          }
       }
-      if (block->register_demand.vgpr - spilled_registers.vgpr > ctx.target_pressure.vgpr &&
-          block->logical_preds.size() == 1) {
-         pred_idx = block->logical_preds[0];
-         for (std::pair<Temp, uint32_t> pair : ctx.spills_exit[pred_idx]) {
-            if (pair.first.type() == RegType::vgpr && next_use_distances.count(pair.first) &&
-                ctx.spills_entry[block_idx].insert(pair).second) {
-               spilled_registers.vgpr += pair.first.size();
-            }
+
+      if (block->logical_preds.empty())
+         return spilled_registers;
+
+      pred_idx = block->logical_preds[0];
+      for (std::pair<Temp, uint32_t> pair : ctx.spills_exit[pred_idx]) {
+         if (pair.first.type() != RegType::vgpr)
+            continue;
+
+         if (next_use_distances.count(pair.first)) {
+            spilled_registers += pair.first;
+            ctx.spills_entry[block_idx].emplace(pair);
          }
       }
 
@@ -767,100 +743,28 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
 void
 add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
 {
-   /* no coupling code necessary */
+   /* No coupling code necessary */
    if (block->linear_preds.size() == 0)
       return;
 
-   std::vector<aco_ptr<Instruction>> instructions;
-   /* branch block: TODO take other branch into consideration */
+   /* Branch block: update renames */
    if (block->linear_preds.size() == 1 &&
        !(block->kind & (block_kind_loop_exit | block_kind_loop_header))) {
       assert(ctx.processed[block->linear_preds[0]]);
       assert(ctx.register_demand[block_idx].size() == block->instructions.size());
-      std::vector<RegisterDemand> reg_demand;
-      unsigned insert_idx = 0;
-      RegisterDemand demand_before = get_demand_before(ctx, block_idx, 0);
-
-      for (std::pair<const Temp, std::pair<uint32_t, uint32_t>>& live :
-           ctx.next_use_distances_start[block_idx]) {
-         const unsigned pred_idx = block->linear_preds[0];
-
-         if (!live.first.is_linear())
-            continue;
-         /* still spilled */
-         if (ctx.spills_entry[block_idx].count(live.first))
-            continue;
 
-         /* in register at end of predecessor */
-         auto spills_exit_it = ctx.spills_exit[pred_idx].find(live.first);
-         if (spills_exit_it == ctx.spills_exit[pred_idx].end()) {
-            std::map<Temp, Temp>::iterator it = ctx.renames[pred_idx].find(live.first);
-            if (it != ctx.renames[pred_idx].end())
-               ctx.renames[block_idx].insert(*it);
-            continue;
+      ctx.renames[block_idx] = ctx.renames[block->linear_preds[0]];
+      if (!block->logical_preds.empty() && block->logical_preds[0] != block->linear_preds[0]) {
+         for (auto it : ctx.renames[block->logical_preds[0]]) {
+            if (it.first.type() == RegType::vgpr)
+               ctx.renames[block_idx].insert_or_assign(it.first, it.second);
          }
-
-         /* variable is spilled at predecessor and live at current block: create reload instruction */
-         Temp new_name = ctx.program->allocateTmp(live.first.regClass());
-         aco_ptr<Instruction> reload = do_reload(ctx, live.first, new_name, spills_exit_it->second);
-         instructions.emplace_back(std::move(reload));
-         reg_demand.push_back(demand_before);
-         ctx.renames[block_idx][live.first] = new_name;
-      }
-
-      if (block->logical_preds.size() == 1) {
-         do {
-            assert(insert_idx < block->instructions.size());
-            instructions.emplace_back(std::move(block->instructions[insert_idx]));
-            reg_demand.push_back(ctx.register_demand[block_idx][insert_idx]);
-            insert_idx++;
-         } while (instructions.back()->opcode != aco_opcode::p_logical_start);
-
-         unsigned pred_idx = block->logical_preds[0];
-         for (std::pair<const Temp, std::pair<uint32_t, uint32_t>>& live :
-              ctx.next_use_distances_start[block_idx]) {
-            if (live.first.is_linear())
-               continue;
-            /* still spilled */
-            if (ctx.spills_entry[block_idx].count(live.first))
-               continue;
-
-            /* in register at end of predecessor */
-            auto spills_exit_it = ctx.spills_exit[pred_idx].find(live.first);
-            if (spills_exit_it == ctx.spills_exit[pred_idx].end()) {
-               std::map<Temp, Temp>::iterator it = ctx.renames[pred_idx].find(live.first);
-               if (it != ctx.renames[pred_idx].end())
-                  ctx.renames[block_idx].insert(*it);
-               continue;
-            }
-
-            /* variable is spilled at predecessor and live at current block:
-             * create reload instruction */
-            Temp new_name = ctx.program->allocateTmp(live.first.regClass());
-            aco_ptr<Instruction> reload =
-               do_reload(ctx, live.first, new_name, spills_exit_it->second);
-            instructions.emplace_back(std::move(reload));
-            reg_demand.emplace_back(reg_demand.back());
-            ctx.renames[block_idx][live.first] = new_name;
-         }
-      }
-
-      /* combine new reload instructions with original block */
-      if (!instructions.empty()) {
-         reg_demand.insert(reg_demand.end(),
-                           std::next(ctx.register_demand[block->index].begin(), insert_idx),
-                           ctx.register_demand[block->index].end());
-         ctx.register_demand[block_idx] = std::move(reg_demand);
-         instructions.insert(instructions.end(),
-                             std::move_iterator<std::vector<aco_ptr<Instruction>>::iterator>(
-                                std::next(block->instructions.begin(), insert_idx)),
-                             std::move_iterator<std::vector<aco_ptr<Instruction>>::iterator>(
-                                block->instructions.end()));
-         block->instructions = std::move(instructions);
       }
       return;
    }
 
+   std::vector<aco_ptr<Instruction>> instructions;
+
    /* loop header and merge blocks: check if all (linear) predecessors have been processed */
    for (ASSERTED unsigned pred : block->linear_preds)
       assert(ctx.processed[pred]);
-- 
GitLab


From d7a543292b504bc80b0727e1b7af5887e08e2627 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 19 Feb 2024 14:19:52 +0100
Subject: [PATCH 04/11] aco/spill: don't prefer to spill phis at merge blocks

Totals from 44 (0.06% of 79242) affected shaders: (GFX11)
Instrs: 165578 -> 165545 (-0.02%); split: -0.08%, +0.06%
CodeSize: 833528 -> 832988 (-0.06%); split: -0.11%, +0.04%
SpillSGPRs: 346 -> 329 (-4.91%)
Latency: 1176341 -> 1176231 (-0.01%); split: -0.02%, +0.01%
InvThroughput: 235771 -> 235761 (-0.00%); split: -0.01%, +0.01%
SClause: 3287 -> 3289 (+0.06%); split: -0.21%, +0.27%
Copies: 16290 -> 16299 (+0.06%); split: -0.62%, +0.68%
Branches: 3633 -> 3641 (+0.22%)
---
 src/amd/compiler/aco_spill.cpp | 17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index d1847c803f620..0d2f3a9cb92e7 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -687,11 +687,14 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       std::vector<unsigned>& preds =
          phi->opcode == aco_opcode::p_phi ? block->logical_preds : block->linear_preds;
       bool is_all_spilled = true;
+      bool is_partial_spill = false;
       for (unsigned i = 0; i < phi->operands.size(); i++) {
          if (phi->operands[i].isUndefined())
             continue;
-         is_all_spilled &= phi->operands[i].isTemp() &&
-                           ctx.spills_exit[preds[i]].count(phi->operands[i].getTemp());
+         bool spilled = phi->operands[i].isTemp() &&
+                        ctx.spills_exit[preds[i]].count(phi->operands[i].getTemp());
+         is_all_spilled &= spilled;
+         is_partial_spill |= spilled;
       }
 
       if (is_all_spilled) {
@@ -701,7 +704,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          spilled_registers += phi->definitions[0].getTemp();
       } else {
          /* Phis might increase the register pressure. */
-         partial_spills[phi->definitions[0].getTemp()] = true;
+         partial_spills[phi->definitions[0].getTemp()] = is_partial_spill;
       }
    }
 
@@ -713,19 +716,19 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       assert(!partial_spills.empty());
       std::map<Temp, bool>::iterator it = partial_spills.begin();
       Temp to_spill = Temp();
-      bool is_spilled_or_phi = false;
+      bool is_partial_spill = false;
       unsigned distance = 0;
       RegType type = reg_pressure.vgpr > ctx.target_pressure.vgpr ? RegType::vgpr : RegType::sgpr;
 
       while (it != partial_spills.end()) {
          assert(!ctx.spills_entry[block_idx].count(it->first));
 
-         if (it->first.type() == type && ((it->second && !is_spilled_or_phi) ||
-                                          (it->second == is_spilled_or_phi &&
+         if (it->first.type() == type && ((it->second && !is_partial_spill) ||
+                                          (it->second == is_partial_spill &&
                                            next_use_distances.at(it->first).second > distance))) {
             distance = next_use_distances.at(it->first).second;
             to_spill = it->first;
-            is_spilled_or_phi = it->second;
+            is_partial_spill = it->second;
          }
          ++it;
       }
-- 
GitLab


From 37b17e06d86a2e5d1f6d5936477a9ad3663b01da Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 21 Feb 2024 16:48:18 +0100
Subject: [PATCH 05/11] aco/spill: avoid re-spilling loop-carried variables in
 process_block()

If a variable is spilled at the loop-header of the current loop,
there is no need to spill it redundantly. Instead, re-use the
spill-slot from the loop-header.
---
 src/amd/compiler/aco_spill.cpp | 39 ++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 0d2f3a9cb92e7..b05b608007772 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -1148,25 +1148,46 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
          while ((new_demand - spilled_registers).exceeds(ctx.target_pressure)) {
             unsigned distance = 0;
             Temp to_spill;
-            bool do_rematerialize = false;
+            unsigned do_rematerialize = 0;
+            unsigned avoid_respill = 0;
             RegType type = RegType::sgpr;
             if (new_demand.vgpr - spilled_registers.vgpr > ctx.target_pressure.vgpr)
                type = RegType::vgpr;
 
             for (std::pair<Temp, uint32_t> pair : ctx.local_next_use_distance[idx]) {
-               if (pair.first.type() != type)
+               if (pair.first.type() != type || current_spills.count(pair.first))
                   continue;
-               bool can_rematerialize = ctx.remat.count(pair.first);
-               if (((pair.second > distance && can_rematerialize == do_rematerialize) ||
-                    (can_rematerialize && !do_rematerialize && pair.second > idx)) &&
-                   !current_spills.count(pair.first)) {
+
+               unsigned can_rematerialize = ctx.remat.count(pair.first);
+               unsigned loop_variable =
+                  block->loop_nest_depth &&
+                  ctx.spills_entry[ctx.loop_header.top()->index].count(pair.first);
+               if (avoid_respill > loop_variable || do_rematerialize > can_rematerialize)
+                  continue;
+
+               if (can_rematerialize > do_rematerialize || loop_variable > avoid_respill ||
+                   pair.second > distance) {
+                  /* Don't spill operands */
+                  if (pair.second <= idx)
+                     continue;
+
                   to_spill = pair.first;
                   distance = pair.second;
                   do_rematerialize = can_rematerialize;
+                  avoid_respill = loop_variable;
                }
             }
-
             assert(distance != 0 && distance > idx);
+
+            if (avoid_respill) {
+               /* This variable is spilled at the loop-header of the current loop.
+                * Re-use the spill-slot in order to avoid an extra store.
+                */
+               current_spills[to_spill] = ctx.spills_entry[ctx.loop_header.top()->index][to_spill];
+               spilled_registers += to_spill;
+               continue;
+            }
+
             uint32_t spill_id = ctx.allocate_spill_id(to_spill.regClass());
 
             /* add interferences with currently spilled variables */
@@ -1174,6 +1195,10 @@ process_block(spill_ctx& ctx, unsigned block_idx, Block* block, RegisterDemand s
                ctx.add_interference(spill_id, pair.second);
             for (std::pair<const Temp, std::pair<Temp, uint32_t>>& pair : reloads)
                ctx.add_interference(spill_id, pair.second.second);
+            if (block->loop_nest_depth) {
+               for (auto pair : ctx.spills_entry[ctx.loop_header.top()->index])
+                  ctx.add_interference(spill_id, pair.second);
+            }
 
             current_spills[to_spill] = spill_id;
             spilled_registers += to_spill;
-- 
GitLab


From b47bde5c572a7bc289ac82727f9ba1678bdb5abb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 21 Feb 2024 17:01:17 +0100
Subject: [PATCH 06/11] aco/spill: avoid re-spilling loop-carried variables in
 add_coupling_code()

These variables only need to be spilled once at the loop-preheader.
---
 src/amd/compiler/aco_spill.cpp | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index b05b608007772..0b4f5b09ef5e6 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -856,6 +856,10 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
          pair.first.is_linear() ? block->linear_preds : block->logical_preds;
 
       for (unsigned pred_idx : preds) {
+         /* variable is dead at predecessor, it must be from a phi: this works because of CSSA form */
+         if (!ctx.next_use_distances_end[pred_idx].count(pair.first))
+            continue;
+
          /* variable is already spilled at predecessor */
          auto spilled = ctx.spills_exit[pred_idx].find(pair.first);
          if (spilled != ctx.spills_exit[pred_idx].end()) {
@@ -864,10 +868,6 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
             continue;
          }
 
-         /* variable is dead at predecessor, it must be from a phi: this works because of CSSA form */
-         if (!ctx.next_use_distances_end[pred_idx].count(pair.first))
-            continue;
-
          /* add interferences between spilled variable and predecessors exit spills */
          for (std::pair<Temp, uint32_t> exit_spill : ctx.spills_exit[pred_idx]) {
             if (exit_spill.first == pair.first)
@@ -875,6 +875,16 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
             ctx.add_interference(exit_spill.second, pair.second);
          }
 
+         /* If this variable is spilled through the entire loop, no need to re-spill.
+          * It can be reloaded from the same spill-slot it got at the loop-preheader.
+          */
+         if (block->loop_nest_depth &&
+             ctx.program->blocks[pred_idx].loop_nest_depth >= block->loop_nest_depth &&
+             ctx.spills_entry[ctx.loop_header.top()->index].count(pair.first)) {
+            ctx.spills_exit[pred_idx].insert(pair);
+            continue;
+         }
+
          /* variable is in register at predecessor and has to be spilled */
          /* rename if necessary */
          Temp var = pair.first;
-- 
GitLab


From 52e3447ae25dacf2e2f4e130e88241c29dd236a5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 22 Feb 2024 17:12:17 +0100
Subject: [PATCH 07/11] aco/spill: keep loop-carried variables spilled at loop
 headers

Now, that we avoid re-spilling loop-carried variables, we can
keep them spilled at loop-headers.

Totals from 57 (0.07% of 79242) affected shaders: (GFX11)
Instrs: 779128 -> 777525 (-0.21%); split: -0.28%, +0.07%
CodeSize: 3971864 -> 3961320 (-0.27%); split: -0.32%, +0.06%
SpillSGPRs: 1553 -> 1151 (-25.89%)
SpillVGPRs: 292 -> 274 (-6.16%)
Scratch: 26880 -> 24320 (-9.52%)
Latency: 4463433 -> 4464512 (+0.02%); split: -0.03%, +0.05%
InvThroughput: 1076521 -> 1077133 (+0.06%); split: -0.03%, +0.09%
VClause: 16267 -> 16306 (+0.24%)
SClause: 15673 -> 15670 (-0.02%); split: -0.10%, +0.08%
Copies: 67673 -> 67119 (-0.82%); split: -1.29%, +0.47%
Branches: 23616 -> 23620 (+0.02%); split: -0.07%, +0.08%
---
 src/amd/compiler/aco_spill.cpp | 12 +++++-------
 1 file changed, 5 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 0b4f5b09ef5e6..c7a1fd059d46c 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -524,15 +524,13 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          if (it == next_use_distances.end())
             continue;
 
-         /* keep constants and live-through variables spilled */
-         if (it->second.first >= loop_end || ctx.remat.count(spilled.first)) {
-            ctx.spills_entry[block_idx][spilled.first] = spilled.second;
-            spilled_registers += spilled.first;
-            loop_demand -= spilled.first;
-         }
+         /* keep live-through variables spilled */
+         ctx.spills_entry[block_idx][spilled.first] = spilled.second;
+         spilled_registers += spilled.first;
+         loop_demand -= spilled.first;
       }
 
-      /* select live-through variables and constants */
+      /* select more live-through variables and constants */
       RegType type = RegType::vgpr;
       while (loop_demand.exceeds(ctx.target_pressure)) {
          /* if VGPR demand is low enough, select SGPRs */
-- 
GitLab


From 20ede22bbaa04cf36ce27a02f50464cbd4ff9b3a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 22 Feb 2024 17:21:05 +0100
Subject: [PATCH 08/11] aco/spill: keep loop-carried variables spilled at merge
 blocks

If loop-carried variables are partially spilled at some predecessor,
keep them spilled without extra instruction.

Also slightly refactors the code for better readability.

Totals from 55 (0.07% of 79242) affected shaders: (GFX11)
Instrs: 179743 -> 179317 (-0.24%); split: -0.28%, +0.05%
CodeSize: 914060 -> 912212 (-0.20%); split: -0.24%, +0.04%
SpillVGPRs: 274 -> 256 (-6.57%)
Scratch: 24320 -> 24832 (+2.11%)
Latency: 1518480 -> 1517317 (-0.08%); split: -0.09%, +0.01%
InvThroughput: 334298 -> 333810 (-0.15%); split: -0.15%, +0.01%
VClause: 2375 -> 2350 (-1.05%)
SClause: 3327 -> 3332 (+0.15%); split: -0.33%, +0.48%
Copies: 17100 -> 16883 (-1.27%); split: -1.84%, +0.57%
Branches: 3614 -> 3604 (-0.28%)
---
 src/amd/compiler/aco_spill.cpp | 25 +++++++++++++++----------
 1 file changed, 15 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index c7a1fd059d46c..44a180dc2b2bb 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -644,10 +644,14 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
        * it. Otherwise, if any predecessor reloads it, ensure it's reloaded on all other
        * predecessors. The idea is that it's better in practice to rematerialize redundantly than to
        * create lots of phis. */
-      /* TODO: test this idea with more than Dawn of War III shaders (the current pipeline-db
-       * doesn't seem to exercise this path much) */
-      bool remat = ctx.remat.count(pair.first);
-      bool spill = !remat;
+      const bool remat = ctx.remat.count(pair.first);
+      /* If the variable is spilled at the current loop-header, spilling is essentially for free
+       * while reloading is not. Thus, keep them spilled if they are at least partially spilled.
+       */
+      const bool avoid_respill =
+         block->loop_nest_depth && ctx.spills_entry[ctx.loop_header.top()->index].count(pair.first);
+      bool spill = true;
+      bool partial_spill = false;
       uint32_t spill_id = 0;
       for (unsigned pred_idx : preds) {
          /* variable is not even live at the predecessor: probably from a phi */
@@ -656,22 +660,22 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
             break;
          }
          if (!ctx.spills_exit[pred_idx].count(pair.first)) {
-            partial_spills.emplace(pair.first, false);
-            if (!remat)
-               spill = false;
+            spill = false;
          } else {
-            partial_spills[pair.first] = true;
+            partial_spill = true;
             /* it might be that on one incoming path, the variable has a different spill_id, but
              * add_couple_code() will take care of that. */
             spill_id = ctx.spills_exit[pred_idx][pair.first];
-            if (remat)
-               spill = true;
          }
       }
+      spill |= (remat && partial_spill);
+      spill |= (avoid_respill && partial_spill);
       if (spill) {
          ctx.spills_entry[block_idx][pair.first] = spill_id;
          partial_spills.erase(pair.first);
          spilled_registers += pair.first;
+      } else {
+         partial_spills[pair.first] = partial_spill;
       }
    }
 
@@ -700,6 +704,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          ctx.spills_entry[block_idx][phi->definitions[0].getTemp()] =
             ctx.allocate_spill_id(phi->definitions[0].regClass());
          spilled_registers += phi->definitions[0].getTemp();
+         partial_spills.erase(phi->definitions[0].getTemp());
       } else {
          /* Phis might increase the register pressure. */
          partial_spills[phi->definitions[0].getTemp()] = is_partial_spill;
-- 
GitLab


From 5c8ef91a0dffe49fd6790fb79323647174b0e06d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 21 Feb 2024 14:57:36 +0100
Subject: [PATCH 09/11] aco/spill: select more loop-carried variables to be
 spilled

This changes the heuristic to also spill live-through variables
if they are used within the loop if the register pressure is too high.

Totals from 83 (0.10% of 79242) affected shaders: (GFX11)
Instrs: 1944025 -> 1941665 (-0.12%); split: -0.20%, +0.08%
CodeSize: 9964568 -> 9954652 (-0.10%); split: -0.21%, +0.12%
SpillSGPRs: 3801 -> 3071 (-19.21%); split: -19.52%, +0.32%
SpillVGPRs: 1184 -> 1037 (-12.42%); split: -13.43%, +1.01%
Scratch: 89856 -> 88320 (-1.71%); split: -1.99%, +0.28%
Latency: 14235013 -> 14499869 (+1.86%); split: -0.05%, +1.91%
InvThroughput: 4268657 -> 4399911 (+3.07%); split: -0.02%, +3.09%
VClause: 45818 -> 45857 (+0.09%); split: -0.05%, +0.14%
SClause: 37674 -> 37604 (-0.19%); split: -0.27%, +0.08%
Copies: 184824 -> 181998 (-1.53%); split: -1.71%, +0.18%
Branches: 60457 -> 60447 (-0.02%); split: -0.13%, +0.11%
---
 src/amd/compiler/aco_spill.cpp | 25 +++++++++----------------
 1 file changed, 9 insertions(+), 16 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 44a180dc2b2bb..34ce10d057de2 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -500,7 +500,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
    const auto& next_use_distances = ctx.next_use_distances_start[block_idx];
 
    /* loop header block */
-   if (block->loop_nest_depth > ctx.program->blocks[block_idx - 1].loop_nest_depth) {
+   if (block->kind & block_kind_loop_header) {
       assert(block->linear_preds[0] == block_idx - 1);
       assert(block->logical_preds[0] == block_idx - 1);
 
@@ -511,11 +511,8 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
       RegisterDemand reg_pressure = get_live_in_demand(ctx, block_idx);
       RegisterDemand loop_demand = reg_pressure;
       unsigned i = block_idx;
-      while (ctx.program->blocks[i].loop_nest_depth >= block->loop_nest_depth) {
-         assert(ctx.program->blocks.size() > i);
+      while (ctx.program->blocks[i].loop_nest_depth >= block->loop_nest_depth)
          loop_demand.update(ctx.program->blocks[i++].register_demand);
-      }
-      unsigned loop_end = i;
 
       for (auto spilled : ctx.spills_exit[block_idx - 1]) {
          auto it = next_use_distances.find(spilled.first);
@@ -541,15 +538,17 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
             break;
 
          unsigned distance = 0;
+         unsigned remat = 0;
          Temp to_spill;
          for (const std::pair<const Temp, std::pair<uint32_t, uint32_t>>& pair :
               next_use_distances) {
-            if (pair.first.type() == type &&
-                (pair.second.first >= loop_end ||
-                 (ctx.remat.count(pair.first) && type == RegType::sgpr)) &&
-                pair.second.second > distance && !ctx.spills_entry[block_idx].count(pair.first)) {
+            unsigned can_remat = ctx.remat.count(pair.first);
+            if (pair.first.type() == type && !ctx.spills_entry[block_idx].count(pair.first) &&
+                ctx.next_use_distances_end[block_idx - 1].count(pair.first) &&
+                (can_remat > remat || (can_remat == remat && pair.second.second > distance))) {
                to_spill = pair.first;
                distance = pair.second.second;
+               remat = can_remat;
             }
          }
 
@@ -561,13 +560,7 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
             continue;
          }
 
-         uint32_t spill_id;
-         if (!ctx.spills_exit[block_idx - 1].count(to_spill)) {
-            spill_id = ctx.allocate_spill_id(to_spill.regClass());
-         } else {
-            spill_id = ctx.spills_exit[block_idx - 1][to_spill];
-         }
-
+         uint32_t spill_id = ctx.allocate_spill_id(to_spill.regClass());
          ctx.spills_entry[block_idx][to_spill] = spill_id;
          spilled_registers += to_spill;
          loop_demand -= to_spill;
-- 
GitLab


From 6ff64be9eca69d6b22fd1e4f83c377a117895d8c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 28 Feb 2024 10:41:12 +0100
Subject: [PATCH 10/11] aco/spill: don't allocate extra spill_id for phi
 operands in add_coupling_code()

We can re-use the phi definition's spill_id.
---
 src/amd/compiler/aco_spill.cpp | 11 ++++-------
 1 file changed, 4 insertions(+), 7 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 34ce10d057de2..6c9192ae7e10d 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -815,17 +815,14 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
             }
          }
 
-         uint32_t spill_id = ctx.allocate_spill_id(phi->definitions[0].regClass());
-
-         /* add interferences and affinity */
+         /* add interferences */
          for (std::pair<Temp, uint32_t> pair : ctx.spills_exit[pred_idx])
-            ctx.add_interference(spill_id, pair.second);
-         ctx.add_affinity(def_spill_id, spill_id);
+            ctx.add_interference(def_spill_id, pair.second);
 
          aco_ptr<Pseudo_instruction> spill{
             create_instruction<Pseudo_instruction>(aco_opcode::p_spill, Format::PSEUDO, 2, 0)};
          spill->operands[0] = spill_op;
-         spill->operands[1] = Operand::c32(spill_id);
+         spill->operands[1] = Operand::c32(def_spill_id);
          Block& pred = ctx.program->blocks[pred_idx];
          unsigned idx = pred.instructions.size();
          do {
@@ -838,7 +835,7 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
 
          /* Add the original name to predecessor's spilled variables */
          if (spill_op.isTemp())
-            ctx.spills_exit[pred_idx][phi->operands[i].getTemp()] = spill_id;
+            ctx.spills_exit[pred_idx][phi->operands[i].getTemp()] = def_spill_id;
       }
 
       /* remove phi from instructions */
-- 
GitLab


From 9eb256165f23ee29377cd83241cf521bffd4a5e3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 28 Feb 2024 11:43:19 +0100
Subject: [PATCH 11/11] aco/spill: add spills_entry interferences only when
 necessary

For variables which are already spilled in previous blocks,
the interferences already exist.
---
 src/amd/compiler/aco_spill.cpp | 34 ++++++++++++++++++++--------------
 1 file changed, 20 insertions(+), 14 deletions(-)

diff --git a/src/amd/compiler/aco_spill.cpp b/src/amd/compiler/aco_spill.cpp
index 6c9192ae7e10d..b5a1658163177 100644
--- a/src/amd/compiler/aco_spill.cpp
+++ b/src/amd/compiler/aco_spill.cpp
@@ -560,7 +560,12 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
             continue;
          }
 
-         uint32_t spill_id = ctx.allocate_spill_id(to_spill.regClass());
+         const uint32_t spill_id = ctx.allocate_spill_id(to_spill.regClass());
+
+         /* Add new interferences */
+         for (std::pair<Temp, uint32_t> pair : ctx.spills_entry[block_idx])
+            ctx.add_interference(spill_id, pair.second);
+
          ctx.spills_entry[block_idx][to_spill] = spill_id;
          spilled_registers += to_spill;
          loop_demand -= to_spill;
@@ -587,7 +592,13 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
             }
          }
          assert(distance != 0);
-         ctx.spills_entry[block_idx][to_spill] = ctx.allocate_spill_id(to_spill.regClass());
+         const uint32_t spill_id = ctx.allocate_spill_id(to_spill.regClass());
+
+         /* Add new interferences */
+         for (std::pair<Temp, uint32_t> pair : ctx.spills_entry[block_idx])
+            ctx.add_interference(spill_id, pair.second);
+
+         ctx.spills_entry[block_idx][to_spill] = spill_id;
          spilled_registers += to_spill;
          reg_pressure -= to_spill;
       }
@@ -729,8 +740,13 @@ init_live_in_vars(spill_ctx& ctx, Block* block, unsigned block_idx)
          ++it;
       }
       assert(distance != 0);
+      const uint32_t spill_id = ctx.allocate_spill_id(to_spill.regClass());
 
-      ctx.spills_entry[block_idx][to_spill] = ctx.allocate_spill_id(to_spill.regClass());
+      /* Add new interferences */
+      for (std::pair<Temp, uint32_t> pair : ctx.spills_entry[block_idx])
+         ctx.add_interference(spill_id, pair.second);
+
+      ctx.spills_entry[block_idx][to_spill] = spill_id;
       partial_spills.erase(to_spill);
       spilled_registers += to_spill;
       reg_pressure -= to_spill;
@@ -862,11 +878,8 @@ add_coupling_code(spill_ctx& ctx, Block* block, unsigned block_idx)
          }
 
          /* add interferences between spilled variable and predecessors exit spills */
-         for (std::pair<Temp, uint32_t> exit_spill : ctx.spills_exit[pred_idx]) {
-            if (exit_spill.first == pair.first)
-               continue;
+         for (std::pair<Temp, uint32_t> exit_spill : ctx.spills_exit[pred_idx])
             ctx.add_interference(exit_spill.second, pair.second);
-         }
 
          /* If this variable is spilled through the entire loop, no need to re-spill.
           * It can be reloaded from the same spill-slot it got at the loop-preheader.
@@ -1241,13 +1254,6 @@ spill_block(spill_ctx& ctx, unsigned block_idx)
    /* determine set of variables which are spilled at the beginning of the block */
    RegisterDemand spilled_registers = init_live_in_vars(ctx, block, block_idx);
 
-   /* add interferences for spilled variables */
-   for (auto it = ctx.spills_entry[block_idx].begin(); it != ctx.spills_entry[block_idx].end();
-        ++it) {
-      for (auto it2 = std::next(it); it2 != ctx.spills_entry[block_idx].end(); ++it2)
-         ctx.add_interference(it->second, it2->second);
-   }
-
    bool is_loop_header = block->loop_nest_depth && ctx.loop_header.top()->index == block_idx;
    if (!is_loop_header) {
       /* add spill/reload code on incoming control flow edges */
-- 
GitLab

