From 858f2d0897bf56fac418a4de72c458fe2bf652b2 Mon Sep 17 00:00:00 2001
From: Daniel Stone <daniels@collabora.com>
Date: Wed, 11 May 2022 19:13:48 +0100
Subject: [PATCH 01/13] vulkan/wsi: Add stub interface for VK_KHR_present_wait

Signed-off-by: Daniel Stone <daniels@collabora.com>
Co-authored-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/vulkan/wsi/wsi_common.c         | 17 ++++++++++++++++-
 src/vulkan/wsi/wsi_common_display.c |  1 +
 src/vulkan/wsi/wsi_common_private.h |  4 ++++
 src/vulkan/wsi/wsi_common_wayland.c |  1 +
 src/vulkan/wsi/wsi_common_win32.c   |  5 +++--
 src/vulkan/wsi/wsi_common_x11.c     |  1 +
 6 files changed, 26 insertions(+), 3 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 5532c44d7b00..710d0c9606d1 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -1080,6 +1080,8 @@ wsi_common_queue_present(const struct wsi_device *wsi,
 
    const VkPresentRegionsKHR *regions =
       vk_find_struct_const(pPresentInfo->pNext, PRESENT_REGIONS_KHR);
+   const VkPresentIdKHR *present_ids =
+      vk_find_struct_const(pPresentInfo->pNext, PRESENT_ID_KHR);
 
    for (uint32_t i = 0; i < pPresentInfo->swapchainCount; i++) {
       VK_FROM_HANDLE(wsi_swapchain, swapchain, pPresentInfo->pSwapchains[i]);
@@ -1227,7 +1229,11 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       if (regions && regions->pRegions)
          region = &regions->pRegions[i];
 
-      result = swapchain->queue_present(swapchain, image_index, region);
+      uint64_t present_id = 0;
+      if (present_ids && present_ids->pPresentIds)
+         present_id = present_ids->pPresentIds[i];
+
+      result = swapchain->queue_present(swapchain, image_index, present_id, region);
       if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)
          goto fail_present;
 
@@ -1789,3 +1795,12 @@ wsi_configure_cpu_image(const struct wsi_swapchain *chain,
 
    return VK_SUCCESS;
 }
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wsi_WaitForPresentKHR(VkDevice device, VkSwapchainKHR _swapchain,
+                      uint64_t presentId, uint64_t timeout)
+{
+   VK_FROM_HANDLE(wsi_swapchain, swapchain, _swapchain);
+   assert(swapchain->wait_for_present);
+   return swapchain->wait_for_present(swapchain, presentId, timeout);
+}
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index a41fabe7da58..8dd972742587 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -1910,6 +1910,7 @@ _wsi_display_queue_next(struct wsi_swapchain *drv_chain)
 static VkResult
 wsi_display_queue_present(struct wsi_swapchain *drv_chain,
                           uint32_t image_index,
+                          uint64_t present_id,
                           const VkPresentRegionKHR *damage)
 {
    struct wsi_display_swapchain *chain =
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index fe3e85556b81..483b313888f5 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -162,7 +162,11 @@ struct wsi_swapchain {
                                   uint32_t *image_index);
    VkResult (*queue_present)(struct wsi_swapchain *swap_chain,
                              uint32_t image_index,
+                             uint64_t present_id,
                              const VkPresentRegionKHR *damage);
+   VkResult (*wait_for_present)(struct wsi_swapchain *swap_chain,
+                                uint64_t present_id,
+                                uint64_t timeout);
 };
 
 bool
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index dc5a38363154..6a337fc24e96 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -1545,6 +1545,7 @@ static const struct wl_callback_listener frame_listener = {
 static VkResult
 wsi_wl_swapchain_queue_present(struct wsi_swapchain *wsi_chain,
                                uint32_t image_index,
+                               uint64_t present_id,
                                const VkPresentRegionKHR *damage)
 {
    struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
diff --git a/src/vulkan/wsi/wsi_common_win32.c b/src/vulkan/wsi/wsi_common_win32.c
index bef81028bde3..d2227fccc4f0 100644
--- a/src/vulkan/wsi/wsi_common_win32.c
+++ b/src/vulkan/wsi/wsi_common_win32.c
@@ -400,8 +400,9 @@ wsi_win32_acquire_next_image(struct wsi_swapchain *drv_chain,
 
 static VkResult
 wsi_win32_queue_present(struct wsi_swapchain *drv_chain,
-                          uint32_t image_index,
-                          const VkPresentRegionKHR *damage)
+                        uint32_t image_index,
+                        uint64_t present_id,
+                        const VkPresentRegionKHR *damage)
 {
    struct wsi_win32_swapchain *chain = (struct wsi_win32_swapchain *) drv_chain;
    assert(image_index < chain->base.image_count);
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index a3c4538366fd..edd47cb9a7c9 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1426,6 +1426,7 @@ x11_acquire_next_image(struct wsi_swapchain *anv_chain,
 static VkResult
 x11_queue_present(struct wsi_swapchain *anv_chain,
                   uint32_t image_index,
+                  uint64_t present_id,
                   const VkPresentRegionKHR *damage)
 {
    struct x11_swapchain *chain = (struct x11_swapchain *)anv_chain;
-- 
GitLab


From fe926cb1ffbe0891add8a2978505fe09c0afa049 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 21 Oct 2022 15:00:32 +0200
Subject: [PATCH 02/13] vulkan/wsi: Refactor out
 wsi_init_pthread_cond_monotonic.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
---
 src/vulkan/wsi/wsi_common.c         | 27 +++++++++++++++++++++++++++
 src/vulkan/wsi/wsi_common_display.c | 25 -------------------------
 src/vulkan/wsi/wsi_common_private.h |  5 +++++
 3 files changed, 32 insertions(+), 25 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 710d0c9606d1..ae89f5589c71 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -26,6 +26,7 @@
 #include "util/u_debug.h"
 #include "util/macros.h"
 #include "util/os_file.h"
+#include "util/os_time.h"
 #include "util/xmlconfig.h"
 #include "vk_device.h"
 #include "vk_fence.h"
@@ -325,6 +326,32 @@ configure_image(const struct wsi_swapchain *chain,
    }
 }
 
+#if defined(HAVE_PTHREAD) && !defined(_WIN32)
+bool
+wsi_init_pthread_cond_monotonic(pthread_cond_t *cond)
+{
+   pthread_condattr_t condattr;
+   bool ret = false;
+
+   if (pthread_condattr_init(&condattr) != 0)
+      goto fail_attr_init;
+
+   if (pthread_condattr_setclock(&condattr, CLOCK_MONOTONIC) != 0)
+      goto fail_attr_set;
+
+   if (pthread_cond_init(cond, &condattr) != 0)
+      goto fail_cond_init;
+
+   ret = true;
+
+fail_cond_init:
+fail_attr_set:
+   pthread_condattr_destroy(&condattr);
+fail_attr_init:
+   return ret;
+}
+#endif
+
 VkResult
 wsi_swapchain_init(const struct wsi_device *wsi,
                    struct wsi_swapchain *chain,
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 8dd972742587..ba1599330647 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -2015,31 +2015,6 @@ fail_init_images:
    return result;
 }
 
-static bool
-wsi_init_pthread_cond_monotonic(pthread_cond_t *cond)
-{
-   pthread_condattr_t condattr;
-   bool ret = false;
-
-   if (pthread_condattr_init(&condattr) != 0)
-      goto fail_attr_init;
-
-   if (pthread_condattr_setclock(&condattr, CLOCK_MONOTONIC) != 0)
-      goto fail_attr_set;
-
-   if (pthread_cond_init(cond, &condattr) != 0)
-      goto fail_cond_init;
-
-   ret = true;
-
-fail_cond_init:
-fail_attr_set:
-   pthread_condattr_destroy(&condattr);
-fail_attr_init:
-   return ret;
-}
-
-
 /*
  * Local version fo the libdrm helper. Added to avoid depending on bleeding
  * edge version of the library.
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 483b313888f5..1b1ed138465f 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -336,4 +336,9 @@ wsi_display_setup_syncobj_fd(struct wsi_device *wsi_device,
 VK_DEFINE_NONDISP_HANDLE_CASTS(wsi_swapchain, base, VkSwapchainKHR,
                                VK_OBJECT_TYPE_SWAPCHAIN_KHR)
 
+#if defined(HAVE_PTHREAD) && !defined(_WIN32)
+bool
+wsi_init_pthread_cond_monotonic(pthread_cond_t *cond);
+#endif
+
 #endif /* WSI_COMMON_PRIVATE_H */
-- 
GitLab


From c01a4cd2a6ebeb8e726dde76c10ee25e51ed485a Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 24 Oct 2022 14:47:51 +0200
Subject: [PATCH 03/13] vulkan/wsi: Add mechanism to wait for WSI semaphore
 unsignal.

When vkWaitForPresentKHR succeeds, we are guaranteed
that any dependent semaphores have been unsignalled.

In an explicit sync world, we are guaranteed this automatically by
having a present complete, since that event must follow a semaphore wait
completion.

However, if the swapchain image is implicitly
synchronized, the semaphore might technically not have been unsignaled
before the present complete event triggers.

Present IDs must be signalled in monotonic order, same as timeline
semaphores.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/vulkan/wsi/wsi_common.c         | 73 +++++++++++++++++++++++++++++
 src/vulkan/wsi/wsi_common.h         |  7 +++
 src/vulkan/wsi/wsi_common_private.h |  5 ++
 3 files changed, 85 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index ae89f5589c71..34512c9cb883 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -129,6 +129,12 @@ wsi_device_init(struct wsi_device *wsi,
       &vk_physical_device_from_handle(pdevice)->supported_extensions;
    wsi->has_import_memory_host =
       supported_extensions->EXT_external_memory_host;
+   wsi->khr_present_wait =
+      supported_extensions->KHR_present_id &&
+      supported_extensions->KHR_present_wait;
+
+   /* We cannot expose KHR_present_wait without timeline semaphores. */
+   assert(!wsi->khr_present_wait || supported_extensions->KHR_timeline_semaphore);
 
    list_inithead(&wsi->hotplug_fences);
 
@@ -169,6 +175,8 @@ wsi_device_init(struct wsi_device *wsi,
    WSI_GET_CB(WaitForFences);
    WSI_GET_CB(MapMemory);
    WSI_GET_CB(UnmapMemory);
+   if (wsi->khr_present_wait)
+      WSI_GET_CB(WaitSemaphoresKHR);
 #undef WSI_GET_CB
 
 #ifdef VK_USE_PLATFORM_XCB_KHR
@@ -487,6 +495,8 @@ wsi_swapchain_finish(struct wsi_swapchain *chain)
    }
    chain->wsi->DestroySemaphore(chain->device, chain->dma_buf_semaphore,
                                 &chain->alloc);
+   chain->wsi->DestroySemaphore(chain->device, chain->present_id_timeline,
+                                &chain->alloc);
 
    int cmd_pools_count = chain->buffer_blit_queue != VK_NULL_HANDLE ?
       1 : chain->wsi->queue_family_count;
@@ -879,12 +889,33 @@ wsi_CreateSwapchainKHR(VkDevice _device,
       return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
 
+   if (wsi_device->khr_present_wait) {
+      const VkSemaphoreTypeCreateInfo type_info = {
+         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
+         .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
+      };
+
+      const VkSemaphoreCreateInfo sem_info = {
+         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
+         .pNext = &type_info,
+         .flags = 0,
+      };
+
+      /* We assume here that a driver exposing present_wait also exposes VK_KHR_timeline_semaphore. */
+      result = wsi_device->CreateSemaphore(_device, &sem_info, alloc, &swapchain->present_id_timeline);
+      if (result != VK_SUCCESS) {
+         swapchain->destroy(swapchain, alloc);
+         return VK_ERROR_OUT_OF_HOST_MEMORY;
+      }
+   }
+
    if (swapchain->buffer_blit_queue != VK_NULL_HANDLE) {
       swapchain->buffer_blit_semaphores = vk_zalloc(alloc,
                                          sizeof (*swapchain->buffer_blit_semaphores) * swapchain->image_count,
                                          sizeof (*swapchain->buffer_blit_semaphores),
                                          VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
       if (!swapchain->buffer_blit_semaphores) {
+         wsi_device->DestroySemaphore(_device, swapchain->present_id_timeline, alloc);
          swapchain->destroy(swapchain, alloc);
          return VK_ERROR_OUT_OF_HOST_MEMORY;
       }
@@ -1091,6 +1122,27 @@ wsi_AcquireNextImage2KHR(VkDevice _device,
                                          _device, pAcquireInfo, pImageIndex);
 }
 
+static VkResult wsi_signal_present_id_timeline(struct wsi_swapchain *swapchain,
+                                               VkQueue queue, uint64_t present_id)
+{
+   assert(swapchain->present_id_timeline);
+
+   const VkTimelineSemaphoreSubmitInfo timeline_info = {
+      .sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
+      .pSignalSemaphoreValues = &present_id,
+      .signalSemaphoreValueCount = 1,
+   };
+
+   const VkSubmitInfo submit_info = {
+      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
+      .pNext = &timeline_info,
+      .signalSemaphoreCount = 1,
+      .pSignalSemaphores = &swapchain->present_id_timeline,
+   };
+
+   return swapchain->wsi->QueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE);
+}
+
 VkResult
 wsi_common_queue_present(const struct wsi_device *wsi,
                          VkDevice device,
@@ -1260,6 +1312,12 @@ wsi_common_queue_present(const struct wsi_device *wsi,
       if (present_ids && present_ids->pPresentIds)
          present_id = present_ids->pPresentIds[i];
 
+      if (present_id) {
+         result = wsi_signal_present_id_timeline(swapchain, queue, present_id);
+         if (result != VK_SUCCESS)
+            goto fail_present;
+      }
+
       result = swapchain->queue_present(swapchain, image_index, present_id, region);
       if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)
          goto fail_present;
@@ -1386,6 +1444,21 @@ wsi_common_bind_swapchain_image(const struct wsi_device *wsi,
    return wsi->BindImageMemory(chain->device, vk_image, image->memory, 0);
 }
 
+VkResult
+wsi_swapchain_wait_for_present_semaphore(const struct wsi_swapchain *chain,
+                                         uint64_t present_id, uint64_t timeout)
+{
+   assert(chain->present_id_timeline);
+   const VkSemaphoreWaitInfo wait_info = {
+      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
+      .semaphoreCount = 1,
+      .pSemaphores = &chain->present_id_timeline,
+      .pValues = &present_id,
+   };
+
+   return chain->wsi->WaitSemaphoresKHR(chain->device, &wait_info, timeout);
+}
+
 uint32_t
 wsi_select_memory_type(const struct wsi_device *wsi,
                        VkMemoryPropertyFlags req_props,
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 886bac9f8003..19b34ed6e189 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -166,6 +166,12 @@ struct wsi_device {
     */
    bool signal_fence_with_memory;
 
+   /* Whether present_wait functionality is enabled on the device.
+    * In this case, we have to create an extra timeline semaphore
+    * to be able to synchronize with the WSI present semaphore being unsignalled.
+    * This requires VK_KHR_timeline_semaphore. */
+   bool khr_present_wait;
+
    /*
     * This sets the ownership for a WSI memory object:
     *
@@ -229,6 +235,7 @@ struct wsi_device {
    WSI_CB(WaitForFences);
    WSI_CB(MapMemory);
    WSI_CB(UnmapMemory);
+   WSI_CB(WaitSemaphoresKHR);
 #undef WSI_CB
 
     struct wsi_interface *                  wsi[VK_ICD_WSI_PLATFORM_MAX];
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index 1b1ed138465f..92efcddf5e43 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -134,6 +134,7 @@ struct wsi_swapchain {
    VkFence* fences;
    VkSemaphore* buffer_blit_semaphores;
    VkPresentModeKHR present_mode;
+   VkSemaphore present_id_timeline;
 
    int signal_dma_buf_from_semaphore;
    VkSemaphore dma_buf_semaphore;
@@ -256,6 +257,10 @@ void
 wsi_destroy_image(const struct wsi_swapchain *chain,
                   struct wsi_image *image);
 
+VkResult
+wsi_swapchain_wait_for_present_semaphore(const struct wsi_swapchain *chain,
+                                         uint64_t present_id, uint64_t timeout);
+
 #ifdef HAVE_LIBDRM
 VkResult
 wsi_prepare_signal_dma_buf_from_semaphore(struct wsi_swapchain *chain,
-- 
GitLab


From bc7f86c6e0af6476dc7920957b0d8b914c84e576 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 21 Oct 2022 15:04:13 +0200
Subject: [PATCH 04/13] wsi/x11: Implement VK_KHR_present_wait on X11.

Based on original implementation by Keith Packard in
https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12086.

Also fixes the implementation to work on IMMEDIATE and MAILBOX
presentation modes and Xwayland.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/vulkan/wsi/wsi_common_x11.c | 307 +++++++++++++++++++++++++++++++-
 1 file changed, 302 insertions(+), 5 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index edd47cb9a7c9..7874d9fd01f2 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -45,6 +45,7 @@
 #include "util/u_debug.h"
 #include "util/u_thread.h"
 #include "util/xmlconfig.h"
+#include "util/timespec.h"
 
 #include "vk_instance.h"
 #include "vk_physical_device.h"
@@ -937,6 +938,7 @@ struct x11_image {
    xcb_shm_seg_t                             shmseg;
    int                                       shmid;
    uint8_t *                                 shmaddr;
+   uint64_t                                  present_id;
 };
 
 struct x11_swapchain {
@@ -966,11 +968,55 @@ struct x11_swapchain {
    struct wsi_queue                             acquire_queue;
    pthread_t                                    queue_manager;
 
+   pthread_mutex_t                              present_id_mutex;
+   pthread_cond_t                               present_id_cond;
+   pthread_mutex_t                              present_id_poll_mutex;
+   uint64_t                                     present_id;
+   uint64_t                                     present_id_pending;
+   VkResult                                     present_id_error;
+
    struct x11_image                             images[0];
 };
 VK_DEFINE_NONDISP_HANDLE_CASTS(x11_swapchain, base.base, VkSwapchainKHR,
                                VK_OBJECT_TYPE_SWAPCHAIN_KHR)
 
+static void x11_present_complete(struct x11_swapchain *swapchain,
+                                 struct x11_image *image)
+{
+   if (image->present_id) {
+      pthread_mutex_lock(&swapchain->present_id_mutex);
+      if (image->present_id > swapchain->present_id) {
+         swapchain->present_id = image->present_id;
+         pthread_cond_broadcast(&swapchain->present_id_cond);
+      }
+      pthread_mutex_unlock(&swapchain->present_id_mutex);
+   }
+}
+
+static void x11_notify_pending_present(struct x11_swapchain *swapchain,
+                                       struct x11_image *image)
+{
+   if (image->present_id) {
+      pthread_mutex_lock(&swapchain->present_id_mutex);
+      if (image->present_id > swapchain->present_id_pending) {
+         /* Unblock any thread waiting for a presentID out of order. */
+         swapchain->present_id_pending = image->present_id;
+         pthread_cond_broadcast(&swapchain->present_id_cond);
+      }
+      pthread_mutex_unlock(&swapchain->present_id_mutex);
+   }
+}
+
+static void x11_swapchain_notify_error(struct x11_swapchain *swapchain, VkResult result)
+{
+   pthread_mutex_lock(&swapchain->present_id_mutex);
+   swapchain->present_id = UINT64_MAX;
+   swapchain->present_id_pending = UINT64_MAX;
+   swapchain->present_id_error = result;
+   pthread_cond_broadcast(&swapchain->present_id_cond);
+   pthread_mutex_unlock(&swapchain->present_id_mutex);
+}
+
 /**
  * Update the swapchain status with the result of an operation, and return
  * the combined status. The chain status will eventually be returned from
@@ -984,6 +1030,9 @@ static VkResult
 _x11_swapchain_result(struct x11_swapchain *chain, VkResult result,
                       const char *file, int line)
 {
+   if (result < 0)
+      x11_swapchain_notify_error(chain, result);
+
    /* Prioritise returning existing errors for consistency. */
    if (chain->status < 0)
       return chain->status;
@@ -1070,8 +1119,10 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
          unsigned i;
          for (i = 0; i < chain->base.image_count; i++) {
             struct x11_image *image = &chain->images[i];
-            if (image->present_queued && image->serial == complete->serial)
+            if (image->present_queued && image->serial == complete->serial) {
+               x11_present_complete(chain, &chain->images[i]);
                image->present_queued = false;
+            }
          }
          chain->last_present_msc = complete->msc;
       }
@@ -1359,9 +1410,18 @@ static VkResult
 x11_present_to_x11(struct x11_swapchain *chain, uint32_t image_index,
                    uint64_t target_msc)
 {
+   VkResult result;
    if (chain->base.wsi->sw && !chain->has_mit_shm)
-      return x11_present_to_x11_sw(chain, image_index, target_msc);
-   return x11_present_to_x11_dri3(chain, image_index, target_msc);
+      result = x11_present_to_x11_sw(chain, image_index, target_msc);
+   else
+      result = x11_present_to_x11_dri3(chain, image_index, target_msc);
+
+   if (result < 0)
+      x11_swapchain_notify_error(chain, result);
+   else
+      x11_notify_pending_present(chain, &chain->images[image_index]);
+
+   return result;
 }
 
 /**
@@ -1410,7 +1470,10 @@ x11_acquire_next_image(struct wsi_swapchain *anv_chain,
    if (chain->has_acquire_queue) {
       return x11_acquire_next_image_from_queue(chain, image_index, timeout);
    } else {
-      return x11_acquire_next_image_poll_x11(chain, image_index, timeout);
+      pthread_mutex_lock(&chain->present_id_poll_mutex);
+      VkResult result = x11_acquire_next_image_poll_x11(chain, image_index, timeout);
+      pthread_mutex_unlock(&chain->present_id_poll_mutex);
+      return result;
    }
 }
 
@@ -1452,6 +1515,7 @@ x11_queue_present(struct wsi_swapchain *anv_chain,
       xcb_xfixes_set_region(chain->conn, update_area, damage->rectangleCount, rects);
    }
    chain->images[image_index].update_area = update_area;
+   chain->images[image_index].present_id = present_id;
 
    chain->images[image_index].busy = true;
    if (chain->has_present_queue) {
@@ -1459,7 +1523,10 @@ x11_queue_present(struct wsi_swapchain *anv_chain,
       return chain->status;
    } else {
       /* No present queue means immedate mode, so we present immediately. */
-      return x11_present_to_x11(chain, image_index, 0);
+      pthread_mutex_lock(&chain->present_id_poll_mutex);
+      VkResult result = x11_present_to_x11(chain, image_index, 0);
+      pthread_mutex_unlock(&chain->present_id_poll_mutex);
+      return result;
    }
 }
 
@@ -1571,7 +1638,15 @@ x11_manage_fifo_queues(void *state)
       if (chain->has_acquire_queue)
          target_msc = chain->last_present_msc + 1;
 
+      /* Locking here is only relevant if we don't have an acquire queue.
+       * WaitForPresentKHR will pump the message queue on its own unless
+       * has_acquire_queue and has_present_queue are both true. */
+      if (!chain->has_acquire_queue)
+         pthread_mutex_lock(&chain->present_id_poll_mutex);
       result = x11_present_to_x11(chain, image_index, target_msc);
+      if (!chain->has_acquire_queue)
+         pthread_mutex_unlock(&chain->present_id_poll_mutex);
+
       if (result < 0)
          goto fail;
 
@@ -1923,6 +1998,10 @@ x11_swapchain_destroy(struct wsi_swapchain *anv_chain,
                                              XCB_PRESENT_EVENT_MASK_NO_EVENT);
    xcb_discard_reply(chain->conn, cookie.sequence);
 
+   pthread_mutex_destroy(&chain->present_id_poll_mutex);
+   pthread_mutex_destroy(&chain->present_id_mutex);
+   pthread_cond_destroy(&chain->present_id_cond);
+
    wsi_swapchain_finish(&chain->base);
 
    vk_free(pAllocator, chain);
@@ -1956,6 +2035,202 @@ wsi_x11_set_adaptive_sync_property(xcb_connection_t *conn,
    free(reply);
 }
 
+static VkResult x11_wait_for_present_queued(
+      struct x11_swapchain *chain,
+      uint64_t waitValue, uint64_t timeout)
+{
+   struct timespec abs_timespec;
+   uint64_t abs_timeout = 0;
+   if (timeout != 0)
+      abs_timeout = os_time_get_absolute_timeout(timeout);
+
+   /* Need to observe that the swapchain semaphore has been unsignalled,
+    * as this is guaranteed when a present is complete. */
+   VkResult result = wsi_swapchain_wait_for_present_semaphore(
+      &chain->base, waitValue, timeout);
+   if (result != VK_SUCCESS)
+      return result;
+
+   timespec_from_nsec(&abs_timespec, abs_timeout);
+
+   pthread_mutex_lock(&chain->present_id_mutex);
+   while (chain->present_id < waitValue) {
+      int ret = pthread_cond_timedwait(&chain->present_id_cond,
+                                       &chain->present_id_mutex,
+                                       &abs_timespec);
+      if (ret == ETIMEDOUT) {
+         result = VK_TIMEOUT;
+         break;
+      }
+      if (ret) {
+         result = VK_ERROR_DEVICE_LOST;
+         break;
+      }
+   }
+   if (result == VK_SUCCESS && chain->present_id_error)
+      result = chain->present_id_error;
+   pthread_mutex_unlock(&chain->present_id_mutex);
+   return result;
+}
+
+static VkResult x11_wait_for_present_polled(
+      struct x11_swapchain *chain,
+      uint64_t waitValue, uint64_t timeout)
+{
+   struct timespec rel_timeout, abs_timespec_realtime, start_time;
+   struct timespec abs_timespec_monotonic;
+   uint64_t abs_timeout_monotonic = 0;
+
+   if (timeout != 0)
+      abs_timeout_monotonic = os_time_get_absolute_timeout(timeout);
+
+   /* Mutex abs_timeout is in REALTIME timebase. */
+   timespec_from_nsec(&rel_timeout, timeout);
+   clock_gettime(CLOCK_REALTIME, &start_time);
+   timespec_add(&abs_timespec_realtime, &rel_timeout, &start_time);
+
+   /* Need to observe that the swapchain semaphore has been unsignalled,
+    * as this is guaranteed when a present is complete. */
+   VkResult result = wsi_swapchain_wait_for_present_semaphore(
+      &chain->base, waitValue, timeout);
+   if (result != VK_SUCCESS)
+      return result;
+
+   /* If we have satisfied the present ID right away, just return early. */
+   pthread_mutex_lock(&chain->present_id_mutex);
+   if (chain->present_id >= waitValue) {
+      result = chain->present_id_error;
+   } else {
+      result = VK_TIMEOUT;
+   }
+
+   if (result != VK_TIMEOUT) {
+      pthread_mutex_unlock(&chain->present_id_mutex);
+      return result;
+   }
+
+   timespec_from_nsec(&abs_timespec_monotonic, abs_timeout_monotonic);
+
+   /* In a situation of wait-before-signal, we need to ensure that a presentID of at least
+    * waitValue has been submitted before we're allowed to lock the XCB connection.
+    * Even if the user does not use wait-before-signal we can still hit this scenario on Xwayland
+    * where we have a present queue, but no acquire queue. We need to observe that the present queue
+    * has actually submitted the present to XCB before we're guaranteed forward progress. */
+   while (chain->present_id_pending < waitValue) {
+      int ret = pthread_cond_timedwait(&chain->present_id_cond,
+                                       &chain->present_id_mutex,
+                                       &abs_timespec_monotonic);
+      if (chain->present_id_error || ret == ETIMEDOUT || ret) {
+         pthread_mutex_unlock(&chain->present_id_mutex);
+
+         if (chain->present_id_error)
+            return chain->present_id_error;
+         else if (ret == ETIMEDOUT)
+            return VK_TIMEOUT;
+         else
+            return VK_ERROR_DEVICE_LOST;
+      }
+   }
+   pthread_mutex_unlock(&chain->present_id_mutex);
+
+   /* This scheme of taking the message queue lock is not optimal,
+    * but it is only problematic in meaningless situations.
+    * - This path can only be hit by IMMEDIATE or MAILBOX mode.
+    *   Using present wait for IMMEDIATE and MAILBOX is not particularly useful except
+    *   for safe teardown purposes and recycling semaphores.
+    * - There is contention with multiple threads waiting for PresentWait,
+    *   where the first thread to wait is blocking with no timeout and hogs the message queue until
+    *   that present is processed. */
+   int ret;
+   if (timeout == UINT64_MAX)
+      ret = pthread_mutex_lock(&chain->present_id_poll_mutex);
+   else
+      ret = pthread_mutex_timedlock(&chain->present_id_poll_mutex, &abs_timespec_realtime);
+
+   if (ret) {
+      if (ret == ETIMEDOUT)
+         return VK_TIMEOUT;
+      else
+         return VK_ERROR_DEVICE_LOST;
+   }
+
+   result = chain->present_id_error;
+
+   while (result == VK_SUCCESS && chain->present_id < waitValue) {
+      xcb_generic_event_t *event;
+      xcb_flush(chain->conn);
+
+      if (timeout == UINT64_MAX) {
+         event = xcb_wait_for_special_event(chain->conn, chain->special_event);
+         if (!event) {
+            result = x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
+            goto fail;
+         }
+      } else {
+         event = xcb_poll_for_special_event(chain->conn, chain->special_event);
+         if (!event) {
+            if (timeout == 0) {
+               result = x11_swapchain_result(chain, VK_TIMEOUT);
+               goto fail;
+            }
+
+            uint64_t current_time = os_time_get_nano();
+            if (abs_timeout_monotonic > current_time)
+               timeout = abs_timeout_monotonic - current_time;
+            else
+               timeout = 0;
+
+            struct pollfd pfds;
+            pfds.fd = xcb_get_file_descriptor(chain->conn);
+            pfds.events = POLLIN;
+            ret = poll(&pfds, 1, timeout / 1000 / 1000);
+
+            if (ret == 0) {
+               result = x11_swapchain_result(chain, VK_TIMEOUT);
+               goto fail;
+            }
+
+            if (ret == -1) {
+               result = x11_swapchain_result(chain, VK_ERROR_OUT_OF_DATE_KHR);
+               goto fail;
+            }
+         }
+      }
+
+      if (event) {
+         result = x11_handle_dri3_present_event(chain, (void *)event);
+         /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
+         result = x11_swapchain_result(chain, result);
+         free(event);
+      }
+   }
+
+fail:
+   pthread_mutex_unlock(&chain->present_id_poll_mutex);
+   return result;
+}
+
+static VkResult x11_wait_for_present(struct wsi_swapchain *wsi_chain,
+                                     uint64_t waitValue,
+                                     uint64_t timeout)
+{
+   struct x11_swapchain *chain = (struct x11_swapchain *)wsi_chain;
+   VkResult result;
+
+   if (chain->has_present_queue && chain->has_acquire_queue) {
+      /* In this style we have guaranteed forward progress in the present queue thread,
+       * so we don't need to do anything.
+       * This path is hit for FIFO presentation modes. */
+      result = x11_wait_for_present_queued(chain, waitValue, timeout);
+   } else {
+      /* In this style we don't necessarily have forward progress, so we need to pump the message queue ourselves.
+       * This blocks the message queue for other threads that want to present.
+       * In practice, we'll only end up blocking on swapchain teardown, so this isn't a big deal. */
+      result = x11_wait_for_present_polled(chain, waitValue, timeout);
+   }
+   return result;
+}
+
 /**
  * Create the swapchain.
  *
@@ -2021,6 +2296,27 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    if (chain == NULL)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
+   int ret = pthread_mutex_init(&chain->present_id_mutex, NULL);
+   if (ret != 0) {
+      vk_free(pAllocator, chain);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+   }
+
+   ret = pthread_mutex_init(&chain->present_id_poll_mutex, NULL);
+   if (ret != 0) {
+      pthread_mutex_destroy(&chain->present_id_mutex);
+      vk_free(pAllocator, chain);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+   }
+
+   bool bret = wsi_init_pthread_cond_monotonic(&chain->present_id_cond);
+   if (!bret) {
+      pthread_mutex_destroy(&chain->present_id_mutex);
+      pthread_mutex_destroy(&chain->present_id_poll_mutex);
+      vk_free(pAllocator, chain);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+   }
+
    struct wsi_base_image_params *image_params = NULL;
    struct wsi_cpu_image_params cpu_image_params;
    struct wsi_drm_image_params drm_image_params;
@@ -2062,6 +2358,7 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->base.get_wsi_image = x11_get_wsi_image;
    chain->base.acquire_next_image = x11_acquire_next_image;
    chain->base.queue_present = x11_queue_present;
+   chain->base.wait_for_present = x11_wait_for_present;
    chain->base.present_mode = present_mode;
    chain->base.image_count = num_images;
    chain->conn = conn;
-- 
GitLab


From 62190ac787f51c9dc44365d3af04b6ba9b4a508b Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 24 Oct 2022 16:10:01 +0200
Subject: [PATCH 05/13] wsi/display: Implement VK_KHR_present_wait on
 KHR_display swapchain.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/vulkan/wsi/wsi_common_display.c | 110 +++++++++++++++++++++++++++-
 1 file changed, 109 insertions(+), 1 deletion(-)

diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index ba1599330647..cf2ac7bb28d2 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -44,6 +44,7 @@
 #include "util/hash_table.h"
 #include "util/list.h"
 #include "util/os_time.h"
+#include "util/timespec.h"
 
 #include "vk_device.h"
 #include "vk_fence.h"
@@ -139,6 +140,7 @@ struct wsi_display_image {
    uint32_t                     fb_id;
    uint32_t                     buffer[4];
    uint64_t                     flip_sequence;
+   uint64_t                     present_id;
 };
 
 struct wsi_display_swapchain {
@@ -147,6 +149,12 @@ struct wsi_display_swapchain {
    VkIcdSurfaceDisplay          *surface;
    uint64_t                     flip_sequence;
    VkResult                     status;
+
+   pthread_mutex_t              present_id_mutex;
+   pthread_cond_t               present_id_cond;
+   uint64_t                     present_id;
+   VkResult                     present_id_error;
+
    struct wsi_display_image     images[0];
 };
 
@@ -1180,6 +1188,9 @@ wsi_display_swapchain_destroy(struct wsi_swapchain *drv_chain,
    for (uint32_t i = 0; i < chain->base.image_count; i++)
       wsi_display_image_finish(drv_chain, allocator, &chain->images[i]);
 
+   pthread_mutex_destroy(&chain->present_id_mutex);
+   pthread_cond_destroy(&chain->present_id_cond);
+
    wsi_swapchain_finish(&chain->base);
    vk_free(allocator, chain);
    return VK_SUCCESS;
@@ -1214,6 +1225,30 @@ wsi_display_idle_old_displaying(struct wsi_display_image *active_image)
 static VkResult
 _wsi_display_queue_next(struct wsi_swapchain *drv_chain);
 
+static void
+wsi_display_present_complete(struct wsi_display_swapchain *swapchain,
+                             struct wsi_display_image *image)
+{
+   if (image->present_id) {
+      pthread_mutex_lock(&swapchain->present_id_mutex);
+      if (image->present_id > swapchain->present_id) {
+         swapchain->present_id = image->present_id;
+         pthread_cond_broadcast(&swapchain->present_id_cond);
+      }
+      pthread_mutex_unlock(&swapchain->present_id_mutex);
+   }
+}
+
+static void
+wsi_display_surface_error(struct wsi_display_swapchain *swapchain, VkResult result)
+{
+   pthread_mutex_lock(&swapchain->present_id_mutex);
+   swapchain->present_id = UINT64_MAX;
+   swapchain->present_id_error = result;
+   pthread_cond_broadcast(&swapchain->present_id_cond);
+   pthread_mutex_unlock(&swapchain->present_id_mutex);
+}
+
 static void
 wsi_display_page_flip_handler2(int fd,
                                unsigned int frame,
@@ -1228,6 +1263,8 @@ wsi_display_page_flip_handler2(int fd,
    wsi_display_debug("image %ld displayed at %d\n",
                      image - &(image->chain->images[0]), frame);
    image->state = WSI_IMAGE_DISPLAYING;
+   wsi_display_present_complete(chain, image);
+
    wsi_display_idle_old_displaying(image);
    VkResult result = _wsi_display_queue_next(&(chain->base));
    if (result != VK_SUCCESS)
@@ -1401,6 +1438,7 @@ wsi_display_acquire_next_image(struct wsi_swapchain *drv_chain,
 
       if (ret && ret != ETIMEDOUT) {
          result = VK_ERROR_SURFACE_LOST_KHR;
+         wsi_display_surface_error(chain, result);
          goto done;
       }
    }
@@ -1814,8 +1852,10 @@ _wsi_display_queue_next(struct wsi_swapchain *drv_chain)
       wsi_display_mode_from_handle(surface->displayMode);
    wsi_display_connector *connector = display_mode->connector;
 
-   if (wsi->fd < 0)
+   if (wsi->fd < 0) {
+      wsi_display_surface_error(chain, VK_ERROR_SURFACE_LOST_KHR);
       return VK_ERROR_SURFACE_LOST_KHR;
+   }
 
    if (display_mode != connector->current_mode)
       connector->active = false;
@@ -1887,6 +1927,7 @@ _wsi_display_queue_next(struct wsi_swapchain *drv_chain)
              * previous image is now idle.
              */
             image->state = WSI_IMAGE_DISPLAYING;
+            wsi_display_present_complete(chain, image);
             wsi_display_idle_old_displaying(image);
             connector->active = true;
             return VK_SUCCESS;
@@ -1896,6 +1937,7 @@ _wsi_display_queue_next(struct wsi_swapchain *drv_chain)
       if (ret != -EACCES) {
          connector->active = false;
          image->state = WSI_IMAGE_IDLE;
+         wsi_display_surface_error(chain, VK_ERROR_SURFACE_LOST_KHR);
          return VK_ERROR_SURFACE_LOST_KHR;
       }
 
@@ -1923,11 +1965,17 @@ wsi_display_queue_present(struct wsi_swapchain *drv_chain,
    if (chain->status != VK_SUCCESS)
       return chain->status;
 
+   image->present_id = present_id;
+
    assert(image->state == WSI_IMAGE_DRAWING);
    wsi_display_debug("present %d\n", image_index);
 
    pthread_mutex_lock(&wsi->wait_mutex);
 
+   /* Make sure that the page flip handler is processed in finite time if using present wait. */
+   if (present_id)
+      wsi_display_start_wait_thread(wsi);
+
    image->flip_sequence = ++chain->flip_sequence;
    image->state = WSI_IMAGE_QUEUED;
 
@@ -1943,6 +1991,48 @@ wsi_display_queue_present(struct wsi_swapchain *drv_chain,
    return chain->status;
 }
 
+static VkResult
+wsi_display_wait_for_present(struct wsi_swapchain *wsi_chain,
+                             uint64_t waitValue,
+                             uint64_t timeout)
+{
+   struct wsi_display_swapchain *chain = (struct wsi_display_swapchain *)wsi_chain;
+   struct timespec abs_timespec;
+   uint64_t abs_timeout = 0;
+
+   if (timeout != 0)
+      abs_timeout = os_time_get_absolute_timeout(timeout);
+
+   /* Need to observe that the swapchain semaphore has been unsignalled,
+    * as this is guaranteed when a present is complete. */
+   VkResult result = wsi_swapchain_wait_for_present_semaphore(
+      &chain->base, waitValue, timeout);
+   if (result != VK_SUCCESS)
+      return result;
+
+   timespec_from_nsec(&abs_timespec, abs_timeout);
+
+   pthread_mutex_lock(&chain->present_id_mutex);
+   while (chain->present_id < waitValue) {
+      int ret = pthread_cond_timedwait(&chain->present_id_cond,
+                                       &chain->present_id_mutex,
+                                       &abs_timespec);
+      if (ret == ETIMEDOUT) {
+         result = VK_TIMEOUT;
+         break;
+      }
+      if (ret) {
+         result = VK_ERROR_DEVICE_LOST;
+         break;
+      }
+   }
+
+   if (result == VK_SUCCESS && chain->present_id_error)
+      result = chain->present_id_error;
+   pthread_mutex_unlock(&chain->present_id_mutex);
+   return result;
+}
+
 static VkResult
 wsi_display_surface_create_swapchain(
    VkIcdSurfaceBase *icd_surface,
@@ -1971,10 +2061,25 @@ wsi_display_surface_create_swapchain(
       .same_gpu = true,
    };
 
+   int ret = pthread_mutex_init(&chain->present_id_mutex, NULL);
+   if (ret != 0) {
+      vk_free(allocator, chain);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+   }
+
+   bool bret = wsi_init_pthread_cond_monotonic(&chain->present_id_cond);
+   if (!bret) {
+      pthread_mutex_destroy(&chain->present_id_mutex);
+      vk_free(allocator, chain);
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+   }
+
    VkResult result = wsi_swapchain_init(wsi_device, &chain->base, device,
                                         create_info, &image_params.base,
                                         allocator);
    if (result != VK_SUCCESS) {
+      pthread_cond_destroy(&chain->present_id_cond);
+      pthread_mutex_destroy(&chain->present_id_mutex);
       vk_free(allocator, chain);
       return result;
    }
@@ -1983,6 +2088,7 @@ wsi_display_surface_create_swapchain(
    chain->base.get_wsi_image = wsi_display_get_wsi_image;
    chain->base.acquire_next_image = wsi_display_acquire_next_image;
    chain->base.queue_present = wsi_display_queue_present;
+   chain->base.wait_for_present = wsi_display_wait_for_present;
    chain->base.present_mode = wsi_swapchain_get_present_mode(wsi_device, create_info);
    chain->base.image_count = num_images;
 
@@ -2001,6 +2107,8 @@ wsi_display_surface_create_swapchain(
             wsi_display_image_finish(&chain->base, allocator,
                                      &chain->images[image]);
          }
+         pthread_cond_destroy(&chain->present_id_cond);
+         pthread_mutex_destroy(&chain->present_id_mutex);
          wsi_swapchain_finish(&chain->base);
          vk_free(allocator, chain);
          goto fail_init_images;
-- 
GitLab


From e9e95732d1f476f89b3ffb51fcb4ebd8fa565d31 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 24 Oct 2022 13:43:37 +0200
Subject: [PATCH 06/13] driconf: Add DRI configuration for exposing
 VK_KHR_present_wait.

These extensions are flawed and do not support the concept of
per-surface queries. For the time being we cannot guarantee that we are
able to implement it on all surfaces, but the feature is useful enough
to make available as an opt-in feature for the time being, so hide it
behind an driconf until we have a better mechanism in place.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/util/driconf.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/util/driconf.h b/src/util/driconf.h
index 8251251dab86..8fb89cacdb78 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -380,6 +380,10 @@
    DRI_CONF_OPT_B(vk_x11_ensure_min_image_count, def, \
                   "Force the X11 WSI to create at least the number of image specified by the driver in VkSurfaceCapabilitiesKHR::minImageCount")
 
+#define DRI_CONF_VK_KHR_PRESENT_WAIT(def) \
+   DRI_CONF_OPT_B(vk_khr_present_wait, def, \
+                  "Expose VK_KHR_present_wait and id extensions despite them not being implemented for all supported surface types")
+
 #define DRI_CONF_VK_XWAYLAND_WAIT_READY(def) \
    DRI_CONF_OPT_B(vk_xwayland_wait_ready, def, \
                   "Wait for fences before submitting buffers to Xwayland")
-- 
GitLab


From 8cdcae78ecd1c247ab0849d9409a4bdc23b2d22e Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 31 Oct 2022 16:00:04 +0100
Subject: [PATCH 07/13] wsi/common: Allow present-wait to be unconditionally
 enabled.

If all potentially supported surface types support present wait,
we can expose the extension.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/vulkan/wsi/wsi_common.c | 22 ++++++++++++++++++++++
 src/vulkan/wsi/wsi_common.h |  4 ++++
 2 files changed, 26 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 34512c9cb883..f6adb208af94 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -1376,6 +1376,28 @@ wsi_GetDeviceGroupSurfacePresentModesKHR(VkDevice device,
    return VK_SUCCESS;
 }
 
+bool
+wsi_common_vk_instance_supports_present_wait(const struct vk_instance *instance)
+{
+   /* Only expose when KHR_surface is actually enabled. */
+   if (!instance->enabled_extensions.KHR_surface)
+      return false;
+
+   /* We can only expose KHR_present_wait and KHR_present_id
+    * if we are guaranteed support on all potential VkSurfaceKHR objects. */
+   if (instance->enabled_extensions.KHR_wayland_surface ||
+         instance->enabled_extensions.KHR_win32_surface ||
+         instance->enabled_extensions.KHR_android_surface) {
+      return false;
+   }
+
+   /* X11 and KHR_display unconditionally expose this.
+    * Only expose extension if one of these is explicitly enabled. */
+   return instance->enabled_extensions.KHR_xcb_surface ||
+         instance->enabled_extensions.KHR_xlib_surface ||
+         instance->enabled_extensions.KHR_display;
+}
+
 VkResult
 wsi_common_create_swapchain_image(const struct wsi_device *wsi,
                                   const VkImageCreateInfo *pCreateInfo,
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 19b34ed6e189..8fad975f554e 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -87,6 +87,7 @@ struct wsi_memory_signal_submit_info {
 };
 
 struct wsi_interface;
+struct vk_instance;
 
 struct driOptionCache;
 
@@ -312,6 +313,9 @@ wsi_common_bind_swapchain_image(const struct wsi_device *wsi,
                                 VkSwapchainKHR _swapchain,
                                 uint32_t image_idx);
 
+bool
+wsi_common_vk_instance_supports_present_wait(const struct vk_instance *instance);
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab


From 6d2796aa76d19afcfedfcde210de2d4926d24541 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 24 Oct 2022 13:48:11 +0200
Subject: [PATCH 08/13] radv: Conditionally expose VK_KHR_present_wait on RADV.

Gate it behind driconf query for now.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 src/amd/vulkan/radv_device.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index a909ac5a432e..4794206050fa 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -522,6 +522,15 @@ radv_physical_device_get_supported_extensions(const struct radv_physical_device
       .KHR_performance_query = radv_perf_query_supported(device),
       .KHR_pipeline_executable_properties = true,
       .KHR_pipeline_library = !device->use_llvm,
+      /* Hide these behind dri configs for now since we cannot implement it reliably on
+       * all surfaces yet. There is no surface capability query for present wait/id,
+       * but the feature is useful enough to hide behind an opt-in mechanism for now.
+       * If the instance only enables surface extensions that unconditionally support present wait,
+       * we can also expose the extension that way. */
+      .KHR_present_id = driQueryOptionb(&device->instance->dri_options, "vk_khr_present_wait") ||
+         wsi_common_vk_instance_supports_present_wait(&device->instance->vk),
+      .KHR_present_wait = driQueryOptionb(&device->instance->dri_options, "vk_khr_present_wait") ||
+         wsi_common_vk_instance_supports_present_wait(&device->instance->vk),
       .KHR_push_descriptor = true,
       .KHR_ray_query = radv_enable_rt(device, false),
       .KHR_ray_tracing_maintenance1 = radv_enable_rt(device, false),
@@ -1108,6 +1117,7 @@ static const driOptionDescription radv_dri_options[] = {
       DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
+      DRI_CONF_VK_KHR_PRESENT_WAIT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(true)
       DRI_CONF_RADV_REPORT_LLVM9_VERSION_STRING(false)
       DRI_CONF_RADV_ENABLE_MRT_OUTPUT_NAN_FIXUP(false)
@@ -1744,6 +1754,18 @@ radv_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
          features->sparseImageFloat32AtomicMinMax = has_shader_image_float_minmax;
          break;
       }
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {
+         VkPhysicalDevicePresentIdFeaturesKHR *features =
+            (VkPhysicalDevicePresentIdFeaturesKHR *) ext;
+         features->presentId = pdevice->vk.supported_extensions.KHR_present_id;
+         break;
+      }
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {
+         VkPhysicalDevicePresentWaitFeaturesKHR *features =
+            (VkPhysicalDevicePresentWaitFeaturesKHR *) ext;
+         features->presentWait = pdevice->vk.supported_extensions.KHR_present_wait;
+         break;
+      }
       case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {
          VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *features =
             (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *)ext;
-- 
GitLab


From e3636e2b6a26ddaa177ccadf1998dfd259bc07f8 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Mon, 24 Oct 2022 13:48:30 +0200
Subject: [PATCH 09/13] anv: Conditionally expose VK_KHR_present_wait on ANV.

Gate it behind driconf query for now.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
---
 src/intel/vulkan/anv_device.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/src/intel/vulkan/anv_device.c b/src/intel/vulkan/anv_device.c
index 8179a35906ca..c7db81847766 100644
--- a/src/intel/vulkan/anv_device.c
+++ b/src/intel/vulkan/anv_device.c
@@ -67,6 +67,7 @@ static const driOptionDescription anv_dri_options[] = {
       DRI_CONF_ADAPTIVE_SYNC(true)
       DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
+      DRI_CONF_VK_KHR_PRESENT_WAIT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(true)
       DRI_CONF_ANV_ASSUME_FULL_SUBGROUPS(false)
       DRI_CONF_ANV_SAMPLE_MASK_OUT_OPENGL_BEHAVIOUR(false)
@@ -231,6 +232,17 @@ get_device_extensions(const struct anv_physical_device *device,
          device->use_call_secondary,
       .KHR_pipeline_executable_properties    = true,
       .KHR_pipeline_library                  = true,
+      /* Hide these behind dri configs for now since we cannot implement it reliably on
+       * all surfaces yet. There is no surface capability query for present wait/id,
+       * but the feature is useful enough to hide behind an opt-in mechanism for now.
+       * If the instance only enables surface extensions that unconditionally support present wait,
+       * we can also expose the extension that way. */
+      .KHR_present_id =
+         driQueryOptionb(&device->instance->dri_options, "vk_khr_present_wait") ||
+         wsi_common_vk_instance_supports_present_wait(&device->instance->vk),
+      .KHR_present_wait =
+         driQueryOptionb(&device->instance->dri_options, "vk_khr_present_wait") ||
+         wsi_common_vk_instance_supports_present_wait(&device->instance->vk),
       .KHR_push_descriptor                   = true,
       .KHR_ray_query                         =
          ANV_SUPPORT_RT && device->info.has_ray_tracing,
@@ -1785,6 +1797,20 @@ void anv_GetPhysicalDeviceFeatures2(
          break;
       }
 
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {
+         VkPhysicalDevicePresentIdFeaturesKHR *features =
+            (VkPhysicalDevicePresentIdFeaturesKHR *) ext;
+         features->presentId = pdevice->vk.supported_extensions.KHR_present_id;
+         break;
+      }
+
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {
+         VkPhysicalDevicePresentWaitFeaturesKHR *features =
+            (VkPhysicalDevicePresentWaitFeaturesKHR *) ext;
+         features->presentWait = pdevice->vk.supported_extensions.KHR_present_wait;
+         break;
+      }
+
       default:
          anv_debug_ignored_stype(ext->sType);
          break;
-- 
GitLab


From 732b6ca48a8e03b1319d579888eec8206a2be85d Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Tue, 25 Oct 2022 11:22:25 +0200
Subject: [PATCH 10/13] turnip: Conditionally enable VK_KHR_present_wait on
 Turnip.

Hide behind driconf.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Tested-by: Gabe Rowe <gaberowe@gmail.com>
Reviewed-by: Jonathan Marek <jonathan@marek.ca>
---
 src/freedreno/vulkan/tu_device.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/freedreno/vulkan/tu_device.c b/src/freedreno/vulkan/tu_device.c
index fd66bd706f66..99f5f47c88cb 100644
--- a/src/freedreno/vulkan/tu_device.c
+++ b/src/freedreno/vulkan/tu_device.c
@@ -171,6 +171,17 @@ get_device_extensions(const struct tu_physical_device *device,
       .KHR_shader_non_semantic_info = true,
       .KHR_synchronization2 = true,
       .KHR_dynamic_rendering = true,
+      /* Hide these behind dri configs for now since we cannot implement it reliably on
+       * all surfaces yet. There is no surface capability query for present wait/id,
+       * but the feature is useful enough to hide behind an opt-in mechanism for now.
+       * If the instance only enables surface extensions that unconditionally support present wait,
+       * we can also expose the extension that way. */
+      .KHR_present_id =
+         driQueryOptionb(&device->instance->dri_options, "vk_khr_present_wait") ||
+         wsi_common_vk_instance_supports_present_wait(&device->instance->vk),
+      .KHR_present_wait =
+         driQueryOptionb(&device->instance->dri_options, "vk_khr_present_wait") ||
+         wsi_common_vk_instance_supports_present_wait(&device->instance->vk),
 #ifndef TU_USE_KGSL
       .KHR_timeline_semaphore = true,
 #endif
@@ -411,6 +422,7 @@ tu_get_debug_option_name(int id)
 static const driOptionDescription tu_dri_options[] = {
    DRI_CONF_SECTION_PERFORMANCE
       DRI_CONF_VK_X11_OVERRIDE_MIN_IMAGE_COUNT(0)
+      DRI_CONF_VK_KHR_PRESENT_WAIT(false)
       DRI_CONF_VK_X11_STRICT_IMAGE_COUNT(false)
       DRI_CONF_VK_X11_ENSURE_MIN_IMAGE_COUNT(false)
       DRI_CONF_VK_XWAYLAND_WAIT_READY(true)
@@ -953,6 +965,18 @@ tu_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
          features->graphicsPipelineLibrary = true;
          break;
       }
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {
+         VkPhysicalDevicePresentIdFeaturesKHR *features =
+            (VkPhysicalDevicePresentIdFeaturesKHR *) ext;
+         features->presentId = pdevice->vk.supported_extensions.KHR_present_id;
+         break;
+      }
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {
+         VkPhysicalDevicePresentWaitFeaturesKHR *features =
+            (VkPhysicalDevicePresentWaitFeaturesKHR *) ext;
+         features->presentWait = pdevice->vk.supported_extensions.KHR_present_wait;
+         break;
+      }
 
       default:
          break;
-- 
GitLab


From 906d50ef216d20af7db275ceeee42984858c8b9f Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 26 Oct 2022 12:57:56 +0200
Subject: [PATCH 11/13] wsi/x11: Mention problems with
 xcb_wait_for_special_event().
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There is no pragmatic solution for this.
Comment about the rationale for doing it like this until we have a more
robust solution in XCB.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Michel Dänzer <mdaenzer@redhat.com>
---
 src/vulkan/wsi/wsi_common_x11.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 7874d9fd01f2..574eccd78d0a 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1197,6 +1197,7 @@ x11_acquire_next_image_poll_x11(struct x11_swapchain *chain,
       xcb_flush(chain->conn);
 
       if (timeout == UINT64_MAX) {
+         /* See comments in x11_manage_fifo_queues about problem scenarios with this call. */
          event = xcb_wait_for_special_event(chain->conn, chain->special_event);
          if (!event)
             return x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
@@ -1684,6 +1685,22 @@ x11_manage_fifo_queues(void *state)
                  * VUID-vkAcquireNextImageKHR-swapchain-01802 */
                 x11_driver_owned_images(chain) < forward_progress_guaranteed_acquired_images) {
 
+            /* Calls to xcb_wait_for_special_event are broken by design due to a XCB flaw.
+             * This call may hang indefinitely if the X window is destroyed before the swapchain.
+             * An X window destruction does not trigger a special event here, unfortunately.
+             *
+             * A workaround was attempted in
+             * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/13564#note_1121977, but
+             * was reverted due to its high CPU usage.
+             * No pragmatic solution exists that solves CPU usage and stutter problems.
+             *
+             * A xcb_poll call followed by poll() is a race condition if other threads read from the XCB connection FD
+             * between the xcb poll and fd poll(), even if it's completely unrelated to this event queue.
+             * poll() may end up waiting indefinitely even if the XCB event has been moved from the FD
+             * to chain->special_event queue.
+             * The proper fix is a wait_for_special_event_with_timeout, but it does not exist.
+             * See https://gitlab.freedesktop.org/xorg/lib/libxcb/-/merge_requests/9.
+             * For now, keep this approach. Applications are generally well-behaved. */
             xcb_generic_event_t *event =
                xcb_wait_for_special_event(chain->conn, chain->special_event);
             if (!event) {
@@ -2161,6 +2178,7 @@ static VkResult x11_wait_for_present_polled(
       xcb_flush(chain->conn);
 
       if (timeout == UINT64_MAX) {
+         /* See comments in x11_manage_fifo_queues about problem scenarios with this call. */
          event = xcb_wait_for_special_event(chain->conn, chain->special_event);
          if (!event) {
             result = x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
-- 
GitLab


From a29de7bfa9bfddb16562cfe3ffc743bd8a406599 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Wed, 26 Oct 2022 14:17:22 +0200
Subject: [PATCH 12/13] wsi/x11: Rewrite wait logic for ANI/WaitForPresentKHR.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When we need to poll the XCB connection with a non-trivial timeout,
be very careful to not hit an XCB bug where a poll() may hang for too
long even if an event is ready in the special event queue.

This is a pragmatic workaround, a wait_for_special_event_with_timeout()
is the only proper solution here.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Michel Dänzer <mdaenzer@redhat.com>
---
 src/vulkan/wsi/wsi_common_x11.c | 140 +++++++++++++++++---------------
 1 file changed, 75 insertions(+), 65 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 574eccd78d0a..fb0ec25d9c6c 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1162,14 +1162,65 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
    return VK_SUCCESS;
 }
 
-
-static uint64_t wsi_get_absolute_timeout(uint64_t timeout)
+static VkResult
+x11_poll_for_special_event(struct x11_swapchain *chain, uint64_t abs_timeout, xcb_generic_event_t **out_event)
 {
-   uint64_t current_time = os_time_get_nano();
+   /* Start out with 1 ms intervals since that's what poll() supports. */
+   uint64_t poll_busywait_ns = 1000 * 1000;
+   xcb_generic_event_t *event;
+   uint64_t rel_timeout;
+   struct pollfd pfds;
+
+   assert(abs_timeout != UINT64_MAX);
+
+   /* abs_timeout is assumed to be in timebase of os_time_get_absolute_timeout(). */
+
+   /* See comments in x11_manage_fifo_queues about problems with xcb_poll followed by poll().
+    * This path is suboptimal for scenarios where we're doing:
+    * - IMMEDIATE / MAILBOX (no acquire queue) and
+    * - Timeout that is neither 0 nor UINT64_MAX (very rare).
+    * The only real solution is a busy-poll scheme to ensure we don't sleep for too long.
+    * In a forward progress scenario, the XCB FD will be written at least once per frame,
+    * so we expect frequent wake-ups either way.
+    * This is a best-effort pragmatic solution until we have a proper solution in XCB.
+    */
+
+   rel_timeout = abs_timeout;
+   *out_event = NULL;
+   event = NULL;
+
+   while (1) {
+      event = xcb_poll_for_special_event(chain->conn, chain->special_event);
+
+      if (event || rel_timeout == 0)
+         break;
 
-   timeout = MIN2(UINT64_MAX - current_time, timeout);
+      /* If a non-special event happens, the fd will still
+       * poll. So recalculate the timeout now just in case.
+       */
+      uint64_t current_time = os_time_get_nano();
+      if (abs_timeout > current_time)
+         rel_timeout = MIN2(poll_busywait_ns, abs_timeout - current_time);
+      else
+         rel_timeout = 0;
+
+      if (rel_timeout) {
+         pfds.fd = xcb_get_file_descriptor(chain->conn);
+         pfds.events = POLLIN;
+         int ret = poll(&pfds, 1, MAX2(rel_timeout / 1000 / 1000, 1u));
+         if (ret == -1)
+            return VK_ERROR_OUT_OF_DATE_KHR;
+
+         /* Gradually increase the poll duration if it takes a very long time to receive a poll event,
+          * since at that point, stutter isn't really the main concern anymore.
+          * We generally expect a special event to be received once every refresh duration. */
+         poll_busywait_ns += poll_busywait_ns / 2;
+         poll_busywait_ns = MIN2(10ull * 1000ull * 1000ull, poll_busywait_ns);
+      }
+   }
 
-   return current_time + timeout;
+   *out_event = event;
+   return event ? VK_SUCCESS : VK_TIMEOUT;
 }
 
 /**
@@ -1181,8 +1232,13 @@ x11_acquire_next_image_poll_x11(struct x11_swapchain *chain,
                                 uint32_t *image_index, uint64_t timeout)
 {
    xcb_generic_event_t *event;
-   struct pollfd pfds;
+
    uint64_t atimeout;
+   if (timeout == 0 || timeout == UINT64_MAX)
+      atimeout = timeout;
+   else
+      atimeout = os_time_get_absolute_timeout(timeout);
+
    while (1) {
       for (uint32_t i = 0; i < chain->base.image_count; i++) {
          if (!chain->images[i].busy) {
@@ -1202,31 +1258,12 @@ x11_acquire_next_image_poll_x11(struct x11_swapchain *chain,
          if (!event)
             return x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
       } else {
-         event = xcb_poll_for_special_event(chain->conn, chain->special_event);
-         if (!event) {
-            int ret;
-            if (timeout == 0)
-               return x11_swapchain_result(chain, VK_NOT_READY);
-
-            atimeout = wsi_get_absolute_timeout(timeout);
-
-            pfds.fd = xcb_get_file_descriptor(chain->conn);
-            pfds.events = POLLIN;
-            ret = poll(&pfds, 1, timeout / 1000 / 1000);
-            if (ret == 0)
-               return x11_swapchain_result(chain, VK_TIMEOUT);
-            if (ret == -1)
-               return x11_swapchain_result(chain, VK_ERROR_OUT_OF_DATE_KHR);
-
-            /* If a non-special event happens, the fd will still
-             * poll. So recalculate the timeout now just in case.
-             */
-            uint64_t current_time = os_time_get_nano();
-            if (atimeout > current_time)
-               timeout = atimeout - current_time;
-            else
-               timeout = 0;
-            continue;
+         VkResult result = x11_poll_for_special_event(chain, atimeout, &event);
+         if (result == VK_TIMEOUT) {
+            /* AcquireNextImageKHR reserves a special return value for 0 timeouts. */
+            return x11_swapchain_result(chain, timeout == 0 ? VK_NOT_READY : VK_TIMEOUT);
+         } else if (result != VK_SUCCESS) {
+            return x11_swapchain_result(chain, result);
          }
       }
 
@@ -2185,42 +2222,15 @@ static VkResult x11_wait_for_present_polled(
             goto fail;
          }
       } else {
-         event = xcb_poll_for_special_event(chain->conn, chain->special_event);
-         if (!event) {
-            if (timeout == 0) {
-               result = x11_swapchain_result(chain, VK_TIMEOUT);
-               goto fail;
-            }
-
-            uint64_t current_time = os_time_get_nano();
-            if (abs_timeout_monotonic > current_time)
-               timeout = abs_timeout_monotonic - current_time;
-            else
-               timeout = 0;
-
-            struct pollfd pfds;
-            pfds.fd = xcb_get_file_descriptor(chain->conn);
-            pfds.events = POLLIN;
-            ret = poll(&pfds, 1, timeout / 1000 / 1000);
-
-            if (ret == 0) {
-               result = x11_swapchain_result(chain, VK_TIMEOUT);
-               goto fail;
-            }
-
-            if (ret == -1) {
-               result = x11_swapchain_result(chain, VK_ERROR_OUT_OF_DATE_KHR);
-               goto fail;
-            }
-         }
+         result = x11_poll_for_special_event(chain, abs_timeout_monotonic, &event);
+         if (result != VK_SUCCESS)
+            goto fail;
       }
 
-      if (event) {
-         result = x11_handle_dri3_present_event(chain, (void *)event);
-         /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
-         result = x11_swapchain_result(chain, result);
-         free(event);
-      }
+      result = x11_handle_dri3_present_event(chain, (void *)event);
+      /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
+      result = x11_swapchain_result(chain, result);
+      free(event);
    }
 
 fail:
-- 
GitLab


From 3d78c41b898d27a1e5ec325e6acf9f9d6d309b33 Mon Sep 17 00:00:00 2001
From: Hans-Kristian Arntzen <post@arntzen-software.no>
Date: Fri, 18 Nov 2022 19:30:18 +0100
Subject: [PATCH 13/13] docs: Mark VK_KHR_present_wait as supported.

Signed-off-by: Hans-Kristian Arntzen <post@arntzen-software.no>
Reviewed-by: Joshua Ashton <joshua@froggi.es>
---
 docs/features.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/docs/features.txt b/docs/features.txt
index 6830b96e87d2..29f56d46d314 100644
--- a/docs/features.txt
+++ b/docs/features.txt
@@ -518,6 +518,7 @@ Khronos extensions that are not part of any Vulkan version:
   VK_KHR_performance_query                              DONE (anv/gen8+, radv/gfx10.3+, tu, v3dv)
   VK_KHR_pipeline_executable_properties                 DONE (anv, radv, tu, v3dv)
   VK_KHR_pipeline_library                               DONE (lvp, radv)
+  VK_KHR_present_wait                                   DONE (anv, radv, tu, x11/display)
   VK_KHR_push_descriptor                                DONE (anv, lvp, radv, tu)
   VK_KHR_ray_query                                      DONE (radv/gfx10.3+)
   VK_KHR_ray_tracing_maintenance1                       DONE (radv/gfx10.3+)
-- 
GitLab

