From de5f603e410fe0aac69b308ff473bc1feda1d21f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 08:12:51 +0200
Subject: [PATCH 1/3] aco/optimizer_postRA: Use unique_ptr + array for
 instruction indices.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

According to perf, this roughly halves the impact of the post-RA
optimizer in ACO's compile times.

Measurement was taken using a debug optimized build using
NIR_DEBUG=novalidate RADV_DEBUG=nocache and replaying the Fossil DB
from the Doom Eternal shaders.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 96edae93071b..7fb522f0b309 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -63,11 +63,22 @@ Idx const_or_undef{UINT32_MAX, 2};
 Idx overwritten_untrackable{UINT32_MAX, 3};
 
 struct pr_opt_ctx {
+   using Idx_array = std::array<Idx, max_reg_cnt>;
+
    Program* program;
    Block* current_block;
    uint32_t current_instr_idx;
    std::vector<uint16_t> uses;
-   std::vector<std::array<Idx, max_reg_cnt>> instr_idx_by_regs;
+   std::unique_ptr<Idx_array[]> instr_idx_by_regs;
+
+   pr_opt_ctx(Program* p)
+      : program(p)
+      , current_block(nullptr)
+      , current_instr_idx(0)
+      , uses(dead_code_analysis(p))
+      , instr_idx_by_regs(new Idx_array[p->blocks.size()])
+   {
+   }
 
    void reset_block(Block* block)
    {
@@ -557,10 +568,7 @@ process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 void
 optimize_postRA(Program* program)
 {
-   pr_opt_ctx ctx;
-   ctx.program = program;
-   ctx.uses = dead_code_analysis(program);
-   ctx.instr_idx_by_regs.resize(program->blocks.size());
+   pr_opt_ctx ctx(program);
 
    /* Forward pass
     * Goes through each instruction exactly once, and can transform
-- 
GitLab


From 4012e55635e5b3c45b3f71bd4f9b47020b3a4109 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 09:05:27 +0200
Subject: [PATCH 2/3] aco/optimizer_postRA: Speed up reset_block() with
 predecessors.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Copy the information from the first predecessor then check whether
it matches other predecessors and modify the data accordingly.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 53 ++++++++++-------------
 1 file changed, 24 insertions(+), 29 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 7fb522f0b309..40eb8e2aa3d3 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -80,6 +80,28 @@ struct pr_opt_ctx {
    {
    }
 
+   ALWAYS_INLINE void reset_block_regs(const std::vector<uint32_t>& preds, const unsigned block_index, const unsigned min_reg, const unsigned num_regs)
+   {
+      const unsigned num_preds = preds.size();
+      const unsigned first_pred = preds[0];
+
+      /* Copy information from the first predecessor. */
+      memcpy(&instr_idx_by_regs[block_index][min_reg], &instr_idx_by_regs[first_pred][min_reg], num_regs * sizeof(Idx));
+
+      /* Mark overwritten if it doesn't match with other predecessors. */
+      const unsigned until_reg = min_reg + num_regs;
+      for (unsigned pred = 1; pred < num_preds; ++pred) {
+         for (unsigned i = min_reg; i < until_reg; ++i) {
+            Idx& idx = instr_idx_by_regs[block_index][i];
+            if (idx == overwritten_untrackable)
+               continue;
+
+            if (idx != instr_idx_by_regs[pred][i])
+               idx = overwritten_untrackable;
+         }
+      }
+   }
+
    void reset_block(Block* block)
    {
       current_block = block;
@@ -89,40 +111,13 @@ struct pr_opt_ctx {
          std::fill(instr_idx_by_regs[block->index].begin(), instr_idx_by_regs[block->index].end(),
                    not_written_yet);
       } else {
-         const uint32_t first_linear_pred = block->linear_preds[0];
-         const std::vector<uint32_t>& linear_preds = block->linear_preds;
-
-         for (unsigned i = 0; i < max_sgpr_cnt; i++) {
-            const bool all_same = std::all_of(
-               std::next(linear_preds.begin()), linear_preds.end(),
-               [=](unsigned pred)
-               { return instr_idx_by_regs[pred][i] == instr_idx_by_regs[first_linear_pred][i]; });
-
-            if (all_same)
-               instr_idx_by_regs[block->index][i] = instr_idx_by_regs[first_linear_pred][i];
-            else
-               instr_idx_by_regs[block->index][i] = overwritten_untrackable;
-         }
+         reset_block_regs(block->linear_preds, block->index, 0, max_sgpr_cnt);
 
          if (!block->logical_preds.empty()) {
             /* We assume that VGPRs are only read by blocks which have a logical predecessor,
              * ie. any block that reads any VGPR has at least 1 logical predecessor.
              */
-            const unsigned first_logical_pred = block->logical_preds[0];
-            const std::vector<uint32_t>& logical_preds = block->logical_preds;
-
-            for (unsigned i = min_vgpr; i < (min_vgpr + max_vgpr_cnt); i++) {
-               const bool all_same = std::all_of(
-                  std::next(logical_preds.begin()), logical_preds.end(),
-                  [=](unsigned pred) {
-                     return instr_idx_by_regs[pred][i] == instr_idx_by_regs[first_logical_pred][i];
-                  });
-
-               if (all_same)
-                  instr_idx_by_regs[block->index][i] = instr_idx_by_regs[first_logical_pred][i];
-               else
-                  instr_idx_by_regs[block->index][i] = overwritten_untrackable;
-            }
+            reset_block_regs(block->logical_preds, block->index, min_vgpr, max_vgpr_cnt);
          } else {
             /* If a block has no logical predecessors, it is not part of the
              * logical CFG and therefore it also won't have any logical successors.
-- 
GitLab


From 45e5c1ef88961eaaa36b6078fd2c7f2c41ffc3d6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 10:05:51 +0200
Subject: [PATCH 3/3] aco/optimizer_postRA: Delete dead instructions more
 efficiently.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 40eb8e2aa3d3..a831bc8a8619 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -581,10 +581,17 @@ optimize_postRA(Program* program)
     * no longer have any uses.
     */
    for (auto& block : program->blocks) {
-      auto new_end = std::remove_if(block.instructions.begin(), block.instructions.end(),
-                                    [&ctx](const aco_ptr<Instruction>& instr)
-                                    { return !instr || is_dead(ctx.uses, instr.get()); });
-      block.instructions.resize(new_end - block.instructions.begin());
+      std::vector<aco_ptr<Instruction>> instructions;
+      instructions.reserve(block.instructions.size());
+
+      for (aco_ptr<Instruction>& instr : block.instructions) {
+         if (!instr || is_dead(ctx.uses, instr.get()))
+            continue;
+
+         instructions.emplace_back(std::move(instr));
+      }
+
+      block.instructions = std::move(instructions);
    }
 }
 
-- 
GitLab

