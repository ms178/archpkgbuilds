From edfa58e0c8241b9916084b9fed9d7cbd9f18e0de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 08:12:51 +0200
Subject: [PATCH 1/5] aco/optimizer_postRA: Initialize context, use raw pointer
 not vector.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

According to perf, this roughly halves the impact of the post-RA
optimizer in ACO's compile times.

Measurement was taken using a debug optimized build using
NIR_DEBUG=novalidate RADV_DEBUG=nocache and replaying the Fossil DB
from the Doom Eternal shaders.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 23 ++++++++++++++++++-----
 1 file changed, 18 insertions(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 726cff40a0c9..05d7c5071aa8 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -51,11 +51,27 @@ Idx const_or_undef{UINT32_MAX, 2};
 Idx written_by_multiple_instrs{UINT32_MAX, 3};
 
 struct pr_opt_ctx {
+   using Idx_array = std::array<Idx, max_reg_cnt>;
+
    Program* program;
    Block* current_block;
    uint32_t current_instr_idx;
    std::vector<uint16_t> uses;
-   std::vector<std::array<Idx, max_reg_cnt>> instr_idx_by_regs;
+   Idx_array* instr_idx_by_regs;
+
+   pr_opt_ctx(Program* p)
+      : program(p)
+      , current_block(nullptr)
+      , current_instr_idx(0)
+      , uses(dead_code_analysis(p))
+      , instr_idx_by_regs(static_cast<Idx_array*>(malloc(p->blocks.size() * sizeof(Idx_array))))
+   {
+   }
+
+   ~pr_opt_ctx()
+   {
+      free(instr_idx_by_regs);
+   }

    void reset_block(Block* block)
    {
@@ -467,10 +483,7 @@ process_instruction(pr_opt_ctx& ctx, aco_ptr<Instruction>& instr)
 void
 optimize_postRA(Program* program)
 {
-   pr_opt_ctx ctx;
-   ctx.program = program;
-   ctx.uses = dead_code_analysis(program);
-   ctx.instr_idx_by_regs.resize(program->blocks.size());
+   pr_opt_ctx ctx(program);
 
    /* Forward pass
     * Goes through each instruction exactly once, and can transform
-- 
GitLab


From 238da291f2e80c2986fcf4a55a9ee80e6865a7be Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 09:05:27 +0200
Subject: [PATCH 2/5] aco/optimizer_postRA: Speed up reset_block() with
 predecessors.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Copy the information from the first predecessor then check whether
it matches other predecessors and modify the data accordingly.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 32 +++++++++++++++--------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 05d7c5071aa8..6ad1db25503f 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -73,6 +73,17 @@ struct pr_opt_ctx {
       free(instr_idx_by_regs);
    }
 
+   inline void reset_instr_idx_by_reg(Block* block, unsigned pred, unsigned i)
+   {
+      Idx& idx = instr_idx_by_regs[block->index][i];
+
+      if (idx == not_written_in_block)
+         return;
+
+      if (idx != instr_idx_by_regs[pred][i])
+         idx = not_written_in_block;
+   }
+
    void reset_block(Block* block)
    {
       current_block = block;
@@ -82,17 +93,16 @@ struct pr_opt_ctx {
          std::fill(instr_idx_by_regs[block->index].begin(), instr_idx_by_regs[block->index].end(),
                    not_written_in_block);
       } else {
-         unsigned first_pred = block->linear_preds[0];
-         for (unsigned i = 0; i < max_reg_cnt; i++) {
-            bool all_same = std::all_of(
-               std::next(block->linear_preds.begin()), block->linear_preds.end(),
-               [&](unsigned pred)
-               { return instr_idx_by_regs[pred][i] == instr_idx_by_regs[first_pred][i]; });
-
-            if (all_same)
-               instr_idx_by_regs[block->index][i] = instr_idx_by_regs[first_pred][i];
-            else
-               instr_idx_by_regs[block->index][i] = not_written_in_block;
+         const unsigned num_preds = block->linear_preds.size();
+         const unsigned first_pred = block->linear_preds[0];
+
+         /* Copy information from the first predecessor. */
+         memcpy(&instr_idx_by_regs[block->index][0], &instr_idx_by_regs[first_pred][0], max_reg_cnt * sizeof(Idx));
+
+         /* Reset to not_written_in_block if it doesn't match with other predecessors. */
+         for (unsigned pred = 1; pred < num_preds; ++pred) {
+            for (unsigned i = 0; i < max_reg_cnt; ++i)
+               reset_instr_idx_by_reg(block, pred, i);
          }
       }
    }
-- 
GitLab


From e5bf1346c7ec564729ec9e5c5b76835c24dbb1a2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 09:57:10 +0200
Subject: [PATCH 3/5] aco: Save max used SGPR and VGPR to Program.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_ir.h                    | 2 ++
 src/amd/compiler/aco_register_allocation.cpp | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 4394cee22843..b0055c825d98 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -2103,6 +2103,8 @@ public:
 
    uint16_t num_waves = 0;
    uint16_t min_waves = 0;
+   uint16_t max_used_sgpr = 0;
+   uint16_t max_used_vgpr = 0;
    unsigned workgroup_size; /* if known; otherwise UINT_MAX */
    bool wgp_mode;
    bool early_rast = false; /* whether rasterization can start as soon as the 1st DONE pos export */
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index c1cc2d917c58..e917c9148a1a 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -3085,6 +3085,8 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
    /* num_gpr = rnd_up(max_used_gpr + 1) */
    program->config->num_vgprs = get_vgpr_alloc(program, ctx.max_used_vgpr + 1);
    program->config->num_sgprs = get_sgpr_alloc(program, ctx.max_used_sgpr + 1);
+   program->max_used_vgpr = ctx.max_used_vgpr;
+   program->max_used_sgpr = ctx.max_used_sgpr;
 
    program->progress = CompilationProgress::after_ra;
 }
-- 
GitLab


From fb8f0b601124c0a47f0deb7227bed2329520129a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 09:57:32 +0200
Subject: [PATCH 4/5] aco/optimize_postRA: Deal with SGPRs/VGPRs separately in
 reset_block.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should reduce the number of iterations in the loop that
examines and sets the instruction indices by register, as well as
the amount of bytes copied.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 30 ++++++++++++++++++++---
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 6ad1db25503f..6ab928119198 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -34,6 +34,9 @@ namespace aco {
 namespace {
 
 constexpr const size_t max_reg_cnt = 512;
+constexpr const size_t min_vgpr = 256;
+constexpr const size_t min_special_sgpr = vcc.reg();
+constexpr const size_t max_special_sgpr = exec_hi.reg();
 
 struct Idx {
    bool operator==(const Idx& other) const { return block == other.block && instr == other.instr; }
@@ -56,6 +59,8 @@ struct pr_opt_ctx {
    Program* program;
    Block* current_block;
    uint32_t current_instr_idx;
+   uint32_t max_sgpr;
+   uint32_t max_vgpr;
    std::vector<uint16_t> uses;
    Idx_array* instr_idx_by_regs;
 
@@ -63,6 +68,8 @@ struct pr_opt_ctx {
       : program(p)
       , current_block(nullptr)
       , current_instr_idx(0)
+      , max_sgpr(program->max_used_sgpr)
+      , max_vgpr(min_vgpr + p->max_used_vgpr)
       , uses(dead_code_analysis(p))
       , instr_idx_by_regs(static_cast<Idx_array*>(malloc(p->blocks.size() * sizeof(Idx_array))))
    {
@@ -89,19 +96,34 @@ struct pr_opt_ctx {
       current_block = block;
       current_instr_idx = 0;
 
+      const uint32_t num_sgpr = max_sgpr + 1;
+      const uint32_t num_vgpr = max_vgpr - min_vgpr + 1;
+      constexpr const size_t num_special_sgpr = max_special_sgpr - min_special_sgpr + 1;
+
       if ((block->kind & block_kind_loop_header) || block->linear_preds.empty()) {
-         std::fill(instr_idx_by_regs[block->index].begin(), instr_idx_by_regs[block->index].end(),
-                   not_written_in_block);
+         auto sgpr_start = instr_idx_by_regs[block->index].begin();
+         auto special_sgpr_start = sgpr_start + min_special_sgpr;
+         auto vgpr_start = sgpr_start + min_vgpr;
+
+         std::fill(sgpr_start, sgpr_start + num_sgpr, not_written_in_block);
+         std::fill(special_sgpr_start, special_sgpr_start + num_special_sgpr, not_written_in_block);
+         std::fill(vgpr_start, vgpr_start + num_vgpr, not_written_in_block);
       } else {
          const unsigned num_preds = block->linear_preds.size();
          const unsigned first_pred = block->linear_preds[0];
 
          /* Copy information from the first predecessor. */
-         memcpy(&instr_idx_by_regs[block->index][0], &instr_idx_by_regs[first_pred][0], max_reg_cnt * sizeof(Idx));
+         memcpy(&instr_idx_by_regs[block->index][0], &instr_idx_by_regs[first_pred][0], num_sgpr * sizeof(Idx));
+         memcpy(&instr_idx_by_regs[block->index][min_special_sgpr], &instr_idx_by_regs[first_pred][min_special_sgpr], num_special_sgpr * sizeof(Idx));
+         memcpy(&instr_idx_by_regs[block->index][min_vgpr], &instr_idx_by_regs[first_pred][min_vgpr], num_vgpr * sizeof(Idx));
 
          /* Reset to not_written_in_block if it doesn't match with other predecessors. */
          for (unsigned pred = 1; pred < num_preds; ++pred) {
-            for (unsigned i = 0; i < max_reg_cnt; ++i)
+            for (unsigned i = 0; i <= max_sgpr; ++i)
+               reset_instr_idx_by_reg(block, pred, i);
+            for (unsigned i = min_special_sgpr; i <= max_special_sgpr; ++i)
+               reset_instr_idx_by_reg(block, pred, i);
+            for (unsigned i = min_vgpr; i <= max_vgpr; ++i)
                reset_instr_idx_by_reg(block, pred, i);
          }
       }
-- 
GitLab


From 92afaa2ab41c42cf525be73e3d6b19eee36cd43d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Wed, 17 Aug 2022 10:05:51 +0200
Subject: [PATCH 5/5] aco/optimizer_postRA: Delete dead instructions more
 efficiently.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/compiler/aco_optimizer_postRA.cpp | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer_postRA.cpp b/src/amd/compiler/aco_optimizer_postRA.cpp
index 6ab928119198..85a5a0c0b101 100644
--- a/src/amd/compiler/aco_optimizer_postRA.cpp
+++ b/src/amd/compiler/aco_optimizer_postRA.cpp
@@ -533,10 +533,17 @@ optimize_postRA(Program* program)
     * no longer have any uses.
     */
    for (auto& block : program->blocks) {
-      auto new_end = std::remove_if(block.instructions.begin(), block.instructions.end(),
-                                    [&ctx](const aco_ptr<Instruction>& instr)
-                                    { return !instr || is_dead(ctx.uses, instr.get()); });
-      block.instructions.resize(new_end - block.instructions.begin());
+      std::vector<aco_ptr<Instruction>> instructions;
+      instructions.reserve(block.instructions.size());
+
+      for (aco_ptr<Instruction>& instr : block.instructions) {
+         if (!instr || is_dead(ctx.uses, instr.get()))
+            continue;
+
+         instructions.emplace_back(std::move(instr));
+      }
+
+      block.instructions = std::move(instructions);
    }
 }
 
-- 
GitLab

