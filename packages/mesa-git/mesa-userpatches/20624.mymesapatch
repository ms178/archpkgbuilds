From ba6df0bd2368970ebd5865df853bd854a2b33a4f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 12 Dec 2022 23:18:37 -0500
Subject: [PATCH 01/20] glthread: rewrite glMultiDrawArrays to never fail to
 upload vertices

The main goal is to never fail to upload non-VBO vertex arrays.
When glthread synchronized, it didn't upload vertices, expecting st/mesa
to do that. This keeps the required sync, and then upload vertices
in glthread.

Also, reorder the code and remove goto statements. This is pretty much
a rewrite.
---
 src/mesa/main/glthread_draw.c | 153 ++++++++++++++++------------------
 1 file changed, 74 insertions(+), 79 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 30ecb5048543..7dc8eabf0152 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -506,107 +506,102 @@ _mesa_unmarshal_MultiDrawArraysUserBuf(struct gl_context *ctx,
    return cmd->cmd_base.cmd_size;
 }
 
-static ALWAYS_INLINE bool
-multi_draw_arrays_async(struct gl_context *ctx, GLenum mode,
-                        const GLint *first, const GLsizei *count,
-                        GLsizei draw_count, unsigned user_buffer_mask,
-                        const struct glthread_attrib_binding *buffers)
-{
-   int real_draw_count = MAX2(draw_count, 0);
-   int first_size = sizeof(GLint) * real_draw_count;
-   int count_size = sizeof(GLsizei) * real_draw_count;
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
-   int cmd_size = sizeof(struct marshal_cmd_MultiDrawArraysUserBuf) +
-                  first_size + count_size + buffers_size;
-   struct marshal_cmd_MultiDrawArraysUserBuf *cmd;
-
-   /* Make sure cmd can fit the queue buffer */
-   if (cmd_size > MARSHAL_MAX_CMD_SIZE) {
-      return false;
-   }
-
-   cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysUserBuf,
-                                         cmd_size);
-   cmd->mode = mode;
-   cmd->draw_count = draw_count;
-   cmd->user_buffer_mask = user_buffer_mask;
-
-   char *variable_data = (char*)(cmd + 1);
-   memcpy(variable_data, first, first_size);
-   variable_data += first_size;
-   memcpy(variable_data, count, count_size);
-
-   if (user_buffer_mask) {
-      variable_data += count_size;
-      memcpy(variable_data, buffers, buffers_size);
-   }
-
-   return true;
-}
-
 void GLAPIENTRY
 _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
                               const GLsizei *count, GLsizei draw_count)
 {
    GET_CURRENT_CONTEXT(ctx);
-
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    unsigned user_buffer_mask =
-      draw_count <= 0 ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+      ctx->API == API_OPENGL_CORE || draw_count <= 0 ?
+            0 : vao->UserPointerMask & vao->BufferEnabled;
 
-   if (ctx->GLThread.ListMode)
-      goto sync;
-
-   if ((ctx->API == API_OPENGL_CORE || !user_buffer_mask) &&
-       multi_draw_arrays_async(ctx, mode, first, count, draw_count, 0, NULL)) {
+   if (ctx->GLThread.ListMode) {
+      _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
+      CALL_MultiDrawArrays(ctx->CurrentServerDispatch,
+                           (mode, first, count, draw_count));
       return;
    }
 
-   assert(draw_count > 0);
+   struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
 
-   /* If the draw count is too high, the queue can't be used. */
-   if (draw_count > MARSHAL_MAX_CMD_SIZE / 16)
-      goto sync;
+   if (user_buffer_mask) {
+      unsigned min_index = ~0;
+      unsigned max_index_exclusive = 0;
 
-   unsigned min_index = ~0;
-   unsigned max_index_exclusive = 0;
+      for (int i = 0; i < draw_count; i++) {
+         GLsizei vertex_count = count[i];
 
-   for (unsigned i = 0; i < draw_count; i++) {
-      GLsizei vertex_count = count[i];
+         if (vertex_count < 0) {
+            /* This will just call the driver to set the GL error. */
+            min_index = ~0;
+            break;
+         }
+         if (vertex_count == 0)
+            continue;
 
-      if (vertex_count < 0) {
-         /* Just call the driver to set the error. */
-         multi_draw_arrays_async(ctx, mode, first, count, draw_count, 0, NULL);
-         return;
+         min_index = MIN2(min_index, first[i]);
+         max_index_exclusive = MAX2(max_index_exclusive, first[i] + vertex_count);
       }
-      if (vertex_count == 0)
-         continue;
 
-      min_index = MIN2(min_index, first[i]);
-      max_index_exclusive = MAX2(max_index_exclusive, first[i] + vertex_count);
-   }
+      if (min_index >= max_index_exclusive) {
+         /* Nothing to do, but call the driver to set possible GL errors. */
+         user_buffer_mask = 0;
+      } else {
+         /* Upload. */
+         unsigned num_vertices = max_index_exclusive - min_index;
 
-   unsigned num_vertices = max_index_exclusive - min_index;
-   if (num_vertices == 0) {
-      /* Nothing to do, but call the driver to set possible GL errors. */
-      multi_draw_arrays_async(ctx, mode, first, count, draw_count, 0, NULL);
-      return;
+         if (!upload_vertices(ctx, user_buffer_mask, min_index, num_vertices,
+                              0, 1, buffers))
+            return; /* the error is set by upload_vertices */
+      }
    }
 
-   /* Upload and draw. */
-   struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
-   if (!upload_vertices(ctx, user_buffer_mask, min_index, num_vertices,
-                        0, 1, buffers))
-      return; /* the error is set by upload_vertices */
+   /* Add the call into the batch buffer. */
+   int real_draw_count = MAX2(draw_count, 0);
+   int first_size = sizeof(GLint) * real_draw_count;
+   int count_size = sizeof(GLsizei) * real_draw_count;
+   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   int cmd_size = sizeof(struct marshal_cmd_MultiDrawArraysUserBuf) +
+                  first_size + count_size + buffers_size;
+   struct marshal_cmd_MultiDrawArraysUserBuf *cmd;
 
-   multi_draw_arrays_async(ctx, mode, first, count, draw_count,
-                           user_buffer_mask, buffers);
-   return;
+   /* Make sure cmd can fit in the batch buffer */
+   if (cmd_size <= MARSHAL_MAX_CMD_SIZE) {
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysUserBuf,
+                                            cmd_size);
+      cmd->mode = mode;
+      cmd->draw_count = draw_count;
+      cmd->user_buffer_mask = user_buffer_mask;
 
-sync:
-   _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
-   CALL_MultiDrawArrays(ctx->CurrentServerDispatch,
-                        (mode, first, count, draw_count));
+      char *variable_data = (char*)(cmd + 1);
+      memcpy(variable_data, first, first_size);
+      variable_data += first_size;
+      memcpy(variable_data, count, count_size);
+
+      if (user_buffer_mask) {
+         variable_data += count_size;
+         memcpy(variable_data, buffers, buffers_size);
+      }
+   } else {
+      /* The call is too large, so sync and execute the unmarshal code here. */
+      _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
+
+      if (user_buffer_mask) {
+         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
+                                         false);
+      }
+
+      CALL_MultiDrawArrays(ctx->CurrentServerDispatch,
+                           (mode, first, count, draw_count));
+
+      /* Restore states. */
+      if (user_buffer_mask) {
+         /* TODO: remove this after glthread takes over all uploading */
+         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
+                                         true);
+      }
+   }
 }
 
 /* DrawElementsInstanced without user buffers. */
-- 
GitLab


From 4c4041f56c47dc2ed96dfe24e12f6efb95721f80 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 13 Dec 2022 00:00:28 -0500
Subject: [PATCH 02/20] glthread: change glMultiDrawElements to execute
 draw_count < 0 asynchronously

also clean up the conditions.
---
 src/mesa/main/glthread_draw.c | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 7dc8eabf0152..692808299c51 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -1068,9 +1068,10 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
                           unsigned user_buffer_mask,
                           const struct glthread_attrib_binding *buffers)
 {
-   int count_size = sizeof(GLsizei) * draw_count;
-   int indices_size = sizeof(indices[0]) * draw_count;
-   int basevertex_size = basevertex ? sizeof(GLsizei) * draw_count : 0;
+   int real_draw_count = MAX2(draw_count, 0);
+   int count_size = sizeof(GLsizei) * real_draw_count;
+   int indices_size = sizeof(indices[0]) * real_draw_count;
+   int basevertex_size = basevertex ? sizeof(GLsizei) * real_draw_count : 0;
    int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
    int cmd_size = sizeof(struct marshal_cmd_MultiDrawElementsUserBuf) +
                   count_size + indices_size + basevertex_size + buffers_size;
@@ -1144,28 +1145,30 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
    GET_CURRENT_CONTEXT(ctx);
 
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
-   unsigned user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
-   bool has_user_indices = vao->CurrentElementBufferName == 0;
+   unsigned user_buffer_mask = 0;
+   bool has_user_indices = false;
+
+   /* Non-VBO vertex arrays are used only if this is true.
+    * When nothing needs to be uploaded or the draw is no-op or generates
+    * a GL error, we don't upload anything.
+    */
+   if (ctx->API != API_OPENGL_CORE && draw_count > 0 &&
+       is_index_type_valid(type)) {
+      user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
+      has_user_indices = vao->CurrentElementBufferName == 0;
+   }
 
    if (ctx->GLThread.ListMode)
       goto sync;
 
-   /* Fast path when nothing needs to be done. */
-   if (draw_count >= 0 &&
-       (ctx->API == API_OPENGL_CORE ||
-        !is_index_type_valid(type) ||
-        (!user_buffer_mask && !has_user_indices))) {
+   /* Fast path when we don't need to upload anything. */
+   if (!user_buffer_mask && !has_user_indices) {
       multi_draw_elements_async(ctx, mode, count, type, indices,
                                 draw_count, basevertex, NULL, 0, NULL);
       return;
    }
 
    bool need_index_bounds = user_buffer_mask & ~vao->NonZeroDivisorMask;
-
-   /* If the draw count is negative, the queue can't be used. */
-   if (draw_count < 0)
-      goto sync;
-
    unsigned index_size = get_index_size(type);
    unsigned min_index = ~0;
    unsigned max_index = 0;
-- 
GitLab


From e64c5185b42798d89dbfa29d37b5b9d596f16765 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 18 Dec 2022 23:35:26 -0500
Subject: [PATCH 03/20] glthread: don't execute glDraw code if we're inside
 glBegin/End

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/glthread_draw.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 692808299c51..cf1d1f659de7 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -448,6 +448,7 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
    if (ctx->API == API_OPENGL_CORE || !user_buffer_mask ||
        count <= 0 || instance_count <= 0 ||
        /* This will just generate GL_INVALID_OPERATION, as it should. */
+       ctx->GLThread.inside_begin_end ||
        (!compiled_into_dlist && ctx->GLThread.ListMode)) {
       draw_arrays_async(ctx, mode, first, count, instance_count, baseinstance);
       return;
@@ -513,7 +514,8 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
    GET_CURRENT_CONTEXT(ctx);
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    unsigned user_buffer_mask =
-      ctx->API == API_OPENGL_CORE || draw_count <= 0 ?
+      ctx->API == API_OPENGL_CORE || draw_count <= 0 ||
+      ctx->GLThread.inside_begin_end ?
             0 : vao->UserPointerMask & vao->BufferEnabled;
 
    if (ctx->GLThread.ListMode) {
@@ -907,6 +909,7 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
        !is_index_type_valid(type) ||
        (!user_buffer_mask && !has_user_indices) ||
        /* This will just generate GL_INVALID_OPERATION, as it should. */
+       ctx->GLThread.inside_begin_end ||
        (!compiled_into_dlist && ctx->GLThread.ListMode)) {
       draw_elements_async(ctx, mode, count, type, indices, instance_count,
                           basevertex, baseinstance, index_bounds_valid,
@@ -1153,7 +1156,7 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
     * a GL error, we don't upload anything.
     */
    if (ctx->API != API_OPENGL_CORE && draw_count > 0 &&
-       is_index_type_valid(type)) {
+       is_index_type_valid(type) && !ctx->GLThread.inside_begin_end) {
       user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
       has_user_indices = vao->CurrentElementBufferName == 0;
    }
-- 
GitLab


From 01a98ae67b0162d833e2ea9a30b09c0bbce65a8e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 18 Dec 2022 17:14:41 -0500
Subject: [PATCH 04/20] glthread: don't pass index bounds to the driver for
 async calls

They are never used with vertex uploads in glthread.
For example, glDrawRangeElements is converted to glDrawElements.
---
 src/mesa/main/glthread_draw.c | 114 +++++++++-------------------------
 1 file changed, 31 insertions(+), 83 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index cf1d1f659de7..c10f94060ca2 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -696,68 +696,21 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *c
    return cmd_size;
 }
 
-struct marshal_cmd_DrawRangeElementsBaseVertex
-{
-   struct marshal_cmd_base cmd_base;
-   GLenum16 mode;
-   GLenum16 type;
-   GLsizei count;
-   GLint basevertex;
-   GLuint min_index;
-   GLuint max_index;
-   const GLvoid *indices;
-};
-
-uint32_t
-_mesa_unmarshal_DrawRangeElementsBaseVertex(struct gl_context *ctx,
-                                            const struct marshal_cmd_DrawRangeElementsBaseVertex *cmd)
-{
-   const GLenum mode = cmd->mode;
-   const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
-   const GLvoid *indices = cmd->indices;
-   const GLint basevertex = cmd->basevertex;
-   const GLuint min_index = cmd->min_index;
-   const GLuint max_index = cmd->max_index;
-
-   CALL_DrawRangeElementsBaseVertex(ctx->CurrentServerDispatch,
-                                    (mode, min_index, max_index, count,
-                                     type, indices, basevertex));
-   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
-   assert(cmd_size == cmd->cmd_base.cmd_size);
-   return cmd_size;
-}
-
 static ALWAYS_INLINE void
 draw_elements_async(struct gl_context *ctx, GLenum mode, GLsizei count,
                     GLenum type, const GLvoid *indices, GLsizei instance_count,
-                    GLint basevertex, GLuint baseinstance,
-                    bool index_bounds_valid, GLuint min_index, GLuint max_index)
+                    GLint basevertex, GLuint baseinstance)
 {
    if (instance_count == 1 && baseinstance == 0) {
-      if (index_bounds_valid) {
-         int cmd_size = sizeof(struct marshal_cmd_DrawRangeElementsBaseVertex);
-         struct marshal_cmd_DrawRangeElementsBaseVertex *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawRangeElementsBaseVertex, cmd_size);
-
-         cmd->mode = MIN2(mode, 0xffff);
-         cmd->type = MIN2(type, 0xffff);
-         cmd->count = count;
-         cmd->indices = indices;
-         cmd->basevertex = basevertex;
-         cmd->min_index = min_index;
-         cmd->max_index = max_index;
-      } else {
-         int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
-         struct marshal_cmd_DrawElementsBaseVertex *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
+      int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
+      struct marshal_cmd_DrawElementsBaseVertex *cmd =
+         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
 
-         cmd->mode = MIN2(mode, 0xffff);
-         cmd->type = MIN2(type, 0xffff);
-         cmd->count = count;
-         cmd->indices = indices;
-         cmd->basevertex = basevertex;
-      }
+      cmd->mode = MIN2(mode, 0xffff);
+      cmd->type = MIN2(type, 0xffff);
+      cmd->count = count;
+      cmd->indices = indices;
+      cmd->basevertex = basevertex;
    } else {
       if (basevertex == 0 && baseinstance == 0) {
          int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstanced);
@@ -788,15 +741,12 @@ draw_elements_async(struct gl_context *ctx, GLenum mode, GLsizei count,
 struct marshal_cmd_DrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
-   bool index_bounds_valid;
-   GLenum8 mode;
+   GLenum16 mode;
    GLenum16 type;
    GLsizei count;
    GLsizei instance_count;
    GLint basevertex;
    GLuint baseinstance;
-   GLuint min_index;
-   GLuint max_index;
    GLuint user_buffer_mask;
    const GLvoid *indices;
    struct gl_buffer_object *index_buffer;
@@ -813,8 +763,6 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    const GLsizei instance_count = cmd->instance_count;
    const GLint basevertex = cmd->basevertex;
    const GLuint baseinstance = cmd->baseinstance;
-   const GLuint min_index = cmd->min_index;
-   const GLuint max_index = cmd->max_index;
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
    struct gl_buffer_object *index_buffer = cmd->index_buffer;
    const struct glthread_attrib_binding *buffers =
@@ -830,16 +778,10 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    }
 
    /* Draw. */
-   if (cmd->index_bounds_valid && instance_count == 1 && baseinstance == 0) {
-      CALL_DrawRangeElementsBaseVertex(ctx->CurrentServerDispatch,
-                                       (mode, min_index, max_index, count,
-                                        type, indices, basevertex));
-   } else {
-      CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->CurrentServerDispatch,
-                                                       (mode, count, type, indices,
-                                                        instance_count, basevertex,
-                                                        baseinstance));
-   }
+   CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->CurrentServerDispatch,
+                                                    (mode, count, type, indices,
+                                                     instance_count, basevertex,
+                                                     baseinstance));
 
    /* Restore states. */
    if (index_buffer) {
@@ -856,7 +798,6 @@ static ALWAYS_INLINE void
 draw_elements_async_user(struct gl_context *ctx, GLenum mode, GLsizei count,
                          GLenum type, const GLvoid *indices, GLsizei instance_count,
                          GLint basevertex, GLuint baseinstance,
-                         bool index_bounds_valid, GLuint min_index, GLuint max_index,
                          struct gl_buffer_object *index_buffer,
                          unsigned user_buffer_mask,
                          const struct glthread_attrib_binding *buffers)
@@ -867,17 +808,14 @@ draw_elements_async_user(struct gl_context *ctx, GLenum mode, GLsizei count,
    struct marshal_cmd_DrawElementsUserBuf *cmd;
 
    cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
-   cmd->mode = MIN2(mode, 0xff); /* primitive types go from 0 to 14 */
+   cmd->mode = MIN2(mode, 0xffff);
    cmd->type = MIN2(type, 0xffff);
    cmd->count = count;
    cmd->indices = indices;
    cmd->instance_count = instance_count;
    cmd->basevertex = basevertex;
    cmd->baseinstance = baseinstance;
-   cmd->min_index = min_index;
-   cmd->max_index = max_index;
    cmd->user_buffer_mask = user_buffer_mask;
-   cmd->index_bounds_valid = index_bounds_valid;
    cmd->index_buffer = index_buffer;
 
    if (user_buffer_mask)
@@ -899,21 +837,24 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    if (compiled_into_dlist && ctx->GLThread.ListMode)
       goto sync;
 
+   if (unlikely(index_bounds_valid && max_index < min_index)) {
+      _mesa_marshal_InternalSetError(GL_INVALID_VALUE);
+      return;
+   }
+
    /* Fast path when nothing needs to be done.
     *
     * This is also an error path. Zero counts should still call the driver
     * for possible GL errors.
     */
-   if (ctx->API == API_OPENGL_CORE ||
-       count <= 0 || instance_count <= 0 || max_index < min_index ||
+   if (ctx->API == API_OPENGL_CORE || count <= 0 || instance_count <= 0 ||
        !is_index_type_valid(type) ||
        (!user_buffer_mask && !has_user_indices) ||
        /* This will just generate GL_INVALID_OPERATION, as it should. */
        ctx->GLThread.inside_begin_end ||
        (!compiled_into_dlist && ctx->GLThread.ListMode)) {
       draw_elements_async(ctx, mode, count, type, indices, instance_count,
-                          basevertex, baseinstance, index_bounds_valid,
-                          min_index, max_index);
+                          basevertex, baseinstance);
       return;
    }
 
@@ -966,8 +907,7 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
 
    /* Draw asynchronously. */
    draw_elements_async_user(ctx, mode, count, type, indices, instance_count,
-                            basevertex, baseinstance, index_bounds_valid,
-                            min_index, max_index, index_buffer,
+                            basevertex, baseinstance, index_buffer,
                             user_buffer_mask, buffers);
    return;
 
@@ -1422,6 +1362,14 @@ _mesa_unmarshal_DrawRangeElements(struct gl_context *ctx,
    return 0;
 }
 
+uint32_t
+_mesa_unmarshal_DrawRangeElementsBaseVertex(struct gl_context *ctx,
+                                            const struct marshal_cmd_DrawRangeElementsBaseVertex *cmd)
+{
+   unreachable("should never end up here");
+   return 0;
+}
+
 uint32_t
 _mesa_unmarshal_DrawElementsInstancedBaseVertex(struct gl_context *ctx,
                                                 const struct marshal_cmd_DrawElementsInstancedBaseVertex *cmd)
-- 
GitLab


From 3a1c13a58a37f30d6ccbde474d9943a0c007e831 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 18 Dec 2022 17:33:09 -0500
Subject: [PATCH 05/20] glthread: move some draw call parameters closer to
 their use

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/glthread_draw.c | 31 +++++++++++++++++--------------
 1 file changed, 17 insertions(+), 14 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index c10f94060ca2..33d57035417a 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -373,11 +373,6 @@ uint32_t
 _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
                                   const struct marshal_cmd_DrawArraysUserBuf *cmd)
 {
-   const GLenum mode = cmd->mode;
-   const GLint first = cmd->first;
-   const GLsizei count = cmd->count;
-   const GLsizei instance_count = cmd->instance_count;
-   const GLuint baseinstance = cmd->baseinstance;
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
    const struct glthread_attrib_binding *buffers =
       (const struct glthread_attrib_binding *)(cmd + 1);
@@ -388,6 +383,12 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
                                       false);
    }
 
+   const GLenum mode = cmd->mode;
+   const GLint first = cmd->first;
+   const GLsizei count = cmd->count;
+   const GLsizei instance_count = cmd->instance_count;
+   const GLuint baseinstance = cmd->baseinstance;
+
    CALL_DrawArraysInstancedBaseInstance(ctx->CurrentServerDispatch,
                                         (mode, first, count, instance_count,
                                          baseinstance));
@@ -756,13 +757,6 @@ uint32_t
 _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
                                     const struct marshal_cmd_DrawElementsUserBuf *cmd)
 {
-   const GLenum mode = cmd->mode;
-   const GLsizei count = cmd->count;
-   const GLenum type = cmd->type;
-   const GLvoid *indices = cmd->indices;
-   const GLsizei instance_count = cmd->instance_count;
-   const GLint basevertex = cmd->basevertex;
-   const GLuint baseinstance = cmd->baseinstance;
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
    struct gl_buffer_object *index_buffer = cmd->index_buffer;
    const struct glthread_attrib_binding *buffers =
@@ -778,6 +772,14 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    }
 
    /* Draw. */
+   const GLenum mode = cmd->mode;
+   const GLsizei count = cmd->count;
+   const GLenum type = cmd->type;
+   const GLvoid *indices = cmd->indices;
+   const GLsizei instance_count = cmd->instance_count;
+   const GLint basevertex = cmd->basevertex;
+   const GLuint baseinstance = cmd->baseinstance;
+
    CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->CurrentServerDispatch,
                                                     (mode, count, type, indices,
                                                      instance_count, basevertex,
@@ -952,8 +954,6 @@ uint32_t
 _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
                                          const struct marshal_cmd_MultiDrawElementsUserBuf *cmd)
 {
-   const GLenum mode = cmd->mode;
-   const GLenum type = cmd->type;
    const GLsizei draw_count = cmd->draw_count;
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
    struct gl_buffer_object *index_buffer = cmd->index_buffer;
@@ -982,6 +982,9 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
    }
 
    /* Draw. */
+   const GLenum mode = cmd->mode;
+   const GLenum type = cmd->type;
+
    if (has_base_vertex) {
       CALL_MultiDrawElementsBaseVertex(ctx->CurrentServerDispatch,
                                        (mode, count, type, indices, draw_count,
-- 
GitLab


From 25c3e2bdc30b1d92a795cfa52540c154923c521f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 18 Dec 2022 17:45:01 -0500
Subject: [PATCH 06/20] glthread: don't bind/unbind uploaded indexbuf, pass it
 to glDraw directly

DrawElementsUserBuf is changed to mean the same thing as
glDrawElementsInstancedBaseVertexBaseInstance, but "gl_buffer_object *
index_buffer" is passed via a parameter instead of using the bound
GL_ELEMENT_ARRAY_BUFFER.

This skips binding and unbinding the index buffer around every draw
where glthread uploads indices.
---
 src/mapi/glapi/gen/gl_API.xml |  8 +++++
 src/mesa/main/draw.c          | 58 +++++++++++++++++++++++++++++------
 src/mesa/main/glthread_draw.c | 28 ++++++-----------
 3 files changed, 67 insertions(+), 27 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 8ead49dbc3d0..6df84ada4d31 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -12944,6 +12944,14 @@
     </function>
 
     <function name="DrawElementsUserBuf" es1="1.0" es2="2.0" marshal="custom">
+        <param name="indexBuf" type="GLintptr"/> <!-- "struct gl_buffer_object *" really -->
+        <param name="mode" type="GLenum"/>
+        <param name="count" type="GLsizei"/>
+        <param name="type" type="GLenum"/>
+        <param name="indices" type="const GLvoid *"/>
+        <param name="instancecount" type="GLsizei"/>
+        <param name="basevertex" type="GLint"/>
+        <param name="baseinstance" type="GLuint"/>
     </function>
 
     <function name="MultiDrawArraysUserBuf" es1="1.0" es2="2.0" marshal="custom">
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 0fbf3063ed2d..30f16ad49a81 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1589,7 +1589,9 @@ dump_element_buffer(struct gl_context *ctx, GLenum type)
  * we've validated buffer bounds, etc.
  */
 static void
-_mesa_validated_drawrangeelements(struct gl_context *ctx, GLenum mode,
+_mesa_validated_drawrangeelements(struct gl_context *ctx,
+                                  struct gl_buffer_object *index_bo,
+                                  GLenum mode,
                                   bool index_bounds_valid,
                                   GLuint start, GLuint end,
                                   GLsizei count, GLenum type,
@@ -1611,7 +1613,6 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx, GLenum mode,
    struct pipe_draw_info info;
    struct pipe_draw_start_count_bias draw;
    unsigned index_size_shift = get_index_size_shift(type);
-   struct gl_buffer_object *index_bo = ctx->Array.VAO->IndexBufferObj;
 
    if (index_bo && !indices_aligned(index_size_shift, indices))
       return;
@@ -1785,7 +1786,8 @@ _mesa_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
       end = ~0;
    }
 
-   _mesa_validated_drawrangeelements(ctx, mode, index_bounds_valid, start, end,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, index_bounds_valid, start, end,
                                      count, type, indices, basevertex, 1, 0);
 }
 
@@ -1819,7 +1821,8 @@ _mesa_DrawElements(GLenum mode, GLsizei count, GLenum type,
        !_mesa_validate_DrawElements(ctx, mode, count, type))
       return;
 
-   _mesa_validated_drawrangeelements(ctx, mode, false, 0, ~0,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, false, 0, ~0,
                                      count, type, indices, 0, 1, 0);
 }
 
@@ -1841,7 +1844,8 @@ _mesa_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
        !_mesa_validate_DrawElements(ctx, mode, count, type))
       return;
 
-   _mesa_validated_drawrangeelements(ctx, mode, false, 0, ~0,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, false, 0, ~0,
                                      count, type, indices, basevertex, 1, 0);
 }
 
@@ -1864,7 +1868,8 @@ _mesa_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type,
                                              numInstances))
       return;
 
-   _mesa_validated_drawrangeelements(ctx, mode, false, 0, ~0,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, false, 0, ~0,
                                      count, type, indices, 0, numInstances, 0);
 }
 
@@ -1889,7 +1894,8 @@ _mesa_DrawElementsInstancedBaseVertex(GLenum mode, GLsizei count,
                                              numInstances))
       return;
 
-   _mesa_validated_drawrangeelements(ctx, mode, false, 0, ~0,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, false, 0, ~0,
                                      count, type, indices,
                                      basevertex, numInstances, 0);
 }
@@ -1916,7 +1922,8 @@ _mesa_DrawElementsInstancedBaseInstance(GLenum mode, GLsizei count,
                                              numInstances))
       return;
 
-   _mesa_validated_drawrangeelements(ctx, mode, false, 0, ~0,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, false, 0, ~0,
                                      count, type, indices, 0, numInstances,
                                      baseInstance);
 }
@@ -1945,7 +1952,40 @@ _mesa_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode,
                                              numInstances))
       return;
 
-   _mesa_validated_drawrangeelements(ctx, mode, false, 0, ~0,
+   _mesa_validated_drawrangeelements(ctx, ctx->Array.VAO->IndexBufferObj,
+                                     mode, false, 0, ~0,
+                                     count, type, indices, basevertex,
+                                     numInstances, baseInstance);
+}
+
+/**
+ * Same as glDrawElementsInstancedBaseVertexBaseInstance, but the index
+ * buffer is set by the indexBuf parameter instead of using the bound
+ * GL_ELEMENT_ARRAY_BUFFER if indexBuf != NULL.
+ */
+void GLAPIENTRY
+_mesa_DrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
+                          GLsizei count, GLenum type,
+                          const GLvoid *indices, GLsizei numInstances,
+                          GLint basevertex, GLuint baseInstance)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   FLUSH_FOR_DRAW(ctx);
+
+   if (ctx->NewState)
+      _mesa_update_state(ctx);
+
+   if (!_mesa_is_no_error_enabled(ctx) &&
+       !_mesa_validate_DrawElementsInstanced(ctx, mode, count, type,
+                                             numInstances))
+      return;
+
+   struct gl_buffer_object *index_bo =
+      indexBuf ? (struct gl_buffer_object*)indexBuf :
+                 ctx->Array.VAO->IndexBufferObj;
+
+   _mesa_validated_drawrangeelements(ctx, index_bo,
+                                     mode, false, 0, ~0,
                                      count, type, indices, basevertex,
                                      numInstances, baseInstance);
 }
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 33d57035417a..8bb2b456b57c 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -758,7 +758,6 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
                                     const struct marshal_cmd_DrawElementsUserBuf *cmd)
 {
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
-   struct gl_buffer_object *index_buffer = cmd->index_buffer;
    const struct glthread_attrib_binding *buffers =
       (const struct glthread_attrib_binding *)(cmd + 1);
 
@@ -767,9 +766,6 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
       _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
                                       false);
    }
-   if (index_buffer) {
-      _mesa_InternalBindElementBuffer(ctx, index_buffer);
-   }
 
    /* Draw. */
    const GLenum mode = cmd->mode;
@@ -779,16 +775,15 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    const GLsizei instance_count = cmd->instance_count;
    const GLint basevertex = cmd->basevertex;
    const GLuint baseinstance = cmd->baseinstance;
+   struct gl_buffer_object *index_buffer = cmd->index_buffer;
 
-   CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->CurrentServerDispatch,
-                                                    (mode, count, type, indices,
-                                                     instance_count, basevertex,
-                                                     baseinstance));
+   CALL_DrawElementsUserBuf(ctx->CurrentServerDispatch,
+                            ((GLintptr)index_buffer, mode, count, type,
+                             indices, instance_count, basevertex,
+                             baseinstance));
+   _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
 
    /* Restore states. */
-   if (index_buffer) {
-      _mesa_InternalBindElementBuffer(ctx, NULL);
-   }
    if (user_buffer_mask) {
       _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
                                       true);
@@ -1412,7 +1407,10 @@ _mesa_marshal_DrawArraysUserBuf(void)
 }
 
 void GLAPIENTRY
-_mesa_marshal_DrawElementsUserBuf(void)
+_mesa_marshal_DrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
+                                  GLsizei count, GLenum type,
+                                  const GLvoid *indices, GLsizei numInstances,
+                                  GLint basevertex, GLuint baseInstance)
 {
    unreachable("should never end up here");
 }
@@ -1435,12 +1433,6 @@ _mesa_DrawArraysUserBuf(void)
    unreachable("should never end up here");
 }
 
-void GLAPIENTRY
-_mesa_DrawElementsUserBuf(void)
-{
-   unreachable("should never end up here");
-}
-
 void GLAPIENTRY
 _mesa_MultiDrawArraysUserBuf(void)
 {
-- 
GitLab


From bbf1a837e08f8767c8ad71dcc12fece9ad6db5bd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 18 Dec 2022 17:45:01 -0500
Subject: [PATCH 07/20] glthread: don't bind/unbind uploaded indexbuf, pass it
 to glMultiDraw directly

MultiDrawElementsUserBuf is changed to mean the same thing as
glMultiDrawElementsBaseVertex, but "gl_buffer_object *index_buffer" is
passed via a parameter instead of using the bound GL_ELEMENT_ARRAY_BUFFER.

This skips binding and unbinding the index buffer around every draw
where glthread uploads indices.
---
 src/mapi/glapi/gen/gl_API.xml |  7 ++++
 src/mesa/main/bufferobj.c     | 13 --------
 src/mesa/main/bufferobj.h     |  4 ---
 src/mesa/main/draw.c          | 60 ++++++++++++++++++++++++++++-------
 src/mesa/main/glthread_draw.c | 50 ++++++++---------------------
 5 files changed, 69 insertions(+), 65 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 6df84ada4d31..79589af2df58 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -12958,6 +12958,13 @@
     </function>
 
     <function name="MultiDrawElementsUserBuf" es1="1.0" es2="2.0" marshal="custom">
+        <param name="indexBuf" type="GLintptr"/> <!-- "struct gl_buffer_object *" really -->
+        <param name="mode" type="GLenum"/>
+        <param name="count" type="const GLsizei *" count="primcount"/>
+        <param name="type" type="GLenum"/>
+        <param name="indices" type="const GLvoid * const *" count="(sizeof(GLvoid *) * primcount)"/>
+        <param name="primcount" type="GLsizei"/>
+        <param name="basevertex" type="const GLint *" count="primcount"/>
     </function>
 </category>
 
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index bdc8c10f7397..8c4f435bc00d 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -1562,19 +1562,6 @@ _mesa_BindBuffer(GLenum target, GLuint buffer)
    bind_buffer_object(ctx, bindTarget, buffer, false);
 }
 
-void
-_mesa_InternalBindElementBuffer(struct gl_context *ctx,
-                                struct gl_buffer_object *buf)
-{
-   struct gl_buffer_object **bindTarget =
-      get_buffer_target(ctx, GL_ELEMENT_ARRAY_BUFFER, false);
-
-   /* Move the buffer reference from the parameter to the bind point. */
-   _mesa_reference_buffer_object(ctx, bindTarget, NULL);
-   if (buf)
-      *bindTarget = buf;
-}
-
 /**
  * Binds a buffer object to a binding point.
  *
diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index 19b5367536cc..197636ee0185 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -258,8 +258,4 @@ _mesa_ClearBufferSubData_sw(struct gl_context *ctx,
                             GLsizeiptr clearValueSize,
                             struct gl_buffer_object *bufObj);
 
-void
-_mesa_InternalBindElementBuffer(struct gl_context *ctx,
-                                struct gl_buffer_object *buf);
-
 #endif
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 30f16ad49a81..28eeab8e9d4c 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -294,7 +294,8 @@ static GLboolean
 _mesa_validate_MultiDrawElements(struct gl_context *ctx,
                                  GLenum mode, const GLsizei *count,
                                  GLenum type, const GLvoid * const *indices,
-                                 GLsizei primcount)
+                                 GLsizei primcount,
+                                 struct gl_buffer_object *index_bo)
 {
    GLenum error;
 
@@ -336,7 +337,7 @@ _mesa_validate_MultiDrawElements(struct gl_context *ctx,
 
    /* Not using a VBO for indices, so avoid NULL pointer derefs later.
     */
-   if (!ctx->Array.VAO->IndexBufferObj) {
+   if (!index_bo) {
       for (int i = 0; i < primcount; i++) {
          if (!indices[i])
             return GL_FALSE;
@@ -1997,9 +1998,10 @@ _mesa_DrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
  * This does the actual rendering after we've checked array indexes, etc.
  */
 static void
-_mesa_validated_multidrawelements(struct gl_context *ctx, GLenum mode,
-                                  const GLsizei *count, GLenum type,
-                                  const GLvoid * const *indices,
+_mesa_validated_multidrawelements(struct gl_context *ctx,
+                                  struct gl_buffer_object *index_bo,
+                                  GLenum mode, const GLsizei *count,
+                                  GLenum type, const GLvoid * const *indices,
                                   GLsizei primcount, const GLint *basevertex)
 {
    uintptr_t min_index_ptr, max_index_ptr;
@@ -2035,7 +2037,6 @@ _mesa_validated_multidrawelements(struct gl_context *ctx, GLenum mode,
       }
    }
 
-   struct gl_buffer_object *index_bo = ctx->Array.VAO->IndexBufferObj;
    struct pipe_draw_info info;
 
    info.mode = mode;
@@ -2139,13 +2140,15 @@ _mesa_MultiDrawElements(GLenum mode, const GLsizei *count, GLenum type,
    if (ctx->NewState)
       _mesa_update_state(ctx);
 
+   struct gl_buffer_object *index_bo = ctx->Array.VAO->IndexBufferObj;
+
    if (!_mesa_is_no_error_enabled(ctx) &&
        !_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
-                                         primcount))
+                                         primcount, index_bo))
       return;
 
-   _mesa_validated_multidrawelements(ctx, mode, count, type, indices, primcount,
-                                     NULL);
+   _mesa_validated_multidrawelements(ctx, index_bo, mode, count, type,
+                                     indices, primcount, NULL);
 }
 
 
@@ -2162,13 +2165,46 @@ _mesa_MultiDrawElementsBaseVertex(GLenum mode,
    if (ctx->NewState)
       _mesa_update_state(ctx);
 
+   struct gl_buffer_object *index_bo = ctx->Array.VAO->IndexBufferObj;
+
+   if (!_mesa_is_no_error_enabled(ctx) &&
+       !_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
+                                         primcount, index_bo))
+      return;
+
+   _mesa_validated_multidrawelements(ctx, index_bo, mode, count, type,
+                                     indices, primcount, basevertex);
+}
+
+
+/**
+ * Same as glMultiDrawElementsBaseVertex, but the index buffer is set by
+ * the indexBuf parameter instead of using the bound GL_ELEMENT_ARRAY_BUFFER
+ * if indexBuf != NULL.
+ */
+void GLAPIENTRY
+_mesa_MultiDrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
+                               const GLsizei *count, GLenum type,
+                               const GLvoid * const * indices,
+                               GLsizei primcount, const GLint * basevertex)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   FLUSH_FOR_DRAW(ctx);
+
+   if (ctx->NewState)
+      _mesa_update_state(ctx);
+
+   struct gl_buffer_object *index_bo =
+      indexBuf ? (struct gl_buffer_object*)indexBuf :
+                 ctx->Array.VAO->IndexBufferObj;
+
    if (!_mesa_is_no_error_enabled(ctx) &&
        !_mesa_validate_MultiDrawElements(ctx, mode, count, type, indices,
-                                         primcount))
+                                         primcount, index_bo))
       return;
 
-   _mesa_validated_multidrawelements(ctx, mode, count, type, indices, primcount,
-                                     basevertex);
+   _mesa_validated_multidrawelements(ctx, index_bo, mode, count, type,
+                                     indices, primcount, basevertex);
 }
 
 
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 8bb2b456b57c..788345815001 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -951,7 +951,6 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
 {
    const GLsizei draw_count = cmd->draw_count;
    const GLuint user_buffer_mask = cmd->user_buffer_mask;
-   struct gl_buffer_object *index_buffer = cmd->index_buffer;
    const bool has_base_vertex = cmd->has_base_vertex;
 
    const char *variable_data = (const char *)(cmd + 1);
@@ -972,27 +971,18 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
       _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
                                       false);
    }
-   if (index_buffer) {
-      _mesa_InternalBindElementBuffer(ctx, index_buffer);
-   }
 
    /* Draw. */
    const GLenum mode = cmd->mode;
    const GLenum type = cmd->type;
+   struct gl_buffer_object *index_buffer = cmd->index_buffer;
 
-   if (has_base_vertex) {
-      CALL_MultiDrawElementsBaseVertex(ctx->CurrentServerDispatch,
-                                       (mode, count, type, indices, draw_count,
-                                        basevertex));
-   } else {
-      CALL_MultiDrawElements(ctx->CurrentServerDispatch,
-                             (mode, count, type, indices, draw_count));
-   }
+   CALL_MultiDrawElementsUserBuf(ctx->CurrentServerDispatch,
+                                 ((GLintptr)index_buffer, mode, count, type,
+                                  indices, draw_count, basevertex));
+   _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
 
    /* Restore states. */
-   if (index_buffer) {
-      _mesa_InternalBindElementBuffer(ctx, NULL);
-   }
    if (user_buffer_mask) {
       _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
                                       true);
@@ -1050,25 +1040,15 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
          _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
                                          false);
       }
-      if (index_buffer) {
-         _mesa_InternalBindElementBuffer(ctx, index_buffer);
-      }
 
       /* Draw. */
-      if (basevertex != NULL) {
-         CALL_MultiDrawElementsBaseVertex(ctx->CurrentServerDispatch,
-                                          (mode, count, type, indices, draw_count,
-                                           basevertex));
-      } else {
-         CALL_MultiDrawElements(ctx->CurrentServerDispatch,
-                                (mode, count, type, indices, draw_count));
-      }
+      CALL_MultiDrawElementsUserBuf(ctx->CurrentServerDispatch,
+                                    ((GLintptr)index_buffer, mode, count,
+                                     type, indices, draw_count, basevertex));
+      _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
 
       /* Restore states. */
       /* TODO: remove this after glthread takes over all uploading */
-      if (index_buffer) {
-         _mesa_InternalBindElementBuffer(ctx, NULL);
-      }
       if (user_buffer_mask) {
          _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
                                          true);
@@ -1422,7 +1402,11 @@ _mesa_marshal_MultiDrawArraysUserBuf(void)
 }
 
 void GLAPIENTRY
-_mesa_marshal_MultiDrawElementsUserBuf(void)
+_mesa_marshal_MultiDrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
+                                       const GLsizei *count, GLenum type,
+                                       const GLvoid * const *indices,
+                                       GLsizei primcount,
+                                       const GLint *basevertex)
 {
    unreachable("should never end up here");
 }
@@ -1438,9 +1422,3 @@ _mesa_MultiDrawArraysUserBuf(void)
 {
    unreachable("should never end up here");
 }
-
-void GLAPIENTRY
-_mesa_MultiDrawElementsUserBuf(void)
-{
-   unreachable("should never end up here");
-}
-- 
GitLab


From eec6b32e7092e755c63e98a84a330a6742861422 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 21 Dec 2022 01:51:49 -0500
Subject: [PATCH 08/20] glthread: track vertex formats for all attributes

We'll need this for a special vertex upload fallback.
---
 .../glapi/gen/ARB_direct_state_access.xml     |   6 +-
 .../glapi/gen/ARB_vertex_attrib_64bit.xml     |   4 +-
 .../glapi/gen/ARB_vertex_attrib_binding.xml   |  12 +-
 .../glapi/gen/EXT_direct_state_access.xml     |  24 ++--
 src/mapi/glapi/gen/GL3x.xml                   |   2 +-
 src/mapi/glapi/gen/es_EXT.xml                 |   2 +-
 src/mapi/glapi/gen/gl_API.xml                 |  30 ++---
 src/mesa/main/glthread.h                      |  25 +++-
 src/mesa/main/glthread_varray.c               | 122 +++++++++++-------
 9 files changed, 131 insertions(+), 96 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_direct_state_access.xml b/src/mapi/glapi/gen/ARB_direct_state_access.xml
index bb12eed7b9bb..49652f57e7c3 100644
--- a/src/mapi/glapi/gen/ARB_direct_state_access.xml
+++ b/src/mapi/glapi/gen/ARB_direct_state_access.xml
@@ -631,7 +631,7 @@
    </function>
 
    <function name="VertexArrayAttribFormat"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, size, type, relativeoffset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, MESA_PACK_VFORMAT(type, size, normalized, 0, 0), relativeoffset);">
       <param name="vaobj" type="GLuint" />
       <param name="attribindex" type="GLuint" />
       <param name="size" type="GLint" />
@@ -641,7 +641,7 @@
    </function>
 
    <function name="VertexArrayAttribIFormat"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, size, type, relativeoffset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, MESA_PACK_VFORMAT(type, size, 0, 1, 0), relativeoffset);">
       <param name="vaobj" type="GLuint" />
       <param name="attribindex" type="GLuint" />
       <param name="size" type="GLint" />
@@ -650,7 +650,7 @@
    </function>
 
    <function name="VertexArrayAttribLFormat"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, size, type, relativeoffset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, MESA_PACK_VFORMAT(type, size, 0, 0, 1), relativeoffset);">
       <param name="vaobj" type="GLuint" />
       <param name="attribindex" type="GLuint" />
       <param name="size" type="GLint" />
diff --git a/src/mapi/glapi/gen/ARB_vertex_attrib_64bit.xml b/src/mapi/glapi/gen/ARB_vertex_attrib_64bit.xml
index c9b75c5f03c5..bb287081cfda 100644
--- a/src/mapi/glapi/gen/ARB_vertex_attrib_64bit.xml
+++ b/src/mapi/glapi/gen/ARB_vertex_attrib_64bit.xml
@@ -52,7 +52,7 @@
     </function>
 
     <function name="VertexAttribLPointer" no_error="true" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_GENERIC(index), size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_GENERIC(index), MESA_PACK_VFORMAT(type, size, 0, 0, 1), stride, pointer);">
         <param name="index" type="GLuint"/>
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
@@ -67,7 +67,7 @@
     </function>
 
     <function name="VertexArrayVertexAttribLOffsetEXT"
-              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_GENERIC(index), size, type, stride, offset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_GENERIC(index), MESA_PACK_VFORMAT(type, size, 0, 0, 1), stride, offset);">
         <param name="vaobj" type="GLuint" />
         <param name="buffer" type="GLuint" />
         <param name="index" type="GLuint" />
diff --git a/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml b/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml
index 056cc3454301..a29e29580634 100644
--- a/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml
+++ b/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml
@@ -16,7 +16,7 @@
     </function>
 
     <function name="VertexAttribFormat" es2="3.1"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribFormat(ctx, attribindex, size, type, relativeoffset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribFormat(ctx, attribindex, MESA_PACK_VFORMAT(type, size, normalized, 0, 0), relativeoffset);">
         <param name="attribindex" type="GLuint"/>
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
@@ -25,7 +25,7 @@
     </function>
 
     <function name="VertexAttribIFormat" es2="3.1"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribFormat(ctx, attribindex, size, type, relativeoffset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribFormat(ctx, attribindex, MESA_PACK_VFORMAT(type, size, 0, 1, 0), relativeoffset);">
         <param name="attribindex" type="GLuint"/>
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
@@ -33,7 +33,7 @@
     </function>
 
     <function name="VertexAttribLFormat"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribFormat(ctx, attribindex, size, type, relativeoffset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribFormat(ctx, attribindex, MESA_PACK_VFORMAT(type, size, 0, 0, 1), relativeoffset);">
         <param name="attribindex" type="GLuint"/>
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
@@ -62,7 +62,7 @@
     </function>
 
     <function name="VertexArrayVertexAttribFormatEXT"
-              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, size, type, relativeoffset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, MESA_PACK_VFORMAT(type, size, normalized, 0, 0), relativeoffset);">
         <param name="vaobj" type="GLuint"/>
         <param name="attribindex" type="GLuint"/>
         <param name="size" type="GLint"/>
@@ -72,7 +72,7 @@
     </function>
 
     <function name="VertexArrayVertexAttribIFormatEXT"
-              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, size, type, relativeoffset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, MESA_PACK_VFORMAT(type, size, 0, 1, 0), relativeoffset);">
         <param name="vaobj" type="GLuint"/>
         <param name="attribindex" type="GLuint"/>
         <param name="size" type="GLint"/>
@@ -81,7 +81,7 @@
     </function>
 
     <function name="VertexArrayVertexAttribLFormatEXT"
-              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, size, type, relativeoffset);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribFormat(ctx, vaobj, attribindex, MESA_PACK_VFORMAT(type, size, 0, 0, 1), relativeoffset);">
         <param name="vaobj" type="GLuint"/>
         <param name="attribindex" type="GLuint"/>
         <param name="size" type="GLint"/>
diff --git a/src/mapi/glapi/gen/EXT_direct_state_access.xml b/src/mapi/glapi/gen/EXT_direct_state_access.xml
index a450846c215f..620a09b96132 100644
--- a/src/mapi/glapi/gen/EXT_direct_state_access.xml
+++ b/src/mapi/glapi/gen/EXT_direct_state_access.xml
@@ -676,7 +676,7 @@
    </function>
 
    <function name="MultiTexCoordPointerEXT" marshal="async"
-             marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_TEX(texunit - GL_TEXTURE0), size, type, stride,  pointer);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_TEX(texunit - GL_TEXTURE0), MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride,  pointer);">
       <param name="texunit" type="GLenum" />
       <param name="size" type="GLint" />
       <param name="type" type="GLenum" />
@@ -1088,7 +1088,7 @@
    </function>
 
    <function name="VertexArrayVertexOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_POS, size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_POS, MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="size" type="GLint" />
@@ -1098,7 +1098,7 @@
    </function>
 
    <function name="VertexArrayColorOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_COLOR0, size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_COLOR0, MESA_PACK_VFORMAT(type, size, 1, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="size" type="GLint" />
@@ -1108,7 +1108,7 @@
    </function>
 
    <function name="VertexArrayEdgeFlagOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_EDGEFLAG, 1, GL_UNSIGNED_BYTE, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_EDGEFLAG, MESA_PACK_VFORMAT(GL_UNSIGNED_BYTE, 1, 0, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="stride" type="GLsizei" />
@@ -1116,7 +1116,7 @@
    </function>
 
    <function name="VertexArrayIndexOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_COLOR_INDEX, 1, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_COLOR_INDEX, MESA_PACK_VFORMAT(type, 1, 0, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="type" type="GLenum" />
@@ -1125,7 +1125,7 @@
    </function>
 
    <function name="VertexArrayNormalOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_NORMAL, 3, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_NORMAL, MESA_PACK_VFORMAT(type, 3, 1, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="type" type="GLenum" />
@@ -1134,7 +1134,7 @@
    </function>
 
    <function name="VertexArrayTexCoordOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_TEX(ctx->GLThread.ClientActiveTexture), size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_TEX(ctx->GLThread.ClientActiveTexture), MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="size" type="GLint" />
@@ -1144,7 +1144,7 @@
    </function>
 
    <function name="VertexArrayMultiTexCoordOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_TEX(texunit - GL_TEXTURE0), size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_TEX(texunit - GL_TEXTURE0), MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="texunit" type="GLenum" />
@@ -1155,7 +1155,7 @@
    </function>
 
    <function name="VertexArrayFogCoordOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_FOG, 1, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_FOG, MESA_PACK_VFORMAT(type, 1, 0, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="type" type="GLenum" />
@@ -1164,7 +1164,7 @@
    </function>
 
    <function name="VertexArraySecondaryColorOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_COLOR1, size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_COLOR1, MESA_PACK_VFORMAT(type, size, 1, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="size" type="GLint" />
@@ -1174,7 +1174,7 @@
    </function>
 
    <function name="VertexArrayVertexAttribOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_GENERIC(index), size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_GENERIC(index), MESA_PACK_VFORMAT(type, size, normalized, 0, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="index" type="GLuint" />
@@ -1186,7 +1186,7 @@
    </function>
 
    <function name="VertexArrayVertexAttribIOffsetEXT"
-             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_GENERIC(index), size, type, stride, offset);">
+             marshal_call_after="if (COMPAT) _mesa_glthread_DSAAttribPointer(ctx, vaobj, buffer, VERT_ATTRIB_GENERIC(index), MESA_PACK_VFORMAT(type, size, 0, 1, 0), stride, offset);">
       <param name="vaobj" type="GLuint" />
       <param name="buffer" type="GLuint" />
       <param name="index" type="GLuint" />
diff --git a/src/mapi/glapi/gen/GL3x.xml b/src/mapi/glapi/gen/GL3x.xml
index e6c639bf4d32..8aae7f85a120 100644
--- a/src/mapi/glapi/gen/GL3x.xml
+++ b/src/mapi/glapi/gen/GL3x.xml
@@ -258,7 +258,7 @@
 
   <function name="VertexAttribIPointer" es2="3.0" marshal="async"
             no_error="true"
-            marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_GENERIC(index), size, type, stride, pointer);">
+            marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_GENERIC(index), MESA_PACK_VFORMAT(type, size, 0, 1, 0), stride, pointer);">
     <param name="index" type="GLuint"/>
     <param name="size" type="GLint"/>
     <param name="type" type="GLenum"/>
diff --git a/src/mapi/glapi/gen/es_EXT.xml b/src/mapi/glapi/gen/es_EXT.xml
index e96f5b83f716..5b02dc847db2 100644
--- a/src/mapi/glapi/gen/es_EXT.xml
+++ b/src/mapi/glapi/gen/es_EXT.xml
@@ -320,7 +320,7 @@
 
     <function name="PointSizePointerOES" es1="1.0" desktop="false"
               no_error="true" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POINT_SIZE, 1, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POINT_SIZE, MESA_PACK_VFORMAT(type, 1, 0, 0, 0), stride, pointer);">
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
         <param name="pointer" type="const GLvoid *"/>
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 79589af2df58..7a02da387967 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -3196,7 +3196,7 @@
 
     <function name="ColorPointer" es1="1.0" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR0, size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR0, MESA_PACK_VFORMAT(type, size, 1, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
@@ -3227,7 +3227,7 @@
 
     <function name="EdgeFlagPointer" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_EDGEFLAG, 1, GL_UNSIGNED_BYTE, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_EDGEFLAG, MESA_PACK_VFORMAT(GL_UNSIGNED_BYTE, 1, 0, 0, 0), stride, pointer);">
         <param name="stride" type="GLsizei"/>
         <param name="pointer" type="const GLvoid *"/>
         <glx handcode="true"/>
@@ -3247,7 +3247,7 @@
 
     <function name="IndexPointer" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR_INDEX, 1, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR_INDEX, MESA_PACK_VFORMAT(type, 1, 0, 0, 0), stride, pointer);">
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
         <param name="pointer" type="const GLvoid *"/>
@@ -3264,7 +3264,7 @@
 
     <function name="NormalPointer" es1="1.0" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL, 3, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL, MESA_PACK_VFORMAT(type, 3, 1, 0, 0), stride, pointer);">
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
         <param name="pointer" type="const GLvoid *"/>
@@ -3273,7 +3273,7 @@
 
     <function name="TexCoordPointer" es1="1.0" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_TEX(ctx->GLThread.ClientActiveTexture), size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_TEX(ctx->GLThread.ClientActiveTexture), MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
@@ -3283,7 +3283,7 @@
 
     <function name="VertexPointer" es1="1.0" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS, size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS, MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
@@ -4789,7 +4789,7 @@
 
     <function name="FogCoordPointer" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_FOG, 1, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_FOG, MESA_PACK_VFORMAT(type, 1, 0, 0, 0), stride, pointer);">
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
         <param name="pointer" type="const GLvoid *"/>
@@ -4929,7 +4929,7 @@
 
     <function name="SecondaryColorPointer" deprecated="3.1" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR1, size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR1, MESA_PACK_VFORMAT(type, size, 1, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
@@ -5892,7 +5892,7 @@
 
     <function name="VertexAttribPointer" es2="2.0" marshal="async"
               no_error="true"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_GENERIC(index), size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_GENERIC(index), MESA_PACK_VFORMAT(type, size, normalized, 0, 0), stride, pointer);">
         <param name="index" type="GLuint"/>
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
@@ -8898,7 +8898,7 @@
     </function>
 
     <function name="ColorPointerEXT" deprecated="3.1" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR0, size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR0, MESA_PACK_VFORMAT(type, size, 1, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
@@ -8914,7 +8914,7 @@
     </function>
 
     <function name="EdgeFlagPointerEXT" deprecated="3.1" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_EDGEFLAG, 1, GL_UNSIGNED_BYTE, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_EDGEFLAG, MESA_PACK_VFORMAT(GL_UNSIGNED_BYTE, 1, 0, 0, 0), stride, pointer);">
         <param name="stride" type="GLsizei"/>
         <param name="count" type="GLsizei"/>
         <param name="pointer" type="const GLboolean *"/>
@@ -8927,7 +8927,7 @@
     </function>
 
     <function name="IndexPointerEXT" deprecated="3.1" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR_INDEX, 1, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR_INDEX, MESA_PACK_VFORMAT(type, 1, 0, 0, 0), stride, pointer);">
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
         <param name="count" type="GLsizei"/>
@@ -8936,7 +8936,7 @@
     </function>
 
     <function name="NormalPointerEXT" deprecated="3.1" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL, 3, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL, MESA_PACK_VFORMAT(type, 3, 1, 0, 0), stride, pointer);">
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
         <param name="count" type="GLsizei"/>
@@ -8945,7 +8945,7 @@
     </function>
 
     <function name="TexCoordPointerEXT" deprecated="3.1" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_TEX(ctx->GLThread.ClientActiveTexture), size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_TEX(ctx->GLThread.ClientActiveTexture), MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
@@ -8955,7 +8955,7 @@
     </function>
 
     <function name="VertexPointerEXT" deprecated="3.1" marshal="async"
-              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS, size, type, stride, pointer);">
+              marshal_call_after="if (COMPAT) _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS, MESA_PACK_VFORMAT(type, size, 0, 0, 0), stride, pointer);">
         <param name="size" type="GLint"/>
         <param name="type" type="GLenum"/>
         <param name="stride" type="GLsizei"/>
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index d752ca9ef7a3..4713b6448f8d 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -75,6 +75,16 @@ union gl_vertex_format_user {
    uint32_t All;
 };
 
+#define MESA_PACK_VFORMAT(type, size, normalized, integer, doubles) \
+   (union gl_vertex_format_user){{ \
+      .Type = MIN2(type, 0xffff), /* 0xffff means invalid value */ \
+      .Bgra = size == GL_BGRA, \
+      .Size = size == GL_BGRA ? 4 : MIN2(size, 5), /* 5 means invalid value */ \
+      .Normalized = normalized, \
+      .Integer = integer, \
+      .Doubles = doubles \
+   }}
+
 struct glthread_attrib_binding {
    struct gl_buffer_object *buffer; /**< where non-VBO data was uploaded */
    int offset;                      /**< offset to uploaded non-VBO data */
@@ -86,6 +96,7 @@ struct glthread_attrib {
    uint8_t ElementSize;       /**< max 32 */
    uint8_t BufferIndex;       /**< Referring to Attrib[BufferIndex]. */
    uint16_t RelativeOffset;   /**< max 0xffff in Mesa */
+   union gl_vertex_format_user Format;
 
    /* Per buffer binding: */
    GLuint Divisor;
@@ -313,16 +324,18 @@ void _mesa_glthread_ClientState(struct gl_context *ctx, GLuint *vaobj,
 void _mesa_glthread_AttribDivisor(struct gl_context *ctx, const GLuint *vaobj,
                                   gl_vert_attrib attrib, GLuint divisor);
 void _mesa_glthread_AttribPointer(struct gl_context *ctx, gl_vert_attrib attrib,
-                                  GLint size, GLenum type, GLsizei stride,
-                                  const void *pointer);
+                                  union gl_vertex_format_user format,
+                                  GLsizei stride, const void *pointer);
 void _mesa_glthread_DSAAttribPointer(struct gl_context *ctx, GLuint vao,
                                      GLuint buffer, gl_vert_attrib attrib,
-                                     GLint size, GLenum type, GLsizei stride,
-                                     GLintptr offset);
+                                     union gl_vertex_format_user format,
+                                     GLsizei stride, GLintptr offset);
 void _mesa_glthread_AttribFormat(struct gl_context *ctx, GLuint attribindex,
-                                 GLint size, GLenum type,  GLuint relativeoffset);
+                                 union gl_vertex_format_user format,
+                                 GLuint relativeoffset);
 void _mesa_glthread_DSAAttribFormat(struct gl_context *ctx, GLuint vaobj,
-                                    GLuint attribindex, GLint size, GLenum type,
+                                    GLuint attribindex,
+                                    union gl_vertex_format_user format,
                                     GLuint relativeoffset);
 void _mesa_glthread_VertexBuffer(struct gl_context *ctx, GLuint bindingindex,
                                  GLuint buffer, GLintptr offset, GLsizei stride);
diff --git a/src/mesa/main/glthread_varray.c b/src/mesa/main/glthread_varray.c
index f4f2bde2158f..a22db6baf44b 100644
--- a/src/mesa/main/glthread_varray.c
+++ b/src/mesa/main/glthread_varray.c
@@ -33,19 +33,28 @@
 #include "main/dispatch.h"
 #include "main/varray.h"
 
+static unsigned
+element_size(union gl_vertex_format_user format)
+{
+   return _mesa_bytes_per_vertex_attrib(format.Size, format.Type);
+}
+
+static void
+init_attrib(struct glthread_attrib *attrib, int index, int size, GLenum type)
+{
+   attrib->Format = MESA_PACK_VFORMAT(type, size, 0, 0, 0);
+   attrib->ElementSize = element_size(attrib->Format);
+   attrib->RelativeOffset = 0;
+   attrib->BufferIndex = index;
+   attrib->Stride = attrib->ElementSize;
+   attrib->Divisor = 0;
+   attrib->EnabledAttribCount = 0;
+   attrib->Pointer = NULL;
+}
 
 void
 _mesa_glthread_reset_vao(struct glthread_vao *vao)
 {
-   static unsigned default_elem_size[VERT_ATTRIB_MAX] = {
-      [VERT_ATTRIB_NORMAL] = 12,
-      [VERT_ATTRIB_COLOR1] = 12,
-      [VERT_ATTRIB_FOG] = 4,
-      [VERT_ATTRIB_COLOR_INDEX] = 4,
-      [VERT_ATTRIB_EDGEFLAG] = 1,
-      [VERT_ATTRIB_POINT_SIZE] = 4,
-   };
-
    vao->CurrentElementBufferName = 0;
    vao->UserEnabled = 0;
    vao->Enabled = 0;
@@ -54,17 +63,29 @@ _mesa_glthread_reset_vao(struct glthread_vao *vao)
    vao->NonZeroDivisorMask = 0;
 
    for (unsigned i = 0; i < ARRAY_SIZE(vao->Attrib); i++) {
-      unsigned elem_size = default_elem_size[i];
-      if (!elem_size)
-         elem_size = 16;
-
-      vao->Attrib[i].ElementSize = elem_size;
-      vao->Attrib[i].RelativeOffset = 0;
-      vao->Attrib[i].BufferIndex = i;
-      vao->Attrib[i].Stride = elem_size;
-      vao->Attrib[i].Divisor = 0;
-      vao->Attrib[i].EnabledAttribCount = 0;
-      vao->Attrib[i].Pointer = NULL;
+      switch (i) {
+      case VERT_ATTRIB_NORMAL:
+         init_attrib(&vao->Attrib[i], i, 3, GL_FLOAT);
+         break;
+      case VERT_ATTRIB_COLOR1:
+         init_attrib(&vao->Attrib[i], i, 3, GL_FLOAT);
+         break;
+      case VERT_ATTRIB_FOG:
+         init_attrib(&vao->Attrib[i], i, 1, GL_FLOAT);
+         break;
+      case VERT_ATTRIB_COLOR_INDEX:
+         init_attrib(&vao->Attrib[i], i, 1, GL_FLOAT);
+         break;
+      case VERT_ATTRIB_EDGEFLAG:
+         init_attrib(&vao->Attrib[i], i, 1, GL_UNSIGNED_BYTE);
+         break;
+      case VERT_ATTRIB_POINT_SIZE:
+         init_attrib(&vao->Attrib[i], i, 1, GL_FLOAT);
+         break;
+      default:
+         init_attrib(&vao->Attrib[i], i, 4, GL_FLOAT);
+         break;
+      }
    }
 }
 
@@ -332,26 +353,18 @@ void _mesa_glthread_AttribDivisor(struct gl_context *ctx, const GLuint *vaobj,
       vao->NonZeroDivisorMask &= ~(1u << attrib);
 }
 
-static unsigned
-element_size(GLint size, GLenum type)
-{
-   if (size == GL_BGRA)
-      size = 4;
-
-   return _mesa_bytes_per_vertex_attrib(size, type);
-}
-
 static void
 attrib_pointer(struct glthread_state *glthread, struct glthread_vao *vao,
                GLuint buffer, gl_vert_attrib attrib,
-               GLint size, GLenum type, GLsizei stride,
+               union gl_vertex_format_user format, GLsizei stride,
                const void *pointer)
 {
    if (attrib >= VERT_ATTRIB_MAX)
       return;
 
-   unsigned elem_size = element_size(size, type);
+   unsigned elem_size = element_size(format);
 
+   vao->Attrib[attrib].Format = format;
    vao->Attrib[attrib].ElementSize = elem_size;
    vao->Attrib[attrib].Stride = stride ? stride : elem_size;
    vao->Attrib[attrib].Pointer = pointer;
@@ -367,21 +380,21 @@ attrib_pointer(struct glthread_state *glthread, struct glthread_vao *vao,
 
 void
 _mesa_glthread_AttribPointer(struct gl_context *ctx, gl_vert_attrib attrib,
-                             GLint size, GLenum type, GLsizei stride,
-                             const void *pointer)
+                             union gl_vertex_format_user format,
+                             GLsizei stride, const void *pointer)
 {
    struct glthread_state *glthread = &ctx->GLThread;
 
    attrib_pointer(glthread, glthread->CurrentVAO,
                   glthread->CurrentArrayBufferName,
-                  attrib, size, type, stride, pointer);
+                  attrib, format, stride, pointer);
 }
 
 void
 _mesa_glthread_DSAAttribPointer(struct gl_context *ctx, GLuint vaobj,
                                 GLuint buffer, gl_vert_attrib attrib,
-                                GLint size, GLenum type, GLsizei stride,
-                                GLintptr offset)
+                                union gl_vertex_format_user format,
+                                GLsizei stride, GLintptr offset)
 {
    struct glthread_state *glthread = &ctx->GLThread;
    struct glthread_vao *vao;
@@ -390,45 +403,48 @@ _mesa_glthread_DSAAttribPointer(struct gl_context *ctx, GLuint vaobj,
    if (!vao)
       return;
 
-   attrib_pointer(glthread, vao, buffer, attrib, size, type, stride,
+   attrib_pointer(glthread, vao, buffer, attrib, format, stride,
                   (const void*)offset);
 }
 
 static void
 attrib_format(struct glthread_state *glthread, struct glthread_vao *vao,
-              GLuint attribindex, GLint size, GLenum type,
+              GLuint attribindex, union gl_vertex_format_user format,
               GLuint relativeoffset)
 {
    if (attribindex >= VERT_ATTRIB_GENERIC_MAX)
       return;
 
-   unsigned elem_size = element_size(size, type);
+   unsigned elem_size = element_size(format);
 
    unsigned i = VERT_ATTRIB_GENERIC(attribindex);
+   vao->Attrib[i].Format = format;
    vao->Attrib[i].ElementSize = elem_size;
    vao->Attrib[i].RelativeOffset = relativeoffset;
 }
 
 void
 _mesa_glthread_AttribFormat(struct gl_context *ctx, GLuint attribindex,
-                            GLint size, GLenum type, GLuint relativeoffset)
+                            union gl_vertex_format_user format,
+                            GLuint relativeoffset)
 {
    struct glthread_state *glthread = &ctx->GLThread;
 
-   attrib_format(glthread, glthread->CurrentVAO, attribindex, size, type,
+   attrib_format(glthread, glthread->CurrentVAO, attribindex, format,
                  relativeoffset);
 }
 
 void
 _mesa_glthread_DSAAttribFormat(struct gl_context *ctx, GLuint vaobj,
-                               GLuint attribindex, GLint size, GLenum type,
+                               GLuint attribindex,
+                               union gl_vertex_format_user format,
                                GLuint relativeoffset)
 {
    struct glthread_state *glthread = &ctx->GLThread;
    struct glthread_vao *vao = lookup_vao(ctx, vaobj);
 
    if (vao)
-      attrib_format(glthread, vao, attribindex, size, type, relativeoffset);
+      attrib_format(glthread, vao, attribindex, format, relativeoffset);
 }
 
 static void
@@ -676,8 +692,10 @@ _mesa_glthread_InterleavedArrays(struct gl_context *ctx, GLenum format,
    /* Texcoords */
    if (layout.tflag) {
       _mesa_glthread_ClientState(ctx, NULL, tex, true);
-      _mesa_glthread_AttribPointer(ctx, tex, layout.tcomps, GL_FLOAT, stride,
-                                   (GLubyte *) pointer + layout.toffset);
+      _mesa_glthread_AttribPointer(ctx, tex,
+                                   MESA_PACK_VFORMAT(GL_FLOAT, layout.tcomps,
+                                                     0, 0, 0),
+                                   stride, (GLubyte *)pointer + layout.toffset);
    } else {
       _mesa_glthread_ClientState(ctx, NULL, tex, false);
    }
@@ -685,9 +703,10 @@ _mesa_glthread_InterleavedArrays(struct gl_context *ctx, GLenum format,
    /* Color */
    if (layout.cflag) {
       _mesa_glthread_ClientState(ctx, NULL, VERT_ATTRIB_COLOR0, true);
-      _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR0, layout.ccomps,
-                                   layout.ctype, stride,
-                                   (GLubyte *) pointer + layout.coffset);
+      _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_COLOR0,
+                                   MESA_PACK_VFORMAT(layout.ctype, layout.ccomps,
+                                                     1, 0, 0),
+                                   stride, (GLubyte *)pointer + layout.coffset);
    } else {
       _mesa_glthread_ClientState(ctx, NULL, VERT_ATTRIB_COLOR0, false);
    }
@@ -695,7 +714,8 @@ _mesa_glthread_InterleavedArrays(struct gl_context *ctx, GLenum format,
    /* Normals */
    if (layout.nflag) {
       _mesa_glthread_ClientState(ctx, NULL, VERT_ATTRIB_NORMAL, true);
-      _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL, 3, GL_FLOAT,
+      _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_NORMAL,
+                                   MESA_PACK_VFORMAT(GL_FLOAT, 3, 1, 0, 0),
                                    stride, (GLubyte *) pointer + layout.noffset);
    } else {
       _mesa_glthread_ClientState(ctx, NULL, VERT_ATTRIB_NORMAL, false);
@@ -703,6 +723,8 @@ _mesa_glthread_InterleavedArrays(struct gl_context *ctx, GLenum format,
 
    /* Vertices */
    _mesa_glthread_ClientState(ctx, NULL, VERT_ATTRIB_POS, true);
-   _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS, layout.vcomps, GL_FLOAT,
+   _mesa_glthread_AttribPointer(ctx, VERT_ATTRIB_POS,
+                                MESA_PACK_VFORMAT(GL_FLOAT, layout.vcomps,
+                                                  0, 0, 0),
                                 stride, (GLubyte *) pointer + layout.voffset);
 }
-- 
GitLab


From c6d08b738a451b111af7a984bdcf564ffa741f35 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 21 Dec 2022 02:42:57 -0500
Subject: [PATCH 09/20] glthread: add a vertex upload path that unrolls indices
 for glDrawElements

u_vbuf does this too. This is the last big missing piece to stop using
u_vbuf.

If the vertex range to upload is much larger than the draw vertex count and
if all attribs are not in VBOs, convert glDrawElements to glBegin/End.

This is a path that makes the Cogs game go from 1 FPS to ~197 FPS. There is
no change in FPS because u_vbuf does this, but it will be disabled.
---
 src/mesa/main/glthread.h             |   3 +
 src/mesa/main/glthread_draw.c        |  35 +-
 src/mesa/main/glthread_draw_unroll.c | 949 +++++++++++++++++++++++++++
 src/mesa/meson.build                 |   1 +
 4 files changed, 984 insertions(+), 4 deletions(-)
 create mode 100644 src/mesa/main/glthread_draw_unroll.c

diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index 4713b6448f8d..87f1e39a6a51 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -364,6 +364,9 @@ void _mesa_glthread_ClientAttribDefault(struct gl_context *ctx, GLbitfield mask)
 void _mesa_glthread_InterleavedArrays(struct gl_context *ctx, GLenum format,
                                       GLsizei stride, const GLvoid *pointer);
 void _mesa_glthread_ProgramChanged(struct gl_context *ctx);
+void _mesa_glthread_UnrollDrawElements(struct gl_context *ctx,
+                                       GLenum mode, GLsizei count, GLenum type,
+                                       const GLvoid *indices, GLint basevertex);
 
 #ifdef __cplusplus
 }
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 788345815001..4a3ea5dbadac 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -819,6 +819,23 @@ draw_elements_async_user(struct gl_context *ctx, GLenum mode, GLsizei count,
       memcpy(cmd + 1, buffers, buffers_size);
 }
 
+static inline bool
+should_convert_to_begin_end(struct gl_context *ctx, unsigned count,
+                            unsigned num_upload_vertices,
+                            unsigned instance_count, struct glthread_vao *vao)
+{
+   /* Some of these are limitations of _mesa_glthread_UnrollDrawElements.
+    * Others prevent syncing, such as disallowing buffer objects because we
+    * can't map them without syncing.
+    */
+   return util_is_vbo_upload_ratio_too_large(count, num_upload_vertices) &&
+          instance_count == 1 &&                /* no instancing */
+          vao->CurrentElementBufferName == 0 && /* only user indices */
+          !ctx->GLThread._PrimitiveRestart &&   /* no primitive restart */
+          vao->UserPointerMask == vao->BufferEnabled && /* no VBOs */
+          !(vao->NonZeroDivisorMask & vao->BufferEnabled); /* no instanced attribs */
+}
+
 static void
 draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
               GLsizei instance_count, GLint basevertex, GLuint baseinstance,
@@ -882,10 +899,20 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    unsigned start_vertex = min_index + basevertex;
    unsigned num_vertices = max_index + 1 - min_index;
 
-   /* If there is too much data to upload, sync and let the driver unroll
-    * indices. */
-   if (util_is_vbo_upload_ratio_too_large(count, num_vertices))
-      goto sync;
+   /* If the vertex range to upload is much greater than the vertex count (e.g.
+    * only 3 vertices with indices 0, 1, 999999), uploading the whole range
+    * would take too much time. If all buffers are user buffers, have glthread
+    * fetch all indices and vertices and convert the draw into glBegin/glEnd.
+    * For such pathological cases, it's the fastest way.
+    *
+    * The game Cogs benefits from this - its FPS increases from 0 to 197.
+    */
+   if (should_convert_to_begin_end(ctx, count, num_vertices, instance_count,
+                                   vao)) {
+      _mesa_glthread_UnrollDrawElements(ctx, mode, count, type, indices,
+                                        basevertex);
+      return;
+   }
 
    struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
    if (user_buffer_mask) {
diff --git a/src/mesa/main/glthread_draw_unroll.c b/src/mesa/main/glthread_draw_unroll.c
new file mode 100644
index 000000000000..f57505fa2669
--- /dev/null
+++ b/src/mesa/main/glthread_draw_unroll.c
@@ -0,0 +1,949 @@
+/*
+ * Mesa 3-D graphics library
+ *
+ * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
+ * Copyright (C) 2022 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* This lowers glDrawElementsBaseVertex into glBegin/glEnd draws.
+ *
+ * It's used by glthread when uploading non-VBO vertex arrays would take too
+ * much time due to small numbers of vertices per draw where indices have very
+ * large differences. (e.g. indices {0, 1000000} normally cause us to upload
+ * (1000000 * stride) bytes to draw 2 vertices) This helps performance for
+ * such pathological cases.
+ */
+
+#include "context.h"
+#include "marshal_generated.h"
+#include "vbo/vbo_util.h"
+#include "util/half_float.h"
+
+#define FIXED_TO_FLOAT(x) \
+   (int32_t)(CLAMP((x), -65536.0f, 65535.0f) * (double)0x10000)
+
+#define UNPACK_RGB10A2_USCALED(x) { \
+   (x) & 0x3ff, \
+   ((x) >> 10) & 0x3ff, \
+   ((x) >> 20) & 0x3ff, \
+   ((x) >> 30) & 0x3 \
+}
+
+#define UNPACK_RGB10A2_SSCALED(x) { \
+   conv_i10_to_i((x) & 0x3ff),         \
+   conv_i10_to_i(((x) >> 10) & 0x3ff), \
+   conv_i10_to_i(((x) >> 20) & 0x3ff), \
+   conv_i2_to_i(((x) >> 30) & 0x3) \
+}
+
+#define UNPACK_RGB10A2_UNORM(x) { \
+   conv_ui10_to_norm_float((x) & 0x3ff), \
+   conv_ui10_to_norm_float(((x) >> 10) & 0x3ff), \
+   conv_ui10_to_norm_float(((x) >> 20) & 0x3ff), \
+   conv_ui2_to_norm_float(((x) >> 30) & 0x3) \
+}
+
+#define UNPACK_RGB10A2_SNORM(x) { \
+   conv_i10_to_norm_float(ctx, (x) & 0x3ff), \
+   conv_i10_to_norm_float(ctx, ((x) >> 10) & 0x3ff), \
+   conv_i10_to_norm_float(ctx, ((x) >> 20) & 0x3ff), \
+   conv_i2_to_norm_float(ctx, ((x) >> 30) & 0x3) \
+}
+
+#define UNPACK_BGR10A2_USCALED(x) { \
+   ((x) >> 20) & 0x3ff, \
+   ((x) >> 10) & 0x3ff, \
+   (x) & 0x3ff, \
+   ((x) >> 30) & 0x3 \
+}
+
+#define UNPACK_BGR10A2_SSCALED(x) { \
+   conv_i10_to_i(((x) >> 20) & 0x3ff), \
+   conv_i10_to_i(((x) >> 10) & 0x3ff), \
+   conv_i10_to_i((x) & 0x3ff),         \
+   conv_i2_to_i(((x) >> 30) & 0x3) \
+}
+
+#define UNPACK_BGR10A2_UNORM(x) { \
+   conv_ui10_to_norm_float(((x) >> 20) & 0x3ff), \
+   conv_ui10_to_norm_float(((x) >> 10) & 0x3ff), \
+   conv_ui10_to_norm_float((x) & 0x3ff), \
+   conv_ui2_to_norm_float(((x) >> 30) & 0x3) \
+}
+
+#define UNPACK_BGR10A2_SNORM(x) { \
+   conv_i10_to_norm_float(ctx, ((x) >> 20) & 0x3ff), \
+   conv_i10_to_norm_float(ctx, ((x) >> 10) & 0x3ff), \
+   conv_i10_to_norm_float(ctx, (x) & 0x3ff), \
+   conv_i2_to_norm_float(ctx, ((x) >> 30) & 0x3) \
+}
+
+#define UNPACK_BGRA8_UNORM(x) { \
+   UBYTE_TO_FLOAT(((x) >> 16) & 0xff), \
+   UBYTE_TO_FLOAT(((x) >> 8) & 0xff), \
+   UBYTE_TO_FLOAT((x) & 0xff), \
+   UBYTE_TO_FLOAT(((x) >> 24) & 0xff) \
+}
+
+#define TEMPLATE_FUNC1(t, src, type, dst, conv) \
+   static void _mesa_wrapped_VertexAttrib##t##1##src(GLuint index, type *v) \
+   { \
+      _mesa_marshal_VertexAttrib##t##1##dst(index, conv(v[0])); \
+   }
+
+#define TEMPLATE_FUNC2(t, src, type, dst, conv) \
+   static void _mesa_wrapped_VertexAttrib##t##2##src(GLuint index, type *v) \
+   { \
+      _mesa_marshal_VertexAttrib##t##2##dst(index, conv(v[0]), conv(v[1])); \
+   }
+
+#define TEMPLATE_FUNC3(t, src, type, dst, conv) \
+   static void _mesa_wrapped_VertexAttrib##t##3##src(GLuint index, type *v) \
+   { \
+      _mesa_marshal_VertexAttrib##t##3##dst(index, conv(v[0]), conv(v[1]), \
+                                             conv(v[2])); \
+   }
+
+#define TEMPLATE_FUNC4(t, src, type, dst, conv) \
+   static void _mesa_wrapped_VertexAttrib##t##4##src(GLuint index, type *v) \
+   { \
+      _mesa_marshal_VertexAttrib##t##4##dst(index, conv(v[0]), conv(v[1]), \
+                                            conv(v[2]), conv(v[3])); \
+   }
+
+#define SCALED false
+#define NORMALIZED true
+
+#define TEMPLATE_FUNCP(n, src, type, normalized) \
+   static void _mesa_wrapped_VertexAttribP##n##src(GLuint index, GLuint *v) \
+   { \
+      _mesa_marshal_VertexAttribP##n##ui(index, type, normalized, v[0]); \
+   }
+
+#define TEMPLATE_FUNCUP(n, src, dst, unpack) \
+   static void _mesa_wrapped_VertexAttribP##n##src(GLuint index, GLuint *v) \
+   { \
+      float fv[n] = unpack(v[0]); \
+      _mesa_marshal_VertexAttrib##n##dst(index, fv); \
+   }
+
+#define TEMPLATE_FUNCUP_CTX(n, src, dst, unpack) \
+   static void _mesa_wrapped_VertexAttribP##n##src(GLuint index, GLuint *v) \
+   { \
+      GET_CURRENT_CONTEXT(ctx); \
+      float fv[n] = unpack(v[0]); \
+      _mesa_marshal_VertexAttrib##n##dst(index, fv); \
+   }
+
+#define TEMPLATE_FUNC_ALL3(t, src, type, dst, conv) \
+   TEMPLATE_FUNC1(t, src, type, dst, conv) \
+   TEMPLATE_FUNC2(t, src, type, dst, conv) \
+   TEMPLATE_FUNC3(t, src, type, dst, conv)
+
+#define TEMPLATE_FUNC_ALL4(t, src, type, dst, conv) \
+   TEMPLATE_FUNC_ALL3(t, src, type, dst, conv) \
+   TEMPLATE_FUNC4(t, src, type, dst, conv)
+
+/* We use NV attributes because they can set all non-generic attributes. */
+
+/* Define VertexAttrib wrappers using template macros. */
+TEMPLATE_FUNC_ALL4(, bvNV, GLbyte, sNV, )
+TEMPLATE_FUNC_ALL4(, NbvNV, GLbyte, fNV, BYTE_TO_FLOAT)
+TEMPLATE_FUNC_ALL4(, ubvNV, GLubyte, sNV, )
+TEMPLATE_FUNC_ALL3(, NubvNV, GLubyte, fNV, UBYTE_TO_FLOAT) /* TODO: use VertexAttrib4ubNV */
+
+TEMPLATE_FUNC_ALL3(, bv, GLbyte, s, )                     /* TODO: use VertexAttrib4bv */
+TEMPLATE_FUNC_ALL3(, Nbv, GLbyte, fARB, BYTE_TO_FLOAT)    /* TODO: use VertexAttrib4Nb */
+TEMPLATE_FUNC_ALL3(, ubv, GLubyte, s, )                   /* TODO: use VertexAttrib4ubv */
+TEMPLATE_FUNC_ALL3(, Nubv, GLubyte, fARB, UBYTE_TO_FLOAT) /* TODO: use VertexAttrib4Nub */
+TEMPLATE_FUNC_ALL3(I, bv, GLbyte, iEXT, )                 /* TODO: use VertexAttribI4bv */
+TEMPLATE_FUNC_ALL3(I, ubv, GLubyte, uiEXT, )              /* TODO: use VertexAttribI4ubv */
+
+TEMPLATE_FUNC_ALL4(, NsvNV, GLshort, fNV, SHORT_TO_FLOAT)
+TEMPLATE_FUNC_ALL4(, usvNV, GLushort, fNV, )
+TEMPLATE_FUNC_ALL4(, NusvNV, GLushort, fNV, USHORT_TO_FLOAT)
+
+TEMPLATE_FUNC_ALL3(, Nsv, GLshort, fARB, SHORT_TO_FLOAT)  /* TODO: use VertexAttrib4Nsv */
+TEMPLATE_FUNC_ALL3(, usv, GLushort, fARB, )               /* TODO: use VertexAttrib4usv */
+TEMPLATE_FUNC_ALL3(, Nusv, GLushort, fARB, USHORT_TO_FLOAT) /* TODO: use VertexAttrib4Nusv */
+TEMPLATE_FUNC_ALL3(I, sv, GLshort, iEXT, )                /* TODO: use VertexAttribI4sv */
+TEMPLATE_FUNC_ALL3(I, usv, GLushort, uiEXT, )             /* TODO: use VertexAttribI4usv */
+
+TEMPLATE_FUNC_ALL4(, ivNV, GLint, fNV, )
+TEMPLATE_FUNC_ALL4(, NivNV, GLint, fNV, INT_TO_FLOAT)
+TEMPLATE_FUNC_ALL4(, uivNV, GLuint, fNV, )
+TEMPLATE_FUNC_ALL4(, NuivNV, GLuint, fNV, UINT_TO_FLOAT)
+
+TEMPLATE_FUNC_ALL3(, iv, GLint, fARB, )
+TEMPLATE_FUNC_ALL3(, Niv, GLint, fARB, INT_TO_FLOAT)
+TEMPLATE_FUNC_ALL3(, uiv, GLuint, fARB, )
+TEMPLATE_FUNC_ALL3(, Nuiv, GLuint, fARB, UINT_TO_FLOAT)
+
+TEMPLATE_FUNC_ALL4(, xvNV, GLfixed, fNV, FIXED_TO_FLOAT)
+TEMPLATE_FUNC_ALL4(, xv, GLfixed, fARB, FIXED_TO_FLOAT)
+
+TEMPLATE_FUNC_ALL4(, hv, GLhalf, fARB, _mesa_half_to_float)
+
+TEMPLATE_FUNC2(L, ui64v, GLuint64, d, UINT64_AS_DOUBLE)
+TEMPLATE_FUNC3(L, ui64v, GLuint64, d, UINT64_AS_DOUBLE)
+TEMPLATE_FUNC4(L, ui64v, GLuint64, d, UINT64_AS_DOUBLE)
+
+TEMPLATE_FUNCP(4, _rgb10a2_sscaled, GL_INT_2_10_10_10_REV, SCALED)
+TEMPLATE_FUNCP(4, _rgb10a2_snorm, GL_INT_2_10_10_10_REV, NORMALIZED)
+TEMPLATE_FUNCP(4, _rgb10a2_uscaled, GL_UNSIGNED_INT_2_10_10_10_REV, SCALED)
+TEMPLATE_FUNCP(4, _rgb10a2_unorm, GL_UNSIGNED_INT_2_10_10_10_REV, NORMALIZED)
+TEMPLATE_FUNCP(3, _rg11b10_float, GL_UNSIGNED_INT_10F_11F_11F_REV, SCALED)
+
+TEMPLATE_FUNCUP(4, NV_rgb10a2_uscaled, fvNV, UNPACK_RGB10A2_USCALED)
+TEMPLATE_FUNCUP(4, NV_rgb10a2_sscaled, fvNV, UNPACK_RGB10A2_SSCALED)
+TEMPLATE_FUNCUP(4, NV_rgb10a2_unorm, fvNV, UNPACK_RGB10A2_UNORM)
+TEMPLATE_FUNCUP_CTX(4, NV_rgb10a2_snorm, fvNV, UNPACK_RGB10A2_SNORM)
+
+TEMPLATE_FUNCUP(4, NV_bgr10a2_uscaled, fvNV, UNPACK_BGR10A2_USCALED)
+TEMPLATE_FUNCUP(4, NV_bgr10a2_sscaled, fvNV, UNPACK_BGR10A2_SSCALED)
+TEMPLATE_FUNCUP(4, NV_bgr10a2_unorm, fvNV, UNPACK_BGR10A2_UNORM)
+TEMPLATE_FUNCUP_CTX(4, NV_bgr10a2_snorm, fvNV, UNPACK_BGR10A2_SNORM)
+TEMPLATE_FUNCUP(4, NV_bgra8_unorm, fvNV, UNPACK_BGRA8_UNORM)
+
+TEMPLATE_FUNCUP(4, _bgr10a2_uscaled, fvARB, UNPACK_BGR10A2_USCALED)
+TEMPLATE_FUNCUP(4, _bgr10a2_sscaled, fvARB, UNPACK_BGR10A2_SSCALED)
+TEMPLATE_FUNCUP(4, _bgr10a2_unorm, fvARB, UNPACK_BGR10A2_UNORM)
+TEMPLATE_FUNCUP_CTX(4, _bgr10a2_snorm, fvARB, UNPACK_BGR10A2_SNORM)
+TEMPLATE_FUNCUP(4, _bgra8_unorm, fvARB, UNPACK_BGRA8_UNORM)
+
+typedef void (GLAPIENTRY *attrib_func)(GLuint indx, const void *data);
+
+/* indexing: [gltype & 0x3f][normalized][size - 1] */
+static const attrib_func legacy_rgba_attrib_funcs[][2][4] = {
+   { /* GL_BYTE */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1bvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2bvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3bvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4bvNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1NbvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2NbvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3NbvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4NbvNV,
+      },
+   },
+   { /* GL_UNSIGNED_BYTE */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1ubvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2ubvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3ubvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4ubvNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1NubvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2NubvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3NubvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4ubvNV, /* always normalized */
+      },
+   },
+   { /* GL_SHORT */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1svNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2svNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3svNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4svNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1NsvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2NsvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3NsvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4NsvNV,
+      },
+   },
+   { /* GL_UNSIGNED_SHORT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1usvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2usvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3usvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4usvNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1NusvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2NusvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3NusvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4NusvNV,
+      },
+   },
+   { /* GL_INT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1ivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2ivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3ivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4ivNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1NivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2NivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3NivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4NivNV,
+      },
+   },
+   { /* GL_UNSIGNED_INT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1uivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2uivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3uivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4uivNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1NuivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2NuivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3NuivNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4NuivNV,
+       },
+   },
+   { /* GL_FLOAT */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1fvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2fvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3fvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4fvNV,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1fvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2fvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3fvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4fvNV,
+      },
+   },
+   {{0}}, /* GL_2_BYTES */
+   {{0}}, /* GL_3_BYTES */
+   {{0}}, /* GL_4_BYTES */
+   { /* GL_DOUBLE */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1dvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2dvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3dvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4dvNV,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1dvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2dvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3dvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4dvNV,
+      },
+   },
+   { /* GL_HALF_FLOAT */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4hvNV,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4hvNV,
+      },
+   },
+   { /* GL_FIXED */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1xvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2xvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3xvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4xvNV,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1xvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib2xvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib3xvNV,
+         (attrib_func)_mesa_wrapped_VertexAttrib4xvNV,
+      },
+   },
+   {{0}}, /* unused (13) */
+   {{0}}, /* unused (14) */
+   {{0}}, /* unused (15) */
+   {{0}}, /* unused (16) */
+   {{0}}, /* unused (17) */
+   {{0}}, /* unused (18) */
+   {{0}}, /* unused (19) */
+   {{0}}, /* unused (20) */
+   {{0}}, /* unused (21) */
+   {{0}}, /* unused (22) */
+   {{0}}, /* unused (23) */
+   {{0}}, /* unused (24) */
+   {{0}}, /* unused (25) */
+   {{0}}, /* unused (26) */
+   {{0}}, /* unused (27) */
+   {{0}}, /* unused (28) */
+   {{0}}, /* unused (29) */
+   {{0}}, /* unused (30) */
+   { /* GL_INT_2_10_10_10_REV */
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4NV_rgb10a2_sscaled,
+      },
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4NV_rgb10a2_snorm,
+      },
+   },
+   {{0}}, /* unused (32) */
+   { /* GL_HALF_FLOAT_OES */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4hvNV,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib2hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib3hvNV,
+         (attrib_func)_mesa_marshal_VertexAttrib4hvNV,
+      },
+   },
+   {{0}}, /* unused (34) */
+   {{0}}, /* unused (35) */
+   {{0}}, /* unused (36) */
+   {{0}}, /* unused (37) */
+   {{0}}, /* unused (38) */
+   {{0}}, /* unused (39) */
+   { /* GL_UNSIGNED_INT_2_10_10_10_REV */
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4NV_rgb10a2_uscaled,
+      },
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4NV_rgb10a2_unorm,
+      },
+   },
+};
+
+/* indexing: [type & 0x3][normalized] */
+static const attrib_func legacy_bgra_attrib_funcs[4][2] = {
+   { /* GL_UNSIGNED_INT_2_10_10_10_REV */
+      (attrib_func)_mesa_wrapped_VertexAttribP4NV_bgr10a2_uscaled,
+      (attrib_func)_mesa_wrapped_VertexAttribP4NV_bgr10a2_unorm,
+   },
+   { /* GL_UNSIGNED_BYTE */
+      0,
+      (attrib_func)_mesa_wrapped_VertexAttribP4NV_bgra8_unorm,
+   },
+   {0}, /* unused (2) */
+   { /* GL_INT_2_10_10_10_REV */
+      (attrib_func)_mesa_wrapped_VertexAttribP4NV_bgr10a2_sscaled,
+      (attrib_func)_mesa_wrapped_VertexAttribP4NV_bgr10a2_snorm,
+   }
+};
+
+/* indexing: [(gltype & 0x3f) | (double << 5)][integer*2 + normalized][size - 1] */
+static const attrib_func generic_rgba_attrib_funcs[][4][4] = {
+   { /* GL_BYTE */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1bv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2bv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3bv,
+         (attrib_func)_mesa_marshal_VertexAttrib4bv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1Nbv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2Nbv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3Nbv,
+         (attrib_func)_mesa_marshal_VertexAttrib4Nbv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttribI1bv,
+         (attrib_func)_mesa_wrapped_VertexAttribI2bv,
+         (attrib_func)_mesa_wrapped_VertexAttribI3bv,
+         (attrib_func)_mesa_marshal_VertexAttribI4bv,
+      },
+   },
+   { /* GL_UNSIGNED_BYTE */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1ubv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2ubv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3ubv,
+         (attrib_func)_mesa_marshal_VertexAttrib4ubv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1Nubv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2Nubv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3Nubv,
+         (attrib_func)_mesa_marshal_VertexAttrib4Nubv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttribI1ubv,
+         (attrib_func)_mesa_wrapped_VertexAttribI2ubv,
+         (attrib_func)_mesa_wrapped_VertexAttribI3ubv,
+         (attrib_func)_mesa_marshal_VertexAttribI4ubv,
+      },
+   },
+   { /* GL_SHORT */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1sv,
+         (attrib_func)_mesa_marshal_VertexAttrib2sv,
+         (attrib_func)_mesa_marshal_VertexAttrib3sv,
+         (attrib_func)_mesa_marshal_VertexAttrib4sv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1Nsv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2Nsv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3Nsv,
+         (attrib_func)_mesa_marshal_VertexAttrib4Nsv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttribI1sv,
+         (attrib_func)_mesa_wrapped_VertexAttribI2sv,
+         (attrib_func)_mesa_wrapped_VertexAttribI3sv,
+         (attrib_func)_mesa_marshal_VertexAttribI4sv,
+      },
+   },
+   { /* GL_UNSIGNED_SHORT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1usv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2usv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3usv,
+         (attrib_func)_mesa_marshal_VertexAttrib4usv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1Nusv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2Nusv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3Nusv,
+         (attrib_func)_mesa_marshal_VertexAttrib4Nusv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttribI1usv,
+         (attrib_func)_mesa_wrapped_VertexAttribI2usv,
+         (attrib_func)_mesa_wrapped_VertexAttribI3usv,
+         (attrib_func)_mesa_marshal_VertexAttribI4usv,
+      },
+   },
+   { /* GL_INT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1iv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2iv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3iv,
+         (attrib_func)_mesa_marshal_VertexAttrib4iv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1Niv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2Niv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3Niv,
+         (attrib_func)_mesa_marshal_VertexAttrib4Niv,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttribI1iv,
+         (attrib_func)_mesa_marshal_VertexAttribI2ivEXT,
+         (attrib_func)_mesa_marshal_VertexAttribI3ivEXT,
+         (attrib_func)_mesa_marshal_VertexAttribI4ivEXT,
+      },
+   },
+   { /* GL_UNSIGNED_INT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1uiv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2uiv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3uiv,
+         (attrib_func)_mesa_marshal_VertexAttrib4uiv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1Nuiv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2Nuiv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3Nuiv,
+         (attrib_func)_mesa_marshal_VertexAttrib4Nuiv,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttribI1uiv,
+         (attrib_func)_mesa_marshal_VertexAttribI2uivEXT,
+         (attrib_func)_mesa_marshal_VertexAttribI3uivEXT,
+         (attrib_func)_mesa_marshal_VertexAttribI4uivEXT,
+      },
+   },
+   { /* GL_FLOAT */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1fvARB,
+         (attrib_func)_mesa_marshal_VertexAttrib2fvARB,
+         (attrib_func)_mesa_marshal_VertexAttrib3fvARB,
+         (attrib_func)_mesa_marshal_VertexAttrib4fvARB,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1fvARB,
+         (attrib_func)_mesa_marshal_VertexAttrib2fvARB,
+         (attrib_func)_mesa_marshal_VertexAttrib3fvARB,
+         (attrib_func)_mesa_marshal_VertexAttrib4fvARB,
+      },
+   },
+   {{0}}, /* GL_2_BYTES */
+   {{0}}, /* GL_3_BYTES */
+   {{0}}, /* GL_4_BYTES */
+   { /* GL_DOUBLE */
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1dv,
+         (attrib_func)_mesa_marshal_VertexAttrib2dv,
+         (attrib_func)_mesa_marshal_VertexAttrib3dv,
+         (attrib_func)_mesa_marshal_VertexAttrib4dv,
+      },
+      {
+         (attrib_func)_mesa_marshal_VertexAttrib1dv,
+         (attrib_func)_mesa_marshal_VertexAttrib2dv,
+         (attrib_func)_mesa_marshal_VertexAttrib3dv,
+         (attrib_func)_mesa_marshal_VertexAttrib4dv,
+      },
+   },
+   { /* GL_HALF_FLOAT */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib4hv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib4hv,
+      },
+   },
+   { /* GL_FIXED */
+       {
+         (attrib_func)_mesa_wrapped_VertexAttrib1xv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2xv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3xv,
+         (attrib_func)_mesa_wrapped_VertexAttrib4xv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1xv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2xv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3xv,
+         (attrib_func)_mesa_wrapped_VertexAttrib4xv,
+      },
+   },
+   {{0}}, /* unused (13) */
+   {{0}}, /* unused (14) */
+   {{0}}, /* unused (15) */
+   {{0}}, /* unused (16) */
+   {{0}}, /* unused (17) */
+   {{0}}, /* unused (18) */
+   {{0}}, /* unused (19) */
+   {{0}}, /* unused (20) */
+   {{0}}, /* unused (21) */
+   {{0}}, /* unused (22) */
+   {{0}}, /* unused (23) */
+   {{0}}, /* unused (24) */
+   {{0}}, /* unused (25) */
+   {{0}}, /* unused (26) */
+   {{0}}, /* unused (27) */
+   {{0}}, /* unused (28) */
+   {{0}}, /* unused (29) */
+   {{0}}, /* unused (30) */
+   { /* GL_INT_2_10_10_10_REV */
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4_rgb10a2_sscaled,
+      },
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4_rgb10a2_snorm,
+      },
+   },
+   {{0}}, /* unused (32) */
+   { /* GL_HALF_FLOAT_OES */
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib4hv,
+      },
+      {
+         (attrib_func)_mesa_wrapped_VertexAttrib1hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib2hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib3hv,
+         (attrib_func)_mesa_wrapped_VertexAttrib4hv,
+      },
+   },
+   {{0}}, /* unused (34) */
+   {{0}}, /* unused (35) */
+   {{0}}, /* unused (36) */
+   {{0}}, /* unused (37) */
+   {{0}}, /* unused (38) */
+   {{0}}, /* unused (39) */
+   { /* GL_UNSIGNED_INT_2_10_10_10_REV */
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4_rgb10a2_uscaled,
+      },
+      {
+         0,
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP4_rgb10a2_unorm,
+      },
+   },
+   {{0}}, /* unused (41) */
+   { /* GL_DOUBLE | (doubles << 5) (real double) */
+      {
+         (attrib_func)_mesa_marshal_VertexAttribL1dv,
+         (attrib_func)_mesa_marshal_VertexAttribL2dv,
+         (attrib_func)_mesa_marshal_VertexAttribL3dv,
+         (attrib_func)_mesa_marshal_VertexAttribL4dv,
+      },
+   },
+   {{0}}, /* unused (43) */
+   {{0}}, /* unused (44) */
+   {{0}}, /* unused (45) */
+   {{0}}, /* unused (46) */
+   { /* GL_UNSIGNED_INT64_ARB | (doubles << 5) (doubles is always true) */
+     {0},
+     {0},
+     {
+        (attrib_func)_mesa_marshal_VertexAttribL1ui64vARB,
+        (attrib_func)_mesa_wrapped_VertexAttribL2ui64v,
+        (attrib_func)_mesa_wrapped_VertexAttribL3ui64v,
+        (attrib_func)_mesa_wrapped_VertexAttribL4ui64v,
+     },
+   },
+   {{0}}, /* unused (48) */
+   {{0}}, /* unused (49) */
+   {{0}}, /* unused (50) */
+   {{0}}, /* unused (51) */
+   {{0}}, /* unused (52) */
+   {{0}}, /* unused (53) */
+   {{0}}, /* unused (54) */
+   {{0}}, /* unused (55) */
+   {{0}}, /* unused (56) */
+   {{0}}, /* unused (57) */
+   {{0}}, /* unused (58) */
+   { /* GL_UNSIGNED_INT_10F_11F_11F_REV */
+      {
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP3_rg11b10_float,
+         0
+      },
+      {
+         0,
+         0,
+         (attrib_func)_mesa_wrapped_VertexAttribP3_rg11b10_float,
+         0
+      },
+   },
+};
+
+/* indexing: [type & 0x3][normalized] */
+static const attrib_func generic_bgra_attrib_funcs[4][2] = {
+   { /* GL_UNSIGNED_INT_2_10_10_10_REV */
+      (attrib_func)_mesa_wrapped_VertexAttribP4_bgr10a2_uscaled,
+      (attrib_func)_mesa_wrapped_VertexAttribP4_bgr10a2_unorm,
+   },
+   { /* GL_UNSIGNED_BYTE */
+      0,
+      (attrib_func)_mesa_wrapped_VertexAttribP4_bgra8_unorm,
+   },
+   {0}, /* unused (2) */
+   { /* GL_INT_2_10_10_10_REV */
+      (attrib_func)_mesa_wrapped_VertexAttribP4_bgr10a2_sscaled,
+      (attrib_func)_mesa_wrapped_VertexAttribP4_bgr10a2_snorm,
+   }
+};
+
+/*
+ * Return VertexAttrib*NV function pointer matching the provided vertex format.
+ */
+static inline attrib_func
+get_legacy_func(union gl_vertex_format_user format)
+{
+   if (format.Bgra)
+      return legacy_bgra_attrib_funcs[format.Type & 0x3][format.Normalized];
+
+   int type = format.Type & 0x3f;
+
+   assert(type < ARRAY_SIZE(legacy_rgba_attrib_funcs));
+   return legacy_rgba_attrib_funcs[type][format.Normalized][format.Size - 1];
+}
+
+/*
+ * Return VertexAttrib*ARB function pointer matching the provided vertex format.
+ */
+static inline attrib_func
+get_generic_func(union gl_vertex_format_user format)
+{
+   if (format.Bgra)
+      return generic_bgra_attrib_funcs[format.Type & 0x3][format.Normalized];
+
+   int type = (format.Type & 0x3f) | ((int)format.Doubles << 5);
+   int mod = format.Integer * 2 + format.Normalized;
+
+   assert(type < ARRAY_SIZE(generic_rgba_attrib_funcs));
+   return generic_rgba_attrib_funcs[type][mod][format.Size - 1];
+}
+
+static inline const uint8_t *
+attrib_addr(const struct glthread_vao *vao,
+            const struct glthread_attrib *array)
+{
+   return (const uint8_t*)vao->Attrib[array->BufferIndex].Pointer +
+          array->RelativeOffset;
+}
+
+static inline unsigned
+attrib_stride(const struct glthread_vao *vao,
+              const struct glthread_attrib *array)
+{
+   return vao->Attrib[array->BufferIndex].Stride;
+}
+
+struct attrib_info {
+   attrib_func marshal; /* glVertex4fv, etc. */
+   const uint8_t *ptr;  /* vertex array pointer at the first vertex */
+   uint16_t stride;
+   uint8_t attrib;      /* VERT_ATTRIB_* */
+};
+
+/**
+ * Convert glDrawElements into glBegin/End.
+ *
+ * We use this when we need to upload non-VBO vertices and the vertex range
+ * to upload is much greater than the draw vertex count, which would cause
+ * the upload to take too much time. We can get better performance if we
+ * read each vertex from user memory and push it through glBegin/End.
+ *
+ * This assumes: No buffer objects, no instancing, no primitive restart.
+ */
+void
+_mesa_glthread_UnrollDrawElements(struct gl_context *ctx,
+                                  GLenum mode, GLsizei count, GLenum type,
+                                  const GLvoid *indices, GLint basevertex)
+{
+   /* First gather all glVertex(Attrib) function pointers and attribute
+    * information, and then execute them between glBegin/End for every vertex.
+    */
+   const struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   struct attrib_info attribs[VERT_ATTRIB_MAX];
+   unsigned num_attribs = 0;
+
+   /* Gather glColor, glTexCoord etc. functions for non-generic attributes. */
+   GLbitfield mask = (VERT_BIT_FF_ALL & ~VERT_BIT_POS) & vao->Enabled;
+   while (mask) {
+      const gl_vert_attrib attrib = u_bit_scan(&mask);
+      struct attrib_info *info = &attribs[num_attribs];
+      const struct glthread_attrib *attr = &vao->Attrib[attrib];
+
+      info->marshal = get_legacy_func(attr->Format);
+      info->attrib = attrib;
+      info->ptr = attrib_addr(vao, attr);
+      info->stride = attrib_stride(vao, attr);
+      num_attribs++;
+   }
+
+   /* Gather glVertexAttrib functions for generic attributes. */
+   mask = (VERT_BIT_GENERIC_ALL & ~VERT_BIT_GENERIC0) & vao->Enabled;
+   while (mask) {
+      const gl_vert_attrib attrib = u_bit_scan(&mask);
+      struct attrib_info *info = &attribs[num_attribs];
+      const struct glthread_attrib *attr = &vao->Attrib[attrib];
+
+      info->marshal = get_generic_func(attr->Format);
+      info->attrib = attrib - VERT_ATTRIB_GENERIC0;
+      info->ptr = attrib_addr(vao, attr);
+      info->stride = attrib_stride(vao, attr);
+      num_attribs++;
+   }
+
+   /* Finally, vertex position. */
+   if (vao->Enabled & VERT_BIT_GENERIC0) {
+      struct attrib_info *info = &attribs[num_attribs];
+      const struct glthread_attrib *attr =
+            &vao->Attrib[VERT_ATTRIB_GENERIC0];
+
+      info->marshal = get_generic_func(attr->Format);
+      info->attrib = 0;
+      info->ptr = attrib_addr(vao, attr);
+      info->stride = attrib_stride(vao, attr);
+      num_attribs++;
+   } else if (vao->Enabled & VERT_BIT_POS) {
+      struct attrib_info *info = &attribs[num_attribs];
+      const struct glthread_attrib *attr =
+            &vao->Attrib[VERT_ATTRIB_POS];
+
+      info->marshal = get_legacy_func(attr->Format);
+      info->attrib = VERT_ATTRIB_POS;
+      info->ptr = attrib_addr(vao, attr);
+      info->stride = attrib_stride(vao, attr);
+      num_attribs++;
+   }
+
+   /* Convert the draw into glBegin/End. */
+   _mesa_marshal_Begin(mode);
+
+   switch (type) {
+   case GL_UNSIGNED_BYTE: {
+      const uint8_t *ub = indices;
+      for (int i = 0; i < count; i++) {
+         for (unsigned a = 0; a < num_attribs; a++) {
+            struct attrib_info *info = &attribs[a];
+            unsigned index = ub[i] + basevertex;
+
+            info->marshal(info->attrib, info->ptr + info->stride * index);
+         }
+      }
+      break;
+   }
+   case GL_UNSIGNED_SHORT: {
+      const uint16_t *us = indices;
+      for (int i = 0; i < count; i++) {
+         for (unsigned a = 0; a < num_attribs; a++) {
+            struct attrib_info *info = &attribs[a];
+            unsigned index = us[i] + basevertex;
+
+            info->marshal(info->attrib, info->ptr + info->stride * index);
+         }
+      }
+      break;
+   }
+   case GL_UNSIGNED_INT: {
+      const uint32_t *ui = indices;
+      for (int i = 0; i < count; i++) {
+         for (unsigned a = 0; a < num_attribs; a++) {
+            struct attrib_info *info = &attribs[a];
+            unsigned index = ui[i] + basevertex;
+
+            info->marshal(info->attrib, info->ptr + info->stride * index);
+         }
+      }
+      break;
+   }
+   }
+
+   _mesa_marshal_End();
+}
diff --git a/src/mesa/meson.build b/src/mesa/meson.build
index c664e9847e2c..dbbcf0b08678 100644
--- a/src/mesa/meson.build
+++ b/src/mesa/meson.build
@@ -119,6 +119,7 @@ files_libmesa = files(
   'main/glthread.h',
   'main/glthread_bufferobj.c',
   'main/glthread_draw.c',
+  'main/glthread_draw_unroll.c',
   'main/glthread_get.c',
   'main/glthread_list.c',
   'main/glthread_marshal.h',
-- 
GitLab


From 3d887f60f97123b5b6377e1739c5627a85a5a63c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 03:36:04 -0500
Subject: [PATCH 10/20] glthread: reorder draw code a little

---
 src/mesa/main/glthread_draw.c | 31 ++++++++++++++++---------------
 1 file changed, 16 insertions(+), 15 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 4a3ea5dbadac..a47a655514fe 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -431,9 +431,6 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
 {
    GET_CURRENT_CONTEXT(ctx);
 
-   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
-   unsigned user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
-
    if (compiled_into_dlist && ctx->GLThread.ListMode) {
       _mesa_glthread_finish_before(ctx, "DrawArrays");
       /* Use the function that's compiled into a display list. */
@@ -441,6 +438,9 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
       return;
    }
 
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
+
    /* Fast path when nothing needs to be done.
     *
     * This is also an error path. Zero counts should still call the driver
@@ -513,11 +513,6 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
                               const GLsizei *count, GLsizei draw_count)
 {
    GET_CURRENT_CONTEXT(ctx);
-   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
-   unsigned user_buffer_mask =
-      ctx->API == API_OPENGL_CORE || draw_count <= 0 ||
-      ctx->GLThread.inside_begin_end ?
-            0 : vao->UserPointerMask & vao->BufferEnabled;
 
    if (ctx->GLThread.ListMode) {
       _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
@@ -526,7 +521,13 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
       return;
    }
 
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
+   unsigned user_buffer_mask =
+      ctx->API == API_OPENGL_CORE ||
+      draw_count <= 0 ||
+      ctx->GLThread.inside_begin_end ?
+            0 : vao->UserPointerMask & vao->BufferEnabled;
 
    if (user_buffer_mask) {
       unsigned min_index = ~0;
@@ -844,10 +845,6 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
 {
    GET_CURRENT_CONTEXT(ctx);
 
-   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
-   unsigned user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
-   bool has_user_indices = vao->CurrentElementBufferName == 0;
-
    if (compiled_into_dlist && ctx->GLThread.ListMode)
       goto sync;
 
@@ -856,6 +853,10 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
       return;
    }
 
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
+   bool has_user_indices = vao->CurrentElementBufferName == 0;
+
    /* Fast path when nothing needs to be done.
     *
     * This is also an error path. Zero counts should still call the driver
@@ -1092,6 +1093,9 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
 {
    GET_CURRENT_CONTEXT(ctx);
 
+   if (ctx->GLThread.ListMode)
+      goto sync;
+
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    unsigned user_buffer_mask = 0;
    bool has_user_indices = false;
@@ -1106,9 +1110,6 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
       has_user_indices = vao->CurrentElementBufferName == 0;
    }
 
-   if (ctx->GLThread.ListMode)
-      goto sync;
-
    /* Fast path when we don't need to upload anything. */
    if (!user_buffer_mask && !has_user_indices) {
       multi_draw_elements_async(ctx, mode, count, type, indices,
-- 
GitLab


From 7c15adadeb3aea957804300a046acc5282ae5dcd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 03:57:20 -0500
Subject: [PATCH 11/20] glthread: add ctx->GLThread.draw_always_async to
 simplify draw checking

This just precomputes 3 terms of the condition to draw asynchronously.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mapi/glapi/gen/gl_API.xml    |  4 ++--
 src/mesa/main/glthread.c         |  2 ++
 src/mesa/main/glthread.h         |  1 +
 src/mesa/main/glthread_draw.c    | 24 ++++++++----------------
 src/mesa/main/glthread_marshal.h | 29 ++++++++++++++++++++++++++++-
 5 files changed, 41 insertions(+), 19 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 7a02da387967..07589bca753e 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -1156,7 +1156,7 @@
     </function>
 
     <function name="Begin" deprecated="3.1" exec="beginend"
-              marshal_call_after="ctx->GLThread.inside_begin_end = true;">
+              marshal_call_after="_mesa_glthread_Begin(ctx);">
         <param name="mode" type="GLenum"/>
         <glx rop="4"/>
     </function>
@@ -1371,7 +1371,7 @@
     </function>
 
     <function name="End" deprecated="3.1" exec="beginend"
-              marshal_call_after="ctx->GLThread.inside_begin_end = false;">
+              marshal_call_after="_mesa_glthread_End(ctx);">
         <glx rop="23"/>
     </function>
 
diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 680fc1a154c7..812fb43f9482 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -155,6 +155,8 @@ _mesa_glthread_init(struct gl_context *ctx)
    /* glthread takes over all L3 pinning */
    ctx->st->pin_thread_counter = ST_L3_PINNING_DISABLED;
 
+   _mesa_glthread_update_draw_always_async(ctx);
+
    /* Execute the thread initialization function in the thread. */
    struct util_queue_fence fence;
    util_queue_fence_init(&fence);
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index 87f1e39a6a51..cd71d492f96b 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -185,6 +185,7 @@ struct glthread_state
    /** Whether GLThread is enabled. */
    bool enabled;
    bool inside_begin_end;
+   bool draw_always_async;
 
    /** Display lists. */
    GLenum16 ListMode; /**< Zero if not inside display list, else list mode. */
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index a47a655514fe..c3099c7507a2 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -446,11 +446,8 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
     * This is also an error path. Zero counts should still call the driver
     * for possible GL errors.
     */
-   if (ctx->API == API_OPENGL_CORE || !user_buffer_mask ||
-       count <= 0 || instance_count <= 0 ||
-       /* This will just generate GL_INVALID_OPERATION, as it should. */
-       ctx->GLThread.inside_begin_end ||
-       (!compiled_into_dlist && ctx->GLThread.ListMode)) {
+   if (ctx->GLThread.draw_always_async ||
+       !user_buffer_mask || count <= 0 || instance_count <= 0) {
       draw_arrays_async(ctx, mode, first, count, instance_count, baseinstance);
       return;
    }
@@ -524,10 +521,8 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    struct glthread_attrib_binding buffers[VERT_ATTRIB_MAX];
    unsigned user_buffer_mask =
-      ctx->API == API_OPENGL_CORE ||
-      draw_count <= 0 ||
-      ctx->GLThread.inside_begin_end ?
-            0 : vao->UserPointerMask & vao->BufferEnabled;
+      ctx->GLThread.draw_always_async || draw_count <= 0 ?
+         0 : vao->UserPointerMask & vao->BufferEnabled;
 
    if (user_buffer_mask) {
       unsigned min_index = ~0;
@@ -862,12 +857,9 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
     * This is also an error path. Zero counts should still call the driver
     * for possible GL errors.
     */
-   if (ctx->API == API_OPENGL_CORE || count <= 0 || instance_count <= 0 ||
+   if (ctx->GLThread.draw_always_async || count <= 0 || instance_count <= 0 ||
        !is_index_type_valid(type) ||
-       (!user_buffer_mask && !has_user_indices) ||
-       /* This will just generate GL_INVALID_OPERATION, as it should. */
-       ctx->GLThread.inside_begin_end ||
-       (!compiled_into_dlist && ctx->GLThread.ListMode)) {
+       (!user_buffer_mask && !has_user_indices)) {
       draw_elements_async(ctx, mode, count, type, indices, instance_count,
                           basevertex, baseinstance);
       return;
@@ -1104,8 +1096,8 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
     * When nothing needs to be uploaded or the draw is no-op or generates
     * a GL error, we don't upload anything.
     */
-   if (ctx->API != API_OPENGL_CORE && draw_count > 0 &&
-       is_index_type_valid(type) && !ctx->GLThread.inside_begin_end) {
+   if (!ctx->GLThread.draw_always_async &&
+       draw_count > 0 && is_index_type_valid(type)) {
       user_buffer_mask = vao->UserPointerMask & vao->BufferEnabled;
       has_user_indices = vao->CurrentElementBufferName == 0;
    }
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 69f4f2a62cd3..1aab57de21c2 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -142,6 +142,16 @@ _mesa_glthread_has_non_vbo_vertices_or_indices_or_indirect(const struct gl_conte
            (vao->UserPointerMask & vao->BufferEnabled));
 }
 
+static inline void
+_mesa_glthread_update_draw_always_async(struct gl_context *ctx)
+{
+   /* Executing erroneous cases will just generate GL_INVALID_OPERATION. */
+   ctx->GLThread.draw_always_async =
+      ctx->API == API_OPENGL_CORE ||
+      ctx->GLThread.inside_begin_end ||
+      ctx->GLThread.ListMode;
+}
+
 static inline unsigned
 _mesa_buffer_enum_to_count(GLenum buffer)
 {
@@ -879,8 +889,10 @@ _mesa_glthread_CallLists(struct gl_context *ctx, GLsizei n, GLenum type,
 static inline void
 _mesa_glthread_NewList(struct gl_context *ctx, GLuint list, GLenum mode)
 {
-   if (!ctx->GLThread.ListMode)
+   if (!ctx->GLThread.ListMode) {
       ctx->GLThread.ListMode = MIN2(mode, 0xffff);
+      _mesa_glthread_update_draw_always_async(ctx);
+   }
 }
 
 static inline void
@@ -890,6 +902,7 @@ _mesa_glthread_EndList(struct gl_context *ctx)
       return;
 
    ctx->GLThread.ListMode = 0;
+   _mesa_glthread_update_draw_always_async(ctx);
 
    /* Track the last display list change. */
    p_atomic_set(&ctx->GLThread.LastDListChangeBatchIndex, ctx->GLThread.next);
@@ -938,4 +951,18 @@ _mesa_glthread_DeleteFramebuffers(struct gl_context *ctx, GLsizei n,
    }
 }
 
+static inline void
+_mesa_glthread_Begin(struct gl_context *ctx)
+{
+   ctx->GLThread.inside_begin_end = true;
+   _mesa_glthread_update_draw_always_async(ctx);
+}
+
+static inline void
+_mesa_glthread_End(struct gl_context *ctx)
+{
+   ctx->GLThread.inside_begin_end = false;
+   _mesa_glthread_update_draw_always_async(ctx);
+}
+
 #endif /* MARSHAL_H */
-- 
GitLab


From e2ccaafe5fca4512f76b309fddcf49f73ad7c5fd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 03:43:37 -0500
Subject: [PATCH 12/20] glthread: remove goto statements and add unlikely()
 into draw functions

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/glthread_draw.c | 75 ++++++++++++++---------------------
 1 file changed, 30 insertions(+), 45 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index c3099c7507a2..f075d904a8d4 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -431,7 +431,7 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
 {
    GET_CURRENT_CONTEXT(ctx);
 
-   if (compiled_into_dlist && ctx->GLThread.ListMode) {
+   if (unlikely(compiled_into_dlist && ctx->GLThread.ListMode)) {
       _mesa_glthread_finish_before(ctx, "DrawArrays");
       /* Use the function that's compiled into a display list. */
       CALL_DrawArrays(ctx->CurrentServerDispatch, (mode, first, count));
@@ -511,7 +511,7 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
 {
    GET_CURRENT_CONTEXT(ctx);
 
-   if (ctx->GLThread.ListMode) {
+   if (unlikely(ctx->GLThread.ListMode)) {
       _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
       CALL_MultiDrawArrays(ctx->CurrentServerDispatch,
                            (mode, first, count, draw_count));
@@ -840,8 +840,21 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
 {
    GET_CURRENT_CONTEXT(ctx);
 
-   if (compiled_into_dlist && ctx->GLThread.ListMode)
-      goto sync;
+   if (unlikely(compiled_into_dlist && ctx->GLThread.ListMode)) {
+      _mesa_glthread_finish_before(ctx, "DrawElements");
+
+      /* Only use the ones that are compiled into display lists. */
+      if (basevertex) {
+         CALL_DrawElementsBaseVertex(ctx->CurrentServerDispatch,
+                                     (mode, count, type, indices, basevertex));
+      } else if (index_bounds_valid) {
+         CALL_DrawRangeElements(ctx->CurrentServerDispatch,
+                                (mode, min_index, max_index, count, type, indices));
+      } else {
+         CALL_DrawElements(ctx->CurrentServerDispatch, (mode, count, type, indices));
+      }
+      return;
+   }
 
    if (unlikely(index_bounds_valid && max_index < min_index)) {
       _mesa_marshal_InternalSetError(GL_INVALID_VALUE);
@@ -926,32 +939,6 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    draw_elements_async_user(ctx, mode, count, type, indices, instance_count,
                             basevertex, baseinstance, index_buffer,
                             user_buffer_mask, buffers);
-   return;
-
-sync:
-   _mesa_glthread_finish_before(ctx, "DrawElements");
-
-   if (compiled_into_dlist && ctx->GLThread.ListMode) {
-      /* Only use the ones that are compiled into display lists. */
-      if (basevertex) {
-         CALL_DrawElementsBaseVertex(ctx->CurrentServerDispatch,
-                                     (mode, count, type, indices, basevertex));
-      } else if (index_bounds_valid) {
-         CALL_DrawRangeElements(ctx->CurrentServerDispatch,
-                                (mode, min_index, max_index, count, type, indices));
-      } else {
-         CALL_DrawElements(ctx->CurrentServerDispatch, (mode, count, type, indices));
-      }
-   } else if (index_bounds_valid && instance_count == 1 && baseinstance == 0) {
-      CALL_DrawRangeElementsBaseVertex(ctx->CurrentServerDispatch,
-                                       (mode, min_index, max_index, count,
-                                        type, indices, basevertex));
-   } else {
-      CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->CurrentServerDispatch,
-                                                       (mode, count, type, indices,
-                                                        instance_count, basevertex,
-                                                        baseinstance));
-   }
 }
 
 struct marshal_cmd_MultiDrawElementsUserBuf
@@ -1085,8 +1072,19 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
 {
    GET_CURRENT_CONTEXT(ctx);
 
-   if (ctx->GLThread.ListMode)
-      goto sync;
+   if (unlikely(ctx->GLThread.ListMode)) {
+      _mesa_glthread_finish_before(ctx, "MultiDrawElements");
+
+      if (basevertex) {
+         CALL_MultiDrawElementsBaseVertex(ctx->CurrentServerDispatch,
+                                          (mode, count, type, indices, draw_count,
+                                           basevertex));
+      } else {
+         CALL_MultiDrawElements(ctx->CurrentServerDispatch,
+                                (mode, count, type, indices, draw_count));
+      }
+      return;
+   }
 
    struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
    unsigned user_buffer_mask = 0;
@@ -1221,19 +1219,6 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
    multi_draw_elements_async(ctx, mode, count, type, indices, draw_count,
                              basevertex, index_buffer, user_buffer_mask,
                              buffers);
-   return;
-
-sync:
-   _mesa_glthread_finish_before(ctx, "MultiDrawElements");
-
-   if (basevertex) {
-      CALL_MultiDrawElementsBaseVertex(ctx->CurrentServerDispatch,
-                                       (mode, count, type, indices, draw_count,
-                                        basevertex));
-   } else {
-      CALL_MultiDrawElements(ctx->CurrentServerDispatch,
-                             (mode, count, type, indices, draw_count));
-   }
 }
 
 void GLAPIENTRY
-- 
GitLab


From 279cc0a7677859cf204a5391a7cdb00b4c4badb2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 05:13:36 -0500
Subject: [PATCH 13/20] glthread: inline draw functions that have only one use

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/glthread_draw.c | 215 ++++++++++++++--------------------
 1 file changed, 88 insertions(+), 127 deletions(-)

diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index f075d904a8d4..604146f7ec1d 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -332,31 +332,6 @@ _mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
    return cmd_size;
 }
 
-static ALWAYS_INLINE void
-draw_arrays_async(struct gl_context *ctx, GLenum mode, GLint first,
-                  GLsizei count, GLsizei instance_count, GLuint baseinstance)
-{
-   if (instance_count == 1 && baseinstance == 0) {
-      int cmd_size = sizeof(struct marshal_cmd_DrawArrays);
-      struct marshal_cmd_DrawArrays *cmd =
-         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArrays, cmd_size);
-
-      cmd->mode = mode;
-      cmd->first = first;
-      cmd->count = count;
-   } else {
-      int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstancedBaseInstance);
-      struct marshal_cmd_DrawArraysInstancedBaseInstance *cmd =
-         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstance, cmd_size);
-
-      cmd->mode = mode;
-      cmd->first = first;
-      cmd->count = count;
-      cmd->instance_count = instance_count;
-      cmd->baseinstance = baseinstance;
-   }
-}
-
 /* DrawArraysInstancedBaseInstance with user buffers. */
 struct marshal_cmd_DrawArraysUserBuf
 {
@@ -401,30 +376,6 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
    return cmd->cmd_base.cmd_size;
 }
 
-static ALWAYS_INLINE void
-draw_arrays_async_user(struct gl_context *ctx, GLenum mode, GLint first,
-                       GLsizei count, GLsizei instance_count, GLuint baseinstance,
-                       unsigned user_buffer_mask,
-                       const struct glthread_attrib_binding *buffers)
-{
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
-   int cmd_size = sizeof(struct marshal_cmd_DrawArraysUserBuf) +
-                  buffers_size;
-   struct marshal_cmd_DrawArraysUserBuf *cmd;
-
-   cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysUserBuf,
-                                         cmd_size);
-   cmd->mode = mode;
-   cmd->first = first;
-   cmd->count = count;
-   cmd->instance_count = instance_count;
-   cmd->baseinstance = baseinstance;
-   cmd->user_buffer_mask = user_buffer_mask;
-
-   if (user_buffer_mask)
-      memcpy(cmd + 1, buffers, buffers_size);
-}
-
 static ALWAYS_INLINE void
 draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
             GLuint baseinstance, bool compiled_into_dlist)
@@ -448,7 +399,25 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
     */
    if (ctx->GLThread.draw_always_async ||
        !user_buffer_mask || count <= 0 || instance_count <= 0) {
-      draw_arrays_async(ctx, mode, first, count, instance_count, baseinstance);
+      if (instance_count == 1 && baseinstance == 0) {
+         int cmd_size = sizeof(struct marshal_cmd_DrawArrays);
+         struct marshal_cmd_DrawArrays *cmd =
+            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArrays, cmd_size);
+
+         cmd->mode = mode;
+         cmd->first = first;
+         cmd->count = count;
+      } else {
+         int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstancedBaseInstance);
+         struct marshal_cmd_DrawArraysInstancedBaseInstance *cmd =
+            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstance, cmd_size);
+
+         cmd->mode = mode;
+         cmd->first = first;
+         cmd->count = count;
+         cmd->instance_count = instance_count;
+         cmd->baseinstance = baseinstance;
+      }
       return;
    }
 
@@ -459,8 +428,22 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
                         instance_count, buffers))
       return; /* the error is set by upload_vertices */
 
-   draw_arrays_async_user(ctx, mode, first, count, instance_count, baseinstance,
-                          user_buffer_mask, buffers);
+   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   int cmd_size = sizeof(struct marshal_cmd_DrawArraysUserBuf) +
+                  buffers_size;
+   struct marshal_cmd_DrawArraysUserBuf *cmd;
+
+   cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysUserBuf,
+                                         cmd_size);
+   cmd->mode = mode;
+   cmd->first = first;
+   cmd->count = count;
+   cmd->instance_count = instance_count;
+   cmd->baseinstance = baseinstance;
+   cmd->user_buffer_mask = user_buffer_mask;
+
+   if (user_buffer_mask)
+      memcpy(cmd + 1, buffers, buffers_size);
 }
 
 /* MultiDrawArrays with user buffers. */
@@ -693,48 +676,6 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *c
    return cmd_size;
 }
 
-static ALWAYS_INLINE void
-draw_elements_async(struct gl_context *ctx, GLenum mode, GLsizei count,
-                    GLenum type, const GLvoid *indices, GLsizei instance_count,
-                    GLint basevertex, GLuint baseinstance)
-{
-   if (instance_count == 1 && baseinstance == 0) {
-      int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
-      struct marshal_cmd_DrawElementsBaseVertex *cmd =
-         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
-
-      cmd->mode = MIN2(mode, 0xffff);
-      cmd->type = MIN2(type, 0xffff);
-      cmd->count = count;
-      cmd->indices = indices;
-      cmd->basevertex = basevertex;
-   } else {
-      if (basevertex == 0 && baseinstance == 0) {
-         int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstanced);
-         struct marshal_cmd_DrawElementsInstanced *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstanced, cmd_size);
-
-         cmd->mode = MIN2(mode, 0xffff);
-         cmd->type = MIN2(type, 0xffff);
-         cmd->count = count;
-         cmd->instance_count = instance_count;
-         cmd->indices = indices;
-      } else {
-         int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance);
-         struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *cmd =
-            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstance, cmd_size);
-
-         cmd->mode = MIN2(mode, 0xffff);
-         cmd->type = MIN2(type, 0xffff);
-         cmd->count = count;
-         cmd->instance_count = instance_count;
-         cmd->basevertex = basevertex;
-         cmd->baseinstance = baseinstance;
-         cmd->indices = indices;
-      }
-   }
-}
-
 struct marshal_cmd_DrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
@@ -787,34 +728,6 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    return cmd->cmd_base.cmd_size;
 }
 
-static ALWAYS_INLINE void
-draw_elements_async_user(struct gl_context *ctx, GLenum mode, GLsizei count,
-                         GLenum type, const GLvoid *indices, GLsizei instance_count,
-                         GLint basevertex, GLuint baseinstance,
-                         struct gl_buffer_object *index_buffer,
-                         unsigned user_buffer_mask,
-                         const struct glthread_attrib_binding *buffers)
-{
-   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
-   int cmd_size = sizeof(struct marshal_cmd_DrawElementsUserBuf) +
-                  buffers_size;
-   struct marshal_cmd_DrawElementsUserBuf *cmd;
-
-   cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
-   cmd->mode = MIN2(mode, 0xffff);
-   cmd->type = MIN2(type, 0xffff);
-   cmd->count = count;
-   cmd->indices = indices;
-   cmd->instance_count = instance_count;
-   cmd->basevertex = basevertex;
-   cmd->baseinstance = baseinstance;
-   cmd->user_buffer_mask = user_buffer_mask;
-   cmd->index_buffer = index_buffer;
-
-   if (user_buffer_mask)
-      memcpy(cmd + 1, buffers, buffers_size);
-}
-
 static inline bool
 should_convert_to_begin_end(struct gl_context *ctx, unsigned count,
                             unsigned num_upload_vertices,
@@ -873,8 +786,41 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    if (ctx->GLThread.draw_always_async || count <= 0 || instance_count <= 0 ||
        !is_index_type_valid(type) ||
        (!user_buffer_mask && !has_user_indices)) {
-      draw_elements_async(ctx, mode, count, type, indices, instance_count,
-                          basevertex, baseinstance);
+      if (instance_count == 1 && baseinstance == 0) {
+         int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
+         struct marshal_cmd_DrawElementsBaseVertex *cmd =
+            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
+
+         cmd->mode = MIN2(mode, 0xffff);
+         cmd->type = MIN2(type, 0xffff);
+         cmd->count = count;
+         cmd->indices = indices;
+         cmd->basevertex = basevertex;
+      } else {
+         if (basevertex == 0 && baseinstance == 0) {
+            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstanced);
+            struct marshal_cmd_DrawElementsInstanced *cmd =
+               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstanced, cmd_size);
+
+            cmd->mode = MIN2(mode, 0xffff);
+            cmd->type = MIN2(type, 0xffff);
+            cmd->count = count;
+            cmd->instance_count = instance_count;
+            cmd->indices = indices;
+         } else {
+            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance);
+            struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *cmd =
+               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstance, cmd_size);
+
+            cmd->mode = MIN2(mode, 0xffff);
+            cmd->type = MIN2(type, 0xffff);
+            cmd->count = count;
+            cmd->instance_count = instance_count;
+            cmd->basevertex = basevertex;
+            cmd->baseinstance = baseinstance;
+            cmd->indices = indices;
+         }
+      }
       return;
    }
 
@@ -936,9 +882,24 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    }
 
    /* Draw asynchronously. */
-   draw_elements_async_user(ctx, mode, count, type, indices, instance_count,
-                            basevertex, baseinstance, index_buffer,
-                            user_buffer_mask, buffers);
+   int buffers_size = util_bitcount(user_buffer_mask) * sizeof(buffers[0]);
+   int cmd_size = sizeof(struct marshal_cmd_DrawElementsUserBuf) +
+                  buffers_size;
+   struct marshal_cmd_DrawElementsUserBuf *cmd;
+
+   cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsUserBuf, cmd_size);
+   cmd->mode = MIN2(mode, 0xffff);
+   cmd->type = MIN2(type, 0xffff);
+   cmd->count = count;
+   cmd->indices = indices;
+   cmd->instance_count = instance_count;
+   cmd->basevertex = basevertex;
+   cmd->baseinstance = baseinstance;
+   cmd->user_buffer_mask = user_buffer_mask;
+   cmd->index_buffer = index_buffer;
+
+   if (user_buffer_mask)
+      memcpy(cmd + 1, buffers, buffers_size);
 }
 
 struct marshal_cmd_MultiDrawElementsUserBuf
-- 
GitLab


From 72c8a5a0d50a6a8748e83f987dfd94ac6835c8ee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 03:58:37 -0500
Subject: [PATCH 14/20] glthread: don't execute Draw and BufferSubData calls if
 the context is lost

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/mesa/main/glthread_bufferobj.c | 1 +
 src/mesa/main/glthread_marshal.h   | 1 +
 src/mesa/main/robustness.c         | 2 ++
 3 files changed, 4 insertions(+)

diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index 34e6ce5a907c..609cb0ffcadf 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -505,6 +505,7 @@ _mesa_marshal_BufferSubData_merged(GLuint target_or_name, GLintptr offset,
     *       the buffer storage, but we don't know the buffer size in glthread.
     */
    if (ctx->Const.AllowGLThreadBufferSubDataOpt &&
+       ctx->CurrentServerDispatch != ctx->ContextLost &&
        data && offset > 0 && size > 0) {
       struct gl_buffer_object *upload_buffer = NULL;
       unsigned upload_offset = 0;
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 1aab57de21c2..6e8ec0e57565 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -148,6 +148,7 @@ _mesa_glthread_update_draw_always_async(struct gl_context *ctx)
    /* Executing erroneous cases will just generate GL_INVALID_OPERATION. */
    ctx->GLThread.draw_always_async =
       ctx->API == API_OPENGL_CORE ||
+      ctx->CurrentServerDispatch == ctx->ContextLost ||
       ctx->GLThread.inside_begin_end ||
       ctx->GLThread.ListMode;
 }
diff --git a/src/mesa/main/robustness.c b/src/mesa/main/robustness.c
index 476dc8d47380..ffbd2fec32d5 100644
--- a/src/mesa/main/robustness.c
+++ b/src/mesa/main/robustness.c
@@ -29,6 +29,7 @@
 #include "macros.h"
 #include "main/dispatch.h" /* for _gloffset_COUNT */
 #include "api_exec_decl.h"
+#include "glthread_marshal.h"
 
 static void GLAPIENTRY
 _context_lost_GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize,
@@ -104,6 +105,7 @@ _mesa_set_context_lost_dispatch(struct gl_context *ctx)
 
    ctx->CurrentServerDispatch = ctx->ContextLost;
    _glapi_set_dispatch(ctx->CurrentServerDispatch);
+   _mesa_glthread_update_draw_always_async(ctx);
 }
 
 /**
-- 
GitLab


From c078591113663b8ac81b0b1bdc7de6074a68080b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 04:08:21 -0500
Subject: [PATCH 15/20] glthread: handle non-VBO uploads for
 glMultiModeDraw{Arrays,Elements}IBM

This was unimplemented, and this implementation matches exactly what we do
in main/draw.c.
---
 src/mapi/glapi/gen/gl_API.xml    |  6 ++---
 src/mesa/main/glthread_draw.c    | 43 ++++++++++++++++++++++++++++++++
 src/mesa/main/glthread_marshal.h | 15 -----------
 3 files changed, 45 insertions(+), 19 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 07589bca753e..db2c44553ab1 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -10974,8 +10974,7 @@
 </category>
 
 <category name="GL_IBM_multimode_draw_arrays" number="200">
-    <function name="MultiModeDrawArraysIBM"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices(ctx)">
+    <function name="MultiModeDrawArraysIBM" marshal="custom">
         <param name="mode" type="const GLenum *" count="primcount"/>
         <param name="first" type="const GLint *" count="primcount"/>
         <param name="count" type="const GLsizei *" count="primcount"/>
@@ -10984,8 +10983,7 @@
         <glx handcode="true" ignore="true"/>
     </function>
 
-    <function name="MultiModeDrawElementsIBM"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices_or_indices(ctx)">
+    <function name="MultiModeDrawElementsIBM" marshal="custom">
         <param name="mode" type="const GLenum *" count="primcount"/>
         <param name="count" type="const GLsizei *" count="primcount"/>
         <param name="type" type="GLenum"/>
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 604146f7ec1d..e308e090b781 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -1182,6 +1182,33 @@ _mesa_marshal_MultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count,
                              buffers);
 }
 
+void GLAPIENTRY
+_mesa_marshal_MultiModeDrawArraysIBM(const GLenum *mode, const GLint *first,
+                                     const GLsizei *count, GLsizei primcount,
+                                     GLint modestride)
+{
+   for (int i = 0 ; i < primcount; i++) {
+      if (count[i] > 0) {
+         GLenum m = *((GLenum *)((GLubyte *)mode + i * modestride));
+         _mesa_marshal_DrawArrays(m, first[i], count[i]);
+      }
+   }
+}
+
+void GLAPIENTRY
+_mesa_marshal_MultiModeDrawElementsIBM(const GLenum *mode,
+                                       const GLsizei *count, GLenum type,
+                                       const GLvoid * const *indices,
+                                       GLsizei primcount, GLint modestride)
+{
+   for (int i = 0 ; i < primcount; i++) {
+      if (count[i] > 0) {
+         GLenum m = *((GLenum *)((GLubyte *)mode + i * modestride));
+         _mesa_marshal_DrawElements(m, count[i], type, indices[i]);
+      }
+   }
+}
+
 void GLAPIENTRY
 _mesa_marshal_DrawArrays(GLenum mode, GLint first, GLsizei count)
 {
@@ -1346,6 +1373,22 @@ _mesa_unmarshal_MultiDrawElementsBaseVertex(struct gl_context *ctx,
    return 0;
 }
 
+uint32_t
+_mesa_unmarshal_MultiModeDrawArraysIBM(struct gl_context *ctx,
+                                       const struct marshal_cmd_MultiModeDrawArraysIBM *cmd)
+{
+   unreachable("should never end up here");
+   return 0;
+}
+
+uint32_t
+_mesa_unmarshal_MultiModeDrawElementsIBM(struct gl_context *ctx,
+                                         const struct marshal_cmd_MultiModeDrawElementsIBM *cmd)
+{
+   unreachable("should never end up here");
+   return 0;
+}
+
 void GLAPIENTRY
 _mesa_marshal_DrawArraysUserBuf(void)
 {
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 6e8ec0e57565..25c6641f5c9d 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -94,21 +94,6 @@ _mesa_glthread_has_no_unpack_buffer(const struct gl_context *ctx)
    return ctx->GLThread.CurrentPixelUnpackBufferName == 0;
 }
 
-/**
- * Instead of conditionally handling marshaling immediate index data in draw
- * calls (deprecated and removed in GL core), we just disable threading.
- */
-static inline bool
-_mesa_glthread_has_non_vbo_vertices_or_indices(const struct gl_context *ctx)
-{
-   const struct glthread_state *glthread = &ctx->GLThread;
-   struct glthread_vao *vao = glthread->CurrentVAO;
-
-   return ctx->API != API_OPENGL_CORE &&
-          (vao->CurrentElementBufferName == 0 ||
-           (vao->UserPointerMask & vao->BufferEnabled));
-}
-
 static inline bool
 _mesa_glthread_has_non_vbo_vertices(const struct gl_context *ctx)
 {
-- 
GitLab


From b03fdd18cf084db3d0a412277418eb0279a0d0e3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 09:48:02 -0500
Subject: [PATCH 16/20] glthread: add API to allow passing DrawID from glthread
 to mesa

This will be needed for lowering DrawIndirect in glthread, which is
needed if non-VBO vertex arrays are present.

This only adds the drawid parameter in glthread's draw_arrays and
draw_elements functions, and implements where needed.

New GL API functions are added because we want to use separate
DISPATCH_CMD_* enums for draws with DrawID, so that we don't increase
the memory footprint of draws in glthread batches if drawid == 0.
---
 src/mapi/glapi/gen/gl_API.xml     |   8 ++
 src/mapi/glapi/gen/static_data.py |   2 +
 src/mesa/main/draw.c              |   4 +-
 src/mesa/main/glthread_draw.c     | 170 ++++++++++++++++++++++++++----
 src/mesa/main/mtypes.h            |   3 +
 5 files changed, 163 insertions(+), 24 deletions(-)

diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index db2c44553ab1..f1c4f4e7ac49 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -12964,6 +12964,14 @@
         <param name="primcount" type="GLsizei"/>
         <param name="basevertex" type="const GLint *" count="primcount"/>
     </function>
+
+    <function name="DrawArraysInstancedBaseInstanceDrawID" es1="1.0" es2="2.0"
+              marshal="custom">
+    </function>
+
+    <function name="DrawElementsInstancedBaseVertexBaseInstanceDrawID"
+              es1="1.0" es2="2.0" marshal="custom">
+    </function>
 </category>
 
 <xi:include href="OES_EGL_image.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
diff --git a/src/mapi/glapi/gen/static_data.py b/src/mapi/glapi/gen/static_data.py
index adddef3f3db3..a98f901bcc83 100644
--- a/src/mapi/glapi/gen/static_data.py
+++ b/src/mapi/glapi/gen/static_data.py
@@ -1701,6 +1701,8 @@ offsets = {
     "DrawElementsUserBuf": 1665,
     "MultiDrawArraysUserBuf": 1666,
     "MultiDrawElementsUserBuf": 1667,
+    "DrawArraysInstancedBaseInstanceDrawID": 1668,
+    "DrawElementsInstancedBaseVertexBaseInstanceDrawID": 1669,
 }
 
 functions = [
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 28eeab8e9d4c..dbe235b9e6d5 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -1200,7 +1200,7 @@ _mesa_draw_arrays(struct gl_context *ctx, GLenum mode, GLint start,
    draw.start = start;
    draw.count = count;
 
-   ctx->Driver.DrawGallium(ctx, &info, 0, &draw, 1);
+   ctx->Driver.DrawGallium(ctx, &info, ctx->DrawID, &draw, 1);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
       _mesa_flush(ctx);
@@ -1694,7 +1694,7 @@ _mesa_validated_drawrangeelements(struct gl_context *ctx,
     * for the latter case elsewhere.
     */
 
-   ctx->Driver.DrawGallium(ctx, &info, 0, &draw, 1);
+   ctx->Driver.DrawGallium(ctx, &info, ctx->DrawID, &draw, 1);
 
    if (MESA_DEBUG_FLAGS & DEBUG_ALWAYS_FLUSH) {
       _mesa_flush(ctx);
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index e308e090b781..42cb0176fb0c 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -332,6 +332,38 @@ _mesa_unmarshal_DrawArraysInstancedBaseInstance(struct gl_context *ctx,
    return cmd_size;
 }
 
+struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum mode;
+   GLint first;
+   GLsizei count;
+   GLsizei instance_count;
+   GLuint baseinstance;
+   GLuint drawid;
+};
+
+uint32_t
+_mesa_unmarshal_DrawArraysInstancedBaseInstanceDrawID(struct gl_context *ctx,
+                                                const struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID *cmd)
+{
+   const GLenum mode = cmd->mode;
+   const GLint first = cmd->first;
+   const GLsizei count = cmd->count;
+   const GLsizei instance_count = cmd->instance_count;
+   const GLuint baseinstance = cmd->baseinstance;
+
+   ctx->DrawID = cmd->drawid;
+   CALL_DrawArraysInstancedBaseInstance(ctx->CurrentServerDispatch,
+                                        (mode, first, count, instance_count,
+                                         baseinstance));
+   ctx->DrawID = 0;
+
+   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
 /* DrawArraysInstancedBaseInstance with user buffers. */
 struct marshal_cmd_DrawArraysUserBuf
 {
@@ -341,6 +373,7 @@ struct marshal_cmd_DrawArraysUserBuf
    GLsizei count;
    GLsizei instance_count;
    GLuint baseinstance;
+   GLuint drawid;
    GLuint user_buffer_mask;
 };
 
@@ -364,9 +397,11 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
    const GLsizei instance_count = cmd->instance_count;
    const GLuint baseinstance = cmd->baseinstance;
 
+   ctx->DrawID = cmd->drawid;
    CALL_DrawArraysInstancedBaseInstance(ctx->CurrentServerDispatch,
                                         (mode, first, count, instance_count,
                                          baseinstance));
+   ctx->DrawID = 0;
 
    /* Restore states. */
    if (user_buffer_mask) {
@@ -377,8 +412,9 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
 }
 
 static ALWAYS_INLINE void
-draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
-            GLuint baseinstance, bool compiled_into_dlist)
+draw_arrays(GLuint drawid, GLenum mode, GLint first, GLsizei count,
+            GLsizei instance_count, GLuint baseinstance,
+            bool compiled_into_dlist)
 {
    GET_CURRENT_CONTEXT(ctx);
 
@@ -399,7 +435,7 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
     */
    if (ctx->GLThread.draw_always_async ||
        !user_buffer_mask || count <= 0 || instance_count <= 0) {
-      if (instance_count == 1 && baseinstance == 0) {
+      if (instance_count == 1 && baseinstance == 0 && drawid == 0) {
          int cmd_size = sizeof(struct marshal_cmd_DrawArrays);
          struct marshal_cmd_DrawArrays *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArrays, cmd_size);
@@ -407,7 +443,7 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
          cmd->mode = mode;
          cmd->first = first;
          cmd->count = count;
-      } else {
+      } else if (drawid == 0) {
          int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstancedBaseInstance);
          struct marshal_cmd_DrawArraysInstancedBaseInstance *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstance, cmd_size);
@@ -417,6 +453,17 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
          cmd->count = count;
          cmd->instance_count = instance_count;
          cmd->baseinstance = baseinstance;
+      } else {
+         int cmd_size = sizeof(struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID);
+         struct marshal_cmd_DrawArraysInstancedBaseInstanceDrawID *cmd =
+            _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysInstancedBaseInstanceDrawID, cmd_size);
+
+         cmd->mode = mode;
+         cmd->first = first;
+         cmd->count = count;
+         cmd->instance_count = instance_count;
+         cmd->baseinstance = baseinstance;
+         cmd->drawid = drawid;
       }
       return;
    }
@@ -440,6 +487,7 @@ draw_arrays(GLenum mode, GLint first, GLsizei count, GLsizei instance_count,
    cmd->count = count;
    cmd->instance_count = instance_count;
    cmd->baseinstance = baseinstance;
+   cmd->drawid = drawid;
    cmd->user_buffer_mask = user_buffer_mask;
 
    if (user_buffer_mask)
@@ -676,6 +724,43 @@ _mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstance(struct gl_context *c
    return cmd_size;
 }
 
+struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   GLenum16 type;
+   GLsizei count;
+   GLsizei instance_count;
+   GLint basevertex;
+   GLuint baseinstance;
+   GLuint drawid;
+   const GLvoid *indices;
+};
+
+uint32_t
+_mesa_unmarshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(struct gl_context *ctx,
+                                                                  const struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID *cmd)
+{
+   const GLenum mode = cmd->mode;
+   const GLsizei count = cmd->count;
+   const GLenum type = cmd->type;
+   const GLvoid *indices = cmd->indices;
+   const GLsizei instance_count = cmd->instance_count;
+   const GLint basevertex = cmd->basevertex;
+   const GLuint baseinstance = cmd->baseinstance;
+
+   ctx->DrawID = cmd->drawid;
+   CALL_DrawElementsInstancedBaseVertexBaseInstance(ctx->CurrentServerDispatch,
+                                                    (mode, count, type, indices,
+                                                     instance_count, basevertex,
+                                                     baseinstance));
+   ctx->DrawID = 0;
+
+   const unsigned cmd_size = align(sizeof(*cmd), 8) / 8;
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
 struct marshal_cmd_DrawElementsUserBuf
 {
    struct marshal_cmd_base cmd_base;
@@ -685,6 +770,7 @@ struct marshal_cmd_DrawElementsUserBuf
    GLsizei instance_count;
    GLint basevertex;
    GLuint baseinstance;
+   GLuint drawid;
    GLuint user_buffer_mask;
    const GLvoid *indices;
    struct gl_buffer_object *index_buffer;
@@ -714,10 +800,12 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
    const GLuint baseinstance = cmd->baseinstance;
    struct gl_buffer_object *index_buffer = cmd->index_buffer;
 
+   ctx->DrawID = cmd->drawid;
    CALL_DrawElementsUserBuf(ctx->CurrentServerDispatch,
                             ((GLintptr)index_buffer, mode, count, type,
                              indices, instance_count, basevertex,
                              baseinstance));
+   ctx->DrawID = 0;
    _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
 
    /* Restore states. */
@@ -746,10 +834,10 @@ should_convert_to_begin_end(struct gl_context *ctx, unsigned count,
 }
 
 static void
-draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
-              GLsizei instance_count, GLint basevertex, GLuint baseinstance,
-              bool index_bounds_valid, GLuint min_index, GLuint max_index,
-              bool compiled_into_dlist)
+draw_elements(GLuint drawid, GLenum mode, GLsizei count, GLenum type,
+              const GLvoid *indices, GLsizei instance_count, GLint basevertex,
+              GLuint baseinstance, bool index_bounds_valid, GLuint min_index,
+              GLuint max_index, bool compiled_into_dlist)
 {
    GET_CURRENT_CONTEXT(ctx);
 
@@ -786,7 +874,7 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    if (ctx->GLThread.draw_always_async || count <= 0 || instance_count <= 0 ||
        !is_index_type_valid(type) ||
        (!user_buffer_mask && !has_user_indices)) {
-      if (instance_count == 1 && baseinstance == 0) {
+      if (instance_count == 1 && baseinstance == 0 && drawid == 0) {
          int cmd_size = sizeof(struct marshal_cmd_DrawElementsBaseVertex);
          struct marshal_cmd_DrawElementsBaseVertex *cmd =
             _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsBaseVertex, cmd_size);
@@ -797,7 +885,7 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
          cmd->indices = indices;
          cmd->basevertex = basevertex;
       } else {
-         if (basevertex == 0 && baseinstance == 0) {
+         if (basevertex == 0 && baseinstance == 0 && drawid == 0) {
             int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstanced);
             struct marshal_cmd_DrawElementsInstanced *cmd =
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstanced, cmd_size);
@@ -807,7 +895,7 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
             cmd->count = count;
             cmd->instance_count = instance_count;
             cmd->indices = indices;
-         } else {
+         } else if (drawid == 0) {
             int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance);
             struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstance *cmd =
                _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstance, cmd_size);
@@ -819,6 +907,19 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
             cmd->basevertex = basevertex;
             cmd->baseinstance = baseinstance;
             cmd->indices = indices;
+         } else {
+            int cmd_size = sizeof(struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID);
+            struct marshal_cmd_DrawElementsInstancedBaseVertexBaseInstanceDrawID *cmd =
+               _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsInstancedBaseVertexBaseInstanceDrawID, cmd_size);
+
+            cmd->mode = MIN2(mode, 0xffff);
+            cmd->type = MIN2(type, 0xffff);
+            cmd->count = count;
+            cmd->instance_count = instance_count;
+            cmd->basevertex = basevertex;
+            cmd->baseinstance = baseinstance;
+            cmd->drawid = drawid;
+            cmd->indices = indices;
          }
       }
       return;
@@ -897,6 +998,7 @@ draw_elements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices,
    cmd->baseinstance = baseinstance;
    cmd->user_buffer_mask = user_buffer_mask;
    cmd->index_buffer = index_buffer;
+   cmd->drawid = drawid;
 
    if (user_buffer_mask)
       memcpy(cmd + 1, buffers, buffers_size);
@@ -1212,14 +1314,14 @@ _mesa_marshal_MultiModeDrawElementsIBM(const GLenum *mode,
 void GLAPIENTRY
 _mesa_marshal_DrawArrays(GLenum mode, GLint first, GLsizei count)
 {
-   draw_arrays(mode, first, count, 1, 0, true);
+   draw_arrays(0, mode, first, count, 1, 0, true);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawArraysInstanced(GLenum mode, GLint first, GLsizei count,
                                   GLsizei instance_count)
 {
-   draw_arrays(mode, first, count, instance_count, 0, false);
+   draw_arrays(0, mode, first, count, instance_count, 0, false);
 }
 
 void GLAPIENTRY
@@ -1227,14 +1329,14 @@ _mesa_marshal_DrawArraysInstancedBaseInstance(GLenum mode, GLint first,
                                               GLsizei count, GLsizei instance_count,
                                               GLuint baseinstance)
 {
-   draw_arrays(mode, first, count, instance_count, baseinstance, false);
+   draw_arrays(0, mode, first, count, instance_count, baseinstance, false);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElements(GLenum mode, GLsizei count, GLenum type,
                            const GLvoid *indices)
 {
-   draw_elements(mode, count, type, indices, 1, 0, 0, false, 0, 0, true);
+   draw_elements(0, mode, count, type, indices, 1, 0, 0, false, 0, 0, true);
 }
 
 void GLAPIENTRY
@@ -1242,21 +1344,21 @@ _mesa_marshal_DrawRangeElements(GLenum mode, GLuint start, GLuint end,
                                 GLsizei count, GLenum type,
                                 const GLvoid *indices)
 {
-   draw_elements(mode, count, type, indices, 1, 0, 0, true, start, end, true);
+   draw_elements(0, mode, count, type, indices, 1, 0, 0, true, start, end, true);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElementsInstanced(GLenum mode, GLsizei count, GLenum type,
                                     const GLvoid *indices, GLsizei instance_count)
 {
-   draw_elements(mode, count, type, indices, instance_count, 0, 0, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, 0, 0, false, 0, 0, false);
 }
 
 void GLAPIENTRY
 _mesa_marshal_DrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type,
                                      const GLvoid *indices, GLint basevertex)
 {
-   draw_elements(mode, count, type, indices, 1, basevertex, 0, false, 0, 0, true);
+   draw_elements(0, mode, count, type, indices, 1, basevertex, 0, false, 0, 0, true);
 }
 
 void GLAPIENTRY
@@ -1264,7 +1366,7 @@ _mesa_marshal_DrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end,
                                           GLsizei count, GLenum type,
                                           const GLvoid *indices, GLint basevertex)
 {
-   draw_elements(mode, count, type, indices, 1, basevertex, 0, true, start, end, true);
+   draw_elements(0, mode, count, type, indices, 1, basevertex, 0, true, start, end, true);
 }
 
 void GLAPIENTRY
@@ -1272,7 +1374,7 @@ _mesa_marshal_DrawElementsInstancedBaseVertex(GLenum mode, GLsizei count,
                                               GLenum type, const GLvoid *indices,
                                               GLsizei instance_count, GLint basevertex)
 {
-   draw_elements(mode, count, type, indices, instance_count, basevertex, 0, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, basevertex, 0, false, 0, 0, false);
 }
 
 void GLAPIENTRY
@@ -1280,7 +1382,7 @@ _mesa_marshal_DrawElementsInstancedBaseInstance(GLenum mode, GLsizei count,
                                                 GLenum type, const GLvoid *indices,
                                                 GLsizei instance_count, GLuint baseinstance)
 {
-   draw_elements(mode, count, type, indices, instance_count, 0, baseinstance, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, 0, baseinstance, false, 0, 0, false);
 }
 
 void GLAPIENTRY
@@ -1289,7 +1391,7 @@ _mesa_marshal_DrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei c
                                                           GLsizei instance_count, GLint basevertex,
                                                           GLuint baseinstance)
 {
-   draw_elements(mode, count, type, indices, instance_count, basevertex, baseinstance, false, 0, 0, false);
+   draw_elements(0, mode, count, type, indices, instance_count, basevertex, baseinstance, false, 0, 0, false);
 }
 
 void GLAPIENTRY
@@ -1420,6 +1522,18 @@ _mesa_marshal_MultiDrawElementsUserBuf(GLintptr indexBuf, GLenum mode,
    unreachable("should never end up here");
 }
 
+void GLAPIENTRY
+_mesa_marshal_DrawArraysInstancedBaseInstanceDrawID(void)
+{
+   unreachable("should never end up here");
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsInstancedBaseVertexBaseInstanceDrawID(void)
+{
+   unreachable("should never end up here");
+}
+
 void GLAPIENTRY
 _mesa_DrawArraysUserBuf(void)
 {
@@ -1431,3 +1545,15 @@ _mesa_MultiDrawArraysUserBuf(void)
 {
    unreachable("should never end up here");
 }
+
+void GLAPIENTRY
+_mesa_DrawArraysInstancedBaseInstanceDrawID(void)
+{
+   unreachable("should never end up here");
+}
+
+void GLAPIENTRY
+_mesa_DrawElementsInstancedBaseVertexBaseInstanceDrawID(void)
+{
+   unreachable("should never end up here");
+}
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 80ce5f903093..e8fbb5a79375 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3295,6 +3295,9 @@ struct gl_context
     */
    GLbitfield ValidPrimMaskIndexed;
 
+   /** DrawID for the next non-multi non-indirect draw. Only set by glthread. */
+   GLuint DrawID;
+
    /**
     * Whether DrawPixels/CopyPixels/Bitmap are valid to render.
     */
-- 
GitLab


From c716dedb5e918c8232aa8cd334c189e7aaba014d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 26 Dec 2022 09:53:28 -0500
Subject: [PATCH 17/20] glthread: convert (Multi)DrawIndirect into direct if
 user buffers are present

so that user buffers are uploaded without syncing.

Now glthread fully handles non-VBO uploads, so that we can disable user
buffer codepaths in st/mesa.
---
 src/mapi/glapi/gen/ARB_draw_indirect.xml      |  14 +-
 .../glapi/gen/ARB_indirect_parameters.xml     |   6 +-
 src/mesa/main/glthread_draw.c                 | 420 ++++++++++++++++++
 src/mesa/main/glthread_marshal.h              |  33 --
 4 files changed, 426 insertions(+), 47 deletions(-)

diff --git a/src/mapi/glapi/gen/ARB_draw_indirect.xml b/src/mapi/glapi/gen/ARB_draw_indirect.xml
index feb6588de356..398720e0b196 100644
--- a/src/mapi/glapi/gen/ARB_draw_indirect.xml
+++ b/src/mapi/glapi/gen/ARB_draw_indirect.xml
@@ -8,16 +8,12 @@
     <enum name="DRAW_INDIRECT_BUFFER"                   value="0x8F3F"/>
     <enum name="DRAW_INDIRECT_BUFFER_BINDING"           value="0x8F43"/>
 
-    <function name="DrawArraysIndirect" es2="3.1" exec="dlist"
-              marshal="async"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices_or_indirect(ctx)">
+    <function name="DrawArraysIndirect" es2="3.1" exec="dlist" marshal="custom">
         <param name="mode" type="GLenum"/>
         <param name="indirect" type="const GLvoid *"/>
     </function>
 
-    <function name="DrawElementsIndirect" es2="3.1" exec="dlist"
-              marshal="async"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices_or_indices_or_indirect(ctx)">
+    <function name="DrawElementsIndirect" es2="3.1" exec="dlist" marshal="custom">
         <param name="mode" type="GLenum"/>
         <param name="type" type="GLenum"/>
         <param name="indirect" type="const GLvoid *"/>
@@ -28,16 +24,14 @@
 
 <category name="GL_ARB_multi_draw_indirect" number="133">
 
-    <function name="MultiDrawArraysIndirect" marshal="async" exec="dlist"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices_or_indirect(ctx)">
+    <function name="MultiDrawArraysIndirect" marshal="custom" exec="dlist">
         <param name="mode" type="GLenum"/>
         <param name="indirect" type="const GLvoid *"/>
         <param name="primcount" type="GLsizei"/>
         <param name="stride" type="GLsizei"/>
     </function>
 
-    <function name="MultiDrawElementsIndirect" marshal="async" exec="dlist"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices_or_indices_or_indirect(ctx)">
+    <function name="MultiDrawElementsIndirect" marshal="custom" exec="dlist">
         <param name="mode" type="GLenum"/>
         <param name="type" type="GLenum"/>
         <param name="indirect" type="const GLvoid *"/>
diff --git a/src/mapi/glapi/gen/ARB_indirect_parameters.xml b/src/mapi/glapi/gen/ARB_indirect_parameters.xml
index f08201d4a221..89250abab1d5 100644
--- a/src/mapi/glapi/gen/ARB_indirect_parameters.xml
+++ b/src/mapi/glapi/gen/ARB_indirect_parameters.xml
@@ -8,8 +8,7 @@
     <enum name="PARAMETER_BUFFER_ARB"                   value="0x80EE"/>
     <enum name="PARAMETER_BUFFER_BINDING_ARB"           value="0x80EF"/>
 
-    <function name="MultiDrawArraysIndirectCountARB"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices(ctx)">
+    <function name="MultiDrawArraysIndirectCountARB" marshal="custom">
         <param name="mode" type="GLenum"/>
         <param name="indirect" type="GLintptr"/>
         <param name="drawcount" type="GLintptr"/>
@@ -18,8 +17,7 @@
     </function>
 
     <!-- Use "...has_non_vbo_vertices", because indices always come from a buffer object. -->
-    <function name="MultiDrawElementsIndirectCountARB"
-              marshal_sync="_mesa_glthread_has_non_vbo_vertices(ctx)">
+    <function name="MultiDrawElementsIndirectCountARB" marshal="custom">
         <param name="mode" type="GLenum"/>
         <param name="type" type="GLenum"/>
         <param name="indirect" type="GLintptr"/>
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 42cb0176fb0c..ac825d3da8b7 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -1311,6 +1311,426 @@ _mesa_marshal_MultiModeDrawElementsIBM(const GLenum *mode,
    }
 }
 
+static const void *
+map_draw_indirect_params(struct gl_context *ctx, GLintptr offset,
+                         unsigned count, unsigned stride)
+{
+   struct gl_buffer_object *obj = ctx->DrawIndirectBuffer;
+
+   if (!obj)
+      return (void*)offset;
+
+   return _mesa_bufferobj_map_range(ctx, offset,
+                                    MIN2((size_t)count * stride, obj->Size),
+                                    GL_MAP_READ_BIT, obj, MAP_INTERNAL);
+}
+
+static void
+unmap_draw_indirect_params(struct gl_context *ctx)
+{
+   if (ctx->DrawIndirectBuffer)
+      _mesa_bufferobj_unmap(ctx, ctx->DrawIndirectBuffer, MAP_INTERNAL);
+}
+
+static unsigned
+read_draw_indirect_count(struct gl_context *ctx, GLintptr offset)
+{
+   unsigned result = 0;
+
+   if (ctx->ParameterBuffer) {
+      _mesa_bufferobj_get_subdata(ctx, offset, sizeof(result), &result,
+                                  ctx->ParameterBuffer);
+   }
+   return result;
+}
+
+static void
+lower_draw_arrays_indirect(struct gl_context *ctx, GLenum mode,
+                           GLintptr indirect, GLsizei stride,
+                           unsigned draw_count)
+{
+   /* If <stride> is zero, the elements are tightly packed. */
+   if (stride == 0)
+      stride = 4 * sizeof(GLuint);      /* sizeof(DrawArraysIndirectCommand) */
+
+   const uint32_t *params =
+      map_draw_indirect_params(ctx, indirect, draw_count, stride);
+
+   for (unsigned i = 0; i < draw_count; i++) {
+      draw_arrays(i, mode,
+                  params[i * stride / 4 + 2],
+                  params[i * stride / 4 + 0],
+                  params[i * stride / 4 + 1],
+                  params[i * stride / 4 + 3], false);
+   }
+
+   unmap_draw_indirect_params(ctx);
+}
+
+static void
+lower_draw_elements_indirect(struct gl_context *ctx, GLenum mode, GLenum type,
+                             GLintptr indirect, GLsizei stride,
+                             unsigned draw_count)
+{
+   /* If <stride> is zero, the elements are tightly packed. */
+   if (stride == 0)
+      stride = 5 * sizeof(GLuint);      /* sizeof(DrawArraysIndirectCommand) */
+
+   const uint32_t *params =
+      map_draw_indirect_params(ctx, indirect, draw_count, stride);
+
+   for (unsigned i = 0; i < draw_count; i++) {
+      draw_elements(i, mode,
+                    params[i * stride / 4 + 0],
+                    type,
+                    (GLvoid*)((uintptr_t)params[i * stride / 4 + 2] *
+                              get_index_size(type)),
+                    params[i * stride / 4 + 1],
+                    params[i * stride / 4 + 3],
+                    params[i * stride / 4 + 4],
+                    false, 0, 0, false);
+   }
+   unmap_draw_indirect_params(ctx);
+}
+
+struct marshal_cmd_DrawArraysIndirect
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   const GLvoid * indirect;
+};
+
+uint32_t
+_mesa_unmarshal_DrawArraysIndirect(struct gl_context *ctx,
+                                   const struct marshal_cmd_DrawArraysIndirect *cmd)
+{
+   GLenum mode = cmd->mode;
+   const GLvoid * indirect = cmd->indirect;
+
+   CALL_DrawArraysIndirect(ctx->CurrentServerDispatch, (mode, indirect));
+
+   const unsigned cmd_size =
+      (align(sizeof(struct marshal_cmd_DrawArraysIndirect), 8) / 8);
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawArraysIndirect(GLenum mode, const GLvoid *indirect)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask =
+      _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+
+   if (ctx->GLThread.draw_always_async ||
+       !ctx->GLThread.CurrentDrawIndirectBufferName ||
+       !user_buffer_mask) {
+      int cmd_size = sizeof(struct marshal_cmd_DrawArraysIndirect);
+      struct marshal_cmd_DrawArraysIndirect *cmd;
+
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawArraysIndirect, cmd_size);
+      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->indirect = indirect;
+      return;
+   }
+
+   _mesa_glthread_finish_before(ctx, "DrawArraysIndirect");
+   lower_draw_arrays_indirect(ctx, mode, (GLintptr)indirect, 0, 1);
+}
+
+struct marshal_cmd_DrawElementsIndirect
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   GLenum16 type;
+   const GLvoid * indirect;
+};
+
+uint32_t
+_mesa_unmarshal_DrawElementsIndirect(struct gl_context *ctx,
+                                     const struct marshal_cmd_DrawElementsIndirect *cmd)
+{
+   GLenum mode = cmd->mode;
+   GLenum type = cmd->type;
+   const GLvoid * indirect = cmd->indirect;
+
+   CALL_DrawElementsIndirect(ctx->CurrentServerDispatch, (mode, type, indirect));
+
+   const unsigned cmd_size =
+      (align(sizeof(struct marshal_cmd_DrawElementsIndirect), 8) / 8);
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
+void GLAPIENTRY
+_mesa_marshal_DrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask =
+      _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+
+   if (ctx->GLThread.draw_always_async || !is_index_type_valid(type) ||
+       !ctx->GLThread.CurrentDrawIndirectBufferName ||
+       !vao->CurrentElementBufferName || !user_buffer_mask) {
+      int cmd_size = sizeof(struct marshal_cmd_DrawElementsIndirect);
+      struct marshal_cmd_DrawElementsIndirect *cmd;
+
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_DrawElementsIndirect, cmd_size);
+      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->indirect = indirect;
+      return;
+   }
+
+   _mesa_glthread_finish_before(ctx, "DrawElementsIndirect");
+   lower_draw_elements_indirect(ctx, mode, type, (GLintptr)indirect, 0, 1);
+}
+
+struct marshal_cmd_MultiDrawArraysIndirect
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   GLsizei primcount;
+   GLsizei stride;
+   const GLvoid * indirect;
+};
+
+uint32_t
+_mesa_unmarshal_MultiDrawArraysIndirect(struct gl_context *ctx,
+                                        const struct marshal_cmd_MultiDrawArraysIndirect *cmd)
+{
+   GLenum mode = cmd->mode;
+   const GLvoid * indirect = cmd->indirect;
+   GLsizei primcount = cmd->primcount;
+   GLsizei stride = cmd->stride;
+
+   CALL_MultiDrawArraysIndirect(ctx->CurrentServerDispatch,
+                                (mode, indirect, primcount, stride));
+
+   const unsigned cmd_size =
+      (align(sizeof(struct marshal_cmd_MultiDrawArraysIndirect), 8) / 8);
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
+void GLAPIENTRY
+_mesa_marshal_MultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect,
+                                      GLsizei primcount, GLsizei stride)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask =
+      _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+
+   if (ctx->GLThread.draw_always_async ||
+       !ctx->GLThread.CurrentDrawIndirectBufferName ||
+       !user_buffer_mask) {
+      int cmd_size = sizeof(struct marshal_cmd_MultiDrawArraysIndirect);
+      struct marshal_cmd_MultiDrawArraysIndirect *cmd;
+
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysIndirect,
+                                            cmd_size);
+      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->indirect = indirect;
+      cmd->primcount = primcount;
+      cmd->stride = stride;
+      return;
+   }
+
+   /* Lower the draw to direct due to non-VBO vertex arrays. */
+   _mesa_glthread_finish_before(ctx, "MultiDrawArraysIndirect");
+   lower_draw_arrays_indirect(ctx, mode, (GLintptr)indirect, stride, primcount);
+}
+
+struct marshal_cmd_MultiDrawElementsIndirect
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   GLenum16 type;
+   GLsizei primcount;
+   GLsizei stride;
+   const GLvoid * indirect;
+};
+
+uint32_t
+_mesa_unmarshal_MultiDrawElementsIndirect(struct gl_context *ctx,
+                                          const struct marshal_cmd_MultiDrawElementsIndirect *cmd)
+{
+   GLenum mode = cmd->mode;
+   GLenum type = cmd->type;
+   const GLvoid * indirect = cmd->indirect;
+   GLsizei primcount = cmd->primcount;
+   GLsizei stride = cmd->stride;
+
+   CALL_MultiDrawElementsIndirect(ctx->CurrentServerDispatch,
+                                  (mode, type, indirect, primcount, stride));
+
+   const unsigned cmd_size =
+      (align(sizeof(struct marshal_cmd_MultiDrawElementsIndirect), 8) / 8);
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
+void GLAPIENTRY
+_mesa_marshal_MultiDrawElementsIndirect(GLenum mode, GLenum type,
+                                        const GLvoid *indirect,
+                                        GLsizei primcount, GLsizei stride)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask =
+      _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+
+   if (ctx->GLThread.draw_always_async || !is_index_type_valid(type) ||
+       !ctx->GLThread.CurrentDrawIndirectBufferName ||
+       !vao->CurrentElementBufferName || !user_buffer_mask) {
+      int cmd_size = sizeof(struct marshal_cmd_MultiDrawElementsIndirect);
+      struct marshal_cmd_MultiDrawElementsIndirect *cmd;
+
+      cmd = _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirect,
+                                            cmd_size);
+      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->indirect = indirect;
+      cmd->primcount = primcount;
+      cmd->stride = stride;
+      return;
+   }
+
+   /* Lower the draw to direct due to non-VBO vertex arrays. */
+   _mesa_glthread_finish_before(ctx, "MultiDrawElementsIndirect");
+   lower_draw_elements_indirect(ctx, mode, type, (GLintptr)indirect, stride,
+                                primcount);
+}
+
+struct marshal_cmd_MultiDrawArraysIndirectCountARB
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   GLsizei maxdrawcount;
+   GLsizei stride;
+   GLintptr indirect;
+   GLintptr drawcount;
+};
+
+uint32_t
+_mesa_unmarshal_MultiDrawArraysIndirectCountARB(struct gl_context *ctx,
+                                                const struct marshal_cmd_MultiDrawArraysIndirectCountARB *cmd)
+{
+   GLenum mode = cmd->mode;
+   GLintptr indirect = cmd->indirect;
+   GLintptr drawcount = cmd->drawcount;
+   GLsizei maxdrawcount = cmd->maxdrawcount;
+   GLsizei stride = cmd->stride;
+
+   CALL_MultiDrawArraysIndirectCountARB(ctx->CurrentServerDispatch,
+                                        (mode, indirect, drawcount,
+                                         maxdrawcount, stride));
+
+   const unsigned cmd_size =
+      (align(sizeof(struct marshal_cmd_MultiDrawArraysIndirectCountARB), 8) / 8);
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
+void GLAPIENTRY
+_mesa_marshal_MultiDrawArraysIndirectCountARB(GLenum mode, GLintptr indirect,
+                                              GLintptr drawcount,
+                                              GLsizei maxdrawcount,
+                                              GLsizei stride)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask =
+      _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+
+   if (ctx->GLThread.draw_always_async || !user_buffer_mask ||
+       !ctx->GLThread.CurrentDrawIndirectBufferName) {
+      int cmd_size =
+         sizeof(struct marshal_cmd_MultiDrawArraysIndirectCountARB);
+      struct marshal_cmd_MultiDrawArraysIndirectCountARB *cmd =
+         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawArraysIndirectCountARB,
+                                         cmd_size);
+
+      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->indirect = indirect;
+      cmd->drawcount = drawcount;
+      cmd->maxdrawcount = maxdrawcount;
+      cmd->stride = stride;
+      return;
+   }
+
+   /* Lower the draw to direct due to non-VBO vertex arrays. */
+   _mesa_glthread_finish_before(ctx, "MultiDrawArraysIndirectCountARB");
+   lower_draw_arrays_indirect(ctx, mode, indirect, stride,
+                              read_draw_indirect_count(ctx, drawcount));
+}
+
+struct marshal_cmd_MultiDrawElementsIndirectCountARB
+{
+   struct marshal_cmd_base cmd_base;
+   GLenum16 mode;
+   GLenum16 type;
+   GLsizei maxdrawcount;
+   GLsizei stride;
+   GLintptr indirect;
+   GLintptr drawcount;
+};
+
+uint32_t
+_mesa_unmarshal_MultiDrawElementsIndirectCountARB(struct gl_context *ctx,
+                                                  const struct marshal_cmd_MultiDrawElementsIndirectCountARB *cmd)
+{
+   GLenum mode = cmd->mode;
+   GLenum type = cmd->type;
+   GLintptr indirect = cmd->indirect;
+   GLintptr drawcount = cmd->drawcount;
+   GLsizei maxdrawcount = cmd->maxdrawcount;
+   GLsizei stride = cmd->stride;
+
+   CALL_MultiDrawElementsIndirectCountARB(ctx->CurrentServerDispatch, (mode, type, indirect, drawcount, maxdrawcount, stride));
+
+   const unsigned cmd_size = (align(sizeof(struct marshal_cmd_MultiDrawElementsIndirectCountARB), 8) / 8);
+   assert(cmd_size == cmd->cmd_base.cmd_size);
+   return cmd_size;
+}
+
+void GLAPIENTRY
+_mesa_marshal_MultiDrawElementsIndirectCountARB(GLenum mode, GLenum type,
+                                                GLintptr indirect,
+                                                GLintptr drawcount,
+                                                GLsizei maxdrawcount,
+                                                GLsizei stride)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct glthread_vao *vao = ctx->GLThread.CurrentVAO;
+   unsigned user_buffer_mask =
+      _mesa_is_gles31(ctx) ? 0 : vao->UserPointerMask & vao->BufferEnabled;
+
+   if (ctx->GLThread.draw_always_async || !user_buffer_mask ||
+       !ctx->GLThread.CurrentDrawIndirectBufferName ||
+       !is_index_type_valid(type)) {
+      int cmd_size = sizeof(struct marshal_cmd_MultiDrawElementsIndirectCountARB);
+      struct marshal_cmd_MultiDrawElementsIndirectCountARB *cmd =
+         _mesa_glthread_allocate_command(ctx, DISPATCH_CMD_MultiDrawElementsIndirectCountARB, cmd_size);
+
+      cmd->mode = MIN2(mode, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->type = MIN2(type, 0xffff); /* clamped to 0xffff (invalid enum) */
+      cmd->indirect = indirect;
+      cmd->drawcount = drawcount;
+      cmd->maxdrawcount = maxdrawcount;
+      cmd->stride = stride;
+      return;
+   }
+
+   /* Lower the draw to direct due to non-VBO vertex arrays. */
+   _mesa_glthread_finish_before(ctx, "MultiDrawElementsIndirectCountARB");
+   lower_draw_elements_indirect(ctx, mode, type, indirect, stride,
+                                read_draw_indirect_count(ctx, drawcount));
+}
+
 void GLAPIENTRY
 _mesa_marshal_DrawArrays(GLenum mode, GLint first, GLsizei count)
 {
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 25c6641f5c9d..157bceab6366 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -94,39 +94,6 @@ _mesa_glthread_has_no_unpack_buffer(const struct gl_context *ctx)
    return ctx->GLThread.CurrentPixelUnpackBufferName == 0;
 }
 
-static inline bool
-_mesa_glthread_has_non_vbo_vertices(const struct gl_context *ctx)
-{
-   const struct glthread_state *glthread = &ctx->GLThread;
-   const struct glthread_vao *vao = glthread->CurrentVAO;
-
-   return ctx->API != API_OPENGL_CORE &&
-          (vao->UserPointerMask & vao->BufferEnabled);
-}
-
-static inline bool
-_mesa_glthread_has_non_vbo_vertices_or_indirect(const struct gl_context *ctx)
-{
-   const struct glthread_state *glthread = &ctx->GLThread;
-   const struct glthread_vao *vao = glthread->CurrentVAO;
-
-   return ctx->API != API_OPENGL_CORE &&
-          (glthread->CurrentDrawIndirectBufferName == 0 ||
-           (vao->UserPointerMask & vao->BufferEnabled));
-}
-
-static inline bool
-_mesa_glthread_has_non_vbo_vertices_or_indices_or_indirect(const struct gl_context *ctx)
-{
-   const struct glthread_state *glthread = &ctx->GLThread;
-   struct glthread_vao *vao = glthread->CurrentVAO;
-
-   return ctx->API != API_OPENGL_CORE &&
-          (glthread->CurrentDrawIndirectBufferName == 0 ||
-           vao->CurrentElementBufferName == 0 ||
-           (vao->UserPointerMask & vao->BufferEnabled));
-}
-
 static inline void
 _mesa_glthread_update_draw_always_async(struct gl_context *ctx)
 {
-- 
GitLab


From 439d12742a7cd72ce3594992d5e91e29cc9cff41 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 31 Dec 2022 02:29:15 -0500
Subject: [PATCH 18/20] glthread: remove unnecessary debug code

_mesa_glthread_destroy won't be called for GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB,
so the "reason" parameter will be useless.
---
 src/mesa/main/glthread.c            | 21 ++-------------------
 src/mesa/main/glthread.h            |  2 +-
 src/mesa/main/glthread_marshal.h    |  2 +-
 src/mesa/state_tracker/st_context.c |  2 +-
 4 files changed, 5 insertions(+), 22 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 812fb43f9482..a8c729f4c8f2 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -173,16 +173,13 @@ free_vao(void *data, UNUSED void *userData)
 }
 
 void
-_mesa_glthread_destroy(struct gl_context *ctx, const char *reason)
+_mesa_glthread_destroy(struct gl_context *ctx)
 {
    struct glthread_state *glthread = &ctx->GLThread;
 
    if (!glthread->enabled)
       return;
 
-   if (reason)
-      _mesa_debug(ctx, "glthread destroy reason: %s\n", reason);
-
    _mesa_glthread_finish(ctx);
    util_queue_destroy(&glthread->queue);
 
@@ -210,7 +207,7 @@ _mesa_glthread_flush_batch(struct gl_context *ctx)
       return;
 
    if (ctx->CurrentServerDispatch == ctx->ContextLost) {
-      _mesa_glthread_destroy(ctx, "context lost");
+      _mesa_glthread_destroy(ctx);
       return;
    }
 
@@ -241,20 +238,6 @@ _mesa_glthread_flush_batch(struct gl_context *ctx)
 
    struct glthread_batch *next = glthread->next_batch;
 
-   /* Debug: execute the batch immediately from this thread.
-    *
-    * Note that glthread_unmarshal_batch() changes the dispatch table so we'll
-    * need to restore it when it returns.
-    */
-   if (false) {
-      glthread_unmarshal_batch(next, NULL, 0);
-      _glapi_set_dispatch(ctx->CurrentClientDispatch);
-
-      glthread->LastCallList = NULL;
-      glthread->LastBindBuffer = NULL;
-      return;
-   }
-
    p_atomic_add(&glthread->stats.num_offloaded_items, glthread->used);
    next->used = glthread->used;
 
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index cd71d492f96b..f7601eea75c0 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -276,7 +276,7 @@ struct glthread_state
 };
 
 void _mesa_glthread_init(struct gl_context *ctx);
-void _mesa_glthread_destroy(struct gl_context *ctx, const char *reason);
+void _mesa_glthread_destroy(struct gl_context *ctx);
 
 void _mesa_glthread_init_dispatch0(struct gl_context *ctx,
                                    struct _glapi_table *table);
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 157bceab6366..25093eeab07f 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -434,7 +434,7 @@ _mesa_glthread_Enable(struct gl_context *ctx, GLenum cap)
       _mesa_glthread_set_prim_restart(ctx, cap, true);
       break;
    case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
-      _mesa_glthread_destroy(ctx, "Enable(DEBUG_OUTPUT_SYNCHRONOUS)");
+      _mesa_glthread_destroy(ctx);
       break;
    case GL_BLEND:
       ctx->GLThread.Blend = true;
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index a62260564c73..950e5c5613d1 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -936,7 +936,7 @@ st_destroy_context(struct st_context *st)
    _mesa_make_current(ctx, NULL, NULL);
 
    /* This must be called first so that glthread has a chance to finish */
-   _mesa_glthread_destroy(ctx, NULL);
+   _mesa_glthread_destroy(ctx);
 
    _mesa_HashWalk(ctx->Shared->TexObjects, destroy_tex_sampler_cb, st);
 
-- 
GitLab


From b224c54bbb6205a698bed59bee389aab40a6865d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 31 Dec 2022 02:31:53 -0500
Subject: [PATCH 19/20] glthread: don't free glthread for
 GL_DEBUG_OUTPUT_SYNCHRONOUS, only disable it

and enable it when GL_DEBUG_OUTPUT_SYNCHRONOUS is disabled.
---
 src/mesa/main/glthread.c         | 49 +++++++++++++++++++++++---------
 src/mesa/main/glthread.h         |  3 ++
 src/mesa/main/glthread_marshal.h | 13 +++++++--
 3 files changed, 48 insertions(+), 17 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index a8c729f4c8f2..9be86399320e 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -144,18 +144,15 @@ _mesa_glthread_init(struct gl_context *ctx)
    }
    glthread->next_batch = &glthread->batches[glthread->next];
    glthread->used = 0;
-
-   glthread->enabled = true;
    glthread->stats.queue = &glthread->queue;
 
-   ctx->CurrentClientDispatch = ctx->MarshalExec;
-
    glthread->LastDListChangeBatchIndex = -1;
 
    /* glthread takes over all L3 pinning */
    ctx->st->pin_thread_counter = ST_L3_PINNING_DISABLED;
 
    _mesa_glthread_update_draw_always_async(ctx);
+   _mesa_glthread_enable(ctx);
 
    /* Execute the thread initialization function in the thread. */
    struct util_queue_fence fence;
@@ -177,23 +174,47 @@ _mesa_glthread_destroy(struct gl_context *ctx)
 {
    struct glthread_state *glthread = &ctx->GLThread;
 
-   if (!glthread->enabled)
+   _mesa_glthread_disable(ctx);
+
+   if (util_queue_is_initialized(&glthread->queue)) {
+      util_queue_destroy(&glthread->queue);
+
+      for (unsigned i = 0; i < MARSHAL_MAX_BATCHES; i++)
+         util_queue_fence_destroy(&glthread->batches[i].fence);
+
+      _mesa_HashDeleteAll(glthread->VAOs, free_vao, NULL);
+      _mesa_DeleteHashTable(glthread->VAOs);
+      _mesa_glthread_release_upload_buffer(ctx);
+   }
+}
+
+void _mesa_glthread_enable(struct gl_context *ctx)
+{
+   if (ctx->GLThread.enabled ||
+       ctx->CurrentServerDispatch == ctx->ContextLost ||
+       ctx->GLThread.DebugOutputSynchronous)
       return;
 
-   _mesa_glthread_finish(ctx);
-   util_queue_destroy(&glthread->queue);
+   ctx->GLThread.enabled = true;
+   ctx->CurrentClientDispatch = ctx->MarshalExec;
 
-   for (unsigned i = 0; i < MARSHAL_MAX_BATCHES; i++)
-      util_queue_fence_destroy(&glthread->batches[i].fence);
+   /* Update the dispatch only if the dispatch is current. */
+   if (_glapi_get_dispatch() == ctx->CurrentServerDispatch) {
+       _glapi_set_dispatch(ctx->CurrentClientDispatch);
+   }
+}
 
-   _mesa_HashDeleteAll(glthread->VAOs, free_vao, NULL);
-   _mesa_DeleteHashTable(glthread->VAOs);
-   _mesa_glthread_release_upload_buffer(ctx);
+void _mesa_glthread_disable(struct gl_context *ctx)
+{
+   if (!ctx->GLThread.enabled)
+      return;
+
+   _mesa_glthread_finish(ctx);
 
    ctx->GLThread.enabled = false;
    ctx->CurrentClientDispatch = ctx->CurrentServerDispatch;
 
-   /* Update the dispatch only if the context is current. */
+   /* Update the dispatch only if the dispatch is current. */
    if (_glapi_get_dispatch() == ctx->MarshalExec) {
        _glapi_set_dispatch(ctx->CurrentClientDispatch);
    }
@@ -207,7 +228,7 @@ _mesa_glthread_flush_batch(struct gl_context *ctx)
       return;
 
    if (ctx->CurrentServerDispatch == ctx->ContextLost) {
-      _mesa_glthread_destroy(ctx);
+      _mesa_glthread_disable(ctx);
       return;
    }
 
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index f7601eea75c0..362864819eab 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -263,6 +263,7 @@ struct glthread_state
    bool Blend;
    bool DepthTest;
    bool CullFace;
+   bool DebugOutputSynchronous;
    bool Lighting;
    bool PolygonStipple;
 
@@ -295,6 +296,8 @@ void _mesa_glthread_init_dispatch6(struct gl_context *ctx,
 void _mesa_glthread_init_dispatch7(struct gl_context *ctx,
                                    struct _glapi_table *table);
 
+void _mesa_glthread_enable(struct gl_context *ctx);
+void _mesa_glthread_disable(struct gl_context *ctx);
 void _mesa_glthread_flush_batch(struct gl_context *ctx);
 void _mesa_glthread_finish(struct gl_context *ctx);
 void _mesa_glthread_finish_before(struct gl_context *ctx, const char *func);
diff --git a/src/mesa/main/glthread_marshal.h b/src/mesa/main/glthread_marshal.h
index 25093eeab07f..e070efd848ec 100644
--- a/src/mesa/main/glthread_marshal.h
+++ b/src/mesa/main/glthread_marshal.h
@@ -433,12 +433,13 @@ _mesa_glthread_Enable(struct gl_context *ctx, GLenum cap)
    case GL_PRIMITIVE_RESTART_FIXED_INDEX:
       _mesa_glthread_set_prim_restart(ctx, cap, true);
       break;
-   case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
-      _mesa_glthread_destroy(ctx);
-      break;
    case GL_BLEND:
       ctx->GLThread.Blend = true;
       break;
+   case GL_DEBUG_OUTPUT_SYNCHRONOUS:
+      _mesa_glthread_disable(ctx);
+      ctx->GLThread.DebugOutputSynchronous = true;
+      break;
    case GL_DEPTH_TEST:
       ctx->GLThread.DepthTest = true;
       break;
@@ -483,6 +484,10 @@ _mesa_glthread_Disable(struct gl_context *ctx, GLenum cap)
    case GL_CULL_FACE:
       ctx->GLThread.CullFace = false;
       break;
+   case GL_DEBUG_OUTPUT_SYNCHRONOUS:
+      ctx->GLThread.DebugOutputSynchronous = false;
+      _mesa_glthread_enable(ctx);
+      break;
    case GL_DEPTH_TEST:
       ctx->GLThread.DepthTest = false;
       break;
@@ -519,6 +524,8 @@ _mesa_glthread_IsEnabled(struct gl_context *ctx, GLenum cap)
       return ctx->GLThread.Blend;
    case GL_CULL_FACE:
       return ctx->GLThread.CullFace;
+   case GL_DEBUG_OUTPUT_SYNCHRONOUS:
+      return ctx->GLThread.DebugOutputSynchronous;
    case GL_DEPTH_TEST:
       return ctx->GLThread.DepthTest;
    case GL_LIGHTING:
-- 
GitLab


From 04a197eade9e81deeaab35407e22502f599e7397 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 27 Dec 2022 02:37:20 -0500
Subject: [PATCH 20/20] glthread: don't restore non-VBO vertex arrays after all
 draws

glthread takes care of all uploads, so it's OK to leave uploaded VBOs
bound. The only thing that will be wrong is the bound vertex buffer
returned by glGet, but the only case when that would be wrong is when
an app that doesn't use VBOs queries the current VBO. That never happens.

However, this adds code to unbind all internal VBOs for the case when
glthread is abruptly disabled (e.g. for GL_DEBUG_OUTPUT_SYNCHRONOUS).
---
 src/mesa/main/glthread.c           |  6 +++
 src/mesa/main/glthread.h           |  2 +-
 src/mesa/main/glthread_bufferobj.c |  1 +
 src/mesa/main/glthread_draw.c      | 76 +++++-------------------------
 src/mesa/main/glthread_varray.c    | 34 +++++++++++++
 src/mesa/main/mtypes.h             |  1 +
 src/mesa/main/varray.c             | 15 +-----
 src/mesa/main/varray.h             |  3 +-
 8 files changed, 57 insertions(+), 81 deletions(-)

diff --git a/src/mesa/main/glthread.c b/src/mesa/main/glthread.c
index 9be86399320e..fd2316c33e27 100644
--- a/src/mesa/main/glthread.c
+++ b/src/mesa/main/glthread.c
@@ -218,6 +218,12 @@ void _mesa_glthread_disable(struct gl_context *ctx)
    if (_glapi_get_dispatch() == ctx->MarshalExec) {
        _glapi_set_dispatch(ctx->CurrentClientDispatch);
    }
+
+   /* Unbind VBOs in all VAOs that glthread bound for non-VBO vertex uploads
+    * to restore original states.
+    */
+   if (ctx->API != API_OPENGL_CORE)
+      _mesa_glthread_unbind_uploaded_vbos(ctx);
 }
 
 void
diff --git a/src/mesa/main/glthread.h b/src/mesa/main/glthread.h
index 362864819eab..205b339292f0 100644
--- a/src/mesa/main/glthread.h
+++ b/src/mesa/main/glthread.h
@@ -88,7 +88,6 @@ union gl_vertex_format_user {
 struct glthread_attrib_binding {
    struct gl_buffer_object *buffer; /**< where non-VBO data was uploaded */
    int offset;                      /**< offset to uploaded non-VBO data */
-   const void *original_pointer;    /**< restore this pointer after the draw */
 };
 
 struct glthread_attrib {
@@ -371,6 +370,7 @@ void _mesa_glthread_ProgramChanged(struct gl_context *ctx);
 void _mesa_glthread_UnrollDrawElements(struct gl_context *ctx,
                                        GLenum mode, GLsizei count, GLenum type,
                                        const GLvoid *indices, GLint basevertex);
+void _mesa_glthread_unbind_uploaded_vbos(struct gl_context *ctx);
 
 #ifdef __cplusplus
 }
diff --git a/src/mesa/main/glthread_bufferobj.c b/src/mesa/main/glthread_bufferobj.c
index 609cb0ffcadf..58e89aba9623 100644
--- a/src/mesa/main/glthread_bufferobj.c
+++ b/src/mesa/main/glthread_bufferobj.c
@@ -38,6 +38,7 @@ new_upload_buffer(struct gl_context *ctx, GLsizeiptr size, uint8_t **ptr)
       return NULL;
 
    obj->Immutable = true;
+   obj->GLThreadInternal = true;
 
    if (!_mesa_bufferobj_data(ctx, GL_ARRAY_BUFFER, size, NULL,
                           GL_WRITE_ONLY,
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index ac825d3da8b7..85c257e2a983 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -212,7 +212,6 @@ upload_vertices(struct gl_context *ctx, unsigned user_buffer_mask,
 
          buffers[num_buffers].buffer = upload_buffer;
          buffers[num_buffers].offset = upload_offset - start;
-         buffers[num_buffers].original_pointer = ptr;
          num_buffers++;
       }
 
@@ -273,7 +272,6 @@ upload_vertices(struct gl_context *ctx, unsigned user_buffer_mask,
 
       buffers[num_buffers].buffer = upload_buffer;
       buffers[num_buffers].offset = upload_offset - offset;
-      buffers[num_buffers].original_pointer = ptr;
       num_buffers++;
    }
 
@@ -386,10 +384,8 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
       (const struct glthread_attrib_binding *)(cmd + 1);
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      false);
-   }
+   if (user_buffer_mask)
+      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
 
    const GLenum mode = cmd->mode;
    const GLint first = cmd->first;
@@ -402,12 +398,6 @@ _mesa_unmarshal_DrawArraysUserBuf(struct gl_context *ctx,
                                         (mode, first, count, instance_count,
                                          baseinstance));
    ctx->DrawID = 0;
-
-   /* Restore states. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      true);
-   }
    return cmd->cmd_base.cmd_size;
 }
 
@@ -520,19 +510,11 @@ _mesa_unmarshal_MultiDrawArraysUserBuf(struct gl_context *ctx,
       (const struct glthread_attrib_binding *)variable_data;
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      false);
-   }
+   if (user_buffer_mask)
+      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
 
    CALL_MultiDrawArrays(ctx->CurrentServerDispatch,
                         (mode, first, count, draw_count));
-
-   /* Restore states. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      true);
-   }
    return cmd->cmd_base.cmd_size;
 }
 
@@ -617,20 +599,11 @@ _mesa_marshal_MultiDrawArrays(GLenum mode, const GLint *first,
       /* The call is too large, so sync and execute the unmarshal code here. */
       _mesa_glthread_finish_before(ctx, "MultiDrawArrays");
 
-      if (user_buffer_mask) {
-         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                         false);
-      }
+      if (user_buffer_mask)
+         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
 
       CALL_MultiDrawArrays(ctx->CurrentServerDispatch,
                            (mode, first, count, draw_count));
-
-      /* Restore states. */
-      if (user_buffer_mask) {
-         /* TODO: remove this after glthread takes over all uploading */
-         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                         true);
-      }
    }
 }
 
@@ -785,10 +758,8 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
       (const struct glthread_attrib_binding *)(cmd + 1);
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      false);
-   }
+   if (user_buffer_mask)
+      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
 
    /* Draw. */
    const GLenum mode = cmd->mode;
@@ -807,12 +778,6 @@ _mesa_unmarshal_DrawElementsUserBuf(struct gl_context *ctx,
                              baseinstance));
    ctx->DrawID = 0;
    _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
-
-   /* Restore states. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      true);
-   }
    return cmd->cmd_base.cmd_size;
 }
 
@@ -1037,10 +1002,8 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
       (const struct glthread_attrib_binding *)variable_data;
 
    /* Bind uploaded buffers if needed. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      false);
-   }
+   if (user_buffer_mask)
+      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
 
    /* Draw. */
    const GLenum mode = cmd->mode;
@@ -1051,12 +1014,6 @@ _mesa_unmarshal_MultiDrawElementsUserBuf(struct gl_context *ctx,
                                  ((GLintptr)index_buffer, mode, count, type,
                                   indices, draw_count, basevertex));
    _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
-
-   /* Restore states. */
-   if (user_buffer_mask) {
-      _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                      true);
-   }
    return cmd->cmd_base.cmd_size;
 }
 
@@ -1106,23 +1063,14 @@ multi_draw_elements_async(struct gl_context *ctx, GLenum mode,
       _mesa_glthread_finish_before(ctx, "DrawElements");
 
       /* Bind uploaded buffers if needed. */
-      if (user_buffer_mask) {
-         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                         false);
-      }
+      if (user_buffer_mask)
+         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask);
 
       /* Draw. */
       CALL_MultiDrawElementsUserBuf(ctx->CurrentServerDispatch,
                                     ((GLintptr)index_buffer, mode, count,
                                      type, indices, draw_count, basevertex));
       _mesa_reference_buffer_object(ctx, &index_buffer, NULL);
-
-      /* Restore states. */
-      /* TODO: remove this after glthread takes over all uploading */
-      if (user_buffer_mask) {
-         _mesa_InternalBindVertexBuffers(ctx, buffers, user_buffer_mask,
-                                         true);
-      }
    }
 }
 
diff --git a/src/mesa/main/glthread_varray.c b/src/mesa/main/glthread_varray.c
index a22db6baf44b..7946f3dc123c 100644
--- a/src/mesa/main/glthread_varray.c
+++ b/src/mesa/main/glthread_varray.c
@@ -728,3 +728,37 @@ _mesa_glthread_InterleavedArrays(struct gl_context *ctx, GLenum format,
                                                   0, 0, 0),
                                 stride, (GLubyte *) pointer + layout.voffset);
 }
+
+static void
+unbind_uploaded_vbos(void *_vao, void *_ctx)
+{
+   struct gl_context *ctx = _ctx;
+   struct gl_vertex_array_object *vao = _vao;
+
+   assert(ctx->API != API_OPENGL_CORE);
+
+   for (unsigned i = 0; i < ARRAY_SIZE(vao->BufferBinding); i++) {
+      if (vao->BufferBinding[i].BufferObj &&
+          vao->BufferBinding[i].BufferObj->GLThreadInternal) {
+         /* We don't need to restore the user pointer because it's never
+          * overwritten. When we bind a VBO internally, the user pointer
+          * in gl_array_attribute::Ptr becomes ignored and unchanged.
+          */
+         _mesa_bind_vertex_buffer(ctx, vao, i, NULL, 0,
+                                  vao->BufferBinding[i].Stride, false, false);
+      }
+   }
+}
+
+/* Unbind VBOs in all VAOs that glthread bound for non-VBO vertex uploads
+ * to restore original states.
+ */
+void
+_mesa_glthread_unbind_uploaded_vbos(struct gl_context *ctx)
+{
+   assert(ctx->API != API_OPENGL_CORE);
+
+   /* Iterate over all VAOs. */
+   _mesa_HashWalk(ctx->Array.Objects, unbind_uploaded_vbos, ctx);
+   unbind_uploaded_vbos(ctx->Array.DefaultVAO, ctx);
+}
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index e8fbb5a79375..949b925acf97 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1463,6 +1463,7 @@ struct gl_buffer_object
    bool DeletePending:1;  /**< true if buffer object is removed from the hash */
    bool Immutable:1;    /**< GL_ARB_buffer_storage */
    bool HandleAllocated:1; /**< GL_ARB_bindless_texture */
+   bool GLThreadInternal:1; /**< Created by glthread. */
    GLenum16 Usage;      /**< GL_STREAM_DRAW_ARB, GL_STREAM_READ_ARB, etc. */
    GLchar *Label;       /**< GL_KHR_debug */
    GLsizeiptrARB Size;  /**< Size of buffer storage in bytes */
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index af67d37d7404..0fef22276374 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -3543,24 +3543,11 @@ _mesa_BindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers,
 void
 _mesa_InternalBindVertexBuffers(struct gl_context *ctx,
                                 const struct glthread_attrib_binding *buffers,
-                                GLbitfield buffer_mask,
-                                GLboolean restore_pointers)
+                                GLbitfield buffer_mask)
 {
    struct gl_vertex_array_object *vao = ctx->Array.VAO;
    unsigned param_index = 0;
 
-   if (restore_pointers) {
-      while (buffer_mask) {
-         unsigned i = u_bit_scan(&buffer_mask);
-
-         _mesa_bind_vertex_buffer(ctx, vao, i, NULL,
-                                  (GLintptr)buffers[param_index].original_pointer,
-                                  vao->BufferBinding[i].Stride, false, false);
-         param_index++;
-      }
-      return;
-   }
-
    while (buffer_mask) {
       unsigned i = u_bit_scan(&buffer_mask);
       struct gl_buffer_object *buf = buffers[param_index].buffer;
diff --git a/src/mesa/main/varray.h b/src/mesa/main/varray.h
index 07cfa23920ac..903f89fe816e 100644
--- a/src/mesa/main/varray.h
+++ b/src/mesa/main/varray.h
@@ -156,8 +156,7 @@ _mesa_primitive_restart_index(const struct gl_context *ctx,
 void
 _mesa_InternalBindVertexBuffers(struct gl_context *ctx,
                                 const struct glthread_attrib_binding *buffers,
-                                GLbitfield buffer_mask,
-                                GLboolean restore_pointers);
+                                GLbitfield buffer_mask);
 
 extern void
 _mesa_print_arrays(struct gl_context *ctx);
-- 
GitLab

