From 0ca0e859c276c4a46debdab023d4f33ef40adeb7 Mon Sep 17 00:00:00 2001
From: Joshua Simmons <josh@nega.tv>
Date: Sat, 27 Jan 2024 21:04:50 +0100
Subject: [PATCH 1/3] fix descriptor size calculation

---
 src/amd/vulkan/radv_descriptor_set.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index e0a4afa1de2..69911dc3c8b 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -447,9 +447,9 @@ radv_GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutC
             break;
          case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
             if (!has_equal_immutable_samplers(binding->pImmutableSamplers, descriptor_count)) {
-               descriptor_size = 64;
-            } else {
                descriptor_size = 96;
+            } else {
+               descriptor_size = 64;
             }
             break;
          case VK_DESCRIPTOR_TYPE_SAMPLER:
--
2.43.0

From d4f97f0b4ba0b5bcf04c17b277748d6f91ac0de2 Mon Sep 17 00:00:00 2001
From: Joshua Simmons <josh@nega.tv>
Date: Sat, 27 Jan 2024 21:26:26 +0100
Subject: [PATCH 2/3] fix descriptor size calc more

---
 src/amd/vulkan/radv_descriptor_set.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 69911dc3c8b..521117d3345 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -425,6 +425,21 @@ radv_GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutC
       for (uint32_t i = 0; i < pCreateInfo->bindingCount; i++) {
          const VkDescriptorSetLayoutBinding *binding = bindings + i;

+         /* main image + fmask */
+         uint32_t max_sampled_image_descriptors = 2;
+
+         if (binding->descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER && binding->pImmutableSamplers) {
+            for (unsigned j = 0; j < binding->descriptorCount; ++j) {
+               struct vk_ycbcr_conversion *conversion =
+                  radv_sampler_from_handle(binding->pImmutableSamplers[j])->vk.ycbcr_conversion;
+
+               if (conversion) {
+                  max_sampled_image_descriptors =
+                     MAX2(max_sampled_image_descriptors, vk_format_get_plane_count(conversion->state.format));
+               }
+            }
+         }
+
          uint64_t descriptor_size = 0;
          uint64_t descriptor_alignment = radv_descriptor_alignment(binding->descriptorType);
          uint32_t descriptor_count = binding->descriptorCount;
@@ -446,7 +461,7 @@ radv_GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutC
             descriptor_size = 64;
             break;
          case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
-            if (!has_equal_immutable_samplers(binding->pImmutableSamplers, descriptor_count)) {
+            if (!has_equal_immutable_samplers(binding->pImmutableSamplers, descriptor_count) || max_sampled_image_descriptors > 2) {
                descriptor_size = 96;
             } else {
                descriptor_size = 64;
--
2.43.0

From 05ad56b8ad13d5a8747a8b1ada09c30e595f7c6d Mon Sep 17 00:00:00 2001
From: Joshua Simmons <josh@nega.tv>
Date: Sun, 4 Feb 2024 16:58:31 +0100
Subject: [PATCH 3/3] remateralize descriptor size

---
 src/amd/vulkan/radv_cmd_buffer.c     |   7 +-
 src/amd/vulkan/radv_descriptor_set.c | 594 ++++++++++++++++-----------
 src/amd/vulkan/radv_descriptor_set.h |   2 +-
 3 files changed, 365 insertions(+), 238 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 2e329d448de..499a0003922 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -531,6 +531,7 @@ radv_cmd_buffer_upload_alloc_aligned(struct radv_cmd_buffer *cmd_buffer, unsigne
                                      unsigned *out_offset, void **ptr)
 {
    assert(size % 4 == 0);
+   assert(alignment && util_is_power_of_two_nonzero(alignment));

    const struct radeon_info *rad_info = &cmd_buffer->device->physical_device->rad_info;

@@ -543,8 +544,8 @@ radv_cmd_buffer_upload_alloc_aligned(struct radv_cmd_buffer *cmd_buffer, unsigne
    if ((size & (line_size - 1)) > gap)
       offset = align(offset, line_size);

-   if (alignment)
-      offset = align(offset, alignment);
+   offset = align(offset, alignment);
+
    if (offset + size > cmd_buffer->upload.size) {
       if (!radv_cmd_buffer_resize_upload_buf(cmd_buffer, size))
          return false;
@@ -561,7 +562,7 @@ radv_cmd_buffer_upload_alloc_aligned(struct radv_cmd_buffer *cmd_buffer, unsigne
 bool
 radv_cmd_buffer_upload_alloc(struct radv_cmd_buffer *cmd_buffer, unsigned size, unsigned *out_offset, void **ptr)
 {
-   return radv_cmd_buffer_upload_alloc_aligned(cmd_buffer, size, 0, out_offset, ptr);
+   return radv_cmd_buffer_upload_alloc_aligned(cmd_buffer, size, 1, out_offset, ptr);
 }

 bool
diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index 521117d3345..c2b8569f4e0 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -340,10 +340,12 @@ radv_CreateDescriptorSetLayout(VkDevice _device, const VkDescriptorSetLayoutCrea
             /* Don't reserve space for the samplers if they're not accessed. */
             if (set_layout->binding[b].immutable_samplers_equal) {
                if (binding->descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER &&
-                   max_sampled_image_descriptors <= 2)
+                   max_sampled_image_descriptors <= 2) {
                   set_layout->binding[b].size -= 32;
-               else if (binding->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER)
+               }
+               else if (binding->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) {
                   set_layout->binding[b].size -= 16;
+               }
             }
             samplers += 4 * binding->descriptorCount;
             samplers_offset += 4 * sizeof(uint32_t) * binding->descriptorCount;
@@ -1066,31 +1068,20 @@ radv_FreeDescriptorSets(VkDevice _device, VkDescriptorPool descriptorPool, uint3
 }

 static ALWAYS_INLINE void
-write_texel_buffer_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_buffer, unsigned *dst,
-                              struct radeon_winsys_bo **buffer_list, const VkBufferView _buffer_view)
+write_texel_buffer_descriptor(unsigned *dst, const VkBufferView _buffer_view)
 {
    RADV_FROM_HANDLE(radv_buffer_view, buffer_view, _buffer_view);

    if (!buffer_view) {
       memset(dst, 0, 4 * 4);
-      if (!cmd_buffer)
-         *buffer_list = NULL;
       return;
    }

    memcpy(dst, buffer_view->state, 4 * 4);
-
-   if (device->use_global_bo_list)
-      return;
-
-   if (cmd_buffer)
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, buffer_view->bo);
-   else
-      *buffer_list = buffer_view->bo;
 }

 static ALWAYS_INLINE void
-write_buffer_descriptor(struct radv_device *device, unsigned *dst, uint64_t va, uint64_t range)
+write_buffer_descriptor(enum amd_gfx_level gfx_level, unsigned *dst, uint64_t va, uint64_t range)
 {
    if (!va) {
       memset(dst, 0, 4 * 4);
@@ -1100,9 +1091,9 @@ write_buffer_descriptor(struct radv_device *device, unsigned *dst, uint64_t va,
    uint32_t rsrc_word3 = S_008F0C_DST_SEL_X(V_008F0C_SQ_SEL_X) | S_008F0C_DST_SEL_Y(V_008F0C_SQ_SEL_Y) |
                          S_008F0C_DST_SEL_Z(V_008F0C_SQ_SEL_Z) | S_008F0C_DST_SEL_W(V_008F0C_SQ_SEL_W);

-   if (device->physical_device->rad_info.gfx_level >= GFX11) {
+   if (gfx_level >= GFX11) {
       rsrc_word3 |= S_008F0C_FORMAT(V_008F0C_GFX11_FORMAT_32_FLOAT) | S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW);
-   } else if (device->physical_device->rad_info.gfx_level >= GFX10) {
+   } else if (gfx_level >= GFX10) {
       rsrc_word3 |= S_008F0C_FORMAT(V_008F0C_GFX10_FORMAT_32_FLOAT) | S_008F0C_OOB_SELECT(V_008F0C_OOB_SELECT_RAW) |
                     S_008F0C_RESOURCE_LEVEL(1);
    } else {
@@ -1110,50 +1101,38 @@ write_buffer_descriptor(struct radv_device *device, unsigned *dst, uint64_t va,
          S_008F0C_NUM_FORMAT(V_008F0C_BUF_NUM_FORMAT_FLOAT) | S_008F0C_DATA_FORMAT(V_008F0C_BUF_DATA_FORMAT_32);
    }

-   dst[0] = va;
-   dst[1] = S_008F04_BASE_ADDRESS_HI(va >> 32);
-   /* robustBufferAccess is relaxed enough to allow this (in combination with the alignment/size
-    * we return from vkGetBufferMemoryRequirements) and this allows the shader compiler to create
-    * more efficient 8/16-bit buffer accesses.
-    */
-   dst[2] = align(range, 4);
-   dst[3] = rsrc_word3;
+   // encourage compiler to emit wider stores
+   const uint32_t descriptor[4] = {
+      va,
+      S_008F04_BASE_ADDRESS_HI(va >> 32),
+      /* robustBufferAccess is relaxed enough to allow this (in combination with the alignment/size
+      * we return from vkGetBufferMemoryRequirements) and this allows the shader compiler to create
+      * more efficient 8/16-bit buffer accesses.
+      */
+      align(range, 4),
+      rsrc_word3
+   };
+
+   memcpy(dst, descriptor, sizeof(descriptor));
 }

 static ALWAYS_INLINE void
-write_buffer_descriptor_impl(struct radv_device *device, struct radv_cmd_buffer *cmd_buffer, unsigned *dst,
-                             struct radeon_winsys_bo **buffer_list, const VkDescriptorBufferInfo *buffer_info)
+write_buffer_descriptor_impl(enum amd_gfx_level gfx_level, unsigned *dst, const VkDescriptorBufferInfo *buffer_info)
 {
    RADV_FROM_HANDLE(radv_buffer, buffer, buffer_info->buffer);
    uint64_t va = 0, range = 0;

    if (buffer) {
       va = radv_buffer_get_va(buffer->bo) + buffer_info->offset + buffer->offset;
-
       range = vk_buffer_range(&buffer->vk, buffer_info->offset, buffer_info->range);
       assert(buffer->vk.size > 0 && range > 0);
    }

-   write_buffer_descriptor(device, dst, va, range);
-
-   if (device->use_global_bo_list)
-      return;
-
-   if (!buffer) {
-      if (!cmd_buffer)
-         *buffer_list = NULL;
-      return;
-   }
-
-   if (cmd_buffer)
-      radv_cs_add_buffer(device->ws, cmd_buffer->cs, buffer->bo);
-   else
-      *buffer_list = buffer->bo;
+   write_buffer_descriptor(gfx_level, dst, va, range);
 }

 static ALWAYS_INLINE void
-write_block_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_buffer, void *dst,
-                       const VkWriteDescriptorSet *writeset)
+write_block_descriptor(struct radv_cmd_buffer *cmd_buffer, void *dst, const VkWriteDescriptorSet *writeset)
 {
    const VkWriteDescriptorSetInlineUniformBlock *inline_ub =
       vk_find_struct_const(writeset->pNext, WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK);
@@ -1162,8 +1141,7 @@ write_block_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_b
 }

 static ALWAYS_INLINE void
-write_dynamic_buffer_descriptor(struct radv_device *device, struct radv_descriptor_range *range,
-                                struct radeon_winsys_bo **buffer_list, const VkDescriptorBufferInfo *buffer_info)
+write_dynamic_buffer_descriptor(struct radv_descriptor_range *range, const VkDescriptorBufferInfo *buffer_info)
 {
    RADV_FROM_HANDLE(radv_buffer, buffer, buffer_info->buffer);
    uint64_t va;
@@ -1171,12 +1149,10 @@ write_dynamic_buffer_descriptor(struct radv_device *device, struct radv_descript

    if (!buffer) {
       range->va = 0;
-      *buffer_list = NULL;
       return;
    }

    va = radv_buffer_get_va(buffer->bo);
-
    size = vk_buffer_range(&buffer->vk, buffer_info->offset, buffer_info->range);
    assert(buffer->vk.size > 0 && size > 0);

@@ -1189,76 +1165,58 @@ write_dynamic_buffer_descriptor(struct radv_device *device, struct radv_descript
    va += buffer_info->offset + buffer->offset;
    range->va = va;
    range->size = size;
-
-   *buffer_list = buffer->bo;
 }

 static ALWAYS_INLINE void
-write_image_descriptor(unsigned *dst, unsigned size, VkDescriptorType descriptor_type,
-                       const VkDescriptorImageInfo *image_info)
+write_storage_image_descriptor(unsigned *dst, size_t descriptor_size, const VkDescriptorImageInfo *image_info)
 {
    struct radv_image_view *iview = NULL;
-   union radv_descriptor *descriptor;

    if (image_info)
       iview = radv_image_view_from_handle(image_info->imageView);

    if (!iview) {
-      memset(dst, 0, size);
+      memset(dst, 0, descriptor_size);
       return;
    }

-   if (descriptor_type == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) {
-      descriptor = &iview->storage_descriptor;
-   } else {
-      descriptor = &iview->descriptor;
-   }
-   assert(size > 0);
-
-   memcpy(dst, descriptor, size);
+   memcpy(dst, &iview->storage_descriptor, descriptor_size);
 }

 static ALWAYS_INLINE void
-write_image_descriptor_impl(struct radv_device *device, struct radv_cmd_buffer *cmd_buffer, unsigned size,
-                            unsigned *dst, struct radeon_winsys_bo **buffer_list, VkDescriptorType descriptor_type,
-                            const VkDescriptorImageInfo *image_info)
+write_image_descriptor(unsigned *dst, size_t descriptor_size, const VkDescriptorImageInfo *image_info)
 {
-   RADV_FROM_HANDLE(radv_image_view, iview, image_info->imageView);
-
-   write_image_descriptor(dst, size, descriptor_type, image_info);
+   struct radv_image_view *iview = NULL;

-   if (device->use_global_bo_list)
-      return;
+   if (image_info)
+      iview = radv_image_view_from_handle(image_info->imageView);

    if (!iview) {
-      if (!cmd_buffer)
-         *buffer_list = NULL;
+      memset(dst, 0, descriptor_size);
       return;
    }

-   const uint32_t max_bindings = sizeof(iview->image->bindings) / sizeof(iview->image->bindings[0]);
-   for (uint32_t b = 0; b < max_bindings; b++) {
-      if (cmd_buffer) {
-         if (iview->image->bindings[b].bo)
-            radv_cs_add_buffer(device->ws, cmd_buffer->cs, iview->image->bindings[b].bo);
-      } else {
-         *buffer_list = iview->image->bindings[b].bo;
-         buffer_list++;
-      }
-   }
+   memcpy(dst, &iview->descriptor, descriptor_size);
 }

 static ALWAYS_INLINE void
-write_combined_image_sampler_descriptor(struct radv_device *device, struct radv_cmd_buffer *cmd_buffer,
-                                        unsigned sampler_offset, unsigned *dst, struct radeon_winsys_bo **buffer_list,
-                                        VkDescriptorType descriptor_type, const VkDescriptorImageInfo *image_info,
-                                        bool has_sampler)
+write_combined_image_sampler_descriptor(unsigned *dst, size_t descriptor_size, const VkDescriptorImageInfo *image_info,
+                                        bool has_sampler, bool copy_immutable_sampler,
+                                        const uint32_t *immutable_samplers, uint32_t immutable_sampler_index)
 {
-   write_image_descriptor_impl(device, cmd_buffer, sampler_offset, dst, buffer_list, descriptor_type, image_info);
-   /* copy over sampler state */
-   if (has_sampler) {
-      RADV_FROM_HANDLE(radv_sampler, sampler, image_info->sampler);
-      memcpy(dst + sampler_offset / sizeof(*dst), sampler->state, 16);
+   // branch here to encourage the compiler to unroll the 64b/96b store
+   if (descriptor_size == 64)
+      write_image_descriptor(dst, 64, image_info);
+   else {
+      assert(descriptor_size == 96);
+      write_image_descriptor(dst, 80, image_info);
+      /* copy over sampler state */
+      if (has_sampler) {
+         RADV_FROM_HANDLE(radv_sampler, sampler, image_info->sampler);
+         memcpy(dst + 80 / 4, sampler->state, 16);
+      } else if (copy_immutable_sampler) {
+         memcpy(dst + 80 / 4, immutable_samplers + 4 * immutable_sampler_index, 16);
+      }
    }
 }

@@ -1266,7 +1224,7 @@ static ALWAYS_INLINE void
 write_sampler_descriptor(unsigned *dst, VkSampler _sampler)
 {
    RADV_FROM_HANDLE(radv_sampler, sampler, _sampler);
-   memcpy(dst, sampler->state, 16);
+   memcpy(dst, sampler->state, sizeof(sampler->state));
 }

 static ALWAYS_INLINE void
@@ -1288,93 +1246,177 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf
                                  const VkCopyDescriptorSet *pDescriptorCopies)
 {
    uint32_t i, j;
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
+
    for (i = 0; i < descriptorWriteCount; i++) {
       const VkWriteDescriptorSet *writeset = &pDescriptorWrites[i];
       RADV_FROM_HANDLE(radv_descriptor_set, set, dstSetOverride ? dstSetOverride : writeset->dstSet);
       const struct radv_descriptor_set_binding_layout *binding_layout =
          set->header.layout->binding + writeset->dstBinding;
-      uint32_t *ptr = set->header.mapped_ptr;
-      struct radeon_winsys_bo **buffer_list = set->descriptors;
-      /* Immutable samplers are not copied into push descriptors when they are
-       * allocated, so if we are writing push descriptors we have to copy the
-       * immutable samplers into them now.
-       */
-      const bool copy_immutable_samplers =
-         cmd_buffer && binding_layout->immutable_samplers_offset && !binding_layout->immutable_samplers_equal;
-      const uint32_t *samplers = radv_immutable_samplers(set->header.layout, binding_layout);
-      const VkWriteDescriptorSetAccelerationStructureKHR *accel_structs = NULL;
+      uint32_t * restrict ptr = set->header.mapped_ptr;
+
+      const uint32_t offset = binding_layout->offset;
+      const uint32_t size = binding_layout->size;

-      ptr += binding_layout->offset / 4;
+      const uint32_t descriptor_count = writeset->descriptorCount;
+      const VkDescriptorType descriptor_type = writeset->descriptorType;
+      const uint32_t dst_array_element = writeset->dstArrayElement;

-      if (writeset->descriptorType == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK) {
-         write_block_descriptor(device, cmd_buffer, (uint8_t *)ptr + writeset->dstArrayElement, writeset);
+      ptr += offset / 4;
+
+      if (descriptor_type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK) {
+         write_block_descriptor(cmd_buffer, (uint8_t *)ptr + dst_array_element, writeset);
          continue;
-      } else if (writeset->descriptorType == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR) {
-         accel_structs = vk_find_struct_const(writeset->pNext, WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR);
       }

-      ptr += binding_layout->size * writeset->dstArrayElement / 4;
-      buffer_list += binding_layout->buffer_offset;
-      buffer_list += writeset->dstArrayElement;
-      for (j = 0; j < writeset->descriptorCount; ++j) {
-         switch (writeset->descriptorType) {
+      ptr += size * dst_array_element / 4;
+
+      switch (descriptor_type) {
+         case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
+         case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: {
+            const VkDescriptorBufferInfo* buffer_info_base = writeset->pBufferInfo;
+            for (j = 0; j < descriptor_count; ++j)
+               write_buffer_descriptor_impl(gfx_level, ptr + j * size / 4, buffer_info_base + j);
+            break;
+         }
          case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
          case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
-            unsigned idx = writeset->dstArrayElement + j;
-            idx += binding_layout->dynamic_offset_offset;
+            const VkDescriptorBufferInfo *buffer_info_base = writeset->pBufferInfo;
+            struct radv_descriptor_range *dynamic_descriptors = set->header.dynamic_descriptors;
+            const uint16_t dynamic_offset_offset = binding_layout->dynamic_offset_offset;
             assert(!(set->header.layout->flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR));
-            write_dynamic_buffer_descriptor(device, set->header.dynamic_descriptors + idx, buffer_list,
-                                            writeset->pBufferInfo + j);
+            for (j = 0; j < descriptor_count; ++j) {
+               const unsigned idx = dst_array_element + j + dynamic_offset_offset;
+               write_dynamic_buffer_descriptor(dynamic_descriptors + idx, buffer_info_base + j);
+            }
             break;
          }
-         case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
-         case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
-            write_buffer_descriptor_impl(device, cmd_buffer, ptr, buffer_list, writeset->pBufferInfo + j);
-            break;
          case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
-         case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
-            write_texel_buffer_descriptor(device, cmd_buffer, ptr, buffer_list, writeset->pTexelBufferView[j]);
+         case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
+            const VkBufferView *texel_buffer_view_base = writeset->pTexelBufferView;
+            for (j = 0; j < descriptor_count; ++j)
+               write_texel_buffer_descriptor(ptr + j * size / 4, texel_buffer_view_base[j]);
             break;
-         case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
-            write_image_descriptor_impl(device, cmd_buffer, 32, ptr, buffer_list, writeset->descriptorType,
-                                        writeset->pImageInfo + j);
+         }
+         case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: {
+            const VkDescriptorImageInfo *image_info_base = writeset->pImageInfo;
+            for (j = 0; j < descriptor_count; ++j)
+               write_storage_image_descriptor(ptr + j * size / 4, 32, image_info_base + j);
             break;
+         }
          case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
-         case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
-            write_image_descriptor_impl(device, cmd_buffer, 64, ptr, buffer_list, writeset->descriptorType,
-                                        writeset->pImageInfo + j);
+         case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
+            const VkDescriptorImageInfo* image_info_base = writeset->pImageInfo;
+            for (j = 0; j < descriptor_count; ++j)
+               write_image_descriptor(ptr + j * size / 4, 64, image_info_base + j);
             break;
+         }
          case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: {
-            unsigned sampler_offset = radv_combined_image_descriptor_sampler_offset(binding_layout);
-            write_combined_image_sampler_descriptor(device, cmd_buffer, sampler_offset, ptr, buffer_list,
-                                                    writeset->descriptorType, writeset->pImageInfo + j,
-                                                    !binding_layout->immutable_samplers_offset);
-            if (copy_immutable_samplers) {
-               const unsigned idx = writeset->dstArrayElement + j;
-               memcpy((char *)ptr + sampler_offset, samplers + 4 * idx, 16);
-            }
+            const uint32_t *samplers = radv_immutable_samplers(set->header.layout, binding_layout);
+            /* Immutable samplers are not copied into push descriptors when they are
+            * allocated, so if we are writing push descriptors we have to copy the
+            * immutable samplers into them now.
+            */
+            const bool copy_immutable_samplers =
+               cmd_buffer && binding_layout->immutable_samplers_offset && !binding_layout->immutable_samplers_equal;
+            const VkDescriptorImageInfo* image_info_base = writeset->pImageInfo;
+            const uint32_t immutable_samplers_offset = binding_layout->immutable_samplers_offset;
+            const size_t descriptor_size = binding_layout->size;
+            for (j = 0; j < descriptor_count; ++j)
+               write_combined_image_sampler_descriptor(ptr + j * size / 4, descriptor_size, image_info_base + j,
+                                                       !immutable_samplers_offset, copy_immutable_samplers, samplers,
+                                                       dst_array_element + j);
             break;
          }
-         case VK_DESCRIPTOR_TYPE_SAMPLER:
+         case VK_DESCRIPTOR_TYPE_SAMPLER: {
+            /* Immutable samplers are not copied into push descriptors when they are
+            * allocated, so if we are writing push descriptors we have to copy the
+            * immutable samplers into them now.
+            */
+            const bool copy_immutable_samplers =
+               cmd_buffer && binding_layout->immutable_samplers_offset && !binding_layout->immutable_samplers_equal;
             if (!binding_layout->immutable_samplers_offset) {
-               const VkDescriptorImageInfo *pImageInfo = writeset->pImageInfo + j;
-               write_sampler_descriptor(ptr, pImageInfo->sampler);
+               const VkDescriptorImageInfo* image_info_base = writeset->pImageInfo;
+               for (j = 0; j < descriptor_count; ++j)
+                  write_sampler_descriptor(ptr + j * size / 4, image_info_base[j].sampler);
             } else if (copy_immutable_samplers) {
-               unsigned idx = writeset->dstArrayElement + j;
-               memcpy(ptr, samplers + 4 * idx, 16);
+               const uint32_t *samplers = radv_immutable_samplers(set->header.layout, binding_layout);
+               for (j = 0; j < descriptor_count; ++j)
+                  memcpy(ptr + j * size / 4, samplers + j * 4, 16);
             }
             break;
+         }
          case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR: {
-            RADV_FROM_HANDLE(vk_acceleration_structure, accel_struct, accel_structs->pAccelerationStructures[j]);
-
-            write_accel_struct(device, ptr, accel_struct ? vk_acceleration_structure_get_va(accel_struct) : 0);
+            const VkWriteDescriptorSetAccelerationStructureKHR *accel_structs = vk_find_struct_const(writeset->pNext, WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR);
+            for (j = 0; j < descriptor_count; ++j) {
+               RADV_FROM_HANDLE(vk_acceleration_structure, accel_struct, accel_structs->pAccelerationStructures[j]);
+               write_accel_struct(device, ptr + j * size / 4, accel_struct ? vk_acceleration_structure_get_va(accel_struct) : 0);
+            }
             break;
          }
          default:
             break;
+      }
+   }
+
+   if (!device->use_global_bo_list) {
+      struct radeon_winsys* ws = cmd_buffer ? device->ws : NULL;
+      struct radeon_cmdbuf* cs = cmd_buffer ? cmd_buffer->cs : NULL;
+
+      for (i = 0; i < descriptorWriteCount; i++) {
+         const VkWriteDescriptorSet *writeset = &pDescriptorWrites[i];
+         RADV_FROM_HANDLE(radv_descriptor_set, set, dstSetOverride ? dstSetOverride : writeset->dstSet);
+         const struct radv_descriptor_set_binding_layout *binding_layout =
+         set->header.layout->binding + writeset->dstBinding;
+
+         struct radeon_winsys_bo **buffer_list = set->descriptors;
+         buffer_list += binding_layout->buffer_offset;
+         buffer_list += writeset->dstArrayElement;
+         for (j = 0; j < writeset->descriptorCount; ++j) {
+            switch (writeset->descriptorType) {
+               case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
+               case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
+               case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
+               case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: {
+                  const VkDescriptorBufferInfo *buffer_info = writeset->pBufferInfo + j;
+                  RADV_FROM_HANDLE(radv_buffer, buffer, buffer_info->buffer);
+                  if (cmd_buffer && buffer) {
+                     radv_cs_add_buffer(ws, cs, buffer->bo);
+                  } else {
+                     *buffer_list++ = buffer ? buffer->bo : NULL;
+                  }
+                  break;
+               }
+               case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
+               case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
+                  const VkBufferView _buffer_view = writeset->pTexelBufferView[j];
+                  RADV_FROM_HANDLE(radv_buffer_view, buffer_view, _buffer_view);
+                  if (cmd_buffer && buffer_view) {
+                     radv_cs_add_buffer(ws, cs, buffer_view->bo);
+                  } else {
+                     *buffer_list++ = buffer_view ? buffer_view->bo : NULL;
+                  }
+                  break;
+               }
+               case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
+               case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
+               case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
+               case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: {
+                  const VkDescriptorImageInfo *image_info = writeset->pImageInfo + j;
+                  RADV_FROM_HANDLE(radv_image_view, image_view, image_info->imageView);
+                  for (int b = 0; b < ARRAY_SIZE(image_view->image->bindings); b++) {
+                     if (cmd_buffer && image_view) {
+                        if (image_view->image->bindings[b].bo)
+                           radv_cs_add_buffer(ws, cs, image_view->image->bindings[b].bo);
+                     } else {
+                        *buffer_list++ = image_view ? image_view->image->bindings[b].bo : NULL;
+                     }
+                  }
+                  break;
+               }
+               default: break;
+            }
          }
-         ptr += binding_layout->size / 4;
-         ++buffer_list;
       }
    }

@@ -1394,7 +1436,12 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf
       src_ptr += src_binding_layout->offset / 4;
       dst_ptr += dst_binding_layout->offset / 4;

-      if (src_binding_layout->type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK) {
+      const VkDescriptorType src_type = src_binding_layout->type;
+      const size_t src_size = src_binding_layout->size;
+      const VkDescriptorType dst_type = dst_binding_layout->type;
+      const size_t dst_size = dst_binding_layout->size;
+
+      if (src_type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK) {
          src_ptr += copyset->srcArrayElement / 4;
          dst_ptr += copyset->dstArrayElement / 4;

@@ -1402,8 +1449,8 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf
          continue;
       }

-      src_ptr += src_binding_layout->size * copyset->srcArrayElement / 4;
-      dst_ptr += dst_binding_layout->size * copyset->dstArrayElement / 4;
+      src_ptr += src_size * copyset->srcArrayElement / 4;
+      dst_ptr += dst_size * copyset->dstArrayElement / 4;

       src_buffer_list += src_binding_layout->buffer_offset;
       src_buffer_list += copyset->srcArrayElement;
@@ -1413,10 +1460,10 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf

       /* In case of copies between mutable descriptor types
        * and non-mutable descriptor types. */
-      size_t copy_size = MIN2(src_binding_layout->size, dst_binding_layout->size);
+      const size_t copy_size = MIN2(src_binding_layout->size, dst_binding_layout->size);

       for (j = 0; j < copyset->descriptorCount; ++j) {
-         switch (src_binding_layout->type) {
+         switch (src_type) {
          case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
          case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
             unsigned src_idx = copyset->srcArrayElement + j;
@@ -1433,11 +1480,11 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf
          default:
             memcpy(dst_ptr, src_ptr, copy_size);
          }
-         src_ptr += src_binding_layout->size / 4;
-         dst_ptr += dst_binding_layout->size / 4;
+         src_ptr += src_size / 4;
+         dst_ptr += dst_size / 4;

-         unsigned src_buffer_count = radv_descriptor_type_buffer_count(src_binding_layout->type);
-         unsigned dst_buffer_count = radv_descriptor_type_buffer_count(dst_binding_layout->type);
+         unsigned src_buffer_count = radv_descriptor_type_buffer_count(src_type);
+         unsigned dst_buffer_count = radv_descriptor_type_buffer_count(dst_type);
          for (unsigned k = 0; k < dst_buffer_count; k++) {
             if (k < src_buffer_count)
                dst_buffer_list[k] = src_buffer_list[k];
@@ -1451,17 +1498,6 @@ radv_update_descriptor_sets_impl(struct radv_device *device, struct radv_cmd_buf
    }
 }

-VKAPI_ATTR void VKAPI_CALL
-radv_UpdateDescriptorSets(VkDevice _device, uint32_t descriptorWriteCount,
-                          const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount,
-                          const VkCopyDescriptorSet *pDescriptorCopies)
-{
-   RADV_FROM_HANDLE(radv_device, device, _device);
-
-   radv_update_descriptor_sets_impl(device, NULL, VK_NULL_HANDLE, descriptorWriteCount, pDescriptorWrites,
-                                    descriptorCopyCount, pDescriptorCopies);
-}
-
 void
 radv_cmd_update_descriptor_sets(struct radv_device *device, struct radv_cmd_buffer *cmd_buffer,
                                 VkDescriptorSet dstSetOverride, uint32_t descriptorWriteCount,
@@ -1474,6 +1510,17 @@ radv_cmd_update_descriptor_sets(struct radv_device *device, struct radv_cmd_buff
                                     descriptorCopyCount, pDescriptorCopies);
 }

+VKAPI_ATTR void VKAPI_CALL
+radv_UpdateDescriptorSets(VkDevice _device, uint32_t descriptorWriteCount,
+                          const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount,
+                          const VkCopyDescriptorSet *pDescriptorCopies)
+{
+   RADV_FROM_HANDLE(radv_device, device, _device);
+
+   radv_update_descriptor_sets_impl(device, NULL, VK_NULL_HANDLE, descriptorWriteCount, pDescriptorWrites,
+                                    descriptorCopyCount, pDescriptorCopies);
+}
+
 VKAPI_ATTR VkResult VKAPI_CALL
 radv_CreateDescriptorUpdateTemplate(VkDevice _device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo,
                                     const VkAllocationCallbacks *pAllocator,
@@ -1553,13 +1600,13 @@ radv_CreateDescriptorUpdateTemplate(VkDevice _device, const VkDescriptorUpdateTe
       templ->entry[i] = (struct radv_descriptor_update_template_entry){
          .descriptor_type = entry->descriptorType,
          .descriptor_count = entry->descriptorCount,
+         .descriptor_size = binding_layout->size,
          .src_offset = entry->offset,
          .src_stride = entry->stride,
          .dst_offset = dst_offset,
          .dst_stride = dst_stride,
          .buffer_offset = buffer_offset,
          .has_sampler = !binding_layout->immutable_samplers_offset,
-         .sampler_offset = radv_combined_image_descriptor_sampler_offset(binding_layout),
          .immutable_samplers = immutable_samplers};
    }

@@ -1588,71 +1635,149 @@ radv_update_descriptor_set_with_template_impl(struct radv_device *device, struct
 {
    RADV_FROM_HANDLE(radv_descriptor_update_template, templ, descriptorUpdateTemplate);
    uint32_t i;
+   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;

    for (i = 0; i < templ->entry_count; ++i) {
-      struct radeon_winsys_bo **buffer_list = set->descriptors + templ->entry[i].buffer_offset;
-      uint32_t *pDst = set->header.mapped_ptr + templ->entry[i].dst_offset;
-      const uint8_t *pSrc = ((const uint8_t *)pData) + templ->entry[i].src_offset;
+      uint32_t * restrict dst = set->header.mapped_ptr + templ->entry[i].dst_offset;
+      const uint8_t *src = ((const uint8_t *)pData) + templ->entry[i].src_offset;
       uint32_t j;

-      if (templ->entry[i].descriptor_type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK) {
-         memcpy((uint8_t *)pDst, pSrc, templ->entry[i].descriptor_count);
+      const VkDescriptorType descriptor_type = templ->entry[i].descriptor_type;
+      const uint32_t descriptor_count = templ->entry[i].descriptor_count;
+
+      const size_t src_stride = templ->entry[i].src_stride;
+      const size_t dst_stride = templ->entry[i].dst_stride;
+
+      if (descriptor_type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK) {
+         memcpy((uint8_t *)dst, src, descriptor_count);
          continue;
       }

-      for (j = 0; j < templ->entry[i].descriptor_count; ++j) {
-         switch (templ->entry[i].descriptor_type) {
-         case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
-         case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
+      switch (descriptor_type) {
+      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
+      case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
+         struct radv_descriptor_range *dynamic_descriptors = set->header.dynamic_descriptors;
+         assert(!(set->header.layout->flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR));
+         for (j = 0; j < descriptor_count; ++j) {
             const unsigned idx = templ->entry[i].dst_offset + j;
-            assert(!(set->header.layout->flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR));
-            write_dynamic_buffer_descriptor(device, set->header.dynamic_descriptors + idx, buffer_list,
-                                            (struct VkDescriptorBufferInfo *)pSrc);
-            break;
+            write_dynamic_buffer_descriptor(dynamic_descriptors + idx,
+                                            (struct VkDescriptorBufferInfo *)(src + src_stride * j));
          }
-         case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
-         case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
-            write_buffer_descriptor_impl(device, cmd_buffer, pDst, buffer_list, (struct VkDescriptorBufferInfo *)pSrc);
-            break;
-         case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
-         case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
-            write_texel_buffer_descriptor(device, cmd_buffer, pDst, buffer_list, *(VkBufferView *)pSrc);
-            break;
-         case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
-            write_image_descriptor_impl(device, cmd_buffer, 32, pDst, buffer_list, templ->entry[i].descriptor_type,
-                                        (struct VkDescriptorImageInfo *)pSrc);
-            break;
-         case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
-         case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
-            write_image_descriptor_impl(device, cmd_buffer, 64, pDst, buffer_list, templ->entry[i].descriptor_type,
-                                        (struct VkDescriptorImageInfo *)pSrc);
-            break;
-         case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
-            write_combined_image_sampler_descriptor(device, cmd_buffer, templ->entry[i].sampler_offset, pDst,
-                                                    buffer_list, templ->entry[i].descriptor_type,
-                                                    (struct VkDescriptorImageInfo *)pSrc, templ->entry[i].has_sampler);
-            if (cmd_buffer && templ->entry[i].immutable_samplers) {
-               memcpy((char *)pDst + templ->entry[i].sampler_offset, templ->entry[i].immutable_samplers + 4 * j, 16);
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
+      case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: {
+         for (j = 0; j < descriptor_count; ++j)
+            write_buffer_descriptor_impl(gfx_level, dst + dst_stride * j, (struct VkDescriptorBufferInfo *)(src + src_stride * j));
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
+      case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
+         for (j = 0; j < descriptor_count; ++j)
+            write_texel_buffer_descriptor(dst + dst_stride * j, *(VkBufferView *)(src + src_stride * j));
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: {
+         for (j = 0; j < descriptor_count; ++j)
+            write_storage_image_descriptor(dst + dst_stride * j, 32, (struct VkDescriptorImageInfo *)(src + src_stride * j));
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
+      case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
+         for (j = 0; j < descriptor_count; ++j)
+            write_image_descriptor(dst + dst_stride * j, 64, (struct VkDescriptorImageInfo *)(src + src_stride * j));
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: {
+         const size_t descriptor_size = templ->entry[i].descriptor_size;
+         const bool has_sampler = templ->entry[i].has_sampler;
+         const uint32_t *immutable_samplers = templ->entry[i].immutable_samplers;
+         for (j = 0; j < descriptor_count; ++j)
+            write_combined_image_sampler_descriptor(dst + dst_stride * j, descriptor_size,
+                                                    (struct VkDescriptorImageInfo *)(src + src_stride * j), has_sampler,
+                                                    cmd_buffer && immutable_samplers, immutable_samplers, j);
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_SAMPLER: {
+         if (templ->entry[i].has_sampler) {
+            for (j = 0; j < descriptor_count; ++j) {
+               const VkDescriptorImageInfo *image_info = (struct VkDescriptorImageInfo *)(src + src_stride * j);
+               write_sampler_descriptor(dst + dst_stride * j, image_info->sampler);
             }
-            break;
-         case VK_DESCRIPTOR_TYPE_SAMPLER:
-            if (templ->entry[i].has_sampler) {
-               const VkDescriptorImageInfo *pImageInfo = (struct VkDescriptorImageInfo *)pSrc;
-               write_sampler_descriptor(pDst, pImageInfo->sampler);
-            } else if (cmd_buffer && templ->entry[i].immutable_samplers)
-               memcpy(pDst, templ->entry[i].immutable_samplers + 4 * j, 16);
-            break;
-         case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR: {
-            RADV_FROM_HANDLE(vk_acceleration_structure, accel_struct, *(const VkAccelerationStructureKHR *)pSrc);
-            write_accel_struct(device, pDst, accel_struct ? vk_acceleration_structure_get_va(accel_struct) : 0);
-            break;
+         } else if (cmd_buffer && templ->entry[i].immutable_samplers) {
+            const uint32_t *immutable_samplers = templ->entry[i].immutable_samplers;
+            for (j = 0; j < descriptor_count; ++j)
+               memcpy(dst + dst_stride * j, immutable_samplers + 4 * j, 16);
          }
-         default:
-            break;
+         break;
+      }
+      case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR: {
+         for (j = 0; j < descriptor_count; ++j) {
+            RADV_FROM_HANDLE(vk_acceleration_structure, accel_struct, *(const VkAccelerationStructureKHR *)(src + src_stride * j));
+            write_accel_struct(device, dst + dst_stride * j, accel_struct ? vk_acceleration_structure_get_va(accel_struct) : 0);
+         }
+         break;
+      }
+      default:
+         break;
+      }
+   }
+
+   if (!device->use_global_bo_list) {
+      struct radeon_winsys* ws = cmd_buffer ? device->ws : NULL;
+      struct radeon_cmdbuf* cs = cmd_buffer ? cmd_buffer->cs : NULL;
+      for (i = 0; i < templ->entry_count; ++i) {
+         const VkDescriptorType descriptor_type = templ->entry[i].descriptor_type;
+         const uint32_t descriptor_count = templ->entry[i].descriptor_count;
+         struct radeon_winsys_bo **buffer_list = set->descriptors + templ->entry[i].buffer_offset;
+         const uint8_t *pSrc = ((const uint8_t *)pData) + templ->entry[i].src_offset;
+         uint32_t j;
+
+         for (j = 0; j < descriptor_count; ++j) {
+            switch (descriptor_type) {
+               case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
+               case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
+               case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
+               case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: {
+                  const VkDescriptorBufferInfo *buffer_info = (struct VkDescriptorBufferInfo *)pSrc;
+                  RADV_FROM_HANDLE(radv_buffer, buffer, buffer_info->buffer);
+                  if (cmd_buffer && buffer) {
+                     radv_cs_add_buffer(ws, cs, buffer->bo);
+                  } else {
+                     *buffer_list++ = buffer ? buffer->bo : NULL;
+                  }
+                  break;
+               }
+               case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
+               case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
+                  const VkBufferView _buffer_view = *(VkBufferView *)pSrc;
+                  RADV_FROM_HANDLE(radv_buffer_view, buffer_view, _buffer_view);
+                  if (cmd_buffer && buffer_view) {
+                     radv_cs_add_buffer(ws, cs, buffer_view->bo);
+                  } else {
+                     *buffer_list++ = buffer_view ? buffer_view->bo : NULL;
+                  }
+                  break;
+               }
+               case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
+               case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
+               case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
+               case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: {
+                  const VkDescriptorImageInfo *image_info = (struct VkDescriptorImageInfo *)pSrc;
+                  RADV_FROM_HANDLE(radv_image_view, image_view, image_info->imageView);
+                  for (int b = 0; b < sizeof(image_view->image->bindings) / sizeof(image_view->image->bindings[0]); b++) {
+                     if (cmd_buffer && image_view) {
+                        if (image_view->image->bindings[b].bo)
+                           radv_cs_add_buffer(ws, cs, image_view->image->bindings[b].bo);
+                     } else {
+                        *buffer_list++ = image_view ? image_view->image->bindings[b].bo : NULL;
+                     }
+                  }
+                  break;
+               }
+               default: break;
+            }
          }
-         pSrc += templ->entry[i].src_stride;
-         pDst += templ->entry[i].dst_stride;
-         ++buffer_list;
       }
    }
 }
@@ -1724,33 +1849,34 @@ radv_GetDescriptorEXT(VkDevice _device, const VkDescriptorGetInfoEXT *pDescripto
    case VK_DESCRIPTOR_TYPE_SAMPLER: {
       write_sampler_descriptor(pDescriptor, *pDescriptorInfo->data.pSampler);
       break;
-   case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
-      write_image_descriptor(pDescriptor, 64, pDescriptorInfo->type, pDescriptorInfo->data.pCombinedImageSampler);
+   case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: {
+      write_image_descriptor(pDescriptor, 80, pDescriptorInfo->data.pCombinedImageSampler);
       if (pDescriptorInfo->data.pCombinedImageSampler) {
-         write_sampler_descriptor((uint32_t *)pDescriptor + 20, pDescriptorInfo->data.pCombinedImageSampler->sampler);
+         write_sampler_descriptor((uint32_t *)pDescriptor + 80 / 4, pDescriptorInfo->data.pCombinedImageSampler->sampler);
       }
       break;
-   case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
-      write_image_descriptor(pDescriptor, 64, pDescriptorInfo->type, pDescriptorInfo->data.pInputAttachmentImage);
+   }
+   case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: {
+      write_storage_image_descriptor(pDescriptor, 32, pDescriptorInfo->data.pStorageImage);
       break;
+   }
    case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
-      write_image_descriptor(pDescriptor, 64, pDescriptorInfo->type, pDescriptorInfo->data.pSampledImage);
-      break;
-   case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
-      write_image_descriptor(pDescriptor, 32, pDescriptorInfo->type, pDescriptorInfo->data.pStorageImage);
+   case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
+      write_image_descriptor(pDescriptor, 64, pDescriptorInfo->data.pSampledImage);
       break;
+   }
    case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: {
       const VkDescriptorAddressInfoEXT *addr_info = pDescriptorInfo->data.pUniformBuffer;

-      write_buffer_descriptor(device, pDescriptor, addr_info ? addr_info->address : 0,
-                              addr_info ? addr_info->range : 0);
+      write_buffer_descriptor(device->physical_device->rad_info.gfx_level, pDescriptor,
+                              addr_info ? addr_info->address : 0, addr_info ? addr_info->range : 0);
       break;
    }
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: {
       const VkDescriptorAddressInfoEXT *addr_info = pDescriptorInfo->data.pStorageBuffer;

-      write_buffer_descriptor(device, pDescriptor, addr_info ? addr_info->address : 0,
-                              addr_info ? addr_info->range : 0);
+      write_buffer_descriptor(device->physical_device->rad_info.gfx_level, pDescriptor,
+                              addr_info ? addr_info->address : 0, addr_info ? addr_info->range : 0);
       break;
    }
    case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: {
diff --git a/src/amd/vulkan/radv_descriptor_set.h b/src/amd/vulkan/radv_descriptor_set.h
index 710037b8d8d..f8a2c82491a 100644
--- a/src/amd/vulkan/radv_descriptor_set.h
+++ b/src/amd/vulkan/radv_descriptor_set.h
@@ -149,6 +149,7 @@ struct radv_descriptor_update_template_entry {

    /* The number of descriptors to update */
    uint32_t descriptor_count;
+   uint32_t descriptor_size;

    /* Into mapped_ptr or dynamic_descriptors, in units of the respective array */
    uint32_t dst_offset;
@@ -160,7 +161,6 @@ struct radv_descriptor_update_template_entry {

    /* Only valid for combined image samplers and samplers */
    uint8_t has_sampler;
-   uint8_t sampler_offset;

    /* In bytes */
    size_t src_offset;
--
2.43.0

