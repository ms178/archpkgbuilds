From aeb15e2830944e781aa792429f0dd97095918664 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 19 Jul 2022 13:37:10 +0200
Subject: [PATCH 1/7] radv: do not lower color exports for FS that need an
 epilog
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When building the main FS with GPL we don't know the color export
formats.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/vulkan/radv_pipeline.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 6d85551c730a..84641893e6ab 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -3889,6 +3889,9 @@ radv_lower_vs_input(nir_shader *nir, const struct radv_physical_device *pdevice,
 static bool
 radv_lower_fs_output(nir_shader *nir, const struct radv_pipeline_key *pipeline_key)
 {
+   if (pipeline_key->ps.has_epilog)
+      return false;
+
    nir_function_impl *impl = nir_shader_get_entrypoint(nir);
    bool progress = false;
 
-- 
GitLab


From ac01a834b27a8072356461f74581745d3ada8af0 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 16:08:50 +0200
Subject: [PATCH 2/7] radv: add radv_remove_color_export() helper
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/vulkan/radv_pipeline.c | 62 +++++++++++++++++++---------------
 1 file changed, 34 insertions(+), 28 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 84641893e6ab..3d4201763059 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2560,6 +2560,39 @@ radv_remove_point_size(const struct radv_pipeline_key *pipeline_key,
    NIR_PASS(_, producer, nir_opt_dce);
 }
 
+static void
+radv_remove_color_export(const struct radv_pipeline_key *pipeline_key, nir_shader *nir)
+{
+   bool fixup_derefs = false;
+
+   nir_foreach_shader_out_variable(var, nir) {
+      int idx = var->data.location;
+      idx -= FRAG_RESULT_DATA0;
+
+      if (idx < 0)
+         continue;
+
+      unsigned col_format = (pipeline_key->ps.col_format >> (4 * idx)) & 0xf;
+      unsigned cb_target_mask = (pipeline_key->ps.cb_target_mask >> (4 * idx)) & 0xf;
+
+      if (col_format == V_028714_SPI_SHADER_ZERO ||
+          (col_format == V_028714_SPI_SHADER_32_R && !cb_target_mask &&
+           !pipeline_key->ps.mrt0_is_dual_src)) {
+         /* Remove the color export if it's unused or in presence of holes. */
+         nir->info.outputs_written &= ~BITFIELD64_BIT(var->data.location);
+         var->data.location = 0;
+         var->data.mode = nir_var_shader_temp;
+         fixup_derefs = true;
+      }
+   }
+
+   if (fixup_derefs) {
+      NIR_PASS_V(nir, nir_fixup_deref_modes);
+      NIR_PASS(_, nir, nir_remove_dead_variables, nir_var_shader_temp, NULL);
+      NIR_PASS(_, nir, nir_opt_dce);
+   }
+}
+
 static void
 merge_tess_info(struct shader_info *tes_info, struct shader_info *tcs_info)
 {
@@ -2909,34 +2942,7 @@ radv_pipeline_link_fs(struct radv_pipeline_stage *fs_stage,
 {
    assert(fs_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-   bool fixup_derefs = false;
-
-   nir_foreach_shader_out_variable(var, fs_stage->nir) {
-      int idx = var->data.location;
-      idx -= FRAG_RESULT_DATA0;
-
-      if (idx < 0)
-         continue;
-
-      unsigned col_format = (pipeline_key->ps.col_format >> (4 * idx)) & 0xf;
-      unsigned cb_target_mask = (pipeline_key->ps.cb_target_mask >> (4 * idx)) & 0xf;
-
-      if (col_format == V_028714_SPI_SHADER_ZERO ||
-          (col_format == V_028714_SPI_SHADER_32_R && !cb_target_mask &&
-           !pipeline_key->ps.mrt0_is_dual_src)) {
-         /* Remove the color export if it's unused or in presence of holes. */
-         fs_stage->nir->info.outputs_written &= ~BITFIELD64_BIT(var->data.location);
-         var->data.location = 0;
-         var->data.mode = nir_var_shader_temp;
-         fixup_derefs = true;
-      }
-   }
-
-   if (fixup_derefs) {
-      NIR_PASS_V(fs_stage->nir, nir_fixup_deref_modes);
-      NIR_PASS(_, fs_stage->nir, nir_remove_dead_variables, nir_var_shader_temp, NULL);
-      NIR_PASS(_, fs_stage->nir, nir_opt_dce);
-   }
+   radv_remove_color_export(pipeline_key, fs_stage->nir);
 
    nir_foreach_shader_out_variable(var, fs_stage->nir) {
       var->data.driver_location = var->data.location + var->data.index;
-- 
GitLab


From 3594903fd57d9ee1bd4faff2dca6c458bd06d98d Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 19 Jul 2022 13:42:00 +0200
Subject: [PATCH 3/7] radv: do not try to remove color exports for FS that need
 an epilog
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The color format would be zero and all exports would be removed.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/amd/vulkan/radv_pipeline.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 3d4201763059..532336faa74b 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2942,7 +2942,10 @@ radv_pipeline_link_fs(struct radv_pipeline_stage *fs_stage,
 {
    assert(fs_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-   radv_remove_color_export(pipeline_key, fs_stage->nir);
+   if (!pipeline_key->ps.has_epilog) {
+      /* Only remove color exports when the format is known. */
+      radv_remove_color_export(pipeline_key, fs_stage->nir);
+   }
 
    nir_foreach_shader_out_variable(var, fs_stage->nir) {
       var->data.driver_location = var->data.location + var->data.index;
-- 
GitLab


From 58a1fe38e74161a7d9b9a50288f25aefaf1c8f59 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 17:14:23 +0200
Subject: [PATCH 4/7] radv: keep track of the code size for VS prologs and PS
 epilogs

This will be used to prefetch PS epilogs.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_shader.c | 1 +
 src/amd/vulkan/radv_shader.h | 1 +
 2 files changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 1653bae61fe1..837e614645f9 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2347,6 +2347,7 @@ upload_shader_part(struct radv_device *device, struct radv_shader_part_binary *b
       return NULL;
 
    shader_part->ref_count = 1;
+   shader_part->code_size = code_size;
 
    shader_part->alloc = radv_alloc_shader_memory(device, code_size, NULL);
    if (!shader_part->alloc) {
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index bde2d0dd3b4c..359710441bed 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -504,6 +504,7 @@ struct radv_shader_part {
 
    struct radeon_winsys_bo *bo;
    union radv_shader_arena_block *alloc;
+   uint32_t code_size;
    uint32_t rsrc1;
    uint8_t num_preserved_sgprs;
    bool nontrivial_divisors;
-- 
GitLab


From 92862034887385b26444356c14adeeb1d790d19b Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 17:17:32 +0200
Subject: [PATCH 5/7] radv: create a PS epilog from a library without the main
 FS

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 34 +++++++++++++++++++++++++++++++---
 src/amd/vulkan/radv_private.h  |  3 +++
 2 files changed, 34 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 532336faa74b..c32a86af6ce4 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -227,6 +227,9 @@ radv_pipeline_destroy(struct radv_device *device, struct radv_pipeline *pipeline
          ralloc_free(pipeline->retained_shaders[i].nir);
       }
 
+      if (gfx_pipeline_lib->base.ps_epilog)
+         radv_shader_part_unref(device, gfx_pipeline_lib->base.ps_epilog);
+
       vk_free(&device->vk.alloc, gfx_pipeline_lib->base.state_data);
    }
 
@@ -6798,10 +6801,32 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
    result = radv_pipeline_import_graphics_info(&pipeline->base, state, pipeline_layout, pCreateInfo,
                                                imported_flags);
    if (result != VK_SUCCESS)
-      goto fail;
+      goto fail_layout;
 
    radv_pipeline_layout_hash(pipeline_layout);
 
+   /* Compile a PS epilog if the fragment shader output interface is present without the main
+    * fragment shader.
+    */
+   if ((imported_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT) &&
+       !(imported_flags & VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT)) {
+      struct radv_blend_state blend =
+         radv_pipeline_init_blend_state(&pipeline->base, state);
+
+      struct radv_pipeline_key key =
+         radv_generate_graphics_pipeline_key(&pipeline->base, pCreateInfo, state, &blend);
+
+      struct radv_ps_epilog_key epilog_key = {0};
+      epilog_key.spi_shader_col_format = blend.spi_shader_col_format;
+      epilog_key.color_is_int8 = blend.col_format_is_int8;
+      epilog_key.color_is_int10 = blend.col_format_is_int10;
+      epilog_key.enable_mrt_output_nan_fixup = key.ps.enable_mrt_output_nan_fixup;
+
+      pipeline->base.ps_epilog = radv_create_ps_epilog(device, &epilog_key);
+      if (!pipeline->base.ps_epilog)
+         goto fail_layout;
+   }
+
    if (pipeline->base.active_stages != 0) {
       const VkPipelineCreationFeedbackCreateInfo *creation_feedback =
          vk_find_struct_const(pCreateInfo->pNext, PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
@@ -6824,12 +6849,15 @@ radv_graphics_lib_pipeline_init(struct radv_graphics_lib_pipeline *pipeline,
                                    creation_feedback, NULL, NULL,
                                    &pipeline->base.last_vgt_api_stage);
       if (result != VK_SUCCESS && result != VK_PIPELINE_COMPILE_REQUIRED)
-         goto fail;
+         goto fail_shaders;
    }
 
    return VK_SUCCESS;
 
-fail:
+fail_shaders:
+   if (pipeline->base.ps_epilog)
+      radv_shader_part_unref(device, pipeline->base.ps_epilog);
+fail_layout:
    radv_pipeline_layout_finish(device, pipeline_layout);
    return result;
 }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index e5172811a9af..610f42c86e99 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2035,6 +2035,9 @@ struct radv_graphics_pipeline {
 
    /* For vk_graphics_pipeline_state */
    void *state_data;
+
+   /* Not NULL if graphics pipeline uses a PS epilog. */
+   struct radv_shader_part *ps_epilog;
 };
 
 struct radv_compute_pipeline {
-- 
GitLab


From 33dd4d5e7ffb54986fc5f1cf3ffdad4d4ee2a7e4 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 17:14:58 +0200
Subject: [PATCH 6/7] radv: add support for emitting and prefetching PS epilogs

Long jumps seem to be slow and prefetching might help.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 45 +++++++++++++++++++++++++++++++-
 1 file changed, 44 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 9ca620a22f11..082b83400ed5 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1219,8 +1219,15 @@ radv_emit_prefetch_L2(struct radv_cmd_buffer *cmd_buffer,
          radv_emit_shader_prefetch(cmd_buffer, pipeline->base.gs_copy_shader);
    }
 
-   if (mask & RADV_PREFETCH_PS)
+   if (mask & RADV_PREFETCH_PS) {
       radv_emit_shader_prefetch(cmd_buffer, pipeline->base.shaders[MESA_SHADER_FRAGMENT]);
+      if (pipeline->ps_epilog) {
+         struct radv_shader_part *ps_epilog = pipeline->ps_epilog;
+         uint64_t va = radv_buffer_get_va(ps_epilog->bo) + ps_epilog->alloc->offset;
+
+         si_cp_dma_prefetch(cmd_buffer, va, ps_epilog->code_size);
+      }
+   }
 
    state->prefetch_L2_mask &= ~mask;
 }
@@ -1391,6 +1398,40 @@ radv_emit_rbplus_state(struct radv_cmd_buffer *cmd_buffer)
    cmd_buffer->state.last_sx_blend_opt_control = sx_blend_opt_control;
 }
 
+static void
+radv_emit_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
+{
+   struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   struct radv_shader *ps_shader = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
+   struct radv_shader_part *ps_epilog = pipeline->ps_epilog;
+   uint64_t ps_epilog_va;
+   unsigned offset;
+
+   if (!ps_epilog)
+      return;
+
+   /* The main shader must not use less VGPRs than the epilog, otherwise shared vgprs might not
+    * work.
+    */
+   assert(G_00B848_VGPRS(ps_shader->config.rsrc1) >= G_00B848_VGPRS(ps_epilog->rsrc1));
+
+   radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, ps_epilog->bo);
+
+   ps_epilog_va = radv_buffer_get_va(ps_epilog->bo) + ps_epilog->alloc->offset;
+   assert((ps_epilog_va >> 32) == cmd_buffer->device->physical_device->rad_info.address32_hi);
+
+   if (!radv_cmd_buffer_upload_data(cmd_buffer, 4, &ps_epilog_va, &offset))
+      return;
+
+   struct radv_userdata_info *loc =
+      &ps_shader->info.user_sgprs_locs.shader_data[AC_UD_PS_EPILOG_PC];
+   uint32_t base_reg = pipeline->base.user_data_0[MESA_SHADER_FRAGMENT];
+   assert(loc->sgpr_idx != -1);
+   assert(loc->num_sgprs == 1);
+   radv_emit_shader_pointer(cmd_buffer->device, cmd_buffer->cs, base_reg + loc->sgpr_idx * 4,
+                            ps_epilog_va, false);
+}
+
 static void
 radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -1483,6 +1524,8 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       }
    }
 
+   radv_emit_ps_epilog(cmd_buffer);
+
    radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, pipeline->base.slab_bo);
 
    if (unlikely(cmd_buffer->device->trace_bo))
-- 
GitLab


From 457eeb8fc9e476f1f094e31ebccd7d7e3ebc4004 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 17:19:12 +0200
Subject: [PATCH 7/7] radv: import PS epilog from libraries if present

This enables using PS epilogs with GPL.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index c32a86af6ce4..6e3c8686bab2 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -197,6 +197,9 @@ radv_pipeline_destroy(struct radv_device *device, struct radv_pipeline *pipeline
    if (pipeline->type == RADV_PIPELINE_GRAPHICS) {
       struct radv_graphics_pipeline *graphics_pipeline = radv_pipeline_to_graphics(pipeline);
 
+      if (graphics_pipeline->ps_epilog)
+         radv_shader_part_unref(device, graphics_pipeline->ps_epilog);
+
       vk_free(&device->vk.alloc, graphics_pipeline->state_data);
    } else if (pipeline->type == RADV_PIPELINE_COMPUTE) {
       struct radv_compute_pipeline *compute_pipeline = radv_pipeline_to_compute(pipeline);
@@ -1592,6 +1595,12 @@ radv_graphics_pipeline_import_lib(struct radv_graphics_pipeline *pipeline,
       pipeline->base.retained_shaders[s] = lib->base.base.retained_shaders[s];
    }
 
+   /* Import the PS epilog if present. */
+   if (lib->base.ps_epilog) {
+      assert(!pipeline->ps_epilog);
+      pipeline->ps_epilog = radv_shader_part_ref(lib->base.ps_epilog);
+   }
+
    /* Import the pipeline layout. */
    struct radv_pipeline_layout *lib_layout = &lib->layout;
    for (uint32_t s = 0; s < lib_layout->num_sets; s++) {
@@ -3136,7 +3145,8 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
    if (device->primitives_generated_query)
       key.primitives_generated_query = true;
 
-   key.ps.has_epilog = false; /* TODO: hook up PS epilogs */
+   if (pipeline->ps_epilog)
+      key.ps.has_epilog = true;
 
    return key;
 }
-- 
GitLab

