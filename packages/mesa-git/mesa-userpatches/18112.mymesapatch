From ad4b04311a7ba24290c1ab1da815f72b510ae455 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 15 Aug 2022 21:42:05 +0200
Subject: [PATCH 1/2] aco: implement custom instruction allocator

This basic allocator implements an arena allocation strategy
and cannot free individual allocations.
All allocated memory must be freed at once.
---
 src/amd/compiler/aco_util.h | 43 +++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 2b32e94a805f..82bdb1161552 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -379,6 +379,49 @@ IDSet::Iterator::operator*() const
    return (word << 6) | bit;
 }
 
+/*
+ * Small memory allocator which implements an arena allocation scheme.
+ * Only suited for small allocations up to pool_size.
+ */
+template <size_t pool_size> struct ArenaAllocator {
+   struct Arena {
+      Arena* next;
+      uint32_t data[];
+   };
+
+   void* allocate(size_t size)
+   {
+      assert(size % 4 == 0);
+      uint32_t alloc_size = size / 4;
+      assert(alloc_size <= num_dwords);
+
+      if (!heap || zero_pos + alloc_size > num_dwords) {
+         Arena* next = heap;
+         heap = (Arena*)malloc(pool_size);
+         heap->next = next;
+         zero_pos = 0;
+      }
+
+      void* ptr = &heap->data[zero_pos];
+      zero_pos += alloc_size;
+      return ptr;
+   }
+
+   void deallocateAll()
+   {
+      while (heap) {
+         void* to_delete = heap;
+         heap = heap->next;
+         free(to_delete);
+      }
+   }
+
+private:
+   Arena* heap;
+   uint32_t zero_pos;
+   static constexpr size_t num_dwords = (pool_size - sizeof(Arena)) / sizeof(uint32_t);
+};
+
 } // namespace aco
 
 #endif // ACO_UTIL_H
-- 
GitLab


From 8b7d9ce4c5598d8d921ea579f9c825273cada7a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Mon, 15 Aug 2022 21:42:19 +0200
Subject: [PATCH 2/2] aco: use custom instruction allocator

---
 src/amd/compiler/aco_interface.cpp |  6 ++++++
 src/amd/compiler/aco_ir.cpp        |  2 ++
 src/amd/compiler/aco_ir.h          | 12 +++++++++---
 3 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_interface.cpp b/src/amd/compiler/aco_interface.cpp
index 03544424c2e7..014388b0d8f9 100644
--- a/src/amd/compiler/aco_interface.cpp
+++ b/src/amd/compiler/aco_interface.cpp
@@ -257,6 +257,8 @@ aco_compile_shader(const struct aco_compiler_options* options,
    if (program->collect_statistics)
       stats_size = aco::num_statistics * sizeof(uint32_t);
 
+   aco::instruction_allocator.deallocateAll();
+
    (*build_binary)(binary,
                    shaders[shader_count - 1]->info.stage,
                    args->is_gs_copy_shader,
@@ -308,6 +310,8 @@ aco_compile_vs_prolog(const struct aco_compiler_options* options,
    if (get_disasm)
       disasm = get_disasm_string(program.get(), code, exec_size);
 
+   aco::instruction_allocator.deallocateAll();
+
    (*build_prolog)(binary,
                    config.num_sgprs,
                    config.num_vgprs,
@@ -353,6 +357,8 @@ aco_compile_ps_epilog(const struct aco_compiler_options* options,
    if (get_disasm)
       disasm = get_disasm_string(program.get(), code, exec_size);
 
+   aco::instruction_allocator.deallocateAll();
+
    (*build_epilog)(binary,
                    config.num_sgprs,
                    config.num_vgprs,
diff --git a/src/amd/compiler/aco_ir.cpp b/src/amd/compiler/aco_ir.cpp
index dd0c5960e8a0..32892e4a7a8f 100644
--- a/src/amd/compiler/aco_ir.cpp
+++ b/src/amd/compiler/aco_ir.cpp
@@ -32,6 +32,8 @@
 
 namespace aco {
 
+thread_local aco::ArenaAllocator<65536> instruction_allocator{};
+
 uint64_t debug_flags = 0;
 
 static const struct debug_control aco_debug_options[] = {{"validateir", DEBUG_VALIDATE_IR},
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 89fd0dd7e27c..02151755037f 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1725,8 +1725,13 @@ struct Pseudo_reduction_instruction : public Instruction {
 static_assert(sizeof(Pseudo_reduction_instruction) == sizeof(Instruction) + 4,
               "Unexpected padding");
 
+extern thread_local aco::ArenaAllocator<65536> instruction_allocator;
+
 struct instr_deleter_functor {
-   void operator()(void* p) { free(p); }
+   /* Don't yet free any instructions. They will be de-allocated
+    * all at once after compilation finished.
+    */
+   void operator()(void* p) { return; }
 };
 
 template <typename T> using aco_ptr = std::unique_ptr<T, instr_deleter_functor>;
@@ -1738,13 +1743,14 @@ create_instruction(aco_opcode opcode, Format format, uint32_t num_operands,
 {
    std::size_t size =
       sizeof(T) + num_operands * sizeof(Operand) + num_definitions * sizeof(Definition);
-   char* data = (char*)calloc(1, size);
+   void* data = instruction_allocator.allocate(size);
+   memset(data, 0, size);
    T* inst = (T*)data;
 
    inst->opcode = opcode;
    inst->format = format;
 
-   uint16_t operands_offset = data + sizeof(T) - (char*)&inst->operands;
+   uint16_t operands_offset = sizeof(T) - offsetof(Instruction, operands);
    inst->operands = aco::span<Operand>(operands_offset, num_operands);
    uint16_t definitions_offset = (char*)inst->operands.end() - (char*)&inst->definitions;
    inst->definitions = aco::span<Definition>(definitions_offset, num_definitions);
-- 
GitLab

