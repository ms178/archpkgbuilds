From f1bf932beda21f90e61ef14c4035dc2e4be6d7bf Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Mon, 30 Oct 2023 14:39:13 -0700
Subject: [PATCH 1/5] radv: fix VkDrmFormatModifierProperties2EXT for
 multi-planar formats

Do not report DCC modifiers for multi-planar formats.  We don't support
DCC for them and drmFormatModifierPlaneCount had incorrect values.

Fix vkGetImageSubresourceLayout for multi-planar images with modifiers.
In that case, memory planes and format planes are equivalent.
---
 src/amd/vulkan/radv_formats.c | 26 ++++++++++----------------
 1 file changed, 10 insertions(+), 16 deletions(-)

diff --git a/src/amd/vulkan/radv_formats.c b/src/amd/vulkan/radv_formats.c
index 5646a8fa1e54..8c43f3bc57f5 100644
--- a/src/amd/vulkan/radv_formats.c
+++ b/src/amd/vulkan/radv_formats.c
@@ -1091,6 +1091,10 @@ radv_get_modifier_flags(struct radv_physical_device *dev, VkFormat format, uint6
    features &= ~VK_FORMAT_FEATURE_2_DISJOINT_BIT;
 
    if (ac_modifier_has_dcc(modifier)) {
+      /* We don't enable DCC for multi-planar formats */
+      if (vk_format_get_plane_count(format) > 1)
+         return 0;
+
       /* Only disable support for STORAGE_IMAGE on modifiers that
        * do not support DCC image stores.
        */
@@ -1136,17 +1140,12 @@ radv_list_drm_format_modifiers(struct radv_physical_device *dev, VkFormat format
 
    for (unsigned i = 0; i < mod_count; ++i) {
       VkFormatFeatureFlags2 features = radv_get_modifier_flags(dev, format, mods[i], format_props);
-      unsigned planes = vk_format_get_plane_count(format);
-      if (planes == 1) {
-         if (ac_modifier_has_dcc_retile(mods[i]))
-            planes = 3;
-         else if (ac_modifier_has_dcc(mods[i]))
-            planes = 2;
-      }
-
       if (!features)
          continue;
 
+      unsigned planes =
+         vk_format_get_plane_count(format) + ac_modifier_has_dcc(mods[i]) + ac_modifier_has_dcc_retile(mods[i]);
+
       vk_outarray_append_typed(VkDrmFormatModifierPropertiesEXT, &out, out_props)
       {
          *out_props = (VkDrmFormatModifierPropertiesEXT){
@@ -1192,17 +1191,12 @@ radv_list_drm_format_modifiers_2(struct radv_physical_device *dev, VkFormat form
 
    for (unsigned i = 0; i < mod_count; ++i) {
       VkFormatFeatureFlags2 features = radv_get_modifier_flags(dev, format, mods[i], format_props);
-      unsigned planes = vk_format_get_plane_count(format);
-      if (planes == 1) {
-         if (ac_modifier_has_dcc_retile(mods[i]))
-            planes = 3;
-         else if (ac_modifier_has_dcc(mods[i]))
-            planes = 2;
-      }
-
       if (!features)
          continue;
 
+      unsigned planes =
+         vk_format_get_plane_count(format) + ac_modifier_has_dcc(mods[i]) + ac_modifier_has_dcc_retile(mods[i]);
+
       vk_outarray_append_typed(VkDrmFormatModifierProperties2EXT, &out, out_props)
       {
          *out_props = (VkDrmFormatModifierProperties2EXT){
-- 
GitLab


From 9ce8e4eef297c07c037bf2d31d2a460f4deefc6d Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Mon, 30 Oct 2023 14:39:13 -0700
Subject: [PATCH 2/5] radv: fix VkSubresourceLayout2KHR for multi-planar
 formats with modifiers

Memory planes and format planes are equivalent for multi-planar formats
with modifiers.  Do not return the DCC info of plane 0.
---
 src/amd/vulkan/radv_image.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 1663c65ec96e..09c2a2a063eb 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -2499,14 +2499,15 @@ radv_GetImageSubresourceLayout2KHR(VkDevice _device, VkImage _image, const VkIma
    int level = pSubresource->imageSubresource.mipLevel;
    int layer = pSubresource->imageSubresource.arrayLayer;
 
+   const unsigned plane_count = vk_format_get_plane_count(image->vk.format);
    unsigned plane_id = 0;
-   if (vk_format_get_plane_count(image->vk.format) > 1)
+   if (plane_count > 1)
       plane_id = radv_plane_from_aspect(pSubresource->imageSubresource.aspectMask);
 
    struct radv_image_plane *plane = &image->planes[plane_id];
    struct radeon_surf *surface = &plane->surface;
 
-   if (image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
+   if (image->vk.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT && plane_count == 1) {
       unsigned mem_plane_id = radv_plane_from_aspect(pSubresource->imageSubresource.aspectMask);
 
       assert(level == 0);
-- 
GitLab


From 073d5c4a81c7069b1a80859aef11cd2acbd9ccd6 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Thu, 2 Nov 2023 16:06:24 -0700
Subject: [PATCH 3/5] radv: fix a typo in radv_image_view_make_descriptor

Only GFX8 and before have legacy_surf_level.
---
 src/amd/vulkan/radv_image.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 09c2a2a063eb..830fea0a0aad 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -2041,7 +2041,7 @@ radv_image_view_make_descriptor(struct radv_image_view *iview, struct radv_devic
                                 img_create_flags, nbc_view, sliced_3d);
 
    const struct legacy_surf_level *base_level_info = NULL;
-   if (device->physical_device->rad_info.gfx_level <= GFX9) {
+   if (device->physical_device->rad_info.gfx_level <= GFX8) {
       if (is_stencil)
          base_level_info = &plane->surface.u.legacy.zs.stencil_level[iview->vk.base_mip_level];
       else
-- 
GitLab


From bb8f0b26d2d6b544072b174725b17e47ceb22270 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Mon, 30 Oct 2023 14:04:13 -0700
Subject: [PATCH 4/5] radv: fix asserts for radv_init_metadata

radv_init_metadata hits several assert failures when the image is
multi-planar.  Make sure we use plane 0.

This change should make no difference in practice.  Also, this is done
only to follow radeonsi.  Since the opaque metadata is mainly for
validations and DCC, and we don't enable DCC for multi-planar images, we
probably don't need to call radv_query_opaque_metadata at all.
---
 src/amd/vulkan/radv_image.c | 32 +++++++++++++++++++-------------
 1 file changed, 19 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_image.c b/src/amd/vulkan/radv_image.c
index 830fea0a0aad..85be685a5936 100644
--- a/src/amd/vulkan/radv_image.c
+++ b/src/amd/vulkan/radv_image.c
@@ -1383,30 +1383,36 @@ radv_make_texture_descriptor(struct radv_device *device, struct radv_image *imag
 }
 
 static void
-radv_query_opaque_metadata(struct radv_device *device, struct radv_image *image, struct radeon_bo_metadata *md)
+radv_query_opaque_metadata(struct radv_device *device, struct radv_image *image, unsigned plane_id,
+                           struct radeon_bo_metadata *md)
 {
    static const VkComponentMapping fixedmapping;
+   const VkFormat plane_format = radv_image_get_plane_format(device->physical_device, image, plane_id);
+   const unsigned plane_width = vk_format_get_plane_width(image->vk.format, plane_id, image->vk.extent.width);
+   const unsigned plane_height = vk_format_get_plane_height(image->vk.format, plane_id, image->vk.extent.height);
+   struct radeon_surf *surface = &image->planes[plane_id].surface;
+   const struct legacy_surf_level *base_level_info =
+      device->physical_device->rad_info.gfx_level <= GFX8 ? &surface->u.legacy.level[0] : NULL;
    uint32_t desc[8];
 
-   assert(image->plane_count == 1);
+   radv_make_texture_descriptor(device, image, false, (VkImageViewType)image->vk.image_type, plane_format,
+                                &fixedmapping, 0, image->vk.mip_levels - 1, 0, image->vk.array_layers - 1, plane_width,
+                                plane_height, image->vk.extent.depth, 0.0f, desc, NULL, 0, NULL, NULL);
 
-   radv_make_texture_descriptor(device, image, false, (VkImageViewType)image->vk.image_type, image->vk.format,
-                                &fixedmapping, 0, image->vk.mip_levels - 1, 0, image->vk.array_layers - 1,
-                                image->vk.extent.width, image->vk.extent.height, image->vk.extent.depth, 0.0f, desc,
-                                NULL, 0, NULL, NULL);
+   si_set_mutable_tex_desc_fields(device, image, base_level_info, plane_id, 0, 0, surface->blk_w, false, false, false,
+                                  false, desc, NULL);
 
-   si_set_mutable_tex_desc_fields(device, image, &image->planes[0].surface.u.legacy.level[0], 0, 0, 0,
-                                  image->planes[0].surface.blk_w, false, false, false, false, desc, NULL);
-
-   ac_surface_compute_umd_metadata(&device->physical_device->rad_info, &image->planes[0].surface, image->vk.mip_levels,
-                                   desc, &md->size_metadata, md->metadata,
+   ac_surface_compute_umd_metadata(&device->physical_device->rad_info, surface, image->vk.mip_levels, desc,
+                                   &md->size_metadata, md->metadata,
                                    device->instance->debug_flags & RADV_DEBUG_EXTRA_MD);
 }
 
 void
 radv_init_metadata(struct radv_device *device, struct radv_image *image, struct radeon_bo_metadata *metadata)
 {
-   struct radeon_surf *surface = &image->planes[0].surface;
+   /* use plane 0, even when there are multiple planes, to follow radeonsi */
+   const unsigned plane_id = 0;
+   struct radeon_surf *surface = &image->planes[plane_id].surface;
 
    memset(metadata, 0, sizeof(*metadata));
 
@@ -1434,7 +1440,7 @@ radv_init_metadata(struct radv_device *device, struct radv_image *image, struct
       metadata->u.legacy.stride = surface->u.legacy.level[0].nblk_x * surface->bpe;
       metadata->u.legacy.scanout = (surface->flags & RADEON_SURF_SCANOUT) != 0;
    }
-   radv_query_opaque_metadata(device, image, metadata);
+   radv_query_opaque_metadata(device, image, plane_id, metadata);
 }
 
 void
-- 
GitLab


From 0c21d2a1bea9c0042864beaa4a6d845f841963d3 Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Mon, 30 Oct 2023 14:31:17 -0700
Subject: [PATCH 5/5] radv: convert a check in radv_get_memory_fd to assert

VUID-VkBindImageMemoryInfo-memory-02628 and
VUID-VkBindImageMemoryInfo-memory-02629 make sure the memory offset is 0
for dedicated allocations.
---
 src/amd/vulkan/radv_device.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 73783403f5bf..402a3bb4f7dc 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1285,9 +1285,13 @@ radv_DestroyDevice(VkDevice _device, const VkAllocationCallbacks *pAllocator)
 bool
 radv_get_memory_fd(struct radv_device *device, struct radv_device_memory *memory, int *pFD)
 {
-   /* Only set BO metadata for the first plane */
-   if (memory->image && memory->image->bindings[0].offset == 0) {
+   /* Set BO metadata for dedicated image allocations.  We don't need it for import when the image
+    * tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, but we set it anyway for foreign consumers.
+    */
+   if (memory->image) {
       struct radeon_bo_metadata metadata;
+
+      assert(memory->image->bindings[0].offset == 0);
       radv_init_metadata(device, memory->image, &metadata);
       device->ws->buffer_set_metadata(device->ws, memory->bo, &metadata);
    }
-- 
GitLab

