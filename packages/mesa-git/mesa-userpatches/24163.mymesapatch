From 7e4a6b1dd4488101b4f9014edfb447e2520a8295 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 14 Jul 2023 12:18:05 -0400
Subject: [PATCH 1/3] nir: fix slot calculations for compact variables with
 location_frac

a variable with a component offset may span multiple slots, and this cannot
be inferred from its type alone (e.g., compacted clip+cull distances)

cc: mesa-stable
---
 src/compiler/nir/nir_gather_info.c            | 4 ++--
 src/freedreno/vulkan/tu_shader.cc             | 2 +-
 src/gallium/auxiliary/nir/nir_to_tgsi_info.c  | 4 ++--
 src/gallium/frontends/lavapipe/lvp_pipeline.c | 2 +-
 src/intel/compiler/brw_fs_nir.cpp             | 2 +-
 5 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/compiler/nir/nir_gather_info.c b/src/compiler/nir/nir_gather_info.c
index 719d72c8c36d2..4093dbdb31357 100644
--- a/src/compiler/nir/nir_gather_info.c
+++ b/src/compiler/nir/nir_gather_info.c
@@ -211,7 +211,7 @@ mark_whole_variable(nir_shader *shader, nir_variable *var,
    }
 
    const unsigned slots =
-      var->data.compact ? DIV_ROUND_UP(glsl_get_length(type), 4)
+      var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(type), 4)
                         : glsl_count_attribute_slots(type, false);
 
    set_io_mask(shader, var, 0, slots, deref, is_output_read);
@@ -288,7 +288,7 @@ try_mask_partial_io(nir_shader *shader, nir_variable *var,
       return false;
 
    const unsigned slots =
-      var->data.compact ? DIV_ROUND_UP(glsl_get_length(type), 4)
+      var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(type), 4)
                         : glsl_count_attribute_slots(type, false);
 
    if (offset >= slots) {
diff --git a/src/freedreno/vulkan/tu_shader.cc b/src/freedreno/vulkan/tu_shader.cc
index 6620c6c1c5756..90cb01860a272 100644
--- a/src/freedreno/vulkan/tu_shader.cc
+++ b/src/freedreno/vulkan/tu_shader.cc
@@ -927,7 +927,7 @@ tu_gather_xfb_info(nir_shader *nir, struct ir3_stream_output_info *info)
 
    nir_foreach_shader_out_variable(var, nir) {
       unsigned slots =
-         var->data.compact ? DIV_ROUND_UP(glsl_get_length(var->type), 4)
+         var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(var->type), 4)
                            : glsl_count_attribute_slots(var->type, false);
       for (unsigned i = 0; i < slots; i++)
          output_map[var->data.location + i] = var->data.driver_location + i;
diff --git a/src/gallium/auxiliary/nir/nir_to_tgsi_info.c b/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
index d8d5d0e16d87f..48c80b583839c 100644
--- a/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
+++ b/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
@@ -477,7 +477,7 @@ void nir_tgsi_scan_shader(const struct nir_shader *nir,
          type = glsl_get_array_element(type);
       }
 
-      unsigned attrib_count = variable->data.compact ? DIV_ROUND_UP(glsl_get_length(type), 4) :
+      unsigned attrib_count = variable->data.compact ? DIV_ROUND_UP(variable->data.location_frac + glsl_get_length(type), 4) :
          glsl_count_attribute_slots(type, nir->info.stage == MESA_SHADER_VERTEX);
 
       i = variable->data.driver_location;
@@ -577,7 +577,7 @@ void nir_tgsi_scan_shader(const struct nir_shader *nir,
          type = glsl_get_array_element(type);
       }
 
-      unsigned attrib_count = variable->data.compact ? DIV_ROUND_UP(glsl_get_length(type), 4) :
+      unsigned attrib_count = variable->data.compact ? DIV_ROUND_UP(variable->data.location_frac + glsl_get_length(type), 4) :
          glsl_count_attribute_slots(type, false);
       for (unsigned k = 0; k < attrib_count; k++, i++) {
 
diff --git a/src/gallium/frontends/lavapipe/lvp_pipeline.c b/src/gallium/frontends/lavapipe/lvp_pipeline.c
index 3fb8d47b1b236..99d440d914238 100644
--- a/src/gallium/frontends/lavapipe/lvp_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_pipeline.c
@@ -527,7 +527,7 @@ lvp_shader_xfb_init(struct lvp_shader *shader)
       memset(output_mapping, 0, sizeof(output_mapping));
 
       nir_foreach_shader_out_variable(var, shader->pipeline_nir->nir) {
-         unsigned slots = var->data.compact ? DIV_ROUND_UP(glsl_get_length(var->type), 4)
+         unsigned slots = var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(var->type), 4)
                                             : glsl_count_attribute_slots(var->type, false);
          for (unsigned i = 0; i < slots; i++)
             output_mapping[var->data.location + i] = var->data.driver_location + i;
diff --git a/src/intel/compiler/brw_fs_nir.cpp b/src/intel/compiler/brw_fs_nir.cpp
index 5aea644f3425a..74df7fa304e6d 100644
--- a/src/intel/compiler/brw_fs_nir.cpp
+++ b/src/intel/compiler/brw_fs_nir.cpp
@@ -70,7 +70,7 @@ fs_visitor::nir_setup_outputs()
    nir_foreach_shader_out_variable(var, nir) {
       const int loc = var->data.driver_location;
       const unsigned var_vec4s =
-         var->data.compact ? DIV_ROUND_UP(glsl_get_length(var->type), 4)
+         var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(var->type), 4)
                            : type_size_vec4(var->type, true);
       vec4s[loc] = MAX2(vec4s[loc], var_vec4s);
    }
-- 
GitLab


From 09b197a1b54f6b2eb39feda3f666fef89ac10329 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 14 Jul 2023 12:19:45 -0400
Subject: [PATCH 2/3] lavapipe: use the component offset directly for xfb

the mask is only indicative of the components being used, not the offset
from which they start

cc: mesa-stable
---
 src/gallium/frontends/lavapipe/lvp_pipeline.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/frontends/lavapipe/lvp_pipeline.c b/src/gallium/frontends/lavapipe/lvp_pipeline.c
index 99d440d914238..c66cc313dfc08 100644
--- a/src/gallium/frontends/lavapipe/lvp_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_pipeline.c
@@ -544,7 +544,7 @@ lvp_shader_xfb_init(struct lvp_shader *shader)
          shader->stream_output.output[i].dst_offset = xfb_info->outputs[i].offset / 4;
          shader->stream_output.output[i].register_index = output_mapping[xfb_info->outputs[i].location];
          shader->stream_output.output[i].num_components = util_bitcount(xfb_info->outputs[i].component_mask);
-         shader->stream_output.output[i].start_component = ffs(xfb_info->outputs[i].component_mask) - 1;
+         shader->stream_output.output[i].start_component = xfb_info->outputs[i].component_offset;
          shader->stream_output.output[i].stream = xfb_info->buffer_to_stream[xfb_info->outputs[i].buffer];
       }
 
-- 
GitLab


From 5d627eeb9a719a89a6bbde98bae383d15fd0bca7 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 14 Jul 2023 12:24:51 -0400
Subject: [PATCH 3/3] nir: add a helper for calculating variable slots

this will maybe avoid future bugs, but probably not
---
 src/compiler/nir/nir.h                        |  8 ++++++++
 src/compiler/nir/nir_gather_info.c            | 10 ++--------
 src/freedreno/vulkan/tu_shader.cc             |  4 +---
 src/gallium/auxiliary/nir/nir_to_tgsi_info.c  |  6 ++----
 src/gallium/frontends/lavapipe/lvp_pipeline.c |  3 +--
 src/intel/compiler/brw_fs_nir.cpp             |  4 +---
 6 files changed, 15 insertions(+), 20 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 373222b076f09..af07f22109178 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -6188,6 +6188,14 @@ nir_variable_is_in_block(const nir_variable *var)
    return nir_variable_is_in_ubo(var) || nir_variable_is_in_ssbo(var);
 }
 
+static inline unsigned
+nir_variable_count_slots(const nir_shader *nir, const nir_variable *var, const struct glsl_type *type)
+{
+   return var->data.compact ?
+          DIV_ROUND_UP(var->data.location_frac + glsl_get_length(type), 4) :
+          glsl_count_attribute_slots(type, nir->info.stage == MESA_SHADER_VERTEX && var->data.mode & nir_var_shader_in);
+}
+
 /* See default_ub_config in nir_range_analysis.c for documentation. */
 typedef struct nir_unsigned_upper_bound_config {
    unsigned min_subgroup_size;
diff --git a/src/compiler/nir/nir_gather_info.c b/src/compiler/nir/nir_gather_info.c
index 4093dbdb31357..864d03e4a29fa 100644
--- a/src/compiler/nir/nir_gather_info.c
+++ b/src/compiler/nir/nir_gather_info.c
@@ -210,10 +210,7 @@ mark_whole_variable(nir_shader *shader, nir_variable *var,
       type = glsl_get_array_element(type);
    }
 
-   const unsigned slots =
-      var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(type), 4)
-                        : glsl_count_attribute_slots(type, false);
-
+   const unsigned slots = nir_variable_count_slots(shader, var, type);
    set_io_mask(shader, var, 0, slots, deref, is_output_read);
 }
 
@@ -287,10 +284,7 @@ try_mask_partial_io(nir_shader *shader, nir_variable *var,
    if (offset == -1)
       return false;
 
-   const unsigned slots =
-      var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(type), 4)
-                        : glsl_count_attribute_slots(type, false);
-
+   const unsigned slots = nir_variable_count_slots(shader, var, type);
    if (offset >= slots) {
       /* Constant index outside the bounds of the matrix/array.  This could
        * arise as a result of constant folding of a legal GLSL program.
diff --git a/src/freedreno/vulkan/tu_shader.cc b/src/freedreno/vulkan/tu_shader.cc
index 90cb01860a272..5cac5df7d8fae 100644
--- a/src/freedreno/vulkan/tu_shader.cc
+++ b/src/freedreno/vulkan/tu_shader.cc
@@ -926,9 +926,7 @@ tu_gather_xfb_info(nir_shader *nir, struct ir3_stream_output_info *info)
    memset(output_map, 0, sizeof(output_map));
 
    nir_foreach_shader_out_variable(var, nir) {
-      unsigned slots =
-         var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(var->type), 4)
-                           : glsl_count_attribute_slots(var->type, false);
+      unsigned slots = nir_variable_count_slots(nir, var, var->type);
       for (unsigned i = 0; i < slots; i++)
          output_map[var->data.location + i] = var->data.driver_location + i;
    }
diff --git a/src/gallium/auxiliary/nir/nir_to_tgsi_info.c b/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
index 48c80b583839c..67838f59a785c 100644
--- a/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
+++ b/src/gallium/auxiliary/nir/nir_to_tgsi_info.c
@@ -477,8 +477,7 @@ void nir_tgsi_scan_shader(const struct nir_shader *nir,
          type = glsl_get_array_element(type);
       }
 
-      unsigned attrib_count = variable->data.compact ? DIV_ROUND_UP(variable->data.location_frac + glsl_get_length(type), 4) :
-         glsl_count_attribute_slots(type, nir->info.stage == MESA_SHADER_VERTEX);
+      unsigned attrib_count = nir_variable_count_slots(nir, variable, type);
 
       i = variable->data.driver_location;
 
@@ -577,8 +576,7 @@ void nir_tgsi_scan_shader(const struct nir_shader *nir,
          type = glsl_get_array_element(type);
       }
 
-      unsigned attrib_count = variable->data.compact ? DIV_ROUND_UP(variable->data.location_frac + glsl_get_length(type), 4) :
-         glsl_count_attribute_slots(type, false);
+      unsigned attrib_count = nir_variable_count_slots(nir, variable, type);
       for (unsigned k = 0; k < attrib_count; k++, i++) {
 
          if (nir->info.stage == MESA_SHADER_FRAGMENT) {
diff --git a/src/gallium/frontends/lavapipe/lvp_pipeline.c b/src/gallium/frontends/lavapipe/lvp_pipeline.c
index c66cc313dfc08..a03ea6a7c050d 100644
--- a/src/gallium/frontends/lavapipe/lvp_pipeline.c
+++ b/src/gallium/frontends/lavapipe/lvp_pipeline.c
@@ -527,8 +527,7 @@ lvp_shader_xfb_init(struct lvp_shader *shader)
       memset(output_mapping, 0, sizeof(output_mapping));
 
       nir_foreach_shader_out_variable(var, shader->pipeline_nir->nir) {
-         unsigned slots = var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(var->type), 4)
-                                            : glsl_count_attribute_slots(var->type, false);
+         unsigned slots = nir_variable_count_slots(shader->pipeline_nir->nir, var, var->type);
          for (unsigned i = 0; i < slots; i++)
             output_mapping[var->data.location + i] = var->data.driver_location + i;
       }
diff --git a/src/intel/compiler/brw_fs_nir.cpp b/src/intel/compiler/brw_fs_nir.cpp
index 74df7fa304e6d..bcd997baa0932 100644
--- a/src/intel/compiler/brw_fs_nir.cpp
+++ b/src/intel/compiler/brw_fs_nir.cpp
@@ -69,9 +69,7 @@ fs_visitor::nir_setup_outputs()
     */
    nir_foreach_shader_out_variable(var, nir) {
       const int loc = var->data.driver_location;
-      const unsigned var_vec4s =
-         var->data.compact ? DIV_ROUND_UP(var->data.location_frac + glsl_get_length(var->type), 4)
-                           : type_size_vec4(var->type, true);
+      const unsigned var_vec4s = nir_variable_count_slots(nir, var, var->type);
       vec4s[loc] = MAX2(vec4s[loc], var_vec4s);
    }
 
-- 
GitLab

