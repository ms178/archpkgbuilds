From ee24a0279e55555eeb8704870aac346347ade68c Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Mon, 12 Feb 2024 20:45:33 +0100
Subject: [PATCH 1/3] frontends/va: Separate QP for I/P/B frames

For H264/HEVC this needs to calculate init_qp + slice_qp_delta.
---
 src/gallium/frontends/va/picture_av1_enc.c  | 27 ++++++++++++---------
 src/gallium/frontends/va/picture_h264_enc.c | 10 +++++---
 src/gallium/frontends/va/picture_hevc_enc.c | 22 ++++++++++++++---
 src/gallium/include/pipe/p_video_state.h    |  3 +++
 4 files changed, 45 insertions(+), 17 deletions(-)

diff --git a/src/gallium/frontends/va/picture_av1_enc.c b/src/gallium/frontends/va/picture_av1_enc.c
index e34190f626625..eb616a192d5c8 100644
--- a/src/gallium/frontends/va/picture_av1_enc.c
+++ b/src/gallium/frontends/va/picture_av1_enc.c
@@ -219,17 +219,6 @@ VAStatus vlVaHandleVAEncPictureParameterBufferTypeAV1(vlVaDriver *drv, vlVaConte
                                             PIPE_USAGE_STAGING, coded_buf->size);
    context->coded_buf = coded_buf;
 
-   for (i = 0; i < ARRAY_SIZE(context->desc.av1enc.rc); i++) {
-      context->desc.av1enc.rc[i].qp = av1->base_qindex ? av1->base_qindex : 60;
-      /* Distinguishes from the default params set for these values and app specific params passed down */
-      context->desc.av1enc.rc[i].app_requested_initial_qp = (av1->base_qindex != 0);
-      context->desc.av1enc.rc[i].min_qp = av1->min_base_qindex ? av1->min_base_qindex : 1;
-      context->desc.av1enc.rc[i].max_qp = av1->max_base_qindex ? av1->max_base_qindex : 255;
-      /* Distinguishes from the default params set for these values and app specific params passed down */
-      context->desc.av1enc.rc[i].app_requested_qp_range = 
-         ((context->desc.av1enc.rc[i].max_qp != AV1_MAX_QP_DEFAULT) || (context->desc.av1enc.rc[i].min_qp != AV1_MIN_QP_DEFAULT));
-   }
-
    /* these frame types will need to be seen as force type */
    switch(av1->picture_flags.bits.frame_type)
    {
@@ -247,6 +236,22 @@ VAStatus vlVaHandleVAEncPictureParameterBufferTypeAV1(vlVaDriver *drv, vlVaConte
          break;
    };
 
+   for (i = 0; i < ARRAY_SIZE(context->desc.av1enc.rc); i++) {
+      unsigned qindex = av1->base_qindex ? av1->base_qindex : 60;
+      if (context->desc.av1enc.frame_type == PIPE_AV1_ENC_FRAME_TYPE_KEY ||
+          context->desc.av1enc.frame_type == PIPE_AV1_ENC_FRAME_TYPE_INTRA_ONLY)
+         context->desc.av1enc.rc[i].qp = qindex;
+      else
+         context->desc.av1enc.rc[i].qp_inter = qindex;
+      /* Distinguishes from the default params set for these values and app specific params passed down */
+      context->desc.av1enc.rc[i].app_requested_initial_qp = (av1->base_qindex != 0);
+      context->desc.av1enc.rc[i].min_qp = av1->min_base_qindex ? av1->min_base_qindex : 1;
+      context->desc.av1enc.rc[i].max_qp = av1->max_base_qindex ? av1->max_base_qindex : 255;
+      /* Distinguishes from the default params set for these values and app specific params passed down */
+      context->desc.av1enc.rc[i].app_requested_qp_range =
+         ((context->desc.av1enc.rc[i].max_qp != AV1_MAX_QP_DEFAULT) || (context->desc.av1enc.rc[i].min_qp != AV1_MIN_QP_DEFAULT));
+   }
+
    if (context->desc.av1enc.frame_type == FRAME_TYPE_KEY_FRAME)
       context->desc.av1enc.last_key_frame_num = context->desc.av1enc.frame_num;
 
diff --git a/src/gallium/frontends/va/picture_h264_enc.c b/src/gallium/frontends/va/picture_h264_enc.c
index b1cd2a94762f1..e381d4884d672 100644
--- a/src/gallium/frontends/va/picture_h264_enc.c
+++ b/src/gallium/frontends/va/picture_h264_enc.c
@@ -84,9 +84,7 @@ vlVaHandleVAEncPictureParameterBufferTypeH264(vlVaDriver *drv, vlVaContext *cont
    context->desc.h264enc.num_slice_descriptors = 0;
    memset(&context->desc.h264enc.slices_descriptors, 0, sizeof(context->desc.h264enc.slices_descriptors));
 
-   context->desc.h264enc.quant_i_frames = h264->pic_init_qp;
-   context->desc.h264enc.quant_b_frames = h264->pic_init_qp;
-   context->desc.h264enc.quant_p_frames = h264->pic_init_qp;
+   context->desc.h264enc.init_qp = h264->pic_init_qp;
    context->desc.h264enc.gop_cnt++;
    if (context->desc.h264enc.gop_cnt == context->desc.h264enc.gop_size)
       context->desc.h264enc.gop_cnt = 0;
@@ -109,6 +107,7 @@ VAStatus
 vlVaHandleVAEncSliceParameterBufferTypeH264(vlVaDriver *drv, vlVaContext *context, vlVaBuffer *buf)
 {
    VAEncSliceParameterBufferH264 *h264;
+   unsigned slice_qp;
 
    h264 = buf->data;
    memset(&context->desc.h264enc.ref_idx_l0_list, VA_INVALID_ID, sizeof(context->desc.h264enc.ref_idx_l0_list));
@@ -144,12 +143,16 @@ vlVaHandleVAEncSliceParameterBufferTypeH264(vlVaDriver *drv, vlVaContext *contex
    slice_descriptor.macroblock_address = h264->macroblock_address;
    slice_descriptor.num_macroblocks = h264->num_macroblocks;
 
+   slice_qp = context->desc.h264enc.init_qp + h264->slice_qp_delta;
+
    if ((h264->slice_type == 1) || (h264->slice_type == 6)) {
       context->desc.h264enc.picture_type = PIPE_H2645_ENC_PICTURE_TYPE_B;
       slice_descriptor.slice_type = PIPE_H264_SLICE_TYPE_B;
+      context->desc.h264enc.quant_b_frames = slice_qp;
    } else if ((h264->slice_type == 0) || (h264->slice_type == 5)) {
       context->desc.h264enc.picture_type = PIPE_H2645_ENC_PICTURE_TYPE_P;
       slice_descriptor.slice_type = PIPE_H264_SLICE_TYPE_P;
+      context->desc.h264enc.quant_p_frames = slice_qp;
    } else if ((h264->slice_type == 2) || (h264->slice_type == 7)) {
       if (context->desc.h264enc.picture_type == PIPE_H2645_ENC_PICTURE_TYPE_IDR) {
          if (slice_descriptor.macroblock_address == 0) {
@@ -161,6 +164,7 @@ vlVaHandleVAEncSliceParameterBufferTypeH264(vlVaDriver *drv, vlVaContext *contex
          context->desc.h264enc.picture_type = PIPE_H2645_ENC_PICTURE_TYPE_I;
          slice_descriptor.slice_type = PIPE_H264_SLICE_TYPE_I;
       }
+      context->desc.h264enc.quant_i_frames = slice_qp;
    } else {
       context->desc.h264enc.picture_type = PIPE_H2645_ENC_PICTURE_TYPE_SKIP;
    }
diff --git a/src/gallium/frontends/va/picture_hevc_enc.c b/src/gallium/frontends/va/picture_hevc_enc.c
index 871832eb7fe58..002c5ff302902 100644
--- a/src/gallium/frontends/va/picture_hevc_enc.c
+++ b/src/gallium/frontends/va/picture_hevc_enc.c
@@ -63,9 +63,7 @@ vlVaHandleVAEncPictureParameterBufferTypeHEVC(vlVaDriver *drv, vlVaContext *cont
    context->coded_buf = coded_buf;
    context->desc.h265enc.pic.log2_parallel_merge_level_minus2 = h265->log2_parallel_merge_level_minus2;
    context->desc.h265enc.pic.nal_unit_type = h265->nal_unit_type;
-   context->desc.h265enc.rc.quant_i_frames = h265->pic_init_qp;
-   context->desc.h265enc.rc.quant_p_frames = h265->pic_init_qp;
-   context->desc.h265enc.rc.quant_b_frames = h265->pic_init_qp;
+   context->desc.h265enc.rc.init_qp = h265->pic_init_qp;
 
    switch(h265->pic_fields.bits.coding_type) {
    case 1:
@@ -106,6 +104,7 @@ VAStatus
 vlVaHandleVAEncSliceParameterBufferTypeHEVC(vlVaDriver *drv, vlVaContext *context, vlVaBuffer *buf)
 {
    VAEncSliceParameterBufferHEVC *h265;
+   unsigned slice_qp;
 
    h265 = buf->data;
    memset(&context->desc.h265enc.ref_idx_l0_list, VA_INVALID_ID, sizeof(context->desc.h265enc.ref_idx_l0_list));
@@ -136,6 +135,23 @@ vlVaHandleVAEncSliceParameterBufferTypeHEVC(vlVaDriver *drv, vlVaContext *contex
    context->desc.h265enc.slice.slice_deblocking_filter_disabled_flag = h265->slice_fields.bits.slice_deblocking_filter_disabled_flag;
    context->desc.h265enc.slice.slice_loop_filter_across_slices_enabled_flag = h265->slice_fields.bits.slice_loop_filter_across_slices_enabled_flag;
 
+   slice_qp = context->desc.h265enc.rc.init_qp + h265->slice_qp_delta;
+
+   switch (context->desc.h265enc.picture_type) {
+   case PIPE_H2645_ENC_PICTURE_TYPE_I:
+   case PIPE_H2645_ENC_PICTURE_TYPE_IDR:
+      context->desc.h265enc.rc.quant_i_frames = slice_qp;
+      break;
+   case PIPE_H2645_ENC_PICTURE_TYPE_P:
+      context->desc.h265enc.rc.quant_p_frames = slice_qp;
+      break;
+   case PIPE_H2645_ENC_PICTURE_TYPE_B:
+      context->desc.h265enc.rc.quant_b_frames = slice_qp;
+      break;
+   default:
+      break;
+   }
+
    /* Handle the slice control parameters */
    struct h265_slice_descriptor slice_descriptor;
    memset(&slice_descriptor, 0, sizeof(slice_descriptor));
diff --git a/src/gallium/include/pipe/p_video_state.h b/src/gallium/include/pipe/p_video_state.h
index e2b2f9dd43411..8061ddfb30728 100644
--- a/src/gallium/include/pipe/p_video_state.h
+++ b/src/gallium/include/pipe/p_video_state.h
@@ -631,6 +631,7 @@ struct pipe_h264_enc_picture_desc
    unsigned intra_idr_period;
    unsigned ip_period;
 
+   unsigned init_qp;
    unsigned quant_i_frames;
    unsigned quant_p_frames;
    unsigned quant_b_frames;
@@ -814,6 +815,7 @@ struct pipe_h265_enc_rate_control
    unsigned peak_bitrate;
    unsigned frame_rate_num;
    unsigned frame_rate_den;
+   unsigned init_qp;
    unsigned quant_i_frames;
    unsigned quant_p_frames;
    unsigned quant_b_frames;
@@ -892,6 +894,7 @@ struct pipe_av1_enc_rate_control
    unsigned enforce_hrd;
    unsigned max_au_size;
    unsigned qp; /* Initial QP */
+   unsigned qp_inter;
    unsigned max_qp;
    unsigned min_qp;
    bool app_requested_qp_range;
-- 
GitLab


From 17308f86f0414d78c1c83d9ea84722a6d6401e33 Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Thu, 22 Feb 2024 16:35:52 +0100
Subject: [PATCH 2/3] radeonsi/vcn: Use temporal_layer_index to select temporal
 layer

Don't change enc_pic.temporal_id as that is used in AV1 encode.

Fixes: 8d44a115080 ("radeonsi/vcn: Don't reinitialize encode session on bitrate/fps change")
---
 src/gallium/drivers/radeonsi/radeon_vcn_enc.c     | 1 -
 src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c | 8 +++-----
 src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c | 2 +-
 3 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
index 9d0aa41e342a6..44076a5690771 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
@@ -238,7 +238,6 @@ static void radeon_vcn_enc_h264_get_rc_param(struct radeon_encoder *enc,
    uint32_t frame_rate_den, frame_rate_num;
 
    enc->enc_pic.num_temporal_layers = pic->seq.num_temporal_layers ? pic->seq.num_temporal_layers : 1;
-   enc->enc_pic.temporal_id = 0;
    for (int i = 0; i < enc->enc_pic.num_temporal_layers; i++) {
       enc->enc_pic.rc_layer_init[i].target_bit_rate = pic->rate_ctrl[i].target_bitrate;
       enc->enc_pic.rc_layer_init[i].peak_bit_rate = pic->rate_ctrl[i].peak_bitrate;
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
index cb1b2957c49db..0e9bfb670c07c 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
@@ -114,8 +114,6 @@ static void radeon_enc_layer_control(struct radeon_encoder *enc)
 
 static void radeon_enc_layer_select(struct radeon_encoder *enc)
 {
-   enc->enc_pic.layer_sel.temporal_layer_index = enc->enc_pic.temporal_id;
-
    RADEON_ENC_BEGIN(enc->cmd.layer_select);
    RADEON_ENC_CS(enc->enc_pic.layer_sel.temporal_layer_index);
    RADEON_ENC_END();
@@ -183,7 +181,7 @@ static void radeon_enc_rc_session_init(struct radeon_encoder *enc)
 
 static void radeon_enc_rc_layer_init(struct radeon_encoder *enc)
 {
-   unsigned int i = enc->enc_pic.temporal_id;
+   unsigned int i = enc->enc_pic.layer_sel.temporal_layer_index;
    RADEON_ENC_BEGIN(enc->cmd.rc_layer_init);
    RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].target_bit_rate);
    RADEON_ENC_CS(enc->enc_pic.rc_layer_init[i].peak_bit_rate);
@@ -1350,7 +1348,7 @@ static void begin(struct radeon_encoder *enc)
 
    i = 0;
    do {
-      enc->enc_pic.temporal_id = i;
+      enc->enc_pic.layer_sel.temporal_layer_index = i;
       enc->layer_select(enc);
       enc->rc_layer_init(enc);
       enc->layer_select(enc);
@@ -1402,7 +1400,7 @@ static void encode(struct radeon_encoder *enc)
    if (enc->need_rate_control) {
       i = 0;
       do {
-         enc->enc_pic.temporal_id = i;
+         enc->enc_pic.layer_sel.temporal_layer_index = i;
          enc->layer_select(enc);
          enc->rc_layer_init(enc);
       } while (++i < enc->enc_pic.num_temporal_layers);
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c
index aefbd3192e856..a6bfd70b97c70 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c
@@ -515,7 +515,7 @@ static void encode(struct radeon_encoder *enc)
    if (enc->need_rate_control) {
       i = 0;
       do {
-         enc->enc_pic.temporal_id = i;
+         enc->enc_pic.layer_sel.temporal_layer_index = i;
          enc->layer_select(enc);
          enc->rc_layer_init(enc);
       } while (++i < enc->enc_pic.num_temporal_layers);
-- 
GitLab


From 8cc5e41ded22a20ad337bdecb874fac6f432142b Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Thu, 22 Feb 2024 16:39:13 +0100
Subject: [PATCH 3/3] radeonsi/vcn: Implement separate QP for I/P/B frames

This also fixes max_au_size as a side effect of using new IB.
---
 src/amd/common/ac_vcn_enc.h                   | 17 +++--
 src/gallium/drivers/radeonsi/radeon_vcn_enc.c | 63 ++++++++++++++-----
 src/gallium/drivers/radeonsi/radeon_vcn_enc.h |  1 +
 .../drivers/radeonsi/radeon_vcn_enc_1_2.c     | 33 +++++++---
 .../drivers/radeonsi/radeon_vcn_enc_2_0.c     | 14 +++--
 5 files changed, 95 insertions(+), 33 deletions(-)

diff --git a/src/amd/common/ac_vcn_enc.h b/src/amd/common/ac_vcn_enc.h
index 73f2154387ea4..939b215c8383b 100644
--- a/src/amd/common/ac_vcn_enc.h
+++ b/src/amd/common/ac_vcn_enc.h
@@ -310,13 +310,22 @@ typedef struct rvcn_enc_rate_ctl_layer_init_s {
 } rvcn_enc_rate_ctl_layer_init_t;
 
 typedef struct rvcn_enc_rate_ctl_per_picture_s {
-   uint32_t qp;
-   uint32_t min_qp_app;
-   uint32_t max_qp_app;
-   uint32_t max_au_size;
+   uint32_t qp_i;
+   uint32_t qp_p;
+   uint32_t qp_b;
+   uint32_t min_qp_i;
+   uint32_t max_qp_i;
+   uint32_t min_qp_p;
+   uint32_t max_qp_p;
+   uint32_t min_qp_b;
+   uint32_t max_qp_b;
+   uint32_t max_au_size_i;
+   uint32_t max_au_size_p;
+   uint32_t max_au_size_b;
    uint32_t enabled_filler_data;
    uint32_t skip_frame_enable;
    uint32_t enforce_hrd;
+   uint32_t reserved_0xff;
 } rvcn_enc_rate_ctl_per_picture_t;
 
 typedef struct rvcn_enc_quality_params_s {
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
index 44076a5690771..c8f44bd69959a 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
@@ -235,7 +235,7 @@ static void radeon_vcn_enc_h264_get_spec_misc_param(struct radeon_encoder *enc,
 static void radeon_vcn_enc_h264_get_rc_param(struct radeon_encoder *enc,
                                              struct pipe_h264_enc_picture_desc *pic)
 {
-   uint32_t frame_rate_den, frame_rate_num;
+   uint32_t frame_rate_den, frame_rate_num, max_qp;
 
    enc->enc_pic.num_temporal_layers = pic->seq.num_temporal_layers ? pic->seq.num_temporal_layers : 1;
    for (int i = 0; i < enc->enc_pic.num_temporal_layers; i++) {
@@ -261,10 +261,16 @@ static void radeon_vcn_enc_h264_get_rc_param(struct radeon_encoder *enc,
                frame_rate_num);
    }
    enc->enc_pic.rc_session_init.vbv_buffer_level = pic->rate_ctrl[0].vbv_buf_lv;
-   enc->enc_pic.rc_per_pic.qp = pic->quant_i_frames;
-   enc->enc_pic.rc_per_pic.min_qp_app = pic->rate_ctrl[0].min_qp;
-   enc->enc_pic.rc_per_pic.max_qp_app = pic->rate_ctrl[0].max_qp ?
-      pic->rate_ctrl[0].max_qp : 51;
+   enc->enc_pic.rc_per_pic.qp_i = pic->quant_i_frames;
+   enc->enc_pic.rc_per_pic.qp_p = pic->quant_p_frames;
+   enc->enc_pic.rc_per_pic.qp_b = pic->quant_b_frames;
+   enc->enc_pic.rc_per_pic.min_qp_i = pic->rate_ctrl[0].min_qp;
+   enc->enc_pic.rc_per_pic.min_qp_p = pic->rate_ctrl[0].min_qp;
+   enc->enc_pic.rc_per_pic.min_qp_b = pic->rate_ctrl[0].min_qp;
+   max_qp = pic->rate_ctrl[0].max_qp ? pic->rate_ctrl[0].max_qp : 51;
+   enc->enc_pic.rc_per_pic.max_qp_i = max_qp;
+   enc->enc_pic.rc_per_pic.max_qp_p = max_qp;
+   enc->enc_pic.rc_per_pic.max_qp_b = max_qp;
    enc->enc_pic.rc_per_pic.enabled_filler_data = pic->rate_ctrl[0].fill_data_enable;
    enc->enc_pic.rc_per_pic.skip_frame_enable = pic->rate_ctrl[0].skip_frame_enable;
    enc->enc_pic.rc_per_pic.enforce_hrd = pic->rate_ctrl[0].enforce_hrd;
@@ -285,7 +291,9 @@ static void radeon_vcn_enc_h264_get_rc_param(struct radeon_encoder *enc,
       default:
          enc->enc_pic.rc_session_init.rate_control_method = RENCODE_RATE_CONTROL_METHOD_NONE;
    }
-   enc->enc_pic.rc_per_pic.max_au_size = pic->rate_ctrl[0].max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_i = pic->rate_ctrl[0].max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_p = pic->rate_ctrl[0].max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_b = pic->rate_ctrl[0].max_au_size;
 }
 
 static void radeon_vcn_enc_h264_get_vui_param(struct radeon_encoder *enc,
@@ -482,7 +490,7 @@ static void radeon_vcn_enc_hevc_get_spec_misc_param(struct radeon_encoder *enc,
 static void radeon_vcn_enc_hevc_get_rc_param(struct radeon_encoder *enc,
                                              struct pipe_h265_enc_picture_desc *pic)
 {
-   uint32_t frame_rate_den, frame_rate_num;
+   uint32_t frame_rate_den, frame_rate_num, max_qp;
 
    enc->enc_pic.rc_layer_init[0].target_bit_rate = pic->rc.target_bitrate;
    enc->enc_pic.rc_layer_init[0].peak_bit_rate = pic->rc.peak_bitrate;
@@ -505,9 +513,13 @@ static void radeon_vcn_enc_hevc_get_rc_param(struct radeon_encoder *enc,
             frame_rate_den,
             frame_rate_num);
    enc->enc_pic.rc_session_init.vbv_buffer_level = pic->rc.vbv_buf_lv;
-   enc->enc_pic.rc_per_pic.qp = pic->rc.quant_i_frames;
-   enc->enc_pic.rc_per_pic.min_qp_app = pic->rc.min_qp;
-   enc->enc_pic.rc_per_pic.max_qp_app = pic->rc.max_qp ? pic->rc.max_qp : 51;
+   enc->enc_pic.rc_per_pic.qp_i = pic->rc.quant_i_frames;
+   enc->enc_pic.rc_per_pic.qp_p = pic->rc.quant_p_frames;
+   enc->enc_pic.rc_per_pic.min_qp_i = pic->rc.min_qp;
+   enc->enc_pic.rc_per_pic.min_qp_p = pic->rc.min_qp;
+   max_qp = pic->rc.max_qp ? pic->rc.max_qp : 51;
+   enc->enc_pic.rc_per_pic.max_qp_i = max_qp;
+   enc->enc_pic.rc_per_pic.max_qp_p = max_qp;
    enc->enc_pic.rc_per_pic.enabled_filler_data = pic->rc.fill_data_enable;
    enc->enc_pic.rc_per_pic.skip_frame_enable = pic->rc.skip_frame_enable;
    enc->enc_pic.rc_per_pic.enforce_hrd = pic->rc.enforce_hrd;
@@ -527,7 +539,8 @@ static void radeon_vcn_enc_hevc_get_rc_param(struct radeon_encoder *enc,
       default:
          enc->enc_pic.rc_session_init.rate_control_method = RENCODE_RATE_CONTROL_METHOD_NONE;
    }
-   enc->enc_pic.rc_per_pic.max_au_size = pic->rc.max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_i = pic->rc.max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_p = pic->rc.max_au_size;
 }
 
 static void radeon_vcn_enc_hevc_get_vui_param(struct radeon_encoder *enc,
@@ -699,7 +712,7 @@ static void radeon_vcn_enc_av1_color_description(struct radeon_encoder *enc,
 static void radeon_vcn_enc_av1_get_rc_param(struct radeon_encoder *enc,
                                             struct pipe_av1_enc_picture_desc *pic)
 {
-   uint32_t frame_rate_den, frame_rate_num;
+   uint32_t frame_rate_den, frame_rate_num, min_qp, max_qp;
 
    for (int i = 0; i < ARRAY_SIZE(enc->enc_pic.rc_layer_init); i++) {
       enc->enc_pic.rc_layer_init[i].target_bit_rate = pic->rc[i].target_bitrate;
@@ -724,9 +737,14 @@ static void radeon_vcn_enc_av1_get_rc_param(struct radeon_encoder *enc,
                                     frame_rate_num);
    }
    enc->enc_pic.rc_session_init.vbv_buffer_level = pic->rc[0].vbv_buf_lv;
-   enc->enc_pic.rc_per_pic.qp = pic->rc[0].qp;
-   enc->enc_pic.rc_per_pic.min_qp_app = pic->rc[0].min_qp ? pic->rc[0].min_qp : 1;
-   enc->enc_pic.rc_per_pic.max_qp_app = pic->rc[0].max_qp ? pic->rc[0].max_qp : 255;
+   enc->enc_pic.rc_per_pic.qp_i = pic->rc[0].qp;
+   enc->enc_pic.rc_per_pic.qp_p = pic->rc[0].qp_inter;
+   min_qp = pic->rc[0].min_qp ? pic->rc[0].min_qp : 1;
+   enc->enc_pic.rc_per_pic.min_qp_i = min_qp;
+   enc->enc_pic.rc_per_pic.min_qp_p = min_qp;
+   max_qp = pic->rc[0].max_qp ? pic->rc[0].max_qp : 255;
+   enc->enc_pic.rc_per_pic.max_qp_i = max_qp;
+   enc->enc_pic.rc_per_pic.max_qp_p = max_qp;
    enc->enc_pic.rc_per_pic.enabled_filler_data = pic->rc[0].fill_data_enable;
    enc->enc_pic.rc_per_pic.skip_frame_enable = pic->rc[0].skip_frame_enable;
    enc->enc_pic.rc_per_pic.enforce_hrd = pic->rc[0].enforce_hrd;
@@ -746,7 +764,8 @@ static void radeon_vcn_enc_av1_get_rc_param(struct radeon_encoder *enc,
       default:
          enc->enc_pic.rc_session_init.rate_control_method = RENCODE_RATE_CONTROL_METHOD_NONE;
    }
-   enc->enc_pic.rc_per_pic.max_au_size = pic->rc[0].max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_i = pic->rc[0].max_au_size;
+   enc->enc_pic.rc_per_pic.max_au_size_p = pic->rc[0].max_au_size;
 }
 
 static void radeon_vcn_enc_av1_get_param(struct radeon_encoder *enc,
@@ -1042,6 +1061,7 @@ static void radeon_enc_begin_frame(struct pipe_video_codec *encoder,
    struct radeon_encoder *enc = (struct radeon_encoder *)encoder;
    struct vl_video_buffer *vid_buf = (struct vl_video_buffer *)source;
    enc->need_rate_control = false;
+   enc->need_rc_per_pic = false;
 
    if (u_reduce_video_profile(enc->base.profile) == PIPE_VIDEO_FORMAT_MPEG4_AVC) {
       struct pipe_h264_enc_picture_desc *pic = (struct pipe_h264_enc_picture_desc *)picture;
@@ -1049,18 +1069,28 @@ static void radeon_enc_begin_frame(struct pipe_video_codec *encoder,
          (enc->enc_pic.rc_layer_init[0].target_bit_rate != pic->rate_ctrl[0].target_bitrate) ||
          (enc->enc_pic.rc_layer_init[0].frame_rate_num != pic->rate_ctrl[0].frame_rate_num) ||
          (enc->enc_pic.rc_layer_init[0].frame_rate_den != pic->rate_ctrl[0].frame_rate_den);
+      enc->need_rc_per_pic =
+         (!enc->enc_pic.rc_per_pic.qp_i && enc->enc_pic.rc_per_pic.qp_i != pic->quant_i_frames) ||
+         (!enc->enc_pic.rc_per_pic.qp_p && enc->enc_pic.rc_per_pic.qp_p != pic->quant_p_frames) ||
+         (!enc->enc_pic.rc_per_pic.qp_b && enc->enc_pic.rc_per_pic.qp_b != pic->quant_b_frames);
    } else if (u_reduce_video_profile(picture->profile) == PIPE_VIDEO_FORMAT_HEVC) {
       struct pipe_h265_enc_picture_desc *pic = (struct pipe_h265_enc_picture_desc *)picture;
       enc->need_rate_control =
          (enc->enc_pic.rc_layer_init[0].target_bit_rate != pic->rc.target_bitrate) ||
          (enc->enc_pic.rc_layer_init[0].frame_rate_num != pic->rc.frame_rate_num) ||
          (enc->enc_pic.rc_layer_init[0].frame_rate_den != pic->rc.frame_rate_den);
+      enc->need_rc_per_pic =
+         (!enc->enc_pic.rc_per_pic.qp_i && enc->enc_pic.rc_per_pic.qp_i != pic->rc.quant_i_frames) ||
+         (!enc->enc_pic.rc_per_pic.qp_p && enc->enc_pic.rc_per_pic.qp_p != pic->rc.quant_p_frames);
    } else if (u_reduce_video_profile(picture->profile) == PIPE_VIDEO_FORMAT_AV1) {
       struct pipe_av1_enc_picture_desc *pic = (struct pipe_av1_enc_picture_desc *)picture;
       enc->need_rate_control =
          (enc->enc_pic.rc_layer_init[0].target_bit_rate != pic->rc[0].target_bitrate) ||
          (enc->enc_pic.rc_layer_init[0].frame_rate_num != pic->rc[0].frame_rate_num) ||
          (enc->enc_pic.rc_layer_init[0].frame_rate_den != pic->rc[0].frame_rate_den);
+      enc->need_rc_per_pic =
+         (!enc->enc_pic.rc_per_pic.qp_i && enc->enc_pic.rc_per_pic.qp_i != pic->rc[0].qp) ||
+         (!enc->enc_pic.rc_per_pic.qp_p && enc->enc_pic.rc_per_pic.qp_p != pic->rc[0].qp_inter);
 
       if (!enc->cdf) {
          enc->cdf = CALLOC_STRUCT(rvid_buffer);
@@ -1128,6 +1158,7 @@ static void radeon_enc_begin_frame(struct pipe_video_codec *encoder,
       flush(enc);
       si_vid_destroy_buffer(&fb);
       enc->need_rate_control = false;
+      enc->need_rc_per_pic = false;
    }
 
    return;
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.h b/src/gallium/drivers/radeonsi/radeon_vcn_enc.h
index 114315ac948d5..5aec6b5a94052 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.h
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.h
@@ -263,6 +263,7 @@ struct radeon_encoder {
    bool emulation_prevention;
    bool need_feedback;
    bool need_rate_control;
+   bool need_rc_per_pic;
    unsigned dpb_size;
    unsigned roi_size;
    rvcn_enc_picture_info_t dpb_info[RENCODE_MAX_NUM_RECONSTRUCTED_PICTURES];
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
index 0e9bfb670c07c..d6d1cfdb941f4 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_1_2.c
@@ -25,7 +25,7 @@
 #define RENCODE_IB_PARAM_LAYER_SELECT              0x00000005
 #define RENCODE_IB_PARAM_RATE_CONTROL_SESSION_INIT 0x00000006
 #define RENCODE_IB_PARAM_RATE_CONTROL_LAYER_INIT   0x00000007
-#define RENCODE_IB_PARAM_RATE_CONTROL_PER_PICTURE  0x00000008
+#define RENCODE_IB_PARAM_RATE_CONTROL_PER_PICTURE  0x0000001d
 #define RENCODE_IB_PARAM_QUALITY_PARAMS            0x00000009
 #define RENCODE_IB_PARAM_SLICE_HEADER              0x0000000a
 #define RENCODE_IB_PARAM_ENCODE_PARAMS             0x0000000b
@@ -1187,14 +1187,25 @@ static void radeon_enc_intra_refresh(struct radeon_encoder *enc)
 
 static void radeon_enc_rc_per_pic(struct radeon_encoder *enc)
 {
+   enc->enc_pic.rc_per_pic.reserved_0xff = 0xFFFFFFFF;
+
    RADEON_ENC_BEGIN(enc->cmd.rc_per_pic);
-   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.qp);
-   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.min_qp_app);
-   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_qp_app);
-   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_au_size);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.qp_i);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.qp_p);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.qp_b);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.min_qp_i);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_qp_i);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.min_qp_p);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_qp_p);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.min_qp_b);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_qp_b);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_au_size_i);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_au_size_p);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.max_au_size_b);
    RADEON_ENC_CS(enc->enc_pic.rc_per_pic.enabled_filler_data);
    RADEON_ENC_CS(enc->enc_pic.rc_per_pic.skip_frame_enable);
    RADEON_ENC_CS(enc->enc_pic.rc_per_pic.enforce_hrd);
+   RADEON_ENC_CS(enc->enc_pic.rc_per_pic.reserved_0xff);
    RADEON_ENC_END();
 }
 
@@ -1397,12 +1408,18 @@ static void encode(struct radeon_encoder *enc)
    enc->total_task_size = 0;
    enc->task_info(enc, enc->need_feedback);
 
-   if (enc->need_rate_control) {
+   if (enc->need_rate_control || enc->need_rc_per_pic) {
       i = 0;
       do {
          enc->enc_pic.layer_sel.temporal_layer_index = i;
-         enc->layer_select(enc);
-         enc->rc_layer_init(enc);
+         if (enc->need_rate_control) {
+            enc->layer_select(enc);
+            enc->rc_layer_init(enc);
+         }
+         if (enc->need_rc_per_pic) {
+            enc->layer_select(enc);
+            enc->rc_per_pic(enc);
+         }
       } while (++i < enc->enc_pic.num_temporal_layers);
    }
 
diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c
index a6bfd70b97c70..d59b61bca6e79 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc_2_0.c
@@ -24,7 +24,6 @@
 #define RENCODE_IB_PARAM_LAYER_SELECT              0x00000005
 #define RENCODE_IB_PARAM_RATE_CONTROL_SESSION_INIT 0x00000006
 #define RENCODE_IB_PARAM_RATE_CONTROL_LAYER_INIT   0x00000007
-#define RENCODE_IB_PARAM_RATE_CONTROL_PER_PICTURE  0x00000008
 #define RENCODE_IB_PARAM_QUALITY_PARAMS            0x00000009
 #define RENCODE_IB_PARAM_DIRECT_OUTPUT_NALU        0x0000000a
 #define RENCODE_IB_PARAM_SLICE_HEADER              0x0000000b
@@ -512,12 +511,18 @@ static void encode(struct radeon_encoder *enc)
    enc->total_task_size = 0;
    enc->task_info(enc, enc->need_feedback);
 
-   if (enc->need_rate_control) {
+   if (enc->need_rate_control || enc->need_rc_per_pic) {
       i = 0;
       do {
          enc->enc_pic.layer_sel.temporal_layer_index = i;
-         enc->layer_select(enc);
-         enc->rc_layer_init(enc);
+         if (enc->need_rate_control) {
+            enc->layer_select(enc);
+            enc->rc_layer_init(enc);
+         }
+         if (enc->need_rc_per_pic) {
+            enc->layer_select(enc);
+            enc->rc_per_pic(enc);
+         }
       } while (++i < enc->enc_pic.num_temporal_layers);
    }
 
@@ -560,7 +565,6 @@ void radeon_enc_2_0_init(struct radeon_encoder *enc)
    enc->cmd.layer_select = RENCODE_IB_PARAM_LAYER_SELECT;
    enc->cmd.rc_session_init = RENCODE_IB_PARAM_RATE_CONTROL_SESSION_INIT;
    enc->cmd.rc_layer_init = RENCODE_IB_PARAM_RATE_CONTROL_LAYER_INIT;
-   enc->cmd.rc_per_pic = RENCODE_IB_PARAM_RATE_CONTROL_PER_PICTURE;
    enc->cmd.quality_params = RENCODE_IB_PARAM_QUALITY_PARAMS;
    enc->cmd.nalu = RENCODE_IB_PARAM_DIRECT_OUTPUT_NALU;
    enc->cmd.slice_header = RENCODE_IB_PARAM_SLICE_HEADER;
-- 
GitLab

