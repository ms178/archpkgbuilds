From f133f857fc94d90f9b244a1b21d23553b6d2960d Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 24 Jun 2022 15:24:20 +1000
Subject: [PATCH 01/28] glsl: add basic params for AMD_gpu_shader_half_float
 extension

This sets us the basic infrastructure to required to add an
extension.
---
 src/compiler/glsl/glsl_parser_extras.cpp | 1 +
 src/compiler/glsl/glsl_parser_extras.h   | 2 ++
 src/mesa/main/consts_exts.h              | 1 +
 src/mesa/main/extensions_table.h         | 1 +
 4 files changed, 5 insertions(+)

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 8795b0ac6b235..486f77d213a69 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -737,6 +737,7 @@ static const _mesa_glsl_extension _mesa_glsl_supported_extensions[] = {
    /* All other extensions go here, sorted alphabetically.
     */
    EXT(AMD_conservative_depth),
+   EXT(AMD_gpu_shader_half_float),
    EXT(AMD_gpu_shader_int64),
    EXT(AMD_shader_stencil_export),
    EXT(AMD_shader_trinary_minmax),
diff --git a/src/compiler/glsl/glsl_parser_extras.h b/src/compiler/glsl/glsl_parser_extras.h
index 061801e7e60db..95f1a7187f166 100644
--- a/src/compiler/glsl/glsl_parser_extras.h
+++ b/src/compiler/glsl/glsl_parser_extras.h
@@ -819,6 +819,8 @@ struct _mesa_glsl_parse_state {
     */
    bool AMD_conservative_depth_enable;
    bool AMD_conservative_depth_warn;
+   bool AMD_gpu_shader_half_float_enable;
+   bool AMD_gpu_shader_half_float_warn;
    bool AMD_gpu_shader_int64_enable;
    bool AMD_gpu_shader_int64_warn;
    bool AMD_shader_stencil_export_enable;
diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 0245a06707c1a..01f24fe23537c 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -224,6 +224,7 @@ struct gl_extensions
    GLboolean AMD_compressed_ATC_texture;
    GLboolean AMD_framebuffer_multisample_advanced;
    GLboolean AMD_depth_clamp_separate;
+   GLboolean AMD_gpu_shader_half_float;
    GLboolean AMD_performance_monitor;
    GLboolean AMD_pinned_memory;
    GLboolean AMD_seamless_cubemap_per_texture;
diff --git a/src/mesa/main/extensions_table.h b/src/mesa/main/extensions_table.h
index ede7a9e813942..91961593066d8 100644
--- a/src/mesa/main/extensions_table.h
+++ b/src/mesa/main/extensions_table.h
@@ -13,6 +13,7 @@ EXT(AMD_conservative_depth                  , ARB_conservative_depth
 EXT(AMD_depth_clamp_separate                , AMD_depth_clamp_separate               , GLL, GLC,  x ,  x , 2009)
 EXT(AMD_draw_buffers_blend                  , ARB_draw_buffers_blend                 , GLL, GLC,  x ,  x , 2009)
 EXT(AMD_framebuffer_multisample_advanced    , AMD_framebuffer_multisample_advanced   , GLL, GLC,  x , ES2, 2018)
+EXT(AMD_gpu_shader_half_float               , AMD_gpu_shader_half_float              ,  40,  40,  x ,  x , 2016)
 EXT(AMD_gpu_shader_int64                    , ARB_gpu_shader_int64                   ,  x , GLC,  x ,  x , 2015)
 EXT(AMD_multi_draw_indirect                 , ARB_draw_indirect                      , GLL, GLC,  x ,  x , 2011)
 EXT(AMD_performance_monitor                 , AMD_performance_monitor                , GLL, GLC,  x , ES2, 2007)
-- 
GitLab


From dd0828bc66aa178ce947b38a3b4a7d203262cf9e Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 24 Jun 2022 16:26:11 +1000
Subject: [PATCH 02/28] glsl: add half float support to the parser

---
 src/compiler/glsl/ast.h          |  2 ++
 src/compiler/glsl/ast_to_hir.cpp |  5 +++++
 src/compiler/glsl/glsl_lexer.ll  | 28 ++++++++++++++++++++++++++++
 src/compiler/glsl/glsl_parser.yy |  9 ++++++++-
 4 files changed, 43 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl/ast.h b/src/compiler/glsl/ast.h
index 0a5b94bb1ceed..5831528d035d6 100644
--- a/src/compiler/glsl/ast.h
+++ b/src/compiler/glsl/ast.h
@@ -197,6 +197,7 @@ enum ast_operators {
    ast_identifier,
    ast_int_constant,
    ast_uint_constant,
+   ast_float16_constant,
    ast_float_constant,
    ast_bool_constant,
    ast_double_constant,
@@ -258,6 +259,7 @@ public:
    union {
       const char *identifier;
       int int_constant;
+      float float16_constant;
       float float_constant;
       unsigned uint_constant;
       int bool_constant;
diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 2092fceacceb7..a33c416d25eab 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -2110,6 +2110,10 @@ ast_expression::do_hir(exec_list *instructions,
       result = new(ctx) ir_constant(this->primary_expression.uint_constant);
       break;
 
+   case ast_float16_constant:
+      result = new(ctx) ir_constant(float16_t(this->primary_expression.float16_constant));
+      break;
+
    case ast_float_constant:
       result = new(ctx) ir_constant(this->primary_expression.float_constant);
       break;
@@ -2253,6 +2257,7 @@ ast_expression::has_sequence_subexpression() const
    case ast_identifier:
    case ast_int_constant:
    case ast_uint_constant:
+   case ast_float16_constant:
    case ast_float_constant:
    case ast_bool_constant:
    case ast_double_constant:
diff --git a/src/compiler/glsl/glsl_lexer.ll b/src/compiler/glsl/glsl_lexer.ll
index ad109b3d112d9..4c33d756970ca 100644
--- a/src/compiler/glsl/glsl_lexer.ll
+++ b/src/compiler/glsl/glsl_lexer.ll
@@ -609,6 +609,16 @@ layout		{
 			    return LITERAL_INTEGER(8);
 			}
 
+[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?(hf|HF)	|
+\.[0-9]+([eE][+-]?[0-9]+)?(hf|HF)	|
+[0-9]+\.([eE][+-]?[0-9]+)?(hf|HF)	|
+[0-9]+[eE][+-]?[0-9]+(hf|HF)		{
+			    if (!yyextra->AMD_gpu_shader_half_float_enable)
+			        return ERROR_TOK;
+			    yylval->dreal = _mesa_strtod(yytext, NULL);
+			    return FLOAT16CONSTANT;
+			}
+
 [0-9]+\.[0-9]+([eE][+-]?[0-9]+)?[fF]?	|
 \.[0-9]+([eE][+-]?[0-9]+)?[fF]?		|
 [0-9]+\.([eE][+-]?[0-9]+)?[fF]?		|
@@ -739,6 +749,24 @@ u64vec2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyext
 u64vec3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyextra->AMD_gpu_shader_int64_enable, glsl_type::u64vec3_type);
 u64vec4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyextra->AMD_gpu_shader_int64_enable, glsl_type::u64vec4_type);
 
+    /* Additional words for AMD_gpu_shader_half_float */
+float16_t	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::float16_t_type);
+f16vec2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16vec2_type);
+f16vec3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16vec3_type);
+f16vec4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16vec4_type);
+f16mat2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2_type);
+f16mat3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3_type);
+f16mat4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4_type);
+f16mat2x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2_type);
+f16mat2x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2x3_type);
+f16mat2x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2x4_type);
+f16mat3x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3x2_type);
+f16mat3x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3_type);
+f16mat3x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3x4_type);
+f16mat4x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4x2_type);
+f16mat4x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4x3_type);
+f16mat4x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4_type);
+
 [_a-zA-Z][_a-zA-Z0-9]*	{
 			    struct _mesa_glsl_parse_state *state = yyextra;
 			    if (state->es_shader && yyleng > 1024) {
diff --git a/src/compiler/glsl/glsl_parser.yy b/src/compiler/glsl/glsl_parser.yy
index 574895b005ae5..af4f385b00657 100644
--- a/src/compiler/glsl/glsl_parser.yy
+++ b/src/compiler/glsl/glsl_parser.yy
@@ -150,7 +150,7 @@ static bool match_layout_qualifier(const char *s1, const char *s2,
 %token <identifier> IDENTIFIER TYPE_IDENTIFIER NEW_IDENTIFIER
 %type <identifier> any_identifier
 %type <interface_block> instance_name_opt
-%token <real> FLOATCONSTANT
+%token <real> FLOATCONSTANT FLOAT16CONSTANT
 %token <dreal> DOUBLECONSTANT
 %token <n> INTCONSTANT UINTCONSTANT BOOLCONSTANT
 %token <n64> INT64CONSTANT UINT64CONSTANT
@@ -461,6 +461,13 @@ primary_expression:
       $$->set_location(@1);
       $$->primary_expression.uint64_constant = $1;
    }
+   | FLOAT16CONSTANT
+   {
+      void *ctx = state->linalloc;
+      $$ = new(ctx) ast_expression(ast_float16_constant, NULL, NULL, NULL);
+      $$->set_location(@1);
+      $$->primary_expression.float16_constant = $1;
+   }
    | FLOATCONSTANT
    {
       void *ctx = state->linalloc;
-- 
GitLab


From 91f33f34aae9c8e6a419917268d9255f0cda81da Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:16:41 +1000
Subject: [PATCH 03/28] glsl: add explicit half float conversion support

---
 src/compiler/glsl/ast_function.cpp           | 46 ++++++++++++++++++++
 src/compiler/glsl/glsl_to_nir.cpp            | 10 +++++
 src/compiler/glsl/ir.cpp                     | 10 +++++
 src/compiler/glsl/ir_expression_operation.py | 10 +++++
 src/compiler/glsl/ir_validate.cpp            | 40 +++++++++++++++++
 5 files changed, 116 insertions(+)

diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index 38e6253adcc6a..505e308b90b2d 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -888,6 +888,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_INT:
          result = new(ctx) ir_expression(ir_unop_i2u, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162u, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2u, src);
          break;
@@ -918,6 +921,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_UINT:
          result = new(ctx) ir_expression(ir_unop_u2i, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162i, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2i, src);
          break;
@@ -935,6 +941,31 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
          break;
       }
       break;
+   case GLSL_TYPE_FLOAT16:
+      switch (b) {
+      case GLSL_TYPE_UINT:
+         result = new(ctx) ir_expression(ir_unop_u2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_INT:
+         result = new(ctx) ir_expression(ir_unop_i2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_BOOL:
+         result = new(ctx) ir_expression(ir_unop_b2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_FLOAT:
+         result = new(ctx) ir_expression(ir_unop_f2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_DOUBLE:
+         result = new(ctx) ir_expression(ir_unop_d2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_UINT64:
+         result = new(ctx) ir_expression(ir_unop_u642f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_INT64:
+         result = new(ctx) ir_expression(ir_unop_i642f16, desired_type, src, NULL);
+         break;
+      }
+      break;
    case GLSL_TYPE_FLOAT:
       switch (b) {
       case GLSL_TYPE_UINT:
@@ -946,6 +977,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_BOOL:
          result = new(ctx) ir_expression(ir_unop_b2f, desired_type, src, NULL);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162f, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_DOUBLE:
          result = new(ctx) ir_expression(ir_unop_d2f, desired_type, src, NULL);
          break;
@@ -967,6 +1001,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_INT:
          result = new(ctx) ir_expression(ir_unop_i2b, desired_type, src, NULL);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162b, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2b, desired_type, src, NULL);
          break;
@@ -996,6 +1033,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
                                          new(ctx) ir_expression(ir_unop_b2f,
                                                                 src));
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162d, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2d, desired_type, src, NULL);
          break;
@@ -1020,6 +1060,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
                                          new(ctx) ir_expression(ir_unop_b2i64,
                                                                 src));
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162u64, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2u64, src);
          break;
@@ -1042,6 +1085,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_BOOL:
          result = new(ctx) ir_expression(ir_unop_b2i64, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162i64, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2i64, src);
          break;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 377a61ec61e0a..cba853344e290 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -1942,10 +1942,20 @@ nir_visitor::visit(ir_expression *ir)
    case ir_unop_b2i64:
    case ir_unop_d2f:
    case ir_unop_f2d:
+   case ir_unop_f162u:
+   case ir_unop_u2f16:
+   case ir_unop_f162i:
+   case ir_unop_i2f16:
    case ir_unop_f162f:
    case ir_unop_f2f16:
    case ir_unop_f162b:
    case ir_unop_b2f16:
+   case ir_unop_f162d:
+   case ir_unop_d2f16:
+   case ir_unop_f162u64:
+   case ir_unop_u642f16:
+   case ir_unop_f162i64:
+   case ir_unop_i642f16:
    case ir_unop_i2i:
    case ir_unop_u2u:
    case ir_unop_d2i:
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index bfd5edb386592..ac560012ecd79 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -255,6 +255,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       this->type = op0->type;
       break;
 
+   case ir_unop_f162i:
    case ir_unop_f2i:
    case ir_unop_b2i:
    case ir_unop_u2i:
@@ -286,6 +287,11 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_f2f16:
    case ir_unop_f2fmp:
    case ir_unop_b2f16:
+   case ir_unop_i2f16:
+   case ir_unop_u2f16:
+   case ir_unop_d2f16:
+   case ir_unop_i642f16:
+   case ir_unop_u642f16:
       this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT16,
 					   op0->type->vector_elements, 1);
       break;
@@ -331,6 +337,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
 					   op0->type->vector_elements, 1);
       break;
 
+   case ir_unop_f162d:
    case ir_unop_f2d:
    case ir_unop_i2d:
    case ir_unop_u2d:
@@ -341,6 +348,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       break;
 
    case ir_unop_i2u:
+   case ir_unop_f162u:
    case ir_unop_f2u:
    case ir_unop_d2u:
    case ir_unop_bitcast_f2u:
@@ -353,6 +361,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_i2i64:
    case ir_unop_u2i64:
    case ir_unop_b2i64:
+   case ir_unop_f162i64:
    case ir_unop_f2i64:
    case ir_unop_d2i64:
    case ir_unop_u642i64:
@@ -362,6 +371,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
 
    case ir_unop_i2u64:
    case ir_unop_u2u64:
+   case ir_unop_f162u64:
    case ir_unop_f2u64:
    case ir_unop_d2u64:
    case ir_unop_i642u64:
diff --git a/src/compiler/glsl/ir_expression_operation.py b/src/compiler/glsl/ir_expression_operation.py
index fa3118b249b48..731b26e736772 100644
--- a/src/compiler/glsl/ir_expression_operation.py
+++ b/src/compiler/glsl/ir_expression_operation.py
@@ -490,6 +490,16 @@ ir_expression_operation = [
    operation("f2f16", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
    operation("f2fmp", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
    operation("f162f", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("u2f16", 1, source_types=(uint_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162u", 1, source_types=(float_type,), dest_type=uint_type, c_expression="{src0}"),
+   operation("i2f16", 1, source_types=(int_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162i", 1, source_types=(float_type,), dest_type=int_type, c_expression="{src0}"),
+   operation("d2f16", 1, source_types=(double_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162d", 1, source_types=(float_type,), dest_type=double_type, c_expression="{src0}"),
+   operation("u642f16", 1, source_types=(uint64_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162u64", 1, source_types=(float_type,), dest_type=uint64_type, c_expression="{src0}"),
+   operation("i642f16", 1, source_types=(int64_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162i64", 1, source_types=(float_type,), dest_type=int64_type, c_expression="{src0}"),
    # int16<->int32 conversion.
    operation("i2i", 1, source_types=(int_type,), dest_type=int_type, c_expression="{src0}"),
    operation("i2imp", 1, source_types=(int_type,), dest_type=int_type, c_expression="{src0}"),
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index de431cc6e5385..5640728f6e9fa 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -693,6 +693,46 @@ ir_validate::visit_leave(ir_expression *ir)
       assert(ir->operands[0]->type->is_double());
       assert(ir->type->is_boolean());
       break;
+   case ir_unop_u2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->is_uint_16_32());
+      break;
+   case ir_unop_f162u:
+      assert(ir->type->is_uint_16_32());
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_i2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->is_int_16_32());
+      break;
+   case ir_unop_f162i:
+      assert(ir->type->is_int_16_32());
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_d2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->is_double());
+      break;
+   case ir_unop_f162d:
+      assert(ir->type->is_double());
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_u642f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
+      break;
+   case ir_unop_f162u64:
+      assert(ir->type->base_type == GLSL_TYPE_UINT64);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_i642f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
+      break;
+   case ir_unop_f162i64:
+      assert(ir->type->base_type == GLSL_TYPE_INT64);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
 
    case ir_unop_frexp_sig:
       assert(ir->operands[0]->type->is_float_32_64());
-- 
GitLab


From 941e5b6d06326de1d1f1618e8bf08c4ed61c1d6e Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:24:02 +1000
Subject: [PATCH 04/28] glsl: update assert to allow for half float support

---
 src/compiler/glsl/ast_function.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index 505e308b90b2d..69510a5dffb65 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -1702,7 +1702,7 @@ emit_inline_matrix_constructor(const glsl_type *type,
        * components with zero.
        */
       glsl_base_type param_base_type = first_param->type->base_type;
-      assert(first_param->type->is_float() || first_param->type->is_double());
+      assert(first_param->type->is_float_16_32_64());
       ir_variable *rhs_var =
          new(ctx) ir_variable(glsl_type::get_instance(param_base_type, 4, 1),
                               "mat_ctor_vec",
-- 
GitLab


From 1c76f3efdeb0a8be2a88148b47bc18d05a8485ca Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:58:27 +1000
Subject: [PATCH 05/28] glsl: add implicit half float conversions

---
 src/compiler/glsl/ast_to_hir.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index a33c416d25eab..6b06f2fbb96fa 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -242,10 +242,18 @@ get_implicit_conversion_operation(const glsl_type *to, const glsl_type *from,
                                   struct _mesa_glsl_parse_state *state)
 {
    switch (to->base_type) {
+   case GLSL_TYPE_FLOAT16:
+      switch (from->base_type) {
+      case GLSL_TYPE_INT: return ir_unop_i2f16;
+      case GLSL_TYPE_UINT: return ir_unop_u2f16;
+      default: return (ir_expression_operation)0;
+      }
+
    case GLSL_TYPE_FLOAT:
       switch (from->base_type) {
       case GLSL_TYPE_INT: return ir_unop_i2f;
       case GLSL_TYPE_UINT: return ir_unop_u2f;
+      case GLSL_TYPE_FLOAT16: return ir_unop_f162f;
       default: return (ir_expression_operation)0;
       }
 
@@ -263,6 +271,7 @@ get_implicit_conversion_operation(const glsl_type *to, const glsl_type *from,
       switch (from->base_type) {
       case GLSL_TYPE_INT: return ir_unop_i2d;
       case GLSL_TYPE_UINT: return ir_unop_u2d;
+      case GLSL_TYPE_FLOAT16: return ir_unop_f162d;
       case GLSL_TYPE_FLOAT: return ir_unop_f2d;
       case GLSL_TYPE_INT64: return ir_unop_i642d;
       case GLSL_TYPE_UINT64: return ir_unop_u642d;
-- 
GitLab


From 6303cf309f77e19562dc96d4aaee6efd29aea86b Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 12:15:50 +1000
Subject: [PATCH 06/28] glsl: add implicit conversion support for half floats

---
 src/compiler/glsl/glsl_parser_extras.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 486f77d213a69..e661d0ea9746d 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -942,7 +942,8 @@ _mesa_glsl_can_implicitly_convert(const glsl_type *from, const glsl_type *desire
       return false;
 
    /* int and uint can be converted to float. */
-   if (desired->is_float() && from->is_integer_32())
+   if (desired->is_float() &&
+       (from->is_integer_32() || from->base_type == GLSL_TYPE_FLOAT16))
       return true;
 
    /* With GLSL 4.0, ARB_gpu_shader5, or MESA_shader_integer_functions, int
@@ -961,7 +962,7 @@ _mesa_glsl_can_implicitly_convert(const glsl_type *from, const glsl_type *desire
 
    /* Conversions from different types to double. */
    if ((!state || state->has_double()) && desired->is_double()) {
-      if (from->is_float())
+      if (from->is_float_16_32())
          return true;
       if (from->is_integer_32())
          return true;
-- 
GitLab


From d9c4cff63abbe9bfa15d453665eb7a8fdfa187d7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 12:16:37 +1000
Subject: [PATCH 07/28] glsl: add ubo packing support for half floats

---
 src/compiler/glsl_types.cpp | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index a7356e2c7e117..9f4d9fe4a4dcf 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -1915,7 +1915,7 @@ glsl_type::varying_count() const
 unsigned
 glsl_type::std140_base_alignment(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2033,7 +2033,7 @@ glsl_type::std140_base_alignment(bool row_major) const
 unsigned
 glsl_type::std140_size(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2249,7 +2249,7 @@ unsigned
 glsl_type::std430_base_alignment(bool row_major) const
 {
 
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2358,7 +2358,7 @@ glsl_type::std430_base_alignment(bool row_major) const
 unsigned
 glsl_type::std430_array_stride(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* Notice that the array stride of a vec3 is not 3 * N but 4 * N.
     * See OpenGL 4.30 spec, section 7.6.2.2 "Standard Uniform Block Layout"
@@ -2446,7 +2446,7 @@ glsl_type::explicit_size(bool align_to_stride) const
 unsigned
 glsl_type::std430_size(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* OpenGL 4.30 spec, section 7.6.2.2 "Standard Uniform Block Layout":
     *
-- 
GitLab


From b82a84f6b8fb3e71ded211f97cf2f53893a33079 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 13:18:25 +1000
Subject: [PATCH 08/28] glsl: skip conversion of half float back to float for
 GL queries

This is only needed for GLES where floats have been lowered to
half floats internally. We don't do that in desktop GL and we
need to skip it to return the correct enums for the
AMD_gpu_shader_half_float extension.
---
 src/mesa/main/shader_query.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index 88de7139825cf..37173696074b2 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -64,8 +64,11 @@ DECL_RESOURCE_FUNC(XFB, gl_transform_feedback_buffer);
 DECL_RESOURCE_FUNC(SUB, gl_subroutine_function);
 
 static GLenum
-mediump_to_highp_type(GLenum type)
+mediump_to_highp_type(struct gl_shader_program *shProg, GLenum type)
 {
+   if (!shProg->IsES)
+      return type;
+
    switch (type) {
    case GL_FLOAT16_NV:
       return GL_FLOAT;
@@ -1466,16 +1469,16 @@ _mesa_program_resource_prop(struct gl_shader_program *shProg,
       case GL_UNIFORM:
       case GL_BUFFER_VARIABLE:
          *val = RESOURCE_UNI(res)->type->gl_type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       case GL_PROGRAM_INPUT:
       case GL_PROGRAM_OUTPUT:
          *val = RESOURCE_VAR(res)->type->gl_type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       case GL_TRANSFORM_FEEDBACK_VARYING:
          *val = RESOURCE_XFV(res)->Type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       default:
          goto invalid_operation;
-- 
GitLab


From d27df2c4810d88282458f00653ee7e685b3e9516 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 30 Jun 2022 15:18:01 +1000
Subject: [PATCH 09/28] glsl: add some new helpers for half float builtin
 functions

These helpers will be used in the following patches.
---
 src/compiler/glsl/builtin_functions.cpp | 190 +++++++++++++++++++++++-
 1 file changed, 189 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 97e37e49f4d03..de355424e1c69 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -459,6 +459,12 @@ gpu_shader5_or_es31_or_integer_functions(const _mesa_glsl_parse_state *state)
           state->MESA_shader_integer_functions_enable;
 }
 
+static bool
+gpu_shader_half_float(const _mesa_glsl_parse_state *state)
+{
+   return state->AMD_gpu_shader_half_float_enable;
+}
+
 static bool
 fs_interpolate_at(const _mesa_glsl_parse_state *state)
 {
@@ -1023,6 +1029,7 @@ private:
    ir_variable *out_lowp_var(const glsl_type *type, const char *name);
    ir_variable *out_highp_var(const glsl_type *type, const char *name);
    ir_variable *as_highp(ir_factory &body, ir_variable *var);
+   ir_constant *imm(float16_t f16, unsigned vector_elements=1);
    ir_constant *imm(float f, unsigned vector_elements=1);
    ir_constant *imm(bool b, unsigned vector_elements=1);
    ir_constant *imm(int i, unsigned vector_elements=1);
@@ -1742,6 +1749,30 @@ builtin_builder::create_builtins()
                 _##NAME(glsl_type::vec4_type),  \
                 NULL);
 
+#define FHF(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(always_available, glsl_type::float_type), \
+                _##NAME(always_available, glsl_type::vec2_type),  \
+                _##NAME(always_available, glsl_type::vec3_type),  \
+                _##NAME(always_available, glsl_type::vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
+#define FHF130(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(v130, glsl_type::float_type), \
+                _##NAME(v130, glsl_type::vec2_type),  \
+                _##NAME(v130, glsl_type::vec3_type),  \
+                _##NAME(v130, glsl_type::vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
 #define FD(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(always_available, glsl_type::float_type), \
@@ -1754,6 +1785,22 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, glsl_type::dvec4_type),      \
                 NULL);
 
+#define FDHF(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(always_available, glsl_type::float_type), \
+                _##NAME(always_available, glsl_type::vec2_type),  \
+                _##NAME(always_available, glsl_type::vec3_type),  \
+                _##NAME(always_available, glsl_type::vec4_type),  \
+                _##NAME(fp64, glsl_type::double_type),  \
+                _##NAME(fp64, glsl_type::dvec2_type),    \
+                _##NAME(fp64, glsl_type::dvec3_type),     \
+                _##NAME(fp64, glsl_type::dvec4_type),      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
 #define FD130(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(v130, glsl_type::float_type), \
@@ -1766,6 +1813,38 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, glsl_type::dvec4_type),      \
                 NULL);
 
+#define FDHF130(NAME)                                                      \
+   add_function(#NAME,                                                     \
+                _##NAME(v130, glsl_type::float_type),                      \
+                _##NAME(v130, glsl_type::vec2_type),                       \
+                _##NAME(v130, glsl_type::vec3_type),                       \
+                _##NAME(v130, glsl_type::vec4_type),                       \
+                _##NAME(fp64, glsl_type::double_type),                     \
+                _##NAME(fp64, glsl_type::dvec2_type),                      \
+                _##NAME(fp64, glsl_type::dvec3_type),                      \
+                _##NAME(fp64, glsl_type::dvec4_type),                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),   \
+                NULL);
+
+#define FDHF130GS4(NAME)                                                   \
+   add_function(#NAME,                                                     \
+                _##NAME(v130_or_gpu_shader4, glsl_type::float_type),       \
+                _##NAME(v130_or_gpu_shader4, glsl_type::vec2_type),        \
+                _##NAME(v130_or_gpu_shader4, glsl_type::vec3_type),        \
+                _##NAME(v130_or_gpu_shader4, glsl_type::vec4_type),        \
+                _##NAME(fp64, glsl_type::double_type),                     \
+                _##NAME(fp64, glsl_type::dvec2_type),                      \
+                _##NAME(fp64, glsl_type::dvec3_type),                      \
+                _##NAME(fp64, glsl_type::dvec4_type),                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),   \
+                NULL);
+
 #define FD130GS4(NAME)                          \
    add_function(#NAME,                          \
                 _##NAME(v130_or_gpu_shader4, glsl_type::float_type), \
@@ -1790,6 +1869,22 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, glsl_type::dvec4_type),      \
                 NULL);
 
+#define FDHFGS5(NAME)                                                      \
+   add_function(#NAME,                                                     \
+                _##NAME(gpu_shader5_es, glsl_type::float_type),            \
+                _##NAME(gpu_shader5_es, glsl_type::vec2_type),             \
+                _##NAME(gpu_shader5_es, glsl_type::vec3_type),             \
+                _##NAME(gpu_shader5_es, glsl_type::vec4_type),             \
+                _##NAME(fp64, glsl_type::double_type),                     \
+                _##NAME(fp64, glsl_type::dvec2_type),                      \
+                _##NAME(fp64, glsl_type::dvec3_type),                      \
+                _##NAME(fp64, glsl_type::dvec4_type),                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),   \
+                NULL);
+
 #define FI(NAME)                                \
    add_function(#NAME,                          \
                 _##NAME(glsl_type::float_type), \
@@ -1822,6 +1917,30 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::i64vec4_type),  \
                 NULL);
 
+#define FI64HF(NAME)                                \
+   add_function(#NAME,                          \
+                _##NAME(always_available, glsl_type::float_type), \
+                _##NAME(always_available, glsl_type::vec2_type),  \
+                _##NAME(always_available, glsl_type::vec3_type),  \
+                _##NAME(always_available, glsl_type::vec4_type),  \
+                _##NAME(always_available, glsl_type::int_type),   \
+                _##NAME(always_available, glsl_type::ivec2_type), \
+                _##NAME(always_available, glsl_type::ivec3_type), \
+                _##NAME(always_available, glsl_type::ivec4_type), \
+                _##NAME(fp64, glsl_type::double_type), \
+                _##NAME(fp64, glsl_type::dvec2_type),  \
+                _##NAME(fp64, glsl_type::dvec3_type),  \
+                _##NAME(fp64, glsl_type::dvec4_type),  \
+                _##NAME(int64_avail, glsl_type::int64_t_type), \
+                _##NAME(int64_avail, glsl_type::i64vec2_type),  \
+                _##NAME(int64_avail, glsl_type::i64vec3_type),  \
+                _##NAME(int64_avail, glsl_type::i64vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
 #define FIUD_VEC(NAME)                                            \
    add_function(#NAME,                                            \
                 _##NAME(always_available, glsl_type::vec2_type),  \
@@ -1945,6 +2064,68 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::u64vec4_type, glsl_type::u64vec4_type),     \
                 NULL);
 
+#define FIUDHF2_MIXED(NAME)                                                                           \
+   add_function(#NAME,                                                                                \
+                _##NAME(always_available, glsl_type::float_type, glsl_type::float_type),              \
+                _##NAME(always_available, glsl_type::vec2_type,  glsl_type::float_type),              \
+                _##NAME(always_available, glsl_type::vec3_type,  glsl_type::float_type),              \
+                _##NAME(always_available, glsl_type::vec4_type,  glsl_type::float_type),              \
+                                                                                                      \
+                _##NAME(always_available, glsl_type::vec2_type,  glsl_type::vec2_type),               \
+                _##NAME(always_available, glsl_type::vec3_type,  glsl_type::vec3_type),               \
+                _##NAME(always_available, glsl_type::vec4_type,  glsl_type::vec4_type),               \
+                                                                                                      \
+                _##NAME(always_available, glsl_type::int_type,   glsl_type::int_type),                \
+                _##NAME(always_available, glsl_type::ivec2_type, glsl_type::int_type),                \
+                _##NAME(always_available, glsl_type::ivec3_type, glsl_type::int_type),                \
+                _##NAME(always_available, glsl_type::ivec4_type, glsl_type::int_type),                \
+                                                                                                      \
+                _##NAME(always_available, glsl_type::ivec2_type, glsl_type::ivec2_type),              \
+                _##NAME(always_available, glsl_type::ivec3_type, glsl_type::ivec3_type),              \
+                _##NAME(always_available, glsl_type::ivec4_type, glsl_type::ivec4_type),              \
+                                                                                                      \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uint_type,  glsl_type::uint_type),            \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec2_type, glsl_type::uint_type),            \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec3_type, glsl_type::uint_type),            \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec4_type, glsl_type::uint_type),            \
+                                                                                                      \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec2_type, glsl_type::uvec2_type),           \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec3_type, glsl_type::uvec3_type),           \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec4_type, glsl_type::uvec4_type),           \
+                                                                                                      \
+                _##NAME(fp64, glsl_type::double_type, glsl_type::double_type),                        \
+                _##NAME(fp64, glsl_type::dvec2_type, glsl_type::double_type),                         \
+                _##NAME(fp64, glsl_type::dvec3_type, glsl_type::double_type),                         \
+                _##NAME(fp64, glsl_type::dvec4_type, glsl_type::double_type),                         \
+                _##NAME(fp64, glsl_type::dvec2_type, glsl_type::dvec2_type),                          \
+                _##NAME(fp64, glsl_type::dvec3_type, glsl_type::dvec3_type),                          \
+                _##NAME(fp64, glsl_type::dvec4_type, glsl_type::dvec4_type),                          \
+                                                                                                      \
+                _##NAME(int64_avail, glsl_type::int64_t_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec2_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec3_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec4_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec2_type, glsl_type::i64vec2_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec3_type, glsl_type::i64vec3_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec4_type, glsl_type::i64vec4_type),               \
+                _##NAME(int64_avail, glsl_type::uint64_t_type, glsl_type::uint64_t_type),             \
+                _##NAME(int64_avail, glsl_type::u64vec2_type, glsl_type::uint64_t_type),              \
+                _##NAME(int64_avail, glsl_type::u64vec3_type, glsl_type::uint64_t_type),              \
+                _##NAME(int64_avail, glsl_type::u64vec4_type, glsl_type::uint64_t_type),              \
+                _##NAME(int64_avail, glsl_type::u64vec2_type, glsl_type::u64vec2_type),               \
+                _##NAME(int64_avail, glsl_type::u64vec3_type, glsl_type::u64vec3_type),               \
+                _##NAME(int64_avail, glsl_type::u64vec4_type, glsl_type::u64vec4_type),               \
+                                                                                                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type, glsl_type::float16_t_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type, glsl_type::float16_t_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type, glsl_type::float16_t_type),   \
+                                                                                                      \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type, glsl_type::f16vec2_type),     \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type, glsl_type::f16vec3_type),     \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type, glsl_type::f16vec4_type),     \
+                NULL);
+
    F(radians)
    F(degrees)
    F(sin)
@@ -5705,6 +5886,12 @@ builtin_builder::as_highp(ir_factory &body, ir_variable *var)
    return t;
 }
 
+ir_constant *
+builtin_builder::imm(float16_t f16, unsigned vector_elements)
+{
+   return new(mem_ctx) ir_constant(f16, vector_elements);
+}
+
 ir_constant *
 builtin_builder::imm(bool b, unsigned vector_elements)
 {
@@ -5741,7 +5928,8 @@ builtin_builder::imm(const glsl_type *type, const ir_constant_data &data)
    return new(mem_ctx) ir_constant(type, &data);
 }
 
-#define IMM_FP(type, val) (type->is_double()) ? imm(val) : imm((float)val)
+#define IMM_FP(type, val) (type->is_double()) ? imm(val) : \
+   (type->base_type == GLSL_TYPE_FLOAT16  ? imm((float16_t)val) : imm((float)val))
 
 ir_dereference_variable *
 builtin_builder::var_ref(ir_variable *var)
-- 
GitLab


From 936217266e3bd9e1be222385ace3c0f1bf85dd36 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 30 Jun 2022 15:19:28 +1000
Subject: [PATCH 10/28] glsl: add half float angle and trigonometry functions

---
 src/compiler/glsl/builtin_functions.cpp | 183 +++++++++++++-----------
 1 file changed, 101 insertions(+), 82 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index de355424e1c69..038deb162664e 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1042,7 +1042,6 @@ private:
    ir_dereference_record *record_ref(ir_variable *var, const char *field);
 
    ir_expression *asin_expr(ir_variable *x, float p0, float p1);
-   void do_atan(ir_factory &body, const glsl_type *type, ir_variable *res, operand y_over_x);
 
    /**
     * Call function \param f with parameters specified as the linked
@@ -1108,21 +1107,21 @@ private:
 #define B3(X) ir_function_signature *_##X(const glsl_type *, const glsl_type *, const glsl_type *);
 #define BA1(X) ir_function_signature *_##X(builtin_available_predicate, const glsl_type *);
 #define BA2(X) ir_function_signature *_##X(builtin_available_predicate, const glsl_type *, const glsl_type *);
-   B1(radians)
-   B1(degrees)
-   B1(sin)
-   B1(cos)
-   B1(tan)
-   B1(asin)
-   B1(acos)
-   B1(atan2)
-   B1(atan)
-   B1(sinh)
-   B1(cosh)
-   B1(tanh)
-   B1(asinh)
-   B1(acosh)
-   B1(atanh)
+   BA1(radians)
+   BA1(degrees)
+   BA1(sin)
+   BA1(cos)
+   BA1(tan)
+   BA1(asin)
+   BA1(acos)
+   BA1(atan2)
+   BA1(atan)
+   BA1(sinh)
+   BA1(cosh)
+   BA1(tanh)
+   BA1(asinh)
+   BA1(acosh)
+   BA1(atanh)
    B1(pow)
    B1(exp)
    B1(log)
@@ -2126,31 +2125,39 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type, glsl_type::f16vec4_type),     \
                 NULL);
 
-   F(radians)
-   F(degrees)
-   F(sin)
-   F(cos)
-   F(tan)
-   F(asin)
-   F(acos)
+   FHF(radians)
+   FHF(degrees)
+   FHF(sin)
+   FHF(cos)
+   FHF(tan)
+   FHF(asin)
+   FHF(acos)
 
    add_function("atan",
-                _atan(glsl_type::float_type),
-                _atan(glsl_type::vec2_type),
-                _atan(glsl_type::vec3_type),
-                _atan(glsl_type::vec4_type),
-                _atan2(glsl_type::float_type),
-                _atan2(glsl_type::vec2_type),
-                _atan2(glsl_type::vec3_type),
-                _atan2(glsl_type::vec4_type),
-                NULL);
-
-   F(sinh)
-   F(cosh)
-   F(tanh)
-   F(asinh)
-   F(acosh)
-   F(atanh)
+                _atan(always_available, glsl_type::float_type),
+                _atan(always_available, glsl_type::vec2_type),
+                _atan(always_available, glsl_type::vec3_type),
+                _atan(always_available, glsl_type::vec4_type),
+                _atan2(always_available, glsl_type::float_type),
+                _atan2(always_available, glsl_type::vec2_type),
+                _atan2(always_available, glsl_type::vec3_type),
+                _atan2(always_available, glsl_type::vec4_type),
+                _atan(gpu_shader_half_float, glsl_type::float16_t_type),
+                _atan(gpu_shader_half_float, glsl_type::f16vec2_type),
+                _atan(gpu_shader_half_float, glsl_type::f16vec3_type),
+                _atan(gpu_shader_half_float, glsl_type::f16vec4_type),
+                _atan2(gpu_shader_half_float, glsl_type::float16_t_type),
+                _atan2(gpu_shader_half_float, glsl_type::f16vec2_type),
+                _atan2(gpu_shader_half_float, glsl_type::f16vec3_type),
+                _atan2(gpu_shader_half_float, glsl_type::f16vec4_type),
+                NULL);
+
+   FHF130(sinh)
+   FHF130(cosh)
+   FHF130(tanh)
+   FHF130(asinh)
+   FHF130(acosh)
+   FHF130(atanh)
    F(pow)
    F(exp)
    F(log)
@@ -6053,31 +6060,34 @@ builtin_builder::_##NAME(const glsl_type *return_type,                  \
  */
 
 ir_function_signature *
-builtin_builder::_radians(const glsl_type *type)
+builtin_builder::_radians(builtin_available_predicate avail,
+                          const glsl_type *type)
 {
    ir_variable *degrees = in_var(type, "degrees");
-   MAKE_SIG(type, always_available, 1, degrees);
-   body.emit(ret(mul(degrees, imm(0.0174532925f))));
+   MAKE_SIG(type, avail, 1, degrees);
+   body.emit(ret(mul(degrees, IMM_FP(type, 0.0174532925f))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_degrees(const glsl_type *type)
+builtin_builder::_degrees(builtin_available_predicate avail,
+                          const glsl_type *type)
 {
    ir_variable *radians = in_var(type, "radians");
-   MAKE_SIG(type, always_available, 1, radians);
-   body.emit(ret(mul(radians, imm(57.29578f))));
+   MAKE_SIG(type, avail, 1, radians);
+   body.emit(ret(mul(radians, IMM_FP(type, 57.29578f))));
    return sig;
 }
 
-UNOP(sin, ir_unop_sin, always_available)
-UNOP(cos, ir_unop_cos, always_available)
+UNOPA(sin, ir_unop_sin)
+UNOPA(cos, ir_unop_cos)
 
 ir_function_signature *
-builtin_builder::_tan(const glsl_type *type)
+builtin_builder::_tan(builtin_available_predicate avail,
+                      const glsl_type *type)
 {
    ir_variable *theta = in_var(type, "theta");
-   MAKE_SIG(type, always_available, 1, theta);
+   MAKE_SIG(type, avail, 1, theta);
    body.emit(ret(div(sin(theta), cos(theta))));
    return sig;
 }
@@ -6086,14 +6096,14 @@ ir_expression *
 builtin_builder::asin_expr(ir_variable *x, float p0, float p1)
 {
    return mul(sign(x),
-              sub(imm(M_PI_2f),
-                  mul(sqrt(sub(imm(1.0f), abs(x))),
-                      add(imm(M_PI_2f),
+              sub(IMM_FP(x->type, M_PI_2f),
+                  mul(sqrt(sub(IMM_FP(x->type, 1.0f), abs(x))),
+                      add(IMM_FP(x->type, M_PI_2f),
                           mul(abs(x),
-                              add(imm(M_PI_4f - 1.0f),
+                              add(IMM_FP(x->type, (M_PI_4f - 1.0f)),
                                   mul(abs(x),
-                                      add(imm(p0),
-                                          mul(abs(x), imm(p1))))))))));
+                                      add(IMM_FP(x->type, p0),
+                                          mul(abs(x), IMM_FP(x->type, p1))))))))));
 }
 
 /**
@@ -6133,10 +6143,11 @@ builtin_builder::call(ir_function *f, ir_variable *ret, exec_list params)
 }
 
 ir_function_signature *
-builtin_builder::_asin(const glsl_type *type)
+builtin_builder::_asin(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, always_available, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(asin_expr(x, 0.086566724f, -0.03102955f)));
 
@@ -6144,45 +6155,49 @@ builtin_builder::_asin(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_acos(const glsl_type *type)
+builtin_builder::_acos(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, always_available, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(sub(imm(M_PI_2f), asin_expr(x, 0.08132463f, -0.02363318f))));
+   body.emit(ret(sub(IMM_FP(type, M_PI_2f), asin_expr(x, 0.08132463f, -0.02363318f))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_sinh(const glsl_type *type)
+builtin_builder::_sinh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* 0.5 * (e^x - e^(-x)) */
-   body.emit(ret(mul(imm(0.5f), sub(exp(x), exp(neg(x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), sub(exp(x), exp(neg(x))))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_cosh(const glsl_type *type)
+builtin_builder::_cosh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* 0.5 * (e^x + e^(-x)) */
-   body.emit(ret(mul(imm(0.5f), add(exp(x), exp(neg(x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), add(exp(x), exp(neg(x))))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_tanh(const glsl_type *type)
+builtin_builder::_tanh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* Clamp x to [-10, +10] to avoid precision problems.
     * When x > 10, e^(-x) is so small relative to e^x that it gets flushed to
@@ -6190,7 +6205,7 @@ builtin_builder::_tanh(const glsl_type *type)
     * direction when x < -10.
     */
    ir_variable *t = body.make_temp(type, "tmp");
-   body.emit(assign(t, min2(max2(x, imm(-10.0f)), imm(10.0f))));
+   body.emit(assign(t, min2(max2(x, IMM_FP(type, -10.0f)), IMM_FP(type, 10.0f))));
 
    /* (e^x - e^(-x)) / (e^x + e^(-x)) */
    body.emit(ret(div(sub(exp(t), exp(neg(t))),
@@ -6200,34 +6215,37 @@ builtin_builder::_tanh(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_asinh(const glsl_type *type)
+builtin_builder::_asinh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(mul(sign(x), log(add(abs(x), sqrt(add(mul(x, x),
-                                                       imm(1.0f))))))));
+                                                       IMM_FP(type, 1.0f))))))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_acosh(const glsl_type *type)
+builtin_builder::_acosh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(log(add(x, sqrt(sub(mul(x, x), imm(1.0f)))))));
+   body.emit(ret(log(add(x, sqrt(sub(mul(x, x), IMM_FP(type, 1.0f)))))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_atanh(const glsl_type *type)
+builtin_builder::_atanh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(mul(imm(0.5f), log(div(add(imm(1.0f), x),
-                                        sub(imm(1.0f), x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), log(div(add(IMM_FP(type, 1.0f), x),
+                                                 sub(IMM_FP(type, 1.0f), x))))));
    return sig;
 }
 /** @} */
@@ -6246,7 +6264,7 @@ UNOP(exp,         ir_unop_exp,  always_available)
 UNOP(log,         ir_unop_log,  always_available)
 UNOP(exp2,        ir_unop_exp2, always_available)
 UNOP(log2,        ir_unop_log2, always_available)
-UNOP(atan,        ir_unop_atan, always_available)
+UNOPA(atan,        ir_unop_atan)
 UNOPA(sqrt,        ir_unop_sqrt)
 UNOPA(inversesqrt, ir_unop_rsq)
 
@@ -6447,9 +6465,10 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
 }
 
 ir_function_signature *
-builtin_builder::_atan2(const glsl_type *x_type)
+builtin_builder::_atan2(builtin_available_predicate avail,
+                        const glsl_type *x_type)
 {
-   return binop(always_available, ir_binop_atan2, x_type, x_type, x_type);
+   return binop(avail, ir_binop_atan2, x_type, x_type, x_type);
 }
 
 ir_function_signature *
-- 
GitLab


From 46047c0c315cd4e213bce397084313b3ee8c359a Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 1 Jul 2022 16:00:35 +1000
Subject: [PATCH 11/28] glsl: add half float exponential functions

---
 src/compiler/glsl/builtin_functions.cpp | 37 +++++++++++++------------
 1 file changed, 19 insertions(+), 18 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 038deb162664e..49ffaca463d59 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1122,11 +1122,11 @@ private:
    BA1(asinh)
    BA1(acosh)
    BA1(atanh)
-   B1(pow)
-   B1(exp)
-   B1(log)
-   B1(exp2)
-   B1(log2)
+   BA1(pow)
+   BA1(exp)
+   BA1(log)
+   BA1(exp2)
+   BA1(log2)
    BA1(sqrt)
    BA1(inversesqrt)
    BA1(abs)
@@ -2158,13 +2158,13 @@ builtin_builder::create_builtins()
    FHF130(asinh)
    FHF130(acosh)
    FHF130(atanh)
-   F(pow)
-   F(exp)
-   F(log)
-   F(exp2)
-   F(log2)
-   FD(sqrt)
-   FD(inversesqrt)
+   FHF(pow)
+   FHF(exp)
+   FHF(log)
+   FHF(exp2)
+   FHF(log2)
+   FDHF(sqrt)
+   FDHF(inversesqrt)
    FI64(abs)
    FI64(sign)
    FD(floor)
@@ -6255,15 +6255,16 @@ builtin_builder::_atanh(builtin_available_predicate avail,
  */
 
 ir_function_signature *
-builtin_builder::_pow(const glsl_type *type)
+builtin_builder::_pow(builtin_available_predicate avail,
+                      const glsl_type *type)
 {
-   return binop(always_available, ir_binop_pow, type, type, type);
+   return binop(avail, ir_binop_pow, type, type, type);
 }
 
-UNOP(exp,         ir_unop_exp,  always_available)
-UNOP(log,         ir_unop_log,  always_available)
-UNOP(exp2,        ir_unop_exp2, always_available)
-UNOP(log2,        ir_unop_log2, always_available)
+UNOPA(exp,         ir_unop_exp)
+UNOPA(log,         ir_unop_log)
+UNOPA(exp2,        ir_unop_exp2)
+UNOPA(log2,        ir_unop_log2)
 UNOPA(atan,        ir_unop_atan)
 UNOPA(sqrt,        ir_unop_sqrt)
 UNOPA(inversesqrt, ir_unop_rsq)
-- 
GitLab


From c8e5d93a99316e94d63c9c8e7e4df15fbfb77184 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 1 Jul 2022 20:44:31 +1000
Subject: [PATCH 12/28] glsl: add half float support for common functions

---
 src/compiler/glsl/builtin_functions.cpp | 101 +++++++++++++++++++-----
 src/compiler/glsl/ir_validate.cpp       |   6 +-
 2 files changed, 86 insertions(+), 21 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 49ffaca463d59..2794e8094c87d 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2165,14 +2165,14 @@ builtin_builder::create_builtins()
    FHF(log2)
    FDHF(sqrt)
    FDHF(inversesqrt)
-   FI64(abs)
-   FI64(sign)
-   FD(floor)
-   FD130(trunc)
-   FD130GS4(round)
-   FD130(roundEven)
-   FD(ceil)
-   FD(fract)
+   FI64HF(abs)
+   FI64HF(sign)
+   FDHF(floor)
+   FDHF130(trunc)
+   FDHF130GS4(round)
+   FDHF130(roundEven)
+   FDHF(ceil)
+   FDHF(fract)
 
    add_function("truncate",
                 _truncate(gpu_shader4, glsl_type::float_type),
@@ -2192,6 +2192,15 @@ builtin_builder::create_builtins()
                 _mod(always_available, glsl_type::vec3_type,  glsl_type::vec3_type),
                 _mod(always_available, glsl_type::vec4_type,  glsl_type::vec4_type),
 
+                _mod(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::float16_t_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::float16_t_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::float16_t_type),
+
+                _mod(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
+
                 _mod(fp64, glsl_type::double_type, glsl_type::double_type),
                 _mod(fp64, glsl_type::dvec2_type,  glsl_type::double_type),
                 _mod(fp64, glsl_type::dvec3_type,  glsl_type::double_type),
@@ -2202,11 +2211,11 @@ builtin_builder::create_builtins()
                 _mod(fp64, glsl_type::dvec4_type,  glsl_type::dvec4_type),
                 NULL);
 
-   FD130(modf)
+   FDHF130(modf)
 
-   FIUD2_MIXED(min)
-   FIUD2_MIXED(max)
-   FIUD2_MIXED(clamp)
+   FIUDHF2_MIXED(min)
+   FIUDHF2_MIXED(max)
+   FIUDHF2_MIXED(clamp)
 
    add_function("mix",
                 _mix_lrp(always_available, glsl_type::float_type, glsl_type::float_type),
@@ -2218,6 +2227,15 @@ builtin_builder::create_builtins()
                 _mix_lrp(always_available, glsl_type::vec3_type,  glsl_type::vec3_type),
                 _mix_lrp(always_available, glsl_type::vec4_type,  glsl_type::vec4_type),
 
+                _mix_lrp(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::float16_t_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::float16_t_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::float16_t_type),
+
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
+
                 _mix_lrp(fp64, glsl_type::double_type, glsl_type::double_type),
                 _mix_lrp(fp64, glsl_type::dvec2_type,  glsl_type::double_type),
                 _mix_lrp(fp64, glsl_type::dvec3_type,  glsl_type::double_type),
@@ -2232,6 +2250,11 @@ builtin_builder::create_builtins()
                 _mix_sel(v130, glsl_type::vec3_type,  glsl_type::bvec3_type),
                 _mix_sel(v130, glsl_type::vec4_type,  glsl_type::bvec4_type),
 
+                _mix_sel(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::bool_type),
+                _mix_sel(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::bvec2_type),
+                _mix_sel(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::bvec3_type),
+                _mix_sel(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::bvec4_type),
+
                 _mix_sel(fp64, glsl_type::double_type, glsl_type::bool_type),
                 _mix_sel(fp64, glsl_type::dvec2_type,  glsl_type::bvec2_type),
                 _mix_sel(fp64, glsl_type::dvec3_type,  glsl_type::bvec3_type),
@@ -2280,6 +2303,15 @@ builtin_builder::create_builtins()
                 _step(fp64, glsl_type::dvec2_type,  glsl_type::dvec2_type),
                 _step(fp64, glsl_type::dvec3_type,  glsl_type::dvec3_type),
                 _step(fp64, glsl_type::dvec4_type,  glsl_type::dvec4_type),
+
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec2_type),
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec3_type),
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec4_type),
+
+                _step(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _step(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _step(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
                 NULL);
 
    add_function("smoothstep",
@@ -2299,10 +2331,19 @@ builtin_builder::create_builtins()
                 _smoothstep(fp64, glsl_type::dvec2_type,  glsl_type::dvec2_type),
                 _smoothstep(fp64, glsl_type::dvec3_type,  glsl_type::dvec3_type),
                 _smoothstep(fp64, glsl_type::dvec4_type,  glsl_type::dvec4_type),
+
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec2_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec3_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec4_type),
+
+                _smoothstep(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
                 NULL);
 
-   FD130(isnan)
-   FD130(isinf)
+   FDHF130(isnan)
+   FDHF130(isinf)
 
    F(floatBitsToInt)
    F(floatBitsToUint)
@@ -4923,7 +4964,7 @@ builtin_builder::create_builtins()
    IU(bitCount)
    IU(findLSB)
    IU(findMSB)
-   FDGS5(fma)
+   FDHFGS5(fma)
 
    add_function("ldexp",
                 _ldexp(glsl_type::float_type, glsl_type::int_type),
@@ -4934,6 +4975,10 @@ builtin_builder::create_builtins()
                 _ldexp(glsl_type::dvec2_type,  glsl_type::ivec2_type),
                 _ldexp(glsl_type::dvec3_type,  glsl_type::ivec3_type),
                 _ldexp(glsl_type::dvec4_type,  glsl_type::ivec4_type),
+                _ldexp(glsl_type::float16_t_type, glsl_type::int_type),
+                _ldexp(glsl_type::f16vec2_type,  glsl_type::ivec2_type),
+                _ldexp(glsl_type::f16vec3_type,  glsl_type::ivec3_type),
+                _ldexp(glsl_type::f16vec4_type,  glsl_type::ivec4_type),
                 NULL);
 
    add_function("frexp",
@@ -4945,6 +4990,10 @@ builtin_builder::create_builtins()
                 _frexp(glsl_type::dvec2_type,  glsl_type::ivec2_type),
                 _frexp(glsl_type::dvec3_type,  glsl_type::ivec3_type),
                 _frexp(glsl_type::dvec4_type,  glsl_type::ivec4_type),
+                _frexp(glsl_type::float16_t_type, glsl_type::int_type),
+                _frexp(glsl_type::f16vec2_type,  glsl_type::ivec2_type),
+                _frexp(glsl_type::f16vec3_type,  glsl_type::ivec3_type),
+                _frexp(glsl_type::f16vec4_type,  glsl_type::ivec4_type),
                 NULL);
    add_function("uaddCarry",
                 _uaddCarry(glsl_type::uint_type),
@@ -6378,6 +6427,8 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
       /* Both are floats */
       if (edge_type->is_double())
          body.emit(assign(t, f2d(b2f(gequal(x, edge)))));
+      else if (edge_type->base_type == GLSL_TYPE_FLOAT16)
+         body.emit(assign(t, f2f16(b2f(gequal(x, edge)))));
       else
          body.emit(assign(t, b2f(gequal(x, edge))));
    } else if (edge_type->vector_elements == 1) {
@@ -6385,6 +6436,8 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
       for (int i = 0; i < x_type->vector_elements; i++) {
          if (edge_type->is_double())
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
+         else if (edge_type->base_type == GLSL_TYPE_FLOAT16)
+            body.emit(assign(t, f2f16(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), edge)), 1 << i));
       }
@@ -6394,6 +6447,9 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
          if (edge_type->is_double())
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
                              1 << i));
+         else if (edge_type->base_type == GLSL_TYPE_FLOAT16)
+            body.emit(assign(t, f2f16(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
+                             1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1))),
                              1 << i));
@@ -6449,6 +6505,9 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
    ir_constant_data infinities;
    for (int i = 0; i < type->vector_elements; i++) {
       switch (type->base_type) {
+      case GLSL_TYPE_FLOAT16:
+         infinities.f16[i] = _mesa_float_to_half(INFINITY);
+         break;
       case GLSL_TYPE_FLOAT:
          infinities.f[i] = INFINITY;
          break;
@@ -7969,7 +8028,11 @@ builtin_builder::_ldexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_highp_var(x_type, "x");
    ir_variable *y = in_highp_var(exp_type, "y");
-   MAKE_SIG(x_type, x_type->is_double() ? fp64 : gpu_shader5_or_es31_or_integer_functions, 2, x, y);
+   builtin_available_predicate avail = x_type->is_double() ? fp64 :
+      (x_type->base_type == GLSL_TYPE_FLOAT16 ?
+          gpu_shader_half_float : gpu_shader5_or_es31_or_integer_functions);
+
+   MAKE_SIG(x_type, avail, 2, x, y);
    sig->return_precision = GLSL_PRECISION_HIGH;
    body.emit(ret(expr(ir_binop_ldexp, x, y)));
    return sig;
@@ -7980,8 +8043,10 @@ builtin_builder::_frexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_highp_var(x_type, "x");
    ir_variable *exponent = out_var(exp_type, "exp");
-   MAKE_SIG(x_type, x_type->is_double() ? fp64 : gpu_shader5_or_es31_or_integer_functions,
-            2, x, exponent);
+   builtin_available_predicate avail = x_type->is_double() ? fp64 :
+      (x_type->base_type == GLSL_TYPE_FLOAT16 ?
+          gpu_shader_half_float : gpu_shader5_or_es31_or_integer_functions);
+   MAKE_SIG(x_type, avail, 2, x, exponent);
    sig->return_precision = GLSL_PRECISION_HIGH;
 
    body.emit(assign(exponent, expr(ir_unop_frexp_exp, x)));
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index 5640728f6e9fa..2a578ecfdc16c 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -735,10 +735,10 @@ ir_validate::visit_leave(ir_expression *ir)
       break;
 
    case ir_unop_frexp_sig:
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(ir->operands[0]->type->is_float_16_32_64());
       break;
    case ir_unop_frexp_exp:
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(ir->operands[0]->type->is_float_16_32_64());
       assert(ir->type->base_type == GLSL_TYPE_INT);
       break;
    case ir_unop_subroutine_to_int:
@@ -894,7 +894,7 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_binop_ldexp:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(ir->operands[0]->type->is_float_16_32_64());
       assert(ir->operands[1]->type->base_type == GLSL_TYPE_INT);
       assert(ir->operands[0]->type->components() ==
              ir->operands[1]->type->components());
-- 
GitLab


From 7f4e5e22965a8154c383fbe0e7eb6fdfc017b033 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 13:49:06 +1000
Subject: [PATCH 13/28] glsl: add support for half float packing functions

---
 src/compiler/glsl/builtin_functions.cpp | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 2794e8094c87d..4c36626313bcc 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1171,6 +1171,8 @@ private:
    ir_function_signature *_unpackSnorm4x8(builtin_available_predicate avail);
    ir_function_signature *_packHalf2x16(builtin_available_predicate avail);
    ir_function_signature *_unpackHalf2x16(builtin_available_predicate avail);
+   ir_function_signature *_packFloat2x16(builtin_available_predicate avail);
+   ir_function_signature *_unpackFloat2x16(builtin_available_predicate avail);
    ir_function_signature *_packDouble2x32(builtin_available_predicate avail);
    ir_function_signature *_unpackDouble2x32(builtin_available_predicate avail);
    ir_function_signature *_packInt2x32(builtin_available_predicate avail);
@@ -2398,6 +2400,8 @@ builtin_builder::create_builtins()
    add_function("unpackSnorm4x8",  _unpackSnorm4x8(shader_packing_or_es31_or_gpu_shader5), NULL);
    add_function("packHalf2x16",    _packHalf2x16(shader_packing_or_es3),                   NULL);
    add_function("unpackHalf2x16",  _unpackHalf2x16(shader_packing_or_es3),                 NULL);
+   add_function("packFloat2x16",    _packFloat2x16(gpu_shader_half_float),                 NULL);
+   add_function("unpackFloat2x16",  _unpackFloat2x16(gpu_shader_half_float),               NULL);
    add_function("packDouble2x32",    _packDouble2x32(fp64),                   NULL);
    add_function("unpackDouble2x32",  _unpackDouble2x32(fp64),                 NULL);
 
@@ -6704,6 +6708,26 @@ builtin_builder::_unpackHalf2x16(builtin_available_predicate avail)
    return sig;
 }
 
+ir_function_signature *
+builtin_builder::_packFloat2x16(builtin_available_predicate avail)
+{
+   ir_variable *v = in_var(glsl_type::f16vec2_type, "v");
+   MAKE_SIG(glsl_type::uint_type, avail, 1, v);
+
+   ir_rvalue *value = new(mem_ctx)ir_dereference_variable(v);
+   body.emit(ret(expr(ir_unop_pack_half_2x16, new(mem_ctx) ir_expression(ir_unop_f162f, glsl_type::vec2_type, value, NULL))));
+   return sig;
+}
+
+ir_function_signature *
+builtin_builder::_unpackFloat2x16(builtin_available_predicate avail)
+{
+   ir_variable *p = in_var(glsl_type::uint_type, "p");
+   MAKE_SIG(glsl_type::f16vec2_type, avail, 1, p);
+   body.emit(ret(f2f16(expr(ir_unop_unpack_half_2x16, p))));
+   return sig;
+}
+
 ir_function_signature *
 builtin_builder::_packDouble2x32(builtin_available_predicate avail)
 {
-- 
GitLab


From 4e93648a8b23d227a584b034a839e639ae7123d6 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 15:33:10 +1000
Subject: [PATCH 14/28] glsl: add half float geometric functions

---
 src/compiler/glsl/builtin_functions.cpp | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 4c36626313bcc..c42eb36bef3e1 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2410,18 +2410,20 @@ builtin_builder::create_builtins()
    add_function("packUint2x32",    _packUint2x32(int64_avail),                   NULL);
    add_function("unpackUint2x32",  _unpackUint2x32(int64_avail),                 NULL);
 
-   FD(length)
-   FD(distance)
-   FD(dot)
+   FDHF(length)
+   FDHF(distance)
+   FDHF(dot)
 
    add_function("cross", _cross(always_available, glsl_type::vec3_type),
-                _cross(fp64, glsl_type::dvec3_type), NULL);
+                _cross(fp64, glsl_type::dvec3_type),
+                _cross(gpu_shader_half_float, glsl_type::f16vec3_type),
+                NULL);
 
-   FD(normalize)
+   FDHF(normalize)
    add_function("ftransform", _ftransform(), NULL);
-   FD(faceforward)
-   FD(reflect)
-   FD(refract)
+   FDHF(faceforward)
+   FDHF(reflect)
+   FDHF(refract)
    // ...
    add_function("matrixCompMult",
                 _matrixCompMult(always_available, glsl_type::mat2_type),
-- 
GitLab


From bc892e42109ee87b93bd4b1e48908fb1eade136b Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 16:13:01 +1000
Subject: [PATCH 15/28] glsl: add half float matrix functions

---
 src/compiler/glsl/builtin_functions.cpp | 41 +++++++++++++++++++++++--
 1 file changed, 38 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index c42eb36bef3e1..e96c6a9d8ca4b 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2444,6 +2444,15 @@ builtin_builder::create_builtins()
                 _matrixCompMult(fp64, glsl_type::dmat3x4_type),
                 _matrixCompMult(fp64, glsl_type::dmat4x2_type),
                 _matrixCompMult(fp64, glsl_type::dmat4x3_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat4_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat2x3_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat2x4_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat3x2_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat3x4_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat4x2_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
    add_function("outerProduct",
                 _outerProduct(v120, glsl_type::mat2_type),
@@ -2464,6 +2473,15 @@ builtin_builder::create_builtins()
                 _outerProduct(fp64, glsl_type::dmat3x4_type),
                 _outerProduct(fp64, glsl_type::dmat4x2_type),
                 _outerProduct(fp64, glsl_type::dmat4x3_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat4_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat2x3_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat2x4_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat3x2_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat3x4_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat4x2_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
    add_function("determinant",
                 _determinant_mat2(v120, glsl_type::mat2_type),
@@ -2472,7 +2490,9 @@ builtin_builder::create_builtins()
                 _determinant_mat2(fp64, glsl_type::dmat2_type),
                 _determinant_mat3(fp64, glsl_type::dmat3_type),
                 _determinant_mat4(fp64, glsl_type::dmat4_type),
-
+                _determinant_mat2(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _determinant_mat3(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _determinant_mat4(gpu_shader_half_float, glsl_type::f16mat4_type),
                 NULL);
    add_function("inverse",
                 _inverse_mat2(v140_or_es3, glsl_type::mat2_type),
@@ -2481,6 +2501,9 @@ builtin_builder::create_builtins()
                 _inverse_mat2(fp64, glsl_type::dmat2_type),
                 _inverse_mat3(fp64, glsl_type::dmat3_type),
                 _inverse_mat4(fp64, glsl_type::dmat4_type),
+                _inverse_mat2(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _inverse_mat3(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _inverse_mat4(gpu_shader_half_float, glsl_type::f16mat4_type),
                 NULL);
    add_function("transpose",
                 _transpose(v120, glsl_type::mat2_type),
@@ -2501,6 +2524,15 @@ builtin_builder::create_builtins()
                 _transpose(fp64, glsl_type::dmat3x4_type),
                 _transpose(fp64, glsl_type::dmat4x2_type),
                 _transpose(fp64, glsl_type::dmat4x3_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat4_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat2x3_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat2x4_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat3x2_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat3x4_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat4x2_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
    FIUD_VEC(lessThan)
    FIUD_VEC(lessThanEqual)
@@ -6948,6 +6980,9 @@ builtin_builder::_outerProduct(builtin_available_predicate avail, const glsl_typ
    if (type->is_double()) {
       r = in_var(glsl_type::dvec(type->matrix_columns), "r");
       c = in_var(glsl_type::dvec(type->vector_elements), "c");
+   } else if (type->base_type == GLSL_TYPE_FLOAT16) {
+      r = in_var(glsl_type::f16vec(type->matrix_columns), "r");
+      c = in_var(glsl_type::f16vec(type->vector_elements), "c");
    } else {
       r = in_var(glsl_type::vec(type->matrix_columns), "r");
       c = in_var(glsl_type::vec(type->vector_elements), "c");
@@ -7071,7 +7106,7 @@ builtin_builder::_determinant_mat4(builtin_available_predicate avail, const glsl
    body.emit(assign(SubFactor17, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 2)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 2)))));
    body.emit(assign(SubFactor18, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 1)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 1)))));
 
-   ir_variable *adj_0 = body.make_temp(btype == glsl_type::float_type ? glsl_type::vec4_type : glsl_type::dvec4_type, "adj_0");
+   ir_variable *adj_0 = body.make_temp(btype == glsl_type::float_type ? glsl_type::vec4_type : btype == glsl_type::float16_t_type ? glsl_type::f16vec4_type : glsl_type::dvec4_type, "adj_0");
 
    body.emit(assign(adj_0,
                     add(sub(mul(matrix_elt(m, 1, 1), SubFactor00),
@@ -7228,7 +7263,7 @@ builtin_builder::_inverse_mat4(builtin_available_predicate avail, const glsl_typ
    body.emit(assign(SubFactor17, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 2)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 2)))));
    body.emit(assign(SubFactor18, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 1)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 1)))));
 
-   ir_variable *adj = body.make_temp(btype == glsl_type::float_type ? glsl_type::mat4_type : glsl_type::dmat4_type, "adj");
+   ir_variable *adj = body.make_temp(btype == glsl_type::float_type ? glsl_type::mat4_type : (btype == glsl_type::double_type ? glsl_type::dmat4_type : glsl_type::f16mat4_type), "adj");
    body.emit(assign(array_ref(adj, 0),
                     add(sub(mul(matrix_elt(m, 1, 1), SubFactor00),
                             mul(matrix_elt(m, 1, 2), SubFactor01)),
-- 
GitLab


From f24607c1e171b57ac30e7169955ed0c2e0dc0f0b Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 16:29:06 +1000
Subject: [PATCH 16/28] glsl: add half float vector relational functions

---
 src/compiler/glsl/builtin_functions.cpp | 26 +++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index e96c6a9d8ca4b..b571c3f1b2f84 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1942,7 +1942,7 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
-#define FIUD_VEC(NAME)                                            \
+#define FIUDHF_VEC(NAME)                                          \
    add_function(#NAME,                                            \
                 _##NAME(always_available, glsl_type::vec2_type),  \
                 _##NAME(always_available, glsl_type::vec3_type),  \
@@ -1966,6 +1966,9 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::u64vec2_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec3_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
 #define IU(NAME)                                \
@@ -1981,7 +1984,7 @@ builtin_builder::create_builtins()
                 _##NAME(glsl_type::uvec4_type), \
                 NULL);
 
-#define FIUBD_VEC(NAME)                                           \
+#define FIUBDHF_VEC(NAME)                                           \
    add_function(#NAME,                                            \
                 _##NAME(always_available, glsl_type::vec2_type),  \
                 _##NAME(always_available, glsl_type::vec3_type),  \
@@ -2010,6 +2013,9 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::u64vec2_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec3_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
 #define FIUD2_MIXED(NAME)                                                                 \
@@ -2534,12 +2540,12 @@ builtin_builder::create_builtins()
                 _transpose(gpu_shader_half_float, glsl_type::f16mat4x2_type),
                 _transpose(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
-   FIUD_VEC(lessThan)
-   FIUD_VEC(lessThanEqual)
-   FIUD_VEC(greaterThan)
-   FIUD_VEC(greaterThanEqual)
-   FIUBD_VEC(notEqual)
-   FIUBD_VEC(equal)
+   FIUDHF_VEC(lessThan)
+   FIUDHF_VEC(lessThanEqual)
+   FIUDHF_VEC(greaterThan)
+   FIUDHF_VEC(greaterThanEqual)
+   FIUBDHF_VEC(notEqual)
+   FIUBDHF_VEC(equal)
 
    add_function("any",
                 _any(glsl_type::bvec2_type),
@@ -5707,8 +5713,8 @@ builtin_builder::create_builtins()
 
 #undef F
 #undef FI
-#undef FIUD_VEC
-#undef FIUBD_VEC
+#undef FIUDHF_VEC
+#undef FIUBDHF_VEC
 #undef FIU2_MIXED
 }
 
-- 
GitLab


From de30b60aae34febaa02c0df9e075c05fa5c52e91 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 21:42:45 +1000
Subject: [PATCH 17/28] glsl: allow half float varyings

---
 src/compiler/glsl/ast_to_hir.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 6b06f2fbb96fa..7c6b8d320f3cc 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -4296,6 +4296,9 @@ apply_type_qualifier_to_variable(const struct ast_type_qualifier *qual,
       case GLSL_TYPE_FLOAT:
          /* Ok in all GLSL versions */
          break;
+      case GLSL_TYPE_FLOAT16:
+         if (state->AMD_gpu_shader_half_float_enable)
+         break;
       case GLSL_TYPE_UINT:
       case GLSL_TYPE_INT:
          if (state->is_version(130, 300) || state->EXT_gpu_shader4_enable)
-- 
GitLab


From c71dc45961c061855e905c4e08a743404597d2b7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 21:44:00 +1000
Subject: [PATCH 18/28] glsl: add half float interpolation functions

---
 src/compiler/glsl/builtin_functions.cpp | 58 +++++++++++++++++--------
 1 file changed, 39 insertions(+), 19 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index b571c3f1b2f84..0249dec856914 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -474,6 +474,11 @@ fs_interpolate_at(const _mesa_glsl_parse_state *state)
            state->OES_shader_multisample_interpolation_enable);
 }
 
+static bool
+fs_half_float_interpolate_at(const _mesa_glsl_parse_state *state)
+{
+   return fs_interpolate_at(state) && gpu_shader_half_float(state);
+}
 
 static bool
 texture_array_lod(const _mesa_glsl_parse_state *state)
@@ -1285,9 +1290,9 @@ private:
    BA1(averageRounded)
    B1(mulExtended)
    BA1(multiply32x16)
-   B1(interpolateAtCentroid)
-   B1(interpolateAtOffset)
-   B1(interpolateAtSample)
+   BA1(interpolateAtCentroid)
+   BA1(interpolateAtOffset)
+   BA1(interpolateAtSample)
 
    ir_function_signature *_atomic_counter_intrinsic(builtin_available_predicate avail,
                                                     enum ir_intrinsic_id id);
@@ -5064,22 +5069,34 @@ builtin_builder::create_builtins()
                 _mulExtended(glsl_type::uvec4_type),
                 NULL);
    add_function("interpolateAtCentroid",
-                _interpolateAtCentroid(glsl_type::float_type),
-                _interpolateAtCentroid(glsl_type::vec2_type),
-                _interpolateAtCentroid(glsl_type::vec3_type),
-                _interpolateAtCentroid(glsl_type::vec4_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::float_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::vec2_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::vec3_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::vec4_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::float16_t_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::f16vec2_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::f16vec3_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::f16vec4_type),
                 NULL);
    add_function("interpolateAtOffset",
-                _interpolateAtOffset(glsl_type::float_type),
-                _interpolateAtOffset(glsl_type::vec2_type),
-                _interpolateAtOffset(glsl_type::vec3_type),
-                _interpolateAtOffset(glsl_type::vec4_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::float_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::vec2_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::vec3_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::vec4_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::float16_t_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::f16vec2_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::f16vec3_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::f16vec4_type),
                 NULL);
    add_function("interpolateAtSample",
-                _interpolateAtSample(glsl_type::float_type),
-                _interpolateAtSample(glsl_type::vec2_type),
-                _interpolateAtSample(glsl_type::vec3_type),
-                _interpolateAtSample(glsl_type::vec4_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::float_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::vec2_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::vec3_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::vec4_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::float16_t_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::f16vec2_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::f16vec3_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::f16vec4_type),
                 NULL);
 
    add_function("atomicCounter",
@@ -8247,7 +8264,8 @@ builtin_builder::_multiply32x16(builtin_available_predicate avail,
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtCentroid(const glsl_type *type)
+builtin_builder::_interpolateAtCentroid(builtin_available_predicate avail,
+                                        const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
@@ -8259,11 +8277,12 @@ builtin_builder::_interpolateAtCentroid(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtOffset(const glsl_type *type)
+builtin_builder::_interpolateAtOffset(builtin_available_predicate avail,
+                                      const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
-   ir_variable *offset = in_var(glsl_type::vec2_type, "offset");
+   ir_variable *offset = in_var(type->base_type == GLSL_TYPE_FLOAT16 ? glsl_type::f16vec2_type : glsl_type::vec2_type, "offset");
    MAKE_SIG(type, fs_interpolate_at, 2, interpolant, offset);
 
    body.emit(ret(interpolate_at_offset(interpolant, offset)));
@@ -8272,7 +8291,8 @@ builtin_builder::_interpolateAtOffset(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtSample(const glsl_type *type)
+builtin_builder::_interpolateAtSample(builtin_available_predicate avail,
+                                      const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
-- 
GitLab


From 032df745bda3c87fac1828420a69f3f36a921ebd Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 27 Jul 2022 13:48:45 +1000
Subject: [PATCH 19/28] glsl: add half float derivative functions

---
 src/compiler/glsl/builtin_functions.cpp | 99 +++++++++++++++++--------
 1 file changed, 69 insertions(+), 30 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 0249dec856914..695cf5d8583f9 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -625,6 +625,18 @@ derivative_control(const _mesa_glsl_parse_state *state)
            state->ARB_derivative_control_enable);
 }
 
+static bool
+half_float_derivatives(const _mesa_glsl_parse_state *state)
+{
+   return derivatives(state) && gpu_shader_half_float(state);
+}
+
+static bool
+half_float_derivative_control(const _mesa_glsl_parse_state *state)
+{
+   return derivative_control(state) && gpu_shader_half_float(state);
+}
+
 /** True if sampler3D exists */
 static bool
 tex3d(const _mesa_glsl_parse_state *state)
@@ -1255,15 +1267,15 @@ private:
    BA2(textureQueryLod);
    BA1(textureQueryLevels);
    BA2(textureSamplesIdentical);
-   B1(dFdx);
-   B1(dFdy);
-   B1(fwidth);
-   B1(dFdxCoarse);
-   B1(dFdyCoarse);
-   B1(fwidthCoarse);
-   B1(dFdxFine);
-   B1(dFdyFine);
-   B1(fwidthFine);
+   BA1(dFdx);
+   BA1(dFdy);
+   BA1(fwidth);
+   BA1(dFdxCoarse);
+   BA1(dFdyCoarse);
+   BA1(fwidthCoarse);
+   BA1(dFdxFine);
+   BA1(dFdyFine);
+   BA1(fwidthFine);
    B1(noise1);
    B1(noise2);
    B1(noise3);
@@ -1767,6 +1779,30 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
+#define FHF_DERIVATIVES(NAME)                                               \
+   add_function(#NAME,                                                      \
+                _##NAME(derivatives, glsl_type::float_type),                \
+                _##NAME(derivatives, glsl_type::vec2_type),                 \
+                _##NAME(derivatives, glsl_type::vec3_type),                 \
+                _##NAME(derivatives, glsl_type::vec4_type),                 \
+                _##NAME(half_float_derivatives, glsl_type::float16_t_type), \
+                _##NAME(half_float_derivatives, glsl_type::f16vec2_type),   \
+                _##NAME(half_float_derivatives, glsl_type::f16vec3_type),   \
+                _##NAME(half_float_derivatives, glsl_type::f16vec4_type),   \
+                NULL);
+
+#define FHF_DERIVATIVE_CONTROL(NAME)                                               \
+   add_function(#NAME,                                                             \
+                _##NAME(derivative_control, glsl_type::float_type),                \
+                _##NAME(derivative_control, glsl_type::vec2_type),                 \
+                _##NAME(derivative_control, glsl_type::vec3_type),                 \
+                _##NAME(derivative_control, glsl_type::vec4_type),                 \
+                _##NAME(half_float_derivative_control, glsl_type::float16_t_type), \
+                _##NAME(half_float_derivative_control, glsl_type::f16vec2_type),   \
+                _##NAME(half_float_derivative_control, glsl_type::f16vec3_type),   \
+                _##NAME(half_float_derivative_control, glsl_type::f16vec4_type),   \
+                NULL);
+
 #define FHF130(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(v130, glsl_type::float_type), \
@@ -4993,15 +5029,15 @@ builtin_builder::create_builtins()
                 _texture(ir_txd, v130_desktop_and_clamp, glsl_type::float_type, glsl_type::sampler2DArrayShadow_type, glsl_type::vec4_type, TEX_OFFSET|TEX_CLAMP),
                 NULL);
 
-   F(dFdx)
-   F(dFdy)
-   F(fwidth)
-   F(dFdxCoarse)
-   F(dFdyCoarse)
-   F(fwidthCoarse)
-   F(dFdxFine)
-   F(dFdyFine)
-   F(fwidthFine)
+   FHF_DERIVATIVES(dFdx)
+   FHF_DERIVATIVES(dFdy)
+   FHF_DERIVATIVES(fwidth)
+   FHF_DERIVATIVE_CONTROL(dFdxCoarse)
+   FHF_DERIVATIVE_CONTROL(dFdyCoarse)
+   FHF_DERIVATIVE_CONTROL(fwidthCoarse)
+   FHF_DERIVATIVE_CONTROL(dFdxFine)
+   FHF_DERIVATIVE_CONTROL(dFdyFine)
+   FHF_DERIVATIVE_CONTROL(fwidthFine)
    F(noise1)
    F(noise2)
    F(noise3)
@@ -7897,18 +7933,19 @@ builtin_builder::_textureSamplesIdentical(builtin_available_predicate avail,
    return sig;
 }
 
-UNOP(dFdx, ir_unop_dFdx, derivatives)
-UNOP(dFdxCoarse, ir_unop_dFdx_coarse, derivative_control)
-UNOP(dFdxFine, ir_unop_dFdx_fine, derivative_control)
-UNOP(dFdy, ir_unop_dFdy, derivatives)
-UNOP(dFdyCoarse, ir_unop_dFdy_coarse, derivative_control)
-UNOP(dFdyFine, ir_unop_dFdy_fine, derivative_control)
+UNOPA(dFdx, ir_unop_dFdx)
+UNOPA(dFdxCoarse, ir_unop_dFdx_coarse)
+UNOPA(dFdxFine, ir_unop_dFdx_fine)
+UNOPA(dFdy, ir_unop_dFdy)
+UNOPA(dFdyCoarse, ir_unop_dFdy_coarse)
+UNOPA(dFdyFine, ir_unop_dFdy_fine)
 
 ir_function_signature *
-builtin_builder::_fwidth(const glsl_type *type)
+builtin_builder::_fwidth(builtin_available_predicate avail,
+                         const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivatives, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx, p)), abs(expr(ir_unop_dFdy, p)))));
 
@@ -7916,10 +7953,11 @@ builtin_builder::_fwidth(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_fwidthCoarse(const glsl_type *type)
+builtin_builder::_fwidthCoarse(builtin_available_predicate avail,
+                               const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivative_control, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx_coarse, p)),
                      abs(expr(ir_unop_dFdy_coarse, p)))));
@@ -7928,10 +7966,11 @@ builtin_builder::_fwidthCoarse(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_fwidthFine(const glsl_type *type)
+builtin_builder::_fwidthFine(builtin_available_predicate avail,
+                             const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivative_control, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx_fine, p)),
                      abs(expr(ir_unop_dFdy_fine, p)))));
-- 
GitLab


From 561bf3c92c7aa0267255807fcc3b73373723420f Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 27 Jul 2022 14:27:04 +1000
Subject: [PATCH 20/28] glsl: add half float AMD_shader_trinary_minmax
 functions

---
 src/compiler/glsl/builtin_functions.cpp | 114 ++++++++++++++----------
 1 file changed, 69 insertions(+), 45 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 695cf5d8583f9..c02b17482af89 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -724,6 +724,12 @@ shader_trinary_minmax(const _mesa_glsl_parse_state *state)
    return state->AMD_shader_trinary_minmax_enable;
 }
 
+static bool
+shader_trinary_minmax_half_float(const _mesa_glsl_parse_state *state)
+{
+   return shader_trinary_minmax(state) && gpu_shader_half_float(state);
+}
+
 static bool
 shader_image_load_store(const _mesa_glsl_parse_state *state)
 {
@@ -1332,9 +1338,9 @@ private:
                                       builtin_available_predicate avail,
                                       const glsl_type *type);
 
-   B1(min3)
-   B1(max3)
-   B1(mid3)
+   BA1(min3)
+   BA1(max3)
+   BA1(mid3)
 
    ir_function_signature *_image_prototype(const glsl_type *image_type,
                                            unsigned num_arguments,
@@ -5342,54 +5348,69 @@ builtin_builder::create_builtins()
                 NULL);
 
    add_function("min3",
-                _min3(glsl_type::float_type),
-                _min3(glsl_type::vec2_type),
-                _min3(glsl_type::vec3_type),
-                _min3(glsl_type::vec4_type),
+                _min3(shader_trinary_minmax, glsl_type::float_type),
+                _min3(shader_trinary_minmax, glsl_type::vec2_type),
+                _min3(shader_trinary_minmax, glsl_type::vec3_type),
+                _min3(shader_trinary_minmax, glsl_type::vec4_type),
+
+                _min3(shader_trinary_minmax_half_float, glsl_type::float16_t_type),
+                _min3(shader_trinary_minmax_half_float, glsl_type::f16vec2_type),
+                _min3(shader_trinary_minmax_half_float, glsl_type::f16vec3_type),
+                _min3(shader_trinary_minmax_half_float, glsl_type::f16vec4_type),
 
-                _min3(glsl_type::int_type),
-                _min3(glsl_type::ivec2_type),
-                _min3(glsl_type::ivec3_type),
-                _min3(glsl_type::ivec4_type),
+                _min3(shader_trinary_minmax, glsl_type::int_type),
+                _min3(shader_trinary_minmax, glsl_type::ivec2_type),
+                _min3(shader_trinary_minmax, glsl_type::ivec3_type),
+                _min3(shader_trinary_minmax, glsl_type::ivec4_type),
 
-                _min3(glsl_type::uint_type),
-                _min3(glsl_type::uvec2_type),
-                _min3(glsl_type::uvec3_type),
-                _min3(glsl_type::uvec4_type),
+                _min3(shader_trinary_minmax, glsl_type::uint_type),
+                _min3(shader_trinary_minmax, glsl_type::uvec2_type),
+                _min3(shader_trinary_minmax, glsl_type::uvec3_type),
+                _min3(shader_trinary_minmax, glsl_type::uvec4_type),
                 NULL);
 
    add_function("max3",
-                _max3(glsl_type::float_type),
-                _max3(glsl_type::vec2_type),
-                _max3(glsl_type::vec3_type),
-                _max3(glsl_type::vec4_type),
+                _max3(shader_trinary_minmax, glsl_type::float_type),
+                _max3(shader_trinary_minmax, glsl_type::vec2_type),
+                _max3(shader_trinary_minmax, glsl_type::vec3_type),
+                _max3(shader_trinary_minmax, glsl_type::vec4_type),
 
-                _max3(glsl_type::int_type),
-                _max3(glsl_type::ivec2_type),
-                _max3(glsl_type::ivec3_type),
-                _max3(glsl_type::ivec4_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::float16_t_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::f16vec2_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::f16vec3_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::f16vec4_type),
 
-                _max3(glsl_type::uint_type),
-                _max3(glsl_type::uvec2_type),
-                _max3(glsl_type::uvec3_type),
-                _max3(glsl_type::uvec4_type),
+                _max3(shader_trinary_minmax, glsl_type::int_type),
+                _max3(shader_trinary_minmax, glsl_type::ivec2_type),
+                _max3(shader_trinary_minmax, glsl_type::ivec3_type),
+                _max3(shader_trinary_minmax, glsl_type::ivec4_type),
+
+                _max3(shader_trinary_minmax, glsl_type::uint_type),
+                _max3(shader_trinary_minmax, glsl_type::uvec2_type),
+                _max3(shader_trinary_minmax, glsl_type::uvec3_type),
+                _max3(shader_trinary_minmax, glsl_type::uvec4_type),
                 NULL);
 
    add_function("mid3",
-                _mid3(glsl_type::float_type),
-                _mid3(glsl_type::vec2_type),
-                _mid3(glsl_type::vec3_type),
-                _mid3(glsl_type::vec4_type),
+                _mid3(shader_trinary_minmax, glsl_type::float_type),
+                _mid3(shader_trinary_minmax, glsl_type::vec2_type),
+                _mid3(shader_trinary_minmax, glsl_type::vec3_type),
+                _mid3(shader_trinary_minmax, glsl_type::vec4_type),
+
+                _mid3(shader_trinary_minmax_half_float, glsl_type::float16_t_type),
+                _mid3(shader_trinary_minmax_half_float, glsl_type::f16vec2_type),
+                _mid3(shader_trinary_minmax_half_float, glsl_type::f16vec3_type),
+                _mid3(shader_trinary_minmax_half_float, glsl_type::f16vec4_type),
 
-                _mid3(glsl_type::int_type),
-                _mid3(glsl_type::ivec2_type),
-                _mid3(glsl_type::ivec3_type),
-                _mid3(glsl_type::ivec4_type),
+                _mid3(shader_trinary_minmax, glsl_type::int_type),
+                _mid3(shader_trinary_minmax, glsl_type::ivec2_type),
+                _mid3(shader_trinary_minmax, glsl_type::ivec3_type),
+                _mid3(shader_trinary_minmax, glsl_type::ivec4_type),
 
-                _mid3(glsl_type::uint_type),
-                _mid3(glsl_type::uvec2_type),
-                _mid3(glsl_type::uvec3_type),
-                _mid3(glsl_type::uvec4_type),
+                _mid3(shader_trinary_minmax, glsl_type::uint_type),
+                _mid3(shader_trinary_minmax, glsl_type::uvec2_type),
+                _mid3(shader_trinary_minmax, glsl_type::uvec3_type),
+                _mid3(shader_trinary_minmax, glsl_type::uvec4_type),
                 NULL);
 
    add_image_functions(true);
@@ -8510,12 +8531,13 @@ builtin_builder::_atomic_op3(const char *intrinsic,
 }
 
 ir_function_signature *
-builtin_builder::_min3(const glsl_type *type)
+builtin_builder::_min3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *min3 = min2(x, min2(y,z));
    body.emit(ret(min3));
@@ -8524,12 +8546,13 @@ builtin_builder::_min3(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_max3(const glsl_type *type)
+builtin_builder::_max3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *max3 = max2(x, max2(y,z));
    body.emit(ret(max3));
@@ -8538,12 +8561,13 @@ builtin_builder::_max3(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_mid3(const glsl_type *type)
+builtin_builder::_mid3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *mid3 = max2(min2(x, y), max2(min2(x, z), min2(y, z)));
    body.emit(ret(mid3));
-- 
GitLab


From 9f5c277a357b44f4db0b60c1ada44bc333649ac3 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 29 Jul 2022 10:46:34 +1000
Subject: [PATCH 21/28] glsl: store xfb stride in "machine units"

Previously we stored it as number of 32bit components and converted
it from that when needed. This worked okish for 64bit component
handing, however it will not work for half float support.

So here we switch to the number of 8bit "machine units" as the spec
refers to them.
---
 src/compiler/glsl/gl_nir_link_varyings.c | 20 ++++++++++----------
 src/compiler/glsl/gl_nir_link_xfb.c      |  4 ++--
 src/mesa/main/shader_query.cpp           |  2 +-
 src/mesa/main/shader_types.h             |  6 +++---
 src/mesa/state_tracker/st_program.c      |  2 +-
 5 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_link_varyings.c b/src/compiler/glsl/gl_nir_link_varyings.c
index 354c741b2e17b..e1d306e688c7f 100644
--- a/src/compiler/glsl/gl_nir_link_varyings.c
+++ b/src/compiler/glsl/gl_nir_link_varyings.c
@@ -983,7 +983,7 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
    unsigned size = xfb_decl->size;
    /* Handle gl_SkipComponents. */
    if (xfb_decl->skip_components) {
-      info->Buffers[buffer].Stride += xfb_decl->skip_components;
+      info->Buffers[buffer].Stride += xfb_decl->skip_components * 4;
       size = xfb_decl->skip_components;
       goto store_varying;
    }
@@ -996,7 +996,7 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
    if (has_xfb_qualifiers) {
       xfb_offset = xfb_decl->offset / 4;
    } else {
-      xfb_offset = info->Buffers[buffer].Stride;
+      xfb_offset = info->Buffers[buffer].Stride / 4;
    }
    info->Varyings[info->NumVarying].Offset = xfb_offset * 4;
 
@@ -1146,28 +1146,28 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
 
    if (explicit_stride && explicit_stride[buffer]) {
       if (_mesa_gl_datatype_is_64bit(xfb_decl->type) &&
-          info->Buffers[buffer].Stride % 2) {
+          info->Buffers[buffer].Stride % 8) {
          linker_error(prog, "invalid qualifier xfb_stride=%d must be a "
                       "multiple of 8 as its applied to a type that is or "
                       "contains a double.",
-                      info->Buffers[buffer].Stride * 4);
+                      info->Buffers[buffer].Stride);
          return false;
       }
 
-      if (xfb_offset > info->Buffers[buffer].Stride) {
+      if ((xfb_offset * 4) > info->Buffers[buffer].Stride) {
          linker_error(prog, "xfb_offset (%d) overflows xfb_stride (%d) for "
                       "buffer (%d)", xfb_offset * 4,
-                      info->Buffers[buffer].Stride * 4, buffer);
+                      info->Buffers[buffer].Stride, buffer);
          return false;
       }
    } else {
       if (max_member_alignment && has_xfb_qualifiers) {
          max_member_alignment[buffer] = MAX2(max_member_alignment[buffer],
-                                             _mesa_gl_datatype_is_64bit(xfb_decl->type) ? 2 : 1);
-         info->Buffers[buffer].Stride = ALIGN(xfb_offset,
+                                             _mesa_gl_datatype_is_64bit(xfb_decl->type) ? 8 : 4);
+         info->Buffers[buffer].Stride = ALIGN((xfb_offset * 4),
                                               max_member_alignment[buffer]);
       } else {
-         info->Buffers[buffer].Stride = xfb_offset;
+         info->Buffers[buffer].Stride = xfb_offset * 4;
       }
    }
 
@@ -1373,7 +1373,7 @@ store_tfeedback_info(const struct gl_constants *consts,
             if (prog->TransformFeedback.BufferStride[j]) {
                explicit_stride[j] = true;
                xfb_prog->sh.LinkedTransformFeedback->Buffers[j].Stride =
-                  prog->TransformFeedback.BufferStride[j] / 4;
+                  prog->TransformFeedback.BufferStride[j];
             }
          }
       }
diff --git a/src/compiler/glsl/gl_nir_link_xfb.c b/src/compiler/glsl/gl_nir_link_xfb.c
index 3492ccdc5a977..022e6d5ba6329 100644
--- a/src/compiler/glsl/gl_nir_link_xfb.c
+++ b/src/compiler/glsl/gl_nir_link_xfb.c
@@ -185,7 +185,7 @@ gl_nir_link_assign_xfb_resources(const struct gl_constants *consts,
 
    for (unsigned buf = 0; buf < MAX_FEEDBACK_BUFFERS; buf++) {
       if (xfb_info->buffers[buf].stride > 0) {
-         linked_xfb->Buffers[buf].Stride = xfb_info->buffers[buf].stride / 4;
+         linked_xfb->Buffers[buf].Stride = xfb_info->buffers[buf].stride;
          linked_xfb->Buffers[buf].NumVaryings = xfb_info->buffers[buf].varying_count;
          buffers |= 1 << buf;
       }
@@ -208,7 +208,7 @@ gl_to_nir_xfb_info(struct gl_transform_feedback_info *info, void *mem_ctx)
    xfb->output_count = info->NumOutputs;
 
    for (unsigned i = 0; i < MAX_FEEDBACK_BUFFERS; i++) {
-      xfb->buffers[i].stride = info->Buffers[i].Stride * 4;
+      xfb->buffers[i].stride = info->Buffers[i].Stride;
       xfb->buffers[i].varying_count = info->Buffers[i].NumVaryings;
       xfb->buffer_to_stream[i] = info->Buffers[i].Stream;
    }
diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index 37173696074b2..2e74db849c1fb 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -1675,7 +1675,7 @@ _mesa_program_resource_prop(struct gl_shader_program *shProg,
       return 1;
    case GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE:
       VALIDATE_TYPE(GL_TRANSFORM_FEEDBACK_BUFFER);
-      *val = RESOURCE_XFB(res)->Stride * 4;
+      *val = RESOURCE_XFB(res)->Stride;
       return 1;
 
    default:
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index 9e2b614f6e326..f538b39ead611 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -765,9 +765,9 @@ struct gl_transform_feedback_buffer
    uint32_t NumVaryings;
 
    /**
-    * Total number of components stored in each buffer.  This may be used by
-    * hardware back-ends to determine the correct stride when interleaving
-    * multiple transform feedback outputs in the same buffer.
+    * Total number of basic machine units stored in each buffer.  This may
+    * be used by hardware back-ends to determine the correct stride when
+    * interleaving multiple transform feedback outputs in the same buffer.
     */
    uint32_t Stride;
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 3936d8fc4453f..6b06ef7064b9e 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -480,7 +480,7 @@ st_translate_stream_output_info(struct gl_program *prog)
    }
 
    for (unsigned i = 0; i < PIPE_MAX_SO_BUFFERS; i++) {
-      so_info->stride[i] = info->Buffers[i].Stride;
+      so_info->stride[i] = info->Buffers[i].Stride / 4;
    }
    so_info->num_outputs = info->NumOutputs;
 }
-- 
GitLab


From 66f439fc135c64e32247eeec5a9e219283323ff7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:08:44 +1000
Subject: [PATCH 22/28] glsl: fix copy and pasted typo

Fixes: 30b548fc6258 ("compiler/types: Add a contains_64bit helper")
---
 src/compiler/glsl_types.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 96ed6eaec06c1..2ee41b717d09d 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -793,7 +793,7 @@ public:
 
    /**
     * Query whether or not type is a 64-bit type, or for struct, interface and
-    * array types, contains a double type.
+    * array types, contains a 64-bit type.
     */
    bool contains_64bit() const;
 
-- 
GitLab


From 457b7affbd9a615676749bc0e3382a0058864a58 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 14:07:11 +1000
Subject: [PATCH 23/28] compiler/types: Add a contains_32bit helper

---
 src/compiler/glsl_types.cpp | 16 ++++++++++++++++
 src/compiler/glsl_types.h   |  6 ++++++
 2 files changed, 22 insertions(+)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 9f4d9fe4a4dcf..91db4171b7e43 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -262,6 +262,22 @@ glsl_type::contains_integer() const
    }
 }
 
+bool
+glsl_type::contains_32bit() const
+{
+   if (this->is_array()) {
+      return this->fields.array->contains_32bit();
+   } else if (this->is_struct() || this->is_interface()) {
+      for (unsigned int i = 0; i < this->length; i++) {
+         if (this->fields.structure[i].type->contains_32bit())
+            return true;
+      }
+      return false;
+   } else {
+      return this->is_32bit();
+   }
+}
+
 bool
 glsl_type::contains_double() const
 {
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 2ee41b717d09d..a18e06578dfbe 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -785,6 +785,12 @@ public:
     */
    bool contains_integer() const;
 
+   /**
+    * Query whether or not type is a 32-bit type, or for struct, interface and
+    * array types, contains a 32-bit type.
+    */
+   bool contains_32bit() const;
+
    /**
     * Query whether or not type is a double type, or for struct, interface and
     * array types, contains a double type.
-- 
GitLab


From 5ece08ee27c9d4b432379f35a7d9fc7539fdbaa1 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:30:29 +1000
Subject: [PATCH 24/28] compiler/types: Add a xfb_component_size() helper

This also includes support for returning the size of half float
components.
---
 src/compiler/glsl_types.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index a18e06578dfbe..86a412e0fa2ba 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1057,6 +1057,13 @@ public:
       return glsl_base_type_bit_size(this->base_type);
    }
 
+   /**
+    * Return the xfb component size in bytes for this type.
+    */
+   unsigned xfb_component_size() const
+   {
+      return this->contains_double() ? 8 : (this->contains_32bit() ? 4 : 2);
+   }
 
    /**
     * Query whether or not a type is an atomic_uint.
-- 
GitLab


From c553e7caad300c474194104015deadf16325f1cc Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:33:29 +1000
Subject: [PATCH 25/28] glsl: make use of xfb_component_size() helper

---
 src/compiler/glsl/ast_to_hir.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 7c6b8d320f3cc..7d3a6484ea563 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -2949,7 +2949,7 @@ validate_xfb_offset_qualifier(YYLTYPE *loc,
           * we apply the component size rules at the member level.
           */
          if (xfb_offset == -1)
-            component_size = member_t->contains_double() ? 8 : 4;
+            component_size = member_t->xfb_component_size();
 
          int xfb_offset = t_without_array->fields.structure[i].offset;
          validate_xfb_offset_qualifier(loc, state, xfb_offset, member_t,
@@ -3898,7 +3898,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
 
    if (qual->flags.q.explicit_xfb_offset) {
       unsigned qual_xfb_offset;
-      unsigned component_size = var->type->contains_double() ? 8 : 4;
+      unsigned component_size = var->type->xfb_component_size();
 
       if (process_qualifier_constant(state, loc, "xfb_offset",
                                      qual->offset, &qual_xfb_offset) &&
@@ -8407,7 +8407,7 @@ ast_interface_block::hir(exec_list *instructions,
                                            GLSL_MATRIX_LAYOUT_ROW_MAJOR,
                                         this->block_name);
 
-   unsigned component_size = block_type->contains_double() ? 8 : 4;
+   unsigned component_size = block_type->xfb_component_size();
    int xfb_offset =
       layout.flags.q.explicit_xfb_offset ? (int) qual_xfb_offset : -1;
    validate_xfb_offset_qualifier(&loc, state, xfb_offset, block_type,
-- 
GitLab


From 9845cca89e303cf4720312bd0c911b792f21a2a9 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 12:13:36 +1100
Subject: [PATCH 26/28] glsl: add f2f16() helper to ir_builder

---
 src/compiler/glsl/ir_builder.cpp | 6 ++++++
 src/compiler/glsl/ir_builder.h   | 2 ++
 2 files changed, 8 insertions(+)

diff --git a/src/compiler/glsl/ir_builder.cpp b/src/compiler/glsl/ir_builder.cpp
index 770ba692efde5..6894a1224b54a 100644
--- a/src/compiler/glsl/ir_builder.cpp
+++ b/src/compiler/glsl/ir_builder.cpp
@@ -553,6 +553,12 @@ interpolate_at_sample(operand a, operand b)
    return expr(ir_binop_interpolate_at_sample, a, b);
 }
 
+ir_expression *
+f2f16(operand a)
+{
+   return expr(ir_unop_f2f16, a);
+}
+
 ir_expression *
 f2d(operand a)
 {
diff --git a/src/compiler/glsl/ir_builder.h b/src/compiler/glsl/ir_builder.h
index dc7d698f4e9a7..f46d9257aed42 100644
--- a/src/compiler/glsl/ir_builder.h
+++ b/src/compiler/glsl/ir_builder.h
@@ -180,6 +180,8 @@ ir_expression *i2b(operand a);
 ir_expression *f2b(operand a);
 ir_expression *b2f(operand a);
 
+ir_expression *f2f16(operand a);
+
 ir_expression *f2d(operand a);
 ir_expression *i2d(operand a);
 ir_expression *u2d(operand a);
-- 
GitLab


From 2f64f2a58c6e5a396aa81c0dabdab4c984ae3b9e Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 15:35:09 +1100
Subject: [PATCH 27/28] gallium: add PIPE_CAP_FP16 for
 AMD_gpu_shader_half_float

---
 docs/gallium/screen.rst                | 1 +
 src/gallium/auxiliary/util/u_screen.c  | 1 +
 src/gallium/include/pipe/p_defines.h   | 1 +
 src/mesa/state_tracker/st_extensions.c | 1 +
 4 files changed, 4 insertions(+)

diff --git a/docs/gallium/screen.rst b/docs/gallium/screen.rst
index d66453c76edac..70994cbb2e79a 100644
--- a/docs/gallium/screen.rst
+++ b/docs/gallium/screen.rst
@@ -426,6 +426,7 @@ The integer capabilities:
 * ``PIPE_CAP_LEGACY_MATH_RULES``: Whether NIR shaders support the
   ``shader_info.use_legacy_math_rules`` flag (see documentation there), and
   TGSI shaders support the corresponding ``TGSI_PROPERTY_LEGACY_MATH_RULES``.
+* ``PIPE_CAP_FP16``: Whether 16-bit float operations are supported.
 * ``PIPE_CAP_DOUBLES``: Whether double precision floating-point operations
   are supported.
 * ``PIPE_CAP_INT64``: Whether 64-bit integer operations are supported.
diff --git a/src/gallium/auxiliary/util/u_screen.c b/src/gallium/auxiliary/util/u_screen.c
index f7005cbcf2aac..d4c42e91e447e 100644
--- a/src/gallium/auxiliary/util/u_screen.c
+++ b/src/gallium/auxiliary/util/u_screen.c
@@ -332,6 +332,7 @@ u_pipe_screen_get_param_defaults(struct pipe_screen *pscreen,
    case PIPE_CAP_FBFETCH_ZS:
    case PIPE_CAP_BLEND_EQUATION_ADVANCED:
    case PIPE_CAP_LEGACY_MATH_RULES:
+   case PIPE_CAP_FP16:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
    case PIPE_CAP_INT64_DIVMOD:
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 3b9a6a9e6466c..ba446c9d1c68b 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -797,6 +797,7 @@ enum pipe_cap
    PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS,
    PIPE_CAP_FBFETCH,
    PIPE_CAP_LEGACY_MATH_RULES,
+   PIPE_CAP_FP16,
    PIPE_CAP_DOUBLES,
    PIPE_CAP_INT64,
    PIPE_CAP_INT64_DIVMOD,
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index c19f3084ad017..9ce866a31de4a 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -846,6 +846,7 @@ void st_init_extensions(struct pipe_screen *screen,
 
       { o(AMD_depth_clamp_separate),         PIPE_CAP_DEPTH_CLIP_DISABLE_SEPARATE      },
       { o(AMD_framebuffer_multisample_advanced), PIPE_CAP_FRAMEBUFFER_MSAA_CONSTRAINTS },
+      { o(AMD_gpu_shader_half_float),        PIPE_CAP_FP16                             },
       { o(AMD_pinned_memory),                PIPE_CAP_RESOURCE_FROM_USER_MEMORY        },
       { o(ATI_meminfo),                      PIPE_CAP_QUERY_MEMORY_INFO                },
       { o(AMD_seamless_cubemap_per_texture), PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE    },
-- 
GitLab


From a1382c01ae5b78676a4e638d93823e32ff8b444c Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 15:51:34 +1100
Subject: [PATCH 28/28] radeonsi: enable AMD_gpu_shader_half_float

---
 src/gallium/drivers/radeonsi/si_get.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 676ca9a1756eb..b39b947f51417 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -163,6 +163,9 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_NULL_TEXTURES:
       return 1;
 
+   case PIPE_CAP_FP16:
+      return sscreen->info.gfx_level >= GFX8;
+
    case PIPE_CAP_TEXTURE_TRANSFER_MODES:
       return PIPE_TEXTURE_TRANSFER_BLIT;
 
-- 
GitLab

