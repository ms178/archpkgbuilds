From ac83c7b764ac3a67eff80619eb417f803469e489 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 24 Jun 2022 15:24:20 +1000
Subject: [PATCH 01/27] glsl: add basic params for AMD_gpu_shader_half_float
 extension

This sets us the basic infrastructure to required to add an
extension.
---
 src/compiler/glsl/glsl_parser_extras.cpp | 1 +
 src/compiler/glsl/glsl_parser_extras.h   | 2 ++
 src/mesa/main/consts_exts.h              | 1 +
 src/mesa/main/extensions_table.h         | 1 +
 4 files changed, 5 insertions(+)

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index afb7f439e96d9..918286703d0eb 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -741,6 +741,7 @@ static const _mesa_glsl_extension _mesa_glsl_supported_extensions[] = {
    /* All other extensions go here, sorted alphabetically.
     */
    EXT(AMD_conservative_depth),
+   EXT(AMD_gpu_shader_half_float),
    EXT(AMD_gpu_shader_int64),
    EXT(AMD_shader_stencil_export),
    EXT(AMD_shader_trinary_minmax),
diff --git a/src/compiler/glsl/glsl_parser_extras.h b/src/compiler/glsl/glsl_parser_extras.h
index d6505eecd0395..f91b88d0b7bdd 100644
--- a/src/compiler/glsl/glsl_parser_extras.h
+++ b/src/compiler/glsl/glsl_parser_extras.h
@@ -820,6 +820,8 @@ struct _mesa_glsl_parse_state {
     */
    bool AMD_conservative_depth_enable;
    bool AMD_conservative_depth_warn;
+   bool AMD_gpu_shader_half_float_enable;
+   bool AMD_gpu_shader_half_float_warn;
    bool AMD_gpu_shader_int64_enable;
    bool AMD_gpu_shader_int64_warn;
    bool AMD_shader_stencil_export_enable;
diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 5f68df7bc2966..c1e05f8a9d850 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -224,6 +224,7 @@ struct gl_extensions
    GLboolean AMD_compressed_ATC_texture;
    GLboolean AMD_framebuffer_multisample_advanced;
    GLboolean AMD_depth_clamp_separate;
+   GLboolean AMD_gpu_shader_half_float;
    GLboolean AMD_performance_monitor;
    GLboolean AMD_pinned_memory;
    GLboolean AMD_seamless_cubemap_per_texture;
diff --git a/src/mesa/main/extensions_table.h b/src/mesa/main/extensions_table.h
index c4ed8c644159d..26491e6ef221c 100644
--- a/src/mesa/main/extensions_table.h
+++ b/src/mesa/main/extensions_table.h
@@ -13,6 +13,7 @@ EXT(AMD_conservative_depth                  , ARB_conservative_depth
 EXT(AMD_depth_clamp_separate                , AMD_depth_clamp_separate               , GLL, GLC,  x ,  x , 2009)
 EXT(AMD_draw_buffers_blend                  , ARB_draw_buffers_blend                 , GLL, GLC,  x ,  x , 2009)
 EXT(AMD_framebuffer_multisample_advanced    , AMD_framebuffer_multisample_advanced   , GLL, GLC,  x , ES2, 2018)
+EXT(AMD_gpu_shader_half_float               , AMD_gpu_shader_half_float              ,  40,  40,  x ,  x , 2016)
 EXT(AMD_gpu_shader_int64                    , ARB_gpu_shader_int64                   ,  x , GLC,  x ,  x , 2015)
 EXT(AMD_multi_draw_indirect                 , ARB_draw_indirect                      , GLL, GLC,  x ,  x , 2011)
 EXT(AMD_performance_monitor                 , AMD_performance_monitor                , GLL, GLC,  x , ES2, 2007)
-- 
GitLab


From a427b188ec9355f1220154efc322dfc023b3f080 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 24 Jun 2022 16:26:11 +1000
Subject: [PATCH 02/27] glsl: add half float support to the parser

---
 src/compiler/glsl/ast.h          |  2 ++
 src/compiler/glsl/ast_to_hir.cpp |  5 +++++
 src/compiler/glsl/glsl_lexer.ll  | 28 ++++++++++++++++++++++++++++
 src/compiler/glsl/glsl_parser.yy |  9 ++++++++-
 4 files changed, 43 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl/ast.h b/src/compiler/glsl/ast.h
index 7be83da9ada47..6450fed9ff611 100644
--- a/src/compiler/glsl/ast.h
+++ b/src/compiler/glsl/ast.h
@@ -197,6 +197,7 @@ enum ast_operators {
    ast_identifier,
    ast_int_constant,
    ast_uint_constant,
+   ast_float16_constant,
    ast_float_constant,
    ast_bool_constant,
    ast_double_constant,
@@ -258,6 +259,7 @@ public:
    union {
       const char *identifier;
       int int_constant;
+      float float16_constant;
       float float_constant;
       unsigned uint_constant;
       int bool_constant;
diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 8b5cdd5cb3557..0c59c2b6710c4 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -2113,6 +2113,10 @@ ast_expression::do_hir(exec_list *instructions,
       result = new(ctx) ir_constant(this->primary_expression.uint_constant);
       break;
 
+   case ast_float16_constant:
+      result = new(ctx) ir_constant(float16_t(this->primary_expression.float16_constant));
+      break;
+
    case ast_float_constant:
       result = new(ctx) ir_constant(this->primary_expression.float_constant);
       break;
@@ -2256,6 +2260,7 @@ ast_expression::has_sequence_subexpression() const
    case ast_identifier:
    case ast_int_constant:
    case ast_uint_constant:
+   case ast_float16_constant:
    case ast_float_constant:
    case ast_bool_constant:
    case ast_double_constant:
diff --git a/src/compiler/glsl/glsl_lexer.ll b/src/compiler/glsl/glsl_lexer.ll
index b8d6b4bb1ba8c..611b3643a537b 100644
--- a/src/compiler/glsl/glsl_lexer.ll
+++ b/src/compiler/glsl/glsl_lexer.ll
@@ -609,6 +609,16 @@ layout		{
 			    return LITERAL_INTEGER(8);
 			}
 
+[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?(hf|HF)	|
+\.[0-9]+([eE][+-]?[0-9]+)?(hf|HF)	|
+[0-9]+\.([eE][+-]?[0-9]+)?(hf|HF)	|
+[0-9]+[eE][+-]?[0-9]+(hf|HF)		{
+			    if (!yyextra->AMD_gpu_shader_half_float_enable)
+			        return ERROR_TOK;
+			    yylval->dreal = _mesa_strtod(yytext, NULL);
+			    return FLOAT16CONSTANT;
+			}
+
 [0-9]+\.[0-9]+([eE][+-]?[0-9]+)?[fF]?	|
 \.[0-9]+([eE][+-]?[0-9]+)?[fF]?		|
 [0-9]+\.([eE][+-]?[0-9]+)?[fF]?		|
@@ -739,6 +749,24 @@ u64vec2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyext
 u64vec3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyextra->AMD_gpu_shader_int64_enable, &glsl_type_builtin_u64vec3);
 u64vec4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyextra->AMD_gpu_shader_int64_enable, &glsl_type_builtin_u64vec4);
 
+    /* Additional words for AMD_gpu_shader_half_float */
+float16_t	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_float16_t);
+f16vec2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16vec2);
+f16vec3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16vec3);
+f16vec4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16vec4);
+f16mat2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat2);
+f16mat3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat3);
+f16mat4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat4);
+f16mat2x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat2);
+f16mat2x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat2x3);
+f16mat2x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat2x4);
+f16mat3x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat3x2);
+f16mat3x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat3);
+f16mat3x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat3x4);
+f16mat4x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat4x2);
+f16mat4x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat4x3);
+f16mat4x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, &glsl_type_builtin_f16mat4);
+
 [_a-zA-Z][_a-zA-Z0-9]*	{
 			    struct _mesa_glsl_parse_state *state = yyextra;
 			    if (state->es_shader && yyleng > 1024) {
diff --git a/src/compiler/glsl/glsl_parser.yy b/src/compiler/glsl/glsl_parser.yy
index 8c0535f4a9d20..aae60ef50bd2e 100644
--- a/src/compiler/glsl/glsl_parser.yy
+++ b/src/compiler/glsl/glsl_parser.yy
@@ -151,7 +151,7 @@ static bool match_layout_qualifier(const char *s1, const char *s2,
 %token <identifier> IDENTIFIER TYPE_IDENTIFIER NEW_IDENTIFIER
 %type <identifier> any_identifier
 %type <interface_block> instance_name_opt
-%token <real> FLOATCONSTANT
+%token <real> FLOATCONSTANT FLOAT16CONSTANT
 %token <dreal> DOUBLECONSTANT
 %token <n> INTCONSTANT UINTCONSTANT BOOLCONSTANT
 %token <n64> INT64CONSTANT UINT64CONSTANT
@@ -462,6 +462,13 @@ primary_expression:
       $$->set_location(@1);
       $$->primary_expression.uint64_constant = $1;
    }
+   | FLOAT16CONSTANT
+   {
+      linear_ctx *ctx = state->linalloc;
+      $$ = new(ctx) ast_expression(ast_float16_constant, NULL, NULL, NULL);
+      $$->set_location(@1);
+      $$->primary_expression.float16_constant = $1;
+   }
    | FLOATCONSTANT
    {
       linear_ctx *ctx = state->linalloc;
-- 
GitLab


From bed0d7e0b4504973e75eed596969c55643ca51a3 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:16:41 +1000
Subject: [PATCH 03/27] glsl: add explicit half float conversion support

---
 src/compiler/glsl/ast_function.cpp           | 46 ++++++++++++++++++++
 src/compiler/glsl/glsl_to_nir.cpp            | 10 +++++
 src/compiler/glsl/ir.cpp                     | 10 +++++
 src/compiler/glsl/ir_expression_operation.py | 10 +++++
 src/compiler/glsl/ir_validate.cpp            | 40 +++++++++++++++++
 5 files changed, 116 insertions(+)

diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index 4354485852e58..e9f5891b80ec0 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -889,6 +889,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_INT:
          result = new(ctx) ir_expression(ir_unop_i2u, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162u, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2u, src);
          break;
@@ -919,6 +922,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_UINT:
          result = new(ctx) ir_expression(ir_unop_u2i, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162i, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2i, src);
          break;
@@ -936,6 +942,31 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
          break;
       }
       break;
+   case GLSL_TYPE_FLOAT16:
+      switch (b) {
+      case GLSL_TYPE_UINT:
+         result = new(ctx) ir_expression(ir_unop_u2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_INT:
+         result = new(ctx) ir_expression(ir_unop_i2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_BOOL:
+         result = new(ctx) ir_expression(ir_unop_b2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_FLOAT:
+         result = new(ctx) ir_expression(ir_unop_f2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_DOUBLE:
+         result = new(ctx) ir_expression(ir_unop_d2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_UINT64:
+         result = new(ctx) ir_expression(ir_unop_u642f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_INT64:
+         result = new(ctx) ir_expression(ir_unop_i642f16, desired_type, src, NULL);
+         break;
+      }
+      break;
    case GLSL_TYPE_FLOAT:
       switch (b) {
       case GLSL_TYPE_UINT:
@@ -947,6 +978,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_BOOL:
          result = new(ctx) ir_expression(ir_unop_b2f, desired_type, src, NULL);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162f, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_DOUBLE:
          result = new(ctx) ir_expression(ir_unop_d2f, desired_type, src, NULL);
          break;
@@ -968,6 +1002,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_INT:
          result = new(ctx) ir_expression(ir_unop_i2b, desired_type, src, NULL);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162b, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2b, desired_type, src, NULL);
          break;
@@ -997,6 +1034,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
                                          new(ctx) ir_expression(ir_unop_b2f,
                                                                 src));
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162d, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2d, desired_type, src, NULL);
          break;
@@ -1021,6 +1061,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
                                          new(ctx) ir_expression(ir_unop_b2i64,
                                                                 src));
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162u64, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2u64, src);
          break;
@@ -1043,6 +1086,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_BOOL:
          result = new(ctx) ir_expression(ir_unop_b2i64, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162i64, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2i64, src);
          break;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 887f5f35c9620..a19bb9ed007db 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -1861,10 +1861,20 @@ nir_visitor::visit(ir_expression *ir)
    case ir_unop_b2i64:
    case ir_unop_d2f:
    case ir_unop_f2d:
+   case ir_unop_f162u:
+   case ir_unop_u2f16:
+   case ir_unop_f162i:
+   case ir_unop_i2f16:
    case ir_unop_f162f:
    case ir_unop_f2f16:
    case ir_unop_f162b:
    case ir_unop_b2f16:
+   case ir_unop_f162d:
+   case ir_unop_d2f16:
+   case ir_unop_f162u64:
+   case ir_unop_u642f16:
+   case ir_unop_f162i64:
+   case ir_unop_i642f16:
    case ir_unop_i2i:
    case ir_unop_u2u:
    case ir_unop_d2i:
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index fa7a4321b01ec..e8979da0c17ce 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -255,6 +255,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       this->type = op0->type;
       break;
 
+   case ir_unop_f162i:
    case ir_unop_f2i:
    case ir_unop_b2i:
    case ir_unop_u2i:
@@ -284,6 +285,11 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_f2f16:
    case ir_unop_f2fmp:
    case ir_unop_b2f16:
+   case ir_unop_i2f16:
+   case ir_unop_u2f16:
+   case ir_unop_d2f16:
+   case ir_unop_i642f16:
+   case ir_unop_u642f16:
       this->type = glsl_simple_type(GLSL_TYPE_FLOAT16, op0->type->vector_elements, 1);
       break;
 
@@ -321,6 +327,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       this->type = glsl_simple_type(GLSL_TYPE_BOOL, op0->type->vector_elements, 1);
       break;
 
+   case ir_unop_f162d:
    case ir_unop_f2d:
    case ir_unop_i2d:
    case ir_unop_u2d:
@@ -330,6 +337,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       break;
 
    case ir_unop_i2u:
+   case ir_unop_f162u:
    case ir_unop_f2u:
    case ir_unop_d2u:
    case ir_unop_bitcast_f2u:
@@ -341,6 +349,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_i2i64:
    case ir_unop_u2i64:
    case ir_unop_b2i64:
+   case ir_unop_f162i64:
    case ir_unop_f2i64:
    case ir_unop_d2i64:
    case ir_unop_u642i64:
@@ -349,6 +358,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
 
    case ir_unop_i2u64:
    case ir_unop_u2u64:
+   case ir_unop_f162u64:
    case ir_unop_f2u64:
    case ir_unop_d2u64:
    case ir_unop_i642u64:
diff --git a/src/compiler/glsl/ir_expression_operation.py b/src/compiler/glsl/ir_expression_operation.py
index 1d9a9aec1de50..78804a34b8279 100644
--- a/src/compiler/glsl/ir_expression_operation.py
+++ b/src/compiler/glsl/ir_expression_operation.py
@@ -490,6 +490,16 @@ ir_expression_operation = [
    operation("f2f16", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
    operation("f2fmp", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
    operation("f162f", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("u2f16", 1, source_types=(uint_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162u", 1, source_types=(float_type,), dest_type=uint_type, c_expression="{src0}"),
+   operation("i2f16", 1, source_types=(int_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162i", 1, source_types=(float_type,), dest_type=int_type, c_expression="{src0}"),
+   operation("d2f16", 1, source_types=(double_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162d", 1, source_types=(float_type,), dest_type=double_type, c_expression="{src0}"),
+   operation("u642f16", 1, source_types=(uint64_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162u64", 1, source_types=(float_type,), dest_type=uint64_type, c_expression="{src0}"),
+   operation("i642f16", 1, source_types=(int64_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162i64", 1, source_types=(float_type,), dest_type=int64_type, c_expression="{src0}"),
    # int16<->int32 conversion.
    operation("i2i", 1, source_types=(int_type,), dest_type=int_type, c_expression="{src0}"),
    operation("i2imp", 1, source_types=(int_type,), dest_type=int_type, c_expression="{src0}"),
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index e71f60c32ca97..b69b66b74143f 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -694,6 +694,46 @@ ir_validate::visit_leave(ir_expression *ir)
       assert(glsl_type_is_double(ir->operands[0]->type));
       assert(glsl_type_is_boolean(ir->type));
       break;
+   case ir_unop_u2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
+      break;
+   case ir_unop_f162u:
+      assert(glsl_type_is_uint_16_32(ir->type));
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_i2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
+      break;
+   case ir_unop_f162i:
+      assert(glsl_type_is_int_16_32(ir->type));
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_d2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(glsl_type_is_double(ir->operands[0]->type));
+      break;
+   case ir_unop_f162d:
+      assert(glsl_type_is_double(ir->type));
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_u642f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
+      break;
+   case ir_unop_f162u64:
+      assert(ir->type->base_type == GLSL_TYPE_UINT64);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_i642f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
+      break;
+   case ir_unop_f162i64:
+      assert(ir->type->base_type == GLSL_TYPE_INT64);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
 
    case ir_unop_frexp_sig:
       assert(glsl_type_is_float_32_64(ir->operands[0]->type));
-- 
GitLab


From 7fc86ee3a115112c31ef72bb38a58a629a8c1966 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:24:02 +1000
Subject: [PATCH 04/27] glsl: update assert to allow for half float support

---
 src/compiler/glsl/ast_function.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index e9f5891b80ec0..464f1ba8a1588 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -1700,7 +1700,7 @@ emit_inline_matrix_constructor(const glsl_type *type,
        * components with zero.
        */
       glsl_base_type param_base_type = first_param->type->base_type;
-      assert(glsl_type_is_float(first_param->type) || glsl_type_is_double(first_param->type));
+      assert(glsl_type_is_float_16_32_64(first_param->type));
       ir_variable *rhs_var =
          new(ctx) ir_variable(glsl_simple_type(param_base_type, 4, 1),
                               "mat_ctor_vec",
-- 
GitLab


From 3bfc19113445928a5ea96f6aca6fb0bede758bfe Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 3 Jan 2024 10:34:35 +1100
Subject: [PATCH 05/27] glsl: add glsl_type_is_float_16() helper

---
 src/compiler/glsl_types.h | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index ad1c4dbe0ef52..4567917cb7276 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -615,6 +615,12 @@ glsl_type_is_integer_16_32_64(const glsl_type *t)
    return glsl_type_is_integer_16(t) || glsl_type_is_integer_32(t) || glsl_type_is_integer_64(t);
 }
 
+static inline bool
+glsl_type_is_float_16(const glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_FLOAT16;
+}
+
 static inline bool
 glsl_type_is_float_16_32(const glsl_type *t)
 {
-- 
GitLab


From fd4d42c248120ffbc75f0a9ea05a3e7b8f873000 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:58:27 +1000
Subject: [PATCH 06/27] glsl: add implicit half float conversions

---
 src/compiler/glsl/ast_to_hir.cpp         | 9 +++++++++
 src/compiler/glsl/glsl_parser_extras.cpp | 5 +++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 0c59c2b6710c4..9a33a2ccd2d45 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -243,10 +243,18 @@ get_implicit_conversion_operation(const glsl_type *to, const glsl_type *from,
                                   struct _mesa_glsl_parse_state *state)
 {
    switch (to->base_type) {
+   case GLSL_TYPE_FLOAT16:
+      switch (from->base_type) {
+      case GLSL_TYPE_INT: return ir_unop_i2f16;
+      case GLSL_TYPE_UINT: return ir_unop_u2f16;
+      default: return (ir_expression_operation)0;
+      }
+
    case GLSL_TYPE_FLOAT:
       switch (from->base_type) {
       case GLSL_TYPE_INT: return ir_unop_i2f;
       case GLSL_TYPE_UINT: return ir_unop_u2f;
+      case GLSL_TYPE_FLOAT16: return ir_unop_f162f;
       default: return (ir_expression_operation)0;
       }
 
@@ -264,6 +272,7 @@ get_implicit_conversion_operation(const glsl_type *to, const glsl_type *from,
       switch (from->base_type) {
       case GLSL_TYPE_INT: return ir_unop_i2d;
       case GLSL_TYPE_UINT: return ir_unop_u2d;
+      case GLSL_TYPE_FLOAT16: return ir_unop_f162d;
       case GLSL_TYPE_FLOAT: return ir_unop_f2d;
       case GLSL_TYPE_INT64: return ir_unop_i642d;
       case GLSL_TYPE_UINT64: return ir_unop_u642d;
diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 918286703d0eb..8c4a08b0bf38b 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -980,7 +980,8 @@ _mesa_glsl_can_implicitly_convert(const glsl_type *from, const glsl_type *desire
       return false;
 
    /* int and uint can be converted to float. */
-   if (glsl_type_is_float(desired) && glsl_type_is_integer_32(from))
+   if (glsl_type_is_float(desired) && (glsl_type_is_integer_32(from) ||
+       glsl_type_is_float_16(from)))
       return true;
 
    /* With GLSL 4.0, ARB_gpu_shader5, or MESA_shader_integer_functions, int
@@ -999,7 +1000,7 @@ _mesa_glsl_can_implicitly_convert(const glsl_type *from, const glsl_type *desire
 
    /* Conversions from different types to double. */
    if ((!state || state->has_double()) && glsl_type_is_double(desired)) {
-      if (glsl_type_is_float(from))
+      if (glsl_type_is_float_16_32(from))
          return true;
       if (glsl_type_is_integer_32(from))
          return true;
-- 
GitLab


From 13f522396340500c66915c288bd8e1c0a33f0467 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 12:16:37 +1000
Subject: [PATCH 07/27] glsl: add ubo packing support for half floats

---
 src/compiler/glsl_types.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/compiler/glsl_types.c b/src/compiler/glsl_types.c
index 71edd9e98b5e4..cc3f264b985bf 100644
--- a/src/compiler/glsl_types.c
+++ b/src/compiler/glsl_types.c
@@ -1969,7 +1969,7 @@ glsl_varying_count(const glsl_type *t)
 unsigned
 glsl_get_std140_base_alignment(const glsl_type *t, bool row_major)
 {
-   unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
+   unsigned N = glsl_type_is_64bit(t) ? 8 : (glsl_type_is_16bit(t) ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2088,7 +2088,7 @@ glsl_get_std140_base_alignment(const glsl_type *t, bool row_major)
 unsigned
 glsl_get_std140_size(const glsl_type *t, bool row_major)
 {
-   unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
+   unsigned N = glsl_type_is_64bit(t) ? 8 : (glsl_type_is_16bit(t) ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2308,7 +2308,7 @@ unsigned
 glsl_get_std430_base_alignment(const glsl_type *t, bool row_major)
 {
 
-   unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
+   unsigned N = glsl_type_is_64bit(t) ? 8 : (glsl_type_is_16bit(t) ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2417,7 +2417,7 @@ glsl_get_std430_base_alignment(const glsl_type *t, bool row_major)
 unsigned
 glsl_get_std430_array_stride(const glsl_type *t, bool row_major)
 {
-   unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
+   unsigned N = glsl_type_is_64bit(t) ? 8 : (glsl_type_is_16bit(t) ? 2 : 4);
 
    /* Notice that the array stride of a vec3 is not 3 * N but 4 * N.
     * See OpenGL 4.30 spec, section 7.6.2.2 "Standard Uniform Block Layout"
@@ -2505,7 +2505,7 @@ glsl_get_explicit_size(const glsl_type *t, bool align_to_stride)
 unsigned
 glsl_get_std430_size(const glsl_type *t, bool row_major)
 {
-   unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
+   unsigned N = glsl_type_is_64bit(t) ? 8 : (glsl_type_is_16bit(t) ? 2 : 4);
 
    /* OpenGL 4.30 spec, section 7.6.2.2 "Standard Uniform Block Layout":
     *
-- 
GitLab


From f7eec9923636cfaa0f8a6282e40b27c8309123ed Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 13:18:25 +1000
Subject: [PATCH 08/27] glsl: skip conversion of half float back to float for
 GL queries

This is only needed for GLES where floats have been lowered to
half floats internally. We don't do that in desktop GL and we
need to skip it to return the correct enums for the
AMD_gpu_shader_half_float extension.
---
 src/mesa/main/shader_query.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index 92442682dd239..aec39fb145cc6 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -64,8 +64,11 @@ DECL_RESOURCE_FUNC(XFB, gl_transform_feedback_buffer);
 DECL_RESOURCE_FUNC(SUB, gl_subroutine_function);
 
 static GLenum
-mediump_to_highp_type(GLenum type)
+mediump_to_highp_type(struct gl_shader_program *shProg, GLenum type)
 {
+   if (!shProg->IsES)
+      return type;
+
    switch (type) {
    case GL_FLOAT16_NV:
       return GL_FLOAT;
@@ -1466,16 +1469,16 @@ _mesa_program_resource_prop(struct gl_shader_program *shProg,
       case GL_UNIFORM:
       case GL_BUFFER_VARIABLE:
          *val = RESOURCE_UNI(res)->type->gl_type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       case GL_PROGRAM_INPUT:
       case GL_PROGRAM_OUTPUT:
          *val = RESOURCE_VAR(res)->type->gl_type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       case GL_TRANSFORM_FEEDBACK_VARYING:
          *val = RESOURCE_XFV(res)->Type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       default:
          goto invalid_operation;
-- 
GitLab


From 285c03942c7a152cd92424aa1d259f5b641bda0b Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 30 Jun 2022 15:18:01 +1000
Subject: [PATCH 09/27] glsl: add some new helpers for half float builtin
 functions

These helpers will be used in the following patches.
---
 src/compiler/glsl/builtin_functions.cpp | 190 +++++++++++++++++++++++-
 1 file changed, 189 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 8a60856991f01..d70ceb2053c5d 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -459,6 +459,12 @@ gpu_shader5_or_es31_or_integer_functions(const _mesa_glsl_parse_state *state)
           state->MESA_shader_integer_functions_enable;
 }
 
+static bool
+gpu_shader_half_float(const _mesa_glsl_parse_state *state)
+{
+   return state->AMD_gpu_shader_half_float_enable;
+}
+
 static bool
 fs_interpolate_at(const _mesa_glsl_parse_state *state)
 {
@@ -1017,6 +1023,7 @@ private:
    ir_variable *out_lowp_var(const glsl_type *type, const char *name);
    ir_variable *out_highp_var(const glsl_type *type, const char *name);
    ir_variable *as_highp(ir_factory &body, ir_variable *var);
+   ir_constant *imm(float16_t f16, unsigned vector_elements=1);
    ir_constant *imm(float f, unsigned vector_elements=1);
    ir_constant *imm(bool b, unsigned vector_elements=1);
    ir_constant *imm(int i, unsigned vector_elements=1);
@@ -1736,6 +1743,30 @@ builtin_builder::create_builtins()
                 _##NAME(&glsl_type_builtin_vec4),  \
                 NULL);
 
+#define FHF(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(always_available, &glsl_type_builtin_float), \
+                _##NAME(always_available, &glsl_type_builtin_vec2),  \
+                _##NAME(always_available, &glsl_type_builtin_vec3),  \
+                _##NAME(always_available, &glsl_type_builtin_vec4),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
+                NULL);
+
+#define FHF130(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(v130, &glsl_type_builtin_float), \
+                _##NAME(v130, &glsl_type_builtin_vec2),  \
+                _##NAME(v130, &glsl_type_builtin_vec3),  \
+                _##NAME(v130, &glsl_type_builtin_vec4),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
+                NULL);
+
 #define FD(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(always_available, &glsl_type_builtin_float), \
@@ -1748,6 +1779,22 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, &glsl_type_builtin_dvec4),      \
                 NULL);
 
+#define FDHF(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(always_available, &glsl_type_builtin_float), \
+                _##NAME(always_available, &glsl_type_builtin_vec2),  \
+                _##NAME(always_available, &glsl_type_builtin_vec3),  \
+                _##NAME(always_available, &glsl_type_builtin_vec4),  \
+                _##NAME(fp64, &glsl_type_builtin_double),  \
+                _##NAME(fp64, &glsl_type_builtin_dvec2),    \
+                _##NAME(fp64, &glsl_type_builtin_dvec3),     \
+                _##NAME(fp64, &glsl_type_builtin_dvec4),      \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
+                NULL);
+
 #define FD130(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(v130, &glsl_type_builtin_float), \
@@ -1760,6 +1807,38 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, &glsl_type_builtin_dvec4),      \
                 NULL);
 
+#define FDHF130(NAME)                                                      \
+   add_function(#NAME,                                                     \
+                _##NAME(v130, &glsl_type_builtin_float),                      \
+                _##NAME(v130, &glsl_type_builtin_vec2),                       \
+                _##NAME(v130, &glsl_type_builtin_vec3),                       \
+                _##NAME(v130, &glsl_type_builtin_vec4),                       \
+                _##NAME(fp64, &glsl_type_builtin_double),                     \
+                _##NAME(fp64, &glsl_type_builtin_dvec2),                      \
+                _##NAME(fp64, &glsl_type_builtin_dvec3),                      \
+                _##NAME(fp64, &glsl_type_builtin_dvec4),                      \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),   \
+                NULL);
+
+#define FDHF130GS4(NAME)                                                   \
+   add_function(#NAME,                                                     \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_float),    \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_vec2),     \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_vec3),     \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_vec4),     \
+                _##NAME(fp64, &glsl_type_builtin_double),                  \
+                _##NAME(fp64, &glsl_type_builtin_dvec2),                      \
+                _##NAME(fp64, &glsl_type_builtin_dvec3),                      \
+                _##NAME(fp64, &glsl_type_builtin_dvec4),                      \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),   \
+                NULL);
+
 #define FD130GS4(NAME)                          \
    add_function(#NAME,                          \
                 _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_float), \
@@ -1784,6 +1863,22 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, &glsl_type_builtin_dvec4),      \
                 NULL);
 
+#define FDHFGS5(NAME)                                                      \
+   add_function(#NAME,                                                     \
+                _##NAME(gpu_shader5_es, &glsl_type_builtin_float),            \
+                _##NAME(gpu_shader5_es, &glsl_type_builtin_vec2),             \
+                _##NAME(gpu_shader5_es, &glsl_type_builtin_vec3),             \
+                _##NAME(gpu_shader5_es, &glsl_type_builtin_vec4),             \
+                _##NAME(fp64, &glsl_type_builtin_double),                     \
+                _##NAME(fp64, &glsl_type_builtin_dvec2),                      \
+                _##NAME(fp64, &glsl_type_builtin_dvec3),                      \
+                _##NAME(fp64, &glsl_type_builtin_dvec4),                      \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),   \
+                NULL);
+
 #define FI(NAME)                                \
    add_function(#NAME,                          \
                 _##NAME(&glsl_type_builtin_float), \
@@ -1816,6 +1911,30 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, &glsl_type_builtin_i64vec4),  \
                 NULL);
 
+#define FI64HF(NAME)                                \
+   add_function(#NAME,                          \
+                _##NAME(always_available, &glsl_type_builtin_float), \
+                _##NAME(always_available, &glsl_type_builtin_vec2),  \
+                _##NAME(always_available, &glsl_type_builtin_vec3),  \
+                _##NAME(always_available, &glsl_type_builtin_vec4),  \
+                _##NAME(always_available, &glsl_type_builtin_int),   \
+                _##NAME(always_available, &glsl_type_builtin_ivec2), \
+                _##NAME(always_available, &glsl_type_builtin_ivec3), \
+                _##NAME(always_available, &glsl_type_builtin_ivec4), \
+                _##NAME(fp64, &glsl_type_builtin_double), \
+                _##NAME(fp64, &glsl_type_builtin_dvec2),  \
+                _##NAME(fp64, &glsl_type_builtin_dvec3),  \
+                _##NAME(fp64, &glsl_type_builtin_dvec4),  \
+                _##NAME(int64_avail, &glsl_type_builtin_int64_t), \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec2),  \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec3),  \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec4),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
+                NULL);
+
 #define FIUD_VEC(NAME)                                            \
    add_function(#NAME,                                            \
                 _##NAME(always_available, &glsl_type_builtin_vec2),  \
@@ -1939,6 +2058,68 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec4, &glsl_type_builtin_u64vec4),     \
                 NULL);
 
+#define FIUDHF2_MIXED(NAME)                                                                           \
+   add_function(#NAME,                                                                                \
+                _##NAME(always_available, &glsl_type_builtin_float, &glsl_type_builtin_float),        \
+                _##NAME(always_available, &glsl_type_builtin_vec2,  &glsl_type_builtin_float),        \
+                _##NAME(always_available, &glsl_type_builtin_vec3,  &glsl_type_builtin_float),        \
+                _##NAME(always_available, &glsl_type_builtin_vec4,  &glsl_type_builtin_float),        \
+                                                                                                      \
+                _##NAME(always_available, &glsl_type_builtin_vec2,  &glsl_type_builtin_vec2),         \
+                _##NAME(always_available, &glsl_type_builtin_vec3,  &glsl_type_builtin_vec3),         \
+                _##NAME(always_available, &glsl_type_builtin_vec4,  &glsl_type_builtin_vec4),         \
+                                                                                                      \
+                _##NAME(always_available, &glsl_type_builtin_int,   &glsl_type_builtin_int),          \
+                _##NAME(always_available, &glsl_type_builtin_ivec2, &glsl_type_builtin_int),          \
+                _##NAME(always_available, &glsl_type_builtin_ivec3, &glsl_type_builtin_int),          \
+                _##NAME(always_available, &glsl_type_builtin_ivec4, &glsl_type_builtin_int),          \
+                                                                                                      \
+                _##NAME(always_available, &glsl_type_builtin_ivec2, &glsl_type_builtin_ivec2),        \
+                _##NAME(always_available, &glsl_type_builtin_ivec3, &glsl_type_builtin_ivec3),        \
+                _##NAME(always_available, &glsl_type_builtin_ivec4, &glsl_type_builtin_ivec4),        \
+                                                                                                      \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uint,  &glsl_type_builtin_uint),      \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uvec2, &glsl_type_builtin_uint),      \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uvec3, &glsl_type_builtin_uint),      \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uvec4, &glsl_type_builtin_uint),      \
+                                                                                                      \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uvec2, &glsl_type_builtin_uvec2),     \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uvec3, &glsl_type_builtin_uvec3),     \
+                _##NAME(v130_or_gpu_shader4, &glsl_type_builtin_uvec4, &glsl_type_builtin_uvec4),     \
+                                                                                                      \
+                _##NAME(fp64, &glsl_type_builtin_double, &glsl_type_builtin_double),                  \
+                _##NAME(fp64, &glsl_type_builtin_dvec2, &glsl_type_builtin_double),                   \
+                _##NAME(fp64, &glsl_type_builtin_dvec3, &glsl_type_builtin_double),                   \
+                _##NAME(fp64, &glsl_type_builtin_dvec4, &glsl_type_builtin_double),                   \
+                _##NAME(fp64, &glsl_type_builtin_dvec2, &glsl_type_builtin_dvec2),                    \
+                _##NAME(fp64, &glsl_type_builtin_dvec3, &glsl_type_builtin_dvec3),                    \
+                _##NAME(fp64, &glsl_type_builtin_dvec4, &glsl_type_builtin_dvec4),                    \
+                                                                                                      \
+                _##NAME(int64_avail, &glsl_type_builtin_int64_t, &glsl_type_builtin_int64_t),         \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec2, &glsl_type_builtin_int64_t),         \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec3, &glsl_type_builtin_int64_t),         \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec4, &glsl_type_builtin_int64_t),         \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec2, &glsl_type_builtin_i64vec2),         \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec3, &glsl_type_builtin_i64vec3),         \
+                _##NAME(int64_avail, &glsl_type_builtin_i64vec4, &glsl_type_builtin_i64vec4),         \
+                _##NAME(int64_avail, &glsl_type_builtin_uint64_t, &glsl_type_builtin_uint64_t),       \
+                _##NAME(int64_avail, &glsl_type_builtin_u64vec2, &glsl_type_builtin_uint64_t),        \
+                _##NAME(int64_avail, &glsl_type_builtin_u64vec3, &glsl_type_builtin_uint64_t),        \
+                _##NAME(int64_avail, &glsl_type_builtin_u64vec4, &glsl_type_builtin_uint64_t),        \
+                _##NAME(int64_avail, &glsl_type_builtin_u64vec2, &glsl_type_builtin_u64vec2),         \
+                _##NAME(int64_avail, &glsl_type_builtin_u64vec3, &glsl_type_builtin_u64vec3),         \
+                _##NAME(int64_avail, &glsl_type_builtin_u64vec4, &glsl_type_builtin_u64vec4),         \
+                                                                                                      \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_float16_t), \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2, &glsl_type_builtin_float16_t),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3, &glsl_type_builtin_float16_t),   \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4, &glsl_type_builtin_float16_t),   \
+                                                                                                            \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2, &glsl_type_builtin_f16vec2),     \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3, &glsl_type_builtin_f16vec3),     \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4, &glsl_type_builtin_f16vec4),     \
+                NULL);
+
    F(radians)
    F(degrees)
    F(sin)
@@ -5683,6 +5864,12 @@ builtin_builder::as_highp(ir_factory &body, ir_variable *var)
    return t;
 }
 
+ir_constant *
+builtin_builder::imm(float16_t f16, unsigned vector_elements)
+{
+   return new(mem_ctx) ir_constant(f16, vector_elements);
+}
+
 ir_constant *
 builtin_builder::imm(bool b, unsigned vector_elements)
 {
@@ -5719,7 +5906,8 @@ builtin_builder::imm(const glsl_type *type, const ir_constant_data &data)
    return new(mem_ctx) ir_constant(type, &data);
 }
 
-#define IMM_FP(type, val) (glsl_type_is_double(type)) ? imm(val) : imm((float)val)
+#define IMM_FP(type, val) (glsl_type_is_double(type)) ? imm(val) : \
+   (glsl_type_is_float_16(type)  ? imm((float16_t)val) : imm((float)val))
 
 ir_dereference_variable *
 builtin_builder::var_ref(ir_variable *var)
-- 
GitLab


From 4a7b46f983ede802d4b189ce3c23b64e55c6bfd7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 30 Jun 2022 15:19:28 +1000
Subject: [PATCH 10/27] glsl: add half float angle and trigonometry functions

---
 src/compiler/glsl/builtin_functions.cpp | 183 +++++++++++++-----------
 1 file changed, 101 insertions(+), 82 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index d70ceb2053c5d..acc9fe084c8ce 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1036,7 +1036,6 @@ private:
    ir_dereference_record *record_ref(ir_variable *var, const char *field);
 
    ir_expression *asin_expr(ir_variable *x, float p0, float p1);
-   void do_atan(ir_factory &body, const glsl_type *type, ir_variable *res, operand y_over_x);
 
    /**
     * Call function \param f with parameters specified as the linked
@@ -1102,21 +1101,21 @@ private:
 #define B3(X) ir_function_signature *_##X(const glsl_type *, const glsl_type *, const glsl_type *);
 #define BA1(X) ir_function_signature *_##X(builtin_available_predicate, const glsl_type *);
 #define BA2(X) ir_function_signature *_##X(builtin_available_predicate, const glsl_type *, const glsl_type *);
-   B1(radians)
-   B1(degrees)
-   B1(sin)
-   B1(cos)
-   B1(tan)
-   B1(asin)
-   B1(acos)
-   B1(atan2)
-   B1(atan)
-   B1(sinh)
-   B1(cosh)
-   B1(tanh)
-   B1(asinh)
-   B1(acosh)
-   B1(atanh)
+   BA1(radians)
+   BA1(degrees)
+   BA1(sin)
+   BA1(cos)
+   BA1(tan)
+   BA1(asin)
+   BA1(acos)
+   BA1(atan2)
+   BA1(atan)
+   BA1(sinh)
+   BA1(cosh)
+   BA1(tanh)
+   BA1(asinh)
+   BA1(acosh)
+   BA1(atanh)
    B1(pow)
    B1(exp)
    B1(log)
@@ -2120,31 +2119,39 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4, &glsl_type_builtin_f16vec4),     \
                 NULL);
 
-   F(radians)
-   F(degrees)
-   F(sin)
-   F(cos)
-   F(tan)
-   F(asin)
-   F(acos)
+   FHF(radians)
+   FHF(degrees)
+   FHF(sin)
+   FHF(cos)
+   FHF(tan)
+   FHF(asin)
+   FHF(acos)
 
    add_function("atan",
-                _atan(&glsl_type_builtin_float),
-                _atan(&glsl_type_builtin_vec2),
-                _atan(&glsl_type_builtin_vec3),
-                _atan(&glsl_type_builtin_vec4),
-                _atan2(&glsl_type_builtin_float),
-                _atan2(&glsl_type_builtin_vec2),
-                _atan2(&glsl_type_builtin_vec3),
-                _atan2(&glsl_type_builtin_vec4),
-                NULL);
-
-   F(sinh)
-   F(cosh)
-   F(tanh)
-   F(asinh)
-   F(acosh)
-   F(atanh)
+                _atan(always_available, &glsl_type_builtin_float),
+                _atan(always_available, &glsl_type_builtin_vec2),
+                _atan(always_available, &glsl_type_builtin_vec3),
+                _atan(always_available, &glsl_type_builtin_vec4),
+                _atan2(always_available, &glsl_type_builtin_float),
+                _atan2(always_available, &glsl_type_builtin_vec2),
+                _atan2(always_available, &glsl_type_builtin_vec3),
+                _atan2(always_available, &glsl_type_builtin_vec4),
+                _atan(gpu_shader_half_float, &glsl_type_builtin_float16_t),
+                _atan(gpu_shader_half_float, &glsl_type_builtin_f16vec2),
+                _atan(gpu_shader_half_float, &glsl_type_builtin_f16vec3),
+                _atan(gpu_shader_half_float, &glsl_type_builtin_f16vec4),
+                _atan2(gpu_shader_half_float, &glsl_type_builtin_float16_t),
+                _atan2(gpu_shader_half_float, &glsl_type_builtin_f16vec2),
+                _atan2(gpu_shader_half_float, &glsl_type_builtin_f16vec3),
+                _atan2(gpu_shader_half_float, &glsl_type_builtin_f16vec4),
+                NULL);
+
+   FHF130(sinh)
+   FHF130(cosh)
+   FHF130(tanh)
+   FHF130(asinh)
+   FHF130(acosh)
+   FHF130(atanh)
    F(pow)
    F(exp)
    F(log)
@@ -6031,31 +6038,34 @@ builtin_builder::_##NAME(const glsl_type *return_type,                  \
  */
 
 ir_function_signature *
-builtin_builder::_radians(const glsl_type *type)
+builtin_builder::_radians(builtin_available_predicate avail,
+                          const glsl_type *type)
 {
    ir_variable *degrees = in_var(type, "degrees");
-   MAKE_SIG(type, always_available, 1, degrees);
-   body.emit(ret(mul(degrees, imm(0.0174532925f))));
+   MAKE_SIG(type, avail, 1, degrees);
+   body.emit(ret(mul(degrees, IMM_FP(type, 0.0174532925f))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_degrees(const glsl_type *type)
+builtin_builder::_degrees(builtin_available_predicate avail,
+                          const glsl_type *type)
 {
    ir_variable *radians = in_var(type, "radians");
-   MAKE_SIG(type, always_available, 1, radians);
-   body.emit(ret(mul(radians, imm(57.29578f))));
+   MAKE_SIG(type, avail, 1, radians);
+   body.emit(ret(mul(radians, IMM_FP(type, 57.29578f))));
    return sig;
 }
 
-UNOP(sin, ir_unop_sin, always_available)
-UNOP(cos, ir_unop_cos, always_available)
+UNOPA(sin, ir_unop_sin)
+UNOPA(cos, ir_unop_cos)
 
 ir_function_signature *
-builtin_builder::_tan(const glsl_type *type)
+builtin_builder::_tan(builtin_available_predicate avail,
+                      const glsl_type *type)
 {
    ir_variable *theta = in_var(type, "theta");
-   MAKE_SIG(type, always_available, 1, theta);
+   MAKE_SIG(type, avail, 1, theta);
    body.emit(ret(div(sin(theta), cos(theta))));
    return sig;
 }
@@ -6064,14 +6074,14 @@ ir_expression *
 builtin_builder::asin_expr(ir_variable *x, float p0, float p1)
 {
    return mul(sign(x),
-              sub(imm(M_PI_2f),
-                  mul(sqrt(sub(imm(1.0f), abs(x))),
-                      add(imm(M_PI_2f),
+              sub(IMM_FP(x->type, M_PI_2f),
+                  mul(sqrt(sub(IMM_FP(x->type, 1.0f), abs(x))),
+                      add(IMM_FP(x->type, M_PI_2f),
                           mul(abs(x),
-                              add(imm(M_PI_4f - 1.0f),
+                              add(IMM_FP(x->type, (M_PI_4f - 1.0f)),
                                   mul(abs(x),
-                                      add(imm(p0),
-                                          mul(abs(x), imm(p1))))))))));
+                                      add(IMM_FP(x->type, p0),
+                                          mul(abs(x), IMM_FP(x->type, p1))))))))));
 }
 
 /**
@@ -6111,10 +6121,11 @@ builtin_builder::call(ir_function *f, ir_variable *ret, exec_list params)
 }
 
 ir_function_signature *
-builtin_builder::_asin(const glsl_type *type)
+builtin_builder::_asin(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, always_available, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(asin_expr(x, 0.086566724f, -0.03102955f)));
 
@@ -6122,45 +6133,49 @@ builtin_builder::_asin(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_acos(const glsl_type *type)
+builtin_builder::_acos(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, always_available, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(sub(imm(M_PI_2f), asin_expr(x, 0.08132463f, -0.02363318f))));
+   body.emit(ret(sub(IMM_FP(type, M_PI_2f), asin_expr(x, 0.08132463f, -0.02363318f))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_sinh(const glsl_type *type)
+builtin_builder::_sinh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* 0.5 * (e^x - e^(-x)) */
-   body.emit(ret(mul(imm(0.5f), sub(exp(x), exp(neg(x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), sub(exp(x), exp(neg(x))))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_cosh(const glsl_type *type)
+builtin_builder::_cosh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* 0.5 * (e^x + e^(-x)) */
-   body.emit(ret(mul(imm(0.5f), add(exp(x), exp(neg(x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), add(exp(x), exp(neg(x))))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_tanh(const glsl_type *type)
+builtin_builder::_tanh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* Clamp x to [-10, +10] to avoid precision problems.
     * When x > 10, e^(-x) is so small relative to e^x that it gets flushed to
@@ -6168,7 +6183,7 @@ builtin_builder::_tanh(const glsl_type *type)
     * direction when x < -10.
     */
    ir_variable *t = body.make_temp(type, "tmp");
-   body.emit(assign(t, min2(max2(x, imm(-10.0f)), imm(10.0f))));
+   body.emit(assign(t, min2(max2(x, IMM_FP(type, -10.0f)), IMM_FP(type, 10.0f))));
 
    /* (e^x - e^(-x)) / (e^x + e^(-x)) */
    body.emit(ret(div(sub(exp(t), exp(neg(t))),
@@ -6178,34 +6193,37 @@ builtin_builder::_tanh(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_asinh(const glsl_type *type)
+builtin_builder::_asinh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(mul(sign(x), log(add(abs(x), sqrt(add(mul(x, x),
-                                                       imm(1.0f))))))));
+                                                       IMM_FP(type, 1.0f))))))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_acosh(const glsl_type *type)
+builtin_builder::_acosh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(log(add(x, sqrt(sub(mul(x, x), imm(1.0f)))))));
+   body.emit(ret(log(add(x, sqrt(sub(mul(x, x), IMM_FP(type, 1.0f)))))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_atanh(const glsl_type *type)
+builtin_builder::_atanh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(mul(imm(0.5f), log(div(add(imm(1.0f), x),
-                                        sub(imm(1.0f), x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), log(div(add(IMM_FP(type, 1.0f), x),
+                                                 sub(IMM_FP(type, 1.0f), x))))));
    return sig;
 }
 /** @} */
@@ -6224,7 +6242,7 @@ UNOP(exp,         ir_unop_exp,  always_available)
 UNOP(log,         ir_unop_log,  always_available)
 UNOP(exp2,        ir_unop_exp2, always_available)
 UNOP(log2,        ir_unop_log2, always_available)
-UNOP(atan,        ir_unop_atan, always_available)
+UNOPA(atan,        ir_unop_atan)
 UNOPA(sqrt,        ir_unop_sqrt)
 UNOPA(inversesqrt, ir_unop_rsq)
 
@@ -6425,9 +6443,10 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
 }
 
 ir_function_signature *
-builtin_builder::_atan2(const glsl_type *x_type)
+builtin_builder::_atan2(builtin_available_predicate avail,
+                        const glsl_type *x_type)
 {
-   return binop(always_available, ir_binop_atan2, x_type, x_type, x_type);
+   return binop(avail, ir_binop_atan2, x_type, x_type, x_type);
 }
 
 ir_function_signature *
-- 
GitLab


From 1d91755bca767ec5cd53cd41e917ec3af63ecaff Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 1 Jul 2022 16:00:35 +1000
Subject: [PATCH 11/27] glsl: add half float exponential functions

---
 src/compiler/glsl/builtin_functions.cpp | 37 +++++++++++++------------
 1 file changed, 19 insertions(+), 18 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index acc9fe084c8ce..501f270f11ea6 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1116,11 +1116,11 @@ private:
    BA1(asinh)
    BA1(acosh)
    BA1(atanh)
-   B1(pow)
-   B1(exp)
-   B1(log)
-   B1(exp2)
-   B1(log2)
+   BA1(pow)
+   BA1(exp)
+   BA1(log)
+   BA1(exp2)
+   BA1(log2)
    BA1(sqrt)
    BA1(inversesqrt)
    BA1(abs)
@@ -2152,13 +2152,13 @@ builtin_builder::create_builtins()
    FHF130(asinh)
    FHF130(acosh)
    FHF130(atanh)
-   F(pow)
-   F(exp)
-   F(log)
-   F(exp2)
-   F(log2)
-   FD(sqrt)
-   FD(inversesqrt)
+   FHF(pow)
+   FHF(exp)
+   FHF(log)
+   FHF(exp2)
+   FHF(log2)
+   FDHF(sqrt)
+   FDHF(inversesqrt)
    FI64(abs)
    FI64(sign)
    FD(floor)
@@ -6233,15 +6233,16 @@ builtin_builder::_atanh(builtin_available_predicate avail,
  */
 
 ir_function_signature *
-builtin_builder::_pow(const glsl_type *type)
+builtin_builder::_pow(builtin_available_predicate avail,
+                      const glsl_type *type)
 {
-   return binop(always_available, ir_binop_pow, type, type, type);
+   return binop(avail, ir_binop_pow, type, type, type);
 }
 
-UNOP(exp,         ir_unop_exp,  always_available)
-UNOP(log,         ir_unop_log,  always_available)
-UNOP(exp2,        ir_unop_exp2, always_available)
-UNOP(log2,        ir_unop_log2, always_available)
+UNOPA(exp,         ir_unop_exp)
+UNOPA(log,         ir_unop_log)
+UNOPA(exp2,        ir_unop_exp2)
+UNOPA(log2,        ir_unop_log2)
 UNOPA(atan,        ir_unop_atan)
 UNOPA(sqrt,        ir_unop_sqrt)
 UNOPA(inversesqrt, ir_unop_rsq)
-- 
GitLab


From dd20b747af41649c9a05071cf3a9614e404a3dda Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 12:13:36 +1100
Subject: [PATCH 12/27] glsl: add f2f16() helper to ir_builder

---
 src/compiler/glsl/ir_builder.cpp | 6 ++++++
 src/compiler/glsl/ir_builder.h   | 2 ++
 2 files changed, 8 insertions(+)

diff --git a/src/compiler/glsl/ir_builder.cpp b/src/compiler/glsl/ir_builder.cpp
index 770ba692efde5..6894a1224b54a 100644
--- a/src/compiler/glsl/ir_builder.cpp
+++ b/src/compiler/glsl/ir_builder.cpp
@@ -553,6 +553,12 @@ interpolate_at_sample(operand a, operand b)
    return expr(ir_binop_interpolate_at_sample, a, b);
 }
 
+ir_expression *
+f2f16(operand a)
+{
+   return expr(ir_unop_f2f16, a);
+}
+
 ir_expression *
 f2d(operand a)
 {
diff --git a/src/compiler/glsl/ir_builder.h b/src/compiler/glsl/ir_builder.h
index dc7d698f4e9a7..f46d9257aed42 100644
--- a/src/compiler/glsl/ir_builder.h
+++ b/src/compiler/glsl/ir_builder.h
@@ -180,6 +180,8 @@ ir_expression *i2b(operand a);
 ir_expression *f2b(operand a);
 ir_expression *b2f(operand a);
 
+ir_expression *f2f16(operand a);
+
 ir_expression *f2d(operand a);
 ir_expression *i2d(operand a);
 ir_expression *u2d(operand a);
-- 
GitLab


From db56c7823cac9ed598de0e9559d16c54ef62d2be Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 1 Jul 2022 20:44:31 +1000
Subject: [PATCH 13/27] glsl: add half float support for common functions

---
 src/compiler/glsl/builtin_functions.cpp | 101 +++++++++++++++++++-----
 src/compiler/glsl/ir_validate.cpp       |   6 +-
 2 files changed, 86 insertions(+), 21 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 501f270f11ea6..a62c71dcbd931 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2159,14 +2159,14 @@ builtin_builder::create_builtins()
    FHF(log2)
    FDHF(sqrt)
    FDHF(inversesqrt)
-   FI64(abs)
-   FI64(sign)
-   FD(floor)
-   FD130(trunc)
-   FD130GS4(round)
-   FD130(roundEven)
-   FD(ceil)
-   FD(fract)
+   FI64HF(abs)
+   FI64HF(sign)
+   FDHF(floor)
+   FDHF130(trunc)
+   FDHF130GS4(round)
+   FDHF130(roundEven)
+   FDHF(ceil)
+   FDHF(fract)
 
    add_function("truncate",
                 _truncate(gpu_shader4, &glsl_type_builtin_float),
@@ -2186,6 +2186,15 @@ builtin_builder::create_builtins()
                 _mod(always_available, &glsl_type_builtin_vec3,  &glsl_type_builtin_vec3),
                 _mod(always_available, &glsl_type_builtin_vec4,  &glsl_type_builtin_vec4),
 
+                _mod(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_float16_t),
+                _mod(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_float16_t),
+                _mod(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_float16_t),
+                _mod(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_float16_t),
+
+                _mod(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_f16vec2),
+                _mod(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_f16vec3),
+                _mod(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_f16vec4),
+
                 _mod(fp64, &glsl_type_builtin_double, &glsl_type_builtin_double),
                 _mod(fp64, &glsl_type_builtin_dvec2,  &glsl_type_builtin_double),
                 _mod(fp64, &glsl_type_builtin_dvec3,  &glsl_type_builtin_double),
@@ -2196,11 +2205,11 @@ builtin_builder::create_builtins()
                 _mod(fp64, &glsl_type_builtin_dvec4,  &glsl_type_builtin_dvec4),
                 NULL);
 
-   FD130(modf)
+   FDHF130(modf)
 
-   FIUD2_MIXED(min)
-   FIUD2_MIXED(max)
-   FIUD2_MIXED(clamp)
+   FIUDHF2_MIXED(min)
+   FIUDHF2_MIXED(max)
+   FIUDHF2_MIXED(clamp)
 
    add_function("mix",
                 _mix_lrp(always_available, &glsl_type_builtin_float, &glsl_type_builtin_float),
@@ -2212,6 +2221,15 @@ builtin_builder::create_builtins()
                 _mix_lrp(always_available, &glsl_type_builtin_vec3,  &glsl_type_builtin_vec3),
                 _mix_lrp(always_available, &glsl_type_builtin_vec4,  &glsl_type_builtin_vec4),
 
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_float16_t),
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_float16_t),
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_float16_t),
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_float16_t),
+
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_f16vec2),
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_f16vec3),
+                _mix_lrp(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_f16vec4),
+
                 _mix_lrp(fp64, &glsl_type_builtin_double, &glsl_type_builtin_double),
                 _mix_lrp(fp64, &glsl_type_builtin_dvec2,  &glsl_type_builtin_double),
                 _mix_lrp(fp64, &glsl_type_builtin_dvec3,  &glsl_type_builtin_double),
@@ -2226,6 +2244,11 @@ builtin_builder::create_builtins()
                 _mix_sel(v130, &glsl_type_builtin_vec3,  &glsl_type_builtin_bvec3),
                 _mix_sel(v130, &glsl_type_builtin_vec4,  &glsl_type_builtin_bvec4),
 
+                _mix_sel(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_bool),
+                _mix_sel(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_bvec2),
+                _mix_sel(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_bvec3),
+                _mix_sel(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_bvec4),
+
                 _mix_sel(fp64, &glsl_type_builtin_double, &glsl_type_builtin_bool),
                 _mix_sel(fp64, &glsl_type_builtin_dvec2,  &glsl_type_builtin_bvec2),
                 _mix_sel(fp64, &glsl_type_builtin_dvec3,  &glsl_type_builtin_bvec3),
@@ -2274,6 +2297,15 @@ builtin_builder::create_builtins()
                 _step(fp64, &glsl_type_builtin_dvec2,  &glsl_type_builtin_dvec2),
                 _step(fp64, &glsl_type_builtin_dvec3,  &glsl_type_builtin_dvec3),
                 _step(fp64, &glsl_type_builtin_dvec4,  &glsl_type_builtin_dvec4),
+
+                _step(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_float16_t),
+                _step(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_f16vec2),
+                _step(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_f16vec3),
+                _step(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_f16vec4),
+
+                _step(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_f16vec2),
+                _step(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_f16vec3),
+                _step(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_f16vec4),
                 NULL);
 
    add_function("smoothstep",
@@ -2293,10 +2325,19 @@ builtin_builder::create_builtins()
                 _smoothstep(fp64, &glsl_type_builtin_dvec2,  &glsl_type_builtin_dvec2),
                 _smoothstep(fp64, &glsl_type_builtin_dvec3,  &glsl_type_builtin_dvec3),
                 _smoothstep(fp64, &glsl_type_builtin_dvec4,  &glsl_type_builtin_dvec4),
+
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_float16_t),
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_f16vec2),
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_f16vec3),
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_float16_t, &glsl_type_builtin_f16vec4),
+
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_f16vec2,  &glsl_type_builtin_f16vec2),
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_f16vec3,  &glsl_type_builtin_f16vec3),
+                _smoothstep(gpu_shader_half_float, &glsl_type_builtin_f16vec4,  &glsl_type_builtin_f16vec4),
                 NULL);
 
-   FD130(isnan)
-   FD130(isinf)
+   FDHF130(isnan)
+   FDHF130(isinf)
 
    F(floatBitsToInt)
    F(floatBitsToUint)
@@ -4917,7 +4958,7 @@ builtin_builder::create_builtins()
    IU(bitCount)
    IU(findLSB)
    IU(findMSB)
-   FDGS5(fma)
+   FDHFGS5(fma)
 
    add_function("ldexp",
                 _ldexp(&glsl_type_builtin_float, &glsl_type_builtin_int),
@@ -4928,6 +4969,10 @@ builtin_builder::create_builtins()
                 _ldexp(&glsl_type_builtin_dvec2,  &glsl_type_builtin_ivec2),
                 _ldexp(&glsl_type_builtin_dvec3,  &glsl_type_builtin_ivec3),
                 _ldexp(&glsl_type_builtin_dvec4,  &glsl_type_builtin_ivec4),
+                _ldexp(&glsl_type_builtin_float16_t, &glsl_type_builtin_int),
+                _ldexp(&glsl_type_builtin_f16vec2,  &glsl_type_builtin_ivec2),
+                _ldexp(&glsl_type_builtin_f16vec3,  &glsl_type_builtin_ivec3),
+                _ldexp(&glsl_type_builtin_f16vec4,  &glsl_type_builtin_ivec4),
                 NULL);
 
    add_function("frexp",
@@ -4939,6 +4984,10 @@ builtin_builder::create_builtins()
                 _frexp(&glsl_type_builtin_dvec2,  &glsl_type_builtin_ivec2),
                 _frexp(&glsl_type_builtin_dvec3,  &glsl_type_builtin_ivec3),
                 _frexp(&glsl_type_builtin_dvec4,  &glsl_type_builtin_ivec4),
+                _frexp(&glsl_type_builtin_float16_t, &glsl_type_builtin_int),
+                _frexp(&glsl_type_builtin_f16vec2,  &glsl_type_builtin_ivec2),
+                _frexp(&glsl_type_builtin_f16vec3,  &glsl_type_builtin_ivec3),
+                _frexp(&glsl_type_builtin_f16vec4,  &glsl_type_builtin_ivec4),
                 NULL);
    add_function("uaddCarry",
                 _uaddCarry(&glsl_type_builtin_uint),
@@ -6356,6 +6405,8 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
       /* Both are floats */
       if (glsl_type_is_double(edge_type))
          body.emit(assign(t, f2d(b2f(gequal(x, edge)))));
+      else if (glsl_type_is_float_16(edge_type))
+         body.emit(assign(t, f2f16(b2f(gequal(x, edge)))));
       else
          body.emit(assign(t, b2f(gequal(x, edge))));
    } else if (edge_type->vector_elements == 1) {
@@ -6363,6 +6414,8 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
       for (int i = 0; i < x_type->vector_elements; i++) {
          if (glsl_type_is_double(edge_type))
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
+         else if (glsl_type_is_float_16(edge_type))
+            body.emit(assign(t, f2f16(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), edge)), 1 << i));
       }
@@ -6372,6 +6425,9 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
          if (glsl_type_is_double(edge_type))
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
                              1 << i));
+         else if (glsl_type_is_float_16(edge_type))
+            body.emit(assign(t, f2f16(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
+                             1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1))),
                              1 << i));
@@ -6427,6 +6483,9 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
    ir_constant_data infinities;
    for (int i = 0; i < type->vector_elements; i++) {
       switch (type->base_type) {
+      case GLSL_TYPE_FLOAT16:
+         infinities.f16[i] = _mesa_float_to_half(INFINITY);
+         break;
       case GLSL_TYPE_FLOAT:
          infinities.f[i] = INFINITY;
          break;
@@ -7947,7 +8006,11 @@ builtin_builder::_ldexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_highp_var(x_type, "x");
    ir_variable *y = in_highp_var(exp_type, "y");
-   MAKE_SIG(x_type, glsl_type_is_double(x_type) ? fp64 : gpu_shader5_or_es31_or_integer_functions, 2, x, y);
+   builtin_available_predicate avail = glsl_type_is_double(x_type) ? fp64 :
+      (glsl_type_is_float_16(x_type) ?
+          gpu_shader_half_float : gpu_shader5_or_es31_or_integer_functions);
+
+   MAKE_SIG(x_type, avail, 2, x, y);
    sig->return_precision = GLSL_PRECISION_HIGH;
    body.emit(ret(expr(ir_binop_ldexp, x, y)));
    return sig;
@@ -7958,8 +8021,10 @@ builtin_builder::_frexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_highp_var(x_type, "x");
    ir_variable *exponent = out_var(exp_type, "exp");
-   MAKE_SIG(x_type, glsl_type_is_double(x_type) ? fp64 : gpu_shader5_or_es31_or_integer_functions,
-            2, x, exponent);
+   builtin_available_predicate avail = glsl_type_is_double(x_type) ? fp64 :
+      (glsl_type_is_float_16(x_type) ?
+          gpu_shader_half_float : gpu_shader5_or_es31_or_integer_functions);
+   MAKE_SIG(x_type, avail, 2, x, exponent);
    sig->return_precision = GLSL_PRECISION_HIGH;
 
    body.emit(assign(exponent, expr(ir_unop_frexp_exp, x)));
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index b69b66b74143f..5a1c941eca311 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -736,10 +736,10 @@ ir_validate::visit_leave(ir_expression *ir)
       break;
 
    case ir_unop_frexp_sig:
-      assert(glsl_type_is_float_32_64(ir->operands[0]->type));
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       break;
    case ir_unop_frexp_exp:
-      assert(glsl_type_is_float_32_64(ir->operands[0]->type));
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT);
       break;
    case ir_unop_subroutine_to_int:
@@ -889,7 +889,7 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_binop_ldexp:
       assert(ir->operands[0]->type == ir->type);
-      assert(glsl_type_is_float_32_64(ir->operands[0]->type));
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->operands[1]->type->base_type == GLSL_TYPE_INT);
       assert(glsl_get_components(ir->operands[0]->type) ==
              glsl_get_components(ir->operands[1]->type));
-- 
GitLab


From 5ab8865a59786aa4cd0e13ab09e7adbd022ce47a Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 13:49:06 +1000
Subject: [PATCH 14/27] glsl: add support for half float packing functions

---
 src/compiler/glsl/builtin_functions.cpp | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index a62c71dcbd931..10558530ebbea 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1165,6 +1165,8 @@ private:
    ir_function_signature *_unpackSnorm4x8(builtin_available_predicate avail);
    ir_function_signature *_packHalf2x16(builtin_available_predicate avail);
    ir_function_signature *_unpackHalf2x16(builtin_available_predicate avail);
+   ir_function_signature *_packFloat2x16(builtin_available_predicate avail);
+   ir_function_signature *_unpackFloat2x16(builtin_available_predicate avail);
    ir_function_signature *_packDouble2x32(builtin_available_predicate avail);
    ir_function_signature *_unpackDouble2x32(builtin_available_predicate avail);
    ir_function_signature *_packInt2x32(builtin_available_predicate avail);
@@ -2392,6 +2394,8 @@ builtin_builder::create_builtins()
    add_function("unpackSnorm4x8",  _unpackSnorm4x8(shader_packing_or_es31_or_gpu_shader5), NULL);
    add_function("packHalf2x16",    _packHalf2x16(shader_packing_or_es3),                   NULL);
    add_function("unpackHalf2x16",  _unpackHalf2x16(shader_packing_or_es3),                 NULL);
+   add_function("packFloat2x16",    _packFloat2x16(gpu_shader_half_float),                 NULL);
+   add_function("unpackFloat2x16",  _unpackFloat2x16(gpu_shader_half_float),               NULL);
    add_function("packDouble2x32",    _packDouble2x32(fp64),                   NULL);
    add_function("unpackDouble2x32",  _unpackDouble2x32(fp64),                 NULL);
 
@@ -6682,6 +6686,26 @@ builtin_builder::_unpackHalf2x16(builtin_available_predicate avail)
    return sig;
 }
 
+ir_function_signature *
+builtin_builder::_packFloat2x16(builtin_available_predicate avail)
+{
+   ir_variable *v = in_var(&glsl_type_builtin_f16vec2, "v");
+   MAKE_SIG(&glsl_type_builtin_uint, avail, 1, v);
+
+   ir_rvalue *value = new(mem_ctx)ir_dereference_variable(v);
+   body.emit(ret(expr(ir_unop_pack_half_2x16, new(mem_ctx) ir_expression(ir_unop_f162f, &glsl_type_builtin_vec2, value, NULL))));
+   return sig;
+}
+
+ir_function_signature *
+builtin_builder::_unpackFloat2x16(builtin_available_predicate avail)
+{
+   ir_variable *p = in_var(&glsl_type_builtin_uint, "p");
+   MAKE_SIG(&glsl_type_builtin_f16vec2, avail, 1, p);
+   body.emit(ret(f2f16(expr(ir_unop_unpack_half_2x16, p))));
+   return sig;
+}
+
 ir_function_signature *
 builtin_builder::_packDouble2x32(builtin_available_predicate avail)
 {
-- 
GitLab


From 1a04f7f37bd5e33aa5ef89f6d752e796cf640ce0 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 15:33:10 +1000
Subject: [PATCH 15/27] glsl: add half float geometric functions

---
 src/compiler/glsl/builtin_functions.cpp | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 10558530ebbea..1b94076979964 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2404,18 +2404,20 @@ builtin_builder::create_builtins()
    add_function("packUint2x32",    _packUint2x32(int64_avail),                   NULL);
    add_function("unpackUint2x32",  _unpackUint2x32(int64_avail),                 NULL);
 
-   FD(length)
-   FD(distance)
-   FD(dot)
+   FDHF(length)
+   FDHF(distance)
+   FDHF(dot)
 
    add_function("cross", _cross(always_available, &glsl_type_builtin_vec3),
-                _cross(fp64, &glsl_type_builtin_dvec3), NULL);
+                _cross(fp64, &glsl_type_builtin_dvec3),
+                _cross(gpu_shader_half_float, &glsl_type_builtin_f16vec3),
+                NULL);
 
-   FD(normalize)
+   FDHF(normalize)
    add_function("ftransform", _ftransform(), NULL);
-   FD(faceforward)
-   FD(reflect)
-   FD(refract)
+   FDHF(faceforward)
+   FDHF(reflect)
+   FDHF(refract)
    // ...
    add_function("matrixCompMult",
                 _matrixCompMult(always_available, &glsl_type_builtin_mat2),
-- 
GitLab


From 5eae3fc4883a91fe11a7662e8c282d1b2611e1d3 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 16:13:01 +1000
Subject: [PATCH 16/27] glsl: add half float matrix functions

---
 src/compiler/glsl/builtin_functions.cpp | 41 +++++++++++++++++++++++--
 1 file changed, 38 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 1b94076979964..0d6d95132ffd1 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2438,6 +2438,15 @@ builtin_builder::create_builtins()
                 _matrixCompMult(fp64, &glsl_type_builtin_dmat3x4),
                 _matrixCompMult(fp64, &glsl_type_builtin_dmat4x2),
                 _matrixCompMult(fp64, &glsl_type_builtin_dmat4x3),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat2),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat3),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat4),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat2x3),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat2x4),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat3x2),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat3x4),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat4x2),
+                _matrixCompMult(gpu_shader_half_float, &glsl_type_builtin_f16mat4x3),
                 NULL);
    add_function("outerProduct",
                 _outerProduct(v120, &glsl_type_builtin_mat2),
@@ -2458,6 +2467,15 @@ builtin_builder::create_builtins()
                 _outerProduct(fp64, &glsl_type_builtin_dmat3x4),
                 _outerProduct(fp64, &glsl_type_builtin_dmat4x2),
                 _outerProduct(fp64, &glsl_type_builtin_dmat4x3),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat2),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat3),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat4),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat2x3),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat2x4),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat3x2),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat3x4),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat4x2),
+                _outerProduct(gpu_shader_half_float, &glsl_type_builtin_f16mat4x3),
                 NULL);
    add_function("determinant",
                 _determinant_mat2(v120, &glsl_type_builtin_mat2),
@@ -2466,7 +2484,9 @@ builtin_builder::create_builtins()
                 _determinant_mat2(fp64, &glsl_type_builtin_dmat2),
                 _determinant_mat3(fp64, &glsl_type_builtin_dmat3),
                 _determinant_mat4(fp64, &glsl_type_builtin_dmat4),
-
+                _determinant_mat2(gpu_shader_half_float, &glsl_type_builtin_f16mat2),
+                _determinant_mat3(gpu_shader_half_float, &glsl_type_builtin_f16mat3),
+                _determinant_mat4(gpu_shader_half_float, &glsl_type_builtin_f16mat4),
                 NULL);
    add_function("inverse",
                 _inverse_mat2(v140_or_es3, &glsl_type_builtin_mat2),
@@ -2475,6 +2495,9 @@ builtin_builder::create_builtins()
                 _inverse_mat2(fp64, &glsl_type_builtin_dmat2),
                 _inverse_mat3(fp64, &glsl_type_builtin_dmat3),
                 _inverse_mat4(fp64, &glsl_type_builtin_dmat4),
+                _inverse_mat2(gpu_shader_half_float, &glsl_type_builtin_f16mat2),
+                _inverse_mat3(gpu_shader_half_float, &glsl_type_builtin_f16mat3),
+                _inverse_mat4(gpu_shader_half_float, &glsl_type_builtin_f16mat4),
                 NULL);
    add_function("transpose",
                 _transpose(v120, &glsl_type_builtin_mat2),
@@ -2495,6 +2518,15 @@ builtin_builder::create_builtins()
                 _transpose(fp64, &glsl_type_builtin_dmat3x4),
                 _transpose(fp64, &glsl_type_builtin_dmat4x2),
                 _transpose(fp64, &glsl_type_builtin_dmat4x3),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat2),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat3),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat4),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat2x3),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat2x4),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat3x2),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat3x4),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat4x2),
+                _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat4x3),
                 NULL);
    FIUD_VEC(lessThan)
    FIUD_VEC(lessThanEqual)
@@ -6926,6 +6958,9 @@ builtin_builder::_outerProduct(builtin_available_predicate avail, const glsl_typ
    if (glsl_type_is_double(type)) {
       r = in_var(glsl_dvec_type(type->matrix_columns), "r");
       c = in_var(glsl_dvec_type(type->vector_elements), "c");
+   } else if (glsl_type_is_float_16(type)) {
+      r = in_var(glsl_f16vec_type(type->matrix_columns), "r");
+      c = in_var(glsl_f16vec_type(type->vector_elements), "c");
    } else {
       r = in_var(glsl_vec_type(type->matrix_columns), "r");
       c = in_var(glsl_vec_type(type->vector_elements), "c");
@@ -7049,7 +7084,7 @@ builtin_builder::_determinant_mat4(builtin_available_predicate avail, const glsl
    body.emit(assign(SubFactor17, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 2)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 2)))));
    body.emit(assign(SubFactor18, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 1)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 1)))));
 
-   ir_variable *adj_0 = body.make_temp(btype == &glsl_type_builtin_float ? &glsl_type_builtin_vec4 : &glsl_type_builtin_dvec4, "adj_0");
+   ir_variable *adj_0 = body.make_temp(btype == &glsl_type_builtin_float ? &glsl_type_builtin_vec4 : btype == &glsl_type_builtin_float16_t ? &glsl_type_builtin_f16vec4 : &glsl_type_builtin_dvec4, "adj_0");
 
    body.emit(assign(adj_0,
                     add(sub(mul(matrix_elt(m, 1, 1), SubFactor00),
@@ -7206,7 +7241,7 @@ builtin_builder::_inverse_mat4(builtin_available_predicate avail, const glsl_typ
    body.emit(assign(SubFactor17, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 2)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 2)))));
    body.emit(assign(SubFactor18, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 1)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 1)))));
 
-   ir_variable *adj = body.make_temp(btype == &glsl_type_builtin_float ? &glsl_type_builtin_mat4 : &glsl_type_builtin_dmat4, "adj");
+   ir_variable *adj = body.make_temp(btype == &glsl_type_builtin_float ? &glsl_type_builtin_mat4 : (btype == &glsl_type_builtin_double ? &glsl_type_builtin_dmat4 : &glsl_type_builtin_f16mat4), "adj");
    body.emit(assign(array_ref(adj, 0),
                     add(sub(mul(matrix_elt(m, 1, 1), SubFactor00),
                             mul(matrix_elt(m, 1, 2), SubFactor01)),
-- 
GitLab


From 6dd53232082c22a908de72a687db72d2849f4c2a Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 16:29:06 +1000
Subject: [PATCH 17/27] glsl: add half float vector relational functions

---
 src/compiler/glsl/builtin_functions.cpp | 26 +++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 0d6d95132ffd1..6f1f3ad9a6814 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1936,7 +1936,7 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
                 NULL);
 
-#define FIUD_VEC(NAME)                                            \
+#define FIUDHF_VEC(NAME)                                          \
    add_function(#NAME,                                            \
                 _##NAME(always_available, &glsl_type_builtin_vec2),  \
                 _##NAME(always_available, &glsl_type_builtin_vec3),  \
@@ -1960,6 +1960,9 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec2),  \
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec3),  \
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec4),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
                 NULL);
 
 #define IU(NAME)                                \
@@ -1975,7 +1978,7 @@ builtin_builder::create_builtins()
                 _##NAME(&glsl_type_builtin_uvec4), \
                 NULL);
 
-#define FIUBD_VEC(NAME)                                           \
+#define FIUBDHF_VEC(NAME)                                           \
    add_function(#NAME,                                            \
                 _##NAME(always_available, &glsl_type_builtin_vec2),  \
                 _##NAME(always_available, &glsl_type_builtin_vec3),  \
@@ -2004,6 +2007,9 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec2),  \
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec3),  \
                 _##NAME(int64_avail, &glsl_type_builtin_u64vec4),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec2),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec3),  \
+                _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
                 NULL);
 
 #define FIUD2_MIXED(NAME)                                                                 \
@@ -2528,12 +2534,12 @@ builtin_builder::create_builtins()
                 _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat4x2),
                 _transpose(gpu_shader_half_float, &glsl_type_builtin_f16mat4x3),
                 NULL);
-   FIUD_VEC(lessThan)
-   FIUD_VEC(lessThanEqual)
-   FIUD_VEC(greaterThan)
-   FIUD_VEC(greaterThanEqual)
-   FIUBD_VEC(notEqual)
-   FIUBD_VEC(equal)
+   FIUDHF_VEC(lessThan)
+   FIUDHF_VEC(lessThanEqual)
+   FIUDHF_VEC(greaterThan)
+   FIUDHF_VEC(greaterThanEqual)
+   FIUBDHF_VEC(notEqual)
+   FIUBDHF_VEC(equal)
 
    add_function("any",
                 _any(&glsl_type_builtin_bvec2),
@@ -5685,8 +5691,8 @@ builtin_builder::create_builtins()
 
 #undef F
 #undef FI
-#undef FIUD_VEC
-#undef FIUBD_VEC
+#undef FIUDHF_VEC
+#undef FIUBDHF_VEC
 #undef FIU2_MIXED
 }
 
-- 
GitLab


From 968b05e78327088e8b5946f6ce73457842f61397 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 21:42:45 +1000
Subject: [PATCH 18/27] glsl: allow half float varyings

---
 src/compiler/glsl/ast_to_hir.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 9a33a2ccd2d45..cf43443d34998 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -4300,6 +4300,9 @@ apply_type_qualifier_to_variable(const struct ast_type_qualifier *qual,
       case GLSL_TYPE_FLOAT:
          /* Ok in all GLSL versions */
          break;
+      case GLSL_TYPE_FLOAT16:
+         if (state->AMD_gpu_shader_half_float_enable)
+         break;
       case GLSL_TYPE_UINT:
       case GLSL_TYPE_INT:
          if (state->is_version(130, 300) || state->EXT_gpu_shader4_enable)
-- 
GitLab


From 19edc51c34138d465a6eff8eb3fc74dcf6a3e3a5 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 21:44:00 +1000
Subject: [PATCH 19/27] glsl: add half float interpolation functions

---
 src/compiler/glsl/builtin_functions.cpp | 58 +++++++++++++++++--------
 1 file changed, 39 insertions(+), 19 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 6f1f3ad9a6814..6c0a28f6fde12 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -474,6 +474,11 @@ fs_interpolate_at(const _mesa_glsl_parse_state *state)
            state->OES_shader_multisample_interpolation_enable);
 }
 
+static bool
+fs_half_float_interpolate_at(const _mesa_glsl_parse_state *state)
+{
+   return fs_interpolate_at(state) && gpu_shader_half_float(state);
+}
 
 static bool
 texture_array_lod(const _mesa_glsl_parse_state *state)
@@ -1279,9 +1284,9 @@ private:
    BA1(averageRounded)
    B1(mulExtended)
    BA1(multiply32x16)
-   B1(interpolateAtCentroid)
-   B1(interpolateAtOffset)
-   B1(interpolateAtSample)
+   BA1(interpolateAtCentroid)
+   BA1(interpolateAtOffset)
+   BA1(interpolateAtSample)
 
    ir_function_signature *_atomic_counter_intrinsic(builtin_available_predicate avail,
                                                     enum ir_intrinsic_id id);
@@ -5058,22 +5063,34 @@ builtin_builder::create_builtins()
                 _mulExtended(&glsl_type_builtin_uvec4),
                 NULL);
    add_function("interpolateAtCentroid",
-                _interpolateAtCentroid(&glsl_type_builtin_float),
-                _interpolateAtCentroid(&glsl_type_builtin_vec2),
-                _interpolateAtCentroid(&glsl_type_builtin_vec3),
-                _interpolateAtCentroid(&glsl_type_builtin_vec4),
+                _interpolateAtCentroid(fs_interpolate_at, &glsl_type_builtin_float),
+                _interpolateAtCentroid(fs_interpolate_at, &glsl_type_builtin_vec2),
+                _interpolateAtCentroid(fs_interpolate_at, &glsl_type_builtin_vec3),
+                _interpolateAtCentroid(fs_interpolate_at, &glsl_type_builtin_vec4),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, &glsl_type_builtin_float16_t),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec2),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec3),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec4),
                 NULL);
    add_function("interpolateAtOffset",
-                _interpolateAtOffset(&glsl_type_builtin_float),
-                _interpolateAtOffset(&glsl_type_builtin_vec2),
-                _interpolateAtOffset(&glsl_type_builtin_vec3),
-                _interpolateAtOffset(&glsl_type_builtin_vec4),
+                _interpolateAtOffset(fs_interpolate_at, &glsl_type_builtin_float),
+                _interpolateAtOffset(fs_interpolate_at, &glsl_type_builtin_vec2),
+                _interpolateAtOffset(fs_interpolate_at, &glsl_type_builtin_vec3),
+                _interpolateAtOffset(fs_interpolate_at, &glsl_type_builtin_vec4),
+                _interpolateAtOffset(fs_half_float_interpolate_at, &glsl_type_builtin_float16_t),
+                _interpolateAtOffset(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec2),
+                _interpolateAtOffset(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec3),
+                _interpolateAtOffset(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec4),
                 NULL);
    add_function("interpolateAtSample",
-                _interpolateAtSample(&glsl_type_builtin_float),
-                _interpolateAtSample(&glsl_type_builtin_vec2),
-                _interpolateAtSample(&glsl_type_builtin_vec3),
-                _interpolateAtSample(&glsl_type_builtin_vec4),
+                _interpolateAtSample(fs_interpolate_at, &glsl_type_builtin_float),
+                _interpolateAtSample(fs_interpolate_at, &glsl_type_builtin_vec2),
+                _interpolateAtSample(fs_interpolate_at, &glsl_type_builtin_vec3),
+                _interpolateAtSample(fs_interpolate_at, &glsl_type_builtin_vec4),
+                _interpolateAtSample(fs_half_float_interpolate_at, &glsl_type_builtin_float16_t),
+                _interpolateAtSample(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec2),
+                _interpolateAtSample(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec3),
+                _interpolateAtSample(fs_half_float_interpolate_at, &glsl_type_builtin_f16vec4),
                 NULL);
 
    add_function("atomicCounter",
@@ -8225,7 +8242,8 @@ builtin_builder::_multiply32x16(builtin_available_predicate avail,
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtCentroid(const glsl_type *type)
+builtin_builder::_interpolateAtCentroid(builtin_available_predicate avail,
+                                        const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
@@ -8237,11 +8255,12 @@ builtin_builder::_interpolateAtCentroid(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtOffset(const glsl_type *type)
+builtin_builder::_interpolateAtOffset(builtin_available_predicate avail,
+                                      const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
-   ir_variable *offset = in_var(&glsl_type_builtin_vec2, "offset");
+   ir_variable *offset = in_var(glsl_type_is_float_16(type) ? &glsl_type_builtin_f16vec2 : &glsl_type_builtin_vec2, "offset");
    MAKE_SIG(type, fs_interpolate_at, 2, interpolant, offset);
 
    body.emit(ret(interpolate_at_offset(interpolant, offset)));
@@ -8250,7 +8269,8 @@ builtin_builder::_interpolateAtOffset(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtSample(const glsl_type *type)
+builtin_builder::_interpolateAtSample(builtin_available_predicate avail,
+                                      const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
-- 
GitLab


From 26586d2c02034497985272e2d3c4e374cb4bcdcf Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 27 Jul 2022 13:48:45 +1000
Subject: [PATCH 20/27] glsl: add half float derivative functions

---
 src/compiler/glsl/builtin_functions.cpp | 99 +++++++++++++++++--------
 1 file changed, 69 insertions(+), 30 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 6c0a28f6fde12..805f5d13cdde4 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -625,6 +625,18 @@ derivative_control(const _mesa_glsl_parse_state *state)
            state->ARB_derivative_control_enable);
 }
 
+static bool
+half_float_derivatives(const _mesa_glsl_parse_state *state)
+{
+   return derivatives(state) && gpu_shader_half_float(state);
+}
+
+static bool
+half_float_derivative_control(const _mesa_glsl_parse_state *state)
+{
+   return derivative_control(state) && gpu_shader_half_float(state);
+}
+
 /** True if sampler3D exists */
 static bool
 tex3d(const _mesa_glsl_parse_state *state)
@@ -1249,15 +1261,15 @@ private:
    BA2(textureQueryLod);
    BA1(textureQueryLevels);
    BA2(textureSamplesIdentical);
-   B1(dFdx);
-   B1(dFdy);
-   B1(fwidth);
-   B1(dFdxCoarse);
-   B1(dFdyCoarse);
-   B1(fwidthCoarse);
-   B1(dFdxFine);
-   B1(dFdyFine);
-   B1(fwidthFine);
+   BA1(dFdx);
+   BA1(dFdy);
+   BA1(fwidth);
+   BA1(dFdxCoarse);
+   BA1(dFdyCoarse);
+   BA1(fwidthCoarse);
+   BA1(dFdxFine);
+   BA1(dFdyFine);
+   BA1(fwidthFine);
    B1(noise1);
    B1(noise2);
    B1(noise3);
@@ -1761,6 +1773,30 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, &glsl_type_builtin_f16vec4),  \
                 NULL);
 
+#define FHF_DERIVATIVES(NAME)                                               \
+   add_function(#NAME,                                                      \
+                _##NAME(derivatives, &glsl_type_builtin_float),                \
+                _##NAME(derivatives, &glsl_type_builtin_vec2),                 \
+                _##NAME(derivatives, &glsl_type_builtin_vec3),                 \
+                _##NAME(derivatives, &glsl_type_builtin_vec4),                 \
+                _##NAME(half_float_derivatives, &glsl_type_builtin_float16_t), \
+                _##NAME(half_float_derivatives, &glsl_type_builtin_f16vec2),   \
+                _##NAME(half_float_derivatives, &glsl_type_builtin_f16vec3),   \
+                _##NAME(half_float_derivatives, &glsl_type_builtin_f16vec4),   \
+                NULL);
+
+#define FHF_DERIVATIVE_CONTROL(NAME)                                               \
+   add_function(#NAME,                                                             \
+                _##NAME(derivative_control, &glsl_type_builtin_float),                \
+                _##NAME(derivative_control, &glsl_type_builtin_vec2),                 \
+                _##NAME(derivative_control, &glsl_type_builtin_vec3),                 \
+                _##NAME(derivative_control, &glsl_type_builtin_vec4),                 \
+                _##NAME(half_float_derivative_control, &glsl_type_builtin_float16_t), \
+                _##NAME(half_float_derivative_control, &glsl_type_builtin_f16vec2),   \
+                _##NAME(half_float_derivative_control, &glsl_type_builtin_f16vec3),   \
+                _##NAME(half_float_derivative_control, &glsl_type_builtin_f16vec4),   \
+                NULL);
+
 #define FHF130(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(v130, &glsl_type_builtin_float), \
@@ -4987,15 +5023,15 @@ builtin_builder::create_builtins()
                 _texture(ir_txd, v130_desktop_and_clamp, &glsl_type_builtin_float, &glsl_type_builtin_sampler2DArrayShadow, &glsl_type_builtin_vec4, TEX_OFFSET|TEX_CLAMP),
                 NULL);
 
-   F(dFdx)
-   F(dFdy)
-   F(fwidth)
-   F(dFdxCoarse)
-   F(dFdyCoarse)
-   F(fwidthCoarse)
-   F(dFdxFine)
-   F(dFdyFine)
-   F(fwidthFine)
+   FHF_DERIVATIVES(dFdx)
+   FHF_DERIVATIVES(dFdy)
+   FHF_DERIVATIVES(fwidth)
+   FHF_DERIVATIVE_CONTROL(dFdxCoarse)
+   FHF_DERIVATIVE_CONTROL(dFdyCoarse)
+   FHF_DERIVATIVE_CONTROL(fwidthCoarse)
+   FHF_DERIVATIVE_CONTROL(dFdxFine)
+   FHF_DERIVATIVE_CONTROL(dFdyFine)
+   FHF_DERIVATIVE_CONTROL(fwidthFine)
    F(noise1)
    F(noise2)
    F(noise3)
@@ -7875,18 +7911,19 @@ builtin_builder::_textureSamplesIdentical(builtin_available_predicate avail,
    return sig;
 }
 
-UNOP(dFdx, ir_unop_dFdx, derivatives)
-UNOP(dFdxCoarse, ir_unop_dFdx_coarse, derivative_control)
-UNOP(dFdxFine, ir_unop_dFdx_fine, derivative_control)
-UNOP(dFdy, ir_unop_dFdy, derivatives)
-UNOP(dFdyCoarse, ir_unop_dFdy_coarse, derivative_control)
-UNOP(dFdyFine, ir_unop_dFdy_fine, derivative_control)
+UNOPA(dFdx, ir_unop_dFdx)
+UNOPA(dFdxCoarse, ir_unop_dFdx_coarse)
+UNOPA(dFdxFine, ir_unop_dFdx_fine)
+UNOPA(dFdy, ir_unop_dFdy)
+UNOPA(dFdyCoarse, ir_unop_dFdy_coarse)
+UNOPA(dFdyFine, ir_unop_dFdy_fine)
 
 ir_function_signature *
-builtin_builder::_fwidth(const glsl_type *type)
+builtin_builder::_fwidth(builtin_available_predicate avail,
+                         const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivatives, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx, p)), abs(expr(ir_unop_dFdy, p)))));
 
@@ -7894,10 +7931,11 @@ builtin_builder::_fwidth(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_fwidthCoarse(const glsl_type *type)
+builtin_builder::_fwidthCoarse(builtin_available_predicate avail,
+                               const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivative_control, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx_coarse, p)),
                      abs(expr(ir_unop_dFdy_coarse, p)))));
@@ -7906,10 +7944,11 @@ builtin_builder::_fwidthCoarse(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_fwidthFine(const glsl_type *type)
+builtin_builder::_fwidthFine(builtin_available_predicate avail,
+                             const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivative_control, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx_fine, p)),
                      abs(expr(ir_unop_dFdy_fine, p)))));
-- 
GitLab


From 411ca97c815c913689a256e4b5b1200b282d2456 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 27 Jul 2022 14:27:04 +1000
Subject: [PATCH 21/27] glsl: add half float AMD_shader_trinary_minmax
 functions

---
 src/compiler/glsl/builtin_functions.cpp | 114 ++++++++++++++----------
 1 file changed, 69 insertions(+), 45 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 805f5d13cdde4..ea74fd4212049 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -724,6 +724,12 @@ shader_trinary_minmax(const _mesa_glsl_parse_state *state)
    return state->AMD_shader_trinary_minmax_enable;
 }
 
+static bool
+shader_trinary_minmax_half_float(const _mesa_glsl_parse_state *state)
+{
+   return shader_trinary_minmax(state) && gpu_shader_half_float(state);
+}
+
 static bool
 shader_image_load_store(const _mesa_glsl_parse_state *state)
 {
@@ -1326,9 +1332,9 @@ private:
                                       builtin_available_predicate avail,
                                       const glsl_type *type);
 
-   B1(min3)
-   B1(max3)
-   B1(mid3)
+   BA1(min3)
+   BA1(max3)
+   BA1(mid3)
 
    ir_function_signature *_image_prototype(const glsl_type *image_type,
                                            unsigned num_arguments,
@@ -5336,54 +5342,69 @@ builtin_builder::create_builtins()
                 NULL);
 
    add_function("min3",
-                _min3(&glsl_type_builtin_float),
-                _min3(&glsl_type_builtin_vec2),
-                _min3(&glsl_type_builtin_vec3),
-                _min3(&glsl_type_builtin_vec4),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_float),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_vec2),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_vec3),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_vec4),
+
+                _min3(shader_trinary_minmax_half_float, &glsl_type_builtin_float16_t),
+                _min3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec2),
+                _min3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec3),
+                _min3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec4),
 
-                _min3(&glsl_type_builtin_int),
-                _min3(&glsl_type_builtin_ivec2),
-                _min3(&glsl_type_builtin_ivec3),
-                _min3(&glsl_type_builtin_ivec4),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_int),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_ivec2),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_ivec3),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_ivec4),
 
-                _min3(&glsl_type_builtin_uint),
-                _min3(&glsl_type_builtin_uvec2),
-                _min3(&glsl_type_builtin_uvec3),
-                _min3(&glsl_type_builtin_uvec4),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_uint),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_uvec2),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_uvec3),
+                _min3(shader_trinary_minmax, &glsl_type_builtin_uvec4),
                 NULL);
 
    add_function("max3",
-                _max3(&glsl_type_builtin_float),
-                _max3(&glsl_type_builtin_vec2),
-                _max3(&glsl_type_builtin_vec3),
-                _max3(&glsl_type_builtin_vec4),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_float),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_vec2),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_vec3),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_vec4),
 
-                _max3(&glsl_type_builtin_int),
-                _max3(&glsl_type_builtin_ivec2),
-                _max3(&glsl_type_builtin_ivec3),
-                _max3(&glsl_type_builtin_ivec4),
+                _max3(shader_trinary_minmax_half_float, &glsl_type_builtin_float16_t),
+                _max3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec2),
+                _max3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec3),
+                _max3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec4),
 
-                _max3(&glsl_type_builtin_uint),
-                _max3(&glsl_type_builtin_uvec2),
-                _max3(&glsl_type_builtin_uvec3),
-                _max3(&glsl_type_builtin_uvec4),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_int),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_ivec2),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_ivec3),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_ivec4),
+
+                _max3(shader_trinary_minmax, &glsl_type_builtin_uint),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_uvec2),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_uvec3),
+                _max3(shader_trinary_minmax, &glsl_type_builtin_uvec4),
                 NULL);
 
    add_function("mid3",
-                _mid3(&glsl_type_builtin_float),
-                _mid3(&glsl_type_builtin_vec2),
-                _mid3(&glsl_type_builtin_vec3),
-                _mid3(&glsl_type_builtin_vec4),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_float),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_vec2),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_vec3),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_vec4),
+
+                _mid3(shader_trinary_minmax_half_float, &glsl_type_builtin_float16_t),
+                _mid3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec2),
+                _mid3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec3),
+                _mid3(shader_trinary_minmax_half_float, &glsl_type_builtin_f16vec4),
 
-                _mid3(&glsl_type_builtin_int),
-                _mid3(&glsl_type_builtin_ivec2),
-                _mid3(&glsl_type_builtin_ivec3),
-                _mid3(&glsl_type_builtin_ivec4),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_int),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_ivec2),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_ivec3),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_ivec4),
 
-                _mid3(&glsl_type_builtin_uint),
-                _mid3(&glsl_type_builtin_uvec2),
-                _mid3(&glsl_type_builtin_uvec3),
-                _mid3(&glsl_type_builtin_uvec4),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_uint),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_uvec2),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_uvec3),
+                _mid3(shader_trinary_minmax, &glsl_type_builtin_uvec4),
                 NULL);
 
    add_image_functions(true);
@@ -8488,12 +8509,13 @@ builtin_builder::_atomic_op3(const char *intrinsic,
 }
 
 ir_function_signature *
-builtin_builder::_min3(const glsl_type *type)
+builtin_builder::_min3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *min3 = min2(x, min2(y,z));
    body.emit(ret(min3));
@@ -8502,12 +8524,13 @@ builtin_builder::_min3(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_max3(const glsl_type *type)
+builtin_builder::_max3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *max3 = max2(x, max2(y,z));
    body.emit(ret(max3));
@@ -8516,12 +8539,13 @@ builtin_builder::_max3(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_mid3(const glsl_type *type)
+builtin_builder::_mid3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *mid3 = max2(min2(x, y), max2(min2(x, z), min2(y, z)));
    body.emit(ret(mid3));
-- 
GitLab


From e218f631a759ea7b43729cf31710ed89397c27be Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 29 Jul 2022 10:46:34 +1000
Subject: [PATCH 22/27] glsl: store xfb stride in "machine units"

Previously we stored it as number of 32bit components and converted
it from that when needed. This worked okish for 64bit component
handing, however it will not work for half float support.

So here we switch to the number of 8bit "machine units" as the spec
refers to them.
---
 src/compiler/glsl/gl_nir_link_varyings.c | 20 ++++++++++----------
 src/compiler/glsl/gl_nir_link_xfb.c      |  4 ++--
 src/mesa/main/shader_query.cpp           |  2 +-
 src/mesa/main/shader_types.h             |  6 +++---
 src/mesa/state_tracker/st_program.c      |  2 +-
 5 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_link_varyings.c b/src/compiler/glsl/gl_nir_link_varyings.c
index 83ad722e04143..4735a5505ad99 100644
--- a/src/compiler/glsl/gl_nir_link_varyings.c
+++ b/src/compiler/glsl/gl_nir_link_varyings.c
@@ -1722,7 +1722,7 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
    unsigned size = xfb_decl->size;
    /* Handle gl_SkipComponents. */
    if (xfb_decl->skip_components) {
-      info->Buffers[buffer].Stride += xfb_decl->skip_components;
+      info->Buffers[buffer].Stride += xfb_decl->skip_components * 4;
       size = xfb_decl->skip_components;
       goto store_varying;
    }
@@ -1735,7 +1735,7 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
    if (has_xfb_qualifiers) {
       xfb_offset = xfb_decl->offset / 4;
    } else {
-      xfb_offset = info->Buffers[buffer].Stride;
+      xfb_offset = info->Buffers[buffer].Stride / 4;
    }
    info->Varyings[info->NumVarying].Offset = xfb_offset * 4;
 
@@ -1885,28 +1885,28 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
 
    if (explicit_stride && explicit_stride[buffer]) {
       if (_mesa_gl_datatype_is_64bit(xfb_decl->type) &&
-          info->Buffers[buffer].Stride % 2) {
+          info->Buffers[buffer].Stride % 8) {
          linker_error(prog, "invalid qualifier xfb_stride=%d must be a "
                       "multiple of 8 as its applied to a type that is or "
                       "contains a double.",
-                      info->Buffers[buffer].Stride * 4);
+                      info->Buffers[buffer].Stride);
          return false;
       }
 
-      if (xfb_offset > info->Buffers[buffer].Stride) {
+      if ((xfb_offset * 4) > info->Buffers[buffer].Stride) {
          linker_error(prog, "xfb_offset (%d) overflows xfb_stride (%d) for "
                       "buffer (%d)", xfb_offset * 4,
-                      info->Buffers[buffer].Stride * 4, buffer);
+                      info->Buffers[buffer].Stride, buffer);
          return false;
       }
    } else {
       if (max_member_alignment && has_xfb_qualifiers) {
          max_member_alignment[buffer] = MAX2(max_member_alignment[buffer],
-                                             _mesa_gl_datatype_is_64bit(xfb_decl->type) ? 2 : 1);
-         info->Buffers[buffer].Stride = ALIGN(xfb_offset,
+                                             _mesa_gl_datatype_is_64bit(xfb_decl->type) ? 8 : 4);
+         info->Buffers[buffer].Stride = ALIGN((xfb_offset * 4),
                                               max_member_alignment[buffer]);
       } else {
-         info->Buffers[buffer].Stride = xfb_offset;
+         info->Buffers[buffer].Stride = xfb_offset * 4;
       }
    }
 
@@ -2112,7 +2112,7 @@ store_tfeedback_info(const struct gl_constants *consts,
             if (prog->TransformFeedback.BufferStride[j]) {
                explicit_stride[j] = true;
                xfb_prog->sh.LinkedTransformFeedback->Buffers[j].Stride =
-                  prog->TransformFeedback.BufferStride[j] / 4;
+                  prog->TransformFeedback.BufferStride[j];
             }
          }
       }
diff --git a/src/compiler/glsl/gl_nir_link_xfb.c b/src/compiler/glsl/gl_nir_link_xfb.c
index a6bb161f2e19b..1a26b576cb560 100644
--- a/src/compiler/glsl/gl_nir_link_xfb.c
+++ b/src/compiler/glsl/gl_nir_link_xfb.c
@@ -184,7 +184,7 @@ gl_nir_link_assign_xfb_resources(const struct gl_constants *consts,
 
    for (unsigned buf = 0; buf < MAX_FEEDBACK_BUFFERS; buf++) {
       if (xfb_info->buffers[buf].stride > 0) {
-         linked_xfb->Buffers[buf].Stride = xfb_info->buffers[buf].stride / 4;
+         linked_xfb->Buffers[buf].Stride = xfb_info->buffers[buf].stride;
          linked_xfb->Buffers[buf].NumVaryings = xfb_info->buffers[buf].varying_count;
          buffers |= 1 << buf;
       }
@@ -207,7 +207,7 @@ gl_to_nir_xfb_info(struct gl_transform_feedback_info *info, void *mem_ctx)
    xfb->output_count = info->NumOutputs;
 
    for (unsigned i = 0; i < MAX_FEEDBACK_BUFFERS; i++) {
-      xfb->buffers[i].stride = info->Buffers[i].Stride * 4;
+      xfb->buffers[i].stride = info->Buffers[i].Stride;
       xfb->buffers[i].varying_count = info->Buffers[i].NumVaryings;
       xfb->buffer_to_stream[i] = info->Buffers[i].Stream;
    }
diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index aec39fb145cc6..5b6622eab590e 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -1675,7 +1675,7 @@ _mesa_program_resource_prop(struct gl_shader_program *shProg,
       return 1;
    case GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE:
       VALIDATE_TYPE(GL_TRANSFORM_FEEDBACK_BUFFER);
-      *val = RESOURCE_XFB(res)->Stride * 4;
+      *val = RESOURCE_XFB(res)->Stride;
       return 1;
 
    default:
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index ab7bac8f275c3..8310fa2401a27 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -756,9 +756,9 @@ struct gl_transform_feedback_buffer
    uint32_t NumVaryings;
 
    /**
-    * Total number of components stored in each buffer.  This may be used by
-    * hardware back-ends to determine the correct stride when interleaving
-    * multiple transform feedback outputs in the same buffer.
+    * Total number of basic machine units stored in each buffer.  This may
+    * be used by hardware back-ends to determine the correct stride when
+    * interleaving multiple transform feedback outputs in the same buffer.
     */
    uint32_t Stride;
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index ab3ed71acb204..0caff6fd5711c 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -481,7 +481,7 @@ st_translate_stream_output_info(struct gl_program *prog)
    }
 
    for (unsigned i = 0; i < PIPE_MAX_SO_BUFFERS; i++) {
-      so_info->stride[i] = info->Buffers[i].Stride;
+      so_info->stride[i] = info->Buffers[i].Stride / 4;
    }
    so_info->num_outputs = info->NumOutputs;
 }
-- 
GitLab


From 027c6ad4119a14ac7fbb5cc5a7fd466f29ba14a9 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 14:07:11 +1000
Subject: [PATCH 23/27] compiler/types: Add a contains_32bit helper

---
 src/compiler/glsl_types.c | 16 ++++++++++++++++
 src/compiler/glsl_types.h |  1 +
 2 files changed, 17 insertions(+)

diff --git a/src/compiler/glsl_types.c b/src/compiler/glsl_types.c
index cc3f264b985bf..287e0e68a0a6a 100644
--- a/src/compiler/glsl_types.c
+++ b/src/compiler/glsl_types.c
@@ -239,6 +239,22 @@ glsl_contains_double(const glsl_type *t)
    }
 }
 
+bool
+glsl_type_contains_32bit(const glsl_type *t)
+{
+   if (glsl_type_is_array(t)) {
+      return glsl_type_contains_32bit(t->fields.array);
+   } else if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
+      for (unsigned int i = 0; i < t->length; i++) {
+         if (glsl_type_contains_32bit(t->fields.structure[i].type))
+            return true;
+      }
+      return false;
+   } else {
+      return glsl_type_is_32bit(t);
+   }
+}
+
 bool
 glsl_type_contains_64bit(const glsl_type *t)
 {
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 4567917cb7276..04eee99cc35eb 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -829,6 +829,7 @@ unsigned glsl_atomic_size(const glsl_type *type);
  * Type A contains type B if A is B or A is a composite type (struct,
  * interface, array) that has an element that contains B.
  */
+bool glsl_type_contains_32bit(const glsl_type *t);
 bool glsl_type_contains_64bit(const glsl_type *t);
 bool glsl_type_contains_image(const glsl_type *t);
 bool glsl_contains_atomic(const glsl_type *t);
-- 
GitLab


From 5827e723e593ebf413ed344803f03548c7791c51 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:30:29 +1000
Subject: [PATCH 24/27] compiler/types: Add a xfb_component_size() helper

This also includes support for returning the size of half float
components.
---
 src/compiler/glsl_types.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 04eee99cc35eb..70ef0362afbb4 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -840,6 +840,14 @@ bool glsl_contains_sampler(const glsl_type *t);
 bool glsl_contains_array(const glsl_type *t);
 bool glsl_contains_subroutine(const glsl_type *t);
 
+/**
+ * Return the xfb component size in bytes for this type.
+ */
+static inline unsigned glsl_xfb_component_size(const glsl_type *t)
+{
+   return glsl_contains_double(t) ? 8 : (glsl_type_contains_32bit(t) ? 4 : 2);
+}
+
 static inline enum glsl_sampler_dim
 glsl_get_sampler_dim(const glsl_type *t)
 {
-- 
GitLab


From 500f8d6991ecc461e411bc32892d9675d3f9da06 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:33:29 +1000
Subject: [PATCH 25/27] glsl: make use of xfb_component_size() helper

---
 src/compiler/glsl/ast_to_hir.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index cf43443d34998..3fbc98cf1c064 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -2952,7 +2952,7 @@ validate_xfb_offset_qualifier(YYLTYPE *loc,
           * we apply the component size rules at the member level.
           */
          if (xfb_offset == -1)
-            component_size = glsl_contains_double(member_t) ? 8 : 4;
+            component_size = glsl_xfb_component_size(member_t);
 
          int xfb_offset = t_without_array->fields.structure[i].offset;
          validate_xfb_offset_qualifier(loc, state, xfb_offset, member_t,
@@ -3902,7 +3902,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
 
    if (qual->flags.q.explicit_xfb_offset) {
       unsigned qual_xfb_offset;
-      unsigned component_size = glsl_contains_double(var->type) ? 8 : 4;
+      unsigned component_size = glsl_xfb_component_size(var->type);
 
       if (process_qualifier_constant(state, loc, "xfb_offset",
                                      qual->offset, &qual_xfb_offset) &&
@@ -8418,7 +8418,7 @@ ast_interface_block::hir(exec_list *instructions,
                           GLSL_MATRIX_LAYOUT_ROW_MAJOR,
                           this->block_name);
 
-   unsigned component_size = glsl_contains_double(block_type) ? 8 : 4;
+   unsigned component_size = glsl_xfb_component_size(block_type);
    int xfb_offset =
       layout.flags.q.explicit_xfb_offset ? (int) qual_xfb_offset : -1;
    validate_xfb_offset_qualifier(&loc, state, xfb_offset, block_type,
-- 
GitLab


From bf320d3b2a817fe605fdf87e7fb1c6f0ef0fdaea Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 15:35:09 +1100
Subject: [PATCH 26/27] gallium: add PIPE_CAP_FP16 for
 AMD_gpu_shader_half_float

---
 docs/gallium/screen.rst                | 1 +
 src/gallium/auxiliary/util/u_screen.c  | 1 +
 src/gallium/include/pipe/p_defines.h   | 1 +
 src/mesa/state_tracker/st_extensions.c | 1 +
 4 files changed, 4 insertions(+)

diff --git a/docs/gallium/screen.rst b/docs/gallium/screen.rst
index 5c668aec4f1f8..c4f0881f341a6 100644
--- a/docs/gallium/screen.rst
+++ b/docs/gallium/screen.rst
@@ -426,6 +426,7 @@ The integer capabilities:
 * ``PIPE_CAP_LEGACY_MATH_RULES``: Whether NIR shaders support the
   ``shader_info.use_legacy_math_rules`` flag (see documentation there), and
   TGSI shaders support the corresponding ``TGSI_PROPERTY_LEGACY_MATH_RULES``.
+* ``PIPE_CAP_FP16``: Whether 16-bit float operations are supported.
 * ``PIPE_CAP_DOUBLES``: Whether double precision floating-point operations
   are supported.
 * ``PIPE_CAP_INT64``: Whether 64-bit integer operations are supported.
diff --git a/src/gallium/auxiliary/util/u_screen.c b/src/gallium/auxiliary/util/u_screen.c
index df9a7c0ab7ff6..78cc8d9bb3f7b 100644
--- a/src/gallium/auxiliary/util/u_screen.c
+++ b/src/gallium/auxiliary/util/u_screen.c
@@ -332,6 +332,7 @@ u_pipe_screen_get_param_defaults(struct pipe_screen *pscreen,
    case PIPE_CAP_FBFETCH_ZS:
    case PIPE_CAP_BLEND_EQUATION_ADVANCED:
    case PIPE_CAP_LEGACY_MATH_RULES:
+   case PIPE_CAP_FP16:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
    case PIPE_CAP_TGSI_TEX_TXF_LZ:
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 11328563a542a..204b91fafbdb2 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -808,6 +808,7 @@ enum pipe_cap
    PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS,
    PIPE_CAP_FBFETCH,
    PIPE_CAP_LEGACY_MATH_RULES,
+   PIPE_CAP_FP16,
    PIPE_CAP_DOUBLES,
    PIPE_CAP_INT64,
    PIPE_CAP_TGSI_TEX_TXF_LZ,
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index b0521fafcf773..a27bd7bc635f2 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -846,6 +846,7 @@ void st_init_extensions(struct pipe_screen *screen,
 
       { o(AMD_depth_clamp_separate),         PIPE_CAP_DEPTH_CLIP_DISABLE_SEPARATE      },
       { o(AMD_framebuffer_multisample_advanced), PIPE_CAP_FRAMEBUFFER_MSAA_CONSTRAINTS },
+      { o(AMD_gpu_shader_half_float),        PIPE_CAP_FP16                             },
       { o(AMD_performance_monitor),          PIPE_CAP_PERFORMANCE_MONITOR              },
       { o(AMD_pinned_memory),                PIPE_CAP_RESOURCE_FROM_USER_MEMORY        },
       { o(ATI_meminfo),                      PIPE_CAP_QUERY_MEMORY_INFO                },
-- 
GitLab


From cb5430faf75af858b54f011d6001cc9000d24e2e Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 15:51:34 +1100
Subject: [PATCH 27/27] radeonsi: enable AMD_gpu_shader_half_float

---
 src/gallium/drivers/radeonsi/si_get.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 111f3adc26b3c..6edd0fff67c23 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -162,6 +162,9 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_HAS_CONST_BW:
       return 1;
 
+   case PIPE_CAP_FP16:
+      return sscreen->info.gfx_level >= GFX8;
+
    case PIPE_CAP_TEXTURE_TRANSFER_MODES:
       return PIPE_TEXTURE_TRANSFER_BLIT;
 
-- 
GitLab

