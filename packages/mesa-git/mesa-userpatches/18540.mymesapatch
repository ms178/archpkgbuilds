From 65ee2bfb9dc74406b63b1e1a73fa74d71118f1ed Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 24 Jun 2022 15:24:20 +1000
Subject: [PATCH 01/29] glsl: add basic params for AMD_gpu_shader_half_float
 extension

This sets us the basic infrastructure to required to add an
extension.
---
 src/compiler/glsl/glsl_parser_extras.cpp | 1 +
 src/compiler/glsl/glsl_parser_extras.h   | 2 ++
 src/mesa/main/consts_exts.h              | 1 +
 src/mesa/main/extensions_table.h         | 1 +
 4 files changed, 5 insertions(+)

diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 59729c2dd797..40bdbde684ec 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -737,6 +737,7 @@ static const _mesa_glsl_extension _mesa_glsl_supported_extensions[] = {
    /* All other extensions go here, sorted alphabetically.
     */
    EXT(AMD_conservative_depth),
+   EXT(AMD_gpu_shader_half_float),
    EXT(AMD_gpu_shader_int64),
    EXT(AMD_shader_stencil_export),
    EXT(AMD_shader_trinary_minmax),
diff --git a/src/compiler/glsl/glsl_parser_extras.h b/src/compiler/glsl/glsl_parser_extras.h
index a8fb7a5572c0..8947d2aaf299 100644
--- a/src/compiler/glsl/glsl_parser_extras.h
+++ b/src/compiler/glsl/glsl_parser_extras.h
@@ -818,6 +818,8 @@ struct _mesa_glsl_parse_state {
     */
    bool AMD_conservative_depth_enable;
    bool AMD_conservative_depth_warn;
+   bool AMD_gpu_shader_half_float_enable;
+   bool AMD_gpu_shader_half_float_warn;
    bool AMD_gpu_shader_int64_enable;
    bool AMD_gpu_shader_int64_warn;
    bool AMD_shader_stencil_export_enable;
diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index ea008792d44f..060809b7ef9b 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -226,6 +226,7 @@ struct gl_extensions
    GLboolean AMD_compressed_ATC_texture;
    GLboolean AMD_framebuffer_multisample_advanced;
    GLboolean AMD_depth_clamp_separate;
+   GLboolean AMD_gpu_shader_half_float;
    GLboolean AMD_performance_monitor;
    GLboolean AMD_pinned_memory;
    GLboolean AMD_seamless_cubemap_per_texture;
diff --git a/src/mesa/main/extensions_table.h b/src/mesa/main/extensions_table.h
index 307b5d3bc1db..942c610e0b73 100644
--- a/src/mesa/main/extensions_table.h
+++ b/src/mesa/main/extensions_table.h
@@ -13,6 +13,7 @@ EXT(AMD_conservative_depth                  , ARB_conservative_depth
 EXT(AMD_depth_clamp_separate                , AMD_depth_clamp_separate               , GLL, GLC,  x ,  x , 2009)
 EXT(AMD_draw_buffers_blend                  , ARB_draw_buffers_blend                 , GLL, GLC,  x ,  x , 2009)
 EXT(AMD_framebuffer_multisample_advanced    , AMD_framebuffer_multisample_advanced   , GLL, GLC,  x , ES2, 2018)
+EXT(AMD_gpu_shader_half_float               , AMD_gpu_shader_half_float              ,  40,  40,  x ,  x , 2016)
 EXT(AMD_gpu_shader_int64                    , ARB_gpu_shader_int64                   ,  x , GLC,  x ,  x , 2015)
 EXT(AMD_multi_draw_indirect                 , ARB_draw_indirect                      , GLL, GLC,  x ,  x , 2011)
 EXT(AMD_performance_monitor                 , AMD_performance_monitor                , GLL, GLC,  x , ES2, 2007)
-- 
GitLab


From 86e0216c2261b7c07020960b3d6cbae1086c3d81 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 24 Jun 2022 16:26:11 +1000
Subject: [PATCH 02/29] glsl: add half float support to the parser

---
 src/compiler/glsl/ast.h          |  2 ++
 src/compiler/glsl/ast_to_hir.cpp |  5 +++++
 src/compiler/glsl/glsl_lexer.ll  | 28 ++++++++++++++++++++++++++++
 src/compiler/glsl/glsl_parser.yy |  9 ++++++++-
 4 files changed, 43 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl/ast.h b/src/compiler/glsl/ast.h
index 0a5b94bb1cee..5831528d035d 100644
--- a/src/compiler/glsl/ast.h
+++ b/src/compiler/glsl/ast.h
@@ -197,6 +197,7 @@ enum ast_operators {
    ast_identifier,
    ast_int_constant,
    ast_uint_constant,
+   ast_float16_constant,
    ast_float_constant,
    ast_bool_constant,
    ast_double_constant,
@@ -258,6 +259,7 @@ public:
    union {
       const char *identifier;
       int int_constant;
+      float float16_constant;
       float float_constant;
       unsigned uint_constant;
       int bool_constant;
diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index a61fe1d56d93..ee91f8e73e67 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -2110,6 +2110,10 @@ ast_expression::do_hir(exec_list *instructions,
       result = new(ctx) ir_constant(this->primary_expression.uint_constant);
       break;
 
+   case ast_float16_constant:
+      result = new(ctx) ir_constant(float16_t(this->primary_expression.float16_constant));
+      break;
+
    case ast_float_constant:
       result = new(ctx) ir_constant(this->primary_expression.float_constant);
       break;
@@ -2253,6 +2257,7 @@ ast_expression::has_sequence_subexpression() const
    case ast_identifier:
    case ast_int_constant:
    case ast_uint_constant:
+   case ast_float16_constant:
    case ast_float_constant:
    case ast_bool_constant:
    case ast_double_constant:
diff --git a/src/compiler/glsl/glsl_lexer.ll b/src/compiler/glsl/glsl_lexer.ll
index ad109b3d112d..4c33d756970c 100644
--- a/src/compiler/glsl/glsl_lexer.ll
+++ b/src/compiler/glsl/glsl_lexer.ll
@@ -609,6 +609,16 @@ layout		{
 			    return LITERAL_INTEGER(8);
 			}
 
+[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?(hf|HF)	|
+\.[0-9]+([eE][+-]?[0-9]+)?(hf|HF)	|
+[0-9]+\.([eE][+-]?[0-9]+)?(hf|HF)	|
+[0-9]+[eE][+-]?[0-9]+(hf|HF)		{
+			    if (!yyextra->AMD_gpu_shader_half_float_enable)
+			        return ERROR_TOK;
+			    yylval->dreal = _mesa_strtod(yytext, NULL);
+			    return FLOAT16CONSTANT;
+			}
+
 [0-9]+\.[0-9]+([eE][+-]?[0-9]+)?[fF]?	|
 \.[0-9]+([eE][+-]?[0-9]+)?[fF]?		|
 [0-9]+\.([eE][+-]?[0-9]+)?[fF]?		|
@@ -739,6 +749,24 @@ u64vec2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyext
 u64vec3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyextra->AMD_gpu_shader_int64_enable, glsl_type::u64vec3_type);
 u64vec4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->ARB_gpu_shader_int64_enable || yyextra->AMD_gpu_shader_int64_enable, glsl_type::u64vec4_type);
 
+    /* Additional words for AMD_gpu_shader_half_float */
+float16_t	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::float16_t_type);
+f16vec2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16vec2_type);
+f16vec3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16vec3_type);
+f16vec4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16vec4_type);
+f16mat2		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2_type);
+f16mat3		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3_type);
+f16mat4		TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4_type);
+f16mat2x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2_type);
+f16mat2x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2x3_type);
+f16mat2x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat2x4_type);
+f16mat3x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3x2_type);
+f16mat3x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3_type);
+f16mat3x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat3x4_type);
+f16mat4x2	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4x2_type);
+f16mat4x3	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4x3_type);
+f16mat4x4	TYPE_WITH_ALT(0, 0, 0, 0, yyextra->AMD_gpu_shader_half_float_enable, glsl_type::f16mat4_type);
+
 [_a-zA-Z][_a-zA-Z0-9]*	{
 			    struct _mesa_glsl_parse_state *state = yyextra;
 			    if (state->es_shader && yyleng > 1024) {
diff --git a/src/compiler/glsl/glsl_parser.yy b/src/compiler/glsl/glsl_parser.yy
index f887cdb247bf..1ea8af2b9f72 100644
--- a/src/compiler/glsl/glsl_parser.yy
+++ b/src/compiler/glsl/glsl_parser.yy
@@ -150,7 +150,7 @@ static bool match_layout_qualifier(const char *s1, const char *s2,
 %token <identifier> IDENTIFIER TYPE_IDENTIFIER NEW_IDENTIFIER
 %type <identifier> any_identifier
 %type <interface_block> instance_name_opt
-%token <real> FLOATCONSTANT
+%token <real> FLOATCONSTANT FLOAT16CONSTANT
 %token <dreal> DOUBLECONSTANT
 %token <n> INTCONSTANT UINTCONSTANT BOOLCONSTANT
 %token <n64> INT64CONSTANT UINT64CONSTANT
@@ -461,6 +461,13 @@ primary_expression:
       $$->set_location(@1);
       $$->primary_expression.uint64_constant = $1;
    }
+   | FLOAT16CONSTANT
+   {
+      void *ctx = state->linalloc;
+      $$ = new(ctx) ast_expression(ast_float16_constant, NULL, NULL, NULL);
+      $$->set_location(@1);
+      $$->primary_expression.float16_constant = $1;
+   }
    | FLOATCONSTANT
    {
       void *ctx = state->linalloc;
-- 
GitLab


From 5bbe03bf316c457e819f967250182595b45d805a Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:16:41 +1000
Subject: [PATCH 03/29] glsl: add explicit half float conversion support

---
 src/compiler/glsl/ast_function.cpp           | 46 ++++++++++++++++++++
 src/compiler/glsl/glsl_to_nir.cpp            | 10 +++++
 src/compiler/glsl/ir.cpp                     | 10 +++++
 src/compiler/glsl/ir_expression_operation.py | 10 +++++
 src/compiler/glsl/ir_validate.cpp            | 40 +++++++++++++++++
 5 files changed, 116 insertions(+)

diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index f1c9ee99d850..c6fa63c385b8 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -887,6 +887,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_INT:
          result = new(ctx) ir_expression(ir_unop_i2u, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162u, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2u, src);
          break;
@@ -917,6 +920,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_UINT:
          result = new(ctx) ir_expression(ir_unop_u2i, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162i, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2i, src);
          break;
@@ -934,6 +940,31 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
          break;
       }
       break;
+   case GLSL_TYPE_FLOAT16:
+      switch (b) {
+      case GLSL_TYPE_UINT:
+         result = new(ctx) ir_expression(ir_unop_u2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_INT:
+         result = new(ctx) ir_expression(ir_unop_i2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_BOOL:
+         result = new(ctx) ir_expression(ir_unop_b2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_FLOAT:
+         result = new(ctx) ir_expression(ir_unop_f2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_DOUBLE:
+         result = new(ctx) ir_expression(ir_unop_d2f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_UINT64:
+         result = new(ctx) ir_expression(ir_unop_u642f16, desired_type, src, NULL);
+         break;
+      case GLSL_TYPE_INT64:
+         result = new(ctx) ir_expression(ir_unop_i642f16, desired_type, src, NULL);
+         break;
+      }
+      break;
    case GLSL_TYPE_FLOAT:
       switch (b) {
       case GLSL_TYPE_UINT:
@@ -945,6 +976,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_BOOL:
          result = new(ctx) ir_expression(ir_unop_b2f, desired_type, src, NULL);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162f, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_DOUBLE:
          result = new(ctx) ir_expression(ir_unop_d2f, desired_type, src, NULL);
          break;
@@ -966,6 +1000,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_INT:
          result = new(ctx) ir_expression(ir_unop_i2b, desired_type, src, NULL);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162b, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2b, desired_type, src, NULL);
          break;
@@ -995,6 +1032,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
                                          new(ctx) ir_expression(ir_unop_b2f,
                                                                 src));
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162d, desired_type, src, NULL);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2d, desired_type, src, NULL);
          break;
@@ -1019,6 +1059,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
                                          new(ctx) ir_expression(ir_unop_b2i64,
                                                                 src));
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162u64, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2u64, src);
          break;
@@ -1041,6 +1084,9 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
       case GLSL_TYPE_BOOL:
          result = new(ctx) ir_expression(ir_unop_b2i64, src);
          break;
+      case GLSL_TYPE_FLOAT16:
+         result = new(ctx) ir_expression(ir_unop_f162i64, src);
+         break;
       case GLSL_TYPE_FLOAT:
          result = new(ctx) ir_expression(ir_unop_f2i64, src);
          break;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 4eb4fdf081db..a0bf4121e298 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -1998,10 +1998,20 @@ nir_visitor::visit(ir_expression *ir)
    case ir_unop_b2i64:
    case ir_unop_d2f:
    case ir_unop_f2d:
+   case ir_unop_f162u:
+   case ir_unop_u2f16:
+   case ir_unop_f162i:
+   case ir_unop_i2f16:
    case ir_unop_f162f:
    case ir_unop_f2f16:
    case ir_unop_f162b:
    case ir_unop_b2f16:
+   case ir_unop_f162d:
+   case ir_unop_d2f16:
+   case ir_unop_f162u64:
+   case ir_unop_u642f16:
+   case ir_unop_f162i64:
+   case ir_unop_i642f16:
    case ir_unop_i2i:
    case ir_unop_u2u:
    case ir_unop_d2i:
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index 08b62ddfafbe..7e7eb16eadbf 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -255,6 +255,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       this->type = op0->type;
       break;
 
+   case ir_unop_f162i:
    case ir_unop_f2i:
    case ir_unop_b2i:
    case ir_unop_u2i:
@@ -286,6 +287,11 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_f2f16:
    case ir_unop_f2fmp:
    case ir_unop_b2f16:
+   case ir_unop_i2f16:
+   case ir_unop_u2f16:
+   case ir_unop_d2f16:
+   case ir_unop_i642f16:
+   case ir_unop_u642f16:
       this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT16,
 					   op0->type->vector_elements, 1);
       break;
@@ -331,6 +337,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
 					   op0->type->vector_elements, 1);
       break;
 
+   case ir_unop_f162d:
    case ir_unop_f2d:
    case ir_unop_i2d:
    case ir_unop_u2d:
@@ -341,6 +348,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       break;
 
    case ir_unop_i2u:
+   case ir_unop_f162u:
    case ir_unop_f2u:
    case ir_unop_d2u:
    case ir_unop_bitcast_f2u:
@@ -353,6 +361,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_i2i64:
    case ir_unop_u2i64:
    case ir_unop_b2i64:
+   case ir_unop_f162i64:
    case ir_unop_f2i64:
    case ir_unop_d2i64:
    case ir_unop_u642i64:
@@ -362,6 +371,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
 
    case ir_unop_i2u64:
    case ir_unop_u2u64:
+   case ir_unop_f162u64:
    case ir_unop_f2u64:
    case ir_unop_d2u64:
    case ir_unop_i642u64:
diff --git a/src/compiler/glsl/ir_expression_operation.py b/src/compiler/glsl/ir_expression_operation.py
index c9f9831c346d..36a5bba10e8f 100644
--- a/src/compiler/glsl/ir_expression_operation.py
+++ b/src/compiler/glsl/ir_expression_operation.py
@@ -461,6 +461,16 @@ ir_expression_operation = [
    operation("f2f16", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
    operation("f2fmp", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
    operation("f162f", 1, source_types=(float_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("u2f16", 1, source_types=(uint_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162u", 1, source_types=(float_type,), dest_type=uint_type, c_expression="{src0}"),
+   operation("i2f16", 1, source_types=(int_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162i", 1, source_types=(float_type,), dest_type=int_type, c_expression="{src0}"),
+   operation("d2f16", 1, source_types=(double_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162d", 1, source_types=(float_type,), dest_type=double_type, c_expression="{src0}"),
+   operation("u642f16", 1, source_types=(uint64_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162u64", 1, source_types=(float_type,), dest_type=uint64_type, c_expression="{src0}"),
+   operation("i642f16", 1, source_types=(int64_type,), dest_type=float_type, c_expression="{src0}"),
+   operation("f162i64", 1, source_types=(float_type,), dest_type=int64_type, c_expression="{src0}"),
    # int16<->int32 conversion.
    operation("i2i", 1, source_types=(int_type,), dest_type=int_type, c_expression="{src0}"),
    operation("i2imp", 1, source_types=(int_type,), dest_type=int_type, c_expression="{src0}"),
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index 2e120db4ea82..5177d4fe8480 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -693,6 +693,46 @@ ir_validate::visit_leave(ir_expression *ir)
       assert(ir->operands[0]->type->is_double());
       assert(ir->type->is_boolean());
       break;
+   case ir_unop_u2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->is_uint_16_32());
+      break;
+   case ir_unop_f162u:
+      assert(ir->type->is_uint_16_32());
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_i2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->is_int_16_32());
+      break;
+   case ir_unop_f162i:
+      assert(ir->type->is_int_16_32());
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_d2f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->is_double());
+      break;
+   case ir_unop_f162d:
+      assert(ir->type->is_double());
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_u642f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
+      break;
+   case ir_unop_f162u64:
+      assert(ir->type->base_type == GLSL_TYPE_UINT64);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
+   case ir_unop_i642f16:
+      assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
+      break;
+   case ir_unop_f162i64:
+      assert(ir->type->base_type == GLSL_TYPE_INT64);
+      assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
+      break;
 
    case ir_unop_frexp_sig:
       assert(ir->operands[0]->type->is_float_32_64());
-- 
GitLab


From 04156831422c67799d9ce7e66f1a7367d01416f1 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:24:02 +1000
Subject: [PATCH 04/29] glsl: update assert to allow for half float support

---
 src/compiler/glsl/ast_function.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index c6fa63c385b8..70c8159636fe 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -1709,7 +1709,7 @@ emit_inline_matrix_constructor(const glsl_type *type,
        * components with zero.
        */
       glsl_base_type param_base_type = first_param->type->base_type;
-      assert(first_param->type->is_float() || first_param->type->is_double());
+      assert(first_param->type->is_float_16_32_64());
       ir_variable *rhs_var =
          new(ctx) ir_variable(glsl_type::get_instance(param_base_type, 4, 1),
                               "mat_ctor_vec",
-- 
GitLab


From 8c75e0bdee63a3eb6bee85a0ca615d78250a3e40 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 27 Jun 2022 15:58:27 +1000
Subject: [PATCH 05/29] glsl: add implicit half float conversions

---
 src/compiler/glsl/ast_to_hir.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index ee91f8e73e67..560da4a5c3a7 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -242,10 +242,18 @@ get_implicit_conversion_operation(const glsl_type *to, const glsl_type *from,
                                   struct _mesa_glsl_parse_state *state)
 {
    switch (to->base_type) {
+   case GLSL_TYPE_FLOAT16:
+      switch (from->base_type) {
+      case GLSL_TYPE_INT: return ir_unop_i2f16;
+      case GLSL_TYPE_UINT: return ir_unop_u2f16;
+      default: return (ir_expression_operation)0;
+      }
+
    case GLSL_TYPE_FLOAT:
       switch (from->base_type) {
       case GLSL_TYPE_INT: return ir_unop_i2f;
       case GLSL_TYPE_UINT: return ir_unop_u2f;
+      case GLSL_TYPE_FLOAT16: return ir_unop_f162f;
       default: return (ir_expression_operation)0;
       }
 
@@ -263,6 +271,7 @@ get_implicit_conversion_operation(const glsl_type *to, const glsl_type *from,
       switch (from->base_type) {
       case GLSL_TYPE_INT: return ir_unop_i2d;
       case GLSL_TYPE_UINT: return ir_unop_u2d;
+      case GLSL_TYPE_FLOAT16: return ir_unop_f162d;
       case GLSL_TYPE_FLOAT: return ir_unop_f2d;
       case GLSL_TYPE_INT64: return ir_unop_i642d;
       case GLSL_TYPE_UINT64: return ir_unop_u642d;
-- 
GitLab


From 044ba76e132fb316e1aa81f3777a07959d6e3f5a Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 12:15:50 +1000
Subject: [PATCH 06/29] glsl: add implicit conversion support for half floats

---
 src/compiler/glsl_types.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 63190eec9dd0..d7ccaf5ea7ec 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -1964,7 +1964,8 @@ glsl_type::can_implicitly_convert_to(const glsl_type *desired,
       return false;
 
    /* int and uint can be converted to float. */
-   if (desired->is_float() && this->is_integer_32())
+   if (desired->is_float() &&
+       (this->is_integer_32() || this->base_type == GLSL_TYPE_FLOAT16))
       return true;
 
    /* With GLSL 4.0, ARB_gpu_shader5, or MESA_shader_integer_functions, int
@@ -1983,7 +1984,7 @@ glsl_type::can_implicitly_convert_to(const glsl_type *desired,
 
    /* Conversions from different types to double. */
    if ((!state || state->has_double()) && desired->is_double()) {
-      if (this->is_float())
+      if (this->is_float_16_32())
          return true;
       if (this->is_integer_32())
          return true;
-- 
GitLab


From df1175b5ca1a62f80c5bd52a4b0d50c2dff7bff7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 12:16:37 +1000
Subject: [PATCH 07/29] glsl: add ubo packing support for half floats

---
 src/compiler/glsl_types.cpp | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index d7ccaf5ea7ec..46d99438d764 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -1996,7 +1996,7 @@ glsl_type::can_implicitly_convert_to(const glsl_type *desired,
 unsigned
 glsl_type::std140_base_alignment(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2114,7 +2114,7 @@ glsl_type::std140_base_alignment(bool row_major) const
 unsigned
 glsl_type::std140_size(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2330,7 +2330,7 @@ unsigned
 glsl_type::std430_base_alignment(bool row_major) const
 {
 
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* (1) If the member is a scalar consuming <N> basic machine units, the
     *     base alignment is <N>.
@@ -2439,7 +2439,7 @@ glsl_type::std430_base_alignment(bool row_major) const
 unsigned
 glsl_type::std430_array_stride(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* Notice that the array stride of a vec3 is not 3 * N but 4 * N.
     * See OpenGL 4.30 spec, section 7.6.2.2 "Standard Uniform Block Layout"
@@ -2527,7 +2527,7 @@ glsl_type::explicit_size(bool align_to_stride) const
 unsigned
 glsl_type::std430_size(bool row_major) const
 {
-   unsigned N = is_64bit() ? 8 : 4;
+   unsigned N = is_64bit() ? 8 : (is_16bit() ? 2 : 4);
 
    /* OpenGL 4.30 spec, section 7.6.2.2 "Standard Uniform Block Layout":
     *
-- 
GitLab


From d6983f7f5c2ac73f1b44ceaeabba9d005a980714 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 28 Jun 2022 13:18:25 +1000
Subject: [PATCH 08/29] glsl: skip conversion of half float back to float for
 GL queries

This is only needed for GLES where floats have been lowered to
half floats internally. We don't do that in desktop GL and we
need to skip it to return the correct enums for the
AMD_gpu_shader_half_float extension.
---
 src/mesa/main/shader_query.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index 88de7139825c..37173696074b 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -64,8 +64,11 @@ DECL_RESOURCE_FUNC(XFB, gl_transform_feedback_buffer);
 DECL_RESOURCE_FUNC(SUB, gl_subroutine_function);
 
 static GLenum
-mediump_to_highp_type(GLenum type)
+mediump_to_highp_type(struct gl_shader_program *shProg, GLenum type)
 {
+   if (!shProg->IsES)
+      return type;
+
    switch (type) {
    case GL_FLOAT16_NV:
       return GL_FLOAT;
@@ -1466,16 +1469,16 @@ _mesa_program_resource_prop(struct gl_shader_program *shProg,
       case GL_UNIFORM:
       case GL_BUFFER_VARIABLE:
          *val = RESOURCE_UNI(res)->type->gl_type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       case GL_PROGRAM_INPUT:
       case GL_PROGRAM_OUTPUT:
          *val = RESOURCE_VAR(res)->type->gl_type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       case GL_TRANSFORM_FEEDBACK_VARYING:
          *val = RESOURCE_XFV(res)->Type;
-         *val = mediump_to_highp_type(*val);
+         *val = mediump_to_highp_type(shProg, *val);
          return 1;
       default:
          goto invalid_operation;
-- 
GitLab


From 00b8fdcb5556b9f2bb9f30fb5b17c019497f87ab Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 30 Jun 2022 15:18:01 +1000
Subject: [PATCH 09/29] glsl: add some new helpers for half float builtin
 functions

These helpers will be used in the following patches.
---
 src/compiler/glsl/builtin_functions.cpp | 190 +++++++++++++++++++++++-
 1 file changed, 189 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 84618dd45216..c6fea622f6ab 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -456,6 +456,12 @@ gpu_shader5_or_es31_or_integer_functions(const _mesa_glsl_parse_state *state)
           state->MESA_shader_integer_functions_enable;
 }
 
+static bool
+gpu_shader_half_float(const _mesa_glsl_parse_state *state)
+{
+   return state->AMD_gpu_shader_half_float_enable;
+}
+
 static bool
 fs_interpolate_at(const _mesa_glsl_parse_state *state)
 {
@@ -1015,6 +1021,7 @@ private:
     */
    ir_variable *in_var(const glsl_type *type, const char *name);
    ir_variable *out_var(const glsl_type *type, const char *name);
+   ir_constant *imm(float16_t f16, unsigned vector_elements=1);
    ir_constant *imm(float f, unsigned vector_elements=1);
    ir_constant *imm(bool b, unsigned vector_elements=1);
    ir_constant *imm(int i, unsigned vector_elements=1);
@@ -1730,6 +1737,30 @@ builtin_builder::create_builtins()
                 _##NAME(glsl_type::vec4_type),  \
                 NULL);
 
+#define FHF(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(always_available, glsl_type::float_type), \
+                _##NAME(always_available, glsl_type::vec2_type),  \
+                _##NAME(always_available, glsl_type::vec3_type),  \
+                _##NAME(always_available, glsl_type::vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
+#define FHF130(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(v130, glsl_type::float_type), \
+                _##NAME(v130, glsl_type::vec2_type),  \
+                _##NAME(v130, glsl_type::vec3_type),  \
+                _##NAME(v130, glsl_type::vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
 #define FD(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(always_available, glsl_type::float_type), \
@@ -1742,6 +1773,22 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, glsl_type::dvec4_type),      \
                 NULL);
 
+#define FDHF(NAME)                                 \
+   add_function(#NAME,                          \
+                _##NAME(always_available, glsl_type::float_type), \
+                _##NAME(always_available, glsl_type::vec2_type),  \
+                _##NAME(always_available, glsl_type::vec3_type),  \
+                _##NAME(always_available, glsl_type::vec4_type),  \
+                _##NAME(fp64, glsl_type::double_type),  \
+                _##NAME(fp64, glsl_type::dvec2_type),    \
+                _##NAME(fp64, glsl_type::dvec3_type),     \
+                _##NAME(fp64, glsl_type::dvec4_type),      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
 #define FD130(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(v130, glsl_type::float_type), \
@@ -1754,6 +1801,38 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, glsl_type::dvec4_type),      \
                 NULL);
 
+#define FDHF130(NAME)                                                      \
+   add_function(#NAME,                                                     \
+                _##NAME(v130, glsl_type::float_type),                      \
+                _##NAME(v130, glsl_type::vec2_type),                       \
+                _##NAME(v130, glsl_type::vec3_type),                       \
+                _##NAME(v130, glsl_type::vec4_type),                       \
+                _##NAME(fp64, glsl_type::double_type),                     \
+                _##NAME(fp64, glsl_type::dvec2_type),                      \
+                _##NAME(fp64, glsl_type::dvec3_type),                      \
+                _##NAME(fp64, glsl_type::dvec4_type),                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),   \
+                NULL);
+
+#define FDHF130GS4(NAME)                                                   \
+   add_function(#NAME,                                                     \
+                _##NAME(v130_or_gpu_shader4, glsl_type::float_type),       \
+                _##NAME(v130_or_gpu_shader4, glsl_type::vec2_type),        \
+                _##NAME(v130_or_gpu_shader4, glsl_type::vec3_type),        \
+                _##NAME(v130_or_gpu_shader4, glsl_type::vec4_type),        \
+                _##NAME(fp64, glsl_type::double_type),                     \
+                _##NAME(fp64, glsl_type::dvec2_type),                      \
+                _##NAME(fp64, glsl_type::dvec3_type),                      \
+                _##NAME(fp64, glsl_type::dvec4_type),                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),   \
+                NULL);
+
 #define FD130GS4(NAME)                          \
    add_function(#NAME,                          \
                 _##NAME(v130_or_gpu_shader4, glsl_type::float_type), \
@@ -1778,6 +1857,22 @@ builtin_builder::create_builtins()
                 _##NAME(fp64, glsl_type::dvec4_type),      \
                 NULL);
 
+#define FDHFGS5(NAME)                                                      \
+   add_function(#NAME,                                                     \
+                _##NAME(gpu_shader5_es, glsl_type::float_type),            \
+                _##NAME(gpu_shader5_es, glsl_type::vec2_type),             \
+                _##NAME(gpu_shader5_es, glsl_type::vec3_type),             \
+                _##NAME(gpu_shader5_es, glsl_type::vec4_type),             \
+                _##NAME(fp64, glsl_type::double_type),                     \
+                _##NAME(fp64, glsl_type::dvec2_type),                      \
+                _##NAME(fp64, glsl_type::dvec3_type),                      \
+                _##NAME(fp64, glsl_type::dvec4_type),                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),   \
+                NULL);
+
 #define FI(NAME)                                \
    add_function(#NAME,                          \
                 _##NAME(glsl_type::float_type), \
@@ -1810,6 +1905,30 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::i64vec4_type),  \
                 NULL);
 
+#define FI64HF(NAME)                                \
+   add_function(#NAME,                          \
+                _##NAME(always_available, glsl_type::float_type), \
+                _##NAME(always_available, glsl_type::vec2_type),  \
+                _##NAME(always_available, glsl_type::vec3_type),  \
+                _##NAME(always_available, glsl_type::vec4_type),  \
+                _##NAME(always_available, glsl_type::int_type),   \
+                _##NAME(always_available, glsl_type::ivec2_type), \
+                _##NAME(always_available, glsl_type::ivec3_type), \
+                _##NAME(always_available, glsl_type::ivec4_type), \
+                _##NAME(fp64, glsl_type::double_type), \
+                _##NAME(fp64, glsl_type::dvec2_type),  \
+                _##NAME(fp64, glsl_type::dvec3_type),  \
+                _##NAME(fp64, glsl_type::dvec4_type),  \
+                _##NAME(int64_avail, glsl_type::int64_t_type), \
+                _##NAME(int64_avail, glsl_type::i64vec2_type),  \
+                _##NAME(int64_avail, glsl_type::i64vec3_type),  \
+                _##NAME(int64_avail, glsl_type::i64vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
+                NULL);
+
 #define FIUD_VEC(NAME)                                            \
    add_function(#NAME,                                            \
                 _##NAME(always_available, glsl_type::vec2_type),  \
@@ -1933,6 +2052,68 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::u64vec4_type, glsl_type::u64vec4_type),     \
                 NULL);
 
+#define FIUDHF2_MIXED(NAME)                                                                           \
+   add_function(#NAME,                                                                                \
+                _##NAME(always_available, glsl_type::float_type, glsl_type::float_type),              \
+                _##NAME(always_available, glsl_type::vec2_type,  glsl_type::float_type),              \
+                _##NAME(always_available, glsl_type::vec3_type,  glsl_type::float_type),              \
+                _##NAME(always_available, glsl_type::vec4_type,  glsl_type::float_type),              \
+                                                                                                      \
+                _##NAME(always_available, glsl_type::vec2_type,  glsl_type::vec2_type),               \
+                _##NAME(always_available, glsl_type::vec3_type,  glsl_type::vec3_type),               \
+                _##NAME(always_available, glsl_type::vec4_type,  glsl_type::vec4_type),               \
+                                                                                                      \
+                _##NAME(always_available, glsl_type::int_type,   glsl_type::int_type),                \
+                _##NAME(always_available, glsl_type::ivec2_type, glsl_type::int_type),                \
+                _##NAME(always_available, glsl_type::ivec3_type, glsl_type::int_type),                \
+                _##NAME(always_available, glsl_type::ivec4_type, glsl_type::int_type),                \
+                                                                                                      \
+                _##NAME(always_available, glsl_type::ivec2_type, glsl_type::ivec2_type),              \
+                _##NAME(always_available, glsl_type::ivec3_type, glsl_type::ivec3_type),              \
+                _##NAME(always_available, glsl_type::ivec4_type, glsl_type::ivec4_type),              \
+                                                                                                      \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uint_type,  glsl_type::uint_type),            \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec2_type, glsl_type::uint_type),            \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec3_type, glsl_type::uint_type),            \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec4_type, glsl_type::uint_type),            \
+                                                                                                      \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec2_type, glsl_type::uvec2_type),           \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec3_type, glsl_type::uvec3_type),           \
+                _##NAME(v130_or_gpu_shader4, glsl_type::uvec4_type, glsl_type::uvec4_type),           \
+                                                                                                      \
+                _##NAME(fp64, glsl_type::double_type, glsl_type::double_type),                        \
+                _##NAME(fp64, glsl_type::dvec2_type, glsl_type::double_type),                         \
+                _##NAME(fp64, glsl_type::dvec3_type, glsl_type::double_type),                         \
+                _##NAME(fp64, glsl_type::dvec4_type, glsl_type::double_type),                         \
+                _##NAME(fp64, glsl_type::dvec2_type, glsl_type::dvec2_type),                          \
+                _##NAME(fp64, glsl_type::dvec3_type, glsl_type::dvec3_type),                          \
+                _##NAME(fp64, glsl_type::dvec4_type, glsl_type::dvec4_type),                          \
+                                                                                                      \
+                _##NAME(int64_avail, glsl_type::int64_t_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec2_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec3_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec4_type, glsl_type::int64_t_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec2_type, glsl_type::i64vec2_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec3_type, glsl_type::i64vec3_type),               \
+                _##NAME(int64_avail, glsl_type::i64vec4_type, glsl_type::i64vec4_type),               \
+                _##NAME(int64_avail, glsl_type::uint64_t_type, glsl_type::uint64_t_type),             \
+                _##NAME(int64_avail, glsl_type::u64vec2_type, glsl_type::uint64_t_type),              \
+                _##NAME(int64_avail, glsl_type::u64vec3_type, glsl_type::uint64_t_type),              \
+                _##NAME(int64_avail, glsl_type::u64vec4_type, glsl_type::uint64_t_type),              \
+                _##NAME(int64_avail, glsl_type::u64vec2_type, glsl_type::u64vec2_type),               \
+                _##NAME(int64_avail, glsl_type::u64vec3_type, glsl_type::u64vec3_type),               \
+                _##NAME(int64_avail, glsl_type::u64vec4_type, glsl_type::u64vec4_type),               \
+                                                                                                      \
+                _##NAME(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type), \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type, glsl_type::float16_t_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type, glsl_type::float16_t_type),   \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type, glsl_type::float16_t_type),   \
+                                                                                                      \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type, glsl_type::f16vec2_type),     \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type, glsl_type::f16vec3_type),     \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type, glsl_type::f16vec4_type),     \
+                NULL);
+
    F(radians)
    F(degrees)
    F(sin)
@@ -5653,6 +5834,12 @@ builtin_builder::out_var(const glsl_type *type, const char *name)
    return new(mem_ctx) ir_variable(type, name, ir_var_function_out);
 }
 
+ir_constant *
+builtin_builder::imm(float16_t f16, unsigned vector_elements)
+{
+   return new(mem_ctx) ir_constant(f16, vector_elements);
+}
+
 ir_constant *
 builtin_builder::imm(bool b, unsigned vector_elements)
 {
@@ -5689,7 +5876,8 @@ builtin_builder::imm(const glsl_type *type, const ir_constant_data &data)
    return new(mem_ctx) ir_constant(type, &data);
 }
 
-#define IMM_FP(type, val) (type->is_double()) ? imm(val) : imm((float)val)
+#define IMM_FP(type, val) (type->is_double()) ? imm(val) : \
+   (type->base_type == GLSL_TYPE_FLOAT16  ? imm((float16_t)val) : imm((float)val))
 
 ir_dereference_variable *
 builtin_builder::var_ref(ir_variable *var)
-- 
GitLab


From 25e6eeed3487d07fde86b6a5626877b97bc731ed Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Thu, 30 Jun 2022 15:19:28 +1000
Subject: [PATCH 10/29] glsl: add half float angle and trigonometry functions

---
 src/compiler/glsl/builtin_functions.cpp | 181 +++++++++++++-----------
 1 file changed, 100 insertions(+), 81 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index c6fea622f6ab..32ba47970bad 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1034,7 +1034,6 @@ private:
    ir_dereference_record *record_ref(ir_variable *var, const char *field);
 
    ir_expression *asin_expr(ir_variable *x, float p0, float p1);
-   void do_atan(ir_factory &body, const glsl_type *type, ir_variable *res, operand y_over_x);
 
    /**
     * Call function \param f with parameters specified as the linked
@@ -1096,21 +1095,21 @@ private:
 #define B3(X) ir_function_signature *_##X(const glsl_type *, const glsl_type *, const glsl_type *);
 #define BA1(X) ir_function_signature *_##X(builtin_available_predicate, const glsl_type *);
 #define BA2(X) ir_function_signature *_##X(builtin_available_predicate, const glsl_type *, const glsl_type *);
-   B1(radians)
-   B1(degrees)
-   B1(sin)
-   B1(cos)
-   B1(tan)
-   B1(asin)
-   B1(acos)
-   B1(atan2)
-   B1(atan)
-   B1(sinh)
-   B1(cosh)
-   B1(tanh)
-   B1(asinh)
-   B1(acosh)
-   B1(atanh)
+   BA1(radians)
+   BA1(degrees)
+   BA1(sin)
+   BA1(cos)
+   BA1(tan)
+   BA1(asin)
+   BA1(acos)
+   BA1(atan2)
+   BA1(atan)
+   BA1(sinh)
+   BA1(cosh)
+   BA1(tanh)
+   BA1(asinh)
+   BA1(acosh)
+   BA1(atanh)
    B1(pow)
    B1(exp)
    B1(log)
@@ -2114,31 +2113,39 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type, glsl_type::f16vec4_type),     \
                 NULL);
 
-   F(radians)
-   F(degrees)
-   F(sin)
-   F(cos)
-   F(tan)
-   F(asin)
-   F(acos)
+   FHF(radians)
+   FHF(degrees)
+   FHF(sin)
+   FHF(cos)
+   FHF(tan)
+   FHF(asin)
+   FHF(acos)
 
    add_function("atan",
-                _atan(glsl_type::float_type),
-                _atan(glsl_type::vec2_type),
-                _atan(glsl_type::vec3_type),
-                _atan(glsl_type::vec4_type),
-                _atan2(glsl_type::float_type),
-                _atan2(glsl_type::vec2_type),
-                _atan2(glsl_type::vec3_type),
-                _atan2(glsl_type::vec4_type),
-                NULL);
-
-   F(sinh)
-   F(cosh)
-   F(tanh)
-   F(asinh)
-   F(acosh)
-   F(atanh)
+                _atan(always_available, glsl_type::float_type),
+                _atan(always_available, glsl_type::vec2_type),
+                _atan(always_available, glsl_type::vec3_type),
+                _atan(always_available, glsl_type::vec4_type),
+                _atan2(always_available, glsl_type::float_type),
+                _atan2(always_available, glsl_type::vec2_type),
+                _atan2(always_available, glsl_type::vec3_type),
+                _atan2(always_available, glsl_type::vec4_type),
+                _atan(gpu_shader_half_float, glsl_type::float16_t_type),
+                _atan(gpu_shader_half_float, glsl_type::f16vec2_type),
+                _atan(gpu_shader_half_float, glsl_type::f16vec3_type),
+                _atan(gpu_shader_half_float, glsl_type::f16vec4_type),
+                _atan2(gpu_shader_half_float, glsl_type::float16_t_type),
+                _atan2(gpu_shader_half_float, glsl_type::f16vec2_type),
+                _atan2(gpu_shader_half_float, glsl_type::f16vec3_type),
+                _atan2(gpu_shader_half_float, glsl_type::f16vec4_type),
+                NULL);
+
+   FHF130(sinh)
+   FHF130(cosh)
+   FHF130(tanh)
+   FHF130(asinh)
+   FHF130(acosh)
+   FHF130(atanh)
    F(pow)
    F(exp)
    F(log)
@@ -6001,31 +6008,34 @@ builtin_builder::_##NAME(const glsl_type *return_type,                  \
  */
 
 ir_function_signature *
-builtin_builder::_radians(const glsl_type *type)
+builtin_builder::_radians(builtin_available_predicate avail,
+                          const glsl_type *type)
 {
    ir_variable *degrees = in_var(type, "degrees");
-   MAKE_SIG(type, always_available, 1, degrees);
-   body.emit(ret(mul(degrees, imm(0.0174532925f))));
+   MAKE_SIG(type, avail, 1, degrees);
+   body.emit(ret(mul(degrees, IMM_FP(type, 0.0174532925f))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_degrees(const glsl_type *type)
+builtin_builder::_degrees(builtin_available_predicate avail,
+                          const glsl_type *type)
 {
    ir_variable *radians = in_var(type, "radians");
-   MAKE_SIG(type, always_available, 1, radians);
-   body.emit(ret(mul(radians, imm(57.29578f))));
+   MAKE_SIG(type, avail, 1, radians);
+   body.emit(ret(mul(radians, IMM_FP(type, 57.29578f))));
    return sig;
 }
 
-UNOP(sin, ir_unop_sin, always_available)
-UNOP(cos, ir_unop_cos, always_available)
+UNOPA(sin, ir_unop_sin)
+UNOPA(cos, ir_unop_cos)
 
 ir_function_signature *
-builtin_builder::_tan(const glsl_type *type)
+builtin_builder::_tan(builtin_available_predicate avail,
+                      const glsl_type *type)
 {
    ir_variable *theta = in_var(type, "theta");
-   MAKE_SIG(type, always_available, 1, theta);
+   MAKE_SIG(type, avail, 1, theta);
    body.emit(ret(div(sin(theta), cos(theta))));
    return sig;
 }
@@ -6034,14 +6044,14 @@ ir_expression *
 builtin_builder::asin_expr(ir_variable *x, float p0, float p1)
 {
    return mul(sign(x),
-              sub(imm(M_PI_2f),
-                  mul(sqrt(sub(imm(1.0f), abs(x))),
-                      add(imm(M_PI_2f),
+              sub(IMM_FP(x->type, M_PI_2f),
+                  mul(sqrt(sub(IMM_FP(x->type, 1.0f), abs(x))),
+                      add(IMM_FP(x->type, M_PI_2f),
                           mul(abs(x),
-                              add(imm(M_PI_4f - 1.0f),
+                              add(IMM_FP(x->type, (M_PI_4f - 1.0f)),
                                   mul(abs(x),
-                                      add(imm(p0),
-                                          mul(abs(x), imm(p1))))))))));
+                                      add(IMM_FP(x->type, p0),
+                                          mul(abs(x), IMM_FP(x->type, p1))))))))));
 }
 
 /**
@@ -6081,10 +6091,11 @@ builtin_builder::call(ir_function *f, ir_variable *ret, exec_list params)
 }
 
 ir_function_signature *
-builtin_builder::_asin(const glsl_type *type)
+builtin_builder::_asin(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, always_available, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(asin_expr(x, 0.086566724f, -0.03102955f)));
 
@@ -6092,10 +6103,11 @@ builtin_builder::_asin(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_acos(const glsl_type *type)
+builtin_builder::_acos(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, always_available, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(sub(imm(M_PI_2f), asin_expr(x, 0.08132463f, -0.02363318f))));
 
@@ -6103,34 +6115,37 @@ builtin_builder::_acos(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_sinh(const glsl_type *type)
+builtin_builder::_sinh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* 0.5 * (e^x - e^(-x)) */
-   body.emit(ret(mul(imm(0.5f), sub(exp(x), exp(neg(x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), sub(exp(x), exp(neg(x))))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_cosh(const glsl_type *type)
+builtin_builder::_cosh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* 0.5 * (e^x + e^(-x)) */
-   body.emit(ret(mul(imm(0.5f), add(exp(x), exp(neg(x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), add(exp(x), exp(neg(x))))));
 
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_tanh(const glsl_type *type)
+builtin_builder::_tanh(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    /* Clamp x to [-10, +10] to avoid precision problems.
     * When x > 10, e^(-x) is so small relative to e^x that it gets flushed to
@@ -6138,7 +6153,7 @@ builtin_builder::_tanh(const glsl_type *type)
     * direction when x < -10.
     */
    ir_variable *t = body.make_temp(type, "tmp");
-   body.emit(assign(t, min2(max2(x, imm(-10.0f)), imm(10.0f))));
+   body.emit(assign(t, min2(max2(x, IMM_FP(type, -10.0f)), IMM_FP(type, 10.0f))));
 
    /* (e^x - e^(-x)) / (e^x + e^(-x)) */
    body.emit(ret(div(sub(exp(t), exp(neg(t))),
@@ -6148,34 +6163,37 @@ builtin_builder::_tanh(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_asinh(const glsl_type *type)
+builtin_builder::_asinh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
    body.emit(ret(mul(sign(x), log(add(abs(x), sqrt(add(mul(x, x),
-                                                       imm(1.0f))))))));
+                                                       IMM_FP(type, 1.0f))))))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_acosh(const glsl_type *type)
+builtin_builder::_acosh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(log(add(x, sqrt(sub(mul(x, x), imm(1.0f)))))));
+   body.emit(ret(log(add(x, sqrt(sub(mul(x, x), IMM_FP(type, 1.0f)))))));
    return sig;
 }
 
 ir_function_signature *
-builtin_builder::_atanh(const glsl_type *type)
+builtin_builder::_atanh(builtin_available_predicate avail,
+                        const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type, v130, 1, x);
+   MAKE_SIG(type, avail, 1, x);
 
-   body.emit(ret(mul(imm(0.5f), log(div(add(imm(1.0f), x),
-                                        sub(imm(1.0f), x))))));
+   body.emit(ret(mul(IMM_FP(type, 0.5f), log(div(add(IMM_FP(type, 1.0f), x),
+                                                 sub(IMM_FP(type, 1.0f), x))))));
    return sig;
 }
 /** @} */
@@ -6194,7 +6212,7 @@ UNOP(exp,         ir_unop_exp,  always_available)
 UNOP(log,         ir_unop_log,  always_available)
 UNOP(exp2,        ir_unop_exp2, always_available)
 UNOP(log2,        ir_unop_log2, always_available)
-UNOP(atan,        ir_unop_atan, always_available)
+UNOPA(atan,        ir_unop_atan)
 UNOPA(sqrt,        ir_unop_sqrt)
 UNOPA(inversesqrt, ir_unop_rsq)
 
@@ -6395,9 +6413,10 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
 }
 
 ir_function_signature *
-builtin_builder::_atan2(const glsl_type *x_type)
+builtin_builder::_atan2(builtin_available_predicate avail,
+                        const glsl_type *x_type)
 {
-   return binop(always_available, ir_binop_atan2, x_type, x_type, x_type);
+   return binop(avail, ir_binop_atan2, x_type, x_type, x_type);
 }
 
 ir_function_signature *
-- 
GitLab


From c5afc779eca52797a8a62952b60d3d4abf5f7c2d Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 1 Jul 2022 16:00:35 +1000
Subject: [PATCH 11/29] glsl: add half float exponential functions

---
 src/compiler/glsl/builtin_functions.cpp | 37 +++++++++++++------------
 1 file changed, 19 insertions(+), 18 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 32ba47970bad..14ef25214f2e 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1110,11 +1110,11 @@ private:
    BA1(asinh)
    BA1(acosh)
    BA1(atanh)
-   B1(pow)
-   B1(exp)
-   B1(log)
-   B1(exp2)
-   B1(log2)
+   BA1(pow)
+   BA1(exp)
+   BA1(log)
+   BA1(exp2)
+   BA1(log2)
    BA1(sqrt)
    BA1(inversesqrt)
    BA1(abs)
@@ -2146,13 +2146,13 @@ builtin_builder::create_builtins()
    FHF130(asinh)
    FHF130(acosh)
    FHF130(atanh)
-   F(pow)
-   F(exp)
-   F(log)
-   F(exp2)
-   F(log2)
-   FD(sqrt)
-   FD(inversesqrt)
+   FHF(pow)
+   FHF(exp)
+   FHF(log)
+   FHF(exp2)
+   FHF(log2)
+   FDHF(sqrt)
+   FDHF(inversesqrt)
    FI64(abs)
    FI64(sign)
    FD(floor)
@@ -6203,15 +6203,16 @@ builtin_builder::_atanh(builtin_available_predicate avail,
  */
 
 ir_function_signature *
-builtin_builder::_pow(const glsl_type *type)
+builtin_builder::_pow(builtin_available_predicate avail,
+                      const glsl_type *type)
 {
-   return binop(always_available, ir_binop_pow, type, type, type);
+   return binop(avail, ir_binop_pow, type, type, type);
 }
 
-UNOP(exp,         ir_unop_exp,  always_available)
-UNOP(log,         ir_unop_log,  always_available)
-UNOP(exp2,        ir_unop_exp2, always_available)
-UNOP(log2,        ir_unop_log2, always_available)
+UNOPA(exp,         ir_unop_exp)
+UNOPA(log,         ir_unop_log)
+UNOPA(exp2,        ir_unop_exp2)
+UNOPA(log2,        ir_unop_log2)
 UNOPA(atan,        ir_unop_atan)
 UNOPA(sqrt,        ir_unop_sqrt)
 UNOPA(inversesqrt, ir_unop_rsq)
-- 
GitLab


From e2015e3fc2c8ecd0068544081b1974c2f82c7071 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 1 Jul 2022 20:44:31 +1000
Subject: [PATCH 12/29] glsl: add half float support for common functions

---
 src/compiler/glsl/builtin_functions.cpp | 101 +++++++++++++++++++-----
 src/compiler/glsl/ir_validate.cpp       |   7 +-
 2 files changed, 87 insertions(+), 21 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 14ef25214f2e..840a364f1e6f 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2153,14 +2153,14 @@ builtin_builder::create_builtins()
    FHF(log2)
    FDHF(sqrt)
    FDHF(inversesqrt)
-   FI64(abs)
-   FI64(sign)
-   FD(floor)
-   FD130(trunc)
-   FD130GS4(round)
-   FD130(roundEven)
-   FD(ceil)
-   FD(fract)
+   FI64HF(abs)
+   FI64HF(sign)
+   FDHF(floor)
+   FDHF130(trunc)
+   FDHF130GS4(round)
+   FDHF130(roundEven)
+   FDHF(ceil)
+   FDHF(fract)
 
    add_function("truncate",
                 _truncate(gpu_shader4, glsl_type::float_type),
@@ -2180,6 +2180,15 @@ builtin_builder::create_builtins()
                 _mod(always_available, glsl_type::vec3_type,  glsl_type::vec3_type),
                 _mod(always_available, glsl_type::vec4_type,  glsl_type::vec4_type),
 
+                _mod(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::float16_t_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::float16_t_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::float16_t_type),
+
+                _mod(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _mod(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
+
                 _mod(fp64, glsl_type::double_type, glsl_type::double_type),
                 _mod(fp64, glsl_type::dvec2_type,  glsl_type::double_type),
                 _mod(fp64, glsl_type::dvec3_type,  glsl_type::double_type),
@@ -2190,11 +2199,11 @@ builtin_builder::create_builtins()
                 _mod(fp64, glsl_type::dvec4_type,  glsl_type::dvec4_type),
                 NULL);
 
-   FD130(modf)
+   FDHF130(modf)
 
-   FIUD2_MIXED(min)
-   FIUD2_MIXED(max)
-   FIUD2_MIXED(clamp)
+   FIUDHF2_MIXED(min)
+   FIUDHF2_MIXED(max)
+   FIUDHF2_MIXED(clamp)
 
    add_function("mix",
                 _mix_lrp(always_available, glsl_type::float_type, glsl_type::float_type),
@@ -2206,6 +2215,15 @@ builtin_builder::create_builtins()
                 _mix_lrp(always_available, glsl_type::vec3_type,  glsl_type::vec3_type),
                 _mix_lrp(always_available, glsl_type::vec4_type,  glsl_type::vec4_type),
 
+                _mix_lrp(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::float16_t_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::float16_t_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::float16_t_type),
+
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _mix_lrp(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
+
                 _mix_lrp(fp64, glsl_type::double_type, glsl_type::double_type),
                 _mix_lrp(fp64, glsl_type::dvec2_type,  glsl_type::double_type),
                 _mix_lrp(fp64, glsl_type::dvec3_type,  glsl_type::double_type),
@@ -2220,6 +2238,11 @@ builtin_builder::create_builtins()
                 _mix_sel(v130, glsl_type::vec3_type,  glsl_type::bvec3_type),
                 _mix_sel(v130, glsl_type::vec4_type,  glsl_type::bvec4_type),
 
+                _mix_sel(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::bool_type),
+                _mix_sel(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::bvec2_type),
+                _mix_sel(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::bvec3_type),
+                _mix_sel(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::bvec4_type),
+
                 _mix_sel(fp64, glsl_type::double_type, glsl_type::bool_type),
                 _mix_sel(fp64, glsl_type::dvec2_type,  glsl_type::bvec2_type),
                 _mix_sel(fp64, glsl_type::dvec3_type,  glsl_type::bvec3_type),
@@ -2268,6 +2291,15 @@ builtin_builder::create_builtins()
                 _step(fp64, glsl_type::dvec2_type,  glsl_type::dvec2_type),
                 _step(fp64, glsl_type::dvec3_type,  glsl_type::dvec3_type),
                 _step(fp64, glsl_type::dvec4_type,  glsl_type::dvec4_type),
+
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec2_type),
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec3_type),
+                _step(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec4_type),
+
+                _step(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _step(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _step(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
                 NULL);
 
    add_function("smoothstep",
@@ -2287,10 +2319,19 @@ builtin_builder::create_builtins()
                 _smoothstep(fp64, glsl_type::dvec2_type,  glsl_type::dvec2_type),
                 _smoothstep(fp64, glsl_type::dvec3_type,  glsl_type::dvec3_type),
                 _smoothstep(fp64, glsl_type::dvec4_type,  glsl_type::dvec4_type),
+
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::float16_t_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec2_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec3_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::float16_t_type, glsl_type::f16vec4_type),
+
+                _smoothstep(gpu_shader_half_float, glsl_type::f16vec2_type,  glsl_type::f16vec2_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::f16vec3_type,  glsl_type::f16vec3_type),
+                _smoothstep(gpu_shader_half_float, glsl_type::f16vec4_type,  glsl_type::f16vec4_type),
                 NULL);
 
-   FD130(isnan)
-   FD130(isinf)
+   FDHF130(isnan)
+   FDHF130(isinf)
 
    F(floatBitsToInt)
    F(floatBitsToUint)
@@ -4911,7 +4952,7 @@ builtin_builder::create_builtins()
    IU(bitCount)
    IU(findLSB)
    IU(findMSB)
-   FDGS5(fma)
+   FDHFGS5(fma)
 
    add_function("ldexp",
                 _ldexp(glsl_type::float_type, glsl_type::int_type),
@@ -4922,6 +4963,10 @@ builtin_builder::create_builtins()
                 _ldexp(glsl_type::dvec2_type,  glsl_type::ivec2_type),
                 _ldexp(glsl_type::dvec3_type,  glsl_type::ivec3_type),
                 _ldexp(glsl_type::dvec4_type,  glsl_type::ivec4_type),
+                _ldexp(glsl_type::float16_t_type, glsl_type::int_type),
+                _ldexp(glsl_type::f16vec2_type,  glsl_type::ivec2_type),
+                _ldexp(glsl_type::f16vec3_type,  glsl_type::ivec3_type),
+                _ldexp(glsl_type::f16vec4_type,  glsl_type::ivec4_type),
                 NULL);
 
    add_function("frexp",
@@ -4933,6 +4978,10 @@ builtin_builder::create_builtins()
                 _dfrexp(glsl_type::dvec2_type,  glsl_type::ivec2_type),
                 _dfrexp(glsl_type::dvec3_type,  glsl_type::ivec3_type),
                 _dfrexp(glsl_type::dvec4_type,  glsl_type::ivec4_type),
+                _dfrexp(glsl_type::float16_t_type, glsl_type::int_type),
+                _dfrexp(glsl_type::f16vec2_type,  glsl_type::ivec2_type),
+                _dfrexp(glsl_type::f16vec3_type,  glsl_type::ivec3_type),
+                _dfrexp(glsl_type::f16vec4_type,  glsl_type::ivec4_type),
                 NULL);
    add_function("uaddCarry",
                 _uaddCarry(glsl_type::uint_type),
@@ -6326,6 +6375,8 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
       /* Both are floats */
       if (edge_type->is_double())
          body.emit(assign(t, f2d(b2f(gequal(x, edge)))));
+      else if (edge_type->base_type == GLSL_TYPE_FLOAT16)
+         body.emit(assign(t, f2f16(b2f(gequal(x, edge)))));
       else
          body.emit(assign(t, b2f(gequal(x, edge))));
    } else if (edge_type->vector_elements == 1) {
@@ -6333,6 +6384,8 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
       for (int i = 0; i < x_type->vector_elements; i++) {
          if (edge_type->is_double())
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
+         else if (edge_type->base_type == GLSL_TYPE_FLOAT16)
+            body.emit(assign(t, f2f16(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), edge)), 1 << i));
       }
@@ -6342,6 +6395,9 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
          if (edge_type->is_double())
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
                              1 << i));
+         else if (edge_type->base_type == GLSL_TYPE_FLOAT16)
+            body.emit(assign(t, f2f16(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
+                             1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1))),
                              1 << i));
@@ -6397,6 +6453,9 @@ builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type
    ir_constant_data infinities;
    for (int i = 0; i < type->vector_elements; i++) {
       switch (type->base_type) {
+      case GLSL_TYPE_FLOAT16:
+         infinities.f16[i] = _mesa_float_to_half(INFINITY);
+         break;
       case GLSL_TYPE_FLOAT:
          infinities.f[i] = INFINITY;
          break;
@@ -7887,8 +7946,11 @@ builtin_builder::_fma(builtin_available_predicate avail, const glsl_type *type)
 ir_function_signature *
 builtin_builder::_ldexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
-   return binop(x_type->is_double() ? fp64 : gpu_shader5_or_es31_or_integer_functions,
-                ir_binop_ldexp, x_type, x_type, exp_type);
+   builtin_available_predicate avail = x_type->is_double() ? fp64 :
+      (x_type->base_type == GLSL_TYPE_FLOAT16 ?
+          gpu_shader_half_float : gpu_shader5_or_es31_or_integer_functions);
+
+   return binop(avail, ir_binop_ldexp, x_type, x_type, exp_type);
 }
 
 ir_function_signature *
@@ -7896,7 +7958,10 @@ builtin_builder::_dfrexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_var(x_type, "x");
    ir_variable *exponent = out_var(exp_type, "exp");
-   MAKE_SIG(x_type, fp64, 2, x, exponent);
+
+   builtin_available_predicate avail = x_type->is_double() ?
+      fp64 : gpu_shader_half_float;
+   MAKE_SIG(x_type, avail, 2, x, exponent);
 
    body.emit(assign(exponent, expr(ir_unop_frexp_exp, x)));
 
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index 5177d4fe8480..e88c7b250486 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -735,11 +735,12 @@ ir_validate::visit_leave(ir_expression *ir)
       break;
 
    case ir_unop_frexp_sig:
-      assert(ir->operands[0]->type->is_float_32_64());
-      assert(ir->type->is_double());
+      assert(ir->operands[0]->type->is_float_16_32_64());
+      assert(ir->type->is_double() ||
+             ir->type->base_type == GLSL_TYPE_FLOAT16);
       break;
    case ir_unop_frexp_exp:
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(ir->operands[0]->type->is_float_16_32_64());
       assert(ir->type->base_type == GLSL_TYPE_INT);
       break;
    case ir_unop_subroutine_to_int:
-- 
GitLab


From fbff2f6846480c02b9d605c557acb93c682c70f1 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 13:49:06 +1000
Subject: [PATCH 13/29] glsl: add support for half float packing functions

We can reused the existing half packing support because the
constant expression evaluation support automatically converts the
float16 type to float for evaluation on the CPU, see 878a35db9daf.
---
 src/compiler/glsl/builtin_functions.cpp | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 840a364f1e6f..c8d19fbc4c02 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1159,6 +1159,8 @@ private:
    ir_function_signature *_unpackSnorm4x8(builtin_available_predicate avail);
    ir_function_signature *_packHalf2x16(builtin_available_predicate avail);
    ir_function_signature *_unpackHalf2x16(builtin_available_predicate avail);
+   ir_function_signature *_packFloat2x16(builtin_available_predicate avail);
+   ir_function_signature *_unpackFloat2x16(builtin_available_predicate avail);
    ir_function_signature *_packDouble2x32(builtin_available_predicate avail);
    ir_function_signature *_unpackDouble2x32(builtin_available_predicate avail);
    ir_function_signature *_packInt2x32(builtin_available_predicate avail);
@@ -2386,6 +2388,8 @@ builtin_builder::create_builtins()
    add_function("unpackSnorm4x8",  _unpackSnorm4x8(shader_packing_or_es31_or_gpu_shader5), NULL);
    add_function("packHalf2x16",    _packHalf2x16(shader_packing_or_es3),                   NULL);
    add_function("unpackHalf2x16",  _unpackHalf2x16(shader_packing_or_es3),                 NULL);
+   add_function("packFloat2x16",    _packFloat2x16(gpu_shader_half_float),                 NULL);
+   add_function("unpackFloat2x16",  _unpackFloat2x16(gpu_shader_half_float),               NULL);
    add_function("packDouble2x32",    _packDouble2x32(fp64),                   NULL);
    add_function("unpackDouble2x32",  _unpackDouble2x32(fp64),                 NULL);
 
@@ -6642,6 +6646,24 @@ builtin_builder::_unpackHalf2x16(builtin_available_predicate avail)
    return sig;
 }
 
+ir_function_signature *
+builtin_builder::_packFloat2x16(builtin_available_predicate avail)
+{
+   ir_variable *v = in_var(glsl_type::f16vec2_type, "v");
+   MAKE_SIG(glsl_type::uint_type, avail, 1, v);
+   body.emit(ret(expr(ir_unop_pack_half_2x16, v)));
+   return sig;
+}
+
+ir_function_signature *
+builtin_builder::_unpackFloat2x16(builtin_available_predicate avail)
+{
+   ir_variable *p = in_var(glsl_type::uint_type, "p");
+   MAKE_SIG(glsl_type::f16vec2_type, avail, 1, p);
+   body.emit(ret(f2f16(expr(ir_unop_unpack_half_2x16, p))));
+   return sig;
+}
+
 ir_function_signature *
 builtin_builder::_packDouble2x32(builtin_available_predicate avail)
 {
-- 
GitLab


From a8e4aa9b28f932c3fe386dcd0e47ed4181791364 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 15:33:10 +1000
Subject: [PATCH 14/29] glsl: add half float geometric functions

---
 src/compiler/glsl/builtin_functions.cpp | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index c8d19fbc4c02..9707ca342743 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2398,18 +2398,20 @@ builtin_builder::create_builtins()
    add_function("packUint2x32",    _packUint2x32(int64_avail),                   NULL);
    add_function("unpackUint2x32",  _unpackUint2x32(int64_avail),                 NULL);
 
-   FD(length)
-   FD(distance)
-   FD(dot)
+   FDHF(length)
+   FDHF(distance)
+   FDHF(dot)
 
    add_function("cross", _cross(always_available, glsl_type::vec3_type),
-                _cross(fp64, glsl_type::dvec3_type), NULL);
+                _cross(fp64, glsl_type::dvec3_type),
+                _cross(gpu_shader_half_float, glsl_type::f16vec3_type),
+                NULL);
 
-   FD(normalize)
+   FDHF(normalize)
    add_function("ftransform", _ftransform(), NULL);
-   FD(faceforward)
-   FD(reflect)
-   FD(refract)
+   FDHF(faceforward)
+   FDHF(reflect)
+   FDHF(refract)
    // ...
    add_function("matrixCompMult",
                 _matrixCompMult(always_available, glsl_type::mat2_type),
-- 
GitLab


From 697d445a96dbcea39d27492dc299d55c72843c63 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 16:13:01 +1000
Subject: [PATCH 15/29] glsl: add half float matrix functions

---
 src/compiler/glsl/builtin_functions.cpp | 41 +++++++++++++++++++++++--
 1 file changed, 38 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 9707ca342743..c9406ca5f126 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -2432,6 +2432,15 @@ builtin_builder::create_builtins()
                 _matrixCompMult(fp64, glsl_type::dmat3x4_type),
                 _matrixCompMult(fp64, glsl_type::dmat4x2_type),
                 _matrixCompMult(fp64, glsl_type::dmat4x3_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat4_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat2x3_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat2x4_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat3x2_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat3x4_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat4x2_type),
+                _matrixCompMult(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
    add_function("outerProduct",
                 _outerProduct(v120, glsl_type::mat2_type),
@@ -2452,6 +2461,15 @@ builtin_builder::create_builtins()
                 _outerProduct(fp64, glsl_type::dmat3x4_type),
                 _outerProduct(fp64, glsl_type::dmat4x2_type),
                 _outerProduct(fp64, glsl_type::dmat4x3_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat4_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat2x3_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat2x4_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat3x2_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat3x4_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat4x2_type),
+                _outerProduct(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
    add_function("determinant",
                 _determinant_mat2(v120, glsl_type::mat2_type),
@@ -2460,7 +2478,9 @@ builtin_builder::create_builtins()
                 _determinant_mat2(fp64, glsl_type::dmat2_type),
                 _determinant_mat3(fp64, glsl_type::dmat3_type),
                 _determinant_mat4(fp64, glsl_type::dmat4_type),
-
+                _determinant_mat2(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _determinant_mat3(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _determinant_mat4(gpu_shader_half_float, glsl_type::f16mat4_type),
                 NULL);
    add_function("inverse",
                 _inverse_mat2(v140_or_es3, glsl_type::mat2_type),
@@ -2469,6 +2489,9 @@ builtin_builder::create_builtins()
                 _inverse_mat2(fp64, glsl_type::dmat2_type),
                 _inverse_mat3(fp64, glsl_type::dmat3_type),
                 _inverse_mat4(fp64, glsl_type::dmat4_type),
+                _inverse_mat2(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _inverse_mat3(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _inverse_mat4(gpu_shader_half_float, glsl_type::f16mat4_type),
                 NULL);
    add_function("transpose",
                 _transpose(v120, glsl_type::mat2_type),
@@ -2489,6 +2512,15 @@ builtin_builder::create_builtins()
                 _transpose(fp64, glsl_type::dmat3x4_type),
                 _transpose(fp64, glsl_type::dmat4x2_type),
                 _transpose(fp64, glsl_type::dmat4x3_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat2_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat3_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat4_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat2x3_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat2x4_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat3x2_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat3x4_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat4x2_type),
+                _transpose(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
    FIUD_VEC(lessThan)
    FIUD_VEC(lessThanEqual)
@@ -6884,6 +6916,9 @@ builtin_builder::_outerProduct(builtin_available_predicate avail, const glsl_typ
    if (type->is_double()) {
       r = in_var(glsl_type::dvec(type->matrix_columns), "r");
       c = in_var(glsl_type::dvec(type->vector_elements), "c");
+   } else if (type->base_type == GLSL_TYPE_FLOAT16) {
+      r = in_var(glsl_type::f16vec(type->matrix_columns), "r");
+      c = in_var(glsl_type::f16vec(type->vector_elements), "c");
    } else {
       r = in_var(glsl_type::vec(type->matrix_columns), "r");
       c = in_var(glsl_type::vec(type->vector_elements), "c");
@@ -7007,7 +7042,7 @@ builtin_builder::_determinant_mat4(builtin_available_predicate avail, const glsl
    body.emit(assign(SubFactor17, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 2)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 2)))));
    body.emit(assign(SubFactor18, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 1)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 1)))));
 
-   ir_variable *adj_0 = body.make_temp(btype == glsl_type::float_type ? glsl_type::vec4_type : glsl_type::dvec4_type, "adj_0");
+   ir_variable *adj_0 = body.make_temp(btype == glsl_type::float_type ? glsl_type::vec4_type : btype == glsl_type::float16_t_type ? glsl_type::f16vec4_type : glsl_type::dvec4_type, "adj_0");
 
    body.emit(assign(adj_0,
                     add(sub(mul(matrix_elt(m, 1, 1), SubFactor00),
@@ -7164,7 +7199,7 @@ builtin_builder::_inverse_mat4(builtin_available_predicate avail, const glsl_typ
    body.emit(assign(SubFactor17, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 2)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 2)))));
    body.emit(assign(SubFactor18, sub(mul(matrix_elt(m, 1, 0), matrix_elt(m, 2, 1)), mul(matrix_elt(m, 2, 0), matrix_elt(m, 1, 1)))));
 
-   ir_variable *adj = body.make_temp(btype == glsl_type::float_type ? glsl_type::mat4_type : glsl_type::dmat4_type, "adj");
+   ir_variable *adj = body.make_temp(btype == glsl_type::float_type ? glsl_type::mat4_type : (btype == glsl_type::double_type ? glsl_type::dmat4_type : glsl_type::f16mat4_type), "adj");
    body.emit(assign(array_ref(adj, 0),
                     add(sub(mul(matrix_elt(m, 1, 1), SubFactor00),
                             mul(matrix_elt(m, 1, 2), SubFactor01)),
-- 
GitLab


From 5fcb66e88ce65a4e92e4ed75402ef589c681e5c8 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 16:29:06 +1000
Subject: [PATCH 16/29] glsl: add half float vector relational functions

---
 src/compiler/glsl/builtin_functions.cpp | 26 +++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index c9406ca5f126..9f1ac4f45bb4 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -1930,7 +1930,7 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
-#define FIUD_VEC(NAME)                                            \
+#define FIUDHF_VEC(NAME)                                          \
    add_function(#NAME,                                            \
                 _##NAME(always_available, glsl_type::vec2_type),  \
                 _##NAME(always_available, glsl_type::vec3_type),  \
@@ -1954,6 +1954,9 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::u64vec2_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec3_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
 #define IU(NAME)                                \
@@ -1969,7 +1972,7 @@ builtin_builder::create_builtins()
                 _##NAME(glsl_type::uvec4_type), \
                 NULL);
 
-#define FIUBD_VEC(NAME)                                           \
+#define FIUBDHF_VEC(NAME)                                           \
    add_function(#NAME,                                            \
                 _##NAME(always_available, glsl_type::vec2_type),  \
                 _##NAME(always_available, glsl_type::vec3_type),  \
@@ -1998,6 +2001,9 @@ builtin_builder::create_builtins()
                 _##NAME(int64_avail, glsl_type::u64vec2_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec3_type),  \
                 _##NAME(int64_avail, glsl_type::u64vec4_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec2_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec3_type),  \
+                _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
 #define FIUD2_MIXED(NAME)                                                                 \
@@ -2522,12 +2528,12 @@ builtin_builder::create_builtins()
                 _transpose(gpu_shader_half_float, glsl_type::f16mat4x2_type),
                 _transpose(gpu_shader_half_float, glsl_type::f16mat4x3_type),
                 NULL);
-   FIUD_VEC(lessThan)
-   FIUD_VEC(lessThanEqual)
-   FIUD_VEC(greaterThan)
-   FIUD_VEC(greaterThanEqual)
-   FIUBD_VEC(notEqual)
-   FIUBD_VEC(equal)
+   FIUDHF_VEC(lessThan)
+   FIUDHF_VEC(lessThanEqual)
+   FIUDHF_VEC(greaterThan)
+   FIUDHF_VEC(greaterThanEqual)
+   FIUBDHF_VEC(notEqual)
+   FIUBDHF_VEC(equal)
 
    add_function("any",
                 _any(glsl_type::bvec2_type),
@@ -5695,8 +5701,8 @@ builtin_builder::create_builtins()
 
 #undef F
 #undef FI
-#undef FIUD_VEC
-#undef FIUBD_VEC
+#undef FIUDHF_VEC
+#undef FIUBDHF_VEC
 #undef FIU2_MIXED
 }
 
-- 
GitLab


From 02310320b7276a73c8824d0908f02c41ee5b9b69 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 21:42:45 +1000
Subject: [PATCH 17/29] glsl: allow half float varyings

---
 src/compiler/glsl/ast_to_hir.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 560da4a5c3a7..441123ca60f4 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -4244,6 +4244,9 @@ apply_type_qualifier_to_variable(const struct ast_type_qualifier *qual,
       case GLSL_TYPE_FLOAT:
          /* Ok in all GLSL versions */
          break;
+      case GLSL_TYPE_FLOAT16:
+         if (state->AMD_gpu_shader_half_float_enable)
+         break;
       case GLSL_TYPE_UINT:
       case GLSL_TYPE_INT:
          if (state->is_version(130, 300) || state->EXT_gpu_shader4_enable)
-- 
GitLab


From 12c43bd28c4e050a782e954058ac26afac37f851 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 26 Jul 2022 21:44:00 +1000
Subject: [PATCH 18/29] glsl: add half float interpolation functions

---
 src/compiler/glsl/builtin_functions.cpp | 58 +++++++++++++++++--------
 1 file changed, 39 insertions(+), 19 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 9f1ac4f45bb4..4c0989f161cf 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -471,6 +471,11 @@ fs_interpolate_at(const _mesa_glsl_parse_state *state)
            state->OES_shader_multisample_interpolation_enable);
 }
 
+static bool
+fs_half_float_interpolate_at(const _mesa_glsl_parse_state *state)
+{
+   return fs_interpolate_at(state) && gpu_shader_half_float(state);
+}
 
 static bool
 texture_array_lod(const _mesa_glsl_parse_state *state)
@@ -1273,9 +1278,9 @@ private:
    BA1(averageRounded)
    B1(mulExtended)
    BA1(multiply32x16)
-   B1(interpolateAtCentroid)
-   B1(interpolateAtOffset)
-   B1(interpolateAtSample)
+   BA1(interpolateAtCentroid)
+   BA1(interpolateAtOffset)
+   BA1(interpolateAtSample)
 
    ir_function_signature *_atomic_counter_intrinsic(builtin_available_predicate avail,
                                                     enum ir_intrinsic_id id);
@@ -5052,22 +5057,34 @@ builtin_builder::create_builtins()
                 _mulExtended(glsl_type::uvec4_type),
                 NULL);
    add_function("interpolateAtCentroid",
-                _interpolateAtCentroid(glsl_type::float_type),
-                _interpolateAtCentroid(glsl_type::vec2_type),
-                _interpolateAtCentroid(glsl_type::vec3_type),
-                _interpolateAtCentroid(glsl_type::vec4_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::float_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::vec2_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::vec3_type),
+                _interpolateAtCentroid(fs_interpolate_at, glsl_type::vec4_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::float16_t_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::f16vec2_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::f16vec3_type),
+                _interpolateAtCentroid(fs_half_float_interpolate_at, glsl_type::f16vec4_type),
                 NULL);
    add_function("interpolateAtOffset",
-                _interpolateAtOffset(glsl_type::float_type),
-                _interpolateAtOffset(glsl_type::vec2_type),
-                _interpolateAtOffset(glsl_type::vec3_type),
-                _interpolateAtOffset(glsl_type::vec4_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::float_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::vec2_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::vec3_type),
+                _interpolateAtOffset(fs_interpolate_at, glsl_type::vec4_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::float16_t_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::f16vec2_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::f16vec3_type),
+                _interpolateAtOffset(fs_half_float_interpolate_at, glsl_type::f16vec4_type),
                 NULL);
    add_function("interpolateAtSample",
-                _interpolateAtSample(glsl_type::float_type),
-                _interpolateAtSample(glsl_type::vec2_type),
-                _interpolateAtSample(glsl_type::vec3_type),
-                _interpolateAtSample(glsl_type::vec4_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::float_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::vec2_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::vec3_type),
+                _interpolateAtSample(fs_interpolate_at, glsl_type::vec4_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::float16_t_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::f16vec2_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::f16vec3_type),
+                _interpolateAtSample(fs_half_float_interpolate_at, glsl_type::f16vec4_type),
                 NULL);
 
    add_function("atomicCounter",
@@ -8205,7 +8222,8 @@ builtin_builder::_multiply32x16(builtin_available_predicate avail,
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtCentroid(const glsl_type *type)
+builtin_builder::_interpolateAtCentroid(builtin_available_predicate avail,
+                                        const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
@@ -8217,11 +8235,12 @@ builtin_builder::_interpolateAtCentroid(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtOffset(const glsl_type *type)
+builtin_builder::_interpolateAtOffset(builtin_available_predicate avail,
+                                      const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
-   ir_variable *offset = in_var(glsl_type::vec2_type, "offset");
+   ir_variable *offset = in_var(type->base_type == GLSL_TYPE_FLOAT16 ? glsl_type::f16vec2_type : glsl_type::vec2_type, "offset");
    MAKE_SIG(type, fs_interpolate_at, 2, interpolant, offset);
 
    body.emit(ret(interpolate_at_offset(interpolant, offset)));
@@ -8230,7 +8249,8 @@ builtin_builder::_interpolateAtOffset(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_interpolateAtSample(const glsl_type *type)
+builtin_builder::_interpolateAtSample(builtin_available_predicate avail,
+                                      const glsl_type *type)
 {
    ir_variable *interpolant = in_var(type, "interpolant");
    interpolant->data.must_be_shader_input = 1;
-- 
GitLab


From 2551d66b478c22967c0703bdc956871c8adc4031 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 27 Jul 2022 13:48:45 +1000
Subject: [PATCH 19/29] glsl: add half float derivative functions

---
 src/compiler/glsl/builtin_functions.cpp | 99 +++++++++++++++++--------
 1 file changed, 69 insertions(+), 30 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 4c0989f161cf..90c4f822686e 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -622,6 +622,18 @@ derivative_control(const _mesa_glsl_parse_state *state)
            state->ARB_derivative_control_enable);
 }
 
+static bool
+half_float_derivatives(const _mesa_glsl_parse_state *state)
+{
+   return derivatives(state) && gpu_shader_half_float(state);
+}
+
+static bool
+half_float_derivative_control(const _mesa_glsl_parse_state *state)
+{
+   return derivative_control(state) && gpu_shader_half_float(state);
+}
+
 /** True if sampler3D exists */
 static bool
 tex3d(const _mesa_glsl_parse_state *state)
@@ -1243,15 +1255,15 @@ private:
    BA2(textureQueryLod);
    BA1(textureQueryLevels);
    BA2(textureSamplesIdentical);
-   B1(dFdx);
-   B1(dFdy);
-   B1(fwidth);
-   B1(dFdxCoarse);
-   B1(dFdyCoarse);
-   B1(fwidthCoarse);
-   B1(dFdxFine);
-   B1(dFdyFine);
-   B1(fwidthFine);
+   BA1(dFdx);
+   BA1(dFdy);
+   BA1(fwidth);
+   BA1(dFdxCoarse);
+   BA1(dFdyCoarse);
+   BA1(fwidthCoarse);
+   BA1(dFdxFine);
+   BA1(dFdyFine);
+   BA1(fwidthFine);
    B1(noise1);
    B1(noise2);
    B1(noise3);
@@ -1755,6 +1767,30 @@ builtin_builder::create_builtins()
                 _##NAME(gpu_shader_half_float, glsl_type::f16vec4_type),  \
                 NULL);
 
+#define FHF_DERIVATIVES(NAME)                                               \
+   add_function(#NAME,                                                      \
+                _##NAME(derivatives, glsl_type::float_type),                \
+                _##NAME(derivatives, glsl_type::vec2_type),                 \
+                _##NAME(derivatives, glsl_type::vec3_type),                 \
+                _##NAME(derivatives, glsl_type::vec4_type),                 \
+                _##NAME(half_float_derivatives, glsl_type::float16_t_type), \
+                _##NAME(half_float_derivatives, glsl_type::f16vec2_type),   \
+                _##NAME(half_float_derivatives, glsl_type::f16vec3_type),   \
+                _##NAME(half_float_derivatives, glsl_type::f16vec4_type),   \
+                NULL);
+
+#define FHF_DERIVATIVE_CONTROL(NAME)                                               \
+   add_function(#NAME,                                                             \
+                _##NAME(derivative_control, glsl_type::float_type),                \
+                _##NAME(derivative_control, glsl_type::vec2_type),                 \
+                _##NAME(derivative_control, glsl_type::vec3_type),                 \
+                _##NAME(derivative_control, glsl_type::vec4_type),                 \
+                _##NAME(half_float_derivative_control, glsl_type::float16_t_type), \
+                _##NAME(half_float_derivative_control, glsl_type::f16vec2_type),   \
+                _##NAME(half_float_derivative_control, glsl_type::f16vec3_type),   \
+                _##NAME(half_float_derivative_control, glsl_type::f16vec4_type),   \
+                NULL);
+
 #define FHF130(NAME)                                 \
    add_function(#NAME,                          \
                 _##NAME(v130, glsl_type::float_type), \
@@ -4981,15 +5017,15 @@ builtin_builder::create_builtins()
                 _texture(ir_txd, v130_desktop_and_clamp, glsl_type::float_type, glsl_type::sampler2DArrayShadow_type, glsl_type::vec4_type, TEX_OFFSET|TEX_CLAMP),
                 NULL);
 
-   F(dFdx)
-   F(dFdy)
-   F(fwidth)
-   F(dFdxCoarse)
-   F(dFdyCoarse)
-   F(fwidthCoarse)
-   F(dFdxFine)
-   F(dFdyFine)
-   F(fwidthFine)
+   FHF_DERIVATIVES(dFdx)
+   FHF_DERIVATIVES(dFdy)
+   FHF_DERIVATIVES(fwidth)
+   FHF_DERIVATIVE_CONTROL(dFdxCoarse)
+   FHF_DERIVATIVE_CONTROL(dFdyCoarse)
+   FHF_DERIVATIVE_CONTROL(fwidthCoarse)
+   FHF_DERIVATIVE_CONTROL(dFdxFine)
+   FHF_DERIVATIVE_CONTROL(dFdyFine)
+   FHF_DERIVATIVE_CONTROL(fwidthFine)
    F(noise1)
    F(noise2)
    F(noise3)
@@ -7832,18 +7868,19 @@ builtin_builder::_textureSamplesIdentical(builtin_available_predicate avail,
    return sig;
 }
 
-UNOP(dFdx, ir_unop_dFdx, derivatives)
-UNOP(dFdxCoarse, ir_unop_dFdx_coarse, derivative_control)
-UNOP(dFdxFine, ir_unop_dFdx_fine, derivative_control)
-UNOP(dFdy, ir_unop_dFdy, derivatives)
-UNOP(dFdyCoarse, ir_unop_dFdy_coarse, derivative_control)
-UNOP(dFdyFine, ir_unop_dFdy_fine, derivative_control)
+UNOPA(dFdx, ir_unop_dFdx)
+UNOPA(dFdxCoarse, ir_unop_dFdx_coarse)
+UNOPA(dFdxFine, ir_unop_dFdx_fine)
+UNOPA(dFdy, ir_unop_dFdy)
+UNOPA(dFdyCoarse, ir_unop_dFdy_coarse)
+UNOPA(dFdyFine, ir_unop_dFdy_fine)
 
 ir_function_signature *
-builtin_builder::_fwidth(const glsl_type *type)
+builtin_builder::_fwidth(builtin_available_predicate avail,
+                         const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivatives, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx, p)), abs(expr(ir_unop_dFdy, p)))));
 
@@ -7851,10 +7888,11 @@ builtin_builder::_fwidth(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_fwidthCoarse(const glsl_type *type)
+builtin_builder::_fwidthCoarse(builtin_available_predicate avail,
+                               const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivative_control, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx_coarse, p)),
                      abs(expr(ir_unop_dFdy_coarse, p)))));
@@ -7863,10 +7901,11 @@ builtin_builder::_fwidthCoarse(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_fwidthFine(const glsl_type *type)
+builtin_builder::_fwidthFine(builtin_available_predicate avail,
+                             const glsl_type *type)
 {
    ir_variable *p = in_var(type, "p");
-   MAKE_SIG(type, derivative_control, 1, p);
+   MAKE_SIG(type, avail, 1, p);
 
    body.emit(ret(add(abs(expr(ir_unop_dFdx_fine, p)),
                      abs(expr(ir_unop_dFdy_fine, p)))));
-- 
GitLab


From 8f5552ace55d9d20a521a8f2fdf31e0201baf0d6 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 27 Jul 2022 14:27:04 +1000
Subject: [PATCH 20/29] glsl: add half float AMD_shader_trinary_minmax
 functions

---
 src/compiler/glsl/builtin_functions.cpp | 114 ++++++++++++++----------
 1 file changed, 69 insertions(+), 45 deletions(-)

diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 90c4f822686e..27a429d11cd1 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -721,6 +721,12 @@ shader_trinary_minmax(const _mesa_glsl_parse_state *state)
    return state->AMD_shader_trinary_minmax_enable;
 }
 
+static bool
+shader_trinary_minmax_half_float(const _mesa_glsl_parse_state *state)
+{
+   return shader_trinary_minmax(state) && gpu_shader_half_float(state);
+}
+
 static bool
 shader_image_load_store(const _mesa_glsl_parse_state *state)
 {
@@ -1320,9 +1326,9 @@ private:
                                       builtin_available_predicate avail,
                                       const glsl_type *type);
 
-   B1(min3)
-   B1(max3)
-   B1(mid3)
+   BA1(min3)
+   BA1(max3)
+   BA1(mid3)
 
    ir_function_signature *_image_prototype(const glsl_type *image_type,
                                            unsigned num_arguments,
@@ -5330,54 +5336,69 @@ builtin_builder::create_builtins()
                 NULL);
 
    add_function("min3",
-                _min3(glsl_type::float_type),
-                _min3(glsl_type::vec2_type),
-                _min3(glsl_type::vec3_type),
-                _min3(glsl_type::vec4_type),
+                _min3(shader_trinary_minmax, glsl_type::float_type),
+                _min3(shader_trinary_minmax, glsl_type::vec2_type),
+                _min3(shader_trinary_minmax, glsl_type::vec3_type),
+                _min3(shader_trinary_minmax, glsl_type::vec4_type),
+
+                _min3(shader_trinary_minmax_half_float, glsl_type::float16_t_type),
+                _min3(shader_trinary_minmax_half_float, glsl_type::f16vec2_type),
+                _min3(shader_trinary_minmax_half_float, glsl_type::f16vec3_type),
+                _min3(shader_trinary_minmax_half_float, glsl_type::f16vec4_type),
 
-                _min3(glsl_type::int_type),
-                _min3(glsl_type::ivec2_type),
-                _min3(glsl_type::ivec3_type),
-                _min3(glsl_type::ivec4_type),
+                _min3(shader_trinary_minmax, glsl_type::int_type),
+                _min3(shader_trinary_minmax, glsl_type::ivec2_type),
+                _min3(shader_trinary_minmax, glsl_type::ivec3_type),
+                _min3(shader_trinary_minmax, glsl_type::ivec4_type),
 
-                _min3(glsl_type::uint_type),
-                _min3(glsl_type::uvec2_type),
-                _min3(glsl_type::uvec3_type),
-                _min3(glsl_type::uvec4_type),
+                _min3(shader_trinary_minmax, glsl_type::uint_type),
+                _min3(shader_trinary_minmax, glsl_type::uvec2_type),
+                _min3(shader_trinary_minmax, glsl_type::uvec3_type),
+                _min3(shader_trinary_minmax, glsl_type::uvec4_type),
                 NULL);
 
    add_function("max3",
-                _max3(glsl_type::float_type),
-                _max3(glsl_type::vec2_type),
-                _max3(glsl_type::vec3_type),
-                _max3(glsl_type::vec4_type),
+                _max3(shader_trinary_minmax, glsl_type::float_type),
+                _max3(shader_trinary_minmax, glsl_type::vec2_type),
+                _max3(shader_trinary_minmax, glsl_type::vec3_type),
+                _max3(shader_trinary_minmax, glsl_type::vec4_type),
 
-                _max3(glsl_type::int_type),
-                _max3(glsl_type::ivec2_type),
-                _max3(glsl_type::ivec3_type),
-                _max3(glsl_type::ivec4_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::float16_t_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::f16vec2_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::f16vec3_type),
+                _max3(shader_trinary_minmax_half_float, glsl_type::f16vec4_type),
 
-                _max3(glsl_type::uint_type),
-                _max3(glsl_type::uvec2_type),
-                _max3(glsl_type::uvec3_type),
-                _max3(glsl_type::uvec4_type),
+                _max3(shader_trinary_minmax, glsl_type::int_type),
+                _max3(shader_trinary_minmax, glsl_type::ivec2_type),
+                _max3(shader_trinary_minmax, glsl_type::ivec3_type),
+                _max3(shader_trinary_minmax, glsl_type::ivec4_type),
+
+                _max3(shader_trinary_minmax, glsl_type::uint_type),
+                _max3(shader_trinary_minmax, glsl_type::uvec2_type),
+                _max3(shader_trinary_minmax, glsl_type::uvec3_type),
+                _max3(shader_trinary_minmax, glsl_type::uvec4_type),
                 NULL);
 
    add_function("mid3",
-                _mid3(glsl_type::float_type),
-                _mid3(glsl_type::vec2_type),
-                _mid3(glsl_type::vec3_type),
-                _mid3(glsl_type::vec4_type),
+                _mid3(shader_trinary_minmax, glsl_type::float_type),
+                _mid3(shader_trinary_minmax, glsl_type::vec2_type),
+                _mid3(shader_trinary_minmax, glsl_type::vec3_type),
+                _mid3(shader_trinary_minmax, glsl_type::vec4_type),
+
+                _mid3(shader_trinary_minmax_half_float, glsl_type::float16_t_type),
+                _mid3(shader_trinary_minmax_half_float, glsl_type::f16vec2_type),
+                _mid3(shader_trinary_minmax_half_float, glsl_type::f16vec3_type),
+                _mid3(shader_trinary_minmax_half_float, glsl_type::f16vec4_type),
 
-                _mid3(glsl_type::int_type),
-                _mid3(glsl_type::ivec2_type),
-                _mid3(glsl_type::ivec3_type),
-                _mid3(glsl_type::ivec4_type),
+                _mid3(shader_trinary_minmax, glsl_type::int_type),
+                _mid3(shader_trinary_minmax, glsl_type::ivec2_type),
+                _mid3(shader_trinary_minmax, glsl_type::ivec3_type),
+                _mid3(shader_trinary_minmax, glsl_type::ivec4_type),
 
-                _mid3(glsl_type::uint_type),
-                _mid3(glsl_type::uvec2_type),
-                _mid3(glsl_type::uvec3_type),
-                _mid3(glsl_type::uvec4_type),
+                _mid3(shader_trinary_minmax, glsl_type::uint_type),
+                _mid3(shader_trinary_minmax, glsl_type::uvec2_type),
+                _mid3(shader_trinary_minmax, glsl_type::uvec3_type),
+                _mid3(shader_trinary_minmax, glsl_type::uvec4_type),
                 NULL);
 
    add_image_functions(true);
@@ -8463,12 +8484,13 @@ builtin_builder::_atomic_op3(const char *intrinsic,
 }
 
 ir_function_signature *
-builtin_builder::_min3(const glsl_type *type)
+builtin_builder::_min3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *min3 = min2(x, min2(y,z));
    body.emit(ret(min3));
@@ -8477,12 +8499,13 @@ builtin_builder::_min3(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_max3(const glsl_type *type)
+builtin_builder::_max3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *max3 = max2(x, max2(y,z));
    body.emit(ret(max3));
@@ -8491,12 +8514,13 @@ builtin_builder::_max3(const glsl_type *type)
 }
 
 ir_function_signature *
-builtin_builder::_mid3(const glsl_type *type)
+builtin_builder::_mid3(builtin_available_predicate avail,
+                       const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
    ir_variable *y = in_var(type, "y");
    ir_variable *z = in_var(type, "z");
-   MAKE_SIG(type, shader_trinary_minmax, 3, x, y, z);
+   MAKE_SIG(type, avail, 3, x, y, z);
 
    ir_expression *mid3 = max2(min2(x, y), max2(min2(x, z), min2(y, z)));
    body.emit(ret(mid3));
-- 
GitLab


From 06fe632e0416e781c974792d6adc501139893cc4 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 29 Jul 2022 10:46:34 +1000
Subject: [PATCH 21/29] glsl: store xfb stride in "machine units"

Previously we stored it as number of 32bit components and converted
it from that when needed. This worked okish for 64bit component
handing, however it will not work for half float support.

So here we switch to the number of 8bit "machine units" as the spec
refers to them.
---
 src/compiler/glsl/gl_nir_link_varyings.c | 20 ++++++++++----------
 src/compiler/glsl/gl_nir_link_xfb.c      |  4 ++--
 src/mesa/main/shader_query.cpp           |  2 +-
 src/mesa/main/shader_types.h             |  6 +++---
 src/mesa/state_tracker/st_program.c      |  2 +-
 5 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_link_varyings.c b/src/compiler/glsl/gl_nir_link_varyings.c
index e91a24212fda..499801c039a5 100644
--- a/src/compiler/glsl/gl_nir_link_varyings.c
+++ b/src/compiler/glsl/gl_nir_link_varyings.c
@@ -474,7 +474,7 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
    unsigned size = xfb_decl->size;
    /* Handle gl_SkipComponents. */
    if (xfb_decl->skip_components) {
-      info->Buffers[buffer].Stride += xfb_decl->skip_components;
+      info->Buffers[buffer].Stride += xfb_decl->skip_components * 4;
       size = xfb_decl->skip_components;
       goto store_varying;
    }
@@ -487,7 +487,7 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
    if (has_xfb_qualifiers) {
       xfb_offset = xfb_decl->offset / 4;
    } else {
-      xfb_offset = info->Buffers[buffer].Stride;
+      xfb_offset = info->Buffers[buffer].Stride / 4;
    }
    info->Varyings[info->NumVarying].Offset = xfb_offset * 4;
 
@@ -637,28 +637,28 @@ xfb_decl_store(struct xfb_decl *xfb_decl, const struct gl_constants *consts,
 
    if (explicit_stride && explicit_stride[buffer]) {
       if (_mesa_gl_datatype_is_64bit(xfb_decl->type) &&
-          info->Buffers[buffer].Stride % 2) {
+          info->Buffers[buffer].Stride % 8) {
          linker_error(prog, "invalid qualifier xfb_stride=%d must be a "
                       "multiple of 8 as its applied to a type that is or "
                       "contains a double.",
-                      info->Buffers[buffer].Stride * 4);
+                      info->Buffers[buffer].Stride);
          return false;
       }
 
-      if (xfb_offset > info->Buffers[buffer].Stride) {
+      if ((xfb_offset * 4) > info->Buffers[buffer].Stride) {
          linker_error(prog, "xfb_offset (%d) overflows xfb_stride (%d) for "
                       "buffer (%d)", xfb_offset * 4,
-                      info->Buffers[buffer].Stride * 4, buffer);
+                      info->Buffers[buffer].Stride, buffer);
          return false;
       }
    } else {
       if (max_member_alignment && has_xfb_qualifiers) {
          max_member_alignment[buffer] = MAX2(max_member_alignment[buffer],
-                                             _mesa_gl_datatype_is_64bit(xfb_decl->type) ? 2 : 1);
-         info->Buffers[buffer].Stride = ALIGN(xfb_offset,
+                                             _mesa_gl_datatype_is_64bit(xfb_decl->type) ? 8 : 4);
+         info->Buffers[buffer].Stride = ALIGN((xfb_offset * 4),
                                               max_member_alignment[buffer]);
       } else {
-         info->Buffers[buffer].Stride = xfb_offset;
+         info->Buffers[buffer].Stride = xfb_offset * 4;
       }
    }
 
@@ -872,7 +872,7 @@ store_tfeedback_info(const struct gl_constants *consts,
             if (prog->TransformFeedback.BufferStride[j]) {
                explicit_stride[j] = true;
                xfb_prog->sh.LinkedTransformFeedback->Buffers[j].Stride =
-                  prog->TransformFeedback.BufferStride[j] / 4;
+                  prog->TransformFeedback.BufferStride[j];
             }
          }
       }
diff --git a/src/compiler/glsl/gl_nir_link_xfb.c b/src/compiler/glsl/gl_nir_link_xfb.c
index 3492ccdc5a97..022e6d5ba632 100644
--- a/src/compiler/glsl/gl_nir_link_xfb.c
+++ b/src/compiler/glsl/gl_nir_link_xfb.c
@@ -185,7 +185,7 @@ gl_nir_link_assign_xfb_resources(const struct gl_constants *consts,
 
    for (unsigned buf = 0; buf < MAX_FEEDBACK_BUFFERS; buf++) {
       if (xfb_info->buffers[buf].stride > 0) {
-         linked_xfb->Buffers[buf].Stride = xfb_info->buffers[buf].stride / 4;
+         linked_xfb->Buffers[buf].Stride = xfb_info->buffers[buf].stride;
          linked_xfb->Buffers[buf].NumVaryings = xfb_info->buffers[buf].varying_count;
          buffers |= 1 << buf;
       }
@@ -208,7 +208,7 @@ gl_to_nir_xfb_info(struct gl_transform_feedback_info *info, void *mem_ctx)
    xfb->output_count = info->NumOutputs;
 
    for (unsigned i = 0; i < MAX_FEEDBACK_BUFFERS; i++) {
-      xfb->buffers[i].stride = info->Buffers[i].Stride * 4;
+      xfb->buffers[i].stride = info->Buffers[i].Stride;
       xfb->buffers[i].varying_count = info->Buffers[i].NumVaryings;
       xfb->buffer_to_stream[i] = info->Buffers[i].Stream;
    }
diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index 37173696074b..2e74db849c1f 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -1675,7 +1675,7 @@ _mesa_program_resource_prop(struct gl_shader_program *shProg,
       return 1;
    case GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE:
       VALIDATE_TYPE(GL_TRANSFORM_FEEDBACK_BUFFER);
-      *val = RESOURCE_XFB(res)->Stride * 4;
+      *val = RESOURCE_XFB(res)->Stride;
       return 1;
 
    default:
diff --git a/src/mesa/main/shader_types.h b/src/mesa/main/shader_types.h
index 364af97282f1..5ffe33d319a4 100644
--- a/src/mesa/main/shader_types.h
+++ b/src/mesa/main/shader_types.h
@@ -769,9 +769,9 @@ struct gl_transform_feedback_buffer
    uint32_t NumVaryings;
 
    /**
-    * Total number of components stored in each buffer.  This may be used by
-    * hardware back-ends to determine the correct stride when interleaving
-    * multiple transform feedback outputs in the same buffer.
+    * Total number of basic machine units stored in each buffer.  This may
+    * be used by hardware back-ends to determine the correct stride when
+    * interleaving multiple transform feedback outputs in the same buffer.
     */
    uint32_t Stride;
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index ff784a448035..ef71f020d713 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -485,7 +485,7 @@ st_translate_stream_output_info(struct gl_program *prog)
    }
 
    for (unsigned i = 0; i < PIPE_MAX_SO_BUFFERS; i++) {
-      so_info->stride[i] = info->Buffers[i].Stride;
+      so_info->stride[i] = info->Buffers[i].Stride / 4;
    }
    so_info->num_outputs = info->NumOutputs;
 }
-- 
GitLab


From b2d670d497e971df33f1133726ae53e82df4730d Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 10:24:24 +1000
Subject: [PATCH 22/29] amd/llvm: fix load ubo for 16/8 bit loads

This effectively reverts ed351b9a71ec which does not work as
intended.
---
 src/amd/llvm/ac_nir_to_llvm.c | 39 ++++++++++++++++++-----------------
 1 file changed, 20 insertions(+), 19 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index a18da4f13e2a..3909267dc2f6 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -2310,31 +2310,32 @@ static LLVMValueRef visit_load_ubo_buffer(struct ac_nir_context *ctx, nir_intrin
    if (ctx->abi->load_ubo)
       rsrc = ctx->abi->load_ubo(ctx->abi, rsrc);
 
-   /* Convert to a scalar 32-bit load. */
    if (instr->dest.ssa.bit_size == 64)
       num_components *= 2;
-   else if (instr->dest.ssa.bit_size == 16)
-      num_components = DIV_ROUND_UP(num_components, 2);
-   else if (instr->dest.ssa.bit_size == 8)
-      num_components = DIV_ROUND_UP(num_components, 4);
 
-   ret =
-      ac_build_buffer_load(&ctx->ac, rsrc, num_components, NULL, offset, NULL,
-                           ctx->ac.f32, 0, true, true);
+   if (instr->dest.ssa.bit_size == 16 || instr->dest.ssa.bit_size == 8) {
+      unsigned load_bytes = instr->dest.ssa.bit_size / 8;
+      LLVMValueRef *const results = alloca(num_components * sizeof(LLVMValueRef));
+      for (unsigned i = 0; i < num_components; ++i) {
+         LLVMValueRef immoffset = LLVMConstInt(ctx->ac.i32, load_bytes * i, 0);
 
-   /* Convert to the original type. */
-   if (instr->dest.ssa.bit_size == 64) {
-      ret = LLVMBuildBitCast(ctx->ac.builder, ret,
-                             LLVMVectorType(ctx->ac.i64, num_components / 2), "");
-   } else if (instr->dest.ssa.bit_size == 16) {
-      ret = LLVMBuildBitCast(ctx->ac.builder, ret,
-                             LLVMVectorType(ctx->ac.i16, num_components * 2), "");
-   } else if (instr->dest.ssa.bit_size == 8) {
-      ret = LLVMBuildBitCast(ctx->ac.builder, ret,
-                             LLVMVectorType(ctx->ac.i8, num_components * 4), "");
+         if (load_bytes == 1) {
+            results[i] =
+               ac_build_buffer_load_byte(&ctx->ac, rsrc, offset, immoffset, 0);
+         } else {
+            assert(load_bytes == 2);
+            results[i] =
+               ac_build_buffer_load_short(&ctx->ac, rsrc, offset, immoffset, 0);
+         }
+      }
+      ret = ac_build_gather_values(&ctx->ac, results, num_components);
+   } else {
+      ret =
+         ac_build_buffer_load(&ctx->ac, rsrc, num_components, NULL, offset, NULL, 0, 0, true, true);
+
+      ret = ac_trim_vector(&ctx->ac, ret, num_components);
    }
 
-   ret = ac_trim_vector(&ctx->ac, ret, instr->num_components);
    ret = LLVMBuildBitCast(ctx->ac.builder, ret, get_def_type(ctx, &instr->dest.ssa), "");
 
    return exit_waterfall(ctx, &wctx, ret);
-- 
GitLab


From 558e6f1f05f085f1ddbb817d3d16f77b4d8ae045 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:08:44 +1000
Subject: [PATCH 23/29] glsl: fix copy and pasted typo

Fixes: 30b548fc6258 ("compiler/types: Add a contains_64bit helper")
---
 src/compiler/glsl_types.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index ecd2fb88def4..40002e830b7c 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -832,7 +832,7 @@ public:
 
    /**
     * Query whether or not type is a 64-bit type, or for struct, interface and
-    * array types, contains a double type.
+    * array types, contains a 64-bit type.
     */
    bool contains_64bit() const;
 
-- 
GitLab


From 303de224fe22798ed12d9a1aa541a461fadbfc77 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 14:07:11 +1000
Subject: [PATCH 24/29] compiler/types: Add a contains_32bit helper

---
 src/compiler/glsl_types.cpp | 16 ++++++++++++++++
 src/compiler/glsl_types.h   |  6 ++++++
 2 files changed, 22 insertions(+)

diff --git a/src/compiler/glsl_types.cpp b/src/compiler/glsl_types.cpp
index 46d99438d764..c4787b02475e 100644
--- a/src/compiler/glsl_types.cpp
+++ b/src/compiler/glsl_types.cpp
@@ -259,6 +259,22 @@ glsl_type::contains_integer() const
    }
 }
 
+bool
+glsl_type::contains_32bit() const
+{
+   if (this->is_array()) {
+      return this->fields.array->contains_32bit();
+   } else if (this->is_struct() || this->is_interface()) {
+      for (unsigned int i = 0; i < this->length; i++) {
+         if (this->fields.structure[i].type->contains_32bit())
+            return true;
+      }
+      return false;
+   } else {
+      return this->is_32bit();
+   }
+}
+
 bool
 glsl_type::contains_double() const
 {
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 40002e830b7c..1bda0a174f74 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -824,6 +824,12 @@ public:
     */
    bool contains_integer() const;
 
+   /**
+    * Query whether or not type is a 32-bit type, or for struct, interface and
+    * array types, contains a 32-bit type.
+    */
+   bool contains_32bit() const;
+
    /**
     * Query whether or not type is a double type, or for struct, interface and
     * array types, contains a double type.
-- 
GitLab


From fc22681e13f0857993c1b9f8caef3467209fb6ad Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:30:29 +1000
Subject: [PATCH 25/29] compiler/types: Add a xfb_component_size() helper

This also includes support for returning the size of half float
components.
---
 src/compiler/glsl_types.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 1bda0a174f74..2838490f7de2 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -1101,6 +1101,13 @@ public:
       return glsl_base_type_bit_size(this->base_type);
    }
 
+   /**
+    * Return the xfb component size in bytes for this type.
+    */
+   unsigned xfb_component_size() const
+   {
+      return this->contains_double() ? 8 : (this->contains_32bit() ? 4 : 2);
+   }
 
    /**
     * Query whether or not a type is an atomic_uint.
-- 
GitLab


From 4c874ec0b668ebf538cdbb699acf7f63a89676f8 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 5 Aug 2022 13:33:29 +1000
Subject: [PATCH 26/29] glsl: make use of xfb_component_size() helper

---
 src/compiler/glsl/ast_to_hir.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 441123ca60f4..b4f680b58215 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -2913,7 +2913,7 @@ validate_xfb_offset_qualifier(YYLTYPE *loc,
           * we apply the component size rules at the member level.
           */
          if (xfb_offset == -1)
-            component_size = member_t->contains_double() ? 8 : 4;
+            component_size = member_t->xfb_component_size();
 
          int xfb_offset = t_without_array->fields.structure[i].offset;
          validate_xfb_offset_qualifier(loc, state, xfb_offset, member_t,
@@ -3846,7 +3846,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
 
    if (qual->flags.q.explicit_xfb_offset) {
       unsigned qual_xfb_offset;
-      unsigned component_size = var->type->contains_double() ? 8 : 4;
+      unsigned component_size = var->type->xfb_component_size();
 
       if (process_qualifier_constant(state, loc, "xfb_offset",
                                      qual->offset, &qual_xfb_offset) &&
@@ -8356,7 +8356,7 @@ ast_interface_block::hir(exec_list *instructions,
                                            GLSL_MATRIX_LAYOUT_ROW_MAJOR,
                                         this->block_name);
 
-   unsigned component_size = block_type->contains_double() ? 8 : 4;
+   unsigned component_size = block_type->xfb_component_size();
    int xfb_offset =
       layout.flags.q.explicit_xfb_offset ? (int) qual_xfb_offset : -1;
    validate_xfb_offset_qualifier(&loc, state, xfb_offset, block_type,
-- 
GitLab


From 84e6ae2a635609c900693709b9db37862fec635d Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 12:13:36 +1100
Subject: [PATCH 27/29] glsl: add f2f16() helper to ir_builder

---
 src/compiler/glsl/ir_builder.cpp | 6 ++++++
 src/compiler/glsl/ir_builder.h   | 2 ++
 2 files changed, 8 insertions(+)

diff --git a/src/compiler/glsl/ir_builder.cpp b/src/compiler/glsl/ir_builder.cpp
index 770ba692efde..6894a1224b54 100644
--- a/src/compiler/glsl/ir_builder.cpp
+++ b/src/compiler/glsl/ir_builder.cpp
@@ -553,6 +553,12 @@ interpolate_at_sample(operand a, operand b)
    return expr(ir_binop_interpolate_at_sample, a, b);
 }
 
+ir_expression *
+f2f16(operand a)
+{
+   return expr(ir_unop_f2f16, a);
+}
+
 ir_expression *
 f2d(operand a)
 {
diff --git a/src/compiler/glsl/ir_builder.h b/src/compiler/glsl/ir_builder.h
index 2a1d3643e568..220494a60844 100644
--- a/src/compiler/glsl/ir_builder.h
+++ b/src/compiler/glsl/ir_builder.h
@@ -189,6 +189,8 @@ ir_expression *i2b(operand a);
 ir_expression *f2b(operand a);
 ir_expression *b2f(operand a);
 
+ir_expression *f2f16(operand a);
+
 ir_expression *f2d(operand a);
 ir_expression *i2d(operand a);
 ir_expression *u2d(operand a);
-- 
GitLab


From 8966dff9751950680d6b8b2b6c02ae0585acf1a8 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 15:35:09 +1100
Subject: [PATCH 28/29] gallium: add PIPE_CAP_FP16 for
 AMD_gpu_shader_half_float

---
 docs/gallium/screen.rst                | 1 +
 src/gallium/auxiliary/util/u_screen.c  | 1 +
 src/gallium/include/pipe/p_defines.h   | 1 +
 src/mesa/state_tracker/st_extensions.c | 1 +
 4 files changed, 4 insertions(+)

diff --git a/docs/gallium/screen.rst b/docs/gallium/screen.rst
index fc193b86d7ac..16bd7d9c39e8 100644
--- a/docs/gallium/screen.rst
+++ b/docs/gallium/screen.rst
@@ -421,6 +421,7 @@ The integer capabilities:
 * ``PIPE_CAP_LEGACY_MATH_RULES``: Whether NIR shaders support the
   ``shader_info.use_legacy_math_rules`` flag (see documentation there), and
   TGSI shaders support the corresponding ``TGSI_PROPERTY_LEGACY_MATH_RULES``.
+* ``PIPE_CAP_FP16``: Whether 16-bit float operations are supported.
 * ``PIPE_CAP_DOUBLES``: Whether double precision floating-point operations
   are supported.
 * ``PIPE_CAP_INT64``: Whether 64-bit integer operations are supported.
diff --git a/src/gallium/auxiliary/util/u_screen.c b/src/gallium/auxiliary/util/u_screen.c
index 4cacc42fbdb3..a428ee8174b0 100644
--- a/src/gallium/auxiliary/util/u_screen.c
+++ b/src/gallium/auxiliary/util/u_screen.c
@@ -314,6 +314,7 @@ u_pipe_screen_get_param_defaults(struct pipe_screen *pscreen,
    case PIPE_CAP_FBFETCH_ZS:
    case PIPE_CAP_BLEND_EQUATION_ADVANCED:
    case PIPE_CAP_LEGACY_MATH_RULES:
+   case PIPE_CAP_FP16:
    case PIPE_CAP_DOUBLES:
    case PIPE_CAP_INT64:
    case PIPE_CAP_INT64_DIVMOD:
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 343487589f7d..7a2bcd19dda5 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -888,6 +888,7 @@ enum pipe_cap
    PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS,
    PIPE_CAP_FBFETCH,
    PIPE_CAP_LEGACY_MATH_RULES,
+   PIPE_CAP_FP16,
    PIPE_CAP_DOUBLES,
    PIPE_CAP_INT64,
    PIPE_CAP_INT64_DIVMOD,
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 7e22cec78958..2daec7a9a7b1 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -849,6 +849,7 @@ void st_init_extensions(struct pipe_screen *screen,
 
       { o(AMD_depth_clamp_separate),         PIPE_CAP_DEPTH_CLIP_DISABLE_SEPARATE      },
       { o(AMD_framebuffer_multisample_advanced), PIPE_CAP_FRAMEBUFFER_MSAA_CONSTRAINTS },
+      { o(AMD_gpu_shader_half_float),        PIPE_CAP_FP16                             },
       { o(AMD_pinned_memory),                PIPE_CAP_RESOURCE_FROM_USER_MEMORY        },
       { o(ATI_meminfo),                      PIPE_CAP_QUERY_MEMORY_INFO                },
       { o(AMD_seamless_cubemap_per_texture), PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE    },
-- 
GitLab


From c98f2523a447da27f459fd8bd3c79c48f961f49c Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 8 Nov 2022 15:51:34 +1100
Subject: [PATCH 29/29] radeonsi: enable AMD_gpu_shader_half_float

---
 src/gallium/drivers/radeonsi/si_get.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 7256ed2c1aac..9a0c49c803f4 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -167,6 +167,9 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_TEXTURE_MULTISAMPLE:
       return 1;
 
+   case PIPE_CAP_FP16:
+      return sscreen->info.gfx_level >= GFX8;
+
    case PIPE_CAP_TEXTURE_TRANSFER_MODES:
       return PIPE_TEXTURE_TRANSFER_BLIT;
 
-- 
GitLab

