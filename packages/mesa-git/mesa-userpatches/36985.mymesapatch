From 7968d183bb2b093ee279746ec4e44926e1a15340 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Mon, 25 Aug 2025 17:53:20 +0200
Subject: [PATCH 1/5] vulkan: Stop combining subpass dependencies

Rather than OR-ing all subpass dependencies together in the Vulkan layer,
pass an array of barriers down to the drivers and allow them to do the
OR-ing if needed.
---
 src/vulkan/runtime/vk_render_pass.c | 93 +++++++++++++++++------------
 1 file changed, 54 insertions(+), 39 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 0cc3a1884a806..156ff8abbda12 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1,5 +1,6 @@
 /*
  * Copyright © 2020 Valve Corporation
+ * Copyright © 2025 Arm Ltd
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -2049,15 +2050,15 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       }
    }
 
-   /* Next, handle any barriers we need.  This may include a general
-    * VkMemoryBarrier for subpass dependencies and it may include some
+   /* Next, handle any barriers we need.  This may include general
+    * VkMemoryBarriers for subpass dependencies and it may include some
     * number of VkImageMemoryBarriers for layout transitions.
     */
 
-   bool needs_mem_barrier = false;
-   VkMemoryBarrier2 mem_barrier = {
-      .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
-   };
+   /* At most all dependencies will need a barrier, and we might have an
+    * implicit one. */
+   STACK_ARRAY(VkMemoryBarrier2, mem_barriers, pass->dependency_count + 1);
+   uint32_t mem_barrier_count = 0;
    for (uint32_t d = 0; d < pass->dependency_count; d++) {
       const struct vk_subpass_dependency *dep = &pass->dependencies[d];
       if (dep->dst_subpass != subpass_idx)
@@ -2098,11 +2099,13 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
             continue;
       }
 
-      needs_mem_barrier = true;
-      mem_barrier.srcStageMask |= dep->src_stage_mask;
-      mem_barrier.srcAccessMask |= dep->src_access_mask;
-      mem_barrier.dstStageMask |= dep->dst_stage_mask;
-      mem_barrier.dstAccessMask |= dep->dst_access_mask;
+      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
+      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
+      mem_barrier->pNext = NULL;
+      mem_barrier->srcStageMask = dep->src_stage_mask;
+      mem_barrier->srcAccessMask = dep->src_access_mask;
+      mem_barrier->dstStageMask = dep->dst_stage_mask;
+      mem_barrier->dstAccessMask = dep->dst_access_mask;
    }
 
    if (subpass_idx == 0) {
@@ -2137,13 +2140,17 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
        * If this is ever a perf problem, we can re-evaluate and do something
        * more intellegent at that time.
        */
-      needs_mem_barrier = true;
-      mem_barrier.dstStageMask |= VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-      mem_barrier.dstAccessMask |= VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
-                                   VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
+      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
+      mem_barrier->pNext = NULL;
+      mem_barrier->srcStageMask = VK_PIPELINE_STAGE_2_NONE;
+      mem_barrier->srcAccessMask = 0;
+      mem_barrier->dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
+      mem_barrier->dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
+                                   VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
+                                   VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
+                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
    }
 
    uint32_t max_image_barrier_count = 0;
@@ -2190,15 +2197,14 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    }
    assert(image_barrier_count <= max_image_barrier_count);
 
-   if (needs_mem_barrier || image_barrier_count > 0) {
+   if (mem_barrier_count > 0 || image_barrier_count > 0) {
       const VkDependencyInfo dependency_info = {
          .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
          .dependencyFlags = 0,
-         .memoryBarrierCount = needs_mem_barrier ? 1 : 0,
-         .pMemoryBarriers = needs_mem_barrier ? &mem_barrier : NULL,
+         .memoryBarrierCount = mem_barrier_count,
+         .pMemoryBarriers = mem_barrier_count > 0 ? mem_barriers : NULL,
          .imageMemoryBarrierCount = image_barrier_count,
-         .pImageMemoryBarriers = image_barrier_count > 0 ?
-                                 image_barriers : NULL,
+         .pImageMemoryBarriers = image_barrier_count > 0 ? image_barriers : NULL,
       };
       cmd_buffer->runtime_rp_barrier = true;
       disp->CmdPipelineBarrier2(vk_command_buffer_to_handle(cmd_buffer),
@@ -2207,6 +2213,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    }
 
    STACK_ARRAY_FINISH(image_barriers);
+   STACK_ARRAY_FINISH(mem_barriers);
 
    /* Next, handle any VK_ATTACHMENT_LOAD_OP_CLEAR that we couldn't handle
     * directly by emitting a quick vkCmdBegin/EndRendering to do the load.
@@ -2353,10 +2360,10 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
 
    disp->CmdEndRendering(vk_command_buffer_to_handle(cmd_buffer));
 
-   bool needs_mem_barrier = false;
-   VkMemoryBarrier2 mem_barrier = {
-      .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
-   };
+   /* At most all dependencies will need a barrier, and we might have an
+    * implicit one. */
+   STACK_ARRAY(VkMemoryBarrier2, mem_barriers, pass->dependency_count + 1);
+   uint32_t mem_barrier_count = 0;
    for (uint32_t d = 0; d < pass->dependency_count; d++) {
       const struct vk_subpass_dependency *dep = &pass->dependencies[d];
       if (dep->src_subpass != subpass_idx)
@@ -2365,11 +2372,13 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
       if (dep->dst_subpass != VK_SUBPASS_EXTERNAL)
          continue;
 
-      needs_mem_barrier = true;
-      mem_barrier.srcStageMask |= dep->src_stage_mask;
-      mem_barrier.srcAccessMask |= dep->src_access_mask;
-      mem_barrier.dstStageMask |= dep->dst_stage_mask;
-      mem_barrier.dstAccessMask |= dep->dst_access_mask;
+      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
+      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
+      mem_barrier->pNext = NULL;
+      mem_barrier->srcStageMask = dep->src_stage_mask;
+      mem_barrier->srcAccessMask = dep->src_access_mask;
+      mem_barrier->dstStageMask = dep->dst_stage_mask;
+      mem_barrier->dstAccessMask = dep->dst_access_mask;
    }
 
    if (subpass_idx == pass->subpass_count - 1) {
@@ -2401,24 +2410,30 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
        * If this is ever a perf problem, we can re-evaluate and do something
        * more intellegent at that time.
        */
-      needs_mem_barrier = true;
-      mem_barrier.srcStageMask |= VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-      mem_barrier.srcAccessMask |= VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
-                                   VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
+      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
+      mem_barrier->pNext = NULL;
+      mem_barrier->srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
+      mem_barrier->srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+      mem_barrier->dstStageMask = VK_PIPELINE_STAGE_2_NONE;
+      mem_barrier->dstAccessMask = 0;
    }
 
-   if (needs_mem_barrier) {
+   if (mem_barrier_count > 0) {
       const VkDependencyInfo dependency_info = {
          .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
          .dependencyFlags = 0,
-         .memoryBarrierCount = 1,
-         .pMemoryBarriers = &mem_barrier,
+         .memoryBarrierCount = mem_barrier_count,
+         .pMemoryBarriers = mem_barriers,
       };
       cmd_buffer->runtime_rp_barrier = true;
       disp->CmdPipelineBarrier2(vk_command_buffer_to_handle(cmd_buffer),
                                 &dependency_info);
       cmd_buffer->runtime_rp_barrier = false;
    }
+
+   STACK_ARRAY_FINISH(mem_barriers);
 }
 
 VKAPI_ATTR void VKAPI_CALL
-- 
GitLab


From d8bff7f007fd165a78cc3e67b3516430dd6e0d1a Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Mon, 25 Aug 2025 17:28:26 +0200
Subject: [PATCH 2/5] vulkan: Find first_subpass when creating renderpass

Like last_subpass, add a per-view mask of what subpass first uses an
attachment. This is required for optimizing out some barriers later.

Note that this requires us to do another loop over the subpasses.
---
 src/vulkan/runtime/vk_render_pass.c | 45 +++++++++++++++++++++++++++++
 src/vulkan/runtime/vk_render_pass.h |  5 ++--
 2 files changed, 48 insertions(+), 2 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 156ff8abbda12..bc45e520d63f1 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -803,6 +803,51 @@ vk_common_CreateRenderPass2(VkDevice _device,
    assert(next_subpass_color_samples ==
           subpass_color_samples + subpass_color_attachment_count);
 
+   /* Walk forwards over the subpasses to compute first_subpass masks for all
+    * attachments.
+    */
+   for (uint32_t s = 0; s < pCreateInfo->subpassCount; s++) {
+      struct vk_subpass *subpass = &pass->subpasses[s];
+
+      /* First, compute first_subpass for all the attachments */
+      for (uint32_t a = 0; a < subpass->attachment_count; a++) {
+         struct vk_subpass_attachment *att = &subpass->attachments[a];
+         if (att->attachment == VK_ATTACHMENT_UNUSED)
+            continue;
+
+         assert(att->attachment < pass->attachment_count);
+         const struct vk_render_pass_attachment *pass_att =
+            &pass->attachments[att->attachment];
+
+         att->first_subpass = subpass->view_mask & ~pass_att->view_mask;
+      }
+
+      /* Then compute pass_att->view_mask.  We do the two separately so that
+       * we end up with the right first_subpass even if the same attachment is
+       * used twice within a subpass.
+       */
+      for (uint32_t a = 0; a < subpass->attachment_count; a++) {
+         const struct vk_subpass_attachment *att = &subpass->attachments[a];
+         if (att->attachment == VK_ATTACHMENT_UNUSED)
+            continue;
+
+         assert(att->attachment < pass->attachment_count);
+         struct vk_render_pass_attachment *pass_att =
+            &pass->attachments[att->attachment];
+
+         pass_att->view_mask |= subpass->view_mask;
+      }
+   }
+
+   /* Zero the view-masks, as we'll need to fill them again when looking for
+    * last_subpass
+    */
+   for (uint32_t a = 0; a < pass->attachment_count; a++) {
+      struct vk_render_pass_attachment *pass_att =
+         &pass->attachments[a];
+      pass_att->view_mask = 0;
+   }
+
    /* Walk backwards over the subpasses to compute view masks and
     * last_subpass masks for all attachments.
     */
diff --git a/src/vulkan/runtime/vk_render_pass.h b/src/vulkan/runtime/vk_render_pass.h
index 4cac6f33ae87f..4dd3740b381fa 100644
--- a/src/vulkan/runtime/vk_render_pass.h
+++ b/src/vulkan/runtime/vk_render_pass.h
@@ -99,12 +99,13 @@ struct vk_subpass_attachment {
     */
    VkImageLayout stencil_layout;
 
-   /** A per-view mask for if this is the last use of this attachment
+   /** A per-view mask for if this is the first or last use of this attachment
     *
     * If the same render pass attachment is used multiple ways within a
-    * subpass, corresponding last_subpass bits will be set in all of them.
+    * subpass, corresponding first/last_subpass bits will be set in all of them.
     * For the non-multiview case, only the first bit is used.
     */
+   uint32_t first_subpass;
    uint32_t last_subpass;
 
    /** Resolve attachment, if any */
-- 
GitLab


From c4aa00ad0c2300e4037c8d5b85e3a5da643a4408 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Mon, 25 Aug 2025 15:22:24 +0200
Subject: [PATCH 3/5] vulkan: Optimize implicit begin_subpass barrier

Rather than adding an implicit barrier on the first subpass
unconditionally, track in what subpasses attachments are used for the
first time and only add dependencies if none exist and there might be an
image transition.
---
 src/vulkan/runtime/vk_render_pass.c | 122 +++++++++++++++-------------
 1 file changed, 64 insertions(+), 58 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index bc45e520d63f1..a4240ec3b25e4 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1409,7 +1409,7 @@ stage_access_for_layout(VkImageLayout layout, VkImageAspectFlags aspects)
    };
 }
 
-static void
+static bool
 transition_image_range(const struct vk_image_view *image_view,
                        VkImageSubresourceRange range,
                        VkImageLayout old_layout,
@@ -1421,6 +1421,7 @@ transition_image_range(const struct vk_image_view *image_view,
                        uint32_t max_barrier_count,
                        VkImageMemoryBarrier2 *barriers)
 {
+   bool has_layout_transition = false;
    VkImageAspectFlags aspects_left = range.aspectMask;
    while (aspects_left) {
       range.aspectMask = aspects_left;
@@ -1468,10 +1469,12 @@ transition_image_range(const struct vk_image_view *image_view,
             .image = vk_image_to_handle(image_view->image),
             .subresourceRange = range,
          };
+         has_layout_transition = true;
       }
 
       aspects_left &= ~range.aspectMask;
    }
+   return has_layout_transition;
 }
 
 static bool
@@ -1605,7 +1608,7 @@ vk_command_buffer_set_attachment_layout(struct vk_command_buffer *cmd_buffer,
    }
 }
 
-static void
+static bool
 transition_attachment(struct vk_command_buffer *cmd_buffer,
                       uint32_t att_idx,
                       uint32_t view_mask,
@@ -1622,6 +1625,8 @@ transition_attachment(struct vk_command_buffer *cmd_buffer,
    struct vk_attachment_state *att_state = &cmd_buffer->attachments[att_idx];
    const struct vk_image_view *image_view = att_state->image_view;
 
+   bool has_layout_transition = false;
+
    /* 3D is stupidly special.  From the Vulkan 1.3.204 spec:
     *
     *    "When the VkImageSubresourceRange structure is used to select a
@@ -1690,15 +1695,17 @@ transition_attachment(struct vk_command_buffer *cmd_buffer,
          range.layerCount = framebuffer->layers;
       }
 
-      transition_image_range(image_view, range,
-                             att_view_state->layout, layout,
-                             att_view_state->stencil_layout, stencil_layout,
-                             att_view_state->sample_locations,
-                             barrier_count, max_barrier_count, barriers);
+      has_layout_transition |=
+         transition_image_range(image_view, range,
+                                att_view_state->layout, layout,
+                                att_view_state->stencil_layout, stencil_layout,
+                                att_view_state->sample_locations,
+                                barrier_count, max_barrier_count, barriers);
 
       att_view_state->layout = layout;
       att_view_state->stencil_layout = stencil_layout;
    }
+   return has_layout_transition;
 }
 
 static void
@@ -2104,6 +2111,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
     * implicit one. */
    STACK_ARRAY(VkMemoryBarrier2, mem_barriers, pass->dependency_count + 1);
    uint32_t mem_barrier_count = 0;
+   bool external_dependency = false;
    for (uint32_t d = 0; d < pass->dependency_count; d++) {
       const struct vk_subpass_dependency *dep = &pass->dependencies[d];
       if (dep->dst_subpass != subpass_idx)
@@ -2151,51 +2159,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       mem_barrier->srcAccessMask = dep->src_access_mask;
       mem_barrier->dstStageMask = dep->dst_stage_mask;
       mem_barrier->dstAccessMask = dep->dst_access_mask;
-   }
-
-   if (subpass_idx == 0) {
-      /* From the Vulkan 1.3.232 spec:
-       *
-       *    "If there is no subpass dependency from VK_SUBPASS_EXTERNAL to the
-       *    first subpass that uses an attachment, then an implicit subpass
-       *    dependency exists from VK_SUBPASS_EXTERNAL to the first subpass it
-       *    is used in. The implicit subpass dependency only exists if there
-       *    exists an automatic layout transition away from initialLayout. The
-       *    subpass dependency operates as if defined with the following
-       *    parameters:
-       *
-       *    VkSubpassDependency implicitDependency = {
-       *        .srcSubpass = VK_SUBPASS_EXTERNAL;
-       *        .dstSubpass = firstSubpass; // First subpass attachment is used in
-       *        .srcStageMask = VK_PIPELINE_STAGE_NONE;
-       *        .dstStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-       *        .srcAccessMask = 0;
-       *        .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
-       *                         VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
-       *                         VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
-       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
-       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
-       *        .dependencyFlags = 0;
-       *    };"
-       *
-       * We could track individual subpasses and attachments and views to make
-       * sure we only insert this barrier when it's absolutely necessary.
-       * However, this is only going to happen for the first subpass and
-       * you're probably going to take a stall in BeginRenderPass() anyway.
-       * If this is ever a perf problem, we can re-evaluate and do something
-       * more intellegent at that time.
-       */
-      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
-      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
-      mem_barrier->pNext = NULL;
-      mem_barrier->srcStageMask = VK_PIPELINE_STAGE_2_NONE;
-      mem_barrier->srcAccessMask = 0;
-      mem_barrier->dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
-      mem_barrier->dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
-                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+      external_dependency |= (dep->src_subpass == VK_SUBPASS_EXTERNAL);
    }
 
    uint32_t max_image_barrier_count = 0;
@@ -2215,6 +2179,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       max_image_barrier_count += util_bitcount(subpass->view_mask);
    STACK_ARRAY(VkImageMemoryBarrier2, image_barriers, max_image_barrier_count);
    uint32_t image_barrier_count = 0;
+   bool has_layout_transition = false;
 
    for (uint32_t a = 0; a < subpass->attachment_count; a++) {
       const struct vk_subpass_attachment *sp_att = &subpass->attachments[a];
@@ -2224,12 +2189,15 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       /* If we're using an initial layout, the attachment will already be
        * marked as transitioned and this will be a no-op.
        */
-      transition_attachment(cmd_buffer, sp_att->attachment,
-                            subpass->view_mask,
-                            sp_att->layout, sp_att->stencil_layout,
-                            &image_barrier_count,
-                            max_image_barrier_count,
-                            image_barriers);
+      bool transition =
+         transition_attachment(cmd_buffer, sp_att->attachment,
+                               subpass->view_mask,
+                               sp_att->layout, sp_att->stencil_layout,
+                               &image_barrier_count,
+                               max_image_barrier_count,
+                               image_barriers);
+
+      has_layout_transition |= (sp_att->first_subpass && transition);
    }
    if (pass->fragment_density_map.attachment != VK_ATTACHMENT_UNUSED) {
       transition_attachment(cmd_buffer, pass->fragment_density_map.attachment,
@@ -2242,6 +2210,44 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    }
    assert(image_barrier_count <= max_image_barrier_count);
 
+   if (has_layout_transition && !external_dependency) {
+      /* From the Vulkan 1.3.232 spec:
+       *
+       *    "If there is no subpass dependency from VK_SUBPASS_EXTERNAL to the
+       *    first subpass that uses an attachment, then an implicit subpass
+       *    dependency exists from VK_SUBPASS_EXTERNAL to the first subpass it
+       *    is used in. The implicit subpass dependency only exists if there
+       *    exists an automatic layout transition away from initialLayout. The
+       *    subpass dependency operates as if defined with the following
+       *    parameters:
+       *
+       *    VkSubpassDependency implicitDependency = {
+       *        .srcSubpass = VK_SUBPASS_EXTERNAL;
+       *        .dstSubpass = firstSubpass; // First subpass attachment is used in
+       *        .srcStageMask = VK_PIPELINE_STAGE_NONE;
+       *        .dstStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+       *        .srcAccessMask = 0;
+       *        .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
+       *                         VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
+       *                         VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
+       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
+       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+       *        .dependencyFlags = 0;
+       *    };"
+       */
+      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
+      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
+      mem_barrier->pNext = NULL;
+      mem_barrier->srcStageMask = VK_PIPELINE_STAGE_2_NONE;
+      mem_barrier->srcAccessMask = 0;
+      mem_barrier->dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
+      mem_barrier->dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
+                                   VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
+                                   VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
+                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+   }
+
    if (mem_barrier_count > 0 || image_barrier_count > 0) {
       const VkDependencyInfo dependency_info = {
          .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
-- 
GitLab


From b442a193f99d2a99dc51a5b3fc19d8452407a58e Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Tue, 26 Aug 2025 13:37:12 +0200
Subject: [PATCH 4/5] vulkan: Optimize implicit end_subpass barrier

Rather than adding an implicit barrier on the last subpass
unconditionally, track in what subpasses attachments are used for the
last time and only add dependencies if none exist and there might be an
image transition.
---
 src/vulkan/runtime/vk_render_pass.c | 72 ++++++++++++++++++++++-------
 1 file changed, 56 insertions(+), 16 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index a4240ec3b25e4..e48de6a9ac265 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -2400,12 +2400,42 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    STACK_ARRAY_FINISH(color_attachment_initial_layouts);
 }
 
+static bool
+transition_needed(
+   struct vk_command_buffer *cmd_buffer,
+   uint32_t att_idx,
+   uint32_t view_mask,
+   VkImageLayout layout,
+   VkImageLayout stencil_layout)
+{
+   bool transition = false;
+   struct vk_attachment_state *att_state = &cmd_buffer->attachments[att_idx];
+   const struct vk_image_view *image_view = att_state->image_view;
+
+   /* 3D is stupidly special.  See transition_attachment() */
+   if (image_view->image->image_type == VK_IMAGE_TYPE_3D)
+      view_mask = 1;
+
+   u_foreach_bit (view, view_mask) {
+      assert(view >= 0 && view < MESA_VK_MAX_MULTIVIEW_VIEW_COUNT);
+      struct vk_attachment_view_state *att_view_state = &att_state->views[view];
+
+      /* Check to see if we need a transition */
+      transition |= (att_view_state->layout != layout ||
+                     att_view_state->stencil_layout != stencil_layout);
+   }
+
+   return transition;
+}
+
 static void
 end_subpass(struct vk_command_buffer *cmd_buffer,
             const VkSubpassEndInfo *end_info)
 {
    const struct vk_render_pass *pass = cmd_buffer->render_pass;
    const uint32_t subpass_idx = cmd_buffer->subpass_idx;
+   assert(subpass_idx < pass->subpass_count);
+   const struct vk_subpass *subpass = &pass->subpasses[subpass_idx];
    struct vk_device_dispatch_table *disp =
       &cmd_buffer->base.device->dispatch_table;
 
@@ -2432,7 +2462,22 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
       mem_barrier->dstAccessMask = dep->dst_access_mask;
    }
 
-   if (subpass_idx == pass->subpass_count - 1) {
+   /* If we have a barrier, we have an external dependency */
+   bool external_dependency = mem_barrier_count > 0;
+
+   if (!external_dependency) {
+      bool has_layout_transition = false;
+      for (uint32_t a = 0; a < subpass->attachment_count; a++) {
+         const struct vk_subpass_attachment *sp_att = &subpass->attachments[a];
+         if (sp_att->attachment == VK_ATTACHMENT_UNUSED)
+            continue;
+
+         const struct vk_render_pass_attachment *rp_att = &pass->attachments[sp_att->attachment];
+         bool transition = transition_needed(cmd_buffer, sp_att->attachment, subpass->view_mask,
+                                             rp_att->final_layout, rp_att->final_stencil_layout);
+         has_layout_transition |= (sp_att->last_subpass && transition);
+      }
+
       /* From the Vulkan 1.3.232 spec:
        *
        *    "Similarly, if there is no subpass dependency from the last
@@ -2453,22 +2498,17 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
        *        .dstAccessMask = 0;
        *        .dependencyFlags = 0;
        *    };"
-       *
-       * We could track individual subpasses and attachments and views to make
-       * sure we only insert this barrier when it's absolutely necessary.
-       * However, this is only going to happen for the last subpass and
-       * you're probably going to take a stall in EndRenderPass() anyway.
-       * If this is ever a perf problem, we can re-evaluate and do something
-       * more intellegent at that time.
        */
-      VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
-      mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
-      mem_barrier->pNext = NULL;
-      mem_barrier->srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
-      mem_barrier->srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
-                                   VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
-      mem_barrier->dstStageMask = VK_PIPELINE_STAGE_2_NONE;
-      mem_barrier->dstAccessMask = 0;
+      if (has_layout_transition) {
+         VkMemoryBarrier2 *mem_barrier = &mem_barriers[mem_barrier_count++];
+         mem_barrier->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
+         mem_barrier->pNext = NULL;
+         mem_barrier->srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT;
+         mem_barrier->srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                                      VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+         mem_barrier->dstStageMask = VK_PIPELINE_STAGE_2_NONE;
+         mem_barrier->dstAccessMask = 0;
+      }
    }
 
    if (mem_barrier_count > 0) {
-- 
GitLab


From 92f5307f0796c5800d56fad7cf54315f2a2baa98 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Wed, 27 Aug 2025 17:34:56 +0200
Subject: [PATCH 5/5] panvk/ci: Add uncovered CTS issue to flakes

The change to the implicit subpass barriers uncovered a CTS bug that is
now hitting CI. The issue is fixed in vulkan-cts-1.4.2.1, but CI is
currently on vulkan-cts-1.4.1.1.
---
 src/panfrost/ci/panfrost-g52-flakes.txt  | 3 +++
 src/panfrost/ci/panfrost-g610-flakes.txt | 3 +++
 src/panfrost/ci/panfrost-g720-flakes.txt | 3 +++
 src/panfrost/ci/panfrost-g725-flakes.txt | 3 +++
 4 files changed, 12 insertions(+)

diff --git a/src/panfrost/ci/panfrost-g52-flakes.txt b/src/panfrost/ci/panfrost-g52-flakes.txt
index fc725ff12fa34..4e3385a69a5e0 100644
--- a/src/panfrost/ci/panfrost-g52-flakes.txt
+++ b/src/panfrost/ci/panfrost-g52-flakes.txt
@@ -43,6 +43,9 @@ dEQP-VK.memory.pipeline_barrier.host_write_index_buffer.1048576
 # Sometime timeout
 dEQP-VK.memory.pipeline_barrier.host_write_storage_buffer.1048576
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 # The simulate_oom WSI tests are broken in CI
 dEQP-VK.wsi.*.swapchain.simulate_oom.*
 
diff --git a/src/panfrost/ci/panfrost-g610-flakes.txt b/src/panfrost/ci/panfrost-g610-flakes.txt
index 47a668a20f62b..89856725025b6 100644
--- a/src/panfrost/ci/panfrost-g610-flakes.txt
+++ b/src/panfrost/ci/panfrost-g610-flakes.txt
@@ -227,6 +227,9 @@ dEQP-VK.renderpass.suballocation.formats.r32_sint.input.load.store.clear_draw_us
 dEQP-VK.renderpass.suballocation.formats.r32g32_uint.input.load.dont_care.draw_use_input_aspect
 dEQP-VK.renderpass.suballocation.subpass_dependencies.external_subpass.render_size_64_64.render_passes_2
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_sint_pack32.input.load.dont_care.draw
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_srgb_pack32.input.load.store.clear_draw
 
diff --git a/src/panfrost/ci/panfrost-g720-flakes.txt b/src/panfrost/ci/panfrost-g720-flakes.txt
index 91033c80bfc3f..e66252102dc15 100644
--- a/src/panfrost/ci/panfrost-g720-flakes.txt
+++ b/src/panfrost/ci/panfrost-g720-flakes.txt
@@ -227,6 +227,9 @@ dEQP-VK.renderpass.suballocation.formats.r32_sint.input.load.store.clear_draw_us
 dEQP-VK.renderpass.suballocation.formats.r32g32_uint.input.load.dont_care.draw_use_input_aspect
 dEQP-VK.renderpass.suballocation.subpass_dependencies.external_subpass.render_size_64_64.render_passes_2
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_sint_pack32.input.load.dont_care.draw
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_srgb_pack32.input.load.store.clear_draw
 
diff --git a/src/panfrost/ci/panfrost-g725-flakes.txt b/src/panfrost/ci/panfrost-g725-flakes.txt
index 91033c80bfc3f..e66252102dc15 100644
--- a/src/panfrost/ci/panfrost-g725-flakes.txt
+++ b/src/panfrost/ci/panfrost-g725-flakes.txt
@@ -227,6 +227,9 @@ dEQP-VK.renderpass.suballocation.formats.r32_sint.input.load.store.clear_draw_us
 dEQP-VK.renderpass.suballocation.formats.r32g32_uint.input.load.dont_care.draw_use_input_aspect
 dEQP-VK.renderpass.suballocation.subpass_dependencies.external_subpass.render_size_64_64.render_passes_2
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_sint_pack32.input.load.dont_care.draw
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_srgb_pack32.input.load.store.clear_draw
 
-- 
GitLab

