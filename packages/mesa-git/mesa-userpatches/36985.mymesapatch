From bc3fc27c5a9150568926d21d83e24dccda3f9f34 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Mon, 25 Aug 2025 17:53:20 +0200
Subject: [PATCH 1/7] vulkan: Stop combining subpass dependencies

Rather than OR-ing all subpass dependencies together in the Vulkan layer,
pass an array of barriers down to the drivers and allow them to do the
OR-ing if needed.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/vulkan/runtime/vk_render_pass.c | 93 +++++++++++++++++------------
 1 file changed, 54 insertions(+), 39 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 0cc3a1884a806..570debba5439a 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1,5 +1,6 @@
 /*
  * Copyright © 2020 Valve Corporation
+ * Copyright © 2025 Arm Ltd
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -2049,15 +2050,15 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       }
    }
 
-   /* Next, handle any barriers we need.  This may include a general
-    * VkMemoryBarrier for subpass dependencies and it may include some
+   /* Next, handle any barriers we need.  This may include general
+    * VkMemoryBarriers for subpass dependencies and it may include some
     * number of VkImageMemoryBarriers for layout transitions.
     */
 
-   bool needs_mem_barrier = false;
-   VkMemoryBarrier2 mem_barrier = {
-      .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
-   };
+   /* At most all dependencies will need a barrier, and we might have an
+    * implicit one. */
+   STACK_ARRAY(VkMemoryBarrier2, mem_barriers, pass->dependency_count + 1);
+   uint32_t mem_barrier_count = 0;
    for (uint32_t d = 0; d < pass->dependency_count; d++) {
       const struct vk_subpass_dependency *dep = &pass->dependencies[d];
       if (dep->dst_subpass != subpass_idx)
@@ -2098,11 +2099,13 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
             continue;
       }
 
-      needs_mem_barrier = true;
-      mem_barrier.srcStageMask |= dep->src_stage_mask;
-      mem_barrier.srcAccessMask |= dep->src_access_mask;
-      mem_barrier.dstStageMask |= dep->dst_stage_mask;
-      mem_barrier.dstAccessMask |= dep->dst_access_mask;
+      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
+         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+         .srcStageMask = dep->src_stage_mask,
+         .srcAccessMask = dep->src_access_mask,
+         .dstStageMask = dep->dst_stage_mask,
+         .dstAccessMask = dep->dst_access_mask,
+      };
    }
 
    if (subpass_idx == 0) {
@@ -2137,13 +2140,17 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
        * If this is ever a perf problem, we can re-evaluate and do something
        * more intellegent at that time.
        */
-      needs_mem_barrier = true;
-      mem_barrier.dstStageMask |= VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-      mem_barrier.dstAccessMask |= VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
-                                   VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
-                                   VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
+         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+         .srcStageMask = VK_PIPELINE_STAGE_2_NONE,
+         .srcAccessMask = VK_ACCESS_2_NONE,
+         .dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
+         .dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
+                          VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
+                          VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
+                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
+      };
    }
 
    uint32_t max_image_barrier_count = 0;
@@ -2190,15 +2197,14 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    }
    assert(image_barrier_count <= max_image_barrier_count);
 
-   if (needs_mem_barrier || image_barrier_count > 0) {
+   if (mem_barrier_count > 0 || image_barrier_count > 0) {
       const VkDependencyInfo dependency_info = {
          .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
          .dependencyFlags = 0,
-         .memoryBarrierCount = needs_mem_barrier ? 1 : 0,
-         .pMemoryBarriers = needs_mem_barrier ? &mem_barrier : NULL,
+         .memoryBarrierCount = mem_barrier_count,
+         .pMemoryBarriers = mem_barrier_count > 0 ? mem_barriers : NULL,
          .imageMemoryBarrierCount = image_barrier_count,
-         .pImageMemoryBarriers = image_barrier_count > 0 ?
-                                 image_barriers : NULL,
+         .pImageMemoryBarriers = image_barrier_count > 0 ? image_barriers : NULL,
       };
       cmd_buffer->runtime_rp_barrier = true;
       disp->CmdPipelineBarrier2(vk_command_buffer_to_handle(cmd_buffer),
@@ -2207,6 +2213,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    }
 
    STACK_ARRAY_FINISH(image_barriers);
+   STACK_ARRAY_FINISH(mem_barriers);
 
    /* Next, handle any VK_ATTACHMENT_LOAD_OP_CLEAR that we couldn't handle
     * directly by emitting a quick vkCmdBegin/EndRendering to do the load.
@@ -2353,10 +2360,10 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
 
    disp->CmdEndRendering(vk_command_buffer_to_handle(cmd_buffer));
 
-   bool needs_mem_barrier = false;
-   VkMemoryBarrier2 mem_barrier = {
-      .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
-   };
+   /* At most all dependencies will need a barrier, and we might have an
+    * implicit one. */
+   STACK_ARRAY(VkMemoryBarrier2, mem_barriers, pass->dependency_count + 1);
+   uint32_t mem_barrier_count = 0;
    for (uint32_t d = 0; d < pass->dependency_count; d++) {
       const struct vk_subpass_dependency *dep = &pass->dependencies[d];
       if (dep->src_subpass != subpass_idx)
@@ -2365,11 +2372,13 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
       if (dep->dst_subpass != VK_SUBPASS_EXTERNAL)
          continue;
 
-      needs_mem_barrier = true;
-      mem_barrier.srcStageMask |= dep->src_stage_mask;
-      mem_barrier.srcAccessMask |= dep->src_access_mask;
-      mem_barrier.dstStageMask |= dep->dst_stage_mask;
-      mem_barrier.dstAccessMask |= dep->dst_access_mask;
+      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
+         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+         .srcStageMask = dep->src_stage_mask,
+         .srcAccessMask = dep->src_access_mask,
+         .dstStageMask = dep->dst_stage_mask,
+         .dstAccessMask = dep->dst_access_mask,
+      };
    }
 
    if (subpass_idx == pass->subpass_count - 1) {
@@ -2401,24 +2410,30 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
        * If this is ever a perf problem, we can re-evaluate and do something
        * more intellegent at that time.
        */
-      needs_mem_barrier = true;
-      mem_barrier.srcStageMask |= VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-      mem_barrier.srcAccessMask |= VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
-                                   VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
+         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+         .srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
+         .srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
+         .dstStageMask = VK_PIPELINE_STAGE_2_NONE,
+         .dstAccessMask = VK_ACCESS_2_NONE,
+      };
    }
 
-   if (needs_mem_barrier) {
+   if (mem_barrier_count > 0) {
       const VkDependencyInfo dependency_info = {
          .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
          .dependencyFlags = 0,
-         .memoryBarrierCount = 1,
-         .pMemoryBarriers = &mem_barrier,
+         .memoryBarrierCount = mem_barrier_count,
+         .pMemoryBarriers = mem_barriers,
       };
       cmd_buffer->runtime_rp_barrier = true;
       disp->CmdPipelineBarrier2(vk_command_buffer_to_handle(cmd_buffer),
                                 &dependency_info);
       cmd_buffer->runtime_rp_barrier = false;
    }
+
+   STACK_ARRAY_FINISH(mem_barriers);
 }
 
 VKAPI_ATTR void VKAPI_CALL
-- 
GitLab


From a2740ec23eca246ad723320aadbb495b4e3d6462 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Mon, 25 Aug 2025 17:28:26 +0200
Subject: [PATCH 2/7] vulkan: Find first_subpass when creating renderpass

Like last_subpass, add a per-view mask of what subpass first uses an
attachment. This is required for optimizing out some barriers later.

Note that this requires us to do another loop over the subpasses.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/vulkan/runtime/vk_render_pass.c | 45 +++++++++++++++++++++++++++++
 src/vulkan/runtime/vk_render_pass.h |  5 ++--
 2 files changed, 48 insertions(+), 2 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 570debba5439a..4640690479d7b 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -803,6 +803,51 @@ vk_common_CreateRenderPass2(VkDevice _device,
    assert(next_subpass_color_samples ==
           subpass_color_samples + subpass_color_attachment_count);
 
+   /* Walk forwards over the subpasses to compute first_subpass masks for all
+    * attachments.
+    */
+   for (uint32_t s = 0; s < pCreateInfo->subpassCount; s++) {
+      struct vk_subpass *subpass = &pass->subpasses[s];
+
+      /* First, compute first_subpass for all the attachments */
+      for (uint32_t a = 0; a < subpass->attachment_count; a++) {
+         struct vk_subpass_attachment *att = &subpass->attachments[a];
+         if (att->attachment == VK_ATTACHMENT_UNUSED)
+            continue;
+
+         assert(att->attachment < pass->attachment_count);
+         const struct vk_render_pass_attachment *pass_att =
+            &pass->attachments[att->attachment];
+
+         att->first_subpass = subpass->view_mask & ~pass_att->view_mask;
+      }
+
+      /* Then compute pass_att->view_mask.  We do the two separately so that
+       * we end up with the right first_subpass even if the same attachment is
+       * used twice within a subpass.
+       */
+      for (uint32_t a = 0; a < subpass->attachment_count; a++) {
+         const struct vk_subpass_attachment *att = &subpass->attachments[a];
+         if (att->attachment == VK_ATTACHMENT_UNUSED)
+            continue;
+
+         assert(att->attachment < pass->attachment_count);
+         struct vk_render_pass_attachment *pass_att =
+            &pass->attachments[att->attachment];
+
+         pass_att->view_mask |= subpass->view_mask;
+      }
+   }
+
+   /* Zero the view-masks, as we'll need to fill them again when looking for
+    * last_subpass
+    */
+   for (uint32_t a = 0; a < pass->attachment_count; a++) {
+      struct vk_render_pass_attachment *pass_att =
+         &pass->attachments[a];
+      pass_att->view_mask = 0;
+   }
+
    /* Walk backwards over the subpasses to compute view masks and
     * last_subpass masks for all attachments.
     */
diff --git a/src/vulkan/runtime/vk_render_pass.h b/src/vulkan/runtime/vk_render_pass.h
index d1016d7bca41b..d4b477e8d0ef8 100644
--- a/src/vulkan/runtime/vk_render_pass.h
+++ b/src/vulkan/runtime/vk_render_pass.h
@@ -64,12 +64,13 @@ struct vk_subpass_attachment {
     */
    VkImageLayout stencil_layout;
 
-   /** A per-view mask for if this is the last use of this attachment
+   /** A per-view mask for if this is the first or last use of this attachment
     *
     * If the same render pass attachment is used multiple ways within a
-    * subpass, corresponding last_subpass bits will be set in all of them.
+    * subpass, corresponding first/last_subpass bits will be set in all of them.
     * For the non-multiview case, only the first bit is used.
     */
+   uint32_t first_subpass;
    uint32_t last_subpass;
 
    /** Resolve attachment, if any */
-- 
GitLab


From 6d6e0e6d0ee2754c3884b4ac21040412ace4eba3 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Fri, 29 Aug 2025 11:25:14 +0200
Subject: [PATCH 3/7] vulkan: Add transition_view_mask calculation

Refactor out a function to calculate the view mask for required layout
transitions. This will be used in the following commits.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/vulkan/runtime/vk_render_pass.c | 63 ++++++++++++++++++++---------
 1 file changed, 45 insertions(+), 18 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 4640690479d7b..4093b7172f34f 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1520,7 +1520,7 @@ can_use_attachment_initial_layout(struct vk_command_buffer *cmd_buffer,
     * view_mask now as the only thing using it will be the loop below.
     */
 
-   /* 3D is stupidly special.  See transition_attachment() */
+   /* 3D is stupidly special. See transition_view_mask() */
    if (image_view->image->image_type == VK_IMAGE_TYPE_3D)
       view_mask = 1;
 
@@ -1605,23 +1605,18 @@ vk_command_buffer_set_attachment_layout(struct vk_command_buffer *cmd_buffer,
    }
 }
 
-static void
-transition_attachment(struct vk_command_buffer *cmd_buffer,
-                      uint32_t att_idx,
-                      uint32_t view_mask,
-                      VkImageLayout layout,
-                      VkImageLayout stencil_layout,
-                      uint32_t *barrier_count,
-                      uint32_t max_barrier_count,
-                      VkImageMemoryBarrier2 *barriers)
+static uint32_t
+transition_view_mask(struct vk_command_buffer *cmd_buffer,
+                     uint32_t att_idx,
+                     uint32_t view_mask,
+                     VkImageLayout layout,
+                     VkImageLayout stencil_layout)
 {
-   const struct vk_render_pass *pass = cmd_buffer->render_pass;
-   const struct vk_framebuffer *framebuffer = cmd_buffer->framebuffer;
-   const struct vk_render_pass_attachment *pass_att =
-      &pass->attachments[att_idx];
    struct vk_attachment_state *att_state = &cmd_buffer->attachments[att_idx];
    const struct vk_image_view *image_view = att_state->image_view;
 
+   uint32_t transition_view_mask = 0;
+
    /* 3D is stupidly special.  From the Vulkan 1.3.204 spec:
     *
     *    "When the VkImageSubresourceRange structure is used to select a
@@ -1649,10 +1644,41 @@ transition_attachment(struct vk_command_buffer *cmd_buffer,
       assert(view >= 0 && view < MESA_VK_MAX_MULTIVIEW_VIEW_COUNT);
       struct vk_attachment_view_state *att_view_state = &att_state->views[view];
 
-      /* First, check to see if we even need a transition */
-      if (att_view_state->layout == layout &&
-          att_view_state->stencil_layout == stencil_layout)
-         continue;
+      if (att_view_state->layout != layout ||
+          att_view_state->stencil_layout != stencil_layout)
+         transition_view_mask |= BITFIELD_BIT(view);
+   }
+
+   return transition_view_mask;
+}
+
+static void
+transition_attachment(struct vk_command_buffer *cmd_buffer,
+                      uint32_t att_idx,
+                      uint32_t view_mask,
+                      VkImageLayout layout,
+                      VkImageLayout stencil_layout,
+                      uint32_t *barrier_count,
+                      uint32_t max_barrier_count,
+                      VkImageMemoryBarrier2 *barriers)
+{
+   const struct vk_render_pass *pass = cmd_buffer->render_pass;
+   const struct vk_framebuffer *framebuffer = cmd_buffer->framebuffer;
+   const struct vk_render_pass_attachment *pass_att =
+      &pass->attachments[att_idx];
+   struct vk_attachment_state *att_state = &cmd_buffer->attachments[att_idx];
+   const struct vk_image_view *image_view = att_state->image_view;
+
+   /* Get a mask of views that need a layout transition. */
+   view_mask = transition_view_mask(cmd_buffer, att_idx, view_mask, layout,
+                                    stencil_layout);
+
+   u_foreach_bit(view, view_mask) {
+      assert(view >= 0 && view < MESA_VK_MAX_MULTIVIEW_VIEW_COUNT);
+      struct vk_attachment_view_state *att_view_state = &att_state->views[view];
+
+      assert(att_view_state->layout != layout ||
+             att_view_state->stencil_layout != stencil_layout);
 
       VkImageSubresourceRange range = {
          .aspectMask = pass_att->aspects,
@@ -1678,6 +1704,7 @@ transition_attachment(struct vk_command_buffer *cmd_buffer,
        *    level in this case."
        */
       if (image_view->image->image_type == VK_IMAGE_TYPE_3D) {
+         /* 3D is stupidly special. See transition_view_mask() */
          assert(view == 0);
          range.baseArrayLayer = 0;
          range.layerCount = image_view->extent.depth;
-- 
GitLab


From 86b17cada35ad266f348ed108e1d9a3d8b854d97 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Mon, 25 Aug 2025 15:22:24 +0200
Subject: [PATCH 4/7] vulkan: Optimize implicit begin_subpass barrier

Rather than adding an implicit barrier on the first subpass
unconditionally, track in what subpasses attachments are used for the
first time and only add dependencies if none exist and there might be an
image transition.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/vulkan/runtime/vk_render_pass.c | 105 ++++++++++++++--------------
 1 file changed, 53 insertions(+), 52 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index 4093b7172f34f..fcc605159a713 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -1652,7 +1652,7 @@ transition_view_mask(struct vk_command_buffer *cmd_buffer,
    return transition_view_mask;
 }
 
-static void
+static uint32_t
 transition_attachment(struct vk_command_buffer *cmd_buffer,
                       uint32_t att_idx,
                       uint32_t view_mask,
@@ -1726,6 +1726,8 @@ transition_attachment(struct vk_command_buffer *cmd_buffer,
       att_view_state->layout = layout;
       att_view_state->stencil_layout = stencil_layout;
    }
+
+   return view_mask;
 }
 
 static void
@@ -2131,6 +2133,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
     * implicit one. */
    STACK_ARRAY(VkMemoryBarrier2, mem_barriers, pass->dependency_count + 1);
    uint32_t mem_barrier_count = 0;
+   bool external_dependency = false;
    for (uint32_t d = 0; d < pass->dependency_count; d++) {
       const struct vk_subpass_dependency *dep = &pass->dependencies[d];
       if (dep->dst_subpass != subpass_idx)
@@ -2178,51 +2181,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
          .dstStageMask = dep->dst_stage_mask,
          .dstAccessMask = dep->dst_access_mask,
       };
-   }
-
-   if (subpass_idx == 0) {
-      /* From the Vulkan 1.3.232 spec:
-       *
-       *    "If there is no subpass dependency from VK_SUBPASS_EXTERNAL to the
-       *    first subpass that uses an attachment, then an implicit subpass
-       *    dependency exists from VK_SUBPASS_EXTERNAL to the first subpass it
-       *    is used in. The implicit subpass dependency only exists if there
-       *    exists an automatic layout transition away from initialLayout. The
-       *    subpass dependency operates as if defined with the following
-       *    parameters:
-       *
-       *    VkSubpassDependency implicitDependency = {
-       *        .srcSubpass = VK_SUBPASS_EXTERNAL;
-       *        .dstSubpass = firstSubpass; // First subpass attachment is used in
-       *        .srcStageMask = VK_PIPELINE_STAGE_NONE;
-       *        .dstStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
-       *        .srcAccessMask = 0;
-       *        .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
-       *                         VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
-       *                         VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
-       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
-       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
-       *        .dependencyFlags = 0;
-       *    };"
-       *
-       * We could track individual subpasses and attachments and views to make
-       * sure we only insert this barrier when it's absolutely necessary.
-       * However, this is only going to happen for the first subpass and
-       * you're probably going to take a stall in BeginRenderPass() anyway.
-       * If this is ever a perf problem, we can re-evaluate and do something
-       * more intellegent at that time.
-       */
-      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
-         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
-         .srcStageMask = VK_PIPELINE_STAGE_2_NONE,
-         .srcAccessMask = VK_ACCESS_2_NONE,
-         .dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
-         .dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
-                          VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
-                          VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
-                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
-                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
-      };
+      external_dependency |= (dep->src_subpass == VK_SUBPASS_EXTERNAL);
    }
 
    uint32_t max_image_barrier_count = 0;
@@ -2242,6 +2201,7 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       max_image_barrier_count += util_bitcount(subpass->view_mask);
    STACK_ARRAY(VkImageMemoryBarrier2, image_barriers, max_image_barrier_count);
    uint32_t image_barrier_count = 0;
+   bool has_layout_transition = false;
 
    for (uint32_t a = 0; a < subpass->attachment_count; a++) {
       const struct vk_subpass_attachment *sp_att = &subpass->attachments[a];
@@ -2251,12 +2211,15 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
       /* If we're using an initial layout, the attachment will already be
        * marked as transitioned and this will be a no-op.
        */
-      transition_attachment(cmd_buffer, sp_att->attachment,
-                            subpass->view_mask,
-                            sp_att->layout, sp_att->stencil_layout,
-                            &image_barrier_count,
-                            max_image_barrier_count,
-                            image_barriers);
+      uint32_t transitioned_views =
+         transition_attachment(cmd_buffer, sp_att->attachment,
+                               subpass->view_mask,
+                               sp_att->layout, sp_att->stencil_layout,
+                               &image_barrier_count,
+                               max_image_barrier_count,
+                               image_barriers);
+
+      has_layout_transition |= (sp_att->first_subpass & transitioned_views) != 0;
    }
    if (pass->fragment_density_map.attachment != VK_ATTACHMENT_UNUSED) {
       transition_attachment(cmd_buffer, pass->fragment_density_map.attachment,
@@ -2269,6 +2232,44 @@ begin_subpass(struct vk_command_buffer *cmd_buffer,
    }
    assert(image_barrier_count <= max_image_barrier_count);
 
+   if (has_layout_transition && !external_dependency) {
+      /* From the Vulkan 1.3.232 spec:
+       *
+       *    "If there is no subpass dependency from VK_SUBPASS_EXTERNAL to the
+       *    first subpass that uses an attachment, then an implicit subpass
+       *    dependency exists from VK_SUBPASS_EXTERNAL to the first subpass it
+       *    is used in. The implicit subpass dependency only exists if there
+       *    exists an automatic layout transition away from initialLayout. The
+       *    subpass dependency operates as if defined with the following
+       *    parameters:
+       *
+       *    VkSubpassDependency implicitDependency = {
+       *        .srcSubpass = VK_SUBPASS_EXTERNAL;
+       *        .dstSubpass = firstSubpass; // First subpass attachment is used in
+       *        .srcStageMask = VK_PIPELINE_STAGE_NONE;
+       *        .dstStageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+       *        .srcAccessMask = 0;
+       *        .dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT |
+       *                         VK_ACCESS_COLOR_ATTACHMENT_READ_BIT |
+       *                         VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
+       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
+       *                         VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
+       *        .dependencyFlags = 0;
+       *    };"
+       */
+      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
+         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+         .srcStageMask = VK_PIPELINE_STAGE_2_NONE,
+         .srcAccessMask = VK_ACCESS_2_NONE,
+         .dstStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
+         .dstAccessMask = VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT |
+                          VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT |
+                          VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT |
+                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
+      };
+   }
+
    if (mem_barrier_count > 0 || image_barrier_count > 0) {
       const VkDependencyInfo dependency_info = {
          .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
-- 
GitLab


From f9c1fb47919fec06bef8f7f570a3a79668231f76 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Tue, 26 Aug 2025 13:37:12 +0200
Subject: [PATCH 5/7] vulkan: Optimize implicit end_subpass barrier

Rather than adding an implicit barrier on the last subpass
unconditionally, track in what subpasses attachments are used for the
last time and only add dependencies if none exist and there might be an
image transition.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/vulkan/runtime/vk_render_pass.c | 48 +++++++++++++++++++----------
 1 file changed, 32 insertions(+), 16 deletions(-)

diff --git a/src/vulkan/runtime/vk_render_pass.c b/src/vulkan/runtime/vk_render_pass.c
index fcc605159a713..0e588a19379aa 100644
--- a/src/vulkan/runtime/vk_render_pass.c
+++ b/src/vulkan/runtime/vk_render_pass.c
@@ -2428,6 +2428,8 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
 {
    const struct vk_render_pass *pass = cmd_buffer->render_pass;
    const uint32_t subpass_idx = cmd_buffer->subpass_idx;
+   assert(subpass_idx < pass->subpass_count);
+   const struct vk_subpass *subpass = &pass->subpasses[subpass_idx];
    struct vk_device_dispatch_table *disp =
       &cmd_buffer->base.device->dispatch_table;
 
@@ -2454,7 +2456,26 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
       };
    }
 
-   if (subpass_idx == pass->subpass_count - 1) {
+   /* If we have a barrier, we have an external dependency */
+   bool external_dependency = mem_barrier_count > 0;
+
+   if (!external_dependency) {
+      bool has_layout_transition = false;
+      for (uint32_t a = 0; a < subpass->attachment_count; a++) {
+         const struct vk_subpass_attachment *sp_att = &subpass->attachments[a];
+         if (sp_att->attachment == VK_ATTACHMENT_UNUSED)
+            continue;
+
+         const struct vk_render_pass_attachment *rp_att =
+            &pass->attachments[sp_att->attachment];
+         uint32_t view_mask = transition_view_mask(cmd_buffer, sp_att->attachment,
+                                                   subpass->view_mask,
+                                                   rp_att->final_layout,
+                                                   rp_att->final_stencil_layout);
+
+         has_layout_transition |= (sp_att->last_subpass & view_mask) != 0;
+      }
+
       /* From the Vulkan 1.3.232 spec:
        *
        *    "Similarly, if there is no subpass dependency from the last
@@ -2475,22 +2496,17 @@ end_subpass(struct vk_command_buffer *cmd_buffer,
        *        .dstAccessMask = 0;
        *        .dependencyFlags = 0;
        *    };"
-       *
-       * We could track individual subpasses and attachments and views to make
-       * sure we only insert this barrier when it's absolutely necessary.
-       * However, this is only going to happen for the last subpass and
-       * you're probably going to take a stall in EndRenderPass() anyway.
-       * If this is ever a perf problem, we can re-evaluate and do something
-       * more intellegent at that time.
        */
-      mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
-         .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
-         .srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
-         .srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
-                          VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
-         .dstStageMask = VK_PIPELINE_STAGE_2_NONE,
-         .dstAccessMask = VK_ACCESS_2_NONE,
-      };
+      if (has_layout_transition) {
+         mem_barriers[mem_barrier_count++] = (VkMemoryBarrier2){
+            .sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
+            .srcStageMask = VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT,
+            .srcAccessMask = VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT |
+                             VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
+            .dstStageMask = VK_PIPELINE_STAGE_2_NONE,
+            .dstAccessMask = VK_ACCESS_2_NONE,
+         };
+      }
    }
 
    if (mem_barrier_count > 0) {
-- 
GitLab


From 18472207ab35d63284882ad9da689d845892cd07 Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Wed, 27 Aug 2025 17:34:56 +0200
Subject: [PATCH 6/7] panvk/ci: Add uncovered CTS issue to flakes

The change to the implicit subpass barriers uncovered a CTS bug that is
now hitting CI. The issue is fixed in vulkan-cts-1.4.2.1, but CI is
currently on vulkan-cts-1.4.1.1.

Reviewed-by: Faith Ekstrand <faith.ekstrand@collabora.com>
---
 src/panfrost/ci/panfrost-g52-flakes.txt  | 3 +++
 src/panfrost/ci/panfrost-g610-flakes.txt | 3 +++
 src/panfrost/ci/panfrost-g720-flakes.txt | 3 +++
 src/panfrost/ci/panfrost-g725-flakes.txt | 3 +++
 4 files changed, 12 insertions(+)

diff --git a/src/panfrost/ci/panfrost-g52-flakes.txt b/src/panfrost/ci/panfrost-g52-flakes.txt
index fc725ff12fa34..4e3385a69a5e0 100644
--- a/src/panfrost/ci/panfrost-g52-flakes.txt
+++ b/src/panfrost/ci/panfrost-g52-flakes.txt
@@ -43,6 +43,9 @@ dEQP-VK.memory.pipeline_barrier.host_write_index_buffer.1048576
 # Sometime timeout
 dEQP-VK.memory.pipeline_barrier.host_write_storage_buffer.1048576
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 # The simulate_oom WSI tests are broken in CI
 dEQP-VK.wsi.*.swapchain.simulate_oom.*
 
diff --git a/src/panfrost/ci/panfrost-g610-flakes.txt b/src/panfrost/ci/panfrost-g610-flakes.txt
index 47a668a20f62b..89856725025b6 100644
--- a/src/panfrost/ci/panfrost-g610-flakes.txt
+++ b/src/panfrost/ci/panfrost-g610-flakes.txt
@@ -227,6 +227,9 @@ dEQP-VK.renderpass.suballocation.formats.r32_sint.input.load.store.clear_draw_us
 dEQP-VK.renderpass.suballocation.formats.r32g32_uint.input.load.dont_care.draw_use_input_aspect
 dEQP-VK.renderpass.suballocation.subpass_dependencies.external_subpass.render_size_64_64.render_passes_2
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_sint_pack32.input.load.dont_care.draw
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_srgb_pack32.input.load.store.clear_draw
 
diff --git a/src/panfrost/ci/panfrost-g720-flakes.txt b/src/panfrost/ci/panfrost-g720-flakes.txt
index 91033c80bfc3f..e66252102dc15 100644
--- a/src/panfrost/ci/panfrost-g720-flakes.txt
+++ b/src/panfrost/ci/panfrost-g720-flakes.txt
@@ -227,6 +227,9 @@ dEQP-VK.renderpass.suballocation.formats.r32_sint.input.load.store.clear_draw_us
 dEQP-VK.renderpass.suballocation.formats.r32g32_uint.input.load.dont_care.draw_use_input_aspect
 dEQP-VK.renderpass.suballocation.subpass_dependencies.external_subpass.render_size_64_64.render_passes_2
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_sint_pack32.input.load.dont_care.draw
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_srgb_pack32.input.load.store.clear_draw
 
diff --git a/src/panfrost/ci/panfrost-g725-flakes.txt b/src/panfrost/ci/panfrost-g725-flakes.txt
index 91033c80bfc3f..e66252102dc15 100644
--- a/src/panfrost/ci/panfrost-g725-flakes.txt
+++ b/src/panfrost/ci/panfrost-g725-flakes.txt
@@ -227,6 +227,9 @@ dEQP-VK.renderpass.suballocation.formats.r32_sint.input.load.store.clear_draw_us
 dEQP-VK.renderpass.suballocation.formats.r32g32_uint.input.load.dont_care.draw_use_input_aspect
 dEQP-VK.renderpass.suballocation.subpass_dependencies.external_subpass.render_size_64_64.render_passes_2
 
+# CTS bug, see https://github.com/KhronosGroup/VK-GL-CTS/commit/3871f1a1c1e5fa479baea4a82ecdd36c30cd7bc0
+dEQP-VK.renderpass2.depth_stencil_resolve.*_samplemask
+
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_sint_pack32.input.load.dont_care.draw
 dEQP-VK.renderpass2.suballocation.formats.a8b8g8r8_srgb_pack32.input.load.store.clear_draw
 
-- 
GitLab


From ec046fbdf906f7d3c78ec26d00f3c0a288589b5f Mon Sep 17 00:00:00 2001
From: Lars-Ivar Hesselberg Simonsen <lars-ivar.simonsen@arm.com>
Date: Thu, 4 Sep 2025 10:55:23 +0200
Subject: [PATCH 7/7] radv/ci: Add uncovered CTS issue to gfx1201 fails

gfx1201 has started hitting some failures in
dEQP-VK.glsl.bfloat16.constant* that seem to be caused by a CTS issue.
---
 src/amd/ci/radv-gfx1201-fails.txt | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/amd/ci/radv-gfx1201-fails.txt b/src/amd/ci/radv-gfx1201-fails.txt
index f26dc9dd97368..dd9f42c318d1c 100644
--- a/src/amd/ci/radv-gfx1201-fails.txt
+++ b/src/amd/ci/radv-gfx1201-fails.txt
@@ -52,3 +52,11 @@ dEQP-VK.compute.shader_object_spirv.cooperative_matrix.khr_r.subgroupscope.conve
 dEQP-VK.compute.shader_object_spirv.cooperative_matrix.khr_r.subgroupscope.convert.input_float32_t_output_bfloat16_t.buffer.rowmajor,Fail
 dEQP-VK.compute.shader_object_spirv.cooperative_matrix.khr_r.subgroupscope.convert.input_float32_t_output_bfloat16_t.physical_buffer.rowmajor,Fail
 dEQP-VK.compute.shader_object_spirv.cooperative_matrix.khr_r.subgroupscope.convert.input_float32_t_output_bfloat16_t.workgroup.rowmajor,Fail
+
+# CTS bug https://gitlab.khronos.org/Tracker/vk-gl-cts/-/issues/5983
+dEQP-VK.glsl.bfloat16.constant.fragmentbf16,Fail
+dEQP-VK.glsl.bfloat16.constant.fragmentfe4m3,Fail
+dEQP-VK.glsl.bfloat16.constant.fragmentfe5m2,Fail
+dEQP-VK.glsl.bfloat16.constant.vertexbf16,Fail
+dEQP-VK.glsl.bfloat16.constant.vertexfe4m3,Fail
+dEQP-VK.glsl.bfloat16.constant.vertexfe5m2,Fail
-- 
GitLab

