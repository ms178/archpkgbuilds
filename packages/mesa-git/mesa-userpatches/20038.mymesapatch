From f1e89e925ddb1a6c9cfa1dad83b01e0c5964b000 Mon Sep 17 00:00:00 2001
From: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date: Mon, 28 Nov 2022 18:50:55 +0530
Subject: [PATCH] radeonsi: fix KHR-GL46.stencil_texturing.functional crash

In si_update_ps_colorbuf0_slot(), variable ps_uses_fbfetch is not updated
since blitter_running will be true in all cases u_blitter_ functions are
used. In the crash case it is si_copy_region_with_blit().

with debug build asserion
"!sctx->ps_uses_fbfetch || sctx->framebuffer.state.cbufs[0] failed" is
hit.

In case of si_blit_decompress_color(), si_update_ps_colorbuf0_slot()
should not be run again otherwise it will end in u_blitter_* recursive
call bug in cards particularly older than vega.

Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
---
 src/gallium/drivers/radeonsi/si_blit.c        | 24 ++++++++++++++-----
 .../drivers/radeonsi/si_compute_blit.c        |  4 ++--
 src/gallium/drivers/radeonsi/si_descriptors.c |  5 ++--
 src/gallium/drivers/radeonsi/si_pipe.h        |  9 ++++++-
 4 files changed, 31 insertions(+), 11 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_blit.c b/src/gallium/drivers/radeonsi/si_blit.c
index 4158bb33a5a5..e6cc0937cb96 100644
--- a/src/gallium/drivers/radeonsi/si_blit.c
+++ b/src/gallium/drivers/radeonsi/si_blit.c
@@ -85,12 +85,13 @@ void si_blitter_begin(struct si_context *sctx, enum si_blitter_op op)
       si_mark_atom_dirty(sctx, &sctx->atoms.s.dpbb_state);
    }
 
-   sctx->blitter_running = true;
+   if (sctx->blitter_running == SI_BLIT_NOT_RUN)
+      sctx->blitter_running = SI_BLIT_RUN;
 }
 
 void si_blitter_end(struct si_context *sctx)
 {
-   sctx->blitter_running = false;
+   sctx->blitter_running = SI_BLIT_NOT_RUN;
 
    if (sctx->screen->dpbb_allowed) {
       sctx->dpbb_force_off = false;
@@ -114,6 +115,17 @@ void si_blitter_end(struct si_context *sctx)
    si_mark_atom_dirty(sctx, &sctx->atoms.s.shader_pointers);
 }
 
+static void si_blitter_decompress_begin(struct si_context *sctx, enum si_blitter_op op)
+{
+   sctx->blitter_running = SI_BLIT_RUN_DECOMPRESS;
+   si_blitter_begin(sctx, op);
+}
+
+static void si_blitter_decompress_end(struct si_context *sctx)
+{
+   si_blitter_end(sctx);
+}
+
 static unsigned u_max_sample(struct pipe_resource *r)
 {
    return r->nr_samples ? r->nr_samples - 1 : 0;
@@ -498,9 +510,9 @@ static void si_blit_decompress_color(struct si_context *sctx, struct si_texture
              custom_blend == sctx->custom_blend_dcc_decompress)
             sctx->flags |= SI_CONTEXT_FLUSH_AND_INV_CB;
 
-         si_blitter_begin(sctx, SI_DECOMPRESS);
+         si_blitter_decompress_begin(sctx, SI_DECOMPRESS);
          util_blitter_custom_color(sctx->blitter, cbsurf, custom_blend);
-         si_blitter_end(sctx);
+         si_blitter_decompress_end(sctx);
 
          if (custom_blend == sctx->custom_blend_fmask_decompress ||
              custom_blend == sctx->custom_blend_dcc_decompress)
@@ -517,9 +529,9 @@ static void si_blit_decompress_color(struct si_context *sctx, struct si_texture
          if (sctx->screen->allow_dcc_msaa_clear_to_reg_for_bpp[util_logbase2(tex->surface.bpe)] &&
              custom_blend == sctx->custom_blend_fmask_decompress &&
              vi_dcc_enabled(tex, level)) {
-            si_blitter_begin(sctx, SI_DECOMPRESS);
+            si_blitter_decompress_begin(sctx, SI_DECOMPRESS);
             util_blitter_custom_color(sctx->blitter, cbsurf, sctx->custom_blend_eliminate_fastclear);
-            si_blitter_end(sctx);
+            si_blitter_decompress_end(sctx);
          }
 
          pipe_surface_reference(&cbsurf, NULL);
diff --git a/src/gallium/drivers/radeonsi/si_compute_blit.c b/src/gallium/drivers/radeonsi/si_compute_blit.c
index 10e78015d7de..e9b1728615b5 100644
--- a/src/gallium/drivers/radeonsi/si_compute_blit.c
+++ b/src/gallium/drivers/radeonsi/si_compute_blit.c
@@ -187,7 +187,7 @@ static void si_launch_grid_internal(struct si_context *sctx, const struct pipe_g
       sctx->render_cond_enabled = false;
 
    /* Skip decompression to prevent infinite recursion. */
-   sctx->blitter_running = true;
+   sctx->blitter_running = SI_BLIT_RUN_DECOMPRESS;
 
    /* Dispatch compute. */
    void *saved_cs = sctx->cs_shader_state.program;
@@ -199,7 +199,7 @@ static void si_launch_grid_internal(struct si_context *sctx, const struct pipe_g
    sctx->flags &= ~SI_CONTEXT_STOP_PIPELINE_STATS;
    sctx->flags |= SI_CONTEXT_START_PIPELINE_STATS;
    sctx->render_cond_enabled = sctx->render_cond;
-   sctx->blitter_running = false;
+   sctx->blitter_running = SI_BLIT_NOT_RUN;
 
    if (flags & SI_OP_SYNC_AFTER) {
       sctx->flags |= SI_CONTEXT_CS_PARTIAL_FLUSH;
diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index abf1c4d66b1e..da4604e655f4 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -946,8 +946,9 @@ void si_update_ps_colorbuf0_slot(struct si_context *sctx)
    unsigned slot = SI_PS_IMAGE_COLORBUF0;
    struct pipe_surface *surf = NULL;
 
-   /* si_texture_disable_dcc can get us here again. */
-   if (sctx->in_update_ps_colorbuf0_slot || sctx->blitter_running) {
+   /* si_texture_disable_dcc and si_eliminate_fast_color_clear can get us here again. */
+   if (sctx->in_update_ps_colorbuf0_slot ||
+       sctx->blitter_running == SI_BLIT_RUN_DECOMPRESS) {
       assert(!sctx->ps_uses_fbfetch || sctx->framebuffer.state.cbufs[0]);
       return;
    }
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 6358d6ddbf2d..f73e75b945aa 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -945,6 +945,13 @@ typedef void (*pipe_draw_vertex_state_func)(struct pipe_context *ctx,
                                             const struct pipe_draw_start_count_bias *draws,
                                             unsigned num_draws);
 
+enum si_blitter_run_status
+{
+   SI_BLIT_NOT_RUN = 0,
+   SI_BLIT_RUN,
+   SI_BLIT_RUN_DECOMPRESS
+};
+
 struct si_context {
    struct pipe_context b; /* base class */
 
@@ -1005,7 +1012,7 @@ struct si_context {
    unsigned wait_mem_number;
    uint16_t prefetch_L2_mask;
 
-   bool blitter_running;
+   enum si_blitter_run_status blitter_running;
    bool in_update_ps_colorbuf0_slot;
    bool is_noop:1;
    bool has_graphics:1;
-- 
GitLab

