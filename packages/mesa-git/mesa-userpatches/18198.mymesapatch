From f232cce254b86ecc899df36a15b7d689f3554a3f Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 12 Aug 2022 12:21:08 -0400
Subject: [PATCH 1/7] mesa/st: split out builtin shader finish

it's useful to be able to run the nir passes separately
---
 src/mesa/state_tracker/st_nir.h          |  2 ++
 src/mesa/state_tracker/st_nir_builtins.c | 13 ++++++++++---
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/src/mesa/state_tracker/st_nir.h b/src/mesa/state_tracker/st_nir.h
index 28fa476589b7..d44d1e50bc8d 100644
--- a/src/mesa/state_tracker/st_nir.h
+++ b/src/mesa/state_tracker/st_nir.h
@@ -59,6 +59,8 @@ void st_nir_lower_samplers(struct pipe_screen *screen, struct nir_shader *nir,
                            struct gl_program *prog);
 void st_nir_lower_uniforms(struct st_context *st, struct nir_shader *nir);
 
+struct nir_shader *
+st_nir_finish_builtin_nir(struct st_context *st, struct nir_shader *nir);
 struct pipe_shader_state *
 st_nir_finish_builtin_shader(struct st_context *st,
                              struct nir_shader *nir);
diff --git a/src/mesa/state_tracker/st_nir_builtins.c b/src/mesa/state_tracker/st_nir_builtins.c
index bfbe0a939b8e..5cfe96cac2aa 100644
--- a/src/mesa/state_tracker/st_nir_builtins.c
+++ b/src/mesa/state_tracker/st_nir_builtins.c
@@ -29,9 +29,8 @@
 #include "compiler/glsl/gl_nir_linker.h"
 #include "tgsi/tgsi_parse.h"
 
-struct pipe_shader_state *
-st_nir_finish_builtin_shader(struct st_context *st,
-                             nir_shader *nir)
+nir_shader *
+st_nir_finish_builtin_nir(struct st_context *st, nir_shader *nir)
 {
    struct pipe_screen *screen = st->screen;
    gl_shader_stage stage = nir->info.stage;
@@ -75,6 +74,14 @@ st_nir_finish_builtin_shader(struct st_context *st,
    } else {
       gl_nir_opts(nir);
    }
+   return nir;
+}
+
+struct pipe_shader_state *
+st_nir_finish_builtin_shader(struct st_context *st,
+                             nir_shader *nir)
+{
+   st_nir_finish_builtin_nir(st, nir);
 
    struct pipe_shader_state state = {
       .type = PIPE_SHADER_IR_NIR,
-- 
GitLab


From 7323bd46017a5a495deb19f97b689ad08278b0e7 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 12 Aug 2022 12:21:49 -0400
Subject: [PATCH 2/7] st_pbo/compute: use split shader finish funcs

no functional changes
---
 src/mesa/state_tracker/st_pbo_compute.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 57b445f2c86e..799375b67de7 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -31,6 +31,7 @@
 #include "state_tracker/st_nir.h"
 #include "state_tracker/st_format.h"
 #include "state_tracker/st_pbo.h"
+#include "state_tracker/st_program.h"
 #include "state_tracker/st_texture.h"
 #include "compiler/nir/nir_builder.h"
 #include "compiler/nir/nir_format_convert.h"
@@ -599,7 +600,7 @@ do_shader_conversion(nir_builder *b, nir_ssa_def *pixel,
    nir_pop_if(b, NULL);
 }
 
-static void *
+static nir_shader *
 create_conversion_shader(struct st_context *st, enum pipe_texture_target target, unsigned num_components)
 {
    const nir_shader_compiler_options *options = st_get_nir_compiler_options(st, MESA_SHADER_COMPUTE);
@@ -673,7 +674,7 @@ create_conversion_shader(struct st_context *st, enum pipe_texture_target target,
 
    nir_validate_shader(b.shader, NULL);
    gl_nir_opts(b.shader);
-   return st_nir_finish_builtin_shader(st, b.shader);
+   return st_nir_finish_builtin_nir(st, b.shader);
 }
 
 static void
@@ -829,7 +830,13 @@ download_texture_compute(struct st_context *st,
    struct hash_entry *he = _mesa_hash_table_search(st->pbo.shaders, (void*)(uintptr_t)hash_key);
    void *cs;
    if (!he) {
-      cs = create_conversion_shader(st, view_target, num_components);
+      nir_shader *nir = create_conversion_shader(st, view_target, num_components);
+      struct pipe_shader_state state = {
+         .type = PIPE_SHADER_IR_NIR,
+         .ir.nir = nir,
+      };
+
+      cs = st_create_nir_shader(st, &state);
       he = _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, cs);
    }
    cs = he->data;
-- 
GitLab


From eee32063453fc8e156d20154cfa89f73a4f90dbe Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 12 Aug 2022 12:25:15 -0400
Subject: [PATCH 3/7] mesa/st: move compute pbo shutdown to compute pbo file

---
 src/mesa/state_tracker/st_pbo.c         | 6 +-----
 src/mesa/state_tracker/st_pbo.h         | 2 ++
 src/mesa/state_tracker/st_pbo_compute.c | 9 +++++++++
 3 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index f32578405f93..27ef99162828 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -739,9 +739,5 @@ st_destroy_pbo_helpers(struct st_context *st)
       st->pbo.vs = NULL;
    }
 
-   if (st->pbo.shaders) {
-      hash_table_foreach(st->pbo.shaders, entry)
-         st->pipe->delete_compute_state(st->pipe, entry->data);
-      _mesa_hash_table_destroy(st->pbo.shaders, NULL);
-   }
+   st_pbo_compute_deinit(st);
 }
diff --git a/src/mesa/state_tracker/st_pbo.h b/src/mesa/state_tracker/st_pbo.h
index b1eafc8fd0a2..0b5e28fdf0d5 100644
--- a/src/mesa/state_tracker/st_pbo.h
+++ b/src/mesa/state_tracker/st_pbo.h
@@ -129,5 +129,7 @@ st_init_pbo_helpers(struct st_context *st);
 
 extern void
 st_destroy_pbo_helpers(struct st_context *st);
+void
+st_pbo_compute_deinit(struct st_context *st);
 
 #endif /* ST_PBO_H */
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 799375b67de7..3c82f2566c0d 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -1158,3 +1158,12 @@ st_GetTexSubImage_shader(struct gl_context * ctx,
    return true;
 }
 
+void
+st_pbo_compute_deinit(struct st_context *st)
+{
+   if (!st->pbo.shaders)
+      return;
+   hash_table_foreach(st->pbo.shaders, entry)
+      st->pipe->delete_compute_state(st->pipe, entry->data);
+   _mesa_hash_table_destroy(st->pbo.shaders, NULL);
+}
-- 
GitLab


From 02a9ddd092ac23f8d005d67749cec8b34e665d30 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 12 Aug 2022 14:30:58 -0400
Subject: [PATCH 4/7] gallium: add pipe_screen::create_shader_nir_async

this allows a frontend to punt creation of a nir shader down to the
driver's compilation thread, which is useful in the event that the
shader being created is so big that it will cause immediate blocking
from running common nir passes
---
 .../auxiliary/driver_trace/tr_screen.c        | 20 +++++++++++++++++++
 src/gallium/include/pipe/p_screen.h           |  3 +++
 2 files changed, 23 insertions(+)

diff --git a/src/gallium/auxiliary/driver_trace/tr_screen.c b/src/gallium/auxiliary/driver_trace/tr_screen.c
index d964b42b0adc..61533de7e014 100644
--- a/src/gallium/auxiliary/driver_trace/tr_screen.c
+++ b/src/gallium/auxiliary/driver_trace/tr_screen.c
@@ -279,6 +279,25 @@ trace_screen_is_format_supported(struct pipe_screen *_screen,
    return result;
 }
 
+static void
+trace_screen_create_shader_nir_async(struct pipe_screen *_screen,
+                                     void *data, struct util_queue_fence *fence,
+                                     void (*create_func)(void *data, void *gdata, int thread_index))
+{
+   struct trace_screen *tr_scr = trace_screen(_screen);
+   struct pipe_screen *screen = tr_scr->screen;
+
+   trace_dump_call_begin("pipe_screen", "create_shader_nir_async");
+
+   trace_dump_arg(ptr, screen);
+   trace_dump_arg(ptr, data);
+   trace_dump_arg(ptr, fence);
+
+   screen->create_shader_nir_async(screen, data, fence, create_func);
+
+   trace_dump_call_end();
+}
+
 static void
 trace_context_replace_buffer_storage(struct pipe_context *_pipe,
                                      struct pipe_resource *dst,
@@ -1453,6 +1472,7 @@ trace_screen_create(struct pipe_screen *screen)
    tr_scr->base.transfer_helper = screen->transfer_helper;
    SCR_INIT(get_sparse_texture_virtual_page_size);
    SCR_INIT(set_fence_timeline_value);
+   SCR_INIT(create_shader_nir_async);
 
    tr_scr->screen = screen;
 
diff --git a/src/gallium/include/pipe/p_screen.h b/src/gallium/include/pipe/p_screen.h
index 8bc1a2de2d81..46aa81b771d3 100644
--- a/src/gallium/include/pipe/p_screen.h
+++ b/src/gallium/include/pipe/p_screen.h
@@ -65,6 +65,7 @@ struct disk_cache;
 struct driOptionCache;
 struct u_transfer_helper;
 struct pipe_screen;
+struct util_queue_fence;
 
 typedef struct pipe_vertex_state *
    (*pipe_create_vertex_state_func)(struct pipe_screen *screen,
@@ -573,6 +574,8 @@ struct pipe_screen {
                                                    void *shader,
                                                    enum pipe_shader_type shader_type);
 
+   void (*create_shader_nir_async)(struct pipe_screen *screen, void *data, struct util_queue_fence *fence, void (*create_func)(void *data, void *gdata, int thread_index));
+
    /**
     * Set the damage region (called when KHR_partial_update() is invoked).
     * This function is passed an array of rectangles encoding the damage area.
-- 
GitLab


From ccf5173a52bd9cf406537a7c395c0199e853db19 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Fri, 12 Aug 2022 14:32:52 -0400
Subject: [PATCH 5/7] st_pbo/compute: use new shader interface to perform async
 shader creation

this enables compatible drivers to initiate threaded creation of huge
compute shaders fully in a thread while falling back to software in
order to avoid blocking for several seconds, as slower progress is better
than no progress at all--especially in cases where the huge pbo shader
may only be used a single time

the mechanics are straightforward for thread-enabled drivers:
* check hash table for existing shader data
* if no shader exists, perform creation of nir shader fully in driver thread
  and return immediately, enabling software fallback without blocking
* once fence for nir shader is signalled, pass the nir back to the driver
  thread again to run common nir passes and execute normal shader creation
* continue to use software fallback until the shader is fully ready
---
 src/mesa/state_tracker/st_pbo_compute.c | 122 +++++++++++++++++-------
 1 file changed, 90 insertions(+), 32 deletions(-)

diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 3c82f2566c0d..d5c06b945c6f 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -40,6 +40,15 @@
 #include "util/u_sampler.h"
 #include "util/streaming-load-memcpy.h"
 
+struct pbo_async_data {
+   struct st_context *st;
+   enum pipe_texture_target target;
+   unsigned num_components;
+   struct util_queue_fence fence;
+   nir_shader *nir;
+   struct pipe_shader_state *cs;
+};
+
 #define BGR_FORMAT(NAME) \
     {{ \
      [0] = PIPE_FORMAT_##NAME##_SNORM, \
@@ -777,6 +786,13 @@ can_copy_direct(const struct gl_pixelstore_attrib *pack)
             pack->SkipImages);
 }
 
+static void
+create_conversion_shader_async(void *data, void *gdata, int thread_index)
+{
+   struct pbo_async_data *async = data;
+   async->nir = create_conversion_shader(async->st, async->target, async->num_components);
+}
+
 static struct pipe_resource *
 download_texture_compute(struct st_context *st,
                          const struct gl_pixelstore_attrib *pack,
@@ -801,48 +817,80 @@ download_texture_compute(struct st_context *st,
 
    unsigned num_components = 0;
    /* Upload constants */
-   {
-      struct pipe_constant_buffer cb;
-      assert(view_target != PIPE_TEXTURE_1D_ARRAY || !zoffset);
-      struct pbo_data pd = {
-         .x = MIN2(xoffset, 65535),
-         .y = view_target == PIPE_TEXTURE_1D_ARRAY ? 0 : MIN2(yoffset, 65535),
-         .width = MIN2(width, 65535),
-         .height = MIN2(height, 65535),
-         .depth = MIN2(depth, 65535),
-         .invert = pack->Invert,
-         .blocksize = util_format_get_blocksize(dst_format) - 1,
-         .alignment = ffs(MAX2(pack->Alignment, 1)) - 1,
-      };
-      num_components = fill_pbo_data(&pd, src_format, dst_format, pack->SwapBytes == 1);
-
-      cb.buffer = NULL;
-      cb.user_buffer = &pd;
-      cb.buffer_offset = 0;
-      cb.buffer_size = sizeof(pd);
+   struct pipe_constant_buffer cb;
+   assert(view_target != PIPE_TEXTURE_1D_ARRAY || !yoffset);
+   struct pbo_data pd = {
+      .x = MIN2(xoffset, 65535),
+      .y = view_target == PIPE_TEXTURE_1D_ARRAY ? 0 : MIN2(yoffset, 65535),
+      .width = MIN2(width, 65535),
+      .height = MIN2(height, 65535),
+      .depth = MIN2(depth, 65535),
+      .invert = pack->Invert,
+      .blocksize = util_format_get_blocksize(dst_format) - 1,
+      .alignment = ffs(MAX2(pack->Alignment, 1)) - 1,
+   };
+   num_components = fill_pbo_data(&pd, src_format, dst_format, pack->SwapBytes == 1);
 
-      pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, false, &cb);
-   }
+   cb.buffer = NULL;
+   cb.user_buffer = &pd;
+   cb.buffer_offset = 0;
+   cb.buffer_size = sizeof(pd);
 
    uint32_t hash_key = compute_shader_key(view_target, num_components);
    assert(hash_key != 0);
 
    struct hash_entry *he = _mesa_hash_table_search(st->pbo.shaders, (void*)(uintptr_t)hash_key);
-   void *cs;
-   if (!he) {
-      nir_shader *nir = create_conversion_shader(st, view_target, num_components);
-      struct pipe_shader_state state = {
-         .type = PIPE_SHADER_IR_NIR,
-         .ir.nir = nir,
-      };
+   void *cs = NULL;
+   if (he) {
+      if (screen->create_shader_nir_async) {
+         struct pbo_async_data *async = he->data;
+         if (!util_queue_fence_is_signalled(&async->fence))
+            return NULL;
+         /* nir is definitely done */
+         if (!async->cs) {
+            /* cs job not yet started */
+            assert(async->nir && !async->cs);
+            struct pipe_compute_state state = {0};
+            state.ir_type = PIPE_SHADER_IR_NIR;
+            state.req_local_mem = async->nir->info.shared_size;
+            state.prog = async->nir;
+            async->nir = NULL;
+            async->cs = pipe->create_compute_state(pipe, &state);
+         }
+         /* cs *may* be done */
+         if (screen->is_parallel_shader_compilation_finished &&
+             !screen->is_parallel_shader_compilation_finished(screen, async->cs, MESA_SHADER_COMPUTE))
+            return NULL;
+         cs = async->cs;
+      }
+   } else {
+      if (screen->create_shader_nir_async) {
+         struct pbo_async_data *async = malloc(sizeof(struct pbo_async_data));
+         async->st = st;
+         async->target = view_target;
+         async->num_components = num_components;
+         async->nir = NULL;
+         async->cs = NULL;
+         util_queue_fence_init(&async->fence);
+         screen->create_shader_nir_async(screen, async, &async->fence, create_conversion_shader_async);
+         _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, async);
+         return NULL;
+      } else {
+         nir_shader *nir = create_conversion_shader(st, view_target, num_components);
+         struct pipe_shader_state state = {
+            .type = PIPE_SHADER_IR_NIR,
+            .ir.nir = nir,
+         };
 
-      cs = st_create_nir_shader(st, &state);
+         cs = st_create_nir_shader(st, &state);
+      }
       he = _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, cs);
    }
-   cs = he->data;
    assert(cs);
    struct cso_context *cso = st->cso_context;
 
+   pipe->set_constant_buffer(pipe, PIPE_SHADER_COMPUTE, 0, false, &cb);
+
    cso_save_compute_state(cso, CSO_BIT_COMPUTE_SHADER | CSO_BIT_COMPUTE_SAMPLERS);
    cso_set_compute_shader_handle(cso, cs);
 
@@ -1161,9 +1209,19 @@ st_GetTexSubImage_shader(struct gl_context * ctx,
 void
 st_pbo_compute_deinit(struct st_context *st)
 {
+   struct pipe_screen *screen = st->screen;
    if (!st->pbo.shaders)
       return;
-   hash_table_foreach(st->pbo.shaders, entry)
-      st->pipe->delete_compute_state(st->pipe, entry->data);
+   hash_table_foreach(st->pbo.shaders, entry) {
+      if (screen->create_shader_nir_async) {
+         struct pbo_async_data *async = entry->data;
+         util_queue_fence_wait(&async->fence);
+         st->pipe->delete_compute_state(st->pipe, async->cs);
+         util_queue_fence_destroy(&async->fence);
+         free(async);
+      } else {
+         st->pipe->delete_compute_state(st->pipe, entry->data);
+      }
+   }
    _mesa_hash_table_destroy(st->pbo.shaders, NULL);
 }
-- 
GitLab


From 2df895555ce13d691c4af0a71ddef88afea137b1 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Wed, 17 Aug 2022 10:04:43 -0400
Subject: [PATCH 6/7] mesa/st: add specialized pbo download shaders

the goal of the pbo ubershaders was to have a very small number of
shaders that could handle lots of different readback operations

this is great for cases where an app is doing lots of different types
of readback, but it's not as optimal for apps which do only 1-2 types
of readback over and over

to handle this, track the usage for every readback which reaches compute pbo
and after the same readback is used N times, inline the constant data and
create a specialized version of the shader which will be more optimal
---
 src/mesa/state_tracker/st_pbo_compute.c | 98 ++++++++++++++++++++++++-
 1 file changed, 97 insertions(+), 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index d5c06b945c6f..25f1c8e728cb 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -40,13 +40,26 @@
 #include "util/u_sampler.h"
 #include "util/streaming-load-memcpy.h"
 
+#define SPEC_USES_THRESHOLD 5
+
+struct pbo_spec_async_data {
+   uint32_t data[4]; //must be first
+   bool created;
+   unsigned uses;
+   struct util_queue_fence fence;
+   nir_shader *nir;
+   struct pipe_shader_state *cs;
+};
+
 struct pbo_async_data {
    struct st_context *st;
    enum pipe_texture_target target;
    unsigned num_components;
    struct util_queue_fence fence;
    nir_shader *nir;
+   nir_shader *copy; //immutable
    struct pipe_shader_state *cs;
+   struct set specialized;
 };
 
 #define BGR_FORMAT(NAME) \
@@ -791,6 +804,52 @@ create_conversion_shader_async(void *data, void *gdata, int thread_index)
 {
    struct pbo_async_data *async = data;
    async->nir = create_conversion_shader(async->st, async->target, async->num_components);
+   /* this is hefty, but specialized shaders need a base to work from */
+   async->copy = nir_shader_clone(NULL, async->nir);
+}
+
+static void
+create_spec_shader_async(void *data, void *gdata, int thread_index)
+{
+   struct pbo_spec_async_data *spec = data;
+   /* this is still the immutable clone: create our own copy */
+   spec->nir = nir_shader_clone(NULL, spec->nir);
+   /* do not inline geometry */
+   uint16_t offsets[2] = {2, 3};
+   nir_inline_uniforms(spec->nir, ARRAY_SIZE(offsets), &spec->data[2], offsets);
+   spec->created = true;
+}
+
+static uint32_t
+hash_pbo_data(const void *data)
+{
+   const struct pbo_data *p = data;
+   return _mesa_hash_data(&p->vec[2], sizeof(uint32_t) * 2);
+}
+
+static bool
+equals_pbo_data(const void *a, const void *b)
+{
+   const struct pbo_data *pa = a, *pb = b;
+   return !memcmp(&pa->vec[2], &pb->vec[2], sizeof(uint32_t) * 2);
+}
+
+static struct pbo_spec_async_data *
+add_spec_data(struct pbo_async_data *async, struct pbo_data *pd)
+{
+   bool found = false;
+   struct pbo_spec_async_data *spec;
+   struct set_entry *entry = _mesa_set_search_or_add(&async->specialized, pd, &found);
+   if (!found) {
+      spec = calloc(1, sizeof(struct pbo_async_data));
+      spec->nir = async->copy;
+      util_queue_fence_init(&spec->fence);
+      memcpy(spec->data, pd, sizeof(struct pbo_data));
+      entry->key = spec;
+   }
+   spec = (void*)entry->key;
+   spec->uses++;
+   return spec;
 }
 
 static struct pipe_resource *
@@ -844,6 +903,7 @@ download_texture_compute(struct st_context *st,
    if (he) {
       if (screen->create_shader_nir_async) {
          struct pbo_async_data *async = he->data;
+         struct pbo_spec_async_data *spec = add_spec_data(async, &pd);
          if (!util_queue_fence_is_signalled(&async->fence))
             return NULL;
          /* nir is definitely done */
@@ -862,6 +922,26 @@ download_texture_compute(struct st_context *st,
              !screen->is_parallel_shader_compilation_finished(screen, async->cs, MESA_SHADER_COMPUTE))
             return NULL;
          cs = async->cs;
+         if (spec->uses > SPEC_USES_THRESHOLD && util_queue_fence_is_signalled(&spec->fence)) {
+            if (spec->created) {
+               if (!spec->cs) {
+                  struct pipe_compute_state state = {0};
+                  state.ir_type = PIPE_SHADER_IR_NIR;
+                  state.req_local_mem = spec->nir->info.shared_size;
+                  state.prog = spec->nir;
+                  spec->cs = pipe->create_compute_state(pipe, &state);
+               }
+               if (screen->is_parallel_shader_compilation_finished &&
+                   screen->is_parallel_shader_compilation_finished(screen, spec->cs, MESA_SHADER_COMPUTE)) {
+                  cs = spec->cs;
+                  cb.buffer_size = 2 * sizeof(uint32_t);
+               }
+            } else {
+               screen->create_shader_nir_async(screen, spec, &spec->fence, create_spec_shader_async);
+            }
+         }
+      } else {
+         cs = he->data;
       }
    } else {
       if (screen->create_shader_nir_async) {
@@ -874,6 +954,9 @@ download_texture_compute(struct st_context *st,
          util_queue_fence_init(&async->fence);
          screen->create_shader_nir_async(screen, async, &async->fence, create_conversion_shader_async);
          _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, async);
+
+         _mesa_set_init(&async->specialized, NULL, hash_pbo_data, equals_pbo_data);
+         add_spec_data(async, &pd);
          return NULL;
       } else {
          nir_shader *nir = create_conversion_shader(st, view_target, num_components);
@@ -1216,8 +1299,21 @@ st_pbo_compute_deinit(struct st_context *st)
       if (screen->create_shader_nir_async) {
          struct pbo_async_data *async = entry->data;
          util_queue_fence_wait(&async->fence);
-         st->pipe->delete_compute_state(st->pipe, async->cs);
+         if (async->cs)
+            st->pipe->delete_compute_state(st->pipe, async->cs);
          util_queue_fence_destroy(&async->fence);
+         ralloc_free(async->copy);
+         set_foreach_remove(&async->specialized, se) {
+            struct pbo_spec_async_data *spec = (void*)se->key;
+            util_queue_fence_wait(&spec->fence);
+            util_queue_fence_destroy(&spec->fence);
+            if (spec->created) {
+               ralloc_free(spec->nir);
+               st->pipe->delete_compute_state(st->pipe, spec->cs);
+            }
+            free(spec);
+         }
+         ralloc_free(async->specialized.table);
          free(async);
       } else {
          st->pipe->delete_compute_state(st->pipe, entry->data);
-- 
GitLab


From b1c571b38d7e6ca3cd0d035a1960936cba5ace5b Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 5 Aug 2021 15:22:06 -0400
Subject: [PATCH 7/7] mesa/st: add MESA_COMPUTE_PBO env var

this adds a variable which, when set, overrides the return of the
pipe_screen::is_compute_copy_faster hook to force using compute shader
downloads even on drivers that don't export the cap/hook, enabling easier
testing

it also adds MESA_COMPUTE_PBO=spec to force always using specialized pbo variants
---
 src/mesa/state_tracker/st_cb_texture.c  |  4 +-
 src/mesa/state_tracker/st_context.h     |  2 +
 src/mesa/state_tracker/st_pbo.c         |  8 ++-
 src/mesa/state_tracker/st_pbo_compute.c | 67 +++++++++++++++++++------
 4 files changed, 63 insertions(+), 18 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 2515c54bc3cc..47fbf17754fd 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -2423,6 +2423,8 @@ st_GetTexSubImage(struct gl_context * ctx,
           texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);
 
    st_flush_bitmap_cache(st);
+   if (st->force_compute_based_texture_transfer)
+      goto non_blit_transfer;
 
    /* GetTexImage only returns a single face for cubemaps. */
    if (gl_target == GL_TEXTURE_CUBE_MAP) {
@@ -2532,7 +2534,7 @@ st_GetTexSubImage(struct gl_context * ctx,
 non_blit_transfer:
    if (done)
       return;
-   if (st->allow_compute_based_texture_transfer) {
+   if (st->allow_compute_based_texture_transfer || st->force_compute_based_texture_transfer) {
       if (st_GetTexSubImage_shader(ctx, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels, texImage))
          return;
    }
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 005d18988cea..008aa900df9b 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -145,6 +145,8 @@ struct st_context
    boolean has_astc_5x5_ldr;
    boolean prefer_blit_based_texture_transfer;
    boolean allow_compute_based_texture_transfer;
+   boolean force_compute_based_texture_transfer;
+   boolean force_specialized_compute_transfer;
    boolean force_persample_in_shader;
    boolean has_shareable_shaders;
    boolean has_half_float_packing;
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index 27ef99162828..210bba4624e9 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -690,7 +690,13 @@ st_init_pbo_helpers(struct st_context *st)
    memset(&st->pbo.raster, 0, sizeof(struct pipe_rasterizer_state));
    st->pbo.raster.half_pixel_center = 1;
 
-   if (st->allow_compute_based_texture_transfer)
+   const char *pbo = debug_get_option("MESA_COMPUTE_PBO", NULL);
+   if (pbo) {
+      st->force_compute_based_texture_transfer = true;
+      st->force_specialized_compute_transfer = !strncmp(pbo, "spec", 4);
+   }
+
+   if (st->allow_compute_based_texture_transfer || st->force_compute_based_texture_transfer)
       st->pbo.shaders = _mesa_hash_table_create_u32_keys(NULL);
 }
 
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 25f1c8e728cb..94a03431d543 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -852,6 +852,21 @@ add_spec_data(struct pbo_async_data *async, struct pbo_data *pd)
    return spec;
 }
 
+static struct pbo_async_data *
+add_async_data(struct st_context *st, enum pipe_texture_target view_target, unsigned num_components, uint32_t hash_key)
+{
+   struct pbo_async_data *async = malloc(sizeof(struct pbo_async_data));
+   async->st = st;
+   async->target = view_target;
+   async->num_components = num_components;
+   async->nir = NULL;
+   async->cs = NULL;
+   util_queue_fence_init(&async->fence);
+   _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, async);
+   _mesa_set_init(&async->specialized, NULL, hash_pbo_data, equals_pbo_data);
+   return async;
+}
+
 static struct pipe_resource *
 download_texture_compute(struct st_context *st,
                          const struct gl_pixelstore_attrib *pack,
@@ -901,7 +916,22 @@ download_texture_compute(struct st_context *st,
    struct hash_entry *he = _mesa_hash_table_search(st->pbo.shaders, (void*)(uintptr_t)hash_key);
    void *cs = NULL;
    if (he) {
-      if (screen->create_shader_nir_async) {
+      /* disable async if MESA_COMPUTE_PBO is set */
+      if (st->force_specialized_compute_transfer) {
+         struct pbo_async_data *async = he->data;
+         struct pbo_spec_async_data *spec = add_spec_data(async, &pd);
+         if (spec->cs) {
+            cs = spec->cs;
+         } else {
+            create_spec_shader_async(spec, NULL, 0);
+            struct pipe_shader_state state = {
+               .type = PIPE_SHADER_IR_NIR,
+               .ir.nir = spec->nir,
+            };
+            cs = spec->cs = st_create_nir_shader(st, &state);
+         }
+         cb.buffer_size = 2 * sizeof(uint32_t);
+      } else if (!st->force_compute_based_texture_transfer && screen->create_shader_nir_async) {
          struct pbo_async_data *async = he->data;
          struct pbo_spec_async_data *spec = add_spec_data(async, &pd);
          if (!util_queue_fence_is_signalled(&async->fence))
@@ -944,30 +974,33 @@ download_texture_compute(struct st_context *st,
          cs = he->data;
       }
    } else {
-      if (screen->create_shader_nir_async) {
-         struct pbo_async_data *async = malloc(sizeof(struct pbo_async_data));
-         async->st = st;
-         async->target = view_target;
-         async->num_components = num_components;
-         async->nir = NULL;
-         async->cs = NULL;
-         util_queue_fence_init(&async->fence);
+      if (!st->force_compute_based_texture_transfer && screen->create_shader_nir_async) {
+         struct pbo_async_data *async = add_async_data(st, view_target, num_components, hash_key);
          screen->create_shader_nir_async(screen, async, &async->fence, create_conversion_shader_async);
-         _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, async);
-
-         _mesa_set_init(&async->specialized, NULL, hash_pbo_data, equals_pbo_data);
          add_spec_data(async, &pd);
          return NULL;
+      }
+
+      if (st->force_specialized_compute_transfer) {
+         struct pbo_async_data *async = add_async_data(st, view_target, num_components, hash_key);
+         create_conversion_shader_async(async, NULL, 0);
+         struct pbo_spec_async_data *spec = add_spec_data(async, &pd);
+         create_spec_shader_async(spec, NULL, 0);
+         struct pipe_shader_state state = {
+            .type = PIPE_SHADER_IR_NIR,
+            .ir.nir = spec->nir,
+         };
+         cs = spec->cs = st_create_nir_shader(st, &state);
+         cb.buffer_size = 2 * sizeof(uint32_t);
       } else {
          nir_shader *nir = create_conversion_shader(st, view_target, num_components);
          struct pipe_shader_state state = {
             .type = PIPE_SHADER_IR_NIR,
             .ir.nir = nir,
          };
-
          cs = st_create_nir_shader(st, &state);
+         he = _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, cs);
       }
-      he = _mesa_hash_table_insert(st->pbo.shaders, (void*)(uintptr_t)hash_key, cs);
    }
    assert(cs);
    struct cso_context *cso = st->cso_context;
@@ -1256,7 +1289,8 @@ st_GetTexSubImage_shader(struct gl_context * ctx,
    }
 
    /* check with the driver to see if memcpy is likely to be faster */
-   if (!screen->is_compute_copy_faster(screen, src_format, dst_format, width, height, depth, true))
+   if (!st->force_compute_based_texture_transfer &&
+       !screen->is_compute_copy_faster(screen, src_format, dst_format, width, height, depth, true))
       return false;
 
    view_target = get_target_from_texture(src);
@@ -1296,7 +1330,8 @@ st_pbo_compute_deinit(struct st_context *st)
    if (!st->pbo.shaders)
       return;
    hash_table_foreach(st->pbo.shaders, entry) {
-      if (screen->create_shader_nir_async) {
+      if (st->force_specialized_compute_transfer ||
+          (!st->force_compute_based_texture_transfer && screen->create_shader_nir_async)) {
          struct pbo_async_data *async = entry->data;
          util_queue_fence_wait(&async->fence);
          if (async->cs)
-- 
GitLab

