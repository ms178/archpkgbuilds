From 98ce520524586bb323f729ca3d7a1fbd42ba88b8 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Fri, 18 Feb 2022 16:59:03 -0800
Subject: [PATCH 01/11] nir/algebraic: Catch some kinds of copy-and-paste bugs
 in algebraic patterns
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

A later commit adds a pattern

   (('umin', ('iand', a, '#b(is_pos_power_of_two)'),
             ('iand', c, '#b(is_pos_power_of_two)')),
    ('iand', ('iand', a, b), ('iand', c, b))),

When I originally made that pattern, I copied and pasted the search to
the replacement as

  (('umin', ('iand', a, '#b(is_pos_power_of_two)'),
            ('iand', c, '#b(is_pos_power_of_two)')),
   ('iand', ('iand', a, '#b(is_pos_power_of_two)'),
            ('iand', c, '#b(is_pos_power_of_two)'))),

The caused the variables in the replacement to be marked is_constant,
and that resulted in an assertion failure deep inside nir_search.

    src/compiler/nir/nir_search.c:530: construct_value: Assertion `!var->is_constant' failed.

These extra validation rules catch this kind of error at compile time
rather than at run time.

Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_algebraic.py | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/compiler/nir/nir_algebraic.py b/src/compiler/nir/nir_algebraic.py
index 9a4e80543455..c4303a215221 100644
--- a/src/compiler/nir/nir_algebraic.py
+++ b/src/compiler/nir/nir_algebraic.py
@@ -739,6 +739,17 @@ class BitSizeValidator(object):
       if isinstance(val, Expression):
          for src in val.sources:
             self.validate_replace(src, search)
+      elif isinstance(val, Variable):
+          # These catch problems when someone copies and pastes the search
+          # into the replacement.
+          assert not val.is_constant, \
+              'Replacement variables must not be marked constant.'
+
+          assert val.cond_index == -1, \
+              'Replacement variables must not have a condition.'
+
+          assert not val.required_type, \
+              'Replacement variables must not have a required type.'
 
    def validate(self, search, replace):
       self.is_search = True
-- 
GitLab


From 13e01770b470c1d0107ddcf478c0e74781c302a1 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Wed, 14 Jul 2021 19:48:11 -0700
Subject: [PATCH 02/11] nir/algebraic: Remove redundant i2b(-x) pattern
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The exact same pattern appears later (around line 1323).

No shader-db or fossil-db changes on any Intel platform.

Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_opt_algebraic.py | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index c851cd76c728..28a36fc800da 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -136,7 +136,6 @@ optimizations = [
    (('iabs', ('iabs', a)), ('iabs', a)),
    (('iabs', ('ineg', a)), ('iabs', a)),
    (('f2b', ('fneg', a)), ('f2b', a)),
-   (('i2b', ('ineg', a)), ('i2b', a)),
    (('~fadd', a, 0.0), a),
    # a+0.0 is 'a' unless 'a' is denormal or -0.0. If it's only used by a
    # floating point instruction, they should flush any input denormals and we
-- 
GitLab


From 957464c3c3e3239f29ce4ba1a994d5816f98f380 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 09:19:25 -0800
Subject: [PATCH 03/11] nir/algebraic: Remove redundant i2b(b2i(x)) patterns
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

A loop below already adds all the permutations... including the 1-bit
version that isn't included in this group.

No shader-db or fossil-db changes on any Intel platform.

Reviewed-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>
Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_opt_algebraic.py | 2 --
 1 file changed, 2 deletions(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 28a36fc800da..5173d427b184 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -1345,8 +1345,6 @@ optimizations.extend([
     ('ineg', ('b2i', ('iand', a, b)))),
 
    # Conversions
-   (('i2b16', ('b2i', 'a@16')), a),
-   (('i2b32', ('b2i', 'a@32')), a),
    (('f2i', ('ftrunc', a)), ('f2i', a)),
    (('f2u', ('ftrunc', a)), ('f2u', a)),
    (('i2b', ('ineg', a)), ('i2b', a)),
-- 
GitLab


From b7044ba3ee96fc80f2473ac5b9a8c9ae93f1c9e3 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 09:24:14 -0800
Subject: [PATCH 04/11] nir/algebraic: Reassociate some iand to eliminate an
 operation
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

No shader-db changes on any Intel platform.

On fossil-db, this also prevents about 46,000 small regressions when
i2b(x) operations are always lowered to (x != 0).

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 143625691 -> 143625668 (-0.0%)
Instructions helped: 1

Cycles in all programs: 8440090702 -> 8440090600 (-0.0%)
Cycles helped: 1

Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_opt_algebraic.py | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 5173d427b184..cd1749bd6f8d 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -871,6 +871,9 @@ optimizations.extend([
    # This is how SpvOpFOrdNotEqual might be implemented.  If both values are
    # numbers, then it can be replaced with fneu.
    (('ior', ('flt', 'a(is_a_number)', 'b(is_a_number)'), ('flt', b, a)), ('fneu', a, b)),
+
+   (('umin', ('iand', a, '#b(is_pos_power_of_two)'), ('iand', c, '#b(is_pos_power_of_two)')),
+    ('iand', ('iand', a, b), ('iand', c, b))),
 ])
 
 # Float sizes
@@ -1226,6 +1229,8 @@ optimizations.extend([
    (('ior', ('ior', a, b), b), ('ior', a, b)),
    (('iand', ('ior', a, b), b), b),
    (('iand', ('iand', a, b), b), ('iand', a, b)),
+   (('iand', ('iand(is_used_once)', a, b), ('iand(is_used_once)', a, c)),
+    ('iand', a, ('iand', b, c))),
    # DeMorgan's Laws
    (('iand', ('inot', a), ('inot', b)), ('inot', ('ior',  a, b))),
    (('ior',  ('inot', a), ('inot', b)), ('inot', ('iand', a, b))),
-- 
GitLab


From 809d27cd63111e230bb79ed7b2b1e017f0545168 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 15:32:00 -0800
Subject: [PATCH 05/11] nir/algebraic: Simplify min and max of b2i
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This prevents ~400 shader-db regresssions and a handful of fossil-db
regressions after i2b is always lowered.

All Ivy Bridge and newer Intel platforms had similar results. (Ice Lake shown)
total cycles in shared programs: 861019414 -> 861018506 (<.01%)
cycles in affected programs: 52021 -> 51113 (-1.75%)
helped: 7
HURT: 2
helped stats (abs) min: 8 max: 870 x̄: 133.14 x̃: 12
helped stats (rel) min: 0.11% max: 19.19% x̄: 2.92% x̃: 0.20%
HURT stats (abs)   min: 2 max: 22 x̄: 12.00 x̃: 12
HURT stats (rel)   min: 0.03% max: 0.25% x̄: 0.14% x̃: 0.14%
95% mean confidence interval for cycles value: -322.75 120.97
95% mean confidence interval for cycles %-change: -7.13% 2.65%
Inconclusive result (value mean confidence interval includes 0).

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 143625668 -> 143625592 (-0.0%)
Instructions helped: 14

Cycles in all programs: 8440090600 -> 8440101198 (+0.0%)
Cycles helped: 12
Cycles hurt: 2

Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_opt_algebraic.py | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index cd1749bd6f8d..f3d2fde2b46e 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -1348,6 +1348,11 @@ optimizations.extend([
     ('ineg', ('b2i', ('ior', a, b)))),
    (('umin', ('ineg', ('b2i', 'a@1')), ('ineg', ('b2i', 'b@1'))),
     ('ineg', ('b2i', ('iand', a, b)))),
+   (('umax', ('b2i', 'a@1'), ('b2i', 'b@1')), ('b2i', ('ior',  a, b))),
+   (('umin', ('b2i', 'a@1'), ('b2i', 'b@1')), ('b2i', ('iand', a, b))),
+
+   (('ine', ('umin', ('ineg', ('b2i', 'a@1')), b), 0), ('iand', a, ('ine', b, 0))),
+   (('ine', ('umax', ('ineg', ('b2i', 'a@1')), b), 0), ('ior' , a, ('ine', b, 0))),
 
    # Conversions
    (('f2i', ('ftrunc', a)), ('f2i', a)),
-- 
GitLab


From 923823e649e1871d1d99a073416ec1d3ee0efd06 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 8 May 2018 09:53:17 -0700
Subject: [PATCH 06/11] nir/algebraic: Eliminate unary op on src of integer
 comparison w/ zero
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This helps because it enables cmod propagation to do more.

The removed patterns involving b2i will be handled by other existing
patterns after the unary operations are removed.

All Intel platforms had similar results. (Ice Lake shown)
total instructions in shared programs: 20119086 -> 20119075 (<.01%)
instructions in affected programs: 6019 -> 6008 (-0.18%)
helped: 17
HURT: 2
helped stats (abs) min: 1 max: 1 x̄: 1.00 x̃: 1
helped stats (rel) min: 0.28% max: 0.56% x̄: 0.32% x̃: 0.30%
HURT stats (abs)   min: 3 max: 3 x̄: 3.00 x̃: 3
HURT stats (rel)   min: 1.18% max: 1.18% x̄: 1.18% x̃: 1.18%
95% mean confidence interval for instructions value: -1.19 0.03
95% mean confidence interval for instructions %-change: -0.39% 0.07%
Inconclusive result (value mean confidence interval includes 0).

total cycles in shared programs: 861018506 -> 860871987 (-0.02%)
cycles in affected programs: 324290240 -> 324143721 (-0.05%)
helped: 332
HURT: 37
helped stats (abs) min: 2 max: 18609 x̄: 534.62 x̃: 300
helped stats (rel) min: <.01% max: 2.03% x̄: 0.08% x̃: 0.03%
HURT stats (abs)   min: 7 max: 7698 x̄: 837.16 x̃: 362
HURT stats (rel)   min: <.01% max: 3.87% x̄: 0.37% x̃: 0.06%
95% mean confidence interval for cycles value: -528.81 -265.33
95% mean confidence interval for cycles %-change: -0.07% <.01%
Cycles are helped.

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 143625592 -> 143625573 (-0.0%)
Instructions helped: 4
Instructions hurt: 3

SENDs in all programs: 6980289 -> 6980283 (-0.0%)
SENDs helped: 1

Cycles in all programs: 8440101198 -> 8440085860 (-0.0%)
Cycles helped: 7
Cycles hurt: 8

In the shader that was helped for sends, it appears that a NIR pass that
moves code out of loops was able to move 3 send operations outside a
loop after this change.  I did not investigate further.

Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_opt_algebraic.py | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index f3d2fde2b46e..cd60e25d0511 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -534,6 +534,11 @@ optimizations.extend([
    (('fneu', ('fneg', a), -1.0), ('fneu', 1.0, a)),
    (('feq', -1.0, ('fneg', a)), ('feq', a, 1.0)),
 
+   (('ieq', ('ineg', a), 0),  ('ieq', a, 0)),
+   (('ine', ('ineg', a), 0),  ('ine', a, 0)),
+   (('ieq', ('iabs', a), 0),  ('ieq', a, 0)),
+   (('ine', ('iabs', a), 0),  ('ine', a, 0)),
+
    # b < fsat(NaN) -> b < 0 -> false, and b < Nan -> false.
    (('flt', '#b(is_gt_0_and_lt_1)', ('fsat(is_used_once)', a)), ('flt', b, a)),
 
@@ -1329,9 +1334,7 @@ optimizations.extend([
     ('ineg', ('b2i', ('iand', a, b)))),
    (('ior', ('ineg', ('b2i','a@1')), ('ineg', ('b2i', 'b@1'))),
     ('ineg', ('b2i', ('ior', a, b)))),
-   (('ieq', ('ineg', ('b2i', 'a@1')), 0), ('inot', a)),
    (('ieq', ('ineg', ('b2i', 'a@1')), -1), a),
-   (('ine', ('ineg', ('b2i', 'a@1')), 0), a),
    (('ine', ('ineg', ('b2i', 'a@1')), -1), ('inot', a)),
    (('ige', ('ineg', ('b2i', 'a@1')), 0), ('inot', a)),
    (('ilt', ('ineg', ('b2i', 'a@1')), 0), a),
-- 
GitLab


From e5a40c7211969ab078fabd4f992007ac1c0b3bad Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 11:02:07 -0800
Subject: [PATCH 07/11] nir/algebraic: Optimize some b2i involved in masking
 operations
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

v2: Remove the ineg from the b2i in the ior pattern.  Suggested by
Jason.

All Ivy Bridge and newer Intel platforms had similar results. (Ice Lake shown)
total instructions in shared programs: 20119075 -> 20119003 (<.01%)
instructions in affected programs: 64319 -> 64247 (-0.11%)
helped: 24
HURT: 0
helped stats (abs) min: 3 max: 3 x̄: 3.00 x̃: 3
helped stats (rel) min: 0.10% max: 0.12% x̄: 0.11% x̃: 0.11%
95% mean confidence interval for instructions value: -3.00 -3.00
95% mean confidence interval for instructions %-change: -0.11% -0.11%
Instructions are helped.

total cycles in shared programs: 860871987 -> 860864879 (<.01%)
cycles in affected programs: 11260012 -> 11252904 (-0.06%)
helped: 22
HURT: 2
helped stats (abs) min: 660 max: 1360 x̄: 806.73 x̃: 790
helped stats (rel) min: 0.12% max: 0.26% x̄: 0.17% x̃: 0.18%
HURT stats (abs)   min: 5320 max: 5320 x̄: 5320.00 x̃: 5320
HURT stats (rel)   min: 1.01% max: 1.01% x̄: 1.01% x̃: 1.01%
95% mean confidence interval for cycles value: -1029.26 436.92
95% mean confidence interval for cycles %-change: -0.22% 0.07%
Inconclusive result (value mean confidence interval includes 0).

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 143541799 -> 143470689 (-0.0%)
Instructions helped: 15200
Instructions hurt: 4

Cycles in all programs: 8438548356 -> 8439155857 (+0.0%)
Cycles helped: 14320
Cycles hurt: 873

Gained: 130
Lost: 266

Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_opt_algebraic.py | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index cd60e25d0511..073e28c8361d 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -1058,6 +1058,19 @@ optimizations.extend([
    (('ine', ('ineg', ('b2i', 'a@1')), ('ineg', ('b2i', 'b@1'))), ('ine', a, b)),
    (('b2i', ('ine', 'a@1', 'b@1')), ('b2i', ('ixor', a, b))),
 
+   (('ishl', ('b2i32', ('ine', ('iand', 'a@32', '#b(is_pos_power_of_two)'), 0)), '#c'),
+    ('bcsel', ('ige', ('iand', c, 31), ('find_lsb', b)),
+              ('ishl', ('iand', a, b), ('iadd', ('iand', c, 31), ('ineg', ('find_lsb', b)))),
+              ('ushr', ('iand', a, b), ('iadd', ('ineg', ('iand', c, 31)), ('find_lsb', b)))
+    )
+   ),
+
+   (('b2i32', ('ine', ('iand', 'a@32', '#b(is_pos_power_of_two)'), 0)),
+    ('ushr', ('iand', a, b), ('find_lsb', b)), '!options->lower_bitops'),
+
+   (('ior',  ('b2i', a), ('iand', b, 1)), ('iand', ('ior', ('b2i', a), b), 1)),
+   (('iand', ('b2i', a), ('iand', b, 1)), ('iand', ('b2i', a), b)),
+
    # This pattern occurs coutresy of __flt64_nonnan in the soft-fp64 code.
    # The first part of the iand comes from the !__feq64_nonnan.
    #
-- 
GitLab


From 364ffb32c88e84d9bbd61a32ea0fc9794448ed12 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 15:24:49 -0800
Subject: [PATCH 08/11] nir: Use nir_i2b wrapper everywhere instead of using
 nir_i2b1 directly
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

No shader-db or fossil-db changes on any Intel platform.

v2: Add missed i2b1 in ir3_nir_opt_preamble.c.

Reviewed-by: Jason Ekstrand <jason.ekstrand@collabora.com>
Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_conversion_builder.h    |  2 +-
 src/compiler/nir/nir_lower_fp16_conv.c       | 10 +++++-----
 src/compiler/spirv/spirv_to_nir.c            |  4 ++--
 src/freedreno/ir3/ir3_nir_opt_preamble.c     |  2 +-
 src/freedreno/vulkan/tu_clear_blit.c         |  6 +++---
 src/gallium/drivers/d3d12/d3d12_nir_passes.c |  2 +-
 src/microsoft/compiler/dxil_nir.c            |  2 +-
 7 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/src/compiler/nir/nir_conversion_builder.h b/src/compiler/nir/nir_conversion_builder.h
index c124e2650f0e..21d8e8b20d1a 100644
--- a/src/compiler/nir/nir_conversion_builder.h
+++ b/src/compiler/nir/nir_conversion_builder.h
@@ -133,7 +133,7 @@ nir_round_int_to_float(nir_builder *b, nir_ssa_def *src,
 
    if (src_type == nir_type_int) {
       nir_ssa_def *sign =
-         nir_i2b1(b, nir_ishr(b, src, nir_imm_int(b, src->bit_size - 1)));
+         nir_i2b(b, nir_ishr(b, src, nir_imm_int(b, src->bit_size - 1)));
       nir_ssa_def *abs = nir_iabs(b, src);
       nir_ssa_def *positive_rounded =
          nir_round_int_to_float(b, abs, nir_type_uint, dest_bit_size, round);
diff --git a/src/compiler/nir/nir_lower_fp16_conv.c b/src/compiler/nir/nir_lower_fp16_conv.c
index c2808a9ddd95..2f6862731a38 100644
--- a/src/compiler/nir/nir_lower_fp16_conv.c
+++ b/src/compiler/nir/nir_lower_fp16_conv.c
@@ -115,11 +115,11 @@ float_to_half_impl(nir_builder *b, nir_ssa_def *src, nir_rounding_mode mode)
          break;
       case nir_rounding_mode_ru:
          /* Negative becomes max float, positive becomes inf */
-         overflowed_fp16 = nir_bcsel(b, nir_i2b1(b, sign), nir_imm_int(b, 0x7BFF), nir_imm_int(b, 0x7C00));
+         overflowed_fp16 = nir_bcsel(b, nir_i2b(b, sign), nir_imm_int(b, 0x7BFF), nir_imm_int(b, 0x7C00));
          break;
       case nir_rounding_mode_rd:
          /* Negative becomes inf, positive becomes max float */
-         overflowed_fp16 = nir_bcsel(b, nir_i2b1(b, sign), nir_imm_int(b, 0x7C00), nir_imm_int(b, 0x7BFF));
+         overflowed_fp16 = nir_bcsel(b, nir_i2b(b, sign), nir_imm_int(b, 0x7C00), nir_imm_int(b, 0x7BFF));
          break;
       default: unreachable("Should've been handled already");
       }
@@ -158,12 +158,12 @@ float_to_half_impl(nir_builder *b, nir_ssa_def *src, nir_rounding_mode mode)
    nir_ssa_def *underflowed_fp16 = zero;
    if (mode == nir_rounding_mode_ru ||
        mode == nir_rounding_mode_rd) {
-      nir_push_if(b, nir_i2b1(b, abs));
+      nir_push_if(b, nir_i2b(b, abs));
 
       if (mode == nir_rounding_mode_ru)
-         underflowed_fp16 = nir_bcsel(b, nir_i2b1(b, sign), zero, one);
+         underflowed_fp16 = nir_bcsel(b, nir_i2b(b, sign), zero, one);
       else
-         underflowed_fp16 = nir_bcsel(b, nir_i2b1(b, sign), one, zero);
+         underflowed_fp16 = nir_bcsel(b, nir_i2b(b, sign), one, zero);
 
       nir_push_else(b, NULL);
       nir_pop_if(b, NULL);
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index ca2e92ab148a..b29a8b8b816e 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -3844,7 +3844,7 @@ vtn_handle_atomics(struct vtn_builder *b, SpvOp opcode,
    nir_builder_instr_insert(&b->nb, &atomic->instr);
 
    if (opcode == SpvOpAtomicFlagTestAndSet) {
-      vtn_push_nir_ssa(b, w[2], nir_i2b1(&b->nb, &atomic->dest.ssa));
+      vtn_push_nir_ssa(b, w[2], nir_i2b(&b->nb, &atomic->dest.ssa));
    }
    if (after_semantics)
       vtn_emit_memory_barrier(b, scope, after_semantics);
@@ -5788,7 +5788,7 @@ vtn_handle_ray_query_intrinsic(struct vtn_builder *b, SpvOp opcode,
    case SpvOpRayQueryGetIntersectionWorldToObjectKHR:
       ray_query_load_intrinsic_create(b, opcode, w,
                                       vtn_ssa_value(b, w[3])->def,
-                                      nir_i2b1(&b->nb, vtn_ssa_value(b, w[4])->def));
+                                      nir_i2b(&b->nb, vtn_ssa_value(b, w[4])->def));
       break;
 
    case SpvOpRayQueryGetRayTMinKHR:
diff --git a/src/freedreno/ir3/ir3_nir_opt_preamble.c b/src/freedreno/ir3/ir3_nir_opt_preamble.c
index a36c14130bf8..43f757f9722b 100644
--- a/src/freedreno/ir3/ir3_nir_opt_preamble.c
+++ b/src/freedreno/ir3/ir3_nir_opt_preamble.c
@@ -335,7 +335,7 @@ ir3_nir_lower_preamble(nir_shader *nir, struct ir3_shader_variant *v)
                              .base = offset);
 
          if (dest->bit_size == 1) {
-            new_dest = nir_i2b1(b, new_dest);
+            new_dest = nir_i2b(b, new_dest);
          } else if (dest->bit_size != 32) {
             assert(dest->bit_size == 16);
             if (all_uses_float(dest, true)) {
diff --git a/src/freedreno/vulkan/tu_clear_blit.c b/src/freedreno/vulkan/tu_clear_blit.c
index 645b34dc7797..81b5027cb23f 100644
--- a/src/freedreno/vulkan/tu_clear_blit.c
+++ b/src/freedreno/vulkan/tu_clear_blit.c
@@ -379,7 +379,7 @@ build_blit_vs_shader(void)
    nir_ssa_def *vert1_pos = load_const(b, 4, 2);
    nir_ssa_def *vertex = nir_load_vertex_id(b);
 
-   nir_ssa_def *pos = nir_bcsel(b, nir_i2b1(b, vertex), vert1_pos, vert0_pos);
+   nir_ssa_def *pos = nir_bcsel(b, nir_i2b(b, vertex), vert1_pos, vert0_pos);
    pos = nir_vec4(b, nir_channel(b, pos, 0),
                      nir_channel(b, pos, 1),
                      nir_imm_float(b, 0.0),
@@ -398,7 +398,7 @@ build_blit_vs_shader(void)
    /* Only used with "z scale" blit path which uses a 3d texture */
    nir_ssa_def *z_coord = load_const(b, 8, 1);
 
-   nir_ssa_def *coords = nir_bcsel(b, nir_i2b1(b, vertex), vert1_coords, vert0_coords);
+   nir_ssa_def *coords = nir_bcsel(b, nir_i2b(b, vertex), vert1_coords, vert0_coords);
    coords = nir_vec3(b, nir_channel(b, coords, 0), nir_channel(b, coords, 1),
                      z_coord);
 
@@ -425,7 +425,7 @@ build_clear_vs_shader(void)
    nir_ssa_def *depth = load_const(b, 2, 1);
    nir_ssa_def *vertex = nir_load_vertex_id(b);
 
-   nir_ssa_def *pos = nir_bcsel(b, nir_i2b1(b, vertex), vert1_pos, vert0_pos);
+   nir_ssa_def *pos = nir_bcsel(b, nir_i2b(b, vertex), vert1_pos, vert0_pos);
    pos = nir_vec4(b, nir_channel(b, pos, 0),
                      nir_channel(b, pos, 1),
                      depth, nir_imm_float(b, 1.0));
diff --git a/src/gallium/drivers/d3d12/d3d12_nir_passes.c b/src/gallium/drivers/d3d12/d3d12_nir_passes.c
index b2a28834a4fa..ee865a3d305a 100644
--- a/src/gallium/drivers/d3d12/d3d12_nir_passes.c
+++ b/src/gallium/drivers/d3d12/d3d12_nir_passes.c
@@ -413,7 +413,7 @@ invert_depth_impl(nir_builder *b, struct invert_depth_state *state)
    nir_ssa_def *pos = nir_ssa_for_src(b, intr->src[1], 4);
 
    if (state->viewport_index) {
-      nir_push_if(b, nir_i2b1(b, nir_iand_imm(b,
+      nir_push_if(b, nir_i2b(b, nir_iand_imm(b,
          nir_ishl(b, nir_imm_int(b, 1), state->viewport_index),
          state->viewport_mask)));
    }
diff --git a/src/microsoft/compiler/dxil_nir.c b/src/microsoft/compiler/dxil_nir.c
index 97a285155655..6345e5a408a1 100644
--- a/src/microsoft/compiler/dxil_nir.c
+++ b/src/microsoft/compiler/dxil_nir.c
@@ -1697,7 +1697,7 @@ lower_bool_input_impl(nir_builder *b, nir_instr *instr,
    }
 
    intr->dest.ssa.bit_size = 32;
-   return nir_i2b1(b, &intr->dest.ssa);
+   return nir_i2b(b, &intr->dest.ssa);
 }
 
 bool
-- 
GitLab


From 5b1ccf2fe377ee8389cb97c95bf2b2b7493645e4 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 15:29:42 -0800
Subject: [PATCH 09/11] nir/builder: Emit x != 0 for nir_i2b
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There are a lot of optimizations in opt_algebraic that match ('ine', a,
0), but there are almost none that match i2b.  Instead of adding a huge
pile of additional patterns (including variation that include both ine
and i2b), just emit a != 0 instead of i2b(a).

I think that the changes to the unit tests weaken them slightly, but
perhaps that's okay?

No shader-db changes on any Intel platform.  The GLSL paths use other
means to generate i2b operations, but the SPIR-V paths use nir_i2b.

v2: Use nir_ine_imm.  Suggested by Jesse.

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 142265881 -> 141912343 (-0.2%)
Instructions helped: 44639

Cycles in all programs: 8810243954 -> 8809053899 (-0.0%)
Cycles helped: 42568
Cycles hurt: 2041

Gained: 1230

Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 src/compiler/nir/nir_builder.h                         | 2 +-
 src/compiler/nir/tests/load_store_vectorizer_tests.cpp | 8 +++++---
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index bfe271645391..b90b0f9b3c29 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -1560,7 +1560,7 @@ nir_f2b(nir_builder *build, nir_ssa_def *f)
 static inline nir_ssa_def *
 nir_i2b(nir_builder *build, nir_ssa_def *i)
 {
-   return nir_i2b1(build, i);
+   return nir_ine_imm(build, i, 0);
 }
 
 static inline nir_ssa_def *
diff --git a/src/compiler/nir/tests/load_store_vectorizer_tests.cpp b/src/compiler/nir/tests/load_store_vectorizer_tests.cpp
index efe19939457f..e0d1ed987b86 100644
--- a/src/compiler/nir/tests/load_store_vectorizer_tests.cpp
+++ b/src/compiler/nir/tests/load_store_vectorizer_tests.cpp
@@ -1461,8 +1461,9 @@ TEST_F(nir_load_store_vectorize_test, shared_load_bool)
    ASSERT_EQ(deref->deref_type, nir_deref_type_var);
    ASSERT_EQ(deref->var, var);
 
-   ASSERT_TRUE(test_alu(loads[0x1]->src.ssa->parent_instr, nir_op_i2b1));
-   ASSERT_TRUE(test_alu(loads[0x2]->src.ssa->parent_instr, nir_op_i2b1));
+   /* The loaded value is converted to Boolean by (loaded != 0). */
+   ASSERT_TRUE(test_alu(loads[0x1]->src.ssa->parent_instr, nir_op_ine));
+   ASSERT_TRUE(test_alu(loads[0x2]->src.ssa->parent_instr, nir_op_ine));
    ASSERT_TRUE(test_alu_def(loads[0x1]->src.ssa->parent_instr, 0, &load->dest.ssa, 0));
    ASSERT_TRUE(test_alu_def(loads[0x2]->src.ssa->parent_instr, 0, &load->dest.ssa, 1));
 }
@@ -1500,7 +1501,8 @@ TEST_F(nir_load_store_vectorize_test, shared_load_bool_mixed)
    ASSERT_EQ(deref->deref_type, nir_deref_type_var);
    ASSERT_EQ(deref->var, var);
 
-   ASSERT_TRUE(test_alu(loads[0x1]->src.ssa->parent_instr, nir_op_i2b1));
+   /* The loaded value is converted to Boolean by (loaded != 0). */
+   ASSERT_TRUE(test_alu(loads[0x1]->src.ssa->parent_instr, nir_op_ine));
    ASSERT_TRUE(test_alu_def(loads[0x1]->src.ssa->parent_instr, 0, &load->dest.ssa, 0));
 
    EXPECT_INSTR_SWIZZLES(movs[0x2], load, "y");
-- 
GitLab


From 61bd733497b994f7efc108bb4d107ffb4d6ea119 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 22 Feb 2022 15:43:14 -0800
Subject: [PATCH 10/11] microsoft/compiler: Simplify
 nir_intrinsic_load_front_face handling

It is invalid to have Boolean variables as either shader inputs or
outputs, so there is no point to try to lower them in general.  The only
use for this was some two-phase lowering of
nir_intrinsic_load_front_face that could be done in a single phase.
Create the SYSTEM_VALUE_FRONT_FACE as a uint and compare it with zero at
the same time.

v2: Remove dxil_nir_lower_bool_input from dxil_nir.h and drop it from
the other caller in the spirv_to_dxil codepath.  Noticed by Jesse.  Fix
setting bit size when loading SYSTEM_VALUE_FRONT_FACE.  Caught by CI.

v3: Use nir_ine_imm.  Change type of gl_FrontFacing GS output in
d3d12_nir_passes from Boolean to integer.  Both suggested by Jesse.

Reviewed-by: Jesse Natalie <jenatali@microsoft.com>
---
 src/gallium/drivers/d3d12/d3d12_compiler.cpp |  1 -
 src/gallium/drivers/d3d12/d3d12_nir_passes.c |  4 +-
 src/microsoft/compiler/dxil_nir.c            | 65 +++++---------------
 src/microsoft/compiler/dxil_nir.h            |  1 -
 src/microsoft/spirv_to_dxil/dxil_spirv_nir.c |  1 -
 5 files changed, 17 insertions(+), 55 deletions(-)

diff --git a/src/gallium/drivers/d3d12/d3d12_compiler.cpp b/src/gallium/drivers/d3d12/d3d12_compiler.cpp
index 0219c6044dc3..afe6defa728e 100644
--- a/src/gallium/drivers/d3d12/d3d12_compiler.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_compiler.cpp
@@ -131,7 +131,6 @@ compile_nir(struct d3d12_context *ctx, struct d3d12_shader_selector *sel,
    NIR_PASS_V(nir, d3d12_lower_load_draw_params);
    NIR_PASS_V(nir, d3d12_lower_load_patch_vertices_in);
    NIR_PASS_V(nir, d3d12_lower_state_vars, shader);
-   NIR_PASS_V(nir, dxil_nir_lower_bool_input);
    NIR_PASS_V(nir, dxil_nir_lower_loads_stores_to_dxil);
    NIR_PASS_V(nir, dxil_nir_lower_atomics_to_dxil);
    NIR_PASS_V(nir, dxil_nir_lower_double_math);
diff --git a/src/gallium/drivers/d3d12/d3d12_nir_passes.c b/src/gallium/drivers/d3d12/d3d12_nir_passes.c
index ee865a3d305a..aa9dc294687e 100644
--- a/src/gallium/drivers/d3d12/d3d12_nir_passes.c
+++ b/src/gallium/drivers/d3d12/d3d12_nir_passes.c
@@ -129,7 +129,7 @@ lower_load_face(nir_builder *b, struct nir_instr *instr, nir_variable *var)
 
    b->cursor = nir_before_instr(&intr->instr);
 
-   nir_ssa_def *load = nir_load_var(b, var);
+   nir_ssa_def *load = nir_ine_imm(b, nir_load_var(b, var), 0);
 
    nir_ssa_def_rewrite_uses(&intr->dest.ssa, load);
    nir_instr_remove(instr);
@@ -141,7 +141,7 @@ d3d12_forward_front_face(nir_shader *nir)
    assert(nir->info.stage == MESA_SHADER_FRAGMENT);
 
    nir_variable *var = nir_variable_create(nir, nir_var_shader_in,
-                                           glsl_bool_type(),
+                                           glsl_uint_type(),
                                            "gl_FrontFacing");
    var->data.location = VARYING_SLOT_VAR12;
    var->data.interpolation = INTERP_MODE_FLAT;
diff --git a/src/microsoft/compiler/dxil_nir.c b/src/microsoft/compiler/dxil_nir.c
index 6345e5a408a1..f1c89fcee0e0 100644
--- a/src/microsoft/compiler/dxil_nir.c
+++ b/src/microsoft/compiler/dxil_nir.c
@@ -1659,54 +1659,6 @@ dxil_nir_split_typed_samplers(nir_shader *nir)
 }
 
 
-static bool
-lower_bool_input_filter(const nir_instr *instr,
-                        UNUSED const void *_options)
-{
-   if (instr->type != nir_instr_type_intrinsic)
-      return false;
-
-   nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
-   if (intr->intrinsic == nir_intrinsic_load_front_face)
-      return true;
-
-   if (intr->intrinsic == nir_intrinsic_load_deref) {
-      nir_deref_instr *deref = nir_instr_as_deref(intr->src[0].ssa->parent_instr);
-      nir_variable *var = nir_deref_instr_get_variable(deref);
-      return var->data.mode == nir_var_shader_in &&
-             glsl_get_base_type(var->type) == GLSL_TYPE_BOOL;
-   }
-
-   return false;
-}
-
-static nir_ssa_def *
-lower_bool_input_impl(nir_builder *b, nir_instr *instr,
-                      UNUSED void *_options)
-{
-   nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
-
-   if (intr->intrinsic == nir_intrinsic_load_deref) {
-      nir_deref_instr *deref = nir_instr_as_deref(intr->src[0].ssa->parent_instr);
-      nir_variable *var = nir_deref_instr_get_variable(deref);
-
-      /* rewrite var->type */
-      var->type = glsl_vector_type(GLSL_TYPE_UINT,
-                                   glsl_get_vector_elements(var->type));
-      deref->type = var->type;
-   }
-
-   intr->dest.ssa.bit_size = 32;
-   return nir_i2b(b, &intr->dest.ssa);
-}
-
-bool
-dxil_nir_lower_bool_input(struct nir_shader *s)
-{
-   return nir_shader_lower_instructions(s, lower_bool_input_filter,
-                                        lower_bool_input_impl, NULL);
-}
-
 static bool
 lower_sysval_to_load_input_impl(nir_builder *b, nir_instr *instr, void *data)
 {
@@ -1733,9 +1685,22 @@ lower_sysval_to_load_input_impl(nir_builder *b, nir_instr *instr, void *data)
    nir_variable *var = sysval_vars[sysval];
    assert(var);
 
+   const nir_alu_type dest_type = (sysval == SYSTEM_VALUE_FRONT_FACE)
+      ? nir_type_uint32 : nir_get_nir_type_for_glsl_type(var->type);
+   const unsigned bit_size = (sysval == SYSTEM_VALUE_FRONT_FACE)
+      ? 32 : intr->dest.ssa.bit_size;
+
    b->cursor = nir_before_instr(instr);
-   nir_ssa_def *result = nir_build_load_input(b, intr->dest.ssa.num_components, intr->dest.ssa.bit_size, nir_imm_int(b, 0),
-      .base = var->data.driver_location, .dest_type = nir_get_nir_type_for_glsl_type(var->type));
+   nir_ssa_def *result = nir_build_load_input(b, intr->dest.ssa.num_components, bit_size, nir_imm_int(b, 0),
+      .base = var->data.driver_location, .dest_type = dest_type);
+
+   /* The nir_type_uint32 is really a nir_type_bool32, but that type is very
+    * inconvenient at this point during compilation.  Convert to
+    * nir_type_bool1 by comparing with zero.
+    */
+   if (sysval == SYSTEM_VALUE_FRONT_FACE)
+      result = nir_ine_imm(b, result, 0);
+
    nir_ssa_def_rewrite_uses(&intr->dest.ssa, result);
    return true;
 }
diff --git a/src/microsoft/compiler/dxil_nir.h b/src/microsoft/compiler/dxil_nir.h
index a7fbf13d7f3b..b5457491893b 100644
--- a/src/microsoft/compiler/dxil_nir.h
+++ b/src/microsoft/compiler/dxil_nir.h
@@ -51,7 +51,6 @@ bool dxil_nir_lower_system_values_to_zero(nir_shader *shader,
                                           uint32_t count);
 bool dxil_nir_lower_system_values(nir_shader *shader);
 bool dxil_nir_split_typed_samplers(nir_shader *shader);
-bool dxil_nir_lower_bool_input(struct nir_shader *s);
 bool dxil_nir_lower_sysval_to_load_input(nir_shader *s, nir_variable **sysval_vars);
 bool dxil_nir_lower_vs_vertex_conversion(nir_shader *s, enum pipe_format target_formats[]);
 
diff --git a/src/microsoft/spirv_to_dxil/dxil_spirv_nir.c b/src/microsoft/spirv_to_dxil/dxil_spirv_nir.c
index bd9aaf9e6df2..bfe6199b695a 100644
--- a/src/microsoft/spirv_to_dxil/dxil_spirv_nir.c
+++ b/src/microsoft/spirv_to_dxil/dxil_spirv_nir.c
@@ -820,7 +820,6 @@ dxil_spirv_nir_passes(nir_shader *nir,
    NIR_PASS_V(nir, dxil_nir_split_clip_cull_distance);
    NIR_PASS_V(nir, dxil_nir_lower_loads_stores_to_dxil);
    NIR_PASS_V(nir, dxil_nir_split_typed_samplers);
-   NIR_PASS_V(nir, dxil_nir_lower_bool_input);
    NIR_PASS_V(nir, dxil_nir_lower_ubo_array_one_to_static);
    NIR_PASS_V(nir, nir_opt_dce);
    NIR_PASS_V(nir, nir_remove_dead_derefs);
-- 
GitLab


From b9097525545bb25786e084ed2cf32cce4b37f686 Mon Sep 17 00:00:00 2001
From: Ian Romanick <ian.d.romanick@intel.com>
Date: Tue, 15 Feb 2022 09:35:47 -0800
Subject: [PATCH 11/11] nir: Always lower i2b
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There are a lot of optimizations in opt_algebraic that match ('ine', a,
0), but there are almost none that match i2b.  Instead of adding a huge
pile of additional patterns (including variation that include both ine
and i2b), always lower i2b to a != 0.

All of the Haswell and Ivy Bridge shaders that were helped for spills
and fills were vertex shaders in Civilization VI.  I suspect the vec4
backend is just missing some optimization that the scalar backend has,
but I did not investigate further.

The failing test on d3d12 is a pre-existing bug that is triggered by
this change.  I talked to Jesse about it, and, after some analysis, he
suggested just adding it to the list of known failures.

v2: Don't rematerialize i2b instructions in dxil_nir_lower_x2b.

v3: Don't rematerialize i2b instructions in zink_nir_algebraic.py.

v4: Fix zink-on-TGL CI failures by calling nir_opt_algebraic after
nir_lower_doubles makes progress.  The latter can generate b2i
instructions, but nir_lower_int64 can't handle them (anymore).

Tiger Lake, Ice Lake, Skylake, and Broadwell had similar results. (Ice Lake shown)
Ice Lake
total instructions in shared programs: 20137738 -> 20137917 (<.01%)
instructions in affected programs: 86850 -> 87029 (0.21%)
helped: 0
HURT: 72
HURT stats (abs)   min: 1 max: 6 x̄: 2.49 x̃: 1
HURT stats (rel)   min: 0.04% max: 1.81% x̄: 0.59% x̃: 0.34%
95% mean confidence interval for instructions value: 2.01 2.96
95% mean confidence interval for instructions %-change: 0.45% 0.74%
Instructions are HURT.

total cycles in shared programs: 859977816 -> 859983001 (<.01%)
cycles in affected programs: 12497925 -> 12503110 (0.04%)
helped: 8
HURT: 85
helped stats (abs) min: 22 max: 702 x̄: 193.50 x̃: 130
helped stats (rel) min: <.01% max: 2.21% x̄: 0.36% x̃: 0.05%
HURT stats (abs)   min: 2 max: 440 x̄: 79.21 x̃: 56
HURT stats (rel)   min: <.01% max: 2.98% x̄: 1.07% x̃: 0.47%
95% mean confidence interval for cycles value: 28.65 82.85
95% mean confidence interval for cycles %-change: 0.72% 1.18%
Cycles are HURT.

Haswell and Ivy Bridge had similar results. (Haswell shown)
total instructions in shared programs: 16702182 -> 16702144 (<.01%)
instructions in affected programs: 105011 -> 104973 (-0.04%)
helped: 57
HURT: 86
helped stats (abs) min: 1 max: 16 x̄: 2.81 x̃: 1
helped stats (rel) min: 0.53% max: 5.56% x̄: 1.18% x̃: 1.18%
HURT stats (abs)   min: 1 max: 3 x̄: 1.42 x̃: 1
HURT stats (rel)   min: 0.04% max: 3.19% x̄: 0.37% x̃: 0.23%
95% mean confidence interval for instructions value: -0.80 0.26
95% mean confidence interval for instructions %-change: -0.41% -0.09%
Inconclusive result (value mean confidence interval includes 0).

total cycles in shared programs: 882390309 -> 882401172 (<.01%)
cycles in affected programs: 12901276 -> 12912139 (0.08%)
helped: 79
HURT: 107
helped stats (abs) min: 2 max: 1080 x̄: 119.30 x̃: 18
helped stats (rel) min: 0.01% max: 30.84% x̄: 1.84% x̃: 0.59%
HURT stats (abs)   min: 2 max: 2726 x̄: 189.61 x̃: 21
HURT stats (rel)   min: <.01% max: 43.10% x̄: 1.81% x̃: 0.68%
95% mean confidence interval for cycles value: -3.31 120.12
95% mean confidence interval for cycles %-change: -0.45% 0.97%
Inconclusive result (value mean confidence interval includes 0).

total spills in shared programs: 14937 -> 14925 (-0.08%)
spills in affected programs: 12 -> 0
helped: 9
HURT: 0

total fills in shared programs: 17572 -> 17560 (-0.07%)
fills in affected programs: 12 -> 0
helped: 9
HURT: 0

Sandy Bridge
total instructions in shared programs: 13936702 -> 13936708 (<.01%)
instructions in affected programs: 7314 -> 7320 (0.08%)
helped: 3
HURT: 8
helped stats (abs) min: 1 max: 2 x̄: 1.67 x̃: 2
helped stats (rel) min: 0.75% max: 0.83% x̄: 0.80% x̃: 0.83%
HURT stats (abs)   min: 1 max: 2 x̄: 1.38 x̃: 1
HURT stats (rel)   min: 0.12% max: 0.55% x̄: 0.24% x̃: 0.15%
95% mean confidence interval for instructions value: -0.47 1.56
95% mean confidence interval for instructions %-change: -0.39% 0.30%
Inconclusive result (value mean confidence interval includes 0).

total cycles in shared programs: 742432695 -> 742420923 (<.01%)
cycles in affected programs: 437816 -> 426044 (-2.69%)
helped: 28
HURT: 1
helped stats (abs) min: 11 max: 1640 x̄: 441.36 x̃: 94
helped stats (rel) min: 0.12% max: 9.45% x̄: 2.45% x̃: 1.10%
HURT stats (abs)   min: 586 max: 586 x̄: 586.00 x̃: 586
HURT stats (rel)   min: 1.55% max: 1.55% x̄: 1.55% x̃: 1.55%
95% mean confidence interval for cycles value: -645.47 -166.39
95% mean confidence interval for cycles %-change: -3.47% -1.16%
Cycles are helped.

LOST:   3
GAINED: 0

No shader-db changes on Iron Lake or GM45.

All Intel platforms had similar results. (Ice Lake shown)
Instructions in all programs: 143345836 -> 143345834 (-0.0%)
Instructions helped: 2

Cycles in all programs: 8442459275 -> 8442459239 (-0.0%)
Cycles helped: 2

Acked-by: Jesse Natalie <jenatali@microsoft.com>
Tested-by: Daniel Schürmann <daniel@schuermann.dev>
---
 .../compiler/aco_instruction_selection.cpp    |  3 +--
 src/amd/llvm/ac_nir_to_llvm.c                 |  1 -
 src/amd/vulkan/radv_pipeline.c                |  3 ++-
 src/asahi/compiler/agx_compile.c              |  1 -
 src/broadcom/compiler/nir_to_vir.c            |  6 ------
 src/compiler/nir/nir_lower_bool_to_bitsize.c  |  3 +--
 src/compiler/nir/nir_lower_bool_to_float.c    |  2 +-
 src/compiler/nir/nir_lower_bool_to_int32.c    |  2 +-
 src/compiler/nir/nir_lower_int64.c            | 14 ++++---------
 src/compiler/nir/nir_lower_int_to_float.c     |  2 +-
 src/compiler/nir/nir_opt_algebraic.py         | 21 +++++--------------
 src/freedreno/ir3/ir3_compiler_nir.c          | 10 ---------
 src/gallium/auxiliary/gallivm/lp_bld_nir.c    | 17 +--------------
 src/gallium/auxiliary/nir/nir_to_tgsi.c       |  7 -------
 .../drivers/d3d12/ci/d3d12-quick_shader.txt   |  5 +++--
 .../etnaviv/etnaviv_compiler_nir_emit.c       |  3 +--
 .../r600/sfn/sfn_emitaluinstruction.cpp       |  4 ++--
 src/gallium/drivers/vc4/vc4_program.c         |  1 -
 .../drivers/zink/nir_to_spirv/nir_to_spirv.c  |  7 -------
 .../zink/nir_to_spirv/zink_nir_algebraic.py   |  2 +-
 src/intel/compiler/brw_fs_nir.cpp             | 20 ++++++------------
 src/intel/compiler/brw_vec4_nir.cpp           |  2 +-
 src/mesa/state_tracker/st_glsl_to_nir.cpp     |  7 +++++++
 src/microsoft/compiler/dxil_nir_algebraic.py  |  3 +--
 src/nouveau/codegen/nv50_ir_from_nir.cpp      | 12 ++---------
 src/panfrost/bifrost/bifrost_compile.c        | 10 ---------
 26 files changed, 41 insertions(+), 127 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index bd027fadda68..633b3c72f805 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -3404,8 +3404,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
          bld.pseudo(aco_opcode::p_create_vector, Definition(dst), tmp, Operand::zero());
       break;
    }
-   case nir_op_b2b1:
-   case nir_op_i2b1: {
+   case nir_op_b2b1: {
       Temp src = get_alu_src(ctx, instr->src[0]);
       assert(dst.regClass() == bld.lm);
 
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 074774e982f0..03011d95c4f7 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -1114,7 +1114,6 @@ static void visit_alu(struct ac_nir_context *ctx, const nir_alu_instr *instr)
    case nir_op_b2i64:
       result = emit_b2i(&ctx->ac, src[0], instr->dest.dest.ssa.bit_size);
       break;
-   case nir_op_i2b1:
    case nir_op_b2b1: /* after loads */
       result = emit_i2b(&ctx->ac, src[0]);
       break;
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 88777beb68b9..c71fa70212f2 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -4023,10 +4023,11 @@ lower_bit_size_callback(const nir_instr *instr, void *_)
    if (nir_src_bit_size(alu->src[0].src) & (8 | 16)) {
       unsigned bit_size = nir_src_bit_size(alu->src[0].src);
       switch (alu->op) {
+      case nir_op_i2b1:
+         unreachable("Should have been lowered in opt_algebraic.");
       case nir_op_bit_count:
       case nir_op_find_lsb:
       case nir_op_ufind_msb:
-      case nir_op_i2b1:
          return 32;
       case nir_op_ilt:
       case nir_op_ige:
diff --git a/src/asahi/compiler/agx_compile.c b/src/asahi/compiler/agx_compile.c
index e787ddfc1a49..9b37d1dbe167 100644
--- a/src/asahi/compiler/agx_compile.c
+++ b/src/asahi/compiler/agx_compile.c
@@ -612,7 +612,6 @@ agx_emit_alu_bool(agx_builder *b, nir_op op,
    case nir_op_inot: return agx_xor_to(b, dst, s0, t);
 
    case nir_op_f2b1: return agx_fcmpsel_to(b, dst, s0, f, f, t, AGX_FCOND_EQ);
-   case nir_op_i2b1: return agx_icmpsel_to(b, dst, s0, f, f, t, AGX_ICOND_UEQ);
    case nir_op_b2b1: return agx_icmpsel_to(b, dst, s0, f, f, t, AGX_ICOND_UEQ);
 
    case nir_op_bcsel:
diff --git a/src/broadcom/compiler/nir_to_vir.c b/src/broadcom/compiler/nir_to_vir.c
index 2bdbccad3080..ec6b31af2767 100644
--- a/src/broadcom/compiler/nir_to_vir.c
+++ b/src/broadcom/compiler/nir_to_vir.c
@@ -1184,11 +1184,6 @@ ntq_emit_comparison(struct v3d_compile *c,
                 vir_set_pf(c, vir_SUB_dest(c, nop, src0, src1), V3D_QPU_PF_PUSHC);
                 break;
 
-        case nir_op_i2b32:
-                vir_set_pf(c, vir_MOV_dest(c, nop, src0), V3D_QPU_PF_PUSHZ);
-                cond_invert = true;
-                break;
-
         case nir_op_f2b32:
                 vir_set_pf(c, vir_FMOV_dest(c, nop, src0), V3D_QPU_PF_PUSHZ);
                 cond_invert = true;
@@ -1618,7 +1613,6 @@ ntq_emit_alu(struct v3d_compile *c, nir_alu_instr *instr)
                 break;
         }
 
-        case nir_op_i2b32:
         case nir_op_f2b32:
         case nir_op_feq32:
         case nir_op_fneu32:
diff --git a/src/compiler/nir/nir_lower_bool_to_bitsize.c b/src/compiler/nir/nir_lower_bool_to_bitsize.c
index 86b1a5ab1afe..d642fb08e3c1 100644
--- a/src/compiler/nir/nir_lower_bool_to_bitsize.c
+++ b/src/compiler/nir/nir_lower_bool_to_bitsize.c
@@ -169,8 +169,7 @@ lower_alu_instr(nir_builder *b, nir_alu_instr *alu)
       break;
 
    case nir_op_i2b1:
-      opcode = bit_size == 8 ? nir_op_i2b8 :
-                               bit_size == 16 ? nir_op_i2b16 : nir_op_i2b32;
+      unreachable("Should have been lowered in opt_algebraic.");
       break;
 
    case nir_op_b2b1:
diff --git a/src/compiler/nir/nir_lower_bool_to_float.c b/src/compiler/nir/nir_lower_bool_to_float.c
index 8247430d7d9e..abd513a15af9 100644
--- a/src/compiler/nir/nir_lower_bool_to_float.c
+++ b/src/compiler/nir/nir_lower_bool_to_float.c
@@ -66,8 +66,8 @@ lower_alu_instr(nir_builder *b, nir_alu_instr *alu)
 
    case nir_op_b2f32: alu->op = nir_op_mov; break;
    case nir_op_b2i32: alu->op = nir_op_mov; break;
+   case nir_op_i2b1: unreachable("Should have been lowered in opt_algebraic.");
    case nir_op_f2b1:
-   case nir_op_i2b1:
       rep = nir_sne(b, nir_ssa_for_alu_src(b, alu, 0),
                        nir_imm_float(b, 0));
       break;
diff --git a/src/compiler/nir/nir_lower_bool_to_int32.c b/src/compiler/nir/nir_lower_bool_to_int32.c
index c1afed492b8e..af5e8be2b89b 100644
--- a/src/compiler/nir/nir_lower_bool_to_int32.c
+++ b/src/compiler/nir/nir_lower_bool_to_int32.c
@@ -66,7 +66,7 @@ lower_alu_instr(nir_alu_instr *alu)
       break;
 
    case nir_op_f2b1: alu->op = nir_op_f2b32; break;
-   case nir_op_i2b1: alu->op = nir_op_i2b32; break;
+   case nir_op_i2b1: unreachable("Should have been lowered in opt_algebraic."); break;
 
    case nir_op_b2b32:
    case nir_op_b2b1:
diff --git a/src/compiler/nir/nir_lower_int64.c b/src/compiler/nir/nir_lower_int64.c
index da393c807c65..0c9706ef69e5 100644
--- a/src/compiler/nir/nir_lower_int64.c
+++ b/src/compiler/nir/nir_lower_int64.c
@@ -47,14 +47,6 @@ lower_b2i64(nir_builder *b, nir_ssa_def *x)
    return nir_pack_64_2x32_split(b, nir_b2i32(b, x), nir_imm_int(b, 0));
 }
 
-static nir_ssa_def *
-lower_i2b(nir_builder *b, nir_ssa_def *x)
-{
-   return nir_ine(b, nir_ior(b, nir_unpack_64_2x32_split_x(b, x),
-                                nir_unpack_64_2x32_split_y(b, x)),
-                     nir_imm_int(b, 0));
-}
-
 static nir_ssa_def *
 lower_i2i8(nir_builder *b, nir_ssa_def *x)
 {
@@ -808,8 +800,9 @@ nir_lower_int64_op_to_options_mask(nir_op opcode)
    case nir_op_imod:
    case nir_op_irem:
       return nir_lower_divmod64;
-   case nir_op_b2i64:
    case nir_op_i2b1:
+      unreachable("Should have been lowered in opt_algebraic.");
+   case nir_op_b2i64:
    case nir_op_i2i8:
    case nir_op_i2i16:
    case nir_op_i2i32:
@@ -902,7 +895,7 @@ lower_int64_alu_instr(nir_builder *b, nir_alu_instr *alu)
    case nir_op_b2i64:
       return lower_b2i64(b, src[0]);
    case nir_op_i2b1:
-      return lower_i2b(b, src[0]);
+      unreachable("Should have been lowered in opt_algebraic.");
    case nir_op_i2i8:
       return lower_i2i8(b, src[0]);
    case nir_op_i2i16:
@@ -993,6 +986,7 @@ should_lower_int64_alu_instr(const nir_alu_instr *alu,
 {
    switch (alu->op) {
    case nir_op_i2b1:
+      unreachable("Should have been lowered in opt_algebraic.");
    case nir_op_i2i8:
    case nir_op_i2i16:
    case nir_op_i2i32:
diff --git a/src/compiler/nir/nir_lower_int_to_float.c b/src/compiler/nir/nir_lower_int_to_float.c
index 6cdb53e7768a..89200118280b 100644
--- a/src/compiler/nir/nir_lower_int_to_float.c
+++ b/src/compiler/nir/nir_lower_int_to_float.c
@@ -89,7 +89,7 @@ lower_alu_instr(nir_builder *b, nir_alu_instr *alu)
    }
 
    case nir_op_f2u32: alu->op = nir_op_ffloor; break;
-   case nir_op_i2b1: alu->op = nir_op_f2b1; break;
+   case nir_op_i2b1: unreachable("Should have been lowered in opt_algebraic.");
 
    case nir_op_ilt: alu->op = nir_op_flt; break;
    case nir_op_ige: alu->op = nir_op_fge; break;
diff --git a/src/compiler/nir/nir_opt_algebraic.py b/src/compiler/nir/nir_opt_algebraic.py
index 073e28c8361d..8e80d4b49799 100644
--- a/src/compiler/nir/nir_opt_algebraic.py
+++ b/src/compiler/nir/nir_opt_algebraic.py
@@ -693,7 +693,6 @@ optimizations.extend([
    (('~bcsel', ('flt', a, b), b, a), ('fmax', a, b)),
    (('~bcsel', ('fge', a, b), b, a), ('fmin', a, b)),
    (('~bcsel', ('fge', b, a), b, a), ('fmax', a, b)),
-   (('bcsel', ('i2b', a), b, c), ('bcsel', ('ine', a, 0), b, c)),
    (('bcsel', ('inot', a), b, c), ('bcsel', a, c, b)),
    (('bcsel', a, ('bcsel', a, b, c), d), ('bcsel', a, b, d)),
    (('bcsel', a, b, ('bcsel', a, c, d)), ('bcsel', a, b, d)),
@@ -1310,9 +1309,9 @@ optimizations.extend([
    (('fsin', a), lowered_sincos(0.5), 'options->lower_sincos'),
    (('fcos', a), lowered_sincos(0.75), 'options->lower_sincos'),
    # Boolean simplifications
-   (('i2b16(is_used_by_if)', a), ('ine16', a, 0)),
-   (('i2b32(is_used_by_if)', a), ('ine32', a, 0)),
-   (('i2b1(is_used_by_if)', a), ('ine', a, 0)),
+   (('i2b16', a), ('ine16', a, 0)),
+   (('i2b32', a), ('ine32', a, 0)),
+   (('i2b1', a), ('ine', a, 0)),
    (('ieq', a, True), a),
    (('ine(is_not_used_by_if)', a, True), ('inot', a)),
    (('ine', a, False), a),
@@ -1373,8 +1372,6 @@ optimizations.extend([
    # Conversions
    (('f2i', ('ftrunc', a)), ('f2i', a)),
    (('f2u', ('ftrunc', a)), ('f2u', a)),
-   (('i2b', ('ineg', a)), ('i2b', a)),
-   (('i2b', ('iabs', a)), ('i2b', a)),
    (('inot', ('f2b1', a)), ('feq', a, 0.0)),
 
    # Conversions from 16 bits to 32 bits and back can always be removed
@@ -1832,8 +1829,8 @@ optimizations.extend([
 
    (('ubfe', a, 0, '#b'), ('iand', a, ('ushr', 0xffffffff, ('ineg', b)))),
 
-   (('b2i32', ('i2b', ('ubfe', a, b, 1))), ('ubfe', a, b, 1)),
-   (('b2i32', ('i2b', ('ibfe', a, b, 1))), ('ubfe', a, b, 1)), # ubfe in the replacement is correct
+   (('b2i32', ('ine', ('ubfe', a, b, 1), 0)), ('ubfe', a, b, 1)),
+   (('b2i32', ('ine', ('ibfe', a, b, 1), 0)), ('ubfe', a, b, 1)), # ubfe in the replacement is correct
    (('ine', ('ibfe(is_used_once)', a, '#b', '#c'), 0), ('ine', ('iand', a, ('ishl', ('ushr', 0xffffffff, ('ineg', c)), b)), 0)),
    (('ieq', ('ibfe(is_used_once)', a, '#b', '#c'), 0), ('ieq', ('iand', a, ('ishl', ('ushr', 0xffffffff, ('ineg', c)), b)), 0)),
    (('ine', ('ubfe(is_used_once)', a, '#b', '#c'), 0), ('ine', ('iand', a, ('ishl', ('ushr', 0xffffffff, ('ineg', c)), b)), 0)),
@@ -2047,14 +2044,6 @@ for left, right in itertools.combinations_with_replacement(invert.keys(), 2):
    optimizations.append((('inot', ('iand(is_used_once)', (left, a, b), (right, c, d))),
                          ('ior', (invert[left], a, b), (invert[right], c, d))))
 
-# Optimize x2bN(b2x(x)) -> x
-for size in type_sizes('bool'):
-    aN = 'a@' + str(size)
-    f2bN = 'f2b' + str(size)
-    i2bN = 'i2b' + str(size)
-    optimizations.append(((f2bN, ('b2f', aN)), a))
-    optimizations.append(((i2bN, ('b2i', aN)), a))
-
 # Optimize x2yN(b2x(x)) -> b2y
 for x, y in itertools.product(['f', 'u', 'i'], ['f', 'u', 'i']):
    if x != 'f' and y != 'f' and x != y:
diff --git a/src/freedreno/ir3/ir3_compiler_nir.c b/src/freedreno/ir3/ir3_compiler_nir.c
index 0e4be1606866..b549ede73657 100644
--- a/src/freedreno/ir3/ir3_compiler_nir.c
+++ b/src/freedreno/ir3/ir3_compiler_nir.c
@@ -476,16 +476,6 @@ emit_alu(struct ir3_context *ctx, nir_alu_instr *alu)
       dst[0]->cat2.condition = IR3_COND_NE;
       break;
 
-   case nir_op_i2b1:
-      /* i2b1 will appear when translating from nir_load_ubo or
-       * nir_intrinsic_load_ssbo, where any non-zero value is true.
-       */
-      dst[0] = ir3_CMPS_S(
-         b, src[0], 0,
-         create_immed_typed(b, 0, type_uint_size(bs[0])), 0);
-      dst[0]->cat2.condition = IR3_COND_NE;
-      break;
-
    case nir_op_b2b1:
       /* b2b1 will appear when translating from
        *
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_nir.c b/src/gallium/auxiliary/gallivm/lp_bld_nir.c
index b261db35f1ce..2bc66e3baf82 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_nir.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_nir.c
@@ -206,21 +206,6 @@ static void assign_alu_dest(struct lp_build_nir_context *bld_base, const nir_alu
       assign_reg(bld_base, &dest->dest.reg, dest->write_mask, vals);
 }
 
-static LLVMValueRef int_to_bool32(struct lp_build_nir_context *bld_base,
-                                uint32_t src_bit_size,
-                                bool is_unsigned,
-                                LLVMValueRef val)
-{
-   LLVMBuilderRef builder = bld_base->base.gallivm->builder;
-   struct lp_build_context *int_bld = get_int_bld(bld_base, is_unsigned, src_bit_size);
-   LLVMValueRef result = lp_build_compare(bld_base->base.gallivm, int_bld->type, PIPE_FUNC_NOTEQUAL, val, int_bld->zero);
-   if (src_bit_size == 16)
-      result = LLVMBuildSExt(builder, result, bld_base->int_bld.vec_type, "");
-   else if (src_bit_size == 64)
-      result = LLVMBuildTrunc(builder, result, bld_base->int_bld.vec_type, "");
-   return result;
-}
-
 static LLVMValueRef flt_to_bool32(struct lp_build_nir_context *bld_base,
                                   uint32_t src_bit_size,
                                   LLVMValueRef val)
@@ -835,7 +820,7 @@ static LLVMValueRef do_alu_action(struct lp_build_nir_context *bld_base,
       result = lp_build_trunc(get_flt_bld(bld_base, src_bit_size[0]), src[0]);
       break;
    case nir_op_i2b32:
-      result = int_to_bool32(bld_base, src_bit_size[0], false, src[0]);
+      unreachable("Should have been lowered in opt_algebraic.");
       break;
    case nir_op_i2f16:
       result = LLVMBuildSIToFP(builder, src[0],
diff --git a/src/gallium/auxiliary/nir/nir_to_tgsi.c b/src/gallium/auxiliary/nir/nir_to_tgsi.c
index 390a532b5469..869ff8e51d62 100644
--- a/src/gallium/auxiliary/nir/nir_to_tgsi.c
+++ b/src/gallium/auxiliary/nir/nir_to_tgsi.c
@@ -1560,13 +1560,6 @@ ntt_emit_alu(struct ntt_compile *c, nir_alu_instr *instr)
             ntt_FSNE(c, dst, src[0], ureg_imm1f(c->ureg, 0));
          break;
 
-      case nir_op_i2b32:
-         if (src_64) {
-            ntt_U64SNE(c, dst, src[0], ureg_imm1u(c->ureg, 0));
-         } else
-            ntt_USNE(c, dst, src[0], ureg_imm1u(c->ureg, 0));
-         break;
-
       case nir_op_b2i32:
          ntt_AND(c, dst, src[0], ureg_imm1u(c->ureg, 1));
          break;
diff --git a/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt b/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt
index 02b65ed1fc82..d8c21b0ab480 100644
--- a/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt
+++ b/src/gallium/drivers/d3d12/ci/d3d12-quick_shader.txt
@@ -584,6 +584,7 @@ spec/arb_tessellation_shader/execution/variable-indexing/tcs-patch-output-array-
 spec/arb_tessellation_shader/execution/variable-indexing/tcs-patch-output-array-vec3-index-wr: crash
 spec/arb_tessellation_shader/execution/variable-indexing/tcs-patch-output-array-vec4-index-wr: crash
 spec/arb_tessellation_shader/execution/variable-indexing/tcs-patch-vec4-index-wr: crash
+spec/arb_tessellation_shader/execution/variable-indexing/tcs-patch-vec4-swiz-index-wr: crash
 spec/arb_tessellation_shader/execution/variable-indexing/tes-both-input-array-float-index-rd: crash
 spec/arb_tessellation_shader/execution/variable-indexing/tes-both-input-array-vec2-index-rd: crash
 spec/arb_tessellation_shader/execution/variable-indexing/tes-both-input-array-vec3-index-rd: crash
@@ -3083,9 +3084,9 @@ spec/oes_viewport_array/viewport-gs-writes-out-of-range: skip
 summary:
        name:  results
        ----  --------
-       pass:    17159
+       pass:    17158
        fail:       44
-      crash:       88
+      crash:       89
        skip:     2925
     timeout:        0
        warn:       25
diff --git a/src/gallium/drivers/etnaviv/etnaviv_compiler_nir_emit.c b/src/gallium/drivers/etnaviv/etnaviv_compiler_nir_emit.c
index dbbc9d5a0d12..4d25ca5fe1f2 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_compiler_nir_emit.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_compiler_nir_emit.c
@@ -83,7 +83,6 @@ static const struct etna_op_info etna_ops[] = {
    UOP(b2f32, AND, 0_X_X), /* AND with fui(1.0f) */
    UOP(b2i32, AND, 0_X_X), /* AND with 1 */
    OPC(f2b32, CMP, 0_X_X, NE), /* != 0.0 */
-   UOPC(i2b32, CMP, 0_X_X, NE), /* != 0 */
 
    /* arithmetic */
    IOP(iadd, ADD, 0_X_1),
@@ -168,7 +167,7 @@ etna_emit_alu(struct etna_compile *c, nir_op op, struct etna_inst_dst dst,
       inst.src[1] = etna_immediate_float(0.0f);
       break;
    case nir_op_i2b32:
-      inst.src[1] = etna_immediate_int(0);
+      unreachable("Should have been lowered in opt_algebraic.");
       break;
    case nir_op_ineg:
       inst.src[0] = etna_immediate_int(0);
diff --git a/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp b/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp
index 306822552baa..4d21aedc7f8b 100644
--- a/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_emitaluinstruction.cpp
@@ -158,8 +158,8 @@ bool EmitAluInstruction::do_emit(nir_instr* ir)
    case nir_op_fsqrt: return emit_alu_trans_op1(instr, op1_sqrt_ieee);
    case nir_op_fsub: return emit_alu_op2(instr, op2_add, op2_opt_neg_src1);
    case nir_op_ftrunc: return emit_alu_op1(instr, op1_trunc);
-   case nir_op_i2b1: return emit_alu_i2orf2_b1(instr, op2_setne_int);
-   case nir_op_i2b32: return emit_alu_i2orf2_b1(instr, op2_setne_int);
+   case nir_op_i2b1:
+   case nir_op_i2b32: unreachable("Should have been lowered in opt_algebraic.");
    case nir_op_i2f32: return emit_alu_trans_op1(instr, op1_int_to_flt);
    case nir_op_iadd: return emit_alu_op2_int(instr, op2_add_int);
    case nir_op_iand: return emit_alu_op2_int(instr, op2_and_int);
diff --git a/src/gallium/drivers/vc4/vc4_program.c b/src/gallium/drivers/vc4/vc4_program.c
index 86e7ba13722c..e79475a55dcc 100644
--- a/src/gallium/drivers/vc4/vc4_program.c
+++ b/src/gallium/drivers/vc4/vc4_program.c
@@ -1151,7 +1151,6 @@ ntq_emit_alu(struct vc4_compile *c, nir_alu_instr *instr)
         case nir_op_b2i32:
                 result = qir_AND(c, src[0], qir_uniform_ui(c, 1));
                 break;
-        case nir_op_i2b32:
         case nir_op_f2b32:
                 qir_SF(c, src[0]);
                 result = qir_MOV(c, qir_SEL(c, QPU_COND_ZC,
diff --git a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
index 94f38d658b9c..091ed73160ee 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
+++ b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
@@ -2106,13 +2106,6 @@ emit_alu(struct ntv_context *ctx, nir_alu_instr *alu)
                                             nir_src_bit_size(alu->src[0].src),
                                             num_components, 0));
       break;
-   case nir_op_i2b1:
-      assert(nir_op_infos[alu->op].num_inputs == 1);
-      result = emit_binop(ctx, SpvOpINotEqual, dest_type, src[0],
-                          get_ivec_constant(ctx,
-                                            nir_src_bit_size(alu->src[0].src),
-                                            num_components, 0));
-      break;
 
 
 #define BINOP(nir_op, spirv_op) \
diff --git a/src/gallium/drivers/zink/nir_to_spirv/zink_nir_algebraic.py b/src/gallium/drivers/zink/nir_to_spirv/zink_nir_algebraic.py
index af2419cf9d42..20ed4cfb5656 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/zink_nir_algebraic.py
+++ b/src/gallium/drivers/zink/nir_to_spirv/zink_nir_algebraic.py
@@ -25,7 +25,7 @@ import sys
 
 lower_b2b = [
    (('b2b32', 'a'), ('b2i32', 'a')),
-   (('b2b1', 'a'), ('i2b1', 'a')),
+   (('b2b1', 'a'), ('ine', 'a', 0)),
 ]
 
 def main():
diff --git a/src/intel/compiler/brw_fs_nir.cpp b/src/intel/compiler/brw_fs_nir.cpp
index 9864acbea6f4..7a381dcfe27c 100644
--- a/src/intel/compiler/brw_fs_nir.cpp
+++ b/src/intel/compiler/brw_fs_nir.cpp
@@ -1584,22 +1584,15 @@ fs_visitor::nir_emit_alu(const fs_builder &bld, nir_alu_instr *instr,
       break;
 
    case nir_op_i2b32:
+      unreachable("not reached: should be handled by opt_algebraic.");
    case nir_op_f2b32: {
       uint32_t bit_size = nir_src_bit_size(instr->src[0].src);
       if (bit_size == 64) {
          /* two-argument instructions can't take 64-bit immediates */
-         fs_reg zero;
-         fs_reg tmp;
+         fs_reg zero = vgrf(glsl_type::double_type);
+         fs_reg tmp = vgrf(glsl_type::double_type);
 
-         if (instr->op == nir_op_f2b32) {
-            zero = vgrf(glsl_type::double_type);
-            tmp = vgrf(glsl_type::double_type);
-            bld.MOV(zero, setup_imm_df(bld, 0.0));
-         } else {
-            zero = vgrf(glsl_type::int64_t_type);
-            tmp = vgrf(glsl_type::int64_t_type);
-            bld.MOV(zero, brw_imm_q(0));
-         }
+         bld.MOV(zero, setup_imm_df(bld, 0.0));
 
          /* A SIMD16 execution needs to be split in two instructions, so use
           * a vgrf instead of the flag register as dst so instruction splitting
@@ -1610,11 +1603,10 @@ fs_visitor::nir_emit_alu(const fs_builder &bld, nir_alu_instr *instr,
       } else {
          fs_reg zero;
          if (bit_size == 32) {
-            zero = instr->op == nir_op_f2b32 ? brw_imm_f(0.0f) : brw_imm_d(0);
+            zero = brw_imm_f(0.0f);
          } else {
             assert(bit_size == 16);
-            zero = instr->op == nir_op_f2b32 ?
-               retype(brw_imm_w(0), BRW_REGISTER_TYPE_HF) : brw_imm_w(0);
+            zero = retype(brw_imm_w(0), BRW_REGISTER_TYPE_HF);
          }
          bld.CMP(result, op[0], zero, BRW_CONDITIONAL_NZ);
       }
diff --git a/src/intel/compiler/brw_vec4_nir.cpp b/src/intel/compiler/brw_vec4_nir.cpp
index 71dede7348b9..08a1151d679c 100644
--- a/src/intel/compiler/brw_vec4_nir.cpp
+++ b/src/intel/compiler/brw_vec4_nir.cpp
@@ -1577,7 +1577,7 @@ vec4_visitor::nir_emit_alu(nir_alu_instr *instr)
       break;
 
    case nir_op_i2b32:
-      emit(CMP(dst, op[0], brw_imm_d(0), BRW_CONDITIONAL_NZ));
+      unreachable("not reached: should be handled by opt_algebraic.");
       break;
 
    case nir_op_unpack_half_2x16_split_x:
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index 27ff0e349cf8..ffaf1f7e79bf 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -511,6 +511,13 @@ st_glsl_to_nir_post_opts(struct st_context *st, struct gl_program *prog,
          }
          NIR_PASS(lowered_64bit_ops, nir, nir_lower_doubles,
                   st->ctx->SoftFP64, nir->options->lower_doubles_options);
+
+         /* Lowering doubles can rematerialize some instructions (e.g., b2i)
+          * that are expected to be lowered by now.  Calling opt_algbraic
+          * removes them.
+          */
+         if (lowered_64bit_ops)
+            NIR_PASS_V(nir, nir_opt_algebraic);
       }
       if (nir->options->lower_int64_options)
          NIR_PASS(lowered_64bit_ops, nir, nir_lower_int64);
diff --git a/src/microsoft/compiler/dxil_nir_algebraic.py b/src/microsoft/compiler/dxil_nir_algebraic.py
index df824b338fd8..c5f216c54e91 100644
--- a/src/microsoft/compiler/dxil_nir_algebraic.py
+++ b/src/microsoft/compiler/dxil_nir_algebraic.py
@@ -93,8 +93,7 @@ remove_unsupported_casts(no_16bit_conv, 16, 0xffff, 65535.0, -32768.0, 32767.0)
 
 lower_x2b = [
   (('b2b32', 'a'), ('b2i32', 'a')),
-  (('b2b1', 'a'), ('i2b1', 'a')),
-  (('i2b1', 'a'), ('ine', a, 0)),
+  (('b2b1', 'a'), ('ine', ('b2i32', a), 0)),
   (('f2b1', 'a'), ('fneu', a, 0)),
 ]
 
diff --git a/src/nouveau/codegen/nv50_ir_from_nir.cpp b/src/nouveau/codegen/nv50_ir_from_nir.cpp
index 9f2f791ace42..e87b7ecb171e 100644
--- a/src/nouveau/codegen/nv50_ir_from_nir.cpp
+++ b/src/nouveau/codegen/nv50_ir_from_nir.cpp
@@ -2863,18 +2863,10 @@ Converter::visit(nir_alu_instr *insn)
       mkOp2(OP_MERGE, TYPE_U64, newDefs[0], loadImm(NULL, 0), tmp);
       break;
    }
-   case nir_op_f2b32:
-   case nir_op_i2b32: {
+   case nir_op_f2b32: {
       DEFAULT_CHECKS;
       LValues &newDefs = convert(&insn->dest);
-      Value *src1;
-      if (typeSizeof(sTypes[0]) == 8) {
-         src1 = loadImm(getSSA(8), 0.0);
-      } else {
-         src1 = zero;
-      }
-      CondCode cc = op == nir_op_f2b32 ? CC_NEU : CC_NE;
-      mkCmp(OP_SET, cc, TYPE_U32, newDefs[0], sTypes[0], getSrc(&insn->src[0]), src1);
+      mkCmp(OP_SET, CC_NEU, TYPE_U32, newDefs[0], sTypes[0], getSrc(&insn->src[0]), zero);
       break;
    }
    case nir_op_b2i32: {
diff --git a/src/panfrost/bifrost/bifrost_compile.c b/src/panfrost/bifrost/bifrost_compile.c
index 5852c7acf485..7f38fcbbea70 100644
--- a/src/panfrost/bifrost/bifrost_compile.c
+++ b/src/panfrost/bifrost/bifrost_compile.c
@@ -2837,16 +2837,6 @@ bi_emit_alu(bi_builder *b, nir_alu_instr *instr)
                 bi_mux_i32_to(b, dst, bi_imm_u32(0), bi_imm_u32(~0), s0, BI_MUX_FP_ZERO);
                 break;
 
-        case nir_op_i2b8:
-                bi_mux_v4i8_to(b, dst, bi_imm_u8(0), bi_imm_u8(~0), s0, BI_MUX_INT_ZERO);
-                break;
-        case nir_op_i2b16:
-                bi_mux_v2i16_to(b, dst, bi_imm_u16(0), bi_imm_u16(~0), s0, BI_MUX_INT_ZERO);
-                break;
-        case nir_op_i2b32:
-                bi_mux_i32_to(b, dst, bi_imm_u32(0), bi_imm_u32(~0), s0, BI_MUX_INT_ZERO);
-                break;
-
         case nir_op_ieq8:
         case nir_op_ine8:
         case nir_op_ilt8:
-- 
GitLab

